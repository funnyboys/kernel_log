commit b417107a659e9745f9ff905196ddff70cbe4eaa7
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Feb 12 18:02:11 2020 -0600

    scsi: advansys: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language extension
    to the C90 standard, but the preferred mechanism to declare variable-length
    types such as these ones is a flexible array member[1][2], introduced in
    C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by this
    change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Link: https://lore.kernel.org/r/20200213000211.GA23171@embeddedor.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index a242a62caaa1..c2c7850ff7b4 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -316,7 +316,7 @@ typedef struct asc_sg_head {
 	ushort queue_cnt;
 	ushort entry_to_copy;
 	ushort res;
-	ASC_SG_LIST sg_list[0];
+	ASC_SG_LIST sg_list[];
 } ASC_SG_HEAD;
 
 typedef struct asc_scsi_q {

commit 1f7563f743d7081710a9d186a8b203997d09f383
Merge: ba6d10ab8014 3e99b3b13a1f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 15:17:41 2019 -0700

    Merge tag 'scsi-sg' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI scatter-gather list updates from James Bottomley:
     "This topic branch covers a fundamental change in how our sg lists are
      allocated to make mq more efficient by reducing the size of the
      preallocated sg list.
    
      This necessitates a large number of driver changes because the
      previous guarantee that if a driver specified SG_ALL as the size of
      its scatter list, it would get a non-chained list and didn't need to
      bother with scatterlist iterators is now broken and every driver
      *must* use scatterlist iterators.
    
      This was broken out as a separate topic because we need to convert all
      the drivers before pulling the trigger and unconverted drivers kept
      being found, necessitating a rebase"
    
    * tag 'scsi-sg' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (21 commits)
      scsi: core: don't preallocate small SGL in case of NO_SG_CHAIN
      scsi: lib/sg_pool.c: clear 'first_chunk' in case of no preallocation
      scsi: core: avoid preallocating big SGL for data
      scsi: core: avoid preallocating big SGL for protection information
      scsi: lib/sg_pool.c: improve APIs for allocating sg pool
      scsi: esp: use sg helper to iterate over scatterlist
      scsi: NCR5380: use sg helper to iterate over scatterlist
      scsi: wd33c93: use sg helper to iterate over scatterlist
      scsi: ppa: use sg helper to iterate over scatterlist
      scsi: pcmcia: nsp_cs: use sg helper to iterate over scatterlist
      scsi: imm: use sg helper to iterate over scatterlist
      scsi: aha152x: use sg helper to iterate over scatterlist
      scsi: s390: zfcp_fc: use sg helper to iterate over scatterlist
      scsi: staging: unisys: visorhba: use sg helper to iterate over scatterlist
      scsi: usb: image: microtek: use sg helper to iterate over scatterlist
      scsi: pmcraid: use sg helper to iterate over scatterlist
      scsi: ipr: use sg helper to iterate over scatterlist
      scsi: mvumi: use sg helper to iterate over scatterlist
      scsi: lpfc: use sg helper to iterate over scatterlist
      scsi: advansys: use sg helper to iterate over scatterlist
      ...

commit c0d0d81ad34a41e2aa562bc59f22bed3e9e98080
Author: Ming Lei <ming.lei@redhat.com>
Date:   Tue Jun 18 09:37:43 2019 +0800

    scsi: advansys: use sg helper to iterate over scatterlist
    
    Unlike the legacy I/O path, scsi-mq preallocates a large array to hold
    the scatterlist for each request. This static allocation can consume
    substantial amounts of memory on modern controllers which support a
    large number of concurrently outstanding requests.
    
    To facilitate a switch to a smaller static allocation combined with a
    dynamic allocation for requests that need it, we need to make sure all
    SCSI drivers handle chained scatterlists correctly.
    
    Convert remaining drivers that directly dereference the scatterlist
    array to using the iterator functions.
    
    [mkp: clarified commit message]
    
    Reviewed-by: Ewan D. Milne <emilne@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d37584403c33..b87de8d3d844 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7714,7 +7714,7 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
 				sg_block->sg_ptr = 0L; /* Last ADV_SG_BLOCK in list. */
 				return ADV_SUCCESS;
 			}
-			slp++;
+			slp = sg_next(slp);
 		}
 		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
 		prev_sg_block = sg_block;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d37584403c33..926311c792d5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters
  *
@@ -6,11 +7,6 @@
  * Copyright (c) 2007 Matthew Wilcox <matthew@wil.cx>
  * Copyright (c) 2014 Hannes Reinecke <hare@suse.de>
  * All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 /*

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 95b4793c33f4..d37584403c33 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3192,8 +3192,8 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 		   shost->sg_tablesize, shost->cmd_per_lun);
 
 	seq_printf(m,
-		   " unchecked_isa_dma %d, use_clustering %d\n",
-		   shost->unchecked_isa_dma, shost->use_clustering);
+		   " unchecked_isa_dma %d\n",
+		   shost->unchecked_isa_dma);
 
 	seq_printf(m,
 		   " flags 0x%x, last_reset 0x%lx, jiffies 0x%lx, asc_n_io_port 0x%x\n",

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 223ef6f4e258..95b4793c33f4 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -10808,14 +10808,6 @@ static struct scsi_host_template advansys_template = {
 	 * for non-ISA adapters.
 	 */
 	.unchecked_isa_dma = true,
-	/*
-	 * All adapters controlled by this driver are capable of large
-	 * scatter-gather lists. According to the mid-level SCSI documentation
-	 * this obviates any performance gain provided by setting
-	 * 'use_clustering'. But empirically while CPU utilization is increased
-	 * by enabling clustering, I/O throughput increases as well.
-	 */
-	.use_clustering = ENABLE_CLUSTERING,
 };
 
 static int advansys_wide_init_chip(struct Scsi_Host *shost)

commit e6760cc43e689ea29dce046c9fa1b10982e6b2b5
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Oct 17 20:34:32 2018 +0800

    scsi: advansys: remove unused variable 'srb_tag' in adv_isr_callback
    
    drivers/scsi/advansys.c: In function 'adv_isr_callback':
    drivers/scsi/advansys.c:5952:6: warning:
     variable 'srb_tag' set but not used [-Wunused-but-set-variable]
    
    It never used since introduction in
    commit 9c17c62aedb0 ("advansys: use shared host tag map for command lookup")
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 44c96199e00a..223ef6f4e258 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -5949,7 +5949,6 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
 static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 {
 	struct asc_board *boardp = adv_dvc_varp->drv_ptr;
-	u32 srb_tag;
 	adv_req_t *reqp;
 	adv_sgblk_t *sgblkp;
 	struct scsi_cmnd *scp;
@@ -5965,7 +5964,6 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	 * completed. The adv_req_t structure actually contains the
 	 * completed ADV_SCSI_REQ_Q structure.
 	 */
-	srb_tag = le32_to_cpu(scsiqp->srb_tag);
 	scp = scsi_host_find_tag(boardp->shost, scsiqp->srb_tag);
 
 	ASC_DBG(1, "scp 0x%p\n", scp);

commit 874deb1c652df94917f5619d972d2435a762b8a0
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Sep 20 13:58:58 2018 -0700

    scsi: advansys: Remove unnecessary parentheses
    
    Clang warns when multiple pairs of parentheses are used for a single
    conditional statement.
    
    drivers/scsi/advansys.c:6451:20: warning: equality comparison with
    extraneous parentheses [-Wparentheses-equality]
                                    if ((sdtr_data == 0xFF)) {
                                         ~~~~~~~~~~^~~~~~~
    drivers/scsi/advansys.c:6451:20: note: remove extraneous parentheses
    around the comparison to silence this warning
                                    if ((sdtr_data == 0xFF)) {
                                        ~          ^      ~
    drivers/scsi/advansys.c:6451:20: note: use '=' to turn this equality
    comparison into an assignment
                                    if ((sdtr_data == 0xFF)) {
                                                   ^~
                                                   =
    1 warning generated.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/155
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Matthew Wilcox <willy@infradead.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 713f69033f20..44c96199e00a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -6448,7 +6448,7 @@ static void AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 				sdtr_data =
 				    AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
 						   ext_msg.req_ack_offset);
-				if ((sdtr_data == 0xFF)) {
+				if (sdtr_data == 0xFF) {
 
 					q_cntl |= QC_MSG_OUT;
 					asc_dvc->init_sdtr &= ~target_id;

commit c84b023a4c1461498abf0eda54f60e2fd64a1ca2
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jun 24 22:03:26 2018 +0800

    scsi: read host_busy via scsi_host_busy()
    
    No functional change.
    
    Just introduce scsi_host_busy() and replace the direct read of
    scsi_host->host_busy with this new API.
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index c9a52905070e..713f69033f20 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2416,8 +2416,8 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 	struct asc_board *boardp = shost_priv(s);
 
 	printk("Scsi_Host at addr 0x%p, device %s\n", s, dev_name(boardp->dev));
-	printk(" host_busy %u, host_no %d,\n",
-	       atomic_read(&s->host_busy), s->host_no);
+	printk(" host_busy %d, host_no %d,\n",
+	       scsi_host_busy(s), s->host_no);
 
 	printk(" base 0x%lx, io_port 0x%lx, irq %d,\n",
 	       (ulong)s->base, (ulong)s->io_port, boardp->irq);
@@ -3182,8 +3182,8 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 		shost->host_no);
 
 	seq_printf(m,
-		   " host_busy %u, max_id %u, max_lun %llu, max_channel %u\n",
-		   atomic_read(&shost->host_busy), shost->max_id,
+		   " host_busy %d, max_id %u, max_lun %llu, max_channel %u\n",
+		   scsi_host_busy(shost), shost->max_id,
 		   shost->max_lun, shost->max_channel);
 
 	seq_printf(m,

commit 91ebc1facd7797d799a4c9208cb7fdc8d86e0bb4
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jun 13 09:53:47 2018 +0200

    scsi: core: remove Scsi_Cmnd typedef
    
    This will make subsequent refactoring easier to handle.
    
    Note: this patch is nowhere checkpatch clean.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 24e57e770432..c9a52905070e 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -8466,7 +8466,7 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, adv_req_t *reqp)
 }
 
 /*
- * Execute a single 'Scsi_Cmnd'.
+ * Execute a single 'struct scsi_cmnd'.
  */
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 {

commit 44a5b977128c0ffff0654392b40f4c2ce72a619b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 23 16:02:18 2017 +0100

    scsi: advansys: fix uninitialized data access
    
    gcc-7.0.1 now warns about a previously unnoticed access of uninitialized
    struct members:
    
    drivers/scsi/advansys.c: In function 'AscMsgOutSDTR':
    drivers/scsi/advansys.c:3860:26: error: '*((void *)&sdtr_buf+5)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
             ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);
                              ^
    drivers/scsi/advansys.c:3860:26: error: '*((void *)&sdtr_buf+7)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/scsi/advansys.c:3860:26: error: '*((void *)&sdtr_buf+5)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/scsi/advansys.c:3860:26: error: '*((void *)&sdtr_buf+7)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    
    The code has existed in this exact form at least since v2.6.12, and the
    warning seems correct. This uses named initializers to ensure we
    initialize all members of the structure.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 81dd0927246b..24e57e770432 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -6291,18 +6291,17 @@ static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)
 static uchar
 AscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)
 {
-	EXT_MSG sdtr_buf;
-	uchar sdtr_period_index;
-	PortAddr iop_base;
-
-	iop_base = asc_dvc->iop_base;
-	sdtr_buf.msg_type = EXTENDED_MESSAGE;
-	sdtr_buf.msg_len = MS_SDTR_LEN;
-	sdtr_buf.msg_req = EXTENDED_SDTR;
-	sdtr_buf.xfer_period = sdtr_period;
+	PortAddr iop_base = asc_dvc->iop_base;
+	uchar sdtr_period_index = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
+	EXT_MSG sdtr_buf = {
+		.msg_type = EXTENDED_MESSAGE,
+		.msg_len = MS_SDTR_LEN,
+		.msg_req = EXTENDED_SDTR,
+		.xfer_period = sdtr_period,
+		.req_ack_offset = sdtr_offset,
+	};
 	sdtr_offset &= ASC_SYN_MAX_OFFSET;
-	sdtr_buf.req_ack_offset = sdtr_offset;
-	sdtr_period_index = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
+
 	if (sdtr_period_index <= asc_dvc->max_sdtr_index) {
 		AscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,
 					(uchar *)&sdtr_buf,

commit f46e7cd36b5f2ce2bfb567e278a10ca717f85b84
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 24 17:51:55 2016 +0200

    scsi: advansys: fix build warning for PCI=n
    
    The advansys probe function tries to handle both ISA and PCI cases, each
    hidden in an #ifdef when unused. This leads to a warning indicating that
    when PCI is disabled we could be using uninitialized data:
    
    drivers/scsi/advansys.c: In function  advansys_board_found :
    drivers/scsi/advansys.c:11036:5: error:  ret  may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/scsi/advansys.c:10928:28: note:  ret  was declared here
    drivers/scsi/advansys.c:11309:8: error:  share_irq  may be used uninitialized in this function [-Werror=maybe-uninitialized]
    drivers/scsi/advansys.c:10928:6: note:  share_irq  was declared here
    
    This cannot happen in practice because the hardware in question only
    exists for PCI, but changing the code to just error out here is better
    for consistency and avoids the warning.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index febbd83e2ecd..81dd0927246b 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -11030,6 +11030,9 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		ASC_DBG(2, "AdvInitGetConfig()\n");
 
 		ret = AdvInitGetConfig(pdev, shost) ? -ENODEV : 0;
+#else
+		share_irq = 0;
+		ret = -ENODEV;
 #endif /* CONFIG_PCI */
 	}
 

commit be9e2f775f5a3147205c552534c3abf0f9374a13
Merge: e619e6cbecb7 3ddda3e4c82d
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Dec 3 09:32:33 2015 -0800

    Merge branch 'mkp-fixes' into fixes

commit 757b22f9d56fb4e510782b29da752824daddf3c8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 16 17:49:23 2015 +0100

    advansys: fix big-endian builds
    
    Building the advansys driver in a big-endian configuration such as
    ARM allmodconfig shows a warning:
    
     drivers/scsi/advansys.c: In function 'adv_build_req':
     include/uapi/linux/byteorder/big_endian.h:32:26: warning: large integer implicitly truncated to unsigned type [-Woverflow]
      #define __cpu_to_le32(x) ((__force __le32)__swab32((x)))
     drivers/scsi/advansys.c:7806:22: note: in expansion of macro 'cpu_to_le32'
       scsiqp->sense_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);
    
    It turns out that the commit that introduced this used the cpu_to_le32()
    incorrectly on an 8-bit field, which results in the sense_len to always
    be set to zero, as the SCSI_SENSE_BUFFERSIZE value gets moved to upper
    byte of the 32-bit intermediate.
    
    This removes the cpu_to_le32() call to restore the original version.
    
    I found this only by looking at the compiler output and have not done a
    full review for possible further endianess bugs in the same driver.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 811ddc057aac ("advansys: use DMA-API for mapping sense buffer")
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Cc: stable@vger.kernel.org # v4.2+
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 4305178e4e01..1c1cd657c380 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7803,7 +7803,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 		return ASC_BUSY;
 	}
 	scsiqp->sense_addr = cpu_to_le32(sense_addr);
-	scsiqp->sense_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);
+	scsiqp->sense_len = SCSI_SENSE_BUFFERSIZE;
 
 	/* Build ADV_SCSI_REQ_Q */
 

commit 64d513ac31bd02a3c9b69ef04444f36c196f9a9d
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 8 09:28:04 2015 +0100

    scsi: use host wide tags by default
    
    This patch changes the !blk-mq path to the same defaults as the blk-mq
    I/O path by always enabling block tagging, and always using host wide
    tags.  We've had blk-mq available for a few releases so bugs with
    this mode should have been ironed out, and this ensures we get better
    coverage of over tagging setup over different configs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 4305178e4e01..519f9a4b3dad 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -10819,7 +10819,6 @@ static struct scsi_host_template advansys_template = {
 	 * by enabling clustering, I/O throughput increases as well.
 	 */
 	.use_clustering = ENABLE_CLUSTERING,
-	.use_blk_tags = 1,
 };
 
 static int advansys_wide_init_chip(struct Scsi_Host *shost)
@@ -11211,11 +11210,6 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		/* Set maximum number of queues the adapter can handle. */
 		shost->can_queue = adv_dvc_varp->max_host_qng;
 	}
-	ret = scsi_init_shared_tag_map(shost, shost->can_queue);
-	if (ret) {
-		shost_printk(KERN_ERR, shost, "init tag map failed\n");
-		goto err_free_dma;
-	}
 
 	/*
 	 * Set the maximum number of scatter-gather elements the

commit 8810eac83624ab1ad593c59da43e187179f5941e
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jun 3 09:56:42 2015 +0200

    advansys: fix compilation errors and warnings when CONFIG_PCI is not set
    
    Fix compilation errors on forgotten #include <linux/dmapool.h> and warnings when
    CONFIG_PCI is not set.
    
    Reported-by: Jim Davis <jim.epost@gmail.com>
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 14d3aa54daa5..4305178e4e01 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -37,6 +37,7 @@
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
 #include <linux/firmware.h>
+#include <linux/dmapool.h>
 
 #include <asm/io.h>
 #include <asm/dma.h>
@@ -9435,6 +9436,7 @@ static int AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
  * on big-endian platforms so char fields read as words are actually being
  * unswapped on big-endian platforms.
  */
+#ifdef CONFIG_PCI
 static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config = {
 	ADV_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
 	0x0000,			/* cfg_msw */
@@ -9771,7 +9773,6 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar = {
 	0			/* 63 reserved */
 };
 
-#ifdef CONFIG_PCI
 /*
  * Wait for EEPROM command to complete
  */
@@ -11385,7 +11386,9 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
  err_unmap:
 	if (boardp->ioremap_addr)
 		iounmap(boardp->ioremap_addr);
+#ifdef CONFIG_PCI
  err_shost:
+#endif
 	return ret;
 }
 

commit 6571fb3f8b7f7e9595174e01b7e7f1b1ba0427d4
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:42 2015 +0200

    advansys: Update to version 3.5 and remove compilation warning
    
    The driver has now been converted to DMA-API, so we should
    increase the version number and remove the compilation
    warning.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e1ce1b70c973..14d3aa54daa5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1,12 +1,10 @@
-#define DRV_NAME "advansys"
-#define ASC_VERSION "3.4"	/* AdvanSys Driver Version */
-
 /*
  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters
  *
  * Copyright (c) 1995-2000 Advanced System Products, Inc.
  * Copyright (c) 2000-2001 ConnectCom Solutions, Inc.
  * Copyright (c) 2007 Matthew Wilcox <matthew@wil.cx>
+ * Copyright (c) 2014 Hannes Reinecke <hare@suse.de>
  * All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -49,26 +47,15 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
 
+#define DRV_NAME "advansys"
+#define ASC_VERSION "3.5"	/* AdvanSys Driver Version */
+
 /* FIXME:
  *
- *  1. Although all of the necessary command mapping places have the
- *     appropriate dma_map.. APIs, the driver still processes its internal
- *     queue using bus_to_virt() and virt_to_bus() which are illegal under
- *     the API.  The entire queue processing structure will need to be
- *     altered to fix this.
- *  2. Need to add memory mapping workaround. Test the memory mapping.
- *     If it doesn't work revert to I/O port access. Can a test be done
- *     safely?
- *  3. Handle an interrupt not working. Keep an interrupt counter in
- *     the interrupt handler. In the timeout function if the interrupt
- *     has not occurred then print a message and run in polled mode.
- *  4. Need to add support for target mode commands, cf. CAM XPT.
- *  5. check DMA mapping functions for failure
- *  6. Use scsi_transport_spi
- *  7. advansys_info is not safe against multiple simultaneous callers
- *  8. Add module_param to override ISA/VLB ioport array
+ *  1. Use scsi_transport_spi
+ *  2. advansys_info is not safe against multiple simultaneous callers
+ *  3. Add module_param to override ISA/VLB ioport array
  */
-#warning this driver is still not properly converted to the DMA API
 
 /* Enable driver /proc statistics. */
 #define ADVANSYS_STATS

commit bc31ec4df58d0ba0de9dae6f651bc9bfa1c2f19a
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:41 2015 +0200

    advansys: Remove call to dma_cache_sync()
    
    Only required if the dma buffer has been allocated via
    dma_alloc_noncoherent(), which this one is not.
    With that call removed we can now also compile on ARM.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 5ece3178195d..e1ce1b70c973 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7510,17 +7510,17 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
-static __le32 advansys_get_sense_buffer_dma(struct scsi_cmnd *scp)
+static __le32 asc_get_sense_buffer_dma(struct scsi_cmnd *scp)
 {
 	struct asc_board *board = shost_priv(scp->device->host);
+
 	scp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,
-					     SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
+					     SCSI_SENSE_BUFFERSIZE,
+					     DMA_FROM_DEVICE);
 	if (dma_mapping_error(board->dev, scp->SCp.dma_handle)) {
 		ASC_DBG(1, "failed to map sense buffer\n");
 		return 0;
 	}
-	dma_cache_sync(board->dev, scp->sense_buffer,
-		       SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
 	return cpu_to_le32(scp->SCp.dma_handle);
 }
 
@@ -7549,7 +7549,7 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	asc_scsi_q->q1.target_lun = scp->device->lun;
 	asc_scsi_q->q2.target_ix =
 	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
-	asc_scsi_q->q1.sense_addr = advansys_get_sense_buffer_dma(scp);
+	asc_scsi_q->q1.sense_addr = asc_get_sense_buffer_dma(scp);
 	asc_scsi_q->q1.sense_len = SCSI_SENSE_BUFFERSIZE;
 	if (!asc_scsi_q->q1.sense_addr)
 		return ASC_BUSY;

commit 00742c91648cee6f5209b3a18e8b6d21e3b4f0e7
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:40 2015 +0200

    advansys: use spin_lock_irqsave() in interrupt handler
    
    We should be using spin_lock_irqsave() when within the
    interrupt handler.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 15bb8d050457..5ece3178195d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7242,9 +7242,10 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	struct Scsi_Host *shost = dev_id;
 	struct asc_board *boardp = shost_priv(shost);
 	irqreturn_t result = IRQ_NONE;
+	unsigned long flags;
 
 	ASC_DBG(2, "boardp 0x%p\n", boardp);
-	spin_lock(shost->host_lock);
+	spin_lock_irqsave(shost->host_lock, flags);
 	if (ASC_NARROW_BOARD(boardp)) {
 		if (AscIsIntPending(shost->io_port)) {
 			result = IRQ_HANDLED;
@@ -7259,7 +7260,7 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 			ASC_STATS(shost, interrupt);
 		}
 	}
-	spin_unlock(shost->host_lock);
+	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	ASC_DBG(1, "end\n");
 	return result;

commit 2207063443739e934184076cbb23db8973d6b2d4
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:39 2015 +0200

    advansys: Check for DMA mapping errors
    
    DMA mapping might fail, so we need to check for errors here.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 3408f1409444..15bb8d050457 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7514,6 +7514,10 @@ static __le32 advansys_get_sense_buffer_dma(struct scsi_cmnd *scp)
 	struct asc_board *board = shost_priv(scp->device->host);
 	scp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,
 					     SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
+	if (dma_mapping_error(board->dev, scp->SCp.dma_handle)) {
+		ASC_DBG(1, "failed to map sense buffer\n");
+		return 0;
+	}
 	dma_cache_sync(board->dev, scp->sense_buffer,
 		       SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
 	return cpu_to_le32(scp->SCp.dma_handle);
@@ -7546,6 +7550,8 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
 	asc_scsi_q->q1.sense_addr = advansys_get_sense_buffer_dma(scp);
 	asc_scsi_q->q1.sense_len = SCSI_SENSE_BUFFERSIZE;
+	if (!asc_scsi_q->q1.sense_addr)
+		return ASC_BUSY;
 
 	/*
 	 * If there are any outstanding requests for the current target,
@@ -7567,7 +7573,10 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 
 	/* Build ASC_SCSI_Q */
 	use_sg = scsi_dma_map(scp);
-	if (use_sg != 0) {
+	if (use_sg < 0) {
+		ASC_DBG(1, "failed to map sglist\n");
+		return ASC_BUSY;
+	} else if (use_sg > 0) {
 		int sgcnt;
 		struct scatterlist *slp;
 		struct asc_sg_head *asc_sg_head;
@@ -7799,13 +7808,22 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 
 	sense_addr = dma_map_single(boardp->dev, scp->sense_buffer,
 				    SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
+	if (dma_mapping_error(boardp->dev, sense_addr)) {
+		ASC_DBG(1, "failed to map sense buffer\n");
+		ASC_STATS(scp->device->host, adv_build_noreq);
+		return ASC_BUSY;
+	}
 	scsiqp->sense_addr = cpu_to_le32(sense_addr);
 	scsiqp->sense_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);
 
 	/* Build ADV_SCSI_REQ_Q */
 
 	use_sg = scsi_dma_map(scp);
-	if (use_sg == 0) {
+	if (use_sg < 0) {
+		ASC_DBG(1, "failed to map SG list\n");
+		ASC_STATS(scp->device->host, adv_build_noreq);
+		return ASC_BUSY;
+	} else if (use_sg == 0) {
 		/* Zero-length transfer */
 		reqp->sgblkp = NULL;
 		scsiqp->data_cnt = 0;
@@ -8473,11 +8491,10 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 		struct asc_scsi_q asc_scsi_q;
 
-		/* asc_build_req() can not return ASC_BUSY. */
 		ret = asc_build_req(boardp, scp, &asc_scsi_q);
-		if (ret == ASC_ERROR) {
+		if (ret != ASC_NOERROR) {
 			ASC_STATS(scp->device->host, build_error);
-			return ASC_ERROR;
+			return ret;
 		}
 
 		ret = AscExeScsiQueue(asc_dvc, &asc_scsi_q);

commit e14f66e921df944ce4c06b7e6ea8f057a32b6b3a
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:38 2015 +0200

    advansys: Remove cmd_per_lun setting
    
    Ancient, and pretty much obsolete by now.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 474393e1ad5a..3408f1409444 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -11211,24 +11211,6 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		goto err_free_dma;
 	}
 
-	/*
-	 * Following v1.3.89, 'cmd_per_lun' is no longer needed
-	 * and should be set to zero.
-	 *
-	 * But because of a bug introduced in v1.3.89 if the driver is
-	 * compiled as a module and 'cmd_per_lun' is zero, the Mid-Level
-	 * SCSI function 'allocate_device' will panic. To allow the driver
-	 * to work as a module in these kernels set 'cmd_per_lun' to 1.
-	 *
-	 * Note: This is wrong.  cmd_per_lun should be set to the depth
-	 * you want on untagged devices always.
-	 #ifdef MODULE
-	 */
-	shost->cmd_per_lun = 1;
-/* #else
-            shost->cmd_per_lun = 0;
-#endif */
-
 	/*
 	 * Set the maximum number of scatter-gather elements the
 	 * adapter can handle.

commit 3754fc642ce1e38a4af4d2d181f5967228c68682
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:37 2015 +0200

    advansys: Remove obsolete virtual memory mapping comment
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 05c5eb0f8905..474393e1ad5a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -884,16 +884,6 @@ typedef struct asc_mc_saved {
 #define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)
 #define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)
 
-/*
- * These macros are used to convert a virtual address to a
- * 32-bit value. This currently can be used on Linux Alpha
- * which uses 64-bit virtual address but a 32-bit bus address.
- * This is likely to break in the future, but doing this now
- * will give us time to change the HW and FW to handle 64-bit
- * addresses.
- */
-#define ADV_U32_TO_VADDR   bus_to_virt
-
 #define AdvPortAddr  void __iomem *	/* Virtual memory address size */
 
 /*

commit d9748dbcb1f9b489f4020d42982f620e56dc1327
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:36 2015 +0200

    advansys: Remove 'a_flag'
    
    Unused, so remove it.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 1f3078d3172f..05c5eb0f8905 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1717,16 +1717,6 @@ typedef struct adv_carr_t {
 #define ADV_CARRIER_BUFSIZE \
 	(ADV_CARRIER_COUNT * sizeof(ADV_CARR_T))
 
-/*
- * ADV_SCSI_REQ_Q 'a_flag' definitions
- *
- * The Adv Library should limit use to the lower nibble (4 bits) of
- * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.
- */
-#define ADV_POLL_REQUEST                0x01	/* poll for request completion */
-#define ADV_SCSIQ_DONE                  0x02	/* request done */
-#define ADV_DONT_RETRY                  0x08	/* don't do retry */
-
 #define ADV_CHIP_ASC3550          0x01	/* Ultra-Wide IC */
 #define ADV_CHIP_ASC38C0800       0x02	/* Ultra2-Wide/LVD IC */
 #define ADV_CHIP_ASC38C1600       0x03	/* Ultra3-Wide/LVD2 IC */
@@ -1808,8 +1798,6 @@ typedef struct adv_scsi_req_q {
 	 * is used by the Adv Library and ignored by the microcode.
 	 */
 	u32 srb_tag;
-	uchar a_flag;
-	uchar pad[3];		/* Pad out to a word boundary. */
 	ADV_SG_BLOCK *sg_list_ptr;	/* SG list virtual address. */
 } ADV_SCSI_REQ_Q;
 
@@ -2592,15 +2580,15 @@ static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
 
 	printk(" ADV_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
 	       (ulong)b, sgblockno);
-	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
-	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
+	printk("  sg_cnt %u, sg_ptr 0x%x\n",
+	       b->sg_cnt, (u32)le32_to_cpu(b->sg_ptr));
 	BUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);
 	if (b->sg_ptr != 0)
 		BUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);
 	for (i = 0; i < b->sg_cnt; i++) {
-		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
-		       i, (ulong)b->sg_list[i].sg_addr,
-		       (ulong)b->sg_list[i].sg_count);
+		printk("  [%u]: sg_addr 0x%x, sg_count 0x%x\n",
+		       i, (u32)le32_to_cpu(b->sg_list[i].sg_addr),
+		       (u32)le32_to_cpu(b->sg_list[i].sg_count));
 	}
 }
 
@@ -2617,8 +2605,8 @@ static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 
 	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
 
-	printk("  target_id %u, target_lun %u, srb_tag 0x%x, a_flag 0x%x\n",
-	       q->target_id, q->target_lun, q->srb_tag, q->a_flag);
+	printk("  target_id %u, target_lun %u, srb_tag 0x%x\n",
+	       q->target_id, q->target_lun, q->srb_tag);
 
 	printk("  cntl 0x%x, data_addr 0x%lx\n",
 	       q->cntl, (ulong)le32_to_cpu(q->data_addr));
@@ -6249,7 +6237,6 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * Notify the driver of the completed request by passing
 		 * the ADV_SCSI_REQ_Q pointer to its callback function.
 		 */
-		scsiq->a_flag |= ADV_SCSIQ_DONE;
 		adv_isr_callback(asc_dvc, scsiq);
 		/*
 		 * Note: After the driver callback function is called, 'scsiq'
@@ -8429,11 +8416,6 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, adv_req_t *reqp)
 
 	asc_dvc->carr_pending_cnt++;
 
-	/*
-	 * Clear the ADV_SCSI_REQ_Q done flag.
-	 */
-	scsiq->a_flag &= ~ADV_SCSIQ_DONE;
-
 	/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
 	scsiq->scsiq_ptr = cpu_to_le32(scsiq->srb_tag);
 	scsiq->scsiq_rptr = cpu_to_le32(reqp->req_addr);

commit 084e6c3639491b17fe0faee1398edf7aa93867d5
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:35 2015 +0200

    advansys: rename 'ASC_RQ_XX' to 'ADV_RQ_XX'
    
    These definitions are only ever used for the wide-scsi board,
    so they should be prefixed with 'ADV', not 'ASC'.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d62a8ca7e2d7..1f3078d3172f 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1700,13 +1700,13 @@ typedef struct adv_carr_t {
 /*
  * Mask used to eliminate low 4 bits of carrier 'next_vpa' field.
  */
-#define ASC_NEXT_VPA_MASK       0xFFFFFFF0
+#define ADV_NEXT_VPA_MASK       0xFFFFFFF0
 
-#define ASC_RQ_DONE             0x00000001
-#define ASC_RQ_GOOD             0x00000002
-#define ASC_CQ_STOPPER          0x00000000
+#define ADV_RQ_DONE             0x00000001
+#define ADV_RQ_GOOD             0x00000002
+#define ADV_CQ_STOPPER          0x00000000
 
-#define ASC_GET_CARRP(carrp) ((carrp) & ASC_NEXT_VPA_MASK)
+#define ADV_GET_CARRP(carrp) ((carrp) & ADV_NEXT_VPA_MASK)
 
 /*
  * Each carrier is 64 bytes, and we need three additional
@@ -4295,7 +4295,7 @@ static ADV_CARR_T *adv_get_next_carrier(struct adv_dvc_var *adv_dvc)
 	/*
 	 * insert stopper carrier to terminate list
 	 */
-	carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	carrp->next_vpa = cpu_to_le32(ADV_CQ_STOPPER);
 
 	return carrp;
 }
@@ -6198,7 +6198,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 	 * Check if the IRQ stopper carrier contains a completed request.
 	 */
 	while (((irq_next_vpa =
-		 le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0) {
+		 le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ADV_RQ_DONE) != 0) {
 		/*
 		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
 		 * The RISC will have set 'areq_vpa' to a virtual address.
@@ -6219,7 +6219,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * DMAed to host memory by the firmware. Set all status fields
 		 * to indicate good status.
 		 */
-		if ((irq_next_vpa & ASC_RQ_GOOD) != 0) {
+		if ((irq_next_vpa & ADV_RQ_GOOD) != 0) {
 			scsiq->done_status = QD_NO_ERROR;
 			scsiq->host_status = scsiq->scsi_status = 0;
 			scsiq->data_cnt = 0L;
@@ -6232,7 +6232,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 */
 		free_carrp = asc_dvc->irq_sp;
 		asc_dvc->irq_sp = adv_get_carrier(asc_dvc,
-						  ASC_GET_CARRP(irq_next_vpa));
+						  ADV_GET_CARRP(irq_next_vpa));
 
 		free_carrp->next_vpa = asc_dvc->carr_freelist->carr_va;
 		asc_dvc->carr_freelist = free_carrp;

commit 96aabb2aacdfce8215fe0d43ba64c94f8d319621
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:34 2015 +0200

    advansys: Remove CC_VERY_LONG_SG_LIST
    
    Was uncommented in the original driver, and I'm too lazy to
    figure out the conversion.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 88604244ae27..d62a8ca7e2d7 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -88,15 +88,6 @@ typedef unsigned char uchar;
 #define PCI_DEVICE_ID_38C0800_REV1	0x2500
 #define PCI_DEVICE_ID_38C1600_REV1	0x2700
 
-/*
- * Enable CC_VERY_LONG_SG_LIST to support up to 64K element SG lists.
- * The SRB structure will have to be changed and the ASC_SRB2SCSIQ()
- * macro re-defined to be able to obtain a ASC_SCSI_Q pointer from the
- * SRB structure.
- */
-#define CC_VERY_LONG_SG_LIST 0
-#define ASC_SRB2SCSIQ(srb_ptr)  (srb_ptr)
-
 #define PortAddr                 unsigned int	/* port address size  */
 #define inp(port)                inb(port)
 #define outp(port, byte)         outb((byte), (port))
@@ -3843,20 +3834,6 @@ static ushort AscReadLramWord(PortAddr iop_base, ushort addr)
 	return (word_data);
 }
 
-#if CC_VERY_LONG_SG_LIST
-static u32 AscReadLramDWord(PortAddr iop_base, ushort addr)
-{
-	ushort val_low, val_high;
-	u32 dword_data;
-
-	AscSetChipLramAddr(iop_base, addr);
-	val_low = AscGetChipLramData(iop_base);
-	val_high = AscGetChipLramData(iop_base);
-	dword_data = ((u32) val_high << 16) | (u32) val_low;
-	return (dword_data);
-}
-#endif /* CC_VERY_LONG_SG_LIST */
-
 static void
 AscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)
 {
@@ -6719,163 +6696,6 @@ static void AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
 		return;
 	}
-#if CC_VERY_LONG_SG_LIST
-	else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC) {
-		uchar q_no;
-		ushort q_addr;
-		uchar sg_wk_q_no;
-		uchar first_sg_wk_q_no;
-		ASC_SCSI_Q *scsiq;	/* Ptr to driver request. */
-		ASC_SG_HEAD *sg_head;	/* Ptr to driver SG request. */
-		ASC_SG_LIST_Q scsi_sg_q;	/* Structure written to queue. */
-		ushort sg_list_dwords;
-		ushort sg_entry_cnt;
-		uchar next_qp;
-		int i;
-
-		q_no = AscReadLramByte(iop_base, (ushort)ASCV_REQ_SG_LIST_QP);
-		if (q_no == ASC_QLINK_END)
-			return 0;
-
-		q_addr = ASC_QNO_TO_QADDR(q_no);
-
-		/*
-		 * Convert the request's SRB pointer to a host ASC_SCSI_Q
-		 * structure pointer using a macro provided by the driver.
-		 * The ASC_SCSI_Q pointer provides a pointer to the
-		 * host ASC_SG_HEAD structure.
-		 */
-		/* Read request's SRB pointer. */
-		scsiq = (ASC_SCSI_Q *)
-		    ASC_SRB2SCSIQ(ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,
-								    (ushort)
-								    (q_addr +
-								     ASC_SCSIQ_D_SRBPTR))));
-
-		/*
-		 * Get request's first and working SG queue.
-		 */
-		sg_wk_q_no = AscReadLramByte(iop_base,
-					     (ushort)(q_addr +
-						      ASC_SCSIQ_B_SG_WK_QP));
-
-		first_sg_wk_q_no = AscReadLramByte(iop_base,
-						   (ushort)(q_addr +
-							    ASC_SCSIQ_B_FIRST_SG_WK_QP));
-
-		/*
-		 * Reset request's working SG queue back to the
-		 * first SG queue.
-		 */
-		AscWriteLramByte(iop_base,
-				 (ushort)(q_addr +
-					  (ushort)ASC_SCSIQ_B_SG_WK_QP),
-				 first_sg_wk_q_no);
-
-		sg_head = scsiq->sg_head;
-
-		/*
-		 * Set sg_entry_cnt to the number of SG elements
-		 * that will be completed on this interrupt.
-		 *
-		 * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1
-		 * SG elements. The data_cnt and data_addr fields which
-		 * add 1 to the SG element capacity are not used when
-		 * restarting SG handling after a halt.
-		 */
-		if (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1)) {
-			sg_entry_cnt = ASC_MAX_SG_LIST - 1;
-
-			/*
-			 * Keep track of remaining number of SG elements that
-			 * will need to be handled on the next interrupt.
-			 */
-			scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
-		} else {
-			sg_entry_cnt = scsiq->remain_sg_entry_cnt;
-			scsiq->remain_sg_entry_cnt = 0;
-		}
-
-		/*
-		 * Copy SG elements into the list of allocated SG queues.
-		 *
-		 * Last index completed is saved in scsiq->next_sg_index.
-		 */
-		next_qp = first_sg_wk_q_no;
-		q_addr = ASC_QNO_TO_QADDR(next_qp);
-		scsi_sg_q.sg_head_qp = q_no;
-		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
-		for (i = 0; i < sg_head->queue_cnt; i++) {
-			scsi_sg_q.seq_no = i + 1;
-			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
-				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
-				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
-				/*
-				 * After very first SG queue RISC FW uses next
-				 * SG queue first element then checks sg_list_cnt
-				 * against zero and then decrements, so set
-				 * sg_list_cnt 1 less than number of SG elements
-				 * in each SG queue.
-				 */
-				scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
-				scsi_sg_q.sg_cur_list_cnt =
-				    ASC_SG_LIST_PER_Q - 1;
-			} else {
-				/*
-				 * This is the last SG queue in the list of
-				 * allocated SG queues. If there are more
-				 * SG elements than will fit in the allocated
-				 * queues, then set the QCSG_SG_XFER_MORE flag.
-				 */
-				if (scsiq->remain_sg_entry_cnt != 0) {
-					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
-				} else {
-					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
-				}
-				/* equals sg_entry_cnt * 2 */
-				sg_list_dwords = sg_entry_cnt << 1;
-				scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
-				scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
-				sg_entry_cnt = 0;
-			}
-
-			scsi_sg_q.q_no = next_qp;
-			AscMemWordCopyPtrToLram(iop_base,
-						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
-						(uchar *)&scsi_sg_q,
-						sizeof(ASC_SG_LIST_Q) >> 1);
-
-			AscMemDWordCopyPtrToLram(iop_base,
-						 q_addr + ASC_SGQ_LIST_BEG,
-						 (uchar *)&sg_head->
-						 sg_list[scsiq->next_sg_index],
-						 sg_list_dwords);
-
-			scsiq->next_sg_index += ASC_SG_LIST_PER_Q;
-
-			/*
-			 * If the just completed SG queue contained the
-			 * last SG element, then no more SG queues need
-			 * to be written.
-			 */
-			if (scsi_sg_q.cntl & QCSG_SG_XFER_END) {
-				break;
-			}
-
-			next_qp = AscReadLramByte(iop_base,
-						  (ushort)(q_addr +
-							   ASC_SCSIQ_B_FWD));
-			q_addr = ASC_QNO_TO_QADDR(next_qp);
-		}
-
-		/*
-		 * Clear the halt condition so the RISC will be restarted
-		 * after the return.
-		 */
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return;
-	}
-#endif /* CC_VERY_LONG_SG_LIST */
 	return;
 }
 
@@ -8221,40 +8041,13 @@ AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 	saved_data_cnt = scsiq->q1.data_cnt;
 	scsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);
 	scsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);
-#if CC_VERY_LONG_SG_LIST
 	/*
-	 * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
-	 * then not all SG elements will fit in the allocated queues.
-	 * The rest of the SG elements will be copied when the RISC
-	 * completes the SG elements that fit and halts.
+	 * Set sg_entry_cnt to be the number of SG elements that
+	 * will fit in the allocated SG queues. It is minus 1, because
+	 * the first SG element is handled above.
 	 */
-	if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
-		/*
-		 * Set sg_entry_cnt to be the number of SG elements that
-		 * will fit in the allocated SG queues. It is minus 1, because
-		 * the first SG element is handled above. ASC_MAX_SG_LIST is
-		 * already inflated by 1 to account for this. For example it
-		 * may be 50 which is 1 + 7 queues * 7 SG elements.
-		 */
-		sg_entry_cnt = ASC_MAX_SG_LIST - 1;
+	sg_entry_cnt = sg_head->entry_cnt - 1;
 
-		/*
-		 * Keep track of remaining number of SG elements that will
-		 * need to be handled from a_isr.c.
-		 */
-		scsiq->remain_sg_entry_cnt =
-		    sg_head->entry_cnt - ASC_MAX_SG_LIST;
-	} else {
-#endif /* CC_VERY_LONG_SG_LIST */
-		/*
-		 * Set sg_entry_cnt to be the number of SG elements that
-		 * will fit in the allocated SG queues. It is minus 1, because
-		 * the first SG element is handled above.
-		 */
-		sg_entry_cnt = sg_head->entry_cnt - 1;
-#if CC_VERY_LONG_SG_LIST
-	}
-#endif /* CC_VERY_LONG_SG_LIST */
 	if (sg_entry_cnt != 0) {
 		scsiq->q1.cntl |= QC_SG_HEAD;
 		q_addr = ASC_QNO_TO_QADDR(q_no);
@@ -8279,21 +8072,7 @@ AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 					    ASC_SG_LIST_PER_Q - 1;
 				}
 			} else {
-#if CC_VERY_LONG_SG_LIST
-				/*
-				 * This is the last SG queue in the list of
-				 * allocated SG queues. If there are more
-				 * SG elements than will fit in the allocated
-				 * queues, then set the QCSG_SG_XFER_MORE flag.
-				 */
-				if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
-					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
-				} else {
-#endif /* CC_VERY_LONG_SG_LIST */
-					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
-#if CC_VERY_LONG_SG_LIST
-				}
-#endif /* CC_VERY_LONG_SG_LIST */
+				scsi_sg_q.cntl |= QCSG_SG_XFER_END;
 				sg_list_dwords = sg_entry_cnt << 1;
 				if (i == 0) {
 					scsi_sg_q.sg_list_cnt = sg_entry_cnt;
@@ -8449,12 +8228,10 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			asc_dvc->in_critical_cnt--;
 			return ASC_ERROR;
 		}
-#if !CC_VERY_LONG_SG_LIST
 		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
 			asc_dvc->in_critical_cnt--;
 			return ASC_ERROR;
 		}
-#endif /* !CC_VERY_LONG_SG_LIST */
 		if (sg_entry_cnt == 1) {
 			scsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);
 			scsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);
@@ -8543,16 +8320,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			}
 		}
 		sg_head->entry_to_copy = sg_head->entry_cnt;
-#if CC_VERY_LONG_SG_LIST
-		/*
-		 * Set the sg_entry_cnt to the maximum possible. The rest of
-		 * the SG elements will be copied when the RISC completes the
-		 * SG elements that fit and halts.
-		 */
-		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
-			sg_entry_cnt = ASC_MAX_SG_LIST;
-		}
-#endif /* CC_VERY_LONG_SG_LIST */
 		n_q_required = AscSgListToQueue(sg_entry_cnt);
 		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=
 		     (uint) n_q_required)

commit 9fef6ba4c2cb311b3a68cc12786c5836fe6a4ae9
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:33 2015 +0200

    advansys: Remove ASC_SCSI_REQ_Q
    
    Removed unused structure ASC_SCSI_REQ_Q and update the
    comments to 'ADV_SCSI_REQ_Q'.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index c3950b5ce344..88604244ae27 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -353,17 +353,6 @@ typedef struct asc_scsi_q {
 	ushort next_sg_index;
 } ASC_SCSI_Q;
 
-typedef struct asc_scsi_req_q {
-	ASC_SCSIQ_1 r1;
-	ASC_SCSIQ_2 r2;
-	uchar *cdbptr;
-	ASC_SG_HEAD *sg_head;
-	uchar *sense_ptr;
-	ASC_SCSIQ_3 r3;
-	uchar cdb[ASC_MAX_CDB_LEN];
-	uchar sense[ASC_MIN_SENSE_LEN];
-} ASC_SCSI_REQ_Q;
-
 typedef struct asc_scsi_bios_req_q {
 	ASC_SCSIQ_1 r1;
 	ASC_SCSIQ_2 r2;
@@ -1707,7 +1696,7 @@ typedef struct adveep_38C1600_config {
 typedef struct adv_carr_t {
 	__le32 carr_va;	/* Carrier Virtual Address */
 	__le32 carr_pa;	/* Carrier Physical Address */
-	__le32 areq_vpa;	/* ASC_SCSI_REQ_Q Virtual or Physical Address */
+	__le32 areq_vpa;	/* ADV_SCSI_REQ_Q Virtual or Physical Address */
 	/*
 	 * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer
 	 *
@@ -1738,7 +1727,7 @@ typedef struct adv_carr_t {
 	(ADV_CARRIER_COUNT * sizeof(ADV_CARR_T))
 
 /*
- * ASC_SCSI_REQ_Q 'a_flag' definitions
+ * ADV_SCSI_REQ_Q 'a_flag' definitions
  *
  * The Adv Library should limit use to the lower nibble (4 bits) of
  * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.
@@ -2029,7 +2018,7 @@ do { \
 
 /*
  * Abort an SRB in the chip's RISC Memory. The 'srb_tag' argument must
- * match the ASC_SCSI_REQ_Q 'srb_tag' field.
+ * match the ADV_SCSI_REQ_Q 'srb_tag' field.
  *
  * If the request has not yet been sent to the device it will simply be
  * aborted from RISC memory. If the request is disconnected it will be
@@ -2075,7 +2064,7 @@ do { \
 #define ADV_TID_TO_TIDMASK(tid)   (0x01 << ((tid) & ADV_MAX_TID))
 
 /*
- * ASC_SCSI_REQ_Q 'done_status' and 'host_status' return values.
+ * ADV_SCSI_REQ_Q 'done_status' and 'host_status' return values.
  */
 
 #define QD_NO_STATUS         0x00	/* Request not completed yet. */
@@ -6237,9 +6226,9 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
 		 * The RISC will have set 'areq_vpa' to a virtual address.
 		 *
-		 * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr
+		 * The firmware will have copied the ADV_SCSI_REQ_Q.scsiq_ptr
 		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
-		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
+		 * below complements the conversion of ADV_SCSI_REQ_Q.scsiq_ptr'
 		 * in AdvExeScsiQueue().
 		 */
 		u32 pa_offset = le32_to_cpu(asc_dvc->irq_sp->areq_vpa);
@@ -6751,9 +6740,9 @@ static void AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		q_addr = ASC_QNO_TO_QADDR(q_no);
 
 		/*
-		 * Convert the request's SRB pointer to a host ASC_SCSI_REQ
+		 * Convert the request's SRB pointer to a host ASC_SCSI_Q
 		 * structure pointer using a macro provided by the driver.
-		 * The ASC_SCSI_REQ pointer provides a pointer to the
+		 * The ASC_SCSI_Q pointer provides a pointer to the
 		 * host ASC_SG_HEAD structure.
 		 */
 		/* Read request's SRB pointer. */
@@ -7947,7 +7936,7 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
  * If an adv_req_t can not be allocated to issue the request,
  * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.
  *
- * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the
+ * Multi-byte fields in the ADV_SCSI_REQ_Q that are used by the
  * microcode for DMA addresses or math operations are byte swapped
  * to little-endian order.
  */
@@ -8633,7 +8622,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
  * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
  * set to SCSI_MAX_RETRY.
  *
- * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the microcode
+ * Multi-byte fields in the ADV_SCSI_REQ_Q that are used by the microcode
  * for DMA addresses or math operations are byte swapped to little-endian
  * order.
  *

commit 37f6460867ef3a40d5385a924780ffdd2a6b750a
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:32 2015 +0200

    advansys: scsi_q1->data_addr is little endian
    
    The 'data_addr' field is accessed by the board, and needs
    to be kept in little endian format.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index f79702412010..c3950b5ce344 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -8230,8 +8230,8 @@ AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 	sg_head = scsiq->sg_head;
 	saved_data_addr = scsiq->q1.data_addr;
 	saved_data_cnt = scsiq->q1.data_cnt;
-	scsiq->q1.data_addr = sg_head->sg_list[0].addr;
-	scsiq->q1.data_cnt = sg_head->sg_list[0].bytes;
+	scsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);
+	scsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);
 #if CC_VERY_LONG_SG_LIST
 	/*
 	 * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
@@ -8467,8 +8467,8 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 		}
 #endif /* !CC_VERY_LONG_SG_LIST */
 		if (sg_entry_cnt == 1) {
-			scsiq->q1.data_addr = sg_head->sg_list[0].addr;
-			scsiq->q1.data_cnt = sg_head->sg_list[0].bytes;
+			scsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);
+			scsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);
 			scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
 		}
 		sg_entry_cnt_minus_one = sg_entry_cnt - 1;

commit f33134e54b074bf2c6bbe67889058fc15ec36d9e
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:31 2015 +0200

    advansys: cleanup function return codes
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index bc52cdcf08e6..f79702412010 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -78,7 +78,6 @@
 
 typedef unsigned char uchar;
 
-#define UW_ERR   (uint)(0xFFFF)
 #define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
 
 #define PCI_VENDOR_ID_ASP		0x10cd
@@ -3981,15 +3980,13 @@ static u32 AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
 	return (sum);
 }
 
-static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
+static void AscInitLram(ASC_DVC_VAR *asc_dvc)
 {
 	uchar i;
 	ushort s_addr;
 	PortAddr iop_base;
-	ushort warn_code;
 
 	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
 	AscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,
 			  (ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *
 				    64) >> 1));
@@ -4028,7 +4025,6 @@ static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
 		AscWriteLramByte(iop_base,
 				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);
 	}
-	return warn_code;
 }
 
 static u32
@@ -4087,10 +4083,10 @@ static void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
 	}
 }
 
-static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
+static int AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 {
 	int i;
-	ushort warn_code;
+	int warn_code;
 	PortAddr iop_base;
 	__le32 phy_addr;
 	__le32 phy_size;
@@ -4132,12 +4128,12 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
 	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
 		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
-		warn_code = UW_ERR;
+		warn_code = -EINVAL;
 		goto err_mcode_start;
 	}
 	if (AscStartChip(iop_base) != 1) {
 		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
-		warn_code = UW_ERR;
+		warn_code = -EIO;
 		goto err_mcode_start;
 	}
 
@@ -4151,13 +4147,13 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	return warn_code;
 }
 
-static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
+static int AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 {
 	const struct firmware *fw;
 	const char fwname[] = "advansys/mcode.bin";
 	int err;
 	unsigned long chksum;
-	ushort warn_code;
+	int warn_code;
 	PortAddr iop_base;
 
 	iop_base = asc_dvc->iop_base;
@@ -4169,15 +4165,13 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	}
 	asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
 	if (asc_dvc->err_code != 0)
-		return UW_ERR;
+		return ASC_ERROR;
 	if (!AscFindSignature(asc_dvc->iop_base)) {
 		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
 		return warn_code;
 	}
 	AscDisableInterrupt(iop_base);
-	warn_code |= AscInitLram(asc_dvc);
-	if (asc_dvc->err_code != 0)
-		return UW_ERR;
+	AscInitLram(asc_dvc);
 
 	err = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);
 	if (err) {
@@ -9028,15 +9022,13 @@ static uchar AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
 }
 #endif /* CONFIG_ISA */
 
-static ushort AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
+static void AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 {
 	int i;
 	PortAddr iop_base;
-	ushort warn_code;
 	uchar chip_version;
 
 	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
 	asc_dvc->err_code = 0;
 	if ((asc_dvc->bus_type &
 	     (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {
@@ -9112,7 +9104,6 @@ static ushort AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 		asc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;
 		asc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;
 	}
-	return warn_code;
 }
 
 static int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
@@ -9378,7 +9369,7 @@ static int AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,
 	return n_error;
 }
 
-static ushort AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
+static int AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 {
 	ASCEEP_CONFIG eep_config_buf;
 	ASCEEP_CONFIG *eep_config;
@@ -9554,8 +9545,8 @@ static int AscInitGetConfig(struct Scsi_Host *shost)
 		return asc_dvc->err_code;
 
 	if (AscFindSignature(asc_dvc->iop_base)) {
-		warn_code |= AscInitAscDvcVar(asc_dvc);
-		warn_code |= AscInitFromEEP(asc_dvc);
+		AscInitAscDvcVar(asc_dvc);
+		warn_code = AscInitFromEEP(asc_dvc);
 		asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
 		if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)
 			asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;

commit 6f0d2e1def218f1e98ed87f00ec10e2535fe69c6
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:30 2015 +0200

    advansys: Make AscIsrChipHalted() a void function
    
    AscIsrChipHalted will only ever return '0', so make it
    a void function.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 1f2e48bc65ed..bc52cdcf08e6 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -6440,7 +6440,7 @@ static void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)
 	AscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);
 }
 
-static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
+static void AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 {
 	EXT_MSG ext_msg;
 	EXT_MSG out_msg;
@@ -6487,14 +6487,14 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 			boardp->sdtr_data[tid_no] = 0;
 		}
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
+		return;
 	} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {
 		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
 			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
 			boardp->sdtr_data[tid_no] = asyn_sdtr;
 		}
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
+		return;
 	} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
 		AscMemWordCopyPtrFromLram(iop_base,
 					  ASCV_MSGIN_BEG,
@@ -6580,7 +6580,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 						  (ushort)ASC_SCSIQ_B_CNTL),
 					 q_cntl);
 			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-			return (0);
+			return;
 		} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&
 			   ext_msg.msg_req == EXTENDED_WDTR &&
 			   ext_msg.msg_len == MS_WDTR_LEN) {
@@ -6596,7 +6596,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 						  (ushort)ASC_SCSIQ_B_CNTL),
 					 q_cntl);
 			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-			return (0);
+			return;
 		} else {
 
 			ext_msg.msg_type = MESSAGE_REJECT;
@@ -6610,7 +6610,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 						  (ushort)ASC_SCSIQ_B_CNTL),
 					 q_cntl);
 			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-			return (0);
+			return;
 		}
 	} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {
 
@@ -6667,7 +6667,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		AscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);
 
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
+		return;
 	} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {
 
 		AscMemWordCopyPtrFromLram(iop_base,
@@ -6689,7 +6689,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 				 (ushort)(halt_q_addr +
 					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
+		return;
 	} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {
 
 		scsi_status = AscReadLramByte(iop_base,
@@ -6734,7 +6734,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 			}
 		}
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
+		return;
 	}
 #if CC_VERY_LONG_SG_LIST
 	else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC) {
@@ -6890,10 +6890,10 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		 * after the return.
 		 */
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
+		return;
 	}
 #endif /* CC_VERY_LONG_SG_LIST */
-	return (0);
+	return;
 }
 
 /*
@@ -7306,13 +7306,9 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 		AscAckInterrupt(iop_base);
 		int_pending = ASC_TRUE;
 		if ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {
-			if (AscIsrChipHalted(asc_dvc) == ASC_ERROR) {
-				goto ISR_REPORT_QDONE_FATAL_ERROR;
-			} else {
-				saved_ctrl_reg &= (uchar)(~CC_HALT);
-			}
+			AscIsrChipHalted(asc_dvc);
+			saved_ctrl_reg &= (uchar)(~CC_HALT);
 		} else {
- ISR_REPORT_QDONE_FATAL_ERROR:
 			if ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {
 				while (((status =
 					 AscIsrQDone(asc_dvc)) & 0x01) != 0) {

commit f1138a84a314d95bece2dea91487a733de31d6e8
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:29 2015 +0200

    advansys: remove 'ERR' definition
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9c3297769490..1f2e48bc65ed 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -78,7 +78,6 @@
 
 typedef unsigned char uchar;
 
-#define ERR      (-1)
 #define UW_ERR   (uint)(0xFFFF)
 #define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
 
@@ -7307,7 +7306,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 		AscAckInterrupt(iop_base);
 		int_pending = ASC_TRUE;
 		if ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {
-			if (AscIsrChipHalted(asc_dvc) == ERR) {
+			if (AscIsrChipHalted(asc_dvc) == ASC_ERROR) {
 				goto ISR_REPORT_QDONE_FATAL_ERROR;
 			} else {
 				saved_ctrl_reg &= (uchar)(~CC_HALT);
@@ -8437,7 +8436,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	iop_base = asc_dvc->iop_base;
 	sg_head = scsiq->sg_head;
 	if (asc_dvc->err_code != 0)
-		return (ERR);
+		return ASC_ERROR;
 	scsiq->q1.q_no = 0;
 	if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
 		scsiq->q1.extra_bytes = 0;
@@ -8463,18 +8462,18 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	}
 	if (asc_dvc->in_critical_cnt != 0) {
 		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
-		return (ERR);
+		return ASC_ERROR;
 	}
 	asc_dvc->in_critical_cnt++;
 	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
 		if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
 			asc_dvc->in_critical_cnt--;
-			return (ERR);
+			return ASC_ERROR;
 		}
 #if !CC_VERY_LONG_SG_LIST
 		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
 			asc_dvc->in_critical_cnt--;
-			return (ERR);
+			return ASC_ERROR;
 		}
 #endif /* !CC_VERY_LONG_SG_LIST */
 		if (sg_entry_cnt == 1) {

commit ae26759e1ceb686ce725e91f0048b90dd98c91ee
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:28 2015 +0200

    advansys: Remove 'TRUE' and 'FALSE' definitions
    
    Use 'bool' type instead.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 4e52625f7929..9c3297769490 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -78,13 +78,6 @@
 
 typedef unsigned char uchar;
 
-#ifndef TRUE
-#define TRUE     (1)
-#endif
-#ifndef FALSE
-#define FALSE    (0)
-#endif
-
 #define ERR      (-1)
 #define UW_ERR   (uint)(0xFFFF)
 #define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
@@ -556,7 +549,7 @@ typedef struct asc_dvc_var {
 	dma_addr_t overrun_dma;
 	uchar scsi_reset_wait;
 	uchar chip_no;
-	char is_in_int;
+	bool is_in_int;
 	uchar max_total_qng;
 	uchar cur_total_qng;
 	uchar in_critical_cnt;
@@ -3754,7 +3747,7 @@ static int AscStartChip(PortAddr iop_base)
 	return (1);
 }
 
-static int AscStopChip(PortAddr iop_base)
+static bool AscStopChip(PortAddr iop_base)
 {
 	uchar cc_val;
 
@@ -3765,9 +3758,9 @@ static int AscStopChip(PortAddr iop_base)
 	AscSetChipIH(iop_base, INS_HALT);
 	AscSetChipIH(iop_base, INS_RFLAG_WTM);
 	if ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {
-		return (0);
+		return false;
 	}
-	return (1);
+	return true;
 }
 
 static bool AscIsChipHalted(PortAddr iop_base)
@@ -6453,7 +6446,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 	EXT_MSG ext_msg;
 	EXT_MSG out_msg;
 	ushort halt_q_addr;
-	int sdtr_accept;
+	bool sdtr_accept;
 	ushort int_halt_code;
 	ASC_SCSI_BIT_ID_TYPE scsi_busy;
 	ASC_SCSI_BIT_ID_TYPE target_id;
@@ -6512,10 +6505,10 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		if (ext_msg.msg_type == EXTENDED_MESSAGE &&
 		    ext_msg.msg_req == EXTENDED_SDTR &&
 		    ext_msg.msg_len == MS_SDTR_LEN) {
-			sdtr_accept = TRUE;
+			sdtr_accept = true;
 			if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
 
-				sdtr_accept = FALSE;
+				sdtr_accept = false;
 				ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
 			}
 			if ((ext_msg.xfer_period <
@@ -6523,7 +6516,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 			    || (ext_msg.xfer_period >
 				asc_dvc->sdtr_period_tbl[asc_dvc->
 							 max_sdtr_index])) {
-				sdtr_accept = FALSE;
+				sdtr_accept = false;
 				ext_msg.xfer_period =
 				    asc_dvc->sdtr_period_tbl[asc_dvc->
 							     min_sdtr_index];
@@ -7111,7 +7104,7 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 	uchar cur_target_qng;
 	ASC_QDONE_INFO scsiq_buf;
 	ASC_QDONE_INFO *scsiq;
-	int false_overrun;
+	bool false_overrun;
 
 	iop_base = asc_dvc->iop_base;
 	n_q_used = 1;
@@ -7189,7 +7182,11 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 		    ((scsiq->q_status & QS_ABORTED) != 0)) {
 			return (0x11);
 		} else if (scsiq->q_status == QS_DONE) {
-			false_overrun = FALSE;
+			/*
+			 * This is also curious.
+			 * false_overrun will _always_ be set to 'false'
+			 */
+			false_overrun = false;
 			if (scsiq->extra_bytes != 0) {
 				scsiq->remain_bytes += scsiq->extra_bytes;
 			}
@@ -7262,23 +7259,23 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 	uchar host_flag;
 
 	iop_base = asc_dvc->iop_base;
-	int_pending = FALSE;
+	int_pending = ASC_FALSE;
 
 	if (AscIsIntPending(iop_base) == 0)
 		return int_pending;
 
 	if ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {
-		return ERR;
+		return ASC_ERROR;
 	}
 	if (asc_dvc->in_critical_cnt != 0) {
 		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);
-		return ERR;
+		return ASC_ERROR;
 	}
 	if (asc_dvc->is_in_int) {
 		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);
-		return ERR;
+		return ASC_ERROR;
 	}
-	asc_dvc->is_in_int = TRUE;
+	asc_dvc->is_in_int = true;
 	ctrl_reg = AscGetChipControl(iop_base);
 	saved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |
 				       CC_SINGLE_STEP | CC_DIAG | CC_TEST));
@@ -7286,7 +7283,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 	if (chipstat & CSW_SCSI_RESET_LATCH) {
 		if (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {
 			int i = 10;
-			int_pending = TRUE;
+			int_pending = ASC_TRUE;
 			asc_dvc->sdtr_done = 0;
 			saved_ctrl_reg &= (uchar)(~CC_HALT);
 			while ((AscGetChipStatus(iop_base) &
@@ -7308,7 +7305,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 			 (uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));
 	if ((chipstat & CSW_INT_PENDING) || (int_pending)) {
 		AscAckInterrupt(iop_base);
-		int_pending = TRUE;
+		int_pending = ASC_TRUE;
 		if ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {
 			if (AscIsrChipHalted(asc_dvc) == ERR) {
 				goto ISR_REPORT_QDONE_FATAL_ERROR;
@@ -7330,13 +7327,13 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 				} while (status == 0x11);
 			}
 			if ((status & 0x80) != 0)
-				int_pending = ERR;
+				int_pending = ASC_ERROR;
 		}
 	}
 	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
 	AscSetChipLramAddr(iop_base, saved_ram_addr);
 	AscSetChipControl(iop_base, saved_ctrl_reg);
-	asc_dvc->is_in_int = FALSE;
+	asc_dvc->is_in_int = false;
 	return int_pending;
 }
 
@@ -8423,7 +8420,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	PortAddr iop_base;
 	int sta;
 	int n_q_required;
-	int disable_syn_offset_one_fix;
+	bool disable_syn_offset_one_fix;
 	int i;
 	u32 addr;
 	ushort sg_entry_cnt = 0;
@@ -8488,7 +8485,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 		sg_entry_cnt_minus_one = sg_entry_cnt - 1;
 	}
 	scsi_cmd = scsiq->cdbptr[0];
-	disable_syn_offset_one_fix = FALSE;
+	disable_syn_offset_one_fix = false;
 	if ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&
 	    !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {
 		if (scsiq->q1.cntl & QC_SG_HEAD) {
@@ -8502,7 +8499,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 		}
 		if (data_cnt != 0UL) {
 			if (data_cnt < 512UL) {
-				disable_syn_offset_one_fix = TRUE;
+				disable_syn_offset_one_fix = true;
 			} else {
 				for (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;
 				     i++) {
@@ -8513,7 +8510,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 					}
 					if (scsi_cmd == disable_cmd) {
 						disable_syn_offset_one_fix =
-						    TRUE;
+						    true;
 						break;
 					}
 				}
@@ -9058,7 +9055,7 @@ static ushort AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	/* asc_dvc->init_state initialized in AscInitGetConfig(). */
 	asc_dvc->sdtr_done = 0;
 	asc_dvc->cur_total_qng = 0;
-	asc_dvc->is_in_int = 0;
+	asc_dvc->is_in_int = false;
 	asc_dvc->in_critical_cnt = 0;
 	asc_dvc->last_q_shortage = 0;
 	asc_dvc->use_tagged_qng = 0;
@@ -9238,7 +9235,7 @@ static int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 	int retry;
 
 	retry = 0;
-	while (TRUE) {
+	while (true) {
 		AscSetChipEEPData(iop_base, data_reg);
 		mdelay(1);
 		read_back = AscGetChipEEPData(iop_base);
@@ -9374,7 +9371,7 @@ static int AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,
 	int n_error;
 
 	retry = 0;
-	while (TRUE) {
+	while (true) {
 		if ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,
 						   bus_type)) == 0) {
 			break;
@@ -9401,7 +9398,7 @@ static ushort AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	warn_code = 0;
 	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);
 	AscStopQueueExe(iop_base);
-	if ((AscStopChip(iop_base) == FALSE) ||
+	if ((AscStopChip(iop_base)) ||
 	    (AscGetChipScsiCtrl(iop_base) != 0)) {
 		asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
 		AscResetChipAndScsiBus(asc_dvc);
@@ -11093,7 +11090,7 @@ static struct scsi_host_template advansys_template = {
 	 * must be set. The flag will be cleared in advansys_board_found
 	 * for non-ISA adapters.
 	 */
-	.unchecked_isa_dma = 1,
+	.unchecked_isa_dma = true,
 	/*
 	 * All adapters controlled by this driver are capable of large
 	 * scatter-gather lists. According to the mid-level SCSI documentation
@@ -11269,28 +11266,28 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		switch (asc_dvc_varp->bus_type) {
 #ifdef CONFIG_ISA
 		case ASC_IS_ISA:
-			shost->unchecked_isa_dma = TRUE;
+			shost->unchecked_isa_dma = true;
 			share_irq = 0;
 			break;
 		case ASC_IS_VL:
-			shost->unchecked_isa_dma = FALSE;
+			shost->unchecked_isa_dma = false;
 			share_irq = 0;
 			break;
 		case ASC_IS_EISA:
-			shost->unchecked_isa_dma = FALSE;
+			shost->unchecked_isa_dma = false;
 			share_irq = IRQF_SHARED;
 			break;
 #endif /* CONFIG_ISA */
 #ifdef CONFIG_PCI
 		case ASC_IS_PCI:
-			shost->unchecked_isa_dma = FALSE;
+			shost->unchecked_isa_dma = false;
 			share_irq = IRQF_SHARED;
 			break;
 #endif /* CONFIG_PCI */
 		default:
 			shost_printk(KERN_ERR, shost, "unknown adapter type: "
 					"%d\n", asc_dvc_varp->bus_type);
-			shost->unchecked_isa_dma = TRUE;
+			shost->unchecked_isa_dma = false;
 			share_irq = 0;
 			break;
 		}
@@ -11309,7 +11306,7 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		 * For Wide boards set PCI information before calling
 		 * AdvInitGetConfig().
 		 */
-		shost->unchecked_isa_dma = FALSE;
+		shost->unchecked_isa_dma = false;
 		share_irq = IRQF_SHARED;
 		ASC_DBG(2, "AdvInitGetConfig()\n");
 

commit 95cfab6c11180f13f0dc47cfef36092189e05801
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:27 2015 +0200

    advansys: use standard data types
    
    No point in defining our own.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 528f928a5dd0..4e52625f7929 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -76,20 +76,6 @@
 /* Enable driver tracing. */
 #undef ADVANSYS_DEBUG
 
-/*
- * Portable Data Types
- *
- * Any instance where a 32-bit long or pointer type is assumed
- * for precision or HW defined structures, the following define
- * types must be used. In Linux the char, short, and int types
- * are all consistent at 8, 16, and 32 bits respectively. Pointers
- * and long types are 64 bits on Alpha and UltraSPARC.
- */
-#define ASC_PADDR __u32		/* Physical/Bus address data type. */
-#define ASC_VADDR __u32		/* Virtual address data type. */
-#define ASC_DCNT  __u32		/* Unsigned Data count type. */
-#define ASC_SDCNT __s32		/* Signed Data count type. */
-
 typedef unsigned char uchar;
 
 #ifndef TRUE
@@ -307,9 +293,9 @@ typedef struct asc_scsiq_1 {
 	uchar sg_queue_cnt;
 	uchar target_id;
 	uchar target_lun;
-	ASC_PADDR data_addr;
-	ASC_DCNT data_cnt;
-	ASC_PADDR sense_addr;
+	__le32 data_addr;
+	__le32 data_cnt;
+	__le32 sense_addr;
 	uchar sense_len;
 	uchar extra_bytes;
 } ASC_SCSIQ_1;
@@ -338,8 +324,8 @@ typedef struct asc_scsiq_4 {
 	uchar y_res;
 	ushort x_req_count;
 	ushort x_reconnect_rtn;
-	ASC_PADDR x_saved_data_addr;
-	ASC_DCNT x_saved_data_cnt;
+	__le32 x_saved_data_addr;
+	__le32 x_saved_data_cnt;
 } ASC_SCSIQ_4;
 
 typedef struct asc_q_done_info {
@@ -351,12 +337,12 @@ typedef struct asc_q_done_info {
 	uchar sense_len;
 	uchar extra_bytes;
 	uchar res;
-	ASC_DCNT remain_bytes;
+	u32 remain_bytes;
 } ASC_QDONE_INFO;
 
 typedef struct asc_sg_list {
-	ASC_PADDR addr;
-	ASC_DCNT bytes;
+	__le32 addr;
+	__le32 bytes;
 } ASC_SG_LIST;
 
 typedef struct asc_sg_head {
@@ -586,13 +572,13 @@ typedef struct asc_dvc_var {
 	char redo_scam;
 	ushort res2;
 	uchar dos_int13_table[ASC_MAX_TID + 1];
-	ASC_DCNT max_dma_count;
+	unsigned int max_dma_count;
 	ASC_SCSI_BIT_ID_TYPE no_scam;
 	ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;
 	uchar min_sdtr_index;
 	uchar max_sdtr_index;
 	struct asc_board *drv_ptr;
-	ASC_DCNT uc_break;
+	unsigned int uc_break;
 } ASC_DVC_VAR;
 
 typedef struct asc_dvc_inq_info {
@@ -600,8 +586,8 @@ typedef struct asc_dvc_inq_info {
 } ASC_DVC_INQ_INFO;
 
 typedef struct asc_cap_info {
-	ASC_DCNT lba;
-	ASC_DCNT blk_size;
+	u32 lba;
+	u32 blk_size;
 } ASC_CAP_INFO;
 
 typedef struct asc_cap_info_array {
@@ -927,20 +913,6 @@ typedef struct asc_mc_saved {
 #define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)
 #define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)
 
-/*
- * Portable Data Types
- *
- * Any instance where a 32-bit long or pointer type is assumed
- * for precision or HW defined structures, the following define
- * types must be used. In Linux the char, short, and int types
- * are all consistent at 8, 16, and 32 bits respectively. Pointers
- * and long types are 64 bits on Alpha and UltraSPARC.
- */
-#define ADV_PADDR __u32		/* Physical address data type. */
-#define ADV_VADDR __u32		/* Virtual address data type. */
-#define ADV_DCNT  __u32		/* Unsigned Data count type. */
-#define ADV_SDCNT __s32		/* Signed Data count type. */
-
 /*
  * These macros are used to convert a virtual address to a
  * 32-bit value. This currently can be used on Linux Alpha
@@ -949,7 +921,6 @@ typedef struct asc_mc_saved {
  * will give us time to change the HW and FW to handle 64-bit
  * addresses.
  */
-#define ADV_VADDR_TO_U32   virt_to_bus
 #define ADV_U32_TO_VADDR   bus_to_virt
 
 #define AdvPortAddr  void __iomem *	/* Virtual memory address size */
@@ -1843,8 +1814,8 @@ typedef struct adv_scsi_req_q {
 	uchar target_cmd;
 	uchar target_id;	/* Device target identifier. */
 	uchar target_lun;	/* Device target logical unit number. */
-	ADV_PADDR data_addr;	/* Data buffer physical address. */
-	ADV_DCNT data_cnt;	/* Data count. Ucode sets to residual. */
+	__le32 data_addr;	/* Data buffer physical address. */
+	__le32 data_cnt;	/* Data count. Ucode sets to residual. */
 	__le32 sense_addr;
 	__le32 carr_pa;
 	uchar mflag;
@@ -1856,7 +1827,7 @@ typedef struct adv_scsi_req_q {
 	uchar host_status;	/* Ucode host status. */
 	uchar sg_working_ix;
 	uchar cdb[12];		/* SCSI CDB bytes 0-11. */
-	ADV_PADDR sg_real_addr;	/* SG list physical address. */
+	__le32 sg_real_addr;	/* SG list physical address. */
 	__le32 scsiq_rptr;
 	uchar cdb16[4];		/* SCSI CDB bytes 12-15. */
 	__le32 scsiq_ptr;
@@ -2151,8 +2122,6 @@ do { \
 #define QHSTA_M_SGBACKUP_ERROR      0x47	/* Scatter-Gather backup error */
 
 /* Return the address that is aligned at the next doubleword >= to 'addr'. */
-#define ADV_8BALIGN(addr)      (((ulong) (addr) + 0x7) & ~0x7)
-#define ADV_16BALIGN(addr)     (((ulong) (addr) + 0xF) & ~0xF)
 #define ADV_32BALIGN(addr)     (((ulong) (addr) + 0x1F) & ~0x1F)
 
 /*
@@ -2313,24 +2282,24 @@ do { \
 /* Per board statistics structure */
 struct asc_stats {
 	/* Driver Entrypoint Statistics */
-	ADV_DCNT queuecommand;	/* # calls to advansys_queuecommand() */
-	ADV_DCNT reset;		/* # calls to advansys_eh_bus_reset() */
-	ADV_DCNT biosparam;	/* # calls to advansys_biosparam() */
-	ADV_DCNT interrupt;	/* # advansys_interrupt() calls */
-	ADV_DCNT callback;	/* # calls to asc/adv_isr_callback() */
-	ADV_DCNT done;		/* # calls to request's scsi_done function */
-	ADV_DCNT build_error;	/* # asc/adv_build_req() ASC_ERROR returns. */
-	ADV_DCNT adv_build_noreq;	/* # adv_build_req() adv_req_t alloc. fail. */
-	ADV_DCNT adv_build_nosg;	/* # adv_build_req() adv_sgblk_t alloc. fail. */
+	unsigned int queuecommand;	/* # calls to advansys_queuecommand() */
+	unsigned int reset;		/* # calls to advansys_eh_bus_reset() */
+	unsigned int biosparam;	/* # calls to advansys_biosparam() */
+	unsigned int interrupt;	/* # advansys_interrupt() calls */
+	unsigned int callback;	/* # calls to asc/adv_isr_callback() */
+	unsigned int done;		/* # calls to request's scsi_done function */
+	unsigned int build_error;	/* # asc/adv_build_req() ASC_ERROR returns. */
+	unsigned int adv_build_noreq;	/* # adv_build_req() adv_req_t alloc. fail. */
+	unsigned int adv_build_nosg;	/* # adv_build_req() adv_sgblk_t alloc. fail. */
 	/* AscExeScsiQueue()/AdvExeScsiQueue() Statistics */
-	ADV_DCNT exe_noerror;	/* # ASC_NOERROR returns. */
-	ADV_DCNT exe_busy;	/* # ASC_BUSY returns. */
-	ADV_DCNT exe_error;	/* # ASC_ERROR returns. */
-	ADV_DCNT exe_unknown;	/* # unknown returns. */
+	unsigned int exe_noerror;	/* # ASC_NOERROR returns. */
+	unsigned int exe_busy;	/* # ASC_BUSY returns. */
+	unsigned int exe_error;	/* # ASC_ERROR returns. */
+	unsigned int exe_unknown;	/* # unknown returns. */
 	/* Data Transfer Statistics */
-	ADV_DCNT xfer_cnt;	/* # I/O requests received */
-	ADV_DCNT xfer_elem;	/* # scatter-gather elements */
-	ADV_DCNT xfer_sect;	/* # 512-byte blocks */
+	unsigned int xfer_cnt;	/* # I/O requests received */
+	unsigned int xfer_elem;	/* # scatter-gather elements */
+	unsigned int xfer_sect;	/* # 512-byte blocks */
 };
 #endif /* ADVANSYS_STATS */
 
@@ -3895,15 +3864,15 @@ static ushort AscReadLramWord(PortAddr iop_base, ushort addr)
 }
 
 #if CC_VERY_LONG_SG_LIST
-static ASC_DCNT AscReadLramDWord(PortAddr iop_base, ushort addr)
+static u32 AscReadLramDWord(PortAddr iop_base, ushort addr)
 {
 	ushort val_low, val_high;
-	ASC_DCNT dword_data;
+	u32 dword_data;
 
 	AscSetChipLramAddr(iop_base, addr);
 	val_low = AscGetChipLramData(iop_base);
 	val_high = AscGetChipLramData(iop_base);
-	dword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;
+	dword_data = ((u32) val_high << 16) | (u32) val_low;
 	return (dword_data);
 }
 #endif /* CC_VERY_LONG_SG_LIST */
@@ -4009,12 +3978,11 @@ AscMemWordCopyPtrFromLram(PortAddr iop_base,
 	}
 }
 
-static ASC_DCNT AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
+static u32 AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
 {
-	ASC_DCNT sum;
+	u32 sum = 0;
 	int i;
 
-	sum = 0L;
 	for (i = 0; i < words; i++, s_addr += 2) {
 		sum += AscReadLramWord(iop_base, s_addr);
 	}
@@ -4071,11 +4039,11 @@ static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
 	return warn_code;
 }
 
-static ASC_DCNT
+static u32
 AscLoadMicroCode(PortAddr iop_base, ushort s_addr,
 		 const uchar *mcode_buf, ushort mcode_size)
 {
-	ASC_DCNT chksum;
+	u32 chksum;
 	ushort mcode_word_size;
 	ushort mcode_chksum;
 
@@ -4132,8 +4100,8 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	int i;
 	ushort warn_code;
 	PortAddr iop_base;
-	ASC_PADDR phy_addr;
-	ASC_DCNT phy_size;
+	__le32 phy_addr;
+	__le32 phy_size;
 	struct asc_board *board = asc_dvc_to_board(asc_dvc);
 
 	iop_base = asc_dvc->iop_base;
@@ -4277,7 +4245,7 @@ static int AdvLoadMicrocode(AdvPortAddr iop_base, const unsigned char *buf,
 			    int size, int memsize, int chksum)
 {
 	int i, j, end, len = 0;
-	ADV_DCNT sum;
+	u32 sum;
 
 	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
 
@@ -4407,10 +4375,9 @@ static adv_req_t * adv_get_reqp(struct adv_dvc_var *adv_dvc, u32 offset)
  */
 static int
 AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
-	       ushort idle_cmd, ADV_DCNT idle_cmd_parameter)
+	       ushort idle_cmd, u32 idle_cmd_parameter)
 {
-	int result;
-	ADV_DCNT i, j;
+	int result, i, j;
 	AdvPortAddr iop_base;
 
 	iop_base = asc_dvc->iop_base;
@@ -6068,7 +6035,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	adv_req_t *reqp;
 	adv_sgblk_t *sgblkp;
 	struct scsi_cmnd *scp;
-	ADV_DCNT resid_cnt;
+	u32 resid_cnt;
 	dma_addr_t sense_addr;
 
 	ASC_DBG(1, "adv_dvc_varp 0x%p, scsiqp 0x%p\n",
@@ -6234,7 +6201,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 	uchar int_stat;
 	ushort target_bit;
 	ADV_CARR_T *free_carrp;
-	ADV_VADDR irq_next_vpa;
+	__le32 irq_next_vpa;
 	ADV_SCSI_REQ_Q *scsiq;
 	adv_req_t *reqp;
 
@@ -6968,7 +6935,7 @@ DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
 static uchar
 _AscCopyLramScsiDoneQ(PortAddr iop_base,
 		      ushort q_addr,
-		      ASC_QDONE_INFO *scsiq, ASC_DCNT max_dma_count)
+		      ASC_QDONE_INFO *scsiq, unsigned int max_dma_count)
 {
 	ushort _val;
 	uchar sg_queue_cnt;
@@ -6995,10 +6962,10 @@ _AscCopyLramScsiDoneQ(PortAddr iop_base,
 	/*
 	 * Read high word of remain bytes from alternate location.
 	 */
-	scsiq->remain_bytes = (((ADV_DCNT)AscReadLramWord(iop_base,
-							  (ushort)(q_addr +
-								   (ushort)
-								   ASC_SCSIQ_W_ALT_DC1)))
+	scsiq->remain_bytes = (((u32)AscReadLramWord(iop_base,
+						     (ushort)(q_addr +
+							      (ushort)
+							      ASC_SCSIQ_W_ALT_DC1)))
 			       << 16);
 	/*
 	 * Read low word of remain bytes from original location.
@@ -7224,8 +7191,7 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 		} else if (scsiq->q_status == QS_DONE) {
 			false_overrun = FALSE;
 			if (scsiq->extra_bytes != 0) {
-				scsiq->remain_bytes +=
-				    (ADV_DCNT)scsiq->extra_bytes;
+				scsiq->remain_bytes += scsiq->extra_bytes;
 			}
 			if (scsiq->d3.done_stat == QD_WITH_ERROR) {
 				if (scsiq->d3.host_stat ==
@@ -8265,8 +8231,8 @@ AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 	int i;
 	ASC_SG_HEAD *sg_head;
 	ASC_SG_LIST_Q scsi_sg_q;
-	ASC_DCNT saved_data_addr;
-	ASC_DCNT saved_data_cnt;
+	__le32 saved_data_addr;
+	__le32 saved_data_cnt;
 	PortAddr iop_base;
 	ushort sg_list_dwords;
 	ushort sg_index;
@@ -8278,8 +8244,8 @@ AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 	sg_head = scsiq->sg_head;
 	saved_data_addr = scsiq->q1.data_addr;
 	saved_data_cnt = scsiq->q1.data_cnt;
-	scsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;
-	scsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;
+	scsiq->q1.data_addr = sg_head->sg_list[0].addr;
+	scsiq->q1.data_cnt = sg_head->sg_list[0].bytes;
 #if CC_VERY_LONG_SG_LIST
 	/*
 	 * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
@@ -8459,7 +8425,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	int n_q_required;
 	int disable_syn_offset_one_fix;
 	int i;
-	ASC_PADDR addr;
+	u32 addr;
 	ushort sg_entry_cnt = 0;
 	ushort sg_entry_cnt_minus_one = 0;
 	uchar target_ix;
@@ -8469,7 +8435,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	uchar scsi_cmd;
 	uchar disable_cmd;
 	ASC_SG_HEAD *sg_head;
-	ASC_DCNT data_cnt;
+	unsigned long data_cnt;
 
 	iop_base = asc_dvc->iop_base;
 	sg_head = scsiq->sg_head;
@@ -8515,10 +8481,8 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 		}
 #endif /* !CC_VERY_LONG_SG_LIST */
 		if (sg_entry_cnt == 1) {
-			scsiq->q1.data_addr =
-			    (ADV_PADDR)sg_head->sg_list[0].addr;
-			scsiq->q1.data_cnt =
-			    (ADV_DCNT)sg_head->sg_list[0].bytes;
+			scsiq->q1.data_addr = sg_head->sg_list[0].addr;
+			scsiq->q1.data_cnt = sg_head->sg_list[0].bytes;
 			scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
 		}
 		sg_entry_cnt_minus_one = sg_entry_cnt - 1;
@@ -8530,9 +8494,8 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 		if (scsiq->q1.cntl & QC_SG_HEAD) {
 			data_cnt = 0;
 			for (i = 0; i < sg_entry_cnt; i++) {
-				data_cnt +=
-				    (ADV_DCNT)le32_to_cpu(sg_head->sg_list[i].
-							  bytes);
+				data_cnt += le32_to_cpu(sg_head->sg_list[i].
+							bytes);
 			}
 		} else {
 			data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
@@ -8569,12 +8532,11 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
 				if ((scsi_cmd == READ_6) ||
 				    (scsi_cmd == READ_10)) {
-					addr =
-					    (ADV_PADDR)le32_to_cpu(sg_head->
+					addr = le32_to_cpu(sg_head->
 								   sg_list
 								   [sg_entry_cnt_minus_one].
 								   addr) +
-					    (ADV_DCNT)le32_to_cpu(sg_head->
+						le32_to_cpu(sg_head->
 								  sg_list
 								  [sg_entry_cnt_minus_one].
 								  bytes);
@@ -8595,8 +8557,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 								sg_list
 								[sg_entry_cnt_minus_one].
 								bytes);
-						data_cnt -=
-						    (ASC_DCNT) extra_bytes;
+						data_cnt -= extra_bytes;
 						sg_head->
 						    sg_list
 						    [sg_entry_cnt_minus_one].
@@ -8651,8 +8612,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 						    == 0) {
 							scsiq->q2.tag_code |=
 							    ASC_TAG_FLAG_EXTRA_BYTES;
-							data_cnt -= (ASC_DCNT)
-							    extra_bytes;
+							data_cnt -= extra_bytes;
 							scsiq->q1.data_cnt =
 							    cpu_to_le32
 							    (data_cnt);
@@ -9015,7 +8975,7 @@ static int AscStopQueueExe(PortAddr iop_base)
 	return (0);
 }
 
-static ASC_DCNT AscGetMaxDmaCount(ushort bus_type)
+static unsigned int AscGetMaxDmaCount(ushort bus_type)
 {
 	if (bus_type & ASC_IS_ISA)
 		return ASC_MAX_ISA_DMA_COUNT;

commit d647c78346ea15103b31dcd8cc3eff8099943a14
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:26 2015 +0200

    advansys: use 'bool' instead of 'int'
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index f74117496072..528f928a5dd0 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3801,17 +3801,17 @@ static int AscStopChip(PortAddr iop_base)
 	return (1);
 }
 
-static int AscIsChipHalted(PortAddr iop_base)
+static bool AscIsChipHalted(PortAddr iop_base)
 {
 	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
 		if ((AscGetChipControl(iop_base) & CC_HALT) != 0) {
-			return (1);
+			return true;
 		}
 	}
-	return (0);
+	return false;
 }
 
-static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
+static bool AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
 {
 	PortAddr iop_base;
 	int i = 10;
@@ -6446,11 +6446,11 @@ AscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)
 	return byte;
 }
 
-static int AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)
+static bool AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)
 {
 	ASC_SCSI_BIT_ID_TYPE org_id;
 	int i;
-	int sta = TRUE;
+	bool sta = true;
 
 	AscSetBank(iop_base, 1);
 	org_id = AscReadChipDvcID(iop_base);
@@ -6464,10 +6464,10 @@ static int AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)
 		AscSetBank(iop_base, 0);
 		AscSetChipSyn(iop_base, sdtr_data);
 		if (AscGetChipSyn(iop_base) != sdtr_data) {
-			sta = FALSE;
+			sta = false;
 		}
 	} else {
-		sta = FALSE;
+		sta = false;
 	}
 	AscSetBank(iop_base, 1);
 	AscWriteChipDvcID(iop_base, org_id);
@@ -7527,32 +7527,32 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	return result;
 }
 
-static int AscHostReqRiscHalt(PortAddr iop_base)
+static bool AscHostReqRiscHalt(PortAddr iop_base)
 {
 	int count = 0;
-	int sta = 0;
+	bool sta = false;
 	uchar saved_stop_code;
 
 	if (AscIsChipHalted(iop_base))
-		return (1);
+		return true;
 	saved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);
 	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
 			 ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);
 	do {
 		if (AscIsChipHalted(iop_base)) {
-			sta = 1;
+			sta = true;
 			break;
 		}
 		mdelay(100);
 	} while (count++ < 20);
 	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
-	return (sta);
+	return sta;
 }
 
-static int
+static bool
 AscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)
 {
-	int sta = FALSE;
+	bool sta = false;
 
 	if (AscHostReqRiscHalt(iop_base)) {
 		sta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
@@ -9447,7 +9447,7 @@ static ushort AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 		AscResetChipAndScsiBus(asc_dvc);
 		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
 	}
-	if (AscIsChipHalted(iop_base) == FALSE) {
+	if (!AscIsChipHalted(iop_base)) {
 		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
 		return (warn_code);
 	}

commit 0ce538226b7a9cbddf812ff94d9f94f8445b0eeb
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:25 2015 +0200

    advansys: Use dma_pool for sg elements
    
    The sg elements should be allocated from a dma pool.
    And rename the structure to 'adv_sg_block' as they
    are only used by the wide board.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e73f7847905c..f74117496072 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1815,15 +1815,15 @@ typedef struct adv_dvc_cfg {
 struct adv_dvc_var;
 struct adv_scsi_req_q;
 
-typedef struct asc_sg_block {
+typedef struct adv_sg_block {
 	uchar reserved1;
 	uchar reserved2;
 	uchar reserved3;
 	uchar sg_cnt;		/* Valid entries in block. */
-	ADV_PADDR sg_ptr;	/* Pointer to next sg block. */
+	__le32 sg_ptr;	/* Pointer to next sg block. */
 	struct {
-		ADV_PADDR sg_addr;	/* SG element address. */
-		ADV_DCNT sg_count;	/* SG element count. */
+		__le32 sg_addr;	/* SG element address. */
+		__le32 sg_count;	/* SG element count. */
 	} sg_list[NO_OF_SG_PER_BLOCK];
 } ADV_SG_BLOCK;
 
@@ -1888,7 +1888,7 @@ typedef struct adv_scsi_req_q {
  */
 typedef struct adv_sgblk {
 	ADV_SG_BLOCK sg_block;	/* Sgblock structure. */
-	uchar align[32];	/* Sgblock structure padding. */
+	dma_addr_t sg_addr;	/* Physical address */
 	struct adv_sgblk *next_sgblkp;	/* Next scatter-gather structure. */
 } adv_sgblk_t;
 
@@ -2381,7 +2381,7 @@ struct asc_board {
 	adv_req_t *adv_reqp;	/* Request structures. */
 	dma_addr_t adv_reqp_addr;
 	size_t adv_reqp_size;
-	adv_sgblk_t *adv_sgblkp;	/* Scatter-gather structures. */
+	struct dma_pool *adv_sgblk_pool;	/* Scatter-gather structures. */
 	ushort bios_signature;	/* BIOS Signature. */
 	ushort bios_version;	/* BIOS Version. */
 	ushort bios_codeseg;	/* BIOS Code Segment. */
@@ -2650,7 +2650,7 @@ static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
 {
 	int i;
 
-	printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
+	printk(" ADV_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
 	       (ulong)b, sgblockno);
 	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
 	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
@@ -2672,7 +2672,8 @@ static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
 static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 {
 	int sg_blk_cnt;
-	struct asc_sg_block *sg_ptr;
+	struct adv_sg_block *sg_ptr;
+	adv_sgblk_t *sgblkp;
 
 	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
 
@@ -2699,21 +2700,15 @@ static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 
 	/* Display the request's ADV_SG_BLOCK structures. */
 	if (q->sg_list_ptr != NULL) {
+		sgblkp = container_of(q->sg_list_ptr, adv_sgblk_t, sg_block);
 		sg_blk_cnt = 0;
-		while (1) {
-			/*
-			 * 'sg_ptr' is a physical address. Convert it to a virtual
-			 * address by indexing 'sg_blk_cnt' into the virtual address
-			 * array 'sg_list_ptr'.
-			 *
-			 * XXX - Assumes all SG physical blocks are virtually contiguous.
-			 */
-			sg_ptr =
-			    &(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);
+		while (sgblkp) {
+			sg_ptr = &sgblkp->sg_block;
 			asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
 			if (sg_ptr->sg_ptr == 0) {
 				break;
 			}
+			sgblkp = sgblkp->next_sgblkp;
 			sg_blk_cnt++;
 		}
 	}
@@ -6207,9 +6202,8 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 		/* Remove 'sgblkp' from the request list. */
 		reqp->sgblkp = sgblkp->next_sgblkp;
 
-		/* Add 'sgblkp' to the board free list. */
-		sgblkp->next_sgblkp = boardp->adv_sgblkp;
-		boardp->adv_sgblkp = sgblkp;
+		dma_pool_free(boardp->adv_sgblk_pool, sgblkp,
+			      sgblkp->sg_addr);
 	}
 
 	ASC_DBG(1, "done\n");
@@ -7903,15 +7897,16 @@ static int
 adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
 	       ADV_SCSI_REQ_Q *scsiqp, struct scsi_cmnd *scp, int use_sg)
 {
-	adv_sgblk_t *sgblkp;
+	adv_sgblk_t *sgblkp, *prev_sgblkp;
 	struct scatterlist *slp;
 	int sg_elem_cnt;
 	ADV_SG_BLOCK *sg_block, *prev_sg_block;
-	ADV_PADDR sg_block_paddr;
+	dma_addr_t sgblk_paddr;
 	int i;
 
 	slp = scsi_sglist(scp);
 	sg_elem_cnt = use_sg;
+	prev_sgblkp = NULL;
 	prev_sg_block = NULL;
 	reqp->sgblkp = NULL;
 
@@ -7921,7 +7916,9 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
 		 * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
 		 * (15) scatter-gather elements.
 		 */
-		if ((sgblkp = boardp->adv_sgblkp) == NULL) {
+		sgblkp = dma_pool_alloc(boardp->adv_sgblk_pool, GFP_ATOMIC,
+					&sgblk_paddr);
+		if (!sgblkp) {
 			ASC_DBG(1, "no free adv_sgblk_t\n");
 			ASC_STATS(scp->device->host, adv_build_nosg);
 
@@ -7932,24 +7929,16 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
 			while ((sgblkp = reqp->sgblkp) != NULL) {
 				/* Remove 'sgblkp' from the request list. */
 				reqp->sgblkp = sgblkp->next_sgblkp;
-
-				/* Add 'sgblkp' to the board free list. */
-				sgblkp->next_sgblkp = boardp->adv_sgblkp;
-				boardp->adv_sgblkp = sgblkp;
+				sgblkp->next_sgblkp = NULL;
+				dma_pool_free(boardp->adv_sgblk_pool, sgblkp,
+					      sgblkp->sg_addr);
 			}
 			return ASC_BUSY;
 		}
-
 		/* Complete 'adv_sgblk_t' board allocation. */
-		boardp->adv_sgblkp = sgblkp->next_sgblkp;
+		sgblkp->sg_addr = sgblk_paddr;
 		sgblkp->next_sgblkp = NULL;
-
-		/*
-		 * Get 8 byte aligned virtual and physical addresses
-		 * for the allocated ADV_SG_BLOCK structure.
-		 */
-		sg_block = (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);
-		sg_block_paddr = virt_to_bus(sg_block);
+		sg_block = &sgblkp->sg_block;
 
 		/*
 		 * Check if this is the first 'adv_sgblk_t' for the
@@ -7964,17 +7953,16 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
 			 * address pointers.
 			 */
 			scsiqp->sg_list_ptr = sg_block;
-			scsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);
+			scsiqp->sg_real_addr = cpu_to_le32(sgblk_paddr);
 		} else {
 			/* Request's second or later scatter-gather block. */
-			sgblkp->next_sgblkp = reqp->sgblkp;
-			reqp->sgblkp = sgblkp;
+			prev_sgblkp->next_sgblkp = sgblkp;
 
 			/*
 			 * Point the previous ADV_SG_BLOCK structure to
 			 * the newly allocated ADV_SG_BLOCK structure.
 			 */
-			prev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);
+			prev_sg_block->sg_ptr = cpu_to_le32(sgblk_paddr);
 		}
 
 		for (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {
@@ -7985,15 +7973,19 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
 			ASC_STATS_ADD(scp->device->host, xfer_sect,
 				      DIV_ROUND_UP(sg_dma_len(slp), 512));
 
-			if (--sg_elem_cnt == 0) {	/* Last ADV_SG_BLOCK and scatter-gather entry. */
+			if (--sg_elem_cnt == 0) {
+				/*
+				 * Last ADV_SG_BLOCK and scatter-gather entry.
+				 */
 				sg_block->sg_cnt = i + 1;
-				sg_block->sg_ptr = 0L;	/* Last ADV_SG_BLOCK in list. */
+				sg_block->sg_ptr = 0L; /* Last ADV_SG_BLOCK in list. */
 				return ADV_SUCCESS;
 			}
 			slp++;
 		}
 		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
 		prev_sg_block = sg_block;
+		prev_sgblkp = sgblkp;
 	}
 }
 
@@ -11157,8 +11149,7 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 {
 	struct asc_board *board = shost_priv(shost);
 	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
-	int sg_cnt = 0;
-	adv_sgblk_t *sgp;
+	size_t sgblk_pool_size;
 	int warn_code, err_code;
 
 	/*
@@ -11195,22 +11186,14 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 	 * Allocate up to ADV_TOT_SG_BLOCK request structures for
 	 * the Wide board. Each structure is about 136 bytes.
 	 */
-	board->adv_sgblkp = NULL;
-	for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
-		sgp = kmalloc(sizeof(adv_sgblk_t), GFP_KERNEL);
-
-		if (!sgp)
-			break;
-
-		sgp->next_sgblkp = board->adv_sgblkp;
-		board->adv_sgblkp = sgp;
-
-	}
+	sgblk_pool_size = sizeof(adv_sgblk_t) * ADV_TOT_SG_BLOCK;
+	board->adv_sgblk_pool = dma_pool_create("adv_sgblk", board->dev,
+						sgblk_pool_size, 32, 0);
 
-	ASC_DBG(1, "sg_cnt %d * %lu = %lu bytes\n", sg_cnt, sizeof(adv_sgblk_t),
-		 sizeof(adv_sgblk_t) * sg_cnt);
+	ASC_DBG(1, "sg_cnt %d * %lu = %lu bytes\n", ADV_TOT_SG_BLOCK,
+		sizeof(adv_sgblk_t), sgblk_pool_size);
 
-	if (!board->adv_sgblkp)
+	if (!board->adv_sgblk_pool)
 		goto kmalloc_failed;
 
 	if (adv_dvc->chip_type == ADV_CHIP_ASC3550) {
@@ -11253,10 +11236,9 @@ static void advansys_wide_free_mem(struct asc_board *board)
 				  board->adv_reqp, board->adv_reqp_addr);
 		board->adv_reqp = NULL;
 	}
-	while (board->adv_sgblkp) {
-		adv_sgblk_t *sgp = board->adv_sgblkp;
-		board->adv_sgblkp = sgp->next_sgblkp;
-		kfree(sgp);
+	if (board->adv_sgblk_pool) {
+		dma_pool_destroy(board->adv_sgblk_pool);
+		board->adv_sgblk_pool = NULL;
 	}
 }
 

commit 4b47e464510c524bcf043f0a66172894abf8801a
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:24 2015 +0200

    advansys: Use DMA-API for mapping request blocks
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0d04565dbc16..e73f7847905c 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1894,11 +1894,11 @@ typedef struct adv_sgblk {
 
 typedef struct adv_req {
 	ADV_SCSI_REQ_Q scsi_req_q;	/* Adv Library request structure. */
-	uchar align[32];	/* Request structure padding. */
+	uchar align[24];	/* Request structure padding. */
 	struct scsi_cmnd *cmndp;	/* Mid-Level SCSI command pointer. */
+	dma_addr_t req_addr;
 	adv_sgblk_t *sgblkp;	/* Adv Library scatter-gather pointer. */
-	struct adv_req *next_reqp;	/* Next Request Structure. */
-} adv_req_t;
+} adv_req_t __aligned(32);
 
 /*
  * Adapter operation variable structure.
@@ -2379,6 +2379,8 @@ struct asc_board {
 	void __iomem *ioremap_addr;	/* I/O Memory remap address. */
 	ushort ioport;		/* I/O Port address. */
 	adv_req_t *adv_reqp;	/* Request structures. */
+	dma_addr_t adv_reqp_addr;
+	size_t adv_reqp_size;
 	adv_sgblk_t *adv_sgblkp;	/* Scatter-gather structures. */
 	ushort bios_signature;	/* BIOS Signature. */
 	ushort bios_version;	/* BIOS Version. */
@@ -4383,6 +4385,17 @@ static ADV_CARR_T *adv_get_next_carrier(struct adv_dvc_var *adv_dvc)
 	return carrp;
 }
 
+/*
+ * 'offset' is the index in the request pointer array
+ */
+static adv_req_t * adv_get_reqp(struct adv_dvc_var *adv_dvc, u32 offset)
+{
+	struct asc_board *boardp = adv_dvc->drv_ptr;
+
+	BUG_ON(offset > adv_dvc->max_host_qng);
+	return &boardp->adv_reqp[offset];
+}
+
 /*
  * Send an idle command to the chip and wait for completion.
  *
@@ -6229,6 +6242,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 	ADV_CARR_T *free_carrp;
 	ADV_VADDR irq_next_vpa;
 	ADV_SCSI_REQ_Q *scsiq;
+	adv_req_t *reqp;
 
 	iop_base = asc_dvc->iop_base;
 
@@ -6281,8 +6295,11 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
 		 * in AdvExeScsiQueue().
 		 */
-		scsiq = (ADV_SCSI_REQ_Q *)
-		    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));
+		u32 pa_offset = le32_to_cpu(asc_dvc->irq_sp->areq_vpa);
+		ASC_DBG(1, "irq_sp %p areq_vpa %u\n",
+			asc_dvc->irq_sp, pa_offset);
+		reqp = adv_get_reqp(asc_dvc, pa_offset);
+		scsiq = &reqp->scsi_req_q;
 
 		/*
 		 * Request finished with good status and the queue was not
@@ -7883,18 +7900,16 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
  *      ADV_ERROR(-1) - SG List creation failed
  */
 static int
-adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
-	       int use_sg)
+adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,
+	       ADV_SCSI_REQ_Q *scsiqp, struct scsi_cmnd *scp, int use_sg)
 {
 	adv_sgblk_t *sgblkp;
-	ADV_SCSI_REQ_Q *scsiqp;
 	struct scatterlist *slp;
 	int sg_elem_cnt;
 	ADV_SG_BLOCK *sg_block, *prev_sg_block;
 	ADV_PADDR sg_block_paddr;
 	int i;
 
-	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
 	slp = scsi_sglist(scp);
 	sg_elem_cnt = use_sg;
 	prev_sg_block = NULL;
@@ -7994,7 +8009,7 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
  */
 static int
 adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
-	      ADV_SCSI_REQ_Q **adv_scsiqpp)
+	      adv_req_t **adv_reqpp)
 {
 	u32 srb_tag = scp->request->tag;
 	adv_req_t *reqp;
@@ -8014,10 +8029,9 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 		return ASC_BUSY;
 	}
 
-	/*
-	 * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.
-	 */
-	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
+	reqp->req_addr = boardp->adv_reqp_addr + (srb_tag * sizeof(adv_req_t));
+
+	scsiqp = &reqp->scsi_req_q;
 
 	/*
 	 * Initialize the structure.
@@ -8030,7 +8044,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	scsiqp->srb_tag = srb_tag;
 
 	/*
-	 * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
+	 * Set 'host_scribble' to point to the adv_req_t structure.
 	 */
 	reqp->cmndp = scp;
 	scp->host_scribble = (void *)reqp;
@@ -8084,7 +8098,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 
 		scsiqp->data_cnt = cpu_to_le32(scsi_bufflen(scp));
 
-		ret = adv_get_sglist(boardp, reqp, scp, use_sg);
+		ret = adv_get_sglist(boardp, reqp, scsiqp, scp, use_sg);
 		if (ret != ADV_SUCCESS) {
 			scsi_dma_unmap(scp);
 			scp->result = HOST_BYTE(DID_ERROR);
@@ -8102,7 +8116,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
 	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
-	*adv_scsiqpp = scsiqp;
+	*adv_reqpp = reqp;
 
 	return ASC_NOERROR;
 }
@@ -8692,11 +8706,11 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
  *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure
  *                       host IC error.
  */
-static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
+static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, adv_req_t *reqp)
 {
 	AdvPortAddr iop_base;
-	ADV_PADDR req_paddr;
 	ADV_CARR_T *new_carrp;
+	ADV_SCSI_REQ_Q *scsiq = &reqp->scsi_req_q;
 
 	/*
 	 * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
@@ -8726,14 +8740,9 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	 */
 	scsiq->a_flag &= ~ADV_SCSIQ_DONE;
 
-	req_paddr = virt_to_bus(scsiq);
-	BUG_ON(req_paddr & 31);
-	/* Wait for assertion before making little-endian */
-	req_paddr = cpu_to_le32(req_paddr);
-
 	/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
-	scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
-	scsiq->scsiq_rptr = req_paddr;
+	scsiq->scsiq_ptr = cpu_to_le32(scsiq->srb_tag);
+	scsiq->scsiq_rptr = cpu_to_le32(reqp->req_addr);
 
 	scsiq->carr_va = asc_dvc->icq_sp->carr_va;
 	scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
@@ -8743,7 +8752,7 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	 * the microcode. The newly allocated stopper will become the new
 	 * stopper.
 	 */
-	asc_dvc->icq_sp->areq_vpa = req_paddr;
+	asc_dvc->icq_sp->areq_vpa = scsiq->scsiq_rptr;
 
 	/*
 	 * Set the 'next_vpa' pointer for the old stopper to be the
@@ -8810,9 +8819,9 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		err_code = asc_dvc->err_code;
 	} else {
 		ADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;
-		ADV_SCSI_REQ_Q *adv_scsiqp;
+		adv_req_t *adv_reqp;
 
-		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
+		switch (adv_build_req(boardp, scp, &adv_reqp)) {
 		case ASC_NOERROR:
 			ASC_DBG(3, "adv_build_req ASC_NOERROR\n");
 			break;
@@ -8832,7 +8841,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			return ASC_ERROR;
 		}
 
-		ret = AdvExeScsiQueue(adv_dvc, adv_scsiqp);
+		ret = AdvExeScsiQueue(adv_dvc, adv_reqp);
 		err_code = adv_dvc->err_code;
 	}
 
@@ -8847,6 +8856,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		ASC_DBG(1, "ExeScsiQueue() ASC_NOERROR\n");
 		break;
 	case ASC_BUSY:
+		ASC_DBG(1, "ExeScsiQueue() ASC_BUSY\n");
 		ASC_STATS(scp->device->host, exe_busy);
 		break;
 	case ASC_ERROR:
@@ -11147,8 +11157,6 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 {
 	struct asc_board *board = shost_priv(shost);
 	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
-	int req_cnt = 0;
-	adv_req_t *reqp = NULL;
 	int sg_cnt = 0;
 	adv_sgblk_t *sgp;
 	int warn_code, err_code;
@@ -11169,20 +11177,19 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 	 * board. The total size is about 16 KB, so allocate all at once.
 	 * If the allocation fails decrement and try again.
 	 */
-	for (req_cnt = adv_dvc->max_host_qng; req_cnt > 0; req_cnt--) {
-		reqp = kzalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);
-
-		ASC_DBG(1, "reqp 0x%p, req_cnt %d, bytes %lu\n", reqp, req_cnt,
-			 (ulong)sizeof(adv_req_t) * req_cnt);
-
-		if (reqp)
-			break;
+	board->adv_reqp_size = adv_dvc->max_host_qng * sizeof(adv_req_t);
+	if (board->adv_reqp_size & 0x1f) {
+		ASC_DBG(1, "unaligned reqp %lu bytes\n", sizeof(adv_req_t));
+		board->adv_reqp_size = ADV_32BALIGN(board->adv_reqp_size);
 	}
+	board->adv_reqp = dma_alloc_coherent(board->dev, board->adv_reqp_size,
+		&board->adv_reqp_addr, GFP_KERNEL);
 
-	if (!reqp)
+	if (!board->adv_reqp)
 		goto kmalloc_failed;
 
-	board->adv_reqp = reqp;
+	ASC_DBG(1, "reqp 0x%p, req_cnt %d, bytes %lu\n", board->adv_reqp,
+		adv_dvc->max_host_qng, board->adv_reqp_size);
 
 	/*
 	 * Allocate up to ADV_TOT_SG_BLOCK request structures for
@@ -11206,16 +11213,6 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 	if (!board->adv_sgblkp)
 		goto kmalloc_failed;
 
-	/*
-	 * Point 'adv_reqp' to the request structures and
-	 * link them together.
-	 */
-	req_cnt--;
-	reqp[req_cnt].next_reqp = NULL;
-	for (; req_cnt > 0; req_cnt--) {
-		reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
-	}
-
 	if (adv_dvc->chip_type == ADV_CHIP_ASC3550) {
 		ASC_DBG(2, "AdvInitAsc3550Driver()\n");
 		warn_code = AdvInitAsc3550Driver(adv_dvc);
@@ -11251,8 +11248,11 @@ static void advansys_wide_free_mem(struct asc_board *board)
 				  adv_dvc->carrier, adv_dvc->carrier_addr);
 		adv_dvc->carrier = NULL;
 	}
-	kfree(board->adv_reqp);
-	board->adv_reqp = NULL;
+	if (board->adv_reqp) {
+		dma_free_coherent(board->dev, board->adv_reqp_size,
+				  board->adv_reqp, board->adv_reqp_addr);
+		board->adv_reqp = NULL;
+	}
 	while (board->adv_sgblkp) {
 		adv_sgblk_t *sgp = board->adv_sgblkp;
 		board->adv_sgblkp = sgp->next_sgblkp;

commit 98b96a7d99c86d4097db57fa38fc265f17c9d134
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:23 2015 +0200

    advansys: Use DMA-API for carrier buffer
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index dba8c1a3b518..0d04565dbc16 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -963,8 +963,6 @@ typedef struct asc_mc_saved {
 #define ADV_MEM_WRITEW(addr, word) writew(word, addr)
 #define ADV_MEM_WRITEDW(addr, dword) writel(dword, addr)
 
-#define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 15)
-
 /*
  * Define total number of simultaneous maximum element scatter-gather
  * request blocks per wide adapter. ASC_DEF_MAX_HOST_QNG (253) is the
@@ -1745,16 +1743,16 @@ typedef struct adveep_38C1600_config {
  * little-endian.
  */
 typedef struct adv_carr_t {
-	ADV_VADDR carr_va;	/* Carrier Virtual Address */
-	ADV_PADDR carr_pa;	/* Carrier Physical Address */
-	ADV_VADDR areq_vpa;	/* ASC_SCSI_REQ_Q Virtual or Physical Address */
+	__le32 carr_va;	/* Carrier Virtual Address */
+	__le32 carr_pa;	/* Carrier Physical Address */
+	__le32 areq_vpa;	/* ASC_SCSI_REQ_Q Virtual or Physical Address */
 	/*
 	 * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer
 	 *
 	 * next_vpa [3:1]             Reserved Bits
 	 * next_vpa [0]               Done Flag set in Response Queue.
 	 */
-	ADV_VADDR next_vpa;
+	__le32 next_vpa;
 } ADV_CARR_T;
 
 /*
@@ -1768,11 +1766,14 @@ typedef struct adv_carr_t {
 
 #define ASC_GET_CARRP(carrp) ((carrp) & ASC_NEXT_VPA_MASK)
 
-#define ADV_CARRIER_NUM_PAGE_CROSSING \
-    (((ADV_CARRIER_COUNT * sizeof(ADV_CARR_T)) + (PAGE_SIZE - 1))/PAGE_SIZE)
+/*
+ * Each carrier is 64 bytes, and we need three additional
+ * carrier for icq, irq, and the termination carrier.
+ */
+#define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 3)
 
 #define ADV_CARRIER_BUFSIZE \
-    ((ADV_CARRIER_COUNT + ADV_CARRIER_NUM_PAGE_CROSSING) * sizeof(ADV_CARR_T))
+	(ADV_CARRIER_COUNT * sizeof(ADV_CARR_T))
 
 /*
  * ASC_SCSI_REQ_Q 'a_flag' definitions
@@ -1845,7 +1846,7 @@ typedef struct adv_scsi_req_q {
 	ADV_PADDR data_addr;	/* Data buffer physical address. */
 	ADV_DCNT data_cnt;	/* Data count. Ucode sets to residual. */
 	__le32 sense_addr;
-	ADV_PADDR carr_pa;
+	__le32 carr_pa;
 	uchar mflag;
 	uchar sense_len;
 	uchar cdb_len;		/* SCSI CDB length. Must <= 16 bytes. */
@@ -1856,19 +1857,18 @@ typedef struct adv_scsi_req_q {
 	uchar sg_working_ix;
 	uchar cdb[12];		/* SCSI CDB bytes 0-11. */
 	ADV_PADDR sg_real_addr;	/* SG list physical address. */
-	ADV_PADDR scsiq_rptr;
+	__le32 scsiq_rptr;
 	uchar cdb16[4];		/* SCSI CDB bytes 12-15. */
-	ADV_VADDR scsiq_ptr;
-	ADV_VADDR carr_va;
+	__le32 scsiq_ptr;
+	__le32 carr_va;
 	/*
 	 * End of microcode structure - 60 bytes. The rest of the structure
 	 * is used by the Adv Library and ignored by the microcode.
 	 */
 	u32 srb_tag;
-	ADV_SG_BLOCK *sg_list_ptr;	/* SG list virtual address. */
-	char *vdata_addr;	/* Data buffer virtual address. */
 	uchar a_flag;
-	uchar pad[2];		/* Pad out to a word boundary. */
+	uchar pad[3];		/* Pad out to a word boundary. */
+	ADV_SG_BLOCK *sg_list_ptr;	/* SG list virtual address. */
 } ADV_SCSI_REQ_Q;
 
 /*
@@ -1935,8 +1935,9 @@ typedef struct adv_dvc_var {
 	uchar chip_scsi_id;	/* chip SCSI target ID */
 	uchar chip_type;
 	uchar bist_err_code;
-	ADV_CARR_T *carrier_buf;
+	ADV_CARR_T *carrier;
 	ADV_CARR_T *carr_freelist;	/* Carrier free list. */
+	dma_addr_t carrier_addr;
 	ADV_CARR_T *icq_sp;	/* Initiator command queue stopper pointer. */
 	ADV_CARR_T *irq_sp;	/* Initiator response queue stopper pointer. */
 	ushort carr_pending_cnt;	/* Count of pending carriers. */
@@ -2467,12 +2468,11 @@ static void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
 	printk("  start_motor 0x%x, scsi_reset_wait 0x%x\n",
 	       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);
 
-	printk("  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
+	printk("  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%p\n",
 	       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,
-	       (ulong)h->carr_freelist);
+	       h->carr_freelist);
 
-	printk("  icq_sp 0x%lx, irq_sp 0x%lx\n",
-	       (ulong)h->icq_sp, (ulong)h->irq_sp);
+	printk("  icq_sp 0x%p, irq_sp 0x%p\n", h->icq_sp, h->irq_sp);
 
 	printk("  no_scam 0x%x, tagqng_able 0x%x\n",
 	       (unsigned)h->no_scam, (unsigned)h->tagqng_able);
@@ -2677,8 +2677,8 @@ static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 	printk("  target_id %u, target_lun %u, srb_tag 0x%x, a_flag 0x%x\n",
 	       q->target_id, q->target_lun, q->srb_tag, q->a_flag);
 
-	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
-	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
+	printk("  cntl 0x%x, data_addr 0x%lx\n",
+	       q->cntl, (ulong)le32_to_cpu(q->data_addr));
 
 	printk("  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
 	       (ulong)le32_to_cpu(q->data_cnt),
@@ -4326,38 +4326,61 @@ static int AdvLoadMicrocode(AdvPortAddr iop_base, const unsigned char *buf,
 	return 0;
 }
 
-static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
+static void AdvBuildCarrierFreelist(struct adv_dvc_var *adv_dvc)
 {
-	ADV_CARR_T *carrp;
-	ADV_SDCNT buf_size;
-	ADV_PADDR carr_paddr;
+	off_t carr_offset = 0, next_offset;
+	dma_addr_t carr_paddr;
+	int carr_num = ADV_CARRIER_BUFSIZE / sizeof(ADV_CARR_T), i;
 
-	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-	asc_dvc->carr_freelist = NULL;
-	if (carrp == asc_dvc->carrier_buf) {
-		buf_size = ADV_CARRIER_BUFSIZE;
-	} else {
-		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+	for (i = 0; i < carr_num; i++) {
+		carr_offset = i * sizeof(ADV_CARR_T);
+		/* Get physical address of the carrier 'carrp'. */
+		carr_paddr = adv_dvc->carrier_addr + carr_offset;
+
+		adv_dvc->carrier[i].carr_pa = cpu_to_le32(carr_paddr);
+		adv_dvc->carrier[i].carr_va = cpu_to_le32(carr_offset);
+		adv_dvc->carrier[i].areq_vpa = 0;
+		next_offset = carr_offset + sizeof(ADV_CARR_T);
+		if (i == carr_num)
+			next_offset = ~0;
+		adv_dvc->carrier[i].next_vpa = cpu_to_le32(next_offset);
 	}
+	/*
+	 * We cannot have a carrier with 'carr_va' of '0', as
+	 * a reference to this carrier would be interpreted as
+	 * list termination.
+	 * So start at carrier 1 with the freelist.
+	 */
+	adv_dvc->carr_freelist = &adv_dvc->carrier[1];
+}
 
-	do {
-		/* Get physical address of the carrier 'carrp'. */
-		carr_paddr = cpu_to_le32(virt_to_bus(carrp));
+static ADV_CARR_T *adv_get_carrier(struct adv_dvc_var *adv_dvc, u32 offset)
+{
+	int index;
 
-		buf_size -= sizeof(ADV_CARR_T);
+	BUG_ON(offset > ADV_CARRIER_BUFSIZE);
 
-		carrp->carr_pa = carr_paddr;
-		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+	index = offset / sizeof(ADV_CARR_T);
+	return &adv_dvc->carrier[index];
+}
 
-		/*
-		 * Insert the carrier at the beginning of the freelist.
-		 */
-		carrp->next_vpa =
-			cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-		asc_dvc->carr_freelist = carrp;
+static ADV_CARR_T *adv_get_next_carrier(struct adv_dvc_var *adv_dvc)
+{
+	ADV_CARR_T *carrp = adv_dvc->carr_freelist;
+	u32 next_vpa = le32_to_cpu(carrp->next_vpa);
+
+	if (next_vpa == 0 || next_vpa == ~0) {
+		ASC_DBG(1, "invalid vpa offset 0x%x\n", next_vpa);
+		return NULL;
+	}
 
-		carrp++;
-	} while (buf_size > 0);
+	adv_dvc->carr_freelist = adv_get_carrier(adv_dvc, next_vpa);
+	/*
+	 * insert stopper carrier to terminate list
+	 */
+	carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	return carrp;
 }
 
 /*
@@ -4846,17 +4869,11 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
 	 */
 
-	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+	asc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);
+	if (!asc_dvc->icq_sp) {
 		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
 		return ADV_ERROR;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
-
-	/*
-	 * The first command issued will be placed in the stopper carrier.
-	 */
-	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
 	 * Set RISC ICQ physical address start value.
@@ -4866,21 +4883,11 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	/*
 	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
 	 */
-	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+	asc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);
+	if (!asc_dvc->irq_sp) {
 		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
 		return ADV_ERROR;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
-
-	/*
-	 * The first command completed by the RISC will be placed in
-	 * the stopper.
-	 *
-	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-	 * completed the RISC will set the ASC_RQ_STOPPER bit.
-	 */
-	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
 	 * Set RISC IRQ physical address start value.
@@ -5343,17 +5350,12 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
 	 */
 
-	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+	asc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);
+	if (!asc_dvc->icq_sp) {
+		ASC_DBG(0, "Failed to get ICQ carrier\n");
 		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
 		return ADV_ERROR;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
-
-	/*
-	 * The first command issued will be placed in the stopper carrier.
-	 */
-	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
 	 * Set RISC ICQ physical address start value.
@@ -5364,21 +5366,12 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	/*
 	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
 	 */
-	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+	asc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);
+	if (!asc_dvc->irq_sp) {
+		ASC_DBG(0, "Failed to get IRQ carrier\n");
 		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
 		return ADV_ERROR;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
-
-	/*
-	 * The first command completed by the RISC will be placed in
-	 * the stopper.
-	 *
-	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-	 * completed the RISC will set the ASC_RQ_STOPPER bit.
-	 */
-	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
 	 * Set RISC IRQ physical address start value.
@@ -5853,17 +5846,11 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	/*
 	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
 	 */
-	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+	asc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);
+	if (!asc_dvc->icq_sp) {
 		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
 		return ADV_ERROR;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
-
-	/*
-	 * The first command issued will be placed in the stopper carrier.
-	 */
-	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
 	 * Set RISC ICQ physical address start value. Initialize the
@@ -5877,21 +5864,11 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	/*
 	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
 	 */
-	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+	asc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);
+	if (!asc_dvc->irq_sp) {
 		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
 		return ADV_ERROR;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
-
-	/*
-	 * The first command completed by the RISC will be placed in
-	 * the stopper.
-	 *
-	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-	 * completed the RISC will set the ASC_RQ_STOPPER bit.
-	 */
-	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
 	 * Set RISC IRQ physical address start value.
@@ -6324,11 +6301,10 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * stopper carrier.
 		 */
 		free_carrp = asc_dvc->irq_sp;
-		asc_dvc->irq_sp = (ADV_CARR_T *)
-		    ADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));
+		asc_dvc->irq_sp = adv_get_carrier(asc_dvc,
+						  ASC_GET_CARRP(irq_next_vpa));
 
-		free_carrp->next_vpa =
-		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		free_carrp->next_vpa = asc_dvc->carr_freelist->carr_va;
 		asc_dvc->carr_freelist = free_carrp;
 		asc_dvc->carr_pending_cnt--;
 
@@ -8089,7 +8065,6 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 		/* Zero-length transfer */
 		reqp->sgblkp = NULL;
 		scsiqp->data_cnt = 0;
-		scsiqp->vdata_addr = NULL;
 
 		scsiqp->data_addr = 0;
 		scsiqp->sg_list_ptr = NULL;
@@ -8738,19 +8713,13 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	 * Allocate a carrier ensuring at least one carrier always
 	 * remains on the freelist and initialize fields.
 	 */
-	if ((new_carrp = asc_dvc->carr_freelist) == NULL) {
+	new_carrp = adv_get_next_carrier(asc_dvc);
+	if (!new_carrp) {
+		ASC_DBG(1, "No free carriers\n");
 		return ADV_BUSY;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));
-	asc_dvc->carr_pending_cnt++;
 
-	/*
-	 * Set the carrier to be a stopper by setting 'next_vpa'
-	 * to the stopper value. The current stopper will be changed
-	 * below to point to the new stopper.
-	 */
-	new_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	asc_dvc->carr_pending_cnt++;
 
 	/*
 	 * Clear the ADV_SCSI_REQ_Q done flag.
@@ -8766,11 +8735,7 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
 	scsiq->scsiq_rptr = req_paddr;
 
-	scsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));
-	/*
-	 * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
-	 * order during initialization.
-	 */
+	scsiq->carr_va = asc_dvc->icq_sp->carr_va;
 	scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
 
 	/*
@@ -11190,12 +11155,13 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 
 	/*
 	 * Allocate buffer carrier structures. The total size
-	 * is about 4 KB, so allocate all at once.
+	 * is about 8 KB, so allocate all at once.
 	 */
-	adv_dvc->carrier_buf = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
-	ASC_DBG(1, "carrier_buf 0x%p\n", adv_dvc->carrier_buf);
+	adv_dvc->carrier = dma_alloc_coherent(board->dev,
+		ADV_CARRIER_BUFSIZE, &adv_dvc->carrier_addr, GFP_KERNEL);
+	ASC_DBG(1, "carrier 0x%p\n", adv_dvc->carrier);
 
-	if (!adv_dvc->carrier_buf)
+	if (!adv_dvc->carrier)
 		goto kmalloc_failed;
 
 	/*
@@ -11279,8 +11245,12 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 static void advansys_wide_free_mem(struct asc_board *board)
 {
 	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
-	kfree(adv_dvc->carrier_buf);
-	adv_dvc->carrier_buf = NULL;
+
+	if (adv_dvc->carrier) {
+		dma_free_coherent(board->dev, ADV_CARRIER_BUFSIZE,
+				  adv_dvc->carrier, adv_dvc->carrier_addr);
+		adv_dvc->carrier = NULL;
+	}
 	kfree(board->adv_reqp);
 	board->adv_reqp = NULL;
 	while (board->adv_sgblkp) {

commit 811ddc057aac7228858fbb9cdd88137714dd807a
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:22 2015 +0200

    advansys: use DMA-API for mapping sense buffer
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index b595e8bc858a..dba8c1a3b518 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1844,7 +1844,7 @@ typedef struct adv_scsi_req_q {
 	uchar target_lun;	/* Device target logical unit number. */
 	ADV_PADDR data_addr;	/* Data buffer physical address. */
 	ADV_DCNT data_cnt;	/* Data count. Ucode sets to residual. */
-	ADV_PADDR sense_addr;
+	__le32 sense_addr;
 	ADV_PADDR carr_pa;
 	uchar mflag;
 	uchar sense_len;
@@ -6084,6 +6084,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	adv_sgblk_t *sgblkp;
 	struct scsi_cmnd *scp;
 	ADV_DCNT resid_cnt;
+	dma_addr_t sense_addr;
 
 	ASC_DBG(1, "adv_dvc_varp 0x%p, scsiqp 0x%p\n",
 		adv_dvc_varp, scsiqp);
@@ -6121,6 +6122,10 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	ASC_STATS(boardp->shost, callback);
 	ASC_DBG(1, "shost 0x%p\n", boardp->shost);
 
+	sense_addr = le32_to_cpu(scsiqp->sense_addr);
+	dma_unmap_single(boardp->dev, sense_addr,
+			 SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
+
 	/*
 	 * 'done_status' contains the command's ending status.
 	 */
@@ -8018,9 +8023,9 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	u32 srb_tag = scp->request->tag;
 	adv_req_t *reqp;
 	ADV_SCSI_REQ_Q *scsiqp;
-	int i;
 	int ret;
 	int use_sg;
+	dma_addr_t sense_addr;
 
 	/*
 	 * Allocate an adv_req_t structure from the board to execute
@@ -8061,19 +8066,21 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	/* Set CDB length and copy it to the request structure.  */
 	scsiqp->cdb_len = scp->cmd_len;
 	/* Copy first 12 CDB bytes to cdb[]. */
-	for (i = 0; i < scp->cmd_len && i < 12; i++) {
-		scsiqp->cdb[i] = scp->cmnd[i];
-	}
+	memcpy(scsiqp->cdb, scp->cmnd, scp->cmd_len < 12 ? scp->cmd_len : 12);
 	/* Copy last 4 CDB bytes, if present, to cdb16[]. */
-	for (; i < scp->cmd_len; i++) {
-		scsiqp->cdb16[i - 12] = scp->cmnd[i];
+	if (scp->cmd_len > 12) {
+		int cdb16_len = scp->cmd_len - 12;
+
+		memcpy(scsiqp->cdb16, &scp->cmnd[12], cdb16_len);
 	}
 
 	scsiqp->target_id = scp->device->id;
 	scsiqp->target_lun = scp->device->lun;
 
-	scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-	scsiqp->sense_len = SCSI_SENSE_BUFFERSIZE;
+	sense_addr = dma_map_single(boardp->dev, scp->sense_buffer,
+				    SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
+	scsiqp->sense_addr = cpu_to_le32(sense_addr);
+	scsiqp->sense_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);
 
 	/* Build ADV_SCSI_REQ_Q */
 

commit 9c17c62aedb003cb7ea644c15f8cbb249c29c8ae
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:21 2015 +0200

    advansys: use shared host tag map for command lookup
    
    Convert to use a shared host tag map for command lookup. This
    saves us having an internal structure and avoid the command
    pointer abuse.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e936f489a267..b595e8bc858a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -315,7 +315,7 @@ typedef struct asc_scsiq_1 {
 } ASC_SCSIQ_1;
 
 typedef struct asc_scsiq_2 {
-	ASC_VADDR srb_ptr;
+	u32 srb_tag;
 	uchar target_ix;
 	uchar flag;
 	uchar cdb_len;
@@ -592,8 +592,6 @@ typedef struct asc_dvc_var {
 	uchar min_sdtr_index;
 	uchar max_sdtr_index;
 	struct asc_board *drv_ptr;
-	int ptr_map_count;
-	void **ptr_map;
 	ASC_DCNT uc_break;
 } ASC_DVC_VAR;
 
@@ -1866,7 +1864,7 @@ typedef struct adv_scsi_req_q {
 	 * End of microcode structure - 60 bytes. The rest of the structure
 	 * is used by the Adv Library and ignored by the microcode.
 	 */
-	ADV_VADDR srb_ptr;
+	u32 srb_tag;
 	ADV_SG_BLOCK *sg_list_ptr;	/* SG list virtual address. */
 	char *vdata_addr;	/* Data buffer virtual address. */
 	uchar a_flag;
@@ -1877,9 +1875,9 @@ typedef struct adv_scsi_req_q {
  * The following two structures are used to process Wide Board requests.
  *
  * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library
- * and microcode with the ADV_SCSI_REQ_Q field 'srb_ptr' pointing to the
- * adv_req_t. The adv_req_t structure 'cmndp' field in turn points to the
- * Mid-Level SCSI request structure.
+ * and microcode with the ADV_SCSI_REQ_Q field 'srb_tag' set to the
+ * SCSI request tag. The adv_req_t structure 'cmndp' field in turn points
+ * to the Mid-Level SCSI request structure.
  *
  * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each
  * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux
@@ -1942,7 +1940,6 @@ typedef struct adv_dvc_var {
 	ADV_CARR_T *icq_sp;	/* Initiator command queue stopper pointer. */
 	ADV_CARR_T *irq_sp;	/* Initiator response queue stopper pointer. */
 	ushort carr_pending_cnt;	/* Count of pending carriers. */
-	struct adv_req *orig_reqp;	/* adv_req_t memory block. */
 	/*
 	 * Note: The following fields will not be used after initialization. The
 	 * driver may discard the buffer after initialization is done.
@@ -2068,8 +2065,8 @@ do { \
     AdvReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)
 
 /*
- * Abort an SRB in the chip's RISC Memory. The 'srb_ptr' argument must
- * match the ASC_SCSI_REQ_Q 'srb_ptr' field.
+ * Abort an SRB in the chip's RISC Memory. The 'srb_tag' argument must
+ * match the ASC_SCSI_REQ_Q 'srb_tag' field.
  *
  * If the request has not yet been sent to the device it will simply be
  * aborted from RISC memory. If the request is disconnected it will be
@@ -2079,9 +2076,9 @@ do { \
  *      ADV_TRUE(1) - Queue was successfully aborted.
  *      ADV_FALSE(0) - Queue was not found on the active queue list.
  */
-#define AdvAbortQueue(asc_dvc, scsiq) \
-        AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \
-                       (ADV_DCNT) (scsiq))
+#define AdvAbortQueue(asc_dvc, srb_tag) \
+     AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \
+		    (ADV_DCNT) (srb_tag))
 
 /*
  * Send a Bus Device Reset Message to the specified target ID.
@@ -2095,8 +2092,8 @@ do { \
  *                     are not purged.
  */
 #define AdvResetDevice(asc_dvc, target_id) \
-        AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET, \
-                    (ADV_DCNT) (target_id))
+     AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET,	\
+		    (ADV_DCNT) (target_id))
 
 /*
  * SCSI Wide Type definition.
@@ -2345,6 +2342,7 @@ struct asc_stats {
  */
 struct asc_board {
 	struct device *dev;
+	struct Scsi_Host *shost;
 	uint flags;		/* Board flags */
 	unsigned int irq;
 	union {
@@ -2599,8 +2597,8 @@ static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
 	printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);
 
 	printk
-	    (" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
-	     q->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,
+	    (" target_ix 0x%x, target_lun %u, srb_tag 0x%x, tag_code 0x%x,\n",
+	     q->q2.target_ix, q->q1.target_lun, q->q2.srb_tag,
 	     q->q2.tag_code);
 
 	printk
@@ -2633,8 +2631,8 @@ static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
 static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
 {
 	printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);
-	printk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
-	       (ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
+	printk(" srb_tag 0x%x, target_ix %u, cdb_len %u, tag_code %u,\n",
+	       q->d2.srb_tag, q->d2.target_ix, q->d2.cdb_len,
 	       q->d2.tag_code);
 	printk
 	    (" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
@@ -2676,8 +2674,8 @@ static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 
 	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
 
-	printk("  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
-	       q->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);
+	printk("  target_id %u, target_lun %u, srb_tag 0x%x, a_flag 0x%x\n",
+	       q->target_id, q->target_lun, q->srb_tag, q->a_flag);
 
 	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
 	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
@@ -2720,59 +2718,6 @@ static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 }
 #endif /* ADVANSYS_DEBUG */
 
-/*
- * The advansys chip/microcode contains a 32-bit identifier for each command
- * known as the 'srb'.  I don't know what it stands for.  The driver used
- * to encode the scsi_cmnd pointer by calling virt_to_bus and retrieve it
- * with bus_to_virt.  Now the driver keeps a per-host map of integers to
- * pointers.  It auto-expands when full, unless it can't allocate memory.
- * Note that an srb of 0 is treated specially by the chip/firmware, hence
- * the return of i+1 in this routine, and the corresponding subtraction in
- * the inverse routine.
- */
-#define BAD_SRB 0
-static u32 advansys_ptr_to_srb(struct asc_dvc_var *asc_dvc, void *ptr)
-{
-	int i;
-	void **new_ptr;
-
-	for (i = 0; i < asc_dvc->ptr_map_count; i++) {
-		if (!asc_dvc->ptr_map[i])
-			goto out;
-	}
-
-	if (asc_dvc->ptr_map_count == 0)
-		asc_dvc->ptr_map_count = 1;
-	else
-		asc_dvc->ptr_map_count *= 2;
-
-	new_ptr = krealloc(asc_dvc->ptr_map,
-			asc_dvc->ptr_map_count * sizeof(void *), GFP_ATOMIC);
-	if (!new_ptr)
-		return BAD_SRB;
-	asc_dvc->ptr_map = new_ptr;
- out:
-	ASC_DBG(3, "Putting ptr %p into array offset %d\n", ptr, i);
-	asc_dvc->ptr_map[i] = ptr;
-	return i + 1;
-}
-
-static void * advansys_srb_to_ptr(struct asc_dvc_var *asc_dvc, u32 srb)
-{
-	void *ptr;
-
-	srb--;
-	if (srb >= asc_dvc->ptr_map_count) {
-		printk("advansys: bad SRB %u, max %u\n", srb,
-							asc_dvc->ptr_map_count);
-		return NULL;
-	}
-	ptr = asc_dvc->ptr_map[srb];
-	asc_dvc->ptr_map[srb] = NULL;
-	ASC_DBG(3, "Returning ptr %p from array offset %d\n", ptr, srb);
-	return ptr;
-}
-
 /*
  * advansys_info()
  *
@@ -6133,15 +6078,15 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
  */
 static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 {
-	struct asc_board *boardp;
+	struct asc_board *boardp = adv_dvc_varp->drv_ptr;
+	u32 srb_tag;
 	adv_req_t *reqp;
 	adv_sgblk_t *sgblkp;
 	struct scsi_cmnd *scp;
-	struct Scsi_Host *shost;
 	ADV_DCNT resid_cnt;
 
-	ASC_DBG(1, "adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
-		 (ulong)adv_dvc_varp, (ulong)scsiqp);
+	ASC_DBG(1, "adv_dvc_varp 0x%p, scsiqp 0x%p\n",
+		adv_dvc_varp, scsiqp);
 	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
 
 	/*
@@ -6149,22 +6094,9 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	 * completed. The adv_req_t structure actually contains the
 	 * completed ADV_SCSI_REQ_Q structure.
 	 */
-	reqp = (adv_req_t *)ADV_U32_TO_VADDR(scsiqp->srb_ptr);
-	ASC_DBG(1, "reqp 0x%lx\n", (ulong)reqp);
-	if (reqp == NULL) {
-		ASC_PRINT("adv_isr_callback: reqp is NULL\n");
-		return;
-	}
+	srb_tag = le32_to_cpu(scsiqp->srb_tag);
+	scp = scsi_host_find_tag(boardp->shost, scsiqp->srb_tag);
 
-	/*
-	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
-	 * command that has been completed.
-	 *
-	 * Note: The adv_req_t request structure and adv_sgblk_t structure,
-	 * if any, are dropped, because a board structure pointer can not be
-	 * determined.
-	 */
-	scp = reqp->cmndp;
 	ASC_DBG(1, "scp 0x%p\n", scp);
 	if (scp == NULL) {
 		ASC_PRINT
@@ -6173,12 +6105,21 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	}
 	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
 
-	shost = scp->device->host;
-	ASC_STATS(shost, callback);
-	ASC_DBG(1, "shost 0x%p\n", shost);
+	reqp = (adv_req_t *)scp->host_scribble;
+	ASC_DBG(1, "reqp 0x%lx\n", (ulong)reqp);
+	if (reqp == NULL) {
+		ASC_PRINT("adv_isr_callback: reqp is NULL\n");
+		return;
+	}
+	/*
+	 * Remove backreferences to avoid duplicate
+	 * command completions.
+	 */
+	scp->host_scribble = NULL;
+	reqp->cmndp = NULL;
 
-	boardp = shost_priv(shost);
-	BUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);
+	ASC_STATS(boardp->shost, callback);
+	ASC_DBG(1, "shost 0x%p\n", boardp->shost);
 
 	/*
 	 * 'done_status' contains the command's ending status.
@@ -6276,13 +6217,6 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 		boardp->adv_sgblkp = sgblkp;
 	}
 
-	/*
-	 * Free the adv_req_t structure used with the command by adding
-	 * it back to the board free list.
-	 */
-	reqp->next_reqp = boardp->adv_reqp;
-	boardp->adv_reqp = reqp;
-
 	ASC_DBG(1, "done\n");
 }
 
@@ -7092,25 +7026,24 @@ _AscCopyLramScsiDoneQ(PortAddr iop_base,
  */
 static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 {
-	struct asc_board *boardp;
+	struct asc_board *boardp = asc_dvc_varp->drv_ptr;
+	u32 srb_tag;
 	struct scsi_cmnd *scp;
-	struct Scsi_Host *shost;
 
 	ASC_DBG(1, "asc_dvc_varp 0x%p, qdonep 0x%p\n", asc_dvc_varp, qdonep);
 	ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
 
-	scp = advansys_srb_to_ptr(asc_dvc_varp, qdonep->d2.srb_ptr);
+	/*
+	 * Decrease the srb_tag by 1 to find the SCSI command
+	 */
+	srb_tag = qdonep->d2.srb_tag - 1;
+	scp = scsi_host_find_tag(boardp->shost, srb_tag);
 	if (!scp)
 		return;
 
 	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
 
-	shost = scp->device->host;
-	ASC_STATS(shost, callback);
-	ASC_DBG(1, "shost 0x%p\n", shost);
-
-	boardp = shost_priv(shost);
-	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
+	ASC_STATS(boardp->shost, callback);
 
 	dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
 			 SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
@@ -7293,7 +7226,7 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 			scsiq->d3.done_stat = QD_WITH_ERROR;
 			goto FATAL_ERR_QDONE;
 		}
-		if ((scsiq->d2.srb_ptr == 0UL) ||
+		if ((scsiq->d2.srb_tag == 0UL) ||
 		    ((scsiq->q_status & QS_ABORTED) != 0)) {
 			return (0x11);
 		} else if (scsiq->q_status == QS_DONE) {
@@ -7861,17 +7794,16 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 {
 	struct asc_dvc_var *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 	int use_sg;
+	u32 srb_tag;
 
 	memset(asc_scsi_q, 0, sizeof(*asc_scsi_q));
 
 	/*
-	 * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
+	 * Set the srb_tag to the command tag + 1, as
+	 * srb_tag '0' is used internally by the chip.
 	 */
-	asc_scsi_q->q2.srb_ptr = advansys_ptr_to_srb(asc_dvc, scp);
-	if (asc_scsi_q->q2.srb_ptr == BAD_SRB) {
-		scp->result = HOST_BYTE(DID_SOFT_ERROR);
-		return ASC_ERROR;
-	}
+	srb_tag = scp->request->tag + 1;
+	asc_scsi_q->q2.srb_tag = srb_tag;
 
 	/*
 	 * Build the ASC_SCSI_Q request.
@@ -8083,6 +8015,7 @@ static int
 adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	      ADV_SCSI_REQ_Q **adv_scsiqpp)
 {
+	u32 srb_tag = scp->request->tag;
 	adv_req_t *reqp;
 	ADV_SCSI_REQ_Q *scsiqp;
 	int i;
@@ -8093,14 +8026,11 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	 * Allocate an adv_req_t structure from the board to execute
 	 * the command.
 	 */
-	if (boardp->adv_reqp == NULL) {
+	reqp = &boardp->adv_reqp[srb_tag];
+	if (reqp->cmndp && reqp->cmndp != scp ) {
 		ASC_DBG(1, "no free adv_req_t\n");
 		ASC_STATS(scp->device->host, adv_build_noreq);
 		return ASC_BUSY;
-	} else {
-		reqp = boardp->adv_reqp;
-		boardp->adv_reqp = reqp->next_reqp;
-		reqp->next_reqp = NULL;
 	}
 
 	/*
@@ -8114,14 +8044,15 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	scsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;
 
 	/*
-	 * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
+	 * Set the srb_tag to the command tag.
 	 */
-	scsiqp->srb_ptr = ADV_VADDR_TO_U32(reqp);
+	scsiqp->srb_tag = srb_tag;
 
 	/*
 	 * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
 	 */
 	reqp->cmndp = scp;
+	scp->host_scribble = (void *)reqp;
 
 	/*
 	 * Build the ADV_SCSI_REQ_Q request.
@@ -8163,13 +8094,8 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 				   scp->device->host->sg_tablesize);
 			scsi_dma_unmap(scp);
 			scp->result = HOST_BYTE(DID_ERROR);
-
-			/*
-			 * Free the 'adv_req_t' structure by adding it back
-			 * to the board free list.
-			 */
-			reqp->next_reqp = boardp->adv_reqp;
-			boardp->adv_reqp = reqp;
+			reqp->cmndp = NULL;
+			scp->host_scribble = NULL;
 
 			return ASC_ERROR;
 		}
@@ -8178,12 +8104,10 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 
 		ret = adv_get_sglist(boardp, reqp, scp, use_sg);
 		if (ret != ADV_SUCCESS) {
-			/*
-			 * Free the adv_req_t structure by adding it back to
-			 * the board free list.
-			 */
-			reqp->next_reqp = boardp->adv_reqp;
-			boardp->adv_reqp = reqp;
+			scsi_dma_unmap(scp);
+			scp->result = HOST_BYTE(DID_ERROR);
+			reqp->cmndp = NULL;
+			scp->host_scribble = NULL;
 
 			return ret;
 		}
@@ -11244,6 +11168,7 @@ static struct scsi_host_template advansys_template = {
 	 * by enabling clustering, I/O throughput increases as well.
 	 */
 	.use_clustering = ENABLE_CLUSTERING,
+	.use_blk_tags = 1,
 };
 
 static int advansys_wide_init_chip(struct Scsi_Host *shost)
@@ -11272,7 +11197,7 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 	 * If the allocation fails decrement and try again.
 	 */
 	for (req_cnt = adv_dvc->max_host_qng; req_cnt > 0; req_cnt--) {
-		reqp = kmalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);
+		reqp = kzalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);
 
 		ASC_DBG(1, "reqp 0x%p, req_cnt %d, bytes %lu\n", reqp, req_cnt,
 			 (ulong)sizeof(adv_req_t) * req_cnt);
@@ -11284,7 +11209,7 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 	if (!reqp)
 		goto kmalloc_failed;
 
-	adv_dvc->orig_reqp = reqp;
+	board->adv_reqp = reqp;
 
 	/*
 	 * Allocate up to ADV_TOT_SG_BLOCK request structures for
@@ -11317,7 +11242,6 @@ static int advansys_wide_init_chip(struct Scsi_Host *shost)
 	for (; req_cnt > 0; req_cnt--) {
 		reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
 	}
-	board->adv_reqp = &reqp[0];
 
 	if (adv_dvc->chip_type == ADV_CHIP_ASC3550) {
 		ASC_DBG(2, "AdvInitAsc3550Driver()\n");
@@ -11350,8 +11274,8 @@ static void advansys_wide_free_mem(struct asc_board *board)
 	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
 	kfree(adv_dvc->carrier_buf);
 	adv_dvc->carrier_buf = NULL;
-	kfree(adv_dvc->orig_reqp);
-	adv_dvc->orig_reqp = board->adv_reqp = NULL;
+	kfree(board->adv_reqp);
+	board->adv_reqp = NULL;
 	while (board->adv_sgblkp) {
 		adv_sgblk_t *sgp = board->adv_sgblkp;
 		board->adv_sgblkp = sgp->next_sgblkp;
@@ -11651,6 +11575,11 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		/* Set maximum number of queues the adapter can handle. */
 		shost->can_queue = adv_dvc_varp->max_host_qng;
 	}
+	ret = scsi_init_shared_tag_map(shost, shost->can_queue);
+	if (ret) {
+		shost_printk(KERN_ERR, shost, "init tag map failed\n");
+		goto err_free_dma;
+	}
 
 	/*
 	 * Following v1.3.89, 'cmd_per_lun' is no longer needed
@@ -11922,6 +11851,7 @@ static int advansys_isa_probe(struct device *dev, unsigned int id)
 	board = shost_priv(shost);
 	board->irq = advansys_isa_irq_no(iop_base);
 	board->dev = dev;
+	board->shost = shost;
 
 	err = advansys_board_found(shost, iop_base, ASC_IS_ISA);
 	if (err)
@@ -12004,6 +11934,7 @@ static int advansys_vlb_probe(struct device *dev, unsigned int id)
 	board = shost_priv(shost);
 	board->irq = advansys_vlb_irq_no(iop_base);
 	board->dev = dev;
+	board->shost = shost;
 
 	err = advansys_board_found(shost, iop_base, ASC_IS_VL);
 	if (err)
@@ -12111,6 +12042,7 @@ static int advansys_eisa_probe(struct device *dev)
 		board = shost_priv(shost);
 		board->irq = irq;
 		board->dev = dev;
+		board->shost = shost;
 
 		err = advansys_board_found(shost, ioport, ASC_IS_EISA);
 		if (!err) {
@@ -12227,6 +12159,7 @@ static int advansys_pci_probe(struct pci_dev *pdev,
 	board = shost_priv(shost);
 	board->irq = pdev->irq;
 	board->dev = &pdev->dev;
+	board->shost = shost;
 
 	if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||
 	    pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||

commit eac0b0c76ff904e66b115777cb3e40a98cca6764
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Apr 24 13:18:20 2015 +0200

    advansys: use host_reset
    
    The advansys_reset() function is actually a host reset, not a
    bus reset. And there is no need to have a 'last_reset'
    value; the same value exists in struct Scsi_Host.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index ae95e347f37d..e936f489a267 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2366,7 +2366,6 @@ struct asc_board {
 		ADVEEP_38C0800_CONFIG adv_38C0800_eep;	/* 38C0800 EEPROM config. */
 		ADVEEP_38C1600_CONFIG adv_38C1600_eep;	/* 38C1600 EEPROM config. */
 	} eep_config;
-	ulong last_reset;	/* Saved last reset time */
 	/* /proc/scsi/advansys/[0...] */
 #ifdef ADVANSYS_STATS
 	struct asc_stats asc_stats;	/* Board statistics */
@@ -3350,7 +3349,7 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 
 	seq_printf(m,
 		   " flags 0x%x, last_reset 0x%lx, jiffies 0x%lx, asc_n_io_port 0x%x\n",
-		   boardp->flags, boardp->last_reset, jiffies,
+		   boardp->flags, shost->last_reset, jiffies,
 		   boardp->asc_n_io_port);
 
 	seq_printf(m, " io_port 0x%lx\n", shost->io_port);
@@ -7453,7 +7452,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 /*
  * advansys_reset()
  *
- * Reset the bus associated with the command 'scp'.
+ * Reset the host associated with the command 'scp'.
  *
  * This function runs its own thread. Interrupts must be blocked but
  * sleeping is allowed and no locking other than for host structures is
@@ -7471,7 +7470,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 
 	ASC_STATS(shost, reset);
 
-	scmd_printk(KERN_INFO, scp, "SCSI bus reset started...\n");
+	scmd_printk(KERN_INFO, scp, "SCSI host reset started...\n");
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
@@ -7482,20 +7481,19 @@ static int advansys_reset(struct scsi_cmnd *scp)
 
 		/* Refer to ASC_IERR_* definitions for meaning of 'err_code'. */
 		if (asc_dvc->err_code || !asc_dvc->overrun_dma) {
-			scmd_printk(KERN_INFO, scp, "SCSI bus reset error: "
+			scmd_printk(KERN_INFO, scp, "SCSI host reset error: "
 				    "0x%x, status: 0x%x\n", asc_dvc->err_code,
 				    status);
 			ret = FAILED;
 		} else if (status) {
-			scmd_printk(KERN_INFO, scp, "SCSI bus reset warning: "
+			scmd_printk(KERN_INFO, scp, "SCSI host reset warning: "
 				    "0x%x\n", status);
 		} else {
-			scmd_printk(KERN_INFO, scp, "SCSI bus reset "
+			scmd_printk(KERN_INFO, scp, "SCSI host reset "
 				    "successful\n");
 		}
 
 		ASC_DBG(1, "after AscInitAsc1000Driver()\n");
-		spin_lock_irqsave(shost->host_lock, flags);
 	} else {
 		/*
 		 * If the suggest reset bus flags are set, then reset the bus.
@@ -7504,28 +7502,25 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		ADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;
 
 		/*
-		 * Reset the target's SCSI bus.
+		 * Reset the chip and SCSI bus.
 		 */
 		ASC_DBG(1, "before AdvResetChipAndSB()\n");
 		switch (AdvResetChipAndSB(adv_dvc)) {
 		case ASC_TRUE:
-			scmd_printk(KERN_INFO, scp, "SCSI bus reset "
+			scmd_printk(KERN_INFO, scp, "SCSI host reset "
 				    "successful\n");
 			break;
 		case ASC_FALSE:
 		default:
-			scmd_printk(KERN_INFO, scp, "SCSI bus reset error\n");
+			scmd_printk(KERN_INFO, scp, "SCSI host reset error\n");
 			ret = FAILED;
 			break;
 		}
 		spin_lock_irqsave(shost->host_lock, flags);
 		AdvISR(adv_dvc);
+		spin_unlock_irqrestore(shost->host_lock, flags);
 	}
 
-	/* Save the time of the most recently completed reset. */
-	boardp->last_reset = jiffies;
-	spin_unlock_irqrestore(shost->host_lock, flags);
-
 	ASC_DBG(1, "ret %d\n", ret);
 
 	return ret;
@@ -11232,7 +11227,7 @@ static struct scsi_host_template advansys_template = {
 	.name = DRV_NAME,
 	.info = advansys_info,
 	.queuecommand = advansys_queuecommand,
-	.eh_bus_reset_handler = advansys_reset,
+	.eh_host_reset_handler = advansys_reset,
 	.bios_param = advansys_biosparam,
 	.slave_configure = advansys_slave_configure,
 	/*

commit f50332ff2574130903356e800913c1a73cc6c1dc
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:54 2014 +0100

    scsi: print single-character strings with seq_putc
    
    Using seq_putc to print a single character saves at least a strlen()
    call and a memory access, and may also give a small .text reduction.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index c91a39916d90..ae95e347f37d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3088,7 +3088,7 @@ static void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 #ifdef CONFIG_ISA
 	if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
@@ -3203,7 +3203,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	seq_puts(m, " Target ID:           ");
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %X", i);
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->disc_enable;
@@ -3216,7 +3216,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->tagqng_able;
@@ -3229,7 +3229,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->start_motor;
@@ -3242,7 +3242,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		seq_puts(m, " Synchronous Transfer:");
@@ -3250,7 +3250,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 			seq_printf(m, " %c",
 				   (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
 				   'Y' : 'N');
-		seq_puts(m, "\n");
+		seq_putc(m, '\n');
 	}
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
@@ -3259,7 +3259,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 			seq_printf(m, " %c",
 				   (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i))
 				   ? 'Y' : 'N');
-		seq_puts(m, "\n");
+		seq_putc(m, '\n');
 	}
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
@@ -3273,7 +3273,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
 	    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {
@@ -3318,7 +3318,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 				seq_puts(m, "\n  ");
 			sdtr_speed >>= 4;
 		}
-		seq_puts(m, "\n");
+		seq_putc(m, '\n');
 	}
 }
 
@@ -3448,7 +3448,7 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		uchar syn_period_ix;
@@ -3483,7 +3483,7 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			seq_puts(m, "*\n");
 			renegotiate = 1;
 		} else {
-			seq_puts(m, "\n");
+			seq_putc(m, '\n');
 		}
 	}
 
@@ -3570,7 +3570,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 		seq_printf(m, " %X:%d", i, lrambyte);
 	}
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
 	seq_puts(m, " Wide Enabled:");
@@ -3584,7 +3584,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
 	seq_puts(m, " Transfer Bit Width:");
@@ -3603,11 +3603,11 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 		if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
 		    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			seq_puts(m, "*");
+			seq_putc(m, '*');
 			renegotiate = 1;
 		}
 	}
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
 	seq_puts(m, " Synchronous Enabled:");
@@ -3621,7 +3621,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_puts(m, "\n");
+	seq_putc(m, '\n');
 
 	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
 	for (i = 0; i <= ADV_MAX_TID; i++) {
@@ -3670,7 +3670,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			seq_puts(m, "*\n");
 			renegotiate = 1;
 		} else {
-			seq_puts(m, "\n");
+			seq_putc(m, '\n');
 		}
 	}
 

commit 3d30079c3a9000504cf71e4e8dd94619070dc4f3
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:53 2014 +0100

    scsi: merge consecutive seq_puts calls
    
    Consecutive seq_puts calls with literal strings may be replaced by a
    single call, saving a little .text.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9cdad1de9ae3..c91a39916d90 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2903,11 +2903,9 @@ static void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)
 	 * the BIOS code segment base address.
 	 */
 	if (boardp->bios_signature != 0x55AA) {
-		seq_puts(m, "Disabled or Pre-3.1\n");
-		seq_puts(m,
-			 "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
-		seq_puts(m,
-			 "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
+		seq_puts(m, "Disabled or Pre-3.1\n"
+			"BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n"
+			"can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
 	} else {
 		major = (boardp->bios_version >> 12) & 0xF;
 		minor = (boardp->bios_version >> 8) & 0xF;
@@ -2923,9 +2921,8 @@ static void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)
 		 */
 		if (major < 3 || (major <= 3 && minor < 1) ||
 		    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {
-			seq_puts(m,
-				 "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
-			seq_puts(m, "ftp://ftp.connectcom.net/pub\n");
+			seq_puts(m, "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n"
+				"ftp://ftp.connectcom.net/pub\n");
 		}
 	}
 }
@@ -3071,27 +3068,23 @@ static void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	seq_puts(m, " Target ID:           ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %d", i);
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Disconnects:         ");
+	seq_puts(m, "\n Disconnects:         ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Command Queuing:     ");
+	seq_puts(m, "\n Command Queuing:     ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Start Motor:         ");
+	seq_puts(m, "\n Start Motor:         ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Synchronous Transfer:");
+	seq_puts(m, "\n Synchronous Transfer:");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
@@ -3410,10 +3403,9 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_puts(m, "\n");
 
 	/* Current number of commands waiting for a device. */
-	seq_puts(m, " Command Queue Pending:");
+	seq_puts(m, "\n Command Queue Pending:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3421,10 +3413,9 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		}
 		seq_printf(m, " %X:%u", i, v->cur_dvc_qng[i]);
 	}
-	seq_puts(m, "\n");
 
 	/* Current limit on number of commands that can be sent to a device. */
-	seq_puts(m, " Command Queue Limit:");
+	seq_puts(m, "\n Command Queue Limit:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3432,10 +3423,9 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		}
 		seq_printf(m, " %X:%u", i, v->max_dvc_qng[i]);
 	}
-	seq_puts(m, "\n");
 
 	/* Indicate whether the device has returned queue full status. */
-	seq_puts(m, " Command Queue Full:");
+	seq_puts(m, "\n Command Queue Full:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3447,9 +3437,8 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		else
 			seq_printf(m, " %X:N", i);
 	}
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Synchronous Transfer:");
+	seq_puts(m, "\n Synchronous Transfer:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3555,9 +3544,8 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Queue Limit:");
+	seq_puts(m, "\n Queue Limit:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3569,9 +3557,8 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 		seq_printf(m, " %X:%d", i, lrambyte);
 	}
-	seq_puts(m, "\n");
 
-	seq_puts(m, " Command Pending:");
+	seq_puts(m, "\n Command Pending:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {

commit 2f979427b2babed959c86d32a506063b9145429e
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:50 2014 +0100

    advansys: replace seq_printf with seq_puts
    
    Using seq_printf to print a simple string is a lot more expensive than
    it needs to be, since seq_puts exists. Replace seq_printf with
    seq_puts when possible.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 2c5ce48c8f95..9cdad1de9ae3 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2880,7 +2880,7 @@ static void asc_prt_board_devices(struct seq_file *m, struct Scsi_Host *shost)
 		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
 	}
 
-	seq_printf(m, "Target IDs Detected:");
+	seq_puts(m, "Target IDs Detected:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i))
 			seq_printf(m, " %X,", i);
@@ -2896,18 +2896,18 @@ static void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)
 	struct asc_board *boardp = shost_priv(shost);
 	ushort major, minor, letter;
 
-	seq_printf(m, "\nROM BIOS Version: ");
+	seq_puts(m, "\nROM BIOS Version: ");
 
 	/*
 	 * If the BIOS saved a valid signature, then fill in
 	 * the BIOS code segment base address.
 	 */
 	if (boardp->bios_signature != 0x55AA) {
-		seq_printf(m, "Disabled or Pre-3.1\n");
-		seq_printf(m,
-			  "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
-		seq_printf(m,
-			  "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
+		seq_puts(m, "Disabled or Pre-3.1\n");
+		seq_puts(m,
+			 "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
+		seq_puts(m,
+			 "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
 	} else {
 		major = (boardp->bios_version >> 12) & 0xF;
 		minor = (boardp->bios_version >> 8) & 0xF;
@@ -2923,10 +2923,9 @@ static void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)
 		 */
 		if (major < 3 || (major <= 3 && minor < 1) ||
 		    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {
-			seq_printf(m,
-				   "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
-			seq_printf(m,
-				   "ftp://ftp.connectcom.net/pub\n");
+			seq_puts(m,
+				 "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
+			seq_puts(m, "ftp://ftp.connectcom.net/pub\n");
 		}
 	}
 }
@@ -3056,11 +3055,10 @@ static void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	    == ASC_TRUE)
 		seq_printf(m, " Serial Number: %s\n", serialstr);
 	else if (ep->adapter_info[5] == 0xBB)
-		seq_printf(m,
-			   " Default Settings Used for EEPROM-less Adapter.\n");
+		seq_puts(m,
+			 " Default Settings Used for EEPROM-less Adapter.\n");
 	else
-		seq_printf(m,
-			   " Serial Number Signature Not Present.\n");
+		seq_puts(m, " Serial Number Signature Not Present.\n");
 
 	seq_printf(m,
 		   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
@@ -3070,34 +3068,34 @@ static void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	seq_printf(m,
 		   " cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);
 
-	seq_printf(m, " Target ID:           ");
+	seq_puts(m, " Target ID:           ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %d", i);
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Disconnects:         ");
+	seq_puts(m, " Disconnects:         ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Command Queuing:     ");
+	seq_puts(m, " Command Queuing:     ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Start Motor:         ");
+	seq_puts(m, " Start Motor:         ");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Synchronous Transfer:");
+	seq_puts(m, " Synchronous Transfer:");
 	for (i = 0; i <= ASC_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 #ifdef CONFIG_ISA
 	if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
@@ -3151,7 +3149,7 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE)
 		seq_printf(m, " Serial Number: %s\n", serialstr);
 	else
-		seq_printf(m, " Serial Number Signature Not Present.\n");
+		seq_puts(m, " Serial Number Signature Not Present.\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
 		seq_printf(m,
@@ -3209,10 +3207,10 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 			   ep_38C1600->termination_lvd, termstr,
 			   ep_38C1600->bios_ctrl);
 
-	seq_printf(m, " Target ID:           ");
+	seq_puts(m, " Target ID:           ");
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %X", i);
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->disc_enable;
@@ -3221,11 +3219,11 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	} else {
 		word = ep_38C1600->disc_enable;
 	}
-	seq_printf(m, " Disconnects:         ");
+	seq_puts(m, " Disconnects:         ");
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->tagqng_able;
@@ -3234,11 +3232,11 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	} else {
 		word = ep_38C1600->tagqng_able;
 	}
-	seq_printf(m, " Command Queuing:     ");
+	seq_puts(m, " Command Queuing:     ");
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->start_motor;
@@ -3247,28 +3245,28 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	} else {
 		word = ep_38C1600->start_motor;
 	}
-	seq_printf(m, " Start Motor:         ");
+	seq_puts(m, " Start Motor:         ");
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		seq_printf(m, " Synchronous Transfer:");
+		seq_puts(m, " Synchronous Transfer:");
 		for (i = 0; i <= ADV_MAX_TID; i++)
 			seq_printf(m, " %c",
 				   (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
 				   'Y' : 'N');
-		seq_printf(m, "\n");
+		seq_puts(m, "\n");
 	}
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		seq_printf(m, " Ultra Transfer:      ");
+		seq_puts(m, " Ultra Transfer:      ");
 		for (i = 0; i <= ADV_MAX_TID; i++)
 			seq_printf(m, " %c",
 				   (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i))
 				   ? 'Y' : 'N');
-		seq_printf(m, "\n");
+		seq_puts(m, "\n");
 	}
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
@@ -3278,16 +3276,15 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 	} else {
 		word = ep_38C1600->wdtr_able;
 	}
-	seq_printf(m, " Wide Transfer:       ");
+	seq_puts(m, " Wide Transfer:       ");
 	for (i = 0; i <= ADV_MAX_TID; i++)
 		seq_printf(m, " %c",
 			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
 	    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {
-		seq_printf(m,
-			   " Synchronous Transfer Speed (Mhz):\n  ");
+		seq_puts(m, " Synchronous Transfer Speed (Mhz):\n  ");
 		for (i = 0; i <= ADV_MAX_TID; i++) {
 			char *speed_str;
 
@@ -3325,10 +3322,10 @@ static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost
 			}
 			seq_printf(m, "%X:%s ", i, speed_str);
 			if (i == 7)
-				seq_printf(m, "\n  ");
+				seq_puts(m, "\n  ");
 			sdtr_speed >>= 4;
 		}
-		seq_printf(m, "\n");
+		seq_puts(m, "\n");
 	}
 }
 
@@ -3403,7 +3400,7 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 	seq_printf(m,
 		   " Total Command Pending: %d\n", v->cur_total_qng);
 
-	seq_printf(m, " Command Queuing:");
+	seq_puts(m, " Command Queuing:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3413,10 +3410,10 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	/* Current number of commands waiting for a device. */
-	seq_printf(m, " Command Queue Pending:");
+	seq_puts(m, " Command Queue Pending:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3424,10 +3421,10 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		}
 		seq_printf(m, " %X:%u", i, v->cur_dvc_qng[i]);
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	/* Current limit on number of commands that can be sent to a device. */
-	seq_printf(m, " Command Queue Limit:");
+	seq_puts(m, " Command Queue Limit:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3435,10 +3432,10 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		}
 		seq_printf(m, " %X:%u", i, v->max_dvc_qng[i]);
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	/* Indicate whether the device has returned queue full status. */
-	seq_printf(m, " Command Queue Full:");
+	seq_puts(m, " Command Queue Full:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3450,9 +3447,9 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		else
 			seq_printf(m, " %X:N", i);
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Synchronous Transfer:");
+	seq_puts(m, " Synchronous Transfer:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3462,7 +3459,7 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		uchar syn_period_ix;
@@ -3476,7 +3473,7 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		seq_printf(m, "  %X:", i);
 
 		if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {
-			seq_printf(m, " Asynchronous");
+			seq_puts(m, " Asynchronous");
 		} else {
 			syn_period_ix =
 			    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -
@@ -3494,16 +3491,15 @@ static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		}
 
 		if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			seq_printf(m, "*\n");
+			seq_puts(m, "*\n");
 			renegotiate = 1;
 		} else {
-			seq_printf(m, "\n");
+			seq_puts(m, "\n");
 		}
 	}
 
 	if (renegotiate) {
-		seq_printf(m,
-			   " * = Re-negotiation pending before next command.\n");
+		seq_puts(m, " * = Re-negotiation pending before next command.\n");
 	}
 }
 
@@ -3548,7 +3544,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		   c->mcode_date, c->mcode_version);
 
 	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	seq_printf(m, " Queuing Enabled:");
+	seq_puts(m, " Queuing Enabled:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3559,9 +3555,9 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Queue Limit:");
+	seq_puts(m, " Queue Limit:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3573,9 +3569,9 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 		seq_printf(m, " %X:%d", i, lrambyte);
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
-	seq_printf(m, " Command Pending:");
+	seq_puts(m, " Command Pending:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3587,10 +3583,10 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 		seq_printf(m, " %X:%d", i, lrambyte);
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	seq_printf(m, " Wide Enabled:");
+	seq_puts(m, " Wide Enabled:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3601,10 +3597,10 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
-	seq_printf(m, " Transfer Bit Width:");
+	seq_puts(m, " Transfer Bit Width:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3620,14 +3616,14 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 		if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
 		    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			seq_printf(m, "*");
+			seq_puts(m, "*");
 			renegotiate = 1;
 		}
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	seq_printf(m, " Synchronous Enabled:");
+	seq_puts(m, " Synchronous Enabled:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3638,7 +3634,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 			   i,
 			   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	seq_printf(m, "\n");
+	seq_puts(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
 	for (i = 0; i <= ADV_MAX_TID; i++) {
@@ -3657,14 +3653,14 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		seq_printf(m, "  %X:", i);
 
 		if ((lramword & 0x1F) == 0) {	/* Check for REQ/ACK Offset 0. */
-			seq_printf(m, " Asynchronous");
+			seq_puts(m, " Asynchronous");
 		} else {
-			seq_printf(m, " Transfer Period Factor: ");
+			seq_puts(m, " Transfer Period Factor: ");
 
 			if ((lramword & 0x1F00) == 0x1100) {	/* 80 Mhz */
-				seq_printf(m, "9 (80.0 Mhz),");
+				seq_puts(m, "9 (80.0 Mhz),");
 			} else if ((lramword & 0x1F00) == 0x1000) {	/* 40 Mhz */
-				seq_printf(m, "10 (40.0 Mhz),");
+				seq_puts(m, "10 (40.0 Mhz),");
 			} else {	/* 20 Mhz or below. */
 
 				period = (((lramword >> 8) * 25) + 50) / 4;
@@ -3684,16 +3680,15 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 		}
 
 		if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			seq_printf(m, "*\n");
+			seq_puts(m, "*\n");
 			renegotiate = 1;
 		} else {
-			seq_printf(m, "\n");
+			seq_puts(m, "\n");
 		}
 	}
 
 	if (renegotiate) {
-		seq_printf(m,
-			   " * = Re-negotiation pending before next command.\n");
+		seq_puts(m, " * = Re-negotiation pending before next command.\n");
 	}
 }
 

commit 68d81f40047cc4f99e86807e1160fb07a7b856c7
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Nov 24 07:07:25 2014 -0800

    scsi: remove MSG_*_TAG defines
    
    For SPI drivers use the message definitions from scsi.h, and for target
    drivers introduce a new TCM_*_TAG namespace.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 6719a3390ebd..2c5ce48c8f95 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7921,9 +7921,9 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	 */
 	if ((asc_dvc->cur_dvc_qng[scp->device->id] > 0) &&
 	    (boardp->reqcnt[scp->device->id] % 255) == 0) {
-		asc_scsi_q->q2.tag_code = MSG_ORDERED_TAG;
+		asc_scsi_q->q2.tag_code = ORDERED_QUEUE_TAG;
 	} else {
-		asc_scsi_q->q2.tag_code = MSG_SIMPLE_TAG;
+		asc_scsi_q->q2.tag_code = SIMPLE_QUEUE_TAG;
 	}
 
 	/* Build ASC_SCSI_Q */
@@ -8351,7 +8351,7 @@ static int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 	}
 	q_addr = ASC_QNO_TO_QADDR(q_no);
 	if ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {
-		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
+		scsiq->q2.tag_code &= ~SIMPLE_QUEUE_TAG;
 	}
 	scsiq->q1.status = QS_FREE;
 	AscMemWordCopyPtrToLram(iop_base,
@@ -8669,7 +8669,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 		}
 	}
 	if (disable_syn_offset_one_fix) {
-		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
+		scsiq->q2.tag_code &= ~SIMPLE_QUEUE_TAG;
 		scsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
 				       ASC_TAG_FLAG_DISABLE_DISCONNECT);
 	} else {

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index ae4840e4c1c5..6719a3390ebd 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7706,7 +7706,7 @@ advansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)
 				asc_dvc->cfg->can_tagged_qng |= tid_bit;
 				asc_dvc->use_tagged_qng |= tid_bit;
 			}
-			scsi_adjust_queue_depth(sdev, 
+			scsi_change_queue_depth(sdev, 
 						asc_dvc->max_dvc_qng[sdev->id]);
 		}
 	} else {
@@ -7847,10 +7847,8 @@ advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
 		}
 	}
 
-	if ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported) {
-		scsi_adjust_queue_depth(sdev,
-					adv_dvc->max_dvc_qng);
-	}
+	if ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported)
+		scsi_change_queue_depth(sdev, adv_dvc->max_dvc_qng);
 }
 
 /*

commit c8b09f6fb67df7fc1b51ced1037fa9b677428149
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 20:15:14 2014 +0100

    scsi: don't set tagging state from scsi_adjust_queue_depth
    
    Remove the tagged argument from scsi_adjust_queue_depth, and just let it
    handle the queue depth.  For most drivers those two are fairly separate,
    given that most modern drivers don't care about the SCSI "tagged" status
    of a command at all, and many old drivers allow queuing of multiple
    untagged commands in the driver.
    
    Instead we start out with the ->simple_tags flag set before calling
    ->slave_configure, which is how all drivers actually looking at
    ->simple_tags except for one worke anyway.  The one other case looks
    broken, but I've kept the behavior as-is for now.
    
    Except for that we only change ->simple_tags from the ->change_queue_type,
    and when rejecting a tag message in a single driver, so keeping this
    churn out of scsi_adjust_queue_depth is a clear win.
    
    Now that the usage of scsi_adjust_queue_depth is more obvious we can
    also remove all the trivial instances in ->slave_alloc or ->slave_configure
    that just set it to the cmd_per_lun default.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 43761c1c46f0..ae4840e4c1c5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7706,7 +7706,7 @@ advansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)
 				asc_dvc->cfg->can_tagged_qng |= tid_bit;
 				asc_dvc->use_tagged_qng |= tid_bit;
 			}
-			scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
+			scsi_adjust_queue_depth(sdev, 
 						asc_dvc->max_dvc_qng[sdev->id]);
 		}
 	} else {
@@ -7714,7 +7714,6 @@ advansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)
 			asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
 			asc_dvc->use_tagged_qng &= ~tid_bit;
 		}
-		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
 	}
 
 	if ((sdev->lun == 0) &&
@@ -7849,10 +7848,8 @@ advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
 	}
 
 	if ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported) {
-		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
+		scsi_adjust_queue_depth(sdev,
 					adv_dvc->max_dvc_qng);
-	} else {
-		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
 	}
 }
 

commit 74665016086615bbaa3fa6f83af410a0a4e029ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 22 15:29:29 2014 +0100

    scsi: convert host_busy to atomic_t
    
    Avoid taking the host-wide host_lock to check the per-host queue limit.
    Instead we do an atomic_inc_return early on to grab our slot in the queue,
    and if necessary decrement it after finishing all checks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Robert Elliott <elliott@hp.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e716d0aef194..43761c1c46f0 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2512,7 +2512,7 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 
 	printk("Scsi_Host at addr 0x%p, device %s\n", s, dev_name(boardp->dev));
 	printk(" host_busy %u, host_no %d,\n",
-	       s->host_busy, s->host_no);
+	       atomic_read(&s->host_busy), s->host_no);
 
 	printk(" base 0x%lx, io_port 0x%lx, irq %d,\n",
 	       (ulong)s->base, (ulong)s->io_port, boardp->irq);
@@ -3346,7 +3346,7 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 
 	seq_printf(m,
 		   " host_busy %u, max_id %u, max_lun %llu, max_channel %u\n",
-		   shost->host_busy, shost->max_id,
+		   atomic_read(&shost->host_busy), shost->max_id,
 		   shost->max_lun, shost->max_channel);
 
 	seq_printf(m,

commit 1abf635d2f3332641570e1913e317073834a055f
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:38 2014 +0200

    scsi: use 64-bit value for 'max_luns'
    
    Now that we're using 64-bit LUNs internally we need to increase
    the size of max_luns to 64 bits, too.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d8145888e66a..e716d0aef194 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3345,7 +3345,7 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 		shost->host_no);
 
 	seq_printf(m,
-		   " host_busy %u, max_id %u, max_lun %u, max_channel %u\n",
+		   " host_busy %u, max_id %u, max_lun %llu, max_channel %u\n",
 		   shost->host_busy, shost->max_id,
 		   shost->max_lun, shost->max_channel);
 

commit 50d14a70fb284f5dcbc9e6f135b110c78786d07c
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Oct 23 10:51:17 2013 +0200

    [SCSI] advansys: Remove 'last_reset' references
    
    Serves no purpose whatsoever.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index c67e401954c5..d8145888e66a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2511,8 +2511,8 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 	struct asc_board *boardp = shost_priv(s);
 
 	printk("Scsi_Host at addr 0x%p, device %s\n", s, dev_name(boardp->dev));
-	printk(" host_busy %u, host_no %d, last_reset %d,\n",
-	       s->host_busy, s->host_no, (unsigned)s->last_reset);
+	printk(" host_busy %u, host_no %d,\n",
+	       s->host_busy, s->host_no);
 
 	printk(" base 0x%lx, io_port 0x%lx, irq %d,\n",
 	       (ulong)s->base, (ulong)s->io_port, boardp->irq);
@@ -3345,8 +3345,8 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 		shost->host_no);
 
 	seq_printf(m,
-		   " host_busy %u, last_reset %lu, max_id %u, max_lun %u, max_channel %u\n",
-		   shost->host_busy, shost->last_reset, shost->max_id,
+		   " host_busy %u, max_id %u, max_lun %u, max_channel %u\n",
+		   shost->host_busy, shost->max_id,
 		   shost->max_lun, shost->max_channel);
 
 	seq_printf(m,

commit 31491e1ac425edc6b80a670a71ac8d2dfdd78417
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 03:04:13 2013 -0400

    advansys: fix buggered formats - unsigned long != u32 on 64bit
    
    asc_prt_line() had been hiding several places where formats had not
    matched the argument types.  The previous commit has finally made them
    visible...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9029a208b9c3..c67e401954c5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3345,7 +3345,7 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 		shost->host_no);
 
 	seq_printf(m,
-		   " host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
+		   " host_busy %u, last_reset %lu, max_id %u, max_lun %u, max_channel %u\n",
 		   shost->host_busy, shost->last_reset, shost->max_id,
 		   shost->max_lun, shost->max_channel);
 
@@ -3359,11 +3359,11 @@ static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 		   shost->unchecked_isa_dma, shost->use_clustering);
 
 	seq_printf(m,
-		   " flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
+		   " flags 0x%x, last_reset 0x%lx, jiffies 0x%lx, asc_n_io_port 0x%x\n",
 		   boardp->flags, boardp->last_reset, jiffies,
 		   boardp->asc_n_io_port);
 
-	seq_printf(m, " io_port 0x%x\n", shost->io_port);
+	seq_printf(m, " io_port 0x%lx\n", shost->io_port);
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
@@ -3539,7 +3539,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 
 	seq_printf(m,
 		   " iop_base 0x%lx, cable_detect: %X, err_code %u\n",
-		   v->iop_base,
+		   (unsigned long)v->iop_base,
 		   AdvReadWordRegister(iop_base,IOPW_SCSI_CFG1) & CABLE_DETECT,
 		   v->err_code);
 
@@ -3670,7 +3670,7 @@ static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 				period = (((lramword >> 8) * 25) + 50) / 4;
 
 				if (period == 0) {	/* Should never happen. */
-					seq_printf(m, "%d (? Mhz), ");
+					seq_printf(m, "%d (? Mhz), ", period);
 				} else {
 					seq_printf(m,
 						   "%d (%d.%d Mhz),",
@@ -3711,17 +3711,17 @@ static void asc_prt_board_stats(struct seq_file *m, struct Scsi_Host *shost)
 		   shost->host_no);
 
 	seq_printf(m,
-		   " queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
+		   " queuecommand %u, reset %u, biosparam %u, interrupt %u\n",
 		   s->queuecommand, s->reset, s->biosparam,
 		   s->interrupt);
 
 	seq_printf(m,
-		   " callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
+		   " callback %u, done %u, build_error %u, build_noreq %u, build_nosg %u\n",
 		   s->callback, s->done, s->build_error,
 		   s->adv_build_noreq, s->adv_build_nosg);
 
 	seq_printf(m,
-		   " exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
+		   " exe_noerror %u, exe_busy %u, exe_error %u, exe_unknown %u\n",
 		   s->exe_noerror, s->exe_busy, s->exe_error,
 		   s->exe_unknown);
 
@@ -3729,22 +3729,22 @@ static void asc_prt_board_stats(struct seq_file *m, struct Scsi_Host *shost)
 	 * Display data transfer statistics.
 	 */
 	if (s->xfer_cnt > 0) {
-		seq_printf(m, " xfer_cnt %lu, xfer_elem %lu, ",
+		seq_printf(m, " xfer_cnt %u, xfer_elem %u, ",
 			   s->xfer_cnt, s->xfer_elem);
 
-		seq_printf(m, "xfer_bytes %lu.%01lu kb\n",
+		seq_printf(m, "xfer_bytes %u.%01u kb\n",
 			   s->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));
 
 		/* Scatter gather transfer statistics */
-		seq_printf(m, " avg_num_elem %lu.%01lu, ",
+		seq_printf(m, " avg_num_elem %u.%01u, ",
 			   s->xfer_elem / s->xfer_cnt,
 			   ASC_TENTHS(s->xfer_elem, s->xfer_cnt));
 
-		seq_printf(m, "avg_elem_size %lu.%01lu kb, ",
+		seq_printf(m, "avg_elem_size %u.%01u kb, ",
 			   (s->xfer_sect / 2) / s->xfer_elem,
 			   ASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));
 
-		seq_printf(m, "avg_xfer_size %lu.%01lu kb\n",
+		seq_printf(m, "avg_xfer_size %u.%01u kb\n",
 			   (s->xfer_sect / 2) / s->xfer_cnt,
 			   ASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));
 	}

commit b59fb6fdce14bbec226cc4a4b5a4511a715ea6c2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 02:59:55 2013 -0400

    advansys: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index dcfaee66a8b9..9029a208b9c3 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2178,22 +2178,6 @@ do { \
 
 #define ASC_INFO_SIZE           128	/* advansys_info() line size */
 
-#ifdef CONFIG_PROC_FS
-/* /proc/scsi/advansys/[0...] related definitions */
-#define ASC_PRTBUF_SIZE         2048
-#define ASC_PRTLINE_SIZE        160
-
-#define ASC_PRT_NEXT() \
-    if (cp) { \
-        totlen += len; \
-        leftlen -= len; \
-        if (leftlen == 0) { \
-            return totlen; \
-        } \
-        cp += len; \
-    }
-#endif /* CONFIG_PROC_FS */
-
 /* Asc Library return codes */
 #define ASC_TRUE        1
 #define ASC_FALSE       0
@@ -2384,7 +2368,6 @@ struct asc_board {
 	} eep_config;
 	ulong last_reset;	/* Saved last reset time */
 	/* /proc/scsi/advansys/[0...] */
-	char *prtbuf;		/* /proc print buffer */
 #ifdef ADVANSYS_STATS
 	struct asc_stats asc_stats;	/* Board statistics */
 #endif				/* ADVANSYS_STATS */
@@ -2875,64 +2858,21 @@ static const char *advansys_info(struct Scsi_Host *shost)
 }
 
 #ifdef CONFIG_PROC_FS
-/*
- * asc_prt_line()
- *
- * If 'cp' is NULL print to the console, otherwise print to a buffer.
- *
- * Return 0 if printing to the console, otherwise return the number of
- * bytes written to the buffer.
- *
- * Note: If any single line is greater than ASC_PRTLINE_SIZE bytes the stack
- * will be corrupted. 's[]' is defined to be ASC_PRTLINE_SIZE bytes.
- */
-static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
-{
-	va_list args;
-	int ret;
-	char s[ASC_PRTLINE_SIZE];
-
-	va_start(args, fmt);
-	ret = vsprintf(s, fmt, args);
-	BUG_ON(ret >= ASC_PRTLINE_SIZE);
-	if (buf == NULL) {
-		(void)printk(s);
-		ret = 0;
-	} else {
-		ret = min(buflen, ret);
-		memcpy(buf, s, ret);
-	}
-	va_end(args);
-	return ret;
-}
 
 /*
  * asc_prt_board_devices()
  *
  * Print driver information for devices attached to the board.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_board_devices(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
-	int leftlen;
-	int totlen;
-	int len;
 	int chip_scsi_id;
 	int i;
 
-	leftlen = cplen;
-	totlen = len = 0;
-
-	len = asc_prt_line(cp, leftlen,
-			   "\nDevice Information for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   "\nDevice Information for AdvanSys SCSI Host %d:\n",
+		   shost->host_no);
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
@@ -2940,60 +2880,42 @@ static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
 		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
 	}
 
-	len = asc_prt_line(cp, leftlen, "Target IDs Detected:");
-	ASC_PRT_NEXT();
+	seq_printf(m, "Target IDs Detected:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) {
-			len = asc_prt_line(cp, leftlen, " %X,", i);
-			ASC_PRT_NEXT();
-		}
+		if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i))
+			seq_printf(m, " %X,", i);
 	}
-	len = asc_prt_line(cp, leftlen, " (%X=Host Adapter)\n", chip_scsi_id);
-	ASC_PRT_NEXT();
-
-	return totlen;
+	seq_printf(m, " (%X=Host Adapter)\n", chip_scsi_id);
 }
 
 /*
  * Display Wide Board BIOS Information.
  */
-static int asc_prt_adv_bios(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
-	int leftlen;
-	int totlen;
-	int len;
 	ushort major, minor, letter;
 
-	leftlen = cplen;
-	totlen = len = 0;
-
-	len = asc_prt_line(cp, leftlen, "\nROM BIOS Version: ");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\nROM BIOS Version: ");
 
 	/*
 	 * If the BIOS saved a valid signature, then fill in
 	 * the BIOS code segment base address.
 	 */
 	if (boardp->bios_signature != 0x55AA) {
-		len = asc_prt_line(cp, leftlen, "Disabled or Pre-3.1\n");
-		ASC_PRT_NEXT();
-		len = asc_prt_line(cp, leftlen,
-				   "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
-		ASC_PRT_NEXT();
-		len = asc_prt_line(cp, leftlen,
-				   "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
-		ASC_PRT_NEXT();
+		seq_printf(m, "Disabled or Pre-3.1\n");
+		seq_printf(m,
+			  "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
+		seq_printf(m,
+			  "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
 	} else {
 		major = (boardp->bios_version >> 12) & 0xF;
 		minor = (boardp->bios_version >> 8) & 0xF;
 		letter = (boardp->bios_version & 0xFF);
 
-		len = asc_prt_line(cp, leftlen, "%d.%d%c\n",
+		seq_printf(m, "%d.%d%c\n",
 				   major, minor,
 				   letter >= 26 ? '?' : letter + 'A');
-		ASC_PRT_NEXT();
-
 		/*
 		 * Current available ROM BIOS release is 3.1I for UW
 		 * and 3.2I for U2W. This code doesn't differentiate
@@ -3001,16 +2923,12 @@ static int asc_prt_adv_bios(struct Scsi_Host *shost, char *cp, int cplen)
 		 */
 		if (major < 3 || (major <= 3 && minor < 1) ||
 		    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {
-			len = asc_prt_line(cp, leftlen,
-					   "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
-			ASC_PRT_NEXT();
-			len = asc_prt_line(cp, leftlen,
-					   "ftp://ftp.connectcom.net/pub\n");
-			ASC_PRT_NEXT();
+			seq_printf(m,
+				   "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
+			seq_printf(m,
+				   "ftp://ftp.connectcom.net/pub\n");
 		}
 	}
-
-	return totlen;
 }
 
 /*
@@ -3115,20 +3033,11 @@ static int asc_get_eeprom_string(ushort *serialnum, uchar *cp)
  * asc_prt_asc_board_eeprom()
  *
  * Print board EEPROM configuration.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
 	ASC_DVC_VAR *asc_dvc_varp;
-	int leftlen;
-	int totlen;
-	int len;
 	ASCEEP_CONFIG *ep;
 	int i;
 #ifdef CONFIG_ISA
@@ -3139,129 +3048,75 @@ static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 	asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 	ep = &boardp->eep_config.asc_eep;
 
-	leftlen = cplen;
-	totlen = len = 0;
-
-	len = asc_prt_line(cp, leftlen,
-			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+		   shost->host_no);
 
 	if (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)
-	    == ASC_TRUE) {
-		len =
-		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
-				 serialstr);
-		ASC_PRT_NEXT();
-	} else {
-		if (ep->adapter_info[5] == 0xBB) {
-			len = asc_prt_line(cp, leftlen,
-					   " Default Settings Used for EEPROM-less Adapter.\n");
-			ASC_PRT_NEXT();
-		} else {
-			len = asc_prt_line(cp, leftlen,
-					   " Serial Number Signature Not Present.\n");
-			ASC_PRT_NEXT();
-		}
-	}
-
-	len = asc_prt_line(cp, leftlen,
-			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-			   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,
-			   ep->max_tag_qng);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Target ID:           ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %d", i);
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	    == ASC_TRUE)
+		seq_printf(m, " Serial Number: %s\n", serialstr);
+	else if (ep->adapter_info[5] == 0xBB)
+		seq_printf(m,
+			   " Default Settings Used for EEPROM-less Adapter.\n");
+	else
+		seq_printf(m,
+			   " Serial Number Signature Not Present.\n");
+
+	seq_printf(m,
+		   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+		   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,
+		   ep->max_tag_qng);
+
+	seq_printf(m,
+		   " cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);
+
+	seq_printf(m, " Target ID:           ");
+	for (i = 0; i <= ASC_MAX_TID; i++)
+		seq_printf(m, " %d", i);
+	seq_printf(m, "\n");
+
+	seq_printf(m, " Disconnects:         ");
+	for (i = 0; i <= ASC_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
+
+	seq_printf(m, " Command Queuing:     ");
+	for (i = 0; i <= ASC_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
+
+	seq_printf(m, " Start Motor:         ");
+	for (i = 0; i <= ASC_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
+
+	seq_printf(m, " Synchronous Transfer:");
+	for (i = 0; i <= ASC_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
 
 #ifdef CONFIG_ISA
 	if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
-		len = asc_prt_line(cp, leftlen,
-				   " Host ISA DMA speed:   %d MB/S\n",
-				   isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
-		ASC_PRT_NEXT();
+		seq_printf(m,
+			   " Host ISA DMA speed:   %d MB/S\n",
+			   isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
 	}
 #endif /* CONFIG_ISA */
-
-	return totlen;
 }
 
 /*
  * asc_prt_adv_board_eeprom()
  *
  * Print board EEPROM configuration.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
 	ADV_DVC_VAR *adv_dvc_varp;
-	int leftlen;
-	int totlen;
-	int len;
 	int i;
 	char *termstr;
 	uchar serialstr[13];
@@ -3281,13 +3136,9 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 		ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
 	}
 
-	leftlen = cplen;
-	totlen = len = 0;
-
-	len = asc_prt_line(cp, leftlen,
-			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+		   shost->host_no);
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		wordp = &ep_3550->serial_number_word1;
@@ -3297,38 +3148,28 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 		wordp = &ep_38C1600->serial_number_word1;
 	}
 
-	if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE) {
-		len =
-		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
-				 serialstr);
-		ASC_PRT_NEXT();
-	} else {
-		len = asc_prt_line(cp, leftlen,
-				   " Serial Number Signature Not Present.\n");
-		ASC_PRT_NEXT();
-	}
+	if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE)
+		seq_printf(m, " Serial Number: %s\n", serialstr);
+	else
+		seq_printf(m, " Serial Number Signature Not Present.\n");
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen,
-				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-				   ep_3550->adapter_scsi_id,
-				   ep_3550->max_host_qng, ep_3550->max_dvc_qng);
-		ASC_PRT_NEXT();
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		len = asc_prt_line(cp, leftlen,
-				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-				   ep_38C0800->adapter_scsi_id,
-				   ep_38C0800->max_host_qng,
-				   ep_38C0800->max_dvc_qng);
-		ASC_PRT_NEXT();
-	} else {
-		len = asc_prt_line(cp, leftlen,
-				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-				   ep_38C1600->adapter_scsi_id,
-				   ep_38C1600->max_host_qng,
-				   ep_38C1600->max_dvc_qng);
-		ASC_PRT_NEXT();
-	}
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+		seq_printf(m,
+			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+			   ep_3550->adapter_scsi_id,
+			   ep_3550->max_host_qng, ep_3550->max_dvc_qng);
+	else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+		seq_printf(m,
+			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+			   ep_38C0800->adapter_scsi_id,
+			   ep_38C0800->max_host_qng,
+			   ep_38C0800->max_dvc_qng);
+	else
+		seq_printf(m,
+			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+			   ep_38C1600->adapter_scsi_id,
+			   ep_38C1600->max_host_qng,
+			   ep_38C1600->max_dvc_qng);
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->termination;
 	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
@@ -3352,34 +3193,26 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 		break;
 	}
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen,
-				   " termination: %u (%s), bios_ctrl: 0x%x\n",
-				   ep_3550->termination, termstr,
-				   ep_3550->bios_ctrl);
-		ASC_PRT_NEXT();
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		len = asc_prt_line(cp, leftlen,
-				   " termination: %u (%s), bios_ctrl: 0x%x\n",
-				   ep_38C0800->termination_lvd, termstr,
-				   ep_38C0800->bios_ctrl);
-		ASC_PRT_NEXT();
-	} else {
-		len = asc_prt_line(cp, leftlen,
-				   " termination: %u (%s), bios_ctrl: 0x%x\n",
-				   ep_38C1600->termination_lvd, termstr,
-				   ep_38C1600->bios_ctrl);
-		ASC_PRT_NEXT();
-	}
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+		seq_printf(m,
+			   " termination: %u (%s), bios_ctrl: 0x%x\n",
+			   ep_3550->termination, termstr,
+			   ep_3550->bios_ctrl);
+	else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+		seq_printf(m,
+			   " termination: %u (%s), bios_ctrl: 0x%x\n",
+			   ep_38C0800->termination_lvd, termstr,
+			   ep_38C0800->bios_ctrl);
+	else
+		seq_printf(m,
+			   " termination: %u (%s), bios_ctrl: 0x%x\n",
+			   ep_38C1600->termination_lvd, termstr,
+			   ep_38C1600->bios_ctrl);
 
-	len = asc_prt_line(cp, leftlen, " Target ID:           ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %X", i);
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Target ID:           ");
+	for (i = 0; i <= ADV_MAX_TID; i++)
+		seq_printf(m, " %X", i);
+	seq_printf(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->disc_enable;
@@ -3388,15 +3221,11 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 	} else {
 		word = ep_38C1600->disc_enable;
 	}
-	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Disconnects:         ");
+	for (i = 0; i <= ADV_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->tagqng_able;
@@ -3405,15 +3234,11 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 	} else {
 		word = ep_38C1600->tagqng_able;
 	}
-	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Command Queuing:     ");
+	for (i = 0; i <= ADV_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		word = ep_3550->start_motor;
@@ -3422,42 +3247,28 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 	} else {
 		word = ep_38C1600->start_motor;
 	}
-	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Start Motor:         ");
+	for (i = 0; i <= ADV_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
-		ASC_PRT_NEXT();
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			len = asc_prt_line(cp, leftlen, " %c",
-					   (ep_3550->
-					    sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
-					   'Y' : 'N');
-			ASC_PRT_NEXT();
-		}
-		len = asc_prt_line(cp, leftlen, "\n");
-		ASC_PRT_NEXT();
+		seq_printf(m, " Synchronous Transfer:");
+		for (i = 0; i <= ADV_MAX_TID; i++)
+			seq_printf(m, " %c",
+				   (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
+				   'Y' : 'N');
+		seq_printf(m, "\n");
 	}
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen, " Ultra Transfer:      ");
-		ASC_PRT_NEXT();
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			len = asc_prt_line(cp, leftlen, " %c",
-					   (ep_3550->
-					    ultra_able & ADV_TID_TO_TIDMASK(i))
-					   ? 'Y' : 'N');
-			ASC_PRT_NEXT();
-		}
-		len = asc_prt_line(cp, leftlen, "\n");
-		ASC_PRT_NEXT();
+		seq_printf(m, " Ultra Transfer:      ");
+		for (i = 0; i <= ADV_MAX_TID; i++)
+			seq_printf(m, " %c",
+				   (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i))
+				   ? 'Y' : 'N');
+		seq_printf(m, "\n");
 	}
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
@@ -3467,21 +3278,16 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 	} else {
 		word = ep_38C1600->wdtr_able;
 	}
-	len = asc_prt_line(cp, leftlen, " Wide Transfer:       ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Wide Transfer:       ");
+	for (i = 0; i <= ADV_MAX_TID; i++)
+		seq_printf(m, " %c",
+			   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+	seq_printf(m, "\n");
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
 	    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {
-		len = asc_prt_line(cp, leftlen,
-				   " Synchronous Transfer Speed (Mhz):\n  ");
-		ASC_PRT_NEXT();
+		seq_printf(m,
+			   " Synchronous Transfer Speed (Mhz):\n  ");
 		for (i = 0; i <= ADV_MAX_TID; i++) {
 			char *speed_str;
 
@@ -3517,99 +3323,64 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 				speed_str = "Unk";
 				break;
 			}
-			len = asc_prt_line(cp, leftlen, "%X:%s ", i, speed_str);
-			ASC_PRT_NEXT();
-			if (i == 7) {
-				len = asc_prt_line(cp, leftlen, "\n  ");
-				ASC_PRT_NEXT();
-			}
+			seq_printf(m, "%X:%s ", i, speed_str);
+			if (i == 7)
+				seq_printf(m, "\n  ");
 			sdtr_speed >>= 4;
 		}
-		len = asc_prt_line(cp, leftlen, "\n");
-		ASC_PRT_NEXT();
+		seq_printf(m, "\n");
 	}
-
-	return totlen;
 }
 
 /*
  * asc_prt_driver_conf()
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
-	int leftlen;
-	int totlen;
-	int len;
 	int chip_scsi_id;
 
-	leftlen = cplen;
-	totlen = len = 0;
+	seq_printf(m,
+		"\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
+		shost->host_no);
 
-	len = asc_prt_line(cp, leftlen,
-			   "\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
+		   shost->host_busy, shost->last_reset, shost->max_id,
+		   shost->max_lun, shost->max_channel);
 
-	len = asc_prt_line(cp, leftlen,
-			   " host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
-			   shost->host_busy, shost->last_reset, shost->max_id,
-			   shost->max_lun, shost->max_channel);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
+		   shost->unique_id, shost->can_queue, shost->this_id,
+		   shost->sg_tablesize, shost->cmd_per_lun);
 
-	len = asc_prt_line(cp, leftlen,
-			   " unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
-			   shost->unique_id, shost->can_queue, shost->this_id,
-			   shost->sg_tablesize, shost->cmd_per_lun);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " unchecked_isa_dma %d, use_clustering %d\n",
+		   shost->unchecked_isa_dma, shost->use_clustering);
 
-	len = asc_prt_line(cp, leftlen,
-			   " unchecked_isa_dma %d, use_clustering %d\n",
-			   shost->unchecked_isa_dma, shost->use_clustering);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
+		   boardp->flags, boardp->last_reset, jiffies,
+		   boardp->asc_n_io_port);
 
-	len = asc_prt_line(cp, leftlen,
-			   " flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
-			   boardp->flags, boardp->last_reset, jiffies,
-			   boardp->asc_n_io_port);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " io_port 0x%x\n", shost->io_port);
-	ASC_PRT_NEXT();
+	seq_printf(m, " io_port 0x%x\n", shost->io_port);
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
 	} else {
 		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
 	}
-
-	return totlen;
 }
 
 /*
  * asc_prt_asc_board_info()
  *
  * Print dynamic board configuration information.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
 	int chip_scsi_id;
-	int leftlen;
-	int totlen;
-	int len;
 	ASC_DVC_VAR *v;
 	ASC_DVC_CFG *c;
 	int i;
@@ -3619,105 +3390,79 @@ static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 	c = &boardp->dvc_cfg.asc_dvc_cfg;
 	chip_scsi_id = c->chip_scsi_id;
 
-	leftlen = cplen;
-	totlen = len = 0;
+	seq_printf(m,
+		   "\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+		   shost->host_no);
 
-	len = asc_prt_line(cp, leftlen,
-			   "\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " chip_version %u, mcode_date 0x%x, "
-			   "mcode_version 0x%x, err_code %u\n",
-			   c->chip_version, c->mcode_date, c->mcode_version,
-			   v->err_code);
-	ASC_PRT_NEXT();
+	seq_printf(m, " chip_version %u, mcode_date 0x%x, "
+		   "mcode_version 0x%x, err_code %u\n",
+		   c->chip_version, c->mcode_date, c->mcode_version,
+		   v->err_code);
 
 	/* Current number of commands waiting for the host. */
-	len = asc_prt_line(cp, leftlen,
-			   " Total Command Pending: %d\n", v->cur_total_qng);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " Total Command Pending: %d\n", v->cur_total_qng);
 
-	len = asc_prt_line(cp, leftlen, " Command Queuing:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Command Queuing:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (v->
-				    use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ?
-				   'Y' : 'N');
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%c",
+			   i,
+			   (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	/* Current number of commands waiting for a device. */
-	len = asc_prt_line(cp, leftlen, " Command Queue Pending:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Command Queue Pending:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
-		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->cur_dvc_qng[i]);
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%u", i, v->cur_dvc_qng[i]);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	/* Current limit on number of commands that can be sent to a device. */
-	len = asc_prt_line(cp, leftlen, " Command Queue Limit:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Command Queue Limit:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
-		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->max_dvc_qng[i]);
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%u", i, v->max_dvc_qng[i]);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	/* Indicate whether the device has returned queue full status. */
-	len = asc_prt_line(cp, leftlen, " Command Queue Full:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Command Queue Full:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
-		if (boardp->queue_full & ADV_TID_TO_TIDMASK(i)) {
-			len = asc_prt_line(cp, leftlen, " %X:Y-%d",
-					   i, boardp->queue_full_cnt[i]);
-		} else {
-			len = asc_prt_line(cp, leftlen, " %X:N", i);
-		}
-		ASC_PRT_NEXT();
+		if (boardp->queue_full & ADV_TID_TO_TIDMASK(i))
+			seq_printf(m, " %X:Y-%d",
+				   i, boardp->queue_full_cnt[i]);
+		else
+			seq_printf(m, " %X:N", i);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
-	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Synchronous Transfer:");
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (v->
-				    sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%c",
+			   i,
+			   (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	for (i = 0; i <= ASC_MAX_TID; i++) {
 		uchar syn_period_ix;
@@ -3728,69 +3473,48 @@ static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 			continue;
 		}
 
-		len = asc_prt_line(cp, leftlen, "  %X:", i);
-		ASC_PRT_NEXT();
+		seq_printf(m, "  %X:", i);
 
 		if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {
-			len = asc_prt_line(cp, leftlen, " Asynchronous");
-			ASC_PRT_NEXT();
+			seq_printf(m, " Asynchronous");
 		} else {
 			syn_period_ix =
 			    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -
 							   1);
 
-			len = asc_prt_line(cp, leftlen,
-					   " Transfer Period Factor: %d (%d.%d Mhz),",
-					   v->sdtr_period_tbl[syn_period_ix],
-					   250 /
-					   v->sdtr_period_tbl[syn_period_ix],
-					   ASC_TENTHS(250,
-						      v->
-						      sdtr_period_tbl
-						      [syn_period_ix]));
-			ASC_PRT_NEXT();
+			seq_printf(m,
+				   " Transfer Period Factor: %d (%d.%d Mhz),",
+				   v->sdtr_period_tbl[syn_period_ix],
+				   250 / v->sdtr_period_tbl[syn_period_ix],
+				   ASC_TENTHS(250,
+					      v->sdtr_period_tbl[syn_period_ix]));
 
-			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
-					   boardp->
-					   sdtr_data[i] & ASC_SYN_MAX_OFFSET);
-			ASC_PRT_NEXT();
+			seq_printf(m, " REQ/ACK Offset: %d",
+				   boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET);
 		}
 
 		if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			len = asc_prt_line(cp, leftlen, "*\n");
+			seq_printf(m, "*\n");
 			renegotiate = 1;
 		} else {
-			len = asc_prt_line(cp, leftlen, "\n");
+			seq_printf(m, "\n");
 		}
-		ASC_PRT_NEXT();
 	}
 
 	if (renegotiate) {
-		len = asc_prt_line(cp, leftlen,
-				   " * = Re-negotiation pending before next command.\n");
-		ASC_PRT_NEXT();
+		seq_printf(m,
+			   " * = Re-negotiation pending before next command.\n");
 	}
-
-	return totlen;
 }
 
 /*
  * asc_prt_adv_board_info()
  *
  * Print dynamic board configuration information.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
-	int leftlen;
-	int totlen;
-	int len;
 	int i;
 	ADV_DVC_VAR *v;
 	ADV_DVC_CFG *c;
@@ -3809,47 +3533,35 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 	iop_base = v->iop_base;
 	chip_scsi_id = v->chip_scsi_id;
 
-	leftlen = cplen;
-	totlen = len = 0;
-
-	len = asc_prt_line(cp, leftlen,
-			   "\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   "\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+		   shost->host_no);
 
-	len = asc_prt_line(cp, leftlen,
-			   " iop_base 0x%lx, cable_detect: %X, err_code %u\n",
-			   v->iop_base,
-			   AdvReadWordRegister(iop_base,
-					       IOPW_SCSI_CFG1) & CABLE_DETECT,
-			   v->err_code);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " iop_base 0x%lx, cable_detect: %X, err_code %u\n",
+		   v->iop_base,
+		   AdvReadWordRegister(iop_base,IOPW_SCSI_CFG1) & CABLE_DETECT,
+		   v->err_code);
 
-	len = asc_prt_line(cp, leftlen, " chip_version %u, mcode_date 0x%x, "
-			   "mcode_version 0x%x\n", c->chip_version,
-			   c->mcode_date, c->mcode_version);
-	ASC_PRT_NEXT();
+	seq_printf(m, " chip_version %u, mcode_date 0x%x, "
+		   "mcode_version 0x%x\n", c->chip_version,
+		   c->mcode_date, c->mcode_version);
 
 	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	len = asc_prt_line(cp, leftlen, " Queuing Enabled:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Queuing Enabled:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
 
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%c",
+			   i,
+			   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
-	len = asc_prt_line(cp, leftlen, " Queue Limit:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Queue Limit:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3859,14 +3571,11 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,
 				lrambyte);
 
-		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%d", i, lrambyte);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
-	len = asc_prt_line(cp, leftlen, " Command Pending:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Command Pending:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3876,33 +3585,26 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,
 				lrambyte);
 
-		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%d", i, lrambyte);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	len = asc_prt_line(cp, leftlen, " Wide Enabled:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Wide Enabled:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
 
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%c",
+			   i,
+			   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
-	len = asc_prt_line(cp, leftlen, " Transfer Bit Width:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Transfer Bit Width:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
@@ -3913,37 +3615,30 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
 				lramword);
 
-		len = asc_prt_line(cp, leftlen, " %X:%d",
-				   i, (lramword & 0x8000) ? 16 : 8);
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%d",
+			   i, (lramword & 0x8000) ? 16 : 8);
 
 		if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
 		    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			len = asc_prt_line(cp, leftlen, "*");
-			ASC_PRT_NEXT();
+			seq_printf(m, "*");
 			renegotiate = 1;
 		}
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	len = asc_prt_line(cp, leftlen, " Synchronous Enabled:");
-	ASC_PRT_NEXT();
+	seq_printf(m, " Synchronous Enabled:");
 	for (i = 0; i <= ADV_MAX_TID; i++) {
 		if ((chip_scsi_id == i) ||
 		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
 			continue;
 		}
 
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
+		seq_printf(m, " %X:%c",
+			   i,
+			   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	seq_printf(m, "\n");
 
 	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
 	for (i = 0; i <= ADV_MAX_TID; i++) {
@@ -3959,358 +3654,170 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 			continue;
 		}
 
-		len = asc_prt_line(cp, leftlen, "  %X:", i);
-		ASC_PRT_NEXT();
+		seq_printf(m, "  %X:", i);
 
 		if ((lramword & 0x1F) == 0) {	/* Check for REQ/ACK Offset 0. */
-			len = asc_prt_line(cp, leftlen, " Asynchronous");
-			ASC_PRT_NEXT();
+			seq_printf(m, " Asynchronous");
 		} else {
-			len =
-			    asc_prt_line(cp, leftlen,
-					 " Transfer Period Factor: ");
-			ASC_PRT_NEXT();
+			seq_printf(m, " Transfer Period Factor: ");
 
 			if ((lramword & 0x1F00) == 0x1100) {	/* 80 Mhz */
-				len =
-				    asc_prt_line(cp, leftlen, "9 (80.0 Mhz),");
-				ASC_PRT_NEXT();
+				seq_printf(m, "9 (80.0 Mhz),");
 			} else if ((lramword & 0x1F00) == 0x1000) {	/* 40 Mhz */
-				len =
-				    asc_prt_line(cp, leftlen, "10 (40.0 Mhz),");
-				ASC_PRT_NEXT();
+				seq_printf(m, "10 (40.0 Mhz),");
 			} else {	/* 20 Mhz or below. */
 
 				period = (((lramword >> 8) * 25) + 50) / 4;
 
 				if (period == 0) {	/* Should never happen. */
-					len =
-					    asc_prt_line(cp, leftlen,
-							 "%d (? Mhz), ");
-					ASC_PRT_NEXT();
+					seq_printf(m, "%d (? Mhz), ");
 				} else {
-					len = asc_prt_line(cp, leftlen,
-							   "%d (%d.%d Mhz),",
-							   period, 250 / period,
-							   ASC_TENTHS(250,
-								      period));
-					ASC_PRT_NEXT();
+					seq_printf(m,
+						   "%d (%d.%d Mhz),",
+						   period, 250 / period,
+						   ASC_TENTHS(250, period));
 				}
 			}
 
-			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
-					   lramword & 0x1F);
-			ASC_PRT_NEXT();
+			seq_printf(m, " REQ/ACK Offset: %d",
+				   lramword & 0x1F);
 		}
 
 		if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			len = asc_prt_line(cp, leftlen, "*\n");
+			seq_printf(m, "*\n");
 			renegotiate = 1;
 		} else {
-			len = asc_prt_line(cp, leftlen, "\n");
+			seq_printf(m, "\n");
 		}
-		ASC_PRT_NEXT();
 	}
 
 	if (renegotiate) {
-		len = asc_prt_line(cp, leftlen,
-				   " * = Re-negotiation pending before next command.\n");
-		ASC_PRT_NEXT();
+		seq_printf(m,
+			   " * = Re-negotiation pending before next command.\n");
 	}
-
-	return totlen;
-}
-
-/*
- * asc_proc_copy()
- *
- * Copy proc information to a read buffer taking into account the current
- * read offset in the file and the remaining space in the read buffer.
- */
-static int
-asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
-	      char *cp, int cplen)
-{
-	int cnt = 0;
-
-	ASC_DBG(2, "offset %d, advoffset %d, cplen %d\n",
-		 (unsigned)offset, (unsigned)advoffset, cplen);
-	if (offset <= advoffset) {
-		/* Read offset below current offset, copy everything. */
-		cnt = min(cplen, leftlen);
-		ASC_DBG(2, "curbuf 0x%lx, cp 0x%lx, cnt %d\n",
-			 (ulong)curbuf, (ulong)cp, cnt);
-		memcpy(curbuf, cp, cnt);
-	} else if (offset < advoffset + cplen) {
-		/* Read offset within current range, partial copy. */
-		cnt = (advoffset + cplen) - offset;
-		cp = (cp + cplen) - cnt;
-		cnt = min(cnt, leftlen);
-		ASC_DBG(2, "curbuf 0x%lx, cp 0x%lx, cnt %d\n",
-			 (ulong)curbuf, (ulong)cp, cnt);
-		memcpy(curbuf, cp, cnt);
-	}
-	return cnt;
 }
 
 #ifdef ADVANSYS_STATS
 /*
  * asc_prt_board_stats()
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
+static void asc_prt_board_stats(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
 	struct asc_stats *s = &boardp->asc_stats;
 
-	int leftlen = cplen;
-	int len, totlen = 0;
+	seq_printf(m,
+		   "\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",
+		   shost->host_no);
 
-	len = asc_prt_line(cp, leftlen,
-			   "\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
+		   s->queuecommand, s->reset, s->biosparam,
+		   s->interrupt);
 
-	len = asc_prt_line(cp, leftlen,
-			   " queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
-			   s->queuecommand, s->reset, s->biosparam,
-			   s->interrupt);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
+		   s->callback, s->done, s->build_error,
+		   s->adv_build_noreq, s->adv_build_nosg);
 
-	len = asc_prt_line(cp, leftlen,
-			   " callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
-			   s->callback, s->done, s->build_error,
-			   s->adv_build_noreq, s->adv_build_nosg);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
-			   s->exe_noerror, s->exe_busy, s->exe_error,
-			   s->exe_unknown);
-	ASC_PRT_NEXT();
+	seq_printf(m,
+		   " exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
+		   s->exe_noerror, s->exe_busy, s->exe_error,
+		   s->exe_unknown);
 
 	/*
 	 * Display data transfer statistics.
 	 */
 	if (s->xfer_cnt > 0) {
-		len = asc_prt_line(cp, leftlen, " xfer_cnt %lu, xfer_elem %lu, ",
-				   s->xfer_cnt, s->xfer_elem);
-		ASC_PRT_NEXT();
+		seq_printf(m, " xfer_cnt %lu, xfer_elem %lu, ",
+			   s->xfer_cnt, s->xfer_elem);
 
-		len = asc_prt_line(cp, leftlen, "xfer_bytes %lu.%01lu kb\n",
-				   s->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));
-		ASC_PRT_NEXT();
+		seq_printf(m, "xfer_bytes %lu.%01lu kb\n",
+			   s->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));
 
 		/* Scatter gather transfer statistics */
-		len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
-				   s->xfer_elem / s->xfer_cnt,
-				   ASC_TENTHS(s->xfer_elem, s->xfer_cnt));
-		ASC_PRT_NEXT();
+		seq_printf(m, " avg_num_elem %lu.%01lu, ",
+			   s->xfer_elem / s->xfer_cnt,
+			   ASC_TENTHS(s->xfer_elem, s->xfer_cnt));
 
-		len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
-				   (s->xfer_sect / 2) / s->xfer_elem,
-				   ASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));
-		ASC_PRT_NEXT();
+		seq_printf(m, "avg_elem_size %lu.%01lu kb, ",
+			   (s->xfer_sect / 2) / s->xfer_elem,
+			   ASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));
 
-		len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
-				   (s->xfer_sect / 2) / s->xfer_cnt,
-				   ASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));
-		ASC_PRT_NEXT();
+		seq_printf(m, "avg_xfer_size %lu.%01lu kb\n",
+			   (s->xfer_sect / 2) / s->xfer_cnt,
+			   ASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));
 	}
-
-	return totlen;
 }
 #endif /* ADVANSYS_STATS */
 
 /*
- * advansys_proc_info() - /proc/scsi/advansys/{0,1,2,3,...}
+ * advansys_show_info() - /proc/scsi/advansys/{0,1,2,3,...}
  *
- * *buffer: I/O buffer
- * **start: if inout == FALSE pointer into buffer where user read should start
- * offset: current offset into a /proc/scsi/advansys/[0...] file
- * length: length of buffer
- * hostno: Scsi_Host host_no
- * inout: TRUE - user is writing; FALSE - user is reading
+ * m: seq_file to print into
+ * shost: Scsi_Host
  *
  * Return the number of bytes read from or written to a
  * /proc/scsi/advansys/[0...] file.
- *
- * Note: This function uses the per board buffer 'prtbuf' which is
- * allocated when the board is initialized in advansys_detect(). The
- * buffer is ASC_PRTBUF_SIZE bytes. The function asc_proc_copy() is
- * used to write to the buffer. The way asc_proc_copy() is written
- * if 'prtbuf' is too small it will not be overwritten. Instead the
- * user just won't get all the available statistics.
  */
 static int
-advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
-		   off_t offset, int length, int inout)
+advansys_show_info(struct seq_file *m, struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
-	char *cp;
-	int cplen;
-	int cnt;
-	int totcnt;
-	int leftlen;
-	char *curbuf;
-	off_t advoffset;
 
 	ASC_DBG(1, "begin\n");
 
-	/*
-	 * User write not supported.
-	 */
-	if (inout == TRUE)
-		return -ENOSYS;
-
 	/*
 	 * User read of /proc/scsi/advansys/[0...] file.
 	 */
 
-	/* Copy read data starting at the beginning of the buffer. */
-	*start = buffer;
-	curbuf = buffer;
-	advoffset = 0;
-	totcnt = 0;
-	leftlen = length;
-
 	/*
 	 * Get board configuration information.
 	 *
 	 * advansys_info() returns the board string from its own static buffer.
 	 */
-	cp = (char *)advansys_info(shost);
-	strcat(cp, "\n");
-	cplen = strlen(cp);
 	/* Copy board information. */
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG(1, "totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
-
+	seq_printf(m, "%s\n", (char *)advansys_info(shost));
 	/*
 	 * Display Wide Board BIOS Information.
 	 */
-	if (!ASC_NARROW_BOARD(boardp)) {
-		cp = boardp->prtbuf;
-		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
-		BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
-				  cplen);
-		totcnt += cnt;
-		leftlen -= cnt;
-		if (leftlen == 0) {
-			ASC_DBG(1, "totcnt %d\n", totcnt);
-			return totcnt;
-		}
-		advoffset += cplen;
-		curbuf += cnt;
-	}
+	if (!ASC_NARROW_BOARD(boardp))
+		asc_prt_adv_bios(m, shost);
 
 	/*
 	 * Display driver information for each device attached to the board.
 	 */
-	cp = boardp->prtbuf;
-	cplen = asc_prt_board_devices(shost, cp, ASC_PRTBUF_SIZE);
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG(1, "totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	asc_prt_board_devices(m, shost);
 
 	/*
 	 * Display EEPROM configuration for the board.
 	 */
-	cp = boardp->prtbuf;
-	if (ASC_NARROW_BOARD(boardp)) {
-		cplen = asc_prt_asc_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
-	} else {
-		cplen = asc_prt_adv_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
-	}
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG(1, "totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	if (ASC_NARROW_BOARD(boardp))
+		asc_prt_asc_board_eeprom(m, shost);
+	else
+		asc_prt_adv_board_eeprom(m, shost);
 
 	/*
 	 * Display driver configuration and information for the board.
 	 */
-	cp = boardp->prtbuf;
-	cplen = asc_prt_driver_conf(shost, cp, ASC_PRTBUF_SIZE);
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG(1, "totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	asc_prt_driver_conf(m, shost);
 
 #ifdef ADVANSYS_STATS
 	/*
 	 * Display driver statistics for the board.
 	 */
-	cp = boardp->prtbuf;
-	cplen = asc_prt_board_stats(shost, cp, ASC_PRTBUF_SIZE);
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG(1, "totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	asc_prt_board_stats(m, shost);
 #endif /* ADVANSYS_STATS */
 
 	/*
 	 * Display Asc Library dynamic configuration information
 	 * for the board.
 	 */
-	cp = boardp->prtbuf;
-	if (ASC_NARROW_BOARD(boardp)) {
-		cplen = asc_prt_asc_board_info(shost, cp, ASC_PRTBUF_SIZE);
-	} else {
-		cplen = asc_prt_adv_board_info(shost, cp, ASC_PRTBUF_SIZE);
-	}
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG(1, "totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
-
-	ASC_DBG(1, "totcnt %d\n", totcnt);
-
-	return totcnt;
+	if (ASC_NARROW_BOARD(boardp))
+		asc_prt_asc_board_info(m, shost);
+	else
+		asc_prt_adv_board_info(m, shost);
+	return 0;
 }
 #endif /* CONFIG_PROC_FS */
 
@@ -11743,7 +11250,7 @@ static int AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
 static struct scsi_host_template advansys_template = {
 	.proc_name = DRV_NAME,
 #ifdef CONFIG_PROC_FS
-	.proc_info = advansys_proc_info,
+	.show_info = advansys_show_info,
 #endif
 	.name = DRV_NAME,
 	.info = advansys_info,
@@ -11939,20 +11446,6 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 #endif /* CONFIG_PCI */
 	}
 
-#ifdef CONFIG_PROC_FS
-	/*
-	 * Allocate buffer for printing information from
-	 * /proc/scsi/advansys/[0...].
-	 */
-	boardp->prtbuf = kmalloc(ASC_PRTBUF_SIZE, GFP_KERNEL);
-	if (!boardp->prtbuf) {
-		shost_printk(KERN_ERR, shost, "kmalloc(%d) returned NULL\n",
-				ASC_PRTBUF_SIZE);
-		ret = -ENOMEM;
-		goto err_unmap;
-	}
-#endif /* CONFIG_PROC_FS */
-
 	if (ASC_NARROW_BOARD(boardp)) {
 		/*
 		 * Set the board bus type and PCI IRQ before
@@ -12010,7 +11503,7 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 	}
 
 	if (ret)
-		goto err_free_proc;
+		goto err_unmap;
 
 	/*
 	 * Save the EEPROM configuration so that it can be displayed
@@ -12055,7 +11548,7 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 		ASC_DBG(2, "AscInitSetConfig()\n");
 		ret = AscInitSetConfig(pdev, shost) ? -ENODEV : 0;
 		if (ret)
-			goto err_free_proc;
+			goto err_unmap;
 	} else {
 		ADVEEP_3550_CONFIG *ep_3550;
 		ADVEEP_38C0800_CONFIG *ep_38C0800;
@@ -12290,7 +11783,7 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 				shost_printk(KERN_ERR, shost, "request_dma() "
 						"%d failed %d\n",
 						shost->dma_channel, ret);
-				goto err_free_proc;
+				goto err_unmap;
 			}
 			AscEnableIsaDma(shost->dma_channel);
 		}
@@ -12371,8 +11864,6 @@ static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
 	if (shost->dma_channel != NO_ISA_DMA)
 		free_dma(shost->dma_channel);
 #endif
- err_free_proc:
-	kfree(boardp->prtbuf);
  err_unmap:
 	if (boardp->ioremap_addr)
 		iounmap(boardp->ioremap_addr);
@@ -12406,7 +11897,6 @@ static int advansys_release(struct Scsi_Host *shost)
 		iounmap(board->ioremap_addr);
 		advansys_wide_free_mem(board);
 	}
-	kfree(board->prtbuf);
 	scsi_host_put(shost);
 	ASC_DBG(1, "end\n");
 	return 0;

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 374c4edf4fcb..dcfaee66a8b9 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9526,7 +9526,7 @@ advansys_queuecommand_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *
 
 static DEF_SCSI_QCMD(advansys_queuecommand)
 
-static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
+static ushort AscGetEisaChipCfg(PortAddr iop_base)
 {
 	PortAddr eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
 	    (PortAddr) (ASC_EISA_CFG_IOP_MASK);
@@ -9537,8 +9537,8 @@ static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
  * Return the BIOS address of the adapter at the specified
  * I/O port and with the specified bus type.
  */
-static unsigned short __devinit
-AscGetChipBiosAddress(PortAddr iop_base, unsigned short bus_type)
+static unsigned short AscGetChipBiosAddress(PortAddr iop_base,
+					    unsigned short bus_type)
 {
 	unsigned short cfg_lsw;
 	unsigned short bios_addr;
@@ -9569,7 +9569,7 @@ AscGetChipBiosAddress(PortAddr iop_base, unsigned short bus_type)
 	return bios_addr;
 }
 
-static uchar __devinit AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
+static uchar AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
 {
 	ushort cfg_lsw;
 
@@ -9583,7 +9583,7 @@ static uchar __devinit AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
 	return (AscGetChipScsiID(iop_base));
 }
 
-static unsigned char __devinit AscGetChipScsiCtrl(PortAddr iop_base)
+static unsigned char AscGetChipScsiCtrl(PortAddr iop_base)
 {
 	unsigned char sc;
 
@@ -9593,8 +9593,8 @@ static unsigned char __devinit AscGetChipScsiCtrl(PortAddr iop_base)
 	return sc;
 }
 
-static unsigned char __devinit
-AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
+static unsigned char AscGetChipVersion(PortAddr iop_base,
+				       unsigned short bus_type)
 {
 	if (bus_type & ASC_IS_EISA) {
 		PortAddr eisa_iop;
@@ -9608,7 +9608,7 @@ AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
 }
 
 #ifdef CONFIG_ISA
-static void __devinit AscEnableIsaDma(uchar dma_channel)
+static void AscEnableIsaDma(uchar dma_channel)
 {
 	if (dma_channel < 4) {
 		outp(0x000B, (ushort)(0xC0 | dma_channel));
@@ -9638,7 +9638,7 @@ static int AscStopQueueExe(PortAddr iop_base)
 	return (0);
 }
 
-static ASC_DCNT __devinit AscGetMaxDmaCount(ushort bus_type)
+static ASC_DCNT AscGetMaxDmaCount(ushort bus_type)
 {
 	if (bus_type & ASC_IS_ISA)
 		return ASC_MAX_ISA_DMA_COUNT;
@@ -9648,7 +9648,7 @@ static ASC_DCNT __devinit AscGetMaxDmaCount(ushort bus_type)
 }
 
 #ifdef CONFIG_ISA
-static ushort __devinit AscGetIsaDmaChannel(PortAddr iop_base)
+static ushort AscGetIsaDmaChannel(PortAddr iop_base)
 {
 	ushort channel;
 
@@ -9660,7 +9660,7 @@ static ushort __devinit AscGetIsaDmaChannel(PortAddr iop_base)
 	return (channel + 4);
 }
 
-static ushort __devinit AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
+static ushort AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
 {
 	ushort cfg_lsw;
 	uchar value;
@@ -9678,7 +9678,7 @@ static ushort __devinit AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channe
 	return 0;
 }
 
-static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
+static uchar AscGetIsaDmaSpeed(PortAddr iop_base)
 {
 	uchar speed_value;
 
@@ -9689,7 +9689,7 @@ static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
 	return speed_value;
 }
 
-static uchar __devinit AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
+static uchar AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
 {
 	speed_value &= 0x07;
 	AscSetBank(iop_base, 1);
@@ -9699,7 +9699,7 @@ static uchar __devinit AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
 }
 #endif /* CONFIG_ISA */
 
-static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
+static ushort AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 {
 	int i;
 	PortAddr iop_base;
@@ -9786,7 +9786,7 @@ static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	return warn_code;
 }
 
-static int __devinit AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
+static int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
 {
 	int retry;
 
@@ -9801,12 +9801,12 @@ static int __devinit AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
 	return 0;
 }
 
-static void __devinit AscWaitEEPRead(void)
+static void AscWaitEEPRead(void)
 {
 	mdelay(1);
 }
 
-static ushort __devinit AscReadEEPWord(PortAddr iop_base, uchar addr)
+static ushort AscReadEEPWord(PortAddr iop_base, uchar addr)
 {
 	ushort read_wval;
 	uchar cmd_reg;
@@ -9821,8 +9821,8 @@ static ushort __devinit AscReadEEPWord(PortAddr iop_base, uchar addr)
 	return read_wval;
 }
 
-static ushort __devinit
-AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
+static ushort AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,
+			      ushort bus_type)
 {
 	ushort wval;
 	ushort sum;
@@ -9868,7 +9868,7 @@ AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 	return sum;
 }
 
-static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
+static int AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 {
 	PortAddr iop_base;
 	ushort q_addr;
@@ -9890,12 +9890,12 @@ static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 	return (sta);
 }
 
-static void __devinit AscWaitEEPWrite(void)
+static void AscWaitEEPWrite(void)
 {
 	mdelay(20);
 }
 
-static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
+static int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 {
 	ushort read_back;
 	int retry;
@@ -9914,8 +9914,7 @@ static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 	}
 }
 
-static ushort __devinit
-AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
+static ushort AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
 {
 	ushort read_wval;
 
@@ -9935,8 +9934,8 @@ AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
 	return (read_wval);
 }
 
-static int __devinit
-AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
+static int AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,
+			       ushort bus_type)
 {
 	int n_error;
 	ushort *wbuf;
@@ -10031,8 +10030,8 @@ AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 	return n_error;
 }
 
-static int __devinit
-AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
+static int AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,
+			   ushort bus_type)
 {
 	int retry;
 	int n_error;
@@ -10050,7 +10049,7 @@ AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 	return n_error;
 }
 
-static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
+static ushort AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 {
 	ASCEEP_CONFIG eep_config_buf;
 	ASCEEP_CONFIG *eep_config;
@@ -10215,7 +10214,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static int __devinit AscInitGetConfig(struct Scsi_Host *shost)
+static int AscInitGetConfig(struct Scsi_Host *shost)
 {
 	struct asc_board *board = shost_priv(shost);
 	ASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;
@@ -10269,7 +10268,7 @@ static int __devinit AscInitGetConfig(struct Scsi_Host *shost)
 	return asc_dvc->err_code;
 }
 
-static int __devinit AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
+static int AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
 {
 	struct asc_board *board = shost_priv(shost);
 	ASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;
@@ -10383,7 +10382,7 @@ static int __devinit AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *sh
  * on big-endian platforms so char fields read as words are actually being
  * unswapped on big-endian platforms.
  */
-static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __devinitdata = {
+static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config = {
 	ADV_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
 	0x0000,			/* cfg_msw */
 	0xFFFF,			/* disc_enable */
@@ -10421,7 +10420,7 @@ static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __devinitdata = {
 	0			/* num_of_err */
 };
 
-static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __devinitdata = {
+static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar = {
 	0,			/* cfg_lsw */
 	0,			/* cfg_msw */
 	0,			/* -disc_enable */
@@ -10459,7 +10458,7 @@ static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __devinitdata = {
 	0			/* num_of_err */
 };
 
-static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __devinitdata = {
+static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config = {
 	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
 	0x0000,			/* 01 cfg_msw */
 	0xFFFF,			/* 02 disc_enable */
@@ -10524,7 +10523,7 @@ static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __devinitdata = {
 	0			/* 63 reserved */
 };
 
-static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __devinitdata = {
+static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar = {
 	0,			/* 00 cfg_lsw */
 	0,			/* 01 cfg_msw */
 	0,			/* 02 disc_enable */
@@ -10589,7 +10588,7 @@ static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __devinitdata =
 	0			/* 63 reserved */
 };
 
-static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __devinitdata = {
+static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config = {
 	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
 	0x0000,			/* 01 cfg_msw */
 	0xFFFF,			/* 02 disc_enable */
@@ -10654,7 +10653,7 @@ static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __devinitdata = {
 	0			/* 63 reserved */
 };
 
-static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata = {
+static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar = {
 	0,			/* 00 cfg_lsw */
 	0,			/* 01 cfg_msw */
 	0,			/* 02 disc_enable */
@@ -10723,7 +10722,7 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata =
 /*
  * Wait for EEPROM command to complete
  */
-static void __devinit AdvWaitEEPCmd(AdvPortAddr iop_base)
+static void AdvWaitEEPCmd(AdvPortAddr iop_base)
 {
 	int eep_delay_ms;
 
@@ -10742,7 +10741,7 @@ static void __devinit AdvWaitEEPCmd(AdvPortAddr iop_base)
 /*
  * Read the EEPROM from specified location
  */
-static ushort __devinit AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
+static ushort AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
 {
 	AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
 			     ASC_EEP_CMD_READ | eep_word_addr);
@@ -10753,8 +10752,8 @@ static ushort __devinit AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-static void __devinit
-AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
+static void AdvSet3550EEPConfig(AdvPortAddr iop_base,
+				ADVEEP_3550_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
 	ushort addr, chksum;
@@ -10820,8 +10819,8 @@ AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-static void __devinit
-AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
+static void AdvSet38C0800EEPConfig(AdvPortAddr iop_base,
+				   ADVEEP_38C0800_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
 	ushort *charfields;
@@ -10887,8 +10886,8 @@ AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-static void __devinit
-AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
+static void AdvSet38C1600EEPConfig(AdvPortAddr iop_base,
+				   ADVEEP_38C1600_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
 	ushort *charfields;
@@ -10956,8 +10955,8 @@ AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-static ushort __devinit
-AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
+static ushort AdvGet3550EEPConfig(AdvPortAddr iop_base,
+				  ADVEEP_3550_CONFIG *cfg_buf)
 {
 	ushort wval, chksum;
 	ushort *wbuf;
@@ -10999,8 +10998,8 @@ AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-static ushort __devinit
-AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
+static ushort AdvGet38C0800EEPConfig(AdvPortAddr iop_base,
+				     ADVEEP_38C0800_CONFIG *cfg_buf)
 {
 	ushort wval, chksum;
 	ushort *wbuf;
@@ -11042,8 +11041,8 @@ AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-static ushort __devinit
-AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
+static ushort AdvGet38C1600EEPConfig(AdvPortAddr iop_base,
+				     ADVEEP_38C1600_CONFIG *cfg_buf)
 {
 	ushort wval, chksum;
 	ushort *wbuf;
@@ -11092,7 +11091,7 @@ AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
  *
  * Note: Chip is stopped on entry.
  */
-static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
+static int AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
@@ -11242,7 +11241,7 @@ static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
  *
  * Note: Chip is stopped on entry.
  */
-static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
+static int AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
@@ -11441,7 +11440,7 @@ static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
  *
  * Note: Chip is stopped on entry.
  */
-static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
+static int AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
@@ -11661,8 +11660,7 @@ static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
  * For a non-fatal error return a warning code. If there are no warnings
  * then 0 is returned.
  */
-static int __devinit
-AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
+static int AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
 {
 	struct asc_board *board = shost_priv(shost);
 	ADV_DVC_VAR *asc_dvc = &board->dvc_var.adv_dvc_var;
@@ -11769,7 +11767,7 @@ static struct scsi_host_template advansys_template = {
 	.use_clustering = ENABLE_CLUSTERING,
 };
 
-static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
+static int advansys_wide_init_chip(struct Scsi_Host *shost)
 {
 	struct asc_board *board = shost_priv(shost);
 	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
@@ -11882,8 +11880,8 @@ static void advansys_wide_free_mem(struct asc_board *board)
 	}
 }
 
-static int __devinit advansys_board_found(struct Scsi_Host *shost,
-					  unsigned int iop, int bus_type)
+static int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,
+				int bus_type)
 {
 	struct pci_dev *pdev;
 	struct asc_board *boardp = shost_priv(shost);
@@ -12428,7 +12426,7 @@ static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] = {
  * 10: 12
  * 11: 15
  */
-static unsigned int __devinit advansys_isa_irq_no(PortAddr iop_base)
+static unsigned int advansys_isa_irq_no(PortAddr iop_base)
 {
 	unsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);
 	unsigned int chip_irq = ((cfg_lsw >> 2) & 0x03) + 10;
@@ -12437,7 +12435,7 @@ static unsigned int __devinit advansys_isa_irq_no(PortAddr iop_base)
 	return chip_irq;
 }
 
-static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
+static int advansys_isa_probe(struct device *dev, unsigned int id)
 {
 	int err = -ENODEV;
 	PortAddr iop_base = _asc_def_iop_base[id];
@@ -12477,7 +12475,7 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	return err;
 }
 
-static int __devexit advansys_isa_remove(struct device *dev, unsigned int id)
+static int advansys_isa_remove(struct device *dev, unsigned int id)
 {
 	int ioport = _asc_def_iop_base[id];
 	advansys_release(dev_get_drvdata(dev));
@@ -12487,7 +12485,7 @@ static int __devexit advansys_isa_remove(struct device *dev, unsigned int id)
 
 static struct isa_driver advansys_isa_driver = {
 	.probe		= advansys_isa_probe,
-	.remove		= __devexit_p(advansys_isa_remove),
+	.remove		= advansys_isa_remove,
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= DRV_NAME,
@@ -12505,7 +12503,7 @@ static struct isa_driver advansys_isa_driver = {
  * 110: 15
  * 111: invalid
  */
-static unsigned int __devinit advansys_vlb_irq_no(PortAddr iop_base)
+static unsigned int advansys_vlb_irq_no(PortAddr iop_base)
 {
 	unsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);
 	unsigned int chip_irq = ((cfg_lsw >> 2) & 0x07) + 9;
@@ -12514,7 +12512,7 @@ static unsigned int __devinit advansys_vlb_irq_no(PortAddr iop_base)
 	return chip_irq;
 }
 
-static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
+static int advansys_vlb_probe(struct device *dev, unsigned int id)
 {
 	int err = -ENODEV;
 	PortAddr iop_base = _asc_def_iop_base[id];
@@ -12561,14 +12559,14 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 
 static struct isa_driver advansys_vlb_driver = {
 	.probe		= advansys_vlb_probe,
-	.remove		= __devexit_p(advansys_isa_remove),
+	.remove		= advansys_isa_remove,
 	.driver = {
 		.owner	= THIS_MODULE,
 		.name	= "advansys_vlb",
 	},
 };
 
-static struct eisa_device_id advansys_eisa_table[] __devinitdata = {
+static struct eisa_device_id advansys_eisa_table[] = {
 	{ "ABP7401" },
 	{ "ABP7501" },
 	{ "" }
@@ -12595,7 +12593,7 @@ struct eisa_scsi_data {
  * 110: invalid
  * 111: invalid
  */
-static unsigned int __devinit advansys_eisa_irq_no(struct eisa_device *edev)
+static unsigned int advansys_eisa_irq_no(struct eisa_device *edev)
 {
 	unsigned short cfg_lsw = inw(edev->base_addr + 0xc86);
 	unsigned int chip_irq = ((cfg_lsw >> 8) & 0x07) + 10;
@@ -12604,7 +12602,7 @@ static unsigned int __devinit advansys_eisa_irq_no(struct eisa_device *edev)
 	return chip_irq;
 }
 
-static int __devinit advansys_eisa_probe(struct device *dev)
+static int advansys_eisa_probe(struct device *dev)
 {
 	int i, ioport, irq = 0;
 	int err;
@@ -12677,7 +12675,7 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 	return err;
 }
 
-static __devexit int advansys_eisa_remove(struct device *dev)
+static int advansys_eisa_remove(struct device *dev)
 {
 	int i;
 	struct eisa_scsi_data *data = dev_get_drvdata(dev);
@@ -12701,12 +12699,12 @@ static struct eisa_driver advansys_eisa_driver = {
 	.driver = {
 		.name =		DRV_NAME,
 		.probe =	advansys_eisa_probe,
-		.remove =	__devexit_p(advansys_eisa_remove),
+		.remove =	advansys_eisa_remove,
 	}
 };
 
 /* PCI Devices supported by this driver */
-static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
+static struct pci_device_id advansys_pci_tbl[] = {
 	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940,
@@ -12724,7 +12722,7 @@ static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
 
-static void __devinit advansys_set_latency(struct pci_dev *pdev)
+static void advansys_set_latency(struct pci_dev *pdev)
 {
 	if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
 	    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
@@ -12737,8 +12735,8 @@ static void __devinit advansys_set_latency(struct pci_dev *pdev)
 	}
 }
 
-static int __devinit
-advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+static int advansys_pci_probe(struct pci_dev *pdev,
+			      const struct pci_device_id *ent)
 {
 	int err, ioport;
 	struct Scsi_Host *shost;
@@ -12791,7 +12789,7 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	return err;
 }
 
-static void __devexit advansys_pci_remove(struct pci_dev *pdev)
+static void advansys_pci_remove(struct pci_dev *pdev)
 {
 	advansys_release(pci_get_drvdata(pdev));
 	pci_release_regions(pdev);
@@ -12802,7 +12800,7 @@ static struct pci_driver advansys_pci_driver = {
 	.name =		DRV_NAME,
 	.id_table =	advansys_pci_tbl,
 	.probe =	advansys_pci_probe,
-	.remove =	__devexit_p(advansys_pci_remove),
+	.remove =	advansys_pci_remove,
 };
 
 static int __init advansys_init(void)

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index bfd618a69499..374c4edf4fcb 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -41,7 +41,6 @@
 #include <linux/firmware.h>
 
 #include <asm/io.h>
-#include <asm/system.h>
 #include <asm/dma.h>
 
 #include <scsi/scsi_cmnd.h>

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 081c6de92bc5..bfd618a69499 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4544,7 +4544,7 @@ AscMemWordCopyPtrToLram(PortAddr iop_base, ushort s_addr,
  * Copy 4 bytes to LRAM.
  *
  * The source data is assumed to be in little-endian order in memory
- * and is maintained in little-endian order when writen to LRAM.
+ * and is maintained in little-endian order when written to LRAM.
  */
 static void
 AscMemDWordCopyPtrToLram(PortAddr iop_base,

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0ec3da6f3e12..081c6de92bc5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9500,7 +9500,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
  * in the 'scp' result field.
  */
 static int
-advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+advansys_queuecommand_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *shost = scp->device->host;
 	int asc_res, result = 0;
@@ -9525,6 +9525,8 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 	return result;
 }
 
+static DEF_SCSI_QCMD(advansys_queuecommand)
+
 static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
 {
 	PortAddr eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |

commit 421f91d21ad6f799dc7b489bb33cc560ccc56f98
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Jun 11 12:17:00 2010 +0200

    fix typos concerning "initiali[zs]e"
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 7f87979da22d..0ec3da6f3e12 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9717,7 +9717,7 @@ static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	asc_dvc->bug_fix_cntl = 0;
 	asc_dvc->pci_fix_asyn_xfer = 0;
 	asc_dvc->pci_fix_asyn_xfer_always = 0;
-	/* asc_dvc->init_state initalized in AscInitGetConfig(). */
+	/* asc_dvc->init_state initialized in AscInitGetConfig(). */
 	asc_dvc->sdtr_done = 0;
 	asc_dvc->cur_total_qng = 0;
 	asc_dvc->is_in_int = 0;

commit 9a908c1aa4d3898f62e2cb8af6936b16503ab3e6
Author: Herton Ronaldo Krzesinski <herton@mandriva.com.br>
Date:   Tue Mar 30 13:35:38 2010 -0300

    [SCSI] advansys: fix narrow board error path
    
    Error handling on advansys_board_found is fixed, because it's buggy in
    the case we have an ASC_NARROW_BOARD set and failure happens on
    AscInitAsc1000Driver step: it was freeing items of wrong struct in the
    dvc_var union of struct asc_board, which could lead to an oops in the
    case we set some of the fields in struct of narrow board as code was
    choosing to always freeing wide board fields, and not everything was
    being freed/released properly.
    
    Signed-off-by: Herton Ronaldo Krzesinski <herton@mandriva.com.br>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9201afe65609..7f87979da22d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4724,6 +4724,10 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	BUG_ON((unsigned long)asc_dvc->overrun_buf & 7);
 	asc_dvc->overrun_dma = dma_map_single(board->dev, asc_dvc->overrun_buf,
 					ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);
+	if (dma_mapping_error(board->dev, asc_dvc->overrun_dma)) {
+		warn_code = -ENOMEM;
+		goto err_dma_map;
+	}
 	phy_addr = cpu_to_le32(asc_dvc->overrun_dma);
 	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
 				 (uchar *)&phy_addr, 1);
@@ -4739,14 +4743,23 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
 	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
 		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
-		return warn_code;
+		warn_code = UW_ERR;
+		goto err_mcode_start;
 	}
 	if (AscStartChip(iop_base) != 1) {
 		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
-		return warn_code;
+		warn_code = UW_ERR;
+		goto err_mcode_start;
 	}
 
 	return warn_code;
+
+err_mcode_start:
+	dma_unmap_single(board->dev, asc_dvc->overrun_dma,
+			 ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);
+err_dma_map:
+	asc_dvc->overrun_dma = 0;
+	return warn_code;
 }
 
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
@@ -4802,6 +4815,8 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	}
 	release_firmware(fw);
 	warn_code |= AscInitMicroCodeVar(asc_dvc);
+	if (!asc_dvc->overrun_dma)
+		return warn_code;
 	asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
 	AscEnableInterrupt(iop_base);
 	return warn_code;
@@ -7978,9 +7993,10 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		status = AscInitAsc1000Driver(asc_dvc);
 
 		/* Refer to ASC_IERR_* definitions for meaning of 'err_code'. */
-		if (asc_dvc->err_code) {
+		if (asc_dvc->err_code || !asc_dvc->overrun_dma) {
 			scmd_printk(KERN_INFO, scp, "SCSI bus reset error: "
-				    "0x%x\n", asc_dvc->err_code);
+				    "0x%x, status: 0x%x\n", asc_dvc->err_code,
+				    status);
 			ret = FAILED;
 		} else if (status) {
 			scmd_printk(KERN_INFO, scp, "SCSI bus reset warning: "
@@ -12311,7 +12327,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		asc_dvc_varp->overrun_buf = kzalloc(ASC_OVERRUN_BSIZE, GFP_KERNEL);
 		if (!asc_dvc_varp->overrun_buf) {
 			ret = -ENOMEM;
-			goto err_free_wide_mem;
+			goto err_free_irq;
 		}
 		warn_code = AscInitAsc1000Driver(asc_dvc_varp);
 
@@ -12320,30 +12336,36 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 					"warn 0x%x, error 0x%x\n",
 					asc_dvc_varp->init_state, warn_code,
 					asc_dvc_varp->err_code);
-			if (asc_dvc_varp->err_code) {
+			if (!asc_dvc_varp->overrun_dma) {
 				ret = -ENODEV;
-				kfree(asc_dvc_varp->overrun_buf);
+				goto err_free_mem;
 			}
 		}
 	} else {
-		if (advansys_wide_init_chip(shost))
+		if (advansys_wide_init_chip(shost)) {
 			ret = -ENODEV;
+			goto err_free_mem;
+		}
 	}
 
-	if (ret)
-		goto err_free_wide_mem;
-
 	ASC_DBG_PRT_SCSI_HOST(2, shost);
 
 	ret = scsi_add_host(shost, boardp->dev);
 	if (ret)
-		goto err_free_wide_mem;
+		goto err_free_mem;
 
 	scsi_scan_host(shost);
 	return 0;
 
- err_free_wide_mem:
-	advansys_wide_free_mem(boardp);
+ err_free_mem:
+	if (ASC_NARROW_BOARD(boardp)) {
+		if (asc_dvc_varp->overrun_dma)
+			dma_unmap_single(boardp->dev, asc_dvc_varp->overrun_dma,
+					 ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);
+		kfree(asc_dvc_varp->overrun_buf);
+	} else
+		advansys_wide_free_mem(boardp);
+ err_free_irq:
 	free_irq(boardp->irq, shost);
  err_free_dma:
 #ifdef CONFIG_ISA

commit cf7474451c3a3cf07811abbf2a39536d33046c36
Author: Herton Ronaldo Krzesinski <herton@mandriva.com.br>
Date:   Fri Mar 19 19:37:26 2010 -0300

    [SCSI] advansys: fix regression with request_firmware change
    
    On newer kernels users of advansys module are reporting system hang when
    trying to load it without firmware files present. After looking closely
    at description on https://qa.mandriva.com/show_bug.cgi?id=53220, I think
    this is related to commit "[SCSI] advansys: use request_firmware". The
    problem is that after switch to request_firmware, asc_dvc->err_code
    isn't being set when firmware files aren't found or loading fails.
    
    err_code is used by the driver to judge if there was a fatal error or
    not, as can be seen for example on advansys_board_found, which will only
    return -ENODEV when err_code is set. Because err_code isn't being set
    when request_firmware fails, this is a change of behaviour of the code
    before request_firmware addition, making it continue to load and it
    fails later as the firmware wasn't really loaded.
    
    Signed-off-by: Herton Ronaldo Krzesinski <herton@mandriva.com.br>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 22626abdb630..9201afe65609 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4781,12 +4781,14 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	if (err) {
 		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
 		       fwname, err);
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
 		return err;
 	}
 	if (fw->size < 4) {
 		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
 		       fw->size, fwname);
 		release_firmware(fw);
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
 		return -EINVAL;
 	}
 	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
@@ -5110,12 +5112,14 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	if (err) {
 		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
 		       fwname, err);
+		asc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;
 		return err;
 	}
 	if (fw->size < 4) {
 		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
 		       fw->size, fwname);
 		release_firmware(fw);
+		asc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;
 		return -EINVAL;
 	}
 	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
@@ -5624,12 +5628,14 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	if (err) {
 		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
 		       fwname, err);
+		asc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;
 		return err;
 	}
 	if (fw->size < 4) {
 		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
 		       fw->size, fwname);
 		release_firmware(fw);
+		asc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;
 		return -EINVAL;
 	}
 	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
@@ -6124,12 +6130,14 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	if (err) {
 		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
 		       fwname, err);
+		asc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;
 		return err;
 	}
 	if (fw->size < 4) {
 		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
 		       fw->size, fwname);
 		release_firmware(fw);
+		asc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;
 		return -EINVAL;
 	}
 	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |

commit 6070d81eb5f2d4943223c96e7609a53cdc984364
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Fri Dec 4 15:47:01 2009 -0500

    tree-wide: fix misspelling of "definition" in comments
    
    "Definition" is misspelled "defintion" in several comments; this
    patch fixes them. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index b756041f0b26..22626abdb630 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -7969,7 +7969,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		ASC_DBG(1, "before AscInitAsc1000Driver()\n");
 		status = AscInitAsc1000Driver(asc_dvc);
 
-		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
+		/* Refer to ASC_IERR_* definitions for meaning of 'err_code'. */
 		if (asc_dvc->err_code) {
 			scmd_printk(KERN_INFO, scp, "SCSI bus reset error: "
 				    "0x%x\n", asc_dvc->err_code);

commit 989bb5f58c14b87f059755f4bbb4b72408c76d9a
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Thu Apr 2 11:28:06 2009 +0530

    [SCSI] advansys: use request_firmware
    
    Firmware blob looks like this...
            __le32 checksum
            unsigned char data[]
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 7507d8bc57a1..b756041f0b26 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -38,6 +38,7 @@
 #include <linux/pci.h>
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
+#include <linux/firmware.h>
 
 #include <asm/io.h>
 #include <asm/system.h>
@@ -4519,8 +4520,8 @@ static void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)
  * and is maintained in little-endian order when written to LRAM.
  */
 static void
-AscMemWordCopyPtrToLram(PortAddr iop_base,
-			ushort s_addr, uchar *s_buffer, int words)
+AscMemWordCopyPtrToLram(PortAddr iop_base, ushort s_addr,
+			const uchar *s_buffer, int words)
 {
 	int i;
 
@@ -4642,8 +4643,8 @@ static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
 }
 
 static ASC_DCNT
-AscLoadMicroCode(PortAddr iop_base,
-		 ushort s_addr, uchar *mcode_buf, ushort mcode_size)
+AscLoadMicroCode(PortAddr iop_base, ushort s_addr,
+		 const uchar *mcode_buf, ushort mcode_size)
 {
 	ASC_DCNT chksum;
 	ushort mcode_word_size;
@@ -4668,1618 +4669,6 @@ AscLoadMicroCode(PortAddr iop_base,
 	return chksum;
 }
 
-/* Microcode buffer is kept after initialization for error recovery. */
-static uchar _asc_mcode_buf[] = {
-	0x01, 0x03, 0x01, 0x19, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x12, 0x0D, 0x05,
-	0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0xFF, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0xE4, 0x88, 0x00, 0x00, 0x00, 0x00, 0x80, 0x73, 0x48, 0x04,
-	0x36, 0x00, 0x00, 0xA2, 0xC2, 0x00, 0x80, 0x73, 0x03, 0x23, 0x36, 0x40,
-	0xB6, 0x00, 0x36, 0x00, 0x05, 0xD6, 0x0C, 0xD2, 0x12, 0xDA, 0x00, 0xA2,
-	0xC2, 0x00, 0x92, 0x80, 0x1E, 0x98, 0x50, 0x00, 0xF5, 0x00, 0x48, 0x98,
-	0xDF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x4F, 0x00, 0xF5, 0x00,
-	0x48, 0x98, 0xEF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x80, 0x62,
-	0x92, 0x80, 0x00, 0x46, 0x15, 0xEE, 0x13, 0xEA, 0x02, 0x01, 0x09, 0xD8,
-	0xCD, 0x04, 0x4D, 0x00, 0x00, 0xA3, 0xD6, 0x00, 0xA6, 0x97, 0x7F, 0x23,
-	0x04, 0x61, 0x84, 0x01, 0xE6, 0x84, 0xD2, 0xC1, 0x80, 0x73, 0xCD, 0x04,
-	0x4D, 0x00, 0x00, 0xA3, 0xDA, 0x01, 0xA6, 0x97, 0xC6, 0x81, 0xC2, 0x88,
-	0x80, 0x73, 0x80, 0x77, 0x00, 0x01, 0x01, 0xA1, 0xFE, 0x00, 0x4F, 0x00,
-	0x84, 0x97, 0x07, 0xA6, 0x08, 0x01, 0x00, 0x33, 0x03, 0x00, 0xC2, 0x88,
-	0x03, 0x03, 0x01, 0xDE, 0xC2, 0x88, 0xCE, 0x00, 0x69, 0x60, 0xCE, 0x00,
-	0x02, 0x03, 0x4A, 0x60, 0x00, 0xA2, 0x78, 0x01, 0x80, 0x63, 0x07, 0xA6,
-	0x24, 0x01, 0x78, 0x81, 0x03, 0x03, 0x80, 0x63, 0xE2, 0x00, 0x07, 0xA6,
-	0x34, 0x01, 0x00, 0x33, 0x04, 0x00, 0xC2, 0x88, 0x03, 0x07, 0x02, 0x01,
-	0x04, 0xCA, 0x0D, 0x23, 0x68, 0x98, 0x4D, 0x04, 0x04, 0x85, 0x05, 0xD8,
-	0x0D, 0x23, 0x68, 0x98, 0xCD, 0x04, 0x15, 0x23, 0xF8, 0x88, 0xFB, 0x23,
-	0x02, 0x61, 0x82, 0x01, 0x80, 0x63, 0x02, 0x03, 0x06, 0xA3, 0x62, 0x01,
-	0x00, 0x33, 0x0A, 0x00, 0xC2, 0x88, 0x4E, 0x00, 0x07, 0xA3, 0x6E, 0x01,
-	0x00, 0x33, 0x0B, 0x00, 0xC2, 0x88, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33,
-	0x1A, 0x00, 0xC2, 0x88, 0x50, 0x04, 0x88, 0x81, 0x06, 0xAB, 0x82, 0x01,
-	0x88, 0x81, 0x4E, 0x00, 0x07, 0xA3, 0x92, 0x01, 0x50, 0x00, 0x00, 0xA3,
-	0x3C, 0x01, 0x00, 0x05, 0x7C, 0x81, 0x46, 0x97, 0x02, 0x01, 0x05, 0xC6,
-	0x04, 0x23, 0xA0, 0x01, 0x15, 0x23, 0xA1, 0x01, 0xBE, 0x81, 0xFD, 0x23,
-	0x02, 0x61, 0x82, 0x01, 0x0A, 0xDA, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA0,
-	0xB4, 0x01, 0x80, 0x63, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33, 0x1B, 0x00,
-	0xC2, 0x88, 0x06, 0x23, 0x68, 0x98, 0xCD, 0x04, 0xE6, 0x84, 0x06, 0x01,
-	0x00, 0xA2, 0xD4, 0x01, 0x57, 0x60, 0x00, 0xA0, 0xDA, 0x01, 0xE6, 0x84,
-	0x80, 0x23, 0xA0, 0x01, 0xE6, 0x84, 0x80, 0x73, 0x4B, 0x00, 0x06, 0x61,
-	0x00, 0xA2, 0x00, 0x02, 0x04, 0x01, 0x0C, 0xDE, 0x02, 0x01, 0x03, 0xCC,
-	0x4F, 0x00, 0x84, 0x97, 0xFC, 0x81, 0x08, 0x23, 0x02, 0x41, 0x82, 0x01,
-	0x4F, 0x00, 0x62, 0x97, 0x48, 0x04, 0x84, 0x80, 0xF0, 0x97, 0x00, 0x46,
-	0x56, 0x00, 0x03, 0xC0, 0x01, 0x23, 0xE8, 0x00, 0x81, 0x73, 0x06, 0x29,
-	0x03, 0x42, 0x06, 0xE2, 0x03, 0xEE, 0x6B, 0xEB, 0x11, 0x23, 0xF8, 0x88,
-	0x04, 0x98, 0xF0, 0x80, 0x80, 0x73, 0x80, 0x77, 0x07, 0xA4, 0x2A, 0x02,
-	0x7C, 0x95, 0x06, 0xA6, 0x34, 0x02, 0x03, 0xA6, 0x4C, 0x04, 0x46, 0x82,
-	0x04, 0x01, 0x03, 0xD8, 0xB4, 0x98, 0x6A, 0x96, 0x46, 0x82, 0xFE, 0x95,
-	0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0xB6, 0x2D, 0x02, 0xA6, 0x6C, 0x02,
-	0x07, 0xA6, 0x5A, 0x02, 0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x62, 0x02,
-	0xC2, 0x88, 0x7C, 0x95, 0x48, 0x82, 0x60, 0x96, 0x48, 0x82, 0x04, 0x23,
-	0xA0, 0x01, 0x14, 0x23, 0xA1, 0x01, 0x3C, 0x84, 0x04, 0x01, 0x0C, 0xDC,
-	0xE0, 0x23, 0x25, 0x61, 0xEF, 0x00, 0x14, 0x01, 0x4F, 0x04, 0xA8, 0x01,
-	0x6F, 0x00, 0xA5, 0x01, 0x03, 0x23, 0xA4, 0x01, 0x06, 0x23, 0x9C, 0x01,
-	0x24, 0x2B, 0x1C, 0x01, 0x02, 0xA6, 0xAA, 0x02, 0x07, 0xA6, 0x5A, 0x02,
-	0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x20, 0x04, 0x01, 0xA6, 0xB4, 0x02,
-	0x00, 0xA6, 0xB4, 0x02, 0x00, 0x33, 0x12, 0x00, 0xC2, 0x88, 0x00, 0x0E,
-	0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0x8C, 0x02, 0x4D, 0x04, 0x04, 0x01,
-	0x0B, 0xDC, 0xE7, 0x23, 0x04, 0x61, 0x84, 0x01, 0x10, 0x31, 0x12, 0x35,
-	0x14, 0x01, 0xEC, 0x00, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0xEA, 0x82,
-	0x18, 0x23, 0x04, 0x61, 0x18, 0xA0, 0xE2, 0x02, 0x04, 0x01, 0xA2, 0xC8,
-	0x00, 0x33, 0x1F, 0x00, 0xC2, 0x88, 0x08, 0x31, 0x0A, 0x35, 0x0C, 0x39,
-	0x0E, 0x3D, 0x7E, 0x98, 0xB6, 0x2D, 0x01, 0xA6, 0x14, 0x03, 0x00, 0xA6,
-	0x14, 0x03, 0x07, 0xA6, 0x0C, 0x03, 0x06, 0xA6, 0x10, 0x03, 0x03, 0xA6,
-	0x20, 0x04, 0x02, 0xA6, 0x6C, 0x02, 0x00, 0x33, 0x33, 0x00, 0xC2, 0x88,
-	0x7C, 0x95, 0xEE, 0x82, 0x60, 0x96, 0xEE, 0x82, 0x82, 0x98, 0x80, 0x42,
-	0x7E, 0x98, 0x64, 0xE4, 0x04, 0x01, 0x2D, 0xC8, 0x31, 0x05, 0x07, 0x01,
-	0x00, 0xA2, 0x54, 0x03, 0x00, 0x43, 0x87, 0x01, 0x05, 0x05, 0x86, 0x98,
-	0x7E, 0x98, 0x00, 0xA6, 0x16, 0x03, 0x07, 0xA6, 0x4C, 0x03, 0x03, 0xA6,
-	0x3C, 0x04, 0x06, 0xA6, 0x50, 0x03, 0x01, 0xA6, 0x16, 0x03, 0x00, 0x33,
-	0x25, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x32, 0x83, 0x60, 0x96, 0x32, 0x83,
-	0x04, 0x01, 0x10, 0xCE, 0x07, 0xC8, 0x05, 0x05, 0xEB, 0x04, 0x00, 0x33,
-	0x00, 0x20, 0xC0, 0x20, 0x81, 0x62, 0x72, 0x83, 0x00, 0x01, 0x05, 0x05,
-	0xFF, 0xA2, 0x7A, 0x03, 0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x2E, 0x83,
-	0x05, 0x05, 0x15, 0x01, 0x00, 0xA2, 0x9A, 0x03, 0xEC, 0x00, 0x6E, 0x00,
-	0x95, 0x01, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0x01, 0xA6, 0x96, 0x03,
-	0x00, 0xA6, 0x96, 0x03, 0x10, 0x84, 0x80, 0x42, 0x7E, 0x98, 0x01, 0xA6,
-	0xA4, 0x03, 0x00, 0xA6, 0xBC, 0x03, 0x10, 0x84, 0xA8, 0x98, 0x80, 0x42,
-	0x01, 0xA6, 0xA4, 0x03, 0x07, 0xA6, 0xB2, 0x03, 0xD4, 0x83, 0x7C, 0x95,
-	0xA8, 0x83, 0x00, 0x33, 0x2F, 0x00, 0xC2, 0x88, 0xA8, 0x98, 0x80, 0x42,
-	0x00, 0xA6, 0xBC, 0x03, 0x07, 0xA6, 0xCA, 0x03, 0xD4, 0x83, 0x7C, 0x95,
-	0xC0, 0x83, 0x00, 0x33, 0x26, 0x00, 0xC2, 0x88, 0x38, 0x2B, 0x80, 0x32,
-	0x80, 0x36, 0x04, 0x23, 0xA0, 0x01, 0x12, 0x23, 0xA1, 0x01, 0x10, 0x84,
-	0x07, 0xF0, 0x06, 0xA4, 0xF4, 0x03, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23,
-	0x83, 0x03, 0x80, 0x63, 0x03, 0xA6, 0x0E, 0x04, 0x07, 0xA6, 0x06, 0x04,
-	0x06, 0xA6, 0x0A, 0x04, 0x00, 0x33, 0x17, 0x00, 0xC2, 0x88, 0x7C, 0x95,
-	0xF4, 0x83, 0x60, 0x96, 0xF4, 0x83, 0x20, 0x84, 0x07, 0xF0, 0x06, 0xA4,
-	0x20, 0x04, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23, 0x83, 0x03, 0x80, 0x63,
-	0xB6, 0x2D, 0x03, 0xA6, 0x3C, 0x04, 0x07, 0xA6, 0x34, 0x04, 0x06, 0xA6,
-	0x38, 0x04, 0x00, 0x33, 0x30, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x20, 0x84,
-	0x60, 0x96, 0x20, 0x84, 0x1D, 0x01, 0x06, 0xCC, 0x00, 0x33, 0x00, 0x84,
-	0xC0, 0x20, 0x00, 0x23, 0xEA, 0x00, 0x81, 0x62, 0xA2, 0x0D, 0x80, 0x63,
-	0x07, 0xA6, 0x5A, 0x04, 0x00, 0x33, 0x18, 0x00, 0xC2, 0x88, 0x03, 0x03,
-	0x80, 0x63, 0xA3, 0x01, 0x07, 0xA4, 0x64, 0x04, 0x23, 0x01, 0x00, 0xA2,
-	0x86, 0x04, 0x0A, 0xA0, 0x76, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1D, 0x00,
-	0xC2, 0x88, 0x0B, 0xA0, 0x82, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1E, 0x00,
-	0xC2, 0x88, 0x42, 0x23, 0xF8, 0x88, 0x00, 0x23, 0x22, 0xA3, 0xE6, 0x04,
-	0x08, 0x23, 0x22, 0xA3, 0xA2, 0x04, 0x28, 0x23, 0x22, 0xA3, 0xAE, 0x04,
-	0x02, 0x23, 0x22, 0xA3, 0xC4, 0x04, 0x42, 0x23, 0xF8, 0x88, 0x4A, 0x00,
-	0x06, 0x61, 0x00, 0xA0, 0xAE, 0x04, 0x45, 0x23, 0xF8, 0x88, 0x04, 0x98,
-	0x00, 0xA2, 0xC0, 0x04, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x82, 0xC0, 0x20,
-	0x81, 0x62, 0xE8, 0x81, 0x47, 0x23, 0xF8, 0x88, 0x04, 0x01, 0x0B, 0xDE,
-	0x04, 0x98, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x81, 0xC0, 0x20, 0x81, 0x62,
-	0x14, 0x01, 0x00, 0xA0, 0x00, 0x02, 0x43, 0x23, 0xF8, 0x88, 0x04, 0x23,
-	0xA0, 0x01, 0x44, 0x23, 0xA1, 0x01, 0x80, 0x73, 0x4D, 0x00, 0x03, 0xA3,
-	0xF4, 0x04, 0x00, 0x33, 0x27, 0x00, 0xC2, 0x88, 0x04, 0x01, 0x04, 0xDC,
-	0x02, 0x23, 0xA2, 0x01, 0x04, 0x23, 0xA0, 0x01, 0x04, 0x98, 0x26, 0x95,
-	0x4B, 0x00, 0xF6, 0x00, 0x4F, 0x04, 0x4F, 0x00, 0x00, 0xA3, 0x22, 0x05,
-	0x00, 0x05, 0x76, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x1C, 0x05, 0x0A, 0x85,
-	0x46, 0x97, 0xCD, 0x04, 0x24, 0x85, 0x48, 0x04, 0x84, 0x80, 0x02, 0x01,
-	0x03, 0xDA, 0x80, 0x23, 0x82, 0x01, 0x34, 0x85, 0x02, 0x23, 0xA0, 0x01,
-	0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x40, 0x05, 0x1D, 0x01, 0x04, 0xD6,
-	0xFF, 0x23, 0x86, 0x41, 0x4B, 0x60, 0xCB, 0x00, 0xFF, 0x23, 0x80, 0x01,
-	0x49, 0x00, 0x81, 0x01, 0x04, 0x01, 0x02, 0xC8, 0x30, 0x01, 0x80, 0x01,
-	0xF7, 0x04, 0x03, 0x01, 0x49, 0x04, 0x80, 0x01, 0xC9, 0x00, 0x00, 0x05,
-	0x00, 0x01, 0xFF, 0xA0, 0x60, 0x05, 0x77, 0x04, 0x01, 0x23, 0xEA, 0x00,
-	0x5D, 0x00, 0xFE, 0xC7, 0x00, 0x62, 0x00, 0x23, 0xEA, 0x00, 0x00, 0x63,
-	0x07, 0xA4, 0xF8, 0x05, 0x03, 0x03, 0x02, 0xA0, 0x8E, 0x05, 0xF4, 0x85,
-	0x00, 0x33, 0x2D, 0x00, 0xC2, 0x88, 0x04, 0xA0, 0xB8, 0x05, 0x80, 0x63,
-	0x00, 0x23, 0xDF, 0x00, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0xA4, 0x05,
-	0x1D, 0x01, 0x06, 0xD6, 0x02, 0x23, 0x02, 0x41, 0x82, 0x01, 0x50, 0x00,
-	0x62, 0x97, 0x04, 0x85, 0x04, 0x23, 0x02, 0x41, 0x82, 0x01, 0x04, 0x85,
-	0x08, 0xA0, 0xBE, 0x05, 0xF4, 0x85, 0x03, 0xA0, 0xC4, 0x05, 0xF4, 0x85,
-	0x01, 0xA0, 0xCE, 0x05, 0x88, 0x00, 0x80, 0x63, 0xCC, 0x86, 0x07, 0xA0,
-	0xEE, 0x05, 0x5F, 0x00, 0x00, 0x2B, 0xDF, 0x08, 0x00, 0xA2, 0xE6, 0x05,
-	0x80, 0x67, 0x80, 0x63, 0x01, 0xA2, 0x7A, 0x06, 0x7C, 0x85, 0x06, 0x23,
-	0x68, 0x98, 0x48, 0x23, 0xF8, 0x88, 0x07, 0x23, 0x80, 0x00, 0x06, 0x87,
-	0x80, 0x63, 0x7C, 0x85, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63, 0x4A, 0x00,
-	0x06, 0x61, 0x00, 0xA2, 0x36, 0x06, 0x1D, 0x01, 0x16, 0xD4, 0xC0, 0x23,
-	0x07, 0x41, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x1C, 0x06, 0x00, 0x33,
-	0x37, 0x00, 0xC2, 0x88, 0x1D, 0x01, 0x01, 0xD6, 0x20, 0x23, 0x63, 0x60,
-	0x83, 0x03, 0x80, 0x63, 0x02, 0x23, 0xDF, 0x00, 0x07, 0xA6, 0x7C, 0x05,
-	0xEF, 0x04, 0x6F, 0x00, 0x00, 0x63, 0x4B, 0x00, 0x06, 0x41, 0xCB, 0x00,
-	0x52, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x4E, 0x06, 0x1D, 0x01, 0x03, 0xCA,
-	0xC0, 0x23, 0x07, 0x41, 0x00, 0x63, 0x1D, 0x01, 0x04, 0xCC, 0x00, 0x33,
-	0x00, 0x83, 0xC0, 0x20, 0x81, 0x62, 0x80, 0x23, 0x07, 0x41, 0x00, 0x63,
-	0x80, 0x67, 0x08, 0x23, 0x83, 0x03, 0x80, 0x63, 0x00, 0x63, 0x01, 0x23,
-	0xDF, 0x00, 0x06, 0xA6, 0x84, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67,
-	0x80, 0x63, 0x00, 0x33, 0x00, 0x40, 0xC0, 0x20, 0x81, 0x62, 0x00, 0x63,
-	0x00, 0x00, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x94, 0x06,
-	0x07, 0xA6, 0x7C, 0x05, 0x00, 0x00, 0x01, 0xA0, 0x14, 0x07, 0x00, 0x2B,
-	0x40, 0x0E, 0x80, 0x63, 0x01, 0x00, 0x06, 0xA6, 0xAA, 0x06, 0x07, 0xA6,
-	0x7C, 0x05, 0x40, 0x0E, 0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0xA2, 0x06,
-	0x06, 0xA6, 0xBC, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67, 0x40, 0x0E,
-	0x80, 0x63, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63,
-	0x07, 0xA6, 0xD6, 0x06, 0x00, 0x33, 0x2A, 0x00, 0xC2, 0x88, 0x03, 0x03,
-	0x80, 0x63, 0x89, 0x00, 0x0A, 0x2B, 0x07, 0xA6, 0xE8, 0x06, 0x00, 0x33,
-	0x29, 0x00, 0xC2, 0x88, 0x00, 0x43, 0x00, 0xA2, 0xF4, 0x06, 0xC0, 0x0E,
-	0x80, 0x63, 0xDE, 0x86, 0xC0, 0x0E, 0x00, 0x33, 0x00, 0x80, 0xC0, 0x20,
-	0x81, 0x62, 0x04, 0x01, 0x02, 0xDA, 0x80, 0x63, 0x7C, 0x85, 0x80, 0x7B,
-	0x80, 0x63, 0x06, 0xA6, 0x8C, 0x06, 0x00, 0x33, 0x2C, 0x00, 0xC2, 0x88,
-	0x0C, 0xA2, 0x2E, 0x07, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6,
-	0x2C, 0x07, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x33, 0x3D, 0x00, 0xC2, 0x88,
-	0x00, 0x00, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0x0C, 0xA0, 0x44, 0x07,
-	0x07, 0xA6, 0x7C, 0x05, 0xBF, 0x23, 0x04, 0x61, 0x84, 0x01, 0xE6, 0x84,
-	0x00, 0x63, 0xF0, 0x04, 0x01, 0x01, 0xF1, 0x00, 0x00, 0x01, 0xF2, 0x00,
-	0x01, 0x05, 0x80, 0x01, 0x72, 0x04, 0x71, 0x00, 0x81, 0x01, 0x70, 0x04,
-	0x80, 0x05, 0x81, 0x05, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04,
-	0x01, 0x01, 0xF1, 0x00, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04, 0x71, 0x00,
-	0x81, 0x01, 0x72, 0x00, 0x80, 0x01, 0x71, 0x04, 0x70, 0x00, 0x80, 0x01,
-	0x70, 0x04, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x00, 0x01,
-	0xF1, 0x00, 0x70, 0x00, 0x80, 0x01, 0x70, 0x04, 0x71, 0x00, 0x80, 0x01,
-	0x72, 0x00, 0x81, 0x01, 0x71, 0x04, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04,
-	0x00, 0x63, 0x00, 0x23, 0xB3, 0x01, 0x83, 0x05, 0xA3, 0x01, 0xA2, 0x01,
-	0xA1, 0x01, 0x01, 0x23, 0xA0, 0x01, 0x00, 0x01, 0xC8, 0x00, 0x03, 0xA1,
-	0xC4, 0x07, 0x00, 0x33, 0x07, 0x00, 0xC2, 0x88, 0x80, 0x05, 0x81, 0x05,
-	0x04, 0x01, 0x11, 0xC8, 0x48, 0x00, 0xB0, 0x01, 0xB1, 0x01, 0x08, 0x23,
-	0xB2, 0x01, 0x05, 0x01, 0x48, 0x04, 0x00, 0x43, 0x00, 0xA2, 0xE4, 0x07,
-	0x00, 0x05, 0xDA, 0x87, 0x00, 0x01, 0xC8, 0x00, 0xFF, 0x23, 0x80, 0x01,
-	0x05, 0x05, 0x00, 0x63, 0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04,
-	0x00, 0x02, 0x80, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04, 0x00, 0x63,
-	0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04, 0x00, 0x02, 0x00, 0xA0,
-	0x14, 0x08, 0x16, 0x88, 0x00, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04,
-	0x00, 0x63, 0xF3, 0x04, 0x00, 0x23, 0xF4, 0x00, 0x74, 0x00, 0x80, 0x43,
-	0xF4, 0x00, 0xCF, 0x40, 0x00, 0xA2, 0x44, 0x08, 0x74, 0x04, 0x02, 0x01,
-	0xF7, 0xC9, 0xF6, 0xD9, 0x00, 0x01, 0x01, 0xA1, 0x24, 0x08, 0x04, 0x98,
-	0x26, 0x95, 0x24, 0x88, 0x73, 0x04, 0x00, 0x63, 0xF3, 0x04, 0x75, 0x04,
-	0x5A, 0x88, 0x02, 0x01, 0x04, 0xD8, 0x46, 0x97, 0x04, 0x98, 0x26, 0x95,
-	0x4A, 0x88, 0x75, 0x00, 0x00, 0xA3, 0x64, 0x08, 0x00, 0x05, 0x4E, 0x88,
-	0x73, 0x04, 0x00, 0x63, 0x80, 0x7B, 0x80, 0x63, 0x06, 0xA6, 0x76, 0x08,
-	0x00, 0x33, 0x3E, 0x00, 0xC2, 0x88, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63,
-	0x00, 0x63, 0x38, 0x2B, 0x9C, 0x88, 0x38, 0x2B, 0x92, 0x88, 0x32, 0x09,
-	0x31, 0x05, 0x92, 0x98, 0x05, 0x05, 0xB2, 0x09, 0x00, 0x63, 0x00, 0x32,
-	0x00, 0x36, 0x00, 0x3A, 0x00, 0x3E, 0x00, 0x63, 0x80, 0x32, 0x80, 0x36,
-	0x80, 0x3A, 0x80, 0x3E, 0xB4, 0x3D, 0x00, 0x63, 0x38, 0x2B, 0x40, 0x32,
-	0x40, 0x36, 0x40, 0x3A, 0x40, 0x3E, 0x00, 0x63, 0x5A, 0x20, 0xC9, 0x40,
-	0x00, 0xA0, 0xB4, 0x08, 0x5D, 0x00, 0xFE, 0xC3, 0x00, 0x63, 0x80, 0x73,
-	0xE6, 0x20, 0x02, 0x23, 0xE8, 0x00, 0x82, 0x73, 0xFF, 0xFD, 0x80, 0x73,
-	0x13, 0x23, 0xF8, 0x88, 0x66, 0x20, 0xC0, 0x20, 0x04, 0x23, 0xA0, 0x01,
-	0xA1, 0x23, 0xA1, 0x01, 0x81, 0x62, 0xE2, 0x88, 0x80, 0x73, 0x80, 0x77,
-	0x68, 0x00, 0x00, 0xA2, 0x80, 0x00, 0x03, 0xC2, 0xF1, 0xC7, 0x41, 0x23,
-	0xF8, 0x88, 0x11, 0x23, 0xA1, 0x01, 0x04, 0x23, 0xA0, 0x01, 0xE6, 0x84,
-};
-
-static unsigned short _asc_mcode_size = sizeof(_asc_mcode_buf);
-static ADV_DCNT _asc_mcode_chksum = 0x012C453FUL;
-
-/* Microcode buffer is kept after initialization for error recovery. */
-static unsigned char _adv_asc3550_buf[] = {
-	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0x16, 0x18, 0xe4, 0x00, 0xfc,
-	0x01, 0x00, 0x48, 0xe4, 0xbe, 0x18, 0x18, 0x80, 0x03, 0xf6, 0x02, 0x00,
-	0x00, 0xfa, 0xff, 0xff, 0x28, 0x0e, 0x9e, 0xe7, 0xff, 0x00, 0x82, 0xe7,
-	0x00, 0xea, 0x00, 0xf6, 0x01, 0xe6, 0x09, 0xe7, 0x55, 0xf0, 0x01, 0xf6,
-	0x01, 0xfa, 0x08, 0x00, 0x03, 0x00, 0x04, 0x00, 0x18, 0xf4, 0x10, 0x00,
-	0x00, 0xec, 0x85, 0xf0, 0xbc, 0x00, 0xd5, 0xf0, 0x8e, 0x0c, 0x38, 0x54,
-	0x00, 0xe6, 0x1e, 0xf0, 0x86, 0xf0, 0xb4, 0x00, 0x98, 0x57, 0xd0, 0x01,
-	0x0c, 0x1c, 0x3e, 0x1c, 0x0c, 0x00, 0xbb, 0x00, 0xaa, 0x18, 0x02, 0x80,
-	0x32, 0xf0, 0x01, 0xfc, 0x88, 0x0c, 0xc6, 0x12, 0x02, 0x13, 0x18, 0x40,
-	0x00, 0x57, 0x01, 0xea, 0x3c, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12,
-	0x3e, 0x57, 0x00, 0x80, 0x03, 0xe6, 0xb6, 0x00, 0xc0, 0x00, 0x01, 0x01,
-	0x3e, 0x01, 0xda, 0x0f, 0x22, 0x10, 0x08, 0x12, 0x02, 0x4a, 0xb9, 0x54,
-	0x03, 0x58, 0x1b, 0x80, 0x30, 0xe4, 0x4b, 0xe4, 0x20, 0x00, 0x32, 0x00,
-	0x3e, 0x00, 0x80, 0x00, 0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01,
-	0x70, 0x01, 0x72, 0x01, 0x74, 0x01, 0x76, 0x01, 0x78, 0x01, 0x62, 0x0a,
-	0x92, 0x0c, 0x2c, 0x10, 0x2e, 0x10, 0x06, 0x13, 0x4c, 0x1c, 0xbb, 0x55,
-	0x3c, 0x56, 0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0, 0xb1, 0xf0,
-	0x03, 0xf7, 0x06, 0xf7, 0x03, 0xfc, 0x0f, 0x00, 0x40, 0x00, 0xbe, 0x00,
-	0x00, 0x01, 0xb0, 0x08, 0x30, 0x13, 0x64, 0x15, 0x32, 0x1c, 0x38, 0x1c,
-	0x4e, 0x1c, 0x10, 0x44, 0x02, 0x48, 0x00, 0x4c, 0x04, 0xea, 0x5d, 0xf0,
-	0x04, 0xf6, 0x02, 0xfc, 0x05, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00,
-	0xcc, 0x00, 0x20, 0x01, 0x4e, 0x01, 0x4e, 0x0b, 0x1e, 0x0e, 0x0c, 0x10,
-	0x0a, 0x12, 0x04, 0x13, 0x40, 0x13, 0x30, 0x1c, 0x00, 0x4e, 0xbd, 0x56,
-	0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0, 0x59, 0xf0, 0xa7, 0xf0,
-	0xb8, 0xf0, 0x0e, 0xf7, 0x06, 0x00, 0x19, 0x00, 0x33, 0x00, 0x9b, 0x00,
-	0xa4, 0x00, 0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00, 0xe7, 0x00,
-	0xde, 0x03, 0x56, 0x0a, 0x14, 0x0e, 0x02, 0x10, 0x04, 0x10, 0x0a, 0x10,
-	0x36, 0x10, 0x0a, 0x13, 0x12, 0x13, 0x52, 0x13, 0x10, 0x15, 0x14, 0x15,
-	0xac, 0x16, 0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c, 0x08, 0x44, 0x38, 0x44,
-	0x91, 0x44, 0x0a, 0x45, 0x48, 0x46, 0x01, 0x48, 0x68, 0x54, 0x83, 0x55,
-	0xb0, 0x57, 0x01, 0x58, 0x83, 0x59, 0x05, 0xe6, 0x0b, 0xf0, 0x0c, 0xf0,
-	0x5c, 0xf0, 0x4b, 0xf4, 0x04, 0xf8, 0x05, 0xf8, 0x02, 0xfa, 0x03, 0xfa,
-	0x04, 0xfc, 0x05, 0xfc, 0x07, 0x00, 0x0a, 0x00, 0x0d, 0x00, 0x1c, 0x00,
-	0x9e, 0x00, 0xa8, 0x00, 0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00, 0x22, 0x01,
-	0x26, 0x01, 0x79, 0x01, 0x7a, 0x01, 0xc0, 0x01, 0xc2, 0x01, 0x7c, 0x02,
-	0x5a, 0x03, 0xea, 0x04, 0xe8, 0x07, 0x68, 0x08, 0x69, 0x08, 0xba, 0x08,
-	0xe9, 0x09, 0x06, 0x0b, 0x3a, 0x0e, 0x00, 0x10, 0x1a, 0x10, 0xed, 0x10,
-	0xf1, 0x10, 0x06, 0x12, 0x0c, 0x13, 0x16, 0x13, 0x1e, 0x13, 0x82, 0x13,
-	0x42, 0x14, 0xd6, 0x14, 0x8a, 0x15, 0xc6, 0x17, 0xd2, 0x17, 0x6b, 0x18,
-	0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40, 0x0e, 0x47, 0x48, 0x47,
-	0x41, 0x48, 0x89, 0x48, 0x80, 0x4c, 0x00, 0x54, 0x44, 0x55, 0xe5, 0x55,
-	0x14, 0x56, 0x77, 0x57, 0xbf, 0x57, 0x40, 0x5c, 0x06, 0x80, 0x08, 0x90,
-	0x03, 0xa1, 0xfe, 0x9c, 0xf0, 0x29, 0x02, 0xfe, 0xb8, 0x0c, 0xff, 0x10,
-	0x00, 0x00, 0xd0, 0xfe, 0xcc, 0x18, 0x00, 0xcf, 0xfe, 0x80, 0x01, 0xff,
-	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
-	0x00, 0xfe, 0x57, 0x24, 0x00, 0xfe, 0x48, 0x00, 0x4f, 0xff, 0x04, 0x00,
-	0x00, 0x10, 0xff, 0x09, 0x00, 0x00, 0xff, 0x08, 0x01, 0x01, 0xff, 0x08,
-	0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10, 0xff, 0xff, 0xff, 0x0f,
-	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
-	0xfe, 0x04, 0xf7, 0xcf, 0x2a, 0x67, 0x0b, 0x01, 0xfe, 0xce, 0x0e, 0xfe,
-	0x04, 0xf7, 0xcf, 0x67, 0x0b, 0x3c, 0x2a, 0xfe, 0x3d, 0xf0, 0xfe, 0x02,
-	0x02, 0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x91, 0xf0, 0xfe, 0xf0, 0x01, 0xfe,
-	0x90, 0xf0, 0xfe, 0xf0, 0x01, 0xfe, 0x8f, 0xf0, 0x9c, 0x05, 0x51, 0x3b,
-	0x02, 0xfe, 0xd4, 0x0c, 0x01, 0xfe, 0x44, 0x0d, 0xfe, 0xdd, 0x12, 0xfe,
-	0xfc, 0x10, 0xfe, 0x28, 0x1c, 0x05, 0xfe, 0xa6, 0x00, 0xfe, 0xd3, 0x12,
-	0x47, 0x18, 0xfe, 0xa6, 0x00, 0xb5, 0xfe, 0x48, 0xf0, 0xfe, 0x86, 0x02,
-	0xfe, 0x49, 0xf0, 0xfe, 0xa0, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xbe, 0x02,
-	0xfe, 0x46, 0xf0, 0xfe, 0x50, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x56, 0x02,
-	0xfe, 0x43, 0xf0, 0xfe, 0x44, 0x02, 0xfe, 0x44, 0xf0, 0xfe, 0x48, 0x02,
-	0xfe, 0x45, 0xf0, 0xfe, 0x4c, 0x02, 0x17, 0x0b, 0xa0, 0x17, 0x06, 0x18,
-	0x96, 0x02, 0x29, 0xfe, 0x00, 0x1c, 0xde, 0xfe, 0x02, 0x1c, 0xdd, 0xfe,
-	0x1e, 0x1c, 0xfe, 0xe9, 0x10, 0x01, 0xfe, 0x20, 0x17, 0xfe, 0xe7, 0x10,
-	0xfe, 0x06, 0xfc, 0xc7, 0x0a, 0x6b, 0x01, 0x9e, 0x02, 0x29, 0x14, 0x4d,
-	0x37, 0x97, 0x01, 0xfe, 0x64, 0x0f, 0x0a, 0x6b, 0x01, 0x82, 0xfe, 0xbd,
-	0x10, 0x0a, 0x6b, 0x01, 0x82, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c, 0xfe,
-	0x58, 0x1c, 0x17, 0x06, 0x18, 0x96, 0x2a, 0x25, 0x29, 0xfe, 0x3d, 0xf0,
-	0xfe, 0x02, 0x02, 0x21, 0xfe, 0x94, 0x02, 0xfe, 0x5a, 0x1c, 0xea, 0xfe,
-	0x14, 0x1c, 0x14, 0xfe, 0x30, 0x00, 0x37, 0x97, 0x01, 0xfe, 0x54, 0x0f,
-	0x17, 0x06, 0x18, 0x96, 0x02, 0xd0, 0x1e, 0x20, 0x07, 0x10, 0x34, 0xfe,
-	0x69, 0x10, 0x17, 0x06, 0x18, 0x96, 0xfe, 0x04, 0xec, 0x20, 0x46, 0x3d,
-	0x12, 0x20, 0xfe, 0x05, 0xf6, 0xc7, 0x01, 0xfe, 0x52, 0x16, 0x09, 0x4a,
-	0x4c, 0x35, 0x11, 0x2d, 0x3c, 0x8a, 0x01, 0xe6, 0x02, 0x29, 0x0a, 0x40,
-	0x01, 0x0e, 0x07, 0x00, 0x5d, 0x01, 0x6f, 0xfe, 0x18, 0x10, 0xfe, 0x41,
-	0x58, 0x0a, 0x99, 0x01, 0x0e, 0xfe, 0xc8, 0x54, 0x64, 0xfe, 0x0c, 0x03,
-	0x01, 0xe6, 0x02, 0x29, 0x2a, 0x46, 0xfe, 0x02, 0xe8, 0x27, 0xf8, 0xfe,
-	0x9e, 0x43, 0xf7, 0xfe, 0x27, 0xf0, 0xfe, 0xdc, 0x01, 0xfe, 0x07, 0x4b,
-	0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x40, 0x1c, 0x25, 0xd2, 0xfe, 0x26, 0xf0,
-	0xfe, 0x56, 0x03, 0xfe, 0xa0, 0xf0, 0xfe, 0x44, 0x03, 0xfe, 0x11, 0xf0,
-	0x9c, 0xfe, 0xef, 0x10, 0xfe, 0x9f, 0xf0, 0xfe, 0x64, 0x03, 0xeb, 0x0f,
-	0xfe, 0x11, 0x00, 0x02, 0x5a, 0x2a, 0xfe, 0x48, 0x1c, 0xeb, 0x09, 0x04,
-	0x1d, 0xfe, 0x18, 0x13, 0x23, 0x1e, 0x98, 0xac, 0x12, 0x98, 0x0a, 0x40,
-	0x01, 0x0e, 0xac, 0x75, 0x01, 0xfe, 0xbc, 0x15, 0x11, 0xca, 0x25, 0xd2,
-	0xfe, 0x01, 0xf0, 0xd2, 0xfe, 0x82, 0xf0, 0xfe, 0x92, 0x03, 0xec, 0x11,
-	0xfe, 0xe4, 0x00, 0x65, 0xfe, 0xa4, 0x03, 0x25, 0x32, 0x1f, 0xfe, 0xb4,
-	0x03, 0x01, 0x43, 0xfe, 0x06, 0xf0, 0xfe, 0xc4, 0x03, 0x8d, 0x81, 0xfe,
-	0x0a, 0xf0, 0xfe, 0x7a, 0x06, 0x02, 0x22, 0x05, 0x6b, 0x28, 0x16, 0xfe,
-	0xf6, 0x04, 0x14, 0x2c, 0x01, 0x33, 0x8f, 0xfe, 0x66, 0x02, 0x02, 0xd1,
-	0xeb, 0x2a, 0x67, 0x1a, 0xfe, 0x67, 0x1b, 0xf8, 0xf7, 0xfe, 0x48, 0x1c,
-	0x70, 0x01, 0x6e, 0x87, 0x0a, 0x40, 0x01, 0x0e, 0x07, 0x00, 0x16, 0xd3,
-	0x0a, 0xca, 0x01, 0x0e, 0x74, 0x60, 0x59, 0x76, 0x27, 0x05, 0x6b, 0x28,
-	0xfe, 0x10, 0x12, 0x14, 0x2c, 0x01, 0x33, 0x8f, 0xfe, 0x66, 0x02, 0x02,
-	0xd1, 0xbc, 0x7d, 0xbd, 0x7f, 0x25, 0x22, 0x65, 0xfe, 0x3c, 0x04, 0x1f,
-	0xfe, 0x38, 0x04, 0x68, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e,
-	0x12, 0x2b, 0xff, 0x02, 0x00, 0x10, 0x01, 0x08, 0x1f, 0xfe, 0xe0, 0x04,
-	0x2b, 0x01, 0x08, 0x1f, 0x22, 0x30, 0x2e, 0xd5, 0xfe, 0x4c, 0x44, 0xfe,
-	0x4c, 0x12, 0x60, 0xfe, 0x44, 0x48, 0x13, 0x2c, 0xfe, 0x4c, 0x54, 0x64,
-	0xd3, 0x46, 0x76, 0x27, 0xfa, 0xef, 0xfe, 0x62, 0x13, 0x09, 0x04, 0x1d,
-	0xfe, 0x2a, 0x13, 0x2f, 0x07, 0x7e, 0xa5, 0xfe, 0x20, 0x10, 0x13, 0x2c,
-	0xfe, 0x4c, 0x54, 0x64, 0xd3, 0xfa, 0xef, 0x86, 0x09, 0x04, 0x1d, 0xfe,
-	0x08, 0x13, 0x2f, 0x07, 0x7e, 0x6e, 0x09, 0x04, 0x1d, 0xfe, 0x1c, 0x12,
-	0x14, 0x92, 0x09, 0x04, 0x06, 0x3b, 0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe,
-	0x70, 0x0c, 0x02, 0x22, 0x2b, 0x11, 0xfe, 0xe6, 0x00, 0xfe, 0x1c, 0x90,
-	0xf9, 0x03, 0x14, 0x92, 0x01, 0x33, 0x02, 0x29, 0xfe, 0x42, 0x5b, 0x67,
-	0x1a, 0xfe, 0x46, 0x59, 0xf8, 0xf7, 0xfe, 0x87, 0x80, 0xfe, 0x31, 0xe4,
-	0x4f, 0x09, 0x04, 0x0b, 0xfe, 0x78, 0x13, 0xfe, 0x20, 0x80, 0x07, 0x1a,
-	0xfe, 0x70, 0x12, 0x49, 0x04, 0x06, 0xfe, 0x60, 0x13, 0x05, 0xfe, 0xa2,
-	0x00, 0x28, 0x16, 0xfe, 0x80, 0x05, 0xfe, 0x31, 0xe4, 0x6a, 0x49, 0x04,
-	0x0b, 0xfe, 0x4a, 0x13, 0x05, 0xfe, 0xa0, 0x00, 0x28, 0xfe, 0x42, 0x12,
-	0x5e, 0x01, 0x08, 0x25, 0x32, 0xf1, 0x01, 0x08, 0x26, 0xfe, 0x98, 0x05,
-	0x11, 0xfe, 0xe3, 0x00, 0x23, 0x49, 0xfe, 0x4a, 0xf0, 0xfe, 0x6a, 0x05,
-	0xfe, 0x49, 0xf0, 0xfe, 0x64, 0x05, 0x83, 0x24, 0xfe, 0x21, 0x00, 0xa1,
-	0x24, 0xfe, 0x22, 0x00, 0xa0, 0x24, 0x4c, 0xfe, 0x09, 0x48, 0x01, 0x08,
-	0x26, 0xfe, 0x98, 0x05, 0xfe, 0xe2, 0x08, 0x49, 0x04, 0xc5, 0x3b, 0x01,
-	0x86, 0x24, 0x06, 0x12, 0xcc, 0x37, 0xfe, 0x27, 0x01, 0x09, 0x04, 0x1d,
-	0xfe, 0x22, 0x12, 0x47, 0x01, 0xa7, 0x14, 0x92, 0x09, 0x04, 0x06, 0x3b,
-	0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe, 0x70, 0x0c, 0x02, 0x22, 0x05, 0xfe,
-	0x9c, 0x00, 0x28, 0xfe, 0x3e, 0x12, 0x05, 0x50, 0x28, 0xfe, 0x36, 0x13,
-	0x47, 0x01, 0xa7, 0x26, 0xfe, 0x08, 0x06, 0x0a, 0x06, 0x49, 0x04, 0x19,
-	0xfe, 0x02, 0x12, 0x5f, 0x01, 0xfe, 0xaa, 0x14, 0x1f, 0xfe, 0xfe, 0x05,
-	0x11, 0x9a, 0x01, 0x43, 0x11, 0xfe, 0xe5, 0x00, 0x05, 0x50, 0xb4, 0x0c,
-	0x50, 0x05, 0xc6, 0x28, 0xfe, 0x62, 0x12, 0x05, 0x3f, 0x28, 0xfe, 0x5a,
-	0x13, 0x01, 0xfe, 0x14, 0x18, 0x01, 0xfe, 0x66, 0x18, 0xfe, 0x43, 0x48,
-	0xb7, 0x19, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0x1c, 0x3d,
-	0x85, 0xb7, 0x69, 0x47, 0x01, 0xa7, 0x26, 0xfe, 0x72, 0x06, 0x49, 0x04,
-	0x1b, 0xdf, 0x89, 0x0a, 0x4d, 0x01, 0xfe, 0xd8, 0x14, 0x1f, 0xfe, 0x68,
-	0x06, 0x11, 0x9a, 0x01, 0x43, 0x11, 0xfe, 0xe5, 0x00, 0x05, 0x3f, 0xb4,
-	0x0c, 0x3f, 0x17, 0x06, 0x01, 0xa7, 0xec, 0x72, 0x70, 0x01, 0x6e, 0x87,
-	0x11, 0xfe, 0xe2, 0x00, 0x01, 0x08, 0x25, 0x32, 0xfe, 0x0a, 0xf0, 0xfe,
-	0xa6, 0x06, 0x8c, 0xfe, 0x5c, 0x07, 0xfe, 0x06, 0xf0, 0xfe, 0x64, 0x07,
-	0x8d, 0x81, 0x02, 0x22, 0x09, 0x04, 0x0b, 0xfe, 0x2e, 0x12, 0x15, 0x1a,
-	0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00,
-	0x01, 0x08, 0xfe, 0x99, 0xa4, 0x01, 0x08, 0x15, 0x00, 0x02, 0xfe, 0x32,
-	0x08, 0x61, 0x04, 0x1b, 0xfe, 0x38, 0x12, 0x09, 0x04, 0x1b, 0x6e, 0x15,
-	0xfe, 0x1b, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01,
-	0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x06, 0x01, 0x08, 0x15, 0x00, 0x02,
-	0xd9, 0x66, 0x4c, 0xfe, 0x3a, 0x55, 0x5f, 0xfe, 0x9a, 0x81, 0x4b, 0x1d,
-	0xba, 0xfe, 0x32, 0x07, 0x0a, 0x1d, 0xfe, 0x09, 0x6f, 0xaf, 0xfe, 0xca,
-	0x45, 0xfe, 0x32, 0x12, 0x62, 0x2c, 0x85, 0x66, 0x7b, 0x01, 0x08, 0x25,
-	0x32, 0xfe, 0x0a, 0xf0, 0xfe, 0x32, 0x07, 0x8d, 0x81, 0x8c, 0xfe, 0x5c,
-	0x07, 0x02, 0x22, 0x01, 0x43, 0x02, 0xfe, 0x8a, 0x06, 0x15, 0x19, 0x02,
-	0xfe, 0x8a, 0x06, 0xfe, 0x9c, 0xf7, 0xd4, 0xfe, 0x2c, 0x90, 0xfe, 0xae,
-	0x90, 0x77, 0xfe, 0xca, 0x07, 0x0c, 0x54, 0x18, 0x55, 0x09, 0x4a, 0x6a,
-	0x35, 0x1e, 0x20, 0x07, 0x10, 0xfe, 0x0e, 0x12, 0x74, 0xfe, 0x80, 0x80,
-	0x37, 0x20, 0x63, 0x27, 0xfe, 0x06, 0x10, 0xfe, 0x83, 0xe7, 0xc4, 0xa1,
-	0xfe, 0x03, 0x40, 0x09, 0x4a, 0x4f, 0x35, 0x01, 0xa8, 0xad, 0xfe, 0x1f,
-	0x40, 0x12, 0x58, 0x01, 0xa5, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe,
-	0x44, 0x51, 0xfe, 0xc6, 0x51, 0x83, 0xfb, 0xfe, 0x8a, 0x90, 0x0c, 0x52,
-	0x18, 0x53, 0xfe, 0x0c, 0x90, 0xfe, 0x8e, 0x90, 0xfe, 0x40, 0x50, 0xfe,
-	0xc2, 0x50, 0x0c, 0x39, 0x18, 0x3a, 0xfe, 0x4a, 0x10, 0x09, 0x04, 0x6a,
-	0xfe, 0x2a, 0x12, 0xfe, 0x2c, 0x90, 0xfe, 0xae, 0x90, 0x0c, 0x54, 0x18,
-	0x55, 0x09, 0x04, 0x4f, 0x85, 0x01, 0xa8, 0xfe, 0x1f, 0x80, 0x12, 0x58,
-	0xfe, 0x44, 0x90, 0xfe, 0xc6, 0x90, 0x0c, 0x56, 0x18, 0x57, 0xfb, 0xfe,
-	0x8a, 0x90, 0x0c, 0x52, 0x18, 0x53, 0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90,
-	0x0c, 0x39, 0x18, 0x3a, 0x0c, 0x38, 0x18, 0x4e, 0x09, 0x4a, 0x19, 0x35,
-	0x2a, 0x13, 0xfe, 0x4e, 0x11, 0x65, 0xfe, 0x48, 0x08, 0xfe, 0x9e, 0xf0,
-	0xfe, 0x5c, 0x08, 0xb1, 0x16, 0x32, 0x2a, 0x73, 0xdd, 0xb8, 0xfe, 0x80,
-	0x08, 0xb9, 0xfe, 0x9e, 0x08, 0x8c, 0xfe, 0x74, 0x08, 0xfe, 0x06, 0xf0,
-	0xfe, 0x7a, 0x08, 0x8d, 0x81, 0x02, 0x22, 0x01, 0x43, 0xfe, 0xc9, 0x10,
-	0x15, 0x19, 0xfe, 0xc9, 0x10, 0x61, 0x04, 0x06, 0xfe, 0x10, 0x12, 0x61,
-	0x04, 0x0b, 0x45, 0x09, 0x04, 0x0b, 0xfe, 0x68, 0x12, 0xfe, 0x2e, 0x1c,
-	0x02, 0xfe, 0x24, 0x0a, 0x61, 0x04, 0x06, 0x45, 0x61, 0x04, 0x0b, 0xfe,
-	0x52, 0x12, 0xfe, 0x2c, 0x1c, 0xfe, 0xaa, 0xf0, 0xfe, 0x1e, 0x09, 0xfe,
-	0xac, 0xf0, 0xfe, 0xbe, 0x08, 0xfe, 0x8a, 0x10, 0xaa, 0xfe, 0xf3, 0x10,
-	0xfe, 0xad, 0xf0, 0xfe, 0xca, 0x08, 0x02, 0xfe, 0x24, 0x0a, 0xab, 0xfe,
-	0xe7, 0x10, 0xfe, 0x2b, 0xf0, 0x9d, 0xe9, 0x1c, 0xfe, 0x00, 0xfe, 0xfe,
-	0x1c, 0x12, 0xb5, 0xfe, 0xd2, 0xf0, 0x9d, 0xfe, 0x76, 0x18, 0x1c, 0x1a,
-	0x16, 0x9d, 0x05, 0xcb, 0x1c, 0x06, 0x16, 0x9d, 0xb8, 0x6d, 0xb9, 0x6d,
-	0xaa, 0xab, 0xfe, 0xb1, 0x10, 0x70, 0x5e, 0x2b, 0x14, 0x92, 0x01, 0x33,
-	0x0f, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x5a, 0x0f, 0x7c, 0x02, 0x5a,
-	0xfe, 0x74, 0x18, 0x1c, 0xfe, 0x00, 0xf8, 0x16, 0x6d, 0x67, 0x1b, 0x01,
-	0xfe, 0x44, 0x0d, 0x3b, 0x01, 0xe6, 0x1e, 0x27, 0x74, 0x67, 0x1a, 0x02,
-	0x6d, 0x09, 0x04, 0x0b, 0x21, 0xfe, 0x06, 0x0a, 0x09, 0x04, 0x6a, 0xfe,
-	0x82, 0x12, 0x09, 0x04, 0x19, 0xfe, 0x66, 0x13, 0x1e, 0x58, 0xac, 0xfc,
-	0xfe, 0x83, 0x80, 0xfe, 0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91,
-	0xfe, 0x86, 0x91, 0x63, 0x27, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x77,
-	0xd7, 0x05, 0x54, 0x31, 0x55, 0x0c, 0x7b, 0x18, 0x7c, 0xbe, 0x54, 0xbf,
-	0x55, 0x01, 0xa8, 0xad, 0x63, 0x27, 0x12, 0x58, 0xc0, 0x38, 0xc1, 0x4e,
-	0x79, 0x56, 0x68, 0x57, 0xf4, 0xf5, 0xfe, 0x04, 0xfa, 0x38, 0xfe, 0x05,
-	0xfa, 0x4e, 0x01, 0xa5, 0xa2, 0x23, 0x0c, 0x7b, 0x0c, 0x7c, 0x79, 0x56,
-	0x68, 0x57, 0xfe, 0x12, 0x10, 0x09, 0x04, 0x19, 0x16, 0xd7, 0x79, 0x39,
-	0x68, 0x3a, 0x09, 0x04, 0xfe, 0xf7, 0x00, 0x35, 0x05, 0x52, 0x31, 0x53,
-	0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59,
-	0x02, 0x6d, 0x09, 0x04, 0x19, 0x16, 0xd7, 0x09, 0x04, 0xfe, 0xf7, 0x00,
-	0x35, 0xfe, 0x3a, 0x55, 0xfe, 0x19, 0x81, 0x5f, 0xfe, 0x10, 0x90, 0xfe,
-	0x92, 0x90, 0xfe, 0xd7, 0x10, 0x2f, 0x07, 0x9b, 0x16, 0xfe, 0xc6, 0x08,
-	0x11, 0x9b, 0x09, 0x04, 0x0b, 0xfe, 0x14, 0x13, 0x05, 0x39, 0x31, 0x3a,
-	0x77, 0xfe, 0xc6, 0x08, 0xfe, 0x0c, 0x58, 0xfe, 0x8d, 0x58, 0x02, 0x6d,
-	0x23, 0x47, 0xfe, 0x19, 0x80, 0xde, 0x09, 0x04, 0x0b, 0xfe, 0x1a, 0x12,
-	0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41, 0xe9, 0xb5, 0xfe, 0xd1, 0xf0, 0xd9,
-	0x14, 0x7a, 0x01, 0x33, 0x0f, 0xfe, 0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe,
-	0x6c, 0x19, 0xbe, 0x39, 0xfe, 0xed, 0x19, 0xbf, 0x3a, 0xfe, 0x0c, 0x51,
-	0xfe, 0x8e, 0x51, 0xe9, 0x1c, 0xfe, 0x00, 0xff, 0x34, 0xfe, 0x74, 0x10,
-	0xb5, 0xfe, 0xd2, 0xf0, 0xfe, 0xb2, 0x0a, 0xfe, 0x76, 0x18, 0x1c, 0x1a,
-	0x84, 0x05, 0xcb, 0x1c, 0x06, 0xfe, 0x08, 0x13, 0x0f, 0xfe, 0x16, 0x00,
-	0x02, 0x5a, 0xfe, 0xd1, 0xf0, 0xfe, 0xc4, 0x0a, 0x14, 0x7a, 0x01, 0x33,
-	0x0f, 0xfe, 0x17, 0x00, 0xfe, 0x42, 0x10, 0xfe, 0xce, 0xf0, 0xfe, 0xca,
-	0x0a, 0xfe, 0x3c, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xd6, 0x0a, 0x0f, 0xfe,
-	0x22, 0x00, 0x02, 0x5a, 0xfe, 0xcb, 0xf0, 0xfe, 0xe2, 0x0a, 0x0f, 0xfe,
-	0x24, 0x00, 0x02, 0x5a, 0xfe, 0xd0, 0xf0, 0xfe, 0xec, 0x0a, 0x0f, 0x93,
-	0xdc, 0xfe, 0xcf, 0xf0, 0xfe, 0xf6, 0x0a, 0x0f, 0x4c, 0xfe, 0x10, 0x10,
-	0xfe, 0xcc, 0xf0, 0xd9, 0x61, 0x04, 0x19, 0x3b, 0x0f, 0xfe, 0x12, 0x00,
-	0x2a, 0x13, 0xfe, 0x4e, 0x11, 0x65, 0xfe, 0x0c, 0x0b, 0xfe, 0x9e, 0xf0,
-	0xfe, 0x20, 0x0b, 0xb1, 0x16, 0x32, 0x2a, 0x73, 0xdd, 0xb8, 0x22, 0xb9,
-	0x22, 0x2a, 0xec, 0x65, 0xfe, 0x2c, 0x0b, 0x25, 0x32, 0x8c, 0xfe, 0x48,
-	0x0b, 0x8d, 0x81, 0xb8, 0xd4, 0xb9, 0xd4, 0x02, 0x22, 0x01, 0x43, 0xfe,
-	0xdb, 0x10, 0x11, 0xfe, 0xe8, 0x00, 0xaa, 0xab, 0x70, 0xbc, 0x7d, 0xbd,
-	0x7f, 0xfe, 0x89, 0xf0, 0x22, 0x30, 0x2e, 0xd8, 0xbc, 0x7d, 0xbd, 0x7f,
-	0x01, 0x08, 0x1f, 0x22, 0x30, 0x2e, 0xd6, 0xb1, 0x45, 0x0f, 0xfe, 0x42,
-	0x00, 0x02, 0x5a, 0x78, 0x06, 0xfe, 0x81, 0x49, 0x16, 0xfe, 0x38, 0x0c,
-	0x09, 0x04, 0x0b, 0xfe, 0x44, 0x13, 0x0f, 0x00, 0x4b, 0x0b, 0xfe, 0x54,
-	0x12, 0x4b, 0xfe, 0x28, 0x00, 0x21, 0xfe, 0xa6, 0x0c, 0x0a, 0x40, 0x01,
-	0x0e, 0x07, 0x00, 0x5d, 0x3e, 0xfe, 0x28, 0x00, 0xfe, 0xe2, 0x10, 0x01,
-	0xe7, 0x01, 0xe8, 0x0a, 0x99, 0x01, 0xfe, 0x32, 0x0e, 0x59, 0x11, 0x2d,
-	0x01, 0x6f, 0x02, 0x29, 0x0f, 0xfe, 0x44, 0x00, 0x4b, 0x0b, 0xdf, 0x3e,
-	0x0b, 0xfe, 0xb4, 0x10, 0x01, 0x86, 0x3e, 0x0b, 0xfe, 0xaa, 0x10, 0x01,
-	0x86, 0xfe, 0x19, 0x82, 0xfe, 0x34, 0x46, 0xa3, 0x3e, 0x0b, 0x0f, 0xfe,
-	0x43, 0x00, 0xfe, 0x96, 0x10, 0x09, 0x4a, 0x0b, 0x35, 0x01, 0xe7, 0x01,
-	0xe8, 0x59, 0x11, 0x2d, 0x01, 0x6f, 0x67, 0x0b, 0x59, 0x3c, 0x8a, 0x02,
-	0xfe, 0x2a, 0x03, 0x09, 0x04, 0x0b, 0x84, 0x3e, 0x0b, 0x0f, 0x00, 0xfe,
-	0x5c, 0x10, 0x61, 0x04, 0x1b, 0xfe, 0x58, 0x12, 0x09, 0x04, 0x1b, 0xfe,
-	0x50, 0x13, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x5c, 0x0c, 0xfe,
-	0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x62, 0x0c, 0x09, 0x4a, 0x1b, 0x35,
-	0xfe, 0xa9, 0x10, 0x0f, 0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0b, 0x5f,
-	0x5c, 0x0f, 0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x0f, 0xfe, 0x47, 0x00,
-	0xa1, 0x0f, 0xfe, 0x41, 0x00, 0xa0, 0x0f, 0xfe, 0x24, 0x00, 0x87, 0xaa,
-	0xab, 0x70, 0x05, 0x6b, 0x28, 0x21, 0xd1, 0x5f, 0xfe, 0x04, 0xe6, 0x1b,
-	0xfe, 0x9d, 0x41, 0xfe, 0x1c, 0x42, 0x59, 0x01, 0xda, 0x02, 0x29, 0xea,
-	0x14, 0x0b, 0x37, 0x95, 0xa9, 0x14, 0xfe, 0x31, 0x00, 0x37, 0x97, 0x01,
-	0xfe, 0x54, 0x0f, 0x02, 0xd0, 0x3c, 0xfe, 0x06, 0xec, 0xc9, 0xee, 0x3e,
-	0x1d, 0xfe, 0xce, 0x45, 0x34, 0x3c, 0xfe, 0x06, 0xea, 0xc9, 0xfe, 0x47,
-	0x4b, 0x89, 0xfe, 0x75, 0x57, 0x05, 0x51, 0xfe, 0x98, 0x56, 0xfe, 0x38,
-	0x12, 0x0a, 0x42, 0x01, 0x0e, 0xfe, 0x44, 0x48, 0x46, 0x09, 0x04, 0x1d,
-	0xfe, 0x1a, 0x13, 0x0a, 0x40, 0x01, 0x0e, 0x47, 0xfe, 0x41, 0x58, 0x0a,
-	0x99, 0x01, 0x0e, 0xfe, 0x49, 0x54, 0x8e, 0xfe, 0x2a, 0x0d, 0x02, 0xfe,
-	0x2a, 0x03, 0x0a, 0x51, 0xfe, 0xee, 0x14, 0xee, 0x3e, 0x1d, 0xfe, 0xce,
-	0x45, 0x34, 0x3c, 0xfe, 0xce, 0x47, 0xfe, 0xad, 0x13, 0x02, 0x29, 0x1e,
-	0x20, 0x07, 0x10, 0xfe, 0x9e, 0x12, 0x23, 0x12, 0x4d, 0x12, 0x94, 0x12,
-	0xce, 0x1e, 0x2d, 0x47, 0x37, 0x2d, 0xb1, 0xe0, 0xfe, 0xbc, 0xf0, 0xfe,
-	0xec, 0x0d, 0x13, 0x06, 0x12, 0x4d, 0x01, 0xfe, 0xe2, 0x15, 0x05, 0xfe,
-	0x38, 0x01, 0x31, 0xfe, 0x3a, 0x01, 0x77, 0xfe, 0xf0, 0x0d, 0xfe, 0x02,
-	0xec, 0xce, 0x62, 0x00, 0x5d, 0xfe, 0x04, 0xec, 0x20, 0x46, 0xfe, 0x05,
-	0xf6, 0xfe, 0x34, 0x01, 0x01, 0xfe, 0x52, 0x16, 0xfb, 0xfe, 0x48, 0xf4,
-	0x0d, 0xfe, 0x18, 0x13, 0xaf, 0xfe, 0x02, 0xea, 0xce, 0x62, 0x7a, 0xfe,
-	0xc5, 0x13, 0x14, 0x1b, 0x37, 0x95, 0xa9, 0x5c, 0x05, 0xfe, 0x38, 0x01,
-	0x1c, 0xfe, 0xf0, 0xff, 0x0c, 0xfe, 0x60, 0x01, 0x05, 0xfe, 0x3a, 0x01,
-	0x0c, 0xfe, 0x62, 0x01, 0x3d, 0x12, 0x20, 0x24, 0x06, 0x12, 0x2d, 0x11,
-	0x2d, 0x8a, 0x13, 0x06, 0x03, 0x23, 0x03, 0x1e, 0x4d, 0xfe, 0xf7, 0x12,
-	0x1e, 0x94, 0xac, 0x12, 0x94, 0x07, 0x7a, 0xfe, 0x71, 0x13, 0xfe, 0x24,
-	0x1c, 0x14, 0x1a, 0x37, 0x95, 0xa9, 0xfe, 0xd9, 0x10, 0xb6, 0xfe, 0x03,
-	0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x03, 0xb6, 0xfe, 0x03, 0xdc,
-	0xfe, 0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x03, 0xfe, 0x03, 0x57, 0xb6, 0x23,
-	0xfe, 0x00, 0xcc, 0x03, 0xfe, 0x03, 0x57, 0xb6, 0x75, 0x03, 0x09, 0x04,
-	0x4c, 0xfe, 0x22, 0x13, 0xfe, 0x1c, 0x80, 0x07, 0x06, 0xfe, 0x1a, 0x13,
-	0xfe, 0x1e, 0x80, 0xe1, 0xfe, 0x1d, 0x80, 0xa4, 0xfe, 0x0c, 0x90, 0xfe,
-	0x0e, 0x13, 0xfe, 0x0e, 0x90, 0xa3, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4,
-	0x0b, 0xfe, 0x3c, 0x50, 0xa0, 0x01, 0xfe, 0x82, 0x16, 0x2f, 0x07, 0x2d,
-	0xe0, 0x01, 0xfe, 0xbc, 0x15, 0x09, 0x04, 0x1d, 0x45, 0x01, 0xe7, 0x01,
-	0xe8, 0x11, 0xfe, 0xe9, 0x00, 0x09, 0x04, 0x4c, 0xfe, 0x2c, 0x13, 0x01,
-	0xfe, 0x14, 0x16, 0xfe, 0x1e, 0x1c, 0xfe, 0x14, 0x90, 0xfe, 0x96, 0x90,
-	0x0c, 0xfe, 0x64, 0x01, 0x18, 0xfe, 0x66, 0x01, 0x09, 0x04, 0x4f, 0xfe,
-	0x12, 0x12, 0xfe, 0x03, 0x80, 0x74, 0xfe, 0x01, 0xec, 0x20, 0xfe, 0x80,
-	0x40, 0x12, 0x20, 0x63, 0x27, 0x11, 0xc8, 0x59, 0x1e, 0x20, 0xed, 0x76,
-	0x20, 0x03, 0xfe, 0x08, 0x1c, 0x05, 0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58,
-	0x05, 0xfe, 0xae, 0x00, 0xfe, 0x07, 0x58, 0x05, 0xfe, 0xb0, 0x00, 0xfe,
-	0x08, 0x58, 0x05, 0xfe, 0xb2, 0x00, 0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c,
-	0x24, 0x69, 0x12, 0xc9, 0x23, 0x0c, 0x50, 0x0c, 0x3f, 0x13, 0x40, 0x48,
-	0x5f, 0x17, 0x1d, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x21, 0xfe, 0x08,
-	0x0f, 0x3e, 0x10, 0x13, 0x42, 0x48, 0x17, 0x4c, 0xfe, 0x90, 0x4d, 0xfe,
-	0x91, 0x54, 0x21, 0xfe, 0x1e, 0x0f, 0x24, 0x10, 0x12, 0x20, 0x78, 0x2c,
-	0x46, 0x1e, 0x20, 0xed, 0x76, 0x20, 0x11, 0xc8, 0xf6, 0xfe, 0xd6, 0xf0,
-	0xfe, 0x32, 0x0f, 0xea, 0x70, 0xfe, 0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe,
-	0x18, 0x1c, 0x03, 0x3c, 0xfe, 0x0c, 0x14, 0xee, 0xfe, 0x07, 0xe6, 0x1d,
-	0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x03, 0x01, 0x86, 0x78, 0x2c, 0x46,
-	0xfa, 0xef, 0xfe, 0x42, 0x13, 0x2f, 0x07, 0x2d, 0xfe, 0x34, 0x13, 0x0a,
-	0x42, 0x01, 0x0e, 0xb0, 0xfe, 0x36, 0x12, 0xf0, 0xfe, 0x45, 0x48, 0x01,
-	0xe3, 0xfe, 0x00, 0xcc, 0xb0, 0xfe, 0xf3, 0x13, 0x3d, 0x75, 0x07, 0x10,
-	0xa3, 0x0a, 0x80, 0x01, 0x0e, 0xfe, 0x80, 0x5c, 0x01, 0x6f, 0xfe, 0x0e,
-	0x10, 0x07, 0x7e, 0x45, 0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x6c, 0x0f, 0x03,
-	0xfe, 0x44, 0x58, 0x74, 0xfe, 0x01, 0xec, 0x97, 0xfe, 0x9e, 0x40, 0xfe,
-	0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x1b, 0x76, 0x27, 0x01, 0xda, 0xfe,
-	0xdd, 0x10, 0x2a, 0xbc, 0x7d, 0xbd, 0x7f, 0x30, 0x2e, 0xd5, 0x07, 0x1b,
-	0xfe, 0x48, 0x12, 0x07, 0x0b, 0xfe, 0x56, 0x12, 0x07, 0x1a, 0xfe, 0x30,
-	0x12, 0x07, 0xc2, 0x16, 0xfe, 0x3e, 0x11, 0x07, 0xfe, 0x23, 0x00, 0x16,
-	0xfe, 0x4a, 0x11, 0x07, 0x06, 0x16, 0xfe, 0xa8, 0x11, 0x07, 0x19, 0xfe,
-	0x12, 0x12, 0x07, 0x00, 0x16, 0x22, 0x14, 0xc2, 0x01, 0x33, 0x9f, 0x2b,
-	0x01, 0x08, 0x8c, 0x43, 0x03, 0x2b, 0xfe, 0x62, 0x08, 0x0a, 0xca, 0x01,
-	0xfe, 0x32, 0x0e, 0x11, 0x7e, 0x02, 0x29, 0x2b, 0x2f, 0x07, 0x9b, 0xfe,
-	0xd9, 0x13, 0x79, 0x39, 0x68, 0x3a, 0x77, 0xfe, 0xfc, 0x10, 0x09, 0x04,
-	0x6a, 0xfe, 0x72, 0x12, 0xc0, 0x38, 0xc1, 0x4e, 0xf4, 0xf5, 0x8e, 0xfe,
-	0xc6, 0x10, 0x1e, 0x58, 0xfe, 0x26, 0x13, 0x05, 0x7b, 0x31, 0x7c, 0x77,
-	0xfe, 0x82, 0x0c, 0x0c, 0x54, 0x18, 0x55, 0x23, 0x0c, 0x7b, 0x0c, 0x7c,
-	0x01, 0xa8, 0x24, 0x69, 0x73, 0x12, 0x58, 0x01, 0xa5, 0xc0, 0x38, 0xc1,
-	0x4e, 0xfe, 0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x38, 0xfe,
-	0x05, 0xfa, 0x4e, 0xfe, 0x91, 0x10, 0x05, 0x56, 0x31, 0x57, 0xfe, 0x40,
-	0x56, 0xfe, 0xe1, 0x56, 0x0c, 0x56, 0x18, 0x57, 0x83, 0xc0, 0x38, 0xc1,
-	0x4e, 0xf4, 0xf5, 0x05, 0x52, 0x31, 0x53, 0xfe, 0x00, 0x56, 0xfe, 0xa1,
-	0x56, 0x0c, 0x52, 0x18, 0x53, 0x09, 0x04, 0x6a, 0xfe, 0x1e, 0x12, 0x1e,
-	0x58, 0xfe, 0x1f, 0x40, 0x05, 0x54, 0x31, 0x55, 0xfe, 0x2c, 0x50, 0xfe,
-	0xae, 0x50, 0x05, 0x56, 0x31, 0x57, 0xfe, 0x44, 0x50, 0xfe, 0xc6, 0x50,
-	0x05, 0x52, 0x31, 0x53, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x05, 0x39,
-	0x31, 0x3a, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x02, 0x5c, 0x24, 0x06,
-	0x12, 0xcd, 0x02, 0x5b, 0x2b, 0x01, 0x08, 0x1f, 0x44, 0x30, 0x2e, 0xd5,
-	0x07, 0x06, 0x21, 0x44, 0x2f, 0x07, 0x9b, 0x21, 0x5b, 0x01, 0x6e, 0x1c,
-	0x3d, 0x16, 0x44, 0x09, 0x04, 0x0b, 0xe2, 0x79, 0x39, 0x68, 0x3a, 0xfe,
-	0x0a, 0x55, 0x34, 0xfe, 0x8b, 0x55, 0xbe, 0x39, 0xbf, 0x3a, 0xfe, 0x0c,
-	0x51, 0xfe, 0x8e, 0x51, 0x02, 0x5b, 0xfe, 0x19, 0x81, 0xaf, 0xfe, 0x19,
-	0x41, 0x02, 0x5b, 0x2b, 0x01, 0x08, 0x25, 0x32, 0x1f, 0xa2, 0x30, 0x2e,
-	0xd8, 0x4b, 0x1a, 0xfe, 0xa6, 0x12, 0x4b, 0x0b, 0x3b, 0x02, 0x44, 0x01,
-	0x08, 0x25, 0x32, 0x1f, 0xa2, 0x30, 0x2e, 0xd6, 0x07, 0x1a, 0x21, 0x44,
-	0x01, 0x08, 0x1f, 0xa2, 0x30, 0x2e, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49,
-	0x60, 0x05, 0xfe, 0x9c, 0x00, 0x28, 0x84, 0x49, 0x04, 0x19, 0x34, 0x9f,
-	0xfe, 0xbb, 0x45, 0x4b, 0x00, 0x45, 0x3e, 0x06, 0x78, 0x3d, 0xfe, 0xda,
-	0x14, 0x01, 0x6e, 0x87, 0xfe, 0x4b, 0x45, 0xe2, 0x2f, 0x07, 0x9a, 0xe1,
-	0x05, 0xc6, 0x28, 0x84, 0x05, 0x3f, 0x28, 0x34, 0x5e, 0x02, 0x5b, 0xfe,
-	0xc0, 0x5d, 0xfe, 0xf8, 0x14, 0xfe, 0x03, 0x17, 0x05, 0x50, 0xb4, 0x0c,
-	0x50, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01, 0xfe, 0xaa, 0x14, 0x02,
-	0x5c, 0x01, 0x08, 0x25, 0x32, 0x1f, 0x44, 0x30, 0x2e, 0xd6, 0x07, 0x06,
-	0x21, 0x44, 0x01, 0xfe, 0x8e, 0x13, 0xfe, 0x42, 0x58, 0xfe, 0x82, 0x14,
-	0xfe, 0xa4, 0x14, 0x87, 0xfe, 0x4a, 0xf4, 0x0b, 0x16, 0x44, 0xfe, 0x4a,
-	0xf4, 0x06, 0xfe, 0x0c, 0x12, 0x2f, 0x07, 0x9a, 0x85, 0x02, 0x5b, 0x05,
-	0x3f, 0xb4, 0x0c, 0x3f, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01, 0xfe,
-	0xd8, 0x14, 0x02, 0x5c, 0x13, 0x06, 0x65, 0xfe, 0xca, 0x12, 0x26, 0xfe,
-	0xe0, 0x12, 0x72, 0xf1, 0x01, 0x08, 0x23, 0x72, 0x03, 0x8f, 0xfe, 0xdc,
-	0x12, 0x25, 0xfe, 0xdc, 0x12, 0x1f, 0xfe, 0xca, 0x12, 0x5e, 0x2b, 0x01,
-	0x08, 0xfe, 0xd5, 0x10, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b,
-	0x1c, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x03, 0x13,
-	0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0x1c, 0x3d, 0xfe, 0x30, 0x56,
-	0xfe, 0x00, 0x5c, 0x03, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b,
-	0x03, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0xfe, 0x0b, 0x58,
-	0x03, 0x0a, 0x50, 0x01, 0x82, 0x0a, 0x3f, 0x01, 0x82, 0x03, 0xfc, 0x1c,
-	0x10, 0xff, 0x03, 0x00, 0x54, 0xfe, 0x00, 0xf4, 0x19, 0x48, 0xfe, 0x00,
-	0x7d, 0xfe, 0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe, 0x03, 0x7c, 0x63, 0x27,
-	0x0c, 0x52, 0x18, 0x53, 0xbe, 0x56, 0xbf, 0x57, 0x03, 0xfe, 0x62, 0x08,
-	0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x74, 0x03, 0x01,
-	0xfe, 0x14, 0x18, 0xfe, 0x42, 0x48, 0x5f, 0x60, 0x89, 0x01, 0x08, 0x1f,
-	0xfe, 0xa2, 0x14, 0x30, 0x2e, 0xd8, 0x01, 0x08, 0x1f, 0xfe, 0xa2, 0x14,
-	0x30, 0x2e, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x05, 0xc6, 0x28, 0xfe,
-	0xcc, 0x12, 0x49, 0x04, 0x1b, 0xfe, 0xc4, 0x13, 0x23, 0x62, 0x1b, 0xe2,
-	0x4b, 0xc3, 0x64, 0xfe, 0xe8, 0x13, 0x3b, 0x13, 0x06, 0x17, 0xc3, 0x78,
-	0xdb, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xa1, 0xff, 0x02, 0x83,
-	0x55, 0x62, 0x1a, 0xa4, 0xbb, 0xfe, 0x30, 0x00, 0x8e, 0xe4, 0x17, 0x2c,
-	0x13, 0x06, 0xfe, 0x56, 0x10, 0x62, 0x0b, 0xe1, 0xbb, 0xfe, 0x64, 0x00,
-	0x8e, 0xe4, 0x0a, 0xfe, 0x64, 0x00, 0x17, 0x93, 0x13, 0x06, 0xfe, 0x28,
-	0x10, 0x62, 0x06, 0xfe, 0x60, 0x13, 0xbb, 0xfe, 0xc8, 0x00, 0x8e, 0xe4,
-	0x0a, 0xfe, 0xc8, 0x00, 0x17, 0x4d, 0x13, 0x06, 0x83, 0xbb, 0xfe, 0x90,
-	0x01, 0xba, 0xfe, 0x4e, 0x14, 0x89, 0xfe, 0x12, 0x10, 0xfe, 0x43, 0xf4,
-	0x94, 0xfe, 0x56, 0xf0, 0xfe, 0x60, 0x14, 0xfe, 0x04, 0xf4, 0x6c, 0xfe,
-	0x43, 0xf4, 0x93, 0xfe, 0xf3, 0x10, 0xf9, 0x01, 0xfe, 0x22, 0x13, 0x1c,
-	0x3d, 0xfe, 0x10, 0x13, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x69, 0xba,
-	0xfe, 0x9c, 0x14, 0xb7, 0x69, 0xfe, 0x1c, 0x10, 0xfe, 0x00, 0x17, 0xfe,
-	0x4d, 0xe4, 0x19, 0xba, 0xfe, 0x9c, 0x14, 0xb7, 0x19, 0x83, 0x60, 0x23,
-	0xfe, 0x4d, 0xf4, 0x00, 0xdf, 0x89, 0x13, 0x06, 0xfe, 0xb4, 0x56, 0xfe,
-	0xc3, 0x58, 0x03, 0x60, 0x13, 0x0b, 0x03, 0x15, 0x06, 0x01, 0x08, 0x26,
-	0xe5, 0x15, 0x0b, 0x01, 0x08, 0x26, 0xe5, 0x15, 0x1a, 0x01, 0x08, 0x26,
-	0xe5, 0x72, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x03, 0x15, 0x06, 0x01, 0x08,
-	0x26, 0xa6, 0x15, 0x1a, 0x01, 0x08, 0x26, 0xa6, 0x15, 0x06, 0x01, 0x08,
-	0x26, 0xa6, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x26, 0xa6, 0x72, 0xfe, 0x89,
-	0x4a, 0x01, 0x08, 0x03, 0x60, 0x03, 0x1e, 0xcc, 0x07, 0x06, 0xfe, 0x44,
-	0x13, 0xad, 0x12, 0xcc, 0xfe, 0x49, 0xf4, 0x00, 0x3b, 0x72, 0x9f, 0x5e,
-	0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xf1, 0x01, 0x08, 0x2f, 0x07, 0xfe,
-	0xe3, 0x00, 0xfe, 0x20, 0x13, 0x1f, 0xfe, 0x5a, 0x15, 0x23, 0x12, 0xcd,
-	0x01, 0x43, 0x1e, 0xcd, 0x07, 0x06, 0x45, 0x09, 0x4a, 0x06, 0x35, 0x03,
-	0x0a, 0x42, 0x01, 0x0e, 0xed, 0x88, 0x07, 0x10, 0xa4, 0x0a, 0x80, 0x01,
-	0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03, 0x0a, 0x80, 0x01, 0x0e, 0x88,
-	0xfe, 0x80, 0xe7, 0x10, 0x07, 0x10, 0x84, 0xfe, 0x45, 0x58, 0x01, 0xe3,
-	0x88, 0x03, 0x0a, 0x42, 0x01, 0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03,
-	0x0a, 0x42, 0x01, 0x0e, 0xfe, 0x80, 0x80, 0xf2, 0xfe, 0x49, 0xe4, 0x10,
-	0xa4, 0x0a, 0x80, 0x01, 0x0e, 0xf2, 0x0a, 0x51, 0x01, 0x82, 0x03, 0x17,
-	0x10, 0x71, 0x66, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde,
-	0xfe, 0x24, 0x1c, 0xfe, 0x1d, 0xf7, 0x1d, 0x90, 0xfe, 0xf6, 0x15, 0x01,
-	0xfe, 0xfc, 0x16, 0xe0, 0x91, 0x1d, 0x66, 0xfe, 0x2c, 0x01, 0xfe, 0x2f,
-	0x19, 0x03, 0xae, 0x21, 0xfe, 0xe6, 0x15, 0xfe, 0xda, 0x10, 0x17, 0x10,
-	0x71, 0x05, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x19, 0xfe, 0x18, 0x58,
-	0x05, 0xfe, 0x66, 0x01, 0xfe, 0x19, 0x58, 0x91, 0x19, 0xfe, 0x3c, 0x90,
-	0xfe, 0x30, 0xf4, 0x06, 0xfe, 0x3c, 0x50, 0x66, 0xfe, 0x38, 0x00, 0xfe,
-	0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x19, 0x90, 0xfe, 0x40, 0x16, 0xfe, 0xb6,
-	0x14, 0x34, 0x03, 0xae, 0x21, 0xfe, 0x18, 0x16, 0xfe, 0x9c, 0x10, 0x17,
-	0x10, 0x71, 0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe,
-	0x1d, 0xf7, 0x38, 0x90, 0xfe, 0x62, 0x16, 0xfe, 0x94, 0x14, 0xfe, 0x10,
-	0x13, 0x91, 0x38, 0x66, 0x1b, 0xfe, 0xaf, 0x19, 0xfe, 0x98, 0xe7, 0x00,
-	0x03, 0xae, 0x21, 0xfe, 0x56, 0x16, 0xfe, 0x6c, 0x10, 0x17, 0x10, 0x71,
-	0xfe, 0x30, 0xbc, 0xfe, 0xb2, 0xbc, 0x91, 0xc5, 0x66, 0x1b, 0xfe, 0x0f,
-	0x79, 0xfe, 0x1c, 0xf7, 0xc5, 0x90, 0xfe, 0x9a, 0x16, 0xfe, 0x5c, 0x14,
-	0x34, 0x03, 0xae, 0x21, 0xfe, 0x86, 0x16, 0xfe, 0x42, 0x10, 0xfe, 0x02,
-	0xf6, 0x10, 0x71, 0xfe, 0x18, 0xfe, 0x54, 0xfe, 0x19, 0xfe, 0x55, 0xfc,
-	0xfe, 0x1d, 0xf7, 0x4f, 0x90, 0xfe, 0xc0, 0x16, 0xfe, 0x36, 0x14, 0xfe,
-	0x1c, 0x13, 0x91, 0x4f, 0x47, 0xfe, 0x83, 0x58, 0xfe, 0xaf, 0x19, 0xfe,
-	0x80, 0xe7, 0x10, 0xfe, 0x81, 0xe7, 0x10, 0x11, 0xfe, 0xdd, 0x00, 0x63,
-	0x27, 0x03, 0x63, 0x27, 0xfe, 0x12, 0x45, 0x21, 0xfe, 0xb0, 0x16, 0x14,
-	0x06, 0x37, 0x95, 0xa9, 0x02, 0x29, 0xfe, 0x39, 0xf0, 0xfe, 0x04, 0x17,
-	0x23, 0x03, 0xfe, 0x7e, 0x18, 0x1c, 0x1a, 0x5d, 0x13, 0x0d, 0x03, 0x71,
-	0x05, 0xcb, 0x1c, 0x06, 0xfe, 0xef, 0x12, 0xfe, 0xe1, 0x10, 0x78, 0x2c,
-	0x46, 0x2f, 0x07, 0x2d, 0xfe, 0x3c, 0x13, 0xfe, 0x82, 0x14, 0xfe, 0x42,
-	0x13, 0x3c, 0x8a, 0x0a, 0x42, 0x01, 0x0e, 0xb0, 0xfe, 0x3e, 0x12, 0xf0,
-	0xfe, 0x45, 0x48, 0x01, 0xe3, 0xfe, 0x00, 0xcc, 0xb0, 0xfe, 0xf3, 0x13,
-	0x3d, 0x75, 0x07, 0x10, 0xa3, 0x0a, 0x80, 0x01, 0x0e, 0xf2, 0x01, 0x6f,
-	0xfe, 0x16, 0x10, 0x07, 0x7e, 0x85, 0xfe, 0x40, 0x14, 0xfe, 0x24, 0x12,
-	0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x24, 0x17, 0x17, 0x0b, 0x03, 0xfe, 0x9c,
-	0xe7, 0x0b, 0x0f, 0xfe, 0x15, 0x00, 0x59, 0x76, 0x27, 0x01, 0xda, 0x17,
-	0x06, 0x03, 0x3c, 0x8a, 0x09, 0x4a, 0x1d, 0x35, 0x11, 0x2d, 0x01, 0x6f,
-	0x17, 0x06, 0x03, 0xfe, 0x38, 0x90, 0xfe, 0xba, 0x90, 0x79, 0xc7, 0x68,
-	0xc8, 0xfe, 0x48, 0x55, 0x34, 0xfe, 0xc9, 0x55, 0x03, 0x1e, 0x98, 0x73,
-	0x12, 0x98, 0x03, 0x0a, 0x99, 0x01, 0x0e, 0xf0, 0x0a, 0x40, 0x01, 0x0e,
-	0xfe, 0x49, 0x44, 0x16, 0xfe, 0xf0, 0x17, 0x73, 0x75, 0x03, 0x0a, 0x42,
-	0x01, 0x0e, 0x07, 0x10, 0x45, 0x0a, 0x51, 0x01, 0x9e, 0x0a, 0x40, 0x01,
-	0x0e, 0x73, 0x75, 0x03, 0xfe, 0x4e, 0xe4, 0x1a, 0x64, 0xfe, 0x24, 0x18,
-	0x05, 0xfe, 0x90, 0x00, 0xfe, 0x3a, 0x45, 0x5b, 0xfe, 0x4e, 0xe4, 0xc2,
-	0x64, 0xfe, 0x36, 0x18, 0x05, 0xfe, 0x92, 0x00, 0xfe, 0x02, 0xe6, 0x1b,
-	0xdc, 0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x64, 0xfe, 0x48, 0x18, 0x05,
-	0xfe, 0x94, 0x00, 0xfe, 0x02, 0xe6, 0x19, 0xfe, 0x08, 0x10, 0x05, 0xfe,
-	0x96, 0x00, 0xfe, 0x02, 0xe6, 0x2c, 0xfe, 0x4e, 0x45, 0xfe, 0x0c, 0x12,
-	0xaf, 0xff, 0x04, 0x68, 0x54, 0xde, 0x1c, 0x69, 0x03, 0x07, 0x7a, 0xfe,
-	0x5a, 0xf0, 0xfe, 0x74, 0x18, 0x24, 0xfe, 0x09, 0x00, 0xfe, 0x34, 0x10,
-	0x07, 0x1b, 0xfe, 0x5a, 0xf0, 0xfe, 0x82, 0x18, 0x24, 0xc3, 0xfe, 0x26,
-	0x10, 0x07, 0x1a, 0x5d, 0x24, 0x2c, 0xdc, 0x07, 0x0b, 0x5d, 0x24, 0x93,
-	0xfe, 0x0e, 0x10, 0x07, 0x06, 0x5d, 0x24, 0x4d, 0x9f, 0xad, 0x03, 0x14,
-	0xfe, 0x09, 0x00, 0x01, 0x33, 0xfe, 0x04, 0xfe, 0x7d, 0x05, 0x7f, 0xf9,
-	0x03, 0x25, 0xfe, 0xca, 0x18, 0xfe, 0x14, 0xf0, 0x08, 0x65, 0xfe, 0xc6,
-	0x18, 0x03, 0xff, 0x1a, 0x00, 0x00,
-};
-
-static unsigned short _adv_asc3550_size = sizeof(_adv_asc3550_buf);	/* 0x13AD */
-static ADV_DCNT _adv_asc3550_chksum = 0x04D52DDDUL;	/* Expanded little-endian checksum. */
-
-/* Microcode buffer is kept after initialization for error recovery. */
-static unsigned char _adv_asc38C0800_buf[] = {
-	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0xfc, 0x00, 0x16, 0x18, 0xe4,
-	0x01, 0x00, 0x48, 0xe4, 0x18, 0x80, 0x03, 0xf6, 0x02, 0x00, 0xce, 0x19,
-	0x00, 0xfa, 0xff, 0xff, 0x1c, 0x0f, 0x00, 0xf6, 0x9e, 0xe7, 0xff, 0x00,
-	0x82, 0xe7, 0x00, 0xea, 0x01, 0xfa, 0x01, 0xe6, 0x09, 0xe7, 0x55, 0xf0,
-	0x01, 0xf6, 0x03, 0x00, 0x04, 0x00, 0x10, 0x00, 0x1e, 0xf0, 0x85, 0xf0,
-	0x18, 0xf4, 0x08, 0x00, 0xbc, 0x00, 0x38, 0x54, 0x00, 0xec, 0xd5, 0xf0,
-	0x82, 0x0d, 0x00, 0xe6, 0x86, 0xf0, 0xb1, 0xf0, 0x98, 0x57, 0x01, 0xfc,
-	0xb4, 0x00, 0xd4, 0x01, 0x0c, 0x1c, 0x3e, 0x1c, 0x3c, 0x00, 0xbb, 0x00,
-	0x00, 0x10, 0xba, 0x19, 0x02, 0x80, 0x32, 0xf0, 0x7c, 0x0d, 0x02, 0x13,
-	0xba, 0x13, 0x18, 0x40, 0x00, 0x57, 0x01, 0xea, 0x02, 0xfc, 0x03, 0xfc,
-	0x3e, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x74, 0x01, 0x76, 0x01, 0xb9, 0x54,
-	0x3e, 0x57, 0x00, 0x80, 0x03, 0xe6, 0xb6, 0x00, 0xc0, 0x00, 0x01, 0x01,
-	0x3e, 0x01, 0x7a, 0x01, 0xca, 0x08, 0xce, 0x10, 0x16, 0x11, 0x04, 0x12,
-	0x08, 0x12, 0x02, 0x4a, 0xbb, 0x55, 0x3c, 0x56, 0x03, 0x58, 0x1b, 0x80,
-	0x30, 0xe4, 0x4b, 0xe4, 0x5d, 0xf0, 0x02, 0xfa, 0x20, 0x00, 0x32, 0x00,
-	0x40, 0x00, 0x80, 0x00, 0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01,
-	0x70, 0x01, 0x72, 0x01, 0x78, 0x01, 0x7c, 0x01, 0x62, 0x0a, 0x86, 0x0d,
-	0x06, 0x13, 0x4c, 0x1c, 0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0,
-	0x03, 0xf7, 0x0c, 0x00, 0x0f, 0x00, 0x47, 0x00, 0xbe, 0x00, 0x00, 0x01,
-	0x20, 0x11, 0x5c, 0x16, 0x32, 0x1c, 0x38, 0x1c, 0x4e, 0x1c, 0x10, 0x44,
-	0x00, 0x4c, 0x04, 0xea, 0x5c, 0xf0, 0xa7, 0xf0, 0x04, 0xf6, 0x03, 0xfa,
-	0x05, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00, 0xcc, 0x00, 0x20, 0x01,
-	0x4e, 0x01, 0x4a, 0x0b, 0x42, 0x0c, 0x12, 0x0f, 0x0c, 0x10, 0x22, 0x11,
-	0x0a, 0x12, 0x04, 0x13, 0x30, 0x1c, 0x02, 0x48, 0x00, 0x4e, 0x42, 0x54,
-	0x44, 0x55, 0xbd, 0x56, 0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0,
-	0x59, 0xf0, 0xb8, 0xf0, 0x4b, 0xf4, 0x06, 0xf7, 0x0e, 0xf7, 0x04, 0xfc,
-	0x05, 0xfc, 0x06, 0x00, 0x19, 0x00, 0x33, 0x00, 0x9b, 0x00, 0xa4, 0x00,
-	0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00, 0xe7, 0x00, 0xe2, 0x03,
-	0x08, 0x0f, 0x02, 0x10, 0x04, 0x10, 0x0a, 0x10, 0x0a, 0x13, 0x0c, 0x13,
-	0x12, 0x13, 0x24, 0x14, 0x34, 0x14, 0x04, 0x16, 0x08, 0x16, 0xa4, 0x17,
-	0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c, 0x08, 0x44, 0x38, 0x44, 0x91, 0x44,
-	0x0a, 0x45, 0x48, 0x46, 0x01, 0x48, 0x68, 0x54, 0x3a, 0x55, 0x83, 0x55,
-	0xe5, 0x55, 0xb0, 0x57, 0x01, 0x58, 0x83, 0x59, 0x05, 0xe6, 0x0b, 0xf0,
-	0x0c, 0xf0, 0x04, 0xf8, 0x05, 0xf8, 0x07, 0x00, 0x0a, 0x00, 0x1c, 0x00,
-	0x1e, 0x00, 0x9e, 0x00, 0xa8, 0x00, 0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00,
-	0x22, 0x01, 0x26, 0x01, 0x79, 0x01, 0x7e, 0x01, 0xc4, 0x01, 0xc6, 0x01,
-	0x80, 0x02, 0x5e, 0x03, 0xee, 0x04, 0x9a, 0x06, 0xf8, 0x07, 0x62, 0x08,
-	0x68, 0x08, 0x69, 0x08, 0xd6, 0x08, 0xe9, 0x09, 0xfa, 0x0b, 0x2e, 0x0f,
-	0x12, 0x10, 0x1a, 0x10, 0xed, 0x10, 0xf1, 0x10, 0x2a, 0x11, 0x06, 0x12,
-	0x0c, 0x12, 0x3e, 0x12, 0x10, 0x13, 0x16, 0x13, 0x1e, 0x13, 0x46, 0x14,
-	0x76, 0x14, 0x82, 0x14, 0x36, 0x15, 0xca, 0x15, 0x6b, 0x18, 0xbe, 0x18,
-	0xca, 0x18, 0xe6, 0x19, 0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40,
-	0x0e, 0x47, 0xfe, 0x9c, 0xf0, 0x2b, 0x02, 0xfe, 0xac, 0x0d, 0xff, 0x10,
-	0x00, 0x00, 0xd7, 0xfe, 0xe8, 0x19, 0x00, 0xd6, 0xfe, 0x84, 0x01, 0xff,
-	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
-	0x00, 0xfe, 0x57, 0x24, 0x00, 0xfe, 0x4c, 0x00, 0x5b, 0xff, 0x04, 0x00,
-	0x00, 0x11, 0xff, 0x09, 0x00, 0x00, 0xff, 0x08, 0x01, 0x01, 0xff, 0x08,
-	0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10, 0xff, 0xff, 0xff, 0x11,
-	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
-	0xfe, 0x04, 0xf7, 0xd6, 0x2c, 0x99, 0x0a, 0x01, 0xfe, 0xc2, 0x0f, 0xfe,
-	0x04, 0xf7, 0xd6, 0x99, 0x0a, 0x42, 0x2c, 0xfe, 0x3d, 0xf0, 0xfe, 0x06,
-	0x02, 0xfe, 0x20, 0xf0, 0xa7, 0xfe, 0x91, 0xf0, 0xfe, 0xf4, 0x01, 0xfe,
-	0x90, 0xf0, 0xfe, 0xf4, 0x01, 0xfe, 0x8f, 0xf0, 0xa7, 0x03, 0x5d, 0x4d,
-	0x02, 0xfe, 0xc8, 0x0d, 0x01, 0xfe, 0x38, 0x0e, 0xfe, 0xdd, 0x12, 0xfe,
-	0xfc, 0x10, 0xfe, 0x28, 0x1c, 0x03, 0xfe, 0xa6, 0x00, 0xfe, 0xd3, 0x12,
-	0x41, 0x14, 0xfe, 0xa6, 0x00, 0xc2, 0xfe, 0x48, 0xf0, 0xfe, 0x8a, 0x02,
-	0xfe, 0x49, 0xf0, 0xfe, 0xa4, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xc2, 0x02,
-	0xfe, 0x46, 0xf0, 0xfe, 0x54, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x5a, 0x02,
-	0xfe, 0x43, 0xf0, 0xfe, 0x48, 0x02, 0xfe, 0x44, 0xf0, 0xfe, 0x4c, 0x02,
-	0xfe, 0x45, 0xf0, 0xfe, 0x50, 0x02, 0x18, 0x0a, 0xaa, 0x18, 0x06, 0x14,
-	0xa1, 0x02, 0x2b, 0xfe, 0x00, 0x1c, 0xe7, 0xfe, 0x02, 0x1c, 0xe6, 0xfe,
-	0x1e, 0x1c, 0xfe, 0xe9, 0x10, 0x01, 0xfe, 0x18, 0x18, 0xfe, 0xe7, 0x10,
-	0xfe, 0x06, 0xfc, 0xce, 0x09, 0x70, 0x01, 0xa8, 0x02, 0x2b, 0x15, 0x59,
-	0x39, 0xa2, 0x01, 0xfe, 0x58, 0x10, 0x09, 0x70, 0x01, 0x87, 0xfe, 0xbd,
-	0x10, 0x09, 0x70, 0x01, 0x87, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c, 0xfe,
-	0x58, 0x1c, 0x18, 0x06, 0x14, 0xa1, 0x2c, 0x1c, 0x2b, 0xfe, 0x3d, 0xf0,
-	0xfe, 0x06, 0x02, 0x23, 0xfe, 0x98, 0x02, 0xfe, 0x5a, 0x1c, 0xf8, 0xfe,
-	0x14, 0x1c, 0x15, 0xfe, 0x30, 0x00, 0x39, 0xa2, 0x01, 0xfe, 0x48, 0x10,
-	0x18, 0x06, 0x14, 0xa1, 0x02, 0xd7, 0x22, 0x20, 0x07, 0x11, 0x35, 0xfe,
-	0x69, 0x10, 0x18, 0x06, 0x14, 0xa1, 0xfe, 0x04, 0xec, 0x20, 0x4f, 0x43,
-	0x13, 0x20, 0xfe, 0x05, 0xf6, 0xce, 0x01, 0xfe, 0x4a, 0x17, 0x08, 0x54,
-	0x58, 0x37, 0x12, 0x2f, 0x42, 0x92, 0x01, 0xfe, 0x82, 0x16, 0x02, 0x2b,
-	0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x66, 0x01, 0x73, 0xfe, 0x18, 0x10,
-	0xfe, 0x41, 0x58, 0x09, 0xa4, 0x01, 0x0e, 0xfe, 0xc8, 0x54, 0x6b, 0xfe,
-	0x10, 0x03, 0x01, 0xfe, 0x82, 0x16, 0x02, 0x2b, 0x2c, 0x4f, 0xfe, 0x02,
-	0xe8, 0x2a, 0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43, 0xfe, 0x77, 0x57, 0xfe,
-	0x27, 0xf0, 0xfe, 0xe0, 0x01, 0xfe, 0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xa7,
-	0xfe, 0x40, 0x1c, 0x1c, 0xd9, 0xfe, 0x26, 0xf0, 0xfe, 0x5a, 0x03, 0xfe,
-	0xa0, 0xf0, 0xfe, 0x48, 0x03, 0xfe, 0x11, 0xf0, 0xa7, 0xfe, 0xef, 0x10,
-	0xfe, 0x9f, 0xf0, 0xfe, 0x68, 0x03, 0xf9, 0x10, 0xfe, 0x11, 0x00, 0x02,
-	0x65, 0x2c, 0xfe, 0x48, 0x1c, 0xf9, 0x08, 0x05, 0x1b, 0xfe, 0x18, 0x13,
-	0x21, 0x22, 0xa3, 0xb7, 0x13, 0xa3, 0x09, 0x46, 0x01, 0x0e, 0xb7, 0x78,
-	0x01, 0xfe, 0xb4, 0x16, 0x12, 0xd1, 0x1c, 0xd9, 0xfe, 0x01, 0xf0, 0xd9,
-	0xfe, 0x82, 0xf0, 0xfe, 0x96, 0x03, 0xfa, 0x12, 0xfe, 0xe4, 0x00, 0x27,
-	0xfe, 0xa8, 0x03, 0x1c, 0x34, 0x1d, 0xfe, 0xb8, 0x03, 0x01, 0x4b, 0xfe,
-	0x06, 0xf0, 0xfe, 0xc8, 0x03, 0x95, 0x86, 0xfe, 0x0a, 0xf0, 0xfe, 0x8a,
-	0x06, 0x02, 0x24, 0x03, 0x70, 0x28, 0x17, 0xfe, 0xfa, 0x04, 0x15, 0x6d,
-	0x01, 0x36, 0x7b, 0xfe, 0x6a, 0x02, 0x02, 0xd8, 0xf9, 0x2c, 0x99, 0x19,
-	0xfe, 0x67, 0x1b, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57, 0xfe, 0x48, 0x1c,
-	0x74, 0x01, 0xaf, 0x8c, 0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x17, 0xda,
-	0x09, 0xd1, 0x01, 0x0e, 0x8d, 0x51, 0x64, 0x79, 0x2a, 0x03, 0x70, 0x28,
-	0xfe, 0x10, 0x12, 0x15, 0x6d, 0x01, 0x36, 0x7b, 0xfe, 0x6a, 0x02, 0x02,
-	0xd8, 0xc7, 0x81, 0xc8, 0x83, 0x1c, 0x24, 0x27, 0xfe, 0x40, 0x04, 0x1d,
-	0xfe, 0x3c, 0x04, 0x3b, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e,
-	0x12, 0x2d, 0xff, 0x02, 0x00, 0x10, 0x01, 0x0b, 0x1d, 0xfe, 0xe4, 0x04,
-	0x2d, 0x01, 0x0b, 0x1d, 0x24, 0x33, 0x31, 0xde, 0xfe, 0x4c, 0x44, 0xfe,
-	0x4c, 0x12, 0x51, 0xfe, 0x44, 0x48, 0x0f, 0x6f, 0xfe, 0x4c, 0x54, 0x6b,
-	0xda, 0x4f, 0x79, 0x2a, 0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x62,
-	0x13, 0x08, 0x05, 0x1b, 0xfe, 0x2a, 0x13, 0x32, 0x07, 0x82, 0xfe, 0x52,
-	0x13, 0xfe, 0x20, 0x10, 0x0f, 0x6f, 0xfe, 0x4c, 0x54, 0x6b, 0xda, 0xfe,
-	0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x40, 0x13, 0x08, 0x05, 0x1b, 0xfe,
-	0x08, 0x13, 0x32, 0x07, 0x82, 0xfe, 0x30, 0x13, 0x08, 0x05, 0x1b, 0xfe,
-	0x1c, 0x12, 0x15, 0x9d, 0x08, 0x05, 0x06, 0x4d, 0x15, 0xfe, 0x0d, 0x00,
-	0x01, 0x36, 0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24, 0x2d, 0x12, 0xfe, 0xe6,
-	0x00, 0xfe, 0x1c, 0x90, 0xfe, 0x40, 0x5c, 0x04, 0x15, 0x9d, 0x01, 0x36,
-	0x02, 0x2b, 0xfe, 0x42, 0x5b, 0x99, 0x19, 0xfe, 0x46, 0x59, 0xfe, 0xbf,
-	0x57, 0xfe, 0x77, 0x57, 0xfe, 0x87, 0x80, 0xfe, 0x31, 0xe4, 0x5b, 0x08,
-	0x05, 0x0a, 0xfe, 0x84, 0x13, 0xfe, 0x20, 0x80, 0x07, 0x19, 0xfe, 0x7c,
-	0x12, 0x53, 0x05, 0x06, 0xfe, 0x6c, 0x13, 0x03, 0xfe, 0xa2, 0x00, 0x28,
-	0x17, 0xfe, 0x90, 0x05, 0xfe, 0x31, 0xe4, 0x5a, 0x53, 0x05, 0x0a, 0xfe,
-	0x56, 0x13, 0x03, 0xfe, 0xa0, 0x00, 0x28, 0xfe, 0x4e, 0x12, 0x67, 0xff,
-	0x02, 0x00, 0x10, 0x27, 0xfe, 0x48, 0x05, 0x1c, 0x34, 0xfe, 0x89, 0x48,
-	0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x56, 0x05, 0x26, 0xfe, 0xa8, 0x05,
-	0x12, 0xfe, 0xe3, 0x00, 0x21, 0x53, 0xfe, 0x4a, 0xf0, 0xfe, 0x76, 0x05,
-	0xfe, 0x49, 0xf0, 0xfe, 0x70, 0x05, 0x88, 0x25, 0xfe, 0x21, 0x00, 0xab,
-	0x25, 0xfe, 0x22, 0x00, 0xaa, 0x25, 0x58, 0xfe, 0x09, 0x48, 0xff, 0x02,
-	0x00, 0x10, 0x27, 0xfe, 0x86, 0x05, 0x26, 0xfe, 0xa8, 0x05, 0xfe, 0xe2,
-	0x08, 0x53, 0x05, 0xcb, 0x4d, 0x01, 0xb0, 0x25, 0x06, 0x13, 0xd3, 0x39,
-	0xfe, 0x27, 0x01, 0x08, 0x05, 0x1b, 0xfe, 0x22, 0x12, 0x41, 0x01, 0xb2,
-	0x15, 0x9d, 0x08, 0x05, 0x06, 0x4d, 0x15, 0xfe, 0x0d, 0x00, 0x01, 0x36,
-	0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24, 0x03, 0xfe, 0x9c, 0x00, 0x28, 0xeb,
-	0x03, 0x5c, 0x28, 0xfe, 0x36, 0x13, 0x41, 0x01, 0xb2, 0x26, 0xfe, 0x18,
-	0x06, 0x09, 0x06, 0x53, 0x05, 0x1f, 0xfe, 0x02, 0x12, 0x50, 0x01, 0xfe,
-	0x9e, 0x15, 0x1d, 0xfe, 0x0e, 0x06, 0x12, 0xa5, 0x01, 0x4b, 0x12, 0xfe,
-	0xe5, 0x00, 0x03, 0x5c, 0xc1, 0x0c, 0x5c, 0x03, 0xcd, 0x28, 0xfe, 0x62,
-	0x12, 0x03, 0x45, 0x28, 0xfe, 0x5a, 0x13, 0x01, 0xfe, 0x0c, 0x19, 0x01,
-	0xfe, 0x76, 0x19, 0xfe, 0x43, 0x48, 0xc4, 0xcc, 0x0f, 0x71, 0xff, 0x02,
-	0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0x8b, 0xc4, 0x6e, 0x41, 0x01, 0xb2,
-	0x26, 0xfe, 0x82, 0x06, 0x53, 0x05, 0x1a, 0xe9, 0x91, 0x09, 0x59, 0x01,
-	0xfe, 0xcc, 0x15, 0x1d, 0xfe, 0x78, 0x06, 0x12, 0xa5, 0x01, 0x4b, 0x12,
-	0xfe, 0xe5, 0x00, 0x03, 0x45, 0xc1, 0x0c, 0x45, 0x18, 0x06, 0x01, 0xb2,
-	0xfa, 0x76, 0x74, 0x01, 0xaf, 0x8c, 0x12, 0xfe, 0xe2, 0x00, 0x27, 0xdb,
-	0x1c, 0x34, 0xfe, 0x0a, 0xf0, 0xfe, 0xb6, 0x06, 0x94, 0xfe, 0x6c, 0x07,
-	0xfe, 0x06, 0xf0, 0xfe, 0x74, 0x07, 0x95, 0x86, 0x02, 0x24, 0x08, 0x05,
-	0x0a, 0xfe, 0x2e, 0x12, 0x16, 0x19, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b,
-	0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b, 0xfe, 0x99, 0xa4, 0x01,
-	0x0b, 0x16, 0x00, 0x02, 0xfe, 0x42, 0x08, 0x68, 0x05, 0x1a, 0xfe, 0x38,
-	0x12, 0x08, 0x05, 0x1a, 0xfe, 0x30, 0x13, 0x16, 0xfe, 0x1b, 0x00, 0x01,
-	0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01,
-	0x0b, 0x16, 0x06, 0x01, 0x0b, 0x16, 0x00, 0x02, 0xe2, 0x6c, 0x58, 0xbe,
-	0x50, 0xfe, 0x9a, 0x81, 0x55, 0x1b, 0x7a, 0xfe, 0x42, 0x07, 0x09, 0x1b,
-	0xfe, 0x09, 0x6f, 0xba, 0xfe, 0xca, 0x45, 0xfe, 0x32, 0x12, 0x69, 0x6d,
-	0x8b, 0x6c, 0x7f, 0x27, 0xfe, 0x54, 0x07, 0x1c, 0x34, 0xfe, 0x0a, 0xf0,
-	0xfe, 0x42, 0x07, 0x95, 0x86, 0x94, 0xfe, 0x6c, 0x07, 0x02, 0x24, 0x01,
-	0x4b, 0x02, 0xdb, 0x16, 0x1f, 0x02, 0xdb, 0xfe, 0x9c, 0xf7, 0xdc, 0xfe,
-	0x2c, 0x90, 0xfe, 0xae, 0x90, 0x56, 0xfe, 0xda, 0x07, 0x0c, 0x60, 0x14,
-	0x61, 0x08, 0x54, 0x5a, 0x37, 0x22, 0x20, 0x07, 0x11, 0xfe, 0x0e, 0x12,
-	0x8d, 0xfe, 0x80, 0x80, 0x39, 0x20, 0x6a, 0x2a, 0xfe, 0x06, 0x10, 0xfe,
-	0x83, 0xe7, 0xfe, 0x48, 0x00, 0xab, 0xfe, 0x03, 0x40, 0x08, 0x54, 0x5b,
-	0x37, 0x01, 0xb3, 0xb8, 0xfe, 0x1f, 0x40, 0x13, 0x62, 0x01, 0xef, 0xfe,
-	0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe, 0x44, 0x51, 0xfe, 0xc6, 0x51, 0x88,
-	0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90, 0x0c, 0x5e, 0x14, 0x5f, 0xfe, 0x0c,
-	0x90, 0xfe, 0x8e, 0x90, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x0c, 0x3d,
-	0x14, 0x3e, 0xfe, 0x4a, 0x10, 0x08, 0x05, 0x5a, 0xfe, 0x2a, 0x12, 0xfe,
-	0x2c, 0x90, 0xfe, 0xae, 0x90, 0x0c, 0x60, 0x14, 0x61, 0x08, 0x05, 0x5b,
-	0x8b, 0x01, 0xb3, 0xfe, 0x1f, 0x80, 0x13, 0x62, 0xfe, 0x44, 0x90, 0xfe,
-	0xc6, 0x90, 0x0c, 0x3f, 0x14, 0x40, 0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90,
-	0x0c, 0x5e, 0x14, 0x5f, 0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90, 0x0c, 0x3d,
-	0x14, 0x3e, 0x0c, 0x2e, 0x14, 0x3c, 0x21, 0x0c, 0x49, 0x0c, 0x63, 0x08,
-	0x54, 0x1f, 0x37, 0x2c, 0x0f, 0xfe, 0x4e, 0x11, 0x27, 0xdd, 0xfe, 0x9e,
-	0xf0, 0xfe, 0x76, 0x08, 0xbc, 0x17, 0x34, 0x2c, 0x77, 0xe6, 0xc5, 0xfe,
-	0x9a, 0x08, 0xc6, 0xfe, 0xb8, 0x08, 0x94, 0xfe, 0x8e, 0x08, 0xfe, 0x06,
-	0xf0, 0xfe, 0x94, 0x08, 0x95, 0x86, 0x02, 0x24, 0x01, 0x4b, 0xfe, 0xc9,
-	0x10, 0x16, 0x1f, 0xfe, 0xc9, 0x10, 0x68, 0x05, 0x06, 0xfe, 0x10, 0x12,
-	0x68, 0x05, 0x0a, 0x4e, 0x08, 0x05, 0x0a, 0xfe, 0x90, 0x12, 0xfe, 0x2e,
-	0x1c, 0x02, 0xfe, 0x18, 0x0b, 0x68, 0x05, 0x06, 0x4e, 0x68, 0x05, 0x0a,
-	0xfe, 0x7a, 0x12, 0xfe, 0x2c, 0x1c, 0xfe, 0xaa, 0xf0, 0xfe, 0xd2, 0x09,
-	0xfe, 0xac, 0xf0, 0xfe, 0x00, 0x09, 0x02, 0xfe, 0xde, 0x09, 0xfe, 0xb7,
-	0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0x02, 0xf6, 0x1a, 0x50, 0xfe, 0x70, 0x18,
-	0xfe, 0xf1, 0x18, 0xfe, 0x40, 0x55, 0xfe, 0xe1, 0x55, 0xfe, 0x10, 0x58,
-	0xfe, 0x91, 0x58, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x1c, 0x85, 0xfe,
-	0x8c, 0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0xac, 0xf0, 0xfe, 0xf0, 0x08, 0xb5,
-	0xfe, 0xcb, 0x10, 0xfe, 0xad, 0xf0, 0xfe, 0x0c, 0x09, 0x02, 0xfe, 0x18,
-	0x0b, 0xb6, 0xfe, 0xbf, 0x10, 0xfe, 0x2b, 0xf0, 0x85, 0xf4, 0x1e, 0xfe,
-	0x00, 0xfe, 0xfe, 0x1c, 0x12, 0xc2, 0xfe, 0xd2, 0xf0, 0x85, 0xfe, 0x76,
-	0x18, 0x1e, 0x19, 0x17, 0x85, 0x03, 0xd2, 0x1e, 0x06, 0x17, 0x85, 0xc5,
-	0x4a, 0xc6, 0x4a, 0xb5, 0xb6, 0xfe, 0x89, 0x10, 0x74, 0x67, 0x2d, 0x15,
-	0x9d, 0x01, 0x36, 0x10, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x65, 0x10,
-	0x80, 0x02, 0x65, 0xfe, 0x98, 0x80, 0xfe, 0x19, 0xe4, 0x0a, 0xfe, 0x1a,
-	0x12, 0x51, 0xfe, 0x19, 0x82, 0xfe, 0x6c, 0x18, 0xfe, 0x44, 0x54, 0xbe,
-	0xfe, 0x19, 0x81, 0xfe, 0x74, 0x18, 0x8f, 0x90, 0x17, 0xfe, 0xce, 0x08,
-	0x02, 0x4a, 0x08, 0x05, 0x5a, 0xec, 0x03, 0x2e, 0x29, 0x3c, 0x0c, 0x3f,
-	0x14, 0x40, 0x9b, 0x2e, 0x9c, 0x3c, 0xfe, 0x6c, 0x18, 0xfe, 0xed, 0x18,
-	0xfe, 0x44, 0x54, 0xfe, 0xe5, 0x54, 0x3a, 0x3f, 0x3b, 0x40, 0x03, 0x49,
-	0x29, 0x63, 0x8f, 0xfe, 0xe3, 0x54, 0xfe, 0x74, 0x18, 0xfe, 0xf5, 0x18,
-	0x8f, 0xfe, 0xe3, 0x54, 0x90, 0xc0, 0x56, 0xfe, 0xce, 0x08, 0x02, 0x4a,
-	0xfe, 0x37, 0xf0, 0xfe, 0xda, 0x09, 0xfe, 0x8b, 0xf0, 0xfe, 0x60, 0x09,
-	0x02, 0x4a, 0x08, 0x05, 0x0a, 0x23, 0xfe, 0xfa, 0x0a, 0x3a, 0x49, 0x3b,
-	0x63, 0x56, 0xfe, 0x3e, 0x0a, 0x0f, 0xfe, 0xc0, 0x07, 0x41, 0x98, 0x00,
-	0xad, 0xfe, 0x01, 0x59, 0xfe, 0x52, 0xf0, 0xfe, 0x0c, 0x0a, 0x8f, 0x7a,
-	0xfe, 0x24, 0x0a, 0x3a, 0x49, 0x8f, 0xfe, 0xe3, 0x54, 0x57, 0x49, 0x7d,
-	0x63, 0xfe, 0x14, 0x58, 0xfe, 0x95, 0x58, 0x02, 0x4a, 0x3a, 0x49, 0x3b,
-	0x63, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0xbe, 0x57, 0x49, 0x57, 0x63,
-	0x02, 0x4a, 0x08, 0x05, 0x5a, 0xfe, 0x82, 0x12, 0x08, 0x05, 0x1f, 0xfe,
-	0x66, 0x13, 0x22, 0x62, 0xb7, 0xfe, 0x03, 0xa1, 0xfe, 0x83, 0x80, 0xfe,
-	0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91, 0xfe, 0x86, 0x91, 0x6a,
-	0x2a, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x56, 0xe0, 0x03, 0x60, 0x29,
-	0x61, 0x0c, 0x7f, 0x14, 0x80, 0x57, 0x60, 0x7d, 0x61, 0x01, 0xb3, 0xb8,
-	0x6a, 0x2a, 0x13, 0x62, 0x9b, 0x2e, 0x9c, 0x3c, 0x3a, 0x3f, 0x3b, 0x40,
-	0x90, 0xc0, 0xfe, 0x04, 0xfa, 0x2e, 0xfe, 0x05, 0xfa, 0x3c, 0x01, 0xef,
-	0xfe, 0x36, 0x10, 0x21, 0x0c, 0x7f, 0x0c, 0x80, 0x3a, 0x3f, 0x3b, 0x40,
-	0xe4, 0x08, 0x05, 0x1f, 0x17, 0xe0, 0x3a, 0x3d, 0x3b, 0x3e, 0x08, 0x05,
-	0xfe, 0xf7, 0x00, 0x37, 0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x10, 0x58, 0xfe,
-	0x91, 0x58, 0x57, 0x49, 0x7d, 0x63, 0x02, 0xfe, 0xf4, 0x09, 0x08, 0x05,
-	0x1f, 0x17, 0xe0, 0x08, 0x05, 0xfe, 0xf7, 0x00, 0x37, 0xbe, 0xfe, 0x19,
-	0x81, 0x50, 0xfe, 0x10, 0x90, 0xfe, 0x92, 0x90, 0xfe, 0xd3, 0x10, 0x32,
-	0x07, 0xa6, 0x17, 0xfe, 0x08, 0x09, 0x12, 0xa6, 0x08, 0x05, 0x0a, 0xfe,
-	0x14, 0x13, 0x03, 0x3d, 0x29, 0x3e, 0x56, 0xfe, 0x08, 0x09, 0xfe, 0x0c,
-	0x58, 0xfe, 0x8d, 0x58, 0x02, 0x4a, 0x21, 0x41, 0xfe, 0x19, 0x80, 0xe7,
-	0x08, 0x05, 0x0a, 0xfe, 0x1a, 0x12, 0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41,
-	0xf4, 0xc2, 0xfe, 0xd1, 0xf0, 0xe2, 0x15, 0x7e, 0x01, 0x36, 0x10, 0xfe,
-	0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe, 0x6c, 0x19, 0x57, 0x3d, 0xfe, 0xed,
-	0x19, 0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0xf4, 0x1e, 0xfe,
-	0x00, 0xff, 0x35, 0xfe, 0x74, 0x10, 0xc2, 0xfe, 0xd2, 0xf0, 0xfe, 0xa6,
-	0x0b, 0xfe, 0x76, 0x18, 0x1e, 0x19, 0x8a, 0x03, 0xd2, 0x1e, 0x06, 0xfe,
-	0x08, 0x13, 0x10, 0xfe, 0x16, 0x00, 0x02, 0x65, 0xfe, 0xd1, 0xf0, 0xfe,
-	0xb8, 0x0b, 0x15, 0x7e, 0x01, 0x36, 0x10, 0xfe, 0x17, 0x00, 0xfe, 0x42,
-	0x10, 0xfe, 0xce, 0xf0, 0xfe, 0xbe, 0x0b, 0xfe, 0x3c, 0x10, 0xfe, 0xcd,
-	0xf0, 0xfe, 0xca, 0x0b, 0x10, 0xfe, 0x22, 0x00, 0x02, 0x65, 0xfe, 0xcb,
-	0xf0, 0xfe, 0xd6, 0x0b, 0x10, 0xfe, 0x24, 0x00, 0x02, 0x65, 0xfe, 0xd0,
-	0xf0, 0xfe, 0xe0, 0x0b, 0x10, 0x9e, 0xe5, 0xfe, 0xcf, 0xf0, 0xfe, 0xea,
-	0x0b, 0x10, 0x58, 0xfe, 0x10, 0x10, 0xfe, 0xcc, 0xf0, 0xe2, 0x68, 0x05,
-	0x1f, 0x4d, 0x10, 0xfe, 0x12, 0x00, 0x2c, 0x0f, 0xfe, 0x4e, 0x11, 0x27,
-	0xfe, 0x00, 0x0c, 0xfe, 0x9e, 0xf0, 0xfe, 0x14, 0x0c, 0xbc, 0x17, 0x34,
-	0x2c, 0x77, 0xe6, 0xc5, 0x24, 0xc6, 0x24, 0x2c, 0xfa, 0x27, 0xfe, 0x20,
-	0x0c, 0x1c, 0x34, 0x94, 0xfe, 0x3c, 0x0c, 0x95, 0x86, 0xc5, 0xdc, 0xc6,
-	0xdc, 0x02, 0x24, 0x01, 0x4b, 0xfe, 0xdb, 0x10, 0x12, 0xfe, 0xe8, 0x00,
-	0xb5, 0xb6, 0x74, 0xc7, 0x81, 0xc8, 0x83, 0xfe, 0x89, 0xf0, 0x24, 0x33,
-	0x31, 0xe1, 0xc7, 0x81, 0xc8, 0x83, 0x27, 0xfe, 0x66, 0x0c, 0x1d, 0x24,
-	0x33, 0x31, 0xdf, 0xbc, 0x4e, 0x10, 0xfe, 0x42, 0x00, 0x02, 0x65, 0x7c,
-	0x06, 0xfe, 0x81, 0x49, 0x17, 0xfe, 0x2c, 0x0d, 0x08, 0x05, 0x0a, 0xfe,
-	0x44, 0x13, 0x10, 0x00, 0x55, 0x0a, 0xfe, 0x54, 0x12, 0x55, 0xfe, 0x28,
-	0x00, 0x23, 0xfe, 0x9a, 0x0d, 0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x66,
-	0x44, 0xfe, 0x28, 0x00, 0xfe, 0xe2, 0x10, 0x01, 0xf5, 0x01, 0xf6, 0x09,
-	0xa4, 0x01, 0xfe, 0x26, 0x0f, 0x64, 0x12, 0x2f, 0x01, 0x73, 0x02, 0x2b,
-	0x10, 0xfe, 0x44, 0x00, 0x55, 0x0a, 0xe9, 0x44, 0x0a, 0xfe, 0xb4, 0x10,
-	0x01, 0xb0, 0x44, 0x0a, 0xfe, 0xaa, 0x10, 0x01, 0xb0, 0xfe, 0x19, 0x82,
-	0xfe, 0x34, 0x46, 0xac, 0x44, 0x0a, 0x10, 0xfe, 0x43, 0x00, 0xfe, 0x96,
-	0x10, 0x08, 0x54, 0x0a, 0x37, 0x01, 0xf5, 0x01, 0xf6, 0x64, 0x12, 0x2f,
-	0x01, 0x73, 0x99, 0x0a, 0x64, 0x42, 0x92, 0x02, 0xfe, 0x2e, 0x03, 0x08,
-	0x05, 0x0a, 0x8a, 0x44, 0x0a, 0x10, 0x00, 0xfe, 0x5c, 0x10, 0x68, 0x05,
-	0x1a, 0xfe, 0x58, 0x12, 0x08, 0x05, 0x1a, 0xfe, 0x50, 0x13, 0xfe, 0x1c,
-	0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x50, 0x0d, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d,
-	0xf0, 0xfe, 0x56, 0x0d, 0x08, 0x54, 0x1a, 0x37, 0xfe, 0xa9, 0x10, 0x10,
-	0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0a, 0x50, 0xfe, 0x2e, 0x10, 0x10,
-	0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x10, 0x6f, 0xab, 0x10, 0xfe, 0x41,
-	0x00, 0xaa, 0x10, 0xfe, 0x24, 0x00, 0x8c, 0xb5, 0xb6, 0x74, 0x03, 0x70,
-	0x28, 0x23, 0xd8, 0x50, 0xfe, 0x04, 0xe6, 0x1a, 0xfe, 0x9d, 0x41, 0xfe,
-	0x1c, 0x42, 0x64, 0x01, 0xe3, 0x02, 0x2b, 0xf8, 0x15, 0x0a, 0x39, 0xa0,
-	0xb4, 0x15, 0xfe, 0x31, 0x00, 0x39, 0xa2, 0x01, 0xfe, 0x48, 0x10, 0x02,
-	0xd7, 0x42, 0xfe, 0x06, 0xec, 0xd0, 0xfc, 0x44, 0x1b, 0xfe, 0xce, 0x45,
-	0x35, 0x42, 0xfe, 0x06, 0xea, 0xd0, 0xfe, 0x47, 0x4b, 0x91, 0xfe, 0x75,
-	0x57, 0x03, 0x5d, 0xfe, 0x98, 0x56, 0xfe, 0x38, 0x12, 0x09, 0x48, 0x01,
-	0x0e, 0xfe, 0x44, 0x48, 0x4f, 0x08, 0x05, 0x1b, 0xfe, 0x1a, 0x13, 0x09,
-	0x46, 0x01, 0x0e, 0x41, 0xfe, 0x41, 0x58, 0x09, 0xa4, 0x01, 0x0e, 0xfe,
-	0x49, 0x54, 0x96, 0xfe, 0x1e, 0x0e, 0x02, 0xfe, 0x2e, 0x03, 0x09, 0x5d,
-	0xfe, 0xee, 0x14, 0xfc, 0x44, 0x1b, 0xfe, 0xce, 0x45, 0x35, 0x42, 0xfe,
-	0xce, 0x47, 0xfe, 0xad, 0x13, 0x02, 0x2b, 0x22, 0x20, 0x07, 0x11, 0xfe,
-	0x9e, 0x12, 0x21, 0x13, 0x59, 0x13, 0x9f, 0x13, 0xd5, 0x22, 0x2f, 0x41,
-	0x39, 0x2f, 0xbc, 0xad, 0xfe, 0xbc, 0xf0, 0xfe, 0xe0, 0x0e, 0x0f, 0x06,
-	0x13, 0x59, 0x01, 0xfe, 0xda, 0x16, 0x03, 0xfe, 0x38, 0x01, 0x29, 0xfe,
-	0x3a, 0x01, 0x56, 0xfe, 0xe4, 0x0e, 0xfe, 0x02, 0xec, 0xd5, 0x69, 0x00,
-	0x66, 0xfe, 0x04, 0xec, 0x20, 0x4f, 0xfe, 0x05, 0xf6, 0xfe, 0x34, 0x01,
-	0x01, 0xfe, 0x4a, 0x17, 0xfe, 0x08, 0x90, 0xfe, 0x48, 0xf4, 0x0d, 0xfe,
-	0x18, 0x13, 0xba, 0xfe, 0x02, 0xea, 0xd5, 0x69, 0x7e, 0xfe, 0xc5, 0x13,
-	0x15, 0x1a, 0x39, 0xa0, 0xb4, 0xfe, 0x2e, 0x10, 0x03, 0xfe, 0x38, 0x01,
-	0x1e, 0xfe, 0xf0, 0xff, 0x0c, 0xfe, 0x60, 0x01, 0x03, 0xfe, 0x3a, 0x01,
-	0x0c, 0xfe, 0x62, 0x01, 0x43, 0x13, 0x20, 0x25, 0x06, 0x13, 0x2f, 0x12,
-	0x2f, 0x92, 0x0f, 0x06, 0x04, 0x21, 0x04, 0x22, 0x59, 0xfe, 0xf7, 0x12,
-	0x22, 0x9f, 0xb7, 0x13, 0x9f, 0x07, 0x7e, 0xfe, 0x71, 0x13, 0xfe, 0x24,
-	0x1c, 0x15, 0x19, 0x39, 0xa0, 0xb4, 0xfe, 0xd9, 0x10, 0xc3, 0xfe, 0x03,
-	0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x04, 0xc3, 0xfe, 0x03, 0xdc,
-	0xfe, 0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x04, 0xfe, 0x03, 0x57, 0xc3, 0x21,
-	0xfe, 0x00, 0xcc, 0x04, 0xfe, 0x03, 0x57, 0xc3, 0x78, 0x04, 0x08, 0x05,
-	0x58, 0xfe, 0x22, 0x13, 0xfe, 0x1c, 0x80, 0x07, 0x06, 0xfe, 0x1a, 0x13,
-	0xfe, 0x1e, 0x80, 0xed, 0xfe, 0x1d, 0x80, 0xae, 0xfe, 0x0c, 0x90, 0xfe,
-	0x0e, 0x13, 0xfe, 0x0e, 0x90, 0xac, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4,
-	0x0a, 0xfe, 0x3c, 0x50, 0xaa, 0x01, 0xfe, 0x7a, 0x17, 0x32, 0x07, 0x2f,
-	0xad, 0x01, 0xfe, 0xb4, 0x16, 0x08, 0x05, 0x1b, 0x4e, 0x01, 0xf5, 0x01,
-	0xf6, 0x12, 0xfe, 0xe9, 0x00, 0x08, 0x05, 0x58, 0xfe, 0x2c, 0x13, 0x01,
-	0xfe, 0x0c, 0x17, 0xfe, 0x1e, 0x1c, 0xfe, 0x14, 0x90, 0xfe, 0x96, 0x90,
-	0x0c, 0xfe, 0x64, 0x01, 0x14, 0xfe, 0x66, 0x01, 0x08, 0x05, 0x5b, 0xfe,
-	0x12, 0x12, 0xfe, 0x03, 0x80, 0x8d, 0xfe, 0x01, 0xec, 0x20, 0xfe, 0x80,
-	0x40, 0x13, 0x20, 0x6a, 0x2a, 0x12, 0xcf, 0x64, 0x22, 0x20, 0xfb, 0x79,
-	0x20, 0x04, 0xfe, 0x08, 0x1c, 0x03, 0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58,
-	0x03, 0xfe, 0xae, 0x00, 0xfe, 0x07, 0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe,
-	0x08, 0x58, 0x03, 0xfe, 0xb2, 0x00, 0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c,
-	0x25, 0x6e, 0x13, 0xd0, 0x21, 0x0c, 0x5c, 0x0c, 0x45, 0x0f, 0x46, 0x52,
-	0x50, 0x18, 0x1b, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x23, 0xfe, 0xfc,
-	0x0f, 0x44, 0x11, 0x0f, 0x48, 0x52, 0x18, 0x58, 0xfe, 0x90, 0x4d, 0xfe,
-	0x91, 0x54, 0x23, 0xe4, 0x25, 0x11, 0x13, 0x20, 0x7c, 0x6f, 0x4f, 0x22,
-	0x20, 0xfb, 0x79, 0x20, 0x12, 0xcf, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0,
-	0xfe, 0x26, 0x10, 0xf8, 0x74, 0xfe, 0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe,
-	0x18, 0x1c, 0x04, 0x42, 0xfe, 0x0c, 0x14, 0xfc, 0xfe, 0x07, 0xe6, 0x1b,
-	0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x04, 0x01, 0xb0, 0x7c, 0x6f, 0x4f,
-	0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42, 0x13, 0x32, 0x07, 0x2f,
-	0xfe, 0x34, 0x13, 0x09, 0x48, 0x01, 0x0e, 0xbb, 0xfe, 0x36, 0x12, 0xfe,
-	0x41, 0x48, 0xfe, 0x45, 0x48, 0x01, 0xf0, 0xfe, 0x00, 0xcc, 0xbb, 0xfe,
-	0xf3, 0x13, 0x43, 0x78, 0x07, 0x11, 0xac, 0x09, 0x84, 0x01, 0x0e, 0xfe,
-	0x80, 0x5c, 0x01, 0x73, 0xfe, 0x0e, 0x10, 0x07, 0x82, 0x4e, 0xfe, 0x14,
-	0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x60, 0x10, 0x04, 0xfe, 0x44, 0x58, 0x8d,
-	0xfe, 0x01, 0xec, 0xa2, 0xfe, 0x9e, 0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe,
-	0x9c, 0xe7, 0x1a, 0x79, 0x2a, 0x01, 0xe3, 0xfe, 0xdd, 0x10, 0x2c, 0xc7,
-	0x81, 0xc8, 0x83, 0x33, 0x31, 0xde, 0x07, 0x1a, 0xfe, 0x48, 0x12, 0x07,
-	0x0a, 0xfe, 0x56, 0x12, 0x07, 0x19, 0xfe, 0x30, 0x12, 0x07, 0xc9, 0x17,
-	0xfe, 0x32, 0x12, 0x07, 0xfe, 0x23, 0x00, 0x17, 0xeb, 0x07, 0x06, 0x17,
-	0xfe, 0x9c, 0x12, 0x07, 0x1f, 0xfe, 0x12, 0x12, 0x07, 0x00, 0x17, 0x24,
-	0x15, 0xc9, 0x01, 0x36, 0xa9, 0x2d, 0x01, 0x0b, 0x94, 0x4b, 0x04, 0x2d,
-	0xdd, 0x09, 0xd1, 0x01, 0xfe, 0x26, 0x0f, 0x12, 0x82, 0x02, 0x2b, 0x2d,
-	0x32, 0x07, 0xa6, 0xfe, 0xd9, 0x13, 0x3a, 0x3d, 0x3b, 0x3e, 0x56, 0xfe,
-	0xf0, 0x11, 0x08, 0x05, 0x5a, 0xfe, 0x72, 0x12, 0x9b, 0x2e, 0x9c, 0x3c,
-	0x90, 0xc0, 0x96, 0xfe, 0xba, 0x11, 0x22, 0x62, 0xfe, 0x26, 0x13, 0x03,
-	0x7f, 0x29, 0x80, 0x56, 0xfe, 0x76, 0x0d, 0x0c, 0x60, 0x14, 0x61, 0x21,
-	0x0c, 0x7f, 0x0c, 0x80, 0x01, 0xb3, 0x25, 0x6e, 0x77, 0x13, 0x62, 0x01,
-	0xef, 0x9b, 0x2e, 0x9c, 0x3c, 0xfe, 0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe,
-	0x04, 0xfa, 0x2e, 0xfe, 0x05, 0xfa, 0x3c, 0xfe, 0x91, 0x10, 0x03, 0x3f,
-	0x29, 0x40, 0xfe, 0x40, 0x56, 0xfe, 0xe1, 0x56, 0x0c, 0x3f, 0x14, 0x40,
-	0x88, 0x9b, 0x2e, 0x9c, 0x3c, 0x90, 0xc0, 0x03, 0x5e, 0x29, 0x5f, 0xfe,
-	0x00, 0x56, 0xfe, 0xa1, 0x56, 0x0c, 0x5e, 0x14, 0x5f, 0x08, 0x05, 0x5a,
-	0xfe, 0x1e, 0x12, 0x22, 0x62, 0xfe, 0x1f, 0x40, 0x03, 0x60, 0x29, 0x61,
-	0xfe, 0x2c, 0x50, 0xfe, 0xae, 0x50, 0x03, 0x3f, 0x29, 0x40, 0xfe, 0x44,
-	0x50, 0xfe, 0xc6, 0x50, 0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x08, 0x50, 0xfe,
-	0x8a, 0x50, 0x03, 0x3d, 0x29, 0x3e, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50,
-	0x02, 0x89, 0x25, 0x06, 0x13, 0xd4, 0x02, 0x72, 0x2d, 0x01, 0x0b, 0x1d,
-	0x4c, 0x33, 0x31, 0xde, 0x07, 0x06, 0x23, 0x4c, 0x32, 0x07, 0xa6, 0x23,
-	0x72, 0x01, 0xaf, 0x1e, 0x43, 0x17, 0x4c, 0x08, 0x05, 0x0a, 0xee, 0x3a,
-	0x3d, 0x3b, 0x3e, 0xfe, 0x0a, 0x55, 0x35, 0xfe, 0x8b, 0x55, 0x57, 0x3d,
-	0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0x02, 0x72, 0xfe, 0x19,
-	0x81, 0xba, 0xfe, 0x19, 0x41, 0x02, 0x72, 0x2d, 0x01, 0x0b, 0x1c, 0x34,
-	0x1d, 0xe8, 0x33, 0x31, 0xe1, 0x55, 0x19, 0xfe, 0xa6, 0x12, 0x55, 0x0a,
-	0x4d, 0x02, 0x4c, 0x01, 0x0b, 0x1c, 0x34, 0x1d, 0xe8, 0x33, 0x31, 0xdf,
-	0x07, 0x19, 0x23, 0x4c, 0x01, 0x0b, 0x1d, 0xe8, 0x33, 0x31, 0xfe, 0xe8,
-	0x09, 0xfe, 0xc2, 0x49, 0x51, 0x03, 0xfe, 0x9c, 0x00, 0x28, 0x8a, 0x53,
-	0x05, 0x1f, 0x35, 0xa9, 0xfe, 0xbb, 0x45, 0x55, 0x00, 0x4e, 0x44, 0x06,
-	0x7c, 0x43, 0xfe, 0xda, 0x14, 0x01, 0xaf, 0x8c, 0xfe, 0x4b, 0x45, 0xee,
-	0x32, 0x07, 0xa5, 0xed, 0x03, 0xcd, 0x28, 0x8a, 0x03, 0x45, 0x28, 0x35,
-	0x67, 0x02, 0x72, 0xfe, 0xc0, 0x5d, 0xfe, 0xf8, 0x14, 0xfe, 0x03, 0x17,
-	0x03, 0x5c, 0xc1, 0x0c, 0x5c, 0x67, 0x2d, 0x01, 0x0b, 0x26, 0x89, 0x01,
-	0xfe, 0x9e, 0x15, 0x02, 0x89, 0x01, 0x0b, 0x1c, 0x34, 0x1d, 0x4c, 0x33,
-	0x31, 0xdf, 0x07, 0x06, 0x23, 0x4c, 0x01, 0xf1, 0xfe, 0x42, 0x58, 0xf1,
-	0xfe, 0xa4, 0x14, 0x8c, 0xfe, 0x4a, 0xf4, 0x0a, 0x17, 0x4c, 0xfe, 0x4a,
-	0xf4, 0x06, 0xea, 0x32, 0x07, 0xa5, 0x8b, 0x02, 0x72, 0x03, 0x45, 0xc1,
-	0x0c, 0x45, 0x67, 0x2d, 0x01, 0x0b, 0x26, 0x89, 0x01, 0xfe, 0xcc, 0x15,
-	0x02, 0x89, 0x0f, 0x06, 0x27, 0xfe, 0xbe, 0x13, 0x26, 0xfe, 0xd4, 0x13,
-	0x76, 0xfe, 0x89, 0x48, 0x01, 0x0b, 0x21, 0x76, 0x04, 0x7b, 0xfe, 0xd0,
-	0x13, 0x1c, 0xfe, 0xd0, 0x13, 0x1d, 0xfe, 0xbe, 0x13, 0x67, 0x2d, 0x01,
-	0x0b, 0xfe, 0xd5, 0x10, 0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93,
-	0x1e, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x04, 0x0f,
-	0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0xfe, 0x30, 0x56,
-	0xfe, 0x00, 0x5c, 0x04, 0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93,
-	0x04, 0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0xfe, 0x0b, 0x58,
-	0x04, 0x09, 0x5c, 0x01, 0x87, 0x09, 0x45, 0x01, 0x87, 0x04, 0xfe, 0x03,
-	0xa1, 0x1e, 0x11, 0xff, 0x03, 0x00, 0x54, 0xfe, 0x00, 0xf4, 0x1f, 0x52,
-	0xfe, 0x00, 0x7d, 0xfe, 0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe, 0x03, 0x7c,
-	0x6a, 0x2a, 0x0c, 0x5e, 0x14, 0x5f, 0x57, 0x3f, 0x7d, 0x40, 0x04, 0xdd,
-	0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x8d, 0x04, 0x01,
-	0xfe, 0x0c, 0x19, 0xfe, 0x42, 0x48, 0x50, 0x51, 0x91, 0x01, 0x0b, 0x1d,
-	0xfe, 0x96, 0x15, 0x33, 0x31, 0xe1, 0x01, 0x0b, 0x1d, 0xfe, 0x96, 0x15,
-	0x33, 0x31, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x03, 0xcd, 0x28, 0xfe,
-	0xcc, 0x12, 0x53, 0x05, 0x1a, 0xfe, 0xc4, 0x13, 0x21, 0x69, 0x1a, 0xee,
-	0x55, 0xca, 0x6b, 0xfe, 0xdc, 0x14, 0x4d, 0x0f, 0x06, 0x18, 0xca, 0x7c,
-	0x30, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xab, 0xff, 0x02, 0x83,
-	0x55, 0x69, 0x19, 0xae, 0x98, 0xfe, 0x30, 0x00, 0x96, 0xf2, 0x18, 0x6d,
-	0x0f, 0x06, 0xfe, 0x56, 0x10, 0x69, 0x0a, 0xed, 0x98, 0xfe, 0x64, 0x00,
-	0x96, 0xf2, 0x09, 0xfe, 0x64, 0x00, 0x18, 0x9e, 0x0f, 0x06, 0xfe, 0x28,
-	0x10, 0x69, 0x06, 0xfe, 0x60, 0x13, 0x98, 0xfe, 0xc8, 0x00, 0x96, 0xf2,
-	0x09, 0xfe, 0xc8, 0x00, 0x18, 0x59, 0x0f, 0x06, 0x88, 0x98, 0xfe, 0x90,
-	0x01, 0x7a, 0xfe, 0x42, 0x15, 0x91, 0xe4, 0xfe, 0x43, 0xf4, 0x9f, 0xfe,
-	0x56, 0xf0, 0xfe, 0x54, 0x15, 0xfe, 0x04, 0xf4, 0x71, 0xfe, 0x43, 0xf4,
-	0x9e, 0xfe, 0xf3, 0x10, 0xfe, 0x40, 0x5c, 0x01, 0xfe, 0x16, 0x14, 0x1e,
-	0x43, 0xec, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x6e, 0x7a, 0xfe, 0x90,
-	0x15, 0xc4, 0x6e, 0xfe, 0x1c, 0x10, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4,
-	0xcc, 0x7a, 0xfe, 0x90, 0x15, 0xc4, 0xcc, 0x88, 0x51, 0x21, 0xfe, 0x4d,
-	0xf4, 0x00, 0xe9, 0x91, 0x0f, 0x06, 0xfe, 0xb4, 0x56, 0xfe, 0xc3, 0x58,
-	0x04, 0x51, 0x0f, 0x0a, 0x04, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xf3, 0x16,
-	0x0a, 0x01, 0x0b, 0x26, 0xf3, 0x16, 0x19, 0x01, 0x0b, 0x26, 0xf3, 0x76,
-	0xfe, 0x89, 0x49, 0x01, 0x0b, 0x04, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1,
-	0x16, 0x19, 0x01, 0x0b, 0x26, 0xb1, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1,
-	0xfe, 0x89, 0x49, 0x01, 0x0b, 0x26, 0xb1, 0x76, 0xfe, 0x89, 0x4a, 0x01,
-	0x0b, 0x04, 0x51, 0x04, 0x22, 0xd3, 0x07, 0x06, 0xfe, 0x48, 0x13, 0xb8,
-	0x13, 0xd3, 0xfe, 0x49, 0xf4, 0x00, 0x4d, 0x76, 0xa9, 0x67, 0xfe, 0x01,
-	0xec, 0xfe, 0x27, 0x01, 0xfe, 0x89, 0x48, 0xff, 0x02, 0x00, 0x10, 0x27,
-	0xfe, 0x2e, 0x16, 0x32, 0x07, 0xfe, 0xe3, 0x00, 0xfe, 0x20, 0x13, 0x1d,
-	0xfe, 0x52, 0x16, 0x21, 0x13, 0xd4, 0x01, 0x4b, 0x22, 0xd4, 0x07, 0x06,
-	0x4e, 0x08, 0x54, 0x06, 0x37, 0x04, 0x09, 0x48, 0x01, 0x0e, 0xfb, 0x8e,
-	0x07, 0x11, 0xae, 0x09, 0x84, 0x01, 0x0e, 0x8e, 0x09, 0x5d, 0x01, 0xa8,
-	0x04, 0x09, 0x84, 0x01, 0x0e, 0x8e, 0xfe, 0x80, 0xe7, 0x11, 0x07, 0x11,
-	0x8a, 0xfe, 0x45, 0x58, 0x01, 0xf0, 0x8e, 0x04, 0x09, 0x48, 0x01, 0x0e,
-	0x8e, 0x09, 0x5d, 0x01, 0xa8, 0x04, 0x09, 0x48, 0x01, 0x0e, 0xfe, 0x80,
-	0x80, 0xfe, 0x80, 0x4c, 0xfe, 0x49, 0xe4, 0x11, 0xae, 0x09, 0x84, 0x01,
-	0x0e, 0xfe, 0x80, 0x4c, 0x09, 0x5d, 0x01, 0x87, 0x04, 0x18, 0x11, 0x75,
-	0x6c, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x24,
-	0x1c, 0xfe, 0x1d, 0xf7, 0x1b, 0x97, 0xfe, 0xee, 0x16, 0x01, 0xfe, 0xf4,
-	0x17, 0xad, 0x9a, 0x1b, 0x6c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x04,
-	0xb9, 0x23, 0xfe, 0xde, 0x16, 0xfe, 0xda, 0x10, 0x18, 0x11, 0x75, 0x03,
-	0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x1f, 0xfe, 0x18, 0x58, 0x03, 0xfe,
-	0x66, 0x01, 0xfe, 0x19, 0x58, 0x9a, 0x1f, 0xfe, 0x3c, 0x90, 0xfe, 0x30,
-	0xf4, 0x06, 0xfe, 0x3c, 0x50, 0x6c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79,
-	0xfe, 0x1c, 0xf7, 0x1f, 0x97, 0xfe, 0x38, 0x17, 0xfe, 0xb6, 0x14, 0x35,
-	0x04, 0xb9, 0x23, 0xfe, 0x10, 0x17, 0xfe, 0x9c, 0x10, 0x18, 0x11, 0x75,
-	0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7,
-	0x2e, 0x97, 0xfe, 0x5a, 0x17, 0xfe, 0x94, 0x14, 0xec, 0x9a, 0x2e, 0x6c,
-	0x1a, 0xfe, 0xaf, 0x19, 0xfe, 0x98, 0xe7, 0x00, 0x04, 0xb9, 0x23, 0xfe,
-	0x4e, 0x17, 0xfe, 0x6c, 0x10, 0x18, 0x11, 0x75, 0xfe, 0x30, 0xbc, 0xfe,
-	0xb2, 0xbc, 0x9a, 0xcb, 0x6c, 0x1a, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7,
-	0xcb, 0x97, 0xfe, 0x92, 0x17, 0xfe, 0x5c, 0x14, 0x35, 0x04, 0xb9, 0x23,
-	0xfe, 0x7e, 0x17, 0xfe, 0x42, 0x10, 0xfe, 0x02, 0xf6, 0x11, 0x75, 0xfe,
-	0x18, 0xfe, 0x60, 0xfe, 0x19, 0xfe, 0x61, 0xfe, 0x03, 0xa1, 0xfe, 0x1d,
-	0xf7, 0x5b, 0x97, 0xfe, 0xb8, 0x17, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13,
-	0x9a, 0x5b, 0x41, 0xfe, 0x83, 0x58, 0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7,
-	0x11, 0xfe, 0x81, 0xe7, 0x11, 0x12, 0xfe, 0xdd, 0x00, 0x6a, 0x2a, 0x04,
-	0x6a, 0x2a, 0xfe, 0x12, 0x45, 0x23, 0xfe, 0xa8, 0x17, 0x15, 0x06, 0x39,
-	0xa0, 0xb4, 0x02, 0x2b, 0xfe, 0x39, 0xf0, 0xfe, 0xfc, 0x17, 0x21, 0x04,
-	0xfe, 0x7e, 0x18, 0x1e, 0x19, 0x66, 0x0f, 0x0d, 0x04, 0x75, 0x03, 0xd2,
-	0x1e, 0x06, 0xfe, 0xef, 0x12, 0xfe, 0xe1, 0x10, 0x7c, 0x6f, 0x4f, 0x32,
-	0x07, 0x2f, 0xfe, 0x3c, 0x13, 0xf1, 0xfe, 0x42, 0x13, 0x42, 0x92, 0x09,
-	0x48, 0x01, 0x0e, 0xbb, 0xeb, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01,
-	0xf0, 0xfe, 0x00, 0xcc, 0xbb, 0xfe, 0xf3, 0x13, 0x43, 0x78, 0x07, 0x11,
-	0xac, 0x09, 0x84, 0x01, 0x0e, 0xfe, 0x80, 0x4c, 0x01, 0x73, 0xfe, 0x16,
-	0x10, 0x07, 0x82, 0x8b, 0xfe, 0x40, 0x14, 0xfe, 0x24, 0x12, 0xfe, 0x14,
-	0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x1c, 0x18, 0x18, 0x0a, 0x04, 0xfe, 0x9c,
-	0xe7, 0x0a, 0x10, 0xfe, 0x15, 0x00, 0x64, 0x79, 0x2a, 0x01, 0xe3, 0x18,
-	0x06, 0x04, 0x42, 0x92, 0x08, 0x54, 0x1b, 0x37, 0x12, 0x2f, 0x01, 0x73,
-	0x18, 0x06, 0x04, 0xfe, 0x38, 0x90, 0xfe, 0xba, 0x90, 0x3a, 0xce, 0x3b,
-	0xcf, 0xfe, 0x48, 0x55, 0x35, 0xfe, 0xc9, 0x55, 0x04, 0x22, 0xa3, 0x77,
-	0x13, 0xa3, 0x04, 0x09, 0xa4, 0x01, 0x0e, 0xfe, 0x41, 0x48, 0x09, 0x46,
-	0x01, 0x0e, 0xfe, 0x49, 0x44, 0x17, 0xfe, 0xe8, 0x18, 0x77, 0x78, 0x04,
-	0x09, 0x48, 0x01, 0x0e, 0x07, 0x11, 0x4e, 0x09, 0x5d, 0x01, 0xa8, 0x09,
-	0x46, 0x01, 0x0e, 0x77, 0x78, 0x04, 0xfe, 0x4e, 0xe4, 0x19, 0x6b, 0xfe,
-	0x1c, 0x19, 0x03, 0xfe, 0x90, 0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10,
-	0xfe, 0x4e, 0xe4, 0xc9, 0x6b, 0xfe, 0x2e, 0x19, 0x03, 0xfe, 0x92, 0x00,
-	0xfe, 0x02, 0xe6, 0x1a, 0xe5, 0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x6b,
-	0xfe, 0x40, 0x19, 0x03, 0xfe, 0x94, 0x00, 0xfe, 0x02, 0xe6, 0x1f, 0xfe,
-	0x08, 0x10, 0x03, 0xfe, 0x96, 0x00, 0xfe, 0x02, 0xe6, 0x6d, 0xfe, 0x4e,
-	0x45, 0xea, 0xba, 0xff, 0x04, 0x68, 0x54, 0xe7, 0x1e, 0x6e, 0xfe, 0x08,
-	0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c, 0xfe, 0x1a, 0xf4, 0xfe, 0x00,
-	0x04, 0xea, 0xfe, 0x48, 0xf4, 0x19, 0x7a, 0xfe, 0x74, 0x19, 0x0f, 0x19,
-	0x04, 0x07, 0x7e, 0xfe, 0x5a, 0xf0, 0xfe, 0x84, 0x19, 0x25, 0xfe, 0x09,
-	0x00, 0xfe, 0x34, 0x10, 0x07, 0x1a, 0xfe, 0x5a, 0xf0, 0xfe, 0x92, 0x19,
-	0x25, 0xca, 0xfe, 0x26, 0x10, 0x07, 0x19, 0x66, 0x25, 0x6d, 0xe5, 0x07,
-	0x0a, 0x66, 0x25, 0x9e, 0xfe, 0x0e, 0x10, 0x07, 0x06, 0x66, 0x25, 0x59,
-	0xa9, 0xb8, 0x04, 0x15, 0xfe, 0x09, 0x00, 0x01, 0x36, 0xfe, 0x04, 0xfe,
-	0x81, 0x03, 0x83, 0xfe, 0x40, 0x5c, 0x04, 0x1c, 0xf7, 0xfe, 0x14, 0xf0,
-	0x0b, 0x27, 0xfe, 0xd6, 0x19, 0x1c, 0xf7, 0x7b, 0xf7, 0xfe, 0x82, 0xf0,
-	0xfe, 0xda, 0x19, 0x04, 0xff, 0xcc, 0x00, 0x00,
-};
-
-static unsigned short _adv_asc38C0800_size = sizeof(_adv_asc38C0800_buf);	/* 0x14E1 */
-static ADV_DCNT _adv_asc38C0800_chksum = 0x050D3FD8UL;	/* Expanded little-endian checksum. */
-
-/* Microcode buffer is kept after initialization for error recovery. */
-static unsigned char _adv_asc38C1600_buf[] = {
-	0x00, 0x00, 0x00, 0xf2, 0x00, 0x16, 0x00, 0xfc, 0x00, 0x10, 0x00, 0xf0,
-	0x18, 0xe4, 0x01, 0x00, 0x04, 0x1e, 0x48, 0xe4, 0x03, 0xf6, 0xf7, 0x13,
-	0x2e, 0x1e, 0x02, 0x00, 0x07, 0x17, 0xc0, 0x5f, 0x00, 0xfa, 0xff, 0xff,
-	0x04, 0x00, 0x00, 0xf6, 0x09, 0xe7, 0x82, 0xe7, 0x85, 0xf0, 0x86, 0xf0,
-	0x4e, 0x10, 0x9e, 0xe7, 0xff, 0x00, 0x55, 0xf0, 0x01, 0xf6, 0x03, 0x00,
-	0x98, 0x57, 0x01, 0xe6, 0x00, 0xea, 0x00, 0xec, 0x01, 0xfa, 0x18, 0xf4,
-	0x08, 0x00, 0xf0, 0x1d, 0x38, 0x54, 0x32, 0xf0, 0x10, 0x00, 0xc2, 0x0e,
-	0x1e, 0xf0, 0xd5, 0xf0, 0xbc, 0x00, 0x4b, 0xe4, 0x00, 0xe6, 0xb1, 0xf0,
-	0xb4, 0x00, 0x02, 0x13, 0x3e, 0x1c, 0xc8, 0x47, 0x3e, 0x00, 0xd8, 0x01,
-	0x06, 0x13, 0x0c, 0x1c, 0x5e, 0x1e, 0x00, 0x57, 0xc8, 0x57, 0x01, 0xfc,
-	0xbc, 0x0e, 0xa2, 0x12, 0xb9, 0x54, 0x00, 0x80, 0x62, 0x0a, 0x5a, 0x12,
-	0xc8, 0x15, 0x3e, 0x1e, 0x18, 0x40, 0xbd, 0x56, 0x03, 0xe6, 0x01, 0xea,
-	0x5c, 0xf0, 0x0f, 0x00, 0x20, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12,
-	0x04, 0x13, 0xbb, 0x55, 0x3c, 0x56, 0x3e, 0x57, 0x03, 0x58, 0x4a, 0xe4,
-	0x40, 0x00, 0xb6, 0x00, 0xbb, 0x00, 0xc0, 0x00, 0x00, 0x01, 0x01, 0x01,
-	0x3e, 0x01, 0x58, 0x0a, 0x44, 0x10, 0x0a, 0x12, 0x4c, 0x1c, 0x4e, 0x1c,
-	0x02, 0x4a, 0x30, 0xe4, 0x05, 0xe6, 0x0c, 0x00, 0x3c, 0x00, 0x80, 0x00,
-	0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01, 0x70, 0x01, 0x72, 0x01,
-	0x74, 0x01, 0x76, 0x01, 0x78, 0x01, 0x7c, 0x01, 0xc6, 0x0e, 0x0c, 0x10,
-	0xac, 0x12, 0xae, 0x12, 0x16, 0x1a, 0x32, 0x1c, 0x6e, 0x1e, 0x02, 0x48,
-	0x3a, 0x55, 0xc9, 0x57, 0x02, 0xee, 0x5b, 0xf0, 0x03, 0xf7, 0x06, 0xf7,
-	0x03, 0xfc, 0x06, 0x00, 0x1e, 0x00, 0xbe, 0x00, 0xe1, 0x00, 0x0c, 0x12,
-	0x18, 0x1a, 0x70, 0x1a, 0x30, 0x1c, 0x38, 0x1c, 0x10, 0x44, 0x00, 0x4c,
-	0xb0, 0x57, 0x40, 0x5c, 0x4d, 0xe4, 0x04, 0xea, 0x5d, 0xf0, 0xa7, 0xf0,
-	0x04, 0xf6, 0x02, 0xfc, 0x05, 0x00, 0x09, 0x00, 0x19, 0x00, 0x32, 0x00,
-	0x33, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00, 0x9e, 0x00, 0xcc, 0x00,
-	0x20, 0x01, 0x4e, 0x01, 0x79, 0x01, 0x3c, 0x09, 0x68, 0x0d, 0x02, 0x10,
-	0x04, 0x10, 0x3a, 0x10, 0x08, 0x12, 0x0a, 0x13, 0x40, 0x16, 0x50, 0x16,
-	0x00, 0x17, 0x4a, 0x19, 0x00, 0x4e, 0x00, 0x54, 0x01, 0x58, 0x00, 0xdc,
-	0x05, 0xf0, 0x09, 0xf0, 0x59, 0xf0, 0xb8, 0xf0, 0x48, 0xf4, 0x0e, 0xf7,
-	0x0a, 0x00, 0x9b, 0x00, 0x9c, 0x00, 0xa4, 0x00, 0xb5, 0x00, 0xba, 0x00,
-	0xd0, 0x00, 0xe7, 0x00, 0xf0, 0x03, 0x69, 0x08, 0xe9, 0x09, 0x5c, 0x0c,
-	0xb6, 0x12, 0xbc, 0x19, 0xd8, 0x1b, 0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c,
-	0x42, 0x1d, 0x08, 0x44, 0x38, 0x44, 0x91, 0x44, 0x0a, 0x45, 0x48, 0x46,
-	0x89, 0x48, 0x68, 0x54, 0x83, 0x55, 0x83, 0x59, 0x31, 0xe4, 0x02, 0xe6,
-	0x07, 0xf0, 0x08, 0xf0, 0x0b, 0xf0, 0x0c, 0xf0, 0x4b, 0xf4, 0x04, 0xf8,
-	0x05, 0xf8, 0x02, 0xfa, 0x03, 0xfa, 0x04, 0xfc, 0x05, 0xfc, 0x07, 0x00,
-	0xa8, 0x00, 0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0x22, 0x01,
-	0x26, 0x01, 0x60, 0x01, 0x7a, 0x01, 0x82, 0x01, 0xc8, 0x01, 0xca, 0x01,
-	0x86, 0x02, 0x6a, 0x03, 0x18, 0x05, 0xb2, 0x07, 0x68, 0x08, 0x10, 0x0d,
-	0x06, 0x10, 0x0a, 0x10, 0x0e, 0x10, 0x12, 0x10, 0x60, 0x10, 0xed, 0x10,
-	0xf3, 0x10, 0x06, 0x12, 0x10, 0x12, 0x1e, 0x12, 0x0c, 0x13, 0x0e, 0x13,
-	0x10, 0x13, 0xfe, 0x9c, 0xf0, 0x35, 0x05, 0xfe, 0xec, 0x0e, 0xff, 0x10,
-	0x00, 0x00, 0xe9, 0xfe, 0x34, 0x1f, 0x00, 0xe8, 0xfe, 0x88, 0x01, 0xff,
-	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
-	0x00, 0xfe, 0x57, 0x24, 0x00, 0xfe, 0x4c, 0x00, 0x65, 0xff, 0x04, 0x00,
-	0x00, 0x1a, 0xff, 0x09, 0x00, 0x00, 0xff, 0x08, 0x01, 0x01, 0xff, 0x08,
-	0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10, 0xff, 0xff, 0xff, 0x13,
-	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
-	0xfe, 0x04, 0xf7, 0xe8, 0x37, 0x7d, 0x0d, 0x01, 0xfe, 0x4a, 0x11, 0xfe,
-	0x04, 0xf7, 0xe8, 0x7d, 0x0d, 0x51, 0x37, 0xfe, 0x3d, 0xf0, 0xfe, 0x0c,
-	0x02, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x91, 0xf0, 0xfe, 0xf8, 0x01, 0xfe,
-	0x90, 0xf0, 0xfe, 0xf8, 0x01, 0xfe, 0x8f, 0xf0, 0xbc, 0x03, 0x67, 0x4d,
-	0x05, 0xfe, 0x08, 0x0f, 0x01, 0xfe, 0x78, 0x0f, 0xfe, 0xdd, 0x12, 0x05,
-	0xfe, 0x0e, 0x03, 0xfe, 0x28, 0x1c, 0x03, 0xfe, 0xa6, 0x00, 0xfe, 0xd1,
-	0x12, 0x3e, 0x22, 0xfe, 0xa6, 0x00, 0xac, 0xfe, 0x48, 0xf0, 0xfe, 0x90,
-	0x02, 0xfe, 0x49, 0xf0, 0xfe, 0xaa, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xc8,
-	0x02, 0xfe, 0x46, 0xf0, 0xfe, 0x5a, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x60,
-	0x02, 0xfe, 0x43, 0xf0, 0xfe, 0x4e, 0x02, 0xfe, 0x44, 0xf0, 0xfe, 0x52,
-	0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x56, 0x02, 0x1c, 0x0d, 0xa2, 0x1c, 0x07,
-	0x22, 0xb7, 0x05, 0x35, 0xfe, 0x00, 0x1c, 0xfe, 0xf1, 0x10, 0xfe, 0x02,
-	0x1c, 0xf5, 0xfe, 0x1e, 0x1c, 0xfe, 0xe9, 0x10, 0x01, 0x5f, 0xfe, 0xe7,
-	0x10, 0xfe, 0x06, 0xfc, 0xde, 0x0a, 0x81, 0x01, 0xa3, 0x05, 0x35, 0x1f,
-	0x95, 0x47, 0xb8, 0x01, 0xfe, 0xe4, 0x11, 0x0a, 0x81, 0x01, 0x5c, 0xfe,
-	0xbd, 0x10, 0x0a, 0x81, 0x01, 0x5c, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c,
-	0xfe, 0x58, 0x1c, 0x1c, 0x07, 0x22, 0xb7, 0x37, 0x2a, 0x35, 0xfe, 0x3d,
-	0xf0, 0xfe, 0x0c, 0x02, 0x2b, 0xfe, 0x9e, 0x02, 0xfe, 0x5a, 0x1c, 0xfe,
-	0x12, 0x1c, 0xfe, 0x14, 0x1c, 0x1f, 0xfe, 0x30, 0x00, 0x47, 0xb8, 0x01,
-	0xfe, 0xd4, 0x11, 0x1c, 0x07, 0x22, 0xb7, 0x05, 0xe9, 0x21, 0x2c, 0x09,
-	0x1a, 0x31, 0xfe, 0x69, 0x10, 0x1c, 0x07, 0x22, 0xb7, 0xfe, 0x04, 0xec,
-	0x2c, 0x60, 0x01, 0xfe, 0x1e, 0x1e, 0x20, 0x2c, 0xfe, 0x05, 0xf6, 0xde,
-	0x01, 0xfe, 0x62, 0x1b, 0x01, 0x0c, 0x61, 0x4a, 0x44, 0x15, 0x56, 0x51,
-	0x01, 0xfe, 0x9e, 0x1e, 0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x0a, 0x57,
-	0x01, 0x18, 0x09, 0x00, 0x36, 0x01, 0x85, 0xfe, 0x18, 0x10, 0xfe, 0x41,
-	0x58, 0x0a, 0xba, 0x01, 0x18, 0xfe, 0xc8, 0x54, 0x7b, 0xfe, 0x1c, 0x03,
-	0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x37, 0x60, 0xfe, 0x02, 0xe8, 0x30,
-	0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43, 0xfe, 0x77, 0x57, 0xfe, 0x27, 0xf0,
-	0xfe, 0xe4, 0x01, 0xfe, 0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x40,
-	0x1c, 0x2a, 0xeb, 0xfe, 0x26, 0xf0, 0xfe, 0x66, 0x03, 0xfe, 0xa0, 0xf0,
-	0xfe, 0x54, 0x03, 0xfe, 0x11, 0xf0, 0xbc, 0xfe, 0xef, 0x10, 0xfe, 0x9f,
-	0xf0, 0xfe, 0x74, 0x03, 0xfe, 0x46, 0x1c, 0x19, 0xfe, 0x11, 0x00, 0x05,
-	0x70, 0x37, 0xfe, 0x48, 0x1c, 0xfe, 0x46, 0x1c, 0x01, 0x0c, 0x06, 0x28,
-	0xfe, 0x18, 0x13, 0x26, 0x21, 0xb9, 0xc7, 0x20, 0xb9, 0x0a, 0x57, 0x01,
-	0x18, 0xc7, 0x89, 0x01, 0xfe, 0xc8, 0x1a, 0x15, 0xe1, 0x2a, 0xeb, 0xfe,
-	0x01, 0xf0, 0xeb, 0xfe, 0x82, 0xf0, 0xfe, 0xa4, 0x03, 0xfe, 0x9c, 0x32,
-	0x15, 0xfe, 0xe4, 0x00, 0x2f, 0xfe, 0xb6, 0x03, 0x2a, 0x3c, 0x16, 0xfe,
-	0xc6, 0x03, 0x01, 0x41, 0xfe, 0x06, 0xf0, 0xfe, 0xd6, 0x03, 0xaf, 0xa0,
-	0xfe, 0x0a, 0xf0, 0xfe, 0xa2, 0x07, 0x05, 0x29, 0x03, 0x81, 0x1e, 0x1b,
-	0xfe, 0x24, 0x05, 0x1f, 0x63, 0x01, 0x42, 0x8f, 0xfe, 0x70, 0x02, 0x05,
-	0xea, 0xfe, 0x46, 0x1c, 0x37, 0x7d, 0x1d, 0xfe, 0x67, 0x1b, 0xfe, 0xbf,
-	0x57, 0xfe, 0x77, 0x57, 0xfe, 0x48, 0x1c, 0x75, 0x01, 0xa6, 0x86, 0x0a,
-	0x57, 0x01, 0x18, 0x09, 0x00, 0x1b, 0xec, 0x0a, 0xe1, 0x01, 0x18, 0x77,
-	0x50, 0x40, 0x8d, 0x30, 0x03, 0x81, 0x1e, 0xf8, 0x1f, 0x63, 0x01, 0x42,
-	0x8f, 0xfe, 0x70, 0x02, 0x05, 0xea, 0xd7, 0x99, 0xd8, 0x9c, 0x2a, 0x29,
-	0x2f, 0xfe, 0x4e, 0x04, 0x16, 0xfe, 0x4a, 0x04, 0x7e, 0xfe, 0xa0, 0x00,
-	0xfe, 0x9b, 0x57, 0xfe, 0x54, 0x12, 0x32, 0xff, 0x02, 0x00, 0x10, 0x01,
-	0x08, 0x16, 0xfe, 0x02, 0x05, 0x32, 0x01, 0x08, 0x16, 0x29, 0x27, 0x25,
-	0xee, 0xfe, 0x4c, 0x44, 0xfe, 0x58, 0x12, 0x50, 0xfe, 0x44, 0x48, 0x13,
-	0x34, 0xfe, 0x4c, 0x54, 0x7b, 0xec, 0x60, 0x8d, 0x30, 0x01, 0xfe, 0x4e,
-	0x1e, 0xfe, 0x48, 0x47, 0xfe, 0x7c, 0x13, 0x01, 0x0c, 0x06, 0x28, 0xfe,
-	0x32, 0x13, 0x01, 0x43, 0x09, 0x9b, 0xfe, 0x68, 0x13, 0xfe, 0x26, 0x10,
-	0x13, 0x34, 0xfe, 0x4c, 0x54, 0x7b, 0xec, 0x01, 0xfe, 0x4e, 0x1e, 0xfe,
-	0x48, 0x47, 0xfe, 0x54, 0x13, 0x01, 0x0c, 0x06, 0x28, 0xa5, 0x01, 0x43,
-	0x09, 0x9b, 0xfe, 0x40, 0x13, 0x01, 0x0c, 0x06, 0x28, 0xf9, 0x1f, 0x7f,
-	0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe, 0x0d, 0x00, 0x01, 0x42, 0x8f,
-	0xfe, 0xa4, 0x0e, 0x05, 0x29, 0x32, 0x15, 0xfe, 0xe6, 0x00, 0x0f, 0xfe,
-	0x1c, 0x90, 0x04, 0xfe, 0x9c, 0x93, 0x3a, 0x0b, 0x0e, 0x8b, 0x02, 0x1f,
-	0x7f, 0x01, 0x42, 0x05, 0x35, 0xfe, 0x42, 0x5b, 0x7d, 0x1d, 0xfe, 0x46,
-	0x59, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57, 0x0f, 0xfe, 0x87, 0x80, 0x04,
-	0xfe, 0x87, 0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0xd0, 0x65, 0x01, 0x0c,
-	0x06, 0x0d, 0xfe, 0x98, 0x13, 0x0f, 0xfe, 0x20, 0x80, 0x04, 0xfe, 0xa0,
-	0x83, 0x33, 0x0b, 0x0e, 0x09, 0x1d, 0xfe, 0x84, 0x12, 0x01, 0x38, 0x06,
-	0x07, 0xfe, 0x70, 0x13, 0x03, 0xfe, 0xa2, 0x00, 0x1e, 0x1b, 0xfe, 0xda,
-	0x05, 0xd0, 0x54, 0x01, 0x38, 0x06, 0x0d, 0xfe, 0x58, 0x13, 0x03, 0xfe,
-	0xa0, 0x00, 0x1e, 0xfe, 0x50, 0x12, 0x5e, 0xff, 0x02, 0x00, 0x10, 0x2f,
-	0xfe, 0x90, 0x05, 0x2a, 0x3c, 0xcc, 0xff, 0x02, 0x00, 0x10, 0x2f, 0xfe,
-	0x9e, 0x05, 0x17, 0xfe, 0xf4, 0x05, 0x15, 0xfe, 0xe3, 0x00, 0x26, 0x01,
-	0x38, 0xfe, 0x4a, 0xf0, 0xfe, 0xc0, 0x05, 0xfe, 0x49, 0xf0, 0xfe, 0xba,
-	0x05, 0x71, 0x2e, 0xfe, 0x21, 0x00, 0xf1, 0x2e, 0xfe, 0x22, 0x00, 0xa2,
-	0x2e, 0x4a, 0xfe, 0x09, 0x48, 0xff, 0x02, 0x00, 0x10, 0x2f, 0xfe, 0xd0,
-	0x05, 0x17, 0xfe, 0xf4, 0x05, 0xfe, 0xe2, 0x08, 0x01, 0x38, 0x06, 0xfe,
-	0x1c, 0x00, 0x4d, 0x01, 0xa7, 0x2e, 0x07, 0x20, 0xe4, 0x47, 0xfe, 0x27,
-	0x01, 0x01, 0x0c, 0x06, 0x28, 0xfe, 0x24, 0x12, 0x3e, 0x01, 0x84, 0x1f,
-	0x7f, 0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe, 0x0d, 0x00, 0x01, 0x42,
-	0x8f, 0xfe, 0xa4, 0x0e, 0x05, 0x29, 0x03, 0xe6, 0x1e, 0xfe, 0xca, 0x13,
-	0x03, 0xb6, 0x1e, 0xfe, 0x40, 0x12, 0x03, 0x66, 0x1e, 0xfe, 0x38, 0x13,
-	0x3e, 0x01, 0x84, 0x17, 0xfe, 0x72, 0x06, 0x0a, 0x07, 0x01, 0x38, 0x06,
-	0x24, 0xfe, 0x02, 0x12, 0x4f, 0x01, 0xfe, 0x56, 0x19, 0x16, 0xfe, 0x68,
-	0x06, 0x15, 0x82, 0x01, 0x41, 0x15, 0xe2, 0x03, 0x66, 0x8a, 0x10, 0x66,
-	0x03, 0x9a, 0x1e, 0xfe, 0x70, 0x12, 0x03, 0x55, 0x1e, 0xfe, 0x68, 0x13,
-	0x01, 0xc6, 0x09, 0x12, 0x48, 0xfe, 0x92, 0x06, 0x2e, 0x12, 0x01, 0xfe,
-	0xac, 0x1d, 0xfe, 0x43, 0x48, 0x62, 0x80, 0x13, 0x58, 0xff, 0x02, 0x00,
-	0x57, 0x52, 0xad, 0x23, 0x3f, 0x4e, 0x62, 0x49, 0x3e, 0x01, 0x84, 0x17,
-	0xfe, 0xea, 0x06, 0x01, 0x38, 0x06, 0x12, 0xf7, 0x45, 0x0a, 0x95, 0x01,
-	0xfe, 0x84, 0x19, 0x16, 0xfe, 0xe0, 0x06, 0x15, 0x82, 0x01, 0x41, 0x15,
-	0xe2, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x1c, 0x07, 0x01, 0x84, 0xfe, 0xae,
-	0x10, 0x03, 0x6f, 0x1e, 0xfe, 0x9e, 0x13, 0x3e, 0x01, 0x84, 0x03, 0x9a,
-	0x1e, 0xfe, 0x1a, 0x12, 0x01, 0x38, 0x06, 0x12, 0xfc, 0x01, 0xc6, 0x01,
-	0xfe, 0xac, 0x1d, 0xfe, 0x43, 0x48, 0x62, 0x80, 0xf0, 0x45, 0x0a, 0x95,
-	0x03, 0xb6, 0x1e, 0xf8, 0x01, 0x38, 0x06, 0x24, 0x36, 0xfe, 0x02, 0xf6,
-	0x07, 0x71, 0x78, 0x8c, 0x00, 0x4d, 0x62, 0x49, 0x3e, 0x2d, 0x93, 0x4e,
-	0xd0, 0x0d, 0x17, 0xfe, 0x9a, 0x07, 0x01, 0xfe, 0xc0, 0x19, 0x16, 0xfe,
-	0x90, 0x07, 0x26, 0x20, 0x9e, 0x15, 0x82, 0x01, 0x41, 0x15, 0xe2, 0x21,
-	0x9e, 0x09, 0x07, 0xfb, 0x03, 0xe6, 0xfe, 0x58, 0x57, 0x10, 0xe6, 0x05,
-	0xfe, 0x2a, 0x06, 0x03, 0x6f, 0x8a, 0x10, 0x6f, 0x1c, 0x07, 0x01, 0x84,
-	0xfe, 0x9c, 0x32, 0x5f, 0x75, 0x01, 0xa6, 0x86, 0x15, 0xfe, 0xe2, 0x00,
-	0x2f, 0xed, 0x2a, 0x3c, 0xfe, 0x0a, 0xf0, 0xfe, 0xce, 0x07, 0xae, 0xfe,
-	0x96, 0x08, 0xfe, 0x06, 0xf0, 0xfe, 0x9e, 0x08, 0xaf, 0xa0, 0x05, 0x29,
-	0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x2e, 0x12, 0x14, 0x1d, 0x01, 0x08, 0x14,
-	0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0xfe,
-	0x99, 0xa4, 0x01, 0x08, 0x14, 0x00, 0x05, 0xfe, 0xc6, 0x09, 0x01, 0x76,
-	0x06, 0x12, 0xfe, 0x3a, 0x12, 0x01, 0x0c, 0x06, 0x12, 0xfe, 0x30, 0x13,
-	0x14, 0xfe, 0x1b, 0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x00,
-	0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x07, 0x01, 0x08, 0x14, 0x00,
-	0x05, 0xef, 0x7c, 0x4a, 0x78, 0x4f, 0x0f, 0xfe, 0x9a, 0x81, 0x04, 0xfe,
-	0x9a, 0x83, 0xfe, 0xcb, 0x47, 0x0b, 0x0e, 0x2d, 0x28, 0x48, 0xfe, 0x6c,
-	0x08, 0x0a, 0x28, 0xfe, 0x09, 0x6f, 0xca, 0xfe, 0xca, 0x45, 0xfe, 0x32,
-	0x12, 0x53, 0x63, 0x4e, 0x7c, 0x97, 0x2f, 0xfe, 0x7e, 0x08, 0x2a, 0x3c,
-	0xfe, 0x0a, 0xf0, 0xfe, 0x6c, 0x08, 0xaf, 0xa0, 0xae, 0xfe, 0x96, 0x08,
-	0x05, 0x29, 0x01, 0x41, 0x05, 0xed, 0x14, 0x24, 0x05, 0xed, 0xfe, 0x9c,
-	0xf7, 0x9f, 0x01, 0xfe, 0xae, 0x1e, 0xfe, 0x18, 0x58, 0x01, 0xfe, 0xbe,
-	0x1e, 0xfe, 0x99, 0x58, 0xfe, 0x78, 0x18, 0xfe, 0xf9, 0x18, 0x8e, 0xfe,
-	0x16, 0x09, 0x10, 0x6a, 0x22, 0x6b, 0x01, 0x0c, 0x61, 0x54, 0x44, 0x21,
-	0x2c, 0x09, 0x1a, 0xf8, 0x77, 0x01, 0xfe, 0x7e, 0x1e, 0x47, 0x2c, 0x7a,
-	0x30, 0xf0, 0xfe, 0x83, 0xe7, 0xfe, 0x3f, 0x00, 0x71, 0xfe, 0x03, 0x40,
-	0x01, 0x0c, 0x61, 0x65, 0x44, 0x01, 0xc2, 0xc8, 0xfe, 0x1f, 0x40, 0x20,
-	0x6e, 0x01, 0xfe, 0x6a, 0x16, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe,
-	0x44, 0x51, 0xfe, 0xc6, 0x51, 0xfe, 0x10, 0x10, 0x01, 0xfe, 0xce, 0x1e,
-	0x01, 0xfe, 0xde, 0x1e, 0x10, 0x68, 0x22, 0x69, 0x01, 0xfe, 0xee, 0x1e,
-	0x01, 0xfe, 0xfe, 0x1e, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x10, 0x4b,
-	0x22, 0x4c, 0xfe, 0x8a, 0x10, 0x01, 0x0c, 0x06, 0x54, 0xfe, 0x50, 0x12,
-	0x01, 0xfe, 0xae, 0x1e, 0x01, 0xfe, 0xbe, 0x1e, 0x10, 0x6a, 0x22, 0x6b,
-	0x01, 0x0c, 0x06, 0x65, 0x4e, 0x01, 0xc2, 0x0f, 0xfe, 0x1f, 0x80, 0x04,
-	0xfe, 0x9f, 0x83, 0x33, 0x0b, 0x0e, 0x20, 0x6e, 0x0f, 0xfe, 0x44, 0x90,
-	0x04, 0xfe, 0xc4, 0x93, 0x3a, 0x0b, 0xfe, 0xc6, 0x90, 0x04, 0xfe, 0xc6,
-	0x93, 0x79, 0x0b, 0x0e, 0x10, 0x6c, 0x22, 0x6d, 0x01, 0xfe, 0xce, 0x1e,
-	0x01, 0xfe, 0xde, 0x1e, 0x10, 0x68, 0x22, 0x69, 0x0f, 0xfe, 0x40, 0x90,
-	0x04, 0xfe, 0xc0, 0x93, 0x3a, 0x0b, 0xfe, 0xc2, 0x90, 0x04, 0xfe, 0xc2,
-	0x93, 0x79, 0x0b, 0x0e, 0x10, 0x4b, 0x22, 0x4c, 0x10, 0x64, 0x22, 0x34,
-	0x01, 0x0c, 0x61, 0x24, 0x44, 0x37, 0x13, 0xfe, 0x4e, 0x11, 0x2f, 0xfe,
-	0xde, 0x09, 0xfe, 0x9e, 0xf0, 0xfe, 0xf2, 0x09, 0xfe, 0x01, 0x48, 0x1b,
-	0x3c, 0x37, 0x88, 0xf5, 0xd4, 0xfe, 0x1e, 0x0a, 0xd5, 0xfe, 0x42, 0x0a,
-	0xd2, 0xfe, 0x1e, 0x0a, 0xd3, 0xfe, 0x42, 0x0a, 0xae, 0xfe, 0x12, 0x0a,
-	0xfe, 0x06, 0xf0, 0xfe, 0x18, 0x0a, 0xaf, 0xa0, 0x05, 0x29, 0x01, 0x41,
-	0xfe, 0xc1, 0x10, 0x14, 0x24, 0xfe, 0xc1, 0x10, 0x01, 0x76, 0x06, 0x07,
-	0xfe, 0x14, 0x12, 0x01, 0x76, 0x06, 0x0d, 0x5d, 0x01, 0x0c, 0x06, 0x0d,
-	0xfe, 0x74, 0x12, 0xfe, 0x2e, 0x1c, 0x05, 0xfe, 0x1a, 0x0c, 0x01, 0x76,
-	0x06, 0x07, 0x5d, 0x01, 0x76, 0x06, 0x0d, 0x41, 0xfe, 0x2c, 0x1c, 0xfe,
-	0xaa, 0xf0, 0xfe, 0xce, 0x0a, 0xfe, 0xac, 0xf0, 0xfe, 0x66, 0x0a, 0xfe,
-	0x92, 0x10, 0xc4, 0xf6, 0xfe, 0xad, 0xf0, 0xfe, 0x72, 0x0a, 0x05, 0xfe,
-	0x1a, 0x0c, 0xc5, 0xfe, 0xe7, 0x10, 0xfe, 0x2b, 0xf0, 0xbf, 0xfe, 0x6b,
-	0x18, 0x23, 0xfe, 0x00, 0xfe, 0xfe, 0x1c, 0x12, 0xac, 0xfe, 0xd2, 0xf0,
-	0xbf, 0xfe, 0x76, 0x18, 0x23, 0x1d, 0x1b, 0xbf, 0x03, 0xe3, 0x23, 0x07,
-	0x1b, 0xbf, 0xd4, 0x5b, 0xd5, 0x5b, 0xd2, 0x5b, 0xd3, 0x5b, 0xc4, 0xc5,
-	0xfe, 0xa9, 0x10, 0x75, 0x5e, 0x32, 0x1f, 0x7f, 0x01, 0x42, 0x19, 0xfe,
-	0x35, 0x00, 0xfe, 0x01, 0xf0, 0x70, 0x19, 0x98, 0x05, 0x70, 0xfe, 0x74,
-	0x18, 0x23, 0xfe, 0x00, 0xf8, 0x1b, 0x5b, 0x7d, 0x12, 0x01, 0xfe, 0x78,
-	0x0f, 0x4d, 0x01, 0xfe, 0x96, 0x1a, 0x21, 0x30, 0x77, 0x7d, 0x1d, 0x05,
-	0x5b, 0x01, 0x0c, 0x06, 0x0d, 0x2b, 0xfe, 0xe2, 0x0b, 0x01, 0x0c, 0x06,
-	0x54, 0xfe, 0xa6, 0x12, 0x01, 0x0c, 0x06, 0x24, 0xfe, 0x88, 0x13, 0x21,
-	0x6e, 0xc7, 0x01, 0xfe, 0x1e, 0x1f, 0x0f, 0xfe, 0x83, 0x80, 0x04, 0xfe,
-	0x83, 0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0xfe, 0xc8, 0x44, 0xfe, 0x42,
-	0x13, 0x0f, 0xfe, 0x04, 0x91, 0x04, 0xfe, 0x84, 0x93, 0xfe, 0xca, 0x57,
-	0x0b, 0xfe, 0x86, 0x91, 0x04, 0xfe, 0x86, 0x93, 0xfe, 0xcb, 0x57, 0x0b,
-	0x0e, 0x7a, 0x30, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x8e, 0x40, 0x03,
-	0x6a, 0x3b, 0x6b, 0x10, 0x97, 0x22, 0x98, 0xd9, 0x6a, 0xda, 0x6b, 0x01,
-	0xc2, 0xc8, 0x7a, 0x30, 0x20, 0x6e, 0xdb, 0x64, 0xdc, 0x34, 0x91, 0x6c,
-	0x7e, 0x6d, 0xfe, 0x44, 0x55, 0xfe, 0xe5, 0x55, 0xfe, 0x04, 0xfa, 0x64,
-	0xfe, 0x05, 0xfa, 0x34, 0x01, 0xfe, 0x6a, 0x16, 0xa3, 0x26, 0x10, 0x97,
-	0x10, 0x98, 0x91, 0x6c, 0x7e, 0x6d, 0xfe, 0x14, 0x10, 0x01, 0x0c, 0x06,
-	0x24, 0x1b, 0x40, 0x91, 0x4b, 0x7e, 0x4c, 0x01, 0x0c, 0x06, 0xfe, 0xf7,
-	0x00, 0x44, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58,
-	0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x05, 0x5b, 0x01, 0x0c, 0x06, 0x24,
-	0x1b, 0x40, 0x01, 0x0c, 0x06, 0xfe, 0xf7, 0x00, 0x44, 0x78, 0x01, 0xfe,
-	0x8e, 0x1e, 0x4f, 0x0f, 0xfe, 0x10, 0x90, 0x04, 0xfe, 0x90, 0x93, 0x3a,
-	0x0b, 0xfe, 0x92, 0x90, 0x04, 0xfe, 0x92, 0x93, 0x79, 0x0b, 0x0e, 0xfe,
-	0xbd, 0x10, 0x01, 0x43, 0x09, 0xbb, 0x1b, 0xfe, 0x6e, 0x0a, 0x15, 0xbb,
-	0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x14, 0x13, 0x03, 0x4b, 0x3b, 0x4c, 0x8e,
-	0xfe, 0x6e, 0x0a, 0xfe, 0x0c, 0x58, 0xfe, 0x8d, 0x58, 0x05, 0x5b, 0x26,
-	0x3e, 0x0f, 0xfe, 0x19, 0x80, 0x04, 0xfe, 0x99, 0x83, 0x33, 0x0b, 0x0e,
-	0xfe, 0xe5, 0x10, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1a, 0x12, 0xfe, 0x6c,
-	0x19, 0xfe, 0x19, 0x41, 0xfe, 0x6b, 0x18, 0xac, 0xfe, 0xd1, 0xf0, 0xef,
-	0x1f, 0x92, 0x01, 0x42, 0x19, 0xfe, 0x44, 0x00, 0xfe, 0x90, 0x10, 0xfe,
-	0x6c, 0x19, 0xd9, 0x4b, 0xfe, 0xed, 0x19, 0xda, 0x4c, 0xfe, 0x0c, 0x51,
-	0xfe, 0x8e, 0x51, 0xfe, 0x6b, 0x18, 0x23, 0xfe, 0x00, 0xff, 0x31, 0xfe,
-	0x76, 0x10, 0xac, 0xfe, 0xd2, 0xf0, 0xfe, 0xba, 0x0c, 0xfe, 0x76, 0x18,
-	0x23, 0x1d, 0x5d, 0x03, 0xe3, 0x23, 0x07, 0xfe, 0x08, 0x13, 0x19, 0xfe,
-	0x16, 0x00, 0x05, 0x70, 0xfe, 0xd1, 0xf0, 0xfe, 0xcc, 0x0c, 0x1f, 0x92,
-	0x01, 0x42, 0x19, 0xfe, 0x17, 0x00, 0x5c, 0xfe, 0xce, 0xf0, 0xfe, 0xd2,
-	0x0c, 0xfe, 0x3e, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xde, 0x0c, 0x19, 0xfe,
-	0x22, 0x00, 0x05, 0x70, 0xfe, 0xcb, 0xf0, 0xfe, 0xea, 0x0c, 0x19, 0xfe,
-	0x24, 0x00, 0x05, 0x70, 0xfe, 0xd0, 0xf0, 0xfe, 0xf4, 0x0c, 0x19, 0x94,
-	0xfe, 0x1c, 0x10, 0xfe, 0xcf, 0xf0, 0xfe, 0xfe, 0x0c, 0x19, 0x4a, 0xf3,
-	0xfe, 0xcc, 0xf0, 0xef, 0x01, 0x76, 0x06, 0x24, 0x4d, 0x19, 0xfe, 0x12,
-	0x00, 0x37, 0x13, 0xfe, 0x4e, 0x11, 0x2f, 0xfe, 0x16, 0x0d, 0xfe, 0x9e,
-	0xf0, 0xfe, 0x2a, 0x0d, 0xfe, 0x01, 0x48, 0x1b, 0x3c, 0x37, 0x88, 0xf5,
-	0xd4, 0x29, 0xd5, 0x29, 0xd2, 0x29, 0xd3, 0x29, 0x37, 0xfe, 0x9c, 0x32,
-	0x2f, 0xfe, 0x3e, 0x0d, 0x2a, 0x3c, 0xae, 0xfe, 0x62, 0x0d, 0xaf, 0xa0,
-	0xd4, 0x9f, 0xd5, 0x9f, 0xd2, 0x9f, 0xd3, 0x9f, 0x05, 0x29, 0x01, 0x41,
-	0xfe, 0xd3, 0x10, 0x15, 0xfe, 0xe8, 0x00, 0xc4, 0xc5, 0x75, 0xd7, 0x99,
-	0xd8, 0x9c, 0xfe, 0x89, 0xf0, 0x29, 0x27, 0x25, 0xbe, 0xd7, 0x99, 0xd8,
-	0x9c, 0x2f, 0xfe, 0x8c, 0x0d, 0x16, 0x29, 0x27, 0x25, 0xbd, 0xfe, 0x01,
-	0x48, 0xa4, 0x19, 0xfe, 0x42, 0x00, 0x05, 0x70, 0x90, 0x07, 0xfe, 0x81,
-	0x49, 0x1b, 0xfe, 0x64, 0x0e, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x44, 0x13,
-	0x19, 0x00, 0x2d, 0x0d, 0xfe, 0x54, 0x12, 0x2d, 0xfe, 0x28, 0x00, 0x2b,
-	0xfe, 0xda, 0x0e, 0x0a, 0x57, 0x01, 0x18, 0x09, 0x00, 0x36, 0x46, 0xfe,
-	0x28, 0x00, 0xfe, 0xfa, 0x10, 0x01, 0xfe, 0xf4, 0x1c, 0x01, 0xfe, 0x00,
-	0x1d, 0x0a, 0xba, 0x01, 0xfe, 0x58, 0x10, 0x40, 0x15, 0x56, 0x01, 0x85,
-	0x05, 0x35, 0x19, 0xfe, 0x44, 0x00, 0x2d, 0x0d, 0xf7, 0x46, 0x0d, 0xfe,
-	0xcc, 0x10, 0x01, 0xa7, 0x46, 0x0d, 0xfe, 0xc2, 0x10, 0x01, 0xa7, 0x0f,
-	0xfe, 0x19, 0x82, 0x04, 0xfe, 0x99, 0x83, 0xfe, 0xcc, 0x47, 0x0b, 0x0e,
-	0xfe, 0x34, 0x46, 0xa5, 0x46, 0x0d, 0x19, 0xfe, 0x43, 0x00, 0xfe, 0xa2,
-	0x10, 0x01, 0x0c, 0x61, 0x0d, 0x44, 0x01, 0xfe, 0xf4, 0x1c, 0x01, 0xfe,
-	0x00, 0x1d, 0x40, 0x15, 0x56, 0x01, 0x85, 0x7d, 0x0d, 0x40, 0x51, 0x01,
-	0xfe, 0x9e, 0x1e, 0x05, 0xfe, 0x3a, 0x03, 0x01, 0x0c, 0x06, 0x0d, 0x5d,
-	0x46, 0x0d, 0x19, 0x00, 0xfe, 0x62, 0x10, 0x01, 0x76, 0x06, 0x12, 0xfe,
-	0x5c, 0x12, 0x01, 0x0c, 0x06, 0x12, 0xfe, 0x52, 0x13, 0xfe, 0x1c, 0x1c,
-	0xfe, 0x9d, 0xf0, 0xfe, 0x8e, 0x0e, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0,
-	0xfe, 0x94, 0x0e, 0x01, 0x0c, 0x61, 0x12, 0x44, 0xfe, 0x9f, 0x10, 0x19,
-	0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0d, 0x4f, 0xfe, 0x2e, 0x10, 0x19,
-	0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x19, 0xfe, 0x47, 0x00, 0xf1, 0x19,
-	0xfe, 0x41, 0x00, 0xa2, 0x19, 0xfe, 0x24, 0x00, 0x86, 0xc4, 0xc5, 0x75,
-	0x03, 0x81, 0x1e, 0x2b, 0xea, 0x4f, 0xfe, 0x04, 0xe6, 0x12, 0xfe, 0x9d,
-	0x41, 0xfe, 0x1c, 0x42, 0x40, 0x01, 0xf4, 0x05, 0x35, 0xfe, 0x12, 0x1c,
-	0x1f, 0x0d, 0x47, 0xb5, 0xc3, 0x1f, 0xfe, 0x31, 0x00, 0x47, 0xb8, 0x01,
-	0xfe, 0xd4, 0x11, 0x05, 0xe9, 0x51, 0xfe, 0x06, 0xec, 0xe0, 0xfe, 0x0e,
-	0x47, 0x46, 0x28, 0xfe, 0xce, 0x45, 0x31, 0x51, 0xfe, 0x06, 0xea, 0xe0,
-	0xfe, 0x47, 0x4b, 0x45, 0xfe, 0x75, 0x57, 0x03, 0x67, 0xfe, 0x98, 0x56,
-	0xfe, 0x38, 0x12, 0x0a, 0x5a, 0x01, 0x18, 0xfe, 0x44, 0x48, 0x60, 0x01,
-	0x0c, 0x06, 0x28, 0xfe, 0x18, 0x13, 0x0a, 0x57, 0x01, 0x18, 0x3e, 0xfe,
-	0x41, 0x58, 0x0a, 0xba, 0xfe, 0xfa, 0x14, 0xfe, 0x49, 0x54, 0xb0, 0xfe,
-	0x5e, 0x0f, 0x05, 0xfe, 0x3a, 0x03, 0x0a, 0x67, 0xfe, 0xe0, 0x14, 0xfe,
-	0x0e, 0x47, 0x46, 0x28, 0xfe, 0xce, 0x45, 0x31, 0x51, 0xfe, 0xce, 0x47,
-	0xfe, 0xad, 0x13, 0x05, 0x35, 0x21, 0x2c, 0x09, 0x1a, 0xfe, 0x98, 0x12,
-	0x26, 0x20, 0x96, 0x20, 0xe7, 0xfe, 0x08, 0x1c, 0xfe, 0x7c, 0x19, 0xfe,
-	0xfd, 0x19, 0xfe, 0x0a, 0x1c, 0x03, 0xe5, 0xfe, 0x48, 0x55, 0xa5, 0x3b,
-	0xfe, 0x62, 0x01, 0xfe, 0xc9, 0x55, 0x31, 0xfe, 0x74, 0x10, 0x01, 0xfe,
-	0xf0, 0x1a, 0x03, 0xfe, 0x38, 0x01, 0x3b, 0xfe, 0x3a, 0x01, 0x8e, 0xfe,
-	0x1e, 0x10, 0xfe, 0x02, 0xec, 0xe7, 0x53, 0x00, 0x36, 0xfe, 0x04, 0xec,
-	0x2c, 0x60, 0xfe, 0x05, 0xf6, 0xfe, 0x34, 0x01, 0x01, 0xfe, 0x62, 0x1b,
-	0x01, 0xfe, 0xce, 0x1e, 0xb2, 0x11, 0xfe, 0x18, 0x13, 0xca, 0xfe, 0x02,
-	0xea, 0xe7, 0x53, 0x92, 0xfe, 0xc3, 0x13, 0x1f, 0x12, 0x47, 0xb5, 0xc3,
-	0xfe, 0x2a, 0x10, 0x03, 0xfe, 0x38, 0x01, 0x23, 0xfe, 0xf0, 0xff, 0x10,
-	0xe5, 0x03, 0xfe, 0x3a, 0x01, 0x10, 0xfe, 0x62, 0x01, 0x01, 0xfe, 0x1e,
-	0x1e, 0x20, 0x2c, 0x15, 0x56, 0x01, 0xfe, 0x9e, 0x1e, 0x13, 0x07, 0x02,
-	0x26, 0x02, 0x21, 0x96, 0xc7, 0x20, 0x96, 0x09, 0x92, 0xfe, 0x79, 0x13,
-	0x1f, 0x1d, 0x47, 0xb5, 0xc3, 0xfe, 0xe1, 0x10, 0xcf, 0xfe, 0x03, 0xdc,
-	0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xcf, 0xfe, 0x03, 0xdc, 0xfe,
-	0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xfe, 0x03, 0x57, 0xcf, 0x26, 0xfe,
-	0x00, 0xcc, 0x02, 0xfe, 0x03, 0x57, 0xcf, 0x89, 0x02, 0x01, 0x0c, 0x06,
-	0x4a, 0xfe, 0x4e, 0x13, 0x0f, 0xfe, 0x1c, 0x80, 0x04, 0xfe, 0x9c, 0x83,
-	0x33, 0x0b, 0x0e, 0x09, 0x07, 0xfe, 0x3a, 0x13, 0x0f, 0xfe, 0x1e, 0x80,
-	0x04, 0xfe, 0x9e, 0x83, 0x33, 0x0b, 0x0e, 0xfe, 0x2a, 0x13, 0x0f, 0xfe,
-	0x1d, 0x80, 0x04, 0xfe, 0x9d, 0x83, 0xfe, 0xf9, 0x13, 0x0e, 0xfe, 0x1c,
-	0x13, 0x01, 0xfe, 0xee, 0x1e, 0xac, 0xfe, 0x14, 0x13, 0x01, 0xfe, 0xfe,
-	0x1e, 0xfe, 0x81, 0x58, 0xfa, 0x01, 0xfe, 0x0e, 0x1f, 0xfe, 0x30, 0xf4,
-	0x0d, 0xfe, 0x3c, 0x50, 0xa2, 0x01, 0xfe, 0x92, 0x1b, 0x01, 0x43, 0x09,
-	0x56, 0xfb, 0x01, 0xfe, 0xc8, 0x1a, 0x01, 0x0c, 0x06, 0x28, 0xa4, 0x01,
-	0xfe, 0xf4, 0x1c, 0x01, 0xfe, 0x00, 0x1d, 0x15, 0xfe, 0xe9, 0x00, 0x01,
-	0x0c, 0x06, 0x4a, 0xfe, 0x4e, 0x13, 0x01, 0xfe, 0x22, 0x1b, 0xfe, 0x1e,
-	0x1c, 0x0f, 0xfe, 0x14, 0x90, 0x04, 0xfe, 0x94, 0x93, 0x3a, 0x0b, 0xfe,
-	0x96, 0x90, 0x04, 0xfe, 0x96, 0x93, 0x79, 0x0b, 0x0e, 0x10, 0xfe, 0x64,
-	0x01, 0x22, 0xfe, 0x66, 0x01, 0x01, 0x0c, 0x06, 0x65, 0xf9, 0x0f, 0xfe,
-	0x03, 0x80, 0x04, 0xfe, 0x83, 0x83, 0x33, 0x0b, 0x0e, 0x77, 0xfe, 0x01,
-	0xec, 0x2c, 0xfe, 0x80, 0x40, 0x20, 0x2c, 0x7a, 0x30, 0x15, 0xdf, 0x40,
-	0x21, 0x2c, 0xfe, 0x00, 0x40, 0x8d, 0x2c, 0x02, 0xfe, 0x08, 0x1c, 0x03,
-	0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58, 0x03, 0xfe, 0xae, 0x00, 0xfe, 0x07,
-	0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe, 0x08, 0x58, 0x03, 0xfe, 0xb2, 0x00,
-	0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c, 0x2e, 0x49, 0x20, 0xe0, 0x26, 0x10,
-	0x66, 0x10, 0x55, 0x10, 0x6f, 0x13, 0x57, 0x52, 0x4f, 0x1c, 0x28, 0xfe,
-	0x90, 0x4d, 0xfe, 0x91, 0x54, 0x2b, 0xfe, 0x88, 0x11, 0x46, 0x1a, 0x13,
-	0x5a, 0x52, 0x1c, 0x4a, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x2b, 0xfe,
-	0x9e, 0x11, 0x2e, 0x1a, 0x20, 0x2c, 0x90, 0x34, 0x60, 0x21, 0x2c, 0xfe,
-	0x00, 0x40, 0x8d, 0x2c, 0x15, 0xdf, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0,
-	0xfe, 0xb2, 0x11, 0xfe, 0x12, 0x1c, 0x75, 0xfe, 0x14, 0x1c, 0xfe, 0x10,
-	0x1c, 0xfe, 0x18, 0x1c, 0x02, 0x51, 0xfe, 0x0c, 0x14, 0xfe, 0x0e, 0x47,
-	0xfe, 0x07, 0xe6, 0x28, 0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x02, 0x01,
-	0xa7, 0x90, 0x34, 0x60, 0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42,
-	0x13, 0xfe, 0x02, 0x80, 0x09, 0x56, 0xfe, 0x34, 0x13, 0x0a, 0x5a, 0x01,
-	0x18, 0xcb, 0xfe, 0x36, 0x12, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01,
-	0xfe, 0xb2, 0x16, 0xfe, 0x00, 0xcc, 0xcb, 0xfe, 0xf3, 0x13, 0x3f, 0x89,
-	0x09, 0x1a, 0xa5, 0x0a, 0x9d, 0x01, 0x18, 0xfe, 0x80, 0x5c, 0x01, 0x85,
-	0xf2, 0x09, 0x9b, 0xa4, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0xec,
-	0x11, 0x02, 0xfe, 0x44, 0x58, 0x77, 0xfe, 0x01, 0xec, 0xb8, 0xfe, 0x9e,
-	0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x12, 0x8d, 0x30, 0x01,
-	0xf4, 0xfe, 0xdd, 0x10, 0x37, 0xd7, 0x99, 0xd8, 0x9c, 0x27, 0x25, 0xee,
-	0x09, 0x12, 0xfe, 0x48, 0x12, 0x09, 0x0d, 0xfe, 0x56, 0x12, 0x09, 0x1d,
-	0xfe, 0x30, 0x12, 0x09, 0xdd, 0x1b, 0xfe, 0xc4, 0x13, 0x09, 0xfe, 0x23,
-	0x00, 0x1b, 0xfe, 0xd0, 0x13, 0x09, 0x07, 0x1b, 0xfe, 0x34, 0x14, 0x09,
-	0x24, 0xfe, 0x12, 0x12, 0x09, 0x00, 0x1b, 0x29, 0x1f, 0xdd, 0x01, 0x42,
-	0xa1, 0x32, 0x01, 0x08, 0xae, 0x41, 0x02, 0x32, 0xfe, 0x62, 0x08, 0x0a,
-	0xe1, 0x01, 0xfe, 0x58, 0x10, 0x15, 0x9b, 0x05, 0x35, 0x32, 0x01, 0x43,
-	0x09, 0xbb, 0xfe, 0xd7, 0x13, 0x91, 0x4b, 0x7e, 0x4c, 0x8e, 0xfe, 0x80,
-	0x13, 0x01, 0x0c, 0x06, 0x54, 0xfe, 0x72, 0x12, 0xdb, 0x64, 0xdc, 0x34,
-	0xfe, 0x44, 0x55, 0xfe, 0xe5, 0x55, 0xb0, 0xfe, 0x4a, 0x13, 0x21, 0x6e,
-	0xfe, 0x26, 0x13, 0x03, 0x97, 0x3b, 0x98, 0x8e, 0xfe, 0xb6, 0x0e, 0x10,
-	0x6a, 0x22, 0x6b, 0x26, 0x10, 0x97, 0x10, 0x98, 0x01, 0xc2, 0x2e, 0x49,
-	0x88, 0x20, 0x6e, 0x01, 0xfe, 0x6a, 0x16, 0xdb, 0x64, 0xdc, 0x34, 0xfe,
-	0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x64, 0xfe, 0x05, 0xfa,
-	0x34, 0xfe, 0x8f, 0x10, 0x03, 0x6c, 0x3b, 0x6d, 0xfe, 0x40, 0x56, 0xfe,
-	0xe1, 0x56, 0x10, 0x6c, 0x22, 0x6d, 0x71, 0xdb, 0x64, 0xdc, 0x34, 0xfe,
-	0x44, 0x55, 0xfe, 0xe5, 0x55, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x00, 0x56,
-	0xfe, 0xa1, 0x56, 0x10, 0x68, 0x22, 0x69, 0x01, 0x0c, 0x06, 0x54, 0xf9,
-	0x21, 0x6e, 0xfe, 0x1f, 0x40, 0x03, 0x6a, 0x3b, 0x6b, 0xfe, 0x2c, 0x50,
-	0xfe, 0xae, 0x50, 0x03, 0x6c, 0x3b, 0x6d, 0xfe, 0x44, 0x50, 0xfe, 0xc6,
-	0x50, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x03,
-	0x4b, 0x3b, 0x4c, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x05, 0x73, 0x2e,
-	0x07, 0x20, 0x9e, 0x05, 0x72, 0x32, 0x01, 0x08, 0x16, 0x3d, 0x27, 0x25,
-	0xee, 0x09, 0x07, 0x2b, 0x3d, 0x01, 0x43, 0x09, 0xbb, 0x2b, 0x72, 0x01,
-	0xa6, 0x23, 0x3f, 0x1b, 0x3d, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1e, 0x13,
-	0x91, 0x4b, 0x7e, 0x4c, 0xfe, 0x0a, 0x55, 0x31, 0xfe, 0x8b, 0x55, 0xd9,
-	0x4b, 0xda, 0x4c, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0x05, 0x72, 0x01,
-	0xfe, 0x8e, 0x1e, 0xca, 0xfe, 0x19, 0x41, 0x05, 0x72, 0x32, 0x01, 0x08,
-	0x2a, 0x3c, 0x16, 0xc0, 0x27, 0x25, 0xbe, 0x2d, 0x1d, 0xc0, 0x2d, 0x0d,
-	0x83, 0x2d, 0x7f, 0x1b, 0xfe, 0x66, 0x15, 0x05, 0x3d, 0x01, 0x08, 0x2a,
-	0x3c, 0x16, 0xc0, 0x27, 0x25, 0xbd, 0x09, 0x1d, 0x2b, 0x3d, 0x01, 0x08,
-	0x16, 0xc0, 0x27, 0x25, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49, 0x50, 0x03,
-	0xb6, 0x1e, 0x83, 0x01, 0x38, 0x06, 0x24, 0x31, 0xa1, 0xfe, 0xbb, 0x45,
-	0x2d, 0x00, 0xa4, 0x46, 0x07, 0x90, 0x3f, 0x01, 0xfe, 0xf8, 0x15, 0x01,
-	0xa6, 0x86, 0xfe, 0x4b, 0x45, 0xfe, 0x20, 0x13, 0x01, 0x43, 0x09, 0x82,
-	0xfe, 0x16, 0x13, 0x03, 0x9a, 0x1e, 0x5d, 0x03, 0x55, 0x1e, 0x31, 0x5e,
-	0x05, 0x72, 0xfe, 0xc0, 0x5d, 0x01, 0xa7, 0xfe, 0x03, 0x17, 0x03, 0x66,
-	0x8a, 0x10, 0x66, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73, 0x01, 0xfe, 0x56,
-	0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0x3d, 0x27, 0x25, 0xbd,
-	0x09, 0x07, 0x2b, 0x3d, 0x01, 0xfe, 0xbe, 0x16, 0xfe, 0x42, 0x58, 0xfe,
-	0xe8, 0x14, 0x01, 0xa6, 0x86, 0xfe, 0x4a, 0xf4, 0x0d, 0x1b, 0x3d, 0xfe,
-	0x4a, 0xf4, 0x07, 0xfe, 0x0e, 0x12, 0x01, 0x43, 0x09, 0x82, 0x4e, 0x05,
-	0x72, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73,
-	0x01, 0xfe, 0x84, 0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0x3d,
-	0x27, 0x25, 0xbd, 0x09, 0x12, 0x2b, 0x3d, 0x01, 0xfe, 0xe8, 0x17, 0x8b,
-	0xfe, 0xaa, 0x14, 0xfe, 0xb6, 0x14, 0x86, 0xa8, 0xb2, 0x0d, 0x1b, 0x3d,
-	0xb2, 0x07, 0xfe, 0x0e, 0x12, 0x01, 0x43, 0x09, 0x82, 0x4e, 0x05, 0x72,
-	0x03, 0x6f, 0x8a, 0x10, 0x6f, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73, 0x01,
-	0xfe, 0xc0, 0x19, 0x05, 0x73, 0x13, 0x07, 0x2f, 0xfe, 0xcc, 0x15, 0x17,
-	0xfe, 0xe2, 0x15, 0x5f, 0xcc, 0x01, 0x08, 0x26, 0x5f, 0x02, 0x8f, 0xfe,
-	0xde, 0x15, 0x2a, 0xfe, 0xde, 0x15, 0x16, 0xfe, 0xcc, 0x15, 0x5e, 0x32,
-	0x01, 0x08, 0xfe, 0xd5, 0x10, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52,
-	0xad, 0x23, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x02,
-	0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xad, 0x23, 0x3f, 0xfe, 0x30,
-	0x56, 0xfe, 0x00, 0x5c, 0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52,
-	0xad, 0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xfe, 0x00, 0x5e,
-	0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xad, 0xfe, 0x0b, 0x58,
-	0x02, 0x0a, 0x66, 0x01, 0x5c, 0x0a, 0x55, 0x01, 0x5c, 0x0a, 0x6f, 0x01,
-	0x5c, 0x02, 0x01, 0xfe, 0x1e, 0x1f, 0x23, 0x1a, 0xff, 0x03, 0x00, 0x54,
-	0xfe, 0x00, 0xf4, 0x24, 0x52, 0x0f, 0xfe, 0x00, 0x7c, 0x04, 0xfe, 0x07,
-	0x7c, 0x3a, 0x0b, 0x0e, 0xfe, 0x00, 0x71, 0xfe, 0xf9, 0x18, 0xfe, 0x7a,
-	0x19, 0xfe, 0xfb, 0x19, 0xfe, 0x1a, 0xf7, 0x00, 0xfe, 0x1b, 0xf7, 0x00,
-	0x7a, 0x30, 0x10, 0x68, 0x22, 0x69, 0xd9, 0x6c, 0xda, 0x6d, 0x02, 0xfe,
-	0x62, 0x08, 0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x77,
-	0x02, 0x01, 0xc6, 0xfe, 0x42, 0x48, 0x4f, 0x50, 0x45, 0x01, 0x08, 0x16,
-	0xfe, 0xe0, 0x17, 0x27, 0x25, 0xbe, 0x01, 0x08, 0x16, 0xfe, 0xe0, 0x17,
-	0x27, 0x25, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x03, 0x9a, 0x1e, 0xfe,
-	0xda, 0x12, 0x01, 0x38, 0x06, 0x12, 0xfe, 0xd0, 0x13, 0x26, 0x53, 0x12,
-	0x48, 0xfe, 0x08, 0x17, 0xd1, 0x12, 0x53, 0x12, 0xfe, 0x1e, 0x13, 0x2d,
-	0xb4, 0x7b, 0xfe, 0x26, 0x17, 0x4d, 0x13, 0x07, 0x1c, 0xb4, 0x90, 0x04,
-	0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xf1, 0xff, 0x02, 0x83, 0x55,
-	0x53, 0x1d, 0xfe, 0x12, 0x13, 0xd6, 0xfe, 0x30, 0x00, 0xb0, 0xfe, 0x80,
-	0x17, 0x1c, 0x63, 0x13, 0x07, 0xfe, 0x56, 0x10, 0x53, 0x0d, 0xfe, 0x16,
-	0x13, 0xd6, 0xfe, 0x64, 0x00, 0xb0, 0xfe, 0x80, 0x17, 0x0a, 0xfe, 0x64,
-	0x00, 0x1c, 0x94, 0x13, 0x07, 0xfe, 0x28, 0x10, 0x53, 0x07, 0xfe, 0x60,
-	0x13, 0xd6, 0xfe, 0xc8, 0x00, 0xb0, 0xfe, 0x80, 0x17, 0x0a, 0xfe, 0xc8,
-	0x00, 0x1c, 0x95, 0x13, 0x07, 0x71, 0xd6, 0xfe, 0x90, 0x01, 0x48, 0xfe,
-	0x8c, 0x17, 0x45, 0xf3, 0xfe, 0x43, 0xf4, 0x96, 0xfe, 0x56, 0xf0, 0xfe,
-	0x9e, 0x17, 0xfe, 0x04, 0xf4, 0x58, 0xfe, 0x43, 0xf4, 0x94, 0xf6, 0x8b,
-	0x01, 0xfe, 0x24, 0x16, 0x23, 0x3f, 0xfc, 0xa8, 0x8c, 0x49, 0x48, 0xfe,
-	0xda, 0x17, 0x62, 0x49, 0xfe, 0x1c, 0x10, 0xa8, 0x8c, 0x80, 0x48, 0xfe,
-	0xda, 0x17, 0x62, 0x80, 0x71, 0x50, 0x26, 0xfe, 0x4d, 0xf4, 0x00, 0xf7,
-	0x45, 0x13, 0x07, 0xfe, 0xb4, 0x56, 0xfe, 0xc3, 0x58, 0x02, 0x50, 0x13,
-	0x0d, 0x02, 0x50, 0x3e, 0x78, 0x4f, 0x45, 0x01, 0x08, 0x16, 0xa9, 0x27,
-	0x25, 0xbe, 0xfe, 0x03, 0xea, 0xfe, 0x7e, 0x01, 0x01, 0x08, 0x16, 0xa9,
-	0x27, 0x25, 0xfe, 0xe9, 0x0a, 0x01, 0x08, 0x16, 0xa9, 0x27, 0x25, 0xfe,
-	0xe9, 0x0a, 0xfe, 0x05, 0xea, 0xfe, 0x7f, 0x01, 0x01, 0x08, 0x16, 0xa9,
-	0x27, 0x25, 0xfe, 0x69, 0x09, 0xfe, 0x02, 0xea, 0xfe, 0x80, 0x01, 0x01,
-	0x08, 0x16, 0xa9, 0x27, 0x25, 0xfe, 0xe8, 0x08, 0x47, 0xfe, 0x81, 0x01,
-	0x03, 0xb6, 0x1e, 0x83, 0x01, 0x38, 0x06, 0x24, 0x31, 0xa2, 0x78, 0xf2,
-	0x53, 0x07, 0x36, 0xfe, 0x34, 0xf4, 0x3f, 0xa1, 0x78, 0x03, 0x9a, 0x1e,
-	0x83, 0x01, 0x38, 0x06, 0x12, 0x31, 0xf0, 0x4f, 0x45, 0xfe, 0x90, 0x10,
-	0xfe, 0x40, 0x5a, 0x23, 0x3f, 0xfb, 0x8c, 0x49, 0x48, 0xfe, 0xaa, 0x18,
-	0x62, 0x49, 0x71, 0x8c, 0x80, 0x48, 0xfe, 0xaa, 0x18, 0x62, 0x80, 0xfe,
-	0xb4, 0x56, 0xfe, 0x40, 0x5d, 0x01, 0xc6, 0x01, 0xfe, 0xac, 0x1d, 0xfe,
-	0x02, 0x17, 0xfe, 0xc8, 0x45, 0xfe, 0x5a, 0xf0, 0xfe, 0xc0, 0x18, 0xfe,
-	0x43, 0x48, 0x2d, 0x93, 0x36, 0xfe, 0x34, 0xf4, 0xfe, 0x00, 0x11, 0xfe,
-	0x40, 0x10, 0x2d, 0xb4, 0x36, 0xfe, 0x34, 0xf4, 0x04, 0xfe, 0x34, 0x10,
-	0x2d, 0xfe, 0x0b, 0x00, 0x36, 0x46, 0x63, 0xfe, 0x28, 0x10, 0xfe, 0xc0,
-	0x49, 0xff, 0x02, 0x00, 0x54, 0xb2, 0xfe, 0x90, 0x01, 0x48, 0xfe, 0xfa,
-	0x18, 0x45, 0xfe, 0x1c, 0xf4, 0x3f, 0xf3, 0xfe, 0x40, 0xf4, 0x96, 0xfe,
-	0x56, 0xf0, 0xfe, 0x0c, 0x19, 0xfe, 0x04, 0xf4, 0x58, 0xfe, 0x40, 0xf4,
-	0x94, 0xf6, 0x3e, 0x2d, 0x93, 0x4e, 0xd0, 0x0d, 0x21, 0xfe, 0x7f, 0x01,
-	0xfe, 0xc8, 0x46, 0xfe, 0x24, 0x13, 0x8c, 0x00, 0x5d, 0x26, 0x21, 0xfe,
-	0x7e, 0x01, 0xfe, 0xc8, 0x45, 0xfe, 0x14, 0x13, 0x21, 0xfe, 0x80, 0x01,
-	0xfe, 0x48, 0x45, 0xfa, 0x21, 0xfe, 0x81, 0x01, 0xfe, 0xc8, 0x44, 0x4e,
-	0x26, 0x02, 0x13, 0x07, 0x02, 0x78, 0x45, 0x50, 0x13, 0x0d, 0x02, 0x14,
-	0x07, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x14, 0x0d, 0x01, 0x08, 0x17,
-	0xfe, 0x82, 0x19, 0x14, 0x1d, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x5f,
-	0xfe, 0x89, 0x49, 0x01, 0x08, 0x02, 0x14, 0x07, 0x01, 0x08, 0x17, 0xc1,
-	0x14, 0x1d, 0x01, 0x08, 0x17, 0xc1, 0x14, 0x07, 0x01, 0x08, 0x17, 0xc1,
-	0xfe, 0x89, 0x49, 0x01, 0x08, 0x17, 0xc1, 0x5f, 0xfe, 0x89, 0x4a, 0x01,
-	0x08, 0x02, 0x50, 0x02, 0x14, 0x07, 0x01, 0x08, 0x17, 0x74, 0x14, 0x7f,
-	0x01, 0x08, 0x17, 0x74, 0x14, 0x12, 0x01, 0x08, 0x17, 0x74, 0xfe, 0x89,
-	0x49, 0x01, 0x08, 0x17, 0x74, 0x14, 0x00, 0x01, 0x08, 0x17, 0x74, 0xfe,
-	0x89, 0x4a, 0x01, 0x08, 0x17, 0x74, 0xfe, 0x09, 0x49, 0x01, 0x08, 0x17,
-	0x74, 0x5f, 0xcc, 0x01, 0x08, 0x02, 0x21, 0xe4, 0x09, 0x07, 0xfe, 0x4c,
-	0x13, 0xc8, 0x20, 0xe4, 0xfe, 0x49, 0xf4, 0x00, 0x4d, 0x5f, 0xa1, 0x5e,
-	0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xcc, 0xff, 0x02, 0x00, 0x10, 0x2f,
-	0xfe, 0x3e, 0x1a, 0x01, 0x43, 0x09, 0xfe, 0xe3, 0x00, 0xfe, 0x22, 0x13,
-	0x16, 0xfe, 0x64, 0x1a, 0x26, 0x20, 0x9e, 0x01, 0x41, 0x21, 0x9e, 0x09,
-	0x07, 0x5d, 0x01, 0x0c, 0x61, 0x07, 0x44, 0x02, 0x0a, 0x5a, 0x01, 0x18,
-	0xfe, 0x00, 0x40, 0xaa, 0x09, 0x1a, 0xfe, 0x12, 0x13, 0x0a, 0x9d, 0x01,
-	0x18, 0xaa, 0x0a, 0x67, 0x01, 0xa3, 0x02, 0x0a, 0x9d, 0x01, 0x18, 0xaa,
-	0xfe, 0x80, 0xe7, 0x1a, 0x09, 0x1a, 0x5d, 0xfe, 0x45, 0x58, 0x01, 0xfe,
-	0xb2, 0x16, 0xaa, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0xaa, 0x0a, 0x67, 0x01,
-	0xa3, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x01, 0xfe, 0x7e, 0x1e, 0xfe, 0x80,
-	0x4c, 0xfe, 0x49, 0xe4, 0x1a, 0xfe, 0x12, 0x13, 0x0a, 0x9d, 0x01, 0x18,
-	0xfe, 0x80, 0x4c, 0x0a, 0x67, 0x01, 0x5c, 0x02, 0x1c, 0x1a, 0x87, 0x7c,
-	0xe5, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x24, 0x1c, 0xfe, 0x1d,
-	0xf7, 0x28, 0xb1, 0xfe, 0x04, 0x1b, 0x01, 0xfe, 0x2a, 0x1c, 0xfa, 0xb3,
-	0x28, 0x7c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x02, 0xc9, 0x2b, 0xfe,
-	0xf4, 0x1a, 0xfe, 0xfa, 0x10, 0x1c, 0x1a, 0x87, 0x03, 0xfe, 0x64, 0x01,
-	0xfe, 0x00, 0xf4, 0x24, 0xfe, 0x18, 0x58, 0x03, 0xfe, 0x66, 0x01, 0xfe,
-	0x19, 0x58, 0xb3, 0x24, 0x01, 0xfe, 0x0e, 0x1f, 0xfe, 0x30, 0xf4, 0x07,
-	0xfe, 0x3c, 0x50, 0x7c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c,
-	0xf7, 0x24, 0xb1, 0xfe, 0x50, 0x1b, 0xfe, 0xd4, 0x14, 0x31, 0x02, 0xc9,
-	0x2b, 0xfe, 0x26, 0x1b, 0xfe, 0xba, 0x10, 0x1c, 0x1a, 0x87, 0xfe, 0x83,
-	0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7, 0x54, 0xb1,
-	0xfe, 0x72, 0x1b, 0xfe, 0xb2, 0x14, 0xfc, 0xb3, 0x54, 0x7c, 0x12, 0xfe,
-	0xaf, 0x19, 0xfe, 0x98, 0xe7, 0x00, 0x02, 0xc9, 0x2b, 0xfe, 0x66, 0x1b,
-	0xfe, 0x8a, 0x10, 0x1c, 0x1a, 0x87, 0x8b, 0x0f, 0xfe, 0x30, 0x90, 0x04,
-	0xfe, 0xb0, 0x93, 0x3a, 0x0b, 0xfe, 0x18, 0x58, 0xfe, 0x32, 0x90, 0x04,
-	0xfe, 0xb2, 0x93, 0x3a, 0x0b, 0xfe, 0x19, 0x58, 0x0e, 0xa8, 0xb3, 0x4a,
-	0x7c, 0x12, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x4a, 0xb1, 0xfe, 0xc6,
-	0x1b, 0xfe, 0x5e, 0x14, 0x31, 0x02, 0xc9, 0x2b, 0xfe, 0x96, 0x1b, 0x5c,
-	0xfe, 0x02, 0xf6, 0x1a, 0x87, 0xfe, 0x18, 0xfe, 0x6a, 0xfe, 0x19, 0xfe,
-	0x6b, 0x01, 0xfe, 0x1e, 0x1f, 0xfe, 0x1d, 0xf7, 0x65, 0xb1, 0xfe, 0xee,
-	0x1b, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13, 0xb3, 0x65, 0x3e, 0xfe, 0x83,
-	0x58, 0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7, 0x1a, 0xfe, 0x81, 0xe7, 0x1a,
-	0x15, 0xfe, 0xdd, 0x00, 0x7a, 0x30, 0x02, 0x7a, 0x30, 0xfe, 0x12, 0x45,
-	0x2b, 0xfe, 0xdc, 0x1b, 0x1f, 0x07, 0x47, 0xb5, 0xc3, 0x05, 0x35, 0xfe,
-	0x39, 0xf0, 0x75, 0x26, 0x02, 0xfe, 0x7e, 0x18, 0x23, 0x1d, 0x36, 0x13,
-	0x11, 0x02, 0x87, 0x03, 0xe3, 0x23, 0x07, 0xfe, 0xef, 0x12, 0xfe, 0xe1,
-	0x10, 0x90, 0x34, 0x60, 0xfe, 0x02, 0x80, 0x09, 0x56, 0xfe, 0x3c, 0x13,
-	0xfe, 0x82, 0x14, 0xfe, 0x42, 0x13, 0x51, 0xfe, 0x06, 0x83, 0x0a, 0x5a,
-	0x01, 0x18, 0xcb, 0xfe, 0x3e, 0x12, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48,
-	0x01, 0xfe, 0xb2, 0x16, 0xfe, 0x00, 0xcc, 0xcb, 0xfe, 0xf3, 0x13, 0x3f,
-	0x89, 0x09, 0x1a, 0xa5, 0x0a, 0x9d, 0x01, 0x18, 0xfe, 0x80, 0x4c, 0x01,
-	0x85, 0xfe, 0x16, 0x10, 0x09, 0x9b, 0x4e, 0xfe, 0x40, 0x14, 0xfe, 0x24,
-	0x12, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x52, 0x1c, 0x1c, 0x0d,
-	0x02, 0xfe, 0x9c, 0xe7, 0x0d, 0x19, 0xfe, 0x15, 0x00, 0x40, 0x8d, 0x30,
-	0x01, 0xf4, 0x1c, 0x07, 0x02, 0x51, 0xfe, 0x06, 0x83, 0xfe, 0x18, 0x80,
-	0x61, 0x28, 0x44, 0x15, 0x56, 0x01, 0x85, 0x1c, 0x07, 0x02, 0xfe, 0x38,
-	0x90, 0xfe, 0xba, 0x90, 0x91, 0xde, 0x7e, 0xdf, 0xfe, 0x48, 0x55, 0x31,
-	0xfe, 0xc9, 0x55, 0x02, 0x21, 0xb9, 0x88, 0x20, 0xb9, 0x02, 0x0a, 0xba,
-	0x01, 0x18, 0xfe, 0x41, 0x48, 0x0a, 0x57, 0x01, 0x18, 0xfe, 0x49, 0x44,
-	0x1b, 0xfe, 0x1e, 0x1d, 0x88, 0x89, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x09,
-	0x1a, 0xa4, 0x0a, 0x67, 0x01, 0xa3, 0x0a, 0x57, 0x01, 0x18, 0x88, 0x89,
-	0x02, 0xfe, 0x4e, 0xe4, 0x1d, 0x7b, 0xfe, 0x52, 0x1d, 0x03, 0xfe, 0x90,
-	0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10, 0xfe, 0x4e, 0xe4, 0xdd, 0x7b,
-	0xfe, 0x64, 0x1d, 0x03, 0xfe, 0x92, 0x00, 0xd1, 0x12, 0xfe, 0x1a, 0x10,
-	0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x7b, 0xfe, 0x76, 0x1d, 0x03, 0xfe,
-	0x94, 0x00, 0xd1, 0x24, 0xfe, 0x08, 0x10, 0x03, 0xfe, 0x96, 0x00, 0xd1,
-	0x63, 0xfe, 0x4e, 0x45, 0x83, 0xca, 0xff, 0x04, 0x68, 0x54, 0xfe, 0xf1,
-	0x10, 0x23, 0x49, 0xfe, 0x08, 0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c,
-	0xfe, 0x1a, 0xf4, 0xfe, 0x00, 0x04, 0x83, 0xb2, 0x1d, 0x48, 0xfe, 0xaa,
-	0x1d, 0x13, 0x1d, 0x02, 0x09, 0x92, 0xfe, 0x5a, 0xf0, 0xfe, 0xba, 0x1d,
-	0x2e, 0x93, 0xfe, 0x34, 0x10, 0x09, 0x12, 0xfe, 0x5a, 0xf0, 0xfe, 0xc8,
-	0x1d, 0x2e, 0xb4, 0xfe, 0x26, 0x10, 0x09, 0x1d, 0x36, 0x2e, 0x63, 0xfe,
-	0x1a, 0x10, 0x09, 0x0d, 0x36, 0x2e, 0x94, 0xf2, 0x09, 0x07, 0x36, 0x2e,
-	0x95, 0xa1, 0xc8, 0x02, 0x1f, 0x93, 0x01, 0x42, 0xfe, 0x04, 0xfe, 0x99,
-	0x03, 0x9c, 0x8b, 0x02, 0x2a, 0xfe, 0x1c, 0x1e, 0xfe, 0x14, 0xf0, 0x08,
-	0x2f, 0xfe, 0x0c, 0x1e, 0x2a, 0xfe, 0x1c, 0x1e, 0x8f, 0xfe, 0x1c, 0x1e,
-	0xfe, 0x82, 0xf0, 0xfe, 0x10, 0x1e, 0x02, 0x0f, 0x3f, 0x04, 0xfe, 0x80,
-	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x18, 0x80, 0x04, 0xfe, 0x98,
-	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x02, 0x80, 0x04, 0xfe, 0x82,
-	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06, 0x80, 0x04, 0xfe, 0x86,
-	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x1b, 0x80, 0x04, 0xfe, 0x9b,
-	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x04, 0x80, 0x04, 0xfe, 0x84,
-	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x80, 0x80, 0x04, 0xfe, 0x80,
-	0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x19, 0x81, 0x04,
-	0xfe, 0x99, 0x83, 0xfe, 0xca, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06,
-	0x83, 0x04, 0xfe, 0x86, 0x83, 0xfe, 0xce, 0x47, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x2c, 0x90, 0x04, 0xfe, 0xac, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0xae, 0x90, 0x04, 0xfe, 0xae, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x08, 0x90, 0x04, 0xfe, 0x88, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x8a, 0x90, 0x04, 0xfe, 0x8a, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x0c, 0x90, 0x04, 0xfe, 0x8c, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x8e, 0x90, 0x04, 0xfe, 0x8e, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x3c, 0x90, 0x04, 0xfe, 0xbc, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x8b,
-	0x0f, 0xfe, 0x03, 0x80, 0x04, 0xfe, 0x83, 0x83, 0x33, 0x0b, 0x77, 0x0e,
-	0xa8, 0x02, 0xff, 0x66, 0x00, 0x00,
-};
-
-static unsigned short _adv_asc38C1600_size = sizeof(_adv_asc38C1600_buf);	/* 0x1673 */
-static ADV_DCNT _adv_asc38C1600_chksum = 0x0604EF77UL;	/* Expanded little-endian checksum. */
-
 static void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
 {
 	PortAddr iop_base;
@@ -6362,6 +4751,10 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 {
+	const struct firmware *fw;
+	const char fwname[] = "advansys/mcode.bin";
+	int err;
+	unsigned long chksum;
 	ushort warn_code;
 	PortAddr iop_base;
 
@@ -6383,12 +4776,29 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	warn_code |= AscInitLram(asc_dvc);
 	if (asc_dvc->err_code != 0)
 		return UW_ERR;
-	ASC_DBG(1, "_asc_mcode_chksum 0x%lx\n", (ulong)_asc_mcode_chksum);
-	if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
-			     _asc_mcode_size) != _asc_mcode_chksum) {
+
+	err = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       fwname, err);
+		return err;
+	}
+	if (fw->size < 4) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, fwname);
+		release_firmware(fw);
+		return -EINVAL;
+	}
+	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
+		 (fw->data[1] << 8) | fw->data[0];
+	ASC_DBG(1, "_asc_mcode_chksum 0x%lx\n", (ulong)chksum);
+	if (AscLoadMicroCode(iop_base, 0, &fw->data[4],
+			     fw->size - 4) != chksum) {
 		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+		release_firmware(fw);
 		return warn_code;
 	}
+	release_firmware(fw);
 	warn_code |= AscInitMicroCodeVar(asc_dvc);
 	asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
 	AscEnableInterrupt(iop_base);
@@ -6417,8 +4827,8 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
  *
  * Returns 0 or an error if the checksum doesn't match
  */
-static int AdvLoadMicrocode(AdvPortAddr iop_base, unsigned char *buf, int size,
-			    int memsize, int chksum)
+static int AdvLoadMicrocode(AdvPortAddr iop_base, const unsigned char *buf,
+			    int size, int memsize, int chksum)
 {
 	int i, j, end, len = 0;
 	ADV_DCNT sum;
@@ -6627,6 +5037,8 @@ static int AdvResetSB(ADV_DVC_VAR *asc_dvc)
  */
 static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 {
+	const struct firmware *fw;
+	const char fwname[] = "advansys/3550.bin";
 	AdvPortAddr iop_base;
 	ushort warn_code;
 	int begin_addr;
@@ -6634,6 +5046,8 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	ushort code_sum;
 	int word;
 	int i;
+	int err;
+	unsigned long chksum;
 	ushort scsi_cfg1;
 	uchar tid;
 	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
@@ -6692,9 +5106,24 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 				max_cmd[tid]);
 	}
 
-	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc3550_buf,
-					_adv_asc3550_size, ADV_3550_MEMSIZE,
-					_adv_asc3550_chksum);
+	err = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       fwname, err);
+		return err;
+	}
+	if (fw->size < 4) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, fwname);
+		release_firmware(fw);
+		return -EINVAL;
+	}
+	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
+		 (fw->data[1] << 8) | fw->data[0];
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],
+					     fw->size - 4, ADV_3550_MEMSIZE,
+					     chksum);
+	release_firmware(fw);
 	if (asc_dvc->err_code)
 		return ADV_ERROR;
 
@@ -7065,6 +5494,8 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
  */
 static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 {
+	const struct firmware *fw;
+	const char fwname[] = "advansys/38C0800.bin";
 	AdvPortAddr iop_base;
 	ushort warn_code;
 	int begin_addr;
@@ -7072,6 +5503,8 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	ushort code_sum;
 	int word;
 	int i;
+	int err;
+	unsigned long chksum;
 	ushort scsi_cfg1;
 	uchar byte;
 	uchar tid;
@@ -7187,9 +5620,24 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	/* We need to reset back to normal mode after LRAM test passes. */
 	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
 
-	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C0800_buf,
-				 _adv_asc38C0800_size, ADV_38C0800_MEMSIZE,
-				 _adv_asc38C0800_chksum);
+	err = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       fwname, err);
+		return err;
+	}
+	if (fw->size < 4) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, fwname);
+		release_firmware(fw);
+		return -EINVAL;
+	}
+	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
+		 (fw->data[1] << 8) | fw->data[0];
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],
+					     fw->size - 4, ADV_38C0800_MEMSIZE,
+					     chksum);
+	release_firmware(fw);
 	if (asc_dvc->err_code)
 		return ADV_ERROR;
 
@@ -7544,6 +5992,8 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
  */
 static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 {
+	const struct firmware *fw;
+	const char fwname[] = "advansys/38C1600.bin";
 	AdvPortAddr iop_base;
 	ushort warn_code;
 	int begin_addr;
@@ -7551,6 +6001,8 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	ushort code_sum;
 	long word;
 	int i;
+	int err;
+	unsigned long chksum;
 	ushort scsi_cfg1;
 	uchar byte;
 	uchar tid;
@@ -7668,9 +6120,24 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	/* We need to reset back to normal mode after LRAM test passes. */
 	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
 
-	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C1600_buf,
-				 _adv_asc38C1600_size, ADV_38C1600_MEMSIZE,
-				 _adv_asc38C1600_chksum);
+	err = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       fwname, err);
+		return err;
+	}
+	if (fw->size < 4) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, fwname);
+		release_firmware(fw);
+		return -EINVAL;
+	}
+	chksum = (fw->data[3] << 24) | (fw->data[2] << 16) |
+		 (fw->data[1] << 8) | fw->data[0];
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],
+					     fw->size - 4, ADV_38C1600_MEMSIZE,
+					     chksum);
+	release_firmware(fw);
 	if (asc_dvc->err_code)
 		return ADV_ERROR;
 
@@ -14353,3 +12820,7 @@ module_init(advansys_init);
 module_exit(advansys_exit);
 
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE("advansys/mcode.bin");
+MODULE_FIRMWARE("advansys/3550.bin");
+MODULE_FIRMWARE("advansys/38C0800.bin");
+MODULE_FIRMWARE("advansys/38C1600.bin");

commit 71610f55fa4db63dbf5385929a47c9fb2451f332
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 3 22:41:36 2008 +0100

    [SCSI] struct device - replace bus_id with dev_name(), dev_set_name()
    
    [jejb: limit ioctl to returning 20 characters to avoid overrun
           on long device names and add a few more conversions]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 2f602720193e..7507d8bc57a1 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2527,7 +2527,7 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 {
 	struct asc_board *boardp = shost_priv(s);
 
-	printk("Scsi_Host at addr 0x%p, device %s\n", s, boardp->dev->bus_id);
+	printk("Scsi_Host at addr 0x%p, device %s\n", s, dev_name(boardp->dev));
 	printk(" host_busy %u, host_no %d, last_reset %d,\n",
 	       s->host_busy, s->host_no, (unsigned)s->last_reset);
 

commit 25729a7fb88ef2912fcb869abe3a76b3be07fc06
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sun Sep 28 16:18:02 2008 -0700

    [SCSI] advansys, arcmsr, ipr, nsp32, qla1280, stex: use pci_ioremap_bar()
    
    Use the newly introduced pci_ioremap_bar() function in drivers/scsi.
    pci_ioremap_bar() just takes a pci device and a bar number, with the goal
    of making it really hard to get wrong, while also having a central place
    to stick sanity checks.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Brian King <brking@us.ibm.com>
    Cc: Ed Lin <ed.lin@promise.com>
    Cc: Nick Cheng <nick.cheng@areca.com.tw>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 399fe559e4de..2f602720193e 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -13425,8 +13425,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		}
 
 		boardp->asc_n_io_port = pci_resource_len(pdev, 1);
-		boardp->ioremap_addr = ioremap(pci_resource_start(pdev, 1),
-					       boardp->asc_n_io_port);
+		boardp->ioremap_addr = pci_ioremap_bar(pdev, 1);
 		if (!boardp->ioremap_addr) {
 			shost_printk(KERN_ERR, shost, "ioremap(%lx, %d) "
 					"returned NULL\n",

commit 30037818f7c1e11cb3742fbecd614ef3dc7b27bb
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Nov 22 17:34:54 2008 +0000

    advansys fix on ISA-less configs
    
    The code
    
            if (shost->dma_channel != NO_ISA_DMA)
                    free_dma(shost->dma_channel);
    
    in there is triggerable only if we have CONFIG_ISA (we only set ->dma_channel to
    something other than NO_ISA_DMA under #ifdef CONFIG_ISA).  OTOH, free_dma() is
    not guaranteed to be there in absense of CONFIG_ISA.  IOW, driver runs into
    undefined symbols on PCI-but-not-ISA configs (e.g. on frv) and it's a false
    positive.
    
    Fix: put the entire if () under #ifdef CONFIG_ISA; behaviour doesn't change and
    dependency on free_dma() disappears for !CONFIG_ISA.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 218777bfc143..399fe559e4de 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -13872,8 +13872,10 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	advansys_wide_free_mem(boardp);
 	free_irq(boardp->irq, shost);
  err_free_dma:
+#ifdef CONFIG_ISA
 	if (shost->dma_channel != NO_ISA_DMA)
 		free_dma(shost->dma_channel);
+#endif
  err_free_proc:
 	kfree(boardp->prtbuf);
  err_unmap:
@@ -13894,10 +13896,12 @@ static int advansys_release(struct Scsi_Host *shost)
 	ASC_DBG(1, "begin\n");
 	scsi_remove_host(shost);
 	free_irq(board->irq, shost);
+#ifdef CONFIG_ISA
 	if (shost->dma_channel != NO_ISA_DMA) {
 		ASC_DBG(1, "free_dma()\n");
 		free_dma(shost->dma_channel);
 	}
+#endif
 	if (ASC_NARROW_BOARD(board)) {
 		dma_unmap_single(board->dev,
 					board->dvc_var.asc_dvc_var.overrun_dma,

commit cadbd4a5e36dde7e6c49b587b2c419103c0b7218
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:47:27 2008 -0700

    [SCSI] replace __FUNCTION__ with __func__
    
    [jejb: fixed up a ton of missed conversions.
    
     All of you are on notice this has happened, driver trees will now
     need to be rebased]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: SCSI List <linux-scsi@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 8591585e5cc5..218777bfc143 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2278,7 +2278,7 @@ do { \
 #define ASC_DBG(lvl, format, arg...) {					\
 	if (asc_dbglvl >= (lvl))					\
 		printk(KERN_DEBUG "%s: %s: " format, DRV_NAME,		\
-			__FUNCTION__ , ## arg);				\
+			__func__ , ## arg);				\
 }
 
 #define ASC_DBG_PRT_SCSI_HOST(lvl, s) \

commit 951b62c11e86acf8c55d9828aa8c921575023c29
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:57:06 2007 -0400

    [SCSI] advansys: Fix bug in AdvLoadMicrocode
    
    buf[i] can be up to 0xfd, so doubling it and assigning the result to an
    unsigned char truncates the value.  Just use an unsigned int instead;
    it's only a temporary.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 3c2d6888bb8c..8591585e5cc5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -6439,7 +6439,7 @@ static int AdvLoadMicrocode(AdvPortAddr iop_base, unsigned char *buf, int size,
 			i += 2;
 			len += 2;
 		} else {
-			unsigned char off = buf[i] * 2;
+			unsigned int off = buf[i] * 2;
 			unsigned short word = (buf[off + 1] << 8) | buf[off];
 			AdvWriteWordAutoIncLram(iop_base, word);
 			len += 2;

commit 7d5d408c77cee95d1380511de46b7a4c8dc2211d
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Feb 8 09:50:08 2008 +0900

    [SCSI] advansys: fix overrun_buf aligned bug
    
    struct asc_dvc_var needs overrun buffer to be placed on an 8 byte
    boundary. advansys defines struct asc_dvc_var:
    
    struct asc_dvc_var {
            ...
            uchar overrun_buf[ASC_OVERRUN_BSIZE] __aligned(8);
    
    The problem is that struct asc_dvc_var is placed on
    shost->hostdata. So if the hostdata is not on an 8 byte boundary, the
    advansys crashes. The hostdata is placed on a sizeof(unsigned long)
    boundary so the 8 byte boundary is not garanteed with x86_32.
    
    With 2.6.23 and 2.6.24, the hostdata is on an 8 byte boundary by
    chance, but with the current git, it's not.
    
    This patch removes overrun_buf static array and use kzalloc.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index ccef891d642f..3c2d6888bb8c 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -566,7 +566,7 @@ typedef struct asc_dvc_var {
 	ASC_SCSI_BIT_ID_TYPE unit_not_ready;
 	ASC_SCSI_BIT_ID_TYPE queue_full_or_busy;
 	ASC_SCSI_BIT_ID_TYPE start_motor;
-	uchar overrun_buf[ASC_OVERRUN_BSIZE] __aligned(8);
+	uchar *overrun_buf;
 	dma_addr_t overrun_dma;
 	uchar scsi_reset_wait;
 	uchar chip_no;
@@ -13833,6 +13833,12 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	 */
 	if (ASC_NARROW_BOARD(boardp)) {
 		ASC_DBG(2, "AscInitAsc1000Driver()\n");
+
+		asc_dvc_varp->overrun_buf = kzalloc(ASC_OVERRUN_BSIZE, GFP_KERNEL);
+		if (!asc_dvc_varp->overrun_buf) {
+			ret = -ENOMEM;
+			goto err_free_wide_mem;
+		}
 		warn_code = AscInitAsc1000Driver(asc_dvc_varp);
 
 		if (warn_code || asc_dvc_varp->err_code) {
@@ -13840,8 +13846,10 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 					"warn 0x%x, error 0x%x\n",
 					asc_dvc_varp->init_state, warn_code,
 					asc_dvc_varp->err_code);
-			if (asc_dvc_varp->err_code)
+			if (asc_dvc_varp->err_code) {
 				ret = -ENODEV;
+				kfree(asc_dvc_varp->overrun_buf);
+			}
 		}
 	} else {
 		if (advansys_wide_init_chip(shost))
@@ -13894,6 +13902,7 @@ static int advansys_release(struct Scsi_Host *shost)
 		dma_unmap_single(board->dev,
 					board->dvc_var.asc_dvc_var.overrun_dma,
 					ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);
+		kfree(board->dvc_var.asc_dvc_var.overrun_buf);
 	} else {
 		iounmap(board->ioremap_addr);
 		advansys_wide_free_mem(board);

commit 63adcc5862cf95f29c8c07d59458f102700da100
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 23:53:19 2008 -0800

    [SCSI] advansys: make 3 functions static
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 374ed025dc5a..ccef891d642f 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -12261,7 +12261,7 @@ static ushort __devinit AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void __devinit
+static void __devinit
 AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
@@ -12328,7 +12328,7 @@ AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void __devinit
+static void __devinit
 AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
@@ -12395,7 +12395,7 @@ AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void __devinit
+static void __devinit
 AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
 	ushort *wbuf;

commit 9b73e76f3cf63379dcf45fcd4f112f5812418d0a
Merge: 50d9a126240f 23c3e290fb9c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 25 17:19:08 2008 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (200 commits)
      [SCSI] usbstorage: use last_sector_bug flag universally
      [SCSI] libsas: abstract STP task status into a function
      [SCSI] ultrastor: clean up inline asm warnings
      [SCSI] aic7xxx: fix firmware build
      [SCSI] aacraid: fib context lock for management ioctls
      [SCSI] ch: remove forward declarations
      [SCSI] ch: fix device minor number management bug
      [SCSI] ch: handle class_device_create failure properly
      [SCSI] NCR5380: fix section mismatch
      [SCSI] sg: fix /proc/scsi/sg/devices when no SCSI devices
      [SCSI] IB/iSER: add logical unit reset support
      [SCSI] don't use __GFP_DMA for sense buffers if not required
      [SCSI] use dynamically allocated sense buffer
      [SCSI] scsi.h: add macro for enclosure bit of inquiry data
      [SCSI] sd: add fix for devices with last sector access problems
      [SCSI] fix pcmcia compile problem
      [SCSI] aacraid: add Voodoo Lite class of cards.
      [SCSI] aacraid: add new driver features flags
      [SCSI] qla2xxx: Update version number to 8.02.00-k7.
      [SCSI] qla2xxx: Issue correct MBC_INITIALIZE_FIRMWARE command.
      ...

commit b80ca4f7ee36c26d300c5a8f429e73372d153379
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jan 13 15:46:13 2008 +0900

    [SCSI] replace sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE
    
    This replaces sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE in
    several LLDs. It's a preparation for the future changes to remove
    sense_buffer array in scsi_cmnd structure.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9dd3952516c5..492702ba6463 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -8233,7 +8233,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 			if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
 				ASC_DBG(2, "SAM_STAT_CHECK_CONDITION\n");
 				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
-						  sizeof(scp->sense_buffer));
+						  SCSI_SENSE_BUFFERSIZE);
 				/*
 				 * Note: The 'status_byte()' macro used by
 				 * target drivers defined in scsi.h shifts the
@@ -9136,7 +9136,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
 
 	dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
-			sizeof(scp->sense_buffer), DMA_FROM_DEVICE);
+			 SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
 	/*
 	 * 'qdonep' contains the command's ending status.
 	 */
@@ -9166,7 +9166,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 			if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
 				ASC_DBG(2, "SAM_STAT_CHECK_CONDITION\n");
 				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
-						  sizeof(scp->sense_buffer));
+						  SCSI_SENSE_BUFFERSIZE);
 				/*
 				 * Note: The 'status_byte()' macro used by
 				 * target drivers defined in scsi.h shifts the
@@ -9881,9 +9881,9 @@ static __le32 advansys_get_sense_buffer_dma(struct scsi_cmnd *scp)
 {
 	struct asc_board *board = shost_priv(scp->device->host);
 	scp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,
-				sizeof(scp->sense_buffer), DMA_FROM_DEVICE);
+					     SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
 	dma_cache_sync(board->dev, scp->sense_buffer,
-				sizeof(scp->sense_buffer), DMA_FROM_DEVICE);
+		       SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);
 	return cpu_to_le32(scp->SCp.dma_handle);
 }
 
@@ -9914,7 +9914,7 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	asc_scsi_q->q2.target_ix =
 	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
 	asc_scsi_q->q1.sense_addr = advansys_get_sense_buffer_dma(scp);
-	asc_scsi_q->q1.sense_len = sizeof(scp->sense_buffer);
+	asc_scsi_q->q1.sense_len = SCSI_SENSE_BUFFERSIZE;
 
 	/*
 	 * If there are any outstanding requests for the current target,
@@ -10173,7 +10173,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	scsiqp->target_lun = scp->device->lun;
 
 	scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-	scsiqp->sense_len = sizeof(scp->sense_buffer);
+	scsiqp->sense_len = SCSI_SENSE_BUFFERSIZE;
 
 	/* Build ADV_SCSI_REQ_Q */
 

commit 747d016e7e25e216b31022fe2b012508d99fb682
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Jan 14 00:55:18 2008 -0800

    advansys: fix section mismatch warning
    
    Fix section mismatch warning:
    
    WARNING: vmlinux.o(.exit.text+0x152a): Section mismatch: reference to .init.data:_asc_def_iop_base (between 'advansys_isa_remove' and 'advansys_exit')
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9dd3952516c5..38a1ee2eacd8 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -13906,7 +13906,7 @@ static int advansys_release(struct Scsi_Host *shost)
 
 #define ASC_IOADR_TABLE_MAX_IX  11
 
-static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __devinitdata = {
+static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] = {
 	0x100, 0x0110, 0x120, 0x0130, 0x140, 0x0150, 0x0190,
 	0x0210, 0x0230, 0x0250, 0x0330
 };

commit 9d511a4b29de6764931343d03e493f2e04df0271
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:42 2007 -0400

    [SCSI] advansys: Changes to work on parisc
    
    Change PortAddr to be an unsigned int instead of an unsigned short (IO
    Port address are 24 bit on parisc).  Fix a couple of printk argument
    warnings.  Remove the Kconfig marking as 'BROKEN'.
    
    I haven't removed the #warning yet because virt_to_bus/bus_to_virt are
    only eliminated for narrow boards.  Wide boards need more work.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 07507a7e9c50..9dd3952516c5 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -120,7 +120,7 @@ typedef unsigned char uchar;
 #define CC_VERY_LONG_SG_LIST 0
 #define ASC_SRB2SCSIQ(srb_ptr)  (srb_ptr)
 
-#define PortAddr                 unsigned short	/* port address size  */
+#define PortAddr                 unsigned int	/* port address size  */
 #define inp(port)                inb(port)
 #define outp(port, byte)         outb((byte), (port))
 
@@ -13333,8 +13333,8 @@ static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
 
 	}
 
-	ASC_DBG(1, "sg_cnt %d * %u = %u bytes\n", sg_cnt, sizeof(adv_sgblk_t),
-		 (unsigned)(sizeof(adv_sgblk_t) * sg_cnt));
+	ASC_DBG(1, "sg_cnt %d * %lu = %lu bytes\n", sg_cnt, sizeof(adv_sgblk_t),
+		 sizeof(adv_sgblk_t) * sg_cnt);
 
 	if (!board->adv_sgblkp)
 		goto kmalloc_failed;
@@ -13428,9 +13428,9 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		boardp->ioremap_addr = ioremap(pci_resource_start(pdev, 1),
 					       boardp->asc_n_io_port);
 		if (!boardp->ioremap_addr) {
-			shost_printk(KERN_ERR, shost, "ioremap(%x, %d) "
+			shost_printk(KERN_ERR, shost, "ioremap(%lx, %d) "
 					"returned NULL\n",
-					pci_resource_start(pdev, 1),
+					(long)pci_resource_start(pdev, 1),
 					boardp->asc_n_io_port);
 			ret = -ENODEV;
 			goto err_shost;

commit d10fb2c7b5ce1b475df50cde9262d2c3fe3d296e
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:41 2007 -0400

    [SCSI] advansys: Use dma mapping for overrun buffer
    
    Convert the call to virt_to_bus() into a call to dma_map_single().  Some
    architectures may require different DMA addresses for different devices,
    so allocate one overrun buffer per host rather than one for all cards.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 88e7fef18a29..07507a7e9c50 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -529,7 +529,6 @@ typedef struct asc_dvc_cfg {
 	ushort mcode_date;
 	ushort mcode_version;
 	uchar max_tag_qng[ASC_MAX_TID + 1];
-	uchar *overrun_buf;
 	uchar sdtr_period_offset[ASC_MAX_TID + 1];
 	uchar adapter_info[6];
 } ASC_DVC_CFG;
@@ -551,6 +550,7 @@ typedef struct asc_dvc_cfg {
 #define ASC_BUG_FIX_ASYN_USE_SYN     0x0002
 #define ASC_MIN_TAGGED_CMD  7
 #define ASC_MAX_SCSI_RESET_WAIT      30
+#define ASC_OVERRUN_BSIZE		64
 
 struct asc_dvc_var;		/* Forward Declaration. */
 
@@ -566,6 +566,8 @@ typedef struct asc_dvc_var {
 	ASC_SCSI_BIT_ID_TYPE unit_not_ready;
 	ASC_SCSI_BIT_ID_TYPE queue_full_or_busy;
 	ASC_SCSI_BIT_ID_TYPE start_motor;
+	uchar overrun_buf[ASC_OVERRUN_BSIZE] __aligned(8);
+	dma_addr_t overrun_dma;
 	uchar scsi_reset_wait;
 	uchar chip_no;
 	char is_in_int;
@@ -668,7 +670,6 @@ typedef struct asceep_config {
 #define ASC_EEP_CMD_WRITE         0x40
 #define ASC_EEP_CMD_WRITE_ABLE    0x30
 #define ASC_EEP_CMD_WRITE_DISABLE 0x00
-#define ASC_OVERRUN_BSIZE  0x00000048UL
 #define ASCV_MSGOUT_BEG         0x0000
 #define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)
 #define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)
@@ -2404,13 +2405,12 @@ struct asc_board {
 	ushort bios_codelen;	/* BIOS Code Segment Length. */
 };
 
+#define asc_dvc_to_board(asc_dvc) container_of(asc_dvc, struct asc_board, \
+							dvc_var.asc_dvc_var)
 #define adv_dvc_to_board(adv_dvc) container_of(adv_dvc, struct asc_board, \
 							dvc_var.adv_dvc_var)
 #define adv_dvc_to_pdev(adv_dvc) to_pci_dev(adv_dvc_to_board(adv_dvc)->dev)
 
-/* Overrun buffer used by all narrow boards. */
-static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
-
 #ifdef ADVANSYS_DEBUG
 static int asc_dbglvl = 3;
 
@@ -2465,8 +2465,8 @@ static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
 		"chip_version %d,\n", h->chip_scsi_id, h->isa_dma_speed,
 		h->isa_dma_channel, h->chip_version);
 
-	printk(" mcode_date 0x%x, mcode_version %d, overrun_buf 0x%p\n",
-		h->mcode_date, h->mcode_version, h->overrun_buf);
+	printk(" mcode_date 0x%x, mcode_version %d\n",
+		h->mcode_date, h->mcode_version);
 }
 
 /*
@@ -6316,6 +6316,7 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	PortAddr iop_base;
 	ASC_PADDR phy_addr;
 	ASC_DCNT phy_size;
+	struct asc_board *board = asc_dvc_to_board(asc_dvc);
 
 	iop_base = asc_dvc->iop_base;
 	warn_code = 0;
@@ -6330,12 +6331,14 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	AscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,
 			 ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));
 
-	/* Align overrun buffer on an 8 byte boundary. */
-	phy_addr = virt_to_bus(asc_dvc->cfg->overrun_buf);
-	phy_addr = cpu_to_le32((phy_addr + 7) & ~0x7);
+	/* Ensure overrun buffer is aligned on an 8 byte boundary. */
+	BUG_ON((unsigned long)asc_dvc->overrun_buf & 7);
+	asc_dvc->overrun_dma = dma_map_single(board->dev, asc_dvc->overrun_buf,
+					ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);
+	phy_addr = cpu_to_le32(asc_dvc->overrun_dma);
 	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
 				 (uchar *)&phy_addr, 1);
-	phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE - 8);
+	phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE);
 	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,
 				 (uchar *)&phy_size, 1);
 
@@ -13404,7 +13407,6 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		asc_dvc_varp->bus_type = bus_type;
 		asc_dvc_varp->drv_ptr = boardp;
 		asc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;
-		asc_dvc_varp->cfg->overrun_buf = &overrun_buf[0];
 		asc_dvc_varp->iop_base = iop;
 	} else {
 #ifdef CONFIG_PCI
@@ -13880,19 +13882,23 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
  */
 static int advansys_release(struct Scsi_Host *shost)
 {
-	struct asc_board *boardp = shost_priv(shost);
+	struct asc_board *board = shost_priv(shost);
 	ASC_DBG(1, "begin\n");
 	scsi_remove_host(shost);
-	free_irq(boardp->irq, shost);
+	free_irq(board->irq, shost);
 	if (shost->dma_channel != NO_ISA_DMA) {
 		ASC_DBG(1, "free_dma()\n");
 		free_dma(shost->dma_channel);
 	}
-	if (!ASC_NARROW_BOARD(boardp)) {
-		iounmap(boardp->ioremap_addr);
-		advansys_wide_free_mem(boardp);
+	if (ASC_NARROW_BOARD(board)) {
+		dma_unmap_single(board->dev,
+					board->dvc_var.asc_dvc_var.overrun_dma,
+					ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);
+	} else {
+		iounmap(board->ioremap_addr);
+		advansys_wide_free_mem(board);
 	}
-	kfree(boardp->prtbuf);
+	kfree(board->prtbuf);
 	scsi_host_put(shost);
 	ASC_DBG(1, "end\n");
 	return 0;

commit b249c7fda2ca8efcbe37ace1e20a3fffac08bccb
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:40 2007 -0400

    [SCSI] advansys: Remove a couple of uses of bus_to_virt
    
    Replace ASC_VADDR_TO_U32 and ASC_U32_TO_VADDR with an auto-expanding
    array that maps pointers to 32-bit IDs and back.  One of the uses of
    ASC_VADDR_TO_U32 was in error; it should have been using ADV_VADDR_TO_U32.
    
    Also replace the use of virt_to_bus when setting the sense_address with
    a call to dma_map_single() followed by dma_cache_sync.  This part cribbed
    from the 53c700 driver.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d35897eaa807..88e7fef18a29 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -90,17 +90,6 @@
 #define ASC_DCNT  __u32		/* Unsigned Data count type. */
 #define ASC_SDCNT __s32		/* Signed Data count type. */
 
-/*
- * These macros are used to convert a virtual address to a
- * 32-bit value. This currently can be used on Linux Alpha
- * which uses 64-bit virtual address but a 32-bit bus address.
- * This is likely to break in the future, but doing this now
- * will give us time to change the HW and FW to handle 64-bit
- * addresses.
- */
-#define ASC_VADDR_TO_U32   virt_to_bus
-#define ASC_U32_TO_VADDR   bus_to_virt
-
 typedef unsigned char uchar;
 
 #ifndef TRUE
@@ -601,6 +590,8 @@ typedef struct asc_dvc_var {
 	uchar min_sdtr_index;
 	uchar max_sdtr_index;
 	struct asc_board *drv_ptr;
+	int ptr_map_count;
+	void **ptr_map;
 	ASC_DCNT uc_break;
 } ASC_DVC_VAR;
 
@@ -2747,6 +2738,59 @@ static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 }
 #endif /* ADVANSYS_DEBUG */
 
+/*
+ * The advansys chip/microcode contains a 32-bit identifier for each command
+ * known as the 'srb'.  I don't know what it stands for.  The driver used
+ * to encode the scsi_cmnd pointer by calling virt_to_bus and retrieve it
+ * with bus_to_virt.  Now the driver keeps a per-host map of integers to
+ * pointers.  It auto-expands when full, unless it can't allocate memory.
+ * Note that an srb of 0 is treated specially by the chip/firmware, hence
+ * the return of i+1 in this routine, and the corresponding subtraction in
+ * the inverse routine.
+ */
+#define BAD_SRB 0
+static u32 advansys_ptr_to_srb(struct asc_dvc_var *asc_dvc, void *ptr)
+{
+	int i;
+	void **new_ptr;
+
+	for (i = 0; i < asc_dvc->ptr_map_count; i++) {
+		if (!asc_dvc->ptr_map[i])
+			goto out;
+	}
+
+	if (asc_dvc->ptr_map_count == 0)
+		asc_dvc->ptr_map_count = 1;
+	else
+		asc_dvc->ptr_map_count *= 2;
+
+	new_ptr = krealloc(asc_dvc->ptr_map,
+			asc_dvc->ptr_map_count * sizeof(void *), GFP_ATOMIC);
+	if (!new_ptr)
+		return BAD_SRB;
+	asc_dvc->ptr_map = new_ptr;
+ out:
+	ASC_DBG(3, "Putting ptr %p into array offset %d\n", ptr, i);
+	asc_dvc->ptr_map[i] = ptr;
+	return i + 1;
+}
+
+static void * advansys_srb_to_ptr(struct asc_dvc_var *asc_dvc, u32 srb)
+{
+	void *ptr;
+
+	srb--;
+	if (srb >= asc_dvc->ptr_map_count) {
+		printk("advansys: bad SRB %u, max %u\n", srb,
+							asc_dvc->ptr_map_count);
+		return NULL;
+	}
+	ptr = asc_dvc->ptr_map[srb];
+	asc_dvc->ptr_map[srb] = NULL;
+	ASC_DBG(3, "Returning ptr %p from array offset %d\n", ptr, srb);
+	return ptr;
+}
+
 /*
  * advansys_info()
  *
@@ -9075,17 +9119,10 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	ASC_DBG(1, "asc_dvc_varp 0x%p, qdonep 0x%p\n", asc_dvc_varp, qdonep);
 	ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
 
-	/*
-	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
-	 * command that has been completed.
-	 */
-	scp = (struct scsi_cmnd *)ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
-	ASC_DBG(1, "scp 0x%p\n", scp);
-
-	if (scp == NULL) {
-		ASC_PRINT("asc_isr_callback: scp is NULL\n");
+	scp = advansys_srb_to_ptr(asc_dvc_varp, qdonep->d2.srb_ptr);
+	if (!scp)
 		return;
-	}
+
 	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
 
 	shost = scp->device->host;
@@ -9095,6 +9132,8 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	boardp = shost_priv(shost);
 	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
 
+	dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
+			sizeof(scp->sense_buffer), DMA_FROM_DEVICE);
 	/*
 	 * 'qdonep' contains the command's ending status.
 	 */
@@ -9835,9 +9874,20 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
+static __le32 advansys_get_sense_buffer_dma(struct scsi_cmnd *scp)
+{
+	struct asc_board *board = shost_priv(scp->device->host);
+	scp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,
+				sizeof(scp->sense_buffer), DMA_FROM_DEVICE);
+	dma_cache_sync(board->dev, scp->sense_buffer,
+				sizeof(scp->sense_buffer), DMA_FROM_DEVICE);
+	return cpu_to_le32(scp->SCp.dma_handle);
+}
+
 static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 			struct asc_scsi_q *asc_scsi_q)
 {
+	struct asc_dvc_var *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 	int use_sg;
 
 	memset(asc_scsi_q, 0, sizeof(*asc_scsi_q));
@@ -9845,7 +9895,11 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	/*
 	 * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
 	 */
-	asc_scsi_q->q2.srb_ptr = ASC_VADDR_TO_U32(scp);
+	asc_scsi_q->q2.srb_ptr = advansys_ptr_to_srb(asc_dvc, scp);
+	if (asc_scsi_q->q2.srb_ptr == BAD_SRB) {
+		scp->result = HOST_BYTE(DID_SOFT_ERROR);
+		return ASC_ERROR;
+	}
 
 	/*
 	 * Build the ASC_SCSI_Q request.
@@ -9856,8 +9910,7 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	asc_scsi_q->q1.target_lun = scp->device->lun;
 	asc_scsi_q->q2.target_ix =
 	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
-	asc_scsi_q->q1.sense_addr =
-	    cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+	asc_scsi_q->q1.sense_addr = advansys_get_sense_buffer_dma(scp);
 	asc_scsi_q->q1.sense_len = sizeof(scp->sense_buffer);
 
 	/*
@@ -9871,7 +9924,7 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	 * started request.
 	 *
 	 */
-	if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
+	if ((asc_dvc->cur_dvc_qng[scp->device->id] > 0) &&
 	    (boardp->reqcnt[scp->device->id] % 255) == 0) {
 		asc_scsi_q->q2.tag_code = MSG_ORDERED_TAG;
 	} else {
@@ -10091,7 +10144,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	/*
 	 * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
 	 */
-	scsiqp->srb_ptr = ASC_VADDR_TO_U32(reqp);
+	scsiqp->srb_ptr = ADV_VADDR_TO_U32(reqp);
 
 	/*
 	 * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.

commit 52c334e9450a15230b84ab4ef8ef7b034b37c371
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:39 2007 -0400

    [SCSI] advansys: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    - convert to use the new accessors for the sg lists and the parameters.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    
    - convert the statistics to not distinguish between single and sg xfers
    - replace ASC_CEILING with DIV_ROUND_UP
    - remove an obsolete comment
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index ab9108293d0f..d35897eaa807 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2223,8 +2223,6 @@ do { \
 	(((struct asc_board *) shost_priv(shost))->asc_stats.counter += (count))
 #endif /* ADVANSYS_STATS */
 
-#define ASC_CEILING(val, unit) (((val) + ((unit) - 1))/(unit))
-
 /* If the result wraps when calculating tenths, return 0. */
 #define ASC_TENTHS(num, den) \
     (((10 * ((num)/(den))) > (((num) * 10)/(den))) ? \
@@ -2356,11 +2354,9 @@ struct asc_stats {
 	ADV_DCNT exe_error;	/* # ASC_ERROR returns. */
 	ADV_DCNT exe_unknown;	/* # unknown returns. */
 	/* Data Transfer Statistics */
-	ADV_DCNT cont_cnt;	/* # non-scatter-gather I/O requests received */
-	ADV_DCNT cont_xfer;	/* # contiguous transfer 512-bytes */
-	ADV_DCNT sg_cnt;	/* # scatter-gather I/O requests received */
-	ADV_DCNT sg_elem;	/* # scatter-gather elements */
-	ADV_DCNT sg_xfer;	/* # scatter-gather transfer 512-bytes */
+	ADV_DCNT xfer_cnt;	/* # I/O requests received */
+	ADV_DCNT xfer_elem;	/* # scatter-gather elements */
+	ADV_DCNT xfer_sect;	/* # 512-byte blocks */
 };
 #endif /* ADVANSYS_STATS */
 
@@ -4057,57 +4053,32 @@ static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
 	/*
 	 * Display data transfer statistics.
 	 */
-	if (s->cont_cnt > 0) {
-		len = asc_prt_line(cp, leftlen, " cont_cnt %lu, ", s->cont_cnt);
-		ASC_PRT_NEXT();
-
-		len = asc_prt_line(cp, leftlen, "cont_xfer %lu.%01lu kb ",
-				   s->cont_xfer / 2,
-				   ASC_TENTHS(s->cont_xfer, 2));
-		ASC_PRT_NEXT();
-
-		/* Contiguous transfer average size */
-		len = asc_prt_line(cp, leftlen, "avg_xfer %lu.%01lu kb\n",
-				   (s->cont_xfer / 2) / s->cont_cnt,
-				   ASC_TENTHS((s->cont_xfer / 2), s->cont_cnt));
-		ASC_PRT_NEXT();
-	}
-
-	if (s->sg_cnt > 0) {
-
-		len = asc_prt_line(cp, leftlen, " sg_cnt %lu, sg_elem %lu, ",
-				   s->sg_cnt, s->sg_elem);
+	if (s->xfer_cnt > 0) {
+		len = asc_prt_line(cp, leftlen, " xfer_cnt %lu, xfer_elem %lu, ",
+				   s->xfer_cnt, s->xfer_elem);
 		ASC_PRT_NEXT();
 
-		len = asc_prt_line(cp, leftlen, "sg_xfer %lu.%01lu kb\n",
-				   s->sg_xfer / 2, ASC_TENTHS(s->sg_xfer, 2));
+		len = asc_prt_line(cp, leftlen, "xfer_bytes %lu.%01lu kb\n",
+				   s->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));
 		ASC_PRT_NEXT();
 
 		/* Scatter gather transfer statistics */
 		len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
-				   s->sg_elem / s->sg_cnt,
-				   ASC_TENTHS(s->sg_elem, s->sg_cnt));
+				   s->xfer_elem / s->xfer_cnt,
+				   ASC_TENTHS(s->xfer_elem, s->xfer_cnt));
 		ASC_PRT_NEXT();
 
 		len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
-				   (s->sg_xfer / 2) / s->sg_elem,
-				   ASC_TENTHS((s->sg_xfer / 2), s->sg_elem));
+				   (s->xfer_sect / 2) / s->xfer_elem,
+				   ASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));
 		ASC_PRT_NEXT();
 
 		len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
-				   (s->sg_xfer / 2) / s->sg_cnt,
-				   ASC_TENTHS((s->sg_xfer / 2), s->sg_cnt));
+				   (s->xfer_sect / 2) / s->xfer_cnt,
+				   ASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));
 		ASC_PRT_NEXT();
 	}
 
-	/*
-	 * Display request queuing statistics.
-	 */
-	len = asc_prt_line(cp, leftlen,
-			   " Active and Waiting Request Queues (Time Unit: %d HZ):\n",
-			   HZ);
-	ASC_PRT_NEXT();
-
 	return totlen;
 }
 #endif /* ADVANSYS_STATS */
@@ -4301,18 +4272,8 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 
 static void asc_scsi_done(struct scsi_cmnd *scp)
 {
-	struct asc_board *boardp = shost_priv(scp->device->host);
-
-	if (scp->use_sg)
-		dma_unmap_sg(boardp->dev,
-			     (struct scatterlist *)scp->request_buffer,
-			     scp->use_sg, scp->sc_data_direction);
-	else if (scp->request_bufflen)
-		dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
-				 scp->request_bufflen, scp->sc_data_direction);
-
+	scsi_dma_unmap(scp);
 	ASC_STATS(scp->device->host, done);
-
 	scp->scsi_done(scp);
 }
 
@@ -8210,11 +8171,11 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 		 * then return the number of underrun bytes.
 		 */
 		resid_cnt = le32_to_cpu(scsiqp->data_cnt);
-		if (scp->request_bufflen != 0 && resid_cnt != 0 &&
-		    resid_cnt <= scp->request_bufflen) {
+		if (scsi_bufflen(scp) != 0 && resid_cnt != 0 &&
+		    resid_cnt <= scsi_bufflen(scp)) {
 			ASC_DBG(1, "underrun condition %lu bytes\n",
 				 (ulong)resid_cnt);
-			scp->resid = resid_cnt;
+			scsi_set_resid(scp, resid_cnt);
 		}
 		break;
 
@@ -9148,11 +9109,11 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 		 * If there was no error and an underrun condition, then
 		 * return the number of underrun bytes.
 		 */
-		if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
-		    qdonep->remain_bytes <= scp->request_bufflen) {
+		if (scsi_bufflen(scp) != 0 && qdonep->remain_bytes != 0 &&
+		    qdonep->remain_bytes <= scsi_bufflen(scp)) {
 			ASC_DBG(1, "underrun condition %u bytes\n",
 				 (unsigned)qdonep->remain_bytes);
-			scp->resid = qdonep->remain_bytes;
+			scsi_set_resid(scp, qdonep->remain_bytes);
 		}
 		break;
 
@@ -9877,6 +9838,8 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 			struct asc_scsi_q *asc_scsi_q)
 {
+	int use_sg;
+
 	memset(asc_scsi_q, 0, sizeof(*asc_scsi_q));
 
 	/*
@@ -9915,55 +9878,26 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 		asc_scsi_q->q2.tag_code = MSG_SIMPLE_TAG;
 	}
 
-	/*
-	 * Build ASC_SCSI_Q for a contiguous buffer or a scatter-gather
-	 * buffer command.
-	 */
-	if (scp->use_sg == 0) {
-		/*
-		 * CDB request of single contiguous buffer.
-		 */
-		ASC_STATS(scp->device->host, cont_cnt);
-		scp->SCp.dma_handle = scp->request_bufflen ?
-		    dma_map_single(boardp->dev, scp->request_buffer,
-				   scp->request_bufflen,
-				   scp->sc_data_direction) : 0;
-		asc_scsi_q->q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
-		asc_scsi_q->q1.data_cnt = cpu_to_le32(scp->request_bufflen);
-		ASC_STATS_ADD(scp->device->host, cont_xfer,
-			      ASC_CEILING(scp->request_bufflen, 512));
-		asc_scsi_q->q1.sg_queue_cnt = 0;
-		asc_scsi_q->sg_head = NULL;
-	} else {
-		/*
-		 * CDB scatter-gather request list.
-		 */
+	/* Build ASC_SCSI_Q */
+	use_sg = scsi_dma_map(scp);
+	if (use_sg != 0) {
 		int sgcnt;
-		int use_sg;
 		struct scatterlist *slp;
 		struct asc_sg_head *asc_sg_head;
 
-		slp = (struct scatterlist *)scp->request_buffer;
-		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
-				    scp->sc_data_direction);
-
 		if (use_sg > scp->device->host->sg_tablesize) {
 			scmd_printk(KERN_ERR, scp, "use_sg %d > "
 				"sg_tablesize %d\n", use_sg,
 				scp->device->host->sg_tablesize);
-			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
-				     scp->sc_data_direction);
+			scsi_dma_unmap(scp);
 			scp->result = HOST_BYTE(DID_ERROR);
 			return ASC_ERROR;
 		}
 
-		ASC_STATS(scp->device->host, sg_cnt);
-
 		asc_sg_head = kzalloc(sizeof(asc_scsi_q->sg_head) +
 			use_sg * sizeof(struct asc_sg_list), GFP_ATOMIC);
 		if (!asc_sg_head) {
-			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
-				     scp->sc_data_direction);
+			scsi_dma_unmap(scp);
 			scp->result = HOST_BYTE(DID_SOFT_ERROR);
 			return ASC_ERROR;
 		}
@@ -9974,22 +9908,24 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 		asc_scsi_q->q1.data_addr = 0;
 		/* This is a byte value, otherwise it would need to be swapped. */
 		asc_sg_head->entry_cnt = asc_scsi_q->q1.sg_queue_cnt = use_sg;
-		ASC_STATS_ADD(scp->device->host, sg_elem,
+		ASC_STATS_ADD(scp->device->host, xfer_elem,
 			      asc_sg_head->entry_cnt);
 
 		/*
 		 * Convert scatter-gather list into ASC_SG_HEAD list.
 		 */
-		for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
+		scsi_for_each_sg(scp, slp, use_sg, sgcnt) {
 			asc_sg_head->sg_list[sgcnt].addr =
 			    cpu_to_le32(sg_dma_address(slp));
 			asc_sg_head->sg_list[sgcnt].bytes =
 			    cpu_to_le32(sg_dma_len(slp));
-			ASC_STATS_ADD(scp->device->host, sg_xfer,
-				      ASC_CEILING(sg_dma_len(slp), 512));
+			ASC_STATS_ADD(scp->device->host, xfer_sect,
+				      DIV_ROUND_UP(sg_dma_len(slp), 512));
 		}
 	}
 
+	ASC_STATS(scp->device->host, xfer_cnt);
+
 	ASC_DBG_PRT_ASC_SCSI_Q(2, asc_scsi_q);
 	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
@@ -10021,7 +9957,7 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 	int i;
 
 	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
-	slp = (struct scatterlist *)scp->request_buffer;
+	slp = scsi_sglist(scp);
 	sg_elem_cnt = use_sg;
 	prev_sg_block = NULL;
 	reqp->sgblkp = NULL;
@@ -10093,8 +10029,8 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 					cpu_to_le32(sg_dma_address(slp));
 			sg_block->sg_list[i].sg_count =
 					cpu_to_le32(sg_dma_len(slp));
-			ASC_STATS_ADD(scp->device->host, sg_xfer,
-				      ASC_CEILING(sg_dma_len(slp), 512));
+			ASC_STATS_ADD(scp->device->host, xfer_sect,
+				      DIV_ROUND_UP(sg_dma_len(slp), 512));
 
 			if (--sg_elem_cnt == 0) {	/* Last ADV_SG_BLOCK and scatter-gather entry. */
 				sg_block->sg_cnt = i + 1;
@@ -10126,6 +10062,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	ADV_SCSI_REQ_Q *scsiqp;
 	int i;
 	int ret;
+	int use_sg;
 
 	/*
 	 * Allocate an adv_req_t structure from the board to execute
@@ -10182,54 +10119,24 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
 	scsiqp->sense_len = sizeof(scp->sense_buffer);
 
-	/*
-	 * Build ADV_SCSI_REQ_Q for a contiguous buffer or a scatter-gather
-	 * buffer command.
-	 */
+	/* Build ADV_SCSI_REQ_Q */
 
-	scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
-	scsiqp->vdata_addr = scp->request_buffer;
-	scsiqp->data_addr = cpu_to_le32(virt_to_bus(scp->request_buffer));
-
-	if (scp->use_sg == 0) {
-		/*
-		 * CDB request of single contiguous buffer.
-		 */
+	use_sg = scsi_dma_map(scp);
+	if (use_sg == 0) {
+		/* Zero-length transfer */
 		reqp->sgblkp = NULL;
-		scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
-		if (scp->request_bufflen) {
-			scsiqp->vdata_addr = scp->request_buffer;
-			scp->SCp.dma_handle =
-			    dma_map_single(boardp->dev, scp->request_buffer,
-					   scp->request_bufflen,
-					   scp->sc_data_direction);
-		} else {
-			scsiqp->vdata_addr = NULL;
-			scp->SCp.dma_handle = 0;
-		}
-		scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);
+		scsiqp->data_cnt = 0;
+		scsiqp->vdata_addr = NULL;
+
+		scsiqp->data_addr = 0;
 		scsiqp->sg_list_ptr = NULL;
 		scsiqp->sg_real_addr = 0;
-		ASC_STATS(scp->device->host, cont_cnt);
-		ASC_STATS_ADD(scp->device->host, cont_xfer,
-			      ASC_CEILING(scp->request_bufflen, 512));
 	} else {
-		/*
-		 * CDB scatter-gather request list.
-		 */
-		struct scatterlist *slp;
-		int use_sg;
-
-		slp = (struct scatterlist *)scp->request_buffer;
-		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
-				    scp->sc_data_direction);
-
 		if (use_sg > ADV_MAX_SG_LIST) {
 			scmd_printk(KERN_ERR, scp, "use_sg %d > "
 				   "ADV_MAX_SG_LIST %d\n", use_sg,
 				   scp->device->host->sg_tablesize);
-			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
-				     scp->sc_data_direction);
+			scsi_dma_unmap(scp);
 			scp->result = HOST_BYTE(DID_ERROR);
 
 			/*
@@ -10242,6 +10149,8 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 			return ASC_ERROR;
 		}
 
+		scsiqp->data_cnt = cpu_to_le32(scsi_bufflen(scp));
+
 		ret = adv_get_sglist(boardp, reqp, scp, use_sg);
 		if (ret != ADV_SUCCESS) {
 			/*
@@ -10254,10 +10163,11 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 			return ret;
 		}
 
-		ASC_STATS(scp->device->host, sg_cnt);
-		ASC_STATS_ADD(scp->device->host, sg_elem, use_sg);
+		ASC_STATS_ADD(scp->device->host, xfer_elem, use_sg);
 	}
 
+	ASC_STATS(scp->device->host, xfer_cnt);
+
 	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
 	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
@@ -10955,48 +10865,6 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 
 /*
  * Execute a single 'Scsi_Cmnd'.
- *
- * The function 'done' is called when the request has been completed.
- *
- * Scsi_Cmnd:
- *
- *  host - board controlling device
- *  device - device to send command
- *  target - target of device
- *  lun - lun of device
- *  cmd_len - length of SCSI CDB
- *  cmnd - buffer for SCSI 8, 10, or 12 byte CDB
- *  use_sg - if non-zero indicates scatter-gather request with use_sg elements
- *
- *  if (use_sg == 0) {
- *    request_buffer - buffer address for request
- *    request_bufflen - length of request buffer
- *  } else {
- *    request_buffer - pointer to scatterlist structure
- *  }
- *
- *  sense_buffer - sense command buffer
- *
- *  result (4 bytes of an int):
- *    Byte Meaning
- *    0 SCSI Status Byte Code
- *    1 SCSI One Byte Message Code
- *    2 Host Error Code
- *    3 Mid-Level Error Code
- *
- *  host driver fields:
- *    SCp - Scsi_Pointer used for command processing status
- *    scsi_done - used to save caller's done function
- *    host_scribble - used for pointer to another struct scsi_cmnd
- *
- * If this function returns ASC_NOERROR the request will be completed
- * from the interrupt handler.
- *
- * If this function returns ASC_ERROR the host error code has been set,
- * and the called must call asc_scsi_done.
- *
- * If ASC_BUSY is returned the request will be returned to the midlayer
- * and re-tried later.
  */
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 {

commit fd625f4705977de1ad00ac3cb519ec3ee8fd8598
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:38 2007 -0400

    [SCSI] advansys: Remove DvcGetPhyAddr
    
    This rather complex function boiled down to calling virt_to_bus().
    Also get rid of some obsolete defines and variables that could never vary.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0459c85b74b8..ab9108293d0f 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -992,19 +992,6 @@ typedef struct asc_mc_saved {
 #define ADV_MAX_SG_LIST         255
 #define NO_OF_SG_PER_BLOCK              15
 
-/* Number of SG blocks needed. */
-#define ADV_NUM_SG_BLOCK \
-    ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK)
-
-/* Total contiguous memory needed for SG blocks. */
-#define ADV_SG_TOTAL_MEM_SIZE \
-    (sizeof(ADV_SG_BLOCK) *  ADV_NUM_SG_BLOCK)
-
-#define ADV_PAGE_SIZE PAGE_SIZE
-
-#define ADV_NUM_PAGE_CROSSING \
-    ((ADV_SG_TOTAL_MEM_SIZE + (ADV_PAGE_SIZE - 1))/ADV_PAGE_SIZE)
-
 #define ADV_EEP_DVC_CFG_BEGIN           (0x00)
 #define ADV_EEP_DVC_CFG_END             (0x15)
 #define ADV_EEP_DVC_CTL_BEGIN           (0x16)	/* location of OEM name */
@@ -1792,8 +1779,7 @@ typedef struct adv_carr_t {
 #define ASC_GET_CARRP(carrp) ((carrp) & ASC_NEXT_VPA_MASK)
 
 #define ADV_CARRIER_NUM_PAGE_CROSSING \
-    (((ADV_CARRIER_COUNT * sizeof(ADV_CARR_T)) + \
-        (ADV_PAGE_SIZE - 1))/ADV_PAGE_SIZE)
+    (((ADV_CARRIER_COUNT * sizeof(ADV_CARR_T)) + (PAGE_SIZE - 1))/PAGE_SIZE)
 
 #define ADV_CARRIER_BUFSIZE \
     ((ADV_CARRIER_COUNT + ADV_CARRIER_NUM_PAGE_CROSSING) * sizeof(ADV_CARR_T))
@@ -2174,16 +2160,6 @@ do { \
 #define QHSTA_M_FROZEN_TIDQ         0x46	/* TID Queue frozen. */
 #define QHSTA_M_SGBACKUP_ERROR      0x47	/* Scatter-Gather backup error */
 
-/*
- * DvcGetPhyAddr() flag arguments
- */
-#define ADV_IS_SCSIQ_FLAG       0x01	/* 'addr' is ASC_SCSI_REQ_Q pointer */
-#define ADV_ASCGETSGLIST_VADDR  0x02	/* 'addr' is AscGetSGList() virtual addr */
-#define ADV_IS_SENSE_FLAG       0x04	/* 'addr' is sense virtual pointer */
-#define ADV_IS_DATA_FLAG        0x08	/* 'addr' is data virtual pointer */
-#define ADV_IS_SGLIST_FLAG      0x10	/* 'addr' is sglist virtual pointer */
-#define ADV_IS_CARRIER_FLAG     0x20	/* 'addr' is ADV_CARR_T pointer */
-
 /* Return the address that is aligned at the next doubleword >= to 'addr'. */
 #define ADV_8BALIGN(addr)      (((ulong) (addr) + 0x7) & ~0x7)
 #define ADV_16BALIGN(addr)     (((ulong) (addr) + 0xF) & ~0xF)
@@ -6483,29 +6459,6 @@ static int AdvLoadMicrocode(AdvPortAddr iop_base, unsigned char *buf, int size,
 	return 0;
 }
 
-/*
- * DvcGetPhyAddr()
- *
- * Return the physical address of 'vaddr' and set '*lenp' to the
- * number of physically contiguous bytes that follow 'vaddr'.
- * 'flag' indicates the type of structure whose physical address
- * is being translated.
- *
- * Note: Because Linux currently doesn't page the kernel and all
- * kernel buffers are physically contiguous, leave '*lenp' unchanged.
- */
-ADV_PADDR
-DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
-	      uchar *vaddr, ADV_SDCNT *lenp, int flag)
-{
-	ADV_PADDR paddr = virt_to_bus(vaddr);
-
-	ASC_DBG(4, "vaddr 0x%p, lenp 0x%p *lenp %lu, paddr 0x%lx\n",
-		 vaddr, lenp, (ulong)*((ulong *)lenp), (ulong)paddr);
-
-	return paddr;
-}
-
 static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
 {
 	ADV_CARR_T *carrp;
@@ -6522,24 +6475,10 @@ static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
 
 	do {
 		/* Get physical address of the carrier 'carrp'. */
-		ADV_DCNT contig_len = sizeof(ADV_CARR_T);
-		carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL,
-						       (uchar *)carrp,
-						       (ADV_SDCNT *)&contig_len,
-						       ADV_IS_CARRIER_FLAG));
+		carr_paddr = cpu_to_le32(virt_to_bus(carrp));
 
 		buf_size -= sizeof(ADV_CARR_T);
 
-		/*
-		 * If the current carrier is not physically contiguous, then
-		 * maybe there was a page crossing. Try the next carrier
-		 * aligned start address.
-		 */
-		if (contig_len < sizeof(ADV_CARR_T)) {
-			carrp++;
-			continue;
-		}
-
 		carrp->carr_pa = carr_paddr;
 		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
 
@@ -10915,7 +10854,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 {
 	AdvPortAddr iop_base;
-	ADV_DCNT req_size;
 	ADV_PADDR req_paddr;
 	ADV_CARR_T *new_carrp;
 
@@ -10953,13 +10891,8 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	 */
 	scsiq->a_flag &= ~ADV_SCSIQ_DONE;
 
-	req_size = sizeof(ADV_SCSI_REQ_Q);
-	req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *)scsiq,
-				  (ADV_SDCNT *)&req_size, ADV_IS_SCSIQ_FLAG);
-
+	req_paddr = virt_to_bus(scsiq);
 	BUG_ON(req_paddr & 31);
-	BUG_ON(req_size < sizeof(ADV_SCSI_REQ_Q));
-
 	/* Wait for assertion before making little-endian */
 	req_paddr = cpu_to_le32(req_paddr);
 

commit 98d41c29a4b38c5b5e8ce5e13c4f3ac852615e0b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:37 2007 -0400

    [SCSI] advansys: Move a couple of fields from struct board to struct adv_dvc
    
    board->carrp is a duplicate of asc_dvc->carrier_buf, so cut out the
    middle-man and assign directly to carrier_buf.  Move orig_reqp to adv_dvc
    too, since it's wide-board specific.  Also eliminate an unnecessary BUG_ON
    (we'll never get there with a NULL carrier_buf, and will crash if we do).
    The bulk of this patch is rearranging structures so everything's declared
    in the right order.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 93b1a47ebaf8..0459c85b74b8 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -983,15 +983,14 @@ typedef struct asc_mc_saved {
  * elements. Allow each command to have at least one ADV_SG_BLOCK structure.
  * This allows about 15 commands to have the maximum 17 ADV_SG_BLOCK
  * structures or 255 scatter-gather elements.
- *
  */
 #define ADV_TOT_SG_BLOCK        ASC_DEF_MAX_HOST_QNG
 
 /*
- * Define Adv Library required maximum number of scatter-gather
- * elements per request.
+ * Define maximum number of scatter-gather elements per request.
  */
 #define ADV_MAX_SG_LIST         255
+#define NO_OF_SG_PER_BLOCK              15
 
 /* Number of SG blocks needed. */
 #define ADV_NUM_SG_BLOCK \
@@ -1839,55 +1838,6 @@ typedef struct adv_dvc_cfg {
 struct adv_dvc_var;
 struct adv_scsi_req_q;
 
-/*
- * Adapter operation variable structure.
- *
- * One structure is required per host adapter.
- *
- * Field naming convention:
- *
- *  *_able indicates both whether a feature should be enabled or disabled
- *  and whether a device isi capable of the feature. At initialization
- *  this field may be set, but later if a device is found to be incapable
- *  of the feature, the field is cleared.
- */
-typedef struct adv_dvc_var {
-	AdvPortAddr iop_base;	/* I/O port address */
-	ushort err_code;	/* fatal error code */
-	ushort bios_ctrl;	/* BIOS control word, EEPROM word 12 */
-	ushort wdtr_able;	/* try WDTR for a device */
-	ushort sdtr_able;	/* try SDTR for a device */
-	ushort ultra_able;	/* try SDTR Ultra speed for a device */
-	ushort sdtr_speed1;	/* EEPROM SDTR Speed for TID 0-3   */
-	ushort sdtr_speed2;	/* EEPROM SDTR Speed for TID 4-7   */
-	ushort sdtr_speed3;	/* EEPROM SDTR Speed for TID 8-11  */
-	ushort sdtr_speed4;	/* EEPROM SDTR Speed for TID 12-15 */
-	ushort tagqng_able;	/* try tagged queuing with a device */
-	ushort ppr_able;	/* PPR message capable per TID bitmask. */
-	uchar max_dvc_qng;	/* maximum number of tagged commands per device */
-	ushort start_motor;	/* start motor command allowed */
-	uchar scsi_reset_wait;	/* delay in seconds after scsi bus reset */
-	uchar chip_no;		/* should be assigned by caller */
-	uchar max_host_qng;	/* maximum number of Q'ed command allowed */
-	ushort no_scam;		/* scam_tolerant of EEPROM */
-	struct asc_board *drv_ptr;	/* driver pointer to private structure */
-	uchar chip_scsi_id;	/* chip SCSI target ID */
-	uchar chip_type;
-	uchar bist_err_code;
-	ADV_CARR_T *carrier_buf;
-	ADV_CARR_T *carr_freelist;	/* Carrier free list. */
-	ADV_CARR_T *icq_sp;	/* Initiator command queue stopper pointer. */
-	ADV_CARR_T *irq_sp;	/* Initiator response queue stopper pointer. */
-	ushort carr_pending_cnt;	/* Count of pending carriers. */
-	/*
-	 * Note: The following fields will not be used after initialization. The
-	 * driver may discard the buffer after initialization is done.
-	 */
-	ADV_DVC_CFG *cfg;	/* temporary configuration structure  */
-} ADV_DVC_VAR;
-
-#define NO_OF_SG_PER_BLOCK              15
-
 typedef struct asc_sg_block {
 	uchar reserved1;
 	uchar reserved2;
@@ -1945,6 +1895,83 @@ typedef struct adv_scsi_req_q {
 	uchar pad[2];		/* Pad out to a word boundary. */
 } ADV_SCSI_REQ_Q;
 
+/*
+ * The following two structures are used to process Wide Board requests.
+ *
+ * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library
+ * and microcode with the ADV_SCSI_REQ_Q field 'srb_ptr' pointing to the
+ * adv_req_t. The adv_req_t structure 'cmndp' field in turn points to the
+ * Mid-Level SCSI request structure.
+ *
+ * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each
+ * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux
+ * up to 255 scatter-gather elements may be used per request or
+ * ADV_SCSI_REQ_Q.
+ *
+ * Both structures must be 32 byte aligned.
+ */
+typedef struct adv_sgblk {
+	ADV_SG_BLOCK sg_block;	/* Sgblock structure. */
+	uchar align[32];	/* Sgblock structure padding. */
+	struct adv_sgblk *next_sgblkp;	/* Next scatter-gather structure. */
+} adv_sgblk_t;
+
+typedef struct adv_req {
+	ADV_SCSI_REQ_Q scsi_req_q;	/* Adv Library request structure. */
+	uchar align[32];	/* Request structure padding. */
+	struct scsi_cmnd *cmndp;	/* Mid-Level SCSI command pointer. */
+	adv_sgblk_t *sgblkp;	/* Adv Library scatter-gather pointer. */
+	struct adv_req *next_reqp;	/* Next Request Structure. */
+} adv_req_t;
+
+/*
+ * Adapter operation variable structure.
+ *
+ * One structure is required per host adapter.
+ *
+ * Field naming convention:
+ *
+ *  *_able indicates both whether a feature should be enabled or disabled
+ *  and whether a device isi capable of the feature. At initialization
+ *  this field may be set, but later if a device is found to be incapable
+ *  of the feature, the field is cleared.
+ */
+typedef struct adv_dvc_var {
+	AdvPortAddr iop_base;	/* I/O port address */
+	ushort err_code;	/* fatal error code */
+	ushort bios_ctrl;	/* BIOS control word, EEPROM word 12 */
+	ushort wdtr_able;	/* try WDTR for a device */
+	ushort sdtr_able;	/* try SDTR for a device */
+	ushort ultra_able;	/* try SDTR Ultra speed for a device */
+	ushort sdtr_speed1;	/* EEPROM SDTR Speed for TID 0-3   */
+	ushort sdtr_speed2;	/* EEPROM SDTR Speed for TID 4-7   */
+	ushort sdtr_speed3;	/* EEPROM SDTR Speed for TID 8-11  */
+	ushort sdtr_speed4;	/* EEPROM SDTR Speed for TID 12-15 */
+	ushort tagqng_able;	/* try tagged queuing with a device */
+	ushort ppr_able;	/* PPR message capable per TID bitmask. */
+	uchar max_dvc_qng;	/* maximum number of tagged commands per device */
+	ushort start_motor;	/* start motor command allowed */
+	uchar scsi_reset_wait;	/* delay in seconds after scsi bus reset */
+	uchar chip_no;		/* should be assigned by caller */
+	uchar max_host_qng;	/* maximum number of Q'ed command allowed */
+	ushort no_scam;		/* scam_tolerant of EEPROM */
+	struct asc_board *drv_ptr;	/* driver pointer to private structure */
+	uchar chip_scsi_id;	/* chip SCSI target ID */
+	uchar chip_type;
+	uchar bist_err_code;
+	ADV_CARR_T *carrier_buf;
+	ADV_CARR_T *carr_freelist;	/* Carrier free list. */
+	ADV_CARR_T *icq_sp;	/* Initiator command queue stopper pointer. */
+	ADV_CARR_T *irq_sp;	/* Initiator response queue stopper pointer. */
+	ushort carr_pending_cnt;	/* Count of pending carriers. */
+	struct adv_req *orig_reqp;	/* adv_req_t memory block. */
+	/*
+	 * Note: The following fields will not be used after initialization. The
+	 * driver may discard the buffer after initialization is done.
+	 */
+	ADV_DVC_CFG *cfg;	/* temporary configuration structure  */
+} ADV_DVC_VAR;
+
 /*
  * Microcode idle loop commands
  */
@@ -2361,37 +2388,6 @@ struct asc_stats {
 };
 #endif /* ADVANSYS_STATS */
 
-/*
- * Adv Library Request Structures
- *
- * The following two structures are used to process Wide Board requests.
- *
- * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library
- * and microcode with the ADV_SCSI_REQ_Q field 'srb_ptr' pointing to the
- * adv_req_t. The adv_req_t structure 'cmndp' field in turn points to the
- * Mid-Level SCSI request structure.
- *
- * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each
- * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux
- * up to 255 scatter-gather elements may be used per request or
- * ADV_SCSI_REQ_Q.
- *
- * Both structures must be 32 byte aligned.
- */
-typedef struct adv_sgblk {
-	ADV_SG_BLOCK sg_block;	/* Sgblock structure. */
-	uchar align[32];	/* Sgblock structure padding. */
-	struct adv_sgblk *next_sgblkp;	/* Next scatter-gather structure. */
-} adv_sgblk_t;
-
-typedef struct adv_req {
-	ADV_SCSI_REQ_Q scsi_req_q;	/* Adv Library request structure. */
-	uchar align[32];	/* Request structure padding. */
-	struct scsi_cmnd *cmndp;	/* Mid-Level SCSI command pointer. */
-	adv_sgblk_t *sgblkp;	/* Adv Library scatter-gather pointer. */
-	struct adv_req *next_reqp;	/* Next Request Structure. */
-} adv_req_t;
-
 /*
  * Structure allocated for each board.
  *
@@ -2437,8 +2433,6 @@ struct asc_board {
 	 */
 	void __iomem *ioremap_addr;	/* I/O Memory remap address. */
 	ushort ioport;		/* I/O Port address. */
-	ADV_CARR_T *carrp;	/* ADV_CARR_T memory block. */
-	adv_req_t *orig_reqp;	/* adv_req_t memory block. */
 	adv_req_t *adv_reqp;	/* Request structures. */
 	adv_sgblk_t *adv_sgblkp;	/* Scatter-gather structures. */
 	ushort bios_signature;	/* BIOS Signature. */
@@ -6518,8 +6512,6 @@ static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
 	ADV_SDCNT buf_size;
 	ADV_PADDR carr_paddr;
 
-	BUG_ON(!asc_dvc->carrier_buf);
-
 	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
 	asc_dvc->carr_freelist = NULL;
 	if (carrp == asc_dvc->carrier_buf) {
@@ -13442,10 +13434,10 @@ static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
 	 * Allocate buffer carrier structures. The total size
 	 * is about 4 KB, so allocate all at once.
 	 */
-	board->carrp = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
-	ASC_DBG(1, "carrp 0x%p\n", board->carrp);
+	adv_dvc->carrier_buf = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
+	ASC_DBG(1, "carrier_buf 0x%p\n", adv_dvc->carrier_buf);
 
-	if (!board->carrp)
+	if (!adv_dvc->carrier_buf)
 		goto kmalloc_failed;
 
 	/*
@@ -13466,7 +13458,7 @@ static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
 	if (!reqp)
 		goto kmalloc_failed;
 
-	board->orig_reqp = reqp;
+	adv_dvc->orig_reqp = reqp;
 
 	/*
 	 * Allocate up to ADV_TOT_SG_BLOCK request structures for
@@ -13490,8 +13482,6 @@ static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
 	if (!board->adv_sgblkp)
 		goto kmalloc_failed;
 
-	adv_dvc->carrier_buf = board->carrp;
-
 	/*
 	 * Point 'adv_reqp' to the request structures and
 	 * link them together.
@@ -13529,15 +13519,16 @@ static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
 	return err_code;
 }
 
-static void advansys_wide_free_mem(struct asc_board *boardp)
+static void advansys_wide_free_mem(struct asc_board *board)
 {
-	kfree(boardp->carrp);
-	boardp->carrp = NULL;
-	kfree(boardp->orig_reqp);
-	boardp->orig_reqp = boardp->adv_reqp = NULL;
-	while (boardp->adv_sgblkp) {
-		adv_sgblk_t *sgp = boardp->adv_sgblkp;
-		boardp->adv_sgblkp = sgp->next_sgblkp;
+	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
+	kfree(adv_dvc->carrier_buf);
+	adv_dvc->carrier_buf = NULL;
+	kfree(adv_dvc->orig_reqp);
+	adv_dvc->orig_reqp = board->adv_reqp = NULL;
+	while (board->adv_sgblkp) {
+		adv_sgblk_t *sgp = board->adv_sgblkp;
+		board->adv_sgblkp = sgp->next_sgblkp;
 		kfree(sgp);
 	}
 }

commit afbb68c35f4bdf0964d88e9e005e6f62ba57d134
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:36 2007 -0400

    [SCSI] advansys: Make sdtr_period_tbl a pointer
    
    It's somewhat neater to make this a pointer to one of two tables
    than initialising an array in the driver.  Also delete the unused
    AscSynIndexToPeriod and rename host_init_sdtr_index to min_sdtr_index
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 93bf3ec514b8..93b1a47ebaf8 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -481,34 +481,22 @@ typedef struct asc_risc_sg_list_q {
 #define ASC_MAX_PCI_INRAM_TOTAL_QNG  20
 #define ASC_MAX_INRAM_TAG_QNG   16
 #define ASC_IOADR_GAP   0x10
-#define ASC_MAX_SYN_XFER_NO        16
 #define ASC_SYN_MAX_OFFSET         0x0F
 #define ASC_DEF_SDTR_OFFSET        0x0F
 #define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02
-#define SYN_XFER_NS_0  25
-#define SYN_XFER_NS_1  30
-#define SYN_XFER_NS_2  35
-#define SYN_XFER_NS_3  40
-#define SYN_XFER_NS_4  50
-#define SYN_XFER_NS_5  60
-#define SYN_XFER_NS_6  70
-#define SYN_XFER_NS_7  85
-#define SYN_ULTRA_XFER_NS_0    12
-#define SYN_ULTRA_XFER_NS_1    19
-#define SYN_ULTRA_XFER_NS_2    25
-#define SYN_ULTRA_XFER_NS_3    32
-#define SYN_ULTRA_XFER_NS_4    38
-#define SYN_ULTRA_XFER_NS_5    44
-#define SYN_ULTRA_XFER_NS_6    50
-#define SYN_ULTRA_XFER_NS_7    57
-#define SYN_ULTRA_XFER_NS_8    63
-#define SYN_ULTRA_XFER_NS_9    69
-#define SYN_ULTRA_XFER_NS_10   75
-#define SYN_ULTRA_XFER_NS_11   82
-#define SYN_ULTRA_XFER_NS_12   88
-#define SYN_ULTRA_XFER_NS_13   94
-#define SYN_ULTRA_XFER_NS_14  100
-#define SYN_ULTRA_XFER_NS_15  107
+#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41
+
+/* The narrow chip only supports a limited selection of transfer rates.
+ * These are encoded in the range 0..7 or 0..15 depending whether the chip
+ * is Ultra-capable or not.  These tables let us convert from one to the other.
+ */
+static const unsigned char asc_syn_xfer_period[8] = {
+	25, 30, 35, 40, 50, 60, 70, 85
+};
+
+static const unsigned char asc_syn_ultra_xfer_period[16] = {
+	12, 19, 25, 32, 38, 44, 50, 57, 63, 69, 75, 82, 88, 94, 100, 107
+};
 
 typedef struct ext_msg {
 	uchar msg_type;
@@ -572,7 +560,6 @@ typedef struct asc_dvc_cfg {
 #define ASC_INIT_STATE_WITHOUT_EEP   0x8000
 #define ASC_BUG_FIX_IF_NOT_DWB       0x0001
 #define ASC_BUG_FIX_ASYN_USE_SYN     0x0002
-#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41
 #define ASC_MIN_TAGGED_CMD  7
 #define ASC_MAX_SCSI_RESET_WAIT      30
 
@@ -602,7 +589,7 @@ typedef struct asc_dvc_var {
 	uchar max_dvc_qng[ASC_MAX_TID + 1];
 	ASC_SCSI_Q *scsiq_busy_head[ASC_MAX_TID + 1];
 	ASC_SCSI_Q *scsiq_busy_tail[ASC_MAX_TID + 1];
-	uchar sdtr_period_tbl[ASC_MAX_SYN_XFER_NO];
+	const uchar *sdtr_period_tbl;
 	ASC_DVC_CFG *cfg;
 	ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always;
 	char redo_scam;
@@ -611,8 +598,8 @@ typedef struct asc_dvc_var {
 	ASC_DCNT max_dma_count;
 	ASC_SCSI_BIT_ID_TYPE no_scam;
 	ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;
+	uchar min_sdtr_index;
 	uchar max_sdtr_index;
-	uchar host_init_sdtr_index;
 	struct asc_board *drv_ptr;
 	ASC_DCNT uc_break;
 } ASC_DVC_VAR;
@@ -896,7 +883,6 @@ typedef struct asc_mc_saved {
 #define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id))
 #define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data)
 #define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id))
-#define AscSynIndexToPeriod(index)        (uchar)(asc_dvc->sdtr_period_tbl[ (index) ])
 #define AscGetChipSignatureByte(port)     (uchar)inp((port)+IOP_SIG_BYTE)
 #define AscGetChipSignatureWord(port)     (ushort)inpw((port)+IOP_SIG_WORD)
 #define AscGetChipVerNo(port)             (uchar)inp((port)+IOP_VERSION)
@@ -8556,14 +8542,14 @@ static void AscAckInterrupt(PortAddr iop_base)
 
 static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)
 {
-	uchar *period_table;
+	const uchar *period_table;
 	int max_index;
 	int min_index;
 	int i;
 
 	period_table = asc_dvc->sdtr_period_tbl;
 	max_index = (int)asc_dvc->max_sdtr_index;
-	min_index = (int)asc_dvc->host_init_sdtr_index;
+	min_index = (int)asc_dvc->min_sdtr_index;
 	if ((syn_time <= period_table[max_index])) {
 		for (i = min_index; i < (max_index - 1); i++) {
 			if (syn_time <= period_table[i]) {
@@ -8612,9 +8598,8 @@ AscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)
 	uchar sdtr_period_ix;
 
 	sdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
-	if (sdtr_period_ix > asc_dvc->max_sdtr_index) {
+	if (sdtr_period_ix > asc_dvc->max_sdtr_index)
 		return 0xFF;
-	}
 	byte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);
 	return byte;
 }
@@ -8725,15 +8710,14 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 				ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
 			}
 			if ((ext_msg.xfer_period <
-			     asc_dvc->sdtr_period_tbl[asc_dvc->
-						      host_init_sdtr_index])
+			     asc_dvc->sdtr_period_tbl[asc_dvc->min_sdtr_index])
 			    || (ext_msg.xfer_period >
 				asc_dvc->sdtr_period_tbl[asc_dvc->
 							 max_sdtr_index])) {
 				sdtr_accept = FALSE;
 				ext_msg.xfer_period =
 				    asc_dvc->sdtr_period_tbl[asc_dvc->
-							     host_init_sdtr_index];
+							     min_sdtr_index];
 			}
 			if (sdtr_accept) {
 				sdtr_data =
@@ -8757,7 +8741,6 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 				AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
 			} else {
 				if (sdtr_accept && (q_cntl & QC_MSG_OUT)) {
-
 					q_cntl &= ~QC_MSG_OUT;
 					asc_dvc->sdtr_done |= target_id;
 					asc_dvc->init_sdtr |= target_id;
@@ -8772,7 +8755,6 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 						       tid_no);
 					boardp->sdtr_data[tid_no] = sdtr_data;
 				} else {
-
 					q_cntl |= QC_MSG_OUT;
 					AscMsgOutSDTR(asc_dvc,
 						      ext_msg.xfer_period,
@@ -11407,7 +11389,7 @@ static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	asc_dvc->queue_full_or_busy = 0;
 	asc_dvc->redo_scam = 0;
 	asc_dvc->res2 = 0;
-	asc_dvc->host_init_sdtr_index = 0;
+	asc_dvc->min_sdtr_index = 0;
 	asc_dvc->cfg->can_tagged_qng = 0;
 	asc_dvc->cfg->cmd_qng_enabled = 0;
 	asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;
@@ -11421,34 +11403,12 @@ static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
 	chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
 	asc_dvc->cfg->chip_version = chip_version;
-	asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
-	asc_dvc->sdtr_period_tbl[1] = SYN_XFER_NS_1;
-	asc_dvc->sdtr_period_tbl[2] = SYN_XFER_NS_2;
-	asc_dvc->sdtr_period_tbl[3] = SYN_XFER_NS_3;
-	asc_dvc->sdtr_period_tbl[4] = SYN_XFER_NS_4;
-	asc_dvc->sdtr_period_tbl[5] = SYN_XFER_NS_5;
-	asc_dvc->sdtr_period_tbl[6] = SYN_XFER_NS_6;
-	asc_dvc->sdtr_period_tbl[7] = SYN_XFER_NS_7;
+	asc_dvc->sdtr_period_tbl = asc_syn_xfer_period;
 	asc_dvc->max_sdtr_index = 7;
 	if ((asc_dvc->bus_type & ASC_IS_PCI) &&
 	    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {
 		asc_dvc->bus_type = ASC_IS_PCI_ULTRA;
-		asc_dvc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;
-		asc_dvc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;
-		asc_dvc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;
-		asc_dvc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;
-		asc_dvc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;
-		asc_dvc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;
-		asc_dvc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;
-		asc_dvc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;
-		asc_dvc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;
-		asc_dvc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;
-		asc_dvc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;
-		asc_dvc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;
-		asc_dvc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;
-		asc_dvc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;
-		asc_dvc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;
-		asc_dvc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;
+		asc_dvc->sdtr_period_tbl = asc_syn_ultra_xfer_period;
 		asc_dvc->max_sdtr_index = 15;
 		if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {
 			AscSetExtraControl(iop_base,
@@ -11889,7 +11849,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
 	if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&
 	    !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {
-		asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
+		asc_dvc->min_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
 	}
 
 	for (i = 0; i <= ASC_MAX_TID; i++) {
@@ -11897,7 +11857,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 		asc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;
 		asc_dvc->cfg->sdtr_period_offset[i] =
 		    (uchar)(ASC_DEF_SDTR_OFFSET |
-			    (asc_dvc->host_init_sdtr_index << 4));
+			    (asc_dvc->min_sdtr_index << 4));
 	}
 	eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
 	if (write_eep) {

commit 9d0e96eba19e9973a1c21ddd1fdbc049b231bf3b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:35 2007 -0400

    [SCSI] advansys: Get rid of board index number
    
    It's always a mistake to have your own index of boards; just use the
    scsi host number.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index a4091ab8d363..93bf3ec514b8 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -66,8 +66,7 @@
  *  5. check DMA mapping functions for failure
  *  6. Use scsi_transport_spi
  *  7. advansys_info is not safe against multiple simultaneous callers
- *  8. Kill boardp->id
- *  9. Add module_param to override ISA/VLB ioport array
+ *  8. Add module_param to override ISA/VLB ioport array
  */
 #warning this driver is still not properly converted to the DMA API
 
@@ -2416,7 +2415,6 @@ typedef struct adv_req {
  */
 struct asc_board {
 	struct device *dev;
-	int id;			/* Board Id */
 	uint flags;		/* Board flags */
 	unsigned int irq;
 	union {
@@ -2467,9 +2465,6 @@ struct asc_board {
 							dvc_var.adv_dvc_var)
 #define adv_dvc_to_pdev(adv_dvc) to_pci_dev(adv_dvc_to_board(adv_dvc)->dev)
 
-/* Number of boards detected in system. */
-static int asc_board_count;
-
 /* Overrun buffer used by all narrow boards. */
 static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 
@@ -2848,9 +2843,8 @@ static const char *advansys_info(struct Scsi_Host *shost)
 				}
 			} else {
 				busname = "?";
-				ASC_PRINT2("advansys_info: board %d: unknown "
-					   "bus type %d\n", boardp->id,
-					   asc_dvc_varp->bus_type);
+				shost_printk(KERN_ERR, shost, "unknown bus "
+					"type %d\n", asc_dvc_varp->bus_type);
 			}
 			sprintf(info,
 				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
@@ -4382,7 +4376,6 @@ static void AscSetBank(PortAddr iop_base, uchar bank)
 		val &= ~CC_BANK_ONE;
 	}
 	AscSetChipControl(iop_base, val);
-	return;
 }
 
 static void AscSetChipIH(PortAddr iop_base, ushort ins_code)
@@ -4390,7 +4383,6 @@ static void AscSetChipIH(PortAddr iop_base, ushort ins_code)
 	AscSetBank(iop_base, 1);
 	AscWriteChipIH(iop_base, ins_code);
 	AscSetBank(iop_base, 0);
-	return;
 }
 
 static int AscStartChip(PortAddr iop_base)
@@ -4475,7 +4467,6 @@ static void AscEnableInterrupt(PortAddr iop_base)
 
 	cfg = AscGetChipCfgLsw(iop_base);
 	AscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);
-	return;
 }
 
 static void AscDisableInterrupt(PortAddr iop_base)
@@ -4484,7 +4475,6 @@ static void AscDisableInterrupt(PortAddr iop_base)
 
 	cfg = AscGetChipCfgLsw(iop_base);
 	AscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));
-	return;
 }
 
 static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
@@ -4542,7 +4532,6 @@ static void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)
 {
 	AscSetChipLramAddr(iop_base, addr);
 	AscSetChipLramData(iop_base, word_val);
-	return;
 }
 
 static void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)
@@ -4560,7 +4549,6 @@ static void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)
 		word_data |= ((ushort)byte_val & 0x00FF);
 	}
 	AscWriteLramWord(iop_base, addr, word_data);
-	return;
 }
 
 /*
@@ -4588,7 +4576,6 @@ AscMemWordCopyPtrToLram(PortAddr iop_base,
 		outpw(iop_base + IOP_RAM_DATA,
 		      ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);
 	}
-	return;
 }
 
 /*
@@ -4608,7 +4595,6 @@ AscMemDWordCopyPtrToLram(PortAddr iop_base,
 		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);	/* LSW */
 		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);	/* MSW */
 	}
-	return;
 }
 
 /*
@@ -4630,7 +4616,6 @@ AscMemWordCopyPtrFromLram(PortAddr iop_base,
 		d_buffer[i] = word & 0xff;
 		d_buffer[i + 1] = (word >> 8) & 0xff;
 	}
-	return;
 }
 
 static ASC_DCNT AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
@@ -8397,8 +8382,6 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	boardp->adv_reqp = reqp;
 
 	ASC_DBG(1, "done\n");
-
-	return;
 }
 
 /*
@@ -8569,7 +8552,6 @@ static void AscAckInterrupt(PortAddr iop_base)
 		}
 	}
 	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
-	return;
 }
 
 static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)
@@ -9325,8 +9307,6 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	}
 
 	asc_scsi_done(scp);
-
-	return;
 }
 
 static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
@@ -10055,9 +10035,9 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 				    scp->sc_data_direction);
 
 		if (use_sg > scp->device->host->sg_tablesize) {
-			ASC_PRINT3("asc_build_req: board %d: use_sg %d > "
-				   "sg_tablesize %d\n", boardp->id, use_sg,
-				   scp->device->host->sg_tablesize);
+			scmd_printk(KERN_ERR, scp, "use_sg %d > "
+				"sg_tablesize %d\n", use_sg,
+				scp->device->host->sg_tablesize);
 			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
 				     scp->sc_data_direction);
 			scp->result = HOST_BYTE(DID_ERROR);
@@ -10332,8 +10312,8 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 				    scp->sc_data_direction);
 
 		if (use_sg > ADV_MAX_SG_LIST) {
-			ASC_PRINT3("adv_build_req: board %d: use_sg %d > "
-				   "ADV_MAX_SG_LIST %d\n", boardp->id, use_sg,
+			scmd_printk(KERN_ERR, scp, "use_sg %d > "
+				   "ADV_MAX_SG_LIST %d\n", use_sg,
 				   scp->device->host->sg_tablesize);
 			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
 				     scp->sc_data_direction);
@@ -11174,14 +11154,14 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		ASC_STATS(scp->device->host, exe_busy);
 		break;
 	case ASC_ERROR:
-		ASC_PRINT2("asc_execute_scsi_cmnd: board %d: ExeScsiQueue() "
-			   "ASC_ERROR, err_code 0x%x\n", boardp->id, err_code);
+		scmd_printk(KERN_ERR, scp, "ExeScsiQueue() ASC_ERROR, "
+			"err_code 0x%x\n", err_code);
 		ASC_STATS(scp->device->host, exe_error);
 		scp->result = HOST_BYTE(DID_ERROR);
 		break;
 	default:
-		ASC_PRINT2("asc_execute_scsi_cmnd: board %d: ExeScsiQueue() "
-			   "unknown, err_code 0x%x\n", boardp->id, err_code);
+		scmd_printk(KERN_ERR, scp, "ExeScsiQueue() unknown, "
+			"err_code 0x%x\n", err_code);
 		ASC_STATS(scp->device->host, exe_unknown);
 		scp->result = HOST_BYTE(DID_ERROR);
 		break;
@@ -11314,7 +11294,6 @@ static void __devinit AscEnableIsaDma(uchar dma_channel)
 		outp(0x00D6, (ushort)(0xC0 | (dma_channel - 4)));
 		outp(0x00D4, (ushort)(dma_channel - 4));
 	}
-	return;
 }
 #endif /* CONFIG_ISA */
 
@@ -11613,7 +11592,6 @@ static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 static void __devinit AscWaitEEPWrite(void)
 {
 	mdelay(20);
-	return;
 }
 
 static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
@@ -11936,9 +11914,10 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static int __devinit AscInitGetConfig(struct asc_board *boardp)
+static int __devinit AscInitGetConfig(struct Scsi_Host *shost)
 {
-	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
+	struct asc_board *board = shost_priv(shost);
+	ASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;
 	unsigned short warn_code = 0;
 
 	asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
@@ -11959,43 +11938,40 @@ static int __devinit AscInitGetConfig(struct asc_board *boardp)
 	case 0:	/* No error */
 		break;
 	case ASC_WARN_IO_PORT_ROTATE:
-		ASC_PRINT1("AscInitGetConfig: board %d: I/O port address "
-			   "modified\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "I/O port address "
+				"modified\n");
 		break;
 	case ASC_WARN_AUTO_CONFIG:
-		ASC_PRINT1("AscInitGetConfig: board %d: I/O port increment "
-			   "switch enabled\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "I/O port increment switch "
+				"enabled\n");
 		break;
 	case ASC_WARN_EEPROM_CHKSUM:
-		ASC_PRINT1("AscInitGetConfig: board %d: EEPROM checksum "
-			   "error\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "EEPROM checksum error\n");
 		break;
 	case ASC_WARN_IRQ_MODIFIED:
-		ASC_PRINT1("AscInitGetConfig: board %d: IRQ modified\n",
-			   boardp->id);
+		shost_printk(KERN_WARNING, shost, "IRQ modified\n");
 		break;
 	case ASC_WARN_CMD_QNG_CONFLICT:
-		ASC_PRINT1("AscInitGetConfig: board %d: tag queuing enabled "
-			   "w/o disconnects\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "tag queuing enabled w/o "
+				"disconnects\n");
 		break;
 	default:
-		ASC_PRINT2("AscInitGetConfig: board %d: unknown warning: "
-			   "0x%x\n", boardp->id, warn_code);
+		shost_printk(KERN_WARNING, shost, "unknown warning: 0x%x\n",
+				warn_code);
 		break;
 	}
 
-	if (asc_dvc->err_code != 0) {
-		ASC_PRINT3("AscInitGetConfig: board %d error: init_state 0x%x, "
-			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
-			   asc_dvc->err_code);
-	}
+	if (asc_dvc->err_code != 0)
+		shost_printk(KERN_ERR, shost, "error 0x%x at init_state "
+			"0x%x\n", asc_dvc->err_code, asc_dvc->init_state);
 
 	return asc_dvc->err_code;
 }
 
-static int __devinit AscInitSetConfig(struct pci_dev *pdev, struct asc_board *boardp)
+static int __devinit AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
 {
-	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
+	struct asc_board *board = shost_priv(shost);
+	ASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;
 	PortAddr iop_base = asc_dvc->iop_base;
 	unsigned short cfg_msw;
 	unsigned short warn_code = 0;
@@ -12060,37 +12036,32 @@ static int __devinit AscInitSetConfig(struct pci_dev *pdev, struct asc_board *bo
 	case 0:	/* No error. */
 		break;
 	case ASC_WARN_IO_PORT_ROTATE:
-		ASC_PRINT1("AscInitSetConfig: board %d: I/O port address "
-			   "modified\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "I/O port address "
+				"modified\n");
 		break;
 	case ASC_WARN_AUTO_CONFIG:
-		ASC_PRINT1("AscInitSetConfig: board %d: I/O port increment "
-			   "switch enabled\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "I/O port increment switch "
+				"enabled\n");
 		break;
 	case ASC_WARN_EEPROM_CHKSUM:
-		ASC_PRINT1("AscInitSetConfig: board %d: EEPROM checksum "
-			   "error\n", boardp->id);
+		shost_printk(KERN_WARNING, shost, "EEPROM checksum error\n");
 		break;
 	case ASC_WARN_IRQ_MODIFIED:
-		ASC_PRINT1("AscInitSetConfig: board %d: IRQ modified\n",
-			   boardp->id);
+		shost_printk(KERN_WARNING, shost, "IRQ modified\n");
 		break;
 	case ASC_WARN_CMD_QNG_CONFLICT:
-		ASC_PRINT1("AscInitSetConfig: board %d: tag queuing w/o "
-			   "disconnects\n",
-		     boardp->id);
+		shost_printk(KERN_WARNING, shost, "tag queuing w/o "
+				"disconnects\n");
 		break;
 	default:
-		ASC_PRINT2("AscInitSetConfig: board %d: unknown warning: "
-			   "0x%x\n", boardp->id, warn_code);
+		shost_printk(KERN_WARNING, shost, "unknown warning: 0x%x\n",
+				warn_code);
 		break;
 	}
 
-	if (asc_dvc->err_code != 0) {
-		ASC_PRINT3("AscInitSetConfig: board %d error: init_state 0x%x, "
-			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
-			   asc_dvc->err_code);
-	}
+	if (asc_dvc->err_code != 0)
+		shost_printk(KERN_ERR, shost, "error 0x%x at init_state "
+			"0x%x\n", asc_dvc->err_code, asc_dvc->init_state);
 
 	return asc_dvc->err_code;
 }
@@ -13390,9 +13361,10 @@ static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
  * then 0 is returned.
  */
 static int __devinit
-AdvInitGetConfig(struct pci_dev *pdev, struct asc_board *boardp)
+AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)
 {
-	ADV_DVC_VAR *asc_dvc = &boardp->dvc_var.adv_dvc_var;
+	struct asc_board *board = shost_priv(shost);
+	ADV_DVC_VAR *asc_dvc = &board->dvc_var.adv_dvc_var;
 	unsigned short warn_code = 0;
 	AdvPortAddr iop_base = asc_dvc->iop_base;
 	u16 cmd;
@@ -13458,15 +13430,12 @@ AdvInitGetConfig(struct pci_dev *pdev, struct asc_board *boardp)
 		warn_code |= status;
 	}
 
-	if (warn_code != 0) {
-		ASC_PRINT2("AdvInitGetConfig: board %d: warning: 0x%x\n",
-			   boardp->id, warn_code);
-	}
+	if (warn_code != 0)
+		shost_printk(KERN_WARNING, shost, "warning: 0x%x\n", warn_code);
 
-	if (asc_dvc->err_code) {
-		ASC_PRINT2("AdvInitGetConfig: board %d error: err_code 0x%x\n",
-		     boardp->id, asc_dvc->err_code);
-	}
+	if (asc_dvc->err_code)
+		shost_printk(KERN_ERR, shost, "error code 0x%x\n",
+				asc_dvc->err_code);
 
 	return asc_dvc->err_code;
 }
@@ -13499,9 +13468,10 @@ static struct scsi_host_template advansys_template = {
 	.use_clustering = ENABLE_CLUSTERING,
 };
 
-static int __devinit
-advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
+static int __devinit advansys_wide_init_chip(struct Scsi_Host *shost)
 {
+	struct asc_board *board = shost_priv(shost);
+	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
 	int req_cnt = 0;
 	adv_req_t *reqp = NULL;
 	int sg_cnt = 0;
@@ -13512,10 +13482,10 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	 * Allocate buffer carrier structures. The total size
 	 * is about 4 KB, so allocate all at once.
 	 */
-	boardp->carrp = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
-	ASC_DBG(1, "carrp 0x%p\n", boardp->carrp);
+	board->carrp = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
+	ASC_DBG(1, "carrp 0x%p\n", board->carrp);
 
-	if (!boardp->carrp)
+	if (!board->carrp)
 		goto kmalloc_failed;
 
 	/*
@@ -13523,7 +13493,7 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	 * board. The total size is about 16 KB, so allocate all at once.
 	 * If the allocation fails decrement and try again.
 	 */
-	for (req_cnt = adv_dvc_varp->max_host_qng; req_cnt > 0; req_cnt--) {
+	for (req_cnt = adv_dvc->max_host_qng; req_cnt > 0; req_cnt--) {
 		reqp = kmalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);
 
 		ASC_DBG(1, "reqp 0x%p, req_cnt %d, bytes %lu\n", reqp, req_cnt,
@@ -13536,31 +13506,31 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	if (!reqp)
 		goto kmalloc_failed;
 
-	boardp->orig_reqp = reqp;
+	board->orig_reqp = reqp;
 
 	/*
 	 * Allocate up to ADV_TOT_SG_BLOCK request structures for
 	 * the Wide board. Each structure is about 136 bytes.
 	 */
-	boardp->adv_sgblkp = NULL;
+	board->adv_sgblkp = NULL;
 	for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
 		sgp = kmalloc(sizeof(adv_sgblk_t), GFP_KERNEL);
 
 		if (!sgp)
 			break;
 
-		sgp->next_sgblkp = boardp->adv_sgblkp;
-		boardp->adv_sgblkp = sgp;
+		sgp->next_sgblkp = board->adv_sgblkp;
+		board->adv_sgblkp = sgp;
 
 	}
 
 	ASC_DBG(1, "sg_cnt %d * %u = %u bytes\n", sg_cnt, sizeof(adv_sgblk_t),
 		 (unsigned)(sizeof(adv_sgblk_t) * sg_cnt));
 
-	if (!boardp->adv_sgblkp)
+	if (!board->adv_sgblkp)
 		goto kmalloc_failed;
 
-	adv_dvc_varp->carrier_buf = boardp->carrp;
+	adv_dvc->carrier_buf = board->carrp;
 
 	/*
 	 * Point 'adv_reqp' to the request structures and
@@ -13571,30 +13541,29 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	for (; req_cnt > 0; req_cnt--) {
 		reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
 	}
-	boardp->adv_reqp = &reqp[0];
+	board->adv_reqp = &reqp[0];
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+	if (adv_dvc->chip_type == ADV_CHIP_ASC3550) {
 		ASC_DBG(2, "AdvInitAsc3550Driver()\n");
-		warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		warn_code = AdvInitAsc3550Driver(adv_dvc);
+	} else if (adv_dvc->chip_type == ADV_CHIP_ASC38C0800) {
 		ASC_DBG(2, "AdvInitAsc38C0800Driver()\n");
-		warn_code = AdvInitAsc38C0800Driver(adv_dvc_varp);
+		warn_code = AdvInitAsc38C0800Driver(adv_dvc);
 	} else {
 		ASC_DBG(2, "AdvInitAsc38C1600Driver()\n");
-		warn_code = AdvInitAsc38C1600Driver(adv_dvc_varp);
+		warn_code = AdvInitAsc38C1600Driver(adv_dvc);
 	}
-	err_code = adv_dvc_varp->err_code;
+	err_code = adv_dvc->err_code;
 
 	if (warn_code || err_code) {
-		ASC_PRINT3("advansys_wide_init_chip: board %d error: warn 0x%x,"
-			   " error 0x%x\n", boardp->id, warn_code, err_code);
+		shost_printk(KERN_WARNING, shost, "error: warn 0x%x, error "
+			"0x%x\n", warn_code, err_code);
 	}
 
 	goto exit;
 
  kmalloc_failed:
-	ASC_PRINT1("advansys_wide_init_chip: board %d error: kmalloc() "
-		   "failed\n", boardp->id);
+	shost_printk(KERN_ERR, shost, "error: kmalloc() failed\n");
 	err_code = ADV_ERROR;
  exit:
 	return err_code;
@@ -13622,7 +13591,6 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	ADV_DVC_VAR *adv_dvc_varp = NULL;
 	int share_irq, warn_code, ret;
 
-	boardp->id = asc_board_count++;
 	pdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;
 
 	if (ASC_NARROW_BOARD(boardp)) {
@@ -13653,10 +13621,10 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		boardp->ioremap_addr = ioremap(pci_resource_start(pdev, 1),
 					       boardp->asc_n_io_port);
 		if (!boardp->ioremap_addr) {
-			ASC_PRINT3
-			    ("advansys_board_found: board %d: ioremap(%x, %d) returned NULL\n",
-			     boardp->id, pci_resource_start(pdev, 1),
-			     boardp->asc_n_io_port);
+			shost_printk(KERN_ERR, shost, "ioremap(%x, %d) "
+					"returned NULL\n",
+					pci_resource_start(pdev, 1),
+					boardp->asc_n_io_port);
 			ret = -ENODEV;
 			goto err_shost;
 		}
@@ -13682,8 +13650,8 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	 */
 	boardp->prtbuf = kmalloc(ASC_PRTBUF_SIZE, GFP_KERNEL);
 	if (!boardp->prtbuf) {
-		ASC_PRINT2("advansys_board_found: board %d: kmalloc(%d) "
-			   "returned NULL\n", boardp->id, ASC_PRTBUF_SIZE);
+		shost_printk(KERN_ERR, shost, "kmalloc(%d) returned NULL\n",
+				ASC_PRTBUF_SIZE);
 		ret = -ENOMEM;
 		goto err_unmap;
 	}
@@ -13716,9 +13684,8 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 			break;
 #endif /* CONFIG_PCI */
 		default:
-			ASC_PRINT2
-			    ("advansys_board_found: board %d: unknown adapter type: %d\n",
-			     boardp->id, asc_dvc_varp->bus_type);
+			shost_printk(KERN_ERR, shost, "unknown adapter type: "
+					"%d\n", asc_dvc_varp->bus_type);
 			shost->unchecked_isa_dma = TRUE;
 			share_irq = 0;
 			break;
@@ -13731,7 +13698,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		 * referenced only use the bit-wise AND operator "&".
 		 */
 		ASC_DBG(2, "AscInitGetConfig()\n");
-		ret = AscInitGetConfig(boardp) ? -ENODEV : 0;
+		ret = AscInitGetConfig(shost) ? -ENODEV : 0;
 	} else {
 #ifdef CONFIG_PCI
 		/*
@@ -13742,7 +13709,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		share_irq = IRQF_SHARED;
 		ASC_DBG(2, "AdvInitGetConfig()\n");
 
-		ret = AdvInitGetConfig(pdev, boardp) ? -ENODEV : 0;
+		ret = AdvInitGetConfig(pdev, shost) ? -ENODEV : 0;
 #endif /* CONFIG_PCI */
 	}
 
@@ -13790,7 +13757,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		 * Modify board configuration.
 		 */
 		ASC_DBG(2, "AscInitSetConfig()\n");
-		ret = AscInitSetConfig(pdev, boardp) ? -ENODEV : 0;
+		ret = AscInitSetConfig(pdev, shost) ? -ENODEV : 0;
 		if (ret)
 			goto err_free_proc;
 	} else {
@@ -14024,9 +13991,9 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 			shost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
 			ret = request_dma(shost->dma_channel, DRV_NAME);
 			if (ret) {
-				ASC_PRINT3
-				    ("advansys_board_found: board %d: request_dma() %d failed %d\n",
-				     boardp->id, shost->dma_channel, ret);
+				shost_printk(KERN_ERR, shost, "request_dma() "
+						"%d failed %d\n",
+						shost->dma_channel, ret);
 				goto err_free_proc;
 			}
 			AscEnableIsaDma(shost->dma_channel);
@@ -14042,17 +14009,14 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 
 	if (ret) {
 		if (ret == -EBUSY) {
-			ASC_PRINT2
-			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x already in use.\n",
-			     boardp->id, boardp->irq);
+			shost_printk(KERN_ERR, shost, "request_irq(): IRQ 0x%x "
+					"already in use\n", boardp->irq);
 		} else if (ret == -EINVAL) {
-			ASC_PRINT2
-			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x not valid.\n",
-			     boardp->id, boardp->irq);
+			shost_printk(KERN_ERR, shost, "request_irq(): IRQ 0x%x "
+					"not valid\n", boardp->irq);
 		} else {
-			ASC_PRINT3
-			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x failed with %d\n",
-			     boardp->id, boardp->irq, ret);
+			shost_printk(KERN_ERR, shost, "request_irq(): IRQ 0x%x "
+					"failed with %d\n", boardp->irq, ret);
 		}
 		goto err_free_dma;
 	}
@@ -14065,15 +14029,15 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		warn_code = AscInitAsc1000Driver(asc_dvc_varp);
 
 		if (warn_code || asc_dvc_varp->err_code) {
-			ASC_PRINT4("advansys_board_found: board %d error: "
-				   "init_state 0x%x, warn 0x%x, error 0x%x\n",
-				   boardp->id, asc_dvc_varp->init_state,
-				   warn_code, asc_dvc_varp->err_code);
+			shost_printk(KERN_ERR, shost, "error: init_state 0x%x, "
+					"warn 0x%x, error 0x%x\n",
+					asc_dvc_varp->init_state, warn_code,
+					asc_dvc_varp->err_code);
 			if (asc_dvc_varp->err_code)
 				ret = -ENODEV;
 		}
 	} else {
-		if (advansys_wide_init_chip(boardp, adv_dvc_varp))
+		if (advansys_wide_init_chip(shost))
 			ret = -ENODEV;
 	}
 

commit f092d2290f905b6e9928df6905f2fc9d18b6ae19
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:34 2007 -0400

    [SCSI] advansys: Remove private lock
    
    The board lock was essentially identical with the host lock.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 6bd8e835ea0f..a4091ab8d363 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2439,7 +2439,6 @@ struct asc_board {
 		ADVEEP_38C1600_CONFIG adv_38C1600_eep;	/* 38C1600 EEPROM config. */
 	} eep_config;
 	ulong last_reset;	/* Saved last reset time */
-	spinlock_t lock;	/* Board spinlock */
 	/* /proc/scsi/advansys/[0...] */
 	char *prtbuf;		/* /proc print buffer */
 #ifdef ADVANSYS_STATS
@@ -9621,7 +9620,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		}
 
 		ASC_DBG(1, "after AscInitAsc1000Driver()\n");
-		spin_lock_irqsave(&boardp->lock, flags);
+		spin_lock_irqsave(shost->host_lock, flags);
 	} else {
 		/*
 		 * If the suggest reset bus flags are set, then reset the bus.
@@ -9644,13 +9643,13 @@ static int advansys_reset(struct scsi_cmnd *scp)
 			ret = FAILED;
 			break;
 		}
-		spin_lock_irqsave(&boardp->lock, flags);
+		spin_lock_irqsave(shost->host_lock, flags);
 		AdvISR(adv_dvc);
 	}
 
 	/* Save the time of the most recently completed reset. */
 	boardp->last_reset = jiffies;
-	spin_unlock_irqrestore(&boardp->lock, flags);
+	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	ASC_DBG(1, "ret %d\n", ret);
 
@@ -9707,13 +9706,12 @@ advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
  */
 static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 {
-	unsigned long flags;
 	struct Scsi_Host *shost = dev_id;
 	struct asc_board *boardp = shost_priv(shost);
 	irqreturn_t result = IRQ_NONE;
 
 	ASC_DBG(2, "boardp 0x%p\n", boardp);
-	spin_lock_irqsave(&boardp->lock, flags);
+	spin_lock(shost->host_lock);
 	if (ASC_NARROW_BOARD(boardp)) {
 		if (AscIsIntPending(shost->io_port)) {
 			result = IRQ_HANDLED;
@@ -9728,7 +9726,7 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 			ASC_STATS(shost, interrupt);
 		}
 	}
-	spin_unlock_irqrestore(&boardp->lock, flags);
+	spin_unlock(shost->host_lock);
 
 	ASC_DBG(1, "end\n");
 	return result;
@@ -11203,20 +11201,12 @@ static int
 advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *shost = scp->device->host;
-	struct asc_board *boardp = shost_priv(shost);
-	unsigned long flags;
 	int asc_res, result = 0;
 
 	ASC_STATS(shost, queuecommand);
 	scp->scsi_done = done;
 
-	/*
-	 * host_lock taken by mid-level prior to call, but need
-	 * to protect against own ISR
-	 */
-	spin_lock_irqsave(&boardp->lock, flags);
 	asc_res = asc_execute_scsi_cmnd(scp);
-	spin_unlock_irqrestore(&boardp->lock, flags);
 
 	switch (asc_res) {
 	case ASC_NOERROR:
@@ -13633,7 +13623,6 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	int share_irq, warn_code, ret;
 
 	boardp->id = asc_board_count++;
-	spin_lock_init(&boardp->lock);
 	pdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;
 
 	if (ASC_NARROW_BOARD(boardp)) {

commit b352f9237622c64afbac367cadd10d23cb4c5484
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:33 2007 -0400

    [SCSI] advansys: Sort out debug macros
    
    Replace ASC_DBG{,1,2,3,4,5} with a single variadic macro ASC_DBG.  As
    suggested by Jeff Garzik, include DRV_NAME and __FUNCTION__ in the output.
    Change all callers to no longer include the function name in the string.
    
    Enabling ADVANSYS_DEBUG to test this feature shows a lot of other problems
    that need to be fixed:
     - Reorder asc_prt_* functions now that their prototypes have been removed.
     - There is no longer a struct device in ASC_DVC_CFG/ADV_DVC_CFG, and it
       wasn't necessarily a PCI device to begin with.  Print the bus_id from
       asc_board->dev instead.
     - isr_callback no longer exists.
     - ASC_DBG_PRT_SCSI_CMND isn't being used, so delete asc_prt_scsi_cmnd
       too.
     - A missing semicolon
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 72ed9721c44b..6bd8e835ea0f 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -75,7 +75,7 @@
 #define ADVANSYS_STATS
 
 /* Enable driver tracing. */
-/* #define ADVANSYS_DEBUG */
+#undef ADVANSYS_DEBUG
 
 /*
  * Portable Data Types
@@ -2277,13 +2277,8 @@ do { \
 
 #ifndef ADVANSYS_DEBUG
 
-#define ASC_DBG(lvl, s)
-#define ASC_DBG1(lvl, s, a1)
-#define ASC_DBG2(lvl, s, a1, a2)
-#define ASC_DBG3(lvl, s, a1, a2, a3)
-#define ASC_DBG4(lvl, s, a1, a2, a3, a4)
+#define ASC_DBG(lvl, s...)
 #define ASC_DBG_PRT_SCSI_HOST(lvl, s)
-#define ASC_DBG_PRT_SCSI_CMND(lvl, s)
 #define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp)
 #define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)
 #define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone)
@@ -2302,40 +2297,11 @@ do { \
  * 2-N: Verbose Tracing
  */
 
-#define ASC_DBG(lvl, s) \
-    { \
-        if (asc_dbglvl >= (lvl)) { \
-            printk(s); \
-        } \
-    }
-
-#define ASC_DBG1(lvl, s, a1) \
-    { \
-        if (asc_dbglvl >= (lvl)) { \
-            printk((s), (a1)); \
-        } \
-    }
-
-#define ASC_DBG2(lvl, s, a1, a2) \
-    { \
-        if (asc_dbglvl >= (lvl)) { \
-            printk((s), (a1), (a2)); \
-        } \
-    }
-
-#define ASC_DBG3(lvl, s, a1, a2, a3) \
-    { \
-        if (asc_dbglvl >= (lvl)) { \
-            printk((s), (a1), (a2), (a3)); \
-        } \
-    }
-
-#define ASC_DBG4(lvl, s, a1, a2, a3, a4) \
-    { \
-        if (asc_dbglvl >= (lvl)) { \
-            printk((s), (a1), (a2), (a3), (a4)); \
-        } \
-    }
+#define ASC_DBG(lvl, format, arg...) {					\
+	if (asc_dbglvl >= (lvl))					\
+		printk(KERN_DEBUG "%s: %s: " format, DRV_NAME,		\
+			__FUNCTION__ , ## arg);				\
+}
 
 #define ASC_DBG_PRT_SCSI_HOST(lvl, s) \
     { \
@@ -2344,13 +2310,6 @@ do { \
         } \
     }
 
-#define ASC_DBG_PRT_SCSI_CMND(lvl, s) \
-    { \
-        if (asc_dbglvl >= (lvl)) { \
-            asc_prt_scsi_cmnd(s); \
-        } \
-    }
-
 #define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp) \
     { \
         if (asc_dbglvl >= (lvl)) { \
@@ -2518,64 +2477,6 @@ static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 #ifdef ADVANSYS_DEBUG
 static int asc_dbglvl = 3;
 
-/*
- * asc_prt_scsi_host()
- */
-static void asc_prt_scsi_host(struct Scsi_Host *s)
-{
-	struct asc_board *boardp = shost_priv(s);
-
-	printk("Scsi_Host at addr 0x%lx\n", (ulong)s);
-	printk(" host_busy %u, host_no %d, last_reset %d,\n",
-	       s->host_busy, s->host_no, (unsigned)s->last_reset);
-
-	printk(" base 0x%lx, io_port 0x%lx, irq 0x%x,\n",
-	       (ulong)s->base, (ulong)s->io_port, boardp->irq);
-
-	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
-	       s->dma_channel, s->this_id, s->can_queue);
-
-	printk(" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
-	       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
-
-	if (ASC_NARROW_BOARD(boardp)) {
-		asc_prt_asc_dvc_var(boardp->dvc_var.asc_dvc_var);
-		asc_prt_asc_dvc_cfg(boardp->dvc_cfg.asc_dvc_cfg);
-	} else {
-		asc_prt_adv_dvc_var(boardp->dvc_var.adv_dvc_var);
-		asc_prt_adv_dvc_cfg(boardp->dvc_cfg.adv_dvc_cfg);
-	}
-}
-
-/*
- * asc_prt_scsi_cmnd()
- */
-static void asc_prt_scsi_cmnd(struct scsi_cmnd *s)
-{
-	printk("struct scsi_cmnd at addr 0x%lx\n", (ulong)s);
-
-	printk(" host 0x%lx, device 0x%lx, target %u, lun %u, channel %u,\n",
-	       (ulong)s->device->host, (ulong)s->device, s->device->id,
-	       s->device->lun, s->device->channel);
-
-	asc_prt_hex(" CDB", s->cmnd, s->cmd_len);
-
-	printk("sc_data_direction %u, resid %d\n",
-	       s->sc_data_direction, s->resid);
-
-	printk(" use_sg %u, sglist_len %u\n", s->use_sg, s->sglist_len);
-
-	printk(" serial_number 0x%x, retries %d, allowed %d\n",
-	       (unsigned)s->serial_number, s->retries, s->allowed);
-
-	printk(" timeout_per_command %d\n", s->timeout_per_command);
-
-	printk(" scsi_done 0x%p, done 0x%p, host_scribble 0x%p, result 0x%x\n",
-		s->scsi_done, s->done, s->host_scribble, s->result);
-
-	printk(" tag %u, pid %u\n", (unsigned)s->tag, (unsigned)s->pid);
-}
-
 /*
  * asc_prt_asc_dvc_var()
  */
@@ -2627,64 +2528,10 @@ static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
 		"chip_version %d,\n", h->chip_scsi_id, h->isa_dma_speed,
 		h->isa_dma_channel, h->chip_version);
 
-	printk(" pci_device_id %d, mcode_date 0x%x, mcode_version %d, "
-		"overrun_buf 0x%p\n", to_pci_dev(h->dev)->device,
+	printk(" mcode_date 0x%x, mcode_version %d, overrun_buf 0x%p\n",
 		h->mcode_date, h->mcode_version, h->overrun_buf);
 }
 
-/*
- * asc_prt_asc_scsi_q()
- */
-static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
-{
-	ASC_SG_HEAD *sgp;
-	int i;
-
-	printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);
-
-	printk
-	    (" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
-	     q->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,
-	     q->q2.tag_code);
-
-	printk
-	    (" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
-	     (ulong)le32_to_cpu(q->q1.data_addr),
-	     (ulong)le32_to_cpu(q->q1.data_cnt),
-	     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
-
-	printk(" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
-	       (ulong)q->cdbptr, q->q2.cdb_len,
-	       (ulong)q->sg_head, q->q1.sg_queue_cnt);
-
-	if (q->sg_head) {
-		sgp = q->sg_head;
-		printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong)sgp);
-		printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt,
-		       sgp->queue_cnt);
-		for (i = 0; i < sgp->entry_cnt; i++) {
-			printk(" [%u]: addr 0x%lx, bytes %lu\n",
-			       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),
-			       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));
-		}
-
-	}
-}
-
-/*
- * asc_prt_asc_qdone_info()
- */
-static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
-{
-	printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);
-	printk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
-	       (ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
-	       q->d2.tag_code);
-	printk
-	    (" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
-	     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
-}
-
 /*
  * asc_prt_adv_dvc_var()
  *
@@ -2697,9 +2544,8 @@ static void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
 	printk("  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",
 	       (ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);
 
-	printk("  isr_callback 0x%lx, sdtr_able 0x%x, wdtr_able 0x%x\n",
-	       (ulong)h->isr_callback, (unsigned)h->sdtr_able,
-	       (unsigned)h->wdtr_able);
+	printk("  sdtr_able 0x%x, wdtr_able 0x%x\n",
+	       (unsigned)h->sdtr_able, (unsigned)h->wdtr_able);
 
 	printk("  start_motor 0x%x, scsi_reset_wait 0x%x\n",
 	       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);
@@ -2733,87 +2579,36 @@ static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
 	printk("  chip_version 0x%x, mcode_date 0x%x\n",
 	       h->chip_version, h->mcode_date);
 
-	printk("  mcode_version 0x%x, pci_device_id 0x%x\n",
-	       h->mcode_version, to_pci_dev(h->dev)->device);
-
-	printk("  control_flag 0x%x\n", h->control_flag);
+	printk("  mcode_version 0x%x, control_flag 0x%x\n",
+	       h->mcode_version, h->control_flag);
 }
 
 /*
- * asc_prt_adv_scsi_req_q()
- *
- * Display an ADV_SCSI_REQ_Q structure.
+ * asc_prt_scsi_host()
  */
-static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
+static void asc_prt_scsi_host(struct Scsi_Host *s)
 {
-	int sg_blk_cnt;
-	struct asc_sg_block *sg_ptr;
-
-	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
-
-	printk("  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
-	       q->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);
-
-	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
-	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
-
-	printk("  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
-	       (ulong)le32_to_cpu(q->data_cnt),
-	       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);
-
-	printk
-	    ("  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
-	     q->cdb_len, q->done_status, q->host_status, q->scsi_status);
+	struct asc_board *boardp = shost_priv(s);
 
-	printk("  sg_working_ix 0x%x, target_cmd %u\n",
-	       q->sg_working_ix, q->target_cmd);
+	printk("Scsi_Host at addr 0x%p, device %s\n", s, boardp->dev->bus_id);
+	printk(" host_busy %u, host_no %d, last_reset %d,\n",
+	       s->host_busy, s->host_no, (unsigned)s->last_reset);
 
-	printk("  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
-	       (ulong)le32_to_cpu(q->scsiq_rptr),
-	       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);
+	printk(" base 0x%lx, io_port 0x%lx, irq %d,\n",
+	       (ulong)s->base, (ulong)s->io_port, boardp->irq);
 
-	/* Display the request's ADV_SG_BLOCK structures. */
-	if (q->sg_list_ptr != NULL) {
-		sg_blk_cnt = 0;
-		while (1) {
-			/*
-			 * 'sg_ptr' is a physical address. Convert it to a virtual
-			 * address by indexing 'sg_blk_cnt' into the virtual address
-			 * array 'sg_list_ptr'.
-			 *
-			 * XXX - Assumes all SG physical blocks are virtually contiguous.
-			 */
-			sg_ptr =
-			    &(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);
-			asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
-			if (sg_ptr->sg_ptr == 0) {
-				break;
-			}
-			sg_blk_cnt++;
-		}
-	}
-}
+	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
+	       s->dma_channel, s->this_id, s->can_queue);
 
-/*
- * asc_prt_adv_sgblock()
- *
- * Display an ADV_SG_BLOCK structure.
- */
-static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
-{
-	int i;
+	printk(" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
+	       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
 
-	printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
-	       (ulong)b, sgblockno);
-	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
-	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
-	BUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);
-	if (b->sg_ptr != 0)
-		BUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);
-	for (i = 0; i < b->sg_cnt; i++) {
-		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
-		       i, (ulong)b->sg_list[i].sg_addr,
-		       (ulong)b->sg_list[i].sg_count);
+	if (ASC_NARROW_BOARD(boardp)) {
+		asc_prt_asc_dvc_var(&boardp->dvc_var.asc_dvc_var);
+		asc_prt_asc_dvc_cfg(&boardp->dvc_cfg.asc_dvc_cfg);
+	} else {
+		asc_prt_adv_dvc_var(&boardp->dvc_var.adv_dvc_var);
+		asc_prt_adv_dvc_cfg(&boardp->dvc_cfg.adv_dvc_cfg);
 	}
 }
 
@@ -2873,6 +2668,137 @@ static void asc_prt_hex(char *f, uchar *s, int l)
 		printk("\n");
 	}
 }
+
+/*
+ * asc_prt_asc_scsi_q()
+ */
+static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
+{
+	ASC_SG_HEAD *sgp;
+	int i;
+
+	printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);
+
+	printk
+	    (" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
+	     q->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,
+	     q->q2.tag_code);
+
+	printk
+	    (" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+	     (ulong)le32_to_cpu(q->q1.data_addr),
+	     (ulong)le32_to_cpu(q->q1.data_cnt),
+	     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
+
+	printk(" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
+	       (ulong)q->cdbptr, q->q2.cdb_len,
+	       (ulong)q->sg_head, q->q1.sg_queue_cnt);
+
+	if (q->sg_head) {
+		sgp = q->sg_head;
+		printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong)sgp);
+		printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt,
+		       sgp->queue_cnt);
+		for (i = 0; i < sgp->entry_cnt; i++) {
+			printk(" [%u]: addr 0x%lx, bytes %lu\n",
+			       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),
+			       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));
+		}
+
+	}
+}
+
+/*
+ * asc_prt_asc_qdone_info()
+ */
+static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
+{
+	printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);
+	printk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
+	       (ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
+	       q->d2.tag_code);
+	printk
+	    (" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
+	     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
+}
+
+/*
+ * asc_prt_adv_sgblock()
+ *
+ * Display an ADV_SG_BLOCK structure.
+ */
+static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
+{
+	int i;
+
+	printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
+	       (ulong)b, sgblockno);
+	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
+	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
+	BUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);
+	if (b->sg_ptr != 0)
+		BUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);
+	for (i = 0; i < b->sg_cnt; i++) {
+		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
+		       i, (ulong)b->sg_list[i].sg_addr,
+		       (ulong)b->sg_list[i].sg_count);
+	}
+}
+
+/*
+ * asc_prt_adv_scsi_req_q()
+ *
+ * Display an ADV_SCSI_REQ_Q structure.
+ */
+static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
+{
+	int sg_blk_cnt;
+	struct asc_sg_block *sg_ptr;
+
+	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
+
+	printk("  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
+	       q->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);
+
+	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
+	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
+
+	printk("  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+	       (ulong)le32_to_cpu(q->data_cnt),
+	       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);
+
+	printk
+	    ("  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
+	     q->cdb_len, q->done_status, q->host_status, q->scsi_status);
+
+	printk("  sg_working_ix 0x%x, target_cmd %u\n",
+	       q->sg_working_ix, q->target_cmd);
+
+	printk("  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
+	       (ulong)le32_to_cpu(q->scsiq_rptr),
+	       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);
+
+	/* Display the request's ADV_SG_BLOCK structures. */
+	if (q->sg_list_ptr != NULL) {
+		sg_blk_cnt = 0;
+		while (1) {
+			/*
+			 * 'sg_ptr' is a physical address. Convert it to a virtual
+			 * address by indexing 'sg_blk_cnt' into the virtual address
+			 * array 'sg_list_ptr'.
+			 *
+			 * XXX - Assumes all SG physical blocks are virtually contiguous.
+			 */
+			sg_ptr =
+			    &(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);
+			asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
+			if (sg_ptr->sg_ptr == 0) {
+				break;
+			}
+			sg_blk_cnt++;
+		}
+	}
+}
 #endif /* ADVANSYS_DEBUG */
 
 /*
@@ -2895,7 +2821,7 @@ static const char *advansys_info(struct Scsi_Host *shost)
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-		ASC_DBG(1, "advansys_info: begin\n");
+		ASC_DBG(1, "begin\n");
 		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
 			if ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) ==
 			    ASC_IS_ISAPNP) {
@@ -2955,7 +2881,7 @@ static const char *advansys_info(struct Scsi_Host *shost)
 			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, boardp->irq);
 	}
 	BUG_ON(strlen(info) >= ASC_INFO_SIZE);
-	ASC_DBG(1, "advansys_info: end\n");
+	ASC_DBG(1, "end\n");
 	return info;
 }
 
@@ -4118,12 +4044,12 @@ asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
 {
 	int cnt = 0;
 
-	ASC_DBG3(2, "asc_proc_copy: offset %d, advoffset %d, cplen %d\n",
+	ASC_DBG(2, "offset %d, advoffset %d, cplen %d\n",
 		 (unsigned)offset, (unsigned)advoffset, cplen);
 	if (offset <= advoffset) {
 		/* Read offset below current offset, copy everything. */
 		cnt = min(cplen, leftlen);
-		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+		ASC_DBG(2, "curbuf 0x%lx, cp 0x%lx, cnt %d\n",
 			 (ulong)curbuf, (ulong)cp, cnt);
 		memcpy(curbuf, cp, cnt);
 	} else if (offset < advoffset + cplen) {
@@ -4131,7 +4057,7 @@ asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
 		cnt = (advoffset + cplen) - offset;
 		cp = (cp + cplen) - cnt;
 		cnt = min(cnt, leftlen);
-		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+		ASC_DBG(2, "curbuf 0x%lx, cp 0x%lx, cnt %d\n",
 			 (ulong)curbuf, (ulong)cp, cnt);
 		memcpy(curbuf, cp, cnt);
 	}
@@ -4270,7 +4196,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	char *curbuf;
 	off_t advoffset;
 
-	ASC_DBG(1, "advansys_proc_info: begin\n");
+	ASC_DBG(1, "begin\n");
 
 	/*
 	 * User write not supported.
@@ -4302,7 +4228,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	totcnt += cnt;
 	leftlen -= cnt;
 	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		ASC_DBG(1, "totcnt %d\n", totcnt);
 		return totcnt;
 	}
 	advoffset += cplen;
@@ -4320,7 +4246,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 		totcnt += cnt;
 		leftlen -= cnt;
 		if (leftlen == 0) {
-			ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+			ASC_DBG(1, "totcnt %d\n", totcnt);
 			return totcnt;
 		}
 		advoffset += cplen;
@@ -4337,7 +4263,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	totcnt += cnt;
 	leftlen -= cnt;
 	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		ASC_DBG(1, "totcnt %d\n", totcnt);
 		return totcnt;
 	}
 	advoffset += cplen;
@@ -4357,7 +4283,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	totcnt += cnt;
 	leftlen -= cnt;
 	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		ASC_DBG(1, "totcnt %d\n", totcnt);
 		return totcnt;
 	}
 	advoffset += cplen;
@@ -4373,7 +4299,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	totcnt += cnt;
 	leftlen -= cnt;
 	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		ASC_DBG(1, "totcnt %d\n", totcnt);
 		return totcnt;
 	}
 	advoffset += cplen;
@@ -4390,7 +4316,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	totcnt += cnt;
 	leftlen -= cnt;
 	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		ASC_DBG(1, "totcnt %d\n", totcnt);
 		return totcnt;
 	}
 	advoffset += cplen;
@@ -4412,13 +4338,13 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	totcnt += cnt;
 	leftlen -= cnt;
 	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		ASC_DBG(1, "totcnt %d\n", totcnt);
 		return totcnt;
 	}
 	advoffset += cplen;
 	curbuf += cnt;
 
-	ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+	ASC_DBG(1, "totcnt %d\n", totcnt);
 
 	return totcnt;
 }
@@ -4530,11 +4456,10 @@ static int AscFindSignature(PortAddr iop_base)
 {
 	ushort sig_word;
 
-	ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureByte(0x%x) 0x%x\n",
+	ASC_DBG(1, "AscGetChipSignatureByte(0x%x) 0x%x\n",
 		 iop_base, AscGetChipSignatureByte(iop_base));
 	if (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {
-		ASC_DBG2(1,
-			 "AscFindSignature: AscGetChipSignatureWord(0x%x) 0x%x\n",
+		ASC_DBG(1, "AscGetChipSignatureWord(0x%x) 0x%x\n",
 			 iop_base, AscGetChipSignatureWord(iop_base));
 		sig_word = AscGetChipSignatureWord(iop_base);
 		if ((sig_word == (ushort)ASC_1000_ID0W) ||
@@ -4785,18 +4710,17 @@ AscLoadMicroCode(PortAddr iop_base,
 	AscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);
 
 	chksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);
-	ASC_DBG1(1, "AscLoadMicroCode: chksum 0x%lx\n", (ulong)chksum);
+	ASC_DBG(1, "chksum 0x%lx\n", (ulong)chksum);
 	mcode_chksum = (ushort)AscMemSumLramWord(iop_base,
 						 (ushort)ASC_CODE_SEC_BEG,
 						 (ushort)((mcode_size -
 							   s_addr - (ushort)
 							   ASC_CODE_SEC_BEG) /
 							  2));
-	ASC_DBG1(1, "AscLoadMicroCode: mcode_chksum 0x%lx\n",
-		 (ulong)mcode_chksum);
+	ASC_DBG(1, "mcode_chksum 0x%lx\n", (ulong)mcode_chksum);
 	AscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);
 	AscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);
-	return (chksum);
+	return chksum;
 }
 
 /* Microcode buffer is kept after initialization for error recovery. */
@@ -6511,8 +6435,7 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	warn_code |= AscInitLram(asc_dvc);
 	if (asc_dvc->err_code != 0)
 		return UW_ERR;
-	ASC_DBG1(1, "AscInitAsc1000Driver: _asc_mcode_chksum 0x%lx\n",
-		 (ulong)_asc_mcode_chksum);
+	ASC_DBG(1, "_asc_mcode_chksum 0x%lx\n", (ulong)_asc_mcode_chksum);
 	if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
 			     _asc_mcode_size) != _asc_mcode_chksum) {
 		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
@@ -6613,7 +6536,7 @@ DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
 {
 	ADV_PADDR paddr = virt_to_bus(vaddr);
 
-	ASC_DBG4(4, "DvcGetPhyAddr: vaddr 0x%p, lenp 0x%p *lenp %lu, paddr 0x%lx\n",
+	ASC_DBG(4, "vaddr 0x%p, lenp 0x%p *lenp %lu, paddr 0x%lx\n",
 		 vaddr, lenp, (ulong)*((ulong *)lenp), (ulong)paddr);
 
 	return paddr;
@@ -8291,8 +8214,7 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
 		/*
 		 * The firmware detected a SCSI Bus reset.
 		 */
-		ASC_DBG(0,
-			"adv_async_callback: ADV_ASYNC_SCSI_BUS_RESET_DET\n");
+		ASC_DBG(0, "ADV_ASYNC_SCSI_BUS_RESET_DET\n");
 		break;
 
 	case ADV_ASYNC_RDMA_FAILURE:
@@ -8301,7 +8223,7 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
 		 * possibly the chip if it is unresponsive. Log the error
 		 * with a unique code.
 		 */
-		ASC_DBG(0, "adv_async_callback: ADV_ASYNC_RDMA_FAILURE\n");
+		ASC_DBG(0, "ADV_ASYNC_RDMA_FAILURE\n");
 		AdvResetChipAndSB(adv_dvc_varp);
 		break;
 
@@ -8309,11 +8231,11 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
 		/*
 		 * Host generated SCSI bus reset occurred.
 		 */
-		ASC_DBG(0, "adv_async_callback: ADV_HOST_SCSI_BUS_RESET\n");
+		ASC_DBG(0, "ADV_HOST_SCSI_BUS_RESET\n");
 		break;
 
 	default:
-		ASC_DBG1(0, "DvcAsyncCallBack: unknown code 0x%x\n", code);
+		ASC_DBG(0, "unknown code 0x%x\n", code);
 		break;
 	}
 }
@@ -8332,7 +8254,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	struct Scsi_Host *shost;
 	ADV_DCNT resid_cnt;
 
-	ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
+	ASC_DBG(1, "adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
 		 (ulong)adv_dvc_varp, (ulong)scsiqp);
 	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
 
@@ -8342,7 +8264,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	 * completed ADV_SCSI_REQ_Q structure.
 	 */
 	reqp = (adv_req_t *)ADV_U32_TO_VADDR(scsiqp->srb_ptr);
-	ASC_DBG1(1, "adv_isr_callback: reqp 0x%lx\n", (ulong)reqp);
+	ASC_DBG(1, "reqp 0x%lx\n", (ulong)reqp);
 	if (reqp == NULL) {
 		ASC_PRINT("adv_isr_callback: reqp is NULL\n");
 		return;
@@ -8357,7 +8279,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	 * determined.
 	 */
 	scp = reqp->cmndp;
-	ASC_DBG1(1, "adv_isr_callback: scp 0x%lx\n", (ulong)scp);
+	ASC_DBG(1, "scp 0x%p\n", scp);
 	if (scp == NULL) {
 		ASC_PRINT
 		    ("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");
@@ -8367,7 +8289,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 
 	shost = scp->device->host;
 	ASC_STATS(shost, callback);
-	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
+	ASC_DBG(1, "shost 0x%p\n", shost);
 
 	boardp = shost_priv(shost);
 	BUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);
@@ -8377,7 +8299,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	 */
 	switch (scsiqp->done_status) {
 	case QD_NO_ERROR:
-		ASC_DBG(2, "adv_isr_callback: QD_NO_ERROR\n");
+		ASC_DBG(2, "QD_NO_ERROR\n");
 		scp->result = 0;
 
 		/*
@@ -8389,20 +8311,18 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 		resid_cnt = le32_to_cpu(scsiqp->data_cnt);
 		if (scp->request_bufflen != 0 && resid_cnt != 0 &&
 		    resid_cnt <= scp->request_bufflen) {
-			ASC_DBG1(1,
-				 "adv_isr_callback: underrun condition %lu bytes\n",
+			ASC_DBG(1, "underrun condition %lu bytes\n",
 				 (ulong)resid_cnt);
 			scp->resid = resid_cnt;
 		}
 		break;
 
 	case QD_WITH_ERROR:
-		ASC_DBG(2, "adv_isr_callback: QD_WITH_ERROR\n");
+		ASC_DBG(2, "QD_WITH_ERROR\n");
 		switch (scsiqp->host_status) {
 		case QHSTA_NO_ERROR:
 			if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
-				ASC_DBG(2,
-					"adv_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+				ASC_DBG(2, "SAM_STAT_CHECK_CONDITION\n");
 				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
 						  sizeof(scp->sense_buffer));
 				/*
@@ -8426,22 +8346,20 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 
 		default:
 			/* Some other QHSTA error occurred. */
-			ASC_DBG1(1, "adv_isr_callback: host_status 0x%x\n",
-				 scsiqp->host_status);
+			ASC_DBG(1, "host_status 0x%x\n", scsiqp->host_status);
 			scp->result = HOST_BYTE(DID_BAD_TARGET);
 			break;
 		}
 		break;
 
 	case QD_ABORTED_BY_HOST:
-		ASC_DBG(1, "adv_isr_callback: QD_ABORTED_BY_HOST\n");
+		ASC_DBG(1, "QD_ABORTED_BY_HOST\n");
 		scp->result =
 		    HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);
 		break;
 
 	default:
-		ASC_DBG1(1, "adv_isr_callback: done_status 0x%x\n",
-			 scsiqp->done_status);
+		ASC_DBG(1, "done_status 0x%x\n", scsiqp->done_status);
 		scp->result =
 		    HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);
 		break;
@@ -8479,7 +8397,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	reqp->next_reqp = boardp->adv_reqp;
 	boardp->adv_reqp = reqp;
 
-	ASC_DBG(1, "adv_isr_callback: done\n");
+	ASC_DBG(1, "done\n");
 
 	return;
 }
@@ -9299,8 +9217,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	struct scsi_cmnd *scp;
 	struct Scsi_Host *shost;
 
-	ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
-		 (ulong)asc_dvc_varp, (ulong)qdonep);
+	ASC_DBG(1, "asc_dvc_varp 0x%p, qdonep 0x%p\n", asc_dvc_varp, qdonep);
 	ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
 
 	/*
@@ -9308,7 +9225,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	 * command that has been completed.
 	 */
 	scp = (struct scsi_cmnd *)ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
-	ASC_DBG1(1, "asc_isr_callback: scp 0x%lx\n", (ulong)scp);
+	ASC_DBG(1, "scp 0x%p\n", scp);
 
 	if (scp == NULL) {
 		ASC_PRINT("asc_isr_callback: scp is NULL\n");
@@ -9318,7 +9235,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 
 	shost = scp->device->host;
 	ASC_STATS(shost, callback);
-	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
+	ASC_DBG(1, "shost 0x%p\n", shost);
 
 	boardp = shost_priv(shost);
 	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
@@ -9328,7 +9245,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	 */
 	switch (qdonep->d3.done_stat) {
 	case QD_NO_ERROR:
-		ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
+		ASC_DBG(2, "QD_NO_ERROR\n");
 		scp->result = 0;
 
 		/*
@@ -9339,20 +9256,18 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 		 */
 		if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
 		    qdonep->remain_bytes <= scp->request_bufflen) {
-			ASC_DBG1(1,
-				 "asc_isr_callback: underrun condition %u bytes\n",
+			ASC_DBG(1, "underrun condition %u bytes\n",
 				 (unsigned)qdonep->remain_bytes);
 			scp->resid = qdonep->remain_bytes;
 		}
 		break;
 
 	case QD_WITH_ERROR:
-		ASC_DBG(2, "asc_isr_callback: QD_WITH_ERROR\n");
+		ASC_DBG(2, "QD_WITH_ERROR\n");
 		switch (qdonep->d3.host_stat) {
 		case QHSTA_NO_ERROR:
 			if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
-				ASC_DBG(2,
-					"asc_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+				ASC_DBG(2, "SAM_STAT_CHECK_CONDITION\n");
 				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
 						  sizeof(scp->sense_buffer));
 				/*
@@ -9376,15 +9291,14 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 
 		default:
 			/* QHSTA error occurred */
-			ASC_DBG1(1, "asc_isr_callback: host_stat 0x%x\n",
-				 qdonep->d3.host_stat);
+			ASC_DBG(1, "host_stat 0x%x\n", qdonep->d3.host_stat);
 			scp->result = HOST_BYTE(DID_BAD_TARGET);
 			break;
 		}
 		break;
 
 	case QD_ABORTED_BY_HOST:
-		ASC_DBG(1, "asc_isr_callback: QD_ABORTED_BY_HOST\n");
+		ASC_DBG(1, "QD_ABORTED_BY_HOST\n");
 		scp->result =
 		    HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.
 						    scsi_msg) |
@@ -9392,8 +9306,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 		break;
 
 	default:
-		ASC_DBG1(1, "asc_isr_callback: done_stat 0x%x\n",
-			 qdonep->d3.done_stat);
+		ASC_DBG(1, "done_stat 0x%x\n", qdonep->d3.done_stat);
 		scp->result =
 		    HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.
 						    scsi_msg) |
@@ -9681,7 +9594,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	int status;
 	int ret = SUCCESS;
 
-	ASC_DBG1(1, "advansys_reset: 0x%p\n", scp);
+	ASC_DBG(1, "0x%p\n", scp);
 
 	ASC_STATS(shost, reset);
 
@@ -9691,7 +9604,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 
 		/* Reset the chip and SCSI bus. */
-		ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
+		ASC_DBG(1, "before AscInitAsc1000Driver()\n");
 		status = AscInitAsc1000Driver(asc_dvc);
 
 		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
@@ -9707,7 +9620,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 				    "successful\n");
 		}
 
-		ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
+		ASC_DBG(1, "after AscInitAsc1000Driver()\n");
 		spin_lock_irqsave(&boardp->lock, flags);
 	} else {
 		/*
@@ -9719,7 +9632,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		/*
 		 * Reset the target's SCSI bus.
 		 */
-		ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
+		ASC_DBG(1, "before AdvResetChipAndSB()\n");
 		switch (AdvResetChipAndSB(adv_dvc)) {
 		case ASC_TRUE:
 			scmd_printk(KERN_INFO, scp, "SCSI bus reset "
@@ -9739,7 +9652,7 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	boardp->last_reset = jiffies;
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
+	ASC_DBG(1, "ret %d\n", ret);
 
 	return ret;
 }
@@ -9761,7 +9674,7 @@ advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 {
 	struct asc_board *boardp = shost_priv(sdev->host);
 
-	ASC_DBG(1, "advansys_biosparam: begin\n");
+	ASC_DBG(1, "begin\n");
 	ASC_STATS(sdev->host, biosparam);
 	if (ASC_NARROW_BOARD(boardp)) {
 		if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
@@ -9783,7 +9696,7 @@ advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 		}
 	}
 	ip[2] = (unsigned long)capacity / (ip[0] * ip[1]);
-	ASC_DBG(1, "advansys_biosparam: end\n");
+	ASC_DBG(1, "end\n");
 	return 0;
 }
 
@@ -9799,17 +9712,17 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	struct asc_board *boardp = shost_priv(shost);
 	irqreturn_t result = IRQ_NONE;
 
-	ASC_DBG1(2, "advansys_interrupt: boardp 0x%p\n", boardp);
+	ASC_DBG(2, "boardp 0x%p\n", boardp);
 	spin_lock_irqsave(&boardp->lock, flags);
 	if (ASC_NARROW_BOARD(boardp)) {
 		if (AscIsIntPending(shost->io_port)) {
 			result = IRQ_HANDLED;
 			ASC_STATS(shost, interrupt);
-			ASC_DBG(1, "advansys_interrupt: before AscISR()\n");
+			ASC_DBG(1, "before AscISR()\n");
 			AscISR(&boardp->dvc_var.asc_dvc_var);
 		}
 	} else {
-		ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
+		ASC_DBG(1, "before AdvISR()\n");
 		if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
 			result = IRQ_HANDLED;
 			ASC_STATS(shost, interrupt);
@@ -9817,7 +9730,7 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	}
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	ASC_DBG(1, "advansys_interrupt: end\n");
+	ASC_DBG(1, "end\n");
 	return result;
 }
 
@@ -10186,7 +10099,7 @@ static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 		}
 	}
 
-	ASC_DBG_PRT_ASC_SCSI_Q(2, &asc_scsi_q);
+	ASC_DBG_PRT_ASC_SCSI_Q(2, asc_scsi_q);
 	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
 	return ASC_NOERROR;
@@ -10229,7 +10142,7 @@ adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 		 * (15) scatter-gather elements.
 		 */
 		if ((sgblkp = boardp->adv_sgblkp) == NULL) {
-			ASC_DBG(1, "adv_get_sglist: no free adv_sgblk_t\n");
+			ASC_DBG(1, "no free adv_sgblk_t\n");
 			ASC_STATS(scp->device->host, adv_build_nosg);
 
 			/*
@@ -10328,7 +10241,7 @@ adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	 * the command.
 	 */
 	if (boardp->adv_reqp == NULL) {
-		ASC_DBG(1, "adv_build_req: no free adv_req_t\n");
+		ASC_DBG(1, "no free adv_req_t\n");
 		ASC_STATS(scp->device->host, adv_build_noreq);
 		return ASC_BUSY;
 	} else {
@@ -11205,7 +11118,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 	int ret, err_code;
 	struct asc_board *boardp = shost_priv(scp->device->host);
 
-	ASC_DBG1(1, "asc_execute_scsi_cmnd: scp 0x%p\n", scp);
+	ASC_DBG(1, "scp 0x%p\n", scp);
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
@@ -11227,12 +11140,10 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 
 		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
 		case ASC_NOERROR:
-			ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req "
-				"ASC_NOERROR\n");
+			ASC_DBG(3, "adv_build_req ASC_NOERROR\n");
 			break;
 		case ASC_BUSY:
-			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
-				"ASC_BUSY\n");
+			ASC_DBG(1, "adv_build_req ASC_BUSY\n");
 			/*
 			 * The asc_stats fields 'adv_build_noreq' and
 			 * 'adv_build_nosg' count wide board busy conditions.
@@ -11242,8 +11153,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			return ASC_BUSY;
 		case ASC_ERROR:
 		default:
-			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
-				"ASC_ERROR\n");
+			ASC_DBG(1, "adv_build_req ASC_ERROR\n");
 			ASC_STATS(scp->device->host, build_error);
 			return ASC_ERROR;
 		}
@@ -11260,8 +11170,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		 * successful request counter. Wrapping doesn't matter.
 		 */
 		boardp->reqcnt[scp->device->id]++;
-		ASC_DBG(1, "asc_execute_scsi_cmnd: ExeScsiQueue(), "
-			"ASC_NOERROR\n");
+		ASC_DBG(1, "ExeScsiQueue() ASC_NOERROR\n");
 		break;
 	case ASC_BUSY:
 		ASC_STATS(scp->device->host, exe_busy);
@@ -11280,7 +11189,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		break;
 	}
 
-	ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");
+	ASC_DBG(1, "end\n");
 	return ret;
 }
 
@@ -11911,7 +11820,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 		AscSetChipCfgMsw(iop_base, cfg_msw);
 	}
 	chksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);
-	ASC_DBG1(1, "AscInitFromEEP: chksum 0x%x\n", chksum);
+	ASC_DBG(1, "chksum 0x%x\n", chksum);
 	if (chksum == 0) {
 		chksum = 0xaa55;
 	}
@@ -11932,13 +11841,11 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	}
 	eep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
 	eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;
-	ASC_DBG1(1, "AscInitFromEEP: eep_config->chksum 0x%x\n",
-		 eep_config->chksum);
+	ASC_DBG(1, "eep_config->chksum 0x%x\n", eep_config->chksum);
 	if (chksum != eep_config->chksum) {
 		if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
 		    ASC_CHIP_VER_PCI_ULTRA_3050) {
-			ASC_DBG(1,
-				"AscInitFromEEP: chksum error ignored; EEPROM-less board\n");
+			ASC_DBG(1, "chksum error ignored; EEPROM-less board\n");
 			eep_config->init_sdtr = 0xFF;
 			eep_config->disc_enable = 0xFF;
 			eep_config->start_motor = 0xFF;
@@ -13517,11 +13424,11 @@ AdvInitGetConfig(struct pci_dev *pdev, struct asc_board *boardp)
 	asc_dvc->cfg->chip_version =
 	    AdvGetChipVersion(iop_base, asc_dvc->bus_type);
 
-	ASC_DBG2(1, "AdvInitGetConfig: iopb_chip_id_1: 0x%x 0x%x\n",
+	ASC_DBG(1, "iopb_chip_id_1: 0x%x 0x%x\n",
 		 (ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),
 		 (ushort)ADV_CHIP_ID_BYTE);
 
-	ASC_DBG2(1, "AdvInitGetConfig: iopw_chip_id_0: 0x%x 0x%x\n",
+	ASC_DBG(1, "iopw_chip_id_0: 0x%x 0x%x\n",
 		 (ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),
 		 (ushort)ADV_CHIP_ID_WORD);
 
@@ -13616,7 +13523,7 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	 * is about 4 KB, so allocate all at once.
 	 */
 	boardp->carrp = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
-	ASC_DBG1(1, "advansys_wide_init_chip: carrp 0x%p\n", boardp->carrp);
+	ASC_DBG(1, "carrp 0x%p\n", boardp->carrp);
 
 	if (!boardp->carrp)
 		goto kmalloc_failed;
@@ -13629,8 +13536,7 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	for (req_cnt = adv_dvc_varp->max_host_qng; req_cnt > 0; req_cnt--) {
 		reqp = kmalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);
 
-		ASC_DBG3(1, "advansys_wide_init_chip: reqp 0x%p, req_cnt %d, "
-			 "bytes %lu\n", reqp, req_cnt,
+		ASC_DBG(1, "reqp 0x%p, req_cnt %d, bytes %lu\n", reqp, req_cnt,
 			 (ulong)sizeof(adv_req_t) * req_cnt);
 
 		if (reqp)
@@ -13658,8 +13564,7 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 
 	}
 
-	ASC_DBG3(1, "advansys_wide_init_chip: sg_cnt %d * %u = %u bytes\n",
-		 sg_cnt, sizeof(adv_sgblk_t),
+	ASC_DBG(1, "sg_cnt %d * %u = %u bytes\n", sg_cnt, sizeof(adv_sgblk_t),
 		 (unsigned)(sizeof(adv_sgblk_t) * sg_cnt));
 
 	if (!boardp->adv_sgblkp)
@@ -13679,15 +13584,13 @@ advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	boardp->adv_reqp = &reqp[0];
 
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		ASC_DBG(2, "advansys_wide_init_chip: AdvInitAsc3550Driver()\n");
+		ASC_DBG(2, "AdvInitAsc3550Driver()\n");
 		warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
 	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		ASC_DBG(2, "advansys_wide_init_chip: AdvInitAsc38C0800Driver()"
-			   "\n");
+		ASC_DBG(2, "AdvInitAsc38C0800Driver()\n");
 		warn_code = AdvInitAsc38C0800Driver(adv_dvc_varp);
 	} else {
-		ASC_DBG(2, "advansys_wide_init_chip: AdvInitAsc38C1600Driver()"
-			   "\n");
+		ASC_DBG(2, "AdvInitAsc38C1600Driver()\n");
 		warn_code = AdvInitAsc38C1600Driver(adv_dvc_varp);
 	}
 	err_code = adv_dvc_varp->err_code;
@@ -13734,7 +13637,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	pdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;
 
 	if (ASC_NARROW_BOARD(boardp)) {
-		ASC_DBG(1, "advansys_board_found: narrow board\n");
+		ASC_DBG(1, "narrow board\n");
 		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 		asc_dvc_varp->bus_type = bus_type;
 		asc_dvc_varp->drv_ptr = boardp;
@@ -13743,18 +13646,17 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		asc_dvc_varp->iop_base = iop;
 	} else {
 #ifdef CONFIG_PCI
-		ASC_DBG(1, "advansys_board_found: wide board\n");
 		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 		adv_dvc_varp->drv_ptr = boardp;
 		adv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;
 		if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {
-			ASC_DBG(1, "advansys_board_found: ASC-3550\n");
+			ASC_DBG(1, "wide board ASC-3550\n");
 			adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;
 		} else if (pdev->device == PCI_DEVICE_ID_38C0800_REV1) {
-			ASC_DBG(1, "advansys_board_found: ASC-38C0800\n");
+			ASC_DBG(1, "wide board ASC-38C0800\n");
 			adv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;
 		} else {
-			ASC_DBG(1, "advansys_board_found: ASC-38C1600\n");
+			ASC_DBG(1, "wide board ASC-38C1600\n");
 			adv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;
 		}
 
@@ -13769,9 +13671,8 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 			ret = -ENODEV;
 			goto err_shost;
 		}
-		adv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr
-		ASC_DBG1(1, "advansys_board_found: iop_base: 0x%lx\n",
-			 adv_dvc_varp->iop_base);
+		adv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr;
+		ASC_DBG(1, "iop_base: 0x%p\n", adv_dvc_varp->iop_base);
 
 		/*
 		 * Even though it isn't used to access wide boards, other
@@ -13780,9 +13681,8 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		 */
 		boardp->ioport = iop;
 
-		ASC_DBG2(1, "advansys_board_found: iopb_chip_id_1 0x%x, "
-			 "iopw_chip_id_0 0x%x\n", (ushort)inp(iop + 1),
-			 (ushort)inpw(iop));
+		ASC_DBG(1, "iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\n",
+				(ushort)inp(iop + 1), (ushort)inpw(iop));
 #endif /* CONFIG_PCI */
 	}
 
@@ -13841,7 +13741,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		 * longer be used. If the bus_type field must be
 		 * referenced only use the bit-wise AND operator "&".
 		 */
-		ASC_DBG(2, "advansys_board_found: AscInitGetConfig()\n");
+		ASC_DBG(2, "AscInitGetConfig()\n");
 		ret = AscInitGetConfig(boardp) ? -ENODEV : 0;
 	} else {
 #ifdef CONFIG_PCI
@@ -13851,7 +13751,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		 */
 		shost->unchecked_isa_dma = FALSE;
 		share_irq = IRQF_SHARED;
-		ASC_DBG(2, "advansys_board_found: AdvInitGetConfig()\n");
+		ASC_DBG(2, "AdvInitGetConfig()\n");
 
 		ret = AdvInitGetConfig(pdev, boardp) ? -ENODEV : 0;
 #endif /* CONFIG_PCI */
@@ -13900,7 +13800,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		/*
 		 * Modify board configuration.
 		 */
-		ASC_DBG(2, "advansys_board_found: AscInitSetConfig()\n");
+		ASC_DBG(2, "AscInitSetConfig()\n");
 		ret = AscInitSetConfig(pdev, boardp) ? -ENODEV : 0;
 		if (ret)
 			goto err_free_proc;
@@ -14081,7 +13981,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		shost->sg_tablesize = SG_ALL;
 	}
 
-	ASC_DBG1(1, "advansys_board_found: sg_tablesize: %d\n", shost->sg_tablesize);
+	ASC_DBG(1, "sg_tablesize: %d\n", shost->sg_tablesize);
 
 	/* BIOS start address. */
 	if (ASC_NARROW_BOARD(boardp)) {
@@ -14101,12 +14001,10 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 		AdvReadWordLram(adv_dvc_varp->iop_base,
 				BIOS_CODELEN, boardp->bios_codelen);
 
-		ASC_DBG2(1,
-			 "advansys_board_found: bios_signature 0x%x, bios_version 0x%x\n",
+		ASC_DBG(1, "bios_signature 0x%x, bios_version 0x%x\n",
 			 boardp->bios_signature, boardp->bios_version);
 
-		ASC_DBG2(1,
-			 "advansys_board_found: bios_codeseg 0x%x, bios_codelen 0x%x\n",
+		ASC_DBG(1, "bios_codeseg 0x%x, bios_codelen 0x%x\n",
 			 boardp->bios_codeseg, boardp->bios_codelen);
 
 		/*
@@ -14148,7 +14046,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 #endif /* CONFIG_ISA */
 
 	/* Register IRQ Number. */
-	ASC_DBG1(2, "advansys_board_found: request_irq() %d\n", boardp->irq);
+	ASC_DBG(2, "request_irq(%d, %p)\n", boardp->irq, shost);
 
 	ret = request_irq(boardp->irq, advansys_interrupt, share_irq,
 			  DRV_NAME, shost);
@@ -14174,7 +14072,7 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 	 * Initialize board RISC chip and enable interrupts.
 	 */
 	if (ASC_NARROW_BOARD(boardp)) {
-		ASC_DBG(2, "advansys_board_found: AscInitAsc1000Driver()\n");
+		ASC_DBG(2, "AscInitAsc1000Driver()\n");
 		warn_code = AscInitAsc1000Driver(asc_dvc_varp);
 
 		if (warn_code || asc_dvc_varp->err_code) {
@@ -14225,11 +14123,11 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 static int advansys_release(struct Scsi_Host *shost)
 {
 	struct asc_board *boardp = shost_priv(shost);
-	ASC_DBG(1, "advansys_release: begin\n");
+	ASC_DBG(1, "begin\n");
 	scsi_remove_host(shost);
 	free_irq(boardp->irq, shost);
 	if (shost->dma_channel != NO_ISA_DMA) {
-		ASC_DBG(1, "advansys_release: free_dma()\n");
+		ASC_DBG(1, "free_dma()\n");
 		free_dma(shost->dma_channel);
 	}
 	if (!ASC_NARROW_BOARD(boardp)) {
@@ -14238,7 +14136,7 @@ static int advansys_release(struct Scsi_Host *shost)
 	}
 	kfree(boardp->prtbuf);
 	scsi_host_put(shost);
-	ASC_DBG(1, "advansys_release: end\n");
+	ASC_DBG(1, "end\n");
 	return 0;
 }
 
@@ -14273,11 +14171,10 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	struct asc_board *board;
 
 	if (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {
-		ASC_DBG1(1, "advansys_isa_match: I/O port 0x%x busy\n",
-			 iop_base);
+		ASC_DBG(1, "I/O port 0x%x busy\n", iop_base);
 		return -ENODEV;
 	}
-	ASC_DBG1(1, "advansys_isa_match: probing I/O port 0x%x\n", iop_base);
+	ASC_DBG(1, "probing I/O port 0x%x\n", iop_base);
 	if (!AscFindSignature(iop_base))
 		goto release_region;
 	if (!(AscGetChipVersion(iop_base, ASC_IS_ISA) & ASC_CHIP_VER_ISA_BIT))
@@ -14351,11 +14248,10 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 	struct asc_board *board;
 
 	if (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {
-		ASC_DBG1(1, "advansys_vlb_match: I/O port 0x%x busy\n",
-			 iop_base);
+		ASC_DBG(1, "I/O port 0x%x busy\n", iop_base);
 		return -ENODEV;
 	}
-	ASC_DBG1(1, "advansys_vlb_match: probing I/O port 0x%x\n", iop_base);
+	ASC_DBG(1, "probing I/O port 0x%x\n", iop_base);
 	if (!AscFindSignature(iop_base))
 		goto release_region;
 	/*

commit b08fc565500a6f691edae7c5ce2e0480365f848c
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:32 2007 -0400

    [SCSI] advansys: Remove library version & serial numbers
    
    With the ASC and ADV libraries merged into the driver, there really is
    no point in reporting their version numbers, or even trying to maintain
    them.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 7570380dc958..72ed9721c44b 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -77,10 +77,6 @@
 /* Enable driver tracing. */
 /* #define ADVANSYS_DEBUG */
 
-#define ASC_LIB_VERSION_MAJOR  1
-#define ASC_LIB_VERSION_MINOR  24
-#define ASC_LIB_SERIAL_NUMBER  123
-
 /*
  * Portable Data Types
  *
@@ -554,8 +550,6 @@ typedef struct asc_dvc_cfg {
 	uchar isa_dma_speed;
 	uchar isa_dma_channel;
 	uchar chip_version;
-	ushort lib_serial_no;
-	ushort lib_version;
 	ushort mcode_date;
 	ushort mcode_version;
 	uchar max_tag_qng[ASC_MAX_TID + 1];
@@ -958,13 +952,6 @@ typedef struct asc_mc_saved {
 #define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)
 #define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)
 
-#define ADV_LIB_VERSION_MAJOR  5
-#define ADV_LIB_VERSION_MINOR  14
-
-/*
- * Define Adv Library required special types.
- */
-
 /*
  * Portable Data Types
  *
@@ -1856,7 +1843,6 @@ typedef struct adv_dvc_cfg {
 	ushort disc_enable;	/* enable disconnection */
 	uchar chip_version;	/* chip version */
 	uchar termination;	/* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */
-	ushort lib_version;	/* Adv Library version number */
 	ushort control_flag;	/* Microcode Control Flag */
 	ushort mcode_date;	/* Microcode date */
 	ushort mcode_version;	/* Microcode version */
@@ -2637,18 +2623,13 @@ static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
 	printk(" disc_enable 0x%x, sdtr_enable 0x%x,\n",
 	       h->disc_enable, h->sdtr_enable);
 
-	printk
-	    (" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, chip_version %d,\n",
-	     h->chip_scsi_id, h->isa_dma_speed, h->isa_dma_channel,
-	     h->chip_version);
-
-	printk
-	    (" pci_device_id %d, lib_serial_no %u, lib_version %u, mcode_date 0x%x,\n",
-	     to_pci_dev(h->dev)->device, h->lib_serial_no, h->lib_version,
-	     h->mcode_date);
+	printk(" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, "
+		"chip_version %d,\n", h->chip_scsi_id, h->isa_dma_speed,
+		h->isa_dma_channel, h->chip_version);
 
-	printk(" mcode_version %d, overrun_buf 0x%lx\n",
-	       h->mcode_version, (ulong)h->overrun_buf);
+	printk(" pci_device_id %d, mcode_date 0x%x, mcode_version %d, "
+		"overrun_buf 0x%p\n", to_pci_dev(h->dev)->device,
+		h->mcode_date, h->mcode_version, h->overrun_buf);
 }
 
 /*
@@ -2752,8 +2733,8 @@ static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
 	printk("  chip_version 0x%x, mcode_date 0x%x\n",
 	       h->chip_version, h->mcode_date);
 
-	printk("  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
-	       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
+	printk("  mcode_version 0x%x, pci_device_id 0x%x\n",
+	       h->mcode_version, to_pci_dev(h->dev)->device);
 
 	printk("  control_flag 0x%x\n", h->control_flag);
 }
@@ -3731,15 +3712,10 @@ static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 			   shost->host_no);
 	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen,
-			   " chip_version %u, lib_version 0x%x, lib_serial_no %u, mcode_date 0x%x\n",
-			   c->chip_version, c->lib_version, c->lib_serial_no,
-			   c->mcode_date);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " mcode_version 0x%x, err_code %u\n",
-			   c->mcode_version, v->err_code);
+	len = asc_prt_line(cp, leftlen, " chip_version %u, mcode_date 0x%x, "
+			   "mcode_version 0x%x, err_code %u\n",
+			   c->chip_version, c->mcode_date, c->mcode_version,
+			   v->err_code);
 	ASC_PRT_NEXT();
 
 	/* Current number of commands waiting for the host. */
@@ -3934,10 +3910,9 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 			   v->err_code);
 	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen,
-			   " chip_version %u, lib_version 0x%x, mcode_date 0x%x, mcode_version 0x%x\n",
-			   c->chip_version, c->lib_version, c->mcode_date,
-			   c->mcode_version);
+	len = asc_prt_line(cp, leftlen, " chip_version %u, mcode_date 0x%x, "
+			   "mcode_version 0x%x\n", c->chip_version,
+			   c->mcode_date, c->mcode_version);
 	ASC_PRT_NEXT();
 
 	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
@@ -11566,9 +11541,6 @@ static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;
 	asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;
 	asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
-	asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER;
-	asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
-	    ASC_LIB_VERSION_MINOR;
 	chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
 	asc_dvc->cfg->chip_version = chip_version;
 	asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
@@ -13542,8 +13514,6 @@ AdvInitGetConfig(struct pci_dev *pdev, struct asc_board *boardp)
 	if ((cmd & PCI_COMMAND_PARITY) == 0)
 		asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
 
-	asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
-	    ADV_LIB_VERSION_MINOR;
 	asc_dvc->cfg->chip_version =
 	    AdvGetChipVersion(iop_base, asc_dvc->bus_type);
 

commit d24114955846c321a9e94fff4764bbef532524b2
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:31 2007 -0400

    [SCSI] advansys: Remove asc_board_t typedef and ASC_BOARDP macro
    
    asc_board_t was simply a typedef for struct asc_board.  ASC_BOARDP()
    can be replaced by shost_priv() except in the ASC_STATS* macros which
    rely on the cast; add an explicit cast there.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0f309e80aaad..7570380dc958 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2203,10 +2203,7 @@ do { \
          (sizeof(ADV_SG_BLOCK) * \
           ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))
 
-/* Reference Scsi_Host hostdata */
-#define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
-
-/* asc_board_t flags */
+/* struct asc_board flags */
 #define ASC_IS_WIDE_BOARD       0x04	/* AdvanSys Wide Board */
 
 #define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)
@@ -2244,15 +2241,12 @@ do { \
 #define HOST_BYTE(byte)     ((byte) << 16)
 #define DRIVER_BYTE(byte)   ((byte) << 24)
 
+#define ASC_STATS(shost, counter) ASC_STATS_ADD(shost, counter, 1)
 #ifndef ADVANSYS_STATS
-#define ASC_STATS(shost, counter)
 #define ASC_STATS_ADD(shost, counter, count)
 #else /* ADVANSYS_STATS */
-#define ASC_STATS(shost, counter) \
-    (ASC_BOARDP(shost)->asc_stats.counter++)
-
 #define ASC_STATS_ADD(shost, counter, count) \
-    (ASC_BOARDP(shost)->asc_stats.counter += (count))
+	(((struct asc_board *) shost_priv(shost))->asc_stats.counter += (count))
 #endif /* ADVANSYS_STATS */
 
 #define ASC_CEILING(val, unit) (((val) + ((unit) - 1))/(unit))
@@ -2475,7 +2469,7 @@ typedef struct adv_req {
  * of the 'Scsi_Host' structure starting at the 'hostdata'
  * field. It is guaranteed to be allocated from DMA-able memory.
  */
-typedef struct asc_board {
+struct asc_board {
 	struct device *dev;
 	int id;			/* Board Id */
 	uint flags;		/* Board flags */
@@ -2523,7 +2517,7 @@ typedef struct asc_board {
 	ushort bios_version;	/* BIOS Version. */
 	ushort bios_codeseg;	/* BIOS Code Segment. */
 	ushort bios_codelen;	/* BIOS Code Segment Length. */
-} asc_board_t;
+};
 
 #define adv_dvc_to_board(adv_dvc) container_of(adv_dvc, struct asc_board, \
 							dvc_var.adv_dvc_var)
@@ -2543,9 +2537,7 @@ static int asc_dbglvl = 3;
  */
 static void asc_prt_scsi_host(struct Scsi_Host *s)
 {
-	asc_board_t *boardp;
-
-	boardp = ASC_BOARDP(s);
+	struct asc_board *boardp = shost_priv(s);
 
 	printk("Scsi_Host at addr 0x%lx\n", (ulong)s);
 	printk(" host_busy %u, host_no %d, last_reset %d,\n",
@@ -2561,11 +2553,11 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 	       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
 
 	if (ASC_NARROW_BOARD(boardp)) {
-		asc_prt_asc_dvc_var(&ASC_BOARDP(s)->dvc_var.asc_dvc_var);
-		asc_prt_asc_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.asc_dvc_cfg);
+		asc_prt_asc_dvc_var(boardp->dvc_var.asc_dvc_var);
+		asc_prt_asc_dvc_cfg(boardp->dvc_cfg.asc_dvc_cfg);
 	} else {
-		asc_prt_adv_dvc_var(&ASC_BOARDP(s)->dvc_var.adv_dvc_var);
-		asc_prt_adv_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.adv_dvc_cfg);
+		asc_prt_adv_dvc_var(boardp->dvc_var.adv_dvc_var);
+		asc_prt_adv_dvc_cfg(boardp->dvc_cfg.adv_dvc_cfg);
 	}
 }
 
@@ -2914,13 +2906,12 @@ static void asc_prt_hex(char *f, uchar *s, int l)
 static const char *advansys_info(struct Scsi_Host *shost)
 {
 	static char info[ASC_INFO_SIZE];
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	ASC_DVC_VAR *asc_dvc_varp;
 	ADV_DVC_VAR *adv_dvc_varp;
 	char *busname;
 	char *widename = NULL;
 
-	boardp = ASC_BOARDP(shost);
 	if (ASC_NARROW_BOARD(boardp)) {
 		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 		ASC_DBG(1, "advansys_info: begin\n");
@@ -3032,14 +3023,13 @@ static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
  */
 static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	int leftlen;
 	int totlen;
 	int len;
 	int chip_scsi_id;
 	int i;
 
-	boardp = ASC_BOARDP(shost);
 	leftlen = cplen;
 	totlen = len = 0;
 
@@ -3073,13 +3063,12 @@ static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
  */
 static int asc_prt_adv_bios(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	int leftlen;
 	int totlen;
 	int len;
 	ushort major, minor, letter;
 
-	boardp = ASC_BOARDP(shost);
 	leftlen = cplen;
 	totlen = len = 0;
 
@@ -3239,7 +3228,7 @@ static int asc_get_eeprom_string(ushort *serialnum, uchar *cp)
  */
 static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	ASC_DVC_VAR *asc_dvc_varp;
 	int leftlen;
 	int totlen;
@@ -3251,7 +3240,6 @@ static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 #endif /* CONFIG_ISA */
 	uchar serialstr[13];
 
-	boardp = ASC_BOARDP(shost);
 	asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 	ep = &boardp->eep_config.asc_eep;
 
@@ -3373,7 +3361,7 @@ static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
  */
 static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	ADV_DVC_VAR *adv_dvc_varp;
 	int leftlen;
 	int totlen;
@@ -3388,7 +3376,6 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
 	ushort *wordp;
 	ushort sdtr_speed = 0;
 
-	boardp = ASC_BOARDP(shost);
 	adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
 		ep_3550 = &boardp->eep_config.adv_3550_eep;
@@ -3660,14 +3647,12 @@ static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen
  */
 static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	int leftlen;
 	int totlen;
 	int len;
 	int chip_scsi_id;
 
-	boardp = ASC_BOARDP(shost);
-
 	leftlen = cplen;
 	totlen = len = 0;
 
@@ -3724,7 +3709,7 @@ static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
  */
 static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	int chip_scsi_id;
 	int leftlen;
 	int totlen;
@@ -3734,7 +3719,6 @@ static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 	int i;
 	int renegotiate = 0;
 
-	boardp = ASC_BOARDP(shost);
 	v = &boardp->dvc_var.asc_dvc_var;
 	c = &boardp->dvc_cfg.asc_dvc_cfg;
 	chip_scsi_id = c->chip_scsi_id;
@@ -3912,7 +3896,7 @@ static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
  */
 static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	int leftlen;
 	int totlen;
 	int len;
@@ -3929,7 +3913,6 @@ static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 	ushort period = 0;
 	int renegotiate = 0;
 
-	boardp = ASC_BOARDP(shost);
 	v = &boardp->dvc_var.adv_dvc_var;
 	c = &boardp->dvc_cfg.adv_dvc_cfg;
 	iop_base = v->iop_base;
@@ -4192,17 +4175,11 @@ asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
  */
 static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	int leftlen;
-	int totlen;
-	int len;
-	struct asc_stats *s;
-	asc_board_t *boardp;
-
-	leftlen = cplen;
-	totlen = len = 0;
+	struct asc_board *boardp = shost_priv(shost);
+	struct asc_stats *s = &boardp->asc_stats;
 
-	boardp = ASC_BOARDP(shost);
-	s = &boardp->asc_stats;
+	int leftlen = cplen;
+	int len, totlen = 0;
 
 	len = asc_prt_line(cp, leftlen,
 			   "\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",
@@ -4309,7 +4286,7 @@ static int
 advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 		   off_t offset, int length, int inout)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	char *cp;
 	int cplen;
 	int cnt;
@@ -4323,16 +4300,13 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	/*
 	 * User write not supported.
 	 */
-	if (inout == TRUE) {
-		return (-ENOSYS);
-	}
+	if (inout == TRUE)
+		return -ENOSYS;
 
 	/*
 	 * User read of /proc/scsi/advansys/[0...] file.
 	 */
 
-	boardp = ASC_BOARDP(shost);
-
 	/* Copy read data starting at the beginning of the buffer. */
 	*start = buffer;
 	curbuf = buffer;
@@ -4477,7 +4451,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 
 static void asc_scsi_done(struct scsi_cmnd *scp)
 {
-	struct asc_board *boardp = ASC_BOARDP(scp->device->host);
+	struct asc_board *boardp = shost_priv(scp->device->host);
 
 	if (scp->use_sg)
 		dma_unmap_sg(boardp->dev,
@@ -8376,7 +8350,7 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
  */
 static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp;
 	adv_req_t *reqp;
 	adv_sgblk_t *sgblkp;
 	struct scsi_cmnd *scp;
@@ -8420,7 +8394,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	ASC_STATS(shost, callback);
 	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
 
-	boardp = ASC_BOARDP(shost);
+	boardp = shost_priv(shost);
 	BUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);
 
 	/*
@@ -8825,7 +8799,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 	uchar cur_dvc_qng;
 	uchar asyn_sdtr;
 	uchar scsi_status;
-	asc_board_t *boardp;
+	struct asc_board *boardp;
 
 	BUG_ON(!asc_dvc->drv_ptr);
 	boardp = asc_dvc->drv_ptr;
@@ -9346,7 +9320,7 @@ _AscCopyLramScsiDoneQ(PortAddr iop_base,
  */
 static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp;
 	struct scsi_cmnd *scp;
 	struct Scsi_Host *shost;
 
@@ -9371,7 +9345,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	ASC_STATS(shost, callback);
 	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
 
-	boardp = ASC_BOARDP(shost);
+	boardp = shost_priv(shost);
 	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
 
 	/*
@@ -9727,7 +9701,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 static int advansys_reset(struct scsi_cmnd *scp)
 {
 	struct Scsi_Host *shost = scp->device->host;
-	struct asc_board *boardp = ASC_BOARDP(shost);
+	struct asc_board *boardp = shost_priv(shost);
 	unsigned long flags;
 	int status;
 	int ret = SUCCESS;
@@ -9810,11 +9784,10 @@ static int
 advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 		   sector_t capacity, int ip[])
 {
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(sdev->host);
 
 	ASC_DBG(1, "advansys_biosparam: begin\n");
 	ASC_STATS(sdev->host, biosparam);
-	boardp = ASC_BOARDP(sdev->host);
 	if (ASC_NARROW_BOARD(boardp)) {
 		if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
 		     ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {
@@ -9848,7 +9821,7 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 {
 	unsigned long flags;
 	struct Scsi_Host *shost = dev_id;
-	asc_board_t *boardp = ASC_BOARDP(shost);
+	struct asc_board *boardp = shost_priv(shost);
 	irqreturn_t result = IRQ_NONE;
 
 	ASC_DBG1(2, "advansys_interrupt: boardp 0x%p\n", boardp);
@@ -10110,7 +10083,7 @@ advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
  */
 static int advansys_slave_configure(struct scsi_device *sdev)
 {
-	asc_board_t *boardp = ASC_BOARDP(sdev->host);
+	struct asc_board *boardp = shost_priv(sdev->host);
 
 	if (ASC_NARROW_BOARD(boardp))
 		advansys_narrow_slave_configure(sdev,
@@ -10122,7 +10095,7 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
-static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
+static int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 			struct asc_scsi_q *asc_scsi_q)
 {
 	memset(asc_scsi_q, 0, sizeof(*asc_scsi_q));
@@ -10257,7 +10230,7 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
  *      ADV_ERROR(-1) - SG List creation failed
  */
 static int
-adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
+adv_get_sglist(struct asc_board *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 	       int use_sg)
 {
 	adv_sgblk_t *sgblkp;
@@ -10367,7 +10340,7 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
  * to little-endian order.
  */
 static int
-adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
+adv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,
 	      ADV_SCSI_REQ_Q **adv_scsiqpp)
 {
 	adv_req_t *reqp;
@@ -11255,7 +11228,7 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 {
 	int ret, err_code;
-	asc_board_t *boardp = ASC_BOARDP(scp->device->host);
+	struct asc_board *boardp = shost_priv(scp->device->host);
 
 	ASC_DBG1(1, "asc_execute_scsi_cmnd: scp 0x%p\n", scp);
 
@@ -11346,7 +11319,7 @@ static int
 advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *shost = scp->device->host;
-	asc_board_t *boardp = ASC_BOARDP(shost);
+	struct asc_board *boardp = shost_priv(shost);
 	unsigned long flags;
 	int asc_res, result = 0;
 
@@ -12094,7 +12067,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static int __devinit AscInitGetConfig(asc_board_t *boardp)
+static int __devinit AscInitGetConfig(struct asc_board *boardp)
 {
 	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 	unsigned short warn_code = 0;
@@ -12151,7 +12124,7 @@ static int __devinit AscInitGetConfig(asc_board_t *boardp)
 	return asc_dvc->err_code;
 }
 
-static int __devinit AscInitSetConfig(struct pci_dev *pdev, asc_board_t *boardp)
+static int __devinit AscInitSetConfig(struct pci_dev *pdev, struct asc_board *boardp)
 {
 	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 	PortAddr iop_base = asc_dvc->iop_base;
@@ -13548,7 +13521,7 @@ static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
  * then 0 is returned.
  */
 static int __devinit
-AdvInitGetConfig(struct pci_dev *pdev, asc_board_t *boardp)
+AdvInitGetConfig(struct pci_dev *pdev, struct asc_board *boardp)
 {
 	ADV_DVC_VAR *asc_dvc = &boardp->dvc_var.adv_dvc_var;
 	unsigned short warn_code = 0;
@@ -13660,7 +13633,7 @@ static struct scsi_host_template advansys_template = {
 };
 
 static int __devinit
-advansys_wide_init_chip(asc_board_t *boardp, ADV_DVC_VAR *adv_dvc_varp)
+advansys_wide_init_chip(struct asc_board *boardp, ADV_DVC_VAR *adv_dvc_varp)
 {
 	int req_cnt = 0;
 	adv_req_t *reqp = NULL;
@@ -13764,7 +13737,7 @@ advansys_wide_init_chip(asc_board_t *boardp, ADV_DVC_VAR *adv_dvc_varp)
 	return err_code;
 }
 
-static void advansys_wide_free_mem(asc_board_t *boardp)
+static void advansys_wide_free_mem(struct asc_board *boardp)
 {
 	kfree(boardp->carrp);
 	boardp->carrp = NULL;
@@ -13781,12 +13754,11 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
 					  unsigned int iop, int bus_type)
 {
 	struct pci_dev *pdev;
-	asc_board_t *boardp;
+	struct asc_board *boardp = shost_priv(shost);
 	ASC_DVC_VAR *asc_dvc_varp = NULL;
 	ADV_DVC_VAR *adv_dvc_varp = NULL;
 	int share_irq, warn_code, ret;
 
-	boardp = ASC_BOARDP(shost);
 	boardp->id = asc_board_count++;
 	spin_lock_init(&boardp->lock);
 	pdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;
@@ -14282,11 +14254,9 @@ static int __devinit advansys_board_found(struct Scsi_Host *shost,
  */
 static int advansys_release(struct Scsi_Host *shost)
 {
-	asc_board_t *boardp;
-
+	struct asc_board *boardp = shost_priv(shost);
 	ASC_DBG(1, "advansys_release: begin\n");
 	scsi_remove_host(shost);
-	boardp = ASC_BOARDP(shost);
 	free_irq(boardp->irq, shost);
 	if (shost->dma_channel != NO_ISA_DMA) {
 		ASC_DBG(1, "advansys_release: free_dma()\n");
@@ -14348,7 +14318,7 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	if (!shost)
 		goto release_region;
 
-	board = ASC_BOARDP(shost);
+	board = shost_priv(shost);
 	board->irq = advansys_isa_irq_no(iop_base);
 	board->dev = dev;
 
@@ -14431,7 +14401,7 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 	if (!shost)
 		goto release_region;
 
-	board = ASC_BOARDP(shost);
+	board = shost_priv(shost);
 	board->irq = advansys_vlb_irq_no(iop_base);
 	board->dev = dev;
 
@@ -14538,7 +14508,7 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 		if (!shost)
 			goto release_region;
 
-		board = ASC_BOARDP(shost);
+		board = shost_priv(shost);
 		board->irq = irq;
 		board->dev = dev;
 
@@ -14654,7 +14624,7 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (!shost)
 		goto release_region;
 
-	board = ASC_BOARDP(shost);
+	board = shost_priv(shost);
 	board->irq = pdev->irq;
 	board->dev = &pdev->dev;
 

commit 720349a879d3e37f3d932bf3ca9b94ac638d59b6
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:30 2007 -0400

    [SCSI] advansys: Merge ASC_IERR definitions
    
    There were two blocks of ASC_IERR definitions; one for narrow and one for
    wide boards.  Some of the same names were used (with the same values),
    and some of the same values were used with different names.  This could
    only lead to confusion, so I unified them in one block of definitions
    with no overlapping values.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e2bd4c9e7c22..0f309e80aaad 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -459,14 +459,22 @@ typedef struct asc_risc_sg_list_q {
 #define ASC_WARN_CFG_MSW_RECOVER      0x0040
 
 /*
- * Error code values are set in ASC_DVC_VAR  'err_code'.
- */
-#define ASC_IERR_MCODE_CHKSUM         0x0002
-#define ASC_IERR_SET_PC_ADDR          0x0004
-#define ASC_IERR_START_STOP_CHIP      0x0008
-#define ASC_IERR_SET_SCSI_ID          0x0080
-#define ASC_IERR_BAD_SIGNATURE        0x0200
-#define ASC_IERR_NO_BUS_TYPE          0x0400
+ * Error code values are set in {ASC/ADV}_DVC_VAR  'err_code'.
+ */
+#define ASC_IERR_NO_CARRIER		0x0001	/* No more carrier memory */
+#define ASC_IERR_MCODE_CHKSUM		0x0002	/* micro code check sum error */
+#define ASC_IERR_SET_PC_ADDR		0x0004
+#define ASC_IERR_START_STOP_CHIP	0x0008	/* start/stop chip failed */
+#define ASC_IERR_ILLEGAL_CONNECTION	0x0010	/* Illegal cable connection */
+#define ASC_IERR_SINGLE_END_DEVICE	0x0020	/* SE device on DIFF bus */
+#define ASC_IERR_REVERSED_CABLE		0x0040	/* Narrow flat cable reversed */
+#define ASC_IERR_SET_SCSI_ID		0x0080	/* set SCSI ID failed */
+#define ASC_IERR_HVD_DEVICE		0x0100	/* HVD device on LVD port */
+#define ASC_IERR_BAD_SIGNATURE		0x0200	/* signature not found */
+#define ASC_IERR_NO_BUS_TYPE		0x0400
+#define ASC_IERR_BIST_PRE_TEST		0x0800	/* BIST pre-test error */
+#define ASC_IERR_BIST_RAM_TEST		0x1000	/* BIST RAM test error */
+#define ASC_IERR_BAD_CHIPTYPE		0x2000	/* Invalid chip_type setting */
 
 #define ASC_DEF_MAX_TOTAL_QNG   (0xF0)
 #define ASC_MIN_TAG_Q_PER_DVC   (0x04)
@@ -1697,22 +1705,6 @@ typedef struct adveep_38C1600_config {
 #define ADV_MAX_TID                     15	/* max. target identifier */
 #define ADV_MAX_LUN                     7	/* max. logical unit number */
 
-/*
- * Error code values are set in ADV_DVC_VAR 'err_code'.
- */
-#define ASC_IERR_MCODE_CHKSUM       0x0002	/* micro code check sum error */
-#define ASC_IERR_NO_CARRIER         0x0004	/* No more carrier memory. */
-#define ASC_IERR_START_STOP_CHIP    0x0008	/* start/stop chip failed */
-#define ASC_IERR_SET_SCSI_ID        0x0080	/* set SCSI ID failed */
-#define ASC_IERR_HVD_DEVICE         0x0100	/* HVD attached to LVD connector. */
-#define ASC_IERR_BAD_SIGNATURE      0x0200	/* signature not found */
-#define ASC_IERR_ILLEGAL_CONNECTION 0x0400	/* Illegal cable connection */
-#define ASC_IERR_SINGLE_END_DEVICE  0x0800	/* Single-end used w/differential */
-#define ASC_IERR_REVERSED_CABLE     0x1000	/* Narrow flat cable reversed */
-#define ASC_IERR_BIST_PRE_TEST      0x2000	/* BIST pre-test error */
-#define ASC_IERR_BIST_RAM_TEST      0x4000	/* BIST RAM test error */
-#define ASC_IERR_BAD_CHIPTYPE       0x8000	/* Invalid 'chip_type' setting. */
-
 /*
  * Fixed locations of microcode operating variables.
  */

commit d361db483241489fc4b37cd168c2ce7940a7845b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:29 2007 -0400

    [SCSI] advansys: Sort out irq number mess
    
    The interrupt number was being stored in 4-5 different places, each with
    its own type, rules and usage.  Fix this by keeping an unsigned int in
    the struct asc_board, and filling it in from the bus probe functions
    (since it's different for each of the four bus types).  In order to do
    this, we have to allocate the Scsi_Host in the bus probe functions too.
    Then we can return an error from advansys_board_found, which requires
    a little rearranging of code (and removing of the err_code variable).
    Move the Wide Board flag setting into the PCI bus probe function.
    
    Split the AscGetChipIRQ function into three functions (one for each bus
    type that needs it) and add some commentary to explain what's going on.
    Also get rid of the AscSetChipIRQ function as we only ever set the
    interrupt number to the same value it already had.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index a5bb4e416bea..e2bd4c9e7c22 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -461,23 +461,13 @@ typedef struct asc_risc_sg_list_q {
 /*
  * Error code values are set in ASC_DVC_VAR  'err_code'.
  */
-#define ASC_IERR_WRITE_EEPROM         0x0001
 #define ASC_IERR_MCODE_CHKSUM         0x0002
 #define ASC_IERR_SET_PC_ADDR          0x0004
 #define ASC_IERR_START_STOP_CHIP      0x0008
-#define ASC_IERR_IRQ_NO               0x0010
-#define ASC_IERR_SET_IRQ_NO           0x0020
-#define ASC_IERR_CHIP_VERSION         0x0040
 #define ASC_IERR_SET_SCSI_ID          0x0080
-#define ASC_IERR_GET_PHY_ADDR         0x0100
 #define ASC_IERR_BAD_SIGNATURE        0x0200
 #define ASC_IERR_NO_BUS_TYPE          0x0400
-#define ASC_IERR_SCAM                 0x0800
-#define ASC_IERR_SET_SDTR             0x1000
-#define ASC_IERR_RW_LRAM              0x8000
 
-#define ASC_MAX_IRQ_NO  15
-#define ASC_MIN_IRQ_NO  10
 #define ASC_DEF_MAX_TOTAL_QNG   (0xF0)
 #define ASC_MIN_TAG_Q_PER_DVC   (0x04)
 #define ASC_MIN_FREE_Q        (0x02)
@@ -605,7 +595,6 @@ typedef struct asc_dvc_var {
 	uchar max_total_qng;
 	uchar cur_total_qng;
 	uchar in_critical_cnt;
-	uchar irq_no;
 	uchar last_q_shortage;
 	ushort init_state;
 	uchar cur_dvc_qng[ASC_MAX_TID + 1];
@@ -1711,11 +1700,9 @@ typedef struct adveep_38C1600_config {
 /*
  * Error code values are set in ADV_DVC_VAR 'err_code'.
  */
-#define ASC_IERR_WRITE_EEPROM       0x0001	/* write EEPROM error */
 #define ASC_IERR_MCODE_CHKSUM       0x0002	/* micro code check sum error */
 #define ASC_IERR_NO_CARRIER         0x0004	/* No more carrier memory. */
 #define ASC_IERR_START_STOP_CHIP    0x0008	/* start/stop chip failed */
-#define ASC_IERR_CHIP_VERSION       0x0040	/* wrong chip version */
 #define ASC_IERR_SET_SCSI_ID        0x0080	/* set SCSI ID failed */
 #define ASC_IERR_HVD_DEVICE         0x0100	/* HVD attached to LVD connector. */
 #define ASC_IERR_BAD_SIGNATURE      0x0200	/* signature not found */
@@ -1919,7 +1906,6 @@ typedef struct adv_dvc_var {
 	uchar scsi_reset_wait;	/* delay in seconds after scsi bus reset */
 	uchar chip_no;		/* should be assigned by caller */
 	uchar max_host_qng;	/* maximum number of Q'ed command allowed */
-	uchar irq_no;		/* IRQ number */
 	ushort no_scam;		/* scam_tolerant of EEPROM */
 	struct asc_board *drv_ptr;	/* driver pointer to private structure */
 	uchar chip_scsi_id;	/* chip SCSI target ID */
@@ -2501,6 +2487,7 @@ typedef struct asc_board {
 	struct device *dev;
 	int id;			/* Board Id */
 	uint flags;		/* Board flags */
+	unsigned int irq;
 	union {
 		ASC_DVC_VAR asc_dvc_var;	/* Narrow board */
 		ADV_DVC_VAR adv_dvc_var;	/* Wide board */
@@ -2573,7 +2560,7 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 	       s->host_busy, s->host_no, (unsigned)s->last_reset);
 
 	printk(" base 0x%lx, io_port 0x%lx, irq 0x%x,\n",
-	       (ulong)s->base, (ulong)s->io_port, s->irq);
+	       (ulong)s->base, (ulong)s->io_port, boardp->irq);
 
 	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
 	       s->dma_channel, s->this_id, s->can_queue);
@@ -2651,7 +2638,7 @@ static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
 	       (unsigned)h->init_state, (unsigned)h->no_scam,
 	       (unsigned)h->pci_fix_asyn_xfer);
 
-	printk(" cfg 0x%lx, irq_no 0x%x\n", (ulong)h->cfg, (unsigned)h->irq_no);
+	printk(" cfg 0x%lx\n", (ulong)h->cfg);
 }
 
 /*
@@ -2749,9 +2736,8 @@ static void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
 	       (ulong)h->isr_callback, (unsigned)h->sdtr_able,
 	       (unsigned)h->wdtr_able);
 
-	printk("  start_motor 0x%x, scsi_reset_wait 0x%x, irq_no 0x%x,\n",
-	       (unsigned)h->start_motor,
-	       (unsigned)h->scsi_reset_wait, (unsigned)h->irq_no);
+	printk("  start_motor 0x%x, scsi_reset_wait 0x%x\n",
+	       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);
 
 	printk("  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
 	       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,
@@ -2958,7 +2944,7 @@ static const char *advansys_info(struct Scsi_Host *shost)
 				ASC_VERSION, busname,
 				(ulong)shost->io_port,
 				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
-				shost->irq, shost->dma_channel);
+				boardp->irq, shost->dma_channel);
 		} else {
 			if (asc_dvc_varp->bus_type & ASC_IS_VL) {
 				busname = "VL";
@@ -2981,7 +2967,7 @@ static const char *advansys_info(struct Scsi_Host *shost)
 				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
 				ASC_VERSION, busname, (ulong)shost->io_port,
 				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
-				shost->irq);
+				boardp->irq);
 		}
 	} else {
 		/*
@@ -3002,7 +2988,7 @@ static const char *advansys_info(struct Scsi_Host *shost)
 		sprintf(info,
 			"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
 			ASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,
-			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, shost->irq);
+			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, boardp->irq);
 	}
 	BUG_ON(strlen(info) >= ASC_INFO_SIZE);
 	ASC_DBG(1, "advansys_info: end\n");
@@ -11479,77 +11465,6 @@ AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
 	return AscGetChipVerNo(iop_base);
 }
 
-static void __devinit AscToggleIRQAct(PortAddr iop_base)
-{
-	AscSetChipStatus(iop_base, CIW_IRQ_ACT);
-	AscSetChipStatus(iop_base, 0);
-	return;
-}
-
-static uchar __devinit AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
-{
-	ushort cfg_lsw;
-	uchar chip_irq;
-
-	if ((bus_type & ASC_IS_EISA) != 0) {
-		cfg_lsw = AscGetEisaChipCfg(iop_base);
-		chip_irq = (uchar)(((cfg_lsw >> 8) & 0x07) + 10);
-		if ((chip_irq == 13) || (chip_irq > 15)) {
-			return (0);
-		}
-		return (chip_irq);
-	}
-	if ((bus_type & ASC_IS_VL) != 0) {
-		cfg_lsw = AscGetChipCfgLsw(iop_base);
-		chip_irq = (uchar)(((cfg_lsw >> 2) & 0x07));
-		if ((chip_irq == 0) || (chip_irq == 4) || (chip_irq == 7)) {
-			return (0);
-		}
-		return ((uchar)(chip_irq + (ASC_MIN_IRQ_NO - 1)));
-	}
-	cfg_lsw = AscGetChipCfgLsw(iop_base);
-	chip_irq = (uchar)(((cfg_lsw >> 2) & 0x03));
-	if (chip_irq == 3)
-		chip_irq += (uchar)2;
-	return ((uchar)(chip_irq + ASC_MIN_IRQ_NO));
-}
-
-static uchar __devinit
-AscSetChipIRQ(PortAddr iop_base, uchar irq_no, ushort bus_type)
-{
-	ushort cfg_lsw;
-
-	if ((bus_type & ASC_IS_VL) != 0) {
-		if (irq_no != 0) {
-			if ((irq_no < ASC_MIN_IRQ_NO)
-			    || (irq_no > ASC_MAX_IRQ_NO)) {
-				irq_no = 0;
-			} else {
-				irq_no -= (uchar)((ASC_MIN_IRQ_NO - 1));
-			}
-		}
-		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE3);
-		cfg_lsw |= (ushort)0x0010;
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		AscToggleIRQAct(iop_base);
-		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE0);
-		cfg_lsw |= (ushort)((irq_no & 0x07) << 2);
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		AscToggleIRQAct(iop_base);
-		return (AscGetChipIRQ(iop_base, bus_type));
-	}
-	if ((bus_type & (ASC_IS_ISA)) != 0) {
-		if (irq_no == 15)
-			irq_no -= (uchar)2;
-		irq_no -= (uchar)ASC_MIN_IRQ_NO;
-		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFF3);
-		cfg_lsw |= (ushort)((irq_no & 0x03) << 2);
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		return (AscGetChipIRQ(iop_base, bus_type));
-	}
-	return (0);
-}
-
 #ifdef CONFIG_ISA
 static void __devinit AscEnableIsaDma(uchar dma_channel)
 {
@@ -12157,9 +12072,6 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 		eep_config->disc_enable = eep_config->use_cmd_qng;
 		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
 	}
-	if (asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA)) {
-		asc_dvc->irq_no = AscGetChipIRQ(iop_base, asc_dvc->bus_type);
-	}
 	ASC_EEP_SET_CHIP_ID(eep_config,
 			    ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);
 	asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
@@ -12276,12 +12188,6 @@ static int __devinit AscInitSetConfig(struct pci_dev *pdev, asc_board_t *boardp)
 	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
 		warn_code |= ASC_WARN_AUTO_CONFIG;
 	}
-	if ((asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {
-		if (AscSetChipIRQ(iop_base, asc_dvc->irq_no, asc_dvc->bus_type)
-		    != asc_dvc->irq_no) {
-			asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
-		}
-	}
 #ifdef CONFIG_PCI
 	if (asc_dvc->bus_type & ASC_IS_PCI) {
 		cfg_msw &= 0xFFC0;
@@ -13879,49 +13785,19 @@ static void advansys_wide_free_mem(asc_board_t *boardp)
 	}
 }
 
-static struct Scsi_Host *__devinit
-advansys_board_found(int iop, struct device *dev, int bus_type)
+static int __devinit advansys_board_found(struct Scsi_Host *shost,
+					  unsigned int iop, int bus_type)
 {
-	struct Scsi_Host *shost;
-	struct pci_dev *pdev = bus_type == ASC_IS_PCI ? to_pci_dev(dev) : NULL;
+	struct pci_dev *pdev;
 	asc_board_t *boardp;
 	ASC_DVC_VAR *asc_dvc_varp = NULL;
 	ADV_DVC_VAR *adv_dvc_varp = NULL;
-	int share_irq;
-	int warn_code, err_code;
-	int ret;
-
-	/*
-	 * Register the adapter, get its configuration, and
-	 * initialize it.
-	 */
-	ASC_DBG(2, "advansys_board_found: scsi_host_alloc()\n");
-	shost = scsi_host_alloc(&advansys_template, sizeof(asc_board_t));
-	if (!shost)
-		return NULL;
+	int share_irq, warn_code, ret;
 
-	/* Initialize private per board data */
 	boardp = ASC_BOARDP(shost);
-	memset(boardp, 0, sizeof(asc_board_t));
 	boardp->id = asc_board_count++;
 	spin_lock_init(&boardp->lock);
-	boardp->dev = dev;
-
-	/*
-	 * Handle both narrow and wide boards.
-	 *
-	 * If a Wide board was detected, set the board structure
-	 * wide board flag. Set-up the board structure based on
-	 * the board type.
-	 */
-#ifdef CONFIG_PCI
-	if (bus_type == ASC_IS_PCI &&
-	    (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||
-	     pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||
-	     pdev->device == PCI_DEVICE_ID_38C1600_REV1)) {
-		boardp->flags |= ASC_IS_WIDE_BOARD;
-	}
-#endif /* CONFIG_PCI */
+	pdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		ASC_DBG(1, "advansys_board_found: narrow board\n");
@@ -13956,6 +13832,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			    ("advansys_board_found: board %d: ioremap(%x, %d) returned NULL\n",
 			     boardp->id, pci_resource_start(pdev, 1),
 			     boardp->asc_n_io_port);
+			ret = -ENODEV;
 			goto err_shost;
 		}
 		adv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr
@@ -13984,6 +13861,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	if (!boardp->prtbuf) {
 		ASC_PRINT2("advansys_board_found: board %d: kmalloc(%d) "
 			   "returned NULL\n", boardp->id, ASC_PRTBUF_SIZE);
+		ret = -ENOMEM;
 		goto err_unmap;
 	}
 #endif /* CONFIG_PROC_FS */
@@ -14010,7 +13888,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 #endif /* CONFIG_ISA */
 #ifdef CONFIG_PCI
 		case ASC_IS_PCI:
-			shost->irq = asc_dvc_varp->irq_no = pdev->irq;
 			shost->unchecked_isa_dma = FALSE;
 			share_irq = IRQF_SHARED;
 			break;
@@ -14031,23 +13908,22 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 * referenced only use the bit-wise AND operator "&".
 		 */
 		ASC_DBG(2, "advansys_board_found: AscInitGetConfig()\n");
-		err_code = AscInitGetConfig(boardp);
+		ret = AscInitGetConfig(boardp) ? -ENODEV : 0;
 	} else {
 #ifdef CONFIG_PCI
 		/*
 		 * For Wide boards set PCI information before calling
 		 * AdvInitGetConfig().
 		 */
-		shost->irq = adv_dvc_varp->irq_no = pdev->irq;
 		shost->unchecked_isa_dma = FALSE;
 		share_irq = IRQF_SHARED;
 		ASC_DBG(2, "advansys_board_found: AdvInitGetConfig()\n");
 
-		err_code = AdvInitGetConfig(pdev, boardp);
+		ret = AdvInitGetConfig(pdev, boardp) ? -ENODEV : 0;
 #endif /* CONFIG_PCI */
 	}
 
-	if (err_code != 0)
+	if (ret)
 		goto err_free_proc;
 
 	/*
@@ -14091,17 +13967,9 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 * Modify board configuration.
 		 */
 		ASC_DBG(2, "advansys_board_found: AscInitSetConfig()\n");
-		err_code = AscInitSetConfig(pdev, boardp);
-		if (err_code)
+		ret = AscInitSetConfig(pdev, boardp) ? -ENODEV : 0;
+		if (ret)
 			goto err_free_proc;
-
-		/*
-		 * Finish initializing the 'Scsi_Host' structure.
-		 */
-		/* AscInitSetConfig() will set the IRQ for non-PCI boards. */
-		if ((asc_dvc_varp->bus_type & ASC_IS_PCI) == 0) {
-			shost->irq = asc_dvc_varp->irq_no;
-		}
 	} else {
 		ADVEEP_3550_CONFIG *ep_3550;
 		ADVEEP_38C0800_CONFIG *ep_38C0800;
@@ -14346,24 +14214,24 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 #endif /* CONFIG_ISA */
 
 	/* Register IRQ Number. */
-	ASC_DBG1(2, "advansys_board_found: request_irq() %d\n", shost->irq);
+	ASC_DBG1(2, "advansys_board_found: request_irq() %d\n", boardp->irq);
 
-	ret = request_irq(shost->irq, advansys_interrupt, share_irq,
+	ret = request_irq(boardp->irq, advansys_interrupt, share_irq,
 			  DRV_NAME, shost);
 
 	if (ret) {
 		if (ret == -EBUSY) {
 			ASC_PRINT2
 			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x already in use.\n",
-			     boardp->id, shost->irq);
+			     boardp->id, boardp->irq);
 		} else if (ret == -EINVAL) {
 			ASC_PRINT2
 			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x not valid.\n",
-			     boardp->id, shost->irq);
+			     boardp->id, boardp->irq);
 		} else {
 			ASC_PRINT3
 			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x failed with %d\n",
-			     boardp->id, shost->irq, ret);
+			     boardp->id, boardp->irq, ret);
 		}
 		goto err_free_dma;
 	}
@@ -14374,33 +14242,35 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	if (ASC_NARROW_BOARD(boardp)) {
 		ASC_DBG(2, "advansys_board_found: AscInitAsc1000Driver()\n");
 		warn_code = AscInitAsc1000Driver(asc_dvc_varp);
-		err_code = asc_dvc_varp->err_code;
 
-		if (warn_code || err_code) {
-			ASC_PRINT4
-			    ("advansys_board_found: board %d error: init_state 0x%x, warn 0x%x, error 0x%x\n",
-			     boardp->id,
-			     asc_dvc_varp->init_state, warn_code, err_code);
+		if (warn_code || asc_dvc_varp->err_code) {
+			ASC_PRINT4("advansys_board_found: board %d error: "
+				   "init_state 0x%x, warn 0x%x, error 0x%x\n",
+				   boardp->id, asc_dvc_varp->init_state,
+				   warn_code, asc_dvc_varp->err_code);
+			if (asc_dvc_varp->err_code)
+				ret = -ENODEV;
 		}
 	} else {
-		err_code = advansys_wide_init_chip(boardp, adv_dvc_varp);
+		if (advansys_wide_init_chip(boardp, adv_dvc_varp))
+			ret = -ENODEV;
 	}
 
-	if (err_code != 0)
+	if (ret)
 		goto err_free_wide_mem;
 
 	ASC_DBG_PRT_SCSI_HOST(2, shost);
 
-	ret = scsi_add_host(shost, dev);
+	ret = scsi_add_host(shost, boardp->dev);
 	if (ret)
 		goto err_free_wide_mem;
 
 	scsi_scan_host(shost);
-	return shost;
+	return 0;
 
  err_free_wide_mem:
 	advansys_wide_free_mem(boardp);
-	free_irq(shost->irq, shost);
+	free_irq(boardp->irq, shost);
  err_free_dma:
 	if (shost->dma_channel != NO_ISA_DMA)
 		free_dma(shost->dma_channel);
@@ -14410,8 +14280,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	if (boardp->ioremap_addr)
 		iounmap(boardp->ioremap_addr);
  err_shost:
-	scsi_host_put(shost);
-	return NULL;
+	return ret;
 }
 
 /*
@@ -14426,7 +14295,7 @@ static int advansys_release(struct Scsi_Host *shost)
 	ASC_DBG(1, "advansys_release: begin\n");
 	scsi_remove_host(shost);
 	boardp = ASC_BOARDP(shost);
-	free_irq(shost->irq, shost);
+	free_irq(boardp->irq, shost);
 	if (shost->dma_channel != NO_ISA_DMA) {
 		ASC_DBG(1, "advansys_release: free_dma()\n");
 		free_dma(shost->dma_channel);
@@ -14448,10 +14317,28 @@ static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __devinitdata = {
 	0x0210, 0x0230, 0x0250, 0x0330
 };
 
+/*
+ * The ISA IRQ number is found in bits 2 and 3 of the CfgLsw.  It decodes as:
+ * 00: 10
+ * 01: 11
+ * 10: 12
+ * 11: 15
+ */
+static unsigned int __devinit advansys_isa_irq_no(PortAddr iop_base)
+{
+	unsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);
+	unsigned int chip_irq = ((cfg_lsw >> 2) & 0x03) + 10;
+	if (chip_irq == 13)
+		chip_irq = 15;
+	return chip_irq;
+}
+
 static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 {
+	int err = -ENODEV;
 	PortAddr iop_base = _asc_def_iop_base[id];
 	struct Scsi_Host *shost;
+	struct asc_board *board;
 
 	if (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {
 		ASC_DBG1(1, "advansys_isa_match: I/O port 0x%x busy\n",
@@ -14460,20 +14347,31 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	}
 	ASC_DBG1(1, "advansys_isa_match: probing I/O port 0x%x\n", iop_base);
 	if (!AscFindSignature(iop_base))
-		goto nodev;
+		goto release_region;
 	if (!(AscGetChipVersion(iop_base, ASC_IS_ISA) & ASC_CHIP_VER_ISA_BIT))
-		goto nodev;
+		goto release_region;
 
-	shost = advansys_board_found(iop_base, dev, ASC_IS_ISA);
+	err = -ENOMEM;
+	shost = scsi_host_alloc(&advansys_template, sizeof(*board));
 	if (!shost)
-		goto nodev;
+		goto release_region;
+
+	board = ASC_BOARDP(shost);
+	board->irq = advansys_isa_irq_no(iop_base);
+	board->dev = dev;
+
+	err = advansys_board_found(shost, iop_base, ASC_IS_ISA);
+	if (err)
+		goto free_host;
 
 	dev_set_drvdata(dev, shost);
 	return 0;
 
- nodev:
+ free_host:
+	scsi_host_put(shost);
+ release_region:
 	release_region(iop_base, ASC_IOADR_GAP);
-	return -ENODEV;
+	return err;
 }
 
 static int __devexit advansys_isa_remove(struct device *dev, unsigned int id)
@@ -14493,10 +14391,32 @@ static struct isa_driver advansys_isa_driver = {
 	},
 };
 
+/*
+ * The VLB IRQ number is found in bits 2 to 4 of the CfgLsw.  It decodes as:
+ * 000: invalid
+ * 001: 10
+ * 010: 11
+ * 011: 12
+ * 100: invalid
+ * 101: 14
+ * 110: 15
+ * 111: invalid
+ */
+static unsigned int __devinit advansys_vlb_irq_no(PortAddr iop_base)
+{
+	unsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);
+	unsigned int chip_irq = ((cfg_lsw >> 2) & 0x07) + 9;
+	if ((chip_irq < 10) || (chip_irq == 13) || (chip_irq > 15))
+		return 0;
+	return chip_irq;
+}
+
 static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 {
+	int err = -ENODEV;
 	PortAddr iop_base = _asc_def_iop_base[id];
 	struct Scsi_Host *shost;
+	struct asc_board *board;
 
 	if (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {
 		ASC_DBG1(1, "advansys_vlb_match: I/O port 0x%x busy\n",
@@ -14505,23 +14425,34 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 	}
 	ASC_DBG1(1, "advansys_vlb_match: probing I/O port 0x%x\n", iop_base);
 	if (!AscFindSignature(iop_base))
-		goto nodev;
+		goto release_region;
 	/*
 	 * I don't think this condition can actually happen, but the old
 	 * driver did it, and the chances of finding a VLB setup in 2007
 	 * to do testing with is slight to none.
 	 */
 	if (AscGetChipVersion(iop_base, ASC_IS_VL) > ASC_CHIP_MAX_VER_VL)
-		goto nodev;
+		goto release_region;
 
-	shost = advansys_board_found(iop_base, dev, ASC_IS_VL);
+	err = -ENOMEM;
+	shost = scsi_host_alloc(&advansys_template, sizeof(*board));
 	if (!shost)
-		goto nodev;
+		goto release_region;
+
+	board = ASC_BOARDP(shost);
+	board->irq = advansys_vlb_irq_no(iop_base);
+	board->dev = dev;
+
+	err = advansys_board_found(shost, iop_base, ASC_IS_VL);
+	if (err)
+		goto free_host;
 
 	dev_set_drvdata(dev, shost);
 	return 0;
 
- nodev:
+ free_host:
+	scsi_host_put(shost);
+ release_region:
 	release_region(iop_base, ASC_IOADR_GAP);
 	return -ENODEV;
 }
@@ -14551,9 +14482,29 @@ struct eisa_scsi_data {
 	struct Scsi_Host *host[2];
 };
 
+/*
+ * The EISA IRQ number is found in bits 8 to 10 of the CfgLsw.  It decodes as:
+ * 000: 10
+ * 001: 11
+ * 010: 12
+ * 011: invalid
+ * 100: 14
+ * 101: 15
+ * 110: invalid
+ * 111: invalid
+ */
+static unsigned int __devinit advansys_eisa_irq_no(struct eisa_device *edev)
+{
+	unsigned short cfg_lsw = inw(edev->base_addr + 0xc86);
+	unsigned int chip_irq = ((cfg_lsw >> 8) & 0x07) + 10;
+	if ((chip_irq == 13) || (chip_irq > 15))
+		return 0;
+	return chip_irq;
+}
+
 static int __devinit advansys_eisa_probe(struct device *dev)
 {
-	int i, ioport;
+	int i, ioport, irq = 0;
 	int err;
 	struct eisa_device *edev = to_eisa_device(dev);
 	struct eisa_scsi_data *data;
@@ -14566,6 +14517,8 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 
 	err = -ENODEV;
 	for (i = 0; i < 2; i++, ioport += 0x20) {
+		struct asc_board *board;
+		struct Scsi_Host *shost;
 		if (!request_region(ioport, ASC_IOADR_GAP, DRV_NAME)) {
 			printk(KERN_WARNING "Region %x-%x busy\n", ioport,
 			       ioport + ASC_IOADR_GAP - 1);
@@ -14584,20 +14537,40 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 		 * test with.
 		 */
 		inw(ioport + 4);
-		data->host[i] = advansys_board_found(ioport, dev, ASC_IS_EISA);
-		if (data->host[i]) {
-			err = 0;
-		} else {
-			release_region(ioport, ASC_IOADR_GAP);
+
+		if (!irq)
+			irq = advansys_eisa_irq_no(edev);
+
+		err = -ENOMEM;
+		shost = scsi_host_alloc(&advansys_template, sizeof(*board));
+		if (!shost)
+			goto release_region;
+
+		board = ASC_BOARDP(shost);
+		board->irq = irq;
+		board->dev = dev;
+
+		err = advansys_board_found(shost, ioport, ASC_IS_EISA);
+		if (!err) {
+			data->host[i] = shost;
+			continue;
 		}
-	}
 
-	if (err) {
-		kfree(data);
-	} else {
-		dev_set_drvdata(dev, data);
+		scsi_host_put(shost);
+ release_region:
+		release_region(ioport, ASC_IOADR_GAP);
+		break;
 	}
 
+	if (err)
+		goto free_data;
+	dev_set_drvdata(dev, data);
+	return 0;
+
+ free_data:
+	kfree(data->host[0]);
+	kfree(data->host[1]);
+	kfree(data);
  fail:
 	return err;
 }
@@ -14667,6 +14640,7 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	int err, ioport;
 	struct Scsi_Host *shost;
+	struct asc_board *board;
 
 	err = pci_enable_device(pdev);
 	if (err)
@@ -14677,20 +14651,37 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	pci_set_master(pdev);
 	advansys_set_latency(pdev);
 
+	err = -ENODEV;
 	if (pci_resource_len(pdev, 0) == 0)
-		goto nodev;
+		goto release_region;
 
 	ioport = pci_resource_start(pdev, 0);
-	shost = advansys_board_found(ioport, &pdev->dev, ASC_IS_PCI);
 
+	err = -ENOMEM;
+	shost = scsi_host_alloc(&advansys_template, sizeof(*board));
 	if (!shost)
-		goto nodev;
+		goto release_region;
+
+	board = ASC_BOARDP(shost);
+	board->irq = pdev->irq;
+	board->dev = &pdev->dev;
+
+	if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||
+	    pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||
+	    pdev->device == PCI_DEVICE_ID_38C1600_REV1) {
+		board->flags |= ASC_IS_WIDE_BOARD;
+	}
+
+	err = advansys_board_found(shost, ioport, ASC_IS_PCI);
+	if (err)
+		goto free_host;
 
 	pci_set_drvdata(pdev, shost);
 	return 0;
 
- nodev:
-	err = -ENODEV;
+ free_host:
+	scsi_host_put(shost);
+ release_region:
 	pci_release_regions(pdev);
  disable_device:
 	pci_disable_device(pdev);

commit 9a256fa50e9a9d6bd03e0d6e8eddce9dca4f15f2
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:28 2007 -0400

    [SCSI] advansys: Remove ASC_WIDE_BOARD predicate
    
    Replace it with !ASC_NARROW_BOARD
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 5e6bcf2e5d15..a5bb4e416bea 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2232,7 +2232,6 @@ do { \
 #define ASC_IS_WIDE_BOARD       0x04	/* AdvanSys Wide Board */
 
 #define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)
-#define ASC_WIDE_BOARD(boardp)   ((boardp)->flags & ASC_IS_WIDE_BOARD)
 
 #define NO_ISA_DMA              0xff	/* No ISA DMA Channel Used */
 
@@ -4385,7 +4384,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	/*
 	 * Display Wide Board BIOS Information.
 	 */
-	if (ASC_WIDE_BOARD(boardp)) {
+	if (!ASC_NARROW_BOARD(boardp)) {
 		cp = boardp->prtbuf;
 		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
 		BUG_ON(cplen >= ASC_PRTBUF_SIZE);
@@ -14432,7 +14431,7 @@ static int advansys_release(struct Scsi_Host *shost)
 		ASC_DBG(1, "advansys_release: free_dma()\n");
 		free_dma(shost->dma_channel);
 	}
-	if (ASC_WIDE_BOARD(boardp)) {
+	if (!ASC_NARROW_BOARD(boardp)) {
 		iounmap(boardp->ioremap_addr);
 		advansys_wide_free_mem(boardp);
 	}

commit ae002fec6906622aa96d01f8065ef90023660a68
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:27 2007 -0400

    [SCSI] advansys: Remove ASC_SELECT_QUEUE_DEPTHS
    
    It was only ever set; never tested, nor cleared.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 52ea41d175af..5e6bcf2e5d15 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2230,7 +2230,6 @@ do { \
 
 /* asc_board_t flags */
 #define ASC_IS_WIDE_BOARD       0x04	/* AdvanSys Wide Board */
-#define ASC_SELECT_QUEUE_DEPTHS 0x08
 
 #define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)
 #define ASC_WIDE_BOARD(boardp)   ((boardp)->flags & ASC_IS_WIDE_BOARD)
@@ -10135,7 +10134,6 @@ advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
 static int advansys_slave_configure(struct scsi_device *sdev)
 {
 	asc_board_t *boardp = ASC_BOARDP(sdev->host);
-	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
 
 	if (ASC_NARROW_BOARD(boardp))
 		advansys_narrow_slave_configure(sdev,

commit 52fa07770921d9cbe815d3aff36702c88cdec978
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:26 2007 -0400

    [SCSI] advansys: Improve reset handler
    
     - Don't need to set ASC_HOST_IN_RESET any more
     - Don't need to test scp->device->host for NULL -- if it's NULL, we
       couldn't've been called.
     - Use scmd_printk instead of ASC_PRINT
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index fd4d6695fea9..52ea41d175af 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2229,7 +2229,6 @@ do { \
 #define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
 
 /* asc_board_t flags */
-#define ASC_HOST_IN_RESET       0x01
 #define ASC_IS_WIDE_BOARD       0x04	/* AdvanSys Wide Board */
 #define ASC_SELECT_QUEUE_DEPTHS 0x08
 
@@ -9751,106 +9750,68 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
  */
 static int advansys_reset(struct scsi_cmnd *scp)
 {
-	struct Scsi_Host *shost;
-	asc_board_t *boardp;
-	ASC_DVC_VAR *asc_dvc_varp;
-	ADV_DVC_VAR *adv_dvc_varp;
-	ulong flags;
+	struct Scsi_Host *shost = scp->device->host;
+	struct asc_board *boardp = ASC_BOARDP(shost);
+	unsigned long flags;
 	int status;
 	int ret = SUCCESS;
 
-	ASC_DBG1(1, "advansys_reset: 0x%lx\n", (ulong)scp);
+	ASC_DBG1(1, "advansys_reset: 0x%p\n", scp);
 
-#ifdef ADVANSYS_STATS
-	if (scp->device->host != NULL) {
-		ASC_STATS(scp->device->host, reset);
-	}
-#endif /* ADVANSYS_STATS */
-
-	if ((shost = scp->device->host) == NULL) {
-		scp->result = HOST_BYTE(DID_ERROR);
-		return FAILED;
-	}
+	ASC_STATS(shost, reset);
 
-	boardp = ASC_BOARDP(shost);
-
-	ASC_PRINT1("advansys_reset: board %d: SCSI bus reset started...\n",
-		   boardp->id);
-	/*
-	 * Check for re-entrancy.
-	 */
-	spin_lock_irqsave(&boardp->lock, flags);
-	if (boardp->flags & ASC_HOST_IN_RESET) {
-		spin_unlock_irqrestore(&boardp->lock, flags);
-		return FAILED;
-	}
-	boardp->flags |= ASC_HOST_IN_RESET;
-	spin_unlock_irqrestore(&boardp->lock, flags);
+	scmd_printk(KERN_INFO, scp, "SCSI bus reset started...\n");
 
 	if (ASC_NARROW_BOARD(boardp)) {
-		/*
-		 * Narrow Board
-		 */
-		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 
-		/*
-		 * Reset the chip and SCSI bus.
-		 */
+		/* Reset the chip and SCSI bus. */
 		ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
-		status = AscInitAsc1000Driver(asc_dvc_varp);
+		status = AscInitAsc1000Driver(asc_dvc);
 
 		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
-		if (asc_dvc_varp->err_code) {
-			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
-				   "error: 0x%x\n", boardp->id,
-				   asc_dvc_varp->err_code);
+		if (asc_dvc->err_code) {
+			scmd_printk(KERN_INFO, scp, "SCSI bus reset error: "
+				    "0x%x\n", asc_dvc->err_code);
 			ret = FAILED;
 		} else if (status) {
-			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
-				   "warning: 0x%x\n", boardp->id, status);
+			scmd_printk(KERN_INFO, scp, "SCSI bus reset warning: "
+				    "0x%x\n", status);
 		} else {
-			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
-				   "successful.\n", boardp->id);
+			scmd_printk(KERN_INFO, scp, "SCSI bus reset "
+				    "successful\n");
 		}
 
 		ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
 		spin_lock_irqsave(&boardp->lock, flags);
-
 	} else {
 		/*
-		 * Wide Board
-		 *
 		 * If the suggest reset bus flags are set, then reset the bus.
 		 * Otherwise only reset the device.
 		 */
-		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+		ADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;
 
 		/*
 		 * Reset the target's SCSI bus.
 		 */
 		ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
-		switch (AdvResetChipAndSB(adv_dvc_varp)) {
+		switch (AdvResetChipAndSB(adv_dvc)) {
 		case ASC_TRUE:
-			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
-				   "successful.\n", boardp->id);
+			scmd_printk(KERN_INFO, scp, "SCSI bus reset "
+				    "successful\n");
 			break;
 		case ASC_FALSE:
 		default:
-			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
-				   "error.\n", boardp->id);
+			scmd_printk(KERN_INFO, scp, "SCSI bus reset error\n");
 			ret = FAILED;
 			break;
 		}
 		spin_lock_irqsave(&boardp->lock, flags);
-		AdvISR(adv_dvc_varp);
+		AdvISR(adv_dvc);
 	}
-	/* Board lock is held. */
 
 	/* Save the time of the most recently completed reset. */
 	boardp->last_reset = jiffies;
-
-	/* Clear reset flag. */
-	boardp->flags &= ~ASC_HOST_IN_RESET;
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
 	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);

commit 05848b6e66ee237c4496c2b49821d2622b0f677e
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:25 2007 -0400

    [SCSI] advansys: Fix simultaneous calls to ->queuecommand
    
    The narrow board used two global structures to set up a command;
    unfortunately they weren't locked, so with two boards in the machine,
    one call to queuecommand could corrupt the data being used by the other
    call to queuecommand.
    
    Fix this by allocating asc_scsi_q on the stack (64 bytes) and using kmalloc
    for the asc_sg_head (2k)
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 3dd785617602..fd4d6695fea9 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -380,7 +380,7 @@ typedef struct asc_sg_head {
 	ushort queue_cnt;
 	ushort entry_to_copy;
 	ushort res;
-	ASC_SG_LIST sg_list[ASC_MAX_SG_LIST];
+	ASC_SG_LIST sg_list[0];
 } ASC_SG_HEAD;
 
 typedef struct asc_scsi_q {
@@ -2559,12 +2559,6 @@ static int asc_board_count;
 /* Overrun buffer used by all narrow boards. */
 static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 
-/*
- * Global structures required to issue a command.
- */
-static ASC_SCSI_Q asc_scsi_q = { {0} };
-static ASC_SG_HEAD asc_sg_head = { 0 };
-
 #ifdef ADVANSYS_DEBUG
 static int asc_dbglvl = 3;
 
@@ -10192,39 +10186,28 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
-/*
- * Build a request structure for the Asc Library (Narrow Board).
- *
- * The global structures 'asc_scsi_q' and 'asc_sg_head' are
- * used to build the request.
- *
- * If an error occurs, then return ASC_ERROR.
- */
-static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
+static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
+			struct asc_scsi_q *asc_scsi_q)
 {
-	/*
-	 * Mutually exclusive access is required to 'asc_scsi_q' and
-	 * 'asc_sg_head' until after the request is started.
-	 */
-	memset(&asc_scsi_q, 0, sizeof(ASC_SCSI_Q));
+	memset(asc_scsi_q, 0, sizeof(*asc_scsi_q));
 
 	/*
 	 * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
 	 */
-	asc_scsi_q.q2.srb_ptr = ASC_VADDR_TO_U32(scp);
+	asc_scsi_q->q2.srb_ptr = ASC_VADDR_TO_U32(scp);
 
 	/*
 	 * Build the ASC_SCSI_Q request.
 	 */
-	asc_scsi_q.cdbptr = &scp->cmnd[0];
-	asc_scsi_q.q2.cdb_len = scp->cmd_len;
-	asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
-	asc_scsi_q.q1.target_lun = scp->device->lun;
-	asc_scsi_q.q2.target_ix =
+	asc_scsi_q->cdbptr = &scp->cmnd[0];
+	asc_scsi_q->q2.cdb_len = scp->cmd_len;
+	asc_scsi_q->q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
+	asc_scsi_q->q1.target_lun = scp->device->lun;
+	asc_scsi_q->q2.target_ix =
 	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
-	asc_scsi_q.q1.sense_addr =
+	asc_scsi_q->q1.sense_addr =
 	    cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-	asc_scsi_q.q1.sense_len = sizeof(scp->sense_buffer);
+	asc_scsi_q->q1.sense_len = sizeof(scp->sense_buffer);
 
 	/*
 	 * If there are any outstanding requests for the current target,
@@ -10239,9 +10222,9 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 	 */
 	if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
 	    (boardp->reqcnt[scp->device->id] % 255) == 0) {
-		asc_scsi_q.q2.tag_code = MSG_ORDERED_TAG;
+		asc_scsi_q->q2.tag_code = MSG_ORDERED_TAG;
 	} else {
-		asc_scsi_q.q2.tag_code = MSG_SIMPLE_TAG;
+		asc_scsi_q->q2.tag_code = MSG_SIMPLE_TAG;
 	}
 
 	/*
@@ -10257,12 +10240,12 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 		    dma_map_single(boardp->dev, scp->request_buffer,
 				   scp->request_bufflen,
 				   scp->sc_data_direction) : 0;
-		asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
-		asc_scsi_q.q1.data_cnt = cpu_to_le32(scp->request_bufflen);
+		asc_scsi_q->q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
+		asc_scsi_q->q1.data_cnt = cpu_to_le32(scp->request_bufflen);
 		ASC_STATS_ADD(scp->device->host, cont_xfer,
 			      ASC_CEILING(scp->request_bufflen, 512));
-		asc_scsi_q.q1.sg_queue_cnt = 0;
-		asc_scsi_q.sg_head = NULL;
+		asc_scsi_q->q1.sg_queue_cnt = 0;
+		asc_scsi_q->sg_head = NULL;
 	} else {
 		/*
 		 * CDB scatter-gather request list.
@@ -10270,6 +10253,7 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 		int sgcnt;
 		int use_sg;
 		struct scatterlist *slp;
+		struct asc_sg_head *asc_sg_head;
 
 		slp = (struct scatterlist *)scp->request_buffer;
 		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
@@ -10287,28 +10271,31 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 
 		ASC_STATS(scp->device->host, sg_cnt);
 
-		/*
-		 * Use global ASC_SG_HEAD structure and set the ASC_SCSI_Q
-		 * structure to point to it.
-		 */
-		memset(&asc_sg_head, 0, sizeof(ASC_SG_HEAD));
+		asc_sg_head = kzalloc(sizeof(asc_scsi_q->sg_head) +
+			use_sg * sizeof(struct asc_sg_list), GFP_ATOMIC);
+		if (!asc_sg_head) {
+			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
+				     scp->sc_data_direction);
+			scp->result = HOST_BYTE(DID_SOFT_ERROR);
+			return ASC_ERROR;
+		}
 
-		asc_scsi_q.q1.cntl |= QC_SG_HEAD;
-		asc_scsi_q.sg_head = &asc_sg_head;
-		asc_scsi_q.q1.data_cnt = 0;
-		asc_scsi_q.q1.data_addr = 0;
+		asc_scsi_q->q1.cntl |= QC_SG_HEAD;
+		asc_scsi_q->sg_head = asc_sg_head;
+		asc_scsi_q->q1.data_cnt = 0;
+		asc_scsi_q->q1.data_addr = 0;
 		/* This is a byte value, otherwise it would need to be swapped. */
-		asc_sg_head.entry_cnt = asc_scsi_q.q1.sg_queue_cnt = use_sg;
+		asc_sg_head->entry_cnt = asc_scsi_q->q1.sg_queue_cnt = use_sg;
 		ASC_STATS_ADD(scp->device->host, sg_elem,
-			      asc_sg_head.entry_cnt);
+			      asc_sg_head->entry_cnt);
 
 		/*
 		 * Convert scatter-gather list into ASC_SG_HEAD list.
 		 */
 		for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
-			asc_sg_head.sg_list[sgcnt].addr =
+			asc_sg_head->sg_list[sgcnt].addr =
 			    cpu_to_le32(sg_dma_address(slp));
-			asc_sg_head.sg_list[sgcnt].bytes =
+			asc_sg_head->sg_list[sgcnt].bytes =
 			    cpu_to_le32(sg_dma_len(slp));
 			ASC_STATS_ADD(scp->device->host, sg_xfer,
 				      ASC_CEILING(sg_dma_len(slp), 512));
@@ -11338,14 +11325,17 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
+		struct asc_scsi_q asc_scsi_q;
 
 		/* asc_build_req() can not return ASC_BUSY. */
-		if (asc_build_req(boardp, scp) == ASC_ERROR) {
+		ret = asc_build_req(boardp, scp, &asc_scsi_q);
+		if (ret == ASC_ERROR) {
 			ASC_STATS(scp->device->host, build_error);
 			return ASC_ERROR;
 		}
 
 		ret = AscExeScsiQueue(asc_dvc, &asc_scsi_q);
+		kfree(asc_scsi_q.sg_head);
 		err_code = asc_dvc->err_code;
 	} else {
 		ADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;

commit 41d2493d3478942f891b21dff60951ff939c08d9
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:24 2007 -0400

    [SCSI] advansys: Restructure asc_execute_scsi_cmnd()
    
    The wide and narrow boards share identical handling of the return value,
    except for some trivial error messages.  Move the handling to the common
    end of the function.  Also move variable declarations to the arms of
    the `if' that they're used in and delete some pointless comments.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 737c0e4b3190..3dd785617602 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -11331,80 +11331,26 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
  */
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 {
-	asc_board_t *boardp;
-	ASC_DVC_VAR *asc_dvc_varp;
-	ADV_DVC_VAR *adv_dvc_varp;
-	ADV_SCSI_REQ_Q *adv_scsiqp;
-	int ret;
+	int ret, err_code;
+	asc_board_t *boardp = ASC_BOARDP(scp->device->host);
 
-	ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
-		 (ulong)scp, (ulong)scp->scsi_done);
-
-	boardp = ASC_BOARDP(scp->device->host);
+	ASC_DBG1(1, "asc_execute_scsi_cmnd: scp 0x%p\n", scp);
 
 	if (ASC_NARROW_BOARD(boardp)) {
-		/*
-		 * Build and execute Narrow Board request.
-		 */
-
-		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+		ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 
-		/*
-		 * Build Asc Library request structure using the
-		 * global structures 'asc_scsi_req' and 'asc_sg_head'.
-		 *
-		 * If an error is returned, then the request has been
-		 * queued on the board done queue. It will be completed
-		 * by the caller.
-		 *
-		 * asc_build_req() can not return ASC_BUSY.
-		 */
+		/* asc_build_req() can not return ASC_BUSY. */
 		if (asc_build_req(boardp, scp) == ASC_ERROR) {
 			ASC_STATS(scp->device->host, build_error);
 			return ASC_ERROR;
 		}
 
-		switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
-		case ASC_NOERROR:
-			ASC_STATS(scp->device->host, exe_noerror);
-			/*
-			 * Increment monotonically increasing per device
-			 * successful request counter. Wrapping doesn't matter.
-			 */
-			boardp->reqcnt[scp->device->id]++;
-			ASC_DBG(1, "asc_execute_scsi_cmnd: AscExeScsiQueue(), "
-				"ASC_NOERROR\n");
-			break;
-		case ASC_BUSY:
-			ASC_STATS(scp->device->host, exe_busy);
-			break;
-		case ASC_ERROR:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-				boardp->id, asc_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_error);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		default:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AscExeScsiQueue() unknown, err_code 0x%x\n",
-				boardp->id, asc_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_unknown);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		}
+		ret = AscExeScsiQueue(asc_dvc, &asc_scsi_q);
+		err_code = asc_dvc->err_code;
 	} else {
-		/*
-		 * Build and execute Wide Board request.
-		 */
-		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+		ADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;
+		ADV_SCSI_REQ_Q *adv_scsiqp;
 
-		/*
-		 * Build and get a pointer to an Adv Library request structure.
-		 *
-		 * If the request is successfully built then send it below,
-		 * otherwise return with an error.
-		 */
 		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
 		case ASC_NOERROR:
 			ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req "
@@ -11428,35 +11374,36 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			return ASC_ERROR;
 		}
 
-		switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
-		case ASC_NOERROR:
-			ASC_STATS(scp->device->host, exe_noerror);
-			/*
-			 * Increment monotonically increasing per device
-			 * successful request counter. Wrapping doesn't matter.
-			 */
-			boardp->reqcnt[scp->device->id]++;
-			ASC_DBG(1, "asc_execute_scsi_cmnd: AdvExeScsiQueue(), "
-				"ASC_NOERROR\n");
-			break;
-		case ASC_BUSY:
-			ASC_STATS(scp->device->host, exe_busy);
-			break;
-		case ASC_ERROR:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-				boardp->id, adv_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_error);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		default:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AdvExeScsiQueue() unknown, err_code 0x%x\n",
-				boardp->id, adv_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_unknown);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		}
+		ret = AdvExeScsiQueue(adv_dvc, adv_scsiqp);
+		err_code = adv_dvc->err_code;
+	}
+
+	switch (ret) {
+	case ASC_NOERROR:
+		ASC_STATS(scp->device->host, exe_noerror);
+		/*
+		 * Increment monotonically increasing per device
+		 * successful request counter. Wrapping doesn't matter.
+		 */
+		boardp->reqcnt[scp->device->id]++;
+		ASC_DBG(1, "asc_execute_scsi_cmnd: ExeScsiQueue(), "
+			"ASC_NOERROR\n");
+		break;
+	case ASC_BUSY:
+		ASC_STATS(scp->device->host, exe_busy);
+		break;
+	case ASC_ERROR:
+		ASC_PRINT2("asc_execute_scsi_cmnd: board %d: ExeScsiQueue() "
+			   "ASC_ERROR, err_code 0x%x\n", boardp->id, err_code);
+		ASC_STATS(scp->device->host, exe_error);
+		scp->result = HOST_BYTE(DID_ERROR);
+		break;
+	default:
+		ASC_PRINT2("asc_execute_scsi_cmnd: board %d: ExeScsiQueue() "
+			   "unknown, err_code 0x%x\n", boardp->id, err_code);
+		ASC_STATS(scp->device->host, exe_unknown);
+		scp->result = HOST_BYTE(DID_ERROR);
+		break;
 	}
 
 	ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");

commit 6e8905f4a028bd07190fa5b2f90b5a35868c84d8
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:23 2007 -0400

    [SCSI] advansys: Remove array of scsi targets
    
    The driver was saving a scsi_device for each target, but wasn't doing
    anything useful with them.  Just delete the array.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 4f047cc87c66..737c0e4b3190 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2514,7 +2514,6 @@ typedef struct asc_board {
 	} dvc_cfg;
 	ushort asc_n_io_port;	/* Number I/O ports. */
 	ADV_SCSI_BIT_ID_TYPE init_tidmask;	/* Target init./valid mask */
-	struct scsi_device *device[ADV_MAX_TID + 1];	/* Mid-Level Scsi Device */
 	ushort reqcnt[ADV_MAX_TID + 1];	/* Starvation request count */
 	ADV_SCSI_BIT_ID_TYPE queue_full;	/* Queue full mask */
 	ushort queue_full_cnt[ADV_MAX_TID + 1];	/* Queue full count */
@@ -10183,13 +10182,6 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 	asc_board_t *boardp = ASC_BOARDP(sdev->host);
 	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
 
-	/*
-	 * Save a pointer to the sdev and set its initial/maximum
-	 * queue depth.  Only save the pointer for a lun0 dev though.
-	 */
-	if (sdev->lun == 0)
-		boardp->device[sdev->id] = sdev;
-
 	if (ASC_NARROW_BOARD(boardp))
 		advansys_narrow_slave_configure(sdev,
 						&boardp->dvc_var.asc_dvc_var);
@@ -11343,14 +11335,12 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 	ASC_DVC_VAR *asc_dvc_varp;
 	ADV_DVC_VAR *adv_dvc_varp;
 	ADV_SCSI_REQ_Q *adv_scsiqp;
-	struct scsi_device *device;
 	int ret;
 
 	ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
 		 (ulong)scp, (ulong)scp->scsi_done);
 
 	boardp = ASC_BOARDP(scp->device->host);
-	device = boardp->device[scp->device->id];
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		/*

commit 512193588db0d38ae6aa78802bb15f3ef3104a00
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 2 21:55:22 2007 -0400

    [SCSI] advansys: Eliminate prototypes
    
    Rearrange a lot of the functions in the file to get rid of all the forward
    declarations.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0303fc7dacd3..4f047cc87c66 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -878,7 +878,6 @@ typedef struct asceep_config {
 #define ASC_1000_ID0W_FIX  0x00C1
 #define ASC_1000_ID1B      0x25
 #define ASC_EISA_REV_IOP_MASK  (0x0C83)
-#define ASC_EISA_PID_IOP_MASK  (0x0C80)
 #define ASC_EISA_CFG_IOP_MASK  (0x0C86)
 #define ASC_GET_EISA_SLOT(iop)  (PortAddr)((iop) & 0xF000)
 #define INS_HALTINT        (ushort)0x6281
@@ -903,10 +902,10 @@ typedef struct asc_mc_saved {
 #define AscGetRiscVarDoneQTail(port)        AscReadLramByte((port), ASCV_DONENEXT_B)
 #define AscPutRiscVarFreeQHead(port, val)   AscWriteLramByte((port), ASCV_NEXTRDY_B, val)
 #define AscPutRiscVarDoneQTail(port, val)   AscWriteLramByte((port), ASCV_DONENEXT_B, val)
-#define AscPutMCodeSDTRDoneAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id), (data));
-#define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id));
-#define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data);
-#define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id));
+#define AscPutMCodeSDTRDoneAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id), (data))
+#define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id))
+#define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data)
+#define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id))
 #define AscSynIndexToPeriod(index)        (uchar)(asc_dvc->sdtr_period_tbl[ (index) ])
 #define AscGetChipSignatureByte(port)     (uchar)inp((port)+IOP_SIG_BYTE)
 #define AscGetChipSignatureWord(port)     (ushort)inpw((port)+IOP_SIG_WORD)
@@ -962,83 +961,6 @@ typedef struct asc_mc_saved {
 #define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)
 #define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)
 
-static int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg);
-static int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg);
-static void AscWaitEEPRead(void);
-static void AscWaitEEPWrite(void);
-static ushort AscReadEEPWord(PortAddr, uchar);
-static ushort AscWriteEEPWord(PortAddr, uchar, ushort);
-static ushort AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
-static int AscSetEEPConfigOnce(PortAddr, ASCEEP_CONFIG *, ushort);
-static int AscSetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
-static int AscStartChip(PortAddr);
-static int AscStopChip(PortAddr);
-static void AscSetChipIH(PortAddr, ushort);
-static int AscIsChipHalted(PortAddr);
-static void AscAckInterrupt(PortAddr);
-static void AscDisableInterrupt(PortAddr);
-static void AscEnableInterrupt(PortAddr);
-static void AscSetBank(PortAddr, uchar);
-static int AscResetChipAndScsiBus(ASC_DVC_VAR *);
-#ifdef CONFIG_ISA
-static uchar AscGetIsaDmaSpeed(PortAddr);
-#endif /* CONFIG_ISA */
-static uchar AscReadLramByte(PortAddr, ushort);
-static ushort AscReadLramWord(PortAddr, ushort);
-#if CC_VERY_LONG_SG_LIST
-static ASC_DCNT AscReadLramDWord(PortAddr, ushort);
-#endif /* CC_VERY_LONG_SG_LIST */
-static void AscWriteLramWord(PortAddr, ushort, ushort);
-static void AscWriteLramByte(PortAddr, ushort, uchar);
-static ASC_DCNT AscMemSumLramWord(PortAddr, ushort, int);
-static void AscMemWordSetLram(PortAddr, ushort, ushort, int);
-static void AscMemWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
-static void AscMemDWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
-static void AscMemWordCopyPtrFromLram(PortAddr, ushort, uchar *, int);
-static ushort AscInitAscDvcVar(ASC_DVC_VAR *);
-static ushort AscInitFromEEP(ASC_DVC_VAR *);
-static ushort AscInitMicroCodeVar(ASC_DVC_VAR *);
-static int AscTestExternalLram(ASC_DVC_VAR *);
-static uchar AscMsgOutSDTR(ASC_DVC_VAR *, uchar, uchar);
-static uchar AscCalSDTRData(ASC_DVC_VAR *, uchar, uchar);
-static void AscSetChipSDTR(PortAddr, uchar, uchar);
-static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *, uchar);
-static uchar AscAllocFreeQueue(PortAddr, uchar);
-static uchar AscAllocMultipleFreeQueue(PortAddr, uchar, uchar);
-static int AscHostReqRiscHalt(PortAddr);
-static int AscStopQueueExe(PortAddr);
-static int AscSendScsiQueue(ASC_DVC_VAR *,
-			    ASC_SCSI_Q *scsiq, uchar n_q_required);
-static int AscPutReadyQueue(ASC_DVC_VAR *, ASC_SCSI_Q *, uchar);
-static int AscPutReadySgListQueue(ASC_DVC_VAR *, ASC_SCSI_Q *, uchar);
-static int AscSetChipSynRegAtID(PortAddr, uchar, uchar);
-static int AscSetRunChipSynRegAtID(PortAddr, uchar, uchar);
-static ushort AscInitLram(ASC_DVC_VAR *);
-static int AscSetLibErrorCode(ASC_DVC_VAR *, ushort);
-static int AscIsrChipHalted(ASC_DVC_VAR *);
-static uchar _AscCopyLramScsiDoneQ(PortAddr, ushort,
-				   ASC_QDONE_INFO *, ASC_DCNT);
-static int AscIsrQDone(ASC_DVC_VAR *);
-#ifdef CONFIG_ISA
-static ushort AscGetEisaChipCfg(PortAddr);
-#endif /* CONFIG_ISA */
-static uchar AscGetChipScsiCtrl(PortAddr);
-static uchar AscGetChipVersion(PortAddr, ushort);
-static ASC_DCNT AscLoadMicroCode(PortAddr, ushort, uchar *, ushort);
-static void AscToggleIRQAct(PortAddr);
-static void DvcPutScsiQ(PortAddr, ushort, uchar *, int);
-static void DvcGetQinfo(PortAddr, ushort, uchar *, int);
-static ushort AscInitAsc1000Driver(ASC_DVC_VAR *);
-static void AscAsyncFix(ASC_DVC_VAR *, struct scsi_device *);
-static int AscExeScsiQueue(ASC_DVC_VAR *, ASC_SCSI_Q *);
-static int AscISR(ASC_DVC_VAR *);
-static uint AscGetNumOfFreeQueue(ASC_DVC_VAR *, uchar, uchar);
-static int AscSgListToQueue(int);
-#ifdef CONFIG_ISA
-static void AscEnableIsaDma(uchar);
-#endif /* CONFIG_ISA */
-static const char *advansys_info(struct Scsi_Host *shost);
-
 #define ADV_LIB_VERSION_MAJOR  5
 #define ADV_LIB_VERSION_MINOR  14
 
@@ -2109,36 +2031,6 @@ typedef struct adv_scsi_req_q {
 
 #define ADV_HOST_SCSI_BUS_RESET      0x80	/* Host Initiated SCSI Bus Reset. */
 
-static ADV_PADDR DvcGetPhyAddr(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *,
-			       uchar *, ASC_SDCNT *, int);
-
-/*
- * Adv Library functions available to drivers.
- */
-static int AdvExeScsiQueue(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
-static int AdvISR(ADV_DVC_VAR *);
-static int AdvInitAsc3550Driver(ADV_DVC_VAR *);
-static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *);
-static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *);
-static int AdvResetChipAndSB(ADV_DVC_VAR *);
-static int AdvResetSB(ADV_DVC_VAR *asc_dvc);
-
-/*
- * Internal Adv Library functions.
- */
-static int AdvSendIdleCmd(ADV_DVC_VAR *, ushort, ADV_DCNT);
-static int AdvInitFrom3550EEP(ADV_DVC_VAR *);
-static int AdvInitFrom38C0800EEP(ADV_DVC_VAR *);
-static int AdvInitFrom38C1600EEP(ADV_DVC_VAR *);
-static ushort AdvGet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
-static void AdvSet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
-static ushort AdvGet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
-static void AdvSet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
-static ushort AdvGet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
-static void AdvSet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
-static void AdvWaitEEPCmd(AdvPortAddr);
-static ushort AdvReadEEPWord(AdvPortAddr, int);
-
 /* Read byte from a register. */
 #define AdvReadByteRegister(iop_base, reg_off) \
      (ADV_MEM_READB((iop_base) + (reg_off)))
@@ -2676,1721 +2568,1373 @@ static ASC_SG_HEAD asc_sg_head = { 0 };
 
 #ifdef ADVANSYS_DEBUG
 static int asc_dbglvl = 3;
-#endif /* ADVANSYS_DEBUG */
-
-static int advansys_slave_configure(struct scsi_device *);
-static int asc_execute_scsi_cmnd(struct scsi_cmnd *);
-static int asc_build_req(asc_board_t *, struct scsi_cmnd *);
-static int adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
-static int adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
-#ifdef CONFIG_PROC_FS
-static int asc_proc_copy(off_t, off_t, char *, int, char *, int);
-static int asc_prt_board_devices(struct Scsi_Host *, char *, int);
-static int asc_prt_adv_bios(struct Scsi_Host *, char *, int);
-static int asc_get_eeprom_string(ushort *serialnum, uchar *cp);
-static int asc_prt_asc_board_eeprom(struct Scsi_Host *, char *, int);
-static int asc_prt_adv_board_eeprom(struct Scsi_Host *, char *, int);
-static int asc_prt_driver_conf(struct Scsi_Host *, char *, int);
-static int asc_prt_asc_board_info(struct Scsi_Host *, char *, int);
-static int asc_prt_adv_board_info(struct Scsi_Host *, char *, int);
-static int asc_prt_line(char *, int, char *fmt, ...);
-#endif /* CONFIG_PROC_FS */
-
-/* Statistics function prototypes. */
-#ifdef ADVANSYS_STATS
-#ifdef CONFIG_PROC_FS
-static int asc_prt_board_stats(struct Scsi_Host *, char *, int);
-#endif /* CONFIG_PROC_FS */
-#endif /* ADVANSYS_STATS */
-
-/* Debug function prototypes. */
-#ifdef ADVANSYS_DEBUG
-static void asc_prt_scsi_host(struct Scsi_Host *);
-static void asc_prt_scsi_cmnd(struct scsi_cmnd *);
-static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *);
-static void asc_prt_asc_dvc_var(ASC_DVC_VAR *);
-static void asc_prt_asc_scsi_q(ASC_SCSI_Q *);
-static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *);
-static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *);
-static void asc_prt_adv_dvc_var(ADV_DVC_VAR *);
-static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *);
-static void asc_prt_adv_sgblock(int, ADV_SG_BLOCK *);
-static void asc_prt_hex(char *f, uchar *, int);
-#endif /* ADVANSYS_DEBUG */
 
-#ifdef CONFIG_PROC_FS
 /*
- * advansys_proc_info() - /proc/scsi/advansys/{0,1,2,3,...}
- *
- * *buffer: I/O buffer
- * **start: if inout == FALSE pointer into buffer where user read should start
- * offset: current offset into a /proc/scsi/advansys/[0...] file
- * length: length of buffer
- * hostno: Scsi_Host host_no
- * inout: TRUE - user is writing; FALSE - user is reading
- *
- * Return the number of bytes read from or written to a
- * /proc/scsi/advansys/[0...] file.
- *
- * Note: This function uses the per board buffer 'prtbuf' which is
- * allocated when the board is initialized in advansys_detect(). The
- * buffer is ASC_PRTBUF_SIZE bytes. The function asc_proc_copy() is
- * used to write to the buffer. The way asc_proc_copy() is written
- * if 'prtbuf' is too small it will not be overwritten. Instead the
- * user just won't get all the available statistics.
+ * asc_prt_scsi_host()
  */
-static int
-advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
-		   off_t offset, int length, int inout)
+static void asc_prt_scsi_host(struct Scsi_Host *s)
 {
 	asc_board_t *boardp;
-	char *cp;
-	int cplen;
-	int cnt;
-	int totcnt;
-	int leftlen;
-	char *curbuf;
-	off_t advoffset;
 
-	ASC_DBG(1, "advansys_proc_info: begin\n");
+	boardp = ASC_BOARDP(s);
 
-	/*
-	 * User write not supported.
-	 */
-	if (inout == TRUE) {
-		return (-ENOSYS);
-	}
+	printk("Scsi_Host at addr 0x%lx\n", (ulong)s);
+	printk(" host_busy %u, host_no %d, last_reset %d,\n",
+	       s->host_busy, s->host_no, (unsigned)s->last_reset);
 
-	/*
-	 * User read of /proc/scsi/advansys/[0...] file.
-	 */
+	printk(" base 0x%lx, io_port 0x%lx, irq 0x%x,\n",
+	       (ulong)s->base, (ulong)s->io_port, s->irq);
 
-	boardp = ASC_BOARDP(shost);
+	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
+	       s->dma_channel, s->this_id, s->can_queue);
 
-	/* Copy read data starting at the beginning of the buffer. */
-	*start = buffer;
-	curbuf = buffer;
-	advoffset = 0;
-	totcnt = 0;
-	leftlen = length;
+	printk(" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
+	       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
 
-	/*
-	 * Get board configuration information.
-	 *
-	 * advansys_info() returns the board string from its own static buffer.
-	 */
-	cp = (char *)advansys_info(shost);
-	strcat(cp, "\n");
-	cplen = strlen(cp);
-	/* Copy board information. */
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-		return totcnt;
+	if (ASC_NARROW_BOARD(boardp)) {
+		asc_prt_asc_dvc_var(&ASC_BOARDP(s)->dvc_var.asc_dvc_var);
+		asc_prt_asc_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.asc_dvc_cfg);
+	} else {
+		asc_prt_adv_dvc_var(&ASC_BOARDP(s)->dvc_var.adv_dvc_var);
+		asc_prt_adv_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.adv_dvc_cfg);
 	}
-	advoffset += cplen;
-	curbuf += cnt;
+}
 
-	/*
-	 * Display Wide Board BIOS Information.
-	 */
-	if (ASC_WIDE_BOARD(boardp)) {
-		cp = boardp->prtbuf;
-		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
-		BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
-				  cplen);
-		totcnt += cnt;
-		leftlen -= cnt;
-		if (leftlen == 0) {
-			ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-			return totcnt;
-		}
-		advoffset += cplen;
-		curbuf += cnt;
-	}
+/*
+ * asc_prt_scsi_cmnd()
+ */
+static void asc_prt_scsi_cmnd(struct scsi_cmnd *s)
+{
+	printk("struct scsi_cmnd at addr 0x%lx\n", (ulong)s);
 
-	/*
-	 * Display driver information for each device attached to the board.
-	 */
-	cp = boardp->prtbuf;
-	cplen = asc_prt_board_devices(shost, cp, ASC_PRTBUF_SIZE);
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	printk(" host 0x%lx, device 0x%lx, target %u, lun %u, channel %u,\n",
+	       (ulong)s->device->host, (ulong)s->device, s->device->id,
+	       s->device->lun, s->device->channel);
 
-	/*
-	 * Display EEPROM configuration for the board.
-	 */
-	cp = boardp->prtbuf;
-	if (ASC_NARROW_BOARD(boardp)) {
-		cplen = asc_prt_asc_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
-	} else {
-		cplen = asc_prt_adv_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
-	}
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	asc_prt_hex(" CDB", s->cmnd, s->cmd_len);
 
-	/*
-	 * Display driver configuration and information for the board.
-	 */
-	cp = boardp->prtbuf;
-	cplen = asc_prt_driver_conf(shost, cp, ASC_PRTBUF_SIZE);
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	printk("sc_data_direction %u, resid %d\n",
+	       s->sc_data_direction, s->resid);
 
-#ifdef ADVANSYS_STATS
-	/*
-	 * Display driver statistics for the board.
-	 */
-	cp = boardp->prtbuf;
-	cplen = asc_prt_board_stats(shost, cp, ASC_PRTBUF_SIZE);
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
-#endif /* ADVANSYS_STATS */
+	printk(" use_sg %u, sglist_len %u\n", s->use_sg, s->sglist_len);
 
-	/*
-	 * Display Asc Library dynamic configuration information
-	 * for the board.
-	 */
-	cp = boardp->prtbuf;
-	if (ASC_NARROW_BOARD(boardp)) {
-		cplen = asc_prt_asc_board_info(shost, cp, ASC_PRTBUF_SIZE);
-	} else {
-		cplen = asc_prt_adv_board_info(shost, cp, ASC_PRTBUF_SIZE);
-	}
-	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
-	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-	totcnt += cnt;
-	leftlen -= cnt;
-	if (leftlen == 0) {
-		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-		return totcnt;
-	}
-	advoffset += cplen;
-	curbuf += cnt;
+	printk(" serial_number 0x%x, retries %d, allowed %d\n",
+	       (unsigned)s->serial_number, s->retries, s->allowed);
 
-	ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+	printk(" timeout_per_command %d\n", s->timeout_per_command);
 
-	return totcnt;
+	printk(" scsi_done 0x%p, done 0x%p, host_scribble 0x%p, result 0x%x\n",
+		s->scsi_done, s->done, s->host_scribble, s->result);
+
+	printk(" tag %u, pid %u\n", (unsigned)s->tag, (unsigned)s->pid);
 }
-#endif /* CONFIG_PROC_FS */
 
 /*
- * advansys_info()
- *
- * Return suitable for printing on the console with the argument
- * adapter's configuration information.
- *
- * Note: The information line should not exceed ASC_INFO_SIZE bytes,
- * otherwise the static 'info' array will be overrun.
+ * asc_prt_asc_dvc_var()
  */
-static const char *advansys_info(struct Scsi_Host *shost)
+static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
 {
-	static char info[ASC_INFO_SIZE];
-	asc_board_t *boardp;
-	ASC_DVC_VAR *asc_dvc_varp;
-	ADV_DVC_VAR *adv_dvc_varp;
-	char *busname;
-	char *widename = NULL;
+	printk("ASC_DVC_VAR at addr 0x%lx\n", (ulong)h);
 
-	boardp = ASC_BOARDP(shost);
-	if (ASC_NARROW_BOARD(boardp)) {
-		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-		ASC_DBG(1, "advansys_info: begin\n");
-		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
-			if ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) ==
-			    ASC_IS_ISAPNP) {
-				busname = "ISA PnP";
-			} else {
-				busname = "ISA";
-			}
-			sprintf(info,
-				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",
-				ASC_VERSION, busname,
-				(ulong)shost->io_port,
-				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
-				shost->irq, shost->dma_channel);
-		} else {
-			if (asc_dvc_varp->bus_type & ASC_IS_VL) {
-				busname = "VL";
-			} else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {
-				busname = "EISA";
-			} else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {
-				if ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)
-				    == ASC_IS_PCI_ULTRA) {
-					busname = "PCI Ultra";
-				} else {
-					busname = "PCI";
-				}
-			} else {
-				busname = "?";
-				ASC_PRINT2("advansys_info: board %d: unknown "
-					   "bus type %d\n", boardp->id,
-					   asc_dvc_varp->bus_type);
-			}
-			sprintf(info,
-				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
-				ASC_VERSION, busname, (ulong)shost->io_port,
-				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
-				shost->irq);
-		}
-	} else {
-		/*
-		 * Wide Adapter Information
-		 *
-		 * Memory-mapped I/O is used instead of I/O space to access
-		 * the adapter, but display the I/O Port range. The Memory
-		 * I/O address is displayed through the driver /proc file.
-		 */
-		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-			widename = "Ultra-Wide";
-		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-			widename = "Ultra2-Wide";
-		} else {
-			widename = "Ultra3-Wide";
-		}
-		sprintf(info,
-			"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
-			ASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,
-			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, shost->irq);
-	}
-	BUG_ON(strlen(info) >= ASC_INFO_SIZE);
-	ASC_DBG(1, "advansys_info: end\n");
-	return info;
+	printk(" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl "
+	       "%d,\n", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
+
+	printk(" bus_type %d, init_sdtr 0x%x,\n", h->bus_type,
+		(unsigned)h->init_sdtr);
+
+	printk(" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, "
+	       "chip_no 0x%x,\n", (unsigned)h->sdtr_done,
+	       (unsigned)h->use_tagged_qng, (unsigned)h->unit_not_ready,
+	       (unsigned)h->chip_no);
+
+	printk(" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait "
+	       "%u,\n", (unsigned)h->queue_full_or_busy,
+	       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);
+
+	printk(" is_in_int %u, max_total_qng %u, cur_total_qng %u, "
+	       "in_critical_cnt %u,\n", (unsigned)h->is_in_int,
+	       (unsigned)h->max_total_qng, (unsigned)h->cur_total_qng,
+	       (unsigned)h->in_critical_cnt);
+
+	printk(" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, "
+	       "pci_fix_asyn_xfer 0x%x,\n", (unsigned)h->last_q_shortage,
+	       (unsigned)h->init_state, (unsigned)h->no_scam,
+	       (unsigned)h->pci_fix_asyn_xfer);
+
+	printk(" cfg 0x%lx, irq_no 0x%x\n", (ulong)h->cfg, (unsigned)h->irq_no);
 }
 
-static void asc_scsi_done(struct scsi_cmnd *scp)
+/*
+ * asc_prt_asc_dvc_cfg()
+ */
+static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
 {
-	struct asc_board *boardp = ASC_BOARDP(scp->device->host);
+	printk("ASC_DVC_CFG at addr 0x%lx\n", (ulong)h);
 
-	if (scp->use_sg)
-		dma_unmap_sg(boardp->dev,
-			     (struct scatterlist *)scp->request_buffer,
-			     scp->use_sg, scp->sc_data_direction);
-	else if (scp->request_bufflen)
-		dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
-				 scp->request_bufflen, scp->sc_data_direction);
+	printk(" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\n",
+	       h->can_tagged_qng, h->cmd_qng_enabled);
+	printk(" disc_enable 0x%x, sdtr_enable 0x%x,\n",
+	       h->disc_enable, h->sdtr_enable);
 
-	ASC_STATS(scp->device->host, done);
+	printk
+	    (" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, chip_version %d,\n",
+	     h->chip_scsi_id, h->isa_dma_speed, h->isa_dma_channel,
+	     h->chip_version);
 
-	scp->scsi_done(scp);
+	printk
+	    (" pci_device_id %d, lib_serial_no %u, lib_version %u, mcode_date 0x%x,\n",
+	     to_pci_dev(h->dev)->device, h->lib_serial_no, h->lib_version,
+	     h->mcode_date);
+
+	printk(" mcode_version %d, overrun_buf 0x%lx\n",
+	       h->mcode_version, (ulong)h->overrun_buf);
 }
 
 /*
- * advansys_queuecommand() - interrupt-driven I/O entrypoint.
- *
- * This function always returns 0. Command return status is saved
- * in the 'scp' result field.
+ * asc_prt_asc_scsi_q()
  */
-static int
-advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
 {
-	struct Scsi_Host *shost = scp->device->host;
-	asc_board_t *boardp = ASC_BOARDP(shost);
-	unsigned long flags;
-	int asc_res, result = 0;
+	ASC_SG_HEAD *sgp;
+	int i;
 
-	ASC_STATS(shost, queuecommand);
-	scp->scsi_done = done;
+	printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);
 
-	/*
-	 * host_lock taken by mid-level prior to call, but need
-	 * to protect against own ISR
-	 */
-	spin_lock_irqsave(&boardp->lock, flags);
-	asc_res = asc_execute_scsi_cmnd(scp);
-	spin_unlock_irqrestore(&boardp->lock, flags);
+	printk
+	    (" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
+	     q->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,
+	     q->q2.tag_code);
+
+	printk
+	    (" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+	     (ulong)le32_to_cpu(q->q1.data_addr),
+	     (ulong)le32_to_cpu(q->q1.data_cnt),
+	     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
+
+	printk(" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
+	       (ulong)q->cdbptr, q->q2.cdb_len,
+	       (ulong)q->sg_head, q->q1.sg_queue_cnt);
+
+	if (q->sg_head) {
+		sgp = q->sg_head;
+		printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong)sgp);
+		printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt,
+		       sgp->queue_cnt);
+		for (i = 0; i < sgp->entry_cnt; i++) {
+			printk(" [%u]: addr 0x%lx, bytes %lu\n",
+			       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),
+			       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));
+		}
 
-	switch (asc_res) {
-	case ASC_NOERROR:
-		break;
-	case ASC_BUSY:
-		result = SCSI_MLQUEUE_HOST_BUSY;
-		break;
-	case ASC_ERROR:
-	default:
-		asc_scsi_done(scp);
-		break;
 	}
+}
 
-	return result;
+/*
+ * asc_prt_asc_qdone_info()
+ */
+static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
+{
+	printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);
+	printk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
+	       (ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
+	       q->d2.tag_code);
+	printk
+	    (" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
+	     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
 }
 
 /*
- * advansys_reset()
- *
- * Reset the bus associated with the command 'scp'.
+ * asc_prt_adv_dvc_var()
  *
- * This function runs its own thread. Interrupts must be blocked but
- * sleeping is allowed and no locking other than for host structures is
- * required. Returns SUCCESS or FAILED.
+ * Display an ADV_DVC_VAR structure.
  */
-static int advansys_reset(struct scsi_cmnd *scp)
+static void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
 {
-	struct Scsi_Host *shost;
-	asc_board_t *boardp;
-	ASC_DVC_VAR *asc_dvc_varp;
-	ADV_DVC_VAR *adv_dvc_varp;
-	ulong flags;
-	int status;
-	int ret = SUCCESS;
+	printk(" ADV_DVC_VAR at addr 0x%lx\n", (ulong)h);
 
-	ASC_DBG1(1, "advansys_reset: 0x%lx\n", (ulong)scp);
+	printk("  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",
+	       (ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);
 
-#ifdef ADVANSYS_STATS
-	if (scp->device->host != NULL) {
-		ASC_STATS(scp->device->host, reset);
-	}
-#endif /* ADVANSYS_STATS */
+	printk("  isr_callback 0x%lx, sdtr_able 0x%x, wdtr_able 0x%x\n",
+	       (ulong)h->isr_callback, (unsigned)h->sdtr_able,
+	       (unsigned)h->wdtr_able);
 
-	if ((shost = scp->device->host) == NULL) {
-		scp->result = HOST_BYTE(DID_ERROR);
-		return FAILED;
-	}
+	printk("  start_motor 0x%x, scsi_reset_wait 0x%x, irq_no 0x%x,\n",
+	       (unsigned)h->start_motor,
+	       (unsigned)h->scsi_reset_wait, (unsigned)h->irq_no);
 
-	boardp = ASC_BOARDP(shost);
+	printk("  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
+	       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,
+	       (ulong)h->carr_freelist);
 
-	ASC_PRINT1("advansys_reset: board %d: SCSI bus reset started...\n",
-		   boardp->id);
-	/*
-	 * Check for re-entrancy.
-	 */
-	spin_lock_irqsave(&boardp->lock, flags);
-	if (boardp->flags & ASC_HOST_IN_RESET) {
-		spin_unlock_irqrestore(&boardp->lock, flags);
-		return FAILED;
-	}
-	boardp->flags |= ASC_HOST_IN_RESET;
-	spin_unlock_irqrestore(&boardp->lock, flags);
+	printk("  icq_sp 0x%lx, irq_sp 0x%lx\n",
+	       (ulong)h->icq_sp, (ulong)h->irq_sp);
 
-	if (ASC_NARROW_BOARD(boardp)) {
-		/*
-		 * Narrow Board
-		 */
-		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+	printk("  no_scam 0x%x, tagqng_able 0x%x\n",
+	       (unsigned)h->no_scam, (unsigned)h->tagqng_able);
 
-		/*
-		 * Reset the chip and SCSI bus.
-		 */
-		ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
-		status = AscInitAsc1000Driver(asc_dvc_varp);
-
-		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
-		if (asc_dvc_varp->err_code) {
-			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
-				   "error: 0x%x\n", boardp->id,
-				   asc_dvc_varp->err_code);
-			ret = FAILED;
-		} else if (status) {
-			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
-				   "warning: 0x%x\n", boardp->id, status);
-		} else {
-			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
-				   "successful.\n", boardp->id);
-		}
-
-		ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
-		spin_lock_irqsave(&boardp->lock, flags);
-
-	} else {
-		/*
-		 * Wide Board
-		 *
-		 * If the suggest reset bus flags are set, then reset the bus.
-		 * Otherwise only reset the device.
-		 */
-		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+	printk("  chip_scsi_id 0x%x, cfg 0x%lx\n",
+	       (unsigned)h->chip_scsi_id, (ulong)h->cfg);
+}
 
-		/*
-		 * Reset the target's SCSI bus.
-		 */
-		ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
-		switch (AdvResetChipAndSB(adv_dvc_varp)) {
-		case ASC_TRUE:
-			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
-				   "successful.\n", boardp->id);
-			break;
-		case ASC_FALSE:
-		default:
-			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
-				   "error.\n", boardp->id);
-			ret = FAILED;
-			break;
-		}
-		spin_lock_irqsave(&boardp->lock, flags);
-		(void)AdvISR(adv_dvc_varp);
-	}
-	/* Board lock is held. */
+/*
+ * asc_prt_adv_dvc_cfg()
+ *
+ * Display an ADV_DVC_CFG structure.
+ */
+static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
+{
+	printk(" ADV_DVC_CFG at addr 0x%lx\n", (ulong)h);
 
-	/* Save the time of the most recently completed reset. */
-	boardp->last_reset = jiffies;
+	printk("  disc_enable 0x%x, termination 0x%x\n",
+	       h->disc_enable, h->termination);
 
-	/* Clear reset flag. */
-	boardp->flags &= ~ASC_HOST_IN_RESET;
-	spin_unlock_irqrestore(&boardp->lock, flags);
+	printk("  chip_version 0x%x, mcode_date 0x%x\n",
+	       h->chip_version, h->mcode_date);
 
-	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
+	printk("  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
+	       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
 
-	return ret;
+	printk("  control_flag 0x%x\n", h->control_flag);
 }
 
 /*
- * advansys_biosparam()
- *
- * Translate disk drive geometry if the "BIOS greater than 1 GB"
- * support is enabled for a drive.
+ * asc_prt_adv_scsi_req_q()
  *
- * ip (information pointer) is an int array with the following definition:
- * ip[0]: heads
- * ip[1]: sectors
- * ip[2]: cylinders
+ * Display an ADV_SCSI_REQ_Q structure.
  */
-static int
-advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
-		   sector_t capacity, int ip[])
+static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 {
-	asc_board_t *boardp;
+	int sg_blk_cnt;
+	struct asc_sg_block *sg_ptr;
 
-	ASC_DBG(1, "advansys_biosparam: begin\n");
-	ASC_STATS(sdev->host, biosparam);
-	boardp = ASC_BOARDP(sdev->host);
-	if (ASC_NARROW_BOARD(boardp)) {
-		if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
-		     ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {
-			ip[0] = 255;
-			ip[1] = 63;
-		} else {
-			ip[0] = 64;
-			ip[1] = 32;
-		}
-	} else {
-		if ((boardp->dvc_var.adv_dvc_var.bios_ctrl &
-		     BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {
-			ip[0] = 255;
-			ip[1] = 63;
-		} else {
-			ip[0] = 64;
-			ip[1] = 32;
+	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
+
+	printk("  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
+	       q->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);
+
+	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
+	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
+
+	printk("  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+	       (ulong)le32_to_cpu(q->data_cnt),
+	       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);
+
+	printk
+	    ("  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
+	     q->cdb_len, q->done_status, q->host_status, q->scsi_status);
+
+	printk("  sg_working_ix 0x%x, target_cmd %u\n",
+	       q->sg_working_ix, q->target_cmd);
+
+	printk("  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
+	       (ulong)le32_to_cpu(q->scsiq_rptr),
+	       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);
+
+	/* Display the request's ADV_SG_BLOCK structures. */
+	if (q->sg_list_ptr != NULL) {
+		sg_blk_cnt = 0;
+		while (1) {
+			/*
+			 * 'sg_ptr' is a physical address. Convert it to a virtual
+			 * address by indexing 'sg_blk_cnt' into the virtual address
+			 * array 'sg_list_ptr'.
+			 *
+			 * XXX - Assumes all SG physical blocks are virtually contiguous.
+			 */
+			sg_ptr =
+			    &(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);
+			asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
+			if (sg_ptr->sg_ptr == 0) {
+				break;
+			}
+			sg_blk_cnt++;
 		}
 	}
-	ip[2] = (unsigned long)capacity / (ip[0] * ip[1]);
-	ASC_DBG(1, "advansys_biosparam: end\n");
-	return 0;
 }
 
-static struct scsi_host_template advansys_template = {
-	.proc_name = DRV_NAME,
-#ifdef CONFIG_PROC_FS
-	.proc_info = advansys_proc_info,
-#endif
-	.name = DRV_NAME,
-	.info = advansys_info,
-	.queuecommand = advansys_queuecommand,
-	.eh_bus_reset_handler = advansys_reset,
-	.bios_param = advansys_biosparam,
-	.slave_configure = advansys_slave_configure,
-	/*
-	 * Because the driver may control an ISA adapter 'unchecked_isa_dma'
-	 * must be set. The flag will be cleared in advansys_board_found
-	 * for non-ISA adapters.
-	 */
-	.unchecked_isa_dma = 1,
-	/*
-	 * All adapters controlled by this driver are capable of large
-	 * scatter-gather lists. According to the mid-level SCSI documentation
-	 * this obviates any performance gain provided by setting
-	 * 'use_clustering'. But empirically while CPU utilization is increased
-	 * by enabling clustering, I/O throughput increases as well.
-	 */
-	.use_clustering = ENABLE_CLUSTERING,
-};
-
 /*
- * First-level interrupt handler.
+ * asc_prt_adv_sgblock()
  *
- * 'dev_id' is a pointer to the interrupting adapter's Scsi_Host.
+ * Display an ADV_SG_BLOCK structure.
  */
-static irqreturn_t advansys_interrupt(int irq, void *dev_id)
+static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
 {
-	unsigned long flags;
-	struct Scsi_Host *shost = dev_id;
-	asc_board_t *boardp = ASC_BOARDP(shost);
-	irqreturn_t result = IRQ_NONE;
+	int i;
 
-	ASC_DBG1(2, "advansys_interrupt: boardp 0x%p\n", boardp);
-	spin_lock_irqsave(&boardp->lock, flags);
-	if (ASC_NARROW_BOARD(boardp)) {
-		if (AscIsIntPending(shost->io_port)) {
-			result = IRQ_HANDLED;
-			ASC_STATS(shost, interrupt);
-			ASC_DBG(1, "advansys_interrupt: before AscISR()\n");
-			AscISR(&boardp->dvc_var.asc_dvc_var);
-		}
-	} else {
-		ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
-		if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
-			result = IRQ_HANDLED;
-			ASC_STATS(shost, interrupt);
-		}
+	printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
+	       (ulong)b, sgblockno);
+	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
+	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
+	BUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);
+	if (b->sg_ptr != 0)
+		BUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);
+	for (i = 0; i < b->sg_cnt; i++) {
+		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
+		       i, (ulong)b->sg_list[i].sg_addr,
+		       (ulong)b->sg_list[i].sg_count);
 	}
-	spin_unlock_irqrestore(&boardp->lock, flags);
-
-	ASC_DBG(1, "advansys_interrupt: end\n");
-	return result;
 }
 
-static void
-advansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)
+/*
+ * asc_prt_hex()
+ *
+ * Print hexadecimal output in 4 byte groupings 32 bytes
+ * or 8 double-words per line.
+ */
+static void asc_prt_hex(char *f, uchar *s, int l)
 {
-	ASC_SCSI_BIT_ID_TYPE tid_bit = 1 << sdev->id;
-	ASC_SCSI_BIT_ID_TYPE orig_use_tagged_qng = asc_dvc->use_tagged_qng;
+	int i;
+	int j;
+	int k;
+	int m;
 
-	if (sdev->lun == 0) {
-		ASC_SCSI_BIT_ID_TYPE orig_init_sdtr = asc_dvc->init_sdtr;
-		if ((asc_dvc->cfg->sdtr_enable & tid_bit) && sdev->sdtr) {
-			asc_dvc->init_sdtr |= tid_bit;
+	printk("%s: (%d bytes)\n", f, l);
+
+	for (i = 0; i < l; i += 32) {
+
+		/* Display a maximum of 8 double-words per line. */
+		if ((k = (l - i) / 4) >= 8) {
+			k = 8;
+			m = 0;
 		} else {
-			asc_dvc->init_sdtr &= ~tid_bit;
+			m = (l - i) % 4;
 		}
 
-		if (orig_init_sdtr != asc_dvc->init_sdtr)
-			AscAsyncFix(asc_dvc, sdev);
-	}
-
-	if (sdev->tagged_supported) {
-		if (asc_dvc->cfg->cmd_qng_enabled & tid_bit) {
-			if (sdev->lun == 0) {
-				asc_dvc->cfg->can_tagged_qng |= tid_bit;
-				asc_dvc->use_tagged_qng |= tid_bit;
-			}
-			scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
-						asc_dvc->max_dvc_qng[sdev->id]);
-		}
-	} else {
-		if (sdev->lun == 0) {
-			asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
-			asc_dvc->use_tagged_qng &= ~tid_bit;
+		for (j = 0; j < k; j++) {
+			printk(" %2.2X%2.2X%2.2X%2.2X",
+			       (unsigned)s[i + (j * 4)],
+			       (unsigned)s[i + (j * 4) + 1],
+			       (unsigned)s[i + (j * 4) + 2],
+			       (unsigned)s[i + (j * 4) + 3]);
 		}
-		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
-	}
 
-	if ((sdev->lun == 0) &&
-	    (orig_use_tagged_qng != asc_dvc->use_tagged_qng)) {
-		AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
-				 asc_dvc->cfg->disc_enable);
-		AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
-				 asc_dvc->use_tagged_qng);
-		AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
-				 asc_dvc->cfg->can_tagged_qng);
+		switch (m) {
+		case 0:
+		default:
+			break;
+		case 1:
+			printk(" %2.2X", (unsigned)s[i + (j * 4)]);
+			break;
+		case 2:
+			printk(" %2.2X%2.2X",
+			       (unsigned)s[i + (j * 4)],
+			       (unsigned)s[i + (j * 4) + 1]);
+			break;
+		case 3:
+			printk(" %2.2X%2.2X%2.2X",
+			       (unsigned)s[i + (j * 4) + 1],
+			       (unsigned)s[i + (j * 4) + 2],
+			       (unsigned)s[i + (j * 4) + 3]);
+			break;
+		}
 
-		asc_dvc->max_dvc_qng[sdev->id] =
-					asc_dvc->cfg->max_tag_qng[sdev->id];
-		AscWriteLramByte(asc_dvc->iop_base,
-				 (ushort)(ASCV_MAX_DVC_QNG_BEG + sdev->id),
-				 asc_dvc->max_dvc_qng[sdev->id]);
+		printk("\n");
 	}
 }
+#endif /* ADVANSYS_DEBUG */
 
 /*
- * Wide Transfers
+ * advansys_info()
  *
- * If the EEPROM enabled WDTR for the device and the device supports wide
- * bus (16 bit) transfers, then turn on the device's 'wdtr_able' bit and
- * write the new value to the microcode.
+ * Return suitable for printing on the console with the argument
+ * adapter's configuration information.
+ *
+ * Note: The information line should not exceed ASC_INFO_SIZE bytes,
+ * otherwise the static 'info' array will be overrun.
  */
-static void
-advansys_wide_enable_wdtr(AdvPortAddr iop_base, unsigned short tidmask)
+static const char *advansys_info(struct Scsi_Host *shost)
 {
-	unsigned short cfg_word;
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
-	if ((cfg_word & tidmask) != 0)
-		return;
-
-	cfg_word |= tidmask;
-	AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
+	static char info[ASC_INFO_SIZE];
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	char *busname;
+	char *widename = NULL;
 
-	/*
-	 * Clear the microcode SDTR and WDTR negotiation done indicators for
-	 * the target to cause it to negotiate with the new setting set above.
-	 * WDTR when accepted causes the target to enter asynchronous mode, so
-	 * SDTR must be negotiated.
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-	cfg_word &= ~tidmask;
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
-	cfg_word &= ~tidmask;
-	AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+	boardp = ASC_BOARDP(shost);
+	if (ASC_NARROW_BOARD(boardp)) {
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+		ASC_DBG(1, "advansys_info: begin\n");
+		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+			if ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) ==
+			    ASC_IS_ISAPNP) {
+				busname = "ISA PnP";
+			} else {
+				busname = "ISA";
+			}
+			sprintf(info,
+				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",
+				ASC_VERSION, busname,
+				(ulong)shost->io_port,
+				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
+				shost->irq, shost->dma_channel);
+		} else {
+			if (asc_dvc_varp->bus_type & ASC_IS_VL) {
+				busname = "VL";
+			} else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {
+				busname = "EISA";
+			} else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {
+				if ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)
+				    == ASC_IS_PCI_ULTRA) {
+					busname = "PCI Ultra";
+				} else {
+					busname = "PCI";
+				}
+			} else {
+				busname = "?";
+				ASC_PRINT2("advansys_info: board %d: unknown "
+					   "bus type %d\n", boardp->id,
+					   asc_dvc_varp->bus_type);
+			}
+			sprintf(info,
+				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
+				ASC_VERSION, busname, (ulong)shost->io_port,
+				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
+				shost->irq);
+		}
+	} else {
+		/*
+		 * Wide Adapter Information
+		 *
+		 * Memory-mapped I/O is used instead of I/O space to access
+		 * the adapter, but display the I/O Port range. The Memory
+		 * I/O address is displayed through the driver /proc file.
+		 */
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+			widename = "Ultra-Wide";
+		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+			widename = "Ultra2-Wide";
+		} else {
+			widename = "Ultra3-Wide";
+		}
+		sprintf(info,
+			"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
+			ASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,
+			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, shost->irq);
+	}
+	BUG_ON(strlen(info) >= ASC_INFO_SIZE);
+	ASC_DBG(1, "advansys_info: end\n");
+	return info;
 }
 
+#ifdef CONFIG_PROC_FS
 /*
- * Synchronous Transfers
+ * asc_prt_line()
  *
- * If the EEPROM enabled SDTR for the device and the device
- * supports synchronous transfers, then turn on the device's
- * 'sdtr_able' bit. Write the new value to the microcode.
+ * If 'cp' is NULL print to the console, otherwise print to a buffer.
+ *
+ * Return 0 if printing to the console, otherwise return the number of
+ * bytes written to the buffer.
+ *
+ * Note: If any single line is greater than ASC_PRTLINE_SIZE bytes the stack
+ * will be corrupted. 's[]' is defined to be ASC_PRTLINE_SIZE bytes.
  */
-static void
-advansys_wide_enable_sdtr(AdvPortAddr iop_base, unsigned short tidmask)
+static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
 {
-	unsigned short cfg_word;
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
-	if ((cfg_word & tidmask) != 0)
-		return;
-
-	cfg_word |= tidmask;
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+	va_list args;
+	int ret;
+	char s[ASC_PRTLINE_SIZE];
 
-	/*
-	 * Clear the microcode "SDTR negotiation" done indicator for the
-	 * target to cause it to negotiate with the new setting set above.
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-	cfg_word &= ~tidmask;
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	va_start(args, fmt);
+	ret = vsprintf(s, fmt, args);
+	BUG_ON(ret >= ASC_PRTLINE_SIZE);
+	if (buf == NULL) {
+		(void)printk(s);
+		ret = 0;
+	} else {
+		ret = min(buflen, ret);
+		memcpy(buf, s, ret);
+	}
+	va_end(args);
+	return ret;
 }
 
 /*
- * PPR (Parallel Protocol Request) Capable
+ * asc_prt_board_devices()
  *
- * If the device supports DT mode, then it must be PPR capable.
- * The PPR message will be used in place of the SDTR and WDTR
- * messages to negotiate synchronous speed and offset, transfer
- * width, and protocol options.
+ * Print driver information for devices attached to the board.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
  */
-static void advansys_wide_enable_ppr(ADV_DVC_VAR *adv_dvc,
-				AdvPortAddr iop_base, unsigned short tidmask)
-{
-	AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);
-	adv_dvc->ppr_able |= tidmask;
-	AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);
-}
-
-static void
-advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
+static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	AdvPortAddr iop_base = adv_dvc->iop_base;
-	unsigned short tidmask = 1 << sdev->id;
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	int chip_scsi_id;
+	int i;
 
-	if (sdev->lun == 0) {
-		/*
-		 * Handle WDTR, SDTR, and Tag Queuing. If the feature
-		 * is enabled in the EEPROM and the device supports the
-		 * feature, then enable it in the microcode.
-		 */
+	boardp = ASC_BOARDP(shost);
+	leftlen = cplen;
+	totlen = len = 0;
 
-		if ((adv_dvc->wdtr_able & tidmask) && sdev->wdtr)
-			advansys_wide_enable_wdtr(iop_base, tidmask);
-		if ((adv_dvc->sdtr_able & tidmask) && sdev->sdtr)
-			advansys_wide_enable_sdtr(iop_base, tidmask);
-		if (adv_dvc->chip_type == ADV_CHIP_ASC38C1600 && sdev->ppr)
-			advansys_wide_enable_ppr(adv_dvc, iop_base, tidmask);
+	len = asc_prt_line(cp, leftlen,
+			   "\nDevice Information for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
 
-		/*
-		 * Tag Queuing is disabled for the BIOS which runs in polled
-		 * mode and would see no benefit from Tag Queuing. Also by
-		 * disabling Tag Queuing in the BIOS devices with Tag Queuing
-		 * bugs will at least work with the BIOS.
-		 */
-		if ((adv_dvc->tagqng_able & tidmask) &&
-		    sdev->tagged_supported) {
-			unsigned short cfg_word;
-			AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
-			cfg_word |= tidmask;
-			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
-					 cfg_word);
-			AdvWriteByteLram(iop_base,
-					 ASC_MC_NUMBER_OF_MAX_CMD + sdev->id,
-					 adv_dvc->max_dvc_qng);
-		}
+	if (ASC_NARROW_BOARD(boardp)) {
+		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+	} else {
+		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
 	}
 
-	if ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported) {
-		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
-					adv_dvc->max_dvc_qng);
-	} else {
-		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
+	len = asc_prt_line(cp, leftlen, "Target IDs Detected:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) {
+			len = asc_prt_line(cp, leftlen, " %X,", i);
+			ASC_PRT_NEXT();
+		}
 	}
+	len = asc_prt_line(cp, leftlen, " (%X=Host Adapter)\n", chip_scsi_id);
+	ASC_PRT_NEXT();
+
+	return totlen;
 }
 
 /*
- * Set the number of commands to queue per device for the
- * specified host adapter.
+ * Display Wide Board BIOS Information.
  */
-static int advansys_slave_configure(struct scsi_device *sdev)
+static int asc_prt_adv_bios(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp = ASC_BOARDP(sdev->host);
-	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	ushort major, minor, letter;
+
+	boardp = ASC_BOARDP(shost);
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen, "\nROM BIOS Version: ");
+	ASC_PRT_NEXT();
 
 	/*
-	 * Save a pointer to the sdev and set its initial/maximum
-	 * queue depth.  Only save the pointer for a lun0 dev though.
+	 * If the BIOS saved a valid signature, then fill in
+	 * the BIOS code segment base address.
 	 */
-	if (sdev->lun == 0)
-		boardp->device[sdev->id] = sdev;
+	if (boardp->bios_signature != 0x55AA) {
+		len = asc_prt_line(cp, leftlen, "Disabled or Pre-3.1\n");
+		ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen,
+				   "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
+		ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen,
+				   "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
+		ASC_PRT_NEXT();
+	} else {
+		major = (boardp->bios_version >> 12) & 0xF;
+		minor = (boardp->bios_version >> 8) & 0xF;
+		letter = (boardp->bios_version & 0xFF);
 
-	if (ASC_NARROW_BOARD(boardp))
-		advansys_narrow_slave_configure(sdev,
-						&boardp->dvc_var.asc_dvc_var);
-	else
-		advansys_wide_slave_configure(sdev,
-						&boardp->dvc_var.adv_dvc_var);
+		len = asc_prt_line(cp, leftlen, "%d.%d%c\n",
+				   major, minor,
+				   letter >= 26 ? '?' : letter + 'A');
+		ASC_PRT_NEXT();
 
-	return 0;
+		/*
+		 * Current available ROM BIOS release is 3.1I for UW
+		 * and 3.2I for U2W. This code doesn't differentiate
+		 * UW and U2W boards.
+		 */
+		if (major < 3 || (major <= 3 && minor < 1) ||
+		    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {
+			len = asc_prt_line(cp, leftlen,
+					   "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
+			ASC_PRT_NEXT();
+			len = asc_prt_line(cp, leftlen,
+					   "ftp://ftp.connectcom.net/pub\n");
+			ASC_PRT_NEXT();
+		}
+	}
+
+	return totlen;
 }
 
 /*
- * Execute a single 'Scsi_Cmnd'.
- *
- * The function 'done' is called when the request has been completed.
- *
- * Scsi_Cmnd:
- *
- *  host - board controlling device
- *  device - device to send command
- *  target - target of device
- *  lun - lun of device
- *  cmd_len - length of SCSI CDB
- *  cmnd - buffer for SCSI 8, 10, or 12 byte CDB
- *  use_sg - if non-zero indicates scatter-gather request with use_sg elements
+ * Add serial number to information bar if signature AAh
+ * is found in at bit 15-9 (7 bits) of word 1.
  *
- *  if (use_sg == 0) {
- *    request_buffer - buffer address for request
- *    request_bufflen - length of request buffer
- *  } else {
- *    request_buffer - pointer to scatterlist structure
- *  }
+ * Serial Number consists fo 12 alpha-numeric digits.
  *
- *  sense_buffer - sense command buffer
+ *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)
+ *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)
+ *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)
+ *       5 - Product revision (A-J)    Word0:  "         "
  *
- *  result (4 bytes of an int):
- *    Byte Meaning
- *    0 SCSI Status Byte Code
- *    1 SCSI One Byte Message Code
- *    2 Host Error Code
- *    3 Mid-Level Error Code
+ *           Signature                 Word1: 15-9 (7 bits)
+ *       6 - Year (0-9)                Word1: 8-6 (3 bits) & Word2: 15 (1 bit)
+ *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)
  *
- *  host driver fields:
- *    SCp - Scsi_Pointer used for command processing status
- *    scsi_done - used to save caller's done function
- *    host_scribble - used for pointer to another struct scsi_cmnd
+ *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)
  *
- * If this function returns ASC_NOERROR the request will be completed
- * from the interrupt handler.
+ * Note 1: Only production cards will have a serial number.
  *
- * If this function returns ASC_ERROR the host error code has been set,
- * and the called must call asc_scsi_done.
+ * Note 2: Signature is most significant 7 bits (0xFE).
  *
- * If ASC_BUSY is returned the request will be returned to the midlayer
- * and re-tried later.
+ * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.
  */
-static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
+static int asc_get_eeprom_string(ushort *serialnum, uchar *cp)
 {
-	asc_board_t *boardp;
-	ASC_DVC_VAR *asc_dvc_varp;
-	ADV_DVC_VAR *adv_dvc_varp;
-	ADV_SCSI_REQ_Q *adv_scsiqp;
-	struct scsi_device *device;
-	int ret;
+	ushort w, num;
 
-	ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
-		 (ulong)scp, (ulong)scp->scsi_done);
+	if ((serialnum[1] & 0xFE00) != ((ushort)0xAA << 8)) {
+		return ASC_FALSE;
+	} else {
+		/*
+		 * First word - 6 digits.
+		 */
+		w = serialnum[0];
 
-	boardp = ASC_BOARDP(scp->device->host);
-	device = boardp->device[scp->device->id];
+		/* Product type - 1st digit. */
+		if ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {
+			/* Product type is P=Prototype */
+			*cp += 0x8;
+		}
+		cp++;
+
+		/* Manufacturing location - 2nd digit. */
+		*cp++ = 'A' + ((w & 0x1C00) >> 10);
+
+		/* Product ID - 3rd, 4th digits. */
+		num = w & 0x3FF;
+		*cp++ = '0' + (num / 100);
+		num %= 100;
+		*cp++ = '0' + (num / 10);
+
+		/* Product revision - 5th digit. */
+		*cp++ = 'A' + (num % 10);
 
-	if (ASC_NARROW_BOARD(boardp)) {
 		/*
-		 * Build and execute Narrow Board request.
+		 * Second word
 		 */
-
-		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+		w = serialnum[1];
 
 		/*
-		 * Build Asc Library request structure using the
-		 * global structures 'asc_scsi_req' and 'asc_sg_head'.
-		 *
-		 * If an error is returned, then the request has been
-		 * queued on the board done queue. It will be completed
-		 * by the caller.
+		 * Year - 6th digit.
 		 *
-		 * asc_build_req() can not return ASC_BUSY.
+		 * If bit 15 of third word is set, then the
+		 * last digit of the year is greater than 7.
 		 */
-		if (asc_build_req(boardp, scp) == ASC_ERROR) {
-			ASC_STATS(scp->device->host, build_error);
-			return ASC_ERROR;
+		if (serialnum[2] & 0x8000) {
+			*cp++ = '8' + ((w & 0x1C0) >> 6);
+		} else {
+			*cp++ = '0' + ((w & 0x1C0) >> 6);
 		}
 
-		switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
-		case ASC_NOERROR:
-			ASC_STATS(scp->device->host, exe_noerror);
-			/*
-			 * Increment monotonically increasing per device
-			 * successful request counter. Wrapping doesn't matter.
-			 */
-			boardp->reqcnt[scp->device->id]++;
-			ASC_DBG(1, "asc_execute_scsi_cmnd: AscExeScsiQueue(), "
-				"ASC_NOERROR\n");
-			break;
-		case ASC_BUSY:
-			ASC_STATS(scp->device->host, exe_busy);
-			break;
-		case ASC_ERROR:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-				boardp->id, asc_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_error);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		default:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AscExeScsiQueue() unknown, err_code 0x%x\n",
-				boardp->id, asc_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_unknown);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		}
-	} else {
-		/*
-		 * Build and execute Wide Board request.
-		 */
-		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+		/* Week of year - 7th, 8th digits. */
+		num = w & 0x003F;
+		*cp++ = '0' + num / 10;
+		num %= 10;
+		*cp++ = '0' + num;
 
 		/*
-		 * Build and get a pointer to an Adv Library request structure.
-		 *
-		 * If the request is successfully built then send it below,
-		 * otherwise return with an error.
+		 * Third word
 		 */
-		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
-		case ASC_NOERROR:
-			ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req "
-				"ASC_NOERROR\n");
-			break;
-		case ASC_BUSY:
-			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
-				"ASC_BUSY\n");
-			/*
-			 * The asc_stats fields 'adv_build_noreq' and
-			 * 'adv_build_nosg' count wide board busy conditions.
-			 * They are updated in adv_build_req and
-			 * adv_get_sglist, respectively.
-			 */
-			return ASC_BUSY;
-		case ASC_ERROR:
-		default:
-			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
-				"ASC_ERROR\n");
-			ASC_STATS(scp->device->host, build_error);
-			return ASC_ERROR;
-		}
+		w = serialnum[2] & 0x7FFF;
 
-		switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
-		case ASC_NOERROR:
-			ASC_STATS(scp->device->host, exe_noerror);
-			/*
-			 * Increment monotonically increasing per device
-			 * successful request counter. Wrapping doesn't matter.
-			 */
-			boardp->reqcnt[scp->device->id]++;
-			ASC_DBG(1, "asc_execute_scsi_cmnd: AdvExeScsiQueue(), "
-				"ASC_NOERROR\n");
-			break;
-		case ASC_BUSY:
-			ASC_STATS(scp->device->host, exe_busy);
-			break;
-		case ASC_ERROR:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-				boardp->id, adv_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_error);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		default:
-			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
-				"AdvExeScsiQueue() unknown, err_code 0x%x\n",
-				boardp->id, adv_dvc_varp->err_code);
-			ASC_STATS(scp->device->host, exe_unknown);
-			scp->result = HOST_BYTE(DID_ERROR);
-			break;
-		}
-	}
+		/* Serial number - 9th digit. */
+		*cp++ = 'A' + (w / 1000);
 
-	ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");
-	return ret;
+		/* 10th, 11th, 12th digits. */
+		num = w % 1000;
+		*cp++ = '0' + num / 100;
+		num %= 100;
+		*cp++ = '0' + num / 10;
+		num %= 10;
+		*cp++ = '0' + num;
+
+		*cp = '\0';	/* Null Terminate the string. */
+		return ASC_TRUE;
+	}
 }
 
 /*
- * Build a request structure for the Asc Library (Narrow Board).
+ * asc_prt_asc_board_eeprom()
  *
- * The global structures 'asc_scsi_q' and 'asc_sg_head' are
- * used to build the request.
+ * Print board EEPROM configuration.
  *
- * If an error occurs, then return ASC_ERROR.
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
+static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	/*
-	 * Mutually exclusive access is required to 'asc_scsi_q' and
-	 * 'asc_sg_head' until after the request is started.
-	 */
-	memset(&asc_scsi_q, 0, sizeof(ASC_SCSI_Q));
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	int leftlen;
+	int totlen;
+	int len;
+	ASCEEP_CONFIG *ep;
+	int i;
+#ifdef CONFIG_ISA
+	int isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };
+#endif /* CONFIG_ISA */
+	uchar serialstr[13];
 
-	/*
-	 * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
-	 */
-	asc_scsi_q.q2.srb_ptr = ASC_VADDR_TO_U32(scp);
+	boardp = ASC_BOARDP(shost);
+	asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+	ep = &boardp->eep_config.asc_eep;
 
-	/*
-	 * Build the ASC_SCSI_Q request.
-	 */
-	asc_scsi_q.cdbptr = &scp->cmnd[0];
-	asc_scsi_q.q2.cdb_len = scp->cmd_len;
-	asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
-	asc_scsi_q.q1.target_lun = scp->device->lun;
-	asc_scsi_q.q2.target_ix =
-	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
-	asc_scsi_q.q1.sense_addr =
-	    cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-	asc_scsi_q.q1.sense_len = sizeof(scp->sense_buffer);
+	leftlen = cplen;
+	totlen = len = 0;
 
-	/*
-	 * If there are any outstanding requests for the current target,
-	 * then every 255th request send an ORDERED request. This heuristic
-	 * tries to retain the benefit of request sorting while preventing
-	 * request starvation. 255 is the max number of tags or pending commands
-	 * a device may have outstanding.
-	 *
-	 * The request count is incremented below for every successfully
-	 * started request.
-	 *
-	 */
-	if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
-	    (boardp->reqcnt[scp->device->id] % 255) == 0) {
-		asc_scsi_q.q2.tag_code = MSG_ORDERED_TAG;
-	} else {
-		asc_scsi_q.q2.tag_code = MSG_SIMPLE_TAG;
-	}
+	len = asc_prt_line(cp, leftlen,
+			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
 
-	/*
-	 * Build ASC_SCSI_Q for a contiguous buffer or a scatter-gather
-	 * buffer command.
-	 */
-	if (scp->use_sg == 0) {
-		/*
-		 * CDB request of single contiguous buffer.
-		 */
-		ASC_STATS(scp->device->host, cont_cnt);
-		scp->SCp.dma_handle = scp->request_bufflen ?
-		    dma_map_single(boardp->dev, scp->request_buffer,
-				   scp->request_bufflen,
-				   scp->sc_data_direction) : 0;
-		asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
-		asc_scsi_q.q1.data_cnt = cpu_to_le32(scp->request_bufflen);
-		ASC_STATS_ADD(scp->device->host, cont_xfer,
-			      ASC_CEILING(scp->request_bufflen, 512));
-		asc_scsi_q.q1.sg_queue_cnt = 0;
-		asc_scsi_q.sg_head = NULL;
+	if (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)
+	    == ASC_TRUE) {
+		len =
+		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
+				 serialstr);
+		ASC_PRT_NEXT();
 	} else {
-		/*
-		 * CDB scatter-gather request list.
-		 */
-		int sgcnt;
-		int use_sg;
-		struct scatterlist *slp;
-
-		slp = (struct scatterlist *)scp->request_buffer;
-		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
-				    scp->sc_data_direction);
-
-		if (use_sg > scp->device->host->sg_tablesize) {
-			ASC_PRINT3("asc_build_req: board %d: use_sg %d > "
-				   "sg_tablesize %d\n", boardp->id, use_sg,
-				   scp->device->host->sg_tablesize);
-			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
-				     scp->sc_data_direction);
-			scp->result = HOST_BYTE(DID_ERROR);
-			return ASC_ERROR;
+		if (ep->adapter_info[5] == 0xBB) {
+			len = asc_prt_line(cp, leftlen,
+					   " Default Settings Used for EEPROM-less Adapter.\n");
+			ASC_PRT_NEXT();
+		} else {
+			len = asc_prt_line(cp, leftlen,
+					   " Serial Number Signature Not Present.\n");
+			ASC_PRT_NEXT();
 		}
+	}
 
-		ASC_STATS(scp->device->host, sg_cnt);
+	len = asc_prt_line(cp, leftlen,
+			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+			   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,
+			   ep->max_tag_qng);
+	ASC_PRT_NEXT();
 
-		/*
-		 * Use global ASC_SG_HEAD structure and set the ASC_SCSI_Q
-		 * structure to point to it.
-		 */
-		memset(&asc_sg_head, 0, sizeof(ASC_SG_HEAD));
+	len = asc_prt_line(cp, leftlen,
+			   " cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);
+	ASC_PRT_NEXT();
 
-		asc_scsi_q.q1.cntl |= QC_SG_HEAD;
-		asc_scsi_q.sg_head = &asc_sg_head;
-		asc_scsi_q.q1.data_cnt = 0;
-		asc_scsi_q.q1.data_addr = 0;
-		/* This is a byte value, otherwise it would need to be swapped. */
-		asc_sg_head.entry_cnt = asc_scsi_q.q1.sg_queue_cnt = use_sg;
-		ASC_STATS_ADD(scp->device->host, sg_elem,
-			      asc_sg_head.entry_cnt);
+	len = asc_prt_line(cp, leftlen, " Target ID:           ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %d", i);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-		/*
-		 * Convert scatter-gather list into ASC_SG_HEAD list.
-		 */
-		for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
-			asc_sg_head.sg_list[sgcnt].addr =
-			    cpu_to_le32(sg_dma_address(slp));
-			asc_sg_head.sg_list[sgcnt].bytes =
-			    cpu_to_le32(sg_dma_len(slp));
-			ASC_STATS_ADD(scp->device->host, sg_xfer,
-				      ASC_CEILING(sg_dma_len(slp), 512));
-		}
+	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
 	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	ASC_DBG_PRT_ASC_SCSI_Q(2, &asc_scsi_q);
-	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	return ASC_NOERROR;
+	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+#ifdef CONFIG_ISA
+	if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+		len = asc_prt_line(cp, leftlen,
+				   " Host ISA DMA speed:   %d MB/S\n",
+				   isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
+		ASC_PRT_NEXT();
+	}
+#endif /* CONFIG_ISA */
+
+	return totlen;
 }
 
 /*
- * Build a request structure for the Adv Library (Wide Board).
+ * asc_prt_adv_board_eeprom()
  *
- * If an adv_req_t can not be allocated to issue the request,
- * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.
+ * Print board EEPROM configuration.
  *
- * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the
- * microcode for DMA addresses or math operations are byte swapped
- * to little-endian order.
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
  */
-static int
-adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
-	      ADV_SCSI_REQ_Q **adv_scsiqpp)
+static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	adv_req_t *reqp;
-	ADV_SCSI_REQ_Q *scsiqp;
+	asc_board_t *boardp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	int leftlen;
+	int totlen;
+	int len;
 	int i;
-	int ret;
+	char *termstr;
+	uchar serialstr[13];
+	ADVEEP_3550_CONFIG *ep_3550 = NULL;
+	ADVEEP_38C0800_CONFIG *ep_38C0800 = NULL;
+	ADVEEP_38C1600_CONFIG *ep_38C1600 = NULL;
+	ushort word;
+	ushort *wordp;
+	ushort sdtr_speed = 0;
 
-	/*
-	 * Allocate an adv_req_t structure from the board to execute
-	 * the command.
-	 */
-	if (boardp->adv_reqp == NULL) {
-		ASC_DBG(1, "adv_build_req: no free adv_req_t\n");
-		ASC_STATS(scp->device->host, adv_build_noreq);
-		return ASC_BUSY;
+	boardp = ASC_BOARDP(shost);
+	adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		ep_3550 = &boardp->eep_config.adv_3550_eep;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
 	} else {
-		reqp = boardp->adv_reqp;
-		boardp->adv_reqp = reqp->next_reqp;
-		reqp->next_reqp = NULL;
+		ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
 	}
 
-	/*
-	 * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.
-	 */
-	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
-
-	/*
-	 * Initialize the structure.
-	 */
-	scsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;
+	leftlen = cplen;
+	totlen = len = 0;
 
-	/*
-	 * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
-	 */
-	scsiqp->srb_ptr = ASC_VADDR_TO_U32(reqp);
+	len = asc_prt_line(cp, leftlen,
+			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
 
-	/*
-	 * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
-	 */
-	reqp->cmndp = scp;
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		wordp = &ep_3550->serial_number_word1;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		wordp = &ep_38C0800->serial_number_word1;
+	} else {
+		wordp = &ep_38C1600->serial_number_word1;
+	}
 
-	/*
-	 * Build the ADV_SCSI_REQ_Q request.
-	 */
+	if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE) {
+		len =
+		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
+				 serialstr);
+		ASC_PRT_NEXT();
+	} else {
+		len = asc_prt_line(cp, leftlen,
+				   " Serial Number Signature Not Present.\n");
+		ASC_PRT_NEXT();
+	}
 
-	/* Set CDB length and copy it to the request structure.  */
-	scsiqp->cdb_len = scp->cmd_len;
-	/* Copy first 12 CDB bytes to cdb[]. */
-	for (i = 0; i < scp->cmd_len && i < 12; i++) {
-		scsiqp->cdb[i] = scp->cmnd[i];
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen,
+				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+				   ep_3550->adapter_scsi_id,
+				   ep_3550->max_host_qng, ep_3550->max_dvc_qng);
+		ASC_PRT_NEXT();
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		len = asc_prt_line(cp, leftlen,
+				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+				   ep_38C0800->adapter_scsi_id,
+				   ep_38C0800->max_host_qng,
+				   ep_38C0800->max_dvc_qng);
+		ASC_PRT_NEXT();
+	} else {
+		len = asc_prt_line(cp, leftlen,
+				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+				   ep_38C1600->adapter_scsi_id,
+				   ep_38C1600->max_host_qng,
+				   ep_38C1600->max_dvc_qng);
+		ASC_PRT_NEXT();
 	}
-	/* Copy last 4 CDB bytes, if present, to cdb16[]. */
-	for (; i < scp->cmd_len; i++) {
-		scsiqp->cdb16[i - 12] = scp->cmnd[i];
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->termination;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->termination_lvd;
+	} else {
+		word = ep_38C1600->termination_lvd;
+	}
+	switch (word) {
+	case 1:
+		termstr = "Low Off/High Off";
+		break;
+	case 2:
+		termstr = "Low Off/High On";
+		break;
+	case 3:
+		termstr = "Low On/High On";
+		break;
+	default:
+	case 0:
+		termstr = "Automatic";
+		break;
 	}
 
-	scsiqp->target_id = scp->device->id;
-	scsiqp->target_lun = scp->device->lun;
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen,
+				   " termination: %u (%s), bios_ctrl: 0x%x\n",
+				   ep_3550->termination, termstr,
+				   ep_3550->bios_ctrl);
+		ASC_PRT_NEXT();
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		len = asc_prt_line(cp, leftlen,
+				   " termination: %u (%s), bios_ctrl: 0x%x\n",
+				   ep_38C0800->termination_lvd, termstr,
+				   ep_38C0800->bios_ctrl);
+		ASC_PRT_NEXT();
+	} else {
+		len = asc_prt_line(cp, leftlen,
+				   " termination: %u (%s), bios_ctrl: 0x%x\n",
+				   ep_38C1600->termination_lvd, termstr,
+				   ep_38C1600->bios_ctrl);
+		ASC_PRT_NEXT();
+	}
 
-	scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-	scsiqp->sense_len = sizeof(scp->sense_buffer);
+	len = asc_prt_line(cp, leftlen, " Target ID:           ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %X", i);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	/*
-	 * Build ADV_SCSI_REQ_Q for a contiguous buffer or a scatter-gather
-	 * buffer command.
-	 */
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->disc_enable;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->disc_enable;
+	} else {
+		word = ep_38C1600->disc_enable;
+	}
+	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
-	scsiqp->vdata_addr = scp->request_buffer;
-	scsiqp->data_addr = cpu_to_le32(virt_to_bus(scp->request_buffer));
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->tagqng_able;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->tagqng_able;
+	} else {
+		word = ep_38C1600->tagqng_able;
+	}
+	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	if (scp->use_sg == 0) {
-		/*
-		 * CDB request of single contiguous buffer.
-		 */
-		reqp->sgblkp = NULL;
-		scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
-		if (scp->request_bufflen) {
-			scsiqp->vdata_addr = scp->request_buffer;
-			scp->SCp.dma_handle =
-			    dma_map_single(boardp->dev, scp->request_buffer,
-					   scp->request_bufflen,
-					   scp->sc_data_direction);
-		} else {
-			scsiqp->vdata_addr = NULL;
-			scp->SCp.dma_handle = 0;
-		}
-		scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);
-		scsiqp->sg_list_ptr = NULL;
-		scsiqp->sg_real_addr = 0;
-		ASC_STATS(scp->device->host, cont_cnt);
-		ASC_STATS_ADD(scp->device->host, cont_xfer,
-			      ASC_CEILING(scp->request_bufflen, 512));
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->start_motor;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->start_motor;
 	} else {
-		/*
-		 * CDB scatter-gather request list.
-		 */
-		struct scatterlist *slp;
-		int use_sg;
-
-		slp = (struct scatterlist *)scp->request_buffer;
-		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
-				    scp->sc_data_direction);
-
-		if (use_sg > ADV_MAX_SG_LIST) {
-			ASC_PRINT3("adv_build_req: board %d: use_sg %d > "
-				   "ADV_MAX_SG_LIST %d\n", boardp->id, use_sg,
-				   scp->device->host->sg_tablesize);
-			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
-				     scp->sc_data_direction);
-			scp->result = HOST_BYTE(DID_ERROR);
-
-			/*
-			 * Free the 'adv_req_t' structure by adding it back
-			 * to the board free list.
-			 */
-			reqp->next_reqp = boardp->adv_reqp;
-			boardp->adv_reqp = reqp;
+		word = ep_38C1600->start_motor;
+	}
+	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-			return ASC_ERROR;
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
+		ASC_PRT_NEXT();
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			len = asc_prt_line(cp, leftlen, " %c",
+					   (ep_3550->
+					    sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
+					   'Y' : 'N');
+			ASC_PRT_NEXT();
 		}
+		len = asc_prt_line(cp, leftlen, "\n");
+		ASC_PRT_NEXT();
+	}
 
-		ret = adv_get_sglist(boardp, reqp, scp, use_sg);
-		if (ret != ADV_SUCCESS) {
-			/*
-			 * Free the adv_req_t structure by adding it back to
-			 * the board free list.
-			 */
-			reqp->next_reqp = boardp->adv_reqp;
-			boardp->adv_reqp = reqp;
-
-			return ret;
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen, " Ultra Transfer:      ");
+		ASC_PRT_NEXT();
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			len = asc_prt_line(cp, leftlen, " %c",
+					   (ep_3550->
+					    ultra_able & ADV_TID_TO_TIDMASK(i))
+					   ? 'Y' : 'N');
+			ASC_PRT_NEXT();
 		}
+		len = asc_prt_line(cp, leftlen, "\n");
+		ASC_PRT_NEXT();
+	}
 
-		ASC_STATS(scp->device->host, sg_cnt);
-		ASC_STATS_ADD(scp->device->host, sg_elem, use_sg);
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->wdtr_able;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->wdtr_able;
+	} else {
+		word = ep_38C1600->wdtr_able;
+	}
+	len = asc_prt_line(cp, leftlen, " Wide Transfer:       ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
 	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
-	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
+	    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {
+		len = asc_prt_line(cp, leftlen,
+				   " Synchronous Transfer Speed (Mhz):\n  ");
+		ASC_PRT_NEXT();
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			char *speed_str;
 
-	*adv_scsiqpp = scsiqp;
+			if (i == 0) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed1;
+			} else if (i == 4) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed2;
+			} else if (i == 8) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed3;
+			} else if (i == 12) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed4;
+			}
+			switch (sdtr_speed & ADV_MAX_TID) {
+			case 0:
+				speed_str = "Off";
+				break;
+			case 1:
+				speed_str = "  5";
+				break;
+			case 2:
+				speed_str = " 10";
+				break;
+			case 3:
+				speed_str = " 20";
+				break;
+			case 4:
+				speed_str = " 40";
+				break;
+			case 5:
+				speed_str = " 80";
+				break;
+			default:
+				speed_str = "Unk";
+				break;
+			}
+			len = asc_prt_line(cp, leftlen, "%X:%s ", i, speed_str);
+			ASC_PRT_NEXT();
+			if (i == 7) {
+				len = asc_prt_line(cp, leftlen, "\n  ");
+				ASC_PRT_NEXT();
+			}
+			sdtr_speed >>= 4;
+		}
+		len = asc_prt_line(cp, leftlen, "\n");
+		ASC_PRT_NEXT();
+	}
 
-	return ASC_NOERROR;
+	return totlen;
 }
 
 /*
- * Build scatter-gather list for Adv Library (Wide Board).
+ * asc_prt_driver_conf()
  *
- * Additional ADV_SG_BLOCK structures will need to be allocated
- * if the total number of scatter-gather elements exceeds
- * NO_OF_SG_PER_BLOCK (15). The ADV_SG_BLOCK structures are
- * assumed to be physically contiguous.
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
  *
- * Return:
- *      ADV_SUCCESS(1) - SG List successfully created
- *      ADV_ERROR(-1) - SG List creation failed
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
  */
-static int
-adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
-	       int use_sg)
+static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	adv_sgblk_t *sgblkp;
-	ADV_SCSI_REQ_Q *scsiqp;
-	struct scatterlist *slp;
-	int sg_elem_cnt;
-	ADV_SG_BLOCK *sg_block, *prev_sg_block;
-	ADV_PADDR sg_block_paddr;
-	int i;
-
-	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
-	slp = (struct scatterlist *)scp->request_buffer;
-	sg_elem_cnt = use_sg;
-	prev_sg_block = NULL;
-	reqp->sgblkp = NULL;
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	int chip_scsi_id;
 
-	for (;;) {
-		/*
-		 * Allocate a 'adv_sgblk_t' structure from the board free
-		 * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
-		 * (15) scatter-gather elements.
-		 */
-		if ((sgblkp = boardp->adv_sgblkp) == NULL) {
-			ASC_DBG(1, "adv_get_sglist: no free adv_sgblk_t\n");
-			ASC_STATS(scp->device->host, adv_build_nosg);
+	boardp = ASC_BOARDP(shost);
 
-			/*
-			 * Allocation failed. Free 'adv_sgblk_t' structures
-			 * already allocated for the request.
-			 */
-			while ((sgblkp = reqp->sgblkp) != NULL) {
-				/* Remove 'sgblkp' from the request list. */
-				reqp->sgblkp = sgblkp->next_sgblkp;
+	leftlen = cplen;
+	totlen = len = 0;
 
-				/* Add 'sgblkp' to the board free list. */
-				sgblkp->next_sgblkp = boardp->adv_sgblkp;
-				boardp->adv_sgblkp = sgblkp;
-			}
-			return ASC_BUSY;
-		}
+	len = asc_prt_line(cp, leftlen,
+			   "\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
 
-		/* Complete 'adv_sgblk_t' board allocation. */
-		boardp->adv_sgblkp = sgblkp->next_sgblkp;
-		sgblkp->next_sgblkp = NULL;
+	len = asc_prt_line(cp, leftlen,
+			   " host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
+			   shost->host_busy, shost->last_reset, shost->max_id,
+			   shost->max_lun, shost->max_channel);
+	ASC_PRT_NEXT();
 
-		/*
-		 * Get 8 byte aligned virtual and physical addresses
-		 * for the allocated ADV_SG_BLOCK structure.
-		 */
-		sg_block = (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);
-		sg_block_paddr = virt_to_bus(sg_block);
+	len = asc_prt_line(cp, leftlen,
+			   " unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
+			   shost->unique_id, shost->can_queue, shost->this_id,
+			   shost->sg_tablesize, shost->cmd_per_lun);
+	ASC_PRT_NEXT();
 
-		/*
-		 * Check if this is the first 'adv_sgblk_t' for the
-		 * request.
-		 */
-		if (reqp->sgblkp == NULL) {
-			/* Request's first scatter-gather block. */
-			reqp->sgblkp = sgblkp;
+	len = asc_prt_line(cp, leftlen,
+			   " unchecked_isa_dma %d, use_clustering %d\n",
+			   shost->unchecked_isa_dma, shost->use_clustering);
+	ASC_PRT_NEXT();
 
-			/*
-			 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
-			 * address pointers.
-			 */
-			scsiqp->sg_list_ptr = sg_block;
-			scsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);
-		} else {
-			/* Request's second or later scatter-gather block. */
-			sgblkp->next_sgblkp = reqp->sgblkp;
-			reqp->sgblkp = sgblkp;
-
-			/*
-			 * Point the previous ADV_SG_BLOCK structure to
-			 * the newly allocated ADV_SG_BLOCK structure.
-			 */
-			prev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);
-		}
+	len = asc_prt_line(cp, leftlen,
+			   " flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
+			   boardp->flags, boardp->last_reset, jiffies,
+			   boardp->asc_n_io_port);
+	ASC_PRT_NEXT();
 
-		for (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {
-			sg_block->sg_list[i].sg_addr =
-					cpu_to_le32(sg_dma_address(slp));
-			sg_block->sg_list[i].sg_count =
-					cpu_to_le32(sg_dma_len(slp));
-			ASC_STATS_ADD(scp->device->host, sg_xfer,
-				      ASC_CEILING(sg_dma_len(slp), 512));
+	len = asc_prt_line(cp, leftlen, " io_port 0x%x\n", shost->io_port);
+	ASC_PRT_NEXT();
 
-			if (--sg_elem_cnt == 0) {	/* Last ADV_SG_BLOCK and scatter-gather entry. */
-				sg_block->sg_cnt = i + 1;
-				sg_block->sg_ptr = 0L;	/* Last ADV_SG_BLOCK in list. */
-				return ADV_SUCCESS;
-			}
-			slp++;
-		}
-		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
-		prev_sg_block = sg_block;
+	if (ASC_NARROW_BOARD(boardp)) {
+		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+	} else {
+		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
 	}
+
+	return totlen;
 }
 
 /*
- * asc_isr_callback() - Second Level Interrupt Handler called by AscISR().
+ * asc_prt_asc_board_info()
  *
- * Interrupt callback function for the Narrow SCSI Asc Library.
+ * Print dynamic board configuration information.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
  */
-static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
+static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 {
 	asc_board_t *boardp;
-	struct scsi_cmnd *scp;
-	struct Scsi_Host *shost;
+	int chip_scsi_id;
+	int leftlen;
+	int totlen;
+	int len;
+	ASC_DVC_VAR *v;
+	ASC_DVC_CFG *c;
+	int i;
+	int renegotiate = 0;
 
-	ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
-		 (ulong)asc_dvc_varp, (ulong)qdonep);
-	ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
+	boardp = ASC_BOARDP(shost);
+	v = &boardp->dvc_var.asc_dvc_var;
+	c = &boardp->dvc_cfg.asc_dvc_cfg;
+	chip_scsi_id = c->chip_scsi_id;
 
-	/*
-	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
-	 * command that has been completed.
-	 */
-	scp = (struct scsi_cmnd *)ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
-	ASC_DBG1(1, "asc_isr_callback: scp 0x%lx\n", (ulong)scp);
+	leftlen = cplen;
+	totlen = len = 0;
 
-	if (scp == NULL) {
-		ASC_PRINT("asc_isr_callback: scp is NULL\n");
-		return;
-	}
-	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+	len = asc_prt_line(cp, leftlen,
+			   "\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
 
-	shost = scp->device->host;
-	ASC_STATS(shost, callback);
-	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
+	len = asc_prt_line(cp, leftlen,
+			   " chip_version %u, lib_version 0x%x, lib_serial_no %u, mcode_date 0x%x\n",
+			   c->chip_version, c->lib_version, c->lib_serial_no,
+			   c->mcode_date);
+	ASC_PRT_NEXT();
 
-	boardp = ASC_BOARDP(shost);
-	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
+	len = asc_prt_line(cp, leftlen,
+			   " mcode_version 0x%x, err_code %u\n",
+			   c->mcode_version, v->err_code);
+	ASC_PRT_NEXT();
 
-	/*
-	 * 'qdonep' contains the command's ending status.
-	 */
-	switch (qdonep->d3.done_stat) {
-	case QD_NO_ERROR:
-		ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
-		scp->result = 0;
+	/* Current number of commands waiting for the host. */
+	len = asc_prt_line(cp, leftlen,
+			   " Total Command Pending: %d\n", v->cur_total_qng);
+	ASC_PRT_NEXT();
 
-		/*
-		 * Check for an underrun condition.
-		 *
-		 * If there was no error and an underrun condition, then
-		 * return the number of underrun bytes.
-		 */
-		if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
-		    qdonep->remain_bytes <= scp->request_bufflen) {
-			ASC_DBG1(1,
-				 "asc_isr_callback: underrun condition %u bytes\n",
-				 (unsigned)qdonep->remain_bytes);
-			scp->resid = qdonep->remain_bytes;
+	len = asc_prt_line(cp, leftlen, " Command Queuing:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
 		}
-		break;
-
-	case QD_WITH_ERROR:
-		ASC_DBG(2, "asc_isr_callback: QD_WITH_ERROR\n");
-		switch (qdonep->d3.host_stat) {
-		case QHSTA_NO_ERROR:
-			if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
-				ASC_DBG(2,
-					"asc_isr_callback: SAM_STAT_CHECK_CONDITION\n");
-				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
-						  sizeof(scp->sense_buffer));
-				/*
-				 * Note: The 'status_byte()' macro used by
-				 * target drivers defined in scsi.h shifts the
-				 * status byte returned by host drivers right
-				 * by 1 bit.  This is why target drivers also
-				 * use right shifted status byte definitions.
-				 * For instance target drivers use
-				 * CHECK_CONDITION, defined to 0x1, instead of
-				 * the SCSI defined check condition value of
-				 * 0x2. Host drivers are supposed to return
-				 * the status byte as it is defined by SCSI.
-				 */
-				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
-				    STATUS_BYTE(qdonep->d3.scsi_stat);
-			} else {
-				scp->result = STATUS_BYTE(qdonep->d3.scsi_stat);
-			}
-			break;
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (v->
+				    use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ?
+				   'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-		default:
-			/* QHSTA error occurred */
-			ASC_DBG1(1, "asc_isr_callback: host_stat 0x%x\n",
-				 qdonep->d3.host_stat);
-			scp->result = HOST_BYTE(DID_BAD_TARGET);
-			break;
+	/* Current number of commands waiting for a device. */
+	len = asc_prt_line(cp, leftlen, " Command Queue Pending:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
 		}
-		break;
-
-	case QD_ABORTED_BY_HOST:
-		ASC_DBG(1, "asc_isr_callback: QD_ABORTED_BY_HOST\n");
-		scp->result =
-		    HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.
-						    scsi_msg) |
-		    STATUS_BYTE(qdonep->d3.scsi_stat);
-		break;
-
-	default:
-		ASC_DBG1(1, "asc_isr_callback: done_stat 0x%x\n",
-			 qdonep->d3.done_stat);
-		scp->result =
-		    HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.
-						    scsi_msg) |
-		    STATUS_BYTE(qdonep->d3.scsi_stat);
-		break;
+		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->cur_dvc_qng[i]);
+		ASC_PRT_NEXT();
 	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	/*
-	 * If the 'init_tidmask' bit isn't already set for the target and the
-	 * current request finished normally, then set the bit for the target
-	 * to indicate that a device is present.
-	 */
-	if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
-	    qdonep->d3.done_stat == QD_NO_ERROR &&
-	    qdonep->d3.host_stat == QHSTA_NO_ERROR) {
-		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+	/* Current limit on number of commands that can be sent to a device. */
+	len = asc_prt_line(cp, leftlen, " Command Queue Limit:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->max_dvc_qng[i]);
+		ASC_PRT_NEXT();
 	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	asc_scsi_done(scp);
-
-	return;
-}
+	/* Indicate whether the device has returned queue full status. */
+	len = asc_prt_line(cp, leftlen, " Command Queue Full:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		if (boardp->queue_full & ADV_TID_TO_TIDMASK(i)) {
+			len = asc_prt_line(cp, leftlen, " %X:Y-%d",
+					   i, boardp->queue_full_cnt[i]);
+		} else {
+			len = asc_prt_line(cp, leftlen, " %X:N", i);
+		}
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-/*
- * adv_isr_callback() - Second Level Interrupt Handler called by AdvISR().
- *
- * Callback function for the Wide SCSI Adv Library.
- */
-static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
-{
-	asc_board_t *boardp;
-	adv_req_t *reqp;
-	adv_sgblk_t *sgblkp;
-	struct scsi_cmnd *scp;
-	struct Scsi_Host *shost;
-	ADV_DCNT resid_cnt;
-
-	ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
-		 (ulong)adv_dvc_varp, (ulong)scsiqp);
-	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
-
-	/*
-	 * Get the adv_req_t structure for the command that has been
-	 * completed. The adv_req_t structure actually contains the
-	 * completed ADV_SCSI_REQ_Q structure.
-	 */
-	reqp = (adv_req_t *)ADV_U32_TO_VADDR(scsiqp->srb_ptr);
-	ASC_DBG1(1, "adv_isr_callback: reqp 0x%lx\n", (ulong)reqp);
-	if (reqp == NULL) {
-		ASC_PRINT("adv_isr_callback: reqp is NULL\n");
-		return;
-	}
-
-	/*
-	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
-	 * command that has been completed.
-	 *
-	 * Note: The adv_req_t request structure and adv_sgblk_t structure,
-	 * if any, are dropped, because a board structure pointer can not be
-	 * determined.
-	 */
-	scp = reqp->cmndp;
-	ASC_DBG1(1, "adv_isr_callback: scp 0x%lx\n", (ulong)scp);
-	if (scp == NULL) {
-		ASC_PRINT
-		    ("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");
-		return;
+	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (v->
+				    sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
 	}
-	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
-
-	shost = scp->device->host;
-	ASC_STATS(shost, callback);
-	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
-
-	boardp = ASC_BOARDP(shost);
-	BUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	/*
-	 * 'done_status' contains the command's ending status.
-	 */
-	switch (scsiqp->done_status) {
-	case QD_NO_ERROR:
-		ASC_DBG(2, "adv_isr_callback: QD_NO_ERROR\n");
-		scp->result = 0;
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		uchar syn_period_ix;
 
-		/*
-		 * Check for an underrun condition.
-		 *
-		 * If there was no error and an underrun condition, then
-		 * then return the number of underrun bytes.
-		 */
-		resid_cnt = le32_to_cpu(scsiqp->data_cnt);
-		if (scp->request_bufflen != 0 && resid_cnt != 0 &&
-		    resid_cnt <= scp->request_bufflen) {
-			ASC_DBG1(1,
-				 "adv_isr_callback: underrun condition %lu bytes\n",
-				 (ulong)resid_cnt);
-			scp->resid = resid_cnt;
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
+		    ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
 		}
-		break;
 
-	case QD_WITH_ERROR:
-		ASC_DBG(2, "adv_isr_callback: QD_WITH_ERROR\n");
-		switch (scsiqp->host_status) {
-		case QHSTA_NO_ERROR:
-			if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
-				ASC_DBG(2,
-					"adv_isr_callback: SAM_STAT_CHECK_CONDITION\n");
-				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
-						  sizeof(scp->sense_buffer));
-				/*
-				 * Note: The 'status_byte()' macro used by
-				 * target drivers defined in scsi.h shifts the
-				 * status byte returned by host drivers right
-				 * by 1 bit.  This is why target drivers also
-				 * use right shifted status byte definitions.
-				 * For instance target drivers use
-				 * CHECK_CONDITION, defined to 0x1, instead of
-				 * the SCSI defined check condition value of
-				 * 0x2. Host drivers are supposed to return
-				 * the status byte as it is defined by SCSI.
-				 */
-				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
-				    STATUS_BYTE(scsiqp->scsi_status);
-			} else {
-				scp->result = STATUS_BYTE(scsiqp->scsi_status);
-			}
-			break;
+		len = asc_prt_line(cp, leftlen, "  %X:", i);
+		ASC_PRT_NEXT();
 
-		default:
-			/* Some other QHSTA error occurred. */
-			ASC_DBG1(1, "adv_isr_callback: host_status 0x%x\n",
-				 scsiqp->host_status);
-			scp->result = HOST_BYTE(DID_BAD_TARGET);
-			break;
-		}
-		break;
+		if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {
+			len = asc_prt_line(cp, leftlen, " Asynchronous");
+			ASC_PRT_NEXT();
+		} else {
+			syn_period_ix =
+			    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -
+							   1);
 
-	case QD_ABORTED_BY_HOST:
-		ASC_DBG(1, "adv_isr_callback: QD_ABORTED_BY_HOST\n");
-		scp->result =
-		    HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);
-		break;
+			len = asc_prt_line(cp, leftlen,
+					   " Transfer Period Factor: %d (%d.%d Mhz),",
+					   v->sdtr_period_tbl[syn_period_ix],
+					   250 /
+					   v->sdtr_period_tbl[syn_period_ix],
+					   ASC_TENTHS(250,
+						      v->
+						      sdtr_period_tbl
+						      [syn_period_ix]));
+			ASC_PRT_NEXT();
 
-	default:
-		ASC_DBG1(1, "adv_isr_callback: done_status 0x%x\n",
-			 scsiqp->done_status);
-		scp->result =
-		    HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);
-		break;
-	}
+			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
+					   boardp->
+					   sdtr_data[i] & ASC_SYN_MAX_OFFSET);
+			ASC_PRT_NEXT();
+		}
 
-	/*
-	 * If the 'init_tidmask' bit isn't already set for the target and the
-	 * current request finished normally, then set the bit for the target
-	 * to indicate that a device is present.
-	 */
-	if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
-	    scsiqp->done_status == QD_NO_ERROR &&
-	    scsiqp->host_status == QHSTA_NO_ERROR) {
-		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+		if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+			len = asc_prt_line(cp, leftlen, "*\n");
+			renegotiate = 1;
+		} else {
+			len = asc_prt_line(cp, leftlen, "\n");
+		}
+		ASC_PRT_NEXT();
 	}
 
-	asc_scsi_done(scp);
-
-	/*
-	 * Free all 'adv_sgblk_t' structures allocated for the request.
-	 */
-	while ((sgblkp = reqp->sgblkp) != NULL) {
-		/* Remove 'sgblkp' from the request list. */
-		reqp->sgblkp = sgblkp->next_sgblkp;
-
-		/* Add 'sgblkp' to the board free list. */
-		sgblkp->next_sgblkp = boardp->adv_sgblkp;
-		boardp->adv_sgblkp = sgblkp;
+	if (renegotiate) {
+		len = asc_prt_line(cp, leftlen,
+				   " * = Re-negotiation pending before next command.\n");
+		ASC_PRT_NEXT();
 	}
 
-	/*
-	 * Free the adv_req_t structure used with the command by adding
-	 * it back to the board free list.
-	 */
-	reqp->next_reqp = boardp->adv_reqp;
-	boardp->adv_reqp = reqp;
-
-	ASC_DBG(1, "adv_isr_callback: done\n");
-
-	return;
-}
-
-/*
- * adv_async_callback() - Adv Library asynchronous event callback function.
- */
-static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
-{
-	switch (code) {
-	case ADV_ASYNC_SCSI_BUS_RESET_DET:
-		/*
-		 * The firmware detected a SCSI Bus reset.
-		 */
-		ASC_DBG(0,
-			"adv_async_callback: ADV_ASYNC_SCSI_BUS_RESET_DET\n");
-		break;
-
-	case ADV_ASYNC_RDMA_FAILURE:
-		/*
-		 * Handle RDMA failure by resetting the SCSI Bus and
-		 * possibly the chip if it is unresponsive. Log the error
-		 * with a unique code.
-		 */
-		ASC_DBG(0, "adv_async_callback: ADV_ASYNC_RDMA_FAILURE\n");
-		AdvResetChipAndSB(adv_dvc_varp);
-		break;
-
-	case ADV_HOST_SCSI_BUS_RESET:
-		/*
-		 * Host generated SCSI bus reset occurred.
-		 */
-		ASC_DBG(0, "adv_async_callback: ADV_HOST_SCSI_BUS_RESET\n");
-		break;
-
-	default:
-		ASC_DBG1(0, "DvcAsyncCallBack: unknown code 0x%x\n", code);
-		break;
-	}
+	return totlen;
 }
 
-#ifdef CONFIG_PROC_FS
 /*
- * asc_prt_board_devices()
+ * asc_prt_adv_board_info()
  *
- * Print driver information for devices attached to the board.
+ * Print dynamic board configuration information.
  *
  * Note: no single line should be greater than ASC_PRTLINE_SIZE,
  * cf. asc_prt_line().
@@ -4398,206 +3942,279 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
+static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 {
 	asc_board_t *boardp;
 	int leftlen;
 	int totlen;
 	int len;
-	int chip_scsi_id;
 	int i;
+	ADV_DVC_VAR *v;
+	ADV_DVC_CFG *c;
+	AdvPortAddr iop_base;
+	ushort chip_scsi_id;
+	ushort lramword;
+	uchar lrambyte;
+	ushort tagqng_able;
+	ushort sdtr_able, wdtr_able;
+	ushort wdtr_done, sdtr_done;
+	ushort period = 0;
+	int renegotiate = 0;
 
 	boardp = ASC_BOARDP(shost);
+	v = &boardp->dvc_var.adv_dvc_var;
+	c = &boardp->dvc_cfg.adv_dvc_cfg;
+	iop_base = v->iop_base;
+	chip_scsi_id = v->chip_scsi_id;
+
 	leftlen = cplen;
 	totlen = len = 0;
 
 	len = asc_prt_line(cp, leftlen,
-			   "\nDevice Information for AdvanSys SCSI Host %d:\n",
+			   "\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
 			   shost->host_no);
 	ASC_PRT_NEXT();
 
-	if (ASC_NARROW_BOARD(boardp)) {
-		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
-	} else {
-		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
-	}
+	len = asc_prt_line(cp, leftlen,
+			   " iop_base 0x%lx, cable_detect: %X, err_code %u\n",
+			   v->iop_base,
+			   AdvReadWordRegister(iop_base,
+					       IOPW_SCSI_CFG1) & CABLE_DETECT,
+			   v->err_code);
+	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, "Target IDs Detected:");
+	len = asc_prt_line(cp, leftlen,
+			   " chip_version %u, lib_version 0x%x, mcode_date 0x%x, mcode_version 0x%x\n",
+			   c->chip_version, c->lib_version, c->mcode_date,
+			   c->mcode_version);
+	ASC_PRT_NEXT();
+
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	len = asc_prt_line(cp, leftlen, " Queuing Enabled:");
 	ASC_PRT_NEXT();
 	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) {
-			len = asc_prt_line(cp, leftlen, " %X,", i);
-			ASC_PRT_NEXT();
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
 		}
+
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
 	}
-	len = asc_prt_line(cp, leftlen, " (%X=Host Adapter)\n", chip_scsi_id);
+	len = asc_prt_line(cp, leftlen, "\n");
 	ASC_PRT_NEXT();
 
-	return totlen;
-}
+	len = asc_prt_line(cp, leftlen, " Queue Limit:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
 
-/*
- * Display Wide Board BIOS Information.
- */
-static int asc_prt_adv_bios(struct Scsi_Host *shost, char *cp, int cplen)
-{
-	asc_board_t *boardp;
-	int leftlen;
-	int totlen;
-	int len;
-	ushort major, minor, letter;
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,
+				lrambyte);
 
-	boardp = ASC_BOARDP(shost);
-	leftlen = cplen;
-	totlen = len = 0;
+		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, "\nROM BIOS Version: ");
+	len = asc_prt_line(cp, leftlen, " Command Pending:");
 	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
 
-	/*
-	 * If the BIOS saved a valid signature, then fill in
-	 * the BIOS code segment base address.
-	 */
-	if (boardp->bios_signature != 0x55AA) {
-		len = asc_prt_line(cp, leftlen, "Disabled or Pre-3.1\n");
-		ASC_PRT_NEXT();
-		len = asc_prt_line(cp, leftlen,
-				   "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
-		ASC_PRT_NEXT();
-		len = asc_prt_line(cp, leftlen,
-				   "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
-		ASC_PRT_NEXT();
-	} else {
-		major = (boardp->bios_version >> 12) & 0xF;
-		minor = (boardp->bios_version >> 8) & 0xF;
-		letter = (boardp->bios_version & 0xFF);
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,
+				lrambyte);
 
-		len = asc_prt_line(cp, leftlen, "%d.%d%c\n",
-				   major, minor,
-				   letter >= 26 ? '?' : letter + 'A');
+		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
 		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-		/*
-		 * Current available ROM BIOS release is 3.1I for UW
-		 * and 3.2I for U2W. This code doesn't differentiate
-		 * UW and U2W boards.
-		 */
-		if (major < 3 || (major <= 3 && minor < 1) ||
-		    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {
-			len = asc_prt_line(cp, leftlen,
-					   "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
-			ASC_PRT_NEXT();
-			len = asc_prt_line(cp, leftlen,
-					   "ftp://ftp.connectcom.net/pub\n");
-			ASC_PRT_NEXT();
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	len = asc_prt_line(cp, leftlen, " Wide Enabled:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
 		}
+
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
 	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-	return totlen;
-}
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
+	len = asc_prt_line(cp, leftlen, " Transfer Bit Width:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
 
-/*
- * Add serial number to information bar if signature AAh
- * is found in at bit 15-9 (7 bits) of word 1.
- *
- * Serial Number consists fo 12 alpha-numeric digits.
- *
- *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)
- *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)
- *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)
- *       5 - Product revision (A-J)    Word0:  "         "
- *
- *           Signature                 Word1: 15-9 (7 bits)
- *       6 - Year (0-9)                Word1: 8-6 (3 bits) & Word2: 15 (1 bit)
- *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)
- *
- *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)
- *
- * Note 1: Only production cards will have a serial number.
- *
- * Note 2: Signature is most significant 7 bits (0xFE).
- *
- * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.
- */
-static int asc_get_eeprom_string(ushort *serialnum, uchar *cp)
-{
-	ushort w, num;
+		AdvReadWordLram(iop_base,
+				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
+				lramword);
 
-	if ((serialnum[1] & 0xFE00) != ((ushort)0xAA << 8)) {
-		return ASC_FALSE;
-	} else {
-		/*
-		 * First word - 6 digits.
-		 */
-		w = serialnum[0];
+		len = asc_prt_line(cp, leftlen, " %X:%d",
+				   i, (lramword & 0x8000) ? 16 : 8);
+		ASC_PRT_NEXT();
 
-		/* Product type - 1st digit. */
-		if ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {
-			/* Product type is P=Prototype */
-			*cp += 0x8;
+		if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
+		    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+			len = asc_prt_line(cp, leftlen, "*");
+			ASC_PRT_NEXT();
+			renegotiate = 1;
 		}
-		cp++;
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-		/* Manufacturing location - 2nd digit. */
-		*cp++ = 'A' + ((w & 0x1C00) >> 10);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	len = asc_prt_line(cp, leftlen, " Synchronous Enabled:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
 
-		/* Product ID - 3rd, 4th digits. */
-		num = w & 0x3FF;
-		*cp++ = '0' + (num / 100);
-		num %= 100;
-		*cp++ = '0' + (num / 10);
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-		/* Product revision - 5th digit. */
-		*cp++ = 'A' + (num % 10);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
+	for (i = 0; i <= ADV_MAX_TID; i++) {
 
-		/*
-		 * Second word
-		 */
-		w = serialnum[1];
+		AdvReadWordLram(iop_base,
+				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
+				lramword);
+		lramword &= ~0x8000;
 
-		/*
-		 * Year - 6th digit.
-		 *
-		 * If bit 15 of third word is set, then the
-		 * last digit of the year is greater than 7.
-		 */
-		if (serialnum[2] & 0x8000) {
-			*cp++ = '8' + ((w & 0x1C0) >> 6);
-		} else {
-			*cp++ = '0' + ((w & 0x1C0) >> 6);
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
+		    ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
 		}
 
-		/* Week of year - 7th, 8th digits. */
-		num = w & 0x003F;
-		*cp++ = '0' + num / 10;
-		num %= 10;
-		*cp++ = '0' + num;
-
-		/*
-		 * Third word
-		 */
-		w = serialnum[2] & 0x7FFF;
+		len = asc_prt_line(cp, leftlen, "  %X:", i);
+		ASC_PRT_NEXT();
 
-		/* Serial number - 9th digit. */
-		*cp++ = 'A' + (w / 1000);
+		if ((lramword & 0x1F) == 0) {	/* Check for REQ/ACK Offset 0. */
+			len = asc_prt_line(cp, leftlen, " Asynchronous");
+			ASC_PRT_NEXT();
+		} else {
+			len =
+			    asc_prt_line(cp, leftlen,
+					 " Transfer Period Factor: ");
+			ASC_PRT_NEXT();
 
-		/* 10th, 11th, 12th digits. */
-		num = w % 1000;
-		*cp++ = '0' + num / 100;
-		num %= 100;
-		*cp++ = '0' + num / 10;
-		num %= 10;
-		*cp++ = '0' + num;
+			if ((lramword & 0x1F00) == 0x1100) {	/* 80 Mhz */
+				len =
+				    asc_prt_line(cp, leftlen, "9 (80.0 Mhz),");
+				ASC_PRT_NEXT();
+			} else if ((lramword & 0x1F00) == 0x1000) {	/* 40 Mhz */
+				len =
+				    asc_prt_line(cp, leftlen, "10 (40.0 Mhz),");
+				ASC_PRT_NEXT();
+			} else {	/* 20 Mhz or below. */
 
-		*cp = '\0';	/* Null Terminate the string. */
-		return ASC_TRUE;
+				period = (((lramword >> 8) * 25) + 50) / 4;
+
+				if (period == 0) {	/* Should never happen. */
+					len =
+					    asc_prt_line(cp, leftlen,
+							 "%d (? Mhz), ");
+					ASC_PRT_NEXT();
+				} else {
+					len = asc_prt_line(cp, leftlen,
+							   "%d (%d.%d Mhz),",
+							   period, 250 / period,
+							   ASC_TENTHS(250,
+								      period));
+					ASC_PRT_NEXT();
+				}
+			}
+
+			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
+					   lramword & 0x1F);
+			ASC_PRT_NEXT();
+		}
+
+		if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+			len = asc_prt_line(cp, leftlen, "*\n");
+			renegotiate = 1;
+		} else {
+			len = asc_prt_line(cp, leftlen, "\n");
+		}
+		ASC_PRT_NEXT();
 	}
+
+	if (renegotiate) {
+		len = asc_prt_line(cp, leftlen,
+				   " * = Re-negotiation pending before next command.\n");
+		ASC_PRT_NEXT();
+	}
+
+	return totlen;
 }
 
 /*
- * asc_prt_asc_board_eeprom()
+ * asc_proc_copy()
  *
- * Print board EEPROM configuration.
+ * Copy proc information to a read buffer taking into account the current
+ * read offset in the file and the remaining space in the read buffer.
+ */
+static int
+asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
+	      char *cp, int cplen)
+{
+	int cnt = 0;
+
+	ASC_DBG3(2, "asc_proc_copy: offset %d, advoffset %d, cplen %d\n",
+		 (unsigned)offset, (unsigned)advoffset, cplen);
+	if (offset <= advoffset) {
+		/* Read offset below current offset, copy everything. */
+		cnt = min(cplen, leftlen);
+		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+			 (ulong)curbuf, (ulong)cp, cnt);
+		memcpy(curbuf, cp, cnt);
+	} else if (offset < advoffset + cplen) {
+		/* Read offset within current range, partial copy. */
+		cnt = (advoffset + cplen) - offset;
+		cp = (cp + cplen) - cnt;
+		cnt = min(cnt, leftlen);
+		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+			 (ulong)curbuf, (ulong)cp, cnt);
+		memcpy(curbuf, cp, cnt);
+	}
+	return cnt;
+}
+
+#ifdef ADVANSYS_STATS
+/*
+ * asc_prt_board_stats()
  *
  * Note: no single line should be greater than ASC_PRTLINE_SIZE,
  * cf. asc_prt_line().
@@ -4605,4673 +4222,864 @@ static int asc_get_eeprom_string(ushort *serialnum, uchar *cp)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
+static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
 {
-	asc_board_t *boardp;
-	ASC_DVC_VAR *asc_dvc_varp;
 	int leftlen;
 	int totlen;
 	int len;
-	ASCEEP_CONFIG *ep;
-	int i;
-#ifdef CONFIG_ISA
-	int isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };
-#endif /* CONFIG_ISA */
-	uchar serialstr[13];
-
-	boardp = ASC_BOARDP(shost);
-	asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-	ep = &boardp->eep_config.asc_eep;
+	struct asc_stats *s;
+	asc_board_t *boardp;
 
 	leftlen = cplen;
 	totlen = len = 0;
 
+	boardp = ASC_BOARDP(shost);
+	s = &boardp->asc_stats;
+
 	len = asc_prt_line(cp, leftlen,
-			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+			   "\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",
 			   shost->host_no);
 	ASC_PRT_NEXT();
 
-	if (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)
-	    == ASC_TRUE) {
-		len =
-		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
-				 serialstr);
-		ASC_PRT_NEXT();
-	} else {
-		if (ep->adapter_info[5] == 0xBB) {
-			len = asc_prt_line(cp, leftlen,
-					   " Default Settings Used for EEPROM-less Adapter.\n");
-			ASC_PRT_NEXT();
-		} else {
-			len = asc_prt_line(cp, leftlen,
-					   " Serial Number Signature Not Present.\n");
-			ASC_PRT_NEXT();
-		}
-	}
-
 	len = asc_prt_line(cp, leftlen,
-			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-			   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,
-			   ep->max_tag_qng);
+			   " queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
+			   s->queuecommand, s->reset, s->biosparam,
+			   s->interrupt);
 	ASC_PRT_NEXT();
 
 	len = asc_prt_line(cp, leftlen,
-			   " cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);
+			   " callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
+			   s->callback, s->done, s->build_error,
+			   s->adv_build_noreq, s->adv_build_nosg);
 	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, " Target ID:           ");
+	len = asc_prt_line(cp, leftlen,
+			   " exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
+			   s->exe_noerror, s->exe_busy, s->exe_error,
+			   s->exe_unknown);
 	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %d", i);
+
+	/*
+	 * Display data transfer statistics.
+	 */
+	if (s->cont_cnt > 0) {
+		len = asc_prt_line(cp, leftlen, " cont_cnt %lu, ", s->cont_cnt);
 		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
+		len = asc_prt_line(cp, leftlen, "cont_xfer %lu.%01lu kb ",
+				   s->cont_xfer / 2,
+				   ASC_TENTHS(s->cont_xfer, 2));
 		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
+		/* Contiguous transfer average size */
+		len = asc_prt_line(cp, leftlen, "avg_xfer %lu.%01lu kb\n",
+				   (s->cont_xfer / 2) / s->cont_cnt,
+				   ASC_TENTHS((s->cont_xfer / 2), s->cont_cnt));
 		ASC_PRT_NEXT();
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
+	if (s->sg_cnt > 0) {
+
+		len = asc_prt_line(cp, leftlen, " sg_cnt %lu, sg_elem %lu, ",
+				   s->sg_cnt, s->sg_elem);
 		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
 
-	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (ep->
-				    init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
+		len = asc_prt_line(cp, leftlen, "sg_xfer %lu.%01lu kb\n",
+				   s->sg_xfer / 2, ASC_TENTHS(s->sg_xfer, 2));
 		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
 
-#ifdef CONFIG_ISA
-	if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
-		len = asc_prt_line(cp, leftlen,
-				   " Host ISA DMA speed:   %d MB/S\n",
-				   isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
+		/* Scatter gather transfer statistics */
+		len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
+				   s->sg_elem / s->sg_cnt,
+				   ASC_TENTHS(s->sg_elem, s->sg_cnt));
+		ASC_PRT_NEXT();
+
+		len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
+				   (s->sg_xfer / 2) / s->sg_elem,
+				   ASC_TENTHS((s->sg_xfer / 2), s->sg_elem));
+		ASC_PRT_NEXT();
+
+		len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
+				   (s->sg_xfer / 2) / s->sg_cnt,
+				   ASC_TENTHS((s->sg_xfer / 2), s->sg_cnt));
 		ASC_PRT_NEXT();
 	}
-#endif /* CONFIG_ISA */
+
+	/*
+	 * Display request queuing statistics.
+	 */
+	len = asc_prt_line(cp, leftlen,
+			   " Active and Waiting Request Queues (Time Unit: %d HZ):\n",
+			   HZ);
+	ASC_PRT_NEXT();
 
 	return totlen;
 }
+#endif /* ADVANSYS_STATS */
 
 /*
- * asc_prt_adv_board_eeprom()
+ * advansys_proc_info() - /proc/scsi/advansys/{0,1,2,3,...}
  *
- * Print board EEPROM configuration.
+ * *buffer: I/O buffer
+ * **start: if inout == FALSE pointer into buffer where user read should start
+ * offset: current offset into a /proc/scsi/advansys/[0...] file
+ * length: length of buffer
+ * hostno: Scsi_Host host_no
+ * inout: TRUE - user is writing; FALSE - user is reading
  *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
+ * Return the number of bytes read from or written to a
+ * /proc/scsi/advansys/[0...] file.
  *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
+ * Note: This function uses the per board buffer 'prtbuf' which is
+ * allocated when the board is initialized in advansys_detect(). The
+ * buffer is ASC_PRTBUF_SIZE bytes. The function asc_proc_copy() is
+ * used to write to the buffer. The way asc_proc_copy() is written
+ * if 'prtbuf' is too small it will not be overwritten. Instead the
+ * user just won't get all the available statistics.
  */
-static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
+static int
+advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
+		   off_t offset, int length, int inout)
 {
 	asc_board_t *boardp;
-	ADV_DVC_VAR *adv_dvc_varp;
+	char *cp;
+	int cplen;
+	int cnt;
+	int totcnt;
 	int leftlen;
-	int totlen;
-	int len;
-	int i;
-	char *termstr;
-	uchar serialstr[13];
-	ADVEEP_3550_CONFIG *ep_3550 = NULL;
-	ADVEEP_38C0800_CONFIG *ep_38C0800 = NULL;
-	ADVEEP_38C1600_CONFIG *ep_38C1600 = NULL;
-	ushort word;
-	ushort *wordp;
-	ushort sdtr_speed = 0;
+	char *curbuf;
+	off_t advoffset;
 
-	boardp = ASC_BOARDP(shost);
-	adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		ep_3550 = &boardp->eep_config.adv_3550_eep;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
-	} else {
-		ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
+	ASC_DBG(1, "advansys_proc_info: begin\n");
+
+	/*
+	 * User write not supported.
+	 */
+	if (inout == TRUE) {
+		return (-ENOSYS);
 	}
 
-	leftlen = cplen;
-	totlen = len = 0;
+	/*
+	 * User read of /proc/scsi/advansys/[0...] file.
+	 */
 
-	len = asc_prt_line(cp, leftlen,
-			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	boardp = ASC_BOARDP(shost);
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		wordp = &ep_3550->serial_number_word1;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		wordp = &ep_38C0800->serial_number_word1;
-	} else {
-		wordp = &ep_38C1600->serial_number_word1;
+	/* Copy read data starting at the beginning of the buffer. */
+	*start = buffer;
+	curbuf = buffer;
+	advoffset = 0;
+	totcnt = 0;
+	leftlen = length;
+
+	/*
+	 * Get board configuration information.
+	 *
+	 * advansys_info() returns the board string from its own static buffer.
+	 */
+	cp = (char *)advansys_info(shost);
+	strcat(cp, "\n");
+	cplen = strlen(cp);
+	/* Copy board information. */
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
 	}
+	advoffset += cplen;
+	curbuf += cnt;
 
-	if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE) {
-		len =
-		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
-				 serialstr);
-		ASC_PRT_NEXT();
-	} else {
-		len = asc_prt_line(cp, leftlen,
-				   " Serial Number Signature Not Present.\n");
-		ASC_PRT_NEXT();
+	/*
+	 * Display Wide Board BIOS Information.
+	 */
+	if (ASC_WIDE_BOARD(boardp)) {
+		cp = boardp->prtbuf;
+		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
+		BUG_ON(cplen >= ASC_PRTBUF_SIZE);
+		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
+				  cplen);
+		totcnt += cnt;
+		leftlen -= cnt;
+		if (leftlen == 0) {
+			ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+			return totcnt;
+		}
+		advoffset += cplen;
+		curbuf += cnt;
 	}
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen,
-				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-				   ep_3550->adapter_scsi_id,
-				   ep_3550->max_host_qng, ep_3550->max_dvc_qng);
-		ASC_PRT_NEXT();
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		len = asc_prt_line(cp, leftlen,
-				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-				   ep_38C0800->adapter_scsi_id,
-				   ep_38C0800->max_host_qng,
-				   ep_38C0800->max_dvc_qng);
-		ASC_PRT_NEXT();
-	} else {
-		len = asc_prt_line(cp, leftlen,
-				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-				   ep_38C1600->adapter_scsi_id,
-				   ep_38C1600->max_host_qng,
-				   ep_38C1600->max_dvc_qng);
-		ASC_PRT_NEXT();
+	/*
+	 * Display driver information for each device attached to the board.
+	 */
+	cp = boardp->prtbuf;
+	cplen = asc_prt_board_devices(shost, cp, ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
 	}
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		word = ep_3550->termination;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		word = ep_38C0800->termination_lvd;
+	advoffset += cplen;
+	curbuf += cnt;
+
+	/*
+	 * Display EEPROM configuration for the board.
+	 */
+	cp = boardp->prtbuf;
+	if (ASC_NARROW_BOARD(boardp)) {
+		cplen = asc_prt_asc_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
 	} else {
-		word = ep_38C1600->termination_lvd;
+		cplen = asc_prt_adv_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
 	}
-	switch (word) {
-	case 1:
-		termstr = "Low Off/High Off";
-		break;
-	case 2:
-		termstr = "Low Off/High On";
-		break;
-	case 3:
-		termstr = "Low On/High On";
-		break;
-	default:
-	case 0:
-		termstr = "Automatic";
-		break;
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
 	}
+	advoffset += cplen;
+	curbuf += cnt;
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen,
-				   " termination: %u (%s), bios_ctrl: 0x%x\n",
-				   ep_3550->termination, termstr,
-				   ep_3550->bios_ctrl);
-		ASC_PRT_NEXT();
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		len = asc_prt_line(cp, leftlen,
-				   " termination: %u (%s), bios_ctrl: 0x%x\n",
-				   ep_38C0800->termination_lvd, termstr,
-				   ep_38C0800->bios_ctrl);
-		ASC_PRT_NEXT();
-	} else {
-		len = asc_prt_line(cp, leftlen,
-				   " termination: %u (%s), bios_ctrl: 0x%x\n",
-				   ep_38C1600->termination_lvd, termstr,
-				   ep_38C1600->bios_ctrl);
-		ASC_PRT_NEXT();
+	/*
+	 * Display driver configuration and information for the board.
+	 */
+	cp = boardp->prtbuf;
+	cplen = asc_prt_driver_conf(shost, cp, ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
 	}
+	advoffset += cplen;
+	curbuf += cnt;
 
-	len = asc_prt_line(cp, leftlen, " Target ID:           ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %X", i);
-		ASC_PRT_NEXT();
+#ifdef ADVANSYS_STATS
+	/*
+	 * Display driver statistics for the board.
+	 */
+	cp = boardp->prtbuf;
+	cplen = asc_prt_board_stats(shost, cp, ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	advoffset += cplen;
+	curbuf += cnt;
+#endif /* ADVANSYS_STATS */
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		word = ep_3550->disc_enable;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		word = ep_38C0800->disc_enable;
+	/*
+	 * Display Asc Library dynamic configuration information
+	 * for the board.
+	 */
+	cp = boardp->prtbuf;
+	if (ASC_NARROW_BOARD(boardp)) {
+		cplen = asc_prt_asc_board_info(shost, cp, ASC_PRTBUF_SIZE);
 	} else {
-		word = ep_38C1600->disc_enable;
+		cplen = asc_prt_adv_board_info(shost, cp, ASC_PRTBUF_SIZE);
 	}
-	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	advoffset += cplen;
+	curbuf += cnt;
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		word = ep_3550->tagqng_able;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		word = ep_38C0800->tagqng_able;
-	} else {
-		word = ep_38C1600->tagqng_able;
-	}
-	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		word = ep_3550->start_motor;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		word = ep_38C0800->start_motor;
+	return totcnt;
+}
+#endif /* CONFIG_PROC_FS */
+
+static void asc_scsi_done(struct scsi_cmnd *scp)
+{
+	struct asc_board *boardp = ASC_BOARDP(scp->device->host);
+
+	if (scp->use_sg)
+		dma_unmap_sg(boardp->dev,
+			     (struct scatterlist *)scp->request_buffer,
+			     scp->use_sg, scp->sc_data_direction);
+	else if (scp->request_bufflen)
+		dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
+				 scp->request_bufflen, scp->sc_data_direction);
+
+	ASC_STATS(scp->device->host, done);
+
+	scp->scsi_done(scp);
+}
+
+static void AscSetBank(PortAddr iop_base, uchar bank)
+{
+	uchar val;
+
+	val = AscGetChipControl(iop_base) &
+	    (~
+	     (CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET |
+	      CC_CHIP_RESET));
+	if (bank == 1) {
+		val |= CC_BANK_ONE;
+	} else if (bank == 2) {
+		val |= CC_DIAG | CC_BANK_ONE;
 	} else {
-		word = ep_38C1600->start_motor;
+		val &= ~CC_BANK_ONE;
 	}
-	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
+	AscSetChipControl(iop_base, val);
+	return;
+}
+
+static void AscSetChipIH(PortAddr iop_base, ushort ins_code)
+{
+	AscSetBank(iop_base, 1);
+	AscWriteChipIH(iop_base, ins_code);
+	AscSetBank(iop_base, 0);
+	return;
+}
+
+static int AscStartChip(PortAddr iop_base)
+{
+	AscSetChipControl(iop_base, 0);
+	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
+		return (0);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	return (1);
+}
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
-		ASC_PRT_NEXT();
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			len = asc_prt_line(cp, leftlen, " %c",
-					   (ep_3550->
-					    sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
-					   'Y' : 'N');
-			ASC_PRT_NEXT();
-		}
-		len = asc_prt_line(cp, leftlen, "\n");
-		ASC_PRT_NEXT();
+static int AscStopChip(PortAddr iop_base)
+{
+	uchar cc_val;
+
+	cc_val =
+	    AscGetChipControl(iop_base) &
+	    (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));
+	AscSetChipControl(iop_base, (uchar)(cc_val | CC_HALT));
+	AscSetChipIH(iop_base, INS_HALT);
+	AscSetChipIH(iop_base, INS_RFLAG_WTM);
+	if ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {
+		return (0);
 	}
+	return (1);
+}
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		len = asc_prt_line(cp, leftlen, " Ultra Transfer:      ");
-		ASC_PRT_NEXT();
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			len = asc_prt_line(cp, leftlen, " %c",
-					   (ep_3550->
-					    ultra_able & ADV_TID_TO_TIDMASK(i))
-					   ? 'Y' : 'N');
-			ASC_PRT_NEXT();
+static int AscIsChipHalted(PortAddr iop_base)
+{
+	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
+		if ((AscGetChipControl(iop_base) & CC_HALT) != 0) {
+			return (1);
 		}
-		len = asc_prt_line(cp, leftlen, "\n");
-		ASC_PRT_NEXT();
 	}
+	return (0);
+}
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-		word = ep_3550->wdtr_able;
-	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-		word = ep_38C0800->wdtr_able;
-	} else {
-		word = ep_38C1600->wdtr_able;
-	}
-	len = asc_prt_line(cp, leftlen, " Wide Transfer:       ");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		len = asc_prt_line(cp, leftlen, " %c",
-				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-		ASC_PRT_NEXT();
+static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
+{
+	PortAddr iop_base;
+	int i = 10;
+
+	iop_base = asc_dvc->iop_base;
+	while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)
+	       && (i-- > 0)) {
+		mdelay(100);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	AscStopChip(iop_base);
+	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);
+	udelay(60);
+	AscSetChipIH(iop_base, INS_RFLAG_WTM);
+	AscSetChipIH(iop_base, INS_HALT);
+	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);
+	AscSetChipControl(iop_base, CC_HALT);
+	mdelay(200);
+	AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+	AscSetChipStatus(iop_base, 0);
+	return (AscIsChipHalted(iop_base));
+}
 
-	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
-	    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {
-		len = asc_prt_line(cp, leftlen,
-				   " Synchronous Transfer Speed (Mhz):\n  ");
-		ASC_PRT_NEXT();
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			char *speed_str;
+static int AscFindSignature(PortAddr iop_base)
+{
+	ushort sig_word;
 
-			if (i == 0) {
-				sdtr_speed = adv_dvc_varp->sdtr_speed1;
-			} else if (i == 4) {
-				sdtr_speed = adv_dvc_varp->sdtr_speed2;
-			} else if (i == 8) {
-				sdtr_speed = adv_dvc_varp->sdtr_speed3;
-			} else if (i == 12) {
-				sdtr_speed = adv_dvc_varp->sdtr_speed4;
-			}
-			switch (sdtr_speed & ADV_MAX_TID) {
-			case 0:
-				speed_str = "Off";
-				break;
-			case 1:
-				speed_str = "  5";
-				break;
-			case 2:
-				speed_str = " 10";
-				break;
-			case 3:
-				speed_str = " 20";
-				break;
-			case 4:
-				speed_str = " 40";
-				break;
-			case 5:
-				speed_str = " 80";
-				break;
-			default:
-				speed_str = "Unk";
-				break;
-			}
-			len = asc_prt_line(cp, leftlen, "%X:%s ", i, speed_str);
-			ASC_PRT_NEXT();
-			if (i == 7) {
-				len = asc_prt_line(cp, leftlen, "\n  ");
-				ASC_PRT_NEXT();
-			}
-			sdtr_speed >>= 4;
+	ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureByte(0x%x) 0x%x\n",
+		 iop_base, AscGetChipSignatureByte(iop_base));
+	if (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {
+		ASC_DBG2(1,
+			 "AscFindSignature: AscGetChipSignatureWord(0x%x) 0x%x\n",
+			 iop_base, AscGetChipSignatureWord(iop_base));
+		sig_word = AscGetChipSignatureWord(iop_base);
+		if ((sig_word == (ushort)ASC_1000_ID0W) ||
+		    (sig_word == (ushort)ASC_1000_ID0W_FIX)) {
+			return (1);
 		}
-		len = asc_prt_line(cp, leftlen, "\n");
-		ASC_PRT_NEXT();
 	}
-
-	return totlen;
+	return (0);
 }
 
-/*
- * asc_prt_driver_conf()
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
- */
-static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
+static void AscEnableInterrupt(PortAddr iop_base)
 {
-	asc_board_t *boardp;
-	int leftlen;
-	int totlen;
-	int len;
-	int chip_scsi_id;
+	ushort cfg;
 
-	boardp = ASC_BOARDP(shost);
+	cfg = AscGetChipCfgLsw(iop_base);
+	AscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);
+	return;
+}
 
-	leftlen = cplen;
-	totlen = len = 0;
+static void AscDisableInterrupt(PortAddr iop_base)
+{
+	ushort cfg;
 
-	len = asc_prt_line(cp, leftlen,
-			   "\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	cfg = AscGetChipCfgLsw(iop_base);
+	AscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));
+	return;
+}
 
-	len = asc_prt_line(cp, leftlen,
-			   " host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
-			   shost->host_busy, shost->last_reset, shost->max_id,
-			   shost->max_lun, shost->max_channel);
-	ASC_PRT_NEXT();
+static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
+{
+	unsigned char byte_data;
+	unsigned short word_data;
 
-	len = asc_prt_line(cp, leftlen,
-			   " unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
-			   shost->unique_id, shost->can_queue, shost->this_id,
-			   shost->sg_tablesize, shost->cmd_per_lun);
-	ASC_PRT_NEXT();
+	if (isodd_word(addr)) {
+		AscSetChipLramAddr(iop_base, addr - 1);
+		word_data = AscGetChipLramData(iop_base);
+		byte_data = (word_data >> 8) & 0xFF;
+	} else {
+		AscSetChipLramAddr(iop_base, addr);
+		word_data = AscGetChipLramData(iop_base);
+		byte_data = word_data & 0xFF;
+	}
+	return byte_data;
+}
 
-	len = asc_prt_line(cp, leftlen,
-			   " unchecked_isa_dma %d, use_clustering %d\n",
-			   shost->unchecked_isa_dma, shost->use_clustering);
-	ASC_PRT_NEXT();
+static ushort AscReadLramWord(PortAddr iop_base, ushort addr)
+{
+	ushort word_data;
 
-	len = asc_prt_line(cp, leftlen,
-			   " flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
-			   boardp->flags, boardp->last_reset, jiffies,
-			   boardp->asc_n_io_port);
-	ASC_PRT_NEXT();
+	AscSetChipLramAddr(iop_base, addr);
+	word_data = AscGetChipLramData(iop_base);
+	return (word_data);
+}
 
-	len = asc_prt_line(cp, leftlen, " io_port 0x%x\n", shost->io_port);
-	ASC_PRT_NEXT();
+#if CC_VERY_LONG_SG_LIST
+static ASC_DCNT AscReadLramDWord(PortAddr iop_base, ushort addr)
+{
+	ushort val_low, val_high;
+	ASC_DCNT dword_data;
 
-	if (ASC_NARROW_BOARD(boardp)) {
-		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
-	} else {
-		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+	AscSetChipLramAddr(iop_base, addr);
+	val_low = AscGetChipLramData(iop_base);
+	val_high = AscGetChipLramData(iop_base);
+	dword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;
+	return (dword_data);
+}
+#endif /* CC_VERY_LONG_SG_LIST */
+
+static void
+AscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)
+{
+	int i;
+
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < words; i++) {
+		AscSetChipLramData(iop_base, set_wval);
 	}
+}
 
-	return totlen;
+static void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)
+{
+	AscSetChipLramAddr(iop_base, addr);
+	AscSetChipLramData(iop_base, word_val);
+	return;
+}
+
+static void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)
+{
+	ushort word_data;
+
+	if (isodd_word(addr)) {
+		addr--;
+		word_data = AscReadLramWord(iop_base, addr);
+		word_data &= 0x00FF;
+		word_data |= (((ushort)byte_val << 8) & 0xFF00);
+	} else {
+		word_data = AscReadLramWord(iop_base, addr);
+		word_data &= 0xFF00;
+		word_data |= ((ushort)byte_val & 0x00FF);
+	}
+	AscWriteLramWord(iop_base, addr, word_data);
+	return;
 }
 
 /*
- * asc_prt_asc_board_info()
- *
- * Print dynamic board configuration information.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
+ * Copy 2 bytes to LRAM.
  *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
+ * The source data is assumed to be in little-endian order in memory
+ * and is maintained in little-endian order when written to LRAM.
  */
-static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
+static void
+AscMemWordCopyPtrToLram(PortAddr iop_base,
+			ushort s_addr, uchar *s_buffer, int words)
 {
-	asc_board_t *boardp;
-	int chip_scsi_id;
-	int leftlen;
-	int totlen;
-	int len;
-	ASC_DVC_VAR *v;
-	ASC_DVC_CFG *c;
 	int i;
-	int renegotiate = 0;
-
-	boardp = ASC_BOARDP(shost);
-	v = &boardp->dvc_var.asc_dvc_var;
-	c = &boardp->dvc_cfg.asc_dvc_cfg;
-	chip_scsi_id = c->chip_scsi_id;
-
-	leftlen = cplen;
-	totlen = len = 0;
 
-	len = asc_prt_line(cp, leftlen,
-			   "\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		/*
+		 * On a little-endian system the second argument below
+		 * produces a little-endian ushort which is written to
+		 * LRAM in little-endian order. On a big-endian system
+		 * the second argument produces a big-endian ushort which
+		 * is "transparently" byte-swapped by outpw() and written
+		 * in little-endian order to LRAM.
+		 */
+		outpw(iop_base + IOP_RAM_DATA,
+		      ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);
+	}
+	return;
+}
 
-	len = asc_prt_line(cp, leftlen,
-			   " chip_version %u, lib_version 0x%x, lib_serial_no %u, mcode_date 0x%x\n",
-			   c->chip_version, c->lib_version, c->lib_serial_no,
-			   c->mcode_date);
-	ASC_PRT_NEXT();
+/*
+ * Copy 4 bytes to LRAM.
+ *
+ * The source data is assumed to be in little-endian order in memory
+ * and is maintained in little-endian order when writen to LRAM.
+ */
+static void
+AscMemDWordCopyPtrToLram(PortAddr iop_base,
+			 ushort s_addr, uchar *s_buffer, int dwords)
+{
+	int i;
 
-	len = asc_prt_line(cp, leftlen,
-			   " mcode_version 0x%x, err_code %u\n",
-			   c->mcode_version, v->err_code);
-	ASC_PRT_NEXT();
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 4 * dwords; i += 4) {
+		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);	/* LSW */
+		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);	/* MSW */
+	}
+	return;
+}
 
-	/* Current number of commands waiting for the host. */
-	len = asc_prt_line(cp, leftlen,
-			   " Total Command Pending: %d\n", v->cur_total_qng);
-	ASC_PRT_NEXT();
+/*
+ * Copy 2 bytes from LRAM.
+ *
+ * The source data is assumed to be in little-endian order in LRAM
+ * and is maintained in little-endian order when written to memory.
+ */
+static void
+AscMemWordCopyPtrFromLram(PortAddr iop_base,
+			  ushort s_addr, uchar *d_buffer, int words)
+{
+	int i;
+	ushort word;
 
-	len = asc_prt_line(cp, leftlen, " Command Queuing:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (v->
-				    use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ?
-				   'Y' : 'N');
-		ASC_PRT_NEXT();
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		word = inpw(iop_base + IOP_RAM_DATA);
+		d_buffer[i] = word & 0xff;
+		d_buffer[i + 1] = (word >> 8) & 0xff;
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	return;
+}
 
-	/* Current number of commands waiting for a device. */
-	len = asc_prt_line(cp, leftlen, " Command Queue Pending:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->cur_dvc_qng[i]);
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+static ASC_DCNT AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
+{
+	ASC_DCNT sum;
+	int i;
 
-	/* Current limit on number of commands that can be sent to a device. */
-	len = asc_prt_line(cp, leftlen, " Command Queue Limit:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->max_dvc_qng[i]);
-		ASC_PRT_NEXT();
+	sum = 0L;
+	for (i = 0; i < words; i++, s_addr += 2) {
+		sum += AscReadLramWord(iop_base, s_addr);
 	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	return (sum);
+}
 
-	/* Indicate whether the device has returned queue full status. */
-	len = asc_prt_line(cp, leftlen, " Command Queue Full:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-		if (boardp->queue_full & ADV_TID_TO_TIDMASK(i)) {
-			len = asc_prt_line(cp, leftlen, " %X:Y-%d",
-					   i, boardp->queue_full_cnt[i]);
-		} else {
-			len = asc_prt_line(cp, leftlen, " %X:N", i);
-		}
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (v->
-				    sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		uchar syn_period_ix;
-
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
-		    ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		len = asc_prt_line(cp, leftlen, "  %X:", i);
-		ASC_PRT_NEXT();
-
-		if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {
-			len = asc_prt_line(cp, leftlen, " Asynchronous");
-			ASC_PRT_NEXT();
-		} else {
-			syn_period_ix =
-			    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -
-							   1);
-
-			len = asc_prt_line(cp, leftlen,
-					   " Transfer Period Factor: %d (%d.%d Mhz),",
-					   v->sdtr_period_tbl[syn_period_ix],
-					   250 /
-					   v->sdtr_period_tbl[syn_period_ix],
-					   ASC_TENTHS(250,
-						      v->
-						      sdtr_period_tbl
-						      [syn_period_ix]));
-			ASC_PRT_NEXT();
-
-			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
-					   boardp->
-					   sdtr_data[i] & ASC_SYN_MAX_OFFSET);
-			ASC_PRT_NEXT();
-		}
+static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
+{
+	uchar i;
+	ushort s_addr;
+	PortAddr iop_base;
+	ushort warn_code;
 
-		if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			len = asc_prt_line(cp, leftlen, "*\n");
-			renegotiate = 1;
-		} else {
-			len = asc_prt_line(cp, leftlen, "\n");
-		}
-		ASC_PRT_NEXT();
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	AscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,
+			  (ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *
+				    64) >> 1));
+	i = ASC_MIN_ACTIVE_QNO;
+	s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
+			 (uchar)(i + 1));
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
+			 (uchar)(asc_dvc->max_total_qng));
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
+			 (uchar)i);
+	i++;
+	s_addr += ASC_QBLK_SIZE;
+	for (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {
+		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
+				 (uchar)(i + 1));
+		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
+				 (uchar)(i - 1));
+		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
+				 (uchar)i);
 	}
-
-	if (renegotiate) {
-		len = asc_prt_line(cp, leftlen,
-				   " * = Re-negotiation pending before next command.\n");
-		ASC_PRT_NEXT();
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
+			 (uchar)ASC_QLINK_END);
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
+			 (uchar)(asc_dvc->max_total_qng - 1));
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
+			 (uchar)asc_dvc->max_total_qng);
+	i++;
+	s_addr += ASC_QBLK_SIZE;
+	for (; i <= (uchar)(asc_dvc->max_total_qng + 3);
+	     i++, s_addr += ASC_QBLK_SIZE) {
+		AscWriteLramByte(iop_base,
+				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_FWD), i);
+		AscWriteLramByte(iop_base,
+				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_BWD), i);
+		AscWriteLramByte(iop_base,
+				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);
 	}
-
-	return totlen;
+	return warn_code;
 }
 
-/*
- * asc_prt_adv_board_info()
- *
- * Print dynamic board configuration information.
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
- */
-static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
+static ASC_DCNT
+AscLoadMicroCode(PortAddr iop_base,
+		 ushort s_addr, uchar *mcode_buf, ushort mcode_size)
 {
-	asc_board_t *boardp;
-	int leftlen;
-	int totlen;
-	int len;
-	int i;
-	ADV_DVC_VAR *v;
-	ADV_DVC_CFG *c;
-	AdvPortAddr iop_base;
-	ushort chip_scsi_id;
-	ushort lramword;
-	uchar lrambyte;
-	ushort tagqng_able;
-	ushort sdtr_able, wdtr_able;
-	ushort wdtr_done, sdtr_done;
-	ushort period = 0;
-	int renegotiate = 0;
-
-	boardp = ASC_BOARDP(shost);
-	v = &boardp->dvc_var.adv_dvc_var;
-	c = &boardp->dvc_cfg.adv_dvc_cfg;
-	iop_base = v->iop_base;
-	chip_scsi_id = v->chip_scsi_id;
-
-	leftlen = cplen;
-	totlen = len = 0;
-
-	len = asc_prt_line(cp, leftlen,
-			   "\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " iop_base 0x%lx, cable_detect: %X, err_code %u\n",
-			   v->iop_base,
-			   AdvReadWordRegister(iop_base,
-					       IOPW_SCSI_CFG1) & CABLE_DETECT,
-			   v->err_code);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " chip_version %u, lib_version 0x%x, mcode_date 0x%x, mcode_version 0x%x\n",
-			   c->chip_version, c->lib_version, c->mcode_date,
-			   c->mcode_version);
-	ASC_PRT_NEXT();
-
-	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	len = asc_prt_line(cp, leftlen, " Queuing Enabled:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen, " Queue Limit:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,
-				lrambyte);
-
-		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+	ASC_DCNT chksum;
+	ushort mcode_word_size;
+	ushort mcode_chksum;
 
-	len = asc_prt_line(cp, leftlen, " Command Pending:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
+	/* Write the microcode buffer starting at LRAM address 0. */
+	mcode_word_size = (ushort)(mcode_size >> 1);
+	AscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);
+	AscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);
 
-		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,
-				lrambyte);
+	chksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);
+	ASC_DBG1(1, "AscLoadMicroCode: chksum 0x%lx\n", (ulong)chksum);
+	mcode_chksum = (ushort)AscMemSumLramWord(iop_base,
+						 (ushort)ASC_CODE_SEC_BEG,
+						 (ushort)((mcode_size -
+							   s_addr - (ushort)
+							   ASC_CODE_SEC_BEG) /
+							  2));
+	ASC_DBG1(1, "AscLoadMicroCode: mcode_chksum 0x%lx\n",
+		 (ulong)mcode_chksum);
+	AscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);
+	AscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);
+	return (chksum);
+}
 
-		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	len = asc_prt_line(cp, leftlen, " Wide Enabled:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
-	len = asc_prt_line(cp, leftlen, " Transfer Bit Width:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		AdvReadWordLram(iop_base,
-				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
-				lramword);
-
-		len = asc_prt_line(cp, leftlen, " %X:%d",
-				   i, (lramword & 0x8000) ? 16 : 8);
-		ASC_PRT_NEXT();
-
-		if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
-		    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			len = asc_prt_line(cp, leftlen, "*");
-			ASC_PRT_NEXT();
-			renegotiate = 1;
-		}
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
+/* Microcode buffer is kept after initialization for error recovery. */
+static uchar _asc_mcode_buf[] = {
+	0x01, 0x03, 0x01, 0x19, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x12, 0x0D, 0x05,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xE4, 0x88, 0x00, 0x00, 0x00, 0x00, 0x80, 0x73, 0x48, 0x04,
+	0x36, 0x00, 0x00, 0xA2, 0xC2, 0x00, 0x80, 0x73, 0x03, 0x23, 0x36, 0x40,
+	0xB6, 0x00, 0x36, 0x00, 0x05, 0xD6, 0x0C, 0xD2, 0x12, 0xDA, 0x00, 0xA2,
+	0xC2, 0x00, 0x92, 0x80, 0x1E, 0x98, 0x50, 0x00, 0xF5, 0x00, 0x48, 0x98,
+	0xDF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x4F, 0x00, 0xF5, 0x00,
+	0x48, 0x98, 0xEF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x80, 0x62,
+	0x92, 0x80, 0x00, 0x46, 0x15, 0xEE, 0x13, 0xEA, 0x02, 0x01, 0x09, 0xD8,
+	0xCD, 0x04, 0x4D, 0x00, 0x00, 0xA3, 0xD6, 0x00, 0xA6, 0x97, 0x7F, 0x23,
+	0x04, 0x61, 0x84, 0x01, 0xE6, 0x84, 0xD2, 0xC1, 0x80, 0x73, 0xCD, 0x04,
+	0x4D, 0x00, 0x00, 0xA3, 0xDA, 0x01, 0xA6, 0x97, 0xC6, 0x81, 0xC2, 0x88,
+	0x80, 0x73, 0x80, 0x77, 0x00, 0x01, 0x01, 0xA1, 0xFE, 0x00, 0x4F, 0x00,
+	0x84, 0x97, 0x07, 0xA6, 0x08, 0x01, 0x00, 0x33, 0x03, 0x00, 0xC2, 0x88,
+	0x03, 0x03, 0x01, 0xDE, 0xC2, 0x88, 0xCE, 0x00, 0x69, 0x60, 0xCE, 0x00,
+	0x02, 0x03, 0x4A, 0x60, 0x00, 0xA2, 0x78, 0x01, 0x80, 0x63, 0x07, 0xA6,
+	0x24, 0x01, 0x78, 0x81, 0x03, 0x03, 0x80, 0x63, 0xE2, 0x00, 0x07, 0xA6,
+	0x34, 0x01, 0x00, 0x33, 0x04, 0x00, 0xC2, 0x88, 0x03, 0x07, 0x02, 0x01,
+	0x04, 0xCA, 0x0D, 0x23, 0x68, 0x98, 0x4D, 0x04, 0x04, 0x85, 0x05, 0xD8,
+	0x0D, 0x23, 0x68, 0x98, 0xCD, 0x04, 0x15, 0x23, 0xF8, 0x88, 0xFB, 0x23,
+	0x02, 0x61, 0x82, 0x01, 0x80, 0x63, 0x02, 0x03, 0x06, 0xA3, 0x62, 0x01,
+	0x00, 0x33, 0x0A, 0x00, 0xC2, 0x88, 0x4E, 0x00, 0x07, 0xA3, 0x6E, 0x01,
+	0x00, 0x33, 0x0B, 0x00, 0xC2, 0x88, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33,
+	0x1A, 0x00, 0xC2, 0x88, 0x50, 0x04, 0x88, 0x81, 0x06, 0xAB, 0x82, 0x01,
+	0x88, 0x81, 0x4E, 0x00, 0x07, 0xA3, 0x92, 0x01, 0x50, 0x00, 0x00, 0xA3,
+	0x3C, 0x01, 0x00, 0x05, 0x7C, 0x81, 0x46, 0x97, 0x02, 0x01, 0x05, 0xC6,
+	0x04, 0x23, 0xA0, 0x01, 0x15, 0x23, 0xA1, 0x01, 0xBE, 0x81, 0xFD, 0x23,
+	0x02, 0x61, 0x82, 0x01, 0x0A, 0xDA, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA0,
+	0xB4, 0x01, 0x80, 0x63, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33, 0x1B, 0x00,
+	0xC2, 0x88, 0x06, 0x23, 0x68, 0x98, 0xCD, 0x04, 0xE6, 0x84, 0x06, 0x01,
+	0x00, 0xA2, 0xD4, 0x01, 0x57, 0x60, 0x00, 0xA0, 0xDA, 0x01, 0xE6, 0x84,
+	0x80, 0x23, 0xA0, 0x01, 0xE6, 0x84, 0x80, 0x73, 0x4B, 0x00, 0x06, 0x61,
+	0x00, 0xA2, 0x00, 0x02, 0x04, 0x01, 0x0C, 0xDE, 0x02, 0x01, 0x03, 0xCC,
+	0x4F, 0x00, 0x84, 0x97, 0xFC, 0x81, 0x08, 0x23, 0x02, 0x41, 0x82, 0x01,
+	0x4F, 0x00, 0x62, 0x97, 0x48, 0x04, 0x84, 0x80, 0xF0, 0x97, 0x00, 0x46,
+	0x56, 0x00, 0x03, 0xC0, 0x01, 0x23, 0xE8, 0x00, 0x81, 0x73, 0x06, 0x29,
+	0x03, 0x42, 0x06, 0xE2, 0x03, 0xEE, 0x6B, 0xEB, 0x11, 0x23, 0xF8, 0x88,
+	0x04, 0x98, 0xF0, 0x80, 0x80, 0x73, 0x80, 0x77, 0x07, 0xA4, 0x2A, 0x02,
+	0x7C, 0x95, 0x06, 0xA6, 0x34, 0x02, 0x03, 0xA6, 0x4C, 0x04, 0x46, 0x82,
+	0x04, 0x01, 0x03, 0xD8, 0xB4, 0x98, 0x6A, 0x96, 0x46, 0x82, 0xFE, 0x95,
+	0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0xB6, 0x2D, 0x02, 0xA6, 0x6C, 0x02,
+	0x07, 0xA6, 0x5A, 0x02, 0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x62, 0x02,
+	0xC2, 0x88, 0x7C, 0x95, 0x48, 0x82, 0x60, 0x96, 0x48, 0x82, 0x04, 0x23,
+	0xA0, 0x01, 0x14, 0x23, 0xA1, 0x01, 0x3C, 0x84, 0x04, 0x01, 0x0C, 0xDC,
+	0xE0, 0x23, 0x25, 0x61, 0xEF, 0x00, 0x14, 0x01, 0x4F, 0x04, 0xA8, 0x01,
+	0x6F, 0x00, 0xA5, 0x01, 0x03, 0x23, 0xA4, 0x01, 0x06, 0x23, 0x9C, 0x01,
+	0x24, 0x2B, 0x1C, 0x01, 0x02, 0xA6, 0xAA, 0x02, 0x07, 0xA6, 0x5A, 0x02,
+	0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x20, 0x04, 0x01, 0xA6, 0xB4, 0x02,
+	0x00, 0xA6, 0xB4, 0x02, 0x00, 0x33, 0x12, 0x00, 0xC2, 0x88, 0x00, 0x0E,
+	0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0x8C, 0x02, 0x4D, 0x04, 0x04, 0x01,
+	0x0B, 0xDC, 0xE7, 0x23, 0x04, 0x61, 0x84, 0x01, 0x10, 0x31, 0x12, 0x35,
+	0x14, 0x01, 0xEC, 0x00, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0xEA, 0x82,
+	0x18, 0x23, 0x04, 0x61, 0x18, 0xA0, 0xE2, 0x02, 0x04, 0x01, 0xA2, 0xC8,
+	0x00, 0x33, 0x1F, 0x00, 0xC2, 0x88, 0x08, 0x31, 0x0A, 0x35, 0x0C, 0x39,
+	0x0E, 0x3D, 0x7E, 0x98, 0xB6, 0x2D, 0x01, 0xA6, 0x14, 0x03, 0x00, 0xA6,
+	0x14, 0x03, 0x07, 0xA6, 0x0C, 0x03, 0x06, 0xA6, 0x10, 0x03, 0x03, 0xA6,
+	0x20, 0x04, 0x02, 0xA6, 0x6C, 0x02, 0x00, 0x33, 0x33, 0x00, 0xC2, 0x88,
+	0x7C, 0x95, 0xEE, 0x82, 0x60, 0x96, 0xEE, 0x82, 0x82, 0x98, 0x80, 0x42,
+	0x7E, 0x98, 0x64, 0xE4, 0x04, 0x01, 0x2D, 0xC8, 0x31, 0x05, 0x07, 0x01,
+	0x00, 0xA2, 0x54, 0x03, 0x00, 0x43, 0x87, 0x01, 0x05, 0x05, 0x86, 0x98,
+	0x7E, 0x98, 0x00, 0xA6, 0x16, 0x03, 0x07, 0xA6, 0x4C, 0x03, 0x03, 0xA6,
+	0x3C, 0x04, 0x06, 0xA6, 0x50, 0x03, 0x01, 0xA6, 0x16, 0x03, 0x00, 0x33,
+	0x25, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x32, 0x83, 0x60, 0x96, 0x32, 0x83,
+	0x04, 0x01, 0x10, 0xCE, 0x07, 0xC8, 0x05, 0x05, 0xEB, 0x04, 0x00, 0x33,
+	0x00, 0x20, 0xC0, 0x20, 0x81, 0x62, 0x72, 0x83, 0x00, 0x01, 0x05, 0x05,
+	0xFF, 0xA2, 0x7A, 0x03, 0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x2E, 0x83,
+	0x05, 0x05, 0x15, 0x01, 0x00, 0xA2, 0x9A, 0x03, 0xEC, 0x00, 0x6E, 0x00,
+	0x95, 0x01, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0x01, 0xA6, 0x96, 0x03,
+	0x00, 0xA6, 0x96, 0x03, 0x10, 0x84, 0x80, 0x42, 0x7E, 0x98, 0x01, 0xA6,
+	0xA4, 0x03, 0x00, 0xA6, 0xBC, 0x03, 0x10, 0x84, 0xA8, 0x98, 0x80, 0x42,
+	0x01, 0xA6, 0xA4, 0x03, 0x07, 0xA6, 0xB2, 0x03, 0xD4, 0x83, 0x7C, 0x95,
+	0xA8, 0x83, 0x00, 0x33, 0x2F, 0x00, 0xC2, 0x88, 0xA8, 0x98, 0x80, 0x42,
+	0x00, 0xA6, 0xBC, 0x03, 0x07, 0xA6, 0xCA, 0x03, 0xD4, 0x83, 0x7C, 0x95,
+	0xC0, 0x83, 0x00, 0x33, 0x26, 0x00, 0xC2, 0x88, 0x38, 0x2B, 0x80, 0x32,
+	0x80, 0x36, 0x04, 0x23, 0xA0, 0x01, 0x12, 0x23, 0xA1, 0x01, 0x10, 0x84,
+	0x07, 0xF0, 0x06, 0xA4, 0xF4, 0x03, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23,
+	0x83, 0x03, 0x80, 0x63, 0x03, 0xA6, 0x0E, 0x04, 0x07, 0xA6, 0x06, 0x04,
+	0x06, 0xA6, 0x0A, 0x04, 0x00, 0x33, 0x17, 0x00, 0xC2, 0x88, 0x7C, 0x95,
+	0xF4, 0x83, 0x60, 0x96, 0xF4, 0x83, 0x20, 0x84, 0x07, 0xF0, 0x06, 0xA4,
+	0x20, 0x04, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23, 0x83, 0x03, 0x80, 0x63,
+	0xB6, 0x2D, 0x03, 0xA6, 0x3C, 0x04, 0x07, 0xA6, 0x34, 0x04, 0x06, 0xA6,
+	0x38, 0x04, 0x00, 0x33, 0x30, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x20, 0x84,
+	0x60, 0x96, 0x20, 0x84, 0x1D, 0x01, 0x06, 0xCC, 0x00, 0x33, 0x00, 0x84,
+	0xC0, 0x20, 0x00, 0x23, 0xEA, 0x00, 0x81, 0x62, 0xA2, 0x0D, 0x80, 0x63,
+	0x07, 0xA6, 0x5A, 0x04, 0x00, 0x33, 0x18, 0x00, 0xC2, 0x88, 0x03, 0x03,
+	0x80, 0x63, 0xA3, 0x01, 0x07, 0xA4, 0x64, 0x04, 0x23, 0x01, 0x00, 0xA2,
+	0x86, 0x04, 0x0A, 0xA0, 0x76, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1D, 0x00,
+	0xC2, 0x88, 0x0B, 0xA0, 0x82, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1E, 0x00,
+	0xC2, 0x88, 0x42, 0x23, 0xF8, 0x88, 0x00, 0x23, 0x22, 0xA3, 0xE6, 0x04,
+	0x08, 0x23, 0x22, 0xA3, 0xA2, 0x04, 0x28, 0x23, 0x22, 0xA3, 0xAE, 0x04,
+	0x02, 0x23, 0x22, 0xA3, 0xC4, 0x04, 0x42, 0x23, 0xF8, 0x88, 0x4A, 0x00,
+	0x06, 0x61, 0x00, 0xA0, 0xAE, 0x04, 0x45, 0x23, 0xF8, 0x88, 0x04, 0x98,
+	0x00, 0xA2, 0xC0, 0x04, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x82, 0xC0, 0x20,
+	0x81, 0x62, 0xE8, 0x81, 0x47, 0x23, 0xF8, 0x88, 0x04, 0x01, 0x0B, 0xDE,
+	0x04, 0x98, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x81, 0xC0, 0x20, 0x81, 0x62,
+	0x14, 0x01, 0x00, 0xA0, 0x00, 0x02, 0x43, 0x23, 0xF8, 0x88, 0x04, 0x23,
+	0xA0, 0x01, 0x44, 0x23, 0xA1, 0x01, 0x80, 0x73, 0x4D, 0x00, 0x03, 0xA3,
+	0xF4, 0x04, 0x00, 0x33, 0x27, 0x00, 0xC2, 0x88, 0x04, 0x01, 0x04, 0xDC,
+	0x02, 0x23, 0xA2, 0x01, 0x04, 0x23, 0xA0, 0x01, 0x04, 0x98, 0x26, 0x95,
+	0x4B, 0x00, 0xF6, 0x00, 0x4F, 0x04, 0x4F, 0x00, 0x00, 0xA3, 0x22, 0x05,
+	0x00, 0x05, 0x76, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x1C, 0x05, 0x0A, 0x85,
+	0x46, 0x97, 0xCD, 0x04, 0x24, 0x85, 0x48, 0x04, 0x84, 0x80, 0x02, 0x01,
+	0x03, 0xDA, 0x80, 0x23, 0x82, 0x01, 0x34, 0x85, 0x02, 0x23, 0xA0, 0x01,
+	0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x40, 0x05, 0x1D, 0x01, 0x04, 0xD6,
+	0xFF, 0x23, 0x86, 0x41, 0x4B, 0x60, 0xCB, 0x00, 0xFF, 0x23, 0x80, 0x01,
+	0x49, 0x00, 0x81, 0x01, 0x04, 0x01, 0x02, 0xC8, 0x30, 0x01, 0x80, 0x01,
+	0xF7, 0x04, 0x03, 0x01, 0x49, 0x04, 0x80, 0x01, 0xC9, 0x00, 0x00, 0x05,
+	0x00, 0x01, 0xFF, 0xA0, 0x60, 0x05, 0x77, 0x04, 0x01, 0x23, 0xEA, 0x00,
+	0x5D, 0x00, 0xFE, 0xC7, 0x00, 0x62, 0x00, 0x23, 0xEA, 0x00, 0x00, 0x63,
+	0x07, 0xA4, 0xF8, 0x05, 0x03, 0x03, 0x02, 0xA0, 0x8E, 0x05, 0xF4, 0x85,
+	0x00, 0x33, 0x2D, 0x00, 0xC2, 0x88, 0x04, 0xA0, 0xB8, 0x05, 0x80, 0x63,
+	0x00, 0x23, 0xDF, 0x00, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0xA4, 0x05,
+	0x1D, 0x01, 0x06, 0xD6, 0x02, 0x23, 0x02, 0x41, 0x82, 0x01, 0x50, 0x00,
+	0x62, 0x97, 0x04, 0x85, 0x04, 0x23, 0x02, 0x41, 0x82, 0x01, 0x04, 0x85,
+	0x08, 0xA0, 0xBE, 0x05, 0xF4, 0x85, 0x03, 0xA0, 0xC4, 0x05, 0xF4, 0x85,
+	0x01, 0xA0, 0xCE, 0x05, 0x88, 0x00, 0x80, 0x63, 0xCC, 0x86, 0x07, 0xA0,
+	0xEE, 0x05, 0x5F, 0x00, 0x00, 0x2B, 0xDF, 0x08, 0x00, 0xA2, 0xE6, 0x05,
+	0x80, 0x67, 0x80, 0x63, 0x01, 0xA2, 0x7A, 0x06, 0x7C, 0x85, 0x06, 0x23,
+	0x68, 0x98, 0x48, 0x23, 0xF8, 0x88, 0x07, 0x23, 0x80, 0x00, 0x06, 0x87,
+	0x80, 0x63, 0x7C, 0x85, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63, 0x4A, 0x00,
+	0x06, 0x61, 0x00, 0xA2, 0x36, 0x06, 0x1D, 0x01, 0x16, 0xD4, 0xC0, 0x23,
+	0x07, 0x41, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x1C, 0x06, 0x00, 0x33,
+	0x37, 0x00, 0xC2, 0x88, 0x1D, 0x01, 0x01, 0xD6, 0x20, 0x23, 0x63, 0x60,
+	0x83, 0x03, 0x80, 0x63, 0x02, 0x23, 0xDF, 0x00, 0x07, 0xA6, 0x7C, 0x05,
+	0xEF, 0x04, 0x6F, 0x00, 0x00, 0x63, 0x4B, 0x00, 0x06, 0x41, 0xCB, 0x00,
+	0x52, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x4E, 0x06, 0x1D, 0x01, 0x03, 0xCA,
+	0xC0, 0x23, 0x07, 0x41, 0x00, 0x63, 0x1D, 0x01, 0x04, 0xCC, 0x00, 0x33,
+	0x00, 0x83, 0xC0, 0x20, 0x81, 0x62, 0x80, 0x23, 0x07, 0x41, 0x00, 0x63,
+	0x80, 0x67, 0x08, 0x23, 0x83, 0x03, 0x80, 0x63, 0x00, 0x63, 0x01, 0x23,
+	0xDF, 0x00, 0x06, 0xA6, 0x84, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67,
+	0x80, 0x63, 0x00, 0x33, 0x00, 0x40, 0xC0, 0x20, 0x81, 0x62, 0x00, 0x63,
+	0x00, 0x00, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x94, 0x06,
+	0x07, 0xA6, 0x7C, 0x05, 0x00, 0x00, 0x01, 0xA0, 0x14, 0x07, 0x00, 0x2B,
+	0x40, 0x0E, 0x80, 0x63, 0x01, 0x00, 0x06, 0xA6, 0xAA, 0x06, 0x07, 0xA6,
+	0x7C, 0x05, 0x40, 0x0E, 0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0xA2, 0x06,
+	0x06, 0xA6, 0xBC, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67, 0x40, 0x0E,
+	0x80, 0x63, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63,
+	0x07, 0xA6, 0xD6, 0x06, 0x00, 0x33, 0x2A, 0x00, 0xC2, 0x88, 0x03, 0x03,
+	0x80, 0x63, 0x89, 0x00, 0x0A, 0x2B, 0x07, 0xA6, 0xE8, 0x06, 0x00, 0x33,
+	0x29, 0x00, 0xC2, 0x88, 0x00, 0x43, 0x00, 0xA2, 0xF4, 0x06, 0xC0, 0x0E,
+	0x80, 0x63, 0xDE, 0x86, 0xC0, 0x0E, 0x00, 0x33, 0x00, 0x80, 0xC0, 0x20,
+	0x81, 0x62, 0x04, 0x01, 0x02, 0xDA, 0x80, 0x63, 0x7C, 0x85, 0x80, 0x7B,
+	0x80, 0x63, 0x06, 0xA6, 0x8C, 0x06, 0x00, 0x33, 0x2C, 0x00, 0xC2, 0x88,
+	0x0C, 0xA2, 0x2E, 0x07, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6,
+	0x2C, 0x07, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x33, 0x3D, 0x00, 0xC2, 0x88,
+	0x00, 0x00, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0x0C, 0xA0, 0x44, 0x07,
+	0x07, 0xA6, 0x7C, 0x05, 0xBF, 0x23, 0x04, 0x61, 0x84, 0x01, 0xE6, 0x84,
+	0x00, 0x63, 0xF0, 0x04, 0x01, 0x01, 0xF1, 0x00, 0x00, 0x01, 0xF2, 0x00,
+	0x01, 0x05, 0x80, 0x01, 0x72, 0x04, 0x71, 0x00, 0x81, 0x01, 0x70, 0x04,
+	0x80, 0x05, 0x81, 0x05, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04,
+	0x01, 0x01, 0xF1, 0x00, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04, 0x71, 0x00,
+	0x81, 0x01, 0x72, 0x00, 0x80, 0x01, 0x71, 0x04, 0x70, 0x00, 0x80, 0x01,
+	0x70, 0x04, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x00, 0x01,
+	0xF1, 0x00, 0x70, 0x00, 0x80, 0x01, 0x70, 0x04, 0x71, 0x00, 0x80, 0x01,
+	0x72, 0x00, 0x81, 0x01, 0x71, 0x04, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04,
+	0x00, 0x63, 0x00, 0x23, 0xB3, 0x01, 0x83, 0x05, 0xA3, 0x01, 0xA2, 0x01,
+	0xA1, 0x01, 0x01, 0x23, 0xA0, 0x01, 0x00, 0x01, 0xC8, 0x00, 0x03, 0xA1,
+	0xC4, 0x07, 0x00, 0x33, 0x07, 0x00, 0xC2, 0x88, 0x80, 0x05, 0x81, 0x05,
+	0x04, 0x01, 0x11, 0xC8, 0x48, 0x00, 0xB0, 0x01, 0xB1, 0x01, 0x08, 0x23,
+	0xB2, 0x01, 0x05, 0x01, 0x48, 0x04, 0x00, 0x43, 0x00, 0xA2, 0xE4, 0x07,
+	0x00, 0x05, 0xDA, 0x87, 0x00, 0x01, 0xC8, 0x00, 0xFF, 0x23, 0x80, 0x01,
+	0x05, 0x05, 0x00, 0x63, 0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04,
+	0x00, 0x02, 0x80, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04, 0x00, 0x63,
+	0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04, 0x00, 0x02, 0x00, 0xA0,
+	0x14, 0x08, 0x16, 0x88, 0x00, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04,
+	0x00, 0x63, 0xF3, 0x04, 0x00, 0x23, 0xF4, 0x00, 0x74, 0x00, 0x80, 0x43,
+	0xF4, 0x00, 0xCF, 0x40, 0x00, 0xA2, 0x44, 0x08, 0x74, 0x04, 0x02, 0x01,
+	0xF7, 0xC9, 0xF6, 0xD9, 0x00, 0x01, 0x01, 0xA1, 0x24, 0x08, 0x04, 0x98,
+	0x26, 0x95, 0x24, 0x88, 0x73, 0x04, 0x00, 0x63, 0xF3, 0x04, 0x75, 0x04,
+	0x5A, 0x88, 0x02, 0x01, 0x04, 0xD8, 0x46, 0x97, 0x04, 0x98, 0x26, 0x95,
+	0x4A, 0x88, 0x75, 0x00, 0x00, 0xA3, 0x64, 0x08, 0x00, 0x05, 0x4E, 0x88,
+	0x73, 0x04, 0x00, 0x63, 0x80, 0x7B, 0x80, 0x63, 0x06, 0xA6, 0x76, 0x08,
+	0x00, 0x33, 0x3E, 0x00, 0xC2, 0x88, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63,
+	0x00, 0x63, 0x38, 0x2B, 0x9C, 0x88, 0x38, 0x2B, 0x92, 0x88, 0x32, 0x09,
+	0x31, 0x05, 0x92, 0x98, 0x05, 0x05, 0xB2, 0x09, 0x00, 0x63, 0x00, 0x32,
+	0x00, 0x36, 0x00, 0x3A, 0x00, 0x3E, 0x00, 0x63, 0x80, 0x32, 0x80, 0x36,
+	0x80, 0x3A, 0x80, 0x3E, 0xB4, 0x3D, 0x00, 0x63, 0x38, 0x2B, 0x40, 0x32,
+	0x40, 0x36, 0x40, 0x3A, 0x40, 0x3E, 0x00, 0x63, 0x5A, 0x20, 0xC9, 0x40,
+	0x00, 0xA0, 0xB4, 0x08, 0x5D, 0x00, 0xFE, 0xC3, 0x00, 0x63, 0x80, 0x73,
+	0xE6, 0x20, 0x02, 0x23, 0xE8, 0x00, 0x82, 0x73, 0xFF, 0xFD, 0x80, 0x73,
+	0x13, 0x23, 0xF8, 0x88, 0x66, 0x20, 0xC0, 0x20, 0x04, 0x23, 0xA0, 0x01,
+	0xA1, 0x23, 0xA1, 0x01, 0x81, 0x62, 0xE2, 0x88, 0x80, 0x73, 0x80, 0x77,
+	0x68, 0x00, 0x00, 0xA2, 0x80, 0x00, 0x03, 0xC2, 0xF1, 0xC7, 0x41, 0x23,
+	0xF8, 0x88, 0x11, 0x23, 0xA1, 0x01, 0x04, 0x23, 0xA0, 0x01, 0xE6, 0x84,
+};
 
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	len = asc_prt_line(cp, leftlen, " Synchronous Enabled:");
-	ASC_PRT_NEXT();
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		len = asc_prt_line(cp, leftlen, " %X:%c",
-				   i,
-				   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
-				   'N');
-		ASC_PRT_NEXT();
-	}
-	len = asc_prt_line(cp, leftlen, "\n");
-	ASC_PRT_NEXT();
-
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
-	for (i = 0; i <= ADV_MAX_TID; i++) {
-
-		AdvReadWordLram(iop_base,
-				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
-				lramword);
-		lramword &= ~0x8000;
-
-		if ((chip_scsi_id == i) ||
-		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
-		    ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {
-			continue;
-		}
-
-		len = asc_prt_line(cp, leftlen, "  %X:", i);
-		ASC_PRT_NEXT();
-
-		if ((lramword & 0x1F) == 0) {	/* Check for REQ/ACK Offset 0. */
-			len = asc_prt_line(cp, leftlen, " Asynchronous");
-			ASC_PRT_NEXT();
-		} else {
-			len =
-			    asc_prt_line(cp, leftlen,
-					 " Transfer Period Factor: ");
-			ASC_PRT_NEXT();
-
-			if ((lramword & 0x1F00) == 0x1100) {	/* 80 Mhz */
-				len =
-				    asc_prt_line(cp, leftlen, "9 (80.0 Mhz),");
-				ASC_PRT_NEXT();
-			} else if ((lramword & 0x1F00) == 0x1000) {	/* 40 Mhz */
-				len =
-				    asc_prt_line(cp, leftlen, "10 (40.0 Mhz),");
-				ASC_PRT_NEXT();
-			} else {	/* 20 Mhz or below. */
-
-				period = (((lramword >> 8) * 25) + 50) / 4;
-
-				if (period == 0) {	/* Should never happen. */
-					len =
-					    asc_prt_line(cp, leftlen,
-							 "%d (? Mhz), ");
-					ASC_PRT_NEXT();
-				} else {
-					len = asc_prt_line(cp, leftlen,
-							   "%d (%d.%d Mhz),",
-							   period, 250 / period,
-							   ASC_TENTHS(250,
-								      period));
-					ASC_PRT_NEXT();
-				}
-			}
-
-			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
-					   lramword & 0x1F);
-			ASC_PRT_NEXT();
-		}
-
-		if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-			len = asc_prt_line(cp, leftlen, "*\n");
-			renegotiate = 1;
-		} else {
-			len = asc_prt_line(cp, leftlen, "\n");
-		}
-		ASC_PRT_NEXT();
-	}
-
-	if (renegotiate) {
-		len = asc_prt_line(cp, leftlen,
-				   " * = Re-negotiation pending before next command.\n");
-		ASC_PRT_NEXT();
-	}
-
-	return totlen;
-}
-
-/*
- * asc_proc_copy()
- *
- * Copy proc information to a read buffer taking into account the current
- * read offset in the file and the remaining space in the read buffer.
- */
-static int
-asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
-	      char *cp, int cplen)
-{
-	int cnt = 0;
-
-	ASC_DBG3(2, "asc_proc_copy: offset %d, advoffset %d, cplen %d\n",
-		 (unsigned)offset, (unsigned)advoffset, cplen);
-	if (offset <= advoffset) {
-		/* Read offset below current offset, copy everything. */
-		cnt = min(cplen, leftlen);
-		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
-			 (ulong)curbuf, (ulong)cp, cnt);
-		memcpy(curbuf, cp, cnt);
-	} else if (offset < advoffset + cplen) {
-		/* Read offset within current range, partial copy. */
-		cnt = (advoffset + cplen) - offset;
-		cp = (cp + cplen) - cnt;
-		cnt = min(cnt, leftlen);
-		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
-			 (ulong)curbuf, (ulong)cp, cnt);
-		memcpy(curbuf, cp, cnt);
-	}
-	return cnt;
-}
-
-/*
- * asc_prt_line()
- *
- * If 'cp' is NULL print to the console, otherwise print to a buffer.
- *
- * Return 0 if printing to the console, otherwise return the number of
- * bytes written to the buffer.
- *
- * Note: If any single line is greater than ASC_PRTLINE_SIZE bytes the stack
- * will be corrupted. 's[]' is defined to be ASC_PRTLINE_SIZE bytes.
- */
-static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
-{
-	va_list args;
-	int ret;
-	char s[ASC_PRTLINE_SIZE];
-
-	va_start(args, fmt);
-	ret = vsprintf(s, fmt, args);
-	BUG_ON(ret >= ASC_PRTLINE_SIZE);
-	if (buf == NULL) {
-		(void)printk(s);
-		ret = 0;
-	} else {
-		ret = min(buflen, ret);
-		memcpy(buf, s, ret);
-	}
-	va_end(args);
-	return ret;
-}
-#endif /* CONFIG_PROC_FS */
-
-/*
- * void
- * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
- *
- * Calling/Exit State:
- *    none
- *
- * Description:
- *     Output an ASC_SCSI_Q structure to the chip
- */
-static void
-DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
-{
-	int i;
-
-	ASC_DBG_PRT_HEX(2, "DvcPutScsiQ", outbuf, 2 * words);
-	AscSetChipLramAddr(iop_base, s_addr);
-	for (i = 0; i < 2 * words; i += 2) {
-		if (i == 4 || i == 20) {
-			continue;
-		}
-		outpw(iop_base + IOP_RAM_DATA,
-		      ((ushort)outbuf[i + 1] << 8) | outbuf[i]);
-	}
-}
-
-/*
- * void
- * DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
- *
- * Calling/Exit State:
- *    none
- *
- * Description:
- *     Input an ASC_QDONE_INFO structure from the chip
- */
-static void
-DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
-{
-	int i;
-	ushort word;
-
-	AscSetChipLramAddr(iop_base, s_addr);
-	for (i = 0; i < 2 * words; i += 2) {
-		if (i == 10) {
-			continue;
-		}
-		word = inpw(iop_base + IOP_RAM_DATA);
-		inbuf[i] = word & 0xff;
-		inbuf[i + 1] = (word >> 8) & 0xff;
-	}
-	ASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);
-}
-
-/*
- * Return the BIOS address of the adapter at the specified
- * I/O port and with the specified bus type.
- */
-static unsigned short __devinit
-AscGetChipBiosAddress(PortAddr iop_base, unsigned short bus_type)
-{
-	unsigned short cfg_lsw;
-	unsigned short bios_addr;
-
-	/*
-	 * The PCI BIOS is re-located by the motherboard BIOS. Because
-	 * of this the driver can not determine where a PCI BIOS is
-	 * loaded and executes.
-	 */
-	if (bus_type & ASC_IS_PCI)
-		return 0;
-
-#ifdef CONFIG_ISA
-	if ((bus_type & ASC_IS_EISA) != 0) {
-		cfg_lsw = AscGetEisaChipCfg(iop_base);
-		cfg_lsw &= 0x000F;
-		bios_addr = ASC_BIOS_MIN_ADDR + cfg_lsw * ASC_BIOS_BANK_SIZE;
-		return bios_addr;
-	}
-#endif /* CONFIG_ISA */
-
-	cfg_lsw = AscGetChipCfgLsw(iop_base);
-
-	/*
-	 *  ISA PnP uses the top bit as the 32K BIOS flag
-	 */
-	if (bus_type == ASC_IS_ISAPNP)
-		cfg_lsw &= 0x7FFF;
-	bios_addr = ASC_BIOS_MIN_ADDR + (cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE;
-	return bios_addr;
-}
-
-/*
- * DvcGetPhyAddr()
- *
- * Return the physical address of 'vaddr' and set '*lenp' to the
- * number of physically contiguous bytes that follow 'vaddr'.
- * 'flag' indicates the type of structure whose physical address
- * is being translated.
- *
- * Note: Because Linux currently doesn't page the kernel and all
- * kernel buffers are physically contiguous, leave '*lenp' unchanged.
- */
-ADV_PADDR
-DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
-	      uchar *vaddr, ADV_SDCNT *lenp, int flag)
-{
-	ADV_PADDR paddr;
-
-	paddr = virt_to_bus(vaddr);
-
-	ASC_DBG4(4,
-		 "DvcGetPhyAddr: vaddr 0x%lx, lenp 0x%lx *lenp %lu, paddr 0x%lx\n",
-		 (ulong)vaddr, (ulong)lenp, (ulong)*((ulong *)lenp),
-		 (ulong)paddr);
-
-	return paddr;
-}
-
-#ifdef ADVANSYS_STATS
-#ifdef CONFIG_PROC_FS
-/*
- * asc_prt_board_stats()
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
- */
-static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
-{
-	int leftlen;
-	int totlen;
-	int len;
-	struct asc_stats *s;
-	asc_board_t *boardp;
-
-	leftlen = cplen;
-	totlen = len = 0;
-
-	boardp = ASC_BOARDP(shost);
-	s = &boardp->asc_stats;
-
-	len = asc_prt_line(cp, leftlen,
-			   "\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",
-			   shost->host_no);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
-			   s->queuecommand, s->reset, s->biosparam,
-			   s->interrupt);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
-			   s->callback, s->done, s->build_error,
-			   s->adv_build_noreq, s->adv_build_nosg);
-	ASC_PRT_NEXT();
-
-	len = asc_prt_line(cp, leftlen,
-			   " exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
-			   s->exe_noerror, s->exe_busy, s->exe_error,
-			   s->exe_unknown);
-	ASC_PRT_NEXT();
-
-	/*
-	 * Display data transfer statistics.
-	 */
-	if (s->cont_cnt > 0) {
-		len = asc_prt_line(cp, leftlen, " cont_cnt %lu, ", s->cont_cnt);
-		ASC_PRT_NEXT();
-
-		len = asc_prt_line(cp, leftlen, "cont_xfer %lu.%01lu kb ",
-				   s->cont_xfer / 2,
-				   ASC_TENTHS(s->cont_xfer, 2));
-		ASC_PRT_NEXT();
-
-		/* Contiguous transfer average size */
-		len = asc_prt_line(cp, leftlen, "avg_xfer %lu.%01lu kb\n",
-				   (s->cont_xfer / 2) / s->cont_cnt,
-				   ASC_TENTHS((s->cont_xfer / 2), s->cont_cnt));
-		ASC_PRT_NEXT();
-	}
-
-	if (s->sg_cnt > 0) {
-
-		len = asc_prt_line(cp, leftlen, " sg_cnt %lu, sg_elem %lu, ",
-				   s->sg_cnt, s->sg_elem);
-		ASC_PRT_NEXT();
-
-		len = asc_prt_line(cp, leftlen, "sg_xfer %lu.%01lu kb\n",
-				   s->sg_xfer / 2, ASC_TENTHS(s->sg_xfer, 2));
-		ASC_PRT_NEXT();
-
-		/* Scatter gather transfer statistics */
-		len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
-				   s->sg_elem / s->sg_cnt,
-				   ASC_TENTHS(s->sg_elem, s->sg_cnt));
-		ASC_PRT_NEXT();
-
-		len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
-				   (s->sg_xfer / 2) / s->sg_elem,
-				   ASC_TENTHS((s->sg_xfer / 2), s->sg_elem));
-		ASC_PRT_NEXT();
-
-		len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
-				   (s->sg_xfer / 2) / s->sg_cnt,
-				   ASC_TENTHS((s->sg_xfer / 2), s->sg_cnt));
-		ASC_PRT_NEXT();
-	}
-
-	/*
-	 * Display request queuing statistics.
-	 */
-	len = asc_prt_line(cp, leftlen,
-			   " Active and Waiting Request Queues (Time Unit: %d HZ):\n",
-			   HZ);
-	ASC_PRT_NEXT();
-
-	return totlen;
-}
-#endif /* CONFIG_PROC_FS */
-#endif /* ADVANSYS_STATS */
-
-#ifdef ADVANSYS_DEBUG
-/*
- * asc_prt_scsi_host()
- */
-static void asc_prt_scsi_host(struct Scsi_Host *s)
-{
-	asc_board_t *boardp;
-
-	boardp = ASC_BOARDP(s);
-
-	printk("Scsi_Host at addr 0x%lx\n", (ulong)s);
-	printk(" host_busy %u, host_no %d, last_reset %d,\n",
-	       s->host_busy, s->host_no, (unsigned)s->last_reset);
-
-	printk(" base 0x%lx, io_port 0x%lx, irq 0x%x,\n",
-	       (ulong)s->base, (ulong)s->io_port, s->irq);
-
-	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
-	       s->dma_channel, s->this_id, s->can_queue);
-
-	printk(" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
-	       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
-
-	if (ASC_NARROW_BOARD(boardp)) {
-		asc_prt_asc_dvc_var(&ASC_BOARDP(s)->dvc_var.asc_dvc_var);
-		asc_prt_asc_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.asc_dvc_cfg);
-	} else {
-		asc_prt_adv_dvc_var(&ASC_BOARDP(s)->dvc_var.adv_dvc_var);
-		asc_prt_adv_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.adv_dvc_cfg);
-	}
-}
-
-/*
- * asc_prt_scsi_cmnd()
- */
-static void asc_prt_scsi_cmnd(struct scsi_cmnd *s)
-{
-	printk("struct scsi_cmnd at addr 0x%lx\n", (ulong)s);
-
-	printk(" host 0x%lx, device 0x%lx, target %u, lun %u, channel %u,\n",
-	       (ulong)s->device->host, (ulong)s->device, s->device->id,
-	       s->device->lun, s->device->channel);
-
-	asc_prt_hex(" CDB", s->cmnd, s->cmd_len);
-
-	printk("sc_data_direction %u, resid %d\n",
-	       s->sc_data_direction, s->resid);
-
-	printk(" use_sg %u, sglist_len %u\n", s->use_sg, s->sglist_len);
-
-	printk(" serial_number 0x%x, retries %d, allowed %d\n",
-	       (unsigned)s->serial_number, s->retries, s->allowed);
-
-	printk(" timeout_per_command %d\n", s->timeout_per_command);
-
-	printk(" scsi_done 0x%p, done 0x%p, host_scribble 0x%p, result 0x%x\n",
-		s->scsi_done, s->done, s->host_scribble, s->result);
-
-	printk(" tag %u, pid %u\n", (unsigned)s->tag, (unsigned)s->pid);
-}
-
-/*
- * asc_prt_asc_dvc_var()
- */
-static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
-{
-	printk("ASC_DVC_VAR at addr 0x%lx\n", (ulong)h);
-
-	printk(" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl "
-	       "%d,\n", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
-
-	printk(" bus_type %d, init_sdtr 0x%x,\n", h->bus_type,
-		(unsigned)h->init_sdtr);
-
-	printk(" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, "
-	       "chip_no 0x%x,\n", (unsigned)h->sdtr_done,
-	       (unsigned)h->use_tagged_qng, (unsigned)h->unit_not_ready,
-	       (unsigned)h->chip_no);
-
-	printk(" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait "
-	       "%u,\n", (unsigned)h->queue_full_or_busy,
-	       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);
-
-	printk(" is_in_int %u, max_total_qng %u, cur_total_qng %u, "
-	       "in_critical_cnt %u,\n", (unsigned)h->is_in_int,
-	       (unsigned)h->max_total_qng, (unsigned)h->cur_total_qng,
-	       (unsigned)h->in_critical_cnt);
-
-	printk(" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, "
-	       "pci_fix_asyn_xfer 0x%x,\n", (unsigned)h->last_q_shortage,
-	       (unsigned)h->init_state, (unsigned)h->no_scam,
-	       (unsigned)h->pci_fix_asyn_xfer);
-
-	printk(" cfg 0x%lx, irq_no 0x%x\n", (ulong)h->cfg, (unsigned)h->irq_no);
-}
-
-/*
- * asc_prt_asc_dvc_cfg()
- */
-static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
-{
-	printk("ASC_DVC_CFG at addr 0x%lx\n", (ulong)h);
-
-	printk(" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\n",
-	       h->can_tagged_qng, h->cmd_qng_enabled);
-	printk(" disc_enable 0x%x, sdtr_enable 0x%x,\n",
-	       h->disc_enable, h->sdtr_enable);
-
-	printk
-	    (" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, chip_version %d,\n",
-	     h->chip_scsi_id, h->isa_dma_speed, h->isa_dma_channel,
-	     h->chip_version);
-
-	printk
-	    (" pci_device_id %d, lib_serial_no %u, lib_version %u, mcode_date 0x%x,\n",
-	     to_pci_dev(h->dev)->device, h->lib_serial_no, h->lib_version,
-	     h->mcode_date);
-
-	printk(" mcode_version %d, overrun_buf 0x%lx\n",
-	       h->mcode_version, (ulong)h->overrun_buf);
-}
-
-/*
- * asc_prt_asc_scsi_q()
- */
-static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
-{
-	ASC_SG_HEAD *sgp;
-	int i;
-
-	printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);
-
-	printk
-	    (" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
-	     q->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,
-	     q->q2.tag_code);
-
-	printk
-	    (" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
-	     (ulong)le32_to_cpu(q->q1.data_addr),
-	     (ulong)le32_to_cpu(q->q1.data_cnt),
-	     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
-
-	printk(" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
-	       (ulong)q->cdbptr, q->q2.cdb_len,
-	       (ulong)q->sg_head, q->q1.sg_queue_cnt);
-
-	if (q->sg_head) {
-		sgp = q->sg_head;
-		printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong)sgp);
-		printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt,
-		       sgp->queue_cnt);
-		for (i = 0; i < sgp->entry_cnt; i++) {
-			printk(" [%u]: addr 0x%lx, bytes %lu\n",
-			       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),
-			       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));
-		}
-
-	}
-}
-
-/*
- * asc_prt_asc_qdone_info()
- */
-static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
-{
-	printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);
-	printk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
-	       (ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
-	       q->d2.tag_code);
-	printk
-	    (" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
-	     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
-}
-
-/*
- * asc_prt_adv_dvc_var()
- *
- * Display an ADV_DVC_VAR structure.
- */
-static void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
-{
-	printk(" ADV_DVC_VAR at addr 0x%lx\n", (ulong)h);
-
-	printk("  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",
-	       (ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);
-
-	printk("  isr_callback 0x%lx, sdtr_able 0x%x, wdtr_able 0x%x\n",
-	       (ulong)h->isr_callback, (unsigned)h->sdtr_able,
-	       (unsigned)h->wdtr_able);
-
-	printk("  start_motor 0x%x, scsi_reset_wait 0x%x, irq_no 0x%x,\n",
-	       (unsigned)h->start_motor,
-	       (unsigned)h->scsi_reset_wait, (unsigned)h->irq_no);
-
-	printk("  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
-	       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,
-	       (ulong)h->carr_freelist);
-
-	printk("  icq_sp 0x%lx, irq_sp 0x%lx\n",
-	       (ulong)h->icq_sp, (ulong)h->irq_sp);
-
-	printk("  no_scam 0x%x, tagqng_able 0x%x\n",
-	       (unsigned)h->no_scam, (unsigned)h->tagqng_able);
-
-	printk("  chip_scsi_id 0x%x, cfg 0x%lx\n",
-	       (unsigned)h->chip_scsi_id, (ulong)h->cfg);
-}
-
-/*
- * asc_prt_adv_dvc_cfg()
- *
- * Display an ADV_DVC_CFG structure.
- */
-static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
-{
-	printk(" ADV_DVC_CFG at addr 0x%lx\n", (ulong)h);
-
-	printk("  disc_enable 0x%x, termination 0x%x\n",
-	       h->disc_enable, h->termination);
-
-	printk("  chip_version 0x%x, mcode_date 0x%x\n",
-	       h->chip_version, h->mcode_date);
-
-	printk("  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
-	       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
-
-	printk("  control_flag 0x%x\n", h->control_flag);
-}
-
-/*
- * asc_prt_adv_scsi_req_q()
- *
- * Display an ADV_SCSI_REQ_Q structure.
- */
-static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
-{
-	int sg_blk_cnt;
-	struct asc_sg_block *sg_ptr;
-
-	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
-
-	printk("  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
-	       q->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);
-
-	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
-	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
-
-	printk("  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
-	       (ulong)le32_to_cpu(q->data_cnt),
-	       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);
-
-	printk
-	    ("  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
-	     q->cdb_len, q->done_status, q->host_status, q->scsi_status);
-
-	printk("  sg_working_ix 0x%x, target_cmd %u\n",
-	       q->sg_working_ix, q->target_cmd);
-
-	printk("  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
-	       (ulong)le32_to_cpu(q->scsiq_rptr),
-	       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);
-
-	/* Display the request's ADV_SG_BLOCK structures. */
-	if (q->sg_list_ptr != NULL) {
-		sg_blk_cnt = 0;
-		while (1) {
-			/*
-			 * 'sg_ptr' is a physical address. Convert it to a virtual
-			 * address by indexing 'sg_blk_cnt' into the virtual address
-			 * array 'sg_list_ptr'.
-			 *
-			 * XXX - Assumes all SG physical blocks are virtually contiguous.
-			 */
-			sg_ptr =
-			    &(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);
-			asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
-			if (sg_ptr->sg_ptr == 0) {
-				break;
-			}
-			sg_blk_cnt++;
-		}
-	}
-}
-
-/*
- * asc_prt_adv_sgblock()
- *
- * Display an ADV_SG_BLOCK structure.
- */
-static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
-{
-	int i;
-
-	printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
-	       (ulong)b, sgblockno);
-	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
-	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
-	BUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);
-	if (b->sg_ptr != 0)
-		BUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);
-	for (i = 0; i < b->sg_cnt; i++) {
-		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
-		       i, (ulong)b->sg_list[i].sg_addr,
-		       (ulong)b->sg_list[i].sg_count);
-	}
-}
-
-/*
- * asc_prt_hex()
- *
- * Print hexadecimal output in 4 byte groupings 32 bytes
- * or 8 double-words per line.
- */
-static void asc_prt_hex(char *f, uchar *s, int l)
-{
-	int i;
-	int j;
-	int k;
-	int m;
-
-	printk("%s: (%d bytes)\n", f, l);
-
-	for (i = 0; i < l; i += 32) {
-
-		/* Display a maximum of 8 double-words per line. */
-		if ((k = (l - i) / 4) >= 8) {
-			k = 8;
-			m = 0;
-		} else {
-			m = (l - i) % 4;
-		}
-
-		for (j = 0; j < k; j++) {
-			printk(" %2.2X%2.2X%2.2X%2.2X",
-			       (unsigned)s[i + (j * 4)],
-			       (unsigned)s[i + (j * 4) + 1],
-			       (unsigned)s[i + (j * 4) + 2],
-			       (unsigned)s[i + (j * 4) + 3]);
-		}
-
-		switch (m) {
-		case 0:
-		default:
-			break;
-		case 1:
-			printk(" %2.2X", (unsigned)s[i + (j * 4)]);
-			break;
-		case 2:
-			printk(" %2.2X%2.2X",
-			       (unsigned)s[i + (j * 4)],
-			       (unsigned)s[i + (j * 4) + 1]);
-			break;
-		case 3:
-			printk(" %2.2X%2.2X%2.2X",
-			       (unsigned)s[i + (j * 4) + 1],
-			       (unsigned)s[i + (j * 4) + 2],
-			       (unsigned)s[i + (j * 4) + 3]);
-			break;
-		}
-
-		printk("\n");
-	}
-}
-#endif /* ADVANSYS_DEBUG */
-
-static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
-{
-	PortAddr eisa_cfg_iop;
-
-	eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
-	    (PortAddr) (ASC_EISA_CFG_IOP_MASK);
-	return (inpw(eisa_cfg_iop));
-}
-
-static uchar __devinit AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
-{
-	ushort cfg_lsw;
-
-	if (AscGetChipScsiID(iop_base) == new_host_id) {
-		return (new_host_id);
-	}
-	cfg_lsw = AscGetChipCfgLsw(iop_base);
-	cfg_lsw &= 0xF8FF;
-	cfg_lsw |= (ushort)((new_host_id & ASC_MAX_TID) << 8);
-	AscSetChipCfgLsw(iop_base, cfg_lsw);
-	return (AscGetChipScsiID(iop_base));
-}
-
-static unsigned char __devinit AscGetChipScsiCtrl(PortAddr iop_base)
-{
-	unsigned char sc;
-
-	AscSetBank(iop_base, 1);
-	sc = inp(iop_base + IOP_REG_SC);
-	AscSetBank(iop_base, 0);
-	return sc;
-}
-
-static unsigned char __devinit
-AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
-{
-	if (bus_type & ASC_IS_EISA) {
-		PortAddr eisa_iop;
-		unsigned char revision;
-		eisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
-		    (PortAddr) ASC_EISA_REV_IOP_MASK;
-		revision = inp(eisa_iop);
-		return ASC_CHIP_MIN_VER_EISA - 1 + revision;
-	}
-	return AscGetChipVerNo(iop_base);
-}
-
-static ASC_DCNT
-AscLoadMicroCode(PortAddr iop_base,
-		 ushort s_addr, uchar *mcode_buf, ushort mcode_size)
-{
-	ASC_DCNT chksum;
-	ushort mcode_word_size;
-	ushort mcode_chksum;
-
-	/* Write the microcode buffer starting at LRAM address 0. */
-	mcode_word_size = (ushort)(mcode_size >> 1);
-	AscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);
-	AscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);
-
-	chksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);
-	ASC_DBG1(1, "AscLoadMicroCode: chksum 0x%lx\n", (ulong)chksum);
-	mcode_chksum = (ushort)AscMemSumLramWord(iop_base,
-						 (ushort)ASC_CODE_SEC_BEG,
-						 (ushort)((mcode_size -
-							   s_addr - (ushort)
-							   ASC_CODE_SEC_BEG) /
-							  2));
-	ASC_DBG1(1, "AscLoadMicroCode: mcode_chksum 0x%lx\n",
-		 (ulong)mcode_chksum);
-	AscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);
-	AscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);
-	return (chksum);
-}
-
-static int AscFindSignature(PortAddr iop_base)
-{
-	ushort sig_word;
-
-	ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureByte(0x%x) 0x%x\n",
-		 iop_base, AscGetChipSignatureByte(iop_base));
-	if (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {
-		ASC_DBG2(1,
-			 "AscFindSignature: AscGetChipSignatureWord(0x%x) 0x%x\n",
-			 iop_base, AscGetChipSignatureWord(iop_base));
-		sig_word = AscGetChipSignatureWord(iop_base);
-		if ((sig_word == (ushort)ASC_1000_ID0W) ||
-		    (sig_word == (ushort)ASC_1000_ID0W_FIX)) {
-			return (1);
-		}
-	}
-	return (0);
-}
-
-static void __devinit AscToggleIRQAct(PortAddr iop_base)
-{
-	AscSetChipStatus(iop_base, CIW_IRQ_ACT);
-	AscSetChipStatus(iop_base, 0);
-	return;
-}
-
-static uchar __devinit AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
-{
-	ushort cfg_lsw;
-	uchar chip_irq;
-
-	if ((bus_type & ASC_IS_EISA) != 0) {
-		cfg_lsw = AscGetEisaChipCfg(iop_base);
-		chip_irq = (uchar)(((cfg_lsw >> 8) & 0x07) + 10);
-		if ((chip_irq == 13) || (chip_irq > 15)) {
-			return (0);
-		}
-		return (chip_irq);
-	}
-	if ((bus_type & ASC_IS_VL) != 0) {
-		cfg_lsw = AscGetChipCfgLsw(iop_base);
-		chip_irq = (uchar)(((cfg_lsw >> 2) & 0x07));
-		if ((chip_irq == 0) || (chip_irq == 4) || (chip_irq == 7)) {
-			return (0);
-		}
-		return ((uchar)(chip_irq + (ASC_MIN_IRQ_NO - 1)));
-	}
-	cfg_lsw = AscGetChipCfgLsw(iop_base);
-	chip_irq = (uchar)(((cfg_lsw >> 2) & 0x03));
-	if (chip_irq == 3)
-		chip_irq += (uchar)2;
-	return ((uchar)(chip_irq + ASC_MIN_IRQ_NO));
-}
-
-static uchar __devinit
-AscSetChipIRQ(PortAddr iop_base, uchar irq_no, ushort bus_type)
-{
-	ushort cfg_lsw;
-
-	if ((bus_type & ASC_IS_VL) != 0) {
-		if (irq_no != 0) {
-			if ((irq_no < ASC_MIN_IRQ_NO)
-			    || (irq_no > ASC_MAX_IRQ_NO)) {
-				irq_no = 0;
-			} else {
-				irq_no -= (uchar)((ASC_MIN_IRQ_NO - 1));
-			}
-		}
-		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE3);
-		cfg_lsw |= (ushort)0x0010;
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		AscToggleIRQAct(iop_base);
-		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE0);
-		cfg_lsw |= (ushort)((irq_no & 0x07) << 2);
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		AscToggleIRQAct(iop_base);
-		return (AscGetChipIRQ(iop_base, bus_type));
-	}
-	if ((bus_type & (ASC_IS_ISA)) != 0) {
-		if (irq_no == 15)
-			irq_no -= (uchar)2;
-		irq_no -= (uchar)ASC_MIN_IRQ_NO;
-		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFF3);
-		cfg_lsw |= (ushort)((irq_no & 0x03) << 2);
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		return (AscGetChipIRQ(iop_base, bus_type));
-	}
-	return (0);
-}
-
-#ifdef CONFIG_ISA
-static void __devinit AscEnableIsaDma(uchar dma_channel)
-{
-	if (dma_channel < 4) {
-		outp(0x000B, (ushort)(0xC0 | dma_channel));
-		outp(0x000A, dma_channel);
-	} else if (dma_channel < 8) {
-		outp(0x00D6, (ushort)(0xC0 | (dma_channel - 4)));
-		outp(0x00D4, (ushort)(dma_channel - 4));
-	}
-	return;
-}
-#endif /* CONFIG_ISA */
-
-static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
-{
-	EXT_MSG ext_msg;
-	EXT_MSG out_msg;
-	ushort halt_q_addr;
-	int sdtr_accept;
-	ushort int_halt_code;
-	ASC_SCSI_BIT_ID_TYPE scsi_busy;
-	ASC_SCSI_BIT_ID_TYPE target_id;
-	PortAddr iop_base;
-	uchar tag_code;
-	uchar q_status;
-	uchar halt_qp;
-	uchar sdtr_data;
-	uchar target_ix;
-	uchar q_cntl, tid_no;
-	uchar cur_dvc_qng;
-	uchar asyn_sdtr;
-	uchar scsi_status;
-	asc_board_t *boardp;
-
-	BUG_ON(!asc_dvc->drv_ptr);
-	boardp = asc_dvc->drv_ptr;
-
-	iop_base = asc_dvc->iop_base;
-	int_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);
-
-	halt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);
-	halt_q_addr = ASC_QNO_TO_QADDR(halt_qp);
-	target_ix = AscReadLramByte(iop_base,
-				    (ushort)(halt_q_addr +
-					     (ushort)ASC_SCSIQ_B_TARGET_IX));
-	q_cntl = AscReadLramByte(iop_base,
-			    (ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));
-	tid_no = ASC_TIX_TO_TID(target_ix);
-	target_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);
-	if (asc_dvc->pci_fix_asyn_xfer & target_id) {
-		asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;
-	} else {
-		asyn_sdtr = 0;
-	}
-	if (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {
-		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
-			AscSetChipSDTR(iop_base, 0, tid_no);
-			boardp->sdtr_data[tid_no] = 0;
-		}
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
-	} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {
-		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
-			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-			boardp->sdtr_data[tid_no] = asyn_sdtr;
-		}
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
-	} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
-		AscMemWordCopyPtrFromLram(iop_base,
-					  ASCV_MSGIN_BEG,
-					  (uchar *)&ext_msg,
-					  sizeof(EXT_MSG) >> 1);
-
-		if (ext_msg.msg_type == EXTENDED_MESSAGE &&
-		    ext_msg.msg_req == EXTENDED_SDTR &&
-		    ext_msg.msg_len == MS_SDTR_LEN) {
-			sdtr_accept = TRUE;
-			if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
-
-				sdtr_accept = FALSE;
-				ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
-			}
-			if ((ext_msg.xfer_period <
-			     asc_dvc->sdtr_period_tbl[asc_dvc->
-						      host_init_sdtr_index])
-			    || (ext_msg.xfer_period >
-				asc_dvc->sdtr_period_tbl[asc_dvc->
-							 max_sdtr_index])) {
-				sdtr_accept = FALSE;
-				ext_msg.xfer_period =
-				    asc_dvc->sdtr_period_tbl[asc_dvc->
-							     host_init_sdtr_index];
-			}
-			if (sdtr_accept) {
-				sdtr_data =
-				    AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
-						   ext_msg.req_ack_offset);
-				if ((sdtr_data == 0xFF)) {
-
-					q_cntl |= QC_MSG_OUT;
-					asc_dvc->init_sdtr &= ~target_id;
-					asc_dvc->sdtr_done &= ~target_id;
-					AscSetChipSDTR(iop_base, asyn_sdtr,
-						       tid_no);
-					boardp->sdtr_data[tid_no] = asyn_sdtr;
-				}
-			}
-			if (ext_msg.req_ack_offset == 0) {
-
-				q_cntl &= ~QC_MSG_OUT;
-				asc_dvc->init_sdtr &= ~target_id;
-				asc_dvc->sdtr_done &= ~target_id;
-				AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-			} else {
-				if (sdtr_accept && (q_cntl & QC_MSG_OUT)) {
-
-					q_cntl &= ~QC_MSG_OUT;
-					asc_dvc->sdtr_done |= target_id;
-					asc_dvc->init_sdtr |= target_id;
-					asc_dvc->pci_fix_asyn_xfer &=
-					    ~target_id;
-					sdtr_data =
-					    AscCalSDTRData(asc_dvc,
-							   ext_msg.xfer_period,
-							   ext_msg.
-							   req_ack_offset);
-					AscSetChipSDTR(iop_base, sdtr_data,
-						       tid_no);
-					boardp->sdtr_data[tid_no] = sdtr_data;
-				} else {
-
-					q_cntl |= QC_MSG_OUT;
-					AscMsgOutSDTR(asc_dvc,
-						      ext_msg.xfer_period,
-						      ext_msg.req_ack_offset);
-					asc_dvc->pci_fix_asyn_xfer &=
-					    ~target_id;
-					sdtr_data =
-					    AscCalSDTRData(asc_dvc,
-							   ext_msg.xfer_period,
-							   ext_msg.
-							   req_ack_offset);
-					AscSetChipSDTR(iop_base, sdtr_data,
-						       tid_no);
-					boardp->sdtr_data[tid_no] = sdtr_data;
-					asc_dvc->sdtr_done |= target_id;
-					asc_dvc->init_sdtr |= target_id;
-				}
-			}
-
-			AscWriteLramByte(iop_base,
-					 (ushort)(halt_q_addr +
-						  (ushort)ASC_SCSIQ_B_CNTL),
-					 q_cntl);
-			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-			return (0);
-		} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&
-			   ext_msg.msg_req == EXTENDED_WDTR &&
-			   ext_msg.msg_len == MS_WDTR_LEN) {
-
-			ext_msg.wdtr_width = 0;
-			AscMemWordCopyPtrToLram(iop_base,
-						ASCV_MSGOUT_BEG,
-						(uchar *)&ext_msg,
-						sizeof(EXT_MSG) >> 1);
-			q_cntl |= QC_MSG_OUT;
-			AscWriteLramByte(iop_base,
-					 (ushort)(halt_q_addr +
-						  (ushort)ASC_SCSIQ_B_CNTL),
-					 q_cntl);
-			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-			return (0);
-		} else {
-
-			ext_msg.msg_type = MESSAGE_REJECT;
-			AscMemWordCopyPtrToLram(iop_base,
-						ASCV_MSGOUT_BEG,
-						(uchar *)&ext_msg,
-						sizeof(EXT_MSG) >> 1);
-			q_cntl |= QC_MSG_OUT;
-			AscWriteLramByte(iop_base,
-					 (ushort)(halt_q_addr +
-						  (ushort)ASC_SCSIQ_B_CNTL),
-					 q_cntl);
-			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-			return (0);
-		}
-	} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {
-
-		q_cntl |= QC_REQ_SENSE;
-
-		if ((asc_dvc->init_sdtr & target_id) != 0) {
-
-			asc_dvc->sdtr_done &= ~target_id;
-
-			sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
-			q_cntl |= QC_MSG_OUT;
-			AscMsgOutSDTR(asc_dvc,
-				      asc_dvc->
-				      sdtr_period_tbl[(sdtr_data >> 4) &
-						      (uchar)(asc_dvc->
-							      max_sdtr_index -
-							      1)],
-				      (uchar)(sdtr_data & (uchar)
-					      ASC_SYN_MAX_OFFSET));
-		}
-
-		AscWriteLramByte(iop_base,
-				 (ushort)(halt_q_addr +
-					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
-
-		tag_code = AscReadLramByte(iop_base,
-					   (ushort)(halt_q_addr + (ushort)
-						    ASC_SCSIQ_B_TAG_CODE));
-		tag_code &= 0xDC;
-		if ((asc_dvc->pci_fix_asyn_xfer & target_id)
-		    && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)
-		    ) {
-
-			tag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT
-				     | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);
-
-		}
-		AscWriteLramByte(iop_base,
-				 (ushort)(halt_q_addr +
-					  (ushort)ASC_SCSIQ_B_TAG_CODE),
-				 tag_code);
-
-		q_status = AscReadLramByte(iop_base,
-					   (ushort)(halt_q_addr + (ushort)
-						    ASC_SCSIQ_B_STATUS));
-		q_status |= (QS_READY | QS_BUSY);
-		AscWriteLramByte(iop_base,
-				 (ushort)(halt_q_addr +
-					  (ushort)ASC_SCSIQ_B_STATUS),
-				 q_status);
-
-		scsi_busy = AscReadLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B);
-		scsi_busy &= ~target_id;
-		AscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);
-
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
-	} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {
-
-		AscMemWordCopyPtrFromLram(iop_base,
-					  ASCV_MSGOUT_BEG,
-					  (uchar *)&out_msg,
-					  sizeof(EXT_MSG) >> 1);
-
-		if ((out_msg.msg_type == EXTENDED_MESSAGE) &&
-		    (out_msg.msg_len == MS_SDTR_LEN) &&
-		    (out_msg.msg_req == EXTENDED_SDTR)) {
-
-			asc_dvc->init_sdtr &= ~target_id;
-			asc_dvc->sdtr_done &= ~target_id;
-			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-			boardp->sdtr_data[tid_no] = asyn_sdtr;
-		}
-		q_cntl &= ~QC_MSG_OUT;
-		AscWriteLramByte(iop_base,
-				 (ushort)(halt_q_addr +
-					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
-	} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {
-
-		scsi_status = AscReadLramByte(iop_base,
-					      (ushort)((ushort)halt_q_addr +
-						       (ushort)
-						       ASC_SCSIQ_SCSI_STATUS));
-		cur_dvc_qng =
-		    AscReadLramByte(iop_base,
-				    (ushort)((ushort)ASC_QADR_BEG +
-					     (ushort)target_ix));
-		if ((cur_dvc_qng > 0) && (asc_dvc->cur_dvc_qng[tid_no] > 0)) {
-
-			scsi_busy = AscReadLramByte(iop_base,
-						    (ushort)ASCV_SCSIBUSY_B);
-			scsi_busy |= target_id;
-			AscWriteLramByte(iop_base,
-					 (ushort)ASCV_SCSIBUSY_B, scsi_busy);
-			asc_dvc->queue_full_or_busy |= target_id;
-
-			if (scsi_status == SAM_STAT_TASK_SET_FULL) {
-				if (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {
-					cur_dvc_qng -= 1;
-					asc_dvc->max_dvc_qng[tid_no] =
-					    cur_dvc_qng;
-
-					AscWriteLramByte(iop_base,
-							 (ushort)((ushort)
-								  ASCV_MAX_DVC_QNG_BEG
-								  + (ushort)
-								  tid_no),
-							 cur_dvc_qng);
-
-					/*
-					 * Set the device queue depth to the
-					 * number of active requests when the
-					 * QUEUE FULL condition was encountered.
-					 */
-					boardp->queue_full |= target_id;
-					boardp->queue_full_cnt[tid_no] =
-					    cur_dvc_qng;
-				}
-			}
-		}
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
-	}
-#if CC_VERY_LONG_SG_LIST
-	else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC) {
-		uchar q_no;
-		ushort q_addr;
-		uchar sg_wk_q_no;
-		uchar first_sg_wk_q_no;
-		ASC_SCSI_Q *scsiq;	/* Ptr to driver request. */
-		ASC_SG_HEAD *sg_head;	/* Ptr to driver SG request. */
-		ASC_SG_LIST_Q scsi_sg_q;	/* Structure written to queue. */
-		ushort sg_list_dwords;
-		ushort sg_entry_cnt;
-		uchar next_qp;
-		int i;
-
-		q_no = AscReadLramByte(iop_base, (ushort)ASCV_REQ_SG_LIST_QP);
-		if (q_no == ASC_QLINK_END)
-			return 0;
-
-		q_addr = ASC_QNO_TO_QADDR(q_no);
-
-		/*
-		 * Convert the request's SRB pointer to a host ASC_SCSI_REQ
-		 * structure pointer using a macro provided by the driver.
-		 * The ASC_SCSI_REQ pointer provides a pointer to the
-		 * host ASC_SG_HEAD structure.
-		 */
-		/* Read request's SRB pointer. */
-		scsiq = (ASC_SCSI_Q *)
-		    ASC_SRB2SCSIQ(ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,
-								    (ushort)
-								    (q_addr +
-								     ASC_SCSIQ_D_SRBPTR))));
-
-		/*
-		 * Get request's first and working SG queue.
-		 */
-		sg_wk_q_no = AscReadLramByte(iop_base,
-					     (ushort)(q_addr +
-						      ASC_SCSIQ_B_SG_WK_QP));
-
-		first_sg_wk_q_no = AscReadLramByte(iop_base,
-						   (ushort)(q_addr +
-							    ASC_SCSIQ_B_FIRST_SG_WK_QP));
-
-		/*
-		 * Reset request's working SG queue back to the
-		 * first SG queue.
-		 */
-		AscWriteLramByte(iop_base,
-				 (ushort)(q_addr +
-					  (ushort)ASC_SCSIQ_B_SG_WK_QP),
-				 first_sg_wk_q_no);
-
-		sg_head = scsiq->sg_head;
-
-		/*
-		 * Set sg_entry_cnt to the number of SG elements
-		 * that will be completed on this interrupt.
-		 *
-		 * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1
-		 * SG elements. The data_cnt and data_addr fields which
-		 * add 1 to the SG element capacity are not used when
-		 * restarting SG handling after a halt.
-		 */
-		if (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1)) {
-			sg_entry_cnt = ASC_MAX_SG_LIST - 1;
-
-			/*
-			 * Keep track of remaining number of SG elements that
-			 * will need to be handled on the next interrupt.
-			 */
-			scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
-		} else {
-			sg_entry_cnt = scsiq->remain_sg_entry_cnt;
-			scsiq->remain_sg_entry_cnt = 0;
-		}
-
-		/*
-		 * Copy SG elements into the list of allocated SG queues.
-		 *
-		 * Last index completed is saved in scsiq->next_sg_index.
-		 */
-		next_qp = first_sg_wk_q_no;
-		q_addr = ASC_QNO_TO_QADDR(next_qp);
-		scsi_sg_q.sg_head_qp = q_no;
-		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
-		for (i = 0; i < sg_head->queue_cnt; i++) {
-			scsi_sg_q.seq_no = i + 1;
-			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
-				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
-				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
-				/*
-				 * After very first SG queue RISC FW uses next
-				 * SG queue first element then checks sg_list_cnt
-				 * against zero and then decrements, so set
-				 * sg_list_cnt 1 less than number of SG elements
-				 * in each SG queue.
-				 */
-				scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
-				scsi_sg_q.sg_cur_list_cnt =
-				    ASC_SG_LIST_PER_Q - 1;
-			} else {
-				/*
-				 * This is the last SG queue in the list of
-				 * allocated SG queues. If there are more
-				 * SG elements than will fit in the allocated
-				 * queues, then set the QCSG_SG_XFER_MORE flag.
-				 */
-				if (scsiq->remain_sg_entry_cnt != 0) {
-					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
-				} else {
-					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
-				}
-				/* equals sg_entry_cnt * 2 */
-				sg_list_dwords = sg_entry_cnt << 1;
-				scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
-				scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
-				sg_entry_cnt = 0;
-			}
-
-			scsi_sg_q.q_no = next_qp;
-			AscMemWordCopyPtrToLram(iop_base,
-						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
-						(uchar *)&scsi_sg_q,
-						sizeof(ASC_SG_LIST_Q) >> 1);
-
-			AscMemDWordCopyPtrToLram(iop_base,
-						 q_addr + ASC_SGQ_LIST_BEG,
-						 (uchar *)&sg_head->
-						 sg_list[scsiq->next_sg_index],
-						 sg_list_dwords);
-
-			scsiq->next_sg_index += ASC_SG_LIST_PER_Q;
-
-			/*
-			 * If the just completed SG queue contained the
-			 * last SG element, then no more SG queues need
-			 * to be written.
-			 */
-			if (scsi_sg_q.cntl & QCSG_SG_XFER_END) {
-				break;
-			}
-
-			next_qp = AscReadLramByte(iop_base,
-						  (ushort)(q_addr +
-							   ASC_SCSIQ_B_FWD));
-			q_addr = ASC_QNO_TO_QADDR(next_qp);
-		}
-
-		/*
-		 * Clear the halt condition so the RISC will be restarted
-		 * after the return.
-		 */
-		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-		return (0);
-	}
-#endif /* CC_VERY_LONG_SG_LIST */
-	return (0);
-}
-
-static uchar
-_AscCopyLramScsiDoneQ(PortAddr iop_base,
-		      ushort q_addr,
-		      ASC_QDONE_INFO *scsiq, ASC_DCNT max_dma_count)
-{
-	ushort _val;
-	uchar sg_queue_cnt;
-
-	DvcGetQinfo(iop_base,
-		    q_addr + ASC_SCSIQ_DONE_INFO_BEG,
-		    (uchar *)scsiq,
-		    (sizeof(ASC_SCSIQ_2) + sizeof(ASC_SCSIQ_3)) / 2);
-
-	_val = AscReadLramWord(iop_base,
-			       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS));
-	scsiq->q_status = (uchar)_val;
-	scsiq->q_no = (uchar)(_val >> 8);
-	_val = AscReadLramWord(iop_base,
-			       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_CNTL));
-	scsiq->cntl = (uchar)_val;
-	sg_queue_cnt = (uchar)(_val >> 8);
-	_val = AscReadLramWord(iop_base,
-			       (ushort)(q_addr +
-					(ushort)ASC_SCSIQ_B_SENSE_LEN));
-	scsiq->sense_len = (uchar)_val;
-	scsiq->extra_bytes = (uchar)(_val >> 8);
-
-	/*
-	 * Read high word of remain bytes from alternate location.
-	 */
-	scsiq->remain_bytes = (((ADV_DCNT)AscReadLramWord(iop_base,
-							  (ushort)(q_addr +
-								   (ushort)
-								   ASC_SCSIQ_W_ALT_DC1)))
-			       << 16);
-	/*
-	 * Read low word of remain bytes from original location.
-	 */
-	scsiq->remain_bytes += AscReadLramWord(iop_base,
-					       (ushort)(q_addr + (ushort)
-							ASC_SCSIQ_DW_REMAIN_XFER_CNT));
-
-	scsiq->remain_bytes &= max_dma_count;
-	return (sg_queue_cnt);
-}
-
-static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
-{
-	uchar next_qp;
-	uchar n_q_used;
-	uchar sg_list_qp;
-	uchar sg_queue_cnt;
-	uchar q_cnt;
-	uchar done_q_tail;
-	uchar tid_no;
-	ASC_SCSI_BIT_ID_TYPE scsi_busy;
-	ASC_SCSI_BIT_ID_TYPE target_id;
-	PortAddr iop_base;
-	ushort q_addr;
-	ushort sg_q_addr;
-	uchar cur_target_qng;
-	ASC_QDONE_INFO scsiq_buf;
-	ASC_QDONE_INFO *scsiq;
-	int false_overrun;
-
-	iop_base = asc_dvc->iop_base;
-	n_q_used = 1;
-	scsiq = (ASC_QDONE_INFO *)&scsiq_buf;
-	done_q_tail = (uchar)AscGetVarDoneQTail(iop_base);
-	q_addr = ASC_QNO_TO_QADDR(done_q_tail);
-	next_qp = AscReadLramByte(iop_base,
-				  (ushort)(q_addr + (ushort)ASC_SCSIQ_B_FWD));
-	if (next_qp != ASC_QLINK_END) {
-		AscPutVarDoneQTail(iop_base, next_qp);
-		q_addr = ASC_QNO_TO_QADDR(next_qp);
-		sg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,
-						     asc_dvc->max_dma_count);
-		AscWriteLramByte(iop_base,
-				 (ushort)(q_addr +
-					  (ushort)ASC_SCSIQ_B_STATUS),
-				 (uchar)(scsiq->
-					 q_status & (uchar)~(QS_READY |
-							     QS_ABORTED)));
-		tid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);
-		target_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);
-		if ((scsiq->cntl & QC_SG_HEAD) != 0) {
-			sg_q_addr = q_addr;
-			sg_list_qp = next_qp;
-			for (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {
-				sg_list_qp = AscReadLramByte(iop_base,
-							     (ushort)(sg_q_addr
-								      + (ushort)
-								      ASC_SCSIQ_B_FWD));
-				sg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);
-				if (sg_list_qp == ASC_QLINK_END) {
-					AscSetLibErrorCode(asc_dvc,
-							   ASCQ_ERR_SG_Q_LINKS);
-					scsiq->d3.done_stat = QD_WITH_ERROR;
-					scsiq->d3.host_stat =
-					    QHSTA_D_QDONE_SG_LIST_CORRUPTED;
-					goto FATAL_ERR_QDONE;
-				}
-				AscWriteLramByte(iop_base,
-						 (ushort)(sg_q_addr + (ushort)
-							  ASC_SCSIQ_B_STATUS),
-						 QS_FREE);
-			}
-			n_q_used = sg_queue_cnt + 1;
-			AscPutVarDoneQTail(iop_base, sg_list_qp);
-		}
-		if (asc_dvc->queue_full_or_busy & target_id) {
-			cur_target_qng = AscReadLramByte(iop_base,
-							 (ushort)((ushort)
-								  ASC_QADR_BEG
-								  + (ushort)
-								  scsiq->d2.
-								  target_ix));
-			if (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {
-				scsi_busy = AscReadLramByte(iop_base, (ushort)
-							    ASCV_SCSIBUSY_B);
-				scsi_busy &= ~target_id;
-				AscWriteLramByte(iop_base,
-						 (ushort)ASCV_SCSIBUSY_B,
-						 scsi_busy);
-				asc_dvc->queue_full_or_busy &= ~target_id;
-			}
-		}
-		if (asc_dvc->cur_total_qng >= n_q_used) {
-			asc_dvc->cur_total_qng -= n_q_used;
-			if (asc_dvc->cur_dvc_qng[tid_no] != 0) {
-				asc_dvc->cur_dvc_qng[tid_no]--;
-			}
-		} else {
-			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);
-			scsiq->d3.done_stat = QD_WITH_ERROR;
-			goto FATAL_ERR_QDONE;
-		}
-		if ((scsiq->d2.srb_ptr == 0UL) ||
-		    ((scsiq->q_status & QS_ABORTED) != 0)) {
-			return (0x11);
-		} else if (scsiq->q_status == QS_DONE) {
-			false_overrun = FALSE;
-			if (scsiq->extra_bytes != 0) {
-				scsiq->remain_bytes +=
-				    (ADV_DCNT)scsiq->extra_bytes;
-			}
-			if (scsiq->d3.done_stat == QD_WITH_ERROR) {
-				if (scsiq->d3.host_stat ==
-				    QHSTA_M_DATA_OVER_RUN) {
-					if ((scsiq->
-					     cntl & (QC_DATA_IN | QC_DATA_OUT))
-					    == 0) {
-						scsiq->d3.done_stat =
-						    QD_NO_ERROR;
-						scsiq->d3.host_stat =
-						    QHSTA_NO_ERROR;
-					} else if (false_overrun) {
-						scsiq->d3.done_stat =
-						    QD_NO_ERROR;
-						scsiq->d3.host_stat =
-						    QHSTA_NO_ERROR;
-					}
-				} else if (scsiq->d3.host_stat ==
-					   QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
-					AscStopChip(iop_base);
-					AscSetChipControl(iop_base,
-							  (uchar)(CC_SCSI_RESET
-								  | CC_HALT));
-					udelay(60);
-					AscSetChipControl(iop_base, CC_HALT);
-					AscSetChipStatus(iop_base,
-							 CIW_CLR_SCSI_RESET_INT);
-					AscSetChipStatus(iop_base, 0);
-					AscSetChipControl(iop_base, 0);
-				}
-			}
-			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
-				asc_isr_callback(asc_dvc, scsiq);
-			} else {
-				if ((AscReadLramByte(iop_base,
-						     (ushort)(q_addr + (ushort)
-							      ASC_SCSIQ_CDB_BEG))
-				     == START_STOP)) {
-					asc_dvc->unit_not_ready &= ~target_id;
-					if (scsiq->d3.done_stat != QD_NO_ERROR) {
-						asc_dvc->start_motor &=
-						    ~target_id;
-					}
-				}
-			}
-			return (1);
-		} else {
-			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);
- FATAL_ERR_QDONE:
-			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
-				asc_isr_callback(asc_dvc, scsiq);
-			}
-			return (0x80);
-		}
-	}
-	return (0);
-}
-
-static int AscISR(ASC_DVC_VAR *asc_dvc)
-{
-	ASC_CS_TYPE chipstat;
-	PortAddr iop_base;
-	ushort saved_ram_addr;
-	uchar ctrl_reg;
-	uchar saved_ctrl_reg;
-	int int_pending;
-	int status;
-	uchar host_flag;
-
-	iop_base = asc_dvc->iop_base;
-	int_pending = FALSE;
-
-	if (AscIsIntPending(iop_base) == 0) {
-		return int_pending;
-	}
-
-	if ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {
-		return (ERR);
-	}
-	if (asc_dvc->in_critical_cnt != 0) {
-		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);
-		return (ERR);
-	}
-	if (asc_dvc->is_in_int) {
-		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);
-		return (ERR);
-	}
-	asc_dvc->is_in_int = TRUE;
-	ctrl_reg = AscGetChipControl(iop_base);
-	saved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |
-				       CC_SINGLE_STEP | CC_DIAG | CC_TEST));
-	chipstat = AscGetChipStatus(iop_base);
-	if (chipstat & CSW_SCSI_RESET_LATCH) {
-		if (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {
-			int i = 10;
-			int_pending = TRUE;
-			asc_dvc->sdtr_done = 0;
-			saved_ctrl_reg &= (uchar)(~CC_HALT);
-			while ((AscGetChipStatus(iop_base) &
-				CSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {
-				mdelay(100);
-			}
-			AscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));
-			AscSetChipControl(iop_base, CC_HALT);
-			AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
-			AscSetChipStatus(iop_base, 0);
-			chipstat = AscGetChipStatus(iop_base);
-		}
-	}
-	saved_ram_addr = AscGetChipLramAddr(iop_base);
-	host_flag = AscReadLramByte(iop_base,
-				    ASCV_HOST_FLAG_B) &
-	    (uchar)(~ASC_HOST_FLAG_IN_ISR);
-	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
-			 (uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));
-	if ((chipstat & CSW_INT_PENDING)
-	    || (int_pending)
-	    ) {
-		AscAckInterrupt(iop_base);
-		int_pending = TRUE;
-		if ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {
-			if (AscIsrChipHalted(asc_dvc) == ERR) {
-				goto ISR_REPORT_QDONE_FATAL_ERROR;
-			} else {
-				saved_ctrl_reg &= (uchar)(~CC_HALT);
-			}
-		} else {
- ISR_REPORT_QDONE_FATAL_ERROR:
-			if ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {
-				while (((status =
-					 AscIsrQDone(asc_dvc)) & 0x01) != 0) {
-				}
-			} else {
-				do {
-					if ((status =
-					     AscIsrQDone(asc_dvc)) == 1) {
-						break;
-					}
-				} while (status == 0x11);
-			}
-			if ((status & 0x80) != 0)
-				int_pending = ERR;
-		}
-	}
-	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
-	AscSetChipLramAddr(iop_base, saved_ram_addr);
-	AscSetChipControl(iop_base, saved_ctrl_reg);
-	asc_dvc->is_in_int = FALSE;
-	return (int_pending);
-}
-
-/* Microcode buffer is kept after initialization for error recovery. */
-static uchar _asc_mcode_buf[] = {
-	0x01, 0x03, 0x01, 0x19, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x12, 0x0D, 0x05,
-	0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0xFF, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0xE4, 0x88, 0x00, 0x00, 0x00, 0x00, 0x80, 0x73, 0x48, 0x04,
-	0x36, 0x00, 0x00, 0xA2, 0xC2, 0x00, 0x80, 0x73, 0x03, 0x23, 0x36, 0x40,
-	0xB6, 0x00, 0x36, 0x00, 0x05, 0xD6, 0x0C, 0xD2, 0x12, 0xDA, 0x00, 0xA2,
-	0xC2, 0x00, 0x92, 0x80, 0x1E, 0x98, 0x50, 0x00, 0xF5, 0x00, 0x48, 0x98,
-	0xDF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x4F, 0x00, 0xF5, 0x00,
-	0x48, 0x98, 0xEF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x80, 0x62,
-	0x92, 0x80, 0x00, 0x46, 0x15, 0xEE, 0x13, 0xEA, 0x02, 0x01, 0x09, 0xD8,
-	0xCD, 0x04, 0x4D, 0x00, 0x00, 0xA3, 0xD6, 0x00, 0xA6, 0x97, 0x7F, 0x23,
-	0x04, 0x61, 0x84, 0x01, 0xE6, 0x84, 0xD2, 0xC1, 0x80, 0x73, 0xCD, 0x04,
-	0x4D, 0x00, 0x00, 0xA3, 0xDA, 0x01, 0xA6, 0x97, 0xC6, 0x81, 0xC2, 0x88,
-	0x80, 0x73, 0x80, 0x77, 0x00, 0x01, 0x01, 0xA1, 0xFE, 0x00, 0x4F, 0x00,
-	0x84, 0x97, 0x07, 0xA6, 0x08, 0x01, 0x00, 0x33, 0x03, 0x00, 0xC2, 0x88,
-	0x03, 0x03, 0x01, 0xDE, 0xC2, 0x88, 0xCE, 0x00, 0x69, 0x60, 0xCE, 0x00,
-	0x02, 0x03, 0x4A, 0x60, 0x00, 0xA2, 0x78, 0x01, 0x80, 0x63, 0x07, 0xA6,
-	0x24, 0x01, 0x78, 0x81, 0x03, 0x03, 0x80, 0x63, 0xE2, 0x00, 0x07, 0xA6,
-	0x34, 0x01, 0x00, 0x33, 0x04, 0x00, 0xC2, 0x88, 0x03, 0x07, 0x02, 0x01,
-	0x04, 0xCA, 0x0D, 0x23, 0x68, 0x98, 0x4D, 0x04, 0x04, 0x85, 0x05, 0xD8,
-	0x0D, 0x23, 0x68, 0x98, 0xCD, 0x04, 0x15, 0x23, 0xF8, 0x88, 0xFB, 0x23,
-	0x02, 0x61, 0x82, 0x01, 0x80, 0x63, 0x02, 0x03, 0x06, 0xA3, 0x62, 0x01,
-	0x00, 0x33, 0x0A, 0x00, 0xC2, 0x88, 0x4E, 0x00, 0x07, 0xA3, 0x6E, 0x01,
-	0x00, 0x33, 0x0B, 0x00, 0xC2, 0x88, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33,
-	0x1A, 0x00, 0xC2, 0x88, 0x50, 0x04, 0x88, 0x81, 0x06, 0xAB, 0x82, 0x01,
-	0x88, 0x81, 0x4E, 0x00, 0x07, 0xA3, 0x92, 0x01, 0x50, 0x00, 0x00, 0xA3,
-	0x3C, 0x01, 0x00, 0x05, 0x7C, 0x81, 0x46, 0x97, 0x02, 0x01, 0x05, 0xC6,
-	0x04, 0x23, 0xA0, 0x01, 0x15, 0x23, 0xA1, 0x01, 0xBE, 0x81, 0xFD, 0x23,
-	0x02, 0x61, 0x82, 0x01, 0x0A, 0xDA, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA0,
-	0xB4, 0x01, 0x80, 0x63, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33, 0x1B, 0x00,
-	0xC2, 0x88, 0x06, 0x23, 0x68, 0x98, 0xCD, 0x04, 0xE6, 0x84, 0x06, 0x01,
-	0x00, 0xA2, 0xD4, 0x01, 0x57, 0x60, 0x00, 0xA0, 0xDA, 0x01, 0xE6, 0x84,
-	0x80, 0x23, 0xA0, 0x01, 0xE6, 0x84, 0x80, 0x73, 0x4B, 0x00, 0x06, 0x61,
-	0x00, 0xA2, 0x00, 0x02, 0x04, 0x01, 0x0C, 0xDE, 0x02, 0x01, 0x03, 0xCC,
-	0x4F, 0x00, 0x84, 0x97, 0xFC, 0x81, 0x08, 0x23, 0x02, 0x41, 0x82, 0x01,
-	0x4F, 0x00, 0x62, 0x97, 0x48, 0x04, 0x84, 0x80, 0xF0, 0x97, 0x00, 0x46,
-	0x56, 0x00, 0x03, 0xC0, 0x01, 0x23, 0xE8, 0x00, 0x81, 0x73, 0x06, 0x29,
-	0x03, 0x42, 0x06, 0xE2, 0x03, 0xEE, 0x6B, 0xEB, 0x11, 0x23, 0xF8, 0x88,
-	0x04, 0x98, 0xF0, 0x80, 0x80, 0x73, 0x80, 0x77, 0x07, 0xA4, 0x2A, 0x02,
-	0x7C, 0x95, 0x06, 0xA6, 0x34, 0x02, 0x03, 0xA6, 0x4C, 0x04, 0x46, 0x82,
-	0x04, 0x01, 0x03, 0xD8, 0xB4, 0x98, 0x6A, 0x96, 0x46, 0x82, 0xFE, 0x95,
-	0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0xB6, 0x2D, 0x02, 0xA6, 0x6C, 0x02,
-	0x07, 0xA6, 0x5A, 0x02, 0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x62, 0x02,
-	0xC2, 0x88, 0x7C, 0x95, 0x48, 0x82, 0x60, 0x96, 0x48, 0x82, 0x04, 0x23,
-	0xA0, 0x01, 0x14, 0x23, 0xA1, 0x01, 0x3C, 0x84, 0x04, 0x01, 0x0C, 0xDC,
-	0xE0, 0x23, 0x25, 0x61, 0xEF, 0x00, 0x14, 0x01, 0x4F, 0x04, 0xA8, 0x01,
-	0x6F, 0x00, 0xA5, 0x01, 0x03, 0x23, 0xA4, 0x01, 0x06, 0x23, 0x9C, 0x01,
-	0x24, 0x2B, 0x1C, 0x01, 0x02, 0xA6, 0xAA, 0x02, 0x07, 0xA6, 0x5A, 0x02,
-	0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x20, 0x04, 0x01, 0xA6, 0xB4, 0x02,
-	0x00, 0xA6, 0xB4, 0x02, 0x00, 0x33, 0x12, 0x00, 0xC2, 0x88, 0x00, 0x0E,
-	0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0x8C, 0x02, 0x4D, 0x04, 0x04, 0x01,
-	0x0B, 0xDC, 0xE7, 0x23, 0x04, 0x61, 0x84, 0x01, 0x10, 0x31, 0x12, 0x35,
-	0x14, 0x01, 0xEC, 0x00, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0xEA, 0x82,
-	0x18, 0x23, 0x04, 0x61, 0x18, 0xA0, 0xE2, 0x02, 0x04, 0x01, 0xA2, 0xC8,
-	0x00, 0x33, 0x1F, 0x00, 0xC2, 0x88, 0x08, 0x31, 0x0A, 0x35, 0x0C, 0x39,
-	0x0E, 0x3D, 0x7E, 0x98, 0xB6, 0x2D, 0x01, 0xA6, 0x14, 0x03, 0x00, 0xA6,
-	0x14, 0x03, 0x07, 0xA6, 0x0C, 0x03, 0x06, 0xA6, 0x10, 0x03, 0x03, 0xA6,
-	0x20, 0x04, 0x02, 0xA6, 0x6C, 0x02, 0x00, 0x33, 0x33, 0x00, 0xC2, 0x88,
-	0x7C, 0x95, 0xEE, 0x82, 0x60, 0x96, 0xEE, 0x82, 0x82, 0x98, 0x80, 0x42,
-	0x7E, 0x98, 0x64, 0xE4, 0x04, 0x01, 0x2D, 0xC8, 0x31, 0x05, 0x07, 0x01,
-	0x00, 0xA2, 0x54, 0x03, 0x00, 0x43, 0x87, 0x01, 0x05, 0x05, 0x86, 0x98,
-	0x7E, 0x98, 0x00, 0xA6, 0x16, 0x03, 0x07, 0xA6, 0x4C, 0x03, 0x03, 0xA6,
-	0x3C, 0x04, 0x06, 0xA6, 0x50, 0x03, 0x01, 0xA6, 0x16, 0x03, 0x00, 0x33,
-	0x25, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x32, 0x83, 0x60, 0x96, 0x32, 0x83,
-	0x04, 0x01, 0x10, 0xCE, 0x07, 0xC8, 0x05, 0x05, 0xEB, 0x04, 0x00, 0x33,
-	0x00, 0x20, 0xC0, 0x20, 0x81, 0x62, 0x72, 0x83, 0x00, 0x01, 0x05, 0x05,
-	0xFF, 0xA2, 0x7A, 0x03, 0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x2E, 0x83,
-	0x05, 0x05, 0x15, 0x01, 0x00, 0xA2, 0x9A, 0x03, 0xEC, 0x00, 0x6E, 0x00,
-	0x95, 0x01, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0x01, 0xA6, 0x96, 0x03,
-	0x00, 0xA6, 0x96, 0x03, 0x10, 0x84, 0x80, 0x42, 0x7E, 0x98, 0x01, 0xA6,
-	0xA4, 0x03, 0x00, 0xA6, 0xBC, 0x03, 0x10, 0x84, 0xA8, 0x98, 0x80, 0x42,
-	0x01, 0xA6, 0xA4, 0x03, 0x07, 0xA6, 0xB2, 0x03, 0xD4, 0x83, 0x7C, 0x95,
-	0xA8, 0x83, 0x00, 0x33, 0x2F, 0x00, 0xC2, 0x88, 0xA8, 0x98, 0x80, 0x42,
-	0x00, 0xA6, 0xBC, 0x03, 0x07, 0xA6, 0xCA, 0x03, 0xD4, 0x83, 0x7C, 0x95,
-	0xC0, 0x83, 0x00, 0x33, 0x26, 0x00, 0xC2, 0x88, 0x38, 0x2B, 0x80, 0x32,
-	0x80, 0x36, 0x04, 0x23, 0xA0, 0x01, 0x12, 0x23, 0xA1, 0x01, 0x10, 0x84,
-	0x07, 0xF0, 0x06, 0xA4, 0xF4, 0x03, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23,
-	0x83, 0x03, 0x80, 0x63, 0x03, 0xA6, 0x0E, 0x04, 0x07, 0xA6, 0x06, 0x04,
-	0x06, 0xA6, 0x0A, 0x04, 0x00, 0x33, 0x17, 0x00, 0xC2, 0x88, 0x7C, 0x95,
-	0xF4, 0x83, 0x60, 0x96, 0xF4, 0x83, 0x20, 0x84, 0x07, 0xF0, 0x06, 0xA4,
-	0x20, 0x04, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23, 0x83, 0x03, 0x80, 0x63,
-	0xB6, 0x2D, 0x03, 0xA6, 0x3C, 0x04, 0x07, 0xA6, 0x34, 0x04, 0x06, 0xA6,
-	0x38, 0x04, 0x00, 0x33, 0x30, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x20, 0x84,
-	0x60, 0x96, 0x20, 0x84, 0x1D, 0x01, 0x06, 0xCC, 0x00, 0x33, 0x00, 0x84,
-	0xC0, 0x20, 0x00, 0x23, 0xEA, 0x00, 0x81, 0x62, 0xA2, 0x0D, 0x80, 0x63,
-	0x07, 0xA6, 0x5A, 0x04, 0x00, 0x33, 0x18, 0x00, 0xC2, 0x88, 0x03, 0x03,
-	0x80, 0x63, 0xA3, 0x01, 0x07, 0xA4, 0x64, 0x04, 0x23, 0x01, 0x00, 0xA2,
-	0x86, 0x04, 0x0A, 0xA0, 0x76, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1D, 0x00,
-	0xC2, 0x88, 0x0B, 0xA0, 0x82, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1E, 0x00,
-	0xC2, 0x88, 0x42, 0x23, 0xF8, 0x88, 0x00, 0x23, 0x22, 0xA3, 0xE6, 0x04,
-	0x08, 0x23, 0x22, 0xA3, 0xA2, 0x04, 0x28, 0x23, 0x22, 0xA3, 0xAE, 0x04,
-	0x02, 0x23, 0x22, 0xA3, 0xC4, 0x04, 0x42, 0x23, 0xF8, 0x88, 0x4A, 0x00,
-	0x06, 0x61, 0x00, 0xA0, 0xAE, 0x04, 0x45, 0x23, 0xF8, 0x88, 0x04, 0x98,
-	0x00, 0xA2, 0xC0, 0x04, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x82, 0xC0, 0x20,
-	0x81, 0x62, 0xE8, 0x81, 0x47, 0x23, 0xF8, 0x88, 0x04, 0x01, 0x0B, 0xDE,
-	0x04, 0x98, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x81, 0xC0, 0x20, 0x81, 0x62,
-	0x14, 0x01, 0x00, 0xA0, 0x00, 0x02, 0x43, 0x23, 0xF8, 0x88, 0x04, 0x23,
-	0xA0, 0x01, 0x44, 0x23, 0xA1, 0x01, 0x80, 0x73, 0x4D, 0x00, 0x03, 0xA3,
-	0xF4, 0x04, 0x00, 0x33, 0x27, 0x00, 0xC2, 0x88, 0x04, 0x01, 0x04, 0xDC,
-	0x02, 0x23, 0xA2, 0x01, 0x04, 0x23, 0xA0, 0x01, 0x04, 0x98, 0x26, 0x95,
-	0x4B, 0x00, 0xF6, 0x00, 0x4F, 0x04, 0x4F, 0x00, 0x00, 0xA3, 0x22, 0x05,
-	0x00, 0x05, 0x76, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x1C, 0x05, 0x0A, 0x85,
-	0x46, 0x97, 0xCD, 0x04, 0x24, 0x85, 0x48, 0x04, 0x84, 0x80, 0x02, 0x01,
-	0x03, 0xDA, 0x80, 0x23, 0x82, 0x01, 0x34, 0x85, 0x02, 0x23, 0xA0, 0x01,
-	0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x40, 0x05, 0x1D, 0x01, 0x04, 0xD6,
-	0xFF, 0x23, 0x86, 0x41, 0x4B, 0x60, 0xCB, 0x00, 0xFF, 0x23, 0x80, 0x01,
-	0x49, 0x00, 0x81, 0x01, 0x04, 0x01, 0x02, 0xC8, 0x30, 0x01, 0x80, 0x01,
-	0xF7, 0x04, 0x03, 0x01, 0x49, 0x04, 0x80, 0x01, 0xC9, 0x00, 0x00, 0x05,
-	0x00, 0x01, 0xFF, 0xA0, 0x60, 0x05, 0x77, 0x04, 0x01, 0x23, 0xEA, 0x00,
-	0x5D, 0x00, 0xFE, 0xC7, 0x00, 0x62, 0x00, 0x23, 0xEA, 0x00, 0x00, 0x63,
-	0x07, 0xA4, 0xF8, 0x05, 0x03, 0x03, 0x02, 0xA0, 0x8E, 0x05, 0xF4, 0x85,
-	0x00, 0x33, 0x2D, 0x00, 0xC2, 0x88, 0x04, 0xA0, 0xB8, 0x05, 0x80, 0x63,
-	0x00, 0x23, 0xDF, 0x00, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0xA4, 0x05,
-	0x1D, 0x01, 0x06, 0xD6, 0x02, 0x23, 0x02, 0x41, 0x82, 0x01, 0x50, 0x00,
-	0x62, 0x97, 0x04, 0x85, 0x04, 0x23, 0x02, 0x41, 0x82, 0x01, 0x04, 0x85,
-	0x08, 0xA0, 0xBE, 0x05, 0xF4, 0x85, 0x03, 0xA0, 0xC4, 0x05, 0xF4, 0x85,
-	0x01, 0xA0, 0xCE, 0x05, 0x88, 0x00, 0x80, 0x63, 0xCC, 0x86, 0x07, 0xA0,
-	0xEE, 0x05, 0x5F, 0x00, 0x00, 0x2B, 0xDF, 0x08, 0x00, 0xA2, 0xE6, 0x05,
-	0x80, 0x67, 0x80, 0x63, 0x01, 0xA2, 0x7A, 0x06, 0x7C, 0x85, 0x06, 0x23,
-	0x68, 0x98, 0x48, 0x23, 0xF8, 0x88, 0x07, 0x23, 0x80, 0x00, 0x06, 0x87,
-	0x80, 0x63, 0x7C, 0x85, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63, 0x4A, 0x00,
-	0x06, 0x61, 0x00, 0xA2, 0x36, 0x06, 0x1D, 0x01, 0x16, 0xD4, 0xC0, 0x23,
-	0x07, 0x41, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x1C, 0x06, 0x00, 0x33,
-	0x37, 0x00, 0xC2, 0x88, 0x1D, 0x01, 0x01, 0xD6, 0x20, 0x23, 0x63, 0x60,
-	0x83, 0x03, 0x80, 0x63, 0x02, 0x23, 0xDF, 0x00, 0x07, 0xA6, 0x7C, 0x05,
-	0xEF, 0x04, 0x6F, 0x00, 0x00, 0x63, 0x4B, 0x00, 0x06, 0x41, 0xCB, 0x00,
-	0x52, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x4E, 0x06, 0x1D, 0x01, 0x03, 0xCA,
-	0xC0, 0x23, 0x07, 0x41, 0x00, 0x63, 0x1D, 0x01, 0x04, 0xCC, 0x00, 0x33,
-	0x00, 0x83, 0xC0, 0x20, 0x81, 0x62, 0x80, 0x23, 0x07, 0x41, 0x00, 0x63,
-	0x80, 0x67, 0x08, 0x23, 0x83, 0x03, 0x80, 0x63, 0x00, 0x63, 0x01, 0x23,
-	0xDF, 0x00, 0x06, 0xA6, 0x84, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67,
-	0x80, 0x63, 0x00, 0x33, 0x00, 0x40, 0xC0, 0x20, 0x81, 0x62, 0x00, 0x63,
-	0x00, 0x00, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x94, 0x06,
-	0x07, 0xA6, 0x7C, 0x05, 0x00, 0x00, 0x01, 0xA0, 0x14, 0x07, 0x00, 0x2B,
-	0x40, 0x0E, 0x80, 0x63, 0x01, 0x00, 0x06, 0xA6, 0xAA, 0x06, 0x07, 0xA6,
-	0x7C, 0x05, 0x40, 0x0E, 0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0xA2, 0x06,
-	0x06, 0xA6, 0xBC, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67, 0x40, 0x0E,
-	0x80, 0x63, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63,
-	0x07, 0xA6, 0xD6, 0x06, 0x00, 0x33, 0x2A, 0x00, 0xC2, 0x88, 0x03, 0x03,
-	0x80, 0x63, 0x89, 0x00, 0x0A, 0x2B, 0x07, 0xA6, 0xE8, 0x06, 0x00, 0x33,
-	0x29, 0x00, 0xC2, 0x88, 0x00, 0x43, 0x00, 0xA2, 0xF4, 0x06, 0xC0, 0x0E,
-	0x80, 0x63, 0xDE, 0x86, 0xC0, 0x0E, 0x00, 0x33, 0x00, 0x80, 0xC0, 0x20,
-	0x81, 0x62, 0x04, 0x01, 0x02, 0xDA, 0x80, 0x63, 0x7C, 0x85, 0x80, 0x7B,
-	0x80, 0x63, 0x06, 0xA6, 0x8C, 0x06, 0x00, 0x33, 0x2C, 0x00, 0xC2, 0x88,
-	0x0C, 0xA2, 0x2E, 0x07, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6,
-	0x2C, 0x07, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x33, 0x3D, 0x00, 0xC2, 0x88,
-	0x00, 0x00, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0x0C, 0xA0, 0x44, 0x07,
-	0x07, 0xA6, 0x7C, 0x05, 0xBF, 0x23, 0x04, 0x61, 0x84, 0x01, 0xE6, 0x84,
-	0x00, 0x63, 0xF0, 0x04, 0x01, 0x01, 0xF1, 0x00, 0x00, 0x01, 0xF2, 0x00,
-	0x01, 0x05, 0x80, 0x01, 0x72, 0x04, 0x71, 0x00, 0x81, 0x01, 0x70, 0x04,
-	0x80, 0x05, 0x81, 0x05, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04,
-	0x01, 0x01, 0xF1, 0x00, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04, 0x71, 0x00,
-	0x81, 0x01, 0x72, 0x00, 0x80, 0x01, 0x71, 0x04, 0x70, 0x00, 0x80, 0x01,
-	0x70, 0x04, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x00, 0x01,
-	0xF1, 0x00, 0x70, 0x00, 0x80, 0x01, 0x70, 0x04, 0x71, 0x00, 0x80, 0x01,
-	0x72, 0x00, 0x81, 0x01, 0x71, 0x04, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04,
-	0x00, 0x63, 0x00, 0x23, 0xB3, 0x01, 0x83, 0x05, 0xA3, 0x01, 0xA2, 0x01,
-	0xA1, 0x01, 0x01, 0x23, 0xA0, 0x01, 0x00, 0x01, 0xC8, 0x00, 0x03, 0xA1,
-	0xC4, 0x07, 0x00, 0x33, 0x07, 0x00, 0xC2, 0x88, 0x80, 0x05, 0x81, 0x05,
-	0x04, 0x01, 0x11, 0xC8, 0x48, 0x00, 0xB0, 0x01, 0xB1, 0x01, 0x08, 0x23,
-	0xB2, 0x01, 0x05, 0x01, 0x48, 0x04, 0x00, 0x43, 0x00, 0xA2, 0xE4, 0x07,
-	0x00, 0x05, 0xDA, 0x87, 0x00, 0x01, 0xC8, 0x00, 0xFF, 0x23, 0x80, 0x01,
-	0x05, 0x05, 0x00, 0x63, 0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04,
-	0x00, 0x02, 0x80, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04, 0x00, 0x63,
-	0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04, 0x00, 0x02, 0x00, 0xA0,
-	0x14, 0x08, 0x16, 0x88, 0x00, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04,
-	0x00, 0x63, 0xF3, 0x04, 0x00, 0x23, 0xF4, 0x00, 0x74, 0x00, 0x80, 0x43,
-	0xF4, 0x00, 0xCF, 0x40, 0x00, 0xA2, 0x44, 0x08, 0x74, 0x04, 0x02, 0x01,
-	0xF7, 0xC9, 0xF6, 0xD9, 0x00, 0x01, 0x01, 0xA1, 0x24, 0x08, 0x04, 0x98,
-	0x26, 0x95, 0x24, 0x88, 0x73, 0x04, 0x00, 0x63, 0xF3, 0x04, 0x75, 0x04,
-	0x5A, 0x88, 0x02, 0x01, 0x04, 0xD8, 0x46, 0x97, 0x04, 0x98, 0x26, 0x95,
-	0x4A, 0x88, 0x75, 0x00, 0x00, 0xA3, 0x64, 0x08, 0x00, 0x05, 0x4E, 0x88,
-	0x73, 0x04, 0x00, 0x63, 0x80, 0x7B, 0x80, 0x63, 0x06, 0xA6, 0x76, 0x08,
-	0x00, 0x33, 0x3E, 0x00, 0xC2, 0x88, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63,
-	0x00, 0x63, 0x38, 0x2B, 0x9C, 0x88, 0x38, 0x2B, 0x92, 0x88, 0x32, 0x09,
-	0x31, 0x05, 0x92, 0x98, 0x05, 0x05, 0xB2, 0x09, 0x00, 0x63, 0x00, 0x32,
-	0x00, 0x36, 0x00, 0x3A, 0x00, 0x3E, 0x00, 0x63, 0x80, 0x32, 0x80, 0x36,
-	0x80, 0x3A, 0x80, 0x3E, 0xB4, 0x3D, 0x00, 0x63, 0x38, 0x2B, 0x40, 0x32,
-	0x40, 0x36, 0x40, 0x3A, 0x40, 0x3E, 0x00, 0x63, 0x5A, 0x20, 0xC9, 0x40,
-	0x00, 0xA0, 0xB4, 0x08, 0x5D, 0x00, 0xFE, 0xC3, 0x00, 0x63, 0x80, 0x73,
-	0xE6, 0x20, 0x02, 0x23, 0xE8, 0x00, 0x82, 0x73, 0xFF, 0xFD, 0x80, 0x73,
-	0x13, 0x23, 0xF8, 0x88, 0x66, 0x20, 0xC0, 0x20, 0x04, 0x23, 0xA0, 0x01,
-	0xA1, 0x23, 0xA1, 0x01, 0x81, 0x62, 0xE2, 0x88, 0x80, 0x73, 0x80, 0x77,
-	0x68, 0x00, 0x00, 0xA2, 0x80, 0x00, 0x03, 0xC2, 0xF1, 0xC7, 0x41, 0x23,
-	0xF8, 0x88, 0x11, 0x23, 0xA1, 0x01, 0x04, 0x23, 0xA0, 0x01, 0xE6, 0x84,
-};
-
-static ushort _asc_mcode_size = sizeof(_asc_mcode_buf);
-static ADV_DCNT _asc_mcode_chksum = 0x012C453FUL;
-
-#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16
-static uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] = {
-	INQUIRY,
-	REQUEST_SENSE,
-	READ_CAPACITY,
-	READ_TOC,
-	MODE_SELECT,
-	MODE_SENSE,
-	MODE_SELECT_10,
-	MODE_SENSE_10,
-	0xFF,
-	0xFF,
-	0xFF,
-	0xFF,
-	0xFF,
-	0xFF,
-	0xFF,
-	0xFF
-};
-
-static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
-{
-	PortAddr iop_base;
-	int sta;
-	int n_q_required;
-	int disable_syn_offset_one_fix;
-	int i;
-	ASC_PADDR addr;
-	ushort sg_entry_cnt = 0;
-	ushort sg_entry_cnt_minus_one = 0;
-	uchar target_ix;
-	uchar tid_no;
-	uchar sdtr_data;
-	uchar extra_bytes;
-	uchar scsi_cmd;
-	uchar disable_cmd;
-	ASC_SG_HEAD *sg_head;
-	ASC_DCNT data_cnt;
-
-	iop_base = asc_dvc->iop_base;
-	sg_head = scsiq->sg_head;
-	if (asc_dvc->err_code != 0)
-		return (ERR);
-	scsiq->q1.q_no = 0;
-	if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
-		scsiq->q1.extra_bytes = 0;
-	}
-	sta = 0;
-	target_ix = scsiq->q2.target_ix;
-	tid_no = ASC_TIX_TO_TID(target_ix);
-	n_q_required = 1;
-	if (scsiq->cdbptr[0] == REQUEST_SENSE) {
-		if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {
-			asc_dvc->sdtr_done &= ~scsiq->q1.target_id;
-			sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
-			AscMsgOutSDTR(asc_dvc,
-				      asc_dvc->
-				      sdtr_period_tbl[(sdtr_data >> 4) &
-						      (uchar)(asc_dvc->
-							      max_sdtr_index -
-							      1)],
-				      (uchar)(sdtr_data & (uchar)
-					      ASC_SYN_MAX_OFFSET));
-			scsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);
-		}
-	}
-	if (asc_dvc->in_critical_cnt != 0) {
-		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
-		return (ERR);
-	}
-	asc_dvc->in_critical_cnt++;
-	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
-		if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
-			asc_dvc->in_critical_cnt--;
-			return (ERR);
-		}
-#if !CC_VERY_LONG_SG_LIST
-		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
-			asc_dvc->in_critical_cnt--;
-			return (ERR);
-		}
-#endif /* !CC_VERY_LONG_SG_LIST */
-		if (sg_entry_cnt == 1) {
-			scsiq->q1.data_addr =
-			    (ADV_PADDR)sg_head->sg_list[0].addr;
-			scsiq->q1.data_cnt =
-			    (ADV_DCNT)sg_head->sg_list[0].bytes;
-			scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
-		}
-		sg_entry_cnt_minus_one = sg_entry_cnt - 1;
-	}
-	scsi_cmd = scsiq->cdbptr[0];
-	disable_syn_offset_one_fix = FALSE;
-	if ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&
-	    !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {
-		if (scsiq->q1.cntl & QC_SG_HEAD) {
-			data_cnt = 0;
-			for (i = 0; i < sg_entry_cnt; i++) {
-				data_cnt +=
-				    (ADV_DCNT)le32_to_cpu(sg_head->sg_list[i].
-							  bytes);
-			}
-		} else {
-			data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
-		}
-		if (data_cnt != 0UL) {
-			if (data_cnt < 512UL) {
-				disable_syn_offset_one_fix = TRUE;
-			} else {
-				for (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;
-				     i++) {
-					disable_cmd =
-					    _syn_offset_one_disable_cmd[i];
-					if (disable_cmd == 0xFF) {
-						break;
-					}
-					if (scsi_cmd == disable_cmd) {
-						disable_syn_offset_one_fix =
-						    TRUE;
-						break;
-					}
-				}
-			}
-		}
-	}
-	if (disable_syn_offset_one_fix) {
-		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
-		scsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
-				       ASC_TAG_FLAG_DISABLE_DISCONNECT);
-	} else {
-		scsiq->q2.tag_code &= 0x27;
-	}
-	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
-		if (asc_dvc->bug_fix_cntl) {
-			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
-				if ((scsi_cmd == READ_6) ||
-				    (scsi_cmd == READ_10)) {
-					addr =
-					    (ADV_PADDR)le32_to_cpu(sg_head->
-								   sg_list
-								   [sg_entry_cnt_minus_one].
-								   addr) +
-					    (ADV_DCNT)le32_to_cpu(sg_head->
-								  sg_list
-								  [sg_entry_cnt_minus_one].
-								  bytes);
-					extra_bytes =
-					    (uchar)((ushort)addr & 0x0003);
-					if ((extra_bytes != 0)
-					    &&
-					    ((scsiq->q2.
-					      tag_code &
-					      ASC_TAG_FLAG_EXTRA_BYTES)
-					     == 0)) {
-						scsiq->q2.tag_code |=
-						    ASC_TAG_FLAG_EXTRA_BYTES;
-						scsiq->q1.extra_bytes =
-						    extra_bytes;
-						data_cnt =
-						    le32_to_cpu(sg_head->
-								sg_list
-								[sg_entry_cnt_minus_one].
-								bytes);
-						data_cnt -=
-						    (ASC_DCNT) extra_bytes;
-						sg_head->
-						    sg_list
-						    [sg_entry_cnt_minus_one].
-						    bytes =
-						    cpu_to_le32(data_cnt);
-					}
-				}
-			}
-		}
-		sg_head->entry_to_copy = sg_head->entry_cnt;
-#if CC_VERY_LONG_SG_LIST
-		/*
-		 * Set the sg_entry_cnt to the maximum possible. The rest of
-		 * the SG elements will be copied when the RISC completes the
-		 * SG elements that fit and halts.
-		 */
-		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
-			sg_entry_cnt = ASC_MAX_SG_LIST;
-		}
-#endif /* CC_VERY_LONG_SG_LIST */
-		n_q_required = AscSgListToQueue(sg_entry_cnt);
-		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=
-		     (uint) n_q_required)
-		    || ((scsiq->q1.cntl & QC_URGENT) != 0)) {
-			if ((sta =
-			     AscSendScsiQueue(asc_dvc, scsiq,
-					      n_q_required)) == 1) {
-				asc_dvc->in_critical_cnt--;
-				return (sta);
-			}
-		}
-	} else {
-		if (asc_dvc->bug_fix_cntl) {
-			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
-				if ((scsi_cmd == READ_6) ||
-				    (scsi_cmd == READ_10)) {
-					addr =
-					    le32_to_cpu(scsiq->q1.data_addr) +
-					    le32_to_cpu(scsiq->q1.data_cnt);
-					extra_bytes =
-					    (uchar)((ushort)addr & 0x0003);
-					if ((extra_bytes != 0)
-					    &&
-					    ((scsiq->q2.
-					      tag_code &
-					      ASC_TAG_FLAG_EXTRA_BYTES)
-					     == 0)) {
-						data_cnt =
-						    le32_to_cpu(scsiq->q1.
-								data_cnt);
-						if (((ushort)data_cnt & 0x01FF)
-						    == 0) {
-							scsiq->q2.tag_code |=
-							    ASC_TAG_FLAG_EXTRA_BYTES;
-							data_cnt -= (ASC_DCNT)
-							    extra_bytes;
-							scsiq->q1.data_cnt =
-							    cpu_to_le32
-							    (data_cnt);
-							scsiq->q1.extra_bytes =
-							    extra_bytes;
-						}
-					}
-				}
-			}
-		}
-		n_q_required = 1;
-		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||
-		    ((scsiq->q1.cntl & QC_URGENT) != 0)) {
-			if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
-						    n_q_required)) == 1) {
-				asc_dvc->in_critical_cnt--;
-				return (sta);
-			}
-		}
-	}
-	asc_dvc->in_critical_cnt--;
-	return (sta);
-}
-
-static int
-AscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)
-{
-	PortAddr iop_base;
-	uchar free_q_head;
-	uchar next_qp;
-	uchar tid_no;
-	uchar target_ix;
-	int sta;
-
-	iop_base = asc_dvc->iop_base;
-	target_ix = scsiq->q2.target_ix;
-	tid_no = ASC_TIX_TO_TID(target_ix);
-	sta = 0;
-	free_q_head = (uchar)AscGetVarFreeQHead(iop_base);
-	if (n_q_required > 1) {
-		next_qp = AscAllocMultipleFreeQueue(iop_base, free_q_head,
-						    (uchar)n_q_required);
-		if (next_qp != ASC_QLINK_END) {
-			asc_dvc->last_q_shortage = 0;
-			scsiq->sg_head->queue_cnt = n_q_required - 1;
-			scsiq->q1.q_no = free_q_head;
-			sta = AscPutReadySgListQueue(asc_dvc, scsiq,
-						     free_q_head);
-		}
-	} else if (n_q_required == 1) {
-		next_qp = AscAllocFreeQueue(iop_base, free_q_head);
-		if (next_qp != ASC_QLINK_END) {
-			scsiq->q1.q_no = free_q_head;
-			sta = AscPutReadyQueue(asc_dvc, scsiq, free_q_head);
-		}
-	}
-	if (sta == 1) {
-		AscPutVarFreeQHead(iop_base, next_qp);
-		asc_dvc->cur_total_qng += (uchar)(n_q_required);
-		asc_dvc->cur_dvc_qng[tid_no]++;
-	}
-	return sta;
-}
-
-static int AscSgListToQueue(int sg_list)
-{
-	int n_sg_list_qs;
-
-	n_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);
-	if (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)
-		n_sg_list_qs++;
-	return (n_sg_list_qs + 1);
-}
-
-static uint
-AscGetNumOfFreeQueue(ASC_DVC_VAR *asc_dvc, uchar target_ix, uchar n_qs)
-{
-	uint cur_used_qs;
-	uint cur_free_qs;
-	ASC_SCSI_BIT_ID_TYPE target_id;
-	uchar tid_no;
-
-	target_id = ASC_TIX_TO_TARGET_ID(target_ix);
-	tid_no = ASC_TIX_TO_TID(target_ix);
-	if ((asc_dvc->unit_not_ready & target_id) ||
-	    (asc_dvc->queue_full_or_busy & target_id)) {
-		return (0);
-	}
-	if (n_qs == 1) {
-		cur_used_qs = (uint) asc_dvc->cur_total_qng +
-		    (uint) asc_dvc->last_q_shortage + (uint) ASC_MIN_FREE_Q;
-	} else {
-		cur_used_qs = (uint) asc_dvc->cur_total_qng +
-		    (uint) ASC_MIN_FREE_Q;
-	}
-	if ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {
-		cur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;
-		if (asc_dvc->cur_dvc_qng[tid_no] >=
-		    asc_dvc->max_dvc_qng[tid_no]) {
-			return (0);
-		}
-		return (cur_free_qs);
-	}
-	if (n_qs > 1) {
-		if ((n_qs > asc_dvc->last_q_shortage)
-		    && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {
-			asc_dvc->last_q_shortage = n_qs;
-		}
-	}
-	return (0);
-}
-
-static int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
-{
-	ushort q_addr;
-	uchar tid_no;
-	uchar sdtr_data;
-	uchar syn_period_ix;
-	uchar syn_offset;
-	PortAddr iop_base;
-
-	iop_base = asc_dvc->iop_base;
-	if (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&
-	    ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {
-		tid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);
-		sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
-		syn_period_ix =
-		    (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);
-		syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;
-		AscMsgOutSDTR(asc_dvc,
-			      asc_dvc->sdtr_period_tbl[syn_period_ix],
-			      syn_offset);
-		scsiq->q1.cntl |= QC_MSG_OUT;
-	}
-	q_addr = ASC_QNO_TO_QADDR(q_no);
-	if ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {
-		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
-	}
-	scsiq->q1.status = QS_FREE;
-	AscMemWordCopyPtrToLram(iop_base,
-				q_addr + ASC_SCSIQ_CDB_BEG,
-				(uchar *)scsiq->cdbptr, scsiq->q2.cdb_len >> 1);
-
-	DvcPutScsiQ(iop_base,
-		    q_addr + ASC_SCSIQ_CPY_BEG,
-		    (uchar *)&scsiq->q1.cntl,
-		    ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);
-	AscWriteLramWord(iop_base,
-			 (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS),
-			 (ushort)(((ushort)scsiq->q1.
-				   q_no << 8) | (ushort)QS_READY));
-	return (1);
-}
-
-static int
-AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
-{
-	int sta;
-	int i;
-	ASC_SG_HEAD *sg_head;
-	ASC_SG_LIST_Q scsi_sg_q;
-	ASC_DCNT saved_data_addr;
-	ASC_DCNT saved_data_cnt;
-	PortAddr iop_base;
-	ushort sg_list_dwords;
-	ushort sg_index;
-	ushort sg_entry_cnt;
-	ushort q_addr;
-	uchar next_qp;
-
-	iop_base = asc_dvc->iop_base;
-	sg_head = scsiq->sg_head;
-	saved_data_addr = scsiq->q1.data_addr;
-	saved_data_cnt = scsiq->q1.data_cnt;
-	scsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;
-	scsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;
-#if CC_VERY_LONG_SG_LIST
-	/*
-	 * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
-	 * then not all SG elements will fit in the allocated queues.
-	 * The rest of the SG elements will be copied when the RISC
-	 * completes the SG elements that fit and halts.
-	 */
-	if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
-		/*
-		 * Set sg_entry_cnt to be the number of SG elements that
-		 * will fit in the allocated SG queues. It is minus 1, because
-		 * the first SG element is handled above. ASC_MAX_SG_LIST is
-		 * already inflated by 1 to account for this. For example it
-		 * may be 50 which is 1 + 7 queues * 7 SG elements.
-		 */
-		sg_entry_cnt = ASC_MAX_SG_LIST - 1;
-
-		/*
-		 * Keep track of remaining number of SG elements that will
-		 * need to be handled from a_isr.c.
-		 */
-		scsiq->remain_sg_entry_cnt =
-		    sg_head->entry_cnt - ASC_MAX_SG_LIST;
-	} else {
-#endif /* CC_VERY_LONG_SG_LIST */
-		/*
-		 * Set sg_entry_cnt to be the number of SG elements that
-		 * will fit in the allocated SG queues. It is minus 1, because
-		 * the first SG element is handled above.
-		 */
-		sg_entry_cnt = sg_head->entry_cnt - 1;
-#if CC_VERY_LONG_SG_LIST
-	}
-#endif /* CC_VERY_LONG_SG_LIST */
-	if (sg_entry_cnt != 0) {
-		scsiq->q1.cntl |= QC_SG_HEAD;
-		q_addr = ASC_QNO_TO_QADDR(q_no);
-		sg_index = 1;
-		scsiq->q1.sg_queue_cnt = sg_head->queue_cnt;
-		scsi_sg_q.sg_head_qp = q_no;
-		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
-		for (i = 0; i < sg_head->queue_cnt; i++) {
-			scsi_sg_q.seq_no = i + 1;
-			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
-				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
-				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
-				if (i == 0) {
-					scsi_sg_q.sg_list_cnt =
-					    ASC_SG_LIST_PER_Q;
-					scsi_sg_q.sg_cur_list_cnt =
-					    ASC_SG_LIST_PER_Q;
-				} else {
-					scsi_sg_q.sg_list_cnt =
-					    ASC_SG_LIST_PER_Q - 1;
-					scsi_sg_q.sg_cur_list_cnt =
-					    ASC_SG_LIST_PER_Q - 1;
-				}
-			} else {
-#if CC_VERY_LONG_SG_LIST
-				/*
-				 * This is the last SG queue in the list of
-				 * allocated SG queues. If there are more
-				 * SG elements than will fit in the allocated
-				 * queues, then set the QCSG_SG_XFER_MORE flag.
-				 */
-				if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
-					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
-				} else {
-#endif /* CC_VERY_LONG_SG_LIST */
-					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
-#if CC_VERY_LONG_SG_LIST
-				}
-#endif /* CC_VERY_LONG_SG_LIST */
-				sg_list_dwords = sg_entry_cnt << 1;
-				if (i == 0) {
-					scsi_sg_q.sg_list_cnt = sg_entry_cnt;
-					scsi_sg_q.sg_cur_list_cnt =
-					    sg_entry_cnt;
-				} else {
-					scsi_sg_q.sg_list_cnt =
-					    sg_entry_cnt - 1;
-					scsi_sg_q.sg_cur_list_cnt =
-					    sg_entry_cnt - 1;
-				}
-				sg_entry_cnt = 0;
-			}
-			next_qp = AscReadLramByte(iop_base,
-						  (ushort)(q_addr +
-							   ASC_SCSIQ_B_FWD));
-			scsi_sg_q.q_no = next_qp;
-			q_addr = ASC_QNO_TO_QADDR(next_qp);
-			AscMemWordCopyPtrToLram(iop_base,
-						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
-						(uchar *)&scsi_sg_q,
-						sizeof(ASC_SG_LIST_Q) >> 1);
-			AscMemDWordCopyPtrToLram(iop_base,
-						 q_addr + ASC_SGQ_LIST_BEG,
-						 (uchar *)&sg_head->
-						 sg_list[sg_index],
-						 sg_list_dwords);
-			sg_index += ASC_SG_LIST_PER_Q;
-			scsiq->next_sg_index = sg_index;
-		}
-	} else {
-		scsiq->q1.cntl &= ~QC_SG_HEAD;
-	}
-	sta = AscPutReadyQueue(asc_dvc, scsiq, q_no);
-	scsiq->q1.data_addr = saved_data_addr;
-	scsiq->q1.data_cnt = saved_data_cnt;
-	return (sta);
-}
-
-static int
-AscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)
-{
-	int sta = FALSE;
-
-	if (AscHostReqRiscHalt(iop_base)) {
-		sta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
-		AscStartChip(iop_base);
-		return (sta);
-	}
-	return (sta);
-}
-
-static int AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)
-{
-	ASC_SCSI_BIT_ID_TYPE org_id;
-	int i;
-	int sta = TRUE;
-
-	AscSetBank(iop_base, 1);
-	org_id = AscReadChipDvcID(iop_base);
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		if (org_id == (0x01 << i))
-			break;
-	}
-	org_id = (ASC_SCSI_BIT_ID_TYPE) i;
-	AscWriteChipDvcID(iop_base, id);
-	if (AscReadChipDvcID(iop_base) == (0x01 << id)) {
-		AscSetBank(iop_base, 0);
-		AscSetChipSyn(iop_base, sdtr_data);
-		if (AscGetChipSyn(iop_base) != sdtr_data) {
-			sta = FALSE;
-		}
-	} else {
-		sta = FALSE;
-	}
-	AscSetBank(iop_base, 1);
-	AscWriteChipDvcID(iop_base, org_id);
-	AscSetBank(iop_base, 0);
-	return (sta);
-}
-
-static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
-{
-	uchar i;
-	ushort s_addr;
-	PortAddr iop_base;
-	ushort warn_code;
-
-	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
-	AscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,
-			  (ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *
-				    64) >> 1)
-	    );
-	i = ASC_MIN_ACTIVE_QNO;
-	s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;
-	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
-			 (uchar)(i + 1));
-	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
-			 (uchar)(asc_dvc->max_total_qng));
-	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
-			 (uchar)i);
-	i++;
-	s_addr += ASC_QBLK_SIZE;
-	for (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {
-		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
-				 (uchar)(i + 1));
-		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
-				 (uchar)(i - 1));
-		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
-				 (uchar)i);
-	}
-	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
-			 (uchar)ASC_QLINK_END);
-	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
-			 (uchar)(asc_dvc->max_total_qng - 1));
-	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
-			 (uchar)asc_dvc->max_total_qng);
-	i++;
-	s_addr += ASC_QBLK_SIZE;
-	for (; i <= (uchar)(asc_dvc->max_total_qng + 3);
-	     i++, s_addr += ASC_QBLK_SIZE) {
-		AscWriteLramByte(iop_base,
-				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_FWD), i);
-		AscWriteLramByte(iop_base,
-				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_BWD), i);
-		AscWriteLramByte(iop_base,
-				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);
-	}
-	return (warn_code);
-}
-
-static void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
-{
-	PortAddr iop_base;
-	int i;
-	ushort lram_addr;
-
-	iop_base = asc_dvc->iop_base;
-	AscPutRiscVarFreeQHead(iop_base, 1);
-	AscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);
-	AscPutVarFreeQHead(iop_base, 1);
-	AscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);
-	AscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,
-			 (uchar)((int)asc_dvc->max_total_qng + 1));
-	AscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,
-			 (uchar)((int)asc_dvc->max_total_qng + 2));
-	AscWriteLramByte(iop_base, (ushort)ASCV_TOTAL_READY_Q_B,
-			 asc_dvc->max_total_qng);
-	AscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);
-	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);
-	AscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);
-	AscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);
-	AscPutQDoneInProgress(iop_base, 0);
-	lram_addr = ASC_QADR_BEG;
-	for (i = 0; i < 32; i++, lram_addr += 2) {
-		AscWriteLramWord(iop_base, lram_addr, 0);
-	}
-}
-
-static int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)
-{
-	if (asc_dvc->err_code == 0) {
-		asc_dvc->err_code = err_code;
-		AscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
-				 err_code);
-	}
-	return (err_code);
-}
-
-static uchar
-AscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)
-{
-	EXT_MSG sdtr_buf;
-	uchar sdtr_period_index;
-	PortAddr iop_base;
-
-	iop_base = asc_dvc->iop_base;
-	sdtr_buf.msg_type = EXTENDED_MESSAGE;
-	sdtr_buf.msg_len = MS_SDTR_LEN;
-	sdtr_buf.msg_req = EXTENDED_SDTR;
-	sdtr_buf.xfer_period = sdtr_period;
-	sdtr_offset &= ASC_SYN_MAX_OFFSET;
-	sdtr_buf.req_ack_offset = sdtr_offset;
-	if ((sdtr_period_index =
-	     AscGetSynPeriodIndex(asc_dvc, sdtr_period)) <=
-	    asc_dvc->max_sdtr_index) {
-		AscMemWordCopyPtrToLram(iop_base,
-					ASCV_MSGOUT_BEG,
-					(uchar *)&sdtr_buf,
-					sizeof(EXT_MSG) >> 1);
-		return ((sdtr_period_index << 4) | sdtr_offset);
-	} else {
-
-		sdtr_buf.req_ack_offset = 0;
-		AscMemWordCopyPtrToLram(iop_base,
-					ASCV_MSGOUT_BEG,
-					(uchar *)&sdtr_buf,
-					sizeof(EXT_MSG) >> 1);
-		return (0);
-	}
-}
-
-static uchar
-AscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)
-{
-	uchar byte;
-	uchar sdtr_period_ix;
-
-	sdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
-	if ((sdtr_period_ix > asc_dvc->max_sdtr_index)
-	    ) {
-		return (0xFF);
-	}
-	byte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);
-	return (byte);
-}
-
-static void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)
-{
-	AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
-	AscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);
-	return;
-}
-
-static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)
-{
-	uchar *period_table;
-	int max_index;
-	int min_index;
-	int i;
-
-	period_table = asc_dvc->sdtr_period_tbl;
-	max_index = (int)asc_dvc->max_sdtr_index;
-	min_index = (int)asc_dvc->host_init_sdtr_index;
-	if ((syn_time <= period_table[max_index])) {
-		for (i = min_index; i < (max_index - 1); i++) {
-			if (syn_time <= period_table[i]) {
-				return ((uchar)i);
-			}
-		}
-		return ((uchar)max_index);
-	} else {
-		return ((uchar)(max_index + 1));
-	}
-}
-
-static uchar AscAllocFreeQueue(PortAddr iop_base, uchar free_q_head)
-{
-	ushort q_addr;
-	uchar next_qp;
-	uchar q_status;
-
-	q_addr = ASC_QNO_TO_QADDR(free_q_head);
-	q_status = (uchar)AscReadLramByte(iop_base,
-					  (ushort)(q_addr +
-						   ASC_SCSIQ_B_STATUS));
-	next_qp = AscReadLramByte(iop_base, (ushort)(q_addr + ASC_SCSIQ_B_FWD));
-	if (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END)) {
-		return (next_qp);
-	}
-	return (ASC_QLINK_END);
-}
-
-static uchar
-AscAllocMultipleFreeQueue(PortAddr iop_base, uchar free_q_head, uchar n_free_q)
-{
-	uchar i;
-
-	for (i = 0; i < n_free_q; i++) {
-		if ((free_q_head = AscAllocFreeQueue(iop_base, free_q_head))
-		    == ASC_QLINK_END) {
-			return (ASC_QLINK_END);
-		}
-	}
-	return (free_q_head);
-}
-
-static int AscHostReqRiscHalt(PortAddr iop_base)
-{
-	int count = 0;
-	int sta = 0;
-	uchar saved_stop_code;
-
-	if (AscIsChipHalted(iop_base))
-		return (1);
-	saved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);
-	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
-			 ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);
-	do {
-		if (AscIsChipHalted(iop_base)) {
-			sta = 1;
-			break;
-		}
-		mdelay(100);
-	} while (count++ < 20);
-	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
-	return (sta);
-}
-
-static int AscStopQueueExe(PortAddr iop_base)
-{
-	int count = 0;
-
-	if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {
-		AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
-				 ASC_STOP_REQ_RISC_STOP);
-		do {
-			if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &
-			    ASC_STOP_ACK_RISC_STOP) {
-				return (1);
-			}
-			mdelay(100);
-		} while (count++ < 20);
-	}
-	return (0);
-}
-
-static int AscStartChip(PortAddr iop_base)
-{
-	AscSetChipControl(iop_base, 0);
-	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
-		return (0);
-	}
-	return (1);
-}
-
-static int AscStopChip(PortAddr iop_base)
-{
-	uchar cc_val;
-
-	cc_val =
-	    AscGetChipControl(iop_base) &
-	    (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));
-	AscSetChipControl(iop_base, (uchar)(cc_val | CC_HALT));
-	AscSetChipIH(iop_base, INS_HALT);
-	AscSetChipIH(iop_base, INS_RFLAG_WTM);
-	if ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {
-		return (0);
-	}
-	return (1);
-}
-
-static int AscIsChipHalted(PortAddr iop_base)
-{
-	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
-		if ((AscGetChipControl(iop_base) & CC_HALT) != 0) {
-			return (1);
-		}
-	}
-	return (0);
-}
-
-static void AscSetChipIH(PortAddr iop_base, ushort ins_code)
-{
-	AscSetBank(iop_base, 1);
-	AscWriteChipIH(iop_base, ins_code);
-	AscSetBank(iop_base, 0);
-	return;
-}
-
-static void AscAckInterrupt(PortAddr iop_base)
-{
-	uchar host_flag;
-	uchar risc_flag;
-	ushort loop;
-
-	loop = 0;
-	do {
-		risc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);
-		if (loop++ > 0x7FFF) {
-			break;
-		}
-	} while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);
-	host_flag =
-	    AscReadLramByte(iop_base,
-			    ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);
-	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
-			 (uchar)(host_flag | ASC_HOST_FLAG_ACK_INT));
-	AscSetChipStatus(iop_base, CIW_INT_ACK);
-	loop = 0;
-	while (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {
-		AscSetChipStatus(iop_base, CIW_INT_ACK);
-		if (loop++ > 3) {
-			break;
-		}
-	}
-	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
-	return;
-}
-
-static void AscDisableInterrupt(PortAddr iop_base)
-{
-	ushort cfg;
-
-	cfg = AscGetChipCfgLsw(iop_base);
-	AscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));
-	return;
-}
-
-static void AscEnableInterrupt(PortAddr iop_base)
-{
-	ushort cfg;
-
-	cfg = AscGetChipCfgLsw(iop_base);
-	AscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);
-	return;
-}
-
-static void AscSetBank(PortAddr iop_base, uchar bank)
-{
-	uchar val;
-
-	val = AscGetChipControl(iop_base) &
-	    (~
-	     (CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET |
-	      CC_CHIP_RESET));
-	if (bank == 1) {
-		val |= CC_BANK_ONE;
-	} else if (bank == 2) {
-		val |= CC_DIAG | CC_BANK_ONE;
-	} else {
-		val &= ~CC_BANK_ONE;
-	}
-	AscSetChipControl(iop_base, val);
-	return;
-}
-
-static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
-{
-	PortAddr iop_base;
-	int i = 10;
-
-	iop_base = asc_dvc->iop_base;
-	while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)
-	       && (i-- > 0)) {
-		mdelay(100);
-	}
-	AscStopChip(iop_base);
-	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);
-	udelay(60);
-	AscSetChipIH(iop_base, INS_RFLAG_WTM);
-	AscSetChipIH(iop_base, INS_HALT);
-	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);
-	AscSetChipControl(iop_base, CC_HALT);
-	mdelay(200);
-	AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
-	AscSetChipStatus(iop_base, 0);
-	return (AscIsChipHalted(iop_base));
-}
-
-static ASC_DCNT __devinit AscGetMaxDmaCount(ushort bus_type)
-{
-	if (bus_type & ASC_IS_ISA)
-		return ASC_MAX_ISA_DMA_COUNT;
-	else if (bus_type & (ASC_IS_EISA | ASC_IS_VL))
-		return ASC_MAX_VL_DMA_COUNT;
-	return ASC_MAX_PCI_DMA_COUNT;
-}
-
-#ifdef CONFIG_ISA
-static ushort __devinit AscGetIsaDmaChannel(PortAddr iop_base)
-{
-	ushort channel;
-
-	channel = AscGetChipCfgLsw(iop_base) & 0x0003;
-	if (channel == 0x03)
-		return (0);
-	else if (channel == 0x00)
-		return (7);
-	return (channel + 4);
-}
-
-static ushort __devinit AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
-{
-	ushort cfg_lsw;
-	uchar value;
-
-	if ((dma_channel >= 5) && (dma_channel <= 7)) {
-		if (dma_channel == 7)
-			value = 0x00;
-		else
-			value = dma_channel - 4;
-		cfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;
-		cfg_lsw |= value;
-		AscSetChipCfgLsw(iop_base, cfg_lsw);
-		return (AscGetIsaDmaChannel(iop_base));
-	}
-	return (0);
-}
-
-static uchar __devinit AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
-{
-	speed_value &= 0x07;
-	AscSetBank(iop_base, 1);
-	AscWriteChipDmaSpeed(iop_base, speed_value);
-	AscSetBank(iop_base, 0);
-	return (AscGetIsaDmaSpeed(iop_base));
-}
-
-static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
-{
-	uchar speed_value;
-
-	AscSetBank(iop_base, 1);
-	speed_value = AscReadChipDmaSpeed(iop_base);
-	speed_value &= 0x07;
-	AscSetBank(iop_base, 0);
-	return (speed_value);
-}
-#endif /* CONFIG_ISA */
-
-static int __devinit AscInitGetConfig(asc_board_t *boardp)
-{
-	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
-	unsigned short warn_code = 0;
-
-	asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
-	if (asc_dvc->err_code != 0)
-		return asc_dvc->err_code;
-
-	if (AscFindSignature(asc_dvc->iop_base)) {
-		warn_code |= AscInitAscDvcVar(asc_dvc);
-		warn_code |= AscInitFromEEP(asc_dvc);
-		asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
-		if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)
-			asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
-	} else {
-		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-	}
-
-	switch (warn_code) {
-	case 0:	/* No error */
-		break;
-	case ASC_WARN_IO_PORT_ROTATE:
-		ASC_PRINT1("AscInitGetConfig: board %d: I/O port address "
-			   "modified\n", boardp->id);
-		break;
-	case ASC_WARN_AUTO_CONFIG:
-		ASC_PRINT1("AscInitGetConfig: board %d: I/O port increment "
-			   "switch enabled\n", boardp->id);
-		break;
-	case ASC_WARN_EEPROM_CHKSUM:
-		ASC_PRINT1("AscInitGetConfig: board %d: EEPROM checksum "
-			   "error\n", boardp->id);
-		break;
-	case ASC_WARN_IRQ_MODIFIED:
-		ASC_PRINT1("AscInitGetConfig: board %d: IRQ modified\n",
-			   boardp->id);
-		break;
-	case ASC_WARN_CMD_QNG_CONFLICT:
-		ASC_PRINT1("AscInitGetConfig: board %d: tag queuing enabled "
-			   "w/o disconnects\n", boardp->id);
-		break;
-	default:
-		ASC_PRINT2("AscInitGetConfig: board %d: unknown warning: "
-			   "0x%x\n", boardp->id, warn_code);
-		break;
-	}
-
-	if (asc_dvc->err_code != 0) {
-		ASC_PRINT3("AscInitGetConfig: board %d error: init_state 0x%x, "
-			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
-			   asc_dvc->err_code);
-	}
-
-	return asc_dvc->err_code;
-}
-
-static int __devinit AscInitSetConfig(struct pci_dev *pdev, asc_board_t *boardp)
-{
-	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
-	PortAddr iop_base = asc_dvc->iop_base;
-	unsigned short cfg_msw;
-	unsigned short warn_code = 0;
-
-	asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
-	if (asc_dvc->err_code != 0)
-		return asc_dvc->err_code;
-	if (!AscFindSignature(asc_dvc->iop_base)) {
-		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-		return asc_dvc->err_code;
-	}
-
-	cfg_msw = AscGetChipCfgMsw(iop_base);
-	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
-		cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
-		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
-		AscSetChipCfgMsw(iop_base, cfg_msw);
-	}
-	if ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=
-	    asc_dvc->cfg->cmd_qng_enabled) {
-		asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;
-		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
-	}
-	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
-		warn_code |= ASC_WARN_AUTO_CONFIG;
-	}
-	if ((asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {
-		if (AscSetChipIRQ(iop_base, asc_dvc->irq_no, asc_dvc->bus_type)
-		    != asc_dvc->irq_no) {
-			asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
-		}
-	}
-#ifdef CONFIG_PCI
-	if (asc_dvc->bus_type & ASC_IS_PCI) {
-		cfg_msw &= 0xFFC0;
-		AscSetChipCfgMsw(iop_base, cfg_msw);
-		if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
-		} else {
-			if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
-			    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
-				asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
-				asc_dvc->bug_fix_cntl |=
-				    ASC_BUG_FIX_ASYN_USE_SYN;
-			}
-		}
-	} else
-#endif /* CONFIG_PCI */
-	if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
-		if (AscGetChipVersion(iop_base, asc_dvc->bus_type)
-		    == ASC_CHIP_VER_ASYN_BUG) {
-			asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
-		}
-	}
-	if (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=
-	    asc_dvc->cfg->chip_scsi_id) {
-		asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;
-	}
-#ifdef CONFIG_ISA
-	if (asc_dvc->bus_type & ASC_IS_ISA) {
-		AscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);
-		AscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);
-	}
-#endif /* CONFIG_ISA */
-
-	asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
-
-	switch (warn_code) {
-	case 0:	/* No error. */
-		break;
-	case ASC_WARN_IO_PORT_ROTATE:
-		ASC_PRINT1("AscInitSetConfig: board %d: I/O port address "
-			   "modified\n", boardp->id);
-		break;
-	case ASC_WARN_AUTO_CONFIG:
-		ASC_PRINT1("AscInitSetConfig: board %d: I/O port increment "
-			   "switch enabled\n", boardp->id);
-		break;
-	case ASC_WARN_EEPROM_CHKSUM:
-		ASC_PRINT1("AscInitSetConfig: board %d: EEPROM checksum "
-			   "error\n", boardp->id);
-		break;
-	case ASC_WARN_IRQ_MODIFIED:
-		ASC_PRINT1("AscInitSetConfig: board %d: IRQ modified\n",
-			   boardp->id);
-		break;
-	case ASC_WARN_CMD_QNG_CONFLICT:
-		ASC_PRINT1("AscInitSetConfig: board %d: tag queuing w/o "
-			   "disconnects\n",
-		     boardp->id);
-		break;
-	default:
-		ASC_PRINT2("AscInitSetConfig: board %d: unknown warning: "
-			   "0x%x\n", boardp->id, warn_code);
-		break;
-	}
-
-	if (asc_dvc->err_code != 0) {
-		ASC_PRINT3("AscInitSetConfig: board %d error: init_state 0x%x, "
-			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
-			   asc_dvc->err_code);
-	}
-
-	return asc_dvc->err_code;
-}
-
-static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
-{
-	ushort warn_code;
-	PortAddr iop_base;
-
-	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
-	if ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&
-	    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {
-		AscResetChipAndScsiBus(asc_dvc);
-		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
-	}
-	asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
-	if (asc_dvc->err_code != 0)
-		return (UW_ERR);
-	if (!AscFindSignature(asc_dvc->iop_base)) {
-		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-		return (warn_code);
-	}
-	AscDisableInterrupt(iop_base);
-	warn_code |= AscInitLram(asc_dvc);
-	if (asc_dvc->err_code != 0)
-		return (UW_ERR);
-	ASC_DBG1(1, "AscInitAsc1000Driver: _asc_mcode_chksum 0x%lx\n",
-		 (ulong)_asc_mcode_chksum);
-	if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
-			     _asc_mcode_size) != _asc_mcode_chksum) {
-		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
-		return (warn_code);
-	}
-	warn_code |= AscInitMicroCodeVar(asc_dvc);
-	asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
-	AscEnableInterrupt(iop_base);
-	return (warn_code);
-}
-
-static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
-{
-	int i;
-	PortAddr iop_base;
-	ushort warn_code;
-	uchar chip_version;
-
-	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
-	asc_dvc->err_code = 0;
-	if ((asc_dvc->bus_type &
-	     (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {
-		asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;
-	}
-	AscSetChipControl(iop_base, CC_HALT);
-	AscSetChipStatus(iop_base, 0);
-	asc_dvc->bug_fix_cntl = 0;
-	asc_dvc->pci_fix_asyn_xfer = 0;
-	asc_dvc->pci_fix_asyn_xfer_always = 0;
-	/* asc_dvc->init_state initalized in AscInitGetConfig(). */
-	asc_dvc->sdtr_done = 0;
-	asc_dvc->cur_total_qng = 0;
-	asc_dvc->is_in_int = 0;
-	asc_dvc->in_critical_cnt = 0;
-	asc_dvc->last_q_shortage = 0;
-	asc_dvc->use_tagged_qng = 0;
-	asc_dvc->no_scam = 0;
-	asc_dvc->unit_not_ready = 0;
-	asc_dvc->queue_full_or_busy = 0;
-	asc_dvc->redo_scam = 0;
-	asc_dvc->res2 = 0;
-	asc_dvc->host_init_sdtr_index = 0;
-	asc_dvc->cfg->can_tagged_qng = 0;
-	asc_dvc->cfg->cmd_qng_enabled = 0;
-	asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;
-	asc_dvc->init_sdtr = 0;
-	asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;
-	asc_dvc->scsi_reset_wait = 3;
-	asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;
-	asc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);
-	asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;
-	asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;
-	asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
-	asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER;
-	asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
-	    ASC_LIB_VERSION_MINOR;
-	chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
-	asc_dvc->cfg->chip_version = chip_version;
-	asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
-	asc_dvc->sdtr_period_tbl[1] = SYN_XFER_NS_1;
-	asc_dvc->sdtr_period_tbl[2] = SYN_XFER_NS_2;
-	asc_dvc->sdtr_period_tbl[3] = SYN_XFER_NS_3;
-	asc_dvc->sdtr_period_tbl[4] = SYN_XFER_NS_4;
-	asc_dvc->sdtr_period_tbl[5] = SYN_XFER_NS_5;
-	asc_dvc->sdtr_period_tbl[6] = SYN_XFER_NS_6;
-	asc_dvc->sdtr_period_tbl[7] = SYN_XFER_NS_7;
-	asc_dvc->max_sdtr_index = 7;
-	if ((asc_dvc->bus_type & ASC_IS_PCI) &&
-	    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {
-		asc_dvc->bus_type = ASC_IS_PCI_ULTRA;
-		asc_dvc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;
-		asc_dvc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;
-		asc_dvc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;
-		asc_dvc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;
-		asc_dvc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;
-		asc_dvc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;
-		asc_dvc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;
-		asc_dvc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;
-		asc_dvc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;
-		asc_dvc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;
-		asc_dvc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;
-		asc_dvc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;
-		asc_dvc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;
-		asc_dvc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;
-		asc_dvc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;
-		asc_dvc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;
-		asc_dvc->max_sdtr_index = 15;
-		if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {
-			AscSetExtraControl(iop_base,
-					   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
-		} else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {
-			AscSetExtraControl(iop_base,
-					   (SEC_ACTIVE_NEGATE |
-					    SEC_ENABLE_FILTER));
-		}
-	}
-	if (asc_dvc->bus_type == ASC_IS_PCI) {
-		AscSetExtraControl(iop_base,
-				   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
-	}
-
-	asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;
-#ifdef CONFIG_ISA
-	if ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {
-		if (chip_version >= ASC_CHIP_MIN_VER_ISA_PNP) {
-			AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
-			asc_dvc->bus_type = ASC_IS_ISAPNP;
-		}
-		asc_dvc->cfg->isa_dma_channel =
-		    (uchar)AscGetIsaDmaChannel(iop_base);
-	}
-#endif /* CONFIG_ISA */
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		asc_dvc->cur_dvc_qng[i] = 0;
-		asc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;
-		asc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *)0L;
-		asc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;
-		asc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;
-	}
-	return (warn_code);
-}
-
-static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
-{
-	ASCEEP_CONFIG eep_config_buf;
-	ASCEEP_CONFIG *eep_config;
-	PortAddr iop_base;
-	ushort chksum;
-	ushort warn_code;
-	ushort cfg_msw, cfg_lsw;
-	int i;
-	int write_eep = 0;
-
-	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
-	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);
-	AscStopQueueExe(iop_base);
-	if ((AscStopChip(iop_base) == FALSE) ||
-	    (AscGetChipScsiCtrl(iop_base) != 0)) {
-		asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
-		AscResetChipAndScsiBus(asc_dvc);
-		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
-	}
-	if (AscIsChipHalted(iop_base) == FALSE) {
-		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
-		return (warn_code);
-	}
-	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
-	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
-		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
-		return (warn_code);
-	}
-	eep_config = (ASCEEP_CONFIG *)&eep_config_buf;
-	cfg_msw = AscGetChipCfgMsw(iop_base);
-	cfg_lsw = AscGetChipCfgLsw(iop_base);
-	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
-		cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
-		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
-		AscSetChipCfgMsw(iop_base, cfg_msw);
-	}
-	chksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);
-	ASC_DBG1(1, "AscInitFromEEP: chksum 0x%x\n", chksum);
-	if (chksum == 0) {
-		chksum = 0xaa55;
-	}
-	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
-		warn_code |= ASC_WARN_AUTO_CONFIG;
-		if (asc_dvc->cfg->chip_version == 3) {
-			if (eep_config->cfg_lsw != cfg_lsw) {
-				warn_code |= ASC_WARN_EEPROM_RECOVER;
-				eep_config->cfg_lsw =
-				    AscGetChipCfgLsw(iop_base);
-			}
-			if (eep_config->cfg_msw != cfg_msw) {
-				warn_code |= ASC_WARN_EEPROM_RECOVER;
-				eep_config->cfg_msw =
-				    AscGetChipCfgMsw(iop_base);
-			}
-		}
-	}
-	eep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
-	eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;
-	ASC_DBG1(1, "AscInitFromEEP: eep_config->chksum 0x%x\n",
-		 eep_config->chksum);
-	if (chksum != eep_config->chksum) {
-		if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
-		    ASC_CHIP_VER_PCI_ULTRA_3050) {
-			ASC_DBG(1,
-				"AscInitFromEEP: chksum error ignored; EEPROM-less board\n");
-			eep_config->init_sdtr = 0xFF;
-			eep_config->disc_enable = 0xFF;
-			eep_config->start_motor = 0xFF;
-			eep_config->use_cmd_qng = 0;
-			eep_config->max_total_qng = 0xF0;
-			eep_config->max_tag_qng = 0x20;
-			eep_config->cntl = 0xBFFF;
-			ASC_EEP_SET_CHIP_ID(eep_config, 7);
-			eep_config->no_scam = 0;
-			eep_config->adapter_info[0] = 0;
-			eep_config->adapter_info[1] = 0;
-			eep_config->adapter_info[2] = 0;
-			eep_config->adapter_info[3] = 0;
-			eep_config->adapter_info[4] = 0;
-			/* Indicate EEPROM-less board. */
-			eep_config->adapter_info[5] = 0xBB;
-		} else {
-			ASC_PRINT
-			    ("AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\n");
-			write_eep = 1;
-			warn_code |= ASC_WARN_EEPROM_CHKSUM;
-		}
-	}
-	asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;
-	asc_dvc->cfg->disc_enable = eep_config->disc_enable;
-	asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;
-	asc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);
-	asc_dvc->start_motor = eep_config->start_motor;
-	asc_dvc->dvc_cntl = eep_config->cntl;
-	asc_dvc->no_scam = eep_config->no_scam;
-	asc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];
-	asc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];
-	asc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];
-	asc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];
-	asc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];
-	asc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];
-	if (!AscTestExternalLram(asc_dvc)) {
-		if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) ==
-		     ASC_IS_PCI_ULTRA)) {
-			eep_config->max_total_qng =
-			    ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;
-			eep_config->max_tag_qng =
-			    ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;
-		} else {
-			eep_config->cfg_msw |= 0x0800;
-			cfg_msw |= 0x0800;
-			AscSetChipCfgMsw(iop_base, cfg_msw);
-			eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;
-			eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;
-		}
-	} else {
-	}
-	if (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {
-		eep_config->max_total_qng = ASC_MIN_TOTAL_QNG;
-	}
-	if (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {
-		eep_config->max_total_qng = ASC_MAX_TOTAL_QNG;
-	}
-	if (eep_config->max_tag_qng > eep_config->max_total_qng) {
-		eep_config->max_tag_qng = eep_config->max_total_qng;
-	}
-	if (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {
-		eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;
-	}
-	asc_dvc->max_total_qng = eep_config->max_total_qng;
-	if ((eep_config->use_cmd_qng & eep_config->disc_enable) !=
-	    eep_config->use_cmd_qng) {
-		eep_config->disc_enable = eep_config->use_cmd_qng;
-		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
-	}
-	if (asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA)) {
-		asc_dvc->irq_no = AscGetChipIRQ(iop_base, asc_dvc->bus_type);
-	}
-	ASC_EEP_SET_CHIP_ID(eep_config,
-			    ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);
-	asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
-	if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&
-	    !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {
-		asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
-	}
-
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		asc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];
-		asc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;
-		asc_dvc->cfg->sdtr_period_offset[i] =
-		    (uchar)(ASC_DEF_SDTR_OFFSET |
-			    (asc_dvc->host_init_sdtr_index << 4));
-	}
-	eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
-	if (write_eep) {
-		if ((i =
-		     AscSetEEPConfig(iop_base, eep_config,
-				     asc_dvc->bus_type)) != 0) {
-			ASC_PRINT1
-			    ("AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n",
-			     i);
-		} else {
-			ASC_PRINT
-			    ("AscInitFromEEP: Successfully re-wrote EEPROM.\n");
-		}
-	}
-	return (warn_code);
-}
-
-static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
-{
-	int i;
-	ushort warn_code;
-	PortAddr iop_base;
-	ASC_PADDR phy_addr;
-	ASC_DCNT phy_size;
-
-	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
-	for (i = 0; i <= ASC_MAX_TID; i++) {
-		AscPutMCodeInitSDTRAtID(iop_base, i,
-					asc_dvc->cfg->sdtr_period_offset[i]
-		    );
-	}
-
-	AscInitQLinkVar(asc_dvc);
-	AscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,
-			 asc_dvc->cfg->disc_enable);
-	AscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,
-			 ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));
-
-	/* Align overrun buffer on an 8 byte boundary. */
-	phy_addr = virt_to_bus(asc_dvc->cfg->overrun_buf);
-	phy_addr = cpu_to_le32((phy_addr + 7) & ~0x7);
-	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
-				 (uchar *)&phy_addr, 1);
-	phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE - 8);
-	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,
-				 (uchar *)&phy_size, 1);
-
-	asc_dvc->cfg->mcode_date =
-	    AscReadLramWord(iop_base, (ushort)ASCV_MC_DATE_W);
-	asc_dvc->cfg->mcode_version =
-	    AscReadLramWord(iop_base, (ushort)ASCV_MC_VER_W);
-
-	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
-	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
-		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
-		return (warn_code);
-	}
-	if (AscStartChip(iop_base) != 1) {
-		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
-		return (warn_code);
-	}
-
-	return (warn_code);
-}
-
-static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
-{
-	PortAddr iop_base;
-	ushort q_addr;
-	ushort saved_word;
-	int sta;
-
-	iop_base = asc_dvc->iop_base;
-	sta = 0;
-	q_addr = ASC_QNO_TO_QADDR(241);
-	saved_word = AscReadLramWord(iop_base, q_addr);
-	AscSetChipLramAddr(iop_base, q_addr);
-	AscSetChipLramData(iop_base, 0x55AA);
-	mdelay(10);
-	AscSetChipLramAddr(iop_base, q_addr);
-	if (AscGetChipLramData(iop_base) == 0x55AA) {
-		sta = 1;
-		AscWriteLramWord(iop_base, q_addr, saved_word);
-	}
-	return (sta);
-}
-
-static int __devinit AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
-{
-	uchar read_back;
-	int retry;
-
-	retry = 0;
-	while (TRUE) {
-		AscSetChipEEPCmd(iop_base, cmd_reg);
-		mdelay(1);
-		read_back = AscGetChipEEPCmd(iop_base);
-		if (read_back == cmd_reg) {
-			return (1);
-		}
-		if (retry++ > ASC_EEP_MAX_RETRY) {
-			return (0);
-		}
-	}
-}
-
-static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
-{
-	ushort read_back;
-	int retry;
-
-	retry = 0;
-	while (TRUE) {
-		AscSetChipEEPData(iop_base, data_reg);
-		mdelay(1);
-		read_back = AscGetChipEEPData(iop_base);
-		if (read_back == data_reg) {
-			return (1);
-		}
-		if (retry++ > ASC_EEP_MAX_RETRY) {
-			return (0);
-		}
-	}
-}
-
-static void __devinit AscWaitEEPRead(void)
-{
-	mdelay(1);
-	return;
-}
-
-static void __devinit AscWaitEEPWrite(void)
-{
-	mdelay(20);
-	return;
-}
-
-static ushort __devinit AscReadEEPWord(PortAddr iop_base, uchar addr)
-{
-	ushort read_wval;
-	uchar cmd_reg;
-
-	AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
-	AscWaitEEPRead();
-	cmd_reg = addr | ASC_EEP_CMD_READ;
-	AscWriteEEPCmdReg(iop_base, cmd_reg);
-	AscWaitEEPRead();
-	read_wval = AscGetChipEEPData(iop_base);
-	AscWaitEEPRead();
-	return (read_wval);
-}
-
-static ushort __devinit
-AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
-{
-	ushort read_wval;
-
-	read_wval = AscReadEEPWord(iop_base, addr);
-	if (read_wval != word_val) {
-		AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);
-		AscWaitEEPRead();
-		AscWriteEEPDataReg(iop_base, word_val);
-		AscWaitEEPRead();
-		AscWriteEEPCmdReg(iop_base,
-				  (uchar)((uchar)ASC_EEP_CMD_WRITE | addr));
-		AscWaitEEPWrite();
-		AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
-		AscWaitEEPRead();
-		return (AscReadEEPWord(iop_base, addr));
-	}
-	return (read_wval);
-}
-
-static ushort __devinit
-AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
-{
-	ushort wval;
-	ushort sum;
-	ushort *wbuf;
-	int cfg_beg;
-	int cfg_end;
-	int uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
-	int s_addr;
-
-	wbuf = (ushort *)cfg_buf;
-	sum = 0;
-	/* Read two config words; Byte-swapping done by AscReadEEPWord(). */
-	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
-		*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);
-		sum += *wbuf;
-	}
-	if (bus_type & ASC_IS_VL) {
-		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
-		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
-	} else {
-		cfg_beg = ASC_EEP_DVC_CFG_BEG;
-		cfg_end = ASC_EEP_MAX_DVC_ADDR;
-	}
-	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
-		wval = AscReadEEPWord(iop_base, (uchar)s_addr);
-		if (s_addr <= uchar_end_in_config) {
-			/*
-			 * Swap all char fields - must unswap bytes already swapped
-			 * by AscReadEEPWord().
-			 */
-			*wbuf = le16_to_cpu(wval);
-		} else {
-			/* Don't swap word field at the end - cntl field. */
-			*wbuf = wval;
-		}
-		sum += wval;	/* Checksum treats all EEPROM data as words. */
-	}
-	/*
-	 * Read the checksum word which will be compared against 'sum'
-	 * by the caller. Word field already swapped.
-	 */
-	*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);
-	return (sum);
-}
-
-static int __devinit
-AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
-{
-	int n_error;
-	ushort *wbuf;
-	ushort word;
-	ushort sum;
-	int s_addr;
-	int cfg_beg;
-	int cfg_end;
-	int uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
-
-	wbuf = (ushort *)cfg_buf;
-	n_error = 0;
-	sum = 0;
-	/* Write two config words; AscWriteEEPWord() will swap bytes. */
-	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
-		sum += *wbuf;
-		if (*wbuf != AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {
-			n_error++;
-		}
-	}
-	if (bus_type & ASC_IS_VL) {
-		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
-		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
-	} else {
-		cfg_beg = ASC_EEP_DVC_CFG_BEG;
-		cfg_end = ASC_EEP_MAX_DVC_ADDR;
-	}
-	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
-		if (s_addr <= uchar_end_in_config) {
-			/*
-			 * This is a char field. Swap char fields before they are
-			 * swapped again by AscWriteEEPWord().
-			 */
-			word = cpu_to_le16(*wbuf);
-			if (word !=
-			    AscWriteEEPWord(iop_base, (uchar)s_addr, word)) {
-				n_error++;
-			}
-		} else {
-			/* Don't swap word field at the end - cntl field. */
-			if (*wbuf !=
-			    AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {
-				n_error++;
-			}
-		}
-		sum += *wbuf;	/* Checksum calculated from word values. */
-	}
-	/* Write checksum word. It will be swapped by AscWriteEEPWord(). */
-	*wbuf = sum;
-	if (sum != AscWriteEEPWord(iop_base, (uchar)s_addr, sum)) {
-		n_error++;
-	}
-
-	/* Read EEPROM back again. */
-	wbuf = (ushort *)cfg_buf;
-	/*
-	 * Read two config words; Byte-swapping done by AscReadEEPWord().
-	 */
-	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
-		if (*wbuf != AscReadEEPWord(iop_base, (uchar)s_addr)) {
-			n_error++;
-		}
-	}
-	if (bus_type & ASC_IS_VL) {
-		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
-		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
-	} else {
-		cfg_beg = ASC_EEP_DVC_CFG_BEG;
-		cfg_end = ASC_EEP_MAX_DVC_ADDR;
-	}
-	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
-		if (s_addr <= uchar_end_in_config) {
-			/*
-			 * Swap all char fields. Must unswap bytes already swapped
-			 * by AscReadEEPWord().
-			 */
-			word =
-			    le16_to_cpu(AscReadEEPWord
-					(iop_base, (uchar)s_addr));
-		} else {
-			/* Don't swap word field at the end - cntl field. */
-			word = AscReadEEPWord(iop_base, (uchar)s_addr);
-		}
-		if (*wbuf != word) {
-			n_error++;
-		}
-	}
-	/* Read checksum; Byte swapping not needed. */
-	if (AscReadEEPWord(iop_base, (uchar)s_addr) != sum) {
-		n_error++;
-	}
-	return (n_error);
-}
-
-static int __devinit
-AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
-{
-	int retry;
-	int n_error;
-
-	retry = 0;
-	while (TRUE) {
-		if ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,
-						   bus_type)) == 0) {
-			break;
-		}
-		if (++retry > ASC_EEP_MAX_RETRY) {
-			break;
-		}
-	}
-	return (n_error);
-}
-
-static void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)
-{
-	char type = sdev->type;
-	ASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;
-
-	if (!(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN))
-		return;
-	if (asc_dvc->init_sdtr & tid_bits)
-		return;
-
-	if ((type == TYPE_ROM) && (strncmp(sdev->vendor, "HP ", 3) == 0))
-		asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
-
-	asc_dvc->pci_fix_asyn_xfer |= tid_bits;
-	if ((type == TYPE_PROCESSOR) || (type == TYPE_SCANNER) ||
-	    (type == TYPE_ROM) || (type == TYPE_TAPE))
-		asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
-
-	if (asc_dvc->pci_fix_asyn_xfer & tid_bits)
-		AscSetRunChipSynRegAtID(asc_dvc->iop_base, sdev->id,
-					ASYN_SDTR_DATA_FIX_PCI_REV_AB);
-}
-
-static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
-{
-	uchar byte_data;
-	ushort word_data;
-
-	if (isodd_word(addr)) {
-		AscSetChipLramAddr(iop_base, addr - 1);
-		word_data = AscGetChipLramData(iop_base);
-		byte_data = (uchar)((word_data >> 8) & 0xFF);
-	} else {
-		AscSetChipLramAddr(iop_base, addr);
-		word_data = AscGetChipLramData(iop_base);
-		byte_data = (uchar)(word_data & 0xFF);
-	}
-	return (byte_data);
-}
-
-static ushort AscReadLramWord(PortAddr iop_base, ushort addr)
-{
-	ushort word_data;
-
-	AscSetChipLramAddr(iop_base, addr);
-	word_data = AscGetChipLramData(iop_base);
-	return (word_data);
-}
-
-#if CC_VERY_LONG_SG_LIST
-static ASC_DCNT AscReadLramDWord(PortAddr iop_base, ushort addr)
-{
-	ushort val_low, val_high;
-	ASC_DCNT dword_data;
-
-	AscSetChipLramAddr(iop_base, addr);
-	val_low = AscGetChipLramData(iop_base);
-	val_high = AscGetChipLramData(iop_base);
-	dword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;
-	return (dword_data);
-}
-#endif /* CC_VERY_LONG_SG_LIST */
-
-static void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)
-{
-	AscSetChipLramAddr(iop_base, addr);
-	AscSetChipLramData(iop_base, word_val);
-	return;
-}
-
-static void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)
-{
-	ushort word_data;
-
-	if (isodd_word(addr)) {
-		addr--;
-		word_data = AscReadLramWord(iop_base, addr);
-		word_data &= 0x00FF;
-		word_data |= (((ushort)byte_val << 8) & 0xFF00);
-	} else {
-		word_data = AscReadLramWord(iop_base, addr);
-		word_data &= 0xFF00;
-		word_data |= ((ushort)byte_val & 0x00FF);
-	}
-	AscWriteLramWord(iop_base, addr, word_data);
-	return;
-}
-
-/*
- * Copy 2 bytes to LRAM.
- *
- * The source data is assumed to be in little-endian order in memory
- * and is maintained in little-endian order when written to LRAM.
- */
-static void
-AscMemWordCopyPtrToLram(PortAddr iop_base,
-			ushort s_addr, uchar *s_buffer, int words)
-{
-	int i;
-
-	AscSetChipLramAddr(iop_base, s_addr);
-	for (i = 0; i < 2 * words; i += 2) {
-		/*
-		 * On a little-endian system the second argument below
-		 * produces a little-endian ushort which is written to
-		 * LRAM in little-endian order. On a big-endian system
-		 * the second argument produces a big-endian ushort which
-		 * is "transparently" byte-swapped by outpw() and written
-		 * in little-endian order to LRAM.
-		 */
-		outpw(iop_base + IOP_RAM_DATA,
-		      ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);
-	}
-	return;
-}
-
-/*
- * Copy 4 bytes to LRAM.
- *
- * The source data is assumed to be in little-endian order in memory
- * and is maintained in little-endian order when writen to LRAM.
- */
-static void
-AscMemDWordCopyPtrToLram(PortAddr iop_base,
-			 ushort s_addr, uchar *s_buffer, int dwords)
-{
-	int i;
-
-	AscSetChipLramAddr(iop_base, s_addr);
-	for (i = 0; i < 4 * dwords; i += 4) {
-		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);	/* LSW */
-		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);	/* MSW */
-	}
-	return;
-}
-
-/*
- * Copy 2 bytes from LRAM.
- *
- * The source data is assumed to be in little-endian order in LRAM
- * and is maintained in little-endian order when written to memory.
- */
-static void
-AscMemWordCopyPtrFromLram(PortAddr iop_base,
-			  ushort s_addr, uchar *d_buffer, int words)
-{
-	int i;
-	ushort word;
-
-	AscSetChipLramAddr(iop_base, s_addr);
-	for (i = 0; i < 2 * words; i += 2) {
-		word = inpw(iop_base + IOP_RAM_DATA);
-		d_buffer[i] = word & 0xff;
-		d_buffer[i + 1] = (word >> 8) & 0xff;
-	}
-	return;
-}
-
-static ASC_DCNT AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
-{
-	ASC_DCNT sum;
-	int i;
-
-	sum = 0L;
-	for (i = 0; i < words; i++, s_addr += 2) {
-		sum += AscReadLramWord(iop_base, s_addr);
-	}
-	return (sum);
-}
-
-static void
-AscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)
-{
-	int i;
-
-	AscSetChipLramAddr(iop_base, s_addr);
-	for (i = 0; i < words; i++) {
-		AscSetChipLramData(iop_base, set_wval);
-	}
-	return;
-}
+static unsigned short _asc_mcode_size = sizeof(_asc_mcode_buf);
+static ADV_DCNT _asc_mcode_chksum = 0x012C453FUL;
 
 /* Microcode buffer is kept after initialization for error recovery. */
 static unsigned char _adv_asc3550_buf[] = {
@@ -10683,2728 +6491,6514 @@ static unsigned char _adv_asc38C1600_buf[] = {
 	0xa8, 0x02, 0xff, 0x66, 0x00, 0x00,
 };
 
-static unsigned short _adv_asc38C1600_size = sizeof(_adv_asc38C1600_buf);	/* 0x1673 */
-static ADV_DCNT _adv_asc38C1600_chksum = 0x0604EF77UL;	/* Expanded little-endian checksum. */
+static unsigned short _adv_asc38C1600_size = sizeof(_adv_asc38C1600_buf);	/* 0x1673 */
+static ADV_DCNT _adv_asc38C1600_chksum = 0x0604EF77UL;	/* Expanded little-endian checksum. */
+
+static void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
+{
+	PortAddr iop_base;
+	int i;
+	ushort lram_addr;
+
+	iop_base = asc_dvc->iop_base;
+	AscPutRiscVarFreeQHead(iop_base, 1);
+	AscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);
+	AscPutVarFreeQHead(iop_base, 1);
+	AscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);
+	AscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,
+			 (uchar)((int)asc_dvc->max_total_qng + 1));
+	AscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,
+			 (uchar)((int)asc_dvc->max_total_qng + 2));
+	AscWriteLramByte(iop_base, (ushort)ASCV_TOTAL_READY_Q_B,
+			 asc_dvc->max_total_qng);
+	AscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);
+	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);
+	AscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);
+	AscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);
+	AscPutQDoneInProgress(iop_base, 0);
+	lram_addr = ASC_QADR_BEG;
+	for (i = 0; i < 32; i++, lram_addr += 2) {
+		AscWriteLramWord(iop_base, lram_addr, 0);
+	}
+}
+
+static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
+{
+	int i;
+	ushort warn_code;
+	PortAddr iop_base;
+	ASC_PADDR phy_addr;
+	ASC_DCNT phy_size;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		AscPutMCodeInitSDTRAtID(iop_base, i,
+					asc_dvc->cfg->sdtr_period_offset[i]);
+	}
+
+	AscInitQLinkVar(asc_dvc);
+	AscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,
+			 asc_dvc->cfg->disc_enable);
+	AscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,
+			 ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));
+
+	/* Align overrun buffer on an 8 byte boundary. */
+	phy_addr = virt_to_bus(asc_dvc->cfg->overrun_buf);
+	phy_addr = cpu_to_le32((phy_addr + 7) & ~0x7);
+	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
+				 (uchar *)&phy_addr, 1);
+	phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE - 8);
+	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,
+				 (uchar *)&phy_size, 1);
+
+	asc_dvc->cfg->mcode_date =
+	    AscReadLramWord(iop_base, (ushort)ASCV_MC_DATE_W);
+	asc_dvc->cfg->mcode_version =
+	    AscReadLramWord(iop_base, (ushort)ASCV_MC_VER_W);
+
+	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
+	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
+		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
+		return warn_code;
+	}
+	if (AscStartChip(iop_base) != 1) {
+		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
+		return warn_code;
+	}
+
+	return warn_code;
+}
+
+static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
+{
+	ushort warn_code;
+	PortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	if ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&
+	    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {
+		AscResetChipAndScsiBus(asc_dvc);
+		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
+	}
+	asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
+	if (asc_dvc->err_code != 0)
+		return UW_ERR;
+	if (!AscFindSignature(asc_dvc->iop_base)) {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+		return warn_code;
+	}
+	AscDisableInterrupt(iop_base);
+	warn_code |= AscInitLram(asc_dvc);
+	if (asc_dvc->err_code != 0)
+		return UW_ERR;
+	ASC_DBG1(1, "AscInitAsc1000Driver: _asc_mcode_chksum 0x%lx\n",
+		 (ulong)_asc_mcode_chksum);
+	if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
+			     _asc_mcode_size) != _asc_mcode_chksum) {
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+		return warn_code;
+	}
+	warn_code |= AscInitMicroCodeVar(asc_dvc);
+	asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
+	AscEnableInterrupt(iop_base);
+	return warn_code;
+}
+
+/*
+ * Load the Microcode
+ *
+ * Write the microcode image to RISC memory starting at address 0.
+ *
+ * The microcode is stored compressed in the following format:
+ *
+ *  254 word (508 byte) table indexed by byte code followed
+ *  by the following byte codes:
+ *
+ *    1-Byte Code:
+ *      00: Emit word 0 in table.
+ *      01: Emit word 1 in table.
+ *      .
+ *      FD: Emit word 253 in table.
+ *
+ *    Multi-Byte Code:
+ *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+ *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+ *
+ * Returns 0 or an error if the checksum doesn't match
+ */
+static int AdvLoadMicrocode(AdvPortAddr iop_base, unsigned char *buf, int size,
+			    int memsize, int chksum)
+{
+	int i, j, end, len = 0;
+	ADV_DCNT sum;
+
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+	for (i = 253 * 2; i < size; i++) {
+		if (buf[i] == 0xff) {
+			unsigned short word = (buf[i + 3] << 8) | buf[i + 2];
+			for (j = 0; j < buf[i + 1]; j++) {
+				AdvWriteWordAutoIncLram(iop_base, word);
+				len += 2;
+			}
+			i += 3;
+		} else if (buf[i] == 0xfe) {
+			unsigned short word = (buf[i + 2] << 8) | buf[i + 1];
+			AdvWriteWordAutoIncLram(iop_base, word);
+			i += 2;
+			len += 2;
+		} else {
+			unsigned char off = buf[i] * 2;
+			unsigned short word = (buf[off + 1] << 8) | buf[off];
+			AdvWriteWordAutoIncLram(iop_base, word);
+			len += 2;
+		}
+	}
+
+	end = len;
+
+	while (len < memsize) {
+		AdvWriteWordAutoIncLram(iop_base, 0);
+		len += 2;
+	}
+
+	/* Verify the microcode checksum. */
+	sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+	for (len = 0; len < end; len += 2) {
+		sum += AdvReadWordAutoIncLram(iop_base);
+	}
+
+	if (sum != chksum)
+		return ASC_IERR_MCODE_CHKSUM;
+
+	return 0;
+}
+
+/*
+ * DvcGetPhyAddr()
+ *
+ * Return the physical address of 'vaddr' and set '*lenp' to the
+ * number of physically contiguous bytes that follow 'vaddr'.
+ * 'flag' indicates the type of structure whose physical address
+ * is being translated.
+ *
+ * Note: Because Linux currently doesn't page the kernel and all
+ * kernel buffers are physically contiguous, leave '*lenp' unchanged.
+ */
+ADV_PADDR
+DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
+	      uchar *vaddr, ADV_SDCNT *lenp, int flag)
+{
+	ADV_PADDR paddr = virt_to_bus(vaddr);
+
+	ASC_DBG4(4, "DvcGetPhyAddr: vaddr 0x%p, lenp 0x%p *lenp %lu, paddr 0x%lx\n",
+		 vaddr, lenp, (ulong)*((ulong *)lenp), (ulong)paddr);
+
+	return paddr;
+}
+
+static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
+{
+	ADV_CARR_T *carrp;
+	ADV_SDCNT buf_size;
+	ADV_PADDR carr_paddr;
+
+	BUG_ON(!asc_dvc->carrier_buf);
+
+	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+	asc_dvc->carr_freelist = NULL;
+	if (carrp == asc_dvc->carrier_buf) {
+		buf_size = ADV_CARRIER_BUFSIZE;
+	} else {
+		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+	}
+
+	do {
+		/* Get physical address of the carrier 'carrp'. */
+		ADV_DCNT contig_len = sizeof(ADV_CARR_T);
+		carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL,
+						       (uchar *)carrp,
+						       (ADV_SDCNT *)&contig_len,
+						       ADV_IS_CARRIER_FLAG));
+
+		buf_size -= sizeof(ADV_CARR_T);
+
+		/*
+		 * If the current carrier is not physically contiguous, then
+		 * maybe there was a page crossing. Try the next carrier
+		 * aligned start address.
+		 */
+		if (contig_len < sizeof(ADV_CARR_T)) {
+			carrp++;
+			continue;
+		}
+
+		carrp->carr_pa = carr_paddr;
+		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+
+		/*
+		 * Insert the carrier at the beginning of the freelist.
+		 */
+		carrp->next_vpa =
+			cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = carrp;
+
+		carrp++;
+	} while (buf_size > 0);
+}
+
+/*
+ * Send an idle command to the chip and wait for completion.
+ *
+ * Command completion is polled for once per microsecond.
+ *
+ * The function can be called from anywhere including an interrupt handler.
+ * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()
+ * functions to prevent reentrancy.
+ *
+ * Return Values:
+ *   ADV_TRUE - command completed successfully
+ *   ADV_FALSE - command failed
+ *   ADV_ERROR - command timed out
+ */
+static int
+AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
+	       ushort idle_cmd, ADV_DCNT idle_cmd_parameter)
+{
+	int result;
+	ADV_DCNT i, j;
+	AdvPortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Clear the idle command status which is set by the microcode
+	 * to a non-zero value to indicate when the command is completed.
+	 * The non-zero result is one of the IDLE_CMD_STATUS_* values
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);
+
+	/*
+	 * Write the idle command value after the idle command parameter
+	 * has been written to avoid a race condition. If the order is not
+	 * followed, the microcode may process the idle command before the
+	 * parameters have been written to LRAM.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,
+				cpu_to_le32(idle_cmd_parameter));
+	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
+
+	/*
+	 * Tickle the RISC to tell it to process the idle command.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);
+	if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+		/*
+		 * Clear the tickle value. In the ASC-3550 the RISC flag
+		 * command 'clr_tickle_b' does not work unless the host
+		 * value is cleared.
+		 */
+		AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
+	}
+
+	/* Wait for up to 100 millisecond for the idle command to timeout. */
+	for (i = 0; i < SCSI_WAIT_100_MSEC; i++) {
+		/* Poll once each microsecond for command completion. */
+		for (j = 0; j < SCSI_US_PER_MSEC; j++) {
+			AdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,
+					result);
+			if (result != 0)
+				return result;
+			udelay(1);
+		}
+	}
+
+	BUG();		/* The idle command should never timeout. */
+	return ADV_ERROR;
+}
+
+/*
+ * Reset SCSI Bus and purge all outstanding requests.
+ *
+ * Return Value:
+ *      ADV_TRUE(1) -   All requests are purged and SCSI Bus is reset.
+ *      ADV_FALSE(0) -  Microcode command failed.
+ *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC
+ *                      may be hung which requires driver recovery.
+ */
+static int AdvResetSB(ADV_DVC_VAR *asc_dvc)
+{
+	int status;
+
+	/*
+	 * Send the SCSI Bus Reset idle start idle command which asserts
+	 * the SCSI Bus Reset signal.
+	 */
+	status = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_START, 0L);
+	if (status != ADV_TRUE) {
+		return status;
+	}
+
+	/*
+	 * Delay for the specified SCSI Bus Reset hold time.
+	 *
+	 * The hold time delay is done on the host because the RISC has no
+	 * microsecond accurate timer.
+	 */
+	udelay(ASC_SCSI_RESET_HOLD_TIME_US);
+
+	/*
+	 * Send the SCSI Bus Reset end idle command which de-asserts
+	 * the SCSI Bus Reset signal and purges any pending requests.
+	 */
+	status = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_END, 0L);
+	if (status != ADV_TRUE) {
+		return status;
+	}
+
+	mdelay(asc_dvc->scsi_reset_wait * 1000);	/* XXX: msleep? */
+
+	return status;
+}
+
+/*
+ * Initialize the ASC-3550.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	int begin_addr;
+	int end_addr;
+	ushort code_sum;
+	int word;
+	int i;
+	ushort scsi_cfg1;
+	uchar tid;
+	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
+	ushort wdtr_able = 0, sdtr_able, tagqng_able;
+	uchar max_cmd[ADV_MAX_TID + 1];
+
+	/* If there is already an error, don't continue. */
+	if (asc_dvc->err_code != 0)
+		return ADV_ERROR;
+
+	/*
+	 * The caller must set 'chip_type' to ADV_CHIP_ASC3550.
+	 */
+	if (asc_dvc->chip_type != ADV_CHIP_ASC3550) {
+		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+		return ADV_ERROR;
+	}
+
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save the RISC memory BIOS region before writing the microcode.
+	 * The BIOS may already be loaded and using its RISC LRAM region
+	 * so its region must be saved and restored.
+	 *
+	 * Note: This code makes the assumption, which is currently true,
+	 * that a chip reset does not clear RISC LRAM.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				bios_mem[i]);
+	}
+
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] == 0x55AA) {
+		ushort bios_version, major, minor;
+
+		bios_version =
+		    bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM) / 2];
+		major = (bios_version >> 12) & 0xF;
+		minor = (bios_version >> 8) & 0xF;
+		if (major < 3 || (major == 3 && minor == 1)) {
+			/* BIOS 3.1 and earlier location of 'wdtr_able' variable. */
+			AdvReadWordLram(iop_base, 0x120, wdtr_able);
+		} else {
+			AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+		}
+	}
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
+
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc3550_buf,
+					_adv_asc3550_size, ADV_3550_MEMSIZE,
+					_adv_asc3550_chksum);
+	if (asc_dvc->err_code)
+		return ADV_ERROR;
+
+	/*
+	 * Restore the RISC memory BIOS region.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				 bios_mem[i]);
+	}
+
+	/*
+	 * Calculate and write the microcode code checksum to the microcode
+	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+	code_sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+	for (word = begin_addr; word < end_addr; word += 2) {
+		code_sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+	/*
+	 * Read and save microcode version and date.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
+			asc_dvc->cfg->mcode_date);
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
+			asc_dvc->cfg->mcode_version);
+
+	/*
+	 * Set the chip type to indicate the ASC3550.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);
+
+	/*
+	 * If the PCI Configuration Command Register "Parity Error Response
+	 * Control" Bit was clear (0), then set the microcode variable
+	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+	 * to ignore DMA parity errors.
+	 */
+	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_IGNORE_PERR;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
+
+	/*
+	 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO
+	 * threshold of 128 bytes. This register is only accessible to the host.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+			     START_CTL_EMFU | READ_CMD_MRM);
+
+	/*
+	 * Microcode operating variables for WDTR, SDTR, and command tag
+	 * queuing will be set in slave_configure() based on what a
+	 * device reports it is capable of in Inquiry byte 7.
+	 *
+	 * If SCSI Bus Resets have been disabled, then directly set
+	 * SDTR and WDTR from the EEPROM configuration. This will allow
+	 * the BIOS and warm boot to work without a SCSI bus hang on
+	 * the Inquiry caused by host and target mismatched DTR values.
+	 * Without the SCSI Bus Reset, before an Inquiry a device can't
+	 * be assumed to be in Asynchronous, Narrow mode.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
+		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+				 asc_dvc->wdtr_able);
+		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+				 asc_dvc->sdtr_able);
+	}
+
+	/*
+	 * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID
+	 * bitmask. These values determine the maximum SDTR speed negotiated
+	 * with a device.
+	 *
+	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+	 * without determining here whether the device supports SDTR.
+	 *
+	 * 4-bit speed  SDTR speed name
+	 * ===========  ===============
+	 * 0000b (0x0)  SDTR disabled
+	 * 0001b (0x1)  5 Mhz
+	 * 0010b (0x2)  10 Mhz
+	 * 0011b (0x3)  20 Mhz (Ultra)
+	 * 0100b (0x4)  40 Mhz (LVD/Ultra2)
+	 * 0101b (0x5)  80 Mhz (LVD2/Ultra3)
+	 * 0110b (0x6)  Undefined
+	 * .
+	 * 1111b (0xF)  Undefined
+	 */
+	word = 0;
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		if (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able) {
+			/* Set Ultra speed for TID 'tid'. */
+			word |= (0x3 << (4 * (tid % 4)));
+		} else {
+			/* Set Fast speed for TID 'tid'. */
+			word |= (0x2 << (4 * (tid % 4)));
+		}
+		if (tid == 3) {	/* Check if done with sdtr_speed1. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);
+			word = 0;
+		} else if (tid == 7) {	/* Check if done with sdtr_speed2. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);
+			word = 0;
+		} else if (tid == 11) {	/* Check if done with sdtr_speed3. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);
+			word = 0;
+		} else if (tid == 15) {	/* Check if done with sdtr_speed4. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);
+			/* End of loop. */
+		}
+	}
+
+	/*
+	 * Set microcode operating variable for the disconnect per TID bitmask.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
+			 asc_dvc->cfg->disc_enable);
+
+	/*
+	 * Set SCSI_CFG0 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG0 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+			 asc_dvc->chip_scsi_id);
+
+	/*
+	 * Determine SCSI_CFG1 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+
+	/* Read current SCSI_CFG1 Register value. */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+	/*
+	 * If all three connectors are in use, return an error.
+	 */
+	if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
+	    (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
+		asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * If the internal narrow cable is reversed all of the SCSI_CTRL
+	 * register signals will be set. Check for and return an error if
+	 * this condition is found.
+	 */
+	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
+		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * If this is a differential board and a single-ended device
+	 * is attached to one of the connectors, return an error.
+	 */
+	if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0) {
+		asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * If automatic termination control is enabled, then set the
+	 * termination value based on a table listed in a_condor.h.
+	 *
+	 * If manual termination was specified with an EEPROM setting
+	 * then 'termination' was set-up in AdvInitFrom3550EEPROM() and
+	 * is ready to be 'ored' into SCSI_CFG1.
+	 */
+	if (asc_dvc->cfg->termination == 0) {
+		/*
+		 * The software always controls termination by setting TERM_CTL_SEL.
+		 * If TERM_CTL_SEL were set to 0, the hardware would set termination.
+		 */
+		asc_dvc->cfg->termination |= TERM_CTL_SEL;
+
+		switch (scsi_cfg1 & CABLE_DETECT) {
+			/* TERM_CTL_H: on, TERM_CTL_L: on */
+		case 0x3:
+		case 0x7:
+		case 0xB:
+		case 0xD:
+		case 0xE:
+		case 0xF:
+			asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
+			break;
+
+			/* TERM_CTL_H: on, TERM_CTL_L: off */
+		case 0x1:
+		case 0x5:
+		case 0x9:
+		case 0xA:
+		case 0xC:
+			asc_dvc->cfg->termination |= TERM_CTL_H;
+			break;
+
+			/* TERM_CTL_H: off, TERM_CTL_L: off */
+		case 0x2:
+		case 0x6:
+			break;
+		}
+	}
+
+	/*
+	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.
+	 */
+	scsi_cfg1 &= ~TERM_CTL;
+
+	/*
+	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then
+	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be
+	 * referenced, because the hardware internally inverts
+	 * the Termination High and Low bits if TERM_POL is set.
+	 */
+	scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));
+
+	/*
+	 * Set SCSI_CFG1 Microcode Default Value
+	 *
+	 * Set filter value and possibly modified termination control
+	 * bits in the Microcode SCSI_CFG1 Register Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
+			 FLTR_DISABLE | scsi_cfg1);
+
+	/*
+	 * Set MEM_CFG Microcode Default Value
+	 *
+	 * The microcode will set the MEM_CFG register using this value
+	 * after it is started below.
+	 *
+	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+	 * are defined.
+	 *
+	 * ASC-3550 has 8KB internal memory.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+			 BIOS_EN | RAM_SZ_8KB);
+
+	/*
+	 * Set SEL_MASK Microcode Default Value
+	 *
+	 * The microcode will set the SEL_MASK register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+	AdvBuildCarrierFreelist(asc_dvc);
+
+	/*
+	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 */
+
+	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+	/*
+	 * The first command issued will be placed in the stopper carrier.
+	 */
+	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC ICQ physical address start value.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+
+	/*
+	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 */
+	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+	/*
+	 * The first command completed by the RISC will be placed in
+	 * the stopper.
+	 *
+	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+	 * completed the RISC will set the ASC_RQ_STOPPER bit.
+	 */
+	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC IRQ physical address start value.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+	asc_dvc->carr_pending_cnt = 0;
+
+	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+			     (ADV_INTR_ENABLE_HOST_INTR |
+			      ADV_INTR_ENABLE_GLOBAL_INTR));
+
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+	/* finally, finally, gentlemen, start your engine */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+	/*
+	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+	 * Resets should be performed. The RISC has to be running
+	 * to issue a SCSI Bus Reset.
+	 */
+	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+		/*
+		 * If the BIOS Signature is present in memory, restore the
+		 * BIOS Handshake Configuration Table and do not perform
+		 * a SCSI Bus Reset.
+		 */
+		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
+		    0x55AA) {
+			/*
+			 * Restore per TID negotiated values.
+			 */
+			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 tagqng_able);
+			for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+				AdvWriteByteLram(iop_base,
+						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+						 max_cmd[tid]);
+			}
+		} else {
+			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
+				warn_code = ASC_WARN_BUSRESET_ERROR;
+			}
+		}
+	}
+
+	return warn_code;
+}
+
+/*
+ * Initialize the ASC-38C0800.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	int begin_addr;
+	int end_addr;
+	ushort code_sum;
+	int word;
+	int i;
+	ushort scsi_cfg1;
+	uchar byte;
+	uchar tid;
+	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
+	ushort wdtr_able, sdtr_able, tagqng_able;
+	uchar max_cmd[ADV_MAX_TID + 1];
+
+	/* If there is already an error, don't continue. */
+	if (asc_dvc->err_code != 0)
+		return ADV_ERROR;
+
+	/*
+	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.
+	 */
+	if (asc_dvc->chip_type != ADV_CHIP_ASC38C0800) {
+		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+		return ADV_ERROR;
+	}
+
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save the RISC memory BIOS region before writing the microcode.
+	 * The BIOS may already be loaded and using its RISC LRAM region
+	 * so its region must be saved and restored.
+	 *
+	 * Note: This code makes the assumption, which is currently true,
+	 * that a chip reset does not clear RISC LRAM.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				bios_mem[i]);
+	}
+
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
+
+	/*
+	 * RAM BIST (RAM Built-In Self Test)
+	 *
+	 * Address : I/O base + offset 0x38h register (byte).
+	 * Function: Bit 7-6(RW) : RAM mode
+	 *                          Normal Mode   : 0x00
+	 *                          Pre-test Mode : 0x40
+	 *                          RAM Test Mode : 0x80
+	 *           Bit 5       : unused
+	 *           Bit 4(RO)   : Done bit
+	 *           Bit 3-0(RO) : Status
+	 *                          Host Error    : 0x08
+	 *                          Int_RAM Error : 0x04
+	 *                          RISC Error    : 0x02
+	 *                          SCSI Error    : 0x01
+	 *                          No Error      : 0x00
+	 *
+	 * Note: RAM BIST code should be put right here, before loading the
+	 * microcode and after saving the RISC memory BIOS region.
+	 */
+
+	/*
+	 * LRAM Pre-test
+	 *
+	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
+	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
+	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
+	 * to NORMAL_MODE, return an error too.
+	 */
+	for (i = 0; i < 2; i++) {
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
+		mdelay(10);	/* Wait for 10ms before reading back. */
+		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+		if ((byte & RAM_TEST_DONE) == 0
+		    || (byte & 0x0F) != PRE_TEST_VALUE) {
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+		mdelay(10);	/* Wait for 10ms before reading back. */
+		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
+		    != NORMAL_VALUE) {
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+	}
+
+	/*
+	 * LRAM Test - It takes about 1.5 ms to run through the test.
+	 *
+	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
+	 * If Done bit not set or Status not 0, save register byte, set the
+	 * err_code, and return an error.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
+	mdelay(10);	/* Wait for 10ms before checking status. */
+
+	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
+		/* Get here if Done bit not set or Status not 0. */
+		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
+		asc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;
+		return ADV_ERROR;
+	}
+
+	/* We need to reset back to normal mode after LRAM test passes. */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C0800_buf,
+				 _adv_asc38C0800_size, ADV_38C0800_MEMSIZE,
+				 _adv_asc38C0800_chksum);
+	if (asc_dvc->err_code)
+		return ADV_ERROR;
+
+	/*
+	 * Restore the RISC memory BIOS region.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				 bios_mem[i]);
+	}
+
+	/*
+	 * Calculate and write the microcode code checksum to the microcode
+	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+	code_sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+	for (word = begin_addr; word < end_addr; word += 2) {
+		code_sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+	/*
+	 * Read microcode version and date.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
+			asc_dvc->cfg->mcode_date);
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
+			asc_dvc->cfg->mcode_version);
+
+	/*
+	 * Set the chip type to indicate the ASC38C0800.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);
+
+	/*
+	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
+	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
+	 * cable detection and then we are able to read C_DET[3:0].
+	 *
+	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
+	 * Microcode Default Value' section below.
+	 */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,
+			     scsi_cfg1 | DIS_TERM_DRV);
+
+	/*
+	 * If the PCI Configuration Command Register "Parity Error Response
+	 * Control" Bit was clear (0), then set the microcode variable
+	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+	 * to ignore DMA parity errors.
+	 */
+	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_IGNORE_PERR;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
+
+	/*
+	 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]
+	 * bits for the default FIFO threshold.
+	 *
+	 * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.
+	 *
+	 * For DMA Errata #4 set the BC_THRESH_ENB bit.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+			     BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH |
+			     READ_CMD_MRM);
+
+	/*
+	 * Microcode operating variables for WDTR, SDTR, and command tag
+	 * queuing will be set in slave_configure() based on what a
+	 * device reports it is capable of in Inquiry byte 7.
+	 *
+	 * If SCSI Bus Resets have been disabled, then directly set
+	 * SDTR and WDTR from the EEPROM configuration. This will allow
+	 * the BIOS and warm boot to work without a SCSI bus hang on
+	 * the Inquiry caused by host and target mismatched DTR values.
+	 * Without the SCSI Bus Reset, before an Inquiry a device can't
+	 * be assumed to be in Asynchronous, Narrow mode.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
+		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+				 asc_dvc->wdtr_able);
+		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+				 asc_dvc->sdtr_able);
+	}
+
+	/*
+	 * Set microcode operating variables for DISC and SDTR_SPEED1,
+	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
+	 * configuration values.
+	 *
+	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+	 * without determining here whether the device supports SDTR.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
+			 asc_dvc->cfg->disc_enable);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+
+	/*
+	 * Set SCSI_CFG0 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG0 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+			 asc_dvc->chip_scsi_id);
+
+	/*
+	 * Determine SCSI_CFG1 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+
+	/* Read current SCSI_CFG1 Register value. */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+	/*
+	 * If the internal narrow cable is reversed all of the SCSI_CTRL
+	 * register signals will be set. Check for and return an error if
+	 * this condition is found.
+	 */
+	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
+		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * All kind of combinations of devices attached to one of four
+	 * connectors are acceptable except HVD device attached. For example,
+	 * LVD device can be attached to SE connector while SE device attached
+	 * to LVD connector.  If LVD device attached to SE connector, it only
+	 * runs up to Ultra speed.
+	 *
+	 * If an HVD device is attached to one of LVD connectors, return an
+	 * error.  However, there is no way to detect HVD device attached to
+	 * SE connectors.
+	 */
+	if (scsi_cfg1 & HVD) {
+		asc_dvc->err_code = ASC_IERR_HVD_DEVICE;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * If either SE or LVD automatic termination control is enabled, then
+	 * set the termination value based on a table listed in a_condor.h.
+	 *
+	 * If manual termination was specified with an EEPROM setting then
+	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready
+	 * to be 'ored' into SCSI_CFG1.
+	 */
+	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
+		/* SE automatic termination control is enabled. */
+		switch (scsi_cfg1 & C_DET_SE) {
+			/* TERM_SE_HI: on, TERM_SE_LO: on */
+		case 0x1:
+		case 0x2:
+		case 0x3:
+			asc_dvc->cfg->termination |= TERM_SE;
+			break;
+
+			/* TERM_SE_HI: on, TERM_SE_LO: off */
+		case 0x0:
+			asc_dvc->cfg->termination |= TERM_SE_HI;
+			break;
+		}
+	}
+
+	if ((asc_dvc->cfg->termination & TERM_LVD) == 0) {
+		/* LVD automatic termination control is enabled. */
+		switch (scsi_cfg1 & C_DET_LVD) {
+			/* TERM_LVD_HI: on, TERM_LVD_LO: on */
+		case 0x4:
+		case 0x8:
+		case 0xC:
+			asc_dvc->cfg->termination |= TERM_LVD;
+			break;
+
+			/* TERM_LVD_HI: off, TERM_LVD_LO: off */
+		case 0x0:
+			break;
+		}
+	}
+
+	/*
+	 * Clear any set TERM_SE and TERM_LVD bits.
+	 */
+	scsi_cfg1 &= (~TERM_SE & ~TERM_LVD);
+
+	/*
+	 * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.
+	 */
+	scsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);
+
+	/*
+	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE
+	 * bits and set possibly modified termination control bits in the
+	 * Microcode SCSI_CFG1 Register Value.
+	 */
+	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);
+
+	/*
+	 * Set SCSI_CFG1 Microcode Default Value
+	 *
+	 * Set possibly modified termination control and reset DIS_TERM_DRV
+	 * bits in the Microcode SCSI_CFG1 Register Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+
+	/*
+	 * Set MEM_CFG Microcode Default Value
+	 *
+	 * The microcode will set the MEM_CFG register using this value
+	 * after it is started below.
+	 *
+	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+	 * are defined.
+	 *
+	 * ASC-38C0800 has 16KB internal memory.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+			 BIOS_EN | RAM_SZ_16KB);
+
+	/*
+	 * Set SEL_MASK Microcode Default Value
+	 *
+	 * The microcode will set the SEL_MASK register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+	AdvBuildCarrierFreelist(asc_dvc);
+
+	/*
+	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 */
+
+	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+	/*
+	 * The first command issued will be placed in the stopper carrier.
+	 */
+	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC ICQ physical address start value.
+	 * carr_pa is LE, must be native before write
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+
+	/*
+	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 */
+	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+	/*
+	 * The first command completed by the RISC will be placed in
+	 * the stopper.
+	 *
+	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+	 * completed the RISC will set the ASC_RQ_STOPPER bit.
+	 */
+	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC IRQ physical address start value.
+	 *
+	 * carr_pa is LE, must be native before write *
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+	asc_dvc->carr_pending_cnt = 0;
+
+	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+			     (ADV_INTR_ENABLE_HOST_INTR |
+			      ADV_INTR_ENABLE_GLOBAL_INTR));
+
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+	/* finally, finally, gentlemen, start your engine */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+	/*
+	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+	 * Resets should be performed. The RISC has to be running
+	 * to issue a SCSI Bus Reset.
+	 */
+	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+		/*
+		 * If the BIOS Signature is present in memory, restore the
+		 * BIOS Handshake Configuration Table and do not perform
+		 * a SCSI Bus Reset.
+		 */
+		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
+		    0x55AA) {
+			/*
+			 * Restore per TID negotiated values.
+			 */
+			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 tagqng_able);
+			for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+				AdvWriteByteLram(iop_base,
+						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+						 max_cmd[tid]);
+			}
+		} else {
+			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
+				warn_code = ASC_WARN_BUSRESET_ERROR;
+			}
+		}
+	}
+
+	return warn_code;
+}
+
+/*
+ * Initialize the ASC-38C1600.
+ *
+ * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	int begin_addr;
+	int end_addr;
+	ushort code_sum;
+	long word;
+	int i;
+	ushort scsi_cfg1;
+	uchar byte;
+	uchar tid;
+	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
+	ushort wdtr_able, sdtr_able, ppr_able, tagqng_able;
+	uchar max_cmd[ASC_MAX_TID + 1];
+
+	/* If there is already an error, don't continue. */
+	if (asc_dvc->err_code != 0) {
+		return ADV_ERROR;
+	}
+
+	/*
+	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.
+	 */
+	if (asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {
+		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+		return ADV_ERROR;
+	}
+
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save the RISC memory BIOS region before writing the microcode.
+	 * The BIOS may already be loaded and using its RISC LRAM region
+	 * so its region must be saved and restored.
+	 *
+	 * Note: This code makes the assumption, which is currently true,
+	 * that a chip reset does not clear RISC LRAM.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				bios_mem[i]);
+	}
+
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ASC_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
+
+	/*
+	 * RAM BIST (Built-In Self Test)
+	 *
+	 * Address : I/O base + offset 0x38h register (byte).
+	 * Function: Bit 7-6(RW) : RAM mode
+	 *                          Normal Mode   : 0x00
+	 *                          Pre-test Mode : 0x40
+	 *                          RAM Test Mode : 0x80
+	 *           Bit 5       : unused
+	 *           Bit 4(RO)   : Done bit
+	 *           Bit 3-0(RO) : Status
+	 *                          Host Error    : 0x08
+	 *                          Int_RAM Error : 0x04
+	 *                          RISC Error    : 0x02
+	 *                          SCSI Error    : 0x01
+	 *                          No Error      : 0x00
+	 *
+	 * Note: RAM BIST code should be put right here, before loading the
+	 * microcode and after saving the RISC memory BIOS region.
+	 */
+
+	/*
+	 * LRAM Pre-test
+	 *
+	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
+	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
+	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
+	 * to NORMAL_MODE, return an error too.
+	 */
+	for (i = 0; i < 2; i++) {
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
+		mdelay(10);	/* Wait for 10ms before reading back. */
+		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+		if ((byte & RAM_TEST_DONE) == 0
+		    || (byte & 0x0F) != PRE_TEST_VALUE) {
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+		mdelay(10);	/* Wait for 10ms before reading back. */
+		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
+		    != NORMAL_VALUE) {
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+	}
+
+	/*
+	 * LRAM Test - It takes about 1.5 ms to run through the test.
+	 *
+	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
+	 * If Done bit not set or Status not 0, save register byte, set the
+	 * err_code, and return an error.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
+	mdelay(10);	/* Wait for 10ms before checking status. */
+
+	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
+		/* Get here if Done bit not set or Status not 0. */
+		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
+		asc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;
+		return ADV_ERROR;
+	}
+
+	/* We need to reset back to normal mode after LRAM test passes. */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C1600_buf,
+				 _adv_asc38C1600_size, ADV_38C1600_MEMSIZE,
+				 _adv_asc38C1600_chksum);
+	if (asc_dvc->err_code)
+		return ADV_ERROR;
+
+	/*
+	 * Restore the RISC memory BIOS region.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				 bios_mem[i]);
+	}
+
+	/*
+	 * Calculate and write the microcode code checksum to the microcode
+	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+	code_sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+	for (word = begin_addr; word < end_addr; word += 2) {
+		code_sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+	/*
+	 * Read microcode version and date.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
+			asc_dvc->cfg->mcode_date);
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
+			asc_dvc->cfg->mcode_version);
+
+	/*
+	 * Set the chip type to indicate the ASC38C1600.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);
+
+	/*
+	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
+	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
+	 * cable detection and then we are able to read C_DET[3:0].
+	 *
+	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
+	 * Microcode Default Value' section below.
+	 */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,
+			     scsi_cfg1 | DIS_TERM_DRV);
+
+	/*
+	 * If the PCI Configuration Command Register "Parity Error Response
+	 * Control" Bit was clear (0), then set the microcode variable
+	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+	 * to ignore DMA parity errors.
+	 */
+	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_IGNORE_PERR;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
+
+	/*
+	 * If the BIOS control flag AIPP (Asynchronous Information
+	 * Phase Protection) disable bit is not set, then set the firmware
+	 * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable
+	 * AIPP checking and encoding.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_ENABLE_AIPP;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
+
+	/*
+	 * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],
+	 * and START_CTL_TH [3:2].
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+			     FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
+
+	/*
+	 * Microcode operating variables for WDTR, SDTR, and command tag
+	 * queuing will be set in slave_configure() based on what a
+	 * device reports it is capable of in Inquiry byte 7.
+	 *
+	 * If SCSI Bus Resets have been disabled, then directly set
+	 * SDTR and WDTR from the EEPROM configuration. This will allow
+	 * the BIOS and warm boot to work without a SCSI bus hang on
+	 * the Inquiry caused by host and target mismatched DTR values.
+	 * Without the SCSI Bus Reset, before an Inquiry a device can't
+	 * be assumed to be in Asynchronous, Narrow mode.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
+		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+				 asc_dvc->wdtr_able);
+		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+				 asc_dvc->sdtr_able);
+	}
+
+	/*
+	 * Set microcode operating variables for DISC and SDTR_SPEED1,
+	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
+	 * configuration values.
+	 *
+	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+	 * without determining here whether the device supports SDTR.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
+			 asc_dvc->cfg->disc_enable);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+
+	/*
+	 * Set SCSI_CFG0 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG0 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+			 asc_dvc->chip_scsi_id);
+
+	/*
+	 * Calculate SCSI_CFG1 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 *
+	 * Each ASC-38C1600 function has only two cable detect bits.
+	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.
+	 */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+	/*
+	 * If the cable is reversed all of the SCSI_CTRL register signals
+	 * will be set. Check for and return an error if this condition is
+	 * found.
+	 */
+	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
+		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * Each ASC-38C1600 function has two connectors. Only an HVD device
+	 * can not be connected to either connector. An LVD device or SE device
+	 * may be connected to either connecor. If an SE device is connected,
+	 * then at most Ultra speed (20 Mhz) can be used on both connectors.
+	 *
+	 * If an HVD device is attached, return an error.
+	 */
+	if (scsi_cfg1 & HVD) {
+		asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
+		return ADV_ERROR;
+	}
+
+	/*
+	 * Each function in the ASC-38C1600 uses only the SE cable detect and
+	 * termination because there are two connectors for each function. Each
+	 * function may use either LVD or SE mode. Corresponding the SE automatic
+	 * termination control EEPROM bits are used for each function. Each
+	 * function has its own EEPROM. If SE automatic control is enabled for
+	 * the function, then set the termination value based on a table listed
+	 * in a_condor.h.
+	 *
+	 * If manual termination is specified in the EEPROM for the function,
+	 * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is
+	 * ready to be 'ored' into SCSI_CFG1.
+	 */
+	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
+		struct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);
+		/* SE automatic termination control is enabled. */
+		switch (scsi_cfg1 & C_DET_SE) {
+			/* TERM_SE_HI: on, TERM_SE_LO: on */
+		case 0x1:
+		case 0x2:
+		case 0x3:
+			asc_dvc->cfg->termination |= TERM_SE;
+			break;
+
+		case 0x0:
+			if (PCI_FUNC(pdev->devfn) == 0) {
+				/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
+			} else {
+				/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
+				asc_dvc->cfg->termination |= TERM_SE_HI;
+			}
+			break;
+		}
+	}
+
+	/*
+	 * Clear any set TERM_SE bits.
+	 */
+	scsi_cfg1 &= ~TERM_SE;
+
+	/*
+	 * Invert the TERM_SE bits and then set 'scsi_cfg1'.
+	 */
+	scsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);
+
+	/*
+	 * Clear Big Endian and Terminator Polarity bits and set possibly
+	 * modified termination control bits in the Microcode SCSI_CFG1
+	 * Register Value.
+	 *
+	 * Big Endian bit is not used even on big endian machines.
+	 */
+	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);
+
+	/*
+	 * Set SCSI_CFG1 Microcode Default Value
+	 *
+	 * Set possibly modified termination control bits in the Microcode
+	 * SCSI_CFG1 Register Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+
+	/*
+	 * Set MEM_CFG Microcode Default Value
+	 *
+	 * The microcode will set the MEM_CFG register using this value
+	 * after it is started below.
+	 *
+	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+	 * are defined.
+	 *
+	 * ASC-38C1600 has 32KB internal memory.
+	 *
+	 * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come
+	 * out a special 16K Adv Library and Microcode version. After the issue
+	 * resolved, we should turn back to the 32K support. Both a_condor.h and
+	 * mcode.sas files also need to be updated.
+	 *
+	 * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+	 *  BIOS_EN | RAM_SZ_32KB);
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+			 BIOS_EN | RAM_SZ_16KB);
+
+	/*
+	 * Set SEL_MASK Microcode Default Value
+	 *
+	 * The microcode will set the SEL_MASK register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+	AdvBuildCarrierFreelist(asc_dvc);
+
+	/*
+	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 */
+	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+	/*
+	 * The first command issued will be placed in the stopper carrier.
+	 */
+	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC ICQ physical address start value. Initialize the
+	 * COMMA register to the same value otherwise the RISC will
+	 * prematurely detect a command is available.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+	AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
+			      le32_to_cpu(asc_dvc->icq_sp->carr_pa));
+
+	/*
+	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 */
+	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+	/*
+	 * The first command completed by the RISC will be placed in
+	 * the stopper.
+	 *
+	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+	 * completed the RISC will set the ASC_RQ_STOPPER bit.
+	 */
+	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC IRQ physical address start value.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+	asc_dvc->carr_pending_cnt = 0;
+
+	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+			     (ADV_INTR_ENABLE_HOST_INTR |
+			      ADV_INTR_ENABLE_GLOBAL_INTR));
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+	/* finally, finally, gentlemen, start your engine */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+	/*
+	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+	 * Resets should be performed. The RISC has to be running
+	 * to issue a SCSI Bus Reset.
+	 */
+	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+		/*
+		 * If the BIOS Signature is present in memory, restore the
+		 * per TID microcode operating variables.
+		 */
+		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
+		    0x55AA) {
+			/*
+			 * Restore per TID negotiated values.
+			 */
+			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 tagqng_able);
+			for (tid = 0; tid <= ASC_MAX_TID; tid++) {
+				AdvWriteByteLram(iop_base,
+						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+						 max_cmd[tid]);
+			}
+		} else {
+			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
+				warn_code = ASC_WARN_BUSRESET_ERROR;
+			}
+		}
+	}
+
+	return warn_code;
+}
+
+/*
+ * Reset chip and SCSI Bus.
+ *
+ * Return Value:
+ *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.
+ *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.
+ */
+static int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
+{
+	int status;
+	ushort wdtr_able, sdtr_able, tagqng_able;
+	ushort ppr_able = 0;
+	uchar tid, max_cmd[ADV_MAX_TID + 1];
+	AdvPortAddr iop_base;
+	ushort bios_sig;
+
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	}
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
+
+	/*
+	 * Force the AdvInitAsc3550/38C0800Driver() function to
+	 * perform a SCSI Bus Reset by clearing the BIOS signature word.
+	 * The initialization functions assumes a SCSI Bus Reset is not
+	 * needed if the BIOS signature word is present.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+	AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);
+
+	/*
+	 * Stop chip and reset it.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);
+	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
+	mdelay(100);
+	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+			     ADV_CTRL_REG_CMD_WR_IO_REG);
+
+	/*
+	 * Reset Adv Library error code, if any, and try
+	 * re-initializing the chip.
+	 */
+	asc_dvc->err_code = 0;
+	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		status = AdvInitAsc38C1600Driver(asc_dvc);
+	} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+		status = AdvInitAsc38C0800Driver(asc_dvc);
+	} else {
+		status = AdvInitAsc3550Driver(asc_dvc);
+	}
+
+	/* Translate initialization return value to status value. */
+	if (status == 0) {
+		status = ADV_TRUE;
+	} else {
+		status = ADV_FALSE;
+	}
+
+	/*
+	 * Restore the BIOS signature word.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+
+	/*
+	 * Restore per TID negotiated values.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				 max_cmd[tid]);
+	}
+
+	return status;
+}
+
+/*
+ * adv_async_callback() - Adv Library asynchronous event callback function.
+ */
+static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
+{
+	switch (code) {
+	case ADV_ASYNC_SCSI_BUS_RESET_DET:
+		/*
+		 * The firmware detected a SCSI Bus reset.
+		 */
+		ASC_DBG(0,
+			"adv_async_callback: ADV_ASYNC_SCSI_BUS_RESET_DET\n");
+		break;
+
+	case ADV_ASYNC_RDMA_FAILURE:
+		/*
+		 * Handle RDMA failure by resetting the SCSI Bus and
+		 * possibly the chip if it is unresponsive. Log the error
+		 * with a unique code.
+		 */
+		ASC_DBG(0, "adv_async_callback: ADV_ASYNC_RDMA_FAILURE\n");
+		AdvResetChipAndSB(adv_dvc_varp);
+		break;
+
+	case ADV_HOST_SCSI_BUS_RESET:
+		/*
+		 * Host generated SCSI bus reset occurred.
+		 */
+		ASC_DBG(0, "adv_async_callback: ADV_HOST_SCSI_BUS_RESET\n");
+		break;
+
+	default:
+		ASC_DBG1(0, "DvcAsyncCallBack: unknown code 0x%x\n", code);
+		break;
+	}
+}
+
+/*
+ * adv_isr_callback() - Second Level Interrupt Handler called by AdvISR().
+ *
+ * Callback function for the Wide SCSI Adv Library.
+ */
+static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
+{
+	asc_board_t *boardp;
+	adv_req_t *reqp;
+	adv_sgblk_t *sgblkp;
+	struct scsi_cmnd *scp;
+	struct Scsi_Host *shost;
+	ADV_DCNT resid_cnt;
+
+	ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
+		 (ulong)adv_dvc_varp, (ulong)scsiqp);
+	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
+
+	/*
+	 * Get the adv_req_t structure for the command that has been
+	 * completed. The adv_req_t structure actually contains the
+	 * completed ADV_SCSI_REQ_Q structure.
+	 */
+	reqp = (adv_req_t *)ADV_U32_TO_VADDR(scsiqp->srb_ptr);
+	ASC_DBG1(1, "adv_isr_callback: reqp 0x%lx\n", (ulong)reqp);
+	if (reqp == NULL) {
+		ASC_PRINT("adv_isr_callback: reqp is NULL\n");
+		return;
+	}
+
+	/*
+	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
+	 * command that has been completed.
+	 *
+	 * Note: The adv_req_t request structure and adv_sgblk_t structure,
+	 * if any, are dropped, because a board structure pointer can not be
+	 * determined.
+	 */
+	scp = reqp->cmndp;
+	ASC_DBG1(1, "adv_isr_callback: scp 0x%lx\n", (ulong)scp);
+	if (scp == NULL) {
+		ASC_PRINT
+		    ("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");
+		return;
+	}
+	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+
+	shost = scp->device->host;
+	ASC_STATS(shost, callback);
+	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
+
+	boardp = ASC_BOARDP(shost);
+	BUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);
+
+	/*
+	 * 'done_status' contains the command's ending status.
+	 */
+	switch (scsiqp->done_status) {
+	case QD_NO_ERROR:
+		ASC_DBG(2, "adv_isr_callback: QD_NO_ERROR\n");
+		scp->result = 0;
+
+		/*
+		 * Check for an underrun condition.
+		 *
+		 * If there was no error and an underrun condition, then
+		 * then return the number of underrun bytes.
+		 */
+		resid_cnt = le32_to_cpu(scsiqp->data_cnt);
+		if (scp->request_bufflen != 0 && resid_cnt != 0 &&
+		    resid_cnt <= scp->request_bufflen) {
+			ASC_DBG1(1,
+				 "adv_isr_callback: underrun condition %lu bytes\n",
+				 (ulong)resid_cnt);
+			scp->resid = resid_cnt;
+		}
+		break;
+
+	case QD_WITH_ERROR:
+		ASC_DBG(2, "adv_isr_callback: QD_WITH_ERROR\n");
+		switch (scsiqp->host_status) {
+		case QHSTA_NO_ERROR:
+			if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
+				ASC_DBG(2,
+					"adv_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
+						  sizeof(scp->sense_buffer));
+				/*
+				 * Note: The 'status_byte()' macro used by
+				 * target drivers defined in scsi.h shifts the
+				 * status byte returned by host drivers right
+				 * by 1 bit.  This is why target drivers also
+				 * use right shifted status byte definitions.
+				 * For instance target drivers use
+				 * CHECK_CONDITION, defined to 0x1, instead of
+				 * the SCSI defined check condition value of
+				 * 0x2. Host drivers are supposed to return
+				 * the status byte as it is defined by SCSI.
+				 */
+				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
+				    STATUS_BYTE(scsiqp->scsi_status);
+			} else {
+				scp->result = STATUS_BYTE(scsiqp->scsi_status);
+			}
+			break;
+
+		default:
+			/* Some other QHSTA error occurred. */
+			ASC_DBG1(1, "adv_isr_callback: host_status 0x%x\n",
+				 scsiqp->host_status);
+			scp->result = HOST_BYTE(DID_BAD_TARGET);
+			break;
+		}
+		break;
+
+	case QD_ABORTED_BY_HOST:
+		ASC_DBG(1, "adv_isr_callback: QD_ABORTED_BY_HOST\n");
+		scp->result =
+		    HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);
+		break;
+
+	default:
+		ASC_DBG1(1, "adv_isr_callback: done_status 0x%x\n",
+			 scsiqp->done_status);
+		scp->result =
+		    HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);
+		break;
+	}
+
+	/*
+	 * If the 'init_tidmask' bit isn't already set for the target and the
+	 * current request finished normally, then set the bit for the target
+	 * to indicate that a device is present.
+	 */
+	if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
+	    scsiqp->done_status == QD_NO_ERROR &&
+	    scsiqp->host_status == QHSTA_NO_ERROR) {
+		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+	}
+
+	asc_scsi_done(scp);
+
+	/*
+	 * Free all 'adv_sgblk_t' structures allocated for the request.
+	 */
+	while ((sgblkp = reqp->sgblkp) != NULL) {
+		/* Remove 'sgblkp' from the request list. */
+		reqp->sgblkp = sgblkp->next_sgblkp;
+
+		/* Add 'sgblkp' to the board free list. */
+		sgblkp->next_sgblkp = boardp->adv_sgblkp;
+		boardp->adv_sgblkp = sgblkp;
+	}
+
+	/*
+	 * Free the adv_req_t structure used with the command by adding
+	 * it back to the board free list.
+	 */
+	reqp->next_reqp = boardp->adv_reqp;
+	boardp->adv_reqp = reqp;
+
+	ASC_DBG(1, "adv_isr_callback: done\n");
+
+	return;
+}
+
+/*
+ * Adv Library Interrupt Service Routine
+ *
+ *  This function is called by a driver's interrupt service routine.
+ *  The function disables and re-enables interrupts.
+ *
+ *  When a microcode idle command is completed, the ADV_DVC_VAR
+ *  'idle_cmd_done' field is set to ADV_TRUE.
+ *
+ *  Note: AdvISR() can be called when interrupts are disabled or even
+ *  when there is no hardware interrupt condition present. It will
+ *  always check for completed idle commands and microcode requests.
+ *  This is an important feature that shouldn't be changed because it
+ *  allows commands to be completed from polling mode loops.
+ *
+ * Return:
+ *   ADV_TRUE(1) - interrupt was pending
+ *   ADV_FALSE(0) - no interrupt was pending
+ */
+static int AdvISR(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	uchar int_stat;
+	ushort target_bit;
+	ADV_CARR_T *free_carrp;
+	ADV_VADDR irq_next_vpa;
+	ADV_SCSI_REQ_Q *scsiq;
+
+	iop_base = asc_dvc->iop_base;
+
+	/* Reading the register clears the interrupt. */
+	int_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);
+
+	if ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |
+			 ADV_INTR_STATUS_INTRC)) == 0) {
+		return ADV_FALSE;
+	}
+
+	/*
+	 * Notify the driver of an asynchronous microcode condition by
+	 * calling the adv_async_callback function. The function
+	 * is passed the microcode ASC_MC_INTRB_CODE byte value.
+	 */
+	if (int_stat & ADV_INTR_STATUS_INTRB) {
+		uchar intrb_code;
+
+		AdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);
+
+		if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
+		    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+			if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
+			    asc_dvc->carr_pending_cnt != 0) {
+				AdvWriteByteRegister(iop_base, IOPB_TICKLE,
+						     ADV_TICKLE_A);
+				if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+					AdvWriteByteRegister(iop_base,
+							     IOPB_TICKLE,
+							     ADV_TICKLE_NOP);
+				}
+			}
+		}
+
+		adv_async_callback(asc_dvc, intrb_code);
+	}
+
+	/*
+	 * Check if the IRQ stopper carrier contains a completed request.
+	 */
+	while (((irq_next_vpa =
+		 le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0) {
+		/*
+		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
+		 * The RISC will have set 'areq_vpa' to a virtual address.
+		 *
+		 * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr
+		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
+		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
+		 * in AdvExeScsiQueue().
+		 */
+		scsiq = (ADV_SCSI_REQ_Q *)
+		    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));
+
+		/*
+		 * Request finished with good status and the queue was not
+		 * DMAed to host memory by the firmware. Set all status fields
+		 * to indicate good status.
+		 */
+		if ((irq_next_vpa & ASC_RQ_GOOD) != 0) {
+			scsiq->done_status = QD_NO_ERROR;
+			scsiq->host_status = scsiq->scsi_status = 0;
+			scsiq->data_cnt = 0L;
+		}
+
+		/*
+		 * Advance the stopper pointer to the next carrier
+		 * ignoring the lower four bits. Free the previous
+		 * stopper carrier.
+		 */
+		free_carrp = asc_dvc->irq_sp;
+		asc_dvc->irq_sp = (ADV_CARR_T *)
+		    ADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));
+
+		free_carrp->next_vpa =
+		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = free_carrp;
+		asc_dvc->carr_pending_cnt--;
+
+		target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);
+
+		/*
+		 * Clear request microcode control flag.
+		 */
+		scsiq->cntl = 0;
+
+		/*
+		 * Notify the driver of the completed request by passing
+		 * the ADV_SCSI_REQ_Q pointer to its callback function.
+		 */
+		scsiq->a_flag |= ADV_SCSIQ_DONE;
+		adv_isr_callback(asc_dvc, scsiq);
+		/*
+		 * Note: After the driver callback function is called, 'scsiq'
+		 * can no longer be referenced.
+		 *
+		 * Fall through and continue processing other completed
+		 * requests...
+		 */
+	}
+	return ADV_TRUE;
+}
+
+static int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)
+{
+	if (asc_dvc->err_code == 0) {
+		asc_dvc->err_code = err_code;
+		AscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
+				 err_code);
+	}
+	return err_code;
+}
+
+static void AscAckInterrupt(PortAddr iop_base)
+{
+	uchar host_flag;
+	uchar risc_flag;
+	ushort loop;
+
+	loop = 0;
+	do {
+		risc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);
+		if (loop++ > 0x7FFF) {
+			break;
+		}
+	} while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);
+	host_flag =
+	    AscReadLramByte(iop_base,
+			    ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
+			 (uchar)(host_flag | ASC_HOST_FLAG_ACK_INT));
+	AscSetChipStatus(iop_base, CIW_INT_ACK);
+	loop = 0;
+	while (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {
+		AscSetChipStatus(iop_base, CIW_INT_ACK);
+		if (loop++ > 3) {
+			break;
+		}
+	}
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
+	return;
+}
+
+static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)
+{
+	uchar *period_table;
+	int max_index;
+	int min_index;
+	int i;
+
+	period_table = asc_dvc->sdtr_period_tbl;
+	max_index = (int)asc_dvc->max_sdtr_index;
+	min_index = (int)asc_dvc->host_init_sdtr_index;
+	if ((syn_time <= period_table[max_index])) {
+		for (i = min_index; i < (max_index - 1); i++) {
+			if (syn_time <= period_table[i]) {
+				return (uchar)i;
+			}
+		}
+		return (uchar)max_index;
+	} else {
+		return (uchar)(max_index + 1);
+	}
+}
+
+static uchar
+AscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)
+{
+	EXT_MSG sdtr_buf;
+	uchar sdtr_period_index;
+	PortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+	sdtr_buf.msg_type = EXTENDED_MESSAGE;
+	sdtr_buf.msg_len = MS_SDTR_LEN;
+	sdtr_buf.msg_req = EXTENDED_SDTR;
+	sdtr_buf.xfer_period = sdtr_period;
+	sdtr_offset &= ASC_SYN_MAX_OFFSET;
+	sdtr_buf.req_ack_offset = sdtr_offset;
+	sdtr_period_index = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
+	if (sdtr_period_index <= asc_dvc->max_sdtr_index) {
+		AscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,
+					(uchar *)&sdtr_buf,
+					sizeof(EXT_MSG) >> 1);
+		return ((sdtr_period_index << 4) | sdtr_offset);
+	} else {
+		sdtr_buf.req_ack_offset = 0;
+		AscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,
+					(uchar *)&sdtr_buf,
+					sizeof(EXT_MSG) >> 1);
+		return 0;
+	}
+}
+
+static uchar
+AscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)
+{
+	uchar byte;
+	uchar sdtr_period_ix;
+
+	sdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
+	if (sdtr_period_ix > asc_dvc->max_sdtr_index) {
+		return 0xFF;
+	}
+	byte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);
+	return byte;
+}
+
+static int AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)
+{
+	ASC_SCSI_BIT_ID_TYPE org_id;
+	int i;
+	int sta = TRUE;
+
+	AscSetBank(iop_base, 1);
+	org_id = AscReadChipDvcID(iop_base);
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if (org_id == (0x01 << i))
+			break;
+	}
+	org_id = (ASC_SCSI_BIT_ID_TYPE) i;
+	AscWriteChipDvcID(iop_base, id);
+	if (AscReadChipDvcID(iop_base) == (0x01 << id)) {
+		AscSetBank(iop_base, 0);
+		AscSetChipSyn(iop_base, sdtr_data);
+		if (AscGetChipSyn(iop_base) != sdtr_data) {
+			sta = FALSE;
+		}
+	} else {
+		sta = FALSE;
+	}
+	AscSetBank(iop_base, 1);
+	AscWriteChipDvcID(iop_base, org_id);
+	AscSetBank(iop_base, 0);
+	return (sta);
+}
+
+static void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)
+{
+	AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
+	AscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);
+}
+
+static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
+{
+	EXT_MSG ext_msg;
+	EXT_MSG out_msg;
+	ushort halt_q_addr;
+	int sdtr_accept;
+	ushort int_halt_code;
+	ASC_SCSI_BIT_ID_TYPE scsi_busy;
+	ASC_SCSI_BIT_ID_TYPE target_id;
+	PortAddr iop_base;
+	uchar tag_code;
+	uchar q_status;
+	uchar halt_qp;
+	uchar sdtr_data;
+	uchar target_ix;
+	uchar q_cntl, tid_no;
+	uchar cur_dvc_qng;
+	uchar asyn_sdtr;
+	uchar scsi_status;
+	asc_board_t *boardp;
+
+	BUG_ON(!asc_dvc->drv_ptr);
+	boardp = asc_dvc->drv_ptr;
+
+	iop_base = asc_dvc->iop_base;
+	int_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);
+
+	halt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);
+	halt_q_addr = ASC_QNO_TO_QADDR(halt_qp);
+	target_ix = AscReadLramByte(iop_base,
+				    (ushort)(halt_q_addr +
+					     (ushort)ASC_SCSIQ_B_TARGET_IX));
+	q_cntl = AscReadLramByte(iop_base,
+			    (ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	target_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);
+	if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+		asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;
+	} else {
+		asyn_sdtr = 0;
+	}
+	if (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {
+		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+			AscSetChipSDTR(iop_base, 0, tid_no);
+			boardp->sdtr_data[tid_no] = 0;
+		}
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {
+		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+			boardp->sdtr_data[tid_no] = asyn_sdtr;
+		}
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
+		AscMemWordCopyPtrFromLram(iop_base,
+					  ASCV_MSGIN_BEG,
+					  (uchar *)&ext_msg,
+					  sizeof(EXT_MSG) >> 1);
+
+		if (ext_msg.msg_type == EXTENDED_MESSAGE &&
+		    ext_msg.msg_req == EXTENDED_SDTR &&
+		    ext_msg.msg_len == MS_SDTR_LEN) {
+			sdtr_accept = TRUE;
+			if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
+
+				sdtr_accept = FALSE;
+				ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
+			}
+			if ((ext_msg.xfer_period <
+			     asc_dvc->sdtr_period_tbl[asc_dvc->
+						      host_init_sdtr_index])
+			    || (ext_msg.xfer_period >
+				asc_dvc->sdtr_period_tbl[asc_dvc->
+							 max_sdtr_index])) {
+				sdtr_accept = FALSE;
+				ext_msg.xfer_period =
+				    asc_dvc->sdtr_period_tbl[asc_dvc->
+							     host_init_sdtr_index];
+			}
+			if (sdtr_accept) {
+				sdtr_data =
+				    AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
+						   ext_msg.req_ack_offset);
+				if ((sdtr_data == 0xFF)) {
+
+					q_cntl |= QC_MSG_OUT;
+					asc_dvc->init_sdtr &= ~target_id;
+					asc_dvc->sdtr_done &= ~target_id;
+					AscSetChipSDTR(iop_base, asyn_sdtr,
+						       tid_no);
+					boardp->sdtr_data[tid_no] = asyn_sdtr;
+				}
+			}
+			if (ext_msg.req_ack_offset == 0) {
+
+				q_cntl &= ~QC_MSG_OUT;
+				asc_dvc->init_sdtr &= ~target_id;
+				asc_dvc->sdtr_done &= ~target_id;
+				AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+			} else {
+				if (sdtr_accept && (q_cntl & QC_MSG_OUT)) {
+
+					q_cntl &= ~QC_MSG_OUT;
+					asc_dvc->sdtr_done |= target_id;
+					asc_dvc->init_sdtr |= target_id;
+					asc_dvc->pci_fix_asyn_xfer &=
+					    ~target_id;
+					sdtr_data =
+					    AscCalSDTRData(asc_dvc,
+							   ext_msg.xfer_period,
+							   ext_msg.
+							   req_ack_offset);
+					AscSetChipSDTR(iop_base, sdtr_data,
+						       tid_no);
+					boardp->sdtr_data[tid_no] = sdtr_data;
+				} else {
+
+					q_cntl |= QC_MSG_OUT;
+					AscMsgOutSDTR(asc_dvc,
+						      ext_msg.xfer_period,
+						      ext_msg.req_ack_offset);
+					asc_dvc->pci_fix_asyn_xfer &=
+					    ~target_id;
+					sdtr_data =
+					    AscCalSDTRData(asc_dvc,
+							   ext_msg.xfer_period,
+							   ext_msg.
+							   req_ack_offset);
+					AscSetChipSDTR(iop_base, sdtr_data,
+						       tid_no);
+					boardp->sdtr_data[tid_no] = sdtr_data;
+					asc_dvc->sdtr_done |= target_id;
+					asc_dvc->init_sdtr |= target_id;
+				}
+			}
+
+			AscWriteLramByte(iop_base,
+					 (ushort)(halt_q_addr +
+						  (ushort)ASC_SCSIQ_B_CNTL),
+					 q_cntl);
+			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+			return (0);
+		} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&
+			   ext_msg.msg_req == EXTENDED_WDTR &&
+			   ext_msg.msg_len == MS_WDTR_LEN) {
+
+			ext_msg.wdtr_width = 0;
+			AscMemWordCopyPtrToLram(iop_base,
+						ASCV_MSGOUT_BEG,
+						(uchar *)&ext_msg,
+						sizeof(EXT_MSG) >> 1);
+			q_cntl |= QC_MSG_OUT;
+			AscWriteLramByte(iop_base,
+					 (ushort)(halt_q_addr +
+						  (ushort)ASC_SCSIQ_B_CNTL),
+					 q_cntl);
+			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+			return (0);
+		} else {
+
+			ext_msg.msg_type = MESSAGE_REJECT;
+			AscMemWordCopyPtrToLram(iop_base,
+						ASCV_MSGOUT_BEG,
+						(uchar *)&ext_msg,
+						sizeof(EXT_MSG) >> 1);
+			q_cntl |= QC_MSG_OUT;
+			AscWriteLramByte(iop_base,
+					 (ushort)(halt_q_addr +
+						  (ushort)ASC_SCSIQ_B_CNTL),
+					 q_cntl);
+			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+			return (0);
+		}
+	} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {
+
+		q_cntl |= QC_REQ_SENSE;
+
+		if ((asc_dvc->init_sdtr & target_id) != 0) {
+
+			asc_dvc->sdtr_done &= ~target_id;
+
+			sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+			q_cntl |= QC_MSG_OUT;
+			AscMsgOutSDTR(asc_dvc,
+				      asc_dvc->
+				      sdtr_period_tbl[(sdtr_data >> 4) &
+						      (uchar)(asc_dvc->
+							      max_sdtr_index -
+							      1)],
+				      (uchar)(sdtr_data & (uchar)
+					      ASC_SYN_MAX_OFFSET));
+		}
+
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
+
+		tag_code = AscReadLramByte(iop_base,
+					   (ushort)(halt_q_addr + (ushort)
+						    ASC_SCSIQ_B_TAG_CODE));
+		tag_code &= 0xDC;
+		if ((asc_dvc->pci_fix_asyn_xfer & target_id)
+		    && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)
+		    ) {
+
+			tag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT
+				     | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);
+
+		}
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_TAG_CODE),
+				 tag_code);
+
+		q_status = AscReadLramByte(iop_base,
+					   (ushort)(halt_q_addr + (ushort)
+						    ASC_SCSIQ_B_STATUS));
+		q_status |= (QS_READY | QS_BUSY);
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_STATUS),
+				 q_status);
+
+		scsi_busy = AscReadLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B);
+		scsi_busy &= ~target_id;
+		AscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);
+
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {
+
+		AscMemWordCopyPtrFromLram(iop_base,
+					  ASCV_MSGOUT_BEG,
+					  (uchar *)&out_msg,
+					  sizeof(EXT_MSG) >> 1);
+
+		if ((out_msg.msg_type == EXTENDED_MESSAGE) &&
+		    (out_msg.msg_len == MS_SDTR_LEN) &&
+		    (out_msg.msg_req == EXTENDED_SDTR)) {
+
+			asc_dvc->init_sdtr &= ~target_id;
+			asc_dvc->sdtr_done &= ~target_id;
+			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+			boardp->sdtr_data[tid_no] = asyn_sdtr;
+		}
+		q_cntl &= ~QC_MSG_OUT;
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {
+
+		scsi_status = AscReadLramByte(iop_base,
+					      (ushort)((ushort)halt_q_addr +
+						       (ushort)
+						       ASC_SCSIQ_SCSI_STATUS));
+		cur_dvc_qng =
+		    AscReadLramByte(iop_base,
+				    (ushort)((ushort)ASC_QADR_BEG +
+					     (ushort)target_ix));
+		if ((cur_dvc_qng > 0) && (asc_dvc->cur_dvc_qng[tid_no] > 0)) {
+
+			scsi_busy = AscReadLramByte(iop_base,
+						    (ushort)ASCV_SCSIBUSY_B);
+			scsi_busy |= target_id;
+			AscWriteLramByte(iop_base,
+					 (ushort)ASCV_SCSIBUSY_B, scsi_busy);
+			asc_dvc->queue_full_or_busy |= target_id;
+
+			if (scsi_status == SAM_STAT_TASK_SET_FULL) {
+				if (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {
+					cur_dvc_qng -= 1;
+					asc_dvc->max_dvc_qng[tid_no] =
+					    cur_dvc_qng;
+
+					AscWriteLramByte(iop_base,
+							 (ushort)((ushort)
+								  ASCV_MAX_DVC_QNG_BEG
+								  + (ushort)
+								  tid_no),
+							 cur_dvc_qng);
+
+					/*
+					 * Set the device queue depth to the
+					 * number of active requests when the
+					 * QUEUE FULL condition was encountered.
+					 */
+					boardp->queue_full |= target_id;
+					boardp->queue_full_cnt[tid_no] =
+					    cur_dvc_qng;
+				}
+			}
+		}
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	}
+#if CC_VERY_LONG_SG_LIST
+	else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC) {
+		uchar q_no;
+		ushort q_addr;
+		uchar sg_wk_q_no;
+		uchar first_sg_wk_q_no;
+		ASC_SCSI_Q *scsiq;	/* Ptr to driver request. */
+		ASC_SG_HEAD *sg_head;	/* Ptr to driver SG request. */
+		ASC_SG_LIST_Q scsi_sg_q;	/* Structure written to queue. */
+		ushort sg_list_dwords;
+		ushort sg_entry_cnt;
+		uchar next_qp;
+		int i;
+
+		q_no = AscReadLramByte(iop_base, (ushort)ASCV_REQ_SG_LIST_QP);
+		if (q_no == ASC_QLINK_END)
+			return 0;
+
+		q_addr = ASC_QNO_TO_QADDR(q_no);
+
+		/*
+		 * Convert the request's SRB pointer to a host ASC_SCSI_REQ
+		 * structure pointer using a macro provided by the driver.
+		 * The ASC_SCSI_REQ pointer provides a pointer to the
+		 * host ASC_SG_HEAD structure.
+		 */
+		/* Read request's SRB pointer. */
+		scsiq = (ASC_SCSI_Q *)
+		    ASC_SRB2SCSIQ(ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,
+								    (ushort)
+								    (q_addr +
+								     ASC_SCSIQ_D_SRBPTR))));
+
+		/*
+		 * Get request's first and working SG queue.
+		 */
+		sg_wk_q_no = AscReadLramByte(iop_base,
+					     (ushort)(q_addr +
+						      ASC_SCSIQ_B_SG_WK_QP));
+
+		first_sg_wk_q_no = AscReadLramByte(iop_base,
+						   (ushort)(q_addr +
+							    ASC_SCSIQ_B_FIRST_SG_WK_QP));
+
+		/*
+		 * Reset request's working SG queue back to the
+		 * first SG queue.
+		 */
+		AscWriteLramByte(iop_base,
+				 (ushort)(q_addr +
+					  (ushort)ASC_SCSIQ_B_SG_WK_QP),
+				 first_sg_wk_q_no);
+
+		sg_head = scsiq->sg_head;
+
+		/*
+		 * Set sg_entry_cnt to the number of SG elements
+		 * that will be completed on this interrupt.
+		 *
+		 * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1
+		 * SG elements. The data_cnt and data_addr fields which
+		 * add 1 to the SG element capacity are not used when
+		 * restarting SG handling after a halt.
+		 */
+		if (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1)) {
+			sg_entry_cnt = ASC_MAX_SG_LIST - 1;
+
+			/*
+			 * Keep track of remaining number of SG elements that
+			 * will need to be handled on the next interrupt.
+			 */
+			scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
+		} else {
+			sg_entry_cnt = scsiq->remain_sg_entry_cnt;
+			scsiq->remain_sg_entry_cnt = 0;
+		}
+
+		/*
+		 * Copy SG elements into the list of allocated SG queues.
+		 *
+		 * Last index completed is saved in scsiq->next_sg_index.
+		 */
+		next_qp = first_sg_wk_q_no;
+		q_addr = ASC_QNO_TO_QADDR(next_qp);
+		scsi_sg_q.sg_head_qp = q_no;
+		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
+		for (i = 0; i < sg_head->queue_cnt; i++) {
+			scsi_sg_q.seq_no = i + 1;
+			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
+				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
+				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
+				/*
+				 * After very first SG queue RISC FW uses next
+				 * SG queue first element then checks sg_list_cnt
+				 * against zero and then decrements, so set
+				 * sg_list_cnt 1 less than number of SG elements
+				 * in each SG queue.
+				 */
+				scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
+				scsi_sg_q.sg_cur_list_cnt =
+				    ASC_SG_LIST_PER_Q - 1;
+			} else {
+				/*
+				 * This is the last SG queue in the list of
+				 * allocated SG queues. If there are more
+				 * SG elements than will fit in the allocated
+				 * queues, then set the QCSG_SG_XFER_MORE flag.
+				 */
+				if (scsiq->remain_sg_entry_cnt != 0) {
+					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
+				} else {
+					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
+				}
+				/* equals sg_entry_cnt * 2 */
+				sg_list_dwords = sg_entry_cnt << 1;
+				scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
+				scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
+				sg_entry_cnt = 0;
+			}
+
+			scsi_sg_q.q_no = next_qp;
+			AscMemWordCopyPtrToLram(iop_base,
+						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
+						(uchar *)&scsi_sg_q,
+						sizeof(ASC_SG_LIST_Q) >> 1);
+
+			AscMemDWordCopyPtrToLram(iop_base,
+						 q_addr + ASC_SGQ_LIST_BEG,
+						 (uchar *)&sg_head->
+						 sg_list[scsiq->next_sg_index],
+						 sg_list_dwords);
+
+			scsiq->next_sg_index += ASC_SG_LIST_PER_Q;
+
+			/*
+			 * If the just completed SG queue contained the
+			 * last SG element, then no more SG queues need
+			 * to be written.
+			 */
+			if (scsi_sg_q.cntl & QCSG_SG_XFER_END) {
+				break;
+			}
+
+			next_qp = AscReadLramByte(iop_base,
+						  (ushort)(q_addr +
+							   ASC_SCSIQ_B_FWD));
+			q_addr = ASC_QNO_TO_QADDR(next_qp);
+		}
+
+		/*
+		 * Clear the halt condition so the RISC will be restarted
+		 * after the return.
+		 */
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	}
+#endif /* CC_VERY_LONG_SG_LIST */
+	return (0);
+}
 
 /*
- * EEPROM Configuration.
+ * void
+ * DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
  *
- * All drivers should use this structure to set the default EEPROM
- * configuration. The BIOS now uses this structure when it is built.
- * Additional structure information can be found in a_condor.h where
- * the structure is defined.
+ * Calling/Exit State:
+ *    none
  *
- * The *_Field_IsChar structs are needed to correct for endianness.
- * These values are read from the board 16 bits at a time directly
- * into the structs. Because some fields are char, the values will be
- * in the wrong order. The *_Field_IsChar tells when to flip the
- * bytes. Data read and written to PCI memory is automatically swapped
- * on big-endian platforms so char fields read as words are actually being
- * unswapped on big-endian platforms.
+ * Description:
+ *     Input an ASC_QDONE_INFO structure from the chip
  */
-static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __devinitdata = {
-	ADV_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
-	0x0000,			/* cfg_msw */
-	0xFFFF,			/* disc_enable */
-	0xFFFF,			/* wdtr_able */
-	0xFFFF,			/* sdtr_able */
-	0xFFFF,			/* start_motor */
-	0xFFFF,			/* tagqng_able */
-	0xFFFF,			/* bios_scan */
-	0,			/* scam_tolerant */
-	7,			/* adapter_scsi_id */
-	0,			/* bios_boot_delay */
-	3,			/* scsi_reset_delay */
-	0,			/* bios_id_lun */
-	0,			/* termination */
-	0,			/* reserved1 */
-	0xFFE7,			/* bios_ctrl */
-	0xFFFF,			/* ultra_able */
-	0,			/* reserved2 */
-	ASC_DEF_MAX_HOST_QNG,	/* max_host_qng */
-	ASC_DEF_MAX_DVC_QNG,	/* max_dvc_qng */
-	0,			/* dvc_cntl */
-	0,			/* bug_fix */
-	0,			/* serial_number_word1 */
-	0,			/* serial_number_word2 */
-	0,			/* serial_number_word3 */
-	0,			/* check_sum */
-	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-	,			/* oem_name[16] */
-	0,			/* dvc_err_code */
-	0,			/* adv_err_code */
-	0,			/* adv_err_addr */
-	0,			/* saved_dvc_err_code */
-	0,			/* saved_adv_err_code */
-	0,			/* saved_adv_err_addr */
-	0			/* num_of_err */
-};
+static void
+DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
+{
+	int i;
+	ushort word;
+
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		if (i == 10) {
+			continue;
+		}
+		word = inpw(iop_base + IOP_RAM_DATA);
+		inbuf[i] = word & 0xff;
+		inbuf[i + 1] = (word >> 8) & 0xff;
+	}
+	ASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);
+}
+
+static uchar
+_AscCopyLramScsiDoneQ(PortAddr iop_base,
+		      ushort q_addr,
+		      ASC_QDONE_INFO *scsiq, ASC_DCNT max_dma_count)
+{
+	ushort _val;
+	uchar sg_queue_cnt;
+
+	DvcGetQinfo(iop_base,
+		    q_addr + ASC_SCSIQ_DONE_INFO_BEG,
+		    (uchar *)scsiq,
+		    (sizeof(ASC_SCSIQ_2) + sizeof(ASC_SCSIQ_3)) / 2);
+
+	_val = AscReadLramWord(iop_base,
+			       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS));
+	scsiq->q_status = (uchar)_val;
+	scsiq->q_no = (uchar)(_val >> 8);
+	_val = AscReadLramWord(iop_base,
+			       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_CNTL));
+	scsiq->cntl = (uchar)_val;
+	sg_queue_cnt = (uchar)(_val >> 8);
+	_val = AscReadLramWord(iop_base,
+			       (ushort)(q_addr +
+					(ushort)ASC_SCSIQ_B_SENSE_LEN));
+	scsiq->sense_len = (uchar)_val;
+	scsiq->extra_bytes = (uchar)(_val >> 8);
+
+	/*
+	 * Read high word of remain bytes from alternate location.
+	 */
+	scsiq->remain_bytes = (((ADV_DCNT)AscReadLramWord(iop_base,
+							  (ushort)(q_addr +
+								   (ushort)
+								   ASC_SCSIQ_W_ALT_DC1)))
+			       << 16);
+	/*
+	 * Read low word of remain bytes from original location.
+	 */
+	scsiq->remain_bytes += AscReadLramWord(iop_base,
+					       (ushort)(q_addr + (ushort)
+							ASC_SCSIQ_DW_REMAIN_XFER_CNT));
+
+	scsiq->remain_bytes &= max_dma_count;
+	return sg_queue_cnt;
+}
+
+/*
+ * asc_isr_callback() - Second Level Interrupt Handler called by AscISR().
+ *
+ * Interrupt callback function for the Narrow SCSI Asc Library.
+ */
+static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
+{
+	asc_board_t *boardp;
+	struct scsi_cmnd *scp;
+	struct Scsi_Host *shost;
+
+	ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
+		 (ulong)asc_dvc_varp, (ulong)qdonep);
+	ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
+
+	/*
+	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
+	 * command that has been completed.
+	 */
+	scp = (struct scsi_cmnd *)ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
+	ASC_DBG1(1, "asc_isr_callback: scp 0x%lx\n", (ulong)scp);
+
+	if (scp == NULL) {
+		ASC_PRINT("asc_isr_callback: scp is NULL\n");
+		return;
+	}
+	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+
+	shost = scp->device->host;
+	ASC_STATS(shost, callback);
+	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
+
+	boardp = ASC_BOARDP(shost);
+	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
+
+	/*
+	 * 'qdonep' contains the command's ending status.
+	 */
+	switch (qdonep->d3.done_stat) {
+	case QD_NO_ERROR:
+		ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
+		scp->result = 0;
+
+		/*
+		 * Check for an underrun condition.
+		 *
+		 * If there was no error and an underrun condition, then
+		 * return the number of underrun bytes.
+		 */
+		if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
+		    qdonep->remain_bytes <= scp->request_bufflen) {
+			ASC_DBG1(1,
+				 "asc_isr_callback: underrun condition %u bytes\n",
+				 (unsigned)qdonep->remain_bytes);
+			scp->resid = qdonep->remain_bytes;
+		}
+		break;
+
+	case QD_WITH_ERROR:
+		ASC_DBG(2, "asc_isr_callback: QD_WITH_ERROR\n");
+		switch (qdonep->d3.host_stat) {
+		case QHSTA_NO_ERROR:
+			if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
+				ASC_DBG(2,
+					"asc_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
+						  sizeof(scp->sense_buffer));
+				/*
+				 * Note: The 'status_byte()' macro used by
+				 * target drivers defined in scsi.h shifts the
+				 * status byte returned by host drivers right
+				 * by 1 bit.  This is why target drivers also
+				 * use right shifted status byte definitions.
+				 * For instance target drivers use
+				 * CHECK_CONDITION, defined to 0x1, instead of
+				 * the SCSI defined check condition value of
+				 * 0x2. Host drivers are supposed to return
+				 * the status byte as it is defined by SCSI.
+				 */
+				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
+				    STATUS_BYTE(qdonep->d3.scsi_stat);
+			} else {
+				scp->result = STATUS_BYTE(qdonep->d3.scsi_stat);
+			}
+			break;
+
+		default:
+			/* QHSTA error occurred */
+			ASC_DBG1(1, "asc_isr_callback: host_stat 0x%x\n",
+				 qdonep->d3.host_stat);
+			scp->result = HOST_BYTE(DID_BAD_TARGET);
+			break;
+		}
+		break;
+
+	case QD_ABORTED_BY_HOST:
+		ASC_DBG(1, "asc_isr_callback: QD_ABORTED_BY_HOST\n");
+		scp->result =
+		    HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.
+						    scsi_msg) |
+		    STATUS_BYTE(qdonep->d3.scsi_stat);
+		break;
+
+	default:
+		ASC_DBG1(1, "asc_isr_callback: done_stat 0x%x\n",
+			 qdonep->d3.done_stat);
+		scp->result =
+		    HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.
+						    scsi_msg) |
+		    STATUS_BYTE(qdonep->d3.scsi_stat);
+		break;
+	}
+
+	/*
+	 * If the 'init_tidmask' bit isn't already set for the target and the
+	 * current request finished normally, then set the bit for the target
+	 * to indicate that a device is present.
+	 */
+	if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
+	    qdonep->d3.done_stat == QD_NO_ERROR &&
+	    qdonep->d3.host_stat == QHSTA_NO_ERROR) {
+		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+	}
 
-static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __devinitdata = {
-	0,			/* cfg_lsw */
-	0,			/* cfg_msw */
-	0,			/* -disc_enable */
-	0,			/* wdtr_able */
-	0,			/* sdtr_able */
-	0,			/* start_motor */
-	0,			/* tagqng_able */
-	0,			/* bios_scan */
-	0,			/* scam_tolerant */
-	1,			/* adapter_scsi_id */
-	1,			/* bios_boot_delay */
-	1,			/* scsi_reset_delay */
-	1,			/* bios_id_lun */
-	1,			/* termination */
-	1,			/* reserved1 */
-	0,			/* bios_ctrl */
-	0,			/* ultra_able */
-	0,			/* reserved2 */
-	1,			/* max_host_qng */
-	1,			/* max_dvc_qng */
-	0,			/* dvc_cntl */
-	0,			/* bug_fix */
-	0,			/* serial_number_word1 */
-	0,			/* serial_number_word2 */
-	0,			/* serial_number_word3 */
-	0,			/* check_sum */
-	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
-	,			/* oem_name[16] */
-	0,			/* dvc_err_code */
-	0,			/* adv_err_code */
-	0,			/* adv_err_addr */
-	0,			/* saved_dvc_err_code */
-	0,			/* saved_adv_err_code */
-	0,			/* saved_adv_err_addr */
-	0			/* num_of_err */
-};
+	asc_scsi_done(scp);
 
-static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __devinitdata = {
-	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
-	0x0000,			/* 01 cfg_msw */
-	0xFFFF,			/* 02 disc_enable */
-	0xFFFF,			/* 03 wdtr_able */
-	0x4444,			/* 04 sdtr_speed1 */
-	0xFFFF,			/* 05 start_motor */
-	0xFFFF,			/* 06 tagqng_able */
-	0xFFFF,			/* 07 bios_scan */
-	0,			/* 08 scam_tolerant */
-	7,			/* 09 adapter_scsi_id */
-	0,			/*    bios_boot_delay */
-	3,			/* 10 scsi_reset_delay */
-	0,			/*    bios_id_lun */
-	0,			/* 11 termination_se */
-	0,			/*    termination_lvd */
-	0xFFE7,			/* 12 bios_ctrl */
-	0x4444,			/* 13 sdtr_speed2 */
-	0x4444,			/* 14 sdtr_speed3 */
-	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
-	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
-	0,			/* 16 dvc_cntl */
-	0x4444,			/* 17 sdtr_speed4 */
-	0,			/* 18 serial_number_word1 */
-	0,			/* 19 serial_number_word2 */
-	0,			/* 20 serial_number_word3 */
-	0,			/* 21 check_sum */
-	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-	,			/* 22-29 oem_name[16] */
-	0,			/* 30 dvc_err_code */
-	0,			/* 31 adv_err_code */
-	0,			/* 32 adv_err_addr */
-	0,			/* 33 saved_dvc_err_code */
-	0,			/* 34 saved_adv_err_code */
-	0,			/* 35 saved_adv_err_addr */
-	0,			/* 36 reserved */
-	0,			/* 37 reserved */
-	0,			/* 38 reserved */
-	0,			/* 39 reserved */
-	0,			/* 40 reserved */
-	0,			/* 41 reserved */
-	0,			/* 42 reserved */
-	0,			/* 43 reserved */
-	0,			/* 44 reserved */
-	0,			/* 45 reserved */
-	0,			/* 46 reserved */
-	0,			/* 47 reserved */
-	0,			/* 48 reserved */
-	0,			/* 49 reserved */
-	0,			/* 50 reserved */
-	0,			/* 51 reserved */
-	0,			/* 52 reserved */
-	0,			/* 53 reserved */
-	0,			/* 54 reserved */
-	0,			/* 55 reserved */
-	0,			/* 56 cisptr_lsw */
-	0,			/* 57 cisprt_msw */
-	PCI_VENDOR_ID_ASP,	/* 58 subsysvid */
-	PCI_DEVICE_ID_38C0800_REV1,	/* 59 subsysid */
-	0,			/* 60 reserved */
-	0,			/* 61 reserved */
-	0,			/* 62 reserved */
-	0			/* 63 reserved */
-};
+	return;
+}
+
+static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
+{
+	uchar next_qp;
+	uchar n_q_used;
+	uchar sg_list_qp;
+	uchar sg_queue_cnt;
+	uchar q_cnt;
+	uchar done_q_tail;
+	uchar tid_no;
+	ASC_SCSI_BIT_ID_TYPE scsi_busy;
+	ASC_SCSI_BIT_ID_TYPE target_id;
+	PortAddr iop_base;
+	ushort q_addr;
+	ushort sg_q_addr;
+	uchar cur_target_qng;
+	ASC_QDONE_INFO scsiq_buf;
+	ASC_QDONE_INFO *scsiq;
+	int false_overrun;
+
+	iop_base = asc_dvc->iop_base;
+	n_q_used = 1;
+	scsiq = (ASC_QDONE_INFO *)&scsiq_buf;
+	done_q_tail = (uchar)AscGetVarDoneQTail(iop_base);
+	q_addr = ASC_QNO_TO_QADDR(done_q_tail);
+	next_qp = AscReadLramByte(iop_base,
+				  (ushort)(q_addr + (ushort)ASC_SCSIQ_B_FWD));
+	if (next_qp != ASC_QLINK_END) {
+		AscPutVarDoneQTail(iop_base, next_qp);
+		q_addr = ASC_QNO_TO_QADDR(next_qp);
+		sg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,
+						     asc_dvc->max_dma_count);
+		AscWriteLramByte(iop_base,
+				 (ushort)(q_addr +
+					  (ushort)ASC_SCSIQ_B_STATUS),
+				 (uchar)(scsiq->
+					 q_status & (uchar)~(QS_READY |
+							     QS_ABORTED)));
+		tid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);
+		target_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);
+		if ((scsiq->cntl & QC_SG_HEAD) != 0) {
+			sg_q_addr = q_addr;
+			sg_list_qp = next_qp;
+			for (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {
+				sg_list_qp = AscReadLramByte(iop_base,
+							     (ushort)(sg_q_addr
+								      + (ushort)
+								      ASC_SCSIQ_B_FWD));
+				sg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);
+				if (sg_list_qp == ASC_QLINK_END) {
+					AscSetLibErrorCode(asc_dvc,
+							   ASCQ_ERR_SG_Q_LINKS);
+					scsiq->d3.done_stat = QD_WITH_ERROR;
+					scsiq->d3.host_stat =
+					    QHSTA_D_QDONE_SG_LIST_CORRUPTED;
+					goto FATAL_ERR_QDONE;
+				}
+				AscWriteLramByte(iop_base,
+						 (ushort)(sg_q_addr + (ushort)
+							  ASC_SCSIQ_B_STATUS),
+						 QS_FREE);
+			}
+			n_q_used = sg_queue_cnt + 1;
+			AscPutVarDoneQTail(iop_base, sg_list_qp);
+		}
+		if (asc_dvc->queue_full_or_busy & target_id) {
+			cur_target_qng = AscReadLramByte(iop_base,
+							 (ushort)((ushort)
+								  ASC_QADR_BEG
+								  + (ushort)
+								  scsiq->d2.
+								  target_ix));
+			if (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {
+				scsi_busy = AscReadLramByte(iop_base, (ushort)
+							    ASCV_SCSIBUSY_B);
+				scsi_busy &= ~target_id;
+				AscWriteLramByte(iop_base,
+						 (ushort)ASCV_SCSIBUSY_B,
+						 scsi_busy);
+				asc_dvc->queue_full_or_busy &= ~target_id;
+			}
+		}
+		if (asc_dvc->cur_total_qng >= n_q_used) {
+			asc_dvc->cur_total_qng -= n_q_used;
+			if (asc_dvc->cur_dvc_qng[tid_no] != 0) {
+				asc_dvc->cur_dvc_qng[tid_no]--;
+			}
+		} else {
+			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);
+			scsiq->d3.done_stat = QD_WITH_ERROR;
+			goto FATAL_ERR_QDONE;
+		}
+		if ((scsiq->d2.srb_ptr == 0UL) ||
+		    ((scsiq->q_status & QS_ABORTED) != 0)) {
+			return (0x11);
+		} else if (scsiq->q_status == QS_DONE) {
+			false_overrun = FALSE;
+			if (scsiq->extra_bytes != 0) {
+				scsiq->remain_bytes +=
+				    (ADV_DCNT)scsiq->extra_bytes;
+			}
+			if (scsiq->d3.done_stat == QD_WITH_ERROR) {
+				if (scsiq->d3.host_stat ==
+				    QHSTA_M_DATA_OVER_RUN) {
+					if ((scsiq->
+					     cntl & (QC_DATA_IN | QC_DATA_OUT))
+					    == 0) {
+						scsiq->d3.done_stat =
+						    QD_NO_ERROR;
+						scsiq->d3.host_stat =
+						    QHSTA_NO_ERROR;
+					} else if (false_overrun) {
+						scsiq->d3.done_stat =
+						    QD_NO_ERROR;
+						scsiq->d3.host_stat =
+						    QHSTA_NO_ERROR;
+					}
+				} else if (scsiq->d3.host_stat ==
+					   QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
+					AscStopChip(iop_base);
+					AscSetChipControl(iop_base,
+							  (uchar)(CC_SCSI_RESET
+								  | CC_HALT));
+					udelay(60);
+					AscSetChipControl(iop_base, CC_HALT);
+					AscSetChipStatus(iop_base,
+							 CIW_CLR_SCSI_RESET_INT);
+					AscSetChipStatus(iop_base, 0);
+					AscSetChipControl(iop_base, 0);
+				}
+			}
+			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
+				asc_isr_callback(asc_dvc, scsiq);
+			} else {
+				if ((AscReadLramByte(iop_base,
+						     (ushort)(q_addr + (ushort)
+							      ASC_SCSIQ_CDB_BEG))
+				     == START_STOP)) {
+					asc_dvc->unit_not_ready &= ~target_id;
+					if (scsiq->d3.done_stat != QD_NO_ERROR) {
+						asc_dvc->start_motor &=
+						    ~target_id;
+					}
+				}
+			}
+			return (1);
+		} else {
+			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);
+ FATAL_ERR_QDONE:
+			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
+				asc_isr_callback(asc_dvc, scsiq);
+			}
+			return (0x80);
+		}
+	}
+	return (0);
+}
 
-static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __devinitdata = {
-	0,			/* 00 cfg_lsw */
-	0,			/* 01 cfg_msw */
-	0,			/* 02 disc_enable */
-	0,			/* 03 wdtr_able */
-	0,			/* 04 sdtr_speed1 */
-	0,			/* 05 start_motor */
-	0,			/* 06 tagqng_able */
-	0,			/* 07 bios_scan */
-	0,			/* 08 scam_tolerant */
-	1,			/* 09 adapter_scsi_id */
-	1,			/*    bios_boot_delay */
-	1,			/* 10 scsi_reset_delay */
-	1,			/*    bios_id_lun */
-	1,			/* 11 termination_se */
-	1,			/*    termination_lvd */
-	0,			/* 12 bios_ctrl */
-	0,			/* 13 sdtr_speed2 */
-	0,			/* 14 sdtr_speed3 */
-	1,			/* 15 max_host_qng */
-	1,			/*    max_dvc_qng */
-	0,			/* 16 dvc_cntl */
-	0,			/* 17 sdtr_speed4 */
-	0,			/* 18 serial_number_word1 */
-	0,			/* 19 serial_number_word2 */
-	0,			/* 20 serial_number_word3 */
-	0,			/* 21 check_sum */
-	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
-	,			/* 22-29 oem_name[16] */
-	0,			/* 30 dvc_err_code */
-	0,			/* 31 adv_err_code */
-	0,			/* 32 adv_err_addr */
-	0,			/* 33 saved_dvc_err_code */
-	0,			/* 34 saved_adv_err_code */
-	0,			/* 35 saved_adv_err_addr */
-	0,			/* 36 reserved */
-	0,			/* 37 reserved */
-	0,			/* 38 reserved */
-	0,			/* 39 reserved */
-	0,			/* 40 reserved */
-	0,			/* 41 reserved */
-	0,			/* 42 reserved */
-	0,			/* 43 reserved */
-	0,			/* 44 reserved */
-	0,			/* 45 reserved */
-	0,			/* 46 reserved */
-	0,			/* 47 reserved */
-	0,			/* 48 reserved */
-	0,			/* 49 reserved */
-	0,			/* 50 reserved */
-	0,			/* 51 reserved */
-	0,			/* 52 reserved */
-	0,			/* 53 reserved */
-	0,			/* 54 reserved */
-	0,			/* 55 reserved */
-	0,			/* 56 cisptr_lsw */
-	0,			/* 57 cisprt_msw */
-	0,			/* 58 subsysvid */
-	0,			/* 59 subsysid */
-	0,			/* 60 reserved */
-	0,			/* 61 reserved */
-	0,			/* 62 reserved */
-	0			/* 63 reserved */
-};
+static int AscISR(ASC_DVC_VAR *asc_dvc)
+{
+	ASC_CS_TYPE chipstat;
+	PortAddr iop_base;
+	ushort saved_ram_addr;
+	uchar ctrl_reg;
+	uchar saved_ctrl_reg;
+	int int_pending;
+	int status;
+	uchar host_flag;
 
-static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __devinitdata = {
-	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
-	0x0000,			/* 01 cfg_msw */
-	0xFFFF,			/* 02 disc_enable */
-	0xFFFF,			/* 03 wdtr_able */
-	0x5555,			/* 04 sdtr_speed1 */
-	0xFFFF,			/* 05 start_motor */
-	0xFFFF,			/* 06 tagqng_able */
-	0xFFFF,			/* 07 bios_scan */
-	0,			/* 08 scam_tolerant */
-	7,			/* 09 adapter_scsi_id */
-	0,			/*    bios_boot_delay */
-	3,			/* 10 scsi_reset_delay */
-	0,			/*    bios_id_lun */
-	0,			/* 11 termination_se */
-	0,			/*    termination_lvd */
-	0xFFE7,			/* 12 bios_ctrl */
-	0x5555,			/* 13 sdtr_speed2 */
-	0x5555,			/* 14 sdtr_speed3 */
-	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
-	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
-	0,			/* 16 dvc_cntl */
-	0x5555,			/* 17 sdtr_speed4 */
-	0,			/* 18 serial_number_word1 */
-	0,			/* 19 serial_number_word2 */
-	0,			/* 20 serial_number_word3 */
-	0,			/* 21 check_sum */
-	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-	,			/* 22-29 oem_name[16] */
-	0,			/* 30 dvc_err_code */
-	0,			/* 31 adv_err_code */
-	0,			/* 32 adv_err_addr */
-	0,			/* 33 saved_dvc_err_code */
-	0,			/* 34 saved_adv_err_code */
-	0,			/* 35 saved_adv_err_addr */
-	0,			/* 36 reserved */
-	0,			/* 37 reserved */
-	0,			/* 38 reserved */
-	0,			/* 39 reserved */
-	0,			/* 40 reserved */
-	0,			/* 41 reserved */
-	0,			/* 42 reserved */
-	0,			/* 43 reserved */
-	0,			/* 44 reserved */
-	0,			/* 45 reserved */
-	0,			/* 46 reserved */
-	0,			/* 47 reserved */
-	0,			/* 48 reserved */
-	0,			/* 49 reserved */
-	0,			/* 50 reserved */
-	0,			/* 51 reserved */
-	0,			/* 52 reserved */
-	0,			/* 53 reserved */
-	0,			/* 54 reserved */
-	0,			/* 55 reserved */
-	0,			/* 56 cisptr_lsw */
-	0,			/* 57 cisprt_msw */
-	PCI_VENDOR_ID_ASP,	/* 58 subsysvid */
-	PCI_DEVICE_ID_38C1600_REV1,	/* 59 subsysid */
-	0,			/* 60 reserved */
-	0,			/* 61 reserved */
-	0,			/* 62 reserved */
-	0			/* 63 reserved */
-};
+	iop_base = asc_dvc->iop_base;
+	int_pending = FALSE;
 
-static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata = {
-	0,			/* 00 cfg_lsw */
-	0,			/* 01 cfg_msw */
-	0,			/* 02 disc_enable */
-	0,			/* 03 wdtr_able */
-	0,			/* 04 sdtr_speed1 */
-	0,			/* 05 start_motor */
-	0,			/* 06 tagqng_able */
-	0,			/* 07 bios_scan */
-	0,			/* 08 scam_tolerant */
-	1,			/* 09 adapter_scsi_id */
-	1,			/*    bios_boot_delay */
-	1,			/* 10 scsi_reset_delay */
-	1,			/*    bios_id_lun */
-	1,			/* 11 termination_se */
-	1,			/*    termination_lvd */
-	0,			/* 12 bios_ctrl */
-	0,			/* 13 sdtr_speed2 */
-	0,			/* 14 sdtr_speed3 */
-	1,			/* 15 max_host_qng */
-	1,			/*    max_dvc_qng */
-	0,			/* 16 dvc_cntl */
-	0,			/* 17 sdtr_speed4 */
-	0,			/* 18 serial_number_word1 */
-	0,			/* 19 serial_number_word2 */
-	0,			/* 20 serial_number_word3 */
-	0,			/* 21 check_sum */
-	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
-	,			/* 22-29 oem_name[16] */
-	0,			/* 30 dvc_err_code */
-	0,			/* 31 adv_err_code */
-	0,			/* 32 adv_err_addr */
-	0,			/* 33 saved_dvc_err_code */
-	0,			/* 34 saved_adv_err_code */
-	0,			/* 35 saved_adv_err_addr */
-	0,			/* 36 reserved */
-	0,			/* 37 reserved */
-	0,			/* 38 reserved */
-	0,			/* 39 reserved */
-	0,			/* 40 reserved */
-	0,			/* 41 reserved */
-	0,			/* 42 reserved */
-	0,			/* 43 reserved */
-	0,			/* 44 reserved */
-	0,			/* 45 reserved */
-	0,			/* 46 reserved */
-	0,			/* 47 reserved */
-	0,			/* 48 reserved */
-	0,			/* 49 reserved */
-	0,			/* 50 reserved */
-	0,			/* 51 reserved */
-	0,			/* 52 reserved */
-	0,			/* 53 reserved */
-	0,			/* 54 reserved */
-	0,			/* 55 reserved */
-	0,			/* 56 cisptr_lsw */
-	0,			/* 57 cisprt_msw */
-	0,			/* 58 subsysvid */
-	0,			/* 59 subsysid */
-	0,			/* 60 reserved */
-	0,			/* 61 reserved */
-	0,			/* 62 reserved */
-	0			/* 63 reserved */
-};
+	if (AscIsIntPending(iop_base) == 0)
+		return int_pending;
+
+	if ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {
+		return ERR;
+	}
+	if (asc_dvc->in_critical_cnt != 0) {
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);
+		return ERR;
+	}
+	if (asc_dvc->is_in_int) {
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);
+		return ERR;
+	}
+	asc_dvc->is_in_int = TRUE;
+	ctrl_reg = AscGetChipControl(iop_base);
+	saved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |
+				       CC_SINGLE_STEP | CC_DIAG | CC_TEST));
+	chipstat = AscGetChipStatus(iop_base);
+	if (chipstat & CSW_SCSI_RESET_LATCH) {
+		if (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {
+			int i = 10;
+			int_pending = TRUE;
+			asc_dvc->sdtr_done = 0;
+			saved_ctrl_reg &= (uchar)(~CC_HALT);
+			while ((AscGetChipStatus(iop_base) &
+				CSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {
+				mdelay(100);
+			}
+			AscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));
+			AscSetChipControl(iop_base, CC_HALT);
+			AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+			AscSetChipStatus(iop_base, 0);
+			chipstat = AscGetChipStatus(iop_base);
+		}
+	}
+	saved_ram_addr = AscGetChipLramAddr(iop_base);
+	host_flag = AscReadLramByte(iop_base,
+				    ASCV_HOST_FLAG_B) &
+	    (uchar)(~ASC_HOST_FLAG_IN_ISR);
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
+			 (uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));
+	if ((chipstat & CSW_INT_PENDING) || (int_pending)) {
+		AscAckInterrupt(iop_base);
+		int_pending = TRUE;
+		if ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {
+			if (AscIsrChipHalted(asc_dvc) == ERR) {
+				goto ISR_REPORT_QDONE_FATAL_ERROR;
+			} else {
+				saved_ctrl_reg &= (uchar)(~CC_HALT);
+			}
+		} else {
+ ISR_REPORT_QDONE_FATAL_ERROR:
+			if ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {
+				while (((status =
+					 AscIsrQDone(asc_dvc)) & 0x01) != 0) {
+				}
+			} else {
+				do {
+					if ((status =
+					     AscIsrQDone(asc_dvc)) == 1) {
+						break;
+					}
+				} while (status == 0x11);
+			}
+			if ((status & 0x80) != 0)
+				int_pending = ERR;
+		}
+	}
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
+	AscSetChipLramAddr(iop_base, saved_ram_addr);
+	AscSetChipControl(iop_base, saved_ctrl_reg);
+	asc_dvc->is_in_int = FALSE;
+	return int_pending;
+}
 
-#ifdef CONFIG_PCI
 /*
- * Initialize the ADV_DVC_VAR structure.
+ * advansys_reset()
  *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ * Reset the bus associated with the command 'scp'.
  *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
+ * This function runs its own thread. Interrupts must be blocked but
+ * sleeping is allowed and no locking other than for host structures is
+ * required. Returns SUCCESS or FAILED.
  */
-static int __devinit
-AdvInitGetConfig(struct pci_dev *pdev, asc_board_t *boardp)
+static int advansys_reset(struct scsi_cmnd *scp)
 {
-	ADV_DVC_VAR *asc_dvc = &boardp->dvc_var.adv_dvc_var;
-	unsigned short warn_code = 0;
-	AdvPortAddr iop_base = asc_dvc->iop_base;
-	u16 cmd;
+	struct Scsi_Host *shost;
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	ulong flags;
 	int status;
+	int ret = SUCCESS;
 
-	asc_dvc->err_code = 0;
-
-	/*
-	 * Save the state of the PCI Configuration Command Register
-	 * "Parity Error Response Control" Bit. If the bit is clear (0),
-	 * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore
-	 * DMA parity errors.
-	 */
-	asc_dvc->cfg->control_flag = 0;
-	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
-	if ((cmd & PCI_COMMAND_PARITY) == 0)
-		asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
+	ASC_DBG1(1, "advansys_reset: 0x%lx\n", (ulong)scp);
 
-	asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
-	    ADV_LIB_VERSION_MINOR;
-	asc_dvc->cfg->chip_version =
-	    AdvGetChipVersion(iop_base, asc_dvc->bus_type);
+#ifdef ADVANSYS_STATS
+	if (scp->device->host != NULL) {
+		ASC_STATS(scp->device->host, reset);
+	}
+#endif /* ADVANSYS_STATS */
 
-	ASC_DBG2(1, "AdvInitGetConfig: iopb_chip_id_1: 0x%x 0x%x\n",
-		 (ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),
-		 (ushort)ADV_CHIP_ID_BYTE);
+	if ((shost = scp->device->host) == NULL) {
+		scp->result = HOST_BYTE(DID_ERROR);
+		return FAILED;
+	}
 
-	ASC_DBG2(1, "AdvInitGetConfig: iopw_chip_id_0: 0x%x 0x%x\n",
-		 (ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),
-		 (ushort)ADV_CHIP_ID_WORD);
+	boardp = ASC_BOARDP(shost);
 
+	ASC_PRINT1("advansys_reset: board %d: SCSI bus reset started...\n",
+		   boardp->id);
 	/*
-	 * Reset the chip to start and allow register writes.
+	 * Check for re-entrancy.
 	 */
-	if (AdvFindSignature(iop_base) == 0) {
-		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-		return ADV_ERROR;
-	} else {
+	spin_lock_irqsave(&boardp->lock, flags);
+	if (boardp->flags & ASC_HOST_IN_RESET) {
+		spin_unlock_irqrestore(&boardp->lock, flags);
+		return FAILED;
+	}
+	boardp->flags |= ASC_HOST_IN_RESET;
+	spin_unlock_irqrestore(&boardp->lock, flags);
+
+	if (ASC_NARROW_BOARD(boardp)) {
 		/*
-		 * The caller must set 'chip_type' to a valid setting.
+		 * Narrow Board
 		 */
-		if (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&
-		    asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&
-		    asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {
-			asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
-			return ADV_ERROR;
-		}
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 
 		/*
-		 * Reset Chip.
+		 * Reset the chip and SCSI bus.
 		 */
-		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
-				     ADV_CTRL_REG_CMD_RESET);
-		mdelay(100);
-		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
-				     ADV_CTRL_REG_CMD_WR_IO_REG);
+		ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
+		status = AscInitAsc1000Driver(asc_dvc_varp);
 
-		if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
-			status = AdvInitFrom38C1600EEP(asc_dvc);
-		} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
-			status = AdvInitFrom38C0800EEP(asc_dvc);
+		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
+		if (asc_dvc_varp->err_code) {
+			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
+				   "error: 0x%x\n", boardp->id,
+				   asc_dvc_varp->err_code);
+			ret = FAILED;
+		} else if (status) {
+			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
+				   "warning: 0x%x\n", boardp->id, status);
 		} else {
-			status = AdvInitFrom3550EEP(asc_dvc);
+			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
+				   "successful.\n", boardp->id);
 		}
-		warn_code |= status;
-	}
-
-	if (warn_code != 0) {
-		ASC_PRINT2("AdvInitGetConfig: board %d: warning: 0x%x\n",
-			   boardp->id, warn_code);
-	}
-
-	if (asc_dvc->err_code) {
-		ASC_PRINT2("AdvInitGetConfig: board %d error: err_code 0x%x\n",
-		     boardp->id, asc_dvc->err_code);
-	}
-
-	return asc_dvc->err_code;
-}
-#endif
-
-static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
-{
-	ADV_CARR_T *carrp;
-	ADV_SDCNT buf_size;
-	ADV_PADDR carr_paddr;
 
-	BUG_ON(!asc_dvc->carrier_buf);
+		ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
+		spin_lock_irqsave(&boardp->lock, flags);
 
-	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-	asc_dvc->carr_freelist = NULL;
-	if (carrp == asc_dvc->carrier_buf) {
-		buf_size = ADV_CARRIER_BUFSIZE;
 	} else {
-		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-	}
-
-	do {
-		/* Get physical address of the carrier 'carrp'. */
-		ADV_DCNT contig_len = sizeof(ADV_CARR_T);
-		carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL,
-						       (uchar *)carrp,
-						       (ADV_SDCNT *)&contig_len,
-						       ADV_IS_CARRIER_FLAG));
-
-		buf_size -= sizeof(ADV_CARR_T);
-
 		/*
-		 * If the current carrier is not physically contiguous, then
-		 * maybe there was a page crossing. Try the next carrier
-		 * aligned start address.
+		 * Wide Board
+		 *
+		 * If the suggest reset bus flags are set, then reset the bus.
+		 * Otherwise only reset the device.
 		 */
-		if (contig_len < sizeof(ADV_CARR_T)) {
-			carrp++;
-			continue;
-		}
-
-		carrp->carr_pa = carr_paddr;
-		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 
 		/*
-		 * Insert the carrier at the beginning of the freelist.
+		 * Reset the target's SCSI bus.
 		 */
-		carrp->next_vpa =
-			cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-		asc_dvc->carr_freelist = carrp;
-
-		carrp++;
-	} while (buf_size > 0);
-}
-
-/*
- * Load the Microcode
- *
- * Write the microcode image to RISC memory starting at address 0.
- *
- * The microcode is stored compressed in the following format:
- *
- *  254 word (508 byte) table indexed by byte code followed
- *  by the following byte codes:
- *
- *    1-Byte Code:
- *      00: Emit word 0 in table.
- *      01: Emit word 1 in table.
- *      .
- *      FD: Emit word 253 in table.
- *
- *    Multi-Byte Code:
- *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
- *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
- *
- * Returns 0 or an error if the checksum doesn't match
- */
-static int AdvLoadMicrocode(AdvPortAddr iop_base, unsigned char *buf, int size,
-			    int memsize, int chksum)
-{
-	int i, j, end, len = 0;
-	ADV_DCNT sum;
-
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-	for (i = 253 * 2; i < size; i++) {
-		if (buf[i] == 0xff) {
-			unsigned short word = (buf[i + 3] << 8) | buf[i + 2];
-			for (j = 0; j < buf[i + 1]; j++) {
-				AdvWriteWordAutoIncLram(iop_base, word);
-				len += 2;
-			}
-			i += 3;
-		} else if (buf[i] == 0xfe) {
-			unsigned short word = (buf[i + 2] << 8) | buf[i + 1];
-			AdvWriteWordAutoIncLram(iop_base, word);
-			i += 2;
-			len += 2;
-		} else {
-			unsigned char off = buf[i] * 2;
-			unsigned short word = (buf[off + 1] << 8) | buf[off];
-			AdvWriteWordAutoIncLram(iop_base, word);
-			len += 2;
+		ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
+		switch (AdvResetChipAndSB(adv_dvc_varp)) {
+		case ASC_TRUE:
+			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
+				   "successful.\n", boardp->id);
+			break;
+		case ASC_FALSE:
+		default:
+			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
+				   "error.\n", boardp->id);
+			ret = FAILED;
+			break;
 		}
+		spin_lock_irqsave(&boardp->lock, flags);
+		AdvISR(adv_dvc_varp);
 	}
+	/* Board lock is held. */
 
-	end = len;
-
-	while (len < memsize) {
-		AdvWriteWordAutoIncLram(iop_base, 0);
-		len += 2;
-	}
-
-	/* Verify the microcode checksum. */
-	sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+	/* Save the time of the most recently completed reset. */
+	boardp->last_reset = jiffies;
 
-	for (len = 0; len < end; len += 2) {
-		sum += AdvReadWordAutoIncLram(iop_base);
-	}
+	/* Clear reset flag. */
+	boardp->flags &= ~ASC_HOST_IN_RESET;
+	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	if (sum != chksum)
-		return ASC_IERR_MCODE_CHKSUM;
+	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
 
-	return 0;
+	return ret;
 }
 
 /*
- * Initialize the ASC-3550.
- *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ * advansys_biosparam()
  *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
+ * Translate disk drive geometry if the "BIOS greater than 1 GB"
+ * support is enabled for a drive.
  *
- * Needed after initialization for error recovery.
+ * ip (information pointer) is an int array with the following definition:
+ * ip[0]: heads
+ * ip[1]: sectors
+ * ip[2]: cylinders
  */
-static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
+static int
+advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+		   sector_t capacity, int ip[])
 {
-	AdvPortAddr iop_base;
-	ushort warn_code;
-	int begin_addr;
-	int end_addr;
-	ushort code_sum;
-	int word;
-	int i;
-	ushort scsi_cfg1;
-	uchar tid;
-	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
-	ushort wdtr_able = 0, sdtr_able, tagqng_able;
-	uchar max_cmd[ADV_MAX_TID + 1];
-
-	/* If there is already an error, don't continue. */
-	if (asc_dvc->err_code != 0)
-		return ADV_ERROR;
+	asc_board_t *boardp;
 
-	/*
-	 * The caller must set 'chip_type' to ADV_CHIP_ASC3550.
-	 */
-	if (asc_dvc->chip_type != ADV_CHIP_ASC3550) {
-		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
-		return ADV_ERROR;
+	ASC_DBG(1, "advansys_biosparam: begin\n");
+	ASC_STATS(sdev->host, biosparam);
+	boardp = ASC_BOARDP(sdev->host);
+	if (ASC_NARROW_BOARD(boardp)) {
+		if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
+		     ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {
+			ip[0] = 255;
+			ip[1] = 63;
+		} else {
+			ip[0] = 64;
+			ip[1] = 32;
+		}
+	} else {
+		if ((boardp->dvc_var.adv_dvc_var.bios_ctrl &
+		     BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {
+			ip[0] = 255;
+			ip[1] = 63;
+		} else {
+			ip[0] = 64;
+			ip[1] = 32;
+		}
 	}
+	ip[2] = (unsigned long)capacity / (ip[0] * ip[1]);
+	ASC_DBG(1, "advansys_biosparam: end\n");
+	return 0;
+}
 
-	warn_code = 0;
-	iop_base = asc_dvc->iop_base;
+/*
+ * First-level interrupt handler.
+ *
+ * 'dev_id' is a pointer to the interrupting adapter's Scsi_Host.
+ */
+static irqreturn_t advansys_interrupt(int irq, void *dev_id)
+{
+	unsigned long flags;
+	struct Scsi_Host *shost = dev_id;
+	asc_board_t *boardp = ASC_BOARDP(shost);
+	irqreturn_t result = IRQ_NONE;
 
-	/*
-	 * Save the RISC memory BIOS region before writing the microcode.
-	 * The BIOS may already be loaded and using its RISC LRAM region
-	 * so its region must be saved and restored.
-	 *
-	 * Note: This code makes the assumption, which is currently true,
-	 * that a chip reset does not clear RISC LRAM.
-	 */
-	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
-		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
-				bios_mem[i]);
+	ASC_DBG1(2, "advansys_interrupt: boardp 0x%p\n", boardp);
+	spin_lock_irqsave(&boardp->lock, flags);
+	if (ASC_NARROW_BOARD(boardp)) {
+		if (AscIsIntPending(shost->io_port)) {
+			result = IRQ_HANDLED;
+			ASC_STATS(shost, interrupt);
+			ASC_DBG(1, "advansys_interrupt: before AscISR()\n");
+			AscISR(&boardp->dvc_var.asc_dvc_var);
+		}
+	} else {
+		ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
+		if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
+			result = IRQ_HANDLED;
+			ASC_STATS(shost, interrupt);
+		}
 	}
+	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	/*
-	 * Save current per TID negotiated values.
-	 */
-	if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] == 0x55AA) {
-		ushort bios_version, major, minor;
+	ASC_DBG(1, "advansys_interrupt: end\n");
+	return result;
+}
 
-		bios_version =
-		    bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM) / 2];
-		major = (bios_version >> 12) & 0xF;
-		minor = (bios_version >> 8) & 0xF;
-		if (major < 3 || (major == 3 && minor == 1)) {
-			/* BIOS 3.1 and earlier location of 'wdtr_able' variable. */
-			AdvReadWordLram(iop_base, 0x120, wdtr_able);
-		} else {
-			AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+static int AscHostReqRiscHalt(PortAddr iop_base)
+{
+	int count = 0;
+	int sta = 0;
+	uchar saved_stop_code;
+
+	if (AscIsChipHalted(iop_base))
+		return (1);
+	saved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);
+	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
+			 ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);
+	do {
+		if (AscIsChipHalted(iop_base)) {
+			sta = 1;
+			break;
 		}
-	}
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-				max_cmd[tid]);
-	}
+		mdelay(100);
+	} while (count++ < 20);
+	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
+	return (sta);
+}
 
-	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc3550_buf,
-					_adv_asc3550_size, ADV_3550_MEMSIZE,
-					_adv_asc3550_chksum);
-	if (asc_dvc->err_code)
-		return ADV_ERROR;
+static int
+AscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)
+{
+	int sta = FALSE;
 
-	/*
-	 * Restore the RISC memory BIOS region.
-	 */
-	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
-		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
-				 bios_mem[i]);
+	if (AscHostReqRiscHalt(iop_base)) {
+		sta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
+		AscStartChip(iop_base);
 	}
+	return sta;
+}
 
-	/*
-	 * Calculate and write the microcode code checksum to the microcode
-	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
-	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
-	code_sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
-	for (word = begin_addr; word < end_addr; word += 2) {
-		code_sum += AdvReadWordAutoIncLram(iop_base);
-	}
-	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+static void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)
+{
+	char type = sdev->type;
+	ASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;
 
-	/*
-	 * Read and save microcode version and date.
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
-			asc_dvc->cfg->mcode_date);
-	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
-			asc_dvc->cfg->mcode_version);
+	if (!(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN))
+		return;
+	if (asc_dvc->init_sdtr & tid_bits)
+		return;
 
-	/*
-	 * Set the chip type to indicate the ASC3550.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);
+	if ((type == TYPE_ROM) && (strncmp(sdev->vendor, "HP ", 3) == 0))
+		asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
 
-	/*
-	 * If the PCI Configuration Command Register "Parity Error Response
-	 * Control" Bit was clear (0), then set the microcode variable
-	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
-	 * to ignore DMA parity errors.
-	 */
-	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
-		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-		word |= CONTROL_FLAG_IGNORE_PERR;
-		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-	}
+	asc_dvc->pci_fix_asyn_xfer |= tid_bits;
+	if ((type == TYPE_PROCESSOR) || (type == TYPE_SCANNER) ||
+	    (type == TYPE_ROM) || (type == TYPE_TAPE))
+		asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
+
+	if (asc_dvc->pci_fix_asyn_xfer & tid_bits)
+		AscSetRunChipSynRegAtID(asc_dvc->iop_base, sdev->id,
+					ASYN_SDTR_DATA_FIX_PCI_REV_AB);
+}
 
-	/*
-	 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO
-	 * threshold of 128 bytes. This register is only accessible to the host.
-	 */
-	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
-			     START_CTL_EMFU | READ_CMD_MRM);
+static void
+advansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)
+{
+	ASC_SCSI_BIT_ID_TYPE tid_bit = 1 << sdev->id;
+	ASC_SCSI_BIT_ID_TYPE orig_use_tagged_qng = asc_dvc->use_tagged_qng;
 
-	/*
-	 * Microcode operating variables for WDTR, SDTR, and command tag
-	 * queuing will be set in slave_configure() based on what a
-	 * device reports it is capable of in Inquiry byte 7.
-	 *
-	 * If SCSI Bus Resets have been disabled, then directly set
-	 * SDTR and WDTR from the EEPROM configuration. This will allow
-	 * the BIOS and warm boot to work without a SCSI bus hang on
-	 * the Inquiry caused by host and target mismatched DTR values.
-	 * Without the SCSI Bus Reset, before an Inquiry a device can't
-	 * be assumed to be in Asynchronous, Narrow mode.
-	 */
-	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
-		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
-				 asc_dvc->wdtr_able);
-		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
-				 asc_dvc->sdtr_able);
+	if (sdev->lun == 0) {
+		ASC_SCSI_BIT_ID_TYPE orig_init_sdtr = asc_dvc->init_sdtr;
+		if ((asc_dvc->cfg->sdtr_enable & tid_bit) && sdev->sdtr) {
+			asc_dvc->init_sdtr |= tid_bit;
+		} else {
+			asc_dvc->init_sdtr &= ~tid_bit;
+		}
+
+		if (orig_init_sdtr != asc_dvc->init_sdtr)
+			AscAsyncFix(asc_dvc, sdev);
 	}
 
-	/*
-	 * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,
-	 * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID
-	 * bitmask. These values determine the maximum SDTR speed negotiated
-	 * with a device.
-	 *
-	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
-	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
-	 * without determining here whether the device supports SDTR.
-	 *
-	 * 4-bit speed  SDTR speed name
-	 * ===========  ===============
-	 * 0000b (0x0)  SDTR disabled
-	 * 0001b (0x1)  5 Mhz
-	 * 0010b (0x2)  10 Mhz
-	 * 0011b (0x3)  20 Mhz (Ultra)
-	 * 0100b (0x4)  40 Mhz (LVD/Ultra2)
-	 * 0101b (0x5)  80 Mhz (LVD2/Ultra3)
-	 * 0110b (0x6)  Undefined
-	 * .
-	 * 1111b (0xF)  Undefined
-	 */
-	word = 0;
-	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-		if (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able) {
-			/* Set Ultra speed for TID 'tid'. */
-			word |= (0x3 << (4 * (tid % 4)));
-		} else {
-			/* Set Fast speed for TID 'tid'. */
-			word |= (0x2 << (4 * (tid % 4)));
+	if (sdev->tagged_supported) {
+		if (asc_dvc->cfg->cmd_qng_enabled & tid_bit) {
+			if (sdev->lun == 0) {
+				asc_dvc->cfg->can_tagged_qng |= tid_bit;
+				asc_dvc->use_tagged_qng |= tid_bit;
+			}
+			scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
+						asc_dvc->max_dvc_qng[sdev->id]);
 		}
-		if (tid == 3) {	/* Check if done with sdtr_speed1. */
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);
-			word = 0;
-		} else if (tid == 7) {	/* Check if done with sdtr_speed2. */
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);
-			word = 0;
-		} else if (tid == 11) {	/* Check if done with sdtr_speed3. */
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);
-			word = 0;
-		} else if (tid == 15) {	/* Check if done with sdtr_speed4. */
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);
-			/* End of loop. */
+	} else {
+		if (sdev->lun == 0) {
+			asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
+			asc_dvc->use_tagged_qng &= ~tid_bit;
 		}
+		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
 	}
 
-	/*
-	 * Set microcode operating variable for the disconnect per TID bitmask.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
-			 asc_dvc->cfg->disc_enable);
+	if ((sdev->lun == 0) &&
+	    (orig_use_tagged_qng != asc_dvc->use_tagged_qng)) {
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
+				 asc_dvc->cfg->disc_enable);
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
+				 asc_dvc->use_tagged_qng);
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
+				 asc_dvc->cfg->can_tagged_qng);
 
-	/*
-	 * Set SCSI_CFG0 Microcode Default Value.
-	 *
-	 * The microcode will set the SCSI_CFG0 register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
-			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
-			 asc_dvc->chip_scsi_id);
+		asc_dvc->max_dvc_qng[sdev->id] =
+					asc_dvc->cfg->max_tag_qng[sdev->id];
+		AscWriteLramByte(asc_dvc->iop_base,
+				 (ushort)(ASCV_MAX_DVC_QNG_BEG + sdev->id),
+				 asc_dvc->max_dvc_qng[sdev->id]);
+	}
+}
 
-	/*
-	 * Determine SCSI_CFG1 Microcode Default Value.
-	 *
-	 * The microcode will set the SCSI_CFG1 register using this value
-	 * after it is started below.
-	 */
+/*
+ * Wide Transfers
+ *
+ * If the EEPROM enabled WDTR for the device and the device supports wide
+ * bus (16 bit) transfers, then turn on the device's 'wdtr_able' bit and
+ * write the new value to the microcode.
+ */
+static void
+advansys_wide_enable_wdtr(AdvPortAddr iop_base, unsigned short tidmask)
+{
+	unsigned short cfg_word;
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
+	if ((cfg_word & tidmask) != 0)
+		return;
 
-	/* Read current SCSI_CFG1 Register value. */
-	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	cfg_word |= tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
 
 	/*
-	 * If all three connectors are in use, return an error.
+	 * Clear the microcode SDTR and WDTR negotiation done indicators for
+	 * the target to cause it to negotiate with the new setting set above.
+	 * WDTR when accepted causes the target to enter asynchronous mode, so
+	 * SDTR must be negotiated.
 	 */
-	if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
-	    (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
-		asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
-		return ADV_ERROR;
-	}
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	cfg_word &= ~tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+	cfg_word &= ~tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+}
 
-	/*
-	 * If the internal narrow cable is reversed all of the SCSI_CTRL
-	 * register signals will be set. Check for and return an error if
-	 * this condition is found.
-	 */
-	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
-		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
-		return ADV_ERROR;
-	}
+/*
+ * Synchronous Transfers
+ *
+ * If the EEPROM enabled SDTR for the device and the device
+ * supports synchronous transfers, then turn on the device's
+ * 'sdtr_able' bit. Write the new value to the microcode.
+ */
+static void
+advansys_wide_enable_sdtr(AdvPortAddr iop_base, unsigned short tidmask)
+{
+	unsigned short cfg_word;
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+	if ((cfg_word & tidmask) != 0)
+		return;
 
-	/*
-	 * If this is a differential board and a single-ended device
-	 * is attached to one of the connectors, return an error.
-	 */
-	if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0) {
-		asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
-		return ADV_ERROR;
-	}
+	cfg_word |= tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
 
 	/*
-	 * If automatic termination control is enabled, then set the
-	 * termination value based on a table listed in a_condor.h.
-	 *
-	 * If manual termination was specified with an EEPROM setting
-	 * then 'termination' was set-up in AdvInitFrom3550EEPROM() and
-	 * is ready to be 'ored' into SCSI_CFG1.
+	 * Clear the microcode "SDTR negotiation" done indicator for the
+	 * target to cause it to negotiate with the new setting set above.
 	 */
-	if (asc_dvc->cfg->termination == 0) {
-		/*
-		 * The software always controls termination by setting TERM_CTL_SEL.
-		 * If TERM_CTL_SEL were set to 0, the hardware would set termination.
-		 */
-		asc_dvc->cfg->termination |= TERM_CTL_SEL;
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	cfg_word &= ~tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+}
 
-		switch (scsi_cfg1 & CABLE_DETECT) {
-			/* TERM_CTL_H: on, TERM_CTL_L: on */
-		case 0x3:
-		case 0x7:
-		case 0xB:
-		case 0xD:
-		case 0xE:
-		case 0xF:
-			asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
-			break;
+/*
+ * PPR (Parallel Protocol Request) Capable
+ *
+ * If the device supports DT mode, then it must be PPR capable.
+ * The PPR message will be used in place of the SDTR and WDTR
+ * messages to negotiate synchronous speed and offset, transfer
+ * width, and protocol options.
+ */
+static void advansys_wide_enable_ppr(ADV_DVC_VAR *adv_dvc,
+				AdvPortAddr iop_base, unsigned short tidmask)
+{
+	AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);
+	adv_dvc->ppr_able |= tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);
+}
 
-			/* TERM_CTL_H: on, TERM_CTL_L: off */
-		case 0x1:
-		case 0x5:
-		case 0x9:
-		case 0xA:
-		case 0xC:
-			asc_dvc->cfg->termination |= TERM_CTL_H;
-			break;
+static void
+advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
+{
+	AdvPortAddr iop_base = adv_dvc->iop_base;
+	unsigned short tidmask = 1 << sdev->id;
+
+	if (sdev->lun == 0) {
+		/*
+		 * Handle WDTR, SDTR, and Tag Queuing. If the feature
+		 * is enabled in the EEPROM and the device supports the
+		 * feature, then enable it in the microcode.
+		 */
 
-			/* TERM_CTL_H: off, TERM_CTL_L: off */
-		case 0x2:
-		case 0x6:
-			break;
+		if ((adv_dvc->wdtr_able & tidmask) && sdev->wdtr)
+			advansys_wide_enable_wdtr(iop_base, tidmask);
+		if ((adv_dvc->sdtr_able & tidmask) && sdev->sdtr)
+			advansys_wide_enable_sdtr(iop_base, tidmask);
+		if (adv_dvc->chip_type == ADV_CHIP_ASC38C1600 && sdev->ppr)
+			advansys_wide_enable_ppr(adv_dvc, iop_base, tidmask);
+
+		/*
+		 * Tag Queuing is disabled for the BIOS which runs in polled
+		 * mode and would see no benefit from Tag Queuing. Also by
+		 * disabling Tag Queuing in the BIOS devices with Tag Queuing
+		 * bugs will at least work with the BIOS.
+		 */
+		if ((adv_dvc->tagqng_able & tidmask) &&
+		    sdev->tagged_supported) {
+			unsigned short cfg_word;
+			AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
+			cfg_word |= tidmask;
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 cfg_word);
+			AdvWriteByteLram(iop_base,
+					 ASC_MC_NUMBER_OF_MAX_CMD + sdev->id,
+					 adv_dvc->max_dvc_qng);
 		}
 	}
 
-	/*
-	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.
-	 */
-	scsi_cfg1 &= ~TERM_CTL;
-
-	/*
-	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then
-	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be
-	 * referenced, because the hardware internally inverts
-	 * the Termination High and Low bits if TERM_POL is set.
-	 */
-	scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));
-
-	/*
-	 * Set SCSI_CFG1 Microcode Default Value
-	 *
-	 * Set filter value and possibly modified termination control
-	 * bits in the Microcode SCSI_CFG1 Register Value.
-	 *
-	 * The microcode will set the SCSI_CFG1 register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
-			 FLTR_DISABLE | scsi_cfg1);
+	if ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported) {
+		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
+					adv_dvc->max_dvc_qng);
+	} else {
+		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
+	}
+}
 
-	/*
-	 * Set MEM_CFG Microcode Default Value
-	 *
-	 * The microcode will set the MEM_CFG register using this value
-	 * after it is started below.
-	 *
-	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
-	 * are defined.
-	 *
-	 * ASC-3550 has 8KB internal memory.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-			 BIOS_EN | RAM_SZ_8KB);
+/*
+ * Set the number of commands to queue per device for the
+ * specified host adapter.
+ */
+static int advansys_slave_configure(struct scsi_device *sdev)
+{
+	asc_board_t *boardp = ASC_BOARDP(sdev->host);
+	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
 
 	/*
-	 * Set SEL_MASK Microcode Default Value
-	 *
-	 * The microcode will set the SEL_MASK register using this value
-	 * after it is started below.
+	 * Save a pointer to the sdev and set its initial/maximum
+	 * queue depth.  Only save the pointer for a lun0 dev though.
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
-			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
-
-	AdvBuildCarrierFreelist(asc_dvc);
+	if (sdev->lun == 0)
+		boardp->device[sdev->id] = sdev;
 
-	/*
-	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
-	 */
+	if (ASC_NARROW_BOARD(boardp))
+		advansys_narrow_slave_configure(sdev,
+						&boardp->dvc_var.asc_dvc_var);
+	else
+		advansys_wide_slave_configure(sdev,
+						&boardp->dvc_var.adv_dvc_var);
 
-	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
-		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-		return ADV_ERROR;
-	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+	return 0;
+}
 
+/*
+ * Build a request structure for the Asc Library (Narrow Board).
+ *
+ * The global structures 'asc_scsi_q' and 'asc_sg_head' are
+ * used to build the request.
+ *
+ * If an error occurs, then return ASC_ERROR.
+ */
+static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
+{
 	/*
-	 * The first command issued will be placed in the stopper carrier.
+	 * Mutually exclusive access is required to 'asc_scsi_q' and
+	 * 'asc_sg_head' until after the request is started.
 	 */
-	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	memset(&asc_scsi_q, 0, sizeof(ASC_SCSI_Q));
 
 	/*
-	 * Set RISC ICQ physical address start value.
+	 * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
 	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+	asc_scsi_q.q2.srb_ptr = ASC_VADDR_TO_U32(scp);
 
 	/*
-	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 * Build the ASC_SCSI_Q request.
 	 */
-	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
-		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-		return ADV_ERROR;
-	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+	asc_scsi_q.cdbptr = &scp->cmnd[0];
+	asc_scsi_q.q2.cdb_len = scp->cmd_len;
+	asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
+	asc_scsi_q.q1.target_lun = scp->device->lun;
+	asc_scsi_q.q2.target_ix =
+	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
+	asc_scsi_q.q1.sense_addr =
+	    cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+	asc_scsi_q.q1.sense_len = sizeof(scp->sense_buffer);
 
 	/*
-	 * The first command completed by the RISC will be placed in
-	 * the stopper.
+	 * If there are any outstanding requests for the current target,
+	 * then every 255th request send an ORDERED request. This heuristic
+	 * tries to retain the benefit of request sorting while preventing
+	 * request starvation. 255 is the max number of tags or pending commands
+	 * a device may have outstanding.
+	 *
+	 * The request count is incremented below for every successfully
+	 * started request.
 	 *
-	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-	 * completed the RISC will set the ASC_RQ_STOPPER bit.
 	 */
-	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
+	    (boardp->reqcnt[scp->device->id] % 255) == 0) {
+		asc_scsi_q.q2.tag_code = MSG_ORDERED_TAG;
+	} else {
+		asc_scsi_q.q2.tag_code = MSG_SIMPLE_TAG;
+	}
 
 	/*
-	 * Set RISC IRQ physical address start value.
+	 * Build ASC_SCSI_Q for a contiguous buffer or a scatter-gather
+	 * buffer command.
 	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
-	asc_dvc->carr_pending_cnt = 0;
+	if (scp->use_sg == 0) {
+		/*
+		 * CDB request of single contiguous buffer.
+		 */
+		ASC_STATS(scp->device->host, cont_cnt);
+		scp->SCp.dma_handle = scp->request_bufflen ?
+		    dma_map_single(boardp->dev, scp->request_buffer,
+				   scp->request_bufflen,
+				   scp->sc_data_direction) : 0;
+		asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
+		asc_scsi_q.q1.data_cnt = cpu_to_le32(scp->request_bufflen);
+		ASC_STATS_ADD(scp->device->host, cont_xfer,
+			      ASC_CEILING(scp->request_bufflen, 512));
+		asc_scsi_q.q1.sg_queue_cnt = 0;
+		asc_scsi_q.sg_head = NULL;
+	} else {
+		/*
+		 * CDB scatter-gather request list.
+		 */
+		int sgcnt;
+		int use_sg;
+		struct scatterlist *slp;
 
-	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
-			     (ADV_INTR_ENABLE_HOST_INTR |
-			      ADV_INTR_ENABLE_GLOBAL_INTR));
+		slp = (struct scatterlist *)scp->request_buffer;
+		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
+				    scp->sc_data_direction);
 
-	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
-	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+		if (use_sg > scp->device->host->sg_tablesize) {
+			ASC_PRINT3("asc_build_req: board %d: use_sg %d > "
+				   "sg_tablesize %d\n", boardp->id, use_sg,
+				   scp->device->host->sg_tablesize);
+			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
+				     scp->sc_data_direction);
+			scp->result = HOST_BYTE(DID_ERROR);
+			return ASC_ERROR;
+		}
 
-	/* finally, finally, gentlemen, start your engine */
-	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+		ASC_STATS(scp->device->host, sg_cnt);
 
-	/*
-	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
-	 * Resets should be performed. The RISC has to be running
-	 * to issue a SCSI Bus Reset.
-	 */
-	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
 		/*
-		 * If the BIOS Signature is present in memory, restore the
-		 * BIOS Handshake Configuration Table and do not perform
-		 * a SCSI Bus Reset.
+		 * Use global ASC_SG_HEAD structure and set the ASC_SCSI_Q
+		 * structure to point to it.
 		 */
-		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
-		    0x55AA) {
-			/*
-			 * Restore per TID negotiated values.
-			 */
-			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
-					 tagqng_able);
-			for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-				AdvWriteByteLram(iop_base,
-						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
-						 max_cmd[tid]);
-			}
-		} else {
-			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
-				warn_code = ASC_WARN_BUSRESET_ERROR;
-			}
+		memset(&asc_sg_head, 0, sizeof(ASC_SG_HEAD));
+
+		asc_scsi_q.q1.cntl |= QC_SG_HEAD;
+		asc_scsi_q.sg_head = &asc_sg_head;
+		asc_scsi_q.q1.data_cnt = 0;
+		asc_scsi_q.q1.data_addr = 0;
+		/* This is a byte value, otherwise it would need to be swapped. */
+		asc_sg_head.entry_cnt = asc_scsi_q.q1.sg_queue_cnt = use_sg;
+		ASC_STATS_ADD(scp->device->host, sg_elem,
+			      asc_sg_head.entry_cnt);
+
+		/*
+		 * Convert scatter-gather list into ASC_SG_HEAD list.
+		 */
+		for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
+			asc_sg_head.sg_list[sgcnt].addr =
+			    cpu_to_le32(sg_dma_address(slp));
+			asc_sg_head.sg_list[sgcnt].bytes =
+			    cpu_to_le32(sg_dma_len(slp));
+			ASC_STATS_ADD(scp->device->host, sg_xfer,
+				      ASC_CEILING(sg_dma_len(slp), 512));
 		}
 	}
 
-	return warn_code;
+	ASC_DBG_PRT_ASC_SCSI_Q(2, &asc_scsi_q);
+	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+
+	return ASC_NOERROR;
 }
 
 /*
- * Initialize the ASC-38C0800.
- *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ * Build scatter-gather list for Adv Library (Wide Board).
  *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
+ * Additional ADV_SG_BLOCK structures will need to be allocated
+ * if the total number of scatter-gather elements exceeds
+ * NO_OF_SG_PER_BLOCK (15). The ADV_SG_BLOCK structures are
+ * assumed to be physically contiguous.
  *
- * Needed after initialization for error recovery.
+ * Return:
+ *      ADV_SUCCESS(1) - SG List successfully created
+ *      ADV_ERROR(-1) - SG List creation failed
  */
-static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
+static int
+adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
+	       int use_sg)
 {
-	AdvPortAddr iop_base;
-	ushort warn_code;
-	int begin_addr;
-	int end_addr;
-	ushort code_sum;
-	int word;
+	adv_sgblk_t *sgblkp;
+	ADV_SCSI_REQ_Q *scsiqp;
+	struct scatterlist *slp;
+	int sg_elem_cnt;
+	ADV_SG_BLOCK *sg_block, *prev_sg_block;
+	ADV_PADDR sg_block_paddr;
 	int i;
-	ushort scsi_cfg1;
-	uchar byte;
-	uchar tid;
-	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
-	ushort wdtr_able, sdtr_able, tagqng_able;
-	uchar max_cmd[ADV_MAX_TID + 1];
 
-	/* If there is already an error, don't continue. */
-	if (asc_dvc->err_code != 0)
-		return ADV_ERROR;
+	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
+	slp = (struct scatterlist *)scp->request_buffer;
+	sg_elem_cnt = use_sg;
+	prev_sg_block = NULL;
+	reqp->sgblkp = NULL;
 
-	/*
-	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.
-	 */
-	if (asc_dvc->chip_type != ADV_CHIP_ASC38C0800) {
-		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
-		return ADV_ERROR;
-	}
+	for (;;) {
+		/*
+		 * Allocate a 'adv_sgblk_t' structure from the board free
+		 * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
+		 * (15) scatter-gather elements.
+		 */
+		if ((sgblkp = boardp->adv_sgblkp) == NULL) {
+			ASC_DBG(1, "adv_get_sglist: no free adv_sgblk_t\n");
+			ASC_STATS(scp->device->host, adv_build_nosg);
 
-	warn_code = 0;
-	iop_base = asc_dvc->iop_base;
+			/*
+			 * Allocation failed. Free 'adv_sgblk_t' structures
+			 * already allocated for the request.
+			 */
+			while ((sgblkp = reqp->sgblkp) != NULL) {
+				/* Remove 'sgblkp' from the request list. */
+				reqp->sgblkp = sgblkp->next_sgblkp;
 
-	/*
-	 * Save the RISC memory BIOS region before writing the microcode.
-	 * The BIOS may already be loaded and using its RISC LRAM region
-	 * so its region must be saved and restored.
-	 *
-	 * Note: This code makes the assumption, which is currently true,
-	 * that a chip reset does not clear RISC LRAM.
-	 */
-	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
-		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
-				bios_mem[i]);
-	}
+				/* Add 'sgblkp' to the board free list. */
+				sgblkp->next_sgblkp = boardp->adv_sgblkp;
+				boardp->adv_sgblkp = sgblkp;
+			}
+			return ASC_BUSY;
+		}
 
-	/*
-	 * Save current per TID negotiated values.
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-				max_cmd[tid]);
-	}
+		/* Complete 'adv_sgblk_t' board allocation. */
+		boardp->adv_sgblkp = sgblkp->next_sgblkp;
+		sgblkp->next_sgblkp = NULL;
 
-	/*
-	 * RAM BIST (RAM Built-In Self Test)
-	 *
-	 * Address : I/O base + offset 0x38h register (byte).
-	 * Function: Bit 7-6(RW) : RAM mode
-	 *                          Normal Mode   : 0x00
-	 *                          Pre-test Mode : 0x40
-	 *                          RAM Test Mode : 0x80
-	 *           Bit 5       : unused
-	 *           Bit 4(RO)   : Done bit
-	 *           Bit 3-0(RO) : Status
-	 *                          Host Error    : 0x08
-	 *                          Int_RAM Error : 0x04
-	 *                          RISC Error    : 0x02
-	 *                          SCSI Error    : 0x01
-	 *                          No Error      : 0x00
-	 *
-	 * Note: RAM BIST code should be put right here, before loading the
-	 * microcode and after saving the RISC memory BIOS region.
-	 */
+		/*
+		 * Get 8 byte aligned virtual and physical addresses
+		 * for the allocated ADV_SG_BLOCK structure.
+		 */
+		sg_block = (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);
+		sg_block_paddr = virt_to_bus(sg_block);
 
-	/*
-	 * LRAM Pre-test
-	 *
-	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
-	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
-	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
-	 * to NORMAL_MODE, return an error too.
-	 */
-	for (i = 0; i < 2; i++) {
-		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
-		mdelay(10);	/* Wait for 10ms before reading back. */
-		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-		if ((byte & RAM_TEST_DONE) == 0
-		    || (byte & 0x0F) != PRE_TEST_VALUE) {
-			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
-			return ADV_ERROR;
-		}
+		/*
+		 * Check if this is the first 'adv_sgblk_t' for the
+		 * request.
+		 */
+		if (reqp->sgblkp == NULL) {
+			/* Request's first scatter-gather block. */
+			reqp->sgblkp = sgblkp;
 
-		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-		mdelay(10);	/* Wait for 10ms before reading back. */
-		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
-		    != NORMAL_VALUE) {
-			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
-			return ADV_ERROR;
+			/*
+			 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
+			 * address pointers.
+			 */
+			scsiqp->sg_list_ptr = sg_block;
+			scsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);
+		} else {
+			/* Request's second or later scatter-gather block. */
+			sgblkp->next_sgblkp = reqp->sgblkp;
+			reqp->sgblkp = sgblkp;
+
+			/*
+			 * Point the previous ADV_SG_BLOCK structure to
+			 * the newly allocated ADV_SG_BLOCK structure.
+			 */
+			prev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);
 		}
-	}
 
-	/*
-	 * LRAM Test - It takes about 1.5 ms to run through the test.
-	 *
-	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
-	 * If Done bit not set or Status not 0, save register byte, set the
-	 * err_code, and return an error.
-	 */
-	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
-	mdelay(10);	/* Wait for 10ms before checking status. */
+		for (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {
+			sg_block->sg_list[i].sg_addr =
+					cpu_to_le32(sg_dma_address(slp));
+			sg_block->sg_list[i].sg_count =
+					cpu_to_le32(sg_dma_len(slp));
+			ASC_STATS_ADD(scp->device->host, sg_xfer,
+				      ASC_CEILING(sg_dma_len(slp), 512));
 
-	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
-		/* Get here if Done bit not set or Status not 0. */
-		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
-		asc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;
-		return ADV_ERROR;
+			if (--sg_elem_cnt == 0) {	/* Last ADV_SG_BLOCK and scatter-gather entry. */
+				sg_block->sg_cnt = i + 1;
+				sg_block->sg_ptr = 0L;	/* Last ADV_SG_BLOCK in list. */
+				return ADV_SUCCESS;
+			}
+			slp++;
+		}
+		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
+		prev_sg_block = sg_block;
 	}
+}
 
-	/* We need to reset back to normal mode after LRAM test passes. */
-	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-
-	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C0800_buf,
-				 _adv_asc38C0800_size, ADV_38C0800_MEMSIZE,
-				 _adv_asc38C0800_chksum);
-	if (asc_dvc->err_code)
-		return ADV_ERROR;
+/*
+ * Build a request structure for the Adv Library (Wide Board).
+ *
+ * If an adv_req_t can not be allocated to issue the request,
+ * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.
+ *
+ * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the
+ * microcode for DMA addresses or math operations are byte swapped
+ * to little-endian order.
+ */
+static int
+adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
+	      ADV_SCSI_REQ_Q **adv_scsiqpp)
+{
+	adv_req_t *reqp;
+	ADV_SCSI_REQ_Q *scsiqp;
+	int i;
+	int ret;
 
 	/*
-	 * Restore the RISC memory BIOS region.
+	 * Allocate an adv_req_t structure from the board to execute
+	 * the command.
 	 */
-	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
-		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
-				 bios_mem[i]);
+	if (boardp->adv_reqp == NULL) {
+		ASC_DBG(1, "adv_build_req: no free adv_req_t\n");
+		ASC_STATS(scp->device->host, adv_build_noreq);
+		return ASC_BUSY;
+	} else {
+		reqp = boardp->adv_reqp;
+		boardp->adv_reqp = reqp->next_reqp;
+		reqp->next_reqp = NULL;
 	}
 
 	/*
-	 * Calculate and write the microcode code checksum to the microcode
-	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.
 	 */
-	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
-	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
-	code_sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
-	for (word = begin_addr; word < end_addr; word += 2) {
-		code_sum += AdvReadWordAutoIncLram(iop_base);
-	}
-	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
 
 	/*
-	 * Read microcode version and date.
+	 * Initialize the structure.
 	 */
-	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
-			asc_dvc->cfg->mcode_date);
-	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
-			asc_dvc->cfg->mcode_version);
+	scsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;
 
 	/*
-	 * Set the chip type to indicate the ASC38C0800.
+	 * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);
+	scsiqp->srb_ptr = ASC_VADDR_TO_U32(reqp);
 
 	/*
-	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
-	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
-	 * cable detection and then we are able to read C_DET[3:0].
-	 *
-	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
-	 * Microcode Default Value' section below.
+	 * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
 	 */
-	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
-	AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,
-			     scsi_cfg1 | DIS_TERM_DRV);
+	reqp->cmndp = scp;
 
 	/*
-	 * If the PCI Configuration Command Register "Parity Error Response
-	 * Control" Bit was clear (0), then set the microcode variable
-	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
-	 * to ignore DMA parity errors.
+	 * Build the ADV_SCSI_REQ_Q request.
 	 */
-	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
-		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-		word |= CONTROL_FLAG_IGNORE_PERR;
-		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+
+	/* Set CDB length and copy it to the request structure.  */
+	scsiqp->cdb_len = scp->cmd_len;
+	/* Copy first 12 CDB bytes to cdb[]. */
+	for (i = 0; i < scp->cmd_len && i < 12; i++) {
+		scsiqp->cdb[i] = scp->cmnd[i];
+	}
+	/* Copy last 4 CDB bytes, if present, to cdb16[]. */
+	for (; i < scp->cmd_len; i++) {
+		scsiqp->cdb16[i - 12] = scp->cmnd[i];
 	}
 
-	/*
-	 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]
-	 * bits for the default FIFO threshold.
-	 *
-	 * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.
-	 *
-	 * For DMA Errata #4 set the BC_THRESH_ENB bit.
-	 */
-	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
-			     BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH |
-			     READ_CMD_MRM);
+	scsiqp->target_id = scp->device->id;
+	scsiqp->target_lun = scp->device->lun;
+
+	scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+	scsiqp->sense_len = sizeof(scp->sense_buffer);
 
 	/*
-	 * Microcode operating variables for WDTR, SDTR, and command tag
-	 * queuing will be set in slave_configure() based on what a
-	 * device reports it is capable of in Inquiry byte 7.
-	 *
-	 * If SCSI Bus Resets have been disabled, then directly set
-	 * SDTR and WDTR from the EEPROM configuration. This will allow
-	 * the BIOS and warm boot to work without a SCSI bus hang on
-	 * the Inquiry caused by host and target mismatched DTR values.
-	 * Without the SCSI Bus Reset, before an Inquiry a device can't
-	 * be assumed to be in Asynchronous, Narrow mode.
+	 * Build ADV_SCSI_REQ_Q for a contiguous buffer or a scatter-gather
+	 * buffer command.
 	 */
-	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
-		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
-				 asc_dvc->wdtr_able);
-		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
-				 asc_dvc->sdtr_able);
+
+	scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
+	scsiqp->vdata_addr = scp->request_buffer;
+	scsiqp->data_addr = cpu_to_le32(virt_to_bus(scp->request_buffer));
+
+	if (scp->use_sg == 0) {
+		/*
+		 * CDB request of single contiguous buffer.
+		 */
+		reqp->sgblkp = NULL;
+		scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
+		if (scp->request_bufflen) {
+			scsiqp->vdata_addr = scp->request_buffer;
+			scp->SCp.dma_handle =
+			    dma_map_single(boardp->dev, scp->request_buffer,
+					   scp->request_bufflen,
+					   scp->sc_data_direction);
+		} else {
+			scsiqp->vdata_addr = NULL;
+			scp->SCp.dma_handle = 0;
+		}
+		scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);
+		scsiqp->sg_list_ptr = NULL;
+		scsiqp->sg_real_addr = 0;
+		ASC_STATS(scp->device->host, cont_cnt);
+		ASC_STATS_ADD(scp->device->host, cont_xfer,
+			      ASC_CEILING(scp->request_bufflen, 512));
+	} else {
+		/*
+		 * CDB scatter-gather request list.
+		 */
+		struct scatterlist *slp;
+		int use_sg;
+
+		slp = (struct scatterlist *)scp->request_buffer;
+		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
+				    scp->sc_data_direction);
+
+		if (use_sg > ADV_MAX_SG_LIST) {
+			ASC_PRINT3("adv_build_req: board %d: use_sg %d > "
+				   "ADV_MAX_SG_LIST %d\n", boardp->id, use_sg,
+				   scp->device->host->sg_tablesize);
+			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
+				     scp->sc_data_direction);
+			scp->result = HOST_BYTE(DID_ERROR);
+
+			/*
+			 * Free the 'adv_req_t' structure by adding it back
+			 * to the board free list.
+			 */
+			reqp->next_reqp = boardp->adv_reqp;
+			boardp->adv_reqp = reqp;
+
+			return ASC_ERROR;
+		}
+
+		ret = adv_get_sglist(boardp, reqp, scp, use_sg);
+		if (ret != ADV_SUCCESS) {
+			/*
+			 * Free the adv_req_t structure by adding it back to
+			 * the board free list.
+			 */
+			reqp->next_reqp = boardp->adv_reqp;
+			boardp->adv_reqp = reqp;
+
+			return ret;
+		}
+
+		ASC_STATS(scp->device->host, sg_cnt);
+		ASC_STATS_ADD(scp->device->host, sg_elem, use_sg);
 	}
 
-	/*
-	 * Set microcode operating variables for DISC and SDTR_SPEED1,
-	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
-	 * configuration values.
-	 *
-	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
-	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
-	 * without determining here whether the device supports SDTR.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
-			 asc_dvc->cfg->disc_enable);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
+	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
-	/*
-	 * Set SCSI_CFG0 Microcode Default Value.
-	 *
-	 * The microcode will set the SCSI_CFG0 register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
-			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
-			 asc_dvc->chip_scsi_id);
+	*adv_scsiqpp = scsiqp;
 
-	/*
-	 * Determine SCSI_CFG1 Microcode Default Value.
-	 *
-	 * The microcode will set the SCSI_CFG1 register using this value
-	 * after it is started below.
-	 */
+	return ASC_NOERROR;
+}
+
+static int AscSgListToQueue(int sg_list)
+{
+	int n_sg_list_qs;
+
+	n_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);
+	if (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)
+		n_sg_list_qs++;
+	return n_sg_list_qs + 1;
+}
+
+static uint
+AscGetNumOfFreeQueue(ASC_DVC_VAR *asc_dvc, uchar target_ix, uchar n_qs)
+{
+	uint cur_used_qs;
+	uint cur_free_qs;
+	ASC_SCSI_BIT_ID_TYPE target_id;
+	uchar tid_no;
+
+	target_id = ASC_TIX_TO_TARGET_ID(target_ix);
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	if ((asc_dvc->unit_not_ready & target_id) ||
+	    (asc_dvc->queue_full_or_busy & target_id)) {
+		return 0;
+	}
+	if (n_qs == 1) {
+		cur_used_qs = (uint) asc_dvc->cur_total_qng +
+		    (uint) asc_dvc->last_q_shortage + (uint) ASC_MIN_FREE_Q;
+	} else {
+		cur_used_qs = (uint) asc_dvc->cur_total_qng +
+		    (uint) ASC_MIN_FREE_Q;
+	}
+	if ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {
+		cur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;
+		if (asc_dvc->cur_dvc_qng[tid_no] >=
+		    asc_dvc->max_dvc_qng[tid_no]) {
+			return 0;
+		}
+		return cur_free_qs;
+	}
+	if (n_qs > 1) {
+		if ((n_qs > asc_dvc->last_q_shortage)
+		    && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {
+			asc_dvc->last_q_shortage = n_qs;
+		}
+	}
+	return 0;
+}
+
+static uchar AscAllocFreeQueue(PortAddr iop_base, uchar free_q_head)
+{
+	ushort q_addr;
+	uchar next_qp;
+	uchar q_status;
+
+	q_addr = ASC_QNO_TO_QADDR(free_q_head);
+	q_status = (uchar)AscReadLramByte(iop_base,
+					  (ushort)(q_addr +
+						   ASC_SCSIQ_B_STATUS));
+	next_qp = AscReadLramByte(iop_base, (ushort)(q_addr + ASC_SCSIQ_B_FWD));
+	if (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END))
+		return next_qp;
+	return ASC_QLINK_END;
+}
+
+static uchar
+AscAllocMultipleFreeQueue(PortAddr iop_base, uchar free_q_head, uchar n_free_q)
+{
+	uchar i;
 
-	/* Read current SCSI_CFG1 Register value. */
-	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	for (i = 0; i < n_free_q; i++) {
+		free_q_head = AscAllocFreeQueue(iop_base, free_q_head);
+		if (free_q_head == ASC_QLINK_END)
+			break;
+	}
+	return free_q_head;
+}
 
-	/*
-	 * If the internal narrow cable is reversed all of the SCSI_CTRL
-	 * register signals will be set. Check for and return an error if
-	 * this condition is found.
-	 */
-	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
-		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
-		return ADV_ERROR;
+/*
+ * void
+ * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
+ *
+ * Calling/Exit State:
+ *    none
+ *
+ * Description:
+ *     Output an ASC_SCSI_Q structure to the chip
+ */
+static void
+DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
+{
+	int i;
+
+	ASC_DBG_PRT_HEX(2, "DvcPutScsiQ", outbuf, 2 * words);
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		if (i == 4 || i == 20) {
+			continue;
+		}
+		outpw(iop_base + IOP_RAM_DATA,
+		      ((ushort)outbuf[i + 1] << 8) | outbuf[i]);
 	}
+}
 
-	/*
-	 * All kind of combinations of devices attached to one of four
-	 * connectors are acceptable except HVD device attached. For example,
-	 * LVD device can be attached to SE connector while SE device attached
-	 * to LVD connector.  If LVD device attached to SE connector, it only
-	 * runs up to Ultra speed.
-	 *
-	 * If an HVD device is attached to one of LVD connectors, return an
-	 * error.  However, there is no way to detect HVD device attached to
-	 * SE connectors.
-	 */
-	if (scsi_cfg1 & HVD) {
-		asc_dvc->err_code = ASC_IERR_HVD_DEVICE;
-		return ADV_ERROR;
+static int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
+{
+	ushort q_addr;
+	uchar tid_no;
+	uchar sdtr_data;
+	uchar syn_period_ix;
+	uchar syn_offset;
+	PortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+	if (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&
+	    ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {
+		tid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);
+		sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+		syn_period_ix =
+		    (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);
+		syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;
+		AscMsgOutSDTR(asc_dvc,
+			      asc_dvc->sdtr_period_tbl[syn_period_ix],
+			      syn_offset);
+		scsiq->q1.cntl |= QC_MSG_OUT;
+	}
+	q_addr = ASC_QNO_TO_QADDR(q_no);
+	if ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {
+		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
 	}
+	scsiq->q1.status = QS_FREE;
+	AscMemWordCopyPtrToLram(iop_base,
+				q_addr + ASC_SCSIQ_CDB_BEG,
+				(uchar *)scsiq->cdbptr, scsiq->q2.cdb_len >> 1);
+
+	DvcPutScsiQ(iop_base,
+		    q_addr + ASC_SCSIQ_CPY_BEG,
+		    (uchar *)&scsiq->q1.cntl,
+		    ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);
+	AscWriteLramWord(iop_base,
+			 (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS),
+			 (ushort)(((ushort)scsiq->q1.
+				   q_no << 8) | (ushort)QS_READY));
+	return 1;
+}
+
+static int
+AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
+{
+	int sta;
+	int i;
+	ASC_SG_HEAD *sg_head;
+	ASC_SG_LIST_Q scsi_sg_q;
+	ASC_DCNT saved_data_addr;
+	ASC_DCNT saved_data_cnt;
+	PortAddr iop_base;
+	ushort sg_list_dwords;
+	ushort sg_index;
+	ushort sg_entry_cnt;
+	ushort q_addr;
+	uchar next_qp;
 
+	iop_base = asc_dvc->iop_base;
+	sg_head = scsiq->sg_head;
+	saved_data_addr = scsiq->q1.data_addr;
+	saved_data_cnt = scsiq->q1.data_cnt;
+	scsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;
+	scsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;
+#if CC_VERY_LONG_SG_LIST
 	/*
-	 * If either SE or LVD automatic termination control is enabled, then
-	 * set the termination value based on a table listed in a_condor.h.
-	 *
-	 * If manual termination was specified with an EEPROM setting then
-	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready
-	 * to be 'ored' into SCSI_CFG1.
+	 * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
+	 * then not all SG elements will fit in the allocated queues.
+	 * The rest of the SG elements will be copied when the RISC
+	 * completes the SG elements that fit and halts.
 	 */
-	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
-		/* SE automatic termination control is enabled. */
-		switch (scsi_cfg1 & C_DET_SE) {
-			/* TERM_SE_HI: on, TERM_SE_LO: on */
-		case 0x1:
-		case 0x2:
-		case 0x3:
-			asc_dvc->cfg->termination |= TERM_SE;
-			break;
+	if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
+		/*
+		 * Set sg_entry_cnt to be the number of SG elements that
+		 * will fit in the allocated SG queues. It is minus 1, because
+		 * the first SG element is handled above. ASC_MAX_SG_LIST is
+		 * already inflated by 1 to account for this. For example it
+		 * may be 50 which is 1 + 7 queues * 7 SG elements.
+		 */
+		sg_entry_cnt = ASC_MAX_SG_LIST - 1;
 
-			/* TERM_SE_HI: on, TERM_SE_LO: off */
-		case 0x0:
-			asc_dvc->cfg->termination |= TERM_SE_HI;
-			break;
+		/*
+		 * Keep track of remaining number of SG elements that will
+		 * need to be handled from a_isr.c.
+		 */
+		scsiq->remain_sg_entry_cnt =
+		    sg_head->entry_cnt - ASC_MAX_SG_LIST;
+	} else {
+#endif /* CC_VERY_LONG_SG_LIST */
+		/*
+		 * Set sg_entry_cnt to be the number of SG elements that
+		 * will fit in the allocated SG queues. It is minus 1, because
+		 * the first SG element is handled above.
+		 */
+		sg_entry_cnt = sg_head->entry_cnt - 1;
+#if CC_VERY_LONG_SG_LIST
+	}
+#endif /* CC_VERY_LONG_SG_LIST */
+	if (sg_entry_cnt != 0) {
+		scsiq->q1.cntl |= QC_SG_HEAD;
+		q_addr = ASC_QNO_TO_QADDR(q_no);
+		sg_index = 1;
+		scsiq->q1.sg_queue_cnt = sg_head->queue_cnt;
+		scsi_sg_q.sg_head_qp = q_no;
+		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
+		for (i = 0; i < sg_head->queue_cnt; i++) {
+			scsi_sg_q.seq_no = i + 1;
+			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
+				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
+				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
+				if (i == 0) {
+					scsi_sg_q.sg_list_cnt =
+					    ASC_SG_LIST_PER_Q;
+					scsi_sg_q.sg_cur_list_cnt =
+					    ASC_SG_LIST_PER_Q;
+				} else {
+					scsi_sg_q.sg_list_cnt =
+					    ASC_SG_LIST_PER_Q - 1;
+					scsi_sg_q.sg_cur_list_cnt =
+					    ASC_SG_LIST_PER_Q - 1;
+				}
+			} else {
+#if CC_VERY_LONG_SG_LIST
+				/*
+				 * This is the last SG queue in the list of
+				 * allocated SG queues. If there are more
+				 * SG elements than will fit in the allocated
+				 * queues, then set the QCSG_SG_XFER_MORE flag.
+				 */
+				if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
+					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
+				} else {
+#endif /* CC_VERY_LONG_SG_LIST */
+					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
+#if CC_VERY_LONG_SG_LIST
+				}
+#endif /* CC_VERY_LONG_SG_LIST */
+				sg_list_dwords = sg_entry_cnt << 1;
+				if (i == 0) {
+					scsi_sg_q.sg_list_cnt = sg_entry_cnt;
+					scsi_sg_q.sg_cur_list_cnt =
+					    sg_entry_cnt;
+				} else {
+					scsi_sg_q.sg_list_cnt =
+					    sg_entry_cnt - 1;
+					scsi_sg_q.sg_cur_list_cnt =
+					    sg_entry_cnt - 1;
+				}
+				sg_entry_cnt = 0;
+			}
+			next_qp = AscReadLramByte(iop_base,
+						  (ushort)(q_addr +
+							   ASC_SCSIQ_B_FWD));
+			scsi_sg_q.q_no = next_qp;
+			q_addr = ASC_QNO_TO_QADDR(next_qp);
+			AscMemWordCopyPtrToLram(iop_base,
+						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
+						(uchar *)&scsi_sg_q,
+						sizeof(ASC_SG_LIST_Q) >> 1);
+			AscMemDWordCopyPtrToLram(iop_base,
+						 q_addr + ASC_SGQ_LIST_BEG,
+						 (uchar *)&sg_head->
+						 sg_list[sg_index],
+						 sg_list_dwords);
+			sg_index += ASC_SG_LIST_PER_Q;
+			scsiq->next_sg_index = sg_index;
 		}
+	} else {
+		scsiq->q1.cntl &= ~QC_SG_HEAD;
 	}
+	sta = AscPutReadyQueue(asc_dvc, scsiq, q_no);
+	scsiq->q1.data_addr = saved_data_addr;
+	scsiq->q1.data_cnt = saved_data_cnt;
+	return (sta);
+}
 
-	if ((asc_dvc->cfg->termination & TERM_LVD) == 0) {
-		/* LVD automatic termination control is enabled. */
-		switch (scsi_cfg1 & C_DET_LVD) {
-			/* TERM_LVD_HI: on, TERM_LVD_LO: on */
-		case 0x4:
-		case 0x8:
-		case 0xC:
-			asc_dvc->cfg->termination |= TERM_LVD;
-			break;
+static int
+AscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)
+{
+	PortAddr iop_base;
+	uchar free_q_head;
+	uchar next_qp;
+	uchar tid_no;
+	uchar target_ix;
+	int sta;
 
-			/* TERM_LVD_HI: off, TERM_LVD_LO: off */
-		case 0x0:
-			break;
+	iop_base = asc_dvc->iop_base;
+	target_ix = scsiq->q2.target_ix;
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	sta = 0;
+	free_q_head = (uchar)AscGetVarFreeQHead(iop_base);
+	if (n_q_required > 1) {
+		next_qp = AscAllocMultipleFreeQueue(iop_base, free_q_head,
+						    (uchar)n_q_required);
+		if (next_qp != ASC_QLINK_END) {
+			asc_dvc->last_q_shortage = 0;
+			scsiq->sg_head->queue_cnt = n_q_required - 1;
+			scsiq->q1.q_no = free_q_head;
+			sta = AscPutReadySgListQueue(asc_dvc, scsiq,
+						     free_q_head);
+		}
+	} else if (n_q_required == 1) {
+		next_qp = AscAllocFreeQueue(iop_base, free_q_head);
+		if (next_qp != ASC_QLINK_END) {
+			scsiq->q1.q_no = free_q_head;
+			sta = AscPutReadyQueue(asc_dvc, scsiq, free_q_head);
 		}
 	}
-
-	/*
-	 * Clear any set TERM_SE and TERM_LVD bits.
-	 */
-	scsi_cfg1 &= (~TERM_SE & ~TERM_LVD);
-
-	/*
-	 * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.
-	 */
-	scsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);
-
-	/*
-	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE
-	 * bits and set possibly modified termination control bits in the
-	 * Microcode SCSI_CFG1 Register Value.
-	 */
-	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);
-
-	/*
-	 * Set SCSI_CFG1 Microcode Default Value
-	 *
-	 * Set possibly modified termination control and reset DIS_TERM_DRV
-	 * bits in the Microcode SCSI_CFG1 Register Value.
-	 *
-	 * The microcode will set the SCSI_CFG1 register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
-
-	/*
-	 * Set MEM_CFG Microcode Default Value
-	 *
-	 * The microcode will set the MEM_CFG register using this value
-	 * after it is started below.
-	 *
-	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
-	 * are defined.
-	 *
-	 * ASC-38C0800 has 16KB internal memory.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-			 BIOS_EN | RAM_SZ_16KB);
-
-	/*
-	 * Set SEL_MASK Microcode Default Value
-	 *
-	 * The microcode will set the SEL_MASK register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
-			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
-
-	AdvBuildCarrierFreelist(asc_dvc);
-
-	/*
-	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
-	 */
-
-	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
-		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-		return ADV_ERROR;
+	if (sta == 1) {
+		AscPutVarFreeQHead(iop_base, next_qp);
+		asc_dvc->cur_total_qng += n_q_required;
+		asc_dvc->cur_dvc_qng[tid_no]++;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+	return sta;
+}
 
-	/*
-	 * The first command issued will be placed in the stopper carrier.
-	 */
-	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16
+static uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] = {
+	INQUIRY,
+	REQUEST_SENSE,
+	READ_CAPACITY,
+	READ_TOC,
+	MODE_SELECT,
+	MODE_SENSE,
+	MODE_SELECT_10,
+	MODE_SENSE_10,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF
+};
 
-	/*
-	 * Set RISC ICQ physical address start value.
-	 * carr_pa is LE, must be native before write
-	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
+{
+	PortAddr iop_base;
+	int sta;
+	int n_q_required;
+	int disable_syn_offset_one_fix;
+	int i;
+	ASC_PADDR addr;
+	ushort sg_entry_cnt = 0;
+	ushort sg_entry_cnt_minus_one = 0;
+	uchar target_ix;
+	uchar tid_no;
+	uchar sdtr_data;
+	uchar extra_bytes;
+	uchar scsi_cmd;
+	uchar disable_cmd;
+	ASC_SG_HEAD *sg_head;
+	ASC_DCNT data_cnt;
 
-	/*
-	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
-	 */
-	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
-		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-		return ADV_ERROR;
+	iop_base = asc_dvc->iop_base;
+	sg_head = scsiq->sg_head;
+	if (asc_dvc->err_code != 0)
+		return (ERR);
+	scsiq->q1.q_no = 0;
+	if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
+		scsiq->q1.extra_bytes = 0;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
-
-	/*
-	 * The first command completed by the RISC will be placed in
-	 * the stopper.
-	 *
-	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-	 * completed the RISC will set the ASC_RQ_STOPPER bit.
-	 */
-	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
-
-	/*
-	 * Set RISC IRQ physical address start value.
-	 *
-	 * carr_pa is LE, must be native before write *
-	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
-	asc_dvc->carr_pending_cnt = 0;
-
-	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
-			     (ADV_INTR_ENABLE_HOST_INTR |
-			      ADV_INTR_ENABLE_GLOBAL_INTR));
-
-	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
-	AdvWriteWordRegister(iop_base, IOPW_PC, word);
-
-	/* finally, finally, gentlemen, start your engine */
-	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
-
-	/*
-	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
-	 * Resets should be performed. The RISC has to be running
-	 * to issue a SCSI Bus Reset.
-	 */
-	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+	sta = 0;
+	target_ix = scsiq->q2.target_ix;
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	n_q_required = 1;
+	if (scsiq->cdbptr[0] == REQUEST_SENSE) {
+		if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {
+			asc_dvc->sdtr_done &= ~scsiq->q1.target_id;
+			sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+			AscMsgOutSDTR(asc_dvc,
+				      asc_dvc->
+				      sdtr_period_tbl[(sdtr_data >> 4) &
+						      (uchar)(asc_dvc->
+							      max_sdtr_index -
+							      1)],
+				      (uchar)(sdtr_data & (uchar)
+					      ASC_SYN_MAX_OFFSET));
+			scsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);
+		}
+	}
+	if (asc_dvc->in_critical_cnt != 0) {
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
+		return (ERR);
+	}
+	asc_dvc->in_critical_cnt++;
+	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
+		if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
+			asc_dvc->in_critical_cnt--;
+			return (ERR);
+		}
+#if !CC_VERY_LONG_SG_LIST
+		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
+			asc_dvc->in_critical_cnt--;
+			return (ERR);
+		}
+#endif /* !CC_VERY_LONG_SG_LIST */
+		if (sg_entry_cnt == 1) {
+			scsiq->q1.data_addr =
+			    (ADV_PADDR)sg_head->sg_list[0].addr;
+			scsiq->q1.data_cnt =
+			    (ADV_DCNT)sg_head->sg_list[0].bytes;
+			scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
+		}
+		sg_entry_cnt_minus_one = sg_entry_cnt - 1;
+	}
+	scsi_cmd = scsiq->cdbptr[0];
+	disable_syn_offset_one_fix = FALSE;
+	if ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&
+	    !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {
+		if (scsiq->q1.cntl & QC_SG_HEAD) {
+			data_cnt = 0;
+			for (i = 0; i < sg_entry_cnt; i++) {
+				data_cnt +=
+				    (ADV_DCNT)le32_to_cpu(sg_head->sg_list[i].
+							  bytes);
+			}
+		} else {
+			data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
+		}
+		if (data_cnt != 0UL) {
+			if (data_cnt < 512UL) {
+				disable_syn_offset_one_fix = TRUE;
+			} else {
+				for (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;
+				     i++) {
+					disable_cmd =
+					    _syn_offset_one_disable_cmd[i];
+					if (disable_cmd == 0xFF) {
+						break;
+					}
+					if (scsi_cmd == disable_cmd) {
+						disable_syn_offset_one_fix =
+						    TRUE;
+						break;
+					}
+				}
+			}
+		}
+	}
+	if (disable_syn_offset_one_fix) {
+		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
+		scsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
+				       ASC_TAG_FLAG_DISABLE_DISCONNECT);
+	} else {
+		scsiq->q2.tag_code &= 0x27;
+	}
+	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
+		if (asc_dvc->bug_fix_cntl) {
+			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
+				if ((scsi_cmd == READ_6) ||
+				    (scsi_cmd == READ_10)) {
+					addr =
+					    (ADV_PADDR)le32_to_cpu(sg_head->
+								   sg_list
+								   [sg_entry_cnt_minus_one].
+								   addr) +
+					    (ADV_DCNT)le32_to_cpu(sg_head->
+								  sg_list
+								  [sg_entry_cnt_minus_one].
+								  bytes);
+					extra_bytes =
+					    (uchar)((ushort)addr & 0x0003);
+					if ((extra_bytes != 0)
+					    &&
+					    ((scsiq->q2.
+					      tag_code &
+					      ASC_TAG_FLAG_EXTRA_BYTES)
+					     == 0)) {
+						scsiq->q2.tag_code |=
+						    ASC_TAG_FLAG_EXTRA_BYTES;
+						scsiq->q1.extra_bytes =
+						    extra_bytes;
+						data_cnt =
+						    le32_to_cpu(sg_head->
+								sg_list
+								[sg_entry_cnt_minus_one].
+								bytes);
+						data_cnt -=
+						    (ASC_DCNT) extra_bytes;
+						sg_head->
+						    sg_list
+						    [sg_entry_cnt_minus_one].
+						    bytes =
+						    cpu_to_le32(data_cnt);
+					}
+				}
+			}
+		}
+		sg_head->entry_to_copy = sg_head->entry_cnt;
+#if CC_VERY_LONG_SG_LIST
 		/*
-		 * If the BIOS Signature is present in memory, restore the
-		 * BIOS Handshake Configuration Table and do not perform
-		 * a SCSI Bus Reset.
+		 * Set the sg_entry_cnt to the maximum possible. The rest of
+		 * the SG elements will be copied when the RISC completes the
+		 * SG elements that fit and halts.
 		 */
-		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
-		    0x55AA) {
-			/*
-			 * Restore per TID negotiated values.
-			 */
-			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
-					 tagqng_able);
-			for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-				AdvWriteByteLram(iop_base,
-						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
-						 max_cmd[tid]);
+		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
+			sg_entry_cnt = ASC_MAX_SG_LIST;
+		}
+#endif /* CC_VERY_LONG_SG_LIST */
+		n_q_required = AscSgListToQueue(sg_entry_cnt);
+		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=
+		     (uint) n_q_required)
+		    || ((scsiq->q1.cntl & QC_URGENT) != 0)) {
+			if ((sta =
+			     AscSendScsiQueue(asc_dvc, scsiq,
+					      n_q_required)) == 1) {
+				asc_dvc->in_critical_cnt--;
+				return (sta);
 			}
-		} else {
-			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
-				warn_code = ASC_WARN_BUSRESET_ERROR;
+		}
+	} else {
+		if (asc_dvc->bug_fix_cntl) {
+			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
+				if ((scsi_cmd == READ_6) ||
+				    (scsi_cmd == READ_10)) {
+					addr =
+					    le32_to_cpu(scsiq->q1.data_addr) +
+					    le32_to_cpu(scsiq->q1.data_cnt);
+					extra_bytes =
+					    (uchar)((ushort)addr & 0x0003);
+					if ((extra_bytes != 0)
+					    &&
+					    ((scsiq->q2.
+					      tag_code &
+					      ASC_TAG_FLAG_EXTRA_BYTES)
+					     == 0)) {
+						data_cnt =
+						    le32_to_cpu(scsiq->q1.
+								data_cnt);
+						if (((ushort)data_cnt & 0x01FF)
+						    == 0) {
+							scsiq->q2.tag_code |=
+							    ASC_TAG_FLAG_EXTRA_BYTES;
+							data_cnt -= (ASC_DCNT)
+							    extra_bytes;
+							scsiq->q1.data_cnt =
+							    cpu_to_le32
+							    (data_cnt);
+							scsiq->q1.extra_bytes =
+							    extra_bytes;
+						}
+					}
+				}
+			}
+		}
+		n_q_required = 1;
+		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||
+		    ((scsiq->q1.cntl & QC_URGENT) != 0)) {
+			if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
+						    n_q_required)) == 1) {
+				asc_dvc->in_critical_cnt--;
+				return (sta);
 			}
 		}
 	}
-
-	return warn_code;
+	asc_dvc->in_critical_cnt--;
+	return (sta);
 }
 
 /*
- * Initialize the ASC-38C1600.
- *
- * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
+ * AdvExeScsiQueue() - Send a request to the RISC microcode program.
  *
- * Needed after initialization for error recovery.
- */
-static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
-{
-	AdvPortAddr iop_base;
-	ushort warn_code;
-	int begin_addr;
-	int end_addr;
-	ushort code_sum;
-	long word;
-	int i;
-	ushort scsi_cfg1;
-	uchar byte;
-	uchar tid;
-	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
-	ushort wdtr_able, sdtr_able, ppr_able, tagqng_able;
-	uchar max_cmd[ASC_MAX_TID + 1];
-
-	/* If there is already an error, don't continue. */
-	if (asc_dvc->err_code != 0) {
-		return ADV_ERROR;
-	}
-
-	/*
-	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.
-	 */
-	if (asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {
-		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
-		return ADV_ERROR;
-	}
-
-	warn_code = 0;
-	iop_base = asc_dvc->iop_base;
-
-	/*
-	 * Save the RISC memory BIOS region before writing the microcode.
-	 * The BIOS may already be loaded and using its RISC LRAM region
-	 * so its region must be saved and restored.
-	 *
-	 * Note: This code makes the assumption, which is currently true,
-	 * that a chip reset does not clear RISC LRAM.
-	 */
-	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
-		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
-				bios_mem[i]);
-	}
-
-	/*
-	 * Save current per TID negotiated values.
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	for (tid = 0; tid <= ASC_MAX_TID; tid++) {
-		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-				max_cmd[tid]);
-	}
-
-	/*
-	 * RAM BIST (Built-In Self Test)
-	 *
-	 * Address : I/O base + offset 0x38h register (byte).
-	 * Function: Bit 7-6(RW) : RAM mode
-	 *                          Normal Mode   : 0x00
-	 *                          Pre-test Mode : 0x40
-	 *                          RAM Test Mode : 0x80
-	 *           Bit 5       : unused
-	 *           Bit 4(RO)   : Done bit
-	 *           Bit 3-0(RO) : Status
-	 *                          Host Error    : 0x08
-	 *                          Int_RAM Error : 0x04
-	 *                          RISC Error    : 0x02
-	 *                          SCSI Error    : 0x01
-	 *                          No Error      : 0x00
-	 *
-	 * Note: RAM BIST code should be put right here, before loading the
-	 * microcode and after saving the RISC memory BIOS region.
-	 */
-
-	/*
-	 * LRAM Pre-test
-	 *
-	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
-	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
-	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
-	 * to NORMAL_MODE, return an error too.
-	 */
-	for (i = 0; i < 2; i++) {
-		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
-		mdelay(10);	/* Wait for 10ms before reading back. */
-		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-		if ((byte & RAM_TEST_DONE) == 0
-		    || (byte & 0x0F) != PRE_TEST_VALUE) {
-			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
-			return ADV_ERROR;
-		}
-
-		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-		mdelay(10);	/* Wait for 10ms before reading back. */
-		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
-		    != NORMAL_VALUE) {
-			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
-			return ADV_ERROR;
-		}
-	}
+ *   Allocate a carrier structure, point the carrier to the ADV_SCSI_REQ_Q,
+ *   add the carrier to the ICQ (Initiator Command Queue), and tickle the
+ *   RISC to notify it a new command is ready to be executed.
+ *
+ * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
+ * set to SCSI_MAX_RETRY.
+ *
+ * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the microcode
+ * for DMA addresses or math operations are byte swapped to little-endian
+ * order.
+ *
+ * Return:
+ *      ADV_SUCCESS(1) - The request was successfully queued.
+ *      ADV_BUSY(0) -    Resource unavailable; Retry again after pending
+ *                       request completes.
+ *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure
+ *                       host IC error.
+ */
+static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
+{
+	AdvPortAddr iop_base;
+	ADV_DCNT req_size;
+	ADV_PADDR req_paddr;
+	ADV_CARR_T *new_carrp;
 
 	/*
-	 * LRAM Test - It takes about 1.5 ms to run through the test.
-	 *
-	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
-	 * If Done bit not set or Status not 0, save register byte, set the
-	 * err_code, and return an error.
+	 * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
 	 */
-	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
-	mdelay(10);	/* Wait for 10ms before checking status. */
-
-	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
-		/* Get here if Done bit not set or Status not 0. */
-		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
-		asc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;
+	if (scsiq->target_id > ADV_MAX_TID) {
+		scsiq->host_status = QHSTA_M_INVALID_DEVICE;
+		scsiq->done_status = QD_WITH_ERROR;
 		return ADV_ERROR;
 	}
 
-	/* We need to reset back to normal mode after LRAM test passes. */
-	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-
-	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C1600_buf,
-				 _adv_asc38C1600_size, ADV_38C1600_MEMSIZE,
-				 _adv_asc38C1600_chksum);
-	if (asc_dvc->err_code)
-		return ADV_ERROR;
+	iop_base = asc_dvc->iop_base;
 
 	/*
-	 * Restore the RISC memory BIOS region.
+	 * Allocate a carrier ensuring at least one carrier always
+	 * remains on the freelist and initialize fields.
 	 */
-	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
-		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
-				 bios_mem[i]);
+	if ((new_carrp = asc_dvc->carr_freelist) == NULL) {
+		return ADV_BUSY;
 	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));
+	asc_dvc->carr_pending_cnt++;
 
 	/*
-	 * Calculate and write the microcode code checksum to the microcode
-	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 * Set the carrier to be a stopper by setting 'next_vpa'
+	 * to the stopper value. The current stopper will be changed
+	 * below to point to the new stopper.
 	 */
-	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
-	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
-	code_sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
-	for (word = begin_addr; word < end_addr; word += 2) {
-		code_sum += AdvReadWordAutoIncLram(iop_base);
-	}
-	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+	new_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
 
 	/*
-	 * Read microcode version and date.
+	 * Clear the ADV_SCSI_REQ_Q done flag.
 	 */
-	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
-			asc_dvc->cfg->mcode_date);
-	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
-			asc_dvc->cfg->mcode_version);
+	scsiq->a_flag &= ~ADV_SCSIQ_DONE;
 
-	/*
-	 * Set the chip type to indicate the ASC38C1600.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);
+	req_size = sizeof(ADV_SCSI_REQ_Q);
+	req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *)scsiq,
+				  (ADV_SDCNT *)&req_size, ADV_IS_SCSIQ_FLAG);
 
-	/*
-	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
-	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
-	 * cable detection and then we are able to read C_DET[3:0].
-	 *
-	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
-	 * Microcode Default Value' section below.
-	 */
-	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
-	AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,
-			     scsi_cfg1 | DIS_TERM_DRV);
+	BUG_ON(req_paddr & 31);
+	BUG_ON(req_size < sizeof(ADV_SCSI_REQ_Q));
+
+	/* Wait for assertion before making little-endian */
+	req_paddr = cpu_to_le32(req_paddr);
 
+	/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
+	scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
+	scsiq->scsiq_rptr = req_paddr;
+
+	scsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));
 	/*
-	 * If the PCI Configuration Command Register "Parity Error Response
-	 * Control" Bit was clear (0), then set the microcode variable
-	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
-	 * to ignore DMA parity errors.
+	 * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
+	 * order during initialization.
 	 */
-	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
-		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-		word |= CONTROL_FLAG_IGNORE_PERR;
-		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-	}
+	scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
 
 	/*
-	 * If the BIOS control flag AIPP (Asynchronous Information
-	 * Phase Protection) disable bit is not set, then set the firmware
-	 * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable
-	 * AIPP checking and encoding.
+	 * Use the current stopper to send the ADV_SCSI_REQ_Q command to
+	 * the microcode. The newly allocated stopper will become the new
+	 * stopper.
 	 */
-	if ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {
-		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-		word |= CONTROL_FLAG_ENABLE_AIPP;
-		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-	}
+	asc_dvc->icq_sp->areq_vpa = req_paddr;
 
 	/*
-	 * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],
-	 * and START_CTL_TH [3:2].
+	 * Set the 'next_vpa' pointer for the old stopper to be the
+	 * physical address of the new stopper. The RISC can only
+	 * follow physical addresses.
 	 */
-	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
-			     FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
+	asc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;
 
 	/*
-	 * Microcode operating variables for WDTR, SDTR, and command tag
-	 * queuing will be set in slave_configure() based on what a
-	 * device reports it is capable of in Inquiry byte 7.
-	 *
-	 * If SCSI Bus Resets have been disabled, then directly set
-	 * SDTR and WDTR from the EEPROM configuration. This will allow
-	 * the BIOS and warm boot to work without a SCSI bus hang on
-	 * the Inquiry caused by host and target mismatched DTR values.
-	 * Without the SCSI Bus Reset, before an Inquiry a device can't
-	 * be assumed to be in Asynchronous, Narrow mode.
+	 * Set the host adapter stopper pointer to point to the new carrier.
 	 */
-	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
-		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
-				 asc_dvc->wdtr_able);
-		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
-				 asc_dvc->sdtr_able);
+	asc_dvc->icq_sp = new_carrp;
+
+	if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
+	    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+		/*
+		 * Tickle the RISC to tell it to read its Command Queue Head pointer.
+		 */
+		AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
+		if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+			/*
+			 * Clear the tickle value. In the ASC-3550 the RISC flag
+			 * command 'clr_tickle_a' does not work unless the host
+			 * value is cleared.
+			 */
+			AdvWriteByteRegister(iop_base, IOPB_TICKLE,
+					     ADV_TICKLE_NOP);
+		}
+	} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		/*
+		 * Notify the RISC a carrier is ready by writing the physical
+		 * address of the new carrier stopper to the COMMA register.
+		 */
+		AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
+				      le32_to_cpu(new_carrp->carr_pa));
 	}
 
-	/*
-	 * Set microcode operating variables for DISC and SDTR_SPEED1,
-	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
-	 * configuration values.
-	 *
-	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
-	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
-	 * without determining here whether the device supports SDTR.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
-			 asc_dvc->cfg->disc_enable);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+	return ADV_SUCCESS;
+}
+
+/*
+ * Execute a single 'Scsi_Cmnd'.
+ *
+ * The function 'done' is called when the request has been completed.
+ *
+ * Scsi_Cmnd:
+ *
+ *  host - board controlling device
+ *  device - device to send command
+ *  target - target of device
+ *  lun - lun of device
+ *  cmd_len - length of SCSI CDB
+ *  cmnd - buffer for SCSI 8, 10, or 12 byte CDB
+ *  use_sg - if non-zero indicates scatter-gather request with use_sg elements
+ *
+ *  if (use_sg == 0) {
+ *    request_buffer - buffer address for request
+ *    request_bufflen - length of request buffer
+ *  } else {
+ *    request_buffer - pointer to scatterlist structure
+ *  }
+ *
+ *  sense_buffer - sense command buffer
+ *
+ *  result (4 bytes of an int):
+ *    Byte Meaning
+ *    0 SCSI Status Byte Code
+ *    1 SCSI One Byte Message Code
+ *    2 Host Error Code
+ *    3 Mid-Level Error Code
+ *
+ *  host driver fields:
+ *    SCp - Scsi_Pointer used for command processing status
+ *    scsi_done - used to save caller's done function
+ *    host_scribble - used for pointer to another struct scsi_cmnd
+ *
+ * If this function returns ASC_NOERROR the request will be completed
+ * from the interrupt handler.
+ *
+ * If this function returns ASC_ERROR the host error code has been set,
+ * and the called must call asc_scsi_done.
+ *
+ * If ASC_BUSY is returned the request will be returned to the midlayer
+ * and re-tried later.
+ */
+static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
+{
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	ADV_SCSI_REQ_Q *adv_scsiqp;
+	struct scsi_device *device;
+	int ret;
+
+	ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
+		 (ulong)scp, (ulong)scp->scsi_done);
 
-	/*
-	 * Set SCSI_CFG0 Microcode Default Value.
-	 *
-	 * The microcode will set the SCSI_CFG0 register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
-			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
-			 asc_dvc->chip_scsi_id);
+	boardp = ASC_BOARDP(scp->device->host);
+	device = boardp->device[scp->device->id];
 
-	/*
-	 * Calculate SCSI_CFG1 Microcode Default Value.
-	 *
-	 * The microcode will set the SCSI_CFG1 register using this value
-	 * after it is started below.
-	 *
-	 * Each ASC-38C1600 function has only two cable detect bits.
-	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.
-	 */
-	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	if (ASC_NARROW_BOARD(boardp)) {
+		/*
+		 * Build and execute Narrow Board request.
+		 */
 
-	/*
-	 * If the cable is reversed all of the SCSI_CTRL register signals
-	 * will be set. Check for and return an error if this condition is
-	 * found.
-	 */
-	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
-		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
-		return ADV_ERROR;
-	}
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 
-	/*
-	 * Each ASC-38C1600 function has two connectors. Only an HVD device
-	 * can not be connected to either connector. An LVD device or SE device
-	 * may be connected to either connecor. If an SE device is connected,
-	 * then at most Ultra speed (20 Mhz) can be used on both connectors.
-	 *
-	 * If an HVD device is attached, return an error.
-	 */
-	if (scsi_cfg1 & HVD) {
-		asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
-		return ADV_ERROR;
-	}
+		/*
+		 * Build Asc Library request structure using the
+		 * global structures 'asc_scsi_req' and 'asc_sg_head'.
+		 *
+		 * If an error is returned, then the request has been
+		 * queued on the board done queue. It will be completed
+		 * by the caller.
+		 *
+		 * asc_build_req() can not return ASC_BUSY.
+		 */
+		if (asc_build_req(boardp, scp) == ASC_ERROR) {
+			ASC_STATS(scp->device->host, build_error);
+			return ASC_ERROR;
+		}
 
-	/*
-	 * Each function in the ASC-38C1600 uses only the SE cable detect and
-	 * termination because there are two connectors for each function. Each
-	 * function may use either LVD or SE mode. Corresponding the SE automatic
-	 * termination control EEPROM bits are used for each function. Each
-	 * function has its own EEPROM. If SE automatic control is enabled for
-	 * the function, then set the termination value based on a table listed
-	 * in a_condor.h.
-	 *
-	 * If manual termination is specified in the EEPROM for the function,
-	 * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is
-	 * ready to be 'ored' into SCSI_CFG1.
-	 */
-	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
-		struct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);
-		/* SE automatic termination control is enabled. */
-		switch (scsi_cfg1 & C_DET_SE) {
-			/* TERM_SE_HI: on, TERM_SE_LO: on */
-		case 0x1:
-		case 0x2:
-		case 0x3:
-			asc_dvc->cfg->termination |= TERM_SE;
+		switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
+		case ASC_NOERROR:
+			ASC_STATS(scp->device->host, exe_noerror);
+			/*
+			 * Increment monotonically increasing per device
+			 * successful request counter. Wrapping doesn't matter.
+			 */
+			boardp->reqcnt[scp->device->id]++;
+			ASC_DBG(1, "asc_execute_scsi_cmnd: AscExeScsiQueue(), "
+				"ASC_NOERROR\n");
+			break;
+		case ASC_BUSY:
+			ASC_STATS(scp->device->host, exe_busy);
 			break;
+		case ASC_ERROR:
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+				boardp->id, asc_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_error);
+			scp->result = HOST_BYTE(DID_ERROR);
+			break;
+		default:
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AscExeScsiQueue() unknown, err_code 0x%x\n",
+				boardp->id, asc_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_unknown);
+			scp->result = HOST_BYTE(DID_ERROR);
+			break;
+		}
+	} else {
+		/*
+		 * Build and execute Wide Board request.
+		 */
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 
-		case 0x0:
-			if (PCI_FUNC(pdev->devfn) == 0) {
-				/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
-			} else {
-				/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
-				asc_dvc->cfg->termination |= TERM_SE_HI;
-			}
+		/*
+		 * Build and get a pointer to an Adv Library request structure.
+		 *
+		 * If the request is successfully built then send it below,
+		 * otherwise return with an error.
+		 */
+		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
+		case ASC_NOERROR:
+			ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req "
+				"ASC_NOERROR\n");
+			break;
+		case ASC_BUSY:
+			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
+				"ASC_BUSY\n");
+			/*
+			 * The asc_stats fields 'adv_build_noreq' and
+			 * 'adv_build_nosg' count wide board busy conditions.
+			 * They are updated in adv_build_req and
+			 * adv_get_sglist, respectively.
+			 */
+			return ASC_BUSY;
+		case ASC_ERROR:
+		default:
+			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
+				"ASC_ERROR\n");
+			ASC_STATS(scp->device->host, build_error);
+			return ASC_ERROR;
+		}
+
+		switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
+		case ASC_NOERROR:
+			ASC_STATS(scp->device->host, exe_noerror);
+			/*
+			 * Increment monotonically increasing per device
+			 * successful request counter. Wrapping doesn't matter.
+			 */
+			boardp->reqcnt[scp->device->id]++;
+			ASC_DBG(1, "asc_execute_scsi_cmnd: AdvExeScsiQueue(), "
+				"ASC_NOERROR\n");
+			break;
+		case ASC_BUSY:
+			ASC_STATS(scp->device->host, exe_busy);
+			break;
+		case ASC_ERROR:
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+				boardp->id, adv_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_error);
+			scp->result = HOST_BYTE(DID_ERROR);
+			break;
+		default:
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AdvExeScsiQueue() unknown, err_code 0x%x\n",
+				boardp->id, adv_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_unknown);
+			scp->result = HOST_BYTE(DID_ERROR);
 			break;
 		}
 	}
 
-	/*
-	 * Clear any set TERM_SE bits.
-	 */
-	scsi_cfg1 &= ~TERM_SE;
+	ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");
+	return ret;
+}
 
-	/*
-	 * Invert the TERM_SE bits and then set 'scsi_cfg1'.
-	 */
-	scsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);
+/*
+ * advansys_queuecommand() - interrupt-driven I/O entrypoint.
+ *
+ * This function always returns 0. Command return status is saved
+ * in the 'scp' result field.
+ */
+static int
+advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+{
+	struct Scsi_Host *shost = scp->device->host;
+	asc_board_t *boardp = ASC_BOARDP(shost);
+	unsigned long flags;
+	int asc_res, result = 0;
 
-	/*
-	 * Clear Big Endian and Terminator Polarity bits and set possibly
-	 * modified termination control bits in the Microcode SCSI_CFG1
-	 * Register Value.
-	 *
-	 * Big Endian bit is not used even on big endian machines.
-	 */
-	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);
+	ASC_STATS(shost, queuecommand);
+	scp->scsi_done = done;
 
 	/*
-	 * Set SCSI_CFG1 Microcode Default Value
-	 *
-	 * Set possibly modified termination control bits in the Microcode
-	 * SCSI_CFG1 Register Value.
-	 *
-	 * The microcode will set the SCSI_CFG1 register using this value
-	 * after it is started below.
+	 * host_lock taken by mid-level prior to call, but need
+	 * to protect against own ISR
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+	spin_lock_irqsave(&boardp->lock, flags);
+	asc_res = asc_execute_scsi_cmnd(scp);
+	spin_unlock_irqrestore(&boardp->lock, flags);
+
+	switch (asc_res) {
+	case ASC_NOERROR:
+		break;
+	case ASC_BUSY:
+		result = SCSI_MLQUEUE_HOST_BUSY;
+		break;
+	case ASC_ERROR:
+	default:
+		asc_scsi_done(scp);
+		break;
+	}
+
+	return result;
+}
+
+static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
+{
+	PortAddr eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
+	    (PortAddr) (ASC_EISA_CFG_IOP_MASK);
+	return inpw(eisa_cfg_iop);
+}
+
+/*
+ * Return the BIOS address of the adapter at the specified
+ * I/O port and with the specified bus type.
+ */
+static unsigned short __devinit
+AscGetChipBiosAddress(PortAddr iop_base, unsigned short bus_type)
+{
+	unsigned short cfg_lsw;
+	unsigned short bios_addr;
 
 	/*
-	 * Set MEM_CFG Microcode Default Value
-	 *
-	 * The microcode will set the MEM_CFG register using this value
-	 * after it is started below.
-	 *
-	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
-	 * are defined.
-	 *
-	 * ASC-38C1600 has 32KB internal memory.
-	 *
-	 * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come
-	 * out a special 16K Adv Library and Microcode version. After the issue
-	 * resolved, we should turn back to the 32K support. Both a_condor.h and
-	 * mcode.sas files also need to be updated.
-	 *
-	 * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-	 *  BIOS_EN | RAM_SZ_32KB);
+	 * The PCI BIOS is re-located by the motherboard BIOS. Because
+	 * of this the driver can not determine where a PCI BIOS is
+	 * loaded and executes.
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-			 BIOS_EN | RAM_SZ_16KB);
+	if (bus_type & ASC_IS_PCI)
+		return 0;
 
-	/*
-	 * Set SEL_MASK Microcode Default Value
-	 *
-	 * The microcode will set the SEL_MASK register using this value
-	 * after it is started below.
-	 */
-	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
-			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+	if ((bus_type & ASC_IS_EISA) != 0) {
+		cfg_lsw = AscGetEisaChipCfg(iop_base);
+		cfg_lsw &= 0x000F;
+		bios_addr = ASC_BIOS_MIN_ADDR + cfg_lsw * ASC_BIOS_BANK_SIZE;
+		return bios_addr;
+	}
 
-	AdvBuildCarrierFreelist(asc_dvc);
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
 
 	/*
-	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 *  ISA PnP uses the top bit as the 32K BIOS flag
 	 */
-	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
-		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-		return ADV_ERROR;
+	if (bus_type == ASC_IS_ISAPNP)
+		cfg_lsw &= 0x7FFF;
+	bios_addr = ASC_BIOS_MIN_ADDR + (cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE;
+	return bios_addr;
+}
+
+static uchar __devinit AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
+{
+	ushort cfg_lsw;
+
+	if (AscGetChipScsiID(iop_base) == new_host_id) {
+		return (new_host_id);
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
+	cfg_lsw &= 0xF8FF;
+	cfg_lsw |= (ushort)((new_host_id & ASC_MAX_TID) << 8);
+	AscSetChipCfgLsw(iop_base, cfg_lsw);
+	return (AscGetChipScsiID(iop_base));
+}
 
-	/*
-	 * The first command issued will be placed in the stopper carrier.
-	 */
-	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+static unsigned char __devinit AscGetChipScsiCtrl(PortAddr iop_base)
+{
+	unsigned char sc;
 
-	/*
-	 * Set RISC ICQ physical address start value. Initialize the
-	 * COMMA register to the same value otherwise the RISC will
-	 * prematurely detect a command is available.
-	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
-	AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
-			      le32_to_cpu(asc_dvc->icq_sp->carr_pa));
+	AscSetBank(iop_base, 1);
+	sc = inp(iop_base + IOP_REG_SC);
+	AscSetBank(iop_base, 0);
+	return sc;
+}
 
-	/*
-	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
-	 */
-	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
-		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-		return ADV_ERROR;
+static unsigned char __devinit
+AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
+{
+	if (bus_type & ASC_IS_EISA) {
+		PortAddr eisa_iop;
+		unsigned char revision;
+		eisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
+		    (PortAddr) ASC_EISA_REV_IOP_MASK;
+		revision = inp(eisa_iop);
+		return ASC_CHIP_MIN_VER_EISA - 1 + revision;
 	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+	return AscGetChipVerNo(iop_base);
+}
 
-	/*
-	 * The first command completed by the RISC will be placed in
-	 * the stopper.
-	 *
-	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-	 * completed the RISC will set the ASC_RQ_STOPPER bit.
-	 */
-	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+static void __devinit AscToggleIRQAct(PortAddr iop_base)
+{
+	AscSetChipStatus(iop_base, CIW_IRQ_ACT);
+	AscSetChipStatus(iop_base, 0);
+	return;
+}
 
-	/*
-	 * Set RISC IRQ physical address start value.
-	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
-	asc_dvc->carr_pending_cnt = 0;
+static uchar __devinit AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
+{
+	ushort cfg_lsw;
+	uchar chip_irq;
 
-	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
-			     (ADV_INTR_ENABLE_HOST_INTR |
-			      ADV_INTR_ENABLE_GLOBAL_INTR));
-	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
-	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+	if ((bus_type & ASC_IS_EISA) != 0) {
+		cfg_lsw = AscGetEisaChipCfg(iop_base);
+		chip_irq = (uchar)(((cfg_lsw >> 8) & 0x07) + 10);
+		if ((chip_irq == 13) || (chip_irq > 15)) {
+			return (0);
+		}
+		return (chip_irq);
+	}
+	if ((bus_type & ASC_IS_VL) != 0) {
+		cfg_lsw = AscGetChipCfgLsw(iop_base);
+		chip_irq = (uchar)(((cfg_lsw >> 2) & 0x07));
+		if ((chip_irq == 0) || (chip_irq == 4) || (chip_irq == 7)) {
+			return (0);
+		}
+		return ((uchar)(chip_irq + (ASC_MIN_IRQ_NO - 1)));
+	}
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
+	chip_irq = (uchar)(((cfg_lsw >> 2) & 0x03));
+	if (chip_irq == 3)
+		chip_irq += (uchar)2;
+	return ((uchar)(chip_irq + ASC_MIN_IRQ_NO));
+}
 
-	/* finally, finally, gentlemen, start your engine */
-	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+static uchar __devinit
+AscSetChipIRQ(PortAddr iop_base, uchar irq_no, ushort bus_type)
+{
+	ushort cfg_lsw;
 
-	/*
-	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
-	 * Resets should be performed. The RISC has to be running
-	 * to issue a SCSI Bus Reset.
-	 */
-	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
-		/*
-		 * If the BIOS Signature is present in memory, restore the
-		 * per TID microcode operating variables.
-		 */
-		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
-		    0x55AA) {
-			/*
-			 * Restore per TID negotiated values.
-			 */
-			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
-					 tagqng_able);
-			for (tid = 0; tid <= ASC_MAX_TID; tid++) {
-				AdvWriteByteLram(iop_base,
-						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
-						 max_cmd[tid]);
-			}
-		} else {
-			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
-				warn_code = ASC_WARN_BUSRESET_ERROR;
+	if ((bus_type & ASC_IS_VL) != 0) {
+		if (irq_no != 0) {
+			if ((irq_no < ASC_MIN_IRQ_NO)
+			    || (irq_no > ASC_MAX_IRQ_NO)) {
+				irq_no = 0;
+			} else {
+				irq_no -= (uchar)((ASC_MIN_IRQ_NO - 1));
 			}
 		}
+		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE3);
+		cfg_lsw |= (ushort)0x0010;
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		AscToggleIRQAct(iop_base);
+		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE0);
+		cfg_lsw |= (ushort)((irq_no & 0x07) << 2);
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		AscToggleIRQAct(iop_base);
+		return (AscGetChipIRQ(iop_base, bus_type));
+	}
+	if ((bus_type & (ASC_IS_ISA)) != 0) {
+		if (irq_no == 15)
+			irq_no -= (uchar)2;
+		irq_no -= (uchar)ASC_MIN_IRQ_NO;
+		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFF3);
+		cfg_lsw |= (ushort)((irq_no & 0x03) << 2);
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		return (AscGetChipIRQ(iop_base, bus_type));
 	}
+	return (0);
+}
 
-	return warn_code;
+#ifdef CONFIG_ISA
+static void __devinit AscEnableIsaDma(uchar dma_channel)
+{
+	if (dma_channel < 4) {
+		outp(0x000B, (ushort)(0xC0 | dma_channel));
+		outp(0x000A, dma_channel);
+	} else if (dma_channel < 8) {
+		outp(0x00D6, (ushort)(0xC0 | (dma_channel - 4)));
+		outp(0x00D4, (ushort)(dma_channel - 4));
+	}
+	return;
+}
+#endif /* CONFIG_ISA */
+
+static int AscStopQueueExe(PortAddr iop_base)
+{
+	int count = 0;
+
+	if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {
+		AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
+				 ASC_STOP_REQ_RISC_STOP);
+		do {
+			if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &
+			    ASC_STOP_ACK_RISC_STOP) {
+				return (1);
+			}
+			mdelay(100);
+		} while (count++ < 20);
+	}
+	return (0);
+}
+
+static ASC_DCNT __devinit AscGetMaxDmaCount(ushort bus_type)
+{
+	if (bus_type & ASC_IS_ISA)
+		return ASC_MAX_ISA_DMA_COUNT;
+	else if (bus_type & (ASC_IS_EISA | ASC_IS_VL))
+		return ASC_MAX_VL_DMA_COUNT;
+	return ASC_MAX_PCI_DMA_COUNT;
 }
 
-/*
- * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
- * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
- * all of this is done.
- *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
- *
- * Note: Chip is stopped on entry.
- */
-static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
+#ifdef CONFIG_ISA
+static ushort __devinit AscGetIsaDmaChannel(PortAddr iop_base)
 {
-	AdvPortAddr iop_base;
-	ushort warn_code;
-	ADVEEP_3550_CONFIG eep_config;
+	ushort channel;
 
-	iop_base = asc_dvc->iop_base;
+	channel = AscGetChipCfgLsw(iop_base) & 0x0003;
+	if (channel == 0x03)
+		return (0);
+	else if (channel == 0x00)
+		return (7);
+	return (channel + 4);
+}
 
-	warn_code = 0;
+static ushort __devinit AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
+{
+	ushort cfg_lsw;
+	uchar value;
 
-	/*
-	 * Read the board's EEPROM configuration.
-	 *
-	 * Set default values if a bad checksum is found.
-	 */
-	if (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum) {
-		warn_code |= ASC_WARN_EEPROM_CHKSUM;
+	if ((dma_channel >= 5) && (dma_channel <= 7)) {
+		if (dma_channel == 7)
+			value = 0x00;
+		else
+			value = dma_channel - 4;
+		cfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;
+		cfg_lsw |= value;
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		return (AscGetIsaDmaChannel(iop_base));
+	}
+	return 0;
+}
 
-		/*
-		 * Set EEPROM default values.
-		 */
-		memcpy(&eep_config, &Default_3550_EEPROM_Config,
-			sizeof(ADVEEP_3550_CONFIG));
+static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
+{
+	uchar speed_value;
 
-		/*
-		 * Assume the 6 byte board serial number that was read from
-		 * EEPROM is correct even if the EEPROM checksum failed.
-		 */
-		eep_config.serial_number_word3 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
+	AscSetBank(iop_base, 1);
+	speed_value = AscReadChipDmaSpeed(iop_base);
+	speed_value &= 0x07;
+	AscSetBank(iop_base, 0);
+	return speed_value;
+}
 
-		eep_config.serial_number_word2 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
+static uchar __devinit AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
+{
+	speed_value &= 0x07;
+	AscSetBank(iop_base, 1);
+	AscWriteChipDmaSpeed(iop_base, speed_value);
+	AscSetBank(iop_base, 0);
+	return AscGetIsaDmaSpeed(iop_base);
+}
+#endif /* CONFIG_ISA */
 
-		eep_config.serial_number_word1 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
+{
+	int i;
+	PortAddr iop_base;
+	ushort warn_code;
+	uchar chip_version;
 
-		AdvSet3550EEPConfig(iop_base, &eep_config);
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	asc_dvc->err_code = 0;
+	if ((asc_dvc->bus_type &
+	     (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {
+		asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;
 	}
-	/*
-	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
-	 * EEPROM configuration that was read.
-	 *
-	 * This is the mapping of EEPROM fields to Adv Library fields.
-	 */
-	asc_dvc->wdtr_able = eep_config.wdtr_able;
-	asc_dvc->sdtr_able = eep_config.sdtr_able;
-	asc_dvc->ultra_able = eep_config.ultra_able;
-	asc_dvc->tagqng_able = eep_config.tagqng_able;
-	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
-	asc_dvc->max_host_qng = eep_config.max_host_qng;
-	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
-	asc_dvc->start_motor = eep_config.start_motor;
-	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
-	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
-	asc_dvc->no_scam = eep_config.scam_tolerant;
-	asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
-	asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
-	asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
-
-	/*
-	 * Set the host maximum queuing (max. 253, min. 16) and the per device
-	 * maximum queuing (max. 63, min. 4).
-	 */
-	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
-		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
-		/* If the value is zero, assume it is uninitialized. */
-		if (eep_config.max_host_qng == 0) {
-			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-		} else {
-			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+	AscSetChipControl(iop_base, CC_HALT);
+	AscSetChipStatus(iop_base, 0);
+	asc_dvc->bug_fix_cntl = 0;
+	asc_dvc->pci_fix_asyn_xfer = 0;
+	asc_dvc->pci_fix_asyn_xfer_always = 0;
+	/* asc_dvc->init_state initalized in AscInitGetConfig(). */
+	asc_dvc->sdtr_done = 0;
+	asc_dvc->cur_total_qng = 0;
+	asc_dvc->is_in_int = 0;
+	asc_dvc->in_critical_cnt = 0;
+	asc_dvc->last_q_shortage = 0;
+	asc_dvc->use_tagged_qng = 0;
+	asc_dvc->no_scam = 0;
+	asc_dvc->unit_not_ready = 0;
+	asc_dvc->queue_full_or_busy = 0;
+	asc_dvc->redo_scam = 0;
+	asc_dvc->res2 = 0;
+	asc_dvc->host_init_sdtr_index = 0;
+	asc_dvc->cfg->can_tagged_qng = 0;
+	asc_dvc->cfg->cmd_qng_enabled = 0;
+	asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;
+	asc_dvc->init_sdtr = 0;
+	asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;
+	asc_dvc->scsi_reset_wait = 3;
+	asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;
+	asc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);
+	asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;
+	asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;
+	asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
+	asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER;
+	asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
+	    ASC_LIB_VERSION_MINOR;
+	chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
+	asc_dvc->cfg->chip_version = chip_version;
+	asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
+	asc_dvc->sdtr_period_tbl[1] = SYN_XFER_NS_1;
+	asc_dvc->sdtr_period_tbl[2] = SYN_XFER_NS_2;
+	asc_dvc->sdtr_period_tbl[3] = SYN_XFER_NS_3;
+	asc_dvc->sdtr_period_tbl[4] = SYN_XFER_NS_4;
+	asc_dvc->sdtr_period_tbl[5] = SYN_XFER_NS_5;
+	asc_dvc->sdtr_period_tbl[6] = SYN_XFER_NS_6;
+	asc_dvc->sdtr_period_tbl[7] = SYN_XFER_NS_7;
+	asc_dvc->max_sdtr_index = 7;
+	if ((asc_dvc->bus_type & ASC_IS_PCI) &&
+	    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {
+		asc_dvc->bus_type = ASC_IS_PCI_ULTRA;
+		asc_dvc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;
+		asc_dvc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;
+		asc_dvc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;
+		asc_dvc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;
+		asc_dvc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;
+		asc_dvc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;
+		asc_dvc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;
+		asc_dvc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;
+		asc_dvc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;
+		asc_dvc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;
+		asc_dvc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;
+		asc_dvc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;
+		asc_dvc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;
+		asc_dvc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;
+		asc_dvc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;
+		asc_dvc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;
+		asc_dvc->max_sdtr_index = 15;
+		if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {
+			AscSetExtraControl(iop_base,
+					   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
+		} else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {
+			AscSetExtraControl(iop_base,
+					   (SEC_ACTIVE_NEGATE |
+					    SEC_ENABLE_FILTER));
 		}
 	}
+	if (asc_dvc->bus_type == ASC_IS_PCI) {
+		AscSetExtraControl(iop_base,
+				   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
+	}
 
-	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
-		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
-		/* If the value is zero, assume it is uninitialized. */
-		if (eep_config.max_dvc_qng == 0) {
-			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-		} else {
-			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+	asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;
+#ifdef CONFIG_ISA
+	if ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {
+		if (chip_version >= ASC_CHIP_MIN_VER_ISA_PNP) {
+			AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
+			asc_dvc->bus_type = ASC_IS_ISAPNP;
 		}
+		asc_dvc->cfg->isa_dma_channel =
+		    (uchar)AscGetIsaDmaChannel(iop_base);
 	}
-
-	/*
-	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
-	 * set 'max_dvc_qng' to 'max_host_qng'.
-	 */
-	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
-		eep_config.max_dvc_qng = eep_config.max_host_qng;
+#endif /* CONFIG_ISA */
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		asc_dvc->cur_dvc_qng[i] = 0;
+		asc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;
+		asc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *)0L;
+		asc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;
+		asc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;
 	}
+	return warn_code;
+}
 
-	/*
-	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
-	 * values based on possibly adjusted EEPROM values.
-	 */
-	asc_dvc->max_host_qng = eep_config.max_host_qng;
-	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-
-	/*
-	 * If the EEPROM 'termination' field is set to automatic (0), then set
-	 * the ADV_DVC_CFG 'termination' field to automatic also.
-	 *
-	 * If the termination is specified with a non-zero 'termination'
-	 * value check that a legal value is set and set the ADV_DVC_CFG
-	 * 'termination' field appropriately.
-	 */
-	if (eep_config.termination == 0) {
-		asc_dvc->cfg->termination = 0;	/* auto termination */
-	} else {
-		/* Enable manual control with low off / high off. */
-		if (eep_config.termination == 1) {
-			asc_dvc->cfg->termination = TERM_CTL_SEL;
-
-			/* Enable manual control with low off / high on. */
-		} else if (eep_config.termination == 2) {
-			asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;
+static int __devinit AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
+{
+	int retry;
 
-			/* Enable manual control with low on / high on. */
-		} else if (eep_config.termination == 3) {
-			asc_dvc->cfg->termination =
-			    TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
-		} else {
-			/*
-			 * The EEPROM 'termination' field contains a bad value. Use
-			 * automatic termination instead.
-			 */
-			asc_dvc->cfg->termination = 0;
-			warn_code |= ASC_WARN_EEPROM_TERMINATION;
-		}
+	for (retry = 0; retry < ASC_EEP_MAX_RETRY; retry++) {
+		unsigned char read_back;
+		AscSetChipEEPCmd(iop_base, cmd_reg);
+		mdelay(1);
+		read_back = AscGetChipEEPCmd(iop_base);
+		if (read_back == cmd_reg)
+			return 1;
 	}
+	return 0;
+}
 
-	return warn_code;
+static void __devinit AscWaitEEPRead(void)
+{
+	mdelay(1);
 }
 
-/*
- * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
- * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
- * all of this is done.
- *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
- *
- * Note: Chip is stopped on entry.
- */
-static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
+static ushort __devinit AscReadEEPWord(PortAddr iop_base, uchar addr)
 {
-	AdvPortAddr iop_base;
-	ushort warn_code;
-	ADVEEP_38C0800_CONFIG eep_config;
-	uchar tid, termination;
-	ushort sdtr_speed = 0;
+	ushort read_wval;
+	uchar cmd_reg;
 
-	iop_base = asc_dvc->iop_base;
+	AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
+	AscWaitEEPRead();
+	cmd_reg = addr | ASC_EEP_CMD_READ;
+	AscWriteEEPCmdReg(iop_base, cmd_reg);
+	AscWaitEEPRead();
+	read_wval = AscGetChipEEPData(iop_base);
+	AscWaitEEPRead();
+	return read_wval;
+}
 
-	warn_code = 0;
+static ushort __devinit
+AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
+{
+	ushort wval;
+	ushort sum;
+	ushort *wbuf;
+	int cfg_beg;
+	int cfg_end;
+	int uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
+	int s_addr;
 
+	wbuf = (ushort *)cfg_buf;
+	sum = 0;
+	/* Read two config words; Byte-swapping done by AscReadEEPWord(). */
+	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+		*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);
+		sum += *wbuf;
+	}
+	if (bus_type & ASC_IS_VL) {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+	} else {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR;
+	}
+	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+		wval = AscReadEEPWord(iop_base, (uchar)s_addr);
+		if (s_addr <= uchar_end_in_config) {
+			/*
+			 * Swap all char fields - must unswap bytes already swapped
+			 * by AscReadEEPWord().
+			 */
+			*wbuf = le16_to_cpu(wval);
+		} else {
+			/* Don't swap word field at the end - cntl field. */
+			*wbuf = wval;
+		}
+		sum += wval;	/* Checksum treats all EEPROM data as words. */
+	}
 	/*
-	 * Read the board's EEPROM configuration.
-	 *
-	 * Set default values if a bad checksum is found.
+	 * Read the checksum word which will be compared against 'sum'
+	 * by the caller. Word field already swapped.
 	 */
-	if (AdvGet38C0800EEPConfig(iop_base, &eep_config) !=
-	    eep_config.check_sum) {
-		warn_code |= ASC_WARN_EEPROM_CHKSUM;
+	*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);
+	return sum;
+}
 
-		/*
-		 * Set EEPROM default values.
-		 */
-		memcpy(&eep_config, &Default_38C0800_EEPROM_Config,
-			sizeof(ADVEEP_38C0800_CONFIG));
+static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
+{
+	PortAddr iop_base;
+	ushort q_addr;
+	ushort saved_word;
+	int sta;
 
-		/*
-		 * Assume the 6 byte board serial number that was read from
-		 * EEPROM is correct even if the EEPROM checksum failed.
-		 */
-		eep_config.serial_number_word3 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
+	iop_base = asc_dvc->iop_base;
+	sta = 0;
+	q_addr = ASC_QNO_TO_QADDR(241);
+	saved_word = AscReadLramWord(iop_base, q_addr);
+	AscSetChipLramAddr(iop_base, q_addr);
+	AscSetChipLramData(iop_base, 0x55AA);
+	mdelay(10);
+	AscSetChipLramAddr(iop_base, q_addr);
+	if (AscGetChipLramData(iop_base) == 0x55AA) {
+		sta = 1;
+		AscWriteLramWord(iop_base, q_addr, saved_word);
+	}
+	return (sta);
+}
 
-		eep_config.serial_number_word2 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
+static void __devinit AscWaitEEPWrite(void)
+{
+	mdelay(20);
+	return;
+}
 
-		eep_config.serial_number_word1 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
+{
+	ushort read_back;
+	int retry;
 
-		AdvSet38C0800EEPConfig(iop_base, &eep_config);
+	retry = 0;
+	while (TRUE) {
+		AscSetChipEEPData(iop_base, data_reg);
+		mdelay(1);
+		read_back = AscGetChipEEPData(iop_base);
+		if (read_back == data_reg) {
+			return (1);
+		}
+		if (retry++ > ASC_EEP_MAX_RETRY) {
+			return (0);
+		}
 	}
-	/*
-	 * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the
-	 * EEPROM configuration that was read.
-	 *
-	 * This is the mapping of EEPROM fields to Adv Library fields.
-	 */
-	asc_dvc->wdtr_able = eep_config.wdtr_able;
-	asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
-	asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
-	asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
-	asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
-	asc_dvc->tagqng_able = eep_config.tagqng_able;
-	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
-	asc_dvc->max_host_qng = eep_config.max_host_qng;
-	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
-	asc_dvc->start_motor = eep_config.start_motor;
-	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
-	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
-	asc_dvc->no_scam = eep_config.scam_tolerant;
-	asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
-	asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
-	asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
+}
 
-	/*
-	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
-	 * are set, then set an 'sdtr_able' bit for it.
-	 */
-	asc_dvc->sdtr_able = 0;
-	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-		if (tid == 0) {
-			sdtr_speed = asc_dvc->sdtr_speed1;
-		} else if (tid == 4) {
-			sdtr_speed = asc_dvc->sdtr_speed2;
-		} else if (tid == 8) {
-			sdtr_speed = asc_dvc->sdtr_speed3;
-		} else if (tid == 12) {
-			sdtr_speed = asc_dvc->sdtr_speed4;
+static ushort __devinit
+AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
+{
+	ushort read_wval;
+
+	read_wval = AscReadEEPWord(iop_base, addr);
+	if (read_wval != word_val) {
+		AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);
+		AscWaitEEPRead();
+		AscWriteEEPDataReg(iop_base, word_val);
+		AscWaitEEPRead();
+		AscWriteEEPCmdReg(iop_base,
+				  (uchar)((uchar)ASC_EEP_CMD_WRITE | addr));
+		AscWaitEEPWrite();
+		AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
+		AscWaitEEPRead();
+		return (AscReadEEPWord(iop_base, addr));
+	}
+	return (read_wval);
+}
+
+static int __devinit
+AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
+{
+	int n_error;
+	ushort *wbuf;
+	ushort word;
+	ushort sum;
+	int s_addr;
+	int cfg_beg;
+	int cfg_end;
+	int uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
+
+	wbuf = (ushort *)cfg_buf;
+	n_error = 0;
+	sum = 0;
+	/* Write two config words; AscWriteEEPWord() will swap bytes. */
+	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+		sum += *wbuf;
+		if (*wbuf != AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {
+			n_error++;
 		}
-		if (sdtr_speed & ADV_MAX_TID) {
-			asc_dvc->sdtr_able |= (1 << tid);
+	}
+	if (bus_type & ASC_IS_VL) {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+	} else {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR;
+	}
+	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+		if (s_addr <= uchar_end_in_config) {
+			/*
+			 * This is a char field. Swap char fields before they are
+			 * swapped again by AscWriteEEPWord().
+			 */
+			word = cpu_to_le16(*wbuf);
+			if (word !=
+			    AscWriteEEPWord(iop_base, (uchar)s_addr, word)) {
+				n_error++;
+			}
+		} else {
+			/* Don't swap word field at the end - cntl field. */
+			if (*wbuf !=
+			    AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {
+				n_error++;
+			}
 		}
-		sdtr_speed >>= 4;
+		sum += *wbuf;	/* Checksum calculated from word values. */
+	}
+	/* Write checksum word. It will be swapped by AscWriteEEPWord(). */
+	*wbuf = sum;
+	if (sum != AscWriteEEPWord(iop_base, (uchar)s_addr, sum)) {
+		n_error++;
 	}
 
+	/* Read EEPROM back again. */
+	wbuf = (ushort *)cfg_buf;
 	/*
-	 * Set the host maximum queuing (max. 253, min. 16) and the per device
-	 * maximum queuing (max. 63, min. 4).
+	 * Read two config words; Byte-swapping done by AscReadEEPWord().
 	 */
-	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
-		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
-		/* If the value is zero, assume it is uninitialized. */
-		if (eep_config.max_host_qng == 0) {
-			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-		} else {
-			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+		if (*wbuf != AscReadEEPWord(iop_base, (uchar)s_addr)) {
+			n_error++;
 		}
 	}
-
-	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
-		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
-		/* If the value is zero, assume it is uninitialized. */
-		if (eep_config.max_dvc_qng == 0) {
-			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	if (bus_type & ASC_IS_VL) {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+	} else {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR;
+	}
+	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+		if (s_addr <= uchar_end_in_config) {
+			/*
+			 * Swap all char fields. Must unswap bytes already swapped
+			 * by AscReadEEPWord().
+			 */
+			word =
+			    le16_to_cpu(AscReadEEPWord
+					(iop_base, (uchar)s_addr));
 		} else {
-			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+			/* Don't swap word field at the end - cntl field. */
+			word = AscReadEEPWord(iop_base, (uchar)s_addr);
+		}
+		if (*wbuf != word) {
+			n_error++;
 		}
 	}
-
-	/*
-	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
-	 * set 'max_dvc_qng' to 'max_host_qng'.
-	 */
-	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
-		eep_config.max_dvc_qng = eep_config.max_host_qng;
+	/* Read checksum; Byte swapping not needed. */
+	if (AscReadEEPWord(iop_base, (uchar)s_addr) != sum) {
+		n_error++;
 	}
+	return n_error;
+}
 
-	/*
-	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
-	 * values based on possibly adjusted EEPROM values.
-	 */
-	asc_dvc->max_host_qng = eep_config.max_host_qng;
-	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+static int __devinit
+AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
+{
+	int retry;
+	int n_error;
 
-	/*
-	 * If the EEPROM 'termination' field is set to automatic (0), then set
-	 * the ADV_DVC_CFG 'termination' field to automatic also.
-	 *
-	 * If the termination is specified with a non-zero 'termination'
-	 * value check that a legal value is set and set the ADV_DVC_CFG
-	 * 'termination' field appropriately.
-	 */
-	if (eep_config.termination_se == 0) {
-		termination = 0;	/* auto termination for SE */
-	} else {
-		/* Enable manual control with low off / high off. */
-		if (eep_config.termination_se == 1) {
-			termination = 0;
+	retry = 0;
+	while (TRUE) {
+		if ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,
+						   bus_type)) == 0) {
+			break;
+		}
+		if (++retry > ASC_EEP_MAX_RETRY) {
+			break;
+		}
+	}
+	return n_error;
+}
 
-			/* Enable manual control with low off / high on. */
-		} else if (eep_config.termination_se == 2) {
-			termination = TERM_SE_HI;
+static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
+{
+	ASCEEP_CONFIG eep_config_buf;
+	ASCEEP_CONFIG *eep_config;
+	PortAddr iop_base;
+	ushort chksum;
+	ushort warn_code;
+	ushort cfg_msw, cfg_lsw;
+	int i;
+	int write_eep = 0;
 
-			/* Enable manual control with low on / high on. */
-		} else if (eep_config.termination_se == 3) {
-			termination = TERM_SE;
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);
+	AscStopQueueExe(iop_base);
+	if ((AscStopChip(iop_base) == FALSE) ||
+	    (AscGetChipScsiCtrl(iop_base) != 0)) {
+		asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
+		AscResetChipAndScsiBus(asc_dvc);
+		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
+	}
+	if (AscIsChipHalted(iop_base) == FALSE) {
+		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
+		return (warn_code);
+	}
+	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
+	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
+		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
+		return (warn_code);
+	}
+	eep_config = (ASCEEP_CONFIG *)&eep_config_buf;
+	cfg_msw = AscGetChipCfgMsw(iop_base);
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
+	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
+		cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
+		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
+		AscSetChipCfgMsw(iop_base, cfg_msw);
+	}
+	chksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);
+	ASC_DBG1(1, "AscInitFromEEP: chksum 0x%x\n", chksum);
+	if (chksum == 0) {
+		chksum = 0xaa55;
+	}
+	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
+		warn_code |= ASC_WARN_AUTO_CONFIG;
+		if (asc_dvc->cfg->chip_version == 3) {
+			if (eep_config->cfg_lsw != cfg_lsw) {
+				warn_code |= ASC_WARN_EEPROM_RECOVER;
+				eep_config->cfg_lsw =
+				    AscGetChipCfgLsw(iop_base);
+			}
+			if (eep_config->cfg_msw != cfg_msw) {
+				warn_code |= ASC_WARN_EEPROM_RECOVER;
+				eep_config->cfg_msw =
+				    AscGetChipCfgMsw(iop_base);
+			}
+		}
+	}
+	eep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
+	eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;
+	ASC_DBG1(1, "AscInitFromEEP: eep_config->chksum 0x%x\n",
+		 eep_config->chksum);
+	if (chksum != eep_config->chksum) {
+		if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
+		    ASC_CHIP_VER_PCI_ULTRA_3050) {
+			ASC_DBG(1,
+				"AscInitFromEEP: chksum error ignored; EEPROM-less board\n");
+			eep_config->init_sdtr = 0xFF;
+			eep_config->disc_enable = 0xFF;
+			eep_config->start_motor = 0xFF;
+			eep_config->use_cmd_qng = 0;
+			eep_config->max_total_qng = 0xF0;
+			eep_config->max_tag_qng = 0x20;
+			eep_config->cntl = 0xBFFF;
+			ASC_EEP_SET_CHIP_ID(eep_config, 7);
+			eep_config->no_scam = 0;
+			eep_config->adapter_info[0] = 0;
+			eep_config->adapter_info[1] = 0;
+			eep_config->adapter_info[2] = 0;
+			eep_config->adapter_info[3] = 0;
+			eep_config->adapter_info[4] = 0;
+			/* Indicate EEPROM-less board. */
+			eep_config->adapter_info[5] = 0xBB;
 		} else {
-			/*
-			 * The EEPROM 'termination_se' field contains a bad value.
-			 * Use automatic termination instead.
-			 */
-			termination = 0;
-			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+			ASC_PRINT
+			    ("AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\n");
+			write_eep = 1;
+			warn_code |= ASC_WARN_EEPROM_CHKSUM;
+		}
+	}
+	asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;
+	asc_dvc->cfg->disc_enable = eep_config->disc_enable;
+	asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;
+	asc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);
+	asc_dvc->start_motor = eep_config->start_motor;
+	asc_dvc->dvc_cntl = eep_config->cntl;
+	asc_dvc->no_scam = eep_config->no_scam;
+	asc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];
+	asc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];
+	asc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];
+	asc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];
+	asc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];
+	asc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];
+	if (!AscTestExternalLram(asc_dvc)) {
+		if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) ==
+		     ASC_IS_PCI_ULTRA)) {
+			eep_config->max_total_qng =
+			    ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;
+			eep_config->max_tag_qng =
+			    ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;
+		} else {
+			eep_config->cfg_msw |= 0x0800;
+			cfg_msw |= 0x0800;
+			AscSetChipCfgMsw(iop_base, cfg_msw);
+			eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;
+			eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;
 		}
+	} else {
+	}
+	if (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {
+		eep_config->max_total_qng = ASC_MIN_TOTAL_QNG;
+	}
+	if (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {
+		eep_config->max_total_qng = ASC_MAX_TOTAL_QNG;
+	}
+	if (eep_config->max_tag_qng > eep_config->max_total_qng) {
+		eep_config->max_tag_qng = eep_config->max_total_qng;
+	}
+	if (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {
+		eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;
+	}
+	asc_dvc->max_total_qng = eep_config->max_total_qng;
+	if ((eep_config->use_cmd_qng & eep_config->disc_enable) !=
+	    eep_config->use_cmd_qng) {
+		eep_config->disc_enable = eep_config->use_cmd_qng;
+		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
+	}
+	if (asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA)) {
+		asc_dvc->irq_no = AscGetChipIRQ(iop_base, asc_dvc->bus_type);
+	}
+	ASC_EEP_SET_CHIP_ID(eep_config,
+			    ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);
+	asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
+	if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&
+	    !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {
+		asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
 	}
 
-	if (eep_config.termination_lvd == 0) {
-		asc_dvc->cfg->termination = termination;	/* auto termination for LVD */
-	} else {
-		/* Enable manual control with low off / high off. */
-		if (eep_config.termination_lvd == 1) {
-			asc_dvc->cfg->termination = termination;
-
-			/* Enable manual control with low off / high on. */
-		} else if (eep_config.termination_lvd == 2) {
-			asc_dvc->cfg->termination = termination | TERM_LVD_HI;
-
-			/* Enable manual control with low on / high on. */
-		} else if (eep_config.termination_lvd == 3) {
-			asc_dvc->cfg->termination = termination | TERM_LVD;
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		asc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];
+		asc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;
+		asc_dvc->cfg->sdtr_period_offset[i] =
+		    (uchar)(ASC_DEF_SDTR_OFFSET |
+			    (asc_dvc->host_init_sdtr_index << 4));
+	}
+	eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
+	if (write_eep) {
+		if ((i = AscSetEEPConfig(iop_base, eep_config,
+				     asc_dvc->bus_type)) != 0) {
+			ASC_PRINT1
+			    ("AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n",
+			     i);
 		} else {
-			/*
-			 * The EEPROM 'termination_lvd' field contains a bad value.
-			 * Use automatic termination instead.
-			 */
-			asc_dvc->cfg->termination = termination;
-			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+			ASC_PRINT
+			    ("AscInitFromEEP: Successfully re-wrote EEPROM.\n");
 		}
 	}
-
-	return warn_code;
+	return (warn_code);
 }
 
-/*
- * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and
- * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
- * all of this is done.
- *
- * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
- *
- * Note: Chip is stopped on entry.
- */
-static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
+static int __devinit AscInitGetConfig(asc_board_t *boardp)
 {
-	AdvPortAddr iop_base;
-	ushort warn_code;
-	ADVEEP_38C1600_CONFIG eep_config;
-	uchar tid, termination;
-	ushort sdtr_speed = 0;
+	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
+	unsigned short warn_code = 0;
 
-	iop_base = asc_dvc->iop_base;
+	asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
+	if (asc_dvc->err_code != 0)
+		return asc_dvc->err_code;
 
-	warn_code = 0;
+	if (AscFindSignature(asc_dvc->iop_base)) {
+		warn_code |= AscInitAscDvcVar(asc_dvc);
+		warn_code |= AscInitFromEEP(asc_dvc);
+		asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
+		if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)
+			asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
+	} else {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+	}
 
-	/*
-	 * Read the board's EEPROM configuration.
-	 *
-	 * Set default values if a bad checksum is found.
-	 */
-	if (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=
-	    eep_config.check_sum) {
-		struct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);
-		warn_code |= ASC_WARN_EEPROM_CHKSUM;
+	switch (warn_code) {
+	case 0:	/* No error */
+		break;
+	case ASC_WARN_IO_PORT_ROTATE:
+		ASC_PRINT1("AscInitGetConfig: board %d: I/O port address "
+			   "modified\n", boardp->id);
+		break;
+	case ASC_WARN_AUTO_CONFIG:
+		ASC_PRINT1("AscInitGetConfig: board %d: I/O port increment "
+			   "switch enabled\n", boardp->id);
+		break;
+	case ASC_WARN_EEPROM_CHKSUM:
+		ASC_PRINT1("AscInitGetConfig: board %d: EEPROM checksum "
+			   "error\n", boardp->id);
+		break;
+	case ASC_WARN_IRQ_MODIFIED:
+		ASC_PRINT1("AscInitGetConfig: board %d: IRQ modified\n",
+			   boardp->id);
+		break;
+	case ASC_WARN_CMD_QNG_CONFLICT:
+		ASC_PRINT1("AscInitGetConfig: board %d: tag queuing enabled "
+			   "w/o disconnects\n", boardp->id);
+		break;
+	default:
+		ASC_PRINT2("AscInitGetConfig: board %d: unknown warning: "
+			   "0x%x\n", boardp->id, warn_code);
+		break;
+	}
 
-		/*
-		 * Set EEPROM default values.
-		 */
-		memcpy(&eep_config, &Default_38C1600_EEPROM_Config,
-			sizeof(ADVEEP_38C1600_CONFIG));
+	if (asc_dvc->err_code != 0) {
+		ASC_PRINT3("AscInitGetConfig: board %d error: init_state 0x%x, "
+			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
+			   asc_dvc->err_code);
+	}
 
-		if (PCI_FUNC(pdev->devfn) != 0) {
-			u8 ints;
-			/*
-			 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60
-			 * and old Mac system booting problem. The Expansion
-			 * ROM must be disabled in Function 1 for these systems
-			 */
-			eep_config.cfg_lsw &= ~ADV_EEPROM_BIOS_ENABLE;
-			/*
-			 * Clear the INTAB (bit 11) if the GPIO 0 input
-			 * indicates the Function 1 interrupt line is wired
-			 * to INTB.
-			 *
-			 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
-			 *   1 - Function 1 interrupt line wired to INT A.
-			 *   0 - Function 1 interrupt line wired to INT B.
-			 *
-			 * Note: Function 0 is always wired to INTA.
-			 * Put all 5 GPIO bits in input mode and then read
-			 * their input values.
-			 */
-			AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);
-			ints = AdvReadByteRegister(iop_base, IOPB_GPIO_DATA);
-			if ((ints & 0x01) == 0)
-				eep_config.cfg_lsw &= ~ADV_EEPROM_INTAB;
-		}
+	return asc_dvc->err_code;
+}
 
-		/*
-		 * Assume the 6 byte board serial number that was read from
-		 * EEPROM is correct even if the EEPROM checksum failed.
-		 */
-		eep_config.serial_number_word3 =
-			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
-		eep_config.serial_number_word2 =
-			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
-		eep_config.serial_number_word1 =
-			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+static int __devinit AscInitSetConfig(struct pci_dev *pdev, asc_board_t *boardp)
+{
+	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
+	PortAddr iop_base = asc_dvc->iop_base;
+	unsigned short cfg_msw;
+	unsigned short warn_code = 0;
 
-		AdvSet38C1600EEPConfig(iop_base, &eep_config);
+	asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
+	if (asc_dvc->err_code != 0)
+		return asc_dvc->err_code;
+	if (!AscFindSignature(asc_dvc->iop_base)) {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+		return asc_dvc->err_code;
 	}
 
-	/*
-	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
-	 * EEPROM configuration that was read.
-	 *
-	 * This is the mapping of EEPROM fields to Adv Library fields.
-	 */
-	asc_dvc->wdtr_able = eep_config.wdtr_able;
-	asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
-	asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
-	asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
-	asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
-	asc_dvc->ppr_able = 0;
-	asc_dvc->tagqng_able = eep_config.tagqng_able;
-	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
-	asc_dvc->max_host_qng = eep_config.max_host_qng;
-	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
-	asc_dvc->start_motor = eep_config.start_motor;
-	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
-	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
-	asc_dvc->no_scam = eep_config.scam_tolerant;
-
-	/*
-	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
-	 * are set, then set an 'sdtr_able' bit for it.
-	 */
-	asc_dvc->sdtr_able = 0;
-	for (tid = 0; tid <= ASC_MAX_TID; tid++) {
-		if (tid == 0) {
-			sdtr_speed = asc_dvc->sdtr_speed1;
-		} else if (tid == 4) {
-			sdtr_speed = asc_dvc->sdtr_speed2;
-		} else if (tid == 8) {
-			sdtr_speed = asc_dvc->sdtr_speed3;
-		} else if (tid == 12) {
-			sdtr_speed = asc_dvc->sdtr_speed4;
-		}
-		if (sdtr_speed & ASC_MAX_TID) {
-			asc_dvc->sdtr_able |= (1 << tid);
+	cfg_msw = AscGetChipCfgMsw(iop_base);
+	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
+		cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
+		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
+		AscSetChipCfgMsw(iop_base, cfg_msw);
+	}
+	if ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=
+	    asc_dvc->cfg->cmd_qng_enabled) {
+		asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;
+		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
+	}
+	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
+		warn_code |= ASC_WARN_AUTO_CONFIG;
+	}
+	if ((asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {
+		if (AscSetChipIRQ(iop_base, asc_dvc->irq_no, asc_dvc->bus_type)
+		    != asc_dvc->irq_no) {
+			asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
 		}
-		sdtr_speed >>= 4;
 	}
-
-	/*
-	 * Set the host maximum queuing (max. 253, min. 16) and the per device
-	 * maximum queuing (max. 63, min. 4).
-	 */
-	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
-		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
-		/* If the value is zero, assume it is uninitialized. */
-		if (eep_config.max_host_qng == 0) {
-			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+#ifdef CONFIG_PCI
+	if (asc_dvc->bus_type & ASC_IS_PCI) {
+		cfg_msw &= 0xFFC0;
+		AscSetChipCfgMsw(iop_base, cfg_msw);
+		if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
 		} else {
-			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+			if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
+			    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
+				asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
+				asc_dvc->bug_fix_cntl |=
+				    ASC_BUG_FIX_ASYN_USE_SYN;
+			}
 		}
-	}
-
-	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
-		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
-		/* If the value is zero, assume it is uninitialized. */
-		if (eep_config.max_dvc_qng == 0) {
-			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-		} else {
-			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+	} else
+#endif /* CONFIG_PCI */
+	if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
+		if (AscGetChipVersion(iop_base, asc_dvc->bus_type)
+		    == ASC_CHIP_VER_ASYN_BUG) {
+			asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
 		}
 	}
+	if (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=
+	    asc_dvc->cfg->chip_scsi_id) {
+		asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;
+	}
+#ifdef CONFIG_ISA
+	if (asc_dvc->bus_type & ASC_IS_ISA) {
+		AscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);
+		AscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);
+	}
+#endif /* CONFIG_ISA */
 
-	/*
-	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
-	 * set 'max_dvc_qng' to 'max_host_qng'.
-	 */
-	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
-		eep_config.max_dvc_qng = eep_config.max_host_qng;
+	asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
+
+	switch (warn_code) {
+	case 0:	/* No error. */
+		break;
+	case ASC_WARN_IO_PORT_ROTATE:
+		ASC_PRINT1("AscInitSetConfig: board %d: I/O port address "
+			   "modified\n", boardp->id);
+		break;
+	case ASC_WARN_AUTO_CONFIG:
+		ASC_PRINT1("AscInitSetConfig: board %d: I/O port increment "
+			   "switch enabled\n", boardp->id);
+		break;
+	case ASC_WARN_EEPROM_CHKSUM:
+		ASC_PRINT1("AscInitSetConfig: board %d: EEPROM checksum "
+			   "error\n", boardp->id);
+		break;
+	case ASC_WARN_IRQ_MODIFIED:
+		ASC_PRINT1("AscInitSetConfig: board %d: IRQ modified\n",
+			   boardp->id);
+		break;
+	case ASC_WARN_CMD_QNG_CONFLICT:
+		ASC_PRINT1("AscInitSetConfig: board %d: tag queuing w/o "
+			   "disconnects\n",
+		     boardp->id);
+		break;
+	default:
+		ASC_PRINT2("AscInitSetConfig: board %d: unknown warning: "
+			   "0x%x\n", boardp->id, warn_code);
+		break;
 	}
 
-	/*
-	 * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'
-	 * values based on possibly adjusted EEPROM values.
-	 */
-	asc_dvc->max_host_qng = eep_config.max_host_qng;
-	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	if (asc_dvc->err_code != 0) {
+		ASC_PRINT3("AscInitSetConfig: board %d error: init_state 0x%x, "
+			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
+			   asc_dvc->err_code);
+	}
 
-	/*
-	 * If the EEPROM 'termination' field is set to automatic (0), then set
-	 * the ASC_DVC_CFG 'termination' field to automatic also.
-	 *
-	 * If the termination is specified with a non-zero 'termination'
-	 * value check that a legal value is set and set the ASC_DVC_CFG
-	 * 'termination' field appropriately.
-	 */
-	if (eep_config.termination_se == 0) {
-		termination = 0;	/* auto termination for SE */
-	} else {
-		/* Enable manual control with low off / high off. */
-		if (eep_config.termination_se == 1) {
-			termination = 0;
+	return asc_dvc->err_code;
+}
 
-			/* Enable manual control with low off / high on. */
-		} else if (eep_config.termination_se == 2) {
-			termination = TERM_SE_HI;
+/*
+ * EEPROM Configuration.
+ *
+ * All drivers should use this structure to set the default EEPROM
+ * configuration. The BIOS now uses this structure when it is built.
+ * Additional structure information can be found in a_condor.h where
+ * the structure is defined.
+ *
+ * The *_Field_IsChar structs are needed to correct for endianness.
+ * These values are read from the board 16 bits at a time directly
+ * into the structs. Because some fields are char, the values will be
+ * in the wrong order. The *_Field_IsChar tells when to flip the
+ * bytes. Data read and written to PCI memory is automatically swapped
+ * on big-endian platforms so char fields read as words are actually being
+ * unswapped on big-endian platforms.
+ */
+static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __devinitdata = {
+	ADV_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
+	0x0000,			/* cfg_msw */
+	0xFFFF,			/* disc_enable */
+	0xFFFF,			/* wdtr_able */
+	0xFFFF,			/* sdtr_able */
+	0xFFFF,			/* start_motor */
+	0xFFFF,			/* tagqng_able */
+	0xFFFF,			/* bios_scan */
+	0,			/* scam_tolerant */
+	7,			/* adapter_scsi_id */
+	0,			/* bios_boot_delay */
+	3,			/* scsi_reset_delay */
+	0,			/* bios_id_lun */
+	0,			/* termination */
+	0,			/* reserved1 */
+	0xFFE7,			/* bios_ctrl */
+	0xFFFF,			/* ultra_able */
+	0,			/* reserved2 */
+	ASC_DEF_MAX_HOST_QNG,	/* max_host_qng */
+	ASC_DEF_MAX_DVC_QNG,	/* max_dvc_qng */
+	0,			/* dvc_cntl */
+	0,			/* bug_fix */
+	0,			/* serial_number_word1 */
+	0,			/* serial_number_word2 */
+	0,			/* serial_number_word3 */
+	0,			/* check_sum */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	,			/* oem_name[16] */
+	0,			/* dvc_err_code */
+	0,			/* adv_err_code */
+	0,			/* adv_err_addr */
+	0,			/* saved_dvc_err_code */
+	0,			/* saved_adv_err_code */
+	0,			/* saved_adv_err_addr */
+	0			/* num_of_err */
+};
 
-			/* Enable manual control with low on / high on. */
-		} else if (eep_config.termination_se == 3) {
-			termination = TERM_SE;
-		} else {
-			/*
-			 * The EEPROM 'termination_se' field contains a bad value.
-			 * Use automatic termination instead.
-			 */
-			termination = 0;
-			warn_code |= ASC_WARN_EEPROM_TERMINATION;
-		}
-	}
+static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __devinitdata = {
+	0,			/* cfg_lsw */
+	0,			/* cfg_msw */
+	0,			/* -disc_enable */
+	0,			/* wdtr_able */
+	0,			/* sdtr_able */
+	0,			/* start_motor */
+	0,			/* tagqng_able */
+	0,			/* bios_scan */
+	0,			/* scam_tolerant */
+	1,			/* adapter_scsi_id */
+	1,			/* bios_boot_delay */
+	1,			/* scsi_reset_delay */
+	1,			/* bios_id_lun */
+	1,			/* termination */
+	1,			/* reserved1 */
+	0,			/* bios_ctrl */
+	0,			/* ultra_able */
+	0,			/* reserved2 */
+	1,			/* max_host_qng */
+	1,			/* max_dvc_qng */
+	0,			/* dvc_cntl */
+	0,			/* bug_fix */
+	0,			/* serial_number_word1 */
+	0,			/* serial_number_word2 */
+	0,			/* serial_number_word3 */
+	0,			/* check_sum */
+	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+	,			/* oem_name[16] */
+	0,			/* dvc_err_code */
+	0,			/* adv_err_code */
+	0,			/* adv_err_addr */
+	0,			/* saved_dvc_err_code */
+	0,			/* saved_adv_err_code */
+	0,			/* saved_adv_err_addr */
+	0			/* num_of_err */
+};
 
-	if (eep_config.termination_lvd == 0) {
-		asc_dvc->cfg->termination = termination;	/* auto termination for LVD */
-	} else {
-		/* Enable manual control with low off / high off. */
-		if (eep_config.termination_lvd == 1) {
-			asc_dvc->cfg->termination = termination;
+static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __devinitdata = {
+	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
+	0x0000,			/* 01 cfg_msw */
+	0xFFFF,			/* 02 disc_enable */
+	0xFFFF,			/* 03 wdtr_able */
+	0x4444,			/* 04 sdtr_speed1 */
+	0xFFFF,			/* 05 start_motor */
+	0xFFFF,			/* 06 tagqng_able */
+	0xFFFF,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	7,			/* 09 adapter_scsi_id */
+	0,			/*    bios_boot_delay */
+	3,			/* 10 scsi_reset_delay */
+	0,			/*    bios_id_lun */
+	0,			/* 11 termination_se */
+	0,			/*    termination_lvd */
+	0xFFE7,			/* 12 bios_ctrl */
+	0x4444,			/* 13 sdtr_speed2 */
+	0x4444,			/* 14 sdtr_speed3 */
+	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
+	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0x4444,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	PCI_VENDOR_ID_ASP,	/* 58 subsysvid */
+	PCI_DEVICE_ID_38C0800_REV1,	/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
+};
 
-			/* Enable manual control with low off / high on. */
-		} else if (eep_config.termination_lvd == 2) {
-			asc_dvc->cfg->termination = termination | TERM_LVD_HI;
+static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __devinitdata = {
+	0,			/* 00 cfg_lsw */
+	0,			/* 01 cfg_msw */
+	0,			/* 02 disc_enable */
+	0,			/* 03 wdtr_able */
+	0,			/* 04 sdtr_speed1 */
+	0,			/* 05 start_motor */
+	0,			/* 06 tagqng_able */
+	0,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	1,			/* 09 adapter_scsi_id */
+	1,			/*    bios_boot_delay */
+	1,			/* 10 scsi_reset_delay */
+	1,			/*    bios_id_lun */
+	1,			/* 11 termination_se */
+	1,			/*    termination_lvd */
+	0,			/* 12 bios_ctrl */
+	0,			/* 13 sdtr_speed2 */
+	0,			/* 14 sdtr_speed3 */
+	1,			/* 15 max_host_qng */
+	1,			/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	0,			/* 58 subsysvid */
+	0,			/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
+};
 
-			/* Enable manual control with low on / high on. */
-		} else if (eep_config.termination_lvd == 3) {
-			asc_dvc->cfg->termination = termination | TERM_LVD;
-		} else {
-			/*
-			 * The EEPROM 'termination_lvd' field contains a bad value.
-			 * Use automatic termination instead.
-			 */
-			asc_dvc->cfg->termination = termination;
-			warn_code |= ASC_WARN_EEPROM_TERMINATION;
-		}
-	}
+static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __devinitdata = {
+	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
+	0x0000,			/* 01 cfg_msw */
+	0xFFFF,			/* 02 disc_enable */
+	0xFFFF,			/* 03 wdtr_able */
+	0x5555,			/* 04 sdtr_speed1 */
+	0xFFFF,			/* 05 start_motor */
+	0xFFFF,			/* 06 tagqng_able */
+	0xFFFF,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	7,			/* 09 adapter_scsi_id */
+	0,			/*    bios_boot_delay */
+	3,			/* 10 scsi_reset_delay */
+	0,			/*    bios_id_lun */
+	0,			/* 11 termination_se */
+	0,			/*    termination_lvd */
+	0xFFE7,			/* 12 bios_ctrl */
+	0x5555,			/* 13 sdtr_speed2 */
+	0x5555,			/* 14 sdtr_speed3 */
+	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
+	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0x5555,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	PCI_VENDOR_ID_ASP,	/* 58 subsysvid */
+	PCI_DEVICE_ID_38C1600_REV1,	/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
+};
 
-	return warn_code;
-}
+static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata = {
+	0,			/* 00 cfg_lsw */
+	0,			/* 01 cfg_msw */
+	0,			/* 02 disc_enable */
+	0,			/* 03 wdtr_able */
+	0,			/* 04 sdtr_speed1 */
+	0,			/* 05 start_motor */
+	0,			/* 06 tagqng_able */
+	0,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	1,			/* 09 adapter_scsi_id */
+	1,			/*    bios_boot_delay */
+	1,			/* 10 scsi_reset_delay */
+	1,			/*    bios_id_lun */
+	1,			/* 11 termination_se */
+	1,			/*    termination_lvd */
+	0,			/* 12 bios_ctrl */
+	0,			/* 13 sdtr_speed2 */
+	0,			/* 14 sdtr_speed3 */
+	1,			/* 15 max_host_qng */
+	1,			/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	0,			/* 58 subsysvid */
+	0,			/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
+};
 
+#ifdef CONFIG_PCI
 /*
- * Read EEPROM configuration into the specified buffer.
- *
- * Return a checksum based on the EEPROM configuration read.
+ * Wait for EEPROM command to complete
  */
-static ushort __devinit
-AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
+static void __devinit AdvWaitEEPCmd(AdvPortAddr iop_base)
 {
-	ushort wval, chksum;
-	ushort *wbuf;
-	int eep_addr;
-	ushort *charfields;
-
-	charfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;
-	wbuf = (ushort *)cfg_buf;
-	chksum = 0;
-
-	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
-	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
-		wval = AdvReadEEPWord(iop_base, eep_addr);
-		chksum += wval;	/* Checksum is calculated from word values. */
-		if (*charfields++) {
-			*wbuf = le16_to_cpu(wval);
-		} else {
-			*wbuf = wval;
-		}
-	}
-	/* Read checksum word. */
-	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
-	wbuf++;
-	charfields++;
+	int eep_delay_ms;
 
-	/* Read rest of EEPROM not covered by the checksum. */
-	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
-	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
-		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
-		if (*charfields++) {
-			*wbuf = le16_to_cpu(*wbuf);
+	for (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++) {
+		if (AdvReadWordRegister(iop_base, IOPW_EE_CMD) &
+		    ASC_EEP_CMD_DONE) {
+			break;
 		}
+		mdelay(1);
 	}
-	return chksum;
+	if ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==
+	    0)
+		BUG();
 }
 
 /*
- * Read EEPROM configuration into the specified buffer.
- *
- * Return a checksum based on the EEPROM configuration read.
+ * Read the EEPROM from specified location
  */
-static ushort __devinit
-AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
+static ushort __devinit AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
+{
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+			     ASC_EEP_CMD_READ | eep_word_addr);
+	AdvWaitEEPCmd(iop_base);
+	return AdvReadWordRegister(iop_base, IOPW_EE_DATA);
+}
+
+/*
+ * Write the EEPROM from 'cfg_buf'.
+ */
+void __devinit
+AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
-	ushort wval, chksum;
 	ushort *wbuf;
-	int eep_addr;
+	ushort addr, chksum;
 	ushort *charfields;
 
-	charfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;
 	wbuf = (ushort *)cfg_buf;
+	charfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;
 	chksum = 0;
 
-	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
-	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
-		wval = AdvReadEEPWord(iop_base, eep_addr);
-		chksum += wval;	/* Checksum is calculated from word values. */
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+	AdvWaitEEPCmd(iop_base);
+
+	/*
+	 * Write EEPROM from word 0 to word 20.
+	 */
+	for (addr = ADV_EEP_DVC_CFG_BEGIN;
+	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
+		ushort word;
+
 		if (*charfields++) {
-			*wbuf = le16_to_cpu(wval);
+			word = cpu_to_le16(*wbuf);
 		} else {
-			*wbuf = wval;
+			word = *wbuf;
 		}
+		chksum += *wbuf;	/* Checksum is calculated from word values. */
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+		mdelay(ADV_EEP_DELAY_MS);
 	}
-	/* Read checksum word. */
-	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+
+	/*
+	 * Write EEPROM checksum at word 21.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+	AdvWaitEEPCmd(iop_base);
 	wbuf++;
 	charfields++;
 
-	/* Read rest of EEPROM not covered by the checksum. */
-	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
-	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
-		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+	/*
+	 * Write EEPROM OEM name at words 22 to 29.
+	 */
+	for (addr = ADV_EEP_DVC_CTL_BEGIN;
+	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
+		ushort word;
+
 		if (*charfields++) {
-			*wbuf = le16_to_cpu(*wbuf);
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
 		}
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
 	}
-	return chksum;
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+	AdvWaitEEPCmd(iop_base);
 }
 
 /*
- * Read EEPROM configuration into the specified buffer.
- *
- * Return a checksum based on the EEPROM configuration read.
+ * Write the EEPROM from 'cfg_buf'.
  */
-static ushort __devinit
-AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
+void __devinit
+AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 {
-	ushort wval, chksum;
 	ushort *wbuf;
-	int eep_addr;
 	ushort *charfields;
+	ushort addr, chksum;
 
-	charfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;
 	wbuf = (ushort *)cfg_buf;
+	charfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;
 	chksum = 0;
 
-	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
-	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
-		wval = AdvReadEEPWord(iop_base, eep_addr);
-		chksum += wval;	/* Checksum is calculated from word values. */
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+	AdvWaitEEPCmd(iop_base);
+
+	/*
+	 * Write EEPROM from word 0 to word 20.
+	 */
+	for (addr = ADV_EEP_DVC_CFG_BEGIN;
+	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
+		ushort word;
+
 		if (*charfields++) {
-			*wbuf = le16_to_cpu(wval);
+			word = cpu_to_le16(*wbuf);
 		} else {
-			*wbuf = wval;
+			word = *wbuf;
 		}
+		chksum += *wbuf;	/* Checksum is calculated from word values. */
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+		mdelay(ADV_EEP_DELAY_MS);
 	}
-	/* Read checksum word. */
-	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+
+	/*
+	 * Write EEPROM checksum at word 21.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+	AdvWaitEEPCmd(iop_base);
 	wbuf++;
 	charfields++;
 
-	/* Read rest of EEPROM not covered by the checksum. */
-	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
-	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
-		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+	/*
+	 * Write EEPROM OEM name at words 22 to 29.
+	 */
+	for (addr = ADV_EEP_DVC_CTL_BEGIN;
+	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
+		ushort word;
+
 		if (*charfields++) {
-			*wbuf = le16_to_cpu(*wbuf);
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
 		}
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
 	}
-	return chksum;
-}
-
-/*
- * Read the EEPROM from specified location
- */
-static ushort __devinit AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
-{
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
-			     ASC_EEP_CMD_READ | eep_word_addr);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
 	AdvWaitEEPCmd(iop_base);
-	return AdvReadWordRegister(iop_base, IOPW_EE_DATA);
-}
-
-/*
- * Wait for EEPROM command to complete
- */
-static void __devinit AdvWaitEEPCmd(AdvPortAddr iop_base)
-{
-	int eep_delay_ms;
-
-	for (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++) {
-		if (AdvReadWordRegister(iop_base, IOPW_EE_CMD) &
-		    ASC_EEP_CMD_DONE) {
-			break;
-		}
-		mdelay(1);
-	}
-	if ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==
-	    0)
-		BUG();
-	return;
 }
 
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
 void __devinit
-AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
+AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
-	ushort addr, chksum;
 	ushort *charfields;
+	ushort addr, chksum;
 
 	wbuf = (ushort *)cfg_buf;
-	charfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;
+	charfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;
 	chksum = 0;
 
 	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
@@ -13458,610 +13052,829 @@ AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 	}
 	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
 	AdvWaitEEPCmd(iop_base);
-	return;
 }
 
 /*
- * Write the EEPROM from 'cfg_buf'.
+ * Read EEPROM configuration into the specified buffer.
+ *
+ * Return a checksum based on the EEPROM configuration read.
  */
-void __devinit
-AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
+static ushort __devinit
+AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
+	ushort wval, chksum;
 	ushort *wbuf;
+	int eep_addr;
 	ushort *charfields;
-	ushort addr, chksum;
 
+	charfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;
 	wbuf = (ushort *)cfg_buf;
-	charfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;
 	chksum = 0;
 
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
-	AdvWaitEEPCmd(iop_base);
+	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
+		wval = AdvReadEEPWord(iop_base, eep_addr);
+		chksum += wval;	/* Checksum is calculated from word values. */
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(wval);
+		} else {
+			*wbuf = wval;
+		}
+	}
+	/* Read checksum word. */
+	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+	wbuf++;
+	charfields++;
 
-	/*
-	 * Write EEPROM from word 0 to word 20.
-	 */
-	for (addr = ADV_EEP_DVC_CFG_BEGIN;
-	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
-		ushort word;
+	/* Read rest of EEPROM not covered by the checksum. */
+	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
+		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(*wbuf);
+		}
+	}
+	return chksum;
+}
+
+/*
+ * Read EEPROM configuration into the specified buffer.
+ *
+ * Return a checksum based on the EEPROM configuration read.
+ */
+static ushort __devinit
+AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
+{
+	ushort wval, chksum;
+	ushort *wbuf;
+	int eep_addr;
+	ushort *charfields;
 
+	charfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;
+	wbuf = (ushort *)cfg_buf;
+	chksum = 0;
+
+	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
+		wval = AdvReadEEPWord(iop_base, eep_addr);
+		chksum += wval;	/* Checksum is calculated from word values. */
 		if (*charfields++) {
-			word = cpu_to_le16(*wbuf);
+			*wbuf = le16_to_cpu(wval);
 		} else {
-			word = *wbuf;
+			*wbuf = wval;
 		}
-		chksum += *wbuf;	/* Checksum is calculated from word values. */
-		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
-				     ASC_EEP_CMD_WRITE | addr);
-		AdvWaitEEPCmd(iop_base);
-		mdelay(ADV_EEP_DELAY_MS);
 	}
-
-	/*
-	 * Write EEPROM checksum at word 21.
-	 */
-	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-	AdvWaitEEPCmd(iop_base);
+	/* Read checksum word. */
+	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
 	wbuf++;
 	charfields++;
 
-	/*
-	 * Write EEPROM OEM name at words 22 to 29.
-	 */
-	for (addr = ADV_EEP_DVC_CTL_BEGIN;
-	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
-		ushort word;
-
+	/* Read rest of EEPROM not covered by the checksum. */
+	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
+		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
 		if (*charfields++) {
-			word = cpu_to_le16(*wbuf);
-		} else {
-			word = *wbuf;
+			*wbuf = le16_to_cpu(*wbuf);
 		}
-		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
-				     ASC_EEP_CMD_WRITE | addr);
-		AdvWaitEEPCmd(iop_base);
 	}
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
-	AdvWaitEEPCmd(iop_base);
-	return;
+	return chksum;
 }
 
 /*
- * Write the EEPROM from 'cfg_buf'.
+ * Read EEPROM configuration into the specified buffer.
+ *
+ * Return a checksum based on the EEPROM configuration read.
  */
-void __devinit
-AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
+static ushort __devinit
+AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
+	ushort wval, chksum;
 	ushort *wbuf;
+	int eep_addr;
 	ushort *charfields;
-	ushort addr, chksum;
 
-	wbuf = (ushort *)cfg_buf;
 	charfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;
+	wbuf = (ushort *)cfg_buf;
 	chksum = 0;
 
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
-	AdvWaitEEPCmd(iop_base);
-
-	/*
-	 * Write EEPROM from word 0 to word 20.
-	 */
-	for (addr = ADV_EEP_DVC_CFG_BEGIN;
-	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
-		ushort word;
-
+	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
+		wval = AdvReadEEPWord(iop_base, eep_addr);
+		chksum += wval;	/* Checksum is calculated from word values. */
 		if (*charfields++) {
-			word = cpu_to_le16(*wbuf);
+			*wbuf = le16_to_cpu(wval);
 		} else {
-			word = *wbuf;
+			*wbuf = wval;
 		}
-		chksum += *wbuf;	/* Checksum is calculated from word values. */
-		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
-				     ASC_EEP_CMD_WRITE | addr);
-		AdvWaitEEPCmd(iop_base);
-		mdelay(ADV_EEP_DELAY_MS);
 	}
-
-	/*
-	 * Write EEPROM checksum at word 21.
-	 */
-	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-	AdvWaitEEPCmd(iop_base);
+	/* Read checksum word. */
+	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
 	wbuf++;
 	charfields++;
 
-	/*
-	 * Write EEPROM OEM name at words 22 to 29.
-	 */
-	for (addr = ADV_EEP_DVC_CTL_BEGIN;
-	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
-		ushort word;
-
+	/* Read rest of EEPROM not covered by the checksum. */
+	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
+		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
 		if (*charfields++) {
-			word = cpu_to_le16(*wbuf);
-		} else {
-			word = *wbuf;
+			*wbuf = le16_to_cpu(*wbuf);
 		}
-		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
-				     ASC_EEP_CMD_WRITE | addr);
-		AdvWaitEEPCmd(iop_base);
 	}
-	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
-	AdvWaitEEPCmd(iop_base);
-	return;
+	return chksum;
 }
 
 /*
- * AdvExeScsiQueue() - Send a request to the RISC microcode program.
- *
- *   Allocate a carrier structure, point the carrier to the ADV_SCSI_REQ_Q,
- *   add the carrier to the ICQ (Initiator Command Queue), and tickle the
- *   RISC to notify it a new command is ready to be executed.
+ * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
+ * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
  *
- * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
- * set to SCSI_MAX_RETRY.
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
  *
- * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the microcode
- * for DMA addresses or math operations are byte swapped to little-endian
- * order.
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
  *
- * Return:
- *      ADV_SUCCESS(1) - The request was successfully queued.
- *      ADV_BUSY(0) -    Resource unavailable; Retry again after pending
- *                       request completes.
- *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure
- *                       host IC error.
+ * Note: Chip is stopped on entry.
  */
-static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
+static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
-	ADV_DCNT req_size;
-	ADV_PADDR req_paddr;
-	ADV_CARR_T *new_carrp;
-
-	/*
-	 * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
-	 */
-	if (scsiq->target_id > ADV_MAX_TID) {
-		scsiq->host_status = QHSTA_M_INVALID_DEVICE;
-		scsiq->done_status = QD_WITH_ERROR;
-		return ADV_ERROR;
-	}
+	ushort warn_code;
+	ADVEEP_3550_CONFIG eep_config;
 
 	iop_base = asc_dvc->iop_base;
 
-	/*
-	 * Allocate a carrier ensuring at least one carrier always
-	 * remains on the freelist and initialize fields.
-	 */
-	if ((new_carrp = asc_dvc->carr_freelist) == NULL) {
-		return ADV_BUSY;
-	}
-	asc_dvc->carr_freelist = (ADV_CARR_T *)
-	    ADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));
-	asc_dvc->carr_pending_cnt++;
+	warn_code = 0;
 
 	/*
-	 * Set the carrier to be a stopper by setting 'next_vpa'
-	 * to the stopper value. The current stopper will be changed
-	 * below to point to the new stopper.
+	 * Read the board's EEPROM configuration.
+	 *
+	 * Set default values if a bad checksum is found.
 	 */
-	new_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	if (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum) {
+		warn_code |= ASC_WARN_EEPROM_CHKSUM;
 
-	/*
-	 * Clear the ADV_SCSI_REQ_Q done flag.
-	 */
-	scsiq->a_flag &= ~ADV_SCSIQ_DONE;
+		/*
+		 * Set EEPROM default values.
+		 */
+		memcpy(&eep_config, &Default_3550_EEPROM_Config,
+			sizeof(ADVEEP_3550_CONFIG));
 
-	req_size = sizeof(ADV_SCSI_REQ_Q);
-	req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *)scsiq,
-				  (ADV_SDCNT *)&req_size, ADV_IS_SCSIQ_FLAG);
+		/*
+		 * Assume the 6 byte board serial number that was read from
+		 * EEPROM is correct even if the EEPROM checksum failed.
+		 */
+		eep_config.serial_number_word3 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
 
-	BUG_ON(req_paddr & 31);
-	BUG_ON(req_size < sizeof(ADV_SCSI_REQ_Q));
+		eep_config.serial_number_word2 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
 
-	/* Wait for assertion before making little-endian */
-	req_paddr = cpu_to_le32(req_paddr);
+		eep_config.serial_number_word1 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
 
-	/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
-	scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
-	scsiq->scsiq_rptr = req_paddr;
+		AdvSet3550EEPConfig(iop_base, &eep_config);
+	}
+	/*
+	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
+	 * EEPROM configuration that was read.
+	 *
+	 * This is the mapping of EEPROM fields to Adv Library fields.
+	 */
+	asc_dvc->wdtr_able = eep_config.wdtr_able;
+	asc_dvc->sdtr_able = eep_config.sdtr_able;
+	asc_dvc->ultra_able = eep_config.ultra_able;
+	asc_dvc->tagqng_able = eep_config.tagqng_able;
+	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
+	asc_dvc->start_motor = eep_config.start_motor;
+	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+	asc_dvc->no_scam = eep_config.scam_tolerant;
+	asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
+	asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
+	asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
 
-	scsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));
 	/*
-	 * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
-	 * order during initialization.
+	 * Set the host maximum queuing (max. 253, min. 16) and the per device
+	 * maximum queuing (max. 63, min. 4).
 	 */
-	scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
+	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
+		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_host_qng == 0) {
+			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+		} else {
+			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+		}
+	}
+
+	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
+		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_dvc_qng == 0) {
+			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+		} else {
+			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+		}
+	}
 
 	/*
-	 * Use the current stopper to send the ADV_SCSI_REQ_Q command to
-	 * the microcode. The newly allocated stopper will become the new
-	 * stopper.
+	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
+	 * set 'max_dvc_qng' to 'max_host_qng'.
 	 */
-	asc_dvc->icq_sp->areq_vpa = req_paddr;
+	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
+		eep_config.max_dvc_qng = eep_config.max_host_qng;
+	}
 
 	/*
-	 * Set the 'next_vpa' pointer for the old stopper to be the
-	 * physical address of the new stopper. The RISC can only
-	 * follow physical addresses.
+	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
+	 * values based on possibly adjusted EEPROM values.
 	 */
-	asc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
 
 	/*
-	 * Set the host adapter stopper pointer to point to the new carrier.
+	 * If the EEPROM 'termination' field is set to automatic (0), then set
+	 * the ADV_DVC_CFG 'termination' field to automatic also.
+	 *
+	 * If the termination is specified with a non-zero 'termination'
+	 * value check that a legal value is set and set the ADV_DVC_CFG
+	 * 'termination' field appropriately.
 	 */
-	asc_dvc->icq_sp = new_carrp;
+	if (eep_config.termination == 0) {
+		asc_dvc->cfg->termination = 0;	/* auto termination */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination == 1) {
+			asc_dvc->cfg->termination = TERM_CTL_SEL;
 
-	if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
-	    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
-		/*
-		 * Tickle the RISC to tell it to read its Command Queue Head pointer.
-		 */
-		AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
-		if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination == 2) {
+			asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination == 3) {
+			asc_dvc->cfg->termination =
+			    TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
+		} else {
 			/*
-			 * Clear the tickle value. In the ASC-3550 the RISC flag
-			 * command 'clr_tickle_a' does not work unless the host
-			 * value is cleared.
+			 * The EEPROM 'termination' field contains a bad value. Use
+			 * automatic termination instead.
 			 */
-			AdvWriteByteRegister(iop_base, IOPB_TICKLE,
-					     ADV_TICKLE_NOP);
+			asc_dvc->cfg->termination = 0;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
 		}
-	} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
-		/*
-		 * Notify the RISC a carrier is ready by writing the physical
-		 * address of the new carrier stopper to the COMMA register.
-		 */
-		AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
-				      le32_to_cpu(new_carrp->carr_pa));
 	}
 
-	return ADV_SUCCESS;
+	return warn_code;
 }
 
 /*
- * Reset SCSI Bus and purge all outstanding requests.
+ * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
+ * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
  *
- * Return Value:
- *      ADV_TRUE(1) -   All requests are purged and SCSI Bus is reset.
- *      ADV_FALSE(0) -  Microcode command failed.
- *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC
- *                      may be hung which requires driver recovery.
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Note: Chip is stopped on entry.
  */
-static int AdvResetSB(ADV_DVC_VAR *asc_dvc)
+static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
 {
-	int status;
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADVEEP_38C0800_CONFIG eep_config;
+	uchar tid, termination;
+	ushort sdtr_speed = 0;
 
-	/*
-	 * Send the SCSI Bus Reset idle start idle command which asserts
-	 * the SCSI Bus Reset signal.
-	 */
-	status = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_START, 0L);
-	if (status != ADV_TRUE) {
-		return status;
-	}
+	iop_base = asc_dvc->iop_base;
 
-	/*
-	 * Delay for the specified SCSI Bus Reset hold time.
-	 *
-	 * The hold time delay is done on the host because the RISC has no
-	 * microsecond accurate timer.
-	 */
-	udelay(ASC_SCSI_RESET_HOLD_TIME_US);
+	warn_code = 0;
 
 	/*
-	 * Send the SCSI Bus Reset end idle command which de-asserts
-	 * the SCSI Bus Reset signal and purges any pending requests.
+	 * Read the board's EEPROM configuration.
+	 *
+	 * Set default values if a bad checksum is found.
 	 */
-	status = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_END, 0L);
-	if (status != ADV_TRUE) {
-		return status;
-	}
+	if (AdvGet38C0800EEPConfig(iop_base, &eep_config) !=
+	    eep_config.check_sum) {
+		warn_code |= ASC_WARN_EEPROM_CHKSUM;
 
-	mdelay(asc_dvc->scsi_reset_wait * 1000);	/* XXX: msleep? */
+		/*
+		 * Set EEPROM default values.
+		 */
+		memcpy(&eep_config, &Default_38C0800_EEPROM_Config,
+			sizeof(ADVEEP_38C0800_CONFIG));
 
-	return status;
-}
+		/*
+		 * Assume the 6 byte board serial number that was read from
+		 * EEPROM is correct even if the EEPROM checksum failed.
+		 */
+		eep_config.serial_number_word3 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
 
-/*
- * Reset chip and SCSI Bus.
- *
- * Return Value:
- *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.
- *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.
- */
-static int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
-{
-	int status;
-	ushort wdtr_able, sdtr_able, tagqng_able;
-	ushort ppr_able = 0;
-	uchar tid, max_cmd[ADV_MAX_TID + 1];
-	AdvPortAddr iop_base;
-	ushort bios_sig;
+		eep_config.serial_number_word2 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
 
-	iop_base = asc_dvc->iop_base;
+		eep_config.serial_number_word1 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
 
-	/*
-	 * Save current per TID negotiated values.
-	 */
-	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
-		AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-	}
-	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-				max_cmd[tid]);
+		AdvSet38C0800EEPConfig(iop_base, &eep_config);
 	}
-
 	/*
-	 * Force the AdvInitAsc3550/38C0800Driver() function to
-	 * perform a SCSI Bus Reset by clearing the BIOS signature word.
-	 * The initialization functions assumes a SCSI Bus Reset is not
-	 * needed if the BIOS signature word is present.
+	 * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the
+	 * EEPROM configuration that was read.
+	 *
+	 * This is the mapping of EEPROM fields to Adv Library fields.
 	 */
-	AdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
-	AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);
+	asc_dvc->wdtr_able = eep_config.wdtr_able;
+	asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
+	asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
+	asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
+	asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
+	asc_dvc->tagqng_able = eep_config.tagqng_able;
+	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
+	asc_dvc->start_motor = eep_config.start_motor;
+	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+	asc_dvc->no_scam = eep_config.scam_tolerant;
+	asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
+	asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
+	asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
 
 	/*
-	 * Stop chip and reset it.
+	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
+	 * are set, then set an 'sdtr_able' bit for it.
 	 */
-	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);
-	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
-	mdelay(100);
-	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
-			     ADV_CTRL_REG_CMD_WR_IO_REG);
+	asc_dvc->sdtr_able = 0;
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		if (tid == 0) {
+			sdtr_speed = asc_dvc->sdtr_speed1;
+		} else if (tid == 4) {
+			sdtr_speed = asc_dvc->sdtr_speed2;
+		} else if (tid == 8) {
+			sdtr_speed = asc_dvc->sdtr_speed3;
+		} else if (tid == 12) {
+			sdtr_speed = asc_dvc->sdtr_speed4;
+		}
+		if (sdtr_speed & ADV_MAX_TID) {
+			asc_dvc->sdtr_able |= (1 << tid);
+		}
+		sdtr_speed >>= 4;
+	}
 
 	/*
-	 * Reset Adv Library error code, if any, and try
-	 * re-initializing the chip.
+	 * Set the host maximum queuing (max. 253, min. 16) and the per device
+	 * maximum queuing (max. 63, min. 4).
 	 */
-	asc_dvc->err_code = 0;
-	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
-		status = AdvInitAsc38C1600Driver(asc_dvc);
-	} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
-		status = AdvInitAsc38C0800Driver(asc_dvc);
-	} else {
-		status = AdvInitAsc3550Driver(asc_dvc);
+	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
+		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_host_qng == 0) {
+			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+		} else {
+			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+		}
 	}
 
-	/* Translate initialization return value to status value. */
-	if (status == 0) {
-		status = ADV_TRUE;
-	} else {
-		status = ADV_FALSE;
+	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
+		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_dvc_qng == 0) {
+			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+		} else {
+			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+		}
+	}
+
+	/*
+	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
+	 * set 'max_dvc_qng' to 'max_host_qng'.
+	 */
+	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
+		eep_config.max_dvc_qng = eep_config.max_host_qng;
 	}
 
 	/*
-	 * Restore the BIOS signature word.
+	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
+	 * values based on possibly adjusted EEPROM values.
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
 
 	/*
-	 * Restore per TID negotiated values.
+	 * If the EEPROM 'termination' field is set to automatic (0), then set
+	 * the ADV_DVC_CFG 'termination' field to automatic also.
+	 *
+	 * If the termination is specified with a non-zero 'termination'
+	 * value check that a legal value is set and set the ADV_DVC_CFG
+	 * 'termination' field appropriately.
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-	AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
-		AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	if (eep_config.termination_se == 0) {
+		termination = 0;	/* auto termination for SE */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_se == 1) {
+			termination = 0;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_se == 2) {
+			termination = TERM_SE_HI;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_se == 3) {
+			termination = TERM_SE;
+		} else {
+			/*
+			 * The EEPROM 'termination_se' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			termination = 0;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
 	}
-	AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
-		AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-				 max_cmd[tid]);
+
+	if (eep_config.termination_lvd == 0) {
+		asc_dvc->cfg->termination = termination;	/* auto termination for LVD */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_lvd == 1) {
+			asc_dvc->cfg->termination = termination;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_lvd == 2) {
+			asc_dvc->cfg->termination = termination | TERM_LVD_HI;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_lvd == 3) {
+			asc_dvc->cfg->termination = termination | TERM_LVD;
+		} else {
+			/*
+			 * The EEPROM 'termination_lvd' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			asc_dvc->cfg->termination = termination;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
 	}
 
-	return status;
+	return warn_code;
 }
 
 /*
- * Adv Library Interrupt Service Routine
- *
- *  This function is called by a driver's interrupt service routine.
- *  The function disables and re-enables interrupts.
+ * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and
+ * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
  *
- *  When a microcode idle command is completed, the ADV_DVC_VAR
- *  'idle_cmd_done' field is set to ADV_TRUE.
+ * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
  *
- *  Note: AdvISR() can be called when interrupts are disabled or even
- *  when there is no hardware interrupt condition present. It will
- *  always check for completed idle commands and microcode requests.
- *  This is an important feature that shouldn't be changed because it
- *  allows commands to be completed from polling mode loops.
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
  *
- * Return:
- *   ADV_TRUE(1) - interrupt was pending
- *   ADV_FALSE(0) - no interrupt was pending
+ * Note: Chip is stopped on entry.
  */
-static int AdvISR(ADV_DVC_VAR *asc_dvc)
+static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
-	uchar int_stat;
-	ushort target_bit;
-	ADV_CARR_T *free_carrp;
-	ADV_VADDR irq_next_vpa;
-	ADV_SCSI_REQ_Q *scsiq;
+	ushort warn_code;
+	ADVEEP_38C1600_CONFIG eep_config;
+	uchar tid, termination;
+	ushort sdtr_speed = 0;
 
 	iop_base = asc_dvc->iop_base;
 
-	/* Reading the register clears the interrupt. */
-	int_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);
+	warn_code = 0;
 
-	if ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |
-			 ADV_INTR_STATUS_INTRC)) == 0) {
-		return ADV_FALSE;
+	/*
+	 * Read the board's EEPROM configuration.
+	 *
+	 * Set default values if a bad checksum is found.
+	 */
+	if (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=
+	    eep_config.check_sum) {
+		struct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);
+		warn_code |= ASC_WARN_EEPROM_CHKSUM;
+
+		/*
+		 * Set EEPROM default values.
+		 */
+		memcpy(&eep_config, &Default_38C1600_EEPROM_Config,
+			sizeof(ADVEEP_38C1600_CONFIG));
+
+		if (PCI_FUNC(pdev->devfn) != 0) {
+			u8 ints;
+			/*
+			 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60
+			 * and old Mac system booting problem. The Expansion
+			 * ROM must be disabled in Function 1 for these systems
+			 */
+			eep_config.cfg_lsw &= ~ADV_EEPROM_BIOS_ENABLE;
+			/*
+			 * Clear the INTAB (bit 11) if the GPIO 0 input
+			 * indicates the Function 1 interrupt line is wired
+			 * to INTB.
+			 *
+			 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
+			 *   1 - Function 1 interrupt line wired to INT A.
+			 *   0 - Function 1 interrupt line wired to INT B.
+			 *
+			 * Note: Function 0 is always wired to INTA.
+			 * Put all 5 GPIO bits in input mode and then read
+			 * their input values.
+			 */
+			AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);
+			ints = AdvReadByteRegister(iop_base, IOPB_GPIO_DATA);
+			if ((ints & 0x01) == 0)
+				eep_config.cfg_lsw &= ~ADV_EEPROM_INTAB;
+		}
+
+		/*
+		 * Assume the 6 byte board serial number that was read from
+		 * EEPROM is correct even if the EEPROM checksum failed.
+		 */
+		eep_config.serial_number_word3 =
+			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
+		eep_config.serial_number_word2 =
+			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
+		eep_config.serial_number_word1 =
+			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+
+		AdvSet38C1600EEPConfig(iop_base, &eep_config);
 	}
 
 	/*
-	 * Notify the driver of an asynchronous microcode condition by
-	 * calling the adv_async_callback function. The function
-	 * is passed the microcode ASC_MC_INTRB_CODE byte value.
+	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
+	 * EEPROM configuration that was read.
+	 *
+	 * This is the mapping of EEPROM fields to Adv Library fields.
 	 */
-	if (int_stat & ADV_INTR_STATUS_INTRB) {
-		uchar intrb_code;
+	asc_dvc->wdtr_able = eep_config.wdtr_able;
+	asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
+	asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
+	asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
+	asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
+	asc_dvc->ppr_able = 0;
+	asc_dvc->tagqng_able = eep_config.tagqng_able;
+	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
+	asc_dvc->start_motor = eep_config.start_motor;
+	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+	asc_dvc->no_scam = eep_config.scam_tolerant;
 
-		AdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);
+	/*
+	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
+	 * are set, then set an 'sdtr_able' bit for it.
+	 */
+	asc_dvc->sdtr_able = 0;
+	for (tid = 0; tid <= ASC_MAX_TID; tid++) {
+		if (tid == 0) {
+			sdtr_speed = asc_dvc->sdtr_speed1;
+		} else if (tid == 4) {
+			sdtr_speed = asc_dvc->sdtr_speed2;
+		} else if (tid == 8) {
+			sdtr_speed = asc_dvc->sdtr_speed3;
+		} else if (tid == 12) {
+			sdtr_speed = asc_dvc->sdtr_speed4;
+		}
+		if (sdtr_speed & ASC_MAX_TID) {
+			asc_dvc->sdtr_able |= (1 << tid);
+		}
+		sdtr_speed >>= 4;
+	}
 
-		if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
-		    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
-			if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
-			    asc_dvc->carr_pending_cnt != 0) {
-				AdvWriteByteRegister(iop_base, IOPB_TICKLE,
-						     ADV_TICKLE_A);
-				if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
-					AdvWriteByteRegister(iop_base,
-							     IOPB_TICKLE,
-							     ADV_TICKLE_NOP);
-				}
-			}
+	/*
+	 * Set the host maximum queuing (max. 253, min. 16) and the per device
+	 * maximum queuing (max. 63, min. 4).
+	 */
+	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
+		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_host_qng == 0) {
+			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+		} else {
+			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
 		}
+	}
 
-		adv_async_callback(asc_dvc, intrb_code);
+	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
+		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_dvc_qng == 0) {
+			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+		} else {
+			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+		}
+	}
+
+	/*
+	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
+	 * set 'max_dvc_qng' to 'max_host_qng'.
+	 */
+	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
+		eep_config.max_dvc_qng = eep_config.max_host_qng;
 	}
 
 	/*
-	 * Check if the IRQ stopper carrier contains a completed request.
+	 * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'
+	 * values based on possibly adjusted EEPROM values.
+	 */
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+	/*
+	 * If the EEPROM 'termination' field is set to automatic (0), then set
+	 * the ASC_DVC_CFG 'termination' field to automatic also.
+	 *
+	 * If the termination is specified with a non-zero 'termination'
+	 * value check that a legal value is set and set the ASC_DVC_CFG
+	 * 'termination' field appropriately.
 	 */
-	while (((irq_next_vpa =
-		 le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0) {
-		/*
-		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
-		 * The RISC will have set 'areq_vpa' to a virtual address.
-		 *
-		 * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr
-		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
-		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
-		 * in AdvExeScsiQueue().
-		 */
-		scsiq = (ADV_SCSI_REQ_Q *)
-		    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));
-
-		/*
-		 * Request finished with good status and the queue was not
-		 * DMAed to host memory by the firmware. Set all status fields
-		 * to indicate good status.
-		 */
-		if ((irq_next_vpa & ASC_RQ_GOOD) != 0) {
-			scsiq->done_status = QD_NO_ERROR;
-			scsiq->host_status = scsiq->scsi_status = 0;
-			scsiq->data_cnt = 0L;
-		}
+	if (eep_config.termination_se == 0) {
+		termination = 0;	/* auto termination for SE */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_se == 1) {
+			termination = 0;
 
-		/*
-		 * Advance the stopper pointer to the next carrier
-		 * ignoring the lower four bits. Free the previous
-		 * stopper carrier.
-		 */
-		free_carrp = asc_dvc->irq_sp;
-		asc_dvc->irq_sp = (ADV_CARR_T *)
-		    ADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_se == 2) {
+			termination = TERM_SE_HI;
 
-		free_carrp->next_vpa =
-		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-		asc_dvc->carr_freelist = free_carrp;
-		asc_dvc->carr_pending_cnt--;
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_se == 3) {
+			termination = TERM_SE;
+		} else {
+			/*
+			 * The EEPROM 'termination_se' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			termination = 0;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
+	}
 
-		target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);
+	if (eep_config.termination_lvd == 0) {
+		asc_dvc->cfg->termination = termination;	/* auto termination for LVD */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_lvd == 1) {
+			asc_dvc->cfg->termination = termination;
 
-		/*
-		 * Clear request microcode control flag.
-		 */
-		scsiq->cntl = 0;
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_lvd == 2) {
+			asc_dvc->cfg->termination = termination | TERM_LVD_HI;
 
-		/*
-		 * Notify the driver of the completed request by passing
-		 * the ADV_SCSI_REQ_Q pointer to its callback function.
-		 */
-		scsiq->a_flag |= ADV_SCSIQ_DONE;
-		adv_isr_callback(asc_dvc, scsiq);
-		/*
-		 * Note: After the driver callback function is called, 'scsiq'
-		 * can no longer be referenced.
-		 *
-		 * Fall through and continue processing other completed
-		 * requests...
-		 */
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_lvd == 3) {
+			asc_dvc->cfg->termination = termination | TERM_LVD;
+		} else {
+			/*
+			 * The EEPROM 'termination_lvd' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			asc_dvc->cfg->termination = termination;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
 	}
-	return ADV_TRUE;
+
+	return warn_code;
 }
 
 /*
- * Send an idle command to the chip and wait for completion.
- *
- * Command completion is polled for once per microsecond.
+ * Initialize the ADV_DVC_VAR structure.
  *
- * The function can be called from anywhere including an interrupt handler.
- * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()
- * functions to prevent reentrancy.
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
  *
- * Return Values:
- *   ADV_TRUE - command completed successfully
- *   ADV_FALSE - command failed
- *   ADV_ERROR - command timed out
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
  */
-static int
-AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
-	       ushort idle_cmd, ADV_DCNT idle_cmd_parameter)
+static int __devinit
+AdvInitGetConfig(struct pci_dev *pdev, asc_board_t *boardp)
 {
-	int result;
-	ADV_DCNT i, j;
-	AdvPortAddr iop_base;
+	ADV_DVC_VAR *asc_dvc = &boardp->dvc_var.adv_dvc_var;
+	unsigned short warn_code = 0;
+	AdvPortAddr iop_base = asc_dvc->iop_base;
+	u16 cmd;
+	int status;
 
-	iop_base = asc_dvc->iop_base;
+	asc_dvc->err_code = 0;
 
 	/*
-	 * Clear the idle command status which is set by the microcode
-	 * to a non-zero value to indicate when the command is completed.
-	 * The non-zero result is one of the IDLE_CMD_STATUS_* values
+	 * Save the state of the PCI Configuration Command Register
+	 * "Parity Error Response Control" Bit. If the bit is clear (0),
+	 * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore
+	 * DMA parity errors.
 	 */
-	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);
+	asc_dvc->cfg->control_flag = 0;
+	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
+	if ((cmd & PCI_COMMAND_PARITY) == 0)
+		asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
 
-	/*
-	 * Write the idle command value after the idle command parameter
-	 * has been written to avoid a race condition. If the order is not
-	 * followed, the microcode may process the idle command before the
-	 * parameters have been written to LRAM.
-	 */
-	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,
-				cpu_to_le32(idle_cmd_parameter));
-	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
+	asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
+	    ADV_LIB_VERSION_MINOR;
+	asc_dvc->cfg->chip_version =
+	    AdvGetChipVersion(iop_base, asc_dvc->bus_type);
+
+	ASC_DBG2(1, "AdvInitGetConfig: iopb_chip_id_1: 0x%x 0x%x\n",
+		 (ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),
+		 (ushort)ADV_CHIP_ID_BYTE);
+
+	ASC_DBG2(1, "AdvInitGetConfig: iopw_chip_id_0: 0x%x 0x%x\n",
+		 (ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),
+		 (ushort)ADV_CHIP_ID_WORD);
 
 	/*
-	 * Tickle the RISC to tell it to process the idle command.
+	 * Reset the chip to start and allow register writes.
 	 */
-	AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);
-	if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+	if (AdvFindSignature(iop_base) == 0) {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+		return ADV_ERROR;
+	} else {
 		/*
-		 * Clear the tickle value. In the ASC-3550 the RISC flag
-		 * command 'clr_tickle_b' does not work unless the host
-		 * value is cleared.
+		 * The caller must set 'chip_type' to a valid setting.
 		 */
-		AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
-	}
+		if (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&
+		    asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&
+		    asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {
+			asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
+			return ADV_ERROR;
+		}
 
-	/* Wait for up to 100 millisecond for the idle command to timeout. */
-	for (i = 0; i < SCSI_WAIT_100_MSEC; i++) {
-		/* Poll once each microsecond for command completion. */
-		for (j = 0; j < SCSI_US_PER_MSEC; j++) {
-			AdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,
-					result);
-			if (result != 0)
-				return result;
-			udelay(1);
+		/*
+		 * Reset Chip.
+		 */
+		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+				     ADV_CTRL_REG_CMD_RESET);
+		mdelay(100);
+		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+				     ADV_CTRL_REG_CMD_WR_IO_REG);
+
+		if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+			status = AdvInitFrom38C1600EEP(asc_dvc);
+		} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+			status = AdvInitFrom38C0800EEP(asc_dvc);
+		} else {
+			status = AdvInitFrom3550EEP(asc_dvc);
 		}
+		warn_code |= status;
 	}
 
-	BUG();		/* The idle command should never timeout. */
-	return ADV_ERROR;
+	if (warn_code != 0) {
+		ASC_PRINT2("AdvInitGetConfig: board %d: warning: 0x%x\n",
+			   boardp->id, warn_code);
+	}
+
+	if (asc_dvc->err_code) {
+		ASC_PRINT2("AdvInitGetConfig: board %d error: err_code 0x%x\n",
+		     boardp->id, asc_dvc->err_code);
+	}
+
+	return asc_dvc->err_code;
 }
+#endif
+
+static struct scsi_host_template advansys_template = {
+	.proc_name = DRV_NAME,
+#ifdef CONFIG_PROC_FS
+	.proc_info = advansys_proc_info,
+#endif
+	.name = DRV_NAME,
+	.info = advansys_info,
+	.queuecommand = advansys_queuecommand,
+	.eh_bus_reset_handler = advansys_reset,
+	.bios_param = advansys_biosparam,
+	.slave_configure = advansys_slave_configure,
+	/*
+	 * Because the driver may control an ISA adapter 'unchecked_isa_dma'
+	 * must be set. The flag will be cleared in advansys_board_found
+	 * for non-ISA adapters.
+	 */
+	.unchecked_isa_dma = 1,
+	/*
+	 * All adapters controlled by this driver are capable of large
+	 * scatter-gather lists. According to the mid-level SCSI documentation
+	 * this obviates any performance gain provided by setting
+	 * 'use_clustering'. But empirically while CPU utilization is increased
+	 * by enabling clustering, I/O throughput increases as well.
+	 */
+	.use_clustering = ENABLE_CLUSTERING,
+};
 
 static int __devinit
 advansys_wide_init_chip(asc_board_t *boardp, ADV_DVC_VAR *adv_dvc_varp)

commit 01fbfe0b8359695a3ff7f4b79ab1e0a777f10ae4
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:40 2007 -0600

    [SCSI] advansys: Use DRV_NAME
    
    Follow the example of some other drivers by defining DRV_NAME to be
    "advansys".  Prevents spelling mistakes.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e5b26a1ea0ec..0303fc7dacd3 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1,3 +1,4 @@
+#define DRV_NAME "advansys"
 #define ASC_VERSION "3.4"	/* AdvanSys Driver Version */
 
 /*
@@ -3213,11 +3214,11 @@ advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 }
 
 static struct scsi_host_template advansys_template = {
-	.proc_name = "advansys",
+	.proc_name = DRV_NAME,
 #ifdef CONFIG_PROC_FS
 	.proc_info = advansys_proc_info,
 #endif
-	.name = "advansys",
+	.name = DRV_NAME,
 	.info = advansys_info,
 	.queuecommand = advansys_queuecommand,
 	.eh_bus_reset_handler = advansys_reset,
@@ -14634,7 +14635,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		/* Register DMA channel for ISA bus. */
 		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
 			shost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
-			ret = request_dma(shost->dma_channel, "advansys");
+			ret = request_dma(shost->dma_channel, DRV_NAME);
 			if (ret) {
 				ASC_PRINT3
 				    ("advansys_board_found: board %d: request_dma() %d failed %d\n",
@@ -14650,7 +14651,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	ASC_DBG1(2, "advansys_board_found: request_irq() %d\n", shost->irq);
 
 	ret = request_irq(shost->irq, advansys_interrupt, share_irq,
-			  "advansys", shost);
+			  DRV_NAME, shost);
 
 	if (ret) {
 		if (ret == -EBUSY) {
@@ -14754,7 +14755,7 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	PortAddr iop_base = _asc_def_iop_base[id];
 	struct Scsi_Host *shost;
 
-	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
+	if (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {
 		ASC_DBG1(1, "advansys_isa_match: I/O port 0x%x busy\n",
 			 iop_base);
 		return -ENODEV;
@@ -14790,7 +14791,7 @@ static struct isa_driver advansys_isa_driver = {
 	.remove		= __devexit_p(advansys_isa_remove),
 	.driver = {
 		.owner	= THIS_MODULE,
-		.name	= "advansys",
+		.name	= DRV_NAME,
 	},
 };
 
@@ -14799,7 +14800,7 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 	PortAddr iop_base = _asc_def_iop_base[id];
 	struct Scsi_Host *shost;
 
-	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
+	if (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {
 		ASC_DBG1(1, "advansys_vlb_match: I/O port 0x%x busy\n",
 			 iop_base);
 		return -ENODEV;
@@ -14867,7 +14868,7 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 
 	err = -ENODEV;
 	for (i = 0; i < 2; i++, ioport += 0x20) {
-		if (!request_region(ioport, ASC_IOADR_GAP, "advansys")) {
+		if (!request_region(ioport, ASC_IOADR_GAP, DRV_NAME)) {
 			printk(KERN_WARNING "Region %x-%x busy\n", ioport,
 			       ioport + ASC_IOADR_GAP - 1);
 			continue;
@@ -14925,7 +14926,7 @@ static __devexit int advansys_eisa_remove(struct device *dev)
 static struct eisa_driver advansys_eisa_driver = {
 	.id_table =		advansys_eisa_table,
 	.driver = {
-		.name =		"advansys",
+		.name =		DRV_NAME,
 		.probe =	advansys_eisa_probe,
 		.remove =	__devexit_p(advansys_eisa_remove),
 	}
@@ -14972,7 +14973,7 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	err = pci_enable_device(pdev);
 	if (err)
 		goto fail;
-	err = pci_request_regions(pdev, "advansys");
+	err = pci_request_regions(pdev, DRV_NAME);
 	if (err)
 		goto disable_device;
 	pci_set_master(pdev);
@@ -15007,7 +15008,7 @@ static void __devexit advansys_pci_remove(struct pci_dev *pdev)
 }
 
 static struct pci_driver advansys_pci_driver = {
-	.name =		"advansys",
+	.name =		DRV_NAME,
 	.id_table =	advansys_pci_tbl,
 	.probe =	advansys_pci_probe,
 	.remove =	__devexit_p(advansys_pci_remove),

commit 95c9f16284960f579205d7da8b5d90e2f3bf44a7
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:39 2007 -0600

    [SCSI] advansys: Comment/indentation/macro cleanup
    
     - Delete comments relating to the previous structure of the driver.
       I have no intention of honouring them ;-)
     - Reformat comments > 80 columns
     - Remove now-obsolete comments from advansys_interrupt
     - Change adv_get_sglist() from do {} while (1) to for (;;)
     - Return void from AscInitQLinkVar()
     - Take out a level of indentation in adv_get_sglist()
     - Reduce indentation level of AscAsyncFix()
     - Remove unused macros
     - Refactor AscSendScsiQueue slightly
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9c5d37d9c79a..e5b26a1ea0ec 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -76,10 +76,6 @@
 /* Enable driver tracing. */
 /* #define ADVANSYS_DEBUG */
 
-/*
- * --- Asc Library Constants and Macros
- */
-
 #define ASC_LIB_VERSION_MAJOR  1
 #define ASC_LIB_VERSION_MINOR  24
 #define ASC_LIB_SERIAL_NUMBER  123
@@ -118,15 +114,10 @@ typedef unsigned char uchar;
 #define FALSE    (0)
 #endif
 
-#define EOF      (-1)
 #define ERR      (-1)
 #define UW_ERR   (uint)(0xFFFF)
 #define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
 
-#define  ASC_DVCLIB_CALL_DONE     (1)
-#define  ASC_DVCLIB_CALL_FAILED   (0)
-#define  ASC_DVCLIB_CALL_ERROR    (-1)
-
 #define PCI_VENDOR_ID_ASP		0x10cd
 #define PCI_DEVICE_ID_ASP_1200A		0x1100
 #define PCI_DEVICE_ID_ASP_ABP940	0x1200
@@ -164,11 +155,10 @@ typedef unsigned char uchar;
 #define ASC_IS_PCMCIA       (0x0008)
 #define ASC_IS_MCA          (0x0020)
 #define ASC_IS_VL           (0x0040)
-#define ASC_ISA_PNP_PORT_ADDR  (0x279)
-#define ASC_ISA_PNP_PORT_WRITE (ASC_ISA_PNP_PORT_ADDR+0x800)
 #define ASC_IS_WIDESCSI_16  (0x0100)
 #define ASC_IS_WIDESCSI_32  (0x0200)
 #define ASC_IS_BIG_ENDIAN   (0x8000)
+
 #define ASC_CHIP_MIN_VER_VL      (0x01)
 #define ASC_CHIP_MAX_VER_VL      (0x07)
 #define ASC_CHIP_MIN_VER_PCI     (0x09)
@@ -187,16 +177,9 @@ typedef unsigned char uchar;
 #define ASC_CHIP_MAX_VER_EISA (0x47)
 #define ASC_CHIP_VER_EISA_BIT (0x40)
 #define ASC_CHIP_LATEST_VER_EISA   ((ASC_CHIP_MIN_VER_EISA - 1) + 3)
-#define ASC_MAX_LIB_SUPPORTED_ISA_CHIP_VER   0x21
-#define ASC_MAX_LIB_SUPPORTED_PCI_CHIP_VER   0x0A
-#define ASC_MAX_VL_DMA_ADDR     (0x07FFFFFFL)
 #define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)
-#define ASC_MAX_PCI_DMA_ADDR    (0xFFFFFFFFL)
 #define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)
-#define ASC_MAX_ISA_DMA_ADDR    (0x00FFFFFFL)
 #define ASC_MAX_ISA_DMA_COUNT   (0x00FFFFFFL)
-#define ASC_MAX_EISA_DMA_ADDR   (0x07FFFFFFL)
-#define ASC_MAX_EISA_DMA_COUNT  (0x07FFFFFFL)
 
 #define ASC_SCSI_ID_BITS  3
 #define ASC_SCSI_TIX_TYPE     uchar
@@ -216,24 +199,6 @@ typedef unsigned char uchar;
 #define ASC_MAX_CDB_LEN     12
 #define ADV_MAX_CDB_LEN     16
 
-/*
- * Inquiry SPC-2 SPI Byte 1 EVPD (Enable Vital Product Data)
- * and CmdDt (Command Support Data) field bit definitions.
- */
-#define ADV_INQ_RTN_VPD_AND_CMDDT           0x3
-#define ADV_INQ_RTN_CMDDT_FOR_OP_CODE       0x2
-#define ADV_INQ_RTN_VPD_FOR_PG_CODE         0x1
-#define ADV_INQ_RTN_STD_INQUIRY_DATA        0x0
-
-#define ASC_SCSIDIR_NOCHK    0x00
-#define ASC_SCSIDIR_T2H      0x08
-#define ASC_SCSIDIR_H2T      0x10
-#define ASC_SCSIDIR_NODATA   0x18
-#define SCSI_ASC_NOMEDIA          0x3A
-#define ASC_SRB_HOST(x)  ((uchar)((uchar)(x) >> 4))
-#define ASC_SRB_TID(x)   ((uchar)((uchar)(x) & (uchar)0x0F))
-#define ASC_SRB_LUN(x)   ((uchar)((uint)(x) >> 13))
-#define PUT_CDB1(x)   ((uchar)((uint)(x) >> 8))
 #define MS_SDTR_LEN    0x03
 #define MS_WDTR_LEN    0x02
 
@@ -417,19 +382,6 @@ typedef struct asc_sg_head {
 	ASC_SG_LIST sg_list[ASC_MAX_SG_LIST];
 } ASC_SG_HEAD;
 
-#define ASC_MIN_SG_LIST   2
-
-typedef struct asc_min_sg_head {
-	ushort entry_cnt;
-	ushort queue_cnt;
-	ushort entry_to_copy;
-	ushort res;
-	ASC_SG_LIST sg_list[ASC_MIN_SG_LIST];
-} ASC_MIN_SG_HEAD;
-
-#define QCX_SORT        (0x0001)
-#define QCX_COALEASE    (0x0002)
-
 typedef struct asc_scsi_q {
 	ASC_SCSIQ_1 q1;
 	ASC_SCSIQ_2 q2;
@@ -486,34 +438,9 @@ typedef struct asc_risc_sg_list_q {
 	ASC_SG_LIST sg_list[7];
 } ASC_RISC_SG_LIST_Q;
 
-#define ASC_EXE_SCSI_IO_MAX_IDLE_LOOP  0x1000000UL
-#define ASC_EXE_SCSI_IO_MAX_WAIT_LOOP  1024
-#define ASCQ_ERR_NO_ERROR             0
-#define ASCQ_ERR_IO_NOT_FOUND         1
-#define ASCQ_ERR_LOCAL_MEM            2
-#define ASCQ_ERR_CHKSUM               3
-#define ASCQ_ERR_START_CHIP           4
-#define ASCQ_ERR_INT_TARGET_ID        5
-#define ASCQ_ERR_INT_LOCAL_MEM        6
-#define ASCQ_ERR_HALT_RISC            7
-#define ASCQ_ERR_GET_ASPI_ENTRY       8
-#define ASCQ_ERR_CLOSE_ASPI           9
-#define ASCQ_ERR_HOST_INQUIRY         0x0A
-#define ASCQ_ERR_SAVED_SRB_BAD        0x0B
-#define ASCQ_ERR_QCNTL_SG_LIST        0x0C
 #define ASCQ_ERR_Q_STATUS             0x0D
-#define ASCQ_ERR_WR_SCSIQ             0x0E
-#define ASCQ_ERR_PC_ADDR              0x0F
-#define ASCQ_ERR_SYN_OFFSET           0x10
-#define ASCQ_ERR_SYN_XFER_TIME        0x11
-#define ASCQ_ERR_LOCK_DMA             0x12
-#define ASCQ_ERR_UNLOCK_DMA           0x13
-#define ASCQ_ERR_VDS_CHK_INSTALL      0x14
-#define ASCQ_ERR_MICRO_CODE_HALT      0x15
-#define ASCQ_ERR_SET_LRAM_ADDR        0x16
 #define ASCQ_ERR_CUR_QNG              0x17
 #define ASCQ_ERR_SG_Q_LINKS           0x18
-#define ASCQ_ERR_SCSIQ_PTR            0x19
 #define ASCQ_ERR_ISR_RE_ENTRY         0x1A
 #define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B
 #define ASCQ_ERR_ISR_ON_CRITICAL      0x1C
@@ -529,7 +456,6 @@ typedef struct asc_risc_sg_list_q {
 #define ASC_WARN_CMD_QNG_CONFLICT     0x0010
 #define ASC_WARN_EEPROM_RECOVER       0x0020
 #define ASC_WARN_CFG_MSW_RECOVER      0x0040
-#define ASC_WARN_SET_PCI_CONFIG_SPACE 0x0080
 
 /*
  * Error code values are set in ASC_DVC_VAR  'err_code'.
@@ -549,27 +475,21 @@ typedef struct asc_risc_sg_list_q {
 #define ASC_IERR_SET_SDTR             0x1000
 #define ASC_IERR_RW_LRAM              0x8000
 
-#define ASC_DEF_IRQ_NO  10
 #define ASC_MAX_IRQ_NO  15
 #define ASC_MIN_IRQ_NO  10
-#define ASC_MIN_REMAIN_Q        (0x02)
 #define ASC_DEF_MAX_TOTAL_QNG   (0xF0)
 #define ASC_MIN_TAG_Q_PER_DVC   (0x04)
-#define ASC_DEF_TAG_Q_PER_DVC   (0x04)
-#define ASC_MIN_FREE_Q        ASC_MIN_REMAIN_Q
+#define ASC_MIN_FREE_Q        (0x02)
 #define ASC_MIN_TOTAL_QNG     ((ASC_MAX_SG_QUEUE)+(ASC_MIN_FREE_Q))
 #define ASC_MAX_TOTAL_QNG 240
 #define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16
 #define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8
 #define ASC_MAX_PCI_INRAM_TOTAL_QNG  20
 #define ASC_MAX_INRAM_TAG_QNG   16
-#define ASC_IOADR_TABLE_MAX_IX  11
 #define ASC_IOADR_GAP   0x10
-#define ASC_LIB_SCSIQ_WK_SP        256
 #define ASC_MAX_SYN_XFER_NO        16
 #define ASC_SYN_MAX_OFFSET         0x0F
 #define ASC_DEF_SDTR_OFFSET        0x0F
-#define ASC_DEF_SDTR_INDEX         0x00
 #define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02
 #define SYN_XFER_NS_0  25
 #define SYN_XFER_NS_1  30
@@ -648,7 +568,6 @@ typedef struct asc_dvc_cfg {
 #define ASC_DEF_DVC_CNTL       0xFFFF
 #define ASC_DEF_CHIP_SCSI_ID   7
 #define ASC_DEF_ISA_DMA_SPEED  4
-#define ASC_INIT_STATE_NULL          0x0000
 #define ASC_INIT_STATE_BEG_GET_CFG   0x0001
 #define ASC_INIT_STATE_END_GET_CFG   0x0002
 #define ASC_INIT_STATE_BEG_SET_CFG   0x0004
@@ -740,12 +659,7 @@ typedef struct asc_cap_info_array {
 #define ASC_EEP_MAX_DVC_ADDR_VL   15
 #define ASC_EEP_DVC_CFG_BEG      32
 #define ASC_EEP_MAX_DVC_ADDR     45
-#define ASC_EEP_DEFINED_WORDS    10
-#define ASC_EEP_MAX_ADDR         63
-#define ASC_EEP_RES_WORDS         0
 #define ASC_EEP_MAX_RETRY        20
-#define ASC_MAX_INIT_BUSY_RETRY   8
-#define ASC_EEP_ISA_PNP_WSIZE    16
 
 /*
  * These macros keep the chip SCSI id and ISA DMA speed
@@ -781,17 +695,11 @@ typedef struct asceep_config {
 	ushort chksum;
 } ASCEEP_CONFIG;
 
-#define ASC_PCI_CFG_LSW_SCSI_PARITY  0x0800
-#define ASC_PCI_CFG_LSW_BURST_MODE   0x0080
-#define ASC_PCI_CFG_LSW_INTR_ABLE    0x0020
-
 #define ASC_EEP_CMD_READ          0x80
 #define ASC_EEP_CMD_WRITE         0x40
 #define ASC_EEP_CMD_WRITE_ABLE    0x30
 #define ASC_EEP_CMD_WRITE_DISABLE 0x00
 #define ASC_OVERRUN_BSIZE  0x00000048UL
-#define ASC_CTRL_BREAK_ONCE        0x0001
-#define ASC_CTRL_BREAK_STAY_IDLE   0x0002
 #define ASCV_MSGOUT_BEG         0x0000
 #define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)
 #define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)
@@ -1105,7 +1013,6 @@ static int AscPutReadySgListQueue(ASC_DVC_VAR *, ASC_SCSI_Q *, uchar);
 static int AscSetChipSynRegAtID(PortAddr, uchar, uchar);
 static int AscSetRunChipSynRegAtID(PortAddr, uchar, uchar);
 static ushort AscInitLram(ASC_DVC_VAR *);
-static ushort AscInitQLinkVar(ASC_DVC_VAR *);
 static int AscSetLibErrorCode(ASC_DVC_VAR *, ushort);
 static int AscIsrChipHalted(ASC_DVC_VAR *);
 static uchar _AscCopyLramScsiDoneQ(PortAddr, ushort,
@@ -1131,10 +1038,6 @@ static void AscEnableIsaDma(uchar);
 #endif /* CONFIG_ISA */
 static const char *advansys_info(struct Scsi_Host *shost);
 
-/*
- * --- Adv Library Constants and Macros
- */
-
 #define ADV_LIB_VERSION_MAJOR  5
 #define ADV_LIB_VERSION_MINOR  14
 
@@ -1515,10 +1418,6 @@ typedef struct adveep_38C1600_config {
  * EEPROM Commands
  */
 #define ASC_EEP_CMD_DONE             0x0200
-#define ASC_EEP_CMD_DONE_ERR         0x0001
-
-/* cfg_word */
-#define EEP_CFG_WORD_BIG_ENDIAN      0x8000
 
 /* bios_ctrl */
 #define BIOS_CTRL_BIOS               0x0001
@@ -1675,8 +1574,6 @@ typedef struct adveep_38C1600_config {
 #define ADV_CHIP_ID_BYTE         0x25
 #define ADV_CHIP_ID_WORD         0x04C1
 
-#define ADV_SC_SCSI_BUS_RESET    0x2000
-
 #define ADV_INTR_ENABLE_HOST_INTR                   0x01
 #define ADV_INTR_ENABLE_SEL_INTR                    0x02
 #define ADV_INTR_ENABLE_DPR_INTR                    0x04
@@ -1716,8 +1613,6 @@ typedef struct adveep_38C1600_config {
 #define ADV_TICKLE_B                        0x02
 #define ADV_TICKLE_C                        0x03
 
-#define ADV_SCSI_CTRL_RSTOUT        0x2000
-
 #define AdvIsIntPending(port) \
     (AdvReadWordRegister(port, IOPW_CTRL_REG) & ADV_CTRL_REG_HOST_INTR)
 
@@ -1870,14 +1765,11 @@ typedef struct adveep_38C1600_config {
  */
 #define INTAB           0x01
 
-/* a_advlib.h */
-
 /*
  * Adv Library Status Definitions
  */
 #define ADV_TRUE        1
 #define ADV_FALSE       0
-#define ADV_NOERROR     1
 #define ADV_SUCCESS     1
 #define ADV_BUSY        0
 #define ADV_ERROR       (-1)
@@ -1888,7 +1780,6 @@ typedef struct adveep_38C1600_config {
 #define ASC_WARN_BUSRESET_ERROR         0x0001	/* SCSI Bus Reset error */
 #define ASC_WARN_EEPROM_CHKSUM          0x0002	/* EEP check sum error */
 #define ASC_WARN_EEPROM_TERMINATION     0x0004	/* EEP termination bad field */
-#define ASC_WARN_SET_PCI_CONFIG_SPACE   0x0080	/* PCI config space set error */
 #define ASC_WARN_ERROR                  0xFFFF	/* ADV_ERROR return */
 
 #define ADV_MAX_TID                     15	/* max. target identifier */
@@ -2206,10 +2097,8 @@ typedef struct adv_scsi_req_q {
 /*
  * Wait loop time out values.
  */
-#define SCSI_WAIT_10_SEC             10UL	/* 10 seconds */
 #define SCSI_WAIT_100_MSEC           100UL	/* 100 milliseconds */
 #define SCSI_US_PER_MSEC             1000	/* microseconds per millisecond */
-#define SCSI_MS_PER_SEC              1000UL	/* milliseconds per second */
 #define SCSI_MAX_RETRY               10	/* retry count */
 
 #define ADV_ASYNC_RDMA_FAILURE          0x01	/* Fatal RDMA failure. */
@@ -2443,10 +2332,6 @@ do { \
          (sizeof(ADV_SG_BLOCK) * \
           ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))
 
-/*
- * --- Driver Constants and Macros
- */
-
 /* Reference Scsi_Host hostdata */
 #define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
 
@@ -2792,10 +2677,6 @@ static ASC_SG_HEAD asc_sg_head = { 0 };
 static int asc_dbglvl = 3;
 #endif /* ADVANSYS_DEBUG */
 
-/*
- * --- Driver Function Prototypes
- */
-
 static int advansys_slave_configure(struct scsi_device *);
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *);
 static int asc_build_req(asc_board_t *, struct scsi_cmnd *);
@@ -3358,18 +3239,10 @@ static struct scsi_host_template advansys_template = {
 	.use_clustering = ENABLE_CLUSTERING,
 };
 
-/*
- * --- Miscellaneous Driver Functions
- */
-
 /*
  * First-level interrupt handler.
  *
- * 'dev_id' is a pointer to the interrupting adapter's asc_board_t. Because
- * all boards are currently checked for interrupts on each interrupt, 'dev_id'
- * is not referenced. 'dev_id' could be used to identify an interrupt passed
- * to the AdvanSys driver which is for a device sharing an interrupt with
- * an AdvanSys adapter.
+ * 'dev_id' is a pointer to the interrupting adapter's Scsi_Host.
  */
 static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 {
@@ -3381,9 +3254,6 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	ASC_DBG1(2, "advansys_interrupt: boardp 0x%p\n", boardp);
 	spin_lock_irqsave(&boardp->lock, flags);
 	if (ASC_NARROW_BOARD(boardp)) {
-		/*
-		 * Narrow Board
-		 */
 		if (AscIsIntPending(shost->io_port)) {
 			result = IRQ_HANDLED;
 			ASC_STATS(shost, interrupt);
@@ -3391,23 +3261,14 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 			AscISR(&boardp->dvc_var.asc_dvc_var);
 		}
 	} else {
-		/*
-		 * Wide Board
-		 */
 		ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
 		if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
 			result = IRQ_HANDLED;
 			ASC_STATS(shost, interrupt);
 		}
 	}
-
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	/*
-	 * If interrupts were enabled on entry, then they
-	 * are now enabled here.
-	 */
-
 	ASC_DBG(1, "advansys_interrupt: end\n");
 	return result;
 }
@@ -4110,7 +3971,7 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 	prev_sg_block = NULL;
 	reqp->sgblkp = NULL;
 
-	do {
+	for (;;) {
 		/*
 		 * Allocate a 'adv_sgblk_t' structure from the board free
 		 * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
@@ -4121,8 +3982,8 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 			ASC_STATS(scp->device->host, adv_build_nosg);
 
 			/*
-			 * Allocation failed. Free 'adv_sgblk_t' structures already
-			 * allocated for the request.
+			 * Allocation failed. Free 'adv_sgblk_t' structures
+			 * already allocated for the request.
 			 */
 			while ((sgblkp = reqp->sgblkp) != NULL) {
 				/* Remove 'sgblkp' from the request list. */
@@ -4133,52 +3994,50 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 				boardp->adv_sgblkp = sgblkp;
 			}
 			return ASC_BUSY;
-		} else {
-			/* Complete 'adv_sgblk_t' board allocation. */
-			boardp->adv_sgblkp = sgblkp->next_sgblkp;
-			sgblkp->next_sgblkp = NULL;
+		}
+
+		/* Complete 'adv_sgblk_t' board allocation. */
+		boardp->adv_sgblkp = sgblkp->next_sgblkp;
+		sgblkp->next_sgblkp = NULL;
+
+		/*
+		 * Get 8 byte aligned virtual and physical addresses
+		 * for the allocated ADV_SG_BLOCK structure.
+		 */
+		sg_block = (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);
+		sg_block_paddr = virt_to_bus(sg_block);
+
+		/*
+		 * Check if this is the first 'adv_sgblk_t' for the
+		 * request.
+		 */
+		if (reqp->sgblkp == NULL) {
+			/* Request's first scatter-gather block. */
+			reqp->sgblkp = sgblkp;
 
 			/*
-			 * Get 8 byte aligned virtual and physical addresses for
-			 * the allocated ADV_SG_BLOCK structure.
+			 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
+			 * address pointers.
 			 */
-			sg_block =
-			    (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);
-			sg_block_paddr = virt_to_bus(sg_block);
+			scsiqp->sg_list_ptr = sg_block;
+			scsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);
+		} else {
+			/* Request's second or later scatter-gather block. */
+			sgblkp->next_sgblkp = reqp->sgblkp;
+			reqp->sgblkp = sgblkp;
 
 			/*
-			 * Check if this is the first 'adv_sgblk_t' for the request.
+			 * Point the previous ADV_SG_BLOCK structure to
+			 * the newly allocated ADV_SG_BLOCK structure.
 			 */
-			if (reqp->sgblkp == NULL) {
-				/* Request's first scatter-gather block. */
-				reqp->sgblkp = sgblkp;
-
-				/*
-				 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
-				 * address pointers.
-				 */
-				scsiqp->sg_list_ptr = sg_block;
-				scsiqp->sg_real_addr =
-				    cpu_to_le32(sg_block_paddr);
-			} else {
-				/* Request's second or later scatter-gather block. */
-				sgblkp->next_sgblkp = reqp->sgblkp;
-				reqp->sgblkp = sgblkp;
-
-				/*
-				 * Point the previous ADV_SG_BLOCK structure to
-				 * the newly allocated ADV_SG_BLOCK structure.
-				 */
-				prev_sg_block->sg_ptr =
-				    cpu_to_le32(sg_block_paddr);
-			}
+			prev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);
 		}
 
 		for (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {
 			sg_block->sg_list[i].sg_addr =
-			    cpu_to_le32(sg_dma_address(slp));
+					cpu_to_le32(sg_dma_address(slp));
 			sg_block->sg_list[i].sg_count =
-			    cpu_to_le32(sg_dma_len(slp));
+					cpu_to_le32(sg_dma_len(slp));
 			ASC_STATS_ADD(scp->device->host, sg_xfer,
 				      ASC_CEILING(sg_dma_len(slp), 512));
 
@@ -4192,8 +4051,6 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
 		prev_sg_block = sg_block;
 	}
-	while (1);
-	/* NOTREACHED */
 }
 
 /*
@@ -4264,14 +4121,16 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
 						  sizeof(scp->sense_buffer));
 				/*
-				 * Note: The 'status_byte()' macro used by target drivers
-				 * defined in scsi.h shifts the status byte returned by
-				 * host drivers right by 1 bit. This is why target drivers
-				 * also use right shifted status byte definitions. For
-				 * instance target drivers use CHECK_CONDITION, defined to
-				 * 0x1, instead of the SCSI defined check condition value
-				 * of 0x2. Host drivers are supposed to return the status
-				 * byte as it is defined by SCSI.
+				 * Note: The 'status_byte()' macro used by
+				 * target drivers defined in scsi.h shifts the
+				 * status byte returned by host drivers right
+				 * by 1 bit.  This is why target drivers also
+				 * use right shifted status byte definitions.
+				 * For instance target drivers use
+				 * CHECK_CONDITION, defined to 0x1, instead of
+				 * the SCSI defined check condition value of
+				 * 0x2. Host drivers are supposed to return
+				 * the status byte as it is defined by SCSI.
 				 */
 				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
 				    STATUS_BYTE(qdonep->d3.scsi_stat);
@@ -4411,14 +4270,16 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
 						  sizeof(scp->sense_buffer));
 				/*
-				 * Note: The 'status_byte()' macro used by target drivers
-				 * defined in scsi.h shifts the status byte returned by
-				 * host drivers right by 1 bit. This is why target drivers
-				 * also use right shifted status byte definitions. For
-				 * instance target drivers use CHECK_CONDITION, defined to
-				 * 0x1, instead of the SCSI defined check condition value
-				 * of 0x2. Host drivers are supposed to return the status
-				 * byte as it is defined by SCSI.
+				 * Note: The 'status_byte()' macro used by
+				 * target drivers defined in scsi.h shifts the
+				 * status byte returned by host drivers right
+				 * by 1 bit.  This is why target drivers also
+				 * use right shifted status byte definitions.
+				 * For instance target drivers use
+				 * CHECK_CONDITION, defined to 0x1, instead of
+				 * the SCSI defined check condition value of
+				 * 0x2. Host drivers are supposed to return
+				 * the status byte as it is defined by SCSI.
 				 */
 				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
 				    STATUS_BYTE(scsiqp->scsi_status);
@@ -5718,10 +5579,6 @@ static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
 }
 #endif /* CONFIG_PROC_FS */
 
-/*
- * --- Functions Required by the Asc Library
- */
-
 /*
  * void
  * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
@@ -5814,10 +5671,6 @@ AscGetChipBiosAddress(PortAddr iop_base, unsigned short bus_type)
 	return bios_addr;
 }
 
-/*
- * --- Functions Required by the Adv Library
- */
-
 /*
  * DvcGetPhyAddr()
  *
@@ -5845,10 +5698,6 @@ DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
 	return paddr;
 }
 
-/*
- * --- Tracing and Debugging Functions
- */
-
 #ifdef ADVANSYS_STATS
 #ifdef CONFIG_PROC_FS
 /*
@@ -6322,10 +6171,6 @@ static void asc_prt_hex(char *f, uchar *s, int l)
 }
 #endif /* ADVANSYS_DEBUG */
 
-/*
- * --- Asc Library Functions
- */
-
 static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
 {
 	PortAddr eisa_cfg_iop;
@@ -6537,8 +6382,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 	target_ix = AscReadLramByte(iop_base,
 				    (ushort)(halt_q_addr +
 					     (ushort)ASC_SCSIQ_B_TARGET_IX));
-	q_cntl =
-	    AscReadLramByte(iop_base,
+	q_cntl = AscReadLramByte(iop_base,
 			    (ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));
 	tid_no = ASC_TIX_TO_TID(target_ix);
 	target_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);
@@ -6562,7 +6406,6 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
 		return (0);
 	} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
-
 		AscMemWordCopyPtrFromLram(iop_base,
 					  ASCV_MSGIN_BEG,
 					  (uchar *)&ext_msg,
@@ -6793,9 +6636,9 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 							 cur_dvc_qng);
 
 					/*
-					 * Set the device queue depth to the number of
-					 * active requests when the QUEUE FULL condition
-					 * was encountered.
+					 * Set the device queue depth to the
+					 * number of active requests when the
+					 * QUEUE FULL condition was encountered.
 					 */
 					boardp->queue_full |= target_id;
 					boardp->queue_full_cnt[tid_no] =
@@ -6821,9 +6664,8 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 		int i;
 
 		q_no = AscReadLramByte(iop_base, (ushort)ASCV_REQ_SG_LIST_QP);
-		if (q_no == ASC_QLINK_END) {
-			return (0);
-		}
+		if (q_no == ASC_QLINK_END)
+			return 0;
 
 		q_addr = ASC_QNO_TO_QADDR(q_no);
 
@@ -6875,8 +6717,8 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 			sg_entry_cnt = ASC_MAX_SG_LIST - 1;
 
 			/*
-			 * Keep track of remaining number of SG elements that will
-			 * need to be handled on the next interrupt.
+			 * Keep track of remaining number of SG elements that
+			 * will need to be handled on the next interrupt.
 			 */
 			scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
 		} else {
@@ -7723,36 +7565,28 @@ AscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)
 	sta = 0;
 	free_q_head = (uchar)AscGetVarFreeQHead(iop_base);
 	if (n_q_required > 1) {
-		if ((next_qp = AscAllocMultipleFreeQueue(iop_base,
-							 free_q_head, (uchar)
-							 (n_q_required)))
-		    != (uchar)ASC_QLINK_END) {
+		next_qp = AscAllocMultipleFreeQueue(iop_base, free_q_head,
+						    (uchar)n_q_required);
+		if (next_qp != ASC_QLINK_END) {
 			asc_dvc->last_q_shortage = 0;
 			scsiq->sg_head->queue_cnt = n_q_required - 1;
 			scsiq->q1.q_no = free_q_head;
-			if ((sta = AscPutReadySgListQueue(asc_dvc, scsiq,
-							  free_q_head)) == 1) {
-				AscPutVarFreeQHead(iop_base, next_qp);
-				asc_dvc->cur_total_qng += (uchar)(n_q_required);
-				asc_dvc->cur_dvc_qng[tid_no]++;
-			}
-			return (sta);
+			sta = AscPutReadySgListQueue(asc_dvc, scsiq,
+						     free_q_head);
 		}
 	} else if (n_q_required == 1) {
-		if ((next_qp = AscAllocFreeQueue(iop_base,
-						 free_q_head)) !=
-		    ASC_QLINK_END) {
+		next_qp = AscAllocFreeQueue(iop_base, free_q_head);
+		if (next_qp != ASC_QLINK_END) {
 			scsiq->q1.q_no = free_q_head;
-			if ((sta = AscPutReadyQueue(asc_dvc, scsiq,
-						    free_q_head)) == 1) {
-				AscPutVarFreeQHead(iop_base, next_qp);
-				asc_dvc->cur_total_qng++;
-				asc_dvc->cur_dvc_qng[tid_no]++;
-			}
-			return (sta);
+			sta = AscPutReadyQueue(asc_dvc, scsiq, free_q_head);
 		}
 	}
-	return (sta);
+	if (sta == 1) {
+		AscPutVarFreeQHead(iop_base, next_qp);
+		asc_dvc->cur_total_qng += (uchar)(n_q_required);
+		asc_dvc->cur_dvc_qng[tid_no]++;
+	}
+	return sta;
 }
 
 static int AscSgListToQueue(int sg_list)
@@ -8072,7 +7906,7 @@ static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static ushort AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
+static void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
 {
 	PortAddr iop_base;
 	int i;
@@ -8099,7 +7933,6 @@ static ushort AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
 	for (i = 0; i < 32; i++, lram_addr += 2) {
 		AscWriteLramWord(iop_base, lram_addr, 0);
 	}
-	return (0);
 }
 
 static int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)
@@ -8396,10 +8229,10 @@ static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
 static ASC_DCNT __devinit AscGetMaxDmaCount(ushort bus_type)
 {
 	if (bus_type & ASC_IS_ISA)
-		return (ASC_MAX_ISA_DMA_COUNT);
+		return ASC_MAX_ISA_DMA_COUNT;
 	else if (bus_type & (ASC_IS_EISA | ASC_IS_VL))
-		return (ASC_MAX_VL_DMA_COUNT);
-	return (ASC_MAX_PCI_DMA_COUNT);
+		return ASC_MAX_VL_DMA_COUNT;
+	return ASC_MAX_PCI_DMA_COUNT;
 }
 
 #ifdef CONFIG_ISA
@@ -9262,26 +9095,22 @@ static void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)
 	char type = sdev->type;
 	ASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;
 
-	if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN) {
-		if (!(asc_dvc->init_sdtr & tid_bits)) {
-			if ((type == TYPE_ROM) &&
-			    (strncmp(sdev->vendor, "HP ", 3) == 0)) {
-				asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
-			}
-			asc_dvc->pci_fix_asyn_xfer |= tid_bits;
-			if ((type == TYPE_PROCESSOR) ||
-			    (type == TYPE_SCANNER) || (type == TYPE_ROM) ||
-			    (type == TYPE_TAPE)) {
-				asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
-			}
+	if (!(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN))
+		return;
+	if (asc_dvc->init_sdtr & tid_bits)
+		return;
+
+	if ((type == TYPE_ROM) && (strncmp(sdev->vendor, "HP ", 3) == 0))
+		asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
+
+	asc_dvc->pci_fix_asyn_xfer |= tid_bits;
+	if ((type == TYPE_PROCESSOR) || (type == TYPE_SCANNER) ||
+	    (type == TYPE_ROM) || (type == TYPE_TAPE))
+		asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
 
-			if (asc_dvc->pci_fix_asyn_xfer & tid_bits) {
-				AscSetRunChipSynRegAtID(asc_dvc->iop_base,
-					sdev->id,
+	if (asc_dvc->pci_fix_asyn_xfer & tid_bits)
+		AscSetRunChipSynRegAtID(asc_dvc->iop_base, sdev->id,
 					ASYN_SDTR_DATA_FIX_PCI_REV_AB);
-			}
-		}
-	}
 }
 
 static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
@@ -9443,12 +9272,6 @@ AscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)
 	return;
 }
 
-/*
- * --- Adv Library Functions
- */
-
-/* a_mcode.h */
-
 /* Microcode buffer is kept after initialization for error recovery. */
 static unsigned char _adv_asc3550_buf[] = {
 	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0x16, 0x18, 0xe4, 0x00, 0xfc,
@@ -13773,7 +13596,6 @@ AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 	return;
 }
 
-/* a_advlib.c */
 /*
  * AdvExeScsiQueue() - Send a request to the RISC microcode program.
  *
@@ -14198,7 +14020,6 @@ AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
 	 * Clear the idle command status which is set by the microcode
 	 * to a non-zero value to indicate when the command is completed.
 	 * The non-zero result is one of the IDLE_CMD_STATUS_* values
-	 * defined in a_advlib.h.
 	 */
 	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);
 
@@ -14921,6 +14742,8 @@ static int advansys_release(struct Scsi_Host *shost)
 	return 0;
 }
 
+#define ASC_IOADR_TABLE_MAX_IX  11
+
 static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __devinitdata = {
 	0x100, 0x0110, 0x120, 0x0130, 0x140, 0x0150, 0x0190,
 	0x0210, 0x0230, 0x0250, 0x0330

commit b009bef6cd2c6c2b870088d9ae67dbc4ec2ca317
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:38 2007 -0600

    [SCSI] advansys: Remove some custom wrappers
    
     - Replace ASC_ASSERT() with BUG_ON().
       In a few places, get rid of the assertion altogether -- the ensuing
       crash will tell us all we need to know.  Use BUG() where it fits better
       than BUG_ON().  Also fix a fencepost error in advansys_proc_info().
     - Replace DvcSleepMilliSecond with mdelay.
       Despite its name using 'sleep', the implementation was a delay.
       I've marked some places with XXX where we should probably be using
       msleep instead.  They need to be audited to be sure we can sleep in
       that context.
     - Replace DvcDelayMicroSecond with udelay.
     - Replace DvcDelayNanoSecond with udelay too.
       All callers were multiples of 1000.
     - Remove DvcEnterCritical and DvcLeaveCritical.
       These functions are no-ops, and as the comments said, the spinlock
       protects the critical sections.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 60a918820d0d..9c5d37d9c79a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -70,9 +70,6 @@
  */
 #warning this driver is still not properly converted to the DMA API
 
-/* Enable driver assertions. */
-#define ADVANSYS_ASSERT
-
 /* Enable driver /proc statistics. */
 #define ADVANSYS_STATS
 
@@ -1121,10 +1118,6 @@ static uchar AscGetChipScsiCtrl(PortAddr);
 static uchar AscGetChipVersion(PortAddr, ushort);
 static ASC_DCNT AscLoadMicroCode(PortAddr, ushort, uchar *, ushort);
 static void AscToggleIRQAct(PortAddr);
-static inline ulong DvcEnterCritical(void);
-static inline void DvcLeaveCritical(ulong);
-static void DvcSleepMilliSecond(ASC_DCNT);
-static void DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
 static void DvcPutScsiQ(PortAddr, ushort, uchar *, int);
 static void DvcGetQinfo(PortAddr, ushort, uchar *, int);
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *);
@@ -2226,15 +2219,8 @@ typedef struct adv_scsi_req_q {
 
 #define ADV_HOST_SCSI_BUS_RESET      0x80	/* Host Initiated SCSI Bus Reset. */
 
-/*
- * Device drivers must define the following functions.
- */
-static inline ulong DvcEnterCritical(void);
-static inline void DvcLeaveCritical(ulong);
-static void DvcSleepMilliSecond(ADV_DCNT);
 static ADV_PADDR DvcGetPhyAddr(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *,
 			       uchar *, ASC_SDCNT *, int);
-static void DvcDelayMicroSecond(ADV_DVC_VAR *, ushort);
 
 /*
  * Adv Library functions available to drivers.
@@ -2670,24 +2656,6 @@ do { \
         ASC_DBG_PRT_HEX((lvl), "INQUIRY", (uchar *) (inq), (len));
 #endif /* ADVANSYS_DEBUG */
 
-#ifndef ADVANSYS_ASSERT
-#define ASC_ASSERT(a)
-#else /* ADVANSYS_ASSERT */
-
-#define ASC_ASSERT(a) \
-    { \
-        if (!(a)) { \
-            printk("ASC_ASSERT() Failure: file %s, line %d\n", \
-                __FILE__, __LINE__); \
-        } \
-    }
-
-#endif /* ADVANSYS_ASSERT */
-
-/*
- * --- Driver Structures
- */
-
 #ifdef ADVANSYS_STATS
 
 /* Per board statistics structure */
@@ -2949,7 +2917,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	if (ASC_WIDE_BOARD(boardp)) {
 		cp = boardp->prtbuf;
 		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
-		ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+		BUG_ON(cplen >= ASC_PRTBUF_SIZE);
 		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
 				  cplen);
 		totcnt += cnt;
@@ -2967,7 +2935,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	cp = boardp->prtbuf;
 	cplen = asc_prt_board_devices(shost, cp, ASC_PRTBUF_SIZE);
-	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
 	leftlen -= cnt;
@@ -2987,7 +2955,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	} else {
 		cplen = asc_prt_adv_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
 	}
-	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
 	leftlen -= cnt;
@@ -3003,7 +2971,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	cp = boardp->prtbuf;
 	cplen = asc_prt_driver_conf(shost, cp, ASC_PRTBUF_SIZE);
-	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
 	leftlen -= cnt;
@@ -3020,7 +2988,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	cp = boardp->prtbuf;
 	cplen = asc_prt_board_stats(shost, cp, ASC_PRTBUF_SIZE);
-	ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
 	leftlen -= cnt;
@@ -3042,7 +3010,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	} else {
 		cplen = asc_prt_adv_board_info(shost, cp, ASC_PRTBUF_SIZE);
 	}
-	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	BUG_ON(cplen >= ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
 	leftlen -= cnt;
@@ -3139,7 +3107,7 @@ static const char *advansys_info(struct Scsi_Host *shost)
 			ASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,
 			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, shost->irq);
 	}
-	ASC_ASSERT(strlen(info) < ASC_INFO_SIZE);
+	BUG_ON(strlen(info) >= ASC_INFO_SIZE);
 	ASC_DBG(1, "advansys_info: end\n");
 	return info;
 }
@@ -4201,7 +4169,6 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
 				 * Point the previous ADV_SG_BLOCK structure to
 				 * the newly allocated ADV_SG_BLOCK structure.
 				 */
-				ASC_ASSERT(prev_sg_block != NULL);
 				prev_sg_block->sg_ptr =
 				    cpu_to_le32(sg_block_paddr);
 			}
@@ -4262,7 +4229,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
 
 	boardp = ASC_BOARDP(shost);
-	ASC_ASSERT(asc_dvc_varp == &boardp->dvc_var.asc_dvc_var);
+	BUG_ON(asc_dvc_varp != &boardp->dvc_var.asc_dvc_var);
 
 	/*
 	 * 'qdonep' contains the command's ending status.
@@ -4408,7 +4375,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
 
 	boardp = ASC_BOARDP(shost);
-	ASC_ASSERT(adv_dvc_varp == &boardp->dvc_var.adv_dvc_var);
+	BUG_ON(adv_dvc_varp != &boardp->dvc_var.adv_dvc_var);
 
 	/*
 	 * 'done_status' contains the command's ending status.
@@ -5738,7 +5705,7 @@ static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
 
 	va_start(args, fmt);
 	ret = vsprintf(s, fmt, args);
-	ASC_ASSERT(ret < ASC_PRTLINE_SIZE);
+	BUG_ON(ret >= ASC_PRTLINE_SIZE);
 	if (buf == NULL) {
 		(void)printk(s);
 		ret = 0;
@@ -5755,36 +5722,6 @@ static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
  * --- Functions Required by the Asc Library
  */
 
-/*
- * Delay for 'n' milliseconds. Don't use the 'jiffies'
- * global variable which is incremented once every 5 ms
- * from a timer interrupt, because this function may be
- * called when interrupts are disabled.
- */
-static void DvcSleepMilliSecond(ADV_DCNT n)
-{
-	ASC_DBG1(4, "DvcSleepMilliSecond: %lu\n", (ulong)n);
-	mdelay(n);
-}
-
-/*
- * Currently and inline noop but leave as a placeholder.
- * Leave DvcEnterCritical() as a noop placeholder.
- */
-static inline ulong DvcEnterCritical(void)
-{
-	return 0;
-}
-
-/*
- * Critical sections are all protected by the board spinlock.
- * Leave DvcLeaveCritical() as a noop placeholder.
- */
-static inline void DvcLeaveCritical(ulong flags)
-{
-	return;
-}
-
 /*
  * void
  * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
@@ -6317,10 +6254,9 @@ static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
 	       (ulong)b, sgblockno);
 	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
 	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
-	ASC_ASSERT(b->sg_cnt <= NO_OF_SG_PER_BLOCK);
-	if (b->sg_ptr != 0) {
-		ASC_ASSERT(b->sg_cnt == NO_OF_SG_PER_BLOCK);
-	}
+	BUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);
+	if (b->sg_ptr != 0)
+		BUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);
 	for (i = 0; i < b->sg_cnt; i++) {
 		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
 		       i, (ulong)b->sg_list[i].sg_addr,
@@ -6590,7 +6526,7 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 	uchar scsi_status;
 	asc_board_t *boardp;
 
-	ASC_ASSERT(asc_dvc->drv_ptr != NULL);
+	BUG_ON(!asc_dvc->drv_ptr);
 	boardp = asc_dvc->drv_ptr;
 
 	iop_base = asc_dvc->iop_base;
@@ -7199,7 +7135,7 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 					AscSetChipControl(iop_base,
 							  (uchar)(CC_SCSI_RESET
 								  | CC_HALT));
-					DvcDelayNanoSecond(asc_dvc, 60000);
+					udelay(60);
 					AscSetChipControl(iop_base, CC_HALT);
 					AscSetChipStatus(iop_base,
 							 CIW_CLR_SCSI_RESET_INT);
@@ -7276,7 +7212,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 			saved_ctrl_reg &= (uchar)(~CC_HALT);
 			while ((AscGetChipStatus(iop_base) &
 				CSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {
-				DvcSleepMilliSecond(100);
+				mdelay(100);
 			}
 			AscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));
 			AscSetChipControl(iop_base, CC_HALT);
@@ -7549,7 +7485,6 @@ static uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] = {
 static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 {
 	PortAddr iop_base;
-	ulong last_int_level;
 	int sta;
 	int n_q_required;
 	int disable_syn_offset_one_fix;
@@ -7593,9 +7528,7 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			scsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);
 		}
 	}
-	last_int_level = DvcEnterCritical();
 	if (asc_dvc->in_critical_cnt != 0) {
-		DvcLeaveCritical(last_int_level);
 		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
 		return (ERR);
 	}
@@ -7603,13 +7536,11 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
 		if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
 			asc_dvc->in_critical_cnt--;
-			DvcLeaveCritical(last_int_level);
 			return (ERR);
 		}
 #if !CC_VERY_LONG_SG_LIST
 		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
 			asc_dvc->in_critical_cnt--;
-			DvcLeaveCritical(last_int_level);
 			return (ERR);
 		}
 #endif /* !CC_VERY_LONG_SG_LIST */
@@ -7724,7 +7655,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			     AscSendScsiQueue(asc_dvc, scsiq,
 					      n_q_required)) == 1) {
 				asc_dvc->in_critical_cnt--;
-				DvcLeaveCritical(last_int_level);
 				return (sta);
 			}
 		}
@@ -7769,13 +7699,11 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
 						    n_q_required)) == 1) {
 				asc_dvc->in_critical_cnt--;
-				DvcLeaveCritical(last_int_level);
 				return (sta);
 			}
 		}
 	}
 	asc_dvc->in_critical_cnt--;
-	DvcLeaveCritical(last_int_level);
 	return (sta);
 }
 
@@ -8308,7 +8236,7 @@ static int AscHostReqRiscHalt(PortAddr iop_base)
 			sta = 1;
 			break;
 		}
-		DvcSleepMilliSecond(100);
+		mdelay(100);
 	} while (count++ < 20);
 	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
 	return (sta);
@@ -8326,22 +8254,12 @@ static int AscStopQueueExe(PortAddr iop_base)
 			    ASC_STOP_ACK_RISC_STOP) {
 				return (1);
 			}
-			DvcSleepMilliSecond(100);
+			mdelay(100);
 		} while (count++ < 20);
 	}
 	return (0);
 }
 
-static void DvcDelayMicroSecond(ADV_DVC_VAR *asc_dvc, ushort micro_sec)
-{
-	udelay(micro_sec);
-}
-
-static void DvcDelayNanoSecond(ASC_DVC_VAR *asc_dvc, ASC_DCNT nano_sec)
-{
-	udelay((nano_sec + 999) / 1000);
-}
-
 static int AscStartChip(PortAddr iop_base)
 {
 	AscSetChipControl(iop_base, 0);
@@ -8460,16 +8378,16 @@ static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
 	iop_base = asc_dvc->iop_base;
 	while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)
 	       && (i-- > 0)) {
-		DvcSleepMilliSecond(100);
+		mdelay(100);
 	}
 	AscStopChip(iop_base);
 	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);
-	DvcDelayNanoSecond(asc_dvc, 60000);
+	udelay(60);
 	AscSetChipIH(iop_base, INS_RFLAG_WTM);
 	AscSetChipIH(iop_base, INS_HALT);
 	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);
 	AscSetChipControl(iop_base, CC_HALT);
-	DvcSleepMilliSecond(200);
+	mdelay(200);
 	AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
 	AscSetChipStatus(iop_base, 0);
 	return (AscIsChipHalted(iop_base));
@@ -8711,8 +8629,7 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	if ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&
 	    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {
 		AscResetChipAndScsiBus(asc_dvc);
-		DvcSleepMilliSecond((ASC_DCNT)
-				    ((ushort)asc_dvc->scsi_reset_wait * 1000));
+		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
 	}
 	asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
 	if (asc_dvc->err_code != 0)
@@ -8869,8 +8786,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	    (AscGetChipScsiCtrl(iop_base) != 0)) {
 		asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
 		AscResetChipAndScsiBus(asc_dvc);
-		DvcSleepMilliSecond((ASC_DCNT)
-				    ((ushort)asc_dvc->scsi_reset_wait * 1000));
+		mdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */
 	}
 	if (AscIsChipHalted(iop_base) == FALSE) {
 		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
@@ -9084,7 +9000,7 @@ static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 	saved_word = AscReadLramWord(iop_base, q_addr);
 	AscSetChipLramAddr(iop_base, q_addr);
 	AscSetChipLramData(iop_base, 0x55AA);
-	DvcSleepMilliSecond(10);
+	mdelay(10);
 	AscSetChipLramAddr(iop_base, q_addr);
 	if (AscGetChipLramData(iop_base) == 0x55AA) {
 		sta = 1;
@@ -9101,7 +9017,7 @@ static int __devinit AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
 	retry = 0;
 	while (TRUE) {
 		AscSetChipEEPCmd(iop_base, cmd_reg);
-		DvcSleepMilliSecond(1);
+		mdelay(1);
 		read_back = AscGetChipEEPCmd(iop_base);
 		if (read_back == cmd_reg) {
 			return (1);
@@ -9120,7 +9036,7 @@ static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 	retry = 0;
 	while (TRUE) {
 		AscSetChipEEPData(iop_base, data_reg);
-		DvcSleepMilliSecond(1);
+		mdelay(1);
 		read_back = AscGetChipEEPData(iop_base);
 		if (read_back == data_reg) {
 			return (1);
@@ -9133,13 +9049,13 @@ static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 
 static void __devinit AscWaitEEPRead(void)
 {
-	DvcSleepMilliSecond(1);
+	mdelay(1);
 	return;
 }
 
 static void __devinit AscWaitEEPWrite(void)
 {
-	DvcSleepMilliSecond(20);
+	mdelay(20);
 	return;
 }
 
@@ -11364,7 +11280,7 @@ AdvInitGetConfig(struct pci_dev *pdev, asc_board_t *boardp)
 		 */
 		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
 				     ADV_CTRL_REG_CMD_RESET);
-		DvcSleepMilliSecond(100);
+		mdelay(100);
 		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
 				     ADV_CTRL_REG_CMD_WR_IO_REG);
 
@@ -12048,7 +11964,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	 */
 	for (i = 0; i < 2; i++) {
 		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
-		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		mdelay(10);	/* Wait for 10ms before reading back. */
 		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
 		if ((byte & RAM_TEST_DONE) == 0
 		    || (byte & 0x0F) != PRE_TEST_VALUE) {
@@ -12057,7 +11973,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 		}
 
 		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		mdelay(10);	/* Wait for 10ms before reading back. */
 		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
 		    != NORMAL_VALUE) {
 			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
@@ -12073,7 +11989,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	 * err_code, and return an error.
 	 */
 	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
-	DvcSleepMilliSecond(10);	/* Wait for 10ms before checking status. */
+	mdelay(10);	/* Wait for 10ms before checking status. */
 
 	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
 	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
@@ -12529,7 +12445,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	 */
 	for (i = 0; i < 2; i++) {
 		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
-		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		mdelay(10);	/* Wait for 10ms before reading back. */
 		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
 		if ((byte & RAM_TEST_DONE) == 0
 		    || (byte & 0x0F) != PRE_TEST_VALUE) {
@@ -12538,7 +12454,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 		}
 
 		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		mdelay(10);	/* Wait for 10ms before reading back. */
 		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
 		    != NORMAL_VALUE) {
 			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
@@ -12554,7 +12470,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	 * err_code, and return an error.
 	 */
 	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
-	DvcSleepMilliSecond(10);	/* Wait for 10ms before checking status. */
+	mdelay(10);	/* Wait for 10ms before checking status. */
 
 	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
 	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
@@ -13645,12 +13561,11 @@ static void __devinit AdvWaitEEPCmd(AdvPortAddr iop_base)
 		    ASC_EEP_CMD_DONE) {
 			break;
 		}
-		DvcSleepMilliSecond(1);
+		mdelay(1);
 	}
 	if ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==
-	    0) {
-		ASC_ASSERT(0);
-	}
+	    0)
+		BUG();
 	return;
 }
 
@@ -13688,7 +13603,7 @@ AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
 				     ASC_EEP_CMD_WRITE | addr);
 		AdvWaitEEPCmd(iop_base);
-		DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+		mdelay(ADV_EEP_DELAY_MS);
 	}
 
 	/*
@@ -13756,7 +13671,7 @@ AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
 				     ASC_EEP_CMD_WRITE | addr);
 		AdvWaitEEPCmd(iop_base);
-		DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+		mdelay(ADV_EEP_DELAY_MS);
 	}
 
 	/*
@@ -13824,7 +13739,7 @@ AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
 				     ASC_EEP_CMD_WRITE | addr);
 		AdvWaitEEPCmd(iop_base);
-		DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+		mdelay(ADV_EEP_DELAY_MS);
 	}
 
 	/*
@@ -13882,14 +13797,11 @@ AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
  */
 static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 {
-	ulong last_int_level;
 	AdvPortAddr iop_base;
 	ADV_DCNT req_size;
 	ADV_PADDR req_paddr;
 	ADV_CARR_T *new_carrp;
 
-	ASC_ASSERT(scsiq != NULL);	/* 'scsiq' should never be NULL. */
-
 	/*
 	 * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
 	 */
@@ -13901,14 +13813,11 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 
 	iop_base = asc_dvc->iop_base;
 
-	last_int_level = DvcEnterCritical();
-
 	/*
 	 * Allocate a carrier ensuring at least one carrier always
 	 * remains on the freelist and initialize fields.
 	 */
 	if ((new_carrp = asc_dvc->carr_freelist) == NULL) {
-		DvcLeaveCritical(last_int_level);
 		return ADV_BUSY;
 	}
 	asc_dvc->carr_freelist = (ADV_CARR_T *)
@@ -13931,8 +13840,8 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *)scsiq,
 				  (ADV_SDCNT *)&req_size, ADV_IS_SCSIQ_FLAG);
 
-	ASC_ASSERT(ADV_32BALIGN(req_paddr) == req_paddr);
-	ASC_ASSERT(req_size >= sizeof(ADV_SCSI_REQ_Q));
+	BUG_ON(req_paddr & 31);
+	BUG_ON(req_size < sizeof(ADV_SCSI_REQ_Q));
 
 	/* Wait for assertion before making little-endian */
 	req_paddr = cpu_to_le32(req_paddr);
@@ -13991,8 +13900,6 @@ static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 				      le32_to_cpu(new_carrp->carr_pa));
 	}
 
-	DvcLeaveCritical(last_int_level);
-
 	return ADV_SUCCESS;
 }
 
@@ -14024,7 +13931,7 @@ static int AdvResetSB(ADV_DVC_VAR *asc_dvc)
 	 * The hold time delay is done on the host because the RISC has no
 	 * microsecond accurate timer.
 	 */
-	DvcDelayMicroSecond(asc_dvc, (ushort)ASC_SCSI_RESET_HOLD_TIME_US);
+	udelay(ASC_SCSI_RESET_HOLD_TIME_US);
 
 	/*
 	 * Send the SCSI Bus Reset end idle command which de-asserts
@@ -14035,7 +13942,7 @@ static int AdvResetSB(ADV_DVC_VAR *asc_dvc)
 		return status;
 	}
 
-	DvcSleepMilliSecond((ADV_DCNT)asc_dvc->scsi_reset_wait * 1000);
+	mdelay(asc_dvc->scsi_reset_wait * 1000);	/* XXX: msleep? */
 
 	return status;
 }
@@ -14086,7 +13993,7 @@ static int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
 	 */
 	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);
 	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
-	DvcSleepMilliSecond(100);
+	mdelay(100);
 	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
 			     ADV_CTRL_REG_CMD_WR_IO_REG);
 
@@ -14158,11 +14065,8 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 	ushort target_bit;
 	ADV_CARR_T *free_carrp;
 	ADV_VADDR irq_next_vpa;
-	int flags;
 	ADV_SCSI_REQ_Q *scsiq;
 
-	flags = DvcEnterCritical();
-
 	iop_base = asc_dvc->iop_base;
 
 	/* Reading the register clears the interrupt. */
@@ -14170,7 +14074,6 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 
 	if ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |
 			 ADV_INTR_STATUS_INTRC)) == 0) {
-		DvcLeaveCritical(flags);
 		return ADV_FALSE;
 	}
 
@@ -14243,7 +14146,6 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		asc_dvc->carr_freelist = free_carrp;
 		asc_dvc->carr_pending_cnt--;
 
-		ASC_ASSERT(scsiq != NULL);
 		target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);
 
 		/*
@@ -14264,18 +14166,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * Fall through and continue processing other completed
 		 * requests...
 		 */
-
-		/*
-		 * Disable interrupts again in case the driver inadvertently
-		 * enabled interrupts in its callback function.
-		 *
-		 * The DvcEnterCritical() return value is ignored, because
-		 * the 'flags' saved when AdvISR() was first entered will be
-		 * used to restore the interrupt flag on exit.
-		 */
-		(void)DvcEnterCritical();
 	}
-	DvcLeaveCritical(flags);
 	return ADV_TRUE;
 }
 
@@ -14297,13 +14188,10 @@ static int
 AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
 	       ushort idle_cmd, ADV_DCNT idle_cmd_parameter)
 {
-	ulong last_int_level;
 	int result;
 	ADV_DCNT i, j;
 	AdvPortAddr iop_base;
 
-	last_int_level = DvcEnterCritical();
-
 	iop_base = asc_dvc->iop_base;
 
 	/*
@@ -14343,16 +14231,13 @@ AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
 		for (j = 0; j < SCSI_US_PER_MSEC; j++) {
 			AdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,
 					result);
-			if (result != 0) {
-				DvcLeaveCritical(last_int_level);
+			if (result != 0)
 				return result;
-			}
-			DvcDelayMicroSecond(asc_dvc, (ushort)1);
+			udelay(1);
 		}
 	}
 
-	ASC_ASSERT(0);		/* The idle command should never timeout. */
-	DvcLeaveCritical(last_int_level);
+	BUG();		/* The idle command should never timeout. */
 	return ADV_ERROR;
 }
 

commit faac48ecf475c8e214190dabe600585e0bd4f455
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:37 2007 -0600

    [SCSI] advansys: Remove a check for an impossible condition
    
    AscExeScsiQueue() has one caller, and it passes the address of a
    variable; this cannot ever be NULL.  This is the only place that ever
    sets ASCQ_ERR_SCSIQ_NULL_PTR, so delete that error code too, as well as
    several other unused ASCQ_ERR codes.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index ef4f6790a251..60a918820d0d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -520,14 +520,6 @@ typedef struct asc_risc_sg_list_q {
 #define ASCQ_ERR_ISR_RE_ENTRY         0x1A
 #define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B
 #define ASCQ_ERR_ISR_ON_CRITICAL      0x1C
-#define ASCQ_ERR_SG_LIST_ODD_ADDRESS  0x1D
-#define ASCQ_ERR_XFER_ADDRESS_TOO_BIG 0x1E
-#define ASCQ_ERR_SCSIQ_NULL_PTR       0x1F
-#define ASCQ_ERR_SCSIQ_BAD_NEXT_PTR   0x20
-#define ASCQ_ERR_GET_NUM_OF_FREE_Q    0x21
-#define ASCQ_ERR_SEND_SCSI_Q          0x22
-#define ASCQ_ERR_HOST_REQ_RISC_HALT   0x23
-#define ASCQ_ERR_RESET_SDTR           0x24
 
 /*
  * Warning code values are set in ASC_DVC_VAR  'warn_code'.
@@ -7578,10 +7570,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	sg_head = scsiq->sg_head;
 	if (asc_dvc->err_code != 0)
 		return (ERR);
-	if (scsiq == (ASC_SCSI_Q *)0L) {
-		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_SCSIQ_NULL_PTR);
-		return (ERR);
-	}
 	scsiq->q1.q_no = 0;
 	if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
 		scsiq->q1.extra_bytes = 0;

commit f05ec594fed6890d38bb8767676f626a4035ba55
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:36 2007 -0600

    [SCSI] advansys: Support 16-byte commands properly
    
    The SCSI midlayer won't send commands greater than ->max_cmd_len.
    So the checks on length in asc_build_req and adv_build_req are obsolete
    and can be deleted, but also we have to set the max_cmd_len in
    advansys_board_found().  Also move the length definitions together, and
    write a helpful comment.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d7bc0cf72134..ef4f6790a251 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -210,9 +210,15 @@ typedef unsigned char uchar;
 #define ASC_SCSI_WIDTH_BIT_SET  0xFF
 #define ASC_MAX_SENSE_LEN   32
 #define ASC_MIN_SENSE_LEN   14
-#define ASC_MAX_CDB_LEN     12
 #define ASC_SCSI_RESET_HOLD_TIME_US  60
 
+/*
+ * Narrow boards only support 12-byte commands, while wide boards
+ * extend to 16-byte commands.
+ */
+#define ASC_MAX_CDB_LEN     12
+#define ADV_MAX_CDB_LEN     16
+
 /*
  * Inquiry SPC-2 SPI Byte 1 EVPD (Enable Vital Product Data)
  * and CmdDt (Command Support Data) field bit definitions.
@@ -1189,12 +1195,6 @@ static const char *advansys_info(struct Scsi_Host *shost);
 
 #define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 15)
 
-/*
- * For wide  boards a CDB length maximum of 16 bytes
- * is supported.
- */
-#define ADV_MAX_CDB_LEN     16
-
 /*
  * Define total number of simultaneous maximum element scatter-gather
  * request blocks per wide adapter. ASC_DEF_MAX_HOST_QNG (253) is the
@@ -3856,17 +3856,7 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 
 	/*
 	 * Build the ASC_SCSI_Q request.
-	 *
-	 * For narrow boards a CDB length maximum of 12 bytes
-	 * is supported.
 	 */
-	if (scp->cmd_len > ASC_MAX_CDB_LEN) {
-		ASC_PRINT3("asc_build_req: board %d: cmd_len %d > "
-			"ASC_MAX_CDB_LEN %d\n", boardp->id, scp->cmd_len,
-			ASC_MAX_CDB_LEN);
-		scp->result = HOST_BYTE(DID_ERROR);
-		return ASC_ERROR;
-	}
 	asc_scsi_q.cdbptr = &scp->cmnd[0];
 	asc_scsi_q.q2.cdb_len = scp->cmd_len;
 	asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
@@ -4029,18 +4019,7 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 	 * Build the ADV_SCSI_REQ_Q request.
 	 */
 
-	/*
-	 * Set CDB length and copy it to the request structure.
-	 * For wide  boards a CDB length maximum of 16 bytes
-	 * is supported.
-	 */
-	if (scp->cmd_len > ADV_MAX_CDB_LEN) {
-		ASC_PRINT3
-		    ("adv_build_req: board %d: cmd_len %d > ADV_MAX_CDB_LEN  %d\n",
-		     boardp->id, scp->cmd_len, ADV_MAX_CDB_LEN);
-		scp->result = HOST_BYTE(DID_ERROR);
-		return ASC_ERROR;
-	}
+	/* Set CDB length and copy it to the request structure.  */
 	scsiqp->cdb_len = scp->cmd_len;
 	/* Copy first 12 CDB bytes to cdb[]. */
 	for (i = 0; i < scp->cmd_len && i < 12; i++) {
@@ -14834,6 +14813,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	if (ASC_NARROW_BOARD(boardp)) {
 		shost->max_id = ASC_MAX_TID + 1;
 		shost->max_lun = ASC_MAX_LUN + 1;
+		shost->max_cmd_len = ASC_MAX_CDB_LEN;
 
 		shost->io_port = asc_dvc_varp->iop_base;
 		boardp->asc_n_io_port = ASC_IOADR_GAP;
@@ -14844,6 +14824,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	} else {
 		shost->max_id = ADV_MAX_TID + 1;
 		shost->max_lun = ADV_MAX_LUN + 1;
+		shost->max_cmd_len = ADV_MAX_CDB_LEN;
 
 		/*
 		 * Save the I/O Port address and length even though

commit b2a7a4ba0497f73295e3f4d20a8cedb1e3d2b1a7
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:35 2007 -0600

    [SCSI] advansys: Enable interrupts earlier in queuecommand
    
    Move as much as possible outside the critical section in queuecommand, eg:
     - Set the scsi_done field before acquiring the lock
     - Call asc_scsi_done after dropping the lock
    
    Also remove a comment suggesting we should enable interrupts (now we do)
    and do some minor reformatting for readability.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 67cdfe6201ce..d7bc0cf72134 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3176,23 +3176,24 @@ static void asc_scsi_done(struct scsi_cmnd *scp)
  * in the 'scp' result field.
  */
 static int
-advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
+advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
-	struct Scsi_Host *shost;
-	asc_board_t *boardp;
-	ulong flags;
+	struct Scsi_Host *shost = scp->device->host;
+	asc_board_t *boardp = ASC_BOARDP(shost);
+	unsigned long flags;
 	int asc_res, result = 0;
 
-	shost = scp->device->host;
-	boardp = ASC_BOARDP(shost);
 	ASC_STATS(shost, queuecommand);
+	scp->scsi_done = done;
 
-	/* host_lock taken by mid-level prior to call but need to protect */
-	/* against own ISR */
+	/*
+	 * host_lock taken by mid-level prior to call, but need
+	 * to protect against own ISR
+	 */
 	spin_lock_irqsave(&boardp->lock, flags);
-
-	scp->scsi_done = done;
 	asc_res = asc_execute_scsi_cmnd(scp);
+	spin_unlock_irqrestore(&boardp->lock, flags);
+
 	switch (asc_res) {
 	case ASC_NOERROR:
 		break;
@@ -3201,11 +3202,9 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 		break;
 	case ASC_ERROR:
 	default:
-		/* Interrupts could be enabled here. */
 		asc_scsi_done(scp);
 		break;
 	}
-	spin_unlock_irqrestore(&boardp->lock, flags);
 
 	return result;
 }

commit 349d2c44291d922614a273e9a4e6b43ee17c103d
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:34 2007 -0600

    [SCSI] advansys: Remove `active' queue and all remaining internal queueing code
    
    The `active' list was used in the reset handler -- but the midlayer
    guarantees that list is empty by the time the reset handler is invoked.
    It was also checked in the interrupt routines to be sure that this command
    belonged to this board, but we don't need to check that either.  We can
    then delete the asc_prt_target_stats() function as it will never print
    anything, along with asc_enqueue(), asc_dequeue_list(), asc_rmqueue(),
    asc_scsi_done_list(), struct asc_queue, ASC_QUEUE_EMPTY, ASC_TID_ALL,
    ASC_FRONT, ASC_BACK, and all the REQ* macros.  Also remove this item from
    the todo list.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 90f05c52be7e..67cdfe6201ce 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -63,11 +63,10 @@
  *     has not occurred then print a message and run in polled mode.
  *  4. Need to add support for target mode commands, cf. CAM XPT.
  *  5. check DMA mapping functions for failure
- *  6. Remove internal queueing
- *  7. Use scsi_transport_spi
- *  8. advansys_info is not safe against multiple simultaneous callers
- *  9. Kill boardp->id
- * 10. Add module_param to override ISA/VLB ioport array
+ *  6. Use scsi_transport_spi
+ *  7. advansys_info is not safe against multiple simultaneous callers
+ *  8. Kill boardp->id
+ *  9. Add module_param to override ISA/VLB ioport array
  */
 #warning this driver is still not properly converted to the DMA API
 
@@ -2514,64 +2513,6 @@ do { \
 #define HOST_BYTE(byte)     ((byte) << 16)
 #define DRIVER_BYTE(byte)   ((byte) << 24)
 
-/*
- * The following definitions and macros are OS independent interfaces to
- * the queue functions:
- *  REQ - SCSI request structure
- *  REQP - pointer to SCSI request structure
- *  REQPTID(reqp) - reqp's target id
- *  REQPNEXT(reqp) - reqp's next pointer
- *  REQPNEXTP(reqp) - pointer to reqp's next pointer
- *  REQPTIME(reqp) - reqp's time stamp value
- *  REQTIMESTAMP() - system time stamp value
- */
-typedef struct scsi_cmnd REQ, *REQP;
-#define REQPNEXT(reqp)       ((REQP) ((reqp)->host_scribble))
-#define REQPNEXTP(reqp)      ((REQP *) &((reqp)->host_scribble))
-#define REQPTID(reqp)        ((reqp)->device->id)
-#define REQPTIME(reqp)       ((reqp)->SCp.this_residual)
-#define REQTIMESTAMP()       (jiffies)
-
-#define REQTIMESTAT(function, ascq, reqp, tid) \
-{ \
-    /*
-     * If the request time stamp is less than the system time stamp, then \
-     * maybe the system time stamp wrapped. Set the request time to zero.\
-     */ \
-    if (REQPTIME(reqp) <= REQTIMESTAMP()) { \
-        REQPTIME(reqp) = REQTIMESTAMP() - REQPTIME(reqp); \
-    } else { \
-        /* Indicate an error occurred with the assertion. */ \
-        ASC_ASSERT(REQPTIME(reqp) <= REQTIMESTAMP()); \
-        REQPTIME(reqp) = 0; \
-    } \
-    /* Handle first minimum time case without external initialization. */ \
-    if (((ascq)->q_tot_cnt[tid] == 1) ||  \
-        (REQPTIME(reqp) < (ascq)->q_min_tim[tid])) { \
-            (ascq)->q_min_tim[tid] = REQPTIME(reqp); \
-            ASC_DBG3(1, "%s: new q_min_tim[%d] %u\n", \
-                (function), (tid), (ascq)->q_min_tim[tid]); \
-        } \
-    if (REQPTIME(reqp) > (ascq)->q_max_tim[tid]) { \
-        (ascq)->q_max_tim[tid] = REQPTIME(reqp); \
-        ASC_DBG3(1, "%s: new q_max_tim[%d] %u\n", \
-            (function), tid, (ascq)->q_max_tim[tid]); \
-    } \
-    (ascq)->q_tot_tim[tid] += REQPTIME(reqp); \
-    /* Reset the time stamp field. */ \
-    REQPTIME(reqp) = 0; \
-}
-
-/* asc_enqueue() flags */
-#define ASC_FRONT       1
-#define ASC_BACK        2
-
-/* asc_dequeue_list() argument */
-#define ASC_TID_ALL        (-1)
-
-/* Return non-zero, if the queue is empty. */
-#define ASC_QUEUE_EMPTY(ascq)    ((ascq)->q_tidmask == 0)
-
 #ifndef ADVANSYS_STATS
 #define ASC_STATS(shost, counter)
 #define ASC_STATS_ADD(shost, counter, count)
@@ -2783,23 +2724,6 @@ struct asc_stats {
 };
 #endif /* ADVANSYS_STATS */
 
-/*
- * Request queuing structure
- */
-typedef struct asc_queue {
-	ADV_SCSI_BIT_ID_TYPE q_tidmask;	/* queue mask */
-	REQP q_first[ADV_MAX_TID + 1];	/* first queued request */
-	REQP q_last[ADV_MAX_TID + 1];	/* last queued request */
-#ifdef ADVANSYS_STATS
-	short q_cur_cnt[ADV_MAX_TID + 1];	/* current queue count */
-	short q_max_cnt[ADV_MAX_TID + 1];	/* maximum queue count */
-	ADV_DCNT q_tot_cnt[ADV_MAX_TID + 1];	/* total enqueue count */
-	ADV_DCNT q_tot_tim[ADV_MAX_TID + 1];	/* total time queued */
-	ushort q_max_tim[ADV_MAX_TID + 1];	/* maximum time queued */
-	ushort q_min_tim[ADV_MAX_TID + 1];	/* minimum time queued */
-#endif				/* ADVANSYS_STATS */
-} asc_queue_t;
-
 /*
  * Adv Library Request Structures
  *
@@ -2851,7 +2775,6 @@ typedef struct asc_board {
 		ADV_DVC_CFG adv_dvc_cfg;	/* Wide board */
 	} dvc_cfg;
 	ushort asc_n_io_port;	/* Number I/O ports. */
-	asc_queue_t active;	/* Active command queue */
 	ADV_SCSI_BIT_ID_TYPE init_tidmask;	/* Target init./valid mask */
 	struct scsi_device *device[ADV_MAX_TID + 1];	/* Mid-Level Scsi Device */
 	ushort reqcnt[ADV_MAX_TID + 1];	/* Starvation request count */
@@ -2914,14 +2837,10 @@ static int asc_dbglvl = 3;
  */
 
 static int advansys_slave_configure(struct scsi_device *);
-static void asc_scsi_done_list(struct scsi_cmnd *);
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *);
 static int asc_build_req(asc_board_t *, struct scsi_cmnd *);
 static int adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
 static int adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
-static void asc_enqueue(asc_queue_t *, REQP, int);
-static REQP asc_dequeue_list(asc_queue_t *, REQP *, int);
-static int asc_rmqueue(asc_queue_t *, REQP);
 #ifdef CONFIG_PROC_FS
 static int asc_proc_copy(off_t, off_t, char *, int, char *, int);
 static int asc_prt_board_devices(struct Scsi_Host *, char *, int);
@@ -2939,7 +2858,6 @@ static int asc_prt_line(char *, int, char *fmt, ...);
 #ifdef ADVANSYS_STATS
 #ifdef CONFIG_PROC_FS
 static int asc_prt_board_stats(struct Scsi_Host *, char *, int);
-static int asc_prt_target_stats(struct Scsi_Host *, int, char *, int);
 #endif /* CONFIG_PROC_FS */
 #endif /* ADVANSYS_STATS */
 
@@ -2991,9 +2909,6 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	int leftlen;
 	char *curbuf;
 	off_t advoffset;
-#ifdef ADVANSYS_STATS
-	int tgt_id;
-#endif /* ADVANSYS_STATS */
 
 	ASC_DBG(1, "advansys_proc_info: begin\n");
 
@@ -3123,26 +3038,6 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	}
 	advoffset += cplen;
 	curbuf += cnt;
-
-	/*
-	 * Display driver statistics for each target.
-	 */
-	for (tgt_id = 0; tgt_id <= ADV_MAX_TID; tgt_id++) {
-		cp = boardp->prtbuf;
-		cplen = asc_prt_target_stats(shost, tgt_id, cp,
-					     ASC_PRTBUF_SIZE);
-		ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
-		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
-				    cplen);
-		totcnt += cnt;
-		leftlen -= cnt;
-		if (leftlen == 0) {
-			ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-			return totcnt;
-		}
-		advoffset += cplen;
-		curbuf += cnt;
-	}
 #endif /* ADVANSYS_STATS */
 
 	/*
@@ -3331,8 +3226,6 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	ASC_DVC_VAR *asc_dvc_varp;
 	ADV_DVC_VAR *adv_dvc_varp;
 	ulong flags;
-	struct scsi_cmnd *done_scp = NULL, *last_scp = NULL;
-	struct scsi_cmnd *tscp, *new_last_scp;
 	int status;
 	int ret = SUCCESS;
 
@@ -3423,34 +3316,6 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	}
 	/* Board lock is held. */
 
-	/*
-	 * Dequeue all board 'active' requests for all devices and set
-	 * the request status to DID_RESET. A pointer to the last request
-	 * is returned in 'last_scp'.
-	 */
-	if (done_scp == NULL) {
-		done_scp = asc_dequeue_list(&boardp->active, &last_scp,
-					    ASC_TID_ALL);
-		for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
-			tscp->result = HOST_BYTE(DID_RESET);
-		}
-	} else {
-		/* Append to 'done_scp' at the end with 'last_scp'. */
-		ASC_ASSERT(last_scp != NULL);
-		last_scp->host_scribble =
-		    (unsigned char *)asc_dequeue_list(&boardp->active,
-						      &new_last_scp,
-						      ASC_TID_ALL);
-		if (new_last_scp != NULL) {
-			ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-			for (tscp = REQPNEXT(last_scp); tscp;
-			     tscp = REQPNEXT(tscp)) {
-				tscp->result = HOST_BYTE(DID_RESET);
-			}
-			last_scp = new_last_scp;
-		}
-	}
-
 	/* Save the time of the most recently completed reset. */
 	boardp->last_reset = jiffies;
 
@@ -3458,12 +3323,6 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	boardp->flags &= ~ASC_HOST_IN_RESET;
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	/*
-	 * Complete all the 'done_scp' requests.
-	 */
-	if (done_scp)
-		asc_scsi_done_list(done_scp);
-
 	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
 
 	return ret;
@@ -3794,30 +3653,6 @@ static int advansys_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
-/*
- * Complete all requests on the singly linked list pointed
- * to by 'scp'.
- *
- * Interrupts can be enabled on entry.
- */
-static void asc_scsi_done_list(struct scsi_cmnd *scp)
-{
-	struct scsi_cmnd *tscp;
-
-	ASC_DBG(2, "asc_scsi_done_list: begin\n");
-	while (scp != NULL) {
-		ASC_DBG1(3, "asc_scsi_done_list: scp 0x%lx\n", (ulong)scp);
-		tscp = REQPNEXT(scp);
-		scp->host_scribble = NULL;
-
-		asc_scsi_done(scp);
-
-		scp = tscp;
-	}
-	ASC_DBG(2, "asc_scsi_done_list: done\n");
-	return;
-}
-
 /*
  * Execute a single 'Scsi_Cmnd'.
  *
@@ -3854,9 +3689,8 @@ static void asc_scsi_done_list(struct scsi_cmnd *scp)
  *    scsi_done - used to save caller's done function
  *    host_scribble - used for pointer to another struct scsi_cmnd
  *
- * If this function returns ASC_NOERROR the request has been enqueued
- * on the board's 'active' queue and will be completed from the
- * interrupt handler.
+ * If this function returns ASC_NOERROR the request will be completed
+ * from the interrupt handler.
  *
  * If this function returns ASC_ERROR the host error code has been set,
  * and the called must call asc_scsi_done.
@@ -3901,10 +3735,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			return ASC_ERROR;
 		}
 
-		/*
-		 * Execute the command. If there is no error, add the command
-		 * to the active queue.
-		 */
 		switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
 		case ASC_NOERROR:
 			ASC_STATS(scp->device->host, exe_noerror);
@@ -3913,7 +3743,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			 * successful request counter. Wrapping doesn't matter.
 			 */
 			boardp->reqcnt[scp->device->id]++;
-			asc_enqueue(&boardp->active, scp, ASC_BACK);
 			ASC_DBG(1, "asc_execute_scsi_cmnd: AscExeScsiQueue(), "
 				"ASC_NOERROR\n");
 			break;
@@ -3970,10 +3799,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			return ASC_ERROR;
 		}
 
-		/*
-		 * Execute the command. If there is no error, add the command
-		 * to the active queue.
-		 */
 		switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
 		case ASC_NOERROR:
 			ASC_STATS(scp->device->host, exe_noerror);
@@ -3982,7 +3807,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			 * successful request counter. Wrapping doesn't matter.
 			 */
 			boardp->reqcnt[scp->device->id]++;
-			asc_enqueue(&boardp->active, scp, ASC_BACK);
 			ASC_DBG(1, "asc_execute_scsi_cmnd: AdvExeScsiQueue(), "
 				"ASC_NOERROR\n");
 			break;
@@ -4467,19 +4291,8 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	ASC_STATS(shost, callback);
 	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
 
-	/*
-	 * If the request isn't found on the active queue, it may
-	 * have been removed to handle a reset request.
-	 * Display a message and return.
-	 */
 	boardp = ASC_BOARDP(shost);
 	ASC_ASSERT(asc_dvc_varp == &boardp->dvc_var.asc_dvc_var);
-	if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
-		ASC_PRINT2
-		    ("asc_isr_callback: board %d: scp 0x%lx not on active queue\n",
-		     boardp->id, (ulong)scp);
-		return;
-	}
 
 	/*
 	 * 'qdonep' contains the command's ending status.
@@ -4624,21 +4437,8 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	ASC_STATS(shost, callback);
 	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
 
-	/*
-	 * If the request isn't found on the active queue, it may have been
-	 * removed to handle a reset request. Display a message and return.
-	 *
-	 * Note: Because the structure may still be in use don't attempt
-	 * to free the adv_req_t and adv_sgblk_t, if any, structures.
-	 */
 	boardp = ASC_BOARDP(shost);
 	ASC_ASSERT(adv_dvc_varp == &boardp->dvc_var.adv_dvc_var);
-	if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
-		ASC_PRINT2
-		    ("adv_isr_callback: board %d: scp 0x%lx not on active queue\n",
-		     boardp->id, (ulong)scp);
-		return;
-	}
 
 	/*
 	 * 'done_status' contains the command's ending status.
@@ -4787,225 +4587,6 @@ static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
 	}
 }
 
-/*
- * Add a 'REQP' to the end of specified queue. Set 'tidmask'
- * to indicate a command is queued for the device.
- *
- * 'flag' may be either ASC_FRONT or ASC_BACK.
- *
- * 'REQPNEXT(reqp)' returns reqp's next pointer.
- */
-static void asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
-{
-	int tid;
-
-	ASC_DBG3(3, "asc_enqueue: ascq 0x%lx, reqp 0x%lx, flag %d\n",
-		 (ulong)ascq, (ulong)reqp, flag);
-	ASC_ASSERT(reqp != NULL);
-	ASC_ASSERT(flag == ASC_FRONT || flag == ASC_BACK);
-	tid = REQPTID(reqp);
-	ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
-	if (flag == ASC_FRONT) {
-		reqp->host_scribble = (unsigned char *)ascq->q_first[tid];
-		ascq->q_first[tid] = reqp;
-		/* If the queue was empty, set the last pointer. */
-		if (ascq->q_last[tid] == NULL) {
-			ascq->q_last[tid] = reqp;
-		}
-	} else {		/* ASC_BACK */
-		if (ascq->q_last[tid] != NULL) {
-			ascq->q_last[tid]->host_scribble =
-			    (unsigned char *)reqp;
-		}
-		ascq->q_last[tid] = reqp;
-		reqp->host_scribble = NULL;
-		/* If the queue was empty, set the first pointer. */
-		if (ascq->q_first[tid] == NULL) {
-			ascq->q_first[tid] = reqp;
-		}
-	}
-	/* The queue has at least one entry, set its bit. */
-	ascq->q_tidmask |= ADV_TID_TO_TIDMASK(tid);
-#ifdef ADVANSYS_STATS
-	/* Maintain request queue statistics. */
-	ascq->q_tot_cnt[tid]++;
-	ascq->q_cur_cnt[tid]++;
-	if (ascq->q_cur_cnt[tid] > ascq->q_max_cnt[tid]) {
-		ascq->q_max_cnt[tid] = ascq->q_cur_cnt[tid];
-		ASC_DBG2(2, "asc_enqueue: new q_max_cnt[%d] %d\n",
-			 tid, ascq->q_max_cnt[tid]);
-	}
-	REQPTIME(reqp) = REQTIMESTAMP();
-#endif /* ADVANSYS_STATS */
-	ASC_DBG1(3, "asc_enqueue: reqp 0x%lx\n", (ulong)reqp);
-	return;
-}
-
-/*
- * Return a pointer to a singly linked list of all the requests queued
- * for 'tid' on the 'asc_queue_t' pointed to by 'ascq'.
- *
- * If 'lastpp' is not NULL, '*lastpp' will be set to point to the
- * the last request returned in the singly linked list.
- *
- * 'tid' should either be a valid target id or if it is ASC_TID_ALL,
- * then all queued requests are concatenated into one list and
- * returned.
- *
- * Note: If 'lastpp' is used to append a new list to the end of
- * an old list, only change the old list last pointer if '*lastpp'
- * (or the function return value) is not NULL, i.e. use a temporary
- * variable for 'lastpp' and check its value after the function return
- * before assigning it to the list last pointer.
- *
- * Unfortunately collecting queuing time statistics adds overhead to
- * the function that isn't inherent to the function's algorithm.
- */
-static REQP asc_dequeue_list(asc_queue_t *ascq, REQP *lastpp, int tid)
-{
-	REQP firstp, lastp;
-	int i;
-
-	ASC_DBG2(3, "asc_dequeue_list: ascq 0x%lx, tid %d\n", (ulong)ascq, tid);
-	ASC_ASSERT((tid == ASC_TID_ALL) || (tid >= 0 && tid <= ADV_MAX_TID));
-
-	/*
-	 * If 'tid' is not ASC_TID_ALL, return requests only for
-	 * the specified 'tid'. If 'tid' is ASC_TID_ALL, return all
-	 * requests for all tids.
-	 */
-	if (tid != ASC_TID_ALL) {
-		/* Return all requests for the specified 'tid'. */
-		if ((ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid)) == 0) {
-			/* List is empty; Set first and last return pointers to NULL. */
-			firstp = lastp = NULL;
-		} else {
-			firstp = ascq->q_first[tid];
-			lastp = ascq->q_last[tid];
-			ascq->q_first[tid] = ascq->q_last[tid] = NULL;
-			ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
-#ifdef ADVANSYS_STATS
-			{
-				REQP reqp;
-				ascq->q_cur_cnt[tid] = 0;
-				for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
-					REQTIMESTAT("asc_dequeue_list", ascq,
-						    reqp, tid);
-				}
-			}
-#endif /* ADVANSYS_STATS */
-		}
-	} else {
-		/* Return all requests for all tids. */
-		firstp = lastp = NULL;
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			if (ascq->q_tidmask & ADV_TID_TO_TIDMASK(i)) {
-				if (firstp == NULL) {
-					firstp = ascq->q_first[i];
-					lastp = ascq->q_last[i];
-				} else {
-					ASC_ASSERT(lastp != NULL);
-					lastp->host_scribble =
-					    (unsigned char *)ascq->q_first[i];
-					lastp = ascq->q_last[i];
-				}
-				ascq->q_first[i] = ascq->q_last[i] = NULL;
-				ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(i);
-#ifdef ADVANSYS_STATS
-				ascq->q_cur_cnt[i] = 0;
-#endif /* ADVANSYS_STATS */
-			}
-		}
-#ifdef ADVANSYS_STATS
-		{
-			REQP reqp;
-			for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
-				REQTIMESTAT("asc_dequeue_list", ascq, reqp,
-					    reqp->device->id);
-			}
-		}
-#endif /* ADVANSYS_STATS */
-	}
-	if (lastpp) {
-		*lastpp = lastp;
-	}
-	ASC_DBG1(3, "asc_dequeue_list: firstp 0x%lx\n", (ulong)firstp);
-	return firstp;
-}
-
-/*
- * Remove the specified 'REQP' from the specified queue for
- * the specified target device. Clear the 'tidmask' bit for the
- * device if no more commands are left queued for it.
- *
- * 'REQPNEXT(reqp)' returns reqp's the next pointer.
- *
- * Return ASC_TRUE if the command was found and removed,
- * otherwise return ASC_FALSE.
- */
-static int asc_rmqueue(asc_queue_t *ascq, REQP reqp)
-{
-	REQP currp, prevp;
-	int tid;
-	int ret = ASC_FALSE;
-
-	ASC_DBG2(3, "asc_rmqueue: ascq 0x%lx, reqp 0x%lx\n",
-		 (ulong)ascq, (ulong)reqp);
-	ASC_ASSERT(reqp != NULL);
-
-	tid = REQPTID(reqp);
-	ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
-
-	/*
-	 * Handle the common case of 'reqp' being the first
-	 * entry on the queue.
-	 */
-	if (reqp == ascq->q_first[tid]) {
-		ret = ASC_TRUE;
-		ascq->q_first[tid] = REQPNEXT(reqp);
-		/* If the queue is now empty, clear its bit and the last pointer. */
-		if (ascq->q_first[tid] == NULL) {
-			ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
-			ASC_ASSERT(ascq->q_last[tid] == reqp);
-			ascq->q_last[tid] = NULL;
-		}
-	} else if (ascq->q_first[tid] != NULL) {
-		ASC_ASSERT(ascq->q_last[tid] != NULL);
-		/*
-		 * Because the case of 'reqp' being the first entry has been
-		 * handled above and it is known the queue is not empty, if
-		 * 'reqp' is found on the queue it is guaranteed the queue will
-		 * not become empty and that 'q_first[tid]' will not be changed.
-		 *
-		 * Set 'prevp' to the first entry, 'currp' to the second entry,
-		 * and search for 'reqp'.
-		 */
-		for (prevp = ascq->q_first[tid], currp = REQPNEXT(prevp);
-		     currp; prevp = currp, currp = REQPNEXT(currp)) {
-			if (currp == reqp) {
-				ret = ASC_TRUE;
-				prevp->host_scribble =
-				    (unsigned char *)REQPNEXT(currp);
-				reqp->host_scribble = NULL;
-				if (ascq->q_last[tid] == reqp) {
-					ascq->q_last[tid] = prevp;
-				}
-				break;
-			}
-		}
-	}
-#ifdef ADVANSYS_STATS
-	/* Maintain request queue statistics. */
-	if (ret == ASC_TRUE) {
-		ascq->q_cur_cnt[tid]--;
-		REQTIMESTAT("asc_rmqueue", ascq, reqp, tid);
-	}
-	ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
-#endif /* ADVANSYS_STATS */
-	ASC_DBG2(3, "asc_rmqueue: reqp 0x%lx, ret %d\n", (ulong)reqp, ret);
-	return ret;
-}
-
 #ifdef CONFIG_PROC_FS
 /*
  * asc_prt_board_devices()
@@ -6465,79 +6046,6 @@ static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
 
 	return totlen;
 }
-
-/*
- * asc_prt_target_stats()
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
- *
- * This is separated from asc_prt_board_stats because a full set
- * of targets will overflow ASC_PRTBUF_SIZE.
- *
- * Return the number of characters copied into 'cp'. No more than
- * 'cplen' characters will be copied to 'cp'.
- */
-static int
-asc_prt_target_stats(struct Scsi_Host *shost, int tgt_id, char *cp, int cplen)
-{
-	int leftlen;
-	int totlen;
-	int len;
-	struct asc_stats *s;
-	ushort chip_scsi_id;
-	asc_board_t *boardp;
-	asc_queue_t *active;
-
-	leftlen = cplen;
-	totlen = len = 0;
-
-	boardp = ASC_BOARDP(shost);
-	s = &boardp->asc_stats;
-
-	active = &ASC_BOARDP(shost)->active;
-
-	if (ASC_NARROW_BOARD(boardp)) {
-		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
-	} else {
-		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
-	}
-
-	if ((chip_scsi_id == tgt_id) ||
-	    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(tgt_id)) == 0)) {
-		return 0;
-	}
-
-	do {
-		if (active->q_tot_cnt[tgt_id] > 0) {
-			len = asc_prt_line(cp, leftlen, " target %d\n", tgt_id);
-			ASC_PRT_NEXT();
-
-			len = asc_prt_line(cp, leftlen,
-					   "   active: cnt [cur %d, max %d, tot %u], time [min %d, max %d, avg %lu.%01lu]\n",
-					   active->q_cur_cnt[tgt_id],
-					   active->q_max_cnt[tgt_id],
-					   active->q_tot_cnt[tgt_id],
-					   active->q_min_tim[tgt_id],
-					   active->q_max_tim[tgt_id],
-					   (active->q_tot_cnt[tgt_id] ==
-					    0) ? 0 : (active->
-						      q_tot_tim[tgt_id] /
-						      active->
-						      q_tot_cnt[tgt_id]),
-					   (active->q_tot_cnt[tgt_id] ==
-					    0) ? 0 : ASC_TENTHS(active->
-								q_tot_tim
-								[tgt_id],
-								active->
-								q_tot_cnt
-								[tgt_id]));
-			ASC_PRT_NEXT();
-		}
-	} while (0);
-
-	return totlen;
-}
 #endif /* CONFIG_PROC_FS */
 #endif /* ADVANSYS_STATS */
 

commit 6ed1ef0786094f06d2462aeeb6ad7bf9f5f9fc18
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:33 2007 -0600

    [SCSI] advansys: Remove `done' queue
    
     - Move the guts of asc_scsi_done_list() into a new function, asc_scsi_done.
     - Call asc_scsi_done() in asc_isr_callback() and adv_isr_callback().  The
       comment was wrong; scsi_done cannot enable interrupts.
     - All other places which queued an scp on the done list are error paths
       for queuecommand, and so we can just call asc_scsi_done() in queuecommand
       if we receive an error.
     - We no longer need to keep a list of done requests in advansys_interrupt
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index cd17f28fd3ba..90f05c52be7e 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2852,7 +2852,6 @@ typedef struct asc_board {
 	} dvc_cfg;
 	ushort asc_n_io_port;	/* Number I/O ports. */
 	asc_queue_t active;	/* Active command queue */
-	asc_queue_t done;	/* Done command queue */
 	ADV_SCSI_BIT_ID_TYPE init_tidmask;	/* Target init./valid mask */
 	struct scsi_device *device[ADV_MAX_TID + 1];	/* Mid-Level Scsi Device */
 	ushort reqcnt[ADV_MAX_TID + 1];	/* Starvation request count */
@@ -3258,6 +3257,23 @@ static const char *advansys_info(struct Scsi_Host *shost)
 	return info;
 }
 
+static void asc_scsi_done(struct scsi_cmnd *scp)
+{
+	struct asc_board *boardp = ASC_BOARDP(scp->device->host);
+
+	if (scp->use_sg)
+		dma_unmap_sg(boardp->dev,
+			     (struct scatterlist *)scp->request_buffer,
+			     scp->use_sg, scp->sc_data_direction);
+	else if (scp->request_bufflen)
+		dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
+				 scp->request_bufflen, scp->sc_data_direction);
+
+	ASC_STATS(scp->device->host, done);
+
+	scp->scsi_done(scp);
+}
+
 /*
  * advansys_queuecommand() - interrupt-driven I/O entrypoint.
  *
@@ -3270,7 +3286,6 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 	struct Scsi_Host *shost;
 	asc_board_t *boardp;
 	ulong flags;
-	struct scsi_cmnd *done_scp;
 	int asc_res, result = 0;
 
 	shost = scp->device->host;
@@ -3291,9 +3306,8 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 		break;
 	case ASC_ERROR:
 	default:
-		done_scp = asc_dequeue_list(&boardp->done, NULL, ASC_TID_ALL);
 		/* Interrupts could be enabled here. */
-		asc_scsi_done_list(done_scp);
+		asc_scsi_done(scp);
 		break;
 	}
 	spin_unlock_irqrestore(&boardp->lock, flags);
@@ -3409,12 +3423,6 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	}
 	/* Board lock is held. */
 
-	/*
-	 * Dequeue all board 'done' requests. A pointer to the last request
-	 * is returned in 'last_scp'.
-	 */
-	done_scp = asc_dequeue_list(&boardp->done, &last_scp, ASC_TID_ALL);
-
 	/*
 	 * Dequeue all board 'active' requests for all devices and set
 	 * the request status to DID_RESET. A pointer to the last request
@@ -3548,8 +3556,6 @@ static struct scsi_host_template advansys_template = {
 static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 {
 	unsigned long flags;
-	struct scsi_cmnd *done_scp = NULL, *last_scp = NULL;
-	struct scsi_cmnd *new_last_scp;
 	struct Scsi_Host *shost = dev_id;
 	asc_board_t *boardp = ASC_BOARDP(shost);
 	irqreturn_t result = IRQ_NONE;
@@ -3577,49 +3583,13 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 		}
 	}
 
-	/*
-	 * Create a list of completed requests.
-	 *
-	 * If a reset request is being performed for the board, the reset
-	 * handler will complete pending requests after it has completed.
-	 */
-	if ((boardp->flags & ASC_HOST_IN_RESET) == 0) {
-		ASC_DBG2(1, "advansys_interrupt: done_scp 0x%p, "
-			 "last_scp 0x%p\n", done_scp, last_scp);
-
-		/*
-		 * Add to the list of requests that must be completed.
-		 *
-		 * 'done_scp' will always be NULL on the first iteration of
-		 * this loop. 'last_scp' is set at the same time as 'done_scp'.
-		 */
-		if (done_scp == NULL) {
-			done_scp = asc_dequeue_list(&boardp->done,
-						&last_scp, ASC_TID_ALL);
-		} else {
-			ASC_ASSERT(last_scp != NULL);
-			last_scp->host_scribble =
-			    (unsigned char *)asc_dequeue_list(&boardp->
-							      done,
-							      &new_last_scp,
-							      ASC_TID_ALL);
-			if (new_last_scp != NULL) {
-				ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-				last_scp = new_last_scp;
-			}
-		}
-	}
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
 	/*
 	 * If interrupts were enabled on entry, then they
 	 * are now enabled here.
-	 *
-	 * Complete all requests on the done list.
 	 */
 
-	asc_scsi_done_list(done_scp);
-
 	ASC_DBG(1, "advansys_interrupt: end\n");
 	return result;
 }
@@ -3836,27 +3806,11 @@ static void asc_scsi_done_list(struct scsi_cmnd *scp)
 
 	ASC_DBG(2, "asc_scsi_done_list: begin\n");
 	while (scp != NULL) {
-		asc_board_t *boardp;
-
 		ASC_DBG1(3, "asc_scsi_done_list: scp 0x%lx\n", (ulong)scp);
 		tscp = REQPNEXT(scp);
 		scp->host_scribble = NULL;
 
-		boardp = ASC_BOARDP(scp->device->host);
-
-		if (scp->use_sg)
-			dma_unmap_sg(boardp->dev,
-				     (struct scatterlist *)scp->request_buffer,
-				     scp->use_sg, scp->sc_data_direction);
-		else if (scp->request_bufflen)
-			dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
-					 scp->request_bufflen,
-					 scp->sc_data_direction);
-
-		ASC_STATS(scp->device->host, done);
-		ASC_ASSERT(scp->scsi_done != NULL);
-
-		scp->scsi_done(scp);
+		asc_scsi_done(scp);
 
 		scp = tscp;
 	}
@@ -3904,8 +3858,8 @@ static void asc_scsi_done_list(struct scsi_cmnd *scp)
  * on the board's 'active' queue and will be completed from the
  * interrupt handler.
  *
- * If this function returns ASC_NOERROR the request has been enqueued
- * on the board's 'done' queue and must be completed by the caller.
+ * If this function returns ASC_ERROR the host error code has been set,
+ * and the called must call asc_scsi_done.
  *
  * If ASC_BUSY is returned the request will be returned to the midlayer
  * and re-tried later.
@@ -3972,7 +3926,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 				boardp->id, asc_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_error);
 			scp->result = HOST_BYTE(DID_ERROR);
-			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			break;
 		default:
 			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
@@ -3980,7 +3933,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 				boardp->id, asc_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_unknown);
 			scp->result = HOST_BYTE(DID_ERROR);
-			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			break;
 		}
 	} else {
@@ -4011,11 +3963,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			 */
 			return ASC_BUSY;
 		case ASC_ERROR:
-			/* 
-			 * If an error is returned, then the request has been
-			 * queued on the board done queue. It will be completed
-			 * by the caller.
-			 */
 		default:
 			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
 				"ASC_ERROR\n");
@@ -4048,7 +3995,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 				boardp->id, adv_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_error);
 			scp->result = HOST_BYTE(DID_ERROR);
-			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			break;
 		default:
 			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
@@ -4056,7 +4002,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 				boardp->id, adv_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_unknown);
 			scp->result = HOST_BYTE(DID_ERROR);
-			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			break;
 		}
 	}
@@ -4071,8 +4016,7 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
  * The global structures 'asc_scsi_q' and 'asc_sg_head' are
  * used to build the request.
  *
- * If an error occurs, then queue the request on the board done
- * queue and return ASC_ERROR.
+ * If an error occurs, then return ASC_ERROR.
  */
 static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 {
@@ -4098,7 +4042,6 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 			"ASC_MAX_CDB_LEN %d\n", boardp->id, scp->cmd_len,
 			ASC_MAX_CDB_LEN);
 		scp->result = HOST_BYTE(DID_ERROR);
-		asc_enqueue(&boardp->done, scp, ASC_BACK);
 		return ASC_ERROR;
 	}
 	asc_scsi_q.cdbptr = &scp->cmnd[0];
@@ -4167,7 +4110,6 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
 				     scp->sc_data_direction);
 			scp->result = HOST_BYTE(DID_ERROR);
-			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			return ASC_ERROR;
 		}
 
@@ -4274,7 +4216,6 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 		    ("adv_build_req: board %d: cmd_len %d > ADV_MAX_CDB_LEN  %d\n",
 		     boardp->id, scp->cmd_len, ADV_MAX_CDB_LEN);
 		scp->result = HOST_BYTE(DID_ERROR);
-		asc_enqueue(&boardp->done, scp, ASC_BACK);
 		return ASC_ERROR;
 	}
 	scsiqp->cdb_len = scp->cmd_len;
@@ -4342,7 +4283,6 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
 				     scp->sc_data_direction);
 			scp->result = HOST_BYTE(DID_ERROR);
-			asc_enqueue(&boardp->done, scp, ASC_BACK);
 
 			/*
 			 * Free the 'adv_req_t' structure by adding it back
@@ -4628,13 +4568,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
 	}
 
-	/*
-	 * Because interrupts may be enabled by the 'struct scsi_cmnd' done
-	 * function, add the command to the end of the board's done queue.
-	 * The done function for the command will be called from
-	 * advansys_interrupt().
-	 */
-	asc_enqueue(&boardp->done, scp, ASC_BACK);
+	asc_scsi_done(scp);
 
 	return;
 }
@@ -4790,13 +4724,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
 	}
 
-	/*
-	 * Because interrupts may be enabled by the 'struct scsi_cmnd' done
-	 * function, add the command to the end of the board's done queue.
-	 * The done function for the command will be called from
-	 * advansys_interrupt().
-	 */
-	asc_enqueue(&boardp->done, scp, ASC_BACK);
+	asc_scsi_done(scp);
 
 	/*
 	 * Free all 'adv_sgblk_t' structures allocated for the request.

commit 7686f02aa8a380b3b0322179090f3c83ee4df977
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:32 2007 -0600

    [SCSI] advansys: Remove a check for an impossible condition
    
    The midlayer guarantees it won't call ->queuecommand for a host which
    is handling a reset condition.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 526239a21332..cd17f28fd3ba 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3281,25 +3281,6 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 	/* against own ISR */
 	spin_lock_irqsave(&boardp->lock, flags);
 
-	/*
-	 * Block new commands while handling a reset or abort request.
-	 */
-	if (boardp->flags & ASC_HOST_IN_RESET) {
-		ASC_DBG1(1,
-			 "advansys_queuecommand: scp 0x%lx blocked for reset request\n",
-			 (ulong)scp);
-		scp->result = HOST_BYTE(DID_RESET);
-
-		/*
-		 * Add blocked requests to the board's 'done' queue. The queued
-		 * requests will be completed at the end of the abort or reset
-		 * handling.
-		 */
-		asc_enqueue(&boardp->done, scp, ASC_BACK);
-		spin_unlock_irqrestore(&boardp->lock, flags);
-		return 0;
-	}
-
 	scp->scsi_done = done;
 	asc_res = asc_execute_scsi_cmnd(scp);
 	switch (asc_res) {

commit b66229258f88a06ecdb8998066861b3ad8ad6a2a
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:31 2007 -0600

    [SCSI] advansys: Remove `waiting' queue
    
    If the adapter is busy, return the request to the midlayer rather than
    queueing it in the driver.  asc_execute_queue() and asc_dequeue() become
    unused, and we don't need to print out stats on the waiting queue any more.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index fe289b1d7ddb..526239a21332 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2852,7 +2852,6 @@ typedef struct asc_board {
 	} dvc_cfg;
 	ushort asc_n_io_port;	/* Number I/O ports. */
 	asc_queue_t active;	/* Active command queue */
-	asc_queue_t waiting;	/* Waiting command queue */
 	asc_queue_t done;	/* Done command queue */
 	ADV_SCSI_BIT_ID_TYPE init_tidmask;	/* Target init./valid mask */
 	struct scsi_device *device[ADV_MAX_TID + 1];	/* Mid-Level Scsi Device */
@@ -2922,10 +2921,8 @@ static int asc_build_req(asc_board_t *, struct scsi_cmnd *);
 static int adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
 static int adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
 static void asc_enqueue(asc_queue_t *, REQP, int);
-static REQP asc_dequeue(asc_queue_t *, int);
 static REQP asc_dequeue_list(asc_queue_t *, REQP *, int);
 static int asc_rmqueue(asc_queue_t *, REQP);
-static void asc_execute_queue(asc_queue_t *);
 #ifdef CONFIG_PROC_FS
 static int asc_proc_copy(off_t, off_t, char *, int, char *, int);
 static int asc_prt_board_devices(struct Scsi_Host *, char *, int);
@@ -3274,6 +3271,7 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 	asc_board_t *boardp;
 	ulong flags;
 	struct scsi_cmnd *done_scp;
+	int asc_res, result = 0;
 
 	shost = scp->device->host;
 	boardp = ASC_BOARDP(shost);
@@ -3302,37 +3300,13 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 		return 0;
 	}
 
-	/*
-	 * Attempt to execute any waiting commands for the board.
-	 */
-	if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
-		ASC_DBG(1,
-			"advansys_queuecommand: before asc_execute_queue() waiting\n");
-		asc_execute_queue(&boardp->waiting);
-	}
-
-	/*
-	 * Save the function pointer to Linux mid-level 'done' function
-	 * and attempt to execute the command.
-	 *
-	 * If ASC_NOERROR is returned the request has been added to the
-	 * board's 'active' queue and will be completed by the interrupt
-	 * handler.
-	 *
-	 * If ASC_BUSY is returned add the request to the board's per
-	 * target waiting list. This is the first time the request has
-	 * been tried. Add it to the back of the waiting list. It will be
-	 * retried later.
-	 *
-	 * If an error occurred, the request will have been placed on the
-	 * board's 'done' queue and must be completed before returning.
-	 */
 	scp->scsi_done = done;
-	switch (asc_execute_scsi_cmnd(scp)) {
+	asc_res = asc_execute_scsi_cmnd(scp);
+	switch (asc_res) {
 	case ASC_NOERROR:
 		break;
 	case ASC_BUSY:
-		asc_enqueue(&boardp->waiting, scp, ASC_BACK);
+		result = SCSI_MLQUEUE_HOST_BUSY;
 		break;
 	case ASC_ERROR:
 	default:
@@ -3343,7 +3317,7 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 	}
 	spin_unlock_irqrestore(&boardp->lock, flags);
 
-	return 0;
+	return result;
 }
 
 /*
@@ -3488,33 +3462,6 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		}
 	}
 
-	/*
-	 * Dequeue all 'waiting' requests and set the request status
-	 * to DID_RESET.
-	 */
-	if (done_scp == NULL) {
-		done_scp = asc_dequeue_list(&boardp->waiting, &last_scp,
-					    ASC_TID_ALL);
-		for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
-			tscp->result = HOST_BYTE(DID_RESET);
-		}
-	} else {
-		/* Append to 'done_scp' at the end with 'last_scp'. */
-		ASC_ASSERT(last_scp != NULL);
-		last_scp->host_scribble =
-		    (unsigned char *)asc_dequeue_list(&boardp->waiting,
-						      &new_last_scp,
-						      ASC_TID_ALL);
-		if (new_last_scp != NULL) {
-			ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-			for (tscp = REQPNEXT(last_scp); tscp;
-			     tscp = REQPNEXT(tscp)) {
-				tscp->result = HOST_BYTE(DID_RESET);
-			}
-			last_scp = new_last_scp;
-		}
-	}
-
 	/* Save the time of the most recently completed reset. */
 	boardp->last_reset = jiffies;
 
@@ -3650,7 +3597,7 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	}
 
 	/*
-	 * Start waiting requests and create a list of completed requests.
+	 * Create a list of completed requests.
 	 *
 	 * If a reset request is being performed for the board, the reset
 	 * handler will complete pending requests after it has completed.
@@ -3659,13 +3606,6 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 		ASC_DBG2(1, "advansys_interrupt: done_scp 0x%p, "
 			 "last_scp 0x%p\n", done_scp, last_scp);
 
-		/* Start any waiting commands for the board. */
-		if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
-			ASC_DBG(1, "advansys_interrupt: before "
-				"asc_execute_queue()\n");
-			asc_execute_queue(&boardp->waiting);
-		}
-
 		/*
 		 * Add to the list of requests that must be completed.
 		 *
@@ -3986,8 +3926,8 @@ static void asc_scsi_done_list(struct scsi_cmnd *scp)
  * If this function returns ASC_NOERROR the request has been enqueued
  * on the board's 'done' queue and must be completed by the caller.
  *
- * If ASC_BUSY is returned the request will be enqueued by the
- * caller on the target's waiting queue and re-tried later.
+ * If ASC_BUSY is returned the request will be returned to the midlayer
+ * and re-tried later.
  */
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 {
@@ -4043,10 +3983,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 				"ASC_NOERROR\n");
 			break;
 		case ASC_BUSY:
-			/*
-			 * Caller will enqueue request on the target's waiting
-			 * queue and retry later.
-			 */
 			ASC_STATS(scp->device->host, exe_busy);
 			break;
 		case ASC_ERROR:
@@ -4087,10 +4023,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
 				"ASC_BUSY\n");
 			/*
-			 * If busy is returned the request has not been
-			 * enqueued.  It will be enqueued by the caller on the
-			 * target's waiting queue and retried later.
-			 *
 			 * The asc_stats fields 'adv_build_noreq' and
 			 * 'adv_build_nosg' count wide board busy conditions.
 			 * They are updated in adv_build_req and
@@ -4127,10 +4059,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 				"ASC_NOERROR\n");
 			break;
 		case ASC_BUSY:
-			/*
-			 * Caller will enqueue request on the target's waiting
-			 * queue and retry later.
-			 */
 			ASC_STATS(scp->device->host, exe_busy);
 			break;
 		case ASC_ERROR:
@@ -5004,39 +4932,6 @@ static void asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
 	return;
 }
 
-/*
- * Return first queued 'REQP' on the specified queue for
- * the specified target device. Clear the 'tidmask' bit for
- * the device if no more commands are left queued for it.
- *
- * 'REQPNEXT(reqp)' returns reqp's next pointer.
- */
-static REQP asc_dequeue(asc_queue_t *ascq, int tid)
-{
-	REQP reqp;
-
-	ASC_DBG2(3, "asc_dequeue: ascq 0x%lx, tid %d\n", (ulong)ascq, tid);
-	ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
-	if ((reqp = ascq->q_first[tid]) != NULL) {
-		ASC_ASSERT(ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid));
-		ascq->q_first[tid] = REQPNEXT(reqp);
-		/* If the queue is empty, clear its bit and the last pointer. */
-		if (ascq->q_first[tid] == NULL) {
-			ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
-			ASC_ASSERT(ascq->q_last[tid] == reqp);
-			ascq->q_last[tid] = NULL;
-		}
-#ifdef ADVANSYS_STATS
-		/* Maintain request queue statistics. */
-		ascq->q_cur_cnt[tid]--;
-		ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
-		REQTIMESTAT("asc_dequeue", ascq, reqp, tid);
-#endif /* ADVANSYS_STATS */
-	}
-	ASC_DBG1(3, "asc_dequeue: reqp 0x%lx\n", (ulong)reqp);
-	return reqp;
-}
-
 /*
  * Return a pointer to a singly linked list of all the requests queued
  * for 'tid' on the 'asc_queue_t' pointed to by 'ascq'.
@@ -5202,45 +5097,6 @@ static int asc_rmqueue(asc_queue_t *ascq, REQP reqp)
 	return ret;
 }
 
-/*
- * Execute as many queued requests as possible for the specified queue.
- *
- * Calls asc_execute_scsi_cmnd() to execute a REQP/struct scsi_cmnd.
- */
-static void asc_execute_queue(asc_queue_t *ascq)
-{
-	ADV_SCSI_BIT_ID_TYPE scan_tidmask;
-	REQP reqp;
-	int i;
-
-	ASC_DBG1(1, "asc_execute_queue: ascq 0x%lx\n", (ulong)ascq);
-	/*
-	 * Execute queued commands for devices attached to
-	 * the current board in round-robin fashion.
-	 */
-	scan_tidmask = ascq->q_tidmask;
-	do {
-		for (i = 0; i <= ADV_MAX_TID; i++) {
-			if (scan_tidmask & ADV_TID_TO_TIDMASK(i)) {
-				if ((reqp = asc_dequeue(ascq, i)) == NULL) {
-					scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
-				} else
-				    if (asc_execute_scsi_cmnd
-					((struct scsi_cmnd *)reqp)
-					== ASC_BUSY) {
-					scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
-					/*
-					 * The request returned ASC_BUSY. Enqueue at the front of
-					 * target's waiting list to maintain correct ordering.
-					 */
-					asc_enqueue(ascq, reqp, ASC_FRONT);
-				}
-			}
-		}
-	} while (scan_tidmask);
-	return;
-}
-
 #ifdef CONFIG_PROC_FS
 /*
  * asc_prt_board_devices()
@@ -6723,7 +6579,6 @@ asc_prt_target_stats(struct Scsi_Host *shost, int tgt_id, char *cp, int cplen)
 	ushort chip_scsi_id;
 	asc_board_t *boardp;
 	asc_queue_t *active;
-	asc_queue_t *waiting;
 
 	leftlen = cplen;
 	totlen = len = 0;
@@ -6732,7 +6587,6 @@ asc_prt_target_stats(struct Scsi_Host *shost, int tgt_id, char *cp, int cplen)
 	s = &boardp->asc_stats;
 
 	active = &ASC_BOARDP(shost)->active;
-	waiting = &ASC_BOARDP(shost)->waiting;
 
 	if (ASC_NARROW_BOARD(boardp)) {
 		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
@@ -6746,8 +6600,7 @@ asc_prt_target_stats(struct Scsi_Host *shost, int tgt_id, char *cp, int cplen)
 	}
 
 	do {
-		if (active->q_tot_cnt[tgt_id] > 0
-		    || waiting->q_tot_cnt[tgt_id] > 0) {
+		if (active->q_tot_cnt[tgt_id] > 0) {
 			len = asc_prt_line(cp, leftlen, " target %d\n", tgt_id);
 			ASC_PRT_NEXT();
 
@@ -6771,27 +6624,6 @@ asc_prt_target_stats(struct Scsi_Host *shost, int tgt_id, char *cp, int cplen)
 								q_tot_cnt
 								[tgt_id]));
 			ASC_PRT_NEXT();
-
-			len = asc_prt_line(cp, leftlen,
-					   "   waiting: cnt [cur %d, max %d, tot %u], time [min %u, max %u, avg %lu.%01lu]\n",
-					   waiting->q_cur_cnt[tgt_id],
-					   waiting->q_max_cnt[tgt_id],
-					   waiting->q_tot_cnt[tgt_id],
-					   waiting->q_min_tim[tgt_id],
-					   waiting->q_max_tim[tgt_id],
-					   (waiting->q_tot_cnt[tgt_id] ==
-					    0) ? 0 : (waiting->
-						      q_tot_tim[tgt_id] /
-						      waiting->
-						      q_tot_cnt[tgt_id]),
-					   (waiting->q_tot_cnt[tgt_id] ==
-					    0) ? 0 : ASC_TENTHS(waiting->
-								q_tot_tim
-								[tgt_id],
-								waiting->
-								q_tot_cnt
-								[tgt_id]));
-			ASC_PRT_NEXT();
 		}
 	} while (0);
 

commit c2dce2fabc7f0b559e920890d13e7b8ecfc91e13
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:30 2007 -0600

    [SCSI] advansys: Shrink advansys_board_found a little more
    
    Move the error reporting into AscInitGetConfig, AdvInitGetConfig and
    AscInitSetConfig.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 5649bf4dd94e..fe289b1d7ddb 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9321,13 +9321,14 @@ static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
 }
 #endif /* CONFIG_ISA */
 
-static ushort __devinit AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
+static int __devinit AscInitGetConfig(asc_board_t *boardp)
 {
+	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 	unsigned short warn_code = 0;
 
 	asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
 	if (asc_dvc->err_code != 0)
-		return (UW_ERR);
+		return asc_dvc->err_code;
 
 	if (AscFindSignature(asc_dvc->iop_base)) {
 		warn_code |= AscInitAscDvcVar(asc_dvc);
@@ -9338,27 +9339,63 @@ static ushort __devinit AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 	} else {
 		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
 	}
-	return warn_code;
+
+	switch (warn_code) {
+	case 0:	/* No error */
+		break;
+	case ASC_WARN_IO_PORT_ROTATE:
+		ASC_PRINT1("AscInitGetConfig: board %d: I/O port address "
+			   "modified\n", boardp->id);
+		break;
+	case ASC_WARN_AUTO_CONFIG:
+		ASC_PRINT1("AscInitGetConfig: board %d: I/O port increment "
+			   "switch enabled\n", boardp->id);
+		break;
+	case ASC_WARN_EEPROM_CHKSUM:
+		ASC_PRINT1("AscInitGetConfig: board %d: EEPROM checksum "
+			   "error\n", boardp->id);
+		break;
+	case ASC_WARN_IRQ_MODIFIED:
+		ASC_PRINT1("AscInitGetConfig: board %d: IRQ modified\n",
+			   boardp->id);
+		break;
+	case ASC_WARN_CMD_QNG_CONFLICT:
+		ASC_PRINT1("AscInitGetConfig: board %d: tag queuing enabled "
+			   "w/o disconnects\n", boardp->id);
+		break;
+	default:
+		ASC_PRINT2("AscInitGetConfig: board %d: unknown warning: "
+			   "0x%x\n", boardp->id, warn_code);
+		break;
+	}
+
+	if (asc_dvc->err_code != 0) {
+		ASC_PRINT3("AscInitGetConfig: board %d error: init_state 0x%x, "
+			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
+			   asc_dvc->err_code);
+	}
+
+	return asc_dvc->err_code;
 }
 
-static unsigned short __devinit
-AscInitSetConfig(struct pci_dev *pdev, ASC_DVC_VAR *asc_dvc)
+static int __devinit AscInitSetConfig(struct pci_dev *pdev, asc_board_t *boardp)
 {
+	ASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;
 	PortAddr iop_base = asc_dvc->iop_base;
 	unsigned short cfg_msw;
 	unsigned short warn_code = 0;
 
 	asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
 	if (asc_dvc->err_code != 0)
-		return UW_ERR;
+		return asc_dvc->err_code;
 	if (!AscFindSignature(asc_dvc->iop_base)) {
 		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-		return 0;
+		return asc_dvc->err_code;
 	}
 
 	cfg_msw = AscGetChipCfgMsw(iop_base);
 	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
-		cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
+		cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
 		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
 		AscSetChipCfgMsw(iop_base, cfg_msw);
 	}
@@ -9409,7 +9446,44 @@ AscInitSetConfig(struct pci_dev *pdev, ASC_DVC_VAR *asc_dvc)
 #endif /* CONFIG_ISA */
 
 	asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
-	return warn_code;
+
+	switch (warn_code) {
+	case 0:	/* No error. */
+		break;
+	case ASC_WARN_IO_PORT_ROTATE:
+		ASC_PRINT1("AscInitSetConfig: board %d: I/O port address "
+			   "modified\n", boardp->id);
+		break;
+	case ASC_WARN_AUTO_CONFIG:
+		ASC_PRINT1("AscInitSetConfig: board %d: I/O port increment "
+			   "switch enabled\n", boardp->id);
+		break;
+	case ASC_WARN_EEPROM_CHKSUM:
+		ASC_PRINT1("AscInitSetConfig: board %d: EEPROM checksum "
+			   "error\n", boardp->id);
+		break;
+	case ASC_WARN_IRQ_MODIFIED:
+		ASC_PRINT1("AscInitSetConfig: board %d: IRQ modified\n",
+			   boardp->id);
+		break;
+	case ASC_WARN_CMD_QNG_CONFLICT:
+		ASC_PRINT1("AscInitSetConfig: board %d: tag queuing w/o "
+			   "disconnects\n",
+		     boardp->id);
+		break;
+	default:
+		ASC_PRINT2("AscInitSetConfig: board %d: unknown warning: "
+			   "0x%x\n", boardp->id, warn_code);
+		break;
+	}
+
+	if (asc_dvc->err_code != 0) {
+		ASC_PRINT3("AscInitSetConfig: board %d error: init_state 0x%x, "
+			   "err_code 0x%x\n", boardp->id, asc_dvc->init_state,
+			   asc_dvc->err_code);
+	}
+
+	return asc_dvc->err_code;
 }
 
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
@@ -9596,7 +9670,7 @@ static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 	cfg_msw = AscGetChipCfgMsw(iop_base);
 	cfg_lsw = AscGetChipCfgLsw(iop_base);
 	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
-		cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
+		cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
 		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
 		AscSetChipCfgMsw(iop_base, cfg_msw);
 	}
@@ -12009,6 +12083,7 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata =
 	0			/* 63 reserved */
 };
 
+#ifdef CONFIG_PCI
 /*
  * Initialize the ADV_DVC_VAR structure.
  *
@@ -12018,8 +12093,9 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata =
  * then 0 is returned.
  */
 static int __devinit
-AdvInitGetConfig(struct pci_dev *pdev, ADV_DVC_VAR *asc_dvc)
+AdvInitGetConfig(struct pci_dev *pdev, asc_board_t *boardp)
 {
+	ADV_DVC_VAR *asc_dvc = &boardp->dvc_var.adv_dvc_var;
 	unsigned short warn_code = 0;
 	AdvPortAddr iop_base = asc_dvc->iop_base;
 	u16 cmd;
@@ -12087,8 +12163,19 @@ AdvInitGetConfig(struct pci_dev *pdev, ADV_DVC_VAR *asc_dvc)
 		warn_code |= status;
 	}
 
-	return warn_code;
+	if (warn_code != 0) {
+		ASC_PRINT2("AdvInitGetConfig: board %d: warning: 0x%x\n",
+			   boardp->id, warn_code);
+	}
+
+	if (asc_dvc->err_code) {
+		ASC_PRINT2("AdvInitGetConfig: board %d error: err_code 0x%x\n",
+		     boardp->id, asc_dvc->err_code);
+	}
+
+	return asc_dvc->err_code;
 }
+#endif
 
 static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
 {
@@ -15316,22 +15403,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			share_irq = 0;
 			break;
 		}
-	} else {
-		/*
-		 * For Wide boards set PCI information before calling
-		 * AdvInitGetConfig().
-		 */
-#ifdef CONFIG_PCI
-		shost->irq = adv_dvc_varp->irq_no = pdev->irq;
-		shost->unchecked_isa_dma = FALSE;
-		share_irq = IRQF_SHARED;
-#endif /* CONFIG_PCI */
-	}
 
-	/*
-	 * Read the board configuration.
-	 */
-	if (ASC_NARROW_BOARD(boardp)) {
 		/*
 		 * NOTE: AscInitGetConfig() may change the board's
 		 * bus_type value. The bus_type value should no
@@ -15339,60 +15411,20 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 * referenced only use the bit-wise AND operator "&".
 		 */
 		ASC_DBG(2, "advansys_board_found: AscInitGetConfig()\n");
-		switch (ret = AscInitGetConfig(asc_dvc_varp)) {
-		case 0:	/* No error */
-			break;
-		case ASC_WARN_IO_PORT_ROTATE:
-			ASC_PRINT1
-			    ("AscInitGetConfig: board %d: I/O port address modified\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_AUTO_CONFIG:
-			ASC_PRINT1
-			    ("AscInitGetConfig: board %d: I/O port increment switch enabled\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_EEPROM_CHKSUM:
-			ASC_PRINT1
-			    ("AscInitGetConfig: board %d: EEPROM checksum error\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_IRQ_MODIFIED:
-			ASC_PRINT1
-			    ("AscInitGetConfig: board %d: IRQ modified\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_CMD_QNG_CONFLICT:
-			ASC_PRINT1
-			    ("AscInitGetConfig: board %d: tag queuing enabled w/o disconnects\n",
-			     boardp->id);
-			break;
-		default:
-			ASC_PRINT2
-			    ("AscInitGetConfig: board %d: unknown warning: 0x%x\n",
-			     boardp->id, ret);
-			break;
-		}
-		if ((err_code = asc_dvc_varp->err_code) != 0) {
-			ASC_PRINT3
-			    ("AscInitGetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
-			     boardp->id,
-			     asc_dvc_varp->init_state, asc_dvc_varp->err_code);
-		}
+		err_code = AscInitGetConfig(boardp);
 	} else {
+#ifdef CONFIG_PCI
+		/*
+		 * For Wide boards set PCI information before calling
+		 * AdvInitGetConfig().
+		 */
+		shost->irq = adv_dvc_varp->irq_no = pdev->irq;
+		shost->unchecked_isa_dma = FALSE;
+		share_irq = IRQF_SHARED;
 		ASC_DBG(2, "advansys_board_found: AdvInitGetConfig()\n");
 
-		ret = AdvInitGetConfig(pdev, adv_dvc_varp);
-		if (ret != 0) {
-			ASC_PRINT2
-			    ("AdvInitGetConfig: board %d: warning: 0x%x\n",
-			     boardp->id, ret);
-		}
-		if ((err_code = adv_dvc_varp->err_code) != 0) {
-			ASC_PRINT2
-			    ("AdvInitGetConfig: board %d error: err_code 0x%x\n",
-			     boardp->id, adv_dvc_varp->err_code);
-		}
+		err_code = AdvInitGetConfig(pdev, boardp);
+#endif /* CONFIG_PCI */
 	}
 
 	if (err_code != 0)
@@ -15439,47 +15471,9 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 * Modify board configuration.
 		 */
 		ASC_DBG(2, "advansys_board_found: AscInitSetConfig()\n");
-		switch (ret = AscInitSetConfig(pdev, asc_dvc_varp)) {
-		case 0:	/* No error. */
-			break;
-		case ASC_WARN_IO_PORT_ROTATE:
-			ASC_PRINT1
-			    ("AscInitSetConfig: board %d: I/O port address modified\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_AUTO_CONFIG:
-			ASC_PRINT1
-			    ("AscInitSetConfig: board %d: I/O port increment switch enabled\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_EEPROM_CHKSUM:
-			ASC_PRINT1
-			    ("AscInitSetConfig: board %d: EEPROM checksum error\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_IRQ_MODIFIED:
-			ASC_PRINT1
-			    ("AscInitSetConfig: board %d: IRQ modified\n",
-			     boardp->id);
-			break;
-		case ASC_WARN_CMD_QNG_CONFLICT:
-			ASC_PRINT1
-			    ("AscInitSetConfig: board %d: tag queuing w/o disconnects\n",
-			     boardp->id);
-			break;
-		default:
-			ASC_PRINT2
-			    ("AscInitSetConfig: board %d: unknown warning: 0x%x\n",
-			     boardp->id, ret);
-			break;
-		}
-		if (asc_dvc_varp->err_code != 0) {
-			ASC_PRINT3
-			    ("AscInitSetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
-			     boardp->id,
-			     asc_dvc_varp->init_state, asc_dvc_varp->err_code);
+		err_code = AscInitSetConfig(pdev, boardp);
+		if (err_code)
 			goto err_free_proc;
-		}
 
 		/*
 		 * Finish initializing the 'Scsi_Host' structure.

commit 629d688d5c3805194b311ad6dcd6f0e90a924ca6
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:29 2007 -0600

    [SCSI] advansys: Reformat microcode
    
    It's just data, so format it to something that looks more visually
    appealing (and saves some lines)
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0f02f3f5f63d..5649bf4dd94e 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -8111,293 +8111,197 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 /* Microcode buffer is kept after initialization for error recovery. */
 static uchar _asc_mcode_buf[] = {
 	0x01, 0x03, 0x01, 0x19, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0xC3, 0x12, 0x0D, 0x05, 0x01, 0x00, 0x00, 0x00,
-	0x00, 0xFF, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x12, 0x0D, 0x05,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xFF,
-	0x00, 0x00, 0x00, 0x00,
-	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x88,
-	0x00, 0x00, 0x00, 0x00,
-	0x80, 0x73, 0x48, 0x04, 0x36, 0x00, 0x00, 0xA2, 0xC2, 0x00, 0x80, 0x73,
-	0x03, 0x23, 0x36, 0x40,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0xE4, 0x88, 0x00, 0x00, 0x00, 0x00, 0x80, 0x73, 0x48, 0x04,
+	0x36, 0x00, 0x00, 0xA2, 0xC2, 0x00, 0x80, 0x73, 0x03, 0x23, 0x36, 0x40,
 	0xB6, 0x00, 0x36, 0x00, 0x05, 0xD6, 0x0C, 0xD2, 0x12, 0xDA, 0x00, 0xA2,
-	0xC2, 0x00, 0x92, 0x80,
-	0x1E, 0x98, 0x50, 0x00, 0xF5, 0x00, 0x48, 0x98, 0xDF, 0x23, 0x36, 0x60,
-	0xB6, 0x00, 0x92, 0x80,
-	0x4F, 0x00, 0xF5, 0x00, 0x48, 0x98, 0xEF, 0x23, 0x36, 0x60, 0xB6, 0x00,
-	0x92, 0x80, 0x80, 0x62,
+	0xC2, 0x00, 0x92, 0x80, 0x1E, 0x98, 0x50, 0x00, 0xF5, 0x00, 0x48, 0x98,
+	0xDF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x4F, 0x00, 0xF5, 0x00,
+	0x48, 0x98, 0xEF, 0x23, 0x36, 0x60, 0xB6, 0x00, 0x92, 0x80, 0x80, 0x62,
 	0x92, 0x80, 0x00, 0x46, 0x15, 0xEE, 0x13, 0xEA, 0x02, 0x01, 0x09, 0xD8,
-	0xCD, 0x04, 0x4D, 0x00,
-	0x00, 0xA3, 0xD6, 0x00, 0xA6, 0x97, 0x7F, 0x23, 0x04, 0x61, 0x84, 0x01,
-	0xE6, 0x84, 0xD2, 0xC1,
-	0x80, 0x73, 0xCD, 0x04, 0x4D, 0x00, 0x00, 0xA3, 0xDA, 0x01, 0xA6, 0x97,
-	0xC6, 0x81, 0xC2, 0x88,
+	0xCD, 0x04, 0x4D, 0x00, 0x00, 0xA3, 0xD6, 0x00, 0xA6, 0x97, 0x7F, 0x23,
+	0x04, 0x61, 0x84, 0x01, 0xE6, 0x84, 0xD2, 0xC1, 0x80, 0x73, 0xCD, 0x04,
+	0x4D, 0x00, 0x00, 0xA3, 0xDA, 0x01, 0xA6, 0x97, 0xC6, 0x81, 0xC2, 0x88,
 	0x80, 0x73, 0x80, 0x77, 0x00, 0x01, 0x01, 0xA1, 0xFE, 0x00, 0x4F, 0x00,
-	0x84, 0x97, 0x07, 0xA6,
-	0x08, 0x01, 0x00, 0x33, 0x03, 0x00, 0xC2, 0x88, 0x03, 0x03, 0x01, 0xDE,
-	0xC2, 0x88, 0xCE, 0x00,
-	0x69, 0x60, 0xCE, 0x00, 0x02, 0x03, 0x4A, 0x60, 0x00, 0xA2, 0x78, 0x01,
-	0x80, 0x63, 0x07, 0xA6,
+	0x84, 0x97, 0x07, 0xA6, 0x08, 0x01, 0x00, 0x33, 0x03, 0x00, 0xC2, 0x88,
+	0x03, 0x03, 0x01, 0xDE, 0xC2, 0x88, 0xCE, 0x00, 0x69, 0x60, 0xCE, 0x00,
+	0x02, 0x03, 0x4A, 0x60, 0x00, 0xA2, 0x78, 0x01, 0x80, 0x63, 0x07, 0xA6,
 	0x24, 0x01, 0x78, 0x81, 0x03, 0x03, 0x80, 0x63, 0xE2, 0x00, 0x07, 0xA6,
-	0x34, 0x01, 0x00, 0x33,
-	0x04, 0x00, 0xC2, 0x88, 0x03, 0x07, 0x02, 0x01, 0x04, 0xCA, 0x0D, 0x23,
-	0x68, 0x98, 0x4D, 0x04,
-	0x04, 0x85, 0x05, 0xD8, 0x0D, 0x23, 0x68, 0x98, 0xCD, 0x04, 0x15, 0x23,
-	0xF8, 0x88, 0xFB, 0x23,
+	0x34, 0x01, 0x00, 0x33, 0x04, 0x00, 0xC2, 0x88, 0x03, 0x07, 0x02, 0x01,
+	0x04, 0xCA, 0x0D, 0x23, 0x68, 0x98, 0x4D, 0x04, 0x04, 0x85, 0x05, 0xD8,
+	0x0D, 0x23, 0x68, 0x98, 0xCD, 0x04, 0x15, 0x23, 0xF8, 0x88, 0xFB, 0x23,
 	0x02, 0x61, 0x82, 0x01, 0x80, 0x63, 0x02, 0x03, 0x06, 0xA3, 0x62, 0x01,
-	0x00, 0x33, 0x0A, 0x00,
-	0xC2, 0x88, 0x4E, 0x00, 0x07, 0xA3, 0x6E, 0x01, 0x00, 0x33, 0x0B, 0x00,
-	0xC2, 0x88, 0xCD, 0x04,
-	0x36, 0x2D, 0x00, 0x33, 0x1A, 0x00, 0xC2, 0x88, 0x50, 0x04, 0x88, 0x81,
-	0x06, 0xAB, 0x82, 0x01,
+	0x00, 0x33, 0x0A, 0x00, 0xC2, 0x88, 0x4E, 0x00, 0x07, 0xA3, 0x6E, 0x01,
+	0x00, 0x33, 0x0B, 0x00, 0xC2, 0x88, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33,
+	0x1A, 0x00, 0xC2, 0x88, 0x50, 0x04, 0x88, 0x81, 0x06, 0xAB, 0x82, 0x01,
 	0x88, 0x81, 0x4E, 0x00, 0x07, 0xA3, 0x92, 0x01, 0x50, 0x00, 0x00, 0xA3,
-	0x3C, 0x01, 0x00, 0x05,
-	0x7C, 0x81, 0x46, 0x97, 0x02, 0x01, 0x05, 0xC6, 0x04, 0x23, 0xA0, 0x01,
-	0x15, 0x23, 0xA1, 0x01,
-	0xBE, 0x81, 0xFD, 0x23, 0x02, 0x61, 0x82, 0x01, 0x0A, 0xDA, 0x4A, 0x00,
-	0x06, 0x61, 0x00, 0xA0,
+	0x3C, 0x01, 0x00, 0x05, 0x7C, 0x81, 0x46, 0x97, 0x02, 0x01, 0x05, 0xC6,
+	0x04, 0x23, 0xA0, 0x01, 0x15, 0x23, 0xA1, 0x01, 0xBE, 0x81, 0xFD, 0x23,
+	0x02, 0x61, 0x82, 0x01, 0x0A, 0xDA, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA0,
 	0xB4, 0x01, 0x80, 0x63, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33, 0x1B, 0x00,
-	0xC2, 0x88, 0x06, 0x23,
-	0x68, 0x98, 0xCD, 0x04, 0xE6, 0x84, 0x06, 0x01, 0x00, 0xA2, 0xD4, 0x01,
-	0x57, 0x60, 0x00, 0xA0,
-	0xDA, 0x01, 0xE6, 0x84, 0x80, 0x23, 0xA0, 0x01, 0xE6, 0x84, 0x80, 0x73,
-	0x4B, 0x00, 0x06, 0x61,
+	0xC2, 0x88, 0x06, 0x23, 0x68, 0x98, 0xCD, 0x04, 0xE6, 0x84, 0x06, 0x01,
+	0x00, 0xA2, 0xD4, 0x01, 0x57, 0x60, 0x00, 0xA0, 0xDA, 0x01, 0xE6, 0x84,
+	0x80, 0x23, 0xA0, 0x01, 0xE6, 0x84, 0x80, 0x73, 0x4B, 0x00, 0x06, 0x61,
 	0x00, 0xA2, 0x00, 0x02, 0x04, 0x01, 0x0C, 0xDE, 0x02, 0x01, 0x03, 0xCC,
-	0x4F, 0x00, 0x84, 0x97,
-	0xFC, 0x81, 0x08, 0x23, 0x02, 0x41, 0x82, 0x01, 0x4F, 0x00, 0x62, 0x97,
-	0x48, 0x04, 0x84, 0x80,
-	0xF0, 0x97, 0x00, 0x46, 0x56, 0x00, 0x03, 0xC0, 0x01, 0x23, 0xE8, 0x00,
-	0x81, 0x73, 0x06, 0x29,
+	0x4F, 0x00, 0x84, 0x97, 0xFC, 0x81, 0x08, 0x23, 0x02, 0x41, 0x82, 0x01,
+	0x4F, 0x00, 0x62, 0x97, 0x48, 0x04, 0x84, 0x80, 0xF0, 0x97, 0x00, 0x46,
+	0x56, 0x00, 0x03, 0xC0, 0x01, 0x23, 0xE8, 0x00, 0x81, 0x73, 0x06, 0x29,
 	0x03, 0x42, 0x06, 0xE2, 0x03, 0xEE, 0x6B, 0xEB, 0x11, 0x23, 0xF8, 0x88,
-	0x04, 0x98, 0xF0, 0x80,
-	0x80, 0x73, 0x80, 0x77, 0x07, 0xA4, 0x2A, 0x02, 0x7C, 0x95, 0x06, 0xA6,
-	0x34, 0x02, 0x03, 0xA6,
-	0x4C, 0x04, 0x46, 0x82, 0x04, 0x01, 0x03, 0xD8, 0xB4, 0x98, 0x6A, 0x96,
-	0x46, 0x82, 0xFE, 0x95,
+	0x04, 0x98, 0xF0, 0x80, 0x80, 0x73, 0x80, 0x77, 0x07, 0xA4, 0x2A, 0x02,
+	0x7C, 0x95, 0x06, 0xA6, 0x34, 0x02, 0x03, 0xA6, 0x4C, 0x04, 0x46, 0x82,
+	0x04, 0x01, 0x03, 0xD8, 0xB4, 0x98, 0x6A, 0x96, 0x46, 0x82, 0xFE, 0x95,
 	0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0xB6, 0x2D, 0x02, 0xA6, 0x6C, 0x02,
-	0x07, 0xA6, 0x5A, 0x02,
-	0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x62, 0x02, 0xC2, 0x88, 0x7C, 0x95,
-	0x48, 0x82, 0x60, 0x96,
-	0x48, 0x82, 0x04, 0x23, 0xA0, 0x01, 0x14, 0x23, 0xA1, 0x01, 0x3C, 0x84,
-	0x04, 0x01, 0x0C, 0xDC,
+	0x07, 0xA6, 0x5A, 0x02, 0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x62, 0x02,
+	0xC2, 0x88, 0x7C, 0x95, 0x48, 0x82, 0x60, 0x96, 0x48, 0x82, 0x04, 0x23,
+	0xA0, 0x01, 0x14, 0x23, 0xA1, 0x01, 0x3C, 0x84, 0x04, 0x01, 0x0C, 0xDC,
 	0xE0, 0x23, 0x25, 0x61, 0xEF, 0x00, 0x14, 0x01, 0x4F, 0x04, 0xA8, 0x01,
-	0x6F, 0x00, 0xA5, 0x01,
-	0x03, 0x23, 0xA4, 0x01, 0x06, 0x23, 0x9C, 0x01, 0x24, 0x2B, 0x1C, 0x01,
-	0x02, 0xA6, 0xAA, 0x02,
-	0x07, 0xA6, 0x5A, 0x02, 0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x20, 0x04,
-	0x01, 0xA6, 0xB4, 0x02,
+	0x6F, 0x00, 0xA5, 0x01, 0x03, 0x23, 0xA4, 0x01, 0x06, 0x23, 0x9C, 0x01,
+	0x24, 0x2B, 0x1C, 0x01, 0x02, 0xA6, 0xAA, 0x02, 0x07, 0xA6, 0x5A, 0x02,
+	0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x20, 0x04, 0x01, 0xA6, 0xB4, 0x02,
 	0x00, 0xA6, 0xB4, 0x02, 0x00, 0x33, 0x12, 0x00, 0xC2, 0x88, 0x00, 0x0E,
-	0x80, 0x63, 0x00, 0x43,
-	0x00, 0xA0, 0x8C, 0x02, 0x4D, 0x04, 0x04, 0x01, 0x0B, 0xDC, 0xE7, 0x23,
-	0x04, 0x61, 0x84, 0x01,
-	0x10, 0x31, 0x12, 0x35, 0x14, 0x01, 0xEC, 0x00, 0x6C, 0x38, 0x00, 0x3F,
-	0x00, 0x00, 0xEA, 0x82,
+	0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0x8C, 0x02, 0x4D, 0x04, 0x04, 0x01,
+	0x0B, 0xDC, 0xE7, 0x23, 0x04, 0x61, 0x84, 0x01, 0x10, 0x31, 0x12, 0x35,
+	0x14, 0x01, 0xEC, 0x00, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0xEA, 0x82,
 	0x18, 0x23, 0x04, 0x61, 0x18, 0xA0, 0xE2, 0x02, 0x04, 0x01, 0xA2, 0xC8,
-	0x00, 0x33, 0x1F, 0x00,
-	0xC2, 0x88, 0x08, 0x31, 0x0A, 0x35, 0x0C, 0x39, 0x0E, 0x3D, 0x7E, 0x98,
-	0xB6, 0x2D, 0x01, 0xA6,
-	0x14, 0x03, 0x00, 0xA6, 0x14, 0x03, 0x07, 0xA6, 0x0C, 0x03, 0x06, 0xA6,
-	0x10, 0x03, 0x03, 0xA6,
+	0x00, 0x33, 0x1F, 0x00, 0xC2, 0x88, 0x08, 0x31, 0x0A, 0x35, 0x0C, 0x39,
+	0x0E, 0x3D, 0x7E, 0x98, 0xB6, 0x2D, 0x01, 0xA6, 0x14, 0x03, 0x00, 0xA6,
+	0x14, 0x03, 0x07, 0xA6, 0x0C, 0x03, 0x06, 0xA6, 0x10, 0x03, 0x03, 0xA6,
 	0x20, 0x04, 0x02, 0xA6, 0x6C, 0x02, 0x00, 0x33, 0x33, 0x00, 0xC2, 0x88,
-	0x7C, 0x95, 0xEE, 0x82,
-	0x60, 0x96, 0xEE, 0x82, 0x82, 0x98, 0x80, 0x42, 0x7E, 0x98, 0x64, 0xE4,
-	0x04, 0x01, 0x2D, 0xC8,
-	0x31, 0x05, 0x07, 0x01, 0x00, 0xA2, 0x54, 0x03, 0x00, 0x43, 0x87, 0x01,
-	0x05, 0x05, 0x86, 0x98,
+	0x7C, 0x95, 0xEE, 0x82, 0x60, 0x96, 0xEE, 0x82, 0x82, 0x98, 0x80, 0x42,
+	0x7E, 0x98, 0x64, 0xE4, 0x04, 0x01, 0x2D, 0xC8, 0x31, 0x05, 0x07, 0x01,
+	0x00, 0xA2, 0x54, 0x03, 0x00, 0x43, 0x87, 0x01, 0x05, 0x05, 0x86, 0x98,
 	0x7E, 0x98, 0x00, 0xA6, 0x16, 0x03, 0x07, 0xA6, 0x4C, 0x03, 0x03, 0xA6,
-	0x3C, 0x04, 0x06, 0xA6,
-	0x50, 0x03, 0x01, 0xA6, 0x16, 0x03, 0x00, 0x33, 0x25, 0x00, 0xC2, 0x88,
-	0x7C, 0x95, 0x32, 0x83,
-	0x60, 0x96, 0x32, 0x83, 0x04, 0x01, 0x10, 0xCE, 0x07, 0xC8, 0x05, 0x05,
-	0xEB, 0x04, 0x00, 0x33,
+	0x3C, 0x04, 0x06, 0xA6, 0x50, 0x03, 0x01, 0xA6, 0x16, 0x03, 0x00, 0x33,
+	0x25, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x32, 0x83, 0x60, 0x96, 0x32, 0x83,
+	0x04, 0x01, 0x10, 0xCE, 0x07, 0xC8, 0x05, 0x05, 0xEB, 0x04, 0x00, 0x33,
 	0x00, 0x20, 0xC0, 0x20, 0x81, 0x62, 0x72, 0x83, 0x00, 0x01, 0x05, 0x05,
-	0xFF, 0xA2, 0x7A, 0x03,
-	0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x2E, 0x83, 0x05, 0x05, 0x15, 0x01,
-	0x00, 0xA2, 0x9A, 0x03,
-	0xEC, 0x00, 0x6E, 0x00, 0x95, 0x01, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00,
-	0x01, 0xA6, 0x96, 0x03,
+	0xFF, 0xA2, 0x7A, 0x03, 0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x2E, 0x83,
+	0x05, 0x05, 0x15, 0x01, 0x00, 0xA2, 0x9A, 0x03, 0xEC, 0x00, 0x6E, 0x00,
+	0x95, 0x01, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00, 0x01, 0xA6, 0x96, 0x03,
 	0x00, 0xA6, 0x96, 0x03, 0x10, 0x84, 0x80, 0x42, 0x7E, 0x98, 0x01, 0xA6,
-	0xA4, 0x03, 0x00, 0xA6,
-	0xBC, 0x03, 0x10, 0x84, 0xA8, 0x98, 0x80, 0x42, 0x01, 0xA6, 0xA4, 0x03,
-	0x07, 0xA6, 0xB2, 0x03,
-	0xD4, 0x83, 0x7C, 0x95, 0xA8, 0x83, 0x00, 0x33, 0x2F, 0x00, 0xC2, 0x88,
-	0xA8, 0x98, 0x80, 0x42,
+	0xA4, 0x03, 0x00, 0xA6, 0xBC, 0x03, 0x10, 0x84, 0xA8, 0x98, 0x80, 0x42,
+	0x01, 0xA6, 0xA4, 0x03, 0x07, 0xA6, 0xB2, 0x03, 0xD4, 0x83, 0x7C, 0x95,
+	0xA8, 0x83, 0x00, 0x33, 0x2F, 0x00, 0xC2, 0x88, 0xA8, 0x98, 0x80, 0x42,
 	0x00, 0xA6, 0xBC, 0x03, 0x07, 0xA6, 0xCA, 0x03, 0xD4, 0x83, 0x7C, 0x95,
-	0xC0, 0x83, 0x00, 0x33,
-	0x26, 0x00, 0xC2, 0x88, 0x38, 0x2B, 0x80, 0x32, 0x80, 0x36, 0x04, 0x23,
-	0xA0, 0x01, 0x12, 0x23,
-	0xA1, 0x01, 0x10, 0x84, 0x07, 0xF0, 0x06, 0xA4, 0xF4, 0x03, 0x80, 0x6B,
-	0x80, 0x67, 0x05, 0x23,
+	0xC0, 0x83, 0x00, 0x33, 0x26, 0x00, 0xC2, 0x88, 0x38, 0x2B, 0x80, 0x32,
+	0x80, 0x36, 0x04, 0x23, 0xA0, 0x01, 0x12, 0x23, 0xA1, 0x01, 0x10, 0x84,
+	0x07, 0xF0, 0x06, 0xA4, 0xF4, 0x03, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23,
 	0x83, 0x03, 0x80, 0x63, 0x03, 0xA6, 0x0E, 0x04, 0x07, 0xA6, 0x06, 0x04,
-	0x06, 0xA6, 0x0A, 0x04,
-	0x00, 0x33, 0x17, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0xF4, 0x83, 0x60, 0x96,
-	0xF4, 0x83, 0x20, 0x84,
-	0x07, 0xF0, 0x06, 0xA4, 0x20, 0x04, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23,
-	0x83, 0x03, 0x80, 0x63,
+	0x06, 0xA6, 0x0A, 0x04, 0x00, 0x33, 0x17, 0x00, 0xC2, 0x88, 0x7C, 0x95,
+	0xF4, 0x83, 0x60, 0x96, 0xF4, 0x83, 0x20, 0x84, 0x07, 0xF0, 0x06, 0xA4,
+	0x20, 0x04, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23, 0x83, 0x03, 0x80, 0x63,
 	0xB6, 0x2D, 0x03, 0xA6, 0x3C, 0x04, 0x07, 0xA6, 0x34, 0x04, 0x06, 0xA6,
-	0x38, 0x04, 0x00, 0x33,
-	0x30, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x20, 0x84, 0x60, 0x96, 0x20, 0x84,
-	0x1D, 0x01, 0x06, 0xCC,
-	0x00, 0x33, 0x00, 0x84, 0xC0, 0x20, 0x00, 0x23, 0xEA, 0x00, 0x81, 0x62,
-	0xA2, 0x0D, 0x80, 0x63,
+	0x38, 0x04, 0x00, 0x33, 0x30, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x20, 0x84,
+	0x60, 0x96, 0x20, 0x84, 0x1D, 0x01, 0x06, 0xCC, 0x00, 0x33, 0x00, 0x84,
+	0xC0, 0x20, 0x00, 0x23, 0xEA, 0x00, 0x81, 0x62, 0xA2, 0x0D, 0x80, 0x63,
 	0x07, 0xA6, 0x5A, 0x04, 0x00, 0x33, 0x18, 0x00, 0xC2, 0x88, 0x03, 0x03,
-	0x80, 0x63, 0xA3, 0x01,
-	0x07, 0xA4, 0x64, 0x04, 0x23, 0x01, 0x00, 0xA2, 0x86, 0x04, 0x0A, 0xA0,
-	0x76, 0x04, 0xE0, 0x00,
-	0x00, 0x33, 0x1D, 0x00, 0xC2, 0x88, 0x0B, 0xA0, 0x82, 0x04, 0xE0, 0x00,
-	0x00, 0x33, 0x1E, 0x00,
+	0x80, 0x63, 0xA3, 0x01, 0x07, 0xA4, 0x64, 0x04, 0x23, 0x01, 0x00, 0xA2,
+	0x86, 0x04, 0x0A, 0xA0, 0x76, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1D, 0x00,
+	0xC2, 0x88, 0x0B, 0xA0, 0x82, 0x04, 0xE0, 0x00, 0x00, 0x33, 0x1E, 0x00,
 	0xC2, 0x88, 0x42, 0x23, 0xF8, 0x88, 0x00, 0x23, 0x22, 0xA3, 0xE6, 0x04,
-	0x08, 0x23, 0x22, 0xA3,
-	0xA2, 0x04, 0x28, 0x23, 0x22, 0xA3, 0xAE, 0x04, 0x02, 0x23, 0x22, 0xA3,
-	0xC4, 0x04, 0x42, 0x23,
-	0xF8, 0x88, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA0, 0xAE, 0x04, 0x45, 0x23,
-	0xF8, 0x88, 0x04, 0x98,
+	0x08, 0x23, 0x22, 0xA3, 0xA2, 0x04, 0x28, 0x23, 0x22, 0xA3, 0xAE, 0x04,
+	0x02, 0x23, 0x22, 0xA3, 0xC4, 0x04, 0x42, 0x23, 0xF8, 0x88, 0x4A, 0x00,
+	0x06, 0x61, 0x00, 0xA0, 0xAE, 0x04, 0x45, 0x23, 0xF8, 0x88, 0x04, 0x98,
 	0x00, 0xA2, 0xC0, 0x04, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x82, 0xC0, 0x20,
-	0x81, 0x62, 0xE8, 0x81,
-	0x47, 0x23, 0xF8, 0x88, 0x04, 0x01, 0x0B, 0xDE, 0x04, 0x98, 0xB4, 0x98,
-	0x00, 0x33, 0x00, 0x81,
-	0xC0, 0x20, 0x81, 0x62, 0x14, 0x01, 0x00, 0xA0, 0x00, 0x02, 0x43, 0x23,
-	0xF8, 0x88, 0x04, 0x23,
+	0x81, 0x62, 0xE8, 0x81, 0x47, 0x23, 0xF8, 0x88, 0x04, 0x01, 0x0B, 0xDE,
+	0x04, 0x98, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x81, 0xC0, 0x20, 0x81, 0x62,
+	0x14, 0x01, 0x00, 0xA0, 0x00, 0x02, 0x43, 0x23, 0xF8, 0x88, 0x04, 0x23,
 	0xA0, 0x01, 0x44, 0x23, 0xA1, 0x01, 0x80, 0x73, 0x4D, 0x00, 0x03, 0xA3,
-	0xF4, 0x04, 0x00, 0x33,
-	0x27, 0x00, 0xC2, 0x88, 0x04, 0x01, 0x04, 0xDC, 0x02, 0x23, 0xA2, 0x01,
-	0x04, 0x23, 0xA0, 0x01,
-	0x04, 0x98, 0x26, 0x95, 0x4B, 0x00, 0xF6, 0x00, 0x4F, 0x04, 0x4F, 0x00,
-	0x00, 0xA3, 0x22, 0x05,
+	0xF4, 0x04, 0x00, 0x33, 0x27, 0x00, 0xC2, 0x88, 0x04, 0x01, 0x04, 0xDC,
+	0x02, 0x23, 0xA2, 0x01, 0x04, 0x23, 0xA0, 0x01, 0x04, 0x98, 0x26, 0x95,
+	0x4B, 0x00, 0xF6, 0x00, 0x4F, 0x04, 0x4F, 0x00, 0x00, 0xA3, 0x22, 0x05,
 	0x00, 0x05, 0x76, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x1C, 0x05, 0x0A, 0x85,
-	0x46, 0x97, 0xCD, 0x04,
-	0x24, 0x85, 0x48, 0x04, 0x84, 0x80, 0x02, 0x01, 0x03, 0xDA, 0x80, 0x23,
-	0x82, 0x01, 0x34, 0x85,
-	0x02, 0x23, 0xA0, 0x01, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x40, 0x05,
-	0x1D, 0x01, 0x04, 0xD6,
+	0x46, 0x97, 0xCD, 0x04, 0x24, 0x85, 0x48, 0x04, 0x84, 0x80, 0x02, 0x01,
+	0x03, 0xDA, 0x80, 0x23, 0x82, 0x01, 0x34, 0x85, 0x02, 0x23, 0xA0, 0x01,
+	0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x40, 0x05, 0x1D, 0x01, 0x04, 0xD6,
 	0xFF, 0x23, 0x86, 0x41, 0x4B, 0x60, 0xCB, 0x00, 0xFF, 0x23, 0x80, 0x01,
-	0x49, 0x00, 0x81, 0x01,
-	0x04, 0x01, 0x02, 0xC8, 0x30, 0x01, 0x80, 0x01, 0xF7, 0x04, 0x03, 0x01,
-	0x49, 0x04, 0x80, 0x01,
-	0xC9, 0x00, 0x00, 0x05, 0x00, 0x01, 0xFF, 0xA0, 0x60, 0x05, 0x77, 0x04,
-	0x01, 0x23, 0xEA, 0x00,
+	0x49, 0x00, 0x81, 0x01, 0x04, 0x01, 0x02, 0xC8, 0x30, 0x01, 0x80, 0x01,
+	0xF7, 0x04, 0x03, 0x01, 0x49, 0x04, 0x80, 0x01, 0xC9, 0x00, 0x00, 0x05,
+	0x00, 0x01, 0xFF, 0xA0, 0x60, 0x05, 0x77, 0x04, 0x01, 0x23, 0xEA, 0x00,
 	0x5D, 0x00, 0xFE, 0xC7, 0x00, 0x62, 0x00, 0x23, 0xEA, 0x00, 0x00, 0x63,
-	0x07, 0xA4, 0xF8, 0x05,
-	0x03, 0x03, 0x02, 0xA0, 0x8E, 0x05, 0xF4, 0x85, 0x00, 0x33, 0x2D, 0x00,
-	0xC2, 0x88, 0x04, 0xA0,
-	0xB8, 0x05, 0x80, 0x63, 0x00, 0x23, 0xDF, 0x00, 0x4A, 0x00, 0x06, 0x61,
-	0x00, 0xA2, 0xA4, 0x05,
+	0x07, 0xA4, 0xF8, 0x05, 0x03, 0x03, 0x02, 0xA0, 0x8E, 0x05, 0xF4, 0x85,
+	0x00, 0x33, 0x2D, 0x00, 0xC2, 0x88, 0x04, 0xA0, 0xB8, 0x05, 0x80, 0x63,
+	0x00, 0x23, 0xDF, 0x00, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0xA4, 0x05,
 	0x1D, 0x01, 0x06, 0xD6, 0x02, 0x23, 0x02, 0x41, 0x82, 0x01, 0x50, 0x00,
-	0x62, 0x97, 0x04, 0x85,
-	0x04, 0x23, 0x02, 0x41, 0x82, 0x01, 0x04, 0x85, 0x08, 0xA0, 0xBE, 0x05,
-	0xF4, 0x85, 0x03, 0xA0,
-	0xC4, 0x05, 0xF4, 0x85, 0x01, 0xA0, 0xCE, 0x05, 0x88, 0x00, 0x80, 0x63,
-	0xCC, 0x86, 0x07, 0xA0,
+	0x62, 0x97, 0x04, 0x85, 0x04, 0x23, 0x02, 0x41, 0x82, 0x01, 0x04, 0x85,
+	0x08, 0xA0, 0xBE, 0x05, 0xF4, 0x85, 0x03, 0xA0, 0xC4, 0x05, 0xF4, 0x85,
+	0x01, 0xA0, 0xCE, 0x05, 0x88, 0x00, 0x80, 0x63, 0xCC, 0x86, 0x07, 0xA0,
 	0xEE, 0x05, 0x5F, 0x00, 0x00, 0x2B, 0xDF, 0x08, 0x00, 0xA2, 0xE6, 0x05,
-	0x80, 0x67, 0x80, 0x63,
-	0x01, 0xA2, 0x7A, 0x06, 0x7C, 0x85, 0x06, 0x23, 0x68, 0x98, 0x48, 0x23,
-	0xF8, 0x88, 0x07, 0x23,
-	0x80, 0x00, 0x06, 0x87, 0x80, 0x63, 0x7C, 0x85, 0x00, 0x23, 0xDF, 0x00,
-	0x00, 0x63, 0x4A, 0x00,
+	0x80, 0x67, 0x80, 0x63, 0x01, 0xA2, 0x7A, 0x06, 0x7C, 0x85, 0x06, 0x23,
+	0x68, 0x98, 0x48, 0x23, 0xF8, 0x88, 0x07, 0x23, 0x80, 0x00, 0x06, 0x87,
+	0x80, 0x63, 0x7C, 0x85, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63, 0x4A, 0x00,
 	0x06, 0x61, 0x00, 0xA2, 0x36, 0x06, 0x1D, 0x01, 0x16, 0xD4, 0xC0, 0x23,
-	0x07, 0x41, 0x83, 0x03,
-	0x80, 0x63, 0x06, 0xA6, 0x1C, 0x06, 0x00, 0x33, 0x37, 0x00, 0xC2, 0x88,
-	0x1D, 0x01, 0x01, 0xD6,
-	0x20, 0x23, 0x63, 0x60, 0x83, 0x03, 0x80, 0x63, 0x02, 0x23, 0xDF, 0x00,
-	0x07, 0xA6, 0x7C, 0x05,
+	0x07, 0x41, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x1C, 0x06, 0x00, 0x33,
+	0x37, 0x00, 0xC2, 0x88, 0x1D, 0x01, 0x01, 0xD6, 0x20, 0x23, 0x63, 0x60,
+	0x83, 0x03, 0x80, 0x63, 0x02, 0x23, 0xDF, 0x00, 0x07, 0xA6, 0x7C, 0x05,
 	0xEF, 0x04, 0x6F, 0x00, 0x00, 0x63, 0x4B, 0x00, 0x06, 0x41, 0xCB, 0x00,
-	0x52, 0x00, 0x06, 0x61,
-	0x00, 0xA2, 0x4E, 0x06, 0x1D, 0x01, 0x03, 0xCA, 0xC0, 0x23, 0x07, 0x41,
-	0x00, 0x63, 0x1D, 0x01,
-	0x04, 0xCC, 0x00, 0x33, 0x00, 0x83, 0xC0, 0x20, 0x81, 0x62, 0x80, 0x23,
-	0x07, 0x41, 0x00, 0x63,
+	0x52, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x4E, 0x06, 0x1D, 0x01, 0x03, 0xCA,
+	0xC0, 0x23, 0x07, 0x41, 0x00, 0x63, 0x1D, 0x01, 0x04, 0xCC, 0x00, 0x33,
+	0x00, 0x83, 0xC0, 0x20, 0x81, 0x62, 0x80, 0x23, 0x07, 0x41, 0x00, 0x63,
 	0x80, 0x67, 0x08, 0x23, 0x83, 0x03, 0x80, 0x63, 0x00, 0x63, 0x01, 0x23,
-	0xDF, 0x00, 0x06, 0xA6,
-	0x84, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67, 0x80, 0x63, 0x00, 0x33,
-	0x00, 0x40, 0xC0, 0x20,
-	0x81, 0x62, 0x00, 0x63, 0x00, 0x00, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63,
-	0x06, 0xA6, 0x94, 0x06,
+	0xDF, 0x00, 0x06, 0xA6, 0x84, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67,
+	0x80, 0x63, 0x00, 0x33, 0x00, 0x40, 0xC0, 0x20, 0x81, 0x62, 0x00, 0x63,
+	0x00, 0x00, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6, 0x94, 0x06,
 	0x07, 0xA6, 0x7C, 0x05, 0x00, 0x00, 0x01, 0xA0, 0x14, 0x07, 0x00, 0x2B,
-	0x40, 0x0E, 0x80, 0x63,
-	0x01, 0x00, 0x06, 0xA6, 0xAA, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x40, 0x0E,
-	0x80, 0x63, 0x00, 0x43,
-	0x00, 0xA0, 0xA2, 0x06, 0x06, 0xA6, 0xBC, 0x06, 0x07, 0xA6, 0x7C, 0x05,
-	0x80, 0x67, 0x40, 0x0E,
+	0x40, 0x0E, 0x80, 0x63, 0x01, 0x00, 0x06, 0xA6, 0xAA, 0x06, 0x07, 0xA6,
+	0x7C, 0x05, 0x40, 0x0E, 0x80, 0x63, 0x00, 0x43, 0x00, 0xA0, 0xA2, 0x06,
+	0x06, 0xA6, 0xBC, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67, 0x40, 0x0E,
 	0x80, 0x63, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63,
-	0x07, 0xA6, 0xD6, 0x06,
-	0x00, 0x33, 0x2A, 0x00, 0xC2, 0x88, 0x03, 0x03, 0x80, 0x63, 0x89, 0x00,
-	0x0A, 0x2B, 0x07, 0xA6,
-	0xE8, 0x06, 0x00, 0x33, 0x29, 0x00, 0xC2, 0x88, 0x00, 0x43, 0x00, 0xA2,
-	0xF4, 0x06, 0xC0, 0x0E,
+	0x07, 0xA6, 0xD6, 0x06, 0x00, 0x33, 0x2A, 0x00, 0xC2, 0x88, 0x03, 0x03,
+	0x80, 0x63, 0x89, 0x00, 0x0A, 0x2B, 0x07, 0xA6, 0xE8, 0x06, 0x00, 0x33,
+	0x29, 0x00, 0xC2, 0x88, 0x00, 0x43, 0x00, 0xA2, 0xF4, 0x06, 0xC0, 0x0E,
 	0x80, 0x63, 0xDE, 0x86, 0xC0, 0x0E, 0x00, 0x33, 0x00, 0x80, 0xC0, 0x20,
-	0x81, 0x62, 0x04, 0x01,
-	0x02, 0xDA, 0x80, 0x63, 0x7C, 0x85, 0x80, 0x7B, 0x80, 0x63, 0x06, 0xA6,
-	0x8C, 0x06, 0x00, 0x33,
-	0x2C, 0x00, 0xC2, 0x88, 0x0C, 0xA2, 0x2E, 0x07, 0xFE, 0x95, 0x83, 0x03,
-	0x80, 0x63, 0x06, 0xA6,
+	0x81, 0x62, 0x04, 0x01, 0x02, 0xDA, 0x80, 0x63, 0x7C, 0x85, 0x80, 0x7B,
+	0x80, 0x63, 0x06, 0xA6, 0x8C, 0x06, 0x00, 0x33, 0x2C, 0x00, 0xC2, 0x88,
+	0x0C, 0xA2, 0x2E, 0x07, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63, 0x06, 0xA6,
 	0x2C, 0x07, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x33, 0x3D, 0x00, 0xC2, 0x88,
-	0x00, 0x00, 0x80, 0x67,
-	0x83, 0x03, 0x80, 0x63, 0x0C, 0xA0, 0x44, 0x07, 0x07, 0xA6, 0x7C, 0x05,
-	0xBF, 0x23, 0x04, 0x61,
-	0x84, 0x01, 0xE6, 0x84, 0x00, 0x63, 0xF0, 0x04, 0x01, 0x01, 0xF1, 0x00,
-	0x00, 0x01, 0xF2, 0x00,
+	0x00, 0x00, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0x0C, 0xA0, 0x44, 0x07,
+	0x07, 0xA6, 0x7C, 0x05, 0xBF, 0x23, 0x04, 0x61, 0x84, 0x01, 0xE6, 0x84,
+	0x00, 0x63, 0xF0, 0x04, 0x01, 0x01, 0xF1, 0x00, 0x00, 0x01, 0xF2, 0x00,
 	0x01, 0x05, 0x80, 0x01, 0x72, 0x04, 0x71, 0x00, 0x81, 0x01, 0x70, 0x04,
-	0x80, 0x05, 0x81, 0x05,
-	0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x01, 0x01, 0xF1, 0x00,
-	0x70, 0x00, 0x81, 0x01,
-	0x70, 0x04, 0x71, 0x00, 0x81, 0x01, 0x72, 0x00, 0x80, 0x01, 0x71, 0x04,
-	0x70, 0x00, 0x80, 0x01,
+	0x80, 0x05, 0x81, 0x05, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04,
+	0x01, 0x01, 0xF1, 0x00, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04, 0x71, 0x00,
+	0x81, 0x01, 0x72, 0x00, 0x80, 0x01, 0x71, 0x04, 0x70, 0x00, 0x80, 0x01,
 	0x70, 0x04, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x00, 0x01,
-	0xF1, 0x00, 0x70, 0x00,
-	0x80, 0x01, 0x70, 0x04, 0x71, 0x00, 0x80, 0x01, 0x72, 0x00, 0x81, 0x01,
-	0x71, 0x04, 0x70, 0x00,
-	0x81, 0x01, 0x70, 0x04, 0x00, 0x63, 0x00, 0x23, 0xB3, 0x01, 0x83, 0x05,
-	0xA3, 0x01, 0xA2, 0x01,
+	0xF1, 0x00, 0x70, 0x00, 0x80, 0x01, 0x70, 0x04, 0x71, 0x00, 0x80, 0x01,
+	0x72, 0x00, 0x81, 0x01, 0x71, 0x04, 0x70, 0x00, 0x81, 0x01, 0x70, 0x04,
+	0x00, 0x63, 0x00, 0x23, 0xB3, 0x01, 0x83, 0x05, 0xA3, 0x01, 0xA2, 0x01,
 	0xA1, 0x01, 0x01, 0x23, 0xA0, 0x01, 0x00, 0x01, 0xC8, 0x00, 0x03, 0xA1,
-	0xC4, 0x07, 0x00, 0x33,
-	0x07, 0x00, 0xC2, 0x88, 0x80, 0x05, 0x81, 0x05, 0x04, 0x01, 0x11, 0xC8,
-	0x48, 0x00, 0xB0, 0x01,
-	0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x05, 0x01, 0x48, 0x04, 0x00, 0x43,
-	0x00, 0xA2, 0xE4, 0x07,
+	0xC4, 0x07, 0x00, 0x33, 0x07, 0x00, 0xC2, 0x88, 0x80, 0x05, 0x81, 0x05,
+	0x04, 0x01, 0x11, 0xC8, 0x48, 0x00, 0xB0, 0x01, 0xB1, 0x01, 0x08, 0x23,
+	0xB2, 0x01, 0x05, 0x01, 0x48, 0x04, 0x00, 0x43, 0x00, 0xA2, 0xE4, 0x07,
 	0x00, 0x05, 0xDA, 0x87, 0x00, 0x01, 0xC8, 0x00, 0xFF, 0x23, 0x80, 0x01,
-	0x05, 0x05, 0x00, 0x63,
-	0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04, 0x00, 0x02, 0x80, 0x43,
-	0x76, 0x08, 0x80, 0x02,
-	0x77, 0x04, 0x00, 0x63, 0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04,
-	0x00, 0x02, 0x00, 0xA0,
+	0x05, 0x05, 0x00, 0x63, 0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04,
+	0x00, 0x02, 0x80, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04, 0x00, 0x63,
+	0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04, 0x00, 0x02, 0x00, 0xA0,
 	0x14, 0x08, 0x16, 0x88, 0x00, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04,
-	0x00, 0x63, 0xF3, 0x04,
-	0x00, 0x23, 0xF4, 0x00, 0x74, 0x00, 0x80, 0x43, 0xF4, 0x00, 0xCF, 0x40,
-	0x00, 0xA2, 0x44, 0x08,
-	0x74, 0x04, 0x02, 0x01, 0xF7, 0xC9, 0xF6, 0xD9, 0x00, 0x01, 0x01, 0xA1,
-	0x24, 0x08, 0x04, 0x98,
+	0x00, 0x63, 0xF3, 0x04, 0x00, 0x23, 0xF4, 0x00, 0x74, 0x00, 0x80, 0x43,
+	0xF4, 0x00, 0xCF, 0x40, 0x00, 0xA2, 0x44, 0x08, 0x74, 0x04, 0x02, 0x01,
+	0xF7, 0xC9, 0xF6, 0xD9, 0x00, 0x01, 0x01, 0xA1, 0x24, 0x08, 0x04, 0x98,
 	0x26, 0x95, 0x24, 0x88, 0x73, 0x04, 0x00, 0x63, 0xF3, 0x04, 0x75, 0x04,
-	0x5A, 0x88, 0x02, 0x01,
-	0x04, 0xD8, 0x46, 0x97, 0x04, 0x98, 0x26, 0x95, 0x4A, 0x88, 0x75, 0x00,
-	0x00, 0xA3, 0x64, 0x08,
-	0x00, 0x05, 0x4E, 0x88, 0x73, 0x04, 0x00, 0x63, 0x80, 0x7B, 0x80, 0x63,
-	0x06, 0xA6, 0x76, 0x08,
+	0x5A, 0x88, 0x02, 0x01, 0x04, 0xD8, 0x46, 0x97, 0x04, 0x98, 0x26, 0x95,
+	0x4A, 0x88, 0x75, 0x00, 0x00, 0xA3, 0x64, 0x08, 0x00, 0x05, 0x4E, 0x88,
+	0x73, 0x04, 0x00, 0x63, 0x80, 0x7B, 0x80, 0x63, 0x06, 0xA6, 0x76, 0x08,
 	0x00, 0x33, 0x3E, 0x00, 0xC2, 0x88, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63,
-	0x00, 0x63, 0x38, 0x2B,
-	0x9C, 0x88, 0x38, 0x2B, 0x92, 0x88, 0x32, 0x09, 0x31, 0x05, 0x92, 0x98,
-	0x05, 0x05, 0xB2, 0x09,
-	0x00, 0x63, 0x00, 0x32, 0x00, 0x36, 0x00, 0x3A, 0x00, 0x3E, 0x00, 0x63,
-	0x80, 0x32, 0x80, 0x36,
+	0x00, 0x63, 0x38, 0x2B, 0x9C, 0x88, 0x38, 0x2B, 0x92, 0x88, 0x32, 0x09,
+	0x31, 0x05, 0x92, 0x98, 0x05, 0x05, 0xB2, 0x09, 0x00, 0x63, 0x00, 0x32,
+	0x00, 0x36, 0x00, 0x3A, 0x00, 0x3E, 0x00, 0x63, 0x80, 0x32, 0x80, 0x36,
 	0x80, 0x3A, 0x80, 0x3E, 0xB4, 0x3D, 0x00, 0x63, 0x38, 0x2B, 0x40, 0x32,
-	0x40, 0x36, 0x40, 0x3A,
-	0x40, 0x3E, 0x00, 0x63, 0x5A, 0x20, 0xC9, 0x40, 0x00, 0xA0, 0xB4, 0x08,
-	0x5D, 0x00, 0xFE, 0xC3,
-	0x00, 0x63, 0x80, 0x73, 0xE6, 0x20, 0x02, 0x23, 0xE8, 0x00, 0x82, 0x73,
-	0xFF, 0xFD, 0x80, 0x73,
+	0x40, 0x36, 0x40, 0x3A, 0x40, 0x3E, 0x00, 0x63, 0x5A, 0x20, 0xC9, 0x40,
+	0x00, 0xA0, 0xB4, 0x08, 0x5D, 0x00, 0xFE, 0xC3, 0x00, 0x63, 0x80, 0x73,
+	0xE6, 0x20, 0x02, 0x23, 0xE8, 0x00, 0x82, 0x73, 0xFF, 0xFD, 0x80, 0x73,
 	0x13, 0x23, 0xF8, 0x88, 0x66, 0x20, 0xC0, 0x20, 0x04, 0x23, 0xA0, 0x01,
-	0xA1, 0x23, 0xA1, 0x01,
-	0x81, 0x62, 0xE2, 0x88, 0x80, 0x73, 0x80, 0x77, 0x68, 0x00, 0x00, 0xA2,
-	0x80, 0x00, 0x03, 0xC2,
-	0xF1, 0xC7, 0x41, 0x23, 0xF8, 0x88, 0x11, 0x23, 0xA1, 0x01, 0x04, 0x23,
-	0xA0, 0x01, 0xE6, 0x84,
+	0xA1, 0x23, 0xA1, 0x01, 0x81, 0x62, 0xE2, 0x88, 0x80, 0x73, 0x80, 0x77,
+	0x68, 0x00, 0x00, 0xA2, 0x80, 0x00, 0x03, 0xC2, 0xF1, 0xC7, 0x41, 0x23,
+	0xF8, 0x88, 0x11, 0x23, 0xA1, 0x01, 0x04, 0x23, 0xA0, 0x01, 0xE6, 0x84,
 };
 
 static ushort _asc_mcode_size = sizeof(_asc_mcode_buf);
@@ -10343,633 +10247,424 @@ AscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)
 /* Microcode buffer is kept after initialization for error recovery. */
 static unsigned char _adv_asc3550_buf[] = {
 	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0x16, 0x18, 0xe4, 0x00, 0xfc,
-	0x01, 0x00, 0x48, 0xe4,
-	0xbe, 0x18, 0x18, 0x80, 0x03, 0xf6, 0x02, 0x00, 0x00, 0xfa, 0xff, 0xff,
-	0x28, 0x0e, 0x9e, 0xe7,
-	0xff, 0x00, 0x82, 0xe7, 0x00, 0xea, 0x00, 0xf6, 0x01, 0xe6, 0x09, 0xe7,
-	0x55, 0xf0, 0x01, 0xf6,
+	0x01, 0x00, 0x48, 0xe4, 0xbe, 0x18, 0x18, 0x80, 0x03, 0xf6, 0x02, 0x00,
+	0x00, 0xfa, 0xff, 0xff, 0x28, 0x0e, 0x9e, 0xe7, 0xff, 0x00, 0x82, 0xe7,
+	0x00, 0xea, 0x00, 0xf6, 0x01, 0xe6, 0x09, 0xe7, 0x55, 0xf0, 0x01, 0xf6,
 	0x01, 0xfa, 0x08, 0x00, 0x03, 0x00, 0x04, 0x00, 0x18, 0xf4, 0x10, 0x00,
-	0x00, 0xec, 0x85, 0xf0,
-	0xbc, 0x00, 0xd5, 0xf0, 0x8e, 0x0c, 0x38, 0x54, 0x00, 0xe6, 0x1e, 0xf0,
-	0x86, 0xf0, 0xb4, 0x00,
-	0x98, 0x57, 0xd0, 0x01, 0x0c, 0x1c, 0x3e, 0x1c, 0x0c, 0x00, 0xbb, 0x00,
-	0xaa, 0x18, 0x02, 0x80,
+	0x00, 0xec, 0x85, 0xf0, 0xbc, 0x00, 0xd5, 0xf0, 0x8e, 0x0c, 0x38, 0x54,
+	0x00, 0xe6, 0x1e, 0xf0, 0x86, 0xf0, 0xb4, 0x00, 0x98, 0x57, 0xd0, 0x01,
+	0x0c, 0x1c, 0x3e, 0x1c, 0x0c, 0x00, 0xbb, 0x00, 0xaa, 0x18, 0x02, 0x80,
 	0x32, 0xf0, 0x01, 0xfc, 0x88, 0x0c, 0xc6, 0x12, 0x02, 0x13, 0x18, 0x40,
-	0x00, 0x57, 0x01, 0xea,
-	0x3c, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12, 0x3e, 0x57, 0x00, 0x80,
-	0x03, 0xe6, 0xb6, 0x00,
-	0xc0, 0x00, 0x01, 0x01, 0x3e, 0x01, 0xda, 0x0f, 0x22, 0x10, 0x08, 0x12,
-	0x02, 0x4a, 0xb9, 0x54,
+	0x00, 0x57, 0x01, 0xea, 0x3c, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12,
+	0x3e, 0x57, 0x00, 0x80, 0x03, 0xe6, 0xb6, 0x00, 0xc0, 0x00, 0x01, 0x01,
+	0x3e, 0x01, 0xda, 0x0f, 0x22, 0x10, 0x08, 0x12, 0x02, 0x4a, 0xb9, 0x54,
 	0x03, 0x58, 0x1b, 0x80, 0x30, 0xe4, 0x4b, 0xe4, 0x20, 0x00, 0x32, 0x00,
-	0x3e, 0x00, 0x80, 0x00,
-	0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01, 0x70, 0x01, 0x72, 0x01,
-	0x74, 0x01, 0x76, 0x01,
-	0x78, 0x01, 0x62, 0x0a, 0x92, 0x0c, 0x2c, 0x10, 0x2e, 0x10, 0x06, 0x13,
-	0x4c, 0x1c, 0xbb, 0x55,
+	0x3e, 0x00, 0x80, 0x00, 0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01,
+	0x70, 0x01, 0x72, 0x01, 0x74, 0x01, 0x76, 0x01, 0x78, 0x01, 0x62, 0x0a,
+	0x92, 0x0c, 0x2c, 0x10, 0x2e, 0x10, 0x06, 0x13, 0x4c, 0x1c, 0xbb, 0x55,
 	0x3c, 0x56, 0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0, 0xb1, 0xf0,
-	0x03, 0xf7, 0x06, 0xf7,
-	0x03, 0xfc, 0x0f, 0x00, 0x40, 0x00, 0xbe, 0x00, 0x00, 0x01, 0xb0, 0x08,
-	0x30, 0x13, 0x64, 0x15,
-	0x32, 0x1c, 0x38, 0x1c, 0x4e, 0x1c, 0x10, 0x44, 0x02, 0x48, 0x00, 0x4c,
-	0x04, 0xea, 0x5d, 0xf0,
+	0x03, 0xf7, 0x06, 0xf7, 0x03, 0xfc, 0x0f, 0x00, 0x40, 0x00, 0xbe, 0x00,
+	0x00, 0x01, 0xb0, 0x08, 0x30, 0x13, 0x64, 0x15, 0x32, 0x1c, 0x38, 0x1c,
+	0x4e, 0x1c, 0x10, 0x44, 0x02, 0x48, 0x00, 0x4c, 0x04, 0xea, 0x5d, 0xf0,
 	0x04, 0xf6, 0x02, 0xfc, 0x05, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00,
-	0xcc, 0x00, 0x20, 0x01,
-	0x4e, 0x01, 0x4e, 0x0b, 0x1e, 0x0e, 0x0c, 0x10, 0x0a, 0x12, 0x04, 0x13,
-	0x40, 0x13, 0x30, 0x1c,
-	0x00, 0x4e, 0xbd, 0x56, 0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0,
-	0x59, 0xf0, 0xa7, 0xf0,
+	0xcc, 0x00, 0x20, 0x01, 0x4e, 0x01, 0x4e, 0x0b, 0x1e, 0x0e, 0x0c, 0x10,
+	0x0a, 0x12, 0x04, 0x13, 0x40, 0x13, 0x30, 0x1c, 0x00, 0x4e, 0xbd, 0x56,
+	0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0, 0x59, 0xf0, 0xa7, 0xf0,
 	0xb8, 0xf0, 0x0e, 0xf7, 0x06, 0x00, 0x19, 0x00, 0x33, 0x00, 0x9b, 0x00,
-	0xa4, 0x00, 0xb5, 0x00,
-	0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00, 0xe7, 0x00, 0xde, 0x03, 0x56, 0x0a,
-	0x14, 0x0e, 0x02, 0x10,
-	0x04, 0x10, 0x0a, 0x10, 0x36, 0x10, 0x0a, 0x13, 0x12, 0x13, 0x52, 0x13,
-	0x10, 0x15, 0x14, 0x15,
+	0xa4, 0x00, 0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00, 0xe7, 0x00,
+	0xde, 0x03, 0x56, 0x0a, 0x14, 0x0e, 0x02, 0x10, 0x04, 0x10, 0x0a, 0x10,
+	0x36, 0x10, 0x0a, 0x13, 0x12, 0x13, 0x52, 0x13, 0x10, 0x15, 0x14, 0x15,
 	0xac, 0x16, 0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c, 0x08, 0x44, 0x38, 0x44,
-	0x91, 0x44, 0x0a, 0x45,
-	0x48, 0x46, 0x01, 0x48, 0x68, 0x54, 0x83, 0x55, 0xb0, 0x57, 0x01, 0x58,
-	0x83, 0x59, 0x05, 0xe6,
-	0x0b, 0xf0, 0x0c, 0xf0, 0x5c, 0xf0, 0x4b, 0xf4, 0x04, 0xf8, 0x05, 0xf8,
-	0x02, 0xfa, 0x03, 0xfa,
+	0x91, 0x44, 0x0a, 0x45, 0x48, 0x46, 0x01, 0x48, 0x68, 0x54, 0x83, 0x55,
+	0xb0, 0x57, 0x01, 0x58, 0x83, 0x59, 0x05, 0xe6, 0x0b, 0xf0, 0x0c, 0xf0,
+	0x5c, 0xf0, 0x4b, 0xf4, 0x04, 0xf8, 0x05, 0xf8, 0x02, 0xfa, 0x03, 0xfa,
 	0x04, 0xfc, 0x05, 0xfc, 0x07, 0x00, 0x0a, 0x00, 0x0d, 0x00, 0x1c, 0x00,
-	0x9e, 0x00, 0xa8, 0x00,
-	0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00, 0x22, 0x01, 0x26, 0x01, 0x79, 0x01,
-	0x7a, 0x01, 0xc0, 0x01,
-	0xc2, 0x01, 0x7c, 0x02, 0x5a, 0x03, 0xea, 0x04, 0xe8, 0x07, 0x68, 0x08,
-	0x69, 0x08, 0xba, 0x08,
+	0x9e, 0x00, 0xa8, 0x00, 0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00, 0x22, 0x01,
+	0x26, 0x01, 0x79, 0x01, 0x7a, 0x01, 0xc0, 0x01, 0xc2, 0x01, 0x7c, 0x02,
+	0x5a, 0x03, 0xea, 0x04, 0xe8, 0x07, 0x68, 0x08, 0x69, 0x08, 0xba, 0x08,
 	0xe9, 0x09, 0x06, 0x0b, 0x3a, 0x0e, 0x00, 0x10, 0x1a, 0x10, 0xed, 0x10,
-	0xf1, 0x10, 0x06, 0x12,
-	0x0c, 0x13, 0x16, 0x13, 0x1e, 0x13, 0x82, 0x13, 0x42, 0x14, 0xd6, 0x14,
-	0x8a, 0x15, 0xc6, 0x17,
-	0xd2, 0x17, 0x6b, 0x18, 0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40,
-	0x0e, 0x47, 0x48, 0x47,
+	0xf1, 0x10, 0x06, 0x12, 0x0c, 0x13, 0x16, 0x13, 0x1e, 0x13, 0x82, 0x13,
+	0x42, 0x14, 0xd6, 0x14, 0x8a, 0x15, 0xc6, 0x17, 0xd2, 0x17, 0x6b, 0x18,
+	0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40, 0x0e, 0x47, 0x48, 0x47,
 	0x41, 0x48, 0x89, 0x48, 0x80, 0x4c, 0x00, 0x54, 0x44, 0x55, 0xe5, 0x55,
-	0x14, 0x56, 0x77, 0x57,
-	0xbf, 0x57, 0x40, 0x5c, 0x06, 0x80, 0x08, 0x90, 0x03, 0xa1, 0xfe, 0x9c,
-	0xf0, 0x29, 0x02, 0xfe,
-	0xb8, 0x0c, 0xff, 0x10, 0x00, 0x00, 0xd0, 0xfe, 0xcc, 0x18, 0x00, 0xcf,
-	0xfe, 0x80, 0x01, 0xff,
+	0x14, 0x56, 0x77, 0x57, 0xbf, 0x57, 0x40, 0x5c, 0x06, 0x80, 0x08, 0x90,
+	0x03, 0xa1, 0xfe, 0x9c, 0xf0, 0x29, 0x02, 0xfe, 0xb8, 0x0c, 0xff, 0x10,
+	0x00, 0x00, 0xd0, 0xfe, 0xcc, 0x18, 0x00, 0xcf, 0xfe, 0x80, 0x01, 0xff,
 	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
-	0x00, 0xfe, 0x57, 0x24,
-	0x00, 0xfe, 0x48, 0x00, 0x4f, 0xff, 0x04, 0x00, 0x00, 0x10, 0xff, 0x09,
-	0x00, 0x00, 0xff, 0x08,
-	0x01, 0x01, 0xff, 0x08, 0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10,
-	0xff, 0xff, 0xff, 0x0f,
+	0x00, 0xfe, 0x57, 0x24, 0x00, 0xfe, 0x48, 0x00, 0x4f, 0xff, 0x04, 0x00,
+	0x00, 0x10, 0xff, 0x09, 0x00, 0x00, 0xff, 0x08, 0x01, 0x01, 0xff, 0x08,
+	0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10, 0xff, 0xff, 0xff, 0x0f,
 	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
-	0xfe, 0x04, 0xf7, 0xcf,
-	0x2a, 0x67, 0x0b, 0x01, 0xfe, 0xce, 0x0e, 0xfe, 0x04, 0xf7, 0xcf, 0x67,
-	0x0b, 0x3c, 0x2a, 0xfe,
-	0x3d, 0xf0, 0xfe, 0x02, 0x02, 0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x91, 0xf0,
-	0xfe, 0xf0, 0x01, 0xfe,
+	0xfe, 0x04, 0xf7, 0xcf, 0x2a, 0x67, 0x0b, 0x01, 0xfe, 0xce, 0x0e, 0xfe,
+	0x04, 0xf7, 0xcf, 0x67, 0x0b, 0x3c, 0x2a, 0xfe, 0x3d, 0xf0, 0xfe, 0x02,
+	0x02, 0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x91, 0xf0, 0xfe, 0xf0, 0x01, 0xfe,
 	0x90, 0xf0, 0xfe, 0xf0, 0x01, 0xfe, 0x8f, 0xf0, 0x9c, 0x05, 0x51, 0x3b,
-	0x02, 0xfe, 0xd4, 0x0c,
-	0x01, 0xfe, 0x44, 0x0d, 0xfe, 0xdd, 0x12, 0xfe, 0xfc, 0x10, 0xfe, 0x28,
-	0x1c, 0x05, 0xfe, 0xa6,
-	0x00, 0xfe, 0xd3, 0x12, 0x47, 0x18, 0xfe, 0xa6, 0x00, 0xb5, 0xfe, 0x48,
-	0xf0, 0xfe, 0x86, 0x02,
+	0x02, 0xfe, 0xd4, 0x0c, 0x01, 0xfe, 0x44, 0x0d, 0xfe, 0xdd, 0x12, 0xfe,
+	0xfc, 0x10, 0xfe, 0x28, 0x1c, 0x05, 0xfe, 0xa6, 0x00, 0xfe, 0xd3, 0x12,
+	0x47, 0x18, 0xfe, 0xa6, 0x00, 0xb5, 0xfe, 0x48, 0xf0, 0xfe, 0x86, 0x02,
 	0xfe, 0x49, 0xf0, 0xfe, 0xa0, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xbe, 0x02,
-	0xfe, 0x46, 0xf0, 0xfe,
-	0x50, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x56, 0x02, 0xfe, 0x43, 0xf0, 0xfe,
-	0x44, 0x02, 0xfe, 0x44,
-	0xf0, 0xfe, 0x48, 0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x4c, 0x02, 0x17, 0x0b,
-	0xa0, 0x17, 0x06, 0x18,
+	0xfe, 0x46, 0xf0, 0xfe, 0x50, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x56, 0x02,
+	0xfe, 0x43, 0xf0, 0xfe, 0x44, 0x02, 0xfe, 0x44, 0xf0, 0xfe, 0x48, 0x02,
+	0xfe, 0x45, 0xf0, 0xfe, 0x4c, 0x02, 0x17, 0x0b, 0xa0, 0x17, 0x06, 0x18,
 	0x96, 0x02, 0x29, 0xfe, 0x00, 0x1c, 0xde, 0xfe, 0x02, 0x1c, 0xdd, 0xfe,
-	0x1e, 0x1c, 0xfe, 0xe9,
-	0x10, 0x01, 0xfe, 0x20, 0x17, 0xfe, 0xe7, 0x10, 0xfe, 0x06, 0xfc, 0xc7,
-	0x0a, 0x6b, 0x01, 0x9e,
-	0x02, 0x29, 0x14, 0x4d, 0x37, 0x97, 0x01, 0xfe, 0x64, 0x0f, 0x0a, 0x6b,
-	0x01, 0x82, 0xfe, 0xbd,
+	0x1e, 0x1c, 0xfe, 0xe9, 0x10, 0x01, 0xfe, 0x20, 0x17, 0xfe, 0xe7, 0x10,
+	0xfe, 0x06, 0xfc, 0xc7, 0x0a, 0x6b, 0x01, 0x9e, 0x02, 0x29, 0x14, 0x4d,
+	0x37, 0x97, 0x01, 0xfe, 0x64, 0x0f, 0x0a, 0x6b, 0x01, 0x82, 0xfe, 0xbd,
 	0x10, 0x0a, 0x6b, 0x01, 0x82, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c, 0xfe,
-	0x58, 0x1c, 0x17, 0x06,
-	0x18, 0x96, 0x2a, 0x25, 0x29, 0xfe, 0x3d, 0xf0, 0xfe, 0x02, 0x02, 0x21,
-	0xfe, 0x94, 0x02, 0xfe,
-	0x5a, 0x1c, 0xea, 0xfe, 0x14, 0x1c, 0x14, 0xfe, 0x30, 0x00, 0x37, 0x97,
-	0x01, 0xfe, 0x54, 0x0f,
+	0x58, 0x1c, 0x17, 0x06, 0x18, 0x96, 0x2a, 0x25, 0x29, 0xfe, 0x3d, 0xf0,
+	0xfe, 0x02, 0x02, 0x21, 0xfe, 0x94, 0x02, 0xfe, 0x5a, 0x1c, 0xea, 0xfe,
+	0x14, 0x1c, 0x14, 0xfe, 0x30, 0x00, 0x37, 0x97, 0x01, 0xfe, 0x54, 0x0f,
 	0x17, 0x06, 0x18, 0x96, 0x02, 0xd0, 0x1e, 0x20, 0x07, 0x10, 0x34, 0xfe,
-	0x69, 0x10, 0x17, 0x06,
-	0x18, 0x96, 0xfe, 0x04, 0xec, 0x20, 0x46, 0x3d, 0x12, 0x20, 0xfe, 0x05,
-	0xf6, 0xc7, 0x01, 0xfe,
-	0x52, 0x16, 0x09, 0x4a, 0x4c, 0x35, 0x11, 0x2d, 0x3c, 0x8a, 0x01, 0xe6,
-	0x02, 0x29, 0x0a, 0x40,
+	0x69, 0x10, 0x17, 0x06, 0x18, 0x96, 0xfe, 0x04, 0xec, 0x20, 0x46, 0x3d,
+	0x12, 0x20, 0xfe, 0x05, 0xf6, 0xc7, 0x01, 0xfe, 0x52, 0x16, 0x09, 0x4a,
+	0x4c, 0x35, 0x11, 0x2d, 0x3c, 0x8a, 0x01, 0xe6, 0x02, 0x29, 0x0a, 0x40,
 	0x01, 0x0e, 0x07, 0x00, 0x5d, 0x01, 0x6f, 0xfe, 0x18, 0x10, 0xfe, 0x41,
-	0x58, 0x0a, 0x99, 0x01,
-	0x0e, 0xfe, 0xc8, 0x54, 0x64, 0xfe, 0x0c, 0x03, 0x01, 0xe6, 0x02, 0x29,
-	0x2a, 0x46, 0xfe, 0x02,
-	0xe8, 0x27, 0xf8, 0xfe, 0x9e, 0x43, 0xf7, 0xfe, 0x27, 0xf0, 0xfe, 0xdc,
-	0x01, 0xfe, 0x07, 0x4b,
+	0x58, 0x0a, 0x99, 0x01, 0x0e, 0xfe, 0xc8, 0x54, 0x64, 0xfe, 0x0c, 0x03,
+	0x01, 0xe6, 0x02, 0x29, 0x2a, 0x46, 0xfe, 0x02, 0xe8, 0x27, 0xf8, 0xfe,
+	0x9e, 0x43, 0xf7, 0xfe, 0x27, 0xf0, 0xfe, 0xdc, 0x01, 0xfe, 0x07, 0x4b,
 	0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x40, 0x1c, 0x25, 0xd2, 0xfe, 0x26, 0xf0,
-	0xfe, 0x56, 0x03, 0xfe,
-	0xa0, 0xf0, 0xfe, 0x44, 0x03, 0xfe, 0x11, 0xf0, 0x9c, 0xfe, 0xef, 0x10,
-	0xfe, 0x9f, 0xf0, 0xfe,
-	0x64, 0x03, 0xeb, 0x0f, 0xfe, 0x11, 0x00, 0x02, 0x5a, 0x2a, 0xfe, 0x48,
-	0x1c, 0xeb, 0x09, 0x04,
+	0xfe, 0x56, 0x03, 0xfe, 0xa0, 0xf0, 0xfe, 0x44, 0x03, 0xfe, 0x11, 0xf0,
+	0x9c, 0xfe, 0xef, 0x10, 0xfe, 0x9f, 0xf0, 0xfe, 0x64, 0x03, 0xeb, 0x0f,
+	0xfe, 0x11, 0x00, 0x02, 0x5a, 0x2a, 0xfe, 0x48, 0x1c, 0xeb, 0x09, 0x04,
 	0x1d, 0xfe, 0x18, 0x13, 0x23, 0x1e, 0x98, 0xac, 0x12, 0x98, 0x0a, 0x40,
-	0x01, 0x0e, 0xac, 0x75,
-	0x01, 0xfe, 0xbc, 0x15, 0x11, 0xca, 0x25, 0xd2, 0xfe, 0x01, 0xf0, 0xd2,
-	0xfe, 0x82, 0xf0, 0xfe,
-	0x92, 0x03, 0xec, 0x11, 0xfe, 0xe4, 0x00, 0x65, 0xfe, 0xa4, 0x03, 0x25,
-	0x32, 0x1f, 0xfe, 0xb4,
+	0x01, 0x0e, 0xac, 0x75, 0x01, 0xfe, 0xbc, 0x15, 0x11, 0xca, 0x25, 0xd2,
+	0xfe, 0x01, 0xf0, 0xd2, 0xfe, 0x82, 0xf0, 0xfe, 0x92, 0x03, 0xec, 0x11,
+	0xfe, 0xe4, 0x00, 0x65, 0xfe, 0xa4, 0x03, 0x25, 0x32, 0x1f, 0xfe, 0xb4,
 	0x03, 0x01, 0x43, 0xfe, 0x06, 0xf0, 0xfe, 0xc4, 0x03, 0x8d, 0x81, 0xfe,
-	0x0a, 0xf0, 0xfe, 0x7a,
-	0x06, 0x02, 0x22, 0x05, 0x6b, 0x28, 0x16, 0xfe, 0xf6, 0x04, 0x14, 0x2c,
-	0x01, 0x33, 0x8f, 0xfe,
-	0x66, 0x02, 0x02, 0xd1, 0xeb, 0x2a, 0x67, 0x1a, 0xfe, 0x67, 0x1b, 0xf8,
-	0xf7, 0xfe, 0x48, 0x1c,
+	0x0a, 0xf0, 0xfe, 0x7a, 0x06, 0x02, 0x22, 0x05, 0x6b, 0x28, 0x16, 0xfe,
+	0xf6, 0x04, 0x14, 0x2c, 0x01, 0x33, 0x8f, 0xfe, 0x66, 0x02, 0x02, 0xd1,
+	0xeb, 0x2a, 0x67, 0x1a, 0xfe, 0x67, 0x1b, 0xf8, 0xf7, 0xfe, 0x48, 0x1c,
 	0x70, 0x01, 0x6e, 0x87, 0x0a, 0x40, 0x01, 0x0e, 0x07, 0x00, 0x16, 0xd3,
-	0x0a, 0xca, 0x01, 0x0e,
-	0x74, 0x60, 0x59, 0x76, 0x27, 0x05, 0x6b, 0x28, 0xfe, 0x10, 0x12, 0x14,
-	0x2c, 0x01, 0x33, 0x8f,
-	0xfe, 0x66, 0x02, 0x02, 0xd1, 0xbc, 0x7d, 0xbd, 0x7f, 0x25, 0x22, 0x65,
-	0xfe, 0x3c, 0x04, 0x1f,
+	0x0a, 0xca, 0x01, 0x0e, 0x74, 0x60, 0x59, 0x76, 0x27, 0x05, 0x6b, 0x28,
+	0xfe, 0x10, 0x12, 0x14, 0x2c, 0x01, 0x33, 0x8f, 0xfe, 0x66, 0x02, 0x02,
+	0xd1, 0xbc, 0x7d, 0xbd, 0x7f, 0x25, 0x22, 0x65, 0xfe, 0x3c, 0x04, 0x1f,
 	0xfe, 0x38, 0x04, 0x68, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e,
-	0x12, 0x2b, 0xff, 0x02,
-	0x00, 0x10, 0x01, 0x08, 0x1f, 0xfe, 0xe0, 0x04, 0x2b, 0x01, 0x08, 0x1f,
-	0x22, 0x30, 0x2e, 0xd5,
-	0xfe, 0x4c, 0x44, 0xfe, 0x4c, 0x12, 0x60, 0xfe, 0x44, 0x48, 0x13, 0x2c,
-	0xfe, 0x4c, 0x54, 0x64,
+	0x12, 0x2b, 0xff, 0x02, 0x00, 0x10, 0x01, 0x08, 0x1f, 0xfe, 0xe0, 0x04,
+	0x2b, 0x01, 0x08, 0x1f, 0x22, 0x30, 0x2e, 0xd5, 0xfe, 0x4c, 0x44, 0xfe,
+	0x4c, 0x12, 0x60, 0xfe, 0x44, 0x48, 0x13, 0x2c, 0xfe, 0x4c, 0x54, 0x64,
 	0xd3, 0x46, 0x76, 0x27, 0xfa, 0xef, 0xfe, 0x62, 0x13, 0x09, 0x04, 0x1d,
-	0xfe, 0x2a, 0x13, 0x2f,
-	0x07, 0x7e, 0xa5, 0xfe, 0x20, 0x10, 0x13, 0x2c, 0xfe, 0x4c, 0x54, 0x64,
-	0xd3, 0xfa, 0xef, 0x86,
-	0x09, 0x04, 0x1d, 0xfe, 0x08, 0x13, 0x2f, 0x07, 0x7e, 0x6e, 0x09, 0x04,
-	0x1d, 0xfe, 0x1c, 0x12,
+	0xfe, 0x2a, 0x13, 0x2f, 0x07, 0x7e, 0xa5, 0xfe, 0x20, 0x10, 0x13, 0x2c,
+	0xfe, 0x4c, 0x54, 0x64, 0xd3, 0xfa, 0xef, 0x86, 0x09, 0x04, 0x1d, 0xfe,
+	0x08, 0x13, 0x2f, 0x07, 0x7e, 0x6e, 0x09, 0x04, 0x1d, 0xfe, 0x1c, 0x12,
 	0x14, 0x92, 0x09, 0x04, 0x06, 0x3b, 0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe,
-	0x70, 0x0c, 0x02, 0x22,
-	0x2b, 0x11, 0xfe, 0xe6, 0x00, 0xfe, 0x1c, 0x90, 0xf9, 0x03, 0x14, 0x92,
-	0x01, 0x33, 0x02, 0x29,
-	0xfe, 0x42, 0x5b, 0x67, 0x1a, 0xfe, 0x46, 0x59, 0xf8, 0xf7, 0xfe, 0x87,
-	0x80, 0xfe, 0x31, 0xe4,
+	0x70, 0x0c, 0x02, 0x22, 0x2b, 0x11, 0xfe, 0xe6, 0x00, 0xfe, 0x1c, 0x90,
+	0xf9, 0x03, 0x14, 0x92, 0x01, 0x33, 0x02, 0x29, 0xfe, 0x42, 0x5b, 0x67,
+	0x1a, 0xfe, 0x46, 0x59, 0xf8, 0xf7, 0xfe, 0x87, 0x80, 0xfe, 0x31, 0xe4,
 	0x4f, 0x09, 0x04, 0x0b, 0xfe, 0x78, 0x13, 0xfe, 0x20, 0x80, 0x07, 0x1a,
-	0xfe, 0x70, 0x12, 0x49,
-	0x04, 0x06, 0xfe, 0x60, 0x13, 0x05, 0xfe, 0xa2, 0x00, 0x28, 0x16, 0xfe,
-	0x80, 0x05, 0xfe, 0x31,
-	0xe4, 0x6a, 0x49, 0x04, 0x0b, 0xfe, 0x4a, 0x13, 0x05, 0xfe, 0xa0, 0x00,
-	0x28, 0xfe, 0x42, 0x12,
+	0xfe, 0x70, 0x12, 0x49, 0x04, 0x06, 0xfe, 0x60, 0x13, 0x05, 0xfe, 0xa2,
+	0x00, 0x28, 0x16, 0xfe, 0x80, 0x05, 0xfe, 0x31, 0xe4, 0x6a, 0x49, 0x04,
+	0x0b, 0xfe, 0x4a, 0x13, 0x05, 0xfe, 0xa0, 0x00, 0x28, 0xfe, 0x42, 0x12,
 	0x5e, 0x01, 0x08, 0x25, 0x32, 0xf1, 0x01, 0x08, 0x26, 0xfe, 0x98, 0x05,
-	0x11, 0xfe, 0xe3, 0x00,
-	0x23, 0x49, 0xfe, 0x4a, 0xf0, 0xfe, 0x6a, 0x05, 0xfe, 0x49, 0xf0, 0xfe,
-	0x64, 0x05, 0x83, 0x24,
-	0xfe, 0x21, 0x00, 0xa1, 0x24, 0xfe, 0x22, 0x00, 0xa0, 0x24, 0x4c, 0xfe,
-	0x09, 0x48, 0x01, 0x08,
+	0x11, 0xfe, 0xe3, 0x00, 0x23, 0x49, 0xfe, 0x4a, 0xf0, 0xfe, 0x6a, 0x05,
+	0xfe, 0x49, 0xf0, 0xfe, 0x64, 0x05, 0x83, 0x24, 0xfe, 0x21, 0x00, 0xa1,
+	0x24, 0xfe, 0x22, 0x00, 0xa0, 0x24, 0x4c, 0xfe, 0x09, 0x48, 0x01, 0x08,
 	0x26, 0xfe, 0x98, 0x05, 0xfe, 0xe2, 0x08, 0x49, 0x04, 0xc5, 0x3b, 0x01,
-	0x86, 0x24, 0x06, 0x12,
-	0xcc, 0x37, 0xfe, 0x27, 0x01, 0x09, 0x04, 0x1d, 0xfe, 0x22, 0x12, 0x47,
-	0x01, 0xa7, 0x14, 0x92,
-	0x09, 0x04, 0x06, 0x3b, 0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe, 0x70, 0x0c,
-	0x02, 0x22, 0x05, 0xfe,
+	0x86, 0x24, 0x06, 0x12, 0xcc, 0x37, 0xfe, 0x27, 0x01, 0x09, 0x04, 0x1d,
+	0xfe, 0x22, 0x12, 0x47, 0x01, 0xa7, 0x14, 0x92, 0x09, 0x04, 0x06, 0x3b,
+	0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe, 0x70, 0x0c, 0x02, 0x22, 0x05, 0xfe,
 	0x9c, 0x00, 0x28, 0xfe, 0x3e, 0x12, 0x05, 0x50, 0x28, 0xfe, 0x36, 0x13,
-	0x47, 0x01, 0xa7, 0x26,
-	0xfe, 0x08, 0x06, 0x0a, 0x06, 0x49, 0x04, 0x19, 0xfe, 0x02, 0x12, 0x5f,
-	0x01, 0xfe, 0xaa, 0x14,
-	0x1f, 0xfe, 0xfe, 0x05, 0x11, 0x9a, 0x01, 0x43, 0x11, 0xfe, 0xe5, 0x00,
-	0x05, 0x50, 0xb4, 0x0c,
+	0x47, 0x01, 0xa7, 0x26, 0xfe, 0x08, 0x06, 0x0a, 0x06, 0x49, 0x04, 0x19,
+	0xfe, 0x02, 0x12, 0x5f, 0x01, 0xfe, 0xaa, 0x14, 0x1f, 0xfe, 0xfe, 0x05,
+	0x11, 0x9a, 0x01, 0x43, 0x11, 0xfe, 0xe5, 0x00, 0x05, 0x50, 0xb4, 0x0c,
 	0x50, 0x05, 0xc6, 0x28, 0xfe, 0x62, 0x12, 0x05, 0x3f, 0x28, 0xfe, 0x5a,
-	0x13, 0x01, 0xfe, 0x14,
-	0x18, 0x01, 0xfe, 0x66, 0x18, 0xfe, 0x43, 0x48, 0xb7, 0x19, 0x13, 0x6c,
-	0xff, 0x02, 0x00, 0x57,
-	0x48, 0x8b, 0x1c, 0x3d, 0x85, 0xb7, 0x69, 0x47, 0x01, 0xa7, 0x26, 0xfe,
-	0x72, 0x06, 0x49, 0x04,
+	0x13, 0x01, 0xfe, 0x14, 0x18, 0x01, 0xfe, 0x66, 0x18, 0xfe, 0x43, 0x48,
+	0xb7, 0x19, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0x1c, 0x3d,
+	0x85, 0xb7, 0x69, 0x47, 0x01, 0xa7, 0x26, 0xfe, 0x72, 0x06, 0x49, 0x04,
 	0x1b, 0xdf, 0x89, 0x0a, 0x4d, 0x01, 0xfe, 0xd8, 0x14, 0x1f, 0xfe, 0x68,
-	0x06, 0x11, 0x9a, 0x01,
-	0x43, 0x11, 0xfe, 0xe5, 0x00, 0x05, 0x3f, 0xb4, 0x0c, 0x3f, 0x17, 0x06,
-	0x01, 0xa7, 0xec, 0x72,
-	0x70, 0x01, 0x6e, 0x87, 0x11, 0xfe, 0xe2, 0x00, 0x01, 0x08, 0x25, 0x32,
-	0xfe, 0x0a, 0xf0, 0xfe,
+	0x06, 0x11, 0x9a, 0x01, 0x43, 0x11, 0xfe, 0xe5, 0x00, 0x05, 0x3f, 0xb4,
+	0x0c, 0x3f, 0x17, 0x06, 0x01, 0xa7, 0xec, 0x72, 0x70, 0x01, 0x6e, 0x87,
+	0x11, 0xfe, 0xe2, 0x00, 0x01, 0x08, 0x25, 0x32, 0xfe, 0x0a, 0xf0, 0xfe,
 	0xa6, 0x06, 0x8c, 0xfe, 0x5c, 0x07, 0xfe, 0x06, 0xf0, 0xfe, 0x64, 0x07,
-	0x8d, 0x81, 0x02, 0x22,
-	0x09, 0x04, 0x0b, 0xfe, 0x2e, 0x12, 0x15, 0x1a, 0x01, 0x08, 0x15, 0x00,
-	0x01, 0x08, 0x15, 0x00,
-	0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0xfe, 0x99, 0xa4, 0x01, 0x08, 0x15,
-	0x00, 0x02, 0xfe, 0x32,
+	0x8d, 0x81, 0x02, 0x22, 0x09, 0x04, 0x0b, 0xfe, 0x2e, 0x12, 0x15, 0x1a,
+	0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00,
+	0x01, 0x08, 0xfe, 0x99, 0xa4, 0x01, 0x08, 0x15, 0x00, 0x02, 0xfe, 0x32,
 	0x08, 0x61, 0x04, 0x1b, 0xfe, 0x38, 0x12, 0x09, 0x04, 0x1b, 0x6e, 0x15,
-	0xfe, 0x1b, 0x00, 0x01,
-	0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01,
-	0x08, 0x15, 0x06, 0x01,
-	0x08, 0x15, 0x00, 0x02, 0xd9, 0x66, 0x4c, 0xfe, 0x3a, 0x55, 0x5f, 0xfe,
-	0x9a, 0x81, 0x4b, 0x1d,
+	0xfe, 0x1b, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01,
+	0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x06, 0x01, 0x08, 0x15, 0x00, 0x02,
+	0xd9, 0x66, 0x4c, 0xfe, 0x3a, 0x55, 0x5f, 0xfe, 0x9a, 0x81, 0x4b, 0x1d,
 	0xba, 0xfe, 0x32, 0x07, 0x0a, 0x1d, 0xfe, 0x09, 0x6f, 0xaf, 0xfe, 0xca,
-	0x45, 0xfe, 0x32, 0x12,
-	0x62, 0x2c, 0x85, 0x66, 0x7b, 0x01, 0x08, 0x25, 0x32, 0xfe, 0x0a, 0xf0,
-	0xfe, 0x32, 0x07, 0x8d,
-	0x81, 0x8c, 0xfe, 0x5c, 0x07, 0x02, 0x22, 0x01, 0x43, 0x02, 0xfe, 0x8a,
-	0x06, 0x15, 0x19, 0x02,
+	0x45, 0xfe, 0x32, 0x12, 0x62, 0x2c, 0x85, 0x66, 0x7b, 0x01, 0x08, 0x25,
+	0x32, 0xfe, 0x0a, 0xf0, 0xfe, 0x32, 0x07, 0x8d, 0x81, 0x8c, 0xfe, 0x5c,
+	0x07, 0x02, 0x22, 0x01, 0x43, 0x02, 0xfe, 0x8a, 0x06, 0x15, 0x19, 0x02,
 	0xfe, 0x8a, 0x06, 0xfe, 0x9c, 0xf7, 0xd4, 0xfe, 0x2c, 0x90, 0xfe, 0xae,
-	0x90, 0x77, 0xfe, 0xca,
-	0x07, 0x0c, 0x54, 0x18, 0x55, 0x09, 0x4a, 0x6a, 0x35, 0x1e, 0x20, 0x07,
-	0x10, 0xfe, 0x0e, 0x12,
-	0x74, 0xfe, 0x80, 0x80, 0x37, 0x20, 0x63, 0x27, 0xfe, 0x06, 0x10, 0xfe,
-	0x83, 0xe7, 0xc4, 0xa1,
+	0x90, 0x77, 0xfe, 0xca, 0x07, 0x0c, 0x54, 0x18, 0x55, 0x09, 0x4a, 0x6a,
+	0x35, 0x1e, 0x20, 0x07, 0x10, 0xfe, 0x0e, 0x12, 0x74, 0xfe, 0x80, 0x80,
+	0x37, 0x20, 0x63, 0x27, 0xfe, 0x06, 0x10, 0xfe, 0x83, 0xe7, 0xc4, 0xa1,
 	0xfe, 0x03, 0x40, 0x09, 0x4a, 0x4f, 0x35, 0x01, 0xa8, 0xad, 0xfe, 0x1f,
-	0x40, 0x12, 0x58, 0x01,
-	0xa5, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe, 0x44, 0x51, 0xfe, 0xc6,
-	0x51, 0x83, 0xfb, 0xfe,
-	0x8a, 0x90, 0x0c, 0x52, 0x18, 0x53, 0xfe, 0x0c, 0x90, 0xfe, 0x8e, 0x90,
-	0xfe, 0x40, 0x50, 0xfe,
+	0x40, 0x12, 0x58, 0x01, 0xa5, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe,
+	0x44, 0x51, 0xfe, 0xc6, 0x51, 0x83, 0xfb, 0xfe, 0x8a, 0x90, 0x0c, 0x52,
+	0x18, 0x53, 0xfe, 0x0c, 0x90, 0xfe, 0x8e, 0x90, 0xfe, 0x40, 0x50, 0xfe,
 	0xc2, 0x50, 0x0c, 0x39, 0x18, 0x3a, 0xfe, 0x4a, 0x10, 0x09, 0x04, 0x6a,
-	0xfe, 0x2a, 0x12, 0xfe,
-	0x2c, 0x90, 0xfe, 0xae, 0x90, 0x0c, 0x54, 0x18, 0x55, 0x09, 0x04, 0x4f,
-	0x85, 0x01, 0xa8, 0xfe,
-	0x1f, 0x80, 0x12, 0x58, 0xfe, 0x44, 0x90, 0xfe, 0xc6, 0x90, 0x0c, 0x56,
-	0x18, 0x57, 0xfb, 0xfe,
+	0xfe, 0x2a, 0x12, 0xfe, 0x2c, 0x90, 0xfe, 0xae, 0x90, 0x0c, 0x54, 0x18,
+	0x55, 0x09, 0x04, 0x4f, 0x85, 0x01, 0xa8, 0xfe, 0x1f, 0x80, 0x12, 0x58,
+	0xfe, 0x44, 0x90, 0xfe, 0xc6, 0x90, 0x0c, 0x56, 0x18, 0x57, 0xfb, 0xfe,
 	0x8a, 0x90, 0x0c, 0x52, 0x18, 0x53, 0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90,
-	0x0c, 0x39, 0x18, 0x3a,
-	0x0c, 0x38, 0x18, 0x4e, 0x09, 0x4a, 0x19, 0x35, 0x2a, 0x13, 0xfe, 0x4e,
-	0x11, 0x65, 0xfe, 0x48,
-	0x08, 0xfe, 0x9e, 0xf0, 0xfe, 0x5c, 0x08, 0xb1, 0x16, 0x32, 0x2a, 0x73,
-	0xdd, 0xb8, 0xfe, 0x80,
+	0x0c, 0x39, 0x18, 0x3a, 0x0c, 0x38, 0x18, 0x4e, 0x09, 0x4a, 0x19, 0x35,
+	0x2a, 0x13, 0xfe, 0x4e, 0x11, 0x65, 0xfe, 0x48, 0x08, 0xfe, 0x9e, 0xf0,
+	0xfe, 0x5c, 0x08, 0xb1, 0x16, 0x32, 0x2a, 0x73, 0xdd, 0xb8, 0xfe, 0x80,
 	0x08, 0xb9, 0xfe, 0x9e, 0x08, 0x8c, 0xfe, 0x74, 0x08, 0xfe, 0x06, 0xf0,
-	0xfe, 0x7a, 0x08, 0x8d,
-	0x81, 0x02, 0x22, 0x01, 0x43, 0xfe, 0xc9, 0x10, 0x15, 0x19, 0xfe, 0xc9,
-	0x10, 0x61, 0x04, 0x06,
-	0xfe, 0x10, 0x12, 0x61, 0x04, 0x0b, 0x45, 0x09, 0x04, 0x0b, 0xfe, 0x68,
-	0x12, 0xfe, 0x2e, 0x1c,
+	0xfe, 0x7a, 0x08, 0x8d, 0x81, 0x02, 0x22, 0x01, 0x43, 0xfe, 0xc9, 0x10,
+	0x15, 0x19, 0xfe, 0xc9, 0x10, 0x61, 0x04, 0x06, 0xfe, 0x10, 0x12, 0x61,
+	0x04, 0x0b, 0x45, 0x09, 0x04, 0x0b, 0xfe, 0x68, 0x12, 0xfe, 0x2e, 0x1c,
 	0x02, 0xfe, 0x24, 0x0a, 0x61, 0x04, 0x06, 0x45, 0x61, 0x04, 0x0b, 0xfe,
-	0x52, 0x12, 0xfe, 0x2c,
-	0x1c, 0xfe, 0xaa, 0xf0, 0xfe, 0x1e, 0x09, 0xfe, 0xac, 0xf0, 0xfe, 0xbe,
-	0x08, 0xfe, 0x8a, 0x10,
-	0xaa, 0xfe, 0xf3, 0x10, 0xfe, 0xad, 0xf0, 0xfe, 0xca, 0x08, 0x02, 0xfe,
-	0x24, 0x0a, 0xab, 0xfe,
+	0x52, 0x12, 0xfe, 0x2c, 0x1c, 0xfe, 0xaa, 0xf0, 0xfe, 0x1e, 0x09, 0xfe,
+	0xac, 0xf0, 0xfe, 0xbe, 0x08, 0xfe, 0x8a, 0x10, 0xaa, 0xfe, 0xf3, 0x10,
+	0xfe, 0xad, 0xf0, 0xfe, 0xca, 0x08, 0x02, 0xfe, 0x24, 0x0a, 0xab, 0xfe,
 	0xe7, 0x10, 0xfe, 0x2b, 0xf0, 0x9d, 0xe9, 0x1c, 0xfe, 0x00, 0xfe, 0xfe,
-	0x1c, 0x12, 0xb5, 0xfe,
-	0xd2, 0xf0, 0x9d, 0xfe, 0x76, 0x18, 0x1c, 0x1a, 0x16, 0x9d, 0x05, 0xcb,
-	0x1c, 0x06, 0x16, 0x9d,
-	0xb8, 0x6d, 0xb9, 0x6d, 0xaa, 0xab, 0xfe, 0xb1, 0x10, 0x70, 0x5e, 0x2b,
-	0x14, 0x92, 0x01, 0x33,
+	0x1c, 0x12, 0xb5, 0xfe, 0xd2, 0xf0, 0x9d, 0xfe, 0x76, 0x18, 0x1c, 0x1a,
+	0x16, 0x9d, 0x05, 0xcb, 0x1c, 0x06, 0x16, 0x9d, 0xb8, 0x6d, 0xb9, 0x6d,
+	0xaa, 0xab, 0xfe, 0xb1, 0x10, 0x70, 0x5e, 0x2b, 0x14, 0x92, 0x01, 0x33,
 	0x0f, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x5a, 0x0f, 0x7c, 0x02, 0x5a,
-	0xfe, 0x74, 0x18, 0x1c,
-	0xfe, 0x00, 0xf8, 0x16, 0x6d, 0x67, 0x1b, 0x01, 0xfe, 0x44, 0x0d, 0x3b,
-	0x01, 0xe6, 0x1e, 0x27,
-	0x74, 0x67, 0x1a, 0x02, 0x6d, 0x09, 0x04, 0x0b, 0x21, 0xfe, 0x06, 0x0a,
-	0x09, 0x04, 0x6a, 0xfe,
+	0xfe, 0x74, 0x18, 0x1c, 0xfe, 0x00, 0xf8, 0x16, 0x6d, 0x67, 0x1b, 0x01,
+	0xfe, 0x44, 0x0d, 0x3b, 0x01, 0xe6, 0x1e, 0x27, 0x74, 0x67, 0x1a, 0x02,
+	0x6d, 0x09, 0x04, 0x0b, 0x21, 0xfe, 0x06, 0x0a, 0x09, 0x04, 0x6a, 0xfe,
 	0x82, 0x12, 0x09, 0x04, 0x19, 0xfe, 0x66, 0x13, 0x1e, 0x58, 0xac, 0xfc,
-	0xfe, 0x83, 0x80, 0xfe,
-	0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91, 0xfe, 0x86, 0x91, 0x63,
-	0x27, 0xfe, 0x40, 0x59,
-	0xfe, 0xc1, 0x59, 0x77, 0xd7, 0x05, 0x54, 0x31, 0x55, 0x0c, 0x7b, 0x18,
-	0x7c, 0xbe, 0x54, 0xbf,
+	0xfe, 0x83, 0x80, 0xfe, 0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91,
+	0xfe, 0x86, 0x91, 0x63, 0x27, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x77,
+	0xd7, 0x05, 0x54, 0x31, 0x55, 0x0c, 0x7b, 0x18, 0x7c, 0xbe, 0x54, 0xbf,
 	0x55, 0x01, 0xa8, 0xad, 0x63, 0x27, 0x12, 0x58, 0xc0, 0x38, 0xc1, 0x4e,
-	0x79, 0x56, 0x68, 0x57,
-	0xf4, 0xf5, 0xfe, 0x04, 0xfa, 0x38, 0xfe, 0x05, 0xfa, 0x4e, 0x01, 0xa5,
-	0xa2, 0x23, 0x0c, 0x7b,
-	0x0c, 0x7c, 0x79, 0x56, 0x68, 0x57, 0xfe, 0x12, 0x10, 0x09, 0x04, 0x19,
-	0x16, 0xd7, 0x79, 0x39,
+	0x79, 0x56, 0x68, 0x57, 0xf4, 0xf5, 0xfe, 0x04, 0xfa, 0x38, 0xfe, 0x05,
+	0xfa, 0x4e, 0x01, 0xa5, 0xa2, 0x23, 0x0c, 0x7b, 0x0c, 0x7c, 0x79, 0x56,
+	0x68, 0x57, 0xfe, 0x12, 0x10, 0x09, 0x04, 0x19, 0x16, 0xd7, 0x79, 0x39,
 	0x68, 0x3a, 0x09, 0x04, 0xfe, 0xf7, 0x00, 0x35, 0x05, 0x52, 0x31, 0x53,
-	0xfe, 0x10, 0x58, 0xfe,
-	0x91, 0x58, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x02, 0x6d, 0x09, 0x04,
-	0x19, 0x16, 0xd7, 0x09,
-	0x04, 0xfe, 0xf7, 0x00, 0x35, 0xfe, 0x3a, 0x55, 0xfe, 0x19, 0x81, 0x5f,
-	0xfe, 0x10, 0x90, 0xfe,
+	0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59,
+	0x02, 0x6d, 0x09, 0x04, 0x19, 0x16, 0xd7, 0x09, 0x04, 0xfe, 0xf7, 0x00,
+	0x35, 0xfe, 0x3a, 0x55, 0xfe, 0x19, 0x81, 0x5f, 0xfe, 0x10, 0x90, 0xfe,
 	0x92, 0x90, 0xfe, 0xd7, 0x10, 0x2f, 0x07, 0x9b, 0x16, 0xfe, 0xc6, 0x08,
-	0x11, 0x9b, 0x09, 0x04,
-	0x0b, 0xfe, 0x14, 0x13, 0x05, 0x39, 0x31, 0x3a, 0x77, 0xfe, 0xc6, 0x08,
-	0xfe, 0x0c, 0x58, 0xfe,
-	0x8d, 0x58, 0x02, 0x6d, 0x23, 0x47, 0xfe, 0x19, 0x80, 0xde, 0x09, 0x04,
-	0x0b, 0xfe, 0x1a, 0x12,
+	0x11, 0x9b, 0x09, 0x04, 0x0b, 0xfe, 0x14, 0x13, 0x05, 0x39, 0x31, 0x3a,
+	0x77, 0xfe, 0xc6, 0x08, 0xfe, 0x0c, 0x58, 0xfe, 0x8d, 0x58, 0x02, 0x6d,
+	0x23, 0x47, 0xfe, 0x19, 0x80, 0xde, 0x09, 0x04, 0x0b, 0xfe, 0x1a, 0x12,
 	0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41, 0xe9, 0xb5, 0xfe, 0xd1, 0xf0, 0xd9,
-	0x14, 0x7a, 0x01, 0x33,
-	0x0f, 0xfe, 0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe, 0x6c, 0x19, 0xbe, 0x39,
-	0xfe, 0xed, 0x19, 0xbf,
-	0x3a, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0xe9, 0x1c, 0xfe, 0x00, 0xff,
-	0x34, 0xfe, 0x74, 0x10,
+	0x14, 0x7a, 0x01, 0x33, 0x0f, 0xfe, 0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe,
+	0x6c, 0x19, 0xbe, 0x39, 0xfe, 0xed, 0x19, 0xbf, 0x3a, 0xfe, 0x0c, 0x51,
+	0xfe, 0x8e, 0x51, 0xe9, 0x1c, 0xfe, 0x00, 0xff, 0x34, 0xfe, 0x74, 0x10,
 	0xb5, 0xfe, 0xd2, 0xf0, 0xfe, 0xb2, 0x0a, 0xfe, 0x76, 0x18, 0x1c, 0x1a,
-	0x84, 0x05, 0xcb, 0x1c,
-	0x06, 0xfe, 0x08, 0x13, 0x0f, 0xfe, 0x16, 0x00, 0x02, 0x5a, 0xfe, 0xd1,
-	0xf0, 0xfe, 0xc4, 0x0a,
-	0x14, 0x7a, 0x01, 0x33, 0x0f, 0xfe, 0x17, 0x00, 0xfe, 0x42, 0x10, 0xfe,
-	0xce, 0xf0, 0xfe, 0xca,
+	0x84, 0x05, 0xcb, 0x1c, 0x06, 0xfe, 0x08, 0x13, 0x0f, 0xfe, 0x16, 0x00,
+	0x02, 0x5a, 0xfe, 0xd1, 0xf0, 0xfe, 0xc4, 0x0a, 0x14, 0x7a, 0x01, 0x33,
+	0x0f, 0xfe, 0x17, 0x00, 0xfe, 0x42, 0x10, 0xfe, 0xce, 0xf0, 0xfe, 0xca,
 	0x0a, 0xfe, 0x3c, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xd6, 0x0a, 0x0f, 0xfe,
-	0x22, 0x00, 0x02, 0x5a,
-	0xfe, 0xcb, 0xf0, 0xfe, 0xe2, 0x0a, 0x0f, 0xfe, 0x24, 0x00, 0x02, 0x5a,
-	0xfe, 0xd0, 0xf0, 0xfe,
-	0xec, 0x0a, 0x0f, 0x93, 0xdc, 0xfe, 0xcf, 0xf0, 0xfe, 0xf6, 0x0a, 0x0f,
-	0x4c, 0xfe, 0x10, 0x10,
+	0x22, 0x00, 0x02, 0x5a, 0xfe, 0xcb, 0xf0, 0xfe, 0xe2, 0x0a, 0x0f, 0xfe,
+	0x24, 0x00, 0x02, 0x5a, 0xfe, 0xd0, 0xf0, 0xfe, 0xec, 0x0a, 0x0f, 0x93,
+	0xdc, 0xfe, 0xcf, 0xf0, 0xfe, 0xf6, 0x0a, 0x0f, 0x4c, 0xfe, 0x10, 0x10,
 	0xfe, 0xcc, 0xf0, 0xd9, 0x61, 0x04, 0x19, 0x3b, 0x0f, 0xfe, 0x12, 0x00,
-	0x2a, 0x13, 0xfe, 0x4e,
-	0x11, 0x65, 0xfe, 0x0c, 0x0b, 0xfe, 0x9e, 0xf0, 0xfe, 0x20, 0x0b, 0xb1,
-	0x16, 0x32, 0x2a, 0x73,
-	0xdd, 0xb8, 0x22, 0xb9, 0x22, 0x2a, 0xec, 0x65, 0xfe, 0x2c, 0x0b, 0x25,
-	0x32, 0x8c, 0xfe, 0x48,
+	0x2a, 0x13, 0xfe, 0x4e, 0x11, 0x65, 0xfe, 0x0c, 0x0b, 0xfe, 0x9e, 0xf0,
+	0xfe, 0x20, 0x0b, 0xb1, 0x16, 0x32, 0x2a, 0x73, 0xdd, 0xb8, 0x22, 0xb9,
+	0x22, 0x2a, 0xec, 0x65, 0xfe, 0x2c, 0x0b, 0x25, 0x32, 0x8c, 0xfe, 0x48,
 	0x0b, 0x8d, 0x81, 0xb8, 0xd4, 0xb9, 0xd4, 0x02, 0x22, 0x01, 0x43, 0xfe,
-	0xdb, 0x10, 0x11, 0xfe,
-	0xe8, 0x00, 0xaa, 0xab, 0x70, 0xbc, 0x7d, 0xbd, 0x7f, 0xfe, 0x89, 0xf0,
-	0x22, 0x30, 0x2e, 0xd8,
-	0xbc, 0x7d, 0xbd, 0x7f, 0x01, 0x08, 0x1f, 0x22, 0x30, 0x2e, 0xd6, 0xb1,
-	0x45, 0x0f, 0xfe, 0x42,
+	0xdb, 0x10, 0x11, 0xfe, 0xe8, 0x00, 0xaa, 0xab, 0x70, 0xbc, 0x7d, 0xbd,
+	0x7f, 0xfe, 0x89, 0xf0, 0x22, 0x30, 0x2e, 0xd8, 0xbc, 0x7d, 0xbd, 0x7f,
+	0x01, 0x08, 0x1f, 0x22, 0x30, 0x2e, 0xd6, 0xb1, 0x45, 0x0f, 0xfe, 0x42,
 	0x00, 0x02, 0x5a, 0x78, 0x06, 0xfe, 0x81, 0x49, 0x16, 0xfe, 0x38, 0x0c,
-	0x09, 0x04, 0x0b, 0xfe,
-	0x44, 0x13, 0x0f, 0x00, 0x4b, 0x0b, 0xfe, 0x54, 0x12, 0x4b, 0xfe, 0x28,
-	0x00, 0x21, 0xfe, 0xa6,
-	0x0c, 0x0a, 0x40, 0x01, 0x0e, 0x07, 0x00, 0x5d, 0x3e, 0xfe, 0x28, 0x00,
-	0xfe, 0xe2, 0x10, 0x01,
+	0x09, 0x04, 0x0b, 0xfe, 0x44, 0x13, 0x0f, 0x00, 0x4b, 0x0b, 0xfe, 0x54,
+	0x12, 0x4b, 0xfe, 0x28, 0x00, 0x21, 0xfe, 0xa6, 0x0c, 0x0a, 0x40, 0x01,
+	0x0e, 0x07, 0x00, 0x5d, 0x3e, 0xfe, 0x28, 0x00, 0xfe, 0xe2, 0x10, 0x01,
 	0xe7, 0x01, 0xe8, 0x0a, 0x99, 0x01, 0xfe, 0x32, 0x0e, 0x59, 0x11, 0x2d,
-	0x01, 0x6f, 0x02, 0x29,
-	0x0f, 0xfe, 0x44, 0x00, 0x4b, 0x0b, 0xdf, 0x3e, 0x0b, 0xfe, 0xb4, 0x10,
-	0x01, 0x86, 0x3e, 0x0b,
-	0xfe, 0xaa, 0x10, 0x01, 0x86, 0xfe, 0x19, 0x82, 0xfe, 0x34, 0x46, 0xa3,
-	0x3e, 0x0b, 0x0f, 0xfe,
+	0x01, 0x6f, 0x02, 0x29, 0x0f, 0xfe, 0x44, 0x00, 0x4b, 0x0b, 0xdf, 0x3e,
+	0x0b, 0xfe, 0xb4, 0x10, 0x01, 0x86, 0x3e, 0x0b, 0xfe, 0xaa, 0x10, 0x01,
+	0x86, 0xfe, 0x19, 0x82, 0xfe, 0x34, 0x46, 0xa3, 0x3e, 0x0b, 0x0f, 0xfe,
 	0x43, 0x00, 0xfe, 0x96, 0x10, 0x09, 0x4a, 0x0b, 0x35, 0x01, 0xe7, 0x01,
-	0xe8, 0x59, 0x11, 0x2d,
-	0x01, 0x6f, 0x67, 0x0b, 0x59, 0x3c, 0x8a, 0x02, 0xfe, 0x2a, 0x03, 0x09,
-	0x04, 0x0b, 0x84, 0x3e,
-	0x0b, 0x0f, 0x00, 0xfe, 0x5c, 0x10, 0x61, 0x04, 0x1b, 0xfe, 0x58, 0x12,
-	0x09, 0x04, 0x1b, 0xfe,
+	0xe8, 0x59, 0x11, 0x2d, 0x01, 0x6f, 0x67, 0x0b, 0x59, 0x3c, 0x8a, 0x02,
+	0xfe, 0x2a, 0x03, 0x09, 0x04, 0x0b, 0x84, 0x3e, 0x0b, 0x0f, 0x00, 0xfe,
+	0x5c, 0x10, 0x61, 0x04, 0x1b, 0xfe, 0x58, 0x12, 0x09, 0x04, 0x1b, 0xfe,
 	0x50, 0x13, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x5c, 0x0c, 0xfe,
-	0x1c, 0x1c, 0xfe, 0x9d,
-	0xf0, 0xfe, 0x62, 0x0c, 0x09, 0x4a, 0x1b, 0x35, 0xfe, 0xa9, 0x10, 0x0f,
-	0xfe, 0x15, 0x00, 0xfe,
-	0x04, 0xe6, 0x0b, 0x5f, 0x5c, 0x0f, 0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10,
-	0x0f, 0xfe, 0x47, 0x00,
+	0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x62, 0x0c, 0x09, 0x4a, 0x1b, 0x35,
+	0xfe, 0xa9, 0x10, 0x0f, 0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0b, 0x5f,
+	0x5c, 0x0f, 0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x0f, 0xfe, 0x47, 0x00,
 	0xa1, 0x0f, 0xfe, 0x41, 0x00, 0xa0, 0x0f, 0xfe, 0x24, 0x00, 0x87, 0xaa,
-	0xab, 0x70, 0x05, 0x6b,
-	0x28, 0x21, 0xd1, 0x5f, 0xfe, 0x04, 0xe6, 0x1b, 0xfe, 0x9d, 0x41, 0xfe,
-	0x1c, 0x42, 0x59, 0x01,
-	0xda, 0x02, 0x29, 0xea, 0x14, 0x0b, 0x37, 0x95, 0xa9, 0x14, 0xfe, 0x31,
-	0x00, 0x37, 0x97, 0x01,
+	0xab, 0x70, 0x05, 0x6b, 0x28, 0x21, 0xd1, 0x5f, 0xfe, 0x04, 0xe6, 0x1b,
+	0xfe, 0x9d, 0x41, 0xfe, 0x1c, 0x42, 0x59, 0x01, 0xda, 0x02, 0x29, 0xea,
+	0x14, 0x0b, 0x37, 0x95, 0xa9, 0x14, 0xfe, 0x31, 0x00, 0x37, 0x97, 0x01,
 	0xfe, 0x54, 0x0f, 0x02, 0xd0, 0x3c, 0xfe, 0x06, 0xec, 0xc9, 0xee, 0x3e,
-	0x1d, 0xfe, 0xce, 0x45,
-	0x34, 0x3c, 0xfe, 0x06, 0xea, 0xc9, 0xfe, 0x47, 0x4b, 0x89, 0xfe, 0x75,
-	0x57, 0x05, 0x51, 0xfe,
-	0x98, 0x56, 0xfe, 0x38, 0x12, 0x0a, 0x42, 0x01, 0x0e, 0xfe, 0x44, 0x48,
-	0x46, 0x09, 0x04, 0x1d,
+	0x1d, 0xfe, 0xce, 0x45, 0x34, 0x3c, 0xfe, 0x06, 0xea, 0xc9, 0xfe, 0x47,
+	0x4b, 0x89, 0xfe, 0x75, 0x57, 0x05, 0x51, 0xfe, 0x98, 0x56, 0xfe, 0x38,
+	0x12, 0x0a, 0x42, 0x01, 0x0e, 0xfe, 0x44, 0x48, 0x46, 0x09, 0x04, 0x1d,
 	0xfe, 0x1a, 0x13, 0x0a, 0x40, 0x01, 0x0e, 0x47, 0xfe, 0x41, 0x58, 0x0a,
-	0x99, 0x01, 0x0e, 0xfe,
-	0x49, 0x54, 0x8e, 0xfe, 0x2a, 0x0d, 0x02, 0xfe, 0x2a, 0x03, 0x0a, 0x51,
-	0xfe, 0xee, 0x14, 0xee,
-	0x3e, 0x1d, 0xfe, 0xce, 0x45, 0x34, 0x3c, 0xfe, 0xce, 0x47, 0xfe, 0xad,
-	0x13, 0x02, 0x29, 0x1e,
+	0x99, 0x01, 0x0e, 0xfe, 0x49, 0x54, 0x8e, 0xfe, 0x2a, 0x0d, 0x02, 0xfe,
+	0x2a, 0x03, 0x0a, 0x51, 0xfe, 0xee, 0x14, 0xee, 0x3e, 0x1d, 0xfe, 0xce,
+	0x45, 0x34, 0x3c, 0xfe, 0xce, 0x47, 0xfe, 0xad, 0x13, 0x02, 0x29, 0x1e,
 	0x20, 0x07, 0x10, 0xfe, 0x9e, 0x12, 0x23, 0x12, 0x4d, 0x12, 0x94, 0x12,
-	0xce, 0x1e, 0x2d, 0x47,
-	0x37, 0x2d, 0xb1, 0xe0, 0xfe, 0xbc, 0xf0, 0xfe, 0xec, 0x0d, 0x13, 0x06,
-	0x12, 0x4d, 0x01, 0xfe,
-	0xe2, 0x15, 0x05, 0xfe, 0x38, 0x01, 0x31, 0xfe, 0x3a, 0x01, 0x77, 0xfe,
-	0xf0, 0x0d, 0xfe, 0x02,
+	0xce, 0x1e, 0x2d, 0x47, 0x37, 0x2d, 0xb1, 0xe0, 0xfe, 0xbc, 0xf0, 0xfe,
+	0xec, 0x0d, 0x13, 0x06, 0x12, 0x4d, 0x01, 0xfe, 0xe2, 0x15, 0x05, 0xfe,
+	0x38, 0x01, 0x31, 0xfe, 0x3a, 0x01, 0x77, 0xfe, 0xf0, 0x0d, 0xfe, 0x02,
 	0xec, 0xce, 0x62, 0x00, 0x5d, 0xfe, 0x04, 0xec, 0x20, 0x46, 0xfe, 0x05,
-	0xf6, 0xfe, 0x34, 0x01,
-	0x01, 0xfe, 0x52, 0x16, 0xfb, 0xfe, 0x48, 0xf4, 0x0d, 0xfe, 0x18, 0x13,
-	0xaf, 0xfe, 0x02, 0xea,
-	0xce, 0x62, 0x7a, 0xfe, 0xc5, 0x13, 0x14, 0x1b, 0x37, 0x95, 0xa9, 0x5c,
-	0x05, 0xfe, 0x38, 0x01,
+	0xf6, 0xfe, 0x34, 0x01, 0x01, 0xfe, 0x52, 0x16, 0xfb, 0xfe, 0x48, 0xf4,
+	0x0d, 0xfe, 0x18, 0x13, 0xaf, 0xfe, 0x02, 0xea, 0xce, 0x62, 0x7a, 0xfe,
+	0xc5, 0x13, 0x14, 0x1b, 0x37, 0x95, 0xa9, 0x5c, 0x05, 0xfe, 0x38, 0x01,
 	0x1c, 0xfe, 0xf0, 0xff, 0x0c, 0xfe, 0x60, 0x01, 0x05, 0xfe, 0x3a, 0x01,
-	0x0c, 0xfe, 0x62, 0x01,
-	0x3d, 0x12, 0x20, 0x24, 0x06, 0x12, 0x2d, 0x11, 0x2d, 0x8a, 0x13, 0x06,
-	0x03, 0x23, 0x03, 0x1e,
-	0x4d, 0xfe, 0xf7, 0x12, 0x1e, 0x94, 0xac, 0x12, 0x94, 0x07, 0x7a, 0xfe,
-	0x71, 0x13, 0xfe, 0x24,
+	0x0c, 0xfe, 0x62, 0x01, 0x3d, 0x12, 0x20, 0x24, 0x06, 0x12, 0x2d, 0x11,
+	0x2d, 0x8a, 0x13, 0x06, 0x03, 0x23, 0x03, 0x1e, 0x4d, 0xfe, 0xf7, 0x12,
+	0x1e, 0x94, 0xac, 0x12, 0x94, 0x07, 0x7a, 0xfe, 0x71, 0x13, 0xfe, 0x24,
 	0x1c, 0x14, 0x1a, 0x37, 0x95, 0xa9, 0xfe, 0xd9, 0x10, 0xb6, 0xfe, 0x03,
-	0xdc, 0xfe, 0x73, 0x57,
-	0xfe, 0x80, 0x5d, 0x03, 0xb6, 0xfe, 0x03, 0xdc, 0xfe, 0x5b, 0x57, 0xfe,
-	0x80, 0x5d, 0x03, 0xfe,
-	0x03, 0x57, 0xb6, 0x23, 0xfe, 0x00, 0xcc, 0x03, 0xfe, 0x03, 0x57, 0xb6,
-	0x75, 0x03, 0x09, 0x04,
+	0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x03, 0xb6, 0xfe, 0x03, 0xdc,
+	0xfe, 0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x03, 0xfe, 0x03, 0x57, 0xb6, 0x23,
+	0xfe, 0x00, 0xcc, 0x03, 0xfe, 0x03, 0x57, 0xb6, 0x75, 0x03, 0x09, 0x04,
 	0x4c, 0xfe, 0x22, 0x13, 0xfe, 0x1c, 0x80, 0x07, 0x06, 0xfe, 0x1a, 0x13,
-	0xfe, 0x1e, 0x80, 0xe1,
-	0xfe, 0x1d, 0x80, 0xa4, 0xfe, 0x0c, 0x90, 0xfe, 0x0e, 0x13, 0xfe, 0x0e,
-	0x90, 0xa3, 0xfe, 0x3c,
-	0x90, 0xfe, 0x30, 0xf4, 0x0b, 0xfe, 0x3c, 0x50, 0xa0, 0x01, 0xfe, 0x82,
-	0x16, 0x2f, 0x07, 0x2d,
+	0xfe, 0x1e, 0x80, 0xe1, 0xfe, 0x1d, 0x80, 0xa4, 0xfe, 0x0c, 0x90, 0xfe,
+	0x0e, 0x13, 0xfe, 0x0e, 0x90, 0xa3, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4,
+	0x0b, 0xfe, 0x3c, 0x50, 0xa0, 0x01, 0xfe, 0x82, 0x16, 0x2f, 0x07, 0x2d,
 	0xe0, 0x01, 0xfe, 0xbc, 0x15, 0x09, 0x04, 0x1d, 0x45, 0x01, 0xe7, 0x01,
-	0xe8, 0x11, 0xfe, 0xe9,
-	0x00, 0x09, 0x04, 0x4c, 0xfe, 0x2c, 0x13, 0x01, 0xfe, 0x14, 0x16, 0xfe,
-	0x1e, 0x1c, 0xfe, 0x14,
-	0x90, 0xfe, 0x96, 0x90, 0x0c, 0xfe, 0x64, 0x01, 0x18, 0xfe, 0x66, 0x01,
-	0x09, 0x04, 0x4f, 0xfe,
+	0xe8, 0x11, 0xfe, 0xe9, 0x00, 0x09, 0x04, 0x4c, 0xfe, 0x2c, 0x13, 0x01,
+	0xfe, 0x14, 0x16, 0xfe, 0x1e, 0x1c, 0xfe, 0x14, 0x90, 0xfe, 0x96, 0x90,
+	0x0c, 0xfe, 0x64, 0x01, 0x18, 0xfe, 0x66, 0x01, 0x09, 0x04, 0x4f, 0xfe,
 	0x12, 0x12, 0xfe, 0x03, 0x80, 0x74, 0xfe, 0x01, 0xec, 0x20, 0xfe, 0x80,
-	0x40, 0x12, 0x20, 0x63,
-	0x27, 0x11, 0xc8, 0x59, 0x1e, 0x20, 0xed, 0x76, 0x20, 0x03, 0xfe, 0x08,
-	0x1c, 0x05, 0xfe, 0xac,
-	0x00, 0xfe, 0x06, 0x58, 0x05, 0xfe, 0xae, 0x00, 0xfe, 0x07, 0x58, 0x05,
-	0xfe, 0xb0, 0x00, 0xfe,
+	0x40, 0x12, 0x20, 0x63, 0x27, 0x11, 0xc8, 0x59, 0x1e, 0x20, 0xed, 0x76,
+	0x20, 0x03, 0xfe, 0x08, 0x1c, 0x05, 0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58,
+	0x05, 0xfe, 0xae, 0x00, 0xfe, 0x07, 0x58, 0x05, 0xfe, 0xb0, 0x00, 0xfe,
 	0x08, 0x58, 0x05, 0xfe, 0xb2, 0x00, 0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c,
-	0x24, 0x69, 0x12, 0xc9,
-	0x23, 0x0c, 0x50, 0x0c, 0x3f, 0x13, 0x40, 0x48, 0x5f, 0x17, 0x1d, 0xfe,
-	0x90, 0x4d, 0xfe, 0x91,
-	0x54, 0x21, 0xfe, 0x08, 0x0f, 0x3e, 0x10, 0x13, 0x42, 0x48, 0x17, 0x4c,
-	0xfe, 0x90, 0x4d, 0xfe,
+	0x24, 0x69, 0x12, 0xc9, 0x23, 0x0c, 0x50, 0x0c, 0x3f, 0x13, 0x40, 0x48,
+	0x5f, 0x17, 0x1d, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x21, 0xfe, 0x08,
+	0x0f, 0x3e, 0x10, 0x13, 0x42, 0x48, 0x17, 0x4c, 0xfe, 0x90, 0x4d, 0xfe,
 	0x91, 0x54, 0x21, 0xfe, 0x1e, 0x0f, 0x24, 0x10, 0x12, 0x20, 0x78, 0x2c,
-	0x46, 0x1e, 0x20, 0xed,
-	0x76, 0x20, 0x11, 0xc8, 0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x32, 0x0f, 0xea,
-	0x70, 0xfe, 0x14, 0x1c,
-	0xfe, 0x10, 0x1c, 0xfe, 0x18, 0x1c, 0x03, 0x3c, 0xfe, 0x0c, 0x14, 0xee,
-	0xfe, 0x07, 0xe6, 0x1d,
+	0x46, 0x1e, 0x20, 0xed, 0x76, 0x20, 0x11, 0xc8, 0xf6, 0xfe, 0xd6, 0xf0,
+	0xfe, 0x32, 0x0f, 0xea, 0x70, 0xfe, 0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe,
+	0x18, 0x1c, 0x03, 0x3c, 0xfe, 0x0c, 0x14, 0xee, 0xfe, 0x07, 0xe6, 0x1d,
 	0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x03, 0x01, 0x86, 0x78, 0x2c, 0x46,
-	0xfa, 0xef, 0xfe, 0x42,
-	0x13, 0x2f, 0x07, 0x2d, 0xfe, 0x34, 0x13, 0x0a, 0x42, 0x01, 0x0e, 0xb0,
-	0xfe, 0x36, 0x12, 0xf0,
-	0xfe, 0x45, 0x48, 0x01, 0xe3, 0xfe, 0x00, 0xcc, 0xb0, 0xfe, 0xf3, 0x13,
-	0x3d, 0x75, 0x07, 0x10,
+	0xfa, 0xef, 0xfe, 0x42, 0x13, 0x2f, 0x07, 0x2d, 0xfe, 0x34, 0x13, 0x0a,
+	0x42, 0x01, 0x0e, 0xb0, 0xfe, 0x36, 0x12, 0xf0, 0xfe, 0x45, 0x48, 0x01,
+	0xe3, 0xfe, 0x00, 0xcc, 0xb0, 0xfe, 0xf3, 0x13, 0x3d, 0x75, 0x07, 0x10,
 	0xa3, 0x0a, 0x80, 0x01, 0x0e, 0xfe, 0x80, 0x5c, 0x01, 0x6f, 0xfe, 0x0e,
-	0x10, 0x07, 0x7e, 0x45,
-	0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x6c, 0x0f, 0x03, 0xfe, 0x44, 0x58, 0x74,
-	0xfe, 0x01, 0xec, 0x97,
-	0xfe, 0x9e, 0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x1b, 0x76,
-	0x27, 0x01, 0xda, 0xfe,
+	0x10, 0x07, 0x7e, 0x45, 0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x6c, 0x0f, 0x03,
+	0xfe, 0x44, 0x58, 0x74, 0xfe, 0x01, 0xec, 0x97, 0xfe, 0x9e, 0x40, 0xfe,
+	0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x1b, 0x76, 0x27, 0x01, 0xda, 0xfe,
 	0xdd, 0x10, 0x2a, 0xbc, 0x7d, 0xbd, 0x7f, 0x30, 0x2e, 0xd5, 0x07, 0x1b,
-	0xfe, 0x48, 0x12, 0x07,
-	0x0b, 0xfe, 0x56, 0x12, 0x07, 0x1a, 0xfe, 0x30, 0x12, 0x07, 0xc2, 0x16,
-	0xfe, 0x3e, 0x11, 0x07,
-	0xfe, 0x23, 0x00, 0x16, 0xfe, 0x4a, 0x11, 0x07, 0x06, 0x16, 0xfe, 0xa8,
-	0x11, 0x07, 0x19, 0xfe,
+	0xfe, 0x48, 0x12, 0x07, 0x0b, 0xfe, 0x56, 0x12, 0x07, 0x1a, 0xfe, 0x30,
+	0x12, 0x07, 0xc2, 0x16, 0xfe, 0x3e, 0x11, 0x07, 0xfe, 0x23, 0x00, 0x16,
+	0xfe, 0x4a, 0x11, 0x07, 0x06, 0x16, 0xfe, 0xa8, 0x11, 0x07, 0x19, 0xfe,
 	0x12, 0x12, 0x07, 0x00, 0x16, 0x22, 0x14, 0xc2, 0x01, 0x33, 0x9f, 0x2b,
-	0x01, 0x08, 0x8c, 0x43,
-	0x03, 0x2b, 0xfe, 0x62, 0x08, 0x0a, 0xca, 0x01, 0xfe, 0x32, 0x0e, 0x11,
-	0x7e, 0x02, 0x29, 0x2b,
-	0x2f, 0x07, 0x9b, 0xfe, 0xd9, 0x13, 0x79, 0x39, 0x68, 0x3a, 0x77, 0xfe,
-	0xfc, 0x10, 0x09, 0x04,
+	0x01, 0x08, 0x8c, 0x43, 0x03, 0x2b, 0xfe, 0x62, 0x08, 0x0a, 0xca, 0x01,
+	0xfe, 0x32, 0x0e, 0x11, 0x7e, 0x02, 0x29, 0x2b, 0x2f, 0x07, 0x9b, 0xfe,
+	0xd9, 0x13, 0x79, 0x39, 0x68, 0x3a, 0x77, 0xfe, 0xfc, 0x10, 0x09, 0x04,
 	0x6a, 0xfe, 0x72, 0x12, 0xc0, 0x38, 0xc1, 0x4e, 0xf4, 0xf5, 0x8e, 0xfe,
-	0xc6, 0x10, 0x1e, 0x58,
-	0xfe, 0x26, 0x13, 0x05, 0x7b, 0x31, 0x7c, 0x77, 0xfe, 0x82, 0x0c, 0x0c,
-	0x54, 0x18, 0x55, 0x23,
-	0x0c, 0x7b, 0x0c, 0x7c, 0x01, 0xa8, 0x24, 0x69, 0x73, 0x12, 0x58, 0x01,
-	0xa5, 0xc0, 0x38, 0xc1,
+	0xc6, 0x10, 0x1e, 0x58, 0xfe, 0x26, 0x13, 0x05, 0x7b, 0x31, 0x7c, 0x77,
+	0xfe, 0x82, 0x0c, 0x0c, 0x54, 0x18, 0x55, 0x23, 0x0c, 0x7b, 0x0c, 0x7c,
+	0x01, 0xa8, 0x24, 0x69, 0x73, 0x12, 0x58, 0x01, 0xa5, 0xc0, 0x38, 0xc1,
 	0x4e, 0xfe, 0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x38, 0xfe,
-	0x05, 0xfa, 0x4e, 0xfe,
-	0x91, 0x10, 0x05, 0x56, 0x31, 0x57, 0xfe, 0x40, 0x56, 0xfe, 0xe1, 0x56,
-	0x0c, 0x56, 0x18, 0x57,
-	0x83, 0xc0, 0x38, 0xc1, 0x4e, 0xf4, 0xf5, 0x05, 0x52, 0x31, 0x53, 0xfe,
-	0x00, 0x56, 0xfe, 0xa1,
+	0x05, 0xfa, 0x4e, 0xfe, 0x91, 0x10, 0x05, 0x56, 0x31, 0x57, 0xfe, 0x40,
+	0x56, 0xfe, 0xe1, 0x56, 0x0c, 0x56, 0x18, 0x57, 0x83, 0xc0, 0x38, 0xc1,
+	0x4e, 0xf4, 0xf5, 0x05, 0x52, 0x31, 0x53, 0xfe, 0x00, 0x56, 0xfe, 0xa1,
 	0x56, 0x0c, 0x52, 0x18, 0x53, 0x09, 0x04, 0x6a, 0xfe, 0x1e, 0x12, 0x1e,
-	0x58, 0xfe, 0x1f, 0x40,
-	0x05, 0x54, 0x31, 0x55, 0xfe, 0x2c, 0x50, 0xfe, 0xae, 0x50, 0x05, 0x56,
-	0x31, 0x57, 0xfe, 0x44,
-	0x50, 0xfe, 0xc6, 0x50, 0x05, 0x52, 0x31, 0x53, 0xfe, 0x08, 0x50, 0xfe,
-	0x8a, 0x50, 0x05, 0x39,
+	0x58, 0xfe, 0x1f, 0x40, 0x05, 0x54, 0x31, 0x55, 0xfe, 0x2c, 0x50, 0xfe,
+	0xae, 0x50, 0x05, 0x56, 0x31, 0x57, 0xfe, 0x44, 0x50, 0xfe, 0xc6, 0x50,
+	0x05, 0x52, 0x31, 0x53, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x05, 0x39,
 	0x31, 0x3a, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x02, 0x5c, 0x24, 0x06,
-	0x12, 0xcd, 0x02, 0x5b,
-	0x2b, 0x01, 0x08, 0x1f, 0x44, 0x30, 0x2e, 0xd5, 0x07, 0x06, 0x21, 0x44,
-	0x2f, 0x07, 0x9b, 0x21,
-	0x5b, 0x01, 0x6e, 0x1c, 0x3d, 0x16, 0x44, 0x09, 0x04, 0x0b, 0xe2, 0x79,
-	0x39, 0x68, 0x3a, 0xfe,
+	0x12, 0xcd, 0x02, 0x5b, 0x2b, 0x01, 0x08, 0x1f, 0x44, 0x30, 0x2e, 0xd5,
+	0x07, 0x06, 0x21, 0x44, 0x2f, 0x07, 0x9b, 0x21, 0x5b, 0x01, 0x6e, 0x1c,
+	0x3d, 0x16, 0x44, 0x09, 0x04, 0x0b, 0xe2, 0x79, 0x39, 0x68, 0x3a, 0xfe,
 	0x0a, 0x55, 0x34, 0xfe, 0x8b, 0x55, 0xbe, 0x39, 0xbf, 0x3a, 0xfe, 0x0c,
-	0x51, 0xfe, 0x8e, 0x51,
-	0x02, 0x5b, 0xfe, 0x19, 0x81, 0xaf, 0xfe, 0x19, 0x41, 0x02, 0x5b, 0x2b,
-	0x01, 0x08, 0x25, 0x32,
-	0x1f, 0xa2, 0x30, 0x2e, 0xd8, 0x4b, 0x1a, 0xfe, 0xa6, 0x12, 0x4b, 0x0b,
-	0x3b, 0x02, 0x44, 0x01,
+	0x51, 0xfe, 0x8e, 0x51, 0x02, 0x5b, 0xfe, 0x19, 0x81, 0xaf, 0xfe, 0x19,
+	0x41, 0x02, 0x5b, 0x2b, 0x01, 0x08, 0x25, 0x32, 0x1f, 0xa2, 0x30, 0x2e,
+	0xd8, 0x4b, 0x1a, 0xfe, 0xa6, 0x12, 0x4b, 0x0b, 0x3b, 0x02, 0x44, 0x01,
 	0x08, 0x25, 0x32, 0x1f, 0xa2, 0x30, 0x2e, 0xd6, 0x07, 0x1a, 0x21, 0x44,
-	0x01, 0x08, 0x1f, 0xa2,
-	0x30, 0x2e, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49, 0x60, 0x05, 0xfe, 0x9c,
-	0x00, 0x28, 0x84, 0x49,
-	0x04, 0x19, 0x34, 0x9f, 0xfe, 0xbb, 0x45, 0x4b, 0x00, 0x45, 0x3e, 0x06,
-	0x78, 0x3d, 0xfe, 0xda,
+	0x01, 0x08, 0x1f, 0xa2, 0x30, 0x2e, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49,
+	0x60, 0x05, 0xfe, 0x9c, 0x00, 0x28, 0x84, 0x49, 0x04, 0x19, 0x34, 0x9f,
+	0xfe, 0xbb, 0x45, 0x4b, 0x00, 0x45, 0x3e, 0x06, 0x78, 0x3d, 0xfe, 0xda,
 	0x14, 0x01, 0x6e, 0x87, 0xfe, 0x4b, 0x45, 0xe2, 0x2f, 0x07, 0x9a, 0xe1,
-	0x05, 0xc6, 0x28, 0x84,
-	0x05, 0x3f, 0x28, 0x34, 0x5e, 0x02, 0x5b, 0xfe, 0xc0, 0x5d, 0xfe, 0xf8,
-	0x14, 0xfe, 0x03, 0x17,
-	0x05, 0x50, 0xb4, 0x0c, 0x50, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01,
-	0xfe, 0xaa, 0x14, 0x02,
+	0x05, 0xc6, 0x28, 0x84, 0x05, 0x3f, 0x28, 0x34, 0x5e, 0x02, 0x5b, 0xfe,
+	0xc0, 0x5d, 0xfe, 0xf8, 0x14, 0xfe, 0x03, 0x17, 0x05, 0x50, 0xb4, 0x0c,
+	0x50, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01, 0xfe, 0xaa, 0x14, 0x02,
 	0x5c, 0x01, 0x08, 0x25, 0x32, 0x1f, 0x44, 0x30, 0x2e, 0xd6, 0x07, 0x06,
-	0x21, 0x44, 0x01, 0xfe,
-	0x8e, 0x13, 0xfe, 0x42, 0x58, 0xfe, 0x82, 0x14, 0xfe, 0xa4, 0x14, 0x87,
-	0xfe, 0x4a, 0xf4, 0x0b,
-	0x16, 0x44, 0xfe, 0x4a, 0xf4, 0x06, 0xfe, 0x0c, 0x12, 0x2f, 0x07, 0x9a,
-	0x85, 0x02, 0x5b, 0x05,
+	0x21, 0x44, 0x01, 0xfe, 0x8e, 0x13, 0xfe, 0x42, 0x58, 0xfe, 0x82, 0x14,
+	0xfe, 0xa4, 0x14, 0x87, 0xfe, 0x4a, 0xf4, 0x0b, 0x16, 0x44, 0xfe, 0x4a,
+	0xf4, 0x06, 0xfe, 0x0c, 0x12, 0x2f, 0x07, 0x9a, 0x85, 0x02, 0x5b, 0x05,
 	0x3f, 0xb4, 0x0c, 0x3f, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01, 0xfe,
-	0xd8, 0x14, 0x02, 0x5c,
-	0x13, 0x06, 0x65, 0xfe, 0xca, 0x12, 0x26, 0xfe, 0xe0, 0x12, 0x72, 0xf1,
-	0x01, 0x08, 0x23, 0x72,
-	0x03, 0x8f, 0xfe, 0xdc, 0x12, 0x25, 0xfe, 0xdc, 0x12, 0x1f, 0xfe, 0xca,
-	0x12, 0x5e, 0x2b, 0x01,
+	0xd8, 0x14, 0x02, 0x5c, 0x13, 0x06, 0x65, 0xfe, 0xca, 0x12, 0x26, 0xfe,
+	0xe0, 0x12, 0x72, 0xf1, 0x01, 0x08, 0x23, 0x72, 0x03, 0x8f, 0xfe, 0xdc,
+	0x12, 0x25, 0xfe, 0xdc, 0x12, 0x1f, 0xfe, 0xca, 0x12, 0x5e, 0x2b, 0x01,
 	0x08, 0xfe, 0xd5, 0x10, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b,
-	0x1c, 0xfe, 0xff, 0x7f,
-	0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x03, 0x13, 0x6c, 0xff, 0x02, 0x00,
-	0x57, 0x48, 0x8b, 0x1c,
-	0x3d, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x03, 0x13, 0x6c, 0xff, 0x02,
-	0x00, 0x57, 0x48, 0x8b,
+	0x1c, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x03, 0x13,
+	0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0x1c, 0x3d, 0xfe, 0x30, 0x56,
+	0xfe, 0x00, 0x5c, 0x03, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b,
 	0x03, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0xfe, 0x0b, 0x58,
-	0x03, 0x0a, 0x50, 0x01,
-	0x82, 0x0a, 0x3f, 0x01, 0x82, 0x03, 0xfc, 0x1c, 0x10, 0xff, 0x03, 0x00,
-	0x54, 0xfe, 0x00, 0xf4,
-	0x19, 0x48, 0xfe, 0x00, 0x7d, 0xfe, 0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe,
-	0x03, 0x7c, 0x63, 0x27,
+	0x03, 0x0a, 0x50, 0x01, 0x82, 0x0a, 0x3f, 0x01, 0x82, 0x03, 0xfc, 0x1c,
+	0x10, 0xff, 0x03, 0x00, 0x54, 0xfe, 0x00, 0xf4, 0x19, 0x48, 0xfe, 0x00,
+	0x7d, 0xfe, 0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe, 0x03, 0x7c, 0x63, 0x27,
 	0x0c, 0x52, 0x18, 0x53, 0xbe, 0x56, 0xbf, 0x57, 0x03, 0xfe, 0x62, 0x08,
-	0xfe, 0x82, 0x4a, 0xfe,
-	0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x74, 0x03, 0x01, 0xfe, 0x14, 0x18, 0xfe,
-	0x42, 0x48, 0x5f, 0x60,
-	0x89, 0x01, 0x08, 0x1f, 0xfe, 0xa2, 0x14, 0x30, 0x2e, 0xd8, 0x01, 0x08,
-	0x1f, 0xfe, 0xa2, 0x14,
+	0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x74, 0x03, 0x01,
+	0xfe, 0x14, 0x18, 0xfe, 0x42, 0x48, 0x5f, 0x60, 0x89, 0x01, 0x08, 0x1f,
+	0xfe, 0xa2, 0x14, 0x30, 0x2e, 0xd8, 0x01, 0x08, 0x1f, 0xfe, 0xa2, 0x14,
 	0x30, 0x2e, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x05, 0xc6, 0x28, 0xfe,
-	0xcc, 0x12, 0x49, 0x04,
-	0x1b, 0xfe, 0xc4, 0x13, 0x23, 0x62, 0x1b, 0xe2, 0x4b, 0xc3, 0x64, 0xfe,
-	0xe8, 0x13, 0x3b, 0x13,
-	0x06, 0x17, 0xc3, 0x78, 0xdb, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55,
-	0xa1, 0xff, 0x02, 0x83,
+	0xcc, 0x12, 0x49, 0x04, 0x1b, 0xfe, 0xc4, 0x13, 0x23, 0x62, 0x1b, 0xe2,
+	0x4b, 0xc3, 0x64, 0xfe, 0xe8, 0x13, 0x3b, 0x13, 0x06, 0x17, 0xc3, 0x78,
+	0xdb, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xa1, 0xff, 0x02, 0x83,
 	0x55, 0x62, 0x1a, 0xa4, 0xbb, 0xfe, 0x30, 0x00, 0x8e, 0xe4, 0x17, 0x2c,
-	0x13, 0x06, 0xfe, 0x56,
-	0x10, 0x62, 0x0b, 0xe1, 0xbb, 0xfe, 0x64, 0x00, 0x8e, 0xe4, 0x0a, 0xfe,
-	0x64, 0x00, 0x17, 0x93,
-	0x13, 0x06, 0xfe, 0x28, 0x10, 0x62, 0x06, 0xfe, 0x60, 0x13, 0xbb, 0xfe,
-	0xc8, 0x00, 0x8e, 0xe4,
+	0x13, 0x06, 0xfe, 0x56, 0x10, 0x62, 0x0b, 0xe1, 0xbb, 0xfe, 0x64, 0x00,
+	0x8e, 0xe4, 0x0a, 0xfe, 0x64, 0x00, 0x17, 0x93, 0x13, 0x06, 0xfe, 0x28,
+	0x10, 0x62, 0x06, 0xfe, 0x60, 0x13, 0xbb, 0xfe, 0xc8, 0x00, 0x8e, 0xe4,
 	0x0a, 0xfe, 0xc8, 0x00, 0x17, 0x4d, 0x13, 0x06, 0x83, 0xbb, 0xfe, 0x90,
-	0x01, 0xba, 0xfe, 0x4e,
-	0x14, 0x89, 0xfe, 0x12, 0x10, 0xfe, 0x43, 0xf4, 0x94, 0xfe, 0x56, 0xf0,
-	0xfe, 0x60, 0x14, 0xfe,
-	0x04, 0xf4, 0x6c, 0xfe, 0x43, 0xf4, 0x93, 0xfe, 0xf3, 0x10, 0xf9, 0x01,
-	0xfe, 0x22, 0x13, 0x1c,
+	0x01, 0xba, 0xfe, 0x4e, 0x14, 0x89, 0xfe, 0x12, 0x10, 0xfe, 0x43, 0xf4,
+	0x94, 0xfe, 0x56, 0xf0, 0xfe, 0x60, 0x14, 0xfe, 0x04, 0xf4, 0x6c, 0xfe,
+	0x43, 0xf4, 0x93, 0xfe, 0xf3, 0x10, 0xf9, 0x01, 0xfe, 0x22, 0x13, 0x1c,
 	0x3d, 0xfe, 0x10, 0x13, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x69, 0xba,
-	0xfe, 0x9c, 0x14, 0xb7,
-	0x69, 0xfe, 0x1c, 0x10, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x19, 0xba,
-	0xfe, 0x9c, 0x14, 0xb7,
-	0x19, 0x83, 0x60, 0x23, 0xfe, 0x4d, 0xf4, 0x00, 0xdf, 0x89, 0x13, 0x06,
-	0xfe, 0xb4, 0x56, 0xfe,
+	0xfe, 0x9c, 0x14, 0xb7, 0x69, 0xfe, 0x1c, 0x10, 0xfe, 0x00, 0x17, 0xfe,
+	0x4d, 0xe4, 0x19, 0xba, 0xfe, 0x9c, 0x14, 0xb7, 0x19, 0x83, 0x60, 0x23,
+	0xfe, 0x4d, 0xf4, 0x00, 0xdf, 0x89, 0x13, 0x06, 0xfe, 0xb4, 0x56, 0xfe,
 	0xc3, 0x58, 0x03, 0x60, 0x13, 0x0b, 0x03, 0x15, 0x06, 0x01, 0x08, 0x26,
-	0xe5, 0x15, 0x0b, 0x01,
-	0x08, 0x26, 0xe5, 0x15, 0x1a, 0x01, 0x08, 0x26, 0xe5, 0x72, 0xfe, 0x89,
-	0x49, 0x01, 0x08, 0x03,
-	0x15, 0x06, 0x01, 0x08, 0x26, 0xa6, 0x15, 0x1a, 0x01, 0x08, 0x26, 0xa6,
-	0x15, 0x06, 0x01, 0x08,
+	0xe5, 0x15, 0x0b, 0x01, 0x08, 0x26, 0xe5, 0x15, 0x1a, 0x01, 0x08, 0x26,
+	0xe5, 0x72, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x03, 0x15, 0x06, 0x01, 0x08,
+	0x26, 0xa6, 0x15, 0x1a, 0x01, 0x08, 0x26, 0xa6, 0x15, 0x06, 0x01, 0x08,
 	0x26, 0xa6, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x26, 0xa6, 0x72, 0xfe, 0x89,
-	0x4a, 0x01, 0x08, 0x03,
-	0x60, 0x03, 0x1e, 0xcc, 0x07, 0x06, 0xfe, 0x44, 0x13, 0xad, 0x12, 0xcc,
-	0xfe, 0x49, 0xf4, 0x00,
-	0x3b, 0x72, 0x9f, 0x5e, 0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xf1, 0x01,
-	0x08, 0x2f, 0x07, 0xfe,
+	0x4a, 0x01, 0x08, 0x03, 0x60, 0x03, 0x1e, 0xcc, 0x07, 0x06, 0xfe, 0x44,
+	0x13, 0xad, 0x12, 0xcc, 0xfe, 0x49, 0xf4, 0x00, 0x3b, 0x72, 0x9f, 0x5e,
+	0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xf1, 0x01, 0x08, 0x2f, 0x07, 0xfe,
 	0xe3, 0x00, 0xfe, 0x20, 0x13, 0x1f, 0xfe, 0x5a, 0x15, 0x23, 0x12, 0xcd,
-	0x01, 0x43, 0x1e, 0xcd,
-	0x07, 0x06, 0x45, 0x09, 0x4a, 0x06, 0x35, 0x03, 0x0a, 0x42, 0x01, 0x0e,
-	0xed, 0x88, 0x07, 0x10,
-	0xa4, 0x0a, 0x80, 0x01, 0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03, 0x0a,
-	0x80, 0x01, 0x0e, 0x88,
+	0x01, 0x43, 0x1e, 0xcd, 0x07, 0x06, 0x45, 0x09, 0x4a, 0x06, 0x35, 0x03,
+	0x0a, 0x42, 0x01, 0x0e, 0xed, 0x88, 0x07, 0x10, 0xa4, 0x0a, 0x80, 0x01,
+	0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03, 0x0a, 0x80, 0x01, 0x0e, 0x88,
 	0xfe, 0x80, 0xe7, 0x10, 0x07, 0x10, 0x84, 0xfe, 0x45, 0x58, 0x01, 0xe3,
-	0x88, 0x03, 0x0a, 0x42,
-	0x01, 0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03, 0x0a, 0x42, 0x01, 0x0e,
-	0xfe, 0x80, 0x80, 0xf2,
-	0xfe, 0x49, 0xe4, 0x10, 0xa4, 0x0a, 0x80, 0x01, 0x0e, 0xf2, 0x0a, 0x51,
-	0x01, 0x82, 0x03, 0x17,
+	0x88, 0x03, 0x0a, 0x42, 0x01, 0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03,
+	0x0a, 0x42, 0x01, 0x0e, 0xfe, 0x80, 0x80, 0xf2, 0xfe, 0x49, 0xe4, 0x10,
+	0xa4, 0x0a, 0x80, 0x01, 0x0e, 0xf2, 0x0a, 0x51, 0x01, 0x82, 0x03, 0x17,
 	0x10, 0x71, 0x66, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde,
-	0xfe, 0x24, 0x1c, 0xfe,
-	0x1d, 0xf7, 0x1d, 0x90, 0xfe, 0xf6, 0x15, 0x01, 0xfe, 0xfc, 0x16, 0xe0,
-	0x91, 0x1d, 0x66, 0xfe,
-	0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x03, 0xae, 0x21, 0xfe, 0xe6, 0x15, 0xfe,
-	0xda, 0x10, 0x17, 0x10,
+	0xfe, 0x24, 0x1c, 0xfe, 0x1d, 0xf7, 0x1d, 0x90, 0xfe, 0xf6, 0x15, 0x01,
+	0xfe, 0xfc, 0x16, 0xe0, 0x91, 0x1d, 0x66, 0xfe, 0x2c, 0x01, 0xfe, 0x2f,
+	0x19, 0x03, 0xae, 0x21, 0xfe, 0xe6, 0x15, 0xfe, 0xda, 0x10, 0x17, 0x10,
 	0x71, 0x05, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x19, 0xfe, 0x18, 0x58,
-	0x05, 0xfe, 0x66, 0x01,
-	0xfe, 0x19, 0x58, 0x91, 0x19, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4, 0x06,
-	0xfe, 0x3c, 0x50, 0x66,
-	0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x19, 0x90, 0xfe,
-	0x40, 0x16, 0xfe, 0xb6,
+	0x05, 0xfe, 0x66, 0x01, 0xfe, 0x19, 0x58, 0x91, 0x19, 0xfe, 0x3c, 0x90,
+	0xfe, 0x30, 0xf4, 0x06, 0xfe, 0x3c, 0x50, 0x66, 0xfe, 0x38, 0x00, 0xfe,
+	0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x19, 0x90, 0xfe, 0x40, 0x16, 0xfe, 0xb6,
 	0x14, 0x34, 0x03, 0xae, 0x21, 0xfe, 0x18, 0x16, 0xfe, 0x9c, 0x10, 0x17,
-	0x10, 0x71, 0xfe, 0x83,
-	0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7, 0x38, 0x90,
-	0xfe, 0x62, 0x16, 0xfe,
-	0x94, 0x14, 0xfe, 0x10, 0x13, 0x91, 0x38, 0x66, 0x1b, 0xfe, 0xaf, 0x19,
-	0xfe, 0x98, 0xe7, 0x00,
+	0x10, 0x71, 0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe,
+	0x1d, 0xf7, 0x38, 0x90, 0xfe, 0x62, 0x16, 0xfe, 0x94, 0x14, 0xfe, 0x10,
+	0x13, 0x91, 0x38, 0x66, 0x1b, 0xfe, 0xaf, 0x19, 0xfe, 0x98, 0xe7, 0x00,
 	0x03, 0xae, 0x21, 0xfe, 0x56, 0x16, 0xfe, 0x6c, 0x10, 0x17, 0x10, 0x71,
-	0xfe, 0x30, 0xbc, 0xfe,
-	0xb2, 0xbc, 0x91, 0xc5, 0x66, 0x1b, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7,
-	0xc5, 0x90, 0xfe, 0x9a,
-	0x16, 0xfe, 0x5c, 0x14, 0x34, 0x03, 0xae, 0x21, 0xfe, 0x86, 0x16, 0xfe,
-	0x42, 0x10, 0xfe, 0x02,
+	0xfe, 0x30, 0xbc, 0xfe, 0xb2, 0xbc, 0x91, 0xc5, 0x66, 0x1b, 0xfe, 0x0f,
+	0x79, 0xfe, 0x1c, 0xf7, 0xc5, 0x90, 0xfe, 0x9a, 0x16, 0xfe, 0x5c, 0x14,
+	0x34, 0x03, 0xae, 0x21, 0xfe, 0x86, 0x16, 0xfe, 0x42, 0x10, 0xfe, 0x02,
 	0xf6, 0x10, 0x71, 0xfe, 0x18, 0xfe, 0x54, 0xfe, 0x19, 0xfe, 0x55, 0xfc,
-	0xfe, 0x1d, 0xf7, 0x4f,
-	0x90, 0xfe, 0xc0, 0x16, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13, 0x91, 0x4f,
-	0x47, 0xfe, 0x83, 0x58,
-	0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7, 0x10, 0xfe, 0x81, 0xe7, 0x10, 0x11,
-	0xfe, 0xdd, 0x00, 0x63,
+	0xfe, 0x1d, 0xf7, 0x4f, 0x90, 0xfe, 0xc0, 0x16, 0xfe, 0x36, 0x14, 0xfe,
+	0x1c, 0x13, 0x91, 0x4f, 0x47, 0xfe, 0x83, 0x58, 0xfe, 0xaf, 0x19, 0xfe,
+	0x80, 0xe7, 0x10, 0xfe, 0x81, 0xe7, 0x10, 0x11, 0xfe, 0xdd, 0x00, 0x63,
 	0x27, 0x03, 0x63, 0x27, 0xfe, 0x12, 0x45, 0x21, 0xfe, 0xb0, 0x16, 0x14,
-	0x06, 0x37, 0x95, 0xa9,
-	0x02, 0x29, 0xfe, 0x39, 0xf0, 0xfe, 0x04, 0x17, 0x23, 0x03, 0xfe, 0x7e,
-	0x18, 0x1c, 0x1a, 0x5d,
-	0x13, 0x0d, 0x03, 0x71, 0x05, 0xcb, 0x1c, 0x06, 0xfe, 0xef, 0x12, 0xfe,
-	0xe1, 0x10, 0x78, 0x2c,
+	0x06, 0x37, 0x95, 0xa9, 0x02, 0x29, 0xfe, 0x39, 0xf0, 0xfe, 0x04, 0x17,
+	0x23, 0x03, 0xfe, 0x7e, 0x18, 0x1c, 0x1a, 0x5d, 0x13, 0x0d, 0x03, 0x71,
+	0x05, 0xcb, 0x1c, 0x06, 0xfe, 0xef, 0x12, 0xfe, 0xe1, 0x10, 0x78, 0x2c,
 	0x46, 0x2f, 0x07, 0x2d, 0xfe, 0x3c, 0x13, 0xfe, 0x82, 0x14, 0xfe, 0x42,
-	0x13, 0x3c, 0x8a, 0x0a,
-	0x42, 0x01, 0x0e, 0xb0, 0xfe, 0x3e, 0x12, 0xf0, 0xfe, 0x45, 0x48, 0x01,
-	0xe3, 0xfe, 0x00, 0xcc,
-	0xb0, 0xfe, 0xf3, 0x13, 0x3d, 0x75, 0x07, 0x10, 0xa3, 0x0a, 0x80, 0x01,
-	0x0e, 0xf2, 0x01, 0x6f,
+	0x13, 0x3c, 0x8a, 0x0a, 0x42, 0x01, 0x0e, 0xb0, 0xfe, 0x3e, 0x12, 0xf0,
+	0xfe, 0x45, 0x48, 0x01, 0xe3, 0xfe, 0x00, 0xcc, 0xb0, 0xfe, 0xf3, 0x13,
+	0x3d, 0x75, 0x07, 0x10, 0xa3, 0x0a, 0x80, 0x01, 0x0e, 0xf2, 0x01, 0x6f,
 	0xfe, 0x16, 0x10, 0x07, 0x7e, 0x85, 0xfe, 0x40, 0x14, 0xfe, 0x24, 0x12,
-	0xf6, 0xfe, 0xd6, 0xf0,
-	0xfe, 0x24, 0x17, 0x17, 0x0b, 0x03, 0xfe, 0x9c, 0xe7, 0x0b, 0x0f, 0xfe,
-	0x15, 0x00, 0x59, 0x76,
-	0x27, 0x01, 0xda, 0x17, 0x06, 0x03, 0x3c, 0x8a, 0x09, 0x4a, 0x1d, 0x35,
-	0x11, 0x2d, 0x01, 0x6f,
+	0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x24, 0x17, 0x17, 0x0b, 0x03, 0xfe, 0x9c,
+	0xe7, 0x0b, 0x0f, 0xfe, 0x15, 0x00, 0x59, 0x76, 0x27, 0x01, 0xda, 0x17,
+	0x06, 0x03, 0x3c, 0x8a, 0x09, 0x4a, 0x1d, 0x35, 0x11, 0x2d, 0x01, 0x6f,
 	0x17, 0x06, 0x03, 0xfe, 0x38, 0x90, 0xfe, 0xba, 0x90, 0x79, 0xc7, 0x68,
-	0xc8, 0xfe, 0x48, 0x55,
-	0x34, 0xfe, 0xc9, 0x55, 0x03, 0x1e, 0x98, 0x73, 0x12, 0x98, 0x03, 0x0a,
-	0x99, 0x01, 0x0e, 0xf0,
-	0x0a, 0x40, 0x01, 0x0e, 0xfe, 0x49, 0x44, 0x16, 0xfe, 0xf0, 0x17, 0x73,
-	0x75, 0x03, 0x0a, 0x42,
+	0xc8, 0xfe, 0x48, 0x55, 0x34, 0xfe, 0xc9, 0x55, 0x03, 0x1e, 0x98, 0x73,
+	0x12, 0x98, 0x03, 0x0a, 0x99, 0x01, 0x0e, 0xf0, 0x0a, 0x40, 0x01, 0x0e,
+	0xfe, 0x49, 0x44, 0x16, 0xfe, 0xf0, 0x17, 0x73, 0x75, 0x03, 0x0a, 0x42,
 	0x01, 0x0e, 0x07, 0x10, 0x45, 0x0a, 0x51, 0x01, 0x9e, 0x0a, 0x40, 0x01,
-	0x0e, 0x73, 0x75, 0x03,
-	0xfe, 0x4e, 0xe4, 0x1a, 0x64, 0xfe, 0x24, 0x18, 0x05, 0xfe, 0x90, 0x00,
-	0xfe, 0x3a, 0x45, 0x5b,
-	0xfe, 0x4e, 0xe4, 0xc2, 0x64, 0xfe, 0x36, 0x18, 0x05, 0xfe, 0x92, 0x00,
-	0xfe, 0x02, 0xe6, 0x1b,
+	0x0e, 0x73, 0x75, 0x03, 0xfe, 0x4e, 0xe4, 0x1a, 0x64, 0xfe, 0x24, 0x18,
+	0x05, 0xfe, 0x90, 0x00, 0xfe, 0x3a, 0x45, 0x5b, 0xfe, 0x4e, 0xe4, 0xc2,
+	0x64, 0xfe, 0x36, 0x18, 0x05, 0xfe, 0x92, 0x00, 0xfe, 0x02, 0xe6, 0x1b,
 	0xdc, 0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x64, 0xfe, 0x48, 0x18, 0x05,
-	0xfe, 0x94, 0x00, 0xfe,
-	0x02, 0xe6, 0x19, 0xfe, 0x08, 0x10, 0x05, 0xfe, 0x96, 0x00, 0xfe, 0x02,
-	0xe6, 0x2c, 0xfe, 0x4e,
-	0x45, 0xfe, 0x0c, 0x12, 0xaf, 0xff, 0x04, 0x68, 0x54, 0xde, 0x1c, 0x69,
-	0x03, 0x07, 0x7a, 0xfe,
+	0xfe, 0x94, 0x00, 0xfe, 0x02, 0xe6, 0x19, 0xfe, 0x08, 0x10, 0x05, 0xfe,
+	0x96, 0x00, 0xfe, 0x02, 0xe6, 0x2c, 0xfe, 0x4e, 0x45, 0xfe, 0x0c, 0x12,
+	0xaf, 0xff, 0x04, 0x68, 0x54, 0xde, 0x1c, 0x69, 0x03, 0x07, 0x7a, 0xfe,
 	0x5a, 0xf0, 0xfe, 0x74, 0x18, 0x24, 0xfe, 0x09, 0x00, 0xfe, 0x34, 0x10,
-	0x07, 0x1b, 0xfe, 0x5a,
-	0xf0, 0xfe, 0x82, 0x18, 0x24, 0xc3, 0xfe, 0x26, 0x10, 0x07, 0x1a, 0x5d,
-	0x24, 0x2c, 0xdc, 0x07,
-	0x0b, 0x5d, 0x24, 0x93, 0xfe, 0x0e, 0x10, 0x07, 0x06, 0x5d, 0x24, 0x4d,
-	0x9f, 0xad, 0x03, 0x14,
+	0x07, 0x1b, 0xfe, 0x5a, 0xf0, 0xfe, 0x82, 0x18, 0x24, 0xc3, 0xfe, 0x26,
+	0x10, 0x07, 0x1a, 0x5d, 0x24, 0x2c, 0xdc, 0x07, 0x0b, 0x5d, 0x24, 0x93,
+	0xfe, 0x0e, 0x10, 0x07, 0x06, 0x5d, 0x24, 0x4d, 0x9f, 0xad, 0x03, 0x14,
 	0xfe, 0x09, 0x00, 0x01, 0x33, 0xfe, 0x04, 0xfe, 0x7d, 0x05, 0x7f, 0xf9,
-	0x03, 0x25, 0xfe, 0xca,
-	0x18, 0xfe, 0x14, 0xf0, 0x08, 0x65, 0xfe, 0xc6, 0x18, 0x03, 0xff, 0x1a,
-	0x00, 0x00,
+	0x03, 0x25, 0xfe, 0xca, 0x18, 0xfe, 0x14, 0xf0, 0x08, 0x65, 0xfe, 0xc6,
+	0x18, 0x03, 0xff, 0x1a, 0x00, 0x00,
 };
 
 static unsigned short _adv_asc3550_size = sizeof(_adv_asc3550_buf);	/* 0x13AD */
@@ -10978,672 +10673,449 @@ static ADV_DCNT _adv_asc3550_chksum = 0x04D52DDDUL;	/* Expanded little-endian ch
 /* Microcode buffer is kept after initialization for error recovery. */
 static unsigned char _adv_asc38C0800_buf[] = {
 	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0xfc, 0x00, 0x16, 0x18, 0xe4,
-	0x01, 0x00, 0x48, 0xe4,
-	0x18, 0x80, 0x03, 0xf6, 0x02, 0x00, 0xce, 0x19, 0x00, 0xfa, 0xff, 0xff,
-	0x1c, 0x0f, 0x00, 0xf6,
-	0x9e, 0xe7, 0xff, 0x00, 0x82, 0xe7, 0x00, 0xea, 0x01, 0xfa, 0x01, 0xe6,
-	0x09, 0xe7, 0x55, 0xf0,
+	0x01, 0x00, 0x48, 0xe4, 0x18, 0x80, 0x03, 0xf6, 0x02, 0x00, 0xce, 0x19,
+	0x00, 0xfa, 0xff, 0xff, 0x1c, 0x0f, 0x00, 0xf6, 0x9e, 0xe7, 0xff, 0x00,
+	0x82, 0xe7, 0x00, 0xea, 0x01, 0xfa, 0x01, 0xe6, 0x09, 0xe7, 0x55, 0xf0,
 	0x01, 0xf6, 0x03, 0x00, 0x04, 0x00, 0x10, 0x00, 0x1e, 0xf0, 0x85, 0xf0,
-	0x18, 0xf4, 0x08, 0x00,
-	0xbc, 0x00, 0x38, 0x54, 0x00, 0xec, 0xd5, 0xf0, 0x82, 0x0d, 0x00, 0xe6,
-	0x86, 0xf0, 0xb1, 0xf0,
-	0x98, 0x57, 0x01, 0xfc, 0xb4, 0x00, 0xd4, 0x01, 0x0c, 0x1c, 0x3e, 0x1c,
-	0x3c, 0x00, 0xbb, 0x00,
+	0x18, 0xf4, 0x08, 0x00, 0xbc, 0x00, 0x38, 0x54, 0x00, 0xec, 0xd5, 0xf0,
+	0x82, 0x0d, 0x00, 0xe6, 0x86, 0xf0, 0xb1, 0xf0, 0x98, 0x57, 0x01, 0xfc,
+	0xb4, 0x00, 0xd4, 0x01, 0x0c, 0x1c, 0x3e, 0x1c, 0x3c, 0x00, 0xbb, 0x00,
 	0x00, 0x10, 0xba, 0x19, 0x02, 0x80, 0x32, 0xf0, 0x7c, 0x0d, 0x02, 0x13,
-	0xba, 0x13, 0x18, 0x40,
-	0x00, 0x57, 0x01, 0xea, 0x02, 0xfc, 0x03, 0xfc, 0x3e, 0x00, 0x6c, 0x01,
-	0x6e, 0x01, 0x74, 0x01,
-	0x76, 0x01, 0xb9, 0x54, 0x3e, 0x57, 0x00, 0x80, 0x03, 0xe6, 0xb6, 0x00,
-	0xc0, 0x00, 0x01, 0x01,
+	0xba, 0x13, 0x18, 0x40, 0x00, 0x57, 0x01, 0xea, 0x02, 0xfc, 0x03, 0xfc,
+	0x3e, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x74, 0x01, 0x76, 0x01, 0xb9, 0x54,
+	0x3e, 0x57, 0x00, 0x80, 0x03, 0xe6, 0xb6, 0x00, 0xc0, 0x00, 0x01, 0x01,
 	0x3e, 0x01, 0x7a, 0x01, 0xca, 0x08, 0xce, 0x10, 0x16, 0x11, 0x04, 0x12,
-	0x08, 0x12, 0x02, 0x4a,
-	0xbb, 0x55, 0x3c, 0x56, 0x03, 0x58, 0x1b, 0x80, 0x30, 0xe4, 0x4b, 0xe4,
-	0x5d, 0xf0, 0x02, 0xfa,
-	0x20, 0x00, 0x32, 0x00, 0x40, 0x00, 0x80, 0x00, 0x24, 0x01, 0x3c, 0x01,
-	0x68, 0x01, 0x6a, 0x01,
+	0x08, 0x12, 0x02, 0x4a, 0xbb, 0x55, 0x3c, 0x56, 0x03, 0x58, 0x1b, 0x80,
+	0x30, 0xe4, 0x4b, 0xe4, 0x5d, 0xf0, 0x02, 0xfa, 0x20, 0x00, 0x32, 0x00,
+	0x40, 0x00, 0x80, 0x00, 0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01,
 	0x70, 0x01, 0x72, 0x01, 0x78, 0x01, 0x7c, 0x01, 0x62, 0x0a, 0x86, 0x0d,
-	0x06, 0x13, 0x4c, 0x1c,
-	0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0, 0x03, 0xf7, 0x0c, 0x00,
-	0x0f, 0x00, 0x47, 0x00,
-	0xbe, 0x00, 0x00, 0x01, 0x20, 0x11, 0x5c, 0x16, 0x32, 0x1c, 0x38, 0x1c,
-	0x4e, 0x1c, 0x10, 0x44,
+	0x06, 0x13, 0x4c, 0x1c, 0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0,
+	0x03, 0xf7, 0x0c, 0x00, 0x0f, 0x00, 0x47, 0x00, 0xbe, 0x00, 0x00, 0x01,
+	0x20, 0x11, 0x5c, 0x16, 0x32, 0x1c, 0x38, 0x1c, 0x4e, 0x1c, 0x10, 0x44,
 	0x00, 0x4c, 0x04, 0xea, 0x5c, 0xf0, 0xa7, 0xf0, 0x04, 0xf6, 0x03, 0xfa,
-	0x05, 0x00, 0x34, 0x00,
-	0x36, 0x00, 0x98, 0x00, 0xcc, 0x00, 0x20, 0x01, 0x4e, 0x01, 0x4a, 0x0b,
-	0x42, 0x0c, 0x12, 0x0f,
-	0x0c, 0x10, 0x22, 0x11, 0x0a, 0x12, 0x04, 0x13, 0x30, 0x1c, 0x02, 0x48,
-	0x00, 0x4e, 0x42, 0x54,
+	0x05, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00, 0xcc, 0x00, 0x20, 0x01,
+	0x4e, 0x01, 0x4a, 0x0b, 0x42, 0x0c, 0x12, 0x0f, 0x0c, 0x10, 0x22, 0x11,
+	0x0a, 0x12, 0x04, 0x13, 0x30, 0x1c, 0x02, 0x48, 0x00, 0x4e, 0x42, 0x54,
 	0x44, 0x55, 0xbd, 0x56, 0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0,
-	0x59, 0xf0, 0xb8, 0xf0,
-	0x4b, 0xf4, 0x06, 0xf7, 0x0e, 0xf7, 0x04, 0xfc, 0x05, 0xfc, 0x06, 0x00,
-	0x19, 0x00, 0x33, 0x00,
-	0x9b, 0x00, 0xa4, 0x00, 0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00,
-	0xe7, 0x00, 0xe2, 0x03,
+	0x59, 0xf0, 0xb8, 0xf0, 0x4b, 0xf4, 0x06, 0xf7, 0x0e, 0xf7, 0x04, 0xfc,
+	0x05, 0xfc, 0x06, 0x00, 0x19, 0x00, 0x33, 0x00, 0x9b, 0x00, 0xa4, 0x00,
+	0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00, 0xe7, 0x00, 0xe2, 0x03,
 	0x08, 0x0f, 0x02, 0x10, 0x04, 0x10, 0x0a, 0x10, 0x0a, 0x13, 0x0c, 0x13,
-	0x12, 0x13, 0x24, 0x14,
-	0x34, 0x14, 0x04, 0x16, 0x08, 0x16, 0xa4, 0x17, 0x20, 0x1c, 0x34, 0x1c,
-	0x36, 0x1c, 0x08, 0x44,
-	0x38, 0x44, 0x91, 0x44, 0x0a, 0x45, 0x48, 0x46, 0x01, 0x48, 0x68, 0x54,
-	0x3a, 0x55, 0x83, 0x55,
+	0x12, 0x13, 0x24, 0x14, 0x34, 0x14, 0x04, 0x16, 0x08, 0x16, 0xa4, 0x17,
+	0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c, 0x08, 0x44, 0x38, 0x44, 0x91, 0x44,
+	0x0a, 0x45, 0x48, 0x46, 0x01, 0x48, 0x68, 0x54, 0x3a, 0x55, 0x83, 0x55,
 	0xe5, 0x55, 0xb0, 0x57, 0x01, 0x58, 0x83, 0x59, 0x05, 0xe6, 0x0b, 0xf0,
-	0x0c, 0xf0, 0x04, 0xf8,
-	0x05, 0xf8, 0x07, 0x00, 0x0a, 0x00, 0x1c, 0x00, 0x1e, 0x00, 0x9e, 0x00,
-	0xa8, 0x00, 0xaa, 0x00,
-	0xb9, 0x00, 0xe0, 0x00, 0x22, 0x01, 0x26, 0x01, 0x79, 0x01, 0x7e, 0x01,
-	0xc4, 0x01, 0xc6, 0x01,
+	0x0c, 0xf0, 0x04, 0xf8, 0x05, 0xf8, 0x07, 0x00, 0x0a, 0x00, 0x1c, 0x00,
+	0x1e, 0x00, 0x9e, 0x00, 0xa8, 0x00, 0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00,
+	0x22, 0x01, 0x26, 0x01, 0x79, 0x01, 0x7e, 0x01, 0xc4, 0x01, 0xc6, 0x01,
 	0x80, 0x02, 0x5e, 0x03, 0xee, 0x04, 0x9a, 0x06, 0xf8, 0x07, 0x62, 0x08,
-	0x68, 0x08, 0x69, 0x08,
-	0xd6, 0x08, 0xe9, 0x09, 0xfa, 0x0b, 0x2e, 0x0f, 0x12, 0x10, 0x1a, 0x10,
-	0xed, 0x10, 0xf1, 0x10,
-	0x2a, 0x11, 0x06, 0x12, 0x0c, 0x12, 0x3e, 0x12, 0x10, 0x13, 0x16, 0x13,
-	0x1e, 0x13, 0x46, 0x14,
+	0x68, 0x08, 0x69, 0x08, 0xd6, 0x08, 0xe9, 0x09, 0xfa, 0x0b, 0x2e, 0x0f,
+	0x12, 0x10, 0x1a, 0x10, 0xed, 0x10, 0xf1, 0x10, 0x2a, 0x11, 0x06, 0x12,
+	0x0c, 0x12, 0x3e, 0x12, 0x10, 0x13, 0x16, 0x13, 0x1e, 0x13, 0x46, 0x14,
 	0x76, 0x14, 0x82, 0x14, 0x36, 0x15, 0xca, 0x15, 0x6b, 0x18, 0xbe, 0x18,
-	0xca, 0x18, 0xe6, 0x19,
-	0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40, 0x0e, 0x47, 0xfe, 0x9c,
-	0xf0, 0x2b, 0x02, 0xfe,
-	0xac, 0x0d, 0xff, 0x10, 0x00, 0x00, 0xd7, 0xfe, 0xe8, 0x19, 0x00, 0xd6,
-	0xfe, 0x84, 0x01, 0xff,
+	0xca, 0x18, 0xe6, 0x19, 0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40,
+	0x0e, 0x47, 0xfe, 0x9c, 0xf0, 0x2b, 0x02, 0xfe, 0xac, 0x0d, 0xff, 0x10,
+	0x00, 0x00, 0xd7, 0xfe, 0xe8, 0x19, 0x00, 0xd6, 0xfe, 0x84, 0x01, 0xff,
 	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
-	0x00, 0xfe, 0x57, 0x24,
-	0x00, 0xfe, 0x4c, 0x00, 0x5b, 0xff, 0x04, 0x00, 0x00, 0x11, 0xff, 0x09,
-	0x00, 0x00, 0xff, 0x08,
-	0x01, 0x01, 0xff, 0x08, 0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10,
-	0xff, 0xff, 0xff, 0x11,
+	0x00, 0xfe, 0x57, 0x24, 0x00, 0xfe, 0x4c, 0x00, 0x5b, 0xff, 0x04, 0x00,
+	0x00, 0x11, 0xff, 0x09, 0x00, 0x00, 0xff, 0x08, 0x01, 0x01, 0xff, 0x08,
+	0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10, 0xff, 0xff, 0xff, 0x11,
 	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
-	0xfe, 0x04, 0xf7, 0xd6,
-	0x2c, 0x99, 0x0a, 0x01, 0xfe, 0xc2, 0x0f, 0xfe, 0x04, 0xf7, 0xd6, 0x99,
-	0x0a, 0x42, 0x2c, 0xfe,
-	0x3d, 0xf0, 0xfe, 0x06, 0x02, 0xfe, 0x20, 0xf0, 0xa7, 0xfe, 0x91, 0xf0,
-	0xfe, 0xf4, 0x01, 0xfe,
+	0xfe, 0x04, 0xf7, 0xd6, 0x2c, 0x99, 0x0a, 0x01, 0xfe, 0xc2, 0x0f, 0xfe,
+	0x04, 0xf7, 0xd6, 0x99, 0x0a, 0x42, 0x2c, 0xfe, 0x3d, 0xf0, 0xfe, 0x06,
+	0x02, 0xfe, 0x20, 0xf0, 0xa7, 0xfe, 0x91, 0xf0, 0xfe, 0xf4, 0x01, 0xfe,
 	0x90, 0xf0, 0xfe, 0xf4, 0x01, 0xfe, 0x8f, 0xf0, 0xa7, 0x03, 0x5d, 0x4d,
-	0x02, 0xfe, 0xc8, 0x0d,
-	0x01, 0xfe, 0x38, 0x0e, 0xfe, 0xdd, 0x12, 0xfe, 0xfc, 0x10, 0xfe, 0x28,
-	0x1c, 0x03, 0xfe, 0xa6,
-	0x00, 0xfe, 0xd3, 0x12, 0x41, 0x14, 0xfe, 0xa6, 0x00, 0xc2, 0xfe, 0x48,
-	0xf0, 0xfe, 0x8a, 0x02,
+	0x02, 0xfe, 0xc8, 0x0d, 0x01, 0xfe, 0x38, 0x0e, 0xfe, 0xdd, 0x12, 0xfe,
+	0xfc, 0x10, 0xfe, 0x28, 0x1c, 0x03, 0xfe, 0xa6, 0x00, 0xfe, 0xd3, 0x12,
+	0x41, 0x14, 0xfe, 0xa6, 0x00, 0xc2, 0xfe, 0x48, 0xf0, 0xfe, 0x8a, 0x02,
 	0xfe, 0x49, 0xf0, 0xfe, 0xa4, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xc2, 0x02,
-	0xfe, 0x46, 0xf0, 0xfe,
-	0x54, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x5a, 0x02, 0xfe, 0x43, 0xf0, 0xfe,
-	0x48, 0x02, 0xfe, 0x44,
-	0xf0, 0xfe, 0x4c, 0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x50, 0x02, 0x18, 0x0a,
-	0xaa, 0x18, 0x06, 0x14,
+	0xfe, 0x46, 0xf0, 0xfe, 0x54, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x5a, 0x02,
+	0xfe, 0x43, 0xf0, 0xfe, 0x48, 0x02, 0xfe, 0x44, 0xf0, 0xfe, 0x4c, 0x02,
+	0xfe, 0x45, 0xf0, 0xfe, 0x50, 0x02, 0x18, 0x0a, 0xaa, 0x18, 0x06, 0x14,
 	0xa1, 0x02, 0x2b, 0xfe, 0x00, 0x1c, 0xe7, 0xfe, 0x02, 0x1c, 0xe6, 0xfe,
-	0x1e, 0x1c, 0xfe, 0xe9,
-	0x10, 0x01, 0xfe, 0x18, 0x18, 0xfe, 0xe7, 0x10, 0xfe, 0x06, 0xfc, 0xce,
-	0x09, 0x70, 0x01, 0xa8,
-	0x02, 0x2b, 0x15, 0x59, 0x39, 0xa2, 0x01, 0xfe, 0x58, 0x10, 0x09, 0x70,
-	0x01, 0x87, 0xfe, 0xbd,
+	0x1e, 0x1c, 0xfe, 0xe9, 0x10, 0x01, 0xfe, 0x18, 0x18, 0xfe, 0xe7, 0x10,
+	0xfe, 0x06, 0xfc, 0xce, 0x09, 0x70, 0x01, 0xa8, 0x02, 0x2b, 0x15, 0x59,
+	0x39, 0xa2, 0x01, 0xfe, 0x58, 0x10, 0x09, 0x70, 0x01, 0x87, 0xfe, 0xbd,
 	0x10, 0x09, 0x70, 0x01, 0x87, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c, 0xfe,
-	0x58, 0x1c, 0x18, 0x06,
-	0x14, 0xa1, 0x2c, 0x1c, 0x2b, 0xfe, 0x3d, 0xf0, 0xfe, 0x06, 0x02, 0x23,
-	0xfe, 0x98, 0x02, 0xfe,
-	0x5a, 0x1c, 0xf8, 0xfe, 0x14, 0x1c, 0x15, 0xfe, 0x30, 0x00, 0x39, 0xa2,
-	0x01, 0xfe, 0x48, 0x10,
+	0x58, 0x1c, 0x18, 0x06, 0x14, 0xa1, 0x2c, 0x1c, 0x2b, 0xfe, 0x3d, 0xf0,
+	0xfe, 0x06, 0x02, 0x23, 0xfe, 0x98, 0x02, 0xfe, 0x5a, 0x1c, 0xf8, 0xfe,
+	0x14, 0x1c, 0x15, 0xfe, 0x30, 0x00, 0x39, 0xa2, 0x01, 0xfe, 0x48, 0x10,
 	0x18, 0x06, 0x14, 0xa1, 0x02, 0xd7, 0x22, 0x20, 0x07, 0x11, 0x35, 0xfe,
-	0x69, 0x10, 0x18, 0x06,
-	0x14, 0xa1, 0xfe, 0x04, 0xec, 0x20, 0x4f, 0x43, 0x13, 0x20, 0xfe, 0x05,
-	0xf6, 0xce, 0x01, 0xfe,
-	0x4a, 0x17, 0x08, 0x54, 0x58, 0x37, 0x12, 0x2f, 0x42, 0x92, 0x01, 0xfe,
-	0x82, 0x16, 0x02, 0x2b,
+	0x69, 0x10, 0x18, 0x06, 0x14, 0xa1, 0xfe, 0x04, 0xec, 0x20, 0x4f, 0x43,
+	0x13, 0x20, 0xfe, 0x05, 0xf6, 0xce, 0x01, 0xfe, 0x4a, 0x17, 0x08, 0x54,
+	0x58, 0x37, 0x12, 0x2f, 0x42, 0x92, 0x01, 0xfe, 0x82, 0x16, 0x02, 0x2b,
 	0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x66, 0x01, 0x73, 0xfe, 0x18, 0x10,
-	0xfe, 0x41, 0x58, 0x09,
-	0xa4, 0x01, 0x0e, 0xfe, 0xc8, 0x54, 0x6b, 0xfe, 0x10, 0x03, 0x01, 0xfe,
-	0x82, 0x16, 0x02, 0x2b,
-	0x2c, 0x4f, 0xfe, 0x02, 0xe8, 0x2a, 0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43,
-	0xfe, 0x77, 0x57, 0xfe,
+	0xfe, 0x41, 0x58, 0x09, 0xa4, 0x01, 0x0e, 0xfe, 0xc8, 0x54, 0x6b, 0xfe,
+	0x10, 0x03, 0x01, 0xfe, 0x82, 0x16, 0x02, 0x2b, 0x2c, 0x4f, 0xfe, 0x02,
+	0xe8, 0x2a, 0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43, 0xfe, 0x77, 0x57, 0xfe,
 	0x27, 0xf0, 0xfe, 0xe0, 0x01, 0xfe, 0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xa7,
-	0xfe, 0x40, 0x1c, 0x1c,
-	0xd9, 0xfe, 0x26, 0xf0, 0xfe, 0x5a, 0x03, 0xfe, 0xa0, 0xf0, 0xfe, 0x48,
-	0x03, 0xfe, 0x11, 0xf0,
-	0xa7, 0xfe, 0xef, 0x10, 0xfe, 0x9f, 0xf0, 0xfe, 0x68, 0x03, 0xf9, 0x10,
-	0xfe, 0x11, 0x00, 0x02,
+	0xfe, 0x40, 0x1c, 0x1c, 0xd9, 0xfe, 0x26, 0xf0, 0xfe, 0x5a, 0x03, 0xfe,
+	0xa0, 0xf0, 0xfe, 0x48, 0x03, 0xfe, 0x11, 0xf0, 0xa7, 0xfe, 0xef, 0x10,
+	0xfe, 0x9f, 0xf0, 0xfe, 0x68, 0x03, 0xf9, 0x10, 0xfe, 0x11, 0x00, 0x02,
 	0x65, 0x2c, 0xfe, 0x48, 0x1c, 0xf9, 0x08, 0x05, 0x1b, 0xfe, 0x18, 0x13,
-	0x21, 0x22, 0xa3, 0xb7,
-	0x13, 0xa3, 0x09, 0x46, 0x01, 0x0e, 0xb7, 0x78, 0x01, 0xfe, 0xb4, 0x16,
-	0x12, 0xd1, 0x1c, 0xd9,
-	0xfe, 0x01, 0xf0, 0xd9, 0xfe, 0x82, 0xf0, 0xfe, 0x96, 0x03, 0xfa, 0x12,
-	0xfe, 0xe4, 0x00, 0x27,
+	0x21, 0x22, 0xa3, 0xb7, 0x13, 0xa3, 0x09, 0x46, 0x01, 0x0e, 0xb7, 0x78,
+	0x01, 0xfe, 0xb4, 0x16, 0x12, 0xd1, 0x1c, 0xd9, 0xfe, 0x01, 0xf0, 0xd9,
+	0xfe, 0x82, 0xf0, 0xfe, 0x96, 0x03, 0xfa, 0x12, 0xfe, 0xe4, 0x00, 0x27,
 	0xfe, 0xa8, 0x03, 0x1c, 0x34, 0x1d, 0xfe, 0xb8, 0x03, 0x01, 0x4b, 0xfe,
-	0x06, 0xf0, 0xfe, 0xc8,
-	0x03, 0x95, 0x86, 0xfe, 0x0a, 0xf0, 0xfe, 0x8a, 0x06, 0x02, 0x24, 0x03,
-	0x70, 0x28, 0x17, 0xfe,
-	0xfa, 0x04, 0x15, 0x6d, 0x01, 0x36, 0x7b, 0xfe, 0x6a, 0x02, 0x02, 0xd8,
-	0xf9, 0x2c, 0x99, 0x19,
+	0x06, 0xf0, 0xfe, 0xc8, 0x03, 0x95, 0x86, 0xfe, 0x0a, 0xf0, 0xfe, 0x8a,
+	0x06, 0x02, 0x24, 0x03, 0x70, 0x28, 0x17, 0xfe, 0xfa, 0x04, 0x15, 0x6d,
+	0x01, 0x36, 0x7b, 0xfe, 0x6a, 0x02, 0x02, 0xd8, 0xf9, 0x2c, 0x99, 0x19,
 	0xfe, 0x67, 0x1b, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57, 0xfe, 0x48, 0x1c,
-	0x74, 0x01, 0xaf, 0x8c,
-	0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x17, 0xda, 0x09, 0xd1, 0x01, 0x0e,
-	0x8d, 0x51, 0x64, 0x79,
-	0x2a, 0x03, 0x70, 0x28, 0xfe, 0x10, 0x12, 0x15, 0x6d, 0x01, 0x36, 0x7b,
-	0xfe, 0x6a, 0x02, 0x02,
+	0x74, 0x01, 0xaf, 0x8c, 0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x17, 0xda,
+	0x09, 0xd1, 0x01, 0x0e, 0x8d, 0x51, 0x64, 0x79, 0x2a, 0x03, 0x70, 0x28,
+	0xfe, 0x10, 0x12, 0x15, 0x6d, 0x01, 0x36, 0x7b, 0xfe, 0x6a, 0x02, 0x02,
 	0xd8, 0xc7, 0x81, 0xc8, 0x83, 0x1c, 0x24, 0x27, 0xfe, 0x40, 0x04, 0x1d,
-	0xfe, 0x3c, 0x04, 0x3b,
-	0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e, 0x12, 0x2d, 0xff, 0x02,
-	0x00, 0x10, 0x01, 0x0b,
-	0x1d, 0xfe, 0xe4, 0x04, 0x2d, 0x01, 0x0b, 0x1d, 0x24, 0x33, 0x31, 0xde,
-	0xfe, 0x4c, 0x44, 0xfe,
+	0xfe, 0x3c, 0x04, 0x3b, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e,
+	0x12, 0x2d, 0xff, 0x02, 0x00, 0x10, 0x01, 0x0b, 0x1d, 0xfe, 0xe4, 0x04,
+	0x2d, 0x01, 0x0b, 0x1d, 0x24, 0x33, 0x31, 0xde, 0xfe, 0x4c, 0x44, 0xfe,
 	0x4c, 0x12, 0x51, 0xfe, 0x44, 0x48, 0x0f, 0x6f, 0xfe, 0x4c, 0x54, 0x6b,
-	0xda, 0x4f, 0x79, 0x2a,
-	0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x62, 0x13, 0x08, 0x05, 0x1b,
-	0xfe, 0x2a, 0x13, 0x32,
-	0x07, 0x82, 0xfe, 0x52, 0x13, 0xfe, 0x20, 0x10, 0x0f, 0x6f, 0xfe, 0x4c,
-	0x54, 0x6b, 0xda, 0xfe,
+	0xda, 0x4f, 0x79, 0x2a, 0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x62,
+	0x13, 0x08, 0x05, 0x1b, 0xfe, 0x2a, 0x13, 0x32, 0x07, 0x82, 0xfe, 0x52,
+	0x13, 0xfe, 0x20, 0x10, 0x0f, 0x6f, 0xfe, 0x4c, 0x54, 0x6b, 0xda, 0xfe,
 	0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x40, 0x13, 0x08, 0x05, 0x1b, 0xfe,
-	0x08, 0x13, 0x32, 0x07,
-	0x82, 0xfe, 0x30, 0x13, 0x08, 0x05, 0x1b, 0xfe, 0x1c, 0x12, 0x15, 0x9d,
-	0x08, 0x05, 0x06, 0x4d,
-	0x15, 0xfe, 0x0d, 0x00, 0x01, 0x36, 0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24,
-	0x2d, 0x12, 0xfe, 0xe6,
+	0x08, 0x13, 0x32, 0x07, 0x82, 0xfe, 0x30, 0x13, 0x08, 0x05, 0x1b, 0xfe,
+	0x1c, 0x12, 0x15, 0x9d, 0x08, 0x05, 0x06, 0x4d, 0x15, 0xfe, 0x0d, 0x00,
+	0x01, 0x36, 0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24, 0x2d, 0x12, 0xfe, 0xe6,
 	0x00, 0xfe, 0x1c, 0x90, 0xfe, 0x40, 0x5c, 0x04, 0x15, 0x9d, 0x01, 0x36,
-	0x02, 0x2b, 0xfe, 0x42,
-	0x5b, 0x99, 0x19, 0xfe, 0x46, 0x59, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57,
-	0xfe, 0x87, 0x80, 0xfe,
-	0x31, 0xe4, 0x5b, 0x08, 0x05, 0x0a, 0xfe, 0x84, 0x13, 0xfe, 0x20, 0x80,
-	0x07, 0x19, 0xfe, 0x7c,
+	0x02, 0x2b, 0xfe, 0x42, 0x5b, 0x99, 0x19, 0xfe, 0x46, 0x59, 0xfe, 0xbf,
+	0x57, 0xfe, 0x77, 0x57, 0xfe, 0x87, 0x80, 0xfe, 0x31, 0xe4, 0x5b, 0x08,
+	0x05, 0x0a, 0xfe, 0x84, 0x13, 0xfe, 0x20, 0x80, 0x07, 0x19, 0xfe, 0x7c,
 	0x12, 0x53, 0x05, 0x06, 0xfe, 0x6c, 0x13, 0x03, 0xfe, 0xa2, 0x00, 0x28,
-	0x17, 0xfe, 0x90, 0x05,
-	0xfe, 0x31, 0xe4, 0x5a, 0x53, 0x05, 0x0a, 0xfe, 0x56, 0x13, 0x03, 0xfe,
-	0xa0, 0x00, 0x28, 0xfe,
-	0x4e, 0x12, 0x67, 0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x48, 0x05, 0x1c,
-	0x34, 0xfe, 0x89, 0x48,
+	0x17, 0xfe, 0x90, 0x05, 0xfe, 0x31, 0xe4, 0x5a, 0x53, 0x05, 0x0a, 0xfe,
+	0x56, 0x13, 0x03, 0xfe, 0xa0, 0x00, 0x28, 0xfe, 0x4e, 0x12, 0x67, 0xff,
+	0x02, 0x00, 0x10, 0x27, 0xfe, 0x48, 0x05, 0x1c, 0x34, 0xfe, 0x89, 0x48,
 	0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x56, 0x05, 0x26, 0xfe, 0xa8, 0x05,
-	0x12, 0xfe, 0xe3, 0x00,
-	0x21, 0x53, 0xfe, 0x4a, 0xf0, 0xfe, 0x76, 0x05, 0xfe, 0x49, 0xf0, 0xfe,
-	0x70, 0x05, 0x88, 0x25,
-	0xfe, 0x21, 0x00, 0xab, 0x25, 0xfe, 0x22, 0x00, 0xaa, 0x25, 0x58, 0xfe,
-	0x09, 0x48, 0xff, 0x02,
+	0x12, 0xfe, 0xe3, 0x00, 0x21, 0x53, 0xfe, 0x4a, 0xf0, 0xfe, 0x76, 0x05,
+	0xfe, 0x49, 0xf0, 0xfe, 0x70, 0x05, 0x88, 0x25, 0xfe, 0x21, 0x00, 0xab,
+	0x25, 0xfe, 0x22, 0x00, 0xaa, 0x25, 0x58, 0xfe, 0x09, 0x48, 0xff, 0x02,
 	0x00, 0x10, 0x27, 0xfe, 0x86, 0x05, 0x26, 0xfe, 0xa8, 0x05, 0xfe, 0xe2,
-	0x08, 0x53, 0x05, 0xcb,
-	0x4d, 0x01, 0xb0, 0x25, 0x06, 0x13, 0xd3, 0x39, 0xfe, 0x27, 0x01, 0x08,
-	0x05, 0x1b, 0xfe, 0x22,
-	0x12, 0x41, 0x01, 0xb2, 0x15, 0x9d, 0x08, 0x05, 0x06, 0x4d, 0x15, 0xfe,
-	0x0d, 0x00, 0x01, 0x36,
+	0x08, 0x53, 0x05, 0xcb, 0x4d, 0x01, 0xb0, 0x25, 0x06, 0x13, 0xd3, 0x39,
+	0xfe, 0x27, 0x01, 0x08, 0x05, 0x1b, 0xfe, 0x22, 0x12, 0x41, 0x01, 0xb2,
+	0x15, 0x9d, 0x08, 0x05, 0x06, 0x4d, 0x15, 0xfe, 0x0d, 0x00, 0x01, 0x36,
 	0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24, 0x03, 0xfe, 0x9c, 0x00, 0x28, 0xeb,
-	0x03, 0x5c, 0x28, 0xfe,
-	0x36, 0x13, 0x41, 0x01, 0xb2, 0x26, 0xfe, 0x18, 0x06, 0x09, 0x06, 0x53,
-	0x05, 0x1f, 0xfe, 0x02,
-	0x12, 0x50, 0x01, 0xfe, 0x9e, 0x15, 0x1d, 0xfe, 0x0e, 0x06, 0x12, 0xa5,
-	0x01, 0x4b, 0x12, 0xfe,
+	0x03, 0x5c, 0x28, 0xfe, 0x36, 0x13, 0x41, 0x01, 0xb2, 0x26, 0xfe, 0x18,
+	0x06, 0x09, 0x06, 0x53, 0x05, 0x1f, 0xfe, 0x02, 0x12, 0x50, 0x01, 0xfe,
+	0x9e, 0x15, 0x1d, 0xfe, 0x0e, 0x06, 0x12, 0xa5, 0x01, 0x4b, 0x12, 0xfe,
 	0xe5, 0x00, 0x03, 0x5c, 0xc1, 0x0c, 0x5c, 0x03, 0xcd, 0x28, 0xfe, 0x62,
-	0x12, 0x03, 0x45, 0x28,
-	0xfe, 0x5a, 0x13, 0x01, 0xfe, 0x0c, 0x19, 0x01, 0xfe, 0x76, 0x19, 0xfe,
-	0x43, 0x48, 0xc4, 0xcc,
-	0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0x8b, 0xc4,
-	0x6e, 0x41, 0x01, 0xb2,
+	0x12, 0x03, 0x45, 0x28, 0xfe, 0x5a, 0x13, 0x01, 0xfe, 0x0c, 0x19, 0x01,
+	0xfe, 0x76, 0x19, 0xfe, 0x43, 0x48, 0xc4, 0xcc, 0x0f, 0x71, 0xff, 0x02,
+	0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0x8b, 0xc4, 0x6e, 0x41, 0x01, 0xb2,
 	0x26, 0xfe, 0x82, 0x06, 0x53, 0x05, 0x1a, 0xe9, 0x91, 0x09, 0x59, 0x01,
-	0xfe, 0xcc, 0x15, 0x1d,
-	0xfe, 0x78, 0x06, 0x12, 0xa5, 0x01, 0x4b, 0x12, 0xfe, 0xe5, 0x00, 0x03,
-	0x45, 0xc1, 0x0c, 0x45,
-	0x18, 0x06, 0x01, 0xb2, 0xfa, 0x76, 0x74, 0x01, 0xaf, 0x8c, 0x12, 0xfe,
-	0xe2, 0x00, 0x27, 0xdb,
+	0xfe, 0xcc, 0x15, 0x1d, 0xfe, 0x78, 0x06, 0x12, 0xa5, 0x01, 0x4b, 0x12,
+	0xfe, 0xe5, 0x00, 0x03, 0x45, 0xc1, 0x0c, 0x45, 0x18, 0x06, 0x01, 0xb2,
+	0xfa, 0x76, 0x74, 0x01, 0xaf, 0x8c, 0x12, 0xfe, 0xe2, 0x00, 0x27, 0xdb,
 	0x1c, 0x34, 0xfe, 0x0a, 0xf0, 0xfe, 0xb6, 0x06, 0x94, 0xfe, 0x6c, 0x07,
-	0xfe, 0x06, 0xf0, 0xfe,
-	0x74, 0x07, 0x95, 0x86, 0x02, 0x24, 0x08, 0x05, 0x0a, 0xfe, 0x2e, 0x12,
-	0x16, 0x19, 0x01, 0x0b,
-	0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b,
-	0xfe, 0x99, 0xa4, 0x01,
+	0xfe, 0x06, 0xf0, 0xfe, 0x74, 0x07, 0x95, 0x86, 0x02, 0x24, 0x08, 0x05,
+	0x0a, 0xfe, 0x2e, 0x12, 0x16, 0x19, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b,
+	0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b, 0xfe, 0x99, 0xa4, 0x01,
 	0x0b, 0x16, 0x00, 0x02, 0xfe, 0x42, 0x08, 0x68, 0x05, 0x1a, 0xfe, 0x38,
-	0x12, 0x08, 0x05, 0x1a,
-	0xfe, 0x30, 0x13, 0x16, 0xfe, 0x1b, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01,
-	0x0b, 0x16, 0x00, 0x01,
-	0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x06, 0x01, 0x0b, 0x16, 0x00, 0x02,
-	0xe2, 0x6c, 0x58, 0xbe,
+	0x12, 0x08, 0x05, 0x1a, 0xfe, 0x30, 0x13, 0x16, 0xfe, 0x1b, 0x00, 0x01,
+	0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01,
+	0x0b, 0x16, 0x06, 0x01, 0x0b, 0x16, 0x00, 0x02, 0xe2, 0x6c, 0x58, 0xbe,
 	0x50, 0xfe, 0x9a, 0x81, 0x55, 0x1b, 0x7a, 0xfe, 0x42, 0x07, 0x09, 0x1b,
-	0xfe, 0x09, 0x6f, 0xba,
-	0xfe, 0xca, 0x45, 0xfe, 0x32, 0x12, 0x69, 0x6d, 0x8b, 0x6c, 0x7f, 0x27,
-	0xfe, 0x54, 0x07, 0x1c,
-	0x34, 0xfe, 0x0a, 0xf0, 0xfe, 0x42, 0x07, 0x95, 0x86, 0x94, 0xfe, 0x6c,
-	0x07, 0x02, 0x24, 0x01,
+	0xfe, 0x09, 0x6f, 0xba, 0xfe, 0xca, 0x45, 0xfe, 0x32, 0x12, 0x69, 0x6d,
+	0x8b, 0x6c, 0x7f, 0x27, 0xfe, 0x54, 0x07, 0x1c, 0x34, 0xfe, 0x0a, 0xf0,
+	0xfe, 0x42, 0x07, 0x95, 0x86, 0x94, 0xfe, 0x6c, 0x07, 0x02, 0x24, 0x01,
 	0x4b, 0x02, 0xdb, 0x16, 0x1f, 0x02, 0xdb, 0xfe, 0x9c, 0xf7, 0xdc, 0xfe,
-	0x2c, 0x90, 0xfe, 0xae,
-	0x90, 0x56, 0xfe, 0xda, 0x07, 0x0c, 0x60, 0x14, 0x61, 0x08, 0x54, 0x5a,
-	0x37, 0x22, 0x20, 0x07,
-	0x11, 0xfe, 0x0e, 0x12, 0x8d, 0xfe, 0x80, 0x80, 0x39, 0x20, 0x6a, 0x2a,
-	0xfe, 0x06, 0x10, 0xfe,
+	0x2c, 0x90, 0xfe, 0xae, 0x90, 0x56, 0xfe, 0xda, 0x07, 0x0c, 0x60, 0x14,
+	0x61, 0x08, 0x54, 0x5a, 0x37, 0x22, 0x20, 0x07, 0x11, 0xfe, 0x0e, 0x12,
+	0x8d, 0xfe, 0x80, 0x80, 0x39, 0x20, 0x6a, 0x2a, 0xfe, 0x06, 0x10, 0xfe,
 	0x83, 0xe7, 0xfe, 0x48, 0x00, 0xab, 0xfe, 0x03, 0x40, 0x08, 0x54, 0x5b,
-	0x37, 0x01, 0xb3, 0xb8,
-	0xfe, 0x1f, 0x40, 0x13, 0x62, 0x01, 0xef, 0xfe, 0x08, 0x50, 0xfe, 0x8a,
-	0x50, 0xfe, 0x44, 0x51,
-	0xfe, 0xc6, 0x51, 0x88, 0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90, 0x0c, 0x5e,
-	0x14, 0x5f, 0xfe, 0x0c,
+	0x37, 0x01, 0xb3, 0xb8, 0xfe, 0x1f, 0x40, 0x13, 0x62, 0x01, 0xef, 0xfe,
+	0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe, 0x44, 0x51, 0xfe, 0xc6, 0x51, 0x88,
+	0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90, 0x0c, 0x5e, 0x14, 0x5f, 0xfe, 0x0c,
 	0x90, 0xfe, 0x8e, 0x90, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x0c, 0x3d,
-	0x14, 0x3e, 0xfe, 0x4a,
-	0x10, 0x08, 0x05, 0x5a, 0xfe, 0x2a, 0x12, 0xfe, 0x2c, 0x90, 0xfe, 0xae,
-	0x90, 0x0c, 0x60, 0x14,
-	0x61, 0x08, 0x05, 0x5b, 0x8b, 0x01, 0xb3, 0xfe, 0x1f, 0x80, 0x13, 0x62,
-	0xfe, 0x44, 0x90, 0xfe,
+	0x14, 0x3e, 0xfe, 0x4a, 0x10, 0x08, 0x05, 0x5a, 0xfe, 0x2a, 0x12, 0xfe,
+	0x2c, 0x90, 0xfe, 0xae, 0x90, 0x0c, 0x60, 0x14, 0x61, 0x08, 0x05, 0x5b,
+	0x8b, 0x01, 0xb3, 0xfe, 0x1f, 0x80, 0x13, 0x62, 0xfe, 0x44, 0x90, 0xfe,
 	0xc6, 0x90, 0x0c, 0x3f, 0x14, 0x40, 0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90,
-	0x0c, 0x5e, 0x14, 0x5f,
-	0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90, 0x0c, 0x3d, 0x14, 0x3e, 0x0c, 0x2e,
-	0x14, 0x3c, 0x21, 0x0c,
-	0x49, 0x0c, 0x63, 0x08, 0x54, 0x1f, 0x37, 0x2c, 0x0f, 0xfe, 0x4e, 0x11,
-	0x27, 0xdd, 0xfe, 0x9e,
+	0x0c, 0x5e, 0x14, 0x5f, 0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90, 0x0c, 0x3d,
+	0x14, 0x3e, 0x0c, 0x2e, 0x14, 0x3c, 0x21, 0x0c, 0x49, 0x0c, 0x63, 0x08,
+	0x54, 0x1f, 0x37, 0x2c, 0x0f, 0xfe, 0x4e, 0x11, 0x27, 0xdd, 0xfe, 0x9e,
 	0xf0, 0xfe, 0x76, 0x08, 0xbc, 0x17, 0x34, 0x2c, 0x77, 0xe6, 0xc5, 0xfe,
-	0x9a, 0x08, 0xc6, 0xfe,
-	0xb8, 0x08, 0x94, 0xfe, 0x8e, 0x08, 0xfe, 0x06, 0xf0, 0xfe, 0x94, 0x08,
-	0x95, 0x86, 0x02, 0x24,
-	0x01, 0x4b, 0xfe, 0xc9, 0x10, 0x16, 0x1f, 0xfe, 0xc9, 0x10, 0x68, 0x05,
-	0x06, 0xfe, 0x10, 0x12,
+	0x9a, 0x08, 0xc6, 0xfe, 0xb8, 0x08, 0x94, 0xfe, 0x8e, 0x08, 0xfe, 0x06,
+	0xf0, 0xfe, 0x94, 0x08, 0x95, 0x86, 0x02, 0x24, 0x01, 0x4b, 0xfe, 0xc9,
+	0x10, 0x16, 0x1f, 0xfe, 0xc9, 0x10, 0x68, 0x05, 0x06, 0xfe, 0x10, 0x12,
 	0x68, 0x05, 0x0a, 0x4e, 0x08, 0x05, 0x0a, 0xfe, 0x90, 0x12, 0xfe, 0x2e,
-	0x1c, 0x02, 0xfe, 0x18,
-	0x0b, 0x68, 0x05, 0x06, 0x4e, 0x68, 0x05, 0x0a, 0xfe, 0x7a, 0x12, 0xfe,
-	0x2c, 0x1c, 0xfe, 0xaa,
-	0xf0, 0xfe, 0xd2, 0x09, 0xfe, 0xac, 0xf0, 0xfe, 0x00, 0x09, 0x02, 0xfe,
-	0xde, 0x09, 0xfe, 0xb7,
+	0x1c, 0x02, 0xfe, 0x18, 0x0b, 0x68, 0x05, 0x06, 0x4e, 0x68, 0x05, 0x0a,
+	0xfe, 0x7a, 0x12, 0xfe, 0x2c, 0x1c, 0xfe, 0xaa, 0xf0, 0xfe, 0xd2, 0x09,
+	0xfe, 0xac, 0xf0, 0xfe, 0x00, 0x09, 0x02, 0xfe, 0xde, 0x09, 0xfe, 0xb7,
 	0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0x02, 0xf6, 0x1a, 0x50, 0xfe, 0x70, 0x18,
-	0xfe, 0xf1, 0x18, 0xfe,
-	0x40, 0x55, 0xfe, 0xe1, 0x55, 0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58, 0xfe,
-	0x14, 0x59, 0xfe, 0x95,
-	0x59, 0x1c, 0x85, 0xfe, 0x8c, 0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0xac, 0xf0,
-	0xfe, 0xf0, 0x08, 0xb5,
+	0xfe, 0xf1, 0x18, 0xfe, 0x40, 0x55, 0xfe, 0xe1, 0x55, 0xfe, 0x10, 0x58,
+	0xfe, 0x91, 0x58, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x1c, 0x85, 0xfe,
+	0x8c, 0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0xac, 0xf0, 0xfe, 0xf0, 0x08, 0xb5,
 	0xfe, 0xcb, 0x10, 0xfe, 0xad, 0xf0, 0xfe, 0x0c, 0x09, 0x02, 0xfe, 0x18,
-	0x0b, 0xb6, 0xfe, 0xbf,
-	0x10, 0xfe, 0x2b, 0xf0, 0x85, 0xf4, 0x1e, 0xfe, 0x00, 0xfe, 0xfe, 0x1c,
-	0x12, 0xc2, 0xfe, 0xd2,
-	0xf0, 0x85, 0xfe, 0x76, 0x18, 0x1e, 0x19, 0x17, 0x85, 0x03, 0xd2, 0x1e,
-	0x06, 0x17, 0x85, 0xc5,
+	0x0b, 0xb6, 0xfe, 0xbf, 0x10, 0xfe, 0x2b, 0xf0, 0x85, 0xf4, 0x1e, 0xfe,
+	0x00, 0xfe, 0xfe, 0x1c, 0x12, 0xc2, 0xfe, 0xd2, 0xf0, 0x85, 0xfe, 0x76,
+	0x18, 0x1e, 0x19, 0x17, 0x85, 0x03, 0xd2, 0x1e, 0x06, 0x17, 0x85, 0xc5,
 	0x4a, 0xc6, 0x4a, 0xb5, 0xb6, 0xfe, 0x89, 0x10, 0x74, 0x67, 0x2d, 0x15,
-	0x9d, 0x01, 0x36, 0x10,
-	0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x65, 0x10, 0x80, 0x02, 0x65, 0xfe,
-	0x98, 0x80, 0xfe, 0x19,
-	0xe4, 0x0a, 0xfe, 0x1a, 0x12, 0x51, 0xfe, 0x19, 0x82, 0xfe, 0x6c, 0x18,
-	0xfe, 0x44, 0x54, 0xbe,
+	0x9d, 0x01, 0x36, 0x10, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x65, 0x10,
+	0x80, 0x02, 0x65, 0xfe, 0x98, 0x80, 0xfe, 0x19, 0xe4, 0x0a, 0xfe, 0x1a,
+	0x12, 0x51, 0xfe, 0x19, 0x82, 0xfe, 0x6c, 0x18, 0xfe, 0x44, 0x54, 0xbe,
 	0xfe, 0x19, 0x81, 0xfe, 0x74, 0x18, 0x8f, 0x90, 0x17, 0xfe, 0xce, 0x08,
-	0x02, 0x4a, 0x08, 0x05,
-	0x5a, 0xec, 0x03, 0x2e, 0x29, 0x3c, 0x0c, 0x3f, 0x14, 0x40, 0x9b, 0x2e,
-	0x9c, 0x3c, 0xfe, 0x6c,
-	0x18, 0xfe, 0xed, 0x18, 0xfe, 0x44, 0x54, 0xfe, 0xe5, 0x54, 0x3a, 0x3f,
-	0x3b, 0x40, 0x03, 0x49,
+	0x02, 0x4a, 0x08, 0x05, 0x5a, 0xec, 0x03, 0x2e, 0x29, 0x3c, 0x0c, 0x3f,
+	0x14, 0x40, 0x9b, 0x2e, 0x9c, 0x3c, 0xfe, 0x6c, 0x18, 0xfe, 0xed, 0x18,
+	0xfe, 0x44, 0x54, 0xfe, 0xe5, 0x54, 0x3a, 0x3f, 0x3b, 0x40, 0x03, 0x49,
 	0x29, 0x63, 0x8f, 0xfe, 0xe3, 0x54, 0xfe, 0x74, 0x18, 0xfe, 0xf5, 0x18,
-	0x8f, 0xfe, 0xe3, 0x54,
-	0x90, 0xc0, 0x56, 0xfe, 0xce, 0x08, 0x02, 0x4a, 0xfe, 0x37, 0xf0, 0xfe,
-	0xda, 0x09, 0xfe, 0x8b,
-	0xf0, 0xfe, 0x60, 0x09, 0x02, 0x4a, 0x08, 0x05, 0x0a, 0x23, 0xfe, 0xfa,
-	0x0a, 0x3a, 0x49, 0x3b,
+	0x8f, 0xfe, 0xe3, 0x54, 0x90, 0xc0, 0x56, 0xfe, 0xce, 0x08, 0x02, 0x4a,
+	0xfe, 0x37, 0xf0, 0xfe, 0xda, 0x09, 0xfe, 0x8b, 0xf0, 0xfe, 0x60, 0x09,
+	0x02, 0x4a, 0x08, 0x05, 0x0a, 0x23, 0xfe, 0xfa, 0x0a, 0x3a, 0x49, 0x3b,
 	0x63, 0x56, 0xfe, 0x3e, 0x0a, 0x0f, 0xfe, 0xc0, 0x07, 0x41, 0x98, 0x00,
-	0xad, 0xfe, 0x01, 0x59,
-	0xfe, 0x52, 0xf0, 0xfe, 0x0c, 0x0a, 0x8f, 0x7a, 0xfe, 0x24, 0x0a, 0x3a,
-	0x49, 0x8f, 0xfe, 0xe3,
-	0x54, 0x57, 0x49, 0x7d, 0x63, 0xfe, 0x14, 0x58, 0xfe, 0x95, 0x58, 0x02,
-	0x4a, 0x3a, 0x49, 0x3b,
+	0xad, 0xfe, 0x01, 0x59, 0xfe, 0x52, 0xf0, 0xfe, 0x0c, 0x0a, 0x8f, 0x7a,
+	0xfe, 0x24, 0x0a, 0x3a, 0x49, 0x8f, 0xfe, 0xe3, 0x54, 0x57, 0x49, 0x7d,
+	0x63, 0xfe, 0x14, 0x58, 0xfe, 0x95, 0x58, 0x02, 0x4a, 0x3a, 0x49, 0x3b,
 	0x63, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0xbe, 0x57, 0x49, 0x57, 0x63,
-	0x02, 0x4a, 0x08, 0x05,
-	0x5a, 0xfe, 0x82, 0x12, 0x08, 0x05, 0x1f, 0xfe, 0x66, 0x13, 0x22, 0x62,
-	0xb7, 0xfe, 0x03, 0xa1,
-	0xfe, 0x83, 0x80, 0xfe, 0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91,
-	0xfe, 0x86, 0x91, 0x6a,
+	0x02, 0x4a, 0x08, 0x05, 0x5a, 0xfe, 0x82, 0x12, 0x08, 0x05, 0x1f, 0xfe,
+	0x66, 0x13, 0x22, 0x62, 0xb7, 0xfe, 0x03, 0xa1, 0xfe, 0x83, 0x80, 0xfe,
+	0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91, 0xfe, 0x86, 0x91, 0x6a,
 	0x2a, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x56, 0xe0, 0x03, 0x60, 0x29,
-	0x61, 0x0c, 0x7f, 0x14,
-	0x80, 0x57, 0x60, 0x7d, 0x61, 0x01, 0xb3, 0xb8, 0x6a, 0x2a, 0x13, 0x62,
-	0x9b, 0x2e, 0x9c, 0x3c,
-	0x3a, 0x3f, 0x3b, 0x40, 0x90, 0xc0, 0xfe, 0x04, 0xfa, 0x2e, 0xfe, 0x05,
-	0xfa, 0x3c, 0x01, 0xef,
+	0x61, 0x0c, 0x7f, 0x14, 0x80, 0x57, 0x60, 0x7d, 0x61, 0x01, 0xb3, 0xb8,
+	0x6a, 0x2a, 0x13, 0x62, 0x9b, 0x2e, 0x9c, 0x3c, 0x3a, 0x3f, 0x3b, 0x40,
+	0x90, 0xc0, 0xfe, 0x04, 0xfa, 0x2e, 0xfe, 0x05, 0xfa, 0x3c, 0x01, 0xef,
 	0xfe, 0x36, 0x10, 0x21, 0x0c, 0x7f, 0x0c, 0x80, 0x3a, 0x3f, 0x3b, 0x40,
-	0xe4, 0x08, 0x05, 0x1f,
-	0x17, 0xe0, 0x3a, 0x3d, 0x3b, 0x3e, 0x08, 0x05, 0xfe, 0xf7, 0x00, 0x37,
-	0x03, 0x5e, 0x29, 0x5f,
-	0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58, 0x57, 0x49, 0x7d, 0x63, 0x02, 0xfe,
-	0xf4, 0x09, 0x08, 0x05,
+	0xe4, 0x08, 0x05, 0x1f, 0x17, 0xe0, 0x3a, 0x3d, 0x3b, 0x3e, 0x08, 0x05,
+	0xfe, 0xf7, 0x00, 0x37, 0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x10, 0x58, 0xfe,
+	0x91, 0x58, 0x57, 0x49, 0x7d, 0x63, 0x02, 0xfe, 0xf4, 0x09, 0x08, 0x05,
 	0x1f, 0x17, 0xe0, 0x08, 0x05, 0xfe, 0xf7, 0x00, 0x37, 0xbe, 0xfe, 0x19,
-	0x81, 0x50, 0xfe, 0x10,
-	0x90, 0xfe, 0x92, 0x90, 0xfe, 0xd3, 0x10, 0x32, 0x07, 0xa6, 0x17, 0xfe,
-	0x08, 0x09, 0x12, 0xa6,
-	0x08, 0x05, 0x0a, 0xfe, 0x14, 0x13, 0x03, 0x3d, 0x29, 0x3e, 0x56, 0xfe,
-	0x08, 0x09, 0xfe, 0x0c,
+	0x81, 0x50, 0xfe, 0x10, 0x90, 0xfe, 0x92, 0x90, 0xfe, 0xd3, 0x10, 0x32,
+	0x07, 0xa6, 0x17, 0xfe, 0x08, 0x09, 0x12, 0xa6, 0x08, 0x05, 0x0a, 0xfe,
+	0x14, 0x13, 0x03, 0x3d, 0x29, 0x3e, 0x56, 0xfe, 0x08, 0x09, 0xfe, 0x0c,
 	0x58, 0xfe, 0x8d, 0x58, 0x02, 0x4a, 0x21, 0x41, 0xfe, 0x19, 0x80, 0xe7,
-	0x08, 0x05, 0x0a, 0xfe,
-	0x1a, 0x12, 0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41, 0xf4, 0xc2, 0xfe, 0xd1,
-	0xf0, 0xe2, 0x15, 0x7e,
-	0x01, 0x36, 0x10, 0xfe, 0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe, 0x6c, 0x19,
-	0x57, 0x3d, 0xfe, 0xed,
+	0x08, 0x05, 0x0a, 0xfe, 0x1a, 0x12, 0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41,
+	0xf4, 0xc2, 0xfe, 0xd1, 0xf0, 0xe2, 0x15, 0x7e, 0x01, 0x36, 0x10, 0xfe,
+	0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe, 0x6c, 0x19, 0x57, 0x3d, 0xfe, 0xed,
 	0x19, 0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0xf4, 0x1e, 0xfe,
-	0x00, 0xff, 0x35, 0xfe,
-	0x74, 0x10, 0xc2, 0xfe, 0xd2, 0xf0, 0xfe, 0xa6, 0x0b, 0xfe, 0x76, 0x18,
-	0x1e, 0x19, 0x8a, 0x03,
-	0xd2, 0x1e, 0x06, 0xfe, 0x08, 0x13, 0x10, 0xfe, 0x16, 0x00, 0x02, 0x65,
-	0xfe, 0xd1, 0xf0, 0xfe,
+	0x00, 0xff, 0x35, 0xfe, 0x74, 0x10, 0xc2, 0xfe, 0xd2, 0xf0, 0xfe, 0xa6,
+	0x0b, 0xfe, 0x76, 0x18, 0x1e, 0x19, 0x8a, 0x03, 0xd2, 0x1e, 0x06, 0xfe,
+	0x08, 0x13, 0x10, 0xfe, 0x16, 0x00, 0x02, 0x65, 0xfe, 0xd1, 0xf0, 0xfe,
 	0xb8, 0x0b, 0x15, 0x7e, 0x01, 0x36, 0x10, 0xfe, 0x17, 0x00, 0xfe, 0x42,
-	0x10, 0xfe, 0xce, 0xf0,
-	0xfe, 0xbe, 0x0b, 0xfe, 0x3c, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xca, 0x0b,
-	0x10, 0xfe, 0x22, 0x00,
-	0x02, 0x65, 0xfe, 0xcb, 0xf0, 0xfe, 0xd6, 0x0b, 0x10, 0xfe, 0x24, 0x00,
-	0x02, 0x65, 0xfe, 0xd0,
+	0x10, 0xfe, 0xce, 0xf0, 0xfe, 0xbe, 0x0b, 0xfe, 0x3c, 0x10, 0xfe, 0xcd,
+	0xf0, 0xfe, 0xca, 0x0b, 0x10, 0xfe, 0x22, 0x00, 0x02, 0x65, 0xfe, 0xcb,
+	0xf0, 0xfe, 0xd6, 0x0b, 0x10, 0xfe, 0x24, 0x00, 0x02, 0x65, 0xfe, 0xd0,
 	0xf0, 0xfe, 0xe0, 0x0b, 0x10, 0x9e, 0xe5, 0xfe, 0xcf, 0xf0, 0xfe, 0xea,
-	0x0b, 0x10, 0x58, 0xfe,
-	0x10, 0x10, 0xfe, 0xcc, 0xf0, 0xe2, 0x68, 0x05, 0x1f, 0x4d, 0x10, 0xfe,
-	0x12, 0x00, 0x2c, 0x0f,
-	0xfe, 0x4e, 0x11, 0x27, 0xfe, 0x00, 0x0c, 0xfe, 0x9e, 0xf0, 0xfe, 0x14,
-	0x0c, 0xbc, 0x17, 0x34,
+	0x0b, 0x10, 0x58, 0xfe, 0x10, 0x10, 0xfe, 0xcc, 0xf0, 0xe2, 0x68, 0x05,
+	0x1f, 0x4d, 0x10, 0xfe, 0x12, 0x00, 0x2c, 0x0f, 0xfe, 0x4e, 0x11, 0x27,
+	0xfe, 0x00, 0x0c, 0xfe, 0x9e, 0xf0, 0xfe, 0x14, 0x0c, 0xbc, 0x17, 0x34,
 	0x2c, 0x77, 0xe6, 0xc5, 0x24, 0xc6, 0x24, 0x2c, 0xfa, 0x27, 0xfe, 0x20,
-	0x0c, 0x1c, 0x34, 0x94,
-	0xfe, 0x3c, 0x0c, 0x95, 0x86, 0xc5, 0xdc, 0xc6, 0xdc, 0x02, 0x24, 0x01,
-	0x4b, 0xfe, 0xdb, 0x10,
-	0x12, 0xfe, 0xe8, 0x00, 0xb5, 0xb6, 0x74, 0xc7, 0x81, 0xc8, 0x83, 0xfe,
-	0x89, 0xf0, 0x24, 0x33,
+	0x0c, 0x1c, 0x34, 0x94, 0xfe, 0x3c, 0x0c, 0x95, 0x86, 0xc5, 0xdc, 0xc6,
+	0xdc, 0x02, 0x24, 0x01, 0x4b, 0xfe, 0xdb, 0x10, 0x12, 0xfe, 0xe8, 0x00,
+	0xb5, 0xb6, 0x74, 0xc7, 0x81, 0xc8, 0x83, 0xfe, 0x89, 0xf0, 0x24, 0x33,
 	0x31, 0xe1, 0xc7, 0x81, 0xc8, 0x83, 0x27, 0xfe, 0x66, 0x0c, 0x1d, 0x24,
-	0x33, 0x31, 0xdf, 0xbc,
-	0x4e, 0x10, 0xfe, 0x42, 0x00, 0x02, 0x65, 0x7c, 0x06, 0xfe, 0x81, 0x49,
-	0x17, 0xfe, 0x2c, 0x0d,
-	0x08, 0x05, 0x0a, 0xfe, 0x44, 0x13, 0x10, 0x00, 0x55, 0x0a, 0xfe, 0x54,
-	0x12, 0x55, 0xfe, 0x28,
+	0x33, 0x31, 0xdf, 0xbc, 0x4e, 0x10, 0xfe, 0x42, 0x00, 0x02, 0x65, 0x7c,
+	0x06, 0xfe, 0x81, 0x49, 0x17, 0xfe, 0x2c, 0x0d, 0x08, 0x05, 0x0a, 0xfe,
+	0x44, 0x13, 0x10, 0x00, 0x55, 0x0a, 0xfe, 0x54, 0x12, 0x55, 0xfe, 0x28,
 	0x00, 0x23, 0xfe, 0x9a, 0x0d, 0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x66,
-	0x44, 0xfe, 0x28, 0x00,
-	0xfe, 0xe2, 0x10, 0x01, 0xf5, 0x01, 0xf6, 0x09, 0xa4, 0x01, 0xfe, 0x26,
-	0x0f, 0x64, 0x12, 0x2f,
-	0x01, 0x73, 0x02, 0x2b, 0x10, 0xfe, 0x44, 0x00, 0x55, 0x0a, 0xe9, 0x44,
-	0x0a, 0xfe, 0xb4, 0x10,
+	0x44, 0xfe, 0x28, 0x00, 0xfe, 0xe2, 0x10, 0x01, 0xf5, 0x01, 0xf6, 0x09,
+	0xa4, 0x01, 0xfe, 0x26, 0x0f, 0x64, 0x12, 0x2f, 0x01, 0x73, 0x02, 0x2b,
+	0x10, 0xfe, 0x44, 0x00, 0x55, 0x0a, 0xe9, 0x44, 0x0a, 0xfe, 0xb4, 0x10,
 	0x01, 0xb0, 0x44, 0x0a, 0xfe, 0xaa, 0x10, 0x01, 0xb0, 0xfe, 0x19, 0x82,
-	0xfe, 0x34, 0x46, 0xac,
-	0x44, 0x0a, 0x10, 0xfe, 0x43, 0x00, 0xfe, 0x96, 0x10, 0x08, 0x54, 0x0a,
-	0x37, 0x01, 0xf5, 0x01,
-	0xf6, 0x64, 0x12, 0x2f, 0x01, 0x73, 0x99, 0x0a, 0x64, 0x42, 0x92, 0x02,
-	0xfe, 0x2e, 0x03, 0x08,
+	0xfe, 0x34, 0x46, 0xac, 0x44, 0x0a, 0x10, 0xfe, 0x43, 0x00, 0xfe, 0x96,
+	0x10, 0x08, 0x54, 0x0a, 0x37, 0x01, 0xf5, 0x01, 0xf6, 0x64, 0x12, 0x2f,
+	0x01, 0x73, 0x99, 0x0a, 0x64, 0x42, 0x92, 0x02, 0xfe, 0x2e, 0x03, 0x08,
 	0x05, 0x0a, 0x8a, 0x44, 0x0a, 0x10, 0x00, 0xfe, 0x5c, 0x10, 0x68, 0x05,
-	0x1a, 0xfe, 0x58, 0x12,
-	0x08, 0x05, 0x1a, 0xfe, 0x50, 0x13, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0,
-	0xfe, 0x50, 0x0d, 0xfe,
-	0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x56, 0x0d, 0x08, 0x54, 0x1a, 0x37,
-	0xfe, 0xa9, 0x10, 0x10,
+	0x1a, 0xfe, 0x58, 0x12, 0x08, 0x05, 0x1a, 0xfe, 0x50, 0x13, 0xfe, 0x1c,
+	0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x50, 0x0d, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d,
+	0xf0, 0xfe, 0x56, 0x0d, 0x08, 0x54, 0x1a, 0x37, 0xfe, 0xa9, 0x10, 0x10,
 	0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0a, 0x50, 0xfe, 0x2e, 0x10, 0x10,
-	0xfe, 0x13, 0x00, 0xfe,
-	0x10, 0x10, 0x10, 0x6f, 0xab, 0x10, 0xfe, 0x41, 0x00, 0xaa, 0x10, 0xfe,
-	0x24, 0x00, 0x8c, 0xb5,
-	0xb6, 0x74, 0x03, 0x70, 0x28, 0x23, 0xd8, 0x50, 0xfe, 0x04, 0xe6, 0x1a,
-	0xfe, 0x9d, 0x41, 0xfe,
+	0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x10, 0x6f, 0xab, 0x10, 0xfe, 0x41,
+	0x00, 0xaa, 0x10, 0xfe, 0x24, 0x00, 0x8c, 0xb5, 0xb6, 0x74, 0x03, 0x70,
+	0x28, 0x23, 0xd8, 0x50, 0xfe, 0x04, 0xe6, 0x1a, 0xfe, 0x9d, 0x41, 0xfe,
 	0x1c, 0x42, 0x64, 0x01, 0xe3, 0x02, 0x2b, 0xf8, 0x15, 0x0a, 0x39, 0xa0,
-	0xb4, 0x15, 0xfe, 0x31,
-	0x00, 0x39, 0xa2, 0x01, 0xfe, 0x48, 0x10, 0x02, 0xd7, 0x42, 0xfe, 0x06,
-	0xec, 0xd0, 0xfc, 0x44,
-	0x1b, 0xfe, 0xce, 0x45, 0x35, 0x42, 0xfe, 0x06, 0xea, 0xd0, 0xfe, 0x47,
-	0x4b, 0x91, 0xfe, 0x75,
+	0xb4, 0x15, 0xfe, 0x31, 0x00, 0x39, 0xa2, 0x01, 0xfe, 0x48, 0x10, 0x02,
+	0xd7, 0x42, 0xfe, 0x06, 0xec, 0xd0, 0xfc, 0x44, 0x1b, 0xfe, 0xce, 0x45,
+	0x35, 0x42, 0xfe, 0x06, 0xea, 0xd0, 0xfe, 0x47, 0x4b, 0x91, 0xfe, 0x75,
 	0x57, 0x03, 0x5d, 0xfe, 0x98, 0x56, 0xfe, 0x38, 0x12, 0x09, 0x48, 0x01,
-	0x0e, 0xfe, 0x44, 0x48,
-	0x4f, 0x08, 0x05, 0x1b, 0xfe, 0x1a, 0x13, 0x09, 0x46, 0x01, 0x0e, 0x41,
-	0xfe, 0x41, 0x58, 0x09,
-	0xa4, 0x01, 0x0e, 0xfe, 0x49, 0x54, 0x96, 0xfe, 0x1e, 0x0e, 0x02, 0xfe,
-	0x2e, 0x03, 0x09, 0x5d,
+	0x0e, 0xfe, 0x44, 0x48, 0x4f, 0x08, 0x05, 0x1b, 0xfe, 0x1a, 0x13, 0x09,
+	0x46, 0x01, 0x0e, 0x41, 0xfe, 0x41, 0x58, 0x09, 0xa4, 0x01, 0x0e, 0xfe,
+	0x49, 0x54, 0x96, 0xfe, 0x1e, 0x0e, 0x02, 0xfe, 0x2e, 0x03, 0x09, 0x5d,
 	0xfe, 0xee, 0x14, 0xfc, 0x44, 0x1b, 0xfe, 0xce, 0x45, 0x35, 0x42, 0xfe,
-	0xce, 0x47, 0xfe, 0xad,
-	0x13, 0x02, 0x2b, 0x22, 0x20, 0x07, 0x11, 0xfe, 0x9e, 0x12, 0x21, 0x13,
-	0x59, 0x13, 0x9f, 0x13,
-	0xd5, 0x22, 0x2f, 0x41, 0x39, 0x2f, 0xbc, 0xad, 0xfe, 0xbc, 0xf0, 0xfe,
-	0xe0, 0x0e, 0x0f, 0x06,
+	0xce, 0x47, 0xfe, 0xad, 0x13, 0x02, 0x2b, 0x22, 0x20, 0x07, 0x11, 0xfe,
+	0x9e, 0x12, 0x21, 0x13, 0x59, 0x13, 0x9f, 0x13, 0xd5, 0x22, 0x2f, 0x41,
+	0x39, 0x2f, 0xbc, 0xad, 0xfe, 0xbc, 0xf0, 0xfe, 0xe0, 0x0e, 0x0f, 0x06,
 	0x13, 0x59, 0x01, 0xfe, 0xda, 0x16, 0x03, 0xfe, 0x38, 0x01, 0x29, 0xfe,
-	0x3a, 0x01, 0x56, 0xfe,
-	0xe4, 0x0e, 0xfe, 0x02, 0xec, 0xd5, 0x69, 0x00, 0x66, 0xfe, 0x04, 0xec,
-	0x20, 0x4f, 0xfe, 0x05,
-	0xf6, 0xfe, 0x34, 0x01, 0x01, 0xfe, 0x4a, 0x17, 0xfe, 0x08, 0x90, 0xfe,
-	0x48, 0xf4, 0x0d, 0xfe,
+	0x3a, 0x01, 0x56, 0xfe, 0xe4, 0x0e, 0xfe, 0x02, 0xec, 0xd5, 0x69, 0x00,
+	0x66, 0xfe, 0x04, 0xec, 0x20, 0x4f, 0xfe, 0x05, 0xf6, 0xfe, 0x34, 0x01,
+	0x01, 0xfe, 0x4a, 0x17, 0xfe, 0x08, 0x90, 0xfe, 0x48, 0xf4, 0x0d, 0xfe,
 	0x18, 0x13, 0xba, 0xfe, 0x02, 0xea, 0xd5, 0x69, 0x7e, 0xfe, 0xc5, 0x13,
-	0x15, 0x1a, 0x39, 0xa0,
-	0xb4, 0xfe, 0x2e, 0x10, 0x03, 0xfe, 0x38, 0x01, 0x1e, 0xfe, 0xf0, 0xff,
-	0x0c, 0xfe, 0x60, 0x01,
-	0x03, 0xfe, 0x3a, 0x01, 0x0c, 0xfe, 0x62, 0x01, 0x43, 0x13, 0x20, 0x25,
-	0x06, 0x13, 0x2f, 0x12,
+	0x15, 0x1a, 0x39, 0xa0, 0xb4, 0xfe, 0x2e, 0x10, 0x03, 0xfe, 0x38, 0x01,
+	0x1e, 0xfe, 0xf0, 0xff, 0x0c, 0xfe, 0x60, 0x01, 0x03, 0xfe, 0x3a, 0x01,
+	0x0c, 0xfe, 0x62, 0x01, 0x43, 0x13, 0x20, 0x25, 0x06, 0x13, 0x2f, 0x12,
 	0x2f, 0x92, 0x0f, 0x06, 0x04, 0x21, 0x04, 0x22, 0x59, 0xfe, 0xf7, 0x12,
-	0x22, 0x9f, 0xb7, 0x13,
-	0x9f, 0x07, 0x7e, 0xfe, 0x71, 0x13, 0xfe, 0x24, 0x1c, 0x15, 0x19, 0x39,
-	0xa0, 0xb4, 0xfe, 0xd9,
-	0x10, 0xc3, 0xfe, 0x03, 0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x04,
-	0xc3, 0xfe, 0x03, 0xdc,
+	0x22, 0x9f, 0xb7, 0x13, 0x9f, 0x07, 0x7e, 0xfe, 0x71, 0x13, 0xfe, 0x24,
+	0x1c, 0x15, 0x19, 0x39, 0xa0, 0xb4, 0xfe, 0xd9, 0x10, 0xc3, 0xfe, 0x03,
+	0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x04, 0xc3, 0xfe, 0x03, 0xdc,
 	0xfe, 0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x04, 0xfe, 0x03, 0x57, 0xc3, 0x21,
-	0xfe, 0x00, 0xcc, 0x04,
-	0xfe, 0x03, 0x57, 0xc3, 0x78, 0x04, 0x08, 0x05, 0x58, 0xfe, 0x22, 0x13,
-	0xfe, 0x1c, 0x80, 0x07,
-	0x06, 0xfe, 0x1a, 0x13, 0xfe, 0x1e, 0x80, 0xed, 0xfe, 0x1d, 0x80, 0xae,
-	0xfe, 0x0c, 0x90, 0xfe,
+	0xfe, 0x00, 0xcc, 0x04, 0xfe, 0x03, 0x57, 0xc3, 0x78, 0x04, 0x08, 0x05,
+	0x58, 0xfe, 0x22, 0x13, 0xfe, 0x1c, 0x80, 0x07, 0x06, 0xfe, 0x1a, 0x13,
+	0xfe, 0x1e, 0x80, 0xed, 0xfe, 0x1d, 0x80, 0xae, 0xfe, 0x0c, 0x90, 0xfe,
 	0x0e, 0x13, 0xfe, 0x0e, 0x90, 0xac, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4,
-	0x0a, 0xfe, 0x3c, 0x50,
-	0xaa, 0x01, 0xfe, 0x7a, 0x17, 0x32, 0x07, 0x2f, 0xad, 0x01, 0xfe, 0xb4,
-	0x16, 0x08, 0x05, 0x1b,
-	0x4e, 0x01, 0xf5, 0x01, 0xf6, 0x12, 0xfe, 0xe9, 0x00, 0x08, 0x05, 0x58,
-	0xfe, 0x2c, 0x13, 0x01,
+	0x0a, 0xfe, 0x3c, 0x50, 0xaa, 0x01, 0xfe, 0x7a, 0x17, 0x32, 0x07, 0x2f,
+	0xad, 0x01, 0xfe, 0xb4, 0x16, 0x08, 0x05, 0x1b, 0x4e, 0x01, 0xf5, 0x01,
+	0xf6, 0x12, 0xfe, 0xe9, 0x00, 0x08, 0x05, 0x58, 0xfe, 0x2c, 0x13, 0x01,
 	0xfe, 0x0c, 0x17, 0xfe, 0x1e, 0x1c, 0xfe, 0x14, 0x90, 0xfe, 0x96, 0x90,
-	0x0c, 0xfe, 0x64, 0x01,
-	0x14, 0xfe, 0x66, 0x01, 0x08, 0x05, 0x5b, 0xfe, 0x12, 0x12, 0xfe, 0x03,
-	0x80, 0x8d, 0xfe, 0x01,
-	0xec, 0x20, 0xfe, 0x80, 0x40, 0x13, 0x20, 0x6a, 0x2a, 0x12, 0xcf, 0x64,
-	0x22, 0x20, 0xfb, 0x79,
+	0x0c, 0xfe, 0x64, 0x01, 0x14, 0xfe, 0x66, 0x01, 0x08, 0x05, 0x5b, 0xfe,
+	0x12, 0x12, 0xfe, 0x03, 0x80, 0x8d, 0xfe, 0x01, 0xec, 0x20, 0xfe, 0x80,
+	0x40, 0x13, 0x20, 0x6a, 0x2a, 0x12, 0xcf, 0x64, 0x22, 0x20, 0xfb, 0x79,
 	0x20, 0x04, 0xfe, 0x08, 0x1c, 0x03, 0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58,
-	0x03, 0xfe, 0xae, 0x00,
-
-	0xfe, 0x07, 0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe, 0x08, 0x58, 0x03, 0xfe,
-	0xb2, 0x00, 0xfe, 0x09,
-	0x58, 0xfe, 0x0a, 0x1c, 0x25, 0x6e, 0x13, 0xd0, 0x21, 0x0c, 0x5c, 0x0c,
-	0x45, 0x0f, 0x46, 0x52,
+	0x03, 0xfe, 0xae, 0x00, 0xfe, 0x07, 0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe,
+	0x08, 0x58, 0x03, 0xfe, 0xb2, 0x00, 0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c,
+	0x25, 0x6e, 0x13, 0xd0, 0x21, 0x0c, 0x5c, 0x0c, 0x45, 0x0f, 0x46, 0x52,
 	0x50, 0x18, 0x1b, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x23, 0xfe, 0xfc,
-	0x0f, 0x44, 0x11, 0x0f,
-	0x48, 0x52, 0x18, 0x58, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x23, 0xe4,
-	0x25, 0x11, 0x13, 0x20,
-	0x7c, 0x6f, 0x4f, 0x22, 0x20, 0xfb, 0x79, 0x20, 0x12, 0xcf, 0xfe, 0x14,
-	0x56, 0xfe, 0xd6, 0xf0,
+	0x0f, 0x44, 0x11, 0x0f, 0x48, 0x52, 0x18, 0x58, 0xfe, 0x90, 0x4d, 0xfe,
+	0x91, 0x54, 0x23, 0xe4, 0x25, 0x11, 0x13, 0x20, 0x7c, 0x6f, 0x4f, 0x22,
+	0x20, 0xfb, 0x79, 0x20, 0x12, 0xcf, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0,
 	0xfe, 0x26, 0x10, 0xf8, 0x74, 0xfe, 0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe,
-	0x18, 0x1c, 0x04, 0x42,
-	0xfe, 0x0c, 0x14, 0xfc, 0xfe, 0x07, 0xe6, 0x1b, 0xfe, 0xce, 0x47, 0xfe,
-	0xf5, 0x13, 0x04, 0x01,
-	0xb0, 0x7c, 0x6f, 0x4f, 0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42,
-	0x13, 0x32, 0x07, 0x2f,
+	0x18, 0x1c, 0x04, 0x42, 0xfe, 0x0c, 0x14, 0xfc, 0xfe, 0x07, 0xe6, 0x1b,
+	0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x04, 0x01, 0xb0, 0x7c, 0x6f, 0x4f,
+	0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42, 0x13, 0x32, 0x07, 0x2f,
 	0xfe, 0x34, 0x13, 0x09, 0x48, 0x01, 0x0e, 0xbb, 0xfe, 0x36, 0x12, 0xfe,
-	0x41, 0x48, 0xfe, 0x45,
-	0x48, 0x01, 0xf0, 0xfe, 0x00, 0xcc, 0xbb, 0xfe, 0xf3, 0x13, 0x43, 0x78,
-	0x07, 0x11, 0xac, 0x09,
-	0x84, 0x01, 0x0e, 0xfe, 0x80, 0x5c, 0x01, 0x73, 0xfe, 0x0e, 0x10, 0x07,
-	0x82, 0x4e, 0xfe, 0x14,
+	0x41, 0x48, 0xfe, 0x45, 0x48, 0x01, 0xf0, 0xfe, 0x00, 0xcc, 0xbb, 0xfe,
+	0xf3, 0x13, 0x43, 0x78, 0x07, 0x11, 0xac, 0x09, 0x84, 0x01, 0x0e, 0xfe,
+	0x80, 0x5c, 0x01, 0x73, 0xfe, 0x0e, 0x10, 0x07, 0x82, 0x4e, 0xfe, 0x14,
 	0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x60, 0x10, 0x04, 0xfe, 0x44, 0x58, 0x8d,
-	0xfe, 0x01, 0xec, 0xa2,
-	0xfe, 0x9e, 0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x1a, 0x79,
-	0x2a, 0x01, 0xe3, 0xfe,
-	0xdd, 0x10, 0x2c, 0xc7, 0x81, 0xc8, 0x83, 0x33, 0x31, 0xde, 0x07, 0x1a,
-	0xfe, 0x48, 0x12, 0x07,
+	0xfe, 0x01, 0xec, 0xa2, 0xfe, 0x9e, 0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe,
+	0x9c, 0xe7, 0x1a, 0x79, 0x2a, 0x01, 0xe3, 0xfe, 0xdd, 0x10, 0x2c, 0xc7,
+	0x81, 0xc8, 0x83, 0x33, 0x31, 0xde, 0x07, 0x1a, 0xfe, 0x48, 0x12, 0x07,
 	0x0a, 0xfe, 0x56, 0x12, 0x07, 0x19, 0xfe, 0x30, 0x12, 0x07, 0xc9, 0x17,
-	0xfe, 0x32, 0x12, 0x07,
-	0xfe, 0x23, 0x00, 0x17, 0xeb, 0x07, 0x06, 0x17, 0xfe, 0x9c, 0x12, 0x07,
-	0x1f, 0xfe, 0x12, 0x12,
-	0x07, 0x00, 0x17, 0x24, 0x15, 0xc9, 0x01, 0x36, 0xa9, 0x2d, 0x01, 0x0b,
-	0x94, 0x4b, 0x04, 0x2d,
+	0xfe, 0x32, 0x12, 0x07, 0xfe, 0x23, 0x00, 0x17, 0xeb, 0x07, 0x06, 0x17,
+	0xfe, 0x9c, 0x12, 0x07, 0x1f, 0xfe, 0x12, 0x12, 0x07, 0x00, 0x17, 0x24,
+	0x15, 0xc9, 0x01, 0x36, 0xa9, 0x2d, 0x01, 0x0b, 0x94, 0x4b, 0x04, 0x2d,
 	0xdd, 0x09, 0xd1, 0x01, 0xfe, 0x26, 0x0f, 0x12, 0x82, 0x02, 0x2b, 0x2d,
-	0x32, 0x07, 0xa6, 0xfe,
-	0xd9, 0x13, 0x3a, 0x3d, 0x3b, 0x3e, 0x56, 0xfe, 0xf0, 0x11, 0x08, 0x05,
-	0x5a, 0xfe, 0x72, 0x12,
-	0x9b, 0x2e, 0x9c, 0x3c, 0x90, 0xc0, 0x96, 0xfe, 0xba, 0x11, 0x22, 0x62,
-	0xfe, 0x26, 0x13, 0x03,
+	0x32, 0x07, 0xa6, 0xfe, 0xd9, 0x13, 0x3a, 0x3d, 0x3b, 0x3e, 0x56, 0xfe,
+	0xf0, 0x11, 0x08, 0x05, 0x5a, 0xfe, 0x72, 0x12, 0x9b, 0x2e, 0x9c, 0x3c,
+	0x90, 0xc0, 0x96, 0xfe, 0xba, 0x11, 0x22, 0x62, 0xfe, 0x26, 0x13, 0x03,
 	0x7f, 0x29, 0x80, 0x56, 0xfe, 0x76, 0x0d, 0x0c, 0x60, 0x14, 0x61, 0x21,
-	0x0c, 0x7f, 0x0c, 0x80,
-	0x01, 0xb3, 0x25, 0x6e, 0x77, 0x13, 0x62, 0x01, 0xef, 0x9b, 0x2e, 0x9c,
-	0x3c, 0xfe, 0x04, 0x55,
-	0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x2e, 0xfe, 0x05, 0xfa, 0x3c, 0xfe,
-	0x91, 0x10, 0x03, 0x3f,
+	0x0c, 0x7f, 0x0c, 0x80, 0x01, 0xb3, 0x25, 0x6e, 0x77, 0x13, 0x62, 0x01,
+	0xef, 0x9b, 0x2e, 0x9c, 0x3c, 0xfe, 0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe,
+	0x04, 0xfa, 0x2e, 0xfe, 0x05, 0xfa, 0x3c, 0xfe, 0x91, 0x10, 0x03, 0x3f,
 	0x29, 0x40, 0xfe, 0x40, 0x56, 0xfe, 0xe1, 0x56, 0x0c, 0x3f, 0x14, 0x40,
-	0x88, 0x9b, 0x2e, 0x9c,
-	0x3c, 0x90, 0xc0, 0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x00, 0x56, 0xfe, 0xa1,
-	0x56, 0x0c, 0x5e, 0x14,
-	0x5f, 0x08, 0x05, 0x5a, 0xfe, 0x1e, 0x12, 0x22, 0x62, 0xfe, 0x1f, 0x40,
-	0x03, 0x60, 0x29, 0x61,
+	0x88, 0x9b, 0x2e, 0x9c, 0x3c, 0x90, 0xc0, 0x03, 0x5e, 0x29, 0x5f, 0xfe,
+	0x00, 0x56, 0xfe, 0xa1, 0x56, 0x0c, 0x5e, 0x14, 0x5f, 0x08, 0x05, 0x5a,
+	0xfe, 0x1e, 0x12, 0x22, 0x62, 0xfe, 0x1f, 0x40, 0x03, 0x60, 0x29, 0x61,
 	0xfe, 0x2c, 0x50, 0xfe, 0xae, 0x50, 0x03, 0x3f, 0x29, 0x40, 0xfe, 0x44,
-	0x50, 0xfe, 0xc6, 0x50,
-	0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x03, 0x3d,
-	0x29, 0x3e, 0xfe, 0x40,
-	0x50, 0xfe, 0xc2, 0x50, 0x02, 0x89, 0x25, 0x06, 0x13, 0xd4, 0x02, 0x72,
-	0x2d, 0x01, 0x0b, 0x1d,
+	0x50, 0xfe, 0xc6, 0x50, 0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x08, 0x50, 0xfe,
+	0x8a, 0x50, 0x03, 0x3d, 0x29, 0x3e, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50,
+	0x02, 0x89, 0x25, 0x06, 0x13, 0xd4, 0x02, 0x72, 0x2d, 0x01, 0x0b, 0x1d,
 	0x4c, 0x33, 0x31, 0xde, 0x07, 0x06, 0x23, 0x4c, 0x32, 0x07, 0xa6, 0x23,
-	0x72, 0x01, 0xaf, 0x1e,
-	0x43, 0x17, 0x4c, 0x08, 0x05, 0x0a, 0xee, 0x3a, 0x3d, 0x3b, 0x3e, 0xfe,
-	0x0a, 0x55, 0x35, 0xfe,
-	0x8b, 0x55, 0x57, 0x3d, 0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51,
-	0x02, 0x72, 0xfe, 0x19,
+	0x72, 0x01, 0xaf, 0x1e, 0x43, 0x17, 0x4c, 0x08, 0x05, 0x0a, 0xee, 0x3a,
+	0x3d, 0x3b, 0x3e, 0xfe, 0x0a, 0x55, 0x35, 0xfe, 0x8b, 0x55, 0x57, 0x3d,
+	0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0x02, 0x72, 0xfe, 0x19,
 	0x81, 0xba, 0xfe, 0x19, 0x41, 0x02, 0x72, 0x2d, 0x01, 0x0b, 0x1c, 0x34,
-	0x1d, 0xe8, 0x33, 0x31,
-	0xe1, 0x55, 0x19, 0xfe, 0xa6, 0x12, 0x55, 0x0a, 0x4d, 0x02, 0x4c, 0x01,
-	0x0b, 0x1c, 0x34, 0x1d,
-	0xe8, 0x33, 0x31, 0xdf, 0x07, 0x19, 0x23, 0x4c, 0x01, 0x0b, 0x1d, 0xe8,
-	0x33, 0x31, 0xfe, 0xe8,
+	0x1d, 0xe8, 0x33, 0x31, 0xe1, 0x55, 0x19, 0xfe, 0xa6, 0x12, 0x55, 0x0a,
+	0x4d, 0x02, 0x4c, 0x01, 0x0b, 0x1c, 0x34, 0x1d, 0xe8, 0x33, 0x31, 0xdf,
+	0x07, 0x19, 0x23, 0x4c, 0x01, 0x0b, 0x1d, 0xe8, 0x33, 0x31, 0xfe, 0xe8,
 	0x09, 0xfe, 0xc2, 0x49, 0x51, 0x03, 0xfe, 0x9c, 0x00, 0x28, 0x8a, 0x53,
-	0x05, 0x1f, 0x35, 0xa9,
-	0xfe, 0xbb, 0x45, 0x55, 0x00, 0x4e, 0x44, 0x06, 0x7c, 0x43, 0xfe, 0xda,
-	0x14, 0x01, 0xaf, 0x8c,
-	0xfe, 0x4b, 0x45, 0xee, 0x32, 0x07, 0xa5, 0xed, 0x03, 0xcd, 0x28, 0x8a,
-	0x03, 0x45, 0x28, 0x35,
+	0x05, 0x1f, 0x35, 0xa9, 0xfe, 0xbb, 0x45, 0x55, 0x00, 0x4e, 0x44, 0x06,
+	0x7c, 0x43, 0xfe, 0xda, 0x14, 0x01, 0xaf, 0x8c, 0xfe, 0x4b, 0x45, 0xee,
+	0x32, 0x07, 0xa5, 0xed, 0x03, 0xcd, 0x28, 0x8a, 0x03, 0x45, 0x28, 0x35,
 	0x67, 0x02, 0x72, 0xfe, 0xc0, 0x5d, 0xfe, 0xf8, 0x14, 0xfe, 0x03, 0x17,
-	0x03, 0x5c, 0xc1, 0x0c,
-	0x5c, 0x67, 0x2d, 0x01, 0x0b, 0x26, 0x89, 0x01, 0xfe, 0x9e, 0x15, 0x02,
-	0x89, 0x01, 0x0b, 0x1c,
-	0x34, 0x1d, 0x4c, 0x33, 0x31, 0xdf, 0x07, 0x06, 0x23, 0x4c, 0x01, 0xf1,
-	0xfe, 0x42, 0x58, 0xf1,
+	0x03, 0x5c, 0xc1, 0x0c, 0x5c, 0x67, 0x2d, 0x01, 0x0b, 0x26, 0x89, 0x01,
+	0xfe, 0x9e, 0x15, 0x02, 0x89, 0x01, 0x0b, 0x1c, 0x34, 0x1d, 0x4c, 0x33,
+	0x31, 0xdf, 0x07, 0x06, 0x23, 0x4c, 0x01, 0xf1, 0xfe, 0x42, 0x58, 0xf1,
 	0xfe, 0xa4, 0x14, 0x8c, 0xfe, 0x4a, 0xf4, 0x0a, 0x17, 0x4c, 0xfe, 0x4a,
-	0xf4, 0x06, 0xea, 0x32,
-	0x07, 0xa5, 0x8b, 0x02, 0x72, 0x03, 0x45, 0xc1, 0x0c, 0x45, 0x67, 0x2d,
-	0x01, 0x0b, 0x26, 0x89,
-	0x01, 0xfe, 0xcc, 0x15, 0x02, 0x89, 0x0f, 0x06, 0x27, 0xfe, 0xbe, 0x13,
-	0x26, 0xfe, 0xd4, 0x13,
+	0xf4, 0x06, 0xea, 0x32, 0x07, 0xa5, 0x8b, 0x02, 0x72, 0x03, 0x45, 0xc1,
+	0x0c, 0x45, 0x67, 0x2d, 0x01, 0x0b, 0x26, 0x89, 0x01, 0xfe, 0xcc, 0x15,
+	0x02, 0x89, 0x0f, 0x06, 0x27, 0xfe, 0xbe, 0x13, 0x26, 0xfe, 0xd4, 0x13,
 	0x76, 0xfe, 0x89, 0x48, 0x01, 0x0b, 0x21, 0x76, 0x04, 0x7b, 0xfe, 0xd0,
-	0x13, 0x1c, 0xfe, 0xd0,
-	0x13, 0x1d, 0xfe, 0xbe, 0x13, 0x67, 0x2d, 0x01, 0x0b, 0xfe, 0xd5, 0x10,
-	0x0f, 0x71, 0xff, 0x02,
-	0x00, 0x57, 0x52, 0x93, 0x1e, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe,
-	0x00, 0x5c, 0x04, 0x0f,
+	0x13, 0x1c, 0xfe, 0xd0, 0x13, 0x1d, 0xfe, 0xbe, 0x13, 0x67, 0x2d, 0x01,
+	0x0b, 0xfe, 0xd5, 0x10, 0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93,
+	0x1e, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x04, 0x0f,
 	0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0xfe, 0x30, 0x56,
-	0xfe, 0x00, 0x5c, 0x04,
-	0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x04, 0x0f, 0x71, 0xff,
-	0x02, 0x00, 0x57, 0x52,
-	0x93, 0xfe, 0x0b, 0x58, 0x04, 0x09, 0x5c, 0x01, 0x87, 0x09, 0x45, 0x01,
-	0x87, 0x04, 0xfe, 0x03,
+	0xfe, 0x00, 0x5c, 0x04, 0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93,
+	0x04, 0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0xfe, 0x0b, 0x58,
+	0x04, 0x09, 0x5c, 0x01, 0x87, 0x09, 0x45, 0x01, 0x87, 0x04, 0xfe, 0x03,
 	0xa1, 0x1e, 0x11, 0xff, 0x03, 0x00, 0x54, 0xfe, 0x00, 0xf4, 0x1f, 0x52,
-	0xfe, 0x00, 0x7d, 0xfe,
-	0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe, 0x03, 0x7c, 0x6a, 0x2a, 0x0c, 0x5e,
-	0x14, 0x5f, 0x57, 0x3f,
-	0x7d, 0x40, 0x04, 0xdd, 0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83,
-	0x5a, 0x8d, 0x04, 0x01,
+	0xfe, 0x00, 0x7d, 0xfe, 0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe, 0x03, 0x7c,
+	0x6a, 0x2a, 0x0c, 0x5e, 0x14, 0x5f, 0x57, 0x3f, 0x7d, 0x40, 0x04, 0xdd,
+	0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x8d, 0x04, 0x01,
 	0xfe, 0x0c, 0x19, 0xfe, 0x42, 0x48, 0x50, 0x51, 0x91, 0x01, 0x0b, 0x1d,
-	0xfe, 0x96, 0x15, 0x33,
-	0x31, 0xe1, 0x01, 0x0b, 0x1d, 0xfe, 0x96, 0x15, 0x33, 0x31, 0xfe, 0xe8,
-	0x0a, 0xfe, 0xc1, 0x59,
-	0x03, 0xcd, 0x28, 0xfe, 0xcc, 0x12, 0x53, 0x05, 0x1a, 0xfe, 0xc4, 0x13,
-	0x21, 0x69, 0x1a, 0xee,
+	0xfe, 0x96, 0x15, 0x33, 0x31, 0xe1, 0x01, 0x0b, 0x1d, 0xfe, 0x96, 0x15,
+	0x33, 0x31, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x03, 0xcd, 0x28, 0xfe,
+	0xcc, 0x12, 0x53, 0x05, 0x1a, 0xfe, 0xc4, 0x13, 0x21, 0x69, 0x1a, 0xee,
 	0x55, 0xca, 0x6b, 0xfe, 0xdc, 0x14, 0x4d, 0x0f, 0x06, 0x18, 0xca, 0x7c,
-	0x30, 0xfe, 0x78, 0x10,
-	0xff, 0x02, 0x83, 0x55, 0xab, 0xff, 0x02, 0x83, 0x55, 0x69, 0x19, 0xae,
-	0x98, 0xfe, 0x30, 0x00,
-	0x96, 0xf2, 0x18, 0x6d, 0x0f, 0x06, 0xfe, 0x56, 0x10, 0x69, 0x0a, 0xed,
-	0x98, 0xfe, 0x64, 0x00,
+	0x30, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xab, 0xff, 0x02, 0x83,
+	0x55, 0x69, 0x19, 0xae, 0x98, 0xfe, 0x30, 0x00, 0x96, 0xf2, 0x18, 0x6d,
+	0x0f, 0x06, 0xfe, 0x56, 0x10, 0x69, 0x0a, 0xed, 0x98, 0xfe, 0x64, 0x00,
 	0x96, 0xf2, 0x09, 0xfe, 0x64, 0x00, 0x18, 0x9e, 0x0f, 0x06, 0xfe, 0x28,
-	0x10, 0x69, 0x06, 0xfe,
-	0x60, 0x13, 0x98, 0xfe, 0xc8, 0x00, 0x96, 0xf2, 0x09, 0xfe, 0xc8, 0x00,
-	0x18, 0x59, 0x0f, 0x06,
-	0x88, 0x98, 0xfe, 0x90, 0x01, 0x7a, 0xfe, 0x42, 0x15, 0x91, 0xe4, 0xfe,
-	0x43, 0xf4, 0x9f, 0xfe,
+	0x10, 0x69, 0x06, 0xfe, 0x60, 0x13, 0x98, 0xfe, 0xc8, 0x00, 0x96, 0xf2,
+	0x09, 0xfe, 0xc8, 0x00, 0x18, 0x59, 0x0f, 0x06, 0x88, 0x98, 0xfe, 0x90,
+	0x01, 0x7a, 0xfe, 0x42, 0x15, 0x91, 0xe4, 0xfe, 0x43, 0xf4, 0x9f, 0xfe,
 	0x56, 0xf0, 0xfe, 0x54, 0x15, 0xfe, 0x04, 0xf4, 0x71, 0xfe, 0x43, 0xf4,
-	0x9e, 0xfe, 0xf3, 0x10,
-	0xfe, 0x40, 0x5c, 0x01, 0xfe, 0x16, 0x14, 0x1e, 0x43, 0xec, 0xfe, 0x00,
-	0x17, 0xfe, 0x4d, 0xe4,
-	0x6e, 0x7a, 0xfe, 0x90, 0x15, 0xc4, 0x6e, 0xfe, 0x1c, 0x10, 0xfe, 0x00,
-	0x17, 0xfe, 0x4d, 0xe4,
+	0x9e, 0xfe, 0xf3, 0x10, 0xfe, 0x40, 0x5c, 0x01, 0xfe, 0x16, 0x14, 0x1e,
+	0x43, 0xec, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x6e, 0x7a, 0xfe, 0x90,
+	0x15, 0xc4, 0x6e, 0xfe, 0x1c, 0x10, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4,
 	0xcc, 0x7a, 0xfe, 0x90, 0x15, 0xc4, 0xcc, 0x88, 0x51, 0x21, 0xfe, 0x4d,
-	0xf4, 0x00, 0xe9, 0x91,
-	0x0f, 0x06, 0xfe, 0xb4, 0x56, 0xfe, 0xc3, 0x58, 0x04, 0x51, 0x0f, 0x0a,
-	0x04, 0x16, 0x06, 0x01,
-	0x0b, 0x26, 0xf3, 0x16, 0x0a, 0x01, 0x0b, 0x26, 0xf3, 0x16, 0x19, 0x01,
-	0x0b, 0x26, 0xf3, 0x76,
+	0xf4, 0x00, 0xe9, 0x91, 0x0f, 0x06, 0xfe, 0xb4, 0x56, 0xfe, 0xc3, 0x58,
+	0x04, 0x51, 0x0f, 0x0a, 0x04, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xf3, 0x16,
+	0x0a, 0x01, 0x0b, 0x26, 0xf3, 0x16, 0x19, 0x01, 0x0b, 0x26, 0xf3, 0x76,
 	0xfe, 0x89, 0x49, 0x01, 0x0b, 0x04, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1,
-	0x16, 0x19, 0x01, 0x0b,
-	0x26, 0xb1, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1, 0xfe, 0x89, 0x49, 0x01,
-	0x0b, 0x26, 0xb1, 0x76,
-	0xfe, 0x89, 0x4a, 0x01, 0x0b, 0x04, 0x51, 0x04, 0x22, 0xd3, 0x07, 0x06,
-	0xfe, 0x48, 0x13, 0xb8,
+	0x16, 0x19, 0x01, 0x0b, 0x26, 0xb1, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1,
+	0xfe, 0x89, 0x49, 0x01, 0x0b, 0x26, 0xb1, 0x76, 0xfe, 0x89, 0x4a, 0x01,
+	0x0b, 0x04, 0x51, 0x04, 0x22, 0xd3, 0x07, 0x06, 0xfe, 0x48, 0x13, 0xb8,
 	0x13, 0xd3, 0xfe, 0x49, 0xf4, 0x00, 0x4d, 0x76, 0xa9, 0x67, 0xfe, 0x01,
-	0xec, 0xfe, 0x27, 0x01,
-	0xfe, 0x89, 0x48, 0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x2e, 0x16, 0x32,
-	0x07, 0xfe, 0xe3, 0x00,
-	0xfe, 0x20, 0x13, 0x1d, 0xfe, 0x52, 0x16, 0x21, 0x13, 0xd4, 0x01, 0x4b,
-	0x22, 0xd4, 0x07, 0x06,
+	0xec, 0xfe, 0x27, 0x01, 0xfe, 0x89, 0x48, 0xff, 0x02, 0x00, 0x10, 0x27,
+	0xfe, 0x2e, 0x16, 0x32, 0x07, 0xfe, 0xe3, 0x00, 0xfe, 0x20, 0x13, 0x1d,
+	0xfe, 0x52, 0x16, 0x21, 0x13, 0xd4, 0x01, 0x4b, 0x22, 0xd4, 0x07, 0x06,
 	0x4e, 0x08, 0x54, 0x06, 0x37, 0x04, 0x09, 0x48, 0x01, 0x0e, 0xfb, 0x8e,
-	0x07, 0x11, 0xae, 0x09,
-	0x84, 0x01, 0x0e, 0x8e, 0x09, 0x5d, 0x01, 0xa8, 0x04, 0x09, 0x84, 0x01,
-	0x0e, 0x8e, 0xfe, 0x80,
-	0xe7, 0x11, 0x07, 0x11, 0x8a, 0xfe, 0x45, 0x58, 0x01, 0xf0, 0x8e, 0x04,
-	0x09, 0x48, 0x01, 0x0e,
+	0x07, 0x11, 0xae, 0x09, 0x84, 0x01, 0x0e, 0x8e, 0x09, 0x5d, 0x01, 0xa8,
+	0x04, 0x09, 0x84, 0x01, 0x0e, 0x8e, 0xfe, 0x80, 0xe7, 0x11, 0x07, 0x11,
+	0x8a, 0xfe, 0x45, 0x58, 0x01, 0xf0, 0x8e, 0x04, 0x09, 0x48, 0x01, 0x0e,
 	0x8e, 0x09, 0x5d, 0x01, 0xa8, 0x04, 0x09, 0x48, 0x01, 0x0e, 0xfe, 0x80,
-	0x80, 0xfe, 0x80, 0x4c,
-	0xfe, 0x49, 0xe4, 0x11, 0xae, 0x09, 0x84, 0x01, 0x0e, 0xfe, 0x80, 0x4c,
-	0x09, 0x5d, 0x01, 0x87,
-	0x04, 0x18, 0x11, 0x75, 0x6c, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe,
-	0x19, 0xde, 0xfe, 0x24,
+	0x80, 0xfe, 0x80, 0x4c, 0xfe, 0x49, 0xe4, 0x11, 0xae, 0x09, 0x84, 0x01,
+	0x0e, 0xfe, 0x80, 0x4c, 0x09, 0x5d, 0x01, 0x87, 0x04, 0x18, 0x11, 0x75,
+	0x6c, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x24,
 	0x1c, 0xfe, 0x1d, 0xf7, 0x1b, 0x97, 0xfe, 0xee, 0x16, 0x01, 0xfe, 0xf4,
-	0x17, 0xad, 0x9a, 0x1b,
-	0x6c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x04, 0xb9, 0x23, 0xfe, 0xde,
-	0x16, 0xfe, 0xda, 0x10,
-	0x18, 0x11, 0x75, 0x03, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x1f, 0xfe,
-	0x18, 0x58, 0x03, 0xfe,
+	0x17, 0xad, 0x9a, 0x1b, 0x6c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x04,
+	0xb9, 0x23, 0xfe, 0xde, 0x16, 0xfe, 0xda, 0x10, 0x18, 0x11, 0x75, 0x03,
+	0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x1f, 0xfe, 0x18, 0x58, 0x03, 0xfe,
 	0x66, 0x01, 0xfe, 0x19, 0x58, 0x9a, 0x1f, 0xfe, 0x3c, 0x90, 0xfe, 0x30,
-	0xf4, 0x06, 0xfe, 0x3c,
-	0x50, 0x6c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x1f,
-	0x97, 0xfe, 0x38, 0x17,
-	0xfe, 0xb6, 0x14, 0x35, 0x04, 0xb9, 0x23, 0xfe, 0x10, 0x17, 0xfe, 0x9c,
-	0x10, 0x18, 0x11, 0x75,
+	0xf4, 0x06, 0xfe, 0x3c, 0x50, 0x6c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79,
+	0xfe, 0x1c, 0xf7, 0x1f, 0x97, 0xfe, 0x38, 0x17, 0xfe, 0xb6, 0x14, 0x35,
+	0x04, 0xb9, 0x23, 0xfe, 0x10, 0x17, 0xfe, 0x9c, 0x10, 0x18, 0x11, 0x75,
 	0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7,
-	0x2e, 0x97, 0xfe, 0x5a,
-	0x17, 0xfe, 0x94, 0x14, 0xec, 0x9a, 0x2e, 0x6c, 0x1a, 0xfe, 0xaf, 0x19,
-	0xfe, 0x98, 0xe7, 0x00,
-	0x04, 0xb9, 0x23, 0xfe, 0x4e, 0x17, 0xfe, 0x6c, 0x10, 0x18, 0x11, 0x75,
-	0xfe, 0x30, 0xbc, 0xfe,
+	0x2e, 0x97, 0xfe, 0x5a, 0x17, 0xfe, 0x94, 0x14, 0xec, 0x9a, 0x2e, 0x6c,
+	0x1a, 0xfe, 0xaf, 0x19, 0xfe, 0x98, 0xe7, 0x00, 0x04, 0xb9, 0x23, 0xfe,
+	0x4e, 0x17, 0xfe, 0x6c, 0x10, 0x18, 0x11, 0x75, 0xfe, 0x30, 0xbc, 0xfe,
 	0xb2, 0xbc, 0x9a, 0xcb, 0x6c, 0x1a, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7,
-	0xcb, 0x97, 0xfe, 0x92,
-	0x17, 0xfe, 0x5c, 0x14, 0x35, 0x04, 0xb9, 0x23, 0xfe, 0x7e, 0x17, 0xfe,
-	0x42, 0x10, 0xfe, 0x02,
-	0xf6, 0x11, 0x75, 0xfe, 0x18, 0xfe, 0x60, 0xfe, 0x19, 0xfe, 0x61, 0xfe,
-	0x03, 0xa1, 0xfe, 0x1d,
+	0xcb, 0x97, 0xfe, 0x92, 0x17, 0xfe, 0x5c, 0x14, 0x35, 0x04, 0xb9, 0x23,
+	0xfe, 0x7e, 0x17, 0xfe, 0x42, 0x10, 0xfe, 0x02, 0xf6, 0x11, 0x75, 0xfe,
+	0x18, 0xfe, 0x60, 0xfe, 0x19, 0xfe, 0x61, 0xfe, 0x03, 0xa1, 0xfe, 0x1d,
 	0xf7, 0x5b, 0x97, 0xfe, 0xb8, 0x17, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13,
-	0x9a, 0x5b, 0x41, 0xfe,
-	0x83, 0x58, 0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7, 0x11, 0xfe, 0x81, 0xe7,
-	0x11, 0x12, 0xfe, 0xdd,
-	0x00, 0x6a, 0x2a, 0x04, 0x6a, 0x2a, 0xfe, 0x12, 0x45, 0x23, 0xfe, 0xa8,
-	0x17, 0x15, 0x06, 0x39,
+	0x9a, 0x5b, 0x41, 0xfe, 0x83, 0x58, 0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7,
+	0x11, 0xfe, 0x81, 0xe7, 0x11, 0x12, 0xfe, 0xdd, 0x00, 0x6a, 0x2a, 0x04,
+	0x6a, 0x2a, 0xfe, 0x12, 0x45, 0x23, 0xfe, 0xa8, 0x17, 0x15, 0x06, 0x39,
 	0xa0, 0xb4, 0x02, 0x2b, 0xfe, 0x39, 0xf0, 0xfe, 0xfc, 0x17, 0x21, 0x04,
-	0xfe, 0x7e, 0x18, 0x1e,
-	0x19, 0x66, 0x0f, 0x0d, 0x04, 0x75, 0x03, 0xd2, 0x1e, 0x06, 0xfe, 0xef,
-	0x12, 0xfe, 0xe1, 0x10,
-	0x7c, 0x6f, 0x4f, 0x32, 0x07, 0x2f, 0xfe, 0x3c, 0x13, 0xf1, 0xfe, 0x42,
-	0x13, 0x42, 0x92, 0x09,
+	0xfe, 0x7e, 0x18, 0x1e, 0x19, 0x66, 0x0f, 0x0d, 0x04, 0x75, 0x03, 0xd2,
+	0x1e, 0x06, 0xfe, 0xef, 0x12, 0xfe, 0xe1, 0x10, 0x7c, 0x6f, 0x4f, 0x32,
+	0x07, 0x2f, 0xfe, 0x3c, 0x13, 0xf1, 0xfe, 0x42, 0x13, 0x42, 0x92, 0x09,
 	0x48, 0x01, 0x0e, 0xbb, 0xeb, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01,
-	0xf0, 0xfe, 0x00, 0xcc,
-	0xbb, 0xfe, 0xf3, 0x13, 0x43, 0x78, 0x07, 0x11, 0xac, 0x09, 0x84, 0x01,
-	0x0e, 0xfe, 0x80, 0x4c,
-	0x01, 0x73, 0xfe, 0x16, 0x10, 0x07, 0x82, 0x8b, 0xfe, 0x40, 0x14, 0xfe,
-	0x24, 0x12, 0xfe, 0x14,
+	0xf0, 0xfe, 0x00, 0xcc, 0xbb, 0xfe, 0xf3, 0x13, 0x43, 0x78, 0x07, 0x11,
+	0xac, 0x09, 0x84, 0x01, 0x0e, 0xfe, 0x80, 0x4c, 0x01, 0x73, 0xfe, 0x16,
+	0x10, 0x07, 0x82, 0x8b, 0xfe, 0x40, 0x14, 0xfe, 0x24, 0x12, 0xfe, 0x14,
 	0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x1c, 0x18, 0x18, 0x0a, 0x04, 0xfe, 0x9c,
-	0xe7, 0x0a, 0x10, 0xfe,
-	0x15, 0x00, 0x64, 0x79, 0x2a, 0x01, 0xe3, 0x18, 0x06, 0x04, 0x42, 0x92,
-	0x08, 0x54, 0x1b, 0x37,
-	0x12, 0x2f, 0x01, 0x73, 0x18, 0x06, 0x04, 0xfe, 0x38, 0x90, 0xfe, 0xba,
-	0x90, 0x3a, 0xce, 0x3b,
+	0xe7, 0x0a, 0x10, 0xfe, 0x15, 0x00, 0x64, 0x79, 0x2a, 0x01, 0xe3, 0x18,
+	0x06, 0x04, 0x42, 0x92, 0x08, 0x54, 0x1b, 0x37, 0x12, 0x2f, 0x01, 0x73,
+	0x18, 0x06, 0x04, 0xfe, 0x38, 0x90, 0xfe, 0xba, 0x90, 0x3a, 0xce, 0x3b,
 	0xcf, 0xfe, 0x48, 0x55, 0x35, 0xfe, 0xc9, 0x55, 0x04, 0x22, 0xa3, 0x77,
-	0x13, 0xa3, 0x04, 0x09,
-	0xa4, 0x01, 0x0e, 0xfe, 0x41, 0x48, 0x09, 0x46, 0x01, 0x0e, 0xfe, 0x49,
-	0x44, 0x17, 0xfe, 0xe8,
-	0x18, 0x77, 0x78, 0x04, 0x09, 0x48, 0x01, 0x0e, 0x07, 0x11, 0x4e, 0x09,
-	0x5d, 0x01, 0xa8, 0x09,
+	0x13, 0xa3, 0x04, 0x09, 0xa4, 0x01, 0x0e, 0xfe, 0x41, 0x48, 0x09, 0x46,
+	0x01, 0x0e, 0xfe, 0x49, 0x44, 0x17, 0xfe, 0xe8, 0x18, 0x77, 0x78, 0x04,
+	0x09, 0x48, 0x01, 0x0e, 0x07, 0x11, 0x4e, 0x09, 0x5d, 0x01, 0xa8, 0x09,
 	0x46, 0x01, 0x0e, 0x77, 0x78, 0x04, 0xfe, 0x4e, 0xe4, 0x19, 0x6b, 0xfe,
-	0x1c, 0x19, 0x03, 0xfe,
-	0x90, 0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10, 0xfe, 0x4e, 0xe4, 0xc9,
-	0x6b, 0xfe, 0x2e, 0x19,
-	0x03, 0xfe, 0x92, 0x00, 0xfe, 0x02, 0xe6, 0x1a, 0xe5, 0xfe, 0x4e, 0xe4,
-	0xfe, 0x0b, 0x00, 0x6b,
+	0x1c, 0x19, 0x03, 0xfe, 0x90, 0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10,
+	0xfe, 0x4e, 0xe4, 0xc9, 0x6b, 0xfe, 0x2e, 0x19, 0x03, 0xfe, 0x92, 0x00,
+	0xfe, 0x02, 0xe6, 0x1a, 0xe5, 0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x6b,
 	0xfe, 0x40, 0x19, 0x03, 0xfe, 0x94, 0x00, 0xfe, 0x02, 0xe6, 0x1f, 0xfe,
-	0x08, 0x10, 0x03, 0xfe,
-	0x96, 0x00, 0xfe, 0x02, 0xe6, 0x6d, 0xfe, 0x4e, 0x45, 0xea, 0xba, 0xff,
-	0x04, 0x68, 0x54, 0xe7,
-	0x1e, 0x6e, 0xfe, 0x08, 0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c, 0xfe,
-	0x1a, 0xf4, 0xfe, 0x00,
+	0x08, 0x10, 0x03, 0xfe, 0x96, 0x00, 0xfe, 0x02, 0xe6, 0x6d, 0xfe, 0x4e,
+	0x45, 0xea, 0xba, 0xff, 0x04, 0x68, 0x54, 0xe7, 0x1e, 0x6e, 0xfe, 0x08,
+	0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c, 0xfe, 0x1a, 0xf4, 0xfe, 0x00,
 	0x04, 0xea, 0xfe, 0x48, 0xf4, 0x19, 0x7a, 0xfe, 0x74, 0x19, 0x0f, 0x19,
-	0x04, 0x07, 0x7e, 0xfe,
-	0x5a, 0xf0, 0xfe, 0x84, 0x19, 0x25, 0xfe, 0x09, 0x00, 0xfe, 0x34, 0x10,
-	0x07, 0x1a, 0xfe, 0x5a,
-	0xf0, 0xfe, 0x92, 0x19, 0x25, 0xca, 0xfe, 0x26, 0x10, 0x07, 0x19, 0x66,
-	0x25, 0x6d, 0xe5, 0x07,
+	0x04, 0x07, 0x7e, 0xfe, 0x5a, 0xf0, 0xfe, 0x84, 0x19, 0x25, 0xfe, 0x09,
+	0x00, 0xfe, 0x34, 0x10, 0x07, 0x1a, 0xfe, 0x5a, 0xf0, 0xfe, 0x92, 0x19,
+	0x25, 0xca, 0xfe, 0x26, 0x10, 0x07, 0x19, 0x66, 0x25, 0x6d, 0xe5, 0x07,
 	0x0a, 0x66, 0x25, 0x9e, 0xfe, 0x0e, 0x10, 0x07, 0x06, 0x66, 0x25, 0x59,
-	0xa9, 0xb8, 0x04, 0x15,
-	0xfe, 0x09, 0x00, 0x01, 0x36, 0xfe, 0x04, 0xfe, 0x81, 0x03, 0x83, 0xfe,
-	0x40, 0x5c, 0x04, 0x1c,
-	0xf7, 0xfe, 0x14, 0xf0, 0x0b, 0x27, 0xfe, 0xd6, 0x19, 0x1c, 0xf7, 0x7b,
-	0xf7, 0xfe, 0x82, 0xf0,
+	0xa9, 0xb8, 0x04, 0x15, 0xfe, 0x09, 0x00, 0x01, 0x36, 0xfe, 0x04, 0xfe,
+	0x81, 0x03, 0x83, 0xfe, 0x40, 0x5c, 0x04, 0x1c, 0xf7, 0xfe, 0x14, 0xf0,
+	0x0b, 0x27, 0xfe, 0xd6, 0x19, 0x1c, 0xf7, 0x7b, 0xf7, 0xfe, 0x82, 0xf0,
 	0xfe, 0xda, 0x19, 0x04, 0xff, 0xcc, 0x00, 0x00,
 };
 
@@ -11653,796 +11125,533 @@ static ADV_DCNT _adv_asc38C0800_chksum = 0x050D3FD8UL;	/* Expanded little-endian
 /* Microcode buffer is kept after initialization for error recovery. */
 static unsigned char _adv_asc38C1600_buf[] = {
 	0x00, 0x00, 0x00, 0xf2, 0x00, 0x16, 0x00, 0xfc, 0x00, 0x10, 0x00, 0xf0,
-	0x18, 0xe4, 0x01, 0x00,
-	0x04, 0x1e, 0x48, 0xe4, 0x03, 0xf6, 0xf7, 0x13, 0x2e, 0x1e, 0x02, 0x00,
-	0x07, 0x17, 0xc0, 0x5f,
-	0x00, 0xfa, 0xff, 0xff, 0x04, 0x00, 0x00, 0xf6, 0x09, 0xe7, 0x82, 0xe7,
-	0x85, 0xf0, 0x86, 0xf0,
+	0x18, 0xe4, 0x01, 0x00, 0x04, 0x1e, 0x48, 0xe4, 0x03, 0xf6, 0xf7, 0x13,
+	0x2e, 0x1e, 0x02, 0x00, 0x07, 0x17, 0xc0, 0x5f, 0x00, 0xfa, 0xff, 0xff,
+	0x04, 0x00, 0x00, 0xf6, 0x09, 0xe7, 0x82, 0xe7, 0x85, 0xf0, 0x86, 0xf0,
 	0x4e, 0x10, 0x9e, 0xe7, 0xff, 0x00, 0x55, 0xf0, 0x01, 0xf6, 0x03, 0x00,
-	0x98, 0x57, 0x01, 0xe6,
-	0x00, 0xea, 0x00, 0xec, 0x01, 0xfa, 0x18, 0xf4, 0x08, 0x00, 0xf0, 0x1d,
-	0x38, 0x54, 0x32, 0xf0,
-	0x10, 0x00, 0xc2, 0x0e, 0x1e, 0xf0, 0xd5, 0xf0, 0xbc, 0x00, 0x4b, 0xe4,
-	0x00, 0xe6, 0xb1, 0xf0,
+	0x98, 0x57, 0x01, 0xe6, 0x00, 0xea, 0x00, 0xec, 0x01, 0xfa, 0x18, 0xf4,
+	0x08, 0x00, 0xf0, 0x1d, 0x38, 0x54, 0x32, 0xf0, 0x10, 0x00, 0xc2, 0x0e,
+	0x1e, 0xf0, 0xd5, 0xf0, 0xbc, 0x00, 0x4b, 0xe4, 0x00, 0xe6, 0xb1, 0xf0,
 	0xb4, 0x00, 0x02, 0x13, 0x3e, 0x1c, 0xc8, 0x47, 0x3e, 0x00, 0xd8, 0x01,
-	0x06, 0x13, 0x0c, 0x1c,
-	0x5e, 0x1e, 0x00, 0x57, 0xc8, 0x57, 0x01, 0xfc, 0xbc, 0x0e, 0xa2, 0x12,
-	0xb9, 0x54, 0x00, 0x80,
-	0x62, 0x0a, 0x5a, 0x12, 0xc8, 0x15, 0x3e, 0x1e, 0x18, 0x40, 0xbd, 0x56,
-	0x03, 0xe6, 0x01, 0xea,
+	0x06, 0x13, 0x0c, 0x1c, 0x5e, 0x1e, 0x00, 0x57, 0xc8, 0x57, 0x01, 0xfc,
+	0xbc, 0x0e, 0xa2, 0x12, 0xb9, 0x54, 0x00, 0x80, 0x62, 0x0a, 0x5a, 0x12,
+	0xc8, 0x15, 0x3e, 0x1e, 0x18, 0x40, 0xbd, 0x56, 0x03, 0xe6, 0x01, 0xea,
 	0x5c, 0xf0, 0x0f, 0x00, 0x20, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12,
-	0x04, 0x13, 0xbb, 0x55,
-	0x3c, 0x56, 0x3e, 0x57, 0x03, 0x58, 0x4a, 0xe4, 0x40, 0x00, 0xb6, 0x00,
-	0xbb, 0x00, 0xc0, 0x00,
-	0x00, 0x01, 0x01, 0x01, 0x3e, 0x01, 0x58, 0x0a, 0x44, 0x10, 0x0a, 0x12,
-	0x4c, 0x1c, 0x4e, 0x1c,
+	0x04, 0x13, 0xbb, 0x55, 0x3c, 0x56, 0x3e, 0x57, 0x03, 0x58, 0x4a, 0xe4,
+	0x40, 0x00, 0xb6, 0x00, 0xbb, 0x00, 0xc0, 0x00, 0x00, 0x01, 0x01, 0x01,
+	0x3e, 0x01, 0x58, 0x0a, 0x44, 0x10, 0x0a, 0x12, 0x4c, 0x1c, 0x4e, 0x1c,
 	0x02, 0x4a, 0x30, 0xe4, 0x05, 0xe6, 0x0c, 0x00, 0x3c, 0x00, 0x80, 0x00,
-	0x24, 0x01, 0x3c, 0x01,
-	0x68, 0x01, 0x6a, 0x01, 0x70, 0x01, 0x72, 0x01, 0x74, 0x01, 0x76, 0x01,
-	0x78, 0x01, 0x7c, 0x01,
-	0xc6, 0x0e, 0x0c, 0x10, 0xac, 0x12, 0xae, 0x12, 0x16, 0x1a, 0x32, 0x1c,
-	0x6e, 0x1e, 0x02, 0x48,
+	0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01, 0x70, 0x01, 0x72, 0x01,
+	0x74, 0x01, 0x76, 0x01, 0x78, 0x01, 0x7c, 0x01, 0xc6, 0x0e, 0x0c, 0x10,
+	0xac, 0x12, 0xae, 0x12, 0x16, 0x1a, 0x32, 0x1c, 0x6e, 0x1e, 0x02, 0x48,
 	0x3a, 0x55, 0xc9, 0x57, 0x02, 0xee, 0x5b, 0xf0, 0x03, 0xf7, 0x06, 0xf7,
-	0x03, 0xfc, 0x06, 0x00,
-	0x1e, 0x00, 0xbe, 0x00, 0xe1, 0x00, 0x0c, 0x12, 0x18, 0x1a, 0x70, 0x1a,
-	0x30, 0x1c, 0x38, 0x1c,
-	0x10, 0x44, 0x00, 0x4c, 0xb0, 0x57, 0x40, 0x5c, 0x4d, 0xe4, 0x04, 0xea,
-	0x5d, 0xf0, 0xa7, 0xf0,
+	0x03, 0xfc, 0x06, 0x00, 0x1e, 0x00, 0xbe, 0x00, 0xe1, 0x00, 0x0c, 0x12,
+	0x18, 0x1a, 0x70, 0x1a, 0x30, 0x1c, 0x38, 0x1c, 0x10, 0x44, 0x00, 0x4c,
+	0xb0, 0x57, 0x40, 0x5c, 0x4d, 0xe4, 0x04, 0xea, 0x5d, 0xf0, 0xa7, 0xf0,
 	0x04, 0xf6, 0x02, 0xfc, 0x05, 0x00, 0x09, 0x00, 0x19, 0x00, 0x32, 0x00,
-	0x33, 0x00, 0x34, 0x00,
-	0x36, 0x00, 0x98, 0x00, 0x9e, 0x00, 0xcc, 0x00, 0x20, 0x01, 0x4e, 0x01,
-	0x79, 0x01, 0x3c, 0x09,
-	0x68, 0x0d, 0x02, 0x10, 0x04, 0x10, 0x3a, 0x10, 0x08, 0x12, 0x0a, 0x13,
-	0x40, 0x16, 0x50, 0x16,
+	0x33, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00, 0x9e, 0x00, 0xcc, 0x00,
+	0x20, 0x01, 0x4e, 0x01, 0x79, 0x01, 0x3c, 0x09, 0x68, 0x0d, 0x02, 0x10,
+	0x04, 0x10, 0x3a, 0x10, 0x08, 0x12, 0x0a, 0x13, 0x40, 0x16, 0x50, 0x16,
 	0x00, 0x17, 0x4a, 0x19, 0x00, 0x4e, 0x00, 0x54, 0x01, 0x58, 0x00, 0xdc,
-	0x05, 0xf0, 0x09, 0xf0,
-	0x59, 0xf0, 0xb8, 0xf0, 0x48, 0xf4, 0x0e, 0xf7, 0x0a, 0x00, 0x9b, 0x00,
-	0x9c, 0x00, 0xa4, 0x00,
-	0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe7, 0x00, 0xf0, 0x03, 0x69, 0x08,
-	0xe9, 0x09, 0x5c, 0x0c,
+	0x05, 0xf0, 0x09, 0xf0, 0x59, 0xf0, 0xb8, 0xf0, 0x48, 0xf4, 0x0e, 0xf7,
+	0x0a, 0x00, 0x9b, 0x00, 0x9c, 0x00, 0xa4, 0x00, 0xb5, 0x00, 0xba, 0x00,
+	0xd0, 0x00, 0xe7, 0x00, 0xf0, 0x03, 0x69, 0x08, 0xe9, 0x09, 0x5c, 0x0c,
 	0xb6, 0x12, 0xbc, 0x19, 0xd8, 0x1b, 0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c,
-	0x42, 0x1d, 0x08, 0x44,
-	0x38, 0x44, 0x91, 0x44, 0x0a, 0x45, 0x48, 0x46, 0x89, 0x48, 0x68, 0x54,
-	0x83, 0x55, 0x83, 0x59,
-	0x31, 0xe4, 0x02, 0xe6, 0x07, 0xf0, 0x08, 0xf0, 0x0b, 0xf0, 0x0c, 0xf0,
-	0x4b, 0xf4, 0x04, 0xf8,
+	0x42, 0x1d, 0x08, 0x44, 0x38, 0x44, 0x91, 0x44, 0x0a, 0x45, 0x48, 0x46,
+	0x89, 0x48, 0x68, 0x54, 0x83, 0x55, 0x83, 0x59, 0x31, 0xe4, 0x02, 0xe6,
+	0x07, 0xf0, 0x08, 0xf0, 0x0b, 0xf0, 0x0c, 0xf0, 0x4b, 0xf4, 0x04, 0xf8,
 	0x05, 0xf8, 0x02, 0xfa, 0x03, 0xfa, 0x04, 0xfc, 0x05, 0xfc, 0x07, 0x00,
-	0xa8, 0x00, 0xaa, 0x00,
-	0xb9, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0x22, 0x01, 0x26, 0x01, 0x60, 0x01,
-	0x7a, 0x01, 0x82, 0x01,
-	0xc8, 0x01, 0xca, 0x01, 0x86, 0x02, 0x6a, 0x03, 0x18, 0x05, 0xb2, 0x07,
-	0x68, 0x08, 0x10, 0x0d,
+	0xa8, 0x00, 0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0x22, 0x01,
+	0x26, 0x01, 0x60, 0x01, 0x7a, 0x01, 0x82, 0x01, 0xc8, 0x01, 0xca, 0x01,
+	0x86, 0x02, 0x6a, 0x03, 0x18, 0x05, 0xb2, 0x07, 0x68, 0x08, 0x10, 0x0d,
 	0x06, 0x10, 0x0a, 0x10, 0x0e, 0x10, 0x12, 0x10, 0x60, 0x10, 0xed, 0x10,
-	0xf3, 0x10, 0x06, 0x12,
-	0x10, 0x12, 0x1e, 0x12, 0x0c, 0x13, 0x0e, 0x13, 0x10, 0x13, 0xfe, 0x9c,
-	0xf0, 0x35, 0x05, 0xfe,
-	0xec, 0x0e, 0xff, 0x10, 0x00, 0x00, 0xe9, 0xfe, 0x34, 0x1f, 0x00, 0xe8,
-	0xfe, 0x88, 0x01, 0xff,
+	0xf3, 0x10, 0x06, 0x12, 0x10, 0x12, 0x1e, 0x12, 0x0c, 0x13, 0x0e, 0x13,
+	0x10, 0x13, 0xfe, 0x9c, 0xf0, 0x35, 0x05, 0xfe, 0xec, 0x0e, 0xff, 0x10,
+	0x00, 0x00, 0xe9, 0xfe, 0x34, 0x1f, 0x00, 0xe8, 0xfe, 0x88, 0x01, 0xff,
 	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
-	0x00, 0xfe, 0x57, 0x24,
-	0x00, 0xfe, 0x4c, 0x00, 0x65, 0xff, 0x04, 0x00, 0x00, 0x1a, 0xff, 0x09,
-	0x00, 0x00, 0xff, 0x08,
-	0x01, 0x01, 0xff, 0x08, 0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10,
-	0xff, 0xff, 0xff, 0x13,
+	0x00, 0xfe, 0x57, 0x24, 0x00, 0xfe, 0x4c, 0x00, 0x65, 0xff, 0x04, 0x00,
+	0x00, 0x1a, 0xff, 0x09, 0x00, 0x00, 0xff, 0x08, 0x01, 0x01, 0xff, 0x08,
+	0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10, 0xff, 0xff, 0xff, 0x13,
 	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
-	0xfe, 0x04, 0xf7, 0xe8,
-	0x37, 0x7d, 0x0d, 0x01, 0xfe, 0x4a, 0x11, 0xfe, 0x04, 0xf7, 0xe8, 0x7d,
-	0x0d, 0x51, 0x37, 0xfe,
-	0x3d, 0xf0, 0xfe, 0x0c, 0x02, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x91, 0xf0,
-	0xfe, 0xf8, 0x01, 0xfe,
+	0xfe, 0x04, 0xf7, 0xe8, 0x37, 0x7d, 0x0d, 0x01, 0xfe, 0x4a, 0x11, 0xfe,
+	0x04, 0xf7, 0xe8, 0x7d, 0x0d, 0x51, 0x37, 0xfe, 0x3d, 0xf0, 0xfe, 0x0c,
+	0x02, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x91, 0xf0, 0xfe, 0xf8, 0x01, 0xfe,
 	0x90, 0xf0, 0xfe, 0xf8, 0x01, 0xfe, 0x8f, 0xf0, 0xbc, 0x03, 0x67, 0x4d,
-	0x05, 0xfe, 0x08, 0x0f,
-	0x01, 0xfe, 0x78, 0x0f, 0xfe, 0xdd, 0x12, 0x05, 0xfe, 0x0e, 0x03, 0xfe,
-	0x28, 0x1c, 0x03, 0xfe,
-	0xa6, 0x00, 0xfe, 0xd1, 0x12, 0x3e, 0x22, 0xfe, 0xa6, 0x00, 0xac, 0xfe,
-	0x48, 0xf0, 0xfe, 0x90,
+	0x05, 0xfe, 0x08, 0x0f, 0x01, 0xfe, 0x78, 0x0f, 0xfe, 0xdd, 0x12, 0x05,
+	0xfe, 0x0e, 0x03, 0xfe, 0x28, 0x1c, 0x03, 0xfe, 0xa6, 0x00, 0xfe, 0xd1,
+	0x12, 0x3e, 0x22, 0xfe, 0xa6, 0x00, 0xac, 0xfe, 0x48, 0xf0, 0xfe, 0x90,
 	0x02, 0xfe, 0x49, 0xf0, 0xfe, 0xaa, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xc8,
-	0x02, 0xfe, 0x46, 0xf0,
-	0xfe, 0x5a, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x60, 0x02, 0xfe, 0x43, 0xf0,
-	0xfe, 0x4e, 0x02, 0xfe,
-	0x44, 0xf0, 0xfe, 0x52, 0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x56, 0x02, 0x1c,
-	0x0d, 0xa2, 0x1c, 0x07,
+	0x02, 0xfe, 0x46, 0xf0, 0xfe, 0x5a, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x60,
+	0x02, 0xfe, 0x43, 0xf0, 0xfe, 0x4e, 0x02, 0xfe, 0x44, 0xf0, 0xfe, 0x52,
+	0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x56, 0x02, 0x1c, 0x0d, 0xa2, 0x1c, 0x07,
 	0x22, 0xb7, 0x05, 0x35, 0xfe, 0x00, 0x1c, 0xfe, 0xf1, 0x10, 0xfe, 0x02,
-	0x1c, 0xf5, 0xfe, 0x1e,
-	0x1c, 0xfe, 0xe9, 0x10, 0x01, 0x5f, 0xfe, 0xe7, 0x10, 0xfe, 0x06, 0xfc,
-	0xde, 0x0a, 0x81, 0x01,
-	0xa3, 0x05, 0x35, 0x1f, 0x95, 0x47, 0xb8, 0x01, 0xfe, 0xe4, 0x11, 0x0a,
-	0x81, 0x01, 0x5c, 0xfe,
+	0x1c, 0xf5, 0xfe, 0x1e, 0x1c, 0xfe, 0xe9, 0x10, 0x01, 0x5f, 0xfe, 0xe7,
+	0x10, 0xfe, 0x06, 0xfc, 0xde, 0x0a, 0x81, 0x01, 0xa3, 0x05, 0x35, 0x1f,
+	0x95, 0x47, 0xb8, 0x01, 0xfe, 0xe4, 0x11, 0x0a, 0x81, 0x01, 0x5c, 0xfe,
 	0xbd, 0x10, 0x0a, 0x81, 0x01, 0x5c, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c,
-	0xfe, 0x58, 0x1c, 0x1c,
-	0x07, 0x22, 0xb7, 0x37, 0x2a, 0x35, 0xfe, 0x3d, 0xf0, 0xfe, 0x0c, 0x02,
-	0x2b, 0xfe, 0x9e, 0x02,
-	0xfe, 0x5a, 0x1c, 0xfe, 0x12, 0x1c, 0xfe, 0x14, 0x1c, 0x1f, 0xfe, 0x30,
-	0x00, 0x47, 0xb8, 0x01,
+	0xfe, 0x58, 0x1c, 0x1c, 0x07, 0x22, 0xb7, 0x37, 0x2a, 0x35, 0xfe, 0x3d,
+	0xf0, 0xfe, 0x0c, 0x02, 0x2b, 0xfe, 0x9e, 0x02, 0xfe, 0x5a, 0x1c, 0xfe,
+	0x12, 0x1c, 0xfe, 0x14, 0x1c, 0x1f, 0xfe, 0x30, 0x00, 0x47, 0xb8, 0x01,
 	0xfe, 0xd4, 0x11, 0x1c, 0x07, 0x22, 0xb7, 0x05, 0xe9, 0x21, 0x2c, 0x09,
-	0x1a, 0x31, 0xfe, 0x69,
-	0x10, 0x1c, 0x07, 0x22, 0xb7, 0xfe, 0x04, 0xec, 0x2c, 0x60, 0x01, 0xfe,
-	0x1e, 0x1e, 0x20, 0x2c,
-	0xfe, 0x05, 0xf6, 0xde, 0x01, 0xfe, 0x62, 0x1b, 0x01, 0x0c, 0x61, 0x4a,
-	0x44, 0x15, 0x56, 0x51,
+	0x1a, 0x31, 0xfe, 0x69, 0x10, 0x1c, 0x07, 0x22, 0xb7, 0xfe, 0x04, 0xec,
+	0x2c, 0x60, 0x01, 0xfe, 0x1e, 0x1e, 0x20, 0x2c, 0xfe, 0x05, 0xf6, 0xde,
+	0x01, 0xfe, 0x62, 0x1b, 0x01, 0x0c, 0x61, 0x4a, 0x44, 0x15, 0x56, 0x51,
 	0x01, 0xfe, 0x9e, 0x1e, 0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x0a, 0x57,
-	0x01, 0x18, 0x09, 0x00,
-	0x36, 0x01, 0x85, 0xfe, 0x18, 0x10, 0xfe, 0x41, 0x58, 0x0a, 0xba, 0x01,
-	0x18, 0xfe, 0xc8, 0x54,
-	0x7b, 0xfe, 0x1c, 0x03, 0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x37, 0x60,
-	0xfe, 0x02, 0xe8, 0x30,
+	0x01, 0x18, 0x09, 0x00, 0x36, 0x01, 0x85, 0xfe, 0x18, 0x10, 0xfe, 0x41,
+	0x58, 0x0a, 0xba, 0x01, 0x18, 0xfe, 0xc8, 0x54, 0x7b, 0xfe, 0x1c, 0x03,
+	0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x37, 0x60, 0xfe, 0x02, 0xe8, 0x30,
 	0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43, 0xfe, 0x77, 0x57, 0xfe, 0x27, 0xf0,
-	0xfe, 0xe4, 0x01, 0xfe,
-	0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x40, 0x1c, 0x2a, 0xeb, 0xfe,
-	0x26, 0xf0, 0xfe, 0x66,
-	0x03, 0xfe, 0xa0, 0xf0, 0xfe, 0x54, 0x03, 0xfe, 0x11, 0xf0, 0xbc, 0xfe,
-	0xef, 0x10, 0xfe, 0x9f,
+	0xfe, 0xe4, 0x01, 0xfe, 0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x40,
+	0x1c, 0x2a, 0xeb, 0xfe, 0x26, 0xf0, 0xfe, 0x66, 0x03, 0xfe, 0xa0, 0xf0,
+	0xfe, 0x54, 0x03, 0xfe, 0x11, 0xf0, 0xbc, 0xfe, 0xef, 0x10, 0xfe, 0x9f,
 	0xf0, 0xfe, 0x74, 0x03, 0xfe, 0x46, 0x1c, 0x19, 0xfe, 0x11, 0x00, 0x05,
-	0x70, 0x37, 0xfe, 0x48,
-	0x1c, 0xfe, 0x46, 0x1c, 0x01, 0x0c, 0x06, 0x28, 0xfe, 0x18, 0x13, 0x26,
-	0x21, 0xb9, 0xc7, 0x20,
-	0xb9, 0x0a, 0x57, 0x01, 0x18, 0xc7, 0x89, 0x01, 0xfe, 0xc8, 0x1a, 0x15,
-	0xe1, 0x2a, 0xeb, 0xfe,
+	0x70, 0x37, 0xfe, 0x48, 0x1c, 0xfe, 0x46, 0x1c, 0x01, 0x0c, 0x06, 0x28,
+	0xfe, 0x18, 0x13, 0x26, 0x21, 0xb9, 0xc7, 0x20, 0xb9, 0x0a, 0x57, 0x01,
+	0x18, 0xc7, 0x89, 0x01, 0xfe, 0xc8, 0x1a, 0x15, 0xe1, 0x2a, 0xeb, 0xfe,
 	0x01, 0xf0, 0xeb, 0xfe, 0x82, 0xf0, 0xfe, 0xa4, 0x03, 0xfe, 0x9c, 0x32,
-	0x15, 0xfe, 0xe4, 0x00,
-	0x2f, 0xfe, 0xb6, 0x03, 0x2a, 0x3c, 0x16, 0xfe, 0xc6, 0x03, 0x01, 0x41,
-	0xfe, 0x06, 0xf0, 0xfe,
-	0xd6, 0x03, 0xaf, 0xa0, 0xfe, 0x0a, 0xf0, 0xfe, 0xa2, 0x07, 0x05, 0x29,
-	0x03, 0x81, 0x1e, 0x1b,
+	0x15, 0xfe, 0xe4, 0x00, 0x2f, 0xfe, 0xb6, 0x03, 0x2a, 0x3c, 0x16, 0xfe,
+	0xc6, 0x03, 0x01, 0x41, 0xfe, 0x06, 0xf0, 0xfe, 0xd6, 0x03, 0xaf, 0xa0,
+	0xfe, 0x0a, 0xf0, 0xfe, 0xa2, 0x07, 0x05, 0x29, 0x03, 0x81, 0x1e, 0x1b,
 	0xfe, 0x24, 0x05, 0x1f, 0x63, 0x01, 0x42, 0x8f, 0xfe, 0x70, 0x02, 0x05,
-	0xea, 0xfe, 0x46, 0x1c,
-	0x37, 0x7d, 0x1d, 0xfe, 0x67, 0x1b, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57,
-	0xfe, 0x48, 0x1c, 0x75,
-	0x01, 0xa6, 0x86, 0x0a, 0x57, 0x01, 0x18, 0x09, 0x00, 0x1b, 0xec, 0x0a,
-	0xe1, 0x01, 0x18, 0x77,
+	0xea, 0xfe, 0x46, 0x1c, 0x37, 0x7d, 0x1d, 0xfe, 0x67, 0x1b, 0xfe, 0xbf,
+	0x57, 0xfe, 0x77, 0x57, 0xfe, 0x48, 0x1c, 0x75, 0x01, 0xa6, 0x86, 0x0a,
+	0x57, 0x01, 0x18, 0x09, 0x00, 0x1b, 0xec, 0x0a, 0xe1, 0x01, 0x18, 0x77,
 	0x50, 0x40, 0x8d, 0x30, 0x03, 0x81, 0x1e, 0xf8, 0x1f, 0x63, 0x01, 0x42,
-	0x8f, 0xfe, 0x70, 0x02,
-	0x05, 0xea, 0xd7, 0x99, 0xd8, 0x9c, 0x2a, 0x29, 0x2f, 0xfe, 0x4e, 0x04,
-	0x16, 0xfe, 0x4a, 0x04,
-	0x7e, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x54, 0x12, 0x32, 0xff,
-	0x02, 0x00, 0x10, 0x01,
+	0x8f, 0xfe, 0x70, 0x02, 0x05, 0xea, 0xd7, 0x99, 0xd8, 0x9c, 0x2a, 0x29,
+	0x2f, 0xfe, 0x4e, 0x04, 0x16, 0xfe, 0x4a, 0x04, 0x7e, 0xfe, 0xa0, 0x00,
+	0xfe, 0x9b, 0x57, 0xfe, 0x54, 0x12, 0x32, 0xff, 0x02, 0x00, 0x10, 0x01,
 	0x08, 0x16, 0xfe, 0x02, 0x05, 0x32, 0x01, 0x08, 0x16, 0x29, 0x27, 0x25,
-	0xee, 0xfe, 0x4c, 0x44,
-	0xfe, 0x58, 0x12, 0x50, 0xfe, 0x44, 0x48, 0x13, 0x34, 0xfe, 0x4c, 0x54,
-	0x7b, 0xec, 0x60, 0x8d,
-	0x30, 0x01, 0xfe, 0x4e, 0x1e, 0xfe, 0x48, 0x47, 0xfe, 0x7c, 0x13, 0x01,
-	0x0c, 0x06, 0x28, 0xfe,
+	0xee, 0xfe, 0x4c, 0x44, 0xfe, 0x58, 0x12, 0x50, 0xfe, 0x44, 0x48, 0x13,
+	0x34, 0xfe, 0x4c, 0x54, 0x7b, 0xec, 0x60, 0x8d, 0x30, 0x01, 0xfe, 0x4e,
+	0x1e, 0xfe, 0x48, 0x47, 0xfe, 0x7c, 0x13, 0x01, 0x0c, 0x06, 0x28, 0xfe,
 	0x32, 0x13, 0x01, 0x43, 0x09, 0x9b, 0xfe, 0x68, 0x13, 0xfe, 0x26, 0x10,
-	0x13, 0x34, 0xfe, 0x4c,
-	0x54, 0x7b, 0xec, 0x01, 0xfe, 0x4e, 0x1e, 0xfe, 0x48, 0x47, 0xfe, 0x54,
-	0x13, 0x01, 0x0c, 0x06,
-	0x28, 0xa5, 0x01, 0x43, 0x09, 0x9b, 0xfe, 0x40, 0x13, 0x01, 0x0c, 0x06,
-	0x28, 0xf9, 0x1f, 0x7f,
+	0x13, 0x34, 0xfe, 0x4c, 0x54, 0x7b, 0xec, 0x01, 0xfe, 0x4e, 0x1e, 0xfe,
+	0x48, 0x47, 0xfe, 0x54, 0x13, 0x01, 0x0c, 0x06, 0x28, 0xa5, 0x01, 0x43,
+	0x09, 0x9b, 0xfe, 0x40, 0x13, 0x01, 0x0c, 0x06, 0x28, 0xf9, 0x1f, 0x7f,
 	0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe, 0x0d, 0x00, 0x01, 0x42, 0x8f,
-	0xfe, 0xa4, 0x0e, 0x05,
-	0x29, 0x32, 0x15, 0xfe, 0xe6, 0x00, 0x0f, 0xfe, 0x1c, 0x90, 0x04, 0xfe,
-	0x9c, 0x93, 0x3a, 0x0b,
-	0x0e, 0x8b, 0x02, 0x1f, 0x7f, 0x01, 0x42, 0x05, 0x35, 0xfe, 0x42, 0x5b,
-	0x7d, 0x1d, 0xfe, 0x46,
+	0xfe, 0xa4, 0x0e, 0x05, 0x29, 0x32, 0x15, 0xfe, 0xe6, 0x00, 0x0f, 0xfe,
+	0x1c, 0x90, 0x04, 0xfe, 0x9c, 0x93, 0x3a, 0x0b, 0x0e, 0x8b, 0x02, 0x1f,
+	0x7f, 0x01, 0x42, 0x05, 0x35, 0xfe, 0x42, 0x5b, 0x7d, 0x1d, 0xfe, 0x46,
 	0x59, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57, 0x0f, 0xfe, 0x87, 0x80, 0x04,
-	0xfe, 0x87, 0x83, 0xfe,
-	0xc9, 0x47, 0x0b, 0x0e, 0xd0, 0x65, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x98,
-	0x13, 0x0f, 0xfe, 0x20,
-	0x80, 0x04, 0xfe, 0xa0, 0x83, 0x33, 0x0b, 0x0e, 0x09, 0x1d, 0xfe, 0x84,
-	0x12, 0x01, 0x38, 0x06,
+	0xfe, 0x87, 0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0xd0, 0x65, 0x01, 0x0c,
+	0x06, 0x0d, 0xfe, 0x98, 0x13, 0x0f, 0xfe, 0x20, 0x80, 0x04, 0xfe, 0xa0,
+	0x83, 0x33, 0x0b, 0x0e, 0x09, 0x1d, 0xfe, 0x84, 0x12, 0x01, 0x38, 0x06,
 	0x07, 0xfe, 0x70, 0x13, 0x03, 0xfe, 0xa2, 0x00, 0x1e, 0x1b, 0xfe, 0xda,
-	0x05, 0xd0, 0x54, 0x01,
-	0x38, 0x06, 0x0d, 0xfe, 0x58, 0x13, 0x03, 0xfe, 0xa0, 0x00, 0x1e, 0xfe,
-	0x50, 0x12, 0x5e, 0xff,
-	0x02, 0x00, 0x10, 0x2f, 0xfe, 0x90, 0x05, 0x2a, 0x3c, 0xcc, 0xff, 0x02,
-	0x00, 0x10, 0x2f, 0xfe,
+	0x05, 0xd0, 0x54, 0x01, 0x38, 0x06, 0x0d, 0xfe, 0x58, 0x13, 0x03, 0xfe,
+	0xa0, 0x00, 0x1e, 0xfe, 0x50, 0x12, 0x5e, 0xff, 0x02, 0x00, 0x10, 0x2f,
+	0xfe, 0x90, 0x05, 0x2a, 0x3c, 0xcc, 0xff, 0x02, 0x00, 0x10, 0x2f, 0xfe,
 	0x9e, 0x05, 0x17, 0xfe, 0xf4, 0x05, 0x15, 0xfe, 0xe3, 0x00, 0x26, 0x01,
-	0x38, 0xfe, 0x4a, 0xf0,
-	0xfe, 0xc0, 0x05, 0xfe, 0x49, 0xf0, 0xfe, 0xba, 0x05, 0x71, 0x2e, 0xfe,
-	0x21, 0x00, 0xf1, 0x2e,
-	0xfe, 0x22, 0x00, 0xa2, 0x2e, 0x4a, 0xfe, 0x09, 0x48, 0xff, 0x02, 0x00,
-	0x10, 0x2f, 0xfe, 0xd0,
+	0x38, 0xfe, 0x4a, 0xf0, 0xfe, 0xc0, 0x05, 0xfe, 0x49, 0xf0, 0xfe, 0xba,
+	0x05, 0x71, 0x2e, 0xfe, 0x21, 0x00, 0xf1, 0x2e, 0xfe, 0x22, 0x00, 0xa2,
+	0x2e, 0x4a, 0xfe, 0x09, 0x48, 0xff, 0x02, 0x00, 0x10, 0x2f, 0xfe, 0xd0,
 	0x05, 0x17, 0xfe, 0xf4, 0x05, 0xfe, 0xe2, 0x08, 0x01, 0x38, 0x06, 0xfe,
-	0x1c, 0x00, 0x4d, 0x01,
-	0xa7, 0x2e, 0x07, 0x20, 0xe4, 0x47, 0xfe, 0x27, 0x01, 0x01, 0x0c, 0x06,
-	0x28, 0xfe, 0x24, 0x12,
-	0x3e, 0x01, 0x84, 0x1f, 0x7f, 0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe,
-	0x0d, 0x00, 0x01, 0x42,
+	0x1c, 0x00, 0x4d, 0x01, 0xa7, 0x2e, 0x07, 0x20, 0xe4, 0x47, 0xfe, 0x27,
+	0x01, 0x01, 0x0c, 0x06, 0x28, 0xfe, 0x24, 0x12, 0x3e, 0x01, 0x84, 0x1f,
+	0x7f, 0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe, 0x0d, 0x00, 0x01, 0x42,
 	0x8f, 0xfe, 0xa4, 0x0e, 0x05, 0x29, 0x03, 0xe6, 0x1e, 0xfe, 0xca, 0x13,
-	0x03, 0xb6, 0x1e, 0xfe,
-	0x40, 0x12, 0x03, 0x66, 0x1e, 0xfe, 0x38, 0x13, 0x3e, 0x01, 0x84, 0x17,
-	0xfe, 0x72, 0x06, 0x0a,
-	0x07, 0x01, 0x38, 0x06, 0x24, 0xfe, 0x02, 0x12, 0x4f, 0x01, 0xfe, 0x56,
-	0x19, 0x16, 0xfe, 0x68,
+	0x03, 0xb6, 0x1e, 0xfe, 0x40, 0x12, 0x03, 0x66, 0x1e, 0xfe, 0x38, 0x13,
+	0x3e, 0x01, 0x84, 0x17, 0xfe, 0x72, 0x06, 0x0a, 0x07, 0x01, 0x38, 0x06,
+	0x24, 0xfe, 0x02, 0x12, 0x4f, 0x01, 0xfe, 0x56, 0x19, 0x16, 0xfe, 0x68,
 	0x06, 0x15, 0x82, 0x01, 0x41, 0x15, 0xe2, 0x03, 0x66, 0x8a, 0x10, 0x66,
-	0x03, 0x9a, 0x1e, 0xfe,
-	0x70, 0x12, 0x03, 0x55, 0x1e, 0xfe, 0x68, 0x13, 0x01, 0xc6, 0x09, 0x12,
-	0x48, 0xfe, 0x92, 0x06,
-	0x2e, 0x12, 0x01, 0xfe, 0xac, 0x1d, 0xfe, 0x43, 0x48, 0x62, 0x80, 0x13,
-	0x58, 0xff, 0x02, 0x00,
+	0x03, 0x9a, 0x1e, 0xfe, 0x70, 0x12, 0x03, 0x55, 0x1e, 0xfe, 0x68, 0x13,
+	0x01, 0xc6, 0x09, 0x12, 0x48, 0xfe, 0x92, 0x06, 0x2e, 0x12, 0x01, 0xfe,
+	0xac, 0x1d, 0xfe, 0x43, 0x48, 0x62, 0x80, 0x13, 0x58, 0xff, 0x02, 0x00,
 	0x57, 0x52, 0xad, 0x23, 0x3f, 0x4e, 0x62, 0x49, 0x3e, 0x01, 0x84, 0x17,
-	0xfe, 0xea, 0x06, 0x01,
-	0x38, 0x06, 0x12, 0xf7, 0x45, 0x0a, 0x95, 0x01, 0xfe, 0x84, 0x19, 0x16,
-	0xfe, 0xe0, 0x06, 0x15,
-	0x82, 0x01, 0x41, 0x15, 0xe2, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x1c, 0x07,
-	0x01, 0x84, 0xfe, 0xae,
+	0xfe, 0xea, 0x06, 0x01, 0x38, 0x06, 0x12, 0xf7, 0x45, 0x0a, 0x95, 0x01,
+	0xfe, 0x84, 0x19, 0x16, 0xfe, 0xe0, 0x06, 0x15, 0x82, 0x01, 0x41, 0x15,
+	0xe2, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x1c, 0x07, 0x01, 0x84, 0xfe, 0xae,
 	0x10, 0x03, 0x6f, 0x1e, 0xfe, 0x9e, 0x13, 0x3e, 0x01, 0x84, 0x03, 0x9a,
-	0x1e, 0xfe, 0x1a, 0x12,
-	0x01, 0x38, 0x06, 0x12, 0xfc, 0x01, 0xc6, 0x01, 0xfe, 0xac, 0x1d, 0xfe,
-	0x43, 0x48, 0x62, 0x80,
-	0xf0, 0x45, 0x0a, 0x95, 0x03, 0xb6, 0x1e, 0xf8, 0x01, 0x38, 0x06, 0x24,
-	0x36, 0xfe, 0x02, 0xf6,
+	0x1e, 0xfe, 0x1a, 0x12, 0x01, 0x38, 0x06, 0x12, 0xfc, 0x01, 0xc6, 0x01,
+	0xfe, 0xac, 0x1d, 0xfe, 0x43, 0x48, 0x62, 0x80, 0xf0, 0x45, 0x0a, 0x95,
+	0x03, 0xb6, 0x1e, 0xf8, 0x01, 0x38, 0x06, 0x24, 0x36, 0xfe, 0x02, 0xf6,
 	0x07, 0x71, 0x78, 0x8c, 0x00, 0x4d, 0x62, 0x49, 0x3e, 0x2d, 0x93, 0x4e,
-	0xd0, 0x0d, 0x17, 0xfe,
-	0x9a, 0x07, 0x01, 0xfe, 0xc0, 0x19, 0x16, 0xfe, 0x90, 0x07, 0x26, 0x20,
-	0x9e, 0x15, 0x82, 0x01,
-	0x41, 0x15, 0xe2, 0x21, 0x9e, 0x09, 0x07, 0xfb, 0x03, 0xe6, 0xfe, 0x58,
-	0x57, 0x10, 0xe6, 0x05,
+	0xd0, 0x0d, 0x17, 0xfe, 0x9a, 0x07, 0x01, 0xfe, 0xc0, 0x19, 0x16, 0xfe,
+	0x90, 0x07, 0x26, 0x20, 0x9e, 0x15, 0x82, 0x01, 0x41, 0x15, 0xe2, 0x21,
+	0x9e, 0x09, 0x07, 0xfb, 0x03, 0xe6, 0xfe, 0x58, 0x57, 0x10, 0xe6, 0x05,
 	0xfe, 0x2a, 0x06, 0x03, 0x6f, 0x8a, 0x10, 0x6f, 0x1c, 0x07, 0x01, 0x84,
-	0xfe, 0x9c, 0x32, 0x5f,
-	0x75, 0x01, 0xa6, 0x86, 0x15, 0xfe, 0xe2, 0x00, 0x2f, 0xed, 0x2a, 0x3c,
-	0xfe, 0x0a, 0xf0, 0xfe,
-	0xce, 0x07, 0xae, 0xfe, 0x96, 0x08, 0xfe, 0x06, 0xf0, 0xfe, 0x9e, 0x08,
-	0xaf, 0xa0, 0x05, 0x29,
+	0xfe, 0x9c, 0x32, 0x5f, 0x75, 0x01, 0xa6, 0x86, 0x15, 0xfe, 0xe2, 0x00,
+	0x2f, 0xed, 0x2a, 0x3c, 0xfe, 0x0a, 0xf0, 0xfe, 0xce, 0x07, 0xae, 0xfe,
+	0x96, 0x08, 0xfe, 0x06, 0xf0, 0xfe, 0x9e, 0x08, 0xaf, 0xa0, 0x05, 0x29,
 	0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x2e, 0x12, 0x14, 0x1d, 0x01, 0x08, 0x14,
-	0x00, 0x01, 0x08, 0x14,
-	0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0xfe, 0x99, 0xa4, 0x01, 0x08,
-	0x14, 0x00, 0x05, 0xfe,
-	0xc6, 0x09, 0x01, 0x76, 0x06, 0x12, 0xfe, 0x3a, 0x12, 0x01, 0x0c, 0x06,
-	0x12, 0xfe, 0x30, 0x13,
+	0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0xfe,
+	0x99, 0xa4, 0x01, 0x08, 0x14, 0x00, 0x05, 0xfe, 0xc6, 0x09, 0x01, 0x76,
+	0x06, 0x12, 0xfe, 0x3a, 0x12, 0x01, 0x0c, 0x06, 0x12, 0xfe, 0x30, 0x13,
 	0x14, 0xfe, 0x1b, 0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x00,
-	0x01, 0x08, 0x14, 0x00,
-	0x01, 0x08, 0x14, 0x07, 0x01, 0x08, 0x14, 0x00, 0x05, 0xef, 0x7c, 0x4a,
-	0x78, 0x4f, 0x0f, 0xfe,
-	0x9a, 0x81, 0x04, 0xfe, 0x9a, 0x83, 0xfe, 0xcb, 0x47, 0x0b, 0x0e, 0x2d,
-	0x28, 0x48, 0xfe, 0x6c,
+	0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x07, 0x01, 0x08, 0x14, 0x00,
+	0x05, 0xef, 0x7c, 0x4a, 0x78, 0x4f, 0x0f, 0xfe, 0x9a, 0x81, 0x04, 0xfe,
+	0x9a, 0x83, 0xfe, 0xcb, 0x47, 0x0b, 0x0e, 0x2d, 0x28, 0x48, 0xfe, 0x6c,
 	0x08, 0x0a, 0x28, 0xfe, 0x09, 0x6f, 0xca, 0xfe, 0xca, 0x45, 0xfe, 0x32,
-	0x12, 0x53, 0x63, 0x4e,
-	0x7c, 0x97, 0x2f, 0xfe, 0x7e, 0x08, 0x2a, 0x3c, 0xfe, 0x0a, 0xf0, 0xfe,
-	0x6c, 0x08, 0xaf, 0xa0,
-	0xae, 0xfe, 0x96, 0x08, 0x05, 0x29, 0x01, 0x41, 0x05, 0xed, 0x14, 0x24,
-	0x05, 0xed, 0xfe, 0x9c,
+	0x12, 0x53, 0x63, 0x4e, 0x7c, 0x97, 0x2f, 0xfe, 0x7e, 0x08, 0x2a, 0x3c,
+	0xfe, 0x0a, 0xf0, 0xfe, 0x6c, 0x08, 0xaf, 0xa0, 0xae, 0xfe, 0x96, 0x08,
+	0x05, 0x29, 0x01, 0x41, 0x05, 0xed, 0x14, 0x24, 0x05, 0xed, 0xfe, 0x9c,
 	0xf7, 0x9f, 0x01, 0xfe, 0xae, 0x1e, 0xfe, 0x18, 0x58, 0x01, 0xfe, 0xbe,
-	0x1e, 0xfe, 0x99, 0x58,
-	0xfe, 0x78, 0x18, 0xfe, 0xf9, 0x18, 0x8e, 0xfe, 0x16, 0x09, 0x10, 0x6a,
-	0x22, 0x6b, 0x01, 0x0c,
-	0x61, 0x54, 0x44, 0x21, 0x2c, 0x09, 0x1a, 0xf8, 0x77, 0x01, 0xfe, 0x7e,
-	0x1e, 0x47, 0x2c, 0x7a,
+	0x1e, 0xfe, 0x99, 0x58, 0xfe, 0x78, 0x18, 0xfe, 0xf9, 0x18, 0x8e, 0xfe,
+	0x16, 0x09, 0x10, 0x6a, 0x22, 0x6b, 0x01, 0x0c, 0x61, 0x54, 0x44, 0x21,
+	0x2c, 0x09, 0x1a, 0xf8, 0x77, 0x01, 0xfe, 0x7e, 0x1e, 0x47, 0x2c, 0x7a,
 	0x30, 0xf0, 0xfe, 0x83, 0xe7, 0xfe, 0x3f, 0x00, 0x71, 0xfe, 0x03, 0x40,
-	0x01, 0x0c, 0x61, 0x65,
-	0x44, 0x01, 0xc2, 0xc8, 0xfe, 0x1f, 0x40, 0x20, 0x6e, 0x01, 0xfe, 0x6a,
-	0x16, 0xfe, 0x08, 0x50,
-	0xfe, 0x8a, 0x50, 0xfe, 0x44, 0x51, 0xfe, 0xc6, 0x51, 0xfe, 0x10, 0x10,
-	0x01, 0xfe, 0xce, 0x1e,
+	0x01, 0x0c, 0x61, 0x65, 0x44, 0x01, 0xc2, 0xc8, 0xfe, 0x1f, 0x40, 0x20,
+	0x6e, 0x01, 0xfe, 0x6a, 0x16, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe,
+	0x44, 0x51, 0xfe, 0xc6, 0x51, 0xfe, 0x10, 0x10, 0x01, 0xfe, 0xce, 0x1e,
 	0x01, 0xfe, 0xde, 0x1e, 0x10, 0x68, 0x22, 0x69, 0x01, 0xfe, 0xee, 0x1e,
-	0x01, 0xfe, 0xfe, 0x1e,
-	0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x10, 0x4b, 0x22, 0x4c, 0xfe, 0x8a,
-	0x10, 0x01, 0x0c, 0x06,
-	0x54, 0xfe, 0x50, 0x12, 0x01, 0xfe, 0xae, 0x1e, 0x01, 0xfe, 0xbe, 0x1e,
-	0x10, 0x6a, 0x22, 0x6b,
+	0x01, 0xfe, 0xfe, 0x1e, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x10, 0x4b,
+	0x22, 0x4c, 0xfe, 0x8a, 0x10, 0x01, 0x0c, 0x06, 0x54, 0xfe, 0x50, 0x12,
+	0x01, 0xfe, 0xae, 0x1e, 0x01, 0xfe, 0xbe, 0x1e, 0x10, 0x6a, 0x22, 0x6b,
 	0x01, 0x0c, 0x06, 0x65, 0x4e, 0x01, 0xc2, 0x0f, 0xfe, 0x1f, 0x80, 0x04,
-	0xfe, 0x9f, 0x83, 0x33,
-	0x0b, 0x0e, 0x20, 0x6e, 0x0f, 0xfe, 0x44, 0x90, 0x04, 0xfe, 0xc4, 0x93,
-	0x3a, 0x0b, 0xfe, 0xc6,
-	0x90, 0x04, 0xfe, 0xc6, 0x93, 0x79, 0x0b, 0x0e, 0x10, 0x6c, 0x22, 0x6d,
-	0x01, 0xfe, 0xce, 0x1e,
+	0xfe, 0x9f, 0x83, 0x33, 0x0b, 0x0e, 0x20, 0x6e, 0x0f, 0xfe, 0x44, 0x90,
+	0x04, 0xfe, 0xc4, 0x93, 0x3a, 0x0b, 0xfe, 0xc6, 0x90, 0x04, 0xfe, 0xc6,
+	0x93, 0x79, 0x0b, 0x0e, 0x10, 0x6c, 0x22, 0x6d, 0x01, 0xfe, 0xce, 0x1e,
 	0x01, 0xfe, 0xde, 0x1e, 0x10, 0x68, 0x22, 0x69, 0x0f, 0xfe, 0x40, 0x90,
-	0x04, 0xfe, 0xc0, 0x93,
-	0x3a, 0x0b, 0xfe, 0xc2, 0x90, 0x04, 0xfe, 0xc2, 0x93, 0x79, 0x0b, 0x0e,
-	0x10, 0x4b, 0x22, 0x4c,
-	0x10, 0x64, 0x22, 0x34, 0x01, 0x0c, 0x61, 0x24, 0x44, 0x37, 0x13, 0xfe,
-	0x4e, 0x11, 0x2f, 0xfe,
+	0x04, 0xfe, 0xc0, 0x93, 0x3a, 0x0b, 0xfe, 0xc2, 0x90, 0x04, 0xfe, 0xc2,
+	0x93, 0x79, 0x0b, 0x0e, 0x10, 0x4b, 0x22, 0x4c, 0x10, 0x64, 0x22, 0x34,
+	0x01, 0x0c, 0x61, 0x24, 0x44, 0x37, 0x13, 0xfe, 0x4e, 0x11, 0x2f, 0xfe,
 	0xde, 0x09, 0xfe, 0x9e, 0xf0, 0xfe, 0xf2, 0x09, 0xfe, 0x01, 0x48, 0x1b,
-	0x3c, 0x37, 0x88, 0xf5,
-	0xd4, 0xfe, 0x1e, 0x0a, 0xd5, 0xfe, 0x42, 0x0a, 0xd2, 0xfe, 0x1e, 0x0a,
-	0xd3, 0xfe, 0x42, 0x0a,
-	0xae, 0xfe, 0x12, 0x0a, 0xfe, 0x06, 0xf0, 0xfe, 0x18, 0x0a, 0xaf, 0xa0,
-	0x05, 0x29, 0x01, 0x41,
+	0x3c, 0x37, 0x88, 0xf5, 0xd4, 0xfe, 0x1e, 0x0a, 0xd5, 0xfe, 0x42, 0x0a,
+	0xd2, 0xfe, 0x1e, 0x0a, 0xd3, 0xfe, 0x42, 0x0a, 0xae, 0xfe, 0x12, 0x0a,
+	0xfe, 0x06, 0xf0, 0xfe, 0x18, 0x0a, 0xaf, 0xa0, 0x05, 0x29, 0x01, 0x41,
 	0xfe, 0xc1, 0x10, 0x14, 0x24, 0xfe, 0xc1, 0x10, 0x01, 0x76, 0x06, 0x07,
-	0xfe, 0x14, 0x12, 0x01,
-	0x76, 0x06, 0x0d, 0x5d, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x74, 0x12, 0xfe,
-	0x2e, 0x1c, 0x05, 0xfe,
-	0x1a, 0x0c, 0x01, 0x76, 0x06, 0x07, 0x5d, 0x01, 0x76, 0x06, 0x0d, 0x41,
-	0xfe, 0x2c, 0x1c, 0xfe,
+	0xfe, 0x14, 0x12, 0x01, 0x76, 0x06, 0x0d, 0x5d, 0x01, 0x0c, 0x06, 0x0d,
+	0xfe, 0x74, 0x12, 0xfe, 0x2e, 0x1c, 0x05, 0xfe, 0x1a, 0x0c, 0x01, 0x76,
+	0x06, 0x07, 0x5d, 0x01, 0x76, 0x06, 0x0d, 0x41, 0xfe, 0x2c, 0x1c, 0xfe,
 	0xaa, 0xf0, 0xfe, 0xce, 0x0a, 0xfe, 0xac, 0xf0, 0xfe, 0x66, 0x0a, 0xfe,
-	0x92, 0x10, 0xc4, 0xf6,
-	0xfe, 0xad, 0xf0, 0xfe, 0x72, 0x0a, 0x05, 0xfe, 0x1a, 0x0c, 0xc5, 0xfe,
-	0xe7, 0x10, 0xfe, 0x2b,
-	0xf0, 0xbf, 0xfe, 0x6b, 0x18, 0x23, 0xfe, 0x00, 0xfe, 0xfe, 0x1c, 0x12,
-	0xac, 0xfe, 0xd2, 0xf0,
+	0x92, 0x10, 0xc4, 0xf6, 0xfe, 0xad, 0xf0, 0xfe, 0x72, 0x0a, 0x05, 0xfe,
+	0x1a, 0x0c, 0xc5, 0xfe, 0xe7, 0x10, 0xfe, 0x2b, 0xf0, 0xbf, 0xfe, 0x6b,
+	0x18, 0x23, 0xfe, 0x00, 0xfe, 0xfe, 0x1c, 0x12, 0xac, 0xfe, 0xd2, 0xf0,
 	0xbf, 0xfe, 0x76, 0x18, 0x23, 0x1d, 0x1b, 0xbf, 0x03, 0xe3, 0x23, 0x07,
-	0x1b, 0xbf, 0xd4, 0x5b,
-	0xd5, 0x5b, 0xd2, 0x5b, 0xd3, 0x5b, 0xc4, 0xc5, 0xfe, 0xa9, 0x10, 0x75,
-	0x5e, 0x32, 0x1f, 0x7f,
-	0x01, 0x42, 0x19, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x70, 0x19, 0x98,
-	0x05, 0x70, 0xfe, 0x74,
+	0x1b, 0xbf, 0xd4, 0x5b, 0xd5, 0x5b, 0xd2, 0x5b, 0xd3, 0x5b, 0xc4, 0xc5,
+	0xfe, 0xa9, 0x10, 0x75, 0x5e, 0x32, 0x1f, 0x7f, 0x01, 0x42, 0x19, 0xfe,
+	0x35, 0x00, 0xfe, 0x01, 0xf0, 0x70, 0x19, 0x98, 0x05, 0x70, 0xfe, 0x74,
 	0x18, 0x23, 0xfe, 0x00, 0xf8, 0x1b, 0x5b, 0x7d, 0x12, 0x01, 0xfe, 0x78,
-	0x0f, 0x4d, 0x01, 0xfe,
-	0x96, 0x1a, 0x21, 0x30, 0x77, 0x7d, 0x1d, 0x05, 0x5b, 0x01, 0x0c, 0x06,
-	0x0d, 0x2b, 0xfe, 0xe2,
-	0x0b, 0x01, 0x0c, 0x06, 0x54, 0xfe, 0xa6, 0x12, 0x01, 0x0c, 0x06, 0x24,
-	0xfe, 0x88, 0x13, 0x21,
+	0x0f, 0x4d, 0x01, 0xfe, 0x96, 0x1a, 0x21, 0x30, 0x77, 0x7d, 0x1d, 0x05,
+	0x5b, 0x01, 0x0c, 0x06, 0x0d, 0x2b, 0xfe, 0xe2, 0x0b, 0x01, 0x0c, 0x06,
+	0x54, 0xfe, 0xa6, 0x12, 0x01, 0x0c, 0x06, 0x24, 0xfe, 0x88, 0x13, 0x21,
 	0x6e, 0xc7, 0x01, 0xfe, 0x1e, 0x1f, 0x0f, 0xfe, 0x83, 0x80, 0x04, 0xfe,
-	0x83, 0x83, 0xfe, 0xc9,
-	0x47, 0x0b, 0x0e, 0xfe, 0xc8, 0x44, 0xfe, 0x42, 0x13, 0x0f, 0xfe, 0x04,
-	0x91, 0x04, 0xfe, 0x84,
-	0x93, 0xfe, 0xca, 0x57, 0x0b, 0xfe, 0x86, 0x91, 0x04, 0xfe, 0x86, 0x93,
-	0xfe, 0xcb, 0x57, 0x0b,
+	0x83, 0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0xfe, 0xc8, 0x44, 0xfe, 0x42,
+	0x13, 0x0f, 0xfe, 0x04, 0x91, 0x04, 0xfe, 0x84, 0x93, 0xfe, 0xca, 0x57,
+	0x0b, 0xfe, 0x86, 0x91, 0x04, 0xfe, 0x86, 0x93, 0xfe, 0xcb, 0x57, 0x0b,
 	0x0e, 0x7a, 0x30, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x8e, 0x40, 0x03,
-	0x6a, 0x3b, 0x6b, 0x10,
-	0x97, 0x22, 0x98, 0xd9, 0x6a, 0xda, 0x6b, 0x01, 0xc2, 0xc8, 0x7a, 0x30,
-	0x20, 0x6e, 0xdb, 0x64,
-	0xdc, 0x34, 0x91, 0x6c, 0x7e, 0x6d, 0xfe, 0x44, 0x55, 0xfe, 0xe5, 0x55,
-	0xfe, 0x04, 0xfa, 0x64,
+	0x6a, 0x3b, 0x6b, 0x10, 0x97, 0x22, 0x98, 0xd9, 0x6a, 0xda, 0x6b, 0x01,
+	0xc2, 0xc8, 0x7a, 0x30, 0x20, 0x6e, 0xdb, 0x64, 0xdc, 0x34, 0x91, 0x6c,
+	0x7e, 0x6d, 0xfe, 0x44, 0x55, 0xfe, 0xe5, 0x55, 0xfe, 0x04, 0xfa, 0x64,
 	0xfe, 0x05, 0xfa, 0x34, 0x01, 0xfe, 0x6a, 0x16, 0xa3, 0x26, 0x10, 0x97,
-	0x10, 0x98, 0x91, 0x6c,
-	0x7e, 0x6d, 0xfe, 0x14, 0x10, 0x01, 0x0c, 0x06, 0x24, 0x1b, 0x40, 0x91,
-	0x4b, 0x7e, 0x4c, 0x01,
-	0x0c, 0x06, 0xfe, 0xf7, 0x00, 0x44, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x10,
-	0x58, 0xfe, 0x91, 0x58,
+	0x10, 0x98, 0x91, 0x6c, 0x7e, 0x6d, 0xfe, 0x14, 0x10, 0x01, 0x0c, 0x06,
+	0x24, 0x1b, 0x40, 0x91, 0x4b, 0x7e, 0x4c, 0x01, 0x0c, 0x06, 0xfe, 0xf7,
+	0x00, 0x44, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58,
 	0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x05, 0x5b, 0x01, 0x0c, 0x06, 0x24,
-	0x1b, 0x40, 0x01, 0x0c,
-	0x06, 0xfe, 0xf7, 0x00, 0x44, 0x78, 0x01, 0xfe, 0x8e, 0x1e, 0x4f, 0x0f,
-	0xfe, 0x10, 0x90, 0x04,
-	0xfe, 0x90, 0x93, 0x3a, 0x0b, 0xfe, 0x92, 0x90, 0x04, 0xfe, 0x92, 0x93,
-	0x79, 0x0b, 0x0e, 0xfe,
+	0x1b, 0x40, 0x01, 0x0c, 0x06, 0xfe, 0xf7, 0x00, 0x44, 0x78, 0x01, 0xfe,
+	0x8e, 0x1e, 0x4f, 0x0f, 0xfe, 0x10, 0x90, 0x04, 0xfe, 0x90, 0x93, 0x3a,
+	0x0b, 0xfe, 0x92, 0x90, 0x04, 0xfe, 0x92, 0x93, 0x79, 0x0b, 0x0e, 0xfe,
 	0xbd, 0x10, 0x01, 0x43, 0x09, 0xbb, 0x1b, 0xfe, 0x6e, 0x0a, 0x15, 0xbb,
-	0x01, 0x0c, 0x06, 0x0d,
-	0xfe, 0x14, 0x13, 0x03, 0x4b, 0x3b, 0x4c, 0x8e, 0xfe, 0x6e, 0x0a, 0xfe,
-	0x0c, 0x58, 0xfe, 0x8d,
-	0x58, 0x05, 0x5b, 0x26, 0x3e, 0x0f, 0xfe, 0x19, 0x80, 0x04, 0xfe, 0x99,
-	0x83, 0x33, 0x0b, 0x0e,
+	0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x14, 0x13, 0x03, 0x4b, 0x3b, 0x4c, 0x8e,
+	0xfe, 0x6e, 0x0a, 0xfe, 0x0c, 0x58, 0xfe, 0x8d, 0x58, 0x05, 0x5b, 0x26,
+	0x3e, 0x0f, 0xfe, 0x19, 0x80, 0x04, 0xfe, 0x99, 0x83, 0x33, 0x0b, 0x0e,
 	0xfe, 0xe5, 0x10, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1a, 0x12, 0xfe, 0x6c,
-	0x19, 0xfe, 0x19, 0x41,
-	0xfe, 0x6b, 0x18, 0xac, 0xfe, 0xd1, 0xf0, 0xef, 0x1f, 0x92, 0x01, 0x42,
-	0x19, 0xfe, 0x44, 0x00,
-	0xfe, 0x90, 0x10, 0xfe, 0x6c, 0x19, 0xd9, 0x4b, 0xfe, 0xed, 0x19, 0xda,
-	0x4c, 0xfe, 0x0c, 0x51,
+	0x19, 0xfe, 0x19, 0x41, 0xfe, 0x6b, 0x18, 0xac, 0xfe, 0xd1, 0xf0, 0xef,
+	0x1f, 0x92, 0x01, 0x42, 0x19, 0xfe, 0x44, 0x00, 0xfe, 0x90, 0x10, 0xfe,
+	0x6c, 0x19, 0xd9, 0x4b, 0xfe, 0xed, 0x19, 0xda, 0x4c, 0xfe, 0x0c, 0x51,
 	0xfe, 0x8e, 0x51, 0xfe, 0x6b, 0x18, 0x23, 0xfe, 0x00, 0xff, 0x31, 0xfe,
-	0x76, 0x10, 0xac, 0xfe,
-	0xd2, 0xf0, 0xfe, 0xba, 0x0c, 0xfe, 0x76, 0x18, 0x23, 0x1d, 0x5d, 0x03,
-	0xe3, 0x23, 0x07, 0xfe,
-	0x08, 0x13, 0x19, 0xfe, 0x16, 0x00, 0x05, 0x70, 0xfe, 0xd1, 0xf0, 0xfe,
-	0xcc, 0x0c, 0x1f, 0x92,
+	0x76, 0x10, 0xac, 0xfe, 0xd2, 0xf0, 0xfe, 0xba, 0x0c, 0xfe, 0x76, 0x18,
+	0x23, 0x1d, 0x5d, 0x03, 0xe3, 0x23, 0x07, 0xfe, 0x08, 0x13, 0x19, 0xfe,
+	0x16, 0x00, 0x05, 0x70, 0xfe, 0xd1, 0xf0, 0xfe, 0xcc, 0x0c, 0x1f, 0x92,
 	0x01, 0x42, 0x19, 0xfe, 0x17, 0x00, 0x5c, 0xfe, 0xce, 0xf0, 0xfe, 0xd2,
-	0x0c, 0xfe, 0x3e, 0x10,
-	0xfe, 0xcd, 0xf0, 0xfe, 0xde, 0x0c, 0x19, 0xfe, 0x22, 0x00, 0x05, 0x70,
-	0xfe, 0xcb, 0xf0, 0xfe,
-	0xea, 0x0c, 0x19, 0xfe, 0x24, 0x00, 0x05, 0x70, 0xfe, 0xd0, 0xf0, 0xfe,
-	0xf4, 0x0c, 0x19, 0x94,
+	0x0c, 0xfe, 0x3e, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xde, 0x0c, 0x19, 0xfe,
+	0x22, 0x00, 0x05, 0x70, 0xfe, 0xcb, 0xf0, 0xfe, 0xea, 0x0c, 0x19, 0xfe,
+	0x24, 0x00, 0x05, 0x70, 0xfe, 0xd0, 0xf0, 0xfe, 0xf4, 0x0c, 0x19, 0x94,
 	0xfe, 0x1c, 0x10, 0xfe, 0xcf, 0xf0, 0xfe, 0xfe, 0x0c, 0x19, 0x4a, 0xf3,
-	0xfe, 0xcc, 0xf0, 0xef,
-	0x01, 0x76, 0x06, 0x24, 0x4d, 0x19, 0xfe, 0x12, 0x00, 0x37, 0x13, 0xfe,
-	0x4e, 0x11, 0x2f, 0xfe,
-	0x16, 0x0d, 0xfe, 0x9e, 0xf0, 0xfe, 0x2a, 0x0d, 0xfe, 0x01, 0x48, 0x1b,
-	0x3c, 0x37, 0x88, 0xf5,
+	0xfe, 0xcc, 0xf0, 0xef, 0x01, 0x76, 0x06, 0x24, 0x4d, 0x19, 0xfe, 0x12,
+	0x00, 0x37, 0x13, 0xfe, 0x4e, 0x11, 0x2f, 0xfe, 0x16, 0x0d, 0xfe, 0x9e,
+	0xf0, 0xfe, 0x2a, 0x0d, 0xfe, 0x01, 0x48, 0x1b, 0x3c, 0x37, 0x88, 0xf5,
 	0xd4, 0x29, 0xd5, 0x29, 0xd2, 0x29, 0xd3, 0x29, 0x37, 0xfe, 0x9c, 0x32,
-	0x2f, 0xfe, 0x3e, 0x0d,
-	0x2a, 0x3c, 0xae, 0xfe, 0x62, 0x0d, 0xaf, 0xa0, 0xd4, 0x9f, 0xd5, 0x9f,
-	0xd2, 0x9f, 0xd3, 0x9f,
-	0x05, 0x29, 0x01, 0x41, 0xfe, 0xd3, 0x10, 0x15, 0xfe, 0xe8, 0x00, 0xc4,
-	0xc5, 0x75, 0xd7, 0x99,
+	0x2f, 0xfe, 0x3e, 0x0d, 0x2a, 0x3c, 0xae, 0xfe, 0x62, 0x0d, 0xaf, 0xa0,
+	0xd4, 0x9f, 0xd5, 0x9f, 0xd2, 0x9f, 0xd3, 0x9f, 0x05, 0x29, 0x01, 0x41,
+	0xfe, 0xd3, 0x10, 0x15, 0xfe, 0xe8, 0x00, 0xc4, 0xc5, 0x75, 0xd7, 0x99,
 	0xd8, 0x9c, 0xfe, 0x89, 0xf0, 0x29, 0x27, 0x25, 0xbe, 0xd7, 0x99, 0xd8,
-	0x9c, 0x2f, 0xfe, 0x8c,
-	0x0d, 0x16, 0x29, 0x27, 0x25, 0xbd, 0xfe, 0x01, 0x48, 0xa4, 0x19, 0xfe,
-	0x42, 0x00, 0x05, 0x70,
-	0x90, 0x07, 0xfe, 0x81, 0x49, 0x1b, 0xfe, 0x64, 0x0e, 0x01, 0x0c, 0x06,
-	0x0d, 0xfe, 0x44, 0x13,
+	0x9c, 0x2f, 0xfe, 0x8c, 0x0d, 0x16, 0x29, 0x27, 0x25, 0xbd, 0xfe, 0x01,
+	0x48, 0xa4, 0x19, 0xfe, 0x42, 0x00, 0x05, 0x70, 0x90, 0x07, 0xfe, 0x81,
+	0x49, 0x1b, 0xfe, 0x64, 0x0e, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x44, 0x13,
 	0x19, 0x00, 0x2d, 0x0d, 0xfe, 0x54, 0x12, 0x2d, 0xfe, 0x28, 0x00, 0x2b,
-	0xfe, 0xda, 0x0e, 0x0a,
-	0x57, 0x01, 0x18, 0x09, 0x00, 0x36, 0x46, 0xfe, 0x28, 0x00, 0xfe, 0xfa,
-	0x10, 0x01, 0xfe, 0xf4,
-	0x1c, 0x01, 0xfe, 0x00, 0x1d, 0x0a, 0xba, 0x01, 0xfe, 0x58, 0x10, 0x40,
-	0x15, 0x56, 0x01, 0x85,
+	0xfe, 0xda, 0x0e, 0x0a, 0x57, 0x01, 0x18, 0x09, 0x00, 0x36, 0x46, 0xfe,
+	0x28, 0x00, 0xfe, 0xfa, 0x10, 0x01, 0xfe, 0xf4, 0x1c, 0x01, 0xfe, 0x00,
+	0x1d, 0x0a, 0xba, 0x01, 0xfe, 0x58, 0x10, 0x40, 0x15, 0x56, 0x01, 0x85,
 	0x05, 0x35, 0x19, 0xfe, 0x44, 0x00, 0x2d, 0x0d, 0xf7, 0x46, 0x0d, 0xfe,
-	0xcc, 0x10, 0x01, 0xa7,
-	0x46, 0x0d, 0xfe, 0xc2, 0x10, 0x01, 0xa7, 0x0f, 0xfe, 0x19, 0x82, 0x04,
-	0xfe, 0x99, 0x83, 0xfe,
-	0xcc, 0x47, 0x0b, 0x0e, 0xfe, 0x34, 0x46, 0xa5, 0x46, 0x0d, 0x19, 0xfe,
-	0x43, 0x00, 0xfe, 0xa2,
+	0xcc, 0x10, 0x01, 0xa7, 0x46, 0x0d, 0xfe, 0xc2, 0x10, 0x01, 0xa7, 0x0f,
+	0xfe, 0x19, 0x82, 0x04, 0xfe, 0x99, 0x83, 0xfe, 0xcc, 0x47, 0x0b, 0x0e,
+	0xfe, 0x34, 0x46, 0xa5, 0x46, 0x0d, 0x19, 0xfe, 0x43, 0x00, 0xfe, 0xa2,
 	0x10, 0x01, 0x0c, 0x61, 0x0d, 0x44, 0x01, 0xfe, 0xf4, 0x1c, 0x01, 0xfe,
-	0x00, 0x1d, 0x40, 0x15,
-	0x56, 0x01, 0x85, 0x7d, 0x0d, 0x40, 0x51, 0x01, 0xfe, 0x9e, 0x1e, 0x05,
-	0xfe, 0x3a, 0x03, 0x01,
-	0x0c, 0x06, 0x0d, 0x5d, 0x46, 0x0d, 0x19, 0x00, 0xfe, 0x62, 0x10, 0x01,
-	0x76, 0x06, 0x12, 0xfe,
+	0x00, 0x1d, 0x40, 0x15, 0x56, 0x01, 0x85, 0x7d, 0x0d, 0x40, 0x51, 0x01,
+	0xfe, 0x9e, 0x1e, 0x05, 0xfe, 0x3a, 0x03, 0x01, 0x0c, 0x06, 0x0d, 0x5d,
+	0x46, 0x0d, 0x19, 0x00, 0xfe, 0x62, 0x10, 0x01, 0x76, 0x06, 0x12, 0xfe,
 	0x5c, 0x12, 0x01, 0x0c, 0x06, 0x12, 0xfe, 0x52, 0x13, 0xfe, 0x1c, 0x1c,
-	0xfe, 0x9d, 0xf0, 0xfe,
-	0x8e, 0x0e, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x94, 0x0e, 0x01,
-	0x0c, 0x61, 0x12, 0x44,
-	0xfe, 0x9f, 0x10, 0x19, 0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0d, 0x4f,
-	0xfe, 0x2e, 0x10, 0x19,
+	0xfe, 0x9d, 0xf0, 0xfe, 0x8e, 0x0e, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0,
+	0xfe, 0x94, 0x0e, 0x01, 0x0c, 0x61, 0x12, 0x44, 0xfe, 0x9f, 0x10, 0x19,
+	0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0d, 0x4f, 0xfe, 0x2e, 0x10, 0x19,
 	0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x19, 0xfe, 0x47, 0x00, 0xf1, 0x19,
-	0xfe, 0x41, 0x00, 0xa2,
-	0x19, 0xfe, 0x24, 0x00, 0x86, 0xc4, 0xc5, 0x75, 0x03, 0x81, 0x1e, 0x2b,
-	0xea, 0x4f, 0xfe, 0x04,
-	0xe6, 0x12, 0xfe, 0x9d, 0x41, 0xfe, 0x1c, 0x42, 0x40, 0x01, 0xf4, 0x05,
-	0x35, 0xfe, 0x12, 0x1c,
+	0xfe, 0x41, 0x00, 0xa2, 0x19, 0xfe, 0x24, 0x00, 0x86, 0xc4, 0xc5, 0x75,
+	0x03, 0x81, 0x1e, 0x2b, 0xea, 0x4f, 0xfe, 0x04, 0xe6, 0x12, 0xfe, 0x9d,
+	0x41, 0xfe, 0x1c, 0x42, 0x40, 0x01, 0xf4, 0x05, 0x35, 0xfe, 0x12, 0x1c,
 	0x1f, 0x0d, 0x47, 0xb5, 0xc3, 0x1f, 0xfe, 0x31, 0x00, 0x47, 0xb8, 0x01,
-	0xfe, 0xd4, 0x11, 0x05,
-	0xe9, 0x51, 0xfe, 0x06, 0xec, 0xe0, 0xfe, 0x0e, 0x47, 0x46, 0x28, 0xfe,
-	0xce, 0x45, 0x31, 0x51,
-	0xfe, 0x06, 0xea, 0xe0, 0xfe, 0x47, 0x4b, 0x45, 0xfe, 0x75, 0x57, 0x03,
-	0x67, 0xfe, 0x98, 0x56,
+	0xfe, 0xd4, 0x11, 0x05, 0xe9, 0x51, 0xfe, 0x06, 0xec, 0xe0, 0xfe, 0x0e,
+	0x47, 0x46, 0x28, 0xfe, 0xce, 0x45, 0x31, 0x51, 0xfe, 0x06, 0xea, 0xe0,
+	0xfe, 0x47, 0x4b, 0x45, 0xfe, 0x75, 0x57, 0x03, 0x67, 0xfe, 0x98, 0x56,
 	0xfe, 0x38, 0x12, 0x0a, 0x5a, 0x01, 0x18, 0xfe, 0x44, 0x48, 0x60, 0x01,
-	0x0c, 0x06, 0x28, 0xfe,
-	0x18, 0x13, 0x0a, 0x57, 0x01, 0x18, 0x3e, 0xfe, 0x41, 0x58, 0x0a, 0xba,
-	0xfe, 0xfa, 0x14, 0xfe,
-	0x49, 0x54, 0xb0, 0xfe, 0x5e, 0x0f, 0x05, 0xfe, 0x3a, 0x03, 0x0a, 0x67,
-	0xfe, 0xe0, 0x14, 0xfe,
+	0x0c, 0x06, 0x28, 0xfe, 0x18, 0x13, 0x0a, 0x57, 0x01, 0x18, 0x3e, 0xfe,
+	0x41, 0x58, 0x0a, 0xba, 0xfe, 0xfa, 0x14, 0xfe, 0x49, 0x54, 0xb0, 0xfe,
+	0x5e, 0x0f, 0x05, 0xfe, 0x3a, 0x03, 0x0a, 0x67, 0xfe, 0xe0, 0x14, 0xfe,
 	0x0e, 0x47, 0x46, 0x28, 0xfe, 0xce, 0x45, 0x31, 0x51, 0xfe, 0xce, 0x47,
-	0xfe, 0xad, 0x13, 0x05,
-	0x35, 0x21, 0x2c, 0x09, 0x1a, 0xfe, 0x98, 0x12, 0x26, 0x20, 0x96, 0x20,
-	0xe7, 0xfe, 0x08, 0x1c,
-	0xfe, 0x7c, 0x19, 0xfe, 0xfd, 0x19, 0xfe, 0x0a, 0x1c, 0x03, 0xe5, 0xfe,
-	0x48, 0x55, 0xa5, 0x3b,
+	0xfe, 0xad, 0x13, 0x05, 0x35, 0x21, 0x2c, 0x09, 0x1a, 0xfe, 0x98, 0x12,
+	0x26, 0x20, 0x96, 0x20, 0xe7, 0xfe, 0x08, 0x1c, 0xfe, 0x7c, 0x19, 0xfe,
+	0xfd, 0x19, 0xfe, 0x0a, 0x1c, 0x03, 0xe5, 0xfe, 0x48, 0x55, 0xa5, 0x3b,
 	0xfe, 0x62, 0x01, 0xfe, 0xc9, 0x55, 0x31, 0xfe, 0x74, 0x10, 0x01, 0xfe,
-	0xf0, 0x1a, 0x03, 0xfe,
-	0x38, 0x01, 0x3b, 0xfe, 0x3a, 0x01, 0x8e, 0xfe, 0x1e, 0x10, 0xfe, 0x02,
-	0xec, 0xe7, 0x53, 0x00,
-	0x36, 0xfe, 0x04, 0xec, 0x2c, 0x60, 0xfe, 0x05, 0xf6, 0xfe, 0x34, 0x01,
-	0x01, 0xfe, 0x62, 0x1b,
+	0xf0, 0x1a, 0x03, 0xfe, 0x38, 0x01, 0x3b, 0xfe, 0x3a, 0x01, 0x8e, 0xfe,
+	0x1e, 0x10, 0xfe, 0x02, 0xec, 0xe7, 0x53, 0x00, 0x36, 0xfe, 0x04, 0xec,
+	0x2c, 0x60, 0xfe, 0x05, 0xf6, 0xfe, 0x34, 0x01, 0x01, 0xfe, 0x62, 0x1b,
 	0x01, 0xfe, 0xce, 0x1e, 0xb2, 0x11, 0xfe, 0x18, 0x13, 0xca, 0xfe, 0x02,
-	0xea, 0xe7, 0x53, 0x92,
-	0xfe, 0xc3, 0x13, 0x1f, 0x12, 0x47, 0xb5, 0xc3, 0xfe, 0x2a, 0x10, 0x03,
-	0xfe, 0x38, 0x01, 0x23,
-	0xfe, 0xf0, 0xff, 0x10, 0xe5, 0x03, 0xfe, 0x3a, 0x01, 0x10, 0xfe, 0x62,
-	0x01, 0x01, 0xfe, 0x1e,
+	0xea, 0xe7, 0x53, 0x92, 0xfe, 0xc3, 0x13, 0x1f, 0x12, 0x47, 0xb5, 0xc3,
+	0xfe, 0x2a, 0x10, 0x03, 0xfe, 0x38, 0x01, 0x23, 0xfe, 0xf0, 0xff, 0x10,
+	0xe5, 0x03, 0xfe, 0x3a, 0x01, 0x10, 0xfe, 0x62, 0x01, 0x01, 0xfe, 0x1e,
 	0x1e, 0x20, 0x2c, 0x15, 0x56, 0x01, 0xfe, 0x9e, 0x1e, 0x13, 0x07, 0x02,
-	0x26, 0x02, 0x21, 0x96,
-	0xc7, 0x20, 0x96, 0x09, 0x92, 0xfe, 0x79, 0x13, 0x1f, 0x1d, 0x47, 0xb5,
-	0xc3, 0xfe, 0xe1, 0x10,
-	0xcf, 0xfe, 0x03, 0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xcf,
-	0xfe, 0x03, 0xdc, 0xfe,
+	0x26, 0x02, 0x21, 0x96, 0xc7, 0x20, 0x96, 0x09, 0x92, 0xfe, 0x79, 0x13,
+	0x1f, 0x1d, 0x47, 0xb5, 0xc3, 0xfe, 0xe1, 0x10, 0xcf, 0xfe, 0x03, 0xdc,
+	0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xcf, 0xfe, 0x03, 0xdc, 0xfe,
 	0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xfe, 0x03, 0x57, 0xcf, 0x26, 0xfe,
-	0x00, 0xcc, 0x02, 0xfe,
-	0x03, 0x57, 0xcf, 0x89, 0x02, 0x01, 0x0c, 0x06, 0x4a, 0xfe, 0x4e, 0x13,
-	0x0f, 0xfe, 0x1c, 0x80,
-	0x04, 0xfe, 0x9c, 0x83, 0x33, 0x0b, 0x0e, 0x09, 0x07, 0xfe, 0x3a, 0x13,
-	0x0f, 0xfe, 0x1e, 0x80,
+	0x00, 0xcc, 0x02, 0xfe, 0x03, 0x57, 0xcf, 0x89, 0x02, 0x01, 0x0c, 0x06,
+	0x4a, 0xfe, 0x4e, 0x13, 0x0f, 0xfe, 0x1c, 0x80, 0x04, 0xfe, 0x9c, 0x83,
+	0x33, 0x0b, 0x0e, 0x09, 0x07, 0xfe, 0x3a, 0x13, 0x0f, 0xfe, 0x1e, 0x80,
 	0x04, 0xfe, 0x9e, 0x83, 0x33, 0x0b, 0x0e, 0xfe, 0x2a, 0x13, 0x0f, 0xfe,
-	0x1d, 0x80, 0x04, 0xfe,
-	0x9d, 0x83, 0xfe, 0xf9, 0x13, 0x0e, 0xfe, 0x1c, 0x13, 0x01, 0xfe, 0xee,
-	0x1e, 0xac, 0xfe, 0x14,
-	0x13, 0x01, 0xfe, 0xfe, 0x1e, 0xfe, 0x81, 0x58, 0xfa, 0x01, 0xfe, 0x0e,
-	0x1f, 0xfe, 0x30, 0xf4,
+	0x1d, 0x80, 0x04, 0xfe, 0x9d, 0x83, 0xfe, 0xf9, 0x13, 0x0e, 0xfe, 0x1c,
+	0x13, 0x01, 0xfe, 0xee, 0x1e, 0xac, 0xfe, 0x14, 0x13, 0x01, 0xfe, 0xfe,
+	0x1e, 0xfe, 0x81, 0x58, 0xfa, 0x01, 0xfe, 0x0e, 0x1f, 0xfe, 0x30, 0xf4,
 	0x0d, 0xfe, 0x3c, 0x50, 0xa2, 0x01, 0xfe, 0x92, 0x1b, 0x01, 0x43, 0x09,
-	0x56, 0xfb, 0x01, 0xfe,
-	0xc8, 0x1a, 0x01, 0x0c, 0x06, 0x28, 0xa4, 0x01, 0xfe, 0xf4, 0x1c, 0x01,
-	0xfe, 0x00, 0x1d, 0x15,
-	0xfe, 0xe9, 0x00, 0x01, 0x0c, 0x06, 0x4a, 0xfe, 0x4e, 0x13, 0x01, 0xfe,
-	0x22, 0x1b, 0xfe, 0x1e,
+	0x56, 0xfb, 0x01, 0xfe, 0xc8, 0x1a, 0x01, 0x0c, 0x06, 0x28, 0xa4, 0x01,
+	0xfe, 0xf4, 0x1c, 0x01, 0xfe, 0x00, 0x1d, 0x15, 0xfe, 0xe9, 0x00, 0x01,
+	0x0c, 0x06, 0x4a, 0xfe, 0x4e, 0x13, 0x01, 0xfe, 0x22, 0x1b, 0xfe, 0x1e,
 	0x1c, 0x0f, 0xfe, 0x14, 0x90, 0x04, 0xfe, 0x94, 0x93, 0x3a, 0x0b, 0xfe,
-	0x96, 0x90, 0x04, 0xfe,
-	0x96, 0x93, 0x79, 0x0b, 0x0e, 0x10, 0xfe, 0x64, 0x01, 0x22, 0xfe, 0x66,
-	0x01, 0x01, 0x0c, 0x06,
-	0x65, 0xf9, 0x0f, 0xfe, 0x03, 0x80, 0x04, 0xfe, 0x83, 0x83, 0x33, 0x0b,
-	0x0e, 0x77, 0xfe, 0x01,
+	0x96, 0x90, 0x04, 0xfe, 0x96, 0x93, 0x79, 0x0b, 0x0e, 0x10, 0xfe, 0x64,
+	0x01, 0x22, 0xfe, 0x66, 0x01, 0x01, 0x0c, 0x06, 0x65, 0xf9, 0x0f, 0xfe,
+	0x03, 0x80, 0x04, 0xfe, 0x83, 0x83, 0x33, 0x0b, 0x0e, 0x77, 0xfe, 0x01,
 	0xec, 0x2c, 0xfe, 0x80, 0x40, 0x20, 0x2c, 0x7a, 0x30, 0x15, 0xdf, 0x40,
-	0x21, 0x2c, 0xfe, 0x00,
-	0x40, 0x8d, 0x2c, 0x02, 0xfe, 0x08, 0x1c, 0x03, 0xfe, 0xac, 0x00, 0xfe,
-	0x06, 0x58, 0x03, 0xfe,
-	0xae, 0x00, 0xfe, 0x07, 0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe, 0x08, 0x58,
-	0x03, 0xfe, 0xb2, 0x00,
+	0x21, 0x2c, 0xfe, 0x00, 0x40, 0x8d, 0x2c, 0x02, 0xfe, 0x08, 0x1c, 0x03,
+	0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58, 0x03, 0xfe, 0xae, 0x00, 0xfe, 0x07,
+	0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe, 0x08, 0x58, 0x03, 0xfe, 0xb2, 0x00,
 	0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c, 0x2e, 0x49, 0x20, 0xe0, 0x26, 0x10,
-	0x66, 0x10, 0x55, 0x10,
-	0x6f, 0x13, 0x57, 0x52, 0x4f, 0x1c, 0x28, 0xfe, 0x90, 0x4d, 0xfe, 0x91,
-	0x54, 0x2b, 0xfe, 0x88,
-	0x11, 0x46, 0x1a, 0x13, 0x5a, 0x52, 0x1c, 0x4a, 0xfe, 0x90, 0x4d, 0xfe,
-	0x91, 0x54, 0x2b, 0xfe,
+	0x66, 0x10, 0x55, 0x10, 0x6f, 0x13, 0x57, 0x52, 0x4f, 0x1c, 0x28, 0xfe,
+	0x90, 0x4d, 0xfe, 0x91, 0x54, 0x2b, 0xfe, 0x88, 0x11, 0x46, 0x1a, 0x13,
+	0x5a, 0x52, 0x1c, 0x4a, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x2b, 0xfe,
 	0x9e, 0x11, 0x2e, 0x1a, 0x20, 0x2c, 0x90, 0x34, 0x60, 0x21, 0x2c, 0xfe,
-	0x00, 0x40, 0x8d, 0x2c,
-	0x15, 0xdf, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0xb2, 0x11, 0xfe,
-	0x12, 0x1c, 0x75, 0xfe,
-	0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe, 0x18, 0x1c, 0x02, 0x51, 0xfe, 0x0c,
-	0x14, 0xfe, 0x0e, 0x47,
+	0x00, 0x40, 0x8d, 0x2c, 0x15, 0xdf, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0,
+	0xfe, 0xb2, 0x11, 0xfe, 0x12, 0x1c, 0x75, 0xfe, 0x14, 0x1c, 0xfe, 0x10,
+	0x1c, 0xfe, 0x18, 0x1c, 0x02, 0x51, 0xfe, 0x0c, 0x14, 0xfe, 0x0e, 0x47,
 	0xfe, 0x07, 0xe6, 0x28, 0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x02, 0x01,
-	0xa7, 0x90, 0x34, 0x60,
-	0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42, 0x13, 0xfe, 0x02, 0x80,
-	0x09, 0x56, 0xfe, 0x34,
-	0x13, 0x0a, 0x5a, 0x01, 0x18, 0xcb, 0xfe, 0x36, 0x12, 0xfe, 0x41, 0x48,
-	0xfe, 0x45, 0x48, 0x01,
+	0xa7, 0x90, 0x34, 0x60, 0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42,
+	0x13, 0xfe, 0x02, 0x80, 0x09, 0x56, 0xfe, 0x34, 0x13, 0x0a, 0x5a, 0x01,
+	0x18, 0xcb, 0xfe, 0x36, 0x12, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01,
 	0xfe, 0xb2, 0x16, 0xfe, 0x00, 0xcc, 0xcb, 0xfe, 0xf3, 0x13, 0x3f, 0x89,
-	0x09, 0x1a, 0xa5, 0x0a,
-	0x9d, 0x01, 0x18, 0xfe, 0x80, 0x5c, 0x01, 0x85, 0xf2, 0x09, 0x9b, 0xa4,
-	0xfe, 0x14, 0x56, 0xfe,
-	0xd6, 0xf0, 0xfe, 0xec, 0x11, 0x02, 0xfe, 0x44, 0x58, 0x77, 0xfe, 0x01,
-	0xec, 0xb8, 0xfe, 0x9e,
+	0x09, 0x1a, 0xa5, 0x0a, 0x9d, 0x01, 0x18, 0xfe, 0x80, 0x5c, 0x01, 0x85,
+	0xf2, 0x09, 0x9b, 0xa4, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0xec,
+	0x11, 0x02, 0xfe, 0x44, 0x58, 0x77, 0xfe, 0x01, 0xec, 0xb8, 0xfe, 0x9e,
 	0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x12, 0x8d, 0x30, 0x01,
-	0xf4, 0xfe, 0xdd, 0x10,
-	0x37, 0xd7, 0x99, 0xd8, 0x9c, 0x27, 0x25, 0xee, 0x09, 0x12, 0xfe, 0x48,
-	0x12, 0x09, 0x0d, 0xfe,
-	0x56, 0x12, 0x09, 0x1d, 0xfe, 0x30, 0x12, 0x09, 0xdd, 0x1b, 0xfe, 0xc4,
-	0x13, 0x09, 0xfe, 0x23,
+	0xf4, 0xfe, 0xdd, 0x10, 0x37, 0xd7, 0x99, 0xd8, 0x9c, 0x27, 0x25, 0xee,
+	0x09, 0x12, 0xfe, 0x48, 0x12, 0x09, 0x0d, 0xfe, 0x56, 0x12, 0x09, 0x1d,
+	0xfe, 0x30, 0x12, 0x09, 0xdd, 0x1b, 0xfe, 0xc4, 0x13, 0x09, 0xfe, 0x23,
 	0x00, 0x1b, 0xfe, 0xd0, 0x13, 0x09, 0x07, 0x1b, 0xfe, 0x34, 0x14, 0x09,
-	0x24, 0xfe, 0x12, 0x12,
-	0x09, 0x00, 0x1b, 0x29, 0x1f, 0xdd, 0x01, 0x42, 0xa1, 0x32, 0x01, 0x08,
-	0xae, 0x41, 0x02, 0x32,
-	0xfe, 0x62, 0x08, 0x0a, 0xe1, 0x01, 0xfe, 0x58, 0x10, 0x15, 0x9b, 0x05,
-	0x35, 0x32, 0x01, 0x43,
+	0x24, 0xfe, 0x12, 0x12, 0x09, 0x00, 0x1b, 0x29, 0x1f, 0xdd, 0x01, 0x42,
+	0xa1, 0x32, 0x01, 0x08, 0xae, 0x41, 0x02, 0x32, 0xfe, 0x62, 0x08, 0x0a,
+	0xe1, 0x01, 0xfe, 0x58, 0x10, 0x15, 0x9b, 0x05, 0x35, 0x32, 0x01, 0x43,
 	0x09, 0xbb, 0xfe, 0xd7, 0x13, 0x91, 0x4b, 0x7e, 0x4c, 0x8e, 0xfe, 0x80,
-	0x13, 0x01, 0x0c, 0x06,
-	0x54, 0xfe, 0x72, 0x12, 0xdb, 0x64, 0xdc, 0x34, 0xfe, 0x44, 0x55, 0xfe,
-	0xe5, 0x55, 0xb0, 0xfe,
-	0x4a, 0x13, 0x21, 0x6e, 0xfe, 0x26, 0x13, 0x03, 0x97, 0x3b, 0x98, 0x8e,
-	0xfe, 0xb6, 0x0e, 0x10,
+	0x13, 0x01, 0x0c, 0x06, 0x54, 0xfe, 0x72, 0x12, 0xdb, 0x64, 0xdc, 0x34,
+	0xfe, 0x44, 0x55, 0xfe, 0xe5, 0x55, 0xb0, 0xfe, 0x4a, 0x13, 0x21, 0x6e,
+	0xfe, 0x26, 0x13, 0x03, 0x97, 0x3b, 0x98, 0x8e, 0xfe, 0xb6, 0x0e, 0x10,
 	0x6a, 0x22, 0x6b, 0x26, 0x10, 0x97, 0x10, 0x98, 0x01, 0xc2, 0x2e, 0x49,
-	0x88, 0x20, 0x6e, 0x01,
-	0xfe, 0x6a, 0x16, 0xdb, 0x64, 0xdc, 0x34, 0xfe, 0x04, 0x55, 0xfe, 0xa5,
-	0x55, 0xfe, 0x04, 0xfa,
-	0x64, 0xfe, 0x05, 0xfa, 0x34, 0xfe, 0x8f, 0x10, 0x03, 0x6c, 0x3b, 0x6d,
-	0xfe, 0x40, 0x56, 0xfe,
+	0x88, 0x20, 0x6e, 0x01, 0xfe, 0x6a, 0x16, 0xdb, 0x64, 0xdc, 0x34, 0xfe,
+	0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x64, 0xfe, 0x05, 0xfa,
+	0x34, 0xfe, 0x8f, 0x10, 0x03, 0x6c, 0x3b, 0x6d, 0xfe, 0x40, 0x56, 0xfe,
 	0xe1, 0x56, 0x10, 0x6c, 0x22, 0x6d, 0x71, 0xdb, 0x64, 0xdc, 0x34, 0xfe,
-	0x44, 0x55, 0xfe, 0xe5,
-	0x55, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x00, 0x56, 0xfe, 0xa1, 0x56, 0x10,
-	0x68, 0x22, 0x69, 0x01,
-	0x0c, 0x06, 0x54, 0xf9, 0x21, 0x6e, 0xfe, 0x1f, 0x40, 0x03, 0x6a, 0x3b,
-	0x6b, 0xfe, 0x2c, 0x50,
+	0x44, 0x55, 0xfe, 0xe5, 0x55, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x00, 0x56,
+	0xfe, 0xa1, 0x56, 0x10, 0x68, 0x22, 0x69, 0x01, 0x0c, 0x06, 0x54, 0xf9,
+	0x21, 0x6e, 0xfe, 0x1f, 0x40, 0x03, 0x6a, 0x3b, 0x6b, 0xfe, 0x2c, 0x50,
 	0xfe, 0xae, 0x50, 0x03, 0x6c, 0x3b, 0x6d, 0xfe, 0x44, 0x50, 0xfe, 0xc6,
-	0x50, 0x03, 0x68, 0x3b,
-	0x69, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x03, 0x4b, 0x3b, 0x4c, 0xfe,
-	0x40, 0x50, 0xfe, 0xc2,
-	0x50, 0x05, 0x73, 0x2e, 0x07, 0x20, 0x9e, 0x05, 0x72, 0x32, 0x01, 0x08,
-	0x16, 0x3d, 0x27, 0x25,
+	0x50, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x03,
+	0x4b, 0x3b, 0x4c, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x05, 0x73, 0x2e,
+	0x07, 0x20, 0x9e, 0x05, 0x72, 0x32, 0x01, 0x08, 0x16, 0x3d, 0x27, 0x25,
 	0xee, 0x09, 0x07, 0x2b, 0x3d, 0x01, 0x43, 0x09, 0xbb, 0x2b, 0x72, 0x01,
-	0xa6, 0x23, 0x3f, 0x1b,
-	0x3d, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1e, 0x13, 0x91, 0x4b, 0x7e, 0x4c,
-	0xfe, 0x0a, 0x55, 0x31,
-	0xfe, 0x8b, 0x55, 0xd9, 0x4b, 0xda, 0x4c, 0xfe, 0x0c, 0x51, 0xfe, 0x8e,
-	0x51, 0x05, 0x72, 0x01,
+	0xa6, 0x23, 0x3f, 0x1b, 0x3d, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1e, 0x13,
+	0x91, 0x4b, 0x7e, 0x4c, 0xfe, 0x0a, 0x55, 0x31, 0xfe, 0x8b, 0x55, 0xd9,
+	0x4b, 0xda, 0x4c, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0x05, 0x72, 0x01,
 	0xfe, 0x8e, 0x1e, 0xca, 0xfe, 0x19, 0x41, 0x05, 0x72, 0x32, 0x01, 0x08,
-	0x2a, 0x3c, 0x16, 0xc0,
-	0x27, 0x25, 0xbe, 0x2d, 0x1d, 0xc0, 0x2d, 0x0d, 0x83, 0x2d, 0x7f, 0x1b,
-	0xfe, 0x66, 0x15, 0x05,
-	0x3d, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0xc0, 0x27, 0x25, 0xbd, 0x09, 0x1d,
-	0x2b, 0x3d, 0x01, 0x08,
+	0x2a, 0x3c, 0x16, 0xc0, 0x27, 0x25, 0xbe, 0x2d, 0x1d, 0xc0, 0x2d, 0x0d,
+	0x83, 0x2d, 0x7f, 0x1b, 0xfe, 0x66, 0x15, 0x05, 0x3d, 0x01, 0x08, 0x2a,
+	0x3c, 0x16, 0xc0, 0x27, 0x25, 0xbd, 0x09, 0x1d, 0x2b, 0x3d, 0x01, 0x08,
 	0x16, 0xc0, 0x27, 0x25, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49, 0x50, 0x03,
-	0xb6, 0x1e, 0x83, 0x01,
-	0x38, 0x06, 0x24, 0x31, 0xa1, 0xfe, 0xbb, 0x45, 0x2d, 0x00, 0xa4, 0x46,
-	0x07, 0x90, 0x3f, 0x01,
-	0xfe, 0xf8, 0x15, 0x01, 0xa6, 0x86, 0xfe, 0x4b, 0x45, 0xfe, 0x20, 0x13,
-	0x01, 0x43, 0x09, 0x82,
+	0xb6, 0x1e, 0x83, 0x01, 0x38, 0x06, 0x24, 0x31, 0xa1, 0xfe, 0xbb, 0x45,
+	0x2d, 0x00, 0xa4, 0x46, 0x07, 0x90, 0x3f, 0x01, 0xfe, 0xf8, 0x15, 0x01,
+	0xa6, 0x86, 0xfe, 0x4b, 0x45, 0xfe, 0x20, 0x13, 0x01, 0x43, 0x09, 0x82,
 	0xfe, 0x16, 0x13, 0x03, 0x9a, 0x1e, 0x5d, 0x03, 0x55, 0x1e, 0x31, 0x5e,
-	0x05, 0x72, 0xfe, 0xc0,
-	0x5d, 0x01, 0xa7, 0xfe, 0x03, 0x17, 0x03, 0x66, 0x8a, 0x10, 0x66, 0x5e,
-	0x32, 0x01, 0x08, 0x17,
-	0x73, 0x01, 0xfe, 0x56, 0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16,
-	0x3d, 0x27, 0x25, 0xbd,
+	0x05, 0x72, 0xfe, 0xc0, 0x5d, 0x01, 0xa7, 0xfe, 0x03, 0x17, 0x03, 0x66,
+	0x8a, 0x10, 0x66, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73, 0x01, 0xfe, 0x56,
+	0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0x3d, 0x27, 0x25, 0xbd,
 	0x09, 0x07, 0x2b, 0x3d, 0x01, 0xfe, 0xbe, 0x16, 0xfe, 0x42, 0x58, 0xfe,
-	0xe8, 0x14, 0x01, 0xa6,
-	0x86, 0xfe, 0x4a, 0xf4, 0x0d, 0x1b, 0x3d, 0xfe, 0x4a, 0xf4, 0x07, 0xfe,
-	0x0e, 0x12, 0x01, 0x43,
-	0x09, 0x82, 0x4e, 0x05, 0x72, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x5e, 0x32,
-	0x01, 0x08, 0x17, 0x73,
+	0xe8, 0x14, 0x01, 0xa6, 0x86, 0xfe, 0x4a, 0xf4, 0x0d, 0x1b, 0x3d, 0xfe,
+	0x4a, 0xf4, 0x07, 0xfe, 0x0e, 0x12, 0x01, 0x43, 0x09, 0x82, 0x4e, 0x05,
+	0x72, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73,
 	0x01, 0xfe, 0x84, 0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0x3d,
-	0x27, 0x25, 0xbd, 0x09,
-	0x12, 0x2b, 0x3d, 0x01, 0xfe, 0xe8, 0x17, 0x8b, 0xfe, 0xaa, 0x14, 0xfe,
-	0xb6, 0x14, 0x86, 0xa8,
-	0xb2, 0x0d, 0x1b, 0x3d, 0xb2, 0x07, 0xfe, 0x0e, 0x12, 0x01, 0x43, 0x09,
-	0x82, 0x4e, 0x05, 0x72,
+	0x27, 0x25, 0xbd, 0x09, 0x12, 0x2b, 0x3d, 0x01, 0xfe, 0xe8, 0x17, 0x8b,
+	0xfe, 0xaa, 0x14, 0xfe, 0xb6, 0x14, 0x86, 0xa8, 0xb2, 0x0d, 0x1b, 0x3d,
+	0xb2, 0x07, 0xfe, 0x0e, 0x12, 0x01, 0x43, 0x09, 0x82, 0x4e, 0x05, 0x72,
 	0x03, 0x6f, 0x8a, 0x10, 0x6f, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73, 0x01,
-	0xfe, 0xc0, 0x19, 0x05,
-	0x73, 0x13, 0x07, 0x2f, 0xfe, 0xcc, 0x15, 0x17, 0xfe, 0xe2, 0x15, 0x5f,
-	0xcc, 0x01, 0x08, 0x26,
-	0x5f, 0x02, 0x8f, 0xfe, 0xde, 0x15, 0x2a, 0xfe, 0xde, 0x15, 0x16, 0xfe,
-	0xcc, 0x15, 0x5e, 0x32,
+	0xfe, 0xc0, 0x19, 0x05, 0x73, 0x13, 0x07, 0x2f, 0xfe, 0xcc, 0x15, 0x17,
+	0xfe, 0xe2, 0x15, 0x5f, 0xcc, 0x01, 0x08, 0x26, 0x5f, 0x02, 0x8f, 0xfe,
+	0xde, 0x15, 0x2a, 0xfe, 0xde, 0x15, 0x16, 0xfe, 0xcc, 0x15, 0x5e, 0x32,
 	0x01, 0x08, 0xfe, 0xd5, 0x10, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52,
-	0xad, 0x23, 0xfe, 0xff,
-	0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x02, 0x13, 0x58, 0xff, 0x02,
-	0x00, 0x57, 0x52, 0xad,
-	0x23, 0x3f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x02, 0x13, 0x58, 0xff,
-	0x02, 0x00, 0x57, 0x52,
+	0xad, 0x23, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x02,
+	0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xad, 0x23, 0x3f, 0xfe, 0x30,
+	0x56, 0xfe, 0x00, 0x5c, 0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52,
 	0xad, 0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xfe, 0x00, 0x5e,
-	0x02, 0x13, 0x58, 0xff,
-	0x02, 0x00, 0x57, 0x52, 0xad, 0xfe, 0x0b, 0x58, 0x02, 0x0a, 0x66, 0x01,
-	0x5c, 0x0a, 0x55, 0x01,
-	0x5c, 0x0a, 0x6f, 0x01, 0x5c, 0x02, 0x01, 0xfe, 0x1e, 0x1f, 0x23, 0x1a,
-	0xff, 0x03, 0x00, 0x54,
+	0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xad, 0xfe, 0x0b, 0x58,
+	0x02, 0x0a, 0x66, 0x01, 0x5c, 0x0a, 0x55, 0x01, 0x5c, 0x0a, 0x6f, 0x01,
+	0x5c, 0x02, 0x01, 0xfe, 0x1e, 0x1f, 0x23, 0x1a, 0xff, 0x03, 0x00, 0x54,
 	0xfe, 0x00, 0xf4, 0x24, 0x52, 0x0f, 0xfe, 0x00, 0x7c, 0x04, 0xfe, 0x07,
-	0x7c, 0x3a, 0x0b, 0x0e,
-	0xfe, 0x00, 0x71, 0xfe, 0xf9, 0x18, 0xfe, 0x7a, 0x19, 0xfe, 0xfb, 0x19,
-	0xfe, 0x1a, 0xf7, 0x00,
-	0xfe, 0x1b, 0xf7, 0x00, 0x7a, 0x30, 0x10, 0x68, 0x22, 0x69, 0xd9, 0x6c,
-	0xda, 0x6d, 0x02, 0xfe,
+	0x7c, 0x3a, 0x0b, 0x0e, 0xfe, 0x00, 0x71, 0xfe, 0xf9, 0x18, 0xfe, 0x7a,
+	0x19, 0xfe, 0xfb, 0x19, 0xfe, 0x1a, 0xf7, 0x00, 0xfe, 0x1b, 0xf7, 0x00,
+	0x7a, 0x30, 0x10, 0x68, 0x22, 0x69, 0xd9, 0x6c, 0xda, 0x6d, 0x02, 0xfe,
 	0x62, 0x08, 0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x77,
-	0x02, 0x01, 0xc6, 0xfe,
-	0x42, 0x48, 0x4f, 0x50, 0x45, 0x01, 0x08, 0x16, 0xfe, 0xe0, 0x17, 0x27,
-	0x25, 0xbe, 0x01, 0x08,
-	0x16, 0xfe, 0xe0, 0x17, 0x27, 0x25, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59,
-	0x03, 0x9a, 0x1e, 0xfe,
+	0x02, 0x01, 0xc6, 0xfe, 0x42, 0x48, 0x4f, 0x50, 0x45, 0x01, 0x08, 0x16,
+	0xfe, 0xe0, 0x17, 0x27, 0x25, 0xbe, 0x01, 0x08, 0x16, 0xfe, 0xe0, 0x17,
+	0x27, 0x25, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x03, 0x9a, 0x1e, 0xfe,
 	0xda, 0x12, 0x01, 0x38, 0x06, 0x12, 0xfe, 0xd0, 0x13, 0x26, 0x53, 0x12,
-	0x48, 0xfe, 0x08, 0x17,
-	0xd1, 0x12, 0x53, 0x12, 0xfe, 0x1e, 0x13, 0x2d, 0xb4, 0x7b, 0xfe, 0x26,
-	0x17, 0x4d, 0x13, 0x07,
-	0x1c, 0xb4, 0x90, 0x04, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xf1,
-	0xff, 0x02, 0x83, 0x55,
+	0x48, 0xfe, 0x08, 0x17, 0xd1, 0x12, 0x53, 0x12, 0xfe, 0x1e, 0x13, 0x2d,
+	0xb4, 0x7b, 0xfe, 0x26, 0x17, 0x4d, 0x13, 0x07, 0x1c, 0xb4, 0x90, 0x04,
+	0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xf1, 0xff, 0x02, 0x83, 0x55,
 	0x53, 0x1d, 0xfe, 0x12, 0x13, 0xd6, 0xfe, 0x30, 0x00, 0xb0, 0xfe, 0x80,
-	0x17, 0x1c, 0x63, 0x13,
-	0x07, 0xfe, 0x56, 0x10, 0x53, 0x0d, 0xfe, 0x16, 0x13, 0xd6, 0xfe, 0x64,
-	0x00, 0xb0, 0xfe, 0x80,
-	0x17, 0x0a, 0xfe, 0x64, 0x00, 0x1c, 0x94, 0x13, 0x07, 0xfe, 0x28, 0x10,
-	0x53, 0x07, 0xfe, 0x60,
+	0x17, 0x1c, 0x63, 0x13, 0x07, 0xfe, 0x56, 0x10, 0x53, 0x0d, 0xfe, 0x16,
+	0x13, 0xd6, 0xfe, 0x64, 0x00, 0xb0, 0xfe, 0x80, 0x17, 0x0a, 0xfe, 0x64,
+	0x00, 0x1c, 0x94, 0x13, 0x07, 0xfe, 0x28, 0x10, 0x53, 0x07, 0xfe, 0x60,
 	0x13, 0xd6, 0xfe, 0xc8, 0x00, 0xb0, 0xfe, 0x80, 0x17, 0x0a, 0xfe, 0xc8,
-	0x00, 0x1c, 0x95, 0x13,
-	0x07, 0x71, 0xd6, 0xfe, 0x90, 0x01, 0x48, 0xfe, 0x8c, 0x17, 0x45, 0xf3,
-	0xfe, 0x43, 0xf4, 0x96,
-	0xfe, 0x56, 0xf0, 0xfe, 0x9e, 0x17, 0xfe, 0x04, 0xf4, 0x58, 0xfe, 0x43,
-	0xf4, 0x94, 0xf6, 0x8b,
+	0x00, 0x1c, 0x95, 0x13, 0x07, 0x71, 0xd6, 0xfe, 0x90, 0x01, 0x48, 0xfe,
+	0x8c, 0x17, 0x45, 0xf3, 0xfe, 0x43, 0xf4, 0x96, 0xfe, 0x56, 0xf0, 0xfe,
+	0x9e, 0x17, 0xfe, 0x04, 0xf4, 0x58, 0xfe, 0x43, 0xf4, 0x94, 0xf6, 0x8b,
 	0x01, 0xfe, 0x24, 0x16, 0x23, 0x3f, 0xfc, 0xa8, 0x8c, 0x49, 0x48, 0xfe,
-	0xda, 0x17, 0x62, 0x49,
-	0xfe, 0x1c, 0x10, 0xa8, 0x8c, 0x80, 0x48, 0xfe, 0xda, 0x17, 0x62, 0x80,
-	0x71, 0x50, 0x26, 0xfe,
-	0x4d, 0xf4, 0x00, 0xf7, 0x45, 0x13, 0x07, 0xfe, 0xb4, 0x56, 0xfe, 0xc3,
-	0x58, 0x02, 0x50, 0x13,
+	0xda, 0x17, 0x62, 0x49, 0xfe, 0x1c, 0x10, 0xa8, 0x8c, 0x80, 0x48, 0xfe,
+	0xda, 0x17, 0x62, 0x80, 0x71, 0x50, 0x26, 0xfe, 0x4d, 0xf4, 0x00, 0xf7,
+	0x45, 0x13, 0x07, 0xfe, 0xb4, 0x56, 0xfe, 0xc3, 0x58, 0x02, 0x50, 0x13,
 	0x0d, 0x02, 0x50, 0x3e, 0x78, 0x4f, 0x45, 0x01, 0x08, 0x16, 0xa9, 0x27,
-	0x25, 0xbe, 0xfe, 0x03,
-	0xea, 0xfe, 0x7e, 0x01, 0x01, 0x08, 0x16, 0xa9, 0x27, 0x25, 0xfe, 0xe9,
-	0x0a, 0x01, 0x08, 0x16,
-	0xa9, 0x27, 0x25, 0xfe, 0xe9, 0x0a, 0xfe, 0x05, 0xea, 0xfe, 0x7f, 0x01,
-	0x01, 0x08, 0x16, 0xa9,
+	0x25, 0xbe, 0xfe, 0x03, 0xea, 0xfe, 0x7e, 0x01, 0x01, 0x08, 0x16, 0xa9,
+	0x27, 0x25, 0xfe, 0xe9, 0x0a, 0x01, 0x08, 0x16, 0xa9, 0x27, 0x25, 0xfe,
+	0xe9, 0x0a, 0xfe, 0x05, 0xea, 0xfe, 0x7f, 0x01, 0x01, 0x08, 0x16, 0xa9,
 	0x27, 0x25, 0xfe, 0x69, 0x09, 0xfe, 0x02, 0xea, 0xfe, 0x80, 0x01, 0x01,
-	0x08, 0x16, 0xa9, 0x27,
-	0x25, 0xfe, 0xe8, 0x08, 0x47, 0xfe, 0x81, 0x01, 0x03, 0xb6, 0x1e, 0x83,
-	0x01, 0x38, 0x06, 0x24,
-	0x31, 0xa2, 0x78, 0xf2, 0x53, 0x07, 0x36, 0xfe, 0x34, 0xf4, 0x3f, 0xa1,
-	0x78, 0x03, 0x9a, 0x1e,
+	0x08, 0x16, 0xa9, 0x27, 0x25, 0xfe, 0xe8, 0x08, 0x47, 0xfe, 0x81, 0x01,
+	0x03, 0xb6, 0x1e, 0x83, 0x01, 0x38, 0x06, 0x24, 0x31, 0xa2, 0x78, 0xf2,
+	0x53, 0x07, 0x36, 0xfe, 0x34, 0xf4, 0x3f, 0xa1, 0x78, 0x03, 0x9a, 0x1e,
 	0x83, 0x01, 0x38, 0x06, 0x12, 0x31, 0xf0, 0x4f, 0x45, 0xfe, 0x90, 0x10,
-	0xfe, 0x40, 0x5a, 0x23,
-	0x3f, 0xfb, 0x8c, 0x49, 0x48, 0xfe, 0xaa, 0x18, 0x62, 0x49, 0x71, 0x8c,
-	0x80, 0x48, 0xfe, 0xaa,
-	0x18, 0x62, 0x80, 0xfe, 0xb4, 0x56, 0xfe, 0x40, 0x5d, 0x01, 0xc6, 0x01,
-	0xfe, 0xac, 0x1d, 0xfe,
+	0xfe, 0x40, 0x5a, 0x23, 0x3f, 0xfb, 0x8c, 0x49, 0x48, 0xfe, 0xaa, 0x18,
+	0x62, 0x49, 0x71, 0x8c, 0x80, 0x48, 0xfe, 0xaa, 0x18, 0x62, 0x80, 0xfe,
+	0xb4, 0x56, 0xfe, 0x40, 0x5d, 0x01, 0xc6, 0x01, 0xfe, 0xac, 0x1d, 0xfe,
 	0x02, 0x17, 0xfe, 0xc8, 0x45, 0xfe, 0x5a, 0xf0, 0xfe, 0xc0, 0x18, 0xfe,
-	0x43, 0x48, 0x2d, 0x93,
-	0x36, 0xfe, 0x34, 0xf4, 0xfe, 0x00, 0x11, 0xfe, 0x40, 0x10, 0x2d, 0xb4,
-	0x36, 0xfe, 0x34, 0xf4,
-	0x04, 0xfe, 0x34, 0x10, 0x2d, 0xfe, 0x0b, 0x00, 0x36, 0x46, 0x63, 0xfe,
-	0x28, 0x10, 0xfe, 0xc0,
+	0x43, 0x48, 0x2d, 0x93, 0x36, 0xfe, 0x34, 0xf4, 0xfe, 0x00, 0x11, 0xfe,
+	0x40, 0x10, 0x2d, 0xb4, 0x36, 0xfe, 0x34, 0xf4, 0x04, 0xfe, 0x34, 0x10,
+	0x2d, 0xfe, 0x0b, 0x00, 0x36, 0x46, 0x63, 0xfe, 0x28, 0x10, 0xfe, 0xc0,
 	0x49, 0xff, 0x02, 0x00, 0x54, 0xb2, 0xfe, 0x90, 0x01, 0x48, 0xfe, 0xfa,
-	0x18, 0x45, 0xfe, 0x1c,
-	0xf4, 0x3f, 0xf3, 0xfe, 0x40, 0xf4, 0x96, 0xfe, 0x56, 0xf0, 0xfe, 0x0c,
-	0x19, 0xfe, 0x04, 0xf4,
-	0x58, 0xfe, 0x40, 0xf4, 0x94, 0xf6, 0x3e, 0x2d, 0x93, 0x4e, 0xd0, 0x0d,
-	0x21, 0xfe, 0x7f, 0x01,
+	0x18, 0x45, 0xfe, 0x1c, 0xf4, 0x3f, 0xf3, 0xfe, 0x40, 0xf4, 0x96, 0xfe,
+	0x56, 0xf0, 0xfe, 0x0c, 0x19, 0xfe, 0x04, 0xf4, 0x58, 0xfe, 0x40, 0xf4,
+	0x94, 0xf6, 0x3e, 0x2d, 0x93, 0x4e, 0xd0, 0x0d, 0x21, 0xfe, 0x7f, 0x01,
 	0xfe, 0xc8, 0x46, 0xfe, 0x24, 0x13, 0x8c, 0x00, 0x5d, 0x26, 0x21, 0xfe,
-	0x7e, 0x01, 0xfe, 0xc8,
-	0x45, 0xfe, 0x14, 0x13, 0x21, 0xfe, 0x80, 0x01, 0xfe, 0x48, 0x45, 0xfa,
-	0x21, 0xfe, 0x81, 0x01,
-	0xfe, 0xc8, 0x44, 0x4e, 0x26, 0x02, 0x13, 0x07, 0x02, 0x78, 0x45, 0x50,
-	0x13, 0x0d, 0x02, 0x14,
+	0x7e, 0x01, 0xfe, 0xc8, 0x45, 0xfe, 0x14, 0x13, 0x21, 0xfe, 0x80, 0x01,
+	0xfe, 0x48, 0x45, 0xfa, 0x21, 0xfe, 0x81, 0x01, 0xfe, 0xc8, 0x44, 0x4e,
+	0x26, 0x02, 0x13, 0x07, 0x02, 0x78, 0x45, 0x50, 0x13, 0x0d, 0x02, 0x14,
 	0x07, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x14, 0x0d, 0x01, 0x08, 0x17,
-	0xfe, 0x82, 0x19, 0x14,
-	0x1d, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x5f, 0xfe, 0x89, 0x49, 0x01,
-	0x08, 0x02, 0x14, 0x07,
-	0x01, 0x08, 0x17, 0xc1, 0x14, 0x1d, 0x01, 0x08, 0x17, 0xc1, 0x14, 0x07,
-	0x01, 0x08, 0x17, 0xc1,
+	0xfe, 0x82, 0x19, 0x14, 0x1d, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x5f,
+	0xfe, 0x89, 0x49, 0x01, 0x08, 0x02, 0x14, 0x07, 0x01, 0x08, 0x17, 0xc1,
+	0x14, 0x1d, 0x01, 0x08, 0x17, 0xc1, 0x14, 0x07, 0x01, 0x08, 0x17, 0xc1,
 	0xfe, 0x89, 0x49, 0x01, 0x08, 0x17, 0xc1, 0x5f, 0xfe, 0x89, 0x4a, 0x01,
-	0x08, 0x02, 0x50, 0x02,
-	0x14, 0x07, 0x01, 0x08, 0x17, 0x74, 0x14, 0x7f, 0x01, 0x08, 0x17, 0x74,
-	0x14, 0x12, 0x01, 0x08,
-	0x17, 0x74, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x17, 0x74, 0x14, 0x00, 0x01,
-	0x08, 0x17, 0x74, 0xfe,
+	0x08, 0x02, 0x50, 0x02, 0x14, 0x07, 0x01, 0x08, 0x17, 0x74, 0x14, 0x7f,
+	0x01, 0x08, 0x17, 0x74, 0x14, 0x12, 0x01, 0x08, 0x17, 0x74, 0xfe, 0x89,
+	0x49, 0x01, 0x08, 0x17, 0x74, 0x14, 0x00, 0x01, 0x08, 0x17, 0x74, 0xfe,
 	0x89, 0x4a, 0x01, 0x08, 0x17, 0x74, 0xfe, 0x09, 0x49, 0x01, 0x08, 0x17,
-	0x74, 0x5f, 0xcc, 0x01,
-	0x08, 0x02, 0x21, 0xe4, 0x09, 0x07, 0xfe, 0x4c, 0x13, 0xc8, 0x20, 0xe4,
-	0xfe, 0x49, 0xf4, 0x00,
-	0x4d, 0x5f, 0xa1, 0x5e, 0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xcc, 0xff,
-	0x02, 0x00, 0x10, 0x2f,
+	0x74, 0x5f, 0xcc, 0x01, 0x08, 0x02, 0x21, 0xe4, 0x09, 0x07, 0xfe, 0x4c,
+	0x13, 0xc8, 0x20, 0xe4, 0xfe, 0x49, 0xf4, 0x00, 0x4d, 0x5f, 0xa1, 0x5e,
+	0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xcc, 0xff, 0x02, 0x00, 0x10, 0x2f,
 	0xfe, 0x3e, 0x1a, 0x01, 0x43, 0x09, 0xfe, 0xe3, 0x00, 0xfe, 0x22, 0x13,
-	0x16, 0xfe, 0x64, 0x1a,
-	0x26, 0x20, 0x9e, 0x01, 0x41, 0x21, 0x9e, 0x09, 0x07, 0x5d, 0x01, 0x0c,
-	0x61, 0x07, 0x44, 0x02,
-	0x0a, 0x5a, 0x01, 0x18, 0xfe, 0x00, 0x40, 0xaa, 0x09, 0x1a, 0xfe, 0x12,
-	0x13, 0x0a, 0x9d, 0x01,
+	0x16, 0xfe, 0x64, 0x1a, 0x26, 0x20, 0x9e, 0x01, 0x41, 0x21, 0x9e, 0x09,
+	0x07, 0x5d, 0x01, 0x0c, 0x61, 0x07, 0x44, 0x02, 0x0a, 0x5a, 0x01, 0x18,
+	0xfe, 0x00, 0x40, 0xaa, 0x09, 0x1a, 0xfe, 0x12, 0x13, 0x0a, 0x9d, 0x01,
 	0x18, 0xaa, 0x0a, 0x67, 0x01, 0xa3, 0x02, 0x0a, 0x9d, 0x01, 0x18, 0xaa,
-	0xfe, 0x80, 0xe7, 0x1a,
-	0x09, 0x1a, 0x5d, 0xfe, 0x45, 0x58, 0x01, 0xfe, 0xb2, 0x16, 0xaa, 0x02,
-	0x0a, 0x5a, 0x01, 0x18,
-	0xaa, 0x0a, 0x67, 0x01, 0xa3, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x01, 0xfe,
-	0x7e, 0x1e, 0xfe, 0x80,
+	0xfe, 0x80, 0xe7, 0x1a, 0x09, 0x1a, 0x5d, 0xfe, 0x45, 0x58, 0x01, 0xfe,
+	0xb2, 0x16, 0xaa, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0xaa, 0x0a, 0x67, 0x01,
+	0xa3, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x01, 0xfe, 0x7e, 0x1e, 0xfe, 0x80,
 	0x4c, 0xfe, 0x49, 0xe4, 0x1a, 0xfe, 0x12, 0x13, 0x0a, 0x9d, 0x01, 0x18,
-	0xfe, 0x80, 0x4c, 0x0a,
-	0x67, 0x01, 0x5c, 0x02, 0x1c, 0x1a, 0x87, 0x7c, 0xe5, 0xfe, 0x18, 0xdf,
-	0xfe, 0x19, 0xde, 0xfe,
-	0x24, 0x1c, 0xfe, 0x1d, 0xf7, 0x28, 0xb1, 0xfe, 0x04, 0x1b, 0x01, 0xfe,
-	0x2a, 0x1c, 0xfa, 0xb3,
+	0xfe, 0x80, 0x4c, 0x0a, 0x67, 0x01, 0x5c, 0x02, 0x1c, 0x1a, 0x87, 0x7c,
+	0xe5, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x24, 0x1c, 0xfe, 0x1d,
+	0xf7, 0x28, 0xb1, 0xfe, 0x04, 0x1b, 0x01, 0xfe, 0x2a, 0x1c, 0xfa, 0xb3,
 	0x28, 0x7c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x02, 0xc9, 0x2b, 0xfe,
-	0xf4, 0x1a, 0xfe, 0xfa,
-	0x10, 0x1c, 0x1a, 0x87, 0x03, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x24,
-	0xfe, 0x18, 0x58, 0x03,
-	0xfe, 0x66, 0x01, 0xfe, 0x19, 0x58, 0xb3, 0x24, 0x01, 0xfe, 0x0e, 0x1f,
-	0xfe, 0x30, 0xf4, 0x07,
+	0xf4, 0x1a, 0xfe, 0xfa, 0x10, 0x1c, 0x1a, 0x87, 0x03, 0xfe, 0x64, 0x01,
+	0xfe, 0x00, 0xf4, 0x24, 0xfe, 0x18, 0x58, 0x03, 0xfe, 0x66, 0x01, 0xfe,
+	0x19, 0x58, 0xb3, 0x24, 0x01, 0xfe, 0x0e, 0x1f, 0xfe, 0x30, 0xf4, 0x07,
 	0xfe, 0x3c, 0x50, 0x7c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c,
-	0xf7, 0x24, 0xb1, 0xfe,
-	0x50, 0x1b, 0xfe, 0xd4, 0x14, 0x31, 0x02, 0xc9, 0x2b, 0xfe, 0x26, 0x1b,
-	0xfe, 0xba, 0x10, 0x1c,
-	0x1a, 0x87, 0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe,
-	0x1d, 0xf7, 0x54, 0xb1,
+	0xf7, 0x24, 0xb1, 0xfe, 0x50, 0x1b, 0xfe, 0xd4, 0x14, 0x31, 0x02, 0xc9,
+	0x2b, 0xfe, 0x26, 0x1b, 0xfe, 0xba, 0x10, 0x1c, 0x1a, 0x87, 0xfe, 0x83,
+	0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7, 0x54, 0xb1,
 	0xfe, 0x72, 0x1b, 0xfe, 0xb2, 0x14, 0xfc, 0xb3, 0x54, 0x7c, 0x12, 0xfe,
-	0xaf, 0x19, 0xfe, 0x98,
-	0xe7, 0x00, 0x02, 0xc9, 0x2b, 0xfe, 0x66, 0x1b, 0xfe, 0x8a, 0x10, 0x1c,
-	0x1a, 0x87, 0x8b, 0x0f,
-	0xfe, 0x30, 0x90, 0x04, 0xfe, 0xb0, 0x93, 0x3a, 0x0b, 0xfe, 0x18, 0x58,
-	0xfe, 0x32, 0x90, 0x04,
+	0xaf, 0x19, 0xfe, 0x98, 0xe7, 0x00, 0x02, 0xc9, 0x2b, 0xfe, 0x66, 0x1b,
+	0xfe, 0x8a, 0x10, 0x1c, 0x1a, 0x87, 0x8b, 0x0f, 0xfe, 0x30, 0x90, 0x04,
+	0xfe, 0xb0, 0x93, 0x3a, 0x0b, 0xfe, 0x18, 0x58, 0xfe, 0x32, 0x90, 0x04,
 	0xfe, 0xb2, 0x93, 0x3a, 0x0b, 0xfe, 0x19, 0x58, 0x0e, 0xa8, 0xb3, 0x4a,
-	0x7c, 0x12, 0xfe, 0x0f,
-	0x79, 0xfe, 0x1c, 0xf7, 0x4a, 0xb1, 0xfe, 0xc6, 0x1b, 0xfe, 0x5e, 0x14,
-	0x31, 0x02, 0xc9, 0x2b,
-	0xfe, 0x96, 0x1b, 0x5c, 0xfe, 0x02, 0xf6, 0x1a, 0x87, 0xfe, 0x18, 0xfe,
-	0x6a, 0xfe, 0x19, 0xfe,
+	0x7c, 0x12, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x4a, 0xb1, 0xfe, 0xc6,
+	0x1b, 0xfe, 0x5e, 0x14, 0x31, 0x02, 0xc9, 0x2b, 0xfe, 0x96, 0x1b, 0x5c,
+	0xfe, 0x02, 0xf6, 0x1a, 0x87, 0xfe, 0x18, 0xfe, 0x6a, 0xfe, 0x19, 0xfe,
 	0x6b, 0x01, 0xfe, 0x1e, 0x1f, 0xfe, 0x1d, 0xf7, 0x65, 0xb1, 0xfe, 0xee,
-	0x1b, 0xfe, 0x36, 0x14,
-	0xfe, 0x1c, 0x13, 0xb3, 0x65, 0x3e, 0xfe, 0x83, 0x58, 0xfe, 0xaf, 0x19,
-	0xfe, 0x80, 0xe7, 0x1a,
-	0xfe, 0x81, 0xe7, 0x1a, 0x15, 0xfe, 0xdd, 0x00, 0x7a, 0x30, 0x02, 0x7a,
-	0x30, 0xfe, 0x12, 0x45,
+	0x1b, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13, 0xb3, 0x65, 0x3e, 0xfe, 0x83,
+	0x58, 0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7, 0x1a, 0xfe, 0x81, 0xe7, 0x1a,
+	0x15, 0xfe, 0xdd, 0x00, 0x7a, 0x30, 0x02, 0x7a, 0x30, 0xfe, 0x12, 0x45,
 	0x2b, 0xfe, 0xdc, 0x1b, 0x1f, 0x07, 0x47, 0xb5, 0xc3, 0x05, 0x35, 0xfe,
-	0x39, 0xf0, 0x75, 0x26,
-	0x02, 0xfe, 0x7e, 0x18, 0x23, 0x1d, 0x36, 0x13, 0x11, 0x02, 0x87, 0x03,
-	0xe3, 0x23, 0x07, 0xfe,
-	0xef, 0x12, 0xfe, 0xe1, 0x10, 0x90, 0x34, 0x60, 0xfe, 0x02, 0x80, 0x09,
-	0x56, 0xfe, 0x3c, 0x13,
+	0x39, 0xf0, 0x75, 0x26, 0x02, 0xfe, 0x7e, 0x18, 0x23, 0x1d, 0x36, 0x13,
+	0x11, 0x02, 0x87, 0x03, 0xe3, 0x23, 0x07, 0xfe, 0xef, 0x12, 0xfe, 0xe1,
+	0x10, 0x90, 0x34, 0x60, 0xfe, 0x02, 0x80, 0x09, 0x56, 0xfe, 0x3c, 0x13,
 	0xfe, 0x82, 0x14, 0xfe, 0x42, 0x13, 0x51, 0xfe, 0x06, 0x83, 0x0a, 0x5a,
-	0x01, 0x18, 0xcb, 0xfe,
-	0x3e, 0x12, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01, 0xfe, 0xb2, 0x16,
-	0xfe, 0x00, 0xcc, 0xcb,
-	0xfe, 0xf3, 0x13, 0x3f, 0x89, 0x09, 0x1a, 0xa5, 0x0a, 0x9d, 0x01, 0x18,
-	0xfe, 0x80, 0x4c, 0x01,
+	0x01, 0x18, 0xcb, 0xfe, 0x3e, 0x12, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48,
+	0x01, 0xfe, 0xb2, 0x16, 0xfe, 0x00, 0xcc, 0xcb, 0xfe, 0xf3, 0x13, 0x3f,
+	0x89, 0x09, 0x1a, 0xa5, 0x0a, 0x9d, 0x01, 0x18, 0xfe, 0x80, 0x4c, 0x01,
 	0x85, 0xfe, 0x16, 0x10, 0x09, 0x9b, 0x4e, 0xfe, 0x40, 0x14, 0xfe, 0x24,
-	0x12, 0xfe, 0x14, 0x56,
-	0xfe, 0xd6, 0xf0, 0xfe, 0x52, 0x1c, 0x1c, 0x0d, 0x02, 0xfe, 0x9c, 0xe7,
-	0x0d, 0x19, 0xfe, 0x15,
-	0x00, 0x40, 0x8d, 0x30, 0x01, 0xf4, 0x1c, 0x07, 0x02, 0x51, 0xfe, 0x06,
-	0x83, 0xfe, 0x18, 0x80,
+	0x12, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x52, 0x1c, 0x1c, 0x0d,
+	0x02, 0xfe, 0x9c, 0xe7, 0x0d, 0x19, 0xfe, 0x15, 0x00, 0x40, 0x8d, 0x30,
+	0x01, 0xf4, 0x1c, 0x07, 0x02, 0x51, 0xfe, 0x06, 0x83, 0xfe, 0x18, 0x80,
 	0x61, 0x28, 0x44, 0x15, 0x56, 0x01, 0x85, 0x1c, 0x07, 0x02, 0xfe, 0x38,
-	0x90, 0xfe, 0xba, 0x90,
-	0x91, 0xde, 0x7e, 0xdf, 0xfe, 0x48, 0x55, 0x31, 0xfe, 0xc9, 0x55, 0x02,
-	0x21, 0xb9, 0x88, 0x20,
-	0xb9, 0x02, 0x0a, 0xba, 0x01, 0x18, 0xfe, 0x41, 0x48, 0x0a, 0x57, 0x01,
-	0x18, 0xfe, 0x49, 0x44,
+	0x90, 0xfe, 0xba, 0x90, 0x91, 0xde, 0x7e, 0xdf, 0xfe, 0x48, 0x55, 0x31,
+	0xfe, 0xc9, 0x55, 0x02, 0x21, 0xb9, 0x88, 0x20, 0xb9, 0x02, 0x0a, 0xba,
+	0x01, 0x18, 0xfe, 0x41, 0x48, 0x0a, 0x57, 0x01, 0x18, 0xfe, 0x49, 0x44,
 	0x1b, 0xfe, 0x1e, 0x1d, 0x88, 0x89, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x09,
-	0x1a, 0xa4, 0x0a, 0x67,
-	0x01, 0xa3, 0x0a, 0x57, 0x01, 0x18, 0x88, 0x89, 0x02, 0xfe, 0x4e, 0xe4,
-	0x1d, 0x7b, 0xfe, 0x52,
-	0x1d, 0x03, 0xfe, 0x90, 0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10, 0xfe,
-	0x4e, 0xe4, 0xdd, 0x7b,
+	0x1a, 0xa4, 0x0a, 0x67, 0x01, 0xa3, 0x0a, 0x57, 0x01, 0x18, 0x88, 0x89,
+	0x02, 0xfe, 0x4e, 0xe4, 0x1d, 0x7b, 0xfe, 0x52, 0x1d, 0x03, 0xfe, 0x90,
+	0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10, 0xfe, 0x4e, 0xe4, 0xdd, 0x7b,
 	0xfe, 0x64, 0x1d, 0x03, 0xfe, 0x92, 0x00, 0xd1, 0x12, 0xfe, 0x1a, 0x10,
-	0xfe, 0x4e, 0xe4, 0xfe,
-	0x0b, 0x00, 0x7b, 0xfe, 0x76, 0x1d, 0x03, 0xfe, 0x94, 0x00, 0xd1, 0x24,
-	0xfe, 0x08, 0x10, 0x03,
-	0xfe, 0x96, 0x00, 0xd1, 0x63, 0xfe, 0x4e, 0x45, 0x83, 0xca, 0xff, 0x04,
-	0x68, 0x54, 0xfe, 0xf1,
+	0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x7b, 0xfe, 0x76, 0x1d, 0x03, 0xfe,
+	0x94, 0x00, 0xd1, 0x24, 0xfe, 0x08, 0x10, 0x03, 0xfe, 0x96, 0x00, 0xd1,
+	0x63, 0xfe, 0x4e, 0x45, 0x83, 0xca, 0xff, 0x04, 0x68, 0x54, 0xfe, 0xf1,
 	0x10, 0x23, 0x49, 0xfe, 0x08, 0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c,
-	0xfe, 0x1a, 0xf4, 0xfe,
-	0x00, 0x04, 0x83, 0xb2, 0x1d, 0x48, 0xfe, 0xaa, 0x1d, 0x13, 0x1d, 0x02,
-	0x09, 0x92, 0xfe, 0x5a,
-	0xf0, 0xfe, 0xba, 0x1d, 0x2e, 0x93, 0xfe, 0x34, 0x10, 0x09, 0x12, 0xfe,
-	0x5a, 0xf0, 0xfe, 0xc8,
+	0xfe, 0x1a, 0xf4, 0xfe, 0x00, 0x04, 0x83, 0xb2, 0x1d, 0x48, 0xfe, 0xaa,
+	0x1d, 0x13, 0x1d, 0x02, 0x09, 0x92, 0xfe, 0x5a, 0xf0, 0xfe, 0xba, 0x1d,
+	0x2e, 0x93, 0xfe, 0x34, 0x10, 0x09, 0x12, 0xfe, 0x5a, 0xf0, 0xfe, 0xc8,
 	0x1d, 0x2e, 0xb4, 0xfe, 0x26, 0x10, 0x09, 0x1d, 0x36, 0x2e, 0x63, 0xfe,
-	0x1a, 0x10, 0x09, 0x0d,
-	0x36, 0x2e, 0x94, 0xf2, 0x09, 0x07, 0x36, 0x2e, 0x95, 0xa1, 0xc8, 0x02,
-	0x1f, 0x93, 0x01, 0x42,
-	0xfe, 0x04, 0xfe, 0x99, 0x03, 0x9c, 0x8b, 0x02, 0x2a, 0xfe, 0x1c, 0x1e,
-	0xfe, 0x14, 0xf0, 0x08,
+	0x1a, 0x10, 0x09, 0x0d, 0x36, 0x2e, 0x94, 0xf2, 0x09, 0x07, 0x36, 0x2e,
+	0x95, 0xa1, 0xc8, 0x02, 0x1f, 0x93, 0x01, 0x42, 0xfe, 0x04, 0xfe, 0x99,
+	0x03, 0x9c, 0x8b, 0x02, 0x2a, 0xfe, 0x1c, 0x1e, 0xfe, 0x14, 0xf0, 0x08,
 	0x2f, 0xfe, 0x0c, 0x1e, 0x2a, 0xfe, 0x1c, 0x1e, 0x8f, 0xfe, 0x1c, 0x1e,
-	0xfe, 0x82, 0xf0, 0xfe,
-	0x10, 0x1e, 0x02, 0x0f, 0x3f, 0x04, 0xfe, 0x80, 0x83, 0x33, 0x0b, 0x0e,
-	0x02, 0x0f, 0xfe, 0x18,
-	0x80, 0x04, 0xfe, 0x98, 0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x02,
-	0x80, 0x04, 0xfe, 0x82,
+	0xfe, 0x82, 0xf0, 0xfe, 0x10, 0x1e, 0x02, 0x0f, 0x3f, 0x04, 0xfe, 0x80,
+	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x18, 0x80, 0x04, 0xfe, 0x98,
+	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x02, 0x80, 0x04, 0xfe, 0x82,
 	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06, 0x80, 0x04, 0xfe, 0x86,
-	0x83, 0x33, 0x0b, 0x0e,
-	0x02, 0x0f, 0xfe, 0x1b, 0x80, 0x04, 0xfe, 0x9b, 0x83, 0x33, 0x0b, 0x0e,
-	0x02, 0x0f, 0xfe, 0x04,
-	0x80, 0x04, 0xfe, 0x84, 0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x80,
-	0x80, 0x04, 0xfe, 0x80,
+	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x1b, 0x80, 0x04, 0xfe, 0x9b,
+	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x04, 0x80, 0x04, 0xfe, 0x84,
+	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x80, 0x80, 0x04, 0xfe, 0x80,
 	0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x19, 0x81, 0x04,
-	0xfe, 0x99, 0x83, 0xfe,
-	0xca, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06, 0x83, 0x04, 0xfe, 0x86,
-	0x83, 0xfe, 0xce, 0x47,
-	0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x2c, 0x90, 0x04, 0xfe, 0xac, 0x93, 0x3a,
-	0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x99, 0x83, 0xfe, 0xca, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06,
+	0x83, 0x04, 0xfe, 0x86, 0x83, 0xfe, 0xce, 0x47, 0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x2c, 0x90, 0x04, 0xfe, 0xac, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f,
 	0xfe, 0xae, 0x90, 0x04, 0xfe, 0xae, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x08, 0x90, 0x04,
-	0xfe, 0x88, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x8a, 0x90, 0x04,
-	0xfe, 0x8a, 0x93, 0x79,
-	0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x0c, 0x90, 0x04, 0xfe, 0x8c, 0x93, 0x3a,
-	0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x08, 0x90, 0x04, 0xfe, 0x88, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x8a, 0x90, 0x04, 0xfe, 0x8a, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x0c, 0x90, 0x04, 0xfe, 0x8c, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f,
 	0xfe, 0x8e, 0x90, 0x04, 0xfe, 0x8e, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
-	0xfe, 0x3c, 0x90, 0x04,
-	0xfe, 0xbc, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x8b, 0x0f, 0xfe, 0x03, 0x80,
-	0x04, 0xfe, 0x83, 0x83,
-	0x33, 0x0b, 0x77, 0x0e, 0xa8, 0x02, 0xff, 0x66, 0x00, 0x00,
+	0xfe, 0x3c, 0x90, 0x04, 0xfe, 0xbc, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x8b,
+	0x0f, 0xfe, 0x03, 0x80, 0x04, 0xfe, 0x83, 0x83, 0x33, 0x0b, 0x77, 0x0e,
+	0xa8, 0x02, 0xff, 0x66, 0x00, 0x00,
 };
 
 static unsigned short _adv_asc38C1600_size = sizeof(_adv_asc38C1600_buf);	/* 0x1673 */

commit b9d9661400dde3fb2027f5da8db600c66d0f876b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:28 2007 -0600

    [SCSI] advansys: Create AdvLoadMicrocode
    
    Split AdvLoadMicrocode out of AdvInitAsc3550Driver, AdvInitAsc38C0800Driver
    and AdvInitAsc38C1600Driver.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index c216d6a76782..0f02f3f5f63d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -12931,6 +12931,78 @@ static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
 	} while (buf_size > 0);
 }
 
+/*
+ * Load the Microcode
+ *
+ * Write the microcode image to RISC memory starting at address 0.
+ *
+ * The microcode is stored compressed in the following format:
+ *
+ *  254 word (508 byte) table indexed by byte code followed
+ *  by the following byte codes:
+ *
+ *    1-Byte Code:
+ *      00: Emit word 0 in table.
+ *      01: Emit word 1 in table.
+ *      .
+ *      FD: Emit word 253 in table.
+ *
+ *    Multi-Byte Code:
+ *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+ *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+ *
+ * Returns 0 or an error if the checksum doesn't match
+ */
+static int AdvLoadMicrocode(AdvPortAddr iop_base, unsigned char *buf, int size,
+			    int memsize, int chksum)
+{
+	int i, j, end, len = 0;
+	ADV_DCNT sum;
+
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+	for (i = 253 * 2; i < size; i++) {
+		if (buf[i] == 0xff) {
+			unsigned short word = (buf[i + 3] << 8) | buf[i + 2];
+			for (j = 0; j < buf[i + 1]; j++) {
+				AdvWriteWordAutoIncLram(iop_base, word);
+				len += 2;
+			}
+			i += 3;
+		} else if (buf[i] == 0xfe) {
+			unsigned short word = (buf[i + 2] << 8) | buf[i + 1];
+			AdvWriteWordAutoIncLram(iop_base, word);
+			i += 2;
+			len += 2;
+		} else {
+			unsigned char off = buf[i] * 2;
+			unsigned short word = (buf[off + 1] << 8) | buf[off];
+			AdvWriteWordAutoIncLram(iop_base, word);
+			len += 2;
+		}
+	}
+
+	end = len;
+
+	while (len < memsize) {
+		AdvWriteWordAutoIncLram(iop_base, 0);
+		len += 2;
+	}
+
+	/* Verify the microcode checksum. */
+	sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+	for (len = 0; len < end; len += 2) {
+		sum += AdvReadWordAutoIncLram(iop_base);
+	}
+
+	if (sum != chksum)
+		return ASC_IERR_MCODE_CHKSUM;
+
+	return 0;
+}
+
 /*
  * Initialize the ASC-3550.
  *
@@ -12945,13 +13017,10 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
-	ADV_DCNT sum;
 	int begin_addr;
 	int end_addr;
 	ushort code_sum;
 	int word;
-	int j;
-	int adv_asc3550_expanded_size;
 	int i;
 	ushort scsi_cfg1;
 	uchar tid;
@@ -12960,15 +13029,14 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	uchar max_cmd[ADV_MAX_TID + 1];
 
 	/* If there is already an error, don't continue. */
-	if (asc_dvc->err_code != 0) {
+	if (asc_dvc->err_code != 0)
 		return ADV_ERROR;
-	}
 
 	/*
 	 * The caller must set 'chip_type' to ADV_CHIP_ASC3550.
 	 */
 	if (asc_dvc->chip_type != ADV_CHIP_ASC3550) {
-		asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
+		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
 		return ADV_ERROR;
 	}
 
@@ -13012,84 +13080,11 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 				max_cmd[tid]);
 	}
 
-	/*
-	 * Load the Microcode
-	 *
-	 * Write the microcode image to RISC memory starting at address 0.
-	 */
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-	/* Assume the following compressed format of the microcode buffer:
-	 *
-	 *  254 word (508 byte) table indexed by byte code followed
-	 *  by the following byte codes:
-	 *
-	 *    1-Byte Code:
-	 *      00: Emit word 0 in table.
-	 *      01: Emit word 1 in table.
-	 *      .
-	 *      FD: Emit word 253 in table.
-	 *
-	 *    Multi-Byte Code:
-	 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
-	 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
-	 */
-	word = 0;
-	for (i = 253 * 2; i < _adv_asc3550_size; i++) {
-		if (_adv_asc3550_buf[i] == 0xff) {
-			for (j = 0; j < _adv_asc3550_buf[i + 1]; j++) {
-				AdvWriteWordAutoIncLram(iop_base, (((ushort)
-								    _adv_asc3550_buf
-								    [i +
-								     3] << 8) |
-								   _adv_asc3550_buf
-								   [i + 2]));
-				word++;
-			}
-			i += 3;
-		} else if (_adv_asc3550_buf[i] == 0xfe) {
-			AdvWriteWordAutoIncLram(iop_base, (((ushort)
-							    _adv_asc3550_buf[i +
-									     2]
-							    << 8) |
-							   _adv_asc3550_buf[i +
-									    1]));
-			i += 2;
-			word++;
-		} else {
-			AdvWriteWordAutoIncLram(iop_base, (((ushort)
-							    _adv_asc3550_buf[(_adv_asc3550_buf[i] * 2) + 1] << 8) | _adv_asc3550_buf[_adv_asc3550_buf[i] * 2]));
-			word++;
-		}
-	}
-
-	/*
-	 * Set 'word' for later use to clear the rest of memory and save
-	 * the expanded mcode size.
-	 */
-	word *= 2;
-	adv_asc3550_expanded_size = word;
-
-	/*
-	 * Clear the rest of ASC-3550 Internal RAM (8KB).
-	 */
-	for (; word < ADV_3550_MEMSIZE; word += 2) {
-		AdvWriteWordAutoIncLram(iop_base, 0);
-	}
-
-	/*
-	 * Verify the microcode checksum.
-	 */
-	sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-	for (word = 0; word < adv_asc3550_expanded_size; word += 2) {
-		sum += AdvReadWordAutoIncLram(iop_base);
-	}
-
-	if (sum != _adv_asc3550_chksum) {
-		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc3550_buf,
+					_adv_asc3550_size, ADV_3550_MEMSIZE,
+					_adv_asc3550_chksum);
+	if (asc_dvc->err_code)
 		return ADV_ERROR;
-	}
 
 	/*
 	 * Restore the RISC memory BIOS region.
@@ -13460,13 +13455,10 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
-	ADV_DCNT sum;
 	int begin_addr;
 	int end_addr;
 	ushort code_sum;
 	int word;
-	int j;
-	int adv_asc38C0800_expanded_size;
 	int i;
 	ushort scsi_cfg1;
 	uchar byte;
@@ -13476,9 +13468,8 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	uchar max_cmd[ADV_MAX_TID + 1];
 
 	/* If there is already an error, don't continue. */
-	if (asc_dvc->err_code != 0) {
+	if (asc_dvc->err_code != 0)
 		return ADV_ERROR;
-	}
 
 	/*
 	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.
@@ -13550,7 +13541,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
 		if ((byte & RAM_TEST_DONE) == 0
 		    || (byte & 0x0F) != PRE_TEST_VALUE) {
-			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
 			return ADV_ERROR;
 		}
 
@@ -13558,7 +13549,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
 		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
 		    != NORMAL_VALUE) {
-			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
 			return ADV_ERROR;
 		}
 	}
@@ -13577,99 +13568,18 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
 		/* Get here if Done bit not set or Status not 0. */
 		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
-		asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
+		asc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;
 		return ADV_ERROR;
 	}
 
 	/* We need to reset back to normal mode after LRAM test passes. */
 	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
 
-	/*
-	 * Load the Microcode
-	 *
-	 * Write the microcode image to RISC memory starting at address 0.
-	 *
-	 */
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-	/* Assume the following compressed format of the microcode buffer:
-	 *
-	 *  254 word (508 byte) table indexed by byte code followed
-	 *  by the following byte codes:
-	 *
-	 *    1-Byte Code:
-	 *      00: Emit word 0 in table.
-	 *      01: Emit word 1 in table.
-	 *      .
-	 *      FD: Emit word 253 in table.
-	 *
-	 *    Multi-Byte Code:
-	 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
-	 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
-	 */
-	word = 0;
-	for (i = 253 * 2; i < _adv_asc38C0800_size; i++) {
-		if (_adv_asc38C0800_buf[i] == 0xff) {
-			for (j = 0; j < _adv_asc38C0800_buf[i + 1]; j++) {
-				AdvWriteWordAutoIncLram(iop_base, (((ushort)
-								    _adv_asc38C0800_buf
-								    [i +
-								     3] << 8) |
-								   _adv_asc38C0800_buf
-								   [i + 2]));
-				word++;
-			}
-			i += 3;
-		} else if (_adv_asc38C0800_buf[i] == 0xfe) {
-			AdvWriteWordAutoIncLram(iop_base, (((ushort)
-							    _adv_asc38C0800_buf
-							    [i +
-							     2] << 8) |
-							   _adv_asc38C0800_buf[i
-									       +
-									       1]));
-			i += 2;
-			word++;
-		} else {
-			AdvWriteWordAutoIncLram(iop_base, (((ushort)
-							    _adv_asc38C0800_buf[(_adv_asc38C0800_buf[i] * 2) + 1] << 8) | _adv_asc38C0800_buf[_adv_asc38C0800_buf[i] * 2]));
-			word++;
-		}
-	}
-
-	/*
-	 * Set 'word' for later use to clear the rest of memory and save
-	 * the expanded mcode size.
-	 */
-	word *= 2;
-	adv_asc38C0800_expanded_size = word;
-
-	/*
-	 * Clear the rest of ASC-38C0800 Internal RAM (16KB).
-	 */
-	for (; word < ADV_38C0800_MEMSIZE; word += 2) {
-		AdvWriteWordAutoIncLram(iop_base, 0);
-	}
-
-	/*
-	 * Verify the microcode checksum.
-	 */
-	sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-	for (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {
-		sum += AdvReadWordAutoIncLram(iop_base);
-	}
-	ASC_DBG2(1, "AdvInitAsc38C0800Driver: word %d, i %d\n", word, i);
-
-	ASC_DBG2(1,
-		 "AdvInitAsc38C0800Driver: sum 0x%lx, _adv_asc38C0800_chksum 0x%lx\n",
-		 (ulong)sum, (ulong)_adv_asc38C0800_chksum);
-
-	if (sum != _adv_asc38C0800_chksum) {
-		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C0800_buf,
+				 _adv_asc38C0800_size, ADV_38C0800_MEMSIZE,
+				 _adv_asc38C0800_chksum);
+	if (asc_dvc->err_code)
 		return ADV_ERROR;
-	}
 
 	/*
 	 * Restore the RISC memory BIOS region.
@@ -13807,16 +13717,18 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	}
 
 	/*
-	 * All kind of combinations of devices attached to one of four connectors
-	 * are acceptable except HVD device attached. For example, LVD device can
-	 * be attached to SE connector while SE device attached to LVD connector.
-	 * If LVD device attached to SE connector, it only runs up to Ultra speed.
+	 * All kind of combinations of devices attached to one of four
+	 * connectors are acceptable except HVD device attached. For example,
+	 * LVD device can be attached to SE connector while SE device attached
+	 * to LVD connector.  If LVD device attached to SE connector, it only
+	 * runs up to Ultra speed.
 	 *
-	 * If an HVD device is attached to one of LVD connectors, return an error.
-	 * However, there is no way to detect HVD device attached to SE connectors.
+	 * If an HVD device is attached to one of LVD connectors, return an
+	 * error.  However, there is no way to detect HVD device attached to
+	 * SE connectors.
 	 */
 	if (scsi_cfg1 & HVD) {
-		asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
+		asc_dvc->err_code = ASC_IERR_HVD_DEVICE;
 		return ADV_ERROR;
 	}
 
@@ -13825,8 +13737,8 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	 * set the termination value based on a table listed in a_condor.h.
 	 *
 	 * If manual termination was specified with an EEPROM setting then
-	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to
-	 * be 'ored' into SCSI_CFG1.
+	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready
+	 * to be 'ored' into SCSI_CFG1.
 	 */
 	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
 		/* SE automatic termination control is enabled. */
@@ -13872,9 +13784,9 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	scsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);
 
 	/*
-	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits
-	 * and set possibly modified termination control bits in the Microcode
-	 * SCSI_CFG1 Register Value.
+	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE
+	 * bits and set possibly modified termination control bits in the
+	 * Microcode SCSI_CFG1 Register Value.
 	 */
 	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);
 
@@ -14022,13 +13934,10 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
-	ADV_DCNT sum;
 	int begin_addr;
 	int end_addr;
 	ushort code_sum;
 	long word;
-	int j;
-	int adv_asc38C1600_expanded_size;
 	int i;
 	ushort scsi_cfg1;
 	uchar byte;
@@ -14113,7 +14022,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
 		if ((byte & RAM_TEST_DONE) == 0
 		    || (byte & 0x0F) != PRE_TEST_VALUE) {
-			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
 			return ADV_ERROR;
 		}
 
@@ -14121,7 +14030,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
 		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
 		    != NORMAL_VALUE) {
-			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			asc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;
 			return ADV_ERROR;
 		}
 	}
@@ -14140,95 +14049,18 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
 		/* Get here if Done bit not set or Status not 0. */
 		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
-		asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
+		asc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;
 		return ADV_ERROR;
 	}
 
 	/* We need to reset back to normal mode after LRAM test passes. */
 	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
 
-	/*
-	 * Load the Microcode
-	 *
-	 * Write the microcode image to RISC memory starting at address 0.
-	 *
-	 */
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-	/*
-	 * Assume the following compressed format of the microcode buffer:
-	 *
-	 *  254 word (508 byte) table indexed by byte code followed
-	 *  by the following byte codes:
-	 *
-	 *    1-Byte Code:
-	 *      00: Emit word 0 in table.
-	 *      01: Emit word 1 in table.
-	 *      .
-	 *      FD: Emit word 253 in table.
-	 *
-	 *    Multi-Byte Code:
-	 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
-	 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
-	 */
-	word = 0;
-	for (i = 253 * 2; i < _adv_asc38C1600_size; i++) {
-		if (_adv_asc38C1600_buf[i] == 0xff) {
-			for (j = 0; j < _adv_asc38C1600_buf[i + 1]; j++) {
-				AdvWriteWordAutoIncLram(iop_base, (((ushort)
-								    _adv_asc38C1600_buf
-								    [i +
-								     3] << 8) |
-								   _adv_asc38C1600_buf
-								   [i + 2]));
-				word++;
-			}
-			i += 3;
-		} else if (_adv_asc38C1600_buf[i] == 0xfe) {
-			AdvWriteWordAutoIncLram(iop_base, (((ushort)
-							    _adv_asc38C1600_buf
-							    [i +
-							     2] << 8) |
-							   _adv_asc38C1600_buf[i
-									       +
-									       1]));
-			i += 2;
-			word++;
-		} else {
-			AdvWriteWordAutoIncLram(iop_base, (((ushort)
-							    _adv_asc38C1600_buf[(_adv_asc38C1600_buf[i] * 2) + 1] << 8) | _adv_asc38C1600_buf[_adv_asc38C1600_buf[i] * 2]));
-			word++;
-		}
-	}
-
-	/*
-	 * Set 'word' for later use to clear the rest of memory and save
-	 * the expanded mcode size.
-	 */
-	word *= 2;
-	adv_asc38C1600_expanded_size = word;
-
-	/*
-	 * Clear the rest of ASC-38C1600 Internal RAM (32KB).
-	 */
-	for (; word < ADV_38C1600_MEMSIZE; word += 2) {
-		AdvWriteWordAutoIncLram(iop_base, 0);
-	}
-
-	/*
-	 * Verify the microcode checksum.
-	 */
-	sum = 0;
-	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-	for (word = 0; word < adv_asc38C1600_expanded_size; word += 2) {
-		sum += AdvReadWordAutoIncLram(iop_base);
-	}
-
-	if (sum != _adv_asc38C1600_chksum) {
-		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+	asc_dvc->err_code = AdvLoadMicrocode(iop_base, _adv_asc38C1600_buf,
+				 _adv_asc38C1600_size, ADV_38C1600_MEMSIZE,
+				 _adv_asc38C1600_chksum);
+	if (asc_dvc->err_code)
 		return ADV_ERROR;
-	}
 
 	/*
 	 * Restore the RISC memory BIOS region.

commit a9f4a59a949c5de6313dcf4ebe2f91448c008a37
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:27 2007 -0600

    [SCSI] advansys: Create AdvBuildCarrierFreelist
    
    Split AdvBuildCarrierFreelist out of AdvInitAsc3550Driver,
    AdvInitAsc38C0800Driver and AdvInitAsc38C1600Driver.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 27b3e95c4e66..c216d6a76782 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -12881,6 +12881,56 @@ AdvInitGetConfig(struct pci_dev *pdev, ADV_DVC_VAR *asc_dvc)
 	return warn_code;
 }
 
+static void AdvBuildCarrierFreelist(struct adv_dvc_var *asc_dvc)
+{
+	ADV_CARR_T *carrp;
+	ADV_SDCNT buf_size;
+	ADV_PADDR carr_paddr;
+
+	BUG_ON(!asc_dvc->carrier_buf);
+
+	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+	asc_dvc->carr_freelist = NULL;
+	if (carrp == asc_dvc->carrier_buf) {
+		buf_size = ADV_CARRIER_BUFSIZE;
+	} else {
+		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+	}
+
+	do {
+		/* Get physical address of the carrier 'carrp'. */
+		ADV_DCNT contig_len = sizeof(ADV_CARR_T);
+		carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL,
+						       (uchar *)carrp,
+						       (ADV_SDCNT *)&contig_len,
+						       ADV_IS_CARRIER_FLAG));
+
+		buf_size -= sizeof(ADV_CARR_T);
+
+		/*
+		 * If the current carrier is not physically contiguous, then
+		 * maybe there was a page crossing. Try the next carrier
+		 * aligned start address.
+		 */
+		if (contig_len < sizeof(ADV_CARR_T)) {
+			carrp++;
+			continue;
+		}
+
+		carrp->carr_pa = carr_paddr;
+		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+
+		/*
+		 * Insert the carrier at the beginning of the freelist.
+		 */
+		carrp->next_vpa =
+			cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = carrp;
+
+		carrp++;
+	} while (buf_size > 0);
+}
+
 /*
  * Initialize the ASC-3550.
  *
@@ -12902,10 +12952,6 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	int word;
 	int j;
 	int adv_asc3550_expanded_size;
-	ADV_CARR_T *carrp;
-	ADV_DCNT contig_len;
-	ADV_SDCNT buf_size;
-	ADV_PADDR carr_paddr;
 	int i;
 	ushort scsi_cfg1;
 	uchar tid;
@@ -13307,57 +13353,7 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
 			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
 
-	/*
-	 * Build carrier freelist.
-	 *
-	 * Driver must have already allocated memory and set 'carrier_buf'.
-	 */
-	ASC_ASSERT(asc_dvc->carrier_buf != NULL);
-
-	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-	asc_dvc->carr_freelist = NULL;
-	if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf) {
-		buf_size = ADV_CARRIER_BUFSIZE;
-	} else {
-		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-	}
-
-	do {
-		/*
-		 * Get physical address of the carrier 'carrp'.
-		 */
-		contig_len = sizeof(ADV_CARR_T);
-		carr_paddr =
-		    cpu_to_le32(DvcGetPhyAddr
-				(asc_dvc, NULL, (uchar *)carrp,
-				 (ADV_SDCNT *)&contig_len,
-				 ADV_IS_CARRIER_FLAG));
-
-		buf_size -= sizeof(ADV_CARR_T);
-
-		/*
-		 * If the current carrier is not physically contiguous, then
-		 * maybe there was a page crossing. Try the next carrier aligned
-		 * start address.
-		 */
-		if (contig_len < sizeof(ADV_CARR_T)) {
-			carrp++;
-			continue;
-		}
-
-		carrp->carr_pa = carr_paddr;
-		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
-
-		/*
-		 * Insert the carrier at the beginning of the freelist.
-		 */
-		carrp->next_vpa =
-		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-		asc_dvc->carr_freelist = carrp;
-
-		carrp++;
-	}
-	while (buf_size > 0);
+	AdvBuildCarrierFreelist(asc_dvc);
 
 	/*
 	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
@@ -13471,10 +13467,6 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	int word;
 	int j;
 	int adv_asc38C0800_expanded_size;
-	ADV_CARR_T *carrp;
-	ADV_DCNT contig_len;
-	ADV_SDCNT buf_size;
-	ADV_PADDR carr_paddr;
 	int i;
 	ushort scsi_cfg1;
 	uchar byte;
@@ -13920,57 +13912,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
 			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
 
-	/*
-	 * Build the carrier freelist.
-	 *
-	 * Driver must have already allocated memory and set 'carrier_buf'.
-	 */
-	ASC_ASSERT(asc_dvc->carrier_buf != NULL);
-
-	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-	asc_dvc->carr_freelist = NULL;
-	if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf) {
-		buf_size = ADV_CARRIER_BUFSIZE;
-	} else {
-		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-	}
-
-	do {
-		/*
-		 * Get physical address for the carrier 'carrp'.
-		 */
-		contig_len = sizeof(ADV_CARR_T);
-		carr_paddr =
-		    cpu_to_le32(DvcGetPhyAddr
-				(asc_dvc, NULL, (uchar *)carrp,
-				 (ADV_SDCNT *)&contig_len,
-				 ADV_IS_CARRIER_FLAG));
-
-		buf_size -= sizeof(ADV_CARR_T);
-
-		/*
-		 * If the current carrier is not physically contiguous, then
-		 * maybe there was a page crossing. Try the next carrier aligned
-		 * start address.
-		 */
-		if (contig_len < sizeof(ADV_CARR_T)) {
-			carrp++;
-			continue;
-		}
-
-		carrp->carr_pa = carr_paddr;
-		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
-
-		/*
-		 * Insert the carrier at the beginning of the freelist.
-		 */
-		carrp->next_vpa =
-		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-		asc_dvc->carr_freelist = carrp;
-
-		carrp++;
-	}
-	while (buf_size > 0);
+	AdvBuildCarrierFreelist(asc_dvc);
 
 	/*
 	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
@@ -14087,10 +14029,6 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	long word;
 	int j;
 	int adv_asc38C1600_expanded_size;
-	ADV_CARR_T *carrp;
-	ADV_DCNT contig_len;
-	ADV_SDCNT buf_size;
-	ADV_PADDR carr_paddr;
 	int i;
 	ushort scsi_cfg1;
 	uchar byte;
@@ -14544,58 +14482,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
 			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
 
-	/*
-	 * Build the carrier freelist.
-	 *
-	 * Driver must have already allocated memory and set 'carrier_buf'.
-	 */
-
-	ASC_ASSERT(asc_dvc->carrier_buf != NULL);
-
-	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-	asc_dvc->carr_freelist = NULL;
-	if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf) {
-		buf_size = ADV_CARRIER_BUFSIZE;
-	} else {
-		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-	}
-
-	do {
-		/*
-		 * Get physical address for the carrier 'carrp'.
-		 */
-		contig_len = sizeof(ADV_CARR_T);
-		carr_paddr =
-		    cpu_to_le32(DvcGetPhyAddr
-				(asc_dvc, NULL, (uchar *)carrp,
-				 (ADV_SDCNT *)&contig_len,
-				 ADV_IS_CARRIER_FLAG));
-
-		buf_size -= sizeof(ADV_CARR_T);
-
-		/*
-		 * If the current carrier is not physically contiguous, then
-		 * maybe there was a page crossing. Try the next carrier aligned
-		 * start address.
-		 */
-		if (contig_len < sizeof(ADV_CARR_T)) {
-			carrp++;
-			continue;
-		}
-
-		carrp->carr_pa = carr_paddr;
-		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
-
-		/*
-		 * Insert the carrier at the beginning of the freelist.
-		 */
-		carrp->next_vpa =
-		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-		asc_dvc->carr_freelist = carrp;
-
-		carrp++;
-	}
-	while (buf_size > 0);
+	AdvBuildCarrierFreelist(asc_dvc);
 
 	/*
 	 * Set-up the Host->RISC Initiator Command Queue (ICQ).

commit b8e5152bf107d7b1b982e682b00a426b515bf15f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Sep 9 08:56:26 2007 -0600

    [SCSI] advansys: Fix VLB driver name
    
    You can't have two drivers for the same bus type with the same name.
    Since ISA and VLB are both isa_drivers, rename the VLB one to advansys_vlb.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 4d4d7c9b22bb..27b3e95c4e66 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -16985,7 +16985,7 @@ static struct isa_driver advansys_vlb_driver = {
 	.remove		= __devexit_p(advansys_isa_remove),
 	.driver = {
 		.owner	= THIS_MODULE,
-		.name	= "advansys",
+		.name	= "advansys_vlb",
 	},
 };
 

commit 4bd6d7f35661a32ed50b72f02b684f894feeaa48
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 08:41:03 2007 -0600

    [SCSI] advansys: Move documentation to Documentation/scsi
    
    The 700+-line comment at the top of the advansys driver fits more comfortably
    in Documentation/scsi.
    
    Delete the sections on:
     - kernels supported
     - other files modified (obsolete)
     - source comments (obsolete)
     - tests to run
     - release history (that's what a VCS is for)
     - contacting connectcom (the domain has expired and the phone number is
       now in use by another organisation)
    
    Known problems/fix list is moved down to the section where jejb put his FIXME.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 19c2d19f254c..4d4d7c9b22bb 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -20,743 +20,6 @@
  * On June 18, 2001 Initio Corp. acquired ConnectCom's SCSI assets
  */
 
-/*
-
-  Documentation for the AdvanSys Driver
-
-  A. Linux Kernels Supported by this Driver
-  B. Adapters Supported by this Driver
-  C. Linux source files modified by AdvanSys Driver
-  D. Source Comments
-  E. Driver Compile Time Options and Debugging
-  F. Driver LILO Option
-  G. Tests to run before releasing new driver
-  H. Release History
-  I. Known Problems/Fix List
-  J. Credits (Chronological Order)
-
-  A. Linux Kernels Supported by this Driver
-
-     This driver has been tested in the following Linux kernels: v2.2.18
-     v2.4.0. The driver is supported on v2.2 and v2.4 kernels and on x86,
-     alpha, and PowerPC platforms.
-
-  B. Adapters Supported by this Driver
-
-     AdvanSys (Advanced System Products, Inc.) manufactures the following
-     RISC-based, Bus-Mastering, Fast (10 Mhz) and Ultra (20 Mhz) Narrow
-     (8-bit transfer) SCSI Host Adapters for the ISA, EISA, VL, and PCI
-     buses and RISC-based, Bus-Mastering, Ultra (20 Mhz) Wide (16-bit
-     transfer) SCSI Host Adapters for the PCI bus.
-
-     The CDB counts below indicate the number of SCSI CDB (Command
-     Descriptor Block) requests that can be stored in the RISC chip
-     cache and board LRAM. A CDB is a single SCSI command. The driver
-     detect routine will display the number of CDBs available for each
-     adapter detected. The number of CDBs used by the driver can be
-     lowered in the BIOS by changing the 'Host Queue Size' adapter setting.
-
-     Laptop Products:
-        ABP-480 - Bus-Master CardBus (16 CDB) (2.4 kernel and greater)
-
-     Connectivity Products:
-        ABP510/5150 - Bus-Master ISA (240 CDB)
-        ABP5140 - Bus-Master ISA PnP (16 CDB)
-        ABP5142 - Bus-Master ISA PnP with floppy (16 CDB)
-        ABP902/3902 - Bus-Master PCI (16 CDB)
-        ABP3905 - Bus-Master PCI (16 CDB)
-        ABP915 - Bus-Master PCI (16 CDB)
-        ABP920 - Bus-Master PCI (16 CDB)
-        ABP3922 - Bus-Master PCI (16 CDB)
-        ABP3925 - Bus-Master PCI (16 CDB)
-        ABP930 - Bus-Master PCI (16 CDB)
-        ABP930U - Bus-Master PCI Ultra (16 CDB)
-        ABP930UA - Bus-Master PCI Ultra (16 CDB)
-        ABP960 - Bus-Master PCI MAC/PC (16 CDB)
-        ABP960U - Bus-Master PCI MAC/PC Ultra (16 CDB)
-
-     Single Channel Products:
-        ABP542 - Bus-Master ISA with floppy (240 CDB)
-        ABP742 - Bus-Master EISA (240 CDB)
-        ABP842 - Bus-Master VL (240 CDB)
-        ABP940 - Bus-Master PCI (240 CDB)
-        ABP940U - Bus-Master PCI Ultra (240 CDB)
-        ABP940UA/3940UA - Bus-Master PCI Ultra (240 CDB)
-        ABP970 - Bus-Master PCI MAC/PC (240 CDB)
-        ABP970U - Bus-Master PCI MAC/PC Ultra (240 CDB)
-        ABP3960UA - Bus-Master PCI MAC/PC Ultra (240 CDB)
-        ABP940UW/3940UW - Bus-Master PCI Ultra-Wide (253 CDB)
-        ABP970UW - Bus-Master PCI MAC/PC Ultra-Wide (253 CDB)
-        ABP3940U2W - Bus-Master PCI LVD/Ultra2-Wide (253 CDB)
-
-     Multi-Channel Products:
-        ABP752 - Dual Channel Bus-Master EISA (240 CDB Per Channel)
-        ABP852 - Dual Channel Bus-Master VL (240 CDB Per Channel)
-        ABP950 - Dual Channel Bus-Master PCI (240 CDB Per Channel)
-        ABP950UW - Dual Channel Bus-Master PCI Ultra-Wide (253 CDB Per Channel)
-        ABP980 - Four Channel Bus-Master PCI (240 CDB Per Channel)
-        ABP980U - Four Channel Bus-Master PCI Ultra (240 CDB Per Channel)
-        ABP980UA/3980UA - Four Channel Bus-Master PCI Ultra (16 CDB Per Chan.)
-        ABP3950U2W - Bus-Master PCI LVD/Ultra2-Wide and Ultra-Wide (253 CDB)
-        ABP3950U3W - Bus-Master PCI Dual LVD2/Ultra3-Wide (253 CDB)
-
-  C. Linux source files modified by AdvanSys Driver
-
-     This section for historical purposes documents the changes
-     originally made to the Linux kernel source to add the advansys
-     driver. As Linux has changed some of these files have also
-     been modified.
-
-     1. linux/arch/i386/config.in:
-
-          bool 'AdvanSys SCSI support' CONFIG_SCSI_ADVANSYS y
-
-     2. linux/drivers/scsi/hosts.c:
-
-          #ifdef CONFIG_SCSI_ADVANSYS
-          #include "advansys.h"
-          #endif
-
-        and after "static struct scsi_host_template builtin_scsi_hosts[] =":
-
-          #ifdef CONFIG_SCSI_ADVANSYS
-          ADVANSYS,
-          #endif
-
-     3. linux/drivers/scsi/Makefile:
-
-          ifdef CONFIG_SCSI_ADVANSYS
-          SCSI_SRCS := $(SCSI_SRCS) advansys.c
-          SCSI_OBJS := $(SCSI_OBJS) advansys.o
-          else
-          SCSI_MODULE_OBJS := $(SCSI_MODULE_OBJS) advansys.o
-          endif
-
-     4. linux/init/main.c:
-
-          extern void advansys_setup(char *str, int *ints);
-
-        and add the following lines to the bootsetups[] array.
-
-          #ifdef CONFIG_SCSI_ADVANSYS
-             { "advansys=", advansys_setup },
-          #endif
-
-  D. Source Comments
-
-     1. Use tab stops set to 4 for the source files. For vi use 'se tabstops=4'.
-
-     2. This driver should be maintained in multiple files. But to make
-        it easier to include with Linux and to follow Linux conventions,
-        the whole driver is maintained in the source files advansys.h and
-        advansys.c. In this file logical sections of the driver begin with
-        a comment that contains '---'. The following are the logical sections
-        of the driver below.
-
-           --- Linux Version
-           --- Linux Include File
-           --- Driver Options
-           --- Debugging Header
-           --- Asc Library Constants and Macros
-           --- Adv Library Constants and Macros
-           --- Driver Constants and Macros
-           --- Driver Structures
-           --- Driver Data
-           --- Driver Function Prototypes
-           --- Linux 'struct scsi_host_template' and advansys_setup() Functions
-           --- Loadable Driver Support
-           --- Miscellaneous Driver Functions
-           --- Functions Required by the Asc Library
-           --- Functions Required by the Adv Library
-           --- Tracing and Debugging Functions
-           --- Asc Library Functions
-           --- Adv Library Functions
-
-     3. The string 'XXX' is used to flag code that needs to be re-written
-        or that contains a problem that needs to be addressed.
-
-     4. I have stripped comments from and reformatted the source for the
-        Asc Library and Adv Library to reduce the size of this file. This
-        source can be found under the following headings. The Asc Library
-        is used to support Narrow Boards. The Adv Library is used to
-        support Wide Boards.
-
-           --- Asc Library Constants and Macros
-           --- Adv Library Constants and Macros
-           --- Asc Library Functions
-           --- Adv Library Functions
-
-  E. Driver Compile Time Options and Debugging
-
-     In this source file the following constants can be defined. They are
-     defined in the source below. Both of these options are enabled by
-     default.
-
-     1. ADVANSYS_ASSERT - Enable driver assertions (Def: Enabled)
-
-        Enabling this option adds assertion logic statements to the
-        driver. If an assertion fails a message will be displayed to
-        the console, but the system will continue to operate. Any
-        assertions encountered should be reported to the person
-        responsible for the driver. Assertion statements may proactively
-        detect problems with the driver and facilitate fixing these
-        problems. Enabling assertions will add a small overhead to the
-        execution of the driver.
-
-     2. ADVANSYS_DEBUG - Enable driver debugging (Def: Disabled)
-
-        Enabling this option adds tracing functions to the driver and
-        the ability to set a driver tracing level at boot time. This
-        option will also export symbols not required outside the driver to
-        the kernel name space. This option is very useful for debugging
-        the driver, but it will add to the size of the driver execution
-        image and add overhead to the execution of the driver.
-
-        The amount of debugging output can be controlled with the global
-        variable 'asc_dbglvl'. The higher the number the more output. By
-        default the debug level is 0.
-
-        If the driver is loaded at boot time and the LILO Driver Option
-        is included in the system, the debug level can be changed by
-        specifying a 5th (ASC_NUM_IOPORT_PROBE + 1) I/O Port. The
-        first three hex digits of the pseudo I/O Port must be set to
-        'deb' and the fourth hex digit specifies the debug level: 0 - F.
-        The following command line will look for an adapter at 0x330
-        and set the debug level to 2.
-
-           linux advansys=0x330,0,0,0,0xdeb2
-
-        If the driver is built as a loadable module this variable can be
-        defined when the driver is loaded. The following insmod command
-        will set the debug level to one.
-
-           insmod advansys.o asc_dbglvl=1
-
-        Debugging Message Levels:
-           0: Errors Only
-           1: High-Level Tracing
-           2-N: Verbose Tracing
-
-        To enable debug output to console, please make sure that:
-
-        a. System and kernel logging is enabled (syslogd, klogd running).
-        b. Kernel messages are routed to console output. Check
-           /etc/syslog.conf for an entry similar to this:
-
-                kern.*                  /dev/console
-
-        c. klogd is started with the appropriate -c parameter
-           (e.g. klogd -c 8)
-
-        This will cause printk() messages to be be displayed on the
-        current console. Refer to the klogd(8) and syslogd(8) man pages
-        for details.
-
-        Alternatively you can enable printk() to console with this
-        program. However, this is not the 'official' way to do this.
-        Debug output is logged in /var/log/messages.
-
-          main()
-          {
-                  syscall(103, 7, 0, 0);
-          }
-
-        Increasing LOG_BUF_LEN in kernel/printk.c to something like
-        40960 allows more debug messages to be buffered in the kernel
-        and written to the console or log file.
-
-     3. ADVANSYS_STATS - Enable statistics (Def: Enabled >= v1.3.0)
-
-        Enabling this option adds statistics collection and display
-        through /proc to the driver. The information is useful for
-        monitoring driver and device performance. It will add to the
-        size of the driver execution image and add minor overhead to
-        the execution of the driver.
-
-        Statistics are maintained on a per adapter basis. Driver entry
-        point call counts and transfer size counts are maintained.
-        Statistics are only available for kernels greater than or equal
-        to v1.3.0 with the CONFIG_PROC_FS (/proc) file system configured.
-
-        AdvanSys SCSI adapter files have the following path name format:
-
-           /proc/scsi/advansys/{0,1,2,3,...}
-
-        This information can be displayed with cat. For example:
-
-           cat /proc/scsi/advansys/0
-
-        When ADVANSYS_STATS is not defined the AdvanSys /proc files only
-        contain adapter and device configuration information.
-
-  F. Driver LILO Option
-
-     If init/main.c is modified as described in the 'Directions for Adding
-     the AdvanSys Driver to Linux' section (B.4.) above, the driver will
-     recognize the 'advansys' LILO command line and /etc/lilo.conf option.
-     This option can be used to either disable I/O port scanning or to limit
-     scanning to 1 - 4 I/O ports. Regardless of the option setting EISA and
-     PCI boards will still be searched for and detected. This option only
-     affects searching for ISA and VL boards.
-
-     Examples:
-       1. Eliminate I/O port scanning:
-            boot: linux advansys=
-              or
-            boot: linux advansys=0x0
-       2. Limit I/O port scanning to one I/O port:
-            boot: linux advansys=0x110
-       3. Limit I/O port scanning to four I/O ports:
-            boot: linux advansys=0x110,0x210,0x230,0x330
-
-     For a loadable module the same effect can be achieved by setting
-     the 'asc_iopflag' variable and 'asc_ioport' array when loading
-     the driver, e.g.
-
-           insmod advansys.o asc_iopflag=1 asc_ioport=0x110,0x330
-
-     If ADVANSYS_DEBUG is defined a 5th (ASC_NUM_IOPORT_PROBE + 1)
-     I/O Port may be added to specify the driver debug level. Refer to
-     the 'Driver Compile Time Options and Debugging' section above for
-     more information.
-
-  G. Tests to run before releasing new driver
-
-     1. In the supported kernels verify there are no warning or compile
-        errors when the kernel is built as both a driver and as a module
-        and with the following options:
-
-        ADVANSYS_DEBUG - enabled and disabled
-        CONFIG_SMP - enabled and disabled
-        CONFIG_PROC_FS - enabled and disabled
-
-     2. Run tests on an x86, alpha, and PowerPC with at least one narrow
-        card and one wide card attached to a hard disk and CD-ROM drive:
-        fdisk, mkfs, fsck, bonnie, copy/compare test from the
-        CD-ROM to the hard drive.
-
-  H. Release History
-
-     BETA-1.0 (12/23/95):
-         First Release
-
-     BETA-1.1 (12/28/95):
-         1. Prevent advansys_detect() from being called twice.
-         2. Add LILO 0xdeb[0-f] option to set 'asc_dbglvl'.
-
-     1.2 (1/12/96):
-         1. Prevent re-entrancy in the interrupt handler which
-            resulted in the driver hanging Linux.
-         2. Fix problem that prevented ABP-940 cards from being
-            recognized on some PCI motherboards.
-         3. Add support for the ABP-5140 PnP ISA card.
-         4. Fix check condition return status.
-         5. Add conditionally compiled code for Linux v1.3.X.
-
-     1.3 (2/23/96):
-         1. Fix problem in advansys_biosparam() that resulted in the
-            wrong drive geometry being returned for drives > 1GB with
-            extended translation enabled.
-         2. Add additional tracing during device initialization.
-         3. Change code that only applies to ISA PnP adapter.
-         4. Eliminate 'make dep' warning.
-         5. Try to fix problem with handling resets by increasing their
-            timeout value.
-
-     1.4 (5/8/96):
-         1. Change definitions to eliminate conflicts with other subsystems.
-         2. Add versioning code for the shared interrupt changes.
-         3. Eliminate problem in asc_rmqueue() with iterating after removing
-            a request.
-         4. Remove reset request loop problem from the "Known Problems or
-            Issues" section. This problem was isolated and fixed in the
-            mid-level SCSI driver.
-
-     1.5 (8/8/96):
-         1. Add support for ABP-940U (PCI Ultra) adapter.
-         2. Add support for IRQ sharing by setting the IRQF_SHARED flag for
-            request_irq and supplying a dev_id pointer to both request_irq()
-            and free_irq().
-         3. In AscSearchIOPortAddr11() restore a call to check_region() which
-            should be used before I/O port probing.
-         4. Fix bug in asc_prt_hex() which resulted in the displaying
-            the wrong data.
-         5. Incorporate miscellaneous Asc Library bug fixes and new microcode.
-         6. Change driver versioning to be specific to each Linux sub-level.
-         7. Change statistics gathering to be per adapter instead of global
-            to the driver.
-         8. Add more information and statistics to the adapter /proc file:
-            /proc/scsi/advansys[0...].
-         9. Remove 'cmd_per_lun' from the "Known Problems or Issues" list.
-            This problem has been addressed with the SCSI mid-level changes
-            made in v1.3.89. The advansys_select_queue_depths() function
-            was added for the v1.3.89 changes.
-
-     1.6 (9/10/96):
-         1. Incorporate miscellaneous Asc Library bug fixes and new microcode.
-
-     1.7 (9/25/96):
-         1. Enable clustering and optimize the setting of the maximum number
-            of scatter gather elements for any particular board. Clustering
-            increases CPU utilization, but results in a relatively larger
-            increase in I/O throughput.
-         2. Improve the performance of the request queuing functions by
-            adding a last pointer to the queue structure.
-         3. Correct problems with reset and abort request handling that
-            could have hung or crashed Linux.
-         4. Add more information to the adapter /proc file:
-            /proc/scsi/advansys[0...].
-         5. Remove the request timeout issue form the driver issues list.
-         6. Miscellaneous documentation additions and changes.
-
-     1.8 (10/4/96):
-         1. Make changes to handle the new v2.1.0 kernel memory mapping
-            in which a kernel virtual address may not be equivalent to its
-            bus or DMA memory address.
-         2. Change abort and reset request handling to make it yet even
-            more robust.
-         3. Try to mitigate request starvation by sending ordered requests
-            to heavily loaded, tag queuing enabled devices.
-         4. Maintain statistics on request response time.
-         5. Add request response time statistics and other information to
-            the adapter /proc file: /proc/scsi/advansys[0...].
-
-     1.9 (10/21/96):
-         1. Add conditionally compiled code (ASC_QUEUE_FLOW_CONTROL) to
-            make use of mid-level SCSI driver device queue depth flow
-            control mechanism. This will eliminate aborts caused by a
-            device being unable to keep up with requests and eliminate
-            repeat busy or QUEUE FULL status returned by a device.
-         2. Incorporate miscellaneous Asc Library bug fixes.
-         3. To allow the driver to work in kernels with broken module
-            support set 'cmd_per_lun' if the driver is compiled as a
-            module. This change affects kernels v1.3.89 to present.
-         4. Remove PCI BIOS address from the driver banner. The PCI BIOS
-            is relocated by the motherboard BIOS and its new address can
-            not be determined by the driver.
-         5. Add mid-level SCSI queue depth information to the adapter
-            /proc file: /proc/scsi/advansys[0...].
-
-     2.0 (11/14/96):
-         1. Change allocation of global structures used for device
-            initialization to guarantee they are in DMA-able memory.
-            Previously when the driver was loaded as a module these
-            structures might not have been in DMA-able memory, causing
-            device initialization to fail.
-
-     2.1 (12/30/96):
-         1. In advansys_reset(), if the request is a synchronous reset
-            request, even if the request serial number has changed, then
-            complete the request.
-         2. Add Asc Library bug fixes including new microcode.
-         3. Clear inquiry buffer before using it.
-         4. Correct ifdef typo.
-
-     2.2 (1/15/97):
-         1. Add Asc Library bug fixes including new microcode.
-         2. Add synchronous data transfer rate information to the
-            adapter /proc file: /proc/scsi/advansys[0...].
-         3. Change ADVANSYS_DEBUG to be disabled by default. This
-            will reduce the size of the driver image, eliminate execution
-            overhead, and remove unneeded symbols from the kernel symbol
-            space that were previously added by the driver.
-         4. Add new compile-time option ADVANSYS_ASSERT for assertion
-            code that used to be defined within ADVANSYS_DEBUG. This
-            option is enabled by default.
-
-     2.8 (5/26/97):
-         1. Change version number to 2.8 to synchronize the Linux driver
-            version numbering with other AdvanSys drivers.
-         2. Reformat source files without tabs to present the same view
-            of the file to everyone regardless of the editor tab setting
-            being used.
-         3. Add Asc Library bug fixes.
-
-     3.1A (1/8/98):
-         1. Change version number to 3.1 to indicate that support for
-            Ultra-Wide adapters (ABP-940UW) is included in this release.
-         2. Add Asc Library (Narrow Board) bug fixes.
-         3. Report an underrun condition with the host status byte set
-            to DID_UNDERRUN. Currently DID_UNDERRUN is defined to 0 which
-            causes the underrun condition to be ignored. When Linux defines
-            its own DID_UNDERRUN the constant defined in this file can be
-            removed.
-         4. Add patch to AscWaitTixISRDone().
-         5. Add support for up to 16 different AdvanSys host adapter SCSI
-            channels in one system. This allows four cards with four channels
-            to be used in one system.
-
-     3.1B (1/9/98):
-         1. Handle that PCI register base addresses are not always page
-            aligned even though ioremap() requires that the address argument
-            be page aligned.
-
-     3.1C (1/10/98):
-         1. Update latest BIOS version checked for from the /proc file.
-         2. Don't set microcode SDTR variable at initialization. Instead
-            wait until device capabilities have been detected from an Inquiry
-            command.
-
-     3.1D (1/21/98):
-         1. Improve performance when the driver is compiled as module by
-            allowing up to 64 scatter-gather elements instead of 8.
-
-     3.1E (5/1/98):
-         1. Set time delay in AscWaitTixISRDone() to 1000 ms.
-         2. Include SMP locking changes.
-         3. For v2.1.93 and newer kernels use CONFIG_PCI and new PCI BIOS
-            access functions.
-         4. Update board serial number printing.
-         5. Try allocating an IRQ both with and without the IRQF_DISABLED
-            flag set to allow IRQ sharing with drivers that do not set
-            the IRQF_DISABLED flag. Also display a more descriptive error
-            message if request_irq() fails.
-         6. Update to latest Asc and Adv Libraries.
-
-     3.2A (7/22/99):
-         1. Update Adv Library to 4.16 which includes support for
-            the ASC38C0800 (Ultra2/LVD) IC.
-
-     3.2B (8/23/99):
-         1. Correct PCI compile time option for v2.1.93 and greater
-            kernels, advansys_info() string, and debug compile time
-            option.
-         2. Correct DvcSleepMilliSecond() for v2.1.0 and greater
-            kernels. This caused an LVD detection/BIST problem problem
-            among other things.
-         3. Sort PCI cards by PCI Bus, Slot, Function ascending order
-            to be consistent with the BIOS.
-         4. Update to Asc Library S121 and Adv Library 5.2.
-
-     3.2C (8/24/99):
-         1. Correct PCI card detection bug introduced in 3.2B that
-            prevented PCI cards from being detected in kernels older
-            than v2.1.93.
-
-     3.2D (8/26/99):
-         1. Correct /proc device synchronous speed information display.
-            Also when re-negotiation is pending for a target device
-            note this condition with an * and footnote.
-         2. Correct initialization problem with Ultra-Wide cards that
-            have a pre-3.2 BIOS. A microcode variable changed locations
-            in 3.2 and greater BIOSes which caused WDTR to be attempted
-            erroneously with drives that don't support WDTR.
-
-     3.2E (8/30/99):
-         1. Fix compile error caused by v2.3.13 PCI structure change.
-         2. Remove field from ASCEEP_CONFIG that resulted in an EEPROM
-            checksum error for ISA cards.
-         3. Remove ASC_QUEUE_FLOW_CONTROL conditional code. The mid-level
-            SCSI changes that it depended on were never included in Linux.
-
-     3.2F (9/3/99):
-         1. Handle new initial function code added in v2.3.16 for all
-            driver versions.
-
-     3.2G (9/8/99):
-         1. Fix PCI board detection in v2.3.13 and greater kernels.
-         2. Fix comiple errors in v2.3.X with debugging enabled.
-
-     3.2H (9/13/99):
-         1. Add 64-bit address, long support for Alpha and UltraSPARC.
-            The driver has been verified to work on an Alpha system.
-         2. Add partial byte order handling support for Power PC and
-            other big-endian platforms. This support has not yet been
-            completed or verified.
-         3. For wide boards replace block zeroing of request and
-            scatter-gather structures with individual field initialization
-            to improve performance.
-         4. Correct and clarify ROM BIOS version detection.
-
-     3.2I (10/8/99):
-         1. Update to Adv Library 5.4.
-         2. Add v2.3.19 underrun reporting to asc_isr_callback() and
-            adv_isr_callback().  Remove DID_UNDERRUN constant and other
-            no longer needed code that previously documented the lack
-            of underrun handling.
-
-     3.2J (10/14/99):
-         1. Eliminate compile errors for v2.0 and earlier kernels.
-
-     3.2K (11/15/99):
-         1. Correct debug compile error in asc_prt_adv_scsi_req_q().
-         2. Update Adv Library to 5.5.
-         3. Add ifdef handling for /proc changes added in v2.3.28.
-         4. Increase Wide board scatter-gather list maximum length to
-            255 when the driver is compiled into the kernel.
-
-     3.2L (11/18/99):
-         1. Fix bug in adv_get_sglist() that caused an assertion failure
-            at line 7475. The reqp->sgblkp pointer must be initialized
-            to NULL in adv_get_sglist().
-
-     3.2M (11/29/99):
-         1. Really fix bug in adv_get_sglist().
-         2. Incorporate v2.3.29 changes into driver.
-
-     3.2N (4/1/00):
-         1. Add CONFIG_ISA ifdef code.
-         2. Include advansys_interrupts_enabled name change patch.
-         3. For >= v2.3.28 use new SCSI error handling with new function
-            advansys_eh_bus_reset(). Don't include an abort function
-            because of base library limitations.
-         4. For >= v2.3.28 use per board lock instead of io_request_lock.
-         5. For >= v2.3.28 eliminate advansys_command() and
-            advansys_command_done().
-         6. Add some changes for PowerPC (Big Endian) support, but it isn't
-            working yet.
-         7. Fix "nonexistent resource free" problem that occurred on a module
-            unload for boards with an I/O space >= 255. The 'n_io_port' field
-            is only one byte and can not be used to hold an ioport length more
-            than 255.
-
-     3.3A (4/4/00):
-         1. Update to Adv Library 5.8.
-         2. For wide cards add support for CDBs up to 16 bytes.
-         3. Eliminate warnings when CONFIG_PROC_FS is not defined.
-
-     3.3B (5/1/00):
-         1. Support for PowerPC (Big Endian) wide cards. Narrow cards
-            still need work.
-         2. Change bitfields to shift and mask access for endian
-            portability.
-
-     3.3C (10/13/00):
-         1. Update for latest 2.4 kernel.
-         2. Test ABP-480 CardBus support in 2.4 kernel - works!
-         3. Update to Asc Library S123.
-         4. Update to Adv Library 5.12.
-
-     3.3D (11/22/00):
-         1. Update for latest 2.4 kernel.
-         2. Create patches for 2.2 and 2.4 kernels.
-
-     3.3E (1/9/01):
-         1. Now that 2.4 is released remove ifdef code for kernel versions
-            less than 2.2. The driver is now only supported in kernels 2.2,
-            2.4, and greater.
-         2. Add code to release and acquire the io_request_lock in
-            the driver entrypoint functions: advansys_detect and
-            advansys_queuecommand. In kernel 2.4 the SCSI mid-level driver
-            still holds the io_request_lock on entry to SCSI low-level drivers.
-            This was supposed to be removed before 2.4 was released but never
-            happened. When the mid-level SCSI driver is changed all references
-            to the io_request_lock should be removed from the driver.
-         3. Simplify error handling by removing advansys_abort(),
-            AscAbortSRB(), AscResetDevice(). SCSI bus reset requests are
-            now handled by resetting the SCSI bus and fully re-initializing
-            the chip. This simple method of error recovery has proven to work
-            most reliably after attempts at different methods. Also now only
-            support the "new" error handling method and remove the obsolete
-            error handling interface.
-         4. Fix debug build errors.
-
-     3.3F (1/24/01):
-         1. Merge with ConnectCom version from Andy Kellner which
-            updates Adv Library to 5.14.
-         2. Make PowerPC (Big Endian) work for narrow cards and
-            fix problems writing EEPROM for wide cards.
-         3. Remove interrupts_enabled assertion function.
-
-     3.3G (2/16/01):
-         1. Return an error from narrow boards if passed a 16 byte
-            CDB. The wide board can already handle 16 byte CDBs.
-
-     3.3GJ (4/15/02):
-	 1. hacks for lk 2.5 series (D. Gilbert)
-
-     3.3GJD (10/14/02):
-         1. change select_queue_depths to slave_configure
-	 2. make cmd_per_lun be sane again
-
-     3.3K [2004/06/24]:
-         1. continuing cleanup for lk 2.6 series
-         2. Fix problem in lk 2.6.7-bk2 that broke PCI wide cards
-         3. Fix problem that oopsed ISA cards
-
-  I. Known Problems/Fix List (XXX)
-
-     1. Need to add memory mapping workaround. Test the memory mapping.
-        If it doesn't work revert to I/O port access. Can a test be done
-        safely?
-     2. Handle an interrupt not working. Keep an interrupt counter in
-        the interrupt handler. In the timeout function if the interrupt
-        has not occurred then print a message and run in polled mode.
-     3. Allow bus type scanning order to be changed.
-     4. Need to add support for target mode commands, cf. CAM XPT.
-
-  J. Credits (Chronological Order)
-
-     Bob Frey <bfrey@turbolinux.com.cn> wrote the AdvanSys SCSI driver
-     and maintained it up to 3.3F. He continues to answer questions
-     and help maintain the driver.
-
-     Nathan Hartwell <mage@cdc3.cdc.net> provided the directions and
-     basis for the Linux v1.3.X changes which were included in the
-     1.2 release.
-
-     Thomas E Zerucha <zerucha@shell.portal.com> pointed out a bug
-     in advansys_biosparam() which was fixed in the 1.3 release.
-
-     Erik Ratcliffe <erik@caldera.com> has done testing of the
-     AdvanSys driver in the Caldera releases.
-
-     Rik van Riel <H.H.vanRiel@fys.ruu.nl> provided a patch to
-     AscWaitTixISRDone() which he found necessary to make the
-     driver work with a SCSI-1 disk.
-
-     Mark Moran <mmoran@mmoran.com> has helped test Ultra-Wide
-     support in the 3.1A driver.
-
-     Doug Gilbert <dgilbert@interlog.com> has made changes and
-     suggestions to improve the driver and done a lot of testing.
-
-     Ken Mort <ken@mort.net> reported a DEBUG compile bug fixed
-     in 3.2K.
-
-     Tom Rini <trini@kernel.crashing.org> provided the CONFIG_ISA
-     patch and helped with PowerPC wide and narrow board support.
-
-     Philip Blundell <philb@gnu.org> provided an
-     advansys_interrupts_enabled patch.
-
-     Dave Jones <dave@denial.force9.co.uk> reported the compiler
-     warnings generated when CONFIG_PROC_FS was not defined in
-     the 3.2M driver.
-
-     Jerry Quinn <jlquinn@us.ibm.com> fixed PowerPC support (endian
-     problems) for wide cards.
-
-     Bryan Henderson <bryanh@giraffe-data.com> helped debug narrow
-     card error handling.
-
-     Manuel Veloso <veloso@pobox.com> worked hard on PowerPC narrow
-     board support and fixed a bug in AscGetEEPConfig().
-
-     Arnaldo Carvalho de Melo <acme@conectiva.com.br> made
-     save_flags/restore_flags changes.
-
-     Andy Kellner <AKellner@connectcom.net> continues the Advansys SCSI
-     driver development for ConnectCom (Version > 3.3F).
-
-  K. ConnectCom (AdvanSys) Contact Information
-
-     Mail:                   ConnectCom Solutions, Inc.
-                             1150 Ringwood Court
-                             San Jose, CA 95131
-     Operator/Sales:         1-408-383-9400
-     FAX:                    1-408-383-9612
-     Tech Support:           1-408-467-2930
-     Tech Support E-Mail:    linux@connectcom.net
-     FTP Site:               ftp.connectcom.net (login: anonymous)
-     Web Site:               http://www.connectcom.net
-
-*/
-
-/*
- * --- Linux Include Files
- */
-
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
@@ -785,20 +48,29 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
 
-/* FIXME: (by jejb@steeleye.com)
+/* FIXME:
  *
- * Although all of the necessary command mapping places have the
- * appropriate dma_map.. APIs, the driver still processes its internal
- * queue using bus_to_virt() and virt_to_bus() which are illegal under
- * the API.  The entire queue processing structure will need to be
- * altered to fix this.
+ *  1. Although all of the necessary command mapping places have the
+ *     appropriate dma_map.. APIs, the driver still processes its internal
+ *     queue using bus_to_virt() and virt_to_bus() which are illegal under
+ *     the API.  The entire queue processing structure will need to be
+ *     altered to fix this.
+ *  2. Need to add memory mapping workaround. Test the memory mapping.
+ *     If it doesn't work revert to I/O port access. Can a test be done
+ *     safely?
+ *  3. Handle an interrupt not working. Keep an interrupt counter in
+ *     the interrupt handler. In the timeout function if the interrupt
+ *     has not occurred then print a message and run in polled mode.
+ *  4. Need to add support for target mode commands, cf. CAM XPT.
+ *  5. check DMA mapping functions for failure
+ *  6. Remove internal queueing
+ *  7. Use scsi_transport_spi
+ *  8. advansys_info is not safe against multiple simultaneous callers
+ *  9. Kill boardp->id
+ * 10. Add module_param to override ISA/VLB ioport array
  */
 #warning this driver is still not properly converted to the DMA API
 
-/*
- * --- Driver Options
- */
-
 /* Enable driver assertions. */
 #define ADVANSYS_ASSERT
 

commit d68f4321357165346fb15ef41dbbf9dce7894f29
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:58:12 2007 -0400

    [SCSI] advansys: use memcpy instead of open-coded loop
    
    Use memcpy to initialise eep_config instead of a loop.  For
    AdvInitFrom38C1600EEP where we need to modify the default EEPROM
    configuration, do it after the loop, and do it using the structure
    definition, not by finding the right byte.  I think it was wrong for
    big-endian machines.
    
    Also delete some non-useful comments and prototypes.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 986c52a7b95e..19c2d19f254c 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3167,13 +3167,6 @@ do { \
 #define QHSTA_M_FROZEN_TIDQ         0x46	/* TID Queue frozen. */
 #define QHSTA_M_SGBACKUP_ERROR      0x47	/* Scatter-Gather backup error */
 
-/*
- * Default EEPROM Configuration structure defined in a_init.c.
- */
-static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config;
-static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config;
-static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config;
-
 /*
  * DvcGetPhyAddr() flag arguments
  */
@@ -13183,7 +13176,6 @@ static unsigned char _adv_asc38C1600_buf[] = {
 static unsigned short _adv_asc38C1600_size = sizeof(_adv_asc38C1600_buf);	/* 0x1673 */
 static ADV_DCNT _adv_asc38C1600_chksum = 0x0604EF77UL;	/* Expanded little-endian checksum. */
 
-/* a_init.c */
 /*
  * EEPROM Configuration.
  *
@@ -15443,7 +15435,6 @@ static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
 	AdvPortAddr iop_base;
 	ushort warn_code;
 	ADVEEP_3550_CONFIG eep_config;
-	int i;
 
 	iop_base = asc_dvc->iop_base;
 
@@ -15460,15 +15451,12 @@ static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
 		/*
 		 * Set EEPROM default values.
 		 */
-		for (i = 0; i < sizeof(ADVEEP_3550_CONFIG); i++) {
-			*((uchar *)&eep_config + i) =
-			    *((uchar *)&Default_3550_EEPROM_Config + i);
-		}
+		memcpy(&eep_config, &Default_3550_EEPROM_Config,
+			sizeof(ADVEEP_3550_CONFIG));
 
 		/*
-		 * Assume the 6 byte board serial number that was read
-		 * from EEPROM is correct even if the EEPROM checksum
-		 * failed.
+		 * Assume the 6 byte board serial number that was read from
+		 * EEPROM is correct even if the EEPROM checksum failed.
 		 */
 		eep_config.serial_number_word3 =
 		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
@@ -15597,7 +15585,6 @@ static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
 	AdvPortAddr iop_base;
 	ushort warn_code;
 	ADVEEP_38C0800_CONFIG eep_config;
-	int i;
 	uchar tid, termination;
 	ushort sdtr_speed = 0;
 
@@ -15617,15 +15604,12 @@ static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
 		/*
 		 * Set EEPROM default values.
 		 */
-		for (i = 0; i < sizeof(ADVEEP_38C0800_CONFIG); i++) {
-			*((uchar *)&eep_config + i) =
-			    *((uchar *)&Default_38C0800_EEPROM_Config + i);
-		}
+		memcpy(&eep_config, &Default_38C0800_EEPROM_Config,
+			sizeof(ADVEEP_38C0800_CONFIG));
 
 		/*
-		 * Assume the 6 byte board serial number that was read
-		 * from EEPROM is correct even if the EEPROM checksum
-		 * failed.
+		 * Assume the 6 byte board serial number that was read from
+		 * EEPROM is correct even if the EEPROM checksum failed.
 		 */
 		eep_config.serial_number_word3 =
 		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
@@ -15800,7 +15784,6 @@ static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 	AdvPortAddr iop_base;
 	ushort warn_code;
 	ADVEEP_38C1600_CONFIG eep_config;
-	int i;
 	uchar tid, termination;
 	ushort sdtr_speed = 0;
 
@@ -15821,68 +15804,46 @@ static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 		/*
 		 * Set EEPROM default values.
 		 */
-		for (i = 0; i < sizeof(ADVEEP_38C1600_CONFIG); i++) {
-			if (i == 1 && PCI_FUNC(pdev->devfn) != 0) {
-				/*
-				 * Set Function 1 EEPROM Word 0 MSB
-				 *
-				 * Clear the BIOS_ENABLE (bit 14) and INTAB (bit 11)
-				 * EEPROM bits.
-				 *
-				 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60 and
-				 * old Mac system booting problem. The Expansion ROM must
-				 * be disabled in Function 1 for these systems.
-				 *
-				 */
-				*((uchar *)&eep_config + i) =
-				    ((*
-				      ((uchar *)&Default_38C1600_EEPROM_Config
-				       +
-				       i)) &
-				     (~
-				      (((ADV_EEPROM_BIOS_ENABLE |
-					 ADV_EEPROM_INTAB) >> 8) & 0xFF)));
+		memcpy(&eep_config, &Default_38C1600_EEPROM_Config,
+			sizeof(ADVEEP_38C1600_CONFIG));
 
-				/*
-				 * Set the INTAB (bit 11) if the GPIO 0 input indicates
-				 * the Function 1 interrupt line is wired to INTA.
-				 *
-				 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
-				 *   1 - Function 1 interrupt line wired to INT A.
-				 *   0 - Function 1 interrupt line wired to INT B.
-				 *
-				 * Note: Adapter boards always have Function 0 wired to INTA.
-				 * Put all 5 GPIO bits in input mode and then read
-				 * their input values.
-				 */
-				AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL,
-						     0);
-				if (AdvReadByteRegister
-				    (iop_base, IOPB_GPIO_DATA) & 0x01) {
-					/* Function 1 interrupt wired to INTA; Set EEPROM bit. */
-					*((uchar *)&eep_config + i) |=
-					    ((ADV_EEPROM_INTAB >> 8) & 0xFF);
-				}
-			} else {
-				*((uchar *)&eep_config + i) =
-				    *((uchar *)&Default_38C1600_EEPROM_Config
-				      + i);
-			}
+		if (PCI_FUNC(pdev->devfn) != 0) {
+			u8 ints;
+			/*
+			 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60
+			 * and old Mac system booting problem. The Expansion
+			 * ROM must be disabled in Function 1 for these systems
+			 */
+			eep_config.cfg_lsw &= ~ADV_EEPROM_BIOS_ENABLE;
+			/*
+			 * Clear the INTAB (bit 11) if the GPIO 0 input
+			 * indicates the Function 1 interrupt line is wired
+			 * to INTB.
+			 *
+			 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
+			 *   1 - Function 1 interrupt line wired to INT A.
+			 *   0 - Function 1 interrupt line wired to INT B.
+			 *
+			 * Note: Function 0 is always wired to INTA.
+			 * Put all 5 GPIO bits in input mode and then read
+			 * their input values.
+			 */
+			AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);
+			ints = AdvReadByteRegister(iop_base, IOPB_GPIO_DATA);
+			if ((ints & 0x01) == 0)
+				eep_config.cfg_lsw &= ~ADV_EEPROM_INTAB;
 		}
 
 		/*
-		 * Assume the 6 byte board serial number that was read
-		 * from EEPROM is correct even if the EEPROM checksum
-		 * failed.
+		 * Assume the 6 byte board serial number that was read from
+		 * EEPROM is correct even if the EEPROM checksum failed.
 		 */
 		eep_config.serial_number_word3 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
-
+			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
 		eep_config.serial_number_word2 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
-
+			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
 		eep_config.serial_number_word1 =
-		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+			AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
 
 		AdvSet38C1600EEPConfig(iop_base, &eep_config);
 	}

commit 13ac2d9c791469d4af51aa65653ab0fbd0916fcc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 08:10:23 2007 -0600

    [SCSI] advansys: Remove pci_slot_info
    
    The driver kept a copy of the PCI config address; refer to the pci_dev
    associated with the card instead.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 310b92678035..986c52a7b95e 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -854,8 +854,6 @@ typedef unsigned char uchar;
 #define ERR      (-1)
 #define UW_ERR   (uint)(0xFFFF)
 #define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
-#define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)
-#define ASC_PCI_MKID(bus, dev, func) ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))
 
 #define  ASC_DVCLIB_CALL_DONE     (1)
 #define  ASC_DVCLIB_CALL_FAILED   (0)
@@ -1378,7 +1376,6 @@ typedef struct asc_dvc_cfg {
 	uchar max_tag_qng[ASC_MAX_TID + 1];
 	uchar *overrun_buf;
 	uchar sdtr_period_offset[ASC_MAX_TID + 1];
-	ushort pci_slot_info;
 	uchar adapter_info[6];
 } ASC_DVC_CFG;
 
@@ -2814,9 +2811,6 @@ typedef struct adv_dvc_cfg {
 	ushort control_flag;	/* Microcode Control Flag */
 	ushort mcode_date;	/* Microcode date */
 	ushort mcode_version;	/* Microcode version */
-	ushort pci_slot_info;	/* high byte device/function number */
-	/* bits 7-3 device num., bits 2-0 function num. */
-	/* low byte bus num. */
 	ushort serial1;		/* EEPROM serial number word 1 */
 	ushort serial2;		/* EEPROM serial number word 2 */
 	ushort serial3;		/* EEPROM serial number word 3 */
@@ -3632,6 +3626,10 @@ typedef struct asc_board {
 	ushort bios_codelen;	/* BIOS Code Segment Length. */
 } asc_board_t;
 
+#define adv_dvc_to_board(adv_dvc) container_of(adv_dvc, struct asc_board, \
+							dvc_var.adv_dvc_var)
+#define adv_dvc_to_pdev(adv_dvc) to_pci_dev(adv_dvc_to_board(adv_dvc)->dev)
+
 /* Number of boards detected in system. */
 static int asc_board_count;
 
@@ -7764,8 +7762,7 @@ static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
 	printk("  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
 	       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
 
-	printk("  control_flag 0x%x, pci_slot_info 0x%x\n",
-	       h->control_flag, h->pci_slot_info);
+	printk("  control_flag 0x%x\n", h->control_flag);
 }
 
 /*
@@ -15201,6 +15198,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 	 * ready to be 'ored' into SCSI_CFG1.
 	 */
 	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
+		struct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);
 		/* SE automatic termination control is enabled. */
 		switch (scsi_cfg1 & C_DET_SE) {
 			/* TERM_SE_HI: on, TERM_SE_LO: on */
@@ -15211,7 +15209,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 			break;
 
 		case 0x0:
-			if (ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) == 0) {
+			if (PCI_FUNC(pdev->devfn) == 0) {
 				/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
 			} else {
 				/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
@@ -15817,15 +15815,14 @@ static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 	 */
 	if (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=
 	    eep_config.check_sum) {
+		struct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);
 		warn_code |= ASC_WARN_EEPROM_CHKSUM;
 
 		/*
 		 * Set EEPROM default values.
 		 */
 		for (i = 0; i < sizeof(ADVEEP_38C1600_CONFIG); i++) {
-			if (i == 1
-			    && ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) !=
-			    0) {
+			if (i == 1 && PCI_FUNC(pdev->devfn) != 0) {
 				/*
 				 * Set Function 1 EEPROM Word 0 MSB
 				 *
@@ -17146,10 +17143,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 #ifdef CONFIG_PCI
 		case ASC_IS_PCI:
 			shost->irq = asc_dvc_varp->irq_no = pdev->irq;
-			asc_dvc_varp->cfg->pci_slot_info =
-			    ASC_PCI_MKID(pdev->bus->number,
-					 PCI_SLOT(pdev->devfn),
-					 PCI_FUNC(pdev->devfn));
 			shost->unchecked_isa_dma = FALSE;
 			share_irq = IRQF_SHARED;
 			break;
@@ -17169,10 +17162,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 */
 #ifdef CONFIG_PCI
 		shost->irq = adv_dvc_varp->irq_no = pdev->irq;
-		adv_dvc_varp->cfg->pci_slot_info =
-		    ASC_PCI_MKID(pdev->bus->number,
-				 PCI_SLOT(pdev->devfn),
-				 PCI_FUNC(pdev->devfn));
 		shost->unchecked_isa_dma = FALSE;
 		share_irq = IRQF_SHARED;
 #endif /* CONFIG_PCI */

commit 895d6b4ca88ecc69b9301675eb220c6a926d8bb1
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:57:06 2007 -0400

    [SCSI] advansys: Remove library-style callback routines
    
    Convert adv_isr_callback, adv_async_callback and asc_isr_callback into
    direct calls.  Remove the unused asc_exe_callback.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 73d974a15fca..310b92678035 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1404,17 +1404,12 @@ typedef struct asc_dvc_cfg {
 
 struct asc_dvc_var;		/* Forward Declaration. */
 
-typedef void (*ASC_ISR_CALLBACK) (struct asc_dvc_var *, ASC_QDONE_INFO *);
-typedef int (*ASC_EXE_CALLBACK) (struct asc_dvc_var *, ASC_SCSI_Q *);
-
 typedef struct asc_dvc_var {
 	PortAddr iop_base;
 	ushort err_code;
 	ushort dvc_cntl;
 	ushort bug_fix_cntl;
 	ushort bus_type;
-	ASC_ISR_CALLBACK isr_callback;
-	ASC_EXE_CALLBACK exe_callback;
 	ASC_SCSI_BIT_ID_TYPE init_sdtr;
 	ASC_SCSI_BIT_ID_TYPE sdtr_done;
 	ASC_SCSI_BIT_ID_TYPE use_tagged_qng;
@@ -2830,12 +2825,6 @@ typedef struct adv_dvc_cfg {
 struct adv_dvc_var;
 struct adv_scsi_req_q;
 
-typedef void (*ADV_ISR_CALLBACK)
- (struct adv_dvc_var *, struct adv_scsi_req_q *);
-
-typedef void (*ADV_ASYNC_CALLBACK)
- (struct adv_dvc_var *, uchar);
-
 /*
  * Adapter operation variable structure.
  *
@@ -2852,8 +2841,6 @@ typedef struct adv_dvc_var {
 	AdvPortAddr iop_base;	/* I/O port address */
 	ushort err_code;	/* fatal error code */
 	ushort bios_ctrl;	/* BIOS control word, EEPROM word 12 */
-	ADV_ISR_CALLBACK isr_callback;
-	ADV_ASYNC_CALLBACK async_callback;
 	ushort wdtr_able;	/* try WDTR for a device */
 	ushort sdtr_able;	/* try SDTR for a device */
 	ushort ultra_able;	/* try SDTR Ultra speed for a device */
@@ -3671,9 +3658,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *);
 static int asc_build_req(asc_board_t *, struct scsi_cmnd *);
 static int adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
 static int adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
-static void asc_isr_callback(ASC_DVC_VAR *, ASC_QDONE_INFO *);
-static void adv_isr_callback(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
-static void adv_async_callback(ADV_DVC_VAR *, uchar);
 static void asc_enqueue(asc_queue_t *, REQP, int);
 static REQP asc_dequeue(asc_queue_t *, int);
 static REQP asc_dequeue_list(asc_queue_t *, REQP *, int);
@@ -7624,9 +7608,8 @@ static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
 	printk(" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl "
 	       "%d,\n", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
 
-	printk(" bus_type %d, isr_callback 0x%p, exe_callback 0x%p, "
-	       "init_sdtr 0x%x,\n", h->bus_type, h->isr_callback,
-	       h->exe_callback, (unsigned)h->init_sdtr);
+	printk(" bus_type %d, init_sdtr 0x%x,\n", h->bus_type,
+		(unsigned)h->init_sdtr);
 
 	printk(" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, "
 	       "chip_no 0x%x,\n", (unsigned)h->sdtr_done,
@@ -8631,10 +8614,8 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 	ASC_QDONE_INFO scsiq_buf;
 	ASC_QDONE_INFO *scsiq;
 	int false_overrun;
-	ASC_ISR_CALLBACK asc_isr_callback;
 
 	iop_base = asc_dvc->iop_base;
-	asc_isr_callback = asc_dvc->isr_callback;
 	n_q_used = 1;
 	scsiq = (ASC_QDONE_INFO *)&scsiq_buf;
 	done_q_tail = (uchar)AscGetVarDoneQTail(iop_base);
@@ -8746,7 +8727,7 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 				}
 			}
 			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
-				(*asc_isr_callback) (asc_dvc, scsiq);
+				asc_isr_callback(asc_dvc, scsiq);
 			} else {
 				if ((AscReadLramByte(iop_base,
 						     (ushort)(q_addr + (ushort)
@@ -8764,7 +8745,7 @@ static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);
  FATAL_ERR_QDONE:
 			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
-				(*asc_isr_callback) (asc_dvc, scsiq);
+				asc_isr_callback(asc_dvc, scsiq);
 			}
 			return (0x80);
 		}
@@ -8790,9 +8771,7 @@ static int AscISR(ASC_DVC_VAR *asc_dvc)
 		return int_pending;
 	}
 
-	if (((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0)
-	    || (asc_dvc->isr_callback == 0)
-	    ) {
+	if ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {
 		return (ERR);
 	}
 	if (asc_dvc->in_critical_cnt != 0) {
@@ -9191,7 +9170,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 	int disable_syn_offset_one_fix;
 	int i;
 	ASC_PADDR addr;
-	ASC_EXE_CALLBACK asc_exe_callback;
 	ushort sg_entry_cnt = 0;
 	ushort sg_entry_cnt_minus_one = 0;
 	uchar target_ix;
@@ -9205,7 +9183,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 
 	iop_base = asc_dvc->iop_base;
 	sg_head = scsiq->sg_head;
-	asc_exe_callback = asc_dvc->exe_callback;
 	if (asc_dvc->err_code != 0)
 		return (ERR);
 	if (scsiq == (ASC_SCSI_Q *)0L) {
@@ -9366,9 +9343,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			     AscSendScsiQueue(asc_dvc, scsiq,
 					      n_q_required)) == 1) {
 				asc_dvc->in_critical_cnt--;
-				if (asc_exe_callback != 0) {
-					(*asc_exe_callback) (asc_dvc, scsiq);
-				}
 				DvcLeaveCritical(last_int_level);
 				return (sta);
 			}
@@ -9414,9 +9388,6 @@ static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 			if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
 						    n_q_required)) == 1) {
 				asc_dvc->in_critical_cnt--;
-				if (asc_exe_callback != 0) {
-					(*asc_exe_callback) (asc_dvc, scsiq);
-				}
 				DvcLeaveCritical(last_int_level);
 				return (sta);
 			}
@@ -16745,7 +16716,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 
 	/*
 	 * Notify the driver of an asynchronous microcode condition by
-	 * calling the ADV_DVC_VAR.async_callback function. The function
+	 * calling the adv_async_callback function. The function
 	 * is passed the microcode ASC_MC_INTRB_CODE byte value.
 	 */
 	if (int_stat & ADV_INTR_STATUS_INTRB) {
@@ -16767,9 +16738,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 			}
 		}
 
-		if (asc_dvc->async_callback != 0) {
-			(*asc_dvc->async_callback) (asc_dvc, intrb_code);
-		}
+		adv_async_callback(asc_dvc, intrb_code);
 	}
 
 	/*
@@ -16827,7 +16796,7 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 * the ADV_SCSI_REQ_Q pointer to its callback function.
 		 */
 		scsiq->a_flag |= ADV_SCSIQ_DONE;
-		(*asc_dvc->isr_callback) (asc_dvc, scsiq);
+		adv_isr_callback(asc_dvc, scsiq);
 		/*
 		 * Note: After the driver callback function is called, 'scsiq'
 		 * can no longer be referenced.
@@ -17097,15 +17066,12 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		asc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;
 		asc_dvc_varp->cfg->overrun_buf = &overrun_buf[0];
 		asc_dvc_varp->iop_base = iop;
-		asc_dvc_varp->isr_callback = asc_isr_callback;
 	} else {
 #ifdef CONFIG_PCI
 		ASC_DBG(1, "advansys_board_found: wide board\n");
 		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 		adv_dvc_varp->drv_ptr = boardp;
 		adv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;
-		adv_dvc_varp->isr_callback = adv_isr_callback;
-		adv_dvc_varp->async_callback = adv_async_callback;
 		if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {
 			ASC_DBG(1, "advansys_board_found: ASC-3550\n");
 			adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;

commit 394dbf3f4005622fa52f1805eb950f08ce20f636
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:56:40 2007 -0400

    [SCSI] advansys: Move struct device out of the cfg structures
    
    The cfg structures are supposed to be disposable after initialisation;
    with the 'dev' used for DMA mapping in there, that's not possible.  Move
    the dev to the board.
    
    Also inline AscInitFromAscDvcVar into its only caller, remove some
    unnecessary prototypes and sort out a few minor formatting issues.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e79f7955f6ea..73d974a15fca 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1380,7 +1380,6 @@ typedef struct asc_dvc_cfg {
 	uchar sdtr_period_offset[ASC_MAX_TID + 1];
 	ushort pci_slot_info;
 	uchar adapter_info[6];
-	struct device *dev;
 } ASC_DVC_CFG;
 
 #define ASC_DEF_DVC_CNTL       0xFFFF
@@ -1831,7 +1830,6 @@ static void AscMemDWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
 static void AscMemWordCopyPtrFromLram(PortAddr, ushort, uchar *, int);
 static ushort AscInitAscDvcVar(ASC_DVC_VAR *);
 static ushort AscInitFromEEP(ASC_DVC_VAR *);
-static ushort AscInitFromAscDvcVar(ASC_DVC_VAR *);
 static ushort AscInitMicroCodeVar(ASC_DVC_VAR *);
 static int AscTestExternalLram(ASC_DVC_VAR *);
 static uchar AscMsgOutSDTR(ASC_DVC_VAR *, uchar, uchar);
@@ -2827,7 +2825,6 @@ typedef struct adv_dvc_cfg {
 	ushort serial1;		/* EEPROM serial number word 1 */
 	ushort serial2;		/* EEPROM serial number word 2 */
 	ushort serial3;		/* EEPROM serial number word 3 */
-	struct device *dev;	/* pointer to the pci dev structure for this board */
 } ADV_DVC_CFG;
 
 struct adv_dvc_var;
@@ -3000,7 +2997,6 @@ static void DvcDelayMicroSecond(ADV_DVC_VAR *, ushort);
  */
 static int AdvExeScsiQueue(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
 static int AdvISR(ADV_DVC_VAR *);
-static int AdvInitGetConfig(ADV_DVC_VAR *);
 static int AdvInitAsc3550Driver(ADV_DVC_VAR *);
 static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *);
 static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *);
@@ -3597,6 +3593,7 @@ typedef struct adv_req {
  * field. It is guaranteed to be allocated from DMA-able memory.
  */
 typedef struct asc_board {
+	struct device *dev;
 	int id;			/* Board Id */
 	uint flags;		/* Board flags */
 	union {
@@ -4672,7 +4669,6 @@ static void asc_scsi_done_list(struct scsi_cmnd *scp)
 	ASC_DBG(2, "asc_scsi_done_list: begin\n");
 	while (scp != NULL) {
 		asc_board_t *boardp;
-		struct device *dev;
 
 		ASC_DBG1(3, "asc_scsi_done_list: scp 0x%lx\n", (ulong)scp);
 		tscp = REQPNEXT(scp);
@@ -4680,17 +4676,12 @@ static void asc_scsi_done_list(struct scsi_cmnd *scp)
 
 		boardp = ASC_BOARDP(scp->device->host);
 
-		if (ASC_NARROW_BOARD(boardp))
-			dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
-		else
-			dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
-
 		if (scp->use_sg)
-			dma_unmap_sg(dev,
+			dma_unmap_sg(boardp->dev,
 				     (struct scatterlist *)scp->request_buffer,
 				     scp->use_sg, scp->sc_data_direction);
 		else if (scp->request_bufflen)
-			dma_unmap_single(dev, scp->SCp.dma_handle,
+			dma_unmap_single(boardp->dev, scp->SCp.dma_handle,
 					 scp->request_bufflen,
 					 scp->sc_data_direction);
 
@@ -4929,8 +4920,6 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
  */
 static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 {
-	struct device *dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
-
 	/*
 	 * Mutually exclusive access is required to 'asc_scsi_q' and
 	 * 'asc_sg_head' until after the request is started.
@@ -4994,7 +4983,7 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 		 */
 		ASC_STATS(scp->device->host, cont_cnt);
 		scp->SCp.dma_handle = scp->request_bufflen ?
-		    dma_map_single(dev, scp->request_buffer,
+		    dma_map_single(boardp->dev, scp->request_buffer,
 				   scp->request_bufflen,
 				   scp->sc_data_direction) : 0;
 		asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
@@ -5012,15 +5001,14 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 		struct scatterlist *slp;
 
 		slp = (struct scatterlist *)scp->request_buffer;
-		use_sg =
-		    dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
+				    scp->sc_data_direction);
 
 		if (use_sg > scp->device->host->sg_tablesize) {
-			ASC_PRINT3
-			    ("asc_build_req: board %d: use_sg %d > sg_tablesize %d\n",
-			     boardp->id, use_sg,
-			     scp->device->host->sg_tablesize);
-			dma_unmap_sg(dev, slp, scp->use_sg,
+			ASC_PRINT3("asc_build_req: board %d: use_sg %d > "
+				   "sg_tablesize %d\n", boardp->id, use_sg,
+				   scp->device->host->sg_tablesize);
+			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
 				     scp->sc_data_direction);
 			scp->result = HOST_BYTE(DID_ERROR);
 			asc_enqueue(&boardp->done, scp, ASC_BACK);
@@ -5081,7 +5069,6 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 	ADV_SCSI_REQ_Q *scsiqp;
 	int i;
 	int ret;
-	struct device *dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
 
 	/*
 	 * Allocate an adv_req_t structure from the board to execute
@@ -5168,7 +5155,7 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 		if (scp->request_bufflen) {
 			scsiqp->vdata_addr = scp->request_buffer;
 			scp->SCp.dma_handle =
-			    dma_map_single(dev, scp->request_buffer,
+			    dma_map_single(boardp->dev, scp->request_buffer,
 					   scp->request_bufflen,
 					   scp->sc_data_direction);
 		} else {
@@ -5189,22 +5176,21 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 		int use_sg;
 
 		slp = (struct scatterlist *)scp->request_buffer;
-		use_sg =
-		    dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+		use_sg = dma_map_sg(boardp->dev, slp, scp->use_sg,
+				    scp->sc_data_direction);
 
 		if (use_sg > ADV_MAX_SG_LIST) {
-			ASC_PRINT3
-			    ("adv_build_req: board %d: use_sg %d > ADV_MAX_SG_LIST %d\n",
-			     boardp->id, use_sg,
-			     scp->device->host->sg_tablesize);
-			dma_unmap_sg(dev, slp, scp->use_sg,
+			ASC_PRINT3("adv_build_req: board %d: use_sg %d > "
+				   "ADV_MAX_SG_LIST %d\n", boardp->id, use_sg,
+				   scp->device->host->sg_tablesize);
+			dma_unmap_sg(boardp->dev, slp, scp->use_sg,
 				     scp->sc_data_direction);
 			scp->result = HOST_BYTE(DID_ERROR);
 			asc_enqueue(&boardp->done, scp, ASC_BACK);
 
 			/*
-			 * Free the 'adv_req_t' structure by adding it back to the
-			 * board free list.
+			 * Free the 'adv_req_t' structure by adding it back
+			 * to the board free list.
 			 */
 			reqp->next_reqp = boardp->adv_reqp;
 			boardp->adv_reqp = reqp;
@@ -5212,12 +5198,11 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 			return ASC_ERROR;
 		}
 
-		if ((ret =
-		     adv_get_sglist(boardp, reqp, scp,
-				    use_sg)) != ADV_SUCCESS) {
+		ret = adv_get_sglist(boardp, reqp, scp, use_sg);
+		if (ret != ADV_SUCCESS) {
 			/*
-			 * Free the adv_req_t structure by adding it back to the
-			 * board free list.
+			 * Free the adv_req_t structure by adding it back to
+			 * the board free list.
 			 */
 			reqp->next_reqp = boardp->adv_reqp;
 			boardp->adv_reqp = reqp;
@@ -10219,30 +10204,21 @@ static ushort __devinit AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 	return warn_code;
 }
 
-static ushort __devinit AscInitSetConfig(ASC_DVC_VAR *asc_dvc)
+static unsigned short __devinit
+AscInitSetConfig(struct pci_dev *pdev, ASC_DVC_VAR *asc_dvc)
 {
-	ushort warn_code = 0;
+	PortAddr iop_base = asc_dvc->iop_base;
+	unsigned short cfg_msw;
+	unsigned short warn_code = 0;
 
 	asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
 	if (asc_dvc->err_code != 0)
-		return (UW_ERR);
-	if (AscFindSignature(asc_dvc->iop_base)) {
-		warn_code |= AscInitFromAscDvcVar(asc_dvc);
-		asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
-	} else {
+		return UW_ERR;
+	if (!AscFindSignature(asc_dvc->iop_base)) {
 		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+		return 0;
 	}
-	return (warn_code);
-}
-
-static ushort __devinit AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
-{
-	PortAddr iop_base;
-	ushort cfg_msw;
-	ushort warn_code;
 
-	iop_base = asc_dvc->iop_base;
-	warn_code = 0;
 	cfg_msw = AscGetChipCfgMsw(iop_base);
 	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
 		cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
@@ -10265,7 +10241,6 @@ static ushort __devinit AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	}
 #ifdef CONFIG_PCI
 	if (asc_dvc->bus_type & ASC_IS_PCI) {
-		struct pci_dev *pdev = to_pci_dev(asc_dvc->cfg->dev);
 		cfg_msw &= 0xFFC0;
 		AscSetChipCfgMsw(iop_base, cfg_msw);
 		if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
@@ -10295,7 +10270,9 @@ static ushort __devinit AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
 		AscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);
 	}
 #endif /* CONFIG_ISA */
-	return (warn_code);
+
+	asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
+	return warn_code;
 }
 
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
@@ -13599,11 +13576,11 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata =
  * For a non-fatal error return a warning code. If there are no warnings
  * then 0 is returned.
  */
-static int __devinit AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
+static int __devinit
+AdvInitGetConfig(struct pci_dev *pdev, ADV_DVC_VAR *asc_dvc)
 {
 	unsigned short warn_code = 0;
 	AdvPortAddr iop_base = asc_dvc->iop_base;
-	struct pci_dev *pdev = to_pci_dev(asc_dvc->cfg->dev);
 	u16 cmd;
 	int status;
 
@@ -17094,6 +17071,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	memset(boardp, 0, sizeof(asc_board_t));
 	boardp->id = asc_board_count++;
 	spin_lock_init(&boardp->lock);
+	boardp->dev = dev;
 
 	/*
 	 * Handle both narrow and wide boards.
@@ -17180,7 +17158,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 #endif /* CONFIG_PROC_FS */
 
 	if (ASC_NARROW_BOARD(boardp)) {
-		asc_dvc_varp->cfg->dev = dev;
 		/*
 		 * Set the board bus type and PCI IRQ before
 		 * calling AscInitGetConfig().
@@ -17220,7 +17197,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			break;
 		}
 	} else {
-		adv_dvc_varp->cfg->dev = dev;
 		/*
 		 * For Wide boards set PCI information before calling
 		 * AdvInitGetConfig().
@@ -17289,7 +17265,9 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		}
 	} else {
 		ASC_DBG(2, "advansys_board_found: AdvInitGetConfig()\n");
-		if ((ret = AdvInitGetConfig(adv_dvc_varp)) != 0) {
+
+		ret = AdvInitGetConfig(pdev, adv_dvc_varp);
+		if (ret != 0) {
 			ASC_PRINT2
 			    ("AdvInitGetConfig: board %d: warning: 0x%x\n",
 			     boardp->id, ret);
@@ -17345,7 +17323,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 * Modify board configuration.
 		 */
 		ASC_DBG(2, "advansys_board_found: AscInitSetConfig()\n");
-		switch (ret = AscInitSetConfig(asc_dvc_varp)) {
+		switch (ret = AscInitSetConfig(pdev, asc_dvc_varp)) {
 		case 0:	/* No error. */
 			break;
 		case ASC_WARN_IO_PORT_ROTATE:

commit 4a2d31c811542d37258b3976975395cb1c0fba1c
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:55:34 2007 -0400

    [SCSI] advansys: Stop using n_io_port in Scsi_Host structure
    
    n_io_port isn't suitable for advansys because some of the boards have
    more than 255 bytes of io port space.  There's already a driver-private
    replacement, asc_n_io_port, but for some reason the driver was still
    setting and occasionally reporting n_io_port.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 2f3707613285..e79f7955f6ea 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2289,10 +2289,8 @@ typedef struct adveep_38C1600_config {
 #define BIOS_CTRL_AIPP_DIS           0x2000
 
 #define ADV_3550_MEMSIZE   0x2000	/* 8 KB Internal Memory */
-#define ADV_3550_IOLEN     0x40	/* I/O Port Range in bytes */
 
 #define ADV_38C0800_MEMSIZE  0x4000	/* 16 KB Internal Memory */
-#define ADV_38C0800_IOLEN    0x100	/* I/O Port Range in bytes */
 
 /*
  * XXX - Since ASC38C1600 Rev.3 has a local RAM failure issue, there is
@@ -2302,8 +2300,6 @@ typedef struct adveep_38C1600_config {
  * #define ADV_38C1600_MEMSIZE  0x8000L   * 32 KB Internal Memory *
  */
 #define ADV_38C1600_MEMSIZE  0x4000	/* 16 KB Internal Memory */
-#define ADV_38C1600_IOLEN    0x100	/* I/O Port Range 256 bytes */
-#define ADV_38C1600_MEMLEN   0x1000	/* Memory Range 4KB bytes */
 
 /*
  * Byte I/O register address from base of 'iop_base'.
@@ -3952,7 +3948,6 @@ static const char *advansys_info(struct Scsi_Host *shost)
 	ASC_DVC_VAR *asc_dvc_varp;
 	ADV_DVC_VAR *adv_dvc_varp;
 	char *busname;
-	int iolen;
 	char *widename = NULL;
 
 	boardp = ASC_BOARDP(shost);
@@ -3966,13 +3961,12 @@ static const char *advansys_info(struct Scsi_Host *shost)
 			} else {
 				busname = "ISA";
 			}
-			/* Don't reference 'shost->n_io_port'; It may be truncated. */
 			sprintf(info,
 				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",
 				ASC_VERSION, busname,
 				(ulong)shost->io_port,
-				(ulong)shost->io_port + boardp->asc_n_io_port -
-				1, shost->irq, shost->dma_channel);
+				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
+				shost->irq, shost->dma_channel);
 		} else {
 			if (asc_dvc_varp->bus_type & ASC_IS_VL) {
 				busname = "VL";
@@ -3991,12 +3985,11 @@ static const char *advansys_info(struct Scsi_Host *shost)
 					   "bus type %d\n", boardp->id,
 					   asc_dvc_varp->bus_type);
 			}
-			/* Don't reference 'shost->n_io_port'; It may be truncated. */
 			sprintf(info,
 				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
 				ASC_VERSION, busname, (ulong)shost->io_port,
-				(ulong)shost->io_port + boardp->asc_n_io_port -
-				1, shost->irq);
+				(ulong)shost->io_port + ASC_IOADR_GAP - 1,
+				shost->irq);
 		}
 	} else {
 		/*
@@ -4008,19 +4001,16 @@ static const char *advansys_info(struct Scsi_Host *shost)
 		 */
 		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-			iolen = ADV_3550_IOLEN;
 			widename = "Ultra-Wide";
 		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-			iolen = ADV_38C0800_IOLEN;
 			widename = "Ultra2-Wide";
 		} else {
-			iolen = ADV_38C1600_IOLEN;
 			widename = "Ultra3-Wide";
 		}
 		sprintf(info,
 			"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
 			ASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,
-			(ulong)adv_dvc_varp->iop_base + iolen - 1, shost->irq);
+			(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, shost->irq);
 	}
 	ASC_ASSERT(strlen(info) < ASC_INFO_SIZE);
 	ASC_DBG(1, "advansys_info: end\n");
@@ -6700,10 +6690,7 @@ static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
 			   boardp->asc_n_io_port);
 	ASC_PRT_NEXT();
 
-	/* 'shost->n_io_port' may be truncated because it is only one byte. */
-	len = asc_prt_line(cp, leftlen,
-			   " io_port 0x%x, n_io_port 0x%x\n",
-			   shost->io_port, shost->n_io_port);
+	len = asc_prt_line(cp, leftlen, " io_port 0x%x\n", shost->io_port);
 	ASC_PRT_NEXT();
 
 	if (ASC_NARROW_BOARD(boardp)) {
@@ -7595,8 +7582,8 @@ static void asc_prt_scsi_host(struct Scsi_Host *s)
 	printk(" host_busy %u, host_no %d, last_reset %d,\n",
 	       s->host_busy, s->host_no, (unsigned)s->last_reset);
 
-	printk(" base 0x%lx, io_port 0x%lx, n_io_port %u, irq 0x%x,\n",
-	       (ulong)s->base, (ulong)s->io_port, s->n_io_port, s->irq);
+	printk(" base 0x%lx, io_port 0x%lx, irq 0x%x,\n",
+	       (ulong)s->base, (ulong)s->io_port, s->irq);
 
 	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
 	       s->dma_channel, s->this_id, s->can_queue);
@@ -17536,15 +17523,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		shost->can_queue = adv_dvc_varp->max_host_qng;
 	}
 
-	/*
-	 * 'n_io_port' currently is one byte.
-	 *
-	 * Set a value to 'n_io_port', but never referenced it because
-	 * it may be truncated.
-	 */
-	shost->n_io_port = boardp->asc_n_io_port <= 255 ?
-	    boardp->asc_n_io_port : 255;
-
 	/*
 	 * Following v1.3.89, 'cmd_per_lun' is no longer needed
 	 * and should be set to zero.

commit 57ba5fe988f6e0845c459bbe75ecd6aea536805d
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:55:07 2007 -0400

    [SCSI] advansys: ioremap no longer needs page-aligned addresses
    
    At some point during Linux 2.1 development, ioremap() gained the ability
    to handle addresses which weren't page-aligned.  Also expand the CONFIG_PCI
    range to encompass that entire section of wide board initialisation, since
    all wide boards are PCI.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e6619868173f..2f3707613285 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -17090,8 +17090,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	ASC_DVC_VAR *asc_dvc_varp = NULL;
 	ADV_DVC_VAR *adv_dvc_varp = NULL;
 	int share_irq;
-	int iolen = 0;
-	ADV_PADDR pci_memory_address;
 	int warn_code, err_code;
 	int ret;
 
@@ -17136,13 +17134,13 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		asc_dvc_varp->iop_base = iop;
 		asc_dvc_varp->isr_callback = asc_isr_callback;
 	} else {
+#ifdef CONFIG_PCI
 		ASC_DBG(1, "advansys_board_found: wide board\n");
 		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 		adv_dvc_varp->drv_ptr = boardp;
 		adv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;
 		adv_dvc_varp->isr_callback = adv_isr_callback;
 		adv_dvc_varp->async_callback = adv_async_callback;
-#ifdef CONFIG_PCI
 		if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {
 			ASC_DBG(1, "advansys_board_found: ASC-3550\n");
 			adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;
@@ -17153,46 +17151,20 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			ASC_DBG(1, "advansys_board_found: ASC-38C1600\n");
 			adv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;
 		}
-#endif /* CONFIG_PCI */
 
-		/*
-		 * Map the board's registers into virtual memory for
-		 * PCI slave access. Only memory accesses are used to
-		 * access the board's registers.
-		 *
-		 * Note: The PCI register base address is not always
-		 * page aligned, but the address passed to ioremap()
-		 * must be page aligned. It is guaranteed that the
-		 * PCI register base address will not cross a page
-		 * boundary.
-		 */
-		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-			iolen = ADV_3550_IOLEN;
-		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-			iolen = ADV_38C0800_IOLEN;
-		} else {
-			iolen = ADV_38C1600_IOLEN;
-		}
-#ifdef CONFIG_PCI
-		pci_memory_address = pci_resource_start(pdev, 1);
-		ASC_DBG1(1,
-			 "advansys_board_found: pci_memory_address: 0x%lx\n",
-			 (ulong)pci_memory_address);
-		if ((boardp->ioremap_addr =
-		     ioremap(pci_memory_address & PAGE_MASK, PAGE_SIZE)) == 0) {
+		boardp->asc_n_io_port = pci_resource_len(pdev, 1);
+		boardp->ioremap_addr = ioremap(pci_resource_start(pdev, 1),
+					       boardp->asc_n_io_port);
+		if (!boardp->ioremap_addr) {
 			ASC_PRINT3
 			    ("advansys_board_found: board %d: ioremap(%x, %d) returned NULL\n",
-			     boardp->id, pci_memory_address, iolen);
+			     boardp->id, pci_resource_start(pdev, 1),
+			     boardp->asc_n_io_port);
 			goto err_shost;
 		}
-		ASC_DBG1(1, "advansys_board_found: ioremap_addr: 0x%lx\n",
-			 (ulong)boardp->ioremap_addr);
-		adv_dvc_varp->iop_base = (AdvPortAddr)
-		    (boardp->ioremap_addr +
-		     (pci_memory_address - (pci_memory_address & PAGE_MASK)));
+		adv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr
 		ASC_DBG1(1, "advansys_board_found: iop_base: 0x%lx\n",
 			 adv_dvc_varp->iop_base);
-#endif /* CONFIG_PCI */
 
 		/*
 		 * Even though it isn't used to access wide boards, other
@@ -17201,9 +17173,10 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 */
 		boardp->ioport = iop;
 
-		ASC_DBG2(1,
-			 "advansys_board_found: iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\n",
-			 (ushort)inp(iop + 1), (ushort)inpw(iop));
+		ASC_DBG2(1, "advansys_board_found: iopb_chip_id_1 0x%x, "
+			 "iopw_chip_id_0 0x%x\n", (ushort)inp(iop + 1),
+			 (ushort)inpw(iop));
+#endif /* CONFIG_PCI */
 	}
 
 #ifdef CONFIG_PROC_FS
@@ -17556,7 +17529,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 * PCI Memory Mapped I/O.
 		 */
 		shost->io_port = iop;
-		boardp->asc_n_io_port = iolen;
 
 		shost->this_id = adv_dvc_varp->chip_scsi_id;
 

commit 59fcf844095a89fe5e42b4e9bfc4b49dd6909e6b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:54:15 2007 -0400

    [SCSI] advansys: delete AscGetChipBusType
    
    By moving a test from AscGetChipBusType into its only caller, we can delete
    the whole function
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index dc9dca37c258..e6619868173f 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -8001,34 +8001,6 @@ AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
 	return AscGetChipVerNo(iop_base);
 }
 
-static ushort __devinit AscGetChipBusType(PortAddr iop_base)
-{
-	ushort chip_ver;
-
-	chip_ver = AscGetChipVerNo(iop_base);
-	if ((chip_ver >= ASC_CHIP_MIN_VER_VL)
-	    && (chip_ver <= ASC_CHIP_MAX_VER_VL)
-	    ) {
-		if (((iop_base & 0x0C30) == 0x0C30)
-		    || ((iop_base & 0x0C50) == 0x0C50)
-		    ) {
-			return (ASC_IS_EISA);
-		}
-		return (ASC_IS_VL);
-	}
-	if ((chip_ver >= ASC_CHIP_MIN_VER_ISA) &&
-	    (chip_ver <= ASC_CHIP_MAX_VER_ISA)) {
-		if (chip_ver >= ASC_CHIP_MIN_VER_ISA_PNP) {
-			return (ASC_IS_ISAPNP);
-		}
-		return (ASC_IS_ISA);
-	} else if ((chip_ver >= ASC_CHIP_MIN_VER_PCI) &&
-		   (chip_ver <= ASC_CHIP_MAX_VER_PCI)) {
-		return (ASC_IS_PCI);
-	}
-	return (0);
-}
-
 static ASC_DCNT
 AscLoadMicroCode(PortAddr iop_base,
 		 ushort s_addr, uchar *mcode_buf, ushort mcode_size)
@@ -10468,12 +10440,12 @@ static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	}
 
 	asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;
-	if (AscGetChipBusType(iop_base) == ASC_IS_ISAPNP) {
-		AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
-		asc_dvc->bus_type = ASC_IS_ISAPNP;
-	}
 #ifdef CONFIG_ISA
 	if ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {
+		if (chip_version >= ASC_CHIP_MIN_VER_ISA_PNP) {
+			AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
+			asc_dvc->bus_type = ASC_IS_ISAPNP;
+		}
 		asc_dvc->cfg->isa_dma_channel =
 		    (uchar)AscGetIsaDmaChannel(iop_base);
 	}

commit ecec1947479e52eeb4378cc5706d6d46b0cf5172
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 08:08:22 2007 -0600

    [SCSI] advansys: misc reformatting
    
    Remove some useless forward declarations
    Reformat some comments, debug messages, and the occasional piece of real code
    Removal of unnecessary braces
    Remove duplicate setting of shost->irq
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 5885ce4aad9a..dc9dca37c258 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1815,9 +1815,6 @@ static void AscEnableInterrupt(PortAddr);
 static void AscSetBank(PortAddr, uchar);
 static int AscResetChipAndScsiBus(ASC_DVC_VAR *);
 #ifdef CONFIG_ISA
-static ushort AscGetIsaDmaChannel(PortAddr);
-static ushort AscSetIsaDmaChannel(PortAddr, ushort);
-static uchar AscSetIsaDmaSpeed(PortAddr, uchar);
 static uchar AscGetIsaDmaSpeed(PortAddr);
 #endif /* CONFIG_ISA */
 static uchar AscReadLramByte(PortAddr, ushort);
@@ -1862,18 +1859,11 @@ static int AscIsrQDone(ASC_DVC_VAR *);
 static ushort AscGetEisaChipCfg(PortAddr);
 #endif /* CONFIG_ISA */
 static uchar AscGetChipScsiCtrl(PortAddr);
-static uchar AscSetChipScsiID(PortAddr, uchar);
 static uchar AscGetChipVersion(PortAddr, ushort);
-static ushort AscGetChipBusType(PortAddr);
 static ASC_DCNT AscLoadMicroCode(PortAddr, ushort, uchar *, ushort);
-static int AscFindSignature(PortAddr);
 static void AscToggleIRQAct(PortAddr);
-static uchar AscGetChipIRQ(PortAddr, ushort);
-static uchar AscSetChipIRQ(PortAddr, uchar, ushort);
-static ushort AscGetChipBiosAddress(PortAddr, ushort);
 static inline ulong DvcEnterCritical(void);
 static inline void DvcLeaveCritical(ulong);
-static ushort AscGetChipBiosAddress(PortAddr, ushort);
 static void DvcSleepMilliSecond(ASC_DCNT);
 static void DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
 static void DvcPutScsiQ(PortAddr, ushort, uchar *, int);
@@ -1887,7 +1877,6 @@ static int AscSgListToQueue(int);
 #ifdef CONFIG_ISA
 static void AscEnableIsaDma(uchar);
 #endif /* CONFIG_ISA */
-static ASC_DCNT AscGetMaxDmaCount(ushort);
 static const char *advansys_info(struct Scsi_Host *shost);
 
 /*
@@ -3710,10 +3699,6 @@ static int asc_prt_adv_board_info(struct Scsi_Host *, char *, int);
 static int asc_prt_line(char *, int, char *fmt, ...);
 #endif /* CONFIG_PROC_FS */
 
-/* Declaration for Asc Library internal functions referenced by driver. */
-static int AscFindSignature(PortAddr);
-static ushort AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
-
 /* Statistics function prototypes. */
 #ifdef ADVANSYS_STATS
 #ifdef CONFIG_PROC_FS
@@ -3822,8 +3807,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 		cp = boardp->prtbuf;
 		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
 		ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
-		cnt =
-		    asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
+		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
 				  cplen);
 		totcnt += cnt;
 		leftlen -= cnt;
@@ -3910,11 +3894,10 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	for (tgt_id = 0; tgt_id <= ADV_MAX_TID; tgt_id++) {
 		cp = boardp->prtbuf;
 		cplen = asc_prt_target_stats(shost, tgt_id, cp,
-							ASC_PRTBUF_SIZE);
+					     ASC_PRTBUF_SIZE);
 		ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
-		cnt =
-		    asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
-				  cplen);
+		cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
+				    cplen);
 		totcnt += cnt;
 		leftlen -= cnt;
 		if (leftlen == 0) {
@@ -4004,15 +3987,14 @@ static const char *advansys_info(struct Scsi_Host *shost)
 				}
 			} else {
 				busname = "?";
-				ASC_PRINT2
-				    ("advansys_info: board %d: unknown bus type %d\n",
-				     boardp->id, asc_dvc_varp->bus_type);
+				ASC_PRINT2("advansys_info: board %d: unknown "
+					   "bus type %d\n", boardp->id,
+					   asc_dvc_varp->bus_type);
 			}
 			/* Don't reference 'shost->n_io_port'; It may be truncated. */
 			sprintf(info,
 				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
-				ASC_VERSION, busname,
-				(ulong)shost->io_port,
+				ASC_VERSION, busname, (ulong)shost->io_port,
 				(ulong)shost->io_port + boardp->asc_n_io_port -
 				1, shost->irq);
 		}
@@ -4193,18 +4175,16 @@ static int advansys_reset(struct scsi_cmnd *scp)
 
 		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
 		if (asc_dvc_varp->err_code) {
-			ASC_PRINT2
-			    ("advansys_reset: board %d: SCSI bus reset error: 0x%x\n",
-			     boardp->id, asc_dvc_varp->err_code);
+			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
+				   "error: 0x%x\n", boardp->id,
+				   asc_dvc_varp->err_code);
 			ret = FAILED;
 		} else if (status) {
-			ASC_PRINT2
-			    ("advansys_reset: board %d: SCSI bus reset warning: 0x%x\n",
-			     boardp->id, status);
+			ASC_PRINT2("advansys_reset: board %d: SCSI bus reset "
+				   "warning: 0x%x\n", boardp->id, status);
 		} else {
-			ASC_PRINT1
-			    ("advansys_reset: board %d: SCSI bus reset successful.\n",
-			     boardp->id);
+			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
+				   "successful.\n", boardp->id);
 		}
 
 		ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
@@ -4225,15 +4205,13 @@ static int advansys_reset(struct scsi_cmnd *scp)
 		ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
 		switch (AdvResetChipAndSB(adv_dvc_varp)) {
 		case ASC_TRUE:
-			ASC_PRINT1
-			    ("advansys_reset: board %d: SCSI bus reset successful.\n",
-			     boardp->id);
+			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
+				   "successful.\n", boardp->id);
 			break;
 		case ASC_FALSE:
 		default:
-			ASC_PRINT1
-			    ("advansys_reset: board %d: SCSI bus reset error.\n",
-			     boardp->id);
+			ASC_PRINT1("advansys_reset: board %d: SCSI bus reset "
+				   "error.\n", boardp->id);
 			ret = FAILED;
 			break;
 		}
@@ -4254,8 +4232,8 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	 * is returned in 'last_scp'.
 	 */
 	if (done_scp == NULL) {
-		done_scp =
-		    asc_dequeue_list(&boardp->active, &last_scp, ASC_TID_ALL);
+		done_scp = asc_dequeue_list(&boardp->active, &last_scp,
+					    ASC_TID_ALL);
 		for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
 			tscp->result = HOST_BYTE(DID_RESET);
 		}
@@ -4281,8 +4259,8 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	 * to DID_RESET.
 	 */
 	if (done_scp == NULL) {
-		done_scp =
-		    asc_dequeue_list(&boardp->waiting, &last_scp, ASC_TID_ALL);
+		done_scp = asc_dequeue_list(&boardp->waiting, &last_scp,
+					    ASC_TID_ALL);
 		for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
 			tscp->result = HOST_BYTE(DID_RESET);
 		}
@@ -4313,9 +4291,8 @@ static int advansys_reset(struct scsi_cmnd *scp)
 	/*
 	 * Complete all the 'done_scp' requests.
 	 */
-	if (done_scp != NULL) {
+	if (done_scp)
 		asc_scsi_done_list(done_scp);
-	}
 
 	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
 
@@ -4829,33 +4806,33 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		case ASC_NOERROR:
 			ASC_STATS(scp->device->host, exe_noerror);
 			/*
-			 * Increment monotonically increasing per device successful
-			 * request counter. Wrapping doesn't matter.
+			 * Increment monotonically increasing per device
+			 * successful request counter. Wrapping doesn't matter.
 			 */
 			boardp->reqcnt[scp->device->id]++;
 			asc_enqueue(&boardp->active, scp, ASC_BACK);
-			ASC_DBG(1,
-				"asc_execute_scsi_cmnd: AscExeScsiQueue(), ASC_NOERROR\n");
+			ASC_DBG(1, "asc_execute_scsi_cmnd: AscExeScsiQueue(), "
+				"ASC_NOERROR\n");
 			break;
 		case ASC_BUSY:
 			/*
-			 * Caller will enqueue request on the target's waiting queue
-			 * and retry later.
+			 * Caller will enqueue request on the target's waiting
+			 * queue and retry later.
 			 */
 			ASC_STATS(scp->device->host, exe_busy);
 			break;
 		case ASC_ERROR:
-			ASC_PRINT2
-			    ("asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-			     boardp->id, asc_dvc_varp->err_code);
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+				boardp->id, asc_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_error);
 			scp->result = HOST_BYTE(DID_ERROR);
 			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			break;
 		default:
-			ASC_PRINT2
-			    ("asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() unknown, err_code 0x%x\n",
-			     boardp->id, asc_dvc_varp->err_code);
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AscExeScsiQueue() unknown, err_code 0x%x\n",
+				boardp->id, asc_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_unknown);
 			scp->result = HOST_BYTE(DID_ERROR);
 			asc_enqueue(&boardp->done, scp, ASC_BACK);
@@ -4875,20 +4852,21 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		 */
 		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
 		case ASC_NOERROR:
-			ASC_DBG(3,
-				"asc_execute_scsi_cmnd: adv_build_req ASC_NOERROR\n");
+			ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req "
+				"ASC_NOERROR\n");
 			break;
 		case ASC_BUSY:
-			ASC_DBG(1,
-				"asc_execute_scsi_cmnd: adv_build_req ASC_BUSY\n");
+			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
+				"ASC_BUSY\n");
 			/*
-			 * If busy is returned the request has not been enqueued.
-			 * It will be enqueued by the caller on the target's waiting
-			 * queue and retried later.
+			 * If busy is returned the request has not been
+			 * enqueued.  It will be enqueued by the caller on the
+			 * target's waiting queue and retried later.
 			 *
-			 * The asc_stats fields 'adv_build_noreq' and 'adv_build_nosg'
-			 * count wide board busy conditions. They are updated in
-			 * adv_build_req and adv_get_sglist, respectively.
+			 * The asc_stats fields 'adv_build_noreq' and
+			 * 'adv_build_nosg' count wide board busy conditions.
+			 * They are updated in adv_build_req and
+			 * adv_get_sglist, respectively.
 			 */
 			return ASC_BUSY;
 		case ASC_ERROR:
@@ -4898,8 +4876,8 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 			 * by the caller.
 			 */
 		default:
-			ASC_DBG(1,
-				"asc_execute_scsi_cmnd: adv_build_req ASC_ERROR\n");
+			ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req "
+				"ASC_ERROR\n");
 			ASC_STATS(scp->device->host, build_error);
 			return ASC_ERROR;
 		}
@@ -4912,33 +4890,33 @@ static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 		case ASC_NOERROR:
 			ASC_STATS(scp->device->host, exe_noerror);
 			/*
-			 * Increment monotonically increasing per device successful
-			 * request counter. Wrapping doesn't matter.
+			 * Increment monotonically increasing per device
+			 * successful request counter. Wrapping doesn't matter.
 			 */
 			boardp->reqcnt[scp->device->id]++;
 			asc_enqueue(&boardp->active, scp, ASC_BACK);
-			ASC_DBG(1,
-				"asc_execute_scsi_cmnd: AdvExeScsiQueue(), ASC_NOERROR\n");
+			ASC_DBG(1, "asc_execute_scsi_cmnd: AdvExeScsiQueue(), "
+				"ASC_NOERROR\n");
 			break;
 		case ASC_BUSY:
 			/*
-			 * Caller will enqueue request on the target's waiting queue
-			 * and retry later.
+			 * Caller will enqueue request on the target's waiting
+			 * queue and retry later.
 			 */
 			ASC_STATS(scp->device->host, exe_busy);
 			break;
 		case ASC_ERROR:
-			ASC_PRINT2
-			    ("asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-			     boardp->id, adv_dvc_varp->err_code);
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+				boardp->id, adv_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_error);
 			scp->result = HOST_BYTE(DID_ERROR);
 			asc_enqueue(&boardp->done, scp, ASC_BACK);
 			break;
 		default:
-			ASC_PRINT2
-			    ("asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() unknown, err_code 0x%x\n",
-			     boardp->id, adv_dvc_varp->err_code);
+			ASC_PRINT2("asc_execute_scsi_cmnd: board %d: "
+				"AdvExeScsiQueue() unknown, err_code 0x%x\n",
+				boardp->id, adv_dvc_varp->err_code);
 			ASC_STATS(scp->device->host, exe_unknown);
 			scp->result = HOST_BYTE(DID_ERROR);
 			asc_enqueue(&boardp->done, scp, ASC_BACK);
@@ -4981,9 +4959,9 @@ static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 	 * is supported.
 	 */
 	if (scp->cmd_len > ASC_MAX_CDB_LEN) {
-		ASC_PRINT3
-		    ("asc_build_req: board %d: cmd_len %d > ASC_MAX_CDB_LEN  %d\n",
-		     boardp->id, scp->cmd_len, ASC_MAX_CDB_LEN);
+		ASC_PRINT3("asc_build_req: board %d: cmd_len %d > "
+			"ASC_MAX_CDB_LEN %d\n", boardp->id, scp->cmd_len,
+			ASC_MAX_CDB_LEN);
 		scp->result = HOST_BYTE(DID_ERROR);
 		asc_enqueue(&boardp->done, scp, ASC_BACK);
 		return ASC_ERROR;
@@ -7330,27 +7308,27 @@ DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
  * Return the BIOS address of the adapter at the specified
  * I/O port and with the specified bus type.
  */
-static ushort __devinit AscGetChipBiosAddress(PortAddr iop_base, ushort bus_type)
+static unsigned short __devinit
+AscGetChipBiosAddress(PortAddr iop_base, unsigned short bus_type)
 {
-	ushort cfg_lsw;
-	ushort bios_addr;
+	unsigned short cfg_lsw;
+	unsigned short bios_addr;
 
 	/*
 	 * The PCI BIOS is re-located by the motherboard BIOS. Because
 	 * of this the driver can not determine where a PCI BIOS is
 	 * loaded and executes.
 	 */
-	if (bus_type & ASC_IS_PCI) {
-		return (0);
-	}
+	if (bus_type & ASC_IS_PCI)
+		return 0;
+
 #ifdef CONFIG_ISA
 	if ((bus_type & ASC_IS_EISA) != 0) {
 		cfg_lsw = AscGetEisaChipCfg(iop_base);
 		cfg_lsw &= 0x000F;
-		bios_addr = (ushort)(ASC_BIOS_MIN_ADDR +
-				     (cfg_lsw * ASC_BIOS_BANK_SIZE));
-		return (bios_addr);
-	}			/* if */
+		bios_addr = ASC_BIOS_MIN_ADDR + cfg_lsw * ASC_BIOS_BANK_SIZE;
+		return bios_addr;
+	}
 #endif /* CONFIG_ISA */
 
 	cfg_lsw = AscGetChipCfgLsw(iop_base);
@@ -7358,13 +7336,10 @@ static ushort __devinit AscGetChipBiosAddress(PortAddr iop_base, ushort bus_type
 	/*
 	 *  ISA PnP uses the top bit as the 32K BIOS flag
 	 */
-	if (bus_type == ASC_IS_ISAPNP) {
+	if (bus_type == ASC_IS_ISAPNP)
 		cfg_lsw &= 0x7FFF;
-	}
-	/* if */
-	bios_addr = (ushort)(((cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE) +
-			     ASC_BIOS_MIN_ADDR);
-	return (bios_addr);
+	bios_addr = ASC_BIOS_MIN_ADDR + (cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE;
+	return bios_addr;
 }
 
 /*
@@ -7661,10 +7636,8 @@ static void asc_prt_scsi_cmnd(struct scsi_cmnd *s)
 
 	printk(" timeout_per_command %d\n", s->timeout_per_command);
 
-	printk
-	    (" scsi_done 0x%lx, done 0x%lx, host_scribble 0x%lx, result 0x%x\n",
-	     (ulong)s->scsi_done, (ulong)s->done, (ulong)s->host_scribble,
-	     s->result);
+	printk(" scsi_done 0x%p, done 0x%p, host_scribble 0x%p, result 0x%x\n",
+		s->scsi_done, s->done, s->host_scribble, s->result);
 
 	printk(" tag %u, pid %u\n", (unsigned)s->tag, (unsigned)s->pid);
 }
@@ -7676,34 +7649,31 @@ static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
 {
 	printk("ASC_DVC_VAR at addr 0x%lx\n", (ulong)h);
 
-	printk
-	    (" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl %d,\n",
-	     h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
+	printk(" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl "
+	       "%d,\n", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
 
-	printk
-	    (" bus_type %d, isr_callback 0x%lx, exe_callback 0x%lx, init_sdtr 0x%x,\n",
-	     h->bus_type, (ulong)h->isr_callback, (ulong)h->exe_callback,
-	     (unsigned)h->init_sdtr);
+	printk(" bus_type %d, isr_callback 0x%p, exe_callback 0x%p, "
+	       "init_sdtr 0x%x,\n", h->bus_type, h->isr_callback,
+	       h->exe_callback, (unsigned)h->init_sdtr);
 
-	printk
-	    (" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, chip_no 0x%x,\n",
-	     (unsigned)h->sdtr_done, (unsigned)h->use_tagged_qng,
-	     (unsigned)h->unit_not_ready, (unsigned)h->chip_no);
+	printk(" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, "
+	       "chip_no 0x%x,\n", (unsigned)h->sdtr_done,
+	       (unsigned)h->use_tagged_qng, (unsigned)h->unit_not_ready,
+	       (unsigned)h->chip_no);
 
-	printk
-	    (" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait %u,\n",
-	     (unsigned)h->queue_full_or_busy, (unsigned)h->start_motor,
-	     (unsigned)h->scsi_reset_wait);
+	printk(" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait "
+	       "%u,\n", (unsigned)h->queue_full_or_busy,
+	       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);
 
-	printk
-	    (" is_in_int %u, max_total_qng %u, cur_total_qng %u, in_critical_cnt %u,\n",
-	     (unsigned)h->is_in_int, (unsigned)h->max_total_qng,
-	     (unsigned)h->cur_total_qng, (unsigned)h->in_critical_cnt);
+	printk(" is_in_int %u, max_total_qng %u, cur_total_qng %u, "
+	       "in_critical_cnt %u,\n", (unsigned)h->is_in_int,
+	       (unsigned)h->max_total_qng, (unsigned)h->cur_total_qng,
+	       (unsigned)h->in_critical_cnt);
 
-	printk
-	    (" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, pci_fix_asyn_xfer 0x%x,\n",
-	     (unsigned)h->last_q_shortage, (unsigned)h->init_state,
-	     (unsigned)h->no_scam, (unsigned)h->pci_fix_asyn_xfer);
+	printk(" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, "
+	       "pci_fix_asyn_xfer 0x%x,\n", (unsigned)h->last_q_shortage,
+	       (unsigned)h->init_state, (unsigned)h->no_scam,
+	       (unsigned)h->pci_fix_asyn_xfer);
 
 	printk(" cfg 0x%lx, irq_no 0x%x\n", (ulong)h->cfg, (unsigned)h->irq_no);
 }
@@ -8007,27 +7977,28 @@ static uchar __devinit AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
 	return (AscGetChipScsiID(iop_base));
 }
 
-static uchar __devinit AscGetChipScsiCtrl(PortAddr iop_base)
+static unsigned char __devinit AscGetChipScsiCtrl(PortAddr iop_base)
 {
-	uchar sc;
+	unsigned char sc;
 
 	AscSetBank(iop_base, 1);
 	sc = inp(iop_base + IOP_REG_SC);
 	AscSetBank(iop_base, 0);
-	return (sc);
+	return sc;
 }
 
-static uchar __devinit AscGetChipVersion(PortAddr iop_base, ushort bus_type)
+static unsigned char __devinit
+AscGetChipVersion(PortAddr iop_base, unsigned short bus_type)
 {
-	if ((bus_type & ASC_IS_EISA) != 0) {
+	if (bus_type & ASC_IS_EISA) {
 		PortAddr eisa_iop;
-		uchar revision;
+		unsigned char revision;
 		eisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
 		    (PortAddr) ASC_EISA_REV_IOP_MASK;
 		revision = inp(eisa_iop);
-		return ((uchar)((ASC_CHIP_MIN_VER_EISA - 1) + revision));
+		return ASC_CHIP_MIN_VER_EISA - 1 + revision;
 	}
-	return (AscGetChipVerNo(iop_base));
+	return AscGetChipVerNo(iop_base);
 }
 
 static ushort __devinit AscGetChipBusType(PortAddr iop_base)
@@ -10281,13 +10252,12 @@ static ushort __devinit AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 		warn_code |= AscInitAscDvcVar(asc_dvc);
 		warn_code |= AscInitFromEEP(asc_dvc);
 		asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
-		if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT) {
+		if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)
 			asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
-		}
 	} else {
 		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
 	}
-	return (warn_code);
+	return warn_code;
 }
 
 static ushort __devinit AscInitSetConfig(ASC_DVC_VAR *asc_dvc)
@@ -17154,14 +17124,11 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	int ret;
 
 	/*
-	 * Adapter found.
-	 *
 	 * Register the adapter, get its configuration, and
 	 * initialize it.
 	 */
 	ASC_DBG(2, "advansys_board_found: scsi_host_alloc()\n");
 	shost = scsi_host_alloc(&advansys_template, sizeof(asc_board_t));
-
 	if (!shost)
 		return NULL;
 
@@ -17169,8 +17136,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	boardp = ASC_BOARDP(shost);
 	memset(boardp, 0, sizeof(asc_board_t));
 	boardp->id = asc_board_count++;
-
-	/* Initialize spinlock. */
 	spin_lock_init(&boardp->lock);
 
 	/*
@@ -17590,11 +17555,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		 */
 		boardp->init_tidmask |=
 		    ADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);
-
-		/*
-		 * Finish initializing the 'Scsi_Host' structure.
-		 */
-		shost->irq = adv_dvc_varp->irq_no;
 	}
 
 	/*

commit 47d853ccbe7fc6b79aeddd97cf6f5b08bf81d58b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:41:33 2007 -0400

    [SCSI] advansys: remove INQUIRY sniffing
    
    Use slave_configure() to do all the work that used to be done in
    AscInquiryHandling and AdvInquiryHandling.  Split slave_configure into
    two functions, one for wide and one for narrow controllers.
    
    Remove some unused definitions, duplicate definitions, unnecessary
    declarations, and scsireqq, cap_info and inquiry from struct asc_board.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 277002a54601..5885ce4aad9a 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -944,10 +944,6 @@ typedef unsigned char uchar;
 #define ASC_MAX_CDB_LEN     12
 #define ASC_SCSI_RESET_HOLD_TIME_US  60
 
-#define ADV_INQ_CLOCKING_ST_ONLY    0x0
-#define ADV_INQ_CLOCKING_DT_ONLY    0x1
-#define ADV_INQ_CLOCKING_ST_AND_DT  0x3
-
 /*
  * Inquiry SPC-2 SPI Byte 1 EVPD (Enable Vital Product Data)
  * and CmdDt (Command Support Data) field bit definitions.
@@ -966,57 +962,8 @@ typedef unsigned char uchar;
 #define ASC_SRB_TID(x)   ((uchar)((uchar)(x) & (uchar)0x0F))
 #define ASC_SRB_LUN(x)   ((uchar)((uint)(x) >> 13))
 #define PUT_CDB1(x)   ((uchar)((uint)(x) >> 8))
-#define MS_CMD_DONE    0x00
-#define MS_EXTEND      0x01
 #define MS_SDTR_LEN    0x03
-#define MS_SDTR_CODE   0x01
 #define MS_WDTR_LEN    0x02
-#define MS_WDTR_CODE   0x03
-#define MS_MDP_LEN    0x05
-#define MS_MDP_CODE   0x00
-
-/*
- * Inquiry data structure and bitfield macros
- *
- * Only quantities of more than 1 bit are shifted, since the others are
- * just tested for true or false. C bitfields aren't portable between big
- * and little-endian platforms so they are not used.
- */
-
-#define ASC_INQ_DVC_TYPE(inq)       ((inq)->periph & 0x1f)
-#define ASC_INQ_QUALIFIER(inq)      (((inq)->periph & 0xe0) >> 5)
-#define ASC_INQ_DVC_TYPE_MOD(inq)   ((inq)->devtype & 0x7f)
-#define ASC_INQ_REMOVABLE(inq)      ((inq)->devtype & 0x80)
-#define ASC_INQ_ANSI_VER(inq)       ((inq)->ver & 0x07)
-#define ASC_INQ_ECMA_VER(inq)       (((inq)->ver & 0x38) >> 3)
-#define ASC_INQ_ISO_VER(inq)        (((inq)->ver & 0xc0) >> 6)
-#define ASC_INQ_RESPONSE_FMT(inq)   ((inq)->byte3 & 0x0f)
-#define ASC_INQ_TERM_IO(inq)        ((inq)->byte3 & 0x40)
-#define ASC_INQ_ASYNC_NOTIF(inq)    ((inq)->byte3 & 0x80)
-#define ASC_INQ_SOFT_RESET(inq)     ((inq)->flags & 0x01)
-#define ASC_INQ_CMD_QUEUE(inq)      ((inq)->flags & 0x02)
-#define ASC_INQ_LINK_CMD(inq)       ((inq)->flags & 0x08)
-#define ASC_INQ_SYNC(inq)           ((inq)->flags & 0x10)
-#define ASC_INQ_WIDE16(inq)         ((inq)->flags & 0x20)
-#define ASC_INQ_WIDE32(inq)         ((inq)->flags & 0x40)
-#define ASC_INQ_REL_ADDR(inq)       ((inq)->flags & 0x80)
-#define ASC_INQ_INFO_UNIT(inq)      ((inq)->info & 0x01)
-#define ASC_INQ_QUICK_ARB(inq)      ((inq)->info & 0x02)
-#define ASC_INQ_CLOCKING(inq)       (((inq)->info & 0x0c) >> 2)
-
-typedef struct {
-	uchar periph;
-	uchar devtype;
-	uchar ver;
-	uchar byte3;
-	uchar add_len;
-	uchar res1;
-	uchar res2;
-	uchar flags;
-	uchar vendor_id[8];
-	uchar product_id[16];
-	uchar product_rev_level[4];
-} ASC_SCSI_INQUIRY;
 
 #define ASC_SG_LIST_PER_Q   7
 #define QS_FREE        0x00
@@ -1932,9 +1879,7 @@ static void DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
 static void DvcPutScsiQ(PortAddr, ushort, uchar *, int);
 static void DvcGetQinfo(PortAddr, ushort, uchar *, int);
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *);
-static void AscAsyncFix(ASC_DVC_VAR *, uchar, ASC_SCSI_INQUIRY *);
-static int AscTagQueuingSafe(ASC_SCSI_INQUIRY *);
-static void AscInquiryHandling(ASC_DVC_VAR *, uchar, ASC_SCSI_INQUIRY *);
+static void AscAsyncFix(ASC_DVC_VAR *, struct scsi_device *);
 static int AscExeScsiQueue(ASC_DVC_VAR *, ASC_SCSI_Q *);
 static int AscISR(ASC_DVC_VAR *);
 static uint AscGetNumOfFreeQueue(ASC_DVC_VAR *, uchar, uchar);
@@ -3081,7 +3026,6 @@ static int AdvResetSB(ADV_DVC_VAR *asc_dvc);
  * Internal Adv Library functions.
  */
 static int AdvSendIdleCmd(ADV_DVC_VAR *, ushort, ADV_DCNT);
-static void AdvInquiryHandling(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
 static int AdvInitFrom3550EEP(ADV_DVC_VAR *);
 static int AdvInitFrom38C0800EEP(ADV_DVC_VAR *);
 static int AdvInitFrom38C1600EEP(ADV_DVC_VAR *);
@@ -3295,74 +3239,6 @@ static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config;
          (sizeof(ADV_SG_BLOCK) * \
           ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))
 
-/*
- * Inquiry data structure and bitfield macros
- *
- * Using bitfields to access the subchar data isn't portable across
- * endianness, so instead mask and shift. Only quantities of more
- * than 1 bit are shifted, since the others are just tested for true
- * or false.
- */
-
-#define ADV_INQ_DVC_TYPE(inq)       ((inq)->periph & 0x1f)
-#define ADV_INQ_QUALIFIER(inq)      (((inq)->periph & 0xe0) >> 5)
-#define ADV_INQ_DVC_TYPE_MOD(inq)   ((inq)->devtype & 0x7f)
-#define ADV_INQ_REMOVABLE(inq)      ((inq)->devtype & 0x80)
-#define ADV_INQ_ANSI_VER(inq)       ((inq)->ver & 0x07)
-#define ADV_INQ_ECMA_VER(inq)       (((inq)->ver & 0x38) >> 3)
-#define ADV_INQ_ISO_VER(inq)        (((inq)->ver & 0xc0) >> 6)
-#define ADV_INQ_RESPONSE_FMT(inq)   ((inq)->byte3 & 0x0f)
-#define ADV_INQ_TERM_IO(inq)        ((inq)->byte3 & 0x40)
-#define ADV_INQ_ASYNC_NOTIF(inq)    ((inq)->byte3 & 0x80)
-#define ADV_INQ_SOFT_RESET(inq)     ((inq)->flags & 0x01)
-#define ADV_INQ_CMD_QUEUE(inq)      ((inq)->flags & 0x02)
-#define ADV_INQ_LINK_CMD(inq)       ((inq)->flags & 0x08)
-#define ADV_INQ_SYNC(inq)           ((inq)->flags & 0x10)
-#define ADV_INQ_WIDE16(inq)         ((inq)->flags & 0x20)
-#define ADV_INQ_WIDE32(inq)         ((inq)->flags & 0x40)
-#define ADV_INQ_REL_ADDR(inq)       ((inq)->flags & 0x80)
-#define ADV_INQ_INFO_UNIT(inq)      ((inq)->info & 0x01)
-#define ADV_INQ_QUICK_ARB(inq)      ((inq)->info & 0x02)
-#define ADV_INQ_CLOCKING(inq)       (((inq)->info & 0x0c) >> 2)
-
-typedef struct {
-	uchar periph;		/* peripheral device type [0:4] */
-	/* peripheral qualifier [5:7] */
-	uchar devtype;		/* device type modifier (for SCSI I) [0:6] */
-	/* RMB - removable medium bit [7] */
-	uchar ver;		/* ANSI approved version [0:2] */
-	/* ECMA version [3:5] */
-	/* ISO version [6:7] */
-	uchar byte3;		/* response data format [0:3] */
-	/* 0 SCSI 1 */
-	/* 1 CCS */
-	/* 2 SCSI-2 */
-	/* 3-F reserved */
-	/* reserved [4:5] */
-	/* terminate I/O process bit (see 5.6.22) [6] */
-	/* asynch. event notification (processor) [7] */
-	uchar add_len;		/* additional length */
-	uchar res1;		/* reserved */
-	uchar res2;		/* reserved */
-	uchar flags;		/* soft reset implemented [0] */
-	/* command queuing [1] */
-	/* reserved [2] */
-	/* linked command for this logical unit [3] */
-	/* synchronous data transfer [4] */
-	/* wide bus 16 bit data transfer [5] */
-	/* wide bus 32 bit data transfer [6] */
-	/* relative addressing mode [7] */
-	uchar vendor_id[8];	/* vendor identification */
-	uchar product_id[16];	/* product identification */
-	uchar product_rev_level[4];	/* product revision level */
-	uchar vendor_specific[20];	/* vendor specific */
-	uchar info;		/* information unit supported [0] */
-	/* quick arbitrate supported [1] */
-	/* clocking field [2:3] */
-	/* reserved [4:7] */
-	uchar res3;		/* reserved */
-} ADV_SCSI_INQUIRY;		/* 58 bytes */
-
 /*
  * --- Driver Constants and Macros
  */
@@ -3771,10 +3647,6 @@ typedef struct asc_board {
 	/*
 	 * The following fields are used only for Narrow Boards.
 	 */
-	/* The following three structures must be in DMA-able memory. */
-	ASC_SCSI_REQ_Q scsireqq;
-	ASC_CAP_INFO cap_info;
-	ASC_SCSI_INQUIRY inquiry;
 	uchar sdtr_data[ASC_MAX_TID + 1];	/* SDTR information */
 	/*
 	 * The following fields are used only for Wide Boards.
@@ -3809,8 +3681,6 @@ static int asc_dbglvl = 3;
 
 /*
  * --- Driver Function Prototypes
- *
- * advansys.h contains function prototypes for functions global to Linux.
  */
 
 static int advansys_slave_configure(struct scsi_device *);
@@ -4622,38 +4492,203 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	return result;
 }
 
+static void
+advansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)
+{
+	ASC_SCSI_BIT_ID_TYPE tid_bit = 1 << sdev->id;
+	ASC_SCSI_BIT_ID_TYPE orig_use_tagged_qng = asc_dvc->use_tagged_qng;
+
+	if (sdev->lun == 0) {
+		ASC_SCSI_BIT_ID_TYPE orig_init_sdtr = asc_dvc->init_sdtr;
+		if ((asc_dvc->cfg->sdtr_enable & tid_bit) && sdev->sdtr) {
+			asc_dvc->init_sdtr |= tid_bit;
+		} else {
+			asc_dvc->init_sdtr &= ~tid_bit;
+		}
+
+		if (orig_init_sdtr != asc_dvc->init_sdtr)
+			AscAsyncFix(asc_dvc, sdev);
+	}
+
+	if (sdev->tagged_supported) {
+		if (asc_dvc->cfg->cmd_qng_enabled & tid_bit) {
+			if (sdev->lun == 0) {
+				asc_dvc->cfg->can_tagged_qng |= tid_bit;
+				asc_dvc->use_tagged_qng |= tid_bit;
+			}
+			scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
+						asc_dvc->max_dvc_qng[sdev->id]);
+		}
+	} else {
+		if (sdev->lun == 0) {
+			asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
+			asc_dvc->use_tagged_qng &= ~tid_bit;
+		}
+		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
+	}
+
+	if ((sdev->lun == 0) &&
+	    (orig_use_tagged_qng != asc_dvc->use_tagged_qng)) {
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
+				 asc_dvc->cfg->disc_enable);
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
+				 asc_dvc->use_tagged_qng);
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
+				 asc_dvc->cfg->can_tagged_qng);
+
+		asc_dvc->max_dvc_qng[sdev->id] =
+					asc_dvc->cfg->max_tag_qng[sdev->id];
+		AscWriteLramByte(asc_dvc->iop_base,
+				 (ushort)(ASCV_MAX_DVC_QNG_BEG + sdev->id),
+				 asc_dvc->max_dvc_qng[sdev->id]);
+	}
+}
+
 /*
- * Set the number of commands to queue per device for the
- * specified host adapter.
+ * Wide Transfers
+ *
+ * If the EEPROM enabled WDTR for the device and the device supports wide
+ * bus (16 bit) transfers, then turn on the device's 'wdtr_able' bit and
+ * write the new value to the microcode.
  */
-static int advansys_slave_configure(struct scsi_device *device)
+static void
+advansys_wide_enable_wdtr(AdvPortAddr iop_base, unsigned short tidmask)
 {
-	asc_board_t *boardp;
+	unsigned short cfg_word;
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
+	if ((cfg_word & tidmask) != 0)
+		return;
+
+	cfg_word |= tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
 
-	boardp = ASC_BOARDP(device->host);
-	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
 	/*
-	 * Save a pointer to the device and set its initial/maximum
-	 * queue depth.  Only save the pointer for a lun0 dev though.
+	 * Clear the microcode SDTR and WDTR negotiation done indicators for
+	 * the target to cause it to negotiate with the new setting set above.
+	 * WDTR when accepted causes the target to enter asynchronous mode, so
+	 * SDTR must be negotiated.
 	 */
-	if (device->lun == 0)
-		boardp->device[device->id] = device;
-	if (device->tagged_supported) {
-		if (ASC_NARROW_BOARD(boardp)) {
-			scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
-						boardp->dvc_var.asc_dvc_var.
-						max_dvc_qng[device->id]);
-		} else {
-			scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
-						boardp->dvc_var.adv_dvc_var.
-						max_dvc_qng);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	cfg_word &= ~tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+	cfg_word &= ~tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+}
+
+/*
+ * Synchronous Transfers
+ *
+ * If the EEPROM enabled SDTR for the device and the device
+ * supports synchronous transfers, then turn on the device's
+ * 'sdtr_able' bit. Write the new value to the microcode.
+ */
+static void
+advansys_wide_enable_sdtr(AdvPortAddr iop_base, unsigned short tidmask)
+{
+	unsigned short cfg_word;
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+	if ((cfg_word & tidmask) != 0)
+		return;
+
+	cfg_word |= tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+
+	/*
+	 * Clear the microcode "SDTR negotiation" done indicator for the
+	 * target to cause it to negotiate with the new setting set above.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+	cfg_word &= ~tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+}
+
+/*
+ * PPR (Parallel Protocol Request) Capable
+ *
+ * If the device supports DT mode, then it must be PPR capable.
+ * The PPR message will be used in place of the SDTR and WDTR
+ * messages to negotiate synchronous speed and offset, transfer
+ * width, and protocol options.
+ */
+static void advansys_wide_enable_ppr(ADV_DVC_VAR *adv_dvc,
+				AdvPortAddr iop_base, unsigned short tidmask)
+{
+	AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);
+	adv_dvc->ppr_able |= tidmask;
+	AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);
+}
+
+static void
+advansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)
+{
+	AdvPortAddr iop_base = adv_dvc->iop_base;
+	unsigned short tidmask = 1 << sdev->id;
+
+	if (sdev->lun == 0) {
+		/*
+		 * Handle WDTR, SDTR, and Tag Queuing. If the feature
+		 * is enabled in the EEPROM and the device supports the
+		 * feature, then enable it in the microcode.
+		 */
+
+		if ((adv_dvc->wdtr_able & tidmask) && sdev->wdtr)
+			advansys_wide_enable_wdtr(iop_base, tidmask);
+		if ((adv_dvc->sdtr_able & tidmask) && sdev->sdtr)
+			advansys_wide_enable_sdtr(iop_base, tidmask);
+		if (adv_dvc->chip_type == ADV_CHIP_ASC38C1600 && sdev->ppr)
+			advansys_wide_enable_ppr(adv_dvc, iop_base, tidmask);
+
+		/*
+		 * Tag Queuing is disabled for the BIOS which runs in polled
+		 * mode and would see no benefit from Tag Queuing. Also by
+		 * disabling Tag Queuing in the BIOS devices with Tag Queuing
+		 * bugs will at least work with the BIOS.
+		 */
+		if ((adv_dvc->tagqng_able & tidmask) &&
+		    sdev->tagged_supported) {
+			unsigned short cfg_word;
+			AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
+			cfg_word |= tidmask;
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 cfg_word);
+			AdvWriteByteLram(iop_base,
+					 ASC_MC_NUMBER_OF_MAX_CMD + sdev->id,
+					 adv_dvc->max_dvc_qng);
 		}
+	}
+
+	if ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported) {
+		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG,
+					adv_dvc->max_dvc_qng);
 	} else {
-		scsi_adjust_queue_depth(device, 0, device->host->cmd_per_lun);
+		scsi_adjust_queue_depth(sdev, 0, sdev->host->cmd_per_lun);
 	}
-	ASC_DBG4(1,
-		 "advansys_slave_configure: device 0x%lx, boardp 0x%lx, id %d, depth %d\n",
-		 (ulong)device, (ulong)boardp, device->id, device->queue_depth);
+}
+
+/*
+ * Set the number of commands to queue per device for the
+ * specified host adapter.
+ */
+static int advansys_slave_configure(struct scsi_device *sdev)
+{
+	asc_board_t *boardp = ASC_BOARDP(sdev->host);
+	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
+
+	/*
+	 * Save a pointer to the sdev and set its initial/maximum
+	 * queue depth.  Only save the pointer for a lun0 dev though.
+	 */
+	if (sdev->lun == 0)
+		boardp->device[sdev->id] = sdev;
+
+	if (ASC_NARROW_BOARD(boardp))
+		advansys_narrow_slave_configure(sdev,
+						&boardp->dvc_var.asc_dvc_var);
+	else
+		advansys_wide_slave_configure(sdev,
+						&boardp->dvc_var.adv_dvc_var);
+
 	return 0;
 }
 
@@ -5405,22 +5440,11 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 		ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
 		scp->result = 0;
 
-		/*
-		 * If an INQUIRY command completed successfully, then call
-		 * the AscInquiryHandling() function to set-up the device.
-		 */
-		if (scp->cmnd[0] == INQUIRY && scp->device->lun == 0 &&
-		    (scp->request_bufflen - qdonep->remain_bytes) >= 8) {
-			AscInquiryHandling(asc_dvc_varp, scp->device->id & 0x7,
-					   (ASC_SCSI_INQUIRY *)scp->
-					   request_buffer);
-		}
-
 		/*
 		 * Check for an underrun condition.
 		 *
 		 * If there was no error and an underrun condition, then
-		 * then return the number of underrun bytes.
+		 * return the number of underrun bytes.
 		 */
 		if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
 		    qdonep->remain_bytes <= scp->request_bufflen) {
@@ -8229,8 +8253,8 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 					  (uchar *)&ext_msg,
 					  sizeof(EXT_MSG) >> 1);
 
-		if (ext_msg.msg_type == MS_EXTEND &&
-		    ext_msg.msg_req == MS_SDTR_CODE &&
+		if (ext_msg.msg_type == EXTENDED_MESSAGE &&
+		    ext_msg.msg_req == EXTENDED_SDTR &&
 		    ext_msg.msg_len == MS_SDTR_LEN) {
 			sdtr_accept = TRUE;
 			if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
@@ -8312,8 +8336,8 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 					 q_cntl);
 			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
 			return (0);
-		} else if (ext_msg.msg_type == MS_EXTEND &&
-			   ext_msg.msg_req == MS_WDTR_CODE &&
+		} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&
+			   ext_msg.msg_req == EXTENDED_WDTR &&
 			   ext_msg.msg_len == MS_WDTR_LEN) {
 
 			ext_msg.wdtr_width = 0;
@@ -8406,9 +8430,9 @@ static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 					  (uchar *)&out_msg,
 					  sizeof(EXT_MSG) >> 1);
 
-		if ((out_msg.msg_type == MS_EXTEND) &&
+		if ((out_msg.msg_type == EXTENDED_MESSAGE) &&
 		    (out_msg.msg_len == MS_SDTR_LEN) &&
-		    (out_msg.msg_req == MS_SDTR_CODE)) {
+		    (out_msg.msg_req == EXTENDED_SDTR)) {
 
 			asc_dvc->init_sdtr &= ~target_id;
 			asc_dvc->sdtr_done &= ~target_id;
@@ -9901,9 +9925,9 @@ AscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)
 	PortAddr iop_base;
 
 	iop_base = asc_dvc->iop_base;
-	sdtr_buf.msg_type = MS_EXTEND;
+	sdtr_buf.msg_type = EXTENDED_MESSAGE;
 	sdtr_buf.msg_len = MS_SDTR_LEN;
-	sdtr_buf.msg_req = MS_SDTR_CODE;
+	sdtr_buf.msg_req = EXTENDED_SDTR;
 	sdtr_buf.xfer_period = sdtr_period;
 	sdtr_offset &= ASC_SYN_MAX_OFFSET;
 	sdtr_buf.req_ack_offset = sdtr_offset;
@@ -10985,91 +11009,31 @@ AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 	return (n_error);
 }
 
-static void
-AscAsyncFix(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
+static void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)
 {
-	uchar dvc_type;
-	ASC_SCSI_BIT_ID_TYPE tid_bits;
-
-	dvc_type = ASC_INQ_DVC_TYPE(inq);
-	tid_bits = ASC_TIX_TO_TARGET_ID(tid_no);
+	char type = sdev->type;
+	ASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;
 
 	if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN) {
 		if (!(asc_dvc->init_sdtr & tid_bits)) {
-			if ((dvc_type == TYPE_ROM) &&
-			    (strncmp(inq->vendor_id, "HP ", 3) == 0)) {
+			if ((type == TYPE_ROM) &&
+			    (strncmp(sdev->vendor, "HP ", 3) == 0)) {
 				asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
 			}
 			asc_dvc->pci_fix_asyn_xfer |= tid_bits;
-			if ((dvc_type == TYPE_PROCESSOR) ||
-			    (dvc_type == TYPE_SCANNER) ||
-			    (dvc_type == TYPE_ROM) || (dvc_type == TYPE_TAPE)) {
+			if ((type == TYPE_PROCESSOR) ||
+			    (type == TYPE_SCANNER) || (type == TYPE_ROM) ||
+			    (type == TYPE_TAPE)) {
 				asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
 			}
 
 			if (asc_dvc->pci_fix_asyn_xfer & tid_bits) {
 				AscSetRunChipSynRegAtID(asc_dvc->iop_base,
-							tid_no,
-							ASYN_SDTR_DATA_FIX_PCI_REV_AB);
+					sdev->id,
+					ASYN_SDTR_DATA_FIX_PCI_REV_AB);
 			}
 		}
 	}
-	return;
-}
-
-static int AscTagQueuingSafe(ASC_SCSI_INQUIRY *inq)
-{
-	if ((inq->add_len >= 32) &&
-	    (strncmp(inq->vendor_id, "QUANTUM XP34301", 15) == 0) &&
-	    (strncmp(inq->product_rev_level, "1071", 4) == 0)) {
-		return 0;
-	}
-	return 1;
-}
-
-static void
-AscInquiryHandling(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
-{
-	ASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);
-	ASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;
-
-	orig_init_sdtr = asc_dvc->init_sdtr;
-	orig_use_tagged_qng = asc_dvc->use_tagged_qng;
-
-	asc_dvc->init_sdtr &= ~tid_bit;
-	asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
-	asc_dvc->use_tagged_qng &= ~tid_bit;
-
-	if (ASC_INQ_RESPONSE_FMT(inq) >= 2 || ASC_INQ_ANSI_VER(inq) >= 2) {
-		if ((asc_dvc->cfg->sdtr_enable & tid_bit) && ASC_INQ_SYNC(inq)) {
-			asc_dvc->init_sdtr |= tid_bit;
-		}
-		if ((asc_dvc->cfg->cmd_qng_enabled & tid_bit) &&
-		    ASC_INQ_CMD_QUEUE(inq)) {
-			if (AscTagQueuingSafe(inq)) {
-				asc_dvc->use_tagged_qng |= tid_bit;
-				asc_dvc->cfg->can_tagged_qng |= tid_bit;
-			}
-		}
-	}
-	if (orig_use_tagged_qng != asc_dvc->use_tagged_qng) {
-		AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
-				 asc_dvc->cfg->disc_enable);
-		AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
-				 asc_dvc->use_tagged_qng);
-		AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
-				 asc_dvc->cfg->can_tagged_qng);
-
-		asc_dvc->max_dvc_qng[tid_no] =
-		    asc_dvc->cfg->max_tag_qng[tid_no];
-		AscWriteLramByte(asc_dvc->iop_base,
-				 (ushort)(ASCV_MAX_DVC_QNG_BEG + tid_no),
-				 asc_dvc->max_dvc_qng[tid_no]);
-	}
-	if (orig_init_sdtr != asc_dvc->init_sdtr) {
-		AscAsyncFix(asc_dvc, tid_no, inq);
-	}
-	return;
 }
 
 static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
@@ -13998,7 +13962,7 @@ static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 
 	/*
 	 * Microcode operating variables for WDTR, SDTR, and command tag
-	 * queuing will be set in AdvInquiryHandling() based on what a
+	 * queuing will be set in slave_configure() based on what a
 	 * device reports it is capable of in Inquiry byte 7.
 	 *
 	 * If SCSI Bus Resets have been disabled, then directly set
@@ -14649,7 +14613,7 @@ static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
 
 	/*
 	 * Microcode operating variables for WDTR, SDTR, and command tag
-	 * queuing will be set in AdvInquiryHandling() based on what a
+	 * queuing will be set in slave_configure() based on what a
 	 * device reports it is capable of in Inquiry byte 7.
 	 *
 	 * If SCSI Bus Resets have been disabled, then directly set
@@ -15269,7 +15233,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 
 	/*
 	 * Microcode operating variables for WDTR, SDTR, and command tag
-	 * queuing will be set in AdvInquiryHandling() based on what a
+	 * queuing will be set in slave_configure() based on what a
 	 * device reports it is capable of in Inquiry byte 7.
 	 *
 	 * If SCSI Bus Resets have been disabled, then directly set
@@ -16952,23 +16916,6 @@ static int AdvISR(ADV_DVC_VAR *asc_dvc)
 		 */
 		scsiq->cntl = 0;
 
-		/*
-		 * If the command that completed was a SCSI INQUIRY and
-		 * LUN 0 was sent the command, then process the INQUIRY
-		 * command information for the device.
-		 *
-		 * Note: If data returned were either VPD or CmdDt data,
-		 * don't process the INQUIRY command information for
-		 * the device, otherwise may erroneously set *_able bits.
-		 */
-		if (scsiq->done_status == QD_NO_ERROR &&
-		    scsiq->cdb[0] == INQUIRY &&
-		    scsiq->target_lun == 0 &&
-		    (scsiq->cdb[1] & ADV_INQ_RTN_VPD_AND_CMDDT)
-		    == ADV_INQ_RTN_STD_INQUIRY_DATA) {
-			AdvInquiryHandling(asc_dvc, scsiq);
-		}
-
 		/*
 		 * Notify the driver of the completed request by passing
 		 * the ADV_SCSI_REQ_Q pointer to its callback function.
@@ -17074,168 +17021,6 @@ AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
 	return ADV_ERROR;
 }
 
-/*
- * Inquiry Information Byte 7 Handling
- *
- * Handle SCSI Inquiry Command information for a device by setting
- * microcode operating variables that affect WDTR, SDTR, and Tag
- * Queuing.
- */
-static void AdvInquiryHandling(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
-{
-	AdvPortAddr iop_base;
-	uchar tid;
-	ADV_SCSI_INQUIRY *inq;
-	ushort tidmask;
-	ushort cfg_word;
-
-	/*
-	 * AdvInquiryHandling() requires up to INQUIRY information Byte 7
-	 * to be available.
-	 *
-	 * If less than 8 bytes of INQUIRY information were requested or less
-	 * than 8 bytes were transferred, then return. cdb[4] is the request
-	 * length and the ADV_SCSI_REQ_Q 'data_cnt' field is set by the
-	 * microcode to the transfer residual count.
-	 */
-
-	if (scsiq->cdb[4] < 8 ||
-	    (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) < 8) {
-		return;
-	}
-
-	iop_base = asc_dvc->iop_base;
-	tid = scsiq->target_id;
-
-	inq = (ADV_SCSI_INQUIRY *) scsiq->vdata_addr;
-
-	/*
-	 * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
-	 */
-	if (ADV_INQ_RESPONSE_FMT(inq) < 2 && ADV_INQ_ANSI_VER(inq) < 2) {
-		return;
-	} else {
-		/*
-		 * INQUIRY Byte 7 Handling
-		 *
-		 * Use a device's INQUIRY byte 7 to determine whether it
-		 * supports WDTR, SDTR, and Tag Queuing. If the feature
-		 * is enabled in the EEPROM and the device supports the
-		 * feature, then enable it in the microcode.
-		 */
-
-		tidmask = ADV_TID_TO_TIDMASK(tid);
-
-		/*
-		 * Wide Transfers
-		 *
-		 * If the EEPROM enabled WDTR for the device and the device
-		 * supports wide bus (16 bit) transfers, then turn on the
-		 * device's 'wdtr_able' bit and write the new value to the
-		 * microcode.
-		 */
-		if ((asc_dvc->wdtr_able & tidmask) && ADV_INQ_WIDE16(inq)) {
-			AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
-			if ((cfg_word & tidmask) == 0) {
-				cfg_word |= tidmask;
-				AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
-						 cfg_word);
-
-				/*
-				 * Clear the microcode "SDTR negotiation" and "WDTR
-				 * negotiation" done indicators for the target to cause
-				 * it to negotiate with the new setting set above.
-				 * WDTR when accepted causes the target to enter
-				 * asynchronous mode, so SDTR must be negotiated.
-				 */
-				AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE,
-						cfg_word);
-				cfg_word &= ~tidmask;
-				AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE,
-						 cfg_word);
-				AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE,
-						cfg_word);
-				cfg_word &= ~tidmask;
-				AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE,
-						 cfg_word);
-			}
-		}
-
-		/*
-		 * Synchronous Transfers
-		 *
-		 * If the EEPROM enabled SDTR for the device and the device
-		 * supports synchronous transfers, then turn on the device's
-		 * 'sdtr_able' bit. Write the new value to the microcode.
-		 */
-		if ((asc_dvc->sdtr_able & tidmask) && ADV_INQ_SYNC(inq)) {
-			AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
-			if ((cfg_word & tidmask) == 0) {
-				cfg_word |= tidmask;
-				AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
-						 cfg_word);
-
-				/*
-				 * Clear the microcode "SDTR negotiation" done indicator
-				 * for the target to cause it to negotiate with the new
-				 * setting set above.
-				 */
-				AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE,
-						cfg_word);
-				cfg_word &= ~tidmask;
-				AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE,
-						 cfg_word);
-			}
-		}
-		/*
-		 * If the Inquiry data included enough space for the SPI-3
-		 * Clocking field, then check if DT mode is supported.
-		 */
-		if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600 &&
-		    (scsiq->cdb[4] >= 57 ||
-		     (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) >= 57)) {
-			/*
-			 * PPR (Parallel Protocol Request) Capable
-			 *
-			 * If the device supports DT mode, then it must be PPR capable.
-			 * The PPR message will be used in place of the SDTR and WDTR
-			 * messages to negotiate synchronous speed and offset, transfer
-			 * width, and protocol options.
-			 */
-			if (ADV_INQ_CLOCKING(inq) & ADV_INQ_CLOCKING_DT_ONLY) {
-				AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE,
-						asc_dvc->ppr_able);
-				asc_dvc->ppr_able |= tidmask;
-				AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE,
-						 asc_dvc->ppr_able);
-			}
-		}
-
-		/*
-		 * If the EEPROM enabled Tag Queuing for the device and the
-		 * device supports Tag Queueing, then turn on the device's
-		 * 'tagqng_enable' bit in the microcode and set the microcode
-		 * maximum command count to the ADV_DVC_VAR 'max_dvc_qng'
-		 * value.
-		 *
-		 * Tag Queuing is disabled for the BIOS which runs in polled
-		 * mode and would see no benefit from Tag Queuing. Also by
-		 * disabling Tag Queuing in the BIOS devices with Tag Queuing
-		 * bugs will at least work with the BIOS.
-		 */
-		if ((asc_dvc->tagqng_able & tidmask) && ADV_INQ_CMD_QUEUE(inq)) {
-			AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
-			cfg_word |= tidmask;
-			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
-					 cfg_word);
-
-			AdvWriteByteLram(iop_base,
-					 ASC_MC_NUMBER_OF_MAX_CMD + tid,
-					 asc_dvc->max_dvc_qng);
-		}
-	}
-}
-
 static int __devinit
 advansys_wide_init_chip(asc_board_t *boardp, ADV_DVC_VAR *adv_dvc_varp)
 {

commit ce3a7f1202e02324841ef87d7d3f08ff351d07c7
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:39:17 2007 -0400

    [SCSI] advansys: remove AscCompareString()
    
    AscCompareString() is just another name for strncmp
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 424549d79b13..277002a54601 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1911,7 +1911,6 @@ static int AscIsrChipHalted(ASC_DVC_VAR *);
 static uchar _AscCopyLramScsiDoneQ(PortAddr, ushort,
 				   ASC_QDONE_INFO *, ASC_DCNT);
 static int AscIsrQDone(ASC_DVC_VAR *);
-static int AscCompareString(uchar *, uchar *, int);
 #ifdef CONFIG_ISA
 static ushort AscGetEisaChipCfg(PortAddr);
 #endif /* CONFIG_ISA */
@@ -10998,8 +10997,7 @@ AscAsyncFix(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
 	if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN) {
 		if (!(asc_dvc->init_sdtr & tid_bits)) {
 			if ((dvc_type == TYPE_ROM) &&
-			    (AscCompareString((uchar *)inq->vendor_id,
-					      (uchar *)"HP ", 3) == 0)) {
+			    (strncmp(inq->vendor_id, "HP ", 3) == 0)) {
 				asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
 			}
 			asc_dvc->pci_fix_asyn_xfer |= tid_bits;
@@ -11022,10 +11020,8 @@ AscAsyncFix(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
 static int AscTagQueuingSafe(ASC_SCSI_INQUIRY *inq)
 {
 	if ((inq->add_len >= 32) &&
-	    (AscCompareString((uchar *)inq->vendor_id,
-			      (uchar *)"QUANTUM XP34301", 15) == 0) &&
-	    (AscCompareString((uchar *)inq->product_rev_level,
-			      (uchar *)"1071", 4) == 0)) {
+	    (strncmp(inq->vendor_id, "QUANTUM XP34301", 15) == 0) &&
+	    (strncmp(inq->product_rev_level, "1071", 4) == 0)) {
 		return 0;
 	}
 	return 1;
@@ -11076,19 +11072,6 @@ AscInquiryHandling(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
 	return;
 }
 
-static int AscCompareString(uchar *str1, uchar *str2, int len)
-{
-	int i;
-	int diff;
-
-	for (i = 0; i < len; i++) {
-		diff = (int)(str1[i] - str2[i]);
-		if (diff != 0)
-			return (diff);
-	}
-	return (0);
-}
-
 static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
 {
 	uchar byte_data;

commit 9649af39e30d8d2668c35d008e8e14ae138e4d40
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 21:51:47 2007 -0600

    [SCSI] advansys: More PCI cleanups
    
     - Remove wrappers around the PCI configuration space accessors
     - Call pci_set_master() instead of poking at config space directly
     - Move the latency setting into one function called for both narrow and
       wide boards.
     - Tidy up AdvInitGetConfig() a little.
     - Delete a few unused prototypes and definitions.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index d51ca86bda74..424549d79b13 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -854,15 +854,6 @@ typedef unsigned char uchar;
 #define ERR      (-1)
 #define UW_ERR   (uint)(0xFFFF)
 #define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
-#define AscPCIConfigVendorIDRegister      0x0000
-#define AscPCIConfigDeviceIDRegister      0x0002
-#define AscPCIConfigCommandRegister       0x0004
-#define AscPCIConfigStatusRegister        0x0006
-#define AscPCIConfigRevisionIDRegister    0x0008
-#define AscPCIConfigCacheSize             0x000C
-#define AscPCIConfigLatencyTimer          0x000D
-#define AscPCIIOBaseRegister              0x0010
-#define AscPCICmdRegBits_IOMemBusMaster   0x0007
 #define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)
 #define ASC_PCI_MKID(bus, dev, func) ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))
 
@@ -1936,17 +1927,11 @@ static uchar AscSetChipIRQ(PortAddr, uchar, ushort);
 static ushort AscGetChipBiosAddress(PortAddr, ushort);
 static inline ulong DvcEnterCritical(void);
 static inline void DvcLeaveCritical(ulong);
-#ifdef CONFIG_PCI
-static uchar DvcReadPCIConfigByte(ASC_DVC_VAR *, ushort);
-static void DvcWritePCIConfigByte(ASC_DVC_VAR *, ushort, uchar);
-#endif /* CONFIG_PCI */
 static ushort AscGetChipBiosAddress(PortAddr, ushort);
 static void DvcSleepMilliSecond(ASC_DCNT);
 static void DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
 static void DvcPutScsiQ(PortAddr, ushort, uchar *, int);
 static void DvcGetQinfo(PortAddr, ushort, uchar *, int);
-static ushort AscInitGetConfig(ASC_DVC_VAR *);
-static ushort AscInitSetConfig(ASC_DVC_VAR *);
 static ushort AscInitAsc1000Driver(ASC_DVC_VAR *);
 static void AscAsyncFix(ASC_DVC_VAR *, uchar, ASC_SCSI_INQUIRY *);
 static int AscTagQueuingSafe(ASC_SCSI_INQUIRY *);
@@ -3077,8 +3062,6 @@ typedef struct adv_scsi_req_q {
 static inline ulong DvcEnterCritical(void);
 static inline void DvcLeaveCritical(ulong);
 static void DvcSleepMilliSecond(ADV_DCNT);
-static uchar DvcAdvReadPCIConfigByte(ADV_DVC_VAR *, ushort);
-static void DvcAdvWritePCIConfigByte(ADV_DVC_VAR *, ushort, uchar);
 static ADV_PADDR DvcGetPhyAddr(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *,
 			       uchar *, ASC_SDCNT *, int);
 static void DvcDelayMicroSecond(ADV_DVC_VAR *, ushort);
@@ -3112,12 +3095,6 @@ static void AdvSet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
 static void AdvWaitEEPCmd(AdvPortAddr);
 static ushort AdvReadEEPWord(AdvPortAddr, int);
 
-/*
- * PCI Bus Definitions
- */
-#define AscPCICmdRegBits_BusMastering     0x0007
-#define AscPCICmdRegBits_ParErrRespCtrl   0x0040
-
 /* Read byte from a register. */
 #define AdvReadByteRegister(iop_base, reg_off) \
      (ADV_MEM_READB((iop_base) + (reg_off)))
@@ -7326,31 +7303,6 @@ DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
 	ASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);
 }
 
-/*
- * Read a PCI configuration byte.
- */
-static uchar __devinit DvcReadPCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset)
-{
-#ifdef CONFIG_PCI
-	uchar byte_data;
-	pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
-	return byte_data;
-#else /* !defined(CONFIG_PCI) */
-	return 0;
-#endif /* !defined(CONFIG_PCI) */
-}
-
-/*
- * Write a PCI configuration byte.
- */
-static void __devinit
-DvcWritePCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
-{
-#ifdef CONFIG_PCI
-	pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
-#endif /* CONFIG_PCI */
-}
-
 /*
  * Return the BIOS address of the adapter at the specified
  * I/O port and with the specified bus type.
@@ -7423,33 +7375,6 @@ DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
 	return paddr;
 }
 
-/*
- * Read a PCI configuration byte.
- */
-static uchar __devinit DvcAdvReadPCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset)
-{
-#ifdef CONFIG_PCI
-	uchar byte_data;
-	pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
-	return byte_data;
-#else /* CONFIG_PCI */
-	return 0;
-#endif /* CONFIG_PCI */
-}
-
-/*
- * Write a PCI configuration byte.
- */
-static void __devinit
-DvcAdvWritePCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
-{
-#ifdef CONFIG_PCI
-	pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
-#else /* CONFIG_PCI */
-	return;
-#endif /* CONFIG_PCI */
-}
-
 /*
  * --- Tracing and Debugging Functions
  */
@@ -10321,89 +10246,15 @@ static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
 }
 #endif /* CONFIG_ISA */
 
-static ushort __devinit
-AscReadPCIConfigWord(ASC_DVC_VAR *asc_dvc, ushort pci_config_offset)
-{
-	uchar lsb, msb;
-
-	lsb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset);
-	msb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset + 1);
-	return ((ushort)((msb << 8) | lsb));
-}
-
 static ushort __devinit AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 {
-	ushort warn_code;
-	PortAddr iop_base;
-	ushort PCIDeviceID;
-	ushort PCIVendorID;
-	uchar PCIRevisionID;
-	uchar prevCmdRegBits;
+	unsigned short warn_code = 0;
 
-	warn_code = 0;
-	iop_base = asc_dvc->iop_base;
 	asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
-	if (asc_dvc->err_code != 0) {
+	if (asc_dvc->err_code != 0)
 		return (UW_ERR);
-	}
-	if (asc_dvc->bus_type == ASC_IS_PCI) {
-		PCIVendorID = AscReadPCIConfigWord(asc_dvc,
-						   AscPCIConfigVendorIDRegister);
-
-		PCIDeviceID = AscReadPCIConfigWord(asc_dvc,
-						   AscPCIConfigDeviceIDRegister);
-
-		PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
-						     AscPCIConfigRevisionIDRegister);
 
-		if (PCIVendorID != PCI_VENDOR_ID_ASP) {
-			warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-		}
-		prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
-						      AscPCIConfigCommandRegister);
-
-		if ((prevCmdRegBits & AscPCICmdRegBits_IOMemBusMaster) !=
-		    AscPCICmdRegBits_IOMemBusMaster) {
-			DvcWritePCIConfigByte(asc_dvc,
-					      AscPCIConfigCommandRegister,
-					      (prevCmdRegBits |
-					       AscPCICmdRegBits_IOMemBusMaster));
-
-			if ((DvcReadPCIConfigByte(asc_dvc,
-						  AscPCIConfigCommandRegister)
-			     & AscPCICmdRegBits_IOMemBusMaster)
-			    != AscPCICmdRegBits_IOMemBusMaster) {
-				warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-			}
-		}
-		if ((PCIDeviceID == PCI_DEVICE_ID_ASP_1200A) ||
-		    (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940)) {
-			DvcWritePCIConfigByte(asc_dvc,
-					      AscPCIConfigLatencyTimer, 0x00);
-			if (DvcReadPCIConfigByte
-			    (asc_dvc, AscPCIConfigLatencyTimer)
-			    != 0x00) {
-				warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-			}
-		} else if (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940U) {
-			if (DvcReadPCIConfigByte(asc_dvc,
-						 AscPCIConfigLatencyTimer) <
-			    0x20) {
-				DvcWritePCIConfigByte(asc_dvc,
-						      AscPCIConfigLatencyTimer,
-						      0x20);
-
-				if (DvcReadPCIConfigByte(asc_dvc,
-							 AscPCIConfigLatencyTimer)
-				    < 0x20) {
-					warn_code |=
-					    ASC_WARN_SET_PCI_CONFIG_SPACE;
-				}
-			}
-		}
-	}
-
-	if (AscFindSignature(iop_base)) {
+	if (AscFindSignature(asc_dvc->iop_base)) {
 		warn_code |= AscInitAscDvcVar(asc_dvc);
 		warn_code |= AscInitFromEEP(asc_dvc);
 		asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
@@ -10437,13 +10288,8 @@ static ushort __devinit AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	PortAddr iop_base;
 	ushort cfg_msw;
 	ushort warn_code;
-	ushort pci_device_id = 0;
 
 	iop_base = asc_dvc->iop_base;
-#ifdef CONFIG_PCI
-	if (asc_dvc->cfg->dev)
-		pci_device_id = to_pci_dev(asc_dvc->cfg->dev)->device;
-#endif
 	warn_code = 0;
 	cfg_msw = AscGetChipCfgMsw(iop_base);
 	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
@@ -10465,19 +10311,23 @@ static ushort __devinit AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
 			asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
 		}
 	}
+#ifdef CONFIG_PCI
 	if (asc_dvc->bus_type & ASC_IS_PCI) {
+		struct pci_dev *pdev = to_pci_dev(asc_dvc->cfg->dev);
 		cfg_msw &= 0xFFC0;
 		AscSetChipCfgMsw(iop_base, cfg_msw);
 		if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
 		} else {
-			if ((pci_device_id == PCI_DEVICE_ID_ASP_1200A) ||
-			    (pci_device_id == PCI_DEVICE_ID_ASP_ABP940)) {
+			if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
+			    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
 				asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
 				asc_dvc->bug_fix_cntl |=
 				    ASC_BUG_FIX_ASYN_USE_SYN;
 			}
 		}
-	} else if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
+	} else
+#endif /* CONFIG_PCI */
+	if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
 		if (AscGetChipVersion(iop_base, asc_dvc->bus_type)
 		    == ASC_CHIP_VER_ASYN_BUG) {
 			asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
@@ -13875,55 +13725,13 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata =
  */
 static int __devinit AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
 {
-	ushort warn_code;
-	AdvPortAddr iop_base;
-	uchar pci_cmd_reg;
+	unsigned short warn_code = 0;
+	AdvPortAddr iop_base = asc_dvc->iop_base;
+	struct pci_dev *pdev = to_pci_dev(asc_dvc->cfg->dev);
+	u16 cmd;
 	int status;
 
-	warn_code = 0;
 	asc_dvc->err_code = 0;
-	iop_base = asc_dvc->iop_base;
-
-	/*
-	 * PCI Command Register
-	 *
-	 * Note: AscPCICmdRegBits_BusMastering definition (0x0007) includes
-	 * I/O Space Control, Memory Space Control and Bus Master Control bits.
-	 */
-
-	if (((pci_cmd_reg = DvcAdvReadPCIConfigByte(asc_dvc,
-						    AscPCIConfigCommandRegister))
-	     & AscPCICmdRegBits_BusMastering)
-	    != AscPCICmdRegBits_BusMastering) {
-		pci_cmd_reg |= AscPCICmdRegBits_BusMastering;
-
-		DvcAdvWritePCIConfigByte(asc_dvc,
-					 AscPCIConfigCommandRegister,
-					 pci_cmd_reg);
-
-		if (((DvcAdvReadPCIConfigByte
-		      (asc_dvc, AscPCIConfigCommandRegister))
-		     & AscPCICmdRegBits_BusMastering)
-		    != AscPCICmdRegBits_BusMastering) {
-			warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-		}
-	}
-
-	/*
-	 * PCI Latency Timer
-	 *
-	 * If the "latency timer" register is 0x20 or above, then we don't need
-	 * to change it.  Otherwise, set it to 0x20 (i.e. set it to 0x20 if it
-	 * comes up less than 0x20).
-	 */
-	if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20) {
-		DvcAdvWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer,
-					 0x20);
-		if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) <
-		    0x20) {
-			warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-		}
-	}
 
 	/*
 	 * Save the state of the PCI Configuration Command Register
@@ -13932,10 +13740,9 @@ static int __devinit AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
 	 * DMA parity errors.
 	 */
 	asc_dvc->cfg->control_flag = 0;
-	if (((DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
-	      & AscPCICmdRegBits_ParErrRespCtrl)) == 0) {
+	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
+	if ((cmd & PCI_COMMAND_PARITY) == 0)
 		asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
-	}
 
 	asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
 	    ADV_LIB_VERSION_MINOR;
@@ -13977,19 +13784,11 @@ static int __devinit AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
 				     ADV_CTRL_REG_CMD_WR_IO_REG);
 
 		if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
-			if ((status =
-			     AdvInitFrom38C1600EEP(asc_dvc)) == ADV_ERROR) {
-				return ADV_ERROR;
-			}
+			status = AdvInitFrom38C1600EEP(asc_dvc);
 		} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
-			if ((status =
-			     AdvInitFrom38C0800EEP(asc_dvc)) == ADV_ERROR) {
-				return ADV_ERROR;
-			}
+			status = AdvInitFrom38C0800EEP(asc_dvc);
 		} else {
-			if ((status = AdvInitFrom3550EEP(asc_dvc)) == ADV_ERROR) {
-				return ADV_ERROR;
-			}
+			status = AdvInitFrom3550EEP(asc_dvc);
 		}
 		warn_code |= status;
 	}
@@ -18488,6 +18287,19 @@ static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
 
+static void __devinit advansys_set_latency(struct pci_dev *pdev)
+{
+	if ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||
+	    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {
+		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0);
+	} else {
+		u8 latency;
+		pci_read_config_byte(pdev, PCI_LATENCY_TIMER, &latency);
+		if (latency < 0x20)
+			pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x20);
+	}
+}
+
 static int __devinit
 advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
@@ -18500,6 +18312,8 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	err = pci_request_regions(pdev, "advansys");
 	if (err)
 		goto disable_device;
+	pci_set_master(pdev);
+	advansys_set_latency(pdev);
 
 	if (pci_resource_len(pdev, 0) == 0)
 		goto nodev;

commit 71f36115d20e8d8b0ef10479ff0cde877ec56f98
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 08:04:53 2007 -0600

    [SCSI] advansys: Update resource management
    
    Make sure the resources are reserved and released by all the callers of
    advansys_board_found().  This eliminates the check_region-style race.
    It also allows us to use the pci_request_regions() API.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index eda41f245bb4..d51ca86bda74 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -17681,14 +17681,12 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			     boardp->id, pci_memory_address, iolen);
 			goto err_shost;
 		}
-		ASC_DBG1(1,
-			 "advansys_board_found: ioremap_addr: 0x%lx\n",
+		ASC_DBG1(1, "advansys_board_found: ioremap_addr: 0x%lx\n",
 			 (ulong)boardp->ioremap_addr);
 		adv_dvc_varp->iop_base = (AdvPortAddr)
 		    (boardp->ioremap_addr +
 		     (pci_memory_address - (pci_memory_address & PAGE_MASK)));
-		ASC_DBG1(1,
-			 "advansys_board_found: iop_base: 0x%lx\n",
+		ASC_DBG1(1, "advansys_board_found: iop_base: 0x%lx\n",
 			 adv_dvc_varp->iop_base);
 #endif /* CONFIG_PCI */
 
@@ -18169,25 +18167,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	 * Register Board Resources - I/O Port, DMA, IRQ
 	 */
 
-	/*
-	 * Register I/O port range.
-	 *
-	 * For Wide boards the I/O ports are not used to access
-	 * the board, but request the region anyway.
-	 *
-	 * 'shost->n_io_port' is not referenced, because it may be truncated.
-	 */
-	ASC_DBG2(2,
-		 "advansys_board_found: request_region port 0x%lx, len 0x%x\n",
-		 (ulong)shost->io_port, boardp->asc_n_io_port);
-	if (request_region(shost->io_port, boardp->asc_n_io_port,
-			   "advansys") == NULL) {
-		ASC_PRINT3
-		    ("advansys_board_found: board %d: request_region() failed, port 0x%lx, len 0x%x\n",
-		     boardp->id, (ulong)shost->io_port, boardp->asc_n_io_port);
-		goto err_free_proc;
-	}
-
 	/* Register DMA Channel for Narrow boards. */
 	shost->dma_channel = NO_ISA_DMA;	/* Default to no ISA DMA. */
 #ifdef CONFIG_ISA
@@ -18200,7 +18179,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 				ASC_PRINT3
 				    ("advansys_board_found: board %d: request_dma() %d failed %d\n",
 				     boardp->id, shost->dma_channel, ret);
-				goto err_free_region;
+				goto err_free_proc;
 			}
 			AscEnableIsaDma(shost->dma_channel);
 		}
@@ -18266,8 +18245,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
  err_free_dma:
 	if (shost->dma_channel != NO_ISA_DMA)
 		free_dma(shost->dma_channel);
- err_free_region:
-	release_region(shost->io_port, boardp->asc_n_io_port);
  err_free_proc:
 	kfree(boardp->prtbuf);
  err_unmap:
@@ -18295,7 +18272,6 @@ static int advansys_release(struct Scsi_Host *shost)
 		ASC_DBG(1, "advansys_release: free_dma()\n");
 		free_dma(shost->dma_channel);
 	}
-	release_region(shost->io_port, boardp->asc_n_io_port);
 	if (ASC_WIDE_BOARD(boardp)) {
 		iounmap(boardp->ioremap_addr);
 		advansys_wide_free_mem(boardp);
@@ -18317,19 +18293,17 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	struct Scsi_Host *shost;
 
 	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
-		ASC_DBG1(1, "advansys_isa_match: check_region() failed "
-			 "I/O port 0x%x\n", iop_base);
+		ASC_DBG1(1, "advansys_isa_match: I/O port 0x%x busy\n",
+			 iop_base);
 		return -ENODEV;
 	}
 	ASC_DBG1(1, "advansys_isa_match: probing I/O port 0x%x\n", iop_base);
-	release_region(iop_base, ASC_IOADR_GAP);
 	if (!AscFindSignature(iop_base))
 		goto nodev;
 	if (!(AscGetChipVersion(iop_base, ASC_IS_ISA) & ASC_CHIP_VER_ISA_BIT))
 		goto nodev;
 
 	shost = advansys_board_found(iop_base, dev, ASC_IS_ISA);
-
 	if (!shost)
 		goto nodev;
 
@@ -18337,12 +18311,15 @@ static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
 	return 0;
 
  nodev:
+	release_region(iop_base, ASC_IOADR_GAP);
 	return -ENODEV;
 }
 
 static int __devexit advansys_isa_remove(struct device *dev, unsigned int id)
 {
+	int ioport = _asc_def_iop_base[id];
 	advansys_release(dev_get_drvdata(dev));
+	release_region(ioport, ASC_IOADR_GAP);
 	return 0;
 }
 
@@ -18361,12 +18338,11 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 	struct Scsi_Host *shost;
 
 	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
-		ASC_DBG1(1, "advansys_vlb_match: check_region() failed "
-			 "I/O port 0x%x\n", iop_base);
+		ASC_DBG1(1, "advansys_vlb_match: I/O port 0x%x busy\n",
+			 iop_base);
 		return -ENODEV;
 	}
 	ASC_DBG1(1, "advansys_vlb_match: probing I/O port 0x%x\n", iop_base);
-	release_region(iop_base, ASC_IOADR_GAP);
 	if (!AscFindSignature(iop_base))
 		goto nodev;
 	/*
@@ -18378,7 +18354,6 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 		goto nodev;
 
 	shost = advansys_board_found(iop_base, dev, ASC_IS_VL);
-
 	if (!shost)
 		goto nodev;
 
@@ -18386,6 +18361,7 @@ static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
 	return 0;
 
  nodev:
+	release_region(iop_base, ASC_IOADR_GAP);
 	return -ENODEV;
 }
 
@@ -18429,8 +18405,16 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 
 	err = -ENODEV;
 	for (i = 0; i < 2; i++, ioport += 0x20) {
-		if (!AscFindSignature(ioport))
+		if (!request_region(ioport, ASC_IOADR_GAP, "advansys")) {
+			printk(KERN_WARNING "Region %x-%x busy\n", ioport,
+			       ioport + ASC_IOADR_GAP - 1);
+			continue;
+		}
+		if (!AscFindSignature(ioport)) {
+			release_region(ioport, ASC_IOADR_GAP);
 			continue;
+		}
+
 		/*
 		 * I don't know why we need to do this for EISA chips, but
 		 * not for any others.  It looks to be equivalent to
@@ -18440,8 +18424,11 @@ static int __devinit advansys_eisa_probe(struct device *dev)
 		 */
 		inw(ioport + 4);
 		data->host[i] = advansys_board_found(ioport, dev, ASC_IS_EISA);
-		if (data->host[i])
+		if (data->host[i]) {
 			err = 0;
+		} else {
+			release_region(ioport, ASC_IOADR_GAP);
+		}
 	}
 
 	if (err) {
@@ -18460,10 +18447,13 @@ static __devexit int advansys_eisa_remove(struct device *dev)
 	struct eisa_scsi_data *data = dev_get_drvdata(dev);
 
 	for (i = 0; i < 2; i++) {
+		int ioport;
 		struct Scsi_Host *shost = data->host[i];
 		if (!shost)
 			continue;
+		ioport = shost->io_port;
 		advansys_release(shost);
+		release_region(ioport, ASC_IOADR_GAP);
 	}
 
 	kfree(data);
@@ -18507,6 +18497,9 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	err = pci_enable_device(pdev);
 	if (err)
 		goto fail;
+	err = pci_request_regions(pdev, "advansys");
+	if (err)
+		goto disable_device;
 
 	if (pci_resource_len(pdev, 0) == 0)
 		goto nodev;
@@ -18522,6 +18515,8 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
  nodev:
 	err = -ENODEV;
+	pci_release_regions(pdev);
+ disable_device:
 	pci_disable_device(pdev);
  fail:
 	return err;
@@ -18530,6 +18525,7 @@ advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 static void __devexit advansys_pci_remove(struct pci_dev *pdev)
 {
 	advansys_release(pci_get_drvdata(pdev));
+	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 }
 

commit c304ec94733aec764396813f3f05dfbe02f4a6da
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 09:18:45 2007 -0600

    [SCSI] advansys: Convert to ISA driver model
    
    Register two isa_drivers, one for ISA and one for VLB, in order to
    preserve detection order.  When deleting advansys_detect, we lose the
    last vestiges of the code that limited IO port scanning.  This code
    has been effectively disabled for many years anyway; I'll restore it
    in a module_param later.  We also lose the code that placed all ISA PnP
    cards into WaitForKey state -- drivers shouldn't be doing this anyway.
    The asc_host array goes away too.  Also remove some IOADR and other
    definitions, such as ASC_NUM_BOARD_SUPPORTED.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e096f19e4dd9..eda41f245bb4 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -280,7 +280,7 @@
 
         AdvanSys SCSI adapter files have the following path name format:
 
-           /proc/scsi/advansys/[0-(ASC_NUM_BOARD_SUPPORTED-1)]
+           /proc/scsi/advansys/{0,1,2,3,...}
 
         This information can be displayed with cat. For example:
 
@@ -769,6 +769,7 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
+#include <linux/isa.h>
 #include <linux/eisa.h>
 #include <linux/pci.h>
 #include <linux/spinlock.h>
@@ -1362,18 +1363,6 @@ typedef struct asc_risc_sg_list_q {
 #define ASC_MAX_INRAM_TAG_QNG   16
 #define ASC_IOADR_TABLE_MAX_IX  11
 #define ASC_IOADR_GAP   0x10
-#define ASC_SEARCH_IOP_GAP 0x10
-#define ASC_MIN_IOP_ADDR   (PortAddr)0x0100
-#define ASC_MAX_IOP_ADDR   (PortAddr)0x3F0
-#define ASC_IOADR_1     (PortAddr)0x0110
-#define ASC_IOADR_2     (PortAddr)0x0130
-#define ASC_IOADR_3     (PortAddr)0x0150
-#define ASC_IOADR_4     (PortAddr)0x0190
-#define ASC_IOADR_5     (PortAddr)0x0210
-#define ASC_IOADR_6     (PortAddr)0x0230
-#define ASC_IOADR_7     (PortAddr)0x0250
-#define ASC_IOADR_8     (PortAddr)0x0330
-#define ASC_IOADR_DEF   ASC_IOADR_8
 #define ASC_LIB_SCSIQ_WK_SP        256
 #define ASC_MAX_SYN_XFER_NO        16
 #define ASC_SYN_MAX_OFFSET         0x0F
@@ -1934,9 +1923,6 @@ static int AscIsrQDone(ASC_DVC_VAR *);
 static int AscCompareString(uchar *, uchar *, int);
 #ifdef CONFIG_ISA
 static ushort AscGetEisaChipCfg(PortAddr);
-static PortAddr AscSearchIOPortAddr11(PortAddr);
-static PortAddr AscSearchIOPortAddr(PortAddr, ushort);
-static void AscSetISAPNPWaitForKey(void);
 #endif /* CONFIG_ISA */
 static uchar AscGetChipScsiCtrl(PortAddr);
 static uchar AscSetChipScsiID(PortAddr, uchar);
@@ -3405,10 +3391,6 @@ typedef struct {
  * --- Driver Constants and Macros
  */
 
-#define ASC_NUM_BOARD_SUPPORTED 16
-#define ASC_NUM_IOPORT_PROBE    4
-#define ASC_NUM_BUS             2
-
 /* Reference Scsi_Host hostdata */
 #define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
 
@@ -3836,10 +3818,6 @@ typedef struct asc_board {
 /* Number of boards detected in system. */
 static int asc_board_count;
 
-/* Number of boards detected by advansys_detect */
-static int asc_legacy_count;
-static struct Scsi_Host *asc_host[ASC_NUM_BOARD_SUPPORTED] = { NULL };
-
 /* Overrun buffer used by all narrow boards. */
 static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 
@@ -3849,27 +3827,10 @@ static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 static ASC_SCSI_Q asc_scsi_q = { {0} };
 static ASC_SG_HEAD asc_sg_head = { 0 };
 
-/* List of bus types probed in advansys_detect. */
-static ushort asc_bus[ASC_NUM_BUS] __initdata = {
-	ASC_IS_ISA,
-	ASC_IS_VL,
-};
-
-static int asc_iopflag = ASC_FALSE;
-static int asc_ioport[ASC_NUM_IOPORT_PROBE] = { 0, 0, 0, 0 };
-
 #ifdef ADVANSYS_DEBUG
-static char *asc_bus_name[ASC_NUM_BUS] = {
-	"ASC_IS_ISA",
-	"ASC_IS_VL",
-};
-
 static int asc_dbglvl = 3;
 #endif /* ADVANSYS_DEBUG */
 
-/* Declaration for Asc Library internal data referenced by driver. */
-static PortAddr _asc_def_iop_base[];
-
 /*
  * --- Driver Function Prototypes
  *
@@ -3932,7 +3893,7 @@ static void asc_prt_hex(char *f, uchar *, int);
 
 #ifdef CONFIG_PROC_FS
 /*
- * advansys_proc_info() - /proc/scsi/advansys/[0-(ASC_NUM_BOARD_SUPPORTED-1)]
+ * advansys_proc_info() - /proc/scsi/advansys/{0,1,2,3,...}
  *
  * *buffer: I/O buffer
  * **start: if inout == FALSE pointer into buffer where user read should start
@@ -8196,77 +8157,6 @@ static int AscFindSignature(PortAddr iop_base)
 	return (0);
 }
 
-static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __initdata = {
-	0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
-	ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
-};
-
-#ifdef CONFIG_ISA
-static uchar _isa_pnp_inited __initdata = 0;
-
-static PortAddr __init AscSearchIOPortAddr(PortAddr iop_beg, ushort bus_type)
-{
-	if (bus_type & ASC_IS_VL) {
-		while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
-			if (AscGetChipVersion(iop_beg, bus_type) <=
-			    ASC_CHIP_MAX_VER_VL) {
-				return (iop_beg);
-			}
-		}
-		return (0);
-	}
-	if (bus_type & ASC_IS_ISA) {
-		if (_isa_pnp_inited == 0) {
-			AscSetISAPNPWaitForKey();
-			_isa_pnp_inited++;
-		}
-		while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
-			if ((AscGetChipVersion(iop_beg, bus_type) &
-			     ASC_CHIP_VER_ISA_BIT) != 0) {
-				return (iop_beg);
-			}
-		}
-		return (0);
-	}
-	return (0);
-}
-
-static PortAddr __init AscSearchIOPortAddr11(PortAddr s_addr)
-{
-	int i;
-	PortAddr iop_base;
-
-	for (i = 0; i < ASC_IOADR_TABLE_MAX_IX; i++) {
-		if (_asc_def_iop_base[i] > s_addr) {
-			break;
-		}
-	}
-	for (; i < ASC_IOADR_TABLE_MAX_IX; i++) {
-		iop_base = _asc_def_iop_base[i];
-		if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
-			ASC_DBG1(1,
-				 "AscSearchIOPortAddr11: check_region() failed I/O port 0x%x\n",
-				 iop_base);
-			continue;
-		}
-		ASC_DBG1(1, "AscSearchIOPortAddr11: probing I/O port 0x%x\n",
-			 iop_base);
-		release_region(iop_base, ASC_IOADR_GAP);
-		if (AscFindSignature(iop_base)) {
-			return (iop_base);
-		}
-	}
-	return (0);
-}
-
-static void __init AscSetISAPNPWaitForKey(void)
-{
-	outp(ASC_ISA_PNP_PORT_ADDR, 0x02);
-	outp(ASC_ISA_PNP_PORT_WRITE, 0x02);
-	return;
-}
-#endif /* CONFIG_ISA */
-
 static void __devinit AscToggleIRQAct(PortAddr iop_base)
 {
 	AscSetChipStatus(iop_base, CIW_IRQ_ACT);
@@ -18388,181 +18278,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	return NULL;
 }
 
-/*
- * advansys_detect()
- *
- * Detect function for AdvanSys adapters.
- *
- * Argument is a pointer to the host driver's scsi_hosts entry.
- *
- * Return number of adapters found.
- *
- * Note: Because this function is called during system initialization
- * it must not call SCSI mid-level functions including scsi_malloc()
- * and scsi_free().
- */
-static int __init advansys_detect(void)
-{
-	int iop;
-	int bus;
-	int ioport = 0;
-	struct Scsi_Host *shost;
-
-	ASC_DBG(1, "advansys_detect: begin\n");
-
-	asc_legacy_count = 0;
-
-	/*
-	 * If I/O port probing has been modified, then verify and
-	 * clean-up the 'asc_ioport' list.
-	 */
-	if (asc_iopflag == ASC_TRUE) {
-		for (ioport = 0; ioport < ASC_NUM_IOPORT_PROBE; ioport++) {
-			ASC_DBG2(1, "advansys_detect: asc_ioport[%d] 0x%x\n",
-				 ioport, asc_ioport[ioport]);
-			if (asc_ioport[ioport] != 0) {
-				for (iop = 0; iop < ASC_IOADR_TABLE_MAX_IX;
-				     iop++) {
-					if (_asc_def_iop_base[iop] ==
-					    asc_ioport[ioport]) {
-						break;
-					}
-				}
-				if (iop == ASC_IOADR_TABLE_MAX_IX) {
-					printk
-					    ("AdvanSys SCSI: specified I/O Port 0x%X is invalid\n",
-					     asc_ioport[ioport]);
-					asc_ioport[ioport] = 0;
-				}
-			}
-		}
-		ioport = 0;
-	}
-
-	for (bus = 0; bus < ASC_NUM_BUS; bus++) {
-
-		ASC_DBG2(1, "advansys_detect: bus search type %d (%s)\n",
-			 bus, asc_bus_name[bus]);
-		iop = 0;
-
-		while (asc_legacy_count < ASC_NUM_BOARD_SUPPORTED) {
-
-			ASC_DBG1(2, "advansys_detect: asc_legacy_count %d\n",
-				 asc_legacy_count);
-
-			switch (asc_bus[bus]) {
-			case ASC_IS_ISA:
-			case ASC_IS_VL:
-#ifdef CONFIG_ISA
-				if (asc_iopflag == ASC_FALSE) {
-					iop =
-					    AscSearchIOPortAddr(iop,
-								asc_bus[bus]);
-				} else {
-					/*
-					 * ISA and VL I/O port scanning has either been
-					 * eliminated or limited to selected ports on
-					 * the LILO command line, /etc/lilo.conf, or
-					 * by setting variables when the module was loaded.
-					 */
-					ASC_DBG(1,
-						"advansys_detect: I/O port scanning modified\n");
- ioport_try_again:
-					iop = 0;
-					for (; ioport < ASC_NUM_IOPORT_PROBE;
-					     ioport++) {
-						if ((iop =
-						     asc_ioport[ioport]) != 0) {
-							break;
-						}
-					}
-					if (iop) {
-						ASC_DBG1(1,
-							 "advansys_detect: probing I/O port 0x%x...\n",
-							 iop);
-						if (!request_region
-						    (iop, ASC_IOADR_GAP,
-						     "advansys")) {
-							printk
-							    ("AdvanSys SCSI: specified I/O Port 0x%X is busy\n",
-							     iop);
-							/* Don't try this I/O port twice. */
-							asc_ioport[ioport] = 0;
-							goto ioport_try_again;
-						} else if (AscFindSignature(iop)
-							   == ASC_FALSE) {
-							printk
-							    ("AdvanSys SCSI: specified I/O Port 0x%X has no adapter\n",
-							     iop);
-							/* Don't try this I/O port twice. */
-							release_region(iop,
-								       ASC_IOADR_GAP);
-							asc_ioport[ioport] = 0;
-							goto ioport_try_again;
-						} else {
-							/*
-							 * If this isn't an ISA board, then it must be
-							 * a VL board. If currently looking an ISA
-							 * board is being looked for then try for
-							 * another ISA board in 'asc_ioport'.
-							 */
-							if (asc_bus[bus] ==
-							    ASC_IS_ISA
-							    &&
-							    (AscGetChipVersion
-							     (iop,
-							      ASC_IS_ISA) &
-							     ASC_CHIP_VER_ISA_BIT)
-							    == 0) {
-								/*
-								 * Don't clear 'asc_ioport[ioport]'. Try
-								 * this board again for VL. Increment
-								 * 'ioport' past this board.
-								 */
-								ioport++;
-								release_region
-								    (iop,
-								     ASC_IOADR_GAP);
-								goto ioport_try_again;
-							}
-						}
-						/*
-						 * This board appears good, don't try the I/O port
-						 * again by clearing its value. Increment 'ioport'
-						 * for the next iteration.
-						 */
-						asc_ioport[ioport++] = 0;
-					}
-				}
-#endif /* CONFIG_ISA */
-				break;
-
-			default:
-				ASC_PRINT1
-				    ("advansys_detect: unknown bus type: %d\n",
-				     asc_bus[bus]);
-				break;
-			}
-			ASC_DBG1(1, "advansys_detect: iop 0x%x\n", iop);
-
-			/*
-			 * Adapter not found, try next bus type.
-			 */
-			if (iop == 0)
-				break;
-
-			shost = advansys_board_found(iop, NULL, asc_bus[bus]);
-			if (shost) {
-				asc_host[asc_legacy_count++] = shost;
-			}
-		}
-	}
-
-	ASC_DBG1(1, "advansys_detect: done: asc_legacy_count %d\n",
-		 asc_legacy_count);
-	return asc_legacy_count;
-}
-
 /*
  * advansys_release()
  *
@@ -18591,6 +18306,98 @@ static int advansys_release(struct Scsi_Host *shost)
 	return 0;
 }
 
+static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __devinitdata = {
+	0x100, 0x0110, 0x120, 0x0130, 0x140, 0x0150, 0x0190,
+	0x0210, 0x0230, 0x0250, 0x0330
+};
+
+static int __devinit advansys_isa_probe(struct device *dev, unsigned int id)
+{
+	PortAddr iop_base = _asc_def_iop_base[id];
+	struct Scsi_Host *shost;
+
+	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
+		ASC_DBG1(1, "advansys_isa_match: check_region() failed "
+			 "I/O port 0x%x\n", iop_base);
+		return -ENODEV;
+	}
+	ASC_DBG1(1, "advansys_isa_match: probing I/O port 0x%x\n", iop_base);
+	release_region(iop_base, ASC_IOADR_GAP);
+	if (!AscFindSignature(iop_base))
+		goto nodev;
+	if (!(AscGetChipVersion(iop_base, ASC_IS_ISA) & ASC_CHIP_VER_ISA_BIT))
+		goto nodev;
+
+	shost = advansys_board_found(iop_base, dev, ASC_IS_ISA);
+
+	if (!shost)
+		goto nodev;
+
+	dev_set_drvdata(dev, shost);
+	return 0;
+
+ nodev:
+	return -ENODEV;
+}
+
+static int __devexit advansys_isa_remove(struct device *dev, unsigned int id)
+{
+	advansys_release(dev_get_drvdata(dev));
+	return 0;
+}
+
+static struct isa_driver advansys_isa_driver = {
+	.probe		= advansys_isa_probe,
+	.remove		= __devexit_p(advansys_isa_remove),
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "advansys",
+	},
+};
+
+static int __devinit advansys_vlb_probe(struct device *dev, unsigned int id)
+{
+	PortAddr iop_base = _asc_def_iop_base[id];
+	struct Scsi_Host *shost;
+
+	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
+		ASC_DBG1(1, "advansys_vlb_match: check_region() failed "
+			 "I/O port 0x%x\n", iop_base);
+		return -ENODEV;
+	}
+	ASC_DBG1(1, "advansys_vlb_match: probing I/O port 0x%x\n", iop_base);
+	release_region(iop_base, ASC_IOADR_GAP);
+	if (!AscFindSignature(iop_base))
+		goto nodev;
+	/*
+	 * I don't think this condition can actually happen, but the old
+	 * driver did it, and the chances of finding a VLB setup in 2007
+	 * to do testing with is slight to none.
+	 */
+	if (AscGetChipVersion(iop_base, ASC_IS_VL) > ASC_CHIP_MAX_VER_VL)
+		goto nodev;
+
+	shost = advansys_board_found(iop_base, dev, ASC_IS_VL);
+
+	if (!shost)
+		goto nodev;
+
+	dev_set_drvdata(dev, shost);
+	return 0;
+
+ nodev:
+	return -ENODEV;
+}
+
+static struct isa_driver advansys_vlb_driver = {
+	.probe		= advansys_vlb_probe,
+	.remove		= __devexit_p(advansys_isa_remove),
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "advansys",
+	},
+};
+
 static struct eisa_device_id advansys_eisa_table[] __devinitdata = {
 	{ "ABP7401" },
 	{ "ABP7501" },
@@ -18735,13 +18542,22 @@ static struct pci_driver advansys_pci_driver = {
 
 static int __init advansys_init(void)
 {
-	int i, error;
-	advansys_detect();
+	int error;
 
-	error = eisa_driver_register(&advansys_eisa_driver);
+	error = isa_register_driver(&advansys_isa_driver,
+				    ASC_IOADR_TABLE_MAX_IX);
 	if (error)
 		goto fail;
 
+	error = isa_register_driver(&advansys_vlb_driver,
+				    ASC_IOADR_TABLE_MAX_IX);
+	if (error)
+		goto unregister_isa;
+
+	error = eisa_driver_register(&advansys_eisa_driver);
+	if (error)
+		goto unregister_vlb;
+
 	error = pci_register_driver(&advansys_pci_driver);
 	if (error)
 		goto unregister_eisa;
@@ -18750,22 +18566,20 @@ static int __init advansys_init(void)
 
  unregister_eisa:
 	eisa_driver_unregister(&advansys_eisa_driver);
+ unregister_vlb:
+	isa_unregister_driver(&advansys_vlb_driver);
+ unregister_isa:
+	isa_unregister_driver(&advansys_isa_driver);
  fail:
-	for (i = 0; i < asc_legacy_count; i++)
-		advansys_release(asc_host[i]);
-
 	return error;
 }
 
 static void __exit advansys_exit(void)
 {
-	int i;
-
 	pci_unregister_driver(&advansys_pci_driver);
 	eisa_driver_unregister(&advansys_eisa_driver);
-
-	for (i = 0; i < asc_legacy_count; i++)
-		advansys_release(asc_host[i]);
+	isa_unregister_driver(&advansys_vlb_driver);
+	isa_unregister_driver(&advansys_isa_driver);
 }
 
 module_init(advansys_init);

commit b09e05a73e8308397371edc15b7d45082971fa95
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 09:14:52 2007 -0600

    [SCSI] advansys: Convert to EISA driver model
    
     - Switch EISA probing to the driver model
     - Remove some now-unused macros and functions
     - Update the FIXME now that we use the correct driver model probing API
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 3ba70323345d..e096f19e4dd9 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -769,6 +769,7 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
+#include <linux/eisa.h>
 #include <linux/pci.h>
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
@@ -783,13 +784,9 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
 
-/* FIXME: (by jejb@steeleye.com) This warning is present for two
- * reasons:
+/* FIXME: (by jejb@steeleye.com)
  *
- * 1) This driver badly needs converting to the correct driver model
- *    probing API
- *
- * 2) Although all of the necessary command mapping places have the
+ * Although all of the necessary command mapping places have the
  * appropriate dma_map.. APIs, the driver still processes its internal
  * queue using bus_to_virt() and virt_to_bus() which are illegal under
  * the API.  The entire queue processing structure will need to be
@@ -1787,16 +1784,10 @@ typedef struct asceep_config {
 #define ASC_1000_ID0W      0x04C1
 #define ASC_1000_ID0W_FIX  0x00C1
 #define ASC_1000_ID1B      0x25
-#define ASC_EISA_BIG_IOP_GAP   (0x1C30-0x0C50)
-#define ASC_EISA_SMALL_IOP_GAP (0x0020)
-#define ASC_EISA_MIN_IOP_ADDR  (0x0C30)
-#define ASC_EISA_MAX_IOP_ADDR  (0xFC50)
 #define ASC_EISA_REV_IOP_MASK  (0x0C83)
 #define ASC_EISA_PID_IOP_MASK  (0x0C80)
 #define ASC_EISA_CFG_IOP_MASK  (0x0C86)
 #define ASC_GET_EISA_SLOT(iop)  (PortAddr)((iop) & 0xF000)
-#define ASC_EISA_ID_740    0x01745004UL
-#define ASC_EISA_ID_750    0x01755004UL
 #define INS_HALTINT        (ushort)0x6281
 #define INS_HALT           (ushort)0x6280
 #define INS_SINT           (ushort)0x6200
@@ -1943,8 +1934,6 @@ static int AscIsrQDone(ASC_DVC_VAR *);
 static int AscCompareString(uchar *, uchar *, int);
 #ifdef CONFIG_ISA
 static ushort AscGetEisaChipCfg(PortAddr);
-static ASC_DCNT AscGetEisaProductID(PortAddr);
-static PortAddr AscSearchIOPortAddrEISA(PortAddr);
 static PortAddr AscSearchIOPortAddr11(PortAddr);
 static PortAddr AscSearchIOPortAddr(PortAddr, ushort);
 static void AscSetISAPNPWaitForKey(void);
@@ -3418,7 +3407,7 @@ typedef struct {
 
 #define ASC_NUM_BOARD_SUPPORTED 16
 #define ASC_NUM_IOPORT_PROBE    4
-#define ASC_NUM_BUS             3
+#define ASC_NUM_BUS             2
 
 /* Reference Scsi_Host hostdata */
 #define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
@@ -3864,7 +3853,6 @@ static ASC_SG_HEAD asc_sg_head = { 0 };
 static ushort asc_bus[ASC_NUM_BUS] __initdata = {
 	ASC_IS_ISA,
 	ASC_IS_VL,
-	ASC_IS_EISA,
 };
 
 static int asc_iopflag = ASC_FALSE;
@@ -3874,7 +3862,6 @@ static int asc_ioport[ASC_NUM_IOPORT_PROBE] = { 0, 0, 0, 0 };
 static char *asc_bus_name[ASC_NUM_BUS] = {
 	"ASC_IS_ISA",
 	"ASC_IS_VL",
-	"ASC_IS_EISA",
 };
 
 static int asc_dbglvl = 3;
@@ -8241,12 +8228,6 @@ static PortAddr __init AscSearchIOPortAddr(PortAddr iop_beg, ushort bus_type)
 		}
 		return (0);
 	}
-	if (bus_type & ASC_IS_EISA) {
-		if ((iop_beg = AscSearchIOPortAddrEISA(iop_beg)) != 0) {
-			return (iop_beg);
-		}
-		return (0);
-	}
 	return (0);
 }
 
@@ -10256,57 +10237,6 @@ static void DvcDelayNanoSecond(ASC_DVC_VAR *asc_dvc, ASC_DCNT nano_sec)
 	udelay((nano_sec + 999) / 1000);
 }
 
-#ifdef CONFIG_ISA
-static ASC_DCNT __init AscGetEisaProductID(PortAddr iop_base)
-{
-	PortAddr eisa_iop;
-	ushort product_id_high, product_id_low;
-	ASC_DCNT product_id;
-
-	eisa_iop = ASC_GET_EISA_SLOT(iop_base) | ASC_EISA_PID_IOP_MASK;
-	product_id_low = inpw(eisa_iop);
-	product_id_high = inpw(eisa_iop + 2);
-	product_id = ((ASC_DCNT) product_id_high << 16) |
-	    (ASC_DCNT) product_id_low;
-	return (product_id);
-}
-
-static PortAddr __init AscSearchIOPortAddrEISA(PortAddr iop_base)
-{
-	ASC_DCNT eisa_product_id;
-
-	if (iop_base == 0) {
-		iop_base = ASC_EISA_MIN_IOP_ADDR;
-	} else {
-		if (iop_base == ASC_EISA_MAX_IOP_ADDR)
-			return (0);
-		if ((iop_base & 0x0050) == 0x0050) {
-			iop_base += ASC_EISA_BIG_IOP_GAP;
-		} else {
-			iop_base += ASC_EISA_SMALL_IOP_GAP;
-		}
-	}
-	while (iop_base <= ASC_EISA_MAX_IOP_ADDR) {
-		eisa_product_id = AscGetEisaProductID(iop_base);
-		if ((eisa_product_id == ASC_EISA_ID_740) ||
-		    (eisa_product_id == ASC_EISA_ID_750)) {
-			if (AscFindSignature(iop_base)) {
-				inpw(iop_base + 4);
-				return (iop_base);
-			}
-		}
-		if (iop_base == ASC_EISA_MAX_IOP_ADDR)
-			return (0);
-		if ((iop_base & 0x0050) == 0x0050) {
-			iop_base += ASC_EISA_BIG_IOP_GAP;
-		} else {
-			iop_base += ASC_EISA_SMALL_IOP_GAP;
-		}
-	}
-	return (0);
-}
-#endif /* CONFIG_ISA */
-
 static int AscStartChip(PortAddr iop_base)
 {
 	AscSetChipControl(iop_base, 0);
@@ -18607,12 +18537,6 @@ static int __init advansys_detect(void)
 #endif /* CONFIG_ISA */
 				break;
 
-			case ASC_IS_EISA:
-#ifdef CONFIG_ISA
-				iop = AscSearchIOPortAddr(iop, asc_bus[bus]);
-#endif /* CONFIG_ISA */
-				break;
-
 			default:
 				ASC_PRINT1
 				    ("advansys_detect: unknown bus type: %d\n",
@@ -18667,6 +18591,87 @@ static int advansys_release(struct Scsi_Host *shost)
 	return 0;
 }
 
+static struct eisa_device_id advansys_eisa_table[] __devinitdata = {
+	{ "ABP7401" },
+	{ "ABP7501" },
+	{ "" }
+};
+
+MODULE_DEVICE_TABLE(eisa, advansys_eisa_table);
+
+/*
+ * EISA is a little more tricky than PCI; each EISA device may have two
+ * channels, and this driver is written to make each channel its own Scsi_Host
+ */
+struct eisa_scsi_data {
+	struct Scsi_Host *host[2];
+};
+
+static int __devinit advansys_eisa_probe(struct device *dev)
+{
+	int i, ioport;
+	int err;
+	struct eisa_device *edev = to_eisa_device(dev);
+	struct eisa_scsi_data *data;
+
+	err = -ENOMEM;
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		goto fail;
+	ioport = edev->base_addr + 0xc30;
+
+	err = -ENODEV;
+	for (i = 0; i < 2; i++, ioport += 0x20) {
+		if (!AscFindSignature(ioport))
+			continue;
+		/*
+		 * I don't know why we need to do this for EISA chips, but
+		 * not for any others.  It looks to be equivalent to
+		 * AscGetChipCfgMsw, but I may have overlooked something,
+		 * so I'm not converting it until I get an EISA board to
+		 * test with.
+		 */
+		inw(ioport + 4);
+		data->host[i] = advansys_board_found(ioport, dev, ASC_IS_EISA);
+		if (data->host[i])
+			err = 0;
+	}
+
+	if (err) {
+		kfree(data);
+	} else {
+		dev_set_drvdata(dev, data);
+	}
+
+ fail:
+	return err;
+}
+
+static __devexit int advansys_eisa_remove(struct device *dev)
+{
+	int i;
+	struct eisa_scsi_data *data = dev_get_drvdata(dev);
+
+	for (i = 0; i < 2; i++) {
+		struct Scsi_Host *shost = data->host[i];
+		if (!shost)
+			continue;
+		advansys_release(shost);
+	}
+
+	kfree(data);
+	return 0;
+}
+
+static struct eisa_driver advansys_eisa_driver = {
+	.id_table =		advansys_eisa_table,
+	.driver = {
+		.name =		"advansys",
+		.probe =	advansys_eisa_probe,
+		.remove =	__devexit_p(advansys_eisa_remove),
+	}
+};
+
 /* PCI Devices supported by this driver */
 static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
@@ -18732,12 +18737,19 @@ static int __init advansys_init(void)
 {
 	int i, error;
 	advansys_detect();
-	error = pci_register_driver(&advansys_pci_driver);
+
+	error = eisa_driver_register(&advansys_eisa_driver);
 	if (error)
 		goto fail;
 
+	error = pci_register_driver(&advansys_pci_driver);
+	if (error)
+		goto unregister_eisa;
+
 	return 0;
 
+ unregister_eisa:
+	eisa_driver_unregister(&advansys_eisa_driver);
  fail:
 	for (i = 0; i < asc_legacy_count; i++)
 		advansys_release(asc_host[i]);
@@ -18750,6 +18762,7 @@ static void __exit advansys_exit(void)
 	int i;
 
 	pci_unregister_driver(&advansys_pci_driver);
+	eisa_driver_unregister(&advansys_eisa_driver);
 
 	for (i = 0; i < asc_legacy_count; i++)
 		advansys_release(asc_host[i]);

commit 78e77d8b50633241d34cd9e64626d39d0a8cd2c0
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Jul 29 21:46:15 2007 -0600

    [SCSI] advansys: Convert to PCI driver model
    
     - Add a pci_driver interface for the PCI advansys devices (for
       ISA/EISA/VLB devices, we still call advansys_detect).
     - Many functions are converted from __init to __devinit to allow hotplug
       PCI to work.
     - Only keep devices found by advansys_detect in the asc_host list.
     - Rename asc_board_count to asc_legacy_count.  New asc_board_count is only
       used to generate a unique name for each device.
     - Remove some now-unused macros and struct definitions
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 8353680b8682..3ba70323345d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -865,12 +865,8 @@ typedef unsigned char uchar;
 #define AscPCIConfigLatencyTimer          0x000D
 #define AscPCIIOBaseRegister              0x0010
 #define AscPCICmdRegBits_IOMemBusMaster   0x0007
-#define ASC_PCI_ID2BUS(id)    ((id) & 0xFF)
-#define ASC_PCI_ID2DEV(id)    (((id) >> 11) & 0x1F)
 #define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)
 #define ASC_PCI_MKID(bus, dev, func) ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))
-#define ASC_PCI_REVISION_3150             0x02
-#define ASC_PCI_REVISION_3050             0x03
 
 #define  ASC_DVCLIB_CALL_DONE     (1)
 #define  ASC_DVCLIB_CALL_FAILED   (0)
@@ -3422,7 +3418,7 @@ typedef struct {
 
 #define ASC_NUM_BOARD_SUPPORTED 16
 #define ASC_NUM_IOPORT_PROBE    4
-#define ASC_NUM_BUS             4
+#define ASC_NUM_BUS             3
 
 /* Reference Scsi_Host hostdata */
 #define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
@@ -3526,11 +3522,6 @@ typedef struct scsi_cmnd REQ, *REQP;
 /* Return non-zero, if the queue is empty. */
 #define ASC_QUEUE_EMPTY(ascq)    ((ascq)->q_tidmask == 0)
 
-#define PCI_MAX_SLOT            0x1F
-#define PCI_MAX_BUS             0xFF
-#define PCI_IOADDRESS_MASK      0xFFFE
-#define ASC_PCI_DEVICE_ID_CNT   6	/* PCI Device ID count. */
-
 #ifndef ADVANSYS_STATS
 #define ASC_STATS(shost, counter)
 #define ASC_STATS_ADD(shost, counter, count)
@@ -3853,60 +3844,11 @@ typedef struct asc_board {
 	ushort bios_codelen;	/* BIOS Code Segment Length. */
 } asc_board_t;
 
-/*
- * PCI configuration structures
- */
-typedef struct _PCI_DATA_ {
-	uchar type;
-	uchar bus;
-	uchar slot;
-	uchar func;
-	uchar offset;
-} PCI_DATA;
-
-typedef struct _PCI_DEVICE_ {
-	ushort vendorID;
-	ushort deviceID;
-	ushort slotNumber;
-	ushort slotFound;
-	uchar busNumber;
-	uchar maxBusNumber;
-	uchar devFunc;
-	ushort startSlot;
-	ushort endSlot;
-	uchar bridge;
-	uchar type;
-} PCI_DEVICE;
-
-typedef struct _PCI_CONFIG_SPACE_ {
-	ushort vendorID;
-	ushort deviceID;
-	ushort command;
-	ushort status;
-	uchar revision;
-	uchar classCode[3];
-	uchar cacheSize;
-	uchar latencyTimer;
-	uchar headerType;
-	uchar bist;
-	ADV_PADDR baseAddress[6];
-	ushort reserved[4];
-	ADV_PADDR optionRomAddr;
-	ushort reserved2[4];
-	uchar irqLine;
-	uchar irqPin;
-	uchar minGnt;
-	uchar maxLatency;
-} PCI_CONFIG_SPACE;
-
-/*
- * --- Driver Data
- */
-
-/* Note: All driver global data should be initialized. */
-
 /* Number of boards detected in system. */
-static int asc_board_count = 0;
+static int asc_board_count;
+
+/* Number of boards detected by advansys_detect */
+static int asc_legacy_count;
 static struct Scsi_Host *asc_host[ASC_NUM_BOARD_SUPPORTED] = { NULL };
 
 /* Overrun buffer used by all narrow boards. */
@@ -3918,12 +3860,11 @@ static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 static ASC_SCSI_Q asc_scsi_q = { {0} };
 static ASC_SG_HEAD asc_sg_head = { 0 };
 
-/* List of supported bus types. */
+/* List of bus types probed in advansys_detect. */
 static ushort asc_bus[ASC_NUM_BUS] __initdata = {
 	ASC_IS_ISA,
 	ASC_IS_VL,
 	ASC_IS_EISA,
-	ASC_IS_PCI,
 };
 
 static int asc_iopflag = ASC_FALSE;
@@ -3934,7 +3875,6 @@ static char *asc_bus_name[ASC_NUM_BUS] = {
 	"ASC_IS_ISA",
 	"ASC_IS_VL",
 	"ASC_IS_EISA",
-	"ASC_IS_PCI",
 };
 
 static int asc_dbglvl = 3;
@@ -7441,7 +7381,7 @@ DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
 /*
  * Read a PCI configuration byte.
  */
-static uchar __init DvcReadPCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset)
+static uchar __devinit DvcReadPCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset)
 {
 #ifdef CONFIG_PCI
 	uchar byte_data;
@@ -7455,7 +7395,7 @@ static uchar __init DvcReadPCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset)
 /*
  * Write a PCI configuration byte.
  */
-static void __init
+static void __devinit
 DvcWritePCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
 {
 #ifdef CONFIG_PCI
@@ -7467,7 +7407,7 @@ DvcWritePCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
  * Return the BIOS address of the adapter at the specified
  * I/O port and with the specified bus type.
  */
-static ushort __init AscGetChipBiosAddress(PortAddr iop_base, ushort bus_type)
+static ushort __devinit AscGetChipBiosAddress(PortAddr iop_base, ushort bus_type)
 {
 	ushort cfg_lsw;
 	ushort bios_addr;
@@ -7538,7 +7478,7 @@ DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
 /*
  * Read a PCI configuration byte.
  */
-static uchar __init DvcAdvReadPCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset)
+static uchar __devinit DvcAdvReadPCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset)
 {
 #ifdef CONFIG_PCI
 	uchar byte_data;
@@ -7552,7 +7492,7 @@ static uchar __init DvcAdvReadPCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset)
 /*
  * Write a PCI configuration byte.
  */
-static void __init
+static void __devinit
 DvcAdvWritePCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
 {
 #ifdef CONFIG_PCI
@@ -8148,7 +8088,7 @@ static void asc_prt_hex(char *f, uchar *s, int l)
  * --- Asc Library Functions
  */
 
-static ushort __init AscGetEisaChipCfg(PortAddr iop_base)
+static ushort __devinit AscGetEisaChipCfg(PortAddr iop_base)
 {
 	PortAddr eisa_cfg_iop;
 
@@ -8157,7 +8097,7 @@ static ushort __init AscGetEisaChipCfg(PortAddr iop_base)
 	return (inpw(eisa_cfg_iop));
 }
 
-static uchar __init AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
+static uchar __devinit AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
 {
 	ushort cfg_lsw;
 
@@ -8171,7 +8111,7 @@ static uchar __init AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
 	return (AscGetChipScsiID(iop_base));
 }
 
-static uchar __init AscGetChipScsiCtrl(PortAddr iop_base)
+static uchar __devinit AscGetChipScsiCtrl(PortAddr iop_base)
 {
 	uchar sc;
 
@@ -8181,7 +8121,7 @@ static uchar __init AscGetChipScsiCtrl(PortAddr iop_base)
 	return (sc);
 }
 
-static uchar __init AscGetChipVersion(PortAddr iop_base, ushort bus_type)
+static uchar __devinit AscGetChipVersion(PortAddr iop_base, ushort bus_type)
 {
 	if ((bus_type & ASC_IS_EISA) != 0) {
 		PortAddr eisa_iop;
@@ -8194,7 +8134,7 @@ static uchar __init AscGetChipVersion(PortAddr iop_base, ushort bus_type)
 	return (AscGetChipVerNo(iop_base));
 }
 
-static ushort __init AscGetChipBusType(PortAddr iop_base)
+static ushort __devinit AscGetChipBusType(PortAddr iop_base)
 {
 	ushort chip_ver;
 
@@ -8346,14 +8286,14 @@ static void __init AscSetISAPNPWaitForKey(void)
 }
 #endif /* CONFIG_ISA */
 
-static void __init AscToggleIRQAct(PortAddr iop_base)
+static void __devinit AscToggleIRQAct(PortAddr iop_base)
 {
 	AscSetChipStatus(iop_base, CIW_IRQ_ACT);
 	AscSetChipStatus(iop_base, 0);
 	return;
 }
 
-static uchar __init AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
+static uchar __devinit AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
 {
 	ushort cfg_lsw;
 	uchar chip_irq;
@@ -8381,7 +8321,7 @@ static uchar __init AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
 	return ((uchar)(chip_irq + ASC_MIN_IRQ_NO));
 }
 
-static uchar __init
+static uchar __devinit
 AscSetChipIRQ(PortAddr iop_base, uchar irq_no, ushort bus_type)
 {
 	ushort cfg_lsw;
@@ -8418,7 +8358,7 @@ AscSetChipIRQ(PortAddr iop_base, uchar irq_no, ushort bus_type)
 }
 
 #ifdef CONFIG_ISA
-static void __init AscEnableIsaDma(uchar dma_channel)
+static void __devinit AscEnableIsaDma(uchar dma_channel)
 {
 	if (dma_channel < 4) {
 		outp(0x000B, (ushort)(0xC0 | dma_channel));
@@ -10500,7 +10440,7 @@ static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
 	return (AscIsChipHalted(iop_base));
 }
 
-static ASC_DCNT __init AscGetMaxDmaCount(ushort bus_type)
+static ASC_DCNT __devinit AscGetMaxDmaCount(ushort bus_type)
 {
 	if (bus_type & ASC_IS_ISA)
 		return (ASC_MAX_ISA_DMA_COUNT);
@@ -10510,7 +10450,7 @@ static ASC_DCNT __init AscGetMaxDmaCount(ushort bus_type)
 }
 
 #ifdef CONFIG_ISA
-static ushort __init AscGetIsaDmaChannel(PortAddr iop_base)
+static ushort __devinit AscGetIsaDmaChannel(PortAddr iop_base)
 {
 	ushort channel;
 
@@ -10522,7 +10462,7 @@ static ushort __init AscGetIsaDmaChannel(PortAddr iop_base)
 	return (channel + 4);
 }
 
-static ushort __init AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
+static ushort __devinit AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
 {
 	ushort cfg_lsw;
 	uchar value;
@@ -10540,7 +10480,7 @@ static ushort __init AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
 	return (0);
 }
 
-static uchar __init AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
+static uchar __devinit AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
 {
 	speed_value &= 0x07;
 	AscSetBank(iop_base, 1);
@@ -10549,7 +10489,7 @@ static uchar __init AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
 	return (AscGetIsaDmaSpeed(iop_base));
 }
 
-static uchar __init AscGetIsaDmaSpeed(PortAddr iop_base)
+static uchar __devinit AscGetIsaDmaSpeed(PortAddr iop_base)
 {
 	uchar speed_value;
 
@@ -10561,7 +10501,7 @@ static uchar __init AscGetIsaDmaSpeed(PortAddr iop_base)
 }
 #endif /* CONFIG_ISA */
 
-static ushort __init
+static ushort __devinit
 AscReadPCIConfigWord(ASC_DVC_VAR *asc_dvc, ushort pci_config_offset)
 {
 	uchar lsb, msb;
@@ -10571,7 +10511,7 @@ AscReadPCIConfigWord(ASC_DVC_VAR *asc_dvc, ushort pci_config_offset)
 	return ((ushort)((msb << 8) | lsb));
 }
 
-static ushort __init AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
+static ushort __devinit AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 {
 	ushort warn_code;
 	PortAddr iop_base;
@@ -10656,7 +10596,7 @@ static ushort __init AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static ushort __init AscInitSetConfig(ASC_DVC_VAR *asc_dvc)
+static ushort __devinit AscInitSetConfig(ASC_DVC_VAR *asc_dvc)
 {
 	ushort warn_code = 0;
 
@@ -10672,7 +10612,7 @@ static ushort __init AscInitSetConfig(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static ushort __init AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
+static ushort __devinit AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
 {
 	PortAddr iop_base;
 	ushort cfg_msw;
@@ -10773,7 +10713,7 @@ static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static ushort __init AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
+static ushort __devinit AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 {
 	int i;
 	PortAddr iop_base;
@@ -10885,7 +10825,7 @@ static ushort __init AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static ushort __init AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
+static ushort __devinit AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 {
 	ASCEEP_CONFIG eep_config_buf;
 	ASCEEP_CONFIG *eep_config;
@@ -11106,7 +11046,7 @@ static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 	return (warn_code);
 }
 
-static int __init AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
+static int __devinit AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 {
 	PortAddr iop_base;
 	ushort q_addr;
@@ -11128,7 +11068,7 @@ static int __init AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 	return (sta);
 }
 
-static int __init AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
+static int __devinit AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
 {
 	uchar read_back;
 	int retry;
@@ -11147,7 +11087,7 @@ static int __init AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
 	}
 }
 
-static int __init AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
+static int __devinit AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 {
 	ushort read_back;
 	int retry;
@@ -11166,19 +11106,19 @@ static int __init AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 	}
 }
 
-static void __init AscWaitEEPRead(void)
+static void __devinit AscWaitEEPRead(void)
 {
 	DvcSleepMilliSecond(1);
 	return;
 }
 
-static void __init AscWaitEEPWrite(void)
+static void __devinit AscWaitEEPWrite(void)
 {
 	DvcSleepMilliSecond(20);
 	return;
 }
 
-static ushort __init AscReadEEPWord(PortAddr iop_base, uchar addr)
+static ushort __devinit AscReadEEPWord(PortAddr iop_base, uchar addr)
 {
 	ushort read_wval;
 	uchar cmd_reg;
@@ -11193,7 +11133,7 @@ static ushort __init AscReadEEPWord(PortAddr iop_base, uchar addr)
 	return (read_wval);
 }
 
-static ushort __init
+static ushort __devinit
 AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
 {
 	ushort read_wval;
@@ -11214,7 +11154,7 @@ AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
 	return (read_wval);
 }
 
-static ushort __init
+static ushort __devinit
 AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 {
 	ushort wval;
@@ -11261,7 +11201,7 @@ AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 	return (sum);
 }
 
-static int __init
+static int __devinit
 AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 {
 	int n_error;
@@ -11357,7 +11297,7 @@ AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 	return (n_error);
 }
 
-static int __init
+static int __devinit
 AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 {
 	int retry;
@@ -13769,7 +13709,7 @@ static ADV_DCNT _adv_asc38C1600_chksum = 0x0604EF77UL;	/* Expanded little-endian
  * on big-endian platforms so char fields read as words are actually being
  * unswapped on big-endian platforms.
  */
-static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __initdata = {
+static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __devinitdata = {
 	ADV_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
 	0x0000,			/* cfg_msw */
 	0xFFFF,			/* disc_enable */
@@ -13807,7 +13747,7 @@ static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __initdata = {
 	0			/* num_of_err */
 };
 
-static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __initdata = {
+static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __devinitdata = {
 	0,			/* cfg_lsw */
 	0,			/* cfg_msw */
 	0,			/* -disc_enable */
@@ -13845,7 +13785,7 @@ static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __initdata = {
 	0			/* num_of_err */
 };
 
-static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __initdata = {
+static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __devinitdata = {
 	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
 	0x0000,			/* 01 cfg_msw */
 	0xFFFF,			/* 02 disc_enable */
@@ -13910,7 +13850,7 @@ static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __initdata = {
 	0			/* 63 reserved */
 };
 
-static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __initdata = {
+static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __devinitdata = {
 	0,			/* 00 cfg_lsw */
 	0,			/* 01 cfg_msw */
 	0,			/* 02 disc_enable */
@@ -13975,7 +13915,7 @@ static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __initdata = {
 	0			/* 63 reserved */
 };
 
-static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __initdata = {
+static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __devinitdata = {
 	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
 	0x0000,			/* 01 cfg_msw */
 	0xFFFF,			/* 02 disc_enable */
@@ -14040,7 +13980,7 @@ static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __initdata = {
 	0			/* 63 reserved */
 };
 
-static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __initdata = {
+static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __devinitdata = {
 	0,			/* 00 cfg_lsw */
 	0,			/* 01 cfg_msw */
 	0,			/* 02 disc_enable */
@@ -14113,7 +14053,7 @@ static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __initdata = {
  * For a non-fatal error return a warning code. If there are no warnings
  * then 0 is returned.
  */
-static int __init AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
+static int __devinit AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
 {
 	ushort warn_code;
 	AdvPortAddr iop_base;
@@ -16057,7 +15997,7 @@ static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
  *
  * Note: Chip is stopped on entry.
  */
-static int __init AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
+static int __devinit AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
@@ -16211,7 +16151,7 @@ static int __init AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
  *
  * Note: Chip is stopped on entry.
  */
-static int __init AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
+static int __devinit AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
@@ -16414,7 +16354,7 @@ static int __init AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
  *
  * Note: Chip is stopped on entry.
  */
-static int __init AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
+static int __devinit AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 {
 	AdvPortAddr iop_base;
 	ushort warn_code;
@@ -16655,7 +16595,7 @@ static int __init AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-static ushort __init
+static ushort __devinit
 AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
 	ushort wval, chksum;
@@ -16698,7 +16638,7 @@ AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-static ushort __init
+static ushort __devinit
 AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 {
 	ushort wval, chksum;
@@ -16741,7 +16681,7 @@ AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-static ushort __init
+static ushort __devinit
 AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
 	ushort wval, chksum;
@@ -16782,7 +16722,7 @@ AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 /*
  * Read the EEPROM from specified location
  */
-static ushort __init AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
+static ushort __devinit AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
 {
 	AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
 			     ASC_EEP_CMD_READ | eep_word_addr);
@@ -16793,7 +16733,7 @@ static ushort __init AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
 /*
  * Wait for EEPROM command to complete
  */
-static void __init AdvWaitEEPCmd(AdvPortAddr iop_base)
+static void __devinit AdvWaitEEPCmd(AdvPortAddr iop_base)
 {
 	int eep_delay_ms;
 
@@ -16814,7 +16754,7 @@ static void __init AdvWaitEEPCmd(AdvPortAddr iop_base)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void __init
+void __devinit
 AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
@@ -16882,7 +16822,7 @@ AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void __init
+void __devinit
 AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
@@ -16950,7 +16890,7 @@ AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void __init
+void __devinit
 AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
 	ushort *wbuf;
@@ -17838,13 +17778,10 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	if (!shost)
 		return NULL;
 
-	/* Save a pointer to the Scsi_Host of each board found. */
-	asc_host[asc_board_count++] = shost;
-
 	/* Initialize private per board data */
 	boardp = ASC_BOARDP(shost);
 	memset(boardp, 0, sizeof(asc_board_t));
-	boardp->id = asc_board_count - 1;
+	boardp->id = asc_board_count++;
 
 	/* Initialize spinlock. */
 	spin_lock_init(&boardp->lock);
@@ -18518,7 +18455,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		iounmap(boardp->ioremap_addr);
  err_shost:
 	scsi_host_put(shost);
-	asc_board_count--;
 	return NULL;
 }
 
@@ -18540,27 +18476,11 @@ static int __init advansys_detect(void)
 	int iop;
 	int bus;
 	int ioport = 0;
-	struct device *dev = NULL;
-#ifdef CONFIG_PCI
-	int pci_init_search = 0;
-	struct pci_dev *pci_devicep[ASC_NUM_BOARD_SUPPORTED];
-	int pci_card_cnt_max = 0;
-	int pci_card_cnt = 0;
-	struct pci_dev *pdev = NULL;
-	int pci_device_id_cnt = 0;
-	unsigned int pci_device_id[ASC_PCI_DEVICE_ID_CNT] = {
-		PCI_DEVICE_ID_ASP_1200A,
-		PCI_DEVICE_ID_ASP_ABP940,
-		PCI_DEVICE_ID_ASP_ABP940U,
-		PCI_DEVICE_ID_ASP_ABP940UW,
-		PCI_DEVICE_ID_38C0800_REV1,
-		PCI_DEVICE_ID_38C1600_REV1
-	};
-#endif /* CONFIG_PCI */
+	struct Scsi_Host *shost;
 
 	ASC_DBG(1, "advansys_detect: begin\n");
 
-	asc_board_count = 0;
+	asc_legacy_count = 0;
 
 	/*
 	 * If I/O port probing has been modified, then verify and
@@ -18595,10 +18515,10 @@ static int __init advansys_detect(void)
 			 bus, asc_bus_name[bus]);
 		iop = 0;
 
-		while (asc_board_count < ASC_NUM_BOARD_SUPPORTED) {
+		while (asc_legacy_count < ASC_NUM_BOARD_SUPPORTED) {
 
-			ASC_DBG1(2, "advansys_detect: asc_board_count %d\n",
-				 asc_board_count);
+			ASC_DBG1(2, "advansys_detect: asc_legacy_count %d\n",
+				 asc_legacy_count);
 
 			switch (asc_bus[bus]) {
 			case ASC_IS_ISA:
@@ -18693,97 +18613,6 @@ static int __init advansys_detect(void)
 #endif /* CONFIG_ISA */
 				break;
 
-			case ASC_IS_PCI:
-#ifdef CONFIG_PCI
-				if (pci_init_search == 0) {
-					int i, j;
-
-					pci_init_search = 1;
-
-					/* Find all PCI cards. */
-					while (pci_device_id_cnt <
-					       ASC_PCI_DEVICE_ID_CNT) {
-						if ((pdev =
-						     pci_find_device
-						     (PCI_VENDOR_ID_ASP,
-						      pci_device_id
-						      [pci_device_id_cnt],
-						      pdev)) == NULL) {
-							pci_device_id_cnt++;
-						} else {
-							if (pci_enable_device
-							    (pdev) == 0) {
-								pci_devicep
-								    [pci_card_cnt_max++]
-								    = pdev;
-							}
-						}
-					}
-
-					/*
-					 * Sort PCI cards in ascending order by PCI Bus, Slot,
-					 * and Device Number.
-					 */
-					for (i = 0; i < pci_card_cnt_max - 1;
-					     i++) {
-						for (j = i + 1;
-						     j < pci_card_cnt_max;
-						     j++) {
-							if ((pci_devicep[j]->
-							     bus->number <
-							     pci_devicep[i]->
-							     bus->number)
-							    ||
-							    ((pci_devicep[j]->
-							      bus->number ==
-							      pci_devicep[i]->
-							      bus->number)
-							     &&
-							     (pci_devicep[j]->
-							      devfn <
-							      pci_devicep[i]->
-							      devfn))) {
-								pdev =
-								    pci_devicep
-								    [i];
-								pci_devicep[i] =
-								    pci_devicep
-								    [j];
-								pci_devicep[j] =
-								    pdev;
-							}
-						}
-					}
-
-					pci_card_cnt = 0;
-				} else {
-					pci_card_cnt++;
-				}
-
-				if (pci_card_cnt == pci_card_cnt_max) {
-					iop = 0;
-				} else {
-					pdev = pci_devicep[pci_card_cnt];
-
-					ASC_DBG2(2,
-						 "advansys_detect: devfn %d, bus number %d\n",
-						 pdev->devfn,
-						 pdev->bus->number);
-					iop = pci_resource_start(pdev, 0);
-					ASC_DBG2(1,
-						 "advansys_detect: vendorID %X, deviceID %X\n",
-						 pdev->vendor,
-						 pdev->device);
-					ASC_DBG2(2,
-						 "advansys_detect: iop %X, irqLine %d\n",
-						 iop, pdev->irq);
-				}
-				if (pdev)
-					dev = &pdev->dev;
-
-#endif /* CONFIG_PCI */
-				break;
-
 			default:
 				ASC_PRINT1
 				    ("advansys_detect: unknown bus type: %d\n",
@@ -18795,17 +18624,19 @@ static int __init advansys_detect(void)
 			/*
 			 * Adapter not found, try next bus type.
 			 */
-			if (iop == 0) {
+			if (iop == 0)
 				break;
-			}
 
-			advansys_board_found(iop, dev, asc_bus[bus]);
+			shost = advansys_board_found(iop, NULL, asc_bus[bus]);
+			if (shost) {
+				asc_host[asc_legacy_count++] = shost;
+			}
 		}
 	}
 
-	ASC_DBG1(1, "advansys_detect: done: asc_board_count %d\n",
-		 asc_board_count);
-	return asc_board_count;
+	ASC_DBG1(1, "advansys_detect: done: asc_legacy_count %d\n",
+		 asc_legacy_count);
+	return asc_legacy_count;
 }
 
 /*
@@ -18836,7 +18667,6 @@ static int advansys_release(struct Scsi_Host *shost)
 	return 0;
 }
 
-#ifdef CONFIG_PCI
 /* PCI Devices supported by this driver */
 static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
@@ -18855,23 +18685,73 @@ static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 };
 
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
-#endif /* CONFIG_PCI */
+
+static int __devinit
+advansys_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int err, ioport;
+	struct Scsi_Host *shost;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		goto fail;
+
+	if (pci_resource_len(pdev, 0) == 0)
+		goto nodev;
+
+	ioport = pci_resource_start(pdev, 0);
+	shost = advansys_board_found(ioport, &pdev->dev, ASC_IS_PCI);
+
+	if (!shost)
+		goto nodev;
+
+	pci_set_drvdata(pdev, shost);
+	return 0;
+
+ nodev:
+	err = -ENODEV;
+	pci_disable_device(pdev);
+ fail:
+	return err;
+}
+
+static void __devexit advansys_pci_remove(struct pci_dev *pdev)
+{
+	advansys_release(pci_get_drvdata(pdev));
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver advansys_pci_driver = {
+	.name =		"advansys",
+	.id_table =	advansys_pci_tbl,
+	.probe =	advansys_pci_probe,
+	.remove =	__devexit_p(advansys_pci_remove),
+};
 
 static int __init advansys_init(void)
 {
-	int count;
-	count = advansys_detect();
-	if (count == 0)
-		return -ENODEV;
+	int i, error;
+	advansys_detect();
+	error = pci_register_driver(&advansys_pci_driver);
+	if (error)
+		goto fail;
 
 	return 0;
+
+ fail:
+	for (i = 0; i < asc_legacy_count; i++)
+		advansys_release(asc_host[i]);
+
+	return error;
 }
 
 static void __exit advansys_exit(void)
 {
 	int i;
 
-	for (i = 0; i < asc_board_count; i++)
+	pci_unregister_driver(&advansys_pci_driver);
+
+	for (i = 0; i < asc_legacy_count; i++)
 		advansys_release(asc_host[i]);
 }
 

commit 8dfb537933a87588e83196d14cd9ec245eb065b8
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 09:08:34 2007 -0600

    [SCSI] advansys: Move to scsi hotplug initialisation model
    
     - Switch from scsi_register/scsi_unregister to scsi_host_alloc,
       scsi_add_host, scsi_scan_host and scsi_host_put.
     - Rename the scsi_host_template to advansys_template
     - Use module_init and module_exit instead of scsi_module.c
     - Remove protection against advansys_detect being called twice
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 303dc98b45c0..8353680b8682 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3793,7 +3793,7 @@ typedef struct adv_req {
 /*
  * Structure allocated for each board.
  *
- * This structure is allocated by scsi_register() at the end
+ * This structure is allocated by scsi_host_alloc() at the end
  * of the 'Scsi_Host' structure starting at the 'hostdata'
  * field. It is guaranteed to be allocated from DMA-able memory.
  */
@@ -4632,17 +4632,12 @@ advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 	return 0;
 }
 
-static int __init advansys_detect(struct scsi_host_template *tpnt);
-static int advansys_release(struct Scsi_Host *shp);
-
-static struct scsi_host_template driver_template = {
+static struct scsi_host_template advansys_template = {
 	.proc_name = "advansys",
 #ifdef CONFIG_PROC_FS
 	.proc_info = advansys_proc_info,
 #endif
 	.name = "advansys",
-	.detect = advansys_detect,
-	.release = advansys_release,
 	.info = advansys_info,
 	.queuecommand = advansys_queuecommand,
 	.eh_bus_reset_handler = advansys_reset,
@@ -4650,8 +4645,8 @@ static struct scsi_host_template driver_template = {
 	.slave_configure = advansys_slave_configure,
 	/*
 	 * Because the driver may control an ISA adapter 'unchecked_isa_dma'
-	 * must be set. The flag will be cleared in advansys_detect for non-ISA
-	 * adapters. Refer to the comment in scsi_module.c for more information.
+	 * must be set. The flag will be cleared in advansys_board_found
+	 * for non-ISA adapters.
 	 */
 	.unchecked_isa_dma = 1,
 	/*
@@ -4664,8 +4659,6 @@ static struct scsi_host_template driver_template = {
 	.use_clustering = ENABLE_CLUSTERING,
 };
 
-#include "scsi_module.c"
-
 /*
  * --- Miscellaneous Driver Functions
  */
@@ -17839,8 +17832,8 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	 * Register the adapter, get its configuration, and
 	 * initialize it.
 	 */
-	ASC_DBG(2, "advansys_board_found: scsi_register()\n");
-	shost = scsi_register(&driver_template, sizeof(asc_board_t));
+	ASC_DBG(2, "advansys_board_found: scsi_host_alloc()\n");
+	shost = scsi_host_alloc(&advansys_template, sizeof(asc_board_t));
 
 	if (!shost)
 		return NULL;
@@ -18503,6 +18496,11 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 
 	ASC_DBG_PRT_SCSI_HOST(2, shost);
 
+	ret = scsi_add_host(shost, dev);
+	if (ret)
+		goto err_free_wide_mem;
+
+	scsi_scan_host(shost);
 	return shost;
 
  err_free_wide_mem:
@@ -18519,7 +18517,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	if (boardp->ioremap_addr)
 		iounmap(boardp->ioremap_addr);
  err_shost:
-	scsi_unregister(shost);
+	scsi_host_put(shost);
 	asc_board_count--;
 	return NULL;
 }
@@ -18537,9 +18535,8 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
  * it must not call SCSI mid-level functions including scsi_malloc()
  * and scsi_free().
  */
-static int __init advansys_detect(struct scsi_host_template *tpnt)
+static int __init advansys_detect(void)
 {
-	static int detect_called = ASC_FALSE;
 	int iop;
 	int bus;
 	int ioport = 0;
@@ -18561,14 +18558,6 @@ static int __init advansys_detect(struct scsi_host_template *tpnt)
 	};
 #endif /* CONFIG_PCI */
 
-	if (detect_called == ASC_FALSE) {
-		detect_called = ASC_TRUE;
-	} else {
-		printk
-		    ("AdvanSys SCSI: advansys_detect() multiple calls ignored\n");
-		return 0;
-	}
-
 	ASC_DBG(1, "advansys_detect: begin\n");
 
 	asc_board_count = 0;
@@ -18829,6 +18818,7 @@ static int advansys_release(struct Scsi_Host *shost)
 	asc_board_t *boardp;
 
 	ASC_DBG(1, "advansys_release: begin\n");
+	scsi_remove_host(shost);
 	boardp = ASC_BOARDP(shost);
 	free_irq(shost->irq, shost);
 	if (shost->dma_channel != NO_ISA_DMA) {
@@ -18841,7 +18831,7 @@ static int advansys_release(struct Scsi_Host *shost)
 		advansys_wide_free_mem(boardp);
 	}
 	kfree(boardp->prtbuf);
-	scsi_unregister(shost);
+	scsi_host_put(shost);
 	ASC_DBG(1, "advansys_release: end\n");
 	return 0;
 }
@@ -18867,4 +18857,25 @@ static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
 #endif /* CONFIG_PCI */
 
+static int __init advansys_init(void)
+{
+	int count;
+	count = advansys_detect();
+	if (count == 0)
+		return -ENODEV;
+
+	return 0;
+}
+
+static void __exit advansys_exit(void)
+{
+	int i;
+
+	for (i = 0; i < asc_board_count; i++)
+		advansys_release(asc_host[i]);
+}
+
+module_init(advansys_init);
+module_exit(advansys_exit);
+
 MODULE_LICENSE("GPL");

commit b2c16f586ee529e97ac63183e70e2bfd586a2f47
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Jul 29 17:30:28 2007 -0600

    [SCSI] advansys: Make advansys_board_found a little more readable
    
     - Put all the error cleanup at the end of the function and goto the
       appropriate label
     - Split advansys_wide_init_chip out of advansys_board_found
     - Split advansys_wide_free_mem out of advansys_board_found.  Use it
       from advansys_release
     - Use GFP_KERNEL, not GFP_ATOMIC, when allocating memory during
       initialisation
     - Eliminate lots of PROC_FS ifdefs by removing the ifdefs around the prtbuf
       struct member
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 7a964bb75acb..303dc98b45c0 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3825,10 +3825,8 @@ typedef struct asc_board {
 	} eep_config;
 	ulong last_reset;	/* Saved last reset time */
 	spinlock_t lock;	/* Board spinlock */
-#ifdef CONFIG_PROC_FS
 	/* /proc/scsi/advansys/[0...] */
 	char *prtbuf;		/* /proc print buffer */
-#endif				/* CONFIG_PROC_FS */
 #ifdef ADVANSYS_STATS
 	struct asc_stats asc_stats;	/* Board statistics */
 #endif				/* ADVANSYS_STATS */
@@ -3845,7 +3843,7 @@ typedef struct asc_board {
 	 */
 	void __iomem *ioremap_addr;	/* I/O Memory remap address. */
 	ushort ioport;		/* I/O Port address. */
-	ADV_CARR_T *orig_carrp;	/* ADV_CARR_T memory block. */
+	ADV_CARR_T *carrp;	/* ADV_CARR_T memory block. */
 	adv_req_t *orig_reqp;	/* adv_req_t memory block. */
 	adv_req_t *adv_reqp;	/* Request structures. */
 	adv_sgblk_t *adv_sgblkp;	/* Scatter-gather structures. */
@@ -17703,6 +17701,124 @@ static void AdvInquiryHandling(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	}
 }
 
+static int __devinit
+advansys_wide_init_chip(asc_board_t *boardp, ADV_DVC_VAR *adv_dvc_varp)
+{
+	int req_cnt = 0;
+	adv_req_t *reqp = NULL;
+	int sg_cnt = 0;
+	adv_sgblk_t *sgp;
+	int warn_code, err_code;
+
+	/*
+	 * Allocate buffer carrier structures. The total size
+	 * is about 4 KB, so allocate all at once.
+	 */
+	boardp->carrp = kmalloc(ADV_CARRIER_BUFSIZE, GFP_KERNEL);
+	ASC_DBG1(1, "advansys_wide_init_chip: carrp 0x%p\n", boardp->carrp);
+
+	if (!boardp->carrp)
+		goto kmalloc_failed;
+
+	/*
+	 * Allocate up to 'max_host_qng' request structures for the Wide
+	 * board. The total size is about 16 KB, so allocate all at once.
+	 * If the allocation fails decrement and try again.
+	 */
+	for (req_cnt = adv_dvc_varp->max_host_qng; req_cnt > 0; req_cnt--) {
+		reqp = kmalloc(sizeof(adv_req_t) * req_cnt, GFP_KERNEL);
+
+		ASC_DBG3(1, "advansys_wide_init_chip: reqp 0x%p, req_cnt %d, "
+			 "bytes %lu\n", reqp, req_cnt,
+			 (ulong)sizeof(adv_req_t) * req_cnt);
+
+		if (reqp)
+			break;
+	}
+
+	if (!reqp)
+		goto kmalloc_failed;
+
+	boardp->orig_reqp = reqp;
+
+	/*
+	 * Allocate up to ADV_TOT_SG_BLOCK request structures for
+	 * the Wide board. Each structure is about 136 bytes.
+	 */
+	boardp->adv_sgblkp = NULL;
+	for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
+		sgp = kmalloc(sizeof(adv_sgblk_t), GFP_KERNEL);
+
+		if (!sgp)
+			break;
+
+		sgp->next_sgblkp = boardp->adv_sgblkp;
+		boardp->adv_sgblkp = sgp;
+
+	}
+
+	ASC_DBG3(1, "advansys_wide_init_chip: sg_cnt %d * %u = %u bytes\n",
+		 sg_cnt, sizeof(adv_sgblk_t),
+		 (unsigned)(sizeof(adv_sgblk_t) * sg_cnt));
+
+	if (!boardp->adv_sgblkp)
+		goto kmalloc_failed;
+
+	adv_dvc_varp->carrier_buf = boardp->carrp;
+
+	/*
+	 * Point 'adv_reqp' to the request structures and
+	 * link them together.
+	 */
+	req_cnt--;
+	reqp[req_cnt].next_reqp = NULL;
+	for (; req_cnt > 0; req_cnt--) {
+		reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
+	}
+	boardp->adv_reqp = &reqp[0];
+
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		ASC_DBG(2, "advansys_wide_init_chip: AdvInitAsc3550Driver()\n");
+		warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		ASC_DBG(2, "advansys_wide_init_chip: AdvInitAsc38C0800Driver()"
+			   "\n");
+		warn_code = AdvInitAsc38C0800Driver(adv_dvc_varp);
+	} else {
+		ASC_DBG(2, "advansys_wide_init_chip: AdvInitAsc38C1600Driver()"
+			   "\n");
+		warn_code = AdvInitAsc38C1600Driver(adv_dvc_varp);
+	}
+	err_code = adv_dvc_varp->err_code;
+
+	if (warn_code || err_code) {
+		ASC_PRINT3("advansys_wide_init_chip: board %d error: warn 0x%x,"
+			   " error 0x%x\n", boardp->id, warn_code, err_code);
+	}
+
+	goto exit;
+
+ kmalloc_failed:
+	ASC_PRINT1("advansys_wide_init_chip: board %d error: kmalloc() "
+		   "failed\n", boardp->id);
+	err_code = ADV_ERROR;
+ exit:
+	return err_code;
+}
+
+static void advansys_wide_free_mem(asc_board_t *boardp)
+{
+	kfree(boardp->carrp);
+	boardp->carrp = NULL;
+	kfree(boardp->orig_reqp);
+	boardp->orig_reqp = boardp->adv_reqp = NULL;
+	while (boardp->adv_sgblkp) {
+		adv_sgblk_t *sgp = boardp->adv_sgblkp;
+		boardp->adv_sgblkp = sgp->next_sgblkp;
+		kfree(sgp);
+	}
+}
+
 static struct Scsi_Host *__devinit
 advansys_board_found(int iop, struct device *dev, int bus_type)
 {
@@ -17711,7 +17827,6 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	asc_board_t *boardp;
 	ASC_DVC_VAR *asc_dvc_varp = NULL;
 	ADV_DVC_VAR *adv_dvc_varp = NULL;
-	adv_sgblk_t *sgp = NULL;
 	int share_irq;
 	int iolen = 0;
 	ADV_PADDR pci_memory_address;
@@ -17814,9 +17929,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			ASC_PRINT3
 			    ("advansys_board_found: board %d: ioremap(%x, %d) returned NULL\n",
 			     boardp->id, pci_memory_address, iolen);
-			scsi_unregister(shost);
-			asc_board_count--;
-			return NULL;
+			goto err_shost;
 		}
 		ASC_DBG1(1,
 			 "advansys_board_found: ioremap_addr: 0x%lx\n",
@@ -17846,13 +17959,11 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	 * Allocate buffer for printing information from
 	 * /proc/scsi/advansys/[0...].
 	 */
-	if ((boardp->prtbuf = kmalloc(ASC_PRTBUF_SIZE, GFP_ATOMIC)) == NULL) {
-		ASC_PRINT3
-		    ("advansys_board_found: board %d: kmalloc(%d, %d) returned NULL\n",
-		     boardp->id, ASC_PRTBUF_SIZE, GFP_ATOMIC);
-		scsi_unregister(shost);
-		asc_board_count--;
-		return NULL;
+	boardp->prtbuf = kmalloc(ASC_PRTBUF_SIZE, GFP_KERNEL);
+	if (!boardp->prtbuf) {
+		ASC_PRINT2("advansys_board_found: board %d: kmalloc(%d) "
+			   "returned NULL\n", boardp->id, ASC_PRTBUF_SIZE);
+		goto err_unmap;
 	}
 #endif /* CONFIG_PROC_FS */
 
@@ -17978,14 +18089,8 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		}
 	}
 
-	if (err_code != 0) {
-#ifdef CONFIG_PROC_FS
-		kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-		scsi_unregister(shost);
-		asc_board_count--;
-		return NULL;
-	}
+	if (err_code != 0)
+		goto err_free_proc;
 
 	/*
 	 * Save the EEPROM configuration so that it can be displayed
@@ -18067,12 +18172,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			    ("AscInitSetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
 			     boardp->id,
 			     asc_dvc_varp->init_state, asc_dvc_varp->err_code);
-#ifdef CONFIG_PROC_FS
-			kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-			scsi_unregister(shost);
-			asc_board_count--;
-			return NULL;
+			goto err_free_proc;
 		}
 
 		/*
@@ -18276,10 +18376,8 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 
 	/* BIOS start address. */
 	if (ASC_NARROW_BOARD(boardp)) {
-		shost->base = ((ulong)
-			     AscGetChipBiosAddress(asc_dvc_varp->
-						   iop_base,
-						   asc_dvc_varp->bus_type));
+		shost->base = AscGetChipBiosAddress(asc_dvc_varp->iop_base,
+						    asc_dvc_varp->bus_type);
 	} else {
 		/*
 		 * Fill-in BIOS board variables. The Wide BIOS saves
@@ -18337,12 +18435,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		ASC_PRINT3
 		    ("advansys_board_found: board %d: request_region() failed, port 0x%lx, len 0x%x\n",
 		     boardp->id, (ulong)shost->io_port, boardp->asc_n_io_port);
-#ifdef CONFIG_PROC_FS
-		kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-		scsi_unregister(shost);
-		asc_board_count--;
-		return NULL;
+		goto err_free_proc;
 	}
 
 	/* Register DMA Channel for Narrow boards. */
@@ -18352,19 +18445,12 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 		/* Register DMA channel for ISA bus. */
 		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
 			shost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
-			if ((ret =
-			     request_dma(shost->dma_channel, "advansys")) != 0) {
+			ret = request_dma(shost->dma_channel, "advansys");
+			if (ret) {
 				ASC_PRINT3
 				    ("advansys_board_found: board %d: request_dma() %d failed %d\n",
 				     boardp->id, shost->dma_channel, ret);
-				release_region(shost->io_port,
-					       boardp->asc_n_io_port);
-#ifdef CONFIG_PROC_FS
-				kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-				scsi_unregister(shost);
-				asc_board_count--;
-				return NULL;
+				goto err_free_region;
 			}
 			AscEnableIsaDma(shost->dma_channel);
 		}
@@ -18391,17 +18477,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x failed with %d\n",
 			     boardp->id, shost->irq, ret);
 		}
-		release_region(shost->io_port, boardp->asc_n_io_port);
-		iounmap(boardp->ioremap_addr);
-		if (shost->dma_channel != NO_ISA_DMA) {
-			free_dma(shost->dma_channel);
-		}
-#ifdef CONFIG_PROC_FS
-		kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-		scsi_unregister(shost);
-		asc_board_count--;
-		return NULL;
+		goto err_free_dma;
 	}
 
 	/*
@@ -18419,173 +18495,33 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			     asc_dvc_varp->init_state, warn_code, err_code);
 		}
 	} else {
-		ADV_CARR_T *carrp;
-		int req_cnt = 0;
-		adv_req_t *reqp = NULL;
-		int sg_cnt = 0;
-
-		/*
-		 * Allocate buffer carrier structures. The total size
-		 * is about 4 KB, so allocate all at once.
-		 */
-		carrp = (ADV_CARR_T *) kmalloc(ADV_CARRIER_BUFSIZE, GFP_ATOMIC);
-		ASC_DBG1(1, "advansys_board_found: carrp 0x%lx\n", (ulong)carrp);
-
-		if (carrp == NULL) {
-			goto kmalloc_error;
-		}
-
-		/*
-		 * Allocate up to 'max_host_qng' request structures for
-		 * the Wide board. The total size is about 16 KB, so
-		 * allocate all at once. If the allocation fails decrement
-		 * and try again.
-		 */
-		for (req_cnt = adv_dvc_varp->max_host_qng;
-		     req_cnt > 0; req_cnt--) {
-
-			reqp = (adv_req_t *)
-			    kmalloc(sizeof(adv_req_t) * req_cnt, GFP_ATOMIC);
-
-			ASC_DBG3(1,
-				 "advansys_board_found: reqp 0x%lx, req_cnt %d, bytes %lu\n",
-				 (ulong)reqp, req_cnt,
-				 (ulong)sizeof(adv_req_t) * req_cnt);
-
-			if (reqp != NULL) {
-				break;
-			}
-		}
-		if (reqp == NULL) {
-			goto kmalloc_error;
-		}
-
-		/*
-		 * Allocate up to ADV_TOT_SG_BLOCK request structures for
-		 * the Wide board. Each structure is about 136 bytes.
-		 */
-		boardp->adv_sgblkp = NULL;
-		for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
-
-			sgp = (adv_sgblk_t *)
-			    kmalloc(sizeof(adv_sgblk_t), GFP_ATOMIC);
-
-			if (sgp == NULL) {
-				break;
-			}
-
-			sgp->next_sgblkp = boardp->adv_sgblkp;
-			boardp->adv_sgblkp = sgp;
-
-		}
-		ASC_DBG3(1,
-			 "advansys_board_found: sg_cnt %d * %u = %u bytes\n",
-			 sg_cnt, sizeof(adv_sgblk_t),
-			 (unsigned)(sizeof(adv_sgblk_t) * sg_cnt));
-
-		/*
-		 * If no request structures or scatter-gather structures could
-		 * be allocated, then return an error. Otherwise continue with
-		 * initialization.
-		 */
- kmalloc_error:
-		if (carrp == NULL) {
-			ASC_PRINT1
-			    ("advansys_board_found: board %d error: failed to kmalloc() carrier buffer.\n",
-			     boardp->id);
-			err_code = ADV_ERROR;
-		} else if (reqp == NULL) {
-			kfree(carrp);
-			ASC_PRINT1
-			    ("advansys_board_found: board %d error: failed to kmalloc() adv_req_t buffer.\n",
-			     boardp->id);
-			err_code = ADV_ERROR;
-		} else if (boardp->adv_sgblkp == NULL) {
-			kfree(carrp);
-			kfree(reqp);
-			ASC_PRINT1
-			    ("advansys_board_found: board %d error: failed to kmalloc() adv_sgblk_t buffers.\n",
-			     boardp->id);
-			err_code = ADV_ERROR;
-		} else {
-
-			/* Save carrier buffer pointer. */
-			boardp->orig_carrp = carrp;
-
-			/*
-			 * Save original pointer for kfree() in case the
-			 * driver is built as a module and can be unloaded.
-			 */
-			boardp->orig_reqp = reqp;
-
-			adv_dvc_varp->carrier_buf = carrp;
-
-			/*
-			 * Point 'adv_reqp' to the request structures and
-			 * link them together.
-			 */
-			req_cnt--;
-			reqp[req_cnt].next_reqp = NULL;
-			for (; req_cnt > 0; req_cnt--) {
-				reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
-			}
-			boardp->adv_reqp = &reqp[0];
-
-			if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
-				ASC_DBG(2,
-					"advansys_board_found: AdvInitAsc3550Driver()\n");
-				warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
-			} else if (adv_dvc_varp->chip_type ==
-				   ADV_CHIP_ASC38C0800) {
-				ASC_DBG(2,
-					"advansys_board_found: AdvInitAsc38C0800Driver()\n");
-				warn_code =
-				    AdvInitAsc38C0800Driver(adv_dvc_varp);
-			} else {
-				ASC_DBG(2,
-					"advansys_board_found: AdvInitAsc38C1600Driver()\n");
-				warn_code =
-				    AdvInitAsc38C1600Driver(adv_dvc_varp);
-			}
-			err_code = adv_dvc_varp->err_code;
-
-			if (warn_code || err_code) {
-				ASC_PRINT3
-				    ("advansys_board_found: board %d error: warn 0x%x, error 0x%x\n",
-				     boardp->id, warn_code, err_code);
-			}
-		}
+		err_code = advansys_wide_init_chip(boardp, adv_dvc_varp);
 	}
 
-	if (err_code != 0) {
-		release_region(shost->io_port, boardp->asc_n_io_port);
-		if (ASC_WIDE_BOARD(boardp)) {
-			iounmap(boardp->ioremap_addr);
-			kfree(boardp->orig_carrp);
-			boardp->orig_carrp = NULL;
-			if (boardp->orig_reqp) {
-				kfree(boardp->orig_reqp);
-				boardp->orig_reqp = boardp->adv_reqp = NULL;
-			}
-			while ((sgp = boardp->adv_sgblkp) != NULL) {
-				boardp->adv_sgblkp = sgp->next_sgblkp;
-				kfree(sgp);
-			}
-		}
-		if (shost->dma_channel != NO_ISA_DMA) {
-			free_dma(shost->dma_channel);
-		}
-#ifdef CONFIG_PROC_FS
-		kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-		free_irq(shost->irq, shost);
-		scsi_unregister(shost);
-		asc_board_count--;
-		return NULL;
-	}
+	if (err_code != 0)
+		goto err_free_wide_mem;
+
 	ASC_DBG_PRT_SCSI_HOST(2, shost);
 
 	return shost;
+
+ err_free_wide_mem:
+	advansys_wide_free_mem(boardp);
+	free_irq(shost->irq, shost);
+ err_free_dma:
+	if (shost->dma_channel != NO_ISA_DMA)
+		free_dma(shost->dma_channel);
+ err_free_region:
+	release_region(shost->io_port, boardp->asc_n_io_port);
+ err_free_proc:
+	kfree(boardp->prtbuf);
+ err_unmap:
+	if (boardp->ioremap_addr)
+		iounmap(boardp->ioremap_addr);
+ err_shost:
+	scsi_unregister(shost);
+	asc_board_count--;
+	return NULL;
 }
 
 /*
@@ -18901,24 +18837,10 @@ static int advansys_release(struct Scsi_Host *shost)
 	}
 	release_region(shost->io_port, boardp->asc_n_io_port);
 	if (ASC_WIDE_BOARD(boardp)) {
-		adv_sgblk_t *sgp = NULL;
-
 		iounmap(boardp->ioremap_addr);
-		kfree(boardp->orig_carrp);
-		boardp->orig_carrp = NULL;
-		if (boardp->orig_reqp) {
-			kfree(boardp->orig_reqp);
-			boardp->orig_reqp = boardp->adv_reqp = NULL;
-		}
-		while ((sgp = boardp->adv_sgblkp) != NULL) {
-			boardp->adv_sgblkp = sgp->next_sgblkp;
-			kfree(sgp);
-		}
+		advansys_wide_free_mem(boardp);
 	}
-#ifdef CONFIG_PROC_FS
-	ASC_ASSERT(boardp->prtbuf != NULL);
 	kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
 	scsi_unregister(shost);
 	ASC_DBG(1, "advansys_release: end\n");
 	return 0;

commit 605fe5987f728e92e75ba12f7be01ffc3b132ad0
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Jul 29 17:27:20 2007 -0600

    [SCSI] advansys: Stop checking the scsi_cmnd belongs to our Scsi_Host
    
    The interrupt routines used to walk the list of Scsi_Hosts belonging to
    this driver to make sure that the scsi_cmnd belonged to one of them.
    This is a waste of time and gets in the way of later cleanups, so
    delete it.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index a407ff34199d..7a964bb75acb 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -5506,7 +5506,6 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	asc_board_t *boardp;
 	struct scsi_cmnd *scp;
 	struct Scsi_Host *shost;
-	int i;
 
 	ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
 		 (ulong)asc_dvc_varp, (ulong)qdonep);
@@ -5525,23 +5524,7 @@ static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 	}
 	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
 
-	/*
-	 * If the request's host pointer is not valid, display a
-	 * message and return.
-	 */
 	shost = scp->device->host;
-	for (i = 0; i < asc_board_count; i++) {
-		if (asc_host[i] == shost) {
-			break;
-		}
-	}
-	if (i == asc_board_count) {
-		ASC_PRINT2
-		    ("asc_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
-		     (ulong)scp, (ulong)shost);
-		return;
-	}
-
 	ASC_STATS(shost, callback);
 	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
 
@@ -5680,7 +5663,6 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	adv_sgblk_t *sgblkp;
 	struct scsi_cmnd *scp;
 	struct Scsi_Host *shost;
-	int i;
 	ADV_DCNT resid_cnt;
 
 	ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
@@ -5716,27 +5698,7 @@ static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 	}
 	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
 
-	/*
-	 * If the request's host pointer is not valid, display a message
-	 * and return.
-	 */
 	shost = scp->device->host;
-	for (i = 0; i < asc_board_count; i++) {
-		if (asc_host[i] == shost) {
-			break;
-		}
-	}
-	/*
-	 * Note: If the host structure is not found, the adv_req_t request
-	 * structure and adv_sgblk_t structure, if any, is dropped.
-	 */
-	if (i == asc_board_count) {
-		ASC_PRINT2
-		    ("adv_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
-		     (ulong)scp, (ulong)shost);
-		return;
-	}
-
 	ASC_STATS(shost, callback);
 	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
 

commit 074c8fe4c0c0c7918d99bca34ea8e02a86997530
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sat Jul 28 23:11:05 2007 -0600

    [SCSI] advansys: Improve interrupt handler
    
    Pass the Scsi_Host to the interrupt handler, rather than polling all
    hosts for each interrupt.
    Return IRQ_NONE if we didn't handle this interrupt
    Don't set the IRQF_DISABLED flag; this is not a fast-executing interrupt
    handler.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 6d11076bbd02..a407ff34199d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3951,7 +3951,6 @@ static PortAddr _asc_def_iop_base[];
  * advansys.h contains function prototypes for functions global to Linux.
  */
 
-static irqreturn_t advansys_interrupt(int, void *);
 static int advansys_slave_configure(struct scsi_device *);
 static void asc_scsi_done_list(struct scsi_cmnd *);
 static int asc_execute_scsi_cmnd(struct scsi_cmnd *);
@@ -4684,89 +4683,76 @@ static struct scsi_host_template driver_template = {
  */
 static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 {
-	ulong flags;
-	int i;
-	asc_board_t *boardp;
+	unsigned long flags;
 	struct scsi_cmnd *done_scp = NULL, *last_scp = NULL;
 	struct scsi_cmnd *new_last_scp;
-	struct Scsi_Host *shost;
+	struct Scsi_Host *shost = dev_id;
+	asc_board_t *boardp = ASC_BOARDP(shost);
+	irqreturn_t result = IRQ_NONE;
 
-	ASC_DBG(1, "advansys_interrupt: begin\n");
+	ASC_DBG1(2, "advansys_interrupt: boardp 0x%p\n", boardp);
+	spin_lock_irqsave(&boardp->lock, flags);
+	if (ASC_NARROW_BOARD(boardp)) {
+		/*
+		 * Narrow Board
+		 */
+		if (AscIsIntPending(shost->io_port)) {
+			result = IRQ_HANDLED;
+			ASC_STATS(shost, interrupt);
+			ASC_DBG(1, "advansys_interrupt: before AscISR()\n");
+			AscISR(&boardp->dvc_var.asc_dvc_var);
+		}
+	} else {
+		/*
+		 * Wide Board
+		 */
+		ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
+		if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
+			result = IRQ_HANDLED;
+			ASC_STATS(shost, interrupt);
+		}
+	}
 
 	/*
-	 * Check for interrupts on all boards.
-	 * AscISR() will call asc_isr_callback().
-	 */
-	for (i = 0; i < asc_board_count; i++) {
-		shost = asc_host[i];
-		boardp = ASC_BOARDP(shost);
-		ASC_DBG2(2, "advansys_interrupt: i %d, boardp 0x%lx\n",
-			 i, (ulong)boardp);
-		spin_lock_irqsave(&boardp->lock, flags);
-		if (ASC_NARROW_BOARD(boardp)) {
-			/*
-			 * Narrow Board
-			 */
-			if (AscIsIntPending(shost->io_port)) {
-				ASC_STATS(shost, interrupt);
-				ASC_DBG(1,
-					"advansys_interrupt: before AscISR()\n");
-				AscISR(&boardp->dvc_var.asc_dvc_var);
-			}
-		} else {
-			/*
-			 * Wide Board
-			 */
-			ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
-			if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
-				ASC_STATS(shost, interrupt);
-			}
+	 * Start waiting requests and create a list of completed requests.
+	 *
+	 * If a reset request is being performed for the board, the reset
+	 * handler will complete pending requests after it has completed.
+	 */
+	if ((boardp->flags & ASC_HOST_IN_RESET) == 0) {
+		ASC_DBG2(1, "advansys_interrupt: done_scp 0x%p, "
+			 "last_scp 0x%p\n", done_scp, last_scp);
+
+		/* Start any waiting commands for the board. */
+		if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
+			ASC_DBG(1, "advansys_interrupt: before "
+				"asc_execute_queue()\n");
+			asc_execute_queue(&boardp->waiting);
 		}
 
 		/*
-		 * Start waiting requests and create a list of completed requests.
+		 * Add to the list of requests that must be completed.
 		 *
-		 * If a reset request is being performed for the board, the reset
-		 * handler will complete pending requests after it has completed.
+		 * 'done_scp' will always be NULL on the first iteration of
+		 * this loop. 'last_scp' is set at the same time as 'done_scp'.
 		 */
-		if ((boardp->flags & ASC_HOST_IN_RESET) == 0) {
-			ASC_DBG2(1,
-				 "advansys_interrupt: done_scp 0x%lx, last_scp 0x%lx\n",
-				 (ulong)done_scp, (ulong)last_scp);
-
-			/* Start any waiting commands for the board. */
-			if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
-				ASC_DBG(1,
-					"advansys_interrupt: before asc_execute_queue()\n");
-				asc_execute_queue(&boardp->waiting);
-			}
-
-			/*
-			 * Add to the list of requests that must be completed.
-			 *
-			 * 'done_scp' will always be NULL on the first iteration
-			 * of this loop. 'last_scp' is set at the same time as
-			 * 'done_scp'.
-			 */
-			if (done_scp == NULL) {
-				done_scp =
-				    asc_dequeue_list(&boardp->done, &last_scp,
-						     ASC_TID_ALL);
-			} else {
-				ASC_ASSERT(last_scp != NULL);
-				last_scp->host_scribble =
-				    (unsigned char *)asc_dequeue_list(&boardp->
-								      done,
-								      &new_last_scp,
-								      ASC_TID_ALL);
-				if (new_last_scp != NULL) {
-					ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-					last_scp = new_last_scp;
-				}
+		if (done_scp == NULL) {
+			done_scp = asc_dequeue_list(&boardp->done,
+						&last_scp, ASC_TID_ALL);
+		} else {
+			ASC_ASSERT(last_scp != NULL);
+			last_scp->host_scribble =
+			    (unsigned char *)asc_dequeue_list(&boardp->
+							      done,
+							      &new_last_scp,
+							      ASC_TID_ALL);
+			if (new_last_scp != NULL) {
+				ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+				last_scp = new_last_scp;
 			}
 		}
-		spin_unlock_irqrestore(&boardp->lock, flags);
 	}
+	spin_unlock_irqrestore(&boardp->lock, flags);
 
 	/*
 	 * If interrupts were enabled on entry, then they
@@ -4778,7 +4764,7 @@ static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 	asc_scsi_done_list(done_scp);
 
 	ASC_DBG(1, "advansys_interrupt: end\n");
-	return IRQ_HANDLED;
+	return result;
 }
 
 /*
@@ -17764,7 +17750,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 	ASC_DVC_VAR *asc_dvc_varp = NULL;
 	ADV_DVC_VAR *adv_dvc_varp = NULL;
 	adv_sgblk_t *sgp = NULL;
-	int share_irq = FALSE;
+	int share_irq;
 	int iolen = 0;
 	ADV_PADDR pci_memory_address;
 	int warn_code, err_code;
@@ -17918,15 +17904,15 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 #ifdef CONFIG_ISA
 		case ASC_IS_ISA:
 			shost->unchecked_isa_dma = TRUE;
-			share_irq = FALSE;
+			share_irq = 0;
 			break;
 		case ASC_IS_VL:
 			shost->unchecked_isa_dma = FALSE;
-			share_irq = FALSE;
+			share_irq = 0;
 			break;
 		case ASC_IS_EISA:
 			shost->unchecked_isa_dma = FALSE;
-			share_irq = TRUE;
+			share_irq = IRQF_SHARED;
 			break;
 #endif /* CONFIG_ISA */
 #ifdef CONFIG_PCI
@@ -17937,7 +17923,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 					 PCI_SLOT(pdev->devfn),
 					 PCI_FUNC(pdev->devfn));
 			shost->unchecked_isa_dma = FALSE;
-			share_irq = TRUE;
+			share_irq = IRQF_SHARED;
 			break;
 #endif /* CONFIG_PCI */
 		default:
@@ -17945,7 +17931,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 			    ("advansys_board_found: board %d: unknown adapter type: %d\n",
 			     boardp->id, asc_dvc_varp->bus_type);
 			shost->unchecked_isa_dma = TRUE;
-			share_irq = FALSE;
+			share_irq = 0;
 			break;
 		}
 	} else {
@@ -17961,7 +17947,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 				 PCI_SLOT(pdev->devfn),
 				 PCI_FUNC(pdev->devfn));
 		shost->unchecked_isa_dma = FALSE;
-		share_irq = TRUE;
+		share_irq = IRQF_SHARED;
 #endif /* CONFIG_PCI */
 	}
 
@@ -18425,25 +18411,11 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 
 	/* Register IRQ Number. */
 	ASC_DBG1(2, "advansys_board_found: request_irq() %d\n", shost->irq);
-	/*
-	 * If request_irq() fails with the IRQF_DISABLED flag set,
-	 * then try again without the IRQF_DISABLED flag set. This
-	 * allows IRQ sharing to work even with other drivers that
-	 * do not set the IRQF_DISABLED flag.
-	 *
-	 * If IRQF_DISABLED is not set, then interrupts are enabled
-	 * before the driver interrupt function is called.
-	 */
-	if (((ret = request_irq(shost->irq, advansys_interrupt,
-				IRQF_DISABLED | (share_irq ==
-						 TRUE ?
-						 IRQF_SHARED :
-						 0), "advansys", boardp)) != 0)
-	    &&
-	    ((ret =
-	      request_irq(shost->irq, advansys_interrupt,
-			  (share_irq == TRUE ? IRQF_SHARED : 0),
-			  "advansys", boardp)) != 0)) {
+
+	ret = request_irq(shost->irq, advansys_interrupt, share_irq,
+			  "advansys", shost);
+
+	if (ret) {
 		if (ret == -EBUSY) {
 			ASC_PRINT2
 			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x already in use.\n",
@@ -18644,7 +18616,7 @@ advansys_board_found(int iop, struct device *dev, int bus_type)
 #ifdef CONFIG_PROC_FS
 		kfree(boardp->prtbuf);
 #endif /* CONFIG_PROC_FS */
-		free_irq(shost->irq, boardp);
+		free_irq(shost->irq, shost);
 		scsi_unregister(shost);
 		asc_board_count--;
 		return NULL;
@@ -18960,7 +18932,7 @@ static int advansys_release(struct Scsi_Host *shost)
 
 	ASC_DBG(1, "advansys_release: begin\n");
 	boardp = ASC_BOARDP(shost);
-	free_irq(shost->irq, boardp);
+	free_irq(shost->irq, shost);
 	if (shost->dma_channel != NO_ISA_DMA) {
 		ASC_DBG(1, "advansys_release: free_dma()\n");
 		free_dma(shost->dma_channel);

commit 2a437959e963d98e04dbbcd26b69bfb1985567ce
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:00:51 2007 -0400

    [SCSI] advansys: Clean up proc_info implementation
    
    Just use the Scsi_Host passed in, rather than looking through the driver's
    own array of boards for one that matches it.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 8ace30ed4186..6d11076bbd02 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4031,9 +4031,7 @@ static int
 advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 		   off_t offset, int length, int inout)
 {
-	struct Scsi_Host *shp;
 	asc_board_t *boardp;
-	int i;
 	char *cp;
 	int cplen;
 	int cnt;
@@ -4058,18 +4056,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 * User read of /proc/scsi/advansys/[0...] file.
 	 */
 
-	/* Find the specified board. */
-	for (i = 0; i < asc_board_count; i++) {
-		if (asc_host[i]->host_no == shost->host_no) {
-			break;
-		}
-	}
-	if (i == asc_board_count) {
-		return (-ENOENT);
-	}
-
-	shp = asc_host[i];
-	boardp = ASC_BOARDP(shp);
+	boardp = ASC_BOARDP(shost);
 
 	/* Copy read data starting at the beginning of the buffer. */
 	*start = buffer;
@@ -4083,7 +4070,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 *
 	 * advansys_info() returns the board string from its own static buffer.
 	 */
-	cp = (char *)advansys_info(shp);
+	cp = (char *)advansys_info(shost);
 	strcat(cp, "\n");
 	cplen = strlen(cp);
 	/* Copy board information. */
@@ -4102,7 +4089,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	if (ASC_WIDE_BOARD(boardp)) {
 		cp = boardp->prtbuf;
-		cplen = asc_prt_adv_bios(shp, cp, ASC_PRTBUF_SIZE);
+		cplen = asc_prt_adv_bios(shost, cp, ASC_PRTBUF_SIZE);
 		ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
 		cnt =
 		    asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
@@ -4121,7 +4108,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 * Display driver information for each device attached to the board.
 	 */
 	cp = boardp->prtbuf;
-	cplen = asc_prt_board_devices(shp, cp, ASC_PRTBUF_SIZE);
+	cplen = asc_prt_board_devices(shost, cp, ASC_PRTBUF_SIZE);
 	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
@@ -4138,9 +4125,9 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	cp = boardp->prtbuf;
 	if (ASC_NARROW_BOARD(boardp)) {
-		cplen = asc_prt_asc_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
+		cplen = asc_prt_asc_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
 	} else {
-		cplen = asc_prt_adv_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
+		cplen = asc_prt_adv_board_eeprom(shost, cp, ASC_PRTBUF_SIZE);
 	}
 	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
@@ -4157,7 +4144,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 * Display driver configuration and information for the board.
 	 */
 	cp = boardp->prtbuf;
-	cplen = asc_prt_driver_conf(shp, cp, ASC_PRTBUF_SIZE);
+	cplen = asc_prt_driver_conf(shost, cp, ASC_PRTBUF_SIZE);
 	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
@@ -4174,7 +4161,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 * Display driver statistics for the board.
 	 */
 	cp = boardp->prtbuf;
-	cplen = asc_prt_board_stats(shp, cp, ASC_PRTBUF_SIZE);
+	cplen = asc_prt_board_stats(shost, cp, ASC_PRTBUF_SIZE);
 	ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
 	totcnt += cnt;
@@ -4191,7 +4178,8 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	for (tgt_id = 0; tgt_id <= ADV_MAX_TID; tgt_id++) {
 		cp = boardp->prtbuf;
-		cplen = asc_prt_target_stats(shp, tgt_id, cp, ASC_PRTBUF_SIZE);
+		cplen = asc_prt_target_stats(shost, tgt_id, cp,
+							ASC_PRTBUF_SIZE);
 		ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
 		cnt =
 		    asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
@@ -4213,9 +4201,9 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 	 */
 	cp = boardp->prtbuf;
 	if (ASC_NARROW_BOARD(boardp)) {
-		cplen = asc_prt_asc_board_info(shp, cp, ASC_PRTBUF_SIZE);
+		cplen = asc_prt_asc_board_info(shost, cp, ASC_PRTBUF_SIZE);
 	} else {
-		cplen = asc_prt_adv_board_info(shp, cp, ASC_PRTBUF_SIZE);
+		cplen = asc_prt_adv_board_info(shost, cp, ASC_PRTBUF_SIZE);
 	}
 	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
 	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);

commit 8c6af9e174abdf40c30a4a229bbd11b458869f97
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 11:03:19 2007 -0400

    [SCSI] advansys: undate version, copyright, etc
    
    Update the version to 3.4
    Add my copyright
    Add myself to MAINTAINERS
    Exercise my right to change the license from dual BSD/GPL to GPL
    Don't force the definition of CONFIG_ISA on x86
    Always include pci.h
    Stop including stat.h
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 79c0b6e37a3b..8ace30ed4186 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1,20 +1,23 @@
-#define ASC_VERSION "3.3K"	/* AdvanSys Driver Version */
+#define ASC_VERSION "3.4"	/* AdvanSys Driver Version */
 
 /*
  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters
  *
  * Copyright (c) 1995-2000 Advanced System Products, Inc.
  * Copyright (c) 2000-2001 ConnectCom Solutions, Inc.
+ * Copyright (c) 2007 Matthew Wilcox <matthew@wil.cx>
  * All Rights Reserved.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that redistributions of source
- * code retain the above copyright notice and this comment without
- * modification.
- *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/*
  * As of March 8, 2000 Advanced System Products, Inc. (AdvanSys)
  * changed its name to ConnectCom Solutions, Inc.
- *
+ * On June 18, 2001 Initio Corp. acquired ConnectCom's SCSI assets
  */
 
 /*
@@ -755,11 +758,6 @@
  */
 
 #include <linux/module.h>
-
-#if defined(CONFIG_X86) && !defined(CONFIG_ISA)
-#define CONFIG_ISA
-#endif /* CONFIG_X86 && !CONFIG_ISA */
-
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -771,7 +769,7 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
-#include <linux/stat.h>
+#include <linux/pci.h>
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
 
@@ -779,6 +777,12 @@
 #include <asm/system.h>
 #include <asm/dma.h>
 
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+
 /* FIXME: (by jejb@steeleye.com) This warning is present for two
  * reasons:
  *
@@ -793,15 +797,6 @@
  */
 #warning this driver is still not properly converted to the DMA API
 
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_tcq.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_host.h>
-#ifdef CONFIG_PCI
-#include <linux/pci.h>
-#endif /* CONFIG_PCI */
-
 /*
  * --- Driver Options
  */
@@ -17772,8 +17767,6 @@ static void AdvInquiryHandling(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 	}
 }
 
-MODULE_LICENSE("Dual BSD/GPL");
-
 static struct Scsi_Host *__devinit
 advansys_board_found(int iop, struct device *dev, int bus_type)
 {
@@ -19029,3 +19022,5 @@ static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
 #endif /* CONFIG_PCI */
+
+MODULE_LICENSE("GPL");

commit 27c868c2233fe0d34b21ceb5287bb2f7617f1095
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Jul 26 10:56:23 2007 -0400

    [SCSI] advansys: lindent and other large, uninteresting changes
    
     - Run Lindent
     - Move advansys_detect and advansys_release to the end of the file
     - Split advansys_board_found out of advansys_detect
     - Rename a few variables, such as shp to shost and pci_devp to pdev
     - Turn STATIC into static
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 2b6689709e53..79c0b6e37a3b 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -1,4 +1,4 @@
-#define ASC_VERSION "3.3K"    /* AdvanSys Driver Version */
+#define ASC_VERSION "3.3K"	/* AdvanSys Driver Version */
 
 /*
  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters
@@ -802,7 +802,6 @@
 #include <linux/pci.h>
 #endif /* CONFIG_PCI */
 
-
 /*
  * --- Driver Options
  */
@@ -816,18 +815,6 @@
 /* Enable driver tracing. */
 /* #define ADVANSYS_DEBUG */
 
-
-/*
- * --- Debugging Header
- */
-
-#ifdef ADVANSYS_DEBUG
-#define STATIC
-#else /* ADVANSYS_DEBUG */
-#define STATIC static
-#endif /* ADVANSYS_DEBUG */
-
-
 /*
  * --- Asc Library Constants and Macros
  */
@@ -845,10 +832,10 @@
  * are all consistent at 8, 16, and 32 bits respectively. Pointers
  * and long types are 64 bits on Alpha and UltraSPARC.
  */
-#define ASC_PADDR __u32         /* Physical/Bus address data type. */
-#define ASC_VADDR __u32         /* Virtual address data type. */
-#define ASC_DCNT  __u32         /* Unsigned Data count type. */
-#define ASC_SDCNT __s32         /* Signed Data count type. */
+#define ASC_PADDR __u32		/* Physical/Bus address data type. */
+#define ASC_VADDR __u32		/* Virtual address data type. */
+#define ASC_DCNT  __u32		/* Unsigned Data count type. */
+#define ASC_SDCNT __s32		/* Signed Data count type. */
 
 /*
  * These macros are used to convert a virtual address to a
@@ -911,7 +898,7 @@ typedef unsigned char uchar;
 #define CC_VERY_LONG_SG_LIST 0
 #define ASC_SRB2SCSIQ(srb_ptr)  (srb_ptr)
 
-#define PortAddr                 unsigned short    /* port address size  */
+#define PortAddr                 unsigned short	/* port address size  */
 #define inp(port)                inb(port)
 #define outp(port, byte)         outb((byte), (port))
 
@@ -1038,17 +1025,17 @@ typedef unsigned char uchar;
 #define ASC_INQ_CLOCKING(inq)       (((inq)->info & 0x0c) >> 2)
 
 typedef struct {
-    uchar               periph;
-    uchar               devtype;
-    uchar               ver;
-    uchar               byte3;
-    uchar               add_len;
-    uchar               res1;
-    uchar               res2;
-    uchar               flags;
-    uchar               vendor_id[8];
-    uchar               product_id[16];
-    uchar               product_rev_level[4];
+	uchar periph;
+	uchar devtype;
+	uchar ver;
+	uchar byte3;
+	uchar add_len;
+	uchar res1;
+	uchar res2;
+	uchar flags;
+	uchar vendor_id[8];
+	uchar product_id[16];
+	uchar product_rev_level[4];
 } ASC_SCSI_INQUIRY;
 
 #define ASC_SG_LIST_PER_Q   7
@@ -1165,139 +1152,139 @@ typedef struct {
 #define ASC_QNO_TO_QADDR(q_no)      ((ASC_QADR_BEG)+((int)(q_no) << 6))
 
 typedef struct asc_scsiq_1 {
-    uchar               status;
-    uchar               q_no;
-    uchar               cntl;
-    uchar               sg_queue_cnt;
-    uchar               target_id;
-    uchar               target_lun;
-    ASC_PADDR           data_addr;
-    ASC_DCNT            data_cnt;
-    ASC_PADDR           sense_addr;
-    uchar               sense_len;
-    uchar               extra_bytes;
+	uchar status;
+	uchar q_no;
+	uchar cntl;
+	uchar sg_queue_cnt;
+	uchar target_id;
+	uchar target_lun;
+	ASC_PADDR data_addr;
+	ASC_DCNT data_cnt;
+	ASC_PADDR sense_addr;
+	uchar sense_len;
+	uchar extra_bytes;
 } ASC_SCSIQ_1;
 
 typedef struct asc_scsiq_2 {
-    ASC_VADDR           srb_ptr;
-    uchar               target_ix;
-    uchar               flag;
-    uchar               cdb_len;
-    uchar               tag_code;
-    ushort              vm_id;
+	ASC_VADDR srb_ptr;
+	uchar target_ix;
+	uchar flag;
+	uchar cdb_len;
+	uchar tag_code;
+	ushort vm_id;
 } ASC_SCSIQ_2;
 
 typedef struct asc_scsiq_3 {
-    uchar               done_stat;
-    uchar               host_stat;
-    uchar               scsi_stat;
-    uchar               scsi_msg;
+	uchar done_stat;
+	uchar host_stat;
+	uchar scsi_stat;
+	uchar scsi_msg;
 } ASC_SCSIQ_3;
 
 typedef struct asc_scsiq_4 {
-    uchar               cdb[ASC_MAX_CDB_LEN];
-    uchar               y_first_sg_list_qp;
-    uchar               y_working_sg_qp;
-    uchar               y_working_sg_ix;
-    uchar               y_res;
-    ushort              x_req_count;
-    ushort              x_reconnect_rtn;
-    ASC_PADDR           x_saved_data_addr;
-    ASC_DCNT            x_saved_data_cnt;
+	uchar cdb[ASC_MAX_CDB_LEN];
+	uchar y_first_sg_list_qp;
+	uchar y_working_sg_qp;
+	uchar y_working_sg_ix;
+	uchar y_res;
+	ushort x_req_count;
+	ushort x_reconnect_rtn;
+	ASC_PADDR x_saved_data_addr;
+	ASC_DCNT x_saved_data_cnt;
 } ASC_SCSIQ_4;
 
 typedef struct asc_q_done_info {
-    ASC_SCSIQ_2         d2;
-    ASC_SCSIQ_3         d3;
-    uchar               q_status;
-    uchar               q_no;
-    uchar               cntl;
-    uchar               sense_len;
-    uchar               extra_bytes;
-    uchar               res;
-    ASC_DCNT            remain_bytes;
+	ASC_SCSIQ_2 d2;
+	ASC_SCSIQ_3 d3;
+	uchar q_status;
+	uchar q_no;
+	uchar cntl;
+	uchar sense_len;
+	uchar extra_bytes;
+	uchar res;
+	ASC_DCNT remain_bytes;
 } ASC_QDONE_INFO;
 
 typedef struct asc_sg_list {
-    ASC_PADDR           addr;
-    ASC_DCNT            bytes;
+	ASC_PADDR addr;
+	ASC_DCNT bytes;
 } ASC_SG_LIST;
 
 typedef struct asc_sg_head {
-    ushort              entry_cnt;
-    ushort              queue_cnt;
-    ushort              entry_to_copy;
-    ushort              res;
-    ASC_SG_LIST         sg_list[ASC_MAX_SG_LIST];
+	ushort entry_cnt;
+	ushort queue_cnt;
+	ushort entry_to_copy;
+	ushort res;
+	ASC_SG_LIST sg_list[ASC_MAX_SG_LIST];
 } ASC_SG_HEAD;
 
 #define ASC_MIN_SG_LIST   2
 
 typedef struct asc_min_sg_head {
-    ushort              entry_cnt;
-    ushort              queue_cnt;
-    ushort              entry_to_copy;
-    ushort              res;
-    ASC_SG_LIST         sg_list[ASC_MIN_SG_LIST];
+	ushort entry_cnt;
+	ushort queue_cnt;
+	ushort entry_to_copy;
+	ushort res;
+	ASC_SG_LIST sg_list[ASC_MIN_SG_LIST];
 } ASC_MIN_SG_HEAD;
 
 #define QCX_SORT        (0x0001)
 #define QCX_COALEASE    (0x0002)
 
 typedef struct asc_scsi_q {
-    ASC_SCSIQ_1         q1;
-    ASC_SCSIQ_2         q2;
-    uchar               *cdbptr;
-    ASC_SG_HEAD         *sg_head;
-    ushort              remain_sg_entry_cnt;
-    ushort              next_sg_index;
+	ASC_SCSIQ_1 q1;
+	ASC_SCSIQ_2 q2;
+	uchar *cdbptr;
+	ASC_SG_HEAD *sg_head;
+	ushort remain_sg_entry_cnt;
+	ushort next_sg_index;
 } ASC_SCSI_Q;
 
 typedef struct asc_scsi_req_q {
-    ASC_SCSIQ_1         r1;
-    ASC_SCSIQ_2         r2;
-    uchar               *cdbptr;
-    ASC_SG_HEAD         *sg_head;
-    uchar               *sense_ptr;
-    ASC_SCSIQ_3         r3;
-    uchar               cdb[ASC_MAX_CDB_LEN];
-    uchar               sense[ASC_MIN_SENSE_LEN];
+	ASC_SCSIQ_1 r1;
+	ASC_SCSIQ_2 r2;
+	uchar *cdbptr;
+	ASC_SG_HEAD *sg_head;
+	uchar *sense_ptr;
+	ASC_SCSIQ_3 r3;
+	uchar cdb[ASC_MAX_CDB_LEN];
+	uchar sense[ASC_MIN_SENSE_LEN];
 } ASC_SCSI_REQ_Q;
 
 typedef struct asc_scsi_bios_req_q {
-    ASC_SCSIQ_1         r1;
-    ASC_SCSIQ_2         r2;
-    uchar               *cdbptr;
-    ASC_SG_HEAD         *sg_head;
-    uchar               *sense_ptr;
-    ASC_SCSIQ_3         r3;
-    uchar               cdb[ASC_MAX_CDB_LEN];
-    uchar               sense[ASC_MIN_SENSE_LEN];
+	ASC_SCSIQ_1 r1;
+	ASC_SCSIQ_2 r2;
+	uchar *cdbptr;
+	ASC_SG_HEAD *sg_head;
+	uchar *sense_ptr;
+	ASC_SCSIQ_3 r3;
+	uchar cdb[ASC_MAX_CDB_LEN];
+	uchar sense[ASC_MIN_SENSE_LEN];
 } ASC_SCSI_BIOS_REQ_Q;
 
 typedef struct asc_risc_q {
-    uchar               fwd;
-    uchar               bwd;
-    ASC_SCSIQ_1         i1;
-    ASC_SCSIQ_2         i2;
-    ASC_SCSIQ_3         i3;
-    ASC_SCSIQ_4         i4;
+	uchar fwd;
+	uchar bwd;
+	ASC_SCSIQ_1 i1;
+	ASC_SCSIQ_2 i2;
+	ASC_SCSIQ_3 i3;
+	ASC_SCSIQ_4 i4;
 } ASC_RISC_Q;
 
 typedef struct asc_sg_list_q {
-    uchar               seq_no;
-    uchar               q_no;
-    uchar               cntl;
-    uchar               sg_head_qp;
-    uchar               sg_list_cnt;
-    uchar               sg_cur_list_cnt;
+	uchar seq_no;
+	uchar q_no;
+	uchar cntl;
+	uchar sg_head_qp;
+	uchar sg_list_cnt;
+	uchar sg_cur_list_cnt;
 } ASC_SG_LIST_Q;
 
 typedef struct asc_risc_sg_list_q {
-    uchar               fwd;
-    uchar               bwd;
-    ASC_SG_LIST_Q       sg;
-    ASC_SG_LIST         sg_list[7];
+	uchar fwd;
+	uchar bwd;
+	ASC_SG_LIST_Q sg;
+	ASC_SG_LIST sg_list[7];
 } ASC_RISC_SG_LIST_Q;
 
 #define ASC_EXE_SCSI_IO_MAX_IDLE_LOOP  0x1000000UL
@@ -1431,25 +1418,25 @@ typedef struct asc_risc_sg_list_q {
 #define SYN_ULTRA_XFER_NS_15  107
 
 typedef struct ext_msg {
-    uchar               msg_type;
-    uchar               msg_len;
-    uchar               msg_req;
-    union {
-        struct {
-            uchar               sdtr_xfer_period;
-            uchar               sdtr_req_ack_offset;
-        } sdtr;
-        struct {
-            uchar               wdtr_width;
-        } wdtr;
-        struct {
-            uchar               mdp_b3;
-            uchar               mdp_b2;
-            uchar               mdp_b1;
-            uchar               mdp_b0;
-        } mdp;
-    } u_ext_msg;
-    uchar               res;
+	uchar msg_type;
+	uchar msg_len;
+	uchar msg_req;
+	union {
+		struct {
+			uchar sdtr_xfer_period;
+			uchar sdtr_req_ack_offset;
+		} sdtr;
+		struct {
+			uchar wdtr_width;
+		} wdtr;
+		struct {
+			uchar mdp_b3;
+			uchar mdp_b2;
+			uchar mdp_b1;
+			uchar mdp_b0;
+		} mdp;
+	} u_ext_msg;
+	uchar res;
 } EXT_MSG;
 
 #define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period
@@ -1461,24 +1448,24 @@ typedef struct ext_msg {
 #define mdp_b0          u_ext_msg.mdp_b0
 
 typedef struct asc_dvc_cfg {
-    ASC_SCSI_BIT_ID_TYPE can_tagged_qng;
-    ASC_SCSI_BIT_ID_TYPE cmd_qng_enabled;
-    ASC_SCSI_BIT_ID_TYPE disc_enable;
-    ASC_SCSI_BIT_ID_TYPE sdtr_enable;
-    uchar               chip_scsi_id;
-    uchar               isa_dma_speed;
-    uchar               isa_dma_channel;
-    uchar               chip_version;
-    ushort              lib_serial_no;
-    ushort              lib_version;
-    ushort              mcode_date;
-    ushort              mcode_version;
-    uchar               max_tag_qng[ASC_MAX_TID + 1];
-    uchar               *overrun_buf;
-    uchar               sdtr_period_offset[ASC_MAX_TID + 1];
-    ushort              pci_slot_info;
-    uchar               adapter_info[6];
-    struct device	*dev;
+	ASC_SCSI_BIT_ID_TYPE can_tagged_qng;
+	ASC_SCSI_BIT_ID_TYPE cmd_qng_enabled;
+	ASC_SCSI_BIT_ID_TYPE disc_enable;
+	ASC_SCSI_BIT_ID_TYPE sdtr_enable;
+	uchar chip_scsi_id;
+	uchar isa_dma_speed;
+	uchar isa_dma_channel;
+	uchar chip_version;
+	ushort lib_serial_no;
+	ushort lib_version;
+	ushort mcode_date;
+	ushort mcode_version;
+	uchar max_tag_qng[ASC_MAX_TID + 1];
+	uchar *overrun_buf;
+	uchar sdtr_period_offset[ASC_MAX_TID + 1];
+	ushort pci_slot_info;
+	uchar adapter_info[6];
+	struct device *dev;
 } ASC_DVC_CFG;
 
 #define ASC_DEF_DVC_CNTL       0xFFFF
@@ -1501,64 +1488,64 @@ typedef struct asc_dvc_cfg {
 #define ASC_MIN_TAGGED_CMD  7
 #define ASC_MAX_SCSI_RESET_WAIT      30
 
-struct asc_dvc_var;     /* Forward Declaration. */
+struct asc_dvc_var;		/* Forward Declaration. */
 
-typedef void (* ASC_ISR_CALLBACK)(struct asc_dvc_var *, ASC_QDONE_INFO *);
-typedef int (* ASC_EXE_CALLBACK)(struct asc_dvc_var *, ASC_SCSI_Q *);
+typedef void (*ASC_ISR_CALLBACK) (struct asc_dvc_var *, ASC_QDONE_INFO *);
+typedef int (*ASC_EXE_CALLBACK) (struct asc_dvc_var *, ASC_SCSI_Q *);
 
 typedef struct asc_dvc_var {
-    PortAddr            iop_base;
-    ushort              err_code;
-    ushort              dvc_cntl;
-    ushort              bug_fix_cntl;
-    ushort              bus_type;
-    ASC_ISR_CALLBACK    isr_callback;
-    ASC_EXE_CALLBACK    exe_callback;
-    ASC_SCSI_BIT_ID_TYPE init_sdtr;
-    ASC_SCSI_BIT_ID_TYPE sdtr_done;
-    ASC_SCSI_BIT_ID_TYPE use_tagged_qng;
-    ASC_SCSI_BIT_ID_TYPE unit_not_ready;
-    ASC_SCSI_BIT_ID_TYPE queue_full_or_busy;
-    ASC_SCSI_BIT_ID_TYPE start_motor;
-    uchar               scsi_reset_wait;
-    uchar               chip_no;
-    char                is_in_int;
-    uchar               max_total_qng;
-    uchar               cur_total_qng;
-    uchar               in_critical_cnt;
-    uchar               irq_no;
-    uchar               last_q_shortage;
-    ushort              init_state;
-    uchar               cur_dvc_qng[ASC_MAX_TID + 1];
-    uchar               max_dvc_qng[ASC_MAX_TID + 1];
-    ASC_SCSI_Q  *scsiq_busy_head[ASC_MAX_TID + 1];
-    ASC_SCSI_Q  *scsiq_busy_tail[ASC_MAX_TID + 1];
-    uchar               sdtr_period_tbl[ASC_MAX_SYN_XFER_NO];
-    ASC_DVC_CFG *cfg;
-    ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always;
-    char                redo_scam;
-    ushort              res2;
-    uchar               dos_int13_table[ASC_MAX_TID + 1];
-    ASC_DCNT            max_dma_count;
-    ASC_SCSI_BIT_ID_TYPE no_scam;
-    ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;
-    uchar               max_sdtr_index;
-    uchar               host_init_sdtr_index;
-    struct asc_board    *drv_ptr;
-    ASC_DCNT            uc_break;
+	PortAddr iop_base;
+	ushort err_code;
+	ushort dvc_cntl;
+	ushort bug_fix_cntl;
+	ushort bus_type;
+	ASC_ISR_CALLBACK isr_callback;
+	ASC_EXE_CALLBACK exe_callback;
+	ASC_SCSI_BIT_ID_TYPE init_sdtr;
+	ASC_SCSI_BIT_ID_TYPE sdtr_done;
+	ASC_SCSI_BIT_ID_TYPE use_tagged_qng;
+	ASC_SCSI_BIT_ID_TYPE unit_not_ready;
+	ASC_SCSI_BIT_ID_TYPE queue_full_or_busy;
+	ASC_SCSI_BIT_ID_TYPE start_motor;
+	uchar scsi_reset_wait;
+	uchar chip_no;
+	char is_in_int;
+	uchar max_total_qng;
+	uchar cur_total_qng;
+	uchar in_critical_cnt;
+	uchar irq_no;
+	uchar last_q_shortage;
+	ushort init_state;
+	uchar cur_dvc_qng[ASC_MAX_TID + 1];
+	uchar max_dvc_qng[ASC_MAX_TID + 1];
+	ASC_SCSI_Q *scsiq_busy_head[ASC_MAX_TID + 1];
+	ASC_SCSI_Q *scsiq_busy_tail[ASC_MAX_TID + 1];
+	uchar sdtr_period_tbl[ASC_MAX_SYN_XFER_NO];
+	ASC_DVC_CFG *cfg;
+	ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always;
+	char redo_scam;
+	ushort res2;
+	uchar dos_int13_table[ASC_MAX_TID + 1];
+	ASC_DCNT max_dma_count;
+	ASC_SCSI_BIT_ID_TYPE no_scam;
+	ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;
+	uchar max_sdtr_index;
+	uchar host_init_sdtr_index;
+	struct asc_board *drv_ptr;
+	ASC_DCNT uc_break;
 } ASC_DVC_VAR;
 
 typedef struct asc_dvc_inq_info {
-    uchar               type[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];
+	uchar type[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];
 } ASC_DVC_INQ_INFO;
 
 typedef struct asc_cap_info {
-    ASC_DCNT            lba;
-    ASC_DCNT            blk_size;
+	ASC_DCNT lba;
+	ASC_DCNT blk_size;
 } ASC_CAP_INFO;
 
 typedef struct asc_cap_info_array {
-    ASC_CAP_INFO        cap_info[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];
+	ASC_CAP_INFO cap_info[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];
 } ASC_CAP_INFO_ARRAY;
 
 #define ASC_MCNTL_NO_SEL_TIMEOUT  (ushort)0x0001
@@ -1603,23 +1590,23 @@ typedef struct asc_cap_info_array {
    ((cfg)->id_speed = ((cfg)->id_speed & 0x0f) | ((spd) & 0x0f) << 4)
 
 typedef struct asceep_config {
-    ushort              cfg_lsw;
-    ushort              cfg_msw;
-    uchar               init_sdtr;
-    uchar               disc_enable;
-    uchar               use_cmd_qng;
-    uchar               start_motor;
-    uchar               max_total_qng;
-    uchar               max_tag_qng;
-    uchar               bios_scan;
-    uchar               power_up_wait;
-    uchar               no_scam;
-    uchar               id_speed; /* low order 4 bits is chip scsi id */
-                                  /* high order 4 bits is isa dma speed */
-    uchar               dos_int13_table[ASC_MAX_TID + 1];
-    uchar               adapter_info[6];
-    ushort              cntl;
-    ushort              chksum;
+	ushort cfg_lsw;
+	ushort cfg_msw;
+	uchar init_sdtr;
+	uchar disc_enable;
+	uchar use_cmd_qng;
+	uchar start_motor;
+	uchar max_total_qng;
+	uchar max_tag_qng;
+	uchar bios_scan;
+	uchar power_up_wait;
+	uchar no_scam;
+	uchar id_speed;		/* low order 4 bits is chip scsi id */
+	/* high order 4 bits is isa dma speed */
+	uchar dos_int13_table[ASC_MAX_TID + 1];
+	uchar adapter_info[6];
+	ushort cntl;
+	ushort chksum;
 } ASCEEP_CONFIG;
 
 #define ASC_PCI_CFG_LSW_SCSI_PARITY  0x0800
@@ -1827,8 +1814,8 @@ typedef struct asceep_config {
 #define ASC_MC_SAVE_DATA_WSIZE  0x40
 
 typedef struct asc_mc_saved {
-    ushort              data[ASC_MC_SAVE_DATA_WSIZE];
-    ushort              code[ASC_MC_SAVE_CODE_WSIZE];
+	ushort data[ASC_MC_SAVE_DATA_WSIZE];
+	ushort code[ASC_MC_SAVE_CODE_WSIZE];
 } ASC_MC_SAVED;
 
 #define AscGetQDoneInProgress(port)         AscReadLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B)
@@ -1900,120 +1887,113 @@ typedef struct asc_mc_saved {
 #define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)
 #define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)
 
-STATIC int       AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg);
-STATIC int       AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg);
-STATIC void      AscWaitEEPRead(void);
-STATIC void      AscWaitEEPWrite(void);
-STATIC ushort    AscReadEEPWord(PortAddr, uchar);
-STATIC ushort    AscWriteEEPWord(PortAddr, uchar, ushort);
-STATIC ushort    AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
-STATIC int       AscSetEEPConfigOnce(PortAddr, ASCEEP_CONFIG *, ushort);
-STATIC int       AscSetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
-STATIC int       AscStartChip(PortAddr);
-STATIC int       AscStopChip(PortAddr);
-STATIC void      AscSetChipIH(PortAddr, ushort);
-STATIC int       AscIsChipHalted(PortAddr);
-STATIC void      AscAckInterrupt(PortAddr);
-STATIC void      AscDisableInterrupt(PortAddr);
-STATIC void      AscEnableInterrupt(PortAddr);
-STATIC void      AscSetBank(PortAddr, uchar);
-STATIC int       AscResetChipAndScsiBus(ASC_DVC_VAR *);
+static int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg);
+static int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg);
+static void AscWaitEEPRead(void);
+static void AscWaitEEPWrite(void);
+static ushort AscReadEEPWord(PortAddr, uchar);
+static ushort AscWriteEEPWord(PortAddr, uchar, ushort);
+static ushort AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
+static int AscSetEEPConfigOnce(PortAddr, ASCEEP_CONFIG *, ushort);
+static int AscSetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
+static int AscStartChip(PortAddr);
+static int AscStopChip(PortAddr);
+static void AscSetChipIH(PortAddr, ushort);
+static int AscIsChipHalted(PortAddr);
+static void AscAckInterrupt(PortAddr);
+static void AscDisableInterrupt(PortAddr);
+static void AscEnableInterrupt(PortAddr);
+static void AscSetBank(PortAddr, uchar);
+static int AscResetChipAndScsiBus(ASC_DVC_VAR *);
 #ifdef CONFIG_ISA
-STATIC ushort    AscGetIsaDmaChannel(PortAddr);
-STATIC ushort    AscSetIsaDmaChannel(PortAddr, ushort);
-STATIC uchar     AscSetIsaDmaSpeed(PortAddr, uchar);
-STATIC uchar     AscGetIsaDmaSpeed(PortAddr);
+static ushort AscGetIsaDmaChannel(PortAddr);
+static ushort AscSetIsaDmaChannel(PortAddr, ushort);
+static uchar AscSetIsaDmaSpeed(PortAddr, uchar);
+static uchar AscGetIsaDmaSpeed(PortAddr);
 #endif /* CONFIG_ISA */
-STATIC uchar     AscReadLramByte(PortAddr, ushort);
-STATIC ushort    AscReadLramWord(PortAddr, ushort);
+static uchar AscReadLramByte(PortAddr, ushort);
+static ushort AscReadLramWord(PortAddr, ushort);
 #if CC_VERY_LONG_SG_LIST
-STATIC ASC_DCNT  AscReadLramDWord(PortAddr, ushort);
+static ASC_DCNT AscReadLramDWord(PortAddr, ushort);
 #endif /* CC_VERY_LONG_SG_LIST */
-STATIC void      AscWriteLramWord(PortAddr, ushort, ushort);
-STATIC void      AscWriteLramByte(PortAddr, ushort, uchar);
-STATIC ASC_DCNT  AscMemSumLramWord(PortAddr, ushort, int);
-STATIC void      AscMemWordSetLram(PortAddr, ushort, ushort, int);
-STATIC void      AscMemWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
-STATIC void      AscMemDWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
-STATIC void      AscMemWordCopyPtrFromLram(PortAddr, ushort, uchar *, int);
-STATIC ushort    AscInitAscDvcVar(ASC_DVC_VAR *);
-STATIC ushort    AscInitFromEEP(ASC_DVC_VAR *);
-STATIC ushort    AscInitFromAscDvcVar(ASC_DVC_VAR *);
-STATIC ushort    AscInitMicroCodeVar(ASC_DVC_VAR *);
-STATIC int       AscTestExternalLram(ASC_DVC_VAR *);
-STATIC uchar     AscMsgOutSDTR(ASC_DVC_VAR *, uchar, uchar);
-STATIC uchar     AscCalSDTRData(ASC_DVC_VAR *, uchar, uchar);
-STATIC void      AscSetChipSDTR(PortAddr, uchar, uchar);
-STATIC uchar     AscGetSynPeriodIndex(ASC_DVC_VAR *, uchar);
-STATIC uchar     AscAllocFreeQueue(PortAddr, uchar);
-STATIC uchar     AscAllocMultipleFreeQueue(PortAddr, uchar, uchar);
-STATIC int       AscHostReqRiscHalt(PortAddr);
-STATIC int       AscStopQueueExe(PortAddr);
-STATIC int       AscSendScsiQueue(ASC_DVC_VAR *,
-                    ASC_SCSI_Q * scsiq,
-                    uchar n_q_required);
-STATIC int       AscPutReadyQueue(ASC_DVC_VAR *,
-                    ASC_SCSI_Q *, uchar);
-STATIC int       AscPutReadySgListQueue(ASC_DVC_VAR *,
-                    ASC_SCSI_Q *, uchar);
-STATIC int       AscSetChipSynRegAtID(PortAddr, uchar, uchar);
-STATIC int       AscSetRunChipSynRegAtID(PortAddr, uchar, uchar);
-STATIC ushort    AscInitLram(ASC_DVC_VAR *);
-STATIC ushort    AscInitQLinkVar(ASC_DVC_VAR *);
-STATIC int       AscSetLibErrorCode(ASC_DVC_VAR *, ushort);
-STATIC int       AscIsrChipHalted(ASC_DVC_VAR *);
-STATIC uchar     _AscCopyLramScsiDoneQ(PortAddr, ushort,
-                    ASC_QDONE_INFO *, ASC_DCNT);
-STATIC int       AscIsrQDone(ASC_DVC_VAR *);
-STATIC int       AscCompareString(uchar *, uchar *, int);
+static void AscWriteLramWord(PortAddr, ushort, ushort);
+static void AscWriteLramByte(PortAddr, ushort, uchar);
+static ASC_DCNT AscMemSumLramWord(PortAddr, ushort, int);
+static void AscMemWordSetLram(PortAddr, ushort, ushort, int);
+static void AscMemWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
+static void AscMemDWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
+static void AscMemWordCopyPtrFromLram(PortAddr, ushort, uchar *, int);
+static ushort AscInitAscDvcVar(ASC_DVC_VAR *);
+static ushort AscInitFromEEP(ASC_DVC_VAR *);
+static ushort AscInitFromAscDvcVar(ASC_DVC_VAR *);
+static ushort AscInitMicroCodeVar(ASC_DVC_VAR *);
+static int AscTestExternalLram(ASC_DVC_VAR *);
+static uchar AscMsgOutSDTR(ASC_DVC_VAR *, uchar, uchar);
+static uchar AscCalSDTRData(ASC_DVC_VAR *, uchar, uchar);
+static void AscSetChipSDTR(PortAddr, uchar, uchar);
+static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *, uchar);
+static uchar AscAllocFreeQueue(PortAddr, uchar);
+static uchar AscAllocMultipleFreeQueue(PortAddr, uchar, uchar);
+static int AscHostReqRiscHalt(PortAddr);
+static int AscStopQueueExe(PortAddr);
+static int AscSendScsiQueue(ASC_DVC_VAR *,
+			    ASC_SCSI_Q *scsiq, uchar n_q_required);
+static int AscPutReadyQueue(ASC_DVC_VAR *, ASC_SCSI_Q *, uchar);
+static int AscPutReadySgListQueue(ASC_DVC_VAR *, ASC_SCSI_Q *, uchar);
+static int AscSetChipSynRegAtID(PortAddr, uchar, uchar);
+static int AscSetRunChipSynRegAtID(PortAddr, uchar, uchar);
+static ushort AscInitLram(ASC_DVC_VAR *);
+static ushort AscInitQLinkVar(ASC_DVC_VAR *);
+static int AscSetLibErrorCode(ASC_DVC_VAR *, ushort);
+static int AscIsrChipHalted(ASC_DVC_VAR *);
+static uchar _AscCopyLramScsiDoneQ(PortAddr, ushort,
+				   ASC_QDONE_INFO *, ASC_DCNT);
+static int AscIsrQDone(ASC_DVC_VAR *);
+static int AscCompareString(uchar *, uchar *, int);
 #ifdef CONFIG_ISA
-STATIC ushort    AscGetEisaChipCfg(PortAddr);
-STATIC ASC_DCNT  AscGetEisaProductID(PortAddr);
-STATIC PortAddr  AscSearchIOPortAddrEISA(PortAddr);
-STATIC PortAddr  AscSearchIOPortAddr11(PortAddr);
-STATIC PortAddr  AscSearchIOPortAddr(PortAddr, ushort);
-STATIC void      AscSetISAPNPWaitForKey(void);
+static ushort AscGetEisaChipCfg(PortAddr);
+static ASC_DCNT AscGetEisaProductID(PortAddr);
+static PortAddr AscSearchIOPortAddrEISA(PortAddr);
+static PortAddr AscSearchIOPortAddr11(PortAddr);
+static PortAddr AscSearchIOPortAddr(PortAddr, ushort);
+static void AscSetISAPNPWaitForKey(void);
 #endif /* CONFIG_ISA */
-STATIC uchar     AscGetChipScsiCtrl(PortAddr);
-STATIC uchar     AscSetChipScsiID(PortAddr, uchar);
-STATIC uchar     AscGetChipVersion(PortAddr, ushort);
-STATIC ushort    AscGetChipBusType(PortAddr);
-STATIC ASC_DCNT  AscLoadMicroCode(PortAddr, ushort, uchar *, ushort);
-STATIC int       AscFindSignature(PortAddr);
-STATIC void      AscToggleIRQAct(PortAddr);
-STATIC uchar     AscGetChipIRQ(PortAddr, ushort);
-STATIC uchar     AscSetChipIRQ(PortAddr, uchar, ushort);
-STATIC ushort    AscGetChipBiosAddress(PortAddr, ushort);
-STATIC inline ulong DvcEnterCritical(void);
-STATIC inline void DvcLeaveCritical(ulong);
+static uchar AscGetChipScsiCtrl(PortAddr);
+static uchar AscSetChipScsiID(PortAddr, uchar);
+static uchar AscGetChipVersion(PortAddr, ushort);
+static ushort AscGetChipBusType(PortAddr);
+static ASC_DCNT AscLoadMicroCode(PortAddr, ushort, uchar *, ushort);
+static int AscFindSignature(PortAddr);
+static void AscToggleIRQAct(PortAddr);
+static uchar AscGetChipIRQ(PortAddr, ushort);
+static uchar AscSetChipIRQ(PortAddr, uchar, ushort);
+static ushort AscGetChipBiosAddress(PortAddr, ushort);
+static inline ulong DvcEnterCritical(void);
+static inline void DvcLeaveCritical(ulong);
 #ifdef CONFIG_PCI
-STATIC uchar     DvcReadPCIConfigByte(ASC_DVC_VAR *, ushort);
-STATIC void      DvcWritePCIConfigByte(ASC_DVC_VAR *,
-                    ushort, uchar);
+static uchar DvcReadPCIConfigByte(ASC_DVC_VAR *, ushort);
+static void DvcWritePCIConfigByte(ASC_DVC_VAR *, ushort, uchar);
 #endif /* CONFIG_PCI */
-STATIC ushort      AscGetChipBiosAddress(PortAddr, ushort);
-STATIC void      DvcSleepMilliSecond(ASC_DCNT);
-STATIC void      DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
-STATIC void      DvcPutScsiQ(PortAddr, ushort, uchar *, int);
-STATIC void      DvcGetQinfo(PortAddr, ushort, uchar *, int);
-STATIC ushort    AscInitGetConfig(ASC_DVC_VAR *);
-STATIC ushort    AscInitSetConfig(ASC_DVC_VAR *);
-STATIC ushort    AscInitAsc1000Driver(ASC_DVC_VAR *);
-STATIC void      AscAsyncFix(ASC_DVC_VAR *, uchar,
-                    ASC_SCSI_INQUIRY *);
-STATIC int       AscTagQueuingSafe(ASC_SCSI_INQUIRY *);
-STATIC void      AscInquiryHandling(ASC_DVC_VAR *,
-                    uchar, ASC_SCSI_INQUIRY *);
-STATIC int       AscExeScsiQueue(ASC_DVC_VAR *, ASC_SCSI_Q *);
-STATIC int       AscISR(ASC_DVC_VAR *);
-STATIC uint      AscGetNumOfFreeQueue(ASC_DVC_VAR *, uchar,
-                    uchar);
-STATIC int       AscSgListToQueue(int);
+static ushort AscGetChipBiosAddress(PortAddr, ushort);
+static void DvcSleepMilliSecond(ASC_DCNT);
+static void DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
+static void DvcPutScsiQ(PortAddr, ushort, uchar *, int);
+static void DvcGetQinfo(PortAddr, ushort, uchar *, int);
+static ushort AscInitGetConfig(ASC_DVC_VAR *);
+static ushort AscInitSetConfig(ASC_DVC_VAR *);
+static ushort AscInitAsc1000Driver(ASC_DVC_VAR *);
+static void AscAsyncFix(ASC_DVC_VAR *, uchar, ASC_SCSI_INQUIRY *);
+static int AscTagQueuingSafe(ASC_SCSI_INQUIRY *);
+static void AscInquiryHandling(ASC_DVC_VAR *, uchar, ASC_SCSI_INQUIRY *);
+static int AscExeScsiQueue(ASC_DVC_VAR *, ASC_SCSI_Q *);
+static int AscISR(ASC_DVC_VAR *);
+static uint AscGetNumOfFreeQueue(ASC_DVC_VAR *, uchar, uchar);
+static int AscSgListToQueue(int);
 #ifdef CONFIG_ISA
-STATIC void      AscEnableIsaDma(uchar);
+static void AscEnableIsaDma(uchar);
 #endif /* CONFIG_ISA */
-STATIC ASC_DCNT  AscGetMaxDmaCount(ushort);
-static const char *advansys_info(struct Scsi_Host *shp);
+static ASC_DCNT AscGetMaxDmaCount(ushort);
+static const char *advansys_info(struct Scsi_Host *shost);
 
 /*
  * --- Adv Library Constants and Macros
@@ -2035,10 +2015,10 @@ static const char *advansys_info(struct Scsi_Host *shp);
  * are all consistent at 8, 16, and 32 bits respectively. Pointers
  * and long types are 64 bits on Alpha and UltraSPARC.
  */
-#define ADV_PADDR __u32         /* Physical address data type. */
-#define ADV_VADDR __u32         /* Virtual address data type. */
-#define ADV_DCNT  __u32         /* Unsigned Data count type. */
-#define ADV_SDCNT __s32         /* Signed Data count type. */
+#define ADV_PADDR __u32		/* Physical address data type. */
+#define ADV_VADDR __u32		/* Virtual address data type. */
+#define ADV_DCNT  __u32		/* Unsigned Data count type. */
+#define ADV_SDCNT __s32		/* Signed Data count type. */
 
 /*
  * These macros are used to convert a virtual address to a
@@ -2051,7 +2031,7 @@ static const char *advansys_info(struct Scsi_Host *shp);
 #define ADV_VADDR_TO_U32   virt_to_bus
 #define ADV_U32_TO_VADDR   bus_to_virt
 
-#define AdvPortAddr  void __iomem *     /* Virtual memory address size */
+#define AdvPortAddr  void __iomem *	/* Virtual memory address size */
 
 /*
  * Define Adv Library required memory access macros.
@@ -2103,20 +2083,20 @@ static const char *advansys_info(struct Scsi_Host *shp);
 
 #define ADV_EEP_DVC_CFG_BEGIN           (0x00)
 #define ADV_EEP_DVC_CFG_END             (0x15)
-#define ADV_EEP_DVC_CTL_BEGIN           (0x16)  /* location of OEM name */
+#define ADV_EEP_DVC_CTL_BEGIN           (0x16)	/* location of OEM name */
 #define ADV_EEP_MAX_WORD_ADDR           (0x1E)
 
 #define ADV_EEP_DELAY_MS                100
 
-#define ADV_EEPROM_BIG_ENDIAN          0x8000   /* EEPROM Bit 15 */
-#define ADV_EEPROM_BIOS_ENABLE         0x4000   /* EEPROM Bit 14 */
+#define ADV_EEPROM_BIG_ENDIAN          0x8000	/* EEPROM Bit 15 */
+#define ADV_EEPROM_BIOS_ENABLE         0x4000	/* EEPROM Bit 14 */
 /*
  * For the ASC3550 Bit 13 is Termination Polarity control bit.
  * For later ICs Bit 13 controls whether the CIS (Card Information
  * Service Section) is loaded from EEPROM.
  */
-#define ADV_EEPROM_TERM_POL            0x2000   /* EEPROM Bit 13 */
-#define ADV_EEPROM_CIS_LD              0x2000   /* EEPROM Bit 13 */
+#define ADV_EEPROM_TERM_POL            0x2000	/* EEPROM Bit 13 */
+#define ADV_EEPROM_CIS_LD              0x2000	/* EEPROM Bit 13 */
 /*
  * ASC38C1600 Bit 11
  *
@@ -2128,280 +2108,277 @@ static const char *advansys_info(struct Scsi_Host *shp);
  * INT B in the PCI Configuration Space Int Pin field. If it is 1, then
  * Function 1 will specify INT A.
  */
-#define ADV_EEPROM_INTAB               0x0800   /* EEPROM Bit 11 */
-
-typedef struct adveep_3550_config
-{
-                                /* Word Offset, Description */
-
-  ushort cfg_lsw;               /* 00 power up initialization */
-                                /*  bit 13 set - Term Polarity Control */
-                                /*  bit 14 set - BIOS Enable */
-                                /*  bit 15 set - Big Endian Mode */
-  ushort cfg_msw;               /* 01 unused      */
-  ushort disc_enable;           /* 02 disconnect enable */
-  ushort wdtr_able;             /* 03 Wide DTR able */
-  ushort sdtr_able;             /* 04 Synchronous DTR able */
-  ushort start_motor;           /* 05 send start up motor */
-  ushort tagqng_able;           /* 06 tag queuing able */
-  ushort bios_scan;             /* 07 BIOS device control */
-  ushort scam_tolerant;         /* 08 no scam */
-
-  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
-  uchar  bios_boot_delay;       /*    power up wait */
-
-  uchar  scsi_reset_delay;      /* 10 reset delay */
-  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
-                                /*    high nibble is lun */
-                                /*    low nibble is scsi id */
-
-  uchar  termination;           /* 11 0 - automatic */
-                                /*    1 - low off / high off */
-                                /*    2 - low off / high on */
-                                /*    3 - low on  / high on */
-                                /*    There is no low on  / high off */
-
-  uchar  reserved1;             /*    reserved byte (not used) */
-
-  ushort bios_ctrl;             /* 12 BIOS control bits */
-                                /*  bit 0  BIOS don't act as initiator. */
-                                /*  bit 1  BIOS > 1 GB support */
-                                /*  bit 2  BIOS > 2 Disk Support */
-                                /*  bit 3  BIOS don't support removables */
-                                /*  bit 4  BIOS support bootable CD */
-                                /*  bit 5  BIOS scan enabled */
-                                /*  bit 6  BIOS support multiple LUNs */
-                                /*  bit 7  BIOS display of message */
-                                /*  bit 8  SCAM disabled */
-                                /*  bit 9  Reset SCSI bus during init. */
-                                /*  bit 10 */
-                                /*  bit 11 No verbose initialization. */
-                                /*  bit 12 SCSI parity enabled */
-                                /*  bit 13 */
-                                /*  bit 14 */
-                                /*  bit 15 */
-  ushort  ultra_able;           /* 13 ULTRA speed able */
-  ushort  reserved2;            /* 14 reserved */
-  uchar   max_host_qng;         /* 15 maximum host queuing */
-  uchar   max_dvc_qng;          /*    maximum per device queuing */
-  ushort  dvc_cntl;             /* 16 control bit for driver */
-  ushort  bug_fix;              /* 17 control bit for bug fix */
-  ushort  serial_number_word1;  /* 18 Board serial number word 1 */
-  ushort  serial_number_word2;  /* 19 Board serial number word 2 */
-  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
-  ushort  check_sum;            /* 21 EEP check sum */
-  uchar   oem_name[16];         /* 22 OEM name */
-  ushort  dvc_err_code;         /* 30 last device driver error code */
-  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
-  ushort  adv_err_addr;         /* 32 last uc error address */
-  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
-  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
-  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */
-  ushort  num_of_err;           /* 36 number of error */
+#define ADV_EEPROM_INTAB               0x0800	/* EEPROM Bit 11 */
+
+typedef struct adveep_3550_config {
+	/* Word Offset, Description */
+
+	ushort cfg_lsw;		/* 00 power up initialization */
+	/*  bit 13 set - Term Polarity Control */
+	/*  bit 14 set - BIOS Enable */
+	/*  bit 15 set - Big Endian Mode */
+	ushort cfg_msw;		/* 01 unused      */
+	ushort disc_enable;	/* 02 disconnect enable */
+	ushort wdtr_able;	/* 03 Wide DTR able */
+	ushort sdtr_able;	/* 04 Synchronous DTR able */
+	ushort start_motor;	/* 05 send start up motor */
+	ushort tagqng_able;	/* 06 tag queuing able */
+	ushort bios_scan;	/* 07 BIOS device control */
+	ushort scam_tolerant;	/* 08 no scam */
+
+	uchar adapter_scsi_id;	/* 09 Host Adapter ID */
+	uchar bios_boot_delay;	/*    power up wait */
+
+	uchar scsi_reset_delay;	/* 10 reset delay */
+	uchar bios_id_lun;	/*    first boot device scsi id & lun */
+	/*    high nibble is lun */
+	/*    low nibble is scsi id */
+
+	uchar termination;	/* 11 0 - automatic */
+	/*    1 - low off / high off */
+	/*    2 - low off / high on */
+	/*    3 - low on  / high on */
+	/*    There is no low on  / high off */
+
+	uchar reserved1;	/*    reserved byte (not used) */
+
+	ushort bios_ctrl;	/* 12 BIOS control bits */
+	/*  bit 0  BIOS don't act as initiator. */
+	/*  bit 1  BIOS > 1 GB support */
+	/*  bit 2  BIOS > 2 Disk Support */
+	/*  bit 3  BIOS don't support removables */
+	/*  bit 4  BIOS support bootable CD */
+	/*  bit 5  BIOS scan enabled */
+	/*  bit 6  BIOS support multiple LUNs */
+	/*  bit 7  BIOS display of message */
+	/*  bit 8  SCAM disabled */
+	/*  bit 9  Reset SCSI bus during init. */
+	/*  bit 10 */
+	/*  bit 11 No verbose initialization. */
+	/*  bit 12 SCSI parity enabled */
+	/*  bit 13 */
+	/*  bit 14 */
+	/*  bit 15 */
+	ushort ultra_able;	/* 13 ULTRA speed able */
+	ushort reserved2;	/* 14 reserved */
+	uchar max_host_qng;	/* 15 maximum host queuing */
+	uchar max_dvc_qng;	/*    maximum per device queuing */
+	ushort dvc_cntl;	/* 16 control bit for driver */
+	ushort bug_fix;		/* 17 control bit for bug fix */
+	ushort serial_number_word1;	/* 18 Board serial number word 1 */
+	ushort serial_number_word2;	/* 19 Board serial number word 2 */
+	ushort serial_number_word3;	/* 20 Board serial number word 3 */
+	ushort check_sum;	/* 21 EEP check sum */
+	uchar oem_name[16];	/* 22 OEM name */
+	ushort dvc_err_code;	/* 30 last device driver error code */
+	ushort adv_err_code;	/* 31 last uc and Adv Lib error code */
+	ushort adv_err_addr;	/* 32 last uc error address */
+	ushort saved_dvc_err_code;	/* 33 saved last dev. driver error code   */
+	ushort saved_adv_err_code;	/* 34 saved last uc and Adv Lib error code */
+	ushort saved_adv_err_addr;	/* 35 saved last uc error address         */
+	ushort num_of_err;	/* 36 number of error */
 } ADVEEP_3550_CONFIG;
 
-typedef struct adveep_38C0800_config
-{
-                                /* Word Offset, Description */
-
-  ushort cfg_lsw;               /* 00 power up initialization */
-                                /*  bit 13 set - Load CIS */
-                                /*  bit 14 set - BIOS Enable */
-                                /*  bit 15 set - Big Endian Mode */
-  ushort cfg_msw;               /* 01 unused      */
-  ushort disc_enable;           /* 02 disconnect enable */
-  ushort wdtr_able;             /* 03 Wide DTR able */
-  ushort sdtr_speed1;           /* 04 SDTR Speed TID 0-3 */
-  ushort start_motor;           /* 05 send start up motor */
-  ushort tagqng_able;           /* 06 tag queuing able */
-  ushort bios_scan;             /* 07 BIOS device control */
-  ushort scam_tolerant;         /* 08 no scam */
-
-  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
-  uchar  bios_boot_delay;       /*    power up wait */
-
-  uchar  scsi_reset_delay;      /* 10 reset delay */
-  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
-                                /*    high nibble is lun */
-                                /*    low nibble is scsi id */
-
-  uchar  termination_se;        /* 11 0 - automatic */
-                                /*    1 - low off / high off */
-                                /*    2 - low off / high on */
-                                /*    3 - low on  / high on */
-                                /*    There is no low on  / high off */
-
-  uchar  termination_lvd;       /* 11 0 - automatic */
-                                /*    1 - low off / high off */
-                                /*    2 - low off / high on */
-                                /*    3 - low on  / high on */
-                                /*    There is no low on  / high off */
-
-  ushort bios_ctrl;             /* 12 BIOS control bits */
-                                /*  bit 0  BIOS don't act as initiator. */
-                                /*  bit 1  BIOS > 1 GB support */
-                                /*  bit 2  BIOS > 2 Disk Support */
-                                /*  bit 3  BIOS don't support removables */
-                                /*  bit 4  BIOS support bootable CD */
-                                /*  bit 5  BIOS scan enabled */
-                                /*  bit 6  BIOS support multiple LUNs */
-                                /*  bit 7  BIOS display of message */
-                                /*  bit 8  SCAM disabled */
-                                /*  bit 9  Reset SCSI bus during init. */
-                                /*  bit 10 */
-                                /*  bit 11 No verbose initialization. */
-                                /*  bit 12 SCSI parity enabled */
-                                /*  bit 13 */
-                                /*  bit 14 */
-                                /*  bit 15 */
-  ushort  sdtr_speed2;          /* 13 SDTR speed TID 4-7 */
-  ushort  sdtr_speed3;          /* 14 SDTR speed TID 8-11 */
-  uchar   max_host_qng;         /* 15 maximum host queueing */
-  uchar   max_dvc_qng;          /*    maximum per device queuing */
-  ushort  dvc_cntl;             /* 16 control bit for driver */
-  ushort  sdtr_speed4;          /* 17 SDTR speed 4 TID 12-15 */
-  ushort  serial_number_word1;  /* 18 Board serial number word 1 */
-  ushort  serial_number_word2;  /* 19 Board serial number word 2 */
-  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
-  ushort  check_sum;            /* 21 EEP check sum */
-  uchar   oem_name[16];         /* 22 OEM name */
-  ushort  dvc_err_code;         /* 30 last device driver error code */
-  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
-  ushort  adv_err_addr;         /* 32 last uc error address */
-  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
-  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
-  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */
-  ushort  reserved36;           /* 36 reserved */
-  ushort  reserved37;           /* 37 reserved */
-  ushort  reserved38;           /* 38 reserved */
-  ushort  reserved39;           /* 39 reserved */
-  ushort  reserved40;           /* 40 reserved */
-  ushort  reserved41;           /* 41 reserved */
-  ushort  reserved42;           /* 42 reserved */
-  ushort  reserved43;           /* 43 reserved */
-  ushort  reserved44;           /* 44 reserved */
-  ushort  reserved45;           /* 45 reserved */
-  ushort  reserved46;           /* 46 reserved */
-  ushort  reserved47;           /* 47 reserved */
-  ushort  reserved48;           /* 48 reserved */
-  ushort  reserved49;           /* 49 reserved */
-  ushort  reserved50;           /* 50 reserved */
-  ushort  reserved51;           /* 51 reserved */
-  ushort  reserved52;           /* 52 reserved */
-  ushort  reserved53;           /* 53 reserved */
-  ushort  reserved54;           /* 54 reserved */
-  ushort  reserved55;           /* 55 reserved */
-  ushort  cisptr_lsw;           /* 56 CIS PTR LSW */
-  ushort  cisprt_msw;           /* 57 CIS PTR MSW */
-  ushort  subsysvid;            /* 58 SubSystem Vendor ID */
-  ushort  subsysid;             /* 59 SubSystem ID */
-  ushort  reserved60;           /* 60 reserved */
-  ushort  reserved61;           /* 61 reserved */
-  ushort  reserved62;           /* 62 reserved */
-  ushort  reserved63;           /* 63 reserved */
+typedef struct adveep_38C0800_config {
+	/* Word Offset, Description */
+
+	ushort cfg_lsw;		/* 00 power up initialization */
+	/*  bit 13 set - Load CIS */
+	/*  bit 14 set - BIOS Enable */
+	/*  bit 15 set - Big Endian Mode */
+	ushort cfg_msw;		/* 01 unused      */
+	ushort disc_enable;	/* 02 disconnect enable */
+	ushort wdtr_able;	/* 03 Wide DTR able */
+	ushort sdtr_speed1;	/* 04 SDTR Speed TID 0-3 */
+	ushort start_motor;	/* 05 send start up motor */
+	ushort tagqng_able;	/* 06 tag queuing able */
+	ushort bios_scan;	/* 07 BIOS device control */
+	ushort scam_tolerant;	/* 08 no scam */
+
+	uchar adapter_scsi_id;	/* 09 Host Adapter ID */
+	uchar bios_boot_delay;	/*    power up wait */
+
+	uchar scsi_reset_delay;	/* 10 reset delay */
+	uchar bios_id_lun;	/*    first boot device scsi id & lun */
+	/*    high nibble is lun */
+	/*    low nibble is scsi id */
+
+	uchar termination_se;	/* 11 0 - automatic */
+	/*    1 - low off / high off */
+	/*    2 - low off / high on */
+	/*    3 - low on  / high on */
+	/*    There is no low on  / high off */
+
+	uchar termination_lvd;	/* 11 0 - automatic */
+	/*    1 - low off / high off */
+	/*    2 - low off / high on */
+	/*    3 - low on  / high on */
+	/*    There is no low on  / high off */
+
+	ushort bios_ctrl;	/* 12 BIOS control bits */
+	/*  bit 0  BIOS don't act as initiator. */
+	/*  bit 1  BIOS > 1 GB support */
+	/*  bit 2  BIOS > 2 Disk Support */
+	/*  bit 3  BIOS don't support removables */
+	/*  bit 4  BIOS support bootable CD */
+	/*  bit 5  BIOS scan enabled */
+	/*  bit 6  BIOS support multiple LUNs */
+	/*  bit 7  BIOS display of message */
+	/*  bit 8  SCAM disabled */
+	/*  bit 9  Reset SCSI bus during init. */
+	/*  bit 10 */
+	/*  bit 11 No verbose initialization. */
+	/*  bit 12 SCSI parity enabled */
+	/*  bit 13 */
+	/*  bit 14 */
+	/*  bit 15 */
+	ushort sdtr_speed2;	/* 13 SDTR speed TID 4-7 */
+	ushort sdtr_speed3;	/* 14 SDTR speed TID 8-11 */
+	uchar max_host_qng;	/* 15 maximum host queueing */
+	uchar max_dvc_qng;	/*    maximum per device queuing */
+	ushort dvc_cntl;	/* 16 control bit for driver */
+	ushort sdtr_speed4;	/* 17 SDTR speed 4 TID 12-15 */
+	ushort serial_number_word1;	/* 18 Board serial number word 1 */
+	ushort serial_number_word2;	/* 19 Board serial number word 2 */
+	ushort serial_number_word3;	/* 20 Board serial number word 3 */
+	ushort check_sum;	/* 21 EEP check sum */
+	uchar oem_name[16];	/* 22 OEM name */
+	ushort dvc_err_code;	/* 30 last device driver error code */
+	ushort adv_err_code;	/* 31 last uc and Adv Lib error code */
+	ushort adv_err_addr;	/* 32 last uc error address */
+	ushort saved_dvc_err_code;	/* 33 saved last dev. driver error code   */
+	ushort saved_adv_err_code;	/* 34 saved last uc and Adv Lib error code */
+	ushort saved_adv_err_addr;	/* 35 saved last uc error address         */
+	ushort reserved36;	/* 36 reserved */
+	ushort reserved37;	/* 37 reserved */
+	ushort reserved38;	/* 38 reserved */
+	ushort reserved39;	/* 39 reserved */
+	ushort reserved40;	/* 40 reserved */
+	ushort reserved41;	/* 41 reserved */
+	ushort reserved42;	/* 42 reserved */
+	ushort reserved43;	/* 43 reserved */
+	ushort reserved44;	/* 44 reserved */
+	ushort reserved45;	/* 45 reserved */
+	ushort reserved46;	/* 46 reserved */
+	ushort reserved47;	/* 47 reserved */
+	ushort reserved48;	/* 48 reserved */
+	ushort reserved49;	/* 49 reserved */
+	ushort reserved50;	/* 50 reserved */
+	ushort reserved51;	/* 51 reserved */
+	ushort reserved52;	/* 52 reserved */
+	ushort reserved53;	/* 53 reserved */
+	ushort reserved54;	/* 54 reserved */
+	ushort reserved55;	/* 55 reserved */
+	ushort cisptr_lsw;	/* 56 CIS PTR LSW */
+	ushort cisprt_msw;	/* 57 CIS PTR MSW */
+	ushort subsysvid;	/* 58 SubSystem Vendor ID */
+	ushort subsysid;	/* 59 SubSystem ID */
+	ushort reserved60;	/* 60 reserved */
+	ushort reserved61;	/* 61 reserved */
+	ushort reserved62;	/* 62 reserved */
+	ushort reserved63;	/* 63 reserved */
 } ADVEEP_38C0800_CONFIG;
 
-typedef struct adveep_38C1600_config
-{
-                                /* Word Offset, Description */
-
-  ushort cfg_lsw;               /* 00 power up initialization */
-                                /*  bit 11 set - Func. 0 INTB, Func. 1 INTA */
-                                /*       clear - Func. 0 INTA, Func. 1 INTB */
-                                /*  bit 13 set - Load CIS */
-                                /*  bit 14 set - BIOS Enable */
-                                /*  bit 15 set - Big Endian Mode */
-  ushort cfg_msw;               /* 01 unused */
-  ushort disc_enable;           /* 02 disconnect enable */
-  ushort wdtr_able;             /* 03 Wide DTR able */
-  ushort sdtr_speed1;           /* 04 SDTR Speed TID 0-3 */
-  ushort start_motor;           /* 05 send start up motor */
-  ushort tagqng_able;           /* 06 tag queuing able */
-  ushort bios_scan;             /* 07 BIOS device control */
-  ushort scam_tolerant;         /* 08 no scam */
-
-  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
-  uchar  bios_boot_delay;       /*    power up wait */
-
-  uchar  scsi_reset_delay;      /* 10 reset delay */
-  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
-                                /*    high nibble is lun */
-                                /*    low nibble is scsi id */
-
-  uchar  termination_se;        /* 11 0 - automatic */
-                                /*    1 - low off / high off */
-                                /*    2 - low off / high on */
-                                /*    3 - low on  / high on */
-                                /*    There is no low on  / high off */
-
-  uchar  termination_lvd;       /* 11 0 - automatic */
-                                /*    1 - low off / high off */
-                                /*    2 - low off / high on */
-                                /*    3 - low on  / high on */
-                                /*    There is no low on  / high off */
-
-  ushort bios_ctrl;             /* 12 BIOS control bits */
-                                /*  bit 0  BIOS don't act as initiator. */
-                                /*  bit 1  BIOS > 1 GB support */
-                                /*  bit 2  BIOS > 2 Disk Support */
-                                /*  bit 3  BIOS don't support removables */
-                                /*  bit 4  BIOS support bootable CD */
-                                /*  bit 5  BIOS scan enabled */
-                                /*  bit 6  BIOS support multiple LUNs */
-                                /*  bit 7  BIOS display of message */
-                                /*  bit 8  SCAM disabled */
-                                /*  bit 9  Reset SCSI bus during init. */
-                                /*  bit 10 Basic Integrity Checking disabled */
-                                /*  bit 11 No verbose initialization. */
-                                /*  bit 12 SCSI parity enabled */
-                                /*  bit 13 AIPP (Asyn. Info. Ph. Prot.) dis. */
-                                /*  bit 14 */
-                                /*  bit 15 */
-  ushort  sdtr_speed2;          /* 13 SDTR speed TID 4-7 */
-  ushort  sdtr_speed3;          /* 14 SDTR speed TID 8-11 */
-  uchar   max_host_qng;         /* 15 maximum host queueing */
-  uchar   max_dvc_qng;          /*    maximum per device queuing */
-  ushort  dvc_cntl;             /* 16 control bit for driver */
-  ushort  sdtr_speed4;          /* 17 SDTR speed 4 TID 12-15 */
-  ushort  serial_number_word1;  /* 18 Board serial number word 1 */
-  ushort  serial_number_word2;  /* 19 Board serial number word 2 */
-  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
-  ushort  check_sum;            /* 21 EEP check sum */
-  uchar   oem_name[16];         /* 22 OEM name */
-  ushort  dvc_err_code;         /* 30 last device driver error code */
-  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
-  ushort  adv_err_addr;         /* 32 last uc error address */
-  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
-  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
-  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */
-  ushort  reserved36;           /* 36 reserved */
-  ushort  reserved37;           /* 37 reserved */
-  ushort  reserved38;           /* 38 reserved */
-  ushort  reserved39;           /* 39 reserved */
-  ushort  reserved40;           /* 40 reserved */
-  ushort  reserved41;           /* 41 reserved */
-  ushort  reserved42;           /* 42 reserved */
-  ushort  reserved43;           /* 43 reserved */
-  ushort  reserved44;           /* 44 reserved */
-  ushort  reserved45;           /* 45 reserved */
-  ushort  reserved46;           /* 46 reserved */
-  ushort  reserved47;           /* 47 reserved */
-  ushort  reserved48;           /* 48 reserved */
-  ushort  reserved49;           /* 49 reserved */
-  ushort  reserved50;           /* 50 reserved */
-  ushort  reserved51;           /* 51 reserved */
-  ushort  reserved52;           /* 52 reserved */
-  ushort  reserved53;           /* 53 reserved */
-  ushort  reserved54;           /* 54 reserved */
-  ushort  reserved55;           /* 55 reserved */
-  ushort  cisptr_lsw;           /* 56 CIS PTR LSW */
-  ushort  cisprt_msw;           /* 57 CIS PTR MSW */
-  ushort  subsysvid;            /* 58 SubSystem Vendor ID */
-  ushort  subsysid;             /* 59 SubSystem ID */
-  ushort  reserved60;           /* 60 reserved */
-  ushort  reserved61;           /* 61 reserved */
-  ushort  reserved62;           /* 62 reserved */
-  ushort  reserved63;           /* 63 reserved */
+typedef struct adveep_38C1600_config {
+	/* Word Offset, Description */
+
+	ushort cfg_lsw;		/* 00 power up initialization */
+	/*  bit 11 set - Func. 0 INTB, Func. 1 INTA */
+	/*       clear - Func. 0 INTA, Func. 1 INTB */
+	/*  bit 13 set - Load CIS */
+	/*  bit 14 set - BIOS Enable */
+	/*  bit 15 set - Big Endian Mode */
+	ushort cfg_msw;		/* 01 unused */
+	ushort disc_enable;	/* 02 disconnect enable */
+	ushort wdtr_able;	/* 03 Wide DTR able */
+	ushort sdtr_speed1;	/* 04 SDTR Speed TID 0-3 */
+	ushort start_motor;	/* 05 send start up motor */
+	ushort tagqng_able;	/* 06 tag queuing able */
+	ushort bios_scan;	/* 07 BIOS device control */
+	ushort scam_tolerant;	/* 08 no scam */
+
+	uchar adapter_scsi_id;	/* 09 Host Adapter ID */
+	uchar bios_boot_delay;	/*    power up wait */
+
+	uchar scsi_reset_delay;	/* 10 reset delay */
+	uchar bios_id_lun;	/*    first boot device scsi id & lun */
+	/*    high nibble is lun */
+	/*    low nibble is scsi id */
+
+	uchar termination_se;	/* 11 0 - automatic */
+	/*    1 - low off / high off */
+	/*    2 - low off / high on */
+	/*    3 - low on  / high on */
+	/*    There is no low on  / high off */
+
+	uchar termination_lvd;	/* 11 0 - automatic */
+	/*    1 - low off / high off */
+	/*    2 - low off / high on */
+	/*    3 - low on  / high on */
+	/*    There is no low on  / high off */
+
+	ushort bios_ctrl;	/* 12 BIOS control bits */
+	/*  bit 0  BIOS don't act as initiator. */
+	/*  bit 1  BIOS > 1 GB support */
+	/*  bit 2  BIOS > 2 Disk Support */
+	/*  bit 3  BIOS don't support removables */
+	/*  bit 4  BIOS support bootable CD */
+	/*  bit 5  BIOS scan enabled */
+	/*  bit 6  BIOS support multiple LUNs */
+	/*  bit 7  BIOS display of message */
+	/*  bit 8  SCAM disabled */
+	/*  bit 9  Reset SCSI bus during init. */
+	/*  bit 10 Basic Integrity Checking disabled */
+	/*  bit 11 No verbose initialization. */
+	/*  bit 12 SCSI parity enabled */
+	/*  bit 13 AIPP (Asyn. Info. Ph. Prot.) dis. */
+	/*  bit 14 */
+	/*  bit 15 */
+	ushort sdtr_speed2;	/* 13 SDTR speed TID 4-7 */
+	ushort sdtr_speed3;	/* 14 SDTR speed TID 8-11 */
+	uchar max_host_qng;	/* 15 maximum host queueing */
+	uchar max_dvc_qng;	/*    maximum per device queuing */
+	ushort dvc_cntl;	/* 16 control bit for driver */
+	ushort sdtr_speed4;	/* 17 SDTR speed 4 TID 12-15 */
+	ushort serial_number_word1;	/* 18 Board serial number word 1 */
+	ushort serial_number_word2;	/* 19 Board serial number word 2 */
+	ushort serial_number_word3;	/* 20 Board serial number word 3 */
+	ushort check_sum;	/* 21 EEP check sum */
+	uchar oem_name[16];	/* 22 OEM name */
+	ushort dvc_err_code;	/* 30 last device driver error code */
+	ushort adv_err_code;	/* 31 last uc and Adv Lib error code */
+	ushort adv_err_addr;	/* 32 last uc error address */
+	ushort saved_dvc_err_code;	/* 33 saved last dev. driver error code   */
+	ushort saved_adv_err_code;	/* 34 saved last uc and Adv Lib error code */
+	ushort saved_adv_err_addr;	/* 35 saved last uc error address         */
+	ushort reserved36;	/* 36 reserved */
+	ushort reserved37;	/* 37 reserved */
+	ushort reserved38;	/* 38 reserved */
+	ushort reserved39;	/* 39 reserved */
+	ushort reserved40;	/* 40 reserved */
+	ushort reserved41;	/* 41 reserved */
+	ushort reserved42;	/* 42 reserved */
+	ushort reserved43;	/* 43 reserved */
+	ushort reserved44;	/* 44 reserved */
+	ushort reserved45;	/* 45 reserved */
+	ushort reserved46;	/* 46 reserved */
+	ushort reserved47;	/* 47 reserved */
+	ushort reserved48;	/* 48 reserved */
+	ushort reserved49;	/* 49 reserved */
+	ushort reserved50;	/* 50 reserved */
+	ushort reserved51;	/* 51 reserved */
+	ushort reserved52;	/* 52 reserved */
+	ushort reserved53;	/* 53 reserved */
+	ushort reserved54;	/* 54 reserved */
+	ushort reserved55;	/* 55 reserved */
+	ushort cisptr_lsw;	/* 56 CIS PTR LSW */
+	ushort cisprt_msw;	/* 57 CIS PTR MSW */
+	ushort subsysvid;	/* 58 SubSystem Vendor ID */
+	ushort subsysid;	/* 59 SubSystem ID */
+	ushort reserved60;	/* 60 reserved */
+	ushort reserved61;	/* 61 reserved */
+	ushort reserved62;	/* 62 reserved */
+	ushort reserved63;	/* 63 reserved */
 } ADVEEP_38C1600_CONFIG;
 
 /*
@@ -2427,11 +2404,11 @@ typedef struct adveep_38C1600_config
 #define BIOS_CTRL_SCSI_PARITY        0x1000
 #define BIOS_CTRL_AIPP_DIS           0x2000
 
-#define ADV_3550_MEMSIZE   0x2000       /* 8 KB Internal Memory */
-#define ADV_3550_IOLEN     0x40         /* I/O Port Range in bytes */
+#define ADV_3550_MEMSIZE   0x2000	/* 8 KB Internal Memory */
+#define ADV_3550_IOLEN     0x40	/* I/O Port Range in bytes */
 
-#define ADV_38C0800_MEMSIZE  0x4000     /* 16 KB Internal Memory */
-#define ADV_38C0800_IOLEN    0x100      /* I/O Port Range in bytes */
+#define ADV_38C0800_MEMSIZE  0x4000	/* 16 KB Internal Memory */
+#define ADV_38C0800_IOLEN    0x100	/* I/O Port Range in bytes */
 
 /*
  * XXX - Since ASC38C1600 Rev.3 has a local RAM failure issue, there is
@@ -2440,9 +2417,9 @@ typedef struct adveep_38C1600_config
  *
  * #define ADV_38C1600_MEMSIZE  0x8000L   * 32 KB Internal Memory *
  */
-#define ADV_38C1600_MEMSIZE  0x4000   /* 16 KB Internal Memory */
-#define ADV_38C1600_IOLEN    0x100     /* I/O Port Range 256 bytes */
-#define ADV_38C1600_MEMLEN   0x1000    /* Memory Range 4KB bytes */
+#define ADV_38C1600_MEMSIZE  0x4000	/* 16 KB Internal Memory */
+#define ADV_38C1600_IOLEN    0x100	/* I/O Port Range 256 bytes */
+#define ADV_38C1600_MEMLEN   0x1000	/* Memory Range 4KB bytes */
 
 /*
  * Byte I/O register address from base of 'iop_base'.
@@ -2515,39 +2492,39 @@ typedef struct adveep_38C1600_config
 /*
  * Word I/O register address from base of 'iop_base'.
  */
-#define IOPW_CHIP_ID_0          0x00  /* CID0  */
-#define IOPW_CTRL_REG           0x02  /* CC    */
-#define IOPW_RAM_ADDR           0x04  /* LA    */
-#define IOPW_RAM_DATA           0x06  /* LD    */
+#define IOPW_CHIP_ID_0          0x00	/* CID0  */
+#define IOPW_CTRL_REG           0x02	/* CC    */
+#define IOPW_RAM_ADDR           0x04	/* LA    */
+#define IOPW_RAM_DATA           0x06	/* LD    */
 #define IOPW_RES_ADDR_08        0x08
-#define IOPW_RISC_CSR           0x0A  /* CSR   */
-#define IOPW_SCSI_CFG0          0x0C  /* CFG0  */
-#define IOPW_SCSI_CFG1          0x0E  /* CFG1  */
+#define IOPW_RISC_CSR           0x0A	/* CSR   */
+#define IOPW_SCSI_CFG0          0x0C	/* CFG0  */
+#define IOPW_SCSI_CFG1          0x0E	/* CFG1  */
 #define IOPW_RES_ADDR_10        0x10
-#define IOPW_SEL_MASK           0x12  /* SM    */
+#define IOPW_SEL_MASK           0x12	/* SM    */
 #define IOPW_RES_ADDR_14        0x14
-#define IOPW_FLASH_ADDR         0x16  /* FA    */
+#define IOPW_FLASH_ADDR         0x16	/* FA    */
 #define IOPW_RES_ADDR_18        0x18
-#define IOPW_EE_CMD             0x1A  /* EC    */
-#define IOPW_EE_DATA            0x1C  /* ED    */
-#define IOPW_SFIFO_CNT          0x1E  /* SFC   */
+#define IOPW_EE_CMD             0x1A	/* EC    */
+#define IOPW_EE_DATA            0x1C	/* ED    */
+#define IOPW_SFIFO_CNT          0x1E	/* SFC   */
 #define IOPW_RES_ADDR_20        0x20
-#define IOPW_Q_BASE             0x22  /* QB    */
-#define IOPW_QP                 0x24  /* QP    */
-#define IOPW_IX                 0x26  /* IX    */
-#define IOPW_SP                 0x28  /* SP    */
-#define IOPW_PC                 0x2A  /* PC    */
+#define IOPW_Q_BASE             0x22	/* QB    */
+#define IOPW_QP                 0x24	/* QP    */
+#define IOPW_IX                 0x26	/* IX    */
+#define IOPW_SP                 0x28	/* SP    */
+#define IOPW_PC                 0x2A	/* PC    */
 #define IOPW_RES_ADDR_2C        0x2C
 #define IOPW_RES_ADDR_2E        0x2E
-#define IOPW_SCSI_DATA          0x30  /* SD    */
-#define IOPW_SCSI_DATA_HSHK     0x32  /* SDH   */
-#define IOPW_SCSI_CTRL          0x34  /* SC    */
-#define IOPW_HSHK_CFG           0x36  /* HCFG  */
-#define IOPW_SXFR_STATUS        0x36  /* SXS   */
-#define IOPW_SXFR_CNTL          0x38  /* SXL   */
-#define IOPW_SXFR_CNTH          0x3A  /* SXH   */
+#define IOPW_SCSI_DATA          0x30	/* SD    */
+#define IOPW_SCSI_DATA_HSHK     0x32	/* SDH   */
+#define IOPW_SCSI_CTRL          0x34	/* SC    */
+#define IOPW_HSHK_CFG           0x36	/* HCFG  */
+#define IOPW_SXFR_STATUS        0x36	/* SXS   */
+#define IOPW_SXFR_CNTL          0x38	/* SXL   */
+#define IOPW_SXFR_CNTH          0x3A	/* SXH   */
 #define IOPW_RES_ADDR_3C        0x3C
-#define IOPW_RFIFO_DATA         0x3E  /* RFD   */
+#define IOPW_RFIFO_DATA         0x3E	/* RFD   */
 
 /*
  * Doubleword I/O register address from base of 'iop_base'.
@@ -2621,36 +2598,36 @@ typedef struct adveep_38C1600_config
 /*
  * SCSI_CFG0 Register bit definitions
  */
-#define TIMER_MODEAB    0xC000  /* Watchdog, Second, and Select. Timer Ctrl. */
-#define PARITY_EN       0x2000  /* Enable SCSI Parity Error detection */
-#define EVEN_PARITY     0x1000  /* Select Even Parity */
-#define WD_LONG         0x0800  /* Watchdog Interval, 1: 57 min, 0: 13 sec */
-#define QUEUE_128       0x0400  /* Queue Size, 1: 128 byte, 0: 64 byte */
-#define PRIM_MODE       0x0100  /* Primitive SCSI mode */
-#define SCAM_EN         0x0080  /* Enable SCAM selection */
-#define SEL_TMO_LONG    0x0040  /* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */
-#define CFRM_ID         0x0020  /* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */
-#define OUR_ID_EN       0x0010  /* Enable OUR_ID bits */
-#define OUR_ID          0x000F  /* SCSI ID */
+#define TIMER_MODEAB    0xC000	/* Watchdog, Second, and Select. Timer Ctrl. */
+#define PARITY_EN       0x2000	/* Enable SCSI Parity Error detection */
+#define EVEN_PARITY     0x1000	/* Select Even Parity */
+#define WD_LONG         0x0800	/* Watchdog Interval, 1: 57 min, 0: 13 sec */
+#define QUEUE_128       0x0400	/* Queue Size, 1: 128 byte, 0: 64 byte */
+#define PRIM_MODE       0x0100	/* Primitive SCSI mode */
+#define SCAM_EN         0x0080	/* Enable SCAM selection */
+#define SEL_TMO_LONG    0x0040	/* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */
+#define CFRM_ID         0x0020	/* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */
+#define OUR_ID_EN       0x0010	/* Enable OUR_ID bits */
+#define OUR_ID          0x000F	/* SCSI ID */
 
 /*
  * SCSI_CFG1 Register bit definitions
  */
-#define BIG_ENDIAN      0x8000  /* Enable Big Endian Mode MIO:15, EEP:15 */
-#define TERM_POL        0x2000  /* Terminator Polarity Ctrl. MIO:13, EEP:13 */
-#define SLEW_RATE       0x1000  /* SCSI output buffer slew rate */
-#define FILTER_SEL      0x0C00  /* Filter Period Selection */
-#define  FLTR_DISABLE    0x0000  /* Input Filtering Disabled */
-#define  FLTR_11_TO_20NS 0x0800  /* Input Filtering 11ns to 20ns */
-#define  FLTR_21_TO_39NS 0x0C00  /* Input Filtering 21ns to 39ns */
-#define ACTIVE_DBL      0x0200  /* Disable Active Negation */
-#define DIFF_MODE       0x0100  /* SCSI differential Mode (Read-Only) */
-#define DIFF_SENSE      0x0080  /* 1: No SE cables, 0: SE cable (Read-Only) */
-#define TERM_CTL_SEL    0x0040  /* Enable TERM_CTL_H and TERM_CTL_L */
-#define TERM_CTL        0x0030  /* External SCSI Termination Bits */
-#define  TERM_CTL_H      0x0020  /* Enable External SCSI Upper Termination */
-#define  TERM_CTL_L      0x0010  /* Enable External SCSI Lower Termination */
-#define CABLE_DETECT    0x000F  /* External SCSI Cable Connection Status */
+#define BIG_ENDIAN      0x8000	/* Enable Big Endian Mode MIO:15, EEP:15 */
+#define TERM_POL        0x2000	/* Terminator Polarity Ctrl. MIO:13, EEP:13 */
+#define SLEW_RATE       0x1000	/* SCSI output buffer slew rate */
+#define FILTER_SEL      0x0C00	/* Filter Period Selection */
+#define  FLTR_DISABLE    0x0000	/* Input Filtering Disabled */
+#define  FLTR_11_TO_20NS 0x0800	/* Input Filtering 11ns to 20ns */
+#define  FLTR_21_TO_39NS 0x0C00	/* Input Filtering 21ns to 39ns */
+#define ACTIVE_DBL      0x0200	/* Disable Active Negation */
+#define DIFF_MODE       0x0100	/* SCSI differential Mode (Read-Only) */
+#define DIFF_SENSE      0x0080	/* 1: No SE cables, 0: SE cable (Read-Only) */
+#define TERM_CTL_SEL    0x0040	/* Enable TERM_CTL_H and TERM_CTL_L */
+#define TERM_CTL        0x0030	/* External SCSI Termination Bits */
+#define  TERM_CTL_H      0x0020	/* Enable External SCSI Upper Termination */
+#define  TERM_CTL_L      0x0010	/* Enable External SCSI Lower Termination */
+#define CABLE_DETECT    0x000F	/* External SCSI Cable Connection Status */
 
 /*
  * Addendum for ASC-38C0800 Chip
@@ -2663,24 +2640,23 @@ typedef struct adveep_38C1600_config
  * Also each ASC-38C1600 function or channel uses only cable bits [5:4]
  * and [1:0]. Bits [14], [7:6], [3:2] are unused.
  */
-#define DIS_TERM_DRV    0x4000  /* 1: Read c_det[3:0], 0: cannot read */
-#define HVD_LVD_SE      0x1C00  /* Device Detect Bits */
-#define  HVD             0x1000  /* HVD Device Detect */
-#define  LVD             0x0800  /* LVD Device Detect */
-#define  SE              0x0400  /* SE Device Detect */
-#define TERM_LVD        0x00C0  /* LVD Termination Bits */
-#define  TERM_LVD_HI     0x0080  /* Enable LVD Upper Termination */
-#define  TERM_LVD_LO     0x0040  /* Enable LVD Lower Termination */
-#define TERM_SE         0x0030  /* SE Termination Bits */
-#define  TERM_SE_HI      0x0020  /* Enable SE Upper Termination */
-#define  TERM_SE_LO      0x0010  /* Enable SE Lower Termination */
-#define C_DET_LVD       0x000C  /* LVD Cable Detect Bits */
-#define  C_DET3          0x0008  /* Cable Detect for LVD External Wide */
-#define  C_DET2          0x0004  /* Cable Detect for LVD Internal Wide */
-#define C_DET_SE        0x0003  /* SE Cable Detect Bits */
-#define  C_DET1          0x0002  /* Cable Detect for SE Internal Wide */
-#define  C_DET0          0x0001  /* Cable Detect for SE Internal Narrow */
-
+#define DIS_TERM_DRV    0x4000	/* 1: Read c_det[3:0], 0: cannot read */
+#define HVD_LVD_SE      0x1C00	/* Device Detect Bits */
+#define  HVD             0x1000	/* HVD Device Detect */
+#define  LVD             0x0800	/* LVD Device Detect */
+#define  SE              0x0400	/* SE Device Detect */
+#define TERM_LVD        0x00C0	/* LVD Termination Bits */
+#define  TERM_LVD_HI     0x0080	/* Enable LVD Upper Termination */
+#define  TERM_LVD_LO     0x0040	/* Enable LVD Lower Termination */
+#define TERM_SE         0x0030	/* SE Termination Bits */
+#define  TERM_SE_HI      0x0020	/* Enable SE Upper Termination */
+#define  TERM_SE_LO      0x0010	/* Enable SE Lower Termination */
+#define C_DET_LVD       0x000C	/* LVD Cable Detect Bits */
+#define  C_DET3          0x0008	/* Cable Detect for LVD External Wide */
+#define  C_DET2          0x0004	/* Cable Detect for LVD Internal Wide */
+#define C_DET_SE        0x0003	/* SE Cable Detect Bits */
+#define  C_DET1          0x0002	/* Cable Detect for SE Internal Wide */
+#define  C_DET0          0x0001	/* Cable Detect for SE Internal Narrow */
 
 #define CABLE_ILLEGAL_A 0x7
     /* x 0 0 0  | on  on | Illegal (all 3 connectors are used) */
@@ -2691,39 +2667,39 @@ typedef struct adveep_38C1600_config
 /*
  * MEM_CFG Register bit definitions
  */
-#define BIOS_EN         0x40    /* BIOS Enable MIO:14,EEP:14 */
-#define FAST_EE_CLK     0x20    /* Diagnostic Bit */
-#define RAM_SZ          0x1C    /* Specify size of RAM to RISC */
-#define  RAM_SZ_2KB      0x00    /* 2 KB */
-#define  RAM_SZ_4KB      0x04    /* 4 KB */
-#define  RAM_SZ_8KB      0x08    /* 8 KB */
-#define  RAM_SZ_16KB     0x0C    /* 16 KB */
-#define  RAM_SZ_32KB     0x10    /* 32 KB */
-#define  RAM_SZ_64KB     0x14    /* 64 KB */
+#define BIOS_EN         0x40	/* BIOS Enable MIO:14,EEP:14 */
+#define FAST_EE_CLK     0x20	/* Diagnostic Bit */
+#define RAM_SZ          0x1C	/* Specify size of RAM to RISC */
+#define  RAM_SZ_2KB      0x00	/* 2 KB */
+#define  RAM_SZ_4KB      0x04	/* 4 KB */
+#define  RAM_SZ_8KB      0x08	/* 8 KB */
+#define  RAM_SZ_16KB     0x0C	/* 16 KB */
+#define  RAM_SZ_32KB     0x10	/* 32 KB */
+#define  RAM_SZ_64KB     0x14	/* 64 KB */
 
 /*
  * DMA_CFG0 Register bit definitions
  *
  * This register is only accessible to the host.
  */
-#define BC_THRESH_ENB   0x80    /* PCI DMA Start Conditions */
-#define FIFO_THRESH     0x70    /* PCI DMA FIFO Threshold */
-#define  FIFO_THRESH_16B  0x00   /* 16 bytes */
-#define  FIFO_THRESH_32B  0x20   /* 32 bytes */
-#define  FIFO_THRESH_48B  0x30   /* 48 bytes */
-#define  FIFO_THRESH_64B  0x40   /* 64 bytes */
-#define  FIFO_THRESH_80B  0x50   /* 80 bytes (default) */
-#define  FIFO_THRESH_96B  0x60   /* 96 bytes */
-#define  FIFO_THRESH_112B 0x70   /* 112 bytes */
-#define START_CTL       0x0C    /* DMA start conditions */
-#define  START_CTL_TH    0x00    /* Wait threshold level (default) */
-#define  START_CTL_ID    0x04    /* Wait SDMA/SBUS idle */
-#define  START_CTL_THID  0x08    /* Wait threshold and SDMA/SBUS idle */
-#define  START_CTL_EMFU  0x0C    /* Wait SDMA FIFO empty/full */
-#define READ_CMD        0x03    /* Memory Read Method */
-#define  READ_CMD_MR     0x00    /* Memory Read */
-#define  READ_CMD_MRL    0x02    /* Memory Read Long */
-#define  READ_CMD_MRM    0x03    /* Memory Read Multiple (default) */
+#define BC_THRESH_ENB   0x80	/* PCI DMA Start Conditions */
+#define FIFO_THRESH     0x70	/* PCI DMA FIFO Threshold */
+#define  FIFO_THRESH_16B  0x00	/* 16 bytes */
+#define  FIFO_THRESH_32B  0x20	/* 32 bytes */
+#define  FIFO_THRESH_48B  0x30	/* 48 bytes */
+#define  FIFO_THRESH_64B  0x40	/* 64 bytes */
+#define  FIFO_THRESH_80B  0x50	/* 80 bytes (default) */
+#define  FIFO_THRESH_96B  0x60	/* 96 bytes */
+#define  FIFO_THRESH_112B 0x70	/* 112 bytes */
+#define START_CTL       0x0C	/* DMA start conditions */
+#define  START_CTL_TH    0x00	/* Wait threshold level (default) */
+#define  START_CTL_ID    0x04	/* Wait SDMA/SBUS idle */
+#define  START_CTL_THID  0x08	/* Wait threshold and SDMA/SBUS idle */
+#define  START_CTL_EMFU  0x0C	/* Wait SDMA FIFO empty/full */
+#define READ_CMD        0x03	/* Memory Read Method */
+#define  READ_CMD_MR     0x00	/* Memory Read */
+#define  READ_CMD_MRL    0x02	/* Memory Read Long */
+#define  READ_CMD_MRM    0x03	/* Memory Read Multiple (default) */
 
 /*
  * ASC-38C0800 RAM BIST Register bit definitions
@@ -2747,7 +2723,7 @@ typedef struct adveep_38C1600_config
  * IOPB_PCI_INT_CFG Bit Field Definitions
  */
 
-#define INTAB_LD        0x80    /* Value loaded from EEPROM Bit 11. */
+#define INTAB_LD        0x80	/* Value loaded from EEPROM Bit 11. */
 
 /*
  * Bit 1 can be set to change the interrupt for the Function to operate in
@@ -2780,53 +2756,52 @@ typedef struct adveep_38C1600_config
 #define ADV_BUSY        0
 #define ADV_ERROR       (-1)
 
-
 /*
  * ADV_DVC_VAR 'warn_code' values
  */
-#define ASC_WARN_BUSRESET_ERROR         0x0001 /* SCSI Bus Reset error */
-#define ASC_WARN_EEPROM_CHKSUM          0x0002 /* EEP check sum error */
-#define ASC_WARN_EEPROM_TERMINATION     0x0004 /* EEP termination bad field */
-#define ASC_WARN_SET_PCI_CONFIG_SPACE   0x0080 /* PCI config space set error */
-#define ASC_WARN_ERROR                  0xFFFF /* ADV_ERROR return */
+#define ASC_WARN_BUSRESET_ERROR         0x0001	/* SCSI Bus Reset error */
+#define ASC_WARN_EEPROM_CHKSUM          0x0002	/* EEP check sum error */
+#define ASC_WARN_EEPROM_TERMINATION     0x0004	/* EEP termination bad field */
+#define ASC_WARN_SET_PCI_CONFIG_SPACE   0x0080	/* PCI config space set error */
+#define ASC_WARN_ERROR                  0xFFFF	/* ADV_ERROR return */
 
-#define ADV_MAX_TID                     15 /* max. target identifier */
-#define ADV_MAX_LUN                     7  /* max. logical unit number */
+#define ADV_MAX_TID                     15	/* max. target identifier */
+#define ADV_MAX_LUN                     7	/* max. logical unit number */
 
 /*
  * Error code values are set in ADV_DVC_VAR 'err_code'.
  */
-#define ASC_IERR_WRITE_EEPROM       0x0001 /* write EEPROM error */
-#define ASC_IERR_MCODE_CHKSUM       0x0002 /* micro code check sum error */
-#define ASC_IERR_NO_CARRIER         0x0004 /* No more carrier memory. */
-#define ASC_IERR_START_STOP_CHIP    0x0008 /* start/stop chip failed */
-#define ASC_IERR_CHIP_VERSION       0x0040 /* wrong chip version */
-#define ASC_IERR_SET_SCSI_ID        0x0080 /* set SCSI ID failed */
-#define ASC_IERR_HVD_DEVICE         0x0100 /* HVD attached to LVD connector. */
-#define ASC_IERR_BAD_SIGNATURE      0x0200 /* signature not found */
-#define ASC_IERR_ILLEGAL_CONNECTION 0x0400 /* Illegal cable connection */
-#define ASC_IERR_SINGLE_END_DEVICE  0x0800 /* Single-end used w/differential */
-#define ASC_IERR_REVERSED_CABLE     0x1000 /* Narrow flat cable reversed */
-#define ASC_IERR_BIST_PRE_TEST      0x2000 /* BIST pre-test error */
-#define ASC_IERR_BIST_RAM_TEST      0x4000 /* BIST RAM test error */
-#define ASC_IERR_BAD_CHIPTYPE       0x8000 /* Invalid 'chip_type' setting. */
+#define ASC_IERR_WRITE_EEPROM       0x0001	/* write EEPROM error */
+#define ASC_IERR_MCODE_CHKSUM       0x0002	/* micro code check sum error */
+#define ASC_IERR_NO_CARRIER         0x0004	/* No more carrier memory. */
+#define ASC_IERR_START_STOP_CHIP    0x0008	/* start/stop chip failed */
+#define ASC_IERR_CHIP_VERSION       0x0040	/* wrong chip version */
+#define ASC_IERR_SET_SCSI_ID        0x0080	/* set SCSI ID failed */
+#define ASC_IERR_HVD_DEVICE         0x0100	/* HVD attached to LVD connector. */
+#define ASC_IERR_BAD_SIGNATURE      0x0200	/* signature not found */
+#define ASC_IERR_ILLEGAL_CONNECTION 0x0400	/* Illegal cable connection */
+#define ASC_IERR_SINGLE_END_DEVICE  0x0800	/* Single-end used w/differential */
+#define ASC_IERR_REVERSED_CABLE     0x1000	/* Narrow flat cable reversed */
+#define ASC_IERR_BIST_PRE_TEST      0x2000	/* BIST pre-test error */
+#define ASC_IERR_BIST_RAM_TEST      0x4000	/* BIST RAM test error */
+#define ASC_IERR_BAD_CHIPTYPE       0x8000	/* Invalid 'chip_type' setting. */
 
 /*
  * Fixed locations of microcode operating variables.
  */
-#define ASC_MC_CODE_BEGIN_ADDR          0x0028 /* microcode start address */
-#define ASC_MC_CODE_END_ADDR            0x002A /* microcode end address */
-#define ASC_MC_CODE_CHK_SUM             0x002C /* microcode code checksum */
-#define ASC_MC_VERSION_DATE             0x0038 /* microcode version */
-#define ASC_MC_VERSION_NUM              0x003A /* microcode number */
-#define ASC_MC_BIOSMEM                  0x0040 /* BIOS RISC Memory Start */
-#define ASC_MC_BIOSLEN                  0x0050 /* BIOS RISC Memory Length */
-#define ASC_MC_BIOS_SIGNATURE           0x0058 /* BIOS Signature 0x55AA */
-#define ASC_MC_BIOS_VERSION             0x005A /* BIOS Version (2 bytes) */
-#define ASC_MC_SDTR_SPEED1              0x0090 /* SDTR Speed for TID 0-3 */
-#define ASC_MC_SDTR_SPEED2              0x0092 /* SDTR Speed for TID 4-7 */
-#define ASC_MC_SDTR_SPEED3              0x0094 /* SDTR Speed for TID 8-11 */
-#define ASC_MC_SDTR_SPEED4              0x0096 /* SDTR Speed for TID 12-15 */
+#define ASC_MC_CODE_BEGIN_ADDR          0x0028	/* microcode start address */
+#define ASC_MC_CODE_END_ADDR            0x002A	/* microcode end address */
+#define ASC_MC_CODE_CHK_SUM             0x002C	/* microcode code checksum */
+#define ASC_MC_VERSION_DATE             0x0038	/* microcode version */
+#define ASC_MC_VERSION_NUM              0x003A	/* microcode number */
+#define ASC_MC_BIOSMEM                  0x0040	/* BIOS RISC Memory Start */
+#define ASC_MC_BIOSLEN                  0x0050	/* BIOS RISC Memory Length */
+#define ASC_MC_BIOS_SIGNATURE           0x0058	/* BIOS Signature 0x55AA */
+#define ASC_MC_BIOS_VERSION             0x005A	/* BIOS Version (2 bytes) */
+#define ASC_MC_SDTR_SPEED1              0x0090	/* SDTR Speed for TID 0-3 */
+#define ASC_MC_SDTR_SPEED2              0x0092	/* SDTR Speed for TID 4-7 */
+#define ASC_MC_SDTR_SPEED3              0x0094	/* SDTR Speed for TID 8-11 */
+#define ASC_MC_SDTR_SPEED4              0x0096	/* SDTR Speed for TID 12-15 */
 #define ASC_MC_CHIP_TYPE                0x009A
 #define ASC_MC_INTRB_CODE               0x009B
 #define ASC_MC_WDTR_ABLE                0x009C
@@ -2844,9 +2819,9 @@ typedef struct adveep_38C1600_config
 #define ASC_MC_NUMBER_OF_QUEUED_CMD     0x00C0
 #define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0
 #define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100
-#define ASC_MC_CONTROL_FLAG             0x0122 /* Microcode control flag. */
+#define ASC_MC_CONTROL_FLAG             0x0122	/* Microcode control flag. */
 #define ASC_MC_WDTR_DONE                0x0124
-#define ASC_MC_CAM_MODE_MASK            0x015E /* CAM mode TID bitmask. */
+#define ASC_MC_CAM_MODE_MASK            0x015E	/* CAM mode TID bitmask. */
 #define ASC_MC_ICQ                      0x0160
 #define ASC_MC_IRQ                      0x0164
 #define ASC_MC_PPR_ABLE                 0x017A
@@ -2865,8 +2840,8 @@ typedef struct adveep_38C1600_config
  * Flags set by the Adv Library in RISC variable 'control_flag' (0x122)
  * and handled by the microcode.
  */
-#define CONTROL_FLAG_IGNORE_PERR        0x0001 /* Ignore DMA Parity Errors */
-#define CONTROL_FLAG_ENABLE_AIPP        0x0002 /* Enabled AIPP checking. */
+#define CONTROL_FLAG_IGNORE_PERR        0x0001	/* Ignore DMA Parity Errors */
+#define CONTROL_FLAG_ENABLE_AIPP        0x0002	/* Enabled AIPP checking. */
 
 /*
  * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format
@@ -2875,45 +2850,44 @@ typedef struct adveep_38C1600_config
 #define HSHK_CFG_RATE           0x0F00
 #define HSHK_CFG_OFFSET         0x001F
 
-#define ASC_DEF_MAX_HOST_QNG    0xFD /* Max. number of host commands (253) */
-#define ASC_DEF_MIN_HOST_QNG    0x10 /* Min. number of host commands (16) */
-#define ASC_DEF_MAX_DVC_QNG     0x3F /* Max. number commands per device (63) */
-#define ASC_DEF_MIN_DVC_QNG     0x04 /* Min. number commands per device (4) */
-
-#define ASC_QC_DATA_CHECK  0x01 /* Require ASC_QC_DATA_OUT set or clear. */
-#define ASC_QC_DATA_OUT    0x02 /* Data out DMA transfer. */
-#define ASC_QC_START_MOTOR 0x04 /* Send auto-start motor before request. */
-#define ASC_QC_NO_OVERRUN  0x08 /* Don't report overrun. */
-#define ASC_QC_FREEZE_TIDQ 0x10 /* Freeze TID queue after request. XXX TBD */
-
-#define ASC_QSC_NO_DISC     0x01 /* Don't allow disconnect for request. */
-#define ASC_QSC_NO_TAGMSG   0x02 /* Don't allow tag queuing for request. */
-#define ASC_QSC_NO_SYNC     0x04 /* Don't use Synch. transfer on request. */
-#define ASC_QSC_NO_WIDE     0x08 /* Don't use Wide transfer on request. */
-#define ASC_QSC_REDO_DTR    0x10 /* Renegotiate WDTR/SDTR before request. */
+#define ASC_DEF_MAX_HOST_QNG    0xFD	/* Max. number of host commands (253) */
+#define ASC_DEF_MIN_HOST_QNG    0x10	/* Min. number of host commands (16) */
+#define ASC_DEF_MAX_DVC_QNG     0x3F	/* Max. number commands per device (63) */
+#define ASC_DEF_MIN_DVC_QNG     0x04	/* Min. number commands per device (4) */
+
+#define ASC_QC_DATA_CHECK  0x01	/* Require ASC_QC_DATA_OUT set or clear. */
+#define ASC_QC_DATA_OUT    0x02	/* Data out DMA transfer. */
+#define ASC_QC_START_MOTOR 0x04	/* Send auto-start motor before request. */
+#define ASC_QC_NO_OVERRUN  0x08	/* Don't report overrun. */
+#define ASC_QC_FREEZE_TIDQ 0x10	/* Freeze TID queue after request. XXX TBD */
+
+#define ASC_QSC_NO_DISC     0x01	/* Don't allow disconnect for request. */
+#define ASC_QSC_NO_TAGMSG   0x02	/* Don't allow tag queuing for request. */
+#define ASC_QSC_NO_SYNC     0x04	/* Don't use Synch. transfer on request. */
+#define ASC_QSC_NO_WIDE     0x08	/* Don't use Wide transfer on request. */
+#define ASC_QSC_REDO_DTR    0x10	/* Renegotiate WDTR/SDTR before request. */
 /*
  * Note: If a Tag Message is to be sent and neither ASC_QSC_HEAD_TAG or
  * ASC_QSC_ORDERED_TAG is set, then a Simple Tag Message (0x20) is used.
  */
-#define ASC_QSC_HEAD_TAG    0x40 /* Use Head Tag Message (0x21). */
-#define ASC_QSC_ORDERED_TAG 0x80 /* Use Ordered Tag Message (0x22). */
+#define ASC_QSC_HEAD_TAG    0x40	/* Use Head Tag Message (0x21). */
+#define ASC_QSC_ORDERED_TAG 0x80	/* Use Ordered Tag Message (0x22). */
 
 /*
  * All fields here are accessed by the board microcode and need to be
  * little-endian.
  */
-typedef struct adv_carr_t
-{
-    ADV_VADDR   carr_va;       /* Carrier Virtual Address */
-    ADV_PADDR   carr_pa;       /* Carrier Physical Address */
-    ADV_VADDR   areq_vpa;      /* ASC_SCSI_REQ_Q Virtual or Physical Address */
-    /*
-     * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer
-     *
-     * next_vpa [3:1]             Reserved Bits
-     * next_vpa [0]               Done Flag set in Response Queue.
-     */
-    ADV_VADDR   next_vpa;
+typedef struct adv_carr_t {
+	ADV_VADDR carr_va;	/* Carrier Virtual Address */
+	ADV_PADDR carr_pa;	/* Carrier Physical Address */
+	ADV_VADDR areq_vpa;	/* ASC_SCSI_REQ_Q Virtual or Physical Address */
+	/*
+	 * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer
+	 *
+	 * next_vpa [3:1]             Reserved Bits
+	 * next_vpa [0]               Done Flag set in Response Queue.
+	 */
+	ADV_VADDR next_vpa;
 } ADV_CARR_T;
 
 /*
@@ -2940,13 +2914,13 @@ typedef struct adv_carr_t
  * The Adv Library should limit use to the lower nibble (4 bits) of
  * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.
  */
-#define ADV_POLL_REQUEST                0x01   /* poll for request completion */
-#define ADV_SCSIQ_DONE                  0x02   /* request done */
-#define ADV_DONT_RETRY                  0x08   /* don't do retry */
+#define ADV_POLL_REQUEST                0x01	/* poll for request completion */
+#define ADV_SCSIQ_DONE                  0x02	/* request done */
+#define ADV_DONT_RETRY                  0x08	/* don't do retry */
 
-#define ADV_CHIP_ASC3550          0x01   /* Ultra-Wide IC */
-#define ADV_CHIP_ASC38C0800       0x02   /* Ultra2-Wide/LVD IC */
-#define ADV_CHIP_ASC38C1600       0x03   /* Ultra3-Wide/LVD2 IC */
+#define ADV_CHIP_ASC3550          0x01	/* Ultra-Wide IC */
+#define ADV_CHIP_ASC38C0800       0x02	/* Ultra2-Wide/LVD IC */
+#define ADV_CHIP_ASC38C1600       0x03	/* Ultra3-Wide/LVD2 IC */
 
 /*
  * Adapter temporary configuration structure
@@ -2960,30 +2934,30 @@ typedef struct adv_carr_t
  *  value of the field is never reset.
  */
 typedef struct adv_dvc_cfg {
-  ushort disc_enable;       /* enable disconnection */
-  uchar  chip_version;      /* chip version */
-  uchar  termination;       /* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */
-  ushort lib_version;       /* Adv Library version number */
-  ushort control_flag;      /* Microcode Control Flag */
-  ushort mcode_date;        /* Microcode date */
-  ushort mcode_version;     /* Microcode version */
-  ushort pci_slot_info;     /* high byte device/function number */
-                            /* bits 7-3 device num., bits 2-0 function num. */
-                            /* low byte bus num. */
-  ushort serial1;           /* EEPROM serial number word 1 */
-  ushort serial2;           /* EEPROM serial number word 2 */
-  ushort serial3;           /* EEPROM serial number word 3 */
-  struct device *dev;  /* pointer to the pci dev structure for this board */
+	ushort disc_enable;	/* enable disconnection */
+	uchar chip_version;	/* chip version */
+	uchar termination;	/* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */
+	ushort lib_version;	/* Adv Library version number */
+	ushort control_flag;	/* Microcode Control Flag */
+	ushort mcode_date;	/* Microcode date */
+	ushort mcode_version;	/* Microcode version */
+	ushort pci_slot_info;	/* high byte device/function number */
+	/* bits 7-3 device num., bits 2-0 function num. */
+	/* low byte bus num. */
+	ushort serial1;		/* EEPROM serial number word 1 */
+	ushort serial2;		/* EEPROM serial number word 2 */
+	ushort serial3;		/* EEPROM serial number word 3 */
+	struct device *dev;	/* pointer to the pci dev structure for this board */
 } ADV_DVC_CFG;
 
 struct adv_dvc_var;
 struct adv_scsi_req_q;
 
-typedef void (* ADV_ISR_CALLBACK)
-    (struct adv_dvc_var *, struct adv_scsi_req_q *);
+typedef void (*ADV_ISR_CALLBACK)
+ (struct adv_dvc_var *, struct adv_scsi_req_q *);
 
-typedef void (* ADV_ASYNC_CALLBACK)
-    (struct adv_dvc_var *, uchar);
+typedef void (*ADV_ASYNC_CALLBACK)
+ (struct adv_dvc_var *, uchar);
 
 /*
  * Adapter operation variable structure.
@@ -2998,55 +2972,55 @@ typedef void (* ADV_ASYNC_CALLBACK)
  *  of the feature, the field is cleared.
  */
 typedef struct adv_dvc_var {
-  AdvPortAddr iop_base;   /* I/O port address */
-  ushort err_code;        /* fatal error code */
-  ushort bios_ctrl;       /* BIOS control word, EEPROM word 12 */
-  ADV_ISR_CALLBACK isr_callback;
-  ADV_ASYNC_CALLBACK async_callback;
-  ushort wdtr_able;       /* try WDTR for a device */
-  ushort sdtr_able;       /* try SDTR for a device */
-  ushort ultra_able;      /* try SDTR Ultra speed for a device */
-  ushort sdtr_speed1;     /* EEPROM SDTR Speed for TID 0-3   */
-  ushort sdtr_speed2;     /* EEPROM SDTR Speed for TID 4-7   */
-  ushort sdtr_speed3;     /* EEPROM SDTR Speed for TID 8-11  */
-  ushort sdtr_speed4;     /* EEPROM SDTR Speed for TID 12-15 */
-  ushort tagqng_able;     /* try tagged queuing with a device */
-  ushort ppr_able;        /* PPR message capable per TID bitmask. */
-  uchar  max_dvc_qng;     /* maximum number of tagged commands per device */
-  ushort start_motor;     /* start motor command allowed */
-  uchar  scsi_reset_wait; /* delay in seconds after scsi bus reset */
-  uchar  chip_no;         /* should be assigned by caller */
-  uchar  max_host_qng;    /* maximum number of Q'ed command allowed */
-  uchar  irq_no;          /* IRQ number */
-  ushort no_scam;         /* scam_tolerant of EEPROM */
-  struct asc_board *drv_ptr; /* driver pointer to private structure */
-  uchar  chip_scsi_id;    /* chip SCSI target ID */
-  uchar  chip_type;
-  uchar  bist_err_code;
-  ADV_CARR_T *carrier_buf;
-  ADV_CARR_T *carr_freelist; /* Carrier free list. */
-  ADV_CARR_T *icq_sp;  /* Initiator command queue stopper pointer. */
-  ADV_CARR_T *irq_sp;  /* Initiator response queue stopper pointer. */
-  ushort carr_pending_cnt;    /* Count of pending carriers. */
- /*
-  * Note: The following fields will not be used after initialization. The
-  * driver may discard the buffer after initialization is done.
-  */
-  ADV_DVC_CFG *cfg; /* temporary configuration structure  */
+	AdvPortAddr iop_base;	/* I/O port address */
+	ushort err_code;	/* fatal error code */
+	ushort bios_ctrl;	/* BIOS control word, EEPROM word 12 */
+	ADV_ISR_CALLBACK isr_callback;
+	ADV_ASYNC_CALLBACK async_callback;
+	ushort wdtr_able;	/* try WDTR for a device */
+	ushort sdtr_able;	/* try SDTR for a device */
+	ushort ultra_able;	/* try SDTR Ultra speed for a device */
+	ushort sdtr_speed1;	/* EEPROM SDTR Speed for TID 0-3   */
+	ushort sdtr_speed2;	/* EEPROM SDTR Speed for TID 4-7   */
+	ushort sdtr_speed3;	/* EEPROM SDTR Speed for TID 8-11  */
+	ushort sdtr_speed4;	/* EEPROM SDTR Speed for TID 12-15 */
+	ushort tagqng_able;	/* try tagged queuing with a device */
+	ushort ppr_able;	/* PPR message capable per TID bitmask. */
+	uchar max_dvc_qng;	/* maximum number of tagged commands per device */
+	ushort start_motor;	/* start motor command allowed */
+	uchar scsi_reset_wait;	/* delay in seconds after scsi bus reset */
+	uchar chip_no;		/* should be assigned by caller */
+	uchar max_host_qng;	/* maximum number of Q'ed command allowed */
+	uchar irq_no;		/* IRQ number */
+	ushort no_scam;		/* scam_tolerant of EEPROM */
+	struct asc_board *drv_ptr;	/* driver pointer to private structure */
+	uchar chip_scsi_id;	/* chip SCSI target ID */
+	uchar chip_type;
+	uchar bist_err_code;
+	ADV_CARR_T *carrier_buf;
+	ADV_CARR_T *carr_freelist;	/* Carrier free list. */
+	ADV_CARR_T *icq_sp;	/* Initiator command queue stopper pointer. */
+	ADV_CARR_T *irq_sp;	/* Initiator response queue stopper pointer. */
+	ushort carr_pending_cnt;	/* Count of pending carriers. */
+	/*
+	 * Note: The following fields will not be used after initialization. The
+	 * driver may discard the buffer after initialization is done.
+	 */
+	ADV_DVC_CFG *cfg;	/* temporary configuration structure  */
 } ADV_DVC_VAR;
 
 #define NO_OF_SG_PER_BLOCK              15
 
 typedef struct asc_sg_block {
-    uchar reserved1;
-    uchar reserved2;
-    uchar reserved3;
-    uchar sg_cnt;                     /* Valid entries in block. */
-    ADV_PADDR sg_ptr;                 /* Pointer to next sg block. */
-    struct  {
-        ADV_PADDR sg_addr;                  /* SG element address. */
-        ADV_DCNT  sg_count;                 /* SG element count. */
-    } sg_list[NO_OF_SG_PER_BLOCK];
+	uchar reserved1;
+	uchar reserved2;
+	uchar reserved3;
+	uchar sg_cnt;		/* Valid entries in block. */
+	ADV_PADDR sg_ptr;	/* Pointer to next sg block. */
+	struct {
+		ADV_PADDR sg_addr;	/* SG element address. */
+		ADV_DCNT sg_count;	/* SG element count. */
+	} sg_list[NO_OF_SG_PER_BLOCK];
 } ADV_SG_BLOCK;
 
 /*
@@ -3061,37 +3035,37 @@ typedef struct asc_sg_block {
  * order.
  */
 typedef struct adv_scsi_req_q {
-    uchar       cntl;           /* Ucode flags and state (ASC_MC_QC_*). */
-    uchar       target_cmd;
-    uchar       target_id;      /* Device target identifier. */
-    uchar       target_lun;     /* Device target logical unit number. */
-    ADV_PADDR   data_addr;      /* Data buffer physical address. */
-    ADV_DCNT    data_cnt;       /* Data count. Ucode sets to residual. */
-    ADV_PADDR   sense_addr;
-    ADV_PADDR   carr_pa;
-    uchar       mflag;
-    uchar       sense_len;
-    uchar       cdb_len;        /* SCSI CDB length. Must <= 16 bytes. */
-    uchar       scsi_cntl;
-    uchar       done_status;    /* Completion status. */
-    uchar       scsi_status;    /* SCSI status byte. */
-    uchar       host_status;    /* Ucode host status. */
-    uchar       sg_working_ix;
-    uchar       cdb[12];        /* SCSI CDB bytes 0-11. */
-    ADV_PADDR   sg_real_addr;   /* SG list physical address. */
-    ADV_PADDR   scsiq_rptr;
-    uchar       cdb16[4];       /* SCSI CDB bytes 12-15. */
-    ADV_VADDR   scsiq_ptr;
-    ADV_VADDR   carr_va;
-    /*
-     * End of microcode structure - 60 bytes. The rest of the structure
-     * is used by the Adv Library and ignored by the microcode.
-     */
-    ADV_VADDR   srb_ptr;
-    ADV_SG_BLOCK *sg_list_ptr; /* SG list virtual address. */
-    char        *vdata_addr;   /* Data buffer virtual address. */
-    uchar       a_flag;
-    uchar       pad[2];        /* Pad out to a word boundary. */
+	uchar cntl;		/* Ucode flags and state (ASC_MC_QC_*). */
+	uchar target_cmd;
+	uchar target_id;	/* Device target identifier. */
+	uchar target_lun;	/* Device target logical unit number. */
+	ADV_PADDR data_addr;	/* Data buffer physical address. */
+	ADV_DCNT data_cnt;	/* Data count. Ucode sets to residual. */
+	ADV_PADDR sense_addr;
+	ADV_PADDR carr_pa;
+	uchar mflag;
+	uchar sense_len;
+	uchar cdb_len;		/* SCSI CDB length. Must <= 16 bytes. */
+	uchar scsi_cntl;
+	uchar done_status;	/* Completion status. */
+	uchar scsi_status;	/* SCSI status byte. */
+	uchar host_status;	/* Ucode host status. */
+	uchar sg_working_ix;
+	uchar cdb[12];		/* SCSI CDB bytes 0-11. */
+	ADV_PADDR sg_real_addr;	/* SG list physical address. */
+	ADV_PADDR scsiq_rptr;
+	uchar cdb16[4];		/* SCSI CDB bytes 12-15. */
+	ADV_VADDR scsiq_ptr;
+	ADV_VADDR carr_va;
+	/*
+	 * End of microcode structure - 60 bytes. The rest of the structure
+	 * is used by the Adv Library and ignored by the microcode.
+	 */
+	ADV_VADDR srb_ptr;
+	ADV_SG_BLOCK *sg_list_ptr;	/* SG list virtual address. */
+	char *vdata_addr;	/* Data buffer virtual address. */
+	uchar a_flag;
+	uchar pad[2];		/* Pad out to a word boundary. */
 } ADV_SCSI_REQ_Q;
 
 /*
@@ -3103,8 +3077,8 @@ typedef struct adv_scsi_req_q {
 #define IDLE_CMD_SEND_INT            0x0004
 #define IDLE_CMD_ABORT               0x0008
 #define IDLE_CMD_DEVICE_RESET        0x0010
-#define IDLE_CMD_SCSI_RESET_START    0x0020 /* Assert SCSI Bus Reset */
-#define IDLE_CMD_SCSI_RESET_END      0x0040 /* Deassert SCSI Bus Reset */
+#define IDLE_CMD_SCSI_RESET_START    0x0020	/* Assert SCSI Bus Reset */
+#define IDLE_CMD_SCSI_RESET_END      0x0040	/* Deassert SCSI Bus Reset */
 #define IDLE_CMD_SCSIREQ             0x0080
 
 #define IDLE_CMD_STATUS_SUCCESS      0x0001
@@ -3118,60 +3092,59 @@ typedef struct adv_scsi_req_q {
 /*
  * Wait loop time out values.
  */
-#define SCSI_WAIT_10_SEC             10UL    /* 10 seconds */
-#define SCSI_WAIT_100_MSEC           100UL   /* 100 milliseconds */
-#define SCSI_US_PER_MSEC             1000    /* microseconds per millisecond */
-#define SCSI_MS_PER_SEC              1000UL  /* milliseconds per second */
-#define SCSI_MAX_RETRY               10      /* retry count */
+#define SCSI_WAIT_10_SEC             10UL	/* 10 seconds */
+#define SCSI_WAIT_100_MSEC           100UL	/* 100 milliseconds */
+#define SCSI_US_PER_MSEC             1000	/* microseconds per millisecond */
+#define SCSI_MS_PER_SEC              1000UL	/* milliseconds per second */
+#define SCSI_MAX_RETRY               10	/* retry count */
 
-#define ADV_ASYNC_RDMA_FAILURE          0x01 /* Fatal RDMA failure. */
-#define ADV_ASYNC_SCSI_BUS_RESET_DET    0x02 /* Detected SCSI Bus Reset. */
-#define ADV_ASYNC_CARRIER_READY_FAILURE 0x03 /* Carrier Ready failure. */
-#define ADV_RDMA_IN_CARR_AND_Q_INVALID  0x04 /* RDMAed-in data invalid. */
+#define ADV_ASYNC_RDMA_FAILURE          0x01	/* Fatal RDMA failure. */
+#define ADV_ASYNC_SCSI_BUS_RESET_DET    0x02	/* Detected SCSI Bus Reset. */
+#define ADV_ASYNC_CARRIER_READY_FAILURE 0x03	/* Carrier Ready failure. */
+#define ADV_RDMA_IN_CARR_AND_Q_INVALID  0x04	/* RDMAed-in data invalid. */
 
-
-#define ADV_HOST_SCSI_BUS_RESET      0x80 /* Host Initiated SCSI Bus Reset. */
+#define ADV_HOST_SCSI_BUS_RESET      0x80	/* Host Initiated SCSI Bus Reset. */
 
 /*
  * Device drivers must define the following functions.
  */
-STATIC inline ulong DvcEnterCritical(void);
-STATIC inline void  DvcLeaveCritical(ulong);
-STATIC void  DvcSleepMilliSecond(ADV_DCNT);
-STATIC uchar DvcAdvReadPCIConfigByte(ADV_DVC_VAR *, ushort);
-STATIC void  DvcAdvWritePCIConfigByte(ADV_DVC_VAR *, ushort, uchar);
-STATIC ADV_PADDR DvcGetPhyAddr(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *,
-                uchar *, ASC_SDCNT *, int);
-STATIC void  DvcDelayMicroSecond(ADV_DVC_VAR *, ushort);
+static inline ulong DvcEnterCritical(void);
+static inline void DvcLeaveCritical(ulong);
+static void DvcSleepMilliSecond(ADV_DCNT);
+static uchar DvcAdvReadPCIConfigByte(ADV_DVC_VAR *, ushort);
+static void DvcAdvWritePCIConfigByte(ADV_DVC_VAR *, ushort, uchar);
+static ADV_PADDR DvcGetPhyAddr(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *,
+			       uchar *, ASC_SDCNT *, int);
+static void DvcDelayMicroSecond(ADV_DVC_VAR *, ushort);
 
 /*
  * Adv Library functions available to drivers.
  */
-STATIC int     AdvExeScsiQueue(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
-STATIC int     AdvISR(ADV_DVC_VAR *);
-STATIC int     AdvInitGetConfig(ADV_DVC_VAR *);
-STATIC int     AdvInitAsc3550Driver(ADV_DVC_VAR *);
-STATIC int     AdvInitAsc38C0800Driver(ADV_DVC_VAR *);
-STATIC int     AdvInitAsc38C1600Driver(ADV_DVC_VAR *);
-STATIC int     AdvResetChipAndSB(ADV_DVC_VAR *);
-STATIC int     AdvResetSB(ADV_DVC_VAR *asc_dvc);
+static int AdvExeScsiQueue(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
+static int AdvISR(ADV_DVC_VAR *);
+static int AdvInitGetConfig(ADV_DVC_VAR *);
+static int AdvInitAsc3550Driver(ADV_DVC_VAR *);
+static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *);
+static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *);
+static int AdvResetChipAndSB(ADV_DVC_VAR *);
+static int AdvResetSB(ADV_DVC_VAR *asc_dvc);
 
 /*
  * Internal Adv Library functions.
  */
-STATIC int    AdvSendIdleCmd(ADV_DVC_VAR *, ushort, ADV_DCNT);
-STATIC void   AdvInquiryHandling(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
-STATIC int    AdvInitFrom3550EEP(ADV_DVC_VAR *);
-STATIC int    AdvInitFrom38C0800EEP(ADV_DVC_VAR *);
-STATIC int    AdvInitFrom38C1600EEP(ADV_DVC_VAR *);
-STATIC ushort AdvGet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
-STATIC void   AdvSet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
-STATIC ushort AdvGet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
-STATIC void   AdvSet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
-STATIC ushort AdvGet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
-STATIC void   AdvSet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
-STATIC void   AdvWaitEEPCmd(AdvPortAddr);
-STATIC ushort AdvReadEEPWord(AdvPortAddr, int);
+static int AdvSendIdleCmd(ADV_DVC_VAR *, ushort, ADV_DCNT);
+static void AdvInquiryHandling(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
+static int AdvInitFrom3550EEP(ADV_DVC_VAR *);
+static int AdvInitFrom38C0800EEP(ADV_DVC_VAR *);
+static int AdvInitFrom38C1600EEP(ADV_DVC_VAR *);
+static ushort AdvGet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
+static void AdvSet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
+static ushort AdvGet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
+static void AdvSet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
+static ushort AdvGet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
+static void AdvSet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
+static void AdvWaitEEPCmd(AdvPortAddr);
+static ushort AdvReadEEPWord(AdvPortAddr, int);
 
 /*
  * PCI Bus Definitions
@@ -3241,7 +3214,6 @@ do { \
 #define AdvWriteWordAutoIncLram(iop_base, word) \
      (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))
 
-
 /*
  * Define macro to check for Condor signature.
  *
@@ -3313,7 +3285,7 @@ do { \
  * ASC_SCSI_REQ_Q 'done_status' and 'host_status' return values.
  */
 
-#define QD_NO_STATUS         0x00       /* Request not completed yet. */
+#define QD_NO_STATUS         0x00	/* Request not completed yet. */
 #define QD_NO_ERROR          0x01
 #define QD_ABORTED_BY_HOST   0x02
 #define QD_WITH_ERROR        0x04
@@ -3323,30 +3295,29 @@ do { \
 #define QHSTA_M_DATA_OVER_RUN       0x12
 #define QHSTA_M_UNEXPECTED_BUS_FREE 0x13
 #define QHSTA_M_QUEUE_ABORTED       0x15
-#define QHSTA_M_SXFR_SDMA_ERR       0x16 /* SXFR_STATUS SCSI DMA Error */
-#define QHSTA_M_SXFR_SXFR_PERR      0x17 /* SXFR_STATUS SCSI Bus Parity Error */
-#define QHSTA_M_RDMA_PERR           0x18 /* RISC PCI DMA parity error */
-#define QHSTA_M_SXFR_OFF_UFLW       0x19 /* SXFR_STATUS Offset Underflow */
-#define QHSTA_M_SXFR_OFF_OFLW       0x20 /* SXFR_STATUS Offset Overflow */
-#define QHSTA_M_SXFR_WD_TMO         0x21 /* SXFR_STATUS Watchdog Timeout */
-#define QHSTA_M_SXFR_DESELECTED     0x22 /* SXFR_STATUS Deselected */
+#define QHSTA_M_SXFR_SDMA_ERR       0x16	/* SXFR_STATUS SCSI DMA Error */
+#define QHSTA_M_SXFR_SXFR_PERR      0x17	/* SXFR_STATUS SCSI Bus Parity Error */
+#define QHSTA_M_RDMA_PERR           0x18	/* RISC PCI DMA parity error */
+#define QHSTA_M_SXFR_OFF_UFLW       0x19	/* SXFR_STATUS Offset Underflow */
+#define QHSTA_M_SXFR_OFF_OFLW       0x20	/* SXFR_STATUS Offset Overflow */
+#define QHSTA_M_SXFR_WD_TMO         0x21	/* SXFR_STATUS Watchdog Timeout */
+#define QHSTA_M_SXFR_DESELECTED     0x22	/* SXFR_STATUS Deselected */
 /* Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */
-#define QHSTA_M_SXFR_XFR_OFLW       0x12 /* SXFR_STATUS Transfer Overflow */
-#define QHSTA_M_SXFR_XFR_PH_ERR     0x24 /* SXFR_STATUS Transfer Phase Error */
-#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25 /* SXFR_STATUS Unknown Error */
-#define QHSTA_M_SCSI_BUS_RESET      0x30 /* Request aborted from SBR */
-#define QHSTA_M_SCSI_BUS_RESET_UNSOL 0x31 /* Request aborted from unsol. SBR */
-#define QHSTA_M_BUS_DEVICE_RESET    0x32 /* Request aborted from BDR */
-#define QHSTA_M_DIRECTION_ERR       0x35 /* Data Phase mismatch */
-#define QHSTA_M_DIRECTION_ERR_HUNG  0x36 /* Data Phase mismatch and bus hang */
+#define QHSTA_M_SXFR_XFR_OFLW       0x12	/* SXFR_STATUS Transfer Overflow */
+#define QHSTA_M_SXFR_XFR_PH_ERR     0x24	/* SXFR_STATUS Transfer Phase Error */
+#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25	/* SXFR_STATUS Unknown Error */
+#define QHSTA_M_SCSI_BUS_RESET      0x30	/* Request aborted from SBR */
+#define QHSTA_M_SCSI_BUS_RESET_UNSOL 0x31	/* Request aborted from unsol. SBR */
+#define QHSTA_M_BUS_DEVICE_RESET    0x32	/* Request aborted from BDR */
+#define QHSTA_M_DIRECTION_ERR       0x35	/* Data Phase mismatch */
+#define QHSTA_M_DIRECTION_ERR_HUNG  0x36	/* Data Phase mismatch and bus hang */
 #define QHSTA_M_WTM_TIMEOUT         0x41
 #define QHSTA_M_BAD_CMPL_STATUS_IN  0x42
 #define QHSTA_M_NO_AUTO_REQ_SENSE   0x43
 #define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44
-#define QHSTA_M_INVALID_DEVICE      0x45 /* Bad target ID */
-#define QHSTA_M_FROZEN_TIDQ         0x46 /* TID Queue frozen. */
-#define QHSTA_M_SGBACKUP_ERROR      0x47 /* Scatter-Gather backup error */
-
+#define QHSTA_M_INVALID_DEVICE      0x45	/* Bad target ID */
+#define QHSTA_M_FROZEN_TIDQ         0x46	/* TID Queue frozen. */
+#define QHSTA_M_SGBACKUP_ERROR      0x47	/* Scatter-Gather backup error */
 
 /*
  * Default EEPROM Configuration structure defined in a_init.c.
@@ -3358,12 +3329,12 @@ static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config;
 /*
  * DvcGetPhyAddr() flag arguments
  */
-#define ADV_IS_SCSIQ_FLAG       0x01 /* 'addr' is ASC_SCSI_REQ_Q pointer */
-#define ADV_ASCGETSGLIST_VADDR  0x02 /* 'addr' is AscGetSGList() virtual addr */
-#define ADV_IS_SENSE_FLAG       0x04 /* 'addr' is sense virtual pointer */
-#define ADV_IS_DATA_FLAG        0x08 /* 'addr' is data virtual pointer */
-#define ADV_IS_SGLIST_FLAG      0x10 /* 'addr' is sglist virtual pointer */
-#define ADV_IS_CARRIER_FLAG     0x20 /* 'addr' is ADV_CARR_T pointer */
+#define ADV_IS_SCSIQ_FLAG       0x01	/* 'addr' is ASC_SCSI_REQ_Q pointer */
+#define ADV_ASCGETSGLIST_VADDR  0x02	/* 'addr' is AscGetSGList() virtual addr */
+#define ADV_IS_SENSE_FLAG       0x04	/* 'addr' is sense virtual pointer */
+#define ADV_IS_DATA_FLAG        0x08	/* 'addr' is data virtual pointer */
+#define ADV_IS_SGLIST_FLAG      0x10	/* 'addr' is sglist virtual pointer */
+#define ADV_IS_CARRIER_FLAG     0x20	/* 'addr' is ADV_CARR_T pointer */
 
 /* Return the address that is aligned at the next doubleword >= to 'addr'. */
 #define ADV_8BALIGN(addr)      (((ulong) (addr) + 0x7) & ~0x7)
@@ -3413,43 +3384,42 @@ static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config;
 #define ADV_INQ_CLOCKING(inq)       (((inq)->info & 0x0c) >> 2)
 
 typedef struct {
-  uchar periph;                 /* peripheral device type [0:4] */
-                                /* peripheral qualifier [5:7] */
-  uchar devtype;                /* device type modifier (for SCSI I) [0:6] */
-                                /* RMB - removable medium bit [7] */
-  uchar ver;                    /* ANSI approved version [0:2] */
-                                /* ECMA version [3:5] */
-                                /* ISO version [6:7] */
-  uchar byte3;                  /* response data format [0:3] */
-                                /* 0 SCSI 1 */
-                                /* 1 CCS */
-                                /* 2 SCSI-2 */
-                                /* 3-F reserved */
-                                /* reserved [4:5] */
-                                /* terminate I/O process bit (see 5.6.22) [6] */
-                                /* asynch. event notification (processor) [7] */
-  uchar add_len;                /* additional length */
-  uchar res1;                   /* reserved */
-  uchar res2;                   /* reserved */
-  uchar flags;                  /* soft reset implemented [0] */
-                                /* command queuing [1] */
-                                /* reserved [2] */
-                                /* linked command for this logical unit [3] */
-                                /* synchronous data transfer [4] */
-                                /* wide bus 16 bit data transfer [5] */
-                                /* wide bus 32 bit data transfer [6] */
-                                /* relative addressing mode [7] */
-  uchar vendor_id[8];           /* vendor identification */
-  uchar product_id[16];         /* product identification */
-  uchar product_rev_level[4];   /* product revision level */
-  uchar vendor_specific[20];    /* vendor specific */
-  uchar info;                   /* information unit supported [0] */
-                                /* quick arbitrate supported [1] */
-                                /* clocking field [2:3] */
-                                /* reserved [4:7] */
-  uchar res3;                   /* reserved */
-} ADV_SCSI_INQUIRY; /* 58 bytes */
-
+	uchar periph;		/* peripheral device type [0:4] */
+	/* peripheral qualifier [5:7] */
+	uchar devtype;		/* device type modifier (for SCSI I) [0:6] */
+	/* RMB - removable medium bit [7] */
+	uchar ver;		/* ANSI approved version [0:2] */
+	/* ECMA version [3:5] */
+	/* ISO version [6:7] */
+	uchar byte3;		/* response data format [0:3] */
+	/* 0 SCSI 1 */
+	/* 1 CCS */
+	/* 2 SCSI-2 */
+	/* 3-F reserved */
+	/* reserved [4:5] */
+	/* terminate I/O process bit (see 5.6.22) [6] */
+	/* asynch. event notification (processor) [7] */
+	uchar add_len;		/* additional length */
+	uchar res1;		/* reserved */
+	uchar res2;		/* reserved */
+	uchar flags;		/* soft reset implemented [0] */
+	/* command queuing [1] */
+	/* reserved [2] */
+	/* linked command for this logical unit [3] */
+	/* synchronous data transfer [4] */
+	/* wide bus 16 bit data transfer [5] */
+	/* wide bus 32 bit data transfer [6] */
+	/* relative addressing mode [7] */
+	uchar vendor_id[8];	/* vendor identification */
+	uchar product_id[16];	/* product identification */
+	uchar product_rev_level[4];	/* product revision level */
+	uchar vendor_specific[20];	/* vendor specific */
+	uchar info;		/* information unit supported [0] */
+	/* quick arbitrate supported [1] */
+	/* clocking field [2:3] */
+	/* reserved [4:7] */
+	uchar res3;		/* reserved */
+} ADV_SCSI_INQUIRY;		/* 58 bytes */
 
 /*
  * --- Driver Constants and Macros
@@ -3464,15 +3434,15 @@ typedef struct {
 
 /* asc_board_t flags */
 #define ASC_HOST_IN_RESET       0x01
-#define ASC_IS_WIDE_BOARD       0x04    /* AdvanSys Wide Board */
+#define ASC_IS_WIDE_BOARD       0x04	/* AdvanSys Wide Board */
 #define ASC_SELECT_QUEUE_DEPTHS 0x08
 
 #define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)
 #define ASC_WIDE_BOARD(boardp)   ((boardp)->flags & ASC_IS_WIDE_BOARD)
 
-#define NO_ISA_DMA              0xff        /* No ISA DMA Channel Used */
+#define NO_ISA_DMA              0xff	/* No ISA DMA Channel Used */
 
-#define ASC_INFO_SIZE           128            /* advansys_info() line size */
+#define ASC_INFO_SIZE           128	/* advansys_info() line size */
 
 #ifdef CONFIG_PROC_FS
 /* /proc/scsi/advansys/[0...] related definitions */
@@ -3514,7 +3484,7 @@ typedef struct {
  *  REQPTIME(reqp) - reqp's time stamp value
  *  REQTIMESTAMP() - system time stamp value
  */
-typedef struct scsi_cmnd     REQ, *REQP;
+typedef struct scsi_cmnd REQ, *REQP;
 #define REQPNEXT(reqp)       ((REQP) ((reqp)->host_scribble))
 #define REQPNEXTP(reqp)      ((REQP *) &((reqp)->host_scribble))
 #define REQPTID(reqp)        ((reqp)->device->id)
@@ -3564,17 +3534,17 @@ typedef struct scsi_cmnd     REQ, *REQP;
 #define PCI_MAX_SLOT            0x1F
 #define PCI_MAX_BUS             0xFF
 #define PCI_IOADDRESS_MASK      0xFFFE
-#define ASC_PCI_DEVICE_ID_CNT   6       /* PCI Device ID count. */
+#define ASC_PCI_DEVICE_ID_CNT   6	/* PCI Device ID count. */
 
 #ifndef ADVANSYS_STATS
-#define ASC_STATS(shp, counter)
-#define ASC_STATS_ADD(shp, counter, count)
+#define ASC_STATS(shost, counter)
+#define ASC_STATS_ADD(shost, counter, count)
 #else /* ADVANSYS_STATS */
-#define ASC_STATS(shp, counter) \
-    (ASC_BOARDP(shp)->asc_stats.counter++)
+#define ASC_STATS(shost, counter) \
+    (ASC_BOARDP(shost)->asc_stats.counter++)
 
-#define ASC_STATS_ADD(shp, counter, count) \
-    (ASC_BOARDP(shp)->asc_stats.counter += (count))
+#define ASC_STATS_ADD(shost, counter, count) \
+    (ASC_BOARDP(shost)->asc_stats.counter += (count))
 #endif /* ADVANSYS_STATS */
 
 #define ASC_CEILING(val, unit) (((val) + ((unit) - 1))/(unit))
@@ -3617,7 +3587,6 @@ typedef struct scsi_cmnd     REQ, *REQP;
         printk((s), (a1), (a2), (a3), (a4)); \
     }
 
-
 #ifndef ADVANSYS_DEBUG
 
 #define ASC_DBG(lvl, s)
@@ -3746,7 +3715,6 @@ typedef struct scsi_cmnd     REQ, *REQP;
 
 #endif /* ADVANSYS_ASSERT */
 
-
 /*
  * --- Driver Structures
  */
@@ -3755,27 +3723,27 @@ typedef struct scsi_cmnd     REQ, *REQP;
 
 /* Per board statistics structure */
 struct asc_stats {
-    /* Driver Entrypoint Statistics */
-    ADV_DCNT queuecommand;    /* # calls to advansys_queuecommand() */
-    ADV_DCNT reset;           /* # calls to advansys_eh_bus_reset() */
-    ADV_DCNT biosparam;       /* # calls to advansys_biosparam() */
-    ADV_DCNT interrupt;       /* # advansys_interrupt() calls */
-    ADV_DCNT callback;        /* # calls to asc/adv_isr_callback() */
-    ADV_DCNT done;            /* # calls to request's scsi_done function */
-    ADV_DCNT build_error;     /* # asc/adv_build_req() ASC_ERROR returns. */
-    ADV_DCNT adv_build_noreq; /* # adv_build_req() adv_req_t alloc. fail. */
-    ADV_DCNT adv_build_nosg;  /* # adv_build_req() adv_sgblk_t alloc. fail. */
-    /* AscExeScsiQueue()/AdvExeScsiQueue() Statistics */
-    ADV_DCNT exe_noerror;     /* # ASC_NOERROR returns. */
-    ADV_DCNT exe_busy;        /* # ASC_BUSY returns. */
-    ADV_DCNT exe_error;       /* # ASC_ERROR returns. */
-    ADV_DCNT exe_unknown;     /* # unknown returns. */
-    /* Data Transfer Statistics */
-    ADV_DCNT cont_cnt;        /* # non-scatter-gather I/O requests received */
-    ADV_DCNT cont_xfer;       /* # contiguous transfer 512-bytes */
-    ADV_DCNT sg_cnt;          /* # scatter-gather I/O requests received */
-    ADV_DCNT sg_elem;         /* # scatter-gather elements */
-    ADV_DCNT sg_xfer;         /* # scatter-gather transfer 512-bytes */
+	/* Driver Entrypoint Statistics */
+	ADV_DCNT queuecommand;	/* # calls to advansys_queuecommand() */
+	ADV_DCNT reset;		/* # calls to advansys_eh_bus_reset() */
+	ADV_DCNT biosparam;	/* # calls to advansys_biosparam() */
+	ADV_DCNT interrupt;	/* # advansys_interrupt() calls */
+	ADV_DCNT callback;	/* # calls to asc/adv_isr_callback() */
+	ADV_DCNT done;		/* # calls to request's scsi_done function */
+	ADV_DCNT build_error;	/* # asc/adv_build_req() ASC_ERROR returns. */
+	ADV_DCNT adv_build_noreq;	/* # adv_build_req() adv_req_t alloc. fail. */
+	ADV_DCNT adv_build_nosg;	/* # adv_build_req() adv_sgblk_t alloc. fail. */
+	/* AscExeScsiQueue()/AdvExeScsiQueue() Statistics */
+	ADV_DCNT exe_noerror;	/* # ASC_NOERROR returns. */
+	ADV_DCNT exe_busy;	/* # ASC_BUSY returns. */
+	ADV_DCNT exe_error;	/* # ASC_ERROR returns. */
+	ADV_DCNT exe_unknown;	/* # unknown returns. */
+	/* Data Transfer Statistics */
+	ADV_DCNT cont_cnt;	/* # non-scatter-gather I/O requests received */
+	ADV_DCNT cont_xfer;	/* # contiguous transfer 512-bytes */
+	ADV_DCNT sg_cnt;	/* # scatter-gather I/O requests received */
+	ADV_DCNT sg_elem;	/* # scatter-gather elements */
+	ADV_DCNT sg_xfer;	/* # scatter-gather transfer 512-bytes */
 };
 #endif /* ADVANSYS_STATS */
 
@@ -3783,17 +3751,17 @@ struct asc_stats {
  * Request queuing structure
  */
 typedef struct asc_queue {
-    ADV_SCSI_BIT_ID_TYPE  q_tidmask;                /* queue mask */
-    REQP                  q_first[ADV_MAX_TID+1];   /* first queued request */
-    REQP                  q_last[ADV_MAX_TID+1];    /* last queued request */
+	ADV_SCSI_BIT_ID_TYPE q_tidmask;	/* queue mask */
+	REQP q_first[ADV_MAX_TID + 1];	/* first queued request */
+	REQP q_last[ADV_MAX_TID + 1];	/* last queued request */
 #ifdef ADVANSYS_STATS
-    short                 q_cur_cnt[ADV_MAX_TID+1]; /* current queue count */
-    short                 q_max_cnt[ADV_MAX_TID+1]; /* maximum queue count */
-    ADV_DCNT              q_tot_cnt[ADV_MAX_TID+1]; /* total enqueue count */
-    ADV_DCNT              q_tot_tim[ADV_MAX_TID+1]; /* total time queued */
-    ushort                q_max_tim[ADV_MAX_TID+1]; /* maximum time queued */
-    ushort                q_min_tim[ADV_MAX_TID+1]; /* minimum time queued */
-#endif /* ADVANSYS_STATS */
+	short q_cur_cnt[ADV_MAX_TID + 1];	/* current queue count */
+	short q_max_cnt[ADV_MAX_TID + 1];	/* maximum queue count */
+	ADV_DCNT q_tot_cnt[ADV_MAX_TID + 1];	/* total enqueue count */
+	ADV_DCNT q_tot_tim[ADV_MAX_TID + 1];	/* total time queued */
+	ushort q_max_tim[ADV_MAX_TID + 1];	/* maximum time queued */
+	ushort q_min_tim[ADV_MAX_TID + 1];	/* minimum time queued */
+#endif				/* ADVANSYS_STATS */
 } asc_queue_t;
 
 /*
@@ -3814,17 +3782,17 @@ typedef struct asc_queue {
  * Both structures must be 32 byte aligned.
  */
 typedef struct adv_sgblk {
-    ADV_SG_BLOCK        sg_block;     /* Sgblock structure. */
-    uchar               align[32];    /* Sgblock structure padding. */
-    struct adv_sgblk    *next_sgblkp; /* Next scatter-gather structure. */
+	ADV_SG_BLOCK sg_block;	/* Sgblock structure. */
+	uchar align[32];	/* Sgblock structure padding. */
+	struct adv_sgblk *next_sgblkp;	/* Next scatter-gather structure. */
 } adv_sgblk_t;
 
 typedef struct adv_req {
-    ADV_SCSI_REQ_Q      scsi_req_q;   /* Adv Library request structure. */
-    uchar               align[32];    /* Request structure padding. */
-    struct scsi_cmnd	*cmndp;       /* Mid-Level SCSI command pointer. */
-    adv_sgblk_t         *sgblkp;      /* Adv Library scatter-gather pointer. */
-    struct adv_req      *next_reqp;   /* Next Request Structure. */
+	ADV_SCSI_REQ_Q scsi_req_q;	/* Adv Library request structure. */
+	uchar align[32];	/* Request structure padding. */
+	struct scsi_cmnd *cmndp;	/* Mid-Level SCSI command pointer. */
+	adv_sgblk_t *sgblkp;	/* Adv Library scatter-gather pointer. */
+	struct adv_req *next_reqp;	/* Next Request Structure. */
 } adv_req_t;
 
 /*
@@ -3835,113 +3803,109 @@ typedef struct adv_req {
  * field. It is guaranteed to be allocated from DMA-able memory.
  */
 typedef struct asc_board {
-    int                  id;                    /* Board Id */
-    uint                 flags;                 /* Board flags */
-    union {
-        ASC_DVC_VAR      asc_dvc_var;           /* Narrow board */
-        ADV_DVC_VAR      adv_dvc_var;           /* Wide board */
-    } dvc_var;
-    union {
-        ASC_DVC_CFG      asc_dvc_cfg;           /* Narrow board */
-        ADV_DVC_CFG      adv_dvc_cfg;           /* Wide board */
-    } dvc_cfg;
-    ushort               asc_n_io_port;         /* Number I/O ports. */
-    asc_queue_t          active;                /* Active command queue */
-    asc_queue_t          waiting;               /* Waiting command queue */
-    asc_queue_t          done;                  /* Done command queue */
-    ADV_SCSI_BIT_ID_TYPE init_tidmask;          /* Target init./valid mask */
-    struct scsi_device	*device[ADV_MAX_TID+1]; /* Mid-Level Scsi Device */
-    ushort               reqcnt[ADV_MAX_TID+1]; /* Starvation request count */
-    ADV_SCSI_BIT_ID_TYPE queue_full;            /* Queue full mask */
-    ushort               queue_full_cnt[ADV_MAX_TID+1]; /* Queue full count */
-    union {
-        ASCEEP_CONFIG         asc_eep;          /* Narrow EEPROM config. */
-        ADVEEP_3550_CONFIG    adv_3550_eep;     /* 3550 EEPROM config. */
-        ADVEEP_38C0800_CONFIG adv_38C0800_eep;  /* 38C0800 EEPROM config. */
-        ADVEEP_38C1600_CONFIG adv_38C1600_eep;  /* 38C1600 EEPROM config. */
-    } eep_config;
-    ulong                last_reset;            /* Saved last reset time */
-    spinlock_t lock;                            /* Board spinlock */
+	int id;			/* Board Id */
+	uint flags;		/* Board flags */
+	union {
+		ASC_DVC_VAR asc_dvc_var;	/* Narrow board */
+		ADV_DVC_VAR adv_dvc_var;	/* Wide board */
+	} dvc_var;
+	union {
+		ASC_DVC_CFG asc_dvc_cfg;	/* Narrow board */
+		ADV_DVC_CFG adv_dvc_cfg;	/* Wide board */
+	} dvc_cfg;
+	ushort asc_n_io_port;	/* Number I/O ports. */
+	asc_queue_t active;	/* Active command queue */
+	asc_queue_t waiting;	/* Waiting command queue */
+	asc_queue_t done;	/* Done command queue */
+	ADV_SCSI_BIT_ID_TYPE init_tidmask;	/* Target init./valid mask */
+	struct scsi_device *device[ADV_MAX_TID + 1];	/* Mid-Level Scsi Device */
+	ushort reqcnt[ADV_MAX_TID + 1];	/* Starvation request count */
+	ADV_SCSI_BIT_ID_TYPE queue_full;	/* Queue full mask */
+	ushort queue_full_cnt[ADV_MAX_TID + 1];	/* Queue full count */
+	union {
+		ASCEEP_CONFIG asc_eep;	/* Narrow EEPROM config. */
+		ADVEEP_3550_CONFIG adv_3550_eep;	/* 3550 EEPROM config. */
+		ADVEEP_38C0800_CONFIG adv_38C0800_eep;	/* 38C0800 EEPROM config. */
+		ADVEEP_38C1600_CONFIG adv_38C1600_eep;	/* 38C1600 EEPROM config. */
+	} eep_config;
+	ulong last_reset;	/* Saved last reset time */
+	spinlock_t lock;	/* Board spinlock */
 #ifdef CONFIG_PROC_FS
-    /* /proc/scsi/advansys/[0...] */
-    char                 *prtbuf;               /* /proc print buffer */
-#endif /* CONFIG_PROC_FS */
+	/* /proc/scsi/advansys/[0...] */
+	char *prtbuf;		/* /proc print buffer */
+#endif				/* CONFIG_PROC_FS */
 #ifdef ADVANSYS_STATS
-    struct asc_stats     asc_stats;             /* Board statistics */
-#endif /* ADVANSYS_STATS */
-    /*
-     * The following fields are used only for Narrow Boards.
-     */
-    /* The following three structures must be in DMA-able memory. */
-    ASC_SCSI_REQ_Q       scsireqq;
-    ASC_CAP_INFO         cap_info;
-    ASC_SCSI_INQUIRY     inquiry;
-    uchar                sdtr_data[ASC_MAX_TID+1]; /* SDTR information */
-    /*
-     * The following fields are used only for Wide Boards.
-     */
-    void                 __iomem *ioremap_addr; /* I/O Memory remap address. */
-    ushort               ioport;                /* I/O Port address. */
-    ADV_CARR_T           *orig_carrp;           /* ADV_CARR_T memory block. */
-    adv_req_t            *orig_reqp;            /* adv_req_t memory block. */
-    adv_req_t            *adv_reqp;             /* Request structures. */
-    adv_sgblk_t          *adv_sgblkp;           /* Scatter-gather structures. */
-    ushort               bios_signature;        /* BIOS Signature. */
-    ushort               bios_version;          /* BIOS Version. */
-    ushort               bios_codeseg;          /* BIOS Code Segment. */
-    ushort               bios_codelen;          /* BIOS Code Segment Length. */
+	struct asc_stats asc_stats;	/* Board statistics */
+#endif				/* ADVANSYS_STATS */
+	/*
+	 * The following fields are used only for Narrow Boards.
+	 */
+	/* The following three structures must be in DMA-able memory. */
+	ASC_SCSI_REQ_Q scsireqq;
+	ASC_CAP_INFO cap_info;
+	ASC_SCSI_INQUIRY inquiry;
+	uchar sdtr_data[ASC_MAX_TID + 1];	/* SDTR information */
+	/*
+	 * The following fields are used only for Wide Boards.
+	 */
+	void __iomem *ioremap_addr;	/* I/O Memory remap address. */
+	ushort ioport;		/* I/O Port address. */
+	ADV_CARR_T *orig_carrp;	/* ADV_CARR_T memory block. */
+	adv_req_t *orig_reqp;	/* adv_req_t memory block. */
+	adv_req_t *adv_reqp;	/* Request structures. */
+	adv_sgblk_t *adv_sgblkp;	/* Scatter-gather structures. */
+	ushort bios_signature;	/* BIOS Signature. */
+	ushort bios_version;	/* BIOS Version. */
+	ushort bios_codeseg;	/* BIOS Code Segment. */
+	ushort bios_codelen;	/* BIOS Code Segment Length. */
 } asc_board_t;
 
 /*
  * PCI configuration structures
  */
-typedef struct _PCI_DATA_
-{
-    uchar    type;
-    uchar    bus;
-    uchar    slot;
-    uchar    func;
-    uchar    offset;
+typedef struct _PCI_DATA_ {
+	uchar type;
+	uchar bus;
+	uchar slot;
+	uchar func;
+	uchar offset;
 } PCI_DATA;
 
-typedef struct _PCI_DEVICE_
-{
-    ushort   vendorID;
-    ushort   deviceID;
-    ushort   slotNumber;
-    ushort   slotFound;
-    uchar    busNumber;
-    uchar    maxBusNumber;
-    uchar    devFunc;
-    ushort   startSlot;
-    ushort   endSlot;
-    uchar    bridge;
-    uchar    type;
+typedef struct _PCI_DEVICE_ {
+	ushort vendorID;
+	ushort deviceID;
+	ushort slotNumber;
+	ushort slotFound;
+	uchar busNumber;
+	uchar maxBusNumber;
+	uchar devFunc;
+	ushort startSlot;
+	ushort endSlot;
+	uchar bridge;
+	uchar type;
 } PCI_DEVICE;
 
-typedef struct _PCI_CONFIG_SPACE_
-{
-    ushort   vendorID;
-    ushort   deviceID;
-    ushort   command;
-    ushort   status;
-    uchar    revision;
-    uchar    classCode[3];
-    uchar    cacheSize;
-    uchar    latencyTimer;
-    uchar    headerType;
-    uchar    bist;
-    ADV_PADDR baseAddress[6];
-    ushort   reserved[4];
-    ADV_PADDR optionRomAddr;
-    ushort   reserved2[4];
-    uchar    irqLine;
-    uchar    irqPin;
-    uchar    minGnt;
-    uchar    maxLatency;
+typedef struct _PCI_CONFIG_SPACE_ {
+	ushort vendorID;
+	ushort deviceID;
+	ushort command;
+	ushort status;
+	uchar revision;
+	uchar classCode[3];
+	uchar cacheSize;
+	uchar latencyTimer;
+	uchar headerType;
+	uchar bist;
+	ADV_PADDR baseAddress[6];
+	ushort reserved[4];
+	ADV_PADDR optionRomAddr;
+	ushort reserved2[4];
+	uchar irqLine;
+	uchar irqPin;
+	uchar minGnt;
+	uchar maxLatency;
 } PCI_CONFIG_SPACE;
 
-
 /*
  * --- Driver Data
  */
@@ -3949,44 +3913,42 @@ typedef struct _PCI_CONFIG_SPACE_
 /* Note: All driver global data should be initialized. */
 
 /* Number of boards detected in system. */
-STATIC int asc_board_count = 0;
-STATIC struct Scsi_Host    *asc_host[ASC_NUM_BOARD_SUPPORTED] = { NULL };
+static int asc_board_count = 0;
+static struct Scsi_Host *asc_host[ASC_NUM_BOARD_SUPPORTED] = { NULL };
 
 /* Overrun buffer used by all narrow boards. */
-STATIC uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
+static uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
 
 /*
  * Global structures required to issue a command.
  */
-STATIC ASC_SCSI_Q asc_scsi_q = { { 0 } };
-STATIC ASC_SG_HEAD asc_sg_head = { 0 };
+static ASC_SCSI_Q asc_scsi_q = { {0} };
+static ASC_SG_HEAD asc_sg_head = { 0 };
 
 /* List of supported bus types. */
-STATIC ushort asc_bus[ASC_NUM_BUS] __initdata = {
-    ASC_IS_ISA,
-    ASC_IS_VL,
-    ASC_IS_EISA,
-    ASC_IS_PCI,
+static ushort asc_bus[ASC_NUM_BUS] __initdata = {
+	ASC_IS_ISA,
+	ASC_IS_VL,
+	ASC_IS_EISA,
+	ASC_IS_PCI,
 };
 
-STATIC int asc_iopflag = ASC_FALSE;
-STATIC int asc_ioport[ASC_NUM_IOPORT_PROBE] = { 0, 0, 0, 0 };
+static int asc_iopflag = ASC_FALSE;
+static int asc_ioport[ASC_NUM_IOPORT_PROBE] = { 0, 0, 0, 0 };
 
 #ifdef ADVANSYS_DEBUG
-STATIC char *
-asc_bus_name[ASC_NUM_BUS] = {
-    "ASC_IS_ISA",
-    "ASC_IS_VL",
-    "ASC_IS_EISA",
-    "ASC_IS_PCI",
+static char *asc_bus_name[ASC_NUM_BUS] = {
+	"ASC_IS_ISA",
+	"ASC_IS_VL",
+	"ASC_IS_EISA",
+	"ASC_IS_PCI",
 };
 
-STATIC int          asc_dbglvl = 3;
+static int asc_dbglvl = 3;
 #endif /* ADVANSYS_DEBUG */
 
 /* Declaration for Asc Library internal data referenced by driver. */
-STATIC PortAddr     _asc_def_iop_base[];
-
+static PortAddr _asc_def_iop_base[];
 
 /*
  * --- Driver Function Prototypes
@@ -3994,62 +3956,61 @@ STATIC PortAddr     _asc_def_iop_base[];
  * advansys.h contains function prototypes for functions global to Linux.
  */
 
-STATIC irqreturn_t advansys_interrupt(int, void *);
-STATIC int	  advansys_slave_configure(struct scsi_device *);
-STATIC void       asc_scsi_done_list(struct scsi_cmnd *);
-STATIC int        asc_execute_scsi_cmnd(struct scsi_cmnd *);
-STATIC int        asc_build_req(asc_board_t *, struct scsi_cmnd *);
-STATIC int        adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
-STATIC int        adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
-STATIC void       asc_isr_callback(ASC_DVC_VAR *, ASC_QDONE_INFO *);
-STATIC void       adv_isr_callback(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
-STATIC void       adv_async_callback(ADV_DVC_VAR *, uchar);
-STATIC void       asc_enqueue(asc_queue_t *, REQP, int);
-STATIC REQP       asc_dequeue(asc_queue_t *, int);
-STATIC REQP       asc_dequeue_list(asc_queue_t *, REQP *, int);
-STATIC int        asc_rmqueue(asc_queue_t *, REQP);
-STATIC void       asc_execute_queue(asc_queue_t *);
+static irqreturn_t advansys_interrupt(int, void *);
+static int advansys_slave_configure(struct scsi_device *);
+static void asc_scsi_done_list(struct scsi_cmnd *);
+static int asc_execute_scsi_cmnd(struct scsi_cmnd *);
+static int asc_build_req(asc_board_t *, struct scsi_cmnd *);
+static int adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
+static int adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
+static void asc_isr_callback(ASC_DVC_VAR *, ASC_QDONE_INFO *);
+static void adv_isr_callback(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
+static void adv_async_callback(ADV_DVC_VAR *, uchar);
+static void asc_enqueue(asc_queue_t *, REQP, int);
+static REQP asc_dequeue(asc_queue_t *, int);
+static REQP asc_dequeue_list(asc_queue_t *, REQP *, int);
+static int asc_rmqueue(asc_queue_t *, REQP);
+static void asc_execute_queue(asc_queue_t *);
 #ifdef CONFIG_PROC_FS
-STATIC int        asc_proc_copy(off_t, off_t, char *, int , char *, int);
-STATIC int        asc_prt_board_devices(struct Scsi_Host *, char *, int);
-STATIC int        asc_prt_adv_bios(struct Scsi_Host *, char *, int);
-STATIC int        asc_get_eeprom_string(ushort *serialnum, uchar *cp);
-STATIC int        asc_prt_asc_board_eeprom(struct Scsi_Host *, char *, int);
-STATIC int        asc_prt_adv_board_eeprom(struct Scsi_Host *, char *, int);
-STATIC int        asc_prt_driver_conf(struct Scsi_Host *, char *, int);
-STATIC int        asc_prt_asc_board_info(struct Scsi_Host *, char *, int);
-STATIC int        asc_prt_adv_board_info(struct Scsi_Host *, char *, int);
-STATIC int        asc_prt_line(char *, int, char *fmt, ...);
+static int asc_proc_copy(off_t, off_t, char *, int, char *, int);
+static int asc_prt_board_devices(struct Scsi_Host *, char *, int);
+static int asc_prt_adv_bios(struct Scsi_Host *, char *, int);
+static int asc_get_eeprom_string(ushort *serialnum, uchar *cp);
+static int asc_prt_asc_board_eeprom(struct Scsi_Host *, char *, int);
+static int asc_prt_adv_board_eeprom(struct Scsi_Host *, char *, int);
+static int asc_prt_driver_conf(struct Scsi_Host *, char *, int);
+static int asc_prt_asc_board_info(struct Scsi_Host *, char *, int);
+static int asc_prt_adv_board_info(struct Scsi_Host *, char *, int);
+static int asc_prt_line(char *, int, char *fmt, ...);
 #endif /* CONFIG_PROC_FS */
 
 /* Declaration for Asc Library internal functions referenced by driver. */
-STATIC int          AscFindSignature(PortAddr);
-STATIC ushort       AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
+static int AscFindSignature(PortAddr);
+static ushort AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
 
 /* Statistics function prototypes. */
 #ifdef ADVANSYS_STATS
 #ifdef CONFIG_PROC_FS
-STATIC int          asc_prt_board_stats(struct Scsi_Host *, char *, int);
-STATIC int          asc_prt_target_stats(struct Scsi_Host *, int, char *, int);
+static int asc_prt_board_stats(struct Scsi_Host *, char *, int);
+static int asc_prt_target_stats(struct Scsi_Host *, int, char *, int);
 #endif /* CONFIG_PROC_FS */
 #endif /* ADVANSYS_STATS */
 
 /* Debug function prototypes. */
 #ifdef ADVANSYS_DEBUG
-STATIC void         asc_prt_scsi_host(struct Scsi_Host *);
-STATIC void         asc_prt_scsi_cmnd(struct scsi_cmnd *);
-STATIC void         asc_prt_asc_dvc_cfg(ASC_DVC_CFG *);
-STATIC void         asc_prt_asc_dvc_var(ASC_DVC_VAR *);
-STATIC void         asc_prt_asc_scsi_q(ASC_SCSI_Q *);
-STATIC void         asc_prt_asc_qdone_info(ASC_QDONE_INFO *);
-STATIC void         asc_prt_adv_dvc_cfg(ADV_DVC_CFG *);
-STATIC void         asc_prt_adv_dvc_var(ADV_DVC_VAR *);
-STATIC void         asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *);
-STATIC void         asc_prt_adv_sgblock(int, ADV_SG_BLOCK *);
-STATIC void         asc_prt_hex(char *f, uchar *, int);
+static void asc_prt_scsi_host(struct Scsi_Host *);
+static void asc_prt_scsi_cmnd(struct scsi_cmnd *);
+static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *);
+static void asc_prt_asc_dvc_var(ASC_DVC_VAR *);
+static void asc_prt_asc_scsi_q(ASC_SCSI_Q *);
+static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *);
+static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *);
+static void asc_prt_adv_dvc_var(ADV_DVC_VAR *);
+static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *);
+static void asc_prt_adv_sgblock(int, ADV_SG_BLOCK *);
+static void asc_prt_hex(char *f, uchar *, int);
 #endif /* ADVANSYS_DEBUG */
 
-
 #ifdef CONFIG_PROC_FS
 /*
  * advansys_proc_info() - /proc/scsi/advansys/[0-(ASC_NUM_BOARD_SUPPORTED-1)]
@@ -4073,1389 +4034,210 @@ STATIC void         asc_prt_hex(char *f, uchar *, int);
  */
 static int
 advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
-		off_t offset, int length, int inout)
+		   off_t offset, int length, int inout)
 {
-    struct Scsi_Host    *shp;
-    asc_board_t         *boardp;
-    int                 i;
-    char                *cp;
-    int			cplen;
-    int                 cnt;
-    int                 totcnt;
-    int                 leftlen;
-    char                *curbuf;
-    off_t               advoffset;
+	struct Scsi_Host *shp;
+	asc_board_t *boardp;
+	int i;
+	char *cp;
+	int cplen;
+	int cnt;
+	int totcnt;
+	int leftlen;
+	char *curbuf;
+	off_t advoffset;
 #ifdef ADVANSYS_STATS
-    int                 tgt_id;
+	int tgt_id;
 #endif /* ADVANSYS_STATS */
 
-    ASC_DBG(1, "advansys_proc_info: begin\n");
-
-    /*
-     * User write not supported.
-     */
-    if (inout == TRUE) {
-        return(-ENOSYS);
-    }
-
-    /*
-     * User read of /proc/scsi/advansys/[0...] file.
-     */
-
-    /* Find the specified board. */
-    for (i = 0; i < asc_board_count; i++) {
-        if (asc_host[i]->host_no == shost->host_no) {
-            break;
-        }
-    }
-    if (i == asc_board_count) {
-        return(-ENOENT);
-    }
-
-    shp = asc_host[i];
-    boardp = ASC_BOARDP(shp);
+	ASC_DBG(1, "advansys_proc_info: begin\n");
 
-    /* Copy read data starting at the beginning of the buffer. */
-    *start = buffer;
-    curbuf = buffer;
-    advoffset = 0;
-    totcnt = 0;
-    leftlen = length;
-
-    /*
-     * Get board configuration information.
-     *
-     * advansys_info() returns the board string from its own static buffer.
-     */
-    cp = (char *) advansys_info(shp);
-    strcat(cp, "\n");
-    cplen = strlen(cp);
-    /* Copy board information. */
-    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-    totcnt += cnt;
-    leftlen -= cnt;
-    if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-    }
-    advoffset += cplen;
-    curbuf += cnt;
+	/*
+	 * User write not supported.
+	 */
+	if (inout == TRUE) {
+		return (-ENOSYS);
+	}
 
-    /*
-     * Display Wide Board BIOS Information.
-     */
-    if (ASC_WIDE_BOARD(boardp)) {
-        cp = boardp->prtbuf;
-        cplen = asc_prt_adv_bios(shp, cp, ASC_PRTBUF_SIZE);
-        ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
-        cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-        totcnt += cnt;
-        leftlen -= cnt;
-        if (leftlen == 0) {
-            ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-            return totcnt;
-        }
-        advoffset += cplen;
-        curbuf += cnt;
-    }
+	/*
+	 * User read of /proc/scsi/advansys/[0...] file.
+	 */
 
-    /*
-     * Display driver information for each device attached to the board.
-     */
-    cp = boardp->prtbuf;
-    cplen = asc_prt_board_devices(shp, cp, ASC_PRTBUF_SIZE);
-    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
-    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-    totcnt += cnt;
-    leftlen -= cnt;
-    if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-    }
-    advoffset += cplen;
-    curbuf += cnt;
+	/* Find the specified board. */
+	for (i = 0; i < asc_board_count; i++) {
+		if (asc_host[i]->host_no == shost->host_no) {
+			break;
+		}
+	}
+	if (i == asc_board_count) {
+		return (-ENOENT);
+	}
 
-    /*
-     * Display EEPROM configuration for the board.
-     */
-    cp = boardp->prtbuf;
-    if (ASC_NARROW_BOARD(boardp)) {
-        cplen = asc_prt_asc_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
-    } else {
-        cplen = asc_prt_adv_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
-    }
-    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
-    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-    totcnt += cnt;
-    leftlen -= cnt;
-    if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-    }
-    advoffset += cplen;
-    curbuf += cnt;
+	shp = asc_host[i];
+	boardp = ASC_BOARDP(shp);
+
+	/* Copy read data starting at the beginning of the buffer. */
+	*start = buffer;
+	curbuf = buffer;
+	advoffset = 0;
+	totcnt = 0;
+	leftlen = length;
+
+	/*
+	 * Get board configuration information.
+	 *
+	 * advansys_info() returns the board string from its own static buffer.
+	 */
+	cp = (char *)advansys_info(shp);
+	strcat(cp, "\n");
+	cplen = strlen(cp);
+	/* Copy board information. */
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
+	}
+	advoffset += cplen;
+	curbuf += cnt;
+
+	/*
+	 * Display Wide Board BIOS Information.
+	 */
+	if (ASC_WIDE_BOARD(boardp)) {
+		cp = boardp->prtbuf;
+		cplen = asc_prt_adv_bios(shp, cp, ASC_PRTBUF_SIZE);
+		ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+		cnt =
+		    asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
+				  cplen);
+		totcnt += cnt;
+		leftlen -= cnt;
+		if (leftlen == 0) {
+			ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+			return totcnt;
+		}
+		advoffset += cplen;
+		curbuf += cnt;
+	}
 
-    /*
-     * Display driver configuration and information for the board.
-     */
-    cp = boardp->prtbuf;
-    cplen = asc_prt_driver_conf(shp, cp, ASC_PRTBUF_SIZE);
-    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
-    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-    totcnt += cnt;
-    leftlen -= cnt;
-    if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-    }
-    advoffset += cplen;
-    curbuf += cnt;
+	/*
+	 * Display driver information for each device attached to the board.
+	 */
+	cp = boardp->prtbuf;
+	cplen = asc_prt_board_devices(shp, cp, ASC_PRTBUF_SIZE);
+	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
+	}
+	advoffset += cplen;
+	curbuf += cnt;
+
+	/*
+	 * Display EEPROM configuration for the board.
+	 */
+	cp = boardp->prtbuf;
+	if (ASC_NARROW_BOARD(boardp)) {
+		cplen = asc_prt_asc_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
+	} else {
+		cplen = asc_prt_adv_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
+	}
+	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
+	}
+	advoffset += cplen;
+	curbuf += cnt;
+
+	/*
+	 * Display driver configuration and information for the board.
+	 */
+	cp = boardp->prtbuf;
+	cplen = asc_prt_driver_conf(shp, cp, ASC_PRTBUF_SIZE);
+	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
+	}
+	advoffset += cplen;
+	curbuf += cnt;
 
 #ifdef ADVANSYS_STATS
-    /*
-     * Display driver statistics for the board.
-     */
-    cp = boardp->prtbuf;
-    cplen = asc_prt_board_stats(shp, cp, ASC_PRTBUF_SIZE);
-    ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
-    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-    totcnt += cnt;
-    leftlen -= cnt;
-    if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-    }
-    advoffset += cplen;
-    curbuf += cnt;
-
-    /*
-     * Display driver statistics for each target.
-     */
-    for (tgt_id = 0; tgt_id <= ADV_MAX_TID; tgt_id++) {
-      cp = boardp->prtbuf;
-      cplen = asc_prt_target_stats(shp, tgt_id, cp, ASC_PRTBUF_SIZE);
-      ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
-      cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-      totcnt += cnt;
-      leftlen -= cnt;
-      if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-      }
-      advoffset += cplen;
-      curbuf += cnt;
-    }
+	/*
+	 * Display driver statistics for the board.
+	 */
+	cp = boardp->prtbuf;
+	cplen = asc_prt_board_stats(shp, cp, ASC_PRTBUF_SIZE);
+	ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
+	}
+	advoffset += cplen;
+	curbuf += cnt;
+
+	/*
+	 * Display driver statistics for each target.
+	 */
+	for (tgt_id = 0; tgt_id <= ADV_MAX_TID; tgt_id++) {
+		cp = boardp->prtbuf;
+		cplen = asc_prt_target_stats(shp, tgt_id, cp, ASC_PRTBUF_SIZE);
+		ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
+		cnt =
+		    asc_proc_copy(advoffset, offset, curbuf, leftlen, cp,
+				  cplen);
+		totcnt += cnt;
+		leftlen -= cnt;
+		if (leftlen == 0) {
+			ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+			return totcnt;
+		}
+		advoffset += cplen;
+		curbuf += cnt;
+	}
 #endif /* ADVANSYS_STATS */
 
-    /*
-     * Display Asc Library dynamic configuration information
-     * for the board.
-     */
-    cp = boardp->prtbuf;
-    if (ASC_NARROW_BOARD(boardp)) {
-        cplen = asc_prt_asc_board_info(shp, cp, ASC_PRTBUF_SIZE);
-    } else {
-        cplen = asc_prt_adv_board_info(shp, cp, ASC_PRTBUF_SIZE);
-    }
-    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
-    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
-    totcnt += cnt;
-    leftlen -= cnt;
-    if (leftlen == 0) {
-        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-        return totcnt;
-    }
-    advoffset += cplen;
-    curbuf += cnt;
-
-    ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
-
-    return totcnt;
-}
-#endif /* CONFIG_PROC_FS */
-
-/*
- * advansys_detect()
- *
- * Detect function for AdvanSys adapters.
- *
- * Argument is a pointer to the host driver's scsi_hosts entry.
- *
- * Return number of adapters found.
- *
- * Note: Because this function is called during system initialization
- * it must not call SCSI mid-level functions including scsi_malloc()
- * and scsi_free().
- */
-static int __init
-advansys_detect(struct scsi_host_template *tpnt)
-{
-    static int          detect_called = ASC_FALSE;
-    int                 iop;
-    int                 bus;
-    struct Scsi_Host    *shp = NULL;
-    asc_board_t         *boardp = NULL;
-    ASC_DVC_VAR         *asc_dvc_varp = NULL;
-    ADV_DVC_VAR         *adv_dvc_varp = NULL;
-    adv_sgblk_t         *sgp = NULL;
-    int                 ioport = 0;
-    int                 share_irq = FALSE;
-    int                 iolen = 0;
-    struct device	*dev = NULL;
-#ifdef CONFIG_PCI
-    int                 pci_init_search = 0;
-    struct pci_dev      *pci_devicep[ASC_NUM_BOARD_SUPPORTED];
-    int                 pci_card_cnt_max = 0;
-    int                 pci_card_cnt = 0;
-    struct pci_dev      *pci_devp = NULL;
-    int                 pci_device_id_cnt = 0;
-    unsigned int        pci_device_id[ASC_PCI_DEVICE_ID_CNT] = {
-                                    PCI_DEVICE_ID_ASP_1200A,
-                                    PCI_DEVICE_ID_ASP_ABP940,
-                                    PCI_DEVICE_ID_ASP_ABP940U,
-                                    PCI_DEVICE_ID_ASP_ABP940UW,
-                                    PCI_DEVICE_ID_38C0800_REV1,
-                                    PCI_DEVICE_ID_38C1600_REV1
-                        };
-    ADV_PADDR           pci_memory_address;
-#endif /* CONFIG_PCI */
-    int                 warn_code, err_code;
-    int                 ret;
-
-    if (detect_called == ASC_FALSE) {
-        detect_called = ASC_TRUE;
-    } else {
-        printk("AdvanSys SCSI: advansys_detect() multiple calls ignored\n");
-        return 0;
-    }
-
-    ASC_DBG(1, "advansys_detect: begin\n");
-
-    asc_board_count = 0;
-
-    /*
-     * If I/O port probing has been modified, then verify and
-     * clean-up the 'asc_ioport' list.
-     */
-    if (asc_iopflag == ASC_TRUE) {
-        for (ioport = 0; ioport < ASC_NUM_IOPORT_PROBE; ioport++) {
-            ASC_DBG2(1, "advansys_detect: asc_ioport[%d] 0x%x\n",
-                ioport, asc_ioport[ioport]);
-            if (asc_ioport[ioport] != 0) {
-                for (iop = 0; iop < ASC_IOADR_TABLE_MAX_IX; iop++) {
-                    if (_asc_def_iop_base[iop] == asc_ioport[ioport]) {
-                        break;
-                    }
-                }
-                if (iop == ASC_IOADR_TABLE_MAX_IX) {
-                    printk(
-"AdvanSys SCSI: specified I/O Port 0x%X is invalid\n",
-                        asc_ioport[ioport]);
-                    asc_ioport[ioport] = 0;
-                }
-            }
-        }
-        ioport = 0;
-    }
-
-    for (bus = 0; bus < ASC_NUM_BUS; bus++) {
-
-        ASC_DBG2(1, "advansys_detect: bus search type %d (%s)\n",
-            bus, asc_bus_name[bus]);
-        iop = 0;
-
-        while (asc_board_count < ASC_NUM_BOARD_SUPPORTED) {
-
-            ASC_DBG1(2, "advansys_detect: asc_board_count %d\n",
-                asc_board_count);
-
-            switch (asc_bus[bus]) {
-            case ASC_IS_ISA:
-            case ASC_IS_VL:
-#ifdef CONFIG_ISA
-                if (asc_iopflag == ASC_FALSE) {
-                    iop = AscSearchIOPortAddr(iop, asc_bus[bus]);
-                } else {
-                    /*
-                     * ISA and VL I/O port scanning has either been
-                     * eliminated or limited to selected ports on
-                     * the LILO command line, /etc/lilo.conf, or
-                     * by setting variables when the module was loaded.
-                     */
-                    ASC_DBG(1, "advansys_detect: I/O port scanning modified\n");
-                ioport_try_again:
-                    iop = 0;
-                    for (; ioport < ASC_NUM_IOPORT_PROBE; ioport++) {
-                        if ((iop = asc_ioport[ioport]) != 0) {
-                            break;
-                        }
-                    }
-                    if (iop) {
-                        ASC_DBG1(1,
-                                "advansys_detect: probing I/O port 0x%x...\n",
-                            iop);
-			if (!request_region(iop, ASC_IOADR_GAP, "advansys")){
-                            printk(
-"AdvanSys SCSI: specified I/O Port 0x%X is busy\n", iop);
-                            /* Don't try this I/O port twice. */
-                            asc_ioport[ioport] = 0;
-                            goto ioport_try_again;
-                        } else if (AscFindSignature(iop) == ASC_FALSE) {
-                            printk(
-"AdvanSys SCSI: specified I/O Port 0x%X has no adapter\n", iop);
-                            /* Don't try this I/O port twice. */
-			    release_region(iop, ASC_IOADR_GAP);
-                            asc_ioport[ioport] = 0;
-                            goto ioport_try_again;
-                        } else {
-                            /*
-                             * If this isn't an ISA board, then it must be
-                             * a VL board. If currently looking an ISA
-                             * board is being looked for then try for
-                             * another ISA board in 'asc_ioport'.
-                             */
-                            if (asc_bus[bus] == ASC_IS_ISA &&
-                                (AscGetChipVersion(iop, ASC_IS_ISA) &
-                                 ASC_CHIP_VER_ISA_BIT) == 0) {
-                                 /*
-                                  * Don't clear 'asc_ioport[ioport]'. Try
-                                  * this board again for VL. Increment
-                                  * 'ioport' past this board.
-                                  */
-                                 ioport++;
-				 release_region(iop, ASC_IOADR_GAP);
-                                 goto ioport_try_again;
-                            }
-                        }
-                        /*
-                         * This board appears good, don't try the I/O port
-                         * again by clearing its value. Increment 'ioport'
-                         * for the next iteration.
-                         */
-                        asc_ioport[ioport++] = 0;
-                    }
-                }
-#endif /* CONFIG_ISA */
-                break;
-
-            case ASC_IS_EISA:
-#ifdef CONFIG_ISA
-                iop = AscSearchIOPortAddr(iop, asc_bus[bus]);
-#endif /* CONFIG_ISA */
-                break;
-
-            case ASC_IS_PCI:
-#ifdef CONFIG_PCI
-                if (pci_init_search == 0) {
-                    int i, j;
-
-                    pci_init_search = 1;
-
-                    /* Find all PCI cards. */
-                    while (pci_device_id_cnt < ASC_PCI_DEVICE_ID_CNT) {
-                        if ((pci_devp = pci_find_device(PCI_VENDOR_ID_ASP,
-                            pci_device_id[pci_device_id_cnt], pci_devp)) ==
-                            NULL) {
-                            pci_device_id_cnt++;
-                        } else {
-                            if (pci_enable_device(pci_devp) == 0) {
-                                pci_devicep[pci_card_cnt_max++] = pci_devp;
-                            }
-                        }
-                    }
-
-                    /*
-                     * Sort PCI cards in ascending order by PCI Bus, Slot,
-                     * and Device Number.
-                     */
-                    for (i = 0; i < pci_card_cnt_max - 1; i++)
-                    {
-                        for (j = i + 1; j < pci_card_cnt_max; j++) {
-                            if ((pci_devicep[j]->bus->number <
-                                 pci_devicep[i]->bus->number) ||
-                                ((pci_devicep[j]->bus->number ==
-                                  pci_devicep[i]->bus->number) &&
-                                  (pci_devicep[j]->devfn <
-                                   pci_devicep[i]->devfn))) {
-                                pci_devp = pci_devicep[i];
-                                pci_devicep[i] = pci_devicep[j];
-                                pci_devicep[j] = pci_devp;
-                            }
-                        }
-                    }
-
-                    pci_card_cnt = 0;
-                } else {
-                    pci_card_cnt++;
-                }
-
-                if (pci_card_cnt == pci_card_cnt_max) {
-                    iop = 0;
-                } else {
-                    pci_devp = pci_devicep[pci_card_cnt];
-
-                    ASC_DBG2(2,
-                        "advansys_detect: devfn %d, bus number %d\n",
-                        pci_devp->devfn, pci_devp->bus->number);
-                    iop = pci_resource_start(pci_devp, 0);
-                    ASC_DBG2(1,
-                        "advansys_detect: vendorID %X, deviceID %X\n",
-                        pci_devp->vendor, pci_devp->device);
-                    ASC_DBG2(2, "advansys_detect: iop %X, irqLine %d\n",
-                        iop, pci_devp->irq);
-                }
-		if(pci_devp)
-		    dev = &pci_devp->dev;
-
-#endif /* CONFIG_PCI */
-                break;
-
-            default:
-                ASC_PRINT1("advansys_detect: unknown bus type: %d\n",
-                    asc_bus[bus]);
-                break;
-            }
-            ASC_DBG1(1, "advansys_detect: iop 0x%x\n", iop);
-
-            /*
-             * Adapter not found, try next bus type.
-             */
-            if (iop == 0) {
-                break;
-            }
-
-            /*
-             * Adapter found.
-             *
-             * Register the adapter, get its configuration, and
-             * initialize it.
-             */
-            ASC_DBG(2, "advansys_detect: scsi_register()\n");
-            shp = scsi_register(tpnt, sizeof(asc_board_t));
-
-            if (shp == NULL) {
-                continue;
-            }
-
-            /* Save a pointer to the Scsi_Host of each board found. */
-            asc_host[asc_board_count++] = shp;
-
-            /* Initialize private per board data */
-            boardp = ASC_BOARDP(shp);
-            memset(boardp, 0, sizeof(asc_board_t));
-            boardp->id = asc_board_count - 1;
-
-            /* Initialize spinlock. */
-            spin_lock_init(&boardp->lock);
-
-            /*
-             * Handle both narrow and wide boards.
-             *
-             * If a Wide board was detected, set the board structure
-             * wide board flag. Set-up the board structure based on
-             * the board type.
-             */
-#ifdef CONFIG_PCI
-            if (asc_bus[bus] == ASC_IS_PCI &&
-                (pci_devp->device == PCI_DEVICE_ID_ASP_ABP940UW ||
-                 pci_devp->device == PCI_DEVICE_ID_38C0800_REV1 ||
-                 pci_devp->device == PCI_DEVICE_ID_38C1600_REV1))
-            {
-                boardp->flags |= ASC_IS_WIDE_BOARD;
-            }
-#endif /* CONFIG_PCI */
-
-            if (ASC_NARROW_BOARD(boardp)) {
-                ASC_DBG(1, "advansys_detect: narrow board\n");
-                asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-                asc_dvc_varp->bus_type = asc_bus[bus];
-                asc_dvc_varp->drv_ptr = boardp;
-                asc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;
-                asc_dvc_varp->cfg->overrun_buf = &overrun_buf[0];
-                asc_dvc_varp->iop_base = iop;
-                asc_dvc_varp->isr_callback = asc_isr_callback;
-            } else {
-                ASC_DBG(1, "advansys_detect: wide board\n");
-                adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-                adv_dvc_varp->drv_ptr = boardp;
-                adv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;
-                adv_dvc_varp->isr_callback = adv_isr_callback;
-                adv_dvc_varp->async_callback = adv_async_callback;
-#ifdef CONFIG_PCI
-                if (pci_devp->device == PCI_DEVICE_ID_ASP_ABP940UW)
-                {
-                    ASC_DBG(1, "advansys_detect: ASC-3550\n");
-                    adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;
-                } else if (pci_devp->device == PCI_DEVICE_ID_38C0800_REV1)
-                {
-                    ASC_DBG(1, "advansys_detect: ASC-38C0800\n");
-                    adv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;
-                } else
-                {
-                    ASC_DBG(1, "advansys_detect: ASC-38C1600\n");
-                    adv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;
-                }
-#endif /* CONFIG_PCI */
-
-                /*
-                 * Map the board's registers into virtual memory for
-                 * PCI slave access. Only memory accesses are used to
-                 * access the board's registers.
-                 *
-                 * Note: The PCI register base address is not always
-                 * page aligned, but the address passed to ioremap()
-                 * must be page aligned. It is guaranteed that the
-                 * PCI register base address will not cross a page
-                 * boundary.
-                 */
-                if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-                {
-                    iolen = ADV_3550_IOLEN;
-                } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-                {
-                    iolen = ADV_38C0800_IOLEN;
-                } else
-                {
-                    iolen = ADV_38C1600_IOLEN;
-                }
-#ifdef CONFIG_PCI
-                pci_memory_address = pci_resource_start(pci_devp, 1);
-                ASC_DBG1(1, "advansys_detect: pci_memory_address: 0x%lx\n",
-                    (ulong) pci_memory_address);
-                if ((boardp->ioremap_addr =
-                    ioremap(pci_memory_address & PAGE_MASK,
-                         PAGE_SIZE)) == 0) {
-                   ASC_PRINT3(
-"advansys_detect: board %d: ioremap(%x, %d) returned NULL\n",
-                       boardp->id, pci_memory_address, iolen);
-                   scsi_unregister(shp);
-                   asc_board_count--;
-                   continue;
-                }
-                ASC_DBG1(1, "advansys_detect: ioremap_addr: 0x%lx\n",
-                    (ulong) boardp->ioremap_addr);
-                adv_dvc_varp->iop_base = (AdvPortAddr)
-                    (boardp->ioremap_addr +
-                     (pci_memory_address - (pci_memory_address & PAGE_MASK)));
-                ASC_DBG1(1, "advansys_detect: iop_base: 0x%lx\n",
-                    adv_dvc_varp->iop_base);
-#endif /* CONFIG_PCI */
-
-                /*
-                 * Even though it isn't used to access wide boards, other
-                 * than for the debug line below, save I/O Port address so
-                 * that it can be reported.
-                 */
-                boardp->ioport = iop;
-
-                ASC_DBG2(1,
-"advansys_detect: iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\n",
-                    (ushort) inp(iop + 1), (ushort) inpw(iop));
-            }
-
-#ifdef CONFIG_PROC_FS
-            /*
-             * Allocate buffer for printing information from
-             * /proc/scsi/advansys/[0...].
-             */
-            if ((boardp->prtbuf =
-                kmalloc(ASC_PRTBUF_SIZE, GFP_ATOMIC)) == NULL) {
-                ASC_PRINT3(
-"advansys_detect: board %d: kmalloc(%d, %d) returned NULL\n",
-                    boardp->id, ASC_PRTBUF_SIZE, GFP_ATOMIC);
-                scsi_unregister(shp);
-                asc_board_count--;
-                continue;
-            }
-#endif /* CONFIG_PROC_FS */
-
-            if (ASC_NARROW_BOARD(boardp)) {
-		asc_dvc_varp->cfg->dev = dev;
-		/*
-                 * Set the board bus type and PCI IRQ before
-                 * calling AscInitGetConfig().
-                 */
-                switch (asc_dvc_varp->bus_type) {
-#ifdef CONFIG_ISA
-                case ASC_IS_ISA:
-                    shp->unchecked_isa_dma = TRUE;
-                    share_irq = FALSE;
-                    break;
-                case ASC_IS_VL:
-                    shp->unchecked_isa_dma = FALSE;
-                    share_irq = FALSE;
-                    break;
-                case ASC_IS_EISA:
-                    shp->unchecked_isa_dma = FALSE;
-                    share_irq = TRUE;
-                    break;
-#endif /* CONFIG_ISA */
-#ifdef CONFIG_PCI
-                case ASC_IS_PCI:
-                    shp->irq = asc_dvc_varp->irq_no = pci_devp->irq;
-                    asc_dvc_varp->cfg->pci_slot_info =
-                        ASC_PCI_MKID(pci_devp->bus->number,
-                            PCI_SLOT(pci_devp->devfn),
-                            PCI_FUNC(pci_devp->devfn));
-                    shp->unchecked_isa_dma = FALSE;
-                    share_irq = TRUE;
-                    break;
-#endif /* CONFIG_PCI */
-                default:
-                    ASC_PRINT2(
-"advansys_detect: board %d: unknown adapter type: %d\n",
-                        boardp->id, asc_dvc_varp->bus_type);
-                    shp->unchecked_isa_dma = TRUE;
-                    share_irq = FALSE;
-                    break;
-                }
-            } else {
-                adv_dvc_varp->cfg->dev = dev;
-                /*
-                 * For Wide boards set PCI information before calling
-                 * AdvInitGetConfig().
-                 */
-#ifdef CONFIG_PCI
-                shp->irq = adv_dvc_varp->irq_no = pci_devp->irq;
-                adv_dvc_varp->cfg->pci_slot_info =
-                    ASC_PCI_MKID(pci_devp->bus->number,
-                        PCI_SLOT(pci_devp->devfn),
-                        PCI_FUNC(pci_devp->devfn));
-                shp->unchecked_isa_dma = FALSE;
-                share_irq = TRUE;
-#endif /* CONFIG_PCI */
-            }
-
-            /*
-             * Read the board configuration.
-             */
-            if (ASC_NARROW_BOARD(boardp)) {
-                 /*
-                  * NOTE: AscInitGetConfig() may change the board's
-                  * bus_type value. The asc_bus[bus] value should no
-                  * longer be used. If the bus_type field must be
-                  * referenced only use the bit-wise AND operator "&".
-                  */
-                ASC_DBG(2, "advansys_detect: AscInitGetConfig()\n");
-                switch(ret = AscInitGetConfig(asc_dvc_varp)) {
-                case 0:    /* No error */
-                    break;
-                case ASC_WARN_IO_PORT_ROTATE:
-                    ASC_PRINT1(
-"AscInitGetConfig: board %d: I/O port address modified\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_AUTO_CONFIG:
-                    ASC_PRINT1(
-"AscInitGetConfig: board %d: I/O port increment switch enabled\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_EEPROM_CHKSUM:
-                    ASC_PRINT1(
-"AscInitGetConfig: board %d: EEPROM checksum error\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_IRQ_MODIFIED:
-                    ASC_PRINT1(
-"AscInitGetConfig: board %d: IRQ modified\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_CMD_QNG_CONFLICT:
-                    ASC_PRINT1(
-"AscInitGetConfig: board %d: tag queuing enabled w/o disconnects\n",
-                        boardp->id);
-                    break;
-                default:
-                    ASC_PRINT2(
-"AscInitGetConfig: board %d: unknown warning: 0x%x\n",
-                        boardp->id, ret);
-                    break;
-                }
-                if ((err_code = asc_dvc_varp->err_code) != 0) {
-                    ASC_PRINT3(
-"AscInitGetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
-                        boardp->id, asc_dvc_varp->init_state,
-                        asc_dvc_varp->err_code);
-                }
-            } else {
-                ASC_DBG(2, "advansys_detect: AdvInitGetConfig()\n");
-                if ((ret = AdvInitGetConfig(adv_dvc_varp)) != 0) {
-                    ASC_PRINT2("AdvInitGetConfig: board %d: warning: 0x%x\n",
-                        boardp->id, ret);
-                }
-                if ((err_code = adv_dvc_varp->err_code) != 0) {
-                    ASC_PRINT2(
-"AdvInitGetConfig: board %d error: err_code 0x%x\n",
-                        boardp->id, adv_dvc_varp->err_code);
-                }
-            }
-
-            if (err_code != 0) {
-#ifdef CONFIG_PROC_FS
-                kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-                scsi_unregister(shp);
-                asc_board_count--;
-                continue;
-            }
-
-            /*
-             * Save the EEPROM configuration so that it can be displayed
-             * from /proc/scsi/advansys/[0...].
-             */
-            if (ASC_NARROW_BOARD(boardp)) {
-
-                ASCEEP_CONFIG *ep;
-
-                /*
-                 * Set the adapter's target id bit in the 'init_tidmask' field.
-                 */
-                boardp->init_tidmask |=
-                    ADV_TID_TO_TIDMASK(asc_dvc_varp->cfg->chip_scsi_id);
-
-                /*
-                 * Save EEPROM settings for the board.
-                 */
-                ep = &boardp->eep_config.asc_eep;
-
-                ep->init_sdtr = asc_dvc_varp->cfg->sdtr_enable;
-                ep->disc_enable = asc_dvc_varp->cfg->disc_enable;
-                ep->use_cmd_qng = asc_dvc_varp->cfg->cmd_qng_enabled;
-                ASC_EEP_SET_DMA_SPD(ep, asc_dvc_varp->cfg->isa_dma_speed);
-                ep->start_motor = asc_dvc_varp->start_motor;
-                ep->cntl = asc_dvc_varp->dvc_cntl;
-                ep->no_scam = asc_dvc_varp->no_scam;
-                ep->max_total_qng = asc_dvc_varp->max_total_qng;
-                ASC_EEP_SET_CHIP_ID(ep, asc_dvc_varp->cfg->chip_scsi_id);
-                /* 'max_tag_qng' is set to the same value for every device. */
-                ep->max_tag_qng = asc_dvc_varp->cfg->max_tag_qng[0];
-                ep->adapter_info[0] = asc_dvc_varp->cfg->adapter_info[0];
-                ep->adapter_info[1] = asc_dvc_varp->cfg->adapter_info[1];
-                ep->adapter_info[2] = asc_dvc_varp->cfg->adapter_info[2];
-                ep->adapter_info[3] = asc_dvc_varp->cfg->adapter_info[3];
-                ep->adapter_info[4] = asc_dvc_varp->cfg->adapter_info[4];
-                ep->adapter_info[5] = asc_dvc_varp->cfg->adapter_info[5];
-
-               /*
-                * Modify board configuration.
-                */
-                ASC_DBG(2, "advansys_detect: AscInitSetConfig()\n");
-                switch (ret = AscInitSetConfig(asc_dvc_varp)) {
-                case 0:    /* No error. */
-                    break;
-                case ASC_WARN_IO_PORT_ROTATE:
-                    ASC_PRINT1(
-"AscInitSetConfig: board %d: I/O port address modified\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_AUTO_CONFIG:
-                    ASC_PRINT1(
-"AscInitSetConfig: board %d: I/O port increment switch enabled\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_EEPROM_CHKSUM:
-                    ASC_PRINT1(
-"AscInitSetConfig: board %d: EEPROM checksum error\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_IRQ_MODIFIED:
-                    ASC_PRINT1(
-"AscInitSetConfig: board %d: IRQ modified\n",
-                        boardp->id);
-                    break;
-                case ASC_WARN_CMD_QNG_CONFLICT:
-                    ASC_PRINT1(
-"AscInitSetConfig: board %d: tag queuing w/o disconnects\n",
-                        boardp->id);
-                    break;
-                default:
-                    ASC_PRINT2(
-"AscInitSetConfig: board %d: unknown warning: 0x%x\n",
-                        boardp->id, ret);
-                    break;
-                }
-                if (asc_dvc_varp->err_code != 0) {
-                    ASC_PRINT3(
-"AscInitSetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
-                        boardp->id, asc_dvc_varp->init_state,
-                        asc_dvc_varp->err_code);
-#ifdef CONFIG_PROC_FS
-                    kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-                    scsi_unregister(shp);
-                    asc_board_count--;
-                    continue;
-                }
-
-                /*
-                 * Finish initializing the 'Scsi_Host' structure.
-                 */
-                /* AscInitSetConfig() will set the IRQ for non-PCI boards. */
-                if ((asc_dvc_varp->bus_type & ASC_IS_PCI) == 0) {
-                    shp->irq = asc_dvc_varp->irq_no;
-                }
-            } else {
-                ADVEEP_3550_CONFIG      *ep_3550;
-                ADVEEP_38C0800_CONFIG   *ep_38C0800;
-                ADVEEP_38C1600_CONFIG   *ep_38C1600;
-
-                /*
-                 * Save Wide EEP Configuration Information.
-                 */
-                if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-                {
-                    ep_3550 = &boardp->eep_config.adv_3550_eep;
-
-                    ep_3550->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
-                    ep_3550->max_host_qng = adv_dvc_varp->max_host_qng;
-                    ep_3550->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
-                    ep_3550->termination = adv_dvc_varp->cfg->termination;
-                    ep_3550->disc_enable = adv_dvc_varp->cfg->disc_enable;
-                    ep_3550->bios_ctrl = adv_dvc_varp->bios_ctrl;
-                    ep_3550->wdtr_able = adv_dvc_varp->wdtr_able;
-                    ep_3550->sdtr_able = adv_dvc_varp->sdtr_able;
-                    ep_3550->ultra_able = adv_dvc_varp->ultra_able;
-                    ep_3550->tagqng_able = adv_dvc_varp->tagqng_able;
-                    ep_3550->start_motor = adv_dvc_varp->start_motor;
-                    ep_3550->scsi_reset_delay = adv_dvc_varp->scsi_reset_wait;
-                    ep_3550->serial_number_word1 =
-                        adv_dvc_varp->cfg->serial1;
-                    ep_3550->serial_number_word2 =
-                        adv_dvc_varp->cfg->serial2;
-                    ep_3550->serial_number_word3 =
-                        adv_dvc_varp->cfg->serial3;
-                } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-                {
-                    ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
-
-                    ep_38C0800->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
-                    ep_38C0800->max_host_qng = adv_dvc_varp->max_host_qng;
-                    ep_38C0800->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
-                    ep_38C0800->termination_lvd =
-                        adv_dvc_varp->cfg->termination;
-                    ep_38C0800->disc_enable = adv_dvc_varp->cfg->disc_enable;
-                    ep_38C0800->bios_ctrl = adv_dvc_varp->bios_ctrl;
-                    ep_38C0800->wdtr_able = adv_dvc_varp->wdtr_able;
-                    ep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;
-                    ep_38C0800->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;
-                    ep_38C0800->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;
-                    ep_38C0800->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;
-                    ep_38C0800->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;
-                    ep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;
-                    ep_38C0800->start_motor = adv_dvc_varp->start_motor;
-                    ep_38C0800->scsi_reset_delay =
-                        adv_dvc_varp->scsi_reset_wait;
-                    ep_38C0800->serial_number_word1 =
-                        adv_dvc_varp->cfg->serial1;
-                    ep_38C0800->serial_number_word2 =
-                        adv_dvc_varp->cfg->serial2;
-                    ep_38C0800->serial_number_word3 =
-                        adv_dvc_varp->cfg->serial3;
-                } else
-                {
-                    ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
-
-                    ep_38C1600->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
-                    ep_38C1600->max_host_qng = adv_dvc_varp->max_host_qng;
-                    ep_38C1600->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
-                    ep_38C1600->termination_lvd =
-                        adv_dvc_varp->cfg->termination;
-                    ep_38C1600->disc_enable = adv_dvc_varp->cfg->disc_enable;
-                    ep_38C1600->bios_ctrl = adv_dvc_varp->bios_ctrl;
-                    ep_38C1600->wdtr_able = adv_dvc_varp->wdtr_able;
-                    ep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;
-                    ep_38C1600->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;
-                    ep_38C1600->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;
-                    ep_38C1600->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;
-                    ep_38C1600->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;
-                    ep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;
-                    ep_38C1600->start_motor = adv_dvc_varp->start_motor;
-                    ep_38C1600->scsi_reset_delay =
-                        adv_dvc_varp->scsi_reset_wait;
-                    ep_38C1600->serial_number_word1 =
-                        adv_dvc_varp->cfg->serial1;
-                    ep_38C1600->serial_number_word2 =
-                        adv_dvc_varp->cfg->serial2;
-                    ep_38C1600->serial_number_word3 =
-                        adv_dvc_varp->cfg->serial3;
-                }
-
-                /*
-                 * Set the adapter's target id bit in the 'init_tidmask' field.
-                 */
-                boardp->init_tidmask |=
-                    ADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);
-
-                /*
-                 * Finish initializing the 'Scsi_Host' structure.
-                 */
-                shp->irq = adv_dvc_varp->irq_no;
-            }
-
-            /*
-             * Channels are numbered beginning with 0. For AdvanSys one host
-             * structure supports one channel. Multi-channel boards have a
-             * separate host structure for each channel.
-             */
-            shp->max_channel = 0;
-            if (ASC_NARROW_BOARD(boardp)) {
-                shp->max_id = ASC_MAX_TID + 1;
-                shp->max_lun = ASC_MAX_LUN + 1;
-
-                shp->io_port = asc_dvc_varp->iop_base;
-                boardp->asc_n_io_port = ASC_IOADR_GAP;
-                shp->this_id = asc_dvc_varp->cfg->chip_scsi_id;
-
-                /* Set maximum number of queues the adapter can handle. */
-                shp->can_queue = asc_dvc_varp->max_total_qng;
-            } else {
-                shp->max_id = ADV_MAX_TID + 1;
-                shp->max_lun = ADV_MAX_LUN + 1;
-
-                /*
-                 * Save the I/O Port address and length even though
-                 * I/O ports are not used to access Wide boards.
-                 * Instead the Wide boards are accessed with
-                 * PCI Memory Mapped I/O.
-                 */
-                shp->io_port = iop;
-                boardp->asc_n_io_port = iolen;
-
-                shp->this_id = adv_dvc_varp->chip_scsi_id;
-
-                /* Set maximum number of queues the adapter can handle. */
-                shp->can_queue = adv_dvc_varp->max_host_qng;
-            }
-
-            /*
-             * 'n_io_port' currently is one byte.
-             *
-             * Set a value to 'n_io_port', but never referenced it because
-             * it may be truncated.
-             */
-            shp->n_io_port = boardp->asc_n_io_port <= 255 ?
-                boardp->asc_n_io_port : 255;
-
-            /*
-             * Following v1.3.89, 'cmd_per_lun' is no longer needed
-             * and should be set to zero.
-             *
-             * But because of a bug introduced in v1.3.89 if the driver is
-             * compiled as a module and 'cmd_per_lun' is zero, the Mid-Level
-             * SCSI function 'allocate_device' will panic. To allow the driver
-             * to work as a module in these kernels set 'cmd_per_lun' to 1.
-	     *
-	     * Note: This is wrong.  cmd_per_lun should be set to the depth
-	     * you want on untagged devices always.
-#ifdef MODULE
-             */
-            shp->cmd_per_lun = 1;
-/* #else
-            shp->cmd_per_lun = 0;
-#endif */
-
-            /*
-             * Set the maximum number of scatter-gather elements the
-             * adapter can handle.
-             */
-            if (ASC_NARROW_BOARD(boardp)) {
-                /*
-                 * Allow two commands with 'sg_tablesize' scatter-gather
-                 * elements to be executed simultaneously. This value is
-                 * the theoretical hardware limit. It may be decreased
-                 * below.
-                 */
-                shp->sg_tablesize =
-                    (((asc_dvc_varp->max_total_qng - 2) / 2) *
-                    ASC_SG_LIST_PER_Q) + 1;
-            } else {
-                shp->sg_tablesize = ADV_MAX_SG_LIST;
-            }
-
-            /*
-             * The value of 'sg_tablesize' can not exceed the SCSI
-             * mid-level driver definition of SG_ALL. SG_ALL also
-             * must not be exceeded, because it is used to define the
-             * size of the scatter-gather table in 'struct asc_sg_head'.
-             */
-            if (shp->sg_tablesize > SG_ALL) {
-                shp->sg_tablesize = SG_ALL;
-            }
-
-            ASC_DBG1(1, "advansys_detect: sg_tablesize: %d\n",
-                shp->sg_tablesize);
-
-            /* BIOS start address. */
-            if (ASC_NARROW_BOARD(boardp)) {
-                shp->base =
-                        ((ulong) AscGetChipBiosAddress(
-                            asc_dvc_varp->iop_base,
-                            asc_dvc_varp->bus_type));
-            } else {
-                /*
-                 * Fill-in BIOS board variables. The Wide BIOS saves
-                 * information in LRAM that is used by the driver.
-                 */
-                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_SIGNATURE,
-                    boardp->bios_signature);
-                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_VERSION,
-                    boardp->bios_version);
-                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_CODESEG,
-                    boardp->bios_codeseg);
-                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_CODELEN,
-                    boardp->bios_codelen);
-
-                ASC_DBG2(1,
-                    "advansys_detect: bios_signature 0x%x, bios_version 0x%x\n",
-                    boardp->bios_signature, boardp->bios_version);
-
-                ASC_DBG2(1,
-                    "advansys_detect: bios_codeseg 0x%x, bios_codelen 0x%x\n",
-                    boardp->bios_codeseg, boardp->bios_codelen);
-
-                /*
-                 * If the BIOS saved a valid signature, then fill in
-                 * the BIOS code segment base address.
-                 */
-                if (boardp->bios_signature == 0x55AA) {
-                    /*
-                     * Convert x86 realmode code segment to a linear
-                     * address by shifting left 4.
-                     */
-                    shp->base = ((ulong) boardp->bios_codeseg << 4);
-                } else {
-                    shp->base = 0;
-                }
-            }
-
-            /*
-             * Register Board Resources - I/O Port, DMA, IRQ
-             */
-
-            /*
-             * Register I/O port range.
-             *
-             * For Wide boards the I/O ports are not used to access
-             * the board, but request the region anyway.
-             *
-             * 'shp->n_io_port' is not referenced, because it may be truncated.
-             */
-            ASC_DBG2(2,
-                "advansys_detect: request_region port 0x%lx, len 0x%x\n",
-                (ulong) shp->io_port, boardp->asc_n_io_port);
-            if (request_region(shp->io_port, boardp->asc_n_io_port,
-                               "advansys") == NULL) {
-                ASC_PRINT3(
-"advansys_detect: board %d: request_region() failed, port 0x%lx, len 0x%x\n",
-                    boardp->id, (ulong) shp->io_port, boardp->asc_n_io_port);
-#ifdef CONFIG_PROC_FS
-                kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-                scsi_unregister(shp);
-                asc_board_count--;
-                continue;
-            }
-
-            /* Register DMA Channel for Narrow boards. */
-            shp->dma_channel = NO_ISA_DMA; /* Default to no ISA DMA. */
-#ifdef CONFIG_ISA
-            if (ASC_NARROW_BOARD(boardp)) {
-                /* Register DMA channel for ISA bus. */
-                if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
-                    shp->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
-                    if ((ret =
-                         request_dma(shp->dma_channel, "advansys")) != 0) {
-                        ASC_PRINT3(
-"advansys_detect: board %d: request_dma() %d failed %d\n",
-                            boardp->id, shp->dma_channel, ret);
-                        release_region(shp->io_port, boardp->asc_n_io_port);
-#ifdef CONFIG_PROC_FS
-                        kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-                        scsi_unregister(shp);
-                        asc_board_count--;
-                        continue;
-                    }
-                    AscEnableIsaDma(shp->dma_channel);
-                }
-            }
-#endif /* CONFIG_ISA */
+	/*
+	 * Display Asc Library dynamic configuration information
+	 * for the board.
+	 */
+	cp = boardp->prtbuf;
+	if (ASC_NARROW_BOARD(boardp)) {
+		cplen = asc_prt_asc_board_info(shp, cp, ASC_PRTBUF_SIZE);
+	} else {
+		cplen = asc_prt_adv_board_info(shp, cp, ASC_PRTBUF_SIZE);
+	}
+	ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+	cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+	totcnt += cnt;
+	leftlen -= cnt;
+	if (leftlen == 0) {
+		ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+		return totcnt;
+	}
+	advoffset += cplen;
+	curbuf += cnt;
 
-            /* Register IRQ Number. */
-            ASC_DBG1(2, "advansys_detect: request_irq() %d\n", shp->irq);
-           /*
-            * If request_irq() fails with the IRQF_DISABLED flag set,
-            * then try again without the IRQF_DISABLED flag set. This
-            * allows IRQ sharing to work even with other drivers that
-            * do not set the IRQF_DISABLED flag.
-            *
-            * If IRQF_DISABLED is not set, then interrupts are enabled
-            * before the driver interrupt function is called.
-            */
-            if (((ret = request_irq(shp->irq, advansys_interrupt,
-                            IRQF_DISABLED | (share_irq == TRUE ? IRQF_SHARED : 0),
-                            "advansys", boardp)) != 0) &&
-                ((ret = request_irq(shp->irq, advansys_interrupt,
-                            (share_irq == TRUE ? IRQF_SHARED : 0),
-                            "advansys", boardp)) != 0))
-            {
-                if (ret == -EBUSY) {
-                    ASC_PRINT2(
-"advansys_detect: board %d: request_irq(): IRQ 0x%x already in use.\n",
-                        boardp->id, shp->irq);
-                } else if (ret == -EINVAL) {
-                    ASC_PRINT2(
-"advansys_detect: board %d: request_irq(): IRQ 0x%x not valid.\n",
-                        boardp->id, shp->irq);
-                } else {
-                    ASC_PRINT3(
-"advansys_detect: board %d: request_irq(): IRQ 0x%x failed with %d\n",
-                        boardp->id, shp->irq, ret);
-                }
-                release_region(shp->io_port, boardp->asc_n_io_port);
-                iounmap(boardp->ioremap_addr);
-                if (shp->dma_channel != NO_ISA_DMA) {
-                    free_dma(shp->dma_channel);
-                }
-#ifdef CONFIG_PROC_FS
-                kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-                scsi_unregister(shp);
-                asc_board_count--;
-                continue;
-            }
-
-            /*
-             * Initialize board RISC chip and enable interrupts.
-             */
-            if (ASC_NARROW_BOARD(boardp)) {
-                ASC_DBG(2, "advansys_detect: AscInitAsc1000Driver()\n");
-                warn_code = AscInitAsc1000Driver(asc_dvc_varp);
-                err_code = asc_dvc_varp->err_code;
-
-                if (warn_code || err_code) {
-                    ASC_PRINT4(
-"advansys_detect: board %d error: init_state 0x%x, warn 0x%x, error 0x%x\n",
-                        boardp->id, asc_dvc_varp->init_state,
-                        warn_code, err_code);
-                }
-            } else {
-                ADV_CARR_T      *carrp;
-                int             req_cnt = 0;
-                adv_req_t       *reqp = NULL;
-                int             sg_cnt = 0;
-
-                /*
-                 * Allocate buffer carrier structures. The total size
-                 * is about 4 KB, so allocate all at once.
-                 */
-                carrp =
-                    (ADV_CARR_T *) kmalloc(ADV_CARRIER_BUFSIZE, GFP_ATOMIC);
-                ASC_DBG1(1, "advansys_detect: carrp 0x%lx\n", (ulong) carrp);
-
-                if (carrp == NULL) {
-                    goto kmalloc_error;
-                }
-
-                /*
-                 * Allocate up to 'max_host_qng' request structures for
-                 * the Wide board. The total size is about 16 KB, so
-                 * allocate all at once. If the allocation fails decrement
-                 * and try again.
-                 */
-                for (req_cnt = adv_dvc_varp->max_host_qng;
-                    req_cnt > 0; req_cnt--) {
-
-                    reqp = (adv_req_t *)
-                        kmalloc(sizeof(adv_req_t) * req_cnt, GFP_ATOMIC);
-
-                    ASC_DBG3(1,
-                        "advansys_detect: reqp 0x%lx, req_cnt %d, bytes %lu\n",
-                        (ulong) reqp, req_cnt,
-                        (ulong) sizeof(adv_req_t) * req_cnt);
-
-                    if (reqp != NULL) {
-                        break;
-                    }
-                }
-                if (reqp == NULL)
-                {
-                    goto kmalloc_error;
-                }
-
-                /*
-                 * Allocate up to ADV_TOT_SG_BLOCK request structures for
-                 * the Wide board. Each structure is about 136 bytes.
-                 */
-                boardp->adv_sgblkp = NULL;
-                for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
-
-                    sgp = (adv_sgblk_t *)
-                        kmalloc(sizeof(adv_sgblk_t), GFP_ATOMIC);
-
-                    if (sgp == NULL) {
-                        break;
-                    }
-
-                    sgp->next_sgblkp = boardp->adv_sgblkp;
-                    boardp->adv_sgblkp = sgp;
-
-                }
-                ASC_DBG3(1,
-                    "advansys_detect: sg_cnt %d * %u = %u bytes\n",
-                    sg_cnt, sizeof(adv_sgblk_t),
-                    (unsigned) (sizeof(adv_sgblk_t) * sg_cnt));
-
-                /*
-                 * If no request structures or scatter-gather structures could
-                 * be allocated, then return an error. Otherwise continue with
-                 * initialization.
-                 */
-    kmalloc_error:
-                if (carrp == NULL)
-                {
-                    ASC_PRINT1(
-"advansys_detect: board %d error: failed to kmalloc() carrier buffer.\n",
-                        boardp->id);
-                    err_code = ADV_ERROR;
-                } else if (reqp == NULL) {
-                    kfree(carrp);
-                    ASC_PRINT1(
-"advansys_detect: board %d error: failed to kmalloc() adv_req_t buffer.\n",
-                        boardp->id);
-                    err_code = ADV_ERROR;
-                } else if (boardp->adv_sgblkp == NULL) {
-                    kfree(carrp);
-                    kfree(reqp);
-                    ASC_PRINT1(
-"advansys_detect: board %d error: failed to kmalloc() adv_sgblk_t buffers.\n",
-                        boardp->id);
-                    err_code = ADV_ERROR;
-                } else {
-
-                    /* Save carrier buffer pointer. */
-                    boardp->orig_carrp = carrp;
-
-                    /*
-                     * Save original pointer for kfree() in case the
-                     * driver is built as a module and can be unloaded.
-                     */
-                    boardp->orig_reqp = reqp;
-
-                    adv_dvc_varp->carrier_buf = carrp;
-
-                    /*
-                     * Point 'adv_reqp' to the request structures and
-                     * link them together.
-                     */
-                    req_cnt--;
-                    reqp[req_cnt].next_reqp = NULL;
-                    for (; req_cnt > 0; req_cnt--) {
-                        reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
-                    }
-                    boardp->adv_reqp = &reqp[0];
-
-                    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-                    {
-                        ASC_DBG(2,
-                            "advansys_detect: AdvInitAsc3550Driver()\n");
-                        warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
-                    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
-                        ASC_DBG(2,
-                            "advansys_detect: AdvInitAsc38C0800Driver()\n");
-                        warn_code = AdvInitAsc38C0800Driver(adv_dvc_varp);
-                    } else {
-                        ASC_DBG(2,
-                            "advansys_detect: AdvInitAsc38C1600Driver()\n");
-                        warn_code = AdvInitAsc38C1600Driver(adv_dvc_varp);
-                    }
-                    err_code = adv_dvc_varp->err_code;
-
-                    if (warn_code || err_code) {
-                        ASC_PRINT3(
-"advansys_detect: board %d error: warn 0x%x, error 0x%x\n",
-                            boardp->id, warn_code, err_code);
-                    }
-                }
-            }
-
-            if (err_code != 0) {
-                release_region(shp->io_port, boardp->asc_n_io_port);
-                if (ASC_WIDE_BOARD(boardp)) {
-                    iounmap(boardp->ioremap_addr);
-                    kfree(boardp->orig_carrp);
-                    boardp->orig_carrp = NULL;
-                    if (boardp->orig_reqp) {
-                        kfree(boardp->orig_reqp);
-                        boardp->orig_reqp = boardp->adv_reqp = NULL;
-                    }
-                    while ((sgp = boardp->adv_sgblkp) != NULL)
-                    {
-                        boardp->adv_sgblkp = sgp->next_sgblkp;
-                        kfree(sgp);
-                    }
-                }
-                if (shp->dma_channel != NO_ISA_DMA) {
-                    free_dma(shp->dma_channel);
-                }
-#ifdef CONFIG_PROC_FS
-                kfree(boardp->prtbuf);
-#endif /* CONFIG_PROC_FS */
-                free_irq(shp->irq, boardp);
-                scsi_unregister(shp);
-                asc_board_count--;
-                continue;
-            }
-            ASC_DBG_PRT_SCSI_HOST(2, shp);
-        }
-    }
+	ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
 
-    ASC_DBG1(1, "advansys_detect: done: asc_board_count %d\n", asc_board_count);
-    return asc_board_count;
+	return totcnt;
 }
-
-/*
- * advansys_release()
- *
- * Release resources allocated for a single AdvanSys adapter.
- */
-static int
-advansys_release(struct Scsi_Host *shp)
-{
-    asc_board_t    *boardp;
-
-    ASC_DBG(1, "advansys_release: begin\n");
-    boardp = ASC_BOARDP(shp);
-    free_irq(shp->irq, boardp);
-    if (shp->dma_channel != NO_ISA_DMA) {
-        ASC_DBG(1, "advansys_release: free_dma()\n");
-        free_dma(shp->dma_channel);
-    }
-    release_region(shp->io_port, boardp->asc_n_io_port);
-    if (ASC_WIDE_BOARD(boardp)) {
-        adv_sgblk_t    *sgp = NULL;
-
-        iounmap(boardp->ioremap_addr);
-        kfree(boardp->orig_carrp);
-        boardp->orig_carrp = NULL;
-        if (boardp->orig_reqp) {
-            kfree(boardp->orig_reqp);
-            boardp->orig_reqp = boardp->adv_reqp = NULL;
-        }
-        while ((sgp = boardp->adv_sgblkp) != NULL)
-        {
-            boardp->adv_sgblkp = sgp->next_sgblkp;
-            kfree(sgp);
-        }
-    }
-#ifdef CONFIG_PROC_FS
-    ASC_ASSERT(boardp->prtbuf != NULL);
-    kfree(boardp->prtbuf);
 #endif /* CONFIG_PROC_FS */
-    scsi_unregister(shp);
-    ASC_DBG(1, "advansys_release: end\n");
-    return 0;
-}
 
 /*
  * advansys_info()
@@ -5466,91 +4248,87 @@ advansys_release(struct Scsi_Host *shp)
  * Note: The information line should not exceed ASC_INFO_SIZE bytes,
  * otherwise the static 'info' array will be overrun.
  */
-static const char *
-advansys_info(struct Scsi_Host *shp)
+static const char *advansys_info(struct Scsi_Host *shost)
 {
-    static char     info[ASC_INFO_SIZE];
-    asc_board_t     *boardp;
-    ASC_DVC_VAR     *asc_dvc_varp;
-    ADV_DVC_VAR     *adv_dvc_varp;
-    char            *busname;
-    int             iolen;
-    char            *widename = NULL;
-
-    boardp = ASC_BOARDP(shp);
-    if (ASC_NARROW_BOARD(boardp)) {
-        asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-        ASC_DBG(1, "advansys_info: begin\n");
-        if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
-            if ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) == ASC_IS_ISAPNP) {
-                busname = "ISA PnP";
-            } else {
-                busname = "ISA";
-            }
-            /* Don't reference 'shp->n_io_port'; It may be truncated. */
-            sprintf(info,
-"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",
-                ASC_VERSION, busname,
-                (ulong) shp->io_port,
-                (ulong) shp->io_port + boardp->asc_n_io_port - 1,
-                shp->irq, shp->dma_channel);
-        } else {
-            if (asc_dvc_varp->bus_type & ASC_IS_VL) {
-                busname = "VL";
-            } else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {
-                busname = "EISA";
-            } else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {
-                if ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)
-                    == ASC_IS_PCI_ULTRA) {
-                    busname = "PCI Ultra";
-                } else {
-                    busname = "PCI";
-                }
-            } else {
-                busname = "?";
-                ASC_PRINT2( "advansys_info: board %d: unknown bus type %d\n",
-                    boardp->id, asc_dvc_varp->bus_type);
-            }
-            /* Don't reference 'shp->n_io_port'; It may be truncated. */
-            sprintf(info,
-                "AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
-                ASC_VERSION, busname,
-                (ulong) shp->io_port,
-                (ulong) shp->io_port + boardp->asc_n_io_port - 1,
-                shp->irq);
-        }
-    } else {
-        /*
-         * Wide Adapter Information
-         *
-         * Memory-mapped I/O is used instead of I/O space to access
-         * the adapter, but display the I/O Port range. The Memory
-         * I/O address is displayed through the driver /proc file.
-         */
-        adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-        if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-        {
-            iolen = ADV_3550_IOLEN;
-            widename = "Ultra-Wide";
-        } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-        {
-            iolen = ADV_38C0800_IOLEN;
-            widename = "Ultra2-Wide";
-        } else
-        {
-            iolen = ADV_38C1600_IOLEN;
-            widename = "Ultra3-Wide";
-        }
-        sprintf(info, "AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
-            ASC_VERSION,
-            widename,
-            (ulong) adv_dvc_varp->iop_base,
-            (ulong) adv_dvc_varp->iop_base + iolen - 1,
-            shp->irq);
-    }
-    ASC_ASSERT(strlen(info) < ASC_INFO_SIZE);
-    ASC_DBG(1, "advansys_info: end\n");
-    return info;
+	static char info[ASC_INFO_SIZE];
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	char *busname;
+	int iolen;
+	char *widename = NULL;
+
+	boardp = ASC_BOARDP(shost);
+	if (ASC_NARROW_BOARD(boardp)) {
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+		ASC_DBG(1, "advansys_info: begin\n");
+		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+			if ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) ==
+			    ASC_IS_ISAPNP) {
+				busname = "ISA PnP";
+			} else {
+				busname = "ISA";
+			}
+			/* Don't reference 'shost->n_io_port'; It may be truncated. */
+			sprintf(info,
+				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",
+				ASC_VERSION, busname,
+				(ulong)shost->io_port,
+				(ulong)shost->io_port + boardp->asc_n_io_port -
+				1, shost->irq, shost->dma_channel);
+		} else {
+			if (asc_dvc_varp->bus_type & ASC_IS_VL) {
+				busname = "VL";
+			} else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {
+				busname = "EISA";
+			} else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {
+				if ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)
+				    == ASC_IS_PCI_ULTRA) {
+					busname = "PCI Ultra";
+				} else {
+					busname = "PCI";
+				}
+			} else {
+				busname = "?";
+				ASC_PRINT2
+				    ("advansys_info: board %d: unknown bus type %d\n",
+				     boardp->id, asc_dvc_varp->bus_type);
+			}
+			/* Don't reference 'shost->n_io_port'; It may be truncated. */
+			sprintf(info,
+				"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
+				ASC_VERSION, busname,
+				(ulong)shost->io_port,
+				(ulong)shost->io_port + boardp->asc_n_io_port -
+				1, shost->irq);
+		}
+	} else {
+		/*
+		 * Wide Adapter Information
+		 *
+		 * Memory-mapped I/O is used instead of I/O space to access
+		 * the adapter, but display the I/O Port range. The Memory
+		 * I/O address is displayed through the driver /proc file.
+		 */
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+			iolen = ADV_3550_IOLEN;
+			widename = "Ultra-Wide";
+		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+			iolen = ADV_38C0800_IOLEN;
+			widename = "Ultra2-Wide";
+		} else {
+			iolen = ADV_38C1600_IOLEN;
+			widename = "Ultra3-Wide";
+		}
+		sprintf(info,
+			"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
+			ASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,
+			(ulong)adv_dvc_varp->iop_base + iolen - 1, shost->irq);
+	}
+	ASC_ASSERT(strlen(info) < ASC_INFO_SIZE);
+	ASC_DBG(1, "advansys_info: end\n");
+	return info;
 }
 
 /*
@@ -5560,82 +4338,82 @@ advansys_info(struct Scsi_Host *shp)
  * in the 'scp' result field.
  */
 static int
-advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+advansys_queuecommand(struct scsi_cmnd *scp, void (*done) (struct scsi_cmnd *))
 {
-    struct Scsi_Host    *shp;
-    asc_board_t         *boardp;
-    ulong               flags;
-    struct scsi_cmnd           *done_scp;
+	struct Scsi_Host *shost;
+	asc_board_t *boardp;
+	ulong flags;
+	struct scsi_cmnd *done_scp;
 
-    shp = scp->device->host;
-    boardp = ASC_BOARDP(shp);
-    ASC_STATS(shp, queuecommand);
+	shost = scp->device->host;
+	boardp = ASC_BOARDP(shost);
+	ASC_STATS(shost, queuecommand);
 
-    /* host_lock taken by mid-level prior to call but need to protect */
-    /* against own ISR */
-    spin_lock_irqsave(&boardp->lock, flags);
+	/* host_lock taken by mid-level prior to call but need to protect */
+	/* against own ISR */
+	spin_lock_irqsave(&boardp->lock, flags);
 
-    /*
-     * Block new commands while handling a reset or abort request.
-     */
-    if (boardp->flags & ASC_HOST_IN_RESET) {
-        ASC_DBG1(1,
-            "advansys_queuecommand: scp 0x%lx blocked for reset request\n",
-            (ulong) scp);
-        scp->result = HOST_BYTE(DID_RESET);
-
-        /*
-         * Add blocked requests to the board's 'done' queue. The queued
-         * requests will be completed at the end of the abort or reset
-         * handling.
-         */
-        asc_enqueue(&boardp->done, scp, ASC_BACK);
-	spin_unlock_irqrestore(&boardp->lock, flags);
-        return 0;
-    }
+	/*
+	 * Block new commands while handling a reset or abort request.
+	 */
+	if (boardp->flags & ASC_HOST_IN_RESET) {
+		ASC_DBG1(1,
+			 "advansys_queuecommand: scp 0x%lx blocked for reset request\n",
+			 (ulong)scp);
+		scp->result = HOST_BYTE(DID_RESET);
 
-    /*
-     * Attempt to execute any waiting commands for the board.
-     */
-    if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
-        ASC_DBG(1,
-            "advansys_queuecommand: before asc_execute_queue() waiting\n");
-        asc_execute_queue(&boardp->waiting);
-    }
+		/*
+		 * Add blocked requests to the board's 'done' queue. The queued
+		 * requests will be completed at the end of the abort or reset
+		 * handling.
+		 */
+		asc_enqueue(&boardp->done, scp, ASC_BACK);
+		spin_unlock_irqrestore(&boardp->lock, flags);
+		return 0;
+	}
 
-    /*
-     * Save the function pointer to Linux mid-level 'done' function
-     * and attempt to execute the command.
-     *
-     * If ASC_NOERROR is returned the request has been added to the
-     * board's 'active' queue and will be completed by the interrupt
-     * handler.
-     *
-     * If ASC_BUSY is returned add the request to the board's per
-     * target waiting list. This is the first time the request has
-     * been tried. Add it to the back of the waiting list. It will be
-     * retried later.
-     *
-     * If an error occurred, the request will have been placed on the
-     * board's 'done' queue and must be completed before returning.
-     */
-    scp->scsi_done = done;
-    switch (asc_execute_scsi_cmnd(scp)) {
-    case ASC_NOERROR:
-        break;
-    case ASC_BUSY:
-        asc_enqueue(&boardp->waiting, scp, ASC_BACK);
-        break;
-    case ASC_ERROR:
-    default:
-        done_scp = asc_dequeue_list(&boardp->done, NULL, ASC_TID_ALL);
-        /* Interrupts could be enabled here. */
-        asc_scsi_done_list(done_scp);
-        break;
-    }
-    spin_unlock_irqrestore(&boardp->lock, flags);
+	/*
+	 * Attempt to execute any waiting commands for the board.
+	 */
+	if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
+		ASC_DBG(1,
+			"advansys_queuecommand: before asc_execute_queue() waiting\n");
+		asc_execute_queue(&boardp->waiting);
+	}
+
+	/*
+	 * Save the function pointer to Linux mid-level 'done' function
+	 * and attempt to execute the command.
+	 *
+	 * If ASC_NOERROR is returned the request has been added to the
+	 * board's 'active' queue and will be completed by the interrupt
+	 * handler.
+	 *
+	 * If ASC_BUSY is returned add the request to the board's per
+	 * target waiting list. This is the first time the request has
+	 * been tried. Add it to the back of the waiting list. It will be
+	 * retried later.
+	 *
+	 * If an error occurred, the request will have been placed on the
+	 * board's 'done' queue and must be completed before returning.
+	 */
+	scp->scsi_done = done;
+	switch (asc_execute_scsi_cmnd(scp)) {
+	case ASC_NOERROR:
+		break;
+	case ASC_BUSY:
+		asc_enqueue(&boardp->waiting, scp, ASC_BACK);
+		break;
+	case ASC_ERROR:
+	default:
+		done_scp = asc_dequeue_list(&boardp->done, NULL, ASC_TID_ALL);
+		/* Interrupts could be enabled here. */
+		asc_scsi_done_list(done_scp);
+		break;
+	}
+	spin_unlock_irqrestore(&boardp->lock, flags);
 
-    return 0;
+	return 0;
 }
 
 /*
@@ -5647,178 +4425,187 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
  * sleeping is allowed and no locking other than for host structures is
  * required. Returns SUCCESS or FAILED.
  */
-static int
-advansys_reset(struct scsi_cmnd *scp)
+static int advansys_reset(struct scsi_cmnd *scp)
 {
-    struct Scsi_Host     *shp;
-    asc_board_t          *boardp;
-    ASC_DVC_VAR          *asc_dvc_varp;
-    ADV_DVC_VAR          *adv_dvc_varp;
-    ulong                flags;
-    struct scsi_cmnd            *done_scp = NULL, *last_scp = NULL;
-    struct scsi_cmnd            *tscp, *new_last_scp;
-    int                  status;
-    int                  ret = SUCCESS;
-
-    ASC_DBG1(1, "advansys_reset: 0x%lx\n", (ulong) scp);
+	struct Scsi_Host *shost;
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	ulong flags;
+	struct scsi_cmnd *done_scp = NULL, *last_scp = NULL;
+	struct scsi_cmnd *tscp, *new_last_scp;
+	int status;
+	int ret = SUCCESS;
+
+	ASC_DBG1(1, "advansys_reset: 0x%lx\n", (ulong)scp);
 
 #ifdef ADVANSYS_STATS
-    if (scp->device->host != NULL) {
-        ASC_STATS(scp->device->host, reset);
-    }
+	if (scp->device->host != NULL) {
+		ASC_STATS(scp->device->host, reset);
+	}
 #endif /* ADVANSYS_STATS */
 
-    if ((shp = scp->device->host) == NULL) {
-        scp->result = HOST_BYTE(DID_ERROR);
-        return FAILED;
-    }
+	if ((shost = scp->device->host) == NULL) {
+		scp->result = HOST_BYTE(DID_ERROR);
+		return FAILED;
+	}
 
-    boardp = ASC_BOARDP(shp);
+	boardp = ASC_BOARDP(shost);
 
-    ASC_PRINT1("advansys_reset: board %d: SCSI bus reset started...\n",
-        boardp->id);
-    /*
-     * Check for re-entrancy.
-     */
-    spin_lock_irqsave(&boardp->lock, flags);
-    if (boardp->flags & ASC_HOST_IN_RESET) {
-	spin_unlock_irqrestore(&boardp->lock, flags);
-        return FAILED;
-    }
-    boardp->flags |= ASC_HOST_IN_RESET;
-    spin_unlock_irqrestore(&boardp->lock, flags);
-
-    if (ASC_NARROW_BOARD(boardp)) {
-        /*
-         * Narrow Board
-         */
-        asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-
-        /*
-         * Reset the chip and SCSI bus.
-         */
-        ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
-        status = AscInitAsc1000Driver(asc_dvc_varp);
-
-        /* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
-        if (asc_dvc_varp->err_code) {
-            ASC_PRINT2(
-                "advansys_reset: board %d: SCSI bus reset error: 0x%x\n",
-                boardp->id, asc_dvc_varp->err_code);
-            ret = FAILED;
-        } else if (status) {
-            ASC_PRINT2(
-                "advansys_reset: board %d: SCSI bus reset warning: 0x%x\n",
-                boardp->id, status);
-        } else {
-            ASC_PRINT1(
-                "advansys_reset: board %d: SCSI bus reset successful.\n",
-                boardp->id);
-        }
-
-        ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
+	ASC_PRINT1("advansys_reset: board %d: SCSI bus reset started...\n",
+		   boardp->id);
+	/*
+	 * Check for re-entrancy.
+	 */
 	spin_lock_irqsave(&boardp->lock, flags);
+	if (boardp->flags & ASC_HOST_IN_RESET) {
+		spin_unlock_irqrestore(&boardp->lock, flags);
+		return FAILED;
+	}
+	boardp->flags |= ASC_HOST_IN_RESET;
+	spin_unlock_irqrestore(&boardp->lock, flags);
 
-    } else {
-        /*
-         * Wide Board
-         *
-         * If the suggest reset bus flags are set, then reset the bus.
-         * Otherwise only reset the device.
-         */
-        adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-
-        /*
-         * Reset the target's SCSI bus.
-         */
-        ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
-        switch (AdvResetChipAndSB(adv_dvc_varp)) {
-        case ASC_TRUE:
-            ASC_PRINT1("advansys_reset: board %d: SCSI bus reset successful.\n",
-                boardp->id);
-            break;
-        case ASC_FALSE:
-        default:
-            ASC_PRINT1("advansys_reset: board %d: SCSI bus reset error.\n",
-                boardp->id);
-            ret = FAILED;
-            break;
-        }
-	spin_lock_irqsave(&boardp->lock, flags);
-        (void) AdvISR(adv_dvc_varp);
-    }
-    /* Board lock is held. */
+	if (ASC_NARROW_BOARD(boardp)) {
+		/*
+		 * Narrow Board
+		 */
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
 
-    /*
-     * Dequeue all board 'done' requests. A pointer to the last request
-     * is returned in 'last_scp'.
-     */
-    done_scp = asc_dequeue_list(&boardp->done, &last_scp, ASC_TID_ALL);
+		/*
+		 * Reset the chip and SCSI bus.
+		 */
+		ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
+		status = AscInitAsc1000Driver(asc_dvc_varp);
+
+		/* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
+		if (asc_dvc_varp->err_code) {
+			ASC_PRINT2
+			    ("advansys_reset: board %d: SCSI bus reset error: 0x%x\n",
+			     boardp->id, asc_dvc_varp->err_code);
+			ret = FAILED;
+		} else if (status) {
+			ASC_PRINT2
+			    ("advansys_reset: board %d: SCSI bus reset warning: 0x%x\n",
+			     boardp->id, status);
+		} else {
+			ASC_PRINT1
+			    ("advansys_reset: board %d: SCSI bus reset successful.\n",
+			     boardp->id);
+		}
+
+		ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
+		spin_lock_irqsave(&boardp->lock, flags);
 
-    /*
-     * Dequeue all board 'active' requests for all devices and set
-     * the request status to DID_RESET. A pointer to the last request
-     * is returned in 'last_scp'.
-     */
-    if (done_scp == NULL) {
-        done_scp = asc_dequeue_list(&boardp->active, &last_scp, ASC_TID_ALL);
-        for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
-            tscp->result = HOST_BYTE(DID_RESET);
-        }
-    } else {
-        /* Append to 'done_scp' at the end with 'last_scp'. */
-        ASC_ASSERT(last_scp != NULL);
-        last_scp->host_scribble = (unsigned char *)asc_dequeue_list(
-			&boardp->active, &new_last_scp, ASC_TID_ALL);
-        if (new_last_scp != NULL) {
-            ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-            for (tscp = REQPNEXT(last_scp); tscp; tscp = REQPNEXT(tscp)) {
-                tscp->result = HOST_BYTE(DID_RESET);
-            }
-            last_scp = new_last_scp;
-        }
-    }
+	} else {
+		/*
+		 * Wide Board
+		 *
+		 * If the suggest reset bus flags are set, then reset the bus.
+		 * Otherwise only reset the device.
+		 */
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
 
-    /*
-     * Dequeue all 'waiting' requests and set the request status
-     * to DID_RESET.
-     */
-    if (done_scp == NULL) {
-        done_scp = asc_dequeue_list(&boardp->waiting, &last_scp, ASC_TID_ALL);
-        for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
-            tscp->result = HOST_BYTE(DID_RESET);
-        }
-    } else {
-        /* Append to 'done_scp' at the end with 'last_scp'. */
-        ASC_ASSERT(last_scp != NULL);
-        last_scp->host_scribble = (unsigned char *)asc_dequeue_list(
-			&boardp->waiting, &new_last_scp, ASC_TID_ALL);
-        if (new_last_scp != NULL) {
-            ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-            for (tscp = REQPNEXT(last_scp); tscp; tscp = REQPNEXT(tscp)) {
-                tscp->result = HOST_BYTE(DID_RESET);
-            }
-            last_scp = new_last_scp;
-        }
-    }
+		/*
+		 * Reset the target's SCSI bus.
+		 */
+		ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
+		switch (AdvResetChipAndSB(adv_dvc_varp)) {
+		case ASC_TRUE:
+			ASC_PRINT1
+			    ("advansys_reset: board %d: SCSI bus reset successful.\n",
+			     boardp->id);
+			break;
+		case ASC_FALSE:
+		default:
+			ASC_PRINT1
+			    ("advansys_reset: board %d: SCSI bus reset error.\n",
+			     boardp->id);
+			ret = FAILED;
+			break;
+		}
+		spin_lock_irqsave(&boardp->lock, flags);
+		(void)AdvISR(adv_dvc_varp);
+	}
+	/* Board lock is held. */
+
+	/*
+	 * Dequeue all board 'done' requests. A pointer to the last request
+	 * is returned in 'last_scp'.
+	 */
+	done_scp = asc_dequeue_list(&boardp->done, &last_scp, ASC_TID_ALL);
+
+	/*
+	 * Dequeue all board 'active' requests for all devices and set
+	 * the request status to DID_RESET. A pointer to the last request
+	 * is returned in 'last_scp'.
+	 */
+	if (done_scp == NULL) {
+		done_scp =
+		    asc_dequeue_list(&boardp->active, &last_scp, ASC_TID_ALL);
+		for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
+			tscp->result = HOST_BYTE(DID_RESET);
+		}
+	} else {
+		/* Append to 'done_scp' at the end with 'last_scp'. */
+		ASC_ASSERT(last_scp != NULL);
+		last_scp->host_scribble =
+		    (unsigned char *)asc_dequeue_list(&boardp->active,
+						      &new_last_scp,
+						      ASC_TID_ALL);
+		if (new_last_scp != NULL) {
+			ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+			for (tscp = REQPNEXT(last_scp); tscp;
+			     tscp = REQPNEXT(tscp)) {
+				tscp->result = HOST_BYTE(DID_RESET);
+			}
+			last_scp = new_last_scp;
+		}
+	}
 
-    /* Save the time of the most recently completed reset. */
-    boardp->last_reset = jiffies;
+	/*
+	 * Dequeue all 'waiting' requests and set the request status
+	 * to DID_RESET.
+	 */
+	if (done_scp == NULL) {
+		done_scp =
+		    asc_dequeue_list(&boardp->waiting, &last_scp, ASC_TID_ALL);
+		for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
+			tscp->result = HOST_BYTE(DID_RESET);
+		}
+	} else {
+		/* Append to 'done_scp' at the end with 'last_scp'. */
+		ASC_ASSERT(last_scp != NULL);
+		last_scp->host_scribble =
+		    (unsigned char *)asc_dequeue_list(&boardp->waiting,
+						      &new_last_scp,
+						      ASC_TID_ALL);
+		if (new_last_scp != NULL) {
+			ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+			for (tscp = REQPNEXT(last_scp); tscp;
+			     tscp = REQPNEXT(tscp)) {
+				tscp->result = HOST_BYTE(DID_RESET);
+			}
+			last_scp = new_last_scp;
+		}
+	}
 
-    /* Clear reset flag. */
-    boardp->flags &= ~ASC_HOST_IN_RESET;
-    spin_unlock_irqrestore(&boardp->lock, flags);
+	/* Save the time of the most recently completed reset. */
+	boardp->last_reset = jiffies;
 
-    /*
-     * Complete all the 'done_scp' requests.
-     */
-    if (done_scp != NULL) {
-        asc_scsi_done_list(done_scp);
-    }
+	/* Clear reset flag. */
+	boardp->flags &= ~ASC_HOST_IN_RESET;
+	spin_unlock_irqrestore(&boardp->lock, flags);
+
+	/*
+	 * Complete all the 'done_scp' requests.
+	 */
+	if (done_scp != NULL) {
+		asc_scsi_done_list(done_scp);
+	}
 
-    ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
+	ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
 
-    return ret;
+	return ret;
 }
 
 /*
@@ -5834,71 +4621,70 @@ advansys_reset(struct scsi_cmnd *scp)
  */
 static int
 advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
-		sector_t capacity, int ip[])
+		   sector_t capacity, int ip[])
 {
-    asc_board_t     *boardp;
-
-    ASC_DBG(1, "advansys_biosparam: begin\n");
-    ASC_STATS(sdev->host, biosparam);
-    boardp = ASC_BOARDP(sdev->host);
-    if (ASC_NARROW_BOARD(boardp)) {
-        if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
-             ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {
-                ip[0] = 255;
-                ip[1] = 63;
-        } else {
-                ip[0] = 64;
-                ip[1] = 32;
-        }
-    } else {
-        if ((boardp->dvc_var.adv_dvc_var.bios_ctrl &
-             BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {
-                ip[0] = 255;
-                ip[1] = 63;
-        } else {
-                ip[0] = 64;
-                ip[1] = 32;
-        }
-    }
-    ip[2] = (unsigned long)capacity / (ip[0] * ip[1]);
-    ASC_DBG(1, "advansys_biosparam: end\n");
-    return 0;
+	asc_board_t *boardp;
+
+	ASC_DBG(1, "advansys_biosparam: begin\n");
+	ASC_STATS(sdev->host, biosparam);
+	boardp = ASC_BOARDP(sdev->host);
+	if (ASC_NARROW_BOARD(boardp)) {
+		if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
+		     ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {
+			ip[0] = 255;
+			ip[1] = 63;
+		} else {
+			ip[0] = 64;
+			ip[1] = 32;
+		}
+	} else {
+		if ((boardp->dvc_var.adv_dvc_var.bios_ctrl &
+		     BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {
+			ip[0] = 255;
+			ip[1] = 63;
+		} else {
+			ip[0] = 64;
+			ip[1] = 32;
+		}
+	}
+	ip[2] = (unsigned long)capacity / (ip[0] * ip[1]);
+	ASC_DBG(1, "advansys_biosparam: end\n");
+	return 0;
 }
 
-/*
- * --- Loadable Driver Support
- */
+static int __init advansys_detect(struct scsi_host_template *tpnt);
+static int advansys_release(struct Scsi_Host *shp);
 
 static struct scsi_host_template driver_template = {
-    .proc_name                  = "advansys",
+	.proc_name = "advansys",
 #ifdef CONFIG_PROC_FS
-    .proc_info                  = advansys_proc_info,
+	.proc_info = advansys_proc_info,
 #endif
-    .name                       = "advansys",
-    .detect                     = advansys_detect, 
-    .release                    = advansys_release,
-    .info                       = advansys_info,
-    .queuecommand               = advansys_queuecommand,
-    .eh_bus_reset_handler	= advansys_reset,
-    .bios_param                 = advansys_biosparam,
-    .slave_configure		= advansys_slave_configure,
-    /*
-     * Because the driver may control an ISA adapter 'unchecked_isa_dma'
-     * must be set. The flag will be cleared in advansys_detect for non-ISA
-     * adapters. Refer to the comment in scsi_module.c for more information.
-     */
-    .unchecked_isa_dma          = 1,
-    /*
-     * All adapters controlled by this driver are capable of large
-     * scatter-gather lists. According to the mid-level SCSI documentation
-     * this obviates any performance gain provided by setting
-     * 'use_clustering'. But empirically while CPU utilization is increased
-     * by enabling clustering, I/O throughput increases as well.
-     */
-    .use_clustering             = ENABLE_CLUSTERING,
+	.name = "advansys",
+	.detect = advansys_detect,
+	.release = advansys_release,
+	.info = advansys_info,
+	.queuecommand = advansys_queuecommand,
+	.eh_bus_reset_handler = advansys_reset,
+	.bios_param = advansys_biosparam,
+	.slave_configure = advansys_slave_configure,
+	/*
+	 * Because the driver may control an ISA adapter 'unchecked_isa_dma'
+	 * must be set. The flag will be cleared in advansys_detect for non-ISA
+	 * adapters. Refer to the comment in scsi_module.c for more information.
+	 */
+	.unchecked_isa_dma = 1,
+	/*
+	 * All adapters controlled by this driver are capable of large
+	 * scatter-gather lists. According to the mid-level SCSI documentation
+	 * this obviates any performance gain provided by setting
+	 * 'use_clustering'. But empirically while CPU utilization is increased
+	 * by enabling clustering, I/O throughput increases as well.
+	 */
+	.use_clustering = ENABLE_CLUSTERING,
 };
-#include "scsi_module.c"
 
+#include "scsi_module.c"
 
 /*
  * --- Miscellaneous Driver Functions
@@ -5913,130 +4699,138 @@ static struct scsi_host_template driver_template = {
  * to the AdvanSys driver which is for a device sharing an interrupt with
  * an AdvanSys adapter.
  */
-STATIC irqreturn_t
-advansys_interrupt(int irq, void *dev_id)
+static irqreturn_t advansys_interrupt(int irq, void *dev_id)
 {
-    ulong           flags;
-    int             i;
-    asc_board_t     *boardp;
-    struct scsi_cmnd       *done_scp = NULL, *last_scp = NULL;
-    struct scsi_cmnd       *new_last_scp;
-    struct Scsi_Host *shp;
-
-    ASC_DBG(1, "advansys_interrupt: begin\n");
+	ulong flags;
+	int i;
+	asc_board_t *boardp;
+	struct scsi_cmnd *done_scp = NULL, *last_scp = NULL;
+	struct scsi_cmnd *new_last_scp;
+	struct Scsi_Host *shost;
+
+	ASC_DBG(1, "advansys_interrupt: begin\n");
+
+	/*
+	 * Check for interrupts on all boards.
+	 * AscISR() will call asc_isr_callback().
+	 */
+	for (i = 0; i < asc_board_count; i++) {
+		shost = asc_host[i];
+		boardp = ASC_BOARDP(shost);
+		ASC_DBG2(2, "advansys_interrupt: i %d, boardp 0x%lx\n",
+			 i, (ulong)boardp);
+		spin_lock_irqsave(&boardp->lock, flags);
+		if (ASC_NARROW_BOARD(boardp)) {
+			/*
+			 * Narrow Board
+			 */
+			if (AscIsIntPending(shost->io_port)) {
+				ASC_STATS(shost, interrupt);
+				ASC_DBG(1,
+					"advansys_interrupt: before AscISR()\n");
+				AscISR(&boardp->dvc_var.asc_dvc_var);
+			}
+		} else {
+			/*
+			 * Wide Board
+			 */
+			ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
+			if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
+				ASC_STATS(shost, interrupt);
+			}
+		}
 
-    /*
-     * Check for interrupts on all boards.
-     * AscISR() will call asc_isr_callback().
-     */
-    for (i = 0; i < asc_board_count; i++) {
-	shp = asc_host[i];
-        boardp = ASC_BOARDP(shp);
-        ASC_DBG2(2, "advansys_interrupt: i %d, boardp 0x%lx\n",
-            i, (ulong) boardp);
-        spin_lock_irqsave(&boardp->lock, flags);
-        if (ASC_NARROW_BOARD(boardp)) {
-            /*
-             * Narrow Board
-             */
-            if (AscIsIntPending(shp->io_port)) {
-                ASC_STATS(shp, interrupt);
-                ASC_DBG(1, "advansys_interrupt: before AscISR()\n");
-                AscISR(&boardp->dvc_var.asc_dvc_var);
-            }
-        } else {
-            /*
-             * Wide Board
-             */
-            ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
-            if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
-                ASC_STATS(shp, interrupt);
-            }
-        }
-
-        /*
-         * Start waiting requests and create a list of completed requests.
-         *
-         * If a reset request is being performed for the board, the reset
-         * handler will complete pending requests after it has completed.
-         */
-        if ((boardp->flags & ASC_HOST_IN_RESET) == 0) {
-            ASC_DBG2(1, "advansys_interrupt: done_scp 0x%lx, last_scp 0x%lx\n",
-                (ulong) done_scp, (ulong) last_scp);
-
-            /* Start any waiting commands for the board. */
-            if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
-                ASC_DBG(1, "advansys_interrupt: before asc_execute_queue()\n");
-                asc_execute_queue(&boardp->waiting);
-            }
-
-             /*
-              * Add to the list of requests that must be completed.
-              *
-              * 'done_scp' will always be NULL on the first iteration
-              * of this loop. 'last_scp' is set at the same time as
-              * 'done_scp'.
-              */
-            if (done_scp == NULL) {
-                done_scp = asc_dequeue_list(&boardp->done, &last_scp,
-                    ASC_TID_ALL);
-            } else {
-                ASC_ASSERT(last_scp != NULL);
-                last_scp->host_scribble = (unsigned char *)asc_dequeue_list(
-			&boardp->done, &new_last_scp, ASC_TID_ALL);
-                if (new_last_scp != NULL) {
-                    ASC_ASSERT(REQPNEXT(last_scp) != NULL);
-                    last_scp = new_last_scp;
-                }
-            }
-        }
-        spin_unlock_irqrestore(&boardp->lock, flags);
-    }
+		/*
+		 * Start waiting requests and create a list of completed requests.
+		 *
+		 * If a reset request is being performed for the board, the reset
+		 * handler will complete pending requests after it has completed.
+		 */
+		if ((boardp->flags & ASC_HOST_IN_RESET) == 0) {
+			ASC_DBG2(1,
+				 "advansys_interrupt: done_scp 0x%lx, last_scp 0x%lx\n",
+				 (ulong)done_scp, (ulong)last_scp);
+
+			/* Start any waiting commands for the board. */
+			if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
+				ASC_DBG(1,
+					"advansys_interrupt: before asc_execute_queue()\n");
+				asc_execute_queue(&boardp->waiting);
+			}
+
+			/*
+			 * Add to the list of requests that must be completed.
+			 *
+			 * 'done_scp' will always be NULL on the first iteration
+			 * of this loop. 'last_scp' is set at the same time as
+			 * 'done_scp'.
+			 */
+			if (done_scp == NULL) {
+				done_scp =
+				    asc_dequeue_list(&boardp->done, &last_scp,
+						     ASC_TID_ALL);
+			} else {
+				ASC_ASSERT(last_scp != NULL);
+				last_scp->host_scribble =
+				    (unsigned char *)asc_dequeue_list(&boardp->
+								      done,
+								      &new_last_scp,
+								      ASC_TID_ALL);
+				if (new_last_scp != NULL) {
+					ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+					last_scp = new_last_scp;
+				}
+			}
+		}
+		spin_unlock_irqrestore(&boardp->lock, flags);
+	}
 
-    /*
-     * If interrupts were enabled on entry, then they
-     * are now enabled here.
-     *
-     * Complete all requests on the done list.
-     */
+	/*
+	 * If interrupts were enabled on entry, then they
+	 * are now enabled here.
+	 *
+	 * Complete all requests on the done list.
+	 */
 
-    asc_scsi_done_list(done_scp);
+	asc_scsi_done_list(done_scp);
 
-    ASC_DBG(1, "advansys_interrupt: end\n");
-    return IRQ_HANDLED;
+	ASC_DBG(1, "advansys_interrupt: end\n");
+	return IRQ_HANDLED;
 }
 
 /*
  * Set the number of commands to queue per device for the
  * specified host adapter.
  */
-STATIC int
-advansys_slave_configure(struct scsi_device *device)
+static int advansys_slave_configure(struct scsi_device *device)
 {
-    asc_board_t        *boardp;
+	asc_board_t *boardp;
 
-    boardp = ASC_BOARDP(device->host);
-    boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
-    /*
-     * Save a pointer to the device and set its initial/maximum
-     * queue depth.  Only save the pointer for a lun0 dev though.
-     */
-    if(device->lun == 0)
-        boardp->device[device->id] = device;
-    if(device->tagged_supported) {
-        if (ASC_NARROW_BOARD(boardp)) {
-	    scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
-                boardp->dvc_var.asc_dvc_var.max_dvc_qng[device->id]);
-        } else {
-	    scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
-                boardp->dvc_var.adv_dvc_var.max_dvc_qng);
-        }
-    } else {
-	scsi_adjust_queue_depth(device, 0, device->host->cmd_per_lun);
-    }
-    ASC_DBG4(1, "advansys_slave_configure: device 0x%lx, boardp 0x%lx, id %d, depth %d\n",
-            (ulong) device, (ulong) boardp, device->id, device->queue_depth);
-    return 0;
+	boardp = ASC_BOARDP(device->host);
+	boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
+	/*
+	 * Save a pointer to the device and set its initial/maximum
+	 * queue depth.  Only save the pointer for a lun0 dev though.
+	 */
+	if (device->lun == 0)
+		boardp->device[device->id] = device;
+	if (device->tagged_supported) {
+		if (ASC_NARROW_BOARD(boardp)) {
+			scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
+						boardp->dvc_var.asc_dvc_var.
+						max_dvc_qng[device->id]);
+		} else {
+			scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
+						boardp->dvc_var.adv_dvc_var.
+						max_dvc_qng);
+		}
+	} else {
+		scsi_adjust_queue_depth(device, 0, device->host->cmd_per_lun);
+	}
+	ASC_DBG4(1,
+		 "advansys_slave_configure: device 0x%lx, boardp 0x%lx, id %d, depth %d\n",
+		 (ulong)device, (ulong)boardp, device->id, device->queue_depth);
+	return 0;
 }
 
 /*
@@ -6045,43 +4839,44 @@ advansys_slave_configure(struct scsi_device *device)
  *
  * Interrupts can be enabled on entry.
  */
-STATIC void
-asc_scsi_done_list(struct scsi_cmnd *scp)
+static void asc_scsi_done_list(struct scsi_cmnd *scp)
 {
-    struct scsi_cmnd    *tscp;
+	struct scsi_cmnd *tscp;
 
-    ASC_DBG(2, "asc_scsi_done_list: begin\n");
-    while (scp != NULL) {
-	asc_board_t *boardp;
-	struct device *dev;
+	ASC_DBG(2, "asc_scsi_done_list: begin\n");
+	while (scp != NULL) {
+		asc_board_t *boardp;
+		struct device *dev;
 
-        ASC_DBG1(3, "asc_scsi_done_list: scp 0x%lx\n", (ulong) scp);
-        tscp = REQPNEXT(scp);
-        scp->host_scribble = NULL;
+		ASC_DBG1(3, "asc_scsi_done_list: scp 0x%lx\n", (ulong)scp);
+		tscp = REQPNEXT(scp);
+		scp->host_scribble = NULL;
 
-	boardp = ASC_BOARDP(scp->device->host);
+		boardp = ASC_BOARDP(scp->device->host);
 
-	if (ASC_NARROW_BOARD(boardp))
-	    dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
-	else
-	    dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
+		if (ASC_NARROW_BOARD(boardp))
+			dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
+		else
+			dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
 
-	if (scp->use_sg)
-	    dma_unmap_sg(dev, (struct scatterlist *)scp->request_buffer,
-			 scp->use_sg, scp->sc_data_direction);
-	else if (scp->request_bufflen)
-	    dma_unmap_single(dev, scp->SCp.dma_handle,
-			     scp->request_bufflen, scp->sc_data_direction);
+		if (scp->use_sg)
+			dma_unmap_sg(dev,
+				     (struct scatterlist *)scp->request_buffer,
+				     scp->use_sg, scp->sc_data_direction);
+		else if (scp->request_bufflen)
+			dma_unmap_single(dev, scp->SCp.dma_handle,
+					 scp->request_bufflen,
+					 scp->sc_data_direction);
 
-        ASC_STATS(scp->device->host, done);
-        ASC_ASSERT(scp->scsi_done != NULL);
+		ASC_STATS(scp->device->host, done);
+		ASC_ASSERT(scp->scsi_done != NULL);
 
-        scp->scsi_done(scp);
+		scp->scsi_done(scp);
 
-        scp = tscp;
-    }
-    ASC_DBG(2, "asc_scsi_done_list: done\n");
-    return;
+		scp = tscp;
+	}
+	ASC_DBG(2, "asc_scsi_done_list: done\n");
+	return;
 }
 
 /*
@@ -6130,168 +4925,170 @@ asc_scsi_done_list(struct scsi_cmnd *scp)
  * If ASC_BUSY is returned the request will be enqueued by the
  * caller on the target's waiting queue and re-tried later.
  */
-STATIC int
-asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
+static int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
 {
-    asc_board_t        *boardp;
-    ASC_DVC_VAR        *asc_dvc_varp;
-    ADV_DVC_VAR        *adv_dvc_varp;
-    ADV_SCSI_REQ_Q     *adv_scsiqp;
-    struct scsi_device *device;
-    int                ret;
-
-    ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
-        (ulong) scp, (ulong) scp->scsi_done);
-
-    boardp = ASC_BOARDP(scp->device->host);
-    device = boardp->device[scp->device->id];
-
-    if (ASC_NARROW_BOARD(boardp)) {
-        /*
-         * Build and execute Narrow Board request.
-         */
-
-        asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-
-        /*
-         * Build Asc Library request structure using the
-         * global structures 'asc_scsi_req' and 'asc_sg_head'.
-         *
-         * If an error is returned, then the request has been
-         * queued on the board done queue. It will be completed
-         * by the caller.
-         *
-         * asc_build_req() can not return ASC_BUSY.
-         */
-        if (asc_build_req(boardp, scp) == ASC_ERROR) {
-            ASC_STATS(scp->device->host, build_error);
-            return ASC_ERROR;
-        }
-
-        /*
-         * Execute the command. If there is no error, add the command
-         * to the active queue.
-         */
-        switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
-        case ASC_NOERROR:
-            ASC_STATS(scp->device->host, exe_noerror);
-            /*
-             * Increment monotonically increasing per device successful
-             * request counter. Wrapping doesn't matter.
-             */
-            boardp->reqcnt[scp->device->id]++;
-            asc_enqueue(&boardp->active, scp, ASC_BACK);
-            ASC_DBG(1,
-                "asc_execute_scsi_cmnd: AscExeScsiQueue(), ASC_NOERROR\n");
-            break;
-        case ASC_BUSY:
-            /*
-             * Caller will enqueue request on the target's waiting queue
-             * and retry later.
-             */
-            ASC_STATS(scp->device->host, exe_busy);
-            break;
-        case ASC_ERROR:
-            ASC_PRINT2(
-"asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-                boardp->id, asc_dvc_varp->err_code);
-            ASC_STATS(scp->device->host, exe_error);
-            scp->result = HOST_BYTE(DID_ERROR);
-            asc_enqueue(&boardp->done, scp, ASC_BACK);
-            break;
-        default:
-            ASC_PRINT2(
-"asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() unknown, err_code 0x%x\n",
-                boardp->id, asc_dvc_varp->err_code);
-            ASC_STATS(scp->device->host, exe_unknown);
-            scp->result = HOST_BYTE(DID_ERROR);
-            asc_enqueue(&boardp->done, scp, ASC_BACK);
-            break;
-        }
-    } else {
-        /*
-         * Build and execute Wide Board request.
-         */
-        adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-
-        /*
-         * Build and get a pointer to an Adv Library request structure.
-         *
-         * If the request is successfully built then send it below,
-         * otherwise return with an error.
-         */
-        switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
-        case ASC_NOERROR:
-            ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req ASC_NOERROR\n");
-            break;
-        case ASC_BUSY:
-            ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req ASC_BUSY\n");
-            /*
-             * If busy is returned the request has not been enqueued.
-             * It will be enqueued by the caller on the target's waiting
-             * queue and retried later.
-             *
-             * The asc_stats fields 'adv_build_noreq' and 'adv_build_nosg'
-             * count wide board busy conditions. They are updated in
-             * adv_build_req and adv_get_sglist, respectively.
-             */
-            return ASC_BUSY;
-        case ASC_ERROR:
-             /* 
-              * If an error is returned, then the request has been
-              * queued on the board done queue. It will be completed
-              * by the caller.
-              */
-        default:
-            ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req ASC_ERROR\n");
-            ASC_STATS(scp->device->host, build_error);
-            return ASC_ERROR;
-        }
-
-        /*
-         * Execute the command. If there is no error, add the command
-         * to the active queue.
-         */
-        switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
-        case ASC_NOERROR:
-            ASC_STATS(scp->device->host, exe_noerror);
-            /*
-             * Increment monotonically increasing per device successful
-             * request counter. Wrapping doesn't matter.
-             */
-            boardp->reqcnt[scp->device->id]++;
-            asc_enqueue(&boardp->active, scp, ASC_BACK);
-            ASC_DBG(1,
-                "asc_execute_scsi_cmnd: AdvExeScsiQueue(), ASC_NOERROR\n");
-            break;
-        case ASC_BUSY:
-            /*
-             * Caller will enqueue request on the target's waiting queue
-             * and retry later.
-             */
-            ASC_STATS(scp->device->host, exe_busy);
-            break;
-        case ASC_ERROR:
-            ASC_PRINT2(
-"asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
-                boardp->id, adv_dvc_varp->err_code);
-            ASC_STATS(scp->device->host, exe_error);
-            scp->result = HOST_BYTE(DID_ERROR);
-            asc_enqueue(&boardp->done, scp, ASC_BACK);
-            break;
-        default:
-            ASC_PRINT2(
-"asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() unknown, err_code 0x%x\n",
-                boardp->id, adv_dvc_varp->err_code);
-            ASC_STATS(scp->device->host, exe_unknown);
-            scp->result = HOST_BYTE(DID_ERROR);
-            asc_enqueue(&boardp->done, scp, ASC_BACK);
-            break;
-        }
-    }
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	ADV_SCSI_REQ_Q *adv_scsiqp;
+	struct scsi_device *device;
+	int ret;
+
+	ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
+		 (ulong)scp, (ulong)scp->scsi_done);
+
+	boardp = ASC_BOARDP(scp->device->host);
+	device = boardp->device[scp->device->id];
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		/*
+		 * Build and execute Narrow Board request.
+		 */
+
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+
+		/*
+		 * Build Asc Library request structure using the
+		 * global structures 'asc_scsi_req' and 'asc_sg_head'.
+		 *
+		 * If an error is returned, then the request has been
+		 * queued on the board done queue. It will be completed
+		 * by the caller.
+		 *
+		 * asc_build_req() can not return ASC_BUSY.
+		 */
+		if (asc_build_req(boardp, scp) == ASC_ERROR) {
+			ASC_STATS(scp->device->host, build_error);
+			return ASC_ERROR;
+		}
+
+		/*
+		 * Execute the command. If there is no error, add the command
+		 * to the active queue.
+		 */
+		switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
+		case ASC_NOERROR:
+			ASC_STATS(scp->device->host, exe_noerror);
+			/*
+			 * Increment monotonically increasing per device successful
+			 * request counter. Wrapping doesn't matter.
+			 */
+			boardp->reqcnt[scp->device->id]++;
+			asc_enqueue(&boardp->active, scp, ASC_BACK);
+			ASC_DBG(1,
+				"asc_execute_scsi_cmnd: AscExeScsiQueue(), ASC_NOERROR\n");
+			break;
+		case ASC_BUSY:
+			/*
+			 * Caller will enqueue request on the target's waiting queue
+			 * and retry later.
+			 */
+			ASC_STATS(scp->device->host, exe_busy);
+			break;
+		case ASC_ERROR:
+			ASC_PRINT2
+			    ("asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+			     boardp->id, asc_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_error);
+			scp->result = HOST_BYTE(DID_ERROR);
+			asc_enqueue(&boardp->done, scp, ASC_BACK);
+			break;
+		default:
+			ASC_PRINT2
+			    ("asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() unknown, err_code 0x%x\n",
+			     boardp->id, asc_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_unknown);
+			scp->result = HOST_BYTE(DID_ERROR);
+			asc_enqueue(&boardp->done, scp, ASC_BACK);
+			break;
+		}
+	} else {
+		/*
+		 * Build and execute Wide Board request.
+		 */
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+
+		/*
+		 * Build and get a pointer to an Adv Library request structure.
+		 *
+		 * If the request is successfully built then send it below,
+		 * otherwise return with an error.
+		 */
+		switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
+		case ASC_NOERROR:
+			ASC_DBG(3,
+				"asc_execute_scsi_cmnd: adv_build_req ASC_NOERROR\n");
+			break;
+		case ASC_BUSY:
+			ASC_DBG(1,
+				"asc_execute_scsi_cmnd: adv_build_req ASC_BUSY\n");
+			/*
+			 * If busy is returned the request has not been enqueued.
+			 * It will be enqueued by the caller on the target's waiting
+			 * queue and retried later.
+			 *
+			 * The asc_stats fields 'adv_build_noreq' and 'adv_build_nosg'
+			 * count wide board busy conditions. They are updated in
+			 * adv_build_req and adv_get_sglist, respectively.
+			 */
+			return ASC_BUSY;
+		case ASC_ERROR:
+			/* 
+			 * If an error is returned, then the request has been
+			 * queued on the board done queue. It will be completed
+			 * by the caller.
+			 */
+		default:
+			ASC_DBG(1,
+				"asc_execute_scsi_cmnd: adv_build_req ASC_ERROR\n");
+			ASC_STATS(scp->device->host, build_error);
+			return ASC_ERROR;
+		}
 
-    ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");
-    return ret;
+		/*
+		 * Execute the command. If there is no error, add the command
+		 * to the active queue.
+		 */
+		switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
+		case ASC_NOERROR:
+			ASC_STATS(scp->device->host, exe_noerror);
+			/*
+			 * Increment monotonically increasing per device successful
+			 * request counter. Wrapping doesn't matter.
+			 */
+			boardp->reqcnt[scp->device->id]++;
+			asc_enqueue(&boardp->active, scp, ASC_BACK);
+			ASC_DBG(1,
+				"asc_execute_scsi_cmnd: AdvExeScsiQueue(), ASC_NOERROR\n");
+			break;
+		case ASC_BUSY:
+			/*
+			 * Caller will enqueue request on the target's waiting queue
+			 * and retry later.
+			 */
+			ASC_STATS(scp->device->host, exe_busy);
+			break;
+		case ASC_ERROR:
+			ASC_PRINT2
+			    ("asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+			     boardp->id, adv_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_error);
+			scp->result = HOST_BYTE(DID_ERROR);
+			asc_enqueue(&boardp->done, scp, ASC_BACK);
+			break;
+		default:
+			ASC_PRINT2
+			    ("asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() unknown, err_code 0x%x\n",
+			     boardp->id, adv_dvc_varp->err_code);
+			ASC_STATS(scp->device->host, exe_unknown);
+			scp->result = HOST_BYTE(DID_ERROR);
+			asc_enqueue(&boardp->done, scp, ASC_BACK);
+			break;
+		}
+	}
+
+	ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");
+	return ret;
 }
 
 /*
@@ -6303,131 +5100,140 @@ asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
  * If an error occurs, then queue the request on the board done
  * queue and return ASC_ERROR.
  */
-STATIC int
-asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
+static int asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
 {
-    struct device *dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
-
-    /*
-     * Mutually exclusive access is required to 'asc_scsi_q' and
-     * 'asc_sg_head' until after the request is started.
-     */
-    memset(&asc_scsi_q, 0, sizeof(ASC_SCSI_Q));
-
-    /*
-     * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
-     */
-    asc_scsi_q.q2.srb_ptr = ASC_VADDR_TO_U32(scp);
-
-    /*
-     * Build the ASC_SCSI_Q request.
-     *
-     * For narrow boards a CDB length maximum of 12 bytes
-     * is supported.
-     */
-    if (scp->cmd_len > ASC_MAX_CDB_LEN) {
-        ASC_PRINT3(
-"asc_build_req: board %d: cmd_len %d > ASC_MAX_CDB_LEN  %d\n",
-            boardp->id, scp->cmd_len, ASC_MAX_CDB_LEN);
-        scp->result = HOST_BYTE(DID_ERROR);
-        asc_enqueue(&boardp->done, scp, ASC_BACK);
-        return ASC_ERROR;
-    }
-    asc_scsi_q.cdbptr = &scp->cmnd[0];
-    asc_scsi_q.q2.cdb_len = scp->cmd_len;
-    asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
-    asc_scsi_q.q1.target_lun = scp->device->lun;
-    asc_scsi_q.q2.target_ix = ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
-    asc_scsi_q.q1.sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-    asc_scsi_q.q1.sense_len = sizeof(scp->sense_buffer);
+	struct device *dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
+
+	/*
+	 * Mutually exclusive access is required to 'asc_scsi_q' and
+	 * 'asc_sg_head' until after the request is started.
+	 */
+	memset(&asc_scsi_q, 0, sizeof(ASC_SCSI_Q));
+
+	/*
+	 * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
+	 */
+	asc_scsi_q.q2.srb_ptr = ASC_VADDR_TO_U32(scp);
+
+	/*
+	 * Build the ASC_SCSI_Q request.
+	 *
+	 * For narrow boards a CDB length maximum of 12 bytes
+	 * is supported.
+	 */
+	if (scp->cmd_len > ASC_MAX_CDB_LEN) {
+		ASC_PRINT3
+		    ("asc_build_req: board %d: cmd_len %d > ASC_MAX_CDB_LEN  %d\n",
+		     boardp->id, scp->cmd_len, ASC_MAX_CDB_LEN);
+		scp->result = HOST_BYTE(DID_ERROR);
+		asc_enqueue(&boardp->done, scp, ASC_BACK);
+		return ASC_ERROR;
+	}
+	asc_scsi_q.cdbptr = &scp->cmnd[0];
+	asc_scsi_q.q2.cdb_len = scp->cmd_len;
+	asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
+	asc_scsi_q.q1.target_lun = scp->device->lun;
+	asc_scsi_q.q2.target_ix =
+	    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
+	asc_scsi_q.q1.sense_addr =
+	    cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+	asc_scsi_q.q1.sense_len = sizeof(scp->sense_buffer);
+
+	/*
+	 * If there are any outstanding requests for the current target,
+	 * then every 255th request send an ORDERED request. This heuristic
+	 * tries to retain the benefit of request sorting while preventing
+	 * request starvation. 255 is the max number of tags or pending commands
+	 * a device may have outstanding.
+	 *
+	 * The request count is incremented below for every successfully
+	 * started request.
+	 *
+	 */
+	if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
+	    (boardp->reqcnt[scp->device->id] % 255) == 0) {
+		asc_scsi_q.q2.tag_code = MSG_ORDERED_TAG;
+	} else {
+		asc_scsi_q.q2.tag_code = MSG_SIMPLE_TAG;
+	}
 
-    /*
-     * If there are any outstanding requests for the current target,
-     * then every 255th request send an ORDERED request. This heuristic
-     * tries to retain the benefit of request sorting while preventing
-     * request starvation. 255 is the max number of tags or pending commands
-     * a device may have outstanding.
-     *
-     * The request count is incremented below for every successfully
-     * started request.
-     *
-     */
-    if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
-        (boardp->reqcnt[scp->device->id] % 255) == 0) {
-        asc_scsi_q.q2.tag_code = MSG_ORDERED_TAG;
-    } else {
-        asc_scsi_q.q2.tag_code = MSG_SIMPLE_TAG;
-    }
+	/*
+	 * Build ASC_SCSI_Q for a contiguous buffer or a scatter-gather
+	 * buffer command.
+	 */
+	if (scp->use_sg == 0) {
+		/*
+		 * CDB request of single contiguous buffer.
+		 */
+		ASC_STATS(scp->device->host, cont_cnt);
+		scp->SCp.dma_handle = scp->request_bufflen ?
+		    dma_map_single(dev, scp->request_buffer,
+				   scp->request_bufflen,
+				   scp->sc_data_direction) : 0;
+		asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
+		asc_scsi_q.q1.data_cnt = cpu_to_le32(scp->request_bufflen);
+		ASC_STATS_ADD(scp->device->host, cont_xfer,
+			      ASC_CEILING(scp->request_bufflen, 512));
+		asc_scsi_q.q1.sg_queue_cnt = 0;
+		asc_scsi_q.sg_head = NULL;
+	} else {
+		/*
+		 * CDB scatter-gather request list.
+		 */
+		int sgcnt;
+		int use_sg;
+		struct scatterlist *slp;
+
+		slp = (struct scatterlist *)scp->request_buffer;
+		use_sg =
+		    dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+
+		if (use_sg > scp->device->host->sg_tablesize) {
+			ASC_PRINT3
+			    ("asc_build_req: board %d: use_sg %d > sg_tablesize %d\n",
+			     boardp->id, use_sg,
+			     scp->device->host->sg_tablesize);
+			dma_unmap_sg(dev, slp, scp->use_sg,
+				     scp->sc_data_direction);
+			scp->result = HOST_BYTE(DID_ERROR);
+			asc_enqueue(&boardp->done, scp, ASC_BACK);
+			return ASC_ERROR;
+		}
+
+		ASC_STATS(scp->device->host, sg_cnt);
 
-    /*
-     * Build ASC_SCSI_Q for a contiguous buffer or a scatter-gather
-     * buffer command.
-     */
-    if (scp->use_sg == 0) {
-        /*
-         * CDB request of single contiguous buffer.
-         */
-        ASC_STATS(scp->device->host, cont_cnt);
-	scp->SCp.dma_handle = scp->request_bufflen ?
-	    dma_map_single(dev, scp->request_buffer,
-			   scp->request_bufflen, scp->sc_data_direction) : 0;
-	asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
-        asc_scsi_q.q1.data_cnt = cpu_to_le32(scp->request_bufflen);
-        ASC_STATS_ADD(scp->device->host, cont_xfer,
-                      ASC_CEILING(scp->request_bufflen, 512));
-        asc_scsi_q.q1.sg_queue_cnt = 0;
-        asc_scsi_q.sg_head = NULL;
-    } else {
-        /*
-         * CDB scatter-gather request list.
-         */
-        int                     sgcnt;
-	int			use_sg;
-        struct scatterlist      *slp;
+		/*
+		 * Use global ASC_SG_HEAD structure and set the ASC_SCSI_Q
+		 * structure to point to it.
+		 */
+		memset(&asc_sg_head, 0, sizeof(ASC_SG_HEAD));
+
+		asc_scsi_q.q1.cntl |= QC_SG_HEAD;
+		asc_scsi_q.sg_head = &asc_sg_head;
+		asc_scsi_q.q1.data_cnt = 0;
+		asc_scsi_q.q1.data_addr = 0;
+		/* This is a byte value, otherwise it would need to be swapped. */
+		asc_sg_head.entry_cnt = asc_scsi_q.q1.sg_queue_cnt = use_sg;
+		ASC_STATS_ADD(scp->device->host, sg_elem,
+			      asc_sg_head.entry_cnt);
 
-	slp = (struct scatterlist *)scp->request_buffer;
-	use_sg = dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
-
-	if (use_sg > scp->device->host->sg_tablesize) {
-            ASC_PRINT3(
-"asc_build_req: board %d: use_sg %d > sg_tablesize %d\n",
-		boardp->id, use_sg, scp->device->host->sg_tablesize);
-	    dma_unmap_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
-            scp->result = HOST_BYTE(DID_ERROR);
-            asc_enqueue(&boardp->done, scp, ASC_BACK);
-            return ASC_ERROR;
-        }
-
-        ASC_STATS(scp->device->host, sg_cnt);
-
-        /*
-         * Use global ASC_SG_HEAD structure and set the ASC_SCSI_Q
-         * structure to point to it.
-         */
-        memset(&asc_sg_head, 0, sizeof(ASC_SG_HEAD));
-
-        asc_scsi_q.q1.cntl |= QC_SG_HEAD;
-        asc_scsi_q.sg_head = &asc_sg_head;
-        asc_scsi_q.q1.data_cnt = 0;
-        asc_scsi_q.q1.data_addr = 0;
-        /* This is a byte value, otherwise it would need to be swapped. */
-	asc_sg_head.entry_cnt = asc_scsi_q.q1.sg_queue_cnt = use_sg;
-        ASC_STATS_ADD(scp->device->host, sg_elem, asc_sg_head.entry_cnt);
-
-        /*
-         * Convert scatter-gather list into ASC_SG_HEAD list.
-         */
-	for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
-	    asc_sg_head.sg_list[sgcnt].addr = cpu_to_le32(sg_dma_address(slp));
-	    asc_sg_head.sg_list[sgcnt].bytes = cpu_to_le32(sg_dma_len(slp));
-	    ASC_STATS_ADD(scp->device->host, sg_xfer, ASC_CEILING(sg_dma_len(slp), 512));
-        }
-    }
+		/*
+		 * Convert scatter-gather list into ASC_SG_HEAD list.
+		 */
+		for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
+			asc_sg_head.sg_list[sgcnt].addr =
+			    cpu_to_le32(sg_dma_address(slp));
+			asc_sg_head.sg_list[sgcnt].bytes =
+			    cpu_to_le32(sg_dma_len(slp));
+			ASC_STATS_ADD(scp->device->host, sg_xfer,
+				      ASC_CEILING(sg_dma_len(slp), 512));
+		}
+	}
 
-    ASC_DBG_PRT_ASC_SCSI_Q(2, &asc_scsi_q);
-    ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+	ASC_DBG_PRT_ASC_SCSI_Q(2, &asc_scsi_q);
+	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
-    return ASC_NOERROR;
+	return ASC_NOERROR;
 }
 
 /*
@@ -6440,162 +5246,168 @@ asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
  * microcode for DMA addresses or math operations are byte swapped
  * to little-endian order.
  */
-STATIC int
+static int
 adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
-    ADV_SCSI_REQ_Q **adv_scsiqpp)
+	      ADV_SCSI_REQ_Q **adv_scsiqpp)
 {
-    adv_req_t           *reqp;
-    ADV_SCSI_REQ_Q      *scsiqp;
-    int                 i;
-    int                 ret;
-    struct device	*dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
-
-    /*
-     * Allocate an adv_req_t structure from the board to execute
-     * the command.
-     */
-    if (boardp->adv_reqp == NULL) {
-        ASC_DBG(1, "adv_build_req: no free adv_req_t\n");
-        ASC_STATS(scp->device->host, adv_build_noreq);
-        return ASC_BUSY;
-    } else {
-        reqp = boardp->adv_reqp;
-        boardp->adv_reqp = reqp->next_reqp;
-        reqp->next_reqp = NULL;
-    }
-
-    /*
-     * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.
-     */
-    scsiqp = (ADV_SCSI_REQ_Q *) ADV_32BALIGN(&reqp->scsi_req_q);
-
-    /*
-     * Initialize the structure.
-     */
-    scsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;
-
-    /*
-     * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
-     */
-    scsiqp->srb_ptr = ASC_VADDR_TO_U32(reqp);
-
-    /*
-     * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
-     */
-    reqp->cmndp = scp;
+	adv_req_t *reqp;
+	ADV_SCSI_REQ_Q *scsiqp;
+	int i;
+	int ret;
+	struct device *dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
+
+	/*
+	 * Allocate an adv_req_t structure from the board to execute
+	 * the command.
+	 */
+	if (boardp->adv_reqp == NULL) {
+		ASC_DBG(1, "adv_build_req: no free adv_req_t\n");
+		ASC_STATS(scp->device->host, adv_build_noreq);
+		return ASC_BUSY;
+	} else {
+		reqp = boardp->adv_reqp;
+		boardp->adv_reqp = reqp->next_reqp;
+		reqp->next_reqp = NULL;
+	}
 
-    /*
-     * Build the ADV_SCSI_REQ_Q request.
-     */
+	/*
+	 * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.
+	 */
+	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
+
+	/*
+	 * Initialize the structure.
+	 */
+	scsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;
+
+	/*
+	 * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
+	 */
+	scsiqp->srb_ptr = ASC_VADDR_TO_U32(reqp);
+
+	/*
+	 * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
+	 */
+	reqp->cmndp = scp;
+
+	/*
+	 * Build the ADV_SCSI_REQ_Q request.
+	 */
+
+	/*
+	 * Set CDB length and copy it to the request structure.
+	 * For wide  boards a CDB length maximum of 16 bytes
+	 * is supported.
+	 */
+	if (scp->cmd_len > ADV_MAX_CDB_LEN) {
+		ASC_PRINT3
+		    ("adv_build_req: board %d: cmd_len %d > ADV_MAX_CDB_LEN  %d\n",
+		     boardp->id, scp->cmd_len, ADV_MAX_CDB_LEN);
+		scp->result = HOST_BYTE(DID_ERROR);
+		asc_enqueue(&boardp->done, scp, ASC_BACK);
+		return ASC_ERROR;
+	}
+	scsiqp->cdb_len = scp->cmd_len;
+	/* Copy first 12 CDB bytes to cdb[]. */
+	for (i = 0; i < scp->cmd_len && i < 12; i++) {
+		scsiqp->cdb[i] = scp->cmnd[i];
+	}
+	/* Copy last 4 CDB bytes, if present, to cdb16[]. */
+	for (; i < scp->cmd_len; i++) {
+		scsiqp->cdb16[i - 12] = scp->cmnd[i];
+	}
 
-    /*
-     * Set CDB length and copy it to the request structure.
-     * For wide  boards a CDB length maximum of 16 bytes
-     * is supported.
-     */
-    if (scp->cmd_len > ADV_MAX_CDB_LEN) {
-        ASC_PRINT3(
-"adv_build_req: board %d: cmd_len %d > ADV_MAX_CDB_LEN  %d\n",
-            boardp->id, scp->cmd_len, ADV_MAX_CDB_LEN);
-        scp->result = HOST_BYTE(DID_ERROR);
-        asc_enqueue(&boardp->done, scp, ASC_BACK);
-        return ASC_ERROR;
-    }
-    scsiqp->cdb_len = scp->cmd_len;
-    /* Copy first 12 CDB bytes to cdb[]. */
-    for (i = 0; i < scp->cmd_len && i < 12; i++) {
-        scsiqp->cdb[i] = scp->cmnd[i];
-    }
-    /* Copy last 4 CDB bytes, if present, to cdb16[]. */
-    for (; i < scp->cmd_len; i++) {
-        scsiqp->cdb16[i - 12] = scp->cmnd[i];
-    }
+	scsiqp->target_id = scp->device->id;
+	scsiqp->target_lun = scp->device->lun;
 
-    scsiqp->target_id = scp->device->id;
-    scsiqp->target_lun = scp->device->lun;
+	scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+	scsiqp->sense_len = sizeof(scp->sense_buffer);
 
-    scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
-    scsiqp->sense_len = sizeof(scp->sense_buffer);
+	/*
+	 * Build ADV_SCSI_REQ_Q for a contiguous buffer or a scatter-gather
+	 * buffer command.
+	 */
 
-    /*
-     * Build ADV_SCSI_REQ_Q for a contiguous buffer or a scatter-gather
-     * buffer command.
-     */
-
-    scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
-    scsiqp->vdata_addr = scp->request_buffer;
-    scsiqp->data_addr = cpu_to_le32(virt_to_bus(scp->request_buffer));
-
-    if (scp->use_sg == 0) {
-        /*
-         * CDB request of single contiguous buffer.
-         */
-        reqp->sgblkp = NULL;
 	scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
-	if (scp->request_bufflen) {
-	    scsiqp->vdata_addr = scp->request_buffer;
-	    scp->SCp.dma_handle =
-	        dma_map_single(dev, scp->request_buffer,
-			       scp->request_bufflen, scp->sc_data_direction);
-	} else {
-	    scsiqp->vdata_addr = NULL;
-	    scp->SCp.dma_handle = 0;
-	}
-	scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);
-        scsiqp->sg_list_ptr = NULL;
-        scsiqp->sg_real_addr = 0;
-        ASC_STATS(scp->device->host, cont_cnt);
-        ASC_STATS_ADD(scp->device->host, cont_xfer,
-                      ASC_CEILING(scp->request_bufflen, 512));
-    } else {
-        /*
-         * CDB scatter-gather request list.
-         */
-	struct scatterlist *slp;
-	int use_sg;
+	scsiqp->vdata_addr = scp->request_buffer;
+	scsiqp->data_addr = cpu_to_le32(virt_to_bus(scp->request_buffer));
 
-	slp = (struct scatterlist *)scp->request_buffer;
-	use_sg = dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
-
-	if (use_sg > ADV_MAX_SG_LIST) {
-            ASC_PRINT3(
-"adv_build_req: board %d: use_sg %d > ADV_MAX_SG_LIST %d\n",
-		boardp->id, use_sg, scp->device->host->sg_tablesize);
-	    dma_unmap_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
-            scp->result = HOST_BYTE(DID_ERROR);
-            asc_enqueue(&boardp->done, scp, ASC_BACK);
-
-            /*
-             * Free the 'adv_req_t' structure by adding it back to the
-             * board free list.
-             */
-            reqp->next_reqp = boardp->adv_reqp;
-            boardp->adv_reqp = reqp;
-
-            return ASC_ERROR;
-        }
-
-	if ((ret = adv_get_sglist(boardp, reqp, scp, use_sg)) != ADV_SUCCESS) {
-            /*
-             * Free the adv_req_t structure by adding it back to the
-             * board free list.
-             */
-            reqp->next_reqp = boardp->adv_reqp;
-            boardp->adv_reqp = reqp;
-
-            return ret;
-        }
-
-        ASC_STATS(scp->device->host, sg_cnt);
-	ASC_STATS_ADD(scp->device->host, sg_elem, use_sg);
-    }
+	if (scp->use_sg == 0) {
+		/*
+		 * CDB request of single contiguous buffer.
+		 */
+		reqp->sgblkp = NULL;
+		scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
+		if (scp->request_bufflen) {
+			scsiqp->vdata_addr = scp->request_buffer;
+			scp->SCp.dma_handle =
+			    dma_map_single(dev, scp->request_buffer,
+					   scp->request_bufflen,
+					   scp->sc_data_direction);
+		} else {
+			scsiqp->vdata_addr = NULL;
+			scp->SCp.dma_handle = 0;
+		}
+		scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);
+		scsiqp->sg_list_ptr = NULL;
+		scsiqp->sg_real_addr = 0;
+		ASC_STATS(scp->device->host, cont_cnt);
+		ASC_STATS_ADD(scp->device->host, cont_xfer,
+			      ASC_CEILING(scp->request_bufflen, 512));
+	} else {
+		/*
+		 * CDB scatter-gather request list.
+		 */
+		struct scatterlist *slp;
+		int use_sg;
+
+		slp = (struct scatterlist *)scp->request_buffer;
+		use_sg =
+		    dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+
+		if (use_sg > ADV_MAX_SG_LIST) {
+			ASC_PRINT3
+			    ("adv_build_req: board %d: use_sg %d > ADV_MAX_SG_LIST %d\n",
+			     boardp->id, use_sg,
+			     scp->device->host->sg_tablesize);
+			dma_unmap_sg(dev, slp, scp->use_sg,
+				     scp->sc_data_direction);
+			scp->result = HOST_BYTE(DID_ERROR);
+			asc_enqueue(&boardp->done, scp, ASC_BACK);
+
+			/*
+			 * Free the 'adv_req_t' structure by adding it back to the
+			 * board free list.
+			 */
+			reqp->next_reqp = boardp->adv_reqp;
+			boardp->adv_reqp = reqp;
+
+			return ASC_ERROR;
+		}
+
+		if ((ret =
+		     adv_get_sglist(boardp, reqp, scp,
+				    use_sg)) != ADV_SUCCESS) {
+			/*
+			 * Free the adv_req_t structure by adding it back to the
+			 * board free list.
+			 */
+			reqp->next_reqp = boardp->adv_reqp;
+			boardp->adv_reqp = reqp;
+
+			return ret;
+		}
+
+		ASC_STATS(scp->device->host, sg_cnt);
+		ASC_STATS_ADD(scp->device->host, sg_elem, use_sg);
+	}
 
-    ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
-    ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
+	ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
 
-    *adv_scsiqpp = scsiqp;
+	*adv_scsiqpp = scsiqp;
 
-    return ASC_NOERROR;
+	return ASC_NOERROR;
 }
 
 /*
@@ -6610,108 +5422,109 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
  *      ADV_SUCCESS(1) - SG List successfully created
  *      ADV_ERROR(-1) - SG List creation failed
  */
-STATIC int
-adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp, int use_sg)
+static int
+adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp,
+	       int use_sg)
 {
-    adv_sgblk_t         *sgblkp;
-    ADV_SCSI_REQ_Q      *scsiqp;
-    struct scatterlist  *slp;
-    int                 sg_elem_cnt;
-    ADV_SG_BLOCK        *sg_block, *prev_sg_block;
-    ADV_PADDR           sg_block_paddr;
-    int                 i;
-
-    scsiqp = (ADV_SCSI_REQ_Q *) ADV_32BALIGN(&reqp->scsi_req_q);
-    slp = (struct scatterlist *) scp->request_buffer;
-    sg_elem_cnt = use_sg;
-    prev_sg_block = NULL;
-    reqp->sgblkp = NULL;
-
-    do
-    {
-        /*
-         * Allocate a 'adv_sgblk_t' structure from the board free
-         * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
-         * (15) scatter-gather elements.
-         */
-        if ((sgblkp = boardp->adv_sgblkp) == NULL) {
-            ASC_DBG(1, "adv_get_sglist: no free adv_sgblk_t\n");
-            ASC_STATS(scp->device->host, adv_build_nosg);
-
-            /*
-             * Allocation failed. Free 'adv_sgblk_t' structures already
-             * allocated for the request.
-             */
-            while ((sgblkp = reqp->sgblkp) != NULL)
-            {
-                /* Remove 'sgblkp' from the request list. */
-                reqp->sgblkp = sgblkp->next_sgblkp;
-
-                /* Add 'sgblkp' to the board free list. */
-                sgblkp->next_sgblkp = boardp->adv_sgblkp;
-                boardp->adv_sgblkp = sgblkp;
-            }
-            return ASC_BUSY;
-        } else {
-            /* Complete 'adv_sgblk_t' board allocation. */
-            boardp->adv_sgblkp = sgblkp->next_sgblkp;
-            sgblkp->next_sgblkp = NULL;
-
-            /*
-             * Get 8 byte aligned virtual and physical addresses for
-             * the allocated ADV_SG_BLOCK structure.
-             */
-            sg_block = (ADV_SG_BLOCK *) ADV_8BALIGN(&sgblkp->sg_block);
-            sg_block_paddr = virt_to_bus(sg_block);
-
-            /*
-             * Check if this is the first 'adv_sgblk_t' for the request.
-             */
-            if (reqp->sgblkp == NULL)
-            {
-                /* Request's first scatter-gather block. */
-                reqp->sgblkp = sgblkp;
-
-                /*
-                 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
-                 * address pointers.
-                 */
-                scsiqp->sg_list_ptr = sg_block;
-                scsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);
-            } else
-            {
-                /* Request's second or later scatter-gather block. */
-                sgblkp->next_sgblkp = reqp->sgblkp;
-                reqp->sgblkp = sgblkp;
-
-                /*
-                 * Point the previous ADV_SG_BLOCK structure to
-                 * the newly allocated ADV_SG_BLOCK structure.
-                 */
-                ASC_ASSERT(prev_sg_block != NULL);
-                prev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);
-            }
-        }
-
-        for (i = 0; i < NO_OF_SG_PER_BLOCK; i++)
-        {
-	    sg_block->sg_list[i].sg_addr = cpu_to_le32(sg_dma_address(slp));
-	    sg_block->sg_list[i].sg_count = cpu_to_le32(sg_dma_len(slp));
-	    ASC_STATS_ADD(scp->device->host, sg_xfer, ASC_CEILING(sg_dma_len(slp), 512));
-
-            if (--sg_elem_cnt == 0)
-            {   /* Last ADV_SG_BLOCK and scatter-gather entry. */
-                sg_block->sg_cnt = i + 1;
-                sg_block->sg_ptr = 0L;    /* Last ADV_SG_BLOCK in list. */
-                return ADV_SUCCESS;
-            }
-            slp++;
-        }
-        sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
-        prev_sg_block = sg_block;
-    }
-    while (1);
-    /* NOTREACHED */
+	adv_sgblk_t *sgblkp;
+	ADV_SCSI_REQ_Q *scsiqp;
+	struct scatterlist *slp;
+	int sg_elem_cnt;
+	ADV_SG_BLOCK *sg_block, *prev_sg_block;
+	ADV_PADDR sg_block_paddr;
+	int i;
+
+	scsiqp = (ADV_SCSI_REQ_Q *)ADV_32BALIGN(&reqp->scsi_req_q);
+	slp = (struct scatterlist *)scp->request_buffer;
+	sg_elem_cnt = use_sg;
+	prev_sg_block = NULL;
+	reqp->sgblkp = NULL;
+
+	do {
+		/*
+		 * Allocate a 'adv_sgblk_t' structure from the board free
+		 * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
+		 * (15) scatter-gather elements.
+		 */
+		if ((sgblkp = boardp->adv_sgblkp) == NULL) {
+			ASC_DBG(1, "adv_get_sglist: no free adv_sgblk_t\n");
+			ASC_STATS(scp->device->host, adv_build_nosg);
+
+			/*
+			 * Allocation failed. Free 'adv_sgblk_t' structures already
+			 * allocated for the request.
+			 */
+			while ((sgblkp = reqp->sgblkp) != NULL) {
+				/* Remove 'sgblkp' from the request list. */
+				reqp->sgblkp = sgblkp->next_sgblkp;
+
+				/* Add 'sgblkp' to the board free list. */
+				sgblkp->next_sgblkp = boardp->adv_sgblkp;
+				boardp->adv_sgblkp = sgblkp;
+			}
+			return ASC_BUSY;
+		} else {
+			/* Complete 'adv_sgblk_t' board allocation. */
+			boardp->adv_sgblkp = sgblkp->next_sgblkp;
+			sgblkp->next_sgblkp = NULL;
+
+			/*
+			 * Get 8 byte aligned virtual and physical addresses for
+			 * the allocated ADV_SG_BLOCK structure.
+			 */
+			sg_block =
+			    (ADV_SG_BLOCK *)ADV_8BALIGN(&sgblkp->sg_block);
+			sg_block_paddr = virt_to_bus(sg_block);
+
+			/*
+			 * Check if this is the first 'adv_sgblk_t' for the request.
+			 */
+			if (reqp->sgblkp == NULL) {
+				/* Request's first scatter-gather block. */
+				reqp->sgblkp = sgblkp;
+
+				/*
+				 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
+				 * address pointers.
+				 */
+				scsiqp->sg_list_ptr = sg_block;
+				scsiqp->sg_real_addr =
+				    cpu_to_le32(sg_block_paddr);
+			} else {
+				/* Request's second or later scatter-gather block. */
+				sgblkp->next_sgblkp = reqp->sgblkp;
+				reqp->sgblkp = sgblkp;
+
+				/*
+				 * Point the previous ADV_SG_BLOCK structure to
+				 * the newly allocated ADV_SG_BLOCK structure.
+				 */
+				ASC_ASSERT(prev_sg_block != NULL);
+				prev_sg_block->sg_ptr =
+				    cpu_to_le32(sg_block_paddr);
+			}
+		}
+
+		for (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {
+			sg_block->sg_list[i].sg_addr =
+			    cpu_to_le32(sg_dma_address(slp));
+			sg_block->sg_list[i].sg_count =
+			    cpu_to_le32(sg_dma_len(slp));
+			ASC_STATS_ADD(scp->device->host, sg_xfer,
+				      ASC_CEILING(sg_dma_len(slp), 512));
+
+			if (--sg_elem_cnt == 0) {	/* Last ADV_SG_BLOCK and scatter-gather entry. */
+				sg_block->sg_cnt = i + 1;
+				sg_block->sg_ptr = 0L;	/* Last ADV_SG_BLOCK in list. */
+				return ADV_SUCCESS;
+			}
+			slp++;
+		}
+		sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
+		prev_sg_block = sg_block;
+	}
+	while (1);
+	/* NOTREACHED */
 }
 
 /*
@@ -6719,165 +5532,171 @@ adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp, int
  *
  * Interrupt callback function for the Narrow SCSI Asc Library.
  */
-STATIC void
-asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
+static void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
 {
-    asc_board_t         *boardp;
-    struct scsi_cmnd           *scp;
-    struct Scsi_Host    *shp;
-    int                 i;
-
-    ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
-        (ulong) asc_dvc_varp, (ulong) qdonep);
-    ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
+	asc_board_t *boardp;
+	struct scsi_cmnd *scp;
+	struct Scsi_Host *shost;
+	int i;
+
+	ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
+		 (ulong)asc_dvc_varp, (ulong)qdonep);
+	ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
+
+	/*
+	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
+	 * command that has been completed.
+	 */
+	scp = (struct scsi_cmnd *)ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
+	ASC_DBG1(1, "asc_isr_callback: scp 0x%lx\n", (ulong)scp);
+
+	if (scp == NULL) {
+		ASC_PRINT("asc_isr_callback: scp is NULL\n");
+		return;
+	}
+	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+
+	/*
+	 * If the request's host pointer is not valid, display a
+	 * message and return.
+	 */
+	shost = scp->device->host;
+	for (i = 0; i < asc_board_count; i++) {
+		if (asc_host[i] == shost) {
+			break;
+		}
+	}
+	if (i == asc_board_count) {
+		ASC_PRINT2
+		    ("asc_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
+		     (ulong)scp, (ulong)shost);
+		return;
+	}
 
-    /*
-     * Get the struct scsi_cmnd structure and Scsi_Host structure for the
-     * command that has been completed.
-     */
-    scp = (struct scsi_cmnd *) ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
-    ASC_DBG1(1, "asc_isr_callback: scp 0x%lx\n", (ulong) scp);
-
-    if (scp == NULL) {
-        ASC_PRINT("asc_isr_callback: scp is NULL\n");
-        return;
-    }
-    ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+	ASC_STATS(shost, callback);
+	ASC_DBG1(1, "asc_isr_callback: shost 0x%lx\n", (ulong)shost);
+
+	/*
+	 * If the request isn't found on the active queue, it may
+	 * have been removed to handle a reset request.
+	 * Display a message and return.
+	 */
+	boardp = ASC_BOARDP(shost);
+	ASC_ASSERT(asc_dvc_varp == &boardp->dvc_var.asc_dvc_var);
+	if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
+		ASC_PRINT2
+		    ("asc_isr_callback: board %d: scp 0x%lx not on active queue\n",
+		     boardp->id, (ulong)scp);
+		return;
+	}
 
-    /*
-     * If the request's host pointer is not valid, display a
-     * message and return.
-     */
-    shp = scp->device->host;
-    for (i = 0; i < asc_board_count; i++) {
-        if (asc_host[i] == shp) {
-            break;
-        }
-    }
-    if (i == asc_board_count) {
-        ASC_PRINT2(
-            "asc_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
-            (ulong) scp, (ulong) shp);
-        return;
-    }
+	/*
+	 * 'qdonep' contains the command's ending status.
+	 */
+	switch (qdonep->d3.done_stat) {
+	case QD_NO_ERROR:
+		ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
+		scp->result = 0;
 
-    ASC_STATS(shp, callback);
-    ASC_DBG1(1, "asc_isr_callback: shp 0x%lx\n", (ulong) shp);
+		/*
+		 * If an INQUIRY command completed successfully, then call
+		 * the AscInquiryHandling() function to set-up the device.
+		 */
+		if (scp->cmnd[0] == INQUIRY && scp->device->lun == 0 &&
+		    (scp->request_bufflen - qdonep->remain_bytes) >= 8) {
+			AscInquiryHandling(asc_dvc_varp, scp->device->id & 0x7,
+					   (ASC_SCSI_INQUIRY *)scp->
+					   request_buffer);
+		}
 
-    /*
-     * If the request isn't found on the active queue, it may
-     * have been removed to handle a reset request.
-     * Display a message and return.
-     */
-    boardp = ASC_BOARDP(shp);
-    ASC_ASSERT(asc_dvc_varp == &boardp->dvc_var.asc_dvc_var);
-    if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
-        ASC_PRINT2(
-            "asc_isr_callback: board %d: scp 0x%lx not on active queue\n",
-            boardp->id, (ulong) scp);
-        return;
-    }
+		/*
+		 * Check for an underrun condition.
+		 *
+		 * If there was no error and an underrun condition, then
+		 * then return the number of underrun bytes.
+		 */
+		if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
+		    qdonep->remain_bytes <= scp->request_bufflen) {
+			ASC_DBG1(1,
+				 "asc_isr_callback: underrun condition %u bytes\n",
+				 (unsigned)qdonep->remain_bytes);
+			scp->resid = qdonep->remain_bytes;
+		}
+		break;
+
+	case QD_WITH_ERROR:
+		ASC_DBG(2, "asc_isr_callback: QD_WITH_ERROR\n");
+		switch (qdonep->d3.host_stat) {
+		case QHSTA_NO_ERROR:
+			if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
+				ASC_DBG(2,
+					"asc_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
+						  sizeof(scp->sense_buffer));
+				/*
+				 * Note: The 'status_byte()' macro used by target drivers
+				 * defined in scsi.h shifts the status byte returned by
+				 * host drivers right by 1 bit. This is why target drivers
+				 * also use right shifted status byte definitions. For
+				 * instance target drivers use CHECK_CONDITION, defined to
+				 * 0x1, instead of the SCSI defined check condition value
+				 * of 0x2. Host drivers are supposed to return the status
+				 * byte as it is defined by SCSI.
+				 */
+				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
+				    STATUS_BYTE(qdonep->d3.scsi_stat);
+			} else {
+				scp->result = STATUS_BYTE(qdonep->d3.scsi_stat);
+			}
+			break;
+
+		default:
+			/* QHSTA error occurred */
+			ASC_DBG1(1, "asc_isr_callback: host_stat 0x%x\n",
+				 qdonep->d3.host_stat);
+			scp->result = HOST_BYTE(DID_BAD_TARGET);
+			break;
+		}
+		break;
+
+	case QD_ABORTED_BY_HOST:
+		ASC_DBG(1, "asc_isr_callback: QD_ABORTED_BY_HOST\n");
+		scp->result =
+		    HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.
+						    scsi_msg) |
+		    STATUS_BYTE(qdonep->d3.scsi_stat);
+		break;
+
+	default:
+		ASC_DBG1(1, "asc_isr_callback: done_stat 0x%x\n",
+			 qdonep->d3.done_stat);
+		scp->result =
+		    HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.
+						    scsi_msg) |
+		    STATUS_BYTE(qdonep->d3.scsi_stat);
+		break;
+	}
 
-    /*
-     * 'qdonep' contains the command's ending status.
-     */
-    switch (qdonep->d3.done_stat) {
-    case QD_NO_ERROR:
-        ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
-        scp->result = 0;
-
-        /*
-         * If an INQUIRY command completed successfully, then call
-         * the AscInquiryHandling() function to set-up the device.
-         */
-        if (scp->cmnd[0] == INQUIRY && scp->device->lun == 0 &&
-            (scp->request_bufflen - qdonep->remain_bytes) >= 8)
-        {
-            AscInquiryHandling(asc_dvc_varp, scp->device->id & 0x7,
-                (ASC_SCSI_INQUIRY *) scp->request_buffer);
-        }
-
-        /*
-         * Check for an underrun condition.
-         *
-         * If there was no error and an underrun condition, then
-         * then return the number of underrun bytes.
-         */
-        if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
-            qdonep->remain_bytes <= scp->request_bufflen) {
-            ASC_DBG1(1, "asc_isr_callback: underrun condition %u bytes\n",
-            (unsigned) qdonep->remain_bytes);
-            scp->resid = qdonep->remain_bytes;
-        }
-        break;
-
-    case QD_WITH_ERROR:
-        ASC_DBG(2, "asc_isr_callback: QD_WITH_ERROR\n");
-        switch (qdonep->d3.host_stat) {
-        case QHSTA_NO_ERROR:
-            if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
-                ASC_DBG(2, "asc_isr_callback: SAM_STAT_CHECK_CONDITION\n");
-                ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
-                    sizeof(scp->sense_buffer));
-                /*
-                 * Note: The 'status_byte()' macro used by target drivers
-                 * defined in scsi.h shifts the status byte returned by
-                 * host drivers right by 1 bit. This is why target drivers
-                 * also use right shifted status byte definitions. For
-                 * instance target drivers use CHECK_CONDITION, defined to
-                 * 0x1, instead of the SCSI defined check condition value
-                 * of 0x2. Host drivers are supposed to return the status
-                 * byte as it is defined by SCSI.
-                 */
-                scp->result = DRIVER_BYTE(DRIVER_SENSE) |
-                    STATUS_BYTE(qdonep->d3.scsi_stat);
-            } else {
-                scp->result = STATUS_BYTE(qdonep->d3.scsi_stat);
-            }
-            break;
-
-        default:
-            /* QHSTA error occurred */
-            ASC_DBG1(1, "asc_isr_callback: host_stat 0x%x\n",
-                qdonep->d3.host_stat);
-            scp->result = HOST_BYTE(DID_BAD_TARGET);
-            break;
-        }
-        break;
-
-    case QD_ABORTED_BY_HOST:
-        ASC_DBG(1, "asc_isr_callback: QD_ABORTED_BY_HOST\n");
-        scp->result = HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.scsi_msg) |
-                STATUS_BYTE(qdonep->d3.scsi_stat);
-        break;
-
-    default:
-        ASC_DBG1(1, "asc_isr_callback: done_stat 0x%x\n", qdonep->d3.done_stat);
-        scp->result = HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.scsi_msg) |
-                STATUS_BYTE(qdonep->d3.scsi_stat);
-        break;
-    }
+	/*
+	 * If the 'init_tidmask' bit isn't already set for the target and the
+	 * current request finished normally, then set the bit for the target
+	 * to indicate that a device is present.
+	 */
+	if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
+	    qdonep->d3.done_stat == QD_NO_ERROR &&
+	    qdonep->d3.host_stat == QHSTA_NO_ERROR) {
+		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+	}
 
-    /*
-     * If the 'init_tidmask' bit isn't already set for the target and the
-     * current request finished normally, then set the bit for the target
-     * to indicate that a device is present.
-     */
-    if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
-        qdonep->d3.done_stat == QD_NO_ERROR &&
-        qdonep->d3.host_stat == QHSTA_NO_ERROR) {
-        boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
-    }
+	/*
+	 * Because interrupts may be enabled by the 'struct scsi_cmnd' done
+	 * function, add the command to the end of the board's done queue.
+	 * The done function for the command will be called from
+	 * advansys_interrupt().
+	 */
+	asc_enqueue(&boardp->done, scp, ASC_BACK);
 
-    /*
-     * Because interrupts may be enabled by the 'struct scsi_cmnd' done
-     * function, add the command to the end of the board's done queue.
-     * The done function for the command will be called from
-     * advansys_interrupt().
-     */
-    asc_enqueue(&boardp->done, scp, ASC_BACK);
-
-    return;
+	return;
 }
 
 /*
@@ -6885,238 +5704,240 @@ asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
  *
  * Callback function for the Wide SCSI Adv Library.
  */
-STATIC void
-adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
+static void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
 {
-    asc_board_t         *boardp;
-    adv_req_t           *reqp;
-    adv_sgblk_t         *sgblkp;
-    struct scsi_cmnd           *scp;
-    struct Scsi_Host    *shp;
-    int                 i;
-    ADV_DCNT            resid_cnt;
-
-
-    ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
-        (ulong) adv_dvc_varp, (ulong) scsiqp);
-    ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
-
-    /*
-     * Get the adv_req_t structure for the command that has been
-     * completed. The adv_req_t structure actually contains the
-     * completed ADV_SCSI_REQ_Q structure.
-     */
-    reqp = (adv_req_t *) ADV_U32_TO_VADDR(scsiqp->srb_ptr);
-    ASC_DBG1(1, "adv_isr_callback: reqp 0x%lx\n", (ulong) reqp);
-    if (reqp == NULL) {
-        ASC_PRINT("adv_isr_callback: reqp is NULL\n");
-        return;
-    }
-
-    /*
-     * Get the struct scsi_cmnd structure and Scsi_Host structure for the
-     * command that has been completed.
-     *
-     * Note: The adv_req_t request structure and adv_sgblk_t structure,
-     * if any, are dropped, because a board structure pointer can not be
-     * determined.
-     */
-    scp = reqp->cmndp;
-    ASC_DBG1(1, "adv_isr_callback: scp 0x%lx\n", (ulong) scp);
-    if (scp == NULL) {
-        ASC_PRINT("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");
-        return;
-    }
-    ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
-
-    /*
-     * If the request's host pointer is not valid, display a message
-     * and return.
-     */
-    shp = scp->device->host;
-    for (i = 0; i < asc_board_count; i++) {
-        if (asc_host[i] == shp) {
-            break;
-        }
-    }
-    /*
-     * Note: If the host structure is not found, the adv_req_t request
-     * structure and adv_sgblk_t structure, if any, is dropped.
-     */
-    if (i == asc_board_count) {
-        ASC_PRINT2(
-            "adv_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
-            (ulong) scp, (ulong) shp);
-        return;
-    }
+	asc_board_t *boardp;
+	adv_req_t *reqp;
+	adv_sgblk_t *sgblkp;
+	struct scsi_cmnd *scp;
+	struct Scsi_Host *shost;
+	int i;
+	ADV_DCNT resid_cnt;
+
+	ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
+		 (ulong)adv_dvc_varp, (ulong)scsiqp);
+	ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
+
+	/*
+	 * Get the adv_req_t structure for the command that has been
+	 * completed. The adv_req_t structure actually contains the
+	 * completed ADV_SCSI_REQ_Q structure.
+	 */
+	reqp = (adv_req_t *)ADV_U32_TO_VADDR(scsiqp->srb_ptr);
+	ASC_DBG1(1, "adv_isr_callback: reqp 0x%lx\n", (ulong)reqp);
+	if (reqp == NULL) {
+		ASC_PRINT("adv_isr_callback: reqp is NULL\n");
+		return;
+	}
 
-    ASC_STATS(shp, callback);
-    ASC_DBG1(1, "adv_isr_callback: shp 0x%lx\n", (ulong) shp);
+	/*
+	 * Get the struct scsi_cmnd structure and Scsi_Host structure for the
+	 * command that has been completed.
+	 *
+	 * Note: The adv_req_t request structure and adv_sgblk_t structure,
+	 * if any, are dropped, because a board structure pointer can not be
+	 * determined.
+	 */
+	scp = reqp->cmndp;
+	ASC_DBG1(1, "adv_isr_callback: scp 0x%lx\n", (ulong)scp);
+	if (scp == NULL) {
+		ASC_PRINT
+		    ("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");
+		return;
+	}
+	ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+
+	/*
+	 * If the request's host pointer is not valid, display a message
+	 * and return.
+	 */
+	shost = scp->device->host;
+	for (i = 0; i < asc_board_count; i++) {
+		if (asc_host[i] == shost) {
+			break;
+		}
+	}
+	/*
+	 * Note: If the host structure is not found, the adv_req_t request
+	 * structure and adv_sgblk_t structure, if any, is dropped.
+	 */
+	if (i == asc_board_count) {
+		ASC_PRINT2
+		    ("adv_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
+		     (ulong)scp, (ulong)shost);
+		return;
+	}
 
-    /*
-     * If the request isn't found on the active queue, it may have been
-     * removed to handle a reset request. Display a message and return.
-     *
-     * Note: Because the structure may still be in use don't attempt
-     * to free the adv_req_t and adv_sgblk_t, if any, structures.
-     */
-    boardp = ASC_BOARDP(shp);
-    ASC_ASSERT(adv_dvc_varp == &boardp->dvc_var.adv_dvc_var);
-    if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
-        ASC_PRINT2(
-            "adv_isr_callback: board %d: scp 0x%lx not on active queue\n",
-            boardp->id, (ulong) scp);
-        return;
-    }
+	ASC_STATS(shost, callback);
+	ASC_DBG1(1, "adv_isr_callback: shost 0x%lx\n", (ulong)shost);
+
+	/*
+	 * If the request isn't found on the active queue, it may have been
+	 * removed to handle a reset request. Display a message and return.
+	 *
+	 * Note: Because the structure may still be in use don't attempt
+	 * to free the adv_req_t and adv_sgblk_t, if any, structures.
+	 */
+	boardp = ASC_BOARDP(shost);
+	ASC_ASSERT(adv_dvc_varp == &boardp->dvc_var.adv_dvc_var);
+	if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
+		ASC_PRINT2
+		    ("adv_isr_callback: board %d: scp 0x%lx not on active queue\n",
+		     boardp->id, (ulong)scp);
+		return;
+	}
 
-    /*
-     * 'done_status' contains the command's ending status.
-     */
-    switch (scsiqp->done_status) {
-    case QD_NO_ERROR:
-        ASC_DBG(2, "adv_isr_callback: QD_NO_ERROR\n");
-        scp->result = 0;
-
-        /*
-         * Check for an underrun condition.
-         *
-         * If there was no error and an underrun condition, then
-         * then return the number of underrun bytes.
-         */
-        resid_cnt = le32_to_cpu(scsiqp->data_cnt);
-        if (scp->request_bufflen != 0 && resid_cnt != 0 &&
-            resid_cnt <= scp->request_bufflen) {
-            ASC_DBG1(1, "adv_isr_callback: underrun condition %lu bytes\n",
-                (ulong) resid_cnt);
-            scp->resid = resid_cnt;
-        }
-        break;
-
-    case QD_WITH_ERROR:
-        ASC_DBG(2, "adv_isr_callback: QD_WITH_ERROR\n");
-        switch (scsiqp->host_status) {
-        case QHSTA_NO_ERROR:
-            if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
-                ASC_DBG(2, "adv_isr_callback: SAM_STAT_CHECK_CONDITION\n");
-                ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
-                    sizeof(scp->sense_buffer));
-                /*
-                 * Note: The 'status_byte()' macro used by target drivers
-                 * defined in scsi.h shifts the status byte returned by
-                 * host drivers right by 1 bit. This is why target drivers
-                 * also use right shifted status byte definitions. For
-                 * instance target drivers use CHECK_CONDITION, defined to
-                 * 0x1, instead of the SCSI defined check condition value
-                 * of 0x2. Host drivers are supposed to return the status
-                 * byte as it is defined by SCSI.
-                 */
-                scp->result = DRIVER_BYTE(DRIVER_SENSE) |
-                    STATUS_BYTE(scsiqp->scsi_status);
-            } else {
-                scp->result = STATUS_BYTE(scsiqp->scsi_status);
-            }
-            break;
-
-        default:
-            /* Some other QHSTA error occurred. */
-            ASC_DBG1(1, "adv_isr_callback: host_status 0x%x\n",
-                scsiqp->host_status);
-            scp->result = HOST_BYTE(DID_BAD_TARGET);
-            break;
-        }
-        break;
-
-    case QD_ABORTED_BY_HOST:
-        ASC_DBG(1, "adv_isr_callback: QD_ABORTED_BY_HOST\n");
-        scp->result = HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);
-        break;
-
-    default:
-        ASC_DBG1(1, "adv_isr_callback: done_status 0x%x\n", scsiqp->done_status);
-        scp->result = HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);
-        break;
-    }
+	/*
+	 * 'done_status' contains the command's ending status.
+	 */
+	switch (scsiqp->done_status) {
+	case QD_NO_ERROR:
+		ASC_DBG(2, "adv_isr_callback: QD_NO_ERROR\n");
+		scp->result = 0;
 
-    /*
-     * If the 'init_tidmask' bit isn't already set for the target and the
-     * current request finished normally, then set the bit for the target
-     * to indicate that a device is present.
-     */
-    if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
-        scsiqp->done_status == QD_NO_ERROR &&
-        scsiqp->host_status == QHSTA_NO_ERROR) {
-        boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
-    }
+		/*
+		 * Check for an underrun condition.
+		 *
+		 * If there was no error and an underrun condition, then
+		 * then return the number of underrun bytes.
+		 */
+		resid_cnt = le32_to_cpu(scsiqp->data_cnt);
+		if (scp->request_bufflen != 0 && resid_cnt != 0 &&
+		    resid_cnt <= scp->request_bufflen) {
+			ASC_DBG1(1,
+				 "adv_isr_callback: underrun condition %lu bytes\n",
+				 (ulong)resid_cnt);
+			scp->resid = resid_cnt;
+		}
+		break;
+
+	case QD_WITH_ERROR:
+		ASC_DBG(2, "adv_isr_callback: QD_WITH_ERROR\n");
+		switch (scsiqp->host_status) {
+		case QHSTA_NO_ERROR:
+			if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
+				ASC_DBG(2,
+					"adv_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+				ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
+						  sizeof(scp->sense_buffer));
+				/*
+				 * Note: The 'status_byte()' macro used by target drivers
+				 * defined in scsi.h shifts the status byte returned by
+				 * host drivers right by 1 bit. This is why target drivers
+				 * also use right shifted status byte definitions. For
+				 * instance target drivers use CHECK_CONDITION, defined to
+				 * 0x1, instead of the SCSI defined check condition value
+				 * of 0x2. Host drivers are supposed to return the status
+				 * byte as it is defined by SCSI.
+				 */
+				scp->result = DRIVER_BYTE(DRIVER_SENSE) |
+				    STATUS_BYTE(scsiqp->scsi_status);
+			} else {
+				scp->result = STATUS_BYTE(scsiqp->scsi_status);
+			}
+			break;
+
+		default:
+			/* Some other QHSTA error occurred. */
+			ASC_DBG1(1, "adv_isr_callback: host_status 0x%x\n",
+				 scsiqp->host_status);
+			scp->result = HOST_BYTE(DID_BAD_TARGET);
+			break;
+		}
+		break;
+
+	case QD_ABORTED_BY_HOST:
+		ASC_DBG(1, "adv_isr_callback: QD_ABORTED_BY_HOST\n");
+		scp->result =
+		    HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);
+		break;
+
+	default:
+		ASC_DBG1(1, "adv_isr_callback: done_status 0x%x\n",
+			 scsiqp->done_status);
+		scp->result =
+		    HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);
+		break;
+	}
 
-    /*
-     * Because interrupts may be enabled by the 'struct scsi_cmnd' done
-     * function, add the command to the end of the board's done queue.
-     * The done function for the command will be called from
-     * advansys_interrupt().
-     */
-    asc_enqueue(&boardp->done, scp, ASC_BACK);
+	/*
+	 * If the 'init_tidmask' bit isn't already set for the target and the
+	 * current request finished normally, then set the bit for the target
+	 * to indicate that a device is present.
+	 */
+	if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
+	    scsiqp->done_status == QD_NO_ERROR &&
+	    scsiqp->host_status == QHSTA_NO_ERROR) {
+		boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+	}
 
-    /*
-     * Free all 'adv_sgblk_t' structures allocated for the request.
-     */
-    while ((sgblkp = reqp->sgblkp) != NULL)
-    {
-        /* Remove 'sgblkp' from the request list. */
-        reqp->sgblkp = sgblkp->next_sgblkp;
-
-        /* Add 'sgblkp' to the board free list. */
-        sgblkp->next_sgblkp = boardp->adv_sgblkp;
-        boardp->adv_sgblkp = sgblkp;
-    }
+	/*
+	 * Because interrupts may be enabled by the 'struct scsi_cmnd' done
+	 * function, add the command to the end of the board's done queue.
+	 * The done function for the command will be called from
+	 * advansys_interrupt().
+	 */
+	asc_enqueue(&boardp->done, scp, ASC_BACK);
+
+	/*
+	 * Free all 'adv_sgblk_t' structures allocated for the request.
+	 */
+	while ((sgblkp = reqp->sgblkp) != NULL) {
+		/* Remove 'sgblkp' from the request list. */
+		reqp->sgblkp = sgblkp->next_sgblkp;
+
+		/* Add 'sgblkp' to the board free list. */
+		sgblkp->next_sgblkp = boardp->adv_sgblkp;
+		boardp->adv_sgblkp = sgblkp;
+	}
 
-    /*
-     * Free the adv_req_t structure used with the command by adding
-     * it back to the board free list.
-     */
-    reqp->next_reqp = boardp->adv_reqp;
-    boardp->adv_reqp = reqp;
+	/*
+	 * Free the adv_req_t structure used with the command by adding
+	 * it back to the board free list.
+	 */
+	reqp->next_reqp = boardp->adv_reqp;
+	boardp->adv_reqp = reqp;
 
-    ASC_DBG(1, "adv_isr_callback: done\n");
+	ASC_DBG(1, "adv_isr_callback: done\n");
 
-    return;
+	return;
 }
 
 /*
  * adv_async_callback() - Adv Library asynchronous event callback function.
  */
-STATIC void
-adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
+static void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
 {
-    switch (code)
-    {
-    case ADV_ASYNC_SCSI_BUS_RESET_DET:
-        /*
-         * The firmware detected a SCSI Bus reset.
-         */
-        ASC_DBG(0, "adv_async_callback: ADV_ASYNC_SCSI_BUS_RESET_DET\n");
-        break;
-
-    case ADV_ASYNC_RDMA_FAILURE:
-        /*
-         * Handle RDMA failure by resetting the SCSI Bus and
-         * possibly the chip if it is unresponsive. Log the error
-         * with a unique code.
-         */
-        ASC_DBG(0, "adv_async_callback: ADV_ASYNC_RDMA_FAILURE\n");
-        AdvResetChipAndSB(adv_dvc_varp);
-        break;
-
-    case ADV_HOST_SCSI_BUS_RESET:
-        /*
-         * Host generated SCSI bus reset occurred.
-         */
-        ASC_DBG(0, "adv_async_callback: ADV_HOST_SCSI_BUS_RESET\n");
-        break;
-
-    default:
-        ASC_DBG1(0, "DvcAsyncCallBack: unknown code 0x%x\n", code);
-        break;
-    }
+	switch (code) {
+	case ADV_ASYNC_SCSI_BUS_RESET_DET:
+		/*
+		 * The firmware detected a SCSI Bus reset.
+		 */
+		ASC_DBG(0,
+			"adv_async_callback: ADV_ASYNC_SCSI_BUS_RESET_DET\n");
+		break;
+
+	case ADV_ASYNC_RDMA_FAILURE:
+		/*
+		 * Handle RDMA failure by resetting the SCSI Bus and
+		 * possibly the chip if it is unresponsive. Log the error
+		 * with a unique code.
+		 */
+		ASC_DBG(0, "adv_async_callback: ADV_ASYNC_RDMA_FAILURE\n");
+		AdvResetChipAndSB(adv_dvc_varp);
+		break;
+
+	case ADV_HOST_SCSI_BUS_RESET:
+		/*
+		 * Host generated SCSI bus reset occurred.
+		 */
+		ASC_DBG(0, "adv_async_callback: ADV_HOST_SCSI_BUS_RESET\n");
+		break;
+
+	default:
+		ASC_DBG1(0, "DvcAsyncCallBack: unknown code 0x%x\n", code);
+		break;
+	}
 }
 
 /*
@@ -7127,50 +5948,50 @@ adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
  *
  * 'REQPNEXT(reqp)' returns reqp's next pointer.
  */
-STATIC void
-asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
+static void asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
 {
-    int        tid;
-
-    ASC_DBG3(3, "asc_enqueue: ascq 0x%lx, reqp 0x%lx, flag %d\n",
-        (ulong) ascq, (ulong) reqp, flag);
-    ASC_ASSERT(reqp != NULL);
-    ASC_ASSERT(flag == ASC_FRONT || flag == ASC_BACK);
-    tid = REQPTID(reqp);
-    ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
-    if (flag == ASC_FRONT) {
-        reqp->host_scribble = (unsigned char *)ascq->q_first[tid];
-        ascq->q_first[tid] = reqp;
-        /* If the queue was empty, set the last pointer. */
-        if (ascq->q_last[tid] == NULL) {
-            ascq->q_last[tid] = reqp;
-        }
-    } else { /* ASC_BACK */
-        if (ascq->q_last[tid] != NULL) {
-            ascq->q_last[tid]->host_scribble = (unsigned char *)reqp;
-        }
-        ascq->q_last[tid] = reqp;
-        reqp->host_scribble = NULL;
-        /* If the queue was empty, set the first pointer. */
-        if (ascq->q_first[tid] == NULL) {
-            ascq->q_first[tid] = reqp;
-        }
-    }
-    /* The queue has at least one entry, set its bit. */
-    ascq->q_tidmask |= ADV_TID_TO_TIDMASK(tid);
+	int tid;
+
+	ASC_DBG3(3, "asc_enqueue: ascq 0x%lx, reqp 0x%lx, flag %d\n",
+		 (ulong)ascq, (ulong)reqp, flag);
+	ASC_ASSERT(reqp != NULL);
+	ASC_ASSERT(flag == ASC_FRONT || flag == ASC_BACK);
+	tid = REQPTID(reqp);
+	ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
+	if (flag == ASC_FRONT) {
+		reqp->host_scribble = (unsigned char *)ascq->q_first[tid];
+		ascq->q_first[tid] = reqp;
+		/* If the queue was empty, set the last pointer. */
+		if (ascq->q_last[tid] == NULL) {
+			ascq->q_last[tid] = reqp;
+		}
+	} else {		/* ASC_BACK */
+		if (ascq->q_last[tid] != NULL) {
+			ascq->q_last[tid]->host_scribble =
+			    (unsigned char *)reqp;
+		}
+		ascq->q_last[tid] = reqp;
+		reqp->host_scribble = NULL;
+		/* If the queue was empty, set the first pointer. */
+		if (ascq->q_first[tid] == NULL) {
+			ascq->q_first[tid] = reqp;
+		}
+	}
+	/* The queue has at least one entry, set its bit. */
+	ascq->q_tidmask |= ADV_TID_TO_TIDMASK(tid);
 #ifdef ADVANSYS_STATS
-    /* Maintain request queue statistics. */
-    ascq->q_tot_cnt[tid]++;
-    ascq->q_cur_cnt[tid]++;
-    if (ascq->q_cur_cnt[tid] > ascq->q_max_cnt[tid]) {
-        ascq->q_max_cnt[tid] = ascq->q_cur_cnt[tid];
-        ASC_DBG2(2, "asc_enqueue: new q_max_cnt[%d] %d\n",
-            tid, ascq->q_max_cnt[tid]);
-    }
-    REQPTIME(reqp) = REQTIMESTAMP();
+	/* Maintain request queue statistics. */
+	ascq->q_tot_cnt[tid]++;
+	ascq->q_cur_cnt[tid]++;
+	if (ascq->q_cur_cnt[tid] > ascq->q_max_cnt[tid]) {
+		ascq->q_max_cnt[tid] = ascq->q_cur_cnt[tid];
+		ASC_DBG2(2, "asc_enqueue: new q_max_cnt[%d] %d\n",
+			 tid, ascq->q_max_cnt[tid]);
+	}
+	REQPTIME(reqp) = REQTIMESTAMP();
 #endif /* ADVANSYS_STATS */
-    ASC_DBG1(3, "asc_enqueue: reqp 0x%lx\n", (ulong) reqp);
-    return;
+	ASC_DBG1(3, "asc_enqueue: reqp 0x%lx\n", (ulong)reqp);
+	return;
 }
 
 /*
@@ -7180,31 +6001,30 @@ asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
  *
  * 'REQPNEXT(reqp)' returns reqp's next pointer.
  */
-STATIC REQP
-asc_dequeue(asc_queue_t *ascq, int tid)
+static REQP asc_dequeue(asc_queue_t *ascq, int tid)
 {
-    REQP    reqp;
-
-    ASC_DBG2(3, "asc_dequeue: ascq 0x%lx, tid %d\n", (ulong) ascq, tid);
-    ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
-    if ((reqp = ascq->q_first[tid]) != NULL) {
-        ASC_ASSERT(ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid));
-        ascq->q_first[tid] = REQPNEXT(reqp);
-        /* If the queue is empty, clear its bit and the last pointer. */
-        if (ascq->q_first[tid] == NULL) {
-            ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
-            ASC_ASSERT(ascq->q_last[tid] == reqp);
-            ascq->q_last[tid] = NULL;
-        }
+	REQP reqp;
+
+	ASC_DBG2(3, "asc_dequeue: ascq 0x%lx, tid %d\n", (ulong)ascq, tid);
+	ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
+	if ((reqp = ascq->q_first[tid]) != NULL) {
+		ASC_ASSERT(ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid));
+		ascq->q_first[tid] = REQPNEXT(reqp);
+		/* If the queue is empty, clear its bit and the last pointer. */
+		if (ascq->q_first[tid] == NULL) {
+			ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
+			ASC_ASSERT(ascq->q_last[tid] == reqp);
+			ascq->q_last[tid] = NULL;
+		}
 #ifdef ADVANSYS_STATS
-        /* Maintain request queue statistics. */
-        ascq->q_cur_cnt[tid]--;
-        ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
-        REQTIMESTAT("asc_dequeue", ascq, reqp, tid);
+		/* Maintain request queue statistics. */
+		ascq->q_cur_cnt[tid]--;
+		ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
+		REQTIMESTAT("asc_dequeue", ascq, reqp, tid);
 #endif /* ADVANSYS_STATS */
-    }
-    ASC_DBG1(3, "asc_dequeue: reqp 0x%lx\n", (ulong) reqp);
-    return reqp;
+	}
+	ASC_DBG1(3, "asc_dequeue: reqp 0x%lx\n", (ulong)reqp);
+	return reqp;
 }
 
 /*
@@ -7227,74 +6047,76 @@ asc_dequeue(asc_queue_t *ascq, int tid)
  * Unfortunately collecting queuing time statistics adds overhead to
  * the function that isn't inherent to the function's algorithm.
  */
-STATIC REQP
-asc_dequeue_list(asc_queue_t *ascq, REQP *lastpp, int tid)
+static REQP asc_dequeue_list(asc_queue_t *ascq, REQP *lastpp, int tid)
 {
-    REQP    firstp, lastp;
-    int     i;
-
-    ASC_DBG2(3, "asc_dequeue_list: ascq 0x%lx, tid %d\n", (ulong) ascq, tid);
-    ASC_ASSERT((tid == ASC_TID_ALL) || (tid >= 0 && tid <= ADV_MAX_TID));
-
-    /*
-     * If 'tid' is not ASC_TID_ALL, return requests only for
-     * the specified 'tid'. If 'tid' is ASC_TID_ALL, return all
-     * requests for all tids.
-     */
-    if (tid != ASC_TID_ALL) {
-        /* Return all requests for the specified 'tid'. */
-        if ((ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid)) == 0) {
-            /* List is empty; Set first and last return pointers to NULL. */
-            firstp = lastp = NULL;
-        } else {
-            firstp = ascq->q_first[tid];
-            lastp = ascq->q_last[tid];
-            ascq->q_first[tid] = ascq->q_last[tid] = NULL;
-            ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
+	REQP firstp, lastp;
+	int i;
+
+	ASC_DBG2(3, "asc_dequeue_list: ascq 0x%lx, tid %d\n", (ulong)ascq, tid);
+	ASC_ASSERT((tid == ASC_TID_ALL) || (tid >= 0 && tid <= ADV_MAX_TID));
+
+	/*
+	 * If 'tid' is not ASC_TID_ALL, return requests only for
+	 * the specified 'tid'. If 'tid' is ASC_TID_ALL, return all
+	 * requests for all tids.
+	 */
+	if (tid != ASC_TID_ALL) {
+		/* Return all requests for the specified 'tid'. */
+		if ((ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid)) == 0) {
+			/* List is empty; Set first and last return pointers to NULL. */
+			firstp = lastp = NULL;
+		} else {
+			firstp = ascq->q_first[tid];
+			lastp = ascq->q_last[tid];
+			ascq->q_first[tid] = ascq->q_last[tid] = NULL;
+			ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
 #ifdef ADVANSYS_STATS
-            {
-                REQP reqp;
-                ascq->q_cur_cnt[tid] = 0;
-                for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
-                    REQTIMESTAT("asc_dequeue_list", ascq, reqp, tid);
-                }
-            }
+			{
+				REQP reqp;
+				ascq->q_cur_cnt[tid] = 0;
+				for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
+					REQTIMESTAT("asc_dequeue_list", ascq,
+						    reqp, tid);
+				}
+			}
 #endif /* ADVANSYS_STATS */
-        }
-    } else {
-        /* Return all requests for all tids. */
-        firstp = lastp = NULL;
-        for (i = 0; i <= ADV_MAX_TID; i++) {
-            if (ascq->q_tidmask & ADV_TID_TO_TIDMASK(i)) {
-                if (firstp == NULL) {
-                    firstp = ascq->q_first[i];
-                    lastp = ascq->q_last[i];
-                } else {
-                    ASC_ASSERT(lastp != NULL);
-                    lastp->host_scribble = (unsigned char *)ascq->q_first[i];
-                    lastp = ascq->q_last[i];
-                }
-                ascq->q_first[i] = ascq->q_last[i] = NULL;
-                ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(i);
+		}
+	} else {
+		/* Return all requests for all tids. */
+		firstp = lastp = NULL;
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			if (ascq->q_tidmask & ADV_TID_TO_TIDMASK(i)) {
+				if (firstp == NULL) {
+					firstp = ascq->q_first[i];
+					lastp = ascq->q_last[i];
+				} else {
+					ASC_ASSERT(lastp != NULL);
+					lastp->host_scribble =
+					    (unsigned char *)ascq->q_first[i];
+					lastp = ascq->q_last[i];
+				}
+				ascq->q_first[i] = ascq->q_last[i] = NULL;
+				ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(i);
 #ifdef ADVANSYS_STATS
-                ascq->q_cur_cnt[i] = 0;
+				ascq->q_cur_cnt[i] = 0;
 #endif /* ADVANSYS_STATS */
-            }
-        }
+			}
+		}
 #ifdef ADVANSYS_STATS
-        {
-            REQP reqp;
-            for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
-                REQTIMESTAT("asc_dequeue_list", ascq, reqp, reqp->device->id);
-            }
-        }
+		{
+			REQP reqp;
+			for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
+				REQTIMESTAT("asc_dequeue_list", ascq, reqp,
+					    reqp->device->id);
+			}
+		}
 #endif /* ADVANSYS_STATS */
-    }
-    if (lastpp) {
-        *lastpp = lastp;
-    }
-    ASC_DBG1(3, "asc_dequeue_list: firstp 0x%lx\n", (ulong) firstp);
-    return firstp;
+	}
+	if (lastpp) {
+		*lastpp = lastp;
+	}
+	ASC_DBG1(3, "asc_dequeue_list: firstp 0x%lx\n", (ulong)firstp);
+	return firstp;
 }
 
 /*
@@ -7307,67 +6129,67 @@ asc_dequeue_list(asc_queue_t *ascq, REQP *lastpp, int tid)
  * Return ASC_TRUE if the command was found and removed,
  * otherwise return ASC_FALSE.
  */
-STATIC int
-asc_rmqueue(asc_queue_t *ascq, REQP reqp)
+static int asc_rmqueue(asc_queue_t *ascq, REQP reqp)
 {
-    REQP        currp, prevp;
-    int         tid;
-    int         ret = ASC_FALSE;
-
-    ASC_DBG2(3, "asc_rmqueue: ascq 0x%lx, reqp 0x%lx\n",
-        (ulong) ascq, (ulong) reqp);
-    ASC_ASSERT(reqp != NULL);
-
-    tid = REQPTID(reqp);
-    ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
-
-    /*
-     * Handle the common case of 'reqp' being the first
-     * entry on the queue.
-     */
-    if (reqp == ascq->q_first[tid]) {
-        ret = ASC_TRUE;
-        ascq->q_first[tid] = REQPNEXT(reqp);
-        /* If the queue is now empty, clear its bit and the last pointer. */
-        if (ascq->q_first[tid] == NULL) {
-            ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
-            ASC_ASSERT(ascq->q_last[tid] == reqp);
-            ascq->q_last[tid] = NULL;
-        }
-    } else if (ascq->q_first[tid] != NULL) {
-        ASC_ASSERT(ascq->q_last[tid] != NULL);
-        /*
-         * Because the case of 'reqp' being the first entry has been
-         * handled above and it is known the queue is not empty, if
-         * 'reqp' is found on the queue it is guaranteed the queue will
-         * not become empty and that 'q_first[tid]' will not be changed.
-         *
-         * Set 'prevp' to the first entry, 'currp' to the second entry,
-         * and search for 'reqp'.
-         */
-        for (prevp = ascq->q_first[tid], currp = REQPNEXT(prevp);
-             currp; prevp = currp, currp = REQPNEXT(currp)) {
-            if (currp == reqp) {
-                ret = ASC_TRUE;
-                prevp->host_scribble = (unsigned char *)REQPNEXT(currp);
-                reqp->host_scribble = NULL;
-                if (ascq->q_last[tid] == reqp) {
-                    ascq->q_last[tid] = prevp;
-                }
-                break;
-            }
-        }
-    }
+	REQP currp, prevp;
+	int tid;
+	int ret = ASC_FALSE;
+
+	ASC_DBG2(3, "asc_rmqueue: ascq 0x%lx, reqp 0x%lx\n",
+		 (ulong)ascq, (ulong)reqp);
+	ASC_ASSERT(reqp != NULL);
+
+	tid = REQPTID(reqp);
+	ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
+
+	/*
+	 * Handle the common case of 'reqp' being the first
+	 * entry on the queue.
+	 */
+	if (reqp == ascq->q_first[tid]) {
+		ret = ASC_TRUE;
+		ascq->q_first[tid] = REQPNEXT(reqp);
+		/* If the queue is now empty, clear its bit and the last pointer. */
+		if (ascq->q_first[tid] == NULL) {
+			ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
+			ASC_ASSERT(ascq->q_last[tid] == reqp);
+			ascq->q_last[tid] = NULL;
+		}
+	} else if (ascq->q_first[tid] != NULL) {
+		ASC_ASSERT(ascq->q_last[tid] != NULL);
+		/*
+		 * Because the case of 'reqp' being the first entry has been
+		 * handled above and it is known the queue is not empty, if
+		 * 'reqp' is found on the queue it is guaranteed the queue will
+		 * not become empty and that 'q_first[tid]' will not be changed.
+		 *
+		 * Set 'prevp' to the first entry, 'currp' to the second entry,
+		 * and search for 'reqp'.
+		 */
+		for (prevp = ascq->q_first[tid], currp = REQPNEXT(prevp);
+		     currp; prevp = currp, currp = REQPNEXT(currp)) {
+			if (currp == reqp) {
+				ret = ASC_TRUE;
+				prevp->host_scribble =
+				    (unsigned char *)REQPNEXT(currp);
+				reqp->host_scribble = NULL;
+				if (ascq->q_last[tid] == reqp) {
+					ascq->q_last[tid] = prevp;
+				}
+				break;
+			}
+		}
+	}
 #ifdef ADVANSYS_STATS
-    /* Maintain request queue statistics. */
-    if (ret == ASC_TRUE) {
-        ascq->q_cur_cnt[tid]--;
-        REQTIMESTAT("asc_rmqueue", ascq, reqp, tid);
-    }
-    ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
+	/* Maintain request queue statistics. */
+	if (ret == ASC_TRUE) {
+		ascq->q_cur_cnt[tid]--;
+		REQTIMESTAT("asc_rmqueue", ascq, reqp, tid);
+	}
+	ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
 #endif /* ADVANSYS_STATS */
-    ASC_DBG2(3, "asc_rmqueue: reqp 0x%lx, ret %d\n", (ulong) reqp, ret);
-    return ret;
+	ASC_DBG2(3, "asc_rmqueue: reqp 0x%lx, ret %d\n", (ulong)reqp, ret);
+	return ret;
 }
 
 /*
@@ -7375,37 +6197,38 @@ asc_rmqueue(asc_queue_t *ascq, REQP reqp)
  *
  * Calls asc_execute_scsi_cmnd() to execute a REQP/struct scsi_cmnd.
  */
-STATIC void
-asc_execute_queue(asc_queue_t *ascq)
+static void asc_execute_queue(asc_queue_t *ascq)
 {
-    ADV_SCSI_BIT_ID_TYPE    scan_tidmask;
-    REQP                    reqp;
-    int                     i;
-
-    ASC_DBG1(1, "asc_execute_queue: ascq 0x%lx\n", (ulong) ascq);
-    /*
-     * Execute queued commands for devices attached to
-     * the current board in round-robin fashion.
-     */
-    scan_tidmask = ascq->q_tidmask;
-    do {
-        for (i = 0; i <= ADV_MAX_TID; i++) {
-            if (scan_tidmask & ADV_TID_TO_TIDMASK(i)) {
-                if ((reqp = asc_dequeue(ascq, i)) == NULL) {
-                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
-                } else if (asc_execute_scsi_cmnd((struct scsi_cmnd *) reqp)
-                            == ASC_BUSY) {
-                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
-                    /*
-                     * The request returned ASC_BUSY. Enqueue at the front of
-                     * target's waiting list to maintain correct ordering.
-                     */
-                    asc_enqueue(ascq, reqp, ASC_FRONT);
-                }
-            }
-        }
-    } while (scan_tidmask);
-    return;
+	ADV_SCSI_BIT_ID_TYPE scan_tidmask;
+	REQP reqp;
+	int i;
+
+	ASC_DBG1(1, "asc_execute_queue: ascq 0x%lx\n", (ulong)ascq);
+	/*
+	 * Execute queued commands for devices attached to
+	 * the current board in round-robin fashion.
+	 */
+	scan_tidmask = ascq->q_tidmask;
+	do {
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			if (scan_tidmask & ADV_TID_TO_TIDMASK(i)) {
+				if ((reqp = asc_dequeue(ascq, i)) == NULL) {
+					scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
+				} else
+				    if (asc_execute_scsi_cmnd
+					((struct scsi_cmnd *)reqp)
+					== ASC_BUSY) {
+					scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
+					/*
+					 * The request returned ASC_BUSY. Enqueue at the front of
+					 * target's waiting list to maintain correct ordering.
+					 */
+					asc_enqueue(ascq, reqp, ASC_FRONT);
+				}
+			}
+		}
+	} while (scan_tidmask);
+	return;
 }
 
 #ifdef CONFIG_PROC_FS
@@ -7420,102 +6243,102 @@ asc_execute_queue(asc_queue_t *ascq)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_board_devices(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_board_devices(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t        *boardp;
-    int                leftlen;
-    int                totlen;
-    int                len;
-    int                chip_scsi_id;
-    int                i;
-
-    boardp = ASC_BOARDP(shp);
-    leftlen = cplen;
-    totlen = len = 0;
-
-    len = asc_prt_line(cp, leftlen,
-"\nDevice Information for AdvanSys SCSI Host %d:\n", shp->host_no);
-    ASC_PRT_NEXT();
-
-    if (ASC_NARROW_BOARD(boardp)) {
-        chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
-    } else {
-        chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
-    }
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	int chip_scsi_id;
+	int i;
+
+	boardp = ASC_BOARDP(shost);
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen,
+			   "\nDevice Information for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+	} else {
+		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+	}
 
-    len = asc_prt_line(cp, leftlen, "Target IDs Detected:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) {
-            len = asc_prt_line(cp, leftlen, " %X,", i);
-            ASC_PRT_NEXT();
-        }
-    }
-    len = asc_prt_line(cp, leftlen, " (%X=Host Adapter)\n", chip_scsi_id);
-    ASC_PRT_NEXT();
+	len = asc_prt_line(cp, leftlen, "Target IDs Detected:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) {
+			len = asc_prt_line(cp, leftlen, " %X,", i);
+			ASC_PRT_NEXT();
+		}
+	}
+	len = asc_prt_line(cp, leftlen, " (%X=Host Adapter)\n", chip_scsi_id);
+	ASC_PRT_NEXT();
 
-    return totlen;
+	return totlen;
 }
 
 /*
  * Display Wide Board BIOS Information.
  */
-STATIC int
-asc_prt_adv_bios(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_adv_bios(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t        *boardp;
-    int                leftlen;
-    int                totlen;
-    int                len;
-    ushort             major, minor, letter;
-
-    boardp = ASC_BOARDP(shp);
-    leftlen = cplen;
-    totlen = len = 0;
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	ushort major, minor, letter;
+
+	boardp = ASC_BOARDP(shost);
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen, "\nROM BIOS Version: ");
+	ASC_PRT_NEXT();
+
+	/*
+	 * If the BIOS saved a valid signature, then fill in
+	 * the BIOS code segment base address.
+	 */
+	if (boardp->bios_signature != 0x55AA) {
+		len = asc_prt_line(cp, leftlen, "Disabled or Pre-3.1\n");
+		ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen,
+				   "BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
+		ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen,
+				   "can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
+		ASC_PRT_NEXT();
+	} else {
+		major = (boardp->bios_version >> 12) & 0xF;
+		minor = (boardp->bios_version >> 8) & 0xF;
+		letter = (boardp->bios_version & 0xFF);
 
-    len = asc_prt_line(cp, leftlen, "\nROM BIOS Version: ");
-    ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen, "%d.%d%c\n",
+				   major, minor,
+				   letter >= 26 ? '?' : letter + 'A');
+		ASC_PRT_NEXT();
 
-    /*
-     * If the BIOS saved a valid signature, then fill in
-     * the BIOS code segment base address.
-     */
-    if (boardp->bios_signature != 0x55AA) {
-        len = asc_prt_line(cp, leftlen, "Disabled or Pre-3.1\n");
-        ASC_PRT_NEXT();
-        len = asc_prt_line(cp, leftlen,
-"BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
-        ASC_PRT_NEXT();
-        len = asc_prt_line(cp, leftlen,
-"can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
-        ASC_PRT_NEXT();
-    } else {
-        major = (boardp->bios_version >> 12) & 0xF;
-        minor = (boardp->bios_version >> 8) & 0xF;
-        letter = (boardp->bios_version & 0xFF);
-
-        len = asc_prt_line(cp, leftlen, "%d.%d%c\n",
-            major, minor, letter >= 26 ? '?' : letter + 'A');
-        ASC_PRT_NEXT();
-
-        /*
-         * Current available ROM BIOS release is 3.1I for UW
-         * and 3.2I for U2W. This code doesn't differentiate
-         * UW and U2W boards.
-         */
-        if (major < 3 || (major <= 3 && minor < 1) ||
-            (major <= 3 && minor <= 1 && letter < ('I'- 'A'))) {
-            len = asc_prt_line(cp, leftlen,
-"Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
-            ASC_PRT_NEXT();
-            len = asc_prt_line(cp, leftlen,
-"ftp://ftp.connectcom.net/pub\n");
-            ASC_PRT_NEXT();
-        }
-    }
+		/*
+		 * Current available ROM BIOS release is 3.1I for UW
+		 * and 3.2I for U2W. This code doesn't differentiate
+		 * UW and U2W boards.
+		 */
+		if (major < 3 || (major <= 3 && minor < 1) ||
+		    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {
+			len = asc_prt_line(cp, leftlen,
+					   "Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
+			ASC_PRT_NEXT();
+			len = asc_prt_line(cp, leftlen,
+					   "ftp://ftp.connectcom.net/pub\n");
+			ASC_PRT_NEXT();
+		}
+	}
 
-    return totlen;
+	return totlen;
 }
 
 /*
@@ -7541,80 +6364,79 @@ asc_prt_adv_bios(struct Scsi_Host *shp, char *cp, int cplen)
  *
  * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.
  */
-STATIC int
-asc_get_eeprom_string(ushort *serialnum, uchar *cp)
+static int asc_get_eeprom_string(ushort *serialnum, uchar *cp)
 {
-    ushort      w, num;
-
-    if ((serialnum[1] & 0xFE00) != ((ushort) 0xAA << 8)) {
-        return ASC_FALSE;
-    } else {
-        /*
-         * First word - 6 digits.
-         */
-        w = serialnum[0];
-
-        /* Product type - 1st digit. */
-        if ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {
-            /* Product type is P=Prototype */
-            *cp += 0x8;
-        }
-        cp++;
-
-        /* Manufacturing location - 2nd digit. */
-        *cp++ = 'A' + ((w & 0x1C00) >> 10);
-
-        /* Product ID - 3rd, 4th digits. */
-        num = w & 0x3FF;
-        *cp++ = '0' + (num / 100);
-        num %= 100;
-        *cp++ = '0' + (num / 10);
-
-        /* Product revision - 5th digit. */
-        *cp++ = 'A' + (num % 10);
-
-        /*
-         * Second word
-         */
-        w = serialnum[1];
-
-        /*
-         * Year - 6th digit.
-         *
-         * If bit 15 of third word is set, then the
-         * last digit of the year is greater than 7.
-         */
-        if (serialnum[2] & 0x8000) {
-            *cp++ = '8' + ((w & 0x1C0) >> 6);
-        } else {
-            *cp++ = '0' + ((w & 0x1C0) >> 6);
-        }
-
-        /* Week of year - 7th, 8th digits. */
-        num = w & 0x003F;
-        *cp++ = '0' + num / 10;
-        num %= 10;
-        *cp++ = '0' + num;
-
-        /*
-         * Third word
-         */
-        w = serialnum[2] & 0x7FFF;
-
-        /* Serial number - 9th digit. */
-        *cp++ = 'A' + (w / 1000);
-
-        /* 10th, 11th, 12th digits. */
-        num = w % 1000;
-        *cp++ = '0' + num / 100;
-        num %= 100;
-        *cp++ = '0' + num / 10;
-        num %= 10;
-        *cp++ = '0' + num;
-
-        *cp = '\0';     /* Null Terminate the string. */
-        return ASC_TRUE;
-    }
+	ushort w, num;
+
+	if ((serialnum[1] & 0xFE00) != ((ushort)0xAA << 8)) {
+		return ASC_FALSE;
+	} else {
+		/*
+		 * First word - 6 digits.
+		 */
+		w = serialnum[0];
+
+		/* Product type - 1st digit. */
+		if ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {
+			/* Product type is P=Prototype */
+			*cp += 0x8;
+		}
+		cp++;
+
+		/* Manufacturing location - 2nd digit. */
+		*cp++ = 'A' + ((w & 0x1C00) >> 10);
+
+		/* Product ID - 3rd, 4th digits. */
+		num = w & 0x3FF;
+		*cp++ = '0' + (num / 100);
+		num %= 100;
+		*cp++ = '0' + (num / 10);
+
+		/* Product revision - 5th digit. */
+		*cp++ = 'A' + (num % 10);
+
+		/*
+		 * Second word
+		 */
+		w = serialnum[1];
+
+		/*
+		 * Year - 6th digit.
+		 *
+		 * If bit 15 of third word is set, then the
+		 * last digit of the year is greater than 7.
+		 */
+		if (serialnum[2] & 0x8000) {
+			*cp++ = '8' + ((w & 0x1C0) >> 6);
+		} else {
+			*cp++ = '0' + ((w & 0x1C0) >> 6);
+		}
+
+		/* Week of year - 7th, 8th digits. */
+		num = w & 0x003F;
+		*cp++ = '0' + num / 10;
+		num %= 10;
+		*cp++ = '0' + num;
+
+		/*
+		 * Third word
+		 */
+		w = serialnum[2] & 0x7FFF;
+
+		/* Serial number - 9th digit. */
+		*cp++ = 'A' + (w / 1000);
+
+		/* 10th, 11th, 12th digits. */
+		num = w % 1000;
+		*cp++ = '0' + num / 100;
+		num %= 100;
+		*cp++ = '0' + num / 10;
+		num %= 10;
+		*cp++ = '0' + num;
+
+		*cp = '\0';	/* Null Terminate the string. */
+		return ASC_TRUE;
+	}
 }
 
 /*
@@ -7628,122 +6450,127 @@ asc_get_eeprom_string(ushort *serialnum, uchar *cp)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_asc_board_eeprom(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_asc_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t        *boardp;
-    ASC_DVC_VAR        *asc_dvc_varp;
-    int                leftlen;
-    int                totlen;
-    int                len;
-    ASCEEP_CONFIG      *ep;
-    int                i;
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp;
+	int leftlen;
+	int totlen;
+	int len;
+	ASCEEP_CONFIG *ep;
+	int i;
 #ifdef CONFIG_ISA
-    int                isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };
+	int isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };
 #endif /* CONFIG_ISA */
-    uchar              serialstr[13];
-
-    boardp = ASC_BOARDP(shp);
-    asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
-    ep = &boardp->eep_config.asc_eep;
-
-    leftlen = cplen;
-    totlen = len = 0;
-
-    len = asc_prt_line(cp, leftlen,
-"\nEEPROM Settings for AdvanSys SCSI Host %d:\n", shp->host_no);
-    ASC_PRT_NEXT();
-
-    if (asc_get_eeprom_string((ushort *) &ep->adapter_info[0], serialstr) ==
-        ASC_TRUE) {
-        len = asc_prt_line(cp, leftlen, " Serial Number: %s\n", serialstr);
-        ASC_PRT_NEXT();
-    } else {
-        if (ep->adapter_info[5] == 0xBB) {
-            len = asc_prt_line(cp, leftlen,
-                " Default Settings Used for EEPROM-less Adapter.\n");
-            ASC_PRT_NEXT();
-        } else {
-            len = asc_prt_line(cp, leftlen,
-                " Serial Number Signature Not Present.\n");
-            ASC_PRT_NEXT();
-        }
-    }
+	uchar serialstr[13];
+
+	boardp = ASC_BOARDP(shost);
+	asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+	ep = &boardp->eep_config.asc_eep;
+
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen,
+			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
+
+	if (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)
+	    == ASC_TRUE) {
+		len =
+		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
+				 serialstr);
+		ASC_PRT_NEXT();
+	} else {
+		if (ep->adapter_info[5] == 0xBB) {
+			len = asc_prt_line(cp, leftlen,
+					   " Default Settings Used for EEPROM-less Adapter.\n");
+			ASC_PRT_NEXT();
+		} else {
+			len = asc_prt_line(cp, leftlen,
+					   " Serial Number Signature Not Present.\n");
+			ASC_PRT_NEXT();
+		}
+	}
 
-    len = asc_prt_line(cp, leftlen,
-" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-        ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng, ep->max_tag_qng);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" cntl 0x%x, no_scam 0x%x\n",
-        ep->cntl, ep->no_scam);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Target ID:           ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %d", i);
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Disconnects:         ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Command Queuing:     ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Start Motor:         ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Synchronous Transfer:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
+	len = asc_prt_line(cp, leftlen,
+			   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+			   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,
+			   ep->max_tag_qng);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " cntl 0x%x, no_scam 0x%x\n", ep->cntl, ep->no_scam);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Target ID:           ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %d", i);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (ep->
+				    init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
 #ifdef CONFIG_ISA
-    if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
-        len = asc_prt_line(cp, leftlen,
-" Host ISA DMA speed:   %d MB/S\n",
-            isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
-        ASC_PRT_NEXT();
-    }
+	if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+		len = asc_prt_line(cp, leftlen,
+				   " Host ISA DMA speed:   %d MB/S\n",
+				   isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
+		ASC_PRT_NEXT();
+	}
 #endif /* CONFIG_ISA */
 
-     return totlen;
+	return totlen;
 }
 
 /*
@@ -7757,365 +6584,347 @@ asc_prt_asc_board_eeprom(struct Scsi_Host *shp, char *cp, int cplen)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_adv_board_eeprom(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_adv_board_eeprom(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t                 *boardp;
-    ADV_DVC_VAR                 *adv_dvc_varp;
-    int                         leftlen;
-    int                         totlen;
-    int                         len;
-    int                         i;
-    char                        *termstr;
-    uchar                       serialstr[13];
-    ADVEEP_3550_CONFIG          *ep_3550 = NULL;
-    ADVEEP_38C0800_CONFIG       *ep_38C0800 = NULL;
-    ADVEEP_38C1600_CONFIG       *ep_38C1600 = NULL;
-    ushort                      word;
-    ushort                      *wordp;
-    ushort                      sdtr_speed = 0;
-
-    boardp = ASC_BOARDP(shp);
-    adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        ep_3550 = &boardp->eep_config.adv_3550_eep;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
-    } else
-    {
-        ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
-    }
+	asc_board_t *boardp;
+	ADV_DVC_VAR *adv_dvc_varp;
+	int leftlen;
+	int totlen;
+	int len;
+	int i;
+	char *termstr;
+	uchar serialstr[13];
+	ADVEEP_3550_CONFIG *ep_3550 = NULL;
+	ADVEEP_38C0800_CONFIG *ep_38C0800 = NULL;
+	ADVEEP_38C1600_CONFIG *ep_38C1600 = NULL;
+	ushort word;
+	ushort *wordp;
+	ushort sdtr_speed = 0;
+
+	boardp = ASC_BOARDP(shost);
+	adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		ep_3550 = &boardp->eep_config.adv_3550_eep;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
+	} else {
+		ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
+	}
 
-    leftlen = cplen;
-    totlen = len = 0;
-
-    len = asc_prt_line(cp, leftlen,
-"\nEEPROM Settings for AdvanSys SCSI Host %d:\n", shp->host_no);
-    ASC_PRT_NEXT();
-
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        wordp = &ep_3550->serial_number_word1;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        wordp = &ep_38C0800->serial_number_word1;
-    } else
-    {
-        wordp = &ep_38C1600->serial_number_word1;
-    }
+	leftlen = cplen;
+	totlen = len = 0;
 
-    if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE) {
-        len = asc_prt_line(cp, leftlen, " Serial Number: %s\n", serialstr);
-        ASC_PRT_NEXT();
-    } else {
-        len = asc_prt_line(cp, leftlen,
-            " Serial Number Signature Not Present.\n");
-        ASC_PRT_NEXT();
-    }
+	len = asc_prt_line(cp, leftlen,
+			   "\nEEPROM Settings for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
 
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        len = asc_prt_line(cp, leftlen,
-" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-            ep_3550->adapter_scsi_id, ep_3550->max_host_qng,
-            ep_3550->max_dvc_qng);
-        ASC_PRT_NEXT();
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        len = asc_prt_line(cp, leftlen,
-" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-            ep_38C0800->adapter_scsi_id, ep_38C0800->max_host_qng,
-            ep_38C0800->max_dvc_qng);
-        ASC_PRT_NEXT();
-    } else
-    {
-        len = asc_prt_line(cp, leftlen,
-" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
-            ep_38C1600->adapter_scsi_id, ep_38C1600->max_host_qng,
-            ep_38C1600->max_dvc_qng);
-        ASC_PRT_NEXT();
-    }
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        word = ep_3550->termination;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        word = ep_38C0800->termination_lvd;
-    } else
-    {
-        word = ep_38C1600->termination_lvd;
-    }
-    switch (word) {
-        case 1:
-            termstr = "Low Off/High Off";
-            break;
-        case 2:
-            termstr = "Low Off/High On";
-            break;
-        case 3:
-            termstr = "Low On/High On";
-            break;
-        default:
-        case 0:
-            termstr = "Automatic";
-            break;
-    }
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		wordp = &ep_3550->serial_number_word1;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		wordp = &ep_38C0800->serial_number_word1;
+	} else {
+		wordp = &ep_38C1600->serial_number_word1;
+	}
 
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        len = asc_prt_line(cp, leftlen,
-" termination: %u (%s), bios_ctrl: 0x%x\n",
-            ep_3550->termination, termstr, ep_3550->bios_ctrl);
-        ASC_PRT_NEXT();
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        len = asc_prt_line(cp, leftlen,
-" termination: %u (%s), bios_ctrl: 0x%x\n",
-            ep_38C0800->termination_lvd, termstr, ep_38C0800->bios_ctrl);
-        ASC_PRT_NEXT();
-    } else
-    {
-        len = asc_prt_line(cp, leftlen,
-" termination: %u (%s), bios_ctrl: 0x%x\n",
-            ep_38C1600->termination_lvd, termstr, ep_38C1600->bios_ctrl);
-        ASC_PRT_NEXT();
-    }
+	if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE) {
+		len =
+		    asc_prt_line(cp, leftlen, " Serial Number: %s\n",
+				 serialstr);
+		ASC_PRT_NEXT();
+	} else {
+		len = asc_prt_line(cp, leftlen,
+				   " Serial Number Signature Not Present.\n");
+		ASC_PRT_NEXT();
+	}
 
-    len = asc_prt_line(cp, leftlen,
-" Target ID:           ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %X", i);
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        word = ep_3550->disc_enable;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        word = ep_38C0800->disc_enable;
-    } else
-    {
-        word = ep_38C1600->disc_enable;
-    }
-    len = asc_prt_line(cp, leftlen,
-" Disconnects:         ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        word = ep_3550->tagqng_able;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        word = ep_38C0800->tagqng_able;
-    } else
-    {
-        word = ep_38C1600->tagqng_able;
-    }
-    len = asc_prt_line(cp, leftlen,
-" Command Queuing:     ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        word = ep_3550->start_motor;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        word = ep_38C0800->start_motor;
-    } else
-    {
-        word = ep_38C1600->start_motor;
-    }
-    len = asc_prt_line(cp, leftlen,
-" Start Motor:         ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        len = asc_prt_line(cp, leftlen,
-" Synchronous Transfer:");
-        ASC_PRT_NEXT();
-        for (i = 0; i <= ADV_MAX_TID; i++) {
-            len = asc_prt_line(cp, leftlen, " %c",
-                (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-            ASC_PRT_NEXT();
-        }
-        len = asc_prt_line(cp, leftlen, "\n");
-        ASC_PRT_NEXT();
-    }
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen,
+				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+				   ep_3550->adapter_scsi_id,
+				   ep_3550->max_host_qng, ep_3550->max_dvc_qng);
+		ASC_PRT_NEXT();
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		len = asc_prt_line(cp, leftlen,
+				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+				   ep_38C0800->adapter_scsi_id,
+				   ep_38C0800->max_host_qng,
+				   ep_38C0800->max_dvc_qng);
+		ASC_PRT_NEXT();
+	} else {
+		len = asc_prt_line(cp, leftlen,
+				   " Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+				   ep_38C1600->adapter_scsi_id,
+				   ep_38C1600->max_host_qng,
+				   ep_38C1600->max_dvc_qng);
+		ASC_PRT_NEXT();
+	}
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->termination;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->termination_lvd;
+	} else {
+		word = ep_38C1600->termination_lvd;
+	}
+	switch (word) {
+	case 1:
+		termstr = "Low Off/High Off";
+		break;
+	case 2:
+		termstr = "Low Off/High On";
+		break;
+	case 3:
+		termstr = "Low On/High On";
+		break;
+	default:
+	case 0:
+		termstr = "Automatic";
+		break;
+	}
 
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        len = asc_prt_line(cp, leftlen,
-" Ultra Transfer:      ");
-    ASC_PRT_NEXT();
-        for (i = 0; i <= ADV_MAX_TID; i++) {
-            len = asc_prt_line(cp, leftlen, " %c",
-                (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-            ASC_PRT_NEXT();
-        }
-        len = asc_prt_line(cp, leftlen, "\n");
-        ASC_PRT_NEXT();
-    }
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen,
+				   " termination: %u (%s), bios_ctrl: 0x%x\n",
+				   ep_3550->termination, termstr,
+				   ep_3550->bios_ctrl);
+		ASC_PRT_NEXT();
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		len = asc_prt_line(cp, leftlen,
+				   " termination: %u (%s), bios_ctrl: 0x%x\n",
+				   ep_38C0800->termination_lvd, termstr,
+				   ep_38C0800->bios_ctrl);
+		ASC_PRT_NEXT();
+	} else {
+		len = asc_prt_line(cp, leftlen,
+				   " termination: %u (%s), bios_ctrl: 0x%x\n",
+				   ep_38C1600->termination_lvd, termstr,
+				   ep_38C1600->bios_ctrl);
+		ASC_PRT_NEXT();
+	}
 
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
-    {
-        word = ep_3550->wdtr_able;
-    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        word = ep_38C0800->wdtr_able;
-    } else
-    {
-        word = ep_38C1600->wdtr_able;
-    }
-    len = asc_prt_line(cp, leftlen,
-" Wide Transfer:       ");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        len = asc_prt_line(cp, leftlen, " %c",
-            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
-        adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600)
-    {
-        len = asc_prt_line(cp, leftlen,
-" Synchronous Transfer Speed (Mhz):\n  ");
-        ASC_PRT_NEXT();
-        for (i = 0; i <= ADV_MAX_TID; i++) {
-            char *speed_str;
-
-            if (i == 0)
-            {
-                sdtr_speed = adv_dvc_varp->sdtr_speed1;
-            } else if (i == 4)
-            {
-                sdtr_speed = adv_dvc_varp->sdtr_speed2;
-            } else if (i == 8)
-            {
-                sdtr_speed = adv_dvc_varp->sdtr_speed3;
-            } else if (i == 12)
-            {
-                sdtr_speed = adv_dvc_varp->sdtr_speed4;
-            }
-            switch (sdtr_speed & ADV_MAX_TID)
-            {
-                case 0:  speed_str = "Off"; break;
-                case 1:  speed_str = "  5"; break;
-                case 2:  speed_str = " 10"; break;
-                case 3:  speed_str = " 20"; break;
-                case 4:  speed_str = " 40"; break;
-                case 5:  speed_str = " 80"; break;
-                default: speed_str = "Unk"; break;
-            }
-            len = asc_prt_line(cp, leftlen, "%X:%s ", i, speed_str);
-            ASC_PRT_NEXT();
-            if (i == 7)
-            {
-                len = asc_prt_line(cp, leftlen, "\n  ");
-                ASC_PRT_NEXT();
-            }
-            sdtr_speed >>= 4;
-        }
-        len = asc_prt_line(cp, leftlen, "\n");
-        ASC_PRT_NEXT();
-    }
+	len = asc_prt_line(cp, leftlen, " Target ID:           ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %X", i);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-    return totlen;
-}
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->disc_enable;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->disc_enable;
+	} else {
+		word = ep_38C1600->disc_enable;
+	}
+	len = asc_prt_line(cp, leftlen, " Disconnects:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
 
-/*
- * asc_prt_driver_conf()
- *
- * Note: no single line should be greater than ASC_PRTLINE_SIZE,
- * cf. asc_prt_line().
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->tagqng_able;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->tagqng_able;
+	} else {
+		word = ep_38C1600->tagqng_able;
+	}
+	len = asc_prt_line(cp, leftlen, " Command Queuing:     ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->start_motor;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->start_motor;
+	} else {
+		word = ep_38C1600->start_motor;
+	}
+	len = asc_prt_line(cp, leftlen, " Start Motor:         ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
+		ASC_PRT_NEXT();
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			len = asc_prt_line(cp, leftlen, " %c",
+					   (ep_3550->
+					    sdtr_able & ADV_TID_TO_TIDMASK(i)) ?
+					   'Y' : 'N');
+			ASC_PRT_NEXT();
+		}
+		len = asc_prt_line(cp, leftlen, "\n");
+		ASC_PRT_NEXT();
+	}
+
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		len = asc_prt_line(cp, leftlen, " Ultra Transfer:      ");
+		ASC_PRT_NEXT();
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			len = asc_prt_line(cp, leftlen, " %c",
+					   (ep_3550->
+					    ultra_able & ADV_TID_TO_TIDMASK(i))
+					   ? 'Y' : 'N');
+			ASC_PRT_NEXT();
+		}
+		len = asc_prt_line(cp, leftlen, "\n");
+		ASC_PRT_NEXT();
+	}
+
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+		word = ep_3550->wdtr_able;
+	} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+		word = ep_38C0800->wdtr_able;
+	} else {
+		word = ep_38C1600->wdtr_able;
+	}
+	len = asc_prt_line(cp, leftlen, " Wide Transfer:       ");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		len = asc_prt_line(cp, leftlen, " %c",
+				   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
+	    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {
+		len = asc_prt_line(cp, leftlen,
+				   " Synchronous Transfer Speed (Mhz):\n  ");
+		ASC_PRT_NEXT();
+		for (i = 0; i <= ADV_MAX_TID; i++) {
+			char *speed_str;
+
+			if (i == 0) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed1;
+			} else if (i == 4) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed2;
+			} else if (i == 8) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed3;
+			} else if (i == 12) {
+				sdtr_speed = adv_dvc_varp->sdtr_speed4;
+			}
+			switch (sdtr_speed & ADV_MAX_TID) {
+			case 0:
+				speed_str = "Off";
+				break;
+			case 1:
+				speed_str = "  5";
+				break;
+			case 2:
+				speed_str = " 10";
+				break;
+			case 3:
+				speed_str = " 20";
+				break;
+			case 4:
+				speed_str = " 40";
+				break;
+			case 5:
+				speed_str = " 80";
+				break;
+			default:
+				speed_str = "Unk";
+				break;
+			}
+			len = asc_prt_line(cp, leftlen, "%X:%s ", i, speed_str);
+			ASC_PRT_NEXT();
+			if (i == 7) {
+				len = asc_prt_line(cp, leftlen, "\n  ");
+				ASC_PRT_NEXT();
+			}
+			sdtr_speed >>= 4;
+		}
+		len = asc_prt_line(cp, leftlen, "\n");
+		ASC_PRT_NEXT();
+	}
+
+	return totlen;
+}
+
+/*
+ * asc_prt_driver_conf()
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
  *
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_driver_conf(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_driver_conf(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t            *boardp;
-    int                    leftlen;
-    int                    totlen;
-    int                    len;
-    int                    chip_scsi_id;
-
-    boardp = ASC_BOARDP(shp);
-
-    leftlen = cplen;
-    totlen = len = 0;
-
-    len = asc_prt_line(cp, leftlen,
-"\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
-        shp->host_no);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
-        shp->host_busy, shp->last_reset, shp->max_id, shp->max_lun,
-        shp->max_channel);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
-        shp->unique_id, shp->can_queue, shp->this_id, shp->sg_tablesize,
-        shp->cmd_per_lun);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" unchecked_isa_dma %d, use_clustering %d\n",
-        shp->unchecked_isa_dma, shp->use_clustering);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
-        boardp->flags, boardp->last_reset, jiffies, boardp->asc_n_io_port);
-    ASC_PRT_NEXT();
-
-     /* 'shp->n_io_port' may be truncated because it is only one byte. */
-    len = asc_prt_line(cp, leftlen,
-" io_port 0x%x, n_io_port 0x%x\n",
-        shp->io_port, shp->n_io_port);
-    ASC_PRT_NEXT();
-
-    if (ASC_NARROW_BOARD(boardp)) {
-        chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
-    } else {
-        chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
-    }
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	int chip_scsi_id;
+
+	boardp = ASC_BOARDP(shost);
+
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen,
+			   "\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
+			   shost->host_busy, shost->last_reset, shost->max_id,
+			   shost->max_lun, shost->max_channel);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
+			   shost->unique_id, shost->can_queue, shost->this_id,
+			   shost->sg_tablesize, shost->cmd_per_lun);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " unchecked_isa_dma %d, use_clustering %d\n",
+			   shost->unchecked_isa_dma, shost->use_clustering);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
+			   boardp->flags, boardp->last_reset, jiffies,
+			   boardp->asc_n_io_port);
+	ASC_PRT_NEXT();
+
+	/* 'shost->n_io_port' may be truncated because it is only one byte. */
+	len = asc_prt_line(cp, leftlen,
+			   " io_port 0x%x, n_io_port 0x%x\n",
+			   shost->io_port, shost->n_io_port);
+	ASC_PRT_NEXT();
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+	} else {
+		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+	}
 
-    return totlen;
+	return totlen;
 }
 
 /*
@@ -8129,178 +6938,181 @@ asc_prt_driver_conf(struct Scsi_Host *shp, char *cp, int cplen)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_asc_board_info(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_asc_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t            *boardp;
-    int                    chip_scsi_id;
-    int                    leftlen;
-    int                    totlen;
-    int                    len;
-    ASC_DVC_VAR            *v;
-    ASC_DVC_CFG            *c;
-    int                    i;
-    int                    renegotiate = 0;
-
-    boardp = ASC_BOARDP(shp);
-    v = &boardp->dvc_var.asc_dvc_var;
-    c = &boardp->dvc_cfg.asc_dvc_cfg;
-    chip_scsi_id = c->chip_scsi_id;
-
-    leftlen = cplen;
-    totlen = len = 0;
-
-    len = asc_prt_line(cp, leftlen,
-"\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
-    shp->host_no);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" chip_version %u, lib_version 0x%x, lib_serial_no %u, mcode_date 0x%x\n",
-        c->chip_version, c->lib_version, c->lib_serial_no, c->mcode_date);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" mcode_version 0x%x, err_code %u\n",
-         c->mcode_version, v->err_code);
-    ASC_PRT_NEXT();
-
-    /* Current number of commands waiting for the host. */
-    len = asc_prt_line(cp, leftlen,
-" Total Command Pending: %d\n", v->cur_total_qng);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Command Queuing:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-        len = asc_prt_line(cp, leftlen, " %X:%c",
-            i, (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    /* Current number of commands waiting for a device. */
-    len = asc_prt_line(cp, leftlen,
-" Command Queue Pending:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-        len = asc_prt_line(cp, leftlen, " %X:%u", i, v->cur_dvc_qng[i]);
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    /* Current limit on number of commands that can be sent to a device. */
-    len = asc_prt_line(cp, leftlen,
-" Command Queue Limit:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-        len = asc_prt_line(cp, leftlen, " %X:%u", i, v->max_dvc_qng[i]);
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    /* Indicate whether the device has returned queue full status. */
-    len = asc_prt_line(cp, leftlen,
-" Command Queue Full:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-        if (boardp->queue_full & ADV_TID_TO_TIDMASK(i)) {
-            len = asc_prt_line(cp, leftlen, " %X:Y-%d",
-                i, boardp->queue_full_cnt[i]);
-        } else {
-            len = asc_prt_line(cp, leftlen, " %X:N", i);
-        }
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Synchronous Transfer:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-        len = asc_prt_line(cp, leftlen, " %X:%c",
-            i, (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        uchar syn_period_ix;
-
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
-            ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        len = asc_prt_line(cp, leftlen, "  %X:", i);
-        ASC_PRT_NEXT();
-
-        if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0)
-        {
-            len = asc_prt_line(cp, leftlen, " Asynchronous");
-            ASC_PRT_NEXT();
-        } else
-        {
-            syn_period_ix =
-                (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index - 1);
-
-            len = asc_prt_line(cp, leftlen,
-                " Transfer Period Factor: %d (%d.%d Mhz),",
-                v->sdtr_period_tbl[syn_period_ix],
-                250 / v->sdtr_period_tbl[syn_period_ix],
-                ASC_TENTHS(250, v->sdtr_period_tbl[syn_period_ix]));
-            ASC_PRT_NEXT();
-
-            len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
-                boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET);
-            ASC_PRT_NEXT();
-        }
-
-        if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-            len = asc_prt_line(cp, leftlen, "*\n");
-            renegotiate = 1;
-        } else
-        {
-            len = asc_prt_line(cp, leftlen, "\n");
-        }
-        ASC_PRT_NEXT();
-    }
+	asc_board_t *boardp;
+	int chip_scsi_id;
+	int leftlen;
+	int totlen;
+	int len;
+	ASC_DVC_VAR *v;
+	ASC_DVC_CFG *c;
+	int i;
+	int renegotiate = 0;
+
+	boardp = ASC_BOARDP(shost);
+	v = &boardp->dvc_var.asc_dvc_var;
+	c = &boardp->dvc_cfg.asc_dvc_cfg;
+	chip_scsi_id = c->chip_scsi_id;
+
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen,
+			   "\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " chip_version %u, lib_version 0x%x, lib_serial_no %u, mcode_date 0x%x\n",
+			   c->chip_version, c->lib_version, c->lib_serial_no,
+			   c->mcode_date);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " mcode_version 0x%x, err_code %u\n",
+			   c->mcode_version, v->err_code);
+	ASC_PRT_NEXT();
+
+	/* Current number of commands waiting for the host. */
+	len = asc_prt_line(cp, leftlen,
+			   " Total Command Pending: %d\n", v->cur_total_qng);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Command Queuing:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (v->
+				    use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ?
+				   'Y' : 'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	/* Current number of commands waiting for a device. */
+	len = asc_prt_line(cp, leftlen, " Command Queue Pending:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->cur_dvc_qng[i]);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	/* Current limit on number of commands that can be sent to a device. */
+	len = asc_prt_line(cp, leftlen, " Command Queue Limit:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		len = asc_prt_line(cp, leftlen, " %X:%u", i, v->max_dvc_qng[i]);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	/* Indicate whether the device has returned queue full status. */
+	len = asc_prt_line(cp, leftlen, " Command Queue Full:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		if (boardp->queue_full & ADV_TID_TO_TIDMASK(i)) {
+			len = asc_prt_line(cp, leftlen, " %X:Y-%d",
+					   i, boardp->queue_full_cnt[i]);
+		} else {
+			len = asc_prt_line(cp, leftlen, " %X:N", i);
+		}
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Synchronous Transfer:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (v->
+				    sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		uchar syn_period_ix;
+
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
+		    ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		len = asc_prt_line(cp, leftlen, "  %X:", i);
+		ASC_PRT_NEXT();
+
+		if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {
+			len = asc_prt_line(cp, leftlen, " Asynchronous");
+			ASC_PRT_NEXT();
+		} else {
+			syn_period_ix =
+			    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -
+							   1);
+
+			len = asc_prt_line(cp, leftlen,
+					   " Transfer Period Factor: %d (%d.%d Mhz),",
+					   v->sdtr_period_tbl[syn_period_ix],
+					   250 /
+					   v->sdtr_period_tbl[syn_period_ix],
+					   ASC_TENTHS(250,
+						      v->
+						      sdtr_period_tbl
+						      [syn_period_ix]));
+			ASC_PRT_NEXT();
+
+			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
+					   boardp->
+					   sdtr_data[i] & ASC_SYN_MAX_OFFSET);
+			ASC_PRT_NEXT();
+		}
+
+		if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+			len = asc_prt_line(cp, leftlen, "*\n");
+			renegotiate = 1;
+		} else {
+			len = asc_prt_line(cp, leftlen, "\n");
+		}
+		ASC_PRT_NEXT();
+	}
 
-    if (renegotiate)
-    {
-        len = asc_prt_line(cp, leftlen,
-            " * = Re-negotiation pending before next command.\n");
-        ASC_PRT_NEXT();
-    }
+	if (renegotiate) {
+		len = asc_prt_line(cp, leftlen,
+				   " * = Re-negotiation pending before next command.\n");
+		ASC_PRT_NEXT();
+	}
 
-    return totlen;
+	return totlen;
 }
 
 /*
@@ -8314,237 +7126,242 @@ asc_prt_asc_board_info(struct Scsi_Host *shp, char *cp, int cplen)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_adv_board_info(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_adv_board_info(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    asc_board_t            *boardp;
-    int                    leftlen;
-    int                    totlen;
-    int                    len;
-    int                    i;
-    ADV_DVC_VAR            *v;
-    ADV_DVC_CFG            *c;
-    AdvPortAddr            iop_base;
-    ushort                 chip_scsi_id;
-    ushort                 lramword;
-    uchar                  lrambyte;
-    ushort                 tagqng_able;
-    ushort                 sdtr_able, wdtr_able;
-    ushort                 wdtr_done, sdtr_done;
-    ushort                 period = 0;
-    int                    renegotiate = 0;
-
-    boardp = ASC_BOARDP(shp);
-    v = &boardp->dvc_var.adv_dvc_var;
-    c = &boardp->dvc_cfg.adv_dvc_cfg;
-    iop_base = v->iop_base;
-    chip_scsi_id = v->chip_scsi_id;
-
-    leftlen = cplen;
-    totlen = len = 0;
-
-    len = asc_prt_line(cp, leftlen,
-"\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
-    shp->host_no);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" iop_base 0x%lx, cable_detect: %X, err_code %u\n",
-         v->iop_base,
-         AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1) & CABLE_DETECT,
-         v->err_code);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" chip_version %u, lib_version 0x%x, mcode_date 0x%x, mcode_version 0x%x\n",
-        c->chip_version, c->lib_version, c->mcode_date, c->mcode_version);
-    ASC_PRT_NEXT();
-
-    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-    len = asc_prt_line(cp, leftlen,
-" Queuing Enabled:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        len = asc_prt_line(cp, leftlen, " %X:%c",
-            i, (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Queue Limit:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i, lrambyte);
-
-        len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" Command Pending:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i, lrambyte);
-
-        len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-    len = asc_prt_line(cp, leftlen,
-" Wide Enabled:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        len = asc_prt_line(cp, leftlen, " %X:%c",
-            i, (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
-    len = asc_prt_line(cp, leftlen,
-" Transfer Bit Width:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        AdvReadWordLram(iop_base, ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
-            lramword);
-
-        len = asc_prt_line(cp, leftlen, " %X:%d",
-            i, (lramword & 0x8000) ? 16 : 8);
-        ASC_PRT_NEXT();
-
-        if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
-            (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-            len = asc_prt_line(cp, leftlen, "*");
-            ASC_PRT_NEXT();
-            renegotiate = 1;
-        }
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-    len = asc_prt_line(cp, leftlen,
-" Synchronous Enabled:");
-    ASC_PRT_NEXT();
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        len = asc_prt_line(cp, leftlen, " %X:%c",
-            i, (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
-        ASC_PRT_NEXT();
-    }
-    len = asc_prt_line(cp, leftlen, "\n");
-    ASC_PRT_NEXT();
-
-    AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
-    for (i = 0; i <= ADV_MAX_TID; i++) {
-
-        AdvReadWordLram(iop_base, ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
-            lramword);
-        lramword &= ~0x8000;
-
-        if ((chip_scsi_id == i) ||
-            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
-            ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {
-            continue;
-        }
-
-        len = asc_prt_line(cp, leftlen, "  %X:", i);
-        ASC_PRT_NEXT();
-
-        if ((lramword & 0x1F) == 0) /* Check for REQ/ACK Offset 0. */
-        {
-            len = asc_prt_line(cp, leftlen, " Asynchronous");
-            ASC_PRT_NEXT();
-        } else
-        {
-            len = asc_prt_line(cp, leftlen, " Transfer Period Factor: ");
-            ASC_PRT_NEXT();
-
-            if ((lramword & 0x1F00) == 0x1100) /* 80 Mhz */
-            {
-                len = asc_prt_line(cp, leftlen, "9 (80.0 Mhz),");
-                ASC_PRT_NEXT();
-            } else if ((lramword & 0x1F00) == 0x1000) /* 40 Mhz */
-            {
-                len = asc_prt_line(cp, leftlen, "10 (40.0 Mhz),");
-                ASC_PRT_NEXT();
-            } else /* 20 Mhz or below. */
-            {
-                period = (((lramword >> 8) * 25) + 50)/4;
-
-                if (period == 0) /* Should never happen. */
-                {
-                    len = asc_prt_line(cp, leftlen, "%d (? Mhz), ");
-                    ASC_PRT_NEXT();
-                } else
-                {
-                    len = asc_prt_line(cp, leftlen,
-                        "%d (%d.%d Mhz),",
-                        period, 250/period, ASC_TENTHS(250, period));
-                    ASC_PRT_NEXT();
-                }
-            }
-
-            len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
-                lramword & 0x1F);
-            ASC_PRT_NEXT();
-        }
-
-        if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
-            len = asc_prt_line(cp, leftlen, "*\n");
-            renegotiate = 1;
-        } else
-        {
-            len = asc_prt_line(cp, leftlen, "\n");
-        }
-        ASC_PRT_NEXT();
-    }
+	asc_board_t *boardp;
+	int leftlen;
+	int totlen;
+	int len;
+	int i;
+	ADV_DVC_VAR *v;
+	ADV_DVC_CFG *c;
+	AdvPortAddr iop_base;
+	ushort chip_scsi_id;
+	ushort lramword;
+	uchar lrambyte;
+	ushort tagqng_able;
+	ushort sdtr_able, wdtr_able;
+	ushort wdtr_done, sdtr_done;
+	ushort period = 0;
+	int renegotiate = 0;
+
+	boardp = ASC_BOARDP(shost);
+	v = &boardp->dvc_var.adv_dvc_var;
+	c = &boardp->dvc_cfg.adv_dvc_cfg;
+	iop_base = v->iop_base;
+	chip_scsi_id = v->chip_scsi_id;
+
+	leftlen = cplen;
+	totlen = len = 0;
+
+	len = asc_prt_line(cp, leftlen,
+			   "\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " iop_base 0x%lx, cable_detect: %X, err_code %u\n",
+			   v->iop_base,
+			   AdvReadWordRegister(iop_base,
+					       IOPW_SCSI_CFG1) & CABLE_DETECT,
+			   v->err_code);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " chip_version %u, lib_version 0x%x, mcode_date 0x%x, mcode_version 0x%x\n",
+			   c->chip_version, c->lib_version, c->mcode_date,
+			   c->mcode_version);
+	ASC_PRT_NEXT();
+
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	len = asc_prt_line(cp, leftlen, " Queuing Enabled:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Queue Limit:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,
+				lrambyte);
+
+		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen, " Command Pending:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,
+				lrambyte);
+
+		len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	len = asc_prt_line(cp, leftlen, " Wide Enabled:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
+	len = asc_prt_line(cp, leftlen, " Transfer Bit Width:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		AdvReadWordLram(iop_base,
+				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
+				lramword);
+
+		len = asc_prt_line(cp, leftlen, " %X:%d",
+				   i, (lramword & 0x8000) ? 16 : 8);
+		ASC_PRT_NEXT();
+
+		if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
+		    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+			len = asc_prt_line(cp, leftlen, "*");
+			ASC_PRT_NEXT();
+			renegotiate = 1;
+		}
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	len = asc_prt_line(cp, leftlen, " Synchronous Enabled:");
+	ASC_PRT_NEXT();
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		len = asc_prt_line(cp, leftlen, " %X:%c",
+				   i,
+				   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' :
+				   'N');
+		ASC_PRT_NEXT();
+	}
+	len = asc_prt_line(cp, leftlen, "\n");
+	ASC_PRT_NEXT();
+
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
+	for (i = 0; i <= ADV_MAX_TID; i++) {
+
+		AdvReadWordLram(iop_base,
+				ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
+				lramword);
+		lramword &= ~0x8000;
+
+		if ((chip_scsi_id == i) ||
+		    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
+		    ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {
+			continue;
+		}
+
+		len = asc_prt_line(cp, leftlen, "  %X:", i);
+		ASC_PRT_NEXT();
+
+		if ((lramword & 0x1F) == 0) {	/* Check for REQ/ACK Offset 0. */
+			len = asc_prt_line(cp, leftlen, " Asynchronous");
+			ASC_PRT_NEXT();
+		} else {
+			len =
+			    asc_prt_line(cp, leftlen,
+					 " Transfer Period Factor: ");
+			ASC_PRT_NEXT();
+
+			if ((lramword & 0x1F00) == 0x1100) {	/* 80 Mhz */
+				len =
+				    asc_prt_line(cp, leftlen, "9 (80.0 Mhz),");
+				ASC_PRT_NEXT();
+			} else if ((lramword & 0x1F00) == 0x1000) {	/* 40 Mhz */
+				len =
+				    asc_prt_line(cp, leftlen, "10 (40.0 Mhz),");
+				ASC_PRT_NEXT();
+			} else {	/* 20 Mhz or below. */
+
+				period = (((lramword >> 8) * 25) + 50) / 4;
+
+				if (period == 0) {	/* Should never happen. */
+					len =
+					    asc_prt_line(cp, leftlen,
+							 "%d (? Mhz), ");
+					ASC_PRT_NEXT();
+				} else {
+					len = asc_prt_line(cp, leftlen,
+							   "%d (%d.%d Mhz),",
+							   period, 250 / period,
+							   ASC_TENTHS(250,
+								      period));
+					ASC_PRT_NEXT();
+				}
+			}
+
+			len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
+					   lramword & 0x1F);
+			ASC_PRT_NEXT();
+		}
+
+		if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+			len = asc_prt_line(cp, leftlen, "*\n");
+			renegotiate = 1;
+		} else {
+			len = asc_prt_line(cp, leftlen, "\n");
+		}
+		ASC_PRT_NEXT();
+	}
 
-    if (renegotiate)
-    {
-        len = asc_prt_line(cp, leftlen,
-            " * = Re-negotiation pending before next command.\n");
-        ASC_PRT_NEXT();
-    }
+	if (renegotiate) {
+		len = asc_prt_line(cp, leftlen,
+				   " * = Re-negotiation pending before next command.\n");
+		ASC_PRT_NEXT();
+	}
 
-    return totlen;
+	return totlen;
 }
 
 /*
@@ -8553,30 +7370,30 @@ asc_prt_adv_board_info(struct Scsi_Host *shp, char *cp, int cplen)
  * Copy proc information to a read buffer taking into account the current
  * read offset in the file and the remaining space in the read buffer.
  */
-STATIC int
+static int
 asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
-              char *cp, int cplen)
+	      char *cp, int cplen)
 {
-    int cnt = 0;
-
-    ASC_DBG3(2, "asc_proc_copy: offset %d, advoffset %d, cplen %d\n",
-            (unsigned) offset, (unsigned) advoffset, cplen);
-    if (offset <= advoffset) {
-        /* Read offset below current offset, copy everything. */
-        cnt = min(cplen, leftlen);
-        ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
-                (ulong) curbuf, (ulong) cp, cnt);
-        memcpy(curbuf, cp, cnt);
-    } else if (offset < advoffset + cplen) {
-        /* Read offset within current range, partial copy. */
-        cnt = (advoffset + cplen) - offset;
-        cp = (cp + cplen) - cnt;
-        cnt = min(cnt, leftlen);
-        ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
-                (ulong) curbuf, (ulong) cp, cnt);
-        memcpy(curbuf, cp, cnt);
-    }
-    return cnt;
+	int cnt = 0;
+
+	ASC_DBG3(2, "asc_proc_copy: offset %d, advoffset %d, cplen %d\n",
+		 (unsigned)offset, (unsigned)advoffset, cplen);
+	if (offset <= advoffset) {
+		/* Read offset below current offset, copy everything. */
+		cnt = min(cplen, leftlen);
+		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+			 (ulong)curbuf, (ulong)cp, cnt);
+		memcpy(curbuf, cp, cnt);
+	} else if (offset < advoffset + cplen) {
+		/* Read offset within current range, partial copy. */
+		cnt = (advoffset + cplen) - offset;
+		cp = (cp + cplen) - cnt;
+		cnt = min(cnt, leftlen);
+		ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+			 (ulong)curbuf, (ulong)cp, cnt);
+		memcpy(curbuf, cp, cnt);
+	}
+	return cnt;
 }
 
 /*
@@ -8590,29 +7407,27 @@ asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
  * Note: If any single line is greater than ASC_PRTLINE_SIZE bytes the stack
  * will be corrupted. 's[]' is defined to be ASC_PRTLINE_SIZE bytes.
  */
-STATIC int
-asc_prt_line(char *buf, int buflen, char *fmt, ...)
+static int asc_prt_line(char *buf, int buflen, char *fmt, ...)
 {
-    va_list        args;
-    int            ret;
-    char           s[ASC_PRTLINE_SIZE];
-
-    va_start(args, fmt);
-    ret = vsprintf(s, fmt, args);
-    ASC_ASSERT(ret < ASC_PRTLINE_SIZE);
-    if (buf == NULL) {
-        (void) printk(s);
-        ret = 0;
-    } else {
-        ret = min(buflen, ret);
-        memcpy(buf, s, ret);
-    }
-    va_end(args);
-    return ret;
+	va_list args;
+	int ret;
+	char s[ASC_PRTLINE_SIZE];
+
+	va_start(args, fmt);
+	ret = vsprintf(s, fmt, args);
+	ASC_ASSERT(ret < ASC_PRTLINE_SIZE);
+	if (buf == NULL) {
+		(void)printk(s);
+		ret = 0;
+	} else {
+		ret = min(buflen, ret);
+		memcpy(buf, s, ret);
+	}
+	va_end(args);
+	return ret;
 }
 #endif /* CONFIG_PROC_FS */
 
-
 /*
  * --- Functions Required by the Asc Library
  */
@@ -8623,31 +7438,28 @@ asc_prt_line(char *buf, int buflen, char *fmt, ...)
  * from a timer interrupt, because this function may be
  * called when interrupts are disabled.
  */
-STATIC void
-DvcSleepMilliSecond(ADV_DCNT n)
+static void DvcSleepMilliSecond(ADV_DCNT n)
 {
-    ASC_DBG1(4, "DvcSleepMilliSecond: %lu\n", (ulong) n);
-    mdelay(n);
+	ASC_DBG1(4, "DvcSleepMilliSecond: %lu\n", (ulong)n);
+	mdelay(n);
 }
 
 /*
  * Currently and inline noop but leave as a placeholder.
  * Leave DvcEnterCritical() as a noop placeholder.
  */
-STATIC inline ulong
-DvcEnterCritical(void)
+static inline ulong DvcEnterCritical(void)
 {
-    return 0;
+	return 0;
 }
 
 /*
  * Critical sections are all protected by the board spinlock.
  * Leave DvcLeaveCritical() as a noop placeholder.
  */
-STATIC inline void
-DvcLeaveCritical(ulong flags)
+static inline void DvcLeaveCritical(ulong flags)
 {
-    return;
+	return;
 }
 
 /*
@@ -8660,20 +7472,20 @@ DvcLeaveCritical(ulong flags)
  * Description:
  *     Output an ASC_SCSI_Q structure to the chip
  */
-STATIC void
+static void
 DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
 {
-    int    i;
-
-    ASC_DBG_PRT_HEX(2, "DvcPutScsiQ", outbuf, 2 * words);
-    AscSetChipLramAddr(iop_base, s_addr);
-    for (i = 0; i < 2 * words; i += 2) {
-        if (i == 4 || i == 20) {
-            continue;
-        }
-        outpw(iop_base + IOP_RAM_DATA,
-            ((ushort) outbuf[i + 1] << 8) | outbuf[i]);
-    }
+	int i;
+
+	ASC_DBG_PRT_HEX(2, "DvcPutScsiQ", outbuf, 2 * words);
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		if (i == 4 || i == 20) {
+			continue;
+		}
+		outpw(iop_base + IOP_RAM_DATA,
+		      ((ushort)outbuf[i + 1] << 8) | outbuf[i]);
+	}
 }
 
 /*
@@ -8686,52 +7498,46 @@ DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
  * Description:
  *     Input an ASC_QDONE_INFO structure from the chip
  */
-STATIC void
+static void
 DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
 {
-    int    i;
-    ushort word;
-
-    AscSetChipLramAddr(iop_base, s_addr);
-    for (i = 0; i < 2 * words; i += 2) {
-        if (i == 10) {
-            continue;
-        }
-        word = inpw(iop_base + IOP_RAM_DATA);
-        inbuf[i] = word & 0xff;
-        inbuf[i + 1] = (word >> 8) & 0xff;
-    }
-    ASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);
+	int i;
+	ushort word;
+
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		if (i == 10) {
+			continue;
+		}
+		word = inpw(iop_base + IOP_RAM_DATA);
+		inbuf[i] = word & 0xff;
+		inbuf[i + 1] = (word >> 8) & 0xff;
+	}
+	ASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);
 }
 
 /*
  * Read a PCI configuration byte.
  */
-STATIC uchar __init
-DvcReadPCIConfigByte(
-        ASC_DVC_VAR *asc_dvc,
-        ushort offset)
+static uchar __init DvcReadPCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset)
 {
 #ifdef CONFIG_PCI
-    uchar byte_data;
-    pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
-    return byte_data;
+	uchar byte_data;
+	pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
+	return byte_data;
 #else /* !defined(CONFIG_PCI) */
-    return 0;
+	return 0;
 #endif /* !defined(CONFIG_PCI) */
 }
 
 /*
  * Write a PCI configuration byte.
  */
-STATIC void __init
-DvcWritePCIConfigByte(
-        ASC_DVC_VAR *asc_dvc,
-        ushort offset,
-        uchar  byte_data)
+static void __init
+DvcWritePCIConfigByte(ASC_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
 {
 #ifdef CONFIG_PCI
-    pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
+	pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
 #endif /* CONFIG_PCI */
 }
 
@@ -8739,51 +7545,43 @@ DvcWritePCIConfigByte(
  * Return the BIOS address of the adapter at the specified
  * I/O port and with the specified bus type.
  */
-STATIC ushort __init
-AscGetChipBiosAddress(
-        PortAddr iop_base,
-        ushort bus_type)
+static ushort __init AscGetChipBiosAddress(PortAddr iop_base, ushort bus_type)
 {
-    ushort  cfg_lsw;
-    ushort  bios_addr;
-
-    /*
-     * The PCI BIOS is re-located by the motherboard BIOS. Because
-     * of this the driver can not determine where a PCI BIOS is
-     * loaded and executes.
-     */
-    if (bus_type & ASC_IS_PCI)
-    {
-        return(0);
-    }
-
+	ushort cfg_lsw;
+	ushort bios_addr;
+
+	/*
+	 * The PCI BIOS is re-located by the motherboard BIOS. Because
+	 * of this the driver can not determine where a PCI BIOS is
+	 * loaded and executes.
+	 */
+	if (bus_type & ASC_IS_PCI) {
+		return (0);
+	}
 #ifdef CONFIG_ISA
-    if((bus_type & ASC_IS_EISA) != 0)
-    {
-        cfg_lsw = AscGetEisaChipCfg(iop_base);
-        cfg_lsw &= 0x000F;
-        bios_addr = (ushort)(ASC_BIOS_MIN_ADDR  +
-                                (cfg_lsw * ASC_BIOS_BANK_SIZE));
-        return(bios_addr);
-    }/* if */
+	if ((bus_type & ASC_IS_EISA) != 0) {
+		cfg_lsw = AscGetEisaChipCfg(iop_base);
+		cfg_lsw &= 0x000F;
+		bios_addr = (ushort)(ASC_BIOS_MIN_ADDR +
+				     (cfg_lsw * ASC_BIOS_BANK_SIZE));
+		return (bios_addr);
+	}			/* if */
 #endif /* CONFIG_ISA */
 
-    cfg_lsw = AscGetChipCfgLsw(iop_base);
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
 
-    /*
-    *  ISA PnP uses the top bit as the 32K BIOS flag
-    */
-    if (bus_type == ASC_IS_ISAPNP)
-    {
-        cfg_lsw &= 0x7FFF;
-    }/* if */
-
-    bios_addr = (ushort)(((cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE) +
-            ASC_BIOS_MIN_ADDR);
-    return(bios_addr);
+	/*
+	 *  ISA PnP uses the top bit as the 32K BIOS flag
+	 */
+	if (bus_type == ASC_IS_ISAPNP) {
+		cfg_lsw &= 0x7FFF;
+	}
+	/* if */
+	bios_addr = (ushort)(((cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE) +
+			     ASC_BIOS_MIN_ADDR);
+	return (bios_addr);
 }
 
-
 /*
  * --- Functions Required by the Adv Library
  */
@@ -8801,49 +7599,44 @@ AscGetChipBiosAddress(
  */
 ADV_PADDR
 DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
-        uchar *vaddr, ADV_SDCNT *lenp, int flag)
+	      uchar *vaddr, ADV_SDCNT *lenp, int flag)
 {
-    ADV_PADDR           paddr;
+	ADV_PADDR paddr;
 
-    paddr = virt_to_bus(vaddr);
+	paddr = virt_to_bus(vaddr);
 
-    ASC_DBG4(4,
-        "DvcGetPhyAddr: vaddr 0x%lx, lenp 0x%lx *lenp %lu, paddr 0x%lx\n",
-        (ulong) vaddr, (ulong) lenp, (ulong) *((ulong *) lenp), (ulong) paddr);
+	ASC_DBG4(4,
+		 "DvcGetPhyAddr: vaddr 0x%lx, lenp 0x%lx *lenp %lu, paddr 0x%lx\n",
+		 (ulong)vaddr, (ulong)lenp, (ulong)*((ulong *)lenp),
+		 (ulong)paddr);
 
-    return paddr;
+	return paddr;
 }
 
 /*
  * Read a PCI configuration byte.
  */
-STATIC uchar __init
-DvcAdvReadPCIConfigByte(
-        ADV_DVC_VAR *asc_dvc,
-        ushort offset)
+static uchar __init DvcAdvReadPCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset)
 {
 #ifdef CONFIG_PCI
-    uchar byte_data;
-    pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
-    return byte_data;
+	uchar byte_data;
+	pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
+	return byte_data;
 #else /* CONFIG_PCI */
-    return 0;
+	return 0;
 #endif /* CONFIG_PCI */
 }
 
 /*
  * Write a PCI configuration byte.
  */
-STATIC void __init
-DvcAdvWritePCIConfigByte(
-        ADV_DVC_VAR *asc_dvc,
-        ushort offset,
-        uchar  byte_data)
+static void __init
+DvcAdvWritePCIConfigByte(ADV_DVC_VAR *asc_dvc, ushort offset, uchar byte_data)
 {
 #ifdef CONFIG_PCI
-    pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
+	pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
 #else /* CONFIG_PCI */
-    return;
+	return;
 #endif /* CONFIG_PCI */
 }
 
@@ -8862,97 +7655,98 @@ DvcAdvWritePCIConfigByte(
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_board_stats(struct Scsi_Host *shp, char *cp, int cplen)
+static int asc_prt_board_stats(struct Scsi_Host *shost, char *cp, int cplen)
 {
-    int                    leftlen;
-    int                    totlen;
-    int                    len;
-    struct asc_stats       *s;
-    asc_board_t            *boardp;
-
-    leftlen = cplen;
-    totlen = len = 0;
-
-    boardp = ASC_BOARDP(shp);
-    s = &boardp->asc_stats;
-
-    len = asc_prt_line(cp, leftlen,
-"\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n", shp->host_no);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
-        s->queuecommand, s->reset, s->biosparam, s->interrupt);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
-        s->callback, s->done, s->build_error, s->adv_build_noreq,
-        s->adv_build_nosg);
-    ASC_PRT_NEXT();
-
-    len = asc_prt_line(cp, leftlen,
-" exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
-        s->exe_noerror, s->exe_busy, s->exe_error, s->exe_unknown);
-    ASC_PRT_NEXT();
-
-    /*
-     * Display data transfer statistics.
-     */
-    if (s->cont_cnt > 0) {
-        len = asc_prt_line(cp, leftlen, " cont_cnt %lu, ", s->cont_cnt);
-        ASC_PRT_NEXT();
-
-        len = asc_prt_line(cp, leftlen, "cont_xfer %lu.%01lu kb ",
-                    s->cont_xfer/2,
-                    ASC_TENTHS(s->cont_xfer, 2));
-        ASC_PRT_NEXT();
-
-        /* Contiguous transfer average size */
-        len = asc_prt_line(cp, leftlen, "avg_xfer %lu.%01lu kb\n",
-                    (s->cont_xfer/2)/s->cont_cnt,
-                    ASC_TENTHS((s->cont_xfer/2), s->cont_cnt));
-        ASC_PRT_NEXT();
-    }
+	int leftlen;
+	int totlen;
+	int len;
+	struct asc_stats *s;
+	asc_board_t *boardp;
 
-    if (s->sg_cnt > 0) {
+	leftlen = cplen;
+	totlen = len = 0;
+
+	boardp = ASC_BOARDP(shost);
+	s = &boardp->asc_stats;
+
+	len = asc_prt_line(cp, leftlen,
+			   "\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n",
+			   shost->host_no);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
+			   s->queuecommand, s->reset, s->biosparam,
+			   s->interrupt);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
+			   s->callback, s->done, s->build_error,
+			   s->adv_build_noreq, s->adv_build_nosg);
+	ASC_PRT_NEXT();
+
+	len = asc_prt_line(cp, leftlen,
+			   " exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
+			   s->exe_noerror, s->exe_busy, s->exe_error,
+			   s->exe_unknown);
+	ASC_PRT_NEXT();
+
+	/*
+	 * Display data transfer statistics.
+	 */
+	if (s->cont_cnt > 0) {
+		len = asc_prt_line(cp, leftlen, " cont_cnt %lu, ", s->cont_cnt);
+		ASC_PRT_NEXT();
+
+		len = asc_prt_line(cp, leftlen, "cont_xfer %lu.%01lu kb ",
+				   s->cont_xfer / 2,
+				   ASC_TENTHS(s->cont_xfer, 2));
+		ASC_PRT_NEXT();
+
+		/* Contiguous transfer average size */
+		len = asc_prt_line(cp, leftlen, "avg_xfer %lu.%01lu kb\n",
+				   (s->cont_xfer / 2) / s->cont_cnt,
+				   ASC_TENTHS((s->cont_xfer / 2), s->cont_cnt));
+		ASC_PRT_NEXT();
+	}
 
-        len = asc_prt_line(cp, leftlen, " sg_cnt %lu, sg_elem %lu, ",
-                    s->sg_cnt, s->sg_elem);
-        ASC_PRT_NEXT();
+	if (s->sg_cnt > 0) {
 
-        len = asc_prt_line(cp, leftlen, "sg_xfer %lu.%01lu kb\n",
-                    s->sg_xfer/2,
-                    ASC_TENTHS(s->sg_xfer, 2));
-        ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen, " sg_cnt %lu, sg_elem %lu, ",
+				   s->sg_cnt, s->sg_elem);
+		ASC_PRT_NEXT();
 
-        /* Scatter gather transfer statistics */
-        len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
-                    s->sg_elem/s->sg_cnt,
-                    ASC_TENTHS(s->sg_elem, s->sg_cnt));
-        ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen, "sg_xfer %lu.%01lu kb\n",
+				   s->sg_xfer / 2, ASC_TENTHS(s->sg_xfer, 2));
+		ASC_PRT_NEXT();
 
-        len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
-                    (s->sg_xfer/2)/s->sg_elem,
-                    ASC_TENTHS((s->sg_xfer/2), s->sg_elem));
-        ASC_PRT_NEXT();
+		/* Scatter gather transfer statistics */
+		len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
+				   s->sg_elem / s->sg_cnt,
+				   ASC_TENTHS(s->sg_elem, s->sg_cnt));
+		ASC_PRT_NEXT();
 
-        len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
-                    (s->sg_xfer/2)/s->sg_cnt,
-                    ASC_TENTHS((s->sg_xfer/2), s->sg_cnt));
-        ASC_PRT_NEXT();
-    }
+		len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
+				   (s->sg_xfer / 2) / s->sg_elem,
+				   ASC_TENTHS((s->sg_xfer / 2), s->sg_elem));
+		ASC_PRT_NEXT();
 
-    /*
-     * Display request queuing statistics.
-     */
-    len = asc_prt_line(cp, leftlen,
-" Active and Waiting Request Queues (Time Unit: %d HZ):\n", HZ);
-    ASC_PRT_NEXT();
+		len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
+				   (s->sg_xfer / 2) / s->sg_cnt,
+				   ASC_TENTHS((s->sg_xfer / 2), s->sg_cnt));
+		ASC_PRT_NEXT();
+	}
 
+	/*
+	 * Display request queuing statistics.
+	 */
+	len = asc_prt_line(cp, leftlen,
+			   " Active and Waiting Request Queues (Time Unit: %d HZ):\n",
+			   HZ);
+	ASC_PRT_NEXT();
 
-     return totlen;
+	return totlen;
 }
 
 /*
@@ -8967,70 +7761,89 @@ asc_prt_board_stats(struct Scsi_Host *shp, char *cp, int cplen)
  * Return the number of characters copied into 'cp'. No more than
  * 'cplen' characters will be copied to 'cp'.
  */
-STATIC int
-asc_prt_target_stats(struct Scsi_Host *shp, int tgt_id, char *cp, int cplen)
+static int
+asc_prt_target_stats(struct Scsi_Host *shost, int tgt_id, char *cp, int cplen)
 {
-    int                    leftlen;
-    int                    totlen;
-    int                    len;
-    struct asc_stats       *s;
-    ushort                 chip_scsi_id;
-    asc_board_t            *boardp;
-    asc_queue_t            *active;
-    asc_queue_t            *waiting;
-
-    leftlen = cplen;
-    totlen = len = 0;
-
-    boardp = ASC_BOARDP(shp);
-    s = &boardp->asc_stats;
-
-    active = &ASC_BOARDP(shp)->active;
-    waiting = &ASC_BOARDP(shp)->waiting;
-
-    if (ASC_NARROW_BOARD(boardp)) {
-        chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
-    } else {
-        chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
-    }
+	int leftlen;
+	int totlen;
+	int len;
+	struct asc_stats *s;
+	ushort chip_scsi_id;
+	asc_board_t *boardp;
+	asc_queue_t *active;
+	asc_queue_t *waiting;
 
-    if ((chip_scsi_id == tgt_id) ||
-        ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(tgt_id)) == 0)) {
-        return 0;
-    }
+	leftlen = cplen;
+	totlen = len = 0;
+
+	boardp = ASC_BOARDP(shost);
+	s = &boardp->asc_stats;
+
+	active = &ASC_BOARDP(shost)->active;
+	waiting = &ASC_BOARDP(shost)->waiting;
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+	} else {
+		chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+	}
+
+	if ((chip_scsi_id == tgt_id) ||
+	    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(tgt_id)) == 0)) {
+		return 0;
+	}
 
-    do {
-        if (active->q_tot_cnt[tgt_id] > 0 || waiting->q_tot_cnt[tgt_id] > 0) {
-            len = asc_prt_line(cp, leftlen, " target %d\n", tgt_id);
-            ASC_PRT_NEXT();
-
-            len = asc_prt_line(cp, leftlen,
-"   active: cnt [cur %d, max %d, tot %u], time [min %d, max %d, avg %lu.%01lu]\n",
-                active->q_cur_cnt[tgt_id], active->q_max_cnt[tgt_id],
-                active->q_tot_cnt[tgt_id],
-                active->q_min_tim[tgt_id], active->q_max_tim[tgt_id],
-                (active->q_tot_cnt[tgt_id] == 0) ? 0 :
-                (active->q_tot_tim[tgt_id]/active->q_tot_cnt[tgt_id]),
-                (active->q_tot_cnt[tgt_id] == 0) ? 0 :
-                ASC_TENTHS(active->q_tot_tim[tgt_id],
-                active->q_tot_cnt[tgt_id]));
-             ASC_PRT_NEXT();
-
-             len = asc_prt_line(cp, leftlen,
-"   waiting: cnt [cur %d, max %d, tot %u], time [min %u, max %u, avg %lu.%01lu]\n",
-                waiting->q_cur_cnt[tgt_id], waiting->q_max_cnt[tgt_id],
-                waiting->q_tot_cnt[tgt_id],
-                waiting->q_min_tim[tgt_id], waiting->q_max_tim[tgt_id],
-                (waiting->q_tot_cnt[tgt_id] == 0) ? 0 :
-                (waiting->q_tot_tim[tgt_id]/waiting->q_tot_cnt[tgt_id]),
-                (waiting->q_tot_cnt[tgt_id] == 0) ? 0 :
-                ASC_TENTHS(waiting->q_tot_tim[tgt_id],
-                waiting->q_tot_cnt[tgt_id]));
-             ASC_PRT_NEXT();
-        }
-    } while (0);
-
-     return totlen;
+	do {
+		if (active->q_tot_cnt[tgt_id] > 0
+		    || waiting->q_tot_cnt[tgt_id] > 0) {
+			len = asc_prt_line(cp, leftlen, " target %d\n", tgt_id);
+			ASC_PRT_NEXT();
+
+			len = asc_prt_line(cp, leftlen,
+					   "   active: cnt [cur %d, max %d, tot %u], time [min %d, max %d, avg %lu.%01lu]\n",
+					   active->q_cur_cnt[tgt_id],
+					   active->q_max_cnt[tgt_id],
+					   active->q_tot_cnt[tgt_id],
+					   active->q_min_tim[tgt_id],
+					   active->q_max_tim[tgt_id],
+					   (active->q_tot_cnt[tgt_id] ==
+					    0) ? 0 : (active->
+						      q_tot_tim[tgt_id] /
+						      active->
+						      q_tot_cnt[tgt_id]),
+					   (active->q_tot_cnt[tgt_id] ==
+					    0) ? 0 : ASC_TENTHS(active->
+								q_tot_tim
+								[tgt_id],
+								active->
+								q_tot_cnt
+								[tgt_id]));
+			ASC_PRT_NEXT();
+
+			len = asc_prt_line(cp, leftlen,
+					   "   waiting: cnt [cur %d, max %d, tot %u], time [min %u, max %u, avg %lu.%01lu]\n",
+					   waiting->q_cur_cnt[tgt_id],
+					   waiting->q_max_cnt[tgt_id],
+					   waiting->q_tot_cnt[tgt_id],
+					   waiting->q_min_tim[tgt_id],
+					   waiting->q_max_tim[tgt_id],
+					   (waiting->q_tot_cnt[tgt_id] ==
+					    0) ? 0 : (waiting->
+						      q_tot_tim[tgt_id] /
+						      waiting->
+						      q_tot_cnt[tgt_id]),
+					   (waiting->q_tot_cnt[tgt_id] ==
+					    0) ? 0 : ASC_TENTHS(waiting->
+								q_tot_tim
+								[tgt_id],
+								waiting->
+								q_tot_cnt
+								[tgt_id]));
+			ASC_PRT_NEXT();
+		}
+	} while (0);
+
+	return totlen;
 }
 #endif /* CONFIG_PROC_FS */
 #endif /* ADVANSYS_STATS */
@@ -9039,207 +7852,181 @@ asc_prt_target_stats(struct Scsi_Host *shp, int tgt_id, char *cp, int cplen)
 /*
  * asc_prt_scsi_host()
  */
-STATIC void
-asc_prt_scsi_host(struct Scsi_Host *s)
+static void asc_prt_scsi_host(struct Scsi_Host *s)
 {
-    asc_board_t         *boardp;
-
-    boardp = ASC_BOARDP(s);
-
-    printk("Scsi_Host at addr 0x%lx\n", (ulong) s);
-    printk(
-" host_busy %u, host_no %d, last_reset %d,\n",
-        s->host_busy, s->host_no,
-        (unsigned) s->last_reset);
-
-    printk(
-" base 0x%lx, io_port 0x%lx, n_io_port %u, irq 0x%x,\n",
-        (ulong) s->base, (ulong) s->io_port, s->n_io_port, s->irq);
-
-    printk(
-" dma_channel %d, this_id %d, can_queue %d,\n",
-        s->dma_channel, s->this_id, s->can_queue);
-
-    printk(
-" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
-        s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
-
-    if (ASC_NARROW_BOARD(boardp)) {
-        asc_prt_asc_dvc_var(&ASC_BOARDP(s)->dvc_var.asc_dvc_var);
-        asc_prt_asc_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.asc_dvc_cfg);
-    } else {
-        asc_prt_adv_dvc_var(&ASC_BOARDP(s)->dvc_var.adv_dvc_var);
-        asc_prt_adv_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.adv_dvc_cfg);
-    }
+	asc_board_t *boardp;
+
+	boardp = ASC_BOARDP(s);
+
+	printk("Scsi_Host at addr 0x%lx\n", (ulong)s);
+	printk(" host_busy %u, host_no %d, last_reset %d,\n",
+	       s->host_busy, s->host_no, (unsigned)s->last_reset);
+
+	printk(" base 0x%lx, io_port 0x%lx, n_io_port %u, irq 0x%x,\n",
+	       (ulong)s->base, (ulong)s->io_port, s->n_io_port, s->irq);
+
+	printk(" dma_channel %d, this_id %d, can_queue %d,\n",
+	       s->dma_channel, s->this_id, s->can_queue);
+
+	printk(" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
+	       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		asc_prt_asc_dvc_var(&ASC_BOARDP(s)->dvc_var.asc_dvc_var);
+		asc_prt_asc_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.asc_dvc_cfg);
+	} else {
+		asc_prt_adv_dvc_var(&ASC_BOARDP(s)->dvc_var.adv_dvc_var);
+		asc_prt_adv_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.adv_dvc_cfg);
+	}
 }
 
 /*
  * asc_prt_scsi_cmnd()
  */
-STATIC void
-asc_prt_scsi_cmnd(struct scsi_cmnd *s)
+static void asc_prt_scsi_cmnd(struct scsi_cmnd *s)
 {
-    printk("struct scsi_cmnd at addr 0x%lx\n", (ulong) s);
+	printk("struct scsi_cmnd at addr 0x%lx\n", (ulong)s);
 
-    printk(
-" host 0x%lx, device 0x%lx, target %u, lun %u, channel %u,\n",
-        (ulong) s->device->host, (ulong) s->device, s->device->id, s->device->lun,
-        s->device->channel);
+	printk(" host 0x%lx, device 0x%lx, target %u, lun %u, channel %u,\n",
+	       (ulong)s->device->host, (ulong)s->device, s->device->id,
+	       s->device->lun, s->device->channel);
 
-    asc_prt_hex(" CDB", s->cmnd, s->cmd_len);
+	asc_prt_hex(" CDB", s->cmnd, s->cmd_len);
 
-    printk (
-"sc_data_direction %u, resid %d\n",
-        s->sc_data_direction, s->resid);
+	printk("sc_data_direction %u, resid %d\n",
+	       s->sc_data_direction, s->resid);
 
-    printk(
-" use_sg %u, sglist_len %u\n",
-        s->use_sg, s->sglist_len);
+	printk(" use_sg %u, sglist_len %u\n", s->use_sg, s->sglist_len);
 
-    printk(
-" serial_number 0x%x, retries %d, allowed %d\n",
-        (unsigned) s->serial_number, s->retries, s->allowed);
+	printk(" serial_number 0x%x, retries %d, allowed %d\n",
+	       (unsigned)s->serial_number, s->retries, s->allowed);
 
-    printk(
-" timeout_per_command %d\n",
-        s->timeout_per_command);
+	printk(" timeout_per_command %d\n", s->timeout_per_command);
 
-    printk(
-" scsi_done 0x%lx, done 0x%lx, host_scribble 0x%lx, result 0x%x\n",
-        (ulong) s->scsi_done, (ulong) s->done,
-        (ulong) s->host_scribble, s->result);
+	printk
+	    (" scsi_done 0x%lx, done 0x%lx, host_scribble 0x%lx, result 0x%x\n",
+	     (ulong)s->scsi_done, (ulong)s->done, (ulong)s->host_scribble,
+	     s->result);
 
-    printk(
-" tag %u, pid %u\n",
-        (unsigned) s->tag, (unsigned) s->pid);
+	printk(" tag %u, pid %u\n", (unsigned)s->tag, (unsigned)s->pid);
 }
 
 /*
  * asc_prt_asc_dvc_var()
  */
-STATIC void
-asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
+static void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
 {
-    printk("ASC_DVC_VAR at addr 0x%lx\n", (ulong) h);
-
-    printk(
-" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl %d,\n",
-        h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
-
-    printk(
-" bus_type %d, isr_callback 0x%lx, exe_callback 0x%lx, init_sdtr 0x%x,\n",
-        h->bus_type, (ulong) h->isr_callback, (ulong) h->exe_callback,
-        (unsigned) h->init_sdtr);
-
-    printk(
-" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, chip_no 0x%x,\n",
-        (unsigned) h->sdtr_done, (unsigned) h->use_tagged_qng,
-        (unsigned) h->unit_not_ready, (unsigned) h->chip_no);
-
-    printk(
-" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait %u,\n",
-        (unsigned) h->queue_full_or_busy, (unsigned) h->start_motor,
-        (unsigned) h->scsi_reset_wait);
-
-    printk(
-" is_in_int %u, max_total_qng %u, cur_total_qng %u, in_critical_cnt %u,\n",
-        (unsigned) h->is_in_int, (unsigned) h->max_total_qng,
-        (unsigned) h->cur_total_qng, (unsigned) h->in_critical_cnt);
-
-    printk(
-" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, pci_fix_asyn_xfer 0x%x,\n",
-        (unsigned) h->last_q_shortage, (unsigned) h->init_state,
-        (unsigned) h->no_scam, (unsigned) h->pci_fix_asyn_xfer);
-
-    printk(
-" cfg 0x%lx, irq_no 0x%x\n",
-        (ulong) h->cfg, (unsigned) h->irq_no);
+	printk("ASC_DVC_VAR at addr 0x%lx\n", (ulong)h);
+
+	printk
+	    (" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl %d,\n",
+	     h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
+
+	printk
+	    (" bus_type %d, isr_callback 0x%lx, exe_callback 0x%lx, init_sdtr 0x%x,\n",
+	     h->bus_type, (ulong)h->isr_callback, (ulong)h->exe_callback,
+	     (unsigned)h->init_sdtr);
+
+	printk
+	    (" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, chip_no 0x%x,\n",
+	     (unsigned)h->sdtr_done, (unsigned)h->use_tagged_qng,
+	     (unsigned)h->unit_not_ready, (unsigned)h->chip_no);
+
+	printk
+	    (" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait %u,\n",
+	     (unsigned)h->queue_full_or_busy, (unsigned)h->start_motor,
+	     (unsigned)h->scsi_reset_wait);
+
+	printk
+	    (" is_in_int %u, max_total_qng %u, cur_total_qng %u, in_critical_cnt %u,\n",
+	     (unsigned)h->is_in_int, (unsigned)h->max_total_qng,
+	     (unsigned)h->cur_total_qng, (unsigned)h->in_critical_cnt);
+
+	printk
+	    (" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, pci_fix_asyn_xfer 0x%x,\n",
+	     (unsigned)h->last_q_shortage, (unsigned)h->init_state,
+	     (unsigned)h->no_scam, (unsigned)h->pci_fix_asyn_xfer);
+
+	printk(" cfg 0x%lx, irq_no 0x%x\n", (ulong)h->cfg, (unsigned)h->irq_no);
 }
 
 /*
  * asc_prt_asc_dvc_cfg()
  */
-STATIC void
-asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
+static void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
 {
-    printk("ASC_DVC_CFG at addr 0x%lx\n", (ulong) h);
-
-    printk(
-" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\n",
-            h->can_tagged_qng, h->cmd_qng_enabled);
-    printk(
-" disc_enable 0x%x, sdtr_enable 0x%x,\n",
-            h->disc_enable, h->sdtr_enable);
-
-    printk(
-" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, chip_version %d,\n",
-             h->chip_scsi_id, h->isa_dma_speed, h->isa_dma_channel,
-             h->chip_version);
-
-    printk(
-" pci_device_id %d, lib_serial_no %u, lib_version %u, mcode_date 0x%x,\n",
-	   to_pci_dev(h->dev)->device, h->lib_serial_no, h->lib_version,
-	   h->mcode_date);
-
-    printk(
-" mcode_version %d, overrun_buf 0x%lx\n",
-            h->mcode_version, (ulong) h->overrun_buf);
+	printk("ASC_DVC_CFG at addr 0x%lx\n", (ulong)h);
+
+	printk(" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\n",
+	       h->can_tagged_qng, h->cmd_qng_enabled);
+	printk(" disc_enable 0x%x, sdtr_enable 0x%x,\n",
+	       h->disc_enable, h->sdtr_enable);
+
+	printk
+	    (" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, chip_version %d,\n",
+	     h->chip_scsi_id, h->isa_dma_speed, h->isa_dma_channel,
+	     h->chip_version);
+
+	printk
+	    (" pci_device_id %d, lib_serial_no %u, lib_version %u, mcode_date 0x%x,\n",
+	     to_pci_dev(h->dev)->device, h->lib_serial_no, h->lib_version,
+	     h->mcode_date);
+
+	printk(" mcode_version %d, overrun_buf 0x%lx\n",
+	       h->mcode_version, (ulong)h->overrun_buf);
 }
 
 /*
  * asc_prt_asc_scsi_q()
  */
-STATIC void
-asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
+static void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
 {
-    ASC_SG_HEAD    *sgp;
-    int i;
-
-    printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong) q);
-
-    printk(
-" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
-            q->q2.target_ix, q->q1.target_lun,
-            (ulong) q->q2.srb_ptr, q->q2.tag_code);
-
-    printk(
-" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
-            (ulong) le32_to_cpu(q->q1.data_addr),
-            (ulong) le32_to_cpu(q->q1.data_cnt),
-            (ulong) le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
-
-    printk(
-" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
-            (ulong) q->cdbptr, q->q2.cdb_len,
-            (ulong) q->sg_head, q->q1.sg_queue_cnt);
-
-    if (q->sg_head) {
-        sgp = q->sg_head;
-        printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong) sgp);
-        printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt, sgp->queue_cnt);
-        for (i = 0; i < sgp->entry_cnt; i++) {
-            printk(" [%u]: addr 0x%lx, bytes %lu\n",
-                i, (ulong) le32_to_cpu(sgp->sg_list[i].addr),
-                (ulong) le32_to_cpu(sgp->sg_list[i].bytes));
-        }
+	ASC_SG_HEAD *sgp;
+	int i;
+
+	printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong)q);
+
+	printk
+	    (" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
+	     q->q2.target_ix, q->q1.target_lun, (ulong)q->q2.srb_ptr,
+	     q->q2.tag_code);
+
+	printk
+	    (" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+	     (ulong)le32_to_cpu(q->q1.data_addr),
+	     (ulong)le32_to_cpu(q->q1.data_cnt),
+	     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
+
+	printk(" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
+	       (ulong)q->cdbptr, q->q2.cdb_len,
+	       (ulong)q->sg_head, q->q1.sg_queue_cnt);
+
+	if (q->sg_head) {
+		sgp = q->sg_head;
+		printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong)sgp);
+		printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt,
+		       sgp->queue_cnt);
+		for (i = 0; i < sgp->entry_cnt; i++) {
+			printk(" [%u]: addr 0x%lx, bytes %lu\n",
+			       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),
+			       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));
+		}
 
-    }
+	}
 }
 
 /*
  * asc_prt_asc_qdone_info()
  */
-STATIC void
-asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
+static void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
 {
-    printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong) q);
-    printk(
-" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
-            (ulong) q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
-            q->d2.tag_code);
-    printk(
-" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
-            q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
+	printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong)q);
+	printk(" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
+	       (ulong)q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
+	       q->d2.tag_code);
+	printk
+	    (" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
+	     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
 }
 
 /*
@@ -9247,41 +8034,33 @@ asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
  *
  * Display an ADV_DVC_VAR structure.
  */
-STATIC void
-asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
+static void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
 {
-    printk(" ADV_DVC_VAR at addr 0x%lx\n", (ulong) h);
-
-    printk(
-"  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",
-        (ulong) h->iop_base, h->err_code, (unsigned) h->ultra_able);
-
-    printk(
-"  isr_callback 0x%lx, sdtr_able 0x%x, wdtr_able 0x%x\n",
-        (ulong) h->isr_callback, (unsigned) h->sdtr_able,
-        (unsigned) h->wdtr_able);
-
-    printk(
-"  start_motor 0x%x, scsi_reset_wait 0x%x, irq_no 0x%x,\n",
-        (unsigned) h->start_motor,
-        (unsigned) h->scsi_reset_wait, (unsigned) h->irq_no);
-
-    printk(
-"  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
-        (unsigned) h->max_host_qng, (unsigned) h->max_dvc_qng,
-        (ulong) h->carr_freelist);
-
-    printk(
-"  icq_sp 0x%lx, irq_sp 0x%lx\n",
-        (ulong) h->icq_sp, (ulong) h->irq_sp);
-
-    printk(
-"  no_scam 0x%x, tagqng_able 0x%x\n",
-        (unsigned) h->no_scam, (unsigned) h->tagqng_able);
-
-    printk(
-"  chip_scsi_id 0x%x, cfg 0x%lx\n",
-        (unsigned) h->chip_scsi_id, (ulong) h->cfg);
+	printk(" ADV_DVC_VAR at addr 0x%lx\n", (ulong)h);
+
+	printk("  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",
+	       (ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);
+
+	printk("  isr_callback 0x%lx, sdtr_able 0x%x, wdtr_able 0x%x\n",
+	       (ulong)h->isr_callback, (unsigned)h->sdtr_able,
+	       (unsigned)h->wdtr_able);
+
+	printk("  start_motor 0x%x, scsi_reset_wait 0x%x, irq_no 0x%x,\n",
+	       (unsigned)h->start_motor,
+	       (unsigned)h->scsi_reset_wait, (unsigned)h->irq_no);
+
+	printk("  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
+	       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,
+	       (ulong)h->carr_freelist);
+
+	printk("  icq_sp 0x%lx, irq_sp 0x%lx\n",
+	       (ulong)h->icq_sp, (ulong)h->irq_sp);
+
+	printk("  no_scam 0x%x, tagqng_able 0x%x\n",
+	       (unsigned)h->no_scam, (unsigned)h->tagqng_able);
+
+	printk("  chip_scsi_id 0x%x, cfg 0x%lx\n",
+	       (unsigned)h->chip_scsi_id, (ulong)h->cfg);
 }
 
 /*
@@ -9289,26 +8068,21 @@ asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
  *
  * Display an ADV_DVC_CFG structure.
  */
-STATIC void
-asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
+static void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
 {
-    printk(" ADV_DVC_CFG at addr 0x%lx\n", (ulong) h);
+	printk(" ADV_DVC_CFG at addr 0x%lx\n", (ulong)h);
 
-    printk(
-"  disc_enable 0x%x, termination 0x%x\n",
-        h->disc_enable, h->termination);
+	printk("  disc_enable 0x%x, termination 0x%x\n",
+	       h->disc_enable, h->termination);
 
-    printk(
-"  chip_version 0x%x, mcode_date 0x%x\n",
-        h->chip_version, h->mcode_date);
+	printk("  chip_version 0x%x, mcode_date 0x%x\n",
+	       h->chip_version, h->mcode_date);
 
-    printk(
-"  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
-       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
+	printk("  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
+	       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
 
-    printk(
-"  control_flag 0x%x, pci_slot_info 0x%x\n",
-       h->control_flag, h->pci_slot_info);
+	printk("  control_flag 0x%x, pci_slot_info 0x%x\n",
+	       h->control_flag, h->pci_slot_info);
 }
 
 /*
@@ -9316,60 +8090,54 @@ asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
  *
  * Display an ADV_SCSI_REQ_Q structure.
  */
-STATIC void
-asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
+static void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
 {
-    int                 sg_blk_cnt;
-    struct asc_sg_block *sg_ptr;
-
-    printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong) q);
-
-    printk(
-"  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
-            q->target_id, q->target_lun, (ulong) q->srb_ptr, q->a_flag);
-
-    printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
-            q->cntl, (ulong) le32_to_cpu(q->data_addr), (ulong) q->vdata_addr);
-
-    printk(
-"  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
-            (ulong) le32_to_cpu(q->data_cnt),
-            (ulong) le32_to_cpu(q->sense_addr), q->sense_len);
-
-    printk(
-"  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
-            q->cdb_len, q->done_status, q->host_status, q->scsi_status);
-
-    printk(
-"  sg_working_ix 0x%x, target_cmd %u\n",
-            q->sg_working_ix, q->target_cmd);
-
-    printk(
-"  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
-            (ulong) le32_to_cpu(q->scsiq_rptr),
-            (ulong) le32_to_cpu(q->sg_real_addr), (ulong) q->sg_list_ptr);
-
-    /* Display the request's ADV_SG_BLOCK structures. */
-    if (q->sg_list_ptr != NULL)
-    {
-        sg_blk_cnt = 0;
-        while (1) {
-            /*
-             * 'sg_ptr' is a physical address. Convert it to a virtual
-             * address by indexing 'sg_blk_cnt' into the virtual address
-             * array 'sg_list_ptr'.
-             *
-             * XXX - Assumes all SG physical blocks are virtually contiguous.
-             */
-            sg_ptr = &(((ADV_SG_BLOCK *) (q->sg_list_ptr))[sg_blk_cnt]);
-            asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
-            if (sg_ptr->sg_ptr == 0)
-            {
-                break;
-            }
-            sg_blk_cnt++;
-        }
-    }
+	int sg_blk_cnt;
+	struct asc_sg_block *sg_ptr;
+
+	printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong)q);
+
+	printk("  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
+	       q->target_id, q->target_lun, (ulong)q->srb_ptr, q->a_flag);
+
+	printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
+	       q->cntl, (ulong)le32_to_cpu(q->data_addr), (ulong)q->vdata_addr);
+
+	printk("  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+	       (ulong)le32_to_cpu(q->data_cnt),
+	       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);
+
+	printk
+	    ("  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
+	     q->cdb_len, q->done_status, q->host_status, q->scsi_status);
+
+	printk("  sg_working_ix 0x%x, target_cmd %u\n",
+	       q->sg_working_ix, q->target_cmd);
+
+	printk("  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
+	       (ulong)le32_to_cpu(q->scsiq_rptr),
+	       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);
+
+	/* Display the request's ADV_SG_BLOCK structures. */
+	if (q->sg_list_ptr != NULL) {
+		sg_blk_cnt = 0;
+		while (1) {
+			/*
+			 * 'sg_ptr' is a physical address. Convert it to a virtual
+			 * address by indexing 'sg_blk_cnt' into the virtual address
+			 * array 'sg_list_ptr'.
+			 *
+			 * XXX - Assumes all SG physical blocks are virtually contiguous.
+			 */
+			sg_ptr =
+			    &(((ADV_SG_BLOCK *)(q->sg_list_ptr))[sg_blk_cnt]);
+			asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
+			if (sg_ptr->sg_ptr == 0) {
+				break;
+			}
+			sg_blk_cnt++;
+		}
+	}
 }
 
 /*
@@ -9377,24 +8145,23 @@ asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
  *
  * Display an ADV_SG_BLOCK structure.
  */
-STATIC void
-asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
+static void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
 {
-    int i;
-
-    printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
-        (ulong) b, sgblockno);
-    printk("  sg_cnt %u, sg_ptr 0x%lx\n",
-        b->sg_cnt, (ulong) le32_to_cpu(b->sg_ptr));
-    ASC_ASSERT(b->sg_cnt <= NO_OF_SG_PER_BLOCK);
-    if (b->sg_ptr != 0)
-    {
-        ASC_ASSERT(b->sg_cnt == NO_OF_SG_PER_BLOCK);
-    }
-    for (i = 0; i < b->sg_cnt; i++) {
-        printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
-            i, (ulong) b->sg_list[i].sg_addr, (ulong) b->sg_list[i].sg_count);
-    }
+	int i;
+
+	printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
+	       (ulong)b, sgblockno);
+	printk("  sg_cnt %u, sg_ptr 0x%lx\n",
+	       b->sg_cnt, (ulong)le32_to_cpu(b->sg_ptr));
+	ASC_ASSERT(b->sg_cnt <= NO_OF_SG_PER_BLOCK);
+	if (b->sg_ptr != 0) {
+		ASC_ASSERT(b->sg_cnt == NO_OF_SG_PER_BLOCK);
+	}
+	for (i = 0; i < b->sg_cnt; i++) {
+		printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
+		       i, (ulong)b->sg_list[i].sg_addr,
+		       (ulong)b->sg_list[i].sg_count);
+	}
 }
 
 /*
@@ -9403,55 +8170,55 @@ asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
  * Print hexadecimal output in 4 byte groupings 32 bytes
  * or 8 double-words per line.
  */
-STATIC void
-asc_prt_hex(char *f, uchar *s, int l)
+static void asc_prt_hex(char *f, uchar *s, int l)
 {
-    int            i;
-    int            j;
-    int            k;
-    int            m;
-
-    printk("%s: (%d bytes)\n", f, l);
-
-    for (i = 0; i < l; i += 32) {
-
-        /* Display a maximum of 8 double-words per line. */
-        if ((k = (l - i) / 4) >= 8) {
-            k = 8;
-            m = 0;
-        } else {
-            m = (l - i) % 4;
-        }
-
-        for (j = 0; j < k; j++) {
-            printk(" %2.2X%2.2X%2.2X%2.2X",
-                (unsigned) s[i+(j*4)], (unsigned) s[i+(j*4)+1],
-                (unsigned) s[i+(j*4)+2], (unsigned) s[i+(j*4)+3]);
-        }
-
-        switch (m) {
-        case 0:
-        default:
-            break;
-        case 1:
-            printk(" %2.2X",
-                (unsigned) s[i+(j*4)]);
-            break;
-        case 2:
-            printk(" %2.2X%2.2X",
-                (unsigned) s[i+(j*4)],
-                (unsigned) s[i+(j*4)+1]);
-            break;
-        case 3:
-            printk(" %2.2X%2.2X%2.2X",
-                (unsigned) s[i+(j*4)+1],
-                (unsigned) s[i+(j*4)+2],
-                (unsigned) s[i+(j*4)+3]);
-            break;
-        }
-
-        printk("\n");
-    }
+	int i;
+	int j;
+	int k;
+	int m;
+
+	printk("%s: (%d bytes)\n", f, l);
+
+	for (i = 0; i < l; i += 32) {
+
+		/* Display a maximum of 8 double-words per line. */
+		if ((k = (l - i) / 4) >= 8) {
+			k = 8;
+			m = 0;
+		} else {
+			m = (l - i) % 4;
+		}
+
+		for (j = 0; j < k; j++) {
+			printk(" %2.2X%2.2X%2.2X%2.2X",
+			       (unsigned)s[i + (j * 4)],
+			       (unsigned)s[i + (j * 4) + 1],
+			       (unsigned)s[i + (j * 4) + 2],
+			       (unsigned)s[i + (j * 4) + 3]);
+		}
+
+		switch (m) {
+		case 0:
+		default:
+			break;
+		case 1:
+			printk(" %2.2X", (unsigned)s[i + (j * 4)]);
+			break;
+		case 2:
+			printk(" %2.2X%2.2X",
+			       (unsigned)s[i + (j * 4)],
+			       (unsigned)s[i + (j * 4) + 1]);
+			break;
+		case 3:
+			printk(" %2.2X%2.2X%2.2X",
+			       (unsigned)s[i + (j * 4) + 1],
+			       (unsigned)s[i + (j * 4) + 2],
+			       (unsigned)s[i + (j * 4) + 3]);
+			break;
+		}
+
+		printk("\n");
+	}
 }
 #endif /* ADVANSYS_DEBUG */
 
@@ -9459,3380 +8226,3400 @@ asc_prt_hex(char *f, uchar *s, int l)
  * --- Asc Library Functions
  */
 
-STATIC ushort __init
-AscGetEisaChipCfg(
-                     PortAddr iop_base)
+static ushort __init AscGetEisaChipCfg(PortAddr iop_base)
 {
-    PortAddr            eisa_cfg_iop;
+	PortAddr eisa_cfg_iop;
 
-    eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
-      (PortAddr) (ASC_EISA_CFG_IOP_MASK);
-    return (inpw(eisa_cfg_iop));
+	eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
+	    (PortAddr) (ASC_EISA_CFG_IOP_MASK);
+	return (inpw(eisa_cfg_iop));
 }
 
-STATIC uchar __init
-AscSetChipScsiID(
-                    PortAddr iop_base,
-                    uchar new_host_id
-)
+static uchar __init AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)
 {
-    ushort              cfg_lsw;
+	ushort cfg_lsw;
 
-    if (AscGetChipScsiID(iop_base) == new_host_id) {
-        return (new_host_id);
-    }
-    cfg_lsw = AscGetChipCfgLsw(iop_base);
-    cfg_lsw &= 0xF8FF;
-    cfg_lsw |= (ushort) ((new_host_id & ASC_MAX_TID) << 8);
-    AscSetChipCfgLsw(iop_base, cfg_lsw);
-    return (AscGetChipScsiID(iop_base));
+	if (AscGetChipScsiID(iop_base) == new_host_id) {
+		return (new_host_id);
+	}
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
+	cfg_lsw &= 0xF8FF;
+	cfg_lsw |= (ushort)((new_host_id & ASC_MAX_TID) << 8);
+	AscSetChipCfgLsw(iop_base, cfg_lsw);
+	return (AscGetChipScsiID(iop_base));
 }
 
-STATIC uchar __init
-AscGetChipScsiCtrl(
-		PortAddr iop_base)
+static uchar __init AscGetChipScsiCtrl(PortAddr iop_base)
 {
-    uchar               sc;
+	uchar sc;
 
-    AscSetBank(iop_base, 1);
-    sc = inp(iop_base + IOP_REG_SC);
-    AscSetBank(iop_base, 0);
-    return (sc);
+	AscSetBank(iop_base, 1);
+	sc = inp(iop_base + IOP_REG_SC);
+	AscSetBank(iop_base, 0);
+	return (sc);
 }
 
-STATIC uchar __init
-AscGetChipVersion(
-                     PortAddr iop_base,
-                     ushort bus_type
-)
+static uchar __init AscGetChipVersion(PortAddr iop_base, ushort bus_type)
 {
-    if ((bus_type & ASC_IS_EISA) != 0) {
-        PortAddr            eisa_iop;
-        uchar               revision;
-        eisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
-          (PortAddr) ASC_EISA_REV_IOP_MASK;
-        revision = inp(eisa_iop);
-        return ((uchar) ((ASC_CHIP_MIN_VER_EISA - 1) + revision));
-    }
-    return (AscGetChipVerNo(iop_base));
+	if ((bus_type & ASC_IS_EISA) != 0) {
+		PortAddr eisa_iop;
+		uchar revision;
+		eisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
+		    (PortAddr) ASC_EISA_REV_IOP_MASK;
+		revision = inp(eisa_iop);
+		return ((uchar)((ASC_CHIP_MIN_VER_EISA - 1) + revision));
+	}
+	return (AscGetChipVerNo(iop_base));
 }
 
-STATIC ushort __init
-AscGetChipBusType(
-                     PortAddr iop_base)
+static ushort __init AscGetChipBusType(PortAddr iop_base)
 {
-    ushort              chip_ver;
-
-    chip_ver = AscGetChipVerNo(iop_base);
-    if (
-           (chip_ver >= ASC_CHIP_MIN_VER_VL)
-           && (chip_ver <= ASC_CHIP_MAX_VER_VL)
-) {
-        if (
-               ((iop_base & 0x0C30) == 0x0C30)
-               || ((iop_base & 0x0C50) == 0x0C50)
-) {
-            return (ASC_IS_EISA);
-        }
-        return (ASC_IS_VL);
-    }
-    if ((chip_ver >= ASC_CHIP_MIN_VER_ISA) &&
-        (chip_ver <= ASC_CHIP_MAX_VER_ISA)) {
-        if (chip_ver >= ASC_CHIP_MIN_VER_ISA_PNP) {
-            return (ASC_IS_ISAPNP);
-        }
-        return (ASC_IS_ISA);
-    } else if ((chip_ver >= ASC_CHIP_MIN_VER_PCI) &&
-               (chip_ver <= ASC_CHIP_MAX_VER_PCI)) {
-        return (ASC_IS_PCI);
-    }
-    return (0);
+	ushort chip_ver;
+
+	chip_ver = AscGetChipVerNo(iop_base);
+	if ((chip_ver >= ASC_CHIP_MIN_VER_VL)
+	    && (chip_ver <= ASC_CHIP_MAX_VER_VL)
+	    ) {
+		if (((iop_base & 0x0C30) == 0x0C30)
+		    || ((iop_base & 0x0C50) == 0x0C50)
+		    ) {
+			return (ASC_IS_EISA);
+		}
+		return (ASC_IS_VL);
+	}
+	if ((chip_ver >= ASC_CHIP_MIN_VER_ISA) &&
+	    (chip_ver <= ASC_CHIP_MAX_VER_ISA)) {
+		if (chip_ver >= ASC_CHIP_MIN_VER_ISA_PNP) {
+			return (ASC_IS_ISAPNP);
+		}
+		return (ASC_IS_ISA);
+	} else if ((chip_ver >= ASC_CHIP_MIN_VER_PCI) &&
+		   (chip_ver <= ASC_CHIP_MAX_VER_PCI)) {
+		return (ASC_IS_PCI);
+	}
+	return (0);
 }
 
-STATIC ASC_DCNT
-AscLoadMicroCode(
-                    PortAddr iop_base,
-                    ushort s_addr,
-                    uchar *mcode_buf,
-                    ushort mcode_size
-)
+static ASC_DCNT
+AscLoadMicroCode(PortAddr iop_base,
+		 ushort s_addr, uchar *mcode_buf, ushort mcode_size)
 {
-    ASC_DCNT            chksum;
-    ushort              mcode_word_size;
-    ushort              mcode_chksum;
-
-    /* Write the microcode buffer starting at LRAM address 0. */
-    mcode_word_size = (ushort) (mcode_size >> 1);
-    AscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);
-    AscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);
-
-    chksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);
-    ASC_DBG1(1, "AscLoadMicroCode: chksum 0x%lx\n", (ulong) chksum);
-    mcode_chksum = (ushort) AscMemSumLramWord(iop_base,
-          (ushort) ASC_CODE_SEC_BEG,
-          (ushort) ((mcode_size - s_addr - (ushort) ASC_CODE_SEC_BEG) / 2));
-    ASC_DBG1(1, "AscLoadMicroCode: mcode_chksum 0x%lx\n",
-        (ulong) mcode_chksum);
-    AscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);
-    AscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);
-    return (chksum);
+	ASC_DCNT chksum;
+	ushort mcode_word_size;
+	ushort mcode_chksum;
+
+	/* Write the microcode buffer starting at LRAM address 0. */
+	mcode_word_size = (ushort)(mcode_size >> 1);
+	AscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);
+	AscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);
+
+	chksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);
+	ASC_DBG1(1, "AscLoadMicroCode: chksum 0x%lx\n", (ulong)chksum);
+	mcode_chksum = (ushort)AscMemSumLramWord(iop_base,
+						 (ushort)ASC_CODE_SEC_BEG,
+						 (ushort)((mcode_size -
+							   s_addr - (ushort)
+							   ASC_CODE_SEC_BEG) /
+							  2));
+	ASC_DBG1(1, "AscLoadMicroCode: mcode_chksum 0x%lx\n",
+		 (ulong)mcode_chksum);
+	AscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);
+	AscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);
+	return (chksum);
 }
 
-STATIC int
-AscFindSignature(
-                    PortAddr iop_base
-)
+static int AscFindSignature(PortAddr iop_base)
 {
-    ushort              sig_word;
-
-    ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureByte(0x%x) 0x%x\n",
-        iop_base, AscGetChipSignatureByte(iop_base));
-    if (AscGetChipSignatureByte(iop_base) == (uchar) ASC_1000_ID1B) {
-        ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureWord(0x%x) 0x%x\n",
-            iop_base, AscGetChipSignatureWord(iop_base));
-        sig_word = AscGetChipSignatureWord(iop_base);
-        if ((sig_word == (ushort) ASC_1000_ID0W) ||
-            (sig_word == (ushort) ASC_1000_ID0W_FIX)) {
-            return (1);
-        }
-    }
-    return (0);
+	ushort sig_word;
+
+	ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureByte(0x%x) 0x%x\n",
+		 iop_base, AscGetChipSignatureByte(iop_base));
+	if (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {
+		ASC_DBG2(1,
+			 "AscFindSignature: AscGetChipSignatureWord(0x%x) 0x%x\n",
+			 iop_base, AscGetChipSignatureWord(iop_base));
+		sig_word = AscGetChipSignatureWord(iop_base);
+		if ((sig_word == (ushort)ASC_1000_ID0W) ||
+		    (sig_word == (ushort)ASC_1000_ID0W_FIX)) {
+			return (1);
+		}
+	}
+	return (0);
 }
 
-STATIC PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __initdata =
-{
-    0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
-    ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
+static PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __initdata = {
+	0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
+	ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
 };
 
 #ifdef CONFIG_ISA
-STATIC uchar _isa_pnp_inited __initdata = 0;
+static uchar _isa_pnp_inited __initdata = 0;
 
-STATIC PortAddr __init
-AscSearchIOPortAddr(
-                       PortAddr iop_beg,
-                       ushort bus_type)
+static PortAddr __init AscSearchIOPortAddr(PortAddr iop_beg, ushort bus_type)
 {
-    if (bus_type & ASC_IS_VL) {
-        while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
-            if (AscGetChipVersion(iop_beg, bus_type) <= ASC_CHIP_MAX_VER_VL) {
-                return (iop_beg);
-            }
-        }
-        return (0);
-    }
-    if (bus_type & ASC_IS_ISA) {
-        if (_isa_pnp_inited == 0) {
-            AscSetISAPNPWaitForKey();
-            _isa_pnp_inited++;
-        }
-        while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
-            if ((AscGetChipVersion(iop_beg, bus_type) & ASC_CHIP_VER_ISA_BIT) != 0) {
-                return (iop_beg);
-            }
-        }
-        return (0);
-    }
-    if (bus_type & ASC_IS_EISA) {
-        if ((iop_beg = AscSearchIOPortAddrEISA(iop_beg)) != 0) {
-            return (iop_beg);
-        }
-        return (0);
-    }
-    return (0);
+	if (bus_type & ASC_IS_VL) {
+		while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
+			if (AscGetChipVersion(iop_beg, bus_type) <=
+			    ASC_CHIP_MAX_VER_VL) {
+				return (iop_beg);
+			}
+		}
+		return (0);
+	}
+	if (bus_type & ASC_IS_ISA) {
+		if (_isa_pnp_inited == 0) {
+			AscSetISAPNPWaitForKey();
+			_isa_pnp_inited++;
+		}
+		while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
+			if ((AscGetChipVersion(iop_beg, bus_type) &
+			     ASC_CHIP_VER_ISA_BIT) != 0) {
+				return (iop_beg);
+			}
+		}
+		return (0);
+	}
+	if (bus_type & ASC_IS_EISA) {
+		if ((iop_beg = AscSearchIOPortAddrEISA(iop_beg)) != 0) {
+			return (iop_beg);
+		}
+		return (0);
+	}
+	return (0);
 }
 
-STATIC PortAddr __init
-AscSearchIOPortAddr11(
-                         PortAddr s_addr
-)
+static PortAddr __init AscSearchIOPortAddr11(PortAddr s_addr)
 {
-    int                 i;
-    PortAddr            iop_base;
+	int i;
+	PortAddr iop_base;
 
-    for (i = 0; i < ASC_IOADR_TABLE_MAX_IX; i++) {
-        if (_asc_def_iop_base[i] > s_addr) {
-            break;
-        }
-    }
-    for (; i < ASC_IOADR_TABLE_MAX_IX; i++) {
-        iop_base = _asc_def_iop_base[i];
-	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")){
-            ASC_DBG1(1,
-               "AscSearchIOPortAddr11: check_region() failed I/O port 0x%x\n",
-                     iop_base);
-            continue;
-        }
-        ASC_DBG1(1, "AscSearchIOPortAddr11: probing I/O port 0x%x\n", iop_base);
-	release_region(iop_base, ASC_IOADR_GAP);
-        if (AscFindSignature(iop_base)) {
-            return (iop_base);
-        }
-    }
-    return (0);
+	for (i = 0; i < ASC_IOADR_TABLE_MAX_IX; i++) {
+		if (_asc_def_iop_base[i] > s_addr) {
+			break;
+		}
+	}
+	for (; i < ASC_IOADR_TABLE_MAX_IX; i++) {
+		iop_base = _asc_def_iop_base[i];
+		if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")) {
+			ASC_DBG1(1,
+				 "AscSearchIOPortAddr11: check_region() failed I/O port 0x%x\n",
+				 iop_base);
+			continue;
+		}
+		ASC_DBG1(1, "AscSearchIOPortAddr11: probing I/O port 0x%x\n",
+			 iop_base);
+		release_region(iop_base, ASC_IOADR_GAP);
+		if (AscFindSignature(iop_base)) {
+			return (iop_base);
+		}
+	}
+	return (0);
 }
 
-STATIC void __init
-AscSetISAPNPWaitForKey(void)
+static void __init AscSetISAPNPWaitForKey(void)
 {
-    outp(ASC_ISA_PNP_PORT_ADDR, 0x02);
-    outp(ASC_ISA_PNP_PORT_WRITE, 0x02);
-    return;
+	outp(ASC_ISA_PNP_PORT_ADDR, 0x02);
+	outp(ASC_ISA_PNP_PORT_WRITE, 0x02);
+	return;
 }
 #endif /* CONFIG_ISA */
 
-STATIC void __init
-AscToggleIRQAct(
-                   PortAddr iop_base
-)
+static void __init AscToggleIRQAct(PortAddr iop_base)
 {
-    AscSetChipStatus(iop_base, CIW_IRQ_ACT);
-    AscSetChipStatus(iop_base, 0);
-    return;
+	AscSetChipStatus(iop_base, CIW_IRQ_ACT);
+	AscSetChipStatus(iop_base, 0);
+	return;
 }
 
-STATIC uchar __init
-AscGetChipIRQ(
-                 PortAddr iop_base,
-                 ushort bus_type)
+static uchar __init AscGetChipIRQ(PortAddr iop_base, ushort bus_type)
 {
-    ushort              cfg_lsw;
-    uchar               chip_irq;
-
-    if ((bus_type & ASC_IS_EISA) != 0) {
-        cfg_lsw = AscGetEisaChipCfg(iop_base);
-        chip_irq = (uchar) (((cfg_lsw >> 8) & 0x07) + 10);
-        if ((chip_irq == 13) || (chip_irq > 15)) {
-            return (0);
-        }
-        return (chip_irq);
-    }
-    if ((bus_type & ASC_IS_VL) != 0) {
-        cfg_lsw = AscGetChipCfgLsw(iop_base);
-        chip_irq = (uchar) (((cfg_lsw >> 2) & 0x07));
-        if ((chip_irq == 0) ||
-            (chip_irq == 4) ||
-            (chip_irq == 7)) {
-            return (0);
-        }
-        return ((uchar) (chip_irq + (ASC_MIN_IRQ_NO - 1)));
-    }
-    cfg_lsw = AscGetChipCfgLsw(iop_base);
-    chip_irq = (uchar) (((cfg_lsw >> 2) & 0x03));
-    if (chip_irq == 3)
-        chip_irq += (uchar) 2;
-    return ((uchar) (chip_irq + ASC_MIN_IRQ_NO));
+	ushort cfg_lsw;
+	uchar chip_irq;
+
+	if ((bus_type & ASC_IS_EISA) != 0) {
+		cfg_lsw = AscGetEisaChipCfg(iop_base);
+		chip_irq = (uchar)(((cfg_lsw >> 8) & 0x07) + 10);
+		if ((chip_irq == 13) || (chip_irq > 15)) {
+			return (0);
+		}
+		return (chip_irq);
+	}
+	if ((bus_type & ASC_IS_VL) != 0) {
+		cfg_lsw = AscGetChipCfgLsw(iop_base);
+		chip_irq = (uchar)(((cfg_lsw >> 2) & 0x07));
+		if ((chip_irq == 0) || (chip_irq == 4) || (chip_irq == 7)) {
+			return (0);
+		}
+		return ((uchar)(chip_irq + (ASC_MIN_IRQ_NO - 1)));
+	}
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
+	chip_irq = (uchar)(((cfg_lsw >> 2) & 0x03));
+	if (chip_irq == 3)
+		chip_irq += (uchar)2;
+	return ((uchar)(chip_irq + ASC_MIN_IRQ_NO));
 }
 
-STATIC uchar __init
-AscSetChipIRQ(
-                 PortAddr iop_base,
-                 uchar irq_no,
-                 ushort bus_type)
+static uchar __init
+AscSetChipIRQ(PortAddr iop_base, uchar irq_no, ushort bus_type)
 {
-    ushort              cfg_lsw;
-
-    if ((bus_type & ASC_IS_VL) != 0) {
-        if (irq_no != 0) {
-            if ((irq_no < ASC_MIN_IRQ_NO) || (irq_no > ASC_MAX_IRQ_NO)) {
-                irq_no = 0;
-            } else {
-                irq_no -= (uchar) ((ASC_MIN_IRQ_NO - 1));
-            }
-        }
-        cfg_lsw = (ushort) (AscGetChipCfgLsw(iop_base) & 0xFFE3);
-        cfg_lsw |= (ushort) 0x0010;
-        AscSetChipCfgLsw(iop_base, cfg_lsw);
-        AscToggleIRQAct(iop_base);
-        cfg_lsw = (ushort) (AscGetChipCfgLsw(iop_base) & 0xFFE0);
-        cfg_lsw |= (ushort) ((irq_no & 0x07) << 2);
-        AscSetChipCfgLsw(iop_base, cfg_lsw);
-        AscToggleIRQAct(iop_base);
-        return (AscGetChipIRQ(iop_base, bus_type));
-    }
-    if ((bus_type & (ASC_IS_ISA)) != 0) {
-        if (irq_no == 15)
-            irq_no -= (uchar) 2;
-        irq_no -= (uchar) ASC_MIN_IRQ_NO;
-        cfg_lsw = (ushort) (AscGetChipCfgLsw(iop_base) & 0xFFF3);
-        cfg_lsw |= (ushort) ((irq_no & 0x03) << 2);
-        AscSetChipCfgLsw(iop_base, cfg_lsw);
-        return (AscGetChipIRQ(iop_base, bus_type));
-    }
-    return (0);
+	ushort cfg_lsw;
+
+	if ((bus_type & ASC_IS_VL) != 0) {
+		if (irq_no != 0) {
+			if ((irq_no < ASC_MIN_IRQ_NO)
+			    || (irq_no > ASC_MAX_IRQ_NO)) {
+				irq_no = 0;
+			} else {
+				irq_no -= (uchar)((ASC_MIN_IRQ_NO - 1));
+			}
+		}
+		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE3);
+		cfg_lsw |= (ushort)0x0010;
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		AscToggleIRQAct(iop_base);
+		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFE0);
+		cfg_lsw |= (ushort)((irq_no & 0x07) << 2);
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		AscToggleIRQAct(iop_base);
+		return (AscGetChipIRQ(iop_base, bus_type));
+	}
+	if ((bus_type & (ASC_IS_ISA)) != 0) {
+		if (irq_no == 15)
+			irq_no -= (uchar)2;
+		irq_no -= (uchar)ASC_MIN_IRQ_NO;
+		cfg_lsw = (ushort)(AscGetChipCfgLsw(iop_base) & 0xFFF3);
+		cfg_lsw |= (ushort)((irq_no & 0x03) << 2);
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		return (AscGetChipIRQ(iop_base, bus_type));
+	}
+	return (0);
 }
 
 #ifdef CONFIG_ISA
-STATIC void __init
-AscEnableIsaDma(
-                   uchar dma_channel)
+static void __init AscEnableIsaDma(uchar dma_channel)
 {
-    if (dma_channel < 4) {
-        outp(0x000B, (ushort) (0xC0 | dma_channel));
-        outp(0x000A, dma_channel);
-    } else if (dma_channel < 8) {
-        outp(0x00D6, (ushort) (0xC0 | (dma_channel - 4)));
-        outp(0x00D4, (ushort) (dma_channel - 4));
-    }
-    return;
+	if (dma_channel < 4) {
+		outp(0x000B, (ushort)(0xC0 | dma_channel));
+		outp(0x000A, dma_channel);
+	} else if (dma_channel < 8) {
+		outp(0x00D6, (ushort)(0xC0 | (dma_channel - 4)));
+		outp(0x00D4, (ushort)(dma_channel - 4));
+	}
+	return;
 }
 #endif /* CONFIG_ISA */
 
-STATIC int
-AscIsrChipHalted(
-                    ASC_DVC_VAR *asc_dvc
-)
+static int AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)
 {
-    EXT_MSG             ext_msg;
-    EXT_MSG             out_msg;
-    ushort              halt_q_addr;
-    int                 sdtr_accept;
-    ushort              int_halt_code;
-    ASC_SCSI_BIT_ID_TYPE scsi_busy;
-    ASC_SCSI_BIT_ID_TYPE target_id;
-    PortAddr            iop_base;
-    uchar               tag_code;
-    uchar               q_status;
-    uchar               halt_qp;
-    uchar               sdtr_data;
-    uchar               target_ix;
-    uchar               q_cntl, tid_no;
-    uchar               cur_dvc_qng;
-    uchar               asyn_sdtr;
-    uchar               scsi_status;
-    asc_board_t         *boardp;
-
-    ASC_ASSERT(asc_dvc->drv_ptr != NULL);
-    boardp = asc_dvc->drv_ptr;
-
-    iop_base = asc_dvc->iop_base;
-    int_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);
-
-    halt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);
-    halt_q_addr = ASC_QNO_TO_QADDR(halt_qp);
-    target_ix = AscReadLramByte(iop_base,
-                   (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_TARGET_IX));
-    q_cntl = AscReadLramByte(iop_base,
-                        (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL));
-    tid_no = ASC_TIX_TO_TID(target_ix);
-    target_id = (uchar) ASC_TID_TO_TARGET_ID(tid_no);
-    if (asc_dvc->pci_fix_asyn_xfer & target_id) {
-        asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;
-    } else {
-        asyn_sdtr = 0;
-    }
-    if (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {
-        if (asc_dvc->pci_fix_asyn_xfer & target_id) {
-            AscSetChipSDTR(iop_base, 0, tid_no);
-            boardp->sdtr_data[tid_no] = 0;
-        }
-        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-        return (0);
-    } else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {
-        if (asc_dvc->pci_fix_asyn_xfer & target_id) {
-            AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-            boardp->sdtr_data[tid_no] = asyn_sdtr;
-        }
-        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-        return (0);
-    } else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
-
-        AscMemWordCopyPtrFromLram(iop_base,
-                               ASCV_MSGIN_BEG,
-                               (uchar *) &ext_msg,
-                               sizeof(EXT_MSG) >> 1);
-
-        if (ext_msg.msg_type == MS_EXTEND &&
-            ext_msg.msg_req == MS_SDTR_CODE &&
-            ext_msg.msg_len == MS_SDTR_LEN) {
-            sdtr_accept = TRUE;
-            if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
-
-                sdtr_accept = FALSE;
-                ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
-            }
-            if ((ext_msg.xfer_period <
-                 asc_dvc->sdtr_period_tbl[asc_dvc->host_init_sdtr_index]) ||
-                (ext_msg.xfer_period >
-                 asc_dvc->sdtr_period_tbl[asc_dvc->max_sdtr_index])) {
-                sdtr_accept = FALSE;
-                ext_msg.xfer_period =
-                    asc_dvc->sdtr_period_tbl[asc_dvc->host_init_sdtr_index];
-            }
-            if (sdtr_accept) {
-                sdtr_data = AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
-                                           ext_msg.req_ack_offset);
-                if ((sdtr_data == 0xFF)) {
-
-                    q_cntl |= QC_MSG_OUT;
-                    asc_dvc->init_sdtr &= ~target_id;
-                    asc_dvc->sdtr_done &= ~target_id;
-                    AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-                    boardp->sdtr_data[tid_no] = asyn_sdtr;
-                }
-            }
-            if (ext_msg.req_ack_offset == 0) {
-
-                q_cntl &= ~QC_MSG_OUT;
-                asc_dvc->init_sdtr &= ~target_id;
-                asc_dvc->sdtr_done &= ~target_id;
-                AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-            } else {
-                if (sdtr_accept && (q_cntl & QC_MSG_OUT)) {
-
-                    q_cntl &= ~QC_MSG_OUT;
-                    asc_dvc->sdtr_done |= target_id;
-                    asc_dvc->init_sdtr |= target_id;
-                    asc_dvc->pci_fix_asyn_xfer &= ~target_id;
-                    sdtr_data = AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
-                                               ext_msg.req_ack_offset);
-                    AscSetChipSDTR(iop_base, sdtr_data, tid_no);
-                    boardp->sdtr_data[tid_no] = sdtr_data;
-                } else {
-
-                    q_cntl |= QC_MSG_OUT;
-                    AscMsgOutSDTR(asc_dvc,
-                                  ext_msg.xfer_period,
-                                  ext_msg.req_ack_offset);
-                    asc_dvc->pci_fix_asyn_xfer &= ~target_id;
-                    sdtr_data = AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
-                                               ext_msg.req_ack_offset);
-                    AscSetChipSDTR(iop_base, sdtr_data, tid_no);
-                    boardp->sdtr_data[tid_no] = sdtr_data;
-                    asc_dvc->sdtr_done |= target_id;
-                    asc_dvc->init_sdtr |= target_id;
-                }
-            }
-
-            AscWriteLramByte(iop_base,
-                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
-                             q_cntl);
-            AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-            return (0);
-        } else if (ext_msg.msg_type == MS_EXTEND &&
-                   ext_msg.msg_req == MS_WDTR_CODE &&
-                   ext_msg.msg_len == MS_WDTR_LEN) {
-
-            ext_msg.wdtr_width = 0;
-            AscMemWordCopyPtrToLram(iop_base,
-                                 ASCV_MSGOUT_BEG,
-                                 (uchar *) &ext_msg,
-                                 sizeof(EXT_MSG) >> 1);
-            q_cntl |= QC_MSG_OUT;
-            AscWriteLramByte(iop_base,
-                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
-                             q_cntl);
-            AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-            return (0);
-        } else {
-
-            ext_msg.msg_type = MESSAGE_REJECT;
-            AscMemWordCopyPtrToLram(iop_base,
-                                 ASCV_MSGOUT_BEG,
-                                 (uchar *) &ext_msg,
-                                 sizeof(EXT_MSG) >> 1);
-            q_cntl |= QC_MSG_OUT;
-            AscWriteLramByte(iop_base,
-                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
-                             q_cntl);
-            AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-            return (0);
-        }
-    } else if (int_halt_code == ASC_HALT_CHK_CONDITION) {
-
-        q_cntl |= QC_REQ_SENSE;
-
-        if ((asc_dvc->init_sdtr & target_id) != 0) {
-
-            asc_dvc->sdtr_done &= ~target_id;
-
-            sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
-            q_cntl |= QC_MSG_OUT;
-            AscMsgOutSDTR(asc_dvc,
-                          asc_dvc->sdtr_period_tbl[(sdtr_data >> 4) &
-                           (uchar) (asc_dvc->max_sdtr_index - 1)],
-                          (uchar) (sdtr_data & (uchar) ASC_SYN_MAX_OFFSET));
-        }
-
-        AscWriteLramByte(iop_base,
-                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
-                         q_cntl);
-
-        tag_code = AscReadLramByte(iop_base,
-                    (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_TAG_CODE));
-        tag_code &= 0xDC;
-        if (
-               (asc_dvc->pci_fix_asyn_xfer & target_id)
-               && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)
-) {
-
-            tag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT
-                         | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);
-
-        }
-        AscWriteLramByte(iop_base,
-                     (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_TAG_CODE),
-                         tag_code);
-
-        q_status = AscReadLramByte(iop_base,
-                      (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_STATUS));
-        q_status |= (QS_READY | QS_BUSY);
-        AscWriteLramByte(iop_base,
-                       (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_STATUS),
-                         q_status);
-
-        scsi_busy = AscReadLramByte(iop_base,
-                                    (ushort) ASCV_SCSIBUSY_B);
-        scsi_busy &= ~target_id;
-        AscWriteLramByte(iop_base, (ushort) ASCV_SCSIBUSY_B, scsi_busy);
-
-        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-        return (0);
-    } else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {
-
-        AscMemWordCopyPtrFromLram(iop_base,
-                               ASCV_MSGOUT_BEG,
-                               (uchar *) &out_msg,
-                               sizeof(EXT_MSG) >> 1);
-
-        if ((out_msg.msg_type == MS_EXTEND) &&
-            (out_msg.msg_len == MS_SDTR_LEN) &&
-            (out_msg.msg_req == MS_SDTR_CODE)) {
-
-            asc_dvc->init_sdtr &= ~target_id;
-            asc_dvc->sdtr_done &= ~target_id;
-            AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
-            boardp->sdtr_data[tid_no] = asyn_sdtr;
-        }
-        q_cntl &= ~QC_MSG_OUT;
-        AscWriteLramByte(iop_base,
-                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
-                         q_cntl);
-        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-        return (0);
-    } else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {
-
-        scsi_status = AscReadLramByte(iop_base,
-          (ushort) ((ushort) halt_q_addr + (ushort) ASC_SCSIQ_SCSI_STATUS));
-        cur_dvc_qng = AscReadLramByte(iop_base,
-                     (ushort) ((ushort) ASC_QADR_BEG + (ushort) target_ix));
-        if ((cur_dvc_qng > 0) &&
-            (asc_dvc->cur_dvc_qng[tid_no] > 0)) {
-
-            scsi_busy = AscReadLramByte(iop_base,
-                                        (ushort) ASCV_SCSIBUSY_B);
-            scsi_busy |= target_id;
-            AscWriteLramByte(iop_base,
-                             (ushort) ASCV_SCSIBUSY_B, scsi_busy);
-            asc_dvc->queue_full_or_busy |= target_id;
-
-            if (scsi_status == SAM_STAT_TASK_SET_FULL) {
-                if (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {
-                    cur_dvc_qng -= 1;
-                    asc_dvc->max_dvc_qng[tid_no] = cur_dvc_qng;
-
-                    AscWriteLramByte(iop_base,
-                          (ushort) ((ushort) ASCV_MAX_DVC_QNG_BEG +
-                           (ushort) tid_no),
-                          cur_dvc_qng);
-
-                    /*
-                     * Set the device queue depth to the number of
-                     * active requests when the QUEUE FULL condition
-                     * was encountered.
-                     */
-                    boardp->queue_full |= target_id;
-                    boardp->queue_full_cnt[tid_no] = cur_dvc_qng;
-                }
-            }
-        }
-        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-        return (0);
-    }
+	EXT_MSG ext_msg;
+	EXT_MSG out_msg;
+	ushort halt_q_addr;
+	int sdtr_accept;
+	ushort int_halt_code;
+	ASC_SCSI_BIT_ID_TYPE scsi_busy;
+	ASC_SCSI_BIT_ID_TYPE target_id;
+	PortAddr iop_base;
+	uchar tag_code;
+	uchar q_status;
+	uchar halt_qp;
+	uchar sdtr_data;
+	uchar target_ix;
+	uchar q_cntl, tid_no;
+	uchar cur_dvc_qng;
+	uchar asyn_sdtr;
+	uchar scsi_status;
+	asc_board_t *boardp;
+
+	ASC_ASSERT(asc_dvc->drv_ptr != NULL);
+	boardp = asc_dvc->drv_ptr;
+
+	iop_base = asc_dvc->iop_base;
+	int_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);
+
+	halt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);
+	halt_q_addr = ASC_QNO_TO_QADDR(halt_qp);
+	target_ix = AscReadLramByte(iop_base,
+				    (ushort)(halt_q_addr +
+					     (ushort)ASC_SCSIQ_B_TARGET_IX));
+	q_cntl =
+	    AscReadLramByte(iop_base,
+			    (ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	target_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);
+	if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+		asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;
+	} else {
+		asyn_sdtr = 0;
+	}
+	if (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {
+		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+			AscSetChipSDTR(iop_base, 0, tid_no);
+			boardp->sdtr_data[tid_no] = 0;
+		}
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {
+		if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+			boardp->sdtr_data[tid_no] = asyn_sdtr;
+		}
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
+
+		AscMemWordCopyPtrFromLram(iop_base,
+					  ASCV_MSGIN_BEG,
+					  (uchar *)&ext_msg,
+					  sizeof(EXT_MSG) >> 1);
+
+		if (ext_msg.msg_type == MS_EXTEND &&
+		    ext_msg.msg_req == MS_SDTR_CODE &&
+		    ext_msg.msg_len == MS_SDTR_LEN) {
+			sdtr_accept = TRUE;
+			if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
+
+				sdtr_accept = FALSE;
+				ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
+			}
+			if ((ext_msg.xfer_period <
+			     asc_dvc->sdtr_period_tbl[asc_dvc->
+						      host_init_sdtr_index])
+			    || (ext_msg.xfer_period >
+				asc_dvc->sdtr_period_tbl[asc_dvc->
+							 max_sdtr_index])) {
+				sdtr_accept = FALSE;
+				ext_msg.xfer_period =
+				    asc_dvc->sdtr_period_tbl[asc_dvc->
+							     host_init_sdtr_index];
+			}
+			if (sdtr_accept) {
+				sdtr_data =
+				    AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
+						   ext_msg.req_ack_offset);
+				if ((sdtr_data == 0xFF)) {
+
+					q_cntl |= QC_MSG_OUT;
+					asc_dvc->init_sdtr &= ~target_id;
+					asc_dvc->sdtr_done &= ~target_id;
+					AscSetChipSDTR(iop_base, asyn_sdtr,
+						       tid_no);
+					boardp->sdtr_data[tid_no] = asyn_sdtr;
+				}
+			}
+			if (ext_msg.req_ack_offset == 0) {
+
+				q_cntl &= ~QC_MSG_OUT;
+				asc_dvc->init_sdtr &= ~target_id;
+				asc_dvc->sdtr_done &= ~target_id;
+				AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+			} else {
+				if (sdtr_accept && (q_cntl & QC_MSG_OUT)) {
+
+					q_cntl &= ~QC_MSG_OUT;
+					asc_dvc->sdtr_done |= target_id;
+					asc_dvc->init_sdtr |= target_id;
+					asc_dvc->pci_fix_asyn_xfer &=
+					    ~target_id;
+					sdtr_data =
+					    AscCalSDTRData(asc_dvc,
+							   ext_msg.xfer_period,
+							   ext_msg.
+							   req_ack_offset);
+					AscSetChipSDTR(iop_base, sdtr_data,
+						       tid_no);
+					boardp->sdtr_data[tid_no] = sdtr_data;
+				} else {
+
+					q_cntl |= QC_MSG_OUT;
+					AscMsgOutSDTR(asc_dvc,
+						      ext_msg.xfer_period,
+						      ext_msg.req_ack_offset);
+					asc_dvc->pci_fix_asyn_xfer &=
+					    ~target_id;
+					sdtr_data =
+					    AscCalSDTRData(asc_dvc,
+							   ext_msg.xfer_period,
+							   ext_msg.
+							   req_ack_offset);
+					AscSetChipSDTR(iop_base, sdtr_data,
+						       tid_no);
+					boardp->sdtr_data[tid_no] = sdtr_data;
+					asc_dvc->sdtr_done |= target_id;
+					asc_dvc->init_sdtr |= target_id;
+				}
+			}
+
+			AscWriteLramByte(iop_base,
+					 (ushort)(halt_q_addr +
+						  (ushort)ASC_SCSIQ_B_CNTL),
+					 q_cntl);
+			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+			return (0);
+		} else if (ext_msg.msg_type == MS_EXTEND &&
+			   ext_msg.msg_req == MS_WDTR_CODE &&
+			   ext_msg.msg_len == MS_WDTR_LEN) {
+
+			ext_msg.wdtr_width = 0;
+			AscMemWordCopyPtrToLram(iop_base,
+						ASCV_MSGOUT_BEG,
+						(uchar *)&ext_msg,
+						sizeof(EXT_MSG) >> 1);
+			q_cntl |= QC_MSG_OUT;
+			AscWriteLramByte(iop_base,
+					 (ushort)(halt_q_addr +
+						  (ushort)ASC_SCSIQ_B_CNTL),
+					 q_cntl);
+			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+			return (0);
+		} else {
+
+			ext_msg.msg_type = MESSAGE_REJECT;
+			AscMemWordCopyPtrToLram(iop_base,
+						ASCV_MSGOUT_BEG,
+						(uchar *)&ext_msg,
+						sizeof(EXT_MSG) >> 1);
+			q_cntl |= QC_MSG_OUT;
+			AscWriteLramByte(iop_base,
+					 (ushort)(halt_q_addr +
+						  (ushort)ASC_SCSIQ_B_CNTL),
+					 q_cntl);
+			AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+			return (0);
+		}
+	} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {
+
+		q_cntl |= QC_REQ_SENSE;
+
+		if ((asc_dvc->init_sdtr & target_id) != 0) {
+
+			asc_dvc->sdtr_done &= ~target_id;
+
+			sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+			q_cntl |= QC_MSG_OUT;
+			AscMsgOutSDTR(asc_dvc,
+				      asc_dvc->
+				      sdtr_period_tbl[(sdtr_data >> 4) &
+						      (uchar)(asc_dvc->
+							      max_sdtr_index -
+							      1)],
+				      (uchar)(sdtr_data & (uchar)
+					      ASC_SYN_MAX_OFFSET));
+		}
+
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
+
+		tag_code = AscReadLramByte(iop_base,
+					   (ushort)(halt_q_addr + (ushort)
+						    ASC_SCSIQ_B_TAG_CODE));
+		tag_code &= 0xDC;
+		if ((asc_dvc->pci_fix_asyn_xfer & target_id)
+		    && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)
+		    ) {
+
+			tag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT
+				     | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);
+
+		}
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_TAG_CODE),
+				 tag_code);
+
+		q_status = AscReadLramByte(iop_base,
+					   (ushort)(halt_q_addr + (ushort)
+						    ASC_SCSIQ_B_STATUS));
+		q_status |= (QS_READY | QS_BUSY);
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_STATUS),
+				 q_status);
+
+		scsi_busy = AscReadLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B);
+		scsi_busy &= ~target_id;
+		AscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);
+
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {
+
+		AscMemWordCopyPtrFromLram(iop_base,
+					  ASCV_MSGOUT_BEG,
+					  (uchar *)&out_msg,
+					  sizeof(EXT_MSG) >> 1);
+
+		if ((out_msg.msg_type == MS_EXTEND) &&
+		    (out_msg.msg_len == MS_SDTR_LEN) &&
+		    (out_msg.msg_req == MS_SDTR_CODE)) {
+
+			asc_dvc->init_sdtr &= ~target_id;
+			asc_dvc->sdtr_done &= ~target_id;
+			AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+			boardp->sdtr_data[tid_no] = asyn_sdtr;
+		}
+		q_cntl &= ~QC_MSG_OUT;
+		AscWriteLramByte(iop_base,
+				 (ushort)(halt_q_addr +
+					  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {
+
+		scsi_status = AscReadLramByte(iop_base,
+					      (ushort)((ushort)halt_q_addr +
+						       (ushort)
+						       ASC_SCSIQ_SCSI_STATUS));
+		cur_dvc_qng =
+		    AscReadLramByte(iop_base,
+				    (ushort)((ushort)ASC_QADR_BEG +
+					     (ushort)target_ix));
+		if ((cur_dvc_qng > 0) && (asc_dvc->cur_dvc_qng[tid_no] > 0)) {
+
+			scsi_busy = AscReadLramByte(iop_base,
+						    (ushort)ASCV_SCSIBUSY_B);
+			scsi_busy |= target_id;
+			AscWriteLramByte(iop_base,
+					 (ushort)ASCV_SCSIBUSY_B, scsi_busy);
+			asc_dvc->queue_full_or_busy |= target_id;
+
+			if (scsi_status == SAM_STAT_TASK_SET_FULL) {
+				if (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {
+					cur_dvc_qng -= 1;
+					asc_dvc->max_dvc_qng[tid_no] =
+					    cur_dvc_qng;
+
+					AscWriteLramByte(iop_base,
+							 (ushort)((ushort)
+								  ASCV_MAX_DVC_QNG_BEG
+								  + (ushort)
+								  tid_no),
+							 cur_dvc_qng);
+
+					/*
+					 * Set the device queue depth to the number of
+					 * active requests when the QUEUE FULL condition
+					 * was encountered.
+					 */
+					boardp->queue_full |= target_id;
+					boardp->queue_full_cnt[tid_no] =
+					    cur_dvc_qng;
+				}
+			}
+		}
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	}
 #if CC_VERY_LONG_SG_LIST
-    else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC)
-    {
-        uchar              q_no;
-        ushort             q_addr;
-        uchar              sg_wk_q_no;
-        uchar              first_sg_wk_q_no;
-        ASC_SCSI_Q         *scsiq; /* Ptr to driver request. */
-        ASC_SG_HEAD        *sg_head; /* Ptr to driver SG request. */
-        ASC_SG_LIST_Q      scsi_sg_q; /* Structure written to queue. */
-        ushort             sg_list_dwords;
-        ushort             sg_entry_cnt;
-        uchar              next_qp;
-        int                i;
-
-        q_no = AscReadLramByte(iop_base, (ushort) ASCV_REQ_SG_LIST_QP);
-        if (q_no == ASC_QLINK_END)
-        {
-            return(0);
-        }
-
-        q_addr = ASC_QNO_TO_QADDR(q_no);
-
-        /*
-         * Convert the request's SRB pointer to a host ASC_SCSI_REQ
-         * structure pointer using a macro provided by the driver.
-         * The ASC_SCSI_REQ pointer provides a pointer to the
-         * host ASC_SG_HEAD structure.
-         */
-        /* Read request's SRB pointer. */
-        scsiq = (ASC_SCSI_Q *)
-           ASC_SRB2SCSIQ(
-               ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,
-               (ushort) (q_addr + ASC_SCSIQ_D_SRBPTR))));
-
-        /*
-         * Get request's first and working SG queue.
-         */
-        sg_wk_q_no = AscReadLramByte(iop_base,
-            (ushort) (q_addr + ASC_SCSIQ_B_SG_WK_QP));
-
-        first_sg_wk_q_no = AscReadLramByte(iop_base,
-            (ushort) (q_addr + ASC_SCSIQ_B_FIRST_SG_WK_QP));
-
-        /*
-         * Reset request's working SG queue back to the
-         * first SG queue.
-         */
-        AscWriteLramByte(iop_base,
-            (ushort) (q_addr + (ushort) ASC_SCSIQ_B_SG_WK_QP),
-            first_sg_wk_q_no);
-
-        sg_head = scsiq->sg_head;
-
-        /*
-         * Set sg_entry_cnt to the number of SG elements
-         * that will be completed on this interrupt.
-         *
-         * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1
-         * SG elements. The data_cnt and data_addr fields which
-         * add 1 to the SG element capacity are not used when
-         * restarting SG handling after a halt.
-         */
-        if (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1))
-        {
-             sg_entry_cnt = ASC_MAX_SG_LIST - 1;
-
-             /*
-              * Keep track of remaining number of SG elements that will
-              * need to be handled on the next interrupt.
-              */
-             scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
-        } else
-        {
-             sg_entry_cnt = scsiq->remain_sg_entry_cnt;
-             scsiq->remain_sg_entry_cnt = 0;
-        }
-
-        /*
-         * Copy SG elements into the list of allocated SG queues.
-         *
-         * Last index completed is saved in scsiq->next_sg_index.
-         */
-        next_qp = first_sg_wk_q_no;
-        q_addr = ASC_QNO_TO_QADDR(next_qp);
-        scsi_sg_q.sg_head_qp = q_no;
-        scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
-        for( i = 0; i < sg_head->queue_cnt; i++)
-        {
-             scsi_sg_q.seq_no = i + 1;
-             if (sg_entry_cnt > ASC_SG_LIST_PER_Q)
-             {
-                 sg_list_dwords = (uchar) (ASC_SG_LIST_PER_Q * 2);
-                 sg_entry_cnt -= ASC_SG_LIST_PER_Q;
-                 /*
-                  * After very first SG queue RISC FW uses next
-                  * SG queue first element then checks sg_list_cnt
-                  * against zero and then decrements, so set
-                  * sg_list_cnt 1 less than number of SG elements
-                  * in each SG queue.
-                  */
-                 scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
-                 scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q - 1;
-             } else {
-                 /*
-                  * This is the last SG queue in the list of
-                  * allocated SG queues. If there are more
-                  * SG elements than will fit in the allocated
-                  * queues, then set the QCSG_SG_XFER_MORE flag.
-                  */
-                 if (scsiq->remain_sg_entry_cnt != 0)
-                 {
-                     scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
-                 } else
-                 {
-                     scsi_sg_q.cntl |= QCSG_SG_XFER_END;
-                 }
-                 /* equals sg_entry_cnt * 2 */
-                 sg_list_dwords = sg_entry_cnt << 1;
-                 scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
-                 scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
-                 sg_entry_cnt = 0;
-             }
-
-             scsi_sg_q.q_no = next_qp;
-             AscMemWordCopyPtrToLram(iop_base,
-                          q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
-                          (uchar *) &scsi_sg_q,
-                          sizeof(ASC_SG_LIST_Q) >> 1);
-
-             AscMemDWordCopyPtrToLram(iop_base,
-                          q_addr + ASC_SGQ_LIST_BEG,
-                          (uchar *) &sg_head->sg_list[scsiq->next_sg_index],
-                          sg_list_dwords);
-
-             scsiq->next_sg_index += ASC_SG_LIST_PER_Q;
-
-             /*
-              * If the just completed SG queue contained the
-              * last SG element, then no more SG queues need
-              * to be written.
-              */
-             if (scsi_sg_q.cntl & QCSG_SG_XFER_END)
-             {
-                 break;
-             }
-
-             next_qp = AscReadLramByte( iop_base,
-                          ( ushort )( q_addr+ASC_SCSIQ_B_FWD ) );
-             q_addr = ASC_QNO_TO_QADDR( next_qp );
-        }
-
-        /*
-         * Clear the halt condition so the RISC will be restarted
-         * after the return.
-         */
-        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-        return(0);
-    }
+	else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC) {
+		uchar q_no;
+		ushort q_addr;
+		uchar sg_wk_q_no;
+		uchar first_sg_wk_q_no;
+		ASC_SCSI_Q *scsiq;	/* Ptr to driver request. */
+		ASC_SG_HEAD *sg_head;	/* Ptr to driver SG request. */
+		ASC_SG_LIST_Q scsi_sg_q;	/* Structure written to queue. */
+		ushort sg_list_dwords;
+		ushort sg_entry_cnt;
+		uchar next_qp;
+		int i;
+
+		q_no = AscReadLramByte(iop_base, (ushort)ASCV_REQ_SG_LIST_QP);
+		if (q_no == ASC_QLINK_END) {
+			return (0);
+		}
+
+		q_addr = ASC_QNO_TO_QADDR(q_no);
+
+		/*
+		 * Convert the request's SRB pointer to a host ASC_SCSI_REQ
+		 * structure pointer using a macro provided by the driver.
+		 * The ASC_SCSI_REQ pointer provides a pointer to the
+		 * host ASC_SG_HEAD structure.
+		 */
+		/* Read request's SRB pointer. */
+		scsiq = (ASC_SCSI_Q *)
+		    ASC_SRB2SCSIQ(ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,
+								    (ushort)
+								    (q_addr +
+								     ASC_SCSIQ_D_SRBPTR))));
+
+		/*
+		 * Get request's first and working SG queue.
+		 */
+		sg_wk_q_no = AscReadLramByte(iop_base,
+					     (ushort)(q_addr +
+						      ASC_SCSIQ_B_SG_WK_QP));
+
+		first_sg_wk_q_no = AscReadLramByte(iop_base,
+						   (ushort)(q_addr +
+							    ASC_SCSIQ_B_FIRST_SG_WK_QP));
+
+		/*
+		 * Reset request's working SG queue back to the
+		 * first SG queue.
+		 */
+		AscWriteLramByte(iop_base,
+				 (ushort)(q_addr +
+					  (ushort)ASC_SCSIQ_B_SG_WK_QP),
+				 first_sg_wk_q_no);
+
+		sg_head = scsiq->sg_head;
+
+		/*
+		 * Set sg_entry_cnt to the number of SG elements
+		 * that will be completed on this interrupt.
+		 *
+		 * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1
+		 * SG elements. The data_cnt and data_addr fields which
+		 * add 1 to the SG element capacity are not used when
+		 * restarting SG handling after a halt.
+		 */
+		if (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1)) {
+			sg_entry_cnt = ASC_MAX_SG_LIST - 1;
+
+			/*
+			 * Keep track of remaining number of SG elements that will
+			 * need to be handled on the next interrupt.
+			 */
+			scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
+		} else {
+			sg_entry_cnt = scsiq->remain_sg_entry_cnt;
+			scsiq->remain_sg_entry_cnt = 0;
+		}
+
+		/*
+		 * Copy SG elements into the list of allocated SG queues.
+		 *
+		 * Last index completed is saved in scsiq->next_sg_index.
+		 */
+		next_qp = first_sg_wk_q_no;
+		q_addr = ASC_QNO_TO_QADDR(next_qp);
+		scsi_sg_q.sg_head_qp = q_no;
+		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
+		for (i = 0; i < sg_head->queue_cnt; i++) {
+			scsi_sg_q.seq_no = i + 1;
+			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
+				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
+				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
+				/*
+				 * After very first SG queue RISC FW uses next
+				 * SG queue first element then checks sg_list_cnt
+				 * against zero and then decrements, so set
+				 * sg_list_cnt 1 less than number of SG elements
+				 * in each SG queue.
+				 */
+				scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
+				scsi_sg_q.sg_cur_list_cnt =
+				    ASC_SG_LIST_PER_Q - 1;
+			} else {
+				/*
+				 * This is the last SG queue in the list of
+				 * allocated SG queues. If there are more
+				 * SG elements than will fit in the allocated
+				 * queues, then set the QCSG_SG_XFER_MORE flag.
+				 */
+				if (scsiq->remain_sg_entry_cnt != 0) {
+					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
+				} else {
+					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
+				}
+				/* equals sg_entry_cnt * 2 */
+				sg_list_dwords = sg_entry_cnt << 1;
+				scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
+				scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
+				sg_entry_cnt = 0;
+			}
+
+			scsi_sg_q.q_no = next_qp;
+			AscMemWordCopyPtrToLram(iop_base,
+						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
+						(uchar *)&scsi_sg_q,
+						sizeof(ASC_SG_LIST_Q) >> 1);
+
+			AscMemDWordCopyPtrToLram(iop_base,
+						 q_addr + ASC_SGQ_LIST_BEG,
+						 (uchar *)&sg_head->
+						 sg_list[scsiq->next_sg_index],
+						 sg_list_dwords);
+
+			scsiq->next_sg_index += ASC_SG_LIST_PER_Q;
+
+			/*
+			 * If the just completed SG queue contained the
+			 * last SG element, then no more SG queues need
+			 * to be written.
+			 */
+			if (scsi_sg_q.cntl & QCSG_SG_XFER_END) {
+				break;
+			}
+
+			next_qp = AscReadLramByte(iop_base,
+						  (ushort)(q_addr +
+							   ASC_SCSIQ_B_FWD));
+			q_addr = ASC_QNO_TO_QADDR(next_qp);
+		}
+
+		/*
+		 * Clear the halt condition so the RISC will be restarted
+		 * after the return.
+		 */
+		AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+		return (0);
+	}
 #endif /* CC_VERY_LONG_SG_LIST */
-    return (0);
+	return (0);
 }
 
-STATIC uchar
-_AscCopyLramScsiDoneQ(
-                         PortAddr iop_base,
-                         ushort q_addr,
-                         ASC_QDONE_INFO * scsiq,
-                         ASC_DCNT max_dma_count
-)
+static uchar
+_AscCopyLramScsiDoneQ(PortAddr iop_base,
+		      ushort q_addr,
+		      ASC_QDONE_INFO *scsiq, ASC_DCNT max_dma_count)
 {
-    ushort              _val;
-    uchar               sg_queue_cnt;
-
-    DvcGetQinfo(iop_base,
-                q_addr + ASC_SCSIQ_DONE_INFO_BEG,
-                (uchar *) scsiq,
-                (sizeof (ASC_SCSIQ_2) + sizeof (ASC_SCSIQ_3)) / 2);
-
-    _val = AscReadLramWord(iop_base,
-                           (ushort) (q_addr + (ushort) ASC_SCSIQ_B_STATUS));
-    scsiq->q_status = (uchar) _val;
-    scsiq->q_no = (uchar) (_val >> 8);
-    _val = AscReadLramWord(iop_base,
-                           (ushort) (q_addr + (ushort) ASC_SCSIQ_B_CNTL));
-    scsiq->cntl = (uchar) _val;
-    sg_queue_cnt = (uchar) (_val >> 8);
-    _val = AscReadLramWord(iop_base,
-                        (ushort) (q_addr + (ushort) ASC_SCSIQ_B_SENSE_LEN));
-    scsiq->sense_len = (uchar) _val;
-    scsiq->extra_bytes = (uchar) (_val >> 8);
-
-    /*
-     * Read high word of remain bytes from alternate location.
-     */
-    scsiq->remain_bytes = (((ADV_DCNT) AscReadLramWord( iop_base,
-                      (ushort) (q_addr+ (ushort) ASC_SCSIQ_W_ALT_DC1))) << 16);
-    /*
-     * Read low word of remain bytes from original location.
-     */
-    scsiq->remain_bytes += AscReadLramWord(iop_base,
-        (ushort) (q_addr+ (ushort) ASC_SCSIQ_DW_REMAIN_XFER_CNT));
-
-    scsiq->remain_bytes &= max_dma_count;
-    return (sg_queue_cnt);
+	ushort _val;
+	uchar sg_queue_cnt;
+
+	DvcGetQinfo(iop_base,
+		    q_addr + ASC_SCSIQ_DONE_INFO_BEG,
+		    (uchar *)scsiq,
+		    (sizeof(ASC_SCSIQ_2) + sizeof(ASC_SCSIQ_3)) / 2);
+
+	_val = AscReadLramWord(iop_base,
+			       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS));
+	scsiq->q_status = (uchar)_val;
+	scsiq->q_no = (uchar)(_val >> 8);
+	_val = AscReadLramWord(iop_base,
+			       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_CNTL));
+	scsiq->cntl = (uchar)_val;
+	sg_queue_cnt = (uchar)(_val >> 8);
+	_val = AscReadLramWord(iop_base,
+			       (ushort)(q_addr +
+					(ushort)ASC_SCSIQ_B_SENSE_LEN));
+	scsiq->sense_len = (uchar)_val;
+	scsiq->extra_bytes = (uchar)(_val >> 8);
+
+	/*
+	 * Read high word of remain bytes from alternate location.
+	 */
+	scsiq->remain_bytes = (((ADV_DCNT)AscReadLramWord(iop_base,
+							  (ushort)(q_addr +
+								   (ushort)
+								   ASC_SCSIQ_W_ALT_DC1)))
+			       << 16);
+	/*
+	 * Read low word of remain bytes from original location.
+	 */
+	scsiq->remain_bytes += AscReadLramWord(iop_base,
+					       (ushort)(q_addr + (ushort)
+							ASC_SCSIQ_DW_REMAIN_XFER_CNT));
+
+	scsiq->remain_bytes &= max_dma_count;
+	return (sg_queue_cnt);
 }
 
-STATIC int
-AscIsrQDone(
-               ASC_DVC_VAR *asc_dvc
-)
+static int AscIsrQDone(ASC_DVC_VAR *asc_dvc)
 {
-    uchar               next_qp;
-    uchar               n_q_used;
-    uchar               sg_list_qp;
-    uchar               sg_queue_cnt;
-    uchar               q_cnt;
-    uchar               done_q_tail;
-    uchar               tid_no;
-    ASC_SCSI_BIT_ID_TYPE scsi_busy;
-    ASC_SCSI_BIT_ID_TYPE target_id;
-    PortAddr            iop_base;
-    ushort              q_addr;
-    ushort              sg_q_addr;
-    uchar               cur_target_qng;
-    ASC_QDONE_INFO      scsiq_buf;
-    ASC_QDONE_INFO *scsiq;
-    int                 false_overrun;
-    ASC_ISR_CALLBACK    asc_isr_callback;
-
-    iop_base = asc_dvc->iop_base;
-    asc_isr_callback = asc_dvc->isr_callback;
-    n_q_used = 1;
-    scsiq = (ASC_QDONE_INFO *) & scsiq_buf;
-    done_q_tail = (uchar) AscGetVarDoneQTail(iop_base);
-    q_addr = ASC_QNO_TO_QADDR(done_q_tail);
-    next_qp = AscReadLramByte(iop_base,
-                              (ushort) (q_addr + (ushort) ASC_SCSIQ_B_FWD));
-    if (next_qp != ASC_QLINK_END) {
-        AscPutVarDoneQTail(iop_base, next_qp);
-        q_addr = ASC_QNO_TO_QADDR(next_qp);
-        sg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,
-            asc_dvc->max_dma_count);
-        AscWriteLramByte(iop_base,
-                         (ushort) (q_addr + (ushort) ASC_SCSIQ_B_STATUS),
-             (uchar) (scsiq->q_status & (uchar) ~ (QS_READY | QS_ABORTED)));
-        tid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);
-        target_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);
-        if ((scsiq->cntl & QC_SG_HEAD) != 0) {
-            sg_q_addr = q_addr;
-            sg_list_qp = next_qp;
-            for (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {
-                sg_list_qp = AscReadLramByte(iop_base,
-                           (ushort) (sg_q_addr + (ushort) ASC_SCSIQ_B_FWD));
-                sg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);
-                if (sg_list_qp == ASC_QLINK_END) {
-                    AscSetLibErrorCode(asc_dvc, ASCQ_ERR_SG_Q_LINKS);
-                    scsiq->d3.done_stat = QD_WITH_ERROR;
-                    scsiq->d3.host_stat = QHSTA_D_QDONE_SG_LIST_CORRUPTED;
-                    goto FATAL_ERR_QDONE;
-                }
-                AscWriteLramByte(iop_base,
-                         (ushort) (sg_q_addr + (ushort) ASC_SCSIQ_B_STATUS),
-                                 QS_FREE);
-            }
-            n_q_used = sg_queue_cnt + 1;
-            AscPutVarDoneQTail(iop_base, sg_list_qp);
-        }
-        if (asc_dvc->queue_full_or_busy & target_id) {
-            cur_target_qng = AscReadLramByte(iop_base,
-            (ushort) ((ushort) ASC_QADR_BEG + (ushort) scsiq->d2.target_ix));
-            if (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {
-                scsi_busy = AscReadLramByte(iop_base,
-                                            (ushort) ASCV_SCSIBUSY_B);
-                scsi_busy &= ~target_id;
-                AscWriteLramByte(iop_base,
-                                 (ushort) ASCV_SCSIBUSY_B, scsi_busy);
-                asc_dvc->queue_full_or_busy &= ~target_id;
-            }
-        }
-        if (asc_dvc->cur_total_qng >= n_q_used) {
-            asc_dvc->cur_total_qng -= n_q_used;
-            if (asc_dvc->cur_dvc_qng[tid_no] != 0) {
-                asc_dvc->cur_dvc_qng[tid_no]--;
-            }
-        } else {
-            AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);
-            scsiq->d3.done_stat = QD_WITH_ERROR;
-            goto FATAL_ERR_QDONE;
-        }
-        if ((scsiq->d2.srb_ptr == 0UL) ||
-            ((scsiq->q_status & QS_ABORTED) != 0)) {
-            return (0x11);
-        } else if (scsiq->q_status == QS_DONE) {
-            false_overrun = FALSE;
-            if (scsiq->extra_bytes != 0) {
-                scsiq->remain_bytes += (ADV_DCNT) scsiq->extra_bytes;
-            }
-            if (scsiq->d3.done_stat == QD_WITH_ERROR) {
-                if (scsiq->d3.host_stat == QHSTA_M_DATA_OVER_RUN) {
-                    if ((scsiq->cntl & (QC_DATA_IN | QC_DATA_OUT)) == 0) {
-                        scsiq->d3.done_stat = QD_NO_ERROR;
-                        scsiq->d3.host_stat = QHSTA_NO_ERROR;
-                    } else if (false_overrun) {
-                        scsiq->d3.done_stat = QD_NO_ERROR;
-                        scsiq->d3.host_stat = QHSTA_NO_ERROR;
-                    }
-                } else if (scsiq->d3.host_stat ==
-                           QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
-                    AscStopChip(iop_base);
-                    AscSetChipControl(iop_base,
-                        (uchar) (CC_SCSI_RESET | CC_HALT));
-                    DvcDelayNanoSecond(asc_dvc, 60000);
-                    AscSetChipControl(iop_base, CC_HALT);
-                    AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
-                    AscSetChipStatus(iop_base, 0);
-                    AscSetChipControl(iop_base, 0);
-                }
-            }
-            if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
-                (*asc_isr_callback) (asc_dvc, scsiq);
-            } else {
-                if ((AscReadLramByte(iop_base,
-                          (ushort) (q_addr + (ushort) ASC_SCSIQ_CDB_BEG)) ==
-                     START_STOP)) {
-                    asc_dvc->unit_not_ready &= ~target_id;
-                    if (scsiq->d3.done_stat != QD_NO_ERROR) {
-                        asc_dvc->start_motor &= ~target_id;
-                    }
-                }
-            }
-            return (1);
-        } else {
-            AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);
-          FATAL_ERR_QDONE:
-            if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
-                (*asc_isr_callback) (asc_dvc, scsiq);
-            }
-            return (0x80);
-        }
-    }
-    return (0);
+	uchar next_qp;
+	uchar n_q_used;
+	uchar sg_list_qp;
+	uchar sg_queue_cnt;
+	uchar q_cnt;
+	uchar done_q_tail;
+	uchar tid_no;
+	ASC_SCSI_BIT_ID_TYPE scsi_busy;
+	ASC_SCSI_BIT_ID_TYPE target_id;
+	PortAddr iop_base;
+	ushort q_addr;
+	ushort sg_q_addr;
+	uchar cur_target_qng;
+	ASC_QDONE_INFO scsiq_buf;
+	ASC_QDONE_INFO *scsiq;
+	int false_overrun;
+	ASC_ISR_CALLBACK asc_isr_callback;
+
+	iop_base = asc_dvc->iop_base;
+	asc_isr_callback = asc_dvc->isr_callback;
+	n_q_used = 1;
+	scsiq = (ASC_QDONE_INFO *)&scsiq_buf;
+	done_q_tail = (uchar)AscGetVarDoneQTail(iop_base);
+	q_addr = ASC_QNO_TO_QADDR(done_q_tail);
+	next_qp = AscReadLramByte(iop_base,
+				  (ushort)(q_addr + (ushort)ASC_SCSIQ_B_FWD));
+	if (next_qp != ASC_QLINK_END) {
+		AscPutVarDoneQTail(iop_base, next_qp);
+		q_addr = ASC_QNO_TO_QADDR(next_qp);
+		sg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,
+						     asc_dvc->max_dma_count);
+		AscWriteLramByte(iop_base,
+				 (ushort)(q_addr +
+					  (ushort)ASC_SCSIQ_B_STATUS),
+				 (uchar)(scsiq->
+					 q_status & (uchar)~(QS_READY |
+							     QS_ABORTED)));
+		tid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);
+		target_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);
+		if ((scsiq->cntl & QC_SG_HEAD) != 0) {
+			sg_q_addr = q_addr;
+			sg_list_qp = next_qp;
+			for (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {
+				sg_list_qp = AscReadLramByte(iop_base,
+							     (ushort)(sg_q_addr
+								      + (ushort)
+								      ASC_SCSIQ_B_FWD));
+				sg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);
+				if (sg_list_qp == ASC_QLINK_END) {
+					AscSetLibErrorCode(asc_dvc,
+							   ASCQ_ERR_SG_Q_LINKS);
+					scsiq->d3.done_stat = QD_WITH_ERROR;
+					scsiq->d3.host_stat =
+					    QHSTA_D_QDONE_SG_LIST_CORRUPTED;
+					goto FATAL_ERR_QDONE;
+				}
+				AscWriteLramByte(iop_base,
+						 (ushort)(sg_q_addr + (ushort)
+							  ASC_SCSIQ_B_STATUS),
+						 QS_FREE);
+			}
+			n_q_used = sg_queue_cnt + 1;
+			AscPutVarDoneQTail(iop_base, sg_list_qp);
+		}
+		if (asc_dvc->queue_full_or_busy & target_id) {
+			cur_target_qng = AscReadLramByte(iop_base,
+							 (ushort)((ushort)
+								  ASC_QADR_BEG
+								  + (ushort)
+								  scsiq->d2.
+								  target_ix));
+			if (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {
+				scsi_busy = AscReadLramByte(iop_base, (ushort)
+							    ASCV_SCSIBUSY_B);
+				scsi_busy &= ~target_id;
+				AscWriteLramByte(iop_base,
+						 (ushort)ASCV_SCSIBUSY_B,
+						 scsi_busy);
+				asc_dvc->queue_full_or_busy &= ~target_id;
+			}
+		}
+		if (asc_dvc->cur_total_qng >= n_q_used) {
+			asc_dvc->cur_total_qng -= n_q_used;
+			if (asc_dvc->cur_dvc_qng[tid_no] != 0) {
+				asc_dvc->cur_dvc_qng[tid_no]--;
+			}
+		} else {
+			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);
+			scsiq->d3.done_stat = QD_WITH_ERROR;
+			goto FATAL_ERR_QDONE;
+		}
+		if ((scsiq->d2.srb_ptr == 0UL) ||
+		    ((scsiq->q_status & QS_ABORTED) != 0)) {
+			return (0x11);
+		} else if (scsiq->q_status == QS_DONE) {
+			false_overrun = FALSE;
+			if (scsiq->extra_bytes != 0) {
+				scsiq->remain_bytes +=
+				    (ADV_DCNT)scsiq->extra_bytes;
+			}
+			if (scsiq->d3.done_stat == QD_WITH_ERROR) {
+				if (scsiq->d3.host_stat ==
+				    QHSTA_M_DATA_OVER_RUN) {
+					if ((scsiq->
+					     cntl & (QC_DATA_IN | QC_DATA_OUT))
+					    == 0) {
+						scsiq->d3.done_stat =
+						    QD_NO_ERROR;
+						scsiq->d3.host_stat =
+						    QHSTA_NO_ERROR;
+					} else if (false_overrun) {
+						scsiq->d3.done_stat =
+						    QD_NO_ERROR;
+						scsiq->d3.host_stat =
+						    QHSTA_NO_ERROR;
+					}
+				} else if (scsiq->d3.host_stat ==
+					   QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
+					AscStopChip(iop_base);
+					AscSetChipControl(iop_base,
+							  (uchar)(CC_SCSI_RESET
+								  | CC_HALT));
+					DvcDelayNanoSecond(asc_dvc, 60000);
+					AscSetChipControl(iop_base, CC_HALT);
+					AscSetChipStatus(iop_base,
+							 CIW_CLR_SCSI_RESET_INT);
+					AscSetChipStatus(iop_base, 0);
+					AscSetChipControl(iop_base, 0);
+				}
+			}
+			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
+				(*asc_isr_callback) (asc_dvc, scsiq);
+			} else {
+				if ((AscReadLramByte(iop_base,
+						     (ushort)(q_addr + (ushort)
+							      ASC_SCSIQ_CDB_BEG))
+				     == START_STOP)) {
+					asc_dvc->unit_not_ready &= ~target_id;
+					if (scsiq->d3.done_stat != QD_NO_ERROR) {
+						asc_dvc->start_motor &=
+						    ~target_id;
+					}
+				}
+			}
+			return (1);
+		} else {
+			AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);
+ FATAL_ERR_QDONE:
+			if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
+				(*asc_isr_callback) (asc_dvc, scsiq);
+			}
+			return (0x80);
+		}
+	}
+	return (0);
 }
 
-STATIC int
-AscISR(
-          ASC_DVC_VAR *asc_dvc
-)
+static int AscISR(ASC_DVC_VAR *asc_dvc)
 {
-    ASC_CS_TYPE         chipstat;
-    PortAddr            iop_base;
-    ushort              saved_ram_addr;
-    uchar               ctrl_reg;
-    uchar               saved_ctrl_reg;
-    int                 int_pending;
-    int                 status;
-    uchar               host_flag;
-
-    iop_base = asc_dvc->iop_base;
-    int_pending = FALSE;
-
-    if (AscIsIntPending(iop_base) == 0)
-    {
-        return int_pending;
-    }
+	ASC_CS_TYPE chipstat;
+	PortAddr iop_base;
+	ushort saved_ram_addr;
+	uchar ctrl_reg;
+	uchar saved_ctrl_reg;
+	int int_pending;
+	int status;
+	uchar host_flag;
+
+	iop_base = asc_dvc->iop_base;
+	int_pending = FALSE;
+
+	if (AscIsIntPending(iop_base) == 0) {
+		return int_pending;
+	}
 
-    if (((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0)
-        || (asc_dvc->isr_callback == 0)
-) {
-        return (ERR);
-    }
-    if (asc_dvc->in_critical_cnt != 0) {
-        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);
-        return (ERR);
-    }
-    if (asc_dvc->is_in_int) {
-        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);
-        return (ERR);
-    }
-    asc_dvc->is_in_int = TRUE;
-    ctrl_reg = AscGetChipControl(iop_base);
-    saved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |
-                                   CC_SINGLE_STEP | CC_DIAG | CC_TEST));
-    chipstat = AscGetChipStatus(iop_base);
-    if (chipstat & CSW_SCSI_RESET_LATCH) {
-        if (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {
-            int i = 10;
-            int_pending = TRUE;
-            asc_dvc->sdtr_done = 0;
-            saved_ctrl_reg &= (uchar) (~CC_HALT);
-            while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE) &&
-                   (i-- > 0))
-            {
-                  DvcSleepMilliSecond(100);
-            }
-            AscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));
-            AscSetChipControl(iop_base, CC_HALT);
-            AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
-            AscSetChipStatus(iop_base, 0);
-            chipstat = AscGetChipStatus(iop_base);
-        }
-    }
-    saved_ram_addr = AscGetChipLramAddr(iop_base);
-    host_flag = AscReadLramByte(iop_base,
-        ASCV_HOST_FLAG_B) & (uchar) (~ASC_HOST_FLAG_IN_ISR);
-    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
-                     (uchar) (host_flag | (uchar) ASC_HOST_FLAG_IN_ISR));
-    if ((chipstat & CSW_INT_PENDING)
-        || (int_pending)
-) {
-        AscAckInterrupt(iop_base);
-        int_pending = TRUE;
-        if ((chipstat & CSW_HALTED) &&
-            (ctrl_reg & CC_SINGLE_STEP)) {
-            if (AscIsrChipHalted(asc_dvc) == ERR) {
-                goto ISR_REPORT_QDONE_FATAL_ERROR;
-            } else {
-                saved_ctrl_reg &= (uchar) (~CC_HALT);
-            }
-        } else {
-          ISR_REPORT_QDONE_FATAL_ERROR:
-            if ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {
-                while (((status = AscIsrQDone(asc_dvc)) & 0x01) != 0) {
-                }
-            } else {
-                do {
-                    if ((status = AscIsrQDone(asc_dvc)) == 1) {
-                        break;
-                    }
-                } while (status == 0x11);
-            }
-            if ((status & 0x80) != 0)
-                int_pending = ERR;
-        }
-    }
-    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
-    AscSetChipLramAddr(iop_base, saved_ram_addr);
-    AscSetChipControl(iop_base, saved_ctrl_reg);
-    asc_dvc->is_in_int = FALSE;
-    return (int_pending);
+	if (((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0)
+	    || (asc_dvc->isr_callback == 0)
+	    ) {
+		return (ERR);
+	}
+	if (asc_dvc->in_critical_cnt != 0) {
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);
+		return (ERR);
+	}
+	if (asc_dvc->is_in_int) {
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);
+		return (ERR);
+	}
+	asc_dvc->is_in_int = TRUE;
+	ctrl_reg = AscGetChipControl(iop_base);
+	saved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |
+				       CC_SINGLE_STEP | CC_DIAG | CC_TEST));
+	chipstat = AscGetChipStatus(iop_base);
+	if (chipstat & CSW_SCSI_RESET_LATCH) {
+		if (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {
+			int i = 10;
+			int_pending = TRUE;
+			asc_dvc->sdtr_done = 0;
+			saved_ctrl_reg &= (uchar)(~CC_HALT);
+			while ((AscGetChipStatus(iop_base) &
+				CSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {
+				DvcSleepMilliSecond(100);
+			}
+			AscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));
+			AscSetChipControl(iop_base, CC_HALT);
+			AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+			AscSetChipStatus(iop_base, 0);
+			chipstat = AscGetChipStatus(iop_base);
+		}
+	}
+	saved_ram_addr = AscGetChipLramAddr(iop_base);
+	host_flag = AscReadLramByte(iop_base,
+				    ASCV_HOST_FLAG_B) &
+	    (uchar)(~ASC_HOST_FLAG_IN_ISR);
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
+			 (uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));
+	if ((chipstat & CSW_INT_PENDING)
+	    || (int_pending)
+	    ) {
+		AscAckInterrupt(iop_base);
+		int_pending = TRUE;
+		if ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {
+			if (AscIsrChipHalted(asc_dvc) == ERR) {
+				goto ISR_REPORT_QDONE_FATAL_ERROR;
+			} else {
+				saved_ctrl_reg &= (uchar)(~CC_HALT);
+			}
+		} else {
+ ISR_REPORT_QDONE_FATAL_ERROR:
+			if ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {
+				while (((status =
+					 AscIsrQDone(asc_dvc)) & 0x01) != 0) {
+				}
+			} else {
+				do {
+					if ((status =
+					     AscIsrQDone(asc_dvc)) == 1) {
+						break;
+					}
+				} while (status == 0x11);
+			}
+			if ((status & 0x80) != 0)
+				int_pending = ERR;
+		}
+	}
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
+	AscSetChipLramAddr(iop_base, saved_ram_addr);
+	AscSetChipControl(iop_base, saved_ctrl_reg);
+	asc_dvc->is_in_int = FALSE;
+	return (int_pending);
 }
 
 /* Microcode buffer is kept after initialization for error recovery. */
-STATIC uchar _asc_mcode_buf[] =
-{
-  0x01,  0x03,  0x01,  0x19,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
-  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
-  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
-  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
-  0x00,  0x00,  0x00,  0x00,  0xC3,  0x12,  0x0D,  0x05,  0x01,  0x00,  0x00,  0x00,  0x00,  0xFF,  0x00,  0x00,
-  0x00,  0x00,  0x00,  0x00,  0xFF,  0x80,  0xFF,  0xFF,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
-  0x00,  0x00,  0x00,  0x23,  0x00,  0x00,  0x00,  0x00,  0x00,  0x07,  0x00,  0xFF,  0x00,  0x00,  0x00,  0x00,
-  0xFF,  0xFF,  0xFF,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0xE4,  0x88,  0x00,  0x00,  0x00,  0x00,
-  0x80,  0x73,  0x48,  0x04,  0x36,  0x00,  0x00,  0xA2,  0xC2,  0x00,  0x80,  0x73,  0x03,  0x23,  0x36,  0x40,
-  0xB6,  0x00,  0x36,  0x00,  0x05,  0xD6,  0x0C,  0xD2,  0x12,  0xDA,  0x00,  0xA2,  0xC2,  0x00,  0x92,  0x80,
-  0x1E,  0x98,  0x50,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xDF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,
-  0x4F,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xEF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,  0x80,  0x62,
-  0x92,  0x80,  0x00,  0x46,  0x15,  0xEE,  0x13,  0xEA,  0x02,  0x01,  0x09,  0xD8,  0xCD,  0x04,  0x4D,  0x00,
-  0x00,  0xA3,  0xD6,  0x00,  0xA6,  0x97,  0x7F,  0x23,  0x04,  0x61,  0x84,  0x01,  0xE6,  0x84,  0xD2,  0xC1,
-  0x80,  0x73,  0xCD,  0x04,  0x4D,  0x00,  0x00,  0xA3,  0xDA,  0x01,  0xA6,  0x97,  0xC6,  0x81,  0xC2,  0x88,
-  0x80,  0x73,  0x80,  0x77,  0x00,  0x01,  0x01,  0xA1,  0xFE,  0x00,  0x4F,  0x00,  0x84,  0x97,  0x07,  0xA6,
-  0x08,  0x01,  0x00,  0x33,  0x03,  0x00,  0xC2,  0x88,  0x03,  0x03,  0x01,  0xDE,  0xC2,  0x88,  0xCE,  0x00,
-  0x69,  0x60,  0xCE,  0x00,  0x02,  0x03,  0x4A,  0x60,  0x00,  0xA2,  0x78,  0x01,  0x80,  0x63,  0x07,  0xA6,
-  0x24,  0x01,  0x78,  0x81,  0x03,  0x03,  0x80,  0x63,  0xE2,  0x00,  0x07,  0xA6,  0x34,  0x01,  0x00,  0x33,
-  0x04,  0x00,  0xC2,  0x88,  0x03,  0x07,  0x02,  0x01,  0x04,  0xCA,  0x0D,  0x23,  0x68,  0x98,  0x4D,  0x04,
-  0x04,  0x85,  0x05,  0xD8,  0x0D,  0x23,  0x68,  0x98,  0xCD,  0x04,  0x15,  0x23,  0xF8,  0x88,  0xFB,  0x23,
-  0x02,  0x61,  0x82,  0x01,  0x80,  0x63,  0x02,  0x03,  0x06,  0xA3,  0x62,  0x01,  0x00,  0x33,  0x0A,  0x00,
-  0xC2,  0x88,  0x4E,  0x00,  0x07,  0xA3,  0x6E,  0x01,  0x00,  0x33,  0x0B,  0x00,  0xC2,  0x88,  0xCD,  0x04,
-  0x36,  0x2D,  0x00,  0x33,  0x1A,  0x00,  0xC2,  0x88,  0x50,  0x04,  0x88,  0x81,  0x06,  0xAB,  0x82,  0x01,
-  0x88,  0x81,  0x4E,  0x00,  0x07,  0xA3,  0x92,  0x01,  0x50,  0x00,  0x00,  0xA3,  0x3C,  0x01,  0x00,  0x05,
-  0x7C,  0x81,  0x46,  0x97,  0x02,  0x01,  0x05,  0xC6,  0x04,  0x23,  0xA0,  0x01,  0x15,  0x23,  0xA1,  0x01,
-  0xBE,  0x81,  0xFD,  0x23,  0x02,  0x61,  0x82,  0x01,  0x0A,  0xDA,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,
-  0xB4,  0x01,  0x80,  0x63,  0xCD,  0x04,  0x36,  0x2D,  0x00,  0x33,  0x1B,  0x00,  0xC2,  0x88,  0x06,  0x23,
-  0x68,  0x98,  0xCD,  0x04,  0xE6,  0x84,  0x06,  0x01,  0x00,  0xA2,  0xD4,  0x01,  0x57,  0x60,  0x00,  0xA0,
-  0xDA,  0x01,  0xE6,  0x84,  0x80,  0x23,  0xA0,  0x01,  0xE6,  0x84,  0x80,  0x73,  0x4B,  0x00,  0x06,  0x61,
-  0x00,  0xA2,  0x00,  0x02,  0x04,  0x01,  0x0C,  0xDE,  0x02,  0x01,  0x03,  0xCC,  0x4F,  0x00,  0x84,  0x97,
-  0xFC,  0x81,  0x08,  0x23,  0x02,  0x41,  0x82,  0x01,  0x4F,  0x00,  0x62,  0x97,  0x48,  0x04,  0x84,  0x80,
-  0xF0,  0x97,  0x00,  0x46,  0x56,  0x00,  0x03,  0xC0,  0x01,  0x23,  0xE8,  0x00,  0x81,  0x73,  0x06,  0x29,
-  0x03,  0x42,  0x06,  0xE2,  0x03,  0xEE,  0x6B,  0xEB,  0x11,  0x23,  0xF8,  0x88,  0x04,  0x98,  0xF0,  0x80,
-  0x80,  0x73,  0x80,  0x77,  0x07,  0xA4,  0x2A,  0x02,  0x7C,  0x95,  0x06,  0xA6,  0x34,  0x02,  0x03,  0xA6,
-  0x4C,  0x04,  0x46,  0x82,  0x04,  0x01,  0x03,  0xD8,  0xB4,  0x98,  0x6A,  0x96,  0x46,  0x82,  0xFE,  0x95,
-  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0xB6,  0x2D,  0x02,  0xA6,  0x6C,  0x02,  0x07,  0xA6,  0x5A,  0x02,
-  0x06,  0xA6,  0x5E,  0x02,  0x03,  0xA6,  0x62,  0x02,  0xC2,  0x88,  0x7C,  0x95,  0x48,  0x82,  0x60,  0x96,
-  0x48,  0x82,  0x04,  0x23,  0xA0,  0x01,  0x14,  0x23,  0xA1,  0x01,  0x3C,  0x84,  0x04,  0x01,  0x0C,  0xDC,
-  0xE0,  0x23,  0x25,  0x61,  0xEF,  0x00,  0x14,  0x01,  0x4F,  0x04,  0xA8,  0x01,  0x6F,  0x00,  0xA5,  0x01,
-  0x03,  0x23,  0xA4,  0x01,  0x06,  0x23,  0x9C,  0x01,  0x24,  0x2B,  0x1C,  0x01,  0x02,  0xA6,  0xAA,  0x02,
-  0x07,  0xA6,  0x5A,  0x02,  0x06,  0xA6,  0x5E,  0x02,  0x03,  0xA6,  0x20,  0x04,  0x01,  0xA6,  0xB4,  0x02,
-  0x00,  0xA6,  0xB4,  0x02,  0x00,  0x33,  0x12,  0x00,  0xC2,  0x88,  0x00,  0x0E,  0x80,  0x63,  0x00,  0x43,
-  0x00,  0xA0,  0x8C,  0x02,  0x4D,  0x04,  0x04,  0x01,  0x0B,  0xDC,  0xE7,  0x23,  0x04,  0x61,  0x84,  0x01,
-  0x10,  0x31,  0x12,  0x35,  0x14,  0x01,  0xEC,  0x00,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,  0xEA,  0x82,
-  0x18,  0x23,  0x04,  0x61,  0x18,  0xA0,  0xE2,  0x02,  0x04,  0x01,  0xA2,  0xC8,  0x00,  0x33,  0x1F,  0x00,
-  0xC2,  0x88,  0x08,  0x31,  0x0A,  0x35,  0x0C,  0x39,  0x0E,  0x3D,  0x7E,  0x98,  0xB6,  0x2D,  0x01,  0xA6,
-  0x14,  0x03,  0x00,  0xA6,  0x14,  0x03,  0x07,  0xA6,  0x0C,  0x03,  0x06,  0xA6,  0x10,  0x03,  0x03,  0xA6,
-  0x20,  0x04,  0x02,  0xA6,  0x6C,  0x02,  0x00,  0x33,  0x33,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0xEE,  0x82,
-  0x60,  0x96,  0xEE,  0x82,  0x82,  0x98,  0x80,  0x42,  0x7E,  0x98,  0x64,  0xE4,  0x04,  0x01,  0x2D,  0xC8,
-  0x31,  0x05,  0x07,  0x01,  0x00,  0xA2,  0x54,  0x03,  0x00,  0x43,  0x87,  0x01,  0x05,  0x05,  0x86,  0x98,
-  0x7E,  0x98,  0x00,  0xA6,  0x16,  0x03,  0x07,  0xA6,  0x4C,  0x03,  0x03,  0xA6,  0x3C,  0x04,  0x06,  0xA6,
-  0x50,  0x03,  0x01,  0xA6,  0x16,  0x03,  0x00,  0x33,  0x25,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0x32,  0x83,
-  0x60,  0x96,  0x32,  0x83,  0x04,  0x01,  0x10,  0xCE,  0x07,  0xC8,  0x05,  0x05,  0xEB,  0x04,  0x00,  0x33,
-  0x00,  0x20,  0xC0,  0x20,  0x81,  0x62,  0x72,  0x83,  0x00,  0x01,  0x05,  0x05,  0xFF,  0xA2,  0x7A,  0x03,
-  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x2E,  0x83,  0x05,  0x05,  0x15,  0x01,  0x00,  0xA2,  0x9A,  0x03,
-  0xEC,  0x00,  0x6E,  0x00,  0x95,  0x01,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,  0x01,  0xA6,  0x96,  0x03,
-  0x00,  0xA6,  0x96,  0x03,  0x10,  0x84,  0x80,  0x42,  0x7E,  0x98,  0x01,  0xA6,  0xA4,  0x03,  0x00,  0xA6,
-  0xBC,  0x03,  0x10,  0x84,  0xA8,  0x98,  0x80,  0x42,  0x01,  0xA6,  0xA4,  0x03,  0x07,  0xA6,  0xB2,  0x03,
-  0xD4,  0x83,  0x7C,  0x95,  0xA8,  0x83,  0x00,  0x33,  0x2F,  0x00,  0xC2,  0x88,  0xA8,  0x98,  0x80,  0x42,
-  0x00,  0xA6,  0xBC,  0x03,  0x07,  0xA6,  0xCA,  0x03,  0xD4,  0x83,  0x7C,  0x95,  0xC0,  0x83,  0x00,  0x33,
-  0x26,  0x00,  0xC2,  0x88,  0x38,  0x2B,  0x80,  0x32,  0x80,  0x36,  0x04,  0x23,  0xA0,  0x01,  0x12,  0x23,
-  0xA1,  0x01,  0x10,  0x84,  0x07,  0xF0,  0x06,  0xA4,  0xF4,  0x03,  0x80,  0x6B,  0x80,  0x67,  0x05,  0x23,
-  0x83,  0x03,  0x80,  0x63,  0x03,  0xA6,  0x0E,  0x04,  0x07,  0xA6,  0x06,  0x04,  0x06,  0xA6,  0x0A,  0x04,
-  0x00,  0x33,  0x17,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0xF4,  0x83,  0x60,  0x96,  0xF4,  0x83,  0x20,  0x84,
-  0x07,  0xF0,  0x06,  0xA4,  0x20,  0x04,  0x80,  0x6B,  0x80,  0x67,  0x05,  0x23,  0x83,  0x03,  0x80,  0x63,
-  0xB6,  0x2D,  0x03,  0xA6,  0x3C,  0x04,  0x07,  0xA6,  0x34,  0x04,  0x06,  0xA6,  0x38,  0x04,  0x00,  0x33,
-  0x30,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0x20,  0x84,  0x60,  0x96,  0x20,  0x84,  0x1D,  0x01,  0x06,  0xCC,
-  0x00,  0x33,  0x00,  0x84,  0xC0,  0x20,  0x00,  0x23,  0xEA,  0x00,  0x81,  0x62,  0xA2,  0x0D,  0x80,  0x63,
-  0x07,  0xA6,  0x5A,  0x04,  0x00,  0x33,  0x18,  0x00,  0xC2,  0x88,  0x03,  0x03,  0x80,  0x63,  0xA3,  0x01,
-  0x07,  0xA4,  0x64,  0x04,  0x23,  0x01,  0x00,  0xA2,  0x86,  0x04,  0x0A,  0xA0,  0x76,  0x04,  0xE0,  0x00,
-  0x00,  0x33,  0x1D,  0x00,  0xC2,  0x88,  0x0B,  0xA0,  0x82,  0x04,  0xE0,  0x00,  0x00,  0x33,  0x1E,  0x00,
-  0xC2,  0x88,  0x42,  0x23,  0xF8,  0x88,  0x00,  0x23,  0x22,  0xA3,  0xE6,  0x04,  0x08,  0x23,  0x22,  0xA3,
-  0xA2,  0x04,  0x28,  0x23,  0x22,  0xA3,  0xAE,  0x04,  0x02,  0x23,  0x22,  0xA3,  0xC4,  0x04,  0x42,  0x23,
-  0xF8,  0x88,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,  0xAE,  0x04,  0x45,  0x23,  0xF8,  0x88,  0x04,  0x98,
-  0x00,  0xA2,  0xC0,  0x04,  0xB4,  0x98,  0x00,  0x33,  0x00,  0x82,  0xC0,  0x20,  0x81,  0x62,  0xE8,  0x81,
-  0x47,  0x23,  0xF8,  0x88,  0x04,  0x01,  0x0B,  0xDE,  0x04,  0x98,  0xB4,  0x98,  0x00,  0x33,  0x00,  0x81,
-  0xC0,  0x20,  0x81,  0x62,  0x14,  0x01,  0x00,  0xA0,  0x00,  0x02,  0x43,  0x23,  0xF8,  0x88,  0x04,  0x23,
-  0xA0,  0x01,  0x44,  0x23,  0xA1,  0x01,  0x80,  0x73,  0x4D,  0x00,  0x03,  0xA3,  0xF4,  0x04,  0x00,  0x33,
-  0x27,  0x00,  0xC2,  0x88,  0x04,  0x01,  0x04,  0xDC,  0x02,  0x23,  0xA2,  0x01,  0x04,  0x23,  0xA0,  0x01,
-  0x04,  0x98,  0x26,  0x95,  0x4B,  0x00,  0xF6,  0x00,  0x4F,  0x04,  0x4F,  0x00,  0x00,  0xA3,  0x22,  0x05,
-  0x00,  0x05,  0x76,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x1C,  0x05,  0x0A,  0x85,  0x46,  0x97,  0xCD,  0x04,
-  0x24,  0x85,  0x48,  0x04,  0x84,  0x80,  0x02,  0x01,  0x03,  0xDA,  0x80,  0x23,  0x82,  0x01,  0x34,  0x85,
-  0x02,  0x23,  0xA0,  0x01,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x40,  0x05,  0x1D,  0x01,  0x04,  0xD6,
-  0xFF,  0x23,  0x86,  0x41,  0x4B,  0x60,  0xCB,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x49,  0x00,  0x81,  0x01,
-  0x04,  0x01,  0x02,  0xC8,  0x30,  0x01,  0x80,  0x01,  0xF7,  0x04,  0x03,  0x01,  0x49,  0x04,  0x80,  0x01,
-  0xC9,  0x00,  0x00,  0x05,  0x00,  0x01,  0xFF,  0xA0,  0x60,  0x05,  0x77,  0x04,  0x01,  0x23,  0xEA,  0x00,
-  0x5D,  0x00,  0xFE,  0xC7,  0x00,  0x62,  0x00,  0x23,  0xEA,  0x00,  0x00,  0x63,  0x07,  0xA4,  0xF8,  0x05,
-  0x03,  0x03,  0x02,  0xA0,  0x8E,  0x05,  0xF4,  0x85,  0x00,  0x33,  0x2D,  0x00,  0xC2,  0x88,  0x04,  0xA0,
-  0xB8,  0x05,  0x80,  0x63,  0x00,  0x23,  0xDF,  0x00,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0xA4,  0x05,
-  0x1D,  0x01,  0x06,  0xD6,  0x02,  0x23,  0x02,  0x41,  0x82,  0x01,  0x50,  0x00,  0x62,  0x97,  0x04,  0x85,
-  0x04,  0x23,  0x02,  0x41,  0x82,  0x01,  0x04,  0x85,  0x08,  0xA0,  0xBE,  0x05,  0xF4,  0x85,  0x03,  0xA0,
-  0xC4,  0x05,  0xF4,  0x85,  0x01,  0xA0,  0xCE,  0x05,  0x88,  0x00,  0x80,  0x63,  0xCC,  0x86,  0x07,  0xA0,
-  0xEE,  0x05,  0x5F,  0x00,  0x00,  0x2B,  0xDF,  0x08,  0x00,  0xA2,  0xE6,  0x05,  0x80,  0x67,  0x80,  0x63,
-  0x01,  0xA2,  0x7A,  0x06,  0x7C,  0x85,  0x06,  0x23,  0x68,  0x98,  0x48,  0x23,  0xF8,  0x88,  0x07,  0x23,
-  0x80,  0x00,  0x06,  0x87,  0x80,  0x63,  0x7C,  0x85,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x4A,  0x00,
-  0x06,  0x61,  0x00,  0xA2,  0x36,  0x06,  0x1D,  0x01,  0x16,  0xD4,  0xC0,  0x23,  0x07,  0x41,  0x83,  0x03,
-  0x80,  0x63,  0x06,  0xA6,  0x1C,  0x06,  0x00,  0x33,  0x37,  0x00,  0xC2,  0x88,  0x1D,  0x01,  0x01,  0xD6,
-  0x20,  0x23,  0x63,  0x60,  0x83,  0x03,  0x80,  0x63,  0x02,  0x23,  0xDF,  0x00,  0x07,  0xA6,  0x7C,  0x05,
-  0xEF,  0x04,  0x6F,  0x00,  0x00,  0x63,  0x4B,  0x00,  0x06,  0x41,  0xCB,  0x00,  0x52,  0x00,  0x06,  0x61,
-  0x00,  0xA2,  0x4E,  0x06,  0x1D,  0x01,  0x03,  0xCA,  0xC0,  0x23,  0x07,  0x41,  0x00,  0x63,  0x1D,  0x01,
-  0x04,  0xCC,  0x00,  0x33,  0x00,  0x83,  0xC0,  0x20,  0x81,  0x62,  0x80,  0x23,  0x07,  0x41,  0x00,  0x63,
-  0x80,  0x67,  0x08,  0x23,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x01,  0x23,  0xDF,  0x00,  0x06,  0xA6,
-  0x84,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x80,  0x63,  0x00,  0x33,  0x00,  0x40,  0xC0,  0x20,
-  0x81,  0x62,  0x00,  0x63,  0x00,  0x00,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,  0x94,  0x06,
-  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x00,  0x01,  0xA0,  0x14,  0x07,  0x00,  0x2B,  0x40,  0x0E,  0x80,  0x63,
-  0x01,  0x00,  0x06,  0xA6,  0xAA,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x40,  0x0E,  0x80,  0x63,  0x00,  0x43,
-  0x00,  0xA0,  0xA2,  0x06,  0x06,  0xA6,  0xBC,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x40,  0x0E,
-  0x80,  0x63,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x07,  0xA6,  0xD6,  0x06,
-  0x00,  0x33,  0x2A,  0x00,  0xC2,  0x88,  0x03,  0x03,  0x80,  0x63,  0x89,  0x00,  0x0A,  0x2B,  0x07,  0xA6,
-  0xE8,  0x06,  0x00,  0x33,  0x29,  0x00,  0xC2,  0x88,  0x00,  0x43,  0x00,  0xA2,  0xF4,  0x06,  0xC0,  0x0E,
-  0x80,  0x63,  0xDE,  0x86,  0xC0,  0x0E,  0x00,  0x33,  0x00,  0x80,  0xC0,  0x20,  0x81,  0x62,  0x04,  0x01,
-  0x02,  0xDA,  0x80,  0x63,  0x7C,  0x85,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x8C,  0x06,  0x00,  0x33,
-  0x2C,  0x00,  0xC2,  0x88,  0x0C,  0xA2,  0x2E,  0x07,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,
-  0x2C,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x33,  0x3D,  0x00,  0xC2,  0x88,  0x00,  0x00,  0x80,  0x67,
-  0x83,  0x03,  0x80,  0x63,  0x0C,  0xA0,  0x44,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0xBF,  0x23,  0x04,  0x61,
-  0x84,  0x01,  0xE6,  0x84,  0x00,  0x63,  0xF0,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x00,  0x01,  0xF2,  0x00,
-  0x01,  0x05,  0x80,  0x01,  0x72,  0x04,  0x71,  0x00,  0x81,  0x01,  0x70,  0x04,  0x80,  0x05,  0x81,  0x05,
-  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x70,  0x00,  0x81,  0x01,
-  0x70,  0x04,  0x71,  0x00,  0x81,  0x01,  0x72,  0x00,  0x80,  0x01,  0x71,  0x04,  0x70,  0x00,  0x80,  0x01,
-  0x70,  0x04,  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x00,  0x01,  0xF1,  0x00,  0x70,  0x00,
-  0x80,  0x01,  0x70,  0x04,  0x71,  0x00,  0x80,  0x01,  0x72,  0x00,  0x81,  0x01,  0x71,  0x04,  0x70,  0x00,
-  0x81,  0x01,  0x70,  0x04,  0x00,  0x63,  0x00,  0x23,  0xB3,  0x01,  0x83,  0x05,  0xA3,  0x01,  0xA2,  0x01,
-  0xA1,  0x01,  0x01,  0x23,  0xA0,  0x01,  0x00,  0x01,  0xC8,  0x00,  0x03,  0xA1,  0xC4,  0x07,  0x00,  0x33,
-  0x07,  0x00,  0xC2,  0x88,  0x80,  0x05,  0x81,  0x05,  0x04,  0x01,  0x11,  0xC8,  0x48,  0x00,  0xB0,  0x01,
-  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x05,  0x01,  0x48,  0x04,  0x00,  0x43,  0x00,  0xA2,  0xE4,  0x07,
-  0x00,  0x05,  0xDA,  0x87,  0x00,  0x01,  0xC8,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x05,  0x05,  0x00,  0x63,
-  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x80,  0x43,  0x76,  0x08,  0x80,  0x02,
-  0x77,  0x04,  0x00,  0x63,  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x00,  0xA0,
-  0x14,  0x08,  0x16,  0x88,  0x00,  0x43,  0x76,  0x08,  0x80,  0x02,  0x77,  0x04,  0x00,  0x63,  0xF3,  0x04,
-  0x00,  0x23,  0xF4,  0x00,  0x74,  0x00,  0x80,  0x43,  0xF4,  0x00,  0xCF,  0x40,  0x00,  0xA2,  0x44,  0x08,
-  0x74,  0x04,  0x02,  0x01,  0xF7,  0xC9,  0xF6,  0xD9,  0x00,  0x01,  0x01,  0xA1,  0x24,  0x08,  0x04,  0x98,
-  0x26,  0x95,  0x24,  0x88,  0x73,  0x04,  0x00,  0x63,  0xF3,  0x04,  0x75,  0x04,  0x5A,  0x88,  0x02,  0x01,
-  0x04,  0xD8,  0x46,  0x97,  0x04,  0x98,  0x26,  0x95,  0x4A,  0x88,  0x75,  0x00,  0x00,  0xA3,  0x64,  0x08,
-  0x00,  0x05,  0x4E,  0x88,  0x73,  0x04,  0x00,  0x63,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x76,  0x08,
-  0x00,  0x33,  0x3E,  0x00,  0xC2,  0x88,  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x38,  0x2B,
-  0x9C,  0x88,  0x38,  0x2B,  0x92,  0x88,  0x32,  0x09,  0x31,  0x05,  0x92,  0x98,  0x05,  0x05,  0xB2,  0x09,
-  0x00,  0x63,  0x00,  0x32,  0x00,  0x36,  0x00,  0x3A,  0x00,  0x3E,  0x00,  0x63,  0x80,  0x32,  0x80,  0x36,
-  0x80,  0x3A,  0x80,  0x3E,  0xB4,  0x3D,  0x00,  0x63,  0x38,  0x2B,  0x40,  0x32,  0x40,  0x36,  0x40,  0x3A,
-  0x40,  0x3E,  0x00,  0x63,  0x5A,  0x20,  0xC9,  0x40,  0x00,  0xA0,  0xB4,  0x08,  0x5D,  0x00,  0xFE,  0xC3,
-  0x00,  0x63,  0x80,  0x73,  0xE6,  0x20,  0x02,  0x23,  0xE8,  0x00,  0x82,  0x73,  0xFF,  0xFD,  0x80,  0x73,
-  0x13,  0x23,  0xF8,  0x88,  0x66,  0x20,  0xC0,  0x20,  0x04,  0x23,  0xA0,  0x01,  0xA1,  0x23,  0xA1,  0x01,
-  0x81,  0x62,  0xE2,  0x88,  0x80,  0x73,  0x80,  0x77,  0x68,  0x00,  0x00,  0xA2,  0x80,  0x00,  0x03,  0xC2,
-  0xF1,  0xC7,  0x41,  0x23,  0xF8,  0x88,  0x11,  0x23,  0xA1,  0x01,  0x04,  0x23,  0xA0,  0x01,  0xE6,  0x84,
+static uchar _asc_mcode_buf[] = {
+	0x01, 0x03, 0x01, 0x19, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xC3, 0x12, 0x0D, 0x05, 0x01, 0x00, 0x00, 0x00,
+	0x00, 0xFF, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0xFF,
+	0x00, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x88,
+	0x00, 0x00, 0x00, 0x00,
+	0x80, 0x73, 0x48, 0x04, 0x36, 0x00, 0x00, 0xA2, 0xC2, 0x00, 0x80, 0x73,
+	0x03, 0x23, 0x36, 0x40,
+	0xB6, 0x00, 0x36, 0x00, 0x05, 0xD6, 0x0C, 0xD2, 0x12, 0xDA, 0x00, 0xA2,
+	0xC2, 0x00, 0x92, 0x80,
+	0x1E, 0x98, 0x50, 0x00, 0xF5, 0x00, 0x48, 0x98, 0xDF, 0x23, 0x36, 0x60,
+	0xB6, 0x00, 0x92, 0x80,
+	0x4F, 0x00, 0xF5, 0x00, 0x48, 0x98, 0xEF, 0x23, 0x36, 0x60, 0xB6, 0x00,
+	0x92, 0x80, 0x80, 0x62,
+	0x92, 0x80, 0x00, 0x46, 0x15, 0xEE, 0x13, 0xEA, 0x02, 0x01, 0x09, 0xD8,
+	0xCD, 0x04, 0x4D, 0x00,
+	0x00, 0xA3, 0xD6, 0x00, 0xA6, 0x97, 0x7F, 0x23, 0x04, 0x61, 0x84, 0x01,
+	0xE6, 0x84, 0xD2, 0xC1,
+	0x80, 0x73, 0xCD, 0x04, 0x4D, 0x00, 0x00, 0xA3, 0xDA, 0x01, 0xA6, 0x97,
+	0xC6, 0x81, 0xC2, 0x88,
+	0x80, 0x73, 0x80, 0x77, 0x00, 0x01, 0x01, 0xA1, 0xFE, 0x00, 0x4F, 0x00,
+	0x84, 0x97, 0x07, 0xA6,
+	0x08, 0x01, 0x00, 0x33, 0x03, 0x00, 0xC2, 0x88, 0x03, 0x03, 0x01, 0xDE,
+	0xC2, 0x88, 0xCE, 0x00,
+	0x69, 0x60, 0xCE, 0x00, 0x02, 0x03, 0x4A, 0x60, 0x00, 0xA2, 0x78, 0x01,
+	0x80, 0x63, 0x07, 0xA6,
+	0x24, 0x01, 0x78, 0x81, 0x03, 0x03, 0x80, 0x63, 0xE2, 0x00, 0x07, 0xA6,
+	0x34, 0x01, 0x00, 0x33,
+	0x04, 0x00, 0xC2, 0x88, 0x03, 0x07, 0x02, 0x01, 0x04, 0xCA, 0x0D, 0x23,
+	0x68, 0x98, 0x4D, 0x04,
+	0x04, 0x85, 0x05, 0xD8, 0x0D, 0x23, 0x68, 0x98, 0xCD, 0x04, 0x15, 0x23,
+	0xF8, 0x88, 0xFB, 0x23,
+	0x02, 0x61, 0x82, 0x01, 0x80, 0x63, 0x02, 0x03, 0x06, 0xA3, 0x62, 0x01,
+	0x00, 0x33, 0x0A, 0x00,
+	0xC2, 0x88, 0x4E, 0x00, 0x07, 0xA3, 0x6E, 0x01, 0x00, 0x33, 0x0B, 0x00,
+	0xC2, 0x88, 0xCD, 0x04,
+	0x36, 0x2D, 0x00, 0x33, 0x1A, 0x00, 0xC2, 0x88, 0x50, 0x04, 0x88, 0x81,
+	0x06, 0xAB, 0x82, 0x01,
+	0x88, 0x81, 0x4E, 0x00, 0x07, 0xA3, 0x92, 0x01, 0x50, 0x00, 0x00, 0xA3,
+	0x3C, 0x01, 0x00, 0x05,
+	0x7C, 0x81, 0x46, 0x97, 0x02, 0x01, 0x05, 0xC6, 0x04, 0x23, 0xA0, 0x01,
+	0x15, 0x23, 0xA1, 0x01,
+	0xBE, 0x81, 0xFD, 0x23, 0x02, 0x61, 0x82, 0x01, 0x0A, 0xDA, 0x4A, 0x00,
+	0x06, 0x61, 0x00, 0xA0,
+	0xB4, 0x01, 0x80, 0x63, 0xCD, 0x04, 0x36, 0x2D, 0x00, 0x33, 0x1B, 0x00,
+	0xC2, 0x88, 0x06, 0x23,
+	0x68, 0x98, 0xCD, 0x04, 0xE6, 0x84, 0x06, 0x01, 0x00, 0xA2, 0xD4, 0x01,
+	0x57, 0x60, 0x00, 0xA0,
+	0xDA, 0x01, 0xE6, 0x84, 0x80, 0x23, 0xA0, 0x01, 0xE6, 0x84, 0x80, 0x73,
+	0x4B, 0x00, 0x06, 0x61,
+	0x00, 0xA2, 0x00, 0x02, 0x04, 0x01, 0x0C, 0xDE, 0x02, 0x01, 0x03, 0xCC,
+	0x4F, 0x00, 0x84, 0x97,
+	0xFC, 0x81, 0x08, 0x23, 0x02, 0x41, 0x82, 0x01, 0x4F, 0x00, 0x62, 0x97,
+	0x48, 0x04, 0x84, 0x80,
+	0xF0, 0x97, 0x00, 0x46, 0x56, 0x00, 0x03, 0xC0, 0x01, 0x23, 0xE8, 0x00,
+	0x81, 0x73, 0x06, 0x29,
+	0x03, 0x42, 0x06, 0xE2, 0x03, 0xEE, 0x6B, 0xEB, 0x11, 0x23, 0xF8, 0x88,
+	0x04, 0x98, 0xF0, 0x80,
+	0x80, 0x73, 0x80, 0x77, 0x07, 0xA4, 0x2A, 0x02, 0x7C, 0x95, 0x06, 0xA6,
+	0x34, 0x02, 0x03, 0xA6,
+	0x4C, 0x04, 0x46, 0x82, 0x04, 0x01, 0x03, 0xD8, 0xB4, 0x98, 0x6A, 0x96,
+	0x46, 0x82, 0xFE, 0x95,
+	0x80, 0x67, 0x83, 0x03, 0x80, 0x63, 0xB6, 0x2D, 0x02, 0xA6, 0x6C, 0x02,
+	0x07, 0xA6, 0x5A, 0x02,
+	0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x62, 0x02, 0xC2, 0x88, 0x7C, 0x95,
+	0x48, 0x82, 0x60, 0x96,
+	0x48, 0x82, 0x04, 0x23, 0xA0, 0x01, 0x14, 0x23, 0xA1, 0x01, 0x3C, 0x84,
+	0x04, 0x01, 0x0C, 0xDC,
+	0xE0, 0x23, 0x25, 0x61, 0xEF, 0x00, 0x14, 0x01, 0x4F, 0x04, 0xA8, 0x01,
+	0x6F, 0x00, 0xA5, 0x01,
+	0x03, 0x23, 0xA4, 0x01, 0x06, 0x23, 0x9C, 0x01, 0x24, 0x2B, 0x1C, 0x01,
+	0x02, 0xA6, 0xAA, 0x02,
+	0x07, 0xA6, 0x5A, 0x02, 0x06, 0xA6, 0x5E, 0x02, 0x03, 0xA6, 0x20, 0x04,
+	0x01, 0xA6, 0xB4, 0x02,
+	0x00, 0xA6, 0xB4, 0x02, 0x00, 0x33, 0x12, 0x00, 0xC2, 0x88, 0x00, 0x0E,
+	0x80, 0x63, 0x00, 0x43,
+	0x00, 0xA0, 0x8C, 0x02, 0x4D, 0x04, 0x04, 0x01, 0x0B, 0xDC, 0xE7, 0x23,
+	0x04, 0x61, 0x84, 0x01,
+	0x10, 0x31, 0x12, 0x35, 0x14, 0x01, 0xEC, 0x00, 0x6C, 0x38, 0x00, 0x3F,
+	0x00, 0x00, 0xEA, 0x82,
+	0x18, 0x23, 0x04, 0x61, 0x18, 0xA0, 0xE2, 0x02, 0x04, 0x01, 0xA2, 0xC8,
+	0x00, 0x33, 0x1F, 0x00,
+	0xC2, 0x88, 0x08, 0x31, 0x0A, 0x35, 0x0C, 0x39, 0x0E, 0x3D, 0x7E, 0x98,
+	0xB6, 0x2D, 0x01, 0xA6,
+	0x14, 0x03, 0x00, 0xA6, 0x14, 0x03, 0x07, 0xA6, 0x0C, 0x03, 0x06, 0xA6,
+	0x10, 0x03, 0x03, 0xA6,
+	0x20, 0x04, 0x02, 0xA6, 0x6C, 0x02, 0x00, 0x33, 0x33, 0x00, 0xC2, 0x88,
+	0x7C, 0x95, 0xEE, 0x82,
+	0x60, 0x96, 0xEE, 0x82, 0x82, 0x98, 0x80, 0x42, 0x7E, 0x98, 0x64, 0xE4,
+	0x04, 0x01, 0x2D, 0xC8,
+	0x31, 0x05, 0x07, 0x01, 0x00, 0xA2, 0x54, 0x03, 0x00, 0x43, 0x87, 0x01,
+	0x05, 0x05, 0x86, 0x98,
+	0x7E, 0x98, 0x00, 0xA6, 0x16, 0x03, 0x07, 0xA6, 0x4C, 0x03, 0x03, 0xA6,
+	0x3C, 0x04, 0x06, 0xA6,
+	0x50, 0x03, 0x01, 0xA6, 0x16, 0x03, 0x00, 0x33, 0x25, 0x00, 0xC2, 0x88,
+	0x7C, 0x95, 0x32, 0x83,
+	0x60, 0x96, 0x32, 0x83, 0x04, 0x01, 0x10, 0xCE, 0x07, 0xC8, 0x05, 0x05,
+	0xEB, 0x04, 0x00, 0x33,
+	0x00, 0x20, 0xC0, 0x20, 0x81, 0x62, 0x72, 0x83, 0x00, 0x01, 0x05, 0x05,
+	0xFF, 0xA2, 0x7A, 0x03,
+	0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x2E, 0x83, 0x05, 0x05, 0x15, 0x01,
+	0x00, 0xA2, 0x9A, 0x03,
+	0xEC, 0x00, 0x6E, 0x00, 0x95, 0x01, 0x6C, 0x38, 0x00, 0x3F, 0x00, 0x00,
+	0x01, 0xA6, 0x96, 0x03,
+	0x00, 0xA6, 0x96, 0x03, 0x10, 0x84, 0x80, 0x42, 0x7E, 0x98, 0x01, 0xA6,
+	0xA4, 0x03, 0x00, 0xA6,
+	0xBC, 0x03, 0x10, 0x84, 0xA8, 0x98, 0x80, 0x42, 0x01, 0xA6, 0xA4, 0x03,
+	0x07, 0xA6, 0xB2, 0x03,
+	0xD4, 0x83, 0x7C, 0x95, 0xA8, 0x83, 0x00, 0x33, 0x2F, 0x00, 0xC2, 0x88,
+	0xA8, 0x98, 0x80, 0x42,
+	0x00, 0xA6, 0xBC, 0x03, 0x07, 0xA6, 0xCA, 0x03, 0xD4, 0x83, 0x7C, 0x95,
+	0xC0, 0x83, 0x00, 0x33,
+	0x26, 0x00, 0xC2, 0x88, 0x38, 0x2B, 0x80, 0x32, 0x80, 0x36, 0x04, 0x23,
+	0xA0, 0x01, 0x12, 0x23,
+	0xA1, 0x01, 0x10, 0x84, 0x07, 0xF0, 0x06, 0xA4, 0xF4, 0x03, 0x80, 0x6B,
+	0x80, 0x67, 0x05, 0x23,
+	0x83, 0x03, 0x80, 0x63, 0x03, 0xA6, 0x0E, 0x04, 0x07, 0xA6, 0x06, 0x04,
+	0x06, 0xA6, 0x0A, 0x04,
+	0x00, 0x33, 0x17, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0xF4, 0x83, 0x60, 0x96,
+	0xF4, 0x83, 0x20, 0x84,
+	0x07, 0xF0, 0x06, 0xA4, 0x20, 0x04, 0x80, 0x6B, 0x80, 0x67, 0x05, 0x23,
+	0x83, 0x03, 0x80, 0x63,
+	0xB6, 0x2D, 0x03, 0xA6, 0x3C, 0x04, 0x07, 0xA6, 0x34, 0x04, 0x06, 0xA6,
+	0x38, 0x04, 0x00, 0x33,
+	0x30, 0x00, 0xC2, 0x88, 0x7C, 0x95, 0x20, 0x84, 0x60, 0x96, 0x20, 0x84,
+	0x1D, 0x01, 0x06, 0xCC,
+	0x00, 0x33, 0x00, 0x84, 0xC0, 0x20, 0x00, 0x23, 0xEA, 0x00, 0x81, 0x62,
+	0xA2, 0x0D, 0x80, 0x63,
+	0x07, 0xA6, 0x5A, 0x04, 0x00, 0x33, 0x18, 0x00, 0xC2, 0x88, 0x03, 0x03,
+	0x80, 0x63, 0xA3, 0x01,
+	0x07, 0xA4, 0x64, 0x04, 0x23, 0x01, 0x00, 0xA2, 0x86, 0x04, 0x0A, 0xA0,
+	0x76, 0x04, 0xE0, 0x00,
+	0x00, 0x33, 0x1D, 0x00, 0xC2, 0x88, 0x0B, 0xA0, 0x82, 0x04, 0xE0, 0x00,
+	0x00, 0x33, 0x1E, 0x00,
+	0xC2, 0x88, 0x42, 0x23, 0xF8, 0x88, 0x00, 0x23, 0x22, 0xA3, 0xE6, 0x04,
+	0x08, 0x23, 0x22, 0xA3,
+	0xA2, 0x04, 0x28, 0x23, 0x22, 0xA3, 0xAE, 0x04, 0x02, 0x23, 0x22, 0xA3,
+	0xC4, 0x04, 0x42, 0x23,
+	0xF8, 0x88, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA0, 0xAE, 0x04, 0x45, 0x23,
+	0xF8, 0x88, 0x04, 0x98,
+	0x00, 0xA2, 0xC0, 0x04, 0xB4, 0x98, 0x00, 0x33, 0x00, 0x82, 0xC0, 0x20,
+	0x81, 0x62, 0xE8, 0x81,
+	0x47, 0x23, 0xF8, 0x88, 0x04, 0x01, 0x0B, 0xDE, 0x04, 0x98, 0xB4, 0x98,
+	0x00, 0x33, 0x00, 0x81,
+	0xC0, 0x20, 0x81, 0x62, 0x14, 0x01, 0x00, 0xA0, 0x00, 0x02, 0x43, 0x23,
+	0xF8, 0x88, 0x04, 0x23,
+	0xA0, 0x01, 0x44, 0x23, 0xA1, 0x01, 0x80, 0x73, 0x4D, 0x00, 0x03, 0xA3,
+	0xF4, 0x04, 0x00, 0x33,
+	0x27, 0x00, 0xC2, 0x88, 0x04, 0x01, 0x04, 0xDC, 0x02, 0x23, 0xA2, 0x01,
+	0x04, 0x23, 0xA0, 0x01,
+	0x04, 0x98, 0x26, 0x95, 0x4B, 0x00, 0xF6, 0x00, 0x4F, 0x04, 0x4F, 0x00,
+	0x00, 0xA3, 0x22, 0x05,
+	0x00, 0x05, 0x76, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x1C, 0x05, 0x0A, 0x85,
+	0x46, 0x97, 0xCD, 0x04,
+	0x24, 0x85, 0x48, 0x04, 0x84, 0x80, 0x02, 0x01, 0x03, 0xDA, 0x80, 0x23,
+	0x82, 0x01, 0x34, 0x85,
+	0x02, 0x23, 0xA0, 0x01, 0x4A, 0x00, 0x06, 0x61, 0x00, 0xA2, 0x40, 0x05,
+	0x1D, 0x01, 0x04, 0xD6,
+	0xFF, 0x23, 0x86, 0x41, 0x4B, 0x60, 0xCB, 0x00, 0xFF, 0x23, 0x80, 0x01,
+	0x49, 0x00, 0x81, 0x01,
+	0x04, 0x01, 0x02, 0xC8, 0x30, 0x01, 0x80, 0x01, 0xF7, 0x04, 0x03, 0x01,
+	0x49, 0x04, 0x80, 0x01,
+	0xC9, 0x00, 0x00, 0x05, 0x00, 0x01, 0xFF, 0xA0, 0x60, 0x05, 0x77, 0x04,
+	0x01, 0x23, 0xEA, 0x00,
+	0x5D, 0x00, 0xFE, 0xC7, 0x00, 0x62, 0x00, 0x23, 0xEA, 0x00, 0x00, 0x63,
+	0x07, 0xA4, 0xF8, 0x05,
+	0x03, 0x03, 0x02, 0xA0, 0x8E, 0x05, 0xF4, 0x85, 0x00, 0x33, 0x2D, 0x00,
+	0xC2, 0x88, 0x04, 0xA0,
+	0xB8, 0x05, 0x80, 0x63, 0x00, 0x23, 0xDF, 0x00, 0x4A, 0x00, 0x06, 0x61,
+	0x00, 0xA2, 0xA4, 0x05,
+	0x1D, 0x01, 0x06, 0xD6, 0x02, 0x23, 0x02, 0x41, 0x82, 0x01, 0x50, 0x00,
+	0x62, 0x97, 0x04, 0x85,
+	0x04, 0x23, 0x02, 0x41, 0x82, 0x01, 0x04, 0x85, 0x08, 0xA0, 0xBE, 0x05,
+	0xF4, 0x85, 0x03, 0xA0,
+	0xC4, 0x05, 0xF4, 0x85, 0x01, 0xA0, 0xCE, 0x05, 0x88, 0x00, 0x80, 0x63,
+	0xCC, 0x86, 0x07, 0xA0,
+	0xEE, 0x05, 0x5F, 0x00, 0x00, 0x2B, 0xDF, 0x08, 0x00, 0xA2, 0xE6, 0x05,
+	0x80, 0x67, 0x80, 0x63,
+	0x01, 0xA2, 0x7A, 0x06, 0x7C, 0x85, 0x06, 0x23, 0x68, 0x98, 0x48, 0x23,
+	0xF8, 0x88, 0x07, 0x23,
+	0x80, 0x00, 0x06, 0x87, 0x80, 0x63, 0x7C, 0x85, 0x00, 0x23, 0xDF, 0x00,
+	0x00, 0x63, 0x4A, 0x00,
+	0x06, 0x61, 0x00, 0xA2, 0x36, 0x06, 0x1D, 0x01, 0x16, 0xD4, 0xC0, 0x23,
+	0x07, 0x41, 0x83, 0x03,
+	0x80, 0x63, 0x06, 0xA6, 0x1C, 0x06, 0x00, 0x33, 0x37, 0x00, 0xC2, 0x88,
+	0x1D, 0x01, 0x01, 0xD6,
+	0x20, 0x23, 0x63, 0x60, 0x83, 0x03, 0x80, 0x63, 0x02, 0x23, 0xDF, 0x00,
+	0x07, 0xA6, 0x7C, 0x05,
+	0xEF, 0x04, 0x6F, 0x00, 0x00, 0x63, 0x4B, 0x00, 0x06, 0x41, 0xCB, 0x00,
+	0x52, 0x00, 0x06, 0x61,
+	0x00, 0xA2, 0x4E, 0x06, 0x1D, 0x01, 0x03, 0xCA, 0xC0, 0x23, 0x07, 0x41,
+	0x00, 0x63, 0x1D, 0x01,
+	0x04, 0xCC, 0x00, 0x33, 0x00, 0x83, 0xC0, 0x20, 0x81, 0x62, 0x80, 0x23,
+	0x07, 0x41, 0x00, 0x63,
+	0x80, 0x67, 0x08, 0x23, 0x83, 0x03, 0x80, 0x63, 0x00, 0x63, 0x01, 0x23,
+	0xDF, 0x00, 0x06, 0xA6,
+	0x84, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x80, 0x67, 0x80, 0x63, 0x00, 0x33,
+	0x00, 0x40, 0xC0, 0x20,
+	0x81, 0x62, 0x00, 0x63, 0x00, 0x00, 0xFE, 0x95, 0x83, 0x03, 0x80, 0x63,
+	0x06, 0xA6, 0x94, 0x06,
+	0x07, 0xA6, 0x7C, 0x05, 0x00, 0x00, 0x01, 0xA0, 0x14, 0x07, 0x00, 0x2B,
+	0x40, 0x0E, 0x80, 0x63,
+	0x01, 0x00, 0x06, 0xA6, 0xAA, 0x06, 0x07, 0xA6, 0x7C, 0x05, 0x40, 0x0E,
+	0x80, 0x63, 0x00, 0x43,
+	0x00, 0xA0, 0xA2, 0x06, 0x06, 0xA6, 0xBC, 0x06, 0x07, 0xA6, 0x7C, 0x05,
+	0x80, 0x67, 0x40, 0x0E,
+	0x80, 0x63, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x23, 0xDF, 0x00, 0x00, 0x63,
+	0x07, 0xA6, 0xD6, 0x06,
+	0x00, 0x33, 0x2A, 0x00, 0xC2, 0x88, 0x03, 0x03, 0x80, 0x63, 0x89, 0x00,
+	0x0A, 0x2B, 0x07, 0xA6,
+	0xE8, 0x06, 0x00, 0x33, 0x29, 0x00, 0xC2, 0x88, 0x00, 0x43, 0x00, 0xA2,
+	0xF4, 0x06, 0xC0, 0x0E,
+	0x80, 0x63, 0xDE, 0x86, 0xC0, 0x0E, 0x00, 0x33, 0x00, 0x80, 0xC0, 0x20,
+	0x81, 0x62, 0x04, 0x01,
+	0x02, 0xDA, 0x80, 0x63, 0x7C, 0x85, 0x80, 0x7B, 0x80, 0x63, 0x06, 0xA6,
+	0x8C, 0x06, 0x00, 0x33,
+	0x2C, 0x00, 0xC2, 0x88, 0x0C, 0xA2, 0x2E, 0x07, 0xFE, 0x95, 0x83, 0x03,
+	0x80, 0x63, 0x06, 0xA6,
+	0x2C, 0x07, 0x07, 0xA6, 0x7C, 0x05, 0x00, 0x33, 0x3D, 0x00, 0xC2, 0x88,
+	0x00, 0x00, 0x80, 0x67,
+	0x83, 0x03, 0x80, 0x63, 0x0C, 0xA0, 0x44, 0x07, 0x07, 0xA6, 0x7C, 0x05,
+	0xBF, 0x23, 0x04, 0x61,
+	0x84, 0x01, 0xE6, 0x84, 0x00, 0x63, 0xF0, 0x04, 0x01, 0x01, 0xF1, 0x00,
+	0x00, 0x01, 0xF2, 0x00,
+	0x01, 0x05, 0x80, 0x01, 0x72, 0x04, 0x71, 0x00, 0x81, 0x01, 0x70, 0x04,
+	0x80, 0x05, 0x81, 0x05,
+	0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x01, 0x01, 0xF1, 0x00,
+	0x70, 0x00, 0x81, 0x01,
+	0x70, 0x04, 0x71, 0x00, 0x81, 0x01, 0x72, 0x00, 0x80, 0x01, 0x71, 0x04,
+	0x70, 0x00, 0x80, 0x01,
+	0x70, 0x04, 0x00, 0x63, 0xF0, 0x04, 0xF2, 0x00, 0x72, 0x04, 0x00, 0x01,
+	0xF1, 0x00, 0x70, 0x00,
+	0x80, 0x01, 0x70, 0x04, 0x71, 0x00, 0x80, 0x01, 0x72, 0x00, 0x81, 0x01,
+	0x71, 0x04, 0x70, 0x00,
+	0x81, 0x01, 0x70, 0x04, 0x00, 0x63, 0x00, 0x23, 0xB3, 0x01, 0x83, 0x05,
+	0xA3, 0x01, 0xA2, 0x01,
+	0xA1, 0x01, 0x01, 0x23, 0xA0, 0x01, 0x00, 0x01, 0xC8, 0x00, 0x03, 0xA1,
+	0xC4, 0x07, 0x00, 0x33,
+	0x07, 0x00, 0xC2, 0x88, 0x80, 0x05, 0x81, 0x05, 0x04, 0x01, 0x11, 0xC8,
+	0x48, 0x00, 0xB0, 0x01,
+	0xB1, 0x01, 0x08, 0x23, 0xB2, 0x01, 0x05, 0x01, 0x48, 0x04, 0x00, 0x43,
+	0x00, 0xA2, 0xE4, 0x07,
+	0x00, 0x05, 0xDA, 0x87, 0x00, 0x01, 0xC8, 0x00, 0xFF, 0x23, 0x80, 0x01,
+	0x05, 0x05, 0x00, 0x63,
+	0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04, 0x00, 0x02, 0x80, 0x43,
+	0x76, 0x08, 0x80, 0x02,
+	0x77, 0x04, 0x00, 0x63, 0xF7, 0x04, 0x1A, 0x09, 0xF6, 0x08, 0x6E, 0x04,
+	0x00, 0x02, 0x00, 0xA0,
+	0x14, 0x08, 0x16, 0x88, 0x00, 0x43, 0x76, 0x08, 0x80, 0x02, 0x77, 0x04,
+	0x00, 0x63, 0xF3, 0x04,
+	0x00, 0x23, 0xF4, 0x00, 0x74, 0x00, 0x80, 0x43, 0xF4, 0x00, 0xCF, 0x40,
+	0x00, 0xA2, 0x44, 0x08,
+	0x74, 0x04, 0x02, 0x01, 0xF7, 0xC9, 0xF6, 0xD9, 0x00, 0x01, 0x01, 0xA1,
+	0x24, 0x08, 0x04, 0x98,
+	0x26, 0x95, 0x24, 0x88, 0x73, 0x04, 0x00, 0x63, 0xF3, 0x04, 0x75, 0x04,
+	0x5A, 0x88, 0x02, 0x01,
+	0x04, 0xD8, 0x46, 0x97, 0x04, 0x98, 0x26, 0x95, 0x4A, 0x88, 0x75, 0x00,
+	0x00, 0xA3, 0x64, 0x08,
+	0x00, 0x05, 0x4E, 0x88, 0x73, 0x04, 0x00, 0x63, 0x80, 0x7B, 0x80, 0x63,
+	0x06, 0xA6, 0x76, 0x08,
+	0x00, 0x33, 0x3E, 0x00, 0xC2, 0x88, 0x80, 0x67, 0x83, 0x03, 0x80, 0x63,
+	0x00, 0x63, 0x38, 0x2B,
+	0x9C, 0x88, 0x38, 0x2B, 0x92, 0x88, 0x32, 0x09, 0x31, 0x05, 0x92, 0x98,
+	0x05, 0x05, 0xB2, 0x09,
+	0x00, 0x63, 0x00, 0x32, 0x00, 0x36, 0x00, 0x3A, 0x00, 0x3E, 0x00, 0x63,
+	0x80, 0x32, 0x80, 0x36,
+	0x80, 0x3A, 0x80, 0x3E, 0xB4, 0x3D, 0x00, 0x63, 0x38, 0x2B, 0x40, 0x32,
+	0x40, 0x36, 0x40, 0x3A,
+	0x40, 0x3E, 0x00, 0x63, 0x5A, 0x20, 0xC9, 0x40, 0x00, 0xA0, 0xB4, 0x08,
+	0x5D, 0x00, 0xFE, 0xC3,
+	0x00, 0x63, 0x80, 0x73, 0xE6, 0x20, 0x02, 0x23, 0xE8, 0x00, 0x82, 0x73,
+	0xFF, 0xFD, 0x80, 0x73,
+	0x13, 0x23, 0xF8, 0x88, 0x66, 0x20, 0xC0, 0x20, 0x04, 0x23, 0xA0, 0x01,
+	0xA1, 0x23, 0xA1, 0x01,
+	0x81, 0x62, 0xE2, 0x88, 0x80, 0x73, 0x80, 0x77, 0x68, 0x00, 0x00, 0xA2,
+	0x80, 0x00, 0x03, 0xC2,
+	0xF1, 0xC7, 0x41, 0x23, 0xF8, 0x88, 0x11, 0x23, 0xA1, 0x01, 0x04, 0x23,
+	0xA0, 0x01, 0xE6, 0x84,
 };
 
-STATIC ushort _asc_mcode_size = sizeof(_asc_mcode_buf);
-STATIC ADV_DCNT _asc_mcode_chksum = 0x012C453FUL;
+static ushort _asc_mcode_size = sizeof(_asc_mcode_buf);
+static ADV_DCNT _asc_mcode_chksum = 0x012C453FUL;
 
 #define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16
-STATIC uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] =
-{
-    INQUIRY,
-    REQUEST_SENSE,
-    READ_CAPACITY,
-    READ_TOC,
-    MODE_SELECT,
-    MODE_SENSE,
-    MODE_SELECT_10,
-    MODE_SENSE_10,
-    0xFF,
-    0xFF,
-    0xFF,
-    0xFF,
-    0xFF,
-    0xFF,
-    0xFF,
-    0xFF
+static uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] = {
+	INQUIRY,
+	REQUEST_SENSE,
+	READ_CAPACITY,
+	READ_TOC,
+	MODE_SELECT,
+	MODE_SENSE,
+	MODE_SELECT_10,
+	MODE_SENSE_10,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF
 };
 
-STATIC int
-AscExeScsiQueue(
-                   ASC_DVC_VAR *asc_dvc,
-                   ASC_SCSI_Q *scsiq
-)
+static int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)
 {
-    PortAddr            iop_base;
-    ulong               last_int_level;
-    int                 sta;
-    int                 n_q_required;
-    int                 disable_syn_offset_one_fix;
-    int                 i;
-    ASC_PADDR           addr;
-    ASC_EXE_CALLBACK    asc_exe_callback;
-    ushort              sg_entry_cnt = 0;
-    ushort              sg_entry_cnt_minus_one = 0;
-    uchar               target_ix;
-    uchar               tid_no;
-    uchar               sdtr_data;
-    uchar               extra_bytes;
-    uchar               scsi_cmd;
-    uchar               disable_cmd;
-    ASC_SG_HEAD         *sg_head;
-    ASC_DCNT            data_cnt;
-
-    iop_base = asc_dvc->iop_base;
-    sg_head = scsiq->sg_head;
-    asc_exe_callback = asc_dvc->exe_callback;
-    if (asc_dvc->err_code != 0)
-        return (ERR);
-    if (scsiq == (ASC_SCSI_Q *) 0L) {
-        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_SCSIQ_NULL_PTR);
-        return (ERR);
-    }
-    scsiq->q1.q_no = 0;
-    if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
-        scsiq->q1.extra_bytes = 0;
-    }
-    sta = 0;
-    target_ix = scsiq->q2.target_ix;
-    tid_no = ASC_TIX_TO_TID(target_ix);
-    n_q_required = 1;
-    if (scsiq->cdbptr[0] == REQUEST_SENSE) {
-        if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {
-            asc_dvc->sdtr_done &= ~scsiq->q1.target_id;
-            sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
-            AscMsgOutSDTR(asc_dvc,
-                          asc_dvc->sdtr_period_tbl[(sdtr_data >> 4) &
-                          (uchar) (asc_dvc->max_sdtr_index - 1)],
-                          (uchar) (sdtr_data & (uchar) ASC_SYN_MAX_OFFSET));
-            scsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);
-        }
-    }
-    last_int_level = DvcEnterCritical();
-    if (asc_dvc->in_critical_cnt != 0) {
-        DvcLeaveCritical(last_int_level);
-        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
-        return (ERR);
-    }
-    asc_dvc->in_critical_cnt++;
-    if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
-        if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
-            asc_dvc->in_critical_cnt--;
-            DvcLeaveCritical(last_int_level);
-            return (ERR);
-        }
+	PortAddr iop_base;
+	ulong last_int_level;
+	int sta;
+	int n_q_required;
+	int disable_syn_offset_one_fix;
+	int i;
+	ASC_PADDR addr;
+	ASC_EXE_CALLBACK asc_exe_callback;
+	ushort sg_entry_cnt = 0;
+	ushort sg_entry_cnt_minus_one = 0;
+	uchar target_ix;
+	uchar tid_no;
+	uchar sdtr_data;
+	uchar extra_bytes;
+	uchar scsi_cmd;
+	uchar disable_cmd;
+	ASC_SG_HEAD *sg_head;
+	ASC_DCNT data_cnt;
+
+	iop_base = asc_dvc->iop_base;
+	sg_head = scsiq->sg_head;
+	asc_exe_callback = asc_dvc->exe_callback;
+	if (asc_dvc->err_code != 0)
+		return (ERR);
+	if (scsiq == (ASC_SCSI_Q *)0L) {
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_SCSIQ_NULL_PTR);
+		return (ERR);
+	}
+	scsiq->q1.q_no = 0;
+	if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
+		scsiq->q1.extra_bytes = 0;
+	}
+	sta = 0;
+	target_ix = scsiq->q2.target_ix;
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	n_q_required = 1;
+	if (scsiq->cdbptr[0] == REQUEST_SENSE) {
+		if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {
+			asc_dvc->sdtr_done &= ~scsiq->q1.target_id;
+			sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+			AscMsgOutSDTR(asc_dvc,
+				      asc_dvc->
+				      sdtr_period_tbl[(sdtr_data >> 4) &
+						      (uchar)(asc_dvc->
+							      max_sdtr_index -
+							      1)],
+				      (uchar)(sdtr_data & (uchar)
+					      ASC_SYN_MAX_OFFSET));
+			scsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);
+		}
+	}
+	last_int_level = DvcEnterCritical();
+	if (asc_dvc->in_critical_cnt != 0) {
+		DvcLeaveCritical(last_int_level);
+		AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
+		return (ERR);
+	}
+	asc_dvc->in_critical_cnt++;
+	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
+		if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
+			asc_dvc->in_critical_cnt--;
+			DvcLeaveCritical(last_int_level);
+			return (ERR);
+		}
 #if !CC_VERY_LONG_SG_LIST
-        if (sg_entry_cnt > ASC_MAX_SG_LIST)
-        {
-            asc_dvc->in_critical_cnt--;
-            DvcLeaveCritical(last_int_level);
-            return(ERR);
-        }
+		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
+			asc_dvc->in_critical_cnt--;
+			DvcLeaveCritical(last_int_level);
+			return (ERR);
+		}
 #endif /* !CC_VERY_LONG_SG_LIST */
-        if (sg_entry_cnt == 1) {
-            scsiq->q1.data_addr = (ADV_PADDR) sg_head->sg_list[0].addr;
-            scsiq->q1.data_cnt = (ADV_DCNT) sg_head->sg_list[0].bytes;
-            scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
-        }
-        sg_entry_cnt_minus_one = sg_entry_cnt - 1;
-    }
-    scsi_cmd = scsiq->cdbptr[0];
-    disable_syn_offset_one_fix = FALSE;
-    if ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&
-        !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {
-        if (scsiq->q1.cntl & QC_SG_HEAD) {
-            data_cnt = 0;
-            for (i = 0; i < sg_entry_cnt; i++) {
-                data_cnt += (ADV_DCNT) le32_to_cpu(sg_head->sg_list[i].bytes);
-            }
-        } else {
-            data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
-        }
-        if (data_cnt != 0UL) {
-            if (data_cnt < 512UL) {
-                disable_syn_offset_one_fix = TRUE;
-            } else {
-                for (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST; i++) {
-                    disable_cmd = _syn_offset_one_disable_cmd[i];
-                    if (disable_cmd == 0xFF) {
-                        break;
-                    }
-                    if (scsi_cmd == disable_cmd) {
-                        disable_syn_offset_one_fix = TRUE;
-                        break;
-                    }
-                }
-            }
-        }
-    }
-    if (disable_syn_offset_one_fix) {
-        scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
-        scsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
-                               ASC_TAG_FLAG_DISABLE_DISCONNECT);
-    } else {
-        scsiq->q2.tag_code &= 0x27;
-    }
-    if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
-        if (asc_dvc->bug_fix_cntl) {
-            if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
-                if ((scsi_cmd == READ_6) ||
-                    (scsi_cmd == READ_10)) {
-                    addr =
-                        (ADV_PADDR) le32_to_cpu(
-                            sg_head->sg_list[sg_entry_cnt_minus_one].addr) +
-                        (ADV_DCNT) le32_to_cpu(
-                            sg_head->sg_list[sg_entry_cnt_minus_one].bytes);
-                    extra_bytes = (uchar) ((ushort) addr & 0x0003);
-                    if ((extra_bytes != 0) &&
-                        ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES)
-                         == 0)) {
-                        scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;
-                        scsiq->q1.extra_bytes = extra_bytes;
-                        data_cnt = le32_to_cpu(
-                            sg_head->sg_list[sg_entry_cnt_minus_one].bytes);
-                        data_cnt -= (ASC_DCNT) extra_bytes;
-                        sg_head->sg_list[sg_entry_cnt_minus_one].bytes =
-                            cpu_to_le32(data_cnt);
-                    }
-                }
-            }
-        }
-        sg_head->entry_to_copy = sg_head->entry_cnt;
+		if (sg_entry_cnt == 1) {
+			scsiq->q1.data_addr =
+			    (ADV_PADDR)sg_head->sg_list[0].addr;
+			scsiq->q1.data_cnt =
+			    (ADV_DCNT)sg_head->sg_list[0].bytes;
+			scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
+		}
+		sg_entry_cnt_minus_one = sg_entry_cnt - 1;
+	}
+	scsi_cmd = scsiq->cdbptr[0];
+	disable_syn_offset_one_fix = FALSE;
+	if ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&
+	    !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {
+		if (scsiq->q1.cntl & QC_SG_HEAD) {
+			data_cnt = 0;
+			for (i = 0; i < sg_entry_cnt; i++) {
+				data_cnt +=
+				    (ADV_DCNT)le32_to_cpu(sg_head->sg_list[i].
+							  bytes);
+			}
+		} else {
+			data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
+		}
+		if (data_cnt != 0UL) {
+			if (data_cnt < 512UL) {
+				disable_syn_offset_one_fix = TRUE;
+			} else {
+				for (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;
+				     i++) {
+					disable_cmd =
+					    _syn_offset_one_disable_cmd[i];
+					if (disable_cmd == 0xFF) {
+						break;
+					}
+					if (scsi_cmd == disable_cmd) {
+						disable_syn_offset_one_fix =
+						    TRUE;
+						break;
+					}
+				}
+			}
+		}
+	}
+	if (disable_syn_offset_one_fix) {
+		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
+		scsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
+				       ASC_TAG_FLAG_DISABLE_DISCONNECT);
+	} else {
+		scsiq->q2.tag_code &= 0x27;
+	}
+	if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
+		if (asc_dvc->bug_fix_cntl) {
+			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
+				if ((scsi_cmd == READ_6) ||
+				    (scsi_cmd == READ_10)) {
+					addr =
+					    (ADV_PADDR)le32_to_cpu(sg_head->
+								   sg_list
+								   [sg_entry_cnt_minus_one].
+								   addr) +
+					    (ADV_DCNT)le32_to_cpu(sg_head->
+								  sg_list
+								  [sg_entry_cnt_minus_one].
+								  bytes);
+					extra_bytes =
+					    (uchar)((ushort)addr & 0x0003);
+					if ((extra_bytes != 0)
+					    &&
+					    ((scsiq->q2.
+					      tag_code &
+					      ASC_TAG_FLAG_EXTRA_BYTES)
+					     == 0)) {
+						scsiq->q2.tag_code |=
+						    ASC_TAG_FLAG_EXTRA_BYTES;
+						scsiq->q1.extra_bytes =
+						    extra_bytes;
+						data_cnt =
+						    le32_to_cpu(sg_head->
+								sg_list
+								[sg_entry_cnt_minus_one].
+								bytes);
+						data_cnt -=
+						    (ASC_DCNT) extra_bytes;
+						sg_head->
+						    sg_list
+						    [sg_entry_cnt_minus_one].
+						    bytes =
+						    cpu_to_le32(data_cnt);
+					}
+				}
+			}
+		}
+		sg_head->entry_to_copy = sg_head->entry_cnt;
 #if CC_VERY_LONG_SG_LIST
-        /*
-         * Set the sg_entry_cnt to the maximum possible. The rest of
-         * the SG elements will be copied when the RISC completes the
-         * SG elements that fit and halts.
-         */
-        if (sg_entry_cnt > ASC_MAX_SG_LIST)
-        {
-             sg_entry_cnt = ASC_MAX_SG_LIST;
-        }
+		/*
+		 * Set the sg_entry_cnt to the maximum possible. The rest of
+		 * the SG elements will be copied when the RISC completes the
+		 * SG elements that fit and halts.
+		 */
+		if (sg_entry_cnt > ASC_MAX_SG_LIST) {
+			sg_entry_cnt = ASC_MAX_SG_LIST;
+		}
 #endif /* CC_VERY_LONG_SG_LIST */
-        n_q_required = AscSgListToQueue(sg_entry_cnt);
-        if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=
-            (uint) n_q_required) || ((scsiq->q1.cntl & QC_URGENT) != 0)) {
-            if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
-                                        n_q_required)) == 1) {
-                asc_dvc->in_critical_cnt--;
-                if (asc_exe_callback != 0) {
-                    (*asc_exe_callback) (asc_dvc, scsiq);
-                }
-                DvcLeaveCritical(last_int_level);
-                return (sta);
-            }
-        }
-    } else {
-        if (asc_dvc->bug_fix_cntl) {
-            if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
-                if ((scsi_cmd == READ_6) ||
-                    (scsi_cmd == READ_10)) {
-                    addr = le32_to_cpu(scsiq->q1.data_addr) +
-                        le32_to_cpu(scsiq->q1.data_cnt);
-                    extra_bytes = (uchar) ((ushort) addr & 0x0003);
-                    if ((extra_bytes != 0) &&
-                        ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES)
-                          == 0)) {
-                        data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
-                        if (((ushort) data_cnt & 0x01FF) == 0) {
-                            scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;
-                            data_cnt -= (ASC_DCNT) extra_bytes;
-                            scsiq->q1.data_cnt = cpu_to_le32(data_cnt);
-                            scsiq->q1.extra_bytes = extra_bytes;
-                        }
-                    }
-                }
-            }
-        }
-        n_q_required = 1;
-        if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||
-            ((scsiq->q1.cntl & QC_URGENT) != 0)) {
-            if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
-                                        n_q_required)) == 1) {
-                asc_dvc->in_critical_cnt--;
-                if (asc_exe_callback != 0) {
-                    (*asc_exe_callback) (asc_dvc, scsiq);
-                }
-                DvcLeaveCritical(last_int_level);
-                return (sta);
-            }
-        }
-    }
-    asc_dvc->in_critical_cnt--;
-    DvcLeaveCritical(last_int_level);
-    return (sta);
+		n_q_required = AscSgListToQueue(sg_entry_cnt);
+		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=
+		     (uint) n_q_required)
+		    || ((scsiq->q1.cntl & QC_URGENT) != 0)) {
+			if ((sta =
+			     AscSendScsiQueue(asc_dvc, scsiq,
+					      n_q_required)) == 1) {
+				asc_dvc->in_critical_cnt--;
+				if (asc_exe_callback != 0) {
+					(*asc_exe_callback) (asc_dvc, scsiq);
+				}
+				DvcLeaveCritical(last_int_level);
+				return (sta);
+			}
+		}
+	} else {
+		if (asc_dvc->bug_fix_cntl) {
+			if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
+				if ((scsi_cmd == READ_6) ||
+				    (scsi_cmd == READ_10)) {
+					addr =
+					    le32_to_cpu(scsiq->q1.data_addr) +
+					    le32_to_cpu(scsiq->q1.data_cnt);
+					extra_bytes =
+					    (uchar)((ushort)addr & 0x0003);
+					if ((extra_bytes != 0)
+					    &&
+					    ((scsiq->q2.
+					      tag_code &
+					      ASC_TAG_FLAG_EXTRA_BYTES)
+					     == 0)) {
+						data_cnt =
+						    le32_to_cpu(scsiq->q1.
+								data_cnt);
+						if (((ushort)data_cnt & 0x01FF)
+						    == 0) {
+							scsiq->q2.tag_code |=
+							    ASC_TAG_FLAG_EXTRA_BYTES;
+							data_cnt -= (ASC_DCNT)
+							    extra_bytes;
+							scsiq->q1.data_cnt =
+							    cpu_to_le32
+							    (data_cnt);
+							scsiq->q1.extra_bytes =
+							    extra_bytes;
+						}
+					}
+				}
+			}
+		}
+		n_q_required = 1;
+		if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||
+		    ((scsiq->q1.cntl & QC_URGENT) != 0)) {
+			if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
+						    n_q_required)) == 1) {
+				asc_dvc->in_critical_cnt--;
+				if (asc_exe_callback != 0) {
+					(*asc_exe_callback) (asc_dvc, scsiq);
+				}
+				DvcLeaveCritical(last_int_level);
+				return (sta);
+			}
+		}
+	}
+	asc_dvc->in_critical_cnt--;
+	DvcLeaveCritical(last_int_level);
+	return (sta);
 }
 
-STATIC int
-AscSendScsiQueue(
-                    ASC_DVC_VAR *asc_dvc,
-                    ASC_SCSI_Q *scsiq,
-                    uchar n_q_required
-)
+static int
+AscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)
 {
-    PortAddr            iop_base;
-    uchar               free_q_head;
-    uchar               next_qp;
-    uchar               tid_no;
-    uchar               target_ix;
-    int                 sta;
-
-    iop_base = asc_dvc->iop_base;
-    target_ix = scsiq->q2.target_ix;
-    tid_no = ASC_TIX_TO_TID(target_ix);
-    sta = 0;
-    free_q_head = (uchar) AscGetVarFreeQHead(iop_base);
-    if (n_q_required > 1) {
-        if ((next_qp = AscAllocMultipleFreeQueue(iop_base,
-                                       free_q_head, (uchar) (n_q_required)))
-            != (uchar) ASC_QLINK_END) {
-            asc_dvc->last_q_shortage = 0;
-            scsiq->sg_head->queue_cnt = n_q_required - 1;
-            scsiq->q1.q_no = free_q_head;
-            if ((sta = AscPutReadySgListQueue(asc_dvc, scsiq,
-                                              free_q_head)) == 1) {
-                AscPutVarFreeQHead(iop_base, next_qp);
-                asc_dvc->cur_total_qng += (uchar) (n_q_required);
-                asc_dvc->cur_dvc_qng[tid_no]++;
-            }
-            return (sta);
-        }
-    } else if (n_q_required == 1) {
-        if ((next_qp = AscAllocFreeQueue(iop_base,
-                                         free_q_head)) != ASC_QLINK_END) {
-            scsiq->q1.q_no = free_q_head;
-            if ((sta = AscPutReadyQueue(asc_dvc, scsiq,
-                                        free_q_head)) == 1) {
-                AscPutVarFreeQHead(iop_base, next_qp);
-                asc_dvc->cur_total_qng++;
-                asc_dvc->cur_dvc_qng[tid_no]++;
-            }
-            return (sta);
-        }
-    }
-    return (sta);
+	PortAddr iop_base;
+	uchar free_q_head;
+	uchar next_qp;
+	uchar tid_no;
+	uchar target_ix;
+	int sta;
+
+	iop_base = asc_dvc->iop_base;
+	target_ix = scsiq->q2.target_ix;
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	sta = 0;
+	free_q_head = (uchar)AscGetVarFreeQHead(iop_base);
+	if (n_q_required > 1) {
+		if ((next_qp = AscAllocMultipleFreeQueue(iop_base,
+							 free_q_head, (uchar)
+							 (n_q_required)))
+		    != (uchar)ASC_QLINK_END) {
+			asc_dvc->last_q_shortage = 0;
+			scsiq->sg_head->queue_cnt = n_q_required - 1;
+			scsiq->q1.q_no = free_q_head;
+			if ((sta = AscPutReadySgListQueue(asc_dvc, scsiq,
+							  free_q_head)) == 1) {
+				AscPutVarFreeQHead(iop_base, next_qp);
+				asc_dvc->cur_total_qng += (uchar)(n_q_required);
+				asc_dvc->cur_dvc_qng[tid_no]++;
+			}
+			return (sta);
+		}
+	} else if (n_q_required == 1) {
+		if ((next_qp = AscAllocFreeQueue(iop_base,
+						 free_q_head)) !=
+		    ASC_QLINK_END) {
+			scsiq->q1.q_no = free_q_head;
+			if ((sta = AscPutReadyQueue(asc_dvc, scsiq,
+						    free_q_head)) == 1) {
+				AscPutVarFreeQHead(iop_base, next_qp);
+				asc_dvc->cur_total_qng++;
+				asc_dvc->cur_dvc_qng[tid_no]++;
+			}
+			return (sta);
+		}
+	}
+	return (sta);
 }
 
-STATIC int
-AscSgListToQueue(
-                    int sg_list
-)
+static int AscSgListToQueue(int sg_list)
 {
-    int                 n_sg_list_qs;
+	int n_sg_list_qs;
 
-    n_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);
-    if (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)
-        n_sg_list_qs++;
-    return (n_sg_list_qs + 1);
+	n_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);
+	if (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)
+		n_sg_list_qs++;
+	return (n_sg_list_qs + 1);
 }
 
-
-STATIC uint
-AscGetNumOfFreeQueue(
-                        ASC_DVC_VAR *asc_dvc,
-                        uchar target_ix,
-                        uchar n_qs
-)
+static uint
+AscGetNumOfFreeQueue(ASC_DVC_VAR *asc_dvc, uchar target_ix, uchar n_qs)
 {
-    uint                cur_used_qs;
-    uint                cur_free_qs;
-    ASC_SCSI_BIT_ID_TYPE target_id;
-    uchar               tid_no;
-
-    target_id = ASC_TIX_TO_TARGET_ID(target_ix);
-    tid_no = ASC_TIX_TO_TID(target_ix);
-    if ((asc_dvc->unit_not_ready & target_id) ||
-        (asc_dvc->queue_full_or_busy & target_id)) {
-        return (0);
-    }
-    if (n_qs == 1) {
-        cur_used_qs = (uint) asc_dvc->cur_total_qng +
-          (uint) asc_dvc->last_q_shortage +
-          (uint) ASC_MIN_FREE_Q;
-    } else {
-        cur_used_qs = (uint) asc_dvc->cur_total_qng +
-          (uint) ASC_MIN_FREE_Q;
-    }
-    if ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {
-        cur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;
-        if (asc_dvc->cur_dvc_qng[tid_no] >=
-            asc_dvc->max_dvc_qng[tid_no]) {
-            return (0);
-        }
-        return (cur_free_qs);
-    }
-    if (n_qs > 1) {
-        if ((n_qs > asc_dvc->last_q_shortage) && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {
-            asc_dvc->last_q_shortage = n_qs;
-        }
-    }
-    return (0);
+	uint cur_used_qs;
+	uint cur_free_qs;
+	ASC_SCSI_BIT_ID_TYPE target_id;
+	uchar tid_no;
+
+	target_id = ASC_TIX_TO_TARGET_ID(target_ix);
+	tid_no = ASC_TIX_TO_TID(target_ix);
+	if ((asc_dvc->unit_not_ready & target_id) ||
+	    (asc_dvc->queue_full_or_busy & target_id)) {
+		return (0);
+	}
+	if (n_qs == 1) {
+		cur_used_qs = (uint) asc_dvc->cur_total_qng +
+		    (uint) asc_dvc->last_q_shortage + (uint) ASC_MIN_FREE_Q;
+	} else {
+		cur_used_qs = (uint) asc_dvc->cur_total_qng +
+		    (uint) ASC_MIN_FREE_Q;
+	}
+	if ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {
+		cur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;
+		if (asc_dvc->cur_dvc_qng[tid_no] >=
+		    asc_dvc->max_dvc_qng[tid_no]) {
+			return (0);
+		}
+		return (cur_free_qs);
+	}
+	if (n_qs > 1) {
+		if ((n_qs > asc_dvc->last_q_shortage)
+		    && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {
+			asc_dvc->last_q_shortage = n_qs;
+		}
+	}
+	return (0);
 }
 
-STATIC int
-AscPutReadyQueue(
-                    ASC_DVC_VAR *asc_dvc,
-                    ASC_SCSI_Q *scsiq,
-                    uchar q_no
-)
+static int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 {
-    ushort              q_addr;
-    uchar               tid_no;
-    uchar               sdtr_data;
-    uchar               syn_period_ix;
-    uchar               syn_offset;
-    PortAddr            iop_base;
-
-    iop_base = asc_dvc->iop_base;
-    if (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&
-        ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {
-        tid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);
-        sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
-        syn_period_ix = (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);
-        syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;
-        AscMsgOutSDTR(asc_dvc,
-                      asc_dvc->sdtr_period_tbl[syn_period_ix],
-                      syn_offset);
-        scsiq->q1.cntl |= QC_MSG_OUT;
-    }
-    q_addr = ASC_QNO_TO_QADDR(q_no);
-    if ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {
-        scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG ;
-    }
-    scsiq->q1.status = QS_FREE;
-    AscMemWordCopyPtrToLram(iop_base,
-                         q_addr + ASC_SCSIQ_CDB_BEG,
-                         (uchar *) scsiq->cdbptr,
-                         scsiq->q2.cdb_len >> 1);
-
-    DvcPutScsiQ(iop_base,
-                q_addr + ASC_SCSIQ_CPY_BEG,
-                (uchar *) &scsiq->q1.cntl,
-                ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);
-    AscWriteLramWord(iop_base,
-                     (ushort) (q_addr + (ushort) ASC_SCSIQ_B_STATUS),
-             (ushort) (((ushort) scsiq->q1.q_no << 8) | (ushort) QS_READY));
-    return (1);
+	ushort q_addr;
+	uchar tid_no;
+	uchar sdtr_data;
+	uchar syn_period_ix;
+	uchar syn_offset;
+	PortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+	if (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&
+	    ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {
+		tid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);
+		sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+		syn_period_ix =
+		    (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);
+		syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;
+		AscMsgOutSDTR(asc_dvc,
+			      asc_dvc->sdtr_period_tbl[syn_period_ix],
+			      syn_offset);
+		scsiq->q1.cntl |= QC_MSG_OUT;
+	}
+	q_addr = ASC_QNO_TO_QADDR(q_no);
+	if ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {
+		scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
+	}
+	scsiq->q1.status = QS_FREE;
+	AscMemWordCopyPtrToLram(iop_base,
+				q_addr + ASC_SCSIQ_CDB_BEG,
+				(uchar *)scsiq->cdbptr, scsiq->q2.cdb_len >> 1);
+
+	DvcPutScsiQ(iop_base,
+		    q_addr + ASC_SCSIQ_CPY_BEG,
+		    (uchar *)&scsiq->q1.cntl,
+		    ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);
+	AscWriteLramWord(iop_base,
+			 (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS),
+			 (ushort)(((ushort)scsiq->q1.
+				   q_no << 8) | (ushort)QS_READY));
+	return (1);
 }
 
-STATIC int
-AscPutReadySgListQueue(
-                          ASC_DVC_VAR *asc_dvc,
-                          ASC_SCSI_Q *scsiq,
-                          uchar q_no
-)
+static int
+AscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)
 {
-    int                 sta;
-    int                 i;
-    ASC_SG_HEAD *sg_head;
-    ASC_SG_LIST_Q       scsi_sg_q;
-    ASC_DCNT            saved_data_addr;
-    ASC_DCNT            saved_data_cnt;
-    PortAddr            iop_base;
-    ushort              sg_list_dwords;
-    ushort              sg_index;
-    ushort              sg_entry_cnt;
-    ushort              q_addr;
-    uchar               next_qp;
-
-    iop_base = asc_dvc->iop_base;
-    sg_head = scsiq->sg_head;
-    saved_data_addr = scsiq->q1.data_addr;
-    saved_data_cnt = scsiq->q1.data_cnt;
-    scsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;
-    scsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;
+	int sta;
+	int i;
+	ASC_SG_HEAD *sg_head;
+	ASC_SG_LIST_Q scsi_sg_q;
+	ASC_DCNT saved_data_addr;
+	ASC_DCNT saved_data_cnt;
+	PortAddr iop_base;
+	ushort sg_list_dwords;
+	ushort sg_index;
+	ushort sg_entry_cnt;
+	ushort q_addr;
+	uchar next_qp;
+
+	iop_base = asc_dvc->iop_base;
+	sg_head = scsiq->sg_head;
+	saved_data_addr = scsiq->q1.data_addr;
+	saved_data_cnt = scsiq->q1.data_cnt;
+	scsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;
+	scsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;
 #if CC_VERY_LONG_SG_LIST
-    /*
-     * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
-     * then not all SG elements will fit in the allocated queues.
-     * The rest of the SG elements will be copied when the RISC
-     * completes the SG elements that fit and halts.
-     */
-    if (sg_head->entry_cnt > ASC_MAX_SG_LIST)
-    {
-         /*
-          * Set sg_entry_cnt to be the number of SG elements that
-          * will fit in the allocated SG queues. It is minus 1, because
-          * the first SG element is handled above. ASC_MAX_SG_LIST is
-          * already inflated by 1 to account for this. For example it
-          * may be 50 which is 1 + 7 queues * 7 SG elements.
-          */
-         sg_entry_cnt = ASC_MAX_SG_LIST - 1;
-
-         /*
-          * Keep track of remaining number of SG elements that will
-          * need to be handled from a_isr.c.
-          */
-         scsiq->remain_sg_entry_cnt = sg_head->entry_cnt - ASC_MAX_SG_LIST;
-    } else
-    {
+	/*
+	 * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
+	 * then not all SG elements will fit in the allocated queues.
+	 * The rest of the SG elements will be copied when the RISC
+	 * completes the SG elements that fit and halts.
+	 */
+	if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
+		/*
+		 * Set sg_entry_cnt to be the number of SG elements that
+		 * will fit in the allocated SG queues. It is minus 1, because
+		 * the first SG element is handled above. ASC_MAX_SG_LIST is
+		 * already inflated by 1 to account for this. For example it
+		 * may be 50 which is 1 + 7 queues * 7 SG elements.
+		 */
+		sg_entry_cnt = ASC_MAX_SG_LIST - 1;
+
+		/*
+		 * Keep track of remaining number of SG elements that will
+		 * need to be handled from a_isr.c.
+		 */
+		scsiq->remain_sg_entry_cnt =
+		    sg_head->entry_cnt - ASC_MAX_SG_LIST;
+	} else {
 #endif /* CC_VERY_LONG_SG_LIST */
-         /*
-          * Set sg_entry_cnt to be the number of SG elements that
-          * will fit in the allocated SG queues. It is minus 1, because
-          * the first SG element is handled above.
-          */
-         sg_entry_cnt = sg_head->entry_cnt - 1;
+		/*
+		 * Set sg_entry_cnt to be the number of SG elements that
+		 * will fit in the allocated SG queues. It is minus 1, because
+		 * the first SG element is handled above.
+		 */
+		sg_entry_cnt = sg_head->entry_cnt - 1;
 #if CC_VERY_LONG_SG_LIST
-    }
+	}
 #endif /* CC_VERY_LONG_SG_LIST */
-    if (sg_entry_cnt != 0) {
-        scsiq->q1.cntl |= QC_SG_HEAD;
-        q_addr = ASC_QNO_TO_QADDR(q_no);
-        sg_index = 1;
-        scsiq->q1.sg_queue_cnt = sg_head->queue_cnt;
-        scsi_sg_q.sg_head_qp = q_no;
-        scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
-        for (i = 0; i < sg_head->queue_cnt; i++) {
-            scsi_sg_q.seq_no = i + 1;
-            if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
-                sg_list_dwords = (uchar) (ASC_SG_LIST_PER_Q * 2);
-                sg_entry_cnt -= ASC_SG_LIST_PER_Q;
-                if (i == 0) {
-                    scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q;
-                    scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q;
-                } else {
-                    scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
-                    scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q - 1;
-                }
-            } else {
+	if (sg_entry_cnt != 0) {
+		scsiq->q1.cntl |= QC_SG_HEAD;
+		q_addr = ASC_QNO_TO_QADDR(q_no);
+		sg_index = 1;
+		scsiq->q1.sg_queue_cnt = sg_head->queue_cnt;
+		scsi_sg_q.sg_head_qp = q_no;
+		scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
+		for (i = 0; i < sg_head->queue_cnt; i++) {
+			scsi_sg_q.seq_no = i + 1;
+			if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
+				sg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);
+				sg_entry_cnt -= ASC_SG_LIST_PER_Q;
+				if (i == 0) {
+					scsi_sg_q.sg_list_cnt =
+					    ASC_SG_LIST_PER_Q;
+					scsi_sg_q.sg_cur_list_cnt =
+					    ASC_SG_LIST_PER_Q;
+				} else {
+					scsi_sg_q.sg_list_cnt =
+					    ASC_SG_LIST_PER_Q - 1;
+					scsi_sg_q.sg_cur_list_cnt =
+					    ASC_SG_LIST_PER_Q - 1;
+				}
+			} else {
 #if CC_VERY_LONG_SG_LIST
-                /*
-                 * This is the last SG queue in the list of
-                 * allocated SG queues. If there are more
-                 * SG elements than will fit in the allocated
-                 * queues, then set the QCSG_SG_XFER_MORE flag.
-                 */
-                if (sg_head->entry_cnt > ASC_MAX_SG_LIST)
-                {
-                    scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
-                } else
-                {
+				/*
+				 * This is the last SG queue in the list of
+				 * allocated SG queues. If there are more
+				 * SG elements than will fit in the allocated
+				 * queues, then set the QCSG_SG_XFER_MORE flag.
+				 */
+				if (sg_head->entry_cnt > ASC_MAX_SG_LIST) {
+					scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
+				} else {
 #endif /* CC_VERY_LONG_SG_LIST */
-                    scsi_sg_q.cntl |= QCSG_SG_XFER_END;
+					scsi_sg_q.cntl |= QCSG_SG_XFER_END;
 #if CC_VERY_LONG_SG_LIST
-                }
+				}
 #endif /* CC_VERY_LONG_SG_LIST */
-                sg_list_dwords = sg_entry_cnt << 1;
-                if (i == 0) {
-                    scsi_sg_q.sg_list_cnt = sg_entry_cnt;
-                    scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt;
-                } else {
-                    scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
-                    scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
-                }
-                sg_entry_cnt = 0;
-            }
-            next_qp = AscReadLramByte(iop_base,
-                                      (ushort) (q_addr + ASC_SCSIQ_B_FWD));
-            scsi_sg_q.q_no = next_qp;
-            q_addr = ASC_QNO_TO_QADDR(next_qp);
-            AscMemWordCopyPtrToLram(iop_base,
-                                q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
-                                (uchar *) &scsi_sg_q,
-                                sizeof(ASC_SG_LIST_Q) >> 1);
-            AscMemDWordCopyPtrToLram(iop_base,
-                                q_addr + ASC_SGQ_LIST_BEG,
-                                (uchar *) &sg_head->sg_list[sg_index],
-                                sg_list_dwords);
-            sg_index += ASC_SG_LIST_PER_Q;
-            scsiq->next_sg_index = sg_index;
-        }
-    } else {
-        scsiq->q1.cntl &= ~QC_SG_HEAD;
-    }
-    sta = AscPutReadyQueue(asc_dvc, scsiq, q_no);
-    scsiq->q1.data_addr = saved_data_addr;
-    scsiq->q1.data_cnt = saved_data_cnt;
-    return (sta);
+				sg_list_dwords = sg_entry_cnt << 1;
+				if (i == 0) {
+					scsi_sg_q.sg_list_cnt = sg_entry_cnt;
+					scsi_sg_q.sg_cur_list_cnt =
+					    sg_entry_cnt;
+				} else {
+					scsi_sg_q.sg_list_cnt =
+					    sg_entry_cnt - 1;
+					scsi_sg_q.sg_cur_list_cnt =
+					    sg_entry_cnt - 1;
+				}
+				sg_entry_cnt = 0;
+			}
+			next_qp = AscReadLramByte(iop_base,
+						  (ushort)(q_addr +
+							   ASC_SCSIQ_B_FWD));
+			scsi_sg_q.q_no = next_qp;
+			q_addr = ASC_QNO_TO_QADDR(next_qp);
+			AscMemWordCopyPtrToLram(iop_base,
+						q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
+						(uchar *)&scsi_sg_q,
+						sizeof(ASC_SG_LIST_Q) >> 1);
+			AscMemDWordCopyPtrToLram(iop_base,
+						 q_addr + ASC_SGQ_LIST_BEG,
+						 (uchar *)&sg_head->
+						 sg_list[sg_index],
+						 sg_list_dwords);
+			sg_index += ASC_SG_LIST_PER_Q;
+			scsiq->next_sg_index = sg_index;
+		}
+	} else {
+		scsiq->q1.cntl &= ~QC_SG_HEAD;
+	}
+	sta = AscPutReadyQueue(asc_dvc, scsiq, q_no);
+	scsiq->q1.data_addr = saved_data_addr;
+	scsiq->q1.data_cnt = saved_data_cnt;
+	return (sta);
 }
 
-STATIC int
-AscSetRunChipSynRegAtID(
-                           PortAddr iop_base,
-                           uchar tid_no,
-                           uchar sdtr_data
-)
+static int
+AscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)
 {
-    int                 sta = FALSE;
+	int sta = FALSE;
 
-    if (AscHostReqRiscHalt(iop_base)) {
-        sta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
-        AscStartChip(iop_base);
-        return (sta);
-    }
-    return (sta);
+	if (AscHostReqRiscHalt(iop_base)) {
+		sta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
+		AscStartChip(iop_base);
+		return (sta);
+	}
+	return (sta);
 }
 
-STATIC int
-AscSetChipSynRegAtID(
-                        PortAddr iop_base,
-                        uchar id,
-                        uchar sdtr_data
-)
+static int AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)
 {
-    ASC_SCSI_BIT_ID_TYPE org_id;
-    int                 i;
-    int                 sta = TRUE;
-
-    AscSetBank(iop_base, 1);
-    org_id = AscReadChipDvcID(iop_base);
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        if (org_id == (0x01 << i))
-            break;
-    }
-    org_id = (ASC_SCSI_BIT_ID_TYPE) i;
-    AscWriteChipDvcID(iop_base, id);
-    if (AscReadChipDvcID(iop_base) == (0x01 << id)) {
-        AscSetBank(iop_base, 0);
-        AscSetChipSyn(iop_base, sdtr_data);
-        if (AscGetChipSyn(iop_base) != sdtr_data) {
-            sta = FALSE;
-        }
-    } else {
-        sta = FALSE;
-    }
-    AscSetBank(iop_base, 1);
-    AscWriteChipDvcID(iop_base, org_id);
-    AscSetBank(iop_base, 0);
-    return (sta);
-}
+	ASC_SCSI_BIT_ID_TYPE org_id;
+	int i;
+	int sta = TRUE;
+
+	AscSetBank(iop_base, 1);
+	org_id = AscReadChipDvcID(iop_base);
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		if (org_id == (0x01 << i))
+			break;
+	}
+	org_id = (ASC_SCSI_BIT_ID_TYPE) i;
+	AscWriteChipDvcID(iop_base, id);
+	if (AscReadChipDvcID(iop_base) == (0x01 << id)) {
+		AscSetBank(iop_base, 0);
+		AscSetChipSyn(iop_base, sdtr_data);
+		if (AscGetChipSyn(iop_base) != sdtr_data) {
+			sta = FALSE;
+		}
+	} else {
+		sta = FALSE;
+	}
+	AscSetBank(iop_base, 1);
+	AscWriteChipDvcID(iop_base, org_id);
+	AscSetBank(iop_base, 0);
+	return (sta);
+}
 
-STATIC ushort
-AscInitLram(
-               ASC_DVC_VAR *asc_dvc
-)
+static ushort AscInitLram(ASC_DVC_VAR *asc_dvc)
 {
-    uchar               i;
-    ushort              s_addr;
-    PortAddr            iop_base;
-    ushort              warn_code;
-
-    iop_base = asc_dvc->iop_base;
-    warn_code = 0;
-    AscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,
-               (ushort) (((int) (asc_dvc->max_total_qng + 2 + 1) * 64) >> 1)
-);
-    i = ASC_MIN_ACTIVE_QNO;
-    s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;
-    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_FWD),
-                     (uchar) (i + 1));
-    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_BWD),
-                     (uchar) (asc_dvc->max_total_qng));
-    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_QNO),
-                     (uchar) i);
-    i++;
-    s_addr += ASC_QBLK_SIZE;
-    for (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {
-        AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_FWD),
-                         (uchar) (i + 1));
-        AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_BWD),
-                         (uchar) (i - 1));
-        AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_QNO),
-                         (uchar) i);
-    }
-    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_FWD),
-                     (uchar) ASC_QLINK_END);
-    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_BWD),
-                     (uchar) (asc_dvc->max_total_qng - 1));
-    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_QNO),
-                     (uchar) asc_dvc->max_total_qng);
-    i++;
-    s_addr += ASC_QBLK_SIZE;
-    for (; i <= (uchar) (asc_dvc->max_total_qng + 3);
-         i++, s_addr += ASC_QBLK_SIZE) {
-        AscWriteLramByte(iop_base,
-                         (ushort) (s_addr + (ushort) ASC_SCSIQ_B_FWD), i);
-        AscWriteLramByte(iop_base,
-                         (ushort) (s_addr + (ushort) ASC_SCSIQ_B_BWD), i);
-        AscWriteLramByte(iop_base,
-                         (ushort) (s_addr + (ushort) ASC_SCSIQ_B_QNO), i);
-    }
-    return (warn_code);
+	uchar i;
+	ushort s_addr;
+	PortAddr iop_base;
+	ushort warn_code;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	AscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,
+			  (ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *
+				    64) >> 1)
+	    );
+	i = ASC_MIN_ACTIVE_QNO;
+	s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
+			 (uchar)(i + 1));
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
+			 (uchar)(asc_dvc->max_total_qng));
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
+			 (uchar)i);
+	i++;
+	s_addr += ASC_QBLK_SIZE;
+	for (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {
+		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
+				 (uchar)(i + 1));
+		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
+				 (uchar)(i - 1));
+		AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
+				 (uchar)i);
+	}
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),
+			 (uchar)ASC_QLINK_END);
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),
+			 (uchar)(asc_dvc->max_total_qng - 1));
+	AscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),
+			 (uchar)asc_dvc->max_total_qng);
+	i++;
+	s_addr += ASC_QBLK_SIZE;
+	for (; i <= (uchar)(asc_dvc->max_total_qng + 3);
+	     i++, s_addr += ASC_QBLK_SIZE) {
+		AscWriteLramByte(iop_base,
+				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_FWD), i);
+		AscWriteLramByte(iop_base,
+				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_BWD), i);
+		AscWriteLramByte(iop_base,
+				 (ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);
+	}
+	return (warn_code);
 }
 
-STATIC ushort
-AscInitQLinkVar(
-                   ASC_DVC_VAR *asc_dvc
-)
+static ushort AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)
 {
-    PortAddr            iop_base;
-    int                 i;
-    ushort              lram_addr;
-
-    iop_base = asc_dvc->iop_base;
-    AscPutRiscVarFreeQHead(iop_base, 1);
-    AscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);
-    AscPutVarFreeQHead(iop_base, 1);
-    AscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);
-    AscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,
-                     (uchar) ((int) asc_dvc->max_total_qng + 1));
-    AscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,
-                     (uchar) ((int) asc_dvc->max_total_qng + 2));
-    AscWriteLramByte(iop_base, (ushort) ASCV_TOTAL_READY_Q_B,
-                     asc_dvc->max_total_qng);
-    AscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);
-    AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
-    AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);
-    AscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);
-    AscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);
-    AscPutQDoneInProgress(iop_base, 0);
-    lram_addr = ASC_QADR_BEG;
-    for (i = 0; i < 32; i++, lram_addr += 2) {
-        AscWriteLramWord(iop_base, lram_addr, 0);
-    }
-    return (0);
+	PortAddr iop_base;
+	int i;
+	ushort lram_addr;
+
+	iop_base = asc_dvc->iop_base;
+	AscPutRiscVarFreeQHead(iop_base, 1);
+	AscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);
+	AscPutVarFreeQHead(iop_base, 1);
+	AscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);
+	AscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,
+			 (uchar)((int)asc_dvc->max_total_qng + 1));
+	AscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,
+			 (uchar)((int)asc_dvc->max_total_qng + 2));
+	AscWriteLramByte(iop_base, (ushort)ASCV_TOTAL_READY_Q_B,
+			 asc_dvc->max_total_qng);
+	AscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);
+	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);
+	AscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);
+	AscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);
+	AscPutQDoneInProgress(iop_base, 0);
+	lram_addr = ASC_QADR_BEG;
+	for (i = 0; i < 32; i++, lram_addr += 2) {
+		AscWriteLramWord(iop_base, lram_addr, 0);
+	}
+	return (0);
 }
 
-STATIC int
-AscSetLibErrorCode(
-                      ASC_DVC_VAR *asc_dvc,
-                      ushort err_code
-)
+static int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)
 {
-    if (asc_dvc->err_code == 0) {
-        asc_dvc->err_code = err_code;
-        AscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
-                         err_code);
-    }
-    return (err_code);
+	if (asc_dvc->err_code == 0) {
+		asc_dvc->err_code = err_code;
+		AscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
+				 err_code);
+	}
+	return (err_code);
 }
 
-
-STATIC uchar
-AscMsgOutSDTR(
-                 ASC_DVC_VAR *asc_dvc,
-                 uchar sdtr_period,
-                 uchar sdtr_offset
-)
+static uchar
+AscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)
 {
-    EXT_MSG             sdtr_buf;
-    uchar               sdtr_period_index;
-    PortAddr            iop_base;
-
-    iop_base = asc_dvc->iop_base;
-    sdtr_buf.msg_type = MS_EXTEND;
-    sdtr_buf.msg_len = MS_SDTR_LEN;
-    sdtr_buf.msg_req = MS_SDTR_CODE;
-    sdtr_buf.xfer_period = sdtr_period;
-    sdtr_offset &= ASC_SYN_MAX_OFFSET;
-    sdtr_buf.req_ack_offset = sdtr_offset;
-    if ((sdtr_period_index =
-         AscGetSynPeriodIndex(asc_dvc, sdtr_period)) <=
-        asc_dvc->max_sdtr_index) {
-        AscMemWordCopyPtrToLram(iop_base,
-                             ASCV_MSGOUT_BEG,
-                             (uchar *) &sdtr_buf,
-                             sizeof (EXT_MSG) >> 1);
-        return ((sdtr_period_index << 4) | sdtr_offset);
-    } else {
-
-        sdtr_buf.req_ack_offset = 0;
-        AscMemWordCopyPtrToLram(iop_base,
-                             ASCV_MSGOUT_BEG,
-                             (uchar *) &sdtr_buf,
-                             sizeof (EXT_MSG) >> 1);
-        return (0);
-    }
+	EXT_MSG sdtr_buf;
+	uchar sdtr_period_index;
+	PortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+	sdtr_buf.msg_type = MS_EXTEND;
+	sdtr_buf.msg_len = MS_SDTR_LEN;
+	sdtr_buf.msg_req = MS_SDTR_CODE;
+	sdtr_buf.xfer_period = sdtr_period;
+	sdtr_offset &= ASC_SYN_MAX_OFFSET;
+	sdtr_buf.req_ack_offset = sdtr_offset;
+	if ((sdtr_period_index =
+	     AscGetSynPeriodIndex(asc_dvc, sdtr_period)) <=
+	    asc_dvc->max_sdtr_index) {
+		AscMemWordCopyPtrToLram(iop_base,
+					ASCV_MSGOUT_BEG,
+					(uchar *)&sdtr_buf,
+					sizeof(EXT_MSG) >> 1);
+		return ((sdtr_period_index << 4) | sdtr_offset);
+	} else {
+
+		sdtr_buf.req_ack_offset = 0;
+		AscMemWordCopyPtrToLram(iop_base,
+					ASCV_MSGOUT_BEG,
+					(uchar *)&sdtr_buf,
+					sizeof(EXT_MSG) >> 1);
+		return (0);
+	}
 }
 
-STATIC uchar
-AscCalSDTRData(
-                  ASC_DVC_VAR *asc_dvc,
-                  uchar sdtr_period,
-                  uchar syn_offset
-)
+static uchar
+AscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)
 {
-    uchar               byte;
-    uchar               sdtr_period_ix;
-
-    sdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
-    if (
-           (sdtr_period_ix > asc_dvc->max_sdtr_index)
-) {
-        return (0xFF);
-    }
-    byte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);
-    return (byte);
+	uchar byte;
+	uchar sdtr_period_ix;
+
+	sdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
+	if ((sdtr_period_ix > asc_dvc->max_sdtr_index)
+	    ) {
+		return (0xFF);
+	}
+	byte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);
+	return (byte);
 }
 
-STATIC void
-AscSetChipSDTR(
-                  PortAddr iop_base,
-                  uchar sdtr_data,
-                  uchar tid_no
-)
+static void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)
 {
-    AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
-    AscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);
-    return;
+	AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
+	AscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);
+	return;
 }
 
-STATIC uchar
-AscGetSynPeriodIndex(
-                        ASC_DVC_VAR *asc_dvc,
-                        uchar syn_time
-)
+static uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)
 {
-    uchar             *period_table;
-    int                 max_index;
-    int                 min_index;
-    int                 i;
-
-    period_table = asc_dvc->sdtr_period_tbl;
-    max_index = (int) asc_dvc->max_sdtr_index;
-    min_index = (int)asc_dvc->host_init_sdtr_index;
-    if ((syn_time <= period_table[max_index])) {
-        for (i = min_index; i < (max_index - 1); i++) {
-            if (syn_time <= period_table[i]) {
-                return ((uchar) i);
-            }
-        }
-        return ((uchar) max_index);
-    } else {
-        return ((uchar) (max_index + 1));
-    }
+	uchar *period_table;
+	int max_index;
+	int min_index;
+	int i;
+
+	period_table = asc_dvc->sdtr_period_tbl;
+	max_index = (int)asc_dvc->max_sdtr_index;
+	min_index = (int)asc_dvc->host_init_sdtr_index;
+	if ((syn_time <= period_table[max_index])) {
+		for (i = min_index; i < (max_index - 1); i++) {
+			if (syn_time <= period_table[i]) {
+				return ((uchar)i);
+			}
+		}
+		return ((uchar)max_index);
+	} else {
+		return ((uchar)(max_index + 1));
+	}
 }
 
-STATIC uchar
-AscAllocFreeQueue(
-                     PortAddr iop_base,
-                     uchar free_q_head
-)
+static uchar AscAllocFreeQueue(PortAddr iop_base, uchar free_q_head)
 {
-    ushort              q_addr;
-    uchar               next_qp;
-    uchar               q_status;
-
-    q_addr = ASC_QNO_TO_QADDR(free_q_head);
-    q_status = (uchar) AscReadLramByte(iop_base,
-                                    (ushort) (q_addr + ASC_SCSIQ_B_STATUS));
-    next_qp = AscReadLramByte(iop_base,
-                              (ushort) (q_addr + ASC_SCSIQ_B_FWD));
-    if (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END)) {
-        return (next_qp);
-    }
-    return (ASC_QLINK_END);
+	ushort q_addr;
+	uchar next_qp;
+	uchar q_status;
+
+	q_addr = ASC_QNO_TO_QADDR(free_q_head);
+	q_status = (uchar)AscReadLramByte(iop_base,
+					  (ushort)(q_addr +
+						   ASC_SCSIQ_B_STATUS));
+	next_qp = AscReadLramByte(iop_base, (ushort)(q_addr + ASC_SCSIQ_B_FWD));
+	if (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END)) {
+		return (next_qp);
+	}
+	return (ASC_QLINK_END);
 }
 
-STATIC uchar
-AscAllocMultipleFreeQueue(
-                             PortAddr iop_base,
-                             uchar free_q_head,
-                             uchar n_free_q
-)
+static uchar
+AscAllocMultipleFreeQueue(PortAddr iop_base, uchar free_q_head, uchar n_free_q)
 {
-    uchar               i;
+	uchar i;
 
-    for (i = 0; i < n_free_q; i++) {
-        if ((free_q_head = AscAllocFreeQueue(iop_base, free_q_head))
-            == ASC_QLINK_END) {
-            return (ASC_QLINK_END);
-        }
-    }
-    return (free_q_head);
+	for (i = 0; i < n_free_q; i++) {
+		if ((free_q_head = AscAllocFreeQueue(iop_base, free_q_head))
+		    == ASC_QLINK_END) {
+			return (ASC_QLINK_END);
+		}
+	}
+	return (free_q_head);
 }
 
-STATIC int
-AscHostReqRiscHalt(
-                      PortAddr iop_base
-)
+static int AscHostReqRiscHalt(PortAddr iop_base)
 {
-    int                 count = 0;
-    int                 sta = 0;
-    uchar               saved_stop_code;
-
-    if (AscIsChipHalted(iop_base))
-        return (1);
-    saved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);
-    AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
-                     ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP
-);
-    do {
-        if (AscIsChipHalted(iop_base)) {
-            sta = 1;
-            break;
-        }
-        DvcSleepMilliSecond(100);
-    } while (count++ < 20);
-    AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
-    return (sta);
+	int count = 0;
+	int sta = 0;
+	uchar saved_stop_code;
+
+	if (AscIsChipHalted(iop_base))
+		return (1);
+	saved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);
+	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
+			 ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);
+	do {
+		if (AscIsChipHalted(iop_base)) {
+			sta = 1;
+			break;
+		}
+		DvcSleepMilliSecond(100);
+	} while (count++ < 20);
+	AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
+	return (sta);
 }
 
-STATIC int
-AscStopQueueExe(
-                   PortAddr iop_base
-)
+static int AscStopQueueExe(PortAddr iop_base)
 {
-    int                 count = 0;
-
-    if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {
-        AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
-                         ASC_STOP_REQ_RISC_STOP);
-        do {
-            if (
-                   AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &
-                   ASC_STOP_ACK_RISC_STOP) {
-                return (1);
-            }
-            DvcSleepMilliSecond(100);
-        } while (count++ < 20);
-    }
-    return (0);
+	int count = 0;
+
+	if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {
+		AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
+				 ASC_STOP_REQ_RISC_STOP);
+		do {
+			if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &
+			    ASC_STOP_ACK_RISC_STOP) {
+				return (1);
+			}
+			DvcSleepMilliSecond(100);
+		} while (count++ < 20);
+	}
+	return (0);
 }
 
-STATIC void
-DvcDelayMicroSecond(ADV_DVC_VAR *asc_dvc, ushort micro_sec)
+static void DvcDelayMicroSecond(ADV_DVC_VAR *asc_dvc, ushort micro_sec)
 {
-    udelay(micro_sec);
+	udelay(micro_sec);
 }
 
-STATIC void
-DvcDelayNanoSecond(ASC_DVC_VAR *asc_dvc, ASC_DCNT nano_sec)
+static void DvcDelayNanoSecond(ASC_DVC_VAR *asc_dvc, ASC_DCNT nano_sec)
 {
-    udelay((nano_sec + 999)/1000);
+	udelay((nano_sec + 999) / 1000);
 }
 
 #ifdef CONFIG_ISA
-STATIC ASC_DCNT __init
-AscGetEisaProductID(
-                       PortAddr iop_base)
+static ASC_DCNT __init AscGetEisaProductID(PortAddr iop_base)
 {
-    PortAddr            eisa_iop;
-    ushort              product_id_high, product_id_low;
-    ASC_DCNT            product_id;
-
-    eisa_iop = ASC_GET_EISA_SLOT(iop_base) | ASC_EISA_PID_IOP_MASK;
-    product_id_low = inpw(eisa_iop);
-    product_id_high = inpw(eisa_iop + 2);
-    product_id = ((ASC_DCNT) product_id_high << 16) |
-        (ASC_DCNT) product_id_low;
-    return (product_id);
+	PortAddr eisa_iop;
+	ushort product_id_high, product_id_low;
+	ASC_DCNT product_id;
+
+	eisa_iop = ASC_GET_EISA_SLOT(iop_base) | ASC_EISA_PID_IOP_MASK;
+	product_id_low = inpw(eisa_iop);
+	product_id_high = inpw(eisa_iop + 2);
+	product_id = ((ASC_DCNT) product_id_high << 16) |
+	    (ASC_DCNT) product_id_low;
+	return (product_id);
 }
 
-STATIC PortAddr __init
-AscSearchIOPortAddrEISA(
-                           PortAddr iop_base)
+static PortAddr __init AscSearchIOPortAddrEISA(PortAddr iop_base)
 {
-    ASC_DCNT            eisa_product_id;
-
-    if (iop_base == 0) {
-        iop_base = ASC_EISA_MIN_IOP_ADDR;
-    } else {
-        if (iop_base == ASC_EISA_MAX_IOP_ADDR)
-            return (0);
-        if ((iop_base & 0x0050) == 0x0050) {
-            iop_base += ASC_EISA_BIG_IOP_GAP;
-        } else {
-            iop_base += ASC_EISA_SMALL_IOP_GAP;
-        }
-    }
-    while (iop_base <= ASC_EISA_MAX_IOP_ADDR) {
-        eisa_product_id = AscGetEisaProductID(iop_base);
-        if ((eisa_product_id == ASC_EISA_ID_740) ||
-            (eisa_product_id == ASC_EISA_ID_750)) {
-            if (AscFindSignature(iop_base)) {
-                inpw(iop_base + 4);
-                return (iop_base);
-            }
-        }
-        if (iop_base == ASC_EISA_MAX_IOP_ADDR)
-            return (0);
-        if ((iop_base & 0x0050) == 0x0050) {
-            iop_base += ASC_EISA_BIG_IOP_GAP;
-        } else {
-            iop_base += ASC_EISA_SMALL_IOP_GAP;
-        }
-    }
-    return (0);
+	ASC_DCNT eisa_product_id;
+
+	if (iop_base == 0) {
+		iop_base = ASC_EISA_MIN_IOP_ADDR;
+	} else {
+		if (iop_base == ASC_EISA_MAX_IOP_ADDR)
+			return (0);
+		if ((iop_base & 0x0050) == 0x0050) {
+			iop_base += ASC_EISA_BIG_IOP_GAP;
+		} else {
+			iop_base += ASC_EISA_SMALL_IOP_GAP;
+		}
+	}
+	while (iop_base <= ASC_EISA_MAX_IOP_ADDR) {
+		eisa_product_id = AscGetEisaProductID(iop_base);
+		if ((eisa_product_id == ASC_EISA_ID_740) ||
+		    (eisa_product_id == ASC_EISA_ID_750)) {
+			if (AscFindSignature(iop_base)) {
+				inpw(iop_base + 4);
+				return (iop_base);
+			}
+		}
+		if (iop_base == ASC_EISA_MAX_IOP_ADDR)
+			return (0);
+		if ((iop_base & 0x0050) == 0x0050) {
+			iop_base += ASC_EISA_BIG_IOP_GAP;
+		} else {
+			iop_base += ASC_EISA_SMALL_IOP_GAP;
+		}
+	}
+	return (0);
 }
 #endif /* CONFIG_ISA */
 
-STATIC int
-AscStartChip(
-                PortAddr iop_base
-)
+static int AscStartChip(PortAddr iop_base)
 {
-    AscSetChipControl(iop_base, 0);
-    if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
-        return (0);
-    }
-    return (1);
+	AscSetChipControl(iop_base, 0);
+	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
+		return (0);
+	}
+	return (1);
 }
 
-STATIC int
-AscStopChip(
-               PortAddr iop_base
-)
+static int AscStopChip(PortAddr iop_base)
 {
-    uchar               cc_val;
-
-    cc_val = AscGetChipControl(iop_base) & (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));
-    AscSetChipControl(iop_base, (uchar) (cc_val | CC_HALT));
-    AscSetChipIH(iop_base, INS_HALT);
-    AscSetChipIH(iop_base, INS_RFLAG_WTM);
-    if ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {
-        return (0);
-    }
-    return (1);
+	uchar cc_val;
+
+	cc_val =
+	    AscGetChipControl(iop_base) &
+	    (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));
+	AscSetChipControl(iop_base, (uchar)(cc_val | CC_HALT));
+	AscSetChipIH(iop_base, INS_HALT);
+	AscSetChipIH(iop_base, INS_RFLAG_WTM);
+	if ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {
+		return (0);
+	}
+	return (1);
 }
 
-STATIC int
-AscIsChipHalted(
-                   PortAddr iop_base
-)
+static int AscIsChipHalted(PortAddr iop_base)
 {
-    if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
-        if ((AscGetChipControl(iop_base) & CC_HALT) != 0) {
-            return (1);
-        }
-    }
-    return (0);
+	if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
+		if ((AscGetChipControl(iop_base) & CC_HALT) != 0) {
+			return (1);
+		}
+	}
+	return (0);
 }
 
-STATIC void
-AscSetChipIH(
-                PortAddr iop_base,
-                ushort ins_code
-)
+static void AscSetChipIH(PortAddr iop_base, ushort ins_code)
 {
-    AscSetBank(iop_base, 1);
-    AscWriteChipIH(iop_base, ins_code);
-    AscSetBank(iop_base, 0);
-    return;
+	AscSetBank(iop_base, 1);
+	AscWriteChipIH(iop_base, ins_code);
+	AscSetBank(iop_base, 0);
+	return;
 }
 
-STATIC void
-AscAckInterrupt(
-                   PortAddr iop_base
-)
+static void AscAckInterrupt(PortAddr iop_base)
 {
-    uchar               host_flag;
-    uchar               risc_flag;
-    ushort              loop;
-
-    loop = 0;
-    do {
-        risc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);
-        if (loop++ > 0x7FFF) {
-            break;
-        }
-    } while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);
-    host_flag = AscReadLramByte(iop_base, ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);
-    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
-                     (uchar) (host_flag | ASC_HOST_FLAG_ACK_INT));
-    AscSetChipStatus(iop_base, CIW_INT_ACK);
-    loop = 0;
-    while (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {
-        AscSetChipStatus(iop_base, CIW_INT_ACK);
-        if (loop++ > 3) {
-            break;
-        }
-    }
-    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
-    return;
+	uchar host_flag;
+	uchar risc_flag;
+	ushort loop;
+
+	loop = 0;
+	do {
+		risc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);
+		if (loop++ > 0x7FFF) {
+			break;
+		}
+	} while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);
+	host_flag =
+	    AscReadLramByte(iop_base,
+			    ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
+			 (uchar)(host_flag | ASC_HOST_FLAG_ACK_INT));
+	AscSetChipStatus(iop_base, CIW_INT_ACK);
+	loop = 0;
+	while (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {
+		AscSetChipStatus(iop_base, CIW_INT_ACK);
+		if (loop++ > 3) {
+			break;
+		}
+	}
+	AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
+	return;
 }
 
-STATIC void
-AscDisableInterrupt(
-                       PortAddr iop_base
-)
+static void AscDisableInterrupt(PortAddr iop_base)
 {
-    ushort              cfg;
+	ushort cfg;
 
-    cfg = AscGetChipCfgLsw(iop_base);
-    AscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));
-    return;
+	cfg = AscGetChipCfgLsw(iop_base);
+	AscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));
+	return;
 }
 
-STATIC void
-AscEnableInterrupt(
-                      PortAddr iop_base
-)
+static void AscEnableInterrupt(PortAddr iop_base)
 {
-    ushort              cfg;
+	ushort cfg;
 
-    cfg = AscGetChipCfgLsw(iop_base);
-    AscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);
-    return;
+	cfg = AscGetChipCfgLsw(iop_base);
+	AscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);
+	return;
 }
 
-
-
-STATIC void
-AscSetBank(
-              PortAddr iop_base,
-              uchar bank
-)
+static void AscSetBank(PortAddr iop_base, uchar bank)
 {
-    uchar               val;
-
-    val = AscGetChipControl(iop_base) &
-      (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET | CC_CHIP_RESET));
-    if (bank == 1) {
-        val |= CC_BANK_ONE;
-    } else if (bank == 2) {
-        val |= CC_DIAG | CC_BANK_ONE;
-    } else {
-        val &= ~CC_BANK_ONE;
-    }
-    AscSetChipControl(iop_base, val);
-    return;
+	uchar val;
+
+	val = AscGetChipControl(iop_base) &
+	    (~
+	     (CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET |
+	      CC_CHIP_RESET));
+	if (bank == 1) {
+		val |= CC_BANK_ONE;
+	} else if (bank == 2) {
+		val |= CC_DIAG | CC_BANK_ONE;
+	} else {
+		val &= ~CC_BANK_ONE;
+	}
+	AscSetChipControl(iop_base, val);
+	return;
 }
 
-STATIC int
-AscResetChipAndScsiBus(
-                          ASC_DVC_VAR *asc_dvc
-)
+static int AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)
 {
-    PortAddr    iop_base;
-    int         i = 10;
+	PortAddr iop_base;
+	int i = 10;
 
-    iop_base = asc_dvc->iop_base;
-    while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE) && (i-- > 0))
-    {
-          DvcSleepMilliSecond(100);
-    }
-    AscStopChip(iop_base);
-    AscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);
-    DvcDelayNanoSecond(asc_dvc, 60000);
-    AscSetChipIH(iop_base, INS_RFLAG_WTM);
-    AscSetChipIH(iop_base, INS_HALT);
-    AscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);
-    AscSetChipControl(iop_base, CC_HALT);
-    DvcSleepMilliSecond(200);
-    AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
-    AscSetChipStatus(iop_base, 0);
-    return (AscIsChipHalted(iop_base));
+	iop_base = asc_dvc->iop_base;
+	while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)
+	       && (i-- > 0)) {
+		DvcSleepMilliSecond(100);
+	}
+	AscStopChip(iop_base);
+	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);
+	DvcDelayNanoSecond(asc_dvc, 60000);
+	AscSetChipIH(iop_base, INS_RFLAG_WTM);
+	AscSetChipIH(iop_base, INS_HALT);
+	AscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);
+	AscSetChipControl(iop_base, CC_HALT);
+	DvcSleepMilliSecond(200);
+	AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+	AscSetChipStatus(iop_base, 0);
+	return (AscIsChipHalted(iop_base));
 }
 
-STATIC ASC_DCNT __init
-AscGetMaxDmaCount(
-                     ushort bus_type)
+static ASC_DCNT __init AscGetMaxDmaCount(ushort bus_type)
 {
-    if (bus_type & ASC_IS_ISA)
-        return (ASC_MAX_ISA_DMA_COUNT);
-    else if (bus_type & (ASC_IS_EISA | ASC_IS_VL))
-        return (ASC_MAX_VL_DMA_COUNT);
-    return (ASC_MAX_PCI_DMA_COUNT);
+	if (bus_type & ASC_IS_ISA)
+		return (ASC_MAX_ISA_DMA_COUNT);
+	else if (bus_type & (ASC_IS_EISA | ASC_IS_VL))
+		return (ASC_MAX_VL_DMA_COUNT);
+	return (ASC_MAX_PCI_DMA_COUNT);
 }
 
 #ifdef CONFIG_ISA
-STATIC ushort __init
-AscGetIsaDmaChannel(
-                       PortAddr iop_base)
+static ushort __init AscGetIsaDmaChannel(PortAddr iop_base)
 {
-    ushort              channel;
-
-    channel = AscGetChipCfgLsw(iop_base) & 0x0003;
-    if (channel == 0x03)
-        return (0);
-    else if (channel == 0x00)
-        return (7);
-    return (channel + 4);
+	ushort channel;
+
+	channel = AscGetChipCfgLsw(iop_base) & 0x0003;
+	if (channel == 0x03)
+		return (0);
+	else if (channel == 0x00)
+		return (7);
+	return (channel + 4);
 }
 
-STATIC ushort __init
-AscSetIsaDmaChannel(
-                       PortAddr iop_base,
-                       ushort dma_channel)
+static ushort __init AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)
 {
-    ushort              cfg_lsw;
-    uchar               value;
-
-    if ((dma_channel >= 5) && (dma_channel <= 7)) {
-        if (dma_channel == 7)
-            value = 0x00;
-        else
-            value = dma_channel - 4;
-        cfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;
-        cfg_lsw |= value;
-        AscSetChipCfgLsw(iop_base, cfg_lsw);
-        return (AscGetIsaDmaChannel(iop_base));
-    }
-    return (0);
+	ushort cfg_lsw;
+	uchar value;
+
+	if ((dma_channel >= 5) && (dma_channel <= 7)) {
+		if (dma_channel == 7)
+			value = 0x00;
+		else
+			value = dma_channel - 4;
+		cfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;
+		cfg_lsw |= value;
+		AscSetChipCfgLsw(iop_base, cfg_lsw);
+		return (AscGetIsaDmaChannel(iop_base));
+	}
+	return (0);
 }
 
-STATIC uchar __init
-AscSetIsaDmaSpeed(
-                     PortAddr iop_base,
-                     uchar speed_value)
+static uchar __init AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)
 {
-    speed_value &= 0x07;
-    AscSetBank(iop_base, 1);
-    AscWriteChipDmaSpeed(iop_base, speed_value);
-    AscSetBank(iop_base, 0);
-    return (AscGetIsaDmaSpeed(iop_base));
+	speed_value &= 0x07;
+	AscSetBank(iop_base, 1);
+	AscWriteChipDmaSpeed(iop_base, speed_value);
+	AscSetBank(iop_base, 0);
+	return (AscGetIsaDmaSpeed(iop_base));
 }
 
-STATIC uchar __init
-AscGetIsaDmaSpeed(
-                     PortAddr iop_base
-)
+static uchar __init AscGetIsaDmaSpeed(PortAddr iop_base)
 {
-    uchar               speed_value;
+	uchar speed_value;
 
-    AscSetBank(iop_base, 1);
-    speed_value = AscReadChipDmaSpeed(iop_base);
-    speed_value &= 0x07;
-    AscSetBank(iop_base, 0);
-    return (speed_value);
+	AscSetBank(iop_base, 1);
+	speed_value = AscReadChipDmaSpeed(iop_base);
+	speed_value &= 0x07;
+	AscSetBank(iop_base, 0);
+	return (speed_value);
 }
 #endif /* CONFIG_ISA */
 
-STATIC ushort __init
-AscReadPCIConfigWord(
-    ASC_DVC_VAR *asc_dvc,
-    ushort pci_config_offset)
+static ushort __init
+AscReadPCIConfigWord(ASC_DVC_VAR *asc_dvc, ushort pci_config_offset)
 {
-    uchar       lsb, msb;
+	uchar lsb, msb;
 
-    lsb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset);
-    msb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset + 1);
-    return ((ushort) ((msb << 8) | lsb));
+	lsb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset);
+	msb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset + 1);
+	return ((ushort)((msb << 8) | lsb));
 }
 
-STATIC ushort __init
-AscInitGetConfig(
-        ASC_DVC_VAR *asc_dvc
-)
+static ushort __init AscInitGetConfig(ASC_DVC_VAR *asc_dvc)
 {
-    ushort              warn_code;
-    PortAddr            iop_base;
-    ushort              PCIDeviceID;
-    ushort              PCIVendorID;
-    uchar               PCIRevisionID;
-    uchar               prevCmdRegBits;
-
-    warn_code = 0;
-    iop_base = asc_dvc->iop_base;
-    asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
-    if (asc_dvc->err_code != 0) {
-        return (UW_ERR);
-    }
-    if (asc_dvc->bus_type == ASC_IS_PCI) {
-        PCIVendorID = AscReadPCIConfigWord(asc_dvc,
-                                    AscPCIConfigVendorIDRegister);
-
-        PCIDeviceID = AscReadPCIConfigWord(asc_dvc,
-                                    AscPCIConfigDeviceIDRegister);
-
-        PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
-                                    AscPCIConfigRevisionIDRegister);
-
-        if (PCIVendorID != PCI_VENDOR_ID_ASP) {
-            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-        }
-        prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
-                                    AscPCIConfigCommandRegister);
-
-        if ((prevCmdRegBits & AscPCICmdRegBits_IOMemBusMaster) !=
-            AscPCICmdRegBits_IOMemBusMaster) {
-            DvcWritePCIConfigByte(asc_dvc,
-                            AscPCIConfigCommandRegister,
-                            (prevCmdRegBits |
-                             AscPCICmdRegBits_IOMemBusMaster));
-
-            if ((DvcReadPCIConfigByte(asc_dvc,
-                                AscPCIConfigCommandRegister)
-                 & AscPCICmdRegBits_IOMemBusMaster)
-                != AscPCICmdRegBits_IOMemBusMaster) {
-                warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-            }
-        }
-        if ((PCIDeviceID == PCI_DEVICE_ID_ASP_1200A) ||
-            (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940)) {
-            DvcWritePCIConfigByte(asc_dvc,
-                            AscPCIConfigLatencyTimer, 0x00);
-            if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
-                != 0x00) {
-                warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-            }
-        } else if (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940U) {
-            if (DvcReadPCIConfigByte(asc_dvc,
-                                AscPCIConfigLatencyTimer) < 0x20) {
-                DvcWritePCIConfigByte(asc_dvc,
-                                    AscPCIConfigLatencyTimer, 0x20);
-
-                if (DvcReadPCIConfigByte(asc_dvc,
-                                    AscPCIConfigLatencyTimer) < 0x20) {
-                    warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-                }
-            }
-        }
-    }
+	ushort warn_code;
+	PortAddr iop_base;
+	ushort PCIDeviceID;
+	ushort PCIVendorID;
+	uchar PCIRevisionID;
+	uchar prevCmdRegBits;
+
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+	asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
+	if (asc_dvc->err_code != 0) {
+		return (UW_ERR);
+	}
+	if (asc_dvc->bus_type == ASC_IS_PCI) {
+		PCIVendorID = AscReadPCIConfigWord(asc_dvc,
+						   AscPCIConfigVendorIDRegister);
+
+		PCIDeviceID = AscReadPCIConfigWord(asc_dvc,
+						   AscPCIConfigDeviceIDRegister);
+
+		PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
+						     AscPCIConfigRevisionIDRegister);
+
+		if (PCIVendorID != PCI_VENDOR_ID_ASP) {
+			warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+		}
+		prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
+						      AscPCIConfigCommandRegister);
+
+		if ((prevCmdRegBits & AscPCICmdRegBits_IOMemBusMaster) !=
+		    AscPCICmdRegBits_IOMemBusMaster) {
+			DvcWritePCIConfigByte(asc_dvc,
+					      AscPCIConfigCommandRegister,
+					      (prevCmdRegBits |
+					       AscPCICmdRegBits_IOMemBusMaster));
+
+			if ((DvcReadPCIConfigByte(asc_dvc,
+						  AscPCIConfigCommandRegister)
+			     & AscPCICmdRegBits_IOMemBusMaster)
+			    != AscPCICmdRegBits_IOMemBusMaster) {
+				warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+			}
+		}
+		if ((PCIDeviceID == PCI_DEVICE_ID_ASP_1200A) ||
+		    (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940)) {
+			DvcWritePCIConfigByte(asc_dvc,
+					      AscPCIConfigLatencyTimer, 0x00);
+			if (DvcReadPCIConfigByte
+			    (asc_dvc, AscPCIConfigLatencyTimer)
+			    != 0x00) {
+				warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+			}
+		} else if (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940U) {
+			if (DvcReadPCIConfigByte(asc_dvc,
+						 AscPCIConfigLatencyTimer) <
+			    0x20) {
+				DvcWritePCIConfigByte(asc_dvc,
+						      AscPCIConfigLatencyTimer,
+						      0x20);
+
+				if (DvcReadPCIConfigByte(asc_dvc,
+							 AscPCIConfigLatencyTimer)
+				    < 0x20) {
+					warn_code |=
+					    ASC_WARN_SET_PCI_CONFIG_SPACE;
+				}
+			}
+		}
+	}
 
-    if (AscFindSignature(iop_base)) {
-        warn_code |= AscInitAscDvcVar(asc_dvc);
-        warn_code |= AscInitFromEEP(asc_dvc);
-        asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
-        if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT) {
-            asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
-        }
-    } else {
-        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-    }
-    return(warn_code);
+	if (AscFindSignature(iop_base)) {
+		warn_code |= AscInitAscDvcVar(asc_dvc);
+		warn_code |= AscInitFromEEP(asc_dvc);
+		asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
+		if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT) {
+			asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
+		}
+	} else {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+	}
+	return (warn_code);
 }
 
-STATIC ushort __init
-AscInitSetConfig(
-                    ASC_DVC_VAR *asc_dvc
-)
+static ushort __init AscInitSetConfig(ASC_DVC_VAR *asc_dvc)
 {
-    ushort              warn_code = 0;
-
-    asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
-    if (asc_dvc->err_code != 0)
-        return (UW_ERR);
-    if (AscFindSignature(asc_dvc->iop_base)) {
-        warn_code |= AscInitFromAscDvcVar(asc_dvc);
-        asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
-    } else {
-        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-    }
-    return (warn_code);
+	ushort warn_code = 0;
+
+	asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
+	if (asc_dvc->err_code != 0)
+		return (UW_ERR);
+	if (AscFindSignature(asc_dvc->iop_base)) {
+		warn_code |= AscInitFromAscDvcVar(asc_dvc);
+		asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
+	} else {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+	}
+	return (warn_code);
 }
 
-STATIC ushort __init
-AscInitFromAscDvcVar(
-                        ASC_DVC_VAR *asc_dvc
-)
+static ushort __init AscInitFromAscDvcVar(ASC_DVC_VAR *asc_dvc)
 {
-    PortAddr            iop_base;
-    ushort              cfg_msw;
-    ushort              warn_code;
-    ushort              pci_device_id = 0;
+	PortAddr iop_base;
+	ushort cfg_msw;
+	ushort warn_code;
+	ushort pci_device_id = 0;
 
-    iop_base = asc_dvc->iop_base;
+	iop_base = asc_dvc->iop_base;
 #ifdef CONFIG_PCI
-    if (asc_dvc->cfg->dev)
-        pci_device_id = to_pci_dev(asc_dvc->cfg->dev)->device;
+	if (asc_dvc->cfg->dev)
+		pci_device_id = to_pci_dev(asc_dvc->cfg->dev)->device;
 #endif
-    warn_code = 0;
-    cfg_msw = AscGetChipCfgMsw(iop_base);
-    if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
-        cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
-        warn_code |= ASC_WARN_CFG_MSW_RECOVER;
-        AscSetChipCfgMsw(iop_base, cfg_msw);
-    }
-    if ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=
-        asc_dvc->cfg->cmd_qng_enabled) {
-        asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;
-        warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
-    }
-    if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
-        warn_code |= ASC_WARN_AUTO_CONFIG;
-    }
-    if ((asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {
-        if (AscSetChipIRQ(iop_base, asc_dvc->irq_no, asc_dvc->bus_type)
-            != asc_dvc->irq_no) {
-            asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
-        }
-    }
-    if (asc_dvc->bus_type & ASC_IS_PCI) {
-        cfg_msw &= 0xFFC0;
-        AscSetChipCfgMsw(iop_base, cfg_msw);
-        if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
-        } else {
-            if ((pci_device_id == PCI_DEVICE_ID_ASP_1200A) ||
-                (pci_device_id == PCI_DEVICE_ID_ASP_ABP940)) {
-                asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
-                asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
-            }
-        }
-    } else if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
-        if (AscGetChipVersion(iop_base, asc_dvc->bus_type)
-            == ASC_CHIP_VER_ASYN_BUG) {
-            asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
-        }
-    }
-    if (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=
-        asc_dvc->cfg->chip_scsi_id) {
-        asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;
-    }
+	warn_code = 0;
+	cfg_msw = AscGetChipCfgMsw(iop_base);
+	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
+		cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
+		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
+		AscSetChipCfgMsw(iop_base, cfg_msw);
+	}
+	if ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=
+	    asc_dvc->cfg->cmd_qng_enabled) {
+		asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;
+		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
+	}
+	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
+		warn_code |= ASC_WARN_AUTO_CONFIG;
+	}
+	if ((asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {
+		if (AscSetChipIRQ(iop_base, asc_dvc->irq_no, asc_dvc->bus_type)
+		    != asc_dvc->irq_no) {
+			asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
+		}
+	}
+	if (asc_dvc->bus_type & ASC_IS_PCI) {
+		cfg_msw &= 0xFFC0;
+		AscSetChipCfgMsw(iop_base, cfg_msw);
+		if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
+		} else {
+			if ((pci_device_id == PCI_DEVICE_ID_ASP_1200A) ||
+			    (pci_device_id == PCI_DEVICE_ID_ASP_ABP940)) {
+				asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
+				asc_dvc->bug_fix_cntl |=
+				    ASC_BUG_FIX_ASYN_USE_SYN;
+			}
+		}
+	} else if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
+		if (AscGetChipVersion(iop_base, asc_dvc->bus_type)
+		    == ASC_CHIP_VER_ASYN_BUG) {
+			asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
+		}
+	}
+	if (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=
+	    asc_dvc->cfg->chip_scsi_id) {
+		asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;
+	}
 #ifdef CONFIG_ISA
-    if (asc_dvc->bus_type & ASC_IS_ISA) {
-        AscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);
-        AscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);
-    }
+	if (asc_dvc->bus_type & ASC_IS_ISA) {
+		AscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);
+		AscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);
+	}
 #endif /* CONFIG_ISA */
-    return (warn_code);
+	return (warn_code);
 }
 
-STATIC ushort
-AscInitAsc1000Driver(
-                        ASC_DVC_VAR *asc_dvc
-)
+static ushort AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)
 {
-    ushort              warn_code;
-    PortAddr            iop_base;
-
-    iop_base = asc_dvc->iop_base;
-    warn_code = 0;
-    if ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&
-        !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {
-        AscResetChipAndScsiBus(asc_dvc);
-        DvcSleepMilliSecond((ASC_DCNT)
-            ((ushort) asc_dvc->scsi_reset_wait * 1000));
-    }
-    asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
-    if (asc_dvc->err_code != 0)
-        return (UW_ERR);
-    if (!AscFindSignature(asc_dvc->iop_base)) {
-        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-        return (warn_code);
-    }
-    AscDisableInterrupt(iop_base);
-    warn_code |= AscInitLram(asc_dvc);
-    if (asc_dvc->err_code != 0)
-        return (UW_ERR);
-    ASC_DBG1(1, "AscInitAsc1000Driver: _asc_mcode_chksum 0x%lx\n",
-        (ulong) _asc_mcode_chksum);
-    if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
-                         _asc_mcode_size) != _asc_mcode_chksum) {
-        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
-        return (warn_code);
-    }
-    warn_code |= AscInitMicroCodeVar(asc_dvc);
-    asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
-    AscEnableInterrupt(iop_base);
-    return (warn_code);
+	ushort warn_code;
+	PortAddr iop_base;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	if ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&
+	    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {
+		AscResetChipAndScsiBus(asc_dvc);
+		DvcSleepMilliSecond((ASC_DCNT)
+				    ((ushort)asc_dvc->scsi_reset_wait * 1000));
+	}
+	asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
+	if (asc_dvc->err_code != 0)
+		return (UW_ERR);
+	if (!AscFindSignature(asc_dvc->iop_base)) {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+		return (warn_code);
+	}
+	AscDisableInterrupt(iop_base);
+	warn_code |= AscInitLram(asc_dvc);
+	if (asc_dvc->err_code != 0)
+		return (UW_ERR);
+	ASC_DBG1(1, "AscInitAsc1000Driver: _asc_mcode_chksum 0x%lx\n",
+		 (ulong)_asc_mcode_chksum);
+	if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
+			     _asc_mcode_size) != _asc_mcode_chksum) {
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+		return (warn_code);
+	}
+	warn_code |= AscInitMicroCodeVar(asc_dvc);
+	asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
+	AscEnableInterrupt(iop_base);
+	return (warn_code);
 }
 
-STATIC ushort __init
-AscInitAscDvcVar(
-                    ASC_DVC_VAR *asc_dvc)
+static ushort __init AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)
 {
-    int                 i;
-    PortAddr            iop_base;
-    ushort              warn_code;
-    uchar               chip_version;
-
-    iop_base = asc_dvc->iop_base;
-    warn_code = 0;
-    asc_dvc->err_code = 0;
-    if ((asc_dvc->bus_type &
-         (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {
-        asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;
-    }
-    AscSetChipControl(iop_base, CC_HALT);
-    AscSetChipStatus(iop_base, 0);
-    asc_dvc->bug_fix_cntl = 0;
-    asc_dvc->pci_fix_asyn_xfer = 0;
-    asc_dvc->pci_fix_asyn_xfer_always = 0;
-    /* asc_dvc->init_state initalized in AscInitGetConfig(). */
-    asc_dvc->sdtr_done = 0;
-    asc_dvc->cur_total_qng = 0;
-    asc_dvc->is_in_int = 0;
-    asc_dvc->in_critical_cnt = 0;
-    asc_dvc->last_q_shortage = 0;
-    asc_dvc->use_tagged_qng = 0;
-    asc_dvc->no_scam = 0;
-    asc_dvc->unit_not_ready = 0;
-    asc_dvc->queue_full_or_busy = 0;
-    asc_dvc->redo_scam = 0;
-    asc_dvc->res2 = 0;
-    asc_dvc->host_init_sdtr_index = 0;
-    asc_dvc->cfg->can_tagged_qng = 0;
-    asc_dvc->cfg->cmd_qng_enabled = 0;
-    asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;
-    asc_dvc->init_sdtr = 0;
-    asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;
-    asc_dvc->scsi_reset_wait = 3;
-    asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;
-    asc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);
-    asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;
-    asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;
-    asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
-    asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER;
-    asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
-      ASC_LIB_VERSION_MINOR;
-    chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
-    asc_dvc->cfg->chip_version = chip_version;
-    asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
-    asc_dvc->sdtr_period_tbl[1] = SYN_XFER_NS_1;
-    asc_dvc->sdtr_period_tbl[2] = SYN_XFER_NS_2;
-    asc_dvc->sdtr_period_tbl[3] = SYN_XFER_NS_3;
-    asc_dvc->sdtr_period_tbl[4] = SYN_XFER_NS_4;
-    asc_dvc->sdtr_period_tbl[5] = SYN_XFER_NS_5;
-    asc_dvc->sdtr_period_tbl[6] = SYN_XFER_NS_6;
-    asc_dvc->sdtr_period_tbl[7] = SYN_XFER_NS_7;
-    asc_dvc->max_sdtr_index = 7;
-    if ((asc_dvc->bus_type & ASC_IS_PCI) &&
-        (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {
-        asc_dvc->bus_type = ASC_IS_PCI_ULTRA;
-        asc_dvc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;
-        asc_dvc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;
-        asc_dvc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;
-        asc_dvc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;
-        asc_dvc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;
-        asc_dvc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;
-        asc_dvc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;
-        asc_dvc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;
-        asc_dvc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;
-        asc_dvc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;
-        asc_dvc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;
-        asc_dvc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;
-        asc_dvc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;
-        asc_dvc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;
-        asc_dvc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;
-        asc_dvc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;
-        asc_dvc->max_sdtr_index = 15;
-        if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150)
-        {
-            AscSetExtraControl(iop_base,
-                (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
-        } else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {
-            AscSetExtraControl(iop_base,
-                (SEC_ACTIVE_NEGATE | SEC_ENABLE_FILTER));
-        }
-    }
-    if (asc_dvc->bus_type == ASC_IS_PCI) {
-           AscSetExtraControl(iop_base, (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
-    }
+	int i;
+	PortAddr iop_base;
+	ushort warn_code;
+	uchar chip_version;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	asc_dvc->err_code = 0;
+	if ((asc_dvc->bus_type &
+	     (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {
+		asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;
+	}
+	AscSetChipControl(iop_base, CC_HALT);
+	AscSetChipStatus(iop_base, 0);
+	asc_dvc->bug_fix_cntl = 0;
+	asc_dvc->pci_fix_asyn_xfer = 0;
+	asc_dvc->pci_fix_asyn_xfer_always = 0;
+	/* asc_dvc->init_state initalized in AscInitGetConfig(). */
+	asc_dvc->sdtr_done = 0;
+	asc_dvc->cur_total_qng = 0;
+	asc_dvc->is_in_int = 0;
+	asc_dvc->in_critical_cnt = 0;
+	asc_dvc->last_q_shortage = 0;
+	asc_dvc->use_tagged_qng = 0;
+	asc_dvc->no_scam = 0;
+	asc_dvc->unit_not_ready = 0;
+	asc_dvc->queue_full_or_busy = 0;
+	asc_dvc->redo_scam = 0;
+	asc_dvc->res2 = 0;
+	asc_dvc->host_init_sdtr_index = 0;
+	asc_dvc->cfg->can_tagged_qng = 0;
+	asc_dvc->cfg->cmd_qng_enabled = 0;
+	asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;
+	asc_dvc->init_sdtr = 0;
+	asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;
+	asc_dvc->scsi_reset_wait = 3;
+	asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;
+	asc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);
+	asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;
+	asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;
+	asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
+	asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER;
+	asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
+	    ASC_LIB_VERSION_MINOR;
+	chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
+	asc_dvc->cfg->chip_version = chip_version;
+	asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
+	asc_dvc->sdtr_period_tbl[1] = SYN_XFER_NS_1;
+	asc_dvc->sdtr_period_tbl[2] = SYN_XFER_NS_2;
+	asc_dvc->sdtr_period_tbl[3] = SYN_XFER_NS_3;
+	asc_dvc->sdtr_period_tbl[4] = SYN_XFER_NS_4;
+	asc_dvc->sdtr_period_tbl[5] = SYN_XFER_NS_5;
+	asc_dvc->sdtr_period_tbl[6] = SYN_XFER_NS_6;
+	asc_dvc->sdtr_period_tbl[7] = SYN_XFER_NS_7;
+	asc_dvc->max_sdtr_index = 7;
+	if ((asc_dvc->bus_type & ASC_IS_PCI) &&
+	    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {
+		asc_dvc->bus_type = ASC_IS_PCI_ULTRA;
+		asc_dvc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;
+		asc_dvc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;
+		asc_dvc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;
+		asc_dvc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;
+		asc_dvc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;
+		asc_dvc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;
+		asc_dvc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;
+		asc_dvc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;
+		asc_dvc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;
+		asc_dvc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;
+		asc_dvc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;
+		asc_dvc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;
+		asc_dvc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;
+		asc_dvc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;
+		asc_dvc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;
+		asc_dvc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;
+		asc_dvc->max_sdtr_index = 15;
+		if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {
+			AscSetExtraControl(iop_base,
+					   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
+		} else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {
+			AscSetExtraControl(iop_base,
+					   (SEC_ACTIVE_NEGATE |
+					    SEC_ENABLE_FILTER));
+		}
+	}
+	if (asc_dvc->bus_type == ASC_IS_PCI) {
+		AscSetExtraControl(iop_base,
+				   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
+	}
 
-    asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;
-    if (AscGetChipBusType(iop_base) == ASC_IS_ISAPNP) {
-        AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
-        asc_dvc->bus_type = ASC_IS_ISAPNP;
-    }
+	asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;
+	if (AscGetChipBusType(iop_base) == ASC_IS_ISAPNP) {
+		AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
+		asc_dvc->bus_type = ASC_IS_ISAPNP;
+	}
 #ifdef CONFIG_ISA
-    if ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {
-        asc_dvc->cfg->isa_dma_channel = (uchar) AscGetIsaDmaChannel(iop_base);
-    }
+	if ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {
+		asc_dvc->cfg->isa_dma_channel =
+		    (uchar)AscGetIsaDmaChannel(iop_base);
+	}
 #endif /* CONFIG_ISA */
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        asc_dvc->cur_dvc_qng[i] = 0;
-        asc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;
-        asc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *) 0L;
-        asc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *) 0L;
-        asc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;
-    }
-    return (warn_code);
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		asc_dvc->cur_dvc_qng[i] = 0;
+		asc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;
+		asc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *)0L;
+		asc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;
+		asc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;
+	}
+	return (warn_code);
 }
 
-STATIC ushort __init
-AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
+static ushort __init AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
 {
-    ASCEEP_CONFIG       eep_config_buf;
-    ASCEEP_CONFIG       *eep_config;
-    PortAddr            iop_base;
-    ushort              chksum;
-    ushort              warn_code;
-    ushort              cfg_msw, cfg_lsw;
-    int                 i;
-    int                 write_eep = 0;
-
-    iop_base = asc_dvc->iop_base;
-    warn_code = 0;
-    AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);
-    AscStopQueueExe(iop_base);
-    if ((AscStopChip(iop_base) == FALSE) ||
-        (AscGetChipScsiCtrl(iop_base) != 0)) {
-        asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
-        AscResetChipAndScsiBus(asc_dvc);
-        DvcSleepMilliSecond((ASC_DCNT)
-            ((ushort) asc_dvc->scsi_reset_wait * 1000));
-    }
-    if (AscIsChipHalted(iop_base) == FALSE) {
-        asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
-        return (warn_code);
-    }
-    AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
-    if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
-        asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
-        return (warn_code);
-    }
-    eep_config = (ASCEEP_CONFIG *) &eep_config_buf;
-    cfg_msw = AscGetChipCfgMsw(iop_base);
-    cfg_lsw = AscGetChipCfgLsw(iop_base);
-    if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
-        cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
-        warn_code |= ASC_WARN_CFG_MSW_RECOVER;
-        AscSetChipCfgMsw(iop_base, cfg_msw);
-    }
-    chksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);
-    ASC_DBG1(1, "AscInitFromEEP: chksum 0x%x\n", chksum);
-    if (chksum == 0) {
-        chksum = 0xaa55;
-    }
-    if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
-        warn_code |= ASC_WARN_AUTO_CONFIG;
-        if (asc_dvc->cfg->chip_version == 3) {
-            if (eep_config->cfg_lsw != cfg_lsw) {
-                warn_code |= ASC_WARN_EEPROM_RECOVER;
-                eep_config->cfg_lsw = AscGetChipCfgLsw(iop_base);
-            }
-            if (eep_config->cfg_msw != cfg_msw) {
-                warn_code |= ASC_WARN_EEPROM_RECOVER;
-                eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
-            }
-        }
-    }
-    eep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
-    eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;
-    ASC_DBG1(1, "AscInitFromEEP: eep_config->chksum 0x%x\n",
-        eep_config->chksum);
-    if (chksum != eep_config->chksum) {
-            if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
-                    ASC_CHIP_VER_PCI_ULTRA_3050 )
-            {
-                ASC_DBG(1,
-"AscInitFromEEP: chksum error ignored; EEPROM-less board\n");
-                eep_config->init_sdtr = 0xFF;
-                eep_config->disc_enable = 0xFF;
-                eep_config->start_motor = 0xFF;
-                eep_config->use_cmd_qng = 0;
-                eep_config->max_total_qng = 0xF0;
-                eep_config->max_tag_qng = 0x20;
-                eep_config->cntl = 0xBFFF;
-                ASC_EEP_SET_CHIP_ID(eep_config, 7);
-                eep_config->no_scam = 0;
-                eep_config->adapter_info[0] = 0;
-                eep_config->adapter_info[1] = 0;
-                eep_config->adapter_info[2] = 0;
-                eep_config->adapter_info[3] = 0;
-                eep_config->adapter_info[4] = 0;
-                /* Indicate EEPROM-less board. */
-                eep_config->adapter_info[5] = 0xBB;
-            } else {
-                ASC_PRINT(
-"AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\n");
-                write_eep = 1;
-                warn_code |= ASC_WARN_EEPROM_CHKSUM;
-            }
-    }
-    asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;
-    asc_dvc->cfg->disc_enable = eep_config->disc_enable;
-    asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;
-    asc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);
-    asc_dvc->start_motor = eep_config->start_motor;
-    asc_dvc->dvc_cntl = eep_config->cntl;
-    asc_dvc->no_scam = eep_config->no_scam;
-    asc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];
-    asc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];
-    asc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];
-    asc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];
-    asc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];
-    asc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];
-    if (!AscTestExternalLram(asc_dvc)) {
-        if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA)) {
-            eep_config->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;
-            eep_config->max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;
-        } else {
-            eep_config->cfg_msw |= 0x0800;
-            cfg_msw |= 0x0800;
-            AscSetChipCfgMsw(iop_base, cfg_msw);
-            eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;
-            eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;
-        }
-    } else {
-    }
-    if (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {
-        eep_config->max_total_qng = ASC_MIN_TOTAL_QNG;
-    }
-    if (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {
-        eep_config->max_total_qng = ASC_MAX_TOTAL_QNG;
-    }
-    if (eep_config->max_tag_qng > eep_config->max_total_qng) {
-        eep_config->max_tag_qng = eep_config->max_total_qng;
-    }
-    if (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {
-        eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;
-    }
-    asc_dvc->max_total_qng = eep_config->max_total_qng;
-    if ((eep_config->use_cmd_qng & eep_config->disc_enable) !=
-        eep_config->use_cmd_qng) {
-        eep_config->disc_enable = eep_config->use_cmd_qng;
-        warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
-    }
-    if (asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA)) {
-        asc_dvc->irq_no = AscGetChipIRQ(iop_base, asc_dvc->bus_type);
-    }
-    ASC_EEP_SET_CHIP_ID(eep_config, ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);
-    asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
-    if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&
-        !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {
-        asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
-    }
+	ASCEEP_CONFIG eep_config_buf;
+	ASCEEP_CONFIG *eep_config;
+	PortAddr iop_base;
+	ushort chksum;
+	ushort warn_code;
+	ushort cfg_msw, cfg_lsw;
+	int i;
+	int write_eep = 0;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);
+	AscStopQueueExe(iop_base);
+	if ((AscStopChip(iop_base) == FALSE) ||
+	    (AscGetChipScsiCtrl(iop_base) != 0)) {
+		asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
+		AscResetChipAndScsiBus(asc_dvc);
+		DvcSleepMilliSecond((ASC_DCNT)
+				    ((ushort)asc_dvc->scsi_reset_wait * 1000));
+	}
+	if (AscIsChipHalted(iop_base) == FALSE) {
+		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
+		return (warn_code);
+	}
+	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
+	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
+		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
+		return (warn_code);
+	}
+	eep_config = (ASCEEP_CONFIG *)&eep_config_buf;
+	cfg_msw = AscGetChipCfgMsw(iop_base);
+	cfg_lsw = AscGetChipCfgLsw(iop_base);
+	if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
+		cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
+		warn_code |= ASC_WARN_CFG_MSW_RECOVER;
+		AscSetChipCfgMsw(iop_base, cfg_msw);
+	}
+	chksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);
+	ASC_DBG1(1, "AscInitFromEEP: chksum 0x%x\n", chksum);
+	if (chksum == 0) {
+		chksum = 0xaa55;
+	}
+	if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
+		warn_code |= ASC_WARN_AUTO_CONFIG;
+		if (asc_dvc->cfg->chip_version == 3) {
+			if (eep_config->cfg_lsw != cfg_lsw) {
+				warn_code |= ASC_WARN_EEPROM_RECOVER;
+				eep_config->cfg_lsw =
+				    AscGetChipCfgLsw(iop_base);
+			}
+			if (eep_config->cfg_msw != cfg_msw) {
+				warn_code |= ASC_WARN_EEPROM_RECOVER;
+				eep_config->cfg_msw =
+				    AscGetChipCfgMsw(iop_base);
+			}
+		}
+	}
+	eep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
+	eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;
+	ASC_DBG1(1, "AscInitFromEEP: eep_config->chksum 0x%x\n",
+		 eep_config->chksum);
+	if (chksum != eep_config->chksum) {
+		if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
+		    ASC_CHIP_VER_PCI_ULTRA_3050) {
+			ASC_DBG(1,
+				"AscInitFromEEP: chksum error ignored; EEPROM-less board\n");
+			eep_config->init_sdtr = 0xFF;
+			eep_config->disc_enable = 0xFF;
+			eep_config->start_motor = 0xFF;
+			eep_config->use_cmd_qng = 0;
+			eep_config->max_total_qng = 0xF0;
+			eep_config->max_tag_qng = 0x20;
+			eep_config->cntl = 0xBFFF;
+			ASC_EEP_SET_CHIP_ID(eep_config, 7);
+			eep_config->no_scam = 0;
+			eep_config->adapter_info[0] = 0;
+			eep_config->adapter_info[1] = 0;
+			eep_config->adapter_info[2] = 0;
+			eep_config->adapter_info[3] = 0;
+			eep_config->adapter_info[4] = 0;
+			/* Indicate EEPROM-less board. */
+			eep_config->adapter_info[5] = 0xBB;
+		} else {
+			ASC_PRINT
+			    ("AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\n");
+			write_eep = 1;
+			warn_code |= ASC_WARN_EEPROM_CHKSUM;
+		}
+	}
+	asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;
+	asc_dvc->cfg->disc_enable = eep_config->disc_enable;
+	asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;
+	asc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);
+	asc_dvc->start_motor = eep_config->start_motor;
+	asc_dvc->dvc_cntl = eep_config->cntl;
+	asc_dvc->no_scam = eep_config->no_scam;
+	asc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];
+	asc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];
+	asc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];
+	asc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];
+	asc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];
+	asc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];
+	if (!AscTestExternalLram(asc_dvc)) {
+		if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) ==
+		     ASC_IS_PCI_ULTRA)) {
+			eep_config->max_total_qng =
+			    ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;
+			eep_config->max_tag_qng =
+			    ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;
+		} else {
+			eep_config->cfg_msw |= 0x0800;
+			cfg_msw |= 0x0800;
+			AscSetChipCfgMsw(iop_base, cfg_msw);
+			eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;
+			eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;
+		}
+	} else {
+	}
+	if (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {
+		eep_config->max_total_qng = ASC_MIN_TOTAL_QNG;
+	}
+	if (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {
+		eep_config->max_total_qng = ASC_MAX_TOTAL_QNG;
+	}
+	if (eep_config->max_tag_qng > eep_config->max_total_qng) {
+		eep_config->max_tag_qng = eep_config->max_total_qng;
+	}
+	if (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {
+		eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;
+	}
+	asc_dvc->max_total_qng = eep_config->max_total_qng;
+	if ((eep_config->use_cmd_qng & eep_config->disc_enable) !=
+	    eep_config->use_cmd_qng) {
+		eep_config->disc_enable = eep_config->use_cmd_qng;
+		warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
+	}
+	if (asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA)) {
+		asc_dvc->irq_no = AscGetChipIRQ(iop_base, asc_dvc->bus_type);
+	}
+	ASC_EEP_SET_CHIP_ID(eep_config,
+			    ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);
+	asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
+	if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&
+	    !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {
+		asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
+	}
 
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        asc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];
-        asc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;
-        asc_dvc->cfg->sdtr_period_offset[i] =
-            (uchar) (ASC_DEF_SDTR_OFFSET |
-                     (asc_dvc->host_init_sdtr_index << 4));
-    }
-    eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
-    if (write_eep) {
-        if ((i = AscSetEEPConfig(iop_base, eep_config, asc_dvc->bus_type)) !=
-             0) {
-                ASC_PRINT1(
-"AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n", i);
-        } else {
-                ASC_PRINT("AscInitFromEEP: Successfully re-wrote EEPROM.\n");
-        }
-    }
-    return (warn_code);
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		asc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];
+		asc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;
+		asc_dvc->cfg->sdtr_period_offset[i] =
+		    (uchar)(ASC_DEF_SDTR_OFFSET |
+			    (asc_dvc->host_init_sdtr_index << 4));
+	}
+	eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
+	if (write_eep) {
+		if ((i =
+		     AscSetEEPConfig(iop_base, eep_config,
+				     asc_dvc->bus_type)) != 0) {
+			ASC_PRINT1
+			    ("AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n",
+			     i);
+		} else {
+			ASC_PRINT
+			    ("AscInitFromEEP: Successfully re-wrote EEPROM.\n");
+		}
+	}
+	return (warn_code);
 }
 
-STATIC ushort
-AscInitMicroCodeVar(
-                       ASC_DVC_VAR *asc_dvc
-)
+static ushort AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)
 {
-    int                 i;
-    ushort              warn_code;
-    PortAddr            iop_base;
-    ASC_PADDR           phy_addr;
-    ASC_DCNT            phy_size;
-
-    iop_base = asc_dvc->iop_base;
-    warn_code = 0;
-    for (i = 0; i <= ASC_MAX_TID; i++) {
-        AscPutMCodeInitSDTRAtID(iop_base, i,
-                                asc_dvc->cfg->sdtr_period_offset[i]
-);
-    }
+	int i;
+	ushort warn_code;
+	PortAddr iop_base;
+	ASC_PADDR phy_addr;
+	ASC_DCNT phy_size;
+
+	iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	for (i = 0; i <= ASC_MAX_TID; i++) {
+		AscPutMCodeInitSDTRAtID(iop_base, i,
+					asc_dvc->cfg->sdtr_period_offset[i]
+		    );
+	}
 
-    AscInitQLinkVar(asc_dvc);
-    AscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,
-                     asc_dvc->cfg->disc_enable);
-    AscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,
-                     ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));
-
-    /* Align overrun buffer on an 8 byte boundary. */
-    phy_addr = virt_to_bus(asc_dvc->cfg->overrun_buf);
-    phy_addr = cpu_to_le32((phy_addr + 7) & ~0x7);
-    AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
-        (uchar *) &phy_addr, 1);
-    phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE - 8);
-    AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,
-        (uchar *) &phy_size, 1);
-
-    asc_dvc->cfg->mcode_date =
-        AscReadLramWord(iop_base, (ushort) ASCV_MC_DATE_W);
-    asc_dvc->cfg->mcode_version =
-        AscReadLramWord(iop_base, (ushort) ASCV_MC_VER_W);
-
-    AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
-    if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
-        asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
-        return (warn_code);
-    }
-    if (AscStartChip(iop_base) != 1) {
-        asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
-        return (warn_code);
-    }
+	AscInitQLinkVar(asc_dvc);
+	AscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,
+			 asc_dvc->cfg->disc_enable);
+	AscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,
+			 ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));
+
+	/* Align overrun buffer on an 8 byte boundary. */
+	phy_addr = virt_to_bus(asc_dvc->cfg->overrun_buf);
+	phy_addr = cpu_to_le32((phy_addr + 7) & ~0x7);
+	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
+				 (uchar *)&phy_addr, 1);
+	phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE - 8);
+	AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,
+				 (uchar *)&phy_size, 1);
+
+	asc_dvc->cfg->mcode_date =
+	    AscReadLramWord(iop_base, (ushort)ASCV_MC_DATE_W);
+	asc_dvc->cfg->mcode_version =
+	    AscReadLramWord(iop_base, (ushort)ASCV_MC_VER_W);
+
+	AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
+	if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
+		asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
+		return (warn_code);
+	}
+	if (AscStartChip(iop_base) != 1) {
+		asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
+		return (warn_code);
+	}
 
-    return (warn_code);
+	return (warn_code);
 }
 
-STATIC int __init
-AscTestExternalLram(
-                       ASC_DVC_VAR *asc_dvc)
+static int __init AscTestExternalLram(ASC_DVC_VAR *asc_dvc)
 {
-    PortAddr            iop_base;
-    ushort              q_addr;
-    ushort              saved_word;
-    int                 sta;
-
-    iop_base = asc_dvc->iop_base;
-    sta = 0;
-    q_addr = ASC_QNO_TO_QADDR(241);
-    saved_word = AscReadLramWord(iop_base, q_addr);
-    AscSetChipLramAddr(iop_base, q_addr);
-    AscSetChipLramData(iop_base, 0x55AA);
-    DvcSleepMilliSecond(10);
-    AscSetChipLramAddr(iop_base, q_addr);
-    if (AscGetChipLramData(iop_base) == 0x55AA) {
-        sta = 1;
-        AscWriteLramWord(iop_base, q_addr, saved_word);
-    }
-    return (sta);
+	PortAddr iop_base;
+	ushort q_addr;
+	ushort saved_word;
+	int sta;
+
+	iop_base = asc_dvc->iop_base;
+	sta = 0;
+	q_addr = ASC_QNO_TO_QADDR(241);
+	saved_word = AscReadLramWord(iop_base, q_addr);
+	AscSetChipLramAddr(iop_base, q_addr);
+	AscSetChipLramData(iop_base, 0x55AA);
+	DvcSleepMilliSecond(10);
+	AscSetChipLramAddr(iop_base, q_addr);
+	if (AscGetChipLramData(iop_base) == 0x55AA) {
+		sta = 1;
+		AscWriteLramWord(iop_base, q_addr, saved_word);
+	}
+	return (sta);
 }
 
-STATIC int __init
-AscWriteEEPCmdReg(
-                     PortAddr iop_base,
-                     uchar cmd_reg
-)
+static int __init AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)
 {
-    uchar               read_back;
-    int                 retry;
-
-    retry = 0;
-    while (TRUE) {
-        AscSetChipEEPCmd(iop_base, cmd_reg);
-        DvcSleepMilliSecond(1);
-        read_back = AscGetChipEEPCmd(iop_base);
-        if (read_back == cmd_reg) {
-            return (1);
-        }
-        if (retry++ > ASC_EEP_MAX_RETRY) {
-            return (0);
-        }
-    }
+	uchar read_back;
+	int retry;
+
+	retry = 0;
+	while (TRUE) {
+		AscSetChipEEPCmd(iop_base, cmd_reg);
+		DvcSleepMilliSecond(1);
+		read_back = AscGetChipEEPCmd(iop_base);
+		if (read_back == cmd_reg) {
+			return (1);
+		}
+		if (retry++ > ASC_EEP_MAX_RETRY) {
+			return (0);
+		}
+	}
 }
 
-STATIC int __init
-AscWriteEEPDataReg(
-                      PortAddr iop_base,
-                      ushort data_reg
-)
+static int __init AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)
 {
-    ushort              read_back;
-    int                 retry;
-
-    retry = 0;
-    while (TRUE) {
-        AscSetChipEEPData(iop_base, data_reg);
-        DvcSleepMilliSecond(1);
-        read_back = AscGetChipEEPData(iop_base);
-        if (read_back == data_reg) {
-            return (1);
-        }
-        if (retry++ > ASC_EEP_MAX_RETRY) {
-            return (0);
-        }
-    }
+	ushort read_back;
+	int retry;
+
+	retry = 0;
+	while (TRUE) {
+		AscSetChipEEPData(iop_base, data_reg);
+		DvcSleepMilliSecond(1);
+		read_back = AscGetChipEEPData(iop_base);
+		if (read_back == data_reg) {
+			return (1);
+		}
+		if (retry++ > ASC_EEP_MAX_RETRY) {
+			return (0);
+		}
+	}
 }
 
-STATIC void __init
-AscWaitEEPRead(void)
+static void __init AscWaitEEPRead(void)
 {
-    DvcSleepMilliSecond(1);
-    return;
+	DvcSleepMilliSecond(1);
+	return;
 }
 
-STATIC void __init
-AscWaitEEPWrite(void)
+static void __init AscWaitEEPWrite(void)
 {
-    DvcSleepMilliSecond(20);
-    return;
+	DvcSleepMilliSecond(20);
+	return;
 }
 
-STATIC ushort __init
-AscReadEEPWord(
-                  PortAddr iop_base,
-                  uchar addr)
+static ushort __init AscReadEEPWord(PortAddr iop_base, uchar addr)
 {
-    ushort              read_wval;
-    uchar               cmd_reg;
-
-    AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
-    AscWaitEEPRead();
-    cmd_reg = addr | ASC_EEP_CMD_READ;
-    AscWriteEEPCmdReg(iop_base, cmd_reg);
-    AscWaitEEPRead();
-    read_wval = AscGetChipEEPData(iop_base);
-    AscWaitEEPRead();
-    return (read_wval);
+	ushort read_wval;
+	uchar cmd_reg;
+
+	AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
+	AscWaitEEPRead();
+	cmd_reg = addr | ASC_EEP_CMD_READ;
+	AscWriteEEPCmdReg(iop_base, cmd_reg);
+	AscWaitEEPRead();
+	read_wval = AscGetChipEEPData(iop_base);
+	AscWaitEEPRead();
+	return (read_wval);
 }
 
-STATIC ushort __init
-AscWriteEEPWord(
-                   PortAddr iop_base,
-                   uchar addr,
-                   ushort word_val)
+static ushort __init
+AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)
 {
-    ushort              read_wval;
-
-    read_wval = AscReadEEPWord(iop_base, addr);
-    if (read_wval != word_val) {
-        AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);
-        AscWaitEEPRead();
-        AscWriteEEPDataReg(iop_base, word_val);
-        AscWaitEEPRead();
-        AscWriteEEPCmdReg(iop_base,
-                          (uchar) ((uchar) ASC_EEP_CMD_WRITE | addr));
-        AscWaitEEPWrite();
-        AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
-        AscWaitEEPRead();
-        return (AscReadEEPWord(iop_base, addr));
-    }
-    return (read_wval);
+	ushort read_wval;
+
+	read_wval = AscReadEEPWord(iop_base, addr);
+	if (read_wval != word_val) {
+		AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);
+		AscWaitEEPRead();
+		AscWriteEEPDataReg(iop_base, word_val);
+		AscWaitEEPRead();
+		AscWriteEEPCmdReg(iop_base,
+				  (uchar)((uchar)ASC_EEP_CMD_WRITE | addr));
+		AscWaitEEPWrite();
+		AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
+		AscWaitEEPRead();
+		return (AscReadEEPWord(iop_base, addr));
+	}
+	return (read_wval);
 }
 
-STATIC ushort __init
-AscGetEEPConfig(
-                   PortAddr iop_base,
-                   ASCEEP_CONFIG * cfg_buf, ushort bus_type)
+static ushort __init
+AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 {
-    ushort              wval;
-    ushort              sum;
-    ushort              *wbuf;
-    int                 cfg_beg;
-    int                 cfg_end;
-    int                 uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
-    int                 s_addr;
-
-    wbuf = (ushort *) cfg_buf;
-    sum = 0;
-    /* Read two config words; Byte-swapping done by AscReadEEPWord(). */
-    for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
-        *wbuf = AscReadEEPWord(iop_base, (uchar) s_addr);
-        sum += *wbuf;
-    }
-    if (bus_type & ASC_IS_VL) {
-        cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
-        cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
-    } else {
-        cfg_beg = ASC_EEP_DVC_CFG_BEG;
-        cfg_end = ASC_EEP_MAX_DVC_ADDR;
-    }
-    for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
-        wval = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
-        if (s_addr <= uchar_end_in_config) {
-            /*
-             * Swap all char fields - must unswap bytes already swapped
-             * by AscReadEEPWord().
-             */
-            *wbuf = le16_to_cpu(wval);
-        } else {
-            /* Don't swap word field at the end - cntl field. */
-            *wbuf = wval;
-        }
-        sum += wval; /* Checksum treats all EEPROM data as words. */
-    }
-    /*
-     * Read the checksum word which will be compared against 'sum'
-     * by the caller. Word field already swapped.
-     */
-    *wbuf = AscReadEEPWord(iop_base, (uchar) s_addr);
-    return (sum);
+	ushort wval;
+	ushort sum;
+	ushort *wbuf;
+	int cfg_beg;
+	int cfg_end;
+	int uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
+	int s_addr;
+
+	wbuf = (ushort *)cfg_buf;
+	sum = 0;
+	/* Read two config words; Byte-swapping done by AscReadEEPWord(). */
+	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+		*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);
+		sum += *wbuf;
+	}
+	if (bus_type & ASC_IS_VL) {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+	} else {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR;
+	}
+	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+		wval = AscReadEEPWord(iop_base, (uchar)s_addr);
+		if (s_addr <= uchar_end_in_config) {
+			/*
+			 * Swap all char fields - must unswap bytes already swapped
+			 * by AscReadEEPWord().
+			 */
+			*wbuf = le16_to_cpu(wval);
+		} else {
+			/* Don't swap word field at the end - cntl field. */
+			*wbuf = wval;
+		}
+		sum += wval;	/* Checksum treats all EEPROM data as words. */
+	}
+	/*
+	 * Read the checksum word which will be compared against 'sum'
+	 * by the caller. Word field already swapped.
+	 */
+	*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);
+	return (sum);
 }
 
-STATIC int __init
-AscSetEEPConfigOnce(
-                       PortAddr iop_base,
-                       ASCEEP_CONFIG * cfg_buf, ushort bus_type)
+static int __init
+AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 {
-    int                 n_error;
-    ushort              *wbuf;
-    ushort              word;
-    ushort              sum;
-    int                 s_addr;
-    int                 cfg_beg;
-    int                 cfg_end;
-    int                 uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
-
-
-    wbuf = (ushort *) cfg_buf;
-    n_error = 0;
-    sum = 0;
-    /* Write two config words; AscWriteEEPWord() will swap bytes. */
-    for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
-        sum += *wbuf;
-        if (*wbuf != AscWriteEEPWord(iop_base, (uchar) s_addr, *wbuf)) {
-            n_error++;
-        }
-    }
-    if (bus_type & ASC_IS_VL) {
-        cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
-        cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
-    } else {
-        cfg_beg = ASC_EEP_DVC_CFG_BEG;
-        cfg_end = ASC_EEP_MAX_DVC_ADDR;
-    }
-    for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
-        if (s_addr <= uchar_end_in_config) {
-            /*
-             * This is a char field. Swap char fields before they are
-             * swapped again by AscWriteEEPWord().
-             */
-            word = cpu_to_le16(*wbuf);
-            if (word != AscWriteEEPWord( iop_base, (uchar) s_addr, word)) {
-                n_error++;
-            }
-        } else {
-            /* Don't swap word field at the end - cntl field. */
-            if (*wbuf != AscWriteEEPWord(iop_base, (uchar) s_addr, *wbuf)) {
-                n_error++;
-            }
-        }
-        sum += *wbuf; /* Checksum calculated from word values. */
-    }
-    /* Write checksum word. It will be swapped by AscWriteEEPWord(). */
-    *wbuf = sum;
-    if (sum != AscWriteEEPWord(iop_base, (uchar) s_addr, sum)) {
-        n_error++;
-    }
+	int n_error;
+	ushort *wbuf;
+	ushort word;
+	ushort sum;
+	int s_addr;
+	int cfg_beg;
+	int cfg_end;
+	int uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
+
+	wbuf = (ushort *)cfg_buf;
+	n_error = 0;
+	sum = 0;
+	/* Write two config words; AscWriteEEPWord() will swap bytes. */
+	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+		sum += *wbuf;
+		if (*wbuf != AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {
+			n_error++;
+		}
+	}
+	if (bus_type & ASC_IS_VL) {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+	} else {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR;
+	}
+	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+		if (s_addr <= uchar_end_in_config) {
+			/*
+			 * This is a char field. Swap char fields before they are
+			 * swapped again by AscWriteEEPWord().
+			 */
+			word = cpu_to_le16(*wbuf);
+			if (word !=
+			    AscWriteEEPWord(iop_base, (uchar)s_addr, word)) {
+				n_error++;
+			}
+		} else {
+			/* Don't swap word field at the end - cntl field. */
+			if (*wbuf !=
+			    AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {
+				n_error++;
+			}
+		}
+		sum += *wbuf;	/* Checksum calculated from word values. */
+	}
+	/* Write checksum word. It will be swapped by AscWriteEEPWord(). */
+	*wbuf = sum;
+	if (sum != AscWriteEEPWord(iop_base, (uchar)s_addr, sum)) {
+		n_error++;
+	}
 
-    /* Read EEPROM back again. */
-    wbuf = (ushort *) cfg_buf;
-    /*
-     * Read two config words; Byte-swapping done by AscReadEEPWord().
-     */
-    for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
-        if (*wbuf != AscReadEEPWord(iop_base, (uchar) s_addr)) {
-            n_error++;
-        }
-    }
-    if (bus_type & ASC_IS_VL) {
-        cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
-        cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
-    } else {
-        cfg_beg = ASC_EEP_DVC_CFG_BEG;
-        cfg_end = ASC_EEP_MAX_DVC_ADDR;
-    }
-    for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
-        if (s_addr <= uchar_end_in_config) {
-            /*
-             * Swap all char fields. Must unswap bytes already swapped
-             * by AscReadEEPWord().
-             */
-            word = le16_to_cpu(AscReadEEPWord(iop_base, (uchar) s_addr));
-        } else {
-            /* Don't swap word field at the end - cntl field. */
-            word = AscReadEEPWord(iop_base, (uchar) s_addr);
-        }
-        if (*wbuf != word) {
-            n_error++;
-        }
-    }
-    /* Read checksum; Byte swapping not needed. */
-    if (AscReadEEPWord(iop_base, (uchar) s_addr) != sum) {
-        n_error++;
-    }
-    return (n_error);
+	/* Read EEPROM back again. */
+	wbuf = (ushort *)cfg_buf;
+	/*
+	 * Read two config words; Byte-swapping done by AscReadEEPWord().
+	 */
+	for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+		if (*wbuf != AscReadEEPWord(iop_base, (uchar)s_addr)) {
+			n_error++;
+		}
+	}
+	if (bus_type & ASC_IS_VL) {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+	} else {
+		cfg_beg = ASC_EEP_DVC_CFG_BEG;
+		cfg_end = ASC_EEP_MAX_DVC_ADDR;
+	}
+	for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+		if (s_addr <= uchar_end_in_config) {
+			/*
+			 * Swap all char fields. Must unswap bytes already swapped
+			 * by AscReadEEPWord().
+			 */
+			word =
+			    le16_to_cpu(AscReadEEPWord
+					(iop_base, (uchar)s_addr));
+		} else {
+			/* Don't swap word field at the end - cntl field. */
+			word = AscReadEEPWord(iop_base, (uchar)s_addr);
+		}
+		if (*wbuf != word) {
+			n_error++;
+		}
+	}
+	/* Read checksum; Byte swapping not needed. */
+	if (AscReadEEPWord(iop_base, (uchar)s_addr) != sum) {
+		n_error++;
+	}
+	return (n_error);
 }
 
-STATIC int __init
-AscSetEEPConfig(
-                   PortAddr iop_base,
-                   ASCEEP_CONFIG * cfg_buf, ushort bus_type
-)
+static int __init
+AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf, ushort bus_type)
 {
-    int            retry;
-    int            n_error;
-
-    retry = 0;
-    while (TRUE) {
-        if ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,
-                                           bus_type)) == 0) {
-            break;
-        }
-        if (++retry > ASC_EEP_MAX_RETRY) {
-            break;
-        }
-    }
-    return (n_error);
+	int retry;
+	int n_error;
+
+	retry = 0;
+	while (TRUE) {
+		if ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,
+						   bus_type)) == 0) {
+			break;
+		}
+		if (++retry > ASC_EEP_MAX_RETRY) {
+			break;
+		}
+	}
+	return (n_error);
 }
 
-STATIC void
-AscAsyncFix(
-               ASC_DVC_VAR *asc_dvc,
-               uchar tid_no,
-               ASC_SCSI_INQUIRY *inq)
+static void
+AscAsyncFix(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
 {
-    uchar                       dvc_type;
-    ASC_SCSI_BIT_ID_TYPE        tid_bits;
-
-    dvc_type = ASC_INQ_DVC_TYPE(inq);
-    tid_bits = ASC_TIX_TO_TARGET_ID(tid_no);
-
-    if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN)
-    {
-        if (!(asc_dvc->init_sdtr & tid_bits))
-        {
-            if ((dvc_type == TYPE_ROM) &&
-                (AscCompareString((uchar *) inq->vendor_id,
-                    (uchar *) "HP ", 3) == 0))
-            {
-                asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
-            }
-            asc_dvc->pci_fix_asyn_xfer |= tid_bits;
-            if ((dvc_type == TYPE_PROCESSOR) ||
-                (dvc_type == TYPE_SCANNER) ||
-                (dvc_type == TYPE_ROM) ||
-                (dvc_type == TYPE_TAPE))
-            {
-                asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
-            }
-
-            if (asc_dvc->pci_fix_asyn_xfer & tid_bits)
-            {
-                AscSetRunChipSynRegAtID(asc_dvc->iop_base, tid_no,
-                    ASYN_SDTR_DATA_FIX_PCI_REV_AB);
-            }
-        }
-    }
-    return;
+	uchar dvc_type;
+	ASC_SCSI_BIT_ID_TYPE tid_bits;
+
+	dvc_type = ASC_INQ_DVC_TYPE(inq);
+	tid_bits = ASC_TIX_TO_TARGET_ID(tid_no);
+
+	if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN) {
+		if (!(asc_dvc->init_sdtr & tid_bits)) {
+			if ((dvc_type == TYPE_ROM) &&
+			    (AscCompareString((uchar *)inq->vendor_id,
+					      (uchar *)"HP ", 3) == 0)) {
+				asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
+			}
+			asc_dvc->pci_fix_asyn_xfer |= tid_bits;
+			if ((dvc_type == TYPE_PROCESSOR) ||
+			    (dvc_type == TYPE_SCANNER) ||
+			    (dvc_type == TYPE_ROM) || (dvc_type == TYPE_TAPE)) {
+				asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
+			}
+
+			if (asc_dvc->pci_fix_asyn_xfer & tid_bits) {
+				AscSetRunChipSynRegAtID(asc_dvc->iop_base,
+							tid_no,
+							ASYN_SDTR_DATA_FIX_PCI_REV_AB);
+			}
+		}
+	}
+	return;
 }
 
-STATIC int
-AscTagQueuingSafe(ASC_SCSI_INQUIRY *inq)
+static int AscTagQueuingSafe(ASC_SCSI_INQUIRY *inq)
 {
-    if ((inq->add_len >= 32) &&
-        (AscCompareString((uchar *) inq->vendor_id,
-            (uchar *) "QUANTUM XP34301", 15) == 0) &&
-        (AscCompareString((uchar *) inq->product_rev_level,
-            (uchar *) "1071", 4) == 0))
-    {
-        return 0;
-    }
-    return 1;
+	if ((inq->add_len >= 32) &&
+	    (AscCompareString((uchar *)inq->vendor_id,
+			      (uchar *)"QUANTUM XP34301", 15) == 0) &&
+	    (AscCompareString((uchar *)inq->product_rev_level,
+			      (uchar *)"1071", 4) == 0)) {
+		return 0;
+	}
+	return 1;
 }
 
-STATIC void
-AscInquiryHandling(ASC_DVC_VAR *asc_dvc,
-                   uchar tid_no, ASC_SCSI_INQUIRY *inq)
+static void
+AscInquiryHandling(ASC_DVC_VAR *asc_dvc, uchar tid_no, ASC_SCSI_INQUIRY *inq)
 {
-    ASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);
-    ASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;
-
-    orig_init_sdtr = asc_dvc->init_sdtr;
-    orig_use_tagged_qng = asc_dvc->use_tagged_qng;
-
-    asc_dvc->init_sdtr &= ~tid_bit;
-    asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
-    asc_dvc->use_tagged_qng &= ~tid_bit;
-
-    if (ASC_INQ_RESPONSE_FMT(inq) >= 2 || ASC_INQ_ANSI_VER(inq) >= 2) {
-        if ((asc_dvc->cfg->sdtr_enable & tid_bit) && ASC_INQ_SYNC(inq)) {
-            asc_dvc->init_sdtr |= tid_bit;
-        }
-        if ((asc_dvc->cfg->cmd_qng_enabled & tid_bit) &&
-             ASC_INQ_CMD_QUEUE(inq)) {
-            if (AscTagQueuingSafe(inq)) {
-                asc_dvc->use_tagged_qng |= tid_bit;
-                asc_dvc->cfg->can_tagged_qng |= tid_bit;
-            }
-        }
-    }
-    if (orig_use_tagged_qng != asc_dvc->use_tagged_qng) {
-        AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
-                         asc_dvc->cfg->disc_enable);
-        AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
-                         asc_dvc->use_tagged_qng);
-        AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
-                         asc_dvc->cfg->can_tagged_qng);
-
-        asc_dvc->max_dvc_qng[tid_no] =
-          asc_dvc->cfg->max_tag_qng[tid_no];
-        AscWriteLramByte(asc_dvc->iop_base,
-                         (ushort) (ASCV_MAX_DVC_QNG_BEG + tid_no),
-                         asc_dvc->max_dvc_qng[tid_no]);
-    }
-    if (orig_init_sdtr != asc_dvc->init_sdtr) {
-        AscAsyncFix(asc_dvc, tid_no, inq);
-    }
-    return;
+	ASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);
+	ASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;
+
+	orig_init_sdtr = asc_dvc->init_sdtr;
+	orig_use_tagged_qng = asc_dvc->use_tagged_qng;
+
+	asc_dvc->init_sdtr &= ~tid_bit;
+	asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
+	asc_dvc->use_tagged_qng &= ~tid_bit;
+
+	if (ASC_INQ_RESPONSE_FMT(inq) >= 2 || ASC_INQ_ANSI_VER(inq) >= 2) {
+		if ((asc_dvc->cfg->sdtr_enable & tid_bit) && ASC_INQ_SYNC(inq)) {
+			asc_dvc->init_sdtr |= tid_bit;
+		}
+		if ((asc_dvc->cfg->cmd_qng_enabled & tid_bit) &&
+		    ASC_INQ_CMD_QUEUE(inq)) {
+			if (AscTagQueuingSafe(inq)) {
+				asc_dvc->use_tagged_qng |= tid_bit;
+				asc_dvc->cfg->can_tagged_qng |= tid_bit;
+			}
+		}
+	}
+	if (orig_use_tagged_qng != asc_dvc->use_tagged_qng) {
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
+				 asc_dvc->cfg->disc_enable);
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
+				 asc_dvc->use_tagged_qng);
+		AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
+				 asc_dvc->cfg->can_tagged_qng);
+
+		asc_dvc->max_dvc_qng[tid_no] =
+		    asc_dvc->cfg->max_tag_qng[tid_no];
+		AscWriteLramByte(asc_dvc->iop_base,
+				 (ushort)(ASCV_MAX_DVC_QNG_BEG + tid_no),
+				 asc_dvc->max_dvc_qng[tid_no]);
+	}
+	if (orig_init_sdtr != asc_dvc->init_sdtr) {
+		AscAsyncFix(asc_dvc, tid_no, inq);
+	}
+	return;
 }
 
-STATIC int
-AscCompareString(
-                    uchar *str1,
-                    uchar *str2,
-                    int len
-)
+static int AscCompareString(uchar *str1, uchar *str2, int len)
 {
-    int                 i;
-    int                 diff;
+	int i;
+	int diff;
 
-    for (i = 0; i < len; i++) {
-        diff = (int) (str1[i] - str2[i]);
-        if (diff != 0)
-            return (diff);
-    }
-    return (0);
+	for (i = 0; i < len; i++) {
+		diff = (int)(str1[i] - str2[i]);
+		if (diff != 0)
+			return (diff);
+	}
+	return (0);
 }
 
-STATIC uchar
-AscReadLramByte(
-                   PortAddr iop_base,
-                   ushort addr
-)
+static uchar AscReadLramByte(PortAddr iop_base, ushort addr)
 {
-    uchar               byte_data;
-    ushort              word_data;
-
-    if (isodd_word(addr)) {
-        AscSetChipLramAddr(iop_base, addr - 1);
-        word_data = AscGetChipLramData(iop_base);
-        byte_data = (uchar) ((word_data >> 8) & 0xFF);
-    } else {
-        AscSetChipLramAddr(iop_base, addr);
-        word_data = AscGetChipLramData(iop_base);
-        byte_data = (uchar) (word_data & 0xFF);
-    }
-    return (byte_data);
+	uchar byte_data;
+	ushort word_data;
+
+	if (isodd_word(addr)) {
+		AscSetChipLramAddr(iop_base, addr - 1);
+		word_data = AscGetChipLramData(iop_base);
+		byte_data = (uchar)((word_data >> 8) & 0xFF);
+	} else {
+		AscSetChipLramAddr(iop_base, addr);
+		word_data = AscGetChipLramData(iop_base);
+		byte_data = (uchar)(word_data & 0xFF);
+	}
+	return (byte_data);
 }
-STATIC ushort
-AscReadLramWord(
-                   PortAddr iop_base,
-                   ushort addr
-)
+
+static ushort AscReadLramWord(PortAddr iop_base, ushort addr)
 {
-    ushort              word_data;
+	ushort word_data;
 
-    AscSetChipLramAddr(iop_base, addr);
-    word_data = AscGetChipLramData(iop_base);
-    return (word_data);
+	AscSetChipLramAddr(iop_base, addr);
+	word_data = AscGetChipLramData(iop_base);
+	return (word_data);
 }
 
 #if CC_VERY_LONG_SG_LIST
-STATIC ASC_DCNT
-AscReadLramDWord(
-                    PortAddr iop_base,
-                    ushort addr
-)
+static ASC_DCNT AscReadLramDWord(PortAddr iop_base, ushort addr)
 {
-    ushort              val_low, val_high;
-    ASC_DCNT            dword_data;
-
-    AscSetChipLramAddr(iop_base, addr);
-    val_low = AscGetChipLramData(iop_base);
-    val_high = AscGetChipLramData(iop_base);
-    dword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;
-    return (dword_data);
+	ushort val_low, val_high;
+	ASC_DCNT dword_data;
+
+	AscSetChipLramAddr(iop_base, addr);
+	val_low = AscGetChipLramData(iop_base);
+	val_high = AscGetChipLramData(iop_base);
+	dword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;
+	return (dword_data);
 }
 #endif /* CC_VERY_LONG_SG_LIST */
 
-STATIC void
-AscWriteLramWord(
-                    PortAddr iop_base,
-                    ushort addr,
-                    ushort word_val
-)
+static void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)
 {
-    AscSetChipLramAddr(iop_base, addr);
-    AscSetChipLramData(iop_base, word_val);
-    return;
+	AscSetChipLramAddr(iop_base, addr);
+	AscSetChipLramData(iop_base, word_val);
+	return;
 }
 
-STATIC void
-AscWriteLramByte(
-                    PortAddr iop_base,
-                    ushort addr,
-                    uchar byte_val
-)
+static void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)
 {
-    ushort              word_data;
-
-    if (isodd_word(addr)) {
-        addr--;
-        word_data = AscReadLramWord(iop_base, addr);
-        word_data &= 0x00FF;
-        word_data |= (((ushort) byte_val << 8) & 0xFF00);
-    } else {
-        word_data = AscReadLramWord(iop_base, addr);
-        word_data &= 0xFF00;
-        word_data |= ((ushort) byte_val & 0x00FF);
-    }
-    AscWriteLramWord(iop_base, addr, word_data);
-    return;
+	ushort word_data;
+
+	if (isodd_word(addr)) {
+		addr--;
+		word_data = AscReadLramWord(iop_base, addr);
+		word_data &= 0x00FF;
+		word_data |= (((ushort)byte_val << 8) & 0xFF00);
+	} else {
+		word_data = AscReadLramWord(iop_base, addr);
+		word_data &= 0xFF00;
+		word_data |= ((ushort)byte_val & 0x00FF);
+	}
+	AscWriteLramWord(iop_base, addr, word_data);
+	return;
 }
 
 /*
@@ -12841,30 +11628,26 @@ AscWriteLramByte(
  * The source data is assumed to be in little-endian order in memory
  * and is maintained in little-endian order when written to LRAM.
  */
-STATIC void
-AscMemWordCopyPtrToLram(
-                        PortAddr iop_base,
-                        ushort s_addr,
-                        uchar *s_buffer,
-                        int words
-)
+static void
+AscMemWordCopyPtrToLram(PortAddr iop_base,
+			ushort s_addr, uchar *s_buffer, int words)
 {
-    int    i;
-
-    AscSetChipLramAddr(iop_base, s_addr);
-    for (i = 0; i < 2 * words; i += 2) {
-        /*
-         * On a little-endian system the second argument below
-         * produces a little-endian ushort which is written to
-         * LRAM in little-endian order. On a big-endian system
-         * the second argument produces a big-endian ushort which
-         * is "transparently" byte-swapped by outpw() and written
-         * in little-endian order to LRAM.
-         */
-        outpw(iop_base + IOP_RAM_DATA,
-            ((ushort) s_buffer[i + 1] << 8) | s_buffer[i]);
-    }
-    return;
+	int i;
+
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		/*
+		 * On a little-endian system the second argument below
+		 * produces a little-endian ushort which is written to
+		 * LRAM in little-endian order. On a big-endian system
+		 * the second argument produces a big-endian ushort which
+		 * is "transparently" byte-swapped by outpw() and written
+		 * in little-endian order to LRAM.
+		 */
+		outpw(iop_base + IOP_RAM_DATA,
+		      ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);
+	}
+	return;
 }
 
 /*
@@ -12873,24 +11656,18 @@ AscMemWordCopyPtrToLram(
  * The source data is assumed to be in little-endian order in memory
  * and is maintained in little-endian order when writen to LRAM.
  */
-STATIC void
-AscMemDWordCopyPtrToLram(
-                         PortAddr iop_base,
-                         ushort s_addr,
-                         uchar *s_buffer,
-                         int dwords
-)
+static void
+AscMemDWordCopyPtrToLram(PortAddr iop_base,
+			 ushort s_addr, uchar *s_buffer, int dwords)
 {
-    int       i;
-
-    AscSetChipLramAddr(iop_base, s_addr);
-    for (i = 0; i < 4 * dwords; i += 4) {
-        outpw(iop_base + IOP_RAM_DATA,
-            ((ushort) s_buffer[i + 1] << 8) | s_buffer[i]); /* LSW */
-        outpw(iop_base + IOP_RAM_DATA,
-            ((ushort) s_buffer[i + 3] << 8) | s_buffer[i + 2]); /* MSW */
-    }
-    return;
+	int i;
+
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 4 * dwords; i += 4) {
+		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);	/* LSW */
+		outpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);	/* MSW */
+	}
+	return;
 }
 
 /*
@@ -12899,61 +11676,46 @@ AscMemDWordCopyPtrToLram(
  * The source data is assumed to be in little-endian order in LRAM
  * and is maintained in little-endian order when written to memory.
  */
-STATIC void
-AscMemWordCopyPtrFromLram(
-                          PortAddr iop_base,
-                          ushort s_addr,
-                          uchar *d_buffer,
-                          int words
-)
+static void
+AscMemWordCopyPtrFromLram(PortAddr iop_base,
+			  ushort s_addr, uchar *d_buffer, int words)
 {
-    int i;
-    ushort word;
-
-    AscSetChipLramAddr(iop_base, s_addr);
-    for (i = 0; i < 2 * words; i += 2) {
-        word = inpw(iop_base + IOP_RAM_DATA);
-        d_buffer[i] = word & 0xff;
-        d_buffer[i + 1] = (word >> 8) & 0xff;
-    }
-    return;
+	int i;
+	ushort word;
+
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < 2 * words; i += 2) {
+		word = inpw(iop_base + IOP_RAM_DATA);
+		d_buffer[i] = word & 0xff;
+		d_buffer[i + 1] = (word >> 8) & 0xff;
+	}
+	return;
 }
 
-STATIC ASC_DCNT
-AscMemSumLramWord(
-                     PortAddr iop_base,
-                     ushort s_addr,
-                     int words
-)
+static ASC_DCNT AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)
 {
-    ASC_DCNT         sum;
-    int              i;
+	ASC_DCNT sum;
+	int i;
 
-    sum = 0L;
-    for (i = 0; i < words; i++, s_addr += 2) {
-        sum += AscReadLramWord(iop_base, s_addr);
-    }
-    return (sum);
+	sum = 0L;
+	for (i = 0; i < words; i++, s_addr += 2) {
+		sum += AscReadLramWord(iop_base, s_addr);
+	}
+	return (sum);
 }
 
-STATIC void
-AscMemWordSetLram(
-                     PortAddr iop_base,
-                     ushort s_addr,
-                     ushort set_wval,
-                     int words
-)
+static void
+AscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)
 {
-    int             i;
+	int i;
 
-    AscSetChipLramAddr(iop_base, s_addr);
-    for (i = 0; i < words; i++) {
-        AscSetChipLramData(iop_base, set_wval);
-    }
-    return;
+	AscSetChipLramAddr(iop_base, s_addr);
+	for (i = 0; i < words; i++) {
+		AscSetChipLramData(iop_base, set_wval);
+	}
+	return;
 }
 
-
 /*
  * --- Adv Library Functions
  */
@@ -12961,1076 +11723,2112 @@ AscMemWordSetLram(
 /* a_mcode.h */
 
 /* Microcode buffer is kept after initialization for error recovery. */
-STATIC unsigned char _adv_asc3550_buf[] = {
-  0x00,  0x00,  0x00,  0xf2,  0x00,  0xf0,  0x00,  0x16,  0x18,  0xe4,  0x00,  0xfc,  0x01,  0x00,  0x48,  0xe4,
-  0xbe,  0x18,  0x18,  0x80,  0x03,  0xf6,  0x02,  0x00,  0x00,  0xfa,  0xff,  0xff,  0x28,  0x0e,  0x9e,  0xe7,
-  0xff,  0x00,  0x82,  0xe7,  0x00,  0xea,  0x00,  0xf6,  0x01,  0xe6,  0x09,  0xe7,  0x55,  0xf0,  0x01,  0xf6,
-  0x01,  0xfa,  0x08,  0x00,  0x03,  0x00,  0x04,  0x00,  0x18,  0xf4,  0x10,  0x00,  0x00,  0xec,  0x85,  0xf0,
-  0xbc,  0x00,  0xd5,  0xf0,  0x8e,  0x0c,  0x38,  0x54,  0x00,  0xe6,  0x1e,  0xf0,  0x86,  0xf0,  0xb4,  0x00,
-  0x98,  0x57,  0xd0,  0x01,  0x0c,  0x1c,  0x3e,  0x1c,  0x0c,  0x00,  0xbb,  0x00,  0xaa,  0x18,  0x02,  0x80,
-  0x32,  0xf0,  0x01,  0xfc,  0x88,  0x0c,  0xc6,  0x12,  0x02,  0x13,  0x18,  0x40,  0x00,  0x57,  0x01,  0xea,
-  0x3c,  0x00,  0x6c,  0x01,  0x6e,  0x01,  0x04,  0x12,  0x3e,  0x57,  0x00,  0x80,  0x03,  0xe6,  0xb6,  0x00,
-  0xc0,  0x00,  0x01,  0x01,  0x3e,  0x01,  0xda,  0x0f,  0x22,  0x10,  0x08,  0x12,  0x02,  0x4a,  0xb9,  0x54,
-  0x03,  0x58,  0x1b,  0x80,  0x30,  0xe4,  0x4b,  0xe4,  0x20,  0x00,  0x32,  0x00,  0x3e,  0x00,  0x80,  0x00,
-  0x24,  0x01,  0x3c,  0x01,  0x68,  0x01,  0x6a,  0x01,  0x70,  0x01,  0x72,  0x01,  0x74,  0x01,  0x76,  0x01,
-  0x78,  0x01,  0x62,  0x0a,  0x92,  0x0c,  0x2c,  0x10,  0x2e,  0x10,  0x06,  0x13,  0x4c,  0x1c,  0xbb,  0x55,
-  0x3c,  0x56,  0x04,  0x80,  0x4a,  0xe4,  0x02,  0xee,  0x5b,  0xf0,  0xb1,  0xf0,  0x03,  0xf7,  0x06,  0xf7,
-  0x03,  0xfc,  0x0f,  0x00,  0x40,  0x00,  0xbe,  0x00,  0x00,  0x01,  0xb0,  0x08,  0x30,  0x13,  0x64,  0x15,
-  0x32,  0x1c,  0x38,  0x1c,  0x4e,  0x1c,  0x10,  0x44,  0x02,  0x48,  0x00,  0x4c,  0x04,  0xea,  0x5d,  0xf0,
-  0x04,  0xf6,  0x02,  0xfc,  0x05,  0x00,  0x34,  0x00,  0x36,  0x00,  0x98,  0x00,  0xcc,  0x00,  0x20,  0x01,
-  0x4e,  0x01,  0x4e,  0x0b,  0x1e,  0x0e,  0x0c,  0x10,  0x0a,  0x12,  0x04,  0x13,  0x40,  0x13,  0x30,  0x1c,
-  0x00,  0x4e,  0xbd,  0x56,  0x06,  0x83,  0x00,  0xdc,  0x05,  0xf0,  0x09,  0xf0,  0x59,  0xf0,  0xa7,  0xf0,
-  0xb8,  0xf0,  0x0e,  0xf7,  0x06,  0x00,  0x19,  0x00,  0x33,  0x00,  0x9b,  0x00,  0xa4,  0x00,  0xb5,  0x00,
-  0xba,  0x00,  0xd0,  0x00,  0xe1,  0x00,  0xe7,  0x00,  0xde,  0x03,  0x56,  0x0a,  0x14,  0x0e,  0x02,  0x10,
-  0x04,  0x10,  0x0a,  0x10,  0x36,  0x10,  0x0a,  0x13,  0x12,  0x13,  0x52,  0x13,  0x10,  0x15,  0x14,  0x15,
-  0xac,  0x16,  0x20,  0x1c,  0x34,  0x1c,  0x36,  0x1c,  0x08,  0x44,  0x38,  0x44,  0x91,  0x44,  0x0a,  0x45,
-  0x48,  0x46,  0x01,  0x48,  0x68,  0x54,  0x83,  0x55,  0xb0,  0x57,  0x01,  0x58,  0x83,  0x59,  0x05,  0xe6,
-  0x0b,  0xf0,  0x0c,  0xf0,  0x5c,  0xf0,  0x4b,  0xf4,  0x04,  0xf8,  0x05,  0xf8,  0x02,  0xfa,  0x03,  0xfa,
-  0x04,  0xfc,  0x05,  0xfc,  0x07,  0x00,  0x0a,  0x00,  0x0d,  0x00,  0x1c,  0x00,  0x9e,  0x00,  0xa8,  0x00,
-  0xaa,  0x00,  0xb9,  0x00,  0xe0,  0x00,  0x22,  0x01,  0x26,  0x01,  0x79,  0x01,  0x7a,  0x01,  0xc0,  0x01,
-  0xc2,  0x01,  0x7c,  0x02,  0x5a,  0x03,  0xea,  0x04,  0xe8,  0x07,  0x68,  0x08,  0x69,  0x08,  0xba,  0x08,
-  0xe9,  0x09,  0x06,  0x0b,  0x3a,  0x0e,  0x00,  0x10,  0x1a,  0x10,  0xed,  0x10,  0xf1,  0x10,  0x06,  0x12,
-  0x0c,  0x13,  0x16,  0x13,  0x1e,  0x13,  0x82,  0x13,  0x42,  0x14,  0xd6,  0x14,  0x8a,  0x15,  0xc6,  0x17,
-  0xd2,  0x17,  0x6b,  0x18,  0x12,  0x1c,  0x46,  0x1c,  0x9c,  0x32,  0x00,  0x40,  0x0e,  0x47,  0x48,  0x47,
-  0x41,  0x48,  0x89,  0x48,  0x80,  0x4c,  0x00,  0x54,  0x44,  0x55,  0xe5,  0x55,  0x14,  0x56,  0x77,  0x57,
-  0xbf,  0x57,  0x40,  0x5c,  0x06,  0x80,  0x08,  0x90,  0x03,  0xa1,  0xfe,  0x9c,  0xf0,  0x29,  0x02,  0xfe,
-  0xb8,  0x0c,  0xff,  0x10,  0x00,  0x00,  0xd0,  0xfe,  0xcc,  0x18,  0x00,  0xcf,  0xfe,  0x80,  0x01,  0xff,
-  0x03,  0x00,  0x00,  0xfe,  0x93,  0x15,  0xfe,  0x0f,  0x05,  0xff,  0x38,  0x00,  0x00,  0xfe,  0x57,  0x24,
-  0x00,  0xfe,  0x48,  0x00,  0x4f,  0xff,  0x04,  0x00,  0x00,  0x10,  0xff,  0x09,  0x00,  0x00,  0xff,  0x08,
-  0x01,  0x01,  0xff,  0x08,  0xff,  0xff,  0xff,  0x27,  0x00,  0x00,  0xff,  0x10,  0xff,  0xff,  0xff,  0x0f,
-  0x00,  0x00,  0xfe,  0x78,  0x56,  0xfe,  0x34,  0x12,  0xff,  0x21,  0x00,  0x00,  0xfe,  0x04,  0xf7,  0xcf,
-  0x2a,  0x67,  0x0b,  0x01,  0xfe,  0xce,  0x0e,  0xfe,  0x04,  0xf7,  0xcf,  0x67,  0x0b,  0x3c,  0x2a,  0xfe,
-  0x3d,  0xf0,  0xfe,  0x02,  0x02,  0xfe,  0x20,  0xf0,  0x9c,  0xfe,  0x91,  0xf0,  0xfe,  0xf0,  0x01,  0xfe,
-  0x90,  0xf0,  0xfe,  0xf0,  0x01,  0xfe,  0x8f,  0xf0,  0x9c,  0x05,  0x51,  0x3b,  0x02,  0xfe,  0xd4,  0x0c,
-  0x01,  0xfe,  0x44,  0x0d,  0xfe,  0xdd,  0x12,  0xfe,  0xfc,  0x10,  0xfe,  0x28,  0x1c,  0x05,  0xfe,  0xa6,
-  0x00,  0xfe,  0xd3,  0x12,  0x47,  0x18,  0xfe,  0xa6,  0x00,  0xb5,  0xfe,  0x48,  0xf0,  0xfe,  0x86,  0x02,
-  0xfe,  0x49,  0xf0,  0xfe,  0xa0,  0x02,  0xfe,  0x4a,  0xf0,  0xfe,  0xbe,  0x02,  0xfe,  0x46,  0xf0,  0xfe,
-  0x50,  0x02,  0xfe,  0x47,  0xf0,  0xfe,  0x56,  0x02,  0xfe,  0x43,  0xf0,  0xfe,  0x44,  0x02,  0xfe,  0x44,
-  0xf0,  0xfe,  0x48,  0x02,  0xfe,  0x45,  0xf0,  0xfe,  0x4c,  0x02,  0x17,  0x0b,  0xa0,  0x17,  0x06,  0x18,
-  0x96,  0x02,  0x29,  0xfe,  0x00,  0x1c,  0xde,  0xfe,  0x02,  0x1c,  0xdd,  0xfe,  0x1e,  0x1c,  0xfe,  0xe9,
-  0x10,  0x01,  0xfe,  0x20,  0x17,  0xfe,  0xe7,  0x10,  0xfe,  0x06,  0xfc,  0xc7,  0x0a,  0x6b,  0x01,  0x9e,
-  0x02,  0x29,  0x14,  0x4d,  0x37,  0x97,  0x01,  0xfe,  0x64,  0x0f,  0x0a,  0x6b,  0x01,  0x82,  0xfe,  0xbd,
-  0x10,  0x0a,  0x6b,  0x01,  0x82,  0xfe,  0xad,  0x10,  0xfe,  0x16,  0x1c,  0xfe,  0x58,  0x1c,  0x17,  0x06,
-  0x18,  0x96,  0x2a,  0x25,  0x29,  0xfe,  0x3d,  0xf0,  0xfe,  0x02,  0x02,  0x21,  0xfe,  0x94,  0x02,  0xfe,
-  0x5a,  0x1c,  0xea,  0xfe,  0x14,  0x1c,  0x14,  0xfe,  0x30,  0x00,  0x37,  0x97,  0x01,  0xfe,  0x54,  0x0f,
-  0x17,  0x06,  0x18,  0x96,  0x02,  0xd0,  0x1e,  0x20,  0x07,  0x10,  0x34,  0xfe,  0x69,  0x10,  0x17,  0x06,
-  0x18,  0x96,  0xfe,  0x04,  0xec,  0x20,  0x46,  0x3d,  0x12,  0x20,  0xfe,  0x05,  0xf6,  0xc7,  0x01,  0xfe,
-  0x52,  0x16,  0x09,  0x4a,  0x4c,  0x35,  0x11,  0x2d,  0x3c,  0x8a,  0x01,  0xe6,  0x02,  0x29,  0x0a,  0x40,
-  0x01,  0x0e,  0x07,  0x00,  0x5d,  0x01,  0x6f,  0xfe,  0x18,  0x10,  0xfe,  0x41,  0x58,  0x0a,  0x99,  0x01,
-  0x0e,  0xfe,  0xc8,  0x54,  0x64,  0xfe,  0x0c,  0x03,  0x01,  0xe6,  0x02,  0x29,  0x2a,  0x46,  0xfe,  0x02,
-  0xe8,  0x27,  0xf8,  0xfe,  0x9e,  0x43,  0xf7,  0xfe,  0x27,  0xf0,  0xfe,  0xdc,  0x01,  0xfe,  0x07,  0x4b,
-  0xfe,  0x20,  0xf0,  0x9c,  0xfe,  0x40,  0x1c,  0x25,  0xd2,  0xfe,  0x26,  0xf0,  0xfe,  0x56,  0x03,  0xfe,
-  0xa0,  0xf0,  0xfe,  0x44,  0x03,  0xfe,  0x11,  0xf0,  0x9c,  0xfe,  0xef,  0x10,  0xfe,  0x9f,  0xf0,  0xfe,
-  0x64,  0x03,  0xeb,  0x0f,  0xfe,  0x11,  0x00,  0x02,  0x5a,  0x2a,  0xfe,  0x48,  0x1c,  0xeb,  0x09,  0x04,
-  0x1d,  0xfe,  0x18,  0x13,  0x23,  0x1e,  0x98,  0xac,  0x12,  0x98,  0x0a,  0x40,  0x01,  0x0e,  0xac,  0x75,
-  0x01,  0xfe,  0xbc,  0x15,  0x11,  0xca,  0x25,  0xd2,  0xfe,  0x01,  0xf0,  0xd2,  0xfe,  0x82,  0xf0,  0xfe,
-  0x92,  0x03,  0xec,  0x11,  0xfe,  0xe4,  0x00,  0x65,  0xfe,  0xa4,  0x03,  0x25,  0x32,  0x1f,  0xfe,  0xb4,
-  0x03,  0x01,  0x43,  0xfe,  0x06,  0xf0,  0xfe,  0xc4,  0x03,  0x8d,  0x81,  0xfe,  0x0a,  0xf0,  0xfe,  0x7a,
-  0x06,  0x02,  0x22,  0x05,  0x6b,  0x28,  0x16,  0xfe,  0xf6,  0x04,  0x14,  0x2c,  0x01,  0x33,  0x8f,  0xfe,
-  0x66,  0x02,  0x02,  0xd1,  0xeb,  0x2a,  0x67,  0x1a,  0xfe,  0x67,  0x1b,  0xf8,  0xf7,  0xfe,  0x48,  0x1c,
-  0x70,  0x01,  0x6e,  0x87,  0x0a,  0x40,  0x01,  0x0e,  0x07,  0x00,  0x16,  0xd3,  0x0a,  0xca,  0x01,  0x0e,
-  0x74,  0x60,  0x59,  0x76,  0x27,  0x05,  0x6b,  0x28,  0xfe,  0x10,  0x12,  0x14,  0x2c,  0x01,  0x33,  0x8f,
-  0xfe,  0x66,  0x02,  0x02,  0xd1,  0xbc,  0x7d,  0xbd,  0x7f,  0x25,  0x22,  0x65,  0xfe,  0x3c,  0x04,  0x1f,
-  0xfe,  0x38,  0x04,  0x68,  0xfe,  0xa0,  0x00,  0xfe,  0x9b,  0x57,  0xfe,  0x4e,  0x12,  0x2b,  0xff,  0x02,
-  0x00,  0x10,  0x01,  0x08,  0x1f,  0xfe,  0xe0,  0x04,  0x2b,  0x01,  0x08,  0x1f,  0x22,  0x30,  0x2e,  0xd5,
-  0xfe,  0x4c,  0x44,  0xfe,  0x4c,  0x12,  0x60,  0xfe,  0x44,  0x48,  0x13,  0x2c,  0xfe,  0x4c,  0x54,  0x64,
-  0xd3,  0x46,  0x76,  0x27,  0xfa,  0xef,  0xfe,  0x62,  0x13,  0x09,  0x04,  0x1d,  0xfe,  0x2a,  0x13,  0x2f,
-  0x07,  0x7e,  0xa5,  0xfe,  0x20,  0x10,  0x13,  0x2c,  0xfe,  0x4c,  0x54,  0x64,  0xd3,  0xfa,  0xef,  0x86,
-  0x09,  0x04,  0x1d,  0xfe,  0x08,  0x13,  0x2f,  0x07,  0x7e,  0x6e,  0x09,  0x04,  0x1d,  0xfe,  0x1c,  0x12,
-  0x14,  0x92,  0x09,  0x04,  0x06,  0x3b,  0x14,  0xc4,  0x01,  0x33,  0x8f,  0xfe,  0x70,  0x0c,  0x02,  0x22,
-  0x2b,  0x11,  0xfe,  0xe6,  0x00,  0xfe,  0x1c,  0x90,  0xf9,  0x03,  0x14,  0x92,  0x01,  0x33,  0x02,  0x29,
-  0xfe,  0x42,  0x5b,  0x67,  0x1a,  0xfe,  0x46,  0x59,  0xf8,  0xf7,  0xfe,  0x87,  0x80,  0xfe,  0x31,  0xe4,
-  0x4f,  0x09,  0x04,  0x0b,  0xfe,  0x78,  0x13,  0xfe,  0x20,  0x80,  0x07,  0x1a,  0xfe,  0x70,  0x12,  0x49,
-  0x04,  0x06,  0xfe,  0x60,  0x13,  0x05,  0xfe,  0xa2,  0x00,  0x28,  0x16,  0xfe,  0x80,  0x05,  0xfe,  0x31,
-  0xe4,  0x6a,  0x49,  0x04,  0x0b,  0xfe,  0x4a,  0x13,  0x05,  0xfe,  0xa0,  0x00,  0x28,  0xfe,  0x42,  0x12,
-  0x5e,  0x01,  0x08,  0x25,  0x32,  0xf1,  0x01,  0x08,  0x26,  0xfe,  0x98,  0x05,  0x11,  0xfe,  0xe3,  0x00,
-  0x23,  0x49,  0xfe,  0x4a,  0xf0,  0xfe,  0x6a,  0x05,  0xfe,  0x49,  0xf0,  0xfe,  0x64,  0x05,  0x83,  0x24,
-  0xfe,  0x21,  0x00,  0xa1,  0x24,  0xfe,  0x22,  0x00,  0xa0,  0x24,  0x4c,  0xfe,  0x09,  0x48,  0x01,  0x08,
-  0x26,  0xfe,  0x98,  0x05,  0xfe,  0xe2,  0x08,  0x49,  0x04,  0xc5,  0x3b,  0x01,  0x86,  0x24,  0x06,  0x12,
-  0xcc,  0x37,  0xfe,  0x27,  0x01,  0x09,  0x04,  0x1d,  0xfe,  0x22,  0x12,  0x47,  0x01,  0xa7,  0x14,  0x92,
-  0x09,  0x04,  0x06,  0x3b,  0x14,  0xc4,  0x01,  0x33,  0x8f,  0xfe,  0x70,  0x0c,  0x02,  0x22,  0x05,  0xfe,
-  0x9c,  0x00,  0x28,  0xfe,  0x3e,  0x12,  0x05,  0x50,  0x28,  0xfe,  0x36,  0x13,  0x47,  0x01,  0xa7,  0x26,
-  0xfe,  0x08,  0x06,  0x0a,  0x06,  0x49,  0x04,  0x19,  0xfe,  0x02,  0x12,  0x5f,  0x01,  0xfe,  0xaa,  0x14,
-  0x1f,  0xfe,  0xfe,  0x05,  0x11,  0x9a,  0x01,  0x43,  0x11,  0xfe,  0xe5,  0x00,  0x05,  0x50,  0xb4,  0x0c,
-  0x50,  0x05,  0xc6,  0x28,  0xfe,  0x62,  0x12,  0x05,  0x3f,  0x28,  0xfe,  0x5a,  0x13,  0x01,  0xfe,  0x14,
-  0x18,  0x01,  0xfe,  0x66,  0x18,  0xfe,  0x43,  0x48,  0xb7,  0x19,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,
-  0x48,  0x8b,  0x1c,  0x3d,  0x85,  0xb7,  0x69,  0x47,  0x01,  0xa7,  0x26,  0xfe,  0x72,  0x06,  0x49,  0x04,
-  0x1b,  0xdf,  0x89,  0x0a,  0x4d,  0x01,  0xfe,  0xd8,  0x14,  0x1f,  0xfe,  0x68,  0x06,  0x11,  0x9a,  0x01,
-  0x43,  0x11,  0xfe,  0xe5,  0x00,  0x05,  0x3f,  0xb4,  0x0c,  0x3f,  0x17,  0x06,  0x01,  0xa7,  0xec,  0x72,
-  0x70,  0x01,  0x6e,  0x87,  0x11,  0xfe,  0xe2,  0x00,  0x01,  0x08,  0x25,  0x32,  0xfe,  0x0a,  0xf0,  0xfe,
-  0xa6,  0x06,  0x8c,  0xfe,  0x5c,  0x07,  0xfe,  0x06,  0xf0,  0xfe,  0x64,  0x07,  0x8d,  0x81,  0x02,  0x22,
-  0x09,  0x04,  0x0b,  0xfe,  0x2e,  0x12,  0x15,  0x1a,  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x00,
-  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0xfe,  0x99,  0xa4,  0x01,  0x08,  0x15,  0x00,  0x02,  0xfe,  0x32,
-  0x08,  0x61,  0x04,  0x1b,  0xfe,  0x38,  0x12,  0x09,  0x04,  0x1b,  0x6e,  0x15,  0xfe,  0x1b,  0x00,  0x01,
-  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x06,  0x01,
-  0x08,  0x15,  0x00,  0x02,  0xd9,  0x66,  0x4c,  0xfe,  0x3a,  0x55,  0x5f,  0xfe,  0x9a,  0x81,  0x4b,  0x1d,
-  0xba,  0xfe,  0x32,  0x07,  0x0a,  0x1d,  0xfe,  0x09,  0x6f,  0xaf,  0xfe,  0xca,  0x45,  0xfe,  0x32,  0x12,
-  0x62,  0x2c,  0x85,  0x66,  0x7b,  0x01,  0x08,  0x25,  0x32,  0xfe,  0x0a,  0xf0,  0xfe,  0x32,  0x07,  0x8d,
-  0x81,  0x8c,  0xfe,  0x5c,  0x07,  0x02,  0x22,  0x01,  0x43,  0x02,  0xfe,  0x8a,  0x06,  0x15,  0x19,  0x02,
-  0xfe,  0x8a,  0x06,  0xfe,  0x9c,  0xf7,  0xd4,  0xfe,  0x2c,  0x90,  0xfe,  0xae,  0x90,  0x77,  0xfe,  0xca,
-  0x07,  0x0c,  0x54,  0x18,  0x55,  0x09,  0x4a,  0x6a,  0x35,  0x1e,  0x20,  0x07,  0x10,  0xfe,  0x0e,  0x12,
-  0x74,  0xfe,  0x80,  0x80,  0x37,  0x20,  0x63,  0x27,  0xfe,  0x06,  0x10,  0xfe,  0x83,  0xe7,  0xc4,  0xa1,
-  0xfe,  0x03,  0x40,  0x09,  0x4a,  0x4f,  0x35,  0x01,  0xa8,  0xad,  0xfe,  0x1f,  0x40,  0x12,  0x58,  0x01,
-  0xa5,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0xfe,  0x44,  0x51,  0xfe,  0xc6,  0x51,  0x83,  0xfb,  0xfe,
-  0x8a,  0x90,  0x0c,  0x52,  0x18,  0x53,  0xfe,  0x0c,  0x90,  0xfe,  0x8e,  0x90,  0xfe,  0x40,  0x50,  0xfe,
-  0xc2,  0x50,  0x0c,  0x39,  0x18,  0x3a,  0xfe,  0x4a,  0x10,  0x09,  0x04,  0x6a,  0xfe,  0x2a,  0x12,  0xfe,
-  0x2c,  0x90,  0xfe,  0xae,  0x90,  0x0c,  0x54,  0x18,  0x55,  0x09,  0x04,  0x4f,  0x85,  0x01,  0xa8,  0xfe,
-  0x1f,  0x80,  0x12,  0x58,  0xfe,  0x44,  0x90,  0xfe,  0xc6,  0x90,  0x0c,  0x56,  0x18,  0x57,  0xfb,  0xfe,
-  0x8a,  0x90,  0x0c,  0x52,  0x18,  0x53,  0xfe,  0x40,  0x90,  0xfe,  0xc2,  0x90,  0x0c,  0x39,  0x18,  0x3a,
-  0x0c,  0x38,  0x18,  0x4e,  0x09,  0x4a,  0x19,  0x35,  0x2a,  0x13,  0xfe,  0x4e,  0x11,  0x65,  0xfe,  0x48,
-  0x08,  0xfe,  0x9e,  0xf0,  0xfe,  0x5c,  0x08,  0xb1,  0x16,  0x32,  0x2a,  0x73,  0xdd,  0xb8,  0xfe,  0x80,
-  0x08,  0xb9,  0xfe,  0x9e,  0x08,  0x8c,  0xfe,  0x74,  0x08,  0xfe,  0x06,  0xf0,  0xfe,  0x7a,  0x08,  0x8d,
-  0x81,  0x02,  0x22,  0x01,  0x43,  0xfe,  0xc9,  0x10,  0x15,  0x19,  0xfe,  0xc9,  0x10,  0x61,  0x04,  0x06,
-  0xfe,  0x10,  0x12,  0x61,  0x04,  0x0b,  0x45,  0x09,  0x04,  0x0b,  0xfe,  0x68,  0x12,  0xfe,  0x2e,  0x1c,
-  0x02,  0xfe,  0x24,  0x0a,  0x61,  0x04,  0x06,  0x45,  0x61,  0x04,  0x0b,  0xfe,  0x52,  0x12,  0xfe,  0x2c,
-  0x1c,  0xfe,  0xaa,  0xf0,  0xfe,  0x1e,  0x09,  0xfe,  0xac,  0xf0,  0xfe,  0xbe,  0x08,  0xfe,  0x8a,  0x10,
-  0xaa,  0xfe,  0xf3,  0x10,  0xfe,  0xad,  0xf0,  0xfe,  0xca,  0x08,  0x02,  0xfe,  0x24,  0x0a,  0xab,  0xfe,
-  0xe7,  0x10,  0xfe,  0x2b,  0xf0,  0x9d,  0xe9,  0x1c,  0xfe,  0x00,  0xfe,  0xfe,  0x1c,  0x12,  0xb5,  0xfe,
-  0xd2,  0xf0,  0x9d,  0xfe,  0x76,  0x18,  0x1c,  0x1a,  0x16,  0x9d,  0x05,  0xcb,  0x1c,  0x06,  0x16,  0x9d,
-  0xb8,  0x6d,  0xb9,  0x6d,  0xaa,  0xab,  0xfe,  0xb1,  0x10,  0x70,  0x5e,  0x2b,  0x14,  0x92,  0x01,  0x33,
-  0x0f,  0xfe,  0x35,  0x00,  0xfe,  0x01,  0xf0,  0x5a,  0x0f,  0x7c,  0x02,  0x5a,  0xfe,  0x74,  0x18,  0x1c,
-  0xfe,  0x00,  0xf8,  0x16,  0x6d,  0x67,  0x1b,  0x01,  0xfe,  0x44,  0x0d,  0x3b,  0x01,  0xe6,  0x1e,  0x27,
-  0x74,  0x67,  0x1a,  0x02,  0x6d,  0x09,  0x04,  0x0b,  0x21,  0xfe,  0x06,  0x0a,  0x09,  0x04,  0x6a,  0xfe,
-  0x82,  0x12,  0x09,  0x04,  0x19,  0xfe,  0x66,  0x13,  0x1e,  0x58,  0xac,  0xfc,  0xfe,  0x83,  0x80,  0xfe,
-  0xc8,  0x44,  0xfe,  0x2e,  0x13,  0xfe,  0x04,  0x91,  0xfe,  0x86,  0x91,  0x63,  0x27,  0xfe,  0x40,  0x59,
-  0xfe,  0xc1,  0x59,  0x77,  0xd7,  0x05,  0x54,  0x31,  0x55,  0x0c,  0x7b,  0x18,  0x7c,  0xbe,  0x54,  0xbf,
-  0x55,  0x01,  0xa8,  0xad,  0x63,  0x27,  0x12,  0x58,  0xc0,  0x38,  0xc1,  0x4e,  0x79,  0x56,  0x68,  0x57,
-  0xf4,  0xf5,  0xfe,  0x04,  0xfa,  0x38,  0xfe,  0x05,  0xfa,  0x4e,  0x01,  0xa5,  0xa2,  0x23,  0x0c,  0x7b,
-  0x0c,  0x7c,  0x79,  0x56,  0x68,  0x57,  0xfe,  0x12,  0x10,  0x09,  0x04,  0x19,  0x16,  0xd7,  0x79,  0x39,
-  0x68,  0x3a,  0x09,  0x04,  0xfe,  0xf7,  0x00,  0x35,  0x05,  0x52,  0x31,  0x53,  0xfe,  0x10,  0x58,  0xfe,
-  0x91,  0x58,  0xfe,  0x14,  0x59,  0xfe,  0x95,  0x59,  0x02,  0x6d,  0x09,  0x04,  0x19,  0x16,  0xd7,  0x09,
-  0x04,  0xfe,  0xf7,  0x00,  0x35,  0xfe,  0x3a,  0x55,  0xfe,  0x19,  0x81,  0x5f,  0xfe,  0x10,  0x90,  0xfe,
-  0x92,  0x90,  0xfe,  0xd7,  0x10,  0x2f,  0x07,  0x9b,  0x16,  0xfe,  0xc6,  0x08,  0x11,  0x9b,  0x09,  0x04,
-  0x0b,  0xfe,  0x14,  0x13,  0x05,  0x39,  0x31,  0x3a,  0x77,  0xfe,  0xc6,  0x08,  0xfe,  0x0c,  0x58,  0xfe,
-  0x8d,  0x58,  0x02,  0x6d,  0x23,  0x47,  0xfe,  0x19,  0x80,  0xde,  0x09,  0x04,  0x0b,  0xfe,  0x1a,  0x12,
-  0xfe,  0x6c,  0x19,  0xfe,  0x19,  0x41,  0xe9,  0xb5,  0xfe,  0xd1,  0xf0,  0xd9,  0x14,  0x7a,  0x01,  0x33,
-  0x0f,  0xfe,  0x44,  0x00,  0xfe,  0x8e,  0x10,  0xfe,  0x6c,  0x19,  0xbe,  0x39,  0xfe,  0xed,  0x19,  0xbf,
-  0x3a,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0xe9,  0x1c,  0xfe,  0x00,  0xff,  0x34,  0xfe,  0x74,  0x10,
-  0xb5,  0xfe,  0xd2,  0xf0,  0xfe,  0xb2,  0x0a,  0xfe,  0x76,  0x18,  0x1c,  0x1a,  0x84,  0x05,  0xcb,  0x1c,
-  0x06,  0xfe,  0x08,  0x13,  0x0f,  0xfe,  0x16,  0x00,  0x02,  0x5a,  0xfe,  0xd1,  0xf0,  0xfe,  0xc4,  0x0a,
-  0x14,  0x7a,  0x01,  0x33,  0x0f,  0xfe,  0x17,  0x00,  0xfe,  0x42,  0x10,  0xfe,  0xce,  0xf0,  0xfe,  0xca,
-  0x0a,  0xfe,  0x3c,  0x10,  0xfe,  0xcd,  0xf0,  0xfe,  0xd6,  0x0a,  0x0f,  0xfe,  0x22,  0x00,  0x02,  0x5a,
-  0xfe,  0xcb,  0xf0,  0xfe,  0xe2,  0x0a,  0x0f,  0xfe,  0x24,  0x00,  0x02,  0x5a,  0xfe,  0xd0,  0xf0,  0xfe,
-  0xec,  0x0a,  0x0f,  0x93,  0xdc,  0xfe,  0xcf,  0xf0,  0xfe,  0xf6,  0x0a,  0x0f,  0x4c,  0xfe,  0x10,  0x10,
-  0xfe,  0xcc,  0xf0,  0xd9,  0x61,  0x04,  0x19,  0x3b,  0x0f,  0xfe,  0x12,  0x00,  0x2a,  0x13,  0xfe,  0x4e,
-  0x11,  0x65,  0xfe,  0x0c,  0x0b,  0xfe,  0x9e,  0xf0,  0xfe,  0x20,  0x0b,  0xb1,  0x16,  0x32,  0x2a,  0x73,
-  0xdd,  0xb8,  0x22,  0xb9,  0x22,  0x2a,  0xec,  0x65,  0xfe,  0x2c,  0x0b,  0x25,  0x32,  0x8c,  0xfe,  0x48,
-  0x0b,  0x8d,  0x81,  0xb8,  0xd4,  0xb9,  0xd4,  0x02,  0x22,  0x01,  0x43,  0xfe,  0xdb,  0x10,  0x11,  0xfe,
-  0xe8,  0x00,  0xaa,  0xab,  0x70,  0xbc,  0x7d,  0xbd,  0x7f,  0xfe,  0x89,  0xf0,  0x22,  0x30,  0x2e,  0xd8,
-  0xbc,  0x7d,  0xbd,  0x7f,  0x01,  0x08,  0x1f,  0x22,  0x30,  0x2e,  0xd6,  0xb1,  0x45,  0x0f,  0xfe,  0x42,
-  0x00,  0x02,  0x5a,  0x78,  0x06,  0xfe,  0x81,  0x49,  0x16,  0xfe,  0x38,  0x0c,  0x09,  0x04,  0x0b,  0xfe,
-  0x44,  0x13,  0x0f,  0x00,  0x4b,  0x0b,  0xfe,  0x54,  0x12,  0x4b,  0xfe,  0x28,  0x00,  0x21,  0xfe,  0xa6,
-  0x0c,  0x0a,  0x40,  0x01,  0x0e,  0x07,  0x00,  0x5d,  0x3e,  0xfe,  0x28,  0x00,  0xfe,  0xe2,  0x10,  0x01,
-  0xe7,  0x01,  0xe8,  0x0a,  0x99,  0x01,  0xfe,  0x32,  0x0e,  0x59,  0x11,  0x2d,  0x01,  0x6f,  0x02,  0x29,
-  0x0f,  0xfe,  0x44,  0x00,  0x4b,  0x0b,  0xdf,  0x3e,  0x0b,  0xfe,  0xb4,  0x10,  0x01,  0x86,  0x3e,  0x0b,
-  0xfe,  0xaa,  0x10,  0x01,  0x86,  0xfe,  0x19,  0x82,  0xfe,  0x34,  0x46,  0xa3,  0x3e,  0x0b,  0x0f,  0xfe,
-  0x43,  0x00,  0xfe,  0x96,  0x10,  0x09,  0x4a,  0x0b,  0x35,  0x01,  0xe7,  0x01,  0xe8,  0x59,  0x11,  0x2d,
-  0x01,  0x6f,  0x67,  0x0b,  0x59,  0x3c,  0x8a,  0x02,  0xfe,  0x2a,  0x03,  0x09,  0x04,  0x0b,  0x84,  0x3e,
-  0x0b,  0x0f,  0x00,  0xfe,  0x5c,  0x10,  0x61,  0x04,  0x1b,  0xfe,  0x58,  0x12,  0x09,  0x04,  0x1b,  0xfe,
-  0x50,  0x13,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x5c,  0x0c,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,
-  0xf0,  0xfe,  0x62,  0x0c,  0x09,  0x4a,  0x1b,  0x35,  0xfe,  0xa9,  0x10,  0x0f,  0xfe,  0x15,  0x00,  0xfe,
-  0x04,  0xe6,  0x0b,  0x5f,  0x5c,  0x0f,  0xfe,  0x13,  0x00,  0xfe,  0x10,  0x10,  0x0f,  0xfe,  0x47,  0x00,
-  0xa1,  0x0f,  0xfe,  0x41,  0x00,  0xa0,  0x0f,  0xfe,  0x24,  0x00,  0x87,  0xaa,  0xab,  0x70,  0x05,  0x6b,
-  0x28,  0x21,  0xd1,  0x5f,  0xfe,  0x04,  0xe6,  0x1b,  0xfe,  0x9d,  0x41,  0xfe,  0x1c,  0x42,  0x59,  0x01,
-  0xda,  0x02,  0x29,  0xea,  0x14,  0x0b,  0x37,  0x95,  0xa9,  0x14,  0xfe,  0x31,  0x00,  0x37,  0x97,  0x01,
-  0xfe,  0x54,  0x0f,  0x02,  0xd0,  0x3c,  0xfe,  0x06,  0xec,  0xc9,  0xee,  0x3e,  0x1d,  0xfe,  0xce,  0x45,
-  0x34,  0x3c,  0xfe,  0x06,  0xea,  0xc9,  0xfe,  0x47,  0x4b,  0x89,  0xfe,  0x75,  0x57,  0x05,  0x51,  0xfe,
-  0x98,  0x56,  0xfe,  0x38,  0x12,  0x0a,  0x42,  0x01,  0x0e,  0xfe,  0x44,  0x48,  0x46,  0x09,  0x04,  0x1d,
-  0xfe,  0x1a,  0x13,  0x0a,  0x40,  0x01,  0x0e,  0x47,  0xfe,  0x41,  0x58,  0x0a,  0x99,  0x01,  0x0e,  0xfe,
-  0x49,  0x54,  0x8e,  0xfe,  0x2a,  0x0d,  0x02,  0xfe,  0x2a,  0x03,  0x0a,  0x51,  0xfe,  0xee,  0x14,  0xee,
-  0x3e,  0x1d,  0xfe,  0xce,  0x45,  0x34,  0x3c,  0xfe,  0xce,  0x47,  0xfe,  0xad,  0x13,  0x02,  0x29,  0x1e,
-  0x20,  0x07,  0x10,  0xfe,  0x9e,  0x12,  0x23,  0x12,  0x4d,  0x12,  0x94,  0x12,  0xce,  0x1e,  0x2d,  0x47,
-  0x37,  0x2d,  0xb1,  0xe0,  0xfe,  0xbc,  0xf0,  0xfe,  0xec,  0x0d,  0x13,  0x06,  0x12,  0x4d,  0x01,  0xfe,
-  0xe2,  0x15,  0x05,  0xfe,  0x38,  0x01,  0x31,  0xfe,  0x3a,  0x01,  0x77,  0xfe,  0xf0,  0x0d,  0xfe,  0x02,
-  0xec,  0xce,  0x62,  0x00,  0x5d,  0xfe,  0x04,  0xec,  0x20,  0x46,  0xfe,  0x05,  0xf6,  0xfe,  0x34,  0x01,
-  0x01,  0xfe,  0x52,  0x16,  0xfb,  0xfe,  0x48,  0xf4,  0x0d,  0xfe,  0x18,  0x13,  0xaf,  0xfe,  0x02,  0xea,
-  0xce,  0x62,  0x7a,  0xfe,  0xc5,  0x13,  0x14,  0x1b,  0x37,  0x95,  0xa9,  0x5c,  0x05,  0xfe,  0x38,  0x01,
-  0x1c,  0xfe,  0xf0,  0xff,  0x0c,  0xfe,  0x60,  0x01,  0x05,  0xfe,  0x3a,  0x01,  0x0c,  0xfe,  0x62,  0x01,
-  0x3d,  0x12,  0x20,  0x24,  0x06,  0x12,  0x2d,  0x11,  0x2d,  0x8a,  0x13,  0x06,  0x03,  0x23,  0x03,  0x1e,
-  0x4d,  0xfe,  0xf7,  0x12,  0x1e,  0x94,  0xac,  0x12,  0x94,  0x07,  0x7a,  0xfe,  0x71,  0x13,  0xfe,  0x24,
-  0x1c,  0x14,  0x1a,  0x37,  0x95,  0xa9,  0xfe,  0xd9,  0x10,  0xb6,  0xfe,  0x03,  0xdc,  0xfe,  0x73,  0x57,
-  0xfe,  0x80,  0x5d,  0x03,  0xb6,  0xfe,  0x03,  0xdc,  0xfe,  0x5b,  0x57,  0xfe,  0x80,  0x5d,  0x03,  0xfe,
-  0x03,  0x57,  0xb6,  0x23,  0xfe,  0x00,  0xcc,  0x03,  0xfe,  0x03,  0x57,  0xb6,  0x75,  0x03,  0x09,  0x04,
-  0x4c,  0xfe,  0x22,  0x13,  0xfe,  0x1c,  0x80,  0x07,  0x06,  0xfe,  0x1a,  0x13,  0xfe,  0x1e,  0x80,  0xe1,
-  0xfe,  0x1d,  0x80,  0xa4,  0xfe,  0x0c,  0x90,  0xfe,  0x0e,  0x13,  0xfe,  0x0e,  0x90,  0xa3,  0xfe,  0x3c,
-  0x90,  0xfe,  0x30,  0xf4,  0x0b,  0xfe,  0x3c,  0x50,  0xa0,  0x01,  0xfe,  0x82,  0x16,  0x2f,  0x07,  0x2d,
-  0xe0,  0x01,  0xfe,  0xbc,  0x15,  0x09,  0x04,  0x1d,  0x45,  0x01,  0xe7,  0x01,  0xe8,  0x11,  0xfe,  0xe9,
-  0x00,  0x09,  0x04,  0x4c,  0xfe,  0x2c,  0x13,  0x01,  0xfe,  0x14,  0x16,  0xfe,  0x1e,  0x1c,  0xfe,  0x14,
-  0x90,  0xfe,  0x96,  0x90,  0x0c,  0xfe,  0x64,  0x01,  0x18,  0xfe,  0x66,  0x01,  0x09,  0x04,  0x4f,  0xfe,
-  0x12,  0x12,  0xfe,  0x03,  0x80,  0x74,  0xfe,  0x01,  0xec,  0x20,  0xfe,  0x80,  0x40,  0x12,  0x20,  0x63,
-  0x27,  0x11,  0xc8,  0x59,  0x1e,  0x20,  0xed,  0x76,  0x20,  0x03,  0xfe,  0x08,  0x1c,  0x05,  0xfe,  0xac,
-  0x00,  0xfe,  0x06,  0x58,  0x05,  0xfe,  0xae,  0x00,  0xfe,  0x07,  0x58,  0x05,  0xfe,  0xb0,  0x00,  0xfe,
-  0x08,  0x58,  0x05,  0xfe,  0xb2,  0x00,  0xfe,  0x09,  0x58,  0xfe,  0x0a,  0x1c,  0x24,  0x69,  0x12,  0xc9,
-  0x23,  0x0c,  0x50,  0x0c,  0x3f,  0x13,  0x40,  0x48,  0x5f,  0x17,  0x1d,  0xfe,  0x90,  0x4d,  0xfe,  0x91,
-  0x54,  0x21,  0xfe,  0x08,  0x0f,  0x3e,  0x10,  0x13,  0x42,  0x48,  0x17,  0x4c,  0xfe,  0x90,  0x4d,  0xfe,
-  0x91,  0x54,  0x21,  0xfe,  0x1e,  0x0f,  0x24,  0x10,  0x12,  0x20,  0x78,  0x2c,  0x46,  0x1e,  0x20,  0xed,
-  0x76,  0x20,  0x11,  0xc8,  0xf6,  0xfe,  0xd6,  0xf0,  0xfe,  0x32,  0x0f,  0xea,  0x70,  0xfe,  0x14,  0x1c,
-  0xfe,  0x10,  0x1c,  0xfe,  0x18,  0x1c,  0x03,  0x3c,  0xfe,  0x0c,  0x14,  0xee,  0xfe,  0x07,  0xe6,  0x1d,
-  0xfe,  0xce,  0x47,  0xfe,  0xf5,  0x13,  0x03,  0x01,  0x86,  0x78,  0x2c,  0x46,  0xfa,  0xef,  0xfe,  0x42,
-  0x13,  0x2f,  0x07,  0x2d,  0xfe,  0x34,  0x13,  0x0a,  0x42,  0x01,  0x0e,  0xb0,  0xfe,  0x36,  0x12,  0xf0,
-  0xfe,  0x45,  0x48,  0x01,  0xe3,  0xfe,  0x00,  0xcc,  0xb0,  0xfe,  0xf3,  0x13,  0x3d,  0x75,  0x07,  0x10,
-  0xa3,  0x0a,  0x80,  0x01,  0x0e,  0xfe,  0x80,  0x5c,  0x01,  0x6f,  0xfe,  0x0e,  0x10,  0x07,  0x7e,  0x45,
-  0xf6,  0xfe,  0xd6,  0xf0,  0xfe,  0x6c,  0x0f,  0x03,  0xfe,  0x44,  0x58,  0x74,  0xfe,  0x01,  0xec,  0x97,
-  0xfe,  0x9e,  0x40,  0xfe,  0x9d,  0xe7,  0x00,  0xfe,  0x9c,  0xe7,  0x1b,  0x76,  0x27,  0x01,  0xda,  0xfe,
-  0xdd,  0x10,  0x2a,  0xbc,  0x7d,  0xbd,  0x7f,  0x30,  0x2e,  0xd5,  0x07,  0x1b,  0xfe,  0x48,  0x12,  0x07,
-  0x0b,  0xfe,  0x56,  0x12,  0x07,  0x1a,  0xfe,  0x30,  0x12,  0x07,  0xc2,  0x16,  0xfe,  0x3e,  0x11,  0x07,
-  0xfe,  0x23,  0x00,  0x16,  0xfe,  0x4a,  0x11,  0x07,  0x06,  0x16,  0xfe,  0xa8,  0x11,  0x07,  0x19,  0xfe,
-  0x12,  0x12,  0x07,  0x00,  0x16,  0x22,  0x14,  0xc2,  0x01,  0x33,  0x9f,  0x2b,  0x01,  0x08,  0x8c,  0x43,
-  0x03,  0x2b,  0xfe,  0x62,  0x08,  0x0a,  0xca,  0x01,  0xfe,  0x32,  0x0e,  0x11,  0x7e,  0x02,  0x29,  0x2b,
-  0x2f,  0x07,  0x9b,  0xfe,  0xd9,  0x13,  0x79,  0x39,  0x68,  0x3a,  0x77,  0xfe,  0xfc,  0x10,  0x09,  0x04,
-  0x6a,  0xfe,  0x72,  0x12,  0xc0,  0x38,  0xc1,  0x4e,  0xf4,  0xf5,  0x8e,  0xfe,  0xc6,  0x10,  0x1e,  0x58,
-  0xfe,  0x26,  0x13,  0x05,  0x7b,  0x31,  0x7c,  0x77,  0xfe,  0x82,  0x0c,  0x0c,  0x54,  0x18,  0x55,  0x23,
-  0x0c,  0x7b,  0x0c,  0x7c,  0x01,  0xa8,  0x24,  0x69,  0x73,  0x12,  0x58,  0x01,  0xa5,  0xc0,  0x38,  0xc1,
-  0x4e,  0xfe,  0x04,  0x55,  0xfe,  0xa5,  0x55,  0xfe,  0x04,  0xfa,  0x38,  0xfe,  0x05,  0xfa,  0x4e,  0xfe,
-  0x91,  0x10,  0x05,  0x56,  0x31,  0x57,  0xfe,  0x40,  0x56,  0xfe,  0xe1,  0x56,  0x0c,  0x56,  0x18,  0x57,
-  0x83,  0xc0,  0x38,  0xc1,  0x4e,  0xf4,  0xf5,  0x05,  0x52,  0x31,  0x53,  0xfe,  0x00,  0x56,  0xfe,  0xa1,
-  0x56,  0x0c,  0x52,  0x18,  0x53,  0x09,  0x04,  0x6a,  0xfe,  0x1e,  0x12,  0x1e,  0x58,  0xfe,  0x1f,  0x40,
-  0x05,  0x54,  0x31,  0x55,  0xfe,  0x2c,  0x50,  0xfe,  0xae,  0x50,  0x05,  0x56,  0x31,  0x57,  0xfe,  0x44,
-  0x50,  0xfe,  0xc6,  0x50,  0x05,  0x52,  0x31,  0x53,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0x05,  0x39,
-  0x31,  0x3a,  0xfe,  0x40,  0x50,  0xfe,  0xc2,  0x50,  0x02,  0x5c,  0x24,  0x06,  0x12,  0xcd,  0x02,  0x5b,
-  0x2b,  0x01,  0x08,  0x1f,  0x44,  0x30,  0x2e,  0xd5,  0x07,  0x06,  0x21,  0x44,  0x2f,  0x07,  0x9b,  0x21,
-  0x5b,  0x01,  0x6e,  0x1c,  0x3d,  0x16,  0x44,  0x09,  0x04,  0x0b,  0xe2,  0x79,  0x39,  0x68,  0x3a,  0xfe,
-  0x0a,  0x55,  0x34,  0xfe,  0x8b,  0x55,  0xbe,  0x39,  0xbf,  0x3a,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,
-  0x02,  0x5b,  0xfe,  0x19,  0x81,  0xaf,  0xfe,  0x19,  0x41,  0x02,  0x5b,  0x2b,  0x01,  0x08,  0x25,  0x32,
-  0x1f,  0xa2,  0x30,  0x2e,  0xd8,  0x4b,  0x1a,  0xfe,  0xa6,  0x12,  0x4b,  0x0b,  0x3b,  0x02,  0x44,  0x01,
-  0x08,  0x25,  0x32,  0x1f,  0xa2,  0x30,  0x2e,  0xd6,  0x07,  0x1a,  0x21,  0x44,  0x01,  0x08,  0x1f,  0xa2,
-  0x30,  0x2e,  0xfe,  0xe8,  0x09,  0xfe,  0xc2,  0x49,  0x60,  0x05,  0xfe,  0x9c,  0x00,  0x28,  0x84,  0x49,
-  0x04,  0x19,  0x34,  0x9f,  0xfe,  0xbb,  0x45,  0x4b,  0x00,  0x45,  0x3e,  0x06,  0x78,  0x3d,  0xfe,  0xda,
-  0x14,  0x01,  0x6e,  0x87,  0xfe,  0x4b,  0x45,  0xe2,  0x2f,  0x07,  0x9a,  0xe1,  0x05,  0xc6,  0x28,  0x84,
-  0x05,  0x3f,  0x28,  0x34,  0x5e,  0x02,  0x5b,  0xfe,  0xc0,  0x5d,  0xfe,  0xf8,  0x14,  0xfe,  0x03,  0x17,
-  0x05,  0x50,  0xb4,  0x0c,  0x50,  0x5e,  0x2b,  0x01,  0x08,  0x26,  0x5c,  0x01,  0xfe,  0xaa,  0x14,  0x02,
-  0x5c,  0x01,  0x08,  0x25,  0x32,  0x1f,  0x44,  0x30,  0x2e,  0xd6,  0x07,  0x06,  0x21,  0x44,  0x01,  0xfe,
-  0x8e,  0x13,  0xfe,  0x42,  0x58,  0xfe,  0x82,  0x14,  0xfe,  0xa4,  0x14,  0x87,  0xfe,  0x4a,  0xf4,  0x0b,
-  0x16,  0x44,  0xfe,  0x4a,  0xf4,  0x06,  0xfe,  0x0c,  0x12,  0x2f,  0x07,  0x9a,  0x85,  0x02,  0x5b,  0x05,
-  0x3f,  0xb4,  0x0c,  0x3f,  0x5e,  0x2b,  0x01,  0x08,  0x26,  0x5c,  0x01,  0xfe,  0xd8,  0x14,  0x02,  0x5c,
-  0x13,  0x06,  0x65,  0xfe,  0xca,  0x12,  0x26,  0xfe,  0xe0,  0x12,  0x72,  0xf1,  0x01,  0x08,  0x23,  0x72,
-  0x03,  0x8f,  0xfe,  0xdc,  0x12,  0x25,  0xfe,  0xdc,  0x12,  0x1f,  0xfe,  0xca,  0x12,  0x5e,  0x2b,  0x01,
-  0x08,  0xfe,  0xd5,  0x10,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,  0x1c,  0xfe,  0xff,  0x7f,
-  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x03,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,  0x1c,
-  0x3d,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x03,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,
-  0x03,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,  0xfe,  0x0b,  0x58,  0x03,  0x0a,  0x50,  0x01,
-  0x82,  0x0a,  0x3f,  0x01,  0x82,  0x03,  0xfc,  0x1c,  0x10,  0xff,  0x03,  0x00,  0x54,  0xfe,  0x00,  0xf4,
-  0x19,  0x48,  0xfe,  0x00,  0x7d,  0xfe,  0x01,  0x7d,  0xfe,  0x02,  0x7d,  0xfe,  0x03,  0x7c,  0x63,  0x27,
-  0x0c,  0x52,  0x18,  0x53,  0xbe,  0x56,  0xbf,  0x57,  0x03,  0xfe,  0x62,  0x08,  0xfe,  0x82,  0x4a,  0xfe,
-  0xe1,  0x1a,  0xfe,  0x83,  0x5a,  0x74,  0x03,  0x01,  0xfe,  0x14,  0x18,  0xfe,  0x42,  0x48,  0x5f,  0x60,
-  0x89,  0x01,  0x08,  0x1f,  0xfe,  0xa2,  0x14,  0x30,  0x2e,  0xd8,  0x01,  0x08,  0x1f,  0xfe,  0xa2,  0x14,
-  0x30,  0x2e,  0xfe,  0xe8,  0x0a,  0xfe,  0xc1,  0x59,  0x05,  0xc6,  0x28,  0xfe,  0xcc,  0x12,  0x49,  0x04,
-  0x1b,  0xfe,  0xc4,  0x13,  0x23,  0x62,  0x1b,  0xe2,  0x4b,  0xc3,  0x64,  0xfe,  0xe8,  0x13,  0x3b,  0x13,
-  0x06,  0x17,  0xc3,  0x78,  0xdb,  0xfe,  0x78,  0x10,  0xff,  0x02,  0x83,  0x55,  0xa1,  0xff,  0x02,  0x83,
-  0x55,  0x62,  0x1a,  0xa4,  0xbb,  0xfe,  0x30,  0x00,  0x8e,  0xe4,  0x17,  0x2c,  0x13,  0x06,  0xfe,  0x56,
-  0x10,  0x62,  0x0b,  0xe1,  0xbb,  0xfe,  0x64,  0x00,  0x8e,  0xe4,  0x0a,  0xfe,  0x64,  0x00,  0x17,  0x93,
-  0x13,  0x06,  0xfe,  0x28,  0x10,  0x62,  0x06,  0xfe,  0x60,  0x13,  0xbb,  0xfe,  0xc8,  0x00,  0x8e,  0xe4,
-  0x0a,  0xfe,  0xc8,  0x00,  0x17,  0x4d,  0x13,  0x06,  0x83,  0xbb,  0xfe,  0x90,  0x01,  0xba,  0xfe,  0x4e,
-  0x14,  0x89,  0xfe,  0x12,  0x10,  0xfe,  0x43,  0xf4,  0x94,  0xfe,  0x56,  0xf0,  0xfe,  0x60,  0x14,  0xfe,
-  0x04,  0xf4,  0x6c,  0xfe,  0x43,  0xf4,  0x93,  0xfe,  0xf3,  0x10,  0xf9,  0x01,  0xfe,  0x22,  0x13,  0x1c,
-  0x3d,  0xfe,  0x10,  0x13,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,  0x69,  0xba,  0xfe,  0x9c,  0x14,  0xb7,
-  0x69,  0xfe,  0x1c,  0x10,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,  0x19,  0xba,  0xfe,  0x9c,  0x14,  0xb7,
-  0x19,  0x83,  0x60,  0x23,  0xfe,  0x4d,  0xf4,  0x00,  0xdf,  0x89,  0x13,  0x06,  0xfe,  0xb4,  0x56,  0xfe,
-  0xc3,  0x58,  0x03,  0x60,  0x13,  0x0b,  0x03,  0x15,  0x06,  0x01,  0x08,  0x26,  0xe5,  0x15,  0x0b,  0x01,
-  0x08,  0x26,  0xe5,  0x15,  0x1a,  0x01,  0x08,  0x26,  0xe5,  0x72,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x03,
-  0x15,  0x06,  0x01,  0x08,  0x26,  0xa6,  0x15,  0x1a,  0x01,  0x08,  0x26,  0xa6,  0x15,  0x06,  0x01,  0x08,
-  0x26,  0xa6,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x26,  0xa6,  0x72,  0xfe,  0x89,  0x4a,  0x01,  0x08,  0x03,
-  0x60,  0x03,  0x1e,  0xcc,  0x07,  0x06,  0xfe,  0x44,  0x13,  0xad,  0x12,  0xcc,  0xfe,  0x49,  0xf4,  0x00,
-  0x3b,  0x72,  0x9f,  0x5e,  0xfe,  0x01,  0xec,  0xfe,  0x27,  0x01,  0xf1,  0x01,  0x08,  0x2f,  0x07,  0xfe,
-  0xe3,  0x00,  0xfe,  0x20,  0x13,  0x1f,  0xfe,  0x5a,  0x15,  0x23,  0x12,  0xcd,  0x01,  0x43,  0x1e,  0xcd,
-  0x07,  0x06,  0x45,  0x09,  0x4a,  0x06,  0x35,  0x03,  0x0a,  0x42,  0x01,  0x0e,  0xed,  0x88,  0x07,  0x10,
-  0xa4,  0x0a,  0x80,  0x01,  0x0e,  0x88,  0x0a,  0x51,  0x01,  0x9e,  0x03,  0x0a,  0x80,  0x01,  0x0e,  0x88,
-  0xfe,  0x80,  0xe7,  0x10,  0x07,  0x10,  0x84,  0xfe,  0x45,  0x58,  0x01,  0xe3,  0x88,  0x03,  0x0a,  0x42,
-  0x01,  0x0e,  0x88,  0x0a,  0x51,  0x01,  0x9e,  0x03,  0x0a,  0x42,  0x01,  0x0e,  0xfe,  0x80,  0x80,  0xf2,
-  0xfe,  0x49,  0xe4,  0x10,  0xa4,  0x0a,  0x80,  0x01,  0x0e,  0xf2,  0x0a,  0x51,  0x01,  0x82,  0x03,  0x17,
-  0x10,  0x71,  0x66,  0xfe,  0x60,  0x01,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x24,  0x1c,  0xfe,
-  0x1d,  0xf7,  0x1d,  0x90,  0xfe,  0xf6,  0x15,  0x01,  0xfe,  0xfc,  0x16,  0xe0,  0x91,  0x1d,  0x66,  0xfe,
-  0x2c,  0x01,  0xfe,  0x2f,  0x19,  0x03,  0xae,  0x21,  0xfe,  0xe6,  0x15,  0xfe,  0xda,  0x10,  0x17,  0x10,
-  0x71,  0x05,  0xfe,  0x64,  0x01,  0xfe,  0x00,  0xf4,  0x19,  0xfe,  0x18,  0x58,  0x05,  0xfe,  0x66,  0x01,
-  0xfe,  0x19,  0x58,  0x91,  0x19,  0xfe,  0x3c,  0x90,  0xfe,  0x30,  0xf4,  0x06,  0xfe,  0x3c,  0x50,  0x66,
-  0xfe,  0x38,  0x00,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0x19,  0x90,  0xfe,  0x40,  0x16,  0xfe,  0xb6,
-  0x14,  0x34,  0x03,  0xae,  0x21,  0xfe,  0x18,  0x16,  0xfe,  0x9c,  0x10,  0x17,  0x10,  0x71,  0xfe,  0x83,
-  0x5a,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x1d,  0xf7,  0x38,  0x90,  0xfe,  0x62,  0x16,  0xfe,
-  0x94,  0x14,  0xfe,  0x10,  0x13,  0x91,  0x38,  0x66,  0x1b,  0xfe,  0xaf,  0x19,  0xfe,  0x98,  0xe7,  0x00,
-  0x03,  0xae,  0x21,  0xfe,  0x56,  0x16,  0xfe,  0x6c,  0x10,  0x17,  0x10,  0x71,  0xfe,  0x30,  0xbc,  0xfe,
-  0xb2,  0xbc,  0x91,  0xc5,  0x66,  0x1b,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0xc5,  0x90,  0xfe,  0x9a,
-  0x16,  0xfe,  0x5c,  0x14,  0x34,  0x03,  0xae,  0x21,  0xfe,  0x86,  0x16,  0xfe,  0x42,  0x10,  0xfe,  0x02,
-  0xf6,  0x10,  0x71,  0xfe,  0x18,  0xfe,  0x54,  0xfe,  0x19,  0xfe,  0x55,  0xfc,  0xfe,  0x1d,  0xf7,  0x4f,
-  0x90,  0xfe,  0xc0,  0x16,  0xfe,  0x36,  0x14,  0xfe,  0x1c,  0x13,  0x91,  0x4f,  0x47,  0xfe,  0x83,  0x58,
-  0xfe,  0xaf,  0x19,  0xfe,  0x80,  0xe7,  0x10,  0xfe,  0x81,  0xe7,  0x10,  0x11,  0xfe,  0xdd,  0x00,  0x63,
-  0x27,  0x03,  0x63,  0x27,  0xfe,  0x12,  0x45,  0x21,  0xfe,  0xb0,  0x16,  0x14,  0x06,  0x37,  0x95,  0xa9,
-  0x02,  0x29,  0xfe,  0x39,  0xf0,  0xfe,  0x04,  0x17,  0x23,  0x03,  0xfe,  0x7e,  0x18,  0x1c,  0x1a,  0x5d,
-  0x13,  0x0d,  0x03,  0x71,  0x05,  0xcb,  0x1c,  0x06,  0xfe,  0xef,  0x12,  0xfe,  0xe1,  0x10,  0x78,  0x2c,
-  0x46,  0x2f,  0x07,  0x2d,  0xfe,  0x3c,  0x13,  0xfe,  0x82,  0x14,  0xfe,  0x42,  0x13,  0x3c,  0x8a,  0x0a,
-  0x42,  0x01,  0x0e,  0xb0,  0xfe,  0x3e,  0x12,  0xf0,  0xfe,  0x45,  0x48,  0x01,  0xe3,  0xfe,  0x00,  0xcc,
-  0xb0,  0xfe,  0xf3,  0x13,  0x3d,  0x75,  0x07,  0x10,  0xa3,  0x0a,  0x80,  0x01,  0x0e,  0xf2,  0x01,  0x6f,
-  0xfe,  0x16,  0x10,  0x07,  0x7e,  0x85,  0xfe,  0x40,  0x14,  0xfe,  0x24,  0x12,  0xf6,  0xfe,  0xd6,  0xf0,
-  0xfe,  0x24,  0x17,  0x17,  0x0b,  0x03,  0xfe,  0x9c,  0xe7,  0x0b,  0x0f,  0xfe,  0x15,  0x00,  0x59,  0x76,
-  0x27,  0x01,  0xda,  0x17,  0x06,  0x03,  0x3c,  0x8a,  0x09,  0x4a,  0x1d,  0x35,  0x11,  0x2d,  0x01,  0x6f,
-  0x17,  0x06,  0x03,  0xfe,  0x38,  0x90,  0xfe,  0xba,  0x90,  0x79,  0xc7,  0x68,  0xc8,  0xfe,  0x48,  0x55,
-  0x34,  0xfe,  0xc9,  0x55,  0x03,  0x1e,  0x98,  0x73,  0x12,  0x98,  0x03,  0x0a,  0x99,  0x01,  0x0e,  0xf0,
-  0x0a,  0x40,  0x01,  0x0e,  0xfe,  0x49,  0x44,  0x16,  0xfe,  0xf0,  0x17,  0x73,  0x75,  0x03,  0x0a,  0x42,
-  0x01,  0x0e,  0x07,  0x10,  0x45,  0x0a,  0x51,  0x01,  0x9e,  0x0a,  0x40,  0x01,  0x0e,  0x73,  0x75,  0x03,
-  0xfe,  0x4e,  0xe4,  0x1a,  0x64,  0xfe,  0x24,  0x18,  0x05,  0xfe,  0x90,  0x00,  0xfe,  0x3a,  0x45,  0x5b,
-  0xfe,  0x4e,  0xe4,  0xc2,  0x64,  0xfe,  0x36,  0x18,  0x05,  0xfe,  0x92,  0x00,  0xfe,  0x02,  0xe6,  0x1b,
-  0xdc,  0xfe,  0x4e,  0xe4,  0xfe,  0x0b,  0x00,  0x64,  0xfe,  0x48,  0x18,  0x05,  0xfe,  0x94,  0x00,  0xfe,
-  0x02,  0xe6,  0x19,  0xfe,  0x08,  0x10,  0x05,  0xfe,  0x96,  0x00,  0xfe,  0x02,  0xe6,  0x2c,  0xfe,  0x4e,
-  0x45,  0xfe,  0x0c,  0x12,  0xaf,  0xff,  0x04,  0x68,  0x54,  0xde,  0x1c,  0x69,  0x03,  0x07,  0x7a,  0xfe,
-  0x5a,  0xf0,  0xfe,  0x74,  0x18,  0x24,  0xfe,  0x09,  0x00,  0xfe,  0x34,  0x10,  0x07,  0x1b,  0xfe,  0x5a,
-  0xf0,  0xfe,  0x82,  0x18,  0x24,  0xc3,  0xfe,  0x26,  0x10,  0x07,  0x1a,  0x5d,  0x24,  0x2c,  0xdc,  0x07,
-  0x0b,  0x5d,  0x24,  0x93,  0xfe,  0x0e,  0x10,  0x07,  0x06,  0x5d,  0x24,  0x4d,  0x9f,  0xad,  0x03,  0x14,
-  0xfe,  0x09,  0x00,  0x01,  0x33,  0xfe,  0x04,  0xfe,  0x7d,  0x05,  0x7f,  0xf9,  0x03,  0x25,  0xfe,  0xca,
-  0x18,  0xfe,  0x14,  0xf0,  0x08,  0x65,  0xfe,  0xc6,  0x18,  0x03,  0xff,  0x1a,  0x00,  0x00,
+static unsigned char _adv_asc3550_buf[] = {
+	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0x16, 0x18, 0xe4, 0x00, 0xfc,
+	0x01, 0x00, 0x48, 0xe4,
+	0xbe, 0x18, 0x18, 0x80, 0x03, 0xf6, 0x02, 0x00, 0x00, 0xfa, 0xff, 0xff,
+	0x28, 0x0e, 0x9e, 0xe7,
+	0xff, 0x00, 0x82, 0xe7, 0x00, 0xea, 0x00, 0xf6, 0x01, 0xe6, 0x09, 0xe7,
+	0x55, 0xf0, 0x01, 0xf6,
+	0x01, 0xfa, 0x08, 0x00, 0x03, 0x00, 0x04, 0x00, 0x18, 0xf4, 0x10, 0x00,
+	0x00, 0xec, 0x85, 0xf0,
+	0xbc, 0x00, 0xd5, 0xf0, 0x8e, 0x0c, 0x38, 0x54, 0x00, 0xe6, 0x1e, 0xf0,
+	0x86, 0xf0, 0xb4, 0x00,
+	0x98, 0x57, 0xd0, 0x01, 0x0c, 0x1c, 0x3e, 0x1c, 0x0c, 0x00, 0xbb, 0x00,
+	0xaa, 0x18, 0x02, 0x80,
+	0x32, 0xf0, 0x01, 0xfc, 0x88, 0x0c, 0xc6, 0x12, 0x02, 0x13, 0x18, 0x40,
+	0x00, 0x57, 0x01, 0xea,
+	0x3c, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12, 0x3e, 0x57, 0x00, 0x80,
+	0x03, 0xe6, 0xb6, 0x00,
+	0xc0, 0x00, 0x01, 0x01, 0x3e, 0x01, 0xda, 0x0f, 0x22, 0x10, 0x08, 0x12,
+	0x02, 0x4a, 0xb9, 0x54,
+	0x03, 0x58, 0x1b, 0x80, 0x30, 0xe4, 0x4b, 0xe4, 0x20, 0x00, 0x32, 0x00,
+	0x3e, 0x00, 0x80, 0x00,
+	0x24, 0x01, 0x3c, 0x01, 0x68, 0x01, 0x6a, 0x01, 0x70, 0x01, 0x72, 0x01,
+	0x74, 0x01, 0x76, 0x01,
+	0x78, 0x01, 0x62, 0x0a, 0x92, 0x0c, 0x2c, 0x10, 0x2e, 0x10, 0x06, 0x13,
+	0x4c, 0x1c, 0xbb, 0x55,
+	0x3c, 0x56, 0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0, 0xb1, 0xf0,
+	0x03, 0xf7, 0x06, 0xf7,
+	0x03, 0xfc, 0x0f, 0x00, 0x40, 0x00, 0xbe, 0x00, 0x00, 0x01, 0xb0, 0x08,
+	0x30, 0x13, 0x64, 0x15,
+	0x32, 0x1c, 0x38, 0x1c, 0x4e, 0x1c, 0x10, 0x44, 0x02, 0x48, 0x00, 0x4c,
+	0x04, 0xea, 0x5d, 0xf0,
+	0x04, 0xf6, 0x02, 0xfc, 0x05, 0x00, 0x34, 0x00, 0x36, 0x00, 0x98, 0x00,
+	0xcc, 0x00, 0x20, 0x01,
+	0x4e, 0x01, 0x4e, 0x0b, 0x1e, 0x0e, 0x0c, 0x10, 0x0a, 0x12, 0x04, 0x13,
+	0x40, 0x13, 0x30, 0x1c,
+	0x00, 0x4e, 0xbd, 0x56, 0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0,
+	0x59, 0xf0, 0xa7, 0xf0,
+	0xb8, 0xf0, 0x0e, 0xf7, 0x06, 0x00, 0x19, 0x00, 0x33, 0x00, 0x9b, 0x00,
+	0xa4, 0x00, 0xb5, 0x00,
+	0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00, 0xe7, 0x00, 0xde, 0x03, 0x56, 0x0a,
+	0x14, 0x0e, 0x02, 0x10,
+	0x04, 0x10, 0x0a, 0x10, 0x36, 0x10, 0x0a, 0x13, 0x12, 0x13, 0x52, 0x13,
+	0x10, 0x15, 0x14, 0x15,
+	0xac, 0x16, 0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c, 0x08, 0x44, 0x38, 0x44,
+	0x91, 0x44, 0x0a, 0x45,
+	0x48, 0x46, 0x01, 0x48, 0x68, 0x54, 0x83, 0x55, 0xb0, 0x57, 0x01, 0x58,
+	0x83, 0x59, 0x05, 0xe6,
+	0x0b, 0xf0, 0x0c, 0xf0, 0x5c, 0xf0, 0x4b, 0xf4, 0x04, 0xf8, 0x05, 0xf8,
+	0x02, 0xfa, 0x03, 0xfa,
+	0x04, 0xfc, 0x05, 0xfc, 0x07, 0x00, 0x0a, 0x00, 0x0d, 0x00, 0x1c, 0x00,
+	0x9e, 0x00, 0xa8, 0x00,
+	0xaa, 0x00, 0xb9, 0x00, 0xe0, 0x00, 0x22, 0x01, 0x26, 0x01, 0x79, 0x01,
+	0x7a, 0x01, 0xc0, 0x01,
+	0xc2, 0x01, 0x7c, 0x02, 0x5a, 0x03, 0xea, 0x04, 0xe8, 0x07, 0x68, 0x08,
+	0x69, 0x08, 0xba, 0x08,
+	0xe9, 0x09, 0x06, 0x0b, 0x3a, 0x0e, 0x00, 0x10, 0x1a, 0x10, 0xed, 0x10,
+	0xf1, 0x10, 0x06, 0x12,
+	0x0c, 0x13, 0x16, 0x13, 0x1e, 0x13, 0x82, 0x13, 0x42, 0x14, 0xd6, 0x14,
+	0x8a, 0x15, 0xc6, 0x17,
+	0xd2, 0x17, 0x6b, 0x18, 0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40,
+	0x0e, 0x47, 0x48, 0x47,
+	0x41, 0x48, 0x89, 0x48, 0x80, 0x4c, 0x00, 0x54, 0x44, 0x55, 0xe5, 0x55,
+	0x14, 0x56, 0x77, 0x57,
+	0xbf, 0x57, 0x40, 0x5c, 0x06, 0x80, 0x08, 0x90, 0x03, 0xa1, 0xfe, 0x9c,
+	0xf0, 0x29, 0x02, 0xfe,
+	0xb8, 0x0c, 0xff, 0x10, 0x00, 0x00, 0xd0, 0xfe, 0xcc, 0x18, 0x00, 0xcf,
+	0xfe, 0x80, 0x01, 0xff,
+	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
+	0x00, 0xfe, 0x57, 0x24,
+	0x00, 0xfe, 0x48, 0x00, 0x4f, 0xff, 0x04, 0x00, 0x00, 0x10, 0xff, 0x09,
+	0x00, 0x00, 0xff, 0x08,
+	0x01, 0x01, 0xff, 0x08, 0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10,
+	0xff, 0xff, 0xff, 0x0f,
+	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
+	0xfe, 0x04, 0xf7, 0xcf,
+	0x2a, 0x67, 0x0b, 0x01, 0xfe, 0xce, 0x0e, 0xfe, 0x04, 0xf7, 0xcf, 0x67,
+	0x0b, 0x3c, 0x2a, 0xfe,
+	0x3d, 0xf0, 0xfe, 0x02, 0x02, 0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x91, 0xf0,
+	0xfe, 0xf0, 0x01, 0xfe,
+	0x90, 0xf0, 0xfe, 0xf0, 0x01, 0xfe, 0x8f, 0xf0, 0x9c, 0x05, 0x51, 0x3b,
+	0x02, 0xfe, 0xd4, 0x0c,
+	0x01, 0xfe, 0x44, 0x0d, 0xfe, 0xdd, 0x12, 0xfe, 0xfc, 0x10, 0xfe, 0x28,
+	0x1c, 0x05, 0xfe, 0xa6,
+	0x00, 0xfe, 0xd3, 0x12, 0x47, 0x18, 0xfe, 0xa6, 0x00, 0xb5, 0xfe, 0x48,
+	0xf0, 0xfe, 0x86, 0x02,
+	0xfe, 0x49, 0xf0, 0xfe, 0xa0, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xbe, 0x02,
+	0xfe, 0x46, 0xf0, 0xfe,
+	0x50, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x56, 0x02, 0xfe, 0x43, 0xf0, 0xfe,
+	0x44, 0x02, 0xfe, 0x44,
+	0xf0, 0xfe, 0x48, 0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x4c, 0x02, 0x17, 0x0b,
+	0xa0, 0x17, 0x06, 0x18,
+	0x96, 0x02, 0x29, 0xfe, 0x00, 0x1c, 0xde, 0xfe, 0x02, 0x1c, 0xdd, 0xfe,
+	0x1e, 0x1c, 0xfe, 0xe9,
+	0x10, 0x01, 0xfe, 0x20, 0x17, 0xfe, 0xe7, 0x10, 0xfe, 0x06, 0xfc, 0xc7,
+	0x0a, 0x6b, 0x01, 0x9e,
+	0x02, 0x29, 0x14, 0x4d, 0x37, 0x97, 0x01, 0xfe, 0x64, 0x0f, 0x0a, 0x6b,
+	0x01, 0x82, 0xfe, 0xbd,
+	0x10, 0x0a, 0x6b, 0x01, 0x82, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c, 0xfe,
+	0x58, 0x1c, 0x17, 0x06,
+	0x18, 0x96, 0x2a, 0x25, 0x29, 0xfe, 0x3d, 0xf0, 0xfe, 0x02, 0x02, 0x21,
+	0xfe, 0x94, 0x02, 0xfe,
+	0x5a, 0x1c, 0xea, 0xfe, 0x14, 0x1c, 0x14, 0xfe, 0x30, 0x00, 0x37, 0x97,
+	0x01, 0xfe, 0x54, 0x0f,
+	0x17, 0x06, 0x18, 0x96, 0x02, 0xd0, 0x1e, 0x20, 0x07, 0x10, 0x34, 0xfe,
+	0x69, 0x10, 0x17, 0x06,
+	0x18, 0x96, 0xfe, 0x04, 0xec, 0x20, 0x46, 0x3d, 0x12, 0x20, 0xfe, 0x05,
+	0xf6, 0xc7, 0x01, 0xfe,
+	0x52, 0x16, 0x09, 0x4a, 0x4c, 0x35, 0x11, 0x2d, 0x3c, 0x8a, 0x01, 0xe6,
+	0x02, 0x29, 0x0a, 0x40,
+	0x01, 0x0e, 0x07, 0x00, 0x5d, 0x01, 0x6f, 0xfe, 0x18, 0x10, 0xfe, 0x41,
+	0x58, 0x0a, 0x99, 0x01,
+	0x0e, 0xfe, 0xc8, 0x54, 0x64, 0xfe, 0x0c, 0x03, 0x01, 0xe6, 0x02, 0x29,
+	0x2a, 0x46, 0xfe, 0x02,
+	0xe8, 0x27, 0xf8, 0xfe, 0x9e, 0x43, 0xf7, 0xfe, 0x27, 0xf0, 0xfe, 0xdc,
+	0x01, 0xfe, 0x07, 0x4b,
+	0xfe, 0x20, 0xf0, 0x9c, 0xfe, 0x40, 0x1c, 0x25, 0xd2, 0xfe, 0x26, 0xf0,
+	0xfe, 0x56, 0x03, 0xfe,
+	0xa0, 0xf0, 0xfe, 0x44, 0x03, 0xfe, 0x11, 0xf0, 0x9c, 0xfe, 0xef, 0x10,
+	0xfe, 0x9f, 0xf0, 0xfe,
+	0x64, 0x03, 0xeb, 0x0f, 0xfe, 0x11, 0x00, 0x02, 0x5a, 0x2a, 0xfe, 0x48,
+	0x1c, 0xeb, 0x09, 0x04,
+	0x1d, 0xfe, 0x18, 0x13, 0x23, 0x1e, 0x98, 0xac, 0x12, 0x98, 0x0a, 0x40,
+	0x01, 0x0e, 0xac, 0x75,
+	0x01, 0xfe, 0xbc, 0x15, 0x11, 0xca, 0x25, 0xd2, 0xfe, 0x01, 0xf0, 0xd2,
+	0xfe, 0x82, 0xf0, 0xfe,
+	0x92, 0x03, 0xec, 0x11, 0xfe, 0xe4, 0x00, 0x65, 0xfe, 0xa4, 0x03, 0x25,
+	0x32, 0x1f, 0xfe, 0xb4,
+	0x03, 0x01, 0x43, 0xfe, 0x06, 0xf0, 0xfe, 0xc4, 0x03, 0x8d, 0x81, 0xfe,
+	0x0a, 0xf0, 0xfe, 0x7a,
+	0x06, 0x02, 0x22, 0x05, 0x6b, 0x28, 0x16, 0xfe, 0xf6, 0x04, 0x14, 0x2c,
+	0x01, 0x33, 0x8f, 0xfe,
+	0x66, 0x02, 0x02, 0xd1, 0xeb, 0x2a, 0x67, 0x1a, 0xfe, 0x67, 0x1b, 0xf8,
+	0xf7, 0xfe, 0x48, 0x1c,
+	0x70, 0x01, 0x6e, 0x87, 0x0a, 0x40, 0x01, 0x0e, 0x07, 0x00, 0x16, 0xd3,
+	0x0a, 0xca, 0x01, 0x0e,
+	0x74, 0x60, 0x59, 0x76, 0x27, 0x05, 0x6b, 0x28, 0xfe, 0x10, 0x12, 0x14,
+	0x2c, 0x01, 0x33, 0x8f,
+	0xfe, 0x66, 0x02, 0x02, 0xd1, 0xbc, 0x7d, 0xbd, 0x7f, 0x25, 0x22, 0x65,
+	0xfe, 0x3c, 0x04, 0x1f,
+	0xfe, 0x38, 0x04, 0x68, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e,
+	0x12, 0x2b, 0xff, 0x02,
+	0x00, 0x10, 0x01, 0x08, 0x1f, 0xfe, 0xe0, 0x04, 0x2b, 0x01, 0x08, 0x1f,
+	0x22, 0x30, 0x2e, 0xd5,
+	0xfe, 0x4c, 0x44, 0xfe, 0x4c, 0x12, 0x60, 0xfe, 0x44, 0x48, 0x13, 0x2c,
+	0xfe, 0x4c, 0x54, 0x64,
+	0xd3, 0x46, 0x76, 0x27, 0xfa, 0xef, 0xfe, 0x62, 0x13, 0x09, 0x04, 0x1d,
+	0xfe, 0x2a, 0x13, 0x2f,
+	0x07, 0x7e, 0xa5, 0xfe, 0x20, 0x10, 0x13, 0x2c, 0xfe, 0x4c, 0x54, 0x64,
+	0xd3, 0xfa, 0xef, 0x86,
+	0x09, 0x04, 0x1d, 0xfe, 0x08, 0x13, 0x2f, 0x07, 0x7e, 0x6e, 0x09, 0x04,
+	0x1d, 0xfe, 0x1c, 0x12,
+	0x14, 0x92, 0x09, 0x04, 0x06, 0x3b, 0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe,
+	0x70, 0x0c, 0x02, 0x22,
+	0x2b, 0x11, 0xfe, 0xe6, 0x00, 0xfe, 0x1c, 0x90, 0xf9, 0x03, 0x14, 0x92,
+	0x01, 0x33, 0x02, 0x29,
+	0xfe, 0x42, 0x5b, 0x67, 0x1a, 0xfe, 0x46, 0x59, 0xf8, 0xf7, 0xfe, 0x87,
+	0x80, 0xfe, 0x31, 0xe4,
+	0x4f, 0x09, 0x04, 0x0b, 0xfe, 0x78, 0x13, 0xfe, 0x20, 0x80, 0x07, 0x1a,
+	0xfe, 0x70, 0x12, 0x49,
+	0x04, 0x06, 0xfe, 0x60, 0x13, 0x05, 0xfe, 0xa2, 0x00, 0x28, 0x16, 0xfe,
+	0x80, 0x05, 0xfe, 0x31,
+	0xe4, 0x6a, 0x49, 0x04, 0x0b, 0xfe, 0x4a, 0x13, 0x05, 0xfe, 0xa0, 0x00,
+	0x28, 0xfe, 0x42, 0x12,
+	0x5e, 0x01, 0x08, 0x25, 0x32, 0xf1, 0x01, 0x08, 0x26, 0xfe, 0x98, 0x05,
+	0x11, 0xfe, 0xe3, 0x00,
+	0x23, 0x49, 0xfe, 0x4a, 0xf0, 0xfe, 0x6a, 0x05, 0xfe, 0x49, 0xf0, 0xfe,
+	0x64, 0x05, 0x83, 0x24,
+	0xfe, 0x21, 0x00, 0xa1, 0x24, 0xfe, 0x22, 0x00, 0xa0, 0x24, 0x4c, 0xfe,
+	0x09, 0x48, 0x01, 0x08,
+	0x26, 0xfe, 0x98, 0x05, 0xfe, 0xe2, 0x08, 0x49, 0x04, 0xc5, 0x3b, 0x01,
+	0x86, 0x24, 0x06, 0x12,
+	0xcc, 0x37, 0xfe, 0x27, 0x01, 0x09, 0x04, 0x1d, 0xfe, 0x22, 0x12, 0x47,
+	0x01, 0xa7, 0x14, 0x92,
+	0x09, 0x04, 0x06, 0x3b, 0x14, 0xc4, 0x01, 0x33, 0x8f, 0xfe, 0x70, 0x0c,
+	0x02, 0x22, 0x05, 0xfe,
+	0x9c, 0x00, 0x28, 0xfe, 0x3e, 0x12, 0x05, 0x50, 0x28, 0xfe, 0x36, 0x13,
+	0x47, 0x01, 0xa7, 0x26,
+	0xfe, 0x08, 0x06, 0x0a, 0x06, 0x49, 0x04, 0x19, 0xfe, 0x02, 0x12, 0x5f,
+	0x01, 0xfe, 0xaa, 0x14,
+	0x1f, 0xfe, 0xfe, 0x05, 0x11, 0x9a, 0x01, 0x43, 0x11, 0xfe, 0xe5, 0x00,
+	0x05, 0x50, 0xb4, 0x0c,
+	0x50, 0x05, 0xc6, 0x28, 0xfe, 0x62, 0x12, 0x05, 0x3f, 0x28, 0xfe, 0x5a,
+	0x13, 0x01, 0xfe, 0x14,
+	0x18, 0x01, 0xfe, 0x66, 0x18, 0xfe, 0x43, 0x48, 0xb7, 0x19, 0x13, 0x6c,
+	0xff, 0x02, 0x00, 0x57,
+	0x48, 0x8b, 0x1c, 0x3d, 0x85, 0xb7, 0x69, 0x47, 0x01, 0xa7, 0x26, 0xfe,
+	0x72, 0x06, 0x49, 0x04,
+	0x1b, 0xdf, 0x89, 0x0a, 0x4d, 0x01, 0xfe, 0xd8, 0x14, 0x1f, 0xfe, 0x68,
+	0x06, 0x11, 0x9a, 0x01,
+	0x43, 0x11, 0xfe, 0xe5, 0x00, 0x05, 0x3f, 0xb4, 0x0c, 0x3f, 0x17, 0x06,
+	0x01, 0xa7, 0xec, 0x72,
+	0x70, 0x01, 0x6e, 0x87, 0x11, 0xfe, 0xe2, 0x00, 0x01, 0x08, 0x25, 0x32,
+	0xfe, 0x0a, 0xf0, 0xfe,
+	0xa6, 0x06, 0x8c, 0xfe, 0x5c, 0x07, 0xfe, 0x06, 0xf0, 0xfe, 0x64, 0x07,
+	0x8d, 0x81, 0x02, 0x22,
+	0x09, 0x04, 0x0b, 0xfe, 0x2e, 0x12, 0x15, 0x1a, 0x01, 0x08, 0x15, 0x00,
+	0x01, 0x08, 0x15, 0x00,
+	0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0xfe, 0x99, 0xa4, 0x01, 0x08, 0x15,
+	0x00, 0x02, 0xfe, 0x32,
+	0x08, 0x61, 0x04, 0x1b, 0xfe, 0x38, 0x12, 0x09, 0x04, 0x1b, 0x6e, 0x15,
+	0xfe, 0x1b, 0x00, 0x01,
+	0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01, 0x08, 0x15, 0x00, 0x01,
+	0x08, 0x15, 0x06, 0x01,
+	0x08, 0x15, 0x00, 0x02, 0xd9, 0x66, 0x4c, 0xfe, 0x3a, 0x55, 0x5f, 0xfe,
+	0x9a, 0x81, 0x4b, 0x1d,
+	0xba, 0xfe, 0x32, 0x07, 0x0a, 0x1d, 0xfe, 0x09, 0x6f, 0xaf, 0xfe, 0xca,
+	0x45, 0xfe, 0x32, 0x12,
+	0x62, 0x2c, 0x85, 0x66, 0x7b, 0x01, 0x08, 0x25, 0x32, 0xfe, 0x0a, 0xf0,
+	0xfe, 0x32, 0x07, 0x8d,
+	0x81, 0x8c, 0xfe, 0x5c, 0x07, 0x02, 0x22, 0x01, 0x43, 0x02, 0xfe, 0x8a,
+	0x06, 0x15, 0x19, 0x02,
+	0xfe, 0x8a, 0x06, 0xfe, 0x9c, 0xf7, 0xd4, 0xfe, 0x2c, 0x90, 0xfe, 0xae,
+	0x90, 0x77, 0xfe, 0xca,
+	0x07, 0x0c, 0x54, 0x18, 0x55, 0x09, 0x4a, 0x6a, 0x35, 0x1e, 0x20, 0x07,
+	0x10, 0xfe, 0x0e, 0x12,
+	0x74, 0xfe, 0x80, 0x80, 0x37, 0x20, 0x63, 0x27, 0xfe, 0x06, 0x10, 0xfe,
+	0x83, 0xe7, 0xc4, 0xa1,
+	0xfe, 0x03, 0x40, 0x09, 0x4a, 0x4f, 0x35, 0x01, 0xa8, 0xad, 0xfe, 0x1f,
+	0x40, 0x12, 0x58, 0x01,
+	0xa5, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0xfe, 0x44, 0x51, 0xfe, 0xc6,
+	0x51, 0x83, 0xfb, 0xfe,
+	0x8a, 0x90, 0x0c, 0x52, 0x18, 0x53, 0xfe, 0x0c, 0x90, 0xfe, 0x8e, 0x90,
+	0xfe, 0x40, 0x50, 0xfe,
+	0xc2, 0x50, 0x0c, 0x39, 0x18, 0x3a, 0xfe, 0x4a, 0x10, 0x09, 0x04, 0x6a,
+	0xfe, 0x2a, 0x12, 0xfe,
+	0x2c, 0x90, 0xfe, 0xae, 0x90, 0x0c, 0x54, 0x18, 0x55, 0x09, 0x04, 0x4f,
+	0x85, 0x01, 0xa8, 0xfe,
+	0x1f, 0x80, 0x12, 0x58, 0xfe, 0x44, 0x90, 0xfe, 0xc6, 0x90, 0x0c, 0x56,
+	0x18, 0x57, 0xfb, 0xfe,
+	0x8a, 0x90, 0x0c, 0x52, 0x18, 0x53, 0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90,
+	0x0c, 0x39, 0x18, 0x3a,
+	0x0c, 0x38, 0x18, 0x4e, 0x09, 0x4a, 0x19, 0x35, 0x2a, 0x13, 0xfe, 0x4e,
+	0x11, 0x65, 0xfe, 0x48,
+	0x08, 0xfe, 0x9e, 0xf0, 0xfe, 0x5c, 0x08, 0xb1, 0x16, 0x32, 0x2a, 0x73,
+	0xdd, 0xb8, 0xfe, 0x80,
+	0x08, 0xb9, 0xfe, 0x9e, 0x08, 0x8c, 0xfe, 0x74, 0x08, 0xfe, 0x06, 0xf0,
+	0xfe, 0x7a, 0x08, 0x8d,
+	0x81, 0x02, 0x22, 0x01, 0x43, 0xfe, 0xc9, 0x10, 0x15, 0x19, 0xfe, 0xc9,
+	0x10, 0x61, 0x04, 0x06,
+	0xfe, 0x10, 0x12, 0x61, 0x04, 0x0b, 0x45, 0x09, 0x04, 0x0b, 0xfe, 0x68,
+	0x12, 0xfe, 0x2e, 0x1c,
+	0x02, 0xfe, 0x24, 0x0a, 0x61, 0x04, 0x06, 0x45, 0x61, 0x04, 0x0b, 0xfe,
+	0x52, 0x12, 0xfe, 0x2c,
+	0x1c, 0xfe, 0xaa, 0xf0, 0xfe, 0x1e, 0x09, 0xfe, 0xac, 0xf0, 0xfe, 0xbe,
+	0x08, 0xfe, 0x8a, 0x10,
+	0xaa, 0xfe, 0xf3, 0x10, 0xfe, 0xad, 0xf0, 0xfe, 0xca, 0x08, 0x02, 0xfe,
+	0x24, 0x0a, 0xab, 0xfe,
+	0xe7, 0x10, 0xfe, 0x2b, 0xf0, 0x9d, 0xe9, 0x1c, 0xfe, 0x00, 0xfe, 0xfe,
+	0x1c, 0x12, 0xb5, 0xfe,
+	0xd2, 0xf0, 0x9d, 0xfe, 0x76, 0x18, 0x1c, 0x1a, 0x16, 0x9d, 0x05, 0xcb,
+	0x1c, 0x06, 0x16, 0x9d,
+	0xb8, 0x6d, 0xb9, 0x6d, 0xaa, 0xab, 0xfe, 0xb1, 0x10, 0x70, 0x5e, 0x2b,
+	0x14, 0x92, 0x01, 0x33,
+	0x0f, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x5a, 0x0f, 0x7c, 0x02, 0x5a,
+	0xfe, 0x74, 0x18, 0x1c,
+	0xfe, 0x00, 0xf8, 0x16, 0x6d, 0x67, 0x1b, 0x01, 0xfe, 0x44, 0x0d, 0x3b,
+	0x01, 0xe6, 0x1e, 0x27,
+	0x74, 0x67, 0x1a, 0x02, 0x6d, 0x09, 0x04, 0x0b, 0x21, 0xfe, 0x06, 0x0a,
+	0x09, 0x04, 0x6a, 0xfe,
+	0x82, 0x12, 0x09, 0x04, 0x19, 0xfe, 0x66, 0x13, 0x1e, 0x58, 0xac, 0xfc,
+	0xfe, 0x83, 0x80, 0xfe,
+	0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91, 0xfe, 0x86, 0x91, 0x63,
+	0x27, 0xfe, 0x40, 0x59,
+	0xfe, 0xc1, 0x59, 0x77, 0xd7, 0x05, 0x54, 0x31, 0x55, 0x0c, 0x7b, 0x18,
+	0x7c, 0xbe, 0x54, 0xbf,
+	0x55, 0x01, 0xa8, 0xad, 0x63, 0x27, 0x12, 0x58, 0xc0, 0x38, 0xc1, 0x4e,
+	0x79, 0x56, 0x68, 0x57,
+	0xf4, 0xf5, 0xfe, 0x04, 0xfa, 0x38, 0xfe, 0x05, 0xfa, 0x4e, 0x01, 0xa5,
+	0xa2, 0x23, 0x0c, 0x7b,
+	0x0c, 0x7c, 0x79, 0x56, 0x68, 0x57, 0xfe, 0x12, 0x10, 0x09, 0x04, 0x19,
+	0x16, 0xd7, 0x79, 0x39,
+	0x68, 0x3a, 0x09, 0x04, 0xfe, 0xf7, 0x00, 0x35, 0x05, 0x52, 0x31, 0x53,
+	0xfe, 0x10, 0x58, 0xfe,
+	0x91, 0x58, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x02, 0x6d, 0x09, 0x04,
+	0x19, 0x16, 0xd7, 0x09,
+	0x04, 0xfe, 0xf7, 0x00, 0x35, 0xfe, 0x3a, 0x55, 0xfe, 0x19, 0x81, 0x5f,
+	0xfe, 0x10, 0x90, 0xfe,
+	0x92, 0x90, 0xfe, 0xd7, 0x10, 0x2f, 0x07, 0x9b, 0x16, 0xfe, 0xc6, 0x08,
+	0x11, 0x9b, 0x09, 0x04,
+	0x0b, 0xfe, 0x14, 0x13, 0x05, 0x39, 0x31, 0x3a, 0x77, 0xfe, 0xc6, 0x08,
+	0xfe, 0x0c, 0x58, 0xfe,
+	0x8d, 0x58, 0x02, 0x6d, 0x23, 0x47, 0xfe, 0x19, 0x80, 0xde, 0x09, 0x04,
+	0x0b, 0xfe, 0x1a, 0x12,
+	0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41, 0xe9, 0xb5, 0xfe, 0xd1, 0xf0, 0xd9,
+	0x14, 0x7a, 0x01, 0x33,
+	0x0f, 0xfe, 0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe, 0x6c, 0x19, 0xbe, 0x39,
+	0xfe, 0xed, 0x19, 0xbf,
+	0x3a, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0xe9, 0x1c, 0xfe, 0x00, 0xff,
+	0x34, 0xfe, 0x74, 0x10,
+	0xb5, 0xfe, 0xd2, 0xf0, 0xfe, 0xb2, 0x0a, 0xfe, 0x76, 0x18, 0x1c, 0x1a,
+	0x84, 0x05, 0xcb, 0x1c,
+	0x06, 0xfe, 0x08, 0x13, 0x0f, 0xfe, 0x16, 0x00, 0x02, 0x5a, 0xfe, 0xd1,
+	0xf0, 0xfe, 0xc4, 0x0a,
+	0x14, 0x7a, 0x01, 0x33, 0x0f, 0xfe, 0x17, 0x00, 0xfe, 0x42, 0x10, 0xfe,
+	0xce, 0xf0, 0xfe, 0xca,
+	0x0a, 0xfe, 0x3c, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xd6, 0x0a, 0x0f, 0xfe,
+	0x22, 0x00, 0x02, 0x5a,
+	0xfe, 0xcb, 0xf0, 0xfe, 0xe2, 0x0a, 0x0f, 0xfe, 0x24, 0x00, 0x02, 0x5a,
+	0xfe, 0xd0, 0xf0, 0xfe,
+	0xec, 0x0a, 0x0f, 0x93, 0xdc, 0xfe, 0xcf, 0xf0, 0xfe, 0xf6, 0x0a, 0x0f,
+	0x4c, 0xfe, 0x10, 0x10,
+	0xfe, 0xcc, 0xf0, 0xd9, 0x61, 0x04, 0x19, 0x3b, 0x0f, 0xfe, 0x12, 0x00,
+	0x2a, 0x13, 0xfe, 0x4e,
+	0x11, 0x65, 0xfe, 0x0c, 0x0b, 0xfe, 0x9e, 0xf0, 0xfe, 0x20, 0x0b, 0xb1,
+	0x16, 0x32, 0x2a, 0x73,
+	0xdd, 0xb8, 0x22, 0xb9, 0x22, 0x2a, 0xec, 0x65, 0xfe, 0x2c, 0x0b, 0x25,
+	0x32, 0x8c, 0xfe, 0x48,
+	0x0b, 0x8d, 0x81, 0xb8, 0xd4, 0xb9, 0xd4, 0x02, 0x22, 0x01, 0x43, 0xfe,
+	0xdb, 0x10, 0x11, 0xfe,
+	0xe8, 0x00, 0xaa, 0xab, 0x70, 0xbc, 0x7d, 0xbd, 0x7f, 0xfe, 0x89, 0xf0,
+	0x22, 0x30, 0x2e, 0xd8,
+	0xbc, 0x7d, 0xbd, 0x7f, 0x01, 0x08, 0x1f, 0x22, 0x30, 0x2e, 0xd6, 0xb1,
+	0x45, 0x0f, 0xfe, 0x42,
+	0x00, 0x02, 0x5a, 0x78, 0x06, 0xfe, 0x81, 0x49, 0x16, 0xfe, 0x38, 0x0c,
+	0x09, 0x04, 0x0b, 0xfe,
+	0x44, 0x13, 0x0f, 0x00, 0x4b, 0x0b, 0xfe, 0x54, 0x12, 0x4b, 0xfe, 0x28,
+	0x00, 0x21, 0xfe, 0xa6,
+	0x0c, 0x0a, 0x40, 0x01, 0x0e, 0x07, 0x00, 0x5d, 0x3e, 0xfe, 0x28, 0x00,
+	0xfe, 0xe2, 0x10, 0x01,
+	0xe7, 0x01, 0xe8, 0x0a, 0x99, 0x01, 0xfe, 0x32, 0x0e, 0x59, 0x11, 0x2d,
+	0x01, 0x6f, 0x02, 0x29,
+	0x0f, 0xfe, 0x44, 0x00, 0x4b, 0x0b, 0xdf, 0x3e, 0x0b, 0xfe, 0xb4, 0x10,
+	0x01, 0x86, 0x3e, 0x0b,
+	0xfe, 0xaa, 0x10, 0x01, 0x86, 0xfe, 0x19, 0x82, 0xfe, 0x34, 0x46, 0xa3,
+	0x3e, 0x0b, 0x0f, 0xfe,
+	0x43, 0x00, 0xfe, 0x96, 0x10, 0x09, 0x4a, 0x0b, 0x35, 0x01, 0xe7, 0x01,
+	0xe8, 0x59, 0x11, 0x2d,
+	0x01, 0x6f, 0x67, 0x0b, 0x59, 0x3c, 0x8a, 0x02, 0xfe, 0x2a, 0x03, 0x09,
+	0x04, 0x0b, 0x84, 0x3e,
+	0x0b, 0x0f, 0x00, 0xfe, 0x5c, 0x10, 0x61, 0x04, 0x1b, 0xfe, 0x58, 0x12,
+	0x09, 0x04, 0x1b, 0xfe,
+	0x50, 0x13, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x5c, 0x0c, 0xfe,
+	0x1c, 0x1c, 0xfe, 0x9d,
+	0xf0, 0xfe, 0x62, 0x0c, 0x09, 0x4a, 0x1b, 0x35, 0xfe, 0xa9, 0x10, 0x0f,
+	0xfe, 0x15, 0x00, 0xfe,
+	0x04, 0xe6, 0x0b, 0x5f, 0x5c, 0x0f, 0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10,
+	0x0f, 0xfe, 0x47, 0x00,
+	0xa1, 0x0f, 0xfe, 0x41, 0x00, 0xa0, 0x0f, 0xfe, 0x24, 0x00, 0x87, 0xaa,
+	0xab, 0x70, 0x05, 0x6b,
+	0x28, 0x21, 0xd1, 0x5f, 0xfe, 0x04, 0xe6, 0x1b, 0xfe, 0x9d, 0x41, 0xfe,
+	0x1c, 0x42, 0x59, 0x01,
+	0xda, 0x02, 0x29, 0xea, 0x14, 0x0b, 0x37, 0x95, 0xa9, 0x14, 0xfe, 0x31,
+	0x00, 0x37, 0x97, 0x01,
+	0xfe, 0x54, 0x0f, 0x02, 0xd0, 0x3c, 0xfe, 0x06, 0xec, 0xc9, 0xee, 0x3e,
+	0x1d, 0xfe, 0xce, 0x45,
+	0x34, 0x3c, 0xfe, 0x06, 0xea, 0xc9, 0xfe, 0x47, 0x4b, 0x89, 0xfe, 0x75,
+	0x57, 0x05, 0x51, 0xfe,
+	0x98, 0x56, 0xfe, 0x38, 0x12, 0x0a, 0x42, 0x01, 0x0e, 0xfe, 0x44, 0x48,
+	0x46, 0x09, 0x04, 0x1d,
+	0xfe, 0x1a, 0x13, 0x0a, 0x40, 0x01, 0x0e, 0x47, 0xfe, 0x41, 0x58, 0x0a,
+	0x99, 0x01, 0x0e, 0xfe,
+	0x49, 0x54, 0x8e, 0xfe, 0x2a, 0x0d, 0x02, 0xfe, 0x2a, 0x03, 0x0a, 0x51,
+	0xfe, 0xee, 0x14, 0xee,
+	0x3e, 0x1d, 0xfe, 0xce, 0x45, 0x34, 0x3c, 0xfe, 0xce, 0x47, 0xfe, 0xad,
+	0x13, 0x02, 0x29, 0x1e,
+	0x20, 0x07, 0x10, 0xfe, 0x9e, 0x12, 0x23, 0x12, 0x4d, 0x12, 0x94, 0x12,
+	0xce, 0x1e, 0x2d, 0x47,
+	0x37, 0x2d, 0xb1, 0xe0, 0xfe, 0xbc, 0xf0, 0xfe, 0xec, 0x0d, 0x13, 0x06,
+	0x12, 0x4d, 0x01, 0xfe,
+	0xe2, 0x15, 0x05, 0xfe, 0x38, 0x01, 0x31, 0xfe, 0x3a, 0x01, 0x77, 0xfe,
+	0xf0, 0x0d, 0xfe, 0x02,
+	0xec, 0xce, 0x62, 0x00, 0x5d, 0xfe, 0x04, 0xec, 0x20, 0x46, 0xfe, 0x05,
+	0xf6, 0xfe, 0x34, 0x01,
+	0x01, 0xfe, 0x52, 0x16, 0xfb, 0xfe, 0x48, 0xf4, 0x0d, 0xfe, 0x18, 0x13,
+	0xaf, 0xfe, 0x02, 0xea,
+	0xce, 0x62, 0x7a, 0xfe, 0xc5, 0x13, 0x14, 0x1b, 0x37, 0x95, 0xa9, 0x5c,
+	0x05, 0xfe, 0x38, 0x01,
+	0x1c, 0xfe, 0xf0, 0xff, 0x0c, 0xfe, 0x60, 0x01, 0x05, 0xfe, 0x3a, 0x01,
+	0x0c, 0xfe, 0x62, 0x01,
+	0x3d, 0x12, 0x20, 0x24, 0x06, 0x12, 0x2d, 0x11, 0x2d, 0x8a, 0x13, 0x06,
+	0x03, 0x23, 0x03, 0x1e,
+	0x4d, 0xfe, 0xf7, 0x12, 0x1e, 0x94, 0xac, 0x12, 0x94, 0x07, 0x7a, 0xfe,
+	0x71, 0x13, 0xfe, 0x24,
+	0x1c, 0x14, 0x1a, 0x37, 0x95, 0xa9, 0xfe, 0xd9, 0x10, 0xb6, 0xfe, 0x03,
+	0xdc, 0xfe, 0x73, 0x57,
+	0xfe, 0x80, 0x5d, 0x03, 0xb6, 0xfe, 0x03, 0xdc, 0xfe, 0x5b, 0x57, 0xfe,
+	0x80, 0x5d, 0x03, 0xfe,
+	0x03, 0x57, 0xb6, 0x23, 0xfe, 0x00, 0xcc, 0x03, 0xfe, 0x03, 0x57, 0xb6,
+	0x75, 0x03, 0x09, 0x04,
+	0x4c, 0xfe, 0x22, 0x13, 0xfe, 0x1c, 0x80, 0x07, 0x06, 0xfe, 0x1a, 0x13,
+	0xfe, 0x1e, 0x80, 0xe1,
+	0xfe, 0x1d, 0x80, 0xa4, 0xfe, 0x0c, 0x90, 0xfe, 0x0e, 0x13, 0xfe, 0x0e,
+	0x90, 0xa3, 0xfe, 0x3c,
+	0x90, 0xfe, 0x30, 0xf4, 0x0b, 0xfe, 0x3c, 0x50, 0xa0, 0x01, 0xfe, 0x82,
+	0x16, 0x2f, 0x07, 0x2d,
+	0xe0, 0x01, 0xfe, 0xbc, 0x15, 0x09, 0x04, 0x1d, 0x45, 0x01, 0xe7, 0x01,
+	0xe8, 0x11, 0xfe, 0xe9,
+	0x00, 0x09, 0x04, 0x4c, 0xfe, 0x2c, 0x13, 0x01, 0xfe, 0x14, 0x16, 0xfe,
+	0x1e, 0x1c, 0xfe, 0x14,
+	0x90, 0xfe, 0x96, 0x90, 0x0c, 0xfe, 0x64, 0x01, 0x18, 0xfe, 0x66, 0x01,
+	0x09, 0x04, 0x4f, 0xfe,
+	0x12, 0x12, 0xfe, 0x03, 0x80, 0x74, 0xfe, 0x01, 0xec, 0x20, 0xfe, 0x80,
+	0x40, 0x12, 0x20, 0x63,
+	0x27, 0x11, 0xc8, 0x59, 0x1e, 0x20, 0xed, 0x76, 0x20, 0x03, 0xfe, 0x08,
+	0x1c, 0x05, 0xfe, 0xac,
+	0x00, 0xfe, 0x06, 0x58, 0x05, 0xfe, 0xae, 0x00, 0xfe, 0x07, 0x58, 0x05,
+	0xfe, 0xb0, 0x00, 0xfe,
+	0x08, 0x58, 0x05, 0xfe, 0xb2, 0x00, 0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c,
+	0x24, 0x69, 0x12, 0xc9,
+	0x23, 0x0c, 0x50, 0x0c, 0x3f, 0x13, 0x40, 0x48, 0x5f, 0x17, 0x1d, 0xfe,
+	0x90, 0x4d, 0xfe, 0x91,
+	0x54, 0x21, 0xfe, 0x08, 0x0f, 0x3e, 0x10, 0x13, 0x42, 0x48, 0x17, 0x4c,
+	0xfe, 0x90, 0x4d, 0xfe,
+	0x91, 0x54, 0x21, 0xfe, 0x1e, 0x0f, 0x24, 0x10, 0x12, 0x20, 0x78, 0x2c,
+	0x46, 0x1e, 0x20, 0xed,
+	0x76, 0x20, 0x11, 0xc8, 0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x32, 0x0f, 0xea,
+	0x70, 0xfe, 0x14, 0x1c,
+	0xfe, 0x10, 0x1c, 0xfe, 0x18, 0x1c, 0x03, 0x3c, 0xfe, 0x0c, 0x14, 0xee,
+	0xfe, 0x07, 0xe6, 0x1d,
+	0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x03, 0x01, 0x86, 0x78, 0x2c, 0x46,
+	0xfa, 0xef, 0xfe, 0x42,
+	0x13, 0x2f, 0x07, 0x2d, 0xfe, 0x34, 0x13, 0x0a, 0x42, 0x01, 0x0e, 0xb0,
+	0xfe, 0x36, 0x12, 0xf0,
+	0xfe, 0x45, 0x48, 0x01, 0xe3, 0xfe, 0x00, 0xcc, 0xb0, 0xfe, 0xf3, 0x13,
+	0x3d, 0x75, 0x07, 0x10,
+	0xa3, 0x0a, 0x80, 0x01, 0x0e, 0xfe, 0x80, 0x5c, 0x01, 0x6f, 0xfe, 0x0e,
+	0x10, 0x07, 0x7e, 0x45,
+	0xf6, 0xfe, 0xd6, 0xf0, 0xfe, 0x6c, 0x0f, 0x03, 0xfe, 0x44, 0x58, 0x74,
+	0xfe, 0x01, 0xec, 0x97,
+	0xfe, 0x9e, 0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x1b, 0x76,
+	0x27, 0x01, 0xda, 0xfe,
+	0xdd, 0x10, 0x2a, 0xbc, 0x7d, 0xbd, 0x7f, 0x30, 0x2e, 0xd5, 0x07, 0x1b,
+	0xfe, 0x48, 0x12, 0x07,
+	0x0b, 0xfe, 0x56, 0x12, 0x07, 0x1a, 0xfe, 0x30, 0x12, 0x07, 0xc2, 0x16,
+	0xfe, 0x3e, 0x11, 0x07,
+	0xfe, 0x23, 0x00, 0x16, 0xfe, 0x4a, 0x11, 0x07, 0x06, 0x16, 0xfe, 0xa8,
+	0x11, 0x07, 0x19, 0xfe,
+	0x12, 0x12, 0x07, 0x00, 0x16, 0x22, 0x14, 0xc2, 0x01, 0x33, 0x9f, 0x2b,
+	0x01, 0x08, 0x8c, 0x43,
+	0x03, 0x2b, 0xfe, 0x62, 0x08, 0x0a, 0xca, 0x01, 0xfe, 0x32, 0x0e, 0x11,
+	0x7e, 0x02, 0x29, 0x2b,
+	0x2f, 0x07, 0x9b, 0xfe, 0xd9, 0x13, 0x79, 0x39, 0x68, 0x3a, 0x77, 0xfe,
+	0xfc, 0x10, 0x09, 0x04,
+	0x6a, 0xfe, 0x72, 0x12, 0xc0, 0x38, 0xc1, 0x4e, 0xf4, 0xf5, 0x8e, 0xfe,
+	0xc6, 0x10, 0x1e, 0x58,
+	0xfe, 0x26, 0x13, 0x05, 0x7b, 0x31, 0x7c, 0x77, 0xfe, 0x82, 0x0c, 0x0c,
+	0x54, 0x18, 0x55, 0x23,
+	0x0c, 0x7b, 0x0c, 0x7c, 0x01, 0xa8, 0x24, 0x69, 0x73, 0x12, 0x58, 0x01,
+	0xa5, 0xc0, 0x38, 0xc1,
+	0x4e, 0xfe, 0x04, 0x55, 0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x38, 0xfe,
+	0x05, 0xfa, 0x4e, 0xfe,
+	0x91, 0x10, 0x05, 0x56, 0x31, 0x57, 0xfe, 0x40, 0x56, 0xfe, 0xe1, 0x56,
+	0x0c, 0x56, 0x18, 0x57,
+	0x83, 0xc0, 0x38, 0xc1, 0x4e, 0xf4, 0xf5, 0x05, 0x52, 0x31, 0x53, 0xfe,
+	0x00, 0x56, 0xfe, 0xa1,
+	0x56, 0x0c, 0x52, 0x18, 0x53, 0x09, 0x04, 0x6a, 0xfe, 0x1e, 0x12, 0x1e,
+	0x58, 0xfe, 0x1f, 0x40,
+	0x05, 0x54, 0x31, 0x55, 0xfe, 0x2c, 0x50, 0xfe, 0xae, 0x50, 0x05, 0x56,
+	0x31, 0x57, 0xfe, 0x44,
+	0x50, 0xfe, 0xc6, 0x50, 0x05, 0x52, 0x31, 0x53, 0xfe, 0x08, 0x50, 0xfe,
+	0x8a, 0x50, 0x05, 0x39,
+	0x31, 0x3a, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x02, 0x5c, 0x24, 0x06,
+	0x12, 0xcd, 0x02, 0x5b,
+	0x2b, 0x01, 0x08, 0x1f, 0x44, 0x30, 0x2e, 0xd5, 0x07, 0x06, 0x21, 0x44,
+	0x2f, 0x07, 0x9b, 0x21,
+	0x5b, 0x01, 0x6e, 0x1c, 0x3d, 0x16, 0x44, 0x09, 0x04, 0x0b, 0xe2, 0x79,
+	0x39, 0x68, 0x3a, 0xfe,
+	0x0a, 0x55, 0x34, 0xfe, 0x8b, 0x55, 0xbe, 0x39, 0xbf, 0x3a, 0xfe, 0x0c,
+	0x51, 0xfe, 0x8e, 0x51,
+	0x02, 0x5b, 0xfe, 0x19, 0x81, 0xaf, 0xfe, 0x19, 0x41, 0x02, 0x5b, 0x2b,
+	0x01, 0x08, 0x25, 0x32,
+	0x1f, 0xa2, 0x30, 0x2e, 0xd8, 0x4b, 0x1a, 0xfe, 0xa6, 0x12, 0x4b, 0x0b,
+	0x3b, 0x02, 0x44, 0x01,
+	0x08, 0x25, 0x32, 0x1f, 0xa2, 0x30, 0x2e, 0xd6, 0x07, 0x1a, 0x21, 0x44,
+	0x01, 0x08, 0x1f, 0xa2,
+	0x30, 0x2e, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49, 0x60, 0x05, 0xfe, 0x9c,
+	0x00, 0x28, 0x84, 0x49,
+	0x04, 0x19, 0x34, 0x9f, 0xfe, 0xbb, 0x45, 0x4b, 0x00, 0x45, 0x3e, 0x06,
+	0x78, 0x3d, 0xfe, 0xda,
+	0x14, 0x01, 0x6e, 0x87, 0xfe, 0x4b, 0x45, 0xe2, 0x2f, 0x07, 0x9a, 0xe1,
+	0x05, 0xc6, 0x28, 0x84,
+	0x05, 0x3f, 0x28, 0x34, 0x5e, 0x02, 0x5b, 0xfe, 0xc0, 0x5d, 0xfe, 0xf8,
+	0x14, 0xfe, 0x03, 0x17,
+	0x05, 0x50, 0xb4, 0x0c, 0x50, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01,
+	0xfe, 0xaa, 0x14, 0x02,
+	0x5c, 0x01, 0x08, 0x25, 0x32, 0x1f, 0x44, 0x30, 0x2e, 0xd6, 0x07, 0x06,
+	0x21, 0x44, 0x01, 0xfe,
+	0x8e, 0x13, 0xfe, 0x42, 0x58, 0xfe, 0x82, 0x14, 0xfe, 0xa4, 0x14, 0x87,
+	0xfe, 0x4a, 0xf4, 0x0b,
+	0x16, 0x44, 0xfe, 0x4a, 0xf4, 0x06, 0xfe, 0x0c, 0x12, 0x2f, 0x07, 0x9a,
+	0x85, 0x02, 0x5b, 0x05,
+	0x3f, 0xb4, 0x0c, 0x3f, 0x5e, 0x2b, 0x01, 0x08, 0x26, 0x5c, 0x01, 0xfe,
+	0xd8, 0x14, 0x02, 0x5c,
+	0x13, 0x06, 0x65, 0xfe, 0xca, 0x12, 0x26, 0xfe, 0xe0, 0x12, 0x72, 0xf1,
+	0x01, 0x08, 0x23, 0x72,
+	0x03, 0x8f, 0xfe, 0xdc, 0x12, 0x25, 0xfe, 0xdc, 0x12, 0x1f, 0xfe, 0xca,
+	0x12, 0x5e, 0x2b, 0x01,
+	0x08, 0xfe, 0xd5, 0x10, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b,
+	0x1c, 0xfe, 0xff, 0x7f,
+	0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x03, 0x13, 0x6c, 0xff, 0x02, 0x00,
+	0x57, 0x48, 0x8b, 0x1c,
+	0x3d, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x03, 0x13, 0x6c, 0xff, 0x02,
+	0x00, 0x57, 0x48, 0x8b,
+	0x03, 0x13, 0x6c, 0xff, 0x02, 0x00, 0x57, 0x48, 0x8b, 0xfe, 0x0b, 0x58,
+	0x03, 0x0a, 0x50, 0x01,
+	0x82, 0x0a, 0x3f, 0x01, 0x82, 0x03, 0xfc, 0x1c, 0x10, 0xff, 0x03, 0x00,
+	0x54, 0xfe, 0x00, 0xf4,
+	0x19, 0x48, 0xfe, 0x00, 0x7d, 0xfe, 0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe,
+	0x03, 0x7c, 0x63, 0x27,
+	0x0c, 0x52, 0x18, 0x53, 0xbe, 0x56, 0xbf, 0x57, 0x03, 0xfe, 0x62, 0x08,
+	0xfe, 0x82, 0x4a, 0xfe,
+	0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x74, 0x03, 0x01, 0xfe, 0x14, 0x18, 0xfe,
+	0x42, 0x48, 0x5f, 0x60,
+	0x89, 0x01, 0x08, 0x1f, 0xfe, 0xa2, 0x14, 0x30, 0x2e, 0xd8, 0x01, 0x08,
+	0x1f, 0xfe, 0xa2, 0x14,
+	0x30, 0x2e, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59, 0x05, 0xc6, 0x28, 0xfe,
+	0xcc, 0x12, 0x49, 0x04,
+	0x1b, 0xfe, 0xc4, 0x13, 0x23, 0x62, 0x1b, 0xe2, 0x4b, 0xc3, 0x64, 0xfe,
+	0xe8, 0x13, 0x3b, 0x13,
+	0x06, 0x17, 0xc3, 0x78, 0xdb, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55,
+	0xa1, 0xff, 0x02, 0x83,
+	0x55, 0x62, 0x1a, 0xa4, 0xbb, 0xfe, 0x30, 0x00, 0x8e, 0xe4, 0x17, 0x2c,
+	0x13, 0x06, 0xfe, 0x56,
+	0x10, 0x62, 0x0b, 0xe1, 0xbb, 0xfe, 0x64, 0x00, 0x8e, 0xe4, 0x0a, 0xfe,
+	0x64, 0x00, 0x17, 0x93,
+	0x13, 0x06, 0xfe, 0x28, 0x10, 0x62, 0x06, 0xfe, 0x60, 0x13, 0xbb, 0xfe,
+	0xc8, 0x00, 0x8e, 0xe4,
+	0x0a, 0xfe, 0xc8, 0x00, 0x17, 0x4d, 0x13, 0x06, 0x83, 0xbb, 0xfe, 0x90,
+	0x01, 0xba, 0xfe, 0x4e,
+	0x14, 0x89, 0xfe, 0x12, 0x10, 0xfe, 0x43, 0xf4, 0x94, 0xfe, 0x56, 0xf0,
+	0xfe, 0x60, 0x14, 0xfe,
+	0x04, 0xf4, 0x6c, 0xfe, 0x43, 0xf4, 0x93, 0xfe, 0xf3, 0x10, 0xf9, 0x01,
+	0xfe, 0x22, 0x13, 0x1c,
+	0x3d, 0xfe, 0x10, 0x13, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x69, 0xba,
+	0xfe, 0x9c, 0x14, 0xb7,
+	0x69, 0xfe, 0x1c, 0x10, 0xfe, 0x00, 0x17, 0xfe, 0x4d, 0xe4, 0x19, 0xba,
+	0xfe, 0x9c, 0x14, 0xb7,
+	0x19, 0x83, 0x60, 0x23, 0xfe, 0x4d, 0xf4, 0x00, 0xdf, 0x89, 0x13, 0x06,
+	0xfe, 0xb4, 0x56, 0xfe,
+	0xc3, 0x58, 0x03, 0x60, 0x13, 0x0b, 0x03, 0x15, 0x06, 0x01, 0x08, 0x26,
+	0xe5, 0x15, 0x0b, 0x01,
+	0x08, 0x26, 0xe5, 0x15, 0x1a, 0x01, 0x08, 0x26, 0xe5, 0x72, 0xfe, 0x89,
+	0x49, 0x01, 0x08, 0x03,
+	0x15, 0x06, 0x01, 0x08, 0x26, 0xa6, 0x15, 0x1a, 0x01, 0x08, 0x26, 0xa6,
+	0x15, 0x06, 0x01, 0x08,
+	0x26, 0xa6, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x26, 0xa6, 0x72, 0xfe, 0x89,
+	0x4a, 0x01, 0x08, 0x03,
+	0x60, 0x03, 0x1e, 0xcc, 0x07, 0x06, 0xfe, 0x44, 0x13, 0xad, 0x12, 0xcc,
+	0xfe, 0x49, 0xf4, 0x00,
+	0x3b, 0x72, 0x9f, 0x5e, 0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xf1, 0x01,
+	0x08, 0x2f, 0x07, 0xfe,
+	0xe3, 0x00, 0xfe, 0x20, 0x13, 0x1f, 0xfe, 0x5a, 0x15, 0x23, 0x12, 0xcd,
+	0x01, 0x43, 0x1e, 0xcd,
+	0x07, 0x06, 0x45, 0x09, 0x4a, 0x06, 0x35, 0x03, 0x0a, 0x42, 0x01, 0x0e,
+	0xed, 0x88, 0x07, 0x10,
+	0xa4, 0x0a, 0x80, 0x01, 0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03, 0x0a,
+	0x80, 0x01, 0x0e, 0x88,
+	0xfe, 0x80, 0xe7, 0x10, 0x07, 0x10, 0x84, 0xfe, 0x45, 0x58, 0x01, 0xe3,
+	0x88, 0x03, 0x0a, 0x42,
+	0x01, 0x0e, 0x88, 0x0a, 0x51, 0x01, 0x9e, 0x03, 0x0a, 0x42, 0x01, 0x0e,
+	0xfe, 0x80, 0x80, 0xf2,
+	0xfe, 0x49, 0xe4, 0x10, 0xa4, 0x0a, 0x80, 0x01, 0x0e, 0xf2, 0x0a, 0x51,
+	0x01, 0x82, 0x03, 0x17,
+	0x10, 0x71, 0x66, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde,
+	0xfe, 0x24, 0x1c, 0xfe,
+	0x1d, 0xf7, 0x1d, 0x90, 0xfe, 0xf6, 0x15, 0x01, 0xfe, 0xfc, 0x16, 0xe0,
+	0x91, 0x1d, 0x66, 0xfe,
+	0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x03, 0xae, 0x21, 0xfe, 0xe6, 0x15, 0xfe,
+	0xda, 0x10, 0x17, 0x10,
+	0x71, 0x05, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x19, 0xfe, 0x18, 0x58,
+	0x05, 0xfe, 0x66, 0x01,
+	0xfe, 0x19, 0x58, 0x91, 0x19, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4, 0x06,
+	0xfe, 0x3c, 0x50, 0x66,
+	0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x19, 0x90, 0xfe,
+	0x40, 0x16, 0xfe, 0xb6,
+	0x14, 0x34, 0x03, 0xae, 0x21, 0xfe, 0x18, 0x16, 0xfe, 0x9c, 0x10, 0x17,
+	0x10, 0x71, 0xfe, 0x83,
+	0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7, 0x38, 0x90,
+	0xfe, 0x62, 0x16, 0xfe,
+	0x94, 0x14, 0xfe, 0x10, 0x13, 0x91, 0x38, 0x66, 0x1b, 0xfe, 0xaf, 0x19,
+	0xfe, 0x98, 0xe7, 0x00,
+	0x03, 0xae, 0x21, 0xfe, 0x56, 0x16, 0xfe, 0x6c, 0x10, 0x17, 0x10, 0x71,
+	0xfe, 0x30, 0xbc, 0xfe,
+	0xb2, 0xbc, 0x91, 0xc5, 0x66, 0x1b, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7,
+	0xc5, 0x90, 0xfe, 0x9a,
+	0x16, 0xfe, 0x5c, 0x14, 0x34, 0x03, 0xae, 0x21, 0xfe, 0x86, 0x16, 0xfe,
+	0x42, 0x10, 0xfe, 0x02,
+	0xf6, 0x10, 0x71, 0xfe, 0x18, 0xfe, 0x54, 0xfe, 0x19, 0xfe, 0x55, 0xfc,
+	0xfe, 0x1d, 0xf7, 0x4f,
+	0x90, 0xfe, 0xc0, 0x16, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13, 0x91, 0x4f,
+	0x47, 0xfe, 0x83, 0x58,
+	0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7, 0x10, 0xfe, 0x81, 0xe7, 0x10, 0x11,
+	0xfe, 0xdd, 0x00, 0x63,
+	0x27, 0x03, 0x63, 0x27, 0xfe, 0x12, 0x45, 0x21, 0xfe, 0xb0, 0x16, 0x14,
+	0x06, 0x37, 0x95, 0xa9,
+	0x02, 0x29, 0xfe, 0x39, 0xf0, 0xfe, 0x04, 0x17, 0x23, 0x03, 0xfe, 0x7e,
+	0x18, 0x1c, 0x1a, 0x5d,
+	0x13, 0x0d, 0x03, 0x71, 0x05, 0xcb, 0x1c, 0x06, 0xfe, 0xef, 0x12, 0xfe,
+	0xe1, 0x10, 0x78, 0x2c,
+	0x46, 0x2f, 0x07, 0x2d, 0xfe, 0x3c, 0x13, 0xfe, 0x82, 0x14, 0xfe, 0x42,
+	0x13, 0x3c, 0x8a, 0x0a,
+	0x42, 0x01, 0x0e, 0xb0, 0xfe, 0x3e, 0x12, 0xf0, 0xfe, 0x45, 0x48, 0x01,
+	0xe3, 0xfe, 0x00, 0xcc,
+	0xb0, 0xfe, 0xf3, 0x13, 0x3d, 0x75, 0x07, 0x10, 0xa3, 0x0a, 0x80, 0x01,
+	0x0e, 0xf2, 0x01, 0x6f,
+	0xfe, 0x16, 0x10, 0x07, 0x7e, 0x85, 0xfe, 0x40, 0x14, 0xfe, 0x24, 0x12,
+	0xf6, 0xfe, 0xd6, 0xf0,
+	0xfe, 0x24, 0x17, 0x17, 0x0b, 0x03, 0xfe, 0x9c, 0xe7, 0x0b, 0x0f, 0xfe,
+	0x15, 0x00, 0x59, 0x76,
+	0x27, 0x01, 0xda, 0x17, 0x06, 0x03, 0x3c, 0x8a, 0x09, 0x4a, 0x1d, 0x35,
+	0x11, 0x2d, 0x01, 0x6f,
+	0x17, 0x06, 0x03, 0xfe, 0x38, 0x90, 0xfe, 0xba, 0x90, 0x79, 0xc7, 0x68,
+	0xc8, 0xfe, 0x48, 0x55,
+	0x34, 0xfe, 0xc9, 0x55, 0x03, 0x1e, 0x98, 0x73, 0x12, 0x98, 0x03, 0x0a,
+	0x99, 0x01, 0x0e, 0xf0,
+	0x0a, 0x40, 0x01, 0x0e, 0xfe, 0x49, 0x44, 0x16, 0xfe, 0xf0, 0x17, 0x73,
+	0x75, 0x03, 0x0a, 0x42,
+	0x01, 0x0e, 0x07, 0x10, 0x45, 0x0a, 0x51, 0x01, 0x9e, 0x0a, 0x40, 0x01,
+	0x0e, 0x73, 0x75, 0x03,
+	0xfe, 0x4e, 0xe4, 0x1a, 0x64, 0xfe, 0x24, 0x18, 0x05, 0xfe, 0x90, 0x00,
+	0xfe, 0x3a, 0x45, 0x5b,
+	0xfe, 0x4e, 0xe4, 0xc2, 0x64, 0xfe, 0x36, 0x18, 0x05, 0xfe, 0x92, 0x00,
+	0xfe, 0x02, 0xe6, 0x1b,
+	0xdc, 0xfe, 0x4e, 0xe4, 0xfe, 0x0b, 0x00, 0x64, 0xfe, 0x48, 0x18, 0x05,
+	0xfe, 0x94, 0x00, 0xfe,
+	0x02, 0xe6, 0x19, 0xfe, 0x08, 0x10, 0x05, 0xfe, 0x96, 0x00, 0xfe, 0x02,
+	0xe6, 0x2c, 0xfe, 0x4e,
+	0x45, 0xfe, 0x0c, 0x12, 0xaf, 0xff, 0x04, 0x68, 0x54, 0xde, 0x1c, 0x69,
+	0x03, 0x07, 0x7a, 0xfe,
+	0x5a, 0xf0, 0xfe, 0x74, 0x18, 0x24, 0xfe, 0x09, 0x00, 0xfe, 0x34, 0x10,
+	0x07, 0x1b, 0xfe, 0x5a,
+	0xf0, 0xfe, 0x82, 0x18, 0x24, 0xc3, 0xfe, 0x26, 0x10, 0x07, 0x1a, 0x5d,
+	0x24, 0x2c, 0xdc, 0x07,
+	0x0b, 0x5d, 0x24, 0x93, 0xfe, 0x0e, 0x10, 0x07, 0x06, 0x5d, 0x24, 0x4d,
+	0x9f, 0xad, 0x03, 0x14,
+	0xfe, 0x09, 0x00, 0x01, 0x33, 0xfe, 0x04, 0xfe, 0x7d, 0x05, 0x7f, 0xf9,
+	0x03, 0x25, 0xfe, 0xca,
+	0x18, 0xfe, 0x14, 0xf0, 0x08, 0x65, 0xfe, 0xc6, 0x18, 0x03, 0xff, 0x1a,
+	0x00, 0x00,
 };
 
-STATIC unsigned short _adv_asc3550_size =
-        sizeof(_adv_asc3550_buf); /* 0x13AD */
-STATIC ADV_DCNT _adv_asc3550_chksum =
-        0x04D52DDDUL; /* Expanded little-endian checksum. */
+static unsigned short _adv_asc3550_size = sizeof(_adv_asc3550_buf);	/* 0x13AD */
+static ADV_DCNT _adv_asc3550_chksum = 0x04D52DDDUL;	/* Expanded little-endian checksum. */
 
 /* Microcode buffer is kept after initialization for error recovery. */
-STATIC unsigned char _adv_asc38C0800_buf[] = {
-  0x00,  0x00,  0x00,  0xf2,  0x00,  0xf0,  0x00,  0xfc,  0x00,  0x16,  0x18,  0xe4,  0x01,  0x00,  0x48,  0xe4,
-  0x18,  0x80,  0x03,  0xf6,  0x02,  0x00,  0xce,  0x19,  0x00,  0xfa,  0xff,  0xff,  0x1c,  0x0f,  0x00,  0xf6,
-  0x9e,  0xe7,  0xff,  0x00,  0x82,  0xe7,  0x00,  0xea,  0x01,  0xfa,  0x01,  0xe6,  0x09,  0xe7,  0x55,  0xf0,
-  0x01,  0xf6,  0x03,  0x00,  0x04,  0x00,  0x10,  0x00,  0x1e,  0xf0,  0x85,  0xf0,  0x18,  0xf4,  0x08,  0x00,
-  0xbc,  0x00,  0x38,  0x54,  0x00,  0xec,  0xd5,  0xf0,  0x82,  0x0d,  0x00,  0xe6,  0x86,  0xf0,  0xb1,  0xf0,
-  0x98,  0x57,  0x01,  0xfc,  0xb4,  0x00,  0xd4,  0x01,  0x0c,  0x1c,  0x3e,  0x1c,  0x3c,  0x00,  0xbb,  0x00,
-  0x00,  0x10,  0xba,  0x19,  0x02,  0x80,  0x32,  0xf0,  0x7c,  0x0d,  0x02,  0x13,  0xba,  0x13,  0x18,  0x40,
-  0x00,  0x57,  0x01,  0xea,  0x02,  0xfc,  0x03,  0xfc,  0x3e,  0x00,  0x6c,  0x01,  0x6e,  0x01,  0x74,  0x01,
-  0x76,  0x01,  0xb9,  0x54,  0x3e,  0x57,  0x00,  0x80,  0x03,  0xe6,  0xb6,  0x00,  0xc0,  0x00,  0x01,  0x01,
-  0x3e,  0x01,  0x7a,  0x01,  0xca,  0x08,  0xce,  0x10,  0x16,  0x11,  0x04,  0x12,  0x08,  0x12,  0x02,  0x4a,
-  0xbb,  0x55,  0x3c,  0x56,  0x03,  0x58,  0x1b,  0x80,  0x30,  0xe4,  0x4b,  0xe4,  0x5d,  0xf0,  0x02,  0xfa,
-  0x20,  0x00,  0x32,  0x00,  0x40,  0x00,  0x80,  0x00,  0x24,  0x01,  0x3c,  0x01,  0x68,  0x01,  0x6a,  0x01,
-  0x70,  0x01,  0x72,  0x01,  0x78,  0x01,  0x7c,  0x01,  0x62,  0x0a,  0x86,  0x0d,  0x06,  0x13,  0x4c,  0x1c,
-  0x04,  0x80,  0x4a,  0xe4,  0x02,  0xee,  0x5b,  0xf0,  0x03,  0xf7,  0x0c,  0x00,  0x0f,  0x00,  0x47,  0x00,
-  0xbe,  0x00,  0x00,  0x01,  0x20,  0x11,  0x5c,  0x16,  0x32,  0x1c,  0x38,  0x1c,  0x4e,  0x1c,  0x10,  0x44,
-  0x00,  0x4c,  0x04,  0xea,  0x5c,  0xf0,  0xa7,  0xf0,  0x04,  0xf6,  0x03,  0xfa,  0x05,  0x00,  0x34,  0x00,
-  0x36,  0x00,  0x98,  0x00,  0xcc,  0x00,  0x20,  0x01,  0x4e,  0x01,  0x4a,  0x0b,  0x42,  0x0c,  0x12,  0x0f,
-  0x0c,  0x10,  0x22,  0x11,  0x0a,  0x12,  0x04,  0x13,  0x30,  0x1c,  0x02,  0x48,  0x00,  0x4e,  0x42,  0x54,
-  0x44,  0x55,  0xbd,  0x56,  0x06,  0x83,  0x00,  0xdc,  0x05,  0xf0,  0x09,  0xf0,  0x59,  0xf0,  0xb8,  0xf0,
-  0x4b,  0xf4,  0x06,  0xf7,  0x0e,  0xf7,  0x04,  0xfc,  0x05,  0xfc,  0x06,  0x00,  0x19,  0x00,  0x33,  0x00,
-  0x9b,  0x00,  0xa4,  0x00,  0xb5,  0x00,  0xba,  0x00,  0xd0,  0x00,  0xe1,  0x00,  0xe7,  0x00,  0xe2,  0x03,
-  0x08,  0x0f,  0x02,  0x10,  0x04,  0x10,  0x0a,  0x10,  0x0a,  0x13,  0x0c,  0x13,  0x12,  0x13,  0x24,  0x14,
-  0x34,  0x14,  0x04,  0x16,  0x08,  0x16,  0xa4,  0x17,  0x20,  0x1c,  0x34,  0x1c,  0x36,  0x1c,  0x08,  0x44,
-  0x38,  0x44,  0x91,  0x44,  0x0a,  0x45,  0x48,  0x46,  0x01,  0x48,  0x68,  0x54,  0x3a,  0x55,  0x83,  0x55,
-  0xe5,  0x55,  0xb0,  0x57,  0x01,  0x58,  0x83,  0x59,  0x05,  0xe6,  0x0b,  0xf0,  0x0c,  0xf0,  0x04,  0xf8,
-  0x05,  0xf8,  0x07,  0x00,  0x0a,  0x00,  0x1c,  0x00,  0x1e,  0x00,  0x9e,  0x00,  0xa8,  0x00,  0xaa,  0x00,
-  0xb9,  0x00,  0xe0,  0x00,  0x22,  0x01,  0x26,  0x01,  0x79,  0x01,  0x7e,  0x01,  0xc4,  0x01,  0xc6,  0x01,
-  0x80,  0x02,  0x5e,  0x03,  0xee,  0x04,  0x9a,  0x06,  0xf8,  0x07,  0x62,  0x08,  0x68,  0x08,  0x69,  0x08,
-  0xd6,  0x08,  0xe9,  0x09,  0xfa,  0x0b,  0x2e,  0x0f,  0x12,  0x10,  0x1a,  0x10,  0xed,  0x10,  0xf1,  0x10,
-  0x2a,  0x11,  0x06,  0x12,  0x0c,  0x12,  0x3e,  0x12,  0x10,  0x13,  0x16,  0x13,  0x1e,  0x13,  0x46,  0x14,
-  0x76,  0x14,  0x82,  0x14,  0x36,  0x15,  0xca,  0x15,  0x6b,  0x18,  0xbe,  0x18,  0xca,  0x18,  0xe6,  0x19,
-  0x12,  0x1c,  0x46,  0x1c,  0x9c,  0x32,  0x00,  0x40,  0x0e,  0x47,  0xfe,  0x9c,  0xf0,  0x2b,  0x02,  0xfe,
-  0xac,  0x0d,  0xff,  0x10,  0x00,  0x00,  0xd7,  0xfe,  0xe8,  0x19,  0x00,  0xd6,  0xfe,  0x84,  0x01,  0xff,
-  0x03,  0x00,  0x00,  0xfe,  0x93,  0x15,  0xfe,  0x0f,  0x05,  0xff,  0x38,  0x00,  0x00,  0xfe,  0x57,  0x24,
-  0x00,  0xfe,  0x4c,  0x00,  0x5b,  0xff,  0x04,  0x00,  0x00,  0x11,  0xff,  0x09,  0x00,  0x00,  0xff,  0x08,
-  0x01,  0x01,  0xff,  0x08,  0xff,  0xff,  0xff,  0x27,  0x00,  0x00,  0xff,  0x10,  0xff,  0xff,  0xff,  0x11,
-  0x00,  0x00,  0xfe,  0x78,  0x56,  0xfe,  0x34,  0x12,  0xff,  0x21,  0x00,  0x00,  0xfe,  0x04,  0xf7,  0xd6,
-  0x2c,  0x99,  0x0a,  0x01,  0xfe,  0xc2,  0x0f,  0xfe,  0x04,  0xf7,  0xd6,  0x99,  0x0a,  0x42,  0x2c,  0xfe,
-  0x3d,  0xf0,  0xfe,  0x06,  0x02,  0xfe,  0x20,  0xf0,  0xa7,  0xfe,  0x91,  0xf0,  0xfe,  0xf4,  0x01,  0xfe,
-  0x90,  0xf0,  0xfe,  0xf4,  0x01,  0xfe,  0x8f,  0xf0,  0xa7,  0x03,  0x5d,  0x4d,  0x02,  0xfe,  0xc8,  0x0d,
-  0x01,  0xfe,  0x38,  0x0e,  0xfe,  0xdd,  0x12,  0xfe,  0xfc,  0x10,  0xfe,  0x28,  0x1c,  0x03,  0xfe,  0xa6,
-  0x00,  0xfe,  0xd3,  0x12,  0x41,  0x14,  0xfe,  0xa6,  0x00,  0xc2,  0xfe,  0x48,  0xf0,  0xfe,  0x8a,  0x02,
-  0xfe,  0x49,  0xf0,  0xfe,  0xa4,  0x02,  0xfe,  0x4a,  0xf0,  0xfe,  0xc2,  0x02,  0xfe,  0x46,  0xf0,  0xfe,
-  0x54,  0x02,  0xfe,  0x47,  0xf0,  0xfe,  0x5a,  0x02,  0xfe,  0x43,  0xf0,  0xfe,  0x48,  0x02,  0xfe,  0x44,
-  0xf0,  0xfe,  0x4c,  0x02,  0xfe,  0x45,  0xf0,  0xfe,  0x50,  0x02,  0x18,  0x0a,  0xaa,  0x18,  0x06,  0x14,
-  0xa1,  0x02,  0x2b,  0xfe,  0x00,  0x1c,  0xe7,  0xfe,  0x02,  0x1c,  0xe6,  0xfe,  0x1e,  0x1c,  0xfe,  0xe9,
-  0x10,  0x01,  0xfe,  0x18,  0x18,  0xfe,  0xe7,  0x10,  0xfe,  0x06,  0xfc,  0xce,  0x09,  0x70,  0x01,  0xa8,
-  0x02,  0x2b,  0x15,  0x59,  0x39,  0xa2,  0x01,  0xfe,  0x58,  0x10,  0x09,  0x70,  0x01,  0x87,  0xfe,  0xbd,
-  0x10,  0x09,  0x70,  0x01,  0x87,  0xfe,  0xad,  0x10,  0xfe,  0x16,  0x1c,  0xfe,  0x58,  0x1c,  0x18,  0x06,
-  0x14,  0xa1,  0x2c,  0x1c,  0x2b,  0xfe,  0x3d,  0xf0,  0xfe,  0x06,  0x02,  0x23,  0xfe,  0x98,  0x02,  0xfe,
-  0x5a,  0x1c,  0xf8,  0xfe,  0x14,  0x1c,  0x15,  0xfe,  0x30,  0x00,  0x39,  0xa2,  0x01,  0xfe,  0x48,  0x10,
-  0x18,  0x06,  0x14,  0xa1,  0x02,  0xd7,  0x22,  0x20,  0x07,  0x11,  0x35,  0xfe,  0x69,  0x10,  0x18,  0x06,
-  0x14,  0xa1,  0xfe,  0x04,  0xec,  0x20,  0x4f,  0x43,  0x13,  0x20,  0xfe,  0x05,  0xf6,  0xce,  0x01,  0xfe,
-  0x4a,  0x17,  0x08,  0x54,  0x58,  0x37,  0x12,  0x2f,  0x42,  0x92,  0x01,  0xfe,  0x82,  0x16,  0x02,  0x2b,
-  0x09,  0x46,  0x01,  0x0e,  0x07,  0x00,  0x66,  0x01,  0x73,  0xfe,  0x18,  0x10,  0xfe,  0x41,  0x58,  0x09,
-  0xa4,  0x01,  0x0e,  0xfe,  0xc8,  0x54,  0x6b,  0xfe,  0x10,  0x03,  0x01,  0xfe,  0x82,  0x16,  0x02,  0x2b,
-  0x2c,  0x4f,  0xfe,  0x02,  0xe8,  0x2a,  0xfe,  0xbf,  0x57,  0xfe,  0x9e,  0x43,  0xfe,  0x77,  0x57,  0xfe,
-  0x27,  0xf0,  0xfe,  0xe0,  0x01,  0xfe,  0x07,  0x4b,  0xfe,  0x20,  0xf0,  0xa7,  0xfe,  0x40,  0x1c,  0x1c,
-  0xd9,  0xfe,  0x26,  0xf0,  0xfe,  0x5a,  0x03,  0xfe,  0xa0,  0xf0,  0xfe,  0x48,  0x03,  0xfe,  0x11,  0xf0,
-  0xa7,  0xfe,  0xef,  0x10,  0xfe,  0x9f,  0xf0,  0xfe,  0x68,  0x03,  0xf9,  0x10,  0xfe,  0x11,  0x00,  0x02,
-  0x65,  0x2c,  0xfe,  0x48,  0x1c,  0xf9,  0x08,  0x05,  0x1b,  0xfe,  0x18,  0x13,  0x21,  0x22,  0xa3,  0xb7,
-  0x13,  0xa3,  0x09,  0x46,  0x01,  0x0e,  0xb7,  0x78,  0x01,  0xfe,  0xb4,  0x16,  0x12,  0xd1,  0x1c,  0xd9,
-  0xfe,  0x01,  0xf0,  0xd9,  0xfe,  0x82,  0xf0,  0xfe,  0x96,  0x03,  0xfa,  0x12,  0xfe,  0xe4,  0x00,  0x27,
-  0xfe,  0xa8,  0x03,  0x1c,  0x34,  0x1d,  0xfe,  0xb8,  0x03,  0x01,  0x4b,  0xfe,  0x06,  0xf0,  0xfe,  0xc8,
-  0x03,  0x95,  0x86,  0xfe,  0x0a,  0xf0,  0xfe,  0x8a,  0x06,  0x02,  0x24,  0x03,  0x70,  0x28,  0x17,  0xfe,
-  0xfa,  0x04,  0x15,  0x6d,  0x01,  0x36,  0x7b,  0xfe,  0x6a,  0x02,  0x02,  0xd8,  0xf9,  0x2c,  0x99,  0x19,
-  0xfe,  0x67,  0x1b,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0xfe,  0x48,  0x1c,  0x74,  0x01,  0xaf,  0x8c,
-  0x09,  0x46,  0x01,  0x0e,  0x07,  0x00,  0x17,  0xda,  0x09,  0xd1,  0x01,  0x0e,  0x8d,  0x51,  0x64,  0x79,
-  0x2a,  0x03,  0x70,  0x28,  0xfe,  0x10,  0x12,  0x15,  0x6d,  0x01,  0x36,  0x7b,  0xfe,  0x6a,  0x02,  0x02,
-  0xd8,  0xc7,  0x81,  0xc8,  0x83,  0x1c,  0x24,  0x27,  0xfe,  0x40,  0x04,  0x1d,  0xfe,  0x3c,  0x04,  0x3b,
-  0xfe,  0xa0,  0x00,  0xfe,  0x9b,  0x57,  0xfe,  0x4e,  0x12,  0x2d,  0xff,  0x02,  0x00,  0x10,  0x01,  0x0b,
-  0x1d,  0xfe,  0xe4,  0x04,  0x2d,  0x01,  0x0b,  0x1d,  0x24,  0x33,  0x31,  0xde,  0xfe,  0x4c,  0x44,  0xfe,
-  0x4c,  0x12,  0x51,  0xfe,  0x44,  0x48,  0x0f,  0x6f,  0xfe,  0x4c,  0x54,  0x6b,  0xda,  0x4f,  0x79,  0x2a,
-  0xfe,  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x62,  0x13,  0x08,  0x05,  0x1b,  0xfe,  0x2a,  0x13,  0x32,
-  0x07,  0x82,  0xfe,  0x52,  0x13,  0xfe,  0x20,  0x10,  0x0f,  0x6f,  0xfe,  0x4c,  0x54,  0x6b,  0xda,  0xfe,
-  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x40,  0x13,  0x08,  0x05,  0x1b,  0xfe,  0x08,  0x13,  0x32,  0x07,
-  0x82,  0xfe,  0x30,  0x13,  0x08,  0x05,  0x1b,  0xfe,  0x1c,  0x12,  0x15,  0x9d,  0x08,  0x05,  0x06,  0x4d,
-  0x15,  0xfe,  0x0d,  0x00,  0x01,  0x36,  0x7b,  0xfe,  0x64,  0x0d,  0x02,  0x24,  0x2d,  0x12,  0xfe,  0xe6,
-  0x00,  0xfe,  0x1c,  0x90,  0xfe,  0x40,  0x5c,  0x04,  0x15,  0x9d,  0x01,  0x36,  0x02,  0x2b,  0xfe,  0x42,
-  0x5b,  0x99,  0x19,  0xfe,  0x46,  0x59,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0xfe,  0x87,  0x80,  0xfe,
-  0x31,  0xe4,  0x5b,  0x08,  0x05,  0x0a,  0xfe,  0x84,  0x13,  0xfe,  0x20,  0x80,  0x07,  0x19,  0xfe,  0x7c,
-  0x12,  0x53,  0x05,  0x06,  0xfe,  0x6c,  0x13,  0x03,  0xfe,  0xa2,  0x00,  0x28,  0x17,  0xfe,  0x90,  0x05,
-  0xfe,  0x31,  0xe4,  0x5a,  0x53,  0x05,  0x0a,  0xfe,  0x56,  0x13,  0x03,  0xfe,  0xa0,  0x00,  0x28,  0xfe,
-  0x4e,  0x12,  0x67,  0xff,  0x02,  0x00,  0x10,  0x27,  0xfe,  0x48,  0x05,  0x1c,  0x34,  0xfe,  0x89,  0x48,
-  0xff,  0x02,  0x00,  0x10,  0x27,  0xfe,  0x56,  0x05,  0x26,  0xfe,  0xa8,  0x05,  0x12,  0xfe,  0xe3,  0x00,
-  0x21,  0x53,  0xfe,  0x4a,  0xf0,  0xfe,  0x76,  0x05,  0xfe,  0x49,  0xf0,  0xfe,  0x70,  0x05,  0x88,  0x25,
-  0xfe,  0x21,  0x00,  0xab,  0x25,  0xfe,  0x22,  0x00,  0xaa,  0x25,  0x58,  0xfe,  0x09,  0x48,  0xff,  0x02,
-  0x00,  0x10,  0x27,  0xfe,  0x86,  0x05,  0x26,  0xfe,  0xa8,  0x05,  0xfe,  0xe2,  0x08,  0x53,  0x05,  0xcb,
-  0x4d,  0x01,  0xb0,  0x25,  0x06,  0x13,  0xd3,  0x39,  0xfe,  0x27,  0x01,  0x08,  0x05,  0x1b,  0xfe,  0x22,
-  0x12,  0x41,  0x01,  0xb2,  0x15,  0x9d,  0x08,  0x05,  0x06,  0x4d,  0x15,  0xfe,  0x0d,  0x00,  0x01,  0x36,
-  0x7b,  0xfe,  0x64,  0x0d,  0x02,  0x24,  0x03,  0xfe,  0x9c,  0x00,  0x28,  0xeb,  0x03,  0x5c,  0x28,  0xfe,
-  0x36,  0x13,  0x41,  0x01,  0xb2,  0x26,  0xfe,  0x18,  0x06,  0x09,  0x06,  0x53,  0x05,  0x1f,  0xfe,  0x02,
-  0x12,  0x50,  0x01,  0xfe,  0x9e,  0x15,  0x1d,  0xfe,  0x0e,  0x06,  0x12,  0xa5,  0x01,  0x4b,  0x12,  0xfe,
-  0xe5,  0x00,  0x03,  0x5c,  0xc1,  0x0c,  0x5c,  0x03,  0xcd,  0x28,  0xfe,  0x62,  0x12,  0x03,  0x45,  0x28,
-  0xfe,  0x5a,  0x13,  0x01,  0xfe,  0x0c,  0x19,  0x01,  0xfe,  0x76,  0x19,  0xfe,  0x43,  0x48,  0xc4,  0xcc,
-  0x0f,  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,  0x93,  0x1e,  0x43,  0x8b,  0xc4,  0x6e,  0x41,  0x01,  0xb2,
-  0x26,  0xfe,  0x82,  0x06,  0x53,  0x05,  0x1a,  0xe9,  0x91,  0x09,  0x59,  0x01,  0xfe,  0xcc,  0x15,  0x1d,
-  0xfe,  0x78,  0x06,  0x12,  0xa5,  0x01,  0x4b,  0x12,  0xfe,  0xe5,  0x00,  0x03,  0x45,  0xc1,  0x0c,  0x45,
-  0x18,  0x06,  0x01,  0xb2,  0xfa,  0x76,  0x74,  0x01,  0xaf,  0x8c,  0x12,  0xfe,  0xe2,  0x00,  0x27,  0xdb,
-  0x1c,  0x34,  0xfe,  0x0a,  0xf0,  0xfe,  0xb6,  0x06,  0x94,  0xfe,  0x6c,  0x07,  0xfe,  0x06,  0xf0,  0xfe,
-  0x74,  0x07,  0x95,  0x86,  0x02,  0x24,  0x08,  0x05,  0x0a,  0xfe,  0x2e,  0x12,  0x16,  0x19,  0x01,  0x0b,
-  0x16,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,  0x0b,  0xfe,  0x99,  0xa4,  0x01,
-  0x0b,  0x16,  0x00,  0x02,  0xfe,  0x42,  0x08,  0x68,  0x05,  0x1a,  0xfe,  0x38,  0x12,  0x08,  0x05,  0x1a,
-  0xfe,  0x30,  0x13,  0x16,  0xfe,  0x1b,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,
-  0x0b,  0x16,  0x00,  0x01,  0x0b,  0x16,  0x06,  0x01,  0x0b,  0x16,  0x00,  0x02,  0xe2,  0x6c,  0x58,  0xbe,
-  0x50,  0xfe,  0x9a,  0x81,  0x55,  0x1b,  0x7a,  0xfe,  0x42,  0x07,  0x09,  0x1b,  0xfe,  0x09,  0x6f,  0xba,
-  0xfe,  0xca,  0x45,  0xfe,  0x32,  0x12,  0x69,  0x6d,  0x8b,  0x6c,  0x7f,  0x27,  0xfe,  0x54,  0x07,  0x1c,
-  0x34,  0xfe,  0x0a,  0xf0,  0xfe,  0x42,  0x07,  0x95,  0x86,  0x94,  0xfe,  0x6c,  0x07,  0x02,  0x24,  0x01,
-  0x4b,  0x02,  0xdb,  0x16,  0x1f,  0x02,  0xdb,  0xfe,  0x9c,  0xf7,  0xdc,  0xfe,  0x2c,  0x90,  0xfe,  0xae,
-  0x90,  0x56,  0xfe,  0xda,  0x07,  0x0c,  0x60,  0x14,  0x61,  0x08,  0x54,  0x5a,  0x37,  0x22,  0x20,  0x07,
-  0x11,  0xfe,  0x0e,  0x12,  0x8d,  0xfe,  0x80,  0x80,  0x39,  0x20,  0x6a,  0x2a,  0xfe,  0x06,  0x10,  0xfe,
-  0x83,  0xe7,  0xfe,  0x48,  0x00,  0xab,  0xfe,  0x03,  0x40,  0x08,  0x54,  0x5b,  0x37,  0x01,  0xb3,  0xb8,
-  0xfe,  0x1f,  0x40,  0x13,  0x62,  0x01,  0xef,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0xfe,  0x44,  0x51,
-  0xfe,  0xc6,  0x51,  0x88,  0xfe,  0x08,  0x90,  0xfe,  0x8a,  0x90,  0x0c,  0x5e,  0x14,  0x5f,  0xfe,  0x0c,
-  0x90,  0xfe,  0x8e,  0x90,  0xfe,  0x40,  0x50,  0xfe,  0xc2,  0x50,  0x0c,  0x3d,  0x14,  0x3e,  0xfe,  0x4a,
-  0x10,  0x08,  0x05,  0x5a,  0xfe,  0x2a,  0x12,  0xfe,  0x2c,  0x90,  0xfe,  0xae,  0x90,  0x0c,  0x60,  0x14,
-  0x61,  0x08,  0x05,  0x5b,  0x8b,  0x01,  0xb3,  0xfe,  0x1f,  0x80,  0x13,  0x62,  0xfe,  0x44,  0x90,  0xfe,
-  0xc6,  0x90,  0x0c,  0x3f,  0x14,  0x40,  0xfe,  0x08,  0x90,  0xfe,  0x8a,  0x90,  0x0c,  0x5e,  0x14,  0x5f,
-  0xfe,  0x40,  0x90,  0xfe,  0xc2,  0x90,  0x0c,  0x3d,  0x14,  0x3e,  0x0c,  0x2e,  0x14,  0x3c,  0x21,  0x0c,
-  0x49,  0x0c,  0x63,  0x08,  0x54,  0x1f,  0x37,  0x2c,  0x0f,  0xfe,  0x4e,  0x11,  0x27,  0xdd,  0xfe,  0x9e,
-  0xf0,  0xfe,  0x76,  0x08,  0xbc,  0x17,  0x34,  0x2c,  0x77,  0xe6,  0xc5,  0xfe,  0x9a,  0x08,  0xc6,  0xfe,
-  0xb8,  0x08,  0x94,  0xfe,  0x8e,  0x08,  0xfe,  0x06,  0xf0,  0xfe,  0x94,  0x08,  0x95,  0x86,  0x02,  0x24,
-  0x01,  0x4b,  0xfe,  0xc9,  0x10,  0x16,  0x1f,  0xfe,  0xc9,  0x10,  0x68,  0x05,  0x06,  0xfe,  0x10,  0x12,
-  0x68,  0x05,  0x0a,  0x4e,  0x08,  0x05,  0x0a,  0xfe,  0x90,  0x12,  0xfe,  0x2e,  0x1c,  0x02,  0xfe,  0x18,
-  0x0b,  0x68,  0x05,  0x06,  0x4e,  0x68,  0x05,  0x0a,  0xfe,  0x7a,  0x12,  0xfe,  0x2c,  0x1c,  0xfe,  0xaa,
-  0xf0,  0xfe,  0xd2,  0x09,  0xfe,  0xac,  0xf0,  0xfe,  0x00,  0x09,  0x02,  0xfe,  0xde,  0x09,  0xfe,  0xb7,
-  0xf0,  0xfe,  0xfc,  0x08,  0xfe,  0x02,  0xf6,  0x1a,  0x50,  0xfe,  0x70,  0x18,  0xfe,  0xf1,  0x18,  0xfe,
-  0x40,  0x55,  0xfe,  0xe1,  0x55,  0xfe,  0x10,  0x58,  0xfe,  0x91,  0x58,  0xfe,  0x14,  0x59,  0xfe,  0x95,
-  0x59,  0x1c,  0x85,  0xfe,  0x8c,  0xf0,  0xfe,  0xfc,  0x08,  0xfe,  0xac,  0xf0,  0xfe,  0xf0,  0x08,  0xb5,
-  0xfe,  0xcb,  0x10,  0xfe,  0xad,  0xf0,  0xfe,  0x0c,  0x09,  0x02,  0xfe,  0x18,  0x0b,  0xb6,  0xfe,  0xbf,
-  0x10,  0xfe,  0x2b,  0xf0,  0x85,  0xf4,  0x1e,  0xfe,  0x00,  0xfe,  0xfe,  0x1c,  0x12,  0xc2,  0xfe,  0xd2,
-  0xf0,  0x85,  0xfe,  0x76,  0x18,  0x1e,  0x19,  0x17,  0x85,  0x03,  0xd2,  0x1e,  0x06,  0x17,  0x85,  0xc5,
-  0x4a,  0xc6,  0x4a,  0xb5,  0xb6,  0xfe,  0x89,  0x10,  0x74,  0x67,  0x2d,  0x15,  0x9d,  0x01,  0x36,  0x10,
-  0xfe,  0x35,  0x00,  0xfe,  0x01,  0xf0,  0x65,  0x10,  0x80,  0x02,  0x65,  0xfe,  0x98,  0x80,  0xfe,  0x19,
-  0xe4,  0x0a,  0xfe,  0x1a,  0x12,  0x51,  0xfe,  0x19,  0x82,  0xfe,  0x6c,  0x18,  0xfe,  0x44,  0x54,  0xbe,
-  0xfe,  0x19,  0x81,  0xfe,  0x74,  0x18,  0x8f,  0x90,  0x17,  0xfe,  0xce,  0x08,  0x02,  0x4a,  0x08,  0x05,
-  0x5a,  0xec,  0x03,  0x2e,  0x29,  0x3c,  0x0c,  0x3f,  0x14,  0x40,  0x9b,  0x2e,  0x9c,  0x3c,  0xfe,  0x6c,
-  0x18,  0xfe,  0xed,  0x18,  0xfe,  0x44,  0x54,  0xfe,  0xe5,  0x54,  0x3a,  0x3f,  0x3b,  0x40,  0x03,  0x49,
-  0x29,  0x63,  0x8f,  0xfe,  0xe3,  0x54,  0xfe,  0x74,  0x18,  0xfe,  0xf5,  0x18,  0x8f,  0xfe,  0xe3,  0x54,
-  0x90,  0xc0,  0x56,  0xfe,  0xce,  0x08,  0x02,  0x4a,  0xfe,  0x37,  0xf0,  0xfe,  0xda,  0x09,  0xfe,  0x8b,
-  0xf0,  0xfe,  0x60,  0x09,  0x02,  0x4a,  0x08,  0x05,  0x0a,  0x23,  0xfe,  0xfa,  0x0a,  0x3a,  0x49,  0x3b,
-  0x63,  0x56,  0xfe,  0x3e,  0x0a,  0x0f,  0xfe,  0xc0,  0x07,  0x41,  0x98,  0x00,  0xad,  0xfe,  0x01,  0x59,
-  0xfe,  0x52,  0xf0,  0xfe,  0x0c,  0x0a,  0x8f,  0x7a,  0xfe,  0x24,  0x0a,  0x3a,  0x49,  0x8f,  0xfe,  0xe3,
-  0x54,  0x57,  0x49,  0x7d,  0x63,  0xfe,  0x14,  0x58,  0xfe,  0x95,  0x58,  0x02,  0x4a,  0x3a,  0x49,  0x3b,
-  0x63,  0xfe,  0x14,  0x59,  0xfe,  0x95,  0x59,  0xbe,  0x57,  0x49,  0x57,  0x63,  0x02,  0x4a,  0x08,  0x05,
-  0x5a,  0xfe,  0x82,  0x12,  0x08,  0x05,  0x1f,  0xfe,  0x66,  0x13,  0x22,  0x62,  0xb7,  0xfe,  0x03,  0xa1,
-  0xfe,  0x83,  0x80,  0xfe,  0xc8,  0x44,  0xfe,  0x2e,  0x13,  0xfe,  0x04,  0x91,  0xfe,  0x86,  0x91,  0x6a,
-  0x2a,  0xfe,  0x40,  0x59,  0xfe,  0xc1,  0x59,  0x56,  0xe0,  0x03,  0x60,  0x29,  0x61,  0x0c,  0x7f,  0x14,
-  0x80,  0x57,  0x60,  0x7d,  0x61,  0x01,  0xb3,  0xb8,  0x6a,  0x2a,  0x13,  0x62,  0x9b,  0x2e,  0x9c,  0x3c,
-  0x3a,  0x3f,  0x3b,  0x40,  0x90,  0xc0,  0xfe,  0x04,  0xfa,  0x2e,  0xfe,  0x05,  0xfa,  0x3c,  0x01,  0xef,
-  0xfe,  0x36,  0x10,  0x21,  0x0c,  0x7f,  0x0c,  0x80,  0x3a,  0x3f,  0x3b,  0x40,  0xe4,  0x08,  0x05,  0x1f,
-  0x17,  0xe0,  0x3a,  0x3d,  0x3b,  0x3e,  0x08,  0x05,  0xfe,  0xf7,  0x00,  0x37,  0x03,  0x5e,  0x29,  0x5f,
-  0xfe,  0x10,  0x58,  0xfe,  0x91,  0x58,  0x57,  0x49,  0x7d,  0x63,  0x02,  0xfe,  0xf4,  0x09,  0x08,  0x05,
-  0x1f,  0x17,  0xe0,  0x08,  0x05,  0xfe,  0xf7,  0x00,  0x37,  0xbe,  0xfe,  0x19,  0x81,  0x50,  0xfe,  0x10,
-  0x90,  0xfe,  0x92,  0x90,  0xfe,  0xd3,  0x10,  0x32,  0x07,  0xa6,  0x17,  0xfe,  0x08,  0x09,  0x12,  0xa6,
-  0x08,  0x05,  0x0a,  0xfe,  0x14,  0x13,  0x03,  0x3d,  0x29,  0x3e,  0x56,  0xfe,  0x08,  0x09,  0xfe,  0x0c,
-  0x58,  0xfe,  0x8d,  0x58,  0x02,  0x4a,  0x21,  0x41,  0xfe,  0x19,  0x80,  0xe7,  0x08,  0x05,  0x0a,  0xfe,
-  0x1a,  0x12,  0xfe,  0x6c,  0x19,  0xfe,  0x19,  0x41,  0xf4,  0xc2,  0xfe,  0xd1,  0xf0,  0xe2,  0x15,  0x7e,
-  0x01,  0x36,  0x10,  0xfe,  0x44,  0x00,  0xfe,  0x8e,  0x10,  0xfe,  0x6c,  0x19,  0x57,  0x3d,  0xfe,  0xed,
-  0x19,  0x7d,  0x3e,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0xf4,  0x1e,  0xfe,  0x00,  0xff,  0x35,  0xfe,
-  0x74,  0x10,  0xc2,  0xfe,  0xd2,  0xf0,  0xfe,  0xa6,  0x0b,  0xfe,  0x76,  0x18,  0x1e,  0x19,  0x8a,  0x03,
-  0xd2,  0x1e,  0x06,  0xfe,  0x08,  0x13,  0x10,  0xfe,  0x16,  0x00,  0x02,  0x65,  0xfe,  0xd1,  0xf0,  0xfe,
-  0xb8,  0x0b,  0x15,  0x7e,  0x01,  0x36,  0x10,  0xfe,  0x17,  0x00,  0xfe,  0x42,  0x10,  0xfe,  0xce,  0xf0,
-  0xfe,  0xbe,  0x0b,  0xfe,  0x3c,  0x10,  0xfe,  0xcd,  0xf0,  0xfe,  0xca,  0x0b,  0x10,  0xfe,  0x22,  0x00,
-  0x02,  0x65,  0xfe,  0xcb,  0xf0,  0xfe,  0xd6,  0x0b,  0x10,  0xfe,  0x24,  0x00,  0x02,  0x65,  0xfe,  0xd0,
-  0xf0,  0xfe,  0xe0,  0x0b,  0x10,  0x9e,  0xe5,  0xfe,  0xcf,  0xf0,  0xfe,  0xea,  0x0b,  0x10,  0x58,  0xfe,
-  0x10,  0x10,  0xfe,  0xcc,  0xf0,  0xe2,  0x68,  0x05,  0x1f,  0x4d,  0x10,  0xfe,  0x12,  0x00,  0x2c,  0x0f,
-  0xfe,  0x4e,  0x11,  0x27,  0xfe,  0x00,  0x0c,  0xfe,  0x9e,  0xf0,  0xfe,  0x14,  0x0c,  0xbc,  0x17,  0x34,
-  0x2c,  0x77,  0xe6,  0xc5,  0x24,  0xc6,  0x24,  0x2c,  0xfa,  0x27,  0xfe,  0x20,  0x0c,  0x1c,  0x34,  0x94,
-  0xfe,  0x3c,  0x0c,  0x95,  0x86,  0xc5,  0xdc,  0xc6,  0xdc,  0x02,  0x24,  0x01,  0x4b,  0xfe,  0xdb,  0x10,
-  0x12,  0xfe,  0xe8,  0x00,  0xb5,  0xb6,  0x74,  0xc7,  0x81,  0xc8,  0x83,  0xfe,  0x89,  0xf0,  0x24,  0x33,
-  0x31,  0xe1,  0xc7,  0x81,  0xc8,  0x83,  0x27,  0xfe,  0x66,  0x0c,  0x1d,  0x24,  0x33,  0x31,  0xdf,  0xbc,
-  0x4e,  0x10,  0xfe,  0x42,  0x00,  0x02,  0x65,  0x7c,  0x06,  0xfe,  0x81,  0x49,  0x17,  0xfe,  0x2c,  0x0d,
-  0x08,  0x05,  0x0a,  0xfe,  0x44,  0x13,  0x10,  0x00,  0x55,  0x0a,  0xfe,  0x54,  0x12,  0x55,  0xfe,  0x28,
-  0x00,  0x23,  0xfe,  0x9a,  0x0d,  0x09,  0x46,  0x01,  0x0e,  0x07,  0x00,  0x66,  0x44,  0xfe,  0x28,  0x00,
-  0xfe,  0xe2,  0x10,  0x01,  0xf5,  0x01,  0xf6,  0x09,  0xa4,  0x01,  0xfe,  0x26,  0x0f,  0x64,  0x12,  0x2f,
-  0x01,  0x73,  0x02,  0x2b,  0x10,  0xfe,  0x44,  0x00,  0x55,  0x0a,  0xe9,  0x44,  0x0a,  0xfe,  0xb4,  0x10,
-  0x01,  0xb0,  0x44,  0x0a,  0xfe,  0xaa,  0x10,  0x01,  0xb0,  0xfe,  0x19,  0x82,  0xfe,  0x34,  0x46,  0xac,
-  0x44,  0x0a,  0x10,  0xfe,  0x43,  0x00,  0xfe,  0x96,  0x10,  0x08,  0x54,  0x0a,  0x37,  0x01,  0xf5,  0x01,
-  0xf6,  0x64,  0x12,  0x2f,  0x01,  0x73,  0x99,  0x0a,  0x64,  0x42,  0x92,  0x02,  0xfe,  0x2e,  0x03,  0x08,
-  0x05,  0x0a,  0x8a,  0x44,  0x0a,  0x10,  0x00,  0xfe,  0x5c,  0x10,  0x68,  0x05,  0x1a,  0xfe,  0x58,  0x12,
-  0x08,  0x05,  0x1a,  0xfe,  0x50,  0x13,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x50,  0x0d,  0xfe,
-  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x56,  0x0d,  0x08,  0x54,  0x1a,  0x37,  0xfe,  0xa9,  0x10,  0x10,
-  0xfe,  0x15,  0x00,  0xfe,  0x04,  0xe6,  0x0a,  0x50,  0xfe,  0x2e,  0x10,  0x10,  0xfe,  0x13,  0x00,  0xfe,
-  0x10,  0x10,  0x10,  0x6f,  0xab,  0x10,  0xfe,  0x41,  0x00,  0xaa,  0x10,  0xfe,  0x24,  0x00,  0x8c,  0xb5,
-  0xb6,  0x74,  0x03,  0x70,  0x28,  0x23,  0xd8,  0x50,  0xfe,  0x04,  0xe6,  0x1a,  0xfe,  0x9d,  0x41,  0xfe,
-  0x1c,  0x42,  0x64,  0x01,  0xe3,  0x02,  0x2b,  0xf8,  0x15,  0x0a,  0x39,  0xa0,  0xb4,  0x15,  0xfe,  0x31,
-  0x00,  0x39,  0xa2,  0x01,  0xfe,  0x48,  0x10,  0x02,  0xd7,  0x42,  0xfe,  0x06,  0xec,  0xd0,  0xfc,  0x44,
-  0x1b,  0xfe,  0xce,  0x45,  0x35,  0x42,  0xfe,  0x06,  0xea,  0xd0,  0xfe,  0x47,  0x4b,  0x91,  0xfe,  0x75,
-  0x57,  0x03,  0x5d,  0xfe,  0x98,  0x56,  0xfe,  0x38,  0x12,  0x09,  0x48,  0x01,  0x0e,  0xfe,  0x44,  0x48,
-  0x4f,  0x08,  0x05,  0x1b,  0xfe,  0x1a,  0x13,  0x09,  0x46,  0x01,  0x0e,  0x41,  0xfe,  0x41,  0x58,  0x09,
-  0xa4,  0x01,  0x0e,  0xfe,  0x49,  0x54,  0x96,  0xfe,  0x1e,  0x0e,  0x02,  0xfe,  0x2e,  0x03,  0x09,  0x5d,
-  0xfe,  0xee,  0x14,  0xfc,  0x44,  0x1b,  0xfe,  0xce,  0x45,  0x35,  0x42,  0xfe,  0xce,  0x47,  0xfe,  0xad,
-  0x13,  0x02,  0x2b,  0x22,  0x20,  0x07,  0x11,  0xfe,  0x9e,  0x12,  0x21,  0x13,  0x59,  0x13,  0x9f,  0x13,
-  0xd5,  0x22,  0x2f,  0x41,  0x39,  0x2f,  0xbc,  0xad,  0xfe,  0xbc,  0xf0,  0xfe,  0xe0,  0x0e,  0x0f,  0x06,
-  0x13,  0x59,  0x01,  0xfe,  0xda,  0x16,  0x03,  0xfe,  0x38,  0x01,  0x29,  0xfe,  0x3a,  0x01,  0x56,  0xfe,
-  0xe4,  0x0e,  0xfe,  0x02,  0xec,  0xd5,  0x69,  0x00,  0x66,  0xfe,  0x04,  0xec,  0x20,  0x4f,  0xfe,  0x05,
-  0xf6,  0xfe,  0x34,  0x01,  0x01,  0xfe,  0x4a,  0x17,  0xfe,  0x08,  0x90,  0xfe,  0x48,  0xf4,  0x0d,  0xfe,
-  0x18,  0x13,  0xba,  0xfe,  0x02,  0xea,  0xd5,  0x69,  0x7e,  0xfe,  0xc5,  0x13,  0x15,  0x1a,  0x39,  0xa0,
-  0xb4,  0xfe,  0x2e,  0x10,  0x03,  0xfe,  0x38,  0x01,  0x1e,  0xfe,  0xf0,  0xff,  0x0c,  0xfe,  0x60,  0x01,
-  0x03,  0xfe,  0x3a,  0x01,  0x0c,  0xfe,  0x62,  0x01,  0x43,  0x13,  0x20,  0x25,  0x06,  0x13,  0x2f,  0x12,
-  0x2f,  0x92,  0x0f,  0x06,  0x04,  0x21,  0x04,  0x22,  0x59,  0xfe,  0xf7,  0x12,  0x22,  0x9f,  0xb7,  0x13,
-  0x9f,  0x07,  0x7e,  0xfe,  0x71,  0x13,  0xfe,  0x24,  0x1c,  0x15,  0x19,  0x39,  0xa0,  0xb4,  0xfe,  0xd9,
-  0x10,  0xc3,  0xfe,  0x03,  0xdc,  0xfe,  0x73,  0x57,  0xfe,  0x80,  0x5d,  0x04,  0xc3,  0xfe,  0x03,  0xdc,
-  0xfe,  0x5b,  0x57,  0xfe,  0x80,  0x5d,  0x04,  0xfe,  0x03,  0x57,  0xc3,  0x21,  0xfe,  0x00,  0xcc,  0x04,
-  0xfe,  0x03,  0x57,  0xc3,  0x78,  0x04,  0x08,  0x05,  0x58,  0xfe,  0x22,  0x13,  0xfe,  0x1c,  0x80,  0x07,
-  0x06,  0xfe,  0x1a,  0x13,  0xfe,  0x1e,  0x80,  0xed,  0xfe,  0x1d,  0x80,  0xae,  0xfe,  0x0c,  0x90,  0xfe,
-  0x0e,  0x13,  0xfe,  0x0e,  0x90,  0xac,  0xfe,  0x3c,  0x90,  0xfe,  0x30,  0xf4,  0x0a,  0xfe,  0x3c,  0x50,
-  0xaa,  0x01,  0xfe,  0x7a,  0x17,  0x32,  0x07,  0x2f,  0xad,  0x01,  0xfe,  0xb4,  0x16,  0x08,  0x05,  0x1b,
-  0x4e,  0x01,  0xf5,  0x01,  0xf6,  0x12,  0xfe,  0xe9,  0x00,  0x08,  0x05,  0x58,  0xfe,  0x2c,  0x13,  0x01,
-  0xfe,  0x0c,  0x17,  0xfe,  0x1e,  0x1c,  0xfe,  0x14,  0x90,  0xfe,  0x96,  0x90,  0x0c,  0xfe,  0x64,  0x01,
-  0x14,  0xfe,  0x66,  0x01,  0x08,  0x05,  0x5b,  0xfe,  0x12,  0x12,  0xfe,  0x03,  0x80,  0x8d,  0xfe,  0x01,
-  0xec,  0x20,  0xfe,  0x80,  0x40,  0x13,  0x20,  0x6a,  0x2a,  0x12,  0xcf,  0x64,  0x22,  0x20,  0xfb,  0x79,
-  0x20,  0x04,  0xfe,  0x08,  0x1c,  0x03,  0xfe,  0xac,  0x00,  0xfe,  0x06,  0x58,  0x03,  0xfe,  0xae,  0x00,
-
-  0xfe,  0x07,  0x58,  0x03,  0xfe,  0xb0,  0x00,  0xfe,  0x08,  0x58,  0x03,  0xfe,  0xb2,  0x00,  0xfe,  0x09,
-  0x58,  0xfe,  0x0a,  0x1c,  0x25,  0x6e,  0x13,  0xd0,  0x21,  0x0c,  0x5c,  0x0c,  0x45,  0x0f,  0x46,  0x52,
-  0x50,  0x18,  0x1b,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x23,  0xfe,  0xfc,  0x0f,  0x44,  0x11,  0x0f,
-  0x48,  0x52,  0x18,  0x58,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x23,  0xe4,  0x25,  0x11,  0x13,  0x20,
-  0x7c,  0x6f,  0x4f,  0x22,  0x20,  0xfb,  0x79,  0x20,  0x12,  0xcf,  0xfe,  0x14,  0x56,  0xfe,  0xd6,  0xf0,
-  0xfe,  0x26,  0x10,  0xf8,  0x74,  0xfe,  0x14,  0x1c,  0xfe,  0x10,  0x1c,  0xfe,  0x18,  0x1c,  0x04,  0x42,
-  0xfe,  0x0c,  0x14,  0xfc,  0xfe,  0x07,  0xe6,  0x1b,  0xfe,  0xce,  0x47,  0xfe,  0xf5,  0x13,  0x04,  0x01,
-  0xb0,  0x7c,  0x6f,  0x4f,  0xfe,  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x42,  0x13,  0x32,  0x07,  0x2f,
-  0xfe,  0x34,  0x13,  0x09,  0x48,  0x01,  0x0e,  0xbb,  0xfe,  0x36,  0x12,  0xfe,  0x41,  0x48,  0xfe,  0x45,
-  0x48,  0x01,  0xf0,  0xfe,  0x00,  0xcc,  0xbb,  0xfe,  0xf3,  0x13,  0x43,  0x78,  0x07,  0x11,  0xac,  0x09,
-  0x84,  0x01,  0x0e,  0xfe,  0x80,  0x5c,  0x01,  0x73,  0xfe,  0x0e,  0x10,  0x07,  0x82,  0x4e,  0xfe,  0x14,
-  0x56,  0xfe,  0xd6,  0xf0,  0xfe,  0x60,  0x10,  0x04,  0xfe,  0x44,  0x58,  0x8d,  0xfe,  0x01,  0xec,  0xa2,
-  0xfe,  0x9e,  0x40,  0xfe,  0x9d,  0xe7,  0x00,  0xfe,  0x9c,  0xe7,  0x1a,  0x79,  0x2a,  0x01,  0xe3,  0xfe,
-  0xdd,  0x10,  0x2c,  0xc7,  0x81,  0xc8,  0x83,  0x33,  0x31,  0xde,  0x07,  0x1a,  0xfe,  0x48,  0x12,  0x07,
-  0x0a,  0xfe,  0x56,  0x12,  0x07,  0x19,  0xfe,  0x30,  0x12,  0x07,  0xc9,  0x17,  0xfe,  0x32,  0x12,  0x07,
-  0xfe,  0x23,  0x00,  0x17,  0xeb,  0x07,  0x06,  0x17,  0xfe,  0x9c,  0x12,  0x07,  0x1f,  0xfe,  0x12,  0x12,
-  0x07,  0x00,  0x17,  0x24,  0x15,  0xc9,  0x01,  0x36,  0xa9,  0x2d,  0x01,  0x0b,  0x94,  0x4b,  0x04,  0x2d,
-  0xdd,  0x09,  0xd1,  0x01,  0xfe,  0x26,  0x0f,  0x12,  0x82,  0x02,  0x2b,  0x2d,  0x32,  0x07,  0xa6,  0xfe,
-  0xd9,  0x13,  0x3a,  0x3d,  0x3b,  0x3e,  0x56,  0xfe,  0xf0,  0x11,  0x08,  0x05,  0x5a,  0xfe,  0x72,  0x12,
-  0x9b,  0x2e,  0x9c,  0x3c,  0x90,  0xc0,  0x96,  0xfe,  0xba,  0x11,  0x22,  0x62,  0xfe,  0x26,  0x13,  0x03,
-  0x7f,  0x29,  0x80,  0x56,  0xfe,  0x76,  0x0d,  0x0c,  0x60,  0x14,  0x61,  0x21,  0x0c,  0x7f,  0x0c,  0x80,
-  0x01,  0xb3,  0x25,  0x6e,  0x77,  0x13,  0x62,  0x01,  0xef,  0x9b,  0x2e,  0x9c,  0x3c,  0xfe,  0x04,  0x55,
-  0xfe,  0xa5,  0x55,  0xfe,  0x04,  0xfa,  0x2e,  0xfe,  0x05,  0xfa,  0x3c,  0xfe,  0x91,  0x10,  0x03,  0x3f,
-  0x29,  0x40,  0xfe,  0x40,  0x56,  0xfe,  0xe1,  0x56,  0x0c,  0x3f,  0x14,  0x40,  0x88,  0x9b,  0x2e,  0x9c,
-  0x3c,  0x90,  0xc0,  0x03,  0x5e,  0x29,  0x5f,  0xfe,  0x00,  0x56,  0xfe,  0xa1,  0x56,  0x0c,  0x5e,  0x14,
-  0x5f,  0x08,  0x05,  0x5a,  0xfe,  0x1e,  0x12,  0x22,  0x62,  0xfe,  0x1f,  0x40,  0x03,  0x60,  0x29,  0x61,
-  0xfe,  0x2c,  0x50,  0xfe,  0xae,  0x50,  0x03,  0x3f,  0x29,  0x40,  0xfe,  0x44,  0x50,  0xfe,  0xc6,  0x50,
-  0x03,  0x5e,  0x29,  0x5f,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0x03,  0x3d,  0x29,  0x3e,  0xfe,  0x40,
-  0x50,  0xfe,  0xc2,  0x50,  0x02,  0x89,  0x25,  0x06,  0x13,  0xd4,  0x02,  0x72,  0x2d,  0x01,  0x0b,  0x1d,
-  0x4c,  0x33,  0x31,  0xde,  0x07,  0x06,  0x23,  0x4c,  0x32,  0x07,  0xa6,  0x23,  0x72,  0x01,  0xaf,  0x1e,
-  0x43,  0x17,  0x4c,  0x08,  0x05,  0x0a,  0xee,  0x3a,  0x3d,  0x3b,  0x3e,  0xfe,  0x0a,  0x55,  0x35,  0xfe,
-  0x8b,  0x55,  0x57,  0x3d,  0x7d,  0x3e,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0x02,  0x72,  0xfe,  0x19,
-  0x81,  0xba,  0xfe,  0x19,  0x41,  0x02,  0x72,  0x2d,  0x01,  0x0b,  0x1c,  0x34,  0x1d,  0xe8,  0x33,  0x31,
-  0xe1,  0x55,  0x19,  0xfe,  0xa6,  0x12,  0x55,  0x0a,  0x4d,  0x02,  0x4c,  0x01,  0x0b,  0x1c,  0x34,  0x1d,
-  0xe8,  0x33,  0x31,  0xdf,  0x07,  0x19,  0x23,  0x4c,  0x01,  0x0b,  0x1d,  0xe8,  0x33,  0x31,  0xfe,  0xe8,
-  0x09,  0xfe,  0xc2,  0x49,  0x51,  0x03,  0xfe,  0x9c,  0x00,  0x28,  0x8a,  0x53,  0x05,  0x1f,  0x35,  0xa9,
-  0xfe,  0xbb,  0x45,  0x55,  0x00,  0x4e,  0x44,  0x06,  0x7c,  0x43,  0xfe,  0xda,  0x14,  0x01,  0xaf,  0x8c,
-  0xfe,  0x4b,  0x45,  0xee,  0x32,  0x07,  0xa5,  0xed,  0x03,  0xcd,  0x28,  0x8a,  0x03,  0x45,  0x28,  0x35,
-  0x67,  0x02,  0x72,  0xfe,  0xc0,  0x5d,  0xfe,  0xf8,  0x14,  0xfe,  0x03,  0x17,  0x03,  0x5c,  0xc1,  0x0c,
-  0x5c,  0x67,  0x2d,  0x01,  0x0b,  0x26,  0x89,  0x01,  0xfe,  0x9e,  0x15,  0x02,  0x89,  0x01,  0x0b,  0x1c,
-  0x34,  0x1d,  0x4c,  0x33,  0x31,  0xdf,  0x07,  0x06,  0x23,  0x4c,  0x01,  0xf1,  0xfe,  0x42,  0x58,  0xf1,
-  0xfe,  0xa4,  0x14,  0x8c,  0xfe,  0x4a,  0xf4,  0x0a,  0x17,  0x4c,  0xfe,  0x4a,  0xf4,  0x06,  0xea,  0x32,
-  0x07,  0xa5,  0x8b,  0x02,  0x72,  0x03,  0x45,  0xc1,  0x0c,  0x45,  0x67,  0x2d,  0x01,  0x0b,  0x26,  0x89,
-  0x01,  0xfe,  0xcc,  0x15,  0x02,  0x89,  0x0f,  0x06,  0x27,  0xfe,  0xbe,  0x13,  0x26,  0xfe,  0xd4,  0x13,
-  0x76,  0xfe,  0x89,  0x48,  0x01,  0x0b,  0x21,  0x76,  0x04,  0x7b,  0xfe,  0xd0,  0x13,  0x1c,  0xfe,  0xd0,
-  0x13,  0x1d,  0xfe,  0xbe,  0x13,  0x67,  0x2d,  0x01,  0x0b,  0xfe,  0xd5,  0x10,  0x0f,  0x71,  0xff,  0x02,
-  0x00,  0x57,  0x52,  0x93,  0x1e,  0xfe,  0xff,  0x7f,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x04,  0x0f,
-  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,  0x93,  0x1e,  0x43,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x04,
-  0x0f,  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,  0x93,  0x04,  0x0f,  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,
-  0x93,  0xfe,  0x0b,  0x58,  0x04,  0x09,  0x5c,  0x01,  0x87,  0x09,  0x45,  0x01,  0x87,  0x04,  0xfe,  0x03,
-  0xa1,  0x1e,  0x11,  0xff,  0x03,  0x00,  0x54,  0xfe,  0x00,  0xf4,  0x1f,  0x52,  0xfe,  0x00,  0x7d,  0xfe,
-  0x01,  0x7d,  0xfe,  0x02,  0x7d,  0xfe,  0x03,  0x7c,  0x6a,  0x2a,  0x0c,  0x5e,  0x14,  0x5f,  0x57,  0x3f,
-  0x7d,  0x40,  0x04,  0xdd,  0xfe,  0x82,  0x4a,  0xfe,  0xe1,  0x1a,  0xfe,  0x83,  0x5a,  0x8d,  0x04,  0x01,
-  0xfe,  0x0c,  0x19,  0xfe,  0x42,  0x48,  0x50,  0x51,  0x91,  0x01,  0x0b,  0x1d,  0xfe,  0x96,  0x15,  0x33,
-  0x31,  0xe1,  0x01,  0x0b,  0x1d,  0xfe,  0x96,  0x15,  0x33,  0x31,  0xfe,  0xe8,  0x0a,  0xfe,  0xc1,  0x59,
-  0x03,  0xcd,  0x28,  0xfe,  0xcc,  0x12,  0x53,  0x05,  0x1a,  0xfe,  0xc4,  0x13,  0x21,  0x69,  0x1a,  0xee,
-  0x55,  0xca,  0x6b,  0xfe,  0xdc,  0x14,  0x4d,  0x0f,  0x06,  0x18,  0xca,  0x7c,  0x30,  0xfe,  0x78,  0x10,
-  0xff,  0x02,  0x83,  0x55,  0xab,  0xff,  0x02,  0x83,  0x55,  0x69,  0x19,  0xae,  0x98,  0xfe,  0x30,  0x00,
-  0x96,  0xf2,  0x18,  0x6d,  0x0f,  0x06,  0xfe,  0x56,  0x10,  0x69,  0x0a,  0xed,  0x98,  0xfe,  0x64,  0x00,
-  0x96,  0xf2,  0x09,  0xfe,  0x64,  0x00,  0x18,  0x9e,  0x0f,  0x06,  0xfe,  0x28,  0x10,  0x69,  0x06,  0xfe,
-  0x60,  0x13,  0x98,  0xfe,  0xc8,  0x00,  0x96,  0xf2,  0x09,  0xfe,  0xc8,  0x00,  0x18,  0x59,  0x0f,  0x06,
-  0x88,  0x98,  0xfe,  0x90,  0x01,  0x7a,  0xfe,  0x42,  0x15,  0x91,  0xe4,  0xfe,  0x43,  0xf4,  0x9f,  0xfe,
-  0x56,  0xf0,  0xfe,  0x54,  0x15,  0xfe,  0x04,  0xf4,  0x71,  0xfe,  0x43,  0xf4,  0x9e,  0xfe,  0xf3,  0x10,
-  0xfe,  0x40,  0x5c,  0x01,  0xfe,  0x16,  0x14,  0x1e,  0x43,  0xec,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,
-  0x6e,  0x7a,  0xfe,  0x90,  0x15,  0xc4,  0x6e,  0xfe,  0x1c,  0x10,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,
-  0xcc,  0x7a,  0xfe,  0x90,  0x15,  0xc4,  0xcc,  0x88,  0x51,  0x21,  0xfe,  0x4d,  0xf4,  0x00,  0xe9,  0x91,
-  0x0f,  0x06,  0xfe,  0xb4,  0x56,  0xfe,  0xc3,  0x58,  0x04,  0x51,  0x0f,  0x0a,  0x04,  0x16,  0x06,  0x01,
-  0x0b,  0x26,  0xf3,  0x16,  0x0a,  0x01,  0x0b,  0x26,  0xf3,  0x16,  0x19,  0x01,  0x0b,  0x26,  0xf3,  0x76,
-  0xfe,  0x89,  0x49,  0x01,  0x0b,  0x04,  0x16,  0x06,  0x01,  0x0b,  0x26,  0xb1,  0x16,  0x19,  0x01,  0x0b,
-  0x26,  0xb1,  0x16,  0x06,  0x01,  0x0b,  0x26,  0xb1,  0xfe,  0x89,  0x49,  0x01,  0x0b,  0x26,  0xb1,  0x76,
-  0xfe,  0x89,  0x4a,  0x01,  0x0b,  0x04,  0x51,  0x04,  0x22,  0xd3,  0x07,  0x06,  0xfe,  0x48,  0x13,  0xb8,
-  0x13,  0xd3,  0xfe,  0x49,  0xf4,  0x00,  0x4d,  0x76,  0xa9,  0x67,  0xfe,  0x01,  0xec,  0xfe,  0x27,  0x01,
-  0xfe,  0x89,  0x48,  0xff,  0x02,  0x00,  0x10,  0x27,  0xfe,  0x2e,  0x16,  0x32,  0x07,  0xfe,  0xe3,  0x00,
-  0xfe,  0x20,  0x13,  0x1d,  0xfe,  0x52,  0x16,  0x21,  0x13,  0xd4,  0x01,  0x4b,  0x22,  0xd4,  0x07,  0x06,
-  0x4e,  0x08,  0x54,  0x06,  0x37,  0x04,  0x09,  0x48,  0x01,  0x0e,  0xfb,  0x8e,  0x07,  0x11,  0xae,  0x09,
-  0x84,  0x01,  0x0e,  0x8e,  0x09,  0x5d,  0x01,  0xa8,  0x04,  0x09,  0x84,  0x01,  0x0e,  0x8e,  0xfe,  0x80,
-  0xe7,  0x11,  0x07,  0x11,  0x8a,  0xfe,  0x45,  0x58,  0x01,  0xf0,  0x8e,  0x04,  0x09,  0x48,  0x01,  0x0e,
-  0x8e,  0x09,  0x5d,  0x01,  0xa8,  0x04,  0x09,  0x48,  0x01,  0x0e,  0xfe,  0x80,  0x80,  0xfe,  0x80,  0x4c,
-  0xfe,  0x49,  0xe4,  0x11,  0xae,  0x09,  0x84,  0x01,  0x0e,  0xfe,  0x80,  0x4c,  0x09,  0x5d,  0x01,  0x87,
-  0x04,  0x18,  0x11,  0x75,  0x6c,  0xfe,  0x60,  0x01,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x24,
-  0x1c,  0xfe,  0x1d,  0xf7,  0x1b,  0x97,  0xfe,  0xee,  0x16,  0x01,  0xfe,  0xf4,  0x17,  0xad,  0x9a,  0x1b,
-  0x6c,  0xfe,  0x2c,  0x01,  0xfe,  0x2f,  0x19,  0x04,  0xb9,  0x23,  0xfe,  0xde,  0x16,  0xfe,  0xda,  0x10,
-  0x18,  0x11,  0x75,  0x03,  0xfe,  0x64,  0x01,  0xfe,  0x00,  0xf4,  0x1f,  0xfe,  0x18,  0x58,  0x03,  0xfe,
-  0x66,  0x01,  0xfe,  0x19,  0x58,  0x9a,  0x1f,  0xfe,  0x3c,  0x90,  0xfe,  0x30,  0xf4,  0x06,  0xfe,  0x3c,
-  0x50,  0x6c,  0xfe,  0x38,  0x00,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0x1f,  0x97,  0xfe,  0x38,  0x17,
-  0xfe,  0xb6,  0x14,  0x35,  0x04,  0xb9,  0x23,  0xfe,  0x10,  0x17,  0xfe,  0x9c,  0x10,  0x18,  0x11,  0x75,
-  0xfe,  0x83,  0x5a,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x1d,  0xf7,  0x2e,  0x97,  0xfe,  0x5a,
-  0x17,  0xfe,  0x94,  0x14,  0xec,  0x9a,  0x2e,  0x6c,  0x1a,  0xfe,  0xaf,  0x19,  0xfe,  0x98,  0xe7,  0x00,
-  0x04,  0xb9,  0x23,  0xfe,  0x4e,  0x17,  0xfe,  0x6c,  0x10,  0x18,  0x11,  0x75,  0xfe,  0x30,  0xbc,  0xfe,
-  0xb2,  0xbc,  0x9a,  0xcb,  0x6c,  0x1a,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0xcb,  0x97,  0xfe,  0x92,
-  0x17,  0xfe,  0x5c,  0x14,  0x35,  0x04,  0xb9,  0x23,  0xfe,  0x7e,  0x17,  0xfe,  0x42,  0x10,  0xfe,  0x02,
-  0xf6,  0x11,  0x75,  0xfe,  0x18,  0xfe,  0x60,  0xfe,  0x19,  0xfe,  0x61,  0xfe,  0x03,  0xa1,  0xfe,  0x1d,
-  0xf7,  0x5b,  0x97,  0xfe,  0xb8,  0x17,  0xfe,  0x36,  0x14,  0xfe,  0x1c,  0x13,  0x9a,  0x5b,  0x41,  0xfe,
-  0x83,  0x58,  0xfe,  0xaf,  0x19,  0xfe,  0x80,  0xe7,  0x11,  0xfe,  0x81,  0xe7,  0x11,  0x12,  0xfe,  0xdd,
-  0x00,  0x6a,  0x2a,  0x04,  0x6a,  0x2a,  0xfe,  0x12,  0x45,  0x23,  0xfe,  0xa8,  0x17,  0x15,  0x06,  0x39,
-  0xa0,  0xb4,  0x02,  0x2b,  0xfe,  0x39,  0xf0,  0xfe,  0xfc,  0x17,  0x21,  0x04,  0xfe,  0x7e,  0x18,  0x1e,
-  0x19,  0x66,  0x0f,  0x0d,  0x04,  0x75,  0x03,  0xd2,  0x1e,  0x06,  0xfe,  0xef,  0x12,  0xfe,  0xe1,  0x10,
-  0x7c,  0x6f,  0x4f,  0x32,  0x07,  0x2f,  0xfe,  0x3c,  0x13,  0xf1,  0xfe,  0x42,  0x13,  0x42,  0x92,  0x09,
-  0x48,  0x01,  0x0e,  0xbb,  0xeb,  0xfe,  0x41,  0x48,  0xfe,  0x45,  0x48,  0x01,  0xf0,  0xfe,  0x00,  0xcc,
-  0xbb,  0xfe,  0xf3,  0x13,  0x43,  0x78,  0x07,  0x11,  0xac,  0x09,  0x84,  0x01,  0x0e,  0xfe,  0x80,  0x4c,
-  0x01,  0x73,  0xfe,  0x16,  0x10,  0x07,  0x82,  0x8b,  0xfe,  0x40,  0x14,  0xfe,  0x24,  0x12,  0xfe,  0x14,
-  0x56,  0xfe,  0xd6,  0xf0,  0xfe,  0x1c,  0x18,  0x18,  0x0a,  0x04,  0xfe,  0x9c,  0xe7,  0x0a,  0x10,  0xfe,
-  0x15,  0x00,  0x64,  0x79,  0x2a,  0x01,  0xe3,  0x18,  0x06,  0x04,  0x42,  0x92,  0x08,  0x54,  0x1b,  0x37,
-  0x12,  0x2f,  0x01,  0x73,  0x18,  0x06,  0x04,  0xfe,  0x38,  0x90,  0xfe,  0xba,  0x90,  0x3a,  0xce,  0x3b,
-  0xcf,  0xfe,  0x48,  0x55,  0x35,  0xfe,  0xc9,  0x55,  0x04,  0x22,  0xa3,  0x77,  0x13,  0xa3,  0x04,  0x09,
-  0xa4,  0x01,  0x0e,  0xfe,  0x41,  0x48,  0x09,  0x46,  0x01,  0x0e,  0xfe,  0x49,  0x44,  0x17,  0xfe,  0xe8,
-  0x18,  0x77,  0x78,  0x04,  0x09,  0x48,  0x01,  0x0e,  0x07,  0x11,  0x4e,  0x09,  0x5d,  0x01,  0xa8,  0x09,
-  0x46,  0x01,  0x0e,  0x77,  0x78,  0x04,  0xfe,  0x4e,  0xe4,  0x19,  0x6b,  0xfe,  0x1c,  0x19,  0x03,  0xfe,
-  0x90,  0x00,  0xfe,  0x3a,  0x45,  0xfe,  0x2c,  0x10,  0xfe,  0x4e,  0xe4,  0xc9,  0x6b,  0xfe,  0x2e,  0x19,
-  0x03,  0xfe,  0x92,  0x00,  0xfe,  0x02,  0xe6,  0x1a,  0xe5,  0xfe,  0x4e,  0xe4,  0xfe,  0x0b,  0x00,  0x6b,
-  0xfe,  0x40,  0x19,  0x03,  0xfe,  0x94,  0x00,  0xfe,  0x02,  0xe6,  0x1f,  0xfe,  0x08,  0x10,  0x03,  0xfe,
-  0x96,  0x00,  0xfe,  0x02,  0xe6,  0x6d,  0xfe,  0x4e,  0x45,  0xea,  0xba,  0xff,  0x04,  0x68,  0x54,  0xe7,
-  0x1e,  0x6e,  0xfe,  0x08,  0x1c,  0xfe,  0x67,  0x19,  0xfe,  0x0a,  0x1c,  0xfe,  0x1a,  0xf4,  0xfe,  0x00,
-  0x04,  0xea,  0xfe,  0x48,  0xf4,  0x19,  0x7a,  0xfe,  0x74,  0x19,  0x0f,  0x19,  0x04,  0x07,  0x7e,  0xfe,
-  0x5a,  0xf0,  0xfe,  0x84,  0x19,  0x25,  0xfe,  0x09,  0x00,  0xfe,  0x34,  0x10,  0x07,  0x1a,  0xfe,  0x5a,
-  0xf0,  0xfe,  0x92,  0x19,  0x25,  0xca,  0xfe,  0x26,  0x10,  0x07,  0x19,  0x66,  0x25,  0x6d,  0xe5,  0x07,
-  0x0a,  0x66,  0x25,  0x9e,  0xfe,  0x0e,  0x10,  0x07,  0x06,  0x66,  0x25,  0x59,  0xa9,  0xb8,  0x04,  0x15,
-  0xfe,  0x09,  0x00,  0x01,  0x36,  0xfe,  0x04,  0xfe,  0x81,  0x03,  0x83,  0xfe,  0x40,  0x5c,  0x04,  0x1c,
-  0xf7,  0xfe,  0x14,  0xf0,  0x0b,  0x27,  0xfe,  0xd6,  0x19,  0x1c,  0xf7,  0x7b,  0xf7,  0xfe,  0x82,  0xf0,
-  0xfe,  0xda,  0x19,  0x04,  0xff,  0xcc,  0x00,  0x00,
+static unsigned char _adv_asc38C0800_buf[] = {
+	0x00, 0x00, 0x00, 0xf2, 0x00, 0xf0, 0x00, 0xfc, 0x00, 0x16, 0x18, 0xe4,
+	0x01, 0x00, 0x48, 0xe4,
+	0x18, 0x80, 0x03, 0xf6, 0x02, 0x00, 0xce, 0x19, 0x00, 0xfa, 0xff, 0xff,
+	0x1c, 0x0f, 0x00, 0xf6,
+	0x9e, 0xe7, 0xff, 0x00, 0x82, 0xe7, 0x00, 0xea, 0x01, 0xfa, 0x01, 0xe6,
+	0x09, 0xe7, 0x55, 0xf0,
+	0x01, 0xf6, 0x03, 0x00, 0x04, 0x00, 0x10, 0x00, 0x1e, 0xf0, 0x85, 0xf0,
+	0x18, 0xf4, 0x08, 0x00,
+	0xbc, 0x00, 0x38, 0x54, 0x00, 0xec, 0xd5, 0xf0, 0x82, 0x0d, 0x00, 0xe6,
+	0x86, 0xf0, 0xb1, 0xf0,
+	0x98, 0x57, 0x01, 0xfc, 0xb4, 0x00, 0xd4, 0x01, 0x0c, 0x1c, 0x3e, 0x1c,
+	0x3c, 0x00, 0xbb, 0x00,
+	0x00, 0x10, 0xba, 0x19, 0x02, 0x80, 0x32, 0xf0, 0x7c, 0x0d, 0x02, 0x13,
+	0xba, 0x13, 0x18, 0x40,
+	0x00, 0x57, 0x01, 0xea, 0x02, 0xfc, 0x03, 0xfc, 0x3e, 0x00, 0x6c, 0x01,
+	0x6e, 0x01, 0x74, 0x01,
+	0x76, 0x01, 0xb9, 0x54, 0x3e, 0x57, 0x00, 0x80, 0x03, 0xe6, 0xb6, 0x00,
+	0xc0, 0x00, 0x01, 0x01,
+	0x3e, 0x01, 0x7a, 0x01, 0xca, 0x08, 0xce, 0x10, 0x16, 0x11, 0x04, 0x12,
+	0x08, 0x12, 0x02, 0x4a,
+	0xbb, 0x55, 0x3c, 0x56, 0x03, 0x58, 0x1b, 0x80, 0x30, 0xe4, 0x4b, 0xe4,
+	0x5d, 0xf0, 0x02, 0xfa,
+	0x20, 0x00, 0x32, 0x00, 0x40, 0x00, 0x80, 0x00, 0x24, 0x01, 0x3c, 0x01,
+	0x68, 0x01, 0x6a, 0x01,
+	0x70, 0x01, 0x72, 0x01, 0x78, 0x01, 0x7c, 0x01, 0x62, 0x0a, 0x86, 0x0d,
+	0x06, 0x13, 0x4c, 0x1c,
+	0x04, 0x80, 0x4a, 0xe4, 0x02, 0xee, 0x5b, 0xf0, 0x03, 0xf7, 0x0c, 0x00,
+	0x0f, 0x00, 0x47, 0x00,
+	0xbe, 0x00, 0x00, 0x01, 0x20, 0x11, 0x5c, 0x16, 0x32, 0x1c, 0x38, 0x1c,
+	0x4e, 0x1c, 0x10, 0x44,
+	0x00, 0x4c, 0x04, 0xea, 0x5c, 0xf0, 0xa7, 0xf0, 0x04, 0xf6, 0x03, 0xfa,
+	0x05, 0x00, 0x34, 0x00,
+	0x36, 0x00, 0x98, 0x00, 0xcc, 0x00, 0x20, 0x01, 0x4e, 0x01, 0x4a, 0x0b,
+	0x42, 0x0c, 0x12, 0x0f,
+	0x0c, 0x10, 0x22, 0x11, 0x0a, 0x12, 0x04, 0x13, 0x30, 0x1c, 0x02, 0x48,
+	0x00, 0x4e, 0x42, 0x54,
+	0x44, 0x55, 0xbd, 0x56, 0x06, 0x83, 0x00, 0xdc, 0x05, 0xf0, 0x09, 0xf0,
+	0x59, 0xf0, 0xb8, 0xf0,
+	0x4b, 0xf4, 0x06, 0xf7, 0x0e, 0xf7, 0x04, 0xfc, 0x05, 0xfc, 0x06, 0x00,
+	0x19, 0x00, 0x33, 0x00,
+	0x9b, 0x00, 0xa4, 0x00, 0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe1, 0x00,
+	0xe7, 0x00, 0xe2, 0x03,
+	0x08, 0x0f, 0x02, 0x10, 0x04, 0x10, 0x0a, 0x10, 0x0a, 0x13, 0x0c, 0x13,
+	0x12, 0x13, 0x24, 0x14,
+	0x34, 0x14, 0x04, 0x16, 0x08, 0x16, 0xa4, 0x17, 0x20, 0x1c, 0x34, 0x1c,
+	0x36, 0x1c, 0x08, 0x44,
+	0x38, 0x44, 0x91, 0x44, 0x0a, 0x45, 0x48, 0x46, 0x01, 0x48, 0x68, 0x54,
+	0x3a, 0x55, 0x83, 0x55,
+	0xe5, 0x55, 0xb0, 0x57, 0x01, 0x58, 0x83, 0x59, 0x05, 0xe6, 0x0b, 0xf0,
+	0x0c, 0xf0, 0x04, 0xf8,
+	0x05, 0xf8, 0x07, 0x00, 0x0a, 0x00, 0x1c, 0x00, 0x1e, 0x00, 0x9e, 0x00,
+	0xa8, 0x00, 0xaa, 0x00,
+	0xb9, 0x00, 0xe0, 0x00, 0x22, 0x01, 0x26, 0x01, 0x79, 0x01, 0x7e, 0x01,
+	0xc4, 0x01, 0xc6, 0x01,
+	0x80, 0x02, 0x5e, 0x03, 0xee, 0x04, 0x9a, 0x06, 0xf8, 0x07, 0x62, 0x08,
+	0x68, 0x08, 0x69, 0x08,
+	0xd6, 0x08, 0xe9, 0x09, 0xfa, 0x0b, 0x2e, 0x0f, 0x12, 0x10, 0x1a, 0x10,
+	0xed, 0x10, 0xf1, 0x10,
+	0x2a, 0x11, 0x06, 0x12, 0x0c, 0x12, 0x3e, 0x12, 0x10, 0x13, 0x16, 0x13,
+	0x1e, 0x13, 0x46, 0x14,
+	0x76, 0x14, 0x82, 0x14, 0x36, 0x15, 0xca, 0x15, 0x6b, 0x18, 0xbe, 0x18,
+	0xca, 0x18, 0xe6, 0x19,
+	0x12, 0x1c, 0x46, 0x1c, 0x9c, 0x32, 0x00, 0x40, 0x0e, 0x47, 0xfe, 0x9c,
+	0xf0, 0x2b, 0x02, 0xfe,
+	0xac, 0x0d, 0xff, 0x10, 0x00, 0x00, 0xd7, 0xfe, 0xe8, 0x19, 0x00, 0xd6,
+	0xfe, 0x84, 0x01, 0xff,
+	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
+	0x00, 0xfe, 0x57, 0x24,
+	0x00, 0xfe, 0x4c, 0x00, 0x5b, 0xff, 0x04, 0x00, 0x00, 0x11, 0xff, 0x09,
+	0x00, 0x00, 0xff, 0x08,
+	0x01, 0x01, 0xff, 0x08, 0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10,
+	0xff, 0xff, 0xff, 0x11,
+	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
+	0xfe, 0x04, 0xf7, 0xd6,
+	0x2c, 0x99, 0x0a, 0x01, 0xfe, 0xc2, 0x0f, 0xfe, 0x04, 0xf7, 0xd6, 0x99,
+	0x0a, 0x42, 0x2c, 0xfe,
+	0x3d, 0xf0, 0xfe, 0x06, 0x02, 0xfe, 0x20, 0xf0, 0xa7, 0xfe, 0x91, 0xf0,
+	0xfe, 0xf4, 0x01, 0xfe,
+	0x90, 0xf0, 0xfe, 0xf4, 0x01, 0xfe, 0x8f, 0xf0, 0xa7, 0x03, 0x5d, 0x4d,
+	0x02, 0xfe, 0xc8, 0x0d,
+	0x01, 0xfe, 0x38, 0x0e, 0xfe, 0xdd, 0x12, 0xfe, 0xfc, 0x10, 0xfe, 0x28,
+	0x1c, 0x03, 0xfe, 0xa6,
+	0x00, 0xfe, 0xd3, 0x12, 0x41, 0x14, 0xfe, 0xa6, 0x00, 0xc2, 0xfe, 0x48,
+	0xf0, 0xfe, 0x8a, 0x02,
+	0xfe, 0x49, 0xf0, 0xfe, 0xa4, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xc2, 0x02,
+	0xfe, 0x46, 0xf0, 0xfe,
+	0x54, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x5a, 0x02, 0xfe, 0x43, 0xf0, 0xfe,
+	0x48, 0x02, 0xfe, 0x44,
+	0xf0, 0xfe, 0x4c, 0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x50, 0x02, 0x18, 0x0a,
+	0xaa, 0x18, 0x06, 0x14,
+	0xa1, 0x02, 0x2b, 0xfe, 0x00, 0x1c, 0xe7, 0xfe, 0x02, 0x1c, 0xe6, 0xfe,
+	0x1e, 0x1c, 0xfe, 0xe9,
+	0x10, 0x01, 0xfe, 0x18, 0x18, 0xfe, 0xe7, 0x10, 0xfe, 0x06, 0xfc, 0xce,
+	0x09, 0x70, 0x01, 0xa8,
+	0x02, 0x2b, 0x15, 0x59, 0x39, 0xa2, 0x01, 0xfe, 0x58, 0x10, 0x09, 0x70,
+	0x01, 0x87, 0xfe, 0xbd,
+	0x10, 0x09, 0x70, 0x01, 0x87, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c, 0xfe,
+	0x58, 0x1c, 0x18, 0x06,
+	0x14, 0xa1, 0x2c, 0x1c, 0x2b, 0xfe, 0x3d, 0xf0, 0xfe, 0x06, 0x02, 0x23,
+	0xfe, 0x98, 0x02, 0xfe,
+	0x5a, 0x1c, 0xf8, 0xfe, 0x14, 0x1c, 0x15, 0xfe, 0x30, 0x00, 0x39, 0xa2,
+	0x01, 0xfe, 0x48, 0x10,
+	0x18, 0x06, 0x14, 0xa1, 0x02, 0xd7, 0x22, 0x20, 0x07, 0x11, 0x35, 0xfe,
+	0x69, 0x10, 0x18, 0x06,
+	0x14, 0xa1, 0xfe, 0x04, 0xec, 0x20, 0x4f, 0x43, 0x13, 0x20, 0xfe, 0x05,
+	0xf6, 0xce, 0x01, 0xfe,
+	0x4a, 0x17, 0x08, 0x54, 0x58, 0x37, 0x12, 0x2f, 0x42, 0x92, 0x01, 0xfe,
+	0x82, 0x16, 0x02, 0x2b,
+	0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x66, 0x01, 0x73, 0xfe, 0x18, 0x10,
+	0xfe, 0x41, 0x58, 0x09,
+	0xa4, 0x01, 0x0e, 0xfe, 0xc8, 0x54, 0x6b, 0xfe, 0x10, 0x03, 0x01, 0xfe,
+	0x82, 0x16, 0x02, 0x2b,
+	0x2c, 0x4f, 0xfe, 0x02, 0xe8, 0x2a, 0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43,
+	0xfe, 0x77, 0x57, 0xfe,
+	0x27, 0xf0, 0xfe, 0xe0, 0x01, 0xfe, 0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xa7,
+	0xfe, 0x40, 0x1c, 0x1c,
+	0xd9, 0xfe, 0x26, 0xf0, 0xfe, 0x5a, 0x03, 0xfe, 0xa0, 0xf0, 0xfe, 0x48,
+	0x03, 0xfe, 0x11, 0xf0,
+	0xa7, 0xfe, 0xef, 0x10, 0xfe, 0x9f, 0xf0, 0xfe, 0x68, 0x03, 0xf9, 0x10,
+	0xfe, 0x11, 0x00, 0x02,
+	0x65, 0x2c, 0xfe, 0x48, 0x1c, 0xf9, 0x08, 0x05, 0x1b, 0xfe, 0x18, 0x13,
+	0x21, 0x22, 0xa3, 0xb7,
+	0x13, 0xa3, 0x09, 0x46, 0x01, 0x0e, 0xb7, 0x78, 0x01, 0xfe, 0xb4, 0x16,
+	0x12, 0xd1, 0x1c, 0xd9,
+	0xfe, 0x01, 0xf0, 0xd9, 0xfe, 0x82, 0xf0, 0xfe, 0x96, 0x03, 0xfa, 0x12,
+	0xfe, 0xe4, 0x00, 0x27,
+	0xfe, 0xa8, 0x03, 0x1c, 0x34, 0x1d, 0xfe, 0xb8, 0x03, 0x01, 0x4b, 0xfe,
+	0x06, 0xf0, 0xfe, 0xc8,
+	0x03, 0x95, 0x86, 0xfe, 0x0a, 0xf0, 0xfe, 0x8a, 0x06, 0x02, 0x24, 0x03,
+	0x70, 0x28, 0x17, 0xfe,
+	0xfa, 0x04, 0x15, 0x6d, 0x01, 0x36, 0x7b, 0xfe, 0x6a, 0x02, 0x02, 0xd8,
+	0xf9, 0x2c, 0x99, 0x19,
+	0xfe, 0x67, 0x1b, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57, 0xfe, 0x48, 0x1c,
+	0x74, 0x01, 0xaf, 0x8c,
+	0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x17, 0xda, 0x09, 0xd1, 0x01, 0x0e,
+	0x8d, 0x51, 0x64, 0x79,
+	0x2a, 0x03, 0x70, 0x28, 0xfe, 0x10, 0x12, 0x15, 0x6d, 0x01, 0x36, 0x7b,
+	0xfe, 0x6a, 0x02, 0x02,
+	0xd8, 0xc7, 0x81, 0xc8, 0x83, 0x1c, 0x24, 0x27, 0xfe, 0x40, 0x04, 0x1d,
+	0xfe, 0x3c, 0x04, 0x3b,
+	0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x4e, 0x12, 0x2d, 0xff, 0x02,
+	0x00, 0x10, 0x01, 0x0b,
+	0x1d, 0xfe, 0xe4, 0x04, 0x2d, 0x01, 0x0b, 0x1d, 0x24, 0x33, 0x31, 0xde,
+	0xfe, 0x4c, 0x44, 0xfe,
+	0x4c, 0x12, 0x51, 0xfe, 0x44, 0x48, 0x0f, 0x6f, 0xfe, 0x4c, 0x54, 0x6b,
+	0xda, 0x4f, 0x79, 0x2a,
+	0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x62, 0x13, 0x08, 0x05, 0x1b,
+	0xfe, 0x2a, 0x13, 0x32,
+	0x07, 0x82, 0xfe, 0x52, 0x13, 0xfe, 0x20, 0x10, 0x0f, 0x6f, 0xfe, 0x4c,
+	0x54, 0x6b, 0xda, 0xfe,
+	0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x40, 0x13, 0x08, 0x05, 0x1b, 0xfe,
+	0x08, 0x13, 0x32, 0x07,
+	0x82, 0xfe, 0x30, 0x13, 0x08, 0x05, 0x1b, 0xfe, 0x1c, 0x12, 0x15, 0x9d,
+	0x08, 0x05, 0x06, 0x4d,
+	0x15, 0xfe, 0x0d, 0x00, 0x01, 0x36, 0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24,
+	0x2d, 0x12, 0xfe, 0xe6,
+	0x00, 0xfe, 0x1c, 0x90, 0xfe, 0x40, 0x5c, 0x04, 0x15, 0x9d, 0x01, 0x36,
+	0x02, 0x2b, 0xfe, 0x42,
+	0x5b, 0x99, 0x19, 0xfe, 0x46, 0x59, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57,
+	0xfe, 0x87, 0x80, 0xfe,
+	0x31, 0xe4, 0x5b, 0x08, 0x05, 0x0a, 0xfe, 0x84, 0x13, 0xfe, 0x20, 0x80,
+	0x07, 0x19, 0xfe, 0x7c,
+	0x12, 0x53, 0x05, 0x06, 0xfe, 0x6c, 0x13, 0x03, 0xfe, 0xa2, 0x00, 0x28,
+	0x17, 0xfe, 0x90, 0x05,
+	0xfe, 0x31, 0xe4, 0x5a, 0x53, 0x05, 0x0a, 0xfe, 0x56, 0x13, 0x03, 0xfe,
+	0xa0, 0x00, 0x28, 0xfe,
+	0x4e, 0x12, 0x67, 0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x48, 0x05, 0x1c,
+	0x34, 0xfe, 0x89, 0x48,
+	0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x56, 0x05, 0x26, 0xfe, 0xa8, 0x05,
+	0x12, 0xfe, 0xe3, 0x00,
+	0x21, 0x53, 0xfe, 0x4a, 0xf0, 0xfe, 0x76, 0x05, 0xfe, 0x49, 0xf0, 0xfe,
+	0x70, 0x05, 0x88, 0x25,
+	0xfe, 0x21, 0x00, 0xab, 0x25, 0xfe, 0x22, 0x00, 0xaa, 0x25, 0x58, 0xfe,
+	0x09, 0x48, 0xff, 0x02,
+	0x00, 0x10, 0x27, 0xfe, 0x86, 0x05, 0x26, 0xfe, 0xa8, 0x05, 0xfe, 0xe2,
+	0x08, 0x53, 0x05, 0xcb,
+	0x4d, 0x01, 0xb0, 0x25, 0x06, 0x13, 0xd3, 0x39, 0xfe, 0x27, 0x01, 0x08,
+	0x05, 0x1b, 0xfe, 0x22,
+	0x12, 0x41, 0x01, 0xb2, 0x15, 0x9d, 0x08, 0x05, 0x06, 0x4d, 0x15, 0xfe,
+	0x0d, 0x00, 0x01, 0x36,
+	0x7b, 0xfe, 0x64, 0x0d, 0x02, 0x24, 0x03, 0xfe, 0x9c, 0x00, 0x28, 0xeb,
+	0x03, 0x5c, 0x28, 0xfe,
+	0x36, 0x13, 0x41, 0x01, 0xb2, 0x26, 0xfe, 0x18, 0x06, 0x09, 0x06, 0x53,
+	0x05, 0x1f, 0xfe, 0x02,
+	0x12, 0x50, 0x01, 0xfe, 0x9e, 0x15, 0x1d, 0xfe, 0x0e, 0x06, 0x12, 0xa5,
+	0x01, 0x4b, 0x12, 0xfe,
+	0xe5, 0x00, 0x03, 0x5c, 0xc1, 0x0c, 0x5c, 0x03, 0xcd, 0x28, 0xfe, 0x62,
+	0x12, 0x03, 0x45, 0x28,
+	0xfe, 0x5a, 0x13, 0x01, 0xfe, 0x0c, 0x19, 0x01, 0xfe, 0x76, 0x19, 0xfe,
+	0x43, 0x48, 0xc4, 0xcc,
+	0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0x8b, 0xc4,
+	0x6e, 0x41, 0x01, 0xb2,
+	0x26, 0xfe, 0x82, 0x06, 0x53, 0x05, 0x1a, 0xe9, 0x91, 0x09, 0x59, 0x01,
+	0xfe, 0xcc, 0x15, 0x1d,
+	0xfe, 0x78, 0x06, 0x12, 0xa5, 0x01, 0x4b, 0x12, 0xfe, 0xe5, 0x00, 0x03,
+	0x45, 0xc1, 0x0c, 0x45,
+	0x18, 0x06, 0x01, 0xb2, 0xfa, 0x76, 0x74, 0x01, 0xaf, 0x8c, 0x12, 0xfe,
+	0xe2, 0x00, 0x27, 0xdb,
+	0x1c, 0x34, 0xfe, 0x0a, 0xf0, 0xfe, 0xb6, 0x06, 0x94, 0xfe, 0x6c, 0x07,
+	0xfe, 0x06, 0xf0, 0xfe,
+	0x74, 0x07, 0x95, 0x86, 0x02, 0x24, 0x08, 0x05, 0x0a, 0xfe, 0x2e, 0x12,
+	0x16, 0x19, 0x01, 0x0b,
+	0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01, 0x0b,
+	0xfe, 0x99, 0xa4, 0x01,
+	0x0b, 0x16, 0x00, 0x02, 0xfe, 0x42, 0x08, 0x68, 0x05, 0x1a, 0xfe, 0x38,
+	0x12, 0x08, 0x05, 0x1a,
+	0xfe, 0x30, 0x13, 0x16, 0xfe, 0x1b, 0x00, 0x01, 0x0b, 0x16, 0x00, 0x01,
+	0x0b, 0x16, 0x00, 0x01,
+	0x0b, 0x16, 0x00, 0x01, 0x0b, 0x16, 0x06, 0x01, 0x0b, 0x16, 0x00, 0x02,
+	0xe2, 0x6c, 0x58, 0xbe,
+	0x50, 0xfe, 0x9a, 0x81, 0x55, 0x1b, 0x7a, 0xfe, 0x42, 0x07, 0x09, 0x1b,
+	0xfe, 0x09, 0x6f, 0xba,
+	0xfe, 0xca, 0x45, 0xfe, 0x32, 0x12, 0x69, 0x6d, 0x8b, 0x6c, 0x7f, 0x27,
+	0xfe, 0x54, 0x07, 0x1c,
+	0x34, 0xfe, 0x0a, 0xf0, 0xfe, 0x42, 0x07, 0x95, 0x86, 0x94, 0xfe, 0x6c,
+	0x07, 0x02, 0x24, 0x01,
+	0x4b, 0x02, 0xdb, 0x16, 0x1f, 0x02, 0xdb, 0xfe, 0x9c, 0xf7, 0xdc, 0xfe,
+	0x2c, 0x90, 0xfe, 0xae,
+	0x90, 0x56, 0xfe, 0xda, 0x07, 0x0c, 0x60, 0x14, 0x61, 0x08, 0x54, 0x5a,
+	0x37, 0x22, 0x20, 0x07,
+	0x11, 0xfe, 0x0e, 0x12, 0x8d, 0xfe, 0x80, 0x80, 0x39, 0x20, 0x6a, 0x2a,
+	0xfe, 0x06, 0x10, 0xfe,
+	0x83, 0xe7, 0xfe, 0x48, 0x00, 0xab, 0xfe, 0x03, 0x40, 0x08, 0x54, 0x5b,
+	0x37, 0x01, 0xb3, 0xb8,
+	0xfe, 0x1f, 0x40, 0x13, 0x62, 0x01, 0xef, 0xfe, 0x08, 0x50, 0xfe, 0x8a,
+	0x50, 0xfe, 0x44, 0x51,
+	0xfe, 0xc6, 0x51, 0x88, 0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90, 0x0c, 0x5e,
+	0x14, 0x5f, 0xfe, 0x0c,
+	0x90, 0xfe, 0x8e, 0x90, 0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x0c, 0x3d,
+	0x14, 0x3e, 0xfe, 0x4a,
+	0x10, 0x08, 0x05, 0x5a, 0xfe, 0x2a, 0x12, 0xfe, 0x2c, 0x90, 0xfe, 0xae,
+	0x90, 0x0c, 0x60, 0x14,
+	0x61, 0x08, 0x05, 0x5b, 0x8b, 0x01, 0xb3, 0xfe, 0x1f, 0x80, 0x13, 0x62,
+	0xfe, 0x44, 0x90, 0xfe,
+	0xc6, 0x90, 0x0c, 0x3f, 0x14, 0x40, 0xfe, 0x08, 0x90, 0xfe, 0x8a, 0x90,
+	0x0c, 0x5e, 0x14, 0x5f,
+	0xfe, 0x40, 0x90, 0xfe, 0xc2, 0x90, 0x0c, 0x3d, 0x14, 0x3e, 0x0c, 0x2e,
+	0x14, 0x3c, 0x21, 0x0c,
+	0x49, 0x0c, 0x63, 0x08, 0x54, 0x1f, 0x37, 0x2c, 0x0f, 0xfe, 0x4e, 0x11,
+	0x27, 0xdd, 0xfe, 0x9e,
+	0xf0, 0xfe, 0x76, 0x08, 0xbc, 0x17, 0x34, 0x2c, 0x77, 0xe6, 0xc5, 0xfe,
+	0x9a, 0x08, 0xc6, 0xfe,
+	0xb8, 0x08, 0x94, 0xfe, 0x8e, 0x08, 0xfe, 0x06, 0xf0, 0xfe, 0x94, 0x08,
+	0x95, 0x86, 0x02, 0x24,
+	0x01, 0x4b, 0xfe, 0xc9, 0x10, 0x16, 0x1f, 0xfe, 0xc9, 0x10, 0x68, 0x05,
+	0x06, 0xfe, 0x10, 0x12,
+	0x68, 0x05, 0x0a, 0x4e, 0x08, 0x05, 0x0a, 0xfe, 0x90, 0x12, 0xfe, 0x2e,
+	0x1c, 0x02, 0xfe, 0x18,
+	0x0b, 0x68, 0x05, 0x06, 0x4e, 0x68, 0x05, 0x0a, 0xfe, 0x7a, 0x12, 0xfe,
+	0x2c, 0x1c, 0xfe, 0xaa,
+	0xf0, 0xfe, 0xd2, 0x09, 0xfe, 0xac, 0xf0, 0xfe, 0x00, 0x09, 0x02, 0xfe,
+	0xde, 0x09, 0xfe, 0xb7,
+	0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0x02, 0xf6, 0x1a, 0x50, 0xfe, 0x70, 0x18,
+	0xfe, 0xf1, 0x18, 0xfe,
+	0x40, 0x55, 0xfe, 0xe1, 0x55, 0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58, 0xfe,
+	0x14, 0x59, 0xfe, 0x95,
+	0x59, 0x1c, 0x85, 0xfe, 0x8c, 0xf0, 0xfe, 0xfc, 0x08, 0xfe, 0xac, 0xf0,
+	0xfe, 0xf0, 0x08, 0xb5,
+	0xfe, 0xcb, 0x10, 0xfe, 0xad, 0xf0, 0xfe, 0x0c, 0x09, 0x02, 0xfe, 0x18,
+	0x0b, 0xb6, 0xfe, 0xbf,
+	0x10, 0xfe, 0x2b, 0xf0, 0x85, 0xf4, 0x1e, 0xfe, 0x00, 0xfe, 0xfe, 0x1c,
+	0x12, 0xc2, 0xfe, 0xd2,
+	0xf0, 0x85, 0xfe, 0x76, 0x18, 0x1e, 0x19, 0x17, 0x85, 0x03, 0xd2, 0x1e,
+	0x06, 0x17, 0x85, 0xc5,
+	0x4a, 0xc6, 0x4a, 0xb5, 0xb6, 0xfe, 0x89, 0x10, 0x74, 0x67, 0x2d, 0x15,
+	0x9d, 0x01, 0x36, 0x10,
+	0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x65, 0x10, 0x80, 0x02, 0x65, 0xfe,
+	0x98, 0x80, 0xfe, 0x19,
+	0xe4, 0x0a, 0xfe, 0x1a, 0x12, 0x51, 0xfe, 0x19, 0x82, 0xfe, 0x6c, 0x18,
+	0xfe, 0x44, 0x54, 0xbe,
+	0xfe, 0x19, 0x81, 0xfe, 0x74, 0x18, 0x8f, 0x90, 0x17, 0xfe, 0xce, 0x08,
+	0x02, 0x4a, 0x08, 0x05,
+	0x5a, 0xec, 0x03, 0x2e, 0x29, 0x3c, 0x0c, 0x3f, 0x14, 0x40, 0x9b, 0x2e,
+	0x9c, 0x3c, 0xfe, 0x6c,
+	0x18, 0xfe, 0xed, 0x18, 0xfe, 0x44, 0x54, 0xfe, 0xe5, 0x54, 0x3a, 0x3f,
+	0x3b, 0x40, 0x03, 0x49,
+	0x29, 0x63, 0x8f, 0xfe, 0xe3, 0x54, 0xfe, 0x74, 0x18, 0xfe, 0xf5, 0x18,
+	0x8f, 0xfe, 0xe3, 0x54,
+	0x90, 0xc0, 0x56, 0xfe, 0xce, 0x08, 0x02, 0x4a, 0xfe, 0x37, 0xf0, 0xfe,
+	0xda, 0x09, 0xfe, 0x8b,
+	0xf0, 0xfe, 0x60, 0x09, 0x02, 0x4a, 0x08, 0x05, 0x0a, 0x23, 0xfe, 0xfa,
+	0x0a, 0x3a, 0x49, 0x3b,
+	0x63, 0x56, 0xfe, 0x3e, 0x0a, 0x0f, 0xfe, 0xc0, 0x07, 0x41, 0x98, 0x00,
+	0xad, 0xfe, 0x01, 0x59,
+	0xfe, 0x52, 0xf0, 0xfe, 0x0c, 0x0a, 0x8f, 0x7a, 0xfe, 0x24, 0x0a, 0x3a,
+	0x49, 0x8f, 0xfe, 0xe3,
+	0x54, 0x57, 0x49, 0x7d, 0x63, 0xfe, 0x14, 0x58, 0xfe, 0x95, 0x58, 0x02,
+	0x4a, 0x3a, 0x49, 0x3b,
+	0x63, 0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0xbe, 0x57, 0x49, 0x57, 0x63,
+	0x02, 0x4a, 0x08, 0x05,
+	0x5a, 0xfe, 0x82, 0x12, 0x08, 0x05, 0x1f, 0xfe, 0x66, 0x13, 0x22, 0x62,
+	0xb7, 0xfe, 0x03, 0xa1,
+	0xfe, 0x83, 0x80, 0xfe, 0xc8, 0x44, 0xfe, 0x2e, 0x13, 0xfe, 0x04, 0x91,
+	0xfe, 0x86, 0x91, 0x6a,
+	0x2a, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x56, 0xe0, 0x03, 0x60, 0x29,
+	0x61, 0x0c, 0x7f, 0x14,
+	0x80, 0x57, 0x60, 0x7d, 0x61, 0x01, 0xb3, 0xb8, 0x6a, 0x2a, 0x13, 0x62,
+	0x9b, 0x2e, 0x9c, 0x3c,
+	0x3a, 0x3f, 0x3b, 0x40, 0x90, 0xc0, 0xfe, 0x04, 0xfa, 0x2e, 0xfe, 0x05,
+	0xfa, 0x3c, 0x01, 0xef,
+	0xfe, 0x36, 0x10, 0x21, 0x0c, 0x7f, 0x0c, 0x80, 0x3a, 0x3f, 0x3b, 0x40,
+	0xe4, 0x08, 0x05, 0x1f,
+	0x17, 0xe0, 0x3a, 0x3d, 0x3b, 0x3e, 0x08, 0x05, 0xfe, 0xf7, 0x00, 0x37,
+	0x03, 0x5e, 0x29, 0x5f,
+	0xfe, 0x10, 0x58, 0xfe, 0x91, 0x58, 0x57, 0x49, 0x7d, 0x63, 0x02, 0xfe,
+	0xf4, 0x09, 0x08, 0x05,
+	0x1f, 0x17, 0xe0, 0x08, 0x05, 0xfe, 0xf7, 0x00, 0x37, 0xbe, 0xfe, 0x19,
+	0x81, 0x50, 0xfe, 0x10,
+	0x90, 0xfe, 0x92, 0x90, 0xfe, 0xd3, 0x10, 0x32, 0x07, 0xa6, 0x17, 0xfe,
+	0x08, 0x09, 0x12, 0xa6,
+	0x08, 0x05, 0x0a, 0xfe, 0x14, 0x13, 0x03, 0x3d, 0x29, 0x3e, 0x56, 0xfe,
+	0x08, 0x09, 0xfe, 0x0c,
+	0x58, 0xfe, 0x8d, 0x58, 0x02, 0x4a, 0x21, 0x41, 0xfe, 0x19, 0x80, 0xe7,
+	0x08, 0x05, 0x0a, 0xfe,
+	0x1a, 0x12, 0xfe, 0x6c, 0x19, 0xfe, 0x19, 0x41, 0xf4, 0xc2, 0xfe, 0xd1,
+	0xf0, 0xe2, 0x15, 0x7e,
+	0x01, 0x36, 0x10, 0xfe, 0x44, 0x00, 0xfe, 0x8e, 0x10, 0xfe, 0x6c, 0x19,
+	0x57, 0x3d, 0xfe, 0xed,
+	0x19, 0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51, 0xf4, 0x1e, 0xfe,
+	0x00, 0xff, 0x35, 0xfe,
+	0x74, 0x10, 0xc2, 0xfe, 0xd2, 0xf0, 0xfe, 0xa6, 0x0b, 0xfe, 0x76, 0x18,
+	0x1e, 0x19, 0x8a, 0x03,
+	0xd2, 0x1e, 0x06, 0xfe, 0x08, 0x13, 0x10, 0xfe, 0x16, 0x00, 0x02, 0x65,
+	0xfe, 0xd1, 0xf0, 0xfe,
+	0xb8, 0x0b, 0x15, 0x7e, 0x01, 0x36, 0x10, 0xfe, 0x17, 0x00, 0xfe, 0x42,
+	0x10, 0xfe, 0xce, 0xf0,
+	0xfe, 0xbe, 0x0b, 0xfe, 0x3c, 0x10, 0xfe, 0xcd, 0xf0, 0xfe, 0xca, 0x0b,
+	0x10, 0xfe, 0x22, 0x00,
+	0x02, 0x65, 0xfe, 0xcb, 0xf0, 0xfe, 0xd6, 0x0b, 0x10, 0xfe, 0x24, 0x00,
+	0x02, 0x65, 0xfe, 0xd0,
+	0xf0, 0xfe, 0xe0, 0x0b, 0x10, 0x9e, 0xe5, 0xfe, 0xcf, 0xf0, 0xfe, 0xea,
+	0x0b, 0x10, 0x58, 0xfe,
+	0x10, 0x10, 0xfe, 0xcc, 0xf0, 0xe2, 0x68, 0x05, 0x1f, 0x4d, 0x10, 0xfe,
+	0x12, 0x00, 0x2c, 0x0f,
+	0xfe, 0x4e, 0x11, 0x27, 0xfe, 0x00, 0x0c, 0xfe, 0x9e, 0xf0, 0xfe, 0x14,
+	0x0c, 0xbc, 0x17, 0x34,
+	0x2c, 0x77, 0xe6, 0xc5, 0x24, 0xc6, 0x24, 0x2c, 0xfa, 0x27, 0xfe, 0x20,
+	0x0c, 0x1c, 0x34, 0x94,
+	0xfe, 0x3c, 0x0c, 0x95, 0x86, 0xc5, 0xdc, 0xc6, 0xdc, 0x02, 0x24, 0x01,
+	0x4b, 0xfe, 0xdb, 0x10,
+	0x12, 0xfe, 0xe8, 0x00, 0xb5, 0xb6, 0x74, 0xc7, 0x81, 0xc8, 0x83, 0xfe,
+	0x89, 0xf0, 0x24, 0x33,
+	0x31, 0xe1, 0xc7, 0x81, 0xc8, 0x83, 0x27, 0xfe, 0x66, 0x0c, 0x1d, 0x24,
+	0x33, 0x31, 0xdf, 0xbc,
+	0x4e, 0x10, 0xfe, 0x42, 0x00, 0x02, 0x65, 0x7c, 0x06, 0xfe, 0x81, 0x49,
+	0x17, 0xfe, 0x2c, 0x0d,
+	0x08, 0x05, 0x0a, 0xfe, 0x44, 0x13, 0x10, 0x00, 0x55, 0x0a, 0xfe, 0x54,
+	0x12, 0x55, 0xfe, 0x28,
+	0x00, 0x23, 0xfe, 0x9a, 0x0d, 0x09, 0x46, 0x01, 0x0e, 0x07, 0x00, 0x66,
+	0x44, 0xfe, 0x28, 0x00,
+	0xfe, 0xe2, 0x10, 0x01, 0xf5, 0x01, 0xf6, 0x09, 0xa4, 0x01, 0xfe, 0x26,
+	0x0f, 0x64, 0x12, 0x2f,
+	0x01, 0x73, 0x02, 0x2b, 0x10, 0xfe, 0x44, 0x00, 0x55, 0x0a, 0xe9, 0x44,
+	0x0a, 0xfe, 0xb4, 0x10,
+	0x01, 0xb0, 0x44, 0x0a, 0xfe, 0xaa, 0x10, 0x01, 0xb0, 0xfe, 0x19, 0x82,
+	0xfe, 0x34, 0x46, 0xac,
+	0x44, 0x0a, 0x10, 0xfe, 0x43, 0x00, 0xfe, 0x96, 0x10, 0x08, 0x54, 0x0a,
+	0x37, 0x01, 0xf5, 0x01,
+	0xf6, 0x64, 0x12, 0x2f, 0x01, 0x73, 0x99, 0x0a, 0x64, 0x42, 0x92, 0x02,
+	0xfe, 0x2e, 0x03, 0x08,
+	0x05, 0x0a, 0x8a, 0x44, 0x0a, 0x10, 0x00, 0xfe, 0x5c, 0x10, 0x68, 0x05,
+	0x1a, 0xfe, 0x58, 0x12,
+	0x08, 0x05, 0x1a, 0xfe, 0x50, 0x13, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0,
+	0xfe, 0x50, 0x0d, 0xfe,
+	0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x56, 0x0d, 0x08, 0x54, 0x1a, 0x37,
+	0xfe, 0xa9, 0x10, 0x10,
+	0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0a, 0x50, 0xfe, 0x2e, 0x10, 0x10,
+	0xfe, 0x13, 0x00, 0xfe,
+	0x10, 0x10, 0x10, 0x6f, 0xab, 0x10, 0xfe, 0x41, 0x00, 0xaa, 0x10, 0xfe,
+	0x24, 0x00, 0x8c, 0xb5,
+	0xb6, 0x74, 0x03, 0x70, 0x28, 0x23, 0xd8, 0x50, 0xfe, 0x04, 0xe6, 0x1a,
+	0xfe, 0x9d, 0x41, 0xfe,
+	0x1c, 0x42, 0x64, 0x01, 0xe3, 0x02, 0x2b, 0xf8, 0x15, 0x0a, 0x39, 0xa0,
+	0xb4, 0x15, 0xfe, 0x31,
+	0x00, 0x39, 0xa2, 0x01, 0xfe, 0x48, 0x10, 0x02, 0xd7, 0x42, 0xfe, 0x06,
+	0xec, 0xd0, 0xfc, 0x44,
+	0x1b, 0xfe, 0xce, 0x45, 0x35, 0x42, 0xfe, 0x06, 0xea, 0xd0, 0xfe, 0x47,
+	0x4b, 0x91, 0xfe, 0x75,
+	0x57, 0x03, 0x5d, 0xfe, 0x98, 0x56, 0xfe, 0x38, 0x12, 0x09, 0x48, 0x01,
+	0x0e, 0xfe, 0x44, 0x48,
+	0x4f, 0x08, 0x05, 0x1b, 0xfe, 0x1a, 0x13, 0x09, 0x46, 0x01, 0x0e, 0x41,
+	0xfe, 0x41, 0x58, 0x09,
+	0xa4, 0x01, 0x0e, 0xfe, 0x49, 0x54, 0x96, 0xfe, 0x1e, 0x0e, 0x02, 0xfe,
+	0x2e, 0x03, 0x09, 0x5d,
+	0xfe, 0xee, 0x14, 0xfc, 0x44, 0x1b, 0xfe, 0xce, 0x45, 0x35, 0x42, 0xfe,
+	0xce, 0x47, 0xfe, 0xad,
+	0x13, 0x02, 0x2b, 0x22, 0x20, 0x07, 0x11, 0xfe, 0x9e, 0x12, 0x21, 0x13,
+	0x59, 0x13, 0x9f, 0x13,
+	0xd5, 0x22, 0x2f, 0x41, 0x39, 0x2f, 0xbc, 0xad, 0xfe, 0xbc, 0xf0, 0xfe,
+	0xe0, 0x0e, 0x0f, 0x06,
+	0x13, 0x59, 0x01, 0xfe, 0xda, 0x16, 0x03, 0xfe, 0x38, 0x01, 0x29, 0xfe,
+	0x3a, 0x01, 0x56, 0xfe,
+	0xe4, 0x0e, 0xfe, 0x02, 0xec, 0xd5, 0x69, 0x00, 0x66, 0xfe, 0x04, 0xec,
+	0x20, 0x4f, 0xfe, 0x05,
+	0xf6, 0xfe, 0x34, 0x01, 0x01, 0xfe, 0x4a, 0x17, 0xfe, 0x08, 0x90, 0xfe,
+	0x48, 0xf4, 0x0d, 0xfe,
+	0x18, 0x13, 0xba, 0xfe, 0x02, 0xea, 0xd5, 0x69, 0x7e, 0xfe, 0xc5, 0x13,
+	0x15, 0x1a, 0x39, 0xa0,
+	0xb4, 0xfe, 0x2e, 0x10, 0x03, 0xfe, 0x38, 0x01, 0x1e, 0xfe, 0xf0, 0xff,
+	0x0c, 0xfe, 0x60, 0x01,
+	0x03, 0xfe, 0x3a, 0x01, 0x0c, 0xfe, 0x62, 0x01, 0x43, 0x13, 0x20, 0x25,
+	0x06, 0x13, 0x2f, 0x12,
+	0x2f, 0x92, 0x0f, 0x06, 0x04, 0x21, 0x04, 0x22, 0x59, 0xfe, 0xf7, 0x12,
+	0x22, 0x9f, 0xb7, 0x13,
+	0x9f, 0x07, 0x7e, 0xfe, 0x71, 0x13, 0xfe, 0x24, 0x1c, 0x15, 0x19, 0x39,
+	0xa0, 0xb4, 0xfe, 0xd9,
+	0x10, 0xc3, 0xfe, 0x03, 0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x04,
+	0xc3, 0xfe, 0x03, 0xdc,
+	0xfe, 0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x04, 0xfe, 0x03, 0x57, 0xc3, 0x21,
+	0xfe, 0x00, 0xcc, 0x04,
+	0xfe, 0x03, 0x57, 0xc3, 0x78, 0x04, 0x08, 0x05, 0x58, 0xfe, 0x22, 0x13,
+	0xfe, 0x1c, 0x80, 0x07,
+	0x06, 0xfe, 0x1a, 0x13, 0xfe, 0x1e, 0x80, 0xed, 0xfe, 0x1d, 0x80, 0xae,
+	0xfe, 0x0c, 0x90, 0xfe,
+	0x0e, 0x13, 0xfe, 0x0e, 0x90, 0xac, 0xfe, 0x3c, 0x90, 0xfe, 0x30, 0xf4,
+	0x0a, 0xfe, 0x3c, 0x50,
+	0xaa, 0x01, 0xfe, 0x7a, 0x17, 0x32, 0x07, 0x2f, 0xad, 0x01, 0xfe, 0xb4,
+	0x16, 0x08, 0x05, 0x1b,
+	0x4e, 0x01, 0xf5, 0x01, 0xf6, 0x12, 0xfe, 0xe9, 0x00, 0x08, 0x05, 0x58,
+	0xfe, 0x2c, 0x13, 0x01,
+	0xfe, 0x0c, 0x17, 0xfe, 0x1e, 0x1c, 0xfe, 0x14, 0x90, 0xfe, 0x96, 0x90,
+	0x0c, 0xfe, 0x64, 0x01,
+	0x14, 0xfe, 0x66, 0x01, 0x08, 0x05, 0x5b, 0xfe, 0x12, 0x12, 0xfe, 0x03,
+	0x80, 0x8d, 0xfe, 0x01,
+	0xec, 0x20, 0xfe, 0x80, 0x40, 0x13, 0x20, 0x6a, 0x2a, 0x12, 0xcf, 0x64,
+	0x22, 0x20, 0xfb, 0x79,
+	0x20, 0x04, 0xfe, 0x08, 0x1c, 0x03, 0xfe, 0xac, 0x00, 0xfe, 0x06, 0x58,
+	0x03, 0xfe, 0xae, 0x00,
+
+	0xfe, 0x07, 0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe, 0x08, 0x58, 0x03, 0xfe,
+	0xb2, 0x00, 0xfe, 0x09,
+	0x58, 0xfe, 0x0a, 0x1c, 0x25, 0x6e, 0x13, 0xd0, 0x21, 0x0c, 0x5c, 0x0c,
+	0x45, 0x0f, 0x46, 0x52,
+	0x50, 0x18, 0x1b, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x23, 0xfe, 0xfc,
+	0x0f, 0x44, 0x11, 0x0f,
+	0x48, 0x52, 0x18, 0x58, 0xfe, 0x90, 0x4d, 0xfe, 0x91, 0x54, 0x23, 0xe4,
+	0x25, 0x11, 0x13, 0x20,
+	0x7c, 0x6f, 0x4f, 0x22, 0x20, 0xfb, 0x79, 0x20, 0x12, 0xcf, 0xfe, 0x14,
+	0x56, 0xfe, 0xd6, 0xf0,
+	0xfe, 0x26, 0x10, 0xf8, 0x74, 0xfe, 0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe,
+	0x18, 0x1c, 0x04, 0x42,
+	0xfe, 0x0c, 0x14, 0xfc, 0xfe, 0x07, 0xe6, 0x1b, 0xfe, 0xce, 0x47, 0xfe,
+	0xf5, 0x13, 0x04, 0x01,
+	0xb0, 0x7c, 0x6f, 0x4f, 0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42,
+	0x13, 0x32, 0x07, 0x2f,
+	0xfe, 0x34, 0x13, 0x09, 0x48, 0x01, 0x0e, 0xbb, 0xfe, 0x36, 0x12, 0xfe,
+	0x41, 0x48, 0xfe, 0x45,
+	0x48, 0x01, 0xf0, 0xfe, 0x00, 0xcc, 0xbb, 0xfe, 0xf3, 0x13, 0x43, 0x78,
+	0x07, 0x11, 0xac, 0x09,
+	0x84, 0x01, 0x0e, 0xfe, 0x80, 0x5c, 0x01, 0x73, 0xfe, 0x0e, 0x10, 0x07,
+	0x82, 0x4e, 0xfe, 0x14,
+	0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x60, 0x10, 0x04, 0xfe, 0x44, 0x58, 0x8d,
+	0xfe, 0x01, 0xec, 0xa2,
+	0xfe, 0x9e, 0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x1a, 0x79,
+	0x2a, 0x01, 0xe3, 0xfe,
+	0xdd, 0x10, 0x2c, 0xc7, 0x81, 0xc8, 0x83, 0x33, 0x31, 0xde, 0x07, 0x1a,
+	0xfe, 0x48, 0x12, 0x07,
+	0x0a, 0xfe, 0x56, 0x12, 0x07, 0x19, 0xfe, 0x30, 0x12, 0x07, 0xc9, 0x17,
+	0xfe, 0x32, 0x12, 0x07,
+	0xfe, 0x23, 0x00, 0x17, 0xeb, 0x07, 0x06, 0x17, 0xfe, 0x9c, 0x12, 0x07,
+	0x1f, 0xfe, 0x12, 0x12,
+	0x07, 0x00, 0x17, 0x24, 0x15, 0xc9, 0x01, 0x36, 0xa9, 0x2d, 0x01, 0x0b,
+	0x94, 0x4b, 0x04, 0x2d,
+	0xdd, 0x09, 0xd1, 0x01, 0xfe, 0x26, 0x0f, 0x12, 0x82, 0x02, 0x2b, 0x2d,
+	0x32, 0x07, 0xa6, 0xfe,
+	0xd9, 0x13, 0x3a, 0x3d, 0x3b, 0x3e, 0x56, 0xfe, 0xf0, 0x11, 0x08, 0x05,
+	0x5a, 0xfe, 0x72, 0x12,
+	0x9b, 0x2e, 0x9c, 0x3c, 0x90, 0xc0, 0x96, 0xfe, 0xba, 0x11, 0x22, 0x62,
+	0xfe, 0x26, 0x13, 0x03,
+	0x7f, 0x29, 0x80, 0x56, 0xfe, 0x76, 0x0d, 0x0c, 0x60, 0x14, 0x61, 0x21,
+	0x0c, 0x7f, 0x0c, 0x80,
+	0x01, 0xb3, 0x25, 0x6e, 0x77, 0x13, 0x62, 0x01, 0xef, 0x9b, 0x2e, 0x9c,
+	0x3c, 0xfe, 0x04, 0x55,
+	0xfe, 0xa5, 0x55, 0xfe, 0x04, 0xfa, 0x2e, 0xfe, 0x05, 0xfa, 0x3c, 0xfe,
+	0x91, 0x10, 0x03, 0x3f,
+	0x29, 0x40, 0xfe, 0x40, 0x56, 0xfe, 0xe1, 0x56, 0x0c, 0x3f, 0x14, 0x40,
+	0x88, 0x9b, 0x2e, 0x9c,
+	0x3c, 0x90, 0xc0, 0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x00, 0x56, 0xfe, 0xa1,
+	0x56, 0x0c, 0x5e, 0x14,
+	0x5f, 0x08, 0x05, 0x5a, 0xfe, 0x1e, 0x12, 0x22, 0x62, 0xfe, 0x1f, 0x40,
+	0x03, 0x60, 0x29, 0x61,
+	0xfe, 0x2c, 0x50, 0xfe, 0xae, 0x50, 0x03, 0x3f, 0x29, 0x40, 0xfe, 0x44,
+	0x50, 0xfe, 0xc6, 0x50,
+	0x03, 0x5e, 0x29, 0x5f, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x03, 0x3d,
+	0x29, 0x3e, 0xfe, 0x40,
+	0x50, 0xfe, 0xc2, 0x50, 0x02, 0x89, 0x25, 0x06, 0x13, 0xd4, 0x02, 0x72,
+	0x2d, 0x01, 0x0b, 0x1d,
+	0x4c, 0x33, 0x31, 0xde, 0x07, 0x06, 0x23, 0x4c, 0x32, 0x07, 0xa6, 0x23,
+	0x72, 0x01, 0xaf, 0x1e,
+	0x43, 0x17, 0x4c, 0x08, 0x05, 0x0a, 0xee, 0x3a, 0x3d, 0x3b, 0x3e, 0xfe,
+	0x0a, 0x55, 0x35, 0xfe,
+	0x8b, 0x55, 0x57, 0x3d, 0x7d, 0x3e, 0xfe, 0x0c, 0x51, 0xfe, 0x8e, 0x51,
+	0x02, 0x72, 0xfe, 0x19,
+	0x81, 0xba, 0xfe, 0x19, 0x41, 0x02, 0x72, 0x2d, 0x01, 0x0b, 0x1c, 0x34,
+	0x1d, 0xe8, 0x33, 0x31,
+	0xe1, 0x55, 0x19, 0xfe, 0xa6, 0x12, 0x55, 0x0a, 0x4d, 0x02, 0x4c, 0x01,
+	0x0b, 0x1c, 0x34, 0x1d,
+	0xe8, 0x33, 0x31, 0xdf, 0x07, 0x19, 0x23, 0x4c, 0x01, 0x0b, 0x1d, 0xe8,
+	0x33, 0x31, 0xfe, 0xe8,
+	0x09, 0xfe, 0xc2, 0x49, 0x51, 0x03, 0xfe, 0x9c, 0x00, 0x28, 0x8a, 0x53,
+	0x05, 0x1f, 0x35, 0xa9,
+	0xfe, 0xbb, 0x45, 0x55, 0x00, 0x4e, 0x44, 0x06, 0x7c, 0x43, 0xfe, 0xda,
+	0x14, 0x01, 0xaf, 0x8c,
+	0xfe, 0x4b, 0x45, 0xee, 0x32, 0x07, 0xa5, 0xed, 0x03, 0xcd, 0x28, 0x8a,
+	0x03, 0x45, 0x28, 0x35,
+	0x67, 0x02, 0x72, 0xfe, 0xc0, 0x5d, 0xfe, 0xf8, 0x14, 0xfe, 0x03, 0x17,
+	0x03, 0x5c, 0xc1, 0x0c,
+	0x5c, 0x67, 0x2d, 0x01, 0x0b, 0x26, 0x89, 0x01, 0xfe, 0x9e, 0x15, 0x02,
+	0x89, 0x01, 0x0b, 0x1c,
+	0x34, 0x1d, 0x4c, 0x33, 0x31, 0xdf, 0x07, 0x06, 0x23, 0x4c, 0x01, 0xf1,
+	0xfe, 0x42, 0x58, 0xf1,
+	0xfe, 0xa4, 0x14, 0x8c, 0xfe, 0x4a, 0xf4, 0x0a, 0x17, 0x4c, 0xfe, 0x4a,
+	0xf4, 0x06, 0xea, 0x32,
+	0x07, 0xa5, 0x8b, 0x02, 0x72, 0x03, 0x45, 0xc1, 0x0c, 0x45, 0x67, 0x2d,
+	0x01, 0x0b, 0x26, 0x89,
+	0x01, 0xfe, 0xcc, 0x15, 0x02, 0x89, 0x0f, 0x06, 0x27, 0xfe, 0xbe, 0x13,
+	0x26, 0xfe, 0xd4, 0x13,
+	0x76, 0xfe, 0x89, 0x48, 0x01, 0x0b, 0x21, 0x76, 0x04, 0x7b, 0xfe, 0xd0,
+	0x13, 0x1c, 0xfe, 0xd0,
+	0x13, 0x1d, 0xfe, 0xbe, 0x13, 0x67, 0x2d, 0x01, 0x0b, 0xfe, 0xd5, 0x10,
+	0x0f, 0x71, 0xff, 0x02,
+	0x00, 0x57, 0x52, 0x93, 0x1e, 0xfe, 0xff, 0x7f, 0xfe, 0x30, 0x56, 0xfe,
+	0x00, 0x5c, 0x04, 0x0f,
+	0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x1e, 0x43, 0xfe, 0x30, 0x56,
+	0xfe, 0x00, 0x5c, 0x04,
+	0x0f, 0x71, 0xff, 0x02, 0x00, 0x57, 0x52, 0x93, 0x04, 0x0f, 0x71, 0xff,
+	0x02, 0x00, 0x57, 0x52,
+	0x93, 0xfe, 0x0b, 0x58, 0x04, 0x09, 0x5c, 0x01, 0x87, 0x09, 0x45, 0x01,
+	0x87, 0x04, 0xfe, 0x03,
+	0xa1, 0x1e, 0x11, 0xff, 0x03, 0x00, 0x54, 0xfe, 0x00, 0xf4, 0x1f, 0x52,
+	0xfe, 0x00, 0x7d, 0xfe,
+	0x01, 0x7d, 0xfe, 0x02, 0x7d, 0xfe, 0x03, 0x7c, 0x6a, 0x2a, 0x0c, 0x5e,
+	0x14, 0x5f, 0x57, 0x3f,
+	0x7d, 0x40, 0x04, 0xdd, 0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83,
+	0x5a, 0x8d, 0x04, 0x01,
+	0xfe, 0x0c, 0x19, 0xfe, 0x42, 0x48, 0x50, 0x51, 0x91, 0x01, 0x0b, 0x1d,
+	0xfe, 0x96, 0x15, 0x33,
+	0x31, 0xe1, 0x01, 0x0b, 0x1d, 0xfe, 0x96, 0x15, 0x33, 0x31, 0xfe, 0xe8,
+	0x0a, 0xfe, 0xc1, 0x59,
+	0x03, 0xcd, 0x28, 0xfe, 0xcc, 0x12, 0x53, 0x05, 0x1a, 0xfe, 0xc4, 0x13,
+	0x21, 0x69, 0x1a, 0xee,
+	0x55, 0xca, 0x6b, 0xfe, 0xdc, 0x14, 0x4d, 0x0f, 0x06, 0x18, 0xca, 0x7c,
+	0x30, 0xfe, 0x78, 0x10,
+	0xff, 0x02, 0x83, 0x55, 0xab, 0xff, 0x02, 0x83, 0x55, 0x69, 0x19, 0xae,
+	0x98, 0xfe, 0x30, 0x00,
+	0x96, 0xf2, 0x18, 0x6d, 0x0f, 0x06, 0xfe, 0x56, 0x10, 0x69, 0x0a, 0xed,
+	0x98, 0xfe, 0x64, 0x00,
+	0x96, 0xf2, 0x09, 0xfe, 0x64, 0x00, 0x18, 0x9e, 0x0f, 0x06, 0xfe, 0x28,
+	0x10, 0x69, 0x06, 0xfe,
+	0x60, 0x13, 0x98, 0xfe, 0xc8, 0x00, 0x96, 0xf2, 0x09, 0xfe, 0xc8, 0x00,
+	0x18, 0x59, 0x0f, 0x06,
+	0x88, 0x98, 0xfe, 0x90, 0x01, 0x7a, 0xfe, 0x42, 0x15, 0x91, 0xe4, 0xfe,
+	0x43, 0xf4, 0x9f, 0xfe,
+	0x56, 0xf0, 0xfe, 0x54, 0x15, 0xfe, 0x04, 0xf4, 0x71, 0xfe, 0x43, 0xf4,
+	0x9e, 0xfe, 0xf3, 0x10,
+	0xfe, 0x40, 0x5c, 0x01, 0xfe, 0x16, 0x14, 0x1e, 0x43, 0xec, 0xfe, 0x00,
+	0x17, 0xfe, 0x4d, 0xe4,
+	0x6e, 0x7a, 0xfe, 0x90, 0x15, 0xc4, 0x6e, 0xfe, 0x1c, 0x10, 0xfe, 0x00,
+	0x17, 0xfe, 0x4d, 0xe4,
+	0xcc, 0x7a, 0xfe, 0x90, 0x15, 0xc4, 0xcc, 0x88, 0x51, 0x21, 0xfe, 0x4d,
+	0xf4, 0x00, 0xe9, 0x91,
+	0x0f, 0x06, 0xfe, 0xb4, 0x56, 0xfe, 0xc3, 0x58, 0x04, 0x51, 0x0f, 0x0a,
+	0x04, 0x16, 0x06, 0x01,
+	0x0b, 0x26, 0xf3, 0x16, 0x0a, 0x01, 0x0b, 0x26, 0xf3, 0x16, 0x19, 0x01,
+	0x0b, 0x26, 0xf3, 0x76,
+	0xfe, 0x89, 0x49, 0x01, 0x0b, 0x04, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1,
+	0x16, 0x19, 0x01, 0x0b,
+	0x26, 0xb1, 0x16, 0x06, 0x01, 0x0b, 0x26, 0xb1, 0xfe, 0x89, 0x49, 0x01,
+	0x0b, 0x26, 0xb1, 0x76,
+	0xfe, 0x89, 0x4a, 0x01, 0x0b, 0x04, 0x51, 0x04, 0x22, 0xd3, 0x07, 0x06,
+	0xfe, 0x48, 0x13, 0xb8,
+	0x13, 0xd3, 0xfe, 0x49, 0xf4, 0x00, 0x4d, 0x76, 0xa9, 0x67, 0xfe, 0x01,
+	0xec, 0xfe, 0x27, 0x01,
+	0xfe, 0x89, 0x48, 0xff, 0x02, 0x00, 0x10, 0x27, 0xfe, 0x2e, 0x16, 0x32,
+	0x07, 0xfe, 0xe3, 0x00,
+	0xfe, 0x20, 0x13, 0x1d, 0xfe, 0x52, 0x16, 0x21, 0x13, 0xd4, 0x01, 0x4b,
+	0x22, 0xd4, 0x07, 0x06,
+	0x4e, 0x08, 0x54, 0x06, 0x37, 0x04, 0x09, 0x48, 0x01, 0x0e, 0xfb, 0x8e,
+	0x07, 0x11, 0xae, 0x09,
+	0x84, 0x01, 0x0e, 0x8e, 0x09, 0x5d, 0x01, 0xa8, 0x04, 0x09, 0x84, 0x01,
+	0x0e, 0x8e, 0xfe, 0x80,
+	0xe7, 0x11, 0x07, 0x11, 0x8a, 0xfe, 0x45, 0x58, 0x01, 0xf0, 0x8e, 0x04,
+	0x09, 0x48, 0x01, 0x0e,
+	0x8e, 0x09, 0x5d, 0x01, 0xa8, 0x04, 0x09, 0x48, 0x01, 0x0e, 0xfe, 0x80,
+	0x80, 0xfe, 0x80, 0x4c,
+	0xfe, 0x49, 0xe4, 0x11, 0xae, 0x09, 0x84, 0x01, 0x0e, 0xfe, 0x80, 0x4c,
+	0x09, 0x5d, 0x01, 0x87,
+	0x04, 0x18, 0x11, 0x75, 0x6c, 0xfe, 0x60, 0x01, 0xfe, 0x18, 0xdf, 0xfe,
+	0x19, 0xde, 0xfe, 0x24,
+	0x1c, 0xfe, 0x1d, 0xf7, 0x1b, 0x97, 0xfe, 0xee, 0x16, 0x01, 0xfe, 0xf4,
+	0x17, 0xad, 0x9a, 0x1b,
+	0x6c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x04, 0xb9, 0x23, 0xfe, 0xde,
+	0x16, 0xfe, 0xda, 0x10,
+	0x18, 0x11, 0x75, 0x03, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x1f, 0xfe,
+	0x18, 0x58, 0x03, 0xfe,
+	0x66, 0x01, 0xfe, 0x19, 0x58, 0x9a, 0x1f, 0xfe, 0x3c, 0x90, 0xfe, 0x30,
+	0xf4, 0x06, 0xfe, 0x3c,
+	0x50, 0x6c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7, 0x1f,
+	0x97, 0xfe, 0x38, 0x17,
+	0xfe, 0xb6, 0x14, 0x35, 0x04, 0xb9, 0x23, 0xfe, 0x10, 0x17, 0xfe, 0x9c,
+	0x10, 0x18, 0x11, 0x75,
+	0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe, 0x1d, 0xf7,
+	0x2e, 0x97, 0xfe, 0x5a,
+	0x17, 0xfe, 0x94, 0x14, 0xec, 0x9a, 0x2e, 0x6c, 0x1a, 0xfe, 0xaf, 0x19,
+	0xfe, 0x98, 0xe7, 0x00,
+	0x04, 0xb9, 0x23, 0xfe, 0x4e, 0x17, 0xfe, 0x6c, 0x10, 0x18, 0x11, 0x75,
+	0xfe, 0x30, 0xbc, 0xfe,
+	0xb2, 0xbc, 0x9a, 0xcb, 0x6c, 0x1a, 0xfe, 0x0f, 0x79, 0xfe, 0x1c, 0xf7,
+	0xcb, 0x97, 0xfe, 0x92,
+	0x17, 0xfe, 0x5c, 0x14, 0x35, 0x04, 0xb9, 0x23, 0xfe, 0x7e, 0x17, 0xfe,
+	0x42, 0x10, 0xfe, 0x02,
+	0xf6, 0x11, 0x75, 0xfe, 0x18, 0xfe, 0x60, 0xfe, 0x19, 0xfe, 0x61, 0xfe,
+	0x03, 0xa1, 0xfe, 0x1d,
+	0xf7, 0x5b, 0x97, 0xfe, 0xb8, 0x17, 0xfe, 0x36, 0x14, 0xfe, 0x1c, 0x13,
+	0x9a, 0x5b, 0x41, 0xfe,
+	0x83, 0x58, 0xfe, 0xaf, 0x19, 0xfe, 0x80, 0xe7, 0x11, 0xfe, 0x81, 0xe7,
+	0x11, 0x12, 0xfe, 0xdd,
+	0x00, 0x6a, 0x2a, 0x04, 0x6a, 0x2a, 0xfe, 0x12, 0x45, 0x23, 0xfe, 0xa8,
+	0x17, 0x15, 0x06, 0x39,
+	0xa0, 0xb4, 0x02, 0x2b, 0xfe, 0x39, 0xf0, 0xfe, 0xfc, 0x17, 0x21, 0x04,
+	0xfe, 0x7e, 0x18, 0x1e,
+	0x19, 0x66, 0x0f, 0x0d, 0x04, 0x75, 0x03, 0xd2, 0x1e, 0x06, 0xfe, 0xef,
+	0x12, 0xfe, 0xe1, 0x10,
+	0x7c, 0x6f, 0x4f, 0x32, 0x07, 0x2f, 0xfe, 0x3c, 0x13, 0xf1, 0xfe, 0x42,
+	0x13, 0x42, 0x92, 0x09,
+	0x48, 0x01, 0x0e, 0xbb, 0xeb, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01,
+	0xf0, 0xfe, 0x00, 0xcc,
+	0xbb, 0xfe, 0xf3, 0x13, 0x43, 0x78, 0x07, 0x11, 0xac, 0x09, 0x84, 0x01,
+	0x0e, 0xfe, 0x80, 0x4c,
+	0x01, 0x73, 0xfe, 0x16, 0x10, 0x07, 0x82, 0x8b, 0xfe, 0x40, 0x14, 0xfe,
+	0x24, 0x12, 0xfe, 0x14,
+	0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0x1c, 0x18, 0x18, 0x0a, 0x04, 0xfe, 0x9c,
+	0xe7, 0x0a, 0x10, 0xfe,
+	0x15, 0x00, 0x64, 0x79, 0x2a, 0x01, 0xe3, 0x18, 0x06, 0x04, 0x42, 0x92,
+	0x08, 0x54, 0x1b, 0x37,
+	0x12, 0x2f, 0x01, 0x73, 0x18, 0x06, 0x04, 0xfe, 0x38, 0x90, 0xfe, 0xba,
+	0x90, 0x3a, 0xce, 0x3b,
+	0xcf, 0xfe, 0x48, 0x55, 0x35, 0xfe, 0xc9, 0x55, 0x04, 0x22, 0xa3, 0x77,
+	0x13, 0xa3, 0x04, 0x09,
+	0xa4, 0x01, 0x0e, 0xfe, 0x41, 0x48, 0x09, 0x46, 0x01, 0x0e, 0xfe, 0x49,
+	0x44, 0x17, 0xfe, 0xe8,
+	0x18, 0x77, 0x78, 0x04, 0x09, 0x48, 0x01, 0x0e, 0x07, 0x11, 0x4e, 0x09,
+	0x5d, 0x01, 0xa8, 0x09,
+	0x46, 0x01, 0x0e, 0x77, 0x78, 0x04, 0xfe, 0x4e, 0xe4, 0x19, 0x6b, 0xfe,
+	0x1c, 0x19, 0x03, 0xfe,
+	0x90, 0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10, 0xfe, 0x4e, 0xe4, 0xc9,
+	0x6b, 0xfe, 0x2e, 0x19,
+	0x03, 0xfe, 0x92, 0x00, 0xfe, 0x02, 0xe6, 0x1a, 0xe5, 0xfe, 0x4e, 0xe4,
+	0xfe, 0x0b, 0x00, 0x6b,
+	0xfe, 0x40, 0x19, 0x03, 0xfe, 0x94, 0x00, 0xfe, 0x02, 0xe6, 0x1f, 0xfe,
+	0x08, 0x10, 0x03, 0xfe,
+	0x96, 0x00, 0xfe, 0x02, 0xe6, 0x6d, 0xfe, 0x4e, 0x45, 0xea, 0xba, 0xff,
+	0x04, 0x68, 0x54, 0xe7,
+	0x1e, 0x6e, 0xfe, 0x08, 0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c, 0xfe,
+	0x1a, 0xf4, 0xfe, 0x00,
+	0x04, 0xea, 0xfe, 0x48, 0xf4, 0x19, 0x7a, 0xfe, 0x74, 0x19, 0x0f, 0x19,
+	0x04, 0x07, 0x7e, 0xfe,
+	0x5a, 0xf0, 0xfe, 0x84, 0x19, 0x25, 0xfe, 0x09, 0x00, 0xfe, 0x34, 0x10,
+	0x07, 0x1a, 0xfe, 0x5a,
+	0xf0, 0xfe, 0x92, 0x19, 0x25, 0xca, 0xfe, 0x26, 0x10, 0x07, 0x19, 0x66,
+	0x25, 0x6d, 0xe5, 0x07,
+	0x0a, 0x66, 0x25, 0x9e, 0xfe, 0x0e, 0x10, 0x07, 0x06, 0x66, 0x25, 0x59,
+	0xa9, 0xb8, 0x04, 0x15,
+	0xfe, 0x09, 0x00, 0x01, 0x36, 0xfe, 0x04, 0xfe, 0x81, 0x03, 0x83, 0xfe,
+	0x40, 0x5c, 0x04, 0x1c,
+	0xf7, 0xfe, 0x14, 0xf0, 0x0b, 0x27, 0xfe, 0xd6, 0x19, 0x1c, 0xf7, 0x7b,
+	0xf7, 0xfe, 0x82, 0xf0,
+	0xfe, 0xda, 0x19, 0x04, 0xff, 0xcc, 0x00, 0x00,
 };
 
-STATIC unsigned short _adv_asc38C0800_size =
-        sizeof(_adv_asc38C0800_buf); /* 0x14E1 */
-STATIC ADV_DCNT _adv_asc38C0800_chksum =
-        0x050D3FD8UL; /* Expanded little-endian checksum. */
+static unsigned short _adv_asc38C0800_size = sizeof(_adv_asc38C0800_buf);	/* 0x14E1 */
+static ADV_DCNT _adv_asc38C0800_chksum = 0x050D3FD8UL;	/* Expanded little-endian checksum. */
 
 /* Microcode buffer is kept after initialization for error recovery. */
-STATIC unsigned char _adv_asc38C1600_buf[] = {
-  0x00,  0x00,  0x00,  0xf2,  0x00,  0x16,  0x00,  0xfc,  0x00,  0x10,  0x00,  0xf0,  0x18,  0xe4,  0x01,  0x00,
-  0x04,  0x1e,  0x48,  0xe4,  0x03,  0xf6,  0xf7,  0x13,  0x2e,  0x1e,  0x02,  0x00,  0x07,  0x17,  0xc0,  0x5f,
-  0x00,  0xfa,  0xff,  0xff,  0x04,  0x00,  0x00,  0xf6,  0x09,  0xe7,  0x82,  0xe7,  0x85,  0xf0,  0x86,  0xf0,
-  0x4e,  0x10,  0x9e,  0xe7,  0xff,  0x00,  0x55,  0xf0,  0x01,  0xf6,  0x03,  0x00,  0x98,  0x57,  0x01,  0xe6,
-  0x00,  0xea,  0x00,  0xec,  0x01,  0xfa,  0x18,  0xf4,  0x08,  0x00,  0xf0,  0x1d,  0x38,  0x54,  0x32,  0xf0,
-  0x10,  0x00,  0xc2,  0x0e,  0x1e,  0xf0,  0xd5,  0xf0,  0xbc,  0x00,  0x4b,  0xe4,  0x00,  0xe6,  0xb1,  0xf0,
-  0xb4,  0x00,  0x02,  0x13,  0x3e,  0x1c,  0xc8,  0x47,  0x3e,  0x00,  0xd8,  0x01,  0x06,  0x13,  0x0c,  0x1c,
-  0x5e,  0x1e,  0x00,  0x57,  0xc8,  0x57,  0x01,  0xfc,  0xbc,  0x0e,  0xa2,  0x12,  0xb9,  0x54,  0x00,  0x80,
-  0x62,  0x0a,  0x5a,  0x12,  0xc8,  0x15,  0x3e,  0x1e,  0x18,  0x40,  0xbd,  0x56,  0x03,  0xe6,  0x01,  0xea,
-  0x5c,  0xf0,  0x0f,  0x00,  0x20,  0x00,  0x6c,  0x01,  0x6e,  0x01,  0x04,  0x12,  0x04,  0x13,  0xbb,  0x55,
-  0x3c,  0x56,  0x3e,  0x57,  0x03,  0x58,  0x4a,  0xe4,  0x40,  0x00,  0xb6,  0x00,  0xbb,  0x00,  0xc0,  0x00,
-  0x00,  0x01,  0x01,  0x01,  0x3e,  0x01,  0x58,  0x0a,  0x44,  0x10,  0x0a,  0x12,  0x4c,  0x1c,  0x4e,  0x1c,
-  0x02,  0x4a,  0x30,  0xe4,  0x05,  0xe6,  0x0c,  0x00,  0x3c,  0x00,  0x80,  0x00,  0x24,  0x01,  0x3c,  0x01,
-  0x68,  0x01,  0x6a,  0x01,  0x70,  0x01,  0x72,  0x01,  0x74,  0x01,  0x76,  0x01,  0x78,  0x01,  0x7c,  0x01,
-  0xc6,  0x0e,  0x0c,  0x10,  0xac,  0x12,  0xae,  0x12,  0x16,  0x1a,  0x32,  0x1c,  0x6e,  0x1e,  0x02,  0x48,
-  0x3a,  0x55,  0xc9,  0x57,  0x02,  0xee,  0x5b,  0xf0,  0x03,  0xf7,  0x06,  0xf7,  0x03,  0xfc,  0x06,  0x00,
-  0x1e,  0x00,  0xbe,  0x00,  0xe1,  0x00,  0x0c,  0x12,  0x18,  0x1a,  0x70,  0x1a,  0x30,  0x1c,  0x38,  0x1c,
-  0x10,  0x44,  0x00,  0x4c,  0xb0,  0x57,  0x40,  0x5c,  0x4d,  0xe4,  0x04,  0xea,  0x5d,  0xf0,  0xa7,  0xf0,
-  0x04,  0xf6,  0x02,  0xfc,  0x05,  0x00,  0x09,  0x00,  0x19,  0x00,  0x32,  0x00,  0x33,  0x00,  0x34,  0x00,
-  0x36,  0x00,  0x98,  0x00,  0x9e,  0x00,  0xcc,  0x00,  0x20,  0x01,  0x4e,  0x01,  0x79,  0x01,  0x3c,  0x09,
-  0x68,  0x0d,  0x02,  0x10,  0x04,  0x10,  0x3a,  0x10,  0x08,  0x12,  0x0a,  0x13,  0x40,  0x16,  0x50,  0x16,
-  0x00,  0x17,  0x4a,  0x19,  0x00,  0x4e,  0x00,  0x54,  0x01,  0x58,  0x00,  0xdc,  0x05,  0xf0,  0x09,  0xf0,
-  0x59,  0xf0,  0xb8,  0xf0,  0x48,  0xf4,  0x0e,  0xf7,  0x0a,  0x00,  0x9b,  0x00,  0x9c,  0x00,  0xa4,  0x00,
-  0xb5,  0x00,  0xba,  0x00,  0xd0,  0x00,  0xe7,  0x00,  0xf0,  0x03,  0x69,  0x08,  0xe9,  0x09,  0x5c,  0x0c,
-  0xb6,  0x12,  0xbc,  0x19,  0xd8,  0x1b,  0x20,  0x1c,  0x34,  0x1c,  0x36,  0x1c,  0x42,  0x1d,  0x08,  0x44,
-  0x38,  0x44,  0x91,  0x44,  0x0a,  0x45,  0x48,  0x46,  0x89,  0x48,  0x68,  0x54,  0x83,  0x55,  0x83,  0x59,
-  0x31,  0xe4,  0x02,  0xe6,  0x07,  0xf0,  0x08,  0xf0,  0x0b,  0xf0,  0x0c,  0xf0,  0x4b,  0xf4,  0x04,  0xf8,
-  0x05,  0xf8,  0x02,  0xfa,  0x03,  0xfa,  0x04,  0xfc,  0x05,  0xfc,  0x07,  0x00,  0xa8,  0x00,  0xaa,  0x00,
-  0xb9,  0x00,  0xe0,  0x00,  0xe5,  0x00,  0x22,  0x01,  0x26,  0x01,  0x60,  0x01,  0x7a,  0x01,  0x82,  0x01,
-  0xc8,  0x01,  0xca,  0x01,  0x86,  0x02,  0x6a,  0x03,  0x18,  0x05,  0xb2,  0x07,  0x68,  0x08,  0x10,  0x0d,
-  0x06,  0x10,  0x0a,  0x10,  0x0e,  0x10,  0x12,  0x10,  0x60,  0x10,  0xed,  0x10,  0xf3,  0x10,  0x06,  0x12,
-  0x10,  0x12,  0x1e,  0x12,  0x0c,  0x13,  0x0e,  0x13,  0x10,  0x13,  0xfe,  0x9c,  0xf0,  0x35,  0x05,  0xfe,
-  0xec,  0x0e,  0xff,  0x10,  0x00,  0x00,  0xe9,  0xfe,  0x34,  0x1f,  0x00,  0xe8,  0xfe,  0x88,  0x01,  0xff,
-  0x03,  0x00,  0x00,  0xfe,  0x93,  0x15,  0xfe,  0x0f,  0x05,  0xff,  0x38,  0x00,  0x00,  0xfe,  0x57,  0x24,
-  0x00,  0xfe,  0x4c,  0x00,  0x65,  0xff,  0x04,  0x00,  0x00,  0x1a,  0xff,  0x09,  0x00,  0x00,  0xff,  0x08,
-  0x01,  0x01,  0xff,  0x08,  0xff,  0xff,  0xff,  0x27,  0x00,  0x00,  0xff,  0x10,  0xff,  0xff,  0xff,  0x13,
-  0x00,  0x00,  0xfe,  0x78,  0x56,  0xfe,  0x34,  0x12,  0xff,  0x21,  0x00,  0x00,  0xfe,  0x04,  0xf7,  0xe8,
-  0x37,  0x7d,  0x0d,  0x01,  0xfe,  0x4a,  0x11,  0xfe,  0x04,  0xf7,  0xe8,  0x7d,  0x0d,  0x51,  0x37,  0xfe,
-  0x3d,  0xf0,  0xfe,  0x0c,  0x02,  0xfe,  0x20,  0xf0,  0xbc,  0xfe,  0x91,  0xf0,  0xfe,  0xf8,  0x01,  0xfe,
-  0x90,  0xf0,  0xfe,  0xf8,  0x01,  0xfe,  0x8f,  0xf0,  0xbc,  0x03,  0x67,  0x4d,  0x05,  0xfe,  0x08,  0x0f,
-  0x01,  0xfe,  0x78,  0x0f,  0xfe,  0xdd,  0x12,  0x05,  0xfe,  0x0e,  0x03,  0xfe,  0x28,  0x1c,  0x03,  0xfe,
-  0xa6,  0x00,  0xfe,  0xd1,  0x12,  0x3e,  0x22,  0xfe,  0xa6,  0x00,  0xac,  0xfe,  0x48,  0xf0,  0xfe,  0x90,
-  0x02,  0xfe,  0x49,  0xf0,  0xfe,  0xaa,  0x02,  0xfe,  0x4a,  0xf0,  0xfe,  0xc8,  0x02,  0xfe,  0x46,  0xf0,
-  0xfe,  0x5a,  0x02,  0xfe,  0x47,  0xf0,  0xfe,  0x60,  0x02,  0xfe,  0x43,  0xf0,  0xfe,  0x4e,  0x02,  0xfe,
-  0x44,  0xf0,  0xfe,  0x52,  0x02,  0xfe,  0x45,  0xf0,  0xfe,  0x56,  0x02,  0x1c,  0x0d,  0xa2,  0x1c,  0x07,
-  0x22,  0xb7,  0x05,  0x35,  0xfe,  0x00,  0x1c,  0xfe,  0xf1,  0x10,  0xfe,  0x02,  0x1c,  0xf5,  0xfe,  0x1e,
-  0x1c,  0xfe,  0xe9,  0x10,  0x01,  0x5f,  0xfe,  0xe7,  0x10,  0xfe,  0x06,  0xfc,  0xde,  0x0a,  0x81,  0x01,
-  0xa3,  0x05,  0x35,  0x1f,  0x95,  0x47,  0xb8,  0x01,  0xfe,  0xe4,  0x11,  0x0a,  0x81,  0x01,  0x5c,  0xfe,
-  0xbd,  0x10,  0x0a,  0x81,  0x01,  0x5c,  0xfe,  0xad,  0x10,  0xfe,  0x16,  0x1c,  0xfe,  0x58,  0x1c,  0x1c,
-  0x07,  0x22,  0xb7,  0x37,  0x2a,  0x35,  0xfe,  0x3d,  0xf0,  0xfe,  0x0c,  0x02,  0x2b,  0xfe,  0x9e,  0x02,
-  0xfe,  0x5a,  0x1c,  0xfe,  0x12,  0x1c,  0xfe,  0x14,  0x1c,  0x1f,  0xfe,  0x30,  0x00,  0x47,  0xb8,  0x01,
-  0xfe,  0xd4,  0x11,  0x1c,  0x07,  0x22,  0xb7,  0x05,  0xe9,  0x21,  0x2c,  0x09,  0x1a,  0x31,  0xfe,  0x69,
-  0x10,  0x1c,  0x07,  0x22,  0xb7,  0xfe,  0x04,  0xec,  0x2c,  0x60,  0x01,  0xfe,  0x1e,  0x1e,  0x20,  0x2c,
-  0xfe,  0x05,  0xf6,  0xde,  0x01,  0xfe,  0x62,  0x1b,  0x01,  0x0c,  0x61,  0x4a,  0x44,  0x15,  0x56,  0x51,
-  0x01,  0xfe,  0x9e,  0x1e,  0x01,  0xfe,  0x96,  0x1a,  0x05,  0x35,  0x0a,  0x57,  0x01,  0x18,  0x09,  0x00,
-  0x36,  0x01,  0x85,  0xfe,  0x18,  0x10,  0xfe,  0x41,  0x58,  0x0a,  0xba,  0x01,  0x18,  0xfe,  0xc8,  0x54,
-  0x7b,  0xfe,  0x1c,  0x03,  0x01,  0xfe,  0x96,  0x1a,  0x05,  0x35,  0x37,  0x60,  0xfe,  0x02,  0xe8,  0x30,
-  0xfe,  0xbf,  0x57,  0xfe,  0x9e,  0x43,  0xfe,  0x77,  0x57,  0xfe,  0x27,  0xf0,  0xfe,  0xe4,  0x01,  0xfe,
-  0x07,  0x4b,  0xfe,  0x20,  0xf0,  0xbc,  0xfe,  0x40,  0x1c,  0x2a,  0xeb,  0xfe,  0x26,  0xf0,  0xfe,  0x66,
-  0x03,  0xfe,  0xa0,  0xf0,  0xfe,  0x54,  0x03,  0xfe,  0x11,  0xf0,  0xbc,  0xfe,  0xef,  0x10,  0xfe,  0x9f,
-  0xf0,  0xfe,  0x74,  0x03,  0xfe,  0x46,  0x1c,  0x19,  0xfe,  0x11,  0x00,  0x05,  0x70,  0x37,  0xfe,  0x48,
-  0x1c,  0xfe,  0x46,  0x1c,  0x01,  0x0c,  0x06,  0x28,  0xfe,  0x18,  0x13,  0x26,  0x21,  0xb9,  0xc7,  0x20,
-  0xb9,  0x0a,  0x57,  0x01,  0x18,  0xc7,  0x89,  0x01,  0xfe,  0xc8,  0x1a,  0x15,  0xe1,  0x2a,  0xeb,  0xfe,
-  0x01,  0xf0,  0xeb,  0xfe,  0x82,  0xf0,  0xfe,  0xa4,  0x03,  0xfe,  0x9c,  0x32,  0x15,  0xfe,  0xe4,  0x00,
-  0x2f,  0xfe,  0xb6,  0x03,  0x2a,  0x3c,  0x16,  0xfe,  0xc6,  0x03,  0x01,  0x41,  0xfe,  0x06,  0xf0,  0xfe,
-  0xd6,  0x03,  0xaf,  0xa0,  0xfe,  0x0a,  0xf0,  0xfe,  0xa2,  0x07,  0x05,  0x29,  0x03,  0x81,  0x1e,  0x1b,
-  0xfe,  0x24,  0x05,  0x1f,  0x63,  0x01,  0x42,  0x8f,  0xfe,  0x70,  0x02,  0x05,  0xea,  0xfe,  0x46,  0x1c,
-  0x37,  0x7d,  0x1d,  0xfe,  0x67,  0x1b,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0xfe,  0x48,  0x1c,  0x75,
-  0x01,  0xa6,  0x86,  0x0a,  0x57,  0x01,  0x18,  0x09,  0x00,  0x1b,  0xec,  0x0a,  0xe1,  0x01,  0x18,  0x77,
-  0x50,  0x40,  0x8d,  0x30,  0x03,  0x81,  0x1e,  0xf8,  0x1f,  0x63,  0x01,  0x42,  0x8f,  0xfe,  0x70,  0x02,
-  0x05,  0xea,  0xd7,  0x99,  0xd8,  0x9c,  0x2a,  0x29,  0x2f,  0xfe,  0x4e,  0x04,  0x16,  0xfe,  0x4a,  0x04,
-  0x7e,  0xfe,  0xa0,  0x00,  0xfe,  0x9b,  0x57,  0xfe,  0x54,  0x12,  0x32,  0xff,  0x02,  0x00,  0x10,  0x01,
-  0x08,  0x16,  0xfe,  0x02,  0x05,  0x32,  0x01,  0x08,  0x16,  0x29,  0x27,  0x25,  0xee,  0xfe,  0x4c,  0x44,
-  0xfe,  0x58,  0x12,  0x50,  0xfe,  0x44,  0x48,  0x13,  0x34,  0xfe,  0x4c,  0x54,  0x7b,  0xec,  0x60,  0x8d,
-  0x30,  0x01,  0xfe,  0x4e,  0x1e,  0xfe,  0x48,  0x47,  0xfe,  0x7c,  0x13,  0x01,  0x0c,  0x06,  0x28,  0xfe,
-  0x32,  0x13,  0x01,  0x43,  0x09,  0x9b,  0xfe,  0x68,  0x13,  0xfe,  0x26,  0x10,  0x13,  0x34,  0xfe,  0x4c,
-  0x54,  0x7b,  0xec,  0x01,  0xfe,  0x4e,  0x1e,  0xfe,  0x48,  0x47,  0xfe,  0x54,  0x13,  0x01,  0x0c,  0x06,
-  0x28,  0xa5,  0x01,  0x43,  0x09,  0x9b,  0xfe,  0x40,  0x13,  0x01,  0x0c,  0x06,  0x28,  0xf9,  0x1f,  0x7f,
-  0x01,  0x0c,  0x06,  0x07,  0x4d,  0x1f,  0xfe,  0x0d,  0x00,  0x01,  0x42,  0x8f,  0xfe,  0xa4,  0x0e,  0x05,
-  0x29,  0x32,  0x15,  0xfe,  0xe6,  0x00,  0x0f,  0xfe,  0x1c,  0x90,  0x04,  0xfe,  0x9c,  0x93,  0x3a,  0x0b,
-  0x0e,  0x8b,  0x02,  0x1f,  0x7f,  0x01,  0x42,  0x05,  0x35,  0xfe,  0x42,  0x5b,  0x7d,  0x1d,  0xfe,  0x46,
-  0x59,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0x0f,  0xfe,  0x87,  0x80,  0x04,  0xfe,  0x87,  0x83,  0xfe,
-  0xc9,  0x47,  0x0b,  0x0e,  0xd0,  0x65,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x98,  0x13,  0x0f,  0xfe,  0x20,
-  0x80,  0x04,  0xfe,  0xa0,  0x83,  0x33,  0x0b,  0x0e,  0x09,  0x1d,  0xfe,  0x84,  0x12,  0x01,  0x38,  0x06,
-  0x07,  0xfe,  0x70,  0x13,  0x03,  0xfe,  0xa2,  0x00,  0x1e,  0x1b,  0xfe,  0xda,  0x05,  0xd0,  0x54,  0x01,
-  0x38,  0x06,  0x0d,  0xfe,  0x58,  0x13,  0x03,  0xfe,  0xa0,  0x00,  0x1e,  0xfe,  0x50,  0x12,  0x5e,  0xff,
-  0x02,  0x00,  0x10,  0x2f,  0xfe,  0x90,  0x05,  0x2a,  0x3c,  0xcc,  0xff,  0x02,  0x00,  0x10,  0x2f,  0xfe,
-  0x9e,  0x05,  0x17,  0xfe,  0xf4,  0x05,  0x15,  0xfe,  0xe3,  0x00,  0x26,  0x01,  0x38,  0xfe,  0x4a,  0xf0,
-  0xfe,  0xc0,  0x05,  0xfe,  0x49,  0xf0,  0xfe,  0xba,  0x05,  0x71,  0x2e,  0xfe,  0x21,  0x00,  0xf1,  0x2e,
-  0xfe,  0x22,  0x00,  0xa2,  0x2e,  0x4a,  0xfe,  0x09,  0x48,  0xff,  0x02,  0x00,  0x10,  0x2f,  0xfe,  0xd0,
-  0x05,  0x17,  0xfe,  0xf4,  0x05,  0xfe,  0xe2,  0x08,  0x01,  0x38,  0x06,  0xfe,  0x1c,  0x00,  0x4d,  0x01,
-  0xa7,  0x2e,  0x07,  0x20,  0xe4,  0x47,  0xfe,  0x27,  0x01,  0x01,  0x0c,  0x06,  0x28,  0xfe,  0x24,  0x12,
-  0x3e,  0x01,  0x84,  0x1f,  0x7f,  0x01,  0x0c,  0x06,  0x07,  0x4d,  0x1f,  0xfe,  0x0d,  0x00,  0x01,  0x42,
-  0x8f,  0xfe,  0xa4,  0x0e,  0x05,  0x29,  0x03,  0xe6,  0x1e,  0xfe,  0xca,  0x13,  0x03,  0xb6,  0x1e,  0xfe,
-  0x40,  0x12,  0x03,  0x66,  0x1e,  0xfe,  0x38,  0x13,  0x3e,  0x01,  0x84,  0x17,  0xfe,  0x72,  0x06,  0x0a,
-  0x07,  0x01,  0x38,  0x06,  0x24,  0xfe,  0x02,  0x12,  0x4f,  0x01,  0xfe,  0x56,  0x19,  0x16,  0xfe,  0x68,
-  0x06,  0x15,  0x82,  0x01,  0x41,  0x15,  0xe2,  0x03,  0x66,  0x8a,  0x10,  0x66,  0x03,  0x9a,  0x1e,  0xfe,
-  0x70,  0x12,  0x03,  0x55,  0x1e,  0xfe,  0x68,  0x13,  0x01,  0xc6,  0x09,  0x12,  0x48,  0xfe,  0x92,  0x06,
-  0x2e,  0x12,  0x01,  0xfe,  0xac,  0x1d,  0xfe,  0x43,  0x48,  0x62,  0x80,  0x13,  0x58,  0xff,  0x02,  0x00,
-  0x57,  0x52,  0xad,  0x23,  0x3f,  0x4e,  0x62,  0x49,  0x3e,  0x01,  0x84,  0x17,  0xfe,  0xea,  0x06,  0x01,
-  0x38,  0x06,  0x12,  0xf7,  0x45,  0x0a,  0x95,  0x01,  0xfe,  0x84,  0x19,  0x16,  0xfe,  0xe0,  0x06,  0x15,
-  0x82,  0x01,  0x41,  0x15,  0xe2,  0x03,  0x55,  0x8a,  0x10,  0x55,  0x1c,  0x07,  0x01,  0x84,  0xfe,  0xae,
-  0x10,  0x03,  0x6f,  0x1e,  0xfe,  0x9e,  0x13,  0x3e,  0x01,  0x84,  0x03,  0x9a,  0x1e,  0xfe,  0x1a,  0x12,
-  0x01,  0x38,  0x06,  0x12,  0xfc,  0x01,  0xc6,  0x01,  0xfe,  0xac,  0x1d,  0xfe,  0x43,  0x48,  0x62,  0x80,
-  0xf0,  0x45,  0x0a,  0x95,  0x03,  0xb6,  0x1e,  0xf8,  0x01,  0x38,  0x06,  0x24,  0x36,  0xfe,  0x02,  0xf6,
-  0x07,  0x71,  0x78,  0x8c,  0x00,  0x4d,  0x62,  0x49,  0x3e,  0x2d,  0x93,  0x4e,  0xd0,  0x0d,  0x17,  0xfe,
-  0x9a,  0x07,  0x01,  0xfe,  0xc0,  0x19,  0x16,  0xfe,  0x90,  0x07,  0x26,  0x20,  0x9e,  0x15,  0x82,  0x01,
-  0x41,  0x15,  0xe2,  0x21,  0x9e,  0x09,  0x07,  0xfb,  0x03,  0xe6,  0xfe,  0x58,  0x57,  0x10,  0xe6,  0x05,
-  0xfe,  0x2a,  0x06,  0x03,  0x6f,  0x8a,  0x10,  0x6f,  0x1c,  0x07,  0x01,  0x84,  0xfe,  0x9c,  0x32,  0x5f,
-  0x75,  0x01,  0xa6,  0x86,  0x15,  0xfe,  0xe2,  0x00,  0x2f,  0xed,  0x2a,  0x3c,  0xfe,  0x0a,  0xf0,  0xfe,
-  0xce,  0x07,  0xae,  0xfe,  0x96,  0x08,  0xfe,  0x06,  0xf0,  0xfe,  0x9e,  0x08,  0xaf,  0xa0,  0x05,  0x29,
-  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x2e,  0x12,  0x14,  0x1d,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0x14,
-  0x00,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0xfe,  0x99,  0xa4,  0x01,  0x08,  0x14,  0x00,  0x05,  0xfe,
-  0xc6,  0x09,  0x01,  0x76,  0x06,  0x12,  0xfe,  0x3a,  0x12,  0x01,  0x0c,  0x06,  0x12,  0xfe,  0x30,  0x13,
-  0x14,  0xfe,  0x1b,  0x00,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0x14,  0x00,
-  0x01,  0x08,  0x14,  0x07,  0x01,  0x08,  0x14,  0x00,  0x05,  0xef,  0x7c,  0x4a,  0x78,  0x4f,  0x0f,  0xfe,
-  0x9a,  0x81,  0x04,  0xfe,  0x9a,  0x83,  0xfe,  0xcb,  0x47,  0x0b,  0x0e,  0x2d,  0x28,  0x48,  0xfe,  0x6c,
-  0x08,  0x0a,  0x28,  0xfe,  0x09,  0x6f,  0xca,  0xfe,  0xca,  0x45,  0xfe,  0x32,  0x12,  0x53,  0x63,  0x4e,
-  0x7c,  0x97,  0x2f,  0xfe,  0x7e,  0x08,  0x2a,  0x3c,  0xfe,  0x0a,  0xf0,  0xfe,  0x6c,  0x08,  0xaf,  0xa0,
-  0xae,  0xfe,  0x96,  0x08,  0x05,  0x29,  0x01,  0x41,  0x05,  0xed,  0x14,  0x24,  0x05,  0xed,  0xfe,  0x9c,
-  0xf7,  0x9f,  0x01,  0xfe,  0xae,  0x1e,  0xfe,  0x18,  0x58,  0x01,  0xfe,  0xbe,  0x1e,  0xfe,  0x99,  0x58,
-  0xfe,  0x78,  0x18,  0xfe,  0xf9,  0x18,  0x8e,  0xfe,  0x16,  0x09,  0x10,  0x6a,  0x22,  0x6b,  0x01,  0x0c,
-  0x61,  0x54,  0x44,  0x21,  0x2c,  0x09,  0x1a,  0xf8,  0x77,  0x01,  0xfe,  0x7e,  0x1e,  0x47,  0x2c,  0x7a,
-  0x30,  0xf0,  0xfe,  0x83,  0xe7,  0xfe,  0x3f,  0x00,  0x71,  0xfe,  0x03,  0x40,  0x01,  0x0c,  0x61,  0x65,
-  0x44,  0x01,  0xc2,  0xc8,  0xfe,  0x1f,  0x40,  0x20,  0x6e,  0x01,  0xfe,  0x6a,  0x16,  0xfe,  0x08,  0x50,
-  0xfe,  0x8a,  0x50,  0xfe,  0x44,  0x51,  0xfe,  0xc6,  0x51,  0xfe,  0x10,  0x10,  0x01,  0xfe,  0xce,  0x1e,
-  0x01,  0xfe,  0xde,  0x1e,  0x10,  0x68,  0x22,  0x69,  0x01,  0xfe,  0xee,  0x1e,  0x01,  0xfe,  0xfe,  0x1e,
-  0xfe,  0x40,  0x50,  0xfe,  0xc2,  0x50,  0x10,  0x4b,  0x22,  0x4c,  0xfe,  0x8a,  0x10,  0x01,  0x0c,  0x06,
-  0x54,  0xfe,  0x50,  0x12,  0x01,  0xfe,  0xae,  0x1e,  0x01,  0xfe,  0xbe,  0x1e,  0x10,  0x6a,  0x22,  0x6b,
-  0x01,  0x0c,  0x06,  0x65,  0x4e,  0x01,  0xc2,  0x0f,  0xfe,  0x1f,  0x80,  0x04,  0xfe,  0x9f,  0x83,  0x33,
-  0x0b,  0x0e,  0x20,  0x6e,  0x0f,  0xfe,  0x44,  0x90,  0x04,  0xfe,  0xc4,  0x93,  0x3a,  0x0b,  0xfe,  0xc6,
-  0x90,  0x04,  0xfe,  0xc6,  0x93,  0x79,  0x0b,  0x0e,  0x10,  0x6c,  0x22,  0x6d,  0x01,  0xfe,  0xce,  0x1e,
-  0x01,  0xfe,  0xde,  0x1e,  0x10,  0x68,  0x22,  0x69,  0x0f,  0xfe,  0x40,  0x90,  0x04,  0xfe,  0xc0,  0x93,
-  0x3a,  0x0b,  0xfe,  0xc2,  0x90,  0x04,  0xfe,  0xc2,  0x93,  0x79,  0x0b,  0x0e,  0x10,  0x4b,  0x22,  0x4c,
-  0x10,  0x64,  0x22,  0x34,  0x01,  0x0c,  0x61,  0x24,  0x44,  0x37,  0x13,  0xfe,  0x4e,  0x11,  0x2f,  0xfe,
-  0xde,  0x09,  0xfe,  0x9e,  0xf0,  0xfe,  0xf2,  0x09,  0xfe,  0x01,  0x48,  0x1b,  0x3c,  0x37,  0x88,  0xf5,
-  0xd4,  0xfe,  0x1e,  0x0a,  0xd5,  0xfe,  0x42,  0x0a,  0xd2,  0xfe,  0x1e,  0x0a,  0xd3,  0xfe,  0x42,  0x0a,
-  0xae,  0xfe,  0x12,  0x0a,  0xfe,  0x06,  0xf0,  0xfe,  0x18,  0x0a,  0xaf,  0xa0,  0x05,  0x29,  0x01,  0x41,
-  0xfe,  0xc1,  0x10,  0x14,  0x24,  0xfe,  0xc1,  0x10,  0x01,  0x76,  0x06,  0x07,  0xfe,  0x14,  0x12,  0x01,
-  0x76,  0x06,  0x0d,  0x5d,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x74,  0x12,  0xfe,  0x2e,  0x1c,  0x05,  0xfe,
-  0x1a,  0x0c,  0x01,  0x76,  0x06,  0x07,  0x5d,  0x01,  0x76,  0x06,  0x0d,  0x41,  0xfe,  0x2c,  0x1c,  0xfe,
-  0xaa,  0xf0,  0xfe,  0xce,  0x0a,  0xfe,  0xac,  0xf0,  0xfe,  0x66,  0x0a,  0xfe,  0x92,  0x10,  0xc4,  0xf6,
-  0xfe,  0xad,  0xf0,  0xfe,  0x72,  0x0a,  0x05,  0xfe,  0x1a,  0x0c,  0xc5,  0xfe,  0xe7,  0x10,  0xfe,  0x2b,
-  0xf0,  0xbf,  0xfe,  0x6b,  0x18,  0x23,  0xfe,  0x00,  0xfe,  0xfe,  0x1c,  0x12,  0xac,  0xfe,  0xd2,  0xf0,
-  0xbf,  0xfe,  0x76,  0x18,  0x23,  0x1d,  0x1b,  0xbf,  0x03,  0xe3,  0x23,  0x07,  0x1b,  0xbf,  0xd4,  0x5b,
-  0xd5,  0x5b,  0xd2,  0x5b,  0xd3,  0x5b,  0xc4,  0xc5,  0xfe,  0xa9,  0x10,  0x75,  0x5e,  0x32,  0x1f,  0x7f,
-  0x01,  0x42,  0x19,  0xfe,  0x35,  0x00,  0xfe,  0x01,  0xf0,  0x70,  0x19,  0x98,  0x05,  0x70,  0xfe,  0x74,
-  0x18,  0x23,  0xfe,  0x00,  0xf8,  0x1b,  0x5b,  0x7d,  0x12,  0x01,  0xfe,  0x78,  0x0f,  0x4d,  0x01,  0xfe,
-  0x96,  0x1a,  0x21,  0x30,  0x77,  0x7d,  0x1d,  0x05,  0x5b,  0x01,  0x0c,  0x06,  0x0d,  0x2b,  0xfe,  0xe2,
-  0x0b,  0x01,  0x0c,  0x06,  0x54,  0xfe,  0xa6,  0x12,  0x01,  0x0c,  0x06,  0x24,  0xfe,  0x88,  0x13,  0x21,
-  0x6e,  0xc7,  0x01,  0xfe,  0x1e,  0x1f,  0x0f,  0xfe,  0x83,  0x80,  0x04,  0xfe,  0x83,  0x83,  0xfe,  0xc9,
-  0x47,  0x0b,  0x0e,  0xfe,  0xc8,  0x44,  0xfe,  0x42,  0x13,  0x0f,  0xfe,  0x04,  0x91,  0x04,  0xfe,  0x84,
-  0x93,  0xfe,  0xca,  0x57,  0x0b,  0xfe,  0x86,  0x91,  0x04,  0xfe,  0x86,  0x93,  0xfe,  0xcb,  0x57,  0x0b,
-  0x0e,  0x7a,  0x30,  0xfe,  0x40,  0x59,  0xfe,  0xc1,  0x59,  0x8e,  0x40,  0x03,  0x6a,  0x3b,  0x6b,  0x10,
-  0x97,  0x22,  0x98,  0xd9,  0x6a,  0xda,  0x6b,  0x01,  0xc2,  0xc8,  0x7a,  0x30,  0x20,  0x6e,  0xdb,  0x64,
-  0xdc,  0x34,  0x91,  0x6c,  0x7e,  0x6d,  0xfe,  0x44,  0x55,  0xfe,  0xe5,  0x55,  0xfe,  0x04,  0xfa,  0x64,
-  0xfe,  0x05,  0xfa,  0x34,  0x01,  0xfe,  0x6a,  0x16,  0xa3,  0x26,  0x10,  0x97,  0x10,  0x98,  0x91,  0x6c,
-  0x7e,  0x6d,  0xfe,  0x14,  0x10,  0x01,  0x0c,  0x06,  0x24,  0x1b,  0x40,  0x91,  0x4b,  0x7e,  0x4c,  0x01,
-  0x0c,  0x06,  0xfe,  0xf7,  0x00,  0x44,  0x03,  0x68,  0x3b,  0x69,  0xfe,  0x10,  0x58,  0xfe,  0x91,  0x58,
-  0xfe,  0x14,  0x59,  0xfe,  0x95,  0x59,  0x05,  0x5b,  0x01,  0x0c,  0x06,  0x24,  0x1b,  0x40,  0x01,  0x0c,
-  0x06,  0xfe,  0xf7,  0x00,  0x44,  0x78,  0x01,  0xfe,  0x8e,  0x1e,  0x4f,  0x0f,  0xfe,  0x10,  0x90,  0x04,
-  0xfe,  0x90,  0x93,  0x3a,  0x0b,  0xfe,  0x92,  0x90,  0x04,  0xfe,  0x92,  0x93,  0x79,  0x0b,  0x0e,  0xfe,
-  0xbd,  0x10,  0x01,  0x43,  0x09,  0xbb,  0x1b,  0xfe,  0x6e,  0x0a,  0x15,  0xbb,  0x01,  0x0c,  0x06,  0x0d,
-  0xfe,  0x14,  0x13,  0x03,  0x4b,  0x3b,  0x4c,  0x8e,  0xfe,  0x6e,  0x0a,  0xfe,  0x0c,  0x58,  0xfe,  0x8d,
-  0x58,  0x05,  0x5b,  0x26,  0x3e,  0x0f,  0xfe,  0x19,  0x80,  0x04,  0xfe,  0x99,  0x83,  0x33,  0x0b,  0x0e,
-  0xfe,  0xe5,  0x10,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x1a,  0x12,  0xfe,  0x6c,  0x19,  0xfe,  0x19,  0x41,
-  0xfe,  0x6b,  0x18,  0xac,  0xfe,  0xd1,  0xf0,  0xef,  0x1f,  0x92,  0x01,  0x42,  0x19,  0xfe,  0x44,  0x00,
-  0xfe,  0x90,  0x10,  0xfe,  0x6c,  0x19,  0xd9,  0x4b,  0xfe,  0xed,  0x19,  0xda,  0x4c,  0xfe,  0x0c,  0x51,
-  0xfe,  0x8e,  0x51,  0xfe,  0x6b,  0x18,  0x23,  0xfe,  0x00,  0xff,  0x31,  0xfe,  0x76,  0x10,  0xac,  0xfe,
-  0xd2,  0xf0,  0xfe,  0xba,  0x0c,  0xfe,  0x76,  0x18,  0x23,  0x1d,  0x5d,  0x03,  0xe3,  0x23,  0x07,  0xfe,
-  0x08,  0x13,  0x19,  0xfe,  0x16,  0x00,  0x05,  0x70,  0xfe,  0xd1,  0xf0,  0xfe,  0xcc,  0x0c,  0x1f,  0x92,
-  0x01,  0x42,  0x19,  0xfe,  0x17,  0x00,  0x5c,  0xfe,  0xce,  0xf0,  0xfe,  0xd2,  0x0c,  0xfe,  0x3e,  0x10,
-  0xfe,  0xcd,  0xf0,  0xfe,  0xde,  0x0c,  0x19,  0xfe,  0x22,  0x00,  0x05,  0x70,  0xfe,  0xcb,  0xf0,  0xfe,
-  0xea,  0x0c,  0x19,  0xfe,  0x24,  0x00,  0x05,  0x70,  0xfe,  0xd0,  0xf0,  0xfe,  0xf4,  0x0c,  0x19,  0x94,
-  0xfe,  0x1c,  0x10,  0xfe,  0xcf,  0xf0,  0xfe,  0xfe,  0x0c,  0x19,  0x4a,  0xf3,  0xfe,  0xcc,  0xf0,  0xef,
-  0x01,  0x76,  0x06,  0x24,  0x4d,  0x19,  0xfe,  0x12,  0x00,  0x37,  0x13,  0xfe,  0x4e,  0x11,  0x2f,  0xfe,
-  0x16,  0x0d,  0xfe,  0x9e,  0xf0,  0xfe,  0x2a,  0x0d,  0xfe,  0x01,  0x48,  0x1b,  0x3c,  0x37,  0x88,  0xf5,
-  0xd4,  0x29,  0xd5,  0x29,  0xd2,  0x29,  0xd3,  0x29,  0x37,  0xfe,  0x9c,  0x32,  0x2f,  0xfe,  0x3e,  0x0d,
-  0x2a,  0x3c,  0xae,  0xfe,  0x62,  0x0d,  0xaf,  0xa0,  0xd4,  0x9f,  0xd5,  0x9f,  0xd2,  0x9f,  0xd3,  0x9f,
-  0x05,  0x29,  0x01,  0x41,  0xfe,  0xd3,  0x10,  0x15,  0xfe,  0xe8,  0x00,  0xc4,  0xc5,  0x75,  0xd7,  0x99,
-  0xd8,  0x9c,  0xfe,  0x89,  0xf0,  0x29,  0x27,  0x25,  0xbe,  0xd7,  0x99,  0xd8,  0x9c,  0x2f,  0xfe,  0x8c,
-  0x0d,  0x16,  0x29,  0x27,  0x25,  0xbd,  0xfe,  0x01,  0x48,  0xa4,  0x19,  0xfe,  0x42,  0x00,  0x05,  0x70,
-  0x90,  0x07,  0xfe,  0x81,  0x49,  0x1b,  0xfe,  0x64,  0x0e,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x44,  0x13,
-  0x19,  0x00,  0x2d,  0x0d,  0xfe,  0x54,  0x12,  0x2d,  0xfe,  0x28,  0x00,  0x2b,  0xfe,  0xda,  0x0e,  0x0a,
-  0x57,  0x01,  0x18,  0x09,  0x00,  0x36,  0x46,  0xfe,  0x28,  0x00,  0xfe,  0xfa,  0x10,  0x01,  0xfe,  0xf4,
-  0x1c,  0x01,  0xfe,  0x00,  0x1d,  0x0a,  0xba,  0x01,  0xfe,  0x58,  0x10,  0x40,  0x15,  0x56,  0x01,  0x85,
-  0x05,  0x35,  0x19,  0xfe,  0x44,  0x00,  0x2d,  0x0d,  0xf7,  0x46,  0x0d,  0xfe,  0xcc,  0x10,  0x01,  0xa7,
-  0x46,  0x0d,  0xfe,  0xc2,  0x10,  0x01,  0xa7,  0x0f,  0xfe,  0x19,  0x82,  0x04,  0xfe,  0x99,  0x83,  0xfe,
-  0xcc,  0x47,  0x0b,  0x0e,  0xfe,  0x34,  0x46,  0xa5,  0x46,  0x0d,  0x19,  0xfe,  0x43,  0x00,  0xfe,  0xa2,
-  0x10,  0x01,  0x0c,  0x61,  0x0d,  0x44,  0x01,  0xfe,  0xf4,  0x1c,  0x01,  0xfe,  0x00,  0x1d,  0x40,  0x15,
-  0x56,  0x01,  0x85,  0x7d,  0x0d,  0x40,  0x51,  0x01,  0xfe,  0x9e,  0x1e,  0x05,  0xfe,  0x3a,  0x03,  0x01,
-  0x0c,  0x06,  0x0d,  0x5d,  0x46,  0x0d,  0x19,  0x00,  0xfe,  0x62,  0x10,  0x01,  0x76,  0x06,  0x12,  0xfe,
-  0x5c,  0x12,  0x01,  0x0c,  0x06,  0x12,  0xfe,  0x52,  0x13,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,
-  0x8e,  0x0e,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x94,  0x0e,  0x01,  0x0c,  0x61,  0x12,  0x44,
-  0xfe,  0x9f,  0x10,  0x19,  0xfe,  0x15,  0x00,  0xfe,  0x04,  0xe6,  0x0d,  0x4f,  0xfe,  0x2e,  0x10,  0x19,
-  0xfe,  0x13,  0x00,  0xfe,  0x10,  0x10,  0x19,  0xfe,  0x47,  0x00,  0xf1,  0x19,  0xfe,  0x41,  0x00,  0xa2,
-  0x19,  0xfe,  0x24,  0x00,  0x86,  0xc4,  0xc5,  0x75,  0x03,  0x81,  0x1e,  0x2b,  0xea,  0x4f,  0xfe,  0x04,
-  0xe6,  0x12,  0xfe,  0x9d,  0x41,  0xfe,  0x1c,  0x42,  0x40,  0x01,  0xf4,  0x05,  0x35,  0xfe,  0x12,  0x1c,
-  0x1f,  0x0d,  0x47,  0xb5,  0xc3,  0x1f,  0xfe,  0x31,  0x00,  0x47,  0xb8,  0x01,  0xfe,  0xd4,  0x11,  0x05,
-  0xe9,  0x51,  0xfe,  0x06,  0xec,  0xe0,  0xfe,  0x0e,  0x47,  0x46,  0x28,  0xfe,  0xce,  0x45,  0x31,  0x51,
-  0xfe,  0x06,  0xea,  0xe0,  0xfe,  0x47,  0x4b,  0x45,  0xfe,  0x75,  0x57,  0x03,  0x67,  0xfe,  0x98,  0x56,
-  0xfe,  0x38,  0x12,  0x0a,  0x5a,  0x01,  0x18,  0xfe,  0x44,  0x48,  0x60,  0x01,  0x0c,  0x06,  0x28,  0xfe,
-  0x18,  0x13,  0x0a,  0x57,  0x01,  0x18,  0x3e,  0xfe,  0x41,  0x58,  0x0a,  0xba,  0xfe,  0xfa,  0x14,  0xfe,
-  0x49,  0x54,  0xb0,  0xfe,  0x5e,  0x0f,  0x05,  0xfe,  0x3a,  0x03,  0x0a,  0x67,  0xfe,  0xe0,  0x14,  0xfe,
-  0x0e,  0x47,  0x46,  0x28,  0xfe,  0xce,  0x45,  0x31,  0x51,  0xfe,  0xce,  0x47,  0xfe,  0xad,  0x13,  0x05,
-  0x35,  0x21,  0x2c,  0x09,  0x1a,  0xfe,  0x98,  0x12,  0x26,  0x20,  0x96,  0x20,  0xe7,  0xfe,  0x08,  0x1c,
-  0xfe,  0x7c,  0x19,  0xfe,  0xfd,  0x19,  0xfe,  0x0a,  0x1c,  0x03,  0xe5,  0xfe,  0x48,  0x55,  0xa5,  0x3b,
-  0xfe,  0x62,  0x01,  0xfe,  0xc9,  0x55,  0x31,  0xfe,  0x74,  0x10,  0x01,  0xfe,  0xf0,  0x1a,  0x03,  0xfe,
-  0x38,  0x01,  0x3b,  0xfe,  0x3a,  0x01,  0x8e,  0xfe,  0x1e,  0x10,  0xfe,  0x02,  0xec,  0xe7,  0x53,  0x00,
-  0x36,  0xfe,  0x04,  0xec,  0x2c,  0x60,  0xfe,  0x05,  0xf6,  0xfe,  0x34,  0x01,  0x01,  0xfe,  0x62,  0x1b,
-  0x01,  0xfe,  0xce,  0x1e,  0xb2,  0x11,  0xfe,  0x18,  0x13,  0xca,  0xfe,  0x02,  0xea,  0xe7,  0x53,  0x92,
-  0xfe,  0xc3,  0x13,  0x1f,  0x12,  0x47,  0xb5,  0xc3,  0xfe,  0x2a,  0x10,  0x03,  0xfe,  0x38,  0x01,  0x23,
-  0xfe,  0xf0,  0xff,  0x10,  0xe5,  0x03,  0xfe,  0x3a,  0x01,  0x10,  0xfe,  0x62,  0x01,  0x01,  0xfe,  0x1e,
-  0x1e,  0x20,  0x2c,  0x15,  0x56,  0x01,  0xfe,  0x9e,  0x1e,  0x13,  0x07,  0x02,  0x26,  0x02,  0x21,  0x96,
-  0xc7,  0x20,  0x96,  0x09,  0x92,  0xfe,  0x79,  0x13,  0x1f,  0x1d,  0x47,  0xb5,  0xc3,  0xfe,  0xe1,  0x10,
-  0xcf,  0xfe,  0x03,  0xdc,  0xfe,  0x73,  0x57,  0xfe,  0x80,  0x5d,  0x02,  0xcf,  0xfe,  0x03,  0xdc,  0xfe,
-  0x5b,  0x57,  0xfe,  0x80,  0x5d,  0x02,  0xfe,  0x03,  0x57,  0xcf,  0x26,  0xfe,  0x00,  0xcc,  0x02,  0xfe,
-  0x03,  0x57,  0xcf,  0x89,  0x02,  0x01,  0x0c,  0x06,  0x4a,  0xfe,  0x4e,  0x13,  0x0f,  0xfe,  0x1c,  0x80,
-  0x04,  0xfe,  0x9c,  0x83,  0x33,  0x0b,  0x0e,  0x09,  0x07,  0xfe,  0x3a,  0x13,  0x0f,  0xfe,  0x1e,  0x80,
-  0x04,  0xfe,  0x9e,  0x83,  0x33,  0x0b,  0x0e,  0xfe,  0x2a,  0x13,  0x0f,  0xfe,  0x1d,  0x80,  0x04,  0xfe,
-  0x9d,  0x83,  0xfe,  0xf9,  0x13,  0x0e,  0xfe,  0x1c,  0x13,  0x01,  0xfe,  0xee,  0x1e,  0xac,  0xfe,  0x14,
-  0x13,  0x01,  0xfe,  0xfe,  0x1e,  0xfe,  0x81,  0x58,  0xfa,  0x01,  0xfe,  0x0e,  0x1f,  0xfe,  0x30,  0xf4,
-  0x0d,  0xfe,  0x3c,  0x50,  0xa2,  0x01,  0xfe,  0x92,  0x1b,  0x01,  0x43,  0x09,  0x56,  0xfb,  0x01,  0xfe,
-  0xc8,  0x1a,  0x01,  0x0c,  0x06,  0x28,  0xa4,  0x01,  0xfe,  0xf4,  0x1c,  0x01,  0xfe,  0x00,  0x1d,  0x15,
-  0xfe,  0xe9,  0x00,  0x01,  0x0c,  0x06,  0x4a,  0xfe,  0x4e,  0x13,  0x01,  0xfe,  0x22,  0x1b,  0xfe,  0x1e,
-  0x1c,  0x0f,  0xfe,  0x14,  0x90,  0x04,  0xfe,  0x94,  0x93,  0x3a,  0x0b,  0xfe,  0x96,  0x90,  0x04,  0xfe,
-  0x96,  0x93,  0x79,  0x0b,  0x0e,  0x10,  0xfe,  0x64,  0x01,  0x22,  0xfe,  0x66,  0x01,  0x01,  0x0c,  0x06,
-  0x65,  0xf9,  0x0f,  0xfe,  0x03,  0x80,  0x04,  0xfe,  0x83,  0x83,  0x33,  0x0b,  0x0e,  0x77,  0xfe,  0x01,
-  0xec,  0x2c,  0xfe,  0x80,  0x40,  0x20,  0x2c,  0x7a,  0x30,  0x15,  0xdf,  0x40,  0x21,  0x2c,  0xfe,  0x00,
-  0x40,  0x8d,  0x2c,  0x02,  0xfe,  0x08,  0x1c,  0x03,  0xfe,  0xac,  0x00,  0xfe,  0x06,  0x58,  0x03,  0xfe,
-  0xae,  0x00,  0xfe,  0x07,  0x58,  0x03,  0xfe,  0xb0,  0x00,  0xfe,  0x08,  0x58,  0x03,  0xfe,  0xb2,  0x00,
-  0xfe,  0x09,  0x58,  0xfe,  0x0a,  0x1c,  0x2e,  0x49,  0x20,  0xe0,  0x26,  0x10,  0x66,  0x10,  0x55,  0x10,
-  0x6f,  0x13,  0x57,  0x52,  0x4f,  0x1c,  0x28,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x2b,  0xfe,  0x88,
-  0x11,  0x46,  0x1a,  0x13,  0x5a,  0x52,  0x1c,  0x4a,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x2b,  0xfe,
-  0x9e,  0x11,  0x2e,  0x1a,  0x20,  0x2c,  0x90,  0x34,  0x60,  0x21,  0x2c,  0xfe,  0x00,  0x40,  0x8d,  0x2c,
-  0x15,  0xdf,  0xfe,  0x14,  0x56,  0xfe,  0xd6,  0xf0,  0xfe,  0xb2,  0x11,  0xfe,  0x12,  0x1c,  0x75,  0xfe,
-  0x14,  0x1c,  0xfe,  0x10,  0x1c,  0xfe,  0x18,  0x1c,  0x02,  0x51,  0xfe,  0x0c,  0x14,  0xfe,  0x0e,  0x47,
-  0xfe,  0x07,  0xe6,  0x28,  0xfe,  0xce,  0x47,  0xfe,  0xf5,  0x13,  0x02,  0x01,  0xa7,  0x90,  0x34,  0x60,
-  0xfe,  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x42,  0x13,  0xfe,  0x02,  0x80,  0x09,  0x56,  0xfe,  0x34,
-  0x13,  0x0a,  0x5a,  0x01,  0x18,  0xcb,  0xfe,  0x36,  0x12,  0xfe,  0x41,  0x48,  0xfe,  0x45,  0x48,  0x01,
-  0xfe,  0xb2,  0x16,  0xfe,  0x00,  0xcc,  0xcb,  0xfe,  0xf3,  0x13,  0x3f,  0x89,  0x09,  0x1a,  0xa5,  0x0a,
-  0x9d,  0x01,  0x18,  0xfe,  0x80,  0x5c,  0x01,  0x85,  0xf2,  0x09,  0x9b,  0xa4,  0xfe,  0x14,  0x56,  0xfe,
-  0xd6,  0xf0,  0xfe,  0xec,  0x11,  0x02,  0xfe,  0x44,  0x58,  0x77,  0xfe,  0x01,  0xec,  0xb8,  0xfe,  0x9e,
-  0x40,  0xfe,  0x9d,  0xe7,  0x00,  0xfe,  0x9c,  0xe7,  0x12,  0x8d,  0x30,  0x01,  0xf4,  0xfe,  0xdd,  0x10,
-  0x37,  0xd7,  0x99,  0xd8,  0x9c,  0x27,  0x25,  0xee,  0x09,  0x12,  0xfe,  0x48,  0x12,  0x09,  0x0d,  0xfe,
-  0x56,  0x12,  0x09,  0x1d,  0xfe,  0x30,  0x12,  0x09,  0xdd,  0x1b,  0xfe,  0xc4,  0x13,  0x09,  0xfe,  0x23,
-  0x00,  0x1b,  0xfe,  0xd0,  0x13,  0x09,  0x07,  0x1b,  0xfe,  0x34,  0x14,  0x09,  0x24,  0xfe,  0x12,  0x12,
-  0x09,  0x00,  0x1b,  0x29,  0x1f,  0xdd,  0x01,  0x42,  0xa1,  0x32,  0x01,  0x08,  0xae,  0x41,  0x02,  0x32,
-  0xfe,  0x62,  0x08,  0x0a,  0xe1,  0x01,  0xfe,  0x58,  0x10,  0x15,  0x9b,  0x05,  0x35,  0x32,  0x01,  0x43,
-  0x09,  0xbb,  0xfe,  0xd7,  0x13,  0x91,  0x4b,  0x7e,  0x4c,  0x8e,  0xfe,  0x80,  0x13,  0x01,  0x0c,  0x06,
-  0x54,  0xfe,  0x72,  0x12,  0xdb,  0x64,  0xdc,  0x34,  0xfe,  0x44,  0x55,  0xfe,  0xe5,  0x55,  0xb0,  0xfe,
-  0x4a,  0x13,  0x21,  0x6e,  0xfe,  0x26,  0x13,  0x03,  0x97,  0x3b,  0x98,  0x8e,  0xfe,  0xb6,  0x0e,  0x10,
-  0x6a,  0x22,  0x6b,  0x26,  0x10,  0x97,  0x10,  0x98,  0x01,  0xc2,  0x2e,  0x49,  0x88,  0x20,  0x6e,  0x01,
-  0xfe,  0x6a,  0x16,  0xdb,  0x64,  0xdc,  0x34,  0xfe,  0x04,  0x55,  0xfe,  0xa5,  0x55,  0xfe,  0x04,  0xfa,
-  0x64,  0xfe,  0x05,  0xfa,  0x34,  0xfe,  0x8f,  0x10,  0x03,  0x6c,  0x3b,  0x6d,  0xfe,  0x40,  0x56,  0xfe,
-  0xe1,  0x56,  0x10,  0x6c,  0x22,  0x6d,  0x71,  0xdb,  0x64,  0xdc,  0x34,  0xfe,  0x44,  0x55,  0xfe,  0xe5,
-  0x55,  0x03,  0x68,  0x3b,  0x69,  0xfe,  0x00,  0x56,  0xfe,  0xa1,  0x56,  0x10,  0x68,  0x22,  0x69,  0x01,
-  0x0c,  0x06,  0x54,  0xf9,  0x21,  0x6e,  0xfe,  0x1f,  0x40,  0x03,  0x6a,  0x3b,  0x6b,  0xfe,  0x2c,  0x50,
-  0xfe,  0xae,  0x50,  0x03,  0x6c,  0x3b,  0x6d,  0xfe,  0x44,  0x50,  0xfe,  0xc6,  0x50,  0x03,  0x68,  0x3b,
-  0x69,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0x03,  0x4b,  0x3b,  0x4c,  0xfe,  0x40,  0x50,  0xfe,  0xc2,
-  0x50,  0x05,  0x73,  0x2e,  0x07,  0x20,  0x9e,  0x05,  0x72,  0x32,  0x01,  0x08,  0x16,  0x3d,  0x27,  0x25,
-  0xee,  0x09,  0x07,  0x2b,  0x3d,  0x01,  0x43,  0x09,  0xbb,  0x2b,  0x72,  0x01,  0xa6,  0x23,  0x3f,  0x1b,
-  0x3d,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x1e,  0x13,  0x91,  0x4b,  0x7e,  0x4c,  0xfe,  0x0a,  0x55,  0x31,
-  0xfe,  0x8b,  0x55,  0xd9,  0x4b,  0xda,  0x4c,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0x05,  0x72,  0x01,
-  0xfe,  0x8e,  0x1e,  0xca,  0xfe,  0x19,  0x41,  0x05,  0x72,  0x32,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0xc0,
-  0x27,  0x25,  0xbe,  0x2d,  0x1d,  0xc0,  0x2d,  0x0d,  0x83,  0x2d,  0x7f,  0x1b,  0xfe,  0x66,  0x15,  0x05,
-  0x3d,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0xc0,  0x27,  0x25,  0xbd,  0x09,  0x1d,  0x2b,  0x3d,  0x01,  0x08,
-  0x16,  0xc0,  0x27,  0x25,  0xfe,  0xe8,  0x09,  0xfe,  0xc2,  0x49,  0x50,  0x03,  0xb6,  0x1e,  0x83,  0x01,
-  0x38,  0x06,  0x24,  0x31,  0xa1,  0xfe,  0xbb,  0x45,  0x2d,  0x00,  0xa4,  0x46,  0x07,  0x90,  0x3f,  0x01,
-  0xfe,  0xf8,  0x15,  0x01,  0xa6,  0x86,  0xfe,  0x4b,  0x45,  0xfe,  0x20,  0x13,  0x01,  0x43,  0x09,  0x82,
-  0xfe,  0x16,  0x13,  0x03,  0x9a,  0x1e,  0x5d,  0x03,  0x55,  0x1e,  0x31,  0x5e,  0x05,  0x72,  0xfe,  0xc0,
-  0x5d,  0x01,  0xa7,  0xfe,  0x03,  0x17,  0x03,  0x66,  0x8a,  0x10,  0x66,  0x5e,  0x32,  0x01,  0x08,  0x17,
-  0x73,  0x01,  0xfe,  0x56,  0x19,  0x05,  0x73,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0x3d,  0x27,  0x25,  0xbd,
-  0x09,  0x07,  0x2b,  0x3d,  0x01,  0xfe,  0xbe,  0x16,  0xfe,  0x42,  0x58,  0xfe,  0xe8,  0x14,  0x01,  0xa6,
-  0x86,  0xfe,  0x4a,  0xf4,  0x0d,  0x1b,  0x3d,  0xfe,  0x4a,  0xf4,  0x07,  0xfe,  0x0e,  0x12,  0x01,  0x43,
-  0x09,  0x82,  0x4e,  0x05,  0x72,  0x03,  0x55,  0x8a,  0x10,  0x55,  0x5e,  0x32,  0x01,  0x08,  0x17,  0x73,
-  0x01,  0xfe,  0x84,  0x19,  0x05,  0x73,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0x3d,  0x27,  0x25,  0xbd,  0x09,
-  0x12,  0x2b,  0x3d,  0x01,  0xfe,  0xe8,  0x17,  0x8b,  0xfe,  0xaa,  0x14,  0xfe,  0xb6,  0x14,  0x86,  0xa8,
-  0xb2,  0x0d,  0x1b,  0x3d,  0xb2,  0x07,  0xfe,  0x0e,  0x12,  0x01,  0x43,  0x09,  0x82,  0x4e,  0x05,  0x72,
-  0x03,  0x6f,  0x8a,  0x10,  0x6f,  0x5e,  0x32,  0x01,  0x08,  0x17,  0x73,  0x01,  0xfe,  0xc0,  0x19,  0x05,
-  0x73,  0x13,  0x07,  0x2f,  0xfe,  0xcc,  0x15,  0x17,  0xfe,  0xe2,  0x15,  0x5f,  0xcc,  0x01,  0x08,  0x26,
-  0x5f,  0x02,  0x8f,  0xfe,  0xde,  0x15,  0x2a,  0xfe,  0xde,  0x15,  0x16,  0xfe,  0xcc,  0x15,  0x5e,  0x32,
-  0x01,  0x08,  0xfe,  0xd5,  0x10,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,  0xad,  0x23,  0xfe,  0xff,
-  0x7f,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x02,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,  0xad,
-  0x23,  0x3f,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x02,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,
-  0xad,  0x02,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,  0xfe,  0x00,  0x5e,  0x02,  0x13,  0x58,  0xff,
-  0x02,  0x00,  0x57,  0x52,  0xad,  0xfe,  0x0b,  0x58,  0x02,  0x0a,  0x66,  0x01,  0x5c,  0x0a,  0x55,  0x01,
-  0x5c,  0x0a,  0x6f,  0x01,  0x5c,  0x02,  0x01,  0xfe,  0x1e,  0x1f,  0x23,  0x1a,  0xff,  0x03,  0x00,  0x54,
-  0xfe,  0x00,  0xf4,  0x24,  0x52,  0x0f,  0xfe,  0x00,  0x7c,  0x04,  0xfe,  0x07,  0x7c,  0x3a,  0x0b,  0x0e,
-  0xfe,  0x00,  0x71,  0xfe,  0xf9,  0x18,  0xfe,  0x7a,  0x19,  0xfe,  0xfb,  0x19,  0xfe,  0x1a,  0xf7,  0x00,
-  0xfe,  0x1b,  0xf7,  0x00,  0x7a,  0x30,  0x10,  0x68,  0x22,  0x69,  0xd9,  0x6c,  0xda,  0x6d,  0x02,  0xfe,
-  0x62,  0x08,  0xfe,  0x82,  0x4a,  0xfe,  0xe1,  0x1a,  0xfe,  0x83,  0x5a,  0x77,  0x02,  0x01,  0xc6,  0xfe,
-  0x42,  0x48,  0x4f,  0x50,  0x45,  0x01,  0x08,  0x16,  0xfe,  0xe0,  0x17,  0x27,  0x25,  0xbe,  0x01,  0x08,
-  0x16,  0xfe,  0xe0,  0x17,  0x27,  0x25,  0xfe,  0xe8,  0x0a,  0xfe,  0xc1,  0x59,  0x03,  0x9a,  0x1e,  0xfe,
-  0xda,  0x12,  0x01,  0x38,  0x06,  0x12,  0xfe,  0xd0,  0x13,  0x26,  0x53,  0x12,  0x48,  0xfe,  0x08,  0x17,
-  0xd1,  0x12,  0x53,  0x12,  0xfe,  0x1e,  0x13,  0x2d,  0xb4,  0x7b,  0xfe,  0x26,  0x17,  0x4d,  0x13,  0x07,
-  0x1c,  0xb4,  0x90,  0x04,  0xfe,  0x78,  0x10,  0xff,  0x02,  0x83,  0x55,  0xf1,  0xff,  0x02,  0x83,  0x55,
-  0x53,  0x1d,  0xfe,  0x12,  0x13,  0xd6,  0xfe,  0x30,  0x00,  0xb0,  0xfe,  0x80,  0x17,  0x1c,  0x63,  0x13,
-  0x07,  0xfe,  0x56,  0x10,  0x53,  0x0d,  0xfe,  0x16,  0x13,  0xd6,  0xfe,  0x64,  0x00,  0xb0,  0xfe,  0x80,
-  0x17,  0x0a,  0xfe,  0x64,  0x00,  0x1c,  0x94,  0x13,  0x07,  0xfe,  0x28,  0x10,  0x53,  0x07,  0xfe,  0x60,
-  0x13,  0xd6,  0xfe,  0xc8,  0x00,  0xb0,  0xfe,  0x80,  0x17,  0x0a,  0xfe,  0xc8,  0x00,  0x1c,  0x95,  0x13,
-  0x07,  0x71,  0xd6,  0xfe,  0x90,  0x01,  0x48,  0xfe,  0x8c,  0x17,  0x45,  0xf3,  0xfe,  0x43,  0xf4,  0x96,
-  0xfe,  0x56,  0xf0,  0xfe,  0x9e,  0x17,  0xfe,  0x04,  0xf4,  0x58,  0xfe,  0x43,  0xf4,  0x94,  0xf6,  0x8b,
-  0x01,  0xfe,  0x24,  0x16,  0x23,  0x3f,  0xfc,  0xa8,  0x8c,  0x49,  0x48,  0xfe,  0xda,  0x17,  0x62,  0x49,
-  0xfe,  0x1c,  0x10,  0xa8,  0x8c,  0x80,  0x48,  0xfe,  0xda,  0x17,  0x62,  0x80,  0x71,  0x50,  0x26,  0xfe,
-  0x4d,  0xf4,  0x00,  0xf7,  0x45,  0x13,  0x07,  0xfe,  0xb4,  0x56,  0xfe,  0xc3,  0x58,  0x02,  0x50,  0x13,
-  0x0d,  0x02,  0x50,  0x3e,  0x78,  0x4f,  0x45,  0x01,  0x08,  0x16,  0xa9,  0x27,  0x25,  0xbe,  0xfe,  0x03,
-  0xea,  0xfe,  0x7e,  0x01,  0x01,  0x08,  0x16,  0xa9,  0x27,  0x25,  0xfe,  0xe9,  0x0a,  0x01,  0x08,  0x16,
-  0xa9,  0x27,  0x25,  0xfe,  0xe9,  0x0a,  0xfe,  0x05,  0xea,  0xfe,  0x7f,  0x01,  0x01,  0x08,  0x16,  0xa9,
-  0x27,  0x25,  0xfe,  0x69,  0x09,  0xfe,  0x02,  0xea,  0xfe,  0x80,  0x01,  0x01,  0x08,  0x16,  0xa9,  0x27,
-  0x25,  0xfe,  0xe8,  0x08,  0x47,  0xfe,  0x81,  0x01,  0x03,  0xb6,  0x1e,  0x83,  0x01,  0x38,  0x06,  0x24,
-  0x31,  0xa2,  0x78,  0xf2,  0x53,  0x07,  0x36,  0xfe,  0x34,  0xf4,  0x3f,  0xa1,  0x78,  0x03,  0x9a,  0x1e,
-  0x83,  0x01,  0x38,  0x06,  0x12,  0x31,  0xf0,  0x4f,  0x45,  0xfe,  0x90,  0x10,  0xfe,  0x40,  0x5a,  0x23,
-  0x3f,  0xfb,  0x8c,  0x49,  0x48,  0xfe,  0xaa,  0x18,  0x62,  0x49,  0x71,  0x8c,  0x80,  0x48,  0xfe,  0xaa,
-  0x18,  0x62,  0x80,  0xfe,  0xb4,  0x56,  0xfe,  0x40,  0x5d,  0x01,  0xc6,  0x01,  0xfe,  0xac,  0x1d,  0xfe,
-  0x02,  0x17,  0xfe,  0xc8,  0x45,  0xfe,  0x5a,  0xf0,  0xfe,  0xc0,  0x18,  0xfe,  0x43,  0x48,  0x2d,  0x93,
-  0x36,  0xfe,  0x34,  0xf4,  0xfe,  0x00,  0x11,  0xfe,  0x40,  0x10,  0x2d,  0xb4,  0x36,  0xfe,  0x34,  0xf4,
-  0x04,  0xfe,  0x34,  0x10,  0x2d,  0xfe,  0x0b,  0x00,  0x36,  0x46,  0x63,  0xfe,  0x28,  0x10,  0xfe,  0xc0,
-  0x49,  0xff,  0x02,  0x00,  0x54,  0xb2,  0xfe,  0x90,  0x01,  0x48,  0xfe,  0xfa,  0x18,  0x45,  0xfe,  0x1c,
-  0xf4,  0x3f,  0xf3,  0xfe,  0x40,  0xf4,  0x96,  0xfe,  0x56,  0xf0,  0xfe,  0x0c,  0x19,  0xfe,  0x04,  0xf4,
-  0x58,  0xfe,  0x40,  0xf4,  0x94,  0xf6,  0x3e,  0x2d,  0x93,  0x4e,  0xd0,  0x0d,  0x21,  0xfe,  0x7f,  0x01,
-  0xfe,  0xc8,  0x46,  0xfe,  0x24,  0x13,  0x8c,  0x00,  0x5d,  0x26,  0x21,  0xfe,  0x7e,  0x01,  0xfe,  0xc8,
-  0x45,  0xfe,  0x14,  0x13,  0x21,  0xfe,  0x80,  0x01,  0xfe,  0x48,  0x45,  0xfa,  0x21,  0xfe,  0x81,  0x01,
-  0xfe,  0xc8,  0x44,  0x4e,  0x26,  0x02,  0x13,  0x07,  0x02,  0x78,  0x45,  0x50,  0x13,  0x0d,  0x02,  0x14,
-  0x07,  0x01,  0x08,  0x17,  0xfe,  0x82,  0x19,  0x14,  0x0d,  0x01,  0x08,  0x17,  0xfe,  0x82,  0x19,  0x14,
-  0x1d,  0x01,  0x08,  0x17,  0xfe,  0x82,  0x19,  0x5f,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x02,  0x14,  0x07,
-  0x01,  0x08,  0x17,  0xc1,  0x14,  0x1d,  0x01,  0x08,  0x17,  0xc1,  0x14,  0x07,  0x01,  0x08,  0x17,  0xc1,
-  0xfe,  0x89,  0x49,  0x01,  0x08,  0x17,  0xc1,  0x5f,  0xfe,  0x89,  0x4a,  0x01,  0x08,  0x02,  0x50,  0x02,
-  0x14,  0x07,  0x01,  0x08,  0x17,  0x74,  0x14,  0x7f,  0x01,  0x08,  0x17,  0x74,  0x14,  0x12,  0x01,  0x08,
-  0x17,  0x74,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x17,  0x74,  0x14,  0x00,  0x01,  0x08,  0x17,  0x74,  0xfe,
-  0x89,  0x4a,  0x01,  0x08,  0x17,  0x74,  0xfe,  0x09,  0x49,  0x01,  0x08,  0x17,  0x74,  0x5f,  0xcc,  0x01,
-  0x08,  0x02,  0x21,  0xe4,  0x09,  0x07,  0xfe,  0x4c,  0x13,  0xc8,  0x20,  0xe4,  0xfe,  0x49,  0xf4,  0x00,
-  0x4d,  0x5f,  0xa1,  0x5e,  0xfe,  0x01,  0xec,  0xfe,  0x27,  0x01,  0xcc,  0xff,  0x02,  0x00,  0x10,  0x2f,
-  0xfe,  0x3e,  0x1a,  0x01,  0x43,  0x09,  0xfe,  0xe3,  0x00,  0xfe,  0x22,  0x13,  0x16,  0xfe,  0x64,  0x1a,
-  0x26,  0x20,  0x9e,  0x01,  0x41,  0x21,  0x9e,  0x09,  0x07,  0x5d,  0x01,  0x0c,  0x61,  0x07,  0x44,  0x02,
-  0x0a,  0x5a,  0x01,  0x18,  0xfe,  0x00,  0x40,  0xaa,  0x09,  0x1a,  0xfe,  0x12,  0x13,  0x0a,  0x9d,  0x01,
-  0x18,  0xaa,  0x0a,  0x67,  0x01,  0xa3,  0x02,  0x0a,  0x9d,  0x01,  0x18,  0xaa,  0xfe,  0x80,  0xe7,  0x1a,
-  0x09,  0x1a,  0x5d,  0xfe,  0x45,  0x58,  0x01,  0xfe,  0xb2,  0x16,  0xaa,  0x02,  0x0a,  0x5a,  0x01,  0x18,
-  0xaa,  0x0a,  0x67,  0x01,  0xa3,  0x02,  0x0a,  0x5a,  0x01,  0x18,  0x01,  0xfe,  0x7e,  0x1e,  0xfe,  0x80,
-  0x4c,  0xfe,  0x49,  0xe4,  0x1a,  0xfe,  0x12,  0x13,  0x0a,  0x9d,  0x01,  0x18,  0xfe,  0x80,  0x4c,  0x0a,
-  0x67,  0x01,  0x5c,  0x02,  0x1c,  0x1a,  0x87,  0x7c,  0xe5,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,
-  0x24,  0x1c,  0xfe,  0x1d,  0xf7,  0x28,  0xb1,  0xfe,  0x04,  0x1b,  0x01,  0xfe,  0x2a,  0x1c,  0xfa,  0xb3,
-  0x28,  0x7c,  0xfe,  0x2c,  0x01,  0xfe,  0x2f,  0x19,  0x02,  0xc9,  0x2b,  0xfe,  0xf4,  0x1a,  0xfe,  0xfa,
-  0x10,  0x1c,  0x1a,  0x87,  0x03,  0xfe,  0x64,  0x01,  0xfe,  0x00,  0xf4,  0x24,  0xfe,  0x18,  0x58,  0x03,
-  0xfe,  0x66,  0x01,  0xfe,  0x19,  0x58,  0xb3,  0x24,  0x01,  0xfe,  0x0e,  0x1f,  0xfe,  0x30,  0xf4,  0x07,
-  0xfe,  0x3c,  0x50,  0x7c,  0xfe,  0x38,  0x00,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0x24,  0xb1,  0xfe,
-  0x50,  0x1b,  0xfe,  0xd4,  0x14,  0x31,  0x02,  0xc9,  0x2b,  0xfe,  0x26,  0x1b,  0xfe,  0xba,  0x10,  0x1c,
-  0x1a,  0x87,  0xfe,  0x83,  0x5a,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x1d,  0xf7,  0x54,  0xb1,
-  0xfe,  0x72,  0x1b,  0xfe,  0xb2,  0x14,  0xfc,  0xb3,  0x54,  0x7c,  0x12,  0xfe,  0xaf,  0x19,  0xfe,  0x98,
-  0xe7,  0x00,  0x02,  0xc9,  0x2b,  0xfe,  0x66,  0x1b,  0xfe,  0x8a,  0x10,  0x1c,  0x1a,  0x87,  0x8b,  0x0f,
-  0xfe,  0x30,  0x90,  0x04,  0xfe,  0xb0,  0x93,  0x3a,  0x0b,  0xfe,  0x18,  0x58,  0xfe,  0x32,  0x90,  0x04,
-  0xfe,  0xb2,  0x93,  0x3a,  0x0b,  0xfe,  0x19,  0x58,  0x0e,  0xa8,  0xb3,  0x4a,  0x7c,  0x12,  0xfe,  0x0f,
-  0x79,  0xfe,  0x1c,  0xf7,  0x4a,  0xb1,  0xfe,  0xc6,  0x1b,  0xfe,  0x5e,  0x14,  0x31,  0x02,  0xc9,  0x2b,
-  0xfe,  0x96,  0x1b,  0x5c,  0xfe,  0x02,  0xf6,  0x1a,  0x87,  0xfe,  0x18,  0xfe,  0x6a,  0xfe,  0x19,  0xfe,
-  0x6b,  0x01,  0xfe,  0x1e,  0x1f,  0xfe,  0x1d,  0xf7,  0x65,  0xb1,  0xfe,  0xee,  0x1b,  0xfe,  0x36,  0x14,
-  0xfe,  0x1c,  0x13,  0xb3,  0x65,  0x3e,  0xfe,  0x83,  0x58,  0xfe,  0xaf,  0x19,  0xfe,  0x80,  0xe7,  0x1a,
-  0xfe,  0x81,  0xe7,  0x1a,  0x15,  0xfe,  0xdd,  0x00,  0x7a,  0x30,  0x02,  0x7a,  0x30,  0xfe,  0x12,  0x45,
-  0x2b,  0xfe,  0xdc,  0x1b,  0x1f,  0x07,  0x47,  0xb5,  0xc3,  0x05,  0x35,  0xfe,  0x39,  0xf0,  0x75,  0x26,
-  0x02,  0xfe,  0x7e,  0x18,  0x23,  0x1d,  0x36,  0x13,  0x11,  0x02,  0x87,  0x03,  0xe3,  0x23,  0x07,  0xfe,
-  0xef,  0x12,  0xfe,  0xe1,  0x10,  0x90,  0x34,  0x60,  0xfe,  0x02,  0x80,  0x09,  0x56,  0xfe,  0x3c,  0x13,
-  0xfe,  0x82,  0x14,  0xfe,  0x42,  0x13,  0x51,  0xfe,  0x06,  0x83,  0x0a,  0x5a,  0x01,  0x18,  0xcb,  0xfe,
-  0x3e,  0x12,  0xfe,  0x41,  0x48,  0xfe,  0x45,  0x48,  0x01,  0xfe,  0xb2,  0x16,  0xfe,  0x00,  0xcc,  0xcb,
-  0xfe,  0xf3,  0x13,  0x3f,  0x89,  0x09,  0x1a,  0xa5,  0x0a,  0x9d,  0x01,  0x18,  0xfe,  0x80,  0x4c,  0x01,
-  0x85,  0xfe,  0x16,  0x10,  0x09,  0x9b,  0x4e,  0xfe,  0x40,  0x14,  0xfe,  0x24,  0x12,  0xfe,  0x14,  0x56,
-  0xfe,  0xd6,  0xf0,  0xfe,  0x52,  0x1c,  0x1c,  0x0d,  0x02,  0xfe,  0x9c,  0xe7,  0x0d,  0x19,  0xfe,  0x15,
-  0x00,  0x40,  0x8d,  0x30,  0x01,  0xf4,  0x1c,  0x07,  0x02,  0x51,  0xfe,  0x06,  0x83,  0xfe,  0x18,  0x80,
-  0x61,  0x28,  0x44,  0x15,  0x56,  0x01,  0x85,  0x1c,  0x07,  0x02,  0xfe,  0x38,  0x90,  0xfe,  0xba,  0x90,
-  0x91,  0xde,  0x7e,  0xdf,  0xfe,  0x48,  0x55,  0x31,  0xfe,  0xc9,  0x55,  0x02,  0x21,  0xb9,  0x88,  0x20,
-  0xb9,  0x02,  0x0a,  0xba,  0x01,  0x18,  0xfe,  0x41,  0x48,  0x0a,  0x57,  0x01,  0x18,  0xfe,  0x49,  0x44,
-  0x1b,  0xfe,  0x1e,  0x1d,  0x88,  0x89,  0x02,  0x0a,  0x5a,  0x01,  0x18,  0x09,  0x1a,  0xa4,  0x0a,  0x67,
-  0x01,  0xa3,  0x0a,  0x57,  0x01,  0x18,  0x88,  0x89,  0x02,  0xfe,  0x4e,  0xe4,  0x1d,  0x7b,  0xfe,  0x52,
-  0x1d,  0x03,  0xfe,  0x90,  0x00,  0xfe,  0x3a,  0x45,  0xfe,  0x2c,  0x10,  0xfe,  0x4e,  0xe4,  0xdd,  0x7b,
-  0xfe,  0x64,  0x1d,  0x03,  0xfe,  0x92,  0x00,  0xd1,  0x12,  0xfe,  0x1a,  0x10,  0xfe,  0x4e,  0xe4,  0xfe,
-  0x0b,  0x00,  0x7b,  0xfe,  0x76,  0x1d,  0x03,  0xfe,  0x94,  0x00,  0xd1,  0x24,  0xfe,  0x08,  0x10,  0x03,
-  0xfe,  0x96,  0x00,  0xd1,  0x63,  0xfe,  0x4e,  0x45,  0x83,  0xca,  0xff,  0x04,  0x68,  0x54,  0xfe,  0xf1,
-  0x10,  0x23,  0x49,  0xfe,  0x08,  0x1c,  0xfe,  0x67,  0x19,  0xfe,  0x0a,  0x1c,  0xfe,  0x1a,  0xf4,  0xfe,
-  0x00,  0x04,  0x83,  0xb2,  0x1d,  0x48,  0xfe,  0xaa,  0x1d,  0x13,  0x1d,  0x02,  0x09,  0x92,  0xfe,  0x5a,
-  0xf0,  0xfe,  0xba,  0x1d,  0x2e,  0x93,  0xfe,  0x34,  0x10,  0x09,  0x12,  0xfe,  0x5a,  0xf0,  0xfe,  0xc8,
-  0x1d,  0x2e,  0xb4,  0xfe,  0x26,  0x10,  0x09,  0x1d,  0x36,  0x2e,  0x63,  0xfe,  0x1a,  0x10,  0x09,  0x0d,
-  0x36,  0x2e,  0x94,  0xf2,  0x09,  0x07,  0x36,  0x2e,  0x95,  0xa1,  0xc8,  0x02,  0x1f,  0x93,  0x01,  0x42,
-  0xfe,  0x04,  0xfe,  0x99,  0x03,  0x9c,  0x8b,  0x02,  0x2a,  0xfe,  0x1c,  0x1e,  0xfe,  0x14,  0xf0,  0x08,
-  0x2f,  0xfe,  0x0c,  0x1e,  0x2a,  0xfe,  0x1c,  0x1e,  0x8f,  0xfe,  0x1c,  0x1e,  0xfe,  0x82,  0xf0,  0xfe,
-  0x10,  0x1e,  0x02,  0x0f,  0x3f,  0x04,  0xfe,  0x80,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x18,
-  0x80,  0x04,  0xfe,  0x98,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x02,  0x80,  0x04,  0xfe,  0x82,
-  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x06,  0x80,  0x04,  0xfe,  0x86,  0x83,  0x33,  0x0b,  0x0e,
-  0x02,  0x0f,  0xfe,  0x1b,  0x80,  0x04,  0xfe,  0x9b,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x04,
-  0x80,  0x04,  0xfe,  0x84,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x80,  0x80,  0x04,  0xfe,  0x80,
-  0x83,  0xfe,  0xc9,  0x47,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x19,  0x81,  0x04,  0xfe,  0x99,  0x83,  0xfe,
-  0xca,  0x47,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x06,  0x83,  0x04,  0xfe,  0x86,  0x83,  0xfe,  0xce,  0x47,
-  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x2c,  0x90,  0x04,  0xfe,  0xac,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x0f,
-  0xfe,  0xae,  0x90,  0x04,  0xfe,  0xae,  0x93,  0x79,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x08,  0x90,  0x04,
-  0xfe,  0x88,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x8a,  0x90,  0x04,  0xfe,  0x8a,  0x93,  0x79,
-  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x0c,  0x90,  0x04,  0xfe,  0x8c,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x0f,
-  0xfe,  0x8e,  0x90,  0x04,  0xfe,  0x8e,  0x93,  0x79,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x3c,  0x90,  0x04,
-  0xfe,  0xbc,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x8b,  0x0f,  0xfe,  0x03,  0x80,  0x04,  0xfe,  0x83,  0x83,
-  0x33,  0x0b,  0x77,  0x0e,  0xa8,  0x02,  0xff,  0x66,  0x00,  0x00,
+static unsigned char _adv_asc38C1600_buf[] = {
+	0x00, 0x00, 0x00, 0xf2, 0x00, 0x16, 0x00, 0xfc, 0x00, 0x10, 0x00, 0xf0,
+	0x18, 0xe4, 0x01, 0x00,
+	0x04, 0x1e, 0x48, 0xe4, 0x03, 0xf6, 0xf7, 0x13, 0x2e, 0x1e, 0x02, 0x00,
+	0x07, 0x17, 0xc0, 0x5f,
+	0x00, 0xfa, 0xff, 0xff, 0x04, 0x00, 0x00, 0xf6, 0x09, 0xe7, 0x82, 0xe7,
+	0x85, 0xf0, 0x86, 0xf0,
+	0x4e, 0x10, 0x9e, 0xe7, 0xff, 0x00, 0x55, 0xf0, 0x01, 0xf6, 0x03, 0x00,
+	0x98, 0x57, 0x01, 0xe6,
+	0x00, 0xea, 0x00, 0xec, 0x01, 0xfa, 0x18, 0xf4, 0x08, 0x00, 0xf0, 0x1d,
+	0x38, 0x54, 0x32, 0xf0,
+	0x10, 0x00, 0xc2, 0x0e, 0x1e, 0xf0, 0xd5, 0xf0, 0xbc, 0x00, 0x4b, 0xe4,
+	0x00, 0xe6, 0xb1, 0xf0,
+	0xb4, 0x00, 0x02, 0x13, 0x3e, 0x1c, 0xc8, 0x47, 0x3e, 0x00, 0xd8, 0x01,
+	0x06, 0x13, 0x0c, 0x1c,
+	0x5e, 0x1e, 0x00, 0x57, 0xc8, 0x57, 0x01, 0xfc, 0xbc, 0x0e, 0xa2, 0x12,
+	0xb9, 0x54, 0x00, 0x80,
+	0x62, 0x0a, 0x5a, 0x12, 0xc8, 0x15, 0x3e, 0x1e, 0x18, 0x40, 0xbd, 0x56,
+	0x03, 0xe6, 0x01, 0xea,
+	0x5c, 0xf0, 0x0f, 0x00, 0x20, 0x00, 0x6c, 0x01, 0x6e, 0x01, 0x04, 0x12,
+	0x04, 0x13, 0xbb, 0x55,
+	0x3c, 0x56, 0x3e, 0x57, 0x03, 0x58, 0x4a, 0xe4, 0x40, 0x00, 0xb6, 0x00,
+	0xbb, 0x00, 0xc0, 0x00,
+	0x00, 0x01, 0x01, 0x01, 0x3e, 0x01, 0x58, 0x0a, 0x44, 0x10, 0x0a, 0x12,
+	0x4c, 0x1c, 0x4e, 0x1c,
+	0x02, 0x4a, 0x30, 0xe4, 0x05, 0xe6, 0x0c, 0x00, 0x3c, 0x00, 0x80, 0x00,
+	0x24, 0x01, 0x3c, 0x01,
+	0x68, 0x01, 0x6a, 0x01, 0x70, 0x01, 0x72, 0x01, 0x74, 0x01, 0x76, 0x01,
+	0x78, 0x01, 0x7c, 0x01,
+	0xc6, 0x0e, 0x0c, 0x10, 0xac, 0x12, 0xae, 0x12, 0x16, 0x1a, 0x32, 0x1c,
+	0x6e, 0x1e, 0x02, 0x48,
+	0x3a, 0x55, 0xc9, 0x57, 0x02, 0xee, 0x5b, 0xf0, 0x03, 0xf7, 0x06, 0xf7,
+	0x03, 0xfc, 0x06, 0x00,
+	0x1e, 0x00, 0xbe, 0x00, 0xe1, 0x00, 0x0c, 0x12, 0x18, 0x1a, 0x70, 0x1a,
+	0x30, 0x1c, 0x38, 0x1c,
+	0x10, 0x44, 0x00, 0x4c, 0xb0, 0x57, 0x40, 0x5c, 0x4d, 0xe4, 0x04, 0xea,
+	0x5d, 0xf0, 0xa7, 0xf0,
+	0x04, 0xf6, 0x02, 0xfc, 0x05, 0x00, 0x09, 0x00, 0x19, 0x00, 0x32, 0x00,
+	0x33, 0x00, 0x34, 0x00,
+	0x36, 0x00, 0x98, 0x00, 0x9e, 0x00, 0xcc, 0x00, 0x20, 0x01, 0x4e, 0x01,
+	0x79, 0x01, 0x3c, 0x09,
+	0x68, 0x0d, 0x02, 0x10, 0x04, 0x10, 0x3a, 0x10, 0x08, 0x12, 0x0a, 0x13,
+	0x40, 0x16, 0x50, 0x16,
+	0x00, 0x17, 0x4a, 0x19, 0x00, 0x4e, 0x00, 0x54, 0x01, 0x58, 0x00, 0xdc,
+	0x05, 0xf0, 0x09, 0xf0,
+	0x59, 0xf0, 0xb8, 0xf0, 0x48, 0xf4, 0x0e, 0xf7, 0x0a, 0x00, 0x9b, 0x00,
+	0x9c, 0x00, 0xa4, 0x00,
+	0xb5, 0x00, 0xba, 0x00, 0xd0, 0x00, 0xe7, 0x00, 0xf0, 0x03, 0x69, 0x08,
+	0xe9, 0x09, 0x5c, 0x0c,
+	0xb6, 0x12, 0xbc, 0x19, 0xd8, 0x1b, 0x20, 0x1c, 0x34, 0x1c, 0x36, 0x1c,
+	0x42, 0x1d, 0x08, 0x44,
+	0x38, 0x44, 0x91, 0x44, 0x0a, 0x45, 0x48, 0x46, 0x89, 0x48, 0x68, 0x54,
+	0x83, 0x55, 0x83, 0x59,
+	0x31, 0xe4, 0x02, 0xe6, 0x07, 0xf0, 0x08, 0xf0, 0x0b, 0xf0, 0x0c, 0xf0,
+	0x4b, 0xf4, 0x04, 0xf8,
+	0x05, 0xf8, 0x02, 0xfa, 0x03, 0xfa, 0x04, 0xfc, 0x05, 0xfc, 0x07, 0x00,
+	0xa8, 0x00, 0xaa, 0x00,
+	0xb9, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0x22, 0x01, 0x26, 0x01, 0x60, 0x01,
+	0x7a, 0x01, 0x82, 0x01,
+	0xc8, 0x01, 0xca, 0x01, 0x86, 0x02, 0x6a, 0x03, 0x18, 0x05, 0xb2, 0x07,
+	0x68, 0x08, 0x10, 0x0d,
+	0x06, 0x10, 0x0a, 0x10, 0x0e, 0x10, 0x12, 0x10, 0x60, 0x10, 0xed, 0x10,
+	0xf3, 0x10, 0x06, 0x12,
+	0x10, 0x12, 0x1e, 0x12, 0x0c, 0x13, 0x0e, 0x13, 0x10, 0x13, 0xfe, 0x9c,
+	0xf0, 0x35, 0x05, 0xfe,
+	0xec, 0x0e, 0xff, 0x10, 0x00, 0x00, 0xe9, 0xfe, 0x34, 0x1f, 0x00, 0xe8,
+	0xfe, 0x88, 0x01, 0xff,
+	0x03, 0x00, 0x00, 0xfe, 0x93, 0x15, 0xfe, 0x0f, 0x05, 0xff, 0x38, 0x00,
+	0x00, 0xfe, 0x57, 0x24,
+	0x00, 0xfe, 0x4c, 0x00, 0x65, 0xff, 0x04, 0x00, 0x00, 0x1a, 0xff, 0x09,
+	0x00, 0x00, 0xff, 0x08,
+	0x01, 0x01, 0xff, 0x08, 0xff, 0xff, 0xff, 0x27, 0x00, 0x00, 0xff, 0x10,
+	0xff, 0xff, 0xff, 0x13,
+	0x00, 0x00, 0xfe, 0x78, 0x56, 0xfe, 0x34, 0x12, 0xff, 0x21, 0x00, 0x00,
+	0xfe, 0x04, 0xf7, 0xe8,
+	0x37, 0x7d, 0x0d, 0x01, 0xfe, 0x4a, 0x11, 0xfe, 0x04, 0xf7, 0xe8, 0x7d,
+	0x0d, 0x51, 0x37, 0xfe,
+	0x3d, 0xf0, 0xfe, 0x0c, 0x02, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x91, 0xf0,
+	0xfe, 0xf8, 0x01, 0xfe,
+	0x90, 0xf0, 0xfe, 0xf8, 0x01, 0xfe, 0x8f, 0xf0, 0xbc, 0x03, 0x67, 0x4d,
+	0x05, 0xfe, 0x08, 0x0f,
+	0x01, 0xfe, 0x78, 0x0f, 0xfe, 0xdd, 0x12, 0x05, 0xfe, 0x0e, 0x03, 0xfe,
+	0x28, 0x1c, 0x03, 0xfe,
+	0xa6, 0x00, 0xfe, 0xd1, 0x12, 0x3e, 0x22, 0xfe, 0xa6, 0x00, 0xac, 0xfe,
+	0x48, 0xf0, 0xfe, 0x90,
+	0x02, 0xfe, 0x49, 0xf0, 0xfe, 0xaa, 0x02, 0xfe, 0x4a, 0xf0, 0xfe, 0xc8,
+	0x02, 0xfe, 0x46, 0xf0,
+	0xfe, 0x5a, 0x02, 0xfe, 0x47, 0xf0, 0xfe, 0x60, 0x02, 0xfe, 0x43, 0xf0,
+	0xfe, 0x4e, 0x02, 0xfe,
+	0x44, 0xf0, 0xfe, 0x52, 0x02, 0xfe, 0x45, 0xf0, 0xfe, 0x56, 0x02, 0x1c,
+	0x0d, 0xa2, 0x1c, 0x07,
+	0x22, 0xb7, 0x05, 0x35, 0xfe, 0x00, 0x1c, 0xfe, 0xf1, 0x10, 0xfe, 0x02,
+	0x1c, 0xf5, 0xfe, 0x1e,
+	0x1c, 0xfe, 0xe9, 0x10, 0x01, 0x5f, 0xfe, 0xe7, 0x10, 0xfe, 0x06, 0xfc,
+	0xde, 0x0a, 0x81, 0x01,
+	0xa3, 0x05, 0x35, 0x1f, 0x95, 0x47, 0xb8, 0x01, 0xfe, 0xe4, 0x11, 0x0a,
+	0x81, 0x01, 0x5c, 0xfe,
+	0xbd, 0x10, 0x0a, 0x81, 0x01, 0x5c, 0xfe, 0xad, 0x10, 0xfe, 0x16, 0x1c,
+	0xfe, 0x58, 0x1c, 0x1c,
+	0x07, 0x22, 0xb7, 0x37, 0x2a, 0x35, 0xfe, 0x3d, 0xf0, 0xfe, 0x0c, 0x02,
+	0x2b, 0xfe, 0x9e, 0x02,
+	0xfe, 0x5a, 0x1c, 0xfe, 0x12, 0x1c, 0xfe, 0x14, 0x1c, 0x1f, 0xfe, 0x30,
+	0x00, 0x47, 0xb8, 0x01,
+	0xfe, 0xd4, 0x11, 0x1c, 0x07, 0x22, 0xb7, 0x05, 0xe9, 0x21, 0x2c, 0x09,
+	0x1a, 0x31, 0xfe, 0x69,
+	0x10, 0x1c, 0x07, 0x22, 0xb7, 0xfe, 0x04, 0xec, 0x2c, 0x60, 0x01, 0xfe,
+	0x1e, 0x1e, 0x20, 0x2c,
+	0xfe, 0x05, 0xf6, 0xde, 0x01, 0xfe, 0x62, 0x1b, 0x01, 0x0c, 0x61, 0x4a,
+	0x44, 0x15, 0x56, 0x51,
+	0x01, 0xfe, 0x9e, 0x1e, 0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x0a, 0x57,
+	0x01, 0x18, 0x09, 0x00,
+	0x36, 0x01, 0x85, 0xfe, 0x18, 0x10, 0xfe, 0x41, 0x58, 0x0a, 0xba, 0x01,
+	0x18, 0xfe, 0xc8, 0x54,
+	0x7b, 0xfe, 0x1c, 0x03, 0x01, 0xfe, 0x96, 0x1a, 0x05, 0x35, 0x37, 0x60,
+	0xfe, 0x02, 0xe8, 0x30,
+	0xfe, 0xbf, 0x57, 0xfe, 0x9e, 0x43, 0xfe, 0x77, 0x57, 0xfe, 0x27, 0xf0,
+	0xfe, 0xe4, 0x01, 0xfe,
+	0x07, 0x4b, 0xfe, 0x20, 0xf0, 0xbc, 0xfe, 0x40, 0x1c, 0x2a, 0xeb, 0xfe,
+	0x26, 0xf0, 0xfe, 0x66,
+	0x03, 0xfe, 0xa0, 0xf0, 0xfe, 0x54, 0x03, 0xfe, 0x11, 0xf0, 0xbc, 0xfe,
+	0xef, 0x10, 0xfe, 0x9f,
+	0xf0, 0xfe, 0x74, 0x03, 0xfe, 0x46, 0x1c, 0x19, 0xfe, 0x11, 0x00, 0x05,
+	0x70, 0x37, 0xfe, 0x48,
+	0x1c, 0xfe, 0x46, 0x1c, 0x01, 0x0c, 0x06, 0x28, 0xfe, 0x18, 0x13, 0x26,
+	0x21, 0xb9, 0xc7, 0x20,
+	0xb9, 0x0a, 0x57, 0x01, 0x18, 0xc7, 0x89, 0x01, 0xfe, 0xc8, 0x1a, 0x15,
+	0xe1, 0x2a, 0xeb, 0xfe,
+	0x01, 0xf0, 0xeb, 0xfe, 0x82, 0xf0, 0xfe, 0xa4, 0x03, 0xfe, 0x9c, 0x32,
+	0x15, 0xfe, 0xe4, 0x00,
+	0x2f, 0xfe, 0xb6, 0x03, 0x2a, 0x3c, 0x16, 0xfe, 0xc6, 0x03, 0x01, 0x41,
+	0xfe, 0x06, 0xf0, 0xfe,
+	0xd6, 0x03, 0xaf, 0xa0, 0xfe, 0x0a, 0xf0, 0xfe, 0xa2, 0x07, 0x05, 0x29,
+	0x03, 0x81, 0x1e, 0x1b,
+	0xfe, 0x24, 0x05, 0x1f, 0x63, 0x01, 0x42, 0x8f, 0xfe, 0x70, 0x02, 0x05,
+	0xea, 0xfe, 0x46, 0x1c,
+	0x37, 0x7d, 0x1d, 0xfe, 0x67, 0x1b, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57,
+	0xfe, 0x48, 0x1c, 0x75,
+	0x01, 0xa6, 0x86, 0x0a, 0x57, 0x01, 0x18, 0x09, 0x00, 0x1b, 0xec, 0x0a,
+	0xe1, 0x01, 0x18, 0x77,
+	0x50, 0x40, 0x8d, 0x30, 0x03, 0x81, 0x1e, 0xf8, 0x1f, 0x63, 0x01, 0x42,
+	0x8f, 0xfe, 0x70, 0x02,
+	0x05, 0xea, 0xd7, 0x99, 0xd8, 0x9c, 0x2a, 0x29, 0x2f, 0xfe, 0x4e, 0x04,
+	0x16, 0xfe, 0x4a, 0x04,
+	0x7e, 0xfe, 0xa0, 0x00, 0xfe, 0x9b, 0x57, 0xfe, 0x54, 0x12, 0x32, 0xff,
+	0x02, 0x00, 0x10, 0x01,
+	0x08, 0x16, 0xfe, 0x02, 0x05, 0x32, 0x01, 0x08, 0x16, 0x29, 0x27, 0x25,
+	0xee, 0xfe, 0x4c, 0x44,
+	0xfe, 0x58, 0x12, 0x50, 0xfe, 0x44, 0x48, 0x13, 0x34, 0xfe, 0x4c, 0x54,
+	0x7b, 0xec, 0x60, 0x8d,
+	0x30, 0x01, 0xfe, 0x4e, 0x1e, 0xfe, 0x48, 0x47, 0xfe, 0x7c, 0x13, 0x01,
+	0x0c, 0x06, 0x28, 0xfe,
+	0x32, 0x13, 0x01, 0x43, 0x09, 0x9b, 0xfe, 0x68, 0x13, 0xfe, 0x26, 0x10,
+	0x13, 0x34, 0xfe, 0x4c,
+	0x54, 0x7b, 0xec, 0x01, 0xfe, 0x4e, 0x1e, 0xfe, 0x48, 0x47, 0xfe, 0x54,
+	0x13, 0x01, 0x0c, 0x06,
+	0x28, 0xa5, 0x01, 0x43, 0x09, 0x9b, 0xfe, 0x40, 0x13, 0x01, 0x0c, 0x06,
+	0x28, 0xf9, 0x1f, 0x7f,
+	0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe, 0x0d, 0x00, 0x01, 0x42, 0x8f,
+	0xfe, 0xa4, 0x0e, 0x05,
+	0x29, 0x32, 0x15, 0xfe, 0xe6, 0x00, 0x0f, 0xfe, 0x1c, 0x90, 0x04, 0xfe,
+	0x9c, 0x93, 0x3a, 0x0b,
+	0x0e, 0x8b, 0x02, 0x1f, 0x7f, 0x01, 0x42, 0x05, 0x35, 0xfe, 0x42, 0x5b,
+	0x7d, 0x1d, 0xfe, 0x46,
+	0x59, 0xfe, 0xbf, 0x57, 0xfe, 0x77, 0x57, 0x0f, 0xfe, 0x87, 0x80, 0x04,
+	0xfe, 0x87, 0x83, 0xfe,
+	0xc9, 0x47, 0x0b, 0x0e, 0xd0, 0x65, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x98,
+	0x13, 0x0f, 0xfe, 0x20,
+	0x80, 0x04, 0xfe, 0xa0, 0x83, 0x33, 0x0b, 0x0e, 0x09, 0x1d, 0xfe, 0x84,
+	0x12, 0x01, 0x38, 0x06,
+	0x07, 0xfe, 0x70, 0x13, 0x03, 0xfe, 0xa2, 0x00, 0x1e, 0x1b, 0xfe, 0xda,
+	0x05, 0xd0, 0x54, 0x01,
+	0x38, 0x06, 0x0d, 0xfe, 0x58, 0x13, 0x03, 0xfe, 0xa0, 0x00, 0x1e, 0xfe,
+	0x50, 0x12, 0x5e, 0xff,
+	0x02, 0x00, 0x10, 0x2f, 0xfe, 0x90, 0x05, 0x2a, 0x3c, 0xcc, 0xff, 0x02,
+	0x00, 0x10, 0x2f, 0xfe,
+	0x9e, 0x05, 0x17, 0xfe, 0xf4, 0x05, 0x15, 0xfe, 0xe3, 0x00, 0x26, 0x01,
+	0x38, 0xfe, 0x4a, 0xf0,
+	0xfe, 0xc0, 0x05, 0xfe, 0x49, 0xf0, 0xfe, 0xba, 0x05, 0x71, 0x2e, 0xfe,
+	0x21, 0x00, 0xf1, 0x2e,
+	0xfe, 0x22, 0x00, 0xa2, 0x2e, 0x4a, 0xfe, 0x09, 0x48, 0xff, 0x02, 0x00,
+	0x10, 0x2f, 0xfe, 0xd0,
+	0x05, 0x17, 0xfe, 0xf4, 0x05, 0xfe, 0xe2, 0x08, 0x01, 0x38, 0x06, 0xfe,
+	0x1c, 0x00, 0x4d, 0x01,
+	0xa7, 0x2e, 0x07, 0x20, 0xe4, 0x47, 0xfe, 0x27, 0x01, 0x01, 0x0c, 0x06,
+	0x28, 0xfe, 0x24, 0x12,
+	0x3e, 0x01, 0x84, 0x1f, 0x7f, 0x01, 0x0c, 0x06, 0x07, 0x4d, 0x1f, 0xfe,
+	0x0d, 0x00, 0x01, 0x42,
+	0x8f, 0xfe, 0xa4, 0x0e, 0x05, 0x29, 0x03, 0xe6, 0x1e, 0xfe, 0xca, 0x13,
+	0x03, 0xb6, 0x1e, 0xfe,
+	0x40, 0x12, 0x03, 0x66, 0x1e, 0xfe, 0x38, 0x13, 0x3e, 0x01, 0x84, 0x17,
+	0xfe, 0x72, 0x06, 0x0a,
+	0x07, 0x01, 0x38, 0x06, 0x24, 0xfe, 0x02, 0x12, 0x4f, 0x01, 0xfe, 0x56,
+	0x19, 0x16, 0xfe, 0x68,
+	0x06, 0x15, 0x82, 0x01, 0x41, 0x15, 0xe2, 0x03, 0x66, 0x8a, 0x10, 0x66,
+	0x03, 0x9a, 0x1e, 0xfe,
+	0x70, 0x12, 0x03, 0x55, 0x1e, 0xfe, 0x68, 0x13, 0x01, 0xc6, 0x09, 0x12,
+	0x48, 0xfe, 0x92, 0x06,
+	0x2e, 0x12, 0x01, 0xfe, 0xac, 0x1d, 0xfe, 0x43, 0x48, 0x62, 0x80, 0x13,
+	0x58, 0xff, 0x02, 0x00,
+	0x57, 0x52, 0xad, 0x23, 0x3f, 0x4e, 0x62, 0x49, 0x3e, 0x01, 0x84, 0x17,
+	0xfe, 0xea, 0x06, 0x01,
+	0x38, 0x06, 0x12, 0xf7, 0x45, 0x0a, 0x95, 0x01, 0xfe, 0x84, 0x19, 0x16,
+	0xfe, 0xe0, 0x06, 0x15,
+	0x82, 0x01, 0x41, 0x15, 0xe2, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x1c, 0x07,
+	0x01, 0x84, 0xfe, 0xae,
+	0x10, 0x03, 0x6f, 0x1e, 0xfe, 0x9e, 0x13, 0x3e, 0x01, 0x84, 0x03, 0x9a,
+	0x1e, 0xfe, 0x1a, 0x12,
+	0x01, 0x38, 0x06, 0x12, 0xfc, 0x01, 0xc6, 0x01, 0xfe, 0xac, 0x1d, 0xfe,
+	0x43, 0x48, 0x62, 0x80,
+	0xf0, 0x45, 0x0a, 0x95, 0x03, 0xb6, 0x1e, 0xf8, 0x01, 0x38, 0x06, 0x24,
+	0x36, 0xfe, 0x02, 0xf6,
+	0x07, 0x71, 0x78, 0x8c, 0x00, 0x4d, 0x62, 0x49, 0x3e, 0x2d, 0x93, 0x4e,
+	0xd0, 0x0d, 0x17, 0xfe,
+	0x9a, 0x07, 0x01, 0xfe, 0xc0, 0x19, 0x16, 0xfe, 0x90, 0x07, 0x26, 0x20,
+	0x9e, 0x15, 0x82, 0x01,
+	0x41, 0x15, 0xe2, 0x21, 0x9e, 0x09, 0x07, 0xfb, 0x03, 0xe6, 0xfe, 0x58,
+	0x57, 0x10, 0xe6, 0x05,
+	0xfe, 0x2a, 0x06, 0x03, 0x6f, 0x8a, 0x10, 0x6f, 0x1c, 0x07, 0x01, 0x84,
+	0xfe, 0x9c, 0x32, 0x5f,
+	0x75, 0x01, 0xa6, 0x86, 0x15, 0xfe, 0xe2, 0x00, 0x2f, 0xed, 0x2a, 0x3c,
+	0xfe, 0x0a, 0xf0, 0xfe,
+	0xce, 0x07, 0xae, 0xfe, 0x96, 0x08, 0xfe, 0x06, 0xf0, 0xfe, 0x9e, 0x08,
+	0xaf, 0xa0, 0x05, 0x29,
+	0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x2e, 0x12, 0x14, 0x1d, 0x01, 0x08, 0x14,
+	0x00, 0x01, 0x08, 0x14,
+	0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0xfe, 0x99, 0xa4, 0x01, 0x08,
+	0x14, 0x00, 0x05, 0xfe,
+	0xc6, 0x09, 0x01, 0x76, 0x06, 0x12, 0xfe, 0x3a, 0x12, 0x01, 0x0c, 0x06,
+	0x12, 0xfe, 0x30, 0x13,
+	0x14, 0xfe, 0x1b, 0x00, 0x01, 0x08, 0x14, 0x00, 0x01, 0x08, 0x14, 0x00,
+	0x01, 0x08, 0x14, 0x00,
+	0x01, 0x08, 0x14, 0x07, 0x01, 0x08, 0x14, 0x00, 0x05, 0xef, 0x7c, 0x4a,
+	0x78, 0x4f, 0x0f, 0xfe,
+	0x9a, 0x81, 0x04, 0xfe, 0x9a, 0x83, 0xfe, 0xcb, 0x47, 0x0b, 0x0e, 0x2d,
+	0x28, 0x48, 0xfe, 0x6c,
+	0x08, 0x0a, 0x28, 0xfe, 0x09, 0x6f, 0xca, 0xfe, 0xca, 0x45, 0xfe, 0x32,
+	0x12, 0x53, 0x63, 0x4e,
+	0x7c, 0x97, 0x2f, 0xfe, 0x7e, 0x08, 0x2a, 0x3c, 0xfe, 0x0a, 0xf0, 0xfe,
+	0x6c, 0x08, 0xaf, 0xa0,
+	0xae, 0xfe, 0x96, 0x08, 0x05, 0x29, 0x01, 0x41, 0x05, 0xed, 0x14, 0x24,
+	0x05, 0xed, 0xfe, 0x9c,
+	0xf7, 0x9f, 0x01, 0xfe, 0xae, 0x1e, 0xfe, 0x18, 0x58, 0x01, 0xfe, 0xbe,
+	0x1e, 0xfe, 0x99, 0x58,
+	0xfe, 0x78, 0x18, 0xfe, 0xf9, 0x18, 0x8e, 0xfe, 0x16, 0x09, 0x10, 0x6a,
+	0x22, 0x6b, 0x01, 0x0c,
+	0x61, 0x54, 0x44, 0x21, 0x2c, 0x09, 0x1a, 0xf8, 0x77, 0x01, 0xfe, 0x7e,
+	0x1e, 0x47, 0x2c, 0x7a,
+	0x30, 0xf0, 0xfe, 0x83, 0xe7, 0xfe, 0x3f, 0x00, 0x71, 0xfe, 0x03, 0x40,
+	0x01, 0x0c, 0x61, 0x65,
+	0x44, 0x01, 0xc2, 0xc8, 0xfe, 0x1f, 0x40, 0x20, 0x6e, 0x01, 0xfe, 0x6a,
+	0x16, 0xfe, 0x08, 0x50,
+	0xfe, 0x8a, 0x50, 0xfe, 0x44, 0x51, 0xfe, 0xc6, 0x51, 0xfe, 0x10, 0x10,
+	0x01, 0xfe, 0xce, 0x1e,
+	0x01, 0xfe, 0xde, 0x1e, 0x10, 0x68, 0x22, 0x69, 0x01, 0xfe, 0xee, 0x1e,
+	0x01, 0xfe, 0xfe, 0x1e,
+	0xfe, 0x40, 0x50, 0xfe, 0xc2, 0x50, 0x10, 0x4b, 0x22, 0x4c, 0xfe, 0x8a,
+	0x10, 0x01, 0x0c, 0x06,
+	0x54, 0xfe, 0x50, 0x12, 0x01, 0xfe, 0xae, 0x1e, 0x01, 0xfe, 0xbe, 0x1e,
+	0x10, 0x6a, 0x22, 0x6b,
+	0x01, 0x0c, 0x06, 0x65, 0x4e, 0x01, 0xc2, 0x0f, 0xfe, 0x1f, 0x80, 0x04,
+	0xfe, 0x9f, 0x83, 0x33,
+	0x0b, 0x0e, 0x20, 0x6e, 0x0f, 0xfe, 0x44, 0x90, 0x04, 0xfe, 0xc4, 0x93,
+	0x3a, 0x0b, 0xfe, 0xc6,
+	0x90, 0x04, 0xfe, 0xc6, 0x93, 0x79, 0x0b, 0x0e, 0x10, 0x6c, 0x22, 0x6d,
+	0x01, 0xfe, 0xce, 0x1e,
+	0x01, 0xfe, 0xde, 0x1e, 0x10, 0x68, 0x22, 0x69, 0x0f, 0xfe, 0x40, 0x90,
+	0x04, 0xfe, 0xc0, 0x93,
+	0x3a, 0x0b, 0xfe, 0xc2, 0x90, 0x04, 0xfe, 0xc2, 0x93, 0x79, 0x0b, 0x0e,
+	0x10, 0x4b, 0x22, 0x4c,
+	0x10, 0x64, 0x22, 0x34, 0x01, 0x0c, 0x61, 0x24, 0x44, 0x37, 0x13, 0xfe,
+	0x4e, 0x11, 0x2f, 0xfe,
+	0xde, 0x09, 0xfe, 0x9e, 0xf0, 0xfe, 0xf2, 0x09, 0xfe, 0x01, 0x48, 0x1b,
+	0x3c, 0x37, 0x88, 0xf5,
+	0xd4, 0xfe, 0x1e, 0x0a, 0xd5, 0xfe, 0x42, 0x0a, 0xd2, 0xfe, 0x1e, 0x0a,
+	0xd3, 0xfe, 0x42, 0x0a,
+	0xae, 0xfe, 0x12, 0x0a, 0xfe, 0x06, 0xf0, 0xfe, 0x18, 0x0a, 0xaf, 0xa0,
+	0x05, 0x29, 0x01, 0x41,
+	0xfe, 0xc1, 0x10, 0x14, 0x24, 0xfe, 0xc1, 0x10, 0x01, 0x76, 0x06, 0x07,
+	0xfe, 0x14, 0x12, 0x01,
+	0x76, 0x06, 0x0d, 0x5d, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x74, 0x12, 0xfe,
+	0x2e, 0x1c, 0x05, 0xfe,
+	0x1a, 0x0c, 0x01, 0x76, 0x06, 0x07, 0x5d, 0x01, 0x76, 0x06, 0x0d, 0x41,
+	0xfe, 0x2c, 0x1c, 0xfe,
+	0xaa, 0xf0, 0xfe, 0xce, 0x0a, 0xfe, 0xac, 0xf0, 0xfe, 0x66, 0x0a, 0xfe,
+	0x92, 0x10, 0xc4, 0xf6,
+	0xfe, 0xad, 0xf0, 0xfe, 0x72, 0x0a, 0x05, 0xfe, 0x1a, 0x0c, 0xc5, 0xfe,
+	0xe7, 0x10, 0xfe, 0x2b,
+	0xf0, 0xbf, 0xfe, 0x6b, 0x18, 0x23, 0xfe, 0x00, 0xfe, 0xfe, 0x1c, 0x12,
+	0xac, 0xfe, 0xd2, 0xf0,
+	0xbf, 0xfe, 0x76, 0x18, 0x23, 0x1d, 0x1b, 0xbf, 0x03, 0xe3, 0x23, 0x07,
+	0x1b, 0xbf, 0xd4, 0x5b,
+	0xd5, 0x5b, 0xd2, 0x5b, 0xd3, 0x5b, 0xc4, 0xc5, 0xfe, 0xa9, 0x10, 0x75,
+	0x5e, 0x32, 0x1f, 0x7f,
+	0x01, 0x42, 0x19, 0xfe, 0x35, 0x00, 0xfe, 0x01, 0xf0, 0x70, 0x19, 0x98,
+	0x05, 0x70, 0xfe, 0x74,
+	0x18, 0x23, 0xfe, 0x00, 0xf8, 0x1b, 0x5b, 0x7d, 0x12, 0x01, 0xfe, 0x78,
+	0x0f, 0x4d, 0x01, 0xfe,
+	0x96, 0x1a, 0x21, 0x30, 0x77, 0x7d, 0x1d, 0x05, 0x5b, 0x01, 0x0c, 0x06,
+	0x0d, 0x2b, 0xfe, 0xe2,
+	0x0b, 0x01, 0x0c, 0x06, 0x54, 0xfe, 0xa6, 0x12, 0x01, 0x0c, 0x06, 0x24,
+	0xfe, 0x88, 0x13, 0x21,
+	0x6e, 0xc7, 0x01, 0xfe, 0x1e, 0x1f, 0x0f, 0xfe, 0x83, 0x80, 0x04, 0xfe,
+	0x83, 0x83, 0xfe, 0xc9,
+	0x47, 0x0b, 0x0e, 0xfe, 0xc8, 0x44, 0xfe, 0x42, 0x13, 0x0f, 0xfe, 0x04,
+	0x91, 0x04, 0xfe, 0x84,
+	0x93, 0xfe, 0xca, 0x57, 0x0b, 0xfe, 0x86, 0x91, 0x04, 0xfe, 0x86, 0x93,
+	0xfe, 0xcb, 0x57, 0x0b,
+	0x0e, 0x7a, 0x30, 0xfe, 0x40, 0x59, 0xfe, 0xc1, 0x59, 0x8e, 0x40, 0x03,
+	0x6a, 0x3b, 0x6b, 0x10,
+	0x97, 0x22, 0x98, 0xd9, 0x6a, 0xda, 0x6b, 0x01, 0xc2, 0xc8, 0x7a, 0x30,
+	0x20, 0x6e, 0xdb, 0x64,
+	0xdc, 0x34, 0x91, 0x6c, 0x7e, 0x6d, 0xfe, 0x44, 0x55, 0xfe, 0xe5, 0x55,
+	0xfe, 0x04, 0xfa, 0x64,
+	0xfe, 0x05, 0xfa, 0x34, 0x01, 0xfe, 0x6a, 0x16, 0xa3, 0x26, 0x10, 0x97,
+	0x10, 0x98, 0x91, 0x6c,
+	0x7e, 0x6d, 0xfe, 0x14, 0x10, 0x01, 0x0c, 0x06, 0x24, 0x1b, 0x40, 0x91,
+	0x4b, 0x7e, 0x4c, 0x01,
+	0x0c, 0x06, 0xfe, 0xf7, 0x00, 0x44, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x10,
+	0x58, 0xfe, 0x91, 0x58,
+	0xfe, 0x14, 0x59, 0xfe, 0x95, 0x59, 0x05, 0x5b, 0x01, 0x0c, 0x06, 0x24,
+	0x1b, 0x40, 0x01, 0x0c,
+	0x06, 0xfe, 0xf7, 0x00, 0x44, 0x78, 0x01, 0xfe, 0x8e, 0x1e, 0x4f, 0x0f,
+	0xfe, 0x10, 0x90, 0x04,
+	0xfe, 0x90, 0x93, 0x3a, 0x0b, 0xfe, 0x92, 0x90, 0x04, 0xfe, 0x92, 0x93,
+	0x79, 0x0b, 0x0e, 0xfe,
+	0xbd, 0x10, 0x01, 0x43, 0x09, 0xbb, 0x1b, 0xfe, 0x6e, 0x0a, 0x15, 0xbb,
+	0x01, 0x0c, 0x06, 0x0d,
+	0xfe, 0x14, 0x13, 0x03, 0x4b, 0x3b, 0x4c, 0x8e, 0xfe, 0x6e, 0x0a, 0xfe,
+	0x0c, 0x58, 0xfe, 0x8d,
+	0x58, 0x05, 0x5b, 0x26, 0x3e, 0x0f, 0xfe, 0x19, 0x80, 0x04, 0xfe, 0x99,
+	0x83, 0x33, 0x0b, 0x0e,
+	0xfe, 0xe5, 0x10, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1a, 0x12, 0xfe, 0x6c,
+	0x19, 0xfe, 0x19, 0x41,
+	0xfe, 0x6b, 0x18, 0xac, 0xfe, 0xd1, 0xf0, 0xef, 0x1f, 0x92, 0x01, 0x42,
+	0x19, 0xfe, 0x44, 0x00,
+	0xfe, 0x90, 0x10, 0xfe, 0x6c, 0x19, 0xd9, 0x4b, 0xfe, 0xed, 0x19, 0xda,
+	0x4c, 0xfe, 0x0c, 0x51,
+	0xfe, 0x8e, 0x51, 0xfe, 0x6b, 0x18, 0x23, 0xfe, 0x00, 0xff, 0x31, 0xfe,
+	0x76, 0x10, 0xac, 0xfe,
+	0xd2, 0xf0, 0xfe, 0xba, 0x0c, 0xfe, 0x76, 0x18, 0x23, 0x1d, 0x5d, 0x03,
+	0xe3, 0x23, 0x07, 0xfe,
+	0x08, 0x13, 0x19, 0xfe, 0x16, 0x00, 0x05, 0x70, 0xfe, 0xd1, 0xf0, 0xfe,
+	0xcc, 0x0c, 0x1f, 0x92,
+	0x01, 0x42, 0x19, 0xfe, 0x17, 0x00, 0x5c, 0xfe, 0xce, 0xf0, 0xfe, 0xd2,
+	0x0c, 0xfe, 0x3e, 0x10,
+	0xfe, 0xcd, 0xf0, 0xfe, 0xde, 0x0c, 0x19, 0xfe, 0x22, 0x00, 0x05, 0x70,
+	0xfe, 0xcb, 0xf0, 0xfe,
+	0xea, 0x0c, 0x19, 0xfe, 0x24, 0x00, 0x05, 0x70, 0xfe, 0xd0, 0xf0, 0xfe,
+	0xf4, 0x0c, 0x19, 0x94,
+	0xfe, 0x1c, 0x10, 0xfe, 0xcf, 0xf0, 0xfe, 0xfe, 0x0c, 0x19, 0x4a, 0xf3,
+	0xfe, 0xcc, 0xf0, 0xef,
+	0x01, 0x76, 0x06, 0x24, 0x4d, 0x19, 0xfe, 0x12, 0x00, 0x37, 0x13, 0xfe,
+	0x4e, 0x11, 0x2f, 0xfe,
+	0x16, 0x0d, 0xfe, 0x9e, 0xf0, 0xfe, 0x2a, 0x0d, 0xfe, 0x01, 0x48, 0x1b,
+	0x3c, 0x37, 0x88, 0xf5,
+	0xd4, 0x29, 0xd5, 0x29, 0xd2, 0x29, 0xd3, 0x29, 0x37, 0xfe, 0x9c, 0x32,
+	0x2f, 0xfe, 0x3e, 0x0d,
+	0x2a, 0x3c, 0xae, 0xfe, 0x62, 0x0d, 0xaf, 0xa0, 0xd4, 0x9f, 0xd5, 0x9f,
+	0xd2, 0x9f, 0xd3, 0x9f,
+	0x05, 0x29, 0x01, 0x41, 0xfe, 0xd3, 0x10, 0x15, 0xfe, 0xe8, 0x00, 0xc4,
+	0xc5, 0x75, 0xd7, 0x99,
+	0xd8, 0x9c, 0xfe, 0x89, 0xf0, 0x29, 0x27, 0x25, 0xbe, 0xd7, 0x99, 0xd8,
+	0x9c, 0x2f, 0xfe, 0x8c,
+	0x0d, 0x16, 0x29, 0x27, 0x25, 0xbd, 0xfe, 0x01, 0x48, 0xa4, 0x19, 0xfe,
+	0x42, 0x00, 0x05, 0x70,
+	0x90, 0x07, 0xfe, 0x81, 0x49, 0x1b, 0xfe, 0x64, 0x0e, 0x01, 0x0c, 0x06,
+	0x0d, 0xfe, 0x44, 0x13,
+	0x19, 0x00, 0x2d, 0x0d, 0xfe, 0x54, 0x12, 0x2d, 0xfe, 0x28, 0x00, 0x2b,
+	0xfe, 0xda, 0x0e, 0x0a,
+	0x57, 0x01, 0x18, 0x09, 0x00, 0x36, 0x46, 0xfe, 0x28, 0x00, 0xfe, 0xfa,
+	0x10, 0x01, 0xfe, 0xf4,
+	0x1c, 0x01, 0xfe, 0x00, 0x1d, 0x0a, 0xba, 0x01, 0xfe, 0x58, 0x10, 0x40,
+	0x15, 0x56, 0x01, 0x85,
+	0x05, 0x35, 0x19, 0xfe, 0x44, 0x00, 0x2d, 0x0d, 0xf7, 0x46, 0x0d, 0xfe,
+	0xcc, 0x10, 0x01, 0xa7,
+	0x46, 0x0d, 0xfe, 0xc2, 0x10, 0x01, 0xa7, 0x0f, 0xfe, 0x19, 0x82, 0x04,
+	0xfe, 0x99, 0x83, 0xfe,
+	0xcc, 0x47, 0x0b, 0x0e, 0xfe, 0x34, 0x46, 0xa5, 0x46, 0x0d, 0x19, 0xfe,
+	0x43, 0x00, 0xfe, 0xa2,
+	0x10, 0x01, 0x0c, 0x61, 0x0d, 0x44, 0x01, 0xfe, 0xf4, 0x1c, 0x01, 0xfe,
+	0x00, 0x1d, 0x40, 0x15,
+	0x56, 0x01, 0x85, 0x7d, 0x0d, 0x40, 0x51, 0x01, 0xfe, 0x9e, 0x1e, 0x05,
+	0xfe, 0x3a, 0x03, 0x01,
+	0x0c, 0x06, 0x0d, 0x5d, 0x46, 0x0d, 0x19, 0x00, 0xfe, 0x62, 0x10, 0x01,
+	0x76, 0x06, 0x12, 0xfe,
+	0x5c, 0x12, 0x01, 0x0c, 0x06, 0x12, 0xfe, 0x52, 0x13, 0xfe, 0x1c, 0x1c,
+	0xfe, 0x9d, 0xf0, 0xfe,
+	0x8e, 0x0e, 0xfe, 0x1c, 0x1c, 0xfe, 0x9d, 0xf0, 0xfe, 0x94, 0x0e, 0x01,
+	0x0c, 0x61, 0x12, 0x44,
+	0xfe, 0x9f, 0x10, 0x19, 0xfe, 0x15, 0x00, 0xfe, 0x04, 0xe6, 0x0d, 0x4f,
+	0xfe, 0x2e, 0x10, 0x19,
+	0xfe, 0x13, 0x00, 0xfe, 0x10, 0x10, 0x19, 0xfe, 0x47, 0x00, 0xf1, 0x19,
+	0xfe, 0x41, 0x00, 0xa2,
+	0x19, 0xfe, 0x24, 0x00, 0x86, 0xc4, 0xc5, 0x75, 0x03, 0x81, 0x1e, 0x2b,
+	0xea, 0x4f, 0xfe, 0x04,
+	0xe6, 0x12, 0xfe, 0x9d, 0x41, 0xfe, 0x1c, 0x42, 0x40, 0x01, 0xf4, 0x05,
+	0x35, 0xfe, 0x12, 0x1c,
+	0x1f, 0x0d, 0x47, 0xb5, 0xc3, 0x1f, 0xfe, 0x31, 0x00, 0x47, 0xb8, 0x01,
+	0xfe, 0xd4, 0x11, 0x05,
+	0xe9, 0x51, 0xfe, 0x06, 0xec, 0xe0, 0xfe, 0x0e, 0x47, 0x46, 0x28, 0xfe,
+	0xce, 0x45, 0x31, 0x51,
+	0xfe, 0x06, 0xea, 0xe0, 0xfe, 0x47, 0x4b, 0x45, 0xfe, 0x75, 0x57, 0x03,
+	0x67, 0xfe, 0x98, 0x56,
+	0xfe, 0x38, 0x12, 0x0a, 0x5a, 0x01, 0x18, 0xfe, 0x44, 0x48, 0x60, 0x01,
+	0x0c, 0x06, 0x28, 0xfe,
+	0x18, 0x13, 0x0a, 0x57, 0x01, 0x18, 0x3e, 0xfe, 0x41, 0x58, 0x0a, 0xba,
+	0xfe, 0xfa, 0x14, 0xfe,
+	0x49, 0x54, 0xb0, 0xfe, 0x5e, 0x0f, 0x05, 0xfe, 0x3a, 0x03, 0x0a, 0x67,
+	0xfe, 0xe0, 0x14, 0xfe,
+	0x0e, 0x47, 0x46, 0x28, 0xfe, 0xce, 0x45, 0x31, 0x51, 0xfe, 0xce, 0x47,
+	0xfe, 0xad, 0x13, 0x05,
+	0x35, 0x21, 0x2c, 0x09, 0x1a, 0xfe, 0x98, 0x12, 0x26, 0x20, 0x96, 0x20,
+	0xe7, 0xfe, 0x08, 0x1c,
+	0xfe, 0x7c, 0x19, 0xfe, 0xfd, 0x19, 0xfe, 0x0a, 0x1c, 0x03, 0xe5, 0xfe,
+	0x48, 0x55, 0xa5, 0x3b,
+	0xfe, 0x62, 0x01, 0xfe, 0xc9, 0x55, 0x31, 0xfe, 0x74, 0x10, 0x01, 0xfe,
+	0xf0, 0x1a, 0x03, 0xfe,
+	0x38, 0x01, 0x3b, 0xfe, 0x3a, 0x01, 0x8e, 0xfe, 0x1e, 0x10, 0xfe, 0x02,
+	0xec, 0xe7, 0x53, 0x00,
+	0x36, 0xfe, 0x04, 0xec, 0x2c, 0x60, 0xfe, 0x05, 0xf6, 0xfe, 0x34, 0x01,
+	0x01, 0xfe, 0x62, 0x1b,
+	0x01, 0xfe, 0xce, 0x1e, 0xb2, 0x11, 0xfe, 0x18, 0x13, 0xca, 0xfe, 0x02,
+	0xea, 0xe7, 0x53, 0x92,
+	0xfe, 0xc3, 0x13, 0x1f, 0x12, 0x47, 0xb5, 0xc3, 0xfe, 0x2a, 0x10, 0x03,
+	0xfe, 0x38, 0x01, 0x23,
+	0xfe, 0xf0, 0xff, 0x10, 0xe5, 0x03, 0xfe, 0x3a, 0x01, 0x10, 0xfe, 0x62,
+	0x01, 0x01, 0xfe, 0x1e,
+	0x1e, 0x20, 0x2c, 0x15, 0x56, 0x01, 0xfe, 0x9e, 0x1e, 0x13, 0x07, 0x02,
+	0x26, 0x02, 0x21, 0x96,
+	0xc7, 0x20, 0x96, 0x09, 0x92, 0xfe, 0x79, 0x13, 0x1f, 0x1d, 0x47, 0xb5,
+	0xc3, 0xfe, 0xe1, 0x10,
+	0xcf, 0xfe, 0x03, 0xdc, 0xfe, 0x73, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xcf,
+	0xfe, 0x03, 0xdc, 0xfe,
+	0x5b, 0x57, 0xfe, 0x80, 0x5d, 0x02, 0xfe, 0x03, 0x57, 0xcf, 0x26, 0xfe,
+	0x00, 0xcc, 0x02, 0xfe,
+	0x03, 0x57, 0xcf, 0x89, 0x02, 0x01, 0x0c, 0x06, 0x4a, 0xfe, 0x4e, 0x13,
+	0x0f, 0xfe, 0x1c, 0x80,
+	0x04, 0xfe, 0x9c, 0x83, 0x33, 0x0b, 0x0e, 0x09, 0x07, 0xfe, 0x3a, 0x13,
+	0x0f, 0xfe, 0x1e, 0x80,
+	0x04, 0xfe, 0x9e, 0x83, 0x33, 0x0b, 0x0e, 0xfe, 0x2a, 0x13, 0x0f, 0xfe,
+	0x1d, 0x80, 0x04, 0xfe,
+	0x9d, 0x83, 0xfe, 0xf9, 0x13, 0x0e, 0xfe, 0x1c, 0x13, 0x01, 0xfe, 0xee,
+	0x1e, 0xac, 0xfe, 0x14,
+	0x13, 0x01, 0xfe, 0xfe, 0x1e, 0xfe, 0x81, 0x58, 0xfa, 0x01, 0xfe, 0x0e,
+	0x1f, 0xfe, 0x30, 0xf4,
+	0x0d, 0xfe, 0x3c, 0x50, 0xa2, 0x01, 0xfe, 0x92, 0x1b, 0x01, 0x43, 0x09,
+	0x56, 0xfb, 0x01, 0xfe,
+	0xc8, 0x1a, 0x01, 0x0c, 0x06, 0x28, 0xa4, 0x01, 0xfe, 0xf4, 0x1c, 0x01,
+	0xfe, 0x00, 0x1d, 0x15,
+	0xfe, 0xe9, 0x00, 0x01, 0x0c, 0x06, 0x4a, 0xfe, 0x4e, 0x13, 0x01, 0xfe,
+	0x22, 0x1b, 0xfe, 0x1e,
+	0x1c, 0x0f, 0xfe, 0x14, 0x90, 0x04, 0xfe, 0x94, 0x93, 0x3a, 0x0b, 0xfe,
+	0x96, 0x90, 0x04, 0xfe,
+	0x96, 0x93, 0x79, 0x0b, 0x0e, 0x10, 0xfe, 0x64, 0x01, 0x22, 0xfe, 0x66,
+	0x01, 0x01, 0x0c, 0x06,
+	0x65, 0xf9, 0x0f, 0xfe, 0x03, 0x80, 0x04, 0xfe, 0x83, 0x83, 0x33, 0x0b,
+	0x0e, 0x77, 0xfe, 0x01,
+	0xec, 0x2c, 0xfe, 0x80, 0x40, 0x20, 0x2c, 0x7a, 0x30, 0x15, 0xdf, 0x40,
+	0x21, 0x2c, 0xfe, 0x00,
+	0x40, 0x8d, 0x2c, 0x02, 0xfe, 0x08, 0x1c, 0x03, 0xfe, 0xac, 0x00, 0xfe,
+	0x06, 0x58, 0x03, 0xfe,
+	0xae, 0x00, 0xfe, 0x07, 0x58, 0x03, 0xfe, 0xb0, 0x00, 0xfe, 0x08, 0x58,
+	0x03, 0xfe, 0xb2, 0x00,
+	0xfe, 0x09, 0x58, 0xfe, 0x0a, 0x1c, 0x2e, 0x49, 0x20, 0xe0, 0x26, 0x10,
+	0x66, 0x10, 0x55, 0x10,
+	0x6f, 0x13, 0x57, 0x52, 0x4f, 0x1c, 0x28, 0xfe, 0x90, 0x4d, 0xfe, 0x91,
+	0x54, 0x2b, 0xfe, 0x88,
+	0x11, 0x46, 0x1a, 0x13, 0x5a, 0x52, 0x1c, 0x4a, 0xfe, 0x90, 0x4d, 0xfe,
+	0x91, 0x54, 0x2b, 0xfe,
+	0x9e, 0x11, 0x2e, 0x1a, 0x20, 0x2c, 0x90, 0x34, 0x60, 0x21, 0x2c, 0xfe,
+	0x00, 0x40, 0x8d, 0x2c,
+	0x15, 0xdf, 0xfe, 0x14, 0x56, 0xfe, 0xd6, 0xf0, 0xfe, 0xb2, 0x11, 0xfe,
+	0x12, 0x1c, 0x75, 0xfe,
+	0x14, 0x1c, 0xfe, 0x10, 0x1c, 0xfe, 0x18, 0x1c, 0x02, 0x51, 0xfe, 0x0c,
+	0x14, 0xfe, 0x0e, 0x47,
+	0xfe, 0x07, 0xe6, 0x28, 0xfe, 0xce, 0x47, 0xfe, 0xf5, 0x13, 0x02, 0x01,
+	0xa7, 0x90, 0x34, 0x60,
+	0xfe, 0x06, 0x80, 0xfe, 0x48, 0x47, 0xfe, 0x42, 0x13, 0xfe, 0x02, 0x80,
+	0x09, 0x56, 0xfe, 0x34,
+	0x13, 0x0a, 0x5a, 0x01, 0x18, 0xcb, 0xfe, 0x36, 0x12, 0xfe, 0x41, 0x48,
+	0xfe, 0x45, 0x48, 0x01,
+	0xfe, 0xb2, 0x16, 0xfe, 0x00, 0xcc, 0xcb, 0xfe, 0xf3, 0x13, 0x3f, 0x89,
+	0x09, 0x1a, 0xa5, 0x0a,
+	0x9d, 0x01, 0x18, 0xfe, 0x80, 0x5c, 0x01, 0x85, 0xf2, 0x09, 0x9b, 0xa4,
+	0xfe, 0x14, 0x56, 0xfe,
+	0xd6, 0xf0, 0xfe, 0xec, 0x11, 0x02, 0xfe, 0x44, 0x58, 0x77, 0xfe, 0x01,
+	0xec, 0xb8, 0xfe, 0x9e,
+	0x40, 0xfe, 0x9d, 0xe7, 0x00, 0xfe, 0x9c, 0xe7, 0x12, 0x8d, 0x30, 0x01,
+	0xf4, 0xfe, 0xdd, 0x10,
+	0x37, 0xd7, 0x99, 0xd8, 0x9c, 0x27, 0x25, 0xee, 0x09, 0x12, 0xfe, 0x48,
+	0x12, 0x09, 0x0d, 0xfe,
+	0x56, 0x12, 0x09, 0x1d, 0xfe, 0x30, 0x12, 0x09, 0xdd, 0x1b, 0xfe, 0xc4,
+	0x13, 0x09, 0xfe, 0x23,
+	0x00, 0x1b, 0xfe, 0xd0, 0x13, 0x09, 0x07, 0x1b, 0xfe, 0x34, 0x14, 0x09,
+	0x24, 0xfe, 0x12, 0x12,
+	0x09, 0x00, 0x1b, 0x29, 0x1f, 0xdd, 0x01, 0x42, 0xa1, 0x32, 0x01, 0x08,
+	0xae, 0x41, 0x02, 0x32,
+	0xfe, 0x62, 0x08, 0x0a, 0xe1, 0x01, 0xfe, 0x58, 0x10, 0x15, 0x9b, 0x05,
+	0x35, 0x32, 0x01, 0x43,
+	0x09, 0xbb, 0xfe, 0xd7, 0x13, 0x91, 0x4b, 0x7e, 0x4c, 0x8e, 0xfe, 0x80,
+	0x13, 0x01, 0x0c, 0x06,
+	0x54, 0xfe, 0x72, 0x12, 0xdb, 0x64, 0xdc, 0x34, 0xfe, 0x44, 0x55, 0xfe,
+	0xe5, 0x55, 0xb0, 0xfe,
+	0x4a, 0x13, 0x21, 0x6e, 0xfe, 0x26, 0x13, 0x03, 0x97, 0x3b, 0x98, 0x8e,
+	0xfe, 0xb6, 0x0e, 0x10,
+	0x6a, 0x22, 0x6b, 0x26, 0x10, 0x97, 0x10, 0x98, 0x01, 0xc2, 0x2e, 0x49,
+	0x88, 0x20, 0x6e, 0x01,
+	0xfe, 0x6a, 0x16, 0xdb, 0x64, 0xdc, 0x34, 0xfe, 0x04, 0x55, 0xfe, 0xa5,
+	0x55, 0xfe, 0x04, 0xfa,
+	0x64, 0xfe, 0x05, 0xfa, 0x34, 0xfe, 0x8f, 0x10, 0x03, 0x6c, 0x3b, 0x6d,
+	0xfe, 0x40, 0x56, 0xfe,
+	0xe1, 0x56, 0x10, 0x6c, 0x22, 0x6d, 0x71, 0xdb, 0x64, 0xdc, 0x34, 0xfe,
+	0x44, 0x55, 0xfe, 0xe5,
+	0x55, 0x03, 0x68, 0x3b, 0x69, 0xfe, 0x00, 0x56, 0xfe, 0xa1, 0x56, 0x10,
+	0x68, 0x22, 0x69, 0x01,
+	0x0c, 0x06, 0x54, 0xf9, 0x21, 0x6e, 0xfe, 0x1f, 0x40, 0x03, 0x6a, 0x3b,
+	0x6b, 0xfe, 0x2c, 0x50,
+	0xfe, 0xae, 0x50, 0x03, 0x6c, 0x3b, 0x6d, 0xfe, 0x44, 0x50, 0xfe, 0xc6,
+	0x50, 0x03, 0x68, 0x3b,
+	0x69, 0xfe, 0x08, 0x50, 0xfe, 0x8a, 0x50, 0x03, 0x4b, 0x3b, 0x4c, 0xfe,
+	0x40, 0x50, 0xfe, 0xc2,
+	0x50, 0x05, 0x73, 0x2e, 0x07, 0x20, 0x9e, 0x05, 0x72, 0x32, 0x01, 0x08,
+	0x16, 0x3d, 0x27, 0x25,
+	0xee, 0x09, 0x07, 0x2b, 0x3d, 0x01, 0x43, 0x09, 0xbb, 0x2b, 0x72, 0x01,
+	0xa6, 0x23, 0x3f, 0x1b,
+	0x3d, 0x01, 0x0c, 0x06, 0x0d, 0xfe, 0x1e, 0x13, 0x91, 0x4b, 0x7e, 0x4c,
+	0xfe, 0x0a, 0x55, 0x31,
+	0xfe, 0x8b, 0x55, 0xd9, 0x4b, 0xda, 0x4c, 0xfe, 0x0c, 0x51, 0xfe, 0x8e,
+	0x51, 0x05, 0x72, 0x01,
+	0xfe, 0x8e, 0x1e, 0xca, 0xfe, 0x19, 0x41, 0x05, 0x72, 0x32, 0x01, 0x08,
+	0x2a, 0x3c, 0x16, 0xc0,
+	0x27, 0x25, 0xbe, 0x2d, 0x1d, 0xc0, 0x2d, 0x0d, 0x83, 0x2d, 0x7f, 0x1b,
+	0xfe, 0x66, 0x15, 0x05,
+	0x3d, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0xc0, 0x27, 0x25, 0xbd, 0x09, 0x1d,
+	0x2b, 0x3d, 0x01, 0x08,
+	0x16, 0xc0, 0x27, 0x25, 0xfe, 0xe8, 0x09, 0xfe, 0xc2, 0x49, 0x50, 0x03,
+	0xb6, 0x1e, 0x83, 0x01,
+	0x38, 0x06, 0x24, 0x31, 0xa1, 0xfe, 0xbb, 0x45, 0x2d, 0x00, 0xa4, 0x46,
+	0x07, 0x90, 0x3f, 0x01,
+	0xfe, 0xf8, 0x15, 0x01, 0xa6, 0x86, 0xfe, 0x4b, 0x45, 0xfe, 0x20, 0x13,
+	0x01, 0x43, 0x09, 0x82,
+	0xfe, 0x16, 0x13, 0x03, 0x9a, 0x1e, 0x5d, 0x03, 0x55, 0x1e, 0x31, 0x5e,
+	0x05, 0x72, 0xfe, 0xc0,
+	0x5d, 0x01, 0xa7, 0xfe, 0x03, 0x17, 0x03, 0x66, 0x8a, 0x10, 0x66, 0x5e,
+	0x32, 0x01, 0x08, 0x17,
+	0x73, 0x01, 0xfe, 0x56, 0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16,
+	0x3d, 0x27, 0x25, 0xbd,
+	0x09, 0x07, 0x2b, 0x3d, 0x01, 0xfe, 0xbe, 0x16, 0xfe, 0x42, 0x58, 0xfe,
+	0xe8, 0x14, 0x01, 0xa6,
+	0x86, 0xfe, 0x4a, 0xf4, 0x0d, 0x1b, 0x3d, 0xfe, 0x4a, 0xf4, 0x07, 0xfe,
+	0x0e, 0x12, 0x01, 0x43,
+	0x09, 0x82, 0x4e, 0x05, 0x72, 0x03, 0x55, 0x8a, 0x10, 0x55, 0x5e, 0x32,
+	0x01, 0x08, 0x17, 0x73,
+	0x01, 0xfe, 0x84, 0x19, 0x05, 0x73, 0x01, 0x08, 0x2a, 0x3c, 0x16, 0x3d,
+	0x27, 0x25, 0xbd, 0x09,
+	0x12, 0x2b, 0x3d, 0x01, 0xfe, 0xe8, 0x17, 0x8b, 0xfe, 0xaa, 0x14, 0xfe,
+	0xb6, 0x14, 0x86, 0xa8,
+	0xb2, 0x0d, 0x1b, 0x3d, 0xb2, 0x07, 0xfe, 0x0e, 0x12, 0x01, 0x43, 0x09,
+	0x82, 0x4e, 0x05, 0x72,
+	0x03, 0x6f, 0x8a, 0x10, 0x6f, 0x5e, 0x32, 0x01, 0x08, 0x17, 0x73, 0x01,
+	0xfe, 0xc0, 0x19, 0x05,
+	0x73, 0x13, 0x07, 0x2f, 0xfe, 0xcc, 0x15, 0x17, 0xfe, 0xe2, 0x15, 0x5f,
+	0xcc, 0x01, 0x08, 0x26,
+	0x5f, 0x02, 0x8f, 0xfe, 0xde, 0x15, 0x2a, 0xfe, 0xde, 0x15, 0x16, 0xfe,
+	0xcc, 0x15, 0x5e, 0x32,
+	0x01, 0x08, 0xfe, 0xd5, 0x10, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52,
+	0xad, 0x23, 0xfe, 0xff,
+	0x7f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x02, 0x13, 0x58, 0xff, 0x02,
+	0x00, 0x57, 0x52, 0xad,
+	0x23, 0x3f, 0xfe, 0x30, 0x56, 0xfe, 0x00, 0x5c, 0x02, 0x13, 0x58, 0xff,
+	0x02, 0x00, 0x57, 0x52,
+	0xad, 0x02, 0x13, 0x58, 0xff, 0x02, 0x00, 0x57, 0x52, 0xfe, 0x00, 0x5e,
+	0x02, 0x13, 0x58, 0xff,
+	0x02, 0x00, 0x57, 0x52, 0xad, 0xfe, 0x0b, 0x58, 0x02, 0x0a, 0x66, 0x01,
+	0x5c, 0x0a, 0x55, 0x01,
+	0x5c, 0x0a, 0x6f, 0x01, 0x5c, 0x02, 0x01, 0xfe, 0x1e, 0x1f, 0x23, 0x1a,
+	0xff, 0x03, 0x00, 0x54,
+	0xfe, 0x00, 0xf4, 0x24, 0x52, 0x0f, 0xfe, 0x00, 0x7c, 0x04, 0xfe, 0x07,
+	0x7c, 0x3a, 0x0b, 0x0e,
+	0xfe, 0x00, 0x71, 0xfe, 0xf9, 0x18, 0xfe, 0x7a, 0x19, 0xfe, 0xfb, 0x19,
+	0xfe, 0x1a, 0xf7, 0x00,
+	0xfe, 0x1b, 0xf7, 0x00, 0x7a, 0x30, 0x10, 0x68, 0x22, 0x69, 0xd9, 0x6c,
+	0xda, 0x6d, 0x02, 0xfe,
+	0x62, 0x08, 0xfe, 0x82, 0x4a, 0xfe, 0xe1, 0x1a, 0xfe, 0x83, 0x5a, 0x77,
+	0x02, 0x01, 0xc6, 0xfe,
+	0x42, 0x48, 0x4f, 0x50, 0x45, 0x01, 0x08, 0x16, 0xfe, 0xe0, 0x17, 0x27,
+	0x25, 0xbe, 0x01, 0x08,
+	0x16, 0xfe, 0xe0, 0x17, 0x27, 0x25, 0xfe, 0xe8, 0x0a, 0xfe, 0xc1, 0x59,
+	0x03, 0x9a, 0x1e, 0xfe,
+	0xda, 0x12, 0x01, 0x38, 0x06, 0x12, 0xfe, 0xd0, 0x13, 0x26, 0x53, 0x12,
+	0x48, 0xfe, 0x08, 0x17,
+	0xd1, 0x12, 0x53, 0x12, 0xfe, 0x1e, 0x13, 0x2d, 0xb4, 0x7b, 0xfe, 0x26,
+	0x17, 0x4d, 0x13, 0x07,
+	0x1c, 0xb4, 0x90, 0x04, 0xfe, 0x78, 0x10, 0xff, 0x02, 0x83, 0x55, 0xf1,
+	0xff, 0x02, 0x83, 0x55,
+	0x53, 0x1d, 0xfe, 0x12, 0x13, 0xd6, 0xfe, 0x30, 0x00, 0xb0, 0xfe, 0x80,
+	0x17, 0x1c, 0x63, 0x13,
+	0x07, 0xfe, 0x56, 0x10, 0x53, 0x0d, 0xfe, 0x16, 0x13, 0xd6, 0xfe, 0x64,
+	0x00, 0xb0, 0xfe, 0x80,
+	0x17, 0x0a, 0xfe, 0x64, 0x00, 0x1c, 0x94, 0x13, 0x07, 0xfe, 0x28, 0x10,
+	0x53, 0x07, 0xfe, 0x60,
+	0x13, 0xd6, 0xfe, 0xc8, 0x00, 0xb0, 0xfe, 0x80, 0x17, 0x0a, 0xfe, 0xc8,
+	0x00, 0x1c, 0x95, 0x13,
+	0x07, 0x71, 0xd6, 0xfe, 0x90, 0x01, 0x48, 0xfe, 0x8c, 0x17, 0x45, 0xf3,
+	0xfe, 0x43, 0xf4, 0x96,
+	0xfe, 0x56, 0xf0, 0xfe, 0x9e, 0x17, 0xfe, 0x04, 0xf4, 0x58, 0xfe, 0x43,
+	0xf4, 0x94, 0xf6, 0x8b,
+	0x01, 0xfe, 0x24, 0x16, 0x23, 0x3f, 0xfc, 0xa8, 0x8c, 0x49, 0x48, 0xfe,
+	0xda, 0x17, 0x62, 0x49,
+	0xfe, 0x1c, 0x10, 0xa8, 0x8c, 0x80, 0x48, 0xfe, 0xda, 0x17, 0x62, 0x80,
+	0x71, 0x50, 0x26, 0xfe,
+	0x4d, 0xf4, 0x00, 0xf7, 0x45, 0x13, 0x07, 0xfe, 0xb4, 0x56, 0xfe, 0xc3,
+	0x58, 0x02, 0x50, 0x13,
+	0x0d, 0x02, 0x50, 0x3e, 0x78, 0x4f, 0x45, 0x01, 0x08, 0x16, 0xa9, 0x27,
+	0x25, 0xbe, 0xfe, 0x03,
+	0xea, 0xfe, 0x7e, 0x01, 0x01, 0x08, 0x16, 0xa9, 0x27, 0x25, 0xfe, 0xe9,
+	0x0a, 0x01, 0x08, 0x16,
+	0xa9, 0x27, 0x25, 0xfe, 0xe9, 0x0a, 0xfe, 0x05, 0xea, 0xfe, 0x7f, 0x01,
+	0x01, 0x08, 0x16, 0xa9,
+	0x27, 0x25, 0xfe, 0x69, 0x09, 0xfe, 0x02, 0xea, 0xfe, 0x80, 0x01, 0x01,
+	0x08, 0x16, 0xa9, 0x27,
+	0x25, 0xfe, 0xe8, 0x08, 0x47, 0xfe, 0x81, 0x01, 0x03, 0xb6, 0x1e, 0x83,
+	0x01, 0x38, 0x06, 0x24,
+	0x31, 0xa2, 0x78, 0xf2, 0x53, 0x07, 0x36, 0xfe, 0x34, 0xf4, 0x3f, 0xa1,
+	0x78, 0x03, 0x9a, 0x1e,
+	0x83, 0x01, 0x38, 0x06, 0x12, 0x31, 0xf0, 0x4f, 0x45, 0xfe, 0x90, 0x10,
+	0xfe, 0x40, 0x5a, 0x23,
+	0x3f, 0xfb, 0x8c, 0x49, 0x48, 0xfe, 0xaa, 0x18, 0x62, 0x49, 0x71, 0x8c,
+	0x80, 0x48, 0xfe, 0xaa,
+	0x18, 0x62, 0x80, 0xfe, 0xb4, 0x56, 0xfe, 0x40, 0x5d, 0x01, 0xc6, 0x01,
+	0xfe, 0xac, 0x1d, 0xfe,
+	0x02, 0x17, 0xfe, 0xc8, 0x45, 0xfe, 0x5a, 0xf0, 0xfe, 0xc0, 0x18, 0xfe,
+	0x43, 0x48, 0x2d, 0x93,
+	0x36, 0xfe, 0x34, 0xf4, 0xfe, 0x00, 0x11, 0xfe, 0x40, 0x10, 0x2d, 0xb4,
+	0x36, 0xfe, 0x34, 0xf4,
+	0x04, 0xfe, 0x34, 0x10, 0x2d, 0xfe, 0x0b, 0x00, 0x36, 0x46, 0x63, 0xfe,
+	0x28, 0x10, 0xfe, 0xc0,
+	0x49, 0xff, 0x02, 0x00, 0x54, 0xb2, 0xfe, 0x90, 0x01, 0x48, 0xfe, 0xfa,
+	0x18, 0x45, 0xfe, 0x1c,
+	0xf4, 0x3f, 0xf3, 0xfe, 0x40, 0xf4, 0x96, 0xfe, 0x56, 0xf0, 0xfe, 0x0c,
+	0x19, 0xfe, 0x04, 0xf4,
+	0x58, 0xfe, 0x40, 0xf4, 0x94, 0xf6, 0x3e, 0x2d, 0x93, 0x4e, 0xd0, 0x0d,
+	0x21, 0xfe, 0x7f, 0x01,
+	0xfe, 0xc8, 0x46, 0xfe, 0x24, 0x13, 0x8c, 0x00, 0x5d, 0x26, 0x21, 0xfe,
+	0x7e, 0x01, 0xfe, 0xc8,
+	0x45, 0xfe, 0x14, 0x13, 0x21, 0xfe, 0x80, 0x01, 0xfe, 0x48, 0x45, 0xfa,
+	0x21, 0xfe, 0x81, 0x01,
+	0xfe, 0xc8, 0x44, 0x4e, 0x26, 0x02, 0x13, 0x07, 0x02, 0x78, 0x45, 0x50,
+	0x13, 0x0d, 0x02, 0x14,
+	0x07, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x14, 0x0d, 0x01, 0x08, 0x17,
+	0xfe, 0x82, 0x19, 0x14,
+	0x1d, 0x01, 0x08, 0x17, 0xfe, 0x82, 0x19, 0x5f, 0xfe, 0x89, 0x49, 0x01,
+	0x08, 0x02, 0x14, 0x07,
+	0x01, 0x08, 0x17, 0xc1, 0x14, 0x1d, 0x01, 0x08, 0x17, 0xc1, 0x14, 0x07,
+	0x01, 0x08, 0x17, 0xc1,
+	0xfe, 0x89, 0x49, 0x01, 0x08, 0x17, 0xc1, 0x5f, 0xfe, 0x89, 0x4a, 0x01,
+	0x08, 0x02, 0x50, 0x02,
+	0x14, 0x07, 0x01, 0x08, 0x17, 0x74, 0x14, 0x7f, 0x01, 0x08, 0x17, 0x74,
+	0x14, 0x12, 0x01, 0x08,
+	0x17, 0x74, 0xfe, 0x89, 0x49, 0x01, 0x08, 0x17, 0x74, 0x14, 0x00, 0x01,
+	0x08, 0x17, 0x74, 0xfe,
+	0x89, 0x4a, 0x01, 0x08, 0x17, 0x74, 0xfe, 0x09, 0x49, 0x01, 0x08, 0x17,
+	0x74, 0x5f, 0xcc, 0x01,
+	0x08, 0x02, 0x21, 0xe4, 0x09, 0x07, 0xfe, 0x4c, 0x13, 0xc8, 0x20, 0xe4,
+	0xfe, 0x49, 0xf4, 0x00,
+	0x4d, 0x5f, 0xa1, 0x5e, 0xfe, 0x01, 0xec, 0xfe, 0x27, 0x01, 0xcc, 0xff,
+	0x02, 0x00, 0x10, 0x2f,
+	0xfe, 0x3e, 0x1a, 0x01, 0x43, 0x09, 0xfe, 0xe3, 0x00, 0xfe, 0x22, 0x13,
+	0x16, 0xfe, 0x64, 0x1a,
+	0x26, 0x20, 0x9e, 0x01, 0x41, 0x21, 0x9e, 0x09, 0x07, 0x5d, 0x01, 0x0c,
+	0x61, 0x07, 0x44, 0x02,
+	0x0a, 0x5a, 0x01, 0x18, 0xfe, 0x00, 0x40, 0xaa, 0x09, 0x1a, 0xfe, 0x12,
+	0x13, 0x0a, 0x9d, 0x01,
+	0x18, 0xaa, 0x0a, 0x67, 0x01, 0xa3, 0x02, 0x0a, 0x9d, 0x01, 0x18, 0xaa,
+	0xfe, 0x80, 0xe7, 0x1a,
+	0x09, 0x1a, 0x5d, 0xfe, 0x45, 0x58, 0x01, 0xfe, 0xb2, 0x16, 0xaa, 0x02,
+	0x0a, 0x5a, 0x01, 0x18,
+	0xaa, 0x0a, 0x67, 0x01, 0xa3, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x01, 0xfe,
+	0x7e, 0x1e, 0xfe, 0x80,
+	0x4c, 0xfe, 0x49, 0xe4, 0x1a, 0xfe, 0x12, 0x13, 0x0a, 0x9d, 0x01, 0x18,
+	0xfe, 0x80, 0x4c, 0x0a,
+	0x67, 0x01, 0x5c, 0x02, 0x1c, 0x1a, 0x87, 0x7c, 0xe5, 0xfe, 0x18, 0xdf,
+	0xfe, 0x19, 0xde, 0xfe,
+	0x24, 0x1c, 0xfe, 0x1d, 0xf7, 0x28, 0xb1, 0xfe, 0x04, 0x1b, 0x01, 0xfe,
+	0x2a, 0x1c, 0xfa, 0xb3,
+	0x28, 0x7c, 0xfe, 0x2c, 0x01, 0xfe, 0x2f, 0x19, 0x02, 0xc9, 0x2b, 0xfe,
+	0xf4, 0x1a, 0xfe, 0xfa,
+	0x10, 0x1c, 0x1a, 0x87, 0x03, 0xfe, 0x64, 0x01, 0xfe, 0x00, 0xf4, 0x24,
+	0xfe, 0x18, 0x58, 0x03,
+	0xfe, 0x66, 0x01, 0xfe, 0x19, 0x58, 0xb3, 0x24, 0x01, 0xfe, 0x0e, 0x1f,
+	0xfe, 0x30, 0xf4, 0x07,
+	0xfe, 0x3c, 0x50, 0x7c, 0xfe, 0x38, 0x00, 0xfe, 0x0f, 0x79, 0xfe, 0x1c,
+	0xf7, 0x24, 0xb1, 0xfe,
+	0x50, 0x1b, 0xfe, 0xd4, 0x14, 0x31, 0x02, 0xc9, 0x2b, 0xfe, 0x26, 0x1b,
+	0xfe, 0xba, 0x10, 0x1c,
+	0x1a, 0x87, 0xfe, 0x83, 0x5a, 0xfe, 0x18, 0xdf, 0xfe, 0x19, 0xde, 0xfe,
+	0x1d, 0xf7, 0x54, 0xb1,
+	0xfe, 0x72, 0x1b, 0xfe, 0xb2, 0x14, 0xfc, 0xb3, 0x54, 0x7c, 0x12, 0xfe,
+	0xaf, 0x19, 0xfe, 0x98,
+	0xe7, 0x00, 0x02, 0xc9, 0x2b, 0xfe, 0x66, 0x1b, 0xfe, 0x8a, 0x10, 0x1c,
+	0x1a, 0x87, 0x8b, 0x0f,
+	0xfe, 0x30, 0x90, 0x04, 0xfe, 0xb0, 0x93, 0x3a, 0x0b, 0xfe, 0x18, 0x58,
+	0xfe, 0x32, 0x90, 0x04,
+	0xfe, 0xb2, 0x93, 0x3a, 0x0b, 0xfe, 0x19, 0x58, 0x0e, 0xa8, 0xb3, 0x4a,
+	0x7c, 0x12, 0xfe, 0x0f,
+	0x79, 0xfe, 0x1c, 0xf7, 0x4a, 0xb1, 0xfe, 0xc6, 0x1b, 0xfe, 0x5e, 0x14,
+	0x31, 0x02, 0xc9, 0x2b,
+	0xfe, 0x96, 0x1b, 0x5c, 0xfe, 0x02, 0xf6, 0x1a, 0x87, 0xfe, 0x18, 0xfe,
+	0x6a, 0xfe, 0x19, 0xfe,
+	0x6b, 0x01, 0xfe, 0x1e, 0x1f, 0xfe, 0x1d, 0xf7, 0x65, 0xb1, 0xfe, 0xee,
+	0x1b, 0xfe, 0x36, 0x14,
+	0xfe, 0x1c, 0x13, 0xb3, 0x65, 0x3e, 0xfe, 0x83, 0x58, 0xfe, 0xaf, 0x19,
+	0xfe, 0x80, 0xe7, 0x1a,
+	0xfe, 0x81, 0xe7, 0x1a, 0x15, 0xfe, 0xdd, 0x00, 0x7a, 0x30, 0x02, 0x7a,
+	0x30, 0xfe, 0x12, 0x45,
+	0x2b, 0xfe, 0xdc, 0x1b, 0x1f, 0x07, 0x47, 0xb5, 0xc3, 0x05, 0x35, 0xfe,
+	0x39, 0xf0, 0x75, 0x26,
+	0x02, 0xfe, 0x7e, 0x18, 0x23, 0x1d, 0x36, 0x13, 0x11, 0x02, 0x87, 0x03,
+	0xe3, 0x23, 0x07, 0xfe,
+	0xef, 0x12, 0xfe, 0xe1, 0x10, 0x90, 0x34, 0x60, 0xfe, 0x02, 0x80, 0x09,
+	0x56, 0xfe, 0x3c, 0x13,
+	0xfe, 0x82, 0x14, 0xfe, 0x42, 0x13, 0x51, 0xfe, 0x06, 0x83, 0x0a, 0x5a,
+	0x01, 0x18, 0xcb, 0xfe,
+	0x3e, 0x12, 0xfe, 0x41, 0x48, 0xfe, 0x45, 0x48, 0x01, 0xfe, 0xb2, 0x16,
+	0xfe, 0x00, 0xcc, 0xcb,
+	0xfe, 0xf3, 0x13, 0x3f, 0x89, 0x09, 0x1a, 0xa5, 0x0a, 0x9d, 0x01, 0x18,
+	0xfe, 0x80, 0x4c, 0x01,
+	0x85, 0xfe, 0x16, 0x10, 0x09, 0x9b, 0x4e, 0xfe, 0x40, 0x14, 0xfe, 0x24,
+	0x12, 0xfe, 0x14, 0x56,
+	0xfe, 0xd6, 0xf0, 0xfe, 0x52, 0x1c, 0x1c, 0x0d, 0x02, 0xfe, 0x9c, 0xe7,
+	0x0d, 0x19, 0xfe, 0x15,
+	0x00, 0x40, 0x8d, 0x30, 0x01, 0xf4, 0x1c, 0x07, 0x02, 0x51, 0xfe, 0x06,
+	0x83, 0xfe, 0x18, 0x80,
+	0x61, 0x28, 0x44, 0x15, 0x56, 0x01, 0x85, 0x1c, 0x07, 0x02, 0xfe, 0x38,
+	0x90, 0xfe, 0xba, 0x90,
+	0x91, 0xde, 0x7e, 0xdf, 0xfe, 0x48, 0x55, 0x31, 0xfe, 0xc9, 0x55, 0x02,
+	0x21, 0xb9, 0x88, 0x20,
+	0xb9, 0x02, 0x0a, 0xba, 0x01, 0x18, 0xfe, 0x41, 0x48, 0x0a, 0x57, 0x01,
+	0x18, 0xfe, 0x49, 0x44,
+	0x1b, 0xfe, 0x1e, 0x1d, 0x88, 0x89, 0x02, 0x0a, 0x5a, 0x01, 0x18, 0x09,
+	0x1a, 0xa4, 0x0a, 0x67,
+	0x01, 0xa3, 0x0a, 0x57, 0x01, 0x18, 0x88, 0x89, 0x02, 0xfe, 0x4e, 0xe4,
+	0x1d, 0x7b, 0xfe, 0x52,
+	0x1d, 0x03, 0xfe, 0x90, 0x00, 0xfe, 0x3a, 0x45, 0xfe, 0x2c, 0x10, 0xfe,
+	0x4e, 0xe4, 0xdd, 0x7b,
+	0xfe, 0x64, 0x1d, 0x03, 0xfe, 0x92, 0x00, 0xd1, 0x12, 0xfe, 0x1a, 0x10,
+	0xfe, 0x4e, 0xe4, 0xfe,
+	0x0b, 0x00, 0x7b, 0xfe, 0x76, 0x1d, 0x03, 0xfe, 0x94, 0x00, 0xd1, 0x24,
+	0xfe, 0x08, 0x10, 0x03,
+	0xfe, 0x96, 0x00, 0xd1, 0x63, 0xfe, 0x4e, 0x45, 0x83, 0xca, 0xff, 0x04,
+	0x68, 0x54, 0xfe, 0xf1,
+	0x10, 0x23, 0x49, 0xfe, 0x08, 0x1c, 0xfe, 0x67, 0x19, 0xfe, 0x0a, 0x1c,
+	0xfe, 0x1a, 0xf4, 0xfe,
+	0x00, 0x04, 0x83, 0xb2, 0x1d, 0x48, 0xfe, 0xaa, 0x1d, 0x13, 0x1d, 0x02,
+	0x09, 0x92, 0xfe, 0x5a,
+	0xf0, 0xfe, 0xba, 0x1d, 0x2e, 0x93, 0xfe, 0x34, 0x10, 0x09, 0x12, 0xfe,
+	0x5a, 0xf0, 0xfe, 0xc8,
+	0x1d, 0x2e, 0xb4, 0xfe, 0x26, 0x10, 0x09, 0x1d, 0x36, 0x2e, 0x63, 0xfe,
+	0x1a, 0x10, 0x09, 0x0d,
+	0x36, 0x2e, 0x94, 0xf2, 0x09, 0x07, 0x36, 0x2e, 0x95, 0xa1, 0xc8, 0x02,
+	0x1f, 0x93, 0x01, 0x42,
+	0xfe, 0x04, 0xfe, 0x99, 0x03, 0x9c, 0x8b, 0x02, 0x2a, 0xfe, 0x1c, 0x1e,
+	0xfe, 0x14, 0xf0, 0x08,
+	0x2f, 0xfe, 0x0c, 0x1e, 0x2a, 0xfe, 0x1c, 0x1e, 0x8f, 0xfe, 0x1c, 0x1e,
+	0xfe, 0x82, 0xf0, 0xfe,
+	0x10, 0x1e, 0x02, 0x0f, 0x3f, 0x04, 0xfe, 0x80, 0x83, 0x33, 0x0b, 0x0e,
+	0x02, 0x0f, 0xfe, 0x18,
+	0x80, 0x04, 0xfe, 0x98, 0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x02,
+	0x80, 0x04, 0xfe, 0x82,
+	0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06, 0x80, 0x04, 0xfe, 0x86,
+	0x83, 0x33, 0x0b, 0x0e,
+	0x02, 0x0f, 0xfe, 0x1b, 0x80, 0x04, 0xfe, 0x9b, 0x83, 0x33, 0x0b, 0x0e,
+	0x02, 0x0f, 0xfe, 0x04,
+	0x80, 0x04, 0xfe, 0x84, 0x83, 0x33, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x80,
+	0x80, 0x04, 0xfe, 0x80,
+	0x83, 0xfe, 0xc9, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x19, 0x81, 0x04,
+	0xfe, 0x99, 0x83, 0xfe,
+	0xca, 0x47, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x06, 0x83, 0x04, 0xfe, 0x86,
+	0x83, 0xfe, 0xce, 0x47,
+	0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x2c, 0x90, 0x04, 0xfe, 0xac, 0x93, 0x3a,
+	0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0xae, 0x90, 0x04, 0xfe, 0xae, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x08, 0x90, 0x04,
+	0xfe, 0x88, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x8a, 0x90, 0x04,
+	0xfe, 0x8a, 0x93, 0x79,
+	0x0b, 0x0e, 0x02, 0x0f, 0xfe, 0x0c, 0x90, 0x04, 0xfe, 0x8c, 0x93, 0x3a,
+	0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x8e, 0x90, 0x04, 0xfe, 0x8e, 0x93, 0x79, 0x0b, 0x0e, 0x02, 0x0f,
+	0xfe, 0x3c, 0x90, 0x04,
+	0xfe, 0xbc, 0x93, 0x3a, 0x0b, 0x0e, 0x02, 0x8b, 0x0f, 0xfe, 0x03, 0x80,
+	0x04, 0xfe, 0x83, 0x83,
+	0x33, 0x0b, 0x77, 0x0e, 0xa8, 0x02, 0xff, 0x66, 0x00, 0x00,
 };
 
-STATIC unsigned short _adv_asc38C1600_size =
-        sizeof(_adv_asc38C1600_buf); /* 0x1673 */
-STATIC ADV_DCNT _adv_asc38C1600_chksum =
-        0x0604EF77UL; /* Expanded little-endian checksum. */
+static unsigned short _adv_asc38C1600_size = sizeof(_adv_asc38C1600_buf);	/* 0x1673 */
+static ADV_DCNT _adv_asc38C1600_chksum = 0x0604EF77UL;	/* Expanded little-endian checksum. */
 
 /* a_init.c */
 /*
@@ -14049,340 +13847,340 @@ STATIC ADV_DCNT _adv_asc38C1600_chksum =
  * on big-endian platforms so char fields read as words are actually being
  * unswapped on big-endian platforms.
  */
-STATIC ADVEEP_3550_CONFIG
-Default_3550_EEPROM_Config __initdata = {
-    ADV_EEPROM_BIOS_ENABLE,     /* cfg_lsw */
-    0x0000,                     /* cfg_msw */
-    0xFFFF,                     /* disc_enable */
-    0xFFFF,                     /* wdtr_able */
-    0xFFFF,                     /* sdtr_able */
-    0xFFFF,                     /* start_motor */
-    0xFFFF,                     /* tagqng_able */
-    0xFFFF,                     /* bios_scan */
-    0,                          /* scam_tolerant */
-    7,                          /* adapter_scsi_id */
-    0,                          /* bios_boot_delay */
-    3,                          /* scsi_reset_delay */
-    0,                          /* bios_id_lun */
-    0,                          /* termination */
-    0,                          /* reserved1 */
-    0xFFE7,                     /* bios_ctrl */
-    0xFFFF,                     /* ultra_able */
-    0,                          /* reserved2 */
-    ASC_DEF_MAX_HOST_QNG,       /* max_host_qng */
-    ASC_DEF_MAX_DVC_QNG,        /* max_dvc_qng */
-    0,                          /* dvc_cntl */
-    0,                          /* bug_fix */
-    0,                          /* serial_number_word1 */
-    0,                          /* serial_number_word2 */
-    0,                          /* serial_number_word3 */
-    0,                          /* check_sum */
-    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* oem_name[16] */
-    0,                          /* dvc_err_code */
-    0,                          /* adv_err_code */
-    0,                          /* adv_err_addr */
-    0,                          /* saved_dvc_err_code */
-    0,                          /* saved_adv_err_code */
-    0,                          /* saved_adv_err_addr */
-    0                           /* num_of_err */
+static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config __initdata = {
+	ADV_EEPROM_BIOS_ENABLE,	/* cfg_lsw */
+	0x0000,			/* cfg_msw */
+	0xFFFF,			/* disc_enable */
+	0xFFFF,			/* wdtr_able */
+	0xFFFF,			/* sdtr_able */
+	0xFFFF,			/* start_motor */
+	0xFFFF,			/* tagqng_able */
+	0xFFFF,			/* bios_scan */
+	0,			/* scam_tolerant */
+	7,			/* adapter_scsi_id */
+	0,			/* bios_boot_delay */
+	3,			/* scsi_reset_delay */
+	0,			/* bios_id_lun */
+	0,			/* termination */
+	0,			/* reserved1 */
+	0xFFE7,			/* bios_ctrl */
+	0xFFFF,			/* ultra_able */
+	0,			/* reserved2 */
+	ASC_DEF_MAX_HOST_QNG,	/* max_host_qng */
+	ASC_DEF_MAX_DVC_QNG,	/* max_dvc_qng */
+	0,			/* dvc_cntl */
+	0,			/* bug_fix */
+	0,			/* serial_number_word1 */
+	0,			/* serial_number_word2 */
+	0,			/* serial_number_word3 */
+	0,			/* check_sum */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	,			/* oem_name[16] */
+	0,			/* dvc_err_code */
+	0,			/* adv_err_code */
+	0,			/* adv_err_addr */
+	0,			/* saved_dvc_err_code */
+	0,			/* saved_adv_err_code */
+	0,			/* saved_adv_err_addr */
+	0			/* num_of_err */
 };
 
-STATIC ADVEEP_3550_CONFIG
-ADVEEP_3550_Config_Field_IsChar __initdata = {
-    0,                          /* cfg_lsw */
-    0,                          /* cfg_msw */
-    0,                          /* -disc_enable */
-    0,                          /* wdtr_able */
-    0,                          /* sdtr_able */
-    0,                          /* start_motor */
-    0,                          /* tagqng_able */
-    0,                          /* bios_scan */
-    0,                          /* scam_tolerant */
-    1,                          /* adapter_scsi_id */
-    1,                          /* bios_boot_delay */
-    1,                          /* scsi_reset_delay */
-    1,                          /* bios_id_lun */
-    1,                          /* termination */
-    1,                          /* reserved1 */
-    0,                          /* bios_ctrl */
-    0,                          /* ultra_able */
-    0,                          /* reserved2 */
-    1,                          /* max_host_qng */
-    1,                          /* max_dvc_qng */
-    0,                          /* dvc_cntl */
-    0,                          /* bug_fix */
-    0,                          /* serial_number_word1 */
-    0,                          /* serial_number_word2 */
-    0,                          /* serial_number_word3 */
-    0,                          /* check_sum */
-    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, /* oem_name[16] */
-    0,                          /* dvc_err_code */
-    0,                          /* adv_err_code */
-    0,                          /* adv_err_addr */
-    0,                          /* saved_dvc_err_code */
-    0,                          /* saved_adv_err_code */
-    0,                          /* saved_adv_err_addr */
-    0                           /* num_of_err */
+static ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar __initdata = {
+	0,			/* cfg_lsw */
+	0,			/* cfg_msw */
+	0,			/* -disc_enable */
+	0,			/* wdtr_able */
+	0,			/* sdtr_able */
+	0,			/* start_motor */
+	0,			/* tagqng_able */
+	0,			/* bios_scan */
+	0,			/* scam_tolerant */
+	1,			/* adapter_scsi_id */
+	1,			/* bios_boot_delay */
+	1,			/* scsi_reset_delay */
+	1,			/* bios_id_lun */
+	1,			/* termination */
+	1,			/* reserved1 */
+	0,			/* bios_ctrl */
+	0,			/* ultra_able */
+	0,			/* reserved2 */
+	1,			/* max_host_qng */
+	1,			/* max_dvc_qng */
+	0,			/* dvc_cntl */
+	0,			/* bug_fix */
+	0,			/* serial_number_word1 */
+	0,			/* serial_number_word2 */
+	0,			/* serial_number_word3 */
+	0,			/* check_sum */
+	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+	,			/* oem_name[16] */
+	0,			/* dvc_err_code */
+	0,			/* adv_err_code */
+	0,			/* adv_err_addr */
+	0,			/* saved_dvc_err_code */
+	0,			/* saved_adv_err_code */
+	0,			/* saved_adv_err_addr */
+	0			/* num_of_err */
 };
 
-STATIC ADVEEP_38C0800_CONFIG
-Default_38C0800_EEPROM_Config __initdata = {
-    ADV_EEPROM_BIOS_ENABLE,     /* 00 cfg_lsw */
-    0x0000,                     /* 01 cfg_msw */
-    0xFFFF,                     /* 02 disc_enable */
-    0xFFFF,                     /* 03 wdtr_able */
-    0x4444,                     /* 04 sdtr_speed1 */
-    0xFFFF,                     /* 05 start_motor */
-    0xFFFF,                     /* 06 tagqng_able */
-    0xFFFF,                     /* 07 bios_scan */
-    0,                          /* 08 scam_tolerant */
-    7,                          /* 09 adapter_scsi_id */
-    0,                          /*    bios_boot_delay */
-    3,                          /* 10 scsi_reset_delay */
-    0,                          /*    bios_id_lun */
-    0,                          /* 11 termination_se */
-    0,                          /*    termination_lvd */
-    0xFFE7,                     /* 12 bios_ctrl */
-    0x4444,                     /* 13 sdtr_speed2 */
-    0x4444,                     /* 14 sdtr_speed3 */
-    ASC_DEF_MAX_HOST_QNG,       /* 15 max_host_qng */
-    ASC_DEF_MAX_DVC_QNG,        /*    max_dvc_qng */
-    0,                          /* 16 dvc_cntl */
-    0x4444,                     /* 17 sdtr_speed4 */
-    0,                          /* 18 serial_number_word1 */
-    0,                          /* 19 serial_number_word2 */
-    0,                          /* 20 serial_number_word3 */
-    0,                          /* 21 check_sum */
-    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */
-    0,                          /* 30 dvc_err_code */
-    0,                          /* 31 adv_err_code */
-    0,                          /* 32 adv_err_addr */
-    0,                          /* 33 saved_dvc_err_code */
-    0,                          /* 34 saved_adv_err_code */
-    0,                          /* 35 saved_adv_err_addr */
-    0,                          /* 36 reserved */
-    0,                          /* 37 reserved */
-    0,                          /* 38 reserved */
-    0,                          /* 39 reserved */
-    0,                          /* 40 reserved */
-    0,                          /* 41 reserved */
-    0,                          /* 42 reserved */
-    0,                          /* 43 reserved */
-    0,                          /* 44 reserved */
-    0,                          /* 45 reserved */
-    0,                          /* 46 reserved */
-    0,                          /* 47 reserved */
-    0,                          /* 48 reserved */
-    0,                          /* 49 reserved */
-    0,                          /* 50 reserved */
-    0,                          /* 51 reserved */
-    0,                          /* 52 reserved */
-    0,                          /* 53 reserved */
-    0,                          /* 54 reserved */
-    0,                          /* 55 reserved */
-    0,                          /* 56 cisptr_lsw */
-    0,                          /* 57 cisprt_msw */
-    PCI_VENDOR_ID_ASP,          /* 58 subsysvid */
-    PCI_DEVICE_ID_38C0800_REV1, /* 59 subsysid */
-    0,                          /* 60 reserved */
-    0,                          /* 61 reserved */
-    0,                          /* 62 reserved */
-    0                           /* 63 reserved */
+static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config __initdata = {
+	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
+	0x0000,			/* 01 cfg_msw */
+	0xFFFF,			/* 02 disc_enable */
+	0xFFFF,			/* 03 wdtr_able */
+	0x4444,			/* 04 sdtr_speed1 */
+	0xFFFF,			/* 05 start_motor */
+	0xFFFF,			/* 06 tagqng_able */
+	0xFFFF,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	7,			/* 09 adapter_scsi_id */
+	0,			/*    bios_boot_delay */
+	3,			/* 10 scsi_reset_delay */
+	0,			/*    bios_id_lun */
+	0,			/* 11 termination_se */
+	0,			/*    termination_lvd */
+	0xFFE7,			/* 12 bios_ctrl */
+	0x4444,			/* 13 sdtr_speed2 */
+	0x4444,			/* 14 sdtr_speed3 */
+	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
+	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0x4444,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	PCI_VENDOR_ID_ASP,	/* 58 subsysvid */
+	PCI_DEVICE_ID_38C0800_REV1,	/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
 };
 
-STATIC ADVEEP_38C0800_CONFIG
-ADVEEP_38C0800_Config_Field_IsChar __initdata = {
-    0,                          /* 00 cfg_lsw */
-    0,                          /* 01 cfg_msw */
-    0,                          /* 02 disc_enable */
-    0,                          /* 03 wdtr_able */
-    0,                          /* 04 sdtr_speed1 */
-    0,                          /* 05 start_motor */
-    0,                          /* 06 tagqng_able */
-    0,                          /* 07 bios_scan */
-    0,                          /* 08 scam_tolerant */
-    1,                          /* 09 adapter_scsi_id */
-    1,                          /*    bios_boot_delay */
-    1,                          /* 10 scsi_reset_delay */
-    1,                          /*    bios_id_lun */
-    1,                          /* 11 termination_se */
-    1,                          /*    termination_lvd */
-    0,                          /* 12 bios_ctrl */
-    0,                          /* 13 sdtr_speed2 */
-    0,                          /* 14 sdtr_speed3 */
-    1,                          /* 15 max_host_qng */
-    1,                          /*    max_dvc_qng */
-    0,                          /* 16 dvc_cntl */
-    0,                          /* 17 sdtr_speed4 */
-    0,                          /* 18 serial_number_word1 */
-    0,                          /* 19 serial_number_word2 */
-    0,                          /* 20 serial_number_word3 */
-    0,                          /* 21 check_sum */
-    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, /* 22-29 oem_name[16] */
-    0,                          /* 30 dvc_err_code */
-    0,                          /* 31 adv_err_code */
-    0,                          /* 32 adv_err_addr */
-    0,                          /* 33 saved_dvc_err_code */
-    0,                          /* 34 saved_adv_err_code */
-    0,                          /* 35 saved_adv_err_addr */
-    0,                          /* 36 reserved */
-    0,                          /* 37 reserved */
-    0,                          /* 38 reserved */
-    0,                          /* 39 reserved */
-    0,                          /* 40 reserved */
-    0,                          /* 41 reserved */
-    0,                          /* 42 reserved */
-    0,                          /* 43 reserved */
-    0,                          /* 44 reserved */
-    0,                          /* 45 reserved */
-    0,                          /* 46 reserved */
-    0,                          /* 47 reserved */
-    0,                          /* 48 reserved */
-    0,                          /* 49 reserved */
-    0,                          /* 50 reserved */
-    0,                          /* 51 reserved */
-    0,                          /* 52 reserved */
-    0,                          /* 53 reserved */
-    0,                          /* 54 reserved */
-    0,                          /* 55 reserved */
-    0,                          /* 56 cisptr_lsw */
-    0,                          /* 57 cisprt_msw */
-    0,                          /* 58 subsysvid */
-    0,                          /* 59 subsysid */
-    0,                          /* 60 reserved */
-    0,                          /* 61 reserved */
-    0,                          /* 62 reserved */
-    0                           /* 63 reserved */
+static ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar __initdata = {
+	0,			/* 00 cfg_lsw */
+	0,			/* 01 cfg_msw */
+	0,			/* 02 disc_enable */
+	0,			/* 03 wdtr_able */
+	0,			/* 04 sdtr_speed1 */
+	0,			/* 05 start_motor */
+	0,			/* 06 tagqng_able */
+	0,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	1,			/* 09 adapter_scsi_id */
+	1,			/*    bios_boot_delay */
+	1,			/* 10 scsi_reset_delay */
+	1,			/*    bios_id_lun */
+	1,			/* 11 termination_se */
+	1,			/*    termination_lvd */
+	0,			/* 12 bios_ctrl */
+	0,			/* 13 sdtr_speed2 */
+	0,			/* 14 sdtr_speed3 */
+	1,			/* 15 max_host_qng */
+	1,			/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	0,			/* 58 subsysvid */
+	0,			/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
 };
 
-STATIC ADVEEP_38C1600_CONFIG
-Default_38C1600_EEPROM_Config __initdata = {
-    ADV_EEPROM_BIOS_ENABLE,     /* 00 cfg_lsw */
-    0x0000,                     /* 01 cfg_msw */
-    0xFFFF,                     /* 02 disc_enable */
-    0xFFFF,                     /* 03 wdtr_able */
-    0x5555,                     /* 04 sdtr_speed1 */
-    0xFFFF,                     /* 05 start_motor */
-    0xFFFF,                     /* 06 tagqng_able */
-    0xFFFF,                     /* 07 bios_scan */
-    0,                          /* 08 scam_tolerant */
-    7,                          /* 09 adapter_scsi_id */
-    0,                          /*    bios_boot_delay */
-    3,                          /* 10 scsi_reset_delay */
-    0,                          /*    bios_id_lun */
-    0,                          /* 11 termination_se */
-    0,                          /*    termination_lvd */
-    0xFFE7,                     /* 12 bios_ctrl */
-    0x5555,                     /* 13 sdtr_speed2 */
-    0x5555,                     /* 14 sdtr_speed3 */
-    ASC_DEF_MAX_HOST_QNG,       /* 15 max_host_qng */
-    ASC_DEF_MAX_DVC_QNG,        /*    max_dvc_qng */
-    0,                          /* 16 dvc_cntl */
-    0x5555,                     /* 17 sdtr_speed4 */
-    0,                          /* 18 serial_number_word1 */
-    0,                          /* 19 serial_number_word2 */
-    0,                          /* 20 serial_number_word3 */
-    0,                          /* 21 check_sum */
-    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */
-    0,                          /* 30 dvc_err_code */
-    0,                          /* 31 adv_err_code */
-    0,                          /* 32 adv_err_addr */
-    0,                          /* 33 saved_dvc_err_code */
-    0,                          /* 34 saved_adv_err_code */
-    0,                          /* 35 saved_adv_err_addr */
-    0,                          /* 36 reserved */
-    0,                          /* 37 reserved */
-    0,                          /* 38 reserved */
-    0,                          /* 39 reserved */
-    0,                          /* 40 reserved */
-    0,                          /* 41 reserved */
-    0,                          /* 42 reserved */
-    0,                          /* 43 reserved */
-    0,                          /* 44 reserved */
-    0,                          /* 45 reserved */
-    0,                          /* 46 reserved */
-    0,                          /* 47 reserved */
-    0,                          /* 48 reserved */
-    0,                          /* 49 reserved */
-    0,                          /* 50 reserved */
-    0,                          /* 51 reserved */
-    0,                          /* 52 reserved */
-    0,                          /* 53 reserved */
-    0,                          /* 54 reserved */
-    0,                          /* 55 reserved */
-    0,                          /* 56 cisptr_lsw */
-    0,                          /* 57 cisprt_msw */
-    PCI_VENDOR_ID_ASP,          /* 58 subsysvid */
-    PCI_DEVICE_ID_38C1600_REV1, /* 59 subsysid */
-    0,                          /* 60 reserved */
-    0,                          /* 61 reserved */
-    0,                          /* 62 reserved */
-    0                           /* 63 reserved */
+static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config __initdata = {
+	ADV_EEPROM_BIOS_ENABLE,	/* 00 cfg_lsw */
+	0x0000,			/* 01 cfg_msw */
+	0xFFFF,			/* 02 disc_enable */
+	0xFFFF,			/* 03 wdtr_able */
+	0x5555,			/* 04 sdtr_speed1 */
+	0xFFFF,			/* 05 start_motor */
+	0xFFFF,			/* 06 tagqng_able */
+	0xFFFF,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	7,			/* 09 adapter_scsi_id */
+	0,			/*    bios_boot_delay */
+	3,			/* 10 scsi_reset_delay */
+	0,			/*    bios_id_lun */
+	0,			/* 11 termination_se */
+	0,			/*    termination_lvd */
+	0xFFE7,			/* 12 bios_ctrl */
+	0x5555,			/* 13 sdtr_speed2 */
+	0x5555,			/* 14 sdtr_speed3 */
+	ASC_DEF_MAX_HOST_QNG,	/* 15 max_host_qng */
+	ASC_DEF_MAX_DVC_QNG,	/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0x5555,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	PCI_VENDOR_ID_ASP,	/* 58 subsysvid */
+	PCI_DEVICE_ID_38C1600_REV1,	/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
 };
 
-STATIC ADVEEP_38C1600_CONFIG
-ADVEEP_38C1600_Config_Field_IsChar __initdata = {
-    0,                          /* 00 cfg_lsw */
-    0,                          /* 01 cfg_msw */
-    0,                          /* 02 disc_enable */
-    0,                          /* 03 wdtr_able */
-    0,                          /* 04 sdtr_speed1 */
-    0,                          /* 05 start_motor */
-    0,                          /* 06 tagqng_able */
-    0,                          /* 07 bios_scan */
-    0,                          /* 08 scam_tolerant */
-    1,                          /* 09 adapter_scsi_id */
-    1,                          /*    bios_boot_delay */
-    1,                          /* 10 scsi_reset_delay */
-    1,                          /*    bios_id_lun */
-    1,                          /* 11 termination_se */
-    1,                          /*    termination_lvd */
-    0,                          /* 12 bios_ctrl */
-    0,                          /* 13 sdtr_speed2 */
-    0,                          /* 14 sdtr_speed3 */
-    1,                          /* 15 max_host_qng */
-    1,                          /*    max_dvc_qng */
-    0,                          /* 16 dvc_cntl */
-    0,                          /* 17 sdtr_speed4 */
-    0,                          /* 18 serial_number_word1 */
-    0,                          /* 19 serial_number_word2 */
-    0,                          /* 20 serial_number_word3 */
-    0,                          /* 21 check_sum */
-    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, /* 22-29 oem_name[16] */
-    0,                          /* 30 dvc_err_code */
-    0,                          /* 31 adv_err_code */
-    0,                          /* 32 adv_err_addr */
-    0,                          /* 33 saved_dvc_err_code */
-    0,                          /* 34 saved_adv_err_code */
-    0,                          /* 35 saved_adv_err_addr */
-    0,                          /* 36 reserved */
-    0,                          /* 37 reserved */
-    0,                          /* 38 reserved */
-    0,                          /* 39 reserved */
-    0,                          /* 40 reserved */
-    0,                          /* 41 reserved */
-    0,                          /* 42 reserved */
-    0,                          /* 43 reserved */
-    0,                          /* 44 reserved */
-    0,                          /* 45 reserved */
-    0,                          /* 46 reserved */
-    0,                          /* 47 reserved */
-    0,                          /* 48 reserved */
-    0,                          /* 49 reserved */
-    0,                          /* 50 reserved */
-    0,                          /* 51 reserved */
-    0,                          /* 52 reserved */
-    0,                          /* 53 reserved */
-    0,                          /* 54 reserved */
-    0,                          /* 55 reserved */
-    0,                          /* 56 cisptr_lsw */
-    0,                          /* 57 cisprt_msw */
-    0,                          /* 58 subsysvid */
-    0,                          /* 59 subsysid */
-    0,                          /* 60 reserved */
-    0,                          /* 61 reserved */
-    0,                          /* 62 reserved */
-    0                           /* 63 reserved */
+static ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar __initdata = {
+	0,			/* 00 cfg_lsw */
+	0,			/* 01 cfg_msw */
+	0,			/* 02 disc_enable */
+	0,			/* 03 wdtr_able */
+	0,			/* 04 sdtr_speed1 */
+	0,			/* 05 start_motor */
+	0,			/* 06 tagqng_able */
+	0,			/* 07 bios_scan */
+	0,			/* 08 scam_tolerant */
+	1,			/* 09 adapter_scsi_id */
+	1,			/*    bios_boot_delay */
+	1,			/* 10 scsi_reset_delay */
+	1,			/*    bios_id_lun */
+	1,			/* 11 termination_se */
+	1,			/*    termination_lvd */
+	0,			/* 12 bios_ctrl */
+	0,			/* 13 sdtr_speed2 */
+	0,			/* 14 sdtr_speed3 */
+	1,			/* 15 max_host_qng */
+	1,			/*    max_dvc_qng */
+	0,			/* 16 dvc_cntl */
+	0,			/* 17 sdtr_speed4 */
+	0,			/* 18 serial_number_word1 */
+	0,			/* 19 serial_number_word2 */
+	0,			/* 20 serial_number_word3 */
+	0,			/* 21 check_sum */
+	{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
+	,			/* 22-29 oem_name[16] */
+	0,			/* 30 dvc_err_code */
+	0,			/* 31 adv_err_code */
+	0,			/* 32 adv_err_addr */
+	0,			/* 33 saved_dvc_err_code */
+	0,			/* 34 saved_adv_err_code */
+	0,			/* 35 saved_adv_err_addr */
+	0,			/* 36 reserved */
+	0,			/* 37 reserved */
+	0,			/* 38 reserved */
+	0,			/* 39 reserved */
+	0,			/* 40 reserved */
+	0,			/* 41 reserved */
+	0,			/* 42 reserved */
+	0,			/* 43 reserved */
+	0,			/* 44 reserved */
+	0,			/* 45 reserved */
+	0,			/* 46 reserved */
+	0,			/* 47 reserved */
+	0,			/* 48 reserved */
+	0,			/* 49 reserved */
+	0,			/* 50 reserved */
+	0,			/* 51 reserved */
+	0,			/* 52 reserved */
+	0,			/* 53 reserved */
+	0,			/* 54 reserved */
+	0,			/* 55 reserved */
+	0,			/* 56 cisptr_lsw */
+	0,			/* 57 cisprt_msw */
+	0,			/* 58 subsysvid */
+	0,			/* 59 subsysid */
+	0,			/* 60 reserved */
+	0,			/* 61 reserved */
+	0,			/* 62 reserved */
+	0			/* 63 reserved */
 };
 
 /*
@@ -14393,136 +14191,128 @@ ADVEEP_38C1600_Config_Field_IsChar __initdata = {
  * For a non-fatal error return a warning code. If there are no warnings
  * then 0 is returned.
  */
-STATIC int __init
-AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
+static int __init AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
 {
-    ushort      warn_code;
-    AdvPortAddr iop_base;
-    uchar       pci_cmd_reg;
-    int         status;
-
-    warn_code = 0;
-    asc_dvc->err_code = 0;
-    iop_base = asc_dvc->iop_base;
-
-    /*
-     * PCI Command Register
-     *
-     * Note: AscPCICmdRegBits_BusMastering definition (0x0007) includes
-     * I/O Space Control, Memory Space Control and Bus Master Control bits.
-     */
-
-    if (((pci_cmd_reg = DvcAdvReadPCIConfigByte(asc_dvc,
-                            AscPCIConfigCommandRegister))
-         & AscPCICmdRegBits_BusMastering)
-        != AscPCICmdRegBits_BusMastering)
-    {
-        pci_cmd_reg |= AscPCICmdRegBits_BusMastering;
-
-        DvcAdvWritePCIConfigByte(asc_dvc,
-                AscPCIConfigCommandRegister, pci_cmd_reg);
-
-        if (((DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister))
-             & AscPCICmdRegBits_BusMastering)
-            != AscPCICmdRegBits_BusMastering)
-        {
-            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-        }
-    }
-
-    /*
-     * PCI Latency Timer
-     *
-     * If the "latency timer" register is 0x20 or above, then we don't need
-     * to change it.  Otherwise, set it to 0x20 (i.e. set it to 0x20 if it
-     * comes up less than 0x20).
-     */
-    if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20) {
-        DvcAdvWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer, 0x20);
-        if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20)
-        {
-            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
-        }
-    }
-
-    /*
-     * Save the state of the PCI Configuration Command Register
-     * "Parity Error Response Control" Bit. If the bit is clear (0),
-     * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore
-     * DMA parity errors.
-     */
-    asc_dvc->cfg->control_flag = 0;
-    if (((DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
-         & AscPCICmdRegBits_ParErrRespCtrl)) == 0)
-    {
-        asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
-    }
+	ushort warn_code;
+	AdvPortAddr iop_base;
+	uchar pci_cmd_reg;
+	int status;
+
+	warn_code = 0;
+	asc_dvc->err_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * PCI Command Register
+	 *
+	 * Note: AscPCICmdRegBits_BusMastering definition (0x0007) includes
+	 * I/O Space Control, Memory Space Control and Bus Master Control bits.
+	 */
+
+	if (((pci_cmd_reg = DvcAdvReadPCIConfigByte(asc_dvc,
+						    AscPCIConfigCommandRegister))
+	     & AscPCICmdRegBits_BusMastering)
+	    != AscPCICmdRegBits_BusMastering) {
+		pci_cmd_reg |= AscPCICmdRegBits_BusMastering;
+
+		DvcAdvWritePCIConfigByte(asc_dvc,
+					 AscPCIConfigCommandRegister,
+					 pci_cmd_reg);
+
+		if (((DvcAdvReadPCIConfigByte
+		      (asc_dvc, AscPCIConfigCommandRegister))
+		     & AscPCICmdRegBits_BusMastering)
+		    != AscPCICmdRegBits_BusMastering) {
+			warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+		}
+	}
 
-    asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
-      ADV_LIB_VERSION_MINOR;
-    asc_dvc->cfg->chip_version =
-      AdvGetChipVersion(iop_base, asc_dvc->bus_type);
+	/*
+	 * PCI Latency Timer
+	 *
+	 * If the "latency timer" register is 0x20 or above, then we don't need
+	 * to change it.  Otherwise, set it to 0x20 (i.e. set it to 0x20 if it
+	 * comes up less than 0x20).
+	 */
+	if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20) {
+		DvcAdvWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer,
+					 0x20);
+		if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) <
+		    0x20) {
+			warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+		}
+	}
 
-    ASC_DBG2(1, "AdvInitGetConfig: iopb_chip_id_1: 0x%x 0x%x\n",
-        (ushort) AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),
-        (ushort) ADV_CHIP_ID_BYTE);
+	/*
+	 * Save the state of the PCI Configuration Command Register
+	 * "Parity Error Response Control" Bit. If the bit is clear (0),
+	 * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore
+	 * DMA parity errors.
+	 */
+	asc_dvc->cfg->control_flag = 0;
+	if (((DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
+	      & AscPCICmdRegBits_ParErrRespCtrl)) == 0) {
+		asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
+	}
 
-    ASC_DBG2(1, "AdvInitGetConfig: iopw_chip_id_0: 0x%x 0x%x\n",
-        (ushort) AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),
-        (ushort) ADV_CHIP_ID_WORD);
+	asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
+	    ADV_LIB_VERSION_MINOR;
+	asc_dvc->cfg->chip_version =
+	    AdvGetChipVersion(iop_base, asc_dvc->bus_type);
+
+	ASC_DBG2(1, "AdvInitGetConfig: iopb_chip_id_1: 0x%x 0x%x\n",
+		 (ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),
+		 (ushort)ADV_CHIP_ID_BYTE);
+
+	ASC_DBG2(1, "AdvInitGetConfig: iopw_chip_id_0: 0x%x 0x%x\n",
+		 (ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),
+		 (ushort)ADV_CHIP_ID_WORD);
+
+	/*
+	 * Reset the chip to start and allow register writes.
+	 */
+	if (AdvFindSignature(iop_base) == 0) {
+		asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+		return ADV_ERROR;
+	} else {
+		/*
+		 * The caller must set 'chip_type' to a valid setting.
+		 */
+		if (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&
+		    asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&
+		    asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {
+			asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
+			return ADV_ERROR;
+		}
 
-    /*
-     * Reset the chip to start and allow register writes.
-     */
-    if (AdvFindSignature(iop_base) == 0)
-    {
-        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
-        return ADV_ERROR;
-    }
-    else {
-        /*
-         * The caller must set 'chip_type' to a valid setting.
-         */
-        if (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&
-            asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&
-            asc_dvc->chip_type != ADV_CHIP_ASC38C1600)
-        {
-            asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
-            return ADV_ERROR;
-        }
-
-        /*
-         * Reset Chip.
-         */
-        AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
-            ADV_CTRL_REG_CMD_RESET);
-        DvcSleepMilliSecond(100);
-        AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
-            ADV_CTRL_REG_CMD_WR_IO_REG);
-
-        if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
-        {
-            if ((status = AdvInitFrom38C1600EEP(asc_dvc)) == ADV_ERROR)
-            {
-                return ADV_ERROR;
-            }
-        } else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
-        {
-            if ((status = AdvInitFrom38C0800EEP(asc_dvc)) == ADV_ERROR)
-            {
-                return ADV_ERROR;
-            }
-        } else
-        {
-            if ((status = AdvInitFrom3550EEP(asc_dvc)) == ADV_ERROR)
-            {
-                return ADV_ERROR;
-            }
-        }
-        warn_code |= status;
-    }
+		/*
+		 * Reset Chip.
+		 */
+		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+				     ADV_CTRL_REG_CMD_RESET);
+		DvcSleepMilliSecond(100);
+		AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+				     ADV_CTRL_REG_CMD_WR_IO_REG);
+
+		if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+			if ((status =
+			     AdvInitFrom38C1600EEP(asc_dvc)) == ADV_ERROR) {
+				return ADV_ERROR;
+			}
+		} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+			if ((status =
+			     AdvInitFrom38C0800EEP(asc_dvc)) == ADV_ERROR) {
+				return ADV_ERROR;
+			}
+		} else {
+			if ((status = AdvInitFrom3550EEP(asc_dvc)) == ADV_ERROR) {
+				return ADV_ERROR;
+			}
+		}
+		warn_code |= status;
+	}
 
-    return warn_code;
+	return warn_code;
 }
 
 /*
@@ -14535,2513 +14325,2407 @@ AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
  *
  * Needed after initialization for error recovery.
  */
-STATIC int
-AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
+static int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
 {
-    AdvPortAddr iop_base;
-    ushort      warn_code;
-    ADV_DCNT    sum;
-    int         begin_addr;
-    int         end_addr;
-    ushort      code_sum;
-    int         word;
-    int         j;
-    int         adv_asc3550_expanded_size;
-    ADV_CARR_T  *carrp;
-    ADV_DCNT    contig_len;
-    ADV_SDCNT   buf_size;
-    ADV_PADDR   carr_paddr;
-    int         i;
-    ushort      scsi_cfg1;
-    uchar       tid;
-    ushort      bios_mem[ASC_MC_BIOSLEN/2]; /* BIOS RISC Memory 0x40-0x8F. */
-    ushort      wdtr_able = 0, sdtr_able, tagqng_able;
-    uchar       max_cmd[ADV_MAX_TID + 1];
-
-    /* If there is already an error, don't continue. */
-    if (asc_dvc->err_code != 0)
-    {
-        return ADV_ERROR;
-    }
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADV_DCNT sum;
+	int begin_addr;
+	int end_addr;
+	ushort code_sum;
+	int word;
+	int j;
+	int adv_asc3550_expanded_size;
+	ADV_CARR_T *carrp;
+	ADV_DCNT contig_len;
+	ADV_SDCNT buf_size;
+	ADV_PADDR carr_paddr;
+	int i;
+	ushort scsi_cfg1;
+	uchar tid;
+	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
+	ushort wdtr_able = 0, sdtr_able, tagqng_able;
+	uchar max_cmd[ADV_MAX_TID + 1];
+
+	/* If there is already an error, don't continue. */
+	if (asc_dvc->err_code != 0) {
+		return ADV_ERROR;
+	}
 
-    /*
-     * The caller must set 'chip_type' to ADV_CHIP_ASC3550.
-     */
-    if (asc_dvc->chip_type != ADV_CHIP_ASC3550)
-    {
-        asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
-        return ADV_ERROR;
-    }
+	/*
+	 * The caller must set 'chip_type' to ADV_CHIP_ASC3550.
+	 */
+	if (asc_dvc->chip_type != ADV_CHIP_ASC3550) {
+		asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
+		return ADV_ERROR;
+	}
 
-    warn_code = 0;
-    iop_base = asc_dvc->iop_base;
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save the RISC memory BIOS region before writing the microcode.
+	 * The BIOS may already be loaded and using its RISC LRAM region
+	 * so its region must be saved and restored.
+	 *
+	 * Note: This code makes the assumption, which is currently true,
+	 * that a chip reset does not clear RISC LRAM.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				bios_mem[i]);
+	}
 
-    /*
-     * Save the RISC memory BIOS region before writing the microcode.
-     * The BIOS may already be loaded and using its RISC LRAM region
-     * so its region must be saved and restored.
-     *
-     * Note: This code makes the assumption, which is currently true,
-     * that a chip reset does not clear RISC LRAM.
-     */
-    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
-    }
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] == 0x55AA) {
+		ushort bios_version, major, minor;
+
+		bios_version =
+		    bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM) / 2];
+		major = (bios_version >> 12) & 0xF;
+		minor = (bios_version >> 8) & 0xF;
+		if (major < 3 || (major == 3 && minor == 1)) {
+			/* BIOS 3.1 and earlier location of 'wdtr_able' variable. */
+			AdvReadWordLram(iop_base, 0x120, wdtr_able);
+		} else {
+			AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+		}
+	}
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
 
-    /*
-     * Save current per TID negotiated values.
-     */
-    if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
-    {
-        ushort  bios_version, major, minor;
-
-        bios_version = bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM)/2];
-        major = (bios_version  >> 12) & 0xF;
-        minor = (bios_version  >> 8) & 0xF;
-        if (major < 3 || (major == 3 && minor == 1))
-        {
-            /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */
-            AdvReadWordLram(iop_base, 0x120, wdtr_able);
-        } else
-        {
-            AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-        }
-    }
-    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-    for (tid = 0; tid <= ADV_MAX_TID; tid++)
-    {
-        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-            max_cmd[tid]);
-    }
+	/*
+	 * Load the Microcode
+	 *
+	 * Write the microcode image to RISC memory starting at address 0.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+	/* Assume the following compressed format of the microcode buffer:
+	 *
+	 *  254 word (508 byte) table indexed by byte code followed
+	 *  by the following byte codes:
+	 *
+	 *    1-Byte Code:
+	 *      00: Emit word 0 in table.
+	 *      01: Emit word 1 in table.
+	 *      .
+	 *      FD: Emit word 253 in table.
+	 *
+	 *    Multi-Byte Code:
+	 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+	 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+	 */
+	word = 0;
+	for (i = 253 * 2; i < _adv_asc3550_size; i++) {
+		if (_adv_asc3550_buf[i] == 0xff) {
+			for (j = 0; j < _adv_asc3550_buf[i + 1]; j++) {
+				AdvWriteWordAutoIncLram(iop_base, (((ushort)
+								    _adv_asc3550_buf
+								    [i +
+								     3] << 8) |
+								   _adv_asc3550_buf
+								   [i + 2]));
+				word++;
+			}
+			i += 3;
+		} else if (_adv_asc3550_buf[i] == 0xfe) {
+			AdvWriteWordAutoIncLram(iop_base, (((ushort)
+							    _adv_asc3550_buf[i +
+									     2]
+							    << 8) |
+							   _adv_asc3550_buf[i +
+									    1]));
+			i += 2;
+			word++;
+		} else {
+			AdvWriteWordAutoIncLram(iop_base, (((ushort)
+							    _adv_asc3550_buf[(_adv_asc3550_buf[i] * 2) + 1] << 8) | _adv_asc3550_buf[_adv_asc3550_buf[i] * 2]));
+			word++;
+		}
+	}
 
-    /*
-     * Load the Microcode
-     *
-     * Write the microcode image to RISC memory starting at address 0.
-     */
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-    /* Assume the following compressed format of the microcode buffer:
-     *
-     *  254 word (508 byte) table indexed by byte code followed
-     *  by the following byte codes:
-     *
-     *    1-Byte Code:
-     *      00: Emit word 0 in table.
-     *      01: Emit word 1 in table.
-     *      .
-     *      FD: Emit word 253 in table.
-     *
-     *    Multi-Byte Code:
-     *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
-     *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
-     */
-    word = 0;
-    for (i = 253 * 2; i < _adv_asc3550_size; i++)
-    {
-        if (_adv_asc3550_buf[i] == 0xff)
-        {
-            for (j = 0; j < _adv_asc3550_buf[i + 1]; j++)
-            {
-                AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                    _adv_asc3550_buf[i + 3] << 8) |
-                _adv_asc3550_buf[i + 2]));
-                word++;
-            }
-            i += 3;
-        } else if (_adv_asc3550_buf[i] == 0xfe)
-        {
-            AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                _adv_asc3550_buf[i + 2] << 8) |
-                _adv_asc3550_buf[i + 1]));
-            i += 2;
-            word++;
-        } else
-        {
-            AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                _adv_asc3550_buf[(_adv_asc3550_buf[i] * 2) + 1] << 8) |
-                _adv_asc3550_buf[_adv_asc3550_buf[i] * 2]));
-            word++;
-        }
-    }
+	/*
+	 * Set 'word' for later use to clear the rest of memory and save
+	 * the expanded mcode size.
+	 */
+	word *= 2;
+	adv_asc3550_expanded_size = word;
+
+	/*
+	 * Clear the rest of ASC-3550 Internal RAM (8KB).
+	 */
+	for (; word < ADV_3550_MEMSIZE; word += 2) {
+		AdvWriteWordAutoIncLram(iop_base, 0);
+	}
 
-    /*
-     * Set 'word' for later use to clear the rest of memory and save
-     * the expanded mcode size.
-     */
-    word *= 2;
-    adv_asc3550_expanded_size = word;
+	/*
+	 * Verify the microcode checksum.
+	 */
+	sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
 
-    /*
-     * Clear the rest of ASC-3550 Internal RAM (8KB).
-     */
-    for (; word < ADV_3550_MEMSIZE; word += 2)
-    {
-        AdvWriteWordAutoIncLram(iop_base, 0);
-    }
+	for (word = 0; word < adv_asc3550_expanded_size; word += 2) {
+		sum += AdvReadWordAutoIncLram(iop_base);
+	}
 
-    /*
-     * Verify the microcode checksum.
-     */
-    sum = 0;
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-    for (word = 0; word < adv_asc3550_expanded_size; word += 2)
-    {
-        sum += AdvReadWordAutoIncLram(iop_base);
-    }
+	if (sum != _adv_asc3550_chksum) {
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+		return ADV_ERROR;
+	}
 
-    if (sum != _adv_asc3550_chksum)
-    {
-        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
-        return ADV_ERROR;
-    }
+	/*
+	 * Restore the RISC memory BIOS region.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				 bios_mem[i]);
+	}
 
-    /*
-     * Restore the RISC memory BIOS region.
-     */
-    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
-    }
+	/*
+	 * Calculate and write the microcode code checksum to the microcode
+	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+	code_sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+	for (word = begin_addr; word < end_addr; word += 2) {
+		code_sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+	/*
+	 * Read and save microcode version and date.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
+			asc_dvc->cfg->mcode_date);
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
+			asc_dvc->cfg->mcode_version);
+
+	/*
+	 * Set the chip type to indicate the ASC3550.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);
+
+	/*
+	 * If the PCI Configuration Command Register "Parity Error Response
+	 * Control" Bit was clear (0), then set the microcode variable
+	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+	 * to ignore DMA parity errors.
+	 */
+	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_IGNORE_PERR;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
 
-    /*
-     * Calculate and write the microcode code checksum to the microcode
-     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
-     */
-    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
-    AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
-    code_sum = 0;
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
-    for (word = begin_addr; word < end_addr; word += 2)
-    {
-        code_sum += AdvReadWordAutoIncLram(iop_base);
-    }
-    AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+	/*
+	 * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO
+	 * threshold of 128 bytes. This register is only accessible to the host.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+			     START_CTL_EMFU | READ_CMD_MRM);
+
+	/*
+	 * Microcode operating variables for WDTR, SDTR, and command tag
+	 * queuing will be set in AdvInquiryHandling() based on what a
+	 * device reports it is capable of in Inquiry byte 7.
+	 *
+	 * If SCSI Bus Resets have been disabled, then directly set
+	 * SDTR and WDTR from the EEPROM configuration. This will allow
+	 * the BIOS and warm boot to work without a SCSI bus hang on
+	 * the Inquiry caused by host and target mismatched DTR values.
+	 * Without the SCSI Bus Reset, before an Inquiry a device can't
+	 * be assumed to be in Asynchronous, Narrow mode.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
+		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+				 asc_dvc->wdtr_able);
+		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+				 asc_dvc->sdtr_able);
+	}
 
-    /*
-     * Read and save microcode version and date.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE, asc_dvc->cfg->mcode_date);
-    AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM, asc_dvc->cfg->mcode_version);
+	/*
+	 * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID
+	 * bitmask. These values determine the maximum SDTR speed negotiated
+	 * with a device.
+	 *
+	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+	 * without determining here whether the device supports SDTR.
+	 *
+	 * 4-bit speed  SDTR speed name
+	 * ===========  ===============
+	 * 0000b (0x0)  SDTR disabled
+	 * 0001b (0x1)  5 Mhz
+	 * 0010b (0x2)  10 Mhz
+	 * 0011b (0x3)  20 Mhz (Ultra)
+	 * 0100b (0x4)  40 Mhz (LVD/Ultra2)
+	 * 0101b (0x5)  80 Mhz (LVD2/Ultra3)
+	 * 0110b (0x6)  Undefined
+	 * .
+	 * 1111b (0xF)  Undefined
+	 */
+	word = 0;
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		if (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able) {
+			/* Set Ultra speed for TID 'tid'. */
+			word |= (0x3 << (4 * (tid % 4)));
+		} else {
+			/* Set Fast speed for TID 'tid'. */
+			word |= (0x2 << (4 * (tid % 4)));
+		}
+		if (tid == 3) {	/* Check if done with sdtr_speed1. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);
+			word = 0;
+		} else if (tid == 7) {	/* Check if done with sdtr_speed2. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);
+			word = 0;
+		} else if (tid == 11) {	/* Check if done with sdtr_speed3. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);
+			word = 0;
+		} else if (tid == 15) {	/* Check if done with sdtr_speed4. */
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);
+			/* End of loop. */
+		}
+	}
 
-    /*
-     * Set the chip type to indicate the ASC3550.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);
+	/*
+	 * Set microcode operating variable for the disconnect per TID bitmask.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
+			 asc_dvc->cfg->disc_enable);
+
+	/*
+	 * Set SCSI_CFG0 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG0 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+			 asc_dvc->chip_scsi_id);
+
+	/*
+	 * Determine SCSI_CFG1 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+
+	/* Read current SCSI_CFG1 Register value. */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+	/*
+	 * If all three connectors are in use, return an error.
+	 */
+	if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
+	    (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {
+		asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
+		return ADV_ERROR;
+	}
 
-    /*
-     * If the PCI Configuration Command Register "Parity Error Response
-     * Control" Bit was clear (0), then set the microcode variable
-     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
-     * to ignore DMA parity errors.
-     */
-    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-        word |= CONTROL_FLAG_IGNORE_PERR;
-        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-    }
+	/*
+	 * If the internal narrow cable is reversed all of the SCSI_CTRL
+	 * register signals will be set. Check for and return an error if
+	 * this condition is found.
+	 */
+	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
+		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO
-     * threshold of 128 bytes. This register is only accessible to the host.
-     */
-    AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
-        START_CTL_EMFU | READ_CMD_MRM);
+	/*
+	 * If this is a differential board and a single-ended device
+	 * is attached to one of the connectors, return an error.
+	 */
+	if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0) {
+		asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Microcode operating variables for WDTR, SDTR, and command tag
-     * queuing will be set in AdvInquiryHandling() based on what a
-     * device reports it is capable of in Inquiry byte 7.
-     *
-     * If SCSI Bus Resets have been disabled, then directly set
-     * SDTR and WDTR from the EEPROM configuration. This will allow
-     * the BIOS and warm boot to work without a SCSI bus hang on
-     * the Inquiry caused by host and target mismatched DTR values.
-     * Without the SCSI Bus Reset, before an Inquiry a device can't
-     * be assumed to be in Asynchronous, Narrow mode.
-     */
-    if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, asc_dvc->wdtr_able);
-        AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, asc_dvc->sdtr_able);
-    }
+	/*
+	 * If automatic termination control is enabled, then set the
+	 * termination value based on a table listed in a_condor.h.
+	 *
+	 * If manual termination was specified with an EEPROM setting
+	 * then 'termination' was set-up in AdvInitFrom3550EEPROM() and
+	 * is ready to be 'ored' into SCSI_CFG1.
+	 */
+	if (asc_dvc->cfg->termination == 0) {
+		/*
+		 * The software always controls termination by setting TERM_CTL_SEL.
+		 * If TERM_CTL_SEL were set to 0, the hardware would set termination.
+		 */
+		asc_dvc->cfg->termination |= TERM_CTL_SEL;
+
+		switch (scsi_cfg1 & CABLE_DETECT) {
+			/* TERM_CTL_H: on, TERM_CTL_L: on */
+		case 0x3:
+		case 0x7:
+		case 0xB:
+		case 0xD:
+		case 0xE:
+		case 0xF:
+			asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
+			break;
+
+			/* TERM_CTL_H: on, TERM_CTL_L: off */
+		case 0x1:
+		case 0x5:
+		case 0x9:
+		case 0xA:
+		case 0xC:
+			asc_dvc->cfg->termination |= TERM_CTL_H;
+			break;
+
+			/* TERM_CTL_H: off, TERM_CTL_L: off */
+		case 0x2:
+		case 0x6:
+			break;
+		}
+	}
 
-    /*
-     * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,
-     * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID
-     * bitmask. These values determine the maximum SDTR speed negotiated
-     * with a device.
-     *
-     * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
-     * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
-     * without determining here whether the device supports SDTR.
-     *
-     * 4-bit speed  SDTR speed name
-     * ===========  ===============
-     * 0000b (0x0)  SDTR disabled
-     * 0001b (0x1)  5 Mhz
-     * 0010b (0x2)  10 Mhz
-     * 0011b (0x3)  20 Mhz (Ultra)
-     * 0100b (0x4)  40 Mhz (LVD/Ultra2)
-     * 0101b (0x5)  80 Mhz (LVD2/Ultra3)
-     * 0110b (0x6)  Undefined
-     * .
-     * 1111b (0xF)  Undefined
-     */
-    word = 0;
-    for (tid = 0; tid <= ADV_MAX_TID; tid++)
-    {
-        if (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able)
-        {
-            /* Set Ultra speed for TID 'tid'. */
-            word |= (0x3 << (4 * (tid % 4)));
-        } else
-        {
-            /* Set Fast speed for TID 'tid'. */
-            word |= (0x2 << (4 * (tid % 4)));
-        }
-        if (tid == 3) /* Check if done with sdtr_speed1. */
-        {
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);
-            word = 0;
-        } else if (tid == 7) /* Check if done with sdtr_speed2. */
-        {
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);
-            word = 0;
-        } else if (tid == 11) /* Check if done with sdtr_speed3. */
-        {
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);
-            word = 0;
-        } else if (tid == 15) /* Check if done with sdtr_speed4. */
-        {
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);
-            /* End of loop. */
-        }
-    }
+	/*
+	 * Clear any set TERM_CTL_H and TERM_CTL_L bits.
+	 */
+	scsi_cfg1 &= ~TERM_CTL;
+
+	/*
+	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then
+	 * set 'scsi_cfg1'. The TERM_POL bit does not need to be
+	 * referenced, because the hardware internally inverts
+	 * the Termination High and Low bits if TERM_POL is set.
+	 */
+	scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));
+
+	/*
+	 * Set SCSI_CFG1 Microcode Default Value
+	 *
+	 * Set filter value and possibly modified termination control
+	 * bits in the Microcode SCSI_CFG1 Register Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
+			 FLTR_DISABLE | scsi_cfg1);
+
+	/*
+	 * Set MEM_CFG Microcode Default Value
+	 *
+	 * The microcode will set the MEM_CFG register using this value
+	 * after it is started below.
+	 *
+	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+	 * are defined.
+	 *
+	 * ASC-3550 has 8KB internal memory.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+			 BIOS_EN | RAM_SZ_8KB);
+
+	/*
+	 * Set SEL_MASK Microcode Default Value
+	 *
+	 * The microcode will set the SEL_MASK register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+	/*
+	 * Build carrier freelist.
+	 *
+	 * Driver must have already allocated memory and set 'carrier_buf'.
+	 */
+	ASC_ASSERT(asc_dvc->carrier_buf != NULL);
+
+	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+	asc_dvc->carr_freelist = NULL;
+	if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf) {
+		buf_size = ADV_CARRIER_BUFSIZE;
+	} else {
+		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+	}
 
-    /*
-     * Set microcode operating variable for the disconnect per TID bitmask.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);
+	do {
+		/*
+		 * Get physical address of the carrier 'carrp'.
+		 */
+		contig_len = sizeof(ADV_CARR_T);
+		carr_paddr =
+		    cpu_to_le32(DvcGetPhyAddr
+				(asc_dvc, NULL, (uchar *)carrp,
+				 (ADV_SDCNT *)&contig_len,
+				 ADV_IS_CARRIER_FLAG));
 
-    /*
-     * Set SCSI_CFG0 Microcode Default Value.
-     *
-     * The microcode will set the SCSI_CFG0 register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
-        PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
-        asc_dvc->chip_scsi_id);
+		buf_size -= sizeof(ADV_CARR_T);
 
-    /*
-     * Determine SCSI_CFG1 Microcode Default Value.
-     *
-     * The microcode will set the SCSI_CFG1 register using this value
-     * after it is started below.
-     */
+		/*
+		 * If the current carrier is not physically contiguous, then
+		 * maybe there was a page crossing. Try the next carrier aligned
+		 * start address.
+		 */
+		if (contig_len < sizeof(ADV_CARR_T)) {
+			carrp++;
+			continue;
+		}
+
+		carrp->carr_pa = carr_paddr;
+		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
 
-    /* Read current SCSI_CFG1 Register value. */
-    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+		/*
+		 * Insert the carrier at the beginning of the freelist.
+		 */
+		carrp->next_vpa =
+		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = carrp;
 
-    /*
-     * If all three connectors are in use, return an error.
-     */
-    if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
-        (scsi_cfg1 & CABLE_ILLEGAL_B) == 0)
-    {
-            asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
-            return ADV_ERROR;
-    }
+		carrp++;
+	}
+	while (buf_size > 0);
 
-    /*
-     * If the internal narrow cable is reversed all of the SCSI_CTRL
-     * register signals will be set. Check for and return an error if
-     * this condition is found.
-     */
-    if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
-    {
-        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
-        return ADV_ERROR;
-    }
+	/*
+	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 */
 
-    /*
-     * If this is a differential board and a single-ended device
-     * is attached to one of the connectors, return an error.
-     */
-    if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0)
-    {
-        asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
-        return ADV_ERROR;
-    }
+	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+	/*
+	 * The first command issued will be placed in the stopper carrier.
+	 */
+	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC ICQ physical address start value.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+
+	/*
+	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 */
+	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+	/*
+	 * The first command completed by the RISC will be placed in
+	 * the stopper.
+	 *
+	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+	 * completed the RISC will set the ASC_RQ_STOPPER bit.
+	 */
+	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC IRQ physical address start value.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+	asc_dvc->carr_pending_cnt = 0;
+
+	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+			     (ADV_INTR_ENABLE_HOST_INTR |
+			      ADV_INTR_ENABLE_GLOBAL_INTR));
+
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+	/* finally, finally, gentlemen, start your engine */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+	/*
+	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+	 * Resets should be performed. The RISC has to be running
+	 * to issue a SCSI Bus Reset.
+	 */
+	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+		/*
+		 * If the BIOS Signature is present in memory, restore the
+		 * BIOS Handshake Configuration Table and do not perform
+		 * a SCSI Bus Reset.
+		 */
+		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
+		    0x55AA) {
+			/*
+			 * Restore per TID negotiated values.
+			 */
+			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 tagqng_able);
+			for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+				AdvWriteByteLram(iop_base,
+						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+						 max_cmd[tid]);
+			}
+		} else {
+			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
+				warn_code = ASC_WARN_BUSRESET_ERROR;
+			}
+		}
+	}
 
-    /*
-     * If automatic termination control is enabled, then set the
-     * termination value based on a table listed in a_condor.h.
-     *
-     * If manual termination was specified with an EEPROM setting
-     * then 'termination' was set-up in AdvInitFrom3550EEPROM() and
-     * is ready to be 'ored' into SCSI_CFG1.
-     */
-    if (asc_dvc->cfg->termination == 0)
-    {
-        /*
-         * The software always controls termination by setting TERM_CTL_SEL.
-         * If TERM_CTL_SEL were set to 0, the hardware would set termination.
-         */
-        asc_dvc->cfg->termination |= TERM_CTL_SEL;
-
-        switch(scsi_cfg1 & CABLE_DETECT)
-        {
-            /* TERM_CTL_H: on, TERM_CTL_L: on */
-            case 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:
-                asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
-                break;
-
-            /* TERM_CTL_H: on, TERM_CTL_L: off */
-            case 0x1: case 0x5: case 0x9: case 0xA: case 0xC:
-                asc_dvc->cfg->termination |= TERM_CTL_H;
-                break;
-
-            /* TERM_CTL_H: off, TERM_CTL_L: off */
-            case 0x2: case 0x6:
-                break;
-        }
-    }
+	return warn_code;
+}
 
-    /*
-     * Clear any set TERM_CTL_H and TERM_CTL_L bits.
-     */
-    scsi_cfg1 &= ~TERM_CTL;
+/*
+ * Initialize the ASC-38C0800.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+static int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADV_DCNT sum;
+	int begin_addr;
+	int end_addr;
+	ushort code_sum;
+	int word;
+	int j;
+	int adv_asc38C0800_expanded_size;
+	ADV_CARR_T *carrp;
+	ADV_DCNT contig_len;
+	ADV_SDCNT buf_size;
+	ADV_PADDR carr_paddr;
+	int i;
+	ushort scsi_cfg1;
+	uchar byte;
+	uchar tid;
+	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
+	ushort wdtr_able, sdtr_able, tagqng_able;
+	uchar max_cmd[ADV_MAX_TID + 1];
+
+	/* If there is already an error, don't continue. */
+	if (asc_dvc->err_code != 0) {
+		return ADV_ERROR;
+	}
 
-    /*
-     * Invert the TERM_CTL_H and TERM_CTL_L bits and then
-     * set 'scsi_cfg1'. The TERM_POL bit does not need to be
-     * referenced, because the hardware internally inverts
-     * the Termination High and Low bits if TERM_POL is set.
-     */
-    scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));
+	/*
+	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.
+	 */
+	if (asc_dvc->chip_type != ADV_CHIP_ASC38C0800) {
+		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Set SCSI_CFG1 Microcode Default Value
-     *
-     * Set filter value and possibly modified termination control
-     * bits in the Microcode SCSI_CFG1 Register Value.
-     *
-     * The microcode will set the SCSI_CFG1 register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
-        FLTR_DISABLE | scsi_cfg1);
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save the RISC memory BIOS region before writing the microcode.
+	 * The BIOS may already be loaded and using its RISC LRAM region
+	 * so its region must be saved and restored.
+	 *
+	 * Note: This code makes the assumption, which is currently true,
+	 * that a chip reset does not clear RISC LRAM.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				bios_mem[i]);
+	}
 
-    /*
-     * Set MEM_CFG Microcode Default Value
-     *
-     * The microcode will set the MEM_CFG register using this value
-     * after it is started below.
-     *
-     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
-     * are defined.
-     *
-     * ASC-3550 has 8KB internal memory.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-        BIOS_EN | RAM_SZ_8KB);
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
 
-    /*
-     * Set SEL_MASK Microcode Default Value
-     *
-     * The microcode will set the SEL_MASK register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
-        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+	/*
+	 * RAM BIST (RAM Built-In Self Test)
+	 *
+	 * Address : I/O base + offset 0x38h register (byte).
+	 * Function: Bit 7-6(RW) : RAM mode
+	 *                          Normal Mode   : 0x00
+	 *                          Pre-test Mode : 0x40
+	 *                          RAM Test Mode : 0x80
+	 *           Bit 5       : unused
+	 *           Bit 4(RO)   : Done bit
+	 *           Bit 3-0(RO) : Status
+	 *                          Host Error    : 0x08
+	 *                          Int_RAM Error : 0x04
+	 *                          RISC Error    : 0x02
+	 *                          SCSI Error    : 0x01
+	 *                          No Error      : 0x00
+	 *
+	 * Note: RAM BIST code should be put right here, before loading the
+	 * microcode and after saving the RISC memory BIOS region.
+	 */
+
+	/*
+	 * LRAM Pre-test
+	 *
+	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
+	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
+	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
+	 * to NORMAL_MODE, return an error too.
+	 */
+	for (i = 0; i < 2; i++) {
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
+		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+		if ((byte & RAM_TEST_DONE) == 0
+		    || (byte & 0x0F) != PRE_TEST_VALUE) {
+			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
+		    != NORMAL_VALUE) {
+			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+	}
 
-    /*
-     * Build carrier freelist.
-     *
-     * Driver must have already allocated memory and set 'carrier_buf'.
-     */
-    ASC_ASSERT(asc_dvc->carrier_buf != NULL);
-
-    carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-    asc_dvc->carr_freelist = NULL;
-    if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf)
-    {
-        buf_size = ADV_CARRIER_BUFSIZE;
-    } else
-    {
-        buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-    }
+	/*
+	 * LRAM Test - It takes about 1.5 ms to run through the test.
+	 *
+	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
+	 * If Done bit not set or Status not 0, save register byte, set the
+	 * err_code, and return an error.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
+	DvcSleepMilliSecond(10);	/* Wait for 10ms before checking status. */
+
+	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
+		/* Get here if Done bit not set or Status not 0. */
+		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
+		asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
+		return ADV_ERROR;
+	}
 
-    do {
-        /*
-         * Get physical address of the carrier 'carrp'.
-         */
-        contig_len = sizeof(ADV_CARR_T);
-        carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL, (uchar *) carrp,
-            (ADV_SDCNT *) &contig_len, ADV_IS_CARRIER_FLAG));
-
-        buf_size -= sizeof(ADV_CARR_T);
-
-        /*
-         * If the current carrier is not physically contiguous, then
-         * maybe there was a page crossing. Try the next carrier aligned
-         * start address.
-         */
-        if (contig_len < sizeof(ADV_CARR_T))
-        {
-            carrp++;
-            continue;
-        }
-
-        carrp->carr_pa = carr_paddr;
-        carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
-
-        /*
-         * Insert the carrier at the beginning of the freelist.
-         */
-        carrp->next_vpa = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-        asc_dvc->carr_freelist = carrp;
-
-        carrp++;
-    }
-    while (buf_size > 0);
+	/* We need to reset back to normal mode after LRAM test passes. */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+
+	/*
+	 * Load the Microcode
+	 *
+	 * Write the microcode image to RISC memory starting at address 0.
+	 *
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+	/* Assume the following compressed format of the microcode buffer:
+	 *
+	 *  254 word (508 byte) table indexed by byte code followed
+	 *  by the following byte codes:
+	 *
+	 *    1-Byte Code:
+	 *      00: Emit word 0 in table.
+	 *      01: Emit word 1 in table.
+	 *      .
+	 *      FD: Emit word 253 in table.
+	 *
+	 *    Multi-Byte Code:
+	 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+	 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+	 */
+	word = 0;
+	for (i = 253 * 2; i < _adv_asc38C0800_size; i++) {
+		if (_adv_asc38C0800_buf[i] == 0xff) {
+			for (j = 0; j < _adv_asc38C0800_buf[i + 1]; j++) {
+				AdvWriteWordAutoIncLram(iop_base, (((ushort)
+								    _adv_asc38C0800_buf
+								    [i +
+								     3] << 8) |
+								   _adv_asc38C0800_buf
+								   [i + 2]));
+				word++;
+			}
+			i += 3;
+		} else if (_adv_asc38C0800_buf[i] == 0xfe) {
+			AdvWriteWordAutoIncLram(iop_base, (((ushort)
+							    _adv_asc38C0800_buf
+							    [i +
+							     2] << 8) |
+							   _adv_asc38C0800_buf[i
+									       +
+									       1]));
+			i += 2;
+			word++;
+		} else {
+			AdvWriteWordAutoIncLram(iop_base, (((ushort)
+							    _adv_asc38C0800_buf[(_adv_asc38C0800_buf[i] * 2) + 1] << 8) | _adv_asc38C0800_buf[_adv_asc38C0800_buf[i] * 2]));
+			word++;
+		}
+	}
 
-    /*
-     * Set-up the Host->RISC Initiator Command Queue (ICQ).
-     */
+	/*
+	 * Set 'word' for later use to clear the rest of memory and save
+	 * the expanded mcode size.
+	 */
+	word *= 2;
+	adv_asc38C0800_expanded_size = word;
+
+	/*
+	 * Clear the rest of ASC-38C0800 Internal RAM (16KB).
+	 */
+	for (; word < ADV_38C0800_MEMSIZE; word += 2) {
+		AdvWriteWordAutoIncLram(iop_base, 0);
+	}
 
-    if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL)
-    {
-        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-        return ADV_ERROR;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+	/*
+	 * Verify the microcode checksum.
+	 */
+	sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
 
-    /*
-     * The first command issued will be placed in the stopper carrier.
-     */
-    asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	for (word = 0; word < adv_asc38C0800_expanded_size; word += 2) {
+		sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	ASC_DBG2(1, "AdvInitAsc38C0800Driver: word %d, i %d\n", word, i);
 
-    /*
-     * Set RISC ICQ physical address start value.
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+	ASC_DBG2(1,
+		 "AdvInitAsc38C0800Driver: sum 0x%lx, _adv_asc38C0800_chksum 0x%lx\n",
+		 (ulong)sum, (ulong)_adv_asc38C0800_chksum);
 
-    /*
-     * Set-up the RISC->Host Initiator Response Queue (IRQ).
-     */
-    if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL)
-    {
-        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-        return ADV_ERROR;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-         ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+	if (sum != _adv_asc38C0800_chksum) {
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+		return ADV_ERROR;
+	}
 
-    /*
-     * The first command completed by the RISC will be placed in
-     * the stopper.
-     *
-     * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-     * completed the RISC will set the ASC_RQ_STOPPER bit.
-     */
-    asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+	/*
+	 * Restore the RISC memory BIOS region.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				 bios_mem[i]);
+	}
 
-    /*
-     * Set RISC IRQ physical address start value.
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
-    asc_dvc->carr_pending_cnt = 0;
+	/*
+	 * Calculate and write the microcode code checksum to the microcode
+	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+	code_sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+	for (word = begin_addr; word < end_addr; word += 2) {
+		code_sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+	/*
+	 * Read microcode version and date.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
+			asc_dvc->cfg->mcode_date);
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
+			asc_dvc->cfg->mcode_version);
+
+	/*
+	 * Set the chip type to indicate the ASC38C0800.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);
+
+	/*
+	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
+	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
+	 * cable detection and then we are able to read C_DET[3:0].
+	 *
+	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
+	 * Microcode Default Value' section below.
+	 */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,
+			     scsi_cfg1 | DIS_TERM_DRV);
+
+	/*
+	 * If the PCI Configuration Command Register "Parity Error Response
+	 * Control" Bit was clear (0), then set the microcode variable
+	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+	 * to ignore DMA parity errors.
+	 */
+	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_IGNORE_PERR;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
 
-    AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
-        (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
+	/*
+	 * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]
+	 * bits for the default FIFO threshold.
+	 *
+	 * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.
+	 *
+	 * For DMA Errata #4 set the BC_THRESH_ENB bit.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+			     BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH |
+			     READ_CMD_MRM);
+
+	/*
+	 * Microcode operating variables for WDTR, SDTR, and command tag
+	 * queuing will be set in AdvInquiryHandling() based on what a
+	 * device reports it is capable of in Inquiry byte 7.
+	 *
+	 * If SCSI Bus Resets have been disabled, then directly set
+	 * SDTR and WDTR from the EEPROM configuration. This will allow
+	 * the BIOS and warm boot to work without a SCSI bus hang on
+	 * the Inquiry caused by host and target mismatched DTR values.
+	 * Without the SCSI Bus Reset, before an Inquiry a device can't
+	 * be assumed to be in Asynchronous, Narrow mode.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
+		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+				 asc_dvc->wdtr_able);
+		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+				 asc_dvc->sdtr_able);
+	}
 
-    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
-    AdvWriteWordRegister(iop_base, IOPW_PC, word);
+	/*
+	 * Set microcode operating variables for DISC and SDTR_SPEED1,
+	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
+	 * configuration values.
+	 *
+	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+	 * without determining here whether the device supports SDTR.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
+			 asc_dvc->cfg->disc_enable);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+
+	/*
+	 * Set SCSI_CFG0 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG0 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+			 asc_dvc->chip_scsi_id);
+
+	/*
+	 * Determine SCSI_CFG1 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+
+	/* Read current SCSI_CFG1 Register value. */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+	/*
+	 * If the internal narrow cable is reversed all of the SCSI_CTRL
+	 * register signals will be set. Check for and return an error if
+	 * this condition is found.
+	 */
+	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
+		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+		return ADV_ERROR;
+	}
 
-    /* finally, finally, gentlemen, start your engine */
-    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+	/*
+	 * All kind of combinations of devices attached to one of four connectors
+	 * are acceptable except HVD device attached. For example, LVD device can
+	 * be attached to SE connector while SE device attached to LVD connector.
+	 * If LVD device attached to SE connector, it only runs up to Ultra speed.
+	 *
+	 * If an HVD device is attached to one of LVD connectors, return an error.
+	 * However, there is no way to detect HVD device attached to SE connectors.
+	 */
+	if (scsi_cfg1 & HVD) {
+		asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
-     * Resets should be performed. The RISC has to be running
-     * to issue a SCSI Bus Reset.
-     */
-    if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
-    {
-        /*
-         * If the BIOS Signature is present in memory, restore the
-         * BIOS Handshake Configuration Table and do not perform
-         * a SCSI Bus Reset.
-         */
-        if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
-        {
-            /*
-             * Restore per TID negotiated values.
-             */
-            AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-            for (tid = 0; tid <= ADV_MAX_TID; tid++)
-            {
-                AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-                    max_cmd[tid]);
-            }
-        } else
-        {
-            if (AdvResetSB(asc_dvc) != ADV_TRUE)
-            {
-                warn_code = ASC_WARN_BUSRESET_ERROR;
-            }
-        }
-    }
+	/*
+	 * If either SE or LVD automatic termination control is enabled, then
+	 * set the termination value based on a table listed in a_condor.h.
+	 *
+	 * If manual termination was specified with an EEPROM setting then
+	 * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to
+	 * be 'ored' into SCSI_CFG1.
+	 */
+	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
+		/* SE automatic termination control is enabled. */
+		switch (scsi_cfg1 & C_DET_SE) {
+			/* TERM_SE_HI: on, TERM_SE_LO: on */
+		case 0x1:
+		case 0x2:
+		case 0x3:
+			asc_dvc->cfg->termination |= TERM_SE;
+			break;
+
+			/* TERM_SE_HI: on, TERM_SE_LO: off */
+		case 0x0:
+			asc_dvc->cfg->termination |= TERM_SE_HI;
+			break;
+		}
+	}
+
+	if ((asc_dvc->cfg->termination & TERM_LVD) == 0) {
+		/* LVD automatic termination control is enabled. */
+		switch (scsi_cfg1 & C_DET_LVD) {
+			/* TERM_LVD_HI: on, TERM_LVD_LO: on */
+		case 0x4:
+		case 0x8:
+		case 0xC:
+			asc_dvc->cfg->termination |= TERM_LVD;
+			break;
+
+			/* TERM_LVD_HI: off, TERM_LVD_LO: off */
+		case 0x0:
+			break;
+		}
+	}
+
+	/*
+	 * Clear any set TERM_SE and TERM_LVD bits.
+	 */
+	scsi_cfg1 &= (~TERM_SE & ~TERM_LVD);
+
+	/*
+	 * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.
+	 */
+	scsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);
+
+	/*
+	 * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits
+	 * and set possibly modified termination control bits in the Microcode
+	 * SCSI_CFG1 Register Value.
+	 */
+	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);
+
+	/*
+	 * Set SCSI_CFG1 Microcode Default Value
+	 *
+	 * Set possibly modified termination control and reset DIS_TERM_DRV
+	 * bits in the Microcode SCSI_CFG1 Register Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+
+	/*
+	 * Set MEM_CFG Microcode Default Value
+	 *
+	 * The microcode will set the MEM_CFG register using this value
+	 * after it is started below.
+	 *
+	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+	 * are defined.
+	 *
+	 * ASC-38C0800 has 16KB internal memory.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+			 BIOS_EN | RAM_SZ_16KB);
+
+	/*
+	 * Set SEL_MASK Microcode Default Value
+	 *
+	 * The microcode will set the SEL_MASK register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+	/*
+	 * Build the carrier freelist.
+	 *
+	 * Driver must have already allocated memory and set 'carrier_buf'.
+	 */
+	ASC_ASSERT(asc_dvc->carrier_buf != NULL);
+
+	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+	asc_dvc->carr_freelist = NULL;
+	if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf) {
+		buf_size = ADV_CARRIER_BUFSIZE;
+	} else {
+		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+	}
+
+	do {
+		/*
+		 * Get physical address for the carrier 'carrp'.
+		 */
+		contig_len = sizeof(ADV_CARR_T);
+		carr_paddr =
+		    cpu_to_le32(DvcGetPhyAddr
+				(asc_dvc, NULL, (uchar *)carrp,
+				 (ADV_SDCNT *)&contig_len,
+				 ADV_IS_CARRIER_FLAG));
 
-    return warn_code;
+		buf_size -= sizeof(ADV_CARR_T);
+
+		/*
+		 * If the current carrier is not physically contiguous, then
+		 * maybe there was a page crossing. Try the next carrier aligned
+		 * start address.
+		 */
+		if (contig_len < sizeof(ADV_CARR_T)) {
+			carrp++;
+			continue;
+		}
+
+		carrp->carr_pa = carr_paddr;
+		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+
+		/*
+		 * Insert the carrier at the beginning of the freelist.
+		 */
+		carrp->next_vpa =
+		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = carrp;
+
+		carrp++;
+	}
+	while (buf_size > 0);
+
+	/*
+	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 */
+
+	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+	/*
+	 * The first command issued will be placed in the stopper carrier.
+	 */
+	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC ICQ physical address start value.
+	 * carr_pa is LE, must be native before write
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+
+	/*
+	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 */
+	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+	/*
+	 * The first command completed by the RISC will be placed in
+	 * the stopper.
+	 *
+	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+	 * completed the RISC will set the ASC_RQ_STOPPER bit.
+	 */
+	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC IRQ physical address start value.
+	 *
+	 * carr_pa is LE, must be native before write *
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+	asc_dvc->carr_pending_cnt = 0;
+
+	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+			     (ADV_INTR_ENABLE_HOST_INTR |
+			      ADV_INTR_ENABLE_GLOBAL_INTR));
+
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+	/* finally, finally, gentlemen, start your engine */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+	/*
+	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+	 * Resets should be performed. The RISC has to be running
+	 * to issue a SCSI Bus Reset.
+	 */
+	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+		/*
+		 * If the BIOS Signature is present in memory, restore the
+		 * BIOS Handshake Configuration Table and do not perform
+		 * a SCSI Bus Reset.
+		 */
+		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
+		    0x55AA) {
+			/*
+			 * Restore per TID negotiated values.
+			 */
+			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 tagqng_able);
+			for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+				AdvWriteByteLram(iop_base,
+						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+						 max_cmd[tid]);
+			}
+		} else {
+			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
+				warn_code = ASC_WARN_BUSRESET_ERROR;
+			}
+		}
+	}
+
+	return warn_code;
 }
 
 /*
- * Initialize the ASC-38C0800.
+ * Initialize the ASC-38C1600.
  *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
  *
  * For a non-fatal error return a warning code. If there are no warnings
  * then 0 is returned.
  *
  * Needed after initialization for error recovery.
  */
-STATIC int
-AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
+static int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
 {
-    AdvPortAddr iop_base;
-    ushort      warn_code;
-    ADV_DCNT    sum;
-    int         begin_addr;
-    int         end_addr;
-    ushort      code_sum;
-    int         word;
-    int         j;
-    int         adv_asc38C0800_expanded_size;
-    ADV_CARR_T  *carrp;
-    ADV_DCNT    contig_len;
-    ADV_SDCNT   buf_size;
-    ADV_PADDR   carr_paddr;
-    int         i;
-    ushort      scsi_cfg1;
-    uchar       byte;
-    uchar       tid;
-    ushort      bios_mem[ASC_MC_BIOSLEN/2]; /* BIOS RISC Memory 0x40-0x8F. */
-    ushort      wdtr_able, sdtr_able, tagqng_able;
-    uchar       max_cmd[ADV_MAX_TID + 1];
-
-    /* If there is already an error, don't continue. */
-    if (asc_dvc->err_code != 0)
-    {
-        return ADV_ERROR;
-    }
-
-    /*
-     * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.
-     */
-    if (asc_dvc->chip_type != ADV_CHIP_ASC38C0800)
-    {
-        asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
-        return ADV_ERROR;
-    }
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADV_DCNT sum;
+	int begin_addr;
+	int end_addr;
+	ushort code_sum;
+	long word;
+	int j;
+	int adv_asc38C1600_expanded_size;
+	ADV_CARR_T *carrp;
+	ADV_DCNT contig_len;
+	ADV_SDCNT buf_size;
+	ADV_PADDR carr_paddr;
+	int i;
+	ushort scsi_cfg1;
+	uchar byte;
+	uchar tid;
+	ushort bios_mem[ASC_MC_BIOSLEN / 2];	/* BIOS RISC Memory 0x40-0x8F. */
+	ushort wdtr_able, sdtr_able, ppr_able, tagqng_able;
+	uchar max_cmd[ASC_MAX_TID + 1];
+
+	/* If there is already an error, don't continue. */
+	if (asc_dvc->err_code != 0) {
+		return ADV_ERROR;
+	}
 
-    warn_code = 0;
-    iop_base = asc_dvc->iop_base;
+	/*
+	 * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.
+	 */
+	if (asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {
+		asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Save the RISC memory BIOS region before writing the microcode.
-     * The BIOS may already be loaded and using its RISC LRAM region
-     * so its region must be saved and restored.
-     *
-     * Note: This code makes the assumption, which is currently true,
-     * that a chip reset does not clear RISC LRAM.
-     */
-    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
-    }
+	warn_code = 0;
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save the RISC memory BIOS region before writing the microcode.
+	 * The BIOS may already be loaded and using its RISC LRAM region
+	 * so its region must be saved and restored.
+	 *
+	 * Note: This code makes the assumption, which is currently true,
+	 * that a chip reset does not clear RISC LRAM.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				bios_mem[i]);
+	}
 
-    /*
-     * Save current per TID negotiated values.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-    for (tid = 0; tid <= ADV_MAX_TID; tid++)
-    {
-        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-            max_cmd[tid]);
-    }
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ASC_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
 
-    /*
-     * RAM BIST (RAM Built-In Self Test)
-     *
-     * Address : I/O base + offset 0x38h register (byte).
-     * Function: Bit 7-6(RW) : RAM mode
-     *                          Normal Mode   : 0x00
-     *                          Pre-test Mode : 0x40
-     *                          RAM Test Mode : 0x80
-     *           Bit 5       : unused
-     *           Bit 4(RO)   : Done bit
-     *           Bit 3-0(RO) : Status
-     *                          Host Error    : 0x08
-     *                          Int_RAM Error : 0x04
-     *                          RISC Error    : 0x02
-     *                          SCSI Error    : 0x01
-     *                          No Error      : 0x00
-     *
-     * Note: RAM BIST code should be put right here, before loading the
-     * microcode and after saving the RISC memory BIOS region.
-     */
+	/*
+	 * RAM BIST (Built-In Self Test)
+	 *
+	 * Address : I/O base + offset 0x38h register (byte).
+	 * Function: Bit 7-6(RW) : RAM mode
+	 *                          Normal Mode   : 0x00
+	 *                          Pre-test Mode : 0x40
+	 *                          RAM Test Mode : 0x80
+	 *           Bit 5       : unused
+	 *           Bit 4(RO)   : Done bit
+	 *           Bit 3-0(RO) : Status
+	 *                          Host Error    : 0x08
+	 *                          Int_RAM Error : 0x04
+	 *                          RISC Error    : 0x02
+	 *                          SCSI Error    : 0x01
+	 *                          No Error      : 0x00
+	 *
+	 * Note: RAM BIST code should be put right here, before loading the
+	 * microcode and after saving the RISC memory BIOS region.
+	 */
+
+	/*
+	 * LRAM Pre-test
+	 *
+	 * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
+	 * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
+	 * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
+	 * to NORMAL_MODE, return an error too.
+	 */
+	for (i = 0; i < 2; i++) {
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
+		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+		if ((byte & RAM_TEST_DONE) == 0
+		    || (byte & 0x0F) != PRE_TEST_VALUE) {
+			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+
+		AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+		DvcSleepMilliSecond(10);	/* Wait for 10ms before reading back. */
+		if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
+		    != NORMAL_VALUE) {
+			asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+			return ADV_ERROR;
+		}
+	}
 
-    /*
-     * LRAM Pre-test
-     *
-     * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
-     * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
-     * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
-     * to NORMAL_MODE, return an error too.
-     */
-    for (i = 0; i < 2; i++)
-    {
-        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
-        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
-        byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-        if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) != PRE_TEST_VALUE)
-        {
-            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
-            return ADV_ERROR;
-        }
-
-        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
-        if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
-            != NORMAL_VALUE)
-        {
-            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
-            return ADV_ERROR;
-        }
-    }
+	/*
+	 * LRAM Test - It takes about 1.5 ms to run through the test.
+	 *
+	 * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
+	 * If Done bit not set or Status not 0, save register byte, set the
+	 * err_code, and return an error.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
+	DvcSleepMilliSecond(10);	/* Wait for 10ms before checking status. */
+
+	byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+	if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {
+		/* Get here if Done bit not set or Status not 0. */
+		asc_dvc->bist_err_code = byte;	/* for BIOS display message */
+		asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
+		return ADV_ERROR;
+	}
 
-    /*
-     * LRAM Test - It takes about 1.5 ms to run through the test.
-     *
-     * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
-     * If Done bit not set or Status not 0, save register byte, set the
-     * err_code, and return an error.
-     */
-    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
-    DvcSleepMilliSecond(10);  /* Wait for 10ms before checking status. */
-
-    byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-    if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0)
-    {
-        /* Get here if Done bit not set or Status not 0. */
-        asc_dvc->bist_err_code = byte;  /* for BIOS display message */
-        asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
-        return ADV_ERROR;
-    }
+	/* We need to reset back to normal mode after LRAM test passes. */
+	AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+
+	/*
+	 * Load the Microcode
+	 *
+	 * Write the microcode image to RISC memory starting at address 0.
+	 *
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+	/*
+	 * Assume the following compressed format of the microcode buffer:
+	 *
+	 *  254 word (508 byte) table indexed by byte code followed
+	 *  by the following byte codes:
+	 *
+	 *    1-Byte Code:
+	 *      00: Emit word 0 in table.
+	 *      01: Emit word 1 in table.
+	 *      .
+	 *      FD: Emit word 253 in table.
+	 *
+	 *    Multi-Byte Code:
+	 *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+	 *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+	 */
+	word = 0;
+	for (i = 253 * 2; i < _adv_asc38C1600_size; i++) {
+		if (_adv_asc38C1600_buf[i] == 0xff) {
+			for (j = 0; j < _adv_asc38C1600_buf[i + 1]; j++) {
+				AdvWriteWordAutoIncLram(iop_base, (((ushort)
+								    _adv_asc38C1600_buf
+								    [i +
+								     3] << 8) |
+								   _adv_asc38C1600_buf
+								   [i + 2]));
+				word++;
+			}
+			i += 3;
+		} else if (_adv_asc38C1600_buf[i] == 0xfe) {
+			AdvWriteWordAutoIncLram(iop_base, (((ushort)
+							    _adv_asc38C1600_buf
+							    [i +
+							     2] << 8) |
+							   _adv_asc38C1600_buf[i
+									       +
+									       1]));
+			i += 2;
+			word++;
+		} else {
+			AdvWriteWordAutoIncLram(iop_base, (((ushort)
+							    _adv_asc38C1600_buf[(_adv_asc38C1600_buf[i] * 2) + 1] << 8) | _adv_asc38C1600_buf[_adv_asc38C1600_buf[i] * 2]));
+			word++;
+		}
+	}
 
-    /* We need to reset back to normal mode after LRAM test passes. */
-    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+	/*
+	 * Set 'word' for later use to clear the rest of memory and save
+	 * the expanded mcode size.
+	 */
+	word *= 2;
+	adv_asc38C1600_expanded_size = word;
+
+	/*
+	 * Clear the rest of ASC-38C1600 Internal RAM (32KB).
+	 */
+	for (; word < ADV_38C1600_MEMSIZE; word += 2) {
+		AdvWriteWordAutoIncLram(iop_base, 0);
+	}
 
-    /*
-     * Load the Microcode
-     *
-     * Write the microcode image to RISC memory starting at address 0.
-     *
-     */
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-    /* Assume the following compressed format of the microcode buffer:
-     *
-     *  254 word (508 byte) table indexed by byte code followed
-     *  by the following byte codes:
-     *
-     *    1-Byte Code:
-     *      00: Emit word 0 in table.
-     *      01: Emit word 1 in table.
-     *      .
-     *      FD: Emit word 253 in table.
-     *
-     *    Multi-Byte Code:
-     *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
-     *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
-     */
-    word = 0;
-    for (i = 253 * 2; i < _adv_asc38C0800_size; i++)
-    {
-        if (_adv_asc38C0800_buf[i] == 0xff)
-        {
-            for (j = 0; j < _adv_asc38C0800_buf[i + 1]; j++)
-            {
-                AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                    _adv_asc38C0800_buf[i + 3] << 8) |
-                    _adv_asc38C0800_buf[i + 2]));
-                word++;
-            }
-            i += 3;
-        } else if (_adv_asc38C0800_buf[i] == 0xfe)
-        {
-            AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                _adv_asc38C0800_buf[i + 2] << 8) |
-                _adv_asc38C0800_buf[i + 1]));
-            i += 2;
-            word++;
-        } else
-        {
-            AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                _adv_asc38C0800_buf[(_adv_asc38C0800_buf[i] * 2) + 1] << 8) |
-                _adv_asc38C0800_buf[_adv_asc38C0800_buf[i] * 2]));
-            word++;
-        }
-    }
+	/*
+	 * Verify the microcode checksum.
+	 */
+	sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
 
-    /*
-     * Set 'word' for later use to clear the rest of memory and save
-     * the expanded mcode size.
-     */
-    word *= 2;
-    adv_asc38C0800_expanded_size = word;
+	for (word = 0; word < adv_asc38C1600_expanded_size; word += 2) {
+		sum += AdvReadWordAutoIncLram(iop_base);
+	}
 
-    /*
-     * Clear the rest of ASC-38C0800 Internal RAM (16KB).
-     */
-    for (; word < ADV_38C0800_MEMSIZE; word += 2)
-    {
-        AdvWriteWordAutoIncLram(iop_base, 0);
-    }
+	if (sum != _adv_asc38C1600_chksum) {
+		asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Verify the microcode checksum.
-     */
-    sum = 0;
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-    for (word = 0; word < adv_asc38C0800_expanded_size; word += 2)
-    {
-        sum += AdvReadWordAutoIncLram(iop_base);
-    }
-    ASC_DBG2(1, "AdvInitAsc38C0800Driver: word %d, i %d\n", word, i);
+	/*
+	 * Restore the RISC memory BIOS region.
+	 */
+	for (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {
+		AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),
+				 bios_mem[i]);
+	}
 
-    ASC_DBG2(1,
-        "AdvInitAsc38C0800Driver: sum 0x%lx, _adv_asc38C0800_chksum 0x%lx\n",
-        (ulong) sum, (ulong) _adv_asc38C0800_chksum);
+	/*
+	 * Calculate and write the microcode code checksum to the microcode
+	 * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+	AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+	code_sum = 0;
+	AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+	for (word = begin_addr; word < end_addr; word += 2) {
+		code_sum += AdvReadWordAutoIncLram(iop_base);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+	/*
+	 * Read microcode version and date.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,
+			asc_dvc->cfg->mcode_date);
+	AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,
+			asc_dvc->cfg->mcode_version);
+
+	/*
+	 * Set the chip type to indicate the ASC38C1600.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);
+
+	/*
+	 * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
+	 * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
+	 * cable detection and then we are able to read C_DET[3:0].
+	 *
+	 * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
+	 * Microcode Default Value' section below.
+	 */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+	AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,
+			     scsi_cfg1 | DIS_TERM_DRV);
+
+	/*
+	 * If the PCI Configuration Command Register "Parity Error Response
+	 * Control" Bit was clear (0), then set the microcode variable
+	 * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+	 * to ignore DMA parity errors.
+	 */
+	if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_IGNORE_PERR;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
 
-    if (sum != _adv_asc38C0800_chksum)
-    {
-        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
-        return ADV_ERROR;
-    }
+	/*
+	 * If the BIOS control flag AIPP (Asynchronous Information
+	 * Phase Protection) disable bit is not set, then set the firmware
+	 * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable
+	 * AIPP checking and encoding.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {
+		AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+		word |= CONTROL_FLAG_ENABLE_AIPP;
+		AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+	}
 
-    /*
-     * Restore the RISC memory BIOS region.
-     */
-    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
-    }
+	/*
+	 * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],
+	 * and START_CTL_TH [3:2].
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+			     FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
+
+	/*
+	 * Microcode operating variables for WDTR, SDTR, and command tag
+	 * queuing will be set in AdvInquiryHandling() based on what a
+	 * device reports it is capable of in Inquiry byte 7.
+	 *
+	 * If SCSI Bus Resets have been disabled, then directly set
+	 * SDTR and WDTR from the EEPROM configuration. This will allow
+	 * the BIOS and warm boot to work without a SCSI bus hang on
+	 * the Inquiry caused by host and target mismatched DTR values.
+	 * Without the SCSI Bus Reset, before an Inquiry a device can't
+	 * be assumed to be in Asynchronous, Narrow mode.
+	 */
+	if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {
+		AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+				 asc_dvc->wdtr_able);
+		AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+				 asc_dvc->sdtr_able);
+	}
 
-    /*
-     * Calculate and write the microcode code checksum to the microcode
-     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
-     */
-    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
-    AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
-    code_sum = 0;
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
-    for (word = begin_addr; word < end_addr; word += 2)
-    {
-        code_sum += AdvReadWordAutoIncLram(iop_base);
-    }
-    AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+	/*
+	 * Set microcode operating variables for DISC and SDTR_SPEED1,
+	 * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
+	 * configuration values.
+	 *
+	 * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+	 * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+	 * without determining here whether the device supports SDTR.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,
+			 asc_dvc->cfg->disc_enable);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+
+	/*
+	 * Set SCSI_CFG0 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG0 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+			 PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+			 asc_dvc->chip_scsi_id);
+
+	/*
+	 * Calculate SCSI_CFG1 Microcode Default Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 *
+	 * Each ASC-38C1600 function has only two cable detect bits.
+	 * The bus mode override bits are in IOPB_SOFT_OVER_WR.
+	 */
+	scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+	/*
+	 * If the cable is reversed all of the SCSI_CTRL register signals
+	 * will be set. Check for and return an error if this condition is
+	 * found.
+	 */
+	if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {
+		asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Read microcode version and date.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE, asc_dvc->cfg->mcode_date);
-    AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM, asc_dvc->cfg->mcode_version);
+	/*
+	 * Each ASC-38C1600 function has two connectors. Only an HVD device
+	 * can not be connected to either connector. An LVD device or SE device
+	 * may be connected to either connecor. If an SE device is connected,
+	 * then at most Ultra speed (20 Mhz) can be used on both connectors.
+	 *
+	 * If an HVD device is attached, return an error.
+	 */
+	if (scsi_cfg1 & HVD) {
+		asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
+		return ADV_ERROR;
+	}
 
-    /*
-     * Set the chip type to indicate the ASC38C0800.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);
+	/*
+	 * Each function in the ASC-38C1600 uses only the SE cable detect and
+	 * termination because there are two connectors for each function. Each
+	 * function may use either LVD or SE mode. Corresponding the SE automatic
+	 * termination control EEPROM bits are used for each function. Each
+	 * function has its own EEPROM. If SE automatic control is enabled for
+	 * the function, then set the termination value based on a table listed
+	 * in a_condor.h.
+	 *
+	 * If manual termination is specified in the EEPROM for the function,
+	 * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is
+	 * ready to be 'ored' into SCSI_CFG1.
+	 */
+	if ((asc_dvc->cfg->termination & TERM_SE) == 0) {
+		/* SE automatic termination control is enabled. */
+		switch (scsi_cfg1 & C_DET_SE) {
+			/* TERM_SE_HI: on, TERM_SE_LO: on */
+		case 0x1:
+		case 0x2:
+		case 0x3:
+			asc_dvc->cfg->termination |= TERM_SE;
+			break;
+
+		case 0x0:
+			if (ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) == 0) {
+				/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
+			} else {
+				/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
+				asc_dvc->cfg->termination |= TERM_SE_HI;
+			}
+			break;
+		}
+	}
 
-    /*
-     * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
-     * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
-     * cable detection and then we are able to read C_DET[3:0].
-     *
-     * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
-     * Microcode Default Value' section below.
-     */
-    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
-    AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1, scsi_cfg1 | DIS_TERM_DRV);
+	/*
+	 * Clear any set TERM_SE bits.
+	 */
+	scsi_cfg1 &= ~TERM_SE;
+
+	/*
+	 * Invert the TERM_SE bits and then set 'scsi_cfg1'.
+	 */
+	scsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);
+
+	/*
+	 * Clear Big Endian and Terminator Polarity bits and set possibly
+	 * modified termination control bits in the Microcode SCSI_CFG1
+	 * Register Value.
+	 *
+	 * Big Endian bit is not used even on big endian machines.
+	 */
+	scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);
+
+	/*
+	 * Set SCSI_CFG1 Microcode Default Value
+	 *
+	 * Set possibly modified termination control bits in the Microcode
+	 * SCSI_CFG1 Register Value.
+	 *
+	 * The microcode will set the SCSI_CFG1 register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+
+	/*
+	 * Set MEM_CFG Microcode Default Value
+	 *
+	 * The microcode will set the MEM_CFG register using this value
+	 * after it is started below.
+	 *
+	 * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+	 * are defined.
+	 *
+	 * ASC-38C1600 has 32KB internal memory.
+	 *
+	 * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come
+	 * out a special 16K Adv Library and Microcode version. After the issue
+	 * resolved, we should turn back to the 32K support. Both a_condor.h and
+	 * mcode.sas files also need to be updated.
+	 *
+	 * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+	 *  BIOS_EN | RAM_SZ_32KB);
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+			 BIOS_EN | RAM_SZ_16KB);
+
+	/*
+	 * Set SEL_MASK Microcode Default Value
+	 *
+	 * The microcode will set the SEL_MASK register using this value
+	 * after it is started below.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+			 ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+	/*
+	 * Build the carrier freelist.
+	 *
+	 * Driver must have already allocated memory and set 'carrier_buf'.
+	 */
+
+	ASC_ASSERT(asc_dvc->carrier_buf != NULL);
+
+	carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+	asc_dvc->carr_freelist = NULL;
+	if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf) {
+		buf_size = ADV_CARRIER_BUFSIZE;
+	} else {
+		buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+	}
 
-    /*
-     * If the PCI Configuration Command Register "Parity Error Response
-     * Control" Bit was clear (0), then set the microcode variable
-     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
-     * to ignore DMA parity errors.
-     */
-    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-        word |= CONTROL_FLAG_IGNORE_PERR;
-        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-    }
+	do {
+		/*
+		 * Get physical address for the carrier 'carrp'.
+		 */
+		contig_len = sizeof(ADV_CARR_T);
+		carr_paddr =
+		    cpu_to_le32(DvcGetPhyAddr
+				(asc_dvc, NULL, (uchar *)carrp,
+				 (ADV_SDCNT *)&contig_len,
+				 ADV_IS_CARRIER_FLAG));
 
-    /*
-     * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]
-     * bits for the default FIFO threshold.
-     *
-     * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.
-     *
-     * For DMA Errata #4 set the BC_THRESH_ENB bit.
-     */
-    AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
-        BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
+		buf_size -= sizeof(ADV_CARR_T);
 
-    /*
-     * Microcode operating variables for WDTR, SDTR, and command tag
-     * queuing will be set in AdvInquiryHandling() based on what a
-     * device reports it is capable of in Inquiry byte 7.
-     *
-     * If SCSI Bus Resets have been disabled, then directly set
-     * SDTR and WDTR from the EEPROM configuration. This will allow
-     * the BIOS and warm boot to work without a SCSI bus hang on
-     * the Inquiry caused by host and target mismatched DTR values.
-     * Without the SCSI Bus Reset, before an Inquiry a device can't
-     * be assumed to be in Asynchronous, Narrow mode.
-     */
-    if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, asc_dvc->wdtr_able);
-        AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, asc_dvc->sdtr_able);
-    }
+		/*
+		 * If the current carrier is not physically contiguous, then
+		 * maybe there was a page crossing. Try the next carrier aligned
+		 * start address.
+		 */
+		if (contig_len < sizeof(ADV_CARR_T)) {
+			carrp++;
+			continue;
+		}
+
+		carrp->carr_pa = carr_paddr;
+		carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
 
-    /*
-     * Set microcode operating variables for DISC and SDTR_SPEED1,
-     * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
-     * configuration values.
-     *
-     * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
-     * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
-     * without determining here whether the device supports SDTR.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+		/*
+		 * Insert the carrier at the beginning of the freelist.
+		 */
+		carrp->next_vpa =
+		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = carrp;
 
-    /*
-     * Set SCSI_CFG0 Microcode Default Value.
-     *
-     * The microcode will set the SCSI_CFG0 register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
-        PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
-        asc_dvc->chip_scsi_id);
+		carrp++;
+	}
+	while (buf_size > 0);
+
+	/*
+	 * Set-up the Host->RISC Initiator Command Queue (ICQ).
+	 */
+	if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+	/*
+	 * The first command issued will be placed in the stopper carrier.
+	 */
+	asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC ICQ physical address start value. Initialize the
+	 * COMMA register to the same value otherwise the RISC will
+	 * prematurely detect a command is available.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+	AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
+			      le32_to_cpu(asc_dvc->icq_sp->carr_pa));
+
+	/*
+	 * Set-up the RISC->Host Initiator Response Queue (IRQ).
+	 */
+	if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL) {
+		asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+		return ADV_ERROR;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+	/*
+	 * The first command completed by the RISC will be placed in
+	 * the stopper.
+	 *
+	 * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+	 * completed the RISC will set the ASC_RQ_STOPPER bit.
+	 */
+	asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Set RISC IRQ physical address start value.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+	asc_dvc->carr_pending_cnt = 0;
+
+	AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+			     (ADV_INTR_ENABLE_HOST_INTR |
+			      ADV_INTR_ENABLE_GLOBAL_INTR));
+	AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+	AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+	/* finally, finally, gentlemen, start your engine */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+	/*
+	 * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+	 * Resets should be performed. The RISC has to be running
+	 * to issue a SCSI Bus Reset.
+	 */
+	if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {
+		/*
+		 * If the BIOS Signature is present in memory, restore the
+		 * per TID microcode operating variables.
+		 */
+		if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==
+		    0x55AA) {
+			/*
+			 * Restore per TID negotiated values.
+			 */
+			AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 tagqng_able);
+			for (tid = 0; tid <= ASC_MAX_TID; tid++) {
+				AdvWriteByteLram(iop_base,
+						 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+						 max_cmd[tid]);
+			}
+		} else {
+			if (AdvResetSB(asc_dvc) != ADV_TRUE) {
+				warn_code = ASC_WARN_BUSRESET_ERROR;
+			}
+		}
+	}
 
-    /*
-     * Determine SCSI_CFG1 Microcode Default Value.
-     *
-     * The microcode will set the SCSI_CFG1 register using this value
-     * after it is started below.
-     */
+	return warn_code;
+}
 
-    /* Read current SCSI_CFG1 Register value. */
-    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+/*
+ * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
+ * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Note: Chip is stopped on entry.
+ */
+static int __init AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADVEEP_3550_CONFIG eep_config;
+	int i;
 
-    /*
-     * If the internal narrow cable is reversed all of the SCSI_CTRL
-     * register signals will be set. Check for and return an error if
-     * this condition is found.
-     */
-    if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
-    {
-        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
-        return ADV_ERROR;
-    }
+	iop_base = asc_dvc->iop_base;
 
-    /*
-     * All kind of combinations of devices attached to one of four connectors
-     * are acceptable except HVD device attached. For example, LVD device can
-     * be attached to SE connector while SE device attached to LVD connector.
-     * If LVD device attached to SE connector, it only runs up to Ultra speed.
-     *
-     * If an HVD device is attached to one of LVD connectors, return an error.
-     * However, there is no way to detect HVD device attached to SE connectors.
-     */
-    if (scsi_cfg1 & HVD)
-    {
-        asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
-        return ADV_ERROR;
-    }
+	warn_code = 0;
 
-    /*
-     * If either SE or LVD automatic termination control is enabled, then
-     * set the termination value based on a table listed in a_condor.h.
-     *
-     * If manual termination was specified with an EEPROM setting then
-     * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to
-     * be 'ored' into SCSI_CFG1.
-     */
-    if ((asc_dvc->cfg->termination & TERM_SE) == 0)
-    {
-        /* SE automatic termination control is enabled. */
-        switch(scsi_cfg1 & C_DET_SE)
-        {
-            /* TERM_SE_HI: on, TERM_SE_LO: on */
-            case 0x1: case 0x2: case 0x3:
-                asc_dvc->cfg->termination |= TERM_SE;
-                break;
-
-            /* TERM_SE_HI: on, TERM_SE_LO: off */
-            case 0x0:
-                asc_dvc->cfg->termination |= TERM_SE_HI;
-                break;
-        }
-    }
+	/*
+	 * Read the board's EEPROM configuration.
+	 *
+	 * Set default values if a bad checksum is found.
+	 */
+	if (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum) {
+		warn_code |= ASC_WARN_EEPROM_CHKSUM;
 
-    if ((asc_dvc->cfg->termination & TERM_LVD) == 0)
-    {
-        /* LVD automatic termination control is enabled. */
-        switch(scsi_cfg1 & C_DET_LVD)
-        {
-            /* TERM_LVD_HI: on, TERM_LVD_LO: on */
-            case 0x4: case 0x8: case 0xC:
-                asc_dvc->cfg->termination |= TERM_LVD;
-                break;
-
-            /* TERM_LVD_HI: off, TERM_LVD_LO: off */
-            case 0x0:
-                break;
-        }
-    }
+		/*
+		 * Set EEPROM default values.
+		 */
+		for (i = 0; i < sizeof(ADVEEP_3550_CONFIG); i++) {
+			*((uchar *)&eep_config + i) =
+			    *((uchar *)&Default_3550_EEPROM_Config + i);
+		}
 
-    /*
-     * Clear any set TERM_SE and TERM_LVD bits.
-     */
-    scsi_cfg1 &= (~TERM_SE & ~TERM_LVD);
+		/*
+		 * Assume the 6 byte board serial number that was read
+		 * from EEPROM is correct even if the EEPROM checksum
+		 * failed.
+		 */
+		eep_config.serial_number_word3 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
 
-    /*
-     * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.
-     */
-    scsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);
+		eep_config.serial_number_word2 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
 
-    /*
-     * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits
-     * and set possibly modified termination control bits in the Microcode
-     * SCSI_CFG1 Register Value.
-     */
-    scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);
+		eep_config.serial_number_word1 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
 
-    /*
-     * Set SCSI_CFG1 Microcode Default Value
-     *
-     * Set possibly modified termination control and reset DIS_TERM_DRV
-     * bits in the Microcode SCSI_CFG1 Register Value.
-     *
-     * The microcode will set the SCSI_CFG1 register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+		AdvSet3550EEPConfig(iop_base, &eep_config);
+	}
+	/*
+	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
+	 * EEPROM configuration that was read.
+	 *
+	 * This is the mapping of EEPROM fields to Adv Library fields.
+	 */
+	asc_dvc->wdtr_able = eep_config.wdtr_able;
+	asc_dvc->sdtr_able = eep_config.sdtr_able;
+	asc_dvc->ultra_able = eep_config.ultra_able;
+	asc_dvc->tagqng_able = eep_config.tagqng_able;
+	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
+	asc_dvc->start_motor = eep_config.start_motor;
+	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+	asc_dvc->no_scam = eep_config.scam_tolerant;
+	asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
+	asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
+	asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
+
+	/*
+	 * Set the host maximum queuing (max. 253, min. 16) and the per device
+	 * maximum queuing (max. 63, min. 4).
+	 */
+	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
+		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_host_qng == 0) {
+			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+		} else {
+			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+		}
+	}
 
-    /*
-     * Set MEM_CFG Microcode Default Value
-     *
-     * The microcode will set the MEM_CFG register using this value
-     * after it is started below.
-     *
-     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
-     * are defined.
-     *
-     * ASC-38C0800 has 16KB internal memory.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-        BIOS_EN | RAM_SZ_16KB);
+	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
+		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_dvc_qng == 0) {
+			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+		} else {
+			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+		}
+	}
 
-    /*
-     * Set SEL_MASK Microcode Default Value
-     *
-     * The microcode will set the SEL_MASK register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
-        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+	/*
+	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
+	 * set 'max_dvc_qng' to 'max_host_qng'.
+	 */
+	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
+		eep_config.max_dvc_qng = eep_config.max_host_qng;
+	}
 
-    /*
-     * Build the carrier freelist.
-     *
-     * Driver must have already allocated memory and set 'carrier_buf'.
-     */
-    ASC_ASSERT(asc_dvc->carrier_buf != NULL);
-
-    carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-    asc_dvc->carr_freelist = NULL;
-    if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf)
-    {
-        buf_size = ADV_CARRIER_BUFSIZE;
-    } else
-    {
-        buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-    }
+	/*
+	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
+	 * values based on possibly adjusted EEPROM values.
+	 */
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+	/*
+	 * If the EEPROM 'termination' field is set to automatic (0), then set
+	 * the ADV_DVC_CFG 'termination' field to automatic also.
+	 *
+	 * If the termination is specified with a non-zero 'termination'
+	 * value check that a legal value is set and set the ADV_DVC_CFG
+	 * 'termination' field appropriately.
+	 */
+	if (eep_config.termination == 0) {
+		asc_dvc->cfg->termination = 0;	/* auto termination */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination == 1) {
+			asc_dvc->cfg->termination = TERM_CTL_SEL;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination == 2) {
+			asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination == 3) {
+			asc_dvc->cfg->termination =
+			    TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
+		} else {
+			/*
+			 * The EEPROM 'termination' field contains a bad value. Use
+			 * automatic termination instead.
+			 */
+			asc_dvc->cfg->termination = 0;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
+	}
 
-    do {
-        /*
-         * Get physical address for the carrier 'carrp'.
-         */
-        contig_len = sizeof(ADV_CARR_T);
-        carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL, (uchar *) carrp,
-            (ADV_SDCNT *) &contig_len, ADV_IS_CARRIER_FLAG));
-
-        buf_size -= sizeof(ADV_CARR_T);
-
-        /*
-         * If the current carrier is not physically contiguous, then
-         * maybe there was a page crossing. Try the next carrier aligned
-         * start address.
-         */
-        if (contig_len < sizeof(ADV_CARR_T))
-        {
-            carrp++;
-            continue;
-        }
-
-        carrp->carr_pa = carr_paddr;
-        carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
-
-        /*
-         * Insert the carrier at the beginning of the freelist.
-         */
-        carrp->next_vpa = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-        asc_dvc->carr_freelist = carrp;
-
-        carrp++;
-    }
-    while (buf_size > 0);
+	return warn_code;
+}
 
-    /*
-     * Set-up the Host->RISC Initiator Command Queue (ICQ).
-     */
+/*
+ * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
+ * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Note: Chip is stopped on entry.
+ */
+static int __init AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
+{
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADVEEP_38C0800_CONFIG eep_config;
+	int i;
+	uchar tid, termination;
+	ushort sdtr_speed = 0;
+
+	iop_base = asc_dvc->iop_base;
+
+	warn_code = 0;
+
+	/*
+	 * Read the board's EEPROM configuration.
+	 *
+	 * Set default values if a bad checksum is found.
+	 */
+	if (AdvGet38C0800EEPConfig(iop_base, &eep_config) !=
+	    eep_config.check_sum) {
+		warn_code |= ASC_WARN_EEPROM_CHKSUM;
 
-    if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL)
-    {
-        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-        return ADV_ERROR;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+		/*
+		 * Set EEPROM default values.
+		 */
+		for (i = 0; i < sizeof(ADVEEP_38C0800_CONFIG); i++) {
+			*((uchar *)&eep_config + i) =
+			    *((uchar *)&Default_38C0800_EEPROM_Config + i);
+		}
 
-    /*
-     * The first command issued will be placed in the stopper carrier.
-     */
-    asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+		/*
+		 * Assume the 6 byte board serial number that was read
+		 * from EEPROM is correct even if the EEPROM checksum
+		 * failed.
+		 */
+		eep_config.serial_number_word3 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
 
-    /*
-     * Set RISC ICQ physical address start value.
-     * carr_pa is LE, must be native before write
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+		eep_config.serial_number_word2 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
 
-    /*
-     * Set-up the RISC->Host Initiator Response Queue (IRQ).
-     */
-    if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL)
-    {
-        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-        return ADV_ERROR;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+		eep_config.serial_number_word1 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
 
-    /*
-     * The first command completed by the RISC will be placed in
-     * the stopper.
-     *
-     * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-     * completed the RISC will set the ASC_RQ_STOPPER bit.
-     */
-    asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+		AdvSet38C0800EEPConfig(iop_base, &eep_config);
+	}
+	/*
+	 * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the
+	 * EEPROM configuration that was read.
+	 *
+	 * This is the mapping of EEPROM fields to Adv Library fields.
+	 */
+	asc_dvc->wdtr_able = eep_config.wdtr_able;
+	asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
+	asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
+	asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
+	asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
+	asc_dvc->tagqng_able = eep_config.tagqng_able;
+	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
+	asc_dvc->start_motor = eep_config.start_motor;
+	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+	asc_dvc->no_scam = eep_config.scam_tolerant;
+	asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
+	asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
+	asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
+
+	/*
+	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
+	 * are set, then set an 'sdtr_able' bit for it.
+	 */
+	asc_dvc->sdtr_able = 0;
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		if (tid == 0) {
+			sdtr_speed = asc_dvc->sdtr_speed1;
+		} else if (tid == 4) {
+			sdtr_speed = asc_dvc->sdtr_speed2;
+		} else if (tid == 8) {
+			sdtr_speed = asc_dvc->sdtr_speed3;
+		} else if (tid == 12) {
+			sdtr_speed = asc_dvc->sdtr_speed4;
+		}
+		if (sdtr_speed & ADV_MAX_TID) {
+			asc_dvc->sdtr_able |= (1 << tid);
+		}
+		sdtr_speed >>= 4;
+	}
 
-    /*
-     * Set RISC IRQ physical address start value.
-     *
-     * carr_pa is LE, must be native before write *
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
-    asc_dvc->carr_pending_cnt = 0;
+	/*
+	 * Set the host maximum queuing (max. 253, min. 16) and the per device
+	 * maximum queuing (max. 63, min. 4).
+	 */
+	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
+		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_host_qng == 0) {
+			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+		} else {
+			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+		}
+	}
 
-    AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
-        (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
+	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
+		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_dvc_qng == 0) {
+			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+		} else {
+			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+		}
+	}
 
-    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
-    AdvWriteWordRegister(iop_base, IOPW_PC, word);
+	/*
+	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
+	 * set 'max_dvc_qng' to 'max_host_qng'.
+	 */
+	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
+		eep_config.max_dvc_qng = eep_config.max_host_qng;
+	}
 
-    /* finally, finally, gentlemen, start your engine */
-    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+	/*
+	 * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
+	 * values based on possibly adjusted EEPROM values.
+	 */
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+	/*
+	 * If the EEPROM 'termination' field is set to automatic (0), then set
+	 * the ADV_DVC_CFG 'termination' field to automatic also.
+	 *
+	 * If the termination is specified with a non-zero 'termination'
+	 * value check that a legal value is set and set the ADV_DVC_CFG
+	 * 'termination' field appropriately.
+	 */
+	if (eep_config.termination_se == 0) {
+		termination = 0;	/* auto termination for SE */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_se == 1) {
+			termination = 0;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_se == 2) {
+			termination = TERM_SE_HI;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_se == 3) {
+			termination = TERM_SE;
+		} else {
+			/*
+			 * The EEPROM 'termination_se' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			termination = 0;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
+	}
 
-    /*
-     * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
-     * Resets should be performed. The RISC has to be running
-     * to issue a SCSI Bus Reset.
-     */
-    if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
-    {
-        /*
-         * If the BIOS Signature is present in memory, restore the
-         * BIOS Handshake Configuration Table and do not perform
-         * a SCSI Bus Reset.
-         */
-        if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
-        {
-            /*
-             * Restore per TID negotiated values.
-             */
-            AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-            for (tid = 0; tid <= ADV_MAX_TID; tid++)
-            {
-                AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-                    max_cmd[tid]);
-            }
-        } else
-        {
-            if (AdvResetSB(asc_dvc) != ADV_TRUE)
-            {
-                warn_code = ASC_WARN_BUSRESET_ERROR;
-            }
-        }
-    }
+	if (eep_config.termination_lvd == 0) {
+		asc_dvc->cfg->termination = termination;	/* auto termination for LVD */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_lvd == 1) {
+			asc_dvc->cfg->termination = termination;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_lvd == 2) {
+			asc_dvc->cfg->termination = termination | TERM_LVD_HI;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_lvd == 3) {
+			asc_dvc->cfg->termination = termination | TERM_LVD;
+		} else {
+			/*
+			 * The EEPROM 'termination_lvd' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			asc_dvc->cfg->termination = termination;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
+	}
 
-    return warn_code;
+	return warn_code;
 }
 
 /*
- * Initialize the ASC-38C1600.
+ * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and
+ * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
  *
  * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
  *
  * For a non-fatal error return a warning code. If there are no warnings
  * then 0 is returned.
  *
- * Needed after initialization for error recovery.
+ * Note: Chip is stopped on entry.
  */
-STATIC int
-AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
+static int __init AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
 {
-    AdvPortAddr iop_base;
-    ushort      warn_code;
-    ADV_DCNT    sum;
-    int         begin_addr;
-    int         end_addr;
-    ushort      code_sum;
-    long        word;
-    int         j;
-    int         adv_asc38C1600_expanded_size;
-    ADV_CARR_T  *carrp;
-    ADV_DCNT    contig_len;
-    ADV_SDCNT   buf_size;
-    ADV_PADDR   carr_paddr;
-    int         i;
-    ushort      scsi_cfg1;
-    uchar       byte;
-    uchar       tid;
-    ushort      bios_mem[ASC_MC_BIOSLEN/2]; /* BIOS RISC Memory 0x40-0x8F. */
-    ushort      wdtr_able, sdtr_able, ppr_able, tagqng_able;
-    uchar       max_cmd[ASC_MAX_TID + 1];
-
-    /* If there is already an error, don't continue. */
-    if (asc_dvc->err_code != 0)
-    {
-        return ADV_ERROR;
-    }
-
-    /*
-     * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.
-     */
-    if (asc_dvc->chip_type != ADV_CHIP_ASC38C1600)
-    {
-        asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
-        return ADV_ERROR;
-    }
-
-    warn_code = 0;
-    iop_base = asc_dvc->iop_base;
-
-    /*
-     * Save the RISC memory BIOS region before writing the microcode.
-     * The BIOS may already be loaded and using its RISC LRAM region
-     * so its region must be saved and restored.
-     *
-     * Note: This code makes the assumption, which is currently true,
-     * that a chip reset does not clear RISC LRAM.
-     */
-    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
-    }
-
-    /*
-     * Save current per TID negotiated values.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-    AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-    for (tid = 0; tid <= ASC_MAX_TID; tid++)
-    {
-        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-            max_cmd[tid]);
-    }
-
-    /*
-     * RAM BIST (Built-In Self Test)
-     *
-     * Address : I/O base + offset 0x38h register (byte).
-     * Function: Bit 7-6(RW) : RAM mode
-     *                          Normal Mode   : 0x00
-     *                          Pre-test Mode : 0x40
-     *                          RAM Test Mode : 0x80
-     *           Bit 5       : unused
-     *           Bit 4(RO)   : Done bit
-     *           Bit 3-0(RO) : Status
-     *                          Host Error    : 0x08
-     *                          Int_RAM Error : 0x04
-     *                          RISC Error    : 0x02
-     *                          SCSI Error    : 0x01
-     *                          No Error      : 0x00
-     *
-     * Note: RAM BIST code should be put right here, before loading the
-     * microcode and after saving the RISC memory BIOS region.
-     */
-
-    /*
-     * LRAM Pre-test
-     *
-     * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
-     * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
-     * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
-     * to NORMAL_MODE, return an error too.
-     */
-    for (i = 0; i < 2; i++)
-    {
-        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
-        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
-        byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-        if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) != PRE_TEST_VALUE)
-        {
-            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
-            return ADV_ERROR;
-        }
-
-        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
-        if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
-            != NORMAL_VALUE)
-        {
-            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
-            return ADV_ERROR;
-        }
-    }
-
-    /*
-     * LRAM Test - It takes about 1.5 ms to run through the test.
-     *
-     * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
-     * If Done bit not set or Status not 0, save register byte, set the
-     * err_code, and return an error.
-     */
-    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
-    DvcSleepMilliSecond(10);  /* Wait for 10ms before checking status. */
-
-    byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
-    if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0)
-    {
-        /* Get here if Done bit not set or Status not 0. */
-        asc_dvc->bist_err_code = byte;  /* for BIOS display message */
-        asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
-        return ADV_ERROR;
-    }
-
-    /* We need to reset back to normal mode after LRAM test passes. */
-    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
-
-    /*
-     * Load the Microcode
-     *
-     * Write the microcode image to RISC memory starting at address 0.
-     *
-     */
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-    /*
-     * Assume the following compressed format of the microcode buffer:
-     *
-     *  254 word (508 byte) table indexed by byte code followed
-     *  by the following byte codes:
-     *
-     *    1-Byte Code:
-     *      00: Emit word 0 in table.
-     *      01: Emit word 1 in table.
-     *      .
-     *      FD: Emit word 253 in table.
-     *
-     *    Multi-Byte Code:
-     *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
-     *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
-     */
-    word = 0;
-    for (i = 253 * 2; i < _adv_asc38C1600_size; i++)
-    {
-        if (_adv_asc38C1600_buf[i] == 0xff)
-        {
-            for (j = 0; j < _adv_asc38C1600_buf[i + 1]; j++)
-            {
-                AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                     _adv_asc38C1600_buf[i + 3] << 8) |
-                     _adv_asc38C1600_buf[i + 2]));
-                word++;
-            }
-           i += 3;
-        } else if (_adv_asc38C1600_buf[i] == 0xfe)
-        {
-                AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                     _adv_asc38C1600_buf[i + 2] << 8) |
-                     _adv_asc38C1600_buf[i + 1]));
-            i += 2;
-            word++;
-        } else
-        {
-            AdvWriteWordAutoIncLram(iop_base, (((ushort)
-                 _adv_asc38C1600_buf[(_adv_asc38C1600_buf[i] * 2) + 1] << 8) |
-                 _adv_asc38C1600_buf[_adv_asc38C1600_buf[i] * 2]));
-            word++;
-        }
-    }
-
-    /*
-     * Set 'word' for later use to clear the rest of memory and save
-     * the expanded mcode size.
-     */
-    word *= 2;
-    adv_asc38C1600_expanded_size = word;
-
-    /*
-     * Clear the rest of ASC-38C1600 Internal RAM (32KB).
-     */
-    for (; word < ADV_38C1600_MEMSIZE; word += 2)
-    {
-        AdvWriteWordAutoIncLram(iop_base, 0);
-    }
-
-    /*
-     * Verify the microcode checksum.
-     */
-    sum = 0;
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
-
-    for (word = 0; word < adv_asc38C1600_expanded_size; word += 2)
-    {
-        sum += AdvReadWordAutoIncLram(iop_base);
-    }
-
-    if (sum != _adv_asc38C1600_chksum)
-    {
-        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
-        return ADV_ERROR;
-    }
-
-    /*
-     * Restore the RISC memory BIOS region.
-     */
-    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
-    }
-
-    /*
-     * Calculate and write the microcode code checksum to the microcode
-     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
-     */
-    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
-    AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
-    code_sum = 0;
-    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
-    for (word = begin_addr; word < end_addr; word += 2)
-    {
-        code_sum += AdvReadWordAutoIncLram(iop_base);
-    }
-    AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
-
-    /*
-     * Read microcode version and date.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE, asc_dvc->cfg->mcode_date);
-    AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM, asc_dvc->cfg->mcode_version);
-
-    /*
-     * Set the chip type to indicate the ASC38C1600.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);
-
-    /*
-     * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
-     * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
-     * cable detection and then we are able to read C_DET[3:0].
-     *
-     * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
-     * Microcode Default Value' section below.
-     */
-    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
-    AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1, scsi_cfg1 | DIS_TERM_DRV);
-
-    /*
-     * If the PCI Configuration Command Register "Parity Error Response
-     * Control" Bit was clear (0), then set the microcode variable
-     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
-     * to ignore DMA parity errors.
-     */
-    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-        word |= CONTROL_FLAG_IGNORE_PERR;
-        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-    }
-
-    /*
-     * If the BIOS control flag AIPP (Asynchronous Information
-     * Phase Protection) disable bit is not set, then set the firmware
-     * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable
-     * AIPP checking and encoding.
-     */
-    if ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-        word |= CONTROL_FLAG_ENABLE_AIPP;
-        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
-    }
-
-    /*
-     * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],
-     * and START_CTL_TH [3:2].
-     */
-    AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
-        FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
-
-    /*
-     * Microcode operating variables for WDTR, SDTR, and command tag
-     * queuing will be set in AdvInquiryHandling() based on what a
-     * device reports it is capable of in Inquiry byte 7.
-     *
-     * If SCSI Bus Resets have been disabled, then directly set
-     * SDTR and WDTR from the EEPROM configuration. This will allow
-     * the BIOS and warm boot to work without a SCSI bus hang on
-     * the Inquiry caused by host and target mismatched DTR values.
-     * Without the SCSI Bus Reset, before an Inquiry a device can't
-     * be assumed to be in Asynchronous, Narrow mode.
-     */
-    if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, asc_dvc->wdtr_able);
-        AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, asc_dvc->sdtr_able);
-    }
-
-    /*
-     * Set microcode operating variables for DISC and SDTR_SPEED1,
-     * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
-     * configuration values.
-     *
-     * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
-     * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
-     * without determining here whether the device supports SDTR.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
-
-    /*
-     * Set SCSI_CFG0 Microcode Default Value.
-     *
-     * The microcode will set the SCSI_CFG0 register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
-        PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
-        asc_dvc->chip_scsi_id);
-
-    /*
-     * Calculate SCSI_CFG1 Microcode Default Value.
-     *
-     * The microcode will set the SCSI_CFG1 register using this value
-     * after it is started below.
-     *
-     * Each ASC-38C1600 function has only two cable detect bits.
-     * The bus mode override bits are in IOPB_SOFT_OVER_WR.
-     */
-    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
-
-    /*
-     * If the cable is reversed all of the SCSI_CTRL register signals
-     * will be set. Check for and return an error if this condition is
-     * found.
-     */
-    if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
-    {
-        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
-        return ADV_ERROR;
-    }
-
-    /*
-     * Each ASC-38C1600 function has two connectors. Only an HVD device
-     * can not be connected to either connector. An LVD device or SE device
-     * may be connected to either connecor. If an SE device is connected,
-     * then at most Ultra speed (20 Mhz) can be used on both connectors.
-     *
-     * If an HVD device is attached, return an error.
-     */
-    if (scsi_cfg1 & HVD)
-    {
-        asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
-        return ADV_ERROR;
-    }
-
-    /*
-     * Each function in the ASC-38C1600 uses only the SE cable detect and
-     * termination because there are two connectors for each function. Each
-     * function may use either LVD or SE mode. Corresponding the SE automatic
-     * termination control EEPROM bits are used for each function. Each
-     * function has its own EEPROM. If SE automatic control is enabled for
-     * the function, then set the termination value based on a table listed
-     * in a_condor.h.
-     *
-     * If manual termination is specified in the EEPROM for the function,
-     * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is
-     * ready to be 'ored' into SCSI_CFG1.
-     */
-    if ((asc_dvc->cfg->termination & TERM_SE) == 0)
-    {
-        /* SE automatic termination control is enabled. */
-        switch(scsi_cfg1 & C_DET_SE)
-        {
-            /* TERM_SE_HI: on, TERM_SE_LO: on */
-            case 0x1: case 0x2: case 0x3:
-                asc_dvc->cfg->termination |= TERM_SE;
-                break;
-
-            case 0x0:
-                if (ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) == 0)
-                {
-                    /* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
-                }
-                else
-                {
-                    /* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
-                    asc_dvc->cfg->termination |= TERM_SE_HI;
-                }
-                break;
-        }
-    }
-
-    /*
-     * Clear any set TERM_SE bits.
-     */
-    scsi_cfg1 &= ~TERM_SE;
-
-    /*
-     * Invert the TERM_SE bits and then set 'scsi_cfg1'.
-     */
-    scsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);
-
-    /*
-     * Clear Big Endian and Terminator Polarity bits and set possibly
-     * modified termination control bits in the Microcode SCSI_CFG1
-     * Register Value.
-     *
-     * Big Endian bit is not used even on big endian machines.
-     */
-    scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);
-
-    /*
-     * Set SCSI_CFG1 Microcode Default Value
-     *
-     * Set possibly modified termination control bits in the Microcode
-     * SCSI_CFG1 Register Value.
-     *
-     * The microcode will set the SCSI_CFG1 register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
-
-    /*
-     * Set MEM_CFG Microcode Default Value
-     *
-     * The microcode will set the MEM_CFG register using this value
-     * after it is started below.
-     *
-     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
-     * are defined.
-     *
-     * ASC-38C1600 has 32KB internal memory.
-     *
-     * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come
-     * out a special 16K Adv Library and Microcode version. After the issue
-     * resolved, we should turn back to the 32K support. Both a_condor.h and
-     * mcode.sas files also need to be updated.
-     *
-     * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
-     *  BIOS_EN | RAM_SZ_32KB);
-     */
-     AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG, BIOS_EN | RAM_SZ_16KB);
-
-    /*
-     * Set SEL_MASK Microcode Default Value
-     *
-     * The microcode will set the SEL_MASK register using this value
-     * after it is started below.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
-        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
-
-    /*
-     * Build the carrier freelist.
-     *
-     * Driver must have already allocated memory and set 'carrier_buf'.
-     */
-
-    ASC_ASSERT(asc_dvc->carrier_buf != NULL);
-
-    carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
-    asc_dvc->carr_freelist = NULL;
-    if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf)
-    {
-        buf_size = ADV_CARRIER_BUFSIZE;
-    } else
-    {
-        buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
-    }
-
-    do {
-        /*
-         * Get physical address for the carrier 'carrp'.
-         */
-        contig_len = sizeof(ADV_CARR_T);
-        carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL, (uchar *) carrp,
-            (ADV_SDCNT *) &contig_len, ADV_IS_CARRIER_FLAG));
-
-        buf_size -= sizeof(ADV_CARR_T);
-
-        /*
-         * If the current carrier is not physically contiguous, then
-         * maybe there was a page crossing. Try the next carrier aligned
-         * start address.
-         */
-        if (contig_len < sizeof(ADV_CARR_T))
-        {
-            carrp++;
-            continue;
-        }
-
-        carrp->carr_pa = carr_paddr;
-        carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
-
-        /*
-         * Insert the carrier at the beginning of the freelist.
-         */
-        carrp->next_vpa = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-        asc_dvc->carr_freelist = carrp;
-
-        carrp++;
-    }
-    while (buf_size > 0);
-
-    /*
-     * Set-up the Host->RISC Initiator Command Queue (ICQ).
-     */
-    if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL)
-    {
-        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-        return ADV_ERROR;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
-
-    /*
-     * The first command issued will be placed in the stopper carrier.
-     */
-    asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
-
-    /*
-     * Set RISC ICQ physical address start value. Initialize the
-     * COMMA register to the same value otherwise the RISC will
-     * prematurely detect a command is available.
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
-    AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
-        le32_to_cpu(asc_dvc->icq_sp->carr_pa));
-
-    /*
-     * Set-up the RISC->Host Initiator Response Queue (IRQ).
-     */
-    if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL)
-    {
-        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
-        return ADV_ERROR;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
-
-    /*
-     * The first command completed by the RISC will be placed in
-     * the stopper.
-     *
-     * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
-     * completed the RISC will set the ASC_RQ_STOPPER bit.
-     */
-    asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
-
-    /*
-     * Set RISC IRQ physical address start value.
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
-    asc_dvc->carr_pending_cnt = 0;
-
-    AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
-        (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
-    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
-    AdvWriteWordRegister(iop_base, IOPW_PC, word);
-
-    /* finally, finally, gentlemen, start your engine */
-    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
-
-    /*
-     * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
-     * Resets should be performed. The RISC has to be running
-     * to issue a SCSI Bus Reset.
-     */
-    if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
-    {
-        /*
-         * If the BIOS Signature is present in memory, restore the
-         * per TID microcode operating variables.
-         */
-        if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
-        {
-            /*
-             * Restore per TID negotiated values.
-             */
-            AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-            for (tid = 0; tid <= ASC_MAX_TID; tid++)
-            {
-                AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-                    max_cmd[tid]);
-            }
-        } else
-        {
-            if (AdvResetSB(asc_dvc) != ADV_TRUE)
-            {
-                warn_code = ASC_WARN_BUSRESET_ERROR;
-            }
-        }
-    }
-
-    return warn_code;
-}
-
-/*
- * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
- * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
- * all of this is done.
- *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
- *
- * Note: Chip is stopped on entry.
- */
-STATIC int __init
-AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
-{
-    AdvPortAddr         iop_base;
-    ushort              warn_code;
-    ADVEEP_3550_CONFIG  eep_config;
-    int                 i;
-
-    iop_base = asc_dvc->iop_base;
-
-    warn_code = 0;
-
-    /*
-     * Read the board's EEPROM configuration.
-     *
-     * Set default values if a bad checksum is found.
-     */
-    if (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum)
-    {
-        warn_code |= ASC_WARN_EEPROM_CHKSUM;
-
-        /*
-         * Set EEPROM default values.
-         */
-        for (i = 0; i < sizeof(ADVEEP_3550_CONFIG); i++)
-        {
-            *((uchar *) &eep_config + i) =
-                *((uchar *) &Default_3550_EEPROM_Config + i);
-        }
-
-        /*
-         * Assume the 6 byte board serial number that was read
-         * from EEPROM is correct even if the EEPROM checksum
-         * failed.
-         */
-        eep_config.serial_number_word3 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
-
-        eep_config.serial_number_word2 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
-
-        eep_config.serial_number_word1 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
-
-        AdvSet3550EEPConfig(iop_base, &eep_config);
-    }
-    /*
-     * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
-     * EEPROM configuration that was read.
-     *
-     * This is the mapping of EEPROM fields to Adv Library fields.
-     */
-    asc_dvc->wdtr_able = eep_config.wdtr_able;
-    asc_dvc->sdtr_able = eep_config.sdtr_able;
-    asc_dvc->ultra_able = eep_config.ultra_able;
-    asc_dvc->tagqng_able = eep_config.tagqng_able;
-    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
-    asc_dvc->max_host_qng = eep_config.max_host_qng;
-    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
-    asc_dvc->start_motor = eep_config.start_motor;
-    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
-    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
-    asc_dvc->no_scam = eep_config.scam_tolerant;
-    asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
-    asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
-    asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
-
-    /*
-     * Set the host maximum queuing (max. 253, min. 16) and the per device
-     * maximum queuing (max. 63, min. 4).
-     */
-    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
-    {
-        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
-    {
-        /* If the value is zero, assume it is uninitialized. */
-        if (eep_config.max_host_qng == 0)
-        {
-            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-        } else
-        {
-            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
-        }
-    }
-
-    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
-    {
-        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
-    {
-        /* If the value is zero, assume it is uninitialized. */
-        if (eep_config.max_dvc_qng == 0)
-        {
-            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-        } else
-        {
-            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
-        }
-    }
-
-    /*
-     * If 'max_dvc_qng' is greater than 'max_host_qng', then
-     * set 'max_dvc_qng' to 'max_host_qng'.
-     */
-    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
-    {
-        eep_config.max_dvc_qng = eep_config.max_host_qng;
-    }
-
-    /*
-     * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
-     * values based on possibly adjusted EEPROM values.
-     */
-    asc_dvc->max_host_qng = eep_config.max_host_qng;
-    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-
-
-    /*
-     * If the EEPROM 'termination' field is set to automatic (0), then set
-     * the ADV_DVC_CFG 'termination' field to automatic also.
-     *
-     * If the termination is specified with a non-zero 'termination'
-     * value check that a legal value is set and set the ADV_DVC_CFG
-     * 'termination' field appropriately.
-     */
-    if (eep_config.termination == 0)
-    {
-        asc_dvc->cfg->termination = 0;    /* auto termination */
-    } else
-    {
-        /* Enable manual control with low off / high off. */
-        if (eep_config.termination == 1)
-        {
-            asc_dvc->cfg->termination = TERM_CTL_SEL;
-
-        /* Enable manual control with low off / high on. */
-        } else if (eep_config.termination == 2)
-        {
-            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;
-
-        /* Enable manual control with low on / high on. */
-        } else if (eep_config.termination == 3)
-        {
-            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
-        } else
-        {
-            /*
-             * The EEPROM 'termination' field contains a bad value. Use
-             * automatic termination instead.
-             */
-            asc_dvc->cfg->termination = 0;
-            warn_code |= ASC_WARN_EEPROM_TERMINATION;
-        }
-    }
-
-    return warn_code;
-}
-
-/*
- * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
- * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
- * all of this is done.
- *
- * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
- *
- * Note: Chip is stopped on entry.
- */
-STATIC int __init
-AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
-{
-    AdvPortAddr              iop_base;
-    ushort                   warn_code;
-    ADVEEP_38C0800_CONFIG    eep_config;
-    int                      i;
-    uchar                    tid, termination;
-    ushort                   sdtr_speed = 0;
-
-    iop_base = asc_dvc->iop_base;
-
-    warn_code = 0;
-
-    /*
-     * Read the board's EEPROM configuration.
-     *
-     * Set default values if a bad checksum is found.
-     */
-    if (AdvGet38C0800EEPConfig(iop_base, &eep_config) != eep_config.check_sum)
-    {
-        warn_code |= ASC_WARN_EEPROM_CHKSUM;
-
-        /*
-         * Set EEPROM default values.
-         */
-        for (i = 0; i < sizeof(ADVEEP_38C0800_CONFIG); i++)
-        {
-            *((uchar *) &eep_config + i) =
-                *((uchar *) &Default_38C0800_EEPROM_Config + i);
-        }
-
-        /*
-         * Assume the 6 byte board serial number that was read
-         * from EEPROM is correct even if the EEPROM checksum
-         * failed.
-         */
-        eep_config.serial_number_word3 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
-
-        eep_config.serial_number_word2 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
-
-        eep_config.serial_number_word1 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
-
-        AdvSet38C0800EEPConfig(iop_base, &eep_config);
-    }
-    /*
-     * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the
-     * EEPROM configuration that was read.
-     *
-     * This is the mapping of EEPROM fields to Adv Library fields.
-     */
-    asc_dvc->wdtr_able = eep_config.wdtr_able;
-    asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
-    asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
-    asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
-    asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
-    asc_dvc->tagqng_able = eep_config.tagqng_able;
-    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
-    asc_dvc->max_host_qng = eep_config.max_host_qng;
-    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
-    asc_dvc->start_motor = eep_config.start_motor;
-    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
-    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
-    asc_dvc->no_scam = eep_config.scam_tolerant;
-    asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
-    asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
-    asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
-
-    /*
-     * For every Target ID if any of its 'sdtr_speed[1234]' bits
-     * are set, then set an 'sdtr_able' bit for it.
-     */
-    asc_dvc->sdtr_able = 0;
-    for (tid = 0; tid <= ADV_MAX_TID; tid++)
-    {
-        if (tid == 0)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed1;
-        } else if (tid == 4)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed2;
-        } else if (tid == 8)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed3;
-        } else if (tid == 12)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed4;
-        }
-        if (sdtr_speed & ADV_MAX_TID)
-        {
-            asc_dvc->sdtr_able |= (1 << tid);
-        }
-        sdtr_speed >>= 4;
-    }
-
-    /*
-     * Set the host maximum queuing (max. 253, min. 16) and the per device
-     * maximum queuing (max. 63, min. 4).
-     */
-    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
-    {
-        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
-    {
-        /* If the value is zero, assume it is uninitialized. */
-        if (eep_config.max_host_qng == 0)
-        {
-            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-        } else
-        {
-            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
-        }
-    }
-
-    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
-    {
-        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
-    {
-        /* If the value is zero, assume it is uninitialized. */
-        if (eep_config.max_dvc_qng == 0)
-        {
-            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-        } else
-        {
-            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
-        }
-    }
-
-    /*
-     * If 'max_dvc_qng' is greater than 'max_host_qng', then
-     * set 'max_dvc_qng' to 'max_host_qng'.
-     */
-    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
-    {
-        eep_config.max_dvc_qng = eep_config.max_host_qng;
-    }
-
-    /*
-     * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
-     * values based on possibly adjusted EEPROM values.
-     */
-    asc_dvc->max_host_qng = eep_config.max_host_qng;
-    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-
-    /*
-     * If the EEPROM 'termination' field is set to automatic (0), then set
-     * the ADV_DVC_CFG 'termination' field to automatic also.
-     *
-     * If the termination is specified with a non-zero 'termination'
-     * value check that a legal value is set and set the ADV_DVC_CFG
-     * 'termination' field appropriately.
-     */
-    if (eep_config.termination_se == 0)
-    {
-        termination = 0;                         /* auto termination for SE */
-    } else
-    {
-        /* Enable manual control with low off / high off. */
-        if (eep_config.termination_se == 1)
-        {
-            termination = 0;
-
-        /* Enable manual control with low off / high on. */
-        } else if (eep_config.termination_se == 2)
-        {
-            termination = TERM_SE_HI;
-
-        /* Enable manual control with low on / high on. */
-        } else if (eep_config.termination_se == 3)
-        {
-            termination = TERM_SE;
-        } else
-        {
-            /*
-             * The EEPROM 'termination_se' field contains a bad value.
-             * Use automatic termination instead.
-             */
-            termination = 0;
-            warn_code |= ASC_WARN_EEPROM_TERMINATION;
-        }
-    }
-
-    if (eep_config.termination_lvd == 0)
-    {
-        asc_dvc->cfg->termination = termination; /* auto termination for LVD */
-    } else
-    {
-        /* Enable manual control with low off / high off. */
-        if (eep_config.termination_lvd == 1)
-        {
-            asc_dvc->cfg->termination = termination;
-
-        /* Enable manual control with low off / high on. */
-        } else if (eep_config.termination_lvd == 2)
-        {
-            asc_dvc->cfg->termination = termination | TERM_LVD_HI;
-
-        /* Enable manual control with low on / high on. */
-        } else if (eep_config.termination_lvd == 3)
-        {
-            asc_dvc->cfg->termination =
-                termination | TERM_LVD;
-        } else
-        {
-            /*
-             * The EEPROM 'termination_lvd' field contains a bad value.
-             * Use automatic termination instead.
-             */
-            asc_dvc->cfg->termination = termination;
-            warn_code |= ASC_WARN_EEPROM_TERMINATION;
-        }
-    }
-
-    return warn_code;
-}
-
-/*
- * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and
- * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
- * all of this is done.
- *
- * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
- *
- * For a non-fatal error return a warning code. If there are no warnings
- * then 0 is returned.
- *
- * Note: Chip is stopped on entry.
- */
-STATIC int __init
-AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
-{
-    AdvPortAddr              iop_base;
-    ushort                   warn_code;
-    ADVEEP_38C1600_CONFIG    eep_config;
-    int                      i;
-    uchar                    tid, termination;
-    ushort                   sdtr_speed = 0;
+	AdvPortAddr iop_base;
+	ushort warn_code;
+	ADVEEP_38C1600_CONFIG eep_config;
+	int i;
+	uchar tid, termination;
+	ushort sdtr_speed = 0;
+
+	iop_base = asc_dvc->iop_base;
+
+	warn_code = 0;
+
+	/*
+	 * Read the board's EEPROM configuration.
+	 *
+	 * Set default values if a bad checksum is found.
+	 */
+	if (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=
+	    eep_config.check_sum) {
+		warn_code |= ASC_WARN_EEPROM_CHKSUM;
 
-    iop_base = asc_dvc->iop_base;
+		/*
+		 * Set EEPROM default values.
+		 */
+		for (i = 0; i < sizeof(ADVEEP_38C1600_CONFIG); i++) {
+			if (i == 1
+			    && ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) !=
+			    0) {
+				/*
+				 * Set Function 1 EEPROM Word 0 MSB
+				 *
+				 * Clear the BIOS_ENABLE (bit 14) and INTAB (bit 11)
+				 * EEPROM bits.
+				 *
+				 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60 and
+				 * old Mac system booting problem. The Expansion ROM must
+				 * be disabled in Function 1 for these systems.
+				 *
+				 */
+				*((uchar *)&eep_config + i) =
+				    ((*
+				      ((uchar *)&Default_38C1600_EEPROM_Config
+				       +
+				       i)) &
+				     (~
+				      (((ADV_EEPROM_BIOS_ENABLE |
+					 ADV_EEPROM_INTAB) >> 8) & 0xFF)));
+
+				/*
+				 * Set the INTAB (bit 11) if the GPIO 0 input indicates
+				 * the Function 1 interrupt line is wired to INTA.
+				 *
+				 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
+				 *   1 - Function 1 interrupt line wired to INT A.
+				 *   0 - Function 1 interrupt line wired to INT B.
+				 *
+				 * Note: Adapter boards always have Function 0 wired to INTA.
+				 * Put all 5 GPIO bits in input mode and then read
+				 * their input values.
+				 */
+				AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL,
+						     0);
+				if (AdvReadByteRegister
+				    (iop_base, IOPB_GPIO_DATA) & 0x01) {
+					/* Function 1 interrupt wired to INTA; Set EEPROM bit. */
+					*((uchar *)&eep_config + i) |=
+					    ((ADV_EEPROM_INTAB >> 8) & 0xFF);
+				}
+			} else {
+				*((uchar *)&eep_config + i) =
+				    *((uchar *)&Default_38C1600_EEPROM_Config
+				      + i);
+			}
+		}
 
-    warn_code = 0;
+		/*
+		 * Assume the 6 byte board serial number that was read
+		 * from EEPROM is correct even if the EEPROM checksum
+		 * failed.
+		 */
+		eep_config.serial_number_word3 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
 
-    /*
-     * Read the board's EEPROM configuration.
-     *
-     * Set default values if a bad checksum is found.
-     */
-    if (AdvGet38C1600EEPConfig(iop_base, &eep_config) != eep_config.check_sum)
-    {
-        warn_code |= ASC_WARN_EEPROM_CHKSUM;
-
-        /*
-         * Set EEPROM default values.
-         */
-        for (i = 0; i < sizeof(ADVEEP_38C1600_CONFIG); i++)
-        {
-            if (i == 1 && ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) != 0)
-            {
-                /*
-                 * Set Function 1 EEPROM Word 0 MSB
-                 *
-                 * Clear the BIOS_ENABLE (bit 14) and INTAB (bit 11)
-                 * EEPROM bits.
-                 *
-                 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60 and
-                 * old Mac system booting problem. The Expansion ROM must
-                 * be disabled in Function 1 for these systems.
-                 *
-                 */
-                *((uchar *) &eep_config + i) =
-                ((*((uchar *) &Default_38C1600_EEPROM_Config + i)) &
-                    (~(((ADV_EEPROM_BIOS_ENABLE | ADV_EEPROM_INTAB) >> 8) &
-                     0xFF)));
-
-                /*
-                 * Set the INTAB (bit 11) if the GPIO 0 input indicates
-                 * the Function 1 interrupt line is wired to INTA.
-                 *
-                 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
-                 *   1 - Function 1 interrupt line wired to INT A.
-                 *   0 - Function 1 interrupt line wired to INT B.
-                 *
-                 * Note: Adapter boards always have Function 0 wired to INTA.
-                 * Put all 5 GPIO bits in input mode and then read
-                 * their input values.
-                 */
-                AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);
-                if (AdvReadByteRegister(iop_base, IOPB_GPIO_DATA) & 0x01)
-                {
-                    /* Function 1 interrupt wired to INTA; Set EEPROM bit. */
-                *((uchar *) &eep_config + i) |=
-                    ((ADV_EEPROM_INTAB >> 8) & 0xFF);
-                }
-            }
-            else
-            {
-                *((uchar *) &eep_config + i) =
-                *((uchar *) &Default_38C1600_EEPROM_Config + i);
-            }
-        }
-
-        /*
-         * Assume the 6 byte board serial number that was read
-         * from EEPROM is correct even if the EEPROM checksum
-         * failed.
-         */
-        eep_config.serial_number_word3 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
-
-        eep_config.serial_number_word2 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
-
-        eep_config.serial_number_word1 =
-            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
-
-        AdvSet38C1600EEPConfig(iop_base, &eep_config);
-    }
+		eep_config.serial_number_word2 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
 
-    /*
-     * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
-     * EEPROM configuration that was read.
-     *
-     * This is the mapping of EEPROM fields to Adv Library fields.
-     */
-    asc_dvc->wdtr_able = eep_config.wdtr_able;
-    asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
-    asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
-    asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
-    asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
-    asc_dvc->ppr_able = 0;
-    asc_dvc->tagqng_able = eep_config.tagqng_able;
-    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
-    asc_dvc->max_host_qng = eep_config.max_host_qng;
-    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
-    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
-    asc_dvc->start_motor = eep_config.start_motor;
-    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
-    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
-    asc_dvc->no_scam = eep_config.scam_tolerant;
+		eep_config.serial_number_word1 =
+		    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
 
-    /*
-     * For every Target ID if any of its 'sdtr_speed[1234]' bits
-     * are set, then set an 'sdtr_able' bit for it.
-     */
-    asc_dvc->sdtr_able = 0;
-    for (tid = 0; tid <= ASC_MAX_TID; tid++)
-    {
-        if (tid == 0)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed1;
-        } else if (tid == 4)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed2;
-        } else if (tid == 8)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed3;
-        } else if (tid == 12)
-        {
-            sdtr_speed = asc_dvc->sdtr_speed4;
-        }
-        if (sdtr_speed & ASC_MAX_TID)
-        {
-            asc_dvc->sdtr_able |= (1 << tid);
-        }
-        sdtr_speed >>= 4;
-    }
+		AdvSet38C1600EEPConfig(iop_base, &eep_config);
+	}
 
-    /*
-     * Set the host maximum queuing (max. 253, min. 16) and the per device
-     * maximum queuing (max. 63, min. 4).
-     */
-    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
-    {
-        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
-    {
-        /* If the value is zero, assume it is uninitialized. */
-        if (eep_config.max_host_qng == 0)
-        {
-            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
-        } else
-        {
-            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
-        }
-    }
+	/*
+	 * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
+	 * EEPROM configuration that was read.
+	 *
+	 * This is the mapping of EEPROM fields to Adv Library fields.
+	 */
+	asc_dvc->wdtr_able = eep_config.wdtr_able;
+	asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
+	asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
+	asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
+	asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
+	asc_dvc->ppr_able = 0;
+	asc_dvc->tagqng_able = eep_config.tagqng_able;
+	asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
+	asc_dvc->start_motor = eep_config.start_motor;
+	asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+	asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+	asc_dvc->no_scam = eep_config.scam_tolerant;
+
+	/*
+	 * For every Target ID if any of its 'sdtr_speed[1234]' bits
+	 * are set, then set an 'sdtr_able' bit for it.
+	 */
+	asc_dvc->sdtr_able = 0;
+	for (tid = 0; tid <= ASC_MAX_TID; tid++) {
+		if (tid == 0) {
+			sdtr_speed = asc_dvc->sdtr_speed1;
+		} else if (tid == 4) {
+			sdtr_speed = asc_dvc->sdtr_speed2;
+		} else if (tid == 8) {
+			sdtr_speed = asc_dvc->sdtr_speed3;
+		} else if (tid == 12) {
+			sdtr_speed = asc_dvc->sdtr_speed4;
+		}
+		if (sdtr_speed & ASC_MAX_TID) {
+			asc_dvc->sdtr_able |= (1 << tid);
+		}
+		sdtr_speed >>= 4;
+	}
 
-    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
-    {
-        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
-    {
-        /* If the value is zero, assume it is uninitialized. */
-        if (eep_config.max_dvc_qng == 0)
-        {
-            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
-        } else
-        {
-            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
-        }
-    }
+	/*
+	 * Set the host maximum queuing (max. 253, min. 16) and the per device
+	 * maximum queuing (max. 63, min. 4).
+	 */
+	if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {
+		eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+	} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_host_qng == 0) {
+			eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+		} else {
+			eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+		}
+	}
 
-    /*
-     * If 'max_dvc_qng' is greater than 'max_host_qng', then
-     * set 'max_dvc_qng' to 'max_host_qng'.
-     */
-    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
-    {
-        eep_config.max_dvc_qng = eep_config.max_host_qng;
-    }
+	if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {
+		eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+	} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {
+		/* If the value is zero, assume it is uninitialized. */
+		if (eep_config.max_dvc_qng == 0) {
+			eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+		} else {
+			eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+		}
+	}
 
-    /*
-     * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'
-     * values based on possibly adjusted EEPROM values.
-     */
-    asc_dvc->max_host_qng = eep_config.max_host_qng;
-    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+	/*
+	 * If 'max_dvc_qng' is greater than 'max_host_qng', then
+	 * set 'max_dvc_qng' to 'max_host_qng'.
+	 */
+	if (eep_config.max_dvc_qng > eep_config.max_host_qng) {
+		eep_config.max_dvc_qng = eep_config.max_host_qng;
+	}
 
-    /*
-     * If the EEPROM 'termination' field is set to automatic (0), then set
-     * the ASC_DVC_CFG 'termination' field to automatic also.
-     *
-     * If the termination is specified with a non-zero 'termination'
-     * value check that a legal value is set and set the ASC_DVC_CFG
-     * 'termination' field appropriately.
-     */
-    if (eep_config.termination_se == 0)
-    {
-        termination = 0;                         /* auto termination for SE */
-    } else
-    {
-        /* Enable manual control with low off / high off. */
-        if (eep_config.termination_se == 1)
-        {
-            termination = 0;
-
-        /* Enable manual control with low off / high on. */
-        } else if (eep_config.termination_se == 2)
-        {
-            termination = TERM_SE_HI;
-
-        /* Enable manual control with low on / high on. */
-        } else if (eep_config.termination_se == 3)
-        {
-            termination = TERM_SE;
-        } else
-        {
-            /*
-             * The EEPROM 'termination_se' field contains a bad value.
-             * Use automatic termination instead.
-             */
-            termination = 0;
-            warn_code |= ASC_WARN_EEPROM_TERMINATION;
-        }
-    }
+	/*
+	 * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'
+	 * values based on possibly adjusted EEPROM values.
+	 */
+	asc_dvc->max_host_qng = eep_config.max_host_qng;
+	asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+	/*
+	 * If the EEPROM 'termination' field is set to automatic (0), then set
+	 * the ASC_DVC_CFG 'termination' field to automatic also.
+	 *
+	 * If the termination is specified with a non-zero 'termination'
+	 * value check that a legal value is set and set the ASC_DVC_CFG
+	 * 'termination' field appropriately.
+	 */
+	if (eep_config.termination_se == 0) {
+		termination = 0;	/* auto termination for SE */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_se == 1) {
+			termination = 0;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_se == 2) {
+			termination = TERM_SE_HI;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_se == 3) {
+			termination = TERM_SE;
+		} else {
+			/*
+			 * The EEPROM 'termination_se' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			termination = 0;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
+	}
 
-    if (eep_config.termination_lvd == 0)
-    {
-        asc_dvc->cfg->termination = termination; /* auto termination for LVD */
-    } else
-    {
-        /* Enable manual control with low off / high off. */
-        if (eep_config.termination_lvd == 1)
-        {
-            asc_dvc->cfg->termination = termination;
-
-        /* Enable manual control with low off / high on. */
-        } else if (eep_config.termination_lvd == 2)
-        {
-            asc_dvc->cfg->termination = termination | TERM_LVD_HI;
-
-        /* Enable manual control with low on / high on. */
-        } else if (eep_config.termination_lvd == 3)
-        {
-            asc_dvc->cfg->termination =
-                termination | TERM_LVD;
-        } else
-        {
-            /*
-             * The EEPROM 'termination_lvd' field contains a bad value.
-             * Use automatic termination instead.
-             */
-            asc_dvc->cfg->termination = termination;
-            warn_code |= ASC_WARN_EEPROM_TERMINATION;
-        }
-    }
+	if (eep_config.termination_lvd == 0) {
+		asc_dvc->cfg->termination = termination;	/* auto termination for LVD */
+	} else {
+		/* Enable manual control with low off / high off. */
+		if (eep_config.termination_lvd == 1) {
+			asc_dvc->cfg->termination = termination;
+
+			/* Enable manual control with low off / high on. */
+		} else if (eep_config.termination_lvd == 2) {
+			asc_dvc->cfg->termination = termination | TERM_LVD_HI;
+
+			/* Enable manual control with low on / high on. */
+		} else if (eep_config.termination_lvd == 3) {
+			asc_dvc->cfg->termination = termination | TERM_LVD;
+		} else {
+			/*
+			 * The EEPROM 'termination_lvd' field contains a bad value.
+			 * Use automatic termination instead.
+			 */
+			asc_dvc->cfg->termination = termination;
+			warn_code |= ASC_WARN_EEPROM_TERMINATION;
+		}
+	}
 
-    return warn_code;
+	return warn_code;
 }
 
 /*
@@ -17049,45 +16733,42 @@ AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-STATIC ushort __init
+static ushort __init
 AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
-    ushort              wval, chksum;
-    ushort              *wbuf;
-    int                 eep_addr;
-    ushort              *charfields;
-
-    charfields = (ushort *) &ADVEEP_3550_Config_Field_IsChar;
-    wbuf = (ushort *) cfg_buf;
-    chksum = 0;
-
-    for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
-         eep_addr < ADV_EEP_DVC_CFG_END;
-         eep_addr++, wbuf++)
-    {
-        wval = AdvReadEEPWord(iop_base, eep_addr);
-        chksum += wval; /* Checksum is calculated from word values. */
-        if (*charfields++) {
-            *wbuf = le16_to_cpu(wval);
-        } else {
-            *wbuf = wval;
-        }
-    }
-    /* Read checksum word. */
-    *wbuf = AdvReadEEPWord(iop_base, eep_addr);
-    wbuf++; charfields++;
-
-    /* Read rest of EEPROM not covered by the checksum. */
-    for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
-         eep_addr < ADV_EEP_MAX_WORD_ADDR;
-         eep_addr++, wbuf++)
-    {
-        *wbuf = AdvReadEEPWord(iop_base, eep_addr);
-        if (*charfields++) {
-            *wbuf = le16_to_cpu(*wbuf);
-        }
-    }
-    return chksum;
+	ushort wval, chksum;
+	ushort *wbuf;
+	int eep_addr;
+	ushort *charfields;
+
+	charfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;
+	wbuf = (ushort *)cfg_buf;
+	chksum = 0;
+
+	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
+		wval = AdvReadEEPWord(iop_base, eep_addr);
+		chksum += wval;	/* Checksum is calculated from word values. */
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(wval);
+		} else {
+			*wbuf = wval;
+		}
+	}
+	/* Read checksum word. */
+	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+	wbuf++;
+	charfields++;
+
+	/* Read rest of EEPROM not covered by the checksum. */
+	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
+		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(*wbuf);
+		}
+	}
+	return chksum;
 }
 
 /*
@@ -17095,46 +16776,42 @@ AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-STATIC ushort __init
-AdvGet38C0800EEPConfig(AdvPortAddr iop_base,
-                       ADVEEP_38C0800_CONFIG *cfg_buf)
+static ushort __init
+AdvGet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 {
-    ushort              wval, chksum;
-    ushort              *wbuf;
-    int                 eep_addr;
-    ushort              *charfields;
-
-    charfields = (ushort *) &ADVEEP_38C0800_Config_Field_IsChar;
-    wbuf = (ushort *) cfg_buf;
-    chksum = 0;
-
-    for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
-         eep_addr < ADV_EEP_DVC_CFG_END;
-         eep_addr++, wbuf++)
-    {
-        wval = AdvReadEEPWord(iop_base, eep_addr);
-        chksum += wval; /* Checksum is calculated from word values. */
-        if (*charfields++) {
-            *wbuf = le16_to_cpu(wval);
-        } else {
-            *wbuf = wval;
-        }
-    }
-    /* Read checksum word. */
-    *wbuf = AdvReadEEPWord(iop_base, eep_addr);
-    wbuf++; charfields++;
-
-    /* Read rest of EEPROM not covered by the checksum. */
-    for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
-         eep_addr < ADV_EEP_MAX_WORD_ADDR;
-         eep_addr++, wbuf++)
-    {
-        *wbuf = AdvReadEEPWord(iop_base, eep_addr);
-        if (*charfields++) {
-            *wbuf = le16_to_cpu(*wbuf);
-        }
-    }
-    return chksum;
+	ushort wval, chksum;
+	ushort *wbuf;
+	int eep_addr;
+	ushort *charfields;
+
+	charfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;
+	wbuf = (ushort *)cfg_buf;
+	chksum = 0;
+
+	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
+		wval = AdvReadEEPWord(iop_base, eep_addr);
+		chksum += wval;	/* Checksum is calculated from word values. */
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(wval);
+		} else {
+			*wbuf = wval;
+		}
+	}
+	/* Read checksum word. */
+	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+	wbuf++;
+	charfields++;
+
+	/* Read rest of EEPROM not covered by the checksum. */
+	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
+		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(*wbuf);
+		}
+	}
+	return chksum;
 }
 
 /*
@@ -17142,81 +16819,74 @@ AdvGet38C0800EEPConfig(AdvPortAddr iop_base,
  *
  * Return a checksum based on the EEPROM configuration read.
  */
-STATIC ushort __init
-AdvGet38C1600EEPConfig(AdvPortAddr iop_base,
-                       ADVEEP_38C1600_CONFIG *cfg_buf)
+static ushort __init
+AdvGet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
-    ushort              wval, chksum;
-    ushort              *wbuf;
-    int                 eep_addr;
-    ushort              *charfields;
-
-    charfields = (ushort*) &ADVEEP_38C1600_Config_Field_IsChar;
-    wbuf = (ushort *) cfg_buf;
-    chksum = 0;
-
-    for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
-         eep_addr < ADV_EEP_DVC_CFG_END;
-         eep_addr++, wbuf++)
-    {
-        wval = AdvReadEEPWord(iop_base, eep_addr);
-        chksum += wval; /* Checksum is calculated from word values. */
-        if (*charfields++) {
-            *wbuf = le16_to_cpu(wval);
-        } else {
-            *wbuf = wval;
-        }
-    }
-    /* Read checksum word. */
-    *wbuf = AdvReadEEPWord(iop_base, eep_addr);
-    wbuf++; charfields++;
-
-    /* Read rest of EEPROM not covered by the checksum. */
-    for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
-         eep_addr < ADV_EEP_MAX_WORD_ADDR;
-         eep_addr++, wbuf++)
-    {
-        *wbuf = AdvReadEEPWord(iop_base, eep_addr);
-        if (*charfields++) {
-            *wbuf = le16_to_cpu(*wbuf);
-        }
-    }
-    return chksum;
+	ushort wval, chksum;
+	ushort *wbuf;
+	int eep_addr;
+	ushort *charfields;
+
+	charfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;
+	wbuf = (ushort *)cfg_buf;
+	chksum = 0;
+
+	for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+	     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {
+		wval = AdvReadEEPWord(iop_base, eep_addr);
+		chksum += wval;	/* Checksum is calculated from word values. */
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(wval);
+		} else {
+			*wbuf = wval;
+		}
+	}
+	/* Read checksum word. */
+	*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+	wbuf++;
+	charfields++;
+
+	/* Read rest of EEPROM not covered by the checksum. */
+	for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+	     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {
+		*wbuf = AdvReadEEPWord(iop_base, eep_addr);
+		if (*charfields++) {
+			*wbuf = le16_to_cpu(*wbuf);
+		}
+	}
+	return chksum;
 }
 
 /*
  * Read the EEPROM from specified location
  */
-STATIC ushort __init
-AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
+static ushort __init AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
 {
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
-        ASC_EEP_CMD_READ | eep_word_addr);
-    AdvWaitEEPCmd(iop_base);
-    return AdvReadWordRegister(iop_base, IOPW_EE_DATA);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+			     ASC_EEP_CMD_READ | eep_word_addr);
+	AdvWaitEEPCmd(iop_base);
+	return AdvReadWordRegister(iop_base, IOPW_EE_DATA);
 }
 
 /*
  * Wait for EEPROM command to complete
  */
-STATIC void __init
-AdvWaitEEPCmd(AdvPortAddr iop_base)
+static void __init AdvWaitEEPCmd(AdvPortAddr iop_base)
 {
-    int eep_delay_ms;
-
-    for (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++)
-    {
-        if (AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE)
-        {
-            break;
-        }
-        DvcSleepMilliSecond(1);
-    }
-    if ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) == 0)
-    {
-        ASC_ASSERT(0);
-    }
-    return;
+	int eep_delay_ms;
+
+	for (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++) {
+		if (AdvReadWordRegister(iop_base, IOPW_EE_CMD) &
+		    ASC_EEP_CMD_DONE) {
+			break;
+		}
+		DvcSleepMilliSecond(1);
+	}
+	if ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==
+	    0) {
+		ASC_ASSERT(0);
+	}
+	return;
 }
 
 /*
@@ -17225,201 +16895,202 @@ AdvWaitEEPCmd(AdvPortAddr iop_base)
 void __init
 AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
-    ushort *wbuf;
-    ushort addr, chksum;
-    ushort *charfields;
-
-    wbuf = (ushort *) cfg_buf;
-    charfields = (ushort *) &ADVEEP_3550_Config_Field_IsChar;
-    chksum = 0;
-
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
-    AdvWaitEEPCmd(iop_base);
-
-    /*
-     * Write EEPROM from word 0 to word 20.
-     */
-    for (addr = ADV_EEP_DVC_CFG_BEGIN;
-         addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++)
-    {
-        ushort word;
-
-        if (*charfields++) {
-            word = cpu_to_le16(*wbuf);
-        } else {
-            word = *wbuf;
-        }
-        chksum += *wbuf; /* Checksum is calculated from word values. */
-        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-        AdvWaitEEPCmd(iop_base);
-        DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
-    }
-
-    /*
-     * Write EEPROM checksum at word 21.
-     */
-    AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-    AdvWaitEEPCmd(iop_base);
-    wbuf++; charfields++;
+	ushort *wbuf;
+	ushort addr, chksum;
+	ushort *charfields;
+
+	wbuf = (ushort *)cfg_buf;
+	charfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;
+	chksum = 0;
+
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+	AdvWaitEEPCmd(iop_base);
+
+	/*
+	 * Write EEPROM from word 0 to word 20.
+	 */
+	for (addr = ADV_EEP_DVC_CFG_BEGIN;
+	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
+		ushort word;
+
+		if (*charfields++) {
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
+		}
+		chksum += *wbuf;	/* Checksum is calculated from word values. */
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+		DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+	}
 
-    /*
-     * Write EEPROM OEM name at words 22 to 29.
-     */
-    for (addr = ADV_EEP_DVC_CTL_BEGIN;
-         addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++)
-    {
-        ushort word;
-
-        if (*charfields++) {
-            word = cpu_to_le16(*wbuf);
-        } else {
-            word = *wbuf;
-        }
-        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-        AdvWaitEEPCmd(iop_base);
-    }
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
-    AdvWaitEEPCmd(iop_base);
-    return;
+	/*
+	 * Write EEPROM checksum at word 21.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+	AdvWaitEEPCmd(iop_base);
+	wbuf++;
+	charfields++;
+
+	/*
+	 * Write EEPROM OEM name at words 22 to 29.
+	 */
+	for (addr = ADV_EEP_DVC_CTL_BEGIN;
+	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
+		ushort word;
+
+		if (*charfields++) {
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
+		}
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+	}
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+	AdvWaitEEPCmd(iop_base);
+	return;
 }
 
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
 void __init
-AdvSet38C0800EEPConfig(AdvPortAddr iop_base,
-                       ADVEEP_38C0800_CONFIG *cfg_buf)
+AdvSet38C0800EEPConfig(AdvPortAddr iop_base, ADVEEP_38C0800_CONFIG *cfg_buf)
 {
-    ushort *wbuf;
-    ushort *charfields;
-    ushort addr, chksum;
-
-    wbuf = (ushort *) cfg_buf;
-    charfields = (ushort *) &ADVEEP_38C0800_Config_Field_IsChar;
-    chksum = 0;
-
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
-    AdvWaitEEPCmd(iop_base);
-
-    /*
-     * Write EEPROM from word 0 to word 20.
-     */
-    for (addr = ADV_EEP_DVC_CFG_BEGIN;
-         addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++)
-    {
-        ushort word;
-
-        if (*charfields++) {
-            word = cpu_to_le16(*wbuf);
-        } else {
-            word = *wbuf;
-        }
-        chksum += *wbuf; /* Checksum is calculated from word values. */
-        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-        AdvWaitEEPCmd(iop_base);
-        DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
-    }
-
-    /*
-     * Write EEPROM checksum at word 21.
-     */
-    AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-    AdvWaitEEPCmd(iop_base);
-    wbuf++; charfields++;
+	ushort *wbuf;
+	ushort *charfields;
+	ushort addr, chksum;
+
+	wbuf = (ushort *)cfg_buf;
+	charfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;
+	chksum = 0;
+
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+	AdvWaitEEPCmd(iop_base);
+
+	/*
+	 * Write EEPROM from word 0 to word 20.
+	 */
+	for (addr = ADV_EEP_DVC_CFG_BEGIN;
+	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
+		ushort word;
+
+		if (*charfields++) {
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
+		}
+		chksum += *wbuf;	/* Checksum is calculated from word values. */
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+		DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+	}
 
-    /*
-     * Write EEPROM OEM name at words 22 to 29.
-     */
-    for (addr = ADV_EEP_DVC_CTL_BEGIN;
-         addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++)
-    {
-        ushort word;
-
-        if (*charfields++) {
-            word = cpu_to_le16(*wbuf);
-        } else {
-            word = *wbuf;
-        }
-        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-        AdvWaitEEPCmd(iop_base);
-    }
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
-    AdvWaitEEPCmd(iop_base);
-    return;
+	/*
+	 * Write EEPROM checksum at word 21.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+	AdvWaitEEPCmd(iop_base);
+	wbuf++;
+	charfields++;
+
+	/*
+	 * Write EEPROM OEM name at words 22 to 29.
+	 */
+	for (addr = ADV_EEP_DVC_CTL_BEGIN;
+	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
+		ushort word;
+
+		if (*charfields++) {
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
+		}
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+	}
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+	AdvWaitEEPCmd(iop_base);
+	return;
 }
 
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
 void __init
-AdvSet38C1600EEPConfig(AdvPortAddr iop_base,
-                       ADVEEP_38C1600_CONFIG *cfg_buf)
+AdvSet38C1600EEPConfig(AdvPortAddr iop_base, ADVEEP_38C1600_CONFIG *cfg_buf)
 {
-    ushort              *wbuf;
-    ushort              *charfields;
-    ushort              addr, chksum;
-
-    wbuf = (ushort *) cfg_buf;
-    charfields = (ushort *) &ADVEEP_38C1600_Config_Field_IsChar;
-    chksum = 0;
-
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
-    AdvWaitEEPCmd(iop_base);
-
-    /*
-     * Write EEPROM from word 0 to word 20.
-     */
-    for (addr = ADV_EEP_DVC_CFG_BEGIN;
-         addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++)
-    {
-        ushort word;
-
-        if (*charfields++) {
-            word = cpu_to_le16(*wbuf);
-        } else {
-            word = *wbuf;
-        }
-        chksum += *wbuf; /* Checksum is calculated from word values. */
-        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-        AdvWaitEEPCmd(iop_base);
-        DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
-    }
-
-    /*
-     * Write EEPROM checksum at word 21.
-     */
-    AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-    AdvWaitEEPCmd(iop_base);
-    wbuf++; charfields++;
+	ushort *wbuf;
+	ushort *charfields;
+	ushort addr, chksum;
+
+	wbuf = (ushort *)cfg_buf;
+	charfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;
+	chksum = 0;
+
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+	AdvWaitEEPCmd(iop_base);
+
+	/*
+	 * Write EEPROM from word 0 to word 20.
+	 */
+	for (addr = ADV_EEP_DVC_CFG_BEGIN;
+	     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {
+		ushort word;
+
+		if (*charfields++) {
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
+		}
+		chksum += *wbuf;	/* Checksum is calculated from word values. */
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+		DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+	}
 
-    /*
-     * Write EEPROM OEM name at words 22 to 29.
-     */
-    for (addr = ADV_EEP_DVC_CTL_BEGIN;
-         addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++)
-    {
-        ushort word;
-
-        if (*charfields++) {
-            word = cpu_to_le16(*wbuf);
-        } else {
-            word = *wbuf;
-        }
-        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
-        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
-        AdvWaitEEPCmd(iop_base);
-    }
-    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
-    AdvWaitEEPCmd(iop_base);
-    return;
+	/*
+	 * Write EEPROM checksum at word 21.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+	AdvWaitEEPCmd(iop_base);
+	wbuf++;
+	charfields++;
+
+	/*
+	 * Write EEPROM OEM name at words 22 to 29.
+	 */
+	for (addr = ADV_EEP_DVC_CTL_BEGIN;
+	     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {
+		ushort word;
+
+		if (*charfields++) {
+			word = cpu_to_le16(*wbuf);
+		} else {
+			word = *wbuf;
+		}
+		AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+		AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+				     ASC_EEP_CMD_WRITE | addr);
+		AdvWaitEEPCmd(iop_base);
+	}
+	AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+	AdvWaitEEPCmd(iop_base);
+	return;
 }
 
 /* a_advlib.c */
@@ -17444,126 +17115,120 @@ AdvSet38C1600EEPConfig(AdvPortAddr iop_base,
  *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure
  *                       host IC error.
  */
-STATIC int
-AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc,
-                ADV_SCSI_REQ_Q *scsiq)
+static int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 {
-    ulong                  last_int_level;
-    AdvPortAddr            iop_base;
-    ADV_DCNT               req_size;
-    ADV_PADDR              req_paddr;
-    ADV_CARR_T             *new_carrp;
-
-    ASC_ASSERT(scsiq != NULL); /* 'scsiq' should never be NULL. */
-
-    /*
-     * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
-     */
-    if (scsiq->target_id > ADV_MAX_TID)
-    {
-        scsiq->host_status = QHSTA_M_INVALID_DEVICE;
-        scsiq->done_status = QD_WITH_ERROR;
-        return ADV_ERROR;
-    }
-
-    iop_base = asc_dvc->iop_base;
-
-    last_int_level = DvcEnterCritical();
-
-    /*
-     * Allocate a carrier ensuring at least one carrier always
-     * remains on the freelist and initialize fields.
-     */
-    if ((new_carrp = asc_dvc->carr_freelist) == NULL)
-    {
-       DvcLeaveCritical(last_int_level);
-       return ADV_BUSY;
-    }
-    asc_dvc->carr_freelist = (ADV_CARR_T *)
-        ADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));
-    asc_dvc->carr_pending_cnt++;
-
-    /*
-     * Set the carrier to be a stopper by setting 'next_vpa'
-     * to the stopper value. The current stopper will be changed
-     * below to point to the new stopper.
-     */
-    new_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
-
-    /*
-     * Clear the ADV_SCSI_REQ_Q done flag.
-     */
-    scsiq->a_flag &= ~ADV_SCSIQ_DONE;
-
-    req_size = sizeof(ADV_SCSI_REQ_Q);
-    req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *) scsiq,
-        (ADV_SDCNT *) &req_size, ADV_IS_SCSIQ_FLAG);
-
-    ASC_ASSERT(ADV_32BALIGN(req_paddr) == req_paddr);
-    ASC_ASSERT(req_size >= sizeof(ADV_SCSI_REQ_Q));
-
-    /* Wait for assertion before making little-endian */
-    req_paddr = cpu_to_le32(req_paddr);
+	ulong last_int_level;
+	AdvPortAddr iop_base;
+	ADV_DCNT req_size;
+	ADV_PADDR req_paddr;
+	ADV_CARR_T *new_carrp;
+
+	ASC_ASSERT(scsiq != NULL);	/* 'scsiq' should never be NULL. */
+
+	/*
+	 * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
+	 */
+	if (scsiq->target_id > ADV_MAX_TID) {
+		scsiq->host_status = QHSTA_M_INVALID_DEVICE;
+		scsiq->done_status = QD_WITH_ERROR;
+		return ADV_ERROR;
+	}
 
-    /* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
-    scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
-    scsiq->scsiq_rptr = req_paddr;
+	iop_base = asc_dvc->iop_base;
 
-    scsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));
-    /*
-     * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
-     * order during initialization.
-     */
-    scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
-
-   /*
-    * Use the current stopper to send the ADV_SCSI_REQ_Q command to
-    * the microcode. The newly allocated stopper will become the new
-    * stopper.
-    */
-    asc_dvc->icq_sp->areq_vpa = req_paddr;
+	last_int_level = DvcEnterCritical();
 
-    /*
-     * Set the 'next_vpa' pointer for the old stopper to be the
-     * physical address of the new stopper. The RISC can only
-     * follow physical addresses.
-     */
-    asc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;
-
-    /*
-     * Set the host adapter stopper pointer to point to the new carrier.
-     */
-    asc_dvc->icq_sp = new_carrp;
-
-    if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
-        asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        /*
-         * Tickle the RISC to tell it to read its Command Queue Head pointer.
-         */
-        AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
-        if (asc_dvc->chip_type == ADV_CHIP_ASC3550)
-        {
-            /*
-             * Clear the tickle value. In the ASC-3550 the RISC flag
-             * command 'clr_tickle_a' does not work unless the host
-             * value is cleared.
-             */
-            AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
-        }
-    } else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
-    {
-        /*
-         * Notify the RISC a carrier is ready by writing the physical
-         * address of the new carrier stopper to the COMMA register.
-         */
-        AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
-                le32_to_cpu(new_carrp->carr_pa));
-    }
+	/*
+	 * Allocate a carrier ensuring at least one carrier always
+	 * remains on the freelist and initialize fields.
+	 */
+	if ((new_carrp = asc_dvc->carr_freelist) == NULL) {
+		DvcLeaveCritical(last_int_level);
+		return ADV_BUSY;
+	}
+	asc_dvc->carr_freelist = (ADV_CARR_T *)
+	    ADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));
+	asc_dvc->carr_pending_cnt++;
+
+	/*
+	 * Set the carrier to be a stopper by setting 'next_vpa'
+	 * to the stopper value. The current stopper will be changed
+	 * below to point to the new stopper.
+	 */
+	new_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+	/*
+	 * Clear the ADV_SCSI_REQ_Q done flag.
+	 */
+	scsiq->a_flag &= ~ADV_SCSIQ_DONE;
+
+	req_size = sizeof(ADV_SCSI_REQ_Q);
+	req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *)scsiq,
+				  (ADV_SDCNT *)&req_size, ADV_IS_SCSIQ_FLAG);
+
+	ASC_ASSERT(ADV_32BALIGN(req_paddr) == req_paddr);
+	ASC_ASSERT(req_size >= sizeof(ADV_SCSI_REQ_Q));
+
+	/* Wait for assertion before making little-endian */
+	req_paddr = cpu_to_le32(req_paddr);
+
+	/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
+	scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
+	scsiq->scsiq_rptr = req_paddr;
+
+	scsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));
+	/*
+	 * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
+	 * order during initialization.
+	 */
+	scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
+
+	/*
+	 * Use the current stopper to send the ADV_SCSI_REQ_Q command to
+	 * the microcode. The newly allocated stopper will become the new
+	 * stopper.
+	 */
+	asc_dvc->icq_sp->areq_vpa = req_paddr;
+
+	/*
+	 * Set the 'next_vpa' pointer for the old stopper to be the
+	 * physical address of the new stopper. The RISC can only
+	 * follow physical addresses.
+	 */
+	asc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;
+
+	/*
+	 * Set the host adapter stopper pointer to point to the new carrier.
+	 */
+	asc_dvc->icq_sp = new_carrp;
+
+	if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
+	    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+		/*
+		 * Tickle the RISC to tell it to read its Command Queue Head pointer.
+		 */
+		AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
+		if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+			/*
+			 * Clear the tickle value. In the ASC-3550 the RISC flag
+			 * command 'clr_tickle_a' does not work unless the host
+			 * value is cleared.
+			 */
+			AdvWriteByteRegister(iop_base, IOPB_TICKLE,
+					     ADV_TICKLE_NOP);
+		}
+	} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		/*
+		 * Notify the RISC a carrier is ready by writing the physical
+		 * address of the new carrier stopper to the COMMA register.
+		 */
+		AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
+				      le32_to_cpu(new_carrp->carr_pa));
+	}
 
-    DvcLeaveCritical(last_int_level);
+	DvcLeaveCritical(last_int_level);
 
-    return ADV_SUCCESS;
+	return ADV_SUCCESS;
 }
 
 /*
@@ -17575,42 +17240,39 @@ AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc,
  *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC
  *                      may be hung which requires driver recovery.
  */
-STATIC int
-AdvResetSB(ADV_DVC_VAR *asc_dvc)
+static int AdvResetSB(ADV_DVC_VAR *asc_dvc)
 {
-    int         status;
-
-    /*
-     * Send the SCSI Bus Reset idle start idle command which asserts
-     * the SCSI Bus Reset signal.
-     */
-    status = AdvSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_SCSI_RESET_START, 0L);
-    if (status != ADV_TRUE)
-    {
-        return status;
-    }
-
-    /*
-     * Delay for the specified SCSI Bus Reset hold time.
-     *
-     * The hold time delay is done on the host because the RISC has no
-     * microsecond accurate timer.
-     */
-    DvcDelayMicroSecond(asc_dvc, (ushort) ASC_SCSI_RESET_HOLD_TIME_US);
-
-    /*
-     * Send the SCSI Bus Reset end idle command which de-asserts
-     * the SCSI Bus Reset signal and purges any pending requests.
-     */
-    status = AdvSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_SCSI_RESET_END, 0L);
-    if (status != ADV_TRUE)
-    {
-        return status;
-    }
+	int status;
+
+	/*
+	 * Send the SCSI Bus Reset idle start idle command which asserts
+	 * the SCSI Bus Reset signal.
+	 */
+	status = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_START, 0L);
+	if (status != ADV_TRUE) {
+		return status;
+	}
 
-    DvcSleepMilliSecond((ADV_DCNT) asc_dvc->scsi_reset_wait * 1000);
+	/*
+	 * Delay for the specified SCSI Bus Reset hold time.
+	 *
+	 * The hold time delay is done on the host because the RISC has no
+	 * microsecond accurate timer.
+	 */
+	DvcDelayMicroSecond(asc_dvc, (ushort)ASC_SCSI_RESET_HOLD_TIME_US);
+
+	/*
+	 * Send the SCSI Bus Reset end idle command which de-asserts
+	 * the SCSI Bus Reset signal and purges any pending requests.
+	 */
+	status = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_END, 0L);
+	if (status != ADV_TRUE) {
+		return status;
+	}
+
+	DvcSleepMilliSecond((ADV_DCNT)asc_dvc->scsi_reset_wait * 1000);
 
-    return status;
+	return status;
 }
 
 /*
@@ -17620,99 +17282,89 @@ AdvResetSB(ADV_DVC_VAR *asc_dvc)
  *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.
  *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.
  */
-STATIC int
-AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
+static int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
 {
-    int         status;
-    ushort      wdtr_able, sdtr_able, tagqng_able;
-    ushort      ppr_able = 0;
-    uchar       tid, max_cmd[ADV_MAX_TID + 1];
-    AdvPortAddr iop_base;
-    ushort      bios_sig;
-
-    iop_base = asc_dvc->iop_base;
-
-    /*
-     * Save current per TID negotiated values.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-    if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
-    {
-        AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-    }
-    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-    for (tid = 0; tid <= ADV_MAX_TID; tid++)
-    {
-        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-            max_cmd[tid]);
-    }
-
-    /*
-     * Force the AdvInitAsc3550/38C0800Driver() function to
-     * perform a SCSI Bus Reset by clearing the BIOS signature word.
-     * The initialization functions assumes a SCSI Bus Reset is not
-     * needed if the BIOS signature word is present.
-     */
-    AdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
-    AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);
-
-    /*
-     * Stop chip and reset it.
-     */
-    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);
-    AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
-    DvcSleepMilliSecond(100);
-    AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_WR_IO_REG);
-
-    /*
-     * Reset Adv Library error code, if any, and try
-     * re-initializing the chip.
-     */
-    asc_dvc->err_code = 0;
-    if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
-    {
-        status = AdvInitAsc38C1600Driver(asc_dvc);
-    }
-    else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
-    {
-        status = AdvInitAsc38C0800Driver(asc_dvc);
-    } else
-    {
-        status = AdvInitAsc3550Driver(asc_dvc);
-    }
+	int status;
+	ushort wdtr_able, sdtr_able, tagqng_able;
+	ushort ppr_able = 0;
+	uchar tid, max_cmd[ADV_MAX_TID + 1];
+	AdvPortAddr iop_base;
+	ushort bios_sig;
+
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Save current per TID negotiated values.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	}
+	AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				max_cmd[tid]);
+	}
 
-    /* Translate initialization return value to status value. */
-    if (status == 0)
-    {
-        status = ADV_TRUE;
-    } else
-    {
-        status = ADV_FALSE;
-    }
+	/*
+	 * Force the AdvInitAsc3550/38C0800Driver() function to
+	 * perform a SCSI Bus Reset by clearing the BIOS signature word.
+	 * The initialization functions assumes a SCSI Bus Reset is not
+	 * needed if the BIOS signature word is present.
+	 */
+	AdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+	AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);
+
+	/*
+	 * Stop chip and reset it.
+	 */
+	AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);
+	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
+	DvcSleepMilliSecond(100);
+	AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+			     ADV_CTRL_REG_CMD_WR_IO_REG);
+
+	/*
+	 * Reset Adv Library error code, if any, and try
+	 * re-initializing the chip.
+	 */
+	asc_dvc->err_code = 0;
+	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		status = AdvInitAsc38C1600Driver(asc_dvc);
+	} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+		status = AdvInitAsc38C0800Driver(asc_dvc);
+	} else {
+		status = AdvInitAsc3550Driver(asc_dvc);
+	}
 
-    /*
-     * Restore the BIOS signature word.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+	/* Translate initialization return value to status value. */
+	if (status == 0) {
+		status = ADV_TRUE;
+	} else {
+		status = ADV_FALSE;
+	}
 
-    /*
-     * Restore per TID negotiated values.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
-    AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
-    if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
-    {
-        AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
-    }
-    AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
-    for (tid = 0; tid <= ADV_MAX_TID; tid++)
-    {
-        AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-            max_cmd[tid]);
-    }
+	/*
+	 * Restore the BIOS signature word.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+
+	/*
+	 * Restore per TID negotiated values.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+	AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+	if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {
+		AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+	}
+	AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+	for (tid = 0; tid <= ADV_MAX_TID; tid++) {
+		AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+				 max_cmd[tid]);
+	}
 
-    return status;
+	return status;
 }
 
 /*
@@ -17734,158 +17386,151 @@ AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
  *   ADV_TRUE(1) - interrupt was pending
  *   ADV_FALSE(0) - no interrupt was pending
  */
-STATIC int
-AdvISR(ADV_DVC_VAR *asc_dvc)
+static int AdvISR(ADV_DVC_VAR *asc_dvc)
 {
-    AdvPortAddr                 iop_base;
-    uchar                       int_stat;
-    ushort                      target_bit;
-    ADV_CARR_T                  *free_carrp;
-    ADV_VADDR                   irq_next_vpa;
-    int                         flags;
-    ADV_SCSI_REQ_Q              *scsiq;
-
-    flags = DvcEnterCritical();
-
-    iop_base = asc_dvc->iop_base;
-
-    /* Reading the register clears the interrupt. */
-    int_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);
-
-    if ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |
-         ADV_INTR_STATUS_INTRC)) == 0)
-    {
-        DvcLeaveCritical(flags);
-        return ADV_FALSE;
-    }
+	AdvPortAddr iop_base;
+	uchar int_stat;
+	ushort target_bit;
+	ADV_CARR_T *free_carrp;
+	ADV_VADDR irq_next_vpa;
+	int flags;
+	ADV_SCSI_REQ_Q *scsiq;
 
-    /*
-     * Notify the driver of an asynchronous microcode condition by
-     * calling the ADV_DVC_VAR.async_callback function. The function
-     * is passed the microcode ASC_MC_INTRB_CODE byte value.
-     */
-    if (int_stat & ADV_INTR_STATUS_INTRB)
-    {
-        uchar intrb_code;
-
-        AdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);
-
-        if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
-            asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
-        {
-            if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
-                asc_dvc->carr_pending_cnt != 0)
-            {
-                AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
-                if (asc_dvc->chip_type == ADV_CHIP_ASC3550)
-                {
-                    AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
-                }
-            }
-        }
-
-        if (asc_dvc->async_callback != 0)
-        {
-            (*asc_dvc->async_callback)(asc_dvc, intrb_code);
-        }
-    }
+	flags = DvcEnterCritical();
 
-    /*
-     * Check if the IRQ stopper carrier contains a completed request.
-     */
-    while (((irq_next_vpa =
-             le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0)
-    {
-        /*
-         * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
-         * The RISC will have set 'areq_vpa' to a virtual address.
-         *
-         * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr
-         * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
-         * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
-         * in AdvExeScsiQueue().
-         */
-        scsiq = (ADV_SCSI_REQ_Q *)
-            ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));
-
-        /*
-         * Request finished with good status and the queue was not
-         * DMAed to host memory by the firmware. Set all status fields
-         * to indicate good status.
-         */
-        if ((irq_next_vpa & ASC_RQ_GOOD) != 0)
-        {
-            scsiq->done_status = QD_NO_ERROR;
-            scsiq->host_status = scsiq->scsi_status = 0;
-            scsiq->data_cnt = 0L;
-        }
-
-        /*
-         * Advance the stopper pointer to the next carrier
-         * ignoring the lower four bits. Free the previous
-         * stopper carrier.
-         */
-        free_carrp = asc_dvc->irq_sp;
-        asc_dvc->irq_sp = (ADV_CARR_T *)
-            ADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));
-
-        free_carrp->next_vpa =
-                cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
-        asc_dvc->carr_freelist = free_carrp;
-        asc_dvc->carr_pending_cnt--;
-
-        ASC_ASSERT(scsiq != NULL);
-        target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);
-
-        /*
-         * Clear request microcode control flag.
-         */
-        scsiq->cntl = 0;
-
-        /*
-         * If the command that completed was a SCSI INQUIRY and
-         * LUN 0 was sent the command, then process the INQUIRY
-         * command information for the device.
-         *
-         * Note: If data returned were either VPD or CmdDt data,
-         * don't process the INQUIRY command information for
-         * the device, otherwise may erroneously set *_able bits.
-         */
-        if (scsiq->done_status == QD_NO_ERROR &&
-            scsiq->cdb[0] == INQUIRY &&
-            scsiq->target_lun == 0 &&
-            (scsiq->cdb[1] & ADV_INQ_RTN_VPD_AND_CMDDT)
-                == ADV_INQ_RTN_STD_INQUIRY_DATA)
-        {
-            AdvInquiryHandling(asc_dvc, scsiq);
-        }
-
-        /*
-         * Notify the driver of the completed request by passing
-         * the ADV_SCSI_REQ_Q pointer to its callback function.
-         */
-        scsiq->a_flag |= ADV_SCSIQ_DONE;
-        (*asc_dvc->isr_callback)(asc_dvc, scsiq);
-        /*
-         * Note: After the driver callback function is called, 'scsiq'
-         * can no longer be referenced.
-         *
-         * Fall through and continue processing other completed
-         * requests...
-         */
-
-        /*
-         * Disable interrupts again in case the driver inadvertently
-         * enabled interrupts in its callback function.
-         *
-         * The DvcEnterCritical() return value is ignored, because
-         * the 'flags' saved when AdvISR() was first entered will be
-         * used to restore the interrupt flag on exit.
-         */
-        (void) DvcEnterCritical();
-    }
-    DvcLeaveCritical(flags);
-    return ADV_TRUE;
+	iop_base = asc_dvc->iop_base;
+
+	/* Reading the register clears the interrupt. */
+	int_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);
+
+	if ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |
+			 ADV_INTR_STATUS_INTRC)) == 0) {
+		DvcLeaveCritical(flags);
+		return ADV_FALSE;
+	}
+
+	/*
+	 * Notify the driver of an asynchronous microcode condition by
+	 * calling the ADV_DVC_VAR.async_callback function. The function
+	 * is passed the microcode ASC_MC_INTRB_CODE byte value.
+	 */
+	if (int_stat & ADV_INTR_STATUS_INTRB) {
+		uchar intrb_code;
+
+		AdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);
+
+		if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
+		    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {
+			if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
+			    asc_dvc->carr_pending_cnt != 0) {
+				AdvWriteByteRegister(iop_base, IOPB_TICKLE,
+						     ADV_TICKLE_A);
+				if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+					AdvWriteByteRegister(iop_base,
+							     IOPB_TICKLE,
+							     ADV_TICKLE_NOP);
+				}
+			}
+		}
+
+		if (asc_dvc->async_callback != 0) {
+			(*asc_dvc->async_callback) (asc_dvc, intrb_code);
+		}
+	}
+
+	/*
+	 * Check if the IRQ stopper carrier contains a completed request.
+	 */
+	while (((irq_next_vpa =
+		 le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0) {
+		/*
+		 * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
+		 * The RISC will have set 'areq_vpa' to a virtual address.
+		 *
+		 * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr
+		 * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
+		 * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
+		 * in AdvExeScsiQueue().
+		 */
+		scsiq = (ADV_SCSI_REQ_Q *)
+		    ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));
+
+		/*
+		 * Request finished with good status and the queue was not
+		 * DMAed to host memory by the firmware. Set all status fields
+		 * to indicate good status.
+		 */
+		if ((irq_next_vpa & ASC_RQ_GOOD) != 0) {
+			scsiq->done_status = QD_NO_ERROR;
+			scsiq->host_status = scsiq->scsi_status = 0;
+			scsiq->data_cnt = 0L;
+		}
+
+		/*
+		 * Advance the stopper pointer to the next carrier
+		 * ignoring the lower four bits. Free the previous
+		 * stopper carrier.
+		 */
+		free_carrp = asc_dvc->irq_sp;
+		asc_dvc->irq_sp = (ADV_CARR_T *)
+		    ADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));
+
+		free_carrp->next_vpa =
+		    cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+		asc_dvc->carr_freelist = free_carrp;
+		asc_dvc->carr_pending_cnt--;
+
+		ASC_ASSERT(scsiq != NULL);
+		target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);
+
+		/*
+		 * Clear request microcode control flag.
+		 */
+		scsiq->cntl = 0;
+
+		/*
+		 * If the command that completed was a SCSI INQUIRY and
+		 * LUN 0 was sent the command, then process the INQUIRY
+		 * command information for the device.
+		 *
+		 * Note: If data returned were either VPD or CmdDt data,
+		 * don't process the INQUIRY command information for
+		 * the device, otherwise may erroneously set *_able bits.
+		 */
+		if (scsiq->done_status == QD_NO_ERROR &&
+		    scsiq->cdb[0] == INQUIRY &&
+		    scsiq->target_lun == 0 &&
+		    (scsiq->cdb[1] & ADV_INQ_RTN_VPD_AND_CMDDT)
+		    == ADV_INQ_RTN_STD_INQUIRY_DATA) {
+			AdvInquiryHandling(asc_dvc, scsiq);
+		}
+
+		/*
+		 * Notify the driver of the completed request by passing
+		 * the ADV_SCSI_REQ_Q pointer to its callback function.
+		 */
+		scsiq->a_flag |= ADV_SCSIQ_DONE;
+		(*asc_dvc->isr_callback) (asc_dvc, scsiq);
+		/*
+		 * Note: After the driver callback function is called, 'scsiq'
+		 * can no longer be referenced.
+		 *
+		 * Fall through and continue processing other completed
+		 * requests...
+		 */
+
+		/*
+		 * Disable interrupts again in case the driver inadvertently
+		 * enabled interrupts in its callback function.
+		 *
+		 * The DvcEnterCritical() return value is ignored, because
+		 * the 'flags' saved when AdvISR() was first entered will be
+		 * used to restore the interrupt flag on exit.
+		 */
+		(void)DvcEnterCritical();
+	}
+	DvcLeaveCritical(flags);
+	return ADV_TRUE;
 }
 
 /*
@@ -17902,71 +17547,67 @@ AdvISR(ADV_DVC_VAR *asc_dvc)
  *   ADV_FALSE - command failed
  *   ADV_ERROR - command timed out
  */
-STATIC int
+static int
 AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
-               ushort idle_cmd,
-               ADV_DCNT idle_cmd_parameter)
+	       ushort idle_cmd, ADV_DCNT idle_cmd_parameter)
 {
-    ulong       last_int_level;
-    int         result;
-    ADV_DCNT    i, j;
-    AdvPortAddr iop_base;
-
-    last_int_level = DvcEnterCritical();
-
-    iop_base = asc_dvc->iop_base;
-
-    /*
-     * Clear the idle command status which is set by the microcode
-     * to a non-zero value to indicate when the command is completed.
-     * The non-zero result is one of the IDLE_CMD_STATUS_* values
-     * defined in a_advlib.h.
-     */
-    AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort) 0);
-
-    /*
-     * Write the idle command value after the idle command parameter
-     * has been written to avoid a race condition. If the order is not
-     * followed, the microcode may process the idle command before the
-     * parameters have been written to LRAM.
-     */
-    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,
-        cpu_to_le32(idle_cmd_parameter));
-    AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
-
-    /*
-     * Tickle the RISC to tell it to process the idle command.
-     */
-    AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);
-    if (asc_dvc->chip_type == ADV_CHIP_ASC3550)
-    {
-        /*
-         * Clear the tickle value. In the ASC-3550 the RISC flag
-         * command 'clr_tickle_b' does not work unless the host
-         * value is cleared.
-         */
-        AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
-    }
+	ulong last_int_level;
+	int result;
+	ADV_DCNT i, j;
+	AdvPortAddr iop_base;
+
+	last_int_level = DvcEnterCritical();
+
+	iop_base = asc_dvc->iop_base;
+
+	/*
+	 * Clear the idle command status which is set by the microcode
+	 * to a non-zero value to indicate when the command is completed.
+	 * The non-zero result is one of the IDLE_CMD_STATUS_* values
+	 * defined in a_advlib.h.
+	 */
+	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);
+
+	/*
+	 * Write the idle command value after the idle command parameter
+	 * has been written to avoid a race condition. If the order is not
+	 * followed, the microcode may process the idle command before the
+	 * parameters have been written to LRAM.
+	 */
+	AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,
+				cpu_to_le32(idle_cmd_parameter));
+	AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
+
+	/*
+	 * Tickle the RISC to tell it to process the idle command.
+	 */
+	AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);
+	if (asc_dvc->chip_type == ADV_CHIP_ASC3550) {
+		/*
+		 * Clear the tickle value. In the ASC-3550 the RISC flag
+		 * command 'clr_tickle_b' does not work unless the host
+		 * value is cleared.
+		 */
+		AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
+	}
 
-    /* Wait for up to 100 millisecond for the idle command to timeout. */
-    for (i = 0; i < SCSI_WAIT_100_MSEC; i++)
-    {
-        /* Poll once each microsecond for command completion. */
-        for (j = 0; j < SCSI_US_PER_MSEC; j++)
-        {
-            AdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, result);
-            if (result != 0)
-            {
-                DvcLeaveCritical(last_int_level);
-                return result;
-            }
-            DvcDelayMicroSecond(asc_dvc, (ushort) 1);
-        }
-    }
+	/* Wait for up to 100 millisecond for the idle command to timeout. */
+	for (i = 0; i < SCSI_WAIT_100_MSEC; i++) {
+		/* Poll once each microsecond for command completion. */
+		for (j = 0; j < SCSI_US_PER_MSEC; j++) {
+			AdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,
+					result);
+			if (result != 0) {
+				DvcLeaveCritical(last_int_level);
+				return result;
+			}
+			DvcDelayMicroSecond(asc_dvc, (ushort)1);
+		}
+	}
 
-    ASC_ASSERT(0); /* The idle command should never timeout. */
-    DvcLeaveCritical(last_int_level);
-    return ADV_ERROR;
+	ASC_ASSERT(0);		/* The idle command should never timeout. */
+	DvcLeaveCritical(last_int_level);
+	return ADV_ERROR;
 }
 
 /*
@@ -17976,179 +17617,1415 @@ AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
  * microcode operating variables that affect WDTR, SDTR, and Tag
  * Queuing.
  */
-STATIC void
-AdvInquiryHandling(
-    ADV_DVC_VAR                 *asc_dvc,
-    ADV_SCSI_REQ_Q              *scsiq)
+static void AdvInquiryHandling(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq)
 {
-    AdvPortAddr                 iop_base;
-    uchar                       tid;
-    ADV_SCSI_INQUIRY            *inq;
-    ushort                      tidmask;
-    ushort                      cfg_word;
+	AdvPortAddr iop_base;
+	uchar tid;
+	ADV_SCSI_INQUIRY *inq;
+	ushort tidmask;
+	ushort cfg_word;
+
+	/*
+	 * AdvInquiryHandling() requires up to INQUIRY information Byte 7
+	 * to be available.
+	 *
+	 * If less than 8 bytes of INQUIRY information were requested or less
+	 * than 8 bytes were transferred, then return. cdb[4] is the request
+	 * length and the ADV_SCSI_REQ_Q 'data_cnt' field is set by the
+	 * microcode to the transfer residual count.
+	 */
+
+	if (scsiq->cdb[4] < 8 ||
+	    (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) < 8) {
+		return;
+	}
 
-    /*
-     * AdvInquiryHandling() requires up to INQUIRY information Byte 7
-     * to be available.
-     *
-     * If less than 8 bytes of INQUIRY information were requested or less
-     * than 8 bytes were transferred, then return. cdb[4] is the request
-     * length and the ADV_SCSI_REQ_Q 'data_cnt' field is set by the
-     * microcode to the transfer residual count.
-     */
-
-    if (scsiq->cdb[4] < 8 ||
-        (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) < 8)
-    {
-        return;
-    }
+	iop_base = asc_dvc->iop_base;
+	tid = scsiq->target_id;
+
+	inq = (ADV_SCSI_INQUIRY *) scsiq->vdata_addr;
 
-    iop_base = asc_dvc->iop_base;
-    tid = scsiq->target_id;
+	/*
+	 * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
+	 */
+	if (ADV_INQ_RESPONSE_FMT(inq) < 2 && ADV_INQ_ANSI_VER(inq) < 2) {
+		return;
+	} else {
+		/*
+		 * INQUIRY Byte 7 Handling
+		 *
+		 * Use a device's INQUIRY byte 7 to determine whether it
+		 * supports WDTR, SDTR, and Tag Queuing. If the feature
+		 * is enabled in the EEPROM and the device supports the
+		 * feature, then enable it in the microcode.
+		 */
 
-    inq = (ADV_SCSI_INQUIRY *) scsiq->vdata_addr;
+		tidmask = ADV_TID_TO_TIDMASK(tid);
 
-    /*
-     * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
-     */
-    if (ADV_INQ_RESPONSE_FMT(inq) < 2 && ADV_INQ_ANSI_VER(inq) < 2)
-    {
-        return;
-    } else
-    {
-        /*
-         * INQUIRY Byte 7 Handling
-         *
-         * Use a device's INQUIRY byte 7 to determine whether it
-         * supports WDTR, SDTR, and Tag Queuing. If the feature
-         * is enabled in the EEPROM and the device supports the
-         * feature, then enable it in the microcode.
-         */
-
-        tidmask = ADV_TID_TO_TIDMASK(tid);
-
-        /*
-         * Wide Transfers
-         *
-         * If the EEPROM enabled WDTR for the device and the device
-         * supports wide bus (16 bit) transfers, then turn on the
-         * device's 'wdtr_able' bit and write the new value to the
-         * microcode.
-         */
-        if ((asc_dvc->wdtr_able & tidmask) && ADV_INQ_WIDE16(inq))
-        {
-            AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
-            if ((cfg_word & tidmask) == 0)
-            {
-                cfg_word |= tidmask;
-                AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
-
-                /*
-                 * Clear the microcode "SDTR negotiation" and "WDTR
-                 * negotiation" done indicators for the target to cause
-                 * it to negotiate with the new setting set above.
-                 * WDTR when accepted causes the target to enter
-                 * asynchronous mode, so SDTR must be negotiated.
-                 */
-                AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-                cfg_word &= ~tidmask;
-                AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-                AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
-                cfg_word &= ~tidmask;
-                AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
-            }
-        }
-
-        /*
-         * Synchronous Transfers
-         *
-         * If the EEPROM enabled SDTR for the device and the device
-         * supports synchronous transfers, then turn on the device's
-         * 'sdtr_able' bit. Write the new value to the microcode.
-         */
-        if ((asc_dvc->sdtr_able & tidmask) && ADV_INQ_SYNC(inq))
-        {
-            AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
-            if ((cfg_word & tidmask) == 0)
-            {
-                cfg_word |= tidmask;
-                AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
-
-                /*
-                 * Clear the microcode "SDTR negotiation" done indicator
-                 * for the target to cause it to negotiate with the new
-                 * setting set above.
-                 */
-                AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-                cfg_word &= ~tidmask;
-                AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
-            }
-        }
-        /*
-         * If the Inquiry data included enough space for the SPI-3
-         * Clocking field, then check if DT mode is supported.
-         */
-        if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600 &&
-            (scsiq->cdb[4] >= 57 ||
-            (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) >= 57))
-        {
-            /*
-             * PPR (Parallel Protocol Request) Capable
-             *
-             * If the device supports DT mode, then it must be PPR capable.
-             * The PPR message will be used in place of the SDTR and WDTR
-             * messages to negotiate synchronous speed and offset, transfer
-             * width, and protocol options.
-             */
-            if (ADV_INQ_CLOCKING(inq) & ADV_INQ_CLOCKING_DT_ONLY)
-            {
-                AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, asc_dvc->ppr_able);
-                asc_dvc->ppr_able |= tidmask;
-                AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, asc_dvc->ppr_able);
-            }
-        }
-
-        /*
-         * If the EEPROM enabled Tag Queuing for the device and the
-         * device supports Tag Queueing, then turn on the device's
-         * 'tagqng_enable' bit in the microcode and set the microcode
-         * maximum command count to the ADV_DVC_VAR 'max_dvc_qng'
-         * value.
-         *
-         * Tag Queuing is disabled for the BIOS which runs in polled
-         * mode and would see no benefit from Tag Queuing. Also by
-         * disabling Tag Queuing in the BIOS devices with Tag Queuing
-         * bugs will at least work with the BIOS.
-         */
-        if ((asc_dvc->tagqng_able & tidmask) && ADV_INQ_CMD_QUEUE(inq))
-        {
-            AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
-            cfg_word |= tidmask;
-            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
-
-            AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
-                asc_dvc->max_dvc_qng);
-        }
-    }
+		/*
+		 * Wide Transfers
+		 *
+		 * If the EEPROM enabled WDTR for the device and the device
+		 * supports wide bus (16 bit) transfers, then turn on the
+		 * device's 'wdtr_able' bit and write the new value to the
+		 * microcode.
+		 */
+		if ((asc_dvc->wdtr_able & tidmask) && ADV_INQ_WIDE16(inq)) {
+			AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
+			if ((cfg_word & tidmask) == 0) {
+				cfg_word |= tidmask;
+				AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,
+						 cfg_word);
+
+				/*
+				 * Clear the microcode "SDTR negotiation" and "WDTR
+				 * negotiation" done indicators for the target to cause
+				 * it to negotiate with the new setting set above.
+				 * WDTR when accepted causes the target to enter
+				 * asynchronous mode, so SDTR must be negotiated.
+				 */
+				AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE,
+						cfg_word);
+				cfg_word &= ~tidmask;
+				AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE,
+						 cfg_word);
+				AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE,
+						cfg_word);
+				cfg_word &= ~tidmask;
+				AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE,
+						 cfg_word);
+			}
+		}
+
+		/*
+		 * Synchronous Transfers
+		 *
+		 * If the EEPROM enabled SDTR for the device and the device
+		 * supports synchronous transfers, then turn on the device's
+		 * 'sdtr_able' bit. Write the new value to the microcode.
+		 */
+		if ((asc_dvc->sdtr_able & tidmask) && ADV_INQ_SYNC(inq)) {
+			AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+			if ((cfg_word & tidmask) == 0) {
+				cfg_word |= tidmask;
+				AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,
+						 cfg_word);
+
+				/*
+				 * Clear the microcode "SDTR negotiation" done indicator
+				 * for the target to cause it to negotiate with the new
+				 * setting set above.
+				 */
+				AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE,
+						cfg_word);
+				cfg_word &= ~tidmask;
+				AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE,
+						 cfg_word);
+			}
+		}
+		/*
+		 * If the Inquiry data included enough space for the SPI-3
+		 * Clocking field, then check if DT mode is supported.
+		 */
+		if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600 &&
+		    (scsiq->cdb[4] >= 57 ||
+		     (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) >= 57)) {
+			/*
+			 * PPR (Parallel Protocol Request) Capable
+			 *
+			 * If the device supports DT mode, then it must be PPR capable.
+			 * The PPR message will be used in place of the SDTR and WDTR
+			 * messages to negotiate synchronous speed and offset, transfer
+			 * width, and protocol options.
+			 */
+			if (ADV_INQ_CLOCKING(inq) & ADV_INQ_CLOCKING_DT_ONLY) {
+				AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE,
+						asc_dvc->ppr_able);
+				asc_dvc->ppr_able |= tidmask;
+				AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE,
+						 asc_dvc->ppr_able);
+			}
+		}
+
+		/*
+		 * If the EEPROM enabled Tag Queuing for the device and the
+		 * device supports Tag Queueing, then turn on the device's
+		 * 'tagqng_enable' bit in the microcode and set the microcode
+		 * maximum command count to the ADV_DVC_VAR 'max_dvc_qng'
+		 * value.
+		 *
+		 * Tag Queuing is disabled for the BIOS which runs in polled
+		 * mode and would see no benefit from Tag Queuing. Also by
+		 * disabling Tag Queuing in the BIOS devices with Tag Queuing
+		 * bugs will at least work with the BIOS.
+		 */
+		if ((asc_dvc->tagqng_able & tidmask) && ADV_INQ_CMD_QUEUE(inq)) {
+			AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
+			cfg_word |= tidmask;
+			AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,
+					 cfg_word);
+
+			AdvWriteByteLram(iop_base,
+					 ASC_MC_NUMBER_OF_MAX_CMD + tid,
+					 asc_dvc->max_dvc_qng);
+		}
+	}
 }
+
 MODULE_LICENSE("Dual BSD/GPL");
 
+static struct Scsi_Host *__devinit
+advansys_board_found(int iop, struct device *dev, int bus_type)
+{
+	struct Scsi_Host *shost;
+	struct pci_dev *pdev = bus_type == ASC_IS_PCI ? to_pci_dev(dev) : NULL;
+	asc_board_t *boardp;
+	ASC_DVC_VAR *asc_dvc_varp = NULL;
+	ADV_DVC_VAR *adv_dvc_varp = NULL;
+	adv_sgblk_t *sgp = NULL;
+	int share_irq = FALSE;
+	int iolen = 0;
+	ADV_PADDR pci_memory_address;
+	int warn_code, err_code;
+	int ret;
+
+	/*
+	 * Adapter found.
+	 *
+	 * Register the adapter, get its configuration, and
+	 * initialize it.
+	 */
+	ASC_DBG(2, "advansys_board_found: scsi_register()\n");
+	shost = scsi_register(&driver_template, sizeof(asc_board_t));
+
+	if (!shost)
+		return NULL;
+
+	/* Save a pointer to the Scsi_Host of each board found. */
+	asc_host[asc_board_count++] = shost;
+
+	/* Initialize private per board data */
+	boardp = ASC_BOARDP(shost);
+	memset(boardp, 0, sizeof(asc_board_t));
+	boardp->id = asc_board_count - 1;
+
+	/* Initialize spinlock. */
+	spin_lock_init(&boardp->lock);
+
+	/*
+	 * Handle both narrow and wide boards.
+	 *
+	 * If a Wide board was detected, set the board structure
+	 * wide board flag. Set-up the board structure based on
+	 * the board type.
+	 */
+#ifdef CONFIG_PCI
+	if (bus_type == ASC_IS_PCI &&
+	    (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||
+	     pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||
+	     pdev->device == PCI_DEVICE_ID_38C1600_REV1)) {
+		boardp->flags |= ASC_IS_WIDE_BOARD;
+	}
+#endif /* CONFIG_PCI */
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		ASC_DBG(1, "advansys_board_found: narrow board\n");
+		asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+		asc_dvc_varp->bus_type = bus_type;
+		asc_dvc_varp->drv_ptr = boardp;
+		asc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;
+		asc_dvc_varp->cfg->overrun_buf = &overrun_buf[0];
+		asc_dvc_varp->iop_base = iop;
+		asc_dvc_varp->isr_callback = asc_isr_callback;
+	} else {
+		ASC_DBG(1, "advansys_board_found: wide board\n");
+		adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+		adv_dvc_varp->drv_ptr = boardp;
+		adv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;
+		adv_dvc_varp->isr_callback = adv_isr_callback;
+		adv_dvc_varp->async_callback = adv_async_callback;
+#ifdef CONFIG_PCI
+		if (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {
+			ASC_DBG(1, "advansys_board_found: ASC-3550\n");
+			adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;
+		} else if (pdev->device == PCI_DEVICE_ID_38C0800_REV1) {
+			ASC_DBG(1, "advansys_board_found: ASC-38C0800\n");
+			adv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;
+		} else {
+			ASC_DBG(1, "advansys_board_found: ASC-38C1600\n");
+			adv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;
+		}
+#endif /* CONFIG_PCI */
+
+		/*
+		 * Map the board's registers into virtual memory for
+		 * PCI slave access. Only memory accesses are used to
+		 * access the board's registers.
+		 *
+		 * Note: The PCI register base address is not always
+		 * page aligned, but the address passed to ioremap()
+		 * must be page aligned. It is guaranteed that the
+		 * PCI register base address will not cross a page
+		 * boundary.
+		 */
+		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+			iolen = ADV_3550_IOLEN;
+		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+			iolen = ADV_38C0800_IOLEN;
+		} else {
+			iolen = ADV_38C1600_IOLEN;
+		}
+#ifdef CONFIG_PCI
+		pci_memory_address = pci_resource_start(pdev, 1);
+		ASC_DBG1(1,
+			 "advansys_board_found: pci_memory_address: 0x%lx\n",
+			 (ulong)pci_memory_address);
+		if ((boardp->ioremap_addr =
+		     ioremap(pci_memory_address & PAGE_MASK, PAGE_SIZE)) == 0) {
+			ASC_PRINT3
+			    ("advansys_board_found: board %d: ioremap(%x, %d) returned NULL\n",
+			     boardp->id, pci_memory_address, iolen);
+			scsi_unregister(shost);
+			asc_board_count--;
+			return NULL;
+		}
+		ASC_DBG1(1,
+			 "advansys_board_found: ioremap_addr: 0x%lx\n",
+			 (ulong)boardp->ioremap_addr);
+		adv_dvc_varp->iop_base = (AdvPortAddr)
+		    (boardp->ioremap_addr +
+		     (pci_memory_address - (pci_memory_address & PAGE_MASK)));
+		ASC_DBG1(1,
+			 "advansys_board_found: iop_base: 0x%lx\n",
+			 adv_dvc_varp->iop_base);
+#endif /* CONFIG_PCI */
+
+		/*
+		 * Even though it isn't used to access wide boards, other
+		 * than for the debug line below, save I/O Port address so
+		 * that it can be reported.
+		 */
+		boardp->ioport = iop;
+
+		ASC_DBG2(1,
+			 "advansys_board_found: iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\n",
+			 (ushort)inp(iop + 1), (ushort)inpw(iop));
+	}
+
+#ifdef CONFIG_PROC_FS
+	/*
+	 * Allocate buffer for printing information from
+	 * /proc/scsi/advansys/[0...].
+	 */
+	if ((boardp->prtbuf = kmalloc(ASC_PRTBUF_SIZE, GFP_ATOMIC)) == NULL) {
+		ASC_PRINT3
+		    ("advansys_board_found: board %d: kmalloc(%d, %d) returned NULL\n",
+		     boardp->id, ASC_PRTBUF_SIZE, GFP_ATOMIC);
+		scsi_unregister(shost);
+		asc_board_count--;
+		return NULL;
+	}
+#endif /* CONFIG_PROC_FS */
+
+	if (ASC_NARROW_BOARD(boardp)) {
+		asc_dvc_varp->cfg->dev = dev;
+		/*
+		 * Set the board bus type and PCI IRQ before
+		 * calling AscInitGetConfig().
+		 */
+		switch (asc_dvc_varp->bus_type) {
+#ifdef CONFIG_ISA
+		case ASC_IS_ISA:
+			shost->unchecked_isa_dma = TRUE;
+			share_irq = FALSE;
+			break;
+		case ASC_IS_VL:
+			shost->unchecked_isa_dma = FALSE;
+			share_irq = FALSE;
+			break;
+		case ASC_IS_EISA:
+			shost->unchecked_isa_dma = FALSE;
+			share_irq = TRUE;
+			break;
+#endif /* CONFIG_ISA */
+#ifdef CONFIG_PCI
+		case ASC_IS_PCI:
+			shost->irq = asc_dvc_varp->irq_no = pdev->irq;
+			asc_dvc_varp->cfg->pci_slot_info =
+			    ASC_PCI_MKID(pdev->bus->number,
+					 PCI_SLOT(pdev->devfn),
+					 PCI_FUNC(pdev->devfn));
+			shost->unchecked_isa_dma = FALSE;
+			share_irq = TRUE;
+			break;
+#endif /* CONFIG_PCI */
+		default:
+			ASC_PRINT2
+			    ("advansys_board_found: board %d: unknown adapter type: %d\n",
+			     boardp->id, asc_dvc_varp->bus_type);
+			shost->unchecked_isa_dma = TRUE;
+			share_irq = FALSE;
+			break;
+		}
+	} else {
+		adv_dvc_varp->cfg->dev = dev;
+		/*
+		 * For Wide boards set PCI information before calling
+		 * AdvInitGetConfig().
+		 */
+#ifdef CONFIG_PCI
+		shost->irq = adv_dvc_varp->irq_no = pdev->irq;
+		adv_dvc_varp->cfg->pci_slot_info =
+		    ASC_PCI_MKID(pdev->bus->number,
+				 PCI_SLOT(pdev->devfn),
+				 PCI_FUNC(pdev->devfn));
+		shost->unchecked_isa_dma = FALSE;
+		share_irq = TRUE;
+#endif /* CONFIG_PCI */
+	}
+
+	/*
+	 * Read the board configuration.
+	 */
+	if (ASC_NARROW_BOARD(boardp)) {
+		/*
+		 * NOTE: AscInitGetConfig() may change the board's
+		 * bus_type value. The bus_type value should no
+		 * longer be used. If the bus_type field must be
+		 * referenced only use the bit-wise AND operator "&".
+		 */
+		ASC_DBG(2, "advansys_board_found: AscInitGetConfig()\n");
+		switch (ret = AscInitGetConfig(asc_dvc_varp)) {
+		case 0:	/* No error */
+			break;
+		case ASC_WARN_IO_PORT_ROTATE:
+			ASC_PRINT1
+			    ("AscInitGetConfig: board %d: I/O port address modified\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_AUTO_CONFIG:
+			ASC_PRINT1
+			    ("AscInitGetConfig: board %d: I/O port increment switch enabled\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_EEPROM_CHKSUM:
+			ASC_PRINT1
+			    ("AscInitGetConfig: board %d: EEPROM checksum error\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_IRQ_MODIFIED:
+			ASC_PRINT1
+			    ("AscInitGetConfig: board %d: IRQ modified\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_CMD_QNG_CONFLICT:
+			ASC_PRINT1
+			    ("AscInitGetConfig: board %d: tag queuing enabled w/o disconnects\n",
+			     boardp->id);
+			break;
+		default:
+			ASC_PRINT2
+			    ("AscInitGetConfig: board %d: unknown warning: 0x%x\n",
+			     boardp->id, ret);
+			break;
+		}
+		if ((err_code = asc_dvc_varp->err_code) != 0) {
+			ASC_PRINT3
+			    ("AscInitGetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
+			     boardp->id,
+			     asc_dvc_varp->init_state, asc_dvc_varp->err_code);
+		}
+	} else {
+		ASC_DBG(2, "advansys_board_found: AdvInitGetConfig()\n");
+		if ((ret = AdvInitGetConfig(adv_dvc_varp)) != 0) {
+			ASC_PRINT2
+			    ("AdvInitGetConfig: board %d: warning: 0x%x\n",
+			     boardp->id, ret);
+		}
+		if ((err_code = adv_dvc_varp->err_code) != 0) {
+			ASC_PRINT2
+			    ("AdvInitGetConfig: board %d error: err_code 0x%x\n",
+			     boardp->id, adv_dvc_varp->err_code);
+		}
+	}
+
+	if (err_code != 0) {
+#ifdef CONFIG_PROC_FS
+		kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+		scsi_unregister(shost);
+		asc_board_count--;
+		return NULL;
+	}
+
+	/*
+	 * Save the EEPROM configuration so that it can be displayed
+	 * from /proc/scsi/advansys/[0...].
+	 */
+	if (ASC_NARROW_BOARD(boardp)) {
+
+		ASCEEP_CONFIG *ep;
+
+		/*
+		 * Set the adapter's target id bit in the 'init_tidmask' field.
+		 */
+		boardp->init_tidmask |=
+		    ADV_TID_TO_TIDMASK(asc_dvc_varp->cfg->chip_scsi_id);
+
+		/*
+		 * Save EEPROM settings for the board.
+		 */
+		ep = &boardp->eep_config.asc_eep;
+
+		ep->init_sdtr = asc_dvc_varp->cfg->sdtr_enable;
+		ep->disc_enable = asc_dvc_varp->cfg->disc_enable;
+		ep->use_cmd_qng = asc_dvc_varp->cfg->cmd_qng_enabled;
+		ASC_EEP_SET_DMA_SPD(ep, asc_dvc_varp->cfg->isa_dma_speed);
+		ep->start_motor = asc_dvc_varp->start_motor;
+		ep->cntl = asc_dvc_varp->dvc_cntl;
+		ep->no_scam = asc_dvc_varp->no_scam;
+		ep->max_total_qng = asc_dvc_varp->max_total_qng;
+		ASC_EEP_SET_CHIP_ID(ep, asc_dvc_varp->cfg->chip_scsi_id);
+		/* 'max_tag_qng' is set to the same value for every device. */
+		ep->max_tag_qng = asc_dvc_varp->cfg->max_tag_qng[0];
+		ep->adapter_info[0] = asc_dvc_varp->cfg->adapter_info[0];
+		ep->adapter_info[1] = asc_dvc_varp->cfg->adapter_info[1];
+		ep->adapter_info[2] = asc_dvc_varp->cfg->adapter_info[2];
+		ep->adapter_info[3] = asc_dvc_varp->cfg->adapter_info[3];
+		ep->adapter_info[4] = asc_dvc_varp->cfg->adapter_info[4];
+		ep->adapter_info[5] = asc_dvc_varp->cfg->adapter_info[5];
+
+		/*
+		 * Modify board configuration.
+		 */
+		ASC_DBG(2, "advansys_board_found: AscInitSetConfig()\n");
+		switch (ret = AscInitSetConfig(asc_dvc_varp)) {
+		case 0:	/* No error. */
+			break;
+		case ASC_WARN_IO_PORT_ROTATE:
+			ASC_PRINT1
+			    ("AscInitSetConfig: board %d: I/O port address modified\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_AUTO_CONFIG:
+			ASC_PRINT1
+			    ("AscInitSetConfig: board %d: I/O port increment switch enabled\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_EEPROM_CHKSUM:
+			ASC_PRINT1
+			    ("AscInitSetConfig: board %d: EEPROM checksum error\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_IRQ_MODIFIED:
+			ASC_PRINT1
+			    ("AscInitSetConfig: board %d: IRQ modified\n",
+			     boardp->id);
+			break;
+		case ASC_WARN_CMD_QNG_CONFLICT:
+			ASC_PRINT1
+			    ("AscInitSetConfig: board %d: tag queuing w/o disconnects\n",
+			     boardp->id);
+			break;
+		default:
+			ASC_PRINT2
+			    ("AscInitSetConfig: board %d: unknown warning: 0x%x\n",
+			     boardp->id, ret);
+			break;
+		}
+		if (asc_dvc_varp->err_code != 0) {
+			ASC_PRINT3
+			    ("AscInitSetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
+			     boardp->id,
+			     asc_dvc_varp->init_state, asc_dvc_varp->err_code);
+#ifdef CONFIG_PROC_FS
+			kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+			scsi_unregister(shost);
+			asc_board_count--;
+			return NULL;
+		}
+
+		/*
+		 * Finish initializing the 'Scsi_Host' structure.
+		 */
+		/* AscInitSetConfig() will set the IRQ for non-PCI boards. */
+		if ((asc_dvc_varp->bus_type & ASC_IS_PCI) == 0) {
+			shost->irq = asc_dvc_varp->irq_no;
+		}
+	} else {
+		ADVEEP_3550_CONFIG *ep_3550;
+		ADVEEP_38C0800_CONFIG *ep_38C0800;
+		ADVEEP_38C1600_CONFIG *ep_38C1600;
+
+		/*
+		 * Save Wide EEP Configuration Information.
+		 */
+		if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+			ep_3550 = &boardp->eep_config.adv_3550_eep;
+
+			ep_3550->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
+			ep_3550->max_host_qng = adv_dvc_varp->max_host_qng;
+			ep_3550->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
+			ep_3550->termination = adv_dvc_varp->cfg->termination;
+			ep_3550->disc_enable = adv_dvc_varp->cfg->disc_enable;
+			ep_3550->bios_ctrl = adv_dvc_varp->bios_ctrl;
+			ep_3550->wdtr_able = adv_dvc_varp->wdtr_able;
+			ep_3550->sdtr_able = adv_dvc_varp->sdtr_able;
+			ep_3550->ultra_able = adv_dvc_varp->ultra_able;
+			ep_3550->tagqng_able = adv_dvc_varp->tagqng_able;
+			ep_3550->start_motor = adv_dvc_varp->start_motor;
+			ep_3550->scsi_reset_delay =
+			    adv_dvc_varp->scsi_reset_wait;
+			ep_3550->serial_number_word1 =
+			    adv_dvc_varp->cfg->serial1;
+			ep_3550->serial_number_word2 =
+			    adv_dvc_varp->cfg->serial2;
+			ep_3550->serial_number_word3 =
+			    adv_dvc_varp->cfg->serial3;
+		} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+			ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
+
+			ep_38C0800->adapter_scsi_id =
+			    adv_dvc_varp->chip_scsi_id;
+			ep_38C0800->max_host_qng = adv_dvc_varp->max_host_qng;
+			ep_38C0800->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
+			ep_38C0800->termination_lvd =
+			    adv_dvc_varp->cfg->termination;
+			ep_38C0800->disc_enable =
+			    adv_dvc_varp->cfg->disc_enable;
+			ep_38C0800->bios_ctrl = adv_dvc_varp->bios_ctrl;
+			ep_38C0800->wdtr_able = adv_dvc_varp->wdtr_able;
+			ep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;
+			ep_38C0800->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;
+			ep_38C0800->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;
+			ep_38C0800->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;
+			ep_38C0800->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;
+			ep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;
+			ep_38C0800->start_motor = adv_dvc_varp->start_motor;
+			ep_38C0800->scsi_reset_delay =
+			    adv_dvc_varp->scsi_reset_wait;
+			ep_38C0800->serial_number_word1 =
+			    adv_dvc_varp->cfg->serial1;
+			ep_38C0800->serial_number_word2 =
+			    adv_dvc_varp->cfg->serial2;
+			ep_38C0800->serial_number_word3 =
+			    adv_dvc_varp->cfg->serial3;
+		} else {
+			ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
+
+			ep_38C1600->adapter_scsi_id =
+			    adv_dvc_varp->chip_scsi_id;
+			ep_38C1600->max_host_qng = adv_dvc_varp->max_host_qng;
+			ep_38C1600->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
+			ep_38C1600->termination_lvd =
+			    adv_dvc_varp->cfg->termination;
+			ep_38C1600->disc_enable =
+			    adv_dvc_varp->cfg->disc_enable;
+			ep_38C1600->bios_ctrl = adv_dvc_varp->bios_ctrl;
+			ep_38C1600->wdtr_able = adv_dvc_varp->wdtr_able;
+			ep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;
+			ep_38C1600->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;
+			ep_38C1600->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;
+			ep_38C1600->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;
+			ep_38C1600->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;
+			ep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;
+			ep_38C1600->start_motor = adv_dvc_varp->start_motor;
+			ep_38C1600->scsi_reset_delay =
+			    adv_dvc_varp->scsi_reset_wait;
+			ep_38C1600->serial_number_word1 =
+			    adv_dvc_varp->cfg->serial1;
+			ep_38C1600->serial_number_word2 =
+			    adv_dvc_varp->cfg->serial2;
+			ep_38C1600->serial_number_word3 =
+			    adv_dvc_varp->cfg->serial3;
+		}
+
+		/*
+		 * Set the adapter's target id bit in the 'init_tidmask' field.
+		 */
+		boardp->init_tidmask |=
+		    ADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);
+
+		/*
+		 * Finish initializing the 'Scsi_Host' structure.
+		 */
+		shost->irq = adv_dvc_varp->irq_no;
+	}
+
+	/*
+	 * Channels are numbered beginning with 0. For AdvanSys one host
+	 * structure supports one channel. Multi-channel boards have a
+	 * separate host structure for each channel.
+	 */
+	shost->max_channel = 0;
+	if (ASC_NARROW_BOARD(boardp)) {
+		shost->max_id = ASC_MAX_TID + 1;
+		shost->max_lun = ASC_MAX_LUN + 1;
+
+		shost->io_port = asc_dvc_varp->iop_base;
+		boardp->asc_n_io_port = ASC_IOADR_GAP;
+		shost->this_id = asc_dvc_varp->cfg->chip_scsi_id;
+
+		/* Set maximum number of queues the adapter can handle. */
+		shost->can_queue = asc_dvc_varp->max_total_qng;
+	} else {
+		shost->max_id = ADV_MAX_TID + 1;
+		shost->max_lun = ADV_MAX_LUN + 1;
+
+		/*
+		 * Save the I/O Port address and length even though
+		 * I/O ports are not used to access Wide boards.
+		 * Instead the Wide boards are accessed with
+		 * PCI Memory Mapped I/O.
+		 */
+		shost->io_port = iop;
+		boardp->asc_n_io_port = iolen;
+
+		shost->this_id = adv_dvc_varp->chip_scsi_id;
+
+		/* Set maximum number of queues the adapter can handle. */
+		shost->can_queue = adv_dvc_varp->max_host_qng;
+	}
+
+	/*
+	 * 'n_io_port' currently is one byte.
+	 *
+	 * Set a value to 'n_io_port', but never referenced it because
+	 * it may be truncated.
+	 */
+	shost->n_io_port = boardp->asc_n_io_port <= 255 ?
+	    boardp->asc_n_io_port : 255;
+
+	/*
+	 * Following v1.3.89, 'cmd_per_lun' is no longer needed
+	 * and should be set to zero.
+	 *
+	 * But because of a bug introduced in v1.3.89 if the driver is
+	 * compiled as a module and 'cmd_per_lun' is zero, the Mid-Level
+	 * SCSI function 'allocate_device' will panic. To allow the driver
+	 * to work as a module in these kernels set 'cmd_per_lun' to 1.
+	 *
+	 * Note: This is wrong.  cmd_per_lun should be set to the depth
+	 * you want on untagged devices always.
+	 #ifdef MODULE
+	 */
+	shost->cmd_per_lun = 1;
+/* #else
+            shost->cmd_per_lun = 0;
+#endif */
+
+	/*
+	 * Set the maximum number of scatter-gather elements the
+	 * adapter can handle.
+	 */
+	if (ASC_NARROW_BOARD(boardp)) {
+		/*
+		 * Allow two commands with 'sg_tablesize' scatter-gather
+		 * elements to be executed simultaneously. This value is
+		 * the theoretical hardware limit. It may be decreased
+		 * below.
+		 */
+		shost->sg_tablesize =
+		    (((asc_dvc_varp->max_total_qng - 2) / 2) *
+		     ASC_SG_LIST_PER_Q) + 1;
+	} else {
+		shost->sg_tablesize = ADV_MAX_SG_LIST;
+	}
+
+	/*
+	 * The value of 'sg_tablesize' can not exceed the SCSI
+	 * mid-level driver definition of SG_ALL. SG_ALL also
+	 * must not be exceeded, because it is used to define the
+	 * size of the scatter-gather table in 'struct asc_sg_head'.
+	 */
+	if (shost->sg_tablesize > SG_ALL) {
+		shost->sg_tablesize = SG_ALL;
+	}
+
+	ASC_DBG1(1, "advansys_board_found: sg_tablesize: %d\n", shost->sg_tablesize);
+
+	/* BIOS start address. */
+	if (ASC_NARROW_BOARD(boardp)) {
+		shost->base = ((ulong)
+			     AscGetChipBiosAddress(asc_dvc_varp->
+						   iop_base,
+						   asc_dvc_varp->bus_type));
+	} else {
+		/*
+		 * Fill-in BIOS board variables. The Wide BIOS saves
+		 * information in LRAM that is used by the driver.
+		 */
+		AdvReadWordLram(adv_dvc_varp->iop_base,
+				BIOS_SIGNATURE, boardp->bios_signature);
+		AdvReadWordLram(adv_dvc_varp->iop_base,
+				BIOS_VERSION, boardp->bios_version);
+		AdvReadWordLram(adv_dvc_varp->iop_base,
+				BIOS_CODESEG, boardp->bios_codeseg);
+		AdvReadWordLram(adv_dvc_varp->iop_base,
+				BIOS_CODELEN, boardp->bios_codelen);
+
+		ASC_DBG2(1,
+			 "advansys_board_found: bios_signature 0x%x, bios_version 0x%x\n",
+			 boardp->bios_signature, boardp->bios_version);
+
+		ASC_DBG2(1,
+			 "advansys_board_found: bios_codeseg 0x%x, bios_codelen 0x%x\n",
+			 boardp->bios_codeseg, boardp->bios_codelen);
+
+		/*
+		 * If the BIOS saved a valid signature, then fill in
+		 * the BIOS code segment base address.
+		 */
+		if (boardp->bios_signature == 0x55AA) {
+			/*
+			 * Convert x86 realmode code segment to a linear
+			 * address by shifting left 4.
+			 */
+			shost->base = ((ulong)boardp->bios_codeseg << 4);
+		} else {
+			shost->base = 0;
+		}
+	}
+
+	/*
+	 * Register Board Resources - I/O Port, DMA, IRQ
+	 */
+
+	/*
+	 * Register I/O port range.
+	 *
+	 * For Wide boards the I/O ports are not used to access
+	 * the board, but request the region anyway.
+	 *
+	 * 'shost->n_io_port' is not referenced, because it may be truncated.
+	 */
+	ASC_DBG2(2,
+		 "advansys_board_found: request_region port 0x%lx, len 0x%x\n",
+		 (ulong)shost->io_port, boardp->asc_n_io_port);
+	if (request_region(shost->io_port, boardp->asc_n_io_port,
+			   "advansys") == NULL) {
+		ASC_PRINT3
+		    ("advansys_board_found: board %d: request_region() failed, port 0x%lx, len 0x%x\n",
+		     boardp->id, (ulong)shost->io_port, boardp->asc_n_io_port);
+#ifdef CONFIG_PROC_FS
+		kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+		scsi_unregister(shost);
+		asc_board_count--;
+		return NULL;
+	}
+
+	/* Register DMA Channel for Narrow boards. */
+	shost->dma_channel = NO_ISA_DMA;	/* Default to no ISA DMA. */
+#ifdef CONFIG_ISA
+	if (ASC_NARROW_BOARD(boardp)) {
+		/* Register DMA channel for ISA bus. */
+		if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+			shost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
+			if ((ret =
+			     request_dma(shost->dma_channel, "advansys")) != 0) {
+				ASC_PRINT3
+				    ("advansys_board_found: board %d: request_dma() %d failed %d\n",
+				     boardp->id, shost->dma_channel, ret);
+				release_region(shost->io_port,
+					       boardp->asc_n_io_port);
+#ifdef CONFIG_PROC_FS
+				kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+				scsi_unregister(shost);
+				asc_board_count--;
+				return NULL;
+			}
+			AscEnableIsaDma(shost->dma_channel);
+		}
+	}
+#endif /* CONFIG_ISA */
+
+	/* Register IRQ Number. */
+	ASC_DBG1(2, "advansys_board_found: request_irq() %d\n", shost->irq);
+	/*
+	 * If request_irq() fails with the IRQF_DISABLED flag set,
+	 * then try again without the IRQF_DISABLED flag set. This
+	 * allows IRQ sharing to work even with other drivers that
+	 * do not set the IRQF_DISABLED flag.
+	 *
+	 * If IRQF_DISABLED is not set, then interrupts are enabled
+	 * before the driver interrupt function is called.
+	 */
+	if (((ret = request_irq(shost->irq, advansys_interrupt,
+				IRQF_DISABLED | (share_irq ==
+						 TRUE ?
+						 IRQF_SHARED :
+						 0), "advansys", boardp)) != 0)
+	    &&
+	    ((ret =
+	      request_irq(shost->irq, advansys_interrupt,
+			  (share_irq == TRUE ? IRQF_SHARED : 0),
+			  "advansys", boardp)) != 0)) {
+		if (ret == -EBUSY) {
+			ASC_PRINT2
+			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x already in use.\n",
+			     boardp->id, shost->irq);
+		} else if (ret == -EINVAL) {
+			ASC_PRINT2
+			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x not valid.\n",
+			     boardp->id, shost->irq);
+		} else {
+			ASC_PRINT3
+			    ("advansys_board_found: board %d: request_irq(): IRQ 0x%x failed with %d\n",
+			     boardp->id, shost->irq, ret);
+		}
+		release_region(shost->io_port, boardp->asc_n_io_port);
+		iounmap(boardp->ioremap_addr);
+		if (shost->dma_channel != NO_ISA_DMA) {
+			free_dma(shost->dma_channel);
+		}
+#ifdef CONFIG_PROC_FS
+		kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+		scsi_unregister(shost);
+		asc_board_count--;
+		return NULL;
+	}
+
+	/*
+	 * Initialize board RISC chip and enable interrupts.
+	 */
+	if (ASC_NARROW_BOARD(boardp)) {
+		ASC_DBG(2, "advansys_board_found: AscInitAsc1000Driver()\n");
+		warn_code = AscInitAsc1000Driver(asc_dvc_varp);
+		err_code = asc_dvc_varp->err_code;
+
+		if (warn_code || err_code) {
+			ASC_PRINT4
+			    ("advansys_board_found: board %d error: init_state 0x%x, warn 0x%x, error 0x%x\n",
+			     boardp->id,
+			     asc_dvc_varp->init_state, warn_code, err_code);
+		}
+	} else {
+		ADV_CARR_T *carrp;
+		int req_cnt = 0;
+		adv_req_t *reqp = NULL;
+		int sg_cnt = 0;
+
+		/*
+		 * Allocate buffer carrier structures. The total size
+		 * is about 4 KB, so allocate all at once.
+		 */
+		carrp = (ADV_CARR_T *) kmalloc(ADV_CARRIER_BUFSIZE, GFP_ATOMIC);
+		ASC_DBG1(1, "advansys_board_found: carrp 0x%lx\n", (ulong)carrp);
+
+		if (carrp == NULL) {
+			goto kmalloc_error;
+		}
+
+		/*
+		 * Allocate up to 'max_host_qng' request structures for
+		 * the Wide board. The total size is about 16 KB, so
+		 * allocate all at once. If the allocation fails decrement
+		 * and try again.
+		 */
+		for (req_cnt = adv_dvc_varp->max_host_qng;
+		     req_cnt > 0; req_cnt--) {
+
+			reqp = (adv_req_t *)
+			    kmalloc(sizeof(adv_req_t) * req_cnt, GFP_ATOMIC);
+
+			ASC_DBG3(1,
+				 "advansys_board_found: reqp 0x%lx, req_cnt %d, bytes %lu\n",
+				 (ulong)reqp, req_cnt,
+				 (ulong)sizeof(adv_req_t) * req_cnt);
+
+			if (reqp != NULL) {
+				break;
+			}
+		}
+		if (reqp == NULL) {
+			goto kmalloc_error;
+		}
+
+		/*
+		 * Allocate up to ADV_TOT_SG_BLOCK request structures for
+		 * the Wide board. Each structure is about 136 bytes.
+		 */
+		boardp->adv_sgblkp = NULL;
+		for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
+
+			sgp = (adv_sgblk_t *)
+			    kmalloc(sizeof(adv_sgblk_t), GFP_ATOMIC);
+
+			if (sgp == NULL) {
+				break;
+			}
+
+			sgp->next_sgblkp = boardp->adv_sgblkp;
+			boardp->adv_sgblkp = sgp;
+
+		}
+		ASC_DBG3(1,
+			 "advansys_board_found: sg_cnt %d * %u = %u bytes\n",
+			 sg_cnt, sizeof(adv_sgblk_t),
+			 (unsigned)(sizeof(adv_sgblk_t) * sg_cnt));
+
+		/*
+		 * If no request structures or scatter-gather structures could
+		 * be allocated, then return an error. Otherwise continue with
+		 * initialization.
+		 */
+ kmalloc_error:
+		if (carrp == NULL) {
+			ASC_PRINT1
+			    ("advansys_board_found: board %d error: failed to kmalloc() carrier buffer.\n",
+			     boardp->id);
+			err_code = ADV_ERROR;
+		} else if (reqp == NULL) {
+			kfree(carrp);
+			ASC_PRINT1
+			    ("advansys_board_found: board %d error: failed to kmalloc() adv_req_t buffer.\n",
+			     boardp->id);
+			err_code = ADV_ERROR;
+		} else if (boardp->adv_sgblkp == NULL) {
+			kfree(carrp);
+			kfree(reqp);
+			ASC_PRINT1
+			    ("advansys_board_found: board %d error: failed to kmalloc() adv_sgblk_t buffers.\n",
+			     boardp->id);
+			err_code = ADV_ERROR;
+		} else {
+
+			/* Save carrier buffer pointer. */
+			boardp->orig_carrp = carrp;
+
+			/*
+			 * Save original pointer for kfree() in case the
+			 * driver is built as a module and can be unloaded.
+			 */
+			boardp->orig_reqp = reqp;
+
+			adv_dvc_varp->carrier_buf = carrp;
+
+			/*
+			 * Point 'adv_reqp' to the request structures and
+			 * link them together.
+			 */
+			req_cnt--;
+			reqp[req_cnt].next_reqp = NULL;
+			for (; req_cnt > 0; req_cnt--) {
+				reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
+			}
+			boardp->adv_reqp = &reqp[0];
+
+			if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {
+				ASC_DBG(2,
+					"advansys_board_found: AdvInitAsc3550Driver()\n");
+				warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
+			} else if (adv_dvc_varp->chip_type ==
+				   ADV_CHIP_ASC38C0800) {
+				ASC_DBG(2,
+					"advansys_board_found: AdvInitAsc38C0800Driver()\n");
+				warn_code =
+				    AdvInitAsc38C0800Driver(adv_dvc_varp);
+			} else {
+				ASC_DBG(2,
+					"advansys_board_found: AdvInitAsc38C1600Driver()\n");
+				warn_code =
+				    AdvInitAsc38C1600Driver(adv_dvc_varp);
+			}
+			err_code = adv_dvc_varp->err_code;
+
+			if (warn_code || err_code) {
+				ASC_PRINT3
+				    ("advansys_board_found: board %d error: warn 0x%x, error 0x%x\n",
+				     boardp->id, warn_code, err_code);
+			}
+		}
+	}
+
+	if (err_code != 0) {
+		release_region(shost->io_port, boardp->asc_n_io_port);
+		if (ASC_WIDE_BOARD(boardp)) {
+			iounmap(boardp->ioremap_addr);
+			kfree(boardp->orig_carrp);
+			boardp->orig_carrp = NULL;
+			if (boardp->orig_reqp) {
+				kfree(boardp->orig_reqp);
+				boardp->orig_reqp = boardp->adv_reqp = NULL;
+			}
+			while ((sgp = boardp->adv_sgblkp) != NULL) {
+				boardp->adv_sgblkp = sgp->next_sgblkp;
+				kfree(sgp);
+			}
+		}
+		if (shost->dma_channel != NO_ISA_DMA) {
+			free_dma(shost->dma_channel);
+		}
+#ifdef CONFIG_PROC_FS
+		kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+		free_irq(shost->irq, boardp);
+		scsi_unregister(shost);
+		asc_board_count--;
+		return NULL;
+	}
+	ASC_DBG_PRT_SCSI_HOST(2, shost);
+
+	return shost;
+}
+
+/*
+ * advansys_detect()
+ *
+ * Detect function for AdvanSys adapters.
+ *
+ * Argument is a pointer to the host driver's scsi_hosts entry.
+ *
+ * Return number of adapters found.
+ *
+ * Note: Because this function is called during system initialization
+ * it must not call SCSI mid-level functions including scsi_malloc()
+ * and scsi_free().
+ */
+static int __init advansys_detect(struct scsi_host_template *tpnt)
+{
+	static int detect_called = ASC_FALSE;
+	int iop;
+	int bus;
+	int ioport = 0;
+	struct device *dev = NULL;
+#ifdef CONFIG_PCI
+	int pci_init_search = 0;
+	struct pci_dev *pci_devicep[ASC_NUM_BOARD_SUPPORTED];
+	int pci_card_cnt_max = 0;
+	int pci_card_cnt = 0;
+	struct pci_dev *pdev = NULL;
+	int pci_device_id_cnt = 0;
+	unsigned int pci_device_id[ASC_PCI_DEVICE_ID_CNT] = {
+		PCI_DEVICE_ID_ASP_1200A,
+		PCI_DEVICE_ID_ASP_ABP940,
+		PCI_DEVICE_ID_ASP_ABP940U,
+		PCI_DEVICE_ID_ASP_ABP940UW,
+		PCI_DEVICE_ID_38C0800_REV1,
+		PCI_DEVICE_ID_38C1600_REV1
+	};
+#endif /* CONFIG_PCI */
+
+	if (detect_called == ASC_FALSE) {
+		detect_called = ASC_TRUE;
+	} else {
+		printk
+		    ("AdvanSys SCSI: advansys_detect() multiple calls ignored\n");
+		return 0;
+	}
+
+	ASC_DBG(1, "advansys_detect: begin\n");
+
+	asc_board_count = 0;
+
+	/*
+	 * If I/O port probing has been modified, then verify and
+	 * clean-up the 'asc_ioport' list.
+	 */
+	if (asc_iopflag == ASC_TRUE) {
+		for (ioport = 0; ioport < ASC_NUM_IOPORT_PROBE; ioport++) {
+			ASC_DBG2(1, "advansys_detect: asc_ioport[%d] 0x%x\n",
+				 ioport, asc_ioport[ioport]);
+			if (asc_ioport[ioport] != 0) {
+				for (iop = 0; iop < ASC_IOADR_TABLE_MAX_IX;
+				     iop++) {
+					if (_asc_def_iop_base[iop] ==
+					    asc_ioport[ioport]) {
+						break;
+					}
+				}
+				if (iop == ASC_IOADR_TABLE_MAX_IX) {
+					printk
+					    ("AdvanSys SCSI: specified I/O Port 0x%X is invalid\n",
+					     asc_ioport[ioport]);
+					asc_ioport[ioport] = 0;
+				}
+			}
+		}
+		ioport = 0;
+	}
+
+	for (bus = 0; bus < ASC_NUM_BUS; bus++) {
+
+		ASC_DBG2(1, "advansys_detect: bus search type %d (%s)\n",
+			 bus, asc_bus_name[bus]);
+		iop = 0;
+
+		while (asc_board_count < ASC_NUM_BOARD_SUPPORTED) {
+
+			ASC_DBG1(2, "advansys_detect: asc_board_count %d\n",
+				 asc_board_count);
+
+			switch (asc_bus[bus]) {
+			case ASC_IS_ISA:
+			case ASC_IS_VL:
+#ifdef CONFIG_ISA
+				if (asc_iopflag == ASC_FALSE) {
+					iop =
+					    AscSearchIOPortAddr(iop,
+								asc_bus[bus]);
+				} else {
+					/*
+					 * ISA and VL I/O port scanning has either been
+					 * eliminated or limited to selected ports on
+					 * the LILO command line, /etc/lilo.conf, or
+					 * by setting variables when the module was loaded.
+					 */
+					ASC_DBG(1,
+						"advansys_detect: I/O port scanning modified\n");
+ ioport_try_again:
+					iop = 0;
+					for (; ioport < ASC_NUM_IOPORT_PROBE;
+					     ioport++) {
+						if ((iop =
+						     asc_ioport[ioport]) != 0) {
+							break;
+						}
+					}
+					if (iop) {
+						ASC_DBG1(1,
+							 "advansys_detect: probing I/O port 0x%x...\n",
+							 iop);
+						if (!request_region
+						    (iop, ASC_IOADR_GAP,
+						     "advansys")) {
+							printk
+							    ("AdvanSys SCSI: specified I/O Port 0x%X is busy\n",
+							     iop);
+							/* Don't try this I/O port twice. */
+							asc_ioport[ioport] = 0;
+							goto ioport_try_again;
+						} else if (AscFindSignature(iop)
+							   == ASC_FALSE) {
+							printk
+							    ("AdvanSys SCSI: specified I/O Port 0x%X has no adapter\n",
+							     iop);
+							/* Don't try this I/O port twice. */
+							release_region(iop,
+								       ASC_IOADR_GAP);
+							asc_ioport[ioport] = 0;
+							goto ioport_try_again;
+						} else {
+							/*
+							 * If this isn't an ISA board, then it must be
+							 * a VL board. If currently looking an ISA
+							 * board is being looked for then try for
+							 * another ISA board in 'asc_ioport'.
+							 */
+							if (asc_bus[bus] ==
+							    ASC_IS_ISA
+							    &&
+							    (AscGetChipVersion
+							     (iop,
+							      ASC_IS_ISA) &
+							     ASC_CHIP_VER_ISA_BIT)
+							    == 0) {
+								/*
+								 * Don't clear 'asc_ioport[ioport]'. Try
+								 * this board again for VL. Increment
+								 * 'ioport' past this board.
+								 */
+								ioport++;
+								release_region
+								    (iop,
+								     ASC_IOADR_GAP);
+								goto ioport_try_again;
+							}
+						}
+						/*
+						 * This board appears good, don't try the I/O port
+						 * again by clearing its value. Increment 'ioport'
+						 * for the next iteration.
+						 */
+						asc_ioport[ioport++] = 0;
+					}
+				}
+#endif /* CONFIG_ISA */
+				break;
+
+			case ASC_IS_EISA:
+#ifdef CONFIG_ISA
+				iop = AscSearchIOPortAddr(iop, asc_bus[bus]);
+#endif /* CONFIG_ISA */
+				break;
+
+			case ASC_IS_PCI:
+#ifdef CONFIG_PCI
+				if (pci_init_search == 0) {
+					int i, j;
+
+					pci_init_search = 1;
+
+					/* Find all PCI cards. */
+					while (pci_device_id_cnt <
+					       ASC_PCI_DEVICE_ID_CNT) {
+						if ((pdev =
+						     pci_find_device
+						     (PCI_VENDOR_ID_ASP,
+						      pci_device_id
+						      [pci_device_id_cnt],
+						      pdev)) == NULL) {
+							pci_device_id_cnt++;
+						} else {
+							if (pci_enable_device
+							    (pdev) == 0) {
+								pci_devicep
+								    [pci_card_cnt_max++]
+								    = pdev;
+							}
+						}
+					}
+
+					/*
+					 * Sort PCI cards in ascending order by PCI Bus, Slot,
+					 * and Device Number.
+					 */
+					for (i = 0; i < pci_card_cnt_max - 1;
+					     i++) {
+						for (j = i + 1;
+						     j < pci_card_cnt_max;
+						     j++) {
+							if ((pci_devicep[j]->
+							     bus->number <
+							     pci_devicep[i]->
+							     bus->number)
+							    ||
+							    ((pci_devicep[j]->
+							      bus->number ==
+							      pci_devicep[i]->
+							      bus->number)
+							     &&
+							     (pci_devicep[j]->
+							      devfn <
+							      pci_devicep[i]->
+							      devfn))) {
+								pdev =
+								    pci_devicep
+								    [i];
+								pci_devicep[i] =
+								    pci_devicep
+								    [j];
+								pci_devicep[j] =
+								    pdev;
+							}
+						}
+					}
+
+					pci_card_cnt = 0;
+				} else {
+					pci_card_cnt++;
+				}
+
+				if (pci_card_cnt == pci_card_cnt_max) {
+					iop = 0;
+				} else {
+					pdev = pci_devicep[pci_card_cnt];
+
+					ASC_DBG2(2,
+						 "advansys_detect: devfn %d, bus number %d\n",
+						 pdev->devfn,
+						 pdev->bus->number);
+					iop = pci_resource_start(pdev, 0);
+					ASC_DBG2(1,
+						 "advansys_detect: vendorID %X, deviceID %X\n",
+						 pdev->vendor,
+						 pdev->device);
+					ASC_DBG2(2,
+						 "advansys_detect: iop %X, irqLine %d\n",
+						 iop, pdev->irq);
+				}
+				if (pdev)
+					dev = &pdev->dev;
+
+#endif /* CONFIG_PCI */
+				break;
+
+			default:
+				ASC_PRINT1
+				    ("advansys_detect: unknown bus type: %d\n",
+				     asc_bus[bus]);
+				break;
+			}
+			ASC_DBG1(1, "advansys_detect: iop 0x%x\n", iop);
+
+			/*
+			 * Adapter not found, try next bus type.
+			 */
+			if (iop == 0) {
+				break;
+			}
+
+			advansys_board_found(iop, dev, asc_bus[bus]);
+		}
+	}
+
+	ASC_DBG1(1, "advansys_detect: done: asc_board_count %d\n",
+		 asc_board_count);
+	return asc_board_count;
+}
+
+/*
+ * advansys_release()
+ *
+ * Release resources allocated for a single AdvanSys adapter.
+ */
+static int advansys_release(struct Scsi_Host *shost)
+{
+	asc_board_t *boardp;
+
+	ASC_DBG(1, "advansys_release: begin\n");
+	boardp = ASC_BOARDP(shost);
+	free_irq(shost->irq, boardp);
+	if (shost->dma_channel != NO_ISA_DMA) {
+		ASC_DBG(1, "advansys_release: free_dma()\n");
+		free_dma(shost->dma_channel);
+	}
+	release_region(shost->io_port, boardp->asc_n_io_port);
+	if (ASC_WIDE_BOARD(boardp)) {
+		adv_sgblk_t *sgp = NULL;
+
+		iounmap(boardp->ioremap_addr);
+		kfree(boardp->orig_carrp);
+		boardp->orig_carrp = NULL;
+		if (boardp->orig_reqp) {
+			kfree(boardp->orig_reqp);
+			boardp->orig_reqp = boardp->adv_reqp = NULL;
+		}
+		while ((sgp = boardp->adv_sgblkp) != NULL) {
+			boardp->adv_sgblkp = sgp->next_sgblkp;
+			kfree(sgp);
+		}
+	}
+#ifdef CONFIG_PROC_FS
+	ASC_ASSERT(boardp->prtbuf != NULL);
+	kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+	scsi_unregister(shost);
+	ASC_DBG(1, "advansys_release: end\n");
+	return 0;
+}
+
 #ifdef CONFIG_PCI
 /* PCI Devices supported by this driver */
 static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
-	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940,
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940U,
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940UW,
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C0800_REV1,
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C1600_REV1,
-	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{ }
+	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940U,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940UW,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C0800_REV1,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C1600_REV1,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{}
 };
+
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
 #endif /* CONFIG_PCI */

commit 70c8d897763e19405a160de729e62a0e727150d2
Author: Adrian Bunk <bunk@stusta.de>
Date:   Wed May 23 14:41:35 2007 -0700

    [SCSI] advansys: cleanups
    
    - remove the unneeded advansys.h
    - remove the unused advansys_setup()
    - make needlessly global functions static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9b3303b64113..2b6689709e53 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -798,7 +798,6 @@
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
-#include "advansys.h"
 #ifdef CONFIG_PCI
 #include <linux/pci.h>
 #endif /* CONFIG_PCI */
@@ -2014,7 +2013,7 @@ STATIC int       AscSgListToQueue(int);
 STATIC void      AscEnableIsaDma(uchar);
 #endif /* CONFIG_ISA */
 STATIC ASC_DCNT  AscGetMaxDmaCount(ushort);
-
+static const char *advansys_info(struct Scsi_Host *shp);
 
 /*
  * --- Adv Library Constants and Macros
@@ -3970,10 +3969,6 @@ STATIC ushort asc_bus[ASC_NUM_BUS] __initdata = {
     ASC_IS_PCI,
 };
 
-/*
- * Used with the LILO 'advansys' option to eliminate or
- * limit I/O port probing at boot time, cf. advansys_setup().
- */
 STATIC int asc_iopflag = ASC_FALSE;
 STATIC int asc_ioport[ASC_NUM_IOPORT_PROBE] = { 0, 0, 0, 0 };
 
@@ -4055,10 +4050,6 @@ STATIC void         asc_prt_hex(char *f, uchar *, int);
 #endif /* ADVANSYS_DEBUG */
 
 
-/*
- * --- Linux 'struct scsi_host_template' and advansys_setup() Functions
- */
-
 #ifdef CONFIG_PROC_FS
 /*
  * advansys_proc_info() - /proc/scsi/advansys/[0-(ASC_NUM_BOARD_SUPPORTED-1)]
@@ -4080,7 +4071,7 @@ STATIC void         asc_prt_hex(char *f, uchar *, int);
  * if 'prtbuf' is too small it will not be overwritten. Instead the
  * user just won't get all the available statistics.
  */
-int
+static int
 advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
 		off_t offset, int length, int inout)
 {
@@ -4296,7 +4287,7 @@ advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
  * it must not call SCSI mid-level functions including scsi_malloc()
  * and scsi_free().
  */
-int __init
+static int __init
 advansys_detect(struct scsi_host_template *tpnt)
 {
     static int          detect_called = ASC_FALSE;
@@ -5428,7 +5419,7 @@ advansys_detect(struct scsi_host_template *tpnt)
  *
  * Release resources allocated for a single AdvanSys adapter.
  */
-int
+static int
 advansys_release(struct Scsi_Host *shp)
 {
     asc_board_t    *boardp;
@@ -5475,7 +5466,7 @@ advansys_release(struct Scsi_Host *shp)
  * Note: The information line should not exceed ASC_INFO_SIZE bytes,
  * otherwise the static 'info' array will be overrun.
  */
-const char *
+static const char *
 advansys_info(struct Scsi_Host *shp)
 {
     static char     info[ASC_INFO_SIZE];
@@ -5568,7 +5559,7 @@ advansys_info(struct Scsi_Host *shp)
  * This function always returns 0. Command return status is saved
  * in the 'scp' result field.
  */
-int
+static int
 advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
 {
     struct Scsi_Host    *shp;
@@ -5656,7 +5647,7 @@ advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
  * sleeping is allowed and no locking other than for host structures is
  * required. Returns SUCCESS or FAILED.
  */
-int
+static int
 advansys_reset(struct scsi_cmnd *scp)
 {
     struct Scsi_Host     *shp;
@@ -5841,7 +5832,7 @@ advansys_reset(struct scsi_cmnd *scp)
  * ip[1]: sectors
  * ip[2]: cylinders
  */
-int
+static int
 advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 		sector_t capacity, int ip[])
 {
@@ -5874,82 +5865,6 @@ advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
     return 0;
 }
 
-/*
- * advansys_setup()
- *
- * This function is called from init/main.c at boot time.
- * It it passed LILO parameters that can be set from the
- * LILO command line or in /etc/lilo.conf.
- *
- * It is used by the AdvanSys driver to either disable I/O
- * port scanning or to limit scanning to 1 - 4 I/O ports.
- * Regardless of the option setting EISA and PCI boards
- * will still be searched for and detected. This option
- * only affects searching for ISA and VL boards.
- *
- * If ADVANSYS_DEBUG is defined the driver debug level may
- * be set using the 5th (ASC_NUM_IOPORT_PROBE + 1) I/O Port.
- *
- * Examples:
- * 1. Eliminate I/O port scanning:
- *         boot: linux advansys=
- *       or
- *         boot: linux advansys=0x0
- * 2. Limit I/O port scanning to one I/O port:
- *        boot: linux advansys=0x110
- * 3. Limit I/O port scanning to four I/O ports:
- *        boot: linux advansys=0x110,0x210,0x230,0x330
- * 4. If ADVANSYS_DEBUG, limit I/O port scanning to four I/O ports and
- *    set the driver debug level to 2.
- *        boot: linux advansys=0x110,0x210,0x230,0x330,0xdeb2
- *
- * ints[0] - number of arguments
- * ints[1] - first argument
- * ints[2] - second argument
- * ...
- */
-void __init
-advansys_setup(char *str, int *ints)
-{
-    int    i;
-
-    if (asc_iopflag == ASC_TRUE) {
-        printk("AdvanSys SCSI: 'advansys' LILO option may appear only once\n");
-        return;
-    }
-
-    asc_iopflag = ASC_TRUE;
-
-    if (ints[0] > ASC_NUM_IOPORT_PROBE) {
-#ifdef ADVANSYS_DEBUG
-        if ((ints[0] == ASC_NUM_IOPORT_PROBE + 1) &&
-            (ints[ASC_NUM_IOPORT_PROBE + 1] >> 4 == 0xdeb)) {
-            asc_dbglvl = ints[ASC_NUM_IOPORT_PROBE + 1] & 0xf;
-        } else {
-#endif /* ADVANSYS_DEBUG */
-            printk("AdvanSys SCSI: only %d I/O ports accepted\n",
-                ASC_NUM_IOPORT_PROBE);
-#ifdef ADVANSYS_DEBUG
-        }
-#endif /* ADVANSYS_DEBUG */
-    }
-
-#ifdef ADVANSYS_DEBUG
-    ASC_DBG1(1, "advansys_setup: ints[0] %d\n", ints[0]);
-    for (i = 1; i < ints[0]; i++) {
-        ASC_DBG2(1, " ints[%d] 0x%x", i, ints[i]);
-    }
-    ASC_DBG(1, "\n");
-#endif /* ADVANSYS_DEBUG */
-
-    for (i = 1; i <= ints[0] && i <= ASC_NUM_IOPORT_PROBE; i++) {
-        asc_ioport[i-1] = ints[i];
-        ASC_DBG2(1, "advansys_setup: asc_ioport[%d] 0x%x\n",
-            i - 1, asc_ioport[i-1]);
-    }
-}
-
-
 /*
  * --- Loadable Driver Support
  */

commit 35d6848322364b396484b5fcc450f6b009a3dac4
Author: Ken Witherow <ken@krwtech.com>
Date:   Mon Feb 5 16:38:28 2007 -0800

    [SCSI] advansys: clean up warnings
    
    Fix typecast warnings and switch from check_region to request_region
    
    (akpm: Ken and Jeffrey Phillips Freeman <jeffreyfreeman@syncleus.com> are
    possible advansys testers)
    
    Signed-off-by: Ken Witherow <ken@krwtech.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 306bec355e45..9b3303b64113 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4403,7 +4403,7 @@ advansys_detect(struct scsi_host_template *tpnt)
                         ASC_DBG1(1,
                                 "advansys_detect: probing I/O port 0x%x...\n",
                             iop);
-                        if (check_region(iop, ASC_IOADR_GAP) != 0) {
+			if (!request_region(iop, ASC_IOADR_GAP, "advansys")){
                             printk(
 "AdvanSys SCSI: specified I/O Port 0x%X is busy\n", iop);
                             /* Don't try this I/O port twice. */
@@ -4413,6 +4413,7 @@ advansys_detect(struct scsi_host_template *tpnt)
                             printk(
 "AdvanSys SCSI: specified I/O Port 0x%X has no adapter\n", iop);
                             /* Don't try this I/O port twice. */
+			    release_region(iop, ASC_IOADR_GAP);
                             asc_ioport[ioport] = 0;
                             goto ioport_try_again;
                         } else {
@@ -4431,6 +4432,7 @@ advansys_detect(struct scsi_host_template *tpnt)
                                   * 'ioport' past this board.
                                   */
                                  ioport++;
+				 release_region(iop, ASC_IOADR_GAP);
                                  goto ioport_try_again;
                             }
                         }
@@ -9740,13 +9742,14 @@ AscSearchIOPortAddr11(
     }
     for (; i < ASC_IOADR_TABLE_MAX_IX; i++) {
         iop_base = _asc_def_iop_base[i];
-        if (check_region(iop_base, ASC_IOADR_GAP) != 0) {
+	if (!request_region(iop_base, ASC_IOADR_GAP, "advansys")){
             ASC_DBG1(1,
                "AscSearchIOPortAddr11: check_region() failed I/O port 0x%x\n",
                      iop_base);
             continue;
         }
         ASC_DBG1(1, "AscSearchIOPortAddr11: probing I/O port 0x%x\n", iop_base);
+	release_region(iop_base, ASC_IOADR_GAP);
         if (AscFindSignature(iop_base)) {
             return (iop_base);
         }

commit d8dafd8ccde06f16095234dc3addf52b511805b3
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Nov 21 13:50:47 2006 -0800

    [SCSI] advansys: wrap PCI table inside ifdef CONFIG_PCI
    
    The Advansys ISA/EISA/PCI driver has a compile error when
    CONFIG_PCI=n, so wrap the pci_device_id table inside
    ifdef CONFIG_PCI.
    
    drivers/scsi/advansys.c: At top level:
    drivers/scsi/advansys.c:18219: error: array type has incomplete element type
    drivers/scsi/advansys.c:18221: error: 'PCI_ANY_ID' undeclared here (not in a function)
    make[2]: *** [drivers/scsi/advansys.o] Error 1
    make[1]: *** [drivers/scsi] Error 2
    make: *** [drivers] Error 2
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 2b344356a29e..306bec355e45 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -18215,6 +18215,7 @@ AdvInquiryHandling(
 }
 MODULE_LICENSE("Dual BSD/GPL");
 
+#ifdef CONFIG_PCI
 /* PCI Devices supported by this driver */
 static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
@@ -18232,4 +18233,4 @@ static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
-
+#endif /* CONFIG_PCI */

commit aa7677d40072a97a861390f0ed1a8c25ce312201
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Tue Oct 10 22:44:57 2006 +0100

    [PATCH] NULL noise removal: advansys
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 587eac920790..2b344356a29e 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3951,7 +3951,7 @@ typedef struct _PCI_CONFIG_SPACE_
 
 /* Number of boards detected in system. */
 STATIC int asc_board_count = 0;
-STATIC struct Scsi_Host    *asc_host[ASC_NUM_BOARD_SUPPORTED] = { 0 };
+STATIC struct Scsi_Host    *asc_host[ASC_NUM_BOARD_SUPPORTED] = { NULL };
 
 /* Overrun buffer used by all narrow boards. */
 STATIC uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
@@ -6621,7 +6621,7 @@ adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
 	        dma_map_single(dev, scp->request_buffer,
 			       scp->request_bufflen, scp->sc_data_direction);
 	} else {
-	    scsiqp->vdata_addr = 0;
+	    scsiqp->vdata_addr = NULL;
 	    scp->SCp.dma_handle = 0;
 	}
 	scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);

commit 1e0dbafd30b2e1cd17fd141f4cfd633078524e8c
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Tue Oct 10 22:44:07 2006 +0100

    [PATCH] advansys __iomem annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 83695416b2c9..587eac920790 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3881,7 +3881,7 @@ typedef struct asc_board {
     /*
      * The following fields are used only for Wide Boards.
      */
-    void                 *ioremap_addr;         /* I/O Memory remap address. */
+    void                 __iomem *ioremap_addr; /* I/O Memory remap address. */
     ushort               ioport;                /* I/O Port address. */
     ADV_CARR_T           *orig_carrp;           /* ADV_CARR_T memory block. */
     adv_req_t            *orig_reqp;            /* adv_req_t memory block. */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 773f02e3b10b..83695416b2c9 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -3999,7 +3999,7 @@ STATIC PortAddr     _asc_def_iop_base[];
  * advansys.h contains function prototypes for functions global to Linux.
  */
 
-STATIC irqreturn_t advansys_interrupt(int, void *, struct pt_regs *);
+STATIC irqreturn_t advansys_interrupt(int, void *);
 STATIC int	  advansys_slave_configure(struct scsi_device *);
 STATIC void       asc_scsi_done_list(struct scsi_cmnd *);
 STATIC int        asc_execute_scsi_cmnd(struct scsi_cmnd *);
@@ -5997,7 +5997,7 @@ static struct scsi_host_template driver_template = {
  * an AdvanSys adapter.
  */
 STATIC irqreturn_t
-advansys_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+advansys_interrupt(int irq, void *dev_id)
 {
     ulong           flags;
     int             i;

commit 2672ea86be26353108a72a28910df4dc61cdb5e2
Author: Dave Jones <davej@redhat.com>
Date:   Wed Aug 2 17:11:49 2006 -0400

    [SCSI] advansys pci tweaks.
    
    Remove a lot of duplicate #defines from the advansys driver,
    and make them look like PCI IDs as defined elsewhere in the kernel.
    Also add a module table so that it automatically gets picked up
    by tools relying on modinfo output (like say, distro installers).
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index e32b4ab2f8fb..773f02e3b10b 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -888,10 +888,6 @@ typedef unsigned char uchar;
 #define ASC_PCI_ID2DEV(id)    (((id) >> 11) & 0x1F)
 #define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)
 #define ASC_PCI_MKID(bus, dev, func) ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))
-#define ASC_PCI_VENDORID                  0x10CD
-#define ASC_PCI_DEVICEID_1200A            0x1100
-#define ASC_PCI_DEVICEID_1200B            0x1200
-#define ASC_PCI_DEVICEID_ULTRA            0x1300
 #define ASC_PCI_REVISION_3150             0x02
 #define ASC_PCI_REVISION_3050             0x03
 
@@ -899,6 +895,14 @@ typedef unsigned char uchar;
 #define  ASC_DVCLIB_CALL_FAILED   (0)
 #define  ASC_DVCLIB_CALL_ERROR    (-1)
 
+#define PCI_VENDOR_ID_ASP		0x10cd
+#define PCI_DEVICE_ID_ASP_1200A		0x1100
+#define PCI_DEVICE_ID_ASP_ABP940	0x1200
+#define PCI_DEVICE_ID_ASP_ABP940U	0x1300
+#define PCI_DEVICE_ID_ASP_ABP940UW	0x2300
+#define PCI_DEVICE_ID_38C0800_REV1	0x2500
+#define PCI_DEVICE_ID_38C1600_REV1	0x2700
+
 /*
  * Enable CC_VERY_LONG_SG_LIST to support up to 64K element SG lists.
  * The SRB structure will have to be changed and the ASC_SRB2SCSIQ()
@@ -1492,8 +1496,6 @@ typedef struct asc_dvc_cfg {
 #define ASC_INIT_STATE_END_INQUIRY   0x0080
 #define ASC_INIT_RESET_SCSI_DONE     0x0100
 #define ASC_INIT_STATE_WITHOUT_EEP   0x8000
-#define ASC_PCI_DEVICE_ID_REV_A      0x1100
-#define ASC_PCI_DEVICE_ID_REV_B      0x1200
 #define ASC_BUG_FIX_IF_NOT_DWB       0x0001
 #define ASC_BUG_FIX_ASYN_USE_SYN     0x0002
 #define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41
@@ -2100,12 +2102,6 @@ STATIC ASC_DCNT  AscGetMaxDmaCount(ushort);
 #define ADV_NUM_PAGE_CROSSING \
     ((ADV_SG_TOTAL_MEM_SIZE + (ADV_PAGE_SIZE - 1))/ADV_PAGE_SIZE)
 
-/* a_condor.h */
-#define ADV_PCI_VENDOR_ID               0x10CD
-#define ADV_PCI_DEVICE_ID_REV_A         0x2300
-#define ADV_PCI_DEVID_38C0800_REV1      0x2500
-#define ADV_PCI_DEVID_38C1600_REV1      0x2700
-
 #define ADV_EEP_DVC_CFG_BEGIN           (0x00)
 #define ADV_EEP_DVC_CFG_END             (0x15)
 #define ADV_EEP_DVC_CTL_BEGIN           (0x16)  /* location of OEM name */
@@ -3569,14 +3565,7 @@ typedef struct scsi_cmnd     REQ, *REQP;
 #define PCI_MAX_SLOT            0x1F
 #define PCI_MAX_BUS             0xFF
 #define PCI_IOADDRESS_MASK      0xFFFE
-#define ASC_PCI_VENDORID        0x10CD
 #define ASC_PCI_DEVICE_ID_CNT   6       /* PCI Device ID count. */
-#define ASC_PCI_DEVICE_ID_1100  0x1100
-#define ASC_PCI_DEVICE_ID_1200  0x1200
-#define ASC_PCI_DEVICE_ID_1300  0x1300
-#define ASC_PCI_DEVICE_ID_2300  0x2300  /* ASC-3550 */
-#define ASC_PCI_DEVICE_ID_2500  0x2500  /* ASC-38C0800 */
-#define ASC_PCI_DEVICE_ID_2700  0x2700  /* ASC-38C1600 */
 
 #ifndef ADVANSYS_STATS
 #define ASC_STATS(shp, counter)
@@ -4330,12 +4319,12 @@ advansys_detect(struct scsi_host_template *tpnt)
     struct pci_dev      *pci_devp = NULL;
     int                 pci_device_id_cnt = 0;
     unsigned int        pci_device_id[ASC_PCI_DEVICE_ID_CNT] = {
-                                    ASC_PCI_DEVICE_ID_1100,
-                                    ASC_PCI_DEVICE_ID_1200,
-                                    ASC_PCI_DEVICE_ID_1300,
-                                    ASC_PCI_DEVICE_ID_2300,
-                                    ASC_PCI_DEVICE_ID_2500,
-                                    ASC_PCI_DEVICE_ID_2700
+                                    PCI_DEVICE_ID_ASP_1200A,
+                                    PCI_DEVICE_ID_ASP_ABP940,
+                                    PCI_DEVICE_ID_ASP_ABP940U,
+                                    PCI_DEVICE_ID_ASP_ABP940UW,
+                                    PCI_DEVICE_ID_38C0800_REV1,
+                                    PCI_DEVICE_ID_38C1600_REV1
                         };
     ADV_PADDR           pci_memory_address;
 #endif /* CONFIG_PCI */
@@ -4471,7 +4460,7 @@ advansys_detect(struct scsi_host_template *tpnt)
 
                     /* Find all PCI cards. */
                     while (pci_device_id_cnt < ASC_PCI_DEVICE_ID_CNT) {
-                        if ((pci_devp = pci_find_device(ASC_PCI_VENDORID,
+                        if ((pci_devp = pci_find_device(PCI_VENDOR_ID_ASP,
                             pci_device_id[pci_device_id_cnt], pci_devp)) ==
                             NULL) {
                             pci_device_id_cnt++;
@@ -4575,9 +4564,9 @@ advansys_detect(struct scsi_host_template *tpnt)
              */
 #ifdef CONFIG_PCI
             if (asc_bus[bus] == ASC_IS_PCI &&
-                (pci_devp->device == ASC_PCI_DEVICE_ID_2300 ||
-                 pci_devp->device == ASC_PCI_DEVICE_ID_2500 ||
-                 pci_devp->device == ASC_PCI_DEVICE_ID_2700))
+                (pci_devp->device == PCI_DEVICE_ID_ASP_ABP940UW ||
+                 pci_devp->device == PCI_DEVICE_ID_38C0800_REV1 ||
+                 pci_devp->device == PCI_DEVICE_ID_38C1600_REV1))
             {
                 boardp->flags |= ASC_IS_WIDE_BOARD;
             }
@@ -4600,11 +4589,11 @@ advansys_detect(struct scsi_host_template *tpnt)
                 adv_dvc_varp->isr_callback = adv_isr_callback;
                 adv_dvc_varp->async_callback = adv_async_callback;
 #ifdef CONFIG_PCI
-                if (pci_devp->device == ASC_PCI_DEVICE_ID_2300)
+                if (pci_devp->device == PCI_DEVICE_ID_ASP_ABP940UW)
                 {
                     ASC_DBG(1, "advansys_detect: ASC-3550\n");
                     adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;
-                } else if (pci_devp->device == ASC_PCI_DEVICE_ID_2500)
+                } else if (pci_devp->device == PCI_DEVICE_ID_38C0800_REV1)
                 {
                     ASC_DBG(1, "advansys_detect: ASC-38C0800\n");
                     adv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;
@@ -11922,7 +11911,7 @@ AscInitGetConfig(
         PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
                                     AscPCIConfigRevisionIDRegister);
 
-        if (PCIVendorID != ASC_PCI_VENDORID) {
+        if (PCIVendorID != PCI_VENDOR_ID_ASP) {
             warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
         }
         prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
@@ -11942,15 +11931,15 @@ AscInitGetConfig(
                 warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
             }
         }
-        if ((PCIDeviceID == ASC_PCI_DEVICEID_1200A) ||
-            (PCIDeviceID == ASC_PCI_DEVICEID_1200B)) {
+        if ((PCIDeviceID == PCI_DEVICE_ID_ASP_1200A) ||
+            (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940)) {
             DvcWritePCIConfigByte(asc_dvc,
                             AscPCIConfigLatencyTimer, 0x00);
             if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                 != 0x00) {
                 warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
             }
-        } else if (PCIDeviceID == ASC_PCI_DEVICEID_ULTRA) {
+        } else if (PCIDeviceID == PCI_DEVICE_ID_ASP_ABP940U) {
             if (DvcReadPCIConfigByte(asc_dvc,
                                 AscPCIConfigLatencyTimer) < 0x20) {
                 DvcWritePCIConfigByte(asc_dvc,
@@ -12037,8 +12026,8 @@ AscInitFromAscDvcVar(
         AscSetChipCfgMsw(iop_base, cfg_msw);
         if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
         } else {
-            if ((pci_device_id == ASC_PCI_DEVICE_ID_REV_A) ||
-                (pci_device_id == ASC_PCI_DEVICE_ID_REV_B)) {
+            if ((pci_device_id == PCI_DEVICE_ID_ASP_1200A) ||
+                (pci_device_id == PCI_DEVICE_ID_ASP_ABP940)) {
                 asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
                 asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
             }
@@ -14275,8 +14264,8 @@ Default_38C0800_EEPROM_Config __initdata = {
     0,                          /* 55 reserved */
     0,                          /* 56 cisptr_lsw */
     0,                          /* 57 cisprt_msw */
-    ADV_PCI_VENDOR_ID,          /* 58 subsysvid */
-    ADV_PCI_DEVID_38C0800_REV1, /* 59 subsysid */
+    PCI_VENDOR_ID_ASP,          /* 58 subsysvid */
+    PCI_DEVICE_ID_38C0800_REV1, /* 59 subsysid */
     0,                          /* 60 reserved */
     0,                          /* 61 reserved */
     0,                          /* 62 reserved */
@@ -14405,8 +14394,8 @@ Default_38C1600_EEPROM_Config __initdata = {
     0,                          /* 55 reserved */
     0,                          /* 56 cisptr_lsw */
     0,                          /* 57 cisprt_msw */
-    ADV_PCI_VENDOR_ID,          /* 58 subsysvid */
-    ADV_PCI_DEVID_38C1600_REV1, /* 59 subsysid */
+    PCI_VENDOR_ID_ASP,          /* 58 subsysvid */
+    PCI_DEVICE_ID_38C1600_REV1, /* 59 subsysid */
     0,                          /* 60 reserved */
     0,                          /* 61 reserved */
     0,                          /* 62 reserved */
@@ -18225,3 +18214,22 @@ AdvInquiryHandling(
     }
 }
 MODULE_LICENSE("Dual BSD/GPL");
+
+/* PCI Devices supported by this driver */
+static struct pci_device_id advansys_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940,
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940U,
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940UW,
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C0800_REV1,
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C1600_REV1,
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, advansys_pci_tbl);
+

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 537136457ea0..e32b4ab2f8fb 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -371,7 +371,7 @@
 
      1.5 (8/8/96):
          1. Add support for ABP-940U (PCI Ultra) adapter.
-         2. Add support for IRQ sharing by setting the SA_SHIRQ flag for
+         2. Add support for IRQ sharing by setting the IRQF_SHARED flag for
             request_irq and supplying a dev_id pointer to both request_irq()
             and free_irq().
          3. In AscSearchIOPortAddr11() restore a call to check_region() which
@@ -504,9 +504,9 @@
          3. For v2.1.93 and newer kernels use CONFIG_PCI and new PCI BIOS
             access functions.
          4. Update board serial number printing.
-         5. Try allocating an IRQ both with and without the SA_INTERRUPT
+         5. Try allocating an IRQ both with and without the IRQF_DISABLED
             flag set to allow IRQ sharing with drivers that do not set
-            the SA_INTERRUPT flag. Also display a more descriptive error
+            the IRQF_DISABLED flag. Also display a more descriptive error
             message if request_irq() fails.
          6. Update to latest Asc and Adv Libraries.
 
@@ -5202,19 +5202,19 @@ advansys_detect(struct scsi_host_template *tpnt)
             /* Register IRQ Number. */
             ASC_DBG1(2, "advansys_detect: request_irq() %d\n", shp->irq);
            /*
-            * If request_irq() fails with the SA_INTERRUPT flag set,
-            * then try again without the SA_INTERRUPT flag set. This
+            * If request_irq() fails with the IRQF_DISABLED flag set,
+            * then try again without the IRQF_DISABLED flag set. This
             * allows IRQ sharing to work even with other drivers that
-            * do not set the SA_INTERRUPT flag.
+            * do not set the IRQF_DISABLED flag.
             *
-            * If SA_INTERRUPT is not set, then interrupts are enabled
+            * If IRQF_DISABLED is not set, then interrupts are enabled
             * before the driver interrupt function is called.
             */
             if (((ret = request_irq(shp->irq, advansys_interrupt,
-                            SA_INTERRUPT | (share_irq == TRUE ? SA_SHIRQ : 0),
+                            IRQF_DISABLED | (share_irq == TRUE ? IRQF_SHARED : 0),
                             "advansys", boardp)) != 0) &&
                 ((ret = request_irq(shp->irq, advansys_interrupt,
-                            (share_irq == TRUE ? SA_SHIRQ : 0),
+                            (share_irq == TRUE ? IRQF_SHARED : 0),
                             "advansys", boardp)) != 0))
             {
                 if (ret == -EBUSY) {

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index dd9fb3d91000..537136457ea0 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -754,7 +754,6 @@
  * --- Linux Include Files
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 
 #if defined(CONFIG_X86) && !defined(CONFIG_ISA)

commit d6e05edc59ecd79e8badf440c0d295a979bdfa3e
Author: Andreas Mohr <andi@lisas.de>
Date:   Mon Jun 26 18:35:02 2006 +0200

    spelling fixes
    
    acquired (aquired)
    contiguous (contigious)
    successful (succesful, succesfull)
    surprise (suprise)
    whether (weather)
    some other misspellings
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 5ee47555a8af..dd9fb3d91000 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -12374,7 +12374,7 @@ AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
                 ASC_PRINT1(
 "AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n", i);
         } else {
-                ASC_PRINT("AscInitFromEEP: Succesfully re-wrote EEPROM.");
+                ASC_PRINT("AscInitFromEEP: Successfully re-wrote EEPROM.\n");
         }
     }
     return (warn_code);

commit c836043e708d50bb301479d0db8e0dc77d4f52ca
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Jun 25 05:48:40 2006 -0700

    [PATCH] advansys section fixes
    
    Priority: not critical.
    Mark 3 functions __init.  Saves a little memory.
    This makes these functions' calls to AdvWaitEEPCmd() (which is __init)
    be clean (i.e., eliminates text -> init -> text call chain).
    
    Fix multiple section mismatch warnings:
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet3550EEPConfig' (at offset 0x7a22) and 'AdvSet38C0800EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet3550EEPConfig' (at offset 0x7a4e) and 'AdvSet38C0800EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet3550EEPConfig' (at offset 0x7a79) and 'AdvSet38C0800EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet3550EEPConfig' (at offset 0x7aa2) and 'AdvSet38C0800EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet3550EEPConfig' (at offset 0x7abb) and 'AdvSet38C0800EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C0800EEPConfig' (at offset 0x7ae0) and 'AdvSet38C1600EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C0800EEPConfig' (at offset 0x7b0c) and 'AdvSet38C1600EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C0800EEPConfig' (at offset 0x7b37) and 'AdvSet38C1600EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C0800EEPConfig' (at offset 0x7b60) and 'AdvSet38C1600EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C0800EEPConfig' (at offset 0x7b79) and 'AdvSet38C1600EEPConfig'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C1600EEPConfig' (at offset 0x7b9e) and 'AdvExeScsiQueue'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C1600EEPConfig' (at offset 0x7bca) and 'AdvExeScsiQueue'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C1600EEPConfig' (at offset 0x7bf5) and 'AdvExeScsiQueue'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C1600EEPConfig' (at offset 0x7c1e) and 'AdvExeScsiQueue'
    WARNING: drivers/scsi/advansys.o - Section mismatch: reference to .init.text: from .text between 'AdvSet38C1600EEPConfig' (at offset 0x7c37) and 'AdvExeScsiQueue'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 2a419634b256..5ee47555a8af 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -17316,7 +17316,7 @@ AdvWaitEEPCmd(AdvPortAddr iop_base)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void
+void __init
 AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 {
     ushort *wbuf;
@@ -17383,7 +17383,7 @@ AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void
+void __init
 AdvSet38C0800EEPConfig(AdvPortAddr iop_base,
                        ADVEEP_38C0800_CONFIG *cfg_buf)
 {
@@ -17451,7 +17451,7 @@ AdvSet38C0800EEPConfig(AdvPortAddr iop_base,
 /*
  * Write the EEPROM from 'cfg_buf'.
  */
-void
+void __init
 AdvSet38C1600EEPConfig(AdvPortAddr iop_base,
                        ADVEEP_38C1600_CONFIG *cfg_buf)
 {

commit 4661e3eace2c7b8433476b5bf0ee437ab3c7dfd4
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sat Apr 29 14:27:13 2006 -0700

    [SCSI] advansys driver: limp along on x86
    
    Let people enable the advansys driver on x86-32, even though it's broken
    on other architectures due to missing DMA mapping infrastructure.
    
    It's used by Jeffrey Phillips Freeman <jeffreyfreeman@syncleus.com> and
    possibly others.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 28b93057b607..2a419634b256 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -2051,7 +2051,7 @@ STATIC ASC_DCNT  AscGetMaxDmaCount(ushort);
 #define ADV_VADDR_TO_U32   virt_to_bus
 #define ADV_U32_TO_VADDR   bus_to_virt
 
-#define AdvPortAddr  ulong              /* Virtual memory address size */
+#define AdvPortAddr  void __iomem *     /* Virtual memory address size */
 
 /*
  * Define Adv Library required memory access macros.

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index f4cfb8f29620..28b93057b607 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -114,7 +114,7 @@
           #include "advansys.h"
           #endif
 
-        and after "static Scsi_Host_Template builtin_scsi_hosts[] =":
+        and after "static struct scsi_host_template builtin_scsi_hosts[] =":
 
           #ifdef CONFIG_SCSI_ADVANSYS
           ADVANSYS,
@@ -160,7 +160,7 @@
            --- Driver Structures
            --- Driver Data
            --- Driver Function Prototypes
-           --- Linux 'Scsi_Host_Template' and advansys_setup() Functions
+           --- Linux 'struct scsi_host_template' and advansys_setup() Functions
            --- Loadable Driver Support
            --- Miscellaneous Driver Functions
            --- Functions Required by the Asc Library
@@ -4068,7 +4068,7 @@ STATIC void         asc_prt_hex(char *f, uchar *, int);
 
 
 /*
- * --- Linux 'Scsi_Host_Template' and advansys_setup() Functions
+ * --- Linux 'struct scsi_host_template' and advansys_setup() Functions
  */
 
 #ifdef CONFIG_PROC_FS

commit c9475cb0c358ff0dd473544280d92482df491913
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:26 2005 -0800

    [PATCH] kfree cleanup: drivers/scsi
    
    This is the drivers/scsi/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in drivers/scsi/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: Kai Makisara <kai.makisara@kolumbus.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 37ec5411e325..f4cfb8f29620 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -5402,10 +5402,8 @@ advansys_detect(struct scsi_host_template *tpnt)
                 release_region(shp->io_port, boardp->asc_n_io_port);
                 if (ASC_WIDE_BOARD(boardp)) {
                     iounmap(boardp->ioremap_addr);
-                    if (boardp->orig_carrp) {
-                        kfree(boardp->orig_carrp);
-                        boardp->orig_carrp = NULL;
-                    }
+                    kfree(boardp->orig_carrp);
+                    boardp->orig_carrp = NULL;
                     if (boardp->orig_reqp) {
                         kfree(boardp->orig_reqp);
                         boardp->orig_reqp = boardp->adv_reqp = NULL;
@@ -5457,10 +5455,8 @@ advansys_release(struct Scsi_Host *shp)
         adv_sgblk_t    *sgp = NULL;
 
         iounmap(boardp->ioremap_addr);
-        if (boardp->orig_carrp) {
-            kfree(boardp->orig_carrp);
-            boardp->orig_carrp = NULL;
-        }
+        kfree(boardp->orig_carrp);
+        boardp->orig_carrp = NULL;
         if (boardp->orig_reqp) {
             kfree(boardp->orig_reqp);
             boardp->orig_reqp = boardp->adv_reqp = NULL;

commit b21a41385118f9a6af3cd96ce71090c5ada52eb5
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Aug 5 21:45:40 2005 -0500

    [SCSI] add global timeout to the scsi mid-layer
    
    There are certain rogue devices (and the aic7xxx driver) that return
    BUSY or QUEUE_FULL forever.  This code will apply a global timeout (of
    the total number of retries times the per command timer) to a given
    command.  If it is exceeded, the command is completed regardless of its
    state.
    
    The patch also removes the unused field in the command: timeout and
    timeout_total.
    
    This solves the problem of detecting an endless loop in the mid-layer
    because of BUSY/QUEUE_FULL bouncing, but will not recover the device.
    In the aic7xxx case, the driver can be recovered by sending a bus reset,
    so possibly this should be tied into the error handler?
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 0fb93363eb22..37ec5411e325 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9200,8 +9200,8 @@ asc_prt_scsi_cmnd(struct scsi_cmnd *s)
         (unsigned) s->serial_number, s->retries, s->allowed);
 
     printk(
-" timeout_per_command %d, timeout_total %d, timeout %d\n",
-        s->timeout_per_command, s->timeout_total, s->timeout);
+" timeout_per_command %d\n",
+        s->timeout_per_command);
 
     printk(
 " scsi_done 0x%lx, done 0x%lx, host_scribble 0x%lx, result 0x%x\n",

commit f5ad56145d43cdb68760bba3e14655ff6ae726aa
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 19 13:40:08 2005 +0200

    [SCSI] remove scsi_cmnd->abort_reason
    
    Never used for anything but printing it out in debug routines.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index a53d43352d99..0fb93363eb22 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9192,8 +9192,8 @@ asc_prt_scsi_cmnd(struct scsi_cmnd *s)
         s->sc_data_direction, s->resid);
 
     printk(
-" use_sg %u, sglist_len %u, abort_reason 0x%x\n",
-        s->use_sg, s->sglist_len, s->abort_reason);
+" use_sg %u, sglist_len %u\n",
+        s->use_sg, s->sglist_len);
 
     printk(
 " serial_number 0x%x, retries %d, allowed %d\n",

commit 12413197eef2a29e0b9fb0fa541f5cbaeb1d3f3f
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 11 01:05:01 2005 +0200

    [SCSI] remove scsi_set_device
    
    scsi_add_host is the proper place to set the device, but people copy
    the scsi_set_device usage from older drivers again and again.
    
    note that this leaves some legacy drivers like qlogicisp/qlogicfc
    without pci association in sysfs, but they're scheduled to go away soon
    anyway.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 04cb5c405a2d..a53d43352d99 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -4556,8 +4556,6 @@ advansys_detect(struct scsi_host_template *tpnt)
                 continue;
             }
 
-	    scsi_set_device(shp, dev);
-
             /* Save a pointer to the Scsi_Host of each board found. */
             asc_host[asc_board_count++] = shp;
 

commit c6295cdf656de63d6d1123def71daba6cd91939c
Author:  <htejun@gmail.com>
Date:   Sun Apr 3 14:59:11 2005 -0500

    [PATCH] scsi: remove meaningless scsi_cmnd->serial_number_at_timeout field
    
    scsi_cmnd->serial_number_at_timeout doesn't serve any purpose
    anymore.  All serial_number == serial_number_at_timeout tests
    are always true in abort callbacks.  Kill the field.  Also, as
    ->pid always equals ->serial_number and ->serial_number
    doesn't have any special meaning anymore, update comments
    above ->serial_number accordingly.  Once we remove all uses of
    this field from all lldd's, this field should go.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index edeb333d8161..04cb5c405a2d 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9198,9 +9198,8 @@ asc_prt_scsi_cmnd(struct scsi_cmnd *s)
         s->use_sg, s->sglist_len, s->abort_reason);
 
     printk(
-" serial_number 0x%x, serial_number_at_timeout 0x%x, retries %d, allowed %d\n",
-        (unsigned) s->serial_number, (unsigned) s->serial_number_at_timeout,
-         s->retries, s->allowed);
+" serial_number 0x%x, retries %d, allowed %d\n",
+        (unsigned) s->serial_number, s->retries, s->allowed);
 
     printk(
 " timeout_per_command %d, timeout_total %d, timeout %d\n",

commit d3a933dc9851e74581f9f4c8e703e77901ae8d01
Author:  <htejun@gmail.com>
Date:   Sun Apr 3 14:55:06 2005 -0500

    [PATCH] scsi: remove unused scsi_cmnd->internal_timeout field
    
    scsi_cmnd->internal_timeout field doesn't have any meaning
    anymore.  Kill the field.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
index 9962c51dc2a7..edeb333d8161 100644
--- a/drivers/scsi/advansys.c
+++ b/drivers/scsi/advansys.c
@@ -9206,8 +9206,6 @@ asc_prt_scsi_cmnd(struct scsi_cmnd *s)
 " timeout_per_command %d, timeout_total %d, timeout %d\n",
         s->timeout_per_command, s->timeout_total, s->timeout);
 
-    printk(" internal_timeout %u\n", s->internal_timeout);
-
     printk(
 " scsi_done 0x%lx, done 0x%lx, host_scribble 0x%lx, result 0x%x\n",
         (ulong) s->scsi_done, (ulong) s->done,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c
new file mode 100644
index 000000000000..9962c51dc2a7
--- /dev/null
+++ b/drivers/scsi/advansys.c
@@ -0,0 +1,18237 @@
+#define ASC_VERSION "3.3K"    /* AdvanSys Driver Version */
+
+/*
+ * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters
+ *
+ * Copyright (c) 1995-2000 Advanced System Products, Inc.
+ * Copyright (c) 2000-2001 ConnectCom Solutions, Inc.
+ * All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that redistributions of source
+ * code retain the above copyright notice and this comment without
+ * modification.
+ *
+ * As of March 8, 2000 Advanced System Products, Inc. (AdvanSys)
+ * changed its name to ConnectCom Solutions, Inc.
+ *
+ */
+
+/*
+
+  Documentation for the AdvanSys Driver
+
+  A. Linux Kernels Supported by this Driver
+  B. Adapters Supported by this Driver
+  C. Linux source files modified by AdvanSys Driver
+  D. Source Comments
+  E. Driver Compile Time Options and Debugging
+  F. Driver LILO Option
+  G. Tests to run before releasing new driver
+  H. Release History
+  I. Known Problems/Fix List
+  J. Credits (Chronological Order)
+
+  A. Linux Kernels Supported by this Driver
+
+     This driver has been tested in the following Linux kernels: v2.2.18
+     v2.4.0. The driver is supported on v2.2 and v2.4 kernels and on x86,
+     alpha, and PowerPC platforms.
+
+  B. Adapters Supported by this Driver
+
+     AdvanSys (Advanced System Products, Inc.) manufactures the following
+     RISC-based, Bus-Mastering, Fast (10 Mhz) and Ultra (20 Mhz) Narrow
+     (8-bit transfer) SCSI Host Adapters for the ISA, EISA, VL, and PCI
+     buses and RISC-based, Bus-Mastering, Ultra (20 Mhz) Wide (16-bit
+     transfer) SCSI Host Adapters for the PCI bus.
+
+     The CDB counts below indicate the number of SCSI CDB (Command
+     Descriptor Block) requests that can be stored in the RISC chip
+     cache and board LRAM. A CDB is a single SCSI command. The driver
+     detect routine will display the number of CDBs available for each
+     adapter detected. The number of CDBs used by the driver can be
+     lowered in the BIOS by changing the 'Host Queue Size' adapter setting.
+
+     Laptop Products:
+        ABP-480 - Bus-Master CardBus (16 CDB) (2.4 kernel and greater)
+
+     Connectivity Products:
+        ABP510/5150 - Bus-Master ISA (240 CDB)
+        ABP5140 - Bus-Master ISA PnP (16 CDB)
+        ABP5142 - Bus-Master ISA PnP with floppy (16 CDB)
+        ABP902/3902 - Bus-Master PCI (16 CDB)
+        ABP3905 - Bus-Master PCI (16 CDB)
+        ABP915 - Bus-Master PCI (16 CDB)
+        ABP920 - Bus-Master PCI (16 CDB)
+        ABP3922 - Bus-Master PCI (16 CDB)
+        ABP3925 - Bus-Master PCI (16 CDB)
+        ABP930 - Bus-Master PCI (16 CDB)
+        ABP930U - Bus-Master PCI Ultra (16 CDB)
+        ABP930UA - Bus-Master PCI Ultra (16 CDB)
+        ABP960 - Bus-Master PCI MAC/PC (16 CDB)
+        ABP960U - Bus-Master PCI MAC/PC Ultra (16 CDB)
+
+     Single Channel Products:
+        ABP542 - Bus-Master ISA with floppy (240 CDB)
+        ABP742 - Bus-Master EISA (240 CDB)
+        ABP842 - Bus-Master VL (240 CDB)
+        ABP940 - Bus-Master PCI (240 CDB)
+        ABP940U - Bus-Master PCI Ultra (240 CDB)
+        ABP940UA/3940UA - Bus-Master PCI Ultra (240 CDB)
+        ABP970 - Bus-Master PCI MAC/PC (240 CDB)
+        ABP970U - Bus-Master PCI MAC/PC Ultra (240 CDB)
+        ABP3960UA - Bus-Master PCI MAC/PC Ultra (240 CDB)
+        ABP940UW/3940UW - Bus-Master PCI Ultra-Wide (253 CDB)
+        ABP970UW - Bus-Master PCI MAC/PC Ultra-Wide (253 CDB)
+        ABP3940U2W - Bus-Master PCI LVD/Ultra2-Wide (253 CDB)
+
+     Multi-Channel Products:
+        ABP752 - Dual Channel Bus-Master EISA (240 CDB Per Channel)
+        ABP852 - Dual Channel Bus-Master VL (240 CDB Per Channel)
+        ABP950 - Dual Channel Bus-Master PCI (240 CDB Per Channel)
+        ABP950UW - Dual Channel Bus-Master PCI Ultra-Wide (253 CDB Per Channel)
+        ABP980 - Four Channel Bus-Master PCI (240 CDB Per Channel)
+        ABP980U - Four Channel Bus-Master PCI Ultra (240 CDB Per Channel)
+        ABP980UA/3980UA - Four Channel Bus-Master PCI Ultra (16 CDB Per Chan.)
+        ABP3950U2W - Bus-Master PCI LVD/Ultra2-Wide and Ultra-Wide (253 CDB)
+        ABP3950U3W - Bus-Master PCI Dual LVD2/Ultra3-Wide (253 CDB)
+
+  C. Linux source files modified by AdvanSys Driver
+
+     This section for historical purposes documents the changes
+     originally made to the Linux kernel source to add the advansys
+     driver. As Linux has changed some of these files have also
+     been modified.
+
+     1. linux/arch/i386/config.in:
+
+          bool 'AdvanSys SCSI support' CONFIG_SCSI_ADVANSYS y
+
+     2. linux/drivers/scsi/hosts.c:
+
+          #ifdef CONFIG_SCSI_ADVANSYS
+          #include "advansys.h"
+          #endif
+
+        and after "static Scsi_Host_Template builtin_scsi_hosts[] =":
+
+          #ifdef CONFIG_SCSI_ADVANSYS
+          ADVANSYS,
+          #endif
+
+     3. linux/drivers/scsi/Makefile:
+
+          ifdef CONFIG_SCSI_ADVANSYS
+          SCSI_SRCS := $(SCSI_SRCS) advansys.c
+          SCSI_OBJS := $(SCSI_OBJS) advansys.o
+          else
+          SCSI_MODULE_OBJS := $(SCSI_MODULE_OBJS) advansys.o
+          endif
+
+     4. linux/init/main.c:
+
+          extern void advansys_setup(char *str, int *ints);
+
+        and add the following lines to the bootsetups[] array.
+
+          #ifdef CONFIG_SCSI_ADVANSYS
+             { "advansys=", advansys_setup },
+          #endif
+
+  D. Source Comments
+
+     1. Use tab stops set to 4 for the source files. For vi use 'se tabstops=4'.
+
+     2. This driver should be maintained in multiple files. But to make
+        it easier to include with Linux and to follow Linux conventions,
+        the whole driver is maintained in the source files advansys.h and
+        advansys.c. In this file logical sections of the driver begin with
+        a comment that contains '---'. The following are the logical sections
+        of the driver below.
+
+           --- Linux Version
+           --- Linux Include File
+           --- Driver Options
+           --- Debugging Header
+           --- Asc Library Constants and Macros
+           --- Adv Library Constants and Macros
+           --- Driver Constants and Macros
+           --- Driver Structures
+           --- Driver Data
+           --- Driver Function Prototypes
+           --- Linux 'Scsi_Host_Template' and advansys_setup() Functions
+           --- Loadable Driver Support
+           --- Miscellaneous Driver Functions
+           --- Functions Required by the Asc Library
+           --- Functions Required by the Adv Library
+           --- Tracing and Debugging Functions
+           --- Asc Library Functions
+           --- Adv Library Functions
+
+     3. The string 'XXX' is used to flag code that needs to be re-written
+        or that contains a problem that needs to be addressed.
+
+     4. I have stripped comments from and reformatted the source for the
+        Asc Library and Adv Library to reduce the size of this file. This
+        source can be found under the following headings. The Asc Library
+        is used to support Narrow Boards. The Adv Library is used to
+        support Wide Boards.
+
+           --- Asc Library Constants and Macros
+           --- Adv Library Constants and Macros
+           --- Asc Library Functions
+           --- Adv Library Functions
+
+  E. Driver Compile Time Options and Debugging
+
+     In this source file the following constants can be defined. They are
+     defined in the source below. Both of these options are enabled by
+     default.
+
+     1. ADVANSYS_ASSERT - Enable driver assertions (Def: Enabled)
+
+        Enabling this option adds assertion logic statements to the
+        driver. If an assertion fails a message will be displayed to
+        the console, but the system will continue to operate. Any
+        assertions encountered should be reported to the person
+        responsible for the driver. Assertion statements may proactively
+        detect problems with the driver and facilitate fixing these
+        problems. Enabling assertions will add a small overhead to the
+        execution of the driver.
+
+     2. ADVANSYS_DEBUG - Enable driver debugging (Def: Disabled)
+
+        Enabling this option adds tracing functions to the driver and
+        the ability to set a driver tracing level at boot time. This
+        option will also export symbols not required outside the driver to
+        the kernel name space. This option is very useful for debugging
+        the driver, but it will add to the size of the driver execution
+        image and add overhead to the execution of the driver.
+
+        The amount of debugging output can be controlled with the global
+        variable 'asc_dbglvl'. The higher the number the more output. By
+        default the debug level is 0.
+
+        If the driver is loaded at boot time and the LILO Driver Option
+        is included in the system, the debug level can be changed by
+        specifying a 5th (ASC_NUM_IOPORT_PROBE + 1) I/O Port. The
+        first three hex digits of the pseudo I/O Port must be set to
+        'deb' and the fourth hex digit specifies the debug level: 0 - F.
+        The following command line will look for an adapter at 0x330
+        and set the debug level to 2.
+
+           linux advansys=0x330,0,0,0,0xdeb2
+
+        If the driver is built as a loadable module this variable can be
+        defined when the driver is loaded. The following insmod command
+        will set the debug level to one.
+
+           insmod advansys.o asc_dbglvl=1
+
+        Debugging Message Levels:
+           0: Errors Only
+           1: High-Level Tracing
+           2-N: Verbose Tracing
+
+        To enable debug output to console, please make sure that:
+
+        a. System and kernel logging is enabled (syslogd, klogd running).
+        b. Kernel messages are routed to console output. Check
+           /etc/syslog.conf for an entry similar to this:
+
+                kern.*                  /dev/console
+
+        c. klogd is started with the appropriate -c parameter
+           (e.g. klogd -c 8)
+
+        This will cause printk() messages to be be displayed on the
+        current console. Refer to the klogd(8) and syslogd(8) man pages
+        for details.
+
+        Alternatively you can enable printk() to console with this
+        program. However, this is not the 'official' way to do this.
+        Debug output is logged in /var/log/messages.
+
+          main()
+          {
+                  syscall(103, 7, 0, 0);
+          }
+
+        Increasing LOG_BUF_LEN in kernel/printk.c to something like
+        40960 allows more debug messages to be buffered in the kernel
+        and written to the console or log file.
+
+     3. ADVANSYS_STATS - Enable statistics (Def: Enabled >= v1.3.0)
+
+        Enabling this option adds statistics collection and display
+        through /proc to the driver. The information is useful for
+        monitoring driver and device performance. It will add to the
+        size of the driver execution image and add minor overhead to
+        the execution of the driver.
+
+        Statistics are maintained on a per adapter basis. Driver entry
+        point call counts and transfer size counts are maintained.
+        Statistics are only available for kernels greater than or equal
+        to v1.3.0 with the CONFIG_PROC_FS (/proc) file system configured.
+
+        AdvanSys SCSI adapter files have the following path name format:
+
+           /proc/scsi/advansys/[0-(ASC_NUM_BOARD_SUPPORTED-1)]
+
+        This information can be displayed with cat. For example:
+
+           cat /proc/scsi/advansys/0
+
+        When ADVANSYS_STATS is not defined the AdvanSys /proc files only
+        contain adapter and device configuration information.
+
+  F. Driver LILO Option
+
+     If init/main.c is modified as described in the 'Directions for Adding
+     the AdvanSys Driver to Linux' section (B.4.) above, the driver will
+     recognize the 'advansys' LILO command line and /etc/lilo.conf option.
+     This option can be used to either disable I/O port scanning or to limit
+     scanning to 1 - 4 I/O ports. Regardless of the option setting EISA and
+     PCI boards will still be searched for and detected. This option only
+     affects searching for ISA and VL boards.
+
+     Examples:
+       1. Eliminate I/O port scanning:
+            boot: linux advansys=
+              or
+            boot: linux advansys=0x0
+       2. Limit I/O port scanning to one I/O port:
+            boot: linux advansys=0x110
+       3. Limit I/O port scanning to four I/O ports:
+            boot: linux advansys=0x110,0x210,0x230,0x330
+
+     For a loadable module the same effect can be achieved by setting
+     the 'asc_iopflag' variable and 'asc_ioport' array when loading
+     the driver, e.g.
+
+           insmod advansys.o asc_iopflag=1 asc_ioport=0x110,0x330
+
+     If ADVANSYS_DEBUG is defined a 5th (ASC_NUM_IOPORT_PROBE + 1)
+     I/O Port may be added to specify the driver debug level. Refer to
+     the 'Driver Compile Time Options and Debugging' section above for
+     more information.
+
+  G. Tests to run before releasing new driver
+
+     1. In the supported kernels verify there are no warning or compile
+        errors when the kernel is built as both a driver and as a module
+        and with the following options:
+
+        ADVANSYS_DEBUG - enabled and disabled
+        CONFIG_SMP - enabled and disabled
+        CONFIG_PROC_FS - enabled and disabled
+
+     2. Run tests on an x86, alpha, and PowerPC with at least one narrow
+        card and one wide card attached to a hard disk and CD-ROM drive:
+        fdisk, mkfs, fsck, bonnie, copy/compare test from the
+        CD-ROM to the hard drive.
+
+  H. Release History
+
+     BETA-1.0 (12/23/95):
+         First Release
+
+     BETA-1.1 (12/28/95):
+         1. Prevent advansys_detect() from being called twice.
+         2. Add LILO 0xdeb[0-f] option to set 'asc_dbglvl'.
+
+     1.2 (1/12/96):
+         1. Prevent re-entrancy in the interrupt handler which
+            resulted in the driver hanging Linux.
+         2. Fix problem that prevented ABP-940 cards from being
+            recognized on some PCI motherboards.
+         3. Add support for the ABP-5140 PnP ISA card.
+         4. Fix check condition return status.
+         5. Add conditionally compiled code for Linux v1.3.X.
+
+     1.3 (2/23/96):
+         1. Fix problem in advansys_biosparam() that resulted in the
+            wrong drive geometry being returned for drives > 1GB with
+            extended translation enabled.
+         2. Add additional tracing during device initialization.
+         3. Change code that only applies to ISA PnP adapter.
+         4. Eliminate 'make dep' warning.
+         5. Try to fix problem with handling resets by increasing their
+            timeout value.
+
+     1.4 (5/8/96):
+         1. Change definitions to eliminate conflicts with other subsystems.
+         2. Add versioning code for the shared interrupt changes.
+         3. Eliminate problem in asc_rmqueue() with iterating after removing
+            a request.
+         4. Remove reset request loop problem from the "Known Problems or
+            Issues" section. This problem was isolated and fixed in the
+            mid-level SCSI driver.
+
+     1.5 (8/8/96):
+         1. Add support for ABP-940U (PCI Ultra) adapter.
+         2. Add support for IRQ sharing by setting the SA_SHIRQ flag for
+            request_irq and supplying a dev_id pointer to both request_irq()
+            and free_irq().
+         3. In AscSearchIOPortAddr11() restore a call to check_region() which
+            should be used before I/O port probing.
+         4. Fix bug in asc_prt_hex() which resulted in the displaying
+            the wrong data.
+         5. Incorporate miscellaneous Asc Library bug fixes and new microcode.
+         6. Change driver versioning to be specific to each Linux sub-level.
+         7. Change statistics gathering to be per adapter instead of global
+            to the driver.
+         8. Add more information and statistics to the adapter /proc file:
+            /proc/scsi/advansys[0...].
+         9. Remove 'cmd_per_lun' from the "Known Problems or Issues" list.
+            This problem has been addressed with the SCSI mid-level changes
+            made in v1.3.89. The advansys_select_queue_depths() function
+            was added for the v1.3.89 changes.
+
+     1.6 (9/10/96):
+         1. Incorporate miscellaneous Asc Library bug fixes and new microcode.
+
+     1.7 (9/25/96):
+         1. Enable clustering and optimize the setting of the maximum number
+            of scatter gather elements for any particular board. Clustering
+            increases CPU utilization, but results in a relatively larger
+            increase in I/O throughput.
+         2. Improve the performance of the request queuing functions by
+            adding a last pointer to the queue structure.
+         3. Correct problems with reset and abort request handling that
+            could have hung or crashed Linux.
+         4. Add more information to the adapter /proc file:
+            /proc/scsi/advansys[0...].
+         5. Remove the request timeout issue form the driver issues list.
+         6. Miscellaneous documentation additions and changes.
+
+     1.8 (10/4/96):
+         1. Make changes to handle the new v2.1.0 kernel memory mapping
+            in which a kernel virtual address may not be equivalent to its
+            bus or DMA memory address.
+         2. Change abort and reset request handling to make it yet even
+            more robust.
+         3. Try to mitigate request starvation by sending ordered requests
+            to heavily loaded, tag queuing enabled devices.
+         4. Maintain statistics on request response time.
+         5. Add request response time statistics and other information to
+            the adapter /proc file: /proc/scsi/advansys[0...].
+
+     1.9 (10/21/96):
+         1. Add conditionally compiled code (ASC_QUEUE_FLOW_CONTROL) to
+            make use of mid-level SCSI driver device queue depth flow
+            control mechanism. This will eliminate aborts caused by a
+            device being unable to keep up with requests and eliminate
+            repeat busy or QUEUE FULL status returned by a device.
+         2. Incorporate miscellaneous Asc Library bug fixes.
+         3. To allow the driver to work in kernels with broken module
+            support set 'cmd_per_lun' if the driver is compiled as a
+            module. This change affects kernels v1.3.89 to present.
+         4. Remove PCI BIOS address from the driver banner. The PCI BIOS
+            is relocated by the motherboard BIOS and its new address can
+            not be determined by the driver.
+         5. Add mid-level SCSI queue depth information to the adapter
+            /proc file: /proc/scsi/advansys[0...].
+
+     2.0 (11/14/96):
+         1. Change allocation of global structures used for device
+            initialization to guarantee they are in DMA-able memory.
+            Previously when the driver was loaded as a module these
+            structures might not have been in DMA-able memory, causing
+            device initialization to fail.
+
+     2.1 (12/30/96):
+         1. In advansys_reset(), if the request is a synchronous reset
+            request, even if the request serial number has changed, then
+            complete the request.
+         2. Add Asc Library bug fixes including new microcode.
+         3. Clear inquiry buffer before using it.
+         4. Correct ifdef typo.
+
+     2.2 (1/15/97):
+         1. Add Asc Library bug fixes including new microcode.
+         2. Add synchronous data transfer rate information to the
+            adapter /proc file: /proc/scsi/advansys[0...].
+         3. Change ADVANSYS_DEBUG to be disabled by default. This
+            will reduce the size of the driver image, eliminate execution
+            overhead, and remove unneeded symbols from the kernel symbol
+            space that were previously added by the driver.
+         4. Add new compile-time option ADVANSYS_ASSERT for assertion
+            code that used to be defined within ADVANSYS_DEBUG. This
+            option is enabled by default.
+
+     2.8 (5/26/97):
+         1. Change version number to 2.8 to synchronize the Linux driver
+            version numbering with other AdvanSys drivers.
+         2. Reformat source files without tabs to present the same view
+            of the file to everyone regardless of the editor tab setting
+            being used.
+         3. Add Asc Library bug fixes.
+
+     3.1A (1/8/98):
+         1. Change version number to 3.1 to indicate that support for
+            Ultra-Wide adapters (ABP-940UW) is included in this release.
+         2. Add Asc Library (Narrow Board) bug fixes.
+         3. Report an underrun condition with the host status byte set
+            to DID_UNDERRUN. Currently DID_UNDERRUN is defined to 0 which
+            causes the underrun condition to be ignored. When Linux defines
+            its own DID_UNDERRUN the constant defined in this file can be
+            removed.
+         4. Add patch to AscWaitTixISRDone().
+         5. Add support for up to 16 different AdvanSys host adapter SCSI
+            channels in one system. This allows four cards with four channels
+            to be used in one system.
+
+     3.1B (1/9/98):
+         1. Handle that PCI register base addresses are not always page
+            aligned even though ioremap() requires that the address argument
+            be page aligned.
+
+     3.1C (1/10/98):
+         1. Update latest BIOS version checked for from the /proc file.
+         2. Don't set microcode SDTR variable at initialization. Instead
+            wait until device capabilities have been detected from an Inquiry
+            command.
+
+     3.1D (1/21/98):
+         1. Improve performance when the driver is compiled as module by
+            allowing up to 64 scatter-gather elements instead of 8.
+
+     3.1E (5/1/98):
+         1. Set time delay in AscWaitTixISRDone() to 1000 ms.
+         2. Include SMP locking changes.
+         3. For v2.1.93 and newer kernels use CONFIG_PCI and new PCI BIOS
+            access functions.
+         4. Update board serial number printing.
+         5. Try allocating an IRQ both with and without the SA_INTERRUPT
+            flag set to allow IRQ sharing with drivers that do not set
+            the SA_INTERRUPT flag. Also display a more descriptive error
+            message if request_irq() fails.
+         6. Update to latest Asc and Adv Libraries.
+
+     3.2A (7/22/99):
+         1. Update Adv Library to 4.16 which includes support for
+            the ASC38C0800 (Ultra2/LVD) IC.
+
+     3.2B (8/23/99):
+         1. Correct PCI compile time option for v2.1.93 and greater
+            kernels, advansys_info() string, and debug compile time
+            option.
+         2. Correct DvcSleepMilliSecond() for v2.1.0 and greater
+            kernels. This caused an LVD detection/BIST problem problem
+            among other things.
+         3. Sort PCI cards by PCI Bus, Slot, Function ascending order
+            to be consistent with the BIOS.
+         4. Update to Asc Library S121 and Adv Library 5.2.
+
+     3.2C (8/24/99):
+         1. Correct PCI card detection bug introduced in 3.2B that
+            prevented PCI cards from being detected in kernels older
+            than v2.1.93.
+
+     3.2D (8/26/99):
+         1. Correct /proc device synchronous speed information display.
+            Also when re-negotiation is pending for a target device
+            note this condition with an * and footnote.
+         2. Correct initialization problem with Ultra-Wide cards that
+            have a pre-3.2 BIOS. A microcode variable changed locations
+            in 3.2 and greater BIOSes which caused WDTR to be attempted
+            erroneously with drives that don't support WDTR.
+
+     3.2E (8/30/99):
+         1. Fix compile error caused by v2.3.13 PCI structure change.
+         2. Remove field from ASCEEP_CONFIG that resulted in an EEPROM
+            checksum error for ISA cards.
+         3. Remove ASC_QUEUE_FLOW_CONTROL conditional code. The mid-level
+            SCSI changes that it depended on were never included in Linux.
+
+     3.2F (9/3/99):
+         1. Handle new initial function code added in v2.3.16 for all
+            driver versions.
+
+     3.2G (9/8/99):
+         1. Fix PCI board detection in v2.3.13 and greater kernels.
+         2. Fix comiple errors in v2.3.X with debugging enabled.
+
+     3.2H (9/13/99):
+         1. Add 64-bit address, long support for Alpha and UltraSPARC.
+            The driver has been verified to work on an Alpha system.
+         2. Add partial byte order handling support for Power PC and
+            other big-endian platforms. This support has not yet been
+            completed or verified.
+         3. For wide boards replace block zeroing of request and
+            scatter-gather structures with individual field initialization
+            to improve performance.
+         4. Correct and clarify ROM BIOS version detection.
+
+     3.2I (10/8/99):
+         1. Update to Adv Library 5.4.
+         2. Add v2.3.19 underrun reporting to asc_isr_callback() and
+            adv_isr_callback().  Remove DID_UNDERRUN constant and other
+            no longer needed code that previously documented the lack
+            of underrun handling.
+
+     3.2J (10/14/99):
+         1. Eliminate compile errors for v2.0 and earlier kernels.
+
+     3.2K (11/15/99):
+         1. Correct debug compile error in asc_prt_adv_scsi_req_q().
+         2. Update Adv Library to 5.5.
+         3. Add ifdef handling for /proc changes added in v2.3.28.
+         4. Increase Wide board scatter-gather list maximum length to
+            255 when the driver is compiled into the kernel.
+
+     3.2L (11/18/99):
+         1. Fix bug in adv_get_sglist() that caused an assertion failure
+            at line 7475. The reqp->sgblkp pointer must be initialized
+            to NULL in adv_get_sglist().
+
+     3.2M (11/29/99):
+         1. Really fix bug in adv_get_sglist().
+         2. Incorporate v2.3.29 changes into driver.
+
+     3.2N (4/1/00):
+         1. Add CONFIG_ISA ifdef code.
+         2. Include advansys_interrupts_enabled name change patch.
+         3. For >= v2.3.28 use new SCSI error handling with new function
+            advansys_eh_bus_reset(). Don't include an abort function
+            because of base library limitations.
+         4. For >= v2.3.28 use per board lock instead of io_request_lock.
+         5. For >= v2.3.28 eliminate advansys_command() and
+            advansys_command_done().
+         6. Add some changes for PowerPC (Big Endian) support, but it isn't
+            working yet.
+         7. Fix "nonexistent resource free" problem that occurred on a module
+            unload for boards with an I/O space >= 255. The 'n_io_port' field
+            is only one byte and can not be used to hold an ioport length more
+            than 255.
+
+     3.3A (4/4/00):
+         1. Update to Adv Library 5.8.
+         2. For wide cards add support for CDBs up to 16 bytes.
+         3. Eliminate warnings when CONFIG_PROC_FS is not defined.
+
+     3.3B (5/1/00):
+         1. Support for PowerPC (Big Endian) wide cards. Narrow cards
+            still need work.
+         2. Change bitfields to shift and mask access for endian
+            portability.
+
+     3.3C (10/13/00):
+         1. Update for latest 2.4 kernel.
+         2. Test ABP-480 CardBus support in 2.4 kernel - works!
+         3. Update to Asc Library S123.
+         4. Update to Adv Library 5.12.
+
+     3.3D (11/22/00):
+         1. Update for latest 2.4 kernel.
+         2. Create patches for 2.2 and 2.4 kernels.
+
+     3.3E (1/9/01):
+         1. Now that 2.4 is released remove ifdef code for kernel versions
+            less than 2.2. The driver is now only supported in kernels 2.2,
+            2.4, and greater.
+         2. Add code to release and acquire the io_request_lock in
+            the driver entrypoint functions: advansys_detect and
+            advansys_queuecommand. In kernel 2.4 the SCSI mid-level driver
+            still holds the io_request_lock on entry to SCSI low-level drivers.
+            This was supposed to be removed before 2.4 was released but never
+            happened. When the mid-level SCSI driver is changed all references
+            to the io_request_lock should be removed from the driver.
+         3. Simplify error handling by removing advansys_abort(),
+            AscAbortSRB(), AscResetDevice(). SCSI bus reset requests are
+            now handled by resetting the SCSI bus and fully re-initializing
+            the chip. This simple method of error recovery has proven to work
+            most reliably after attempts at different methods. Also now only
+            support the "new" error handling method and remove the obsolete
+            error handling interface.
+         4. Fix debug build errors.
+
+     3.3F (1/24/01):
+         1. Merge with ConnectCom version from Andy Kellner which
+            updates Adv Library to 5.14.
+         2. Make PowerPC (Big Endian) work for narrow cards and
+            fix problems writing EEPROM for wide cards.
+         3. Remove interrupts_enabled assertion function.
+
+     3.3G (2/16/01):
+         1. Return an error from narrow boards if passed a 16 byte
+            CDB. The wide board can already handle 16 byte CDBs.
+
+     3.3GJ (4/15/02):
+	 1. hacks for lk 2.5 series (D. Gilbert)
+
+     3.3GJD (10/14/02):
+         1. change select_queue_depths to slave_configure
+	 2. make cmd_per_lun be sane again
+
+     3.3K [2004/06/24]:
+         1. continuing cleanup for lk 2.6 series
+         2. Fix problem in lk 2.6.7-bk2 that broke PCI wide cards
+         3. Fix problem that oopsed ISA cards
+
+  I. Known Problems/Fix List (XXX)
+
+     1. Need to add memory mapping workaround. Test the memory mapping.
+        If it doesn't work revert to I/O port access. Can a test be done
+        safely?
+     2. Handle an interrupt not working. Keep an interrupt counter in
+        the interrupt handler. In the timeout function if the interrupt
+        has not occurred then print a message and run in polled mode.
+     3. Allow bus type scanning order to be changed.
+     4. Need to add support for target mode commands, cf. CAM XPT.
+
+  J. Credits (Chronological Order)
+
+     Bob Frey <bfrey@turbolinux.com.cn> wrote the AdvanSys SCSI driver
+     and maintained it up to 3.3F. He continues to answer questions
+     and help maintain the driver.
+
+     Nathan Hartwell <mage@cdc3.cdc.net> provided the directions and
+     basis for the Linux v1.3.X changes which were included in the
+     1.2 release.
+
+     Thomas E Zerucha <zerucha@shell.portal.com> pointed out a bug
+     in advansys_biosparam() which was fixed in the 1.3 release.
+
+     Erik Ratcliffe <erik@caldera.com> has done testing of the
+     AdvanSys driver in the Caldera releases.
+
+     Rik van Riel <H.H.vanRiel@fys.ruu.nl> provided a patch to
+     AscWaitTixISRDone() which he found necessary to make the
+     driver work with a SCSI-1 disk.
+
+     Mark Moran <mmoran@mmoran.com> has helped test Ultra-Wide
+     support in the 3.1A driver.
+
+     Doug Gilbert <dgilbert@interlog.com> has made changes and
+     suggestions to improve the driver and done a lot of testing.
+
+     Ken Mort <ken@mort.net> reported a DEBUG compile bug fixed
+     in 3.2K.
+
+     Tom Rini <trini@kernel.crashing.org> provided the CONFIG_ISA
+     patch and helped with PowerPC wide and narrow board support.
+
+     Philip Blundell <philb@gnu.org> provided an
+     advansys_interrupts_enabled patch.
+
+     Dave Jones <dave@denial.force9.co.uk> reported the compiler
+     warnings generated when CONFIG_PROC_FS was not defined in
+     the 3.2M driver.
+
+     Jerry Quinn <jlquinn@us.ibm.com> fixed PowerPC support (endian
+     problems) for wide cards.
+
+     Bryan Henderson <bryanh@giraffe-data.com> helped debug narrow
+     card error handling.
+
+     Manuel Veloso <veloso@pobox.com> worked hard on PowerPC narrow
+     board support and fixed a bug in AscGetEEPConfig().
+
+     Arnaldo Carvalho de Melo <acme@conectiva.com.br> made
+     save_flags/restore_flags changes.
+
+     Andy Kellner <AKellner@connectcom.net> continues the Advansys SCSI
+     driver development for ConnectCom (Version > 3.3F).
+
+  K. ConnectCom (AdvanSys) Contact Information
+
+     Mail:                   ConnectCom Solutions, Inc.
+                             1150 Ringwood Court
+                             San Jose, CA 95131
+     Operator/Sales:         1-408-383-9400
+     FAX:                    1-408-383-9612
+     Tech Support:           1-408-467-2930
+     Tech Support E-Mail:    linux@connectcom.net
+     FTP Site:               ftp.connectcom.net (login: anonymous)
+     Web Site:               http://www.connectcom.net
+
+*/
+
+/*
+ * --- Linux Include Files
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#if defined(CONFIG_X86) && !defined(CONFIG_ISA)
+#define CONFIG_ISA
+#endif /* CONFIG_X86 && !CONFIG_ISA */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/stat.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/dma.h>
+
+/* FIXME: (by jejb@steeleye.com) This warning is present for two
+ * reasons:
+ *
+ * 1) This driver badly needs converting to the correct driver model
+ *    probing API
+ *
+ * 2) Although all of the necessary command mapping places have the
+ * appropriate dma_map.. APIs, the driver still processes its internal
+ * queue using bus_to_virt() and virt_to_bus() which are illegal under
+ * the API.  The entire queue processing structure will need to be
+ * altered to fix this.
+ */
+#warning this driver is still not properly converted to the DMA API
+
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include "advansys.h"
+#ifdef CONFIG_PCI
+#include <linux/pci.h>
+#endif /* CONFIG_PCI */
+
+
+/*
+ * --- Driver Options
+ */
+
+/* Enable driver assertions. */
+#define ADVANSYS_ASSERT
+
+/* Enable driver /proc statistics. */
+#define ADVANSYS_STATS
+
+/* Enable driver tracing. */
+/* #define ADVANSYS_DEBUG */
+
+
+/*
+ * --- Debugging Header
+ */
+
+#ifdef ADVANSYS_DEBUG
+#define STATIC
+#else /* ADVANSYS_DEBUG */
+#define STATIC static
+#endif /* ADVANSYS_DEBUG */
+
+
+/*
+ * --- Asc Library Constants and Macros
+ */
+
+#define ASC_LIB_VERSION_MAJOR  1
+#define ASC_LIB_VERSION_MINOR  24
+#define ASC_LIB_SERIAL_NUMBER  123
+
+/*
+ * Portable Data Types
+ *
+ * Any instance where a 32-bit long or pointer type is assumed
+ * for precision or HW defined structures, the following define
+ * types must be used. In Linux the char, short, and int types
+ * are all consistent at 8, 16, and 32 bits respectively. Pointers
+ * and long types are 64 bits on Alpha and UltraSPARC.
+ */
+#define ASC_PADDR __u32         /* Physical/Bus address data type. */
+#define ASC_VADDR __u32         /* Virtual address data type. */
+#define ASC_DCNT  __u32         /* Unsigned Data count type. */
+#define ASC_SDCNT __s32         /* Signed Data count type. */
+
+/*
+ * These macros are used to convert a virtual address to a
+ * 32-bit value. This currently can be used on Linux Alpha
+ * which uses 64-bit virtual address but a 32-bit bus address.
+ * This is likely to break in the future, but doing this now
+ * will give us time to change the HW and FW to handle 64-bit
+ * addresses.
+ */
+#define ASC_VADDR_TO_U32   virt_to_bus
+#define ASC_U32_TO_VADDR   bus_to_virt
+
+typedef unsigned char uchar;
+
+#ifndef TRUE
+#define TRUE     (1)
+#endif
+#ifndef FALSE
+#define FALSE    (0)
+#endif
+
+#define EOF      (-1)
+#define ERR      (-1)
+#define UW_ERR   (uint)(0xFFFF)
+#define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)
+#define AscPCIConfigVendorIDRegister      0x0000
+#define AscPCIConfigDeviceIDRegister      0x0002
+#define AscPCIConfigCommandRegister       0x0004
+#define AscPCIConfigStatusRegister        0x0006
+#define AscPCIConfigRevisionIDRegister    0x0008
+#define AscPCIConfigCacheSize             0x000C
+#define AscPCIConfigLatencyTimer          0x000D
+#define AscPCIIOBaseRegister              0x0010
+#define AscPCICmdRegBits_IOMemBusMaster   0x0007
+#define ASC_PCI_ID2BUS(id)    ((id) & 0xFF)
+#define ASC_PCI_ID2DEV(id)    (((id) >> 11) & 0x1F)
+#define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)
+#define ASC_PCI_MKID(bus, dev, func) ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))
+#define ASC_PCI_VENDORID                  0x10CD
+#define ASC_PCI_DEVICEID_1200A            0x1100
+#define ASC_PCI_DEVICEID_1200B            0x1200
+#define ASC_PCI_DEVICEID_ULTRA            0x1300
+#define ASC_PCI_REVISION_3150             0x02
+#define ASC_PCI_REVISION_3050             0x03
+
+#define  ASC_DVCLIB_CALL_DONE     (1)
+#define  ASC_DVCLIB_CALL_FAILED   (0)
+#define  ASC_DVCLIB_CALL_ERROR    (-1)
+
+/*
+ * Enable CC_VERY_LONG_SG_LIST to support up to 64K element SG lists.
+ * The SRB structure will have to be changed and the ASC_SRB2SCSIQ()
+ * macro re-defined to be able to obtain a ASC_SCSI_Q pointer from the
+ * SRB structure.
+ */
+#define CC_VERY_LONG_SG_LIST 0
+#define ASC_SRB2SCSIQ(srb_ptr)  (srb_ptr)
+
+#define PortAddr                 unsigned short    /* port address size  */
+#define inp(port)                inb(port)
+#define outp(port, byte)         outb((byte), (port))
+
+#define inpw(port)               inw(port)
+#define outpw(port, word)        outw((word), (port))
+
+#define ASC_MAX_SG_QUEUE    7
+#define ASC_MAX_SG_LIST     255
+
+#define ASC_CS_TYPE  unsigned short
+
+#define ASC_IS_ISA          (0x0001)
+#define ASC_IS_ISAPNP       (0x0081)
+#define ASC_IS_EISA         (0x0002)
+#define ASC_IS_PCI          (0x0004)
+#define ASC_IS_PCI_ULTRA    (0x0104)
+#define ASC_IS_PCMCIA       (0x0008)
+#define ASC_IS_MCA          (0x0020)
+#define ASC_IS_VL           (0x0040)
+#define ASC_ISA_PNP_PORT_ADDR  (0x279)
+#define ASC_ISA_PNP_PORT_WRITE (ASC_ISA_PNP_PORT_ADDR+0x800)
+#define ASC_IS_WIDESCSI_16  (0x0100)
+#define ASC_IS_WIDESCSI_32  (0x0200)
+#define ASC_IS_BIG_ENDIAN   (0x8000)
+#define ASC_CHIP_MIN_VER_VL      (0x01)
+#define ASC_CHIP_MAX_VER_VL      (0x07)
+#define ASC_CHIP_MIN_VER_PCI     (0x09)
+#define ASC_CHIP_MAX_VER_PCI     (0x0F)
+#define ASC_CHIP_VER_PCI_BIT     (0x08)
+#define ASC_CHIP_MIN_VER_ISA     (0x11)
+#define ASC_CHIP_MIN_VER_ISA_PNP (0x21)
+#define ASC_CHIP_MAX_VER_ISA     (0x27)
+#define ASC_CHIP_VER_ISA_BIT     (0x30)
+#define ASC_CHIP_VER_ISAPNP_BIT  (0x20)
+#define ASC_CHIP_VER_ASYN_BUG    (0x21)
+#define ASC_CHIP_VER_PCI             0x08
+#define ASC_CHIP_VER_PCI_ULTRA_3150  (ASC_CHIP_VER_PCI | 0x02)
+#define ASC_CHIP_VER_PCI_ULTRA_3050  (ASC_CHIP_VER_PCI | 0x03)
+#define ASC_CHIP_MIN_VER_EISA (0x41)
+#define ASC_CHIP_MAX_VER_EISA (0x47)
+#define ASC_CHIP_VER_EISA_BIT (0x40)
+#define ASC_CHIP_LATEST_VER_EISA   ((ASC_CHIP_MIN_VER_EISA - 1) + 3)
+#define ASC_MAX_LIB_SUPPORTED_ISA_CHIP_VER   0x21
+#define ASC_MAX_LIB_SUPPORTED_PCI_CHIP_VER   0x0A
+#define ASC_MAX_VL_DMA_ADDR     (0x07FFFFFFL)
+#define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)
+#define ASC_MAX_PCI_DMA_ADDR    (0xFFFFFFFFL)
+#define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)
+#define ASC_MAX_ISA_DMA_ADDR    (0x00FFFFFFL)
+#define ASC_MAX_ISA_DMA_COUNT   (0x00FFFFFFL)
+#define ASC_MAX_EISA_DMA_ADDR   (0x07FFFFFFL)
+#define ASC_MAX_EISA_DMA_COUNT  (0x07FFFFFFL)
+
+#define ASC_SCSI_ID_BITS  3
+#define ASC_SCSI_TIX_TYPE     uchar
+#define ASC_ALL_DEVICE_BIT_SET  0xFF
+#define ASC_SCSI_BIT_ID_TYPE  uchar
+#define ASC_MAX_TID       7
+#define ASC_MAX_LUN       7
+#define ASC_SCSI_WIDTH_BIT_SET  0xFF
+#define ASC_MAX_SENSE_LEN   32
+#define ASC_MIN_SENSE_LEN   14
+#define ASC_MAX_CDB_LEN     12
+#define ASC_SCSI_RESET_HOLD_TIME_US  60
+
+#define ADV_INQ_CLOCKING_ST_ONLY    0x0
+#define ADV_INQ_CLOCKING_DT_ONLY    0x1
+#define ADV_INQ_CLOCKING_ST_AND_DT  0x3
+
+/*
+ * Inquiry SPC-2 SPI Byte 1 EVPD (Enable Vital Product Data)
+ * and CmdDt (Command Support Data) field bit definitions.
+ */
+#define ADV_INQ_RTN_VPD_AND_CMDDT           0x3
+#define ADV_INQ_RTN_CMDDT_FOR_OP_CODE       0x2
+#define ADV_INQ_RTN_VPD_FOR_PG_CODE         0x1
+#define ADV_INQ_RTN_STD_INQUIRY_DATA        0x0
+
+#define ASC_SCSIDIR_NOCHK    0x00
+#define ASC_SCSIDIR_T2H      0x08
+#define ASC_SCSIDIR_H2T      0x10
+#define ASC_SCSIDIR_NODATA   0x18
+#define SCSI_ASC_NOMEDIA          0x3A
+#define ASC_SRB_HOST(x)  ((uchar)((uchar)(x) >> 4))
+#define ASC_SRB_TID(x)   ((uchar)((uchar)(x) & (uchar)0x0F))
+#define ASC_SRB_LUN(x)   ((uchar)((uint)(x) >> 13))
+#define PUT_CDB1(x)   ((uchar)((uint)(x) >> 8))
+#define MS_CMD_DONE    0x00
+#define MS_EXTEND      0x01
+#define MS_SDTR_LEN    0x03
+#define MS_SDTR_CODE   0x01
+#define MS_WDTR_LEN    0x02
+#define MS_WDTR_CODE   0x03
+#define MS_MDP_LEN    0x05
+#define MS_MDP_CODE   0x00
+
+/*
+ * Inquiry data structure and bitfield macros
+ *
+ * Only quantities of more than 1 bit are shifted, since the others are
+ * just tested for true or false. C bitfields aren't portable between big
+ * and little-endian platforms so they are not used.
+ */
+
+#define ASC_INQ_DVC_TYPE(inq)       ((inq)->periph & 0x1f)
+#define ASC_INQ_QUALIFIER(inq)      (((inq)->periph & 0xe0) >> 5)
+#define ASC_INQ_DVC_TYPE_MOD(inq)   ((inq)->devtype & 0x7f)
+#define ASC_INQ_REMOVABLE(inq)      ((inq)->devtype & 0x80)
+#define ASC_INQ_ANSI_VER(inq)       ((inq)->ver & 0x07)
+#define ASC_INQ_ECMA_VER(inq)       (((inq)->ver & 0x38) >> 3)
+#define ASC_INQ_ISO_VER(inq)        (((inq)->ver & 0xc0) >> 6)
+#define ASC_INQ_RESPONSE_FMT(inq)   ((inq)->byte3 & 0x0f)
+#define ASC_INQ_TERM_IO(inq)        ((inq)->byte3 & 0x40)
+#define ASC_INQ_ASYNC_NOTIF(inq)    ((inq)->byte3 & 0x80)
+#define ASC_INQ_SOFT_RESET(inq)     ((inq)->flags & 0x01)
+#define ASC_INQ_CMD_QUEUE(inq)      ((inq)->flags & 0x02)
+#define ASC_INQ_LINK_CMD(inq)       ((inq)->flags & 0x08)
+#define ASC_INQ_SYNC(inq)           ((inq)->flags & 0x10)
+#define ASC_INQ_WIDE16(inq)         ((inq)->flags & 0x20)
+#define ASC_INQ_WIDE32(inq)         ((inq)->flags & 0x40)
+#define ASC_INQ_REL_ADDR(inq)       ((inq)->flags & 0x80)
+#define ASC_INQ_INFO_UNIT(inq)      ((inq)->info & 0x01)
+#define ASC_INQ_QUICK_ARB(inq)      ((inq)->info & 0x02)
+#define ASC_INQ_CLOCKING(inq)       (((inq)->info & 0x0c) >> 2)
+
+typedef struct {
+    uchar               periph;
+    uchar               devtype;
+    uchar               ver;
+    uchar               byte3;
+    uchar               add_len;
+    uchar               res1;
+    uchar               res2;
+    uchar               flags;
+    uchar               vendor_id[8];
+    uchar               product_id[16];
+    uchar               product_rev_level[4];
+} ASC_SCSI_INQUIRY;
+
+#define ASC_SG_LIST_PER_Q   7
+#define QS_FREE        0x00
+#define QS_READY       0x01
+#define QS_DISC1       0x02
+#define QS_DISC2       0x04
+#define QS_BUSY        0x08
+#define QS_ABORTED     0x40
+#define QS_DONE        0x80
+#define QC_NO_CALLBACK   0x01
+#define QC_SG_SWAP_QUEUE 0x02
+#define QC_SG_HEAD       0x04
+#define QC_DATA_IN       0x08
+#define QC_DATA_OUT      0x10
+#define QC_URGENT        0x20
+#define QC_MSG_OUT       0x40
+#define QC_REQ_SENSE     0x80
+#define QCSG_SG_XFER_LIST  0x02
+#define QCSG_SG_XFER_MORE  0x04
+#define QCSG_SG_XFER_END   0x08
+#define QD_IN_PROGRESS       0x00
+#define QD_NO_ERROR          0x01
+#define QD_ABORTED_BY_HOST   0x02
+#define QD_WITH_ERROR        0x04
+#define QD_INVALID_REQUEST   0x80
+#define QD_INVALID_HOST_NUM  0x81
+#define QD_INVALID_DEVICE    0x82
+#define QD_ERR_INTERNAL      0xFF
+#define QHSTA_NO_ERROR               0x00
+#define QHSTA_M_SEL_TIMEOUT          0x11
+#define QHSTA_M_DATA_OVER_RUN        0x12
+#define QHSTA_M_DATA_UNDER_RUN       0x12
+#define QHSTA_M_UNEXPECTED_BUS_FREE  0x13
+#define QHSTA_M_BAD_BUS_PHASE_SEQ    0x14
+#define QHSTA_D_QDONE_SG_LIST_CORRUPTED 0x21
+#define QHSTA_D_ASC_DVC_ERROR_CODE_SET  0x22
+#define QHSTA_D_HOST_ABORT_FAILED       0x23
+#define QHSTA_D_EXE_SCSI_Q_FAILED       0x24
+#define QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT 0x25
+#define QHSTA_D_ASPI_NO_BUF_POOL        0x26
+#define QHSTA_M_WTM_TIMEOUT         0x41
+#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42
+#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43
+#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44
+#define QHSTA_M_TARGET_STATUS_BUSY  0x45
+#define QHSTA_M_BAD_TAG_CODE        0x46
+#define QHSTA_M_BAD_QUEUE_FULL_OR_BUSY  0x47
+#define QHSTA_M_HUNG_REQ_SCSI_BUS_RESET 0x48
+#define QHSTA_D_LRAM_CMP_ERROR        0x81
+#define QHSTA_M_MICRO_CODE_ERROR_HALT 0xA1
+#define ASC_FLAG_SCSIQ_REQ        0x01
+#define ASC_FLAG_BIOS_SCSIQ_REQ   0x02
+#define ASC_FLAG_BIOS_ASYNC_IO    0x04
+#define ASC_FLAG_SRB_LINEAR_ADDR  0x08
+#define ASC_FLAG_WIN16            0x10
+#define ASC_FLAG_WIN32            0x20
+#define ASC_FLAG_ISA_OVER_16MB    0x40
+#define ASC_FLAG_DOS_VM_CALLBACK  0x80
+#define ASC_TAG_FLAG_EXTRA_BYTES               0x10
+#define ASC_TAG_FLAG_DISABLE_DISCONNECT        0x04
+#define ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX  0x08
+#define ASC_TAG_FLAG_DISABLE_CHK_COND_INT_HOST 0x40
+#define ASC_SCSIQ_CPY_BEG              4
+#define ASC_SCSIQ_SGHD_CPY_BEG         2
+#define ASC_SCSIQ_B_FWD                0
+#define ASC_SCSIQ_B_BWD                1
+#define ASC_SCSIQ_B_STATUS             2
+#define ASC_SCSIQ_B_QNO                3
+#define ASC_SCSIQ_B_CNTL               4
+#define ASC_SCSIQ_B_SG_QUEUE_CNT       5
+#define ASC_SCSIQ_D_DATA_ADDR          8
+#define ASC_SCSIQ_D_DATA_CNT          12
+#define ASC_SCSIQ_B_SENSE_LEN         20
+#define ASC_SCSIQ_DONE_INFO_BEG       22
+#define ASC_SCSIQ_D_SRBPTR            22
+#define ASC_SCSIQ_B_TARGET_IX         26
+#define ASC_SCSIQ_B_CDB_LEN           28
+#define ASC_SCSIQ_B_TAG_CODE          29
+#define ASC_SCSIQ_W_VM_ID             30
+#define ASC_SCSIQ_DONE_STATUS         32
+#define ASC_SCSIQ_HOST_STATUS         33
+#define ASC_SCSIQ_SCSI_STATUS         34
+#define ASC_SCSIQ_CDB_BEG             36
+#define ASC_SCSIQ_DW_REMAIN_XFER_ADDR 56
+#define ASC_SCSIQ_DW_REMAIN_XFER_CNT  60
+#define ASC_SCSIQ_B_FIRST_SG_WK_QP    48
+#define ASC_SCSIQ_B_SG_WK_QP          49
+#define ASC_SCSIQ_B_SG_WK_IX          50
+#define ASC_SCSIQ_W_ALT_DC1           52
+#define ASC_SCSIQ_B_LIST_CNT          6
+#define ASC_SCSIQ_B_CUR_LIST_CNT      7
+#define ASC_SGQ_B_SG_CNTL             4
+#define ASC_SGQ_B_SG_HEAD_QP          5
+#define ASC_SGQ_B_SG_LIST_CNT         6
+#define ASC_SGQ_B_SG_CUR_LIST_CNT     7
+#define ASC_SGQ_LIST_BEG              8
+#define ASC_DEF_SCSI1_QNG    4
+#define ASC_MAX_SCSI1_QNG    4
+#define ASC_DEF_SCSI2_QNG    16
+#define ASC_MAX_SCSI2_QNG    32
+#define ASC_TAG_CODE_MASK    0x23
+#define ASC_STOP_REQ_RISC_STOP      0x01
+#define ASC_STOP_ACK_RISC_STOP      0x03
+#define ASC_STOP_CLEAN_UP_BUSY_Q    0x10
+#define ASC_STOP_CLEAN_UP_DISC_Q    0x20
+#define ASC_STOP_HOST_REQ_RISC_HALT 0x40
+#define ASC_TIDLUN_TO_IX(tid, lun)  (ASC_SCSI_TIX_TYPE)((tid) + ((lun)<<ASC_SCSI_ID_BITS))
+#define ASC_TID_TO_TARGET_ID(tid)   (ASC_SCSI_BIT_ID_TYPE)(0x01 << (tid))
+#define ASC_TIX_TO_TARGET_ID(tix)   (0x01 << ((tix) & ASC_MAX_TID))
+#define ASC_TIX_TO_TID(tix)         ((tix) & ASC_MAX_TID)
+#define ASC_TID_TO_TIX(tid)         ((tid) & ASC_MAX_TID)
+#define ASC_TIX_TO_LUN(tix)         (((tix) >> ASC_SCSI_ID_BITS) & ASC_MAX_LUN)
+#define ASC_QNO_TO_QADDR(q_no)      ((ASC_QADR_BEG)+((int)(q_no) << 6))
+
+typedef struct asc_scsiq_1 {
+    uchar               status;
+    uchar               q_no;
+    uchar               cntl;
+    uchar               sg_queue_cnt;
+    uchar               target_id;
+    uchar               target_lun;
+    ASC_PADDR           data_addr;
+    ASC_DCNT            data_cnt;
+    ASC_PADDR           sense_addr;
+    uchar               sense_len;
+    uchar               extra_bytes;
+} ASC_SCSIQ_1;
+
+typedef struct asc_scsiq_2 {
+    ASC_VADDR           srb_ptr;
+    uchar               target_ix;
+    uchar               flag;
+    uchar               cdb_len;
+    uchar               tag_code;
+    ushort              vm_id;
+} ASC_SCSIQ_2;
+
+typedef struct asc_scsiq_3 {
+    uchar               done_stat;
+    uchar               host_stat;
+    uchar               scsi_stat;
+    uchar               scsi_msg;
+} ASC_SCSIQ_3;
+
+typedef struct asc_scsiq_4 {
+    uchar               cdb[ASC_MAX_CDB_LEN];
+    uchar               y_first_sg_list_qp;
+    uchar               y_working_sg_qp;
+    uchar               y_working_sg_ix;
+    uchar               y_res;
+    ushort              x_req_count;
+    ushort              x_reconnect_rtn;
+    ASC_PADDR           x_saved_data_addr;
+    ASC_DCNT            x_saved_data_cnt;
+} ASC_SCSIQ_4;
+
+typedef struct asc_q_done_info {
+    ASC_SCSIQ_2         d2;
+    ASC_SCSIQ_3         d3;
+    uchar               q_status;
+    uchar               q_no;
+    uchar               cntl;
+    uchar               sense_len;
+    uchar               extra_bytes;
+    uchar               res;
+    ASC_DCNT            remain_bytes;
+} ASC_QDONE_INFO;
+
+typedef struct asc_sg_list {
+    ASC_PADDR           addr;
+    ASC_DCNT            bytes;
+} ASC_SG_LIST;
+
+typedef struct asc_sg_head {
+    ushort              entry_cnt;
+    ushort              queue_cnt;
+    ushort              entry_to_copy;
+    ushort              res;
+    ASC_SG_LIST         sg_list[ASC_MAX_SG_LIST];
+} ASC_SG_HEAD;
+
+#define ASC_MIN_SG_LIST   2
+
+typedef struct asc_min_sg_head {
+    ushort              entry_cnt;
+    ushort              queue_cnt;
+    ushort              entry_to_copy;
+    ushort              res;
+    ASC_SG_LIST         sg_list[ASC_MIN_SG_LIST];
+} ASC_MIN_SG_HEAD;
+
+#define QCX_SORT        (0x0001)
+#define QCX_COALEASE    (0x0002)
+
+typedef struct asc_scsi_q {
+    ASC_SCSIQ_1         q1;
+    ASC_SCSIQ_2         q2;
+    uchar               *cdbptr;
+    ASC_SG_HEAD         *sg_head;
+    ushort              remain_sg_entry_cnt;
+    ushort              next_sg_index;
+} ASC_SCSI_Q;
+
+typedef struct asc_scsi_req_q {
+    ASC_SCSIQ_1         r1;
+    ASC_SCSIQ_2         r2;
+    uchar               *cdbptr;
+    ASC_SG_HEAD         *sg_head;
+    uchar               *sense_ptr;
+    ASC_SCSIQ_3         r3;
+    uchar               cdb[ASC_MAX_CDB_LEN];
+    uchar               sense[ASC_MIN_SENSE_LEN];
+} ASC_SCSI_REQ_Q;
+
+typedef struct asc_scsi_bios_req_q {
+    ASC_SCSIQ_1         r1;
+    ASC_SCSIQ_2         r2;
+    uchar               *cdbptr;
+    ASC_SG_HEAD         *sg_head;
+    uchar               *sense_ptr;
+    ASC_SCSIQ_3         r3;
+    uchar               cdb[ASC_MAX_CDB_LEN];
+    uchar               sense[ASC_MIN_SENSE_LEN];
+} ASC_SCSI_BIOS_REQ_Q;
+
+typedef struct asc_risc_q {
+    uchar               fwd;
+    uchar               bwd;
+    ASC_SCSIQ_1         i1;
+    ASC_SCSIQ_2         i2;
+    ASC_SCSIQ_3         i3;
+    ASC_SCSIQ_4         i4;
+} ASC_RISC_Q;
+
+typedef struct asc_sg_list_q {
+    uchar               seq_no;
+    uchar               q_no;
+    uchar               cntl;
+    uchar               sg_head_qp;
+    uchar               sg_list_cnt;
+    uchar               sg_cur_list_cnt;
+} ASC_SG_LIST_Q;
+
+typedef struct asc_risc_sg_list_q {
+    uchar               fwd;
+    uchar               bwd;
+    ASC_SG_LIST_Q       sg;
+    ASC_SG_LIST         sg_list[7];
+} ASC_RISC_SG_LIST_Q;
+
+#define ASC_EXE_SCSI_IO_MAX_IDLE_LOOP  0x1000000UL
+#define ASC_EXE_SCSI_IO_MAX_WAIT_LOOP  1024
+#define ASCQ_ERR_NO_ERROR             0
+#define ASCQ_ERR_IO_NOT_FOUND         1
+#define ASCQ_ERR_LOCAL_MEM            2
+#define ASCQ_ERR_CHKSUM               3
+#define ASCQ_ERR_START_CHIP           4
+#define ASCQ_ERR_INT_TARGET_ID        5
+#define ASCQ_ERR_INT_LOCAL_MEM        6
+#define ASCQ_ERR_HALT_RISC            7
+#define ASCQ_ERR_GET_ASPI_ENTRY       8
+#define ASCQ_ERR_CLOSE_ASPI           9
+#define ASCQ_ERR_HOST_INQUIRY         0x0A
+#define ASCQ_ERR_SAVED_SRB_BAD        0x0B
+#define ASCQ_ERR_QCNTL_SG_LIST        0x0C
+#define ASCQ_ERR_Q_STATUS             0x0D
+#define ASCQ_ERR_WR_SCSIQ             0x0E
+#define ASCQ_ERR_PC_ADDR              0x0F
+#define ASCQ_ERR_SYN_OFFSET           0x10
+#define ASCQ_ERR_SYN_XFER_TIME        0x11
+#define ASCQ_ERR_LOCK_DMA             0x12
+#define ASCQ_ERR_UNLOCK_DMA           0x13
+#define ASCQ_ERR_VDS_CHK_INSTALL      0x14
+#define ASCQ_ERR_MICRO_CODE_HALT      0x15
+#define ASCQ_ERR_SET_LRAM_ADDR        0x16
+#define ASCQ_ERR_CUR_QNG              0x17
+#define ASCQ_ERR_SG_Q_LINKS           0x18
+#define ASCQ_ERR_SCSIQ_PTR            0x19
+#define ASCQ_ERR_ISR_RE_ENTRY         0x1A
+#define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B
+#define ASCQ_ERR_ISR_ON_CRITICAL      0x1C
+#define ASCQ_ERR_SG_LIST_ODD_ADDRESS  0x1D
+#define ASCQ_ERR_XFER_ADDRESS_TOO_BIG 0x1E
+#define ASCQ_ERR_SCSIQ_NULL_PTR       0x1F
+#define ASCQ_ERR_SCSIQ_BAD_NEXT_PTR   0x20
+#define ASCQ_ERR_GET_NUM_OF_FREE_Q    0x21
+#define ASCQ_ERR_SEND_SCSI_Q          0x22
+#define ASCQ_ERR_HOST_REQ_RISC_HALT   0x23
+#define ASCQ_ERR_RESET_SDTR           0x24
+
+/*
+ * Warning code values are set in ASC_DVC_VAR  'warn_code'.
+ */
+#define ASC_WARN_NO_ERROR             0x0000
+#define ASC_WARN_IO_PORT_ROTATE       0x0001
+#define ASC_WARN_EEPROM_CHKSUM        0x0002
+#define ASC_WARN_IRQ_MODIFIED         0x0004
+#define ASC_WARN_AUTO_CONFIG          0x0008
+#define ASC_WARN_CMD_QNG_CONFLICT     0x0010
+#define ASC_WARN_EEPROM_RECOVER       0x0020
+#define ASC_WARN_CFG_MSW_RECOVER      0x0040
+#define ASC_WARN_SET_PCI_CONFIG_SPACE 0x0080
+
+/*
+ * Error code values are set in ASC_DVC_VAR  'err_code'.
+ */
+#define ASC_IERR_WRITE_EEPROM         0x0001
+#define ASC_IERR_MCODE_CHKSUM         0x0002
+#define ASC_IERR_SET_PC_ADDR          0x0004
+#define ASC_IERR_START_STOP_CHIP      0x0008
+#define ASC_IERR_IRQ_NO               0x0010
+#define ASC_IERR_SET_IRQ_NO           0x0020
+#define ASC_IERR_CHIP_VERSION         0x0040
+#define ASC_IERR_SET_SCSI_ID          0x0080
+#define ASC_IERR_GET_PHY_ADDR         0x0100
+#define ASC_IERR_BAD_SIGNATURE        0x0200
+#define ASC_IERR_NO_BUS_TYPE          0x0400
+#define ASC_IERR_SCAM                 0x0800
+#define ASC_IERR_SET_SDTR             0x1000
+#define ASC_IERR_RW_LRAM              0x8000
+
+#define ASC_DEF_IRQ_NO  10
+#define ASC_MAX_IRQ_NO  15
+#define ASC_MIN_IRQ_NO  10
+#define ASC_MIN_REMAIN_Q        (0x02)
+#define ASC_DEF_MAX_TOTAL_QNG   (0xF0)
+#define ASC_MIN_TAG_Q_PER_DVC   (0x04)
+#define ASC_DEF_TAG_Q_PER_DVC   (0x04)
+#define ASC_MIN_FREE_Q        ASC_MIN_REMAIN_Q
+#define ASC_MIN_TOTAL_QNG     ((ASC_MAX_SG_QUEUE)+(ASC_MIN_FREE_Q))
+#define ASC_MAX_TOTAL_QNG 240
+#define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16
+#define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8
+#define ASC_MAX_PCI_INRAM_TOTAL_QNG  20
+#define ASC_MAX_INRAM_TAG_QNG   16
+#define ASC_IOADR_TABLE_MAX_IX  11
+#define ASC_IOADR_GAP   0x10
+#define ASC_SEARCH_IOP_GAP 0x10
+#define ASC_MIN_IOP_ADDR   (PortAddr)0x0100
+#define ASC_MAX_IOP_ADDR   (PortAddr)0x3F0
+#define ASC_IOADR_1     (PortAddr)0x0110
+#define ASC_IOADR_2     (PortAddr)0x0130
+#define ASC_IOADR_3     (PortAddr)0x0150
+#define ASC_IOADR_4     (PortAddr)0x0190
+#define ASC_IOADR_5     (PortAddr)0x0210
+#define ASC_IOADR_6     (PortAddr)0x0230
+#define ASC_IOADR_7     (PortAddr)0x0250
+#define ASC_IOADR_8     (PortAddr)0x0330
+#define ASC_IOADR_DEF   ASC_IOADR_8
+#define ASC_LIB_SCSIQ_WK_SP        256
+#define ASC_MAX_SYN_XFER_NO        16
+#define ASC_SYN_MAX_OFFSET         0x0F
+#define ASC_DEF_SDTR_OFFSET        0x0F
+#define ASC_DEF_SDTR_INDEX         0x00
+#define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02
+#define SYN_XFER_NS_0  25
+#define SYN_XFER_NS_1  30
+#define SYN_XFER_NS_2  35
+#define SYN_XFER_NS_3  40
+#define SYN_XFER_NS_4  50
+#define SYN_XFER_NS_5  60
+#define SYN_XFER_NS_6  70
+#define SYN_XFER_NS_7  85
+#define SYN_ULTRA_XFER_NS_0    12
+#define SYN_ULTRA_XFER_NS_1    19
+#define SYN_ULTRA_XFER_NS_2    25
+#define SYN_ULTRA_XFER_NS_3    32
+#define SYN_ULTRA_XFER_NS_4    38
+#define SYN_ULTRA_XFER_NS_5    44
+#define SYN_ULTRA_XFER_NS_6    50
+#define SYN_ULTRA_XFER_NS_7    57
+#define SYN_ULTRA_XFER_NS_8    63
+#define SYN_ULTRA_XFER_NS_9    69
+#define SYN_ULTRA_XFER_NS_10   75
+#define SYN_ULTRA_XFER_NS_11   82
+#define SYN_ULTRA_XFER_NS_12   88
+#define SYN_ULTRA_XFER_NS_13   94
+#define SYN_ULTRA_XFER_NS_14  100
+#define SYN_ULTRA_XFER_NS_15  107
+
+typedef struct ext_msg {
+    uchar               msg_type;
+    uchar               msg_len;
+    uchar               msg_req;
+    union {
+        struct {
+            uchar               sdtr_xfer_period;
+            uchar               sdtr_req_ack_offset;
+        } sdtr;
+        struct {
+            uchar               wdtr_width;
+        } wdtr;
+        struct {
+            uchar               mdp_b3;
+            uchar               mdp_b2;
+            uchar               mdp_b1;
+            uchar               mdp_b0;
+        } mdp;
+    } u_ext_msg;
+    uchar               res;
+} EXT_MSG;
+
+#define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period
+#define req_ack_offset  u_ext_msg.sdtr.sdtr_req_ack_offset
+#define wdtr_width      u_ext_msg.wdtr.wdtr_width
+#define mdp_b3          u_ext_msg.mdp_b3
+#define mdp_b2          u_ext_msg.mdp_b2
+#define mdp_b1          u_ext_msg.mdp_b1
+#define mdp_b0          u_ext_msg.mdp_b0
+
+typedef struct asc_dvc_cfg {
+    ASC_SCSI_BIT_ID_TYPE can_tagged_qng;
+    ASC_SCSI_BIT_ID_TYPE cmd_qng_enabled;
+    ASC_SCSI_BIT_ID_TYPE disc_enable;
+    ASC_SCSI_BIT_ID_TYPE sdtr_enable;
+    uchar               chip_scsi_id;
+    uchar               isa_dma_speed;
+    uchar               isa_dma_channel;
+    uchar               chip_version;
+    ushort              lib_serial_no;
+    ushort              lib_version;
+    ushort              mcode_date;
+    ushort              mcode_version;
+    uchar               max_tag_qng[ASC_MAX_TID + 1];
+    uchar               *overrun_buf;
+    uchar               sdtr_period_offset[ASC_MAX_TID + 1];
+    ushort              pci_slot_info;
+    uchar               adapter_info[6];
+    struct device	*dev;
+} ASC_DVC_CFG;
+
+#define ASC_DEF_DVC_CNTL       0xFFFF
+#define ASC_DEF_CHIP_SCSI_ID   7
+#define ASC_DEF_ISA_DMA_SPEED  4
+#define ASC_INIT_STATE_NULL          0x0000
+#define ASC_INIT_STATE_BEG_GET_CFG   0x0001
+#define ASC_INIT_STATE_END_GET_CFG   0x0002
+#define ASC_INIT_STATE_BEG_SET_CFG   0x0004
+#define ASC_INIT_STATE_END_SET_CFG   0x0008
+#define ASC_INIT_STATE_BEG_LOAD_MC   0x0010
+#define ASC_INIT_STATE_END_LOAD_MC   0x0020
+#define ASC_INIT_STATE_BEG_INQUIRY   0x0040
+#define ASC_INIT_STATE_END_INQUIRY   0x0080
+#define ASC_INIT_RESET_SCSI_DONE     0x0100
+#define ASC_INIT_STATE_WITHOUT_EEP   0x8000
+#define ASC_PCI_DEVICE_ID_REV_A      0x1100
+#define ASC_PCI_DEVICE_ID_REV_B      0x1200
+#define ASC_BUG_FIX_IF_NOT_DWB       0x0001
+#define ASC_BUG_FIX_ASYN_USE_SYN     0x0002
+#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41
+#define ASC_MIN_TAGGED_CMD  7
+#define ASC_MAX_SCSI_RESET_WAIT      30
+
+struct asc_dvc_var;     /* Forward Declaration. */
+
+typedef void (* ASC_ISR_CALLBACK)(struct asc_dvc_var *, ASC_QDONE_INFO *);
+typedef int (* ASC_EXE_CALLBACK)(struct asc_dvc_var *, ASC_SCSI_Q *);
+
+typedef struct asc_dvc_var {
+    PortAddr            iop_base;
+    ushort              err_code;
+    ushort              dvc_cntl;
+    ushort              bug_fix_cntl;
+    ushort              bus_type;
+    ASC_ISR_CALLBACK    isr_callback;
+    ASC_EXE_CALLBACK    exe_callback;
+    ASC_SCSI_BIT_ID_TYPE init_sdtr;
+    ASC_SCSI_BIT_ID_TYPE sdtr_done;
+    ASC_SCSI_BIT_ID_TYPE use_tagged_qng;
+    ASC_SCSI_BIT_ID_TYPE unit_not_ready;
+    ASC_SCSI_BIT_ID_TYPE queue_full_or_busy;
+    ASC_SCSI_BIT_ID_TYPE start_motor;
+    uchar               scsi_reset_wait;
+    uchar               chip_no;
+    char                is_in_int;
+    uchar               max_total_qng;
+    uchar               cur_total_qng;
+    uchar               in_critical_cnt;
+    uchar               irq_no;
+    uchar               last_q_shortage;
+    ushort              init_state;
+    uchar               cur_dvc_qng[ASC_MAX_TID + 1];
+    uchar               max_dvc_qng[ASC_MAX_TID + 1];
+    ASC_SCSI_Q  *scsiq_busy_head[ASC_MAX_TID + 1];
+    ASC_SCSI_Q  *scsiq_busy_tail[ASC_MAX_TID + 1];
+    uchar               sdtr_period_tbl[ASC_MAX_SYN_XFER_NO];
+    ASC_DVC_CFG *cfg;
+    ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always;
+    char                redo_scam;
+    ushort              res2;
+    uchar               dos_int13_table[ASC_MAX_TID + 1];
+    ASC_DCNT            max_dma_count;
+    ASC_SCSI_BIT_ID_TYPE no_scam;
+    ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;
+    uchar               max_sdtr_index;
+    uchar               host_init_sdtr_index;
+    struct asc_board    *drv_ptr;
+    ASC_DCNT            uc_break;
+} ASC_DVC_VAR;
+
+typedef struct asc_dvc_inq_info {
+    uchar               type[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];
+} ASC_DVC_INQ_INFO;
+
+typedef struct asc_cap_info {
+    ASC_DCNT            lba;
+    ASC_DCNT            blk_size;
+} ASC_CAP_INFO;
+
+typedef struct asc_cap_info_array {
+    ASC_CAP_INFO        cap_info[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];
+} ASC_CAP_INFO_ARRAY;
+
+#define ASC_MCNTL_NO_SEL_TIMEOUT  (ushort)0x0001
+#define ASC_MCNTL_NULL_TARGET     (ushort)0x0002
+#define ASC_CNTL_INITIATOR         (ushort)0x0001
+#define ASC_CNTL_BIOS_GT_1GB       (ushort)0x0002
+#define ASC_CNTL_BIOS_GT_2_DISK    (ushort)0x0004
+#define ASC_CNTL_BIOS_REMOVABLE    (ushort)0x0008
+#define ASC_CNTL_NO_SCAM           (ushort)0x0010
+#define ASC_CNTL_INT_MULTI_Q       (ushort)0x0080
+#define ASC_CNTL_NO_LUN_SUPPORT    (ushort)0x0040
+#define ASC_CNTL_NO_VERIFY_COPY    (ushort)0x0100
+#define ASC_CNTL_RESET_SCSI        (ushort)0x0200
+#define ASC_CNTL_INIT_INQUIRY      (ushort)0x0400
+#define ASC_CNTL_INIT_VERBOSE      (ushort)0x0800
+#define ASC_CNTL_SCSI_PARITY       (ushort)0x1000
+#define ASC_CNTL_BURST_MODE        (ushort)0x2000
+#define ASC_CNTL_SDTR_ENABLE_ULTRA (ushort)0x4000
+#define ASC_EEP_DVC_CFG_BEG_VL    2
+#define ASC_EEP_MAX_DVC_ADDR_VL   15
+#define ASC_EEP_DVC_CFG_BEG      32
+#define ASC_EEP_MAX_DVC_ADDR     45
+#define ASC_EEP_DEFINED_WORDS    10
+#define ASC_EEP_MAX_ADDR         63
+#define ASC_EEP_RES_WORDS         0
+#define ASC_EEP_MAX_RETRY        20
+#define ASC_MAX_INIT_BUSY_RETRY   8
+#define ASC_EEP_ISA_PNP_WSIZE    16
+
+/*
+ * These macros keep the chip SCSI id and ISA DMA speed
+ * bitfields in board order. C bitfields aren't portable
+ * between big and little-endian platforms so they are
+ * not used.
+ */
+
+#define ASC_EEP_GET_CHIP_ID(cfg)    ((cfg)->id_speed & 0x0f)
+#define ASC_EEP_GET_DMA_SPD(cfg)    (((cfg)->id_speed & 0xf0) >> 4)
+#define ASC_EEP_SET_CHIP_ID(cfg, sid) \
+   ((cfg)->id_speed = ((cfg)->id_speed & 0xf0) | ((sid) & ASC_MAX_TID))
+#define ASC_EEP_SET_DMA_SPD(cfg, spd) \
+   ((cfg)->id_speed = ((cfg)->id_speed & 0x0f) | ((spd) & 0x0f) << 4)
+
+typedef struct asceep_config {
+    ushort              cfg_lsw;
+    ushort              cfg_msw;
+    uchar               init_sdtr;
+    uchar               disc_enable;
+    uchar               use_cmd_qng;
+    uchar               start_motor;
+    uchar               max_total_qng;
+    uchar               max_tag_qng;
+    uchar               bios_scan;
+    uchar               power_up_wait;
+    uchar               no_scam;
+    uchar               id_speed; /* low order 4 bits is chip scsi id */
+                                  /* high order 4 bits is isa dma speed */
+    uchar               dos_int13_table[ASC_MAX_TID + 1];
+    uchar               adapter_info[6];
+    ushort              cntl;
+    ushort              chksum;
+} ASCEEP_CONFIG;
+
+#define ASC_PCI_CFG_LSW_SCSI_PARITY  0x0800
+#define ASC_PCI_CFG_LSW_BURST_MODE   0x0080
+#define ASC_PCI_CFG_LSW_INTR_ABLE    0x0020
+
+#define ASC_EEP_CMD_READ          0x80
+#define ASC_EEP_CMD_WRITE         0x40
+#define ASC_EEP_CMD_WRITE_ABLE    0x30
+#define ASC_EEP_CMD_WRITE_DISABLE 0x00
+#define ASC_OVERRUN_BSIZE  0x00000048UL
+#define ASC_CTRL_BREAK_ONCE        0x0001
+#define ASC_CTRL_BREAK_STAY_IDLE   0x0002
+#define ASCV_MSGOUT_BEG         0x0000
+#define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)
+#define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)
+#define ASCV_BREAK_SAVED_CODE   (ushort)0x0006
+#define ASCV_MSGIN_BEG          (ASCV_MSGOUT_BEG+8)
+#define ASCV_MSGIN_SDTR_PERIOD  (ASCV_MSGIN_BEG+3)
+#define ASCV_MSGIN_SDTR_OFFSET  (ASCV_MSGIN_BEG+4)
+#define ASCV_SDTR_DATA_BEG      (ASCV_MSGIN_BEG+8)
+#define ASCV_SDTR_DONE_BEG      (ASCV_SDTR_DATA_BEG+8)
+#define ASCV_MAX_DVC_QNG_BEG    (ushort)0x0020
+#define ASCV_BREAK_ADDR           (ushort)0x0028
+#define ASCV_BREAK_NOTIFY_COUNT   (ushort)0x002A
+#define ASCV_BREAK_CONTROL        (ushort)0x002C
+#define ASCV_BREAK_HIT_COUNT      (ushort)0x002E
+
+#define ASCV_ASCDVC_ERR_CODE_W  (ushort)0x0030
+#define ASCV_MCODE_CHKSUM_W   (ushort)0x0032
+#define ASCV_MCODE_SIZE_W     (ushort)0x0034
+#define ASCV_STOP_CODE_B      (ushort)0x0036
+#define ASCV_DVC_ERR_CODE_B   (ushort)0x0037
+#define ASCV_OVERRUN_PADDR_D  (ushort)0x0038
+#define ASCV_OVERRUN_BSIZE_D  (ushort)0x003C
+#define ASCV_HALTCODE_W       (ushort)0x0040
+#define ASCV_CHKSUM_W         (ushort)0x0042
+#define ASCV_MC_DATE_W        (ushort)0x0044
+#define ASCV_MC_VER_W         (ushort)0x0046
+#define ASCV_NEXTRDY_B        (ushort)0x0048
+#define ASCV_DONENEXT_B       (ushort)0x0049
+#define ASCV_USE_TAGGED_QNG_B (ushort)0x004A
+#define ASCV_SCSIBUSY_B       (ushort)0x004B
+#define ASCV_Q_DONE_IN_PROGRESS_B  (ushort)0x004C
+#define ASCV_CURCDB_B         (ushort)0x004D
+#define ASCV_RCLUN_B          (ushort)0x004E
+#define ASCV_BUSY_QHEAD_B     (ushort)0x004F
+#define ASCV_DISC1_QHEAD_B    (ushort)0x0050
+#define ASCV_DISC_ENABLE_B    (ushort)0x0052
+#define ASCV_CAN_TAGGED_QNG_B (ushort)0x0053
+#define ASCV_HOSTSCSI_ID_B    (ushort)0x0055
+#define ASCV_MCODE_CNTL_B     (ushort)0x0056
+#define ASCV_NULL_TARGET_B    (ushort)0x0057
+#define ASCV_FREE_Q_HEAD_W    (ushort)0x0058
+#define ASCV_DONE_Q_TAIL_W    (ushort)0x005A
+#define ASCV_FREE_Q_HEAD_B    (ushort)(ASCV_FREE_Q_HEAD_W+1)
+#define ASCV_DONE_Q_TAIL_B    (ushort)(ASCV_DONE_Q_TAIL_W+1)
+#define ASCV_HOST_FLAG_B      (ushort)0x005D
+#define ASCV_TOTAL_READY_Q_B  (ushort)0x0064
+#define ASCV_VER_SERIAL_B     (ushort)0x0065
+#define ASCV_HALTCODE_SAVED_W (ushort)0x0066
+#define ASCV_WTM_FLAG_B       (ushort)0x0068
+#define ASCV_RISC_FLAG_B      (ushort)0x006A
+#define ASCV_REQ_SG_LIST_QP   (ushort)0x006B
+#define ASC_HOST_FLAG_IN_ISR        0x01
+#define ASC_HOST_FLAG_ACK_INT       0x02
+#define ASC_RISC_FLAG_GEN_INT      0x01
+#define ASC_RISC_FLAG_REQ_SG_LIST  0x02
+#define IOP_CTRL         (0x0F)
+#define IOP_STATUS       (0x0E)
+#define IOP_INT_ACK      IOP_STATUS
+#define IOP_REG_IFC      (0x0D)
+#define IOP_SYN_OFFSET    (0x0B)
+#define IOP_EXTRA_CONTROL (0x0D)
+#define IOP_REG_PC        (0x0C)
+#define IOP_RAM_ADDR      (0x0A)
+#define IOP_RAM_DATA      (0x08)
+#define IOP_EEP_DATA      (0x06)
+#define IOP_EEP_CMD       (0x07)
+#define IOP_VERSION       (0x03)
+#define IOP_CONFIG_HIGH   (0x04)
+#define IOP_CONFIG_LOW    (0x02)
+#define IOP_SIG_BYTE      (0x01)
+#define IOP_SIG_WORD      (0x00)
+#define IOP_REG_DC1      (0x0E)
+#define IOP_REG_DC0      (0x0C)
+#define IOP_REG_SB       (0x0B)
+#define IOP_REG_DA1      (0x0A)
+#define IOP_REG_DA0      (0x08)
+#define IOP_REG_SC       (0x09)
+#define IOP_DMA_SPEED    (0x07)
+#define IOP_REG_FLAG     (0x07)
+#define IOP_FIFO_H       (0x06)
+#define IOP_FIFO_L       (0x04)
+#define IOP_REG_ID       (0x05)
+#define IOP_REG_QP       (0x03)
+#define IOP_REG_IH       (0x02)
+#define IOP_REG_IX       (0x01)
+#define IOP_REG_AX       (0x00)
+#define IFC_REG_LOCK      (0x00)
+#define IFC_REG_UNLOCK    (0x09)
+#define IFC_WR_EN_FILTER  (0x10)
+#define IFC_RD_NO_EEPROM  (0x10)
+#define IFC_SLEW_RATE     (0x20)
+#define IFC_ACT_NEG       (0x40)
+#define IFC_INP_FILTER    (0x80)
+#define IFC_INIT_DEFAULT  (IFC_ACT_NEG | IFC_REG_UNLOCK)
+#define SC_SEL   (uchar)(0x80)
+#define SC_BSY   (uchar)(0x40)
+#define SC_ACK   (uchar)(0x20)
+#define SC_REQ   (uchar)(0x10)
+#define SC_ATN   (uchar)(0x08)
+#define SC_IO    (uchar)(0x04)
+#define SC_CD    (uchar)(0x02)
+#define SC_MSG   (uchar)(0x01)
+#define SEC_SCSI_CTL         (uchar)(0x80)
+#define SEC_ACTIVE_NEGATE    (uchar)(0x40)
+#define SEC_SLEW_RATE        (uchar)(0x20)
+#define SEC_ENABLE_FILTER    (uchar)(0x10)
+#define ASC_HALT_EXTMSG_IN     (ushort)0x8000
+#define ASC_HALT_CHK_CONDITION (ushort)0x8100
+#define ASC_HALT_SS_QUEUE_FULL (ushort)0x8200
+#define ASC_HALT_DISABLE_ASYN_USE_SYN_FIX  (ushort)0x8300
+#define ASC_HALT_ENABLE_ASYN_USE_SYN_FIX   (ushort)0x8400
+#define ASC_HALT_SDTR_REJECTED (ushort)0x4000
+#define ASC_HALT_HOST_COPY_SG_LIST_TO_RISC ( ushort )0x2000
+#define ASC_MAX_QNO        0xF8
+#define ASC_DATA_SEC_BEG   (ushort)0x0080
+#define ASC_DATA_SEC_END   (ushort)0x0080
+#define ASC_CODE_SEC_BEG   (ushort)0x0080
+#define ASC_CODE_SEC_END   (ushort)0x0080
+#define ASC_QADR_BEG       (0x4000)
+#define ASC_QADR_USED      (ushort)(ASC_MAX_QNO * 64)
+#define ASC_QADR_END       (ushort)0x7FFF
+#define ASC_QLAST_ADR      (ushort)0x7FC0
+#define ASC_QBLK_SIZE      0x40
+#define ASC_BIOS_DATA_QBEG 0xF8
+#define ASC_MIN_ACTIVE_QNO 0x01
+#define ASC_QLINK_END      0xFF
+#define ASC_EEPROM_WORDS   0x10
+#define ASC_MAX_MGS_LEN    0x10
+#define ASC_BIOS_ADDR_DEF  0xDC00
+#define ASC_BIOS_SIZE      0x3800
+#define ASC_BIOS_RAM_OFF   0x3800
+#define ASC_BIOS_RAM_SIZE  0x800
+#define ASC_BIOS_MIN_ADDR  0xC000
+#define ASC_BIOS_MAX_ADDR  0xEC00
+#define ASC_BIOS_BANK_SIZE 0x0400
+#define ASC_MCODE_START_ADDR  0x0080
+#define ASC_CFG0_HOST_INT_ON    0x0020
+#define ASC_CFG0_BIOS_ON        0x0040
+#define ASC_CFG0_VERA_BURST_ON  0x0080
+#define ASC_CFG0_SCSI_PARITY_ON 0x0800
+#define ASC_CFG1_SCSI_TARGET_ON 0x0080
+#define ASC_CFG1_LRAM_8BITS_ON  0x0800
+#define ASC_CFG_MSW_CLR_MASK    0x3080
+#define CSW_TEST1             (ASC_CS_TYPE)0x8000
+#define CSW_AUTO_CONFIG       (ASC_CS_TYPE)0x4000
+#define CSW_RESERVED1         (ASC_CS_TYPE)0x2000
+#define CSW_IRQ_WRITTEN       (ASC_CS_TYPE)0x1000
+#define CSW_33MHZ_SELECTED    (ASC_CS_TYPE)0x0800
+#define CSW_TEST2             (ASC_CS_TYPE)0x0400
+#define CSW_TEST3             (ASC_CS_TYPE)0x0200
+#define CSW_RESERVED2         (ASC_CS_TYPE)0x0100
+#define CSW_DMA_DONE          (ASC_CS_TYPE)0x0080
+#define CSW_FIFO_RDY          (ASC_CS_TYPE)0x0040
+#define CSW_EEP_READ_DONE     (ASC_CS_TYPE)0x0020
+#define CSW_HALTED            (ASC_CS_TYPE)0x0010
+#define CSW_SCSI_RESET_ACTIVE (ASC_CS_TYPE)0x0008
+#define CSW_PARITY_ERR        (ASC_CS_TYPE)0x0004
+#define CSW_SCSI_RESET_LATCH  (ASC_CS_TYPE)0x0002
+#define CSW_INT_PENDING       (ASC_CS_TYPE)0x0001
+#define CIW_CLR_SCSI_RESET_INT (ASC_CS_TYPE)0x1000
+#define CIW_INT_ACK      (ASC_CS_TYPE)0x0100
+#define CIW_TEST1        (ASC_CS_TYPE)0x0200
+#define CIW_TEST2        (ASC_CS_TYPE)0x0400
+#define CIW_SEL_33MHZ    (ASC_CS_TYPE)0x0800
+#define CIW_IRQ_ACT      (ASC_CS_TYPE)0x1000
+#define CC_CHIP_RESET   (uchar)0x80
+#define CC_SCSI_RESET   (uchar)0x40
+#define CC_HALT         (uchar)0x20
+#define CC_SINGLE_STEP  (uchar)0x10
+#define CC_DMA_ABLE     (uchar)0x08
+#define CC_TEST         (uchar)0x04
+#define CC_BANK_ONE     (uchar)0x02
+#define CC_DIAG         (uchar)0x01
+#define ASC_1000_ID0W      0x04C1
+#define ASC_1000_ID0W_FIX  0x00C1
+#define ASC_1000_ID1B      0x25
+#define ASC_EISA_BIG_IOP_GAP   (0x1C30-0x0C50)
+#define ASC_EISA_SMALL_IOP_GAP (0x0020)
+#define ASC_EISA_MIN_IOP_ADDR  (0x0C30)
+#define ASC_EISA_MAX_IOP_ADDR  (0xFC50)
+#define ASC_EISA_REV_IOP_MASK  (0x0C83)
+#define ASC_EISA_PID_IOP_MASK  (0x0C80)
+#define ASC_EISA_CFG_IOP_MASK  (0x0C86)
+#define ASC_GET_EISA_SLOT(iop)  (PortAddr)((iop) & 0xF000)
+#define ASC_EISA_ID_740    0x01745004UL
+#define ASC_EISA_ID_750    0x01755004UL
+#define INS_HALTINT        (ushort)0x6281
+#define INS_HALT           (ushort)0x6280
+#define INS_SINT           (ushort)0x6200
+#define INS_RFLAG_WTM      (ushort)0x7380
+#define ASC_MC_SAVE_CODE_WSIZE  0x500
+#define ASC_MC_SAVE_DATA_WSIZE  0x40
+
+typedef struct asc_mc_saved {
+    ushort              data[ASC_MC_SAVE_DATA_WSIZE];
+    ushort              code[ASC_MC_SAVE_CODE_WSIZE];
+} ASC_MC_SAVED;
+
+#define AscGetQDoneInProgress(port)         AscReadLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B)
+#define AscPutQDoneInProgress(port, val)    AscWriteLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B, val)
+#define AscGetVarFreeQHead(port)            AscReadLramWord((port), ASCV_FREE_Q_HEAD_W)
+#define AscGetVarDoneQTail(port)            AscReadLramWord((port), ASCV_DONE_Q_TAIL_W)
+#define AscPutVarFreeQHead(port, val)       AscWriteLramWord((port), ASCV_FREE_Q_HEAD_W, val)
+#define AscPutVarDoneQTail(port, val)       AscWriteLramWord((port), ASCV_DONE_Q_TAIL_W, val)
+#define AscGetRiscVarFreeQHead(port)        AscReadLramByte((port), ASCV_NEXTRDY_B)
+#define AscGetRiscVarDoneQTail(port)        AscReadLramByte((port), ASCV_DONENEXT_B)
+#define AscPutRiscVarFreeQHead(port, val)   AscWriteLramByte((port), ASCV_NEXTRDY_B, val)
+#define AscPutRiscVarDoneQTail(port, val)   AscWriteLramByte((port), ASCV_DONENEXT_B, val)
+#define AscPutMCodeSDTRDoneAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id), (data));
+#define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id));
+#define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data);
+#define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id));
+#define AscSynIndexToPeriod(index)        (uchar)(asc_dvc->sdtr_period_tbl[ (index) ])
+#define AscGetChipSignatureByte(port)     (uchar)inp((port)+IOP_SIG_BYTE)
+#define AscGetChipSignatureWord(port)     (ushort)inpw((port)+IOP_SIG_WORD)
+#define AscGetChipVerNo(port)             (uchar)inp((port)+IOP_VERSION)
+#define AscGetChipCfgLsw(port)            (ushort)inpw((port)+IOP_CONFIG_LOW)
+#define AscGetChipCfgMsw(port)            (ushort)inpw((port)+IOP_CONFIG_HIGH)
+#define AscSetChipCfgLsw(port, data)      outpw((port)+IOP_CONFIG_LOW, data)
+#define AscSetChipCfgMsw(port, data)      outpw((port)+IOP_CONFIG_HIGH, data)
+#define AscGetChipEEPCmd(port)            (uchar)inp((port)+IOP_EEP_CMD)
+#define AscSetChipEEPCmd(port, data)      outp((port)+IOP_EEP_CMD, data)
+#define AscGetChipEEPData(port)           (ushort)inpw((port)+IOP_EEP_DATA)
+#define AscSetChipEEPData(port, data)     outpw((port)+IOP_EEP_DATA, data)
+#define AscGetChipLramAddr(port)          (ushort)inpw((PortAddr)((port)+IOP_RAM_ADDR))
+#define AscSetChipLramAddr(port, addr)    outpw((PortAddr)((port)+IOP_RAM_ADDR), addr)
+#define AscGetChipLramData(port)          (ushort)inpw((port)+IOP_RAM_DATA)
+#define AscSetChipLramData(port, data)    outpw((port)+IOP_RAM_DATA, data)
+#define AscGetChipIFC(port)               (uchar)inp((port)+IOP_REG_IFC)
+#define AscSetChipIFC(port, data)          outp((port)+IOP_REG_IFC, data)
+#define AscGetChipStatus(port)            (ASC_CS_TYPE)inpw((port)+IOP_STATUS)
+#define AscSetChipStatus(port, cs_val)    outpw((port)+IOP_STATUS, cs_val)
+#define AscGetChipControl(port)           (uchar)inp((port)+IOP_CTRL)
+#define AscSetChipControl(port, cc_val)   outp((port)+IOP_CTRL, cc_val)
+#define AscGetChipSyn(port)               (uchar)inp((port)+IOP_SYN_OFFSET)
+#define AscSetChipSyn(port, data)         outp((port)+IOP_SYN_OFFSET, data)
+#define AscSetPCAddr(port, data)          outpw((port)+IOP_REG_PC, data)
+#define AscGetPCAddr(port)                (ushort)inpw((port)+IOP_REG_PC)
+#define AscIsIntPending(port)             (AscGetChipStatus(port) & (CSW_INT_PENDING | CSW_SCSI_RESET_LATCH))
+#define AscGetChipScsiID(port)            ((AscGetChipCfgLsw(port) >> 8) & ASC_MAX_TID)
+#define AscGetExtraControl(port)          (uchar)inp((port)+IOP_EXTRA_CONTROL)
+#define AscSetExtraControl(port, data)    outp((port)+IOP_EXTRA_CONTROL, data)
+#define AscReadChipAX(port)               (ushort)inpw((port)+IOP_REG_AX)
+#define AscWriteChipAX(port, data)        outpw((port)+IOP_REG_AX, data)
+#define AscReadChipIX(port)               (uchar)inp((port)+IOP_REG_IX)
+#define AscWriteChipIX(port, data)        outp((port)+IOP_REG_IX, data)
+#define AscReadChipIH(port)               (ushort)inpw((port)+IOP_REG_IH)
+#define AscWriteChipIH(port, data)        outpw((port)+IOP_REG_IH, data)
+#define AscReadChipQP(port)               (uchar)inp((port)+IOP_REG_QP)
+#define AscWriteChipQP(port, data)        outp((port)+IOP_REG_QP, data)
+#define AscReadChipFIFO_L(port)           (ushort)inpw((port)+IOP_REG_FIFO_L)
+#define AscWriteChipFIFO_L(port, data)    outpw((port)+IOP_REG_FIFO_L, data)
+#define AscReadChipFIFO_H(port)           (ushort)inpw((port)+IOP_REG_FIFO_H)
+#define AscWriteChipFIFO_H(port, data)    outpw((port)+IOP_REG_FIFO_H, data)
+#define AscReadChipDmaSpeed(port)         (uchar)inp((port)+IOP_DMA_SPEED)
+#define AscWriteChipDmaSpeed(port, data)  outp((port)+IOP_DMA_SPEED, data)
+#define AscReadChipDA0(port)              (ushort)inpw((port)+IOP_REG_DA0)
+#define AscWriteChipDA0(port)             outpw((port)+IOP_REG_DA0, data)
+#define AscReadChipDA1(port)              (ushort)inpw((port)+IOP_REG_DA1)
+#define AscWriteChipDA1(port)             outpw((port)+IOP_REG_DA1, data)
+#define AscReadChipDC0(port)              (ushort)inpw((port)+IOP_REG_DC0)
+#define AscWriteChipDC0(port)             outpw((port)+IOP_REG_DC0, data)
+#define AscReadChipDC1(port)              (ushort)inpw((port)+IOP_REG_DC1)
+#define AscWriteChipDC1(port)             outpw((port)+IOP_REG_DC1, data)
+#define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)
+#define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)
+
+STATIC int       AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg);
+STATIC int       AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg);
+STATIC void      AscWaitEEPRead(void);
+STATIC void      AscWaitEEPWrite(void);
+STATIC ushort    AscReadEEPWord(PortAddr, uchar);
+STATIC ushort    AscWriteEEPWord(PortAddr, uchar, ushort);
+STATIC ushort    AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
+STATIC int       AscSetEEPConfigOnce(PortAddr, ASCEEP_CONFIG *, ushort);
+STATIC int       AscSetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
+STATIC int       AscStartChip(PortAddr);
+STATIC int       AscStopChip(PortAddr);
+STATIC void      AscSetChipIH(PortAddr, ushort);
+STATIC int       AscIsChipHalted(PortAddr);
+STATIC void      AscAckInterrupt(PortAddr);
+STATIC void      AscDisableInterrupt(PortAddr);
+STATIC void      AscEnableInterrupt(PortAddr);
+STATIC void      AscSetBank(PortAddr, uchar);
+STATIC int       AscResetChipAndScsiBus(ASC_DVC_VAR *);
+#ifdef CONFIG_ISA
+STATIC ushort    AscGetIsaDmaChannel(PortAddr);
+STATIC ushort    AscSetIsaDmaChannel(PortAddr, ushort);
+STATIC uchar     AscSetIsaDmaSpeed(PortAddr, uchar);
+STATIC uchar     AscGetIsaDmaSpeed(PortAddr);
+#endif /* CONFIG_ISA */
+STATIC uchar     AscReadLramByte(PortAddr, ushort);
+STATIC ushort    AscReadLramWord(PortAddr, ushort);
+#if CC_VERY_LONG_SG_LIST
+STATIC ASC_DCNT  AscReadLramDWord(PortAddr, ushort);
+#endif /* CC_VERY_LONG_SG_LIST */
+STATIC void      AscWriteLramWord(PortAddr, ushort, ushort);
+STATIC void      AscWriteLramByte(PortAddr, ushort, uchar);
+STATIC ASC_DCNT  AscMemSumLramWord(PortAddr, ushort, int);
+STATIC void      AscMemWordSetLram(PortAddr, ushort, ushort, int);
+STATIC void      AscMemWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
+STATIC void      AscMemDWordCopyPtrToLram(PortAddr, ushort, uchar *, int);
+STATIC void      AscMemWordCopyPtrFromLram(PortAddr, ushort, uchar *, int);
+STATIC ushort    AscInitAscDvcVar(ASC_DVC_VAR *);
+STATIC ushort    AscInitFromEEP(ASC_DVC_VAR *);
+STATIC ushort    AscInitFromAscDvcVar(ASC_DVC_VAR *);
+STATIC ushort    AscInitMicroCodeVar(ASC_DVC_VAR *);
+STATIC int       AscTestExternalLram(ASC_DVC_VAR *);
+STATIC uchar     AscMsgOutSDTR(ASC_DVC_VAR *, uchar, uchar);
+STATIC uchar     AscCalSDTRData(ASC_DVC_VAR *, uchar, uchar);
+STATIC void      AscSetChipSDTR(PortAddr, uchar, uchar);
+STATIC uchar     AscGetSynPeriodIndex(ASC_DVC_VAR *, uchar);
+STATIC uchar     AscAllocFreeQueue(PortAddr, uchar);
+STATIC uchar     AscAllocMultipleFreeQueue(PortAddr, uchar, uchar);
+STATIC int       AscHostReqRiscHalt(PortAddr);
+STATIC int       AscStopQueueExe(PortAddr);
+STATIC int       AscSendScsiQueue(ASC_DVC_VAR *,
+                    ASC_SCSI_Q * scsiq,
+                    uchar n_q_required);
+STATIC int       AscPutReadyQueue(ASC_DVC_VAR *,
+                    ASC_SCSI_Q *, uchar);
+STATIC int       AscPutReadySgListQueue(ASC_DVC_VAR *,
+                    ASC_SCSI_Q *, uchar);
+STATIC int       AscSetChipSynRegAtID(PortAddr, uchar, uchar);
+STATIC int       AscSetRunChipSynRegAtID(PortAddr, uchar, uchar);
+STATIC ushort    AscInitLram(ASC_DVC_VAR *);
+STATIC ushort    AscInitQLinkVar(ASC_DVC_VAR *);
+STATIC int       AscSetLibErrorCode(ASC_DVC_VAR *, ushort);
+STATIC int       AscIsrChipHalted(ASC_DVC_VAR *);
+STATIC uchar     _AscCopyLramScsiDoneQ(PortAddr, ushort,
+                    ASC_QDONE_INFO *, ASC_DCNT);
+STATIC int       AscIsrQDone(ASC_DVC_VAR *);
+STATIC int       AscCompareString(uchar *, uchar *, int);
+#ifdef CONFIG_ISA
+STATIC ushort    AscGetEisaChipCfg(PortAddr);
+STATIC ASC_DCNT  AscGetEisaProductID(PortAddr);
+STATIC PortAddr  AscSearchIOPortAddrEISA(PortAddr);
+STATIC PortAddr  AscSearchIOPortAddr11(PortAddr);
+STATIC PortAddr  AscSearchIOPortAddr(PortAddr, ushort);
+STATIC void      AscSetISAPNPWaitForKey(void);
+#endif /* CONFIG_ISA */
+STATIC uchar     AscGetChipScsiCtrl(PortAddr);
+STATIC uchar     AscSetChipScsiID(PortAddr, uchar);
+STATIC uchar     AscGetChipVersion(PortAddr, ushort);
+STATIC ushort    AscGetChipBusType(PortAddr);
+STATIC ASC_DCNT  AscLoadMicroCode(PortAddr, ushort, uchar *, ushort);
+STATIC int       AscFindSignature(PortAddr);
+STATIC void      AscToggleIRQAct(PortAddr);
+STATIC uchar     AscGetChipIRQ(PortAddr, ushort);
+STATIC uchar     AscSetChipIRQ(PortAddr, uchar, ushort);
+STATIC ushort    AscGetChipBiosAddress(PortAddr, ushort);
+STATIC inline ulong DvcEnterCritical(void);
+STATIC inline void DvcLeaveCritical(ulong);
+#ifdef CONFIG_PCI
+STATIC uchar     DvcReadPCIConfigByte(ASC_DVC_VAR *, ushort);
+STATIC void      DvcWritePCIConfigByte(ASC_DVC_VAR *,
+                    ushort, uchar);
+#endif /* CONFIG_PCI */
+STATIC ushort      AscGetChipBiosAddress(PortAddr, ushort);
+STATIC void      DvcSleepMilliSecond(ASC_DCNT);
+STATIC void      DvcDelayNanoSecond(ASC_DVC_VAR *, ASC_DCNT);
+STATIC void      DvcPutScsiQ(PortAddr, ushort, uchar *, int);
+STATIC void      DvcGetQinfo(PortAddr, ushort, uchar *, int);
+STATIC ushort    AscInitGetConfig(ASC_DVC_VAR *);
+STATIC ushort    AscInitSetConfig(ASC_DVC_VAR *);
+STATIC ushort    AscInitAsc1000Driver(ASC_DVC_VAR *);
+STATIC void      AscAsyncFix(ASC_DVC_VAR *, uchar,
+                    ASC_SCSI_INQUIRY *);
+STATIC int       AscTagQueuingSafe(ASC_SCSI_INQUIRY *);
+STATIC void      AscInquiryHandling(ASC_DVC_VAR *,
+                    uchar, ASC_SCSI_INQUIRY *);
+STATIC int       AscExeScsiQueue(ASC_DVC_VAR *, ASC_SCSI_Q *);
+STATIC int       AscISR(ASC_DVC_VAR *);
+STATIC uint      AscGetNumOfFreeQueue(ASC_DVC_VAR *, uchar,
+                    uchar);
+STATIC int       AscSgListToQueue(int);
+#ifdef CONFIG_ISA
+STATIC void      AscEnableIsaDma(uchar);
+#endif /* CONFIG_ISA */
+STATIC ASC_DCNT  AscGetMaxDmaCount(ushort);
+
+
+/*
+ * --- Adv Library Constants and Macros
+ */
+
+#define ADV_LIB_VERSION_MAJOR  5
+#define ADV_LIB_VERSION_MINOR  14
+
+/*
+ * Define Adv Library required special types.
+ */
+
+/*
+ * Portable Data Types
+ *
+ * Any instance where a 32-bit long or pointer type is assumed
+ * for precision or HW defined structures, the following define
+ * types must be used. In Linux the char, short, and int types
+ * are all consistent at 8, 16, and 32 bits respectively. Pointers
+ * and long types are 64 bits on Alpha and UltraSPARC.
+ */
+#define ADV_PADDR __u32         /* Physical address data type. */
+#define ADV_VADDR __u32         /* Virtual address data type. */
+#define ADV_DCNT  __u32         /* Unsigned Data count type. */
+#define ADV_SDCNT __s32         /* Signed Data count type. */
+
+/*
+ * These macros are used to convert a virtual address to a
+ * 32-bit value. This currently can be used on Linux Alpha
+ * which uses 64-bit virtual address but a 32-bit bus address.
+ * This is likely to break in the future, but doing this now
+ * will give us time to change the HW and FW to handle 64-bit
+ * addresses.
+ */
+#define ADV_VADDR_TO_U32   virt_to_bus
+#define ADV_U32_TO_VADDR   bus_to_virt
+
+#define AdvPortAddr  ulong              /* Virtual memory address size */
+
+/*
+ * Define Adv Library required memory access macros.
+ */
+#define ADV_MEM_READB(addr) readb(addr)
+#define ADV_MEM_READW(addr) readw(addr)
+#define ADV_MEM_WRITEB(addr, byte) writeb(byte, addr)
+#define ADV_MEM_WRITEW(addr, word) writew(word, addr)
+#define ADV_MEM_WRITEDW(addr, dword) writel(dword, addr)
+
+#define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 15)
+
+/*
+ * For wide  boards a CDB length maximum of 16 bytes
+ * is supported.
+ */
+#define ADV_MAX_CDB_LEN     16
+
+/*
+ * Define total number of simultaneous maximum element scatter-gather
+ * request blocks per wide adapter. ASC_DEF_MAX_HOST_QNG (253) is the
+ * maximum number of outstanding commands per wide host adapter. Each
+ * command uses one or more ADV_SG_BLOCK each with 15 scatter-gather
+ * elements. Allow each command to have at least one ADV_SG_BLOCK structure.
+ * This allows about 15 commands to have the maximum 17 ADV_SG_BLOCK
+ * structures or 255 scatter-gather elements.
+ *
+ */
+#define ADV_TOT_SG_BLOCK        ASC_DEF_MAX_HOST_QNG
+
+/*
+ * Define Adv Library required maximum number of scatter-gather
+ * elements per request.
+ */
+#define ADV_MAX_SG_LIST         255
+
+/* Number of SG blocks needed. */
+#define ADV_NUM_SG_BLOCK \
+    ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK)
+
+/* Total contiguous memory needed for SG blocks. */
+#define ADV_SG_TOTAL_MEM_SIZE \
+    (sizeof(ADV_SG_BLOCK) *  ADV_NUM_SG_BLOCK)
+
+#define ADV_PAGE_SIZE PAGE_SIZE
+
+#define ADV_NUM_PAGE_CROSSING \
+    ((ADV_SG_TOTAL_MEM_SIZE + (ADV_PAGE_SIZE - 1))/ADV_PAGE_SIZE)
+
+/* a_condor.h */
+#define ADV_PCI_VENDOR_ID               0x10CD
+#define ADV_PCI_DEVICE_ID_REV_A         0x2300
+#define ADV_PCI_DEVID_38C0800_REV1      0x2500
+#define ADV_PCI_DEVID_38C1600_REV1      0x2700
+
+#define ADV_EEP_DVC_CFG_BEGIN           (0x00)
+#define ADV_EEP_DVC_CFG_END             (0x15)
+#define ADV_EEP_DVC_CTL_BEGIN           (0x16)  /* location of OEM name */
+#define ADV_EEP_MAX_WORD_ADDR           (0x1E)
+
+#define ADV_EEP_DELAY_MS                100
+
+#define ADV_EEPROM_BIG_ENDIAN          0x8000   /* EEPROM Bit 15 */
+#define ADV_EEPROM_BIOS_ENABLE         0x4000   /* EEPROM Bit 14 */
+/*
+ * For the ASC3550 Bit 13 is Termination Polarity control bit.
+ * For later ICs Bit 13 controls whether the CIS (Card Information
+ * Service Section) is loaded from EEPROM.
+ */
+#define ADV_EEPROM_TERM_POL            0x2000   /* EEPROM Bit 13 */
+#define ADV_EEPROM_CIS_LD              0x2000   /* EEPROM Bit 13 */
+/*
+ * ASC38C1600 Bit 11
+ *
+ * If EEPROM Bit 11 is 0 for Function 0, then Function 0 will specify
+ * INT A in the PCI Configuration Space Int Pin field. If it is 1, then
+ * Function 0 will specify INT B.
+ *
+ * If EEPROM Bit 11 is 0 for Function 1, then Function 1 will specify
+ * INT B in the PCI Configuration Space Int Pin field. If it is 1, then
+ * Function 1 will specify INT A.
+ */
+#define ADV_EEPROM_INTAB               0x0800   /* EEPROM Bit 11 */
+
+typedef struct adveep_3550_config
+{
+                                /* Word Offset, Description */
+
+  ushort cfg_lsw;               /* 00 power up initialization */
+                                /*  bit 13 set - Term Polarity Control */
+                                /*  bit 14 set - BIOS Enable */
+                                /*  bit 15 set - Big Endian Mode */
+  ushort cfg_msw;               /* 01 unused      */
+  ushort disc_enable;           /* 02 disconnect enable */
+  ushort wdtr_able;             /* 03 Wide DTR able */
+  ushort sdtr_able;             /* 04 Synchronous DTR able */
+  ushort start_motor;           /* 05 send start up motor */
+  ushort tagqng_able;           /* 06 tag queuing able */
+  ushort bios_scan;             /* 07 BIOS device control */
+  ushort scam_tolerant;         /* 08 no scam */
+
+  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
+  uchar  bios_boot_delay;       /*    power up wait */
+
+  uchar  scsi_reset_delay;      /* 10 reset delay */
+  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
+                                /*    high nibble is lun */
+                                /*    low nibble is scsi id */
+
+  uchar  termination;           /* 11 0 - automatic */
+                                /*    1 - low off / high off */
+                                /*    2 - low off / high on */
+                                /*    3 - low on  / high on */
+                                /*    There is no low on  / high off */
+
+  uchar  reserved1;             /*    reserved byte (not used) */
+
+  ushort bios_ctrl;             /* 12 BIOS control bits */
+                                /*  bit 0  BIOS don't act as initiator. */
+                                /*  bit 1  BIOS > 1 GB support */
+                                /*  bit 2  BIOS > 2 Disk Support */
+                                /*  bit 3  BIOS don't support removables */
+                                /*  bit 4  BIOS support bootable CD */
+                                /*  bit 5  BIOS scan enabled */
+                                /*  bit 6  BIOS support multiple LUNs */
+                                /*  bit 7  BIOS display of message */
+                                /*  bit 8  SCAM disabled */
+                                /*  bit 9  Reset SCSI bus during init. */
+                                /*  bit 10 */
+                                /*  bit 11 No verbose initialization. */
+                                /*  bit 12 SCSI parity enabled */
+                                /*  bit 13 */
+                                /*  bit 14 */
+                                /*  bit 15 */
+  ushort  ultra_able;           /* 13 ULTRA speed able */
+  ushort  reserved2;            /* 14 reserved */
+  uchar   max_host_qng;         /* 15 maximum host queuing */
+  uchar   max_dvc_qng;          /*    maximum per device queuing */
+  ushort  dvc_cntl;             /* 16 control bit for driver */
+  ushort  bug_fix;              /* 17 control bit for bug fix */
+  ushort  serial_number_word1;  /* 18 Board serial number word 1 */
+  ushort  serial_number_word2;  /* 19 Board serial number word 2 */
+  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
+  ushort  check_sum;            /* 21 EEP check sum */
+  uchar   oem_name[16];         /* 22 OEM name */
+  ushort  dvc_err_code;         /* 30 last device driver error code */
+  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
+  ushort  adv_err_addr;         /* 32 last uc error address */
+  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
+  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
+  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */
+  ushort  num_of_err;           /* 36 number of error */
+} ADVEEP_3550_CONFIG;
+
+typedef struct adveep_38C0800_config
+{
+                                /* Word Offset, Description */
+
+  ushort cfg_lsw;               /* 00 power up initialization */
+                                /*  bit 13 set - Load CIS */
+                                /*  bit 14 set - BIOS Enable */
+                                /*  bit 15 set - Big Endian Mode */
+  ushort cfg_msw;               /* 01 unused      */
+  ushort disc_enable;           /* 02 disconnect enable */
+  ushort wdtr_able;             /* 03 Wide DTR able */
+  ushort sdtr_speed1;           /* 04 SDTR Speed TID 0-3 */
+  ushort start_motor;           /* 05 send start up motor */
+  ushort tagqng_able;           /* 06 tag queuing able */
+  ushort bios_scan;             /* 07 BIOS device control */
+  ushort scam_tolerant;         /* 08 no scam */
+
+  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
+  uchar  bios_boot_delay;       /*    power up wait */
+
+  uchar  scsi_reset_delay;      /* 10 reset delay */
+  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
+                                /*    high nibble is lun */
+                                /*    low nibble is scsi id */
+
+  uchar  termination_se;        /* 11 0 - automatic */
+                                /*    1 - low off / high off */
+                                /*    2 - low off / high on */
+                                /*    3 - low on  / high on */
+                                /*    There is no low on  / high off */
+
+  uchar  termination_lvd;       /* 11 0 - automatic */
+                                /*    1 - low off / high off */
+                                /*    2 - low off / high on */
+                                /*    3 - low on  / high on */
+                                /*    There is no low on  / high off */
+
+  ushort bios_ctrl;             /* 12 BIOS control bits */
+                                /*  bit 0  BIOS don't act as initiator. */
+                                /*  bit 1  BIOS > 1 GB support */
+                                /*  bit 2  BIOS > 2 Disk Support */
+                                /*  bit 3  BIOS don't support removables */
+                                /*  bit 4  BIOS support bootable CD */
+                                /*  bit 5  BIOS scan enabled */
+                                /*  bit 6  BIOS support multiple LUNs */
+                                /*  bit 7  BIOS display of message */
+                                /*  bit 8  SCAM disabled */
+                                /*  bit 9  Reset SCSI bus during init. */
+                                /*  bit 10 */
+                                /*  bit 11 No verbose initialization. */
+                                /*  bit 12 SCSI parity enabled */
+                                /*  bit 13 */
+                                /*  bit 14 */
+                                /*  bit 15 */
+  ushort  sdtr_speed2;          /* 13 SDTR speed TID 4-7 */
+  ushort  sdtr_speed3;          /* 14 SDTR speed TID 8-11 */
+  uchar   max_host_qng;         /* 15 maximum host queueing */
+  uchar   max_dvc_qng;          /*    maximum per device queuing */
+  ushort  dvc_cntl;             /* 16 control bit for driver */
+  ushort  sdtr_speed4;          /* 17 SDTR speed 4 TID 12-15 */
+  ushort  serial_number_word1;  /* 18 Board serial number word 1 */
+  ushort  serial_number_word2;  /* 19 Board serial number word 2 */
+  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
+  ushort  check_sum;            /* 21 EEP check sum */
+  uchar   oem_name[16];         /* 22 OEM name */
+  ushort  dvc_err_code;         /* 30 last device driver error code */
+  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
+  ushort  adv_err_addr;         /* 32 last uc error address */
+  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
+  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
+  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */
+  ushort  reserved36;           /* 36 reserved */
+  ushort  reserved37;           /* 37 reserved */
+  ushort  reserved38;           /* 38 reserved */
+  ushort  reserved39;           /* 39 reserved */
+  ushort  reserved40;           /* 40 reserved */
+  ushort  reserved41;           /* 41 reserved */
+  ushort  reserved42;           /* 42 reserved */
+  ushort  reserved43;           /* 43 reserved */
+  ushort  reserved44;           /* 44 reserved */
+  ushort  reserved45;           /* 45 reserved */
+  ushort  reserved46;           /* 46 reserved */
+  ushort  reserved47;           /* 47 reserved */
+  ushort  reserved48;           /* 48 reserved */
+  ushort  reserved49;           /* 49 reserved */
+  ushort  reserved50;           /* 50 reserved */
+  ushort  reserved51;           /* 51 reserved */
+  ushort  reserved52;           /* 52 reserved */
+  ushort  reserved53;           /* 53 reserved */
+  ushort  reserved54;           /* 54 reserved */
+  ushort  reserved55;           /* 55 reserved */
+  ushort  cisptr_lsw;           /* 56 CIS PTR LSW */
+  ushort  cisprt_msw;           /* 57 CIS PTR MSW */
+  ushort  subsysvid;            /* 58 SubSystem Vendor ID */
+  ushort  subsysid;             /* 59 SubSystem ID */
+  ushort  reserved60;           /* 60 reserved */
+  ushort  reserved61;           /* 61 reserved */
+  ushort  reserved62;           /* 62 reserved */
+  ushort  reserved63;           /* 63 reserved */
+} ADVEEP_38C0800_CONFIG;
+
+typedef struct adveep_38C1600_config
+{
+                                /* Word Offset, Description */
+
+  ushort cfg_lsw;               /* 00 power up initialization */
+                                /*  bit 11 set - Func. 0 INTB, Func. 1 INTA */
+                                /*       clear - Func. 0 INTA, Func. 1 INTB */
+                                /*  bit 13 set - Load CIS */
+                                /*  bit 14 set - BIOS Enable */
+                                /*  bit 15 set - Big Endian Mode */
+  ushort cfg_msw;               /* 01 unused */
+  ushort disc_enable;           /* 02 disconnect enable */
+  ushort wdtr_able;             /* 03 Wide DTR able */
+  ushort sdtr_speed1;           /* 04 SDTR Speed TID 0-3 */
+  ushort start_motor;           /* 05 send start up motor */
+  ushort tagqng_able;           /* 06 tag queuing able */
+  ushort bios_scan;             /* 07 BIOS device control */
+  ushort scam_tolerant;         /* 08 no scam */
+
+  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
+  uchar  bios_boot_delay;       /*    power up wait */
+
+  uchar  scsi_reset_delay;      /* 10 reset delay */
+  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
+                                /*    high nibble is lun */
+                                /*    low nibble is scsi id */
+
+  uchar  termination_se;        /* 11 0 - automatic */
+                                /*    1 - low off / high off */
+                                /*    2 - low off / high on */
+                                /*    3 - low on  / high on */
+                                /*    There is no low on  / high off */
+
+  uchar  termination_lvd;       /* 11 0 - automatic */
+                                /*    1 - low off / high off */
+                                /*    2 - low off / high on */
+                                /*    3 - low on  / high on */
+                                /*    There is no low on  / high off */
+
+  ushort bios_ctrl;             /* 12 BIOS control bits */
+                                /*  bit 0  BIOS don't act as initiator. */
+                                /*  bit 1  BIOS > 1 GB support */
+                                /*  bit 2  BIOS > 2 Disk Support */
+                                /*  bit 3  BIOS don't support removables */
+                                /*  bit 4  BIOS support bootable CD */
+                                /*  bit 5  BIOS scan enabled */
+                                /*  bit 6  BIOS support multiple LUNs */
+                                /*  bit 7  BIOS display of message */
+                                /*  bit 8  SCAM disabled */
+                                /*  bit 9  Reset SCSI bus during init. */
+                                /*  bit 10 Basic Integrity Checking disabled */
+                                /*  bit 11 No verbose initialization. */
+                                /*  bit 12 SCSI parity enabled */
+                                /*  bit 13 AIPP (Asyn. Info. Ph. Prot.) dis. */
+                                /*  bit 14 */
+                                /*  bit 15 */
+  ushort  sdtr_speed2;          /* 13 SDTR speed TID 4-7 */
+  ushort  sdtr_speed3;          /* 14 SDTR speed TID 8-11 */
+  uchar   max_host_qng;         /* 15 maximum host queueing */
+  uchar   max_dvc_qng;          /*    maximum per device queuing */
+  ushort  dvc_cntl;             /* 16 control bit for driver */
+  ushort  sdtr_speed4;          /* 17 SDTR speed 4 TID 12-15 */
+  ushort  serial_number_word1;  /* 18 Board serial number word 1 */
+  ushort  serial_number_word2;  /* 19 Board serial number word 2 */
+  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
+  ushort  check_sum;            /* 21 EEP check sum */
+  uchar   oem_name[16];         /* 22 OEM name */
+  ushort  dvc_err_code;         /* 30 last device driver error code */
+  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
+  ushort  adv_err_addr;         /* 32 last uc error address */
+  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
+  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
+  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */
+  ushort  reserved36;           /* 36 reserved */
+  ushort  reserved37;           /* 37 reserved */
+  ushort  reserved38;           /* 38 reserved */
+  ushort  reserved39;           /* 39 reserved */
+  ushort  reserved40;           /* 40 reserved */
+  ushort  reserved41;           /* 41 reserved */
+  ushort  reserved42;           /* 42 reserved */
+  ushort  reserved43;           /* 43 reserved */
+  ushort  reserved44;           /* 44 reserved */
+  ushort  reserved45;           /* 45 reserved */
+  ushort  reserved46;           /* 46 reserved */
+  ushort  reserved47;           /* 47 reserved */
+  ushort  reserved48;           /* 48 reserved */
+  ushort  reserved49;           /* 49 reserved */
+  ushort  reserved50;           /* 50 reserved */
+  ushort  reserved51;           /* 51 reserved */
+  ushort  reserved52;           /* 52 reserved */
+  ushort  reserved53;           /* 53 reserved */
+  ushort  reserved54;           /* 54 reserved */
+  ushort  reserved55;           /* 55 reserved */
+  ushort  cisptr_lsw;           /* 56 CIS PTR LSW */
+  ushort  cisprt_msw;           /* 57 CIS PTR MSW */
+  ushort  subsysvid;            /* 58 SubSystem Vendor ID */
+  ushort  subsysid;             /* 59 SubSystem ID */
+  ushort  reserved60;           /* 60 reserved */
+  ushort  reserved61;           /* 61 reserved */
+  ushort  reserved62;           /* 62 reserved */
+  ushort  reserved63;           /* 63 reserved */
+} ADVEEP_38C1600_CONFIG;
+
+/*
+ * EEPROM Commands
+ */
+#define ASC_EEP_CMD_DONE             0x0200
+#define ASC_EEP_CMD_DONE_ERR         0x0001
+
+/* cfg_word */
+#define EEP_CFG_WORD_BIG_ENDIAN      0x8000
+
+/* bios_ctrl */
+#define BIOS_CTRL_BIOS               0x0001
+#define BIOS_CTRL_EXTENDED_XLAT      0x0002
+#define BIOS_CTRL_GT_2_DISK          0x0004
+#define BIOS_CTRL_BIOS_REMOVABLE     0x0008
+#define BIOS_CTRL_BOOTABLE_CD        0x0010
+#define BIOS_CTRL_MULTIPLE_LUN       0x0040
+#define BIOS_CTRL_DISPLAY_MSG        0x0080
+#define BIOS_CTRL_NO_SCAM            0x0100
+#define BIOS_CTRL_RESET_SCSI_BUS     0x0200
+#define BIOS_CTRL_INIT_VERBOSE       0x0800
+#define BIOS_CTRL_SCSI_PARITY        0x1000
+#define BIOS_CTRL_AIPP_DIS           0x2000
+
+#define ADV_3550_MEMSIZE   0x2000       /* 8 KB Internal Memory */
+#define ADV_3550_IOLEN     0x40         /* I/O Port Range in bytes */
+
+#define ADV_38C0800_MEMSIZE  0x4000     /* 16 KB Internal Memory */
+#define ADV_38C0800_IOLEN    0x100      /* I/O Port Range in bytes */
+
+/*
+ * XXX - Since ASC38C1600 Rev.3 has a local RAM failure issue, there is
+ * a special 16K Adv Library and Microcode version. After the issue is
+ * resolved, should restore 32K support.
+ *
+ * #define ADV_38C1600_MEMSIZE  0x8000L   * 32 KB Internal Memory *
+ */
+#define ADV_38C1600_MEMSIZE  0x4000   /* 16 KB Internal Memory */
+#define ADV_38C1600_IOLEN    0x100     /* I/O Port Range 256 bytes */
+#define ADV_38C1600_MEMLEN   0x1000    /* Memory Range 4KB bytes */
+
+/*
+ * Byte I/O register address from base of 'iop_base'.
+ */
+#define IOPB_INTR_STATUS_REG    0x00
+#define IOPB_CHIP_ID_1          0x01
+#define IOPB_INTR_ENABLES       0x02
+#define IOPB_CHIP_TYPE_REV      0x03
+#define IOPB_RES_ADDR_4         0x04
+#define IOPB_RES_ADDR_5         0x05
+#define IOPB_RAM_DATA           0x06
+#define IOPB_RES_ADDR_7         0x07
+#define IOPB_FLAG_REG           0x08
+#define IOPB_RES_ADDR_9         0x09
+#define IOPB_RISC_CSR           0x0A
+#define IOPB_RES_ADDR_B         0x0B
+#define IOPB_RES_ADDR_C         0x0C
+#define IOPB_RES_ADDR_D         0x0D
+#define IOPB_SOFT_OVER_WR       0x0E
+#define IOPB_RES_ADDR_F         0x0F
+#define IOPB_MEM_CFG            0x10
+#define IOPB_RES_ADDR_11        0x11
+#define IOPB_GPIO_DATA          0x12
+#define IOPB_RES_ADDR_13        0x13
+#define IOPB_FLASH_PAGE         0x14
+#define IOPB_RES_ADDR_15        0x15
+#define IOPB_GPIO_CNTL          0x16
+#define IOPB_RES_ADDR_17        0x17
+#define IOPB_FLASH_DATA         0x18
+#define IOPB_RES_ADDR_19        0x19
+#define IOPB_RES_ADDR_1A        0x1A
+#define IOPB_RES_ADDR_1B        0x1B
+#define IOPB_RES_ADDR_1C        0x1C
+#define IOPB_RES_ADDR_1D        0x1D
+#define IOPB_RES_ADDR_1E        0x1E
+#define IOPB_RES_ADDR_1F        0x1F
+#define IOPB_DMA_CFG0           0x20
+#define IOPB_DMA_CFG1           0x21
+#define IOPB_TICKLE             0x22
+#define IOPB_DMA_REG_WR         0x23
+#define IOPB_SDMA_STATUS        0x24
+#define IOPB_SCSI_BYTE_CNT      0x25
+#define IOPB_HOST_BYTE_CNT      0x26
+#define IOPB_BYTE_LEFT_TO_XFER  0x27
+#define IOPB_BYTE_TO_XFER_0     0x28
+#define IOPB_BYTE_TO_XFER_1     0x29
+#define IOPB_BYTE_TO_XFER_2     0x2A
+#define IOPB_BYTE_TO_XFER_3     0x2B
+#define IOPB_ACC_GRP            0x2C
+#define IOPB_RES_ADDR_2D        0x2D
+#define IOPB_DEV_ID             0x2E
+#define IOPB_RES_ADDR_2F        0x2F
+#define IOPB_SCSI_DATA          0x30
+#define IOPB_RES_ADDR_31        0x31
+#define IOPB_RES_ADDR_32        0x32
+#define IOPB_SCSI_DATA_HSHK     0x33
+#define IOPB_SCSI_CTRL          0x34
+#define IOPB_RES_ADDR_35        0x35
+#define IOPB_RES_ADDR_36        0x36
+#define IOPB_RES_ADDR_37        0x37
+#define IOPB_RAM_BIST           0x38
+#define IOPB_PLL_TEST           0x39
+#define IOPB_PCI_INT_CFG        0x3A
+#define IOPB_RES_ADDR_3B        0x3B
+#define IOPB_RFIFO_CNT          0x3C
+#define IOPB_RES_ADDR_3D        0x3D
+#define IOPB_RES_ADDR_3E        0x3E
+#define IOPB_RES_ADDR_3F        0x3F
+
+/*
+ * Word I/O register address from base of 'iop_base'.
+ */
+#define IOPW_CHIP_ID_0          0x00  /* CID0  */
+#define IOPW_CTRL_REG           0x02  /* CC    */
+#define IOPW_RAM_ADDR           0x04  /* LA    */
+#define IOPW_RAM_DATA           0x06  /* LD    */
+#define IOPW_RES_ADDR_08        0x08
+#define IOPW_RISC_CSR           0x0A  /* CSR   */
+#define IOPW_SCSI_CFG0          0x0C  /* CFG0  */
+#define IOPW_SCSI_CFG1          0x0E  /* CFG1  */
+#define IOPW_RES_ADDR_10        0x10
+#define IOPW_SEL_MASK           0x12  /* SM    */
+#define IOPW_RES_ADDR_14        0x14
+#define IOPW_FLASH_ADDR         0x16  /* FA    */
+#define IOPW_RES_ADDR_18        0x18
+#define IOPW_EE_CMD             0x1A  /* EC    */
+#define IOPW_EE_DATA            0x1C  /* ED    */
+#define IOPW_SFIFO_CNT          0x1E  /* SFC   */
+#define IOPW_RES_ADDR_20        0x20
+#define IOPW_Q_BASE             0x22  /* QB    */
+#define IOPW_QP                 0x24  /* QP    */
+#define IOPW_IX                 0x26  /* IX    */
+#define IOPW_SP                 0x28  /* SP    */
+#define IOPW_PC                 0x2A  /* PC    */
+#define IOPW_RES_ADDR_2C        0x2C
+#define IOPW_RES_ADDR_2E        0x2E
+#define IOPW_SCSI_DATA          0x30  /* SD    */
+#define IOPW_SCSI_DATA_HSHK     0x32  /* SDH   */
+#define IOPW_SCSI_CTRL          0x34  /* SC    */
+#define IOPW_HSHK_CFG           0x36  /* HCFG  */
+#define IOPW_SXFR_STATUS        0x36  /* SXS   */
+#define IOPW_SXFR_CNTL          0x38  /* SXL   */
+#define IOPW_SXFR_CNTH          0x3A  /* SXH   */
+#define IOPW_RES_ADDR_3C        0x3C
+#define IOPW_RFIFO_DATA         0x3E  /* RFD   */
+
+/*
+ * Doubleword I/O register address from base of 'iop_base'.
+ */
+#define IOPDW_RES_ADDR_0         0x00
+#define IOPDW_RAM_DATA           0x04
+#define IOPDW_RES_ADDR_8         0x08
+#define IOPDW_RES_ADDR_C         0x0C
+#define IOPDW_RES_ADDR_10        0x10
+#define IOPDW_COMMA              0x14
+#define IOPDW_COMMB              0x18
+#define IOPDW_RES_ADDR_1C        0x1C
+#define IOPDW_SDMA_ADDR0         0x20
+#define IOPDW_SDMA_ADDR1         0x24
+#define IOPDW_SDMA_COUNT         0x28
+#define IOPDW_SDMA_ERROR         0x2C
+#define IOPDW_RDMA_ADDR0         0x30
+#define IOPDW_RDMA_ADDR1         0x34
+#define IOPDW_RDMA_COUNT         0x38
+#define IOPDW_RDMA_ERROR         0x3C
+
+#define ADV_CHIP_ID_BYTE         0x25
+#define ADV_CHIP_ID_WORD         0x04C1
+
+#define ADV_SC_SCSI_BUS_RESET    0x2000
+
+#define ADV_INTR_ENABLE_HOST_INTR                   0x01
+#define ADV_INTR_ENABLE_SEL_INTR                    0x02
+#define ADV_INTR_ENABLE_DPR_INTR                    0x04
+#define ADV_INTR_ENABLE_RTA_INTR                    0x08
+#define ADV_INTR_ENABLE_RMA_INTR                    0x10
+#define ADV_INTR_ENABLE_RST_INTR                    0x20
+#define ADV_INTR_ENABLE_DPE_INTR                    0x40
+#define ADV_INTR_ENABLE_GLOBAL_INTR                 0x80
+
+#define ADV_INTR_STATUS_INTRA            0x01
+#define ADV_INTR_STATUS_INTRB            0x02
+#define ADV_INTR_STATUS_INTRC            0x04
+
+#define ADV_RISC_CSR_STOP           (0x0000)
+#define ADV_RISC_TEST_COND          (0x2000)
+#define ADV_RISC_CSR_RUN            (0x4000)
+#define ADV_RISC_CSR_SINGLE_STEP    (0x8000)
+
+#define ADV_CTRL_REG_HOST_INTR      0x0100
+#define ADV_CTRL_REG_SEL_INTR       0x0200
+#define ADV_CTRL_REG_DPR_INTR       0x0400
+#define ADV_CTRL_REG_RTA_INTR       0x0800
+#define ADV_CTRL_REG_RMA_INTR       0x1000
+#define ADV_CTRL_REG_RES_BIT14      0x2000
+#define ADV_CTRL_REG_DPE_INTR       0x4000
+#define ADV_CTRL_REG_POWER_DONE     0x8000
+#define ADV_CTRL_REG_ANY_INTR       0xFF00
+
+#define ADV_CTRL_REG_CMD_RESET             0x00C6
+#define ADV_CTRL_REG_CMD_WR_IO_REG         0x00C5
+#define ADV_CTRL_REG_CMD_RD_IO_REG         0x00C4
+#define ADV_CTRL_REG_CMD_WR_PCI_CFG_SPACE  0x00C3
+#define ADV_CTRL_REG_CMD_RD_PCI_CFG_SPACE  0x00C2
+
+#define ADV_TICKLE_NOP                      0x00
+#define ADV_TICKLE_A                        0x01
+#define ADV_TICKLE_B                        0x02
+#define ADV_TICKLE_C                        0x03
+
+#define ADV_SCSI_CTRL_RSTOUT        0x2000
+
+#define AdvIsIntPending(port) \
+    (AdvReadWordRegister(port, IOPW_CTRL_REG) & ADV_CTRL_REG_HOST_INTR)
+
+/*
+ * SCSI_CFG0 Register bit definitions
+ */
+#define TIMER_MODEAB    0xC000  /* Watchdog, Second, and Select. Timer Ctrl. */
+#define PARITY_EN       0x2000  /* Enable SCSI Parity Error detection */
+#define EVEN_PARITY     0x1000  /* Select Even Parity */
+#define WD_LONG         0x0800  /* Watchdog Interval, 1: 57 min, 0: 13 sec */
+#define QUEUE_128       0x0400  /* Queue Size, 1: 128 byte, 0: 64 byte */
+#define PRIM_MODE       0x0100  /* Primitive SCSI mode */
+#define SCAM_EN         0x0080  /* Enable SCAM selection */
+#define SEL_TMO_LONG    0x0040  /* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */
+#define CFRM_ID         0x0020  /* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */
+#define OUR_ID_EN       0x0010  /* Enable OUR_ID bits */
+#define OUR_ID          0x000F  /* SCSI ID */
+
+/*
+ * SCSI_CFG1 Register bit definitions
+ */
+#define BIG_ENDIAN      0x8000  /* Enable Big Endian Mode MIO:15, EEP:15 */
+#define TERM_POL        0x2000  /* Terminator Polarity Ctrl. MIO:13, EEP:13 */
+#define SLEW_RATE       0x1000  /* SCSI output buffer slew rate */
+#define FILTER_SEL      0x0C00  /* Filter Period Selection */
+#define  FLTR_DISABLE    0x0000  /* Input Filtering Disabled */
+#define  FLTR_11_TO_20NS 0x0800  /* Input Filtering 11ns to 20ns */
+#define  FLTR_21_TO_39NS 0x0C00  /* Input Filtering 21ns to 39ns */
+#define ACTIVE_DBL      0x0200  /* Disable Active Negation */
+#define DIFF_MODE       0x0100  /* SCSI differential Mode (Read-Only) */
+#define DIFF_SENSE      0x0080  /* 1: No SE cables, 0: SE cable (Read-Only) */
+#define TERM_CTL_SEL    0x0040  /* Enable TERM_CTL_H and TERM_CTL_L */
+#define TERM_CTL        0x0030  /* External SCSI Termination Bits */
+#define  TERM_CTL_H      0x0020  /* Enable External SCSI Upper Termination */
+#define  TERM_CTL_L      0x0010  /* Enable External SCSI Lower Termination */
+#define CABLE_DETECT    0x000F  /* External SCSI Cable Connection Status */
+
+/*
+ * Addendum for ASC-38C0800 Chip
+ *
+ * The ASC-38C1600 Chip uses the same definitions except that the
+ * bus mode override bits [12:10] have been moved to byte register
+ * offset 0xE (IOPB_SOFT_OVER_WR) bits [12:10]. The [12:10] bits in
+ * SCSI_CFG1 are read-only and always available. Bit 14 (DIS_TERM_DRV)
+ * is not needed. The [12:10] bits in IOPB_SOFT_OVER_WR are write-only.
+ * Also each ASC-38C1600 function or channel uses only cable bits [5:4]
+ * and [1:0]. Bits [14], [7:6], [3:2] are unused.
+ */
+#define DIS_TERM_DRV    0x4000  /* 1: Read c_det[3:0], 0: cannot read */
+#define HVD_LVD_SE      0x1C00  /* Device Detect Bits */
+#define  HVD             0x1000  /* HVD Device Detect */
+#define  LVD             0x0800  /* LVD Device Detect */
+#define  SE              0x0400  /* SE Device Detect */
+#define TERM_LVD        0x00C0  /* LVD Termination Bits */
+#define  TERM_LVD_HI     0x0080  /* Enable LVD Upper Termination */
+#define  TERM_LVD_LO     0x0040  /* Enable LVD Lower Termination */
+#define TERM_SE         0x0030  /* SE Termination Bits */
+#define  TERM_SE_HI      0x0020  /* Enable SE Upper Termination */
+#define  TERM_SE_LO      0x0010  /* Enable SE Lower Termination */
+#define C_DET_LVD       0x000C  /* LVD Cable Detect Bits */
+#define  C_DET3          0x0008  /* Cable Detect for LVD External Wide */
+#define  C_DET2          0x0004  /* Cable Detect for LVD Internal Wide */
+#define C_DET_SE        0x0003  /* SE Cable Detect Bits */
+#define  C_DET1          0x0002  /* Cable Detect for SE Internal Wide */
+#define  C_DET0          0x0001  /* Cable Detect for SE Internal Narrow */
+
+
+#define CABLE_ILLEGAL_A 0x7
+    /* x 0 0 0  | on  on | Illegal (all 3 connectors are used) */
+
+#define CABLE_ILLEGAL_B 0xB
+    /* 0 x 0 0  | on  on | Illegal (all 3 connectors are used) */
+
+/*
+ * MEM_CFG Register bit definitions
+ */
+#define BIOS_EN         0x40    /* BIOS Enable MIO:14,EEP:14 */
+#define FAST_EE_CLK     0x20    /* Diagnostic Bit */
+#define RAM_SZ          0x1C    /* Specify size of RAM to RISC */
+#define  RAM_SZ_2KB      0x00    /* 2 KB */
+#define  RAM_SZ_4KB      0x04    /* 4 KB */
+#define  RAM_SZ_8KB      0x08    /* 8 KB */
+#define  RAM_SZ_16KB     0x0C    /* 16 KB */
+#define  RAM_SZ_32KB     0x10    /* 32 KB */
+#define  RAM_SZ_64KB     0x14    /* 64 KB */
+
+/*
+ * DMA_CFG0 Register bit definitions
+ *
+ * This register is only accessible to the host.
+ */
+#define BC_THRESH_ENB   0x80    /* PCI DMA Start Conditions */
+#define FIFO_THRESH     0x70    /* PCI DMA FIFO Threshold */
+#define  FIFO_THRESH_16B  0x00   /* 16 bytes */
+#define  FIFO_THRESH_32B  0x20   /* 32 bytes */
+#define  FIFO_THRESH_48B  0x30   /* 48 bytes */
+#define  FIFO_THRESH_64B  0x40   /* 64 bytes */
+#define  FIFO_THRESH_80B  0x50   /* 80 bytes (default) */
+#define  FIFO_THRESH_96B  0x60   /* 96 bytes */
+#define  FIFO_THRESH_112B 0x70   /* 112 bytes */
+#define START_CTL       0x0C    /* DMA start conditions */
+#define  START_CTL_TH    0x00    /* Wait threshold level (default) */
+#define  START_CTL_ID    0x04    /* Wait SDMA/SBUS idle */
+#define  START_CTL_THID  0x08    /* Wait threshold and SDMA/SBUS idle */
+#define  START_CTL_EMFU  0x0C    /* Wait SDMA FIFO empty/full */
+#define READ_CMD        0x03    /* Memory Read Method */
+#define  READ_CMD_MR     0x00    /* Memory Read */
+#define  READ_CMD_MRL    0x02    /* Memory Read Long */
+#define  READ_CMD_MRM    0x03    /* Memory Read Multiple (default) */
+
+/*
+ * ASC-38C0800 RAM BIST Register bit definitions
+ */
+#define RAM_TEST_MODE         0x80
+#define PRE_TEST_MODE         0x40
+#define NORMAL_MODE           0x00
+#define RAM_TEST_DONE         0x10
+#define RAM_TEST_STATUS       0x0F
+#define  RAM_TEST_HOST_ERROR   0x08
+#define  RAM_TEST_INTRAM_ERROR 0x04
+#define  RAM_TEST_RISC_ERROR   0x02
+#define  RAM_TEST_SCSI_ERROR   0x01
+#define  RAM_TEST_SUCCESS      0x00
+#define PRE_TEST_VALUE        0x05
+#define NORMAL_VALUE          0x00
+
+/*
+ * ASC38C1600 Definitions
+ *
+ * IOPB_PCI_INT_CFG Bit Field Definitions
+ */
+
+#define INTAB_LD        0x80    /* Value loaded from EEPROM Bit 11. */
+
+/*
+ * Bit 1 can be set to change the interrupt for the Function to operate in
+ * Totem Pole mode. By default Bit 1 is 0 and the interrupt operates in
+ * Open Drain mode. Both functions of the ASC38C1600 must be set to the same
+ * mode, otherwise the operating mode is undefined.
+ */
+#define TOTEMPOLE       0x02
+
+/*
+ * Bit 0 can be used to change the Int Pin for the Function. The value is
+ * 0 by default for both Functions with Function 0 using INT A and Function
+ * B using INT B. For Function 0 if set, INT B is used. For Function 1 if set,
+ * INT A is used.
+ *
+ * EEPROM Word 0 Bit 11 for each Function may change the initial Int Pin
+ * value specified in the PCI Configuration Space.
+ */
+#define INTAB           0x01
+
+/* a_advlib.h */
+
+/*
+ * Adv Library Status Definitions
+ */
+#define ADV_TRUE        1
+#define ADV_FALSE       0
+#define ADV_NOERROR     1
+#define ADV_SUCCESS     1
+#define ADV_BUSY        0
+#define ADV_ERROR       (-1)
+
+
+/*
+ * ADV_DVC_VAR 'warn_code' values
+ */
+#define ASC_WARN_BUSRESET_ERROR         0x0001 /* SCSI Bus Reset error */
+#define ASC_WARN_EEPROM_CHKSUM          0x0002 /* EEP check sum error */
+#define ASC_WARN_EEPROM_TERMINATION     0x0004 /* EEP termination bad field */
+#define ASC_WARN_SET_PCI_CONFIG_SPACE   0x0080 /* PCI config space set error */
+#define ASC_WARN_ERROR                  0xFFFF /* ADV_ERROR return */
+
+#define ADV_MAX_TID                     15 /* max. target identifier */
+#define ADV_MAX_LUN                     7  /* max. logical unit number */
+
+/*
+ * Error code values are set in ADV_DVC_VAR 'err_code'.
+ */
+#define ASC_IERR_WRITE_EEPROM       0x0001 /* write EEPROM error */
+#define ASC_IERR_MCODE_CHKSUM       0x0002 /* micro code check sum error */
+#define ASC_IERR_NO_CARRIER         0x0004 /* No more carrier memory. */
+#define ASC_IERR_START_STOP_CHIP    0x0008 /* start/stop chip failed */
+#define ASC_IERR_CHIP_VERSION       0x0040 /* wrong chip version */
+#define ASC_IERR_SET_SCSI_ID        0x0080 /* set SCSI ID failed */
+#define ASC_IERR_HVD_DEVICE         0x0100 /* HVD attached to LVD connector. */
+#define ASC_IERR_BAD_SIGNATURE      0x0200 /* signature not found */
+#define ASC_IERR_ILLEGAL_CONNECTION 0x0400 /* Illegal cable connection */
+#define ASC_IERR_SINGLE_END_DEVICE  0x0800 /* Single-end used w/differential */
+#define ASC_IERR_REVERSED_CABLE     0x1000 /* Narrow flat cable reversed */
+#define ASC_IERR_BIST_PRE_TEST      0x2000 /* BIST pre-test error */
+#define ASC_IERR_BIST_RAM_TEST      0x4000 /* BIST RAM test error */
+#define ASC_IERR_BAD_CHIPTYPE       0x8000 /* Invalid 'chip_type' setting. */
+
+/*
+ * Fixed locations of microcode operating variables.
+ */
+#define ASC_MC_CODE_BEGIN_ADDR          0x0028 /* microcode start address */
+#define ASC_MC_CODE_END_ADDR            0x002A /* microcode end address */
+#define ASC_MC_CODE_CHK_SUM             0x002C /* microcode code checksum */
+#define ASC_MC_VERSION_DATE             0x0038 /* microcode version */
+#define ASC_MC_VERSION_NUM              0x003A /* microcode number */
+#define ASC_MC_BIOSMEM                  0x0040 /* BIOS RISC Memory Start */
+#define ASC_MC_BIOSLEN                  0x0050 /* BIOS RISC Memory Length */
+#define ASC_MC_BIOS_SIGNATURE           0x0058 /* BIOS Signature 0x55AA */
+#define ASC_MC_BIOS_VERSION             0x005A /* BIOS Version (2 bytes) */
+#define ASC_MC_SDTR_SPEED1              0x0090 /* SDTR Speed for TID 0-3 */
+#define ASC_MC_SDTR_SPEED2              0x0092 /* SDTR Speed for TID 4-7 */
+#define ASC_MC_SDTR_SPEED3              0x0094 /* SDTR Speed for TID 8-11 */
+#define ASC_MC_SDTR_SPEED4              0x0096 /* SDTR Speed for TID 12-15 */
+#define ASC_MC_CHIP_TYPE                0x009A
+#define ASC_MC_INTRB_CODE               0x009B
+#define ASC_MC_WDTR_ABLE                0x009C
+#define ASC_MC_SDTR_ABLE                0x009E
+#define ASC_MC_TAGQNG_ABLE              0x00A0
+#define ASC_MC_DISC_ENABLE              0x00A2
+#define ASC_MC_IDLE_CMD_STATUS          0x00A4
+#define ASC_MC_IDLE_CMD                 0x00A6
+#define ASC_MC_IDLE_CMD_PARAMETER       0x00A8
+#define ASC_MC_DEFAULT_SCSI_CFG0        0x00AC
+#define ASC_MC_DEFAULT_SCSI_CFG1        0x00AE
+#define ASC_MC_DEFAULT_MEM_CFG          0x00B0
+#define ASC_MC_DEFAULT_SEL_MASK         0x00B2
+#define ASC_MC_SDTR_DONE                0x00B6
+#define ASC_MC_NUMBER_OF_QUEUED_CMD     0x00C0
+#define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0
+#define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100
+#define ASC_MC_CONTROL_FLAG             0x0122 /* Microcode control flag. */
+#define ASC_MC_WDTR_DONE                0x0124
+#define ASC_MC_CAM_MODE_MASK            0x015E /* CAM mode TID bitmask. */
+#define ASC_MC_ICQ                      0x0160
+#define ASC_MC_IRQ                      0x0164
+#define ASC_MC_PPR_ABLE                 0x017A
+
+/*
+ * BIOS LRAM variable absolute offsets.
+ */
+#define BIOS_CODESEG    0x54
+#define BIOS_CODELEN    0x56
+#define BIOS_SIGNATURE  0x58
+#define BIOS_VERSION    0x5A
+
+/*
+ * Microcode Control Flags
+ *
+ * Flags set by the Adv Library in RISC variable 'control_flag' (0x122)
+ * and handled by the microcode.
+ */
+#define CONTROL_FLAG_IGNORE_PERR        0x0001 /* Ignore DMA Parity Errors */
+#define CONTROL_FLAG_ENABLE_AIPP        0x0002 /* Enabled AIPP checking. */
+
+/*
+ * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format
+ */
+#define HSHK_CFG_WIDE_XFR       0x8000
+#define HSHK_CFG_RATE           0x0F00
+#define HSHK_CFG_OFFSET         0x001F
+
+#define ASC_DEF_MAX_HOST_QNG    0xFD /* Max. number of host commands (253) */
+#define ASC_DEF_MIN_HOST_QNG    0x10 /* Min. number of host commands (16) */
+#define ASC_DEF_MAX_DVC_QNG     0x3F /* Max. number commands per device (63) */
+#define ASC_DEF_MIN_DVC_QNG     0x04 /* Min. number commands per device (4) */
+
+#define ASC_QC_DATA_CHECK  0x01 /* Require ASC_QC_DATA_OUT set or clear. */
+#define ASC_QC_DATA_OUT    0x02 /* Data out DMA transfer. */
+#define ASC_QC_START_MOTOR 0x04 /* Send auto-start motor before request. */
+#define ASC_QC_NO_OVERRUN  0x08 /* Don't report overrun. */
+#define ASC_QC_FREEZE_TIDQ 0x10 /* Freeze TID queue after request. XXX TBD */
+
+#define ASC_QSC_NO_DISC     0x01 /* Don't allow disconnect for request. */
+#define ASC_QSC_NO_TAGMSG   0x02 /* Don't allow tag queuing for request. */
+#define ASC_QSC_NO_SYNC     0x04 /* Don't use Synch. transfer on request. */
+#define ASC_QSC_NO_WIDE     0x08 /* Don't use Wide transfer on request. */
+#define ASC_QSC_REDO_DTR    0x10 /* Renegotiate WDTR/SDTR before request. */
+/*
+ * Note: If a Tag Message is to be sent and neither ASC_QSC_HEAD_TAG or
+ * ASC_QSC_ORDERED_TAG is set, then a Simple Tag Message (0x20) is used.
+ */
+#define ASC_QSC_HEAD_TAG    0x40 /* Use Head Tag Message (0x21). */
+#define ASC_QSC_ORDERED_TAG 0x80 /* Use Ordered Tag Message (0x22). */
+
+/*
+ * All fields here are accessed by the board microcode and need to be
+ * little-endian.
+ */
+typedef struct adv_carr_t
+{
+    ADV_VADDR   carr_va;       /* Carrier Virtual Address */
+    ADV_PADDR   carr_pa;       /* Carrier Physical Address */
+    ADV_VADDR   areq_vpa;      /* ASC_SCSI_REQ_Q Virtual or Physical Address */
+    /*
+     * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer
+     *
+     * next_vpa [3:1]             Reserved Bits
+     * next_vpa [0]               Done Flag set in Response Queue.
+     */
+    ADV_VADDR   next_vpa;
+} ADV_CARR_T;
+
+/*
+ * Mask used to eliminate low 4 bits of carrier 'next_vpa' field.
+ */
+#define ASC_NEXT_VPA_MASK       0xFFFFFFF0
+
+#define ASC_RQ_DONE             0x00000001
+#define ASC_RQ_GOOD             0x00000002
+#define ASC_CQ_STOPPER          0x00000000
+
+#define ASC_GET_CARRP(carrp) ((carrp) & ASC_NEXT_VPA_MASK)
+
+#define ADV_CARRIER_NUM_PAGE_CROSSING \
+    (((ADV_CARRIER_COUNT * sizeof(ADV_CARR_T)) + \
+        (ADV_PAGE_SIZE - 1))/ADV_PAGE_SIZE)
+
+#define ADV_CARRIER_BUFSIZE \
+    ((ADV_CARRIER_COUNT + ADV_CARRIER_NUM_PAGE_CROSSING) * sizeof(ADV_CARR_T))
+
+/*
+ * ASC_SCSI_REQ_Q 'a_flag' definitions
+ *
+ * The Adv Library should limit use to the lower nibble (4 bits) of
+ * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.
+ */
+#define ADV_POLL_REQUEST                0x01   /* poll for request completion */
+#define ADV_SCSIQ_DONE                  0x02   /* request done */
+#define ADV_DONT_RETRY                  0x08   /* don't do retry */
+
+#define ADV_CHIP_ASC3550          0x01   /* Ultra-Wide IC */
+#define ADV_CHIP_ASC38C0800       0x02   /* Ultra2-Wide/LVD IC */
+#define ADV_CHIP_ASC38C1600       0x03   /* Ultra3-Wide/LVD2 IC */
+
+/*
+ * Adapter temporary configuration structure
+ *
+ * This structure can be discarded after initialization. Don't add
+ * fields here needed after initialization.
+ *
+ * Field naming convention:
+ *
+ *  *_enable indicates the field enables or disables a feature. The
+ *  value of the field is never reset.
+ */
+typedef struct adv_dvc_cfg {
+  ushort disc_enable;       /* enable disconnection */
+  uchar  chip_version;      /* chip version */
+  uchar  termination;       /* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */
+  ushort lib_version;       /* Adv Library version number */
+  ushort control_flag;      /* Microcode Control Flag */
+  ushort mcode_date;        /* Microcode date */
+  ushort mcode_version;     /* Microcode version */
+  ushort pci_slot_info;     /* high byte device/function number */
+                            /* bits 7-3 device num., bits 2-0 function num. */
+                            /* low byte bus num. */
+  ushort serial1;           /* EEPROM serial number word 1 */
+  ushort serial2;           /* EEPROM serial number word 2 */
+  ushort serial3;           /* EEPROM serial number word 3 */
+  struct device *dev;  /* pointer to the pci dev structure for this board */
+} ADV_DVC_CFG;
+
+struct adv_dvc_var;
+struct adv_scsi_req_q;
+
+typedef void (* ADV_ISR_CALLBACK)
+    (struct adv_dvc_var *, struct adv_scsi_req_q *);
+
+typedef void (* ADV_ASYNC_CALLBACK)
+    (struct adv_dvc_var *, uchar);
+
+/*
+ * Adapter operation variable structure.
+ *
+ * One structure is required per host adapter.
+ *
+ * Field naming convention:
+ *
+ *  *_able indicates both whether a feature should be enabled or disabled
+ *  and whether a device isi capable of the feature. At initialization
+ *  this field may be set, but later if a device is found to be incapable
+ *  of the feature, the field is cleared.
+ */
+typedef struct adv_dvc_var {
+  AdvPortAddr iop_base;   /* I/O port address */
+  ushort err_code;        /* fatal error code */
+  ushort bios_ctrl;       /* BIOS control word, EEPROM word 12 */
+  ADV_ISR_CALLBACK isr_callback;
+  ADV_ASYNC_CALLBACK async_callback;
+  ushort wdtr_able;       /* try WDTR for a device */
+  ushort sdtr_able;       /* try SDTR for a device */
+  ushort ultra_able;      /* try SDTR Ultra speed for a device */
+  ushort sdtr_speed1;     /* EEPROM SDTR Speed for TID 0-3   */
+  ushort sdtr_speed2;     /* EEPROM SDTR Speed for TID 4-7   */
+  ushort sdtr_speed3;     /* EEPROM SDTR Speed for TID 8-11  */
+  ushort sdtr_speed4;     /* EEPROM SDTR Speed for TID 12-15 */
+  ushort tagqng_able;     /* try tagged queuing with a device */
+  ushort ppr_able;        /* PPR message capable per TID bitmask. */
+  uchar  max_dvc_qng;     /* maximum number of tagged commands per device */
+  ushort start_motor;     /* start motor command allowed */
+  uchar  scsi_reset_wait; /* delay in seconds after scsi bus reset */
+  uchar  chip_no;         /* should be assigned by caller */
+  uchar  max_host_qng;    /* maximum number of Q'ed command allowed */
+  uchar  irq_no;          /* IRQ number */
+  ushort no_scam;         /* scam_tolerant of EEPROM */
+  struct asc_board *drv_ptr; /* driver pointer to private structure */
+  uchar  chip_scsi_id;    /* chip SCSI target ID */
+  uchar  chip_type;
+  uchar  bist_err_code;
+  ADV_CARR_T *carrier_buf;
+  ADV_CARR_T *carr_freelist; /* Carrier free list. */
+  ADV_CARR_T *icq_sp;  /* Initiator command queue stopper pointer. */
+  ADV_CARR_T *irq_sp;  /* Initiator response queue stopper pointer. */
+  ushort carr_pending_cnt;    /* Count of pending carriers. */
+ /*
+  * Note: The following fields will not be used after initialization. The
+  * driver may discard the buffer after initialization is done.
+  */
+  ADV_DVC_CFG *cfg; /* temporary configuration structure  */
+} ADV_DVC_VAR;
+
+#define NO_OF_SG_PER_BLOCK              15
+
+typedef struct asc_sg_block {
+    uchar reserved1;
+    uchar reserved2;
+    uchar reserved3;
+    uchar sg_cnt;                     /* Valid entries in block. */
+    ADV_PADDR sg_ptr;                 /* Pointer to next sg block. */
+    struct  {
+        ADV_PADDR sg_addr;                  /* SG element address. */
+        ADV_DCNT  sg_count;                 /* SG element count. */
+    } sg_list[NO_OF_SG_PER_BLOCK];
+} ADV_SG_BLOCK;
+
+/*
+ * ADV_SCSI_REQ_Q - microcode request structure
+ *
+ * All fields in this structure up to byte 60 are used by the microcode.
+ * The microcode makes assumptions about the size and ordering of fields
+ * in this structure. Do not change the structure definition here without
+ * coordinating the change with the microcode.
+ *
+ * All fields accessed by microcode must be maintained in little_endian
+ * order.
+ */
+typedef struct adv_scsi_req_q {
+    uchar       cntl;           /* Ucode flags and state (ASC_MC_QC_*). */
+    uchar       target_cmd;
+    uchar       target_id;      /* Device target identifier. */
+    uchar       target_lun;     /* Device target logical unit number. */
+    ADV_PADDR   data_addr;      /* Data buffer physical address. */
+    ADV_DCNT    data_cnt;       /* Data count. Ucode sets to residual. */
+    ADV_PADDR   sense_addr;
+    ADV_PADDR   carr_pa;
+    uchar       mflag;
+    uchar       sense_len;
+    uchar       cdb_len;        /* SCSI CDB length. Must <= 16 bytes. */
+    uchar       scsi_cntl;
+    uchar       done_status;    /* Completion status. */
+    uchar       scsi_status;    /* SCSI status byte. */
+    uchar       host_status;    /* Ucode host status. */
+    uchar       sg_working_ix;
+    uchar       cdb[12];        /* SCSI CDB bytes 0-11. */
+    ADV_PADDR   sg_real_addr;   /* SG list physical address. */
+    ADV_PADDR   scsiq_rptr;
+    uchar       cdb16[4];       /* SCSI CDB bytes 12-15. */
+    ADV_VADDR   scsiq_ptr;
+    ADV_VADDR   carr_va;
+    /*
+     * End of microcode structure - 60 bytes. The rest of the structure
+     * is used by the Adv Library and ignored by the microcode.
+     */
+    ADV_VADDR   srb_ptr;
+    ADV_SG_BLOCK *sg_list_ptr; /* SG list virtual address. */
+    char        *vdata_addr;   /* Data buffer virtual address. */
+    uchar       a_flag;
+    uchar       pad[2];        /* Pad out to a word boundary. */
+} ADV_SCSI_REQ_Q;
+
+/*
+ * Microcode idle loop commands
+ */
+#define IDLE_CMD_COMPLETED           0
+#define IDLE_CMD_STOP_CHIP           0x0001
+#define IDLE_CMD_STOP_CHIP_SEND_INT  0x0002
+#define IDLE_CMD_SEND_INT            0x0004
+#define IDLE_CMD_ABORT               0x0008
+#define IDLE_CMD_DEVICE_RESET        0x0010
+#define IDLE_CMD_SCSI_RESET_START    0x0020 /* Assert SCSI Bus Reset */
+#define IDLE_CMD_SCSI_RESET_END      0x0040 /* Deassert SCSI Bus Reset */
+#define IDLE_CMD_SCSIREQ             0x0080
+
+#define IDLE_CMD_STATUS_SUCCESS      0x0001
+#define IDLE_CMD_STATUS_FAILURE      0x0002
+
+/*
+ * AdvSendIdleCmd() flag definitions.
+ */
+#define ADV_NOWAIT     0x01
+
+/*
+ * Wait loop time out values.
+ */
+#define SCSI_WAIT_10_SEC             10UL    /* 10 seconds */
+#define SCSI_WAIT_100_MSEC           100UL   /* 100 milliseconds */
+#define SCSI_US_PER_MSEC             1000    /* microseconds per millisecond */
+#define SCSI_MS_PER_SEC              1000UL  /* milliseconds per second */
+#define SCSI_MAX_RETRY               10      /* retry count */
+
+#define ADV_ASYNC_RDMA_FAILURE          0x01 /* Fatal RDMA failure. */
+#define ADV_ASYNC_SCSI_BUS_RESET_DET    0x02 /* Detected SCSI Bus Reset. */
+#define ADV_ASYNC_CARRIER_READY_FAILURE 0x03 /* Carrier Ready failure. */
+#define ADV_RDMA_IN_CARR_AND_Q_INVALID  0x04 /* RDMAed-in data invalid. */
+
+
+#define ADV_HOST_SCSI_BUS_RESET      0x80 /* Host Initiated SCSI Bus Reset. */
+
+/*
+ * Device drivers must define the following functions.
+ */
+STATIC inline ulong DvcEnterCritical(void);
+STATIC inline void  DvcLeaveCritical(ulong);
+STATIC void  DvcSleepMilliSecond(ADV_DCNT);
+STATIC uchar DvcAdvReadPCIConfigByte(ADV_DVC_VAR *, ushort);
+STATIC void  DvcAdvWritePCIConfigByte(ADV_DVC_VAR *, ushort, uchar);
+STATIC ADV_PADDR DvcGetPhyAddr(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *,
+                uchar *, ASC_SDCNT *, int);
+STATIC void  DvcDelayMicroSecond(ADV_DVC_VAR *, ushort);
+
+/*
+ * Adv Library functions available to drivers.
+ */
+STATIC int     AdvExeScsiQueue(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
+STATIC int     AdvISR(ADV_DVC_VAR *);
+STATIC int     AdvInitGetConfig(ADV_DVC_VAR *);
+STATIC int     AdvInitAsc3550Driver(ADV_DVC_VAR *);
+STATIC int     AdvInitAsc38C0800Driver(ADV_DVC_VAR *);
+STATIC int     AdvInitAsc38C1600Driver(ADV_DVC_VAR *);
+STATIC int     AdvResetChipAndSB(ADV_DVC_VAR *);
+STATIC int     AdvResetSB(ADV_DVC_VAR *asc_dvc);
+
+/*
+ * Internal Adv Library functions.
+ */
+STATIC int    AdvSendIdleCmd(ADV_DVC_VAR *, ushort, ADV_DCNT);
+STATIC void   AdvInquiryHandling(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
+STATIC int    AdvInitFrom3550EEP(ADV_DVC_VAR *);
+STATIC int    AdvInitFrom38C0800EEP(ADV_DVC_VAR *);
+STATIC int    AdvInitFrom38C1600EEP(ADV_DVC_VAR *);
+STATIC ushort AdvGet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
+STATIC void   AdvSet3550EEPConfig(AdvPortAddr, ADVEEP_3550_CONFIG *);
+STATIC ushort AdvGet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
+STATIC void   AdvSet38C0800EEPConfig(AdvPortAddr, ADVEEP_38C0800_CONFIG *);
+STATIC ushort AdvGet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
+STATIC void   AdvSet38C1600EEPConfig(AdvPortAddr, ADVEEP_38C1600_CONFIG *);
+STATIC void   AdvWaitEEPCmd(AdvPortAddr);
+STATIC ushort AdvReadEEPWord(AdvPortAddr, int);
+
+/*
+ * PCI Bus Definitions
+ */
+#define AscPCICmdRegBits_BusMastering     0x0007
+#define AscPCICmdRegBits_ParErrRespCtrl   0x0040
+
+/* Read byte from a register. */
+#define AdvReadByteRegister(iop_base, reg_off) \
+     (ADV_MEM_READB((iop_base) + (reg_off)))
+
+/* Write byte to a register. */
+#define AdvWriteByteRegister(iop_base, reg_off, byte) \
+     (ADV_MEM_WRITEB((iop_base) + (reg_off), (byte)))
+
+/* Read word (2 bytes) from a register. */
+#define AdvReadWordRegister(iop_base, reg_off) \
+     (ADV_MEM_READW((iop_base) + (reg_off)))
+
+/* Write word (2 bytes) to a register. */
+#define AdvWriteWordRegister(iop_base, reg_off, word) \
+     (ADV_MEM_WRITEW((iop_base) + (reg_off), (word)))
+
+/* Write dword (4 bytes) to a register. */
+#define AdvWriteDWordRegister(iop_base, reg_off, dword) \
+     (ADV_MEM_WRITEDW((iop_base) + (reg_off), (dword)))
+
+/* Read byte from LRAM. */
+#define AdvReadByteLram(iop_base, addr, byte) \
+do { \
+    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \
+    (byte) = ADV_MEM_READB((iop_base) + IOPB_RAM_DATA); \
+} while (0)
+
+/* Write byte to LRAM. */
+#define AdvWriteByteLram(iop_base, addr, byte) \
+    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
+     ADV_MEM_WRITEB((iop_base) + IOPB_RAM_DATA, (byte)))
+
+/* Read word (2 bytes) from LRAM. */
+#define AdvReadWordLram(iop_base, addr, word) \
+do { \
+    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \
+    (word) = (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA)); \
+} while (0)
+
+/* Write word (2 bytes) to LRAM. */
+#define AdvWriteWordLram(iop_base, addr, word) \
+    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
+     ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))
+
+/* Write little-endian double word (4 bytes) to LRAM */
+/* Because of unspecified C language ordering don't use auto-increment. */
+#define AdvWriteDWordLramNoSwap(iop_base, addr, dword) \
+    ((ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
+      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \
+                     cpu_to_le16((ushort) ((dword) & 0xFFFF)))), \
+     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \
+      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \
+                     cpu_to_le16((ushort) ((dword >> 16) & 0xFFFF)))))
+
+/* Read word (2 bytes) from LRAM assuming that the address is already set. */
+#define AdvReadWordAutoIncLram(iop_base) \
+     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA))
+
+/* Write word (2 bytes) to LRAM assuming that the address is already set. */
+#define AdvWriteWordAutoIncLram(iop_base, word) \
+     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))
+
+
+/*
+ * Define macro to check for Condor signature.
+ *
+ * Evaluate to ADV_TRUE if a Condor chip is found the specified port
+ * address 'iop_base'. Otherwise evalue to ADV_FALSE.
+ */
+#define AdvFindSignature(iop_base) \
+    (((AdvReadByteRegister((iop_base), IOPB_CHIP_ID_1) == \
+    ADV_CHIP_ID_BYTE) && \
+     (AdvReadWordRegister((iop_base), IOPW_CHIP_ID_0) == \
+    ADV_CHIP_ID_WORD)) ?  ADV_TRUE : ADV_FALSE)
+
+/*
+ * Define macro to Return the version number of the chip at 'iop_base'.
+ *
+ * The second parameter 'bus_type' is currently unused.
+ */
+#define AdvGetChipVersion(iop_base, bus_type) \
+    AdvReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)
+
+/*
+ * Abort an SRB in the chip's RISC Memory. The 'srb_ptr' argument must
+ * match the ASC_SCSI_REQ_Q 'srb_ptr' field.
+ *
+ * If the request has not yet been sent to the device it will simply be
+ * aborted from RISC memory. If the request is disconnected it will be
+ * aborted on reselection by sending an Abort Message to the target ID.
+ *
+ * Return value:
+ *      ADV_TRUE(1) - Queue was successfully aborted.
+ *      ADV_FALSE(0) - Queue was not found on the active queue list.
+ */
+#define AdvAbortQueue(asc_dvc, scsiq) \
+        AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \
+                       (ADV_DCNT) (scsiq))
+
+/*
+ * Send a Bus Device Reset Message to the specified target ID.
+ *
+ * All outstanding commands will be purged if sending the
+ * Bus Device Reset Message is successful.
+ *
+ * Return Value:
+ *      ADV_TRUE(1) - All requests on the target are purged.
+ *      ADV_FALSE(0) - Couldn't issue Bus Device Reset Message; Requests
+ *                     are not purged.
+ */
+#define AdvResetDevice(asc_dvc, target_id) \
+        AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET, \
+                    (ADV_DCNT) (target_id))
+
+/*
+ * SCSI Wide Type definition.
+ */
+#define ADV_SCSI_BIT_ID_TYPE   ushort
+
+/*
+ * AdvInitScsiTarget() 'cntl_flag' options.
+ */
+#define ADV_SCAN_LUN           0x01
+#define ADV_CAPINFO_NOLUN      0x02
+
+/*
+ * Convert target id to target id bit mask.
+ */
+#define ADV_TID_TO_TIDMASK(tid)   (0x01 << ((tid) & ADV_MAX_TID))
+
+/*
+ * ASC_SCSI_REQ_Q 'done_status' and 'host_status' return values.
+ */
+
+#define QD_NO_STATUS         0x00       /* Request not completed yet. */
+#define QD_NO_ERROR          0x01
+#define QD_ABORTED_BY_HOST   0x02
+#define QD_WITH_ERROR        0x04
+
+#define QHSTA_NO_ERROR              0x00
+#define QHSTA_M_SEL_TIMEOUT         0x11
+#define QHSTA_M_DATA_OVER_RUN       0x12
+#define QHSTA_M_UNEXPECTED_BUS_FREE 0x13
+#define QHSTA_M_QUEUE_ABORTED       0x15
+#define QHSTA_M_SXFR_SDMA_ERR       0x16 /* SXFR_STATUS SCSI DMA Error */
+#define QHSTA_M_SXFR_SXFR_PERR      0x17 /* SXFR_STATUS SCSI Bus Parity Error */
+#define QHSTA_M_RDMA_PERR           0x18 /* RISC PCI DMA parity error */
+#define QHSTA_M_SXFR_OFF_UFLW       0x19 /* SXFR_STATUS Offset Underflow */
+#define QHSTA_M_SXFR_OFF_OFLW       0x20 /* SXFR_STATUS Offset Overflow */
+#define QHSTA_M_SXFR_WD_TMO         0x21 /* SXFR_STATUS Watchdog Timeout */
+#define QHSTA_M_SXFR_DESELECTED     0x22 /* SXFR_STATUS Deselected */
+/* Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */
+#define QHSTA_M_SXFR_XFR_OFLW       0x12 /* SXFR_STATUS Transfer Overflow */
+#define QHSTA_M_SXFR_XFR_PH_ERR     0x24 /* SXFR_STATUS Transfer Phase Error */
+#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25 /* SXFR_STATUS Unknown Error */
+#define QHSTA_M_SCSI_BUS_RESET      0x30 /* Request aborted from SBR */
+#define QHSTA_M_SCSI_BUS_RESET_UNSOL 0x31 /* Request aborted from unsol. SBR */
+#define QHSTA_M_BUS_DEVICE_RESET    0x32 /* Request aborted from BDR */
+#define QHSTA_M_DIRECTION_ERR       0x35 /* Data Phase mismatch */
+#define QHSTA_M_DIRECTION_ERR_HUNG  0x36 /* Data Phase mismatch and bus hang */
+#define QHSTA_M_WTM_TIMEOUT         0x41
+#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42
+#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43
+#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44
+#define QHSTA_M_INVALID_DEVICE      0x45 /* Bad target ID */
+#define QHSTA_M_FROZEN_TIDQ         0x46 /* TID Queue frozen. */
+#define QHSTA_M_SGBACKUP_ERROR      0x47 /* Scatter-Gather backup error */
+
+
+/*
+ * Default EEPROM Configuration structure defined in a_init.c.
+ */
+static ADVEEP_3550_CONFIG Default_3550_EEPROM_Config;
+static ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config;
+static ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config;
+
+/*
+ * DvcGetPhyAddr() flag arguments
+ */
+#define ADV_IS_SCSIQ_FLAG       0x01 /* 'addr' is ASC_SCSI_REQ_Q pointer */
+#define ADV_ASCGETSGLIST_VADDR  0x02 /* 'addr' is AscGetSGList() virtual addr */
+#define ADV_IS_SENSE_FLAG       0x04 /* 'addr' is sense virtual pointer */
+#define ADV_IS_DATA_FLAG        0x08 /* 'addr' is data virtual pointer */
+#define ADV_IS_SGLIST_FLAG      0x10 /* 'addr' is sglist virtual pointer */
+#define ADV_IS_CARRIER_FLAG     0x20 /* 'addr' is ADV_CARR_T pointer */
+
+/* Return the address that is aligned at the next doubleword >= to 'addr'. */
+#define ADV_8BALIGN(addr)      (((ulong) (addr) + 0x7) & ~0x7)
+#define ADV_16BALIGN(addr)     (((ulong) (addr) + 0xF) & ~0xF)
+#define ADV_32BALIGN(addr)     (((ulong) (addr) + 0x1F) & ~0x1F)
+
+/*
+ * Total contiguous memory needed for driver SG blocks.
+ *
+ * ADV_MAX_SG_LIST must be defined by a driver. It is the maximum
+ * number of scatter-gather elements the driver supports in a
+ * single request.
+ */
+
+#define ADV_SG_LIST_MAX_BYTE_SIZE \
+         (sizeof(ADV_SG_BLOCK) * \
+          ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))
+
+/*
+ * Inquiry data structure and bitfield macros
+ *
+ * Using bitfields to access the subchar data isn't portable across
+ * endianness, so instead mask and shift. Only quantities of more
+ * than 1 bit are shifted, since the others are just tested for true
+ * or false.
+ */
+
+#define ADV_INQ_DVC_TYPE(inq)       ((inq)->periph & 0x1f)
+#define ADV_INQ_QUALIFIER(inq)      (((inq)->periph & 0xe0) >> 5)
+#define ADV_INQ_DVC_TYPE_MOD(inq)   ((inq)->devtype & 0x7f)
+#define ADV_INQ_REMOVABLE(inq)      ((inq)->devtype & 0x80)
+#define ADV_INQ_ANSI_VER(inq)       ((inq)->ver & 0x07)
+#define ADV_INQ_ECMA_VER(inq)       (((inq)->ver & 0x38) >> 3)
+#define ADV_INQ_ISO_VER(inq)        (((inq)->ver & 0xc0) >> 6)
+#define ADV_INQ_RESPONSE_FMT(inq)   ((inq)->byte3 & 0x0f)
+#define ADV_INQ_TERM_IO(inq)        ((inq)->byte3 & 0x40)
+#define ADV_INQ_ASYNC_NOTIF(inq)    ((inq)->byte3 & 0x80)
+#define ADV_INQ_SOFT_RESET(inq)     ((inq)->flags & 0x01)
+#define ADV_INQ_CMD_QUEUE(inq)      ((inq)->flags & 0x02)
+#define ADV_INQ_LINK_CMD(inq)       ((inq)->flags & 0x08)
+#define ADV_INQ_SYNC(inq)           ((inq)->flags & 0x10)
+#define ADV_INQ_WIDE16(inq)         ((inq)->flags & 0x20)
+#define ADV_INQ_WIDE32(inq)         ((inq)->flags & 0x40)
+#define ADV_INQ_REL_ADDR(inq)       ((inq)->flags & 0x80)
+#define ADV_INQ_INFO_UNIT(inq)      ((inq)->info & 0x01)
+#define ADV_INQ_QUICK_ARB(inq)      ((inq)->info & 0x02)
+#define ADV_INQ_CLOCKING(inq)       (((inq)->info & 0x0c) >> 2)
+
+typedef struct {
+  uchar periph;                 /* peripheral device type [0:4] */
+                                /* peripheral qualifier [5:7] */
+  uchar devtype;                /* device type modifier (for SCSI I) [0:6] */
+                                /* RMB - removable medium bit [7] */
+  uchar ver;                    /* ANSI approved version [0:2] */
+                                /* ECMA version [3:5] */
+                                /* ISO version [6:7] */
+  uchar byte3;                  /* response data format [0:3] */
+                                /* 0 SCSI 1 */
+                                /* 1 CCS */
+                                /* 2 SCSI-2 */
+                                /* 3-F reserved */
+                                /* reserved [4:5] */
+                                /* terminate I/O process bit (see 5.6.22) [6] */
+                                /* asynch. event notification (processor) [7] */
+  uchar add_len;                /* additional length */
+  uchar res1;                   /* reserved */
+  uchar res2;                   /* reserved */
+  uchar flags;                  /* soft reset implemented [0] */
+                                /* command queuing [1] */
+                                /* reserved [2] */
+                                /* linked command for this logical unit [3] */
+                                /* synchronous data transfer [4] */
+                                /* wide bus 16 bit data transfer [5] */
+                                /* wide bus 32 bit data transfer [6] */
+                                /* relative addressing mode [7] */
+  uchar vendor_id[8];           /* vendor identification */
+  uchar product_id[16];         /* product identification */
+  uchar product_rev_level[4];   /* product revision level */
+  uchar vendor_specific[20];    /* vendor specific */
+  uchar info;                   /* information unit supported [0] */
+                                /* quick arbitrate supported [1] */
+                                /* clocking field [2:3] */
+                                /* reserved [4:7] */
+  uchar res3;                   /* reserved */
+} ADV_SCSI_INQUIRY; /* 58 bytes */
+
+
+/*
+ * --- Driver Constants and Macros
+ */
+
+#define ASC_NUM_BOARD_SUPPORTED 16
+#define ASC_NUM_IOPORT_PROBE    4
+#define ASC_NUM_BUS             4
+
+/* Reference Scsi_Host hostdata */
+#define ASC_BOARDP(host) ((asc_board_t *) &((host)->hostdata))
+
+/* asc_board_t flags */
+#define ASC_HOST_IN_RESET       0x01
+#define ASC_IS_WIDE_BOARD       0x04    /* AdvanSys Wide Board */
+#define ASC_SELECT_QUEUE_DEPTHS 0x08
+
+#define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)
+#define ASC_WIDE_BOARD(boardp)   ((boardp)->flags & ASC_IS_WIDE_BOARD)
+
+#define NO_ISA_DMA              0xff        /* No ISA DMA Channel Used */
+
+#define ASC_INFO_SIZE           128            /* advansys_info() line size */
+
+#ifdef CONFIG_PROC_FS
+/* /proc/scsi/advansys/[0...] related definitions */
+#define ASC_PRTBUF_SIZE         2048
+#define ASC_PRTLINE_SIZE        160
+
+#define ASC_PRT_NEXT() \
+    if (cp) { \
+        totlen += len; \
+        leftlen -= len; \
+        if (leftlen == 0) { \
+            return totlen; \
+        } \
+        cp += len; \
+    }
+#endif /* CONFIG_PROC_FS */
+
+/* Asc Library return codes */
+#define ASC_TRUE        1
+#define ASC_FALSE       0
+#define ASC_NOERROR     1
+#define ASC_BUSY        0
+#define ASC_ERROR       (-1)
+
+/* struct scsi_cmnd function return codes */
+#define STATUS_BYTE(byte)   (byte)
+#define MSG_BYTE(byte)      ((byte) << 8)
+#define HOST_BYTE(byte)     ((byte) << 16)
+#define DRIVER_BYTE(byte)   ((byte) << 24)
+
+/*
+ * The following definitions and macros are OS independent interfaces to
+ * the queue functions:
+ *  REQ - SCSI request structure
+ *  REQP - pointer to SCSI request structure
+ *  REQPTID(reqp) - reqp's target id
+ *  REQPNEXT(reqp) - reqp's next pointer
+ *  REQPNEXTP(reqp) - pointer to reqp's next pointer
+ *  REQPTIME(reqp) - reqp's time stamp value
+ *  REQTIMESTAMP() - system time stamp value
+ */
+typedef struct scsi_cmnd     REQ, *REQP;
+#define REQPNEXT(reqp)       ((REQP) ((reqp)->host_scribble))
+#define REQPNEXTP(reqp)      ((REQP *) &((reqp)->host_scribble))
+#define REQPTID(reqp)        ((reqp)->device->id)
+#define REQPTIME(reqp)       ((reqp)->SCp.this_residual)
+#define REQTIMESTAMP()       (jiffies)
+
+#define REQTIMESTAT(function, ascq, reqp, tid) \
+{ \
+    /*
+     * If the request time stamp is less than the system time stamp, then \
+     * maybe the system time stamp wrapped. Set the request time to zero.\
+     */ \
+    if (REQPTIME(reqp) <= REQTIMESTAMP()) { \
+        REQPTIME(reqp) = REQTIMESTAMP() - REQPTIME(reqp); \
+    } else { \
+        /* Indicate an error occurred with the assertion. */ \
+        ASC_ASSERT(REQPTIME(reqp) <= REQTIMESTAMP()); \
+        REQPTIME(reqp) = 0; \
+    } \
+    /* Handle first minimum time case without external initialization. */ \
+    if (((ascq)->q_tot_cnt[tid] == 1) ||  \
+        (REQPTIME(reqp) < (ascq)->q_min_tim[tid])) { \
+            (ascq)->q_min_tim[tid] = REQPTIME(reqp); \
+            ASC_DBG3(1, "%s: new q_min_tim[%d] %u\n", \
+                (function), (tid), (ascq)->q_min_tim[tid]); \
+        } \
+    if (REQPTIME(reqp) > (ascq)->q_max_tim[tid]) { \
+        (ascq)->q_max_tim[tid] = REQPTIME(reqp); \
+        ASC_DBG3(1, "%s: new q_max_tim[%d] %u\n", \
+            (function), tid, (ascq)->q_max_tim[tid]); \
+    } \
+    (ascq)->q_tot_tim[tid] += REQPTIME(reqp); \
+    /* Reset the time stamp field. */ \
+    REQPTIME(reqp) = 0; \
+}
+
+/* asc_enqueue() flags */
+#define ASC_FRONT       1
+#define ASC_BACK        2
+
+/* asc_dequeue_list() argument */
+#define ASC_TID_ALL        (-1)
+
+/* Return non-zero, if the queue is empty. */
+#define ASC_QUEUE_EMPTY(ascq)    ((ascq)->q_tidmask == 0)
+
+#define PCI_MAX_SLOT            0x1F
+#define PCI_MAX_BUS             0xFF
+#define PCI_IOADDRESS_MASK      0xFFFE
+#define ASC_PCI_VENDORID        0x10CD
+#define ASC_PCI_DEVICE_ID_CNT   6       /* PCI Device ID count. */
+#define ASC_PCI_DEVICE_ID_1100  0x1100
+#define ASC_PCI_DEVICE_ID_1200  0x1200
+#define ASC_PCI_DEVICE_ID_1300  0x1300
+#define ASC_PCI_DEVICE_ID_2300  0x2300  /* ASC-3550 */
+#define ASC_PCI_DEVICE_ID_2500  0x2500  /* ASC-38C0800 */
+#define ASC_PCI_DEVICE_ID_2700  0x2700  /* ASC-38C1600 */
+
+#ifndef ADVANSYS_STATS
+#define ASC_STATS(shp, counter)
+#define ASC_STATS_ADD(shp, counter, count)
+#else /* ADVANSYS_STATS */
+#define ASC_STATS(shp, counter) \
+    (ASC_BOARDP(shp)->asc_stats.counter++)
+
+#define ASC_STATS_ADD(shp, counter, count) \
+    (ASC_BOARDP(shp)->asc_stats.counter += (count))
+#endif /* ADVANSYS_STATS */
+
+#define ASC_CEILING(val, unit) (((val) + ((unit) - 1))/(unit))
+
+/* If the result wraps when calculating tenths, return 0. */
+#define ASC_TENTHS(num, den) \
+    (((10 * ((num)/(den))) > (((num) * 10)/(den))) ? \
+    0 : ((((num) * 10)/(den)) - (10 * ((num)/(den)))))
+
+/*
+ * Display a message to the console.
+ */
+#define ASC_PRINT(s) \
+    { \
+        printk("advansys: "); \
+        printk(s); \
+    }
+
+#define ASC_PRINT1(s, a1) \
+    { \
+        printk("advansys: "); \
+        printk((s), (a1)); \
+    }
+
+#define ASC_PRINT2(s, a1, a2) \
+    { \
+        printk("advansys: "); \
+        printk((s), (a1), (a2)); \
+    }
+
+#define ASC_PRINT3(s, a1, a2, a3) \
+    { \
+        printk("advansys: "); \
+        printk((s), (a1), (a2), (a3)); \
+    }
+
+#define ASC_PRINT4(s, a1, a2, a3, a4) \
+    { \
+        printk("advansys: "); \
+        printk((s), (a1), (a2), (a3), (a4)); \
+    }
+
+
+#ifndef ADVANSYS_DEBUG
+
+#define ASC_DBG(lvl, s)
+#define ASC_DBG1(lvl, s, a1)
+#define ASC_DBG2(lvl, s, a1, a2)
+#define ASC_DBG3(lvl, s, a1, a2, a3)
+#define ASC_DBG4(lvl, s, a1, a2, a3, a4)
+#define ASC_DBG_PRT_SCSI_HOST(lvl, s)
+#define ASC_DBG_PRT_SCSI_CMND(lvl, s)
+#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp)
+#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)
+#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone)
+#define ADV_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)
+#define ASC_DBG_PRT_HEX(lvl, name, start, length)
+#define ASC_DBG_PRT_CDB(lvl, cdb, len)
+#define ASC_DBG_PRT_SENSE(lvl, sense, len)
+#define ASC_DBG_PRT_INQUIRY(lvl, inq, len)
+
+#else /* ADVANSYS_DEBUG */
+
+/*
+ * Debugging Message Levels:
+ * 0: Errors Only
+ * 1: High-Level Tracing
+ * 2-N: Verbose Tracing
+ */
+
+#define ASC_DBG(lvl, s) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            printk(s); \
+        } \
+    }
+
+#define ASC_DBG1(lvl, s, a1) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            printk((s), (a1)); \
+        } \
+    }
+
+#define ASC_DBG2(lvl, s, a1, a2) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            printk((s), (a1), (a2)); \
+        } \
+    }
+
+#define ASC_DBG3(lvl, s, a1, a2, a3) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            printk((s), (a1), (a2), (a3)); \
+        } \
+    }
+
+#define ASC_DBG4(lvl, s, a1, a2, a3, a4) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            printk((s), (a1), (a2), (a3), (a4)); \
+        } \
+    }
+
+#define ASC_DBG_PRT_SCSI_HOST(lvl, s) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            asc_prt_scsi_host(s); \
+        } \
+    }
+
+#define ASC_DBG_PRT_SCSI_CMND(lvl, s) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            asc_prt_scsi_cmnd(s); \
+        } \
+    }
+
+#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            asc_prt_asc_scsi_q(scsiqp); \
+        } \
+    }
+
+#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            asc_prt_asc_qdone_info(qdone); \
+        } \
+    }
+
+#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            asc_prt_adv_scsi_req_q(scsiqp); \
+        } \
+    }
+
+#define ASC_DBG_PRT_HEX(lvl, name, start, length) \
+    { \
+        if (asc_dbglvl >= (lvl)) { \
+            asc_prt_hex((name), (start), (length)); \
+        } \
+    }
+
+#define ASC_DBG_PRT_CDB(lvl, cdb, len) \
+        ASC_DBG_PRT_HEX((lvl), "CDB", (uchar *) (cdb), (len));
+
+#define ASC_DBG_PRT_SENSE(lvl, sense, len) \
+        ASC_DBG_PRT_HEX((lvl), "SENSE", (uchar *) (sense), (len));
+
+#define ASC_DBG_PRT_INQUIRY(lvl, inq, len) \
+        ASC_DBG_PRT_HEX((lvl), "INQUIRY", (uchar *) (inq), (len));
+#endif /* ADVANSYS_DEBUG */
+
+#ifndef ADVANSYS_ASSERT
+#define ASC_ASSERT(a)
+#else /* ADVANSYS_ASSERT */
+
+#define ASC_ASSERT(a) \
+    { \
+        if (!(a)) { \
+            printk("ASC_ASSERT() Failure: file %s, line %d\n", \
+                __FILE__, __LINE__); \
+        } \
+    }
+
+#endif /* ADVANSYS_ASSERT */
+
+
+/*
+ * --- Driver Structures
+ */
+
+#ifdef ADVANSYS_STATS
+
+/* Per board statistics structure */
+struct asc_stats {
+    /* Driver Entrypoint Statistics */
+    ADV_DCNT queuecommand;    /* # calls to advansys_queuecommand() */
+    ADV_DCNT reset;           /* # calls to advansys_eh_bus_reset() */
+    ADV_DCNT biosparam;       /* # calls to advansys_biosparam() */
+    ADV_DCNT interrupt;       /* # advansys_interrupt() calls */
+    ADV_DCNT callback;        /* # calls to asc/adv_isr_callback() */
+    ADV_DCNT done;            /* # calls to request's scsi_done function */
+    ADV_DCNT build_error;     /* # asc/adv_build_req() ASC_ERROR returns. */
+    ADV_DCNT adv_build_noreq; /* # adv_build_req() adv_req_t alloc. fail. */
+    ADV_DCNT adv_build_nosg;  /* # adv_build_req() adv_sgblk_t alloc. fail. */
+    /* AscExeScsiQueue()/AdvExeScsiQueue() Statistics */
+    ADV_DCNT exe_noerror;     /* # ASC_NOERROR returns. */
+    ADV_DCNT exe_busy;        /* # ASC_BUSY returns. */
+    ADV_DCNT exe_error;       /* # ASC_ERROR returns. */
+    ADV_DCNT exe_unknown;     /* # unknown returns. */
+    /* Data Transfer Statistics */
+    ADV_DCNT cont_cnt;        /* # non-scatter-gather I/O requests received */
+    ADV_DCNT cont_xfer;       /* # contiguous transfer 512-bytes */
+    ADV_DCNT sg_cnt;          /* # scatter-gather I/O requests received */
+    ADV_DCNT sg_elem;         /* # scatter-gather elements */
+    ADV_DCNT sg_xfer;         /* # scatter-gather transfer 512-bytes */
+};
+#endif /* ADVANSYS_STATS */
+
+/*
+ * Request queuing structure
+ */
+typedef struct asc_queue {
+    ADV_SCSI_BIT_ID_TYPE  q_tidmask;                /* queue mask */
+    REQP                  q_first[ADV_MAX_TID+1];   /* first queued request */
+    REQP                  q_last[ADV_MAX_TID+1];    /* last queued request */
+#ifdef ADVANSYS_STATS
+    short                 q_cur_cnt[ADV_MAX_TID+1]; /* current queue count */
+    short                 q_max_cnt[ADV_MAX_TID+1]; /* maximum queue count */
+    ADV_DCNT              q_tot_cnt[ADV_MAX_TID+1]; /* total enqueue count */
+    ADV_DCNT              q_tot_tim[ADV_MAX_TID+1]; /* total time queued */
+    ushort                q_max_tim[ADV_MAX_TID+1]; /* maximum time queued */
+    ushort                q_min_tim[ADV_MAX_TID+1]; /* minimum time queued */
+#endif /* ADVANSYS_STATS */
+} asc_queue_t;
+
+/*
+ * Adv Library Request Structures
+ *
+ * The following two structures are used to process Wide Board requests.
+ *
+ * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library
+ * and microcode with the ADV_SCSI_REQ_Q field 'srb_ptr' pointing to the
+ * adv_req_t. The adv_req_t structure 'cmndp' field in turn points to the
+ * Mid-Level SCSI request structure.
+ *
+ * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each
+ * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux
+ * up to 255 scatter-gather elements may be used per request or
+ * ADV_SCSI_REQ_Q.
+ *
+ * Both structures must be 32 byte aligned.
+ */
+typedef struct adv_sgblk {
+    ADV_SG_BLOCK        sg_block;     /* Sgblock structure. */
+    uchar               align[32];    /* Sgblock structure padding. */
+    struct adv_sgblk    *next_sgblkp; /* Next scatter-gather structure. */
+} adv_sgblk_t;
+
+typedef struct adv_req {
+    ADV_SCSI_REQ_Q      scsi_req_q;   /* Adv Library request structure. */
+    uchar               align[32];    /* Request structure padding. */
+    struct scsi_cmnd	*cmndp;       /* Mid-Level SCSI command pointer. */
+    adv_sgblk_t         *sgblkp;      /* Adv Library scatter-gather pointer. */
+    struct adv_req      *next_reqp;   /* Next Request Structure. */
+} adv_req_t;
+
+/*
+ * Structure allocated for each board.
+ *
+ * This structure is allocated by scsi_register() at the end
+ * of the 'Scsi_Host' structure starting at the 'hostdata'
+ * field. It is guaranteed to be allocated from DMA-able memory.
+ */
+typedef struct asc_board {
+    int                  id;                    /* Board Id */
+    uint                 flags;                 /* Board flags */
+    union {
+        ASC_DVC_VAR      asc_dvc_var;           /* Narrow board */
+        ADV_DVC_VAR      adv_dvc_var;           /* Wide board */
+    } dvc_var;
+    union {
+        ASC_DVC_CFG      asc_dvc_cfg;           /* Narrow board */
+        ADV_DVC_CFG      adv_dvc_cfg;           /* Wide board */
+    } dvc_cfg;
+    ushort               asc_n_io_port;         /* Number I/O ports. */
+    asc_queue_t          active;                /* Active command queue */
+    asc_queue_t          waiting;               /* Waiting command queue */
+    asc_queue_t          done;                  /* Done command queue */
+    ADV_SCSI_BIT_ID_TYPE init_tidmask;          /* Target init./valid mask */
+    struct scsi_device	*device[ADV_MAX_TID+1]; /* Mid-Level Scsi Device */
+    ushort               reqcnt[ADV_MAX_TID+1]; /* Starvation request count */
+    ADV_SCSI_BIT_ID_TYPE queue_full;            /* Queue full mask */
+    ushort               queue_full_cnt[ADV_MAX_TID+1]; /* Queue full count */
+    union {
+        ASCEEP_CONFIG         asc_eep;          /* Narrow EEPROM config. */
+        ADVEEP_3550_CONFIG    adv_3550_eep;     /* 3550 EEPROM config. */
+        ADVEEP_38C0800_CONFIG adv_38C0800_eep;  /* 38C0800 EEPROM config. */
+        ADVEEP_38C1600_CONFIG adv_38C1600_eep;  /* 38C1600 EEPROM config. */
+    } eep_config;
+    ulong                last_reset;            /* Saved last reset time */
+    spinlock_t lock;                            /* Board spinlock */
+#ifdef CONFIG_PROC_FS
+    /* /proc/scsi/advansys/[0...] */
+    char                 *prtbuf;               /* /proc print buffer */
+#endif /* CONFIG_PROC_FS */
+#ifdef ADVANSYS_STATS
+    struct asc_stats     asc_stats;             /* Board statistics */
+#endif /* ADVANSYS_STATS */
+    /*
+     * The following fields are used only for Narrow Boards.
+     */
+    /* The following three structures must be in DMA-able memory. */
+    ASC_SCSI_REQ_Q       scsireqq;
+    ASC_CAP_INFO         cap_info;
+    ASC_SCSI_INQUIRY     inquiry;
+    uchar                sdtr_data[ASC_MAX_TID+1]; /* SDTR information */
+    /*
+     * The following fields are used only for Wide Boards.
+     */
+    void                 *ioremap_addr;         /* I/O Memory remap address. */
+    ushort               ioport;                /* I/O Port address. */
+    ADV_CARR_T           *orig_carrp;           /* ADV_CARR_T memory block. */
+    adv_req_t            *orig_reqp;            /* adv_req_t memory block. */
+    adv_req_t            *adv_reqp;             /* Request structures. */
+    adv_sgblk_t          *adv_sgblkp;           /* Scatter-gather structures. */
+    ushort               bios_signature;        /* BIOS Signature. */
+    ushort               bios_version;          /* BIOS Version. */
+    ushort               bios_codeseg;          /* BIOS Code Segment. */
+    ushort               bios_codelen;          /* BIOS Code Segment Length. */
+} asc_board_t;
+
+/*
+ * PCI configuration structures
+ */
+typedef struct _PCI_DATA_
+{
+    uchar    type;
+    uchar    bus;
+    uchar    slot;
+    uchar    func;
+    uchar    offset;
+} PCI_DATA;
+
+typedef struct _PCI_DEVICE_
+{
+    ushort   vendorID;
+    ushort   deviceID;
+    ushort   slotNumber;
+    ushort   slotFound;
+    uchar    busNumber;
+    uchar    maxBusNumber;
+    uchar    devFunc;
+    ushort   startSlot;
+    ushort   endSlot;
+    uchar    bridge;
+    uchar    type;
+} PCI_DEVICE;
+
+typedef struct _PCI_CONFIG_SPACE_
+{
+    ushort   vendorID;
+    ushort   deviceID;
+    ushort   command;
+    ushort   status;
+    uchar    revision;
+    uchar    classCode[3];
+    uchar    cacheSize;
+    uchar    latencyTimer;
+    uchar    headerType;
+    uchar    bist;
+    ADV_PADDR baseAddress[6];
+    ushort   reserved[4];
+    ADV_PADDR optionRomAddr;
+    ushort   reserved2[4];
+    uchar    irqLine;
+    uchar    irqPin;
+    uchar    minGnt;
+    uchar    maxLatency;
+} PCI_CONFIG_SPACE;
+
+
+/*
+ * --- Driver Data
+ */
+
+/* Note: All driver global data should be initialized. */
+
+/* Number of boards detected in system. */
+STATIC int asc_board_count = 0;
+STATIC struct Scsi_Host    *asc_host[ASC_NUM_BOARD_SUPPORTED] = { 0 };
+
+/* Overrun buffer used by all narrow boards. */
+STATIC uchar overrun_buf[ASC_OVERRUN_BSIZE] = { 0 };
+
+/*
+ * Global structures required to issue a command.
+ */
+STATIC ASC_SCSI_Q asc_scsi_q = { { 0 } };
+STATIC ASC_SG_HEAD asc_sg_head = { 0 };
+
+/* List of supported bus types. */
+STATIC ushort asc_bus[ASC_NUM_BUS] __initdata = {
+    ASC_IS_ISA,
+    ASC_IS_VL,
+    ASC_IS_EISA,
+    ASC_IS_PCI,
+};
+
+/*
+ * Used with the LILO 'advansys' option to eliminate or
+ * limit I/O port probing at boot time, cf. advansys_setup().
+ */
+STATIC int asc_iopflag = ASC_FALSE;
+STATIC int asc_ioport[ASC_NUM_IOPORT_PROBE] = { 0, 0, 0, 0 };
+
+#ifdef ADVANSYS_DEBUG
+STATIC char *
+asc_bus_name[ASC_NUM_BUS] = {
+    "ASC_IS_ISA",
+    "ASC_IS_VL",
+    "ASC_IS_EISA",
+    "ASC_IS_PCI",
+};
+
+STATIC int          asc_dbglvl = 3;
+#endif /* ADVANSYS_DEBUG */
+
+/* Declaration for Asc Library internal data referenced by driver. */
+STATIC PortAddr     _asc_def_iop_base[];
+
+
+/*
+ * --- Driver Function Prototypes
+ *
+ * advansys.h contains function prototypes for functions global to Linux.
+ */
+
+STATIC irqreturn_t advansys_interrupt(int, void *, struct pt_regs *);
+STATIC int	  advansys_slave_configure(struct scsi_device *);
+STATIC void       asc_scsi_done_list(struct scsi_cmnd *);
+STATIC int        asc_execute_scsi_cmnd(struct scsi_cmnd *);
+STATIC int        asc_build_req(asc_board_t *, struct scsi_cmnd *);
+STATIC int        adv_build_req(asc_board_t *, struct scsi_cmnd *, ADV_SCSI_REQ_Q **);
+STATIC int        adv_get_sglist(asc_board_t *, adv_req_t *, struct scsi_cmnd *, int);
+STATIC void       asc_isr_callback(ASC_DVC_VAR *, ASC_QDONE_INFO *);
+STATIC void       adv_isr_callback(ADV_DVC_VAR *, ADV_SCSI_REQ_Q *);
+STATIC void       adv_async_callback(ADV_DVC_VAR *, uchar);
+STATIC void       asc_enqueue(asc_queue_t *, REQP, int);
+STATIC REQP       asc_dequeue(asc_queue_t *, int);
+STATIC REQP       asc_dequeue_list(asc_queue_t *, REQP *, int);
+STATIC int        asc_rmqueue(asc_queue_t *, REQP);
+STATIC void       asc_execute_queue(asc_queue_t *);
+#ifdef CONFIG_PROC_FS
+STATIC int        asc_proc_copy(off_t, off_t, char *, int , char *, int);
+STATIC int        asc_prt_board_devices(struct Scsi_Host *, char *, int);
+STATIC int        asc_prt_adv_bios(struct Scsi_Host *, char *, int);
+STATIC int        asc_get_eeprom_string(ushort *serialnum, uchar *cp);
+STATIC int        asc_prt_asc_board_eeprom(struct Scsi_Host *, char *, int);
+STATIC int        asc_prt_adv_board_eeprom(struct Scsi_Host *, char *, int);
+STATIC int        asc_prt_driver_conf(struct Scsi_Host *, char *, int);
+STATIC int        asc_prt_asc_board_info(struct Scsi_Host *, char *, int);
+STATIC int        asc_prt_adv_board_info(struct Scsi_Host *, char *, int);
+STATIC int        asc_prt_line(char *, int, char *fmt, ...);
+#endif /* CONFIG_PROC_FS */
+
+/* Declaration for Asc Library internal functions referenced by driver. */
+STATIC int          AscFindSignature(PortAddr);
+STATIC ushort       AscGetEEPConfig(PortAddr, ASCEEP_CONFIG *, ushort);
+
+/* Statistics function prototypes. */
+#ifdef ADVANSYS_STATS
+#ifdef CONFIG_PROC_FS
+STATIC int          asc_prt_board_stats(struct Scsi_Host *, char *, int);
+STATIC int          asc_prt_target_stats(struct Scsi_Host *, int, char *, int);
+#endif /* CONFIG_PROC_FS */
+#endif /* ADVANSYS_STATS */
+
+/* Debug function prototypes. */
+#ifdef ADVANSYS_DEBUG
+STATIC void         asc_prt_scsi_host(struct Scsi_Host *);
+STATIC void         asc_prt_scsi_cmnd(struct scsi_cmnd *);
+STATIC void         asc_prt_asc_dvc_cfg(ASC_DVC_CFG *);
+STATIC void         asc_prt_asc_dvc_var(ASC_DVC_VAR *);
+STATIC void         asc_prt_asc_scsi_q(ASC_SCSI_Q *);
+STATIC void         asc_prt_asc_qdone_info(ASC_QDONE_INFO *);
+STATIC void         asc_prt_adv_dvc_cfg(ADV_DVC_CFG *);
+STATIC void         asc_prt_adv_dvc_var(ADV_DVC_VAR *);
+STATIC void         asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *);
+STATIC void         asc_prt_adv_sgblock(int, ADV_SG_BLOCK *);
+STATIC void         asc_prt_hex(char *f, uchar *, int);
+#endif /* ADVANSYS_DEBUG */
+
+
+/*
+ * --- Linux 'Scsi_Host_Template' and advansys_setup() Functions
+ */
+
+#ifdef CONFIG_PROC_FS
+/*
+ * advansys_proc_info() - /proc/scsi/advansys/[0-(ASC_NUM_BOARD_SUPPORTED-1)]
+ *
+ * *buffer: I/O buffer
+ * **start: if inout == FALSE pointer into buffer where user read should start
+ * offset: current offset into a /proc/scsi/advansys/[0...] file
+ * length: length of buffer
+ * hostno: Scsi_Host host_no
+ * inout: TRUE - user is writing; FALSE - user is reading
+ *
+ * Return the number of bytes read from or written to a
+ * /proc/scsi/advansys/[0...] file.
+ *
+ * Note: This function uses the per board buffer 'prtbuf' which is
+ * allocated when the board is initialized in advansys_detect(). The
+ * buffer is ASC_PRTBUF_SIZE bytes. The function asc_proc_copy() is
+ * used to write to the buffer. The way asc_proc_copy() is written
+ * if 'prtbuf' is too small it will not be overwritten. Instead the
+ * user just won't get all the available statistics.
+ */
+int
+advansys_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
+		off_t offset, int length, int inout)
+{
+    struct Scsi_Host    *shp;
+    asc_board_t         *boardp;
+    int                 i;
+    char                *cp;
+    int			cplen;
+    int                 cnt;
+    int                 totcnt;
+    int                 leftlen;
+    char                *curbuf;
+    off_t               advoffset;
+#ifdef ADVANSYS_STATS
+    int                 tgt_id;
+#endif /* ADVANSYS_STATS */
+
+    ASC_DBG(1, "advansys_proc_info: begin\n");
+
+    /*
+     * User write not supported.
+     */
+    if (inout == TRUE) {
+        return(-ENOSYS);
+    }
+
+    /*
+     * User read of /proc/scsi/advansys/[0...] file.
+     */
+
+    /* Find the specified board. */
+    for (i = 0; i < asc_board_count; i++) {
+        if (asc_host[i]->host_no == shost->host_no) {
+            break;
+        }
+    }
+    if (i == asc_board_count) {
+        return(-ENOENT);
+    }
+
+    shp = asc_host[i];
+    boardp = ASC_BOARDP(shp);
+
+    /* Copy read data starting at the beginning of the buffer. */
+    *start = buffer;
+    curbuf = buffer;
+    advoffset = 0;
+    totcnt = 0;
+    leftlen = length;
+
+    /*
+     * Get board configuration information.
+     *
+     * advansys_info() returns the board string from its own static buffer.
+     */
+    cp = (char *) advansys_info(shp);
+    strcat(cp, "\n");
+    cplen = strlen(cp);
+    /* Copy board information. */
+    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+    totcnt += cnt;
+    leftlen -= cnt;
+    if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+    }
+    advoffset += cplen;
+    curbuf += cnt;
+
+    /*
+     * Display Wide Board BIOS Information.
+     */
+    if (ASC_WIDE_BOARD(boardp)) {
+        cp = boardp->prtbuf;
+        cplen = asc_prt_adv_bios(shp, cp, ASC_PRTBUF_SIZE);
+        ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+        cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+        totcnt += cnt;
+        leftlen -= cnt;
+        if (leftlen == 0) {
+            ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+            return totcnt;
+        }
+        advoffset += cplen;
+        curbuf += cnt;
+    }
+
+    /*
+     * Display driver information for each device attached to the board.
+     */
+    cp = boardp->prtbuf;
+    cplen = asc_prt_board_devices(shp, cp, ASC_PRTBUF_SIZE);
+    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+    totcnt += cnt;
+    leftlen -= cnt;
+    if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+    }
+    advoffset += cplen;
+    curbuf += cnt;
+
+    /*
+     * Display EEPROM configuration for the board.
+     */
+    cp = boardp->prtbuf;
+    if (ASC_NARROW_BOARD(boardp)) {
+        cplen = asc_prt_asc_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
+    } else {
+        cplen = asc_prt_adv_board_eeprom(shp, cp, ASC_PRTBUF_SIZE);
+    }
+    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+    totcnt += cnt;
+    leftlen -= cnt;
+    if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+    }
+    advoffset += cplen;
+    curbuf += cnt;
+
+    /*
+     * Display driver configuration and information for the board.
+     */
+    cp = boardp->prtbuf;
+    cplen = asc_prt_driver_conf(shp, cp, ASC_PRTBUF_SIZE);
+    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+    totcnt += cnt;
+    leftlen -= cnt;
+    if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+    }
+    advoffset += cplen;
+    curbuf += cnt;
+
+#ifdef ADVANSYS_STATS
+    /*
+     * Display driver statistics for the board.
+     */
+    cp = boardp->prtbuf;
+    cplen = asc_prt_board_stats(shp, cp, ASC_PRTBUF_SIZE);
+    ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
+    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+    totcnt += cnt;
+    leftlen -= cnt;
+    if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+    }
+    advoffset += cplen;
+    curbuf += cnt;
+
+    /*
+     * Display driver statistics for each target.
+     */
+    for (tgt_id = 0; tgt_id <= ADV_MAX_TID; tgt_id++) {
+      cp = boardp->prtbuf;
+      cplen = asc_prt_target_stats(shp, tgt_id, cp, ASC_PRTBUF_SIZE);
+      ASC_ASSERT(cplen <= ASC_PRTBUF_SIZE);
+      cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+      totcnt += cnt;
+      leftlen -= cnt;
+      if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+      }
+      advoffset += cplen;
+      curbuf += cnt;
+    }
+#endif /* ADVANSYS_STATS */
+
+    /*
+     * Display Asc Library dynamic configuration information
+     * for the board.
+     */
+    cp = boardp->prtbuf;
+    if (ASC_NARROW_BOARD(boardp)) {
+        cplen = asc_prt_asc_board_info(shp, cp, ASC_PRTBUF_SIZE);
+    } else {
+        cplen = asc_prt_adv_board_info(shp, cp, ASC_PRTBUF_SIZE);
+    }
+    ASC_ASSERT(cplen < ASC_PRTBUF_SIZE);
+    cnt = asc_proc_copy(advoffset, offset, curbuf, leftlen, cp, cplen);
+    totcnt += cnt;
+    leftlen -= cnt;
+    if (leftlen == 0) {
+        ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+        return totcnt;
+    }
+    advoffset += cplen;
+    curbuf += cnt;
+
+    ASC_DBG1(1, "advansys_proc_info: totcnt %d\n", totcnt);
+
+    return totcnt;
+}
+#endif /* CONFIG_PROC_FS */
+
+/*
+ * advansys_detect()
+ *
+ * Detect function for AdvanSys adapters.
+ *
+ * Argument is a pointer to the host driver's scsi_hosts entry.
+ *
+ * Return number of adapters found.
+ *
+ * Note: Because this function is called during system initialization
+ * it must not call SCSI mid-level functions including scsi_malloc()
+ * and scsi_free().
+ */
+int __init
+advansys_detect(struct scsi_host_template *tpnt)
+{
+    static int          detect_called = ASC_FALSE;
+    int                 iop;
+    int                 bus;
+    struct Scsi_Host    *shp = NULL;
+    asc_board_t         *boardp = NULL;
+    ASC_DVC_VAR         *asc_dvc_varp = NULL;
+    ADV_DVC_VAR         *adv_dvc_varp = NULL;
+    adv_sgblk_t         *sgp = NULL;
+    int                 ioport = 0;
+    int                 share_irq = FALSE;
+    int                 iolen = 0;
+    struct device	*dev = NULL;
+#ifdef CONFIG_PCI
+    int                 pci_init_search = 0;
+    struct pci_dev      *pci_devicep[ASC_NUM_BOARD_SUPPORTED];
+    int                 pci_card_cnt_max = 0;
+    int                 pci_card_cnt = 0;
+    struct pci_dev      *pci_devp = NULL;
+    int                 pci_device_id_cnt = 0;
+    unsigned int        pci_device_id[ASC_PCI_DEVICE_ID_CNT] = {
+                                    ASC_PCI_DEVICE_ID_1100,
+                                    ASC_PCI_DEVICE_ID_1200,
+                                    ASC_PCI_DEVICE_ID_1300,
+                                    ASC_PCI_DEVICE_ID_2300,
+                                    ASC_PCI_DEVICE_ID_2500,
+                                    ASC_PCI_DEVICE_ID_2700
+                        };
+    ADV_PADDR           pci_memory_address;
+#endif /* CONFIG_PCI */
+    int                 warn_code, err_code;
+    int                 ret;
+
+    if (detect_called == ASC_FALSE) {
+        detect_called = ASC_TRUE;
+    } else {
+        printk("AdvanSys SCSI: advansys_detect() multiple calls ignored\n");
+        return 0;
+    }
+
+    ASC_DBG(1, "advansys_detect: begin\n");
+
+    asc_board_count = 0;
+
+    /*
+     * If I/O port probing has been modified, then verify and
+     * clean-up the 'asc_ioport' list.
+     */
+    if (asc_iopflag == ASC_TRUE) {
+        for (ioport = 0; ioport < ASC_NUM_IOPORT_PROBE; ioport++) {
+            ASC_DBG2(1, "advansys_detect: asc_ioport[%d] 0x%x\n",
+                ioport, asc_ioport[ioport]);
+            if (asc_ioport[ioport] != 0) {
+                for (iop = 0; iop < ASC_IOADR_TABLE_MAX_IX; iop++) {
+                    if (_asc_def_iop_base[iop] == asc_ioport[ioport]) {
+                        break;
+                    }
+                }
+                if (iop == ASC_IOADR_TABLE_MAX_IX) {
+                    printk(
+"AdvanSys SCSI: specified I/O Port 0x%X is invalid\n",
+                        asc_ioport[ioport]);
+                    asc_ioport[ioport] = 0;
+                }
+            }
+        }
+        ioport = 0;
+    }
+
+    for (bus = 0; bus < ASC_NUM_BUS; bus++) {
+
+        ASC_DBG2(1, "advansys_detect: bus search type %d (%s)\n",
+            bus, asc_bus_name[bus]);
+        iop = 0;
+
+        while (asc_board_count < ASC_NUM_BOARD_SUPPORTED) {
+
+            ASC_DBG1(2, "advansys_detect: asc_board_count %d\n",
+                asc_board_count);
+
+            switch (asc_bus[bus]) {
+            case ASC_IS_ISA:
+            case ASC_IS_VL:
+#ifdef CONFIG_ISA
+                if (asc_iopflag == ASC_FALSE) {
+                    iop = AscSearchIOPortAddr(iop, asc_bus[bus]);
+                } else {
+                    /*
+                     * ISA and VL I/O port scanning has either been
+                     * eliminated or limited to selected ports on
+                     * the LILO command line, /etc/lilo.conf, or
+                     * by setting variables when the module was loaded.
+                     */
+                    ASC_DBG(1, "advansys_detect: I/O port scanning modified\n");
+                ioport_try_again:
+                    iop = 0;
+                    for (; ioport < ASC_NUM_IOPORT_PROBE; ioport++) {
+                        if ((iop = asc_ioport[ioport]) != 0) {
+                            break;
+                        }
+                    }
+                    if (iop) {
+                        ASC_DBG1(1,
+                                "advansys_detect: probing I/O port 0x%x...\n",
+                            iop);
+                        if (check_region(iop, ASC_IOADR_GAP) != 0) {
+                            printk(
+"AdvanSys SCSI: specified I/O Port 0x%X is busy\n", iop);
+                            /* Don't try this I/O port twice. */
+                            asc_ioport[ioport] = 0;
+                            goto ioport_try_again;
+                        } else if (AscFindSignature(iop) == ASC_FALSE) {
+                            printk(
+"AdvanSys SCSI: specified I/O Port 0x%X has no adapter\n", iop);
+                            /* Don't try this I/O port twice. */
+                            asc_ioport[ioport] = 0;
+                            goto ioport_try_again;
+                        } else {
+                            /*
+                             * If this isn't an ISA board, then it must be
+                             * a VL board. If currently looking an ISA
+                             * board is being looked for then try for
+                             * another ISA board in 'asc_ioport'.
+                             */
+                            if (asc_bus[bus] == ASC_IS_ISA &&
+                                (AscGetChipVersion(iop, ASC_IS_ISA) &
+                                 ASC_CHIP_VER_ISA_BIT) == 0) {
+                                 /*
+                                  * Don't clear 'asc_ioport[ioport]'. Try
+                                  * this board again for VL. Increment
+                                  * 'ioport' past this board.
+                                  */
+                                 ioport++;
+                                 goto ioport_try_again;
+                            }
+                        }
+                        /*
+                         * This board appears good, don't try the I/O port
+                         * again by clearing its value. Increment 'ioport'
+                         * for the next iteration.
+                         */
+                        asc_ioport[ioport++] = 0;
+                    }
+                }
+#endif /* CONFIG_ISA */
+                break;
+
+            case ASC_IS_EISA:
+#ifdef CONFIG_ISA
+                iop = AscSearchIOPortAddr(iop, asc_bus[bus]);
+#endif /* CONFIG_ISA */
+                break;
+
+            case ASC_IS_PCI:
+#ifdef CONFIG_PCI
+                if (pci_init_search == 0) {
+                    int i, j;
+
+                    pci_init_search = 1;
+
+                    /* Find all PCI cards. */
+                    while (pci_device_id_cnt < ASC_PCI_DEVICE_ID_CNT) {
+                        if ((pci_devp = pci_find_device(ASC_PCI_VENDORID,
+                            pci_device_id[pci_device_id_cnt], pci_devp)) ==
+                            NULL) {
+                            pci_device_id_cnt++;
+                        } else {
+                            if (pci_enable_device(pci_devp) == 0) {
+                                pci_devicep[pci_card_cnt_max++] = pci_devp;
+                            }
+                        }
+                    }
+
+                    /*
+                     * Sort PCI cards in ascending order by PCI Bus, Slot,
+                     * and Device Number.
+                     */
+                    for (i = 0; i < pci_card_cnt_max - 1; i++)
+                    {
+                        for (j = i + 1; j < pci_card_cnt_max; j++) {
+                            if ((pci_devicep[j]->bus->number <
+                                 pci_devicep[i]->bus->number) ||
+                                ((pci_devicep[j]->bus->number ==
+                                  pci_devicep[i]->bus->number) &&
+                                  (pci_devicep[j]->devfn <
+                                   pci_devicep[i]->devfn))) {
+                                pci_devp = pci_devicep[i];
+                                pci_devicep[i] = pci_devicep[j];
+                                pci_devicep[j] = pci_devp;
+                            }
+                        }
+                    }
+
+                    pci_card_cnt = 0;
+                } else {
+                    pci_card_cnt++;
+                }
+
+                if (pci_card_cnt == pci_card_cnt_max) {
+                    iop = 0;
+                } else {
+                    pci_devp = pci_devicep[pci_card_cnt];
+
+                    ASC_DBG2(2,
+                        "advansys_detect: devfn %d, bus number %d\n",
+                        pci_devp->devfn, pci_devp->bus->number);
+                    iop = pci_resource_start(pci_devp, 0);
+                    ASC_DBG2(1,
+                        "advansys_detect: vendorID %X, deviceID %X\n",
+                        pci_devp->vendor, pci_devp->device);
+                    ASC_DBG2(2, "advansys_detect: iop %X, irqLine %d\n",
+                        iop, pci_devp->irq);
+                }
+		if(pci_devp)
+		    dev = &pci_devp->dev;
+
+#endif /* CONFIG_PCI */
+                break;
+
+            default:
+                ASC_PRINT1("advansys_detect: unknown bus type: %d\n",
+                    asc_bus[bus]);
+                break;
+            }
+            ASC_DBG1(1, "advansys_detect: iop 0x%x\n", iop);
+
+            /*
+             * Adapter not found, try next bus type.
+             */
+            if (iop == 0) {
+                break;
+            }
+
+            /*
+             * Adapter found.
+             *
+             * Register the adapter, get its configuration, and
+             * initialize it.
+             */
+            ASC_DBG(2, "advansys_detect: scsi_register()\n");
+            shp = scsi_register(tpnt, sizeof(asc_board_t));
+
+            if (shp == NULL) {
+                continue;
+            }
+
+	    scsi_set_device(shp, dev);
+
+            /* Save a pointer to the Scsi_Host of each board found. */
+            asc_host[asc_board_count++] = shp;
+
+            /* Initialize private per board data */
+            boardp = ASC_BOARDP(shp);
+            memset(boardp, 0, sizeof(asc_board_t));
+            boardp->id = asc_board_count - 1;
+
+            /* Initialize spinlock. */
+            spin_lock_init(&boardp->lock);
+
+            /*
+             * Handle both narrow and wide boards.
+             *
+             * If a Wide board was detected, set the board structure
+             * wide board flag. Set-up the board structure based on
+             * the board type.
+             */
+#ifdef CONFIG_PCI
+            if (asc_bus[bus] == ASC_IS_PCI &&
+                (pci_devp->device == ASC_PCI_DEVICE_ID_2300 ||
+                 pci_devp->device == ASC_PCI_DEVICE_ID_2500 ||
+                 pci_devp->device == ASC_PCI_DEVICE_ID_2700))
+            {
+                boardp->flags |= ASC_IS_WIDE_BOARD;
+            }
+#endif /* CONFIG_PCI */
+
+            if (ASC_NARROW_BOARD(boardp)) {
+                ASC_DBG(1, "advansys_detect: narrow board\n");
+                asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+                asc_dvc_varp->bus_type = asc_bus[bus];
+                asc_dvc_varp->drv_ptr = boardp;
+                asc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;
+                asc_dvc_varp->cfg->overrun_buf = &overrun_buf[0];
+                asc_dvc_varp->iop_base = iop;
+                asc_dvc_varp->isr_callback = asc_isr_callback;
+            } else {
+                ASC_DBG(1, "advansys_detect: wide board\n");
+                adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+                adv_dvc_varp->drv_ptr = boardp;
+                adv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;
+                adv_dvc_varp->isr_callback = adv_isr_callback;
+                adv_dvc_varp->async_callback = adv_async_callback;
+#ifdef CONFIG_PCI
+                if (pci_devp->device == ASC_PCI_DEVICE_ID_2300)
+                {
+                    ASC_DBG(1, "advansys_detect: ASC-3550\n");
+                    adv_dvc_varp->chip_type = ADV_CHIP_ASC3550;
+                } else if (pci_devp->device == ASC_PCI_DEVICE_ID_2500)
+                {
+                    ASC_DBG(1, "advansys_detect: ASC-38C0800\n");
+                    adv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;
+                } else
+                {
+                    ASC_DBG(1, "advansys_detect: ASC-38C1600\n");
+                    adv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;
+                }
+#endif /* CONFIG_PCI */
+
+                /*
+                 * Map the board's registers into virtual memory for
+                 * PCI slave access. Only memory accesses are used to
+                 * access the board's registers.
+                 *
+                 * Note: The PCI register base address is not always
+                 * page aligned, but the address passed to ioremap()
+                 * must be page aligned. It is guaranteed that the
+                 * PCI register base address will not cross a page
+                 * boundary.
+                 */
+                if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+                {
+                    iolen = ADV_3550_IOLEN;
+                } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+                {
+                    iolen = ADV_38C0800_IOLEN;
+                } else
+                {
+                    iolen = ADV_38C1600_IOLEN;
+                }
+#ifdef CONFIG_PCI
+                pci_memory_address = pci_resource_start(pci_devp, 1);
+                ASC_DBG1(1, "advansys_detect: pci_memory_address: 0x%lx\n",
+                    (ulong) pci_memory_address);
+                if ((boardp->ioremap_addr =
+                    ioremap(pci_memory_address & PAGE_MASK,
+                         PAGE_SIZE)) == 0) {
+                   ASC_PRINT3(
+"advansys_detect: board %d: ioremap(%x, %d) returned NULL\n",
+                       boardp->id, pci_memory_address, iolen);
+                   scsi_unregister(shp);
+                   asc_board_count--;
+                   continue;
+                }
+                ASC_DBG1(1, "advansys_detect: ioremap_addr: 0x%lx\n",
+                    (ulong) boardp->ioremap_addr);
+                adv_dvc_varp->iop_base = (AdvPortAddr)
+                    (boardp->ioremap_addr +
+                     (pci_memory_address - (pci_memory_address & PAGE_MASK)));
+                ASC_DBG1(1, "advansys_detect: iop_base: 0x%lx\n",
+                    adv_dvc_varp->iop_base);
+#endif /* CONFIG_PCI */
+
+                /*
+                 * Even though it isn't used to access wide boards, other
+                 * than for the debug line below, save I/O Port address so
+                 * that it can be reported.
+                 */
+                boardp->ioport = iop;
+
+                ASC_DBG2(1,
+"advansys_detect: iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\n",
+                    (ushort) inp(iop + 1), (ushort) inpw(iop));
+            }
+
+#ifdef CONFIG_PROC_FS
+            /*
+             * Allocate buffer for printing information from
+             * /proc/scsi/advansys/[0...].
+             */
+            if ((boardp->prtbuf =
+                kmalloc(ASC_PRTBUF_SIZE, GFP_ATOMIC)) == NULL) {
+                ASC_PRINT3(
+"advansys_detect: board %d: kmalloc(%d, %d) returned NULL\n",
+                    boardp->id, ASC_PRTBUF_SIZE, GFP_ATOMIC);
+                scsi_unregister(shp);
+                asc_board_count--;
+                continue;
+            }
+#endif /* CONFIG_PROC_FS */
+
+            if (ASC_NARROW_BOARD(boardp)) {
+		asc_dvc_varp->cfg->dev = dev;
+		/*
+                 * Set the board bus type and PCI IRQ before
+                 * calling AscInitGetConfig().
+                 */
+                switch (asc_dvc_varp->bus_type) {
+#ifdef CONFIG_ISA
+                case ASC_IS_ISA:
+                    shp->unchecked_isa_dma = TRUE;
+                    share_irq = FALSE;
+                    break;
+                case ASC_IS_VL:
+                    shp->unchecked_isa_dma = FALSE;
+                    share_irq = FALSE;
+                    break;
+                case ASC_IS_EISA:
+                    shp->unchecked_isa_dma = FALSE;
+                    share_irq = TRUE;
+                    break;
+#endif /* CONFIG_ISA */
+#ifdef CONFIG_PCI
+                case ASC_IS_PCI:
+                    shp->irq = asc_dvc_varp->irq_no = pci_devp->irq;
+                    asc_dvc_varp->cfg->pci_slot_info =
+                        ASC_PCI_MKID(pci_devp->bus->number,
+                            PCI_SLOT(pci_devp->devfn),
+                            PCI_FUNC(pci_devp->devfn));
+                    shp->unchecked_isa_dma = FALSE;
+                    share_irq = TRUE;
+                    break;
+#endif /* CONFIG_PCI */
+                default:
+                    ASC_PRINT2(
+"advansys_detect: board %d: unknown adapter type: %d\n",
+                        boardp->id, asc_dvc_varp->bus_type);
+                    shp->unchecked_isa_dma = TRUE;
+                    share_irq = FALSE;
+                    break;
+                }
+            } else {
+                adv_dvc_varp->cfg->dev = dev;
+                /*
+                 * For Wide boards set PCI information before calling
+                 * AdvInitGetConfig().
+                 */
+#ifdef CONFIG_PCI
+                shp->irq = adv_dvc_varp->irq_no = pci_devp->irq;
+                adv_dvc_varp->cfg->pci_slot_info =
+                    ASC_PCI_MKID(pci_devp->bus->number,
+                        PCI_SLOT(pci_devp->devfn),
+                        PCI_FUNC(pci_devp->devfn));
+                shp->unchecked_isa_dma = FALSE;
+                share_irq = TRUE;
+#endif /* CONFIG_PCI */
+            }
+
+            /*
+             * Read the board configuration.
+             */
+            if (ASC_NARROW_BOARD(boardp)) {
+                 /*
+                  * NOTE: AscInitGetConfig() may change the board's
+                  * bus_type value. The asc_bus[bus] value should no
+                  * longer be used. If the bus_type field must be
+                  * referenced only use the bit-wise AND operator "&".
+                  */
+                ASC_DBG(2, "advansys_detect: AscInitGetConfig()\n");
+                switch(ret = AscInitGetConfig(asc_dvc_varp)) {
+                case 0:    /* No error */
+                    break;
+                case ASC_WARN_IO_PORT_ROTATE:
+                    ASC_PRINT1(
+"AscInitGetConfig: board %d: I/O port address modified\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_AUTO_CONFIG:
+                    ASC_PRINT1(
+"AscInitGetConfig: board %d: I/O port increment switch enabled\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_EEPROM_CHKSUM:
+                    ASC_PRINT1(
+"AscInitGetConfig: board %d: EEPROM checksum error\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_IRQ_MODIFIED:
+                    ASC_PRINT1(
+"AscInitGetConfig: board %d: IRQ modified\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_CMD_QNG_CONFLICT:
+                    ASC_PRINT1(
+"AscInitGetConfig: board %d: tag queuing enabled w/o disconnects\n",
+                        boardp->id);
+                    break;
+                default:
+                    ASC_PRINT2(
+"AscInitGetConfig: board %d: unknown warning: 0x%x\n",
+                        boardp->id, ret);
+                    break;
+                }
+                if ((err_code = asc_dvc_varp->err_code) != 0) {
+                    ASC_PRINT3(
+"AscInitGetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
+                        boardp->id, asc_dvc_varp->init_state,
+                        asc_dvc_varp->err_code);
+                }
+            } else {
+                ASC_DBG(2, "advansys_detect: AdvInitGetConfig()\n");
+                if ((ret = AdvInitGetConfig(adv_dvc_varp)) != 0) {
+                    ASC_PRINT2("AdvInitGetConfig: board %d: warning: 0x%x\n",
+                        boardp->id, ret);
+                }
+                if ((err_code = adv_dvc_varp->err_code) != 0) {
+                    ASC_PRINT2(
+"AdvInitGetConfig: board %d error: err_code 0x%x\n",
+                        boardp->id, adv_dvc_varp->err_code);
+                }
+            }
+
+            if (err_code != 0) {
+#ifdef CONFIG_PROC_FS
+                kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+                scsi_unregister(shp);
+                asc_board_count--;
+                continue;
+            }
+
+            /*
+             * Save the EEPROM configuration so that it can be displayed
+             * from /proc/scsi/advansys/[0...].
+             */
+            if (ASC_NARROW_BOARD(boardp)) {
+
+                ASCEEP_CONFIG *ep;
+
+                /*
+                 * Set the adapter's target id bit in the 'init_tidmask' field.
+                 */
+                boardp->init_tidmask |=
+                    ADV_TID_TO_TIDMASK(asc_dvc_varp->cfg->chip_scsi_id);
+
+                /*
+                 * Save EEPROM settings for the board.
+                 */
+                ep = &boardp->eep_config.asc_eep;
+
+                ep->init_sdtr = asc_dvc_varp->cfg->sdtr_enable;
+                ep->disc_enable = asc_dvc_varp->cfg->disc_enable;
+                ep->use_cmd_qng = asc_dvc_varp->cfg->cmd_qng_enabled;
+                ASC_EEP_SET_DMA_SPD(ep, asc_dvc_varp->cfg->isa_dma_speed);
+                ep->start_motor = asc_dvc_varp->start_motor;
+                ep->cntl = asc_dvc_varp->dvc_cntl;
+                ep->no_scam = asc_dvc_varp->no_scam;
+                ep->max_total_qng = asc_dvc_varp->max_total_qng;
+                ASC_EEP_SET_CHIP_ID(ep, asc_dvc_varp->cfg->chip_scsi_id);
+                /* 'max_tag_qng' is set to the same value for every device. */
+                ep->max_tag_qng = asc_dvc_varp->cfg->max_tag_qng[0];
+                ep->adapter_info[0] = asc_dvc_varp->cfg->adapter_info[0];
+                ep->adapter_info[1] = asc_dvc_varp->cfg->adapter_info[1];
+                ep->adapter_info[2] = asc_dvc_varp->cfg->adapter_info[2];
+                ep->adapter_info[3] = asc_dvc_varp->cfg->adapter_info[3];
+                ep->adapter_info[4] = asc_dvc_varp->cfg->adapter_info[4];
+                ep->adapter_info[5] = asc_dvc_varp->cfg->adapter_info[5];
+
+               /*
+                * Modify board configuration.
+                */
+                ASC_DBG(2, "advansys_detect: AscInitSetConfig()\n");
+                switch (ret = AscInitSetConfig(asc_dvc_varp)) {
+                case 0:    /* No error. */
+                    break;
+                case ASC_WARN_IO_PORT_ROTATE:
+                    ASC_PRINT1(
+"AscInitSetConfig: board %d: I/O port address modified\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_AUTO_CONFIG:
+                    ASC_PRINT1(
+"AscInitSetConfig: board %d: I/O port increment switch enabled\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_EEPROM_CHKSUM:
+                    ASC_PRINT1(
+"AscInitSetConfig: board %d: EEPROM checksum error\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_IRQ_MODIFIED:
+                    ASC_PRINT1(
+"AscInitSetConfig: board %d: IRQ modified\n",
+                        boardp->id);
+                    break;
+                case ASC_WARN_CMD_QNG_CONFLICT:
+                    ASC_PRINT1(
+"AscInitSetConfig: board %d: tag queuing w/o disconnects\n",
+                        boardp->id);
+                    break;
+                default:
+                    ASC_PRINT2(
+"AscInitSetConfig: board %d: unknown warning: 0x%x\n",
+                        boardp->id, ret);
+                    break;
+                }
+                if (asc_dvc_varp->err_code != 0) {
+                    ASC_PRINT3(
+"AscInitSetConfig: board %d error: init_state 0x%x, err_code 0x%x\n",
+                        boardp->id, asc_dvc_varp->init_state,
+                        asc_dvc_varp->err_code);
+#ifdef CONFIG_PROC_FS
+                    kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+                    scsi_unregister(shp);
+                    asc_board_count--;
+                    continue;
+                }
+
+                /*
+                 * Finish initializing the 'Scsi_Host' structure.
+                 */
+                /* AscInitSetConfig() will set the IRQ for non-PCI boards. */
+                if ((asc_dvc_varp->bus_type & ASC_IS_PCI) == 0) {
+                    shp->irq = asc_dvc_varp->irq_no;
+                }
+            } else {
+                ADVEEP_3550_CONFIG      *ep_3550;
+                ADVEEP_38C0800_CONFIG   *ep_38C0800;
+                ADVEEP_38C1600_CONFIG   *ep_38C1600;
+
+                /*
+                 * Save Wide EEP Configuration Information.
+                 */
+                if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+                {
+                    ep_3550 = &boardp->eep_config.adv_3550_eep;
+
+                    ep_3550->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
+                    ep_3550->max_host_qng = adv_dvc_varp->max_host_qng;
+                    ep_3550->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
+                    ep_3550->termination = adv_dvc_varp->cfg->termination;
+                    ep_3550->disc_enable = adv_dvc_varp->cfg->disc_enable;
+                    ep_3550->bios_ctrl = adv_dvc_varp->bios_ctrl;
+                    ep_3550->wdtr_able = adv_dvc_varp->wdtr_able;
+                    ep_3550->sdtr_able = adv_dvc_varp->sdtr_able;
+                    ep_3550->ultra_able = adv_dvc_varp->ultra_able;
+                    ep_3550->tagqng_able = adv_dvc_varp->tagqng_able;
+                    ep_3550->start_motor = adv_dvc_varp->start_motor;
+                    ep_3550->scsi_reset_delay = adv_dvc_varp->scsi_reset_wait;
+                    ep_3550->serial_number_word1 =
+                        adv_dvc_varp->cfg->serial1;
+                    ep_3550->serial_number_word2 =
+                        adv_dvc_varp->cfg->serial2;
+                    ep_3550->serial_number_word3 =
+                        adv_dvc_varp->cfg->serial3;
+                } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+                {
+                    ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
+
+                    ep_38C0800->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
+                    ep_38C0800->max_host_qng = adv_dvc_varp->max_host_qng;
+                    ep_38C0800->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
+                    ep_38C0800->termination_lvd =
+                        adv_dvc_varp->cfg->termination;
+                    ep_38C0800->disc_enable = adv_dvc_varp->cfg->disc_enable;
+                    ep_38C0800->bios_ctrl = adv_dvc_varp->bios_ctrl;
+                    ep_38C0800->wdtr_able = adv_dvc_varp->wdtr_able;
+                    ep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;
+                    ep_38C0800->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;
+                    ep_38C0800->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;
+                    ep_38C0800->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;
+                    ep_38C0800->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;
+                    ep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;
+                    ep_38C0800->start_motor = adv_dvc_varp->start_motor;
+                    ep_38C0800->scsi_reset_delay =
+                        adv_dvc_varp->scsi_reset_wait;
+                    ep_38C0800->serial_number_word1 =
+                        adv_dvc_varp->cfg->serial1;
+                    ep_38C0800->serial_number_word2 =
+                        adv_dvc_varp->cfg->serial2;
+                    ep_38C0800->serial_number_word3 =
+                        adv_dvc_varp->cfg->serial3;
+                } else
+                {
+                    ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
+
+                    ep_38C1600->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;
+                    ep_38C1600->max_host_qng = adv_dvc_varp->max_host_qng;
+                    ep_38C1600->max_dvc_qng = adv_dvc_varp->max_dvc_qng;
+                    ep_38C1600->termination_lvd =
+                        adv_dvc_varp->cfg->termination;
+                    ep_38C1600->disc_enable = adv_dvc_varp->cfg->disc_enable;
+                    ep_38C1600->bios_ctrl = adv_dvc_varp->bios_ctrl;
+                    ep_38C1600->wdtr_able = adv_dvc_varp->wdtr_able;
+                    ep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;
+                    ep_38C1600->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;
+                    ep_38C1600->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;
+                    ep_38C1600->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;
+                    ep_38C1600->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;
+                    ep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;
+                    ep_38C1600->start_motor = adv_dvc_varp->start_motor;
+                    ep_38C1600->scsi_reset_delay =
+                        adv_dvc_varp->scsi_reset_wait;
+                    ep_38C1600->serial_number_word1 =
+                        adv_dvc_varp->cfg->serial1;
+                    ep_38C1600->serial_number_word2 =
+                        adv_dvc_varp->cfg->serial2;
+                    ep_38C1600->serial_number_word3 =
+                        adv_dvc_varp->cfg->serial3;
+                }
+
+                /*
+                 * Set the adapter's target id bit in the 'init_tidmask' field.
+                 */
+                boardp->init_tidmask |=
+                    ADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);
+
+                /*
+                 * Finish initializing the 'Scsi_Host' structure.
+                 */
+                shp->irq = adv_dvc_varp->irq_no;
+            }
+
+            /*
+             * Channels are numbered beginning with 0. For AdvanSys one host
+             * structure supports one channel. Multi-channel boards have a
+             * separate host structure for each channel.
+             */
+            shp->max_channel = 0;
+            if (ASC_NARROW_BOARD(boardp)) {
+                shp->max_id = ASC_MAX_TID + 1;
+                shp->max_lun = ASC_MAX_LUN + 1;
+
+                shp->io_port = asc_dvc_varp->iop_base;
+                boardp->asc_n_io_port = ASC_IOADR_GAP;
+                shp->this_id = asc_dvc_varp->cfg->chip_scsi_id;
+
+                /* Set maximum number of queues the adapter can handle. */
+                shp->can_queue = asc_dvc_varp->max_total_qng;
+            } else {
+                shp->max_id = ADV_MAX_TID + 1;
+                shp->max_lun = ADV_MAX_LUN + 1;
+
+                /*
+                 * Save the I/O Port address and length even though
+                 * I/O ports are not used to access Wide boards.
+                 * Instead the Wide boards are accessed with
+                 * PCI Memory Mapped I/O.
+                 */
+                shp->io_port = iop;
+                boardp->asc_n_io_port = iolen;
+
+                shp->this_id = adv_dvc_varp->chip_scsi_id;
+
+                /* Set maximum number of queues the adapter can handle. */
+                shp->can_queue = adv_dvc_varp->max_host_qng;
+            }
+
+            /*
+             * 'n_io_port' currently is one byte.
+             *
+             * Set a value to 'n_io_port', but never referenced it because
+             * it may be truncated.
+             */
+            shp->n_io_port = boardp->asc_n_io_port <= 255 ?
+                boardp->asc_n_io_port : 255;
+
+            /*
+             * Following v1.3.89, 'cmd_per_lun' is no longer needed
+             * and should be set to zero.
+             *
+             * But because of a bug introduced in v1.3.89 if the driver is
+             * compiled as a module and 'cmd_per_lun' is zero, the Mid-Level
+             * SCSI function 'allocate_device' will panic. To allow the driver
+             * to work as a module in these kernels set 'cmd_per_lun' to 1.
+	     *
+	     * Note: This is wrong.  cmd_per_lun should be set to the depth
+	     * you want on untagged devices always.
+#ifdef MODULE
+             */
+            shp->cmd_per_lun = 1;
+/* #else
+            shp->cmd_per_lun = 0;
+#endif */
+
+            /*
+             * Set the maximum number of scatter-gather elements the
+             * adapter can handle.
+             */
+            if (ASC_NARROW_BOARD(boardp)) {
+                /*
+                 * Allow two commands with 'sg_tablesize' scatter-gather
+                 * elements to be executed simultaneously. This value is
+                 * the theoretical hardware limit. It may be decreased
+                 * below.
+                 */
+                shp->sg_tablesize =
+                    (((asc_dvc_varp->max_total_qng - 2) / 2) *
+                    ASC_SG_LIST_PER_Q) + 1;
+            } else {
+                shp->sg_tablesize = ADV_MAX_SG_LIST;
+            }
+
+            /*
+             * The value of 'sg_tablesize' can not exceed the SCSI
+             * mid-level driver definition of SG_ALL. SG_ALL also
+             * must not be exceeded, because it is used to define the
+             * size of the scatter-gather table in 'struct asc_sg_head'.
+             */
+            if (shp->sg_tablesize > SG_ALL) {
+                shp->sg_tablesize = SG_ALL;
+            }
+
+            ASC_DBG1(1, "advansys_detect: sg_tablesize: %d\n",
+                shp->sg_tablesize);
+
+            /* BIOS start address. */
+            if (ASC_NARROW_BOARD(boardp)) {
+                shp->base =
+                        ((ulong) AscGetChipBiosAddress(
+                            asc_dvc_varp->iop_base,
+                            asc_dvc_varp->bus_type));
+            } else {
+                /*
+                 * Fill-in BIOS board variables. The Wide BIOS saves
+                 * information in LRAM that is used by the driver.
+                 */
+                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_SIGNATURE,
+                    boardp->bios_signature);
+                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_VERSION,
+                    boardp->bios_version);
+                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_CODESEG,
+                    boardp->bios_codeseg);
+                AdvReadWordLram(adv_dvc_varp->iop_base, BIOS_CODELEN,
+                    boardp->bios_codelen);
+
+                ASC_DBG2(1,
+                    "advansys_detect: bios_signature 0x%x, bios_version 0x%x\n",
+                    boardp->bios_signature, boardp->bios_version);
+
+                ASC_DBG2(1,
+                    "advansys_detect: bios_codeseg 0x%x, bios_codelen 0x%x\n",
+                    boardp->bios_codeseg, boardp->bios_codelen);
+
+                /*
+                 * If the BIOS saved a valid signature, then fill in
+                 * the BIOS code segment base address.
+                 */
+                if (boardp->bios_signature == 0x55AA) {
+                    /*
+                     * Convert x86 realmode code segment to a linear
+                     * address by shifting left 4.
+                     */
+                    shp->base = ((ulong) boardp->bios_codeseg << 4);
+                } else {
+                    shp->base = 0;
+                }
+            }
+
+            /*
+             * Register Board Resources - I/O Port, DMA, IRQ
+             */
+
+            /*
+             * Register I/O port range.
+             *
+             * For Wide boards the I/O ports are not used to access
+             * the board, but request the region anyway.
+             *
+             * 'shp->n_io_port' is not referenced, because it may be truncated.
+             */
+            ASC_DBG2(2,
+                "advansys_detect: request_region port 0x%lx, len 0x%x\n",
+                (ulong) shp->io_port, boardp->asc_n_io_port);
+            if (request_region(shp->io_port, boardp->asc_n_io_port,
+                               "advansys") == NULL) {
+                ASC_PRINT3(
+"advansys_detect: board %d: request_region() failed, port 0x%lx, len 0x%x\n",
+                    boardp->id, (ulong) shp->io_port, boardp->asc_n_io_port);
+#ifdef CONFIG_PROC_FS
+                kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+                scsi_unregister(shp);
+                asc_board_count--;
+                continue;
+            }
+
+            /* Register DMA Channel for Narrow boards. */
+            shp->dma_channel = NO_ISA_DMA; /* Default to no ISA DMA. */
+#ifdef CONFIG_ISA
+            if (ASC_NARROW_BOARD(boardp)) {
+                /* Register DMA channel for ISA bus. */
+                if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+                    shp->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;
+                    if ((ret =
+                         request_dma(shp->dma_channel, "advansys")) != 0) {
+                        ASC_PRINT3(
+"advansys_detect: board %d: request_dma() %d failed %d\n",
+                            boardp->id, shp->dma_channel, ret);
+                        release_region(shp->io_port, boardp->asc_n_io_port);
+#ifdef CONFIG_PROC_FS
+                        kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+                        scsi_unregister(shp);
+                        asc_board_count--;
+                        continue;
+                    }
+                    AscEnableIsaDma(shp->dma_channel);
+                }
+            }
+#endif /* CONFIG_ISA */
+
+            /* Register IRQ Number. */
+            ASC_DBG1(2, "advansys_detect: request_irq() %d\n", shp->irq);
+           /*
+            * If request_irq() fails with the SA_INTERRUPT flag set,
+            * then try again without the SA_INTERRUPT flag set. This
+            * allows IRQ sharing to work even with other drivers that
+            * do not set the SA_INTERRUPT flag.
+            *
+            * If SA_INTERRUPT is not set, then interrupts are enabled
+            * before the driver interrupt function is called.
+            */
+            if (((ret = request_irq(shp->irq, advansys_interrupt,
+                            SA_INTERRUPT | (share_irq == TRUE ? SA_SHIRQ : 0),
+                            "advansys", boardp)) != 0) &&
+                ((ret = request_irq(shp->irq, advansys_interrupt,
+                            (share_irq == TRUE ? SA_SHIRQ : 0),
+                            "advansys", boardp)) != 0))
+            {
+                if (ret == -EBUSY) {
+                    ASC_PRINT2(
+"advansys_detect: board %d: request_irq(): IRQ 0x%x already in use.\n",
+                        boardp->id, shp->irq);
+                } else if (ret == -EINVAL) {
+                    ASC_PRINT2(
+"advansys_detect: board %d: request_irq(): IRQ 0x%x not valid.\n",
+                        boardp->id, shp->irq);
+                } else {
+                    ASC_PRINT3(
+"advansys_detect: board %d: request_irq(): IRQ 0x%x failed with %d\n",
+                        boardp->id, shp->irq, ret);
+                }
+                release_region(shp->io_port, boardp->asc_n_io_port);
+                iounmap(boardp->ioremap_addr);
+                if (shp->dma_channel != NO_ISA_DMA) {
+                    free_dma(shp->dma_channel);
+                }
+#ifdef CONFIG_PROC_FS
+                kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+                scsi_unregister(shp);
+                asc_board_count--;
+                continue;
+            }
+
+            /*
+             * Initialize board RISC chip and enable interrupts.
+             */
+            if (ASC_NARROW_BOARD(boardp)) {
+                ASC_DBG(2, "advansys_detect: AscInitAsc1000Driver()\n");
+                warn_code = AscInitAsc1000Driver(asc_dvc_varp);
+                err_code = asc_dvc_varp->err_code;
+
+                if (warn_code || err_code) {
+                    ASC_PRINT4(
+"advansys_detect: board %d error: init_state 0x%x, warn 0x%x, error 0x%x\n",
+                        boardp->id, asc_dvc_varp->init_state,
+                        warn_code, err_code);
+                }
+            } else {
+                ADV_CARR_T      *carrp;
+                int             req_cnt = 0;
+                adv_req_t       *reqp = NULL;
+                int             sg_cnt = 0;
+
+                /*
+                 * Allocate buffer carrier structures. The total size
+                 * is about 4 KB, so allocate all at once.
+                 */
+                carrp =
+                    (ADV_CARR_T *) kmalloc(ADV_CARRIER_BUFSIZE, GFP_ATOMIC);
+                ASC_DBG1(1, "advansys_detect: carrp 0x%lx\n", (ulong) carrp);
+
+                if (carrp == NULL) {
+                    goto kmalloc_error;
+                }
+
+                /*
+                 * Allocate up to 'max_host_qng' request structures for
+                 * the Wide board. The total size is about 16 KB, so
+                 * allocate all at once. If the allocation fails decrement
+                 * and try again.
+                 */
+                for (req_cnt = adv_dvc_varp->max_host_qng;
+                    req_cnt > 0; req_cnt--) {
+
+                    reqp = (adv_req_t *)
+                        kmalloc(sizeof(adv_req_t) * req_cnt, GFP_ATOMIC);
+
+                    ASC_DBG3(1,
+                        "advansys_detect: reqp 0x%lx, req_cnt %d, bytes %lu\n",
+                        (ulong) reqp, req_cnt,
+                        (ulong) sizeof(adv_req_t) * req_cnt);
+
+                    if (reqp != NULL) {
+                        break;
+                    }
+                }
+                if (reqp == NULL)
+                {
+                    goto kmalloc_error;
+                }
+
+                /*
+                 * Allocate up to ADV_TOT_SG_BLOCK request structures for
+                 * the Wide board. Each structure is about 136 bytes.
+                 */
+                boardp->adv_sgblkp = NULL;
+                for (sg_cnt = 0; sg_cnt < ADV_TOT_SG_BLOCK; sg_cnt++) {
+
+                    sgp = (adv_sgblk_t *)
+                        kmalloc(sizeof(adv_sgblk_t), GFP_ATOMIC);
+
+                    if (sgp == NULL) {
+                        break;
+                    }
+
+                    sgp->next_sgblkp = boardp->adv_sgblkp;
+                    boardp->adv_sgblkp = sgp;
+
+                }
+                ASC_DBG3(1,
+                    "advansys_detect: sg_cnt %d * %u = %u bytes\n",
+                    sg_cnt, sizeof(adv_sgblk_t),
+                    (unsigned) (sizeof(adv_sgblk_t) * sg_cnt));
+
+                /*
+                 * If no request structures or scatter-gather structures could
+                 * be allocated, then return an error. Otherwise continue with
+                 * initialization.
+                 */
+    kmalloc_error:
+                if (carrp == NULL)
+                {
+                    ASC_PRINT1(
+"advansys_detect: board %d error: failed to kmalloc() carrier buffer.\n",
+                        boardp->id);
+                    err_code = ADV_ERROR;
+                } else if (reqp == NULL) {
+                    kfree(carrp);
+                    ASC_PRINT1(
+"advansys_detect: board %d error: failed to kmalloc() adv_req_t buffer.\n",
+                        boardp->id);
+                    err_code = ADV_ERROR;
+                } else if (boardp->adv_sgblkp == NULL) {
+                    kfree(carrp);
+                    kfree(reqp);
+                    ASC_PRINT1(
+"advansys_detect: board %d error: failed to kmalloc() adv_sgblk_t buffers.\n",
+                        boardp->id);
+                    err_code = ADV_ERROR;
+                } else {
+
+                    /* Save carrier buffer pointer. */
+                    boardp->orig_carrp = carrp;
+
+                    /*
+                     * Save original pointer for kfree() in case the
+                     * driver is built as a module and can be unloaded.
+                     */
+                    boardp->orig_reqp = reqp;
+
+                    adv_dvc_varp->carrier_buf = carrp;
+
+                    /*
+                     * Point 'adv_reqp' to the request structures and
+                     * link them together.
+                     */
+                    req_cnt--;
+                    reqp[req_cnt].next_reqp = NULL;
+                    for (; req_cnt > 0; req_cnt--) {
+                        reqp[req_cnt - 1].next_reqp = &reqp[req_cnt];
+                    }
+                    boardp->adv_reqp = &reqp[0];
+
+                    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+                    {
+                        ASC_DBG(2,
+                            "advansys_detect: AdvInitAsc3550Driver()\n");
+                        warn_code = AdvInitAsc3550Driver(adv_dvc_varp);
+                    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {
+                        ASC_DBG(2,
+                            "advansys_detect: AdvInitAsc38C0800Driver()\n");
+                        warn_code = AdvInitAsc38C0800Driver(adv_dvc_varp);
+                    } else {
+                        ASC_DBG(2,
+                            "advansys_detect: AdvInitAsc38C1600Driver()\n");
+                        warn_code = AdvInitAsc38C1600Driver(adv_dvc_varp);
+                    }
+                    err_code = adv_dvc_varp->err_code;
+
+                    if (warn_code || err_code) {
+                        ASC_PRINT3(
+"advansys_detect: board %d error: warn 0x%x, error 0x%x\n",
+                            boardp->id, warn_code, err_code);
+                    }
+                }
+            }
+
+            if (err_code != 0) {
+                release_region(shp->io_port, boardp->asc_n_io_port);
+                if (ASC_WIDE_BOARD(boardp)) {
+                    iounmap(boardp->ioremap_addr);
+                    if (boardp->orig_carrp) {
+                        kfree(boardp->orig_carrp);
+                        boardp->orig_carrp = NULL;
+                    }
+                    if (boardp->orig_reqp) {
+                        kfree(boardp->orig_reqp);
+                        boardp->orig_reqp = boardp->adv_reqp = NULL;
+                    }
+                    while ((sgp = boardp->adv_sgblkp) != NULL)
+                    {
+                        boardp->adv_sgblkp = sgp->next_sgblkp;
+                        kfree(sgp);
+                    }
+                }
+                if (shp->dma_channel != NO_ISA_DMA) {
+                    free_dma(shp->dma_channel);
+                }
+#ifdef CONFIG_PROC_FS
+                kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+                free_irq(shp->irq, boardp);
+                scsi_unregister(shp);
+                asc_board_count--;
+                continue;
+            }
+            ASC_DBG_PRT_SCSI_HOST(2, shp);
+        }
+    }
+
+    ASC_DBG1(1, "advansys_detect: done: asc_board_count %d\n", asc_board_count);
+    return asc_board_count;
+}
+
+/*
+ * advansys_release()
+ *
+ * Release resources allocated for a single AdvanSys adapter.
+ */
+int
+advansys_release(struct Scsi_Host *shp)
+{
+    asc_board_t    *boardp;
+
+    ASC_DBG(1, "advansys_release: begin\n");
+    boardp = ASC_BOARDP(shp);
+    free_irq(shp->irq, boardp);
+    if (shp->dma_channel != NO_ISA_DMA) {
+        ASC_DBG(1, "advansys_release: free_dma()\n");
+        free_dma(shp->dma_channel);
+    }
+    release_region(shp->io_port, boardp->asc_n_io_port);
+    if (ASC_WIDE_BOARD(boardp)) {
+        adv_sgblk_t    *sgp = NULL;
+
+        iounmap(boardp->ioremap_addr);
+        if (boardp->orig_carrp) {
+            kfree(boardp->orig_carrp);
+            boardp->orig_carrp = NULL;
+        }
+        if (boardp->orig_reqp) {
+            kfree(boardp->orig_reqp);
+            boardp->orig_reqp = boardp->adv_reqp = NULL;
+        }
+        while ((sgp = boardp->adv_sgblkp) != NULL)
+        {
+            boardp->adv_sgblkp = sgp->next_sgblkp;
+            kfree(sgp);
+        }
+    }
+#ifdef CONFIG_PROC_FS
+    ASC_ASSERT(boardp->prtbuf != NULL);
+    kfree(boardp->prtbuf);
+#endif /* CONFIG_PROC_FS */
+    scsi_unregister(shp);
+    ASC_DBG(1, "advansys_release: end\n");
+    return 0;
+}
+
+/*
+ * advansys_info()
+ *
+ * Return suitable for printing on the console with the argument
+ * adapter's configuration information.
+ *
+ * Note: The information line should not exceed ASC_INFO_SIZE bytes,
+ * otherwise the static 'info' array will be overrun.
+ */
+const char *
+advansys_info(struct Scsi_Host *shp)
+{
+    static char     info[ASC_INFO_SIZE];
+    asc_board_t     *boardp;
+    ASC_DVC_VAR     *asc_dvc_varp;
+    ADV_DVC_VAR     *adv_dvc_varp;
+    char            *busname;
+    int             iolen;
+    char            *widename = NULL;
+
+    boardp = ASC_BOARDP(shp);
+    if (ASC_NARROW_BOARD(boardp)) {
+        asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+        ASC_DBG(1, "advansys_info: begin\n");
+        if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+            if ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) == ASC_IS_ISAPNP) {
+                busname = "ISA PnP";
+            } else {
+                busname = "ISA";
+            }
+            /* Don't reference 'shp->n_io_port'; It may be truncated. */
+            sprintf(info,
+"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X",
+                ASC_VERSION, busname,
+                (ulong) shp->io_port,
+                (ulong) shp->io_port + boardp->asc_n_io_port - 1,
+                shp->irq, shp->dma_channel);
+        } else {
+            if (asc_dvc_varp->bus_type & ASC_IS_VL) {
+                busname = "VL";
+            } else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {
+                busname = "EISA";
+            } else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {
+                if ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)
+                    == ASC_IS_PCI_ULTRA) {
+                    busname = "PCI Ultra";
+                } else {
+                    busname = "PCI";
+                }
+            } else {
+                busname = "?";
+                ASC_PRINT2( "advansys_info: board %d: unknown bus type %d\n",
+                    boardp->id, asc_dvc_varp->bus_type);
+            }
+            /* Don't reference 'shp->n_io_port'; It may be truncated. */
+            sprintf(info,
+                "AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X",
+                ASC_VERSION, busname,
+                (ulong) shp->io_port,
+                (ulong) shp->io_port + boardp->asc_n_io_port - 1,
+                shp->irq);
+        }
+    } else {
+        /*
+         * Wide Adapter Information
+         *
+         * Memory-mapped I/O is used instead of I/O space to access
+         * the adapter, but display the I/O Port range. The Memory
+         * I/O address is displayed through the driver /proc file.
+         */
+        adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+        if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+        {
+            iolen = ADV_3550_IOLEN;
+            widename = "Ultra-Wide";
+        } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+        {
+            iolen = ADV_38C0800_IOLEN;
+            widename = "Ultra2-Wide";
+        } else
+        {
+            iolen = ADV_38C1600_IOLEN;
+            widename = "Ultra3-Wide";
+        }
+        sprintf(info, "AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X",
+            ASC_VERSION,
+            widename,
+            (ulong) adv_dvc_varp->iop_base,
+            (ulong) adv_dvc_varp->iop_base + iolen - 1,
+            shp->irq);
+    }
+    ASC_ASSERT(strlen(info) < ASC_INFO_SIZE);
+    ASC_DBG(1, "advansys_info: end\n");
+    return info;
+}
+
+/*
+ * advansys_queuecommand() - interrupt-driven I/O entrypoint.
+ *
+ * This function always returns 0. Command return status is saved
+ * in the 'scp' result field.
+ */
+int
+advansys_queuecommand(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))
+{
+    struct Scsi_Host    *shp;
+    asc_board_t         *boardp;
+    ulong               flags;
+    struct scsi_cmnd           *done_scp;
+
+    shp = scp->device->host;
+    boardp = ASC_BOARDP(shp);
+    ASC_STATS(shp, queuecommand);
+
+    /* host_lock taken by mid-level prior to call but need to protect */
+    /* against own ISR */
+    spin_lock_irqsave(&boardp->lock, flags);
+
+    /*
+     * Block new commands while handling a reset or abort request.
+     */
+    if (boardp->flags & ASC_HOST_IN_RESET) {
+        ASC_DBG1(1,
+            "advansys_queuecommand: scp 0x%lx blocked for reset request\n",
+            (ulong) scp);
+        scp->result = HOST_BYTE(DID_RESET);
+
+        /*
+         * Add blocked requests to the board's 'done' queue. The queued
+         * requests will be completed at the end of the abort or reset
+         * handling.
+         */
+        asc_enqueue(&boardp->done, scp, ASC_BACK);
+	spin_unlock_irqrestore(&boardp->lock, flags);
+        return 0;
+    }
+
+    /*
+     * Attempt to execute any waiting commands for the board.
+     */
+    if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
+        ASC_DBG(1,
+            "advansys_queuecommand: before asc_execute_queue() waiting\n");
+        asc_execute_queue(&boardp->waiting);
+    }
+
+    /*
+     * Save the function pointer to Linux mid-level 'done' function
+     * and attempt to execute the command.
+     *
+     * If ASC_NOERROR is returned the request has been added to the
+     * board's 'active' queue and will be completed by the interrupt
+     * handler.
+     *
+     * If ASC_BUSY is returned add the request to the board's per
+     * target waiting list. This is the first time the request has
+     * been tried. Add it to the back of the waiting list. It will be
+     * retried later.
+     *
+     * If an error occurred, the request will have been placed on the
+     * board's 'done' queue and must be completed before returning.
+     */
+    scp->scsi_done = done;
+    switch (asc_execute_scsi_cmnd(scp)) {
+    case ASC_NOERROR:
+        break;
+    case ASC_BUSY:
+        asc_enqueue(&boardp->waiting, scp, ASC_BACK);
+        break;
+    case ASC_ERROR:
+    default:
+        done_scp = asc_dequeue_list(&boardp->done, NULL, ASC_TID_ALL);
+        /* Interrupts could be enabled here. */
+        asc_scsi_done_list(done_scp);
+        break;
+    }
+    spin_unlock_irqrestore(&boardp->lock, flags);
+
+    return 0;
+}
+
+/*
+ * advansys_reset()
+ *
+ * Reset the bus associated with the command 'scp'.
+ *
+ * This function runs its own thread. Interrupts must be blocked but
+ * sleeping is allowed and no locking other than for host structures is
+ * required. Returns SUCCESS or FAILED.
+ */
+int
+advansys_reset(struct scsi_cmnd *scp)
+{
+    struct Scsi_Host     *shp;
+    asc_board_t          *boardp;
+    ASC_DVC_VAR          *asc_dvc_varp;
+    ADV_DVC_VAR          *adv_dvc_varp;
+    ulong                flags;
+    struct scsi_cmnd            *done_scp = NULL, *last_scp = NULL;
+    struct scsi_cmnd            *tscp, *new_last_scp;
+    int                  status;
+    int                  ret = SUCCESS;
+
+    ASC_DBG1(1, "advansys_reset: 0x%lx\n", (ulong) scp);
+
+#ifdef ADVANSYS_STATS
+    if (scp->device->host != NULL) {
+        ASC_STATS(scp->device->host, reset);
+    }
+#endif /* ADVANSYS_STATS */
+
+    if ((shp = scp->device->host) == NULL) {
+        scp->result = HOST_BYTE(DID_ERROR);
+        return FAILED;
+    }
+
+    boardp = ASC_BOARDP(shp);
+
+    ASC_PRINT1("advansys_reset: board %d: SCSI bus reset started...\n",
+        boardp->id);
+    /*
+     * Check for re-entrancy.
+     */
+    spin_lock_irqsave(&boardp->lock, flags);
+    if (boardp->flags & ASC_HOST_IN_RESET) {
+	spin_unlock_irqrestore(&boardp->lock, flags);
+        return FAILED;
+    }
+    boardp->flags |= ASC_HOST_IN_RESET;
+    spin_unlock_irqrestore(&boardp->lock, flags);
+
+    if (ASC_NARROW_BOARD(boardp)) {
+        /*
+         * Narrow Board
+         */
+        asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+
+        /*
+         * Reset the chip and SCSI bus.
+         */
+        ASC_DBG(1, "advansys_reset: before AscInitAsc1000Driver()\n");
+        status = AscInitAsc1000Driver(asc_dvc_varp);
+
+        /* Refer to ASC_IERR_* defintions for meaning of 'err_code'. */
+        if (asc_dvc_varp->err_code) {
+            ASC_PRINT2(
+                "advansys_reset: board %d: SCSI bus reset error: 0x%x\n",
+                boardp->id, asc_dvc_varp->err_code);
+            ret = FAILED;
+        } else if (status) {
+            ASC_PRINT2(
+                "advansys_reset: board %d: SCSI bus reset warning: 0x%x\n",
+                boardp->id, status);
+        } else {
+            ASC_PRINT1(
+                "advansys_reset: board %d: SCSI bus reset successful.\n",
+                boardp->id);
+        }
+
+        ASC_DBG(1, "advansys_reset: after AscInitAsc1000Driver()\n");
+	spin_lock_irqsave(&boardp->lock, flags);
+
+    } else {
+        /*
+         * Wide Board
+         *
+         * If the suggest reset bus flags are set, then reset the bus.
+         * Otherwise only reset the device.
+         */
+        adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+
+        /*
+         * Reset the target's SCSI bus.
+         */
+        ASC_DBG(1, "advansys_reset: before AdvResetChipAndSB()\n");
+        switch (AdvResetChipAndSB(adv_dvc_varp)) {
+        case ASC_TRUE:
+            ASC_PRINT1("advansys_reset: board %d: SCSI bus reset successful.\n",
+                boardp->id);
+            break;
+        case ASC_FALSE:
+        default:
+            ASC_PRINT1("advansys_reset: board %d: SCSI bus reset error.\n",
+                boardp->id);
+            ret = FAILED;
+            break;
+        }
+	spin_lock_irqsave(&boardp->lock, flags);
+        (void) AdvISR(adv_dvc_varp);
+    }
+    /* Board lock is held. */
+
+    /*
+     * Dequeue all board 'done' requests. A pointer to the last request
+     * is returned in 'last_scp'.
+     */
+    done_scp = asc_dequeue_list(&boardp->done, &last_scp, ASC_TID_ALL);
+
+    /*
+     * Dequeue all board 'active' requests for all devices and set
+     * the request status to DID_RESET. A pointer to the last request
+     * is returned in 'last_scp'.
+     */
+    if (done_scp == NULL) {
+        done_scp = asc_dequeue_list(&boardp->active, &last_scp, ASC_TID_ALL);
+        for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
+            tscp->result = HOST_BYTE(DID_RESET);
+        }
+    } else {
+        /* Append to 'done_scp' at the end with 'last_scp'. */
+        ASC_ASSERT(last_scp != NULL);
+        last_scp->host_scribble = (unsigned char *)asc_dequeue_list(
+			&boardp->active, &new_last_scp, ASC_TID_ALL);
+        if (new_last_scp != NULL) {
+            ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+            for (tscp = REQPNEXT(last_scp); tscp; tscp = REQPNEXT(tscp)) {
+                tscp->result = HOST_BYTE(DID_RESET);
+            }
+            last_scp = new_last_scp;
+        }
+    }
+
+    /*
+     * Dequeue all 'waiting' requests and set the request status
+     * to DID_RESET.
+     */
+    if (done_scp == NULL) {
+        done_scp = asc_dequeue_list(&boardp->waiting, &last_scp, ASC_TID_ALL);
+        for (tscp = done_scp; tscp; tscp = REQPNEXT(tscp)) {
+            tscp->result = HOST_BYTE(DID_RESET);
+        }
+    } else {
+        /* Append to 'done_scp' at the end with 'last_scp'. */
+        ASC_ASSERT(last_scp != NULL);
+        last_scp->host_scribble = (unsigned char *)asc_dequeue_list(
+			&boardp->waiting, &new_last_scp, ASC_TID_ALL);
+        if (new_last_scp != NULL) {
+            ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+            for (tscp = REQPNEXT(last_scp); tscp; tscp = REQPNEXT(tscp)) {
+                tscp->result = HOST_BYTE(DID_RESET);
+            }
+            last_scp = new_last_scp;
+        }
+    }
+
+    /* Save the time of the most recently completed reset. */
+    boardp->last_reset = jiffies;
+
+    /* Clear reset flag. */
+    boardp->flags &= ~ASC_HOST_IN_RESET;
+    spin_unlock_irqrestore(&boardp->lock, flags);
+
+    /*
+     * Complete all the 'done_scp' requests.
+     */
+    if (done_scp != NULL) {
+        asc_scsi_done_list(done_scp);
+    }
+
+    ASC_DBG1(1, "advansys_reset: ret %d\n", ret);
+
+    return ret;
+}
+
+/*
+ * advansys_biosparam()
+ *
+ * Translate disk drive geometry if the "BIOS greater than 1 GB"
+ * support is enabled for a drive.
+ *
+ * ip (information pointer) is an int array with the following definition:
+ * ip[0]: heads
+ * ip[1]: sectors
+ * ip[2]: cylinders
+ */
+int
+advansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+		sector_t capacity, int ip[])
+{
+    asc_board_t     *boardp;
+
+    ASC_DBG(1, "advansys_biosparam: begin\n");
+    ASC_STATS(sdev->host, biosparam);
+    boardp = ASC_BOARDP(sdev->host);
+    if (ASC_NARROW_BOARD(boardp)) {
+        if ((boardp->dvc_var.asc_dvc_var.dvc_cntl &
+             ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {
+                ip[0] = 255;
+                ip[1] = 63;
+        } else {
+                ip[0] = 64;
+                ip[1] = 32;
+        }
+    } else {
+        if ((boardp->dvc_var.adv_dvc_var.bios_ctrl &
+             BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {
+                ip[0] = 255;
+                ip[1] = 63;
+        } else {
+                ip[0] = 64;
+                ip[1] = 32;
+        }
+    }
+    ip[2] = (unsigned long)capacity / (ip[0] * ip[1]);
+    ASC_DBG(1, "advansys_biosparam: end\n");
+    return 0;
+}
+
+/*
+ * advansys_setup()
+ *
+ * This function is called from init/main.c at boot time.
+ * It it passed LILO parameters that can be set from the
+ * LILO command line or in /etc/lilo.conf.
+ *
+ * It is used by the AdvanSys driver to either disable I/O
+ * port scanning or to limit scanning to 1 - 4 I/O ports.
+ * Regardless of the option setting EISA and PCI boards
+ * will still be searched for and detected. This option
+ * only affects searching for ISA and VL boards.
+ *
+ * If ADVANSYS_DEBUG is defined the driver debug level may
+ * be set using the 5th (ASC_NUM_IOPORT_PROBE + 1) I/O Port.
+ *
+ * Examples:
+ * 1. Eliminate I/O port scanning:
+ *         boot: linux advansys=
+ *       or
+ *         boot: linux advansys=0x0
+ * 2. Limit I/O port scanning to one I/O port:
+ *        boot: linux advansys=0x110
+ * 3. Limit I/O port scanning to four I/O ports:
+ *        boot: linux advansys=0x110,0x210,0x230,0x330
+ * 4. If ADVANSYS_DEBUG, limit I/O port scanning to four I/O ports and
+ *    set the driver debug level to 2.
+ *        boot: linux advansys=0x110,0x210,0x230,0x330,0xdeb2
+ *
+ * ints[0] - number of arguments
+ * ints[1] - first argument
+ * ints[2] - second argument
+ * ...
+ */
+void __init
+advansys_setup(char *str, int *ints)
+{
+    int    i;
+
+    if (asc_iopflag == ASC_TRUE) {
+        printk("AdvanSys SCSI: 'advansys' LILO option may appear only once\n");
+        return;
+    }
+
+    asc_iopflag = ASC_TRUE;
+
+    if (ints[0] > ASC_NUM_IOPORT_PROBE) {
+#ifdef ADVANSYS_DEBUG
+        if ((ints[0] == ASC_NUM_IOPORT_PROBE + 1) &&
+            (ints[ASC_NUM_IOPORT_PROBE + 1] >> 4 == 0xdeb)) {
+            asc_dbglvl = ints[ASC_NUM_IOPORT_PROBE + 1] & 0xf;
+        } else {
+#endif /* ADVANSYS_DEBUG */
+            printk("AdvanSys SCSI: only %d I/O ports accepted\n",
+                ASC_NUM_IOPORT_PROBE);
+#ifdef ADVANSYS_DEBUG
+        }
+#endif /* ADVANSYS_DEBUG */
+    }
+
+#ifdef ADVANSYS_DEBUG
+    ASC_DBG1(1, "advansys_setup: ints[0] %d\n", ints[0]);
+    for (i = 1; i < ints[0]; i++) {
+        ASC_DBG2(1, " ints[%d] 0x%x", i, ints[i]);
+    }
+    ASC_DBG(1, "\n");
+#endif /* ADVANSYS_DEBUG */
+
+    for (i = 1; i <= ints[0] && i <= ASC_NUM_IOPORT_PROBE; i++) {
+        asc_ioport[i-1] = ints[i];
+        ASC_DBG2(1, "advansys_setup: asc_ioport[%d] 0x%x\n",
+            i - 1, asc_ioport[i-1]);
+    }
+}
+
+
+/*
+ * --- Loadable Driver Support
+ */
+
+static struct scsi_host_template driver_template = {
+    .proc_name                  = "advansys",
+#ifdef CONFIG_PROC_FS
+    .proc_info                  = advansys_proc_info,
+#endif
+    .name                       = "advansys",
+    .detect                     = advansys_detect, 
+    .release                    = advansys_release,
+    .info                       = advansys_info,
+    .queuecommand               = advansys_queuecommand,
+    .eh_bus_reset_handler	= advansys_reset,
+    .bios_param                 = advansys_biosparam,
+    .slave_configure		= advansys_slave_configure,
+    /*
+     * Because the driver may control an ISA adapter 'unchecked_isa_dma'
+     * must be set. The flag will be cleared in advansys_detect for non-ISA
+     * adapters. Refer to the comment in scsi_module.c for more information.
+     */
+    .unchecked_isa_dma          = 1,
+    /*
+     * All adapters controlled by this driver are capable of large
+     * scatter-gather lists. According to the mid-level SCSI documentation
+     * this obviates any performance gain provided by setting
+     * 'use_clustering'. But empirically while CPU utilization is increased
+     * by enabling clustering, I/O throughput increases as well.
+     */
+    .use_clustering             = ENABLE_CLUSTERING,
+};
+#include "scsi_module.c"
+
+
+/*
+ * --- Miscellaneous Driver Functions
+ */
+
+/*
+ * First-level interrupt handler.
+ *
+ * 'dev_id' is a pointer to the interrupting adapter's asc_board_t. Because
+ * all boards are currently checked for interrupts on each interrupt, 'dev_id'
+ * is not referenced. 'dev_id' could be used to identify an interrupt passed
+ * to the AdvanSys driver which is for a device sharing an interrupt with
+ * an AdvanSys adapter.
+ */
+STATIC irqreturn_t
+advansys_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+    ulong           flags;
+    int             i;
+    asc_board_t     *boardp;
+    struct scsi_cmnd       *done_scp = NULL, *last_scp = NULL;
+    struct scsi_cmnd       *new_last_scp;
+    struct Scsi_Host *shp;
+
+    ASC_DBG(1, "advansys_interrupt: begin\n");
+
+    /*
+     * Check for interrupts on all boards.
+     * AscISR() will call asc_isr_callback().
+     */
+    for (i = 0; i < asc_board_count; i++) {
+	shp = asc_host[i];
+        boardp = ASC_BOARDP(shp);
+        ASC_DBG2(2, "advansys_interrupt: i %d, boardp 0x%lx\n",
+            i, (ulong) boardp);
+        spin_lock_irqsave(&boardp->lock, flags);
+        if (ASC_NARROW_BOARD(boardp)) {
+            /*
+             * Narrow Board
+             */
+            if (AscIsIntPending(shp->io_port)) {
+                ASC_STATS(shp, interrupt);
+                ASC_DBG(1, "advansys_interrupt: before AscISR()\n");
+                AscISR(&boardp->dvc_var.asc_dvc_var);
+            }
+        } else {
+            /*
+             * Wide Board
+             */
+            ASC_DBG(1, "advansys_interrupt: before AdvISR()\n");
+            if (AdvISR(&boardp->dvc_var.adv_dvc_var)) {
+                ASC_STATS(shp, interrupt);
+            }
+        }
+
+        /*
+         * Start waiting requests and create a list of completed requests.
+         *
+         * If a reset request is being performed for the board, the reset
+         * handler will complete pending requests after it has completed.
+         */
+        if ((boardp->flags & ASC_HOST_IN_RESET) == 0) {
+            ASC_DBG2(1, "advansys_interrupt: done_scp 0x%lx, last_scp 0x%lx\n",
+                (ulong) done_scp, (ulong) last_scp);
+
+            /* Start any waiting commands for the board. */
+            if (!ASC_QUEUE_EMPTY(&boardp->waiting)) {
+                ASC_DBG(1, "advansys_interrupt: before asc_execute_queue()\n");
+                asc_execute_queue(&boardp->waiting);
+            }
+
+             /*
+              * Add to the list of requests that must be completed.
+              *
+              * 'done_scp' will always be NULL on the first iteration
+              * of this loop. 'last_scp' is set at the same time as
+              * 'done_scp'.
+              */
+            if (done_scp == NULL) {
+                done_scp = asc_dequeue_list(&boardp->done, &last_scp,
+                    ASC_TID_ALL);
+            } else {
+                ASC_ASSERT(last_scp != NULL);
+                last_scp->host_scribble = (unsigned char *)asc_dequeue_list(
+			&boardp->done, &new_last_scp, ASC_TID_ALL);
+                if (new_last_scp != NULL) {
+                    ASC_ASSERT(REQPNEXT(last_scp) != NULL);
+                    last_scp = new_last_scp;
+                }
+            }
+        }
+        spin_unlock_irqrestore(&boardp->lock, flags);
+    }
+
+    /*
+     * If interrupts were enabled on entry, then they
+     * are now enabled here.
+     *
+     * Complete all requests on the done list.
+     */
+
+    asc_scsi_done_list(done_scp);
+
+    ASC_DBG(1, "advansys_interrupt: end\n");
+    return IRQ_HANDLED;
+}
+
+/*
+ * Set the number of commands to queue per device for the
+ * specified host adapter.
+ */
+STATIC int
+advansys_slave_configure(struct scsi_device *device)
+{
+    asc_board_t        *boardp;
+
+    boardp = ASC_BOARDP(device->host);
+    boardp->flags |= ASC_SELECT_QUEUE_DEPTHS;
+    /*
+     * Save a pointer to the device and set its initial/maximum
+     * queue depth.  Only save the pointer for a lun0 dev though.
+     */
+    if(device->lun == 0)
+        boardp->device[device->id] = device;
+    if(device->tagged_supported) {
+        if (ASC_NARROW_BOARD(boardp)) {
+	    scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
+                boardp->dvc_var.asc_dvc_var.max_dvc_qng[device->id]);
+        } else {
+	    scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
+                boardp->dvc_var.adv_dvc_var.max_dvc_qng);
+        }
+    } else {
+	scsi_adjust_queue_depth(device, 0, device->host->cmd_per_lun);
+    }
+    ASC_DBG4(1, "advansys_slave_configure: device 0x%lx, boardp 0x%lx, id %d, depth %d\n",
+            (ulong) device, (ulong) boardp, device->id, device->queue_depth);
+    return 0;
+}
+
+/*
+ * Complete all requests on the singly linked list pointed
+ * to by 'scp'.
+ *
+ * Interrupts can be enabled on entry.
+ */
+STATIC void
+asc_scsi_done_list(struct scsi_cmnd *scp)
+{
+    struct scsi_cmnd    *tscp;
+
+    ASC_DBG(2, "asc_scsi_done_list: begin\n");
+    while (scp != NULL) {
+	asc_board_t *boardp;
+	struct device *dev;
+
+        ASC_DBG1(3, "asc_scsi_done_list: scp 0x%lx\n", (ulong) scp);
+        tscp = REQPNEXT(scp);
+        scp->host_scribble = NULL;
+
+	boardp = ASC_BOARDP(scp->device->host);
+
+	if (ASC_NARROW_BOARD(boardp))
+	    dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
+	else
+	    dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
+
+	if (scp->use_sg)
+	    dma_unmap_sg(dev, (struct scatterlist *)scp->request_buffer,
+			 scp->use_sg, scp->sc_data_direction);
+	else if (scp->request_bufflen)
+	    dma_unmap_single(dev, scp->SCp.dma_handle,
+			     scp->request_bufflen, scp->sc_data_direction);
+
+        ASC_STATS(scp->device->host, done);
+        ASC_ASSERT(scp->scsi_done != NULL);
+
+        scp->scsi_done(scp);
+
+        scp = tscp;
+    }
+    ASC_DBG(2, "asc_scsi_done_list: done\n");
+    return;
+}
+
+/*
+ * Execute a single 'Scsi_Cmnd'.
+ *
+ * The function 'done' is called when the request has been completed.
+ *
+ * Scsi_Cmnd:
+ *
+ *  host - board controlling device
+ *  device - device to send command
+ *  target - target of device
+ *  lun - lun of device
+ *  cmd_len - length of SCSI CDB
+ *  cmnd - buffer for SCSI 8, 10, or 12 byte CDB
+ *  use_sg - if non-zero indicates scatter-gather request with use_sg elements
+ *
+ *  if (use_sg == 0) {
+ *    request_buffer - buffer address for request
+ *    request_bufflen - length of request buffer
+ *  } else {
+ *    request_buffer - pointer to scatterlist structure
+ *  }
+ *
+ *  sense_buffer - sense command buffer
+ *
+ *  result (4 bytes of an int):
+ *    Byte Meaning
+ *    0 SCSI Status Byte Code
+ *    1 SCSI One Byte Message Code
+ *    2 Host Error Code
+ *    3 Mid-Level Error Code
+ *
+ *  host driver fields:
+ *    SCp - Scsi_Pointer used for command processing status
+ *    scsi_done - used to save caller's done function
+ *    host_scribble - used for pointer to another struct scsi_cmnd
+ *
+ * If this function returns ASC_NOERROR the request has been enqueued
+ * on the board's 'active' queue and will be completed from the
+ * interrupt handler.
+ *
+ * If this function returns ASC_NOERROR the request has been enqueued
+ * on the board's 'done' queue and must be completed by the caller.
+ *
+ * If ASC_BUSY is returned the request will be enqueued by the
+ * caller on the target's waiting queue and re-tried later.
+ */
+STATIC int
+asc_execute_scsi_cmnd(struct scsi_cmnd *scp)
+{
+    asc_board_t        *boardp;
+    ASC_DVC_VAR        *asc_dvc_varp;
+    ADV_DVC_VAR        *adv_dvc_varp;
+    ADV_SCSI_REQ_Q     *adv_scsiqp;
+    struct scsi_device *device;
+    int                ret;
+
+    ASC_DBG2(1, "asc_execute_scsi_cmnd: scp 0x%lx, done 0x%lx\n",
+        (ulong) scp, (ulong) scp->scsi_done);
+
+    boardp = ASC_BOARDP(scp->device->host);
+    device = boardp->device[scp->device->id];
+
+    if (ASC_NARROW_BOARD(boardp)) {
+        /*
+         * Build and execute Narrow Board request.
+         */
+
+        asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+
+        /*
+         * Build Asc Library request structure using the
+         * global structures 'asc_scsi_req' and 'asc_sg_head'.
+         *
+         * If an error is returned, then the request has been
+         * queued on the board done queue. It will be completed
+         * by the caller.
+         *
+         * asc_build_req() can not return ASC_BUSY.
+         */
+        if (asc_build_req(boardp, scp) == ASC_ERROR) {
+            ASC_STATS(scp->device->host, build_error);
+            return ASC_ERROR;
+        }
+
+        /*
+         * Execute the command. If there is no error, add the command
+         * to the active queue.
+         */
+        switch (ret = AscExeScsiQueue(asc_dvc_varp, &asc_scsi_q)) {
+        case ASC_NOERROR:
+            ASC_STATS(scp->device->host, exe_noerror);
+            /*
+             * Increment monotonically increasing per device successful
+             * request counter. Wrapping doesn't matter.
+             */
+            boardp->reqcnt[scp->device->id]++;
+            asc_enqueue(&boardp->active, scp, ASC_BACK);
+            ASC_DBG(1,
+                "asc_execute_scsi_cmnd: AscExeScsiQueue(), ASC_NOERROR\n");
+            break;
+        case ASC_BUSY:
+            /*
+             * Caller will enqueue request on the target's waiting queue
+             * and retry later.
+             */
+            ASC_STATS(scp->device->host, exe_busy);
+            break;
+        case ASC_ERROR:
+            ASC_PRINT2(
+"asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+                boardp->id, asc_dvc_varp->err_code);
+            ASC_STATS(scp->device->host, exe_error);
+            scp->result = HOST_BYTE(DID_ERROR);
+            asc_enqueue(&boardp->done, scp, ASC_BACK);
+            break;
+        default:
+            ASC_PRINT2(
+"asc_execute_scsi_cmnd: board %d: AscExeScsiQueue() unknown, err_code 0x%x\n",
+                boardp->id, asc_dvc_varp->err_code);
+            ASC_STATS(scp->device->host, exe_unknown);
+            scp->result = HOST_BYTE(DID_ERROR);
+            asc_enqueue(&boardp->done, scp, ASC_BACK);
+            break;
+        }
+    } else {
+        /*
+         * Build and execute Wide Board request.
+         */
+        adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+
+        /*
+         * Build and get a pointer to an Adv Library request structure.
+         *
+         * If the request is successfully built then send it below,
+         * otherwise return with an error.
+         */
+        switch (adv_build_req(boardp, scp, &adv_scsiqp)) {
+        case ASC_NOERROR:
+            ASC_DBG(3, "asc_execute_scsi_cmnd: adv_build_req ASC_NOERROR\n");
+            break;
+        case ASC_BUSY:
+            ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req ASC_BUSY\n");
+            /*
+             * If busy is returned the request has not been enqueued.
+             * It will be enqueued by the caller on the target's waiting
+             * queue and retried later.
+             *
+             * The asc_stats fields 'adv_build_noreq' and 'adv_build_nosg'
+             * count wide board busy conditions. They are updated in
+             * adv_build_req and adv_get_sglist, respectively.
+             */
+            return ASC_BUSY;
+        case ASC_ERROR:
+             /* 
+              * If an error is returned, then the request has been
+              * queued on the board done queue. It will be completed
+              * by the caller.
+              */
+        default:
+            ASC_DBG(1, "asc_execute_scsi_cmnd: adv_build_req ASC_ERROR\n");
+            ASC_STATS(scp->device->host, build_error);
+            return ASC_ERROR;
+        }
+
+        /*
+         * Execute the command. If there is no error, add the command
+         * to the active queue.
+         */
+        switch (ret = AdvExeScsiQueue(adv_dvc_varp, adv_scsiqp)) {
+        case ASC_NOERROR:
+            ASC_STATS(scp->device->host, exe_noerror);
+            /*
+             * Increment monotonically increasing per device successful
+             * request counter. Wrapping doesn't matter.
+             */
+            boardp->reqcnt[scp->device->id]++;
+            asc_enqueue(&boardp->active, scp, ASC_BACK);
+            ASC_DBG(1,
+                "asc_execute_scsi_cmnd: AdvExeScsiQueue(), ASC_NOERROR\n");
+            break;
+        case ASC_BUSY:
+            /*
+             * Caller will enqueue request on the target's waiting queue
+             * and retry later.
+             */
+            ASC_STATS(scp->device->host, exe_busy);
+            break;
+        case ASC_ERROR:
+            ASC_PRINT2(
+"asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() ASC_ERROR, err_code 0x%x\n",
+                boardp->id, adv_dvc_varp->err_code);
+            ASC_STATS(scp->device->host, exe_error);
+            scp->result = HOST_BYTE(DID_ERROR);
+            asc_enqueue(&boardp->done, scp, ASC_BACK);
+            break;
+        default:
+            ASC_PRINT2(
+"asc_execute_scsi_cmnd: board %d: AdvExeScsiQueue() unknown, err_code 0x%x\n",
+                boardp->id, adv_dvc_varp->err_code);
+            ASC_STATS(scp->device->host, exe_unknown);
+            scp->result = HOST_BYTE(DID_ERROR);
+            asc_enqueue(&boardp->done, scp, ASC_BACK);
+            break;
+        }
+    }
+
+    ASC_DBG(1, "asc_execute_scsi_cmnd: end\n");
+    return ret;
+}
+
+/*
+ * Build a request structure for the Asc Library (Narrow Board).
+ *
+ * The global structures 'asc_scsi_q' and 'asc_sg_head' are
+ * used to build the request.
+ *
+ * If an error occurs, then queue the request on the board done
+ * queue and return ASC_ERROR.
+ */
+STATIC int
+asc_build_req(asc_board_t *boardp, struct scsi_cmnd *scp)
+{
+    struct device *dev = boardp->dvc_cfg.asc_dvc_cfg.dev;
+
+    /*
+     * Mutually exclusive access is required to 'asc_scsi_q' and
+     * 'asc_sg_head' until after the request is started.
+     */
+    memset(&asc_scsi_q, 0, sizeof(ASC_SCSI_Q));
+
+    /*
+     * Point the ASC_SCSI_Q to the 'struct scsi_cmnd'.
+     */
+    asc_scsi_q.q2.srb_ptr = ASC_VADDR_TO_U32(scp);
+
+    /*
+     * Build the ASC_SCSI_Q request.
+     *
+     * For narrow boards a CDB length maximum of 12 bytes
+     * is supported.
+     */
+    if (scp->cmd_len > ASC_MAX_CDB_LEN) {
+        ASC_PRINT3(
+"asc_build_req: board %d: cmd_len %d > ASC_MAX_CDB_LEN  %d\n",
+            boardp->id, scp->cmd_len, ASC_MAX_CDB_LEN);
+        scp->result = HOST_BYTE(DID_ERROR);
+        asc_enqueue(&boardp->done, scp, ASC_BACK);
+        return ASC_ERROR;
+    }
+    asc_scsi_q.cdbptr = &scp->cmnd[0];
+    asc_scsi_q.q2.cdb_len = scp->cmd_len;
+    asc_scsi_q.q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);
+    asc_scsi_q.q1.target_lun = scp->device->lun;
+    asc_scsi_q.q2.target_ix = ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);
+    asc_scsi_q.q1.sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+    asc_scsi_q.q1.sense_len = sizeof(scp->sense_buffer);
+
+    /*
+     * If there are any outstanding requests for the current target,
+     * then every 255th request send an ORDERED request. This heuristic
+     * tries to retain the benefit of request sorting while preventing
+     * request starvation. 255 is the max number of tags or pending commands
+     * a device may have outstanding.
+     *
+     * The request count is incremented below for every successfully
+     * started request.
+     *
+     */
+    if ((boardp->dvc_var.asc_dvc_var.cur_dvc_qng[scp->device->id] > 0) &&
+        (boardp->reqcnt[scp->device->id] % 255) == 0) {
+        asc_scsi_q.q2.tag_code = MSG_ORDERED_TAG;
+    } else {
+        asc_scsi_q.q2.tag_code = MSG_SIMPLE_TAG;
+    }
+
+    /*
+     * Build ASC_SCSI_Q for a contiguous buffer or a scatter-gather
+     * buffer command.
+     */
+    if (scp->use_sg == 0) {
+        /*
+         * CDB request of single contiguous buffer.
+         */
+        ASC_STATS(scp->device->host, cont_cnt);
+	scp->SCp.dma_handle = scp->request_bufflen ?
+	    dma_map_single(dev, scp->request_buffer,
+			   scp->request_bufflen, scp->sc_data_direction) : 0;
+	asc_scsi_q.q1.data_addr = cpu_to_le32(scp->SCp.dma_handle);
+        asc_scsi_q.q1.data_cnt = cpu_to_le32(scp->request_bufflen);
+        ASC_STATS_ADD(scp->device->host, cont_xfer,
+                      ASC_CEILING(scp->request_bufflen, 512));
+        asc_scsi_q.q1.sg_queue_cnt = 0;
+        asc_scsi_q.sg_head = NULL;
+    } else {
+        /*
+         * CDB scatter-gather request list.
+         */
+        int                     sgcnt;
+	int			use_sg;
+        struct scatterlist      *slp;
+
+	slp = (struct scatterlist *)scp->request_buffer;
+	use_sg = dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+
+	if (use_sg > scp->device->host->sg_tablesize) {
+            ASC_PRINT3(
+"asc_build_req: board %d: use_sg %d > sg_tablesize %d\n",
+		boardp->id, use_sg, scp->device->host->sg_tablesize);
+	    dma_unmap_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+            scp->result = HOST_BYTE(DID_ERROR);
+            asc_enqueue(&boardp->done, scp, ASC_BACK);
+            return ASC_ERROR;
+        }
+
+        ASC_STATS(scp->device->host, sg_cnt);
+
+        /*
+         * Use global ASC_SG_HEAD structure and set the ASC_SCSI_Q
+         * structure to point to it.
+         */
+        memset(&asc_sg_head, 0, sizeof(ASC_SG_HEAD));
+
+        asc_scsi_q.q1.cntl |= QC_SG_HEAD;
+        asc_scsi_q.sg_head = &asc_sg_head;
+        asc_scsi_q.q1.data_cnt = 0;
+        asc_scsi_q.q1.data_addr = 0;
+        /* This is a byte value, otherwise it would need to be swapped. */
+	asc_sg_head.entry_cnt = asc_scsi_q.q1.sg_queue_cnt = use_sg;
+        ASC_STATS_ADD(scp->device->host, sg_elem, asc_sg_head.entry_cnt);
+
+        /*
+         * Convert scatter-gather list into ASC_SG_HEAD list.
+         */
+	for (sgcnt = 0; sgcnt < use_sg; sgcnt++, slp++) {
+	    asc_sg_head.sg_list[sgcnt].addr = cpu_to_le32(sg_dma_address(slp));
+	    asc_sg_head.sg_list[sgcnt].bytes = cpu_to_le32(sg_dma_len(slp));
+	    ASC_STATS_ADD(scp->device->host, sg_xfer, ASC_CEILING(sg_dma_len(slp), 512));
+        }
+    }
+
+    ASC_DBG_PRT_ASC_SCSI_Q(2, &asc_scsi_q);
+    ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+
+    return ASC_NOERROR;
+}
+
+/*
+ * Build a request structure for the Adv Library (Wide Board).
+ *
+ * If an adv_req_t can not be allocated to issue the request,
+ * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.
+ *
+ * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the
+ * microcode for DMA addresses or math operations are byte swapped
+ * to little-endian order.
+ */
+STATIC int
+adv_build_req(asc_board_t *boardp, struct scsi_cmnd *scp,
+    ADV_SCSI_REQ_Q **adv_scsiqpp)
+{
+    adv_req_t           *reqp;
+    ADV_SCSI_REQ_Q      *scsiqp;
+    int                 i;
+    int                 ret;
+    struct device	*dev = boardp->dvc_cfg.adv_dvc_cfg.dev;
+
+    /*
+     * Allocate an adv_req_t structure from the board to execute
+     * the command.
+     */
+    if (boardp->adv_reqp == NULL) {
+        ASC_DBG(1, "adv_build_req: no free adv_req_t\n");
+        ASC_STATS(scp->device->host, adv_build_noreq);
+        return ASC_BUSY;
+    } else {
+        reqp = boardp->adv_reqp;
+        boardp->adv_reqp = reqp->next_reqp;
+        reqp->next_reqp = NULL;
+    }
+
+    /*
+     * Get 32-byte aligned ADV_SCSI_REQ_Q and ADV_SG_BLOCK pointers.
+     */
+    scsiqp = (ADV_SCSI_REQ_Q *) ADV_32BALIGN(&reqp->scsi_req_q);
+
+    /*
+     * Initialize the structure.
+     */
+    scsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;
+
+    /*
+     * Set the ADV_SCSI_REQ_Q 'srb_ptr' to point to the adv_req_t structure.
+     */
+    scsiqp->srb_ptr = ASC_VADDR_TO_U32(reqp);
+
+    /*
+     * Set the adv_req_t 'cmndp' to point to the struct scsi_cmnd structure.
+     */
+    reqp->cmndp = scp;
+
+    /*
+     * Build the ADV_SCSI_REQ_Q request.
+     */
+
+    /*
+     * Set CDB length and copy it to the request structure.
+     * For wide  boards a CDB length maximum of 16 bytes
+     * is supported.
+     */
+    if (scp->cmd_len > ADV_MAX_CDB_LEN) {
+        ASC_PRINT3(
+"adv_build_req: board %d: cmd_len %d > ADV_MAX_CDB_LEN  %d\n",
+            boardp->id, scp->cmd_len, ADV_MAX_CDB_LEN);
+        scp->result = HOST_BYTE(DID_ERROR);
+        asc_enqueue(&boardp->done, scp, ASC_BACK);
+        return ASC_ERROR;
+    }
+    scsiqp->cdb_len = scp->cmd_len;
+    /* Copy first 12 CDB bytes to cdb[]. */
+    for (i = 0; i < scp->cmd_len && i < 12; i++) {
+        scsiqp->cdb[i] = scp->cmnd[i];
+    }
+    /* Copy last 4 CDB bytes, if present, to cdb16[]. */
+    for (; i < scp->cmd_len; i++) {
+        scsiqp->cdb16[i - 12] = scp->cmnd[i];
+    }
+
+    scsiqp->target_id = scp->device->id;
+    scsiqp->target_lun = scp->device->lun;
+
+    scsiqp->sense_addr = cpu_to_le32(virt_to_bus(&scp->sense_buffer[0]));
+    scsiqp->sense_len = sizeof(scp->sense_buffer);
+
+    /*
+     * Build ADV_SCSI_REQ_Q for a contiguous buffer or a scatter-gather
+     * buffer command.
+     */
+
+    scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
+    scsiqp->vdata_addr = scp->request_buffer;
+    scsiqp->data_addr = cpu_to_le32(virt_to_bus(scp->request_buffer));
+
+    if (scp->use_sg == 0) {
+        /*
+         * CDB request of single contiguous buffer.
+         */
+        reqp->sgblkp = NULL;
+	scsiqp->data_cnt = cpu_to_le32(scp->request_bufflen);
+	if (scp->request_bufflen) {
+	    scsiqp->vdata_addr = scp->request_buffer;
+	    scp->SCp.dma_handle =
+	        dma_map_single(dev, scp->request_buffer,
+			       scp->request_bufflen, scp->sc_data_direction);
+	} else {
+	    scsiqp->vdata_addr = 0;
+	    scp->SCp.dma_handle = 0;
+	}
+	scsiqp->data_addr = cpu_to_le32(scp->SCp.dma_handle);
+        scsiqp->sg_list_ptr = NULL;
+        scsiqp->sg_real_addr = 0;
+        ASC_STATS(scp->device->host, cont_cnt);
+        ASC_STATS_ADD(scp->device->host, cont_xfer,
+                      ASC_CEILING(scp->request_bufflen, 512));
+    } else {
+        /*
+         * CDB scatter-gather request list.
+         */
+	struct scatterlist *slp;
+	int use_sg;
+
+	slp = (struct scatterlist *)scp->request_buffer;
+	use_sg = dma_map_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+
+	if (use_sg > ADV_MAX_SG_LIST) {
+            ASC_PRINT3(
+"adv_build_req: board %d: use_sg %d > ADV_MAX_SG_LIST %d\n",
+		boardp->id, use_sg, scp->device->host->sg_tablesize);
+	    dma_unmap_sg(dev, slp, scp->use_sg, scp->sc_data_direction);
+            scp->result = HOST_BYTE(DID_ERROR);
+            asc_enqueue(&boardp->done, scp, ASC_BACK);
+
+            /*
+             * Free the 'adv_req_t' structure by adding it back to the
+             * board free list.
+             */
+            reqp->next_reqp = boardp->adv_reqp;
+            boardp->adv_reqp = reqp;
+
+            return ASC_ERROR;
+        }
+
+	if ((ret = adv_get_sglist(boardp, reqp, scp, use_sg)) != ADV_SUCCESS) {
+            /*
+             * Free the adv_req_t structure by adding it back to the
+             * board free list.
+             */
+            reqp->next_reqp = boardp->adv_reqp;
+            boardp->adv_reqp = reqp;
+
+            return ret;
+        }
+
+        ASC_STATS(scp->device->host, sg_cnt);
+	ASC_STATS_ADD(scp->device->host, sg_elem, use_sg);
+    }
+
+    ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
+    ASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);
+
+    *adv_scsiqpp = scsiqp;
+
+    return ASC_NOERROR;
+}
+
+/*
+ * Build scatter-gather list for Adv Library (Wide Board).
+ *
+ * Additional ADV_SG_BLOCK structures will need to be allocated
+ * if the total number of scatter-gather elements exceeds
+ * NO_OF_SG_PER_BLOCK (15). The ADV_SG_BLOCK structures are
+ * assumed to be physically contiguous.
+ *
+ * Return:
+ *      ADV_SUCCESS(1) - SG List successfully created
+ *      ADV_ERROR(-1) - SG List creation failed
+ */
+STATIC int
+adv_get_sglist(asc_board_t *boardp, adv_req_t *reqp, struct scsi_cmnd *scp, int use_sg)
+{
+    adv_sgblk_t         *sgblkp;
+    ADV_SCSI_REQ_Q      *scsiqp;
+    struct scatterlist  *slp;
+    int                 sg_elem_cnt;
+    ADV_SG_BLOCK        *sg_block, *prev_sg_block;
+    ADV_PADDR           sg_block_paddr;
+    int                 i;
+
+    scsiqp = (ADV_SCSI_REQ_Q *) ADV_32BALIGN(&reqp->scsi_req_q);
+    slp = (struct scatterlist *) scp->request_buffer;
+    sg_elem_cnt = use_sg;
+    prev_sg_block = NULL;
+    reqp->sgblkp = NULL;
+
+    do
+    {
+        /*
+         * Allocate a 'adv_sgblk_t' structure from the board free
+         * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK
+         * (15) scatter-gather elements.
+         */
+        if ((sgblkp = boardp->adv_sgblkp) == NULL) {
+            ASC_DBG(1, "adv_get_sglist: no free adv_sgblk_t\n");
+            ASC_STATS(scp->device->host, adv_build_nosg);
+
+            /*
+             * Allocation failed. Free 'adv_sgblk_t' structures already
+             * allocated for the request.
+             */
+            while ((sgblkp = reqp->sgblkp) != NULL)
+            {
+                /* Remove 'sgblkp' from the request list. */
+                reqp->sgblkp = sgblkp->next_sgblkp;
+
+                /* Add 'sgblkp' to the board free list. */
+                sgblkp->next_sgblkp = boardp->adv_sgblkp;
+                boardp->adv_sgblkp = sgblkp;
+            }
+            return ASC_BUSY;
+        } else {
+            /* Complete 'adv_sgblk_t' board allocation. */
+            boardp->adv_sgblkp = sgblkp->next_sgblkp;
+            sgblkp->next_sgblkp = NULL;
+
+            /*
+             * Get 8 byte aligned virtual and physical addresses for
+             * the allocated ADV_SG_BLOCK structure.
+             */
+            sg_block = (ADV_SG_BLOCK *) ADV_8BALIGN(&sgblkp->sg_block);
+            sg_block_paddr = virt_to_bus(sg_block);
+
+            /*
+             * Check if this is the first 'adv_sgblk_t' for the request.
+             */
+            if (reqp->sgblkp == NULL)
+            {
+                /* Request's first scatter-gather block. */
+                reqp->sgblkp = sgblkp;
+
+                /*
+                 * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical
+                 * address pointers.
+                 */
+                scsiqp->sg_list_ptr = sg_block;
+                scsiqp->sg_real_addr = cpu_to_le32(sg_block_paddr);
+            } else
+            {
+                /* Request's second or later scatter-gather block. */
+                sgblkp->next_sgblkp = reqp->sgblkp;
+                reqp->sgblkp = sgblkp;
+
+                /*
+                 * Point the previous ADV_SG_BLOCK structure to
+                 * the newly allocated ADV_SG_BLOCK structure.
+                 */
+                ASC_ASSERT(prev_sg_block != NULL);
+                prev_sg_block->sg_ptr = cpu_to_le32(sg_block_paddr);
+            }
+        }
+
+        for (i = 0; i < NO_OF_SG_PER_BLOCK; i++)
+        {
+	    sg_block->sg_list[i].sg_addr = cpu_to_le32(sg_dma_address(slp));
+	    sg_block->sg_list[i].sg_count = cpu_to_le32(sg_dma_len(slp));
+	    ASC_STATS_ADD(scp->device->host, sg_xfer, ASC_CEILING(sg_dma_len(slp), 512));
+
+            if (--sg_elem_cnt == 0)
+            {   /* Last ADV_SG_BLOCK and scatter-gather entry. */
+                sg_block->sg_cnt = i + 1;
+                sg_block->sg_ptr = 0L;    /* Last ADV_SG_BLOCK in list. */
+                return ADV_SUCCESS;
+            }
+            slp++;
+        }
+        sg_block->sg_cnt = NO_OF_SG_PER_BLOCK;
+        prev_sg_block = sg_block;
+    }
+    while (1);
+    /* NOTREACHED */
+}
+
+/*
+ * asc_isr_callback() - Second Level Interrupt Handler called by AscISR().
+ *
+ * Interrupt callback function for the Narrow SCSI Asc Library.
+ */
+STATIC void
+asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)
+{
+    asc_board_t         *boardp;
+    struct scsi_cmnd           *scp;
+    struct Scsi_Host    *shp;
+    int                 i;
+
+    ASC_DBG2(1, "asc_isr_callback: asc_dvc_varp 0x%lx, qdonep 0x%lx\n",
+        (ulong) asc_dvc_varp, (ulong) qdonep);
+    ASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);
+
+    /*
+     * Get the struct scsi_cmnd structure and Scsi_Host structure for the
+     * command that has been completed.
+     */
+    scp = (struct scsi_cmnd *) ASC_U32_TO_VADDR(qdonep->d2.srb_ptr);
+    ASC_DBG1(1, "asc_isr_callback: scp 0x%lx\n", (ulong) scp);
+
+    if (scp == NULL) {
+        ASC_PRINT("asc_isr_callback: scp is NULL\n");
+        return;
+    }
+    ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+
+    /*
+     * If the request's host pointer is not valid, display a
+     * message and return.
+     */
+    shp = scp->device->host;
+    for (i = 0; i < asc_board_count; i++) {
+        if (asc_host[i] == shp) {
+            break;
+        }
+    }
+    if (i == asc_board_count) {
+        ASC_PRINT2(
+            "asc_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
+            (ulong) scp, (ulong) shp);
+        return;
+    }
+
+    ASC_STATS(shp, callback);
+    ASC_DBG1(1, "asc_isr_callback: shp 0x%lx\n", (ulong) shp);
+
+    /*
+     * If the request isn't found on the active queue, it may
+     * have been removed to handle a reset request.
+     * Display a message and return.
+     */
+    boardp = ASC_BOARDP(shp);
+    ASC_ASSERT(asc_dvc_varp == &boardp->dvc_var.asc_dvc_var);
+    if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
+        ASC_PRINT2(
+            "asc_isr_callback: board %d: scp 0x%lx not on active queue\n",
+            boardp->id, (ulong) scp);
+        return;
+    }
+
+    /*
+     * 'qdonep' contains the command's ending status.
+     */
+    switch (qdonep->d3.done_stat) {
+    case QD_NO_ERROR:
+        ASC_DBG(2, "asc_isr_callback: QD_NO_ERROR\n");
+        scp->result = 0;
+
+        /*
+         * If an INQUIRY command completed successfully, then call
+         * the AscInquiryHandling() function to set-up the device.
+         */
+        if (scp->cmnd[0] == INQUIRY && scp->device->lun == 0 &&
+            (scp->request_bufflen - qdonep->remain_bytes) >= 8)
+        {
+            AscInquiryHandling(asc_dvc_varp, scp->device->id & 0x7,
+                (ASC_SCSI_INQUIRY *) scp->request_buffer);
+        }
+
+        /*
+         * Check for an underrun condition.
+         *
+         * If there was no error and an underrun condition, then
+         * then return the number of underrun bytes.
+         */
+        if (scp->request_bufflen != 0 && qdonep->remain_bytes != 0 &&
+            qdonep->remain_bytes <= scp->request_bufflen) {
+            ASC_DBG1(1, "asc_isr_callback: underrun condition %u bytes\n",
+            (unsigned) qdonep->remain_bytes);
+            scp->resid = qdonep->remain_bytes;
+        }
+        break;
+
+    case QD_WITH_ERROR:
+        ASC_DBG(2, "asc_isr_callback: QD_WITH_ERROR\n");
+        switch (qdonep->d3.host_stat) {
+        case QHSTA_NO_ERROR:
+            if (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {
+                ASC_DBG(2, "asc_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+                ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
+                    sizeof(scp->sense_buffer));
+                /*
+                 * Note: The 'status_byte()' macro used by target drivers
+                 * defined in scsi.h shifts the status byte returned by
+                 * host drivers right by 1 bit. This is why target drivers
+                 * also use right shifted status byte definitions. For
+                 * instance target drivers use CHECK_CONDITION, defined to
+                 * 0x1, instead of the SCSI defined check condition value
+                 * of 0x2. Host drivers are supposed to return the status
+                 * byte as it is defined by SCSI.
+                 */
+                scp->result = DRIVER_BYTE(DRIVER_SENSE) |
+                    STATUS_BYTE(qdonep->d3.scsi_stat);
+            } else {
+                scp->result = STATUS_BYTE(qdonep->d3.scsi_stat);
+            }
+            break;
+
+        default:
+            /* QHSTA error occurred */
+            ASC_DBG1(1, "asc_isr_callback: host_stat 0x%x\n",
+                qdonep->d3.host_stat);
+            scp->result = HOST_BYTE(DID_BAD_TARGET);
+            break;
+        }
+        break;
+
+    case QD_ABORTED_BY_HOST:
+        ASC_DBG(1, "asc_isr_callback: QD_ABORTED_BY_HOST\n");
+        scp->result = HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.scsi_msg) |
+                STATUS_BYTE(qdonep->d3.scsi_stat);
+        break;
+
+    default:
+        ASC_DBG1(1, "asc_isr_callback: done_stat 0x%x\n", qdonep->d3.done_stat);
+        scp->result = HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.scsi_msg) |
+                STATUS_BYTE(qdonep->d3.scsi_stat);
+        break;
+    }
+
+    /*
+     * If the 'init_tidmask' bit isn't already set for the target and the
+     * current request finished normally, then set the bit for the target
+     * to indicate that a device is present.
+     */
+    if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
+        qdonep->d3.done_stat == QD_NO_ERROR &&
+        qdonep->d3.host_stat == QHSTA_NO_ERROR) {
+        boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+    }
+
+    /*
+     * Because interrupts may be enabled by the 'struct scsi_cmnd' done
+     * function, add the command to the end of the board's done queue.
+     * The done function for the command will be called from
+     * advansys_interrupt().
+     */
+    asc_enqueue(&boardp->done, scp, ASC_BACK);
+
+    return;
+}
+
+/*
+ * adv_isr_callback() - Second Level Interrupt Handler called by AdvISR().
+ *
+ * Callback function for the Wide SCSI Adv Library.
+ */
+STATIC void
+adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)
+{
+    asc_board_t         *boardp;
+    adv_req_t           *reqp;
+    adv_sgblk_t         *sgblkp;
+    struct scsi_cmnd           *scp;
+    struct Scsi_Host    *shp;
+    int                 i;
+    ADV_DCNT            resid_cnt;
+
+
+    ASC_DBG2(1, "adv_isr_callback: adv_dvc_varp 0x%lx, scsiqp 0x%lx\n",
+        (ulong) adv_dvc_varp, (ulong) scsiqp);
+    ASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);
+
+    /*
+     * Get the adv_req_t structure for the command that has been
+     * completed. The adv_req_t structure actually contains the
+     * completed ADV_SCSI_REQ_Q structure.
+     */
+    reqp = (adv_req_t *) ADV_U32_TO_VADDR(scsiqp->srb_ptr);
+    ASC_DBG1(1, "adv_isr_callback: reqp 0x%lx\n", (ulong) reqp);
+    if (reqp == NULL) {
+        ASC_PRINT("adv_isr_callback: reqp is NULL\n");
+        return;
+    }
+
+    /*
+     * Get the struct scsi_cmnd structure and Scsi_Host structure for the
+     * command that has been completed.
+     *
+     * Note: The adv_req_t request structure and adv_sgblk_t structure,
+     * if any, are dropped, because a board structure pointer can not be
+     * determined.
+     */
+    scp = reqp->cmndp;
+    ASC_DBG1(1, "adv_isr_callback: scp 0x%lx\n", (ulong) scp);
+    if (scp == NULL) {
+        ASC_PRINT("adv_isr_callback: scp is NULL; adv_req_t dropped.\n");
+        return;
+    }
+    ASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);
+
+    /*
+     * If the request's host pointer is not valid, display a message
+     * and return.
+     */
+    shp = scp->device->host;
+    for (i = 0; i < asc_board_count; i++) {
+        if (asc_host[i] == shp) {
+            break;
+        }
+    }
+    /*
+     * Note: If the host structure is not found, the adv_req_t request
+     * structure and adv_sgblk_t structure, if any, is dropped.
+     */
+    if (i == asc_board_count) {
+        ASC_PRINT2(
+            "adv_isr_callback: scp 0x%lx has bad host pointer, host 0x%lx\n",
+            (ulong) scp, (ulong) shp);
+        return;
+    }
+
+    ASC_STATS(shp, callback);
+    ASC_DBG1(1, "adv_isr_callback: shp 0x%lx\n", (ulong) shp);
+
+    /*
+     * If the request isn't found on the active queue, it may have been
+     * removed to handle a reset request. Display a message and return.
+     *
+     * Note: Because the structure may still be in use don't attempt
+     * to free the adv_req_t and adv_sgblk_t, if any, structures.
+     */
+    boardp = ASC_BOARDP(shp);
+    ASC_ASSERT(adv_dvc_varp == &boardp->dvc_var.adv_dvc_var);
+    if (asc_rmqueue(&boardp->active, scp) == ASC_FALSE) {
+        ASC_PRINT2(
+            "adv_isr_callback: board %d: scp 0x%lx not on active queue\n",
+            boardp->id, (ulong) scp);
+        return;
+    }
+
+    /*
+     * 'done_status' contains the command's ending status.
+     */
+    switch (scsiqp->done_status) {
+    case QD_NO_ERROR:
+        ASC_DBG(2, "adv_isr_callback: QD_NO_ERROR\n");
+        scp->result = 0;
+
+        /*
+         * Check for an underrun condition.
+         *
+         * If there was no error and an underrun condition, then
+         * then return the number of underrun bytes.
+         */
+        resid_cnt = le32_to_cpu(scsiqp->data_cnt);
+        if (scp->request_bufflen != 0 && resid_cnt != 0 &&
+            resid_cnt <= scp->request_bufflen) {
+            ASC_DBG1(1, "adv_isr_callback: underrun condition %lu bytes\n",
+                (ulong) resid_cnt);
+            scp->resid = resid_cnt;
+        }
+        break;
+
+    case QD_WITH_ERROR:
+        ASC_DBG(2, "adv_isr_callback: QD_WITH_ERROR\n");
+        switch (scsiqp->host_status) {
+        case QHSTA_NO_ERROR:
+            if (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {
+                ASC_DBG(2, "adv_isr_callback: SAM_STAT_CHECK_CONDITION\n");
+                ASC_DBG_PRT_SENSE(2, scp->sense_buffer,
+                    sizeof(scp->sense_buffer));
+                /*
+                 * Note: The 'status_byte()' macro used by target drivers
+                 * defined in scsi.h shifts the status byte returned by
+                 * host drivers right by 1 bit. This is why target drivers
+                 * also use right shifted status byte definitions. For
+                 * instance target drivers use CHECK_CONDITION, defined to
+                 * 0x1, instead of the SCSI defined check condition value
+                 * of 0x2. Host drivers are supposed to return the status
+                 * byte as it is defined by SCSI.
+                 */
+                scp->result = DRIVER_BYTE(DRIVER_SENSE) |
+                    STATUS_BYTE(scsiqp->scsi_status);
+            } else {
+                scp->result = STATUS_BYTE(scsiqp->scsi_status);
+            }
+            break;
+
+        default:
+            /* Some other QHSTA error occurred. */
+            ASC_DBG1(1, "adv_isr_callback: host_status 0x%x\n",
+                scsiqp->host_status);
+            scp->result = HOST_BYTE(DID_BAD_TARGET);
+            break;
+        }
+        break;
+
+    case QD_ABORTED_BY_HOST:
+        ASC_DBG(1, "adv_isr_callback: QD_ABORTED_BY_HOST\n");
+        scp->result = HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);
+        break;
+
+    default:
+        ASC_DBG1(1, "adv_isr_callback: done_status 0x%x\n", scsiqp->done_status);
+        scp->result = HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);
+        break;
+    }
+
+    /*
+     * If the 'init_tidmask' bit isn't already set for the target and the
+     * current request finished normally, then set the bit for the target
+     * to indicate that a device is present.
+     */
+    if ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&
+        scsiqp->done_status == QD_NO_ERROR &&
+        scsiqp->host_status == QHSTA_NO_ERROR) {
+        boardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);
+    }
+
+    /*
+     * Because interrupts may be enabled by the 'struct scsi_cmnd' done
+     * function, add the command to the end of the board's done queue.
+     * The done function for the command will be called from
+     * advansys_interrupt().
+     */
+    asc_enqueue(&boardp->done, scp, ASC_BACK);
+
+    /*
+     * Free all 'adv_sgblk_t' structures allocated for the request.
+     */
+    while ((sgblkp = reqp->sgblkp) != NULL)
+    {
+        /* Remove 'sgblkp' from the request list. */
+        reqp->sgblkp = sgblkp->next_sgblkp;
+
+        /* Add 'sgblkp' to the board free list. */
+        sgblkp->next_sgblkp = boardp->adv_sgblkp;
+        boardp->adv_sgblkp = sgblkp;
+    }
+
+    /*
+     * Free the adv_req_t structure used with the command by adding
+     * it back to the board free list.
+     */
+    reqp->next_reqp = boardp->adv_reqp;
+    boardp->adv_reqp = reqp;
+
+    ASC_DBG(1, "adv_isr_callback: done\n");
+
+    return;
+}
+
+/*
+ * adv_async_callback() - Adv Library asynchronous event callback function.
+ */
+STATIC void
+adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)
+{
+    switch (code)
+    {
+    case ADV_ASYNC_SCSI_BUS_RESET_DET:
+        /*
+         * The firmware detected a SCSI Bus reset.
+         */
+        ASC_DBG(0, "adv_async_callback: ADV_ASYNC_SCSI_BUS_RESET_DET\n");
+        break;
+
+    case ADV_ASYNC_RDMA_FAILURE:
+        /*
+         * Handle RDMA failure by resetting the SCSI Bus and
+         * possibly the chip if it is unresponsive. Log the error
+         * with a unique code.
+         */
+        ASC_DBG(0, "adv_async_callback: ADV_ASYNC_RDMA_FAILURE\n");
+        AdvResetChipAndSB(adv_dvc_varp);
+        break;
+
+    case ADV_HOST_SCSI_BUS_RESET:
+        /*
+         * Host generated SCSI bus reset occurred.
+         */
+        ASC_DBG(0, "adv_async_callback: ADV_HOST_SCSI_BUS_RESET\n");
+        break;
+
+    default:
+        ASC_DBG1(0, "DvcAsyncCallBack: unknown code 0x%x\n", code);
+        break;
+    }
+}
+
+/*
+ * Add a 'REQP' to the end of specified queue. Set 'tidmask'
+ * to indicate a command is queued for the device.
+ *
+ * 'flag' may be either ASC_FRONT or ASC_BACK.
+ *
+ * 'REQPNEXT(reqp)' returns reqp's next pointer.
+ */
+STATIC void
+asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
+{
+    int        tid;
+
+    ASC_DBG3(3, "asc_enqueue: ascq 0x%lx, reqp 0x%lx, flag %d\n",
+        (ulong) ascq, (ulong) reqp, flag);
+    ASC_ASSERT(reqp != NULL);
+    ASC_ASSERT(flag == ASC_FRONT || flag == ASC_BACK);
+    tid = REQPTID(reqp);
+    ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
+    if (flag == ASC_FRONT) {
+        reqp->host_scribble = (unsigned char *)ascq->q_first[tid];
+        ascq->q_first[tid] = reqp;
+        /* If the queue was empty, set the last pointer. */
+        if (ascq->q_last[tid] == NULL) {
+            ascq->q_last[tid] = reqp;
+        }
+    } else { /* ASC_BACK */
+        if (ascq->q_last[tid] != NULL) {
+            ascq->q_last[tid]->host_scribble = (unsigned char *)reqp;
+        }
+        ascq->q_last[tid] = reqp;
+        reqp->host_scribble = NULL;
+        /* If the queue was empty, set the first pointer. */
+        if (ascq->q_first[tid] == NULL) {
+            ascq->q_first[tid] = reqp;
+        }
+    }
+    /* The queue has at least one entry, set its bit. */
+    ascq->q_tidmask |= ADV_TID_TO_TIDMASK(tid);
+#ifdef ADVANSYS_STATS
+    /* Maintain request queue statistics. */
+    ascq->q_tot_cnt[tid]++;
+    ascq->q_cur_cnt[tid]++;
+    if (ascq->q_cur_cnt[tid] > ascq->q_max_cnt[tid]) {
+        ascq->q_max_cnt[tid] = ascq->q_cur_cnt[tid];
+        ASC_DBG2(2, "asc_enqueue: new q_max_cnt[%d] %d\n",
+            tid, ascq->q_max_cnt[tid]);
+    }
+    REQPTIME(reqp) = REQTIMESTAMP();
+#endif /* ADVANSYS_STATS */
+    ASC_DBG1(3, "asc_enqueue: reqp 0x%lx\n", (ulong) reqp);
+    return;
+}
+
+/*
+ * Return first queued 'REQP' on the specified queue for
+ * the specified target device. Clear the 'tidmask' bit for
+ * the device if no more commands are left queued for it.
+ *
+ * 'REQPNEXT(reqp)' returns reqp's next pointer.
+ */
+STATIC REQP
+asc_dequeue(asc_queue_t *ascq, int tid)
+{
+    REQP    reqp;
+
+    ASC_DBG2(3, "asc_dequeue: ascq 0x%lx, tid %d\n", (ulong) ascq, tid);
+    ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
+    if ((reqp = ascq->q_first[tid]) != NULL) {
+        ASC_ASSERT(ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid));
+        ascq->q_first[tid] = REQPNEXT(reqp);
+        /* If the queue is empty, clear its bit and the last pointer. */
+        if (ascq->q_first[tid] == NULL) {
+            ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
+            ASC_ASSERT(ascq->q_last[tid] == reqp);
+            ascq->q_last[tid] = NULL;
+        }
+#ifdef ADVANSYS_STATS
+        /* Maintain request queue statistics. */
+        ascq->q_cur_cnt[tid]--;
+        ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
+        REQTIMESTAT("asc_dequeue", ascq, reqp, tid);
+#endif /* ADVANSYS_STATS */
+    }
+    ASC_DBG1(3, "asc_dequeue: reqp 0x%lx\n", (ulong) reqp);
+    return reqp;
+}
+
+/*
+ * Return a pointer to a singly linked list of all the requests queued
+ * for 'tid' on the 'asc_queue_t' pointed to by 'ascq'.
+ *
+ * If 'lastpp' is not NULL, '*lastpp' will be set to point to the
+ * the last request returned in the singly linked list.
+ *
+ * 'tid' should either be a valid target id or if it is ASC_TID_ALL,
+ * then all queued requests are concatenated into one list and
+ * returned.
+ *
+ * Note: If 'lastpp' is used to append a new list to the end of
+ * an old list, only change the old list last pointer if '*lastpp'
+ * (or the function return value) is not NULL, i.e. use a temporary
+ * variable for 'lastpp' and check its value after the function return
+ * before assigning it to the list last pointer.
+ *
+ * Unfortunately collecting queuing time statistics adds overhead to
+ * the function that isn't inherent to the function's algorithm.
+ */
+STATIC REQP
+asc_dequeue_list(asc_queue_t *ascq, REQP *lastpp, int tid)
+{
+    REQP    firstp, lastp;
+    int     i;
+
+    ASC_DBG2(3, "asc_dequeue_list: ascq 0x%lx, tid %d\n", (ulong) ascq, tid);
+    ASC_ASSERT((tid == ASC_TID_ALL) || (tid >= 0 && tid <= ADV_MAX_TID));
+
+    /*
+     * If 'tid' is not ASC_TID_ALL, return requests only for
+     * the specified 'tid'. If 'tid' is ASC_TID_ALL, return all
+     * requests for all tids.
+     */
+    if (tid != ASC_TID_ALL) {
+        /* Return all requests for the specified 'tid'. */
+        if ((ascq->q_tidmask & ADV_TID_TO_TIDMASK(tid)) == 0) {
+            /* List is empty; Set first and last return pointers to NULL. */
+            firstp = lastp = NULL;
+        } else {
+            firstp = ascq->q_first[tid];
+            lastp = ascq->q_last[tid];
+            ascq->q_first[tid] = ascq->q_last[tid] = NULL;
+            ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
+#ifdef ADVANSYS_STATS
+            {
+                REQP reqp;
+                ascq->q_cur_cnt[tid] = 0;
+                for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
+                    REQTIMESTAT("asc_dequeue_list", ascq, reqp, tid);
+                }
+            }
+#endif /* ADVANSYS_STATS */
+        }
+    } else {
+        /* Return all requests for all tids. */
+        firstp = lastp = NULL;
+        for (i = 0; i <= ADV_MAX_TID; i++) {
+            if (ascq->q_tidmask & ADV_TID_TO_TIDMASK(i)) {
+                if (firstp == NULL) {
+                    firstp = ascq->q_first[i];
+                    lastp = ascq->q_last[i];
+                } else {
+                    ASC_ASSERT(lastp != NULL);
+                    lastp->host_scribble = (unsigned char *)ascq->q_first[i];
+                    lastp = ascq->q_last[i];
+                }
+                ascq->q_first[i] = ascq->q_last[i] = NULL;
+                ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(i);
+#ifdef ADVANSYS_STATS
+                ascq->q_cur_cnt[i] = 0;
+#endif /* ADVANSYS_STATS */
+            }
+        }
+#ifdef ADVANSYS_STATS
+        {
+            REQP reqp;
+            for (reqp = firstp; reqp; reqp = REQPNEXT(reqp)) {
+                REQTIMESTAT("asc_dequeue_list", ascq, reqp, reqp->device->id);
+            }
+        }
+#endif /* ADVANSYS_STATS */
+    }
+    if (lastpp) {
+        *lastpp = lastp;
+    }
+    ASC_DBG1(3, "asc_dequeue_list: firstp 0x%lx\n", (ulong) firstp);
+    return firstp;
+}
+
+/*
+ * Remove the specified 'REQP' from the specified queue for
+ * the specified target device. Clear the 'tidmask' bit for the
+ * device if no more commands are left queued for it.
+ *
+ * 'REQPNEXT(reqp)' returns reqp's the next pointer.
+ *
+ * Return ASC_TRUE if the command was found and removed,
+ * otherwise return ASC_FALSE.
+ */
+STATIC int
+asc_rmqueue(asc_queue_t *ascq, REQP reqp)
+{
+    REQP        currp, prevp;
+    int         tid;
+    int         ret = ASC_FALSE;
+
+    ASC_DBG2(3, "asc_rmqueue: ascq 0x%lx, reqp 0x%lx\n",
+        (ulong) ascq, (ulong) reqp);
+    ASC_ASSERT(reqp != NULL);
+
+    tid = REQPTID(reqp);
+    ASC_ASSERT(tid >= 0 && tid <= ADV_MAX_TID);
+
+    /*
+     * Handle the common case of 'reqp' being the first
+     * entry on the queue.
+     */
+    if (reqp == ascq->q_first[tid]) {
+        ret = ASC_TRUE;
+        ascq->q_first[tid] = REQPNEXT(reqp);
+        /* If the queue is now empty, clear its bit and the last pointer. */
+        if (ascq->q_first[tid] == NULL) {
+            ascq->q_tidmask &= ~ADV_TID_TO_TIDMASK(tid);
+            ASC_ASSERT(ascq->q_last[tid] == reqp);
+            ascq->q_last[tid] = NULL;
+        }
+    } else if (ascq->q_first[tid] != NULL) {
+        ASC_ASSERT(ascq->q_last[tid] != NULL);
+        /*
+         * Because the case of 'reqp' being the first entry has been
+         * handled above and it is known the queue is not empty, if
+         * 'reqp' is found on the queue it is guaranteed the queue will
+         * not become empty and that 'q_first[tid]' will not be changed.
+         *
+         * Set 'prevp' to the first entry, 'currp' to the second entry,
+         * and search for 'reqp'.
+         */
+        for (prevp = ascq->q_first[tid], currp = REQPNEXT(prevp);
+             currp; prevp = currp, currp = REQPNEXT(currp)) {
+            if (currp == reqp) {
+                ret = ASC_TRUE;
+                prevp->host_scribble = (unsigned char *)REQPNEXT(currp);
+                reqp->host_scribble = NULL;
+                if (ascq->q_last[tid] == reqp) {
+                    ascq->q_last[tid] = prevp;
+                }
+                break;
+            }
+        }
+    }
+#ifdef ADVANSYS_STATS
+    /* Maintain request queue statistics. */
+    if (ret == ASC_TRUE) {
+        ascq->q_cur_cnt[tid]--;
+        REQTIMESTAT("asc_rmqueue", ascq, reqp, tid);
+    }
+    ASC_ASSERT(ascq->q_cur_cnt[tid] >= 0);
+#endif /* ADVANSYS_STATS */
+    ASC_DBG2(3, "asc_rmqueue: reqp 0x%lx, ret %d\n", (ulong) reqp, ret);
+    return ret;
+}
+
+/*
+ * Execute as many queued requests as possible for the specified queue.
+ *
+ * Calls asc_execute_scsi_cmnd() to execute a REQP/struct scsi_cmnd.
+ */
+STATIC void
+asc_execute_queue(asc_queue_t *ascq)
+{
+    ADV_SCSI_BIT_ID_TYPE    scan_tidmask;
+    REQP                    reqp;
+    int                     i;
+
+    ASC_DBG1(1, "asc_execute_queue: ascq 0x%lx\n", (ulong) ascq);
+    /*
+     * Execute queued commands for devices attached to
+     * the current board in round-robin fashion.
+     */
+    scan_tidmask = ascq->q_tidmask;
+    do {
+        for (i = 0; i <= ADV_MAX_TID; i++) {
+            if (scan_tidmask & ADV_TID_TO_TIDMASK(i)) {
+                if ((reqp = asc_dequeue(ascq, i)) == NULL) {
+                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
+                } else if (asc_execute_scsi_cmnd((struct scsi_cmnd *) reqp)
+                            == ASC_BUSY) {
+                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
+                    /*
+                     * The request returned ASC_BUSY. Enqueue at the front of
+                     * target's waiting list to maintain correct ordering.
+                     */
+                    asc_enqueue(ascq, reqp, ASC_FRONT);
+                }
+            }
+        }
+    } while (scan_tidmask);
+    return;
+}
+
+#ifdef CONFIG_PROC_FS
+/*
+ * asc_prt_board_devices()
+ *
+ * Print driver information for devices attached to the board.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_board_devices(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t        *boardp;
+    int                leftlen;
+    int                totlen;
+    int                len;
+    int                chip_scsi_id;
+    int                i;
+
+    boardp = ASC_BOARDP(shp);
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen,
+"\nDevice Information for AdvanSys SCSI Host %d:\n", shp->host_no);
+    ASC_PRT_NEXT();
+
+    if (ASC_NARROW_BOARD(boardp)) {
+        chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+    } else {
+        chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+    }
+
+    len = asc_prt_line(cp, leftlen, "Target IDs Detected:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) {
+            len = asc_prt_line(cp, leftlen, " %X,", i);
+            ASC_PRT_NEXT();
+        }
+    }
+    len = asc_prt_line(cp, leftlen, " (%X=Host Adapter)\n", chip_scsi_id);
+    ASC_PRT_NEXT();
+
+    return totlen;
+}
+
+/*
+ * Display Wide Board BIOS Information.
+ */
+STATIC int
+asc_prt_adv_bios(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t        *boardp;
+    int                leftlen;
+    int                totlen;
+    int                len;
+    ushort             major, minor, letter;
+
+    boardp = ASC_BOARDP(shp);
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen, "\nROM BIOS Version: ");
+    ASC_PRT_NEXT();
+
+    /*
+     * If the BIOS saved a valid signature, then fill in
+     * the BIOS code segment base address.
+     */
+    if (boardp->bios_signature != 0x55AA) {
+        len = asc_prt_line(cp, leftlen, "Disabled or Pre-3.1\n");
+        ASC_PRT_NEXT();
+        len = asc_prt_line(cp, leftlen,
+"BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\n");
+        ASC_PRT_NEXT();
+        len = asc_prt_line(cp, leftlen,
+"can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\n");
+        ASC_PRT_NEXT();
+    } else {
+        major = (boardp->bios_version >> 12) & 0xF;
+        minor = (boardp->bios_version >> 8) & 0xF;
+        letter = (boardp->bios_version & 0xFF);
+
+        len = asc_prt_line(cp, leftlen, "%d.%d%c\n",
+            major, minor, letter >= 26 ? '?' : letter + 'A');
+        ASC_PRT_NEXT();
+
+        /*
+         * Current available ROM BIOS release is 3.1I for UW
+         * and 3.2I for U2W. This code doesn't differentiate
+         * UW and U2W boards.
+         */
+        if (major < 3 || (major <= 3 && minor < 1) ||
+            (major <= 3 && minor <= 1 && letter < ('I'- 'A'))) {
+            len = asc_prt_line(cp, leftlen,
+"Newer version of ROM BIOS is available at the ConnectCom FTP site:\n");
+            ASC_PRT_NEXT();
+            len = asc_prt_line(cp, leftlen,
+"ftp://ftp.connectcom.net/pub\n");
+            ASC_PRT_NEXT();
+        }
+    }
+
+    return totlen;
+}
+
+/*
+ * Add serial number to information bar if signature AAh
+ * is found in at bit 15-9 (7 bits) of word 1.
+ *
+ * Serial Number consists fo 12 alpha-numeric digits.
+ *
+ *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)
+ *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)
+ *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)
+ *       5 - Product revision (A-J)    Word0:  "         "
+ *
+ *           Signature                 Word1: 15-9 (7 bits)
+ *       6 - Year (0-9)                Word1: 8-6 (3 bits) & Word2: 15 (1 bit)
+ *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)
+ *
+ *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)
+ *
+ * Note 1: Only production cards will have a serial number.
+ *
+ * Note 2: Signature is most significant 7 bits (0xFE).
+ *
+ * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.
+ */
+STATIC int
+asc_get_eeprom_string(ushort *serialnum, uchar *cp)
+{
+    ushort      w, num;
+
+    if ((serialnum[1] & 0xFE00) != ((ushort) 0xAA << 8)) {
+        return ASC_FALSE;
+    } else {
+        /*
+         * First word - 6 digits.
+         */
+        w = serialnum[0];
+
+        /* Product type - 1st digit. */
+        if ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {
+            /* Product type is P=Prototype */
+            *cp += 0x8;
+        }
+        cp++;
+
+        /* Manufacturing location - 2nd digit. */
+        *cp++ = 'A' + ((w & 0x1C00) >> 10);
+
+        /* Product ID - 3rd, 4th digits. */
+        num = w & 0x3FF;
+        *cp++ = '0' + (num / 100);
+        num %= 100;
+        *cp++ = '0' + (num / 10);
+
+        /* Product revision - 5th digit. */
+        *cp++ = 'A' + (num % 10);
+
+        /*
+         * Second word
+         */
+        w = serialnum[1];
+
+        /*
+         * Year - 6th digit.
+         *
+         * If bit 15 of third word is set, then the
+         * last digit of the year is greater than 7.
+         */
+        if (serialnum[2] & 0x8000) {
+            *cp++ = '8' + ((w & 0x1C0) >> 6);
+        } else {
+            *cp++ = '0' + ((w & 0x1C0) >> 6);
+        }
+
+        /* Week of year - 7th, 8th digits. */
+        num = w & 0x003F;
+        *cp++ = '0' + num / 10;
+        num %= 10;
+        *cp++ = '0' + num;
+
+        /*
+         * Third word
+         */
+        w = serialnum[2] & 0x7FFF;
+
+        /* Serial number - 9th digit. */
+        *cp++ = 'A' + (w / 1000);
+
+        /* 10th, 11th, 12th digits. */
+        num = w % 1000;
+        *cp++ = '0' + num / 100;
+        num %= 100;
+        *cp++ = '0' + num / 10;
+        num %= 10;
+        *cp++ = '0' + num;
+
+        *cp = '\0';     /* Null Terminate the string. */
+        return ASC_TRUE;
+    }
+}
+
+/*
+ * asc_prt_asc_board_eeprom()
+ *
+ * Print board EEPROM configuration.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_asc_board_eeprom(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t        *boardp;
+    ASC_DVC_VAR        *asc_dvc_varp;
+    int                leftlen;
+    int                totlen;
+    int                len;
+    ASCEEP_CONFIG      *ep;
+    int                i;
+#ifdef CONFIG_ISA
+    int                isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };
+#endif /* CONFIG_ISA */
+    uchar              serialstr[13];
+
+    boardp = ASC_BOARDP(shp);
+    asc_dvc_varp = &boardp->dvc_var.asc_dvc_var;
+    ep = &boardp->eep_config.asc_eep;
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen,
+"\nEEPROM Settings for AdvanSys SCSI Host %d:\n", shp->host_no);
+    ASC_PRT_NEXT();
+
+    if (asc_get_eeprom_string((ushort *) &ep->adapter_info[0], serialstr) ==
+        ASC_TRUE) {
+        len = asc_prt_line(cp, leftlen, " Serial Number: %s\n", serialstr);
+        ASC_PRT_NEXT();
+    } else {
+        if (ep->adapter_info[5] == 0xBB) {
+            len = asc_prt_line(cp, leftlen,
+                " Default Settings Used for EEPROM-less Adapter.\n");
+            ASC_PRT_NEXT();
+        } else {
+            len = asc_prt_line(cp, leftlen,
+                " Serial Number Signature Not Present.\n");
+            ASC_PRT_NEXT();
+        }
+    }
+
+    len = asc_prt_line(cp, leftlen,
+" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+        ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng, ep->max_tag_qng);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" cntl 0x%x, no_scam 0x%x\n",
+        ep->cntl, ep->no_scam);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Target ID:           ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %d", i);
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Disconnects:         ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Command Queuing:     ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Start Motor:         ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Synchronous Transfer:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+#ifdef CONFIG_ISA
+    if (asc_dvc_varp->bus_type & ASC_IS_ISA) {
+        len = asc_prt_line(cp, leftlen,
+" Host ISA DMA speed:   %d MB/S\n",
+            isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);
+        ASC_PRT_NEXT();
+    }
+#endif /* CONFIG_ISA */
+
+     return totlen;
+}
+
+/*
+ * asc_prt_adv_board_eeprom()
+ *
+ * Print board EEPROM configuration.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_adv_board_eeprom(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t                 *boardp;
+    ADV_DVC_VAR                 *adv_dvc_varp;
+    int                         leftlen;
+    int                         totlen;
+    int                         len;
+    int                         i;
+    char                        *termstr;
+    uchar                       serialstr[13];
+    ADVEEP_3550_CONFIG          *ep_3550 = NULL;
+    ADVEEP_38C0800_CONFIG       *ep_38C0800 = NULL;
+    ADVEEP_38C1600_CONFIG       *ep_38C1600 = NULL;
+    ushort                      word;
+    ushort                      *wordp;
+    ushort                      sdtr_speed = 0;
+
+    boardp = ASC_BOARDP(shp);
+    adv_dvc_varp = &boardp->dvc_var.adv_dvc_var;
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        ep_3550 = &boardp->eep_config.adv_3550_eep;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        ep_38C0800 = &boardp->eep_config.adv_38C0800_eep;
+    } else
+    {
+        ep_38C1600 = &boardp->eep_config.adv_38C1600_eep;
+    }
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen,
+"\nEEPROM Settings for AdvanSys SCSI Host %d:\n", shp->host_no);
+    ASC_PRT_NEXT();
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        wordp = &ep_3550->serial_number_word1;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        wordp = &ep_38C0800->serial_number_word1;
+    } else
+    {
+        wordp = &ep_38C1600->serial_number_word1;
+    }
+
+    if (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE) {
+        len = asc_prt_line(cp, leftlen, " Serial Number: %s\n", serialstr);
+        ASC_PRT_NEXT();
+    } else {
+        len = asc_prt_line(cp, leftlen,
+            " Serial Number Signature Not Present.\n");
+        ASC_PRT_NEXT();
+    }
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        len = asc_prt_line(cp, leftlen,
+" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+            ep_3550->adapter_scsi_id, ep_3550->max_host_qng,
+            ep_3550->max_dvc_qng);
+        ASC_PRT_NEXT();
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        len = asc_prt_line(cp, leftlen,
+" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+            ep_38C0800->adapter_scsi_id, ep_38C0800->max_host_qng,
+            ep_38C0800->max_dvc_qng);
+        ASC_PRT_NEXT();
+    } else
+    {
+        len = asc_prt_line(cp, leftlen,
+" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\n",
+            ep_38C1600->adapter_scsi_id, ep_38C1600->max_host_qng,
+            ep_38C1600->max_dvc_qng);
+        ASC_PRT_NEXT();
+    }
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        word = ep_3550->termination;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        word = ep_38C0800->termination_lvd;
+    } else
+    {
+        word = ep_38C1600->termination_lvd;
+    }
+    switch (word) {
+        case 1:
+            termstr = "Low Off/High Off";
+            break;
+        case 2:
+            termstr = "Low Off/High On";
+            break;
+        case 3:
+            termstr = "Low On/High On";
+            break;
+        default:
+        case 0:
+            termstr = "Automatic";
+            break;
+    }
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        len = asc_prt_line(cp, leftlen,
+" termination: %u (%s), bios_ctrl: 0x%x\n",
+            ep_3550->termination, termstr, ep_3550->bios_ctrl);
+        ASC_PRT_NEXT();
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        len = asc_prt_line(cp, leftlen,
+" termination: %u (%s), bios_ctrl: 0x%x\n",
+            ep_38C0800->termination_lvd, termstr, ep_38C0800->bios_ctrl);
+        ASC_PRT_NEXT();
+    } else
+    {
+        len = asc_prt_line(cp, leftlen,
+" termination: %u (%s), bios_ctrl: 0x%x\n",
+            ep_38C1600->termination_lvd, termstr, ep_38C1600->bios_ctrl);
+        ASC_PRT_NEXT();
+    }
+
+    len = asc_prt_line(cp, leftlen,
+" Target ID:           ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %X", i);
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        word = ep_3550->disc_enable;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        word = ep_38C0800->disc_enable;
+    } else
+    {
+        word = ep_38C1600->disc_enable;
+    }
+    len = asc_prt_line(cp, leftlen,
+" Disconnects:         ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        word = ep_3550->tagqng_able;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        word = ep_38C0800->tagqng_able;
+    } else
+    {
+        word = ep_38C1600->tagqng_able;
+    }
+    len = asc_prt_line(cp, leftlen,
+" Command Queuing:     ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        word = ep_3550->start_motor;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        word = ep_38C0800->start_motor;
+    } else
+    {
+        word = ep_38C1600->start_motor;
+    }
+    len = asc_prt_line(cp, leftlen,
+" Start Motor:         ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        len = asc_prt_line(cp, leftlen,
+" Synchronous Transfer:");
+        ASC_PRT_NEXT();
+        for (i = 0; i <= ADV_MAX_TID; i++) {
+            len = asc_prt_line(cp, leftlen, " %c",
+                (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+            ASC_PRT_NEXT();
+        }
+        len = asc_prt_line(cp, leftlen, "\n");
+        ASC_PRT_NEXT();
+    }
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        len = asc_prt_line(cp, leftlen,
+" Ultra Transfer:      ");
+    ASC_PRT_NEXT();
+        for (i = 0; i <= ADV_MAX_TID; i++) {
+            len = asc_prt_line(cp, leftlen, " %c",
+                (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+            ASC_PRT_NEXT();
+        }
+        len = asc_prt_line(cp, leftlen, "\n");
+        ASC_PRT_NEXT();
+    }
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)
+    {
+        word = ep_3550->wdtr_able;
+    } else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        word = ep_38C0800->wdtr_able;
+    } else
+    {
+        word = ep_38C1600->wdtr_able;
+    }
+    len = asc_prt_line(cp, leftlen,
+" Wide Transfer:       ");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        len = asc_prt_line(cp, leftlen, " %c",
+            (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||
+        adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600)
+    {
+        len = asc_prt_line(cp, leftlen,
+" Synchronous Transfer Speed (Mhz):\n  ");
+        ASC_PRT_NEXT();
+        for (i = 0; i <= ADV_MAX_TID; i++) {
+            char *speed_str;
+
+            if (i == 0)
+            {
+                sdtr_speed = adv_dvc_varp->sdtr_speed1;
+            } else if (i == 4)
+            {
+                sdtr_speed = adv_dvc_varp->sdtr_speed2;
+            } else if (i == 8)
+            {
+                sdtr_speed = adv_dvc_varp->sdtr_speed3;
+            } else if (i == 12)
+            {
+                sdtr_speed = adv_dvc_varp->sdtr_speed4;
+            }
+            switch (sdtr_speed & ADV_MAX_TID)
+            {
+                case 0:  speed_str = "Off"; break;
+                case 1:  speed_str = "  5"; break;
+                case 2:  speed_str = " 10"; break;
+                case 3:  speed_str = " 20"; break;
+                case 4:  speed_str = " 40"; break;
+                case 5:  speed_str = " 80"; break;
+                default: speed_str = "Unk"; break;
+            }
+            len = asc_prt_line(cp, leftlen, "%X:%s ", i, speed_str);
+            ASC_PRT_NEXT();
+            if (i == 7)
+            {
+                len = asc_prt_line(cp, leftlen, "\n  ");
+                ASC_PRT_NEXT();
+            }
+            sdtr_speed >>= 4;
+        }
+        len = asc_prt_line(cp, leftlen, "\n");
+        ASC_PRT_NEXT();
+    }
+
+    return totlen;
+}
+
+/*
+ * asc_prt_driver_conf()
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_driver_conf(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t            *boardp;
+    int                    leftlen;
+    int                    totlen;
+    int                    len;
+    int                    chip_scsi_id;
+
+    boardp = ASC_BOARDP(shp);
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen,
+"\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\n",
+        shp->host_no);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" host_busy %u, last_reset %u, max_id %u, max_lun %u, max_channel %u\n",
+        shp->host_busy, shp->last_reset, shp->max_id, shp->max_lun,
+        shp->max_channel);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\n",
+        shp->unique_id, shp->can_queue, shp->this_id, shp->sg_tablesize,
+        shp->cmd_per_lun);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" unchecked_isa_dma %d, use_clustering %d\n",
+        shp->unchecked_isa_dma, shp->use_clustering);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" flags 0x%x, last_reset 0x%x, jiffies 0x%x, asc_n_io_port 0x%x\n",
+        boardp->flags, boardp->last_reset, jiffies, boardp->asc_n_io_port);
+    ASC_PRT_NEXT();
+
+     /* 'shp->n_io_port' may be truncated because it is only one byte. */
+    len = asc_prt_line(cp, leftlen,
+" io_port 0x%x, n_io_port 0x%x\n",
+        shp->io_port, shp->n_io_port);
+    ASC_PRT_NEXT();
+
+    if (ASC_NARROW_BOARD(boardp)) {
+        chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+    } else {
+        chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+    }
+
+    return totlen;
+}
+
+/*
+ * asc_prt_asc_board_info()
+ *
+ * Print dynamic board configuration information.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_asc_board_info(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t            *boardp;
+    int                    chip_scsi_id;
+    int                    leftlen;
+    int                    totlen;
+    int                    len;
+    ASC_DVC_VAR            *v;
+    ASC_DVC_CFG            *c;
+    int                    i;
+    int                    renegotiate = 0;
+
+    boardp = ASC_BOARDP(shp);
+    v = &boardp->dvc_var.asc_dvc_var;
+    c = &boardp->dvc_cfg.asc_dvc_cfg;
+    chip_scsi_id = c->chip_scsi_id;
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen,
+"\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+    shp->host_no);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" chip_version %u, lib_version 0x%x, lib_serial_no %u, mcode_date 0x%x\n",
+        c->chip_version, c->lib_version, c->lib_serial_no, c->mcode_date);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" mcode_version 0x%x, err_code %u\n",
+         c->mcode_version, v->err_code);
+    ASC_PRT_NEXT();
+
+    /* Current number of commands waiting for the host. */
+    len = asc_prt_line(cp, leftlen,
+" Total Command Pending: %d\n", v->cur_total_qng);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Command Queuing:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+        len = asc_prt_line(cp, leftlen, " %X:%c",
+            i, (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    /* Current number of commands waiting for a device. */
+    len = asc_prt_line(cp, leftlen,
+" Command Queue Pending:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+        len = asc_prt_line(cp, leftlen, " %X:%u", i, v->cur_dvc_qng[i]);
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    /* Current limit on number of commands that can be sent to a device. */
+    len = asc_prt_line(cp, leftlen,
+" Command Queue Limit:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+        len = asc_prt_line(cp, leftlen, " %X:%u", i, v->max_dvc_qng[i]);
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    /* Indicate whether the device has returned queue full status. */
+    len = asc_prt_line(cp, leftlen,
+" Command Queue Full:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+        if (boardp->queue_full & ADV_TID_TO_TIDMASK(i)) {
+            len = asc_prt_line(cp, leftlen, " %X:Y-%d",
+                i, boardp->queue_full_cnt[i]);
+        } else {
+            len = asc_prt_line(cp, leftlen, " %X:N", i);
+        }
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Synchronous Transfer:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+        len = asc_prt_line(cp, leftlen, " %X:%c",
+            i, (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        uchar syn_period_ix;
+
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
+            ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        len = asc_prt_line(cp, leftlen, "  %X:", i);
+        ASC_PRT_NEXT();
+
+        if ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0)
+        {
+            len = asc_prt_line(cp, leftlen, " Asynchronous");
+            ASC_PRT_NEXT();
+        } else
+        {
+            syn_period_ix =
+                (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index - 1);
+
+            len = asc_prt_line(cp, leftlen,
+                " Transfer Period Factor: %d (%d.%d Mhz),",
+                v->sdtr_period_tbl[syn_period_ix],
+                250 / v->sdtr_period_tbl[syn_period_ix],
+                ASC_TENTHS(250, v->sdtr_period_tbl[syn_period_ix]));
+            ASC_PRT_NEXT();
+
+            len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
+                boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET);
+            ASC_PRT_NEXT();
+        }
+
+        if ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+            len = asc_prt_line(cp, leftlen, "*\n");
+            renegotiate = 1;
+        } else
+        {
+            len = asc_prt_line(cp, leftlen, "\n");
+        }
+        ASC_PRT_NEXT();
+    }
+
+    if (renegotiate)
+    {
+        len = asc_prt_line(cp, leftlen,
+            " * = Re-negotiation pending before next command.\n");
+        ASC_PRT_NEXT();
+    }
+
+    return totlen;
+}
+
+/*
+ * asc_prt_adv_board_info()
+ *
+ * Print dynamic board configuration information.
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_adv_board_info(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    asc_board_t            *boardp;
+    int                    leftlen;
+    int                    totlen;
+    int                    len;
+    int                    i;
+    ADV_DVC_VAR            *v;
+    ADV_DVC_CFG            *c;
+    AdvPortAddr            iop_base;
+    ushort                 chip_scsi_id;
+    ushort                 lramword;
+    uchar                  lrambyte;
+    ushort                 tagqng_able;
+    ushort                 sdtr_able, wdtr_able;
+    ushort                 wdtr_done, sdtr_done;
+    ushort                 period = 0;
+    int                    renegotiate = 0;
+
+    boardp = ASC_BOARDP(shp);
+    v = &boardp->dvc_var.adv_dvc_var;
+    c = &boardp->dvc_cfg.adv_dvc_cfg;
+    iop_base = v->iop_base;
+    chip_scsi_id = v->chip_scsi_id;
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    len = asc_prt_line(cp, leftlen,
+"\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\n",
+    shp->host_no);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" iop_base 0x%lx, cable_detect: %X, err_code %u\n",
+         v->iop_base,
+         AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1) & CABLE_DETECT,
+         v->err_code);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" chip_version %u, lib_version 0x%x, mcode_date 0x%x, mcode_version 0x%x\n",
+        c->chip_version, c->lib_version, c->mcode_date, c->mcode_version);
+    ASC_PRT_NEXT();
+
+    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+    len = asc_prt_line(cp, leftlen,
+" Queuing Enabled:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        len = asc_prt_line(cp, leftlen, " %X:%c",
+            i, (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Queue Limit:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i, lrambyte);
+
+        len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" Command Pending:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i, lrambyte);
+
+        len = asc_prt_line(cp, leftlen, " %X:%d", i, lrambyte);
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+    len = asc_prt_line(cp, leftlen,
+" Wide Enabled:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        len = asc_prt_line(cp, leftlen, " %X:%c",
+            i, (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);
+    len = asc_prt_line(cp, leftlen,
+" Transfer Bit Width:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        AdvReadWordLram(iop_base, ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
+            lramword);
+
+        len = asc_prt_line(cp, leftlen, " %X:%d",
+            i, (lramword & 0x8000) ? 16 : 8);
+        ASC_PRT_NEXT();
+
+        if ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&
+            (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+            len = asc_prt_line(cp, leftlen, "*");
+            ASC_PRT_NEXT();
+            renegotiate = 1;
+        }
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+    len = asc_prt_line(cp, leftlen,
+" Synchronous Enabled:");
+    ASC_PRT_NEXT();
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        len = asc_prt_line(cp, leftlen, " %X:%c",
+            i, (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');
+        ASC_PRT_NEXT();
+    }
+    len = asc_prt_line(cp, leftlen, "\n");
+    ASC_PRT_NEXT();
+
+    AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);
+    for (i = 0; i <= ADV_MAX_TID; i++) {
+
+        AdvReadWordLram(iop_base, ASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),
+            lramword);
+        lramword &= ~0x8000;
+
+        if ((chip_scsi_id == i) ||
+            ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||
+            ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {
+            continue;
+        }
+
+        len = asc_prt_line(cp, leftlen, "  %X:", i);
+        ASC_PRT_NEXT();
+
+        if ((lramword & 0x1F) == 0) /* Check for REQ/ACK Offset 0. */
+        {
+            len = asc_prt_line(cp, leftlen, " Asynchronous");
+            ASC_PRT_NEXT();
+        } else
+        {
+            len = asc_prt_line(cp, leftlen, " Transfer Period Factor: ");
+            ASC_PRT_NEXT();
+
+            if ((lramword & 0x1F00) == 0x1100) /* 80 Mhz */
+            {
+                len = asc_prt_line(cp, leftlen, "9 (80.0 Mhz),");
+                ASC_PRT_NEXT();
+            } else if ((lramword & 0x1F00) == 0x1000) /* 40 Mhz */
+            {
+                len = asc_prt_line(cp, leftlen, "10 (40.0 Mhz),");
+                ASC_PRT_NEXT();
+            } else /* 20 Mhz or below. */
+            {
+                period = (((lramword >> 8) * 25) + 50)/4;
+
+                if (period == 0) /* Should never happen. */
+                {
+                    len = asc_prt_line(cp, leftlen, "%d (? Mhz), ");
+                    ASC_PRT_NEXT();
+                } else
+                {
+                    len = asc_prt_line(cp, leftlen,
+                        "%d (%d.%d Mhz),",
+                        period, 250/period, ASC_TENTHS(250, period));
+                    ASC_PRT_NEXT();
+                }
+            }
+
+            len = asc_prt_line(cp, leftlen, " REQ/ACK Offset: %d",
+                lramword & 0x1F);
+            ASC_PRT_NEXT();
+        }
+
+        if ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {
+            len = asc_prt_line(cp, leftlen, "*\n");
+            renegotiate = 1;
+        } else
+        {
+            len = asc_prt_line(cp, leftlen, "\n");
+        }
+        ASC_PRT_NEXT();
+    }
+
+    if (renegotiate)
+    {
+        len = asc_prt_line(cp, leftlen,
+            " * = Re-negotiation pending before next command.\n");
+        ASC_PRT_NEXT();
+    }
+
+    return totlen;
+}
+
+/*
+ * asc_proc_copy()
+ *
+ * Copy proc information to a read buffer taking into account the current
+ * read offset in the file and the remaining space in the read buffer.
+ */
+STATIC int
+asc_proc_copy(off_t advoffset, off_t offset, char *curbuf, int leftlen,
+              char *cp, int cplen)
+{
+    int cnt = 0;
+
+    ASC_DBG3(2, "asc_proc_copy: offset %d, advoffset %d, cplen %d\n",
+            (unsigned) offset, (unsigned) advoffset, cplen);
+    if (offset <= advoffset) {
+        /* Read offset below current offset, copy everything. */
+        cnt = min(cplen, leftlen);
+        ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+                (ulong) curbuf, (ulong) cp, cnt);
+        memcpy(curbuf, cp, cnt);
+    } else if (offset < advoffset + cplen) {
+        /* Read offset within current range, partial copy. */
+        cnt = (advoffset + cplen) - offset;
+        cp = (cp + cplen) - cnt;
+        cnt = min(cnt, leftlen);
+        ASC_DBG3(2, "asc_proc_copy: curbuf 0x%lx, cp 0x%lx, cnt %d\n",
+                (ulong) curbuf, (ulong) cp, cnt);
+        memcpy(curbuf, cp, cnt);
+    }
+    return cnt;
+}
+
+/*
+ * asc_prt_line()
+ *
+ * If 'cp' is NULL print to the console, otherwise print to a buffer.
+ *
+ * Return 0 if printing to the console, otherwise return the number of
+ * bytes written to the buffer.
+ *
+ * Note: If any single line is greater than ASC_PRTLINE_SIZE bytes the stack
+ * will be corrupted. 's[]' is defined to be ASC_PRTLINE_SIZE bytes.
+ */
+STATIC int
+asc_prt_line(char *buf, int buflen, char *fmt, ...)
+{
+    va_list        args;
+    int            ret;
+    char           s[ASC_PRTLINE_SIZE];
+
+    va_start(args, fmt);
+    ret = vsprintf(s, fmt, args);
+    ASC_ASSERT(ret < ASC_PRTLINE_SIZE);
+    if (buf == NULL) {
+        (void) printk(s);
+        ret = 0;
+    } else {
+        ret = min(buflen, ret);
+        memcpy(buf, s, ret);
+    }
+    va_end(args);
+    return ret;
+}
+#endif /* CONFIG_PROC_FS */
+
+
+/*
+ * --- Functions Required by the Asc Library
+ */
+
+/*
+ * Delay for 'n' milliseconds. Don't use the 'jiffies'
+ * global variable which is incremented once every 5 ms
+ * from a timer interrupt, because this function may be
+ * called when interrupts are disabled.
+ */
+STATIC void
+DvcSleepMilliSecond(ADV_DCNT n)
+{
+    ASC_DBG1(4, "DvcSleepMilliSecond: %lu\n", (ulong) n);
+    mdelay(n);
+}
+
+/*
+ * Currently and inline noop but leave as a placeholder.
+ * Leave DvcEnterCritical() as a noop placeholder.
+ */
+STATIC inline ulong
+DvcEnterCritical(void)
+{
+    return 0;
+}
+
+/*
+ * Critical sections are all protected by the board spinlock.
+ * Leave DvcLeaveCritical() as a noop placeholder.
+ */
+STATIC inline void
+DvcLeaveCritical(ulong flags)
+{
+    return;
+}
+
+/*
+ * void
+ * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
+ *
+ * Calling/Exit State:
+ *    none
+ *
+ * Description:
+ *     Output an ASC_SCSI_Q structure to the chip
+ */
+STATIC void
+DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)
+{
+    int    i;
+
+    ASC_DBG_PRT_HEX(2, "DvcPutScsiQ", outbuf, 2 * words);
+    AscSetChipLramAddr(iop_base, s_addr);
+    for (i = 0; i < 2 * words; i += 2) {
+        if (i == 4 || i == 20) {
+            continue;
+        }
+        outpw(iop_base + IOP_RAM_DATA,
+            ((ushort) outbuf[i + 1] << 8) | outbuf[i]);
+    }
+}
+
+/*
+ * void
+ * DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
+ *
+ * Calling/Exit State:
+ *    none
+ *
+ * Description:
+ *     Input an ASC_QDONE_INFO structure from the chip
+ */
+STATIC void
+DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)
+{
+    int    i;
+    ushort word;
+
+    AscSetChipLramAddr(iop_base, s_addr);
+    for (i = 0; i < 2 * words; i += 2) {
+        if (i == 10) {
+            continue;
+        }
+        word = inpw(iop_base + IOP_RAM_DATA);
+        inbuf[i] = word & 0xff;
+        inbuf[i + 1] = (word >> 8) & 0xff;
+    }
+    ASC_DBG_PRT_HEX(2, "DvcGetQinfo", inbuf, 2 * words);
+}
+
+/*
+ * Read a PCI configuration byte.
+ */
+STATIC uchar __init
+DvcReadPCIConfigByte(
+        ASC_DVC_VAR *asc_dvc,
+        ushort offset)
+{
+#ifdef CONFIG_PCI
+    uchar byte_data;
+    pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
+    return byte_data;
+#else /* !defined(CONFIG_PCI) */
+    return 0;
+#endif /* !defined(CONFIG_PCI) */
+}
+
+/*
+ * Write a PCI configuration byte.
+ */
+STATIC void __init
+DvcWritePCIConfigByte(
+        ASC_DVC_VAR *asc_dvc,
+        ushort offset,
+        uchar  byte_data)
+{
+#ifdef CONFIG_PCI
+    pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
+#endif /* CONFIG_PCI */
+}
+
+/*
+ * Return the BIOS address of the adapter at the specified
+ * I/O port and with the specified bus type.
+ */
+STATIC ushort __init
+AscGetChipBiosAddress(
+        PortAddr iop_base,
+        ushort bus_type)
+{
+    ushort  cfg_lsw;
+    ushort  bios_addr;
+
+    /*
+     * The PCI BIOS is re-located by the motherboard BIOS. Because
+     * of this the driver can not determine where a PCI BIOS is
+     * loaded and executes.
+     */
+    if (bus_type & ASC_IS_PCI)
+    {
+        return(0);
+    }
+
+#ifdef CONFIG_ISA
+    if((bus_type & ASC_IS_EISA) != 0)
+    {
+        cfg_lsw = AscGetEisaChipCfg(iop_base);
+        cfg_lsw &= 0x000F;
+        bios_addr = (ushort)(ASC_BIOS_MIN_ADDR  +
+                                (cfg_lsw * ASC_BIOS_BANK_SIZE));
+        return(bios_addr);
+    }/* if */
+#endif /* CONFIG_ISA */
+
+    cfg_lsw = AscGetChipCfgLsw(iop_base);
+
+    /*
+    *  ISA PnP uses the top bit as the 32K BIOS flag
+    */
+    if (bus_type == ASC_IS_ISAPNP)
+    {
+        cfg_lsw &= 0x7FFF;
+    }/* if */
+
+    bios_addr = (ushort)(((cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE) +
+            ASC_BIOS_MIN_ADDR);
+    return(bios_addr);
+}
+
+
+/*
+ * --- Functions Required by the Adv Library
+ */
+
+/*
+ * DvcGetPhyAddr()
+ *
+ * Return the physical address of 'vaddr' and set '*lenp' to the
+ * number of physically contiguous bytes that follow 'vaddr'.
+ * 'flag' indicates the type of structure whose physical address
+ * is being translated.
+ *
+ * Note: Because Linux currently doesn't page the kernel and all
+ * kernel buffers are physically contiguous, leave '*lenp' unchanged.
+ */
+ADV_PADDR
+DvcGetPhyAddr(ADV_DVC_VAR *asc_dvc, ADV_SCSI_REQ_Q *scsiq,
+        uchar *vaddr, ADV_SDCNT *lenp, int flag)
+{
+    ADV_PADDR           paddr;
+
+    paddr = virt_to_bus(vaddr);
+
+    ASC_DBG4(4,
+        "DvcGetPhyAddr: vaddr 0x%lx, lenp 0x%lx *lenp %lu, paddr 0x%lx\n",
+        (ulong) vaddr, (ulong) lenp, (ulong) *((ulong *) lenp), (ulong) paddr);
+
+    return paddr;
+}
+
+/*
+ * Read a PCI configuration byte.
+ */
+STATIC uchar __init
+DvcAdvReadPCIConfigByte(
+        ADV_DVC_VAR *asc_dvc,
+        ushort offset)
+{
+#ifdef CONFIG_PCI
+    uchar byte_data;
+    pci_read_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, &byte_data);
+    return byte_data;
+#else /* CONFIG_PCI */
+    return 0;
+#endif /* CONFIG_PCI */
+}
+
+/*
+ * Write a PCI configuration byte.
+ */
+STATIC void __init
+DvcAdvWritePCIConfigByte(
+        ADV_DVC_VAR *asc_dvc,
+        ushort offset,
+        uchar  byte_data)
+{
+#ifdef CONFIG_PCI
+    pci_write_config_byte(to_pci_dev(asc_dvc->cfg->dev), offset, byte_data);
+#else /* CONFIG_PCI */
+    return;
+#endif /* CONFIG_PCI */
+}
+
+/*
+ * --- Tracing and Debugging Functions
+ */
+
+#ifdef ADVANSYS_STATS
+#ifdef CONFIG_PROC_FS
+/*
+ * asc_prt_board_stats()
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_board_stats(struct Scsi_Host *shp, char *cp, int cplen)
+{
+    int                    leftlen;
+    int                    totlen;
+    int                    len;
+    struct asc_stats       *s;
+    asc_board_t            *boardp;
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    boardp = ASC_BOARDP(shp);
+    s = &boardp->asc_stats;
+
+    len = asc_prt_line(cp, leftlen,
+"\nLinux Driver Statistics for AdvanSys SCSI Host %d:\n", shp->host_no);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" queuecommand %lu, reset %lu, biosparam %lu, interrupt %lu\n",
+        s->queuecommand, s->reset, s->biosparam, s->interrupt);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" callback %lu, done %lu, build_error %lu, build_noreq %lu, build_nosg %lu\n",
+        s->callback, s->done, s->build_error, s->adv_build_noreq,
+        s->adv_build_nosg);
+    ASC_PRT_NEXT();
+
+    len = asc_prt_line(cp, leftlen,
+" exe_noerror %lu, exe_busy %lu, exe_error %lu, exe_unknown %lu\n",
+        s->exe_noerror, s->exe_busy, s->exe_error, s->exe_unknown);
+    ASC_PRT_NEXT();
+
+    /*
+     * Display data transfer statistics.
+     */
+    if (s->cont_cnt > 0) {
+        len = asc_prt_line(cp, leftlen, " cont_cnt %lu, ", s->cont_cnt);
+        ASC_PRT_NEXT();
+
+        len = asc_prt_line(cp, leftlen, "cont_xfer %lu.%01lu kb ",
+                    s->cont_xfer/2,
+                    ASC_TENTHS(s->cont_xfer, 2));
+        ASC_PRT_NEXT();
+
+        /* Contiguous transfer average size */
+        len = asc_prt_line(cp, leftlen, "avg_xfer %lu.%01lu kb\n",
+                    (s->cont_xfer/2)/s->cont_cnt,
+                    ASC_TENTHS((s->cont_xfer/2), s->cont_cnt));
+        ASC_PRT_NEXT();
+    }
+
+    if (s->sg_cnt > 0) {
+
+        len = asc_prt_line(cp, leftlen, " sg_cnt %lu, sg_elem %lu, ",
+                    s->sg_cnt, s->sg_elem);
+        ASC_PRT_NEXT();
+
+        len = asc_prt_line(cp, leftlen, "sg_xfer %lu.%01lu kb\n",
+                    s->sg_xfer/2,
+                    ASC_TENTHS(s->sg_xfer, 2));
+        ASC_PRT_NEXT();
+
+        /* Scatter gather transfer statistics */
+        len = asc_prt_line(cp, leftlen, " avg_num_elem %lu.%01lu, ",
+                    s->sg_elem/s->sg_cnt,
+                    ASC_TENTHS(s->sg_elem, s->sg_cnt));
+        ASC_PRT_NEXT();
+
+        len = asc_prt_line(cp, leftlen, "avg_elem_size %lu.%01lu kb, ",
+                    (s->sg_xfer/2)/s->sg_elem,
+                    ASC_TENTHS((s->sg_xfer/2), s->sg_elem));
+        ASC_PRT_NEXT();
+
+        len = asc_prt_line(cp, leftlen, "avg_xfer_size %lu.%01lu kb\n",
+                    (s->sg_xfer/2)/s->sg_cnt,
+                    ASC_TENTHS((s->sg_xfer/2), s->sg_cnt));
+        ASC_PRT_NEXT();
+    }
+
+    /*
+     * Display request queuing statistics.
+     */
+    len = asc_prt_line(cp, leftlen,
+" Active and Waiting Request Queues (Time Unit: %d HZ):\n", HZ);
+    ASC_PRT_NEXT();
+
+
+     return totlen;
+}
+
+/*
+ * asc_prt_target_stats()
+ *
+ * Note: no single line should be greater than ASC_PRTLINE_SIZE,
+ * cf. asc_prt_line().
+ *
+ * This is separated from asc_prt_board_stats because a full set
+ * of targets will overflow ASC_PRTBUF_SIZE.
+ *
+ * Return the number of characters copied into 'cp'. No more than
+ * 'cplen' characters will be copied to 'cp'.
+ */
+STATIC int
+asc_prt_target_stats(struct Scsi_Host *shp, int tgt_id, char *cp, int cplen)
+{
+    int                    leftlen;
+    int                    totlen;
+    int                    len;
+    struct asc_stats       *s;
+    ushort                 chip_scsi_id;
+    asc_board_t            *boardp;
+    asc_queue_t            *active;
+    asc_queue_t            *waiting;
+
+    leftlen = cplen;
+    totlen = len = 0;
+
+    boardp = ASC_BOARDP(shp);
+    s = &boardp->asc_stats;
+
+    active = &ASC_BOARDP(shp)->active;
+    waiting = &ASC_BOARDP(shp)->waiting;
+
+    if (ASC_NARROW_BOARD(boardp)) {
+        chip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;
+    } else {
+        chip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;
+    }
+
+    if ((chip_scsi_id == tgt_id) ||
+        ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(tgt_id)) == 0)) {
+        return 0;
+    }
+
+    do {
+        if (active->q_tot_cnt[tgt_id] > 0 || waiting->q_tot_cnt[tgt_id] > 0) {
+            len = asc_prt_line(cp, leftlen, " target %d\n", tgt_id);
+            ASC_PRT_NEXT();
+
+            len = asc_prt_line(cp, leftlen,
+"   active: cnt [cur %d, max %d, tot %u], time [min %d, max %d, avg %lu.%01lu]\n",
+                active->q_cur_cnt[tgt_id], active->q_max_cnt[tgt_id],
+                active->q_tot_cnt[tgt_id],
+                active->q_min_tim[tgt_id], active->q_max_tim[tgt_id],
+                (active->q_tot_cnt[tgt_id] == 0) ? 0 :
+                (active->q_tot_tim[tgt_id]/active->q_tot_cnt[tgt_id]),
+                (active->q_tot_cnt[tgt_id] == 0) ? 0 :
+                ASC_TENTHS(active->q_tot_tim[tgt_id],
+                active->q_tot_cnt[tgt_id]));
+             ASC_PRT_NEXT();
+
+             len = asc_prt_line(cp, leftlen,
+"   waiting: cnt [cur %d, max %d, tot %u], time [min %u, max %u, avg %lu.%01lu]\n",
+                waiting->q_cur_cnt[tgt_id], waiting->q_max_cnt[tgt_id],
+                waiting->q_tot_cnt[tgt_id],
+                waiting->q_min_tim[tgt_id], waiting->q_max_tim[tgt_id],
+                (waiting->q_tot_cnt[tgt_id] == 0) ? 0 :
+                (waiting->q_tot_tim[tgt_id]/waiting->q_tot_cnt[tgt_id]),
+                (waiting->q_tot_cnt[tgt_id] == 0) ? 0 :
+                ASC_TENTHS(waiting->q_tot_tim[tgt_id],
+                waiting->q_tot_cnt[tgt_id]));
+             ASC_PRT_NEXT();
+        }
+    } while (0);
+
+     return totlen;
+}
+#endif /* CONFIG_PROC_FS */
+#endif /* ADVANSYS_STATS */
+
+#ifdef ADVANSYS_DEBUG
+/*
+ * asc_prt_scsi_host()
+ */
+STATIC void
+asc_prt_scsi_host(struct Scsi_Host *s)
+{
+    asc_board_t         *boardp;
+
+    boardp = ASC_BOARDP(s);
+
+    printk("Scsi_Host at addr 0x%lx\n", (ulong) s);
+    printk(
+" host_busy %u, host_no %d, last_reset %d,\n",
+        s->host_busy, s->host_no,
+        (unsigned) s->last_reset);
+
+    printk(
+" base 0x%lx, io_port 0x%lx, n_io_port %u, irq 0x%x,\n",
+        (ulong) s->base, (ulong) s->io_port, s->n_io_port, s->irq);
+
+    printk(
+" dma_channel %d, this_id %d, can_queue %d,\n",
+        s->dma_channel, s->this_id, s->can_queue);
+
+    printk(
+" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\n",
+        s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);
+
+    if (ASC_NARROW_BOARD(boardp)) {
+        asc_prt_asc_dvc_var(&ASC_BOARDP(s)->dvc_var.asc_dvc_var);
+        asc_prt_asc_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.asc_dvc_cfg);
+    } else {
+        asc_prt_adv_dvc_var(&ASC_BOARDP(s)->dvc_var.adv_dvc_var);
+        asc_prt_adv_dvc_cfg(&ASC_BOARDP(s)->dvc_cfg.adv_dvc_cfg);
+    }
+}
+
+/*
+ * asc_prt_scsi_cmnd()
+ */
+STATIC void
+asc_prt_scsi_cmnd(struct scsi_cmnd *s)
+{
+    printk("struct scsi_cmnd at addr 0x%lx\n", (ulong) s);
+
+    printk(
+" host 0x%lx, device 0x%lx, target %u, lun %u, channel %u,\n",
+        (ulong) s->device->host, (ulong) s->device, s->device->id, s->device->lun,
+        s->device->channel);
+
+    asc_prt_hex(" CDB", s->cmnd, s->cmd_len);
+
+    printk (
+"sc_data_direction %u, resid %d\n",
+        s->sc_data_direction, s->resid);
+
+    printk(
+" use_sg %u, sglist_len %u, abort_reason 0x%x\n",
+        s->use_sg, s->sglist_len, s->abort_reason);
+
+    printk(
+" serial_number 0x%x, serial_number_at_timeout 0x%x, retries %d, allowed %d\n",
+        (unsigned) s->serial_number, (unsigned) s->serial_number_at_timeout,
+         s->retries, s->allowed);
+
+    printk(
+" timeout_per_command %d, timeout_total %d, timeout %d\n",
+        s->timeout_per_command, s->timeout_total, s->timeout);
+
+    printk(" internal_timeout %u\n", s->internal_timeout);
+
+    printk(
+" scsi_done 0x%lx, done 0x%lx, host_scribble 0x%lx, result 0x%x\n",
+        (ulong) s->scsi_done, (ulong) s->done,
+        (ulong) s->host_scribble, s->result);
+
+    printk(
+" tag %u, pid %u\n",
+        (unsigned) s->tag, (unsigned) s->pid);
+}
+
+/*
+ * asc_prt_asc_dvc_var()
+ */
+STATIC void
+asc_prt_asc_dvc_var(ASC_DVC_VAR *h)
+{
+    printk("ASC_DVC_VAR at addr 0x%lx\n", (ulong) h);
+
+    printk(
+" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl %d,\n",
+        h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);
+
+    printk(
+" bus_type %d, isr_callback 0x%lx, exe_callback 0x%lx, init_sdtr 0x%x,\n",
+        h->bus_type, (ulong) h->isr_callback, (ulong) h->exe_callback,
+        (unsigned) h->init_sdtr);
+
+    printk(
+" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, chip_no 0x%x,\n",
+        (unsigned) h->sdtr_done, (unsigned) h->use_tagged_qng,
+        (unsigned) h->unit_not_ready, (unsigned) h->chip_no);
+
+    printk(
+" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait %u,\n",
+        (unsigned) h->queue_full_or_busy, (unsigned) h->start_motor,
+        (unsigned) h->scsi_reset_wait);
+
+    printk(
+" is_in_int %u, max_total_qng %u, cur_total_qng %u, in_critical_cnt %u,\n",
+        (unsigned) h->is_in_int, (unsigned) h->max_total_qng,
+        (unsigned) h->cur_total_qng, (unsigned) h->in_critical_cnt);
+
+    printk(
+" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, pci_fix_asyn_xfer 0x%x,\n",
+        (unsigned) h->last_q_shortage, (unsigned) h->init_state,
+        (unsigned) h->no_scam, (unsigned) h->pci_fix_asyn_xfer);
+
+    printk(
+" cfg 0x%lx, irq_no 0x%x\n",
+        (ulong) h->cfg, (unsigned) h->irq_no);
+}
+
+/*
+ * asc_prt_asc_dvc_cfg()
+ */
+STATIC void
+asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)
+{
+    printk("ASC_DVC_CFG at addr 0x%lx\n", (ulong) h);
+
+    printk(
+" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\n",
+            h->can_tagged_qng, h->cmd_qng_enabled);
+    printk(
+" disc_enable 0x%x, sdtr_enable 0x%x,\n",
+            h->disc_enable, h->sdtr_enable);
+
+    printk(
+" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, chip_version %d,\n",
+             h->chip_scsi_id, h->isa_dma_speed, h->isa_dma_channel,
+             h->chip_version);
+
+    printk(
+" pci_device_id %d, lib_serial_no %u, lib_version %u, mcode_date 0x%x,\n",
+	   to_pci_dev(h->dev)->device, h->lib_serial_no, h->lib_version,
+	   h->mcode_date);
+
+    printk(
+" mcode_version %d, overrun_buf 0x%lx\n",
+            h->mcode_version, (ulong) h->overrun_buf);
+}
+
+/*
+ * asc_prt_asc_scsi_q()
+ */
+STATIC void
+asc_prt_asc_scsi_q(ASC_SCSI_Q *q)
+{
+    ASC_SG_HEAD    *sgp;
+    int i;
+
+    printk("ASC_SCSI_Q at addr 0x%lx\n", (ulong) q);
+
+    printk(
+" target_ix 0x%x, target_lun %u, srb_ptr 0x%lx, tag_code 0x%x,\n",
+            q->q2.target_ix, q->q1.target_lun,
+            (ulong) q->q2.srb_ptr, q->q2.tag_code);
+
+    printk(
+" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+            (ulong) le32_to_cpu(q->q1.data_addr),
+            (ulong) le32_to_cpu(q->q1.data_cnt),
+            (ulong) le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);
+
+    printk(
+" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\n",
+            (ulong) q->cdbptr, q->q2.cdb_len,
+            (ulong) q->sg_head, q->q1.sg_queue_cnt);
+
+    if (q->sg_head) {
+        sgp = q->sg_head;
+        printk("ASC_SG_HEAD at addr 0x%lx\n", (ulong) sgp);
+        printk(" entry_cnt %u, queue_cnt %u\n", sgp->entry_cnt, sgp->queue_cnt);
+        for (i = 0; i < sgp->entry_cnt; i++) {
+            printk(" [%u]: addr 0x%lx, bytes %lu\n",
+                i, (ulong) le32_to_cpu(sgp->sg_list[i].addr),
+                (ulong) le32_to_cpu(sgp->sg_list[i].bytes));
+        }
+
+    }
+}
+
+/*
+ * asc_prt_asc_qdone_info()
+ */
+STATIC void
+asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)
+{
+    printk("ASC_QDONE_INFO at addr 0x%lx\n", (ulong) q);
+    printk(
+" srb_ptr 0x%lx, target_ix %u, cdb_len %u, tag_code %u,\n",
+            (ulong) q->d2.srb_ptr, q->d2.target_ix, q->d2.cdb_len,
+            q->d2.tag_code);
+    printk(
+" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\n",
+            q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);
+}
+
+/*
+ * asc_prt_adv_dvc_var()
+ *
+ * Display an ADV_DVC_VAR structure.
+ */
+STATIC void
+asc_prt_adv_dvc_var(ADV_DVC_VAR *h)
+{
+    printk(" ADV_DVC_VAR at addr 0x%lx\n", (ulong) h);
+
+    printk(
+"  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\n",
+        (ulong) h->iop_base, h->err_code, (unsigned) h->ultra_able);
+
+    printk(
+"  isr_callback 0x%lx, sdtr_able 0x%x, wdtr_able 0x%x\n",
+        (ulong) h->isr_callback, (unsigned) h->sdtr_able,
+        (unsigned) h->wdtr_able);
+
+    printk(
+"  start_motor 0x%x, scsi_reset_wait 0x%x, irq_no 0x%x,\n",
+        (unsigned) h->start_motor,
+        (unsigned) h->scsi_reset_wait, (unsigned) h->irq_no);
+
+    printk(
+"  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%lxn\n",
+        (unsigned) h->max_host_qng, (unsigned) h->max_dvc_qng,
+        (ulong) h->carr_freelist);
+
+    printk(
+"  icq_sp 0x%lx, irq_sp 0x%lx\n",
+        (ulong) h->icq_sp, (ulong) h->irq_sp);
+
+    printk(
+"  no_scam 0x%x, tagqng_able 0x%x\n",
+        (unsigned) h->no_scam, (unsigned) h->tagqng_able);
+
+    printk(
+"  chip_scsi_id 0x%x, cfg 0x%lx\n",
+        (unsigned) h->chip_scsi_id, (ulong) h->cfg);
+}
+
+/*
+ * asc_prt_adv_dvc_cfg()
+ *
+ * Display an ADV_DVC_CFG structure.
+ */
+STATIC void
+asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)
+{
+    printk(" ADV_DVC_CFG at addr 0x%lx\n", (ulong) h);
+
+    printk(
+"  disc_enable 0x%x, termination 0x%x\n",
+        h->disc_enable, h->termination);
+
+    printk(
+"  chip_version 0x%x, mcode_date 0x%x\n",
+        h->chip_version, h->mcode_date);
+
+    printk(
+"  mcode_version 0x%x, pci_device_id 0x%x, lib_version %u\n",
+       h->mcode_version, to_pci_dev(h->dev)->device, h->lib_version);
+
+    printk(
+"  control_flag 0x%x, pci_slot_info 0x%x\n",
+       h->control_flag, h->pci_slot_info);
+}
+
+/*
+ * asc_prt_adv_scsi_req_q()
+ *
+ * Display an ADV_SCSI_REQ_Q structure.
+ */
+STATIC void
+asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)
+{
+    int                 sg_blk_cnt;
+    struct asc_sg_block *sg_ptr;
+
+    printk("ADV_SCSI_REQ_Q at addr 0x%lx\n", (ulong) q);
+
+    printk(
+"  target_id %u, target_lun %u, srb_ptr 0x%lx, a_flag 0x%x\n",
+            q->target_id, q->target_lun, (ulong) q->srb_ptr, q->a_flag);
+
+    printk("  cntl 0x%x, data_addr 0x%lx, vdata_addr 0x%lx\n",
+            q->cntl, (ulong) le32_to_cpu(q->data_addr), (ulong) q->vdata_addr);
+
+    printk(
+"  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\n",
+            (ulong) le32_to_cpu(q->data_cnt),
+            (ulong) le32_to_cpu(q->sense_addr), q->sense_len);
+
+    printk(
+"  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\n",
+            q->cdb_len, q->done_status, q->host_status, q->scsi_status);
+
+    printk(
+"  sg_working_ix 0x%x, target_cmd %u\n",
+            q->sg_working_ix, q->target_cmd);
+
+    printk(
+"  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\n",
+            (ulong) le32_to_cpu(q->scsiq_rptr),
+            (ulong) le32_to_cpu(q->sg_real_addr), (ulong) q->sg_list_ptr);
+
+    /* Display the request's ADV_SG_BLOCK structures. */
+    if (q->sg_list_ptr != NULL)
+    {
+        sg_blk_cnt = 0;
+        while (1) {
+            /*
+             * 'sg_ptr' is a physical address. Convert it to a virtual
+             * address by indexing 'sg_blk_cnt' into the virtual address
+             * array 'sg_list_ptr'.
+             *
+             * XXX - Assumes all SG physical blocks are virtually contiguous.
+             */
+            sg_ptr = &(((ADV_SG_BLOCK *) (q->sg_list_ptr))[sg_blk_cnt]);
+            asc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);
+            if (sg_ptr->sg_ptr == 0)
+            {
+                break;
+            }
+            sg_blk_cnt++;
+        }
+    }
+}
+
+/*
+ * asc_prt_adv_sgblock()
+ *
+ * Display an ADV_SG_BLOCK structure.
+ */
+STATIC void
+asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)
+{
+    int i;
+
+    printk(" ASC_SG_BLOCK at addr 0x%lx (sgblockno %d)\n",
+        (ulong) b, sgblockno);
+    printk("  sg_cnt %u, sg_ptr 0x%lx\n",
+        b->sg_cnt, (ulong) le32_to_cpu(b->sg_ptr));
+    ASC_ASSERT(b->sg_cnt <= NO_OF_SG_PER_BLOCK);
+    if (b->sg_ptr != 0)
+    {
+        ASC_ASSERT(b->sg_cnt == NO_OF_SG_PER_BLOCK);
+    }
+    for (i = 0; i < b->sg_cnt; i++) {
+        printk("  [%u]: sg_addr 0x%lx, sg_count 0x%lx\n",
+            i, (ulong) b->sg_list[i].sg_addr, (ulong) b->sg_list[i].sg_count);
+    }
+}
+
+/*
+ * asc_prt_hex()
+ *
+ * Print hexadecimal output in 4 byte groupings 32 bytes
+ * or 8 double-words per line.
+ */
+STATIC void
+asc_prt_hex(char *f, uchar *s, int l)
+{
+    int            i;
+    int            j;
+    int            k;
+    int            m;
+
+    printk("%s: (%d bytes)\n", f, l);
+
+    for (i = 0; i < l; i += 32) {
+
+        /* Display a maximum of 8 double-words per line. */
+        if ((k = (l - i) / 4) >= 8) {
+            k = 8;
+            m = 0;
+        } else {
+            m = (l - i) % 4;
+        }
+
+        for (j = 0; j < k; j++) {
+            printk(" %2.2X%2.2X%2.2X%2.2X",
+                (unsigned) s[i+(j*4)], (unsigned) s[i+(j*4)+1],
+                (unsigned) s[i+(j*4)+2], (unsigned) s[i+(j*4)+3]);
+        }
+
+        switch (m) {
+        case 0:
+        default:
+            break;
+        case 1:
+            printk(" %2.2X",
+                (unsigned) s[i+(j*4)]);
+            break;
+        case 2:
+            printk(" %2.2X%2.2X",
+                (unsigned) s[i+(j*4)],
+                (unsigned) s[i+(j*4)+1]);
+            break;
+        case 3:
+            printk(" %2.2X%2.2X%2.2X",
+                (unsigned) s[i+(j*4)+1],
+                (unsigned) s[i+(j*4)+2],
+                (unsigned) s[i+(j*4)+3]);
+            break;
+        }
+
+        printk("\n");
+    }
+}
+#endif /* ADVANSYS_DEBUG */
+
+/*
+ * --- Asc Library Functions
+ */
+
+STATIC ushort __init
+AscGetEisaChipCfg(
+                     PortAddr iop_base)
+{
+    PortAddr            eisa_cfg_iop;
+
+    eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
+      (PortAddr) (ASC_EISA_CFG_IOP_MASK);
+    return (inpw(eisa_cfg_iop));
+}
+
+STATIC uchar __init
+AscSetChipScsiID(
+                    PortAddr iop_base,
+                    uchar new_host_id
+)
+{
+    ushort              cfg_lsw;
+
+    if (AscGetChipScsiID(iop_base) == new_host_id) {
+        return (new_host_id);
+    }
+    cfg_lsw = AscGetChipCfgLsw(iop_base);
+    cfg_lsw &= 0xF8FF;
+    cfg_lsw |= (ushort) ((new_host_id & ASC_MAX_TID) << 8);
+    AscSetChipCfgLsw(iop_base, cfg_lsw);
+    return (AscGetChipScsiID(iop_base));
+}
+
+STATIC uchar __init
+AscGetChipScsiCtrl(
+		PortAddr iop_base)
+{
+    uchar               sc;
+
+    AscSetBank(iop_base, 1);
+    sc = inp(iop_base + IOP_REG_SC);
+    AscSetBank(iop_base, 0);
+    return (sc);
+}
+
+STATIC uchar __init
+AscGetChipVersion(
+                     PortAddr iop_base,
+                     ushort bus_type
+)
+{
+    if ((bus_type & ASC_IS_EISA) != 0) {
+        PortAddr            eisa_iop;
+        uchar               revision;
+        eisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |
+          (PortAddr) ASC_EISA_REV_IOP_MASK;
+        revision = inp(eisa_iop);
+        return ((uchar) ((ASC_CHIP_MIN_VER_EISA - 1) + revision));
+    }
+    return (AscGetChipVerNo(iop_base));
+}
+
+STATIC ushort __init
+AscGetChipBusType(
+                     PortAddr iop_base)
+{
+    ushort              chip_ver;
+
+    chip_ver = AscGetChipVerNo(iop_base);
+    if (
+           (chip_ver >= ASC_CHIP_MIN_VER_VL)
+           && (chip_ver <= ASC_CHIP_MAX_VER_VL)
+) {
+        if (
+               ((iop_base & 0x0C30) == 0x0C30)
+               || ((iop_base & 0x0C50) == 0x0C50)
+) {
+            return (ASC_IS_EISA);
+        }
+        return (ASC_IS_VL);
+    }
+    if ((chip_ver >= ASC_CHIP_MIN_VER_ISA) &&
+        (chip_ver <= ASC_CHIP_MAX_VER_ISA)) {
+        if (chip_ver >= ASC_CHIP_MIN_VER_ISA_PNP) {
+            return (ASC_IS_ISAPNP);
+        }
+        return (ASC_IS_ISA);
+    } else if ((chip_ver >= ASC_CHIP_MIN_VER_PCI) &&
+               (chip_ver <= ASC_CHIP_MAX_VER_PCI)) {
+        return (ASC_IS_PCI);
+    }
+    return (0);
+}
+
+STATIC ASC_DCNT
+AscLoadMicroCode(
+                    PortAddr iop_base,
+                    ushort s_addr,
+                    uchar *mcode_buf,
+                    ushort mcode_size
+)
+{
+    ASC_DCNT            chksum;
+    ushort              mcode_word_size;
+    ushort              mcode_chksum;
+
+    /* Write the microcode buffer starting at LRAM address 0. */
+    mcode_word_size = (ushort) (mcode_size >> 1);
+    AscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);
+    AscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);
+
+    chksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);
+    ASC_DBG1(1, "AscLoadMicroCode: chksum 0x%lx\n", (ulong) chksum);
+    mcode_chksum = (ushort) AscMemSumLramWord(iop_base,
+          (ushort) ASC_CODE_SEC_BEG,
+          (ushort) ((mcode_size - s_addr - (ushort) ASC_CODE_SEC_BEG) / 2));
+    ASC_DBG1(1, "AscLoadMicroCode: mcode_chksum 0x%lx\n",
+        (ulong) mcode_chksum);
+    AscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);
+    AscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);
+    return (chksum);
+}
+
+STATIC int
+AscFindSignature(
+                    PortAddr iop_base
+)
+{
+    ushort              sig_word;
+
+    ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureByte(0x%x) 0x%x\n",
+        iop_base, AscGetChipSignatureByte(iop_base));
+    if (AscGetChipSignatureByte(iop_base) == (uchar) ASC_1000_ID1B) {
+        ASC_DBG2(1, "AscFindSignature: AscGetChipSignatureWord(0x%x) 0x%x\n",
+            iop_base, AscGetChipSignatureWord(iop_base));
+        sig_word = AscGetChipSignatureWord(iop_base);
+        if ((sig_word == (ushort) ASC_1000_ID0W) ||
+            (sig_word == (ushort) ASC_1000_ID0W_FIX)) {
+            return (1);
+        }
+    }
+    return (0);
+}
+
+STATIC PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] __initdata =
+{
+    0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
+    ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
+};
+
+#ifdef CONFIG_ISA
+STATIC uchar _isa_pnp_inited __initdata = 0;
+
+STATIC PortAddr __init
+AscSearchIOPortAddr(
+                       PortAddr iop_beg,
+                       ushort bus_type)
+{
+    if (bus_type & ASC_IS_VL) {
+        while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
+            if (AscGetChipVersion(iop_beg, bus_type) <= ASC_CHIP_MAX_VER_VL) {
+                return (iop_beg);
+            }
+        }
+        return (0);
+    }
+    if (bus_type & ASC_IS_ISA) {
+        if (_isa_pnp_inited == 0) {
+            AscSetISAPNPWaitForKey();
+            _isa_pnp_inited++;
+        }
+        while ((iop_beg = AscSearchIOPortAddr11(iop_beg)) != 0) {
+            if ((AscGetChipVersion(iop_beg, bus_type) & ASC_CHIP_VER_ISA_BIT) != 0) {
+                return (iop_beg);
+            }
+        }
+        return (0);
+    }
+    if (bus_type & ASC_IS_EISA) {
+        if ((iop_beg = AscSearchIOPortAddrEISA(iop_beg)) != 0) {
+            return (iop_beg);
+        }
+        return (0);
+    }
+    return (0);
+}
+
+STATIC PortAddr __init
+AscSearchIOPortAddr11(
+                         PortAddr s_addr
+)
+{
+    int                 i;
+    PortAddr            iop_base;
+
+    for (i = 0; i < ASC_IOADR_TABLE_MAX_IX; i++) {
+        if (_asc_def_iop_base[i] > s_addr) {
+            break;
+        }
+    }
+    for (; i < ASC_IOADR_TABLE_MAX_IX; i++) {
+        iop_base = _asc_def_iop_base[i];
+        if (check_region(iop_base, ASC_IOADR_GAP) != 0) {
+            ASC_DBG1(1,
+               "AscSearchIOPortAddr11: check_region() failed I/O port 0x%x\n",
+                     iop_base);
+            continue;
+        }
+        ASC_DBG1(1, "AscSearchIOPortAddr11: probing I/O port 0x%x\n", iop_base);
+        if (AscFindSignature(iop_base)) {
+            return (iop_base);
+        }
+    }
+    return (0);
+}
+
+STATIC void __init
+AscSetISAPNPWaitForKey(void)
+{
+    outp(ASC_ISA_PNP_PORT_ADDR, 0x02);
+    outp(ASC_ISA_PNP_PORT_WRITE, 0x02);
+    return;
+}
+#endif /* CONFIG_ISA */
+
+STATIC void __init
+AscToggleIRQAct(
+                   PortAddr iop_base
+)
+{
+    AscSetChipStatus(iop_base, CIW_IRQ_ACT);
+    AscSetChipStatus(iop_base, 0);
+    return;
+}
+
+STATIC uchar __init
+AscGetChipIRQ(
+                 PortAddr iop_base,
+                 ushort bus_type)
+{
+    ushort              cfg_lsw;
+    uchar               chip_irq;
+
+    if ((bus_type & ASC_IS_EISA) != 0) {
+        cfg_lsw = AscGetEisaChipCfg(iop_base);
+        chip_irq = (uchar) (((cfg_lsw >> 8) & 0x07) + 10);
+        if ((chip_irq == 13) || (chip_irq > 15)) {
+            return (0);
+        }
+        return (chip_irq);
+    }
+    if ((bus_type & ASC_IS_VL) != 0) {
+        cfg_lsw = AscGetChipCfgLsw(iop_base);
+        chip_irq = (uchar) (((cfg_lsw >> 2) & 0x07));
+        if ((chip_irq == 0) ||
+            (chip_irq == 4) ||
+            (chip_irq == 7)) {
+            return (0);
+        }
+        return ((uchar) (chip_irq + (ASC_MIN_IRQ_NO - 1)));
+    }
+    cfg_lsw = AscGetChipCfgLsw(iop_base);
+    chip_irq = (uchar) (((cfg_lsw >> 2) & 0x03));
+    if (chip_irq == 3)
+        chip_irq += (uchar) 2;
+    return ((uchar) (chip_irq + ASC_MIN_IRQ_NO));
+}
+
+STATIC uchar __init
+AscSetChipIRQ(
+                 PortAddr iop_base,
+                 uchar irq_no,
+                 ushort bus_type)
+{
+    ushort              cfg_lsw;
+
+    if ((bus_type & ASC_IS_VL) != 0) {
+        if (irq_no != 0) {
+            if ((irq_no < ASC_MIN_IRQ_NO) || (irq_no > ASC_MAX_IRQ_NO)) {
+                irq_no = 0;
+            } else {
+                irq_no -= (uchar) ((ASC_MIN_IRQ_NO - 1));
+            }
+        }
+        cfg_lsw = (ushort) (AscGetChipCfgLsw(iop_base) & 0xFFE3);
+        cfg_lsw |= (ushort) 0x0010;
+        AscSetChipCfgLsw(iop_base, cfg_lsw);
+        AscToggleIRQAct(iop_base);
+        cfg_lsw = (ushort) (AscGetChipCfgLsw(iop_base) & 0xFFE0);
+        cfg_lsw |= (ushort) ((irq_no & 0x07) << 2);
+        AscSetChipCfgLsw(iop_base, cfg_lsw);
+        AscToggleIRQAct(iop_base);
+        return (AscGetChipIRQ(iop_base, bus_type));
+    }
+    if ((bus_type & (ASC_IS_ISA)) != 0) {
+        if (irq_no == 15)
+            irq_no -= (uchar) 2;
+        irq_no -= (uchar) ASC_MIN_IRQ_NO;
+        cfg_lsw = (ushort) (AscGetChipCfgLsw(iop_base) & 0xFFF3);
+        cfg_lsw |= (ushort) ((irq_no & 0x03) << 2);
+        AscSetChipCfgLsw(iop_base, cfg_lsw);
+        return (AscGetChipIRQ(iop_base, bus_type));
+    }
+    return (0);
+}
+
+#ifdef CONFIG_ISA
+STATIC void __init
+AscEnableIsaDma(
+                   uchar dma_channel)
+{
+    if (dma_channel < 4) {
+        outp(0x000B, (ushort) (0xC0 | dma_channel));
+        outp(0x000A, dma_channel);
+    } else if (dma_channel < 8) {
+        outp(0x00D6, (ushort) (0xC0 | (dma_channel - 4)));
+        outp(0x00D4, (ushort) (dma_channel - 4));
+    }
+    return;
+}
+#endif /* CONFIG_ISA */
+
+STATIC int
+AscIsrChipHalted(
+                    ASC_DVC_VAR *asc_dvc
+)
+{
+    EXT_MSG             ext_msg;
+    EXT_MSG             out_msg;
+    ushort              halt_q_addr;
+    int                 sdtr_accept;
+    ushort              int_halt_code;
+    ASC_SCSI_BIT_ID_TYPE scsi_busy;
+    ASC_SCSI_BIT_ID_TYPE target_id;
+    PortAddr            iop_base;
+    uchar               tag_code;
+    uchar               q_status;
+    uchar               halt_qp;
+    uchar               sdtr_data;
+    uchar               target_ix;
+    uchar               q_cntl, tid_no;
+    uchar               cur_dvc_qng;
+    uchar               asyn_sdtr;
+    uchar               scsi_status;
+    asc_board_t         *boardp;
+
+    ASC_ASSERT(asc_dvc->drv_ptr != NULL);
+    boardp = asc_dvc->drv_ptr;
+
+    iop_base = asc_dvc->iop_base;
+    int_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);
+
+    halt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);
+    halt_q_addr = ASC_QNO_TO_QADDR(halt_qp);
+    target_ix = AscReadLramByte(iop_base,
+                   (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_TARGET_IX));
+    q_cntl = AscReadLramByte(iop_base,
+                        (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL));
+    tid_no = ASC_TIX_TO_TID(target_ix);
+    target_id = (uchar) ASC_TID_TO_TARGET_ID(tid_no);
+    if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+        asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;
+    } else {
+        asyn_sdtr = 0;
+    }
+    if (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {
+        if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+            AscSetChipSDTR(iop_base, 0, tid_no);
+            boardp->sdtr_data[tid_no] = 0;
+        }
+        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+        return (0);
+    } else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {
+        if (asc_dvc->pci_fix_asyn_xfer & target_id) {
+            AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+            boardp->sdtr_data[tid_no] = asyn_sdtr;
+        }
+        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+        return (0);
+    } else if (int_halt_code == ASC_HALT_EXTMSG_IN) {
+
+        AscMemWordCopyPtrFromLram(iop_base,
+                               ASCV_MSGIN_BEG,
+                               (uchar *) &ext_msg,
+                               sizeof(EXT_MSG) >> 1);
+
+        if (ext_msg.msg_type == MS_EXTEND &&
+            ext_msg.msg_req == MS_SDTR_CODE &&
+            ext_msg.msg_len == MS_SDTR_LEN) {
+            sdtr_accept = TRUE;
+            if ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {
+
+                sdtr_accept = FALSE;
+                ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;
+            }
+            if ((ext_msg.xfer_period <
+                 asc_dvc->sdtr_period_tbl[asc_dvc->host_init_sdtr_index]) ||
+                (ext_msg.xfer_period >
+                 asc_dvc->sdtr_period_tbl[asc_dvc->max_sdtr_index])) {
+                sdtr_accept = FALSE;
+                ext_msg.xfer_period =
+                    asc_dvc->sdtr_period_tbl[asc_dvc->host_init_sdtr_index];
+            }
+            if (sdtr_accept) {
+                sdtr_data = AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
+                                           ext_msg.req_ack_offset);
+                if ((sdtr_data == 0xFF)) {
+
+                    q_cntl |= QC_MSG_OUT;
+                    asc_dvc->init_sdtr &= ~target_id;
+                    asc_dvc->sdtr_done &= ~target_id;
+                    AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+                    boardp->sdtr_data[tid_no] = asyn_sdtr;
+                }
+            }
+            if (ext_msg.req_ack_offset == 0) {
+
+                q_cntl &= ~QC_MSG_OUT;
+                asc_dvc->init_sdtr &= ~target_id;
+                asc_dvc->sdtr_done &= ~target_id;
+                AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+            } else {
+                if (sdtr_accept && (q_cntl & QC_MSG_OUT)) {
+
+                    q_cntl &= ~QC_MSG_OUT;
+                    asc_dvc->sdtr_done |= target_id;
+                    asc_dvc->init_sdtr |= target_id;
+                    asc_dvc->pci_fix_asyn_xfer &= ~target_id;
+                    sdtr_data = AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
+                                               ext_msg.req_ack_offset);
+                    AscSetChipSDTR(iop_base, sdtr_data, tid_no);
+                    boardp->sdtr_data[tid_no] = sdtr_data;
+                } else {
+
+                    q_cntl |= QC_MSG_OUT;
+                    AscMsgOutSDTR(asc_dvc,
+                                  ext_msg.xfer_period,
+                                  ext_msg.req_ack_offset);
+                    asc_dvc->pci_fix_asyn_xfer &= ~target_id;
+                    sdtr_data = AscCalSDTRData(asc_dvc, ext_msg.xfer_period,
+                                               ext_msg.req_ack_offset);
+                    AscSetChipSDTR(iop_base, sdtr_data, tid_no);
+                    boardp->sdtr_data[tid_no] = sdtr_data;
+                    asc_dvc->sdtr_done |= target_id;
+                    asc_dvc->init_sdtr |= target_id;
+                }
+            }
+
+            AscWriteLramByte(iop_base,
+                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
+                             q_cntl);
+            AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+            return (0);
+        } else if (ext_msg.msg_type == MS_EXTEND &&
+                   ext_msg.msg_req == MS_WDTR_CODE &&
+                   ext_msg.msg_len == MS_WDTR_LEN) {
+
+            ext_msg.wdtr_width = 0;
+            AscMemWordCopyPtrToLram(iop_base,
+                                 ASCV_MSGOUT_BEG,
+                                 (uchar *) &ext_msg,
+                                 sizeof(EXT_MSG) >> 1);
+            q_cntl |= QC_MSG_OUT;
+            AscWriteLramByte(iop_base,
+                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
+                             q_cntl);
+            AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+            return (0);
+        } else {
+
+            ext_msg.msg_type = MESSAGE_REJECT;
+            AscMemWordCopyPtrToLram(iop_base,
+                                 ASCV_MSGOUT_BEG,
+                                 (uchar *) &ext_msg,
+                                 sizeof(EXT_MSG) >> 1);
+            q_cntl |= QC_MSG_OUT;
+            AscWriteLramByte(iop_base,
+                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
+                             q_cntl);
+            AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+            return (0);
+        }
+    } else if (int_halt_code == ASC_HALT_CHK_CONDITION) {
+
+        q_cntl |= QC_REQ_SENSE;
+
+        if ((asc_dvc->init_sdtr & target_id) != 0) {
+
+            asc_dvc->sdtr_done &= ~target_id;
+
+            sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+            q_cntl |= QC_MSG_OUT;
+            AscMsgOutSDTR(asc_dvc,
+                          asc_dvc->sdtr_period_tbl[(sdtr_data >> 4) &
+                           (uchar) (asc_dvc->max_sdtr_index - 1)],
+                          (uchar) (sdtr_data & (uchar) ASC_SYN_MAX_OFFSET));
+        }
+
+        AscWriteLramByte(iop_base,
+                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
+                         q_cntl);
+
+        tag_code = AscReadLramByte(iop_base,
+                    (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_TAG_CODE));
+        tag_code &= 0xDC;
+        if (
+               (asc_dvc->pci_fix_asyn_xfer & target_id)
+               && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)
+) {
+
+            tag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT
+                         | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);
+
+        }
+        AscWriteLramByte(iop_base,
+                     (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_TAG_CODE),
+                         tag_code);
+
+        q_status = AscReadLramByte(iop_base,
+                      (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_STATUS));
+        q_status |= (QS_READY | QS_BUSY);
+        AscWriteLramByte(iop_base,
+                       (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_STATUS),
+                         q_status);
+
+        scsi_busy = AscReadLramByte(iop_base,
+                                    (ushort) ASCV_SCSIBUSY_B);
+        scsi_busy &= ~target_id;
+        AscWriteLramByte(iop_base, (ushort) ASCV_SCSIBUSY_B, scsi_busy);
+
+        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+        return (0);
+    } else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {
+
+        AscMemWordCopyPtrFromLram(iop_base,
+                               ASCV_MSGOUT_BEG,
+                               (uchar *) &out_msg,
+                               sizeof(EXT_MSG) >> 1);
+
+        if ((out_msg.msg_type == MS_EXTEND) &&
+            (out_msg.msg_len == MS_SDTR_LEN) &&
+            (out_msg.msg_req == MS_SDTR_CODE)) {
+
+            asc_dvc->init_sdtr &= ~target_id;
+            asc_dvc->sdtr_done &= ~target_id;
+            AscSetChipSDTR(iop_base, asyn_sdtr, tid_no);
+            boardp->sdtr_data[tid_no] = asyn_sdtr;
+        }
+        q_cntl &= ~QC_MSG_OUT;
+        AscWriteLramByte(iop_base,
+                         (ushort) (halt_q_addr + (ushort) ASC_SCSIQ_B_CNTL),
+                         q_cntl);
+        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+        return (0);
+    } else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {
+
+        scsi_status = AscReadLramByte(iop_base,
+          (ushort) ((ushort) halt_q_addr + (ushort) ASC_SCSIQ_SCSI_STATUS));
+        cur_dvc_qng = AscReadLramByte(iop_base,
+                     (ushort) ((ushort) ASC_QADR_BEG + (ushort) target_ix));
+        if ((cur_dvc_qng > 0) &&
+            (asc_dvc->cur_dvc_qng[tid_no] > 0)) {
+
+            scsi_busy = AscReadLramByte(iop_base,
+                                        (ushort) ASCV_SCSIBUSY_B);
+            scsi_busy |= target_id;
+            AscWriteLramByte(iop_base,
+                             (ushort) ASCV_SCSIBUSY_B, scsi_busy);
+            asc_dvc->queue_full_or_busy |= target_id;
+
+            if (scsi_status == SAM_STAT_TASK_SET_FULL) {
+                if (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {
+                    cur_dvc_qng -= 1;
+                    asc_dvc->max_dvc_qng[tid_no] = cur_dvc_qng;
+
+                    AscWriteLramByte(iop_base,
+                          (ushort) ((ushort) ASCV_MAX_DVC_QNG_BEG +
+                           (ushort) tid_no),
+                          cur_dvc_qng);
+
+                    /*
+                     * Set the device queue depth to the number of
+                     * active requests when the QUEUE FULL condition
+                     * was encountered.
+                     */
+                    boardp->queue_full |= target_id;
+                    boardp->queue_full_cnt[tid_no] = cur_dvc_qng;
+                }
+            }
+        }
+        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+        return (0);
+    }
+#if CC_VERY_LONG_SG_LIST
+    else if (int_halt_code == ASC_HALT_HOST_COPY_SG_LIST_TO_RISC)
+    {
+        uchar              q_no;
+        ushort             q_addr;
+        uchar              sg_wk_q_no;
+        uchar              first_sg_wk_q_no;
+        ASC_SCSI_Q         *scsiq; /* Ptr to driver request. */
+        ASC_SG_HEAD        *sg_head; /* Ptr to driver SG request. */
+        ASC_SG_LIST_Q      scsi_sg_q; /* Structure written to queue. */
+        ushort             sg_list_dwords;
+        ushort             sg_entry_cnt;
+        uchar              next_qp;
+        int                i;
+
+        q_no = AscReadLramByte(iop_base, (ushort) ASCV_REQ_SG_LIST_QP);
+        if (q_no == ASC_QLINK_END)
+        {
+            return(0);
+        }
+
+        q_addr = ASC_QNO_TO_QADDR(q_no);
+
+        /*
+         * Convert the request's SRB pointer to a host ASC_SCSI_REQ
+         * structure pointer using a macro provided by the driver.
+         * The ASC_SCSI_REQ pointer provides a pointer to the
+         * host ASC_SG_HEAD structure.
+         */
+        /* Read request's SRB pointer. */
+        scsiq = (ASC_SCSI_Q *)
+           ASC_SRB2SCSIQ(
+               ASC_U32_TO_VADDR(AscReadLramDWord(iop_base,
+               (ushort) (q_addr + ASC_SCSIQ_D_SRBPTR))));
+
+        /*
+         * Get request's first and working SG queue.
+         */
+        sg_wk_q_no = AscReadLramByte(iop_base,
+            (ushort) (q_addr + ASC_SCSIQ_B_SG_WK_QP));
+
+        first_sg_wk_q_no = AscReadLramByte(iop_base,
+            (ushort) (q_addr + ASC_SCSIQ_B_FIRST_SG_WK_QP));
+
+        /*
+         * Reset request's working SG queue back to the
+         * first SG queue.
+         */
+        AscWriteLramByte(iop_base,
+            (ushort) (q_addr + (ushort) ASC_SCSIQ_B_SG_WK_QP),
+            first_sg_wk_q_no);
+
+        sg_head = scsiq->sg_head;
+
+        /*
+         * Set sg_entry_cnt to the number of SG elements
+         * that will be completed on this interrupt.
+         *
+         * Note: The allocated SG queues contain ASC_MAX_SG_LIST - 1
+         * SG elements. The data_cnt and data_addr fields which
+         * add 1 to the SG element capacity are not used when
+         * restarting SG handling after a halt.
+         */
+        if (scsiq->remain_sg_entry_cnt > (ASC_MAX_SG_LIST - 1))
+        {
+             sg_entry_cnt = ASC_MAX_SG_LIST - 1;
+
+             /*
+              * Keep track of remaining number of SG elements that will
+              * need to be handled on the next interrupt.
+              */
+             scsiq->remain_sg_entry_cnt -= (ASC_MAX_SG_LIST - 1);
+        } else
+        {
+             sg_entry_cnt = scsiq->remain_sg_entry_cnt;
+             scsiq->remain_sg_entry_cnt = 0;
+        }
+
+        /*
+         * Copy SG elements into the list of allocated SG queues.
+         *
+         * Last index completed is saved in scsiq->next_sg_index.
+         */
+        next_qp = first_sg_wk_q_no;
+        q_addr = ASC_QNO_TO_QADDR(next_qp);
+        scsi_sg_q.sg_head_qp = q_no;
+        scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
+        for( i = 0; i < sg_head->queue_cnt; i++)
+        {
+             scsi_sg_q.seq_no = i + 1;
+             if (sg_entry_cnt > ASC_SG_LIST_PER_Q)
+             {
+                 sg_list_dwords = (uchar) (ASC_SG_LIST_PER_Q * 2);
+                 sg_entry_cnt -= ASC_SG_LIST_PER_Q;
+                 /*
+                  * After very first SG queue RISC FW uses next
+                  * SG queue first element then checks sg_list_cnt
+                  * against zero and then decrements, so set
+                  * sg_list_cnt 1 less than number of SG elements
+                  * in each SG queue.
+                  */
+                 scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
+                 scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q - 1;
+             } else {
+                 /*
+                  * This is the last SG queue in the list of
+                  * allocated SG queues. If there are more
+                  * SG elements than will fit in the allocated
+                  * queues, then set the QCSG_SG_XFER_MORE flag.
+                  */
+                 if (scsiq->remain_sg_entry_cnt != 0)
+                 {
+                     scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
+                 } else
+                 {
+                     scsi_sg_q.cntl |= QCSG_SG_XFER_END;
+                 }
+                 /* equals sg_entry_cnt * 2 */
+                 sg_list_dwords = sg_entry_cnt << 1;
+                 scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
+                 scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
+                 sg_entry_cnt = 0;
+             }
+
+             scsi_sg_q.q_no = next_qp;
+             AscMemWordCopyPtrToLram(iop_base,
+                          q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
+                          (uchar *) &scsi_sg_q,
+                          sizeof(ASC_SG_LIST_Q) >> 1);
+
+             AscMemDWordCopyPtrToLram(iop_base,
+                          q_addr + ASC_SGQ_LIST_BEG,
+                          (uchar *) &sg_head->sg_list[scsiq->next_sg_index],
+                          sg_list_dwords);
+
+             scsiq->next_sg_index += ASC_SG_LIST_PER_Q;
+
+             /*
+              * If the just completed SG queue contained the
+              * last SG element, then no more SG queues need
+              * to be written.
+              */
+             if (scsi_sg_q.cntl & QCSG_SG_XFER_END)
+             {
+                 break;
+             }
+
+             next_qp = AscReadLramByte( iop_base,
+                          ( ushort )( q_addr+ASC_SCSIQ_B_FWD ) );
+             q_addr = ASC_QNO_TO_QADDR( next_qp );
+        }
+
+        /*
+         * Clear the halt condition so the RISC will be restarted
+         * after the return.
+         */
+        AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+        return(0);
+    }
+#endif /* CC_VERY_LONG_SG_LIST */
+    return (0);
+}
+
+STATIC uchar
+_AscCopyLramScsiDoneQ(
+                         PortAddr iop_base,
+                         ushort q_addr,
+                         ASC_QDONE_INFO * scsiq,
+                         ASC_DCNT max_dma_count
+)
+{
+    ushort              _val;
+    uchar               sg_queue_cnt;
+
+    DvcGetQinfo(iop_base,
+                q_addr + ASC_SCSIQ_DONE_INFO_BEG,
+                (uchar *) scsiq,
+                (sizeof (ASC_SCSIQ_2) + sizeof (ASC_SCSIQ_3)) / 2);
+
+    _val = AscReadLramWord(iop_base,
+                           (ushort) (q_addr + (ushort) ASC_SCSIQ_B_STATUS));
+    scsiq->q_status = (uchar) _val;
+    scsiq->q_no = (uchar) (_val >> 8);
+    _val = AscReadLramWord(iop_base,
+                           (ushort) (q_addr + (ushort) ASC_SCSIQ_B_CNTL));
+    scsiq->cntl = (uchar) _val;
+    sg_queue_cnt = (uchar) (_val >> 8);
+    _val = AscReadLramWord(iop_base,
+                        (ushort) (q_addr + (ushort) ASC_SCSIQ_B_SENSE_LEN));
+    scsiq->sense_len = (uchar) _val;
+    scsiq->extra_bytes = (uchar) (_val >> 8);
+
+    /*
+     * Read high word of remain bytes from alternate location.
+     */
+    scsiq->remain_bytes = (((ADV_DCNT) AscReadLramWord( iop_base,
+                      (ushort) (q_addr+ (ushort) ASC_SCSIQ_W_ALT_DC1))) << 16);
+    /*
+     * Read low word of remain bytes from original location.
+     */
+    scsiq->remain_bytes += AscReadLramWord(iop_base,
+        (ushort) (q_addr+ (ushort) ASC_SCSIQ_DW_REMAIN_XFER_CNT));
+
+    scsiq->remain_bytes &= max_dma_count;
+    return (sg_queue_cnt);
+}
+
+STATIC int
+AscIsrQDone(
+               ASC_DVC_VAR *asc_dvc
+)
+{
+    uchar               next_qp;
+    uchar               n_q_used;
+    uchar               sg_list_qp;
+    uchar               sg_queue_cnt;
+    uchar               q_cnt;
+    uchar               done_q_tail;
+    uchar               tid_no;
+    ASC_SCSI_BIT_ID_TYPE scsi_busy;
+    ASC_SCSI_BIT_ID_TYPE target_id;
+    PortAddr            iop_base;
+    ushort              q_addr;
+    ushort              sg_q_addr;
+    uchar               cur_target_qng;
+    ASC_QDONE_INFO      scsiq_buf;
+    ASC_QDONE_INFO *scsiq;
+    int                 false_overrun;
+    ASC_ISR_CALLBACK    asc_isr_callback;
+
+    iop_base = asc_dvc->iop_base;
+    asc_isr_callback = asc_dvc->isr_callback;
+    n_q_used = 1;
+    scsiq = (ASC_QDONE_INFO *) & scsiq_buf;
+    done_q_tail = (uchar) AscGetVarDoneQTail(iop_base);
+    q_addr = ASC_QNO_TO_QADDR(done_q_tail);
+    next_qp = AscReadLramByte(iop_base,
+                              (ushort) (q_addr + (ushort) ASC_SCSIQ_B_FWD));
+    if (next_qp != ASC_QLINK_END) {
+        AscPutVarDoneQTail(iop_base, next_qp);
+        q_addr = ASC_QNO_TO_QADDR(next_qp);
+        sg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,
+            asc_dvc->max_dma_count);
+        AscWriteLramByte(iop_base,
+                         (ushort) (q_addr + (ushort) ASC_SCSIQ_B_STATUS),
+             (uchar) (scsiq->q_status & (uchar) ~ (QS_READY | QS_ABORTED)));
+        tid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);
+        target_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);
+        if ((scsiq->cntl & QC_SG_HEAD) != 0) {
+            sg_q_addr = q_addr;
+            sg_list_qp = next_qp;
+            for (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {
+                sg_list_qp = AscReadLramByte(iop_base,
+                           (ushort) (sg_q_addr + (ushort) ASC_SCSIQ_B_FWD));
+                sg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);
+                if (sg_list_qp == ASC_QLINK_END) {
+                    AscSetLibErrorCode(asc_dvc, ASCQ_ERR_SG_Q_LINKS);
+                    scsiq->d3.done_stat = QD_WITH_ERROR;
+                    scsiq->d3.host_stat = QHSTA_D_QDONE_SG_LIST_CORRUPTED;
+                    goto FATAL_ERR_QDONE;
+                }
+                AscWriteLramByte(iop_base,
+                         (ushort) (sg_q_addr + (ushort) ASC_SCSIQ_B_STATUS),
+                                 QS_FREE);
+            }
+            n_q_used = sg_queue_cnt + 1;
+            AscPutVarDoneQTail(iop_base, sg_list_qp);
+        }
+        if (asc_dvc->queue_full_or_busy & target_id) {
+            cur_target_qng = AscReadLramByte(iop_base,
+            (ushort) ((ushort) ASC_QADR_BEG + (ushort) scsiq->d2.target_ix));
+            if (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {
+                scsi_busy = AscReadLramByte(iop_base,
+                                            (ushort) ASCV_SCSIBUSY_B);
+                scsi_busy &= ~target_id;
+                AscWriteLramByte(iop_base,
+                                 (ushort) ASCV_SCSIBUSY_B, scsi_busy);
+                asc_dvc->queue_full_or_busy &= ~target_id;
+            }
+        }
+        if (asc_dvc->cur_total_qng >= n_q_used) {
+            asc_dvc->cur_total_qng -= n_q_used;
+            if (asc_dvc->cur_dvc_qng[tid_no] != 0) {
+                asc_dvc->cur_dvc_qng[tid_no]--;
+            }
+        } else {
+            AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);
+            scsiq->d3.done_stat = QD_WITH_ERROR;
+            goto FATAL_ERR_QDONE;
+        }
+        if ((scsiq->d2.srb_ptr == 0UL) ||
+            ((scsiq->q_status & QS_ABORTED) != 0)) {
+            return (0x11);
+        } else if (scsiq->q_status == QS_DONE) {
+            false_overrun = FALSE;
+            if (scsiq->extra_bytes != 0) {
+                scsiq->remain_bytes += (ADV_DCNT) scsiq->extra_bytes;
+            }
+            if (scsiq->d3.done_stat == QD_WITH_ERROR) {
+                if (scsiq->d3.host_stat == QHSTA_M_DATA_OVER_RUN) {
+                    if ((scsiq->cntl & (QC_DATA_IN | QC_DATA_OUT)) == 0) {
+                        scsiq->d3.done_stat = QD_NO_ERROR;
+                        scsiq->d3.host_stat = QHSTA_NO_ERROR;
+                    } else if (false_overrun) {
+                        scsiq->d3.done_stat = QD_NO_ERROR;
+                        scsiq->d3.host_stat = QHSTA_NO_ERROR;
+                    }
+                } else if (scsiq->d3.host_stat ==
+                           QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
+                    AscStopChip(iop_base);
+                    AscSetChipControl(iop_base,
+                        (uchar) (CC_SCSI_RESET | CC_HALT));
+                    DvcDelayNanoSecond(asc_dvc, 60000);
+                    AscSetChipControl(iop_base, CC_HALT);
+                    AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+                    AscSetChipStatus(iop_base, 0);
+                    AscSetChipControl(iop_base, 0);
+                }
+            }
+            if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
+                (*asc_isr_callback) (asc_dvc, scsiq);
+            } else {
+                if ((AscReadLramByte(iop_base,
+                          (ushort) (q_addr + (ushort) ASC_SCSIQ_CDB_BEG)) ==
+                     START_STOP)) {
+                    asc_dvc->unit_not_ready &= ~target_id;
+                    if (scsiq->d3.done_stat != QD_NO_ERROR) {
+                        asc_dvc->start_motor &= ~target_id;
+                    }
+                }
+            }
+            return (1);
+        } else {
+            AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);
+          FATAL_ERR_QDONE:
+            if ((scsiq->cntl & QC_NO_CALLBACK) == 0) {
+                (*asc_isr_callback) (asc_dvc, scsiq);
+            }
+            return (0x80);
+        }
+    }
+    return (0);
+}
+
+STATIC int
+AscISR(
+          ASC_DVC_VAR *asc_dvc
+)
+{
+    ASC_CS_TYPE         chipstat;
+    PortAddr            iop_base;
+    ushort              saved_ram_addr;
+    uchar               ctrl_reg;
+    uchar               saved_ctrl_reg;
+    int                 int_pending;
+    int                 status;
+    uchar               host_flag;
+
+    iop_base = asc_dvc->iop_base;
+    int_pending = FALSE;
+
+    if (AscIsIntPending(iop_base) == 0)
+    {
+        return int_pending;
+    }
+
+    if (((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0)
+        || (asc_dvc->isr_callback == 0)
+) {
+        return (ERR);
+    }
+    if (asc_dvc->in_critical_cnt != 0) {
+        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);
+        return (ERR);
+    }
+    if (asc_dvc->is_in_int) {
+        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);
+        return (ERR);
+    }
+    asc_dvc->is_in_int = TRUE;
+    ctrl_reg = AscGetChipControl(iop_base);
+    saved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |
+                                   CC_SINGLE_STEP | CC_DIAG | CC_TEST));
+    chipstat = AscGetChipStatus(iop_base);
+    if (chipstat & CSW_SCSI_RESET_LATCH) {
+        if (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {
+            int i = 10;
+            int_pending = TRUE;
+            asc_dvc->sdtr_done = 0;
+            saved_ctrl_reg &= (uchar) (~CC_HALT);
+            while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE) &&
+                   (i-- > 0))
+            {
+                  DvcSleepMilliSecond(100);
+            }
+            AscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));
+            AscSetChipControl(iop_base, CC_HALT);
+            AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+            AscSetChipStatus(iop_base, 0);
+            chipstat = AscGetChipStatus(iop_base);
+        }
+    }
+    saved_ram_addr = AscGetChipLramAddr(iop_base);
+    host_flag = AscReadLramByte(iop_base,
+        ASCV_HOST_FLAG_B) & (uchar) (~ASC_HOST_FLAG_IN_ISR);
+    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
+                     (uchar) (host_flag | (uchar) ASC_HOST_FLAG_IN_ISR));
+    if ((chipstat & CSW_INT_PENDING)
+        || (int_pending)
+) {
+        AscAckInterrupt(iop_base);
+        int_pending = TRUE;
+        if ((chipstat & CSW_HALTED) &&
+            (ctrl_reg & CC_SINGLE_STEP)) {
+            if (AscIsrChipHalted(asc_dvc) == ERR) {
+                goto ISR_REPORT_QDONE_FATAL_ERROR;
+            } else {
+                saved_ctrl_reg &= (uchar) (~CC_HALT);
+            }
+        } else {
+          ISR_REPORT_QDONE_FATAL_ERROR:
+            if ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {
+                while (((status = AscIsrQDone(asc_dvc)) & 0x01) != 0) {
+                }
+            } else {
+                do {
+                    if ((status = AscIsrQDone(asc_dvc)) == 1) {
+                        break;
+                    }
+                } while (status == 0x11);
+            }
+            if ((status & 0x80) != 0)
+                int_pending = ERR;
+        }
+    }
+    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
+    AscSetChipLramAddr(iop_base, saved_ram_addr);
+    AscSetChipControl(iop_base, saved_ctrl_reg);
+    asc_dvc->is_in_int = FALSE;
+    return (int_pending);
+}
+
+/* Microcode buffer is kept after initialization for error recovery. */
+STATIC uchar _asc_mcode_buf[] =
+{
+  0x01,  0x03,  0x01,  0x19,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0xC3,  0x12,  0x0D,  0x05,  0x01,  0x00,  0x00,  0x00,  0x00,  0xFF,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0xFF,  0x80,  0xFF,  0xFF,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x23,  0x00,  0x00,  0x00,  0x00,  0x00,  0x07,  0x00,  0xFF,  0x00,  0x00,  0x00,  0x00,
+  0xFF,  0xFF,  0xFF,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0xE4,  0x88,  0x00,  0x00,  0x00,  0x00,
+  0x80,  0x73,  0x48,  0x04,  0x36,  0x00,  0x00,  0xA2,  0xC2,  0x00,  0x80,  0x73,  0x03,  0x23,  0x36,  0x40,
+  0xB6,  0x00,  0x36,  0x00,  0x05,  0xD6,  0x0C,  0xD2,  0x12,  0xDA,  0x00,  0xA2,  0xC2,  0x00,  0x92,  0x80,
+  0x1E,  0x98,  0x50,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xDF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,
+  0x4F,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xEF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,  0x80,  0x62,
+  0x92,  0x80,  0x00,  0x46,  0x15,  0xEE,  0x13,  0xEA,  0x02,  0x01,  0x09,  0xD8,  0xCD,  0x04,  0x4D,  0x00,
+  0x00,  0xA3,  0xD6,  0x00,  0xA6,  0x97,  0x7F,  0x23,  0x04,  0x61,  0x84,  0x01,  0xE6,  0x84,  0xD2,  0xC1,
+  0x80,  0x73,  0xCD,  0x04,  0x4D,  0x00,  0x00,  0xA3,  0xDA,  0x01,  0xA6,  0x97,  0xC6,  0x81,  0xC2,  0x88,
+  0x80,  0x73,  0x80,  0x77,  0x00,  0x01,  0x01,  0xA1,  0xFE,  0x00,  0x4F,  0x00,  0x84,  0x97,  0x07,  0xA6,
+  0x08,  0x01,  0x00,  0x33,  0x03,  0x00,  0xC2,  0x88,  0x03,  0x03,  0x01,  0xDE,  0xC2,  0x88,  0xCE,  0x00,
+  0x69,  0x60,  0xCE,  0x00,  0x02,  0x03,  0x4A,  0x60,  0x00,  0xA2,  0x78,  0x01,  0x80,  0x63,  0x07,  0xA6,
+  0x24,  0x01,  0x78,  0x81,  0x03,  0x03,  0x80,  0x63,  0xE2,  0x00,  0x07,  0xA6,  0x34,  0x01,  0x00,  0x33,
+  0x04,  0x00,  0xC2,  0x88,  0x03,  0x07,  0x02,  0x01,  0x04,  0xCA,  0x0D,  0x23,  0x68,  0x98,  0x4D,  0x04,
+  0x04,  0x85,  0x05,  0xD8,  0x0D,  0x23,  0x68,  0x98,  0xCD,  0x04,  0x15,  0x23,  0xF8,  0x88,  0xFB,  0x23,
+  0x02,  0x61,  0x82,  0x01,  0x80,  0x63,  0x02,  0x03,  0x06,  0xA3,  0x62,  0x01,  0x00,  0x33,  0x0A,  0x00,
+  0xC2,  0x88,  0x4E,  0x00,  0x07,  0xA3,  0x6E,  0x01,  0x00,  0x33,  0x0B,  0x00,  0xC2,  0x88,  0xCD,  0x04,
+  0x36,  0x2D,  0x00,  0x33,  0x1A,  0x00,  0xC2,  0x88,  0x50,  0x04,  0x88,  0x81,  0x06,  0xAB,  0x82,  0x01,
+  0x88,  0x81,  0x4E,  0x00,  0x07,  0xA3,  0x92,  0x01,  0x50,  0x00,  0x00,  0xA3,  0x3C,  0x01,  0x00,  0x05,
+  0x7C,  0x81,  0x46,  0x97,  0x02,  0x01,  0x05,  0xC6,  0x04,  0x23,  0xA0,  0x01,  0x15,  0x23,  0xA1,  0x01,
+  0xBE,  0x81,  0xFD,  0x23,  0x02,  0x61,  0x82,  0x01,  0x0A,  0xDA,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,
+  0xB4,  0x01,  0x80,  0x63,  0xCD,  0x04,  0x36,  0x2D,  0x00,  0x33,  0x1B,  0x00,  0xC2,  0x88,  0x06,  0x23,
+  0x68,  0x98,  0xCD,  0x04,  0xE6,  0x84,  0x06,  0x01,  0x00,  0xA2,  0xD4,  0x01,  0x57,  0x60,  0x00,  0xA0,
+  0xDA,  0x01,  0xE6,  0x84,  0x80,  0x23,  0xA0,  0x01,  0xE6,  0x84,  0x80,  0x73,  0x4B,  0x00,  0x06,  0x61,
+  0x00,  0xA2,  0x00,  0x02,  0x04,  0x01,  0x0C,  0xDE,  0x02,  0x01,  0x03,  0xCC,  0x4F,  0x00,  0x84,  0x97,
+  0xFC,  0x81,  0x08,  0x23,  0x02,  0x41,  0x82,  0x01,  0x4F,  0x00,  0x62,  0x97,  0x48,  0x04,  0x84,  0x80,
+  0xF0,  0x97,  0x00,  0x46,  0x56,  0x00,  0x03,  0xC0,  0x01,  0x23,  0xE8,  0x00,  0x81,  0x73,  0x06,  0x29,
+  0x03,  0x42,  0x06,  0xE2,  0x03,  0xEE,  0x6B,  0xEB,  0x11,  0x23,  0xF8,  0x88,  0x04,  0x98,  0xF0,  0x80,
+  0x80,  0x73,  0x80,  0x77,  0x07,  0xA4,  0x2A,  0x02,  0x7C,  0x95,  0x06,  0xA6,  0x34,  0x02,  0x03,  0xA6,
+  0x4C,  0x04,  0x46,  0x82,  0x04,  0x01,  0x03,  0xD8,  0xB4,  0x98,  0x6A,  0x96,  0x46,  0x82,  0xFE,  0x95,
+  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0xB6,  0x2D,  0x02,  0xA6,  0x6C,  0x02,  0x07,  0xA6,  0x5A,  0x02,
+  0x06,  0xA6,  0x5E,  0x02,  0x03,  0xA6,  0x62,  0x02,  0xC2,  0x88,  0x7C,  0x95,  0x48,  0x82,  0x60,  0x96,
+  0x48,  0x82,  0x04,  0x23,  0xA0,  0x01,  0x14,  0x23,  0xA1,  0x01,  0x3C,  0x84,  0x04,  0x01,  0x0C,  0xDC,
+  0xE0,  0x23,  0x25,  0x61,  0xEF,  0x00,  0x14,  0x01,  0x4F,  0x04,  0xA8,  0x01,  0x6F,  0x00,  0xA5,  0x01,
+  0x03,  0x23,  0xA4,  0x01,  0x06,  0x23,  0x9C,  0x01,  0x24,  0x2B,  0x1C,  0x01,  0x02,  0xA6,  0xAA,  0x02,
+  0x07,  0xA6,  0x5A,  0x02,  0x06,  0xA6,  0x5E,  0x02,  0x03,  0xA6,  0x20,  0x04,  0x01,  0xA6,  0xB4,  0x02,
+  0x00,  0xA6,  0xB4,  0x02,  0x00,  0x33,  0x12,  0x00,  0xC2,  0x88,  0x00,  0x0E,  0x80,  0x63,  0x00,  0x43,
+  0x00,  0xA0,  0x8C,  0x02,  0x4D,  0x04,  0x04,  0x01,  0x0B,  0xDC,  0xE7,  0x23,  0x04,  0x61,  0x84,  0x01,
+  0x10,  0x31,  0x12,  0x35,  0x14,  0x01,  0xEC,  0x00,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,  0xEA,  0x82,
+  0x18,  0x23,  0x04,  0x61,  0x18,  0xA0,  0xE2,  0x02,  0x04,  0x01,  0xA2,  0xC8,  0x00,  0x33,  0x1F,  0x00,
+  0xC2,  0x88,  0x08,  0x31,  0x0A,  0x35,  0x0C,  0x39,  0x0E,  0x3D,  0x7E,  0x98,  0xB6,  0x2D,  0x01,  0xA6,
+  0x14,  0x03,  0x00,  0xA6,  0x14,  0x03,  0x07,  0xA6,  0x0C,  0x03,  0x06,  0xA6,  0x10,  0x03,  0x03,  0xA6,
+  0x20,  0x04,  0x02,  0xA6,  0x6C,  0x02,  0x00,  0x33,  0x33,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0xEE,  0x82,
+  0x60,  0x96,  0xEE,  0x82,  0x82,  0x98,  0x80,  0x42,  0x7E,  0x98,  0x64,  0xE4,  0x04,  0x01,  0x2D,  0xC8,
+  0x31,  0x05,  0x07,  0x01,  0x00,  0xA2,  0x54,  0x03,  0x00,  0x43,  0x87,  0x01,  0x05,  0x05,  0x86,  0x98,
+  0x7E,  0x98,  0x00,  0xA6,  0x16,  0x03,  0x07,  0xA6,  0x4C,  0x03,  0x03,  0xA6,  0x3C,  0x04,  0x06,  0xA6,
+  0x50,  0x03,  0x01,  0xA6,  0x16,  0x03,  0x00,  0x33,  0x25,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0x32,  0x83,
+  0x60,  0x96,  0x32,  0x83,  0x04,  0x01,  0x10,  0xCE,  0x07,  0xC8,  0x05,  0x05,  0xEB,  0x04,  0x00,  0x33,
+  0x00,  0x20,  0xC0,  0x20,  0x81,  0x62,  0x72,  0x83,  0x00,  0x01,  0x05,  0x05,  0xFF,  0xA2,  0x7A,  0x03,
+  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x2E,  0x83,  0x05,  0x05,  0x15,  0x01,  0x00,  0xA2,  0x9A,  0x03,
+  0xEC,  0x00,  0x6E,  0x00,  0x95,  0x01,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,  0x01,  0xA6,  0x96,  0x03,
+  0x00,  0xA6,  0x96,  0x03,  0x10,  0x84,  0x80,  0x42,  0x7E,  0x98,  0x01,  0xA6,  0xA4,  0x03,  0x00,  0xA6,
+  0xBC,  0x03,  0x10,  0x84,  0xA8,  0x98,  0x80,  0x42,  0x01,  0xA6,  0xA4,  0x03,  0x07,  0xA6,  0xB2,  0x03,
+  0xD4,  0x83,  0x7C,  0x95,  0xA8,  0x83,  0x00,  0x33,  0x2F,  0x00,  0xC2,  0x88,  0xA8,  0x98,  0x80,  0x42,
+  0x00,  0xA6,  0xBC,  0x03,  0x07,  0xA6,  0xCA,  0x03,  0xD4,  0x83,  0x7C,  0x95,  0xC0,  0x83,  0x00,  0x33,
+  0x26,  0x00,  0xC2,  0x88,  0x38,  0x2B,  0x80,  0x32,  0x80,  0x36,  0x04,  0x23,  0xA0,  0x01,  0x12,  0x23,
+  0xA1,  0x01,  0x10,  0x84,  0x07,  0xF0,  0x06,  0xA4,  0xF4,  0x03,  0x80,  0x6B,  0x80,  0x67,  0x05,  0x23,
+  0x83,  0x03,  0x80,  0x63,  0x03,  0xA6,  0x0E,  0x04,  0x07,  0xA6,  0x06,  0x04,  0x06,  0xA6,  0x0A,  0x04,
+  0x00,  0x33,  0x17,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0xF4,  0x83,  0x60,  0x96,  0xF4,  0x83,  0x20,  0x84,
+  0x07,  0xF0,  0x06,  0xA4,  0x20,  0x04,  0x80,  0x6B,  0x80,  0x67,  0x05,  0x23,  0x83,  0x03,  0x80,  0x63,
+  0xB6,  0x2D,  0x03,  0xA6,  0x3C,  0x04,  0x07,  0xA6,  0x34,  0x04,  0x06,  0xA6,  0x38,  0x04,  0x00,  0x33,
+  0x30,  0x00,  0xC2,  0x88,  0x7C,  0x95,  0x20,  0x84,  0x60,  0x96,  0x20,  0x84,  0x1D,  0x01,  0x06,  0xCC,
+  0x00,  0x33,  0x00,  0x84,  0xC0,  0x20,  0x00,  0x23,  0xEA,  0x00,  0x81,  0x62,  0xA2,  0x0D,  0x80,  0x63,
+  0x07,  0xA6,  0x5A,  0x04,  0x00,  0x33,  0x18,  0x00,  0xC2,  0x88,  0x03,  0x03,  0x80,  0x63,  0xA3,  0x01,
+  0x07,  0xA4,  0x64,  0x04,  0x23,  0x01,  0x00,  0xA2,  0x86,  0x04,  0x0A,  0xA0,  0x76,  0x04,  0xE0,  0x00,
+  0x00,  0x33,  0x1D,  0x00,  0xC2,  0x88,  0x0B,  0xA0,  0x82,  0x04,  0xE0,  0x00,  0x00,  0x33,  0x1E,  0x00,
+  0xC2,  0x88,  0x42,  0x23,  0xF8,  0x88,  0x00,  0x23,  0x22,  0xA3,  0xE6,  0x04,  0x08,  0x23,  0x22,  0xA3,
+  0xA2,  0x04,  0x28,  0x23,  0x22,  0xA3,  0xAE,  0x04,  0x02,  0x23,  0x22,  0xA3,  0xC4,  0x04,  0x42,  0x23,
+  0xF8,  0x88,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,  0xAE,  0x04,  0x45,  0x23,  0xF8,  0x88,  0x04,  0x98,
+  0x00,  0xA2,  0xC0,  0x04,  0xB4,  0x98,  0x00,  0x33,  0x00,  0x82,  0xC0,  0x20,  0x81,  0x62,  0xE8,  0x81,
+  0x47,  0x23,  0xF8,  0x88,  0x04,  0x01,  0x0B,  0xDE,  0x04,  0x98,  0xB4,  0x98,  0x00,  0x33,  0x00,  0x81,
+  0xC0,  0x20,  0x81,  0x62,  0x14,  0x01,  0x00,  0xA0,  0x00,  0x02,  0x43,  0x23,  0xF8,  0x88,  0x04,  0x23,
+  0xA0,  0x01,  0x44,  0x23,  0xA1,  0x01,  0x80,  0x73,  0x4D,  0x00,  0x03,  0xA3,  0xF4,  0x04,  0x00,  0x33,
+  0x27,  0x00,  0xC2,  0x88,  0x04,  0x01,  0x04,  0xDC,  0x02,  0x23,  0xA2,  0x01,  0x04,  0x23,  0xA0,  0x01,
+  0x04,  0x98,  0x26,  0x95,  0x4B,  0x00,  0xF6,  0x00,  0x4F,  0x04,  0x4F,  0x00,  0x00,  0xA3,  0x22,  0x05,
+  0x00,  0x05,  0x76,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x1C,  0x05,  0x0A,  0x85,  0x46,  0x97,  0xCD,  0x04,
+  0x24,  0x85,  0x48,  0x04,  0x84,  0x80,  0x02,  0x01,  0x03,  0xDA,  0x80,  0x23,  0x82,  0x01,  0x34,  0x85,
+  0x02,  0x23,  0xA0,  0x01,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x40,  0x05,  0x1D,  0x01,  0x04,  0xD6,
+  0xFF,  0x23,  0x86,  0x41,  0x4B,  0x60,  0xCB,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x49,  0x00,  0x81,  0x01,
+  0x04,  0x01,  0x02,  0xC8,  0x30,  0x01,  0x80,  0x01,  0xF7,  0x04,  0x03,  0x01,  0x49,  0x04,  0x80,  0x01,
+  0xC9,  0x00,  0x00,  0x05,  0x00,  0x01,  0xFF,  0xA0,  0x60,  0x05,  0x77,  0x04,  0x01,  0x23,  0xEA,  0x00,
+  0x5D,  0x00,  0xFE,  0xC7,  0x00,  0x62,  0x00,  0x23,  0xEA,  0x00,  0x00,  0x63,  0x07,  0xA4,  0xF8,  0x05,
+  0x03,  0x03,  0x02,  0xA0,  0x8E,  0x05,  0xF4,  0x85,  0x00,  0x33,  0x2D,  0x00,  0xC2,  0x88,  0x04,  0xA0,
+  0xB8,  0x05,  0x80,  0x63,  0x00,  0x23,  0xDF,  0x00,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0xA4,  0x05,
+  0x1D,  0x01,  0x06,  0xD6,  0x02,  0x23,  0x02,  0x41,  0x82,  0x01,  0x50,  0x00,  0x62,  0x97,  0x04,  0x85,
+  0x04,  0x23,  0x02,  0x41,  0x82,  0x01,  0x04,  0x85,  0x08,  0xA0,  0xBE,  0x05,  0xF4,  0x85,  0x03,  0xA0,
+  0xC4,  0x05,  0xF4,  0x85,  0x01,  0xA0,  0xCE,  0x05,  0x88,  0x00,  0x80,  0x63,  0xCC,  0x86,  0x07,  0xA0,
+  0xEE,  0x05,  0x5F,  0x00,  0x00,  0x2B,  0xDF,  0x08,  0x00,  0xA2,  0xE6,  0x05,  0x80,  0x67,  0x80,  0x63,
+  0x01,  0xA2,  0x7A,  0x06,  0x7C,  0x85,  0x06,  0x23,  0x68,  0x98,  0x48,  0x23,  0xF8,  0x88,  0x07,  0x23,
+  0x80,  0x00,  0x06,  0x87,  0x80,  0x63,  0x7C,  0x85,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x4A,  0x00,
+  0x06,  0x61,  0x00,  0xA2,  0x36,  0x06,  0x1D,  0x01,  0x16,  0xD4,  0xC0,  0x23,  0x07,  0x41,  0x83,  0x03,
+  0x80,  0x63,  0x06,  0xA6,  0x1C,  0x06,  0x00,  0x33,  0x37,  0x00,  0xC2,  0x88,  0x1D,  0x01,  0x01,  0xD6,
+  0x20,  0x23,  0x63,  0x60,  0x83,  0x03,  0x80,  0x63,  0x02,  0x23,  0xDF,  0x00,  0x07,  0xA6,  0x7C,  0x05,
+  0xEF,  0x04,  0x6F,  0x00,  0x00,  0x63,  0x4B,  0x00,  0x06,  0x41,  0xCB,  0x00,  0x52,  0x00,  0x06,  0x61,
+  0x00,  0xA2,  0x4E,  0x06,  0x1D,  0x01,  0x03,  0xCA,  0xC0,  0x23,  0x07,  0x41,  0x00,  0x63,  0x1D,  0x01,
+  0x04,  0xCC,  0x00,  0x33,  0x00,  0x83,  0xC0,  0x20,  0x81,  0x62,  0x80,  0x23,  0x07,  0x41,  0x00,  0x63,
+  0x80,  0x67,  0x08,  0x23,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x01,  0x23,  0xDF,  0x00,  0x06,  0xA6,
+  0x84,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x80,  0x63,  0x00,  0x33,  0x00,  0x40,  0xC0,  0x20,
+  0x81,  0x62,  0x00,  0x63,  0x00,  0x00,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,  0x94,  0x06,
+  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x00,  0x01,  0xA0,  0x14,  0x07,  0x00,  0x2B,  0x40,  0x0E,  0x80,  0x63,
+  0x01,  0x00,  0x06,  0xA6,  0xAA,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x40,  0x0E,  0x80,  0x63,  0x00,  0x43,
+  0x00,  0xA0,  0xA2,  0x06,  0x06,  0xA6,  0xBC,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x40,  0x0E,
+  0x80,  0x63,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x07,  0xA6,  0xD6,  0x06,
+  0x00,  0x33,  0x2A,  0x00,  0xC2,  0x88,  0x03,  0x03,  0x80,  0x63,  0x89,  0x00,  0x0A,  0x2B,  0x07,  0xA6,
+  0xE8,  0x06,  0x00,  0x33,  0x29,  0x00,  0xC2,  0x88,  0x00,  0x43,  0x00,  0xA2,  0xF4,  0x06,  0xC0,  0x0E,
+  0x80,  0x63,  0xDE,  0x86,  0xC0,  0x0E,  0x00,  0x33,  0x00,  0x80,  0xC0,  0x20,  0x81,  0x62,  0x04,  0x01,
+  0x02,  0xDA,  0x80,  0x63,  0x7C,  0x85,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x8C,  0x06,  0x00,  0x33,
+  0x2C,  0x00,  0xC2,  0x88,  0x0C,  0xA2,  0x2E,  0x07,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,
+  0x2C,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x33,  0x3D,  0x00,  0xC2,  0x88,  0x00,  0x00,  0x80,  0x67,
+  0x83,  0x03,  0x80,  0x63,  0x0C,  0xA0,  0x44,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0xBF,  0x23,  0x04,  0x61,
+  0x84,  0x01,  0xE6,  0x84,  0x00,  0x63,  0xF0,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x00,  0x01,  0xF2,  0x00,
+  0x01,  0x05,  0x80,  0x01,  0x72,  0x04,  0x71,  0x00,  0x81,  0x01,  0x70,  0x04,  0x80,  0x05,  0x81,  0x05,
+  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x70,  0x00,  0x81,  0x01,
+  0x70,  0x04,  0x71,  0x00,  0x81,  0x01,  0x72,  0x00,  0x80,  0x01,  0x71,  0x04,  0x70,  0x00,  0x80,  0x01,
+  0x70,  0x04,  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x00,  0x01,  0xF1,  0x00,  0x70,  0x00,
+  0x80,  0x01,  0x70,  0x04,  0x71,  0x00,  0x80,  0x01,  0x72,  0x00,  0x81,  0x01,  0x71,  0x04,  0x70,  0x00,
+  0x81,  0x01,  0x70,  0x04,  0x00,  0x63,  0x00,  0x23,  0xB3,  0x01,  0x83,  0x05,  0xA3,  0x01,  0xA2,  0x01,
+  0xA1,  0x01,  0x01,  0x23,  0xA0,  0x01,  0x00,  0x01,  0xC8,  0x00,  0x03,  0xA1,  0xC4,  0x07,  0x00,  0x33,
+  0x07,  0x00,  0xC2,  0x88,  0x80,  0x05,  0x81,  0x05,  0x04,  0x01,  0x11,  0xC8,  0x48,  0x00,  0xB0,  0x01,
+  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x05,  0x01,  0x48,  0x04,  0x00,  0x43,  0x00,  0xA2,  0xE4,  0x07,
+  0x00,  0x05,  0xDA,  0x87,  0x00,  0x01,  0xC8,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x05,  0x05,  0x00,  0x63,
+  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x80,  0x43,  0x76,  0x08,  0x80,  0x02,
+  0x77,  0x04,  0x00,  0x63,  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x00,  0xA0,
+  0x14,  0x08,  0x16,  0x88,  0x00,  0x43,  0x76,  0x08,  0x80,  0x02,  0x77,  0x04,  0x00,  0x63,  0xF3,  0x04,
+  0x00,  0x23,  0xF4,  0x00,  0x74,  0x00,  0x80,  0x43,  0xF4,  0x00,  0xCF,  0x40,  0x00,  0xA2,  0x44,  0x08,
+  0x74,  0x04,  0x02,  0x01,  0xF7,  0xC9,  0xF6,  0xD9,  0x00,  0x01,  0x01,  0xA1,  0x24,  0x08,  0x04,  0x98,
+  0x26,  0x95,  0x24,  0x88,  0x73,  0x04,  0x00,  0x63,  0xF3,  0x04,  0x75,  0x04,  0x5A,  0x88,  0x02,  0x01,
+  0x04,  0xD8,  0x46,  0x97,  0x04,  0x98,  0x26,  0x95,  0x4A,  0x88,  0x75,  0x00,  0x00,  0xA3,  0x64,  0x08,
+  0x00,  0x05,  0x4E,  0x88,  0x73,  0x04,  0x00,  0x63,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x76,  0x08,
+  0x00,  0x33,  0x3E,  0x00,  0xC2,  0x88,  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x38,  0x2B,
+  0x9C,  0x88,  0x38,  0x2B,  0x92,  0x88,  0x32,  0x09,  0x31,  0x05,  0x92,  0x98,  0x05,  0x05,  0xB2,  0x09,
+  0x00,  0x63,  0x00,  0x32,  0x00,  0x36,  0x00,  0x3A,  0x00,  0x3E,  0x00,  0x63,  0x80,  0x32,  0x80,  0x36,
+  0x80,  0x3A,  0x80,  0x3E,  0xB4,  0x3D,  0x00,  0x63,  0x38,  0x2B,  0x40,  0x32,  0x40,  0x36,  0x40,  0x3A,
+  0x40,  0x3E,  0x00,  0x63,  0x5A,  0x20,  0xC9,  0x40,  0x00,  0xA0,  0xB4,  0x08,  0x5D,  0x00,  0xFE,  0xC3,
+  0x00,  0x63,  0x80,  0x73,  0xE6,  0x20,  0x02,  0x23,  0xE8,  0x00,  0x82,  0x73,  0xFF,  0xFD,  0x80,  0x73,
+  0x13,  0x23,  0xF8,  0x88,  0x66,  0x20,  0xC0,  0x20,  0x04,  0x23,  0xA0,  0x01,  0xA1,  0x23,  0xA1,  0x01,
+  0x81,  0x62,  0xE2,  0x88,  0x80,  0x73,  0x80,  0x77,  0x68,  0x00,  0x00,  0xA2,  0x80,  0x00,  0x03,  0xC2,
+  0xF1,  0xC7,  0x41,  0x23,  0xF8,  0x88,  0x11,  0x23,  0xA1,  0x01,  0x04,  0x23,  0xA0,  0x01,  0xE6,  0x84,
+};
+
+STATIC ushort _asc_mcode_size = sizeof(_asc_mcode_buf);
+STATIC ADV_DCNT _asc_mcode_chksum = 0x012C453FUL;
+
+#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16
+STATIC uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] =
+{
+    INQUIRY,
+    REQUEST_SENSE,
+    READ_CAPACITY,
+    READ_TOC,
+    MODE_SELECT,
+    MODE_SENSE,
+    MODE_SELECT_10,
+    MODE_SENSE_10,
+    0xFF,
+    0xFF,
+    0xFF,
+    0xFF,
+    0xFF,
+    0xFF,
+    0xFF,
+    0xFF
+};
+
+STATIC int
+AscExeScsiQueue(
+                   ASC_DVC_VAR *asc_dvc,
+                   ASC_SCSI_Q *scsiq
+)
+{
+    PortAddr            iop_base;
+    ulong               last_int_level;
+    int                 sta;
+    int                 n_q_required;
+    int                 disable_syn_offset_one_fix;
+    int                 i;
+    ASC_PADDR           addr;
+    ASC_EXE_CALLBACK    asc_exe_callback;
+    ushort              sg_entry_cnt = 0;
+    ushort              sg_entry_cnt_minus_one = 0;
+    uchar               target_ix;
+    uchar               tid_no;
+    uchar               sdtr_data;
+    uchar               extra_bytes;
+    uchar               scsi_cmd;
+    uchar               disable_cmd;
+    ASC_SG_HEAD         *sg_head;
+    ASC_DCNT            data_cnt;
+
+    iop_base = asc_dvc->iop_base;
+    sg_head = scsiq->sg_head;
+    asc_exe_callback = asc_dvc->exe_callback;
+    if (asc_dvc->err_code != 0)
+        return (ERR);
+    if (scsiq == (ASC_SCSI_Q *) 0L) {
+        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_SCSIQ_NULL_PTR);
+        return (ERR);
+    }
+    scsiq->q1.q_no = 0;
+    if ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {
+        scsiq->q1.extra_bytes = 0;
+    }
+    sta = 0;
+    target_ix = scsiq->q2.target_ix;
+    tid_no = ASC_TIX_TO_TID(target_ix);
+    n_q_required = 1;
+    if (scsiq->cdbptr[0] == REQUEST_SENSE) {
+        if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {
+            asc_dvc->sdtr_done &= ~scsiq->q1.target_id;
+            sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+            AscMsgOutSDTR(asc_dvc,
+                          asc_dvc->sdtr_period_tbl[(sdtr_data >> 4) &
+                          (uchar) (asc_dvc->max_sdtr_index - 1)],
+                          (uchar) (sdtr_data & (uchar) ASC_SYN_MAX_OFFSET));
+            scsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);
+        }
+    }
+    last_int_level = DvcEnterCritical();
+    if (asc_dvc->in_critical_cnt != 0) {
+        DvcLeaveCritical(last_int_level);
+        AscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);
+        return (ERR);
+    }
+    asc_dvc->in_critical_cnt++;
+    if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
+        if ((sg_entry_cnt = sg_head->entry_cnt) == 0) {
+            asc_dvc->in_critical_cnt--;
+            DvcLeaveCritical(last_int_level);
+            return (ERR);
+        }
+#if !CC_VERY_LONG_SG_LIST
+        if (sg_entry_cnt > ASC_MAX_SG_LIST)
+        {
+            asc_dvc->in_critical_cnt--;
+            DvcLeaveCritical(last_int_level);
+            return(ERR);
+        }
+#endif /* !CC_VERY_LONG_SG_LIST */
+        if (sg_entry_cnt == 1) {
+            scsiq->q1.data_addr = (ADV_PADDR) sg_head->sg_list[0].addr;
+            scsiq->q1.data_cnt = (ADV_DCNT) sg_head->sg_list[0].bytes;
+            scsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);
+        }
+        sg_entry_cnt_minus_one = sg_entry_cnt - 1;
+    }
+    scsi_cmd = scsiq->cdbptr[0];
+    disable_syn_offset_one_fix = FALSE;
+    if ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&
+        !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {
+        if (scsiq->q1.cntl & QC_SG_HEAD) {
+            data_cnt = 0;
+            for (i = 0; i < sg_entry_cnt; i++) {
+                data_cnt += (ADV_DCNT) le32_to_cpu(sg_head->sg_list[i].bytes);
+            }
+        } else {
+            data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
+        }
+        if (data_cnt != 0UL) {
+            if (data_cnt < 512UL) {
+                disable_syn_offset_one_fix = TRUE;
+            } else {
+                for (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST; i++) {
+                    disable_cmd = _syn_offset_one_disable_cmd[i];
+                    if (disable_cmd == 0xFF) {
+                        break;
+                    }
+                    if (scsi_cmd == disable_cmd) {
+                        disable_syn_offset_one_fix = TRUE;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+    if (disable_syn_offset_one_fix) {
+        scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG;
+        scsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
+                               ASC_TAG_FLAG_DISABLE_DISCONNECT);
+    } else {
+        scsiq->q2.tag_code &= 0x27;
+    }
+    if ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {
+        if (asc_dvc->bug_fix_cntl) {
+            if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
+                if ((scsi_cmd == READ_6) ||
+                    (scsi_cmd == READ_10)) {
+                    addr =
+                        (ADV_PADDR) le32_to_cpu(
+                            sg_head->sg_list[sg_entry_cnt_minus_one].addr) +
+                        (ADV_DCNT) le32_to_cpu(
+                            sg_head->sg_list[sg_entry_cnt_minus_one].bytes);
+                    extra_bytes = (uchar) ((ushort) addr & 0x0003);
+                    if ((extra_bytes != 0) &&
+                        ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES)
+                         == 0)) {
+                        scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;
+                        scsiq->q1.extra_bytes = extra_bytes;
+                        data_cnt = le32_to_cpu(
+                            sg_head->sg_list[sg_entry_cnt_minus_one].bytes);
+                        data_cnt -= (ASC_DCNT) extra_bytes;
+                        sg_head->sg_list[sg_entry_cnt_minus_one].bytes =
+                            cpu_to_le32(data_cnt);
+                    }
+                }
+            }
+        }
+        sg_head->entry_to_copy = sg_head->entry_cnt;
+#if CC_VERY_LONG_SG_LIST
+        /*
+         * Set the sg_entry_cnt to the maximum possible. The rest of
+         * the SG elements will be copied when the RISC completes the
+         * SG elements that fit and halts.
+         */
+        if (sg_entry_cnt > ASC_MAX_SG_LIST)
+        {
+             sg_entry_cnt = ASC_MAX_SG_LIST;
+        }
+#endif /* CC_VERY_LONG_SG_LIST */
+        n_q_required = AscSgListToQueue(sg_entry_cnt);
+        if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=
+            (uint) n_q_required) || ((scsiq->q1.cntl & QC_URGENT) != 0)) {
+            if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
+                                        n_q_required)) == 1) {
+                asc_dvc->in_critical_cnt--;
+                if (asc_exe_callback != 0) {
+                    (*asc_exe_callback) (asc_dvc, scsiq);
+                }
+                DvcLeaveCritical(last_int_level);
+                return (sta);
+            }
+        }
+    } else {
+        if (asc_dvc->bug_fix_cntl) {
+            if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {
+                if ((scsi_cmd == READ_6) ||
+                    (scsi_cmd == READ_10)) {
+                    addr = le32_to_cpu(scsiq->q1.data_addr) +
+                        le32_to_cpu(scsiq->q1.data_cnt);
+                    extra_bytes = (uchar) ((ushort) addr & 0x0003);
+                    if ((extra_bytes != 0) &&
+                        ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES)
+                          == 0)) {
+                        data_cnt = le32_to_cpu(scsiq->q1.data_cnt);
+                        if (((ushort) data_cnt & 0x01FF) == 0) {
+                            scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES;
+                            data_cnt -= (ASC_DCNT) extra_bytes;
+                            scsiq->q1.data_cnt = cpu_to_le32(data_cnt);
+                            scsiq->q1.extra_bytes = extra_bytes;
+                        }
+                    }
+                }
+            }
+        }
+        n_q_required = 1;
+        if ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||
+            ((scsiq->q1.cntl & QC_URGENT) != 0)) {
+            if ((sta = AscSendScsiQueue(asc_dvc, scsiq,
+                                        n_q_required)) == 1) {
+                asc_dvc->in_critical_cnt--;
+                if (asc_exe_callback != 0) {
+                    (*asc_exe_callback) (asc_dvc, scsiq);
+                }
+                DvcLeaveCritical(last_int_level);
+                return (sta);
+            }
+        }
+    }
+    asc_dvc->in_critical_cnt--;
+    DvcLeaveCritical(last_int_level);
+    return (sta);
+}
+
+STATIC int
+AscSendScsiQueue(
+                    ASC_DVC_VAR *asc_dvc,
+                    ASC_SCSI_Q *scsiq,
+                    uchar n_q_required
+)
+{
+    PortAddr            iop_base;
+    uchar               free_q_head;
+    uchar               next_qp;
+    uchar               tid_no;
+    uchar               target_ix;
+    int                 sta;
+
+    iop_base = asc_dvc->iop_base;
+    target_ix = scsiq->q2.target_ix;
+    tid_no = ASC_TIX_TO_TID(target_ix);
+    sta = 0;
+    free_q_head = (uchar) AscGetVarFreeQHead(iop_base);
+    if (n_q_required > 1) {
+        if ((next_qp = AscAllocMultipleFreeQueue(iop_base,
+                                       free_q_head, (uchar) (n_q_required)))
+            != (uchar) ASC_QLINK_END) {
+            asc_dvc->last_q_shortage = 0;
+            scsiq->sg_head->queue_cnt = n_q_required - 1;
+            scsiq->q1.q_no = free_q_head;
+            if ((sta = AscPutReadySgListQueue(asc_dvc, scsiq,
+                                              free_q_head)) == 1) {
+                AscPutVarFreeQHead(iop_base, next_qp);
+                asc_dvc->cur_total_qng += (uchar) (n_q_required);
+                asc_dvc->cur_dvc_qng[tid_no]++;
+            }
+            return (sta);
+        }
+    } else if (n_q_required == 1) {
+        if ((next_qp = AscAllocFreeQueue(iop_base,
+                                         free_q_head)) != ASC_QLINK_END) {
+            scsiq->q1.q_no = free_q_head;
+            if ((sta = AscPutReadyQueue(asc_dvc, scsiq,
+                                        free_q_head)) == 1) {
+                AscPutVarFreeQHead(iop_base, next_qp);
+                asc_dvc->cur_total_qng++;
+                asc_dvc->cur_dvc_qng[tid_no]++;
+            }
+            return (sta);
+        }
+    }
+    return (sta);
+}
+
+STATIC int
+AscSgListToQueue(
+                    int sg_list
+)
+{
+    int                 n_sg_list_qs;
+
+    n_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);
+    if (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)
+        n_sg_list_qs++;
+    return (n_sg_list_qs + 1);
+}
+
+
+STATIC uint
+AscGetNumOfFreeQueue(
+                        ASC_DVC_VAR *asc_dvc,
+                        uchar target_ix,
+                        uchar n_qs
+)
+{
+    uint                cur_used_qs;
+    uint                cur_free_qs;
+    ASC_SCSI_BIT_ID_TYPE target_id;
+    uchar               tid_no;
+
+    target_id = ASC_TIX_TO_TARGET_ID(target_ix);
+    tid_no = ASC_TIX_TO_TID(target_ix);
+    if ((asc_dvc->unit_not_ready & target_id) ||
+        (asc_dvc->queue_full_or_busy & target_id)) {
+        return (0);
+    }
+    if (n_qs == 1) {
+        cur_used_qs = (uint) asc_dvc->cur_total_qng +
+          (uint) asc_dvc->last_q_shortage +
+          (uint) ASC_MIN_FREE_Q;
+    } else {
+        cur_used_qs = (uint) asc_dvc->cur_total_qng +
+          (uint) ASC_MIN_FREE_Q;
+    }
+    if ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {
+        cur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;
+        if (asc_dvc->cur_dvc_qng[tid_no] >=
+            asc_dvc->max_dvc_qng[tid_no]) {
+            return (0);
+        }
+        return (cur_free_qs);
+    }
+    if (n_qs > 1) {
+        if ((n_qs > asc_dvc->last_q_shortage) && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {
+            asc_dvc->last_q_shortage = n_qs;
+        }
+    }
+    return (0);
+}
+
+STATIC int
+AscPutReadyQueue(
+                    ASC_DVC_VAR *asc_dvc,
+                    ASC_SCSI_Q *scsiq,
+                    uchar q_no
+)
+{
+    ushort              q_addr;
+    uchar               tid_no;
+    uchar               sdtr_data;
+    uchar               syn_period_ix;
+    uchar               syn_offset;
+    PortAddr            iop_base;
+
+    iop_base = asc_dvc->iop_base;
+    if (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&
+        ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {
+        tid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);
+        sdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);
+        syn_period_ix = (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);
+        syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;
+        AscMsgOutSDTR(asc_dvc,
+                      asc_dvc->sdtr_period_tbl[syn_period_ix],
+                      syn_offset);
+        scsiq->q1.cntl |= QC_MSG_OUT;
+    }
+    q_addr = ASC_QNO_TO_QADDR(q_no);
+    if ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {
+        scsiq->q2.tag_code &= ~MSG_SIMPLE_TAG ;
+    }
+    scsiq->q1.status = QS_FREE;
+    AscMemWordCopyPtrToLram(iop_base,
+                         q_addr + ASC_SCSIQ_CDB_BEG,
+                         (uchar *) scsiq->cdbptr,
+                         scsiq->q2.cdb_len >> 1);
+
+    DvcPutScsiQ(iop_base,
+                q_addr + ASC_SCSIQ_CPY_BEG,
+                (uchar *) &scsiq->q1.cntl,
+                ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);
+    AscWriteLramWord(iop_base,
+                     (ushort) (q_addr + (ushort) ASC_SCSIQ_B_STATUS),
+             (ushort) (((ushort) scsiq->q1.q_no << 8) | (ushort) QS_READY));
+    return (1);
+}
+
+STATIC int
+AscPutReadySgListQueue(
+                          ASC_DVC_VAR *asc_dvc,
+                          ASC_SCSI_Q *scsiq,
+                          uchar q_no
+)
+{
+    int                 sta;
+    int                 i;
+    ASC_SG_HEAD *sg_head;
+    ASC_SG_LIST_Q       scsi_sg_q;
+    ASC_DCNT            saved_data_addr;
+    ASC_DCNT            saved_data_cnt;
+    PortAddr            iop_base;
+    ushort              sg_list_dwords;
+    ushort              sg_index;
+    ushort              sg_entry_cnt;
+    ushort              q_addr;
+    uchar               next_qp;
+
+    iop_base = asc_dvc->iop_base;
+    sg_head = scsiq->sg_head;
+    saved_data_addr = scsiq->q1.data_addr;
+    saved_data_cnt = scsiq->q1.data_cnt;
+    scsiq->q1.data_addr = (ASC_PADDR) sg_head->sg_list[0].addr;
+    scsiq->q1.data_cnt = (ASC_DCNT) sg_head->sg_list[0].bytes;
+#if CC_VERY_LONG_SG_LIST
+    /*
+     * If sg_head->entry_cnt is greater than ASC_MAX_SG_LIST
+     * then not all SG elements will fit in the allocated queues.
+     * The rest of the SG elements will be copied when the RISC
+     * completes the SG elements that fit and halts.
+     */
+    if (sg_head->entry_cnt > ASC_MAX_SG_LIST)
+    {
+         /*
+          * Set sg_entry_cnt to be the number of SG elements that
+          * will fit in the allocated SG queues. It is minus 1, because
+          * the first SG element is handled above. ASC_MAX_SG_LIST is
+          * already inflated by 1 to account for this. For example it
+          * may be 50 which is 1 + 7 queues * 7 SG elements.
+          */
+         sg_entry_cnt = ASC_MAX_SG_LIST - 1;
+
+         /*
+          * Keep track of remaining number of SG elements that will
+          * need to be handled from a_isr.c.
+          */
+         scsiq->remain_sg_entry_cnt = sg_head->entry_cnt - ASC_MAX_SG_LIST;
+    } else
+    {
+#endif /* CC_VERY_LONG_SG_LIST */
+         /*
+          * Set sg_entry_cnt to be the number of SG elements that
+          * will fit in the allocated SG queues. It is minus 1, because
+          * the first SG element is handled above.
+          */
+         sg_entry_cnt = sg_head->entry_cnt - 1;
+#if CC_VERY_LONG_SG_LIST
+    }
+#endif /* CC_VERY_LONG_SG_LIST */
+    if (sg_entry_cnt != 0) {
+        scsiq->q1.cntl |= QC_SG_HEAD;
+        q_addr = ASC_QNO_TO_QADDR(q_no);
+        sg_index = 1;
+        scsiq->q1.sg_queue_cnt = sg_head->queue_cnt;
+        scsi_sg_q.sg_head_qp = q_no;
+        scsi_sg_q.cntl = QCSG_SG_XFER_LIST;
+        for (i = 0; i < sg_head->queue_cnt; i++) {
+            scsi_sg_q.seq_no = i + 1;
+            if (sg_entry_cnt > ASC_SG_LIST_PER_Q) {
+                sg_list_dwords = (uchar) (ASC_SG_LIST_PER_Q * 2);
+                sg_entry_cnt -= ASC_SG_LIST_PER_Q;
+                if (i == 0) {
+                    scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q;
+                    scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q;
+                } else {
+                    scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1;
+                    scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q - 1;
+                }
+            } else {
+#if CC_VERY_LONG_SG_LIST
+                /*
+                 * This is the last SG queue in the list of
+                 * allocated SG queues. If there are more
+                 * SG elements than will fit in the allocated
+                 * queues, then set the QCSG_SG_XFER_MORE flag.
+                 */
+                if (sg_head->entry_cnt > ASC_MAX_SG_LIST)
+                {
+                    scsi_sg_q.cntl |= QCSG_SG_XFER_MORE;
+                } else
+                {
+#endif /* CC_VERY_LONG_SG_LIST */
+                    scsi_sg_q.cntl |= QCSG_SG_XFER_END;
+#if CC_VERY_LONG_SG_LIST
+                }
+#endif /* CC_VERY_LONG_SG_LIST */
+                sg_list_dwords = sg_entry_cnt << 1;
+                if (i == 0) {
+                    scsi_sg_q.sg_list_cnt = sg_entry_cnt;
+                    scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt;
+                } else {
+                    scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1;
+                    scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1;
+                }
+                sg_entry_cnt = 0;
+            }
+            next_qp = AscReadLramByte(iop_base,
+                                      (ushort) (q_addr + ASC_SCSIQ_B_FWD));
+            scsi_sg_q.q_no = next_qp;
+            q_addr = ASC_QNO_TO_QADDR(next_qp);
+            AscMemWordCopyPtrToLram(iop_base,
+                                q_addr + ASC_SCSIQ_SGHD_CPY_BEG,
+                                (uchar *) &scsi_sg_q,
+                                sizeof(ASC_SG_LIST_Q) >> 1);
+            AscMemDWordCopyPtrToLram(iop_base,
+                                q_addr + ASC_SGQ_LIST_BEG,
+                                (uchar *) &sg_head->sg_list[sg_index],
+                                sg_list_dwords);
+            sg_index += ASC_SG_LIST_PER_Q;
+            scsiq->next_sg_index = sg_index;
+        }
+    } else {
+        scsiq->q1.cntl &= ~QC_SG_HEAD;
+    }
+    sta = AscPutReadyQueue(asc_dvc, scsiq, q_no);
+    scsiq->q1.data_addr = saved_data_addr;
+    scsiq->q1.data_cnt = saved_data_cnt;
+    return (sta);
+}
+
+STATIC int
+AscSetRunChipSynRegAtID(
+                           PortAddr iop_base,
+                           uchar tid_no,
+                           uchar sdtr_data
+)
+{
+    int                 sta = FALSE;
+
+    if (AscHostReqRiscHalt(iop_base)) {
+        sta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
+        AscStartChip(iop_base);
+        return (sta);
+    }
+    return (sta);
+}
+
+STATIC int
+AscSetChipSynRegAtID(
+                        PortAddr iop_base,
+                        uchar id,
+                        uchar sdtr_data
+)
+{
+    ASC_SCSI_BIT_ID_TYPE org_id;
+    int                 i;
+    int                 sta = TRUE;
+
+    AscSetBank(iop_base, 1);
+    org_id = AscReadChipDvcID(iop_base);
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        if (org_id == (0x01 << i))
+            break;
+    }
+    org_id = (ASC_SCSI_BIT_ID_TYPE) i;
+    AscWriteChipDvcID(iop_base, id);
+    if (AscReadChipDvcID(iop_base) == (0x01 << id)) {
+        AscSetBank(iop_base, 0);
+        AscSetChipSyn(iop_base, sdtr_data);
+        if (AscGetChipSyn(iop_base) != sdtr_data) {
+            sta = FALSE;
+        }
+    } else {
+        sta = FALSE;
+    }
+    AscSetBank(iop_base, 1);
+    AscWriteChipDvcID(iop_base, org_id);
+    AscSetBank(iop_base, 0);
+    return (sta);
+}
+
+STATIC ushort
+AscInitLram(
+               ASC_DVC_VAR *asc_dvc
+)
+{
+    uchar               i;
+    ushort              s_addr;
+    PortAddr            iop_base;
+    ushort              warn_code;
+
+    iop_base = asc_dvc->iop_base;
+    warn_code = 0;
+    AscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,
+               (ushort) (((int) (asc_dvc->max_total_qng + 2 + 1) * 64) >> 1)
+);
+    i = ASC_MIN_ACTIVE_QNO;
+    s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;
+    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_FWD),
+                     (uchar) (i + 1));
+    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_BWD),
+                     (uchar) (asc_dvc->max_total_qng));
+    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_QNO),
+                     (uchar) i);
+    i++;
+    s_addr += ASC_QBLK_SIZE;
+    for (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {
+        AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_FWD),
+                         (uchar) (i + 1));
+        AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_BWD),
+                         (uchar) (i - 1));
+        AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_QNO),
+                         (uchar) i);
+    }
+    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_FWD),
+                     (uchar) ASC_QLINK_END);
+    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_BWD),
+                     (uchar) (asc_dvc->max_total_qng - 1));
+    AscWriteLramByte(iop_base, (ushort) (s_addr + ASC_SCSIQ_B_QNO),
+                     (uchar) asc_dvc->max_total_qng);
+    i++;
+    s_addr += ASC_QBLK_SIZE;
+    for (; i <= (uchar) (asc_dvc->max_total_qng + 3);
+         i++, s_addr += ASC_QBLK_SIZE) {
+        AscWriteLramByte(iop_base,
+                         (ushort) (s_addr + (ushort) ASC_SCSIQ_B_FWD), i);
+        AscWriteLramByte(iop_base,
+                         (ushort) (s_addr + (ushort) ASC_SCSIQ_B_BWD), i);
+        AscWriteLramByte(iop_base,
+                         (ushort) (s_addr + (ushort) ASC_SCSIQ_B_QNO), i);
+    }
+    return (warn_code);
+}
+
+STATIC ushort
+AscInitQLinkVar(
+                   ASC_DVC_VAR *asc_dvc
+)
+{
+    PortAddr            iop_base;
+    int                 i;
+    ushort              lram_addr;
+
+    iop_base = asc_dvc->iop_base;
+    AscPutRiscVarFreeQHead(iop_base, 1);
+    AscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);
+    AscPutVarFreeQHead(iop_base, 1);
+    AscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);
+    AscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,
+                     (uchar) ((int) asc_dvc->max_total_qng + 1));
+    AscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,
+                     (uchar) ((int) asc_dvc->max_total_qng + 2));
+    AscWriteLramByte(iop_base, (ushort) ASCV_TOTAL_READY_Q_B,
+                     asc_dvc->max_total_qng);
+    AscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);
+    AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);
+    AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);
+    AscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);
+    AscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);
+    AscPutQDoneInProgress(iop_base, 0);
+    lram_addr = ASC_QADR_BEG;
+    for (i = 0; i < 32; i++, lram_addr += 2) {
+        AscWriteLramWord(iop_base, lram_addr, 0);
+    }
+    return (0);
+}
+
+STATIC int
+AscSetLibErrorCode(
+                      ASC_DVC_VAR *asc_dvc,
+                      ushort err_code
+)
+{
+    if (asc_dvc->err_code == 0) {
+        asc_dvc->err_code = err_code;
+        AscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
+                         err_code);
+    }
+    return (err_code);
+}
+
+
+STATIC uchar
+AscMsgOutSDTR(
+                 ASC_DVC_VAR *asc_dvc,
+                 uchar sdtr_period,
+                 uchar sdtr_offset
+)
+{
+    EXT_MSG             sdtr_buf;
+    uchar               sdtr_period_index;
+    PortAddr            iop_base;
+
+    iop_base = asc_dvc->iop_base;
+    sdtr_buf.msg_type = MS_EXTEND;
+    sdtr_buf.msg_len = MS_SDTR_LEN;
+    sdtr_buf.msg_req = MS_SDTR_CODE;
+    sdtr_buf.xfer_period = sdtr_period;
+    sdtr_offset &= ASC_SYN_MAX_OFFSET;
+    sdtr_buf.req_ack_offset = sdtr_offset;
+    if ((sdtr_period_index =
+         AscGetSynPeriodIndex(asc_dvc, sdtr_period)) <=
+        asc_dvc->max_sdtr_index) {
+        AscMemWordCopyPtrToLram(iop_base,
+                             ASCV_MSGOUT_BEG,
+                             (uchar *) &sdtr_buf,
+                             sizeof (EXT_MSG) >> 1);
+        return ((sdtr_period_index << 4) | sdtr_offset);
+    } else {
+
+        sdtr_buf.req_ack_offset = 0;
+        AscMemWordCopyPtrToLram(iop_base,
+                             ASCV_MSGOUT_BEG,
+                             (uchar *) &sdtr_buf,
+                             sizeof (EXT_MSG) >> 1);
+        return (0);
+    }
+}
+
+STATIC uchar
+AscCalSDTRData(
+                  ASC_DVC_VAR *asc_dvc,
+                  uchar sdtr_period,
+                  uchar syn_offset
+)
+{
+    uchar               byte;
+    uchar               sdtr_period_ix;
+
+    sdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);
+    if (
+           (sdtr_period_ix > asc_dvc->max_sdtr_index)
+) {
+        return (0xFF);
+    }
+    byte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);
+    return (byte);
+}
+
+STATIC void
+AscSetChipSDTR(
+                  PortAddr iop_base,
+                  uchar sdtr_data,
+                  uchar tid_no
+)
+{
+    AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);
+    AscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);
+    return;
+}
+
+STATIC uchar
+AscGetSynPeriodIndex(
+                        ASC_DVC_VAR *asc_dvc,
+                        uchar syn_time
+)
+{
+    uchar             *period_table;
+    int                 max_index;
+    int                 min_index;
+    int                 i;
+
+    period_table = asc_dvc->sdtr_period_tbl;
+    max_index = (int) asc_dvc->max_sdtr_index;
+    min_index = (int)asc_dvc->host_init_sdtr_index;
+    if ((syn_time <= period_table[max_index])) {
+        for (i = min_index; i < (max_index - 1); i++) {
+            if (syn_time <= period_table[i]) {
+                return ((uchar) i);
+            }
+        }
+        return ((uchar) max_index);
+    } else {
+        return ((uchar) (max_index + 1));
+    }
+}
+
+STATIC uchar
+AscAllocFreeQueue(
+                     PortAddr iop_base,
+                     uchar free_q_head
+)
+{
+    ushort              q_addr;
+    uchar               next_qp;
+    uchar               q_status;
+
+    q_addr = ASC_QNO_TO_QADDR(free_q_head);
+    q_status = (uchar) AscReadLramByte(iop_base,
+                                    (ushort) (q_addr + ASC_SCSIQ_B_STATUS));
+    next_qp = AscReadLramByte(iop_base,
+                              (ushort) (q_addr + ASC_SCSIQ_B_FWD));
+    if (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END)) {
+        return (next_qp);
+    }
+    return (ASC_QLINK_END);
+}
+
+STATIC uchar
+AscAllocMultipleFreeQueue(
+                             PortAddr iop_base,
+                             uchar free_q_head,
+                             uchar n_free_q
+)
+{
+    uchar               i;
+
+    for (i = 0; i < n_free_q; i++) {
+        if ((free_q_head = AscAllocFreeQueue(iop_base, free_q_head))
+            == ASC_QLINK_END) {
+            return (ASC_QLINK_END);
+        }
+    }
+    return (free_q_head);
+}
+
+STATIC int
+AscHostReqRiscHalt(
+                      PortAddr iop_base
+)
+{
+    int                 count = 0;
+    int                 sta = 0;
+    uchar               saved_stop_code;
+
+    if (AscIsChipHalted(iop_base))
+        return (1);
+    saved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);
+    AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
+                     ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP
+);
+    do {
+        if (AscIsChipHalted(iop_base)) {
+            sta = 1;
+            break;
+        }
+        DvcSleepMilliSecond(100);
+    } while (count++ < 20);
+    AscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);
+    return (sta);
+}
+
+STATIC int
+AscStopQueueExe(
+                   PortAddr iop_base
+)
+{
+    int                 count = 0;
+
+    if (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {
+        AscWriteLramByte(iop_base, ASCV_STOP_CODE_B,
+                         ASC_STOP_REQ_RISC_STOP);
+        do {
+            if (
+                   AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &
+                   ASC_STOP_ACK_RISC_STOP) {
+                return (1);
+            }
+            DvcSleepMilliSecond(100);
+        } while (count++ < 20);
+    }
+    return (0);
+}
+
+STATIC void
+DvcDelayMicroSecond(ADV_DVC_VAR *asc_dvc, ushort micro_sec)
+{
+    udelay(micro_sec);
+}
+
+STATIC void
+DvcDelayNanoSecond(ASC_DVC_VAR *asc_dvc, ASC_DCNT nano_sec)
+{
+    udelay((nano_sec + 999)/1000);
+}
+
+#ifdef CONFIG_ISA
+STATIC ASC_DCNT __init
+AscGetEisaProductID(
+                       PortAddr iop_base)
+{
+    PortAddr            eisa_iop;
+    ushort              product_id_high, product_id_low;
+    ASC_DCNT            product_id;
+
+    eisa_iop = ASC_GET_EISA_SLOT(iop_base) | ASC_EISA_PID_IOP_MASK;
+    product_id_low = inpw(eisa_iop);
+    product_id_high = inpw(eisa_iop + 2);
+    product_id = ((ASC_DCNT) product_id_high << 16) |
+        (ASC_DCNT) product_id_low;
+    return (product_id);
+}
+
+STATIC PortAddr __init
+AscSearchIOPortAddrEISA(
+                           PortAddr iop_base)
+{
+    ASC_DCNT            eisa_product_id;
+
+    if (iop_base == 0) {
+        iop_base = ASC_EISA_MIN_IOP_ADDR;
+    } else {
+        if (iop_base == ASC_EISA_MAX_IOP_ADDR)
+            return (0);
+        if ((iop_base & 0x0050) == 0x0050) {
+            iop_base += ASC_EISA_BIG_IOP_GAP;
+        } else {
+            iop_base += ASC_EISA_SMALL_IOP_GAP;
+        }
+    }
+    while (iop_base <= ASC_EISA_MAX_IOP_ADDR) {
+        eisa_product_id = AscGetEisaProductID(iop_base);
+        if ((eisa_product_id == ASC_EISA_ID_740) ||
+            (eisa_product_id == ASC_EISA_ID_750)) {
+            if (AscFindSignature(iop_base)) {
+                inpw(iop_base + 4);
+                return (iop_base);
+            }
+        }
+        if (iop_base == ASC_EISA_MAX_IOP_ADDR)
+            return (0);
+        if ((iop_base & 0x0050) == 0x0050) {
+            iop_base += ASC_EISA_BIG_IOP_GAP;
+        } else {
+            iop_base += ASC_EISA_SMALL_IOP_GAP;
+        }
+    }
+    return (0);
+}
+#endif /* CONFIG_ISA */
+
+STATIC int
+AscStartChip(
+                PortAddr iop_base
+)
+{
+    AscSetChipControl(iop_base, 0);
+    if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
+        return (0);
+    }
+    return (1);
+}
+
+STATIC int
+AscStopChip(
+               PortAddr iop_base
+)
+{
+    uchar               cc_val;
+
+    cc_val = AscGetChipControl(iop_base) & (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));
+    AscSetChipControl(iop_base, (uchar) (cc_val | CC_HALT));
+    AscSetChipIH(iop_base, INS_HALT);
+    AscSetChipIH(iop_base, INS_RFLAG_WTM);
+    if ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {
+        return (0);
+    }
+    return (1);
+}
+
+STATIC int
+AscIsChipHalted(
+                   PortAddr iop_base
+)
+{
+    if ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {
+        if ((AscGetChipControl(iop_base) & CC_HALT) != 0) {
+            return (1);
+        }
+    }
+    return (0);
+}
+
+STATIC void
+AscSetChipIH(
+                PortAddr iop_base,
+                ushort ins_code
+)
+{
+    AscSetBank(iop_base, 1);
+    AscWriteChipIH(iop_base, ins_code);
+    AscSetBank(iop_base, 0);
+    return;
+}
+
+STATIC void
+AscAckInterrupt(
+                   PortAddr iop_base
+)
+{
+    uchar               host_flag;
+    uchar               risc_flag;
+    ushort              loop;
+
+    loop = 0;
+    do {
+        risc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);
+        if (loop++ > 0x7FFF) {
+            break;
+        }
+    } while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);
+    host_flag = AscReadLramByte(iop_base, ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);
+    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,
+                     (uchar) (host_flag | ASC_HOST_FLAG_ACK_INT));
+    AscSetChipStatus(iop_base, CIW_INT_ACK);
+    loop = 0;
+    while (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {
+        AscSetChipStatus(iop_base, CIW_INT_ACK);
+        if (loop++ > 3) {
+            break;
+        }
+    }
+    AscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);
+    return;
+}
+
+STATIC void
+AscDisableInterrupt(
+                       PortAddr iop_base
+)
+{
+    ushort              cfg;
+
+    cfg = AscGetChipCfgLsw(iop_base);
+    AscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));
+    return;
+}
+
+STATIC void
+AscEnableInterrupt(
+                      PortAddr iop_base
+)
+{
+    ushort              cfg;
+
+    cfg = AscGetChipCfgLsw(iop_base);
+    AscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);
+    return;
+}
+
+
+
+STATIC void
+AscSetBank(
+              PortAddr iop_base,
+              uchar bank
+)
+{
+    uchar               val;
+
+    val = AscGetChipControl(iop_base) &
+      (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET | CC_CHIP_RESET));
+    if (bank == 1) {
+        val |= CC_BANK_ONE;
+    } else if (bank == 2) {
+        val |= CC_DIAG | CC_BANK_ONE;
+    } else {
+        val &= ~CC_BANK_ONE;
+    }
+    AscSetChipControl(iop_base, val);
+    return;
+}
+
+STATIC int
+AscResetChipAndScsiBus(
+                          ASC_DVC_VAR *asc_dvc
+)
+{
+    PortAddr    iop_base;
+    int         i = 10;
+
+    iop_base = asc_dvc->iop_base;
+    while ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE) && (i-- > 0))
+    {
+          DvcSleepMilliSecond(100);
+    }
+    AscStopChip(iop_base);
+    AscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);
+    DvcDelayNanoSecond(asc_dvc, 60000);
+    AscSetChipIH(iop_base, INS_RFLAG_WTM);
+    AscSetChipIH(iop_base, INS_HALT);
+    AscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);
+    AscSetChipControl(iop_base, CC_HALT);
+    DvcSleepMilliSecond(200);
+    AscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);
+    AscSetChipStatus(iop_base, 0);
+    return (AscIsChipHalted(iop_base));
+}
+
+STATIC ASC_DCNT __init
+AscGetMaxDmaCount(
+                     ushort bus_type)
+{
+    if (bus_type & ASC_IS_ISA)
+        return (ASC_MAX_ISA_DMA_COUNT);
+    else if (bus_type & (ASC_IS_EISA | ASC_IS_VL))
+        return (ASC_MAX_VL_DMA_COUNT);
+    return (ASC_MAX_PCI_DMA_COUNT);
+}
+
+#ifdef CONFIG_ISA
+STATIC ushort __init
+AscGetIsaDmaChannel(
+                       PortAddr iop_base)
+{
+    ushort              channel;
+
+    channel = AscGetChipCfgLsw(iop_base) & 0x0003;
+    if (channel == 0x03)
+        return (0);
+    else if (channel == 0x00)
+        return (7);
+    return (channel + 4);
+}
+
+STATIC ushort __init
+AscSetIsaDmaChannel(
+                       PortAddr iop_base,
+                       ushort dma_channel)
+{
+    ushort              cfg_lsw;
+    uchar               value;
+
+    if ((dma_channel >= 5) && (dma_channel <= 7)) {
+        if (dma_channel == 7)
+            value = 0x00;
+        else
+            value = dma_channel - 4;
+        cfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;
+        cfg_lsw |= value;
+        AscSetChipCfgLsw(iop_base, cfg_lsw);
+        return (AscGetIsaDmaChannel(iop_base));
+    }
+    return (0);
+}
+
+STATIC uchar __init
+AscSetIsaDmaSpeed(
+                     PortAddr iop_base,
+                     uchar speed_value)
+{
+    speed_value &= 0x07;
+    AscSetBank(iop_base, 1);
+    AscWriteChipDmaSpeed(iop_base, speed_value);
+    AscSetBank(iop_base, 0);
+    return (AscGetIsaDmaSpeed(iop_base));
+}
+
+STATIC uchar __init
+AscGetIsaDmaSpeed(
+                     PortAddr iop_base
+)
+{
+    uchar               speed_value;
+
+    AscSetBank(iop_base, 1);
+    speed_value = AscReadChipDmaSpeed(iop_base);
+    speed_value &= 0x07;
+    AscSetBank(iop_base, 0);
+    return (speed_value);
+}
+#endif /* CONFIG_ISA */
+
+STATIC ushort __init
+AscReadPCIConfigWord(
+    ASC_DVC_VAR *asc_dvc,
+    ushort pci_config_offset)
+{
+    uchar       lsb, msb;
+
+    lsb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset);
+    msb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset + 1);
+    return ((ushort) ((msb << 8) | lsb));
+}
+
+STATIC ushort __init
+AscInitGetConfig(
+        ASC_DVC_VAR *asc_dvc
+)
+{
+    ushort              warn_code;
+    PortAddr            iop_base;
+    ushort              PCIDeviceID;
+    ushort              PCIVendorID;
+    uchar               PCIRevisionID;
+    uchar               prevCmdRegBits;
+
+    warn_code = 0;
+    iop_base = asc_dvc->iop_base;
+    asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;
+    if (asc_dvc->err_code != 0) {
+        return (UW_ERR);
+    }
+    if (asc_dvc->bus_type == ASC_IS_PCI) {
+        PCIVendorID = AscReadPCIConfigWord(asc_dvc,
+                                    AscPCIConfigVendorIDRegister);
+
+        PCIDeviceID = AscReadPCIConfigWord(asc_dvc,
+                                    AscPCIConfigDeviceIDRegister);
+
+        PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
+                                    AscPCIConfigRevisionIDRegister);
+
+        if (PCIVendorID != ASC_PCI_VENDORID) {
+            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+        }
+        prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
+                                    AscPCIConfigCommandRegister);
+
+        if ((prevCmdRegBits & AscPCICmdRegBits_IOMemBusMaster) !=
+            AscPCICmdRegBits_IOMemBusMaster) {
+            DvcWritePCIConfigByte(asc_dvc,
+                            AscPCIConfigCommandRegister,
+                            (prevCmdRegBits |
+                             AscPCICmdRegBits_IOMemBusMaster));
+
+            if ((DvcReadPCIConfigByte(asc_dvc,
+                                AscPCIConfigCommandRegister)
+                 & AscPCICmdRegBits_IOMemBusMaster)
+                != AscPCICmdRegBits_IOMemBusMaster) {
+                warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+            }
+        }
+        if ((PCIDeviceID == ASC_PCI_DEVICEID_1200A) ||
+            (PCIDeviceID == ASC_PCI_DEVICEID_1200B)) {
+            DvcWritePCIConfigByte(asc_dvc,
+                            AscPCIConfigLatencyTimer, 0x00);
+            if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
+                != 0x00) {
+                warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+            }
+        } else if (PCIDeviceID == ASC_PCI_DEVICEID_ULTRA) {
+            if (DvcReadPCIConfigByte(asc_dvc,
+                                AscPCIConfigLatencyTimer) < 0x20) {
+                DvcWritePCIConfigByte(asc_dvc,
+                                    AscPCIConfigLatencyTimer, 0x20);
+
+                if (DvcReadPCIConfigByte(asc_dvc,
+                                    AscPCIConfigLatencyTimer) < 0x20) {
+                    warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+                }
+            }
+        }
+    }
+
+    if (AscFindSignature(iop_base)) {
+        warn_code |= AscInitAscDvcVar(asc_dvc);
+        warn_code |= AscInitFromEEP(asc_dvc);
+        asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;
+        if (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT) {
+            asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;
+        }
+    } else {
+        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+    }
+    return(warn_code);
+}
+
+STATIC ushort __init
+AscInitSetConfig(
+                    ASC_DVC_VAR *asc_dvc
+)
+{
+    ushort              warn_code = 0;
+
+    asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;
+    if (asc_dvc->err_code != 0)
+        return (UW_ERR);
+    if (AscFindSignature(asc_dvc->iop_base)) {
+        warn_code |= AscInitFromAscDvcVar(asc_dvc);
+        asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;
+    } else {
+        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+    }
+    return (warn_code);
+}
+
+STATIC ushort __init
+AscInitFromAscDvcVar(
+                        ASC_DVC_VAR *asc_dvc
+)
+{
+    PortAddr            iop_base;
+    ushort              cfg_msw;
+    ushort              warn_code;
+    ushort              pci_device_id = 0;
+
+    iop_base = asc_dvc->iop_base;
+#ifdef CONFIG_PCI
+    if (asc_dvc->cfg->dev)
+        pci_device_id = to_pci_dev(asc_dvc->cfg->dev)->device;
+#endif
+    warn_code = 0;
+    cfg_msw = AscGetChipCfgMsw(iop_base);
+    if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
+        cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
+        warn_code |= ASC_WARN_CFG_MSW_RECOVER;
+        AscSetChipCfgMsw(iop_base, cfg_msw);
+    }
+    if ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=
+        asc_dvc->cfg->cmd_qng_enabled) {
+        asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;
+        warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
+    }
+    if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
+        warn_code |= ASC_WARN_AUTO_CONFIG;
+    }
+    if ((asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL)) != 0) {
+        if (AscSetChipIRQ(iop_base, asc_dvc->irq_no, asc_dvc->bus_type)
+            != asc_dvc->irq_no) {
+            asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO;
+        }
+    }
+    if (asc_dvc->bus_type & ASC_IS_PCI) {
+        cfg_msw &= 0xFFC0;
+        AscSetChipCfgMsw(iop_base, cfg_msw);
+        if ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {
+        } else {
+            if ((pci_device_id == ASC_PCI_DEVICE_ID_REV_A) ||
+                (pci_device_id == ASC_PCI_DEVICE_ID_REV_B)) {
+                asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;
+                asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
+            }
+        }
+    } else if (asc_dvc->bus_type == ASC_IS_ISAPNP) {
+        if (AscGetChipVersion(iop_base, asc_dvc->bus_type)
+            == ASC_CHIP_VER_ASYN_BUG) {
+            asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;
+        }
+    }
+    if (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=
+        asc_dvc->cfg->chip_scsi_id) {
+        asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;
+    }
+#ifdef CONFIG_ISA
+    if (asc_dvc->bus_type & ASC_IS_ISA) {
+        AscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);
+        AscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);
+    }
+#endif /* CONFIG_ISA */
+    return (warn_code);
+}
+
+STATIC ushort
+AscInitAsc1000Driver(
+                        ASC_DVC_VAR *asc_dvc
+)
+{
+    ushort              warn_code;
+    PortAddr            iop_base;
+
+    iop_base = asc_dvc->iop_base;
+    warn_code = 0;
+    if ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&
+        !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {
+        AscResetChipAndScsiBus(asc_dvc);
+        DvcSleepMilliSecond((ASC_DCNT)
+            ((ushort) asc_dvc->scsi_reset_wait * 1000));
+    }
+    asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;
+    if (asc_dvc->err_code != 0)
+        return (UW_ERR);
+    if (!AscFindSignature(asc_dvc->iop_base)) {
+        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+        return (warn_code);
+    }
+    AscDisableInterrupt(iop_base);
+    warn_code |= AscInitLram(asc_dvc);
+    if (asc_dvc->err_code != 0)
+        return (UW_ERR);
+    ASC_DBG1(1, "AscInitAsc1000Driver: _asc_mcode_chksum 0x%lx\n",
+        (ulong) _asc_mcode_chksum);
+    if (AscLoadMicroCode(iop_base, 0, _asc_mcode_buf,
+                         _asc_mcode_size) != _asc_mcode_chksum) {
+        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+        return (warn_code);
+    }
+    warn_code |= AscInitMicroCodeVar(asc_dvc);
+    asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;
+    AscEnableInterrupt(iop_base);
+    return (warn_code);
+}
+
+STATIC ushort __init
+AscInitAscDvcVar(
+                    ASC_DVC_VAR *asc_dvc)
+{
+    int                 i;
+    PortAddr            iop_base;
+    ushort              warn_code;
+    uchar               chip_version;
+
+    iop_base = asc_dvc->iop_base;
+    warn_code = 0;
+    asc_dvc->err_code = 0;
+    if ((asc_dvc->bus_type &
+         (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {
+        asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;
+    }
+    AscSetChipControl(iop_base, CC_HALT);
+    AscSetChipStatus(iop_base, 0);
+    asc_dvc->bug_fix_cntl = 0;
+    asc_dvc->pci_fix_asyn_xfer = 0;
+    asc_dvc->pci_fix_asyn_xfer_always = 0;
+    /* asc_dvc->init_state initalized in AscInitGetConfig(). */
+    asc_dvc->sdtr_done = 0;
+    asc_dvc->cur_total_qng = 0;
+    asc_dvc->is_in_int = 0;
+    asc_dvc->in_critical_cnt = 0;
+    asc_dvc->last_q_shortage = 0;
+    asc_dvc->use_tagged_qng = 0;
+    asc_dvc->no_scam = 0;
+    asc_dvc->unit_not_ready = 0;
+    asc_dvc->queue_full_or_busy = 0;
+    asc_dvc->redo_scam = 0;
+    asc_dvc->res2 = 0;
+    asc_dvc->host_init_sdtr_index = 0;
+    asc_dvc->cfg->can_tagged_qng = 0;
+    asc_dvc->cfg->cmd_qng_enabled = 0;
+    asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;
+    asc_dvc->init_sdtr = 0;
+    asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;
+    asc_dvc->scsi_reset_wait = 3;
+    asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;
+    asc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);
+    asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;
+    asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;
+    asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;
+    asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER;
+    asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
+      ASC_LIB_VERSION_MINOR;
+    chip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);
+    asc_dvc->cfg->chip_version = chip_version;
+    asc_dvc->sdtr_period_tbl[0] = SYN_XFER_NS_0;
+    asc_dvc->sdtr_period_tbl[1] = SYN_XFER_NS_1;
+    asc_dvc->sdtr_period_tbl[2] = SYN_XFER_NS_2;
+    asc_dvc->sdtr_period_tbl[3] = SYN_XFER_NS_3;
+    asc_dvc->sdtr_period_tbl[4] = SYN_XFER_NS_4;
+    asc_dvc->sdtr_period_tbl[5] = SYN_XFER_NS_5;
+    asc_dvc->sdtr_period_tbl[6] = SYN_XFER_NS_6;
+    asc_dvc->sdtr_period_tbl[7] = SYN_XFER_NS_7;
+    asc_dvc->max_sdtr_index = 7;
+    if ((asc_dvc->bus_type & ASC_IS_PCI) &&
+        (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {
+        asc_dvc->bus_type = ASC_IS_PCI_ULTRA;
+        asc_dvc->sdtr_period_tbl[0] = SYN_ULTRA_XFER_NS_0;
+        asc_dvc->sdtr_period_tbl[1] = SYN_ULTRA_XFER_NS_1;
+        asc_dvc->sdtr_period_tbl[2] = SYN_ULTRA_XFER_NS_2;
+        asc_dvc->sdtr_period_tbl[3] = SYN_ULTRA_XFER_NS_3;
+        asc_dvc->sdtr_period_tbl[4] = SYN_ULTRA_XFER_NS_4;
+        asc_dvc->sdtr_period_tbl[5] = SYN_ULTRA_XFER_NS_5;
+        asc_dvc->sdtr_period_tbl[6] = SYN_ULTRA_XFER_NS_6;
+        asc_dvc->sdtr_period_tbl[7] = SYN_ULTRA_XFER_NS_7;
+        asc_dvc->sdtr_period_tbl[8] = SYN_ULTRA_XFER_NS_8;
+        asc_dvc->sdtr_period_tbl[9] = SYN_ULTRA_XFER_NS_9;
+        asc_dvc->sdtr_period_tbl[10] = SYN_ULTRA_XFER_NS_10;
+        asc_dvc->sdtr_period_tbl[11] = SYN_ULTRA_XFER_NS_11;
+        asc_dvc->sdtr_period_tbl[12] = SYN_ULTRA_XFER_NS_12;
+        asc_dvc->sdtr_period_tbl[13] = SYN_ULTRA_XFER_NS_13;
+        asc_dvc->sdtr_period_tbl[14] = SYN_ULTRA_XFER_NS_14;
+        asc_dvc->sdtr_period_tbl[15] = SYN_ULTRA_XFER_NS_15;
+        asc_dvc->max_sdtr_index = 15;
+        if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150)
+        {
+            AscSetExtraControl(iop_base,
+                (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
+        } else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {
+            AscSetExtraControl(iop_base,
+                (SEC_ACTIVE_NEGATE | SEC_ENABLE_FILTER));
+        }
+    }
+    if (asc_dvc->bus_type == ASC_IS_PCI) {
+           AscSetExtraControl(iop_base, (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
+    }
+
+    asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;
+    if (AscGetChipBusType(iop_base) == ASC_IS_ISAPNP) {
+        AscSetChipIFC(iop_base, IFC_INIT_DEFAULT);
+        asc_dvc->bus_type = ASC_IS_ISAPNP;
+    }
+#ifdef CONFIG_ISA
+    if ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {
+        asc_dvc->cfg->isa_dma_channel = (uchar) AscGetIsaDmaChannel(iop_base);
+    }
+#endif /* CONFIG_ISA */
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        asc_dvc->cur_dvc_qng[i] = 0;
+        asc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;
+        asc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *) 0L;
+        asc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *) 0L;
+        asc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;
+    }
+    return (warn_code);
+}
+
+STATIC ushort __init
+AscInitFromEEP(ASC_DVC_VAR *asc_dvc)
+{
+    ASCEEP_CONFIG       eep_config_buf;
+    ASCEEP_CONFIG       *eep_config;
+    PortAddr            iop_base;
+    ushort              chksum;
+    ushort              warn_code;
+    ushort              cfg_msw, cfg_lsw;
+    int                 i;
+    int                 write_eep = 0;
+
+    iop_base = asc_dvc->iop_base;
+    warn_code = 0;
+    AscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);
+    AscStopQueueExe(iop_base);
+    if ((AscStopChip(iop_base) == FALSE) ||
+        (AscGetChipScsiCtrl(iop_base) != 0)) {
+        asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;
+        AscResetChipAndScsiBus(asc_dvc);
+        DvcSleepMilliSecond((ASC_DCNT)
+            ((ushort) asc_dvc->scsi_reset_wait * 1000));
+    }
+    if (AscIsChipHalted(iop_base) == FALSE) {
+        asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
+        return (warn_code);
+    }
+    AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
+    if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
+        asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
+        return (warn_code);
+    }
+    eep_config = (ASCEEP_CONFIG *) &eep_config_buf;
+    cfg_msw = AscGetChipCfgMsw(iop_base);
+    cfg_lsw = AscGetChipCfgLsw(iop_base);
+    if ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {
+        cfg_msw &= (~(ASC_CFG_MSW_CLR_MASK));
+        warn_code |= ASC_WARN_CFG_MSW_RECOVER;
+        AscSetChipCfgMsw(iop_base, cfg_msw);
+    }
+    chksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);
+    ASC_DBG1(1, "AscInitFromEEP: chksum 0x%x\n", chksum);
+    if (chksum == 0) {
+        chksum = 0xaa55;
+    }
+    if (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {
+        warn_code |= ASC_WARN_AUTO_CONFIG;
+        if (asc_dvc->cfg->chip_version == 3) {
+            if (eep_config->cfg_lsw != cfg_lsw) {
+                warn_code |= ASC_WARN_EEPROM_RECOVER;
+                eep_config->cfg_lsw = AscGetChipCfgLsw(iop_base);
+            }
+            if (eep_config->cfg_msw != cfg_msw) {
+                warn_code |= ASC_WARN_EEPROM_RECOVER;
+                eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
+            }
+        }
+    }
+    eep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;
+    eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;
+    ASC_DBG1(1, "AscInitFromEEP: eep_config->chksum 0x%x\n",
+        eep_config->chksum);
+    if (chksum != eep_config->chksum) {
+            if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
+                    ASC_CHIP_VER_PCI_ULTRA_3050 )
+            {
+                ASC_DBG(1,
+"AscInitFromEEP: chksum error ignored; EEPROM-less board\n");
+                eep_config->init_sdtr = 0xFF;
+                eep_config->disc_enable = 0xFF;
+                eep_config->start_motor = 0xFF;
+                eep_config->use_cmd_qng = 0;
+                eep_config->max_total_qng = 0xF0;
+                eep_config->max_tag_qng = 0x20;
+                eep_config->cntl = 0xBFFF;
+                ASC_EEP_SET_CHIP_ID(eep_config, 7);
+                eep_config->no_scam = 0;
+                eep_config->adapter_info[0] = 0;
+                eep_config->adapter_info[1] = 0;
+                eep_config->adapter_info[2] = 0;
+                eep_config->adapter_info[3] = 0;
+                eep_config->adapter_info[4] = 0;
+                /* Indicate EEPROM-less board. */
+                eep_config->adapter_info[5] = 0xBB;
+            } else {
+                ASC_PRINT(
+"AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\n");
+                write_eep = 1;
+                warn_code |= ASC_WARN_EEPROM_CHKSUM;
+            }
+    }
+    asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;
+    asc_dvc->cfg->disc_enable = eep_config->disc_enable;
+    asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;
+    asc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);
+    asc_dvc->start_motor = eep_config->start_motor;
+    asc_dvc->dvc_cntl = eep_config->cntl;
+    asc_dvc->no_scam = eep_config->no_scam;
+    asc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];
+    asc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];
+    asc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];
+    asc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];
+    asc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];
+    asc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];
+    if (!AscTestExternalLram(asc_dvc)) {
+        if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA)) {
+            eep_config->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;
+            eep_config->max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;
+        } else {
+            eep_config->cfg_msw |= 0x0800;
+            cfg_msw |= 0x0800;
+            AscSetChipCfgMsw(iop_base, cfg_msw);
+            eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;
+            eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;
+        }
+    } else {
+    }
+    if (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {
+        eep_config->max_total_qng = ASC_MIN_TOTAL_QNG;
+    }
+    if (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {
+        eep_config->max_total_qng = ASC_MAX_TOTAL_QNG;
+    }
+    if (eep_config->max_tag_qng > eep_config->max_total_qng) {
+        eep_config->max_tag_qng = eep_config->max_total_qng;
+    }
+    if (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {
+        eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;
+    }
+    asc_dvc->max_total_qng = eep_config->max_total_qng;
+    if ((eep_config->use_cmd_qng & eep_config->disc_enable) !=
+        eep_config->use_cmd_qng) {
+        eep_config->disc_enable = eep_config->use_cmd_qng;
+        warn_code |= ASC_WARN_CMD_QNG_CONFLICT;
+    }
+    if (asc_dvc->bus_type & (ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA)) {
+        asc_dvc->irq_no = AscGetChipIRQ(iop_base, asc_dvc->bus_type);
+    }
+    ASC_EEP_SET_CHIP_ID(eep_config, ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);
+    asc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);
+    if (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&
+        !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {
+        asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;
+    }
+
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        asc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];
+        asc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;
+        asc_dvc->cfg->sdtr_period_offset[i] =
+            (uchar) (ASC_DEF_SDTR_OFFSET |
+                     (asc_dvc->host_init_sdtr_index << 4));
+    }
+    eep_config->cfg_msw = AscGetChipCfgMsw(iop_base);
+    if (write_eep) {
+        if ((i = AscSetEEPConfig(iop_base, eep_config, asc_dvc->bus_type)) !=
+             0) {
+                ASC_PRINT1(
+"AscInitFromEEP: Failed to re-write EEPROM with %d errors.\n", i);
+        } else {
+                ASC_PRINT("AscInitFromEEP: Succesfully re-wrote EEPROM.");
+        }
+    }
+    return (warn_code);
+}
+
+STATIC ushort
+AscInitMicroCodeVar(
+                       ASC_DVC_VAR *asc_dvc
+)
+{
+    int                 i;
+    ushort              warn_code;
+    PortAddr            iop_base;
+    ASC_PADDR           phy_addr;
+    ASC_DCNT            phy_size;
+
+    iop_base = asc_dvc->iop_base;
+    warn_code = 0;
+    for (i = 0; i <= ASC_MAX_TID; i++) {
+        AscPutMCodeInitSDTRAtID(iop_base, i,
+                                asc_dvc->cfg->sdtr_period_offset[i]
+);
+    }
+
+    AscInitQLinkVar(asc_dvc);
+    AscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,
+                     asc_dvc->cfg->disc_enable);
+    AscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,
+                     ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));
+
+    /* Align overrun buffer on an 8 byte boundary. */
+    phy_addr = virt_to_bus(asc_dvc->cfg->overrun_buf);
+    phy_addr = cpu_to_le32((phy_addr + 7) & ~0x7);
+    AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,
+        (uchar *) &phy_addr, 1);
+    phy_size = cpu_to_le32(ASC_OVERRUN_BSIZE - 8);
+    AscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,
+        (uchar *) &phy_size, 1);
+
+    asc_dvc->cfg->mcode_date =
+        AscReadLramWord(iop_base, (ushort) ASCV_MC_DATE_W);
+    asc_dvc->cfg->mcode_version =
+        AscReadLramWord(iop_base, (ushort) ASCV_MC_VER_W);
+
+    AscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);
+    if (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {
+        asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;
+        return (warn_code);
+    }
+    if (AscStartChip(iop_base) != 1) {
+        asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;
+        return (warn_code);
+    }
+
+    return (warn_code);
+}
+
+STATIC int __init
+AscTestExternalLram(
+                       ASC_DVC_VAR *asc_dvc)
+{
+    PortAddr            iop_base;
+    ushort              q_addr;
+    ushort              saved_word;
+    int                 sta;
+
+    iop_base = asc_dvc->iop_base;
+    sta = 0;
+    q_addr = ASC_QNO_TO_QADDR(241);
+    saved_word = AscReadLramWord(iop_base, q_addr);
+    AscSetChipLramAddr(iop_base, q_addr);
+    AscSetChipLramData(iop_base, 0x55AA);
+    DvcSleepMilliSecond(10);
+    AscSetChipLramAddr(iop_base, q_addr);
+    if (AscGetChipLramData(iop_base) == 0x55AA) {
+        sta = 1;
+        AscWriteLramWord(iop_base, q_addr, saved_word);
+    }
+    return (sta);
+}
+
+STATIC int __init
+AscWriteEEPCmdReg(
+                     PortAddr iop_base,
+                     uchar cmd_reg
+)
+{
+    uchar               read_back;
+    int                 retry;
+
+    retry = 0;
+    while (TRUE) {
+        AscSetChipEEPCmd(iop_base, cmd_reg);
+        DvcSleepMilliSecond(1);
+        read_back = AscGetChipEEPCmd(iop_base);
+        if (read_back == cmd_reg) {
+            return (1);
+        }
+        if (retry++ > ASC_EEP_MAX_RETRY) {
+            return (0);
+        }
+    }
+}
+
+STATIC int __init
+AscWriteEEPDataReg(
+                      PortAddr iop_base,
+                      ushort data_reg
+)
+{
+    ushort              read_back;
+    int                 retry;
+
+    retry = 0;
+    while (TRUE) {
+        AscSetChipEEPData(iop_base, data_reg);
+        DvcSleepMilliSecond(1);
+        read_back = AscGetChipEEPData(iop_base);
+        if (read_back == data_reg) {
+            return (1);
+        }
+        if (retry++ > ASC_EEP_MAX_RETRY) {
+            return (0);
+        }
+    }
+}
+
+STATIC void __init
+AscWaitEEPRead(void)
+{
+    DvcSleepMilliSecond(1);
+    return;
+}
+
+STATIC void __init
+AscWaitEEPWrite(void)
+{
+    DvcSleepMilliSecond(20);
+    return;
+}
+
+STATIC ushort __init
+AscReadEEPWord(
+                  PortAddr iop_base,
+                  uchar addr)
+{
+    ushort              read_wval;
+    uchar               cmd_reg;
+
+    AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
+    AscWaitEEPRead();
+    cmd_reg = addr | ASC_EEP_CMD_READ;
+    AscWriteEEPCmdReg(iop_base, cmd_reg);
+    AscWaitEEPRead();
+    read_wval = AscGetChipEEPData(iop_base);
+    AscWaitEEPRead();
+    return (read_wval);
+}
+
+STATIC ushort __init
+AscWriteEEPWord(
+                   PortAddr iop_base,
+                   uchar addr,
+                   ushort word_val)
+{
+    ushort              read_wval;
+
+    read_wval = AscReadEEPWord(iop_base, addr);
+    if (read_wval != word_val) {
+        AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);
+        AscWaitEEPRead();
+        AscWriteEEPDataReg(iop_base, word_val);
+        AscWaitEEPRead();
+        AscWriteEEPCmdReg(iop_base,
+                          (uchar) ((uchar) ASC_EEP_CMD_WRITE | addr));
+        AscWaitEEPWrite();
+        AscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);
+        AscWaitEEPRead();
+        return (AscReadEEPWord(iop_base, addr));
+    }
+    return (read_wval);
+}
+
+STATIC ushort __init
+AscGetEEPConfig(
+                   PortAddr iop_base,
+                   ASCEEP_CONFIG * cfg_buf, ushort bus_type)
+{
+    ushort              wval;
+    ushort              sum;
+    ushort              *wbuf;
+    int                 cfg_beg;
+    int                 cfg_end;
+    int                 uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
+    int                 s_addr;
+
+    wbuf = (ushort *) cfg_buf;
+    sum = 0;
+    /* Read two config words; Byte-swapping done by AscReadEEPWord(). */
+    for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+        *wbuf = AscReadEEPWord(iop_base, (uchar) s_addr);
+        sum += *wbuf;
+    }
+    if (bus_type & ASC_IS_VL) {
+        cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+        cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+    } else {
+        cfg_beg = ASC_EEP_DVC_CFG_BEG;
+        cfg_end = ASC_EEP_MAX_DVC_ADDR;
+    }
+    for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+        wval = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
+        if (s_addr <= uchar_end_in_config) {
+            /*
+             * Swap all char fields - must unswap bytes already swapped
+             * by AscReadEEPWord().
+             */
+            *wbuf = le16_to_cpu(wval);
+        } else {
+            /* Don't swap word field at the end - cntl field. */
+            *wbuf = wval;
+        }
+        sum += wval; /* Checksum treats all EEPROM data as words. */
+    }
+    /*
+     * Read the checksum word which will be compared against 'sum'
+     * by the caller. Word field already swapped.
+     */
+    *wbuf = AscReadEEPWord(iop_base, (uchar) s_addr);
+    return (sum);
+}
+
+STATIC int __init
+AscSetEEPConfigOnce(
+                       PortAddr iop_base,
+                       ASCEEP_CONFIG * cfg_buf, ushort bus_type)
+{
+    int                 n_error;
+    ushort              *wbuf;
+    ushort              word;
+    ushort              sum;
+    int                 s_addr;
+    int                 cfg_beg;
+    int                 cfg_end;
+    int                 uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;
+
+
+    wbuf = (ushort *) cfg_buf;
+    n_error = 0;
+    sum = 0;
+    /* Write two config words; AscWriteEEPWord() will swap bytes. */
+    for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+        sum += *wbuf;
+        if (*wbuf != AscWriteEEPWord(iop_base, (uchar) s_addr, *wbuf)) {
+            n_error++;
+        }
+    }
+    if (bus_type & ASC_IS_VL) {
+        cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+        cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+    } else {
+        cfg_beg = ASC_EEP_DVC_CFG_BEG;
+        cfg_end = ASC_EEP_MAX_DVC_ADDR;
+    }
+    for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+        if (s_addr <= uchar_end_in_config) {
+            /*
+             * This is a char field. Swap char fields before they are
+             * swapped again by AscWriteEEPWord().
+             */
+            word = cpu_to_le16(*wbuf);
+            if (word != AscWriteEEPWord( iop_base, (uchar) s_addr, word)) {
+                n_error++;
+            }
+        } else {
+            /* Don't swap word field at the end - cntl field. */
+            if (*wbuf != AscWriteEEPWord(iop_base, (uchar) s_addr, *wbuf)) {
+                n_error++;
+            }
+        }
+        sum += *wbuf; /* Checksum calculated from word values. */
+    }
+    /* Write checksum word. It will be swapped by AscWriteEEPWord(). */
+    *wbuf = sum;
+    if (sum != AscWriteEEPWord(iop_base, (uchar) s_addr, sum)) {
+        n_error++;
+    }
+
+    /* Read EEPROM back again. */
+    wbuf = (ushort *) cfg_buf;
+    /*
+     * Read two config words; Byte-swapping done by AscReadEEPWord().
+     */
+    for (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {
+        if (*wbuf != AscReadEEPWord(iop_base, (uchar) s_addr)) {
+            n_error++;
+        }
+    }
+    if (bus_type & ASC_IS_VL) {
+        cfg_beg = ASC_EEP_DVC_CFG_BEG_VL;
+        cfg_end = ASC_EEP_MAX_DVC_ADDR_VL;
+    } else {
+        cfg_beg = ASC_EEP_DVC_CFG_BEG;
+        cfg_end = ASC_EEP_MAX_DVC_ADDR;
+    }
+    for (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {
+        if (s_addr <= uchar_end_in_config) {
+            /*
+             * Swap all char fields. Must unswap bytes already swapped
+             * by AscReadEEPWord().
+             */
+            word = le16_to_cpu(AscReadEEPWord(iop_base, (uchar) s_addr));
+        } else {
+            /* Don't swap word field at the end - cntl field. */
+            word = AscReadEEPWord(iop_base, (uchar) s_addr);
+        }
+        if (*wbuf != word) {
+            n_error++;
+        }
+    }
+    /* Read checksum; Byte swapping not needed. */
+    if (AscReadEEPWord(iop_base, (uchar) s_addr) != sum) {
+        n_error++;
+    }
+    return (n_error);
+}
+
+STATIC int __init
+AscSetEEPConfig(
+                   PortAddr iop_base,
+                   ASCEEP_CONFIG * cfg_buf, ushort bus_type
+)
+{
+    int            retry;
+    int            n_error;
+
+    retry = 0;
+    while (TRUE) {
+        if ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,
+                                           bus_type)) == 0) {
+            break;
+        }
+        if (++retry > ASC_EEP_MAX_RETRY) {
+            break;
+        }
+    }
+    return (n_error);
+}
+
+STATIC void
+AscAsyncFix(
+               ASC_DVC_VAR *asc_dvc,
+               uchar tid_no,
+               ASC_SCSI_INQUIRY *inq)
+{
+    uchar                       dvc_type;
+    ASC_SCSI_BIT_ID_TYPE        tid_bits;
+
+    dvc_type = ASC_INQ_DVC_TYPE(inq);
+    tid_bits = ASC_TIX_TO_TARGET_ID(tid_no);
+
+    if (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN)
+    {
+        if (!(asc_dvc->init_sdtr & tid_bits))
+        {
+            if ((dvc_type == TYPE_ROM) &&
+                (AscCompareString((uchar *) inq->vendor_id,
+                    (uchar *) "HP ", 3) == 0))
+            {
+                asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
+            }
+            asc_dvc->pci_fix_asyn_xfer |= tid_bits;
+            if ((dvc_type == TYPE_PROCESSOR) ||
+                (dvc_type == TYPE_SCANNER) ||
+                (dvc_type == TYPE_ROM) ||
+                (dvc_type == TYPE_TAPE))
+            {
+                asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
+            }
+
+            if (asc_dvc->pci_fix_asyn_xfer & tid_bits)
+            {
+                AscSetRunChipSynRegAtID(asc_dvc->iop_base, tid_no,
+                    ASYN_SDTR_DATA_FIX_PCI_REV_AB);
+            }
+        }
+    }
+    return;
+}
+
+STATIC int
+AscTagQueuingSafe(ASC_SCSI_INQUIRY *inq)
+{
+    if ((inq->add_len >= 32) &&
+        (AscCompareString((uchar *) inq->vendor_id,
+            (uchar *) "QUANTUM XP34301", 15) == 0) &&
+        (AscCompareString((uchar *) inq->product_rev_level,
+            (uchar *) "1071", 4) == 0))
+    {
+        return 0;
+    }
+    return 1;
+}
+
+STATIC void
+AscInquiryHandling(ASC_DVC_VAR *asc_dvc,
+                   uchar tid_no, ASC_SCSI_INQUIRY *inq)
+{
+    ASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);
+    ASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;
+
+    orig_init_sdtr = asc_dvc->init_sdtr;
+    orig_use_tagged_qng = asc_dvc->use_tagged_qng;
+
+    asc_dvc->init_sdtr &= ~tid_bit;
+    asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
+    asc_dvc->use_tagged_qng &= ~tid_bit;
+
+    if (ASC_INQ_RESPONSE_FMT(inq) >= 2 || ASC_INQ_ANSI_VER(inq) >= 2) {
+        if ((asc_dvc->cfg->sdtr_enable & tid_bit) && ASC_INQ_SYNC(inq)) {
+            asc_dvc->init_sdtr |= tid_bit;
+        }
+        if ((asc_dvc->cfg->cmd_qng_enabled & tid_bit) &&
+             ASC_INQ_CMD_QUEUE(inq)) {
+            if (AscTagQueuingSafe(inq)) {
+                asc_dvc->use_tagged_qng |= tid_bit;
+                asc_dvc->cfg->can_tagged_qng |= tid_bit;
+            }
+        }
+    }
+    if (orig_use_tagged_qng != asc_dvc->use_tagged_qng) {
+        AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
+                         asc_dvc->cfg->disc_enable);
+        AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
+                         asc_dvc->use_tagged_qng);
+        AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
+                         asc_dvc->cfg->can_tagged_qng);
+
+        asc_dvc->max_dvc_qng[tid_no] =
+          asc_dvc->cfg->max_tag_qng[tid_no];
+        AscWriteLramByte(asc_dvc->iop_base,
+                         (ushort) (ASCV_MAX_DVC_QNG_BEG + tid_no),
+                         asc_dvc->max_dvc_qng[tid_no]);
+    }
+    if (orig_init_sdtr != asc_dvc->init_sdtr) {
+        AscAsyncFix(asc_dvc, tid_no, inq);
+    }
+    return;
+}
+
+STATIC int
+AscCompareString(
+                    uchar *str1,
+                    uchar *str2,
+                    int len
+)
+{
+    int                 i;
+    int                 diff;
+
+    for (i = 0; i < len; i++) {
+        diff = (int) (str1[i] - str2[i]);
+        if (diff != 0)
+            return (diff);
+    }
+    return (0);
+}
+
+STATIC uchar
+AscReadLramByte(
+                   PortAddr iop_base,
+                   ushort addr
+)
+{
+    uchar               byte_data;
+    ushort              word_data;
+
+    if (isodd_word(addr)) {
+        AscSetChipLramAddr(iop_base, addr - 1);
+        word_data = AscGetChipLramData(iop_base);
+        byte_data = (uchar) ((word_data >> 8) & 0xFF);
+    } else {
+        AscSetChipLramAddr(iop_base, addr);
+        word_data = AscGetChipLramData(iop_base);
+        byte_data = (uchar) (word_data & 0xFF);
+    }
+    return (byte_data);
+}
+STATIC ushort
+AscReadLramWord(
+                   PortAddr iop_base,
+                   ushort addr
+)
+{
+    ushort              word_data;
+
+    AscSetChipLramAddr(iop_base, addr);
+    word_data = AscGetChipLramData(iop_base);
+    return (word_data);
+}
+
+#if CC_VERY_LONG_SG_LIST
+STATIC ASC_DCNT
+AscReadLramDWord(
+                    PortAddr iop_base,
+                    ushort addr
+)
+{
+    ushort              val_low, val_high;
+    ASC_DCNT            dword_data;
+
+    AscSetChipLramAddr(iop_base, addr);
+    val_low = AscGetChipLramData(iop_base);
+    val_high = AscGetChipLramData(iop_base);
+    dword_data = ((ASC_DCNT) val_high << 16) | (ASC_DCNT) val_low;
+    return (dword_data);
+}
+#endif /* CC_VERY_LONG_SG_LIST */
+
+STATIC void
+AscWriteLramWord(
+                    PortAddr iop_base,
+                    ushort addr,
+                    ushort word_val
+)
+{
+    AscSetChipLramAddr(iop_base, addr);
+    AscSetChipLramData(iop_base, word_val);
+    return;
+}
+
+STATIC void
+AscWriteLramByte(
+                    PortAddr iop_base,
+                    ushort addr,
+                    uchar byte_val
+)
+{
+    ushort              word_data;
+
+    if (isodd_word(addr)) {
+        addr--;
+        word_data = AscReadLramWord(iop_base, addr);
+        word_data &= 0x00FF;
+        word_data |= (((ushort) byte_val << 8) & 0xFF00);
+    } else {
+        word_data = AscReadLramWord(iop_base, addr);
+        word_data &= 0xFF00;
+        word_data |= ((ushort) byte_val & 0x00FF);
+    }
+    AscWriteLramWord(iop_base, addr, word_data);
+    return;
+}
+
+/*
+ * Copy 2 bytes to LRAM.
+ *
+ * The source data is assumed to be in little-endian order in memory
+ * and is maintained in little-endian order when written to LRAM.
+ */
+STATIC void
+AscMemWordCopyPtrToLram(
+                        PortAddr iop_base,
+                        ushort s_addr,
+                        uchar *s_buffer,
+                        int words
+)
+{
+    int    i;
+
+    AscSetChipLramAddr(iop_base, s_addr);
+    for (i = 0; i < 2 * words; i += 2) {
+        /*
+         * On a little-endian system the second argument below
+         * produces a little-endian ushort which is written to
+         * LRAM in little-endian order. On a big-endian system
+         * the second argument produces a big-endian ushort which
+         * is "transparently" byte-swapped by outpw() and written
+         * in little-endian order to LRAM.
+         */
+        outpw(iop_base + IOP_RAM_DATA,
+            ((ushort) s_buffer[i + 1] << 8) | s_buffer[i]);
+    }
+    return;
+}
+
+/*
+ * Copy 4 bytes to LRAM.
+ *
+ * The source data is assumed to be in little-endian order in memory
+ * and is maintained in little-endian order when writen to LRAM.
+ */
+STATIC void
+AscMemDWordCopyPtrToLram(
+                         PortAddr iop_base,
+                         ushort s_addr,
+                         uchar *s_buffer,
+                         int dwords
+)
+{
+    int       i;
+
+    AscSetChipLramAddr(iop_base, s_addr);
+    for (i = 0; i < 4 * dwords; i += 4) {
+        outpw(iop_base + IOP_RAM_DATA,
+            ((ushort) s_buffer[i + 1] << 8) | s_buffer[i]); /* LSW */
+        outpw(iop_base + IOP_RAM_DATA,
+            ((ushort) s_buffer[i + 3] << 8) | s_buffer[i + 2]); /* MSW */
+    }
+    return;
+}
+
+/*
+ * Copy 2 bytes from LRAM.
+ *
+ * The source data is assumed to be in little-endian order in LRAM
+ * and is maintained in little-endian order when written to memory.
+ */
+STATIC void
+AscMemWordCopyPtrFromLram(
+                          PortAddr iop_base,
+                          ushort s_addr,
+                          uchar *d_buffer,
+                          int words
+)
+{
+    int i;
+    ushort word;
+
+    AscSetChipLramAddr(iop_base, s_addr);
+    for (i = 0; i < 2 * words; i += 2) {
+        word = inpw(iop_base + IOP_RAM_DATA);
+        d_buffer[i] = word & 0xff;
+        d_buffer[i + 1] = (word >> 8) & 0xff;
+    }
+    return;
+}
+
+STATIC ASC_DCNT
+AscMemSumLramWord(
+                     PortAddr iop_base,
+                     ushort s_addr,
+                     int words
+)
+{
+    ASC_DCNT         sum;
+    int              i;
+
+    sum = 0L;
+    for (i = 0; i < words; i++, s_addr += 2) {
+        sum += AscReadLramWord(iop_base, s_addr);
+    }
+    return (sum);
+}
+
+STATIC void
+AscMemWordSetLram(
+                     PortAddr iop_base,
+                     ushort s_addr,
+                     ushort set_wval,
+                     int words
+)
+{
+    int             i;
+
+    AscSetChipLramAddr(iop_base, s_addr);
+    for (i = 0; i < words; i++) {
+        AscSetChipLramData(iop_base, set_wval);
+    }
+    return;
+}
+
+
+/*
+ * --- Adv Library Functions
+ */
+
+/* a_mcode.h */
+
+/* Microcode buffer is kept after initialization for error recovery. */
+STATIC unsigned char _adv_asc3550_buf[] = {
+  0x00,  0x00,  0x00,  0xf2,  0x00,  0xf0,  0x00,  0x16,  0x18,  0xe4,  0x00,  0xfc,  0x01,  0x00,  0x48,  0xe4,
+  0xbe,  0x18,  0x18,  0x80,  0x03,  0xf6,  0x02,  0x00,  0x00,  0xfa,  0xff,  0xff,  0x28,  0x0e,  0x9e,  0xe7,
+  0xff,  0x00,  0x82,  0xe7,  0x00,  0xea,  0x00,  0xf6,  0x01,  0xe6,  0x09,  0xe7,  0x55,  0xf0,  0x01,  0xf6,
+  0x01,  0xfa,  0x08,  0x00,  0x03,  0x00,  0x04,  0x00,  0x18,  0xf4,  0x10,  0x00,  0x00,  0xec,  0x85,  0xf0,
+  0xbc,  0x00,  0xd5,  0xf0,  0x8e,  0x0c,  0x38,  0x54,  0x00,  0xe6,  0x1e,  0xf0,  0x86,  0xf0,  0xb4,  0x00,
+  0x98,  0x57,  0xd0,  0x01,  0x0c,  0x1c,  0x3e,  0x1c,  0x0c,  0x00,  0xbb,  0x00,  0xaa,  0x18,  0x02,  0x80,
+  0x32,  0xf0,  0x01,  0xfc,  0x88,  0x0c,  0xc6,  0x12,  0x02,  0x13,  0x18,  0x40,  0x00,  0x57,  0x01,  0xea,
+  0x3c,  0x00,  0x6c,  0x01,  0x6e,  0x01,  0x04,  0x12,  0x3e,  0x57,  0x00,  0x80,  0x03,  0xe6,  0xb6,  0x00,
+  0xc0,  0x00,  0x01,  0x01,  0x3e,  0x01,  0xda,  0x0f,  0x22,  0x10,  0x08,  0x12,  0x02,  0x4a,  0xb9,  0x54,
+  0x03,  0x58,  0x1b,  0x80,  0x30,  0xe4,  0x4b,  0xe4,  0x20,  0x00,  0x32,  0x00,  0x3e,  0x00,  0x80,  0x00,
+  0x24,  0x01,  0x3c,  0x01,  0x68,  0x01,  0x6a,  0x01,  0x70,  0x01,  0x72,  0x01,  0x74,  0x01,  0x76,  0x01,
+  0x78,  0x01,  0x62,  0x0a,  0x92,  0x0c,  0x2c,  0x10,  0x2e,  0x10,  0x06,  0x13,  0x4c,  0x1c,  0xbb,  0x55,
+  0x3c,  0x56,  0x04,  0x80,  0x4a,  0xe4,  0x02,  0xee,  0x5b,  0xf0,  0xb1,  0xf0,  0x03,  0xf7,  0x06,  0xf7,
+  0x03,  0xfc,  0x0f,  0x00,  0x40,  0x00,  0xbe,  0x00,  0x00,  0x01,  0xb0,  0x08,  0x30,  0x13,  0x64,  0x15,
+  0x32,  0x1c,  0x38,  0x1c,  0x4e,  0x1c,  0x10,  0x44,  0x02,  0x48,  0x00,  0x4c,  0x04,  0xea,  0x5d,  0xf0,
+  0x04,  0xf6,  0x02,  0xfc,  0x05,  0x00,  0x34,  0x00,  0x36,  0x00,  0x98,  0x00,  0xcc,  0x00,  0x20,  0x01,
+  0x4e,  0x01,  0x4e,  0x0b,  0x1e,  0x0e,  0x0c,  0x10,  0x0a,  0x12,  0x04,  0x13,  0x40,  0x13,  0x30,  0x1c,
+  0x00,  0x4e,  0xbd,  0x56,  0x06,  0x83,  0x00,  0xdc,  0x05,  0xf0,  0x09,  0xf0,  0x59,  0xf0,  0xa7,  0xf0,
+  0xb8,  0xf0,  0x0e,  0xf7,  0x06,  0x00,  0x19,  0x00,  0x33,  0x00,  0x9b,  0x00,  0xa4,  0x00,  0xb5,  0x00,
+  0xba,  0x00,  0xd0,  0x00,  0xe1,  0x00,  0xe7,  0x00,  0xde,  0x03,  0x56,  0x0a,  0x14,  0x0e,  0x02,  0x10,
+  0x04,  0x10,  0x0a,  0x10,  0x36,  0x10,  0x0a,  0x13,  0x12,  0x13,  0x52,  0x13,  0x10,  0x15,  0x14,  0x15,
+  0xac,  0x16,  0x20,  0x1c,  0x34,  0x1c,  0x36,  0x1c,  0x08,  0x44,  0x38,  0x44,  0x91,  0x44,  0x0a,  0x45,
+  0x48,  0x46,  0x01,  0x48,  0x68,  0x54,  0x83,  0x55,  0xb0,  0x57,  0x01,  0x58,  0x83,  0x59,  0x05,  0xe6,
+  0x0b,  0xf0,  0x0c,  0xf0,  0x5c,  0xf0,  0x4b,  0xf4,  0x04,  0xf8,  0x05,  0xf8,  0x02,  0xfa,  0x03,  0xfa,
+  0x04,  0xfc,  0x05,  0xfc,  0x07,  0x00,  0x0a,  0x00,  0x0d,  0x00,  0x1c,  0x00,  0x9e,  0x00,  0xa8,  0x00,
+  0xaa,  0x00,  0xb9,  0x00,  0xe0,  0x00,  0x22,  0x01,  0x26,  0x01,  0x79,  0x01,  0x7a,  0x01,  0xc0,  0x01,
+  0xc2,  0x01,  0x7c,  0x02,  0x5a,  0x03,  0xea,  0x04,  0xe8,  0x07,  0x68,  0x08,  0x69,  0x08,  0xba,  0x08,
+  0xe9,  0x09,  0x06,  0x0b,  0x3a,  0x0e,  0x00,  0x10,  0x1a,  0x10,  0xed,  0x10,  0xf1,  0x10,  0x06,  0x12,
+  0x0c,  0x13,  0x16,  0x13,  0x1e,  0x13,  0x82,  0x13,  0x42,  0x14,  0xd6,  0x14,  0x8a,  0x15,  0xc6,  0x17,
+  0xd2,  0x17,  0x6b,  0x18,  0x12,  0x1c,  0x46,  0x1c,  0x9c,  0x32,  0x00,  0x40,  0x0e,  0x47,  0x48,  0x47,
+  0x41,  0x48,  0x89,  0x48,  0x80,  0x4c,  0x00,  0x54,  0x44,  0x55,  0xe5,  0x55,  0x14,  0x56,  0x77,  0x57,
+  0xbf,  0x57,  0x40,  0x5c,  0x06,  0x80,  0x08,  0x90,  0x03,  0xa1,  0xfe,  0x9c,  0xf0,  0x29,  0x02,  0xfe,
+  0xb8,  0x0c,  0xff,  0x10,  0x00,  0x00,  0xd0,  0xfe,  0xcc,  0x18,  0x00,  0xcf,  0xfe,  0x80,  0x01,  0xff,
+  0x03,  0x00,  0x00,  0xfe,  0x93,  0x15,  0xfe,  0x0f,  0x05,  0xff,  0x38,  0x00,  0x00,  0xfe,  0x57,  0x24,
+  0x00,  0xfe,  0x48,  0x00,  0x4f,  0xff,  0x04,  0x00,  0x00,  0x10,  0xff,  0x09,  0x00,  0x00,  0xff,  0x08,
+  0x01,  0x01,  0xff,  0x08,  0xff,  0xff,  0xff,  0x27,  0x00,  0x00,  0xff,  0x10,  0xff,  0xff,  0xff,  0x0f,
+  0x00,  0x00,  0xfe,  0x78,  0x56,  0xfe,  0x34,  0x12,  0xff,  0x21,  0x00,  0x00,  0xfe,  0x04,  0xf7,  0xcf,
+  0x2a,  0x67,  0x0b,  0x01,  0xfe,  0xce,  0x0e,  0xfe,  0x04,  0xf7,  0xcf,  0x67,  0x0b,  0x3c,  0x2a,  0xfe,
+  0x3d,  0xf0,  0xfe,  0x02,  0x02,  0xfe,  0x20,  0xf0,  0x9c,  0xfe,  0x91,  0xf0,  0xfe,  0xf0,  0x01,  0xfe,
+  0x90,  0xf0,  0xfe,  0xf0,  0x01,  0xfe,  0x8f,  0xf0,  0x9c,  0x05,  0x51,  0x3b,  0x02,  0xfe,  0xd4,  0x0c,
+  0x01,  0xfe,  0x44,  0x0d,  0xfe,  0xdd,  0x12,  0xfe,  0xfc,  0x10,  0xfe,  0x28,  0x1c,  0x05,  0xfe,  0xa6,
+  0x00,  0xfe,  0xd3,  0x12,  0x47,  0x18,  0xfe,  0xa6,  0x00,  0xb5,  0xfe,  0x48,  0xf0,  0xfe,  0x86,  0x02,
+  0xfe,  0x49,  0xf0,  0xfe,  0xa0,  0x02,  0xfe,  0x4a,  0xf0,  0xfe,  0xbe,  0x02,  0xfe,  0x46,  0xf0,  0xfe,
+  0x50,  0x02,  0xfe,  0x47,  0xf0,  0xfe,  0x56,  0x02,  0xfe,  0x43,  0xf0,  0xfe,  0x44,  0x02,  0xfe,  0x44,
+  0xf0,  0xfe,  0x48,  0x02,  0xfe,  0x45,  0xf0,  0xfe,  0x4c,  0x02,  0x17,  0x0b,  0xa0,  0x17,  0x06,  0x18,
+  0x96,  0x02,  0x29,  0xfe,  0x00,  0x1c,  0xde,  0xfe,  0x02,  0x1c,  0xdd,  0xfe,  0x1e,  0x1c,  0xfe,  0xe9,
+  0x10,  0x01,  0xfe,  0x20,  0x17,  0xfe,  0xe7,  0x10,  0xfe,  0x06,  0xfc,  0xc7,  0x0a,  0x6b,  0x01,  0x9e,
+  0x02,  0x29,  0x14,  0x4d,  0x37,  0x97,  0x01,  0xfe,  0x64,  0x0f,  0x0a,  0x6b,  0x01,  0x82,  0xfe,  0xbd,
+  0x10,  0x0a,  0x6b,  0x01,  0x82,  0xfe,  0xad,  0x10,  0xfe,  0x16,  0x1c,  0xfe,  0x58,  0x1c,  0x17,  0x06,
+  0x18,  0x96,  0x2a,  0x25,  0x29,  0xfe,  0x3d,  0xf0,  0xfe,  0x02,  0x02,  0x21,  0xfe,  0x94,  0x02,  0xfe,
+  0x5a,  0x1c,  0xea,  0xfe,  0x14,  0x1c,  0x14,  0xfe,  0x30,  0x00,  0x37,  0x97,  0x01,  0xfe,  0x54,  0x0f,
+  0x17,  0x06,  0x18,  0x96,  0x02,  0xd0,  0x1e,  0x20,  0x07,  0x10,  0x34,  0xfe,  0x69,  0x10,  0x17,  0x06,
+  0x18,  0x96,  0xfe,  0x04,  0xec,  0x20,  0x46,  0x3d,  0x12,  0x20,  0xfe,  0x05,  0xf6,  0xc7,  0x01,  0xfe,
+  0x52,  0x16,  0x09,  0x4a,  0x4c,  0x35,  0x11,  0x2d,  0x3c,  0x8a,  0x01,  0xe6,  0x02,  0x29,  0x0a,  0x40,
+  0x01,  0x0e,  0x07,  0x00,  0x5d,  0x01,  0x6f,  0xfe,  0x18,  0x10,  0xfe,  0x41,  0x58,  0x0a,  0x99,  0x01,
+  0x0e,  0xfe,  0xc8,  0x54,  0x64,  0xfe,  0x0c,  0x03,  0x01,  0xe6,  0x02,  0x29,  0x2a,  0x46,  0xfe,  0x02,
+  0xe8,  0x27,  0xf8,  0xfe,  0x9e,  0x43,  0xf7,  0xfe,  0x27,  0xf0,  0xfe,  0xdc,  0x01,  0xfe,  0x07,  0x4b,
+  0xfe,  0x20,  0xf0,  0x9c,  0xfe,  0x40,  0x1c,  0x25,  0xd2,  0xfe,  0x26,  0xf0,  0xfe,  0x56,  0x03,  0xfe,
+  0xa0,  0xf0,  0xfe,  0x44,  0x03,  0xfe,  0x11,  0xf0,  0x9c,  0xfe,  0xef,  0x10,  0xfe,  0x9f,  0xf0,  0xfe,
+  0x64,  0x03,  0xeb,  0x0f,  0xfe,  0x11,  0x00,  0x02,  0x5a,  0x2a,  0xfe,  0x48,  0x1c,  0xeb,  0x09,  0x04,
+  0x1d,  0xfe,  0x18,  0x13,  0x23,  0x1e,  0x98,  0xac,  0x12,  0x98,  0x0a,  0x40,  0x01,  0x0e,  0xac,  0x75,
+  0x01,  0xfe,  0xbc,  0x15,  0x11,  0xca,  0x25,  0xd2,  0xfe,  0x01,  0xf0,  0xd2,  0xfe,  0x82,  0xf0,  0xfe,
+  0x92,  0x03,  0xec,  0x11,  0xfe,  0xe4,  0x00,  0x65,  0xfe,  0xa4,  0x03,  0x25,  0x32,  0x1f,  0xfe,  0xb4,
+  0x03,  0x01,  0x43,  0xfe,  0x06,  0xf0,  0xfe,  0xc4,  0x03,  0x8d,  0x81,  0xfe,  0x0a,  0xf0,  0xfe,  0x7a,
+  0x06,  0x02,  0x22,  0x05,  0x6b,  0x28,  0x16,  0xfe,  0xf6,  0x04,  0x14,  0x2c,  0x01,  0x33,  0x8f,  0xfe,
+  0x66,  0x02,  0x02,  0xd1,  0xeb,  0x2a,  0x67,  0x1a,  0xfe,  0x67,  0x1b,  0xf8,  0xf7,  0xfe,  0x48,  0x1c,
+  0x70,  0x01,  0x6e,  0x87,  0x0a,  0x40,  0x01,  0x0e,  0x07,  0x00,  0x16,  0xd3,  0x0a,  0xca,  0x01,  0x0e,
+  0x74,  0x60,  0x59,  0x76,  0x27,  0x05,  0x6b,  0x28,  0xfe,  0x10,  0x12,  0x14,  0x2c,  0x01,  0x33,  0x8f,
+  0xfe,  0x66,  0x02,  0x02,  0xd1,  0xbc,  0x7d,  0xbd,  0x7f,  0x25,  0x22,  0x65,  0xfe,  0x3c,  0x04,  0x1f,
+  0xfe,  0x38,  0x04,  0x68,  0xfe,  0xa0,  0x00,  0xfe,  0x9b,  0x57,  0xfe,  0x4e,  0x12,  0x2b,  0xff,  0x02,
+  0x00,  0x10,  0x01,  0x08,  0x1f,  0xfe,  0xe0,  0x04,  0x2b,  0x01,  0x08,  0x1f,  0x22,  0x30,  0x2e,  0xd5,
+  0xfe,  0x4c,  0x44,  0xfe,  0x4c,  0x12,  0x60,  0xfe,  0x44,  0x48,  0x13,  0x2c,  0xfe,  0x4c,  0x54,  0x64,
+  0xd3,  0x46,  0x76,  0x27,  0xfa,  0xef,  0xfe,  0x62,  0x13,  0x09,  0x04,  0x1d,  0xfe,  0x2a,  0x13,  0x2f,
+  0x07,  0x7e,  0xa5,  0xfe,  0x20,  0x10,  0x13,  0x2c,  0xfe,  0x4c,  0x54,  0x64,  0xd3,  0xfa,  0xef,  0x86,
+  0x09,  0x04,  0x1d,  0xfe,  0x08,  0x13,  0x2f,  0x07,  0x7e,  0x6e,  0x09,  0x04,  0x1d,  0xfe,  0x1c,  0x12,
+  0x14,  0x92,  0x09,  0x04,  0x06,  0x3b,  0x14,  0xc4,  0x01,  0x33,  0x8f,  0xfe,  0x70,  0x0c,  0x02,  0x22,
+  0x2b,  0x11,  0xfe,  0xe6,  0x00,  0xfe,  0x1c,  0x90,  0xf9,  0x03,  0x14,  0x92,  0x01,  0x33,  0x02,  0x29,
+  0xfe,  0x42,  0x5b,  0x67,  0x1a,  0xfe,  0x46,  0x59,  0xf8,  0xf7,  0xfe,  0x87,  0x80,  0xfe,  0x31,  0xe4,
+  0x4f,  0x09,  0x04,  0x0b,  0xfe,  0x78,  0x13,  0xfe,  0x20,  0x80,  0x07,  0x1a,  0xfe,  0x70,  0x12,  0x49,
+  0x04,  0x06,  0xfe,  0x60,  0x13,  0x05,  0xfe,  0xa2,  0x00,  0x28,  0x16,  0xfe,  0x80,  0x05,  0xfe,  0x31,
+  0xe4,  0x6a,  0x49,  0x04,  0x0b,  0xfe,  0x4a,  0x13,  0x05,  0xfe,  0xa0,  0x00,  0x28,  0xfe,  0x42,  0x12,
+  0x5e,  0x01,  0x08,  0x25,  0x32,  0xf1,  0x01,  0x08,  0x26,  0xfe,  0x98,  0x05,  0x11,  0xfe,  0xe3,  0x00,
+  0x23,  0x49,  0xfe,  0x4a,  0xf0,  0xfe,  0x6a,  0x05,  0xfe,  0x49,  0xf0,  0xfe,  0x64,  0x05,  0x83,  0x24,
+  0xfe,  0x21,  0x00,  0xa1,  0x24,  0xfe,  0x22,  0x00,  0xa0,  0x24,  0x4c,  0xfe,  0x09,  0x48,  0x01,  0x08,
+  0x26,  0xfe,  0x98,  0x05,  0xfe,  0xe2,  0x08,  0x49,  0x04,  0xc5,  0x3b,  0x01,  0x86,  0x24,  0x06,  0x12,
+  0xcc,  0x37,  0xfe,  0x27,  0x01,  0x09,  0x04,  0x1d,  0xfe,  0x22,  0x12,  0x47,  0x01,  0xa7,  0x14,  0x92,
+  0x09,  0x04,  0x06,  0x3b,  0x14,  0xc4,  0x01,  0x33,  0x8f,  0xfe,  0x70,  0x0c,  0x02,  0x22,  0x05,  0xfe,
+  0x9c,  0x00,  0x28,  0xfe,  0x3e,  0x12,  0x05,  0x50,  0x28,  0xfe,  0x36,  0x13,  0x47,  0x01,  0xa7,  0x26,
+  0xfe,  0x08,  0x06,  0x0a,  0x06,  0x49,  0x04,  0x19,  0xfe,  0x02,  0x12,  0x5f,  0x01,  0xfe,  0xaa,  0x14,
+  0x1f,  0xfe,  0xfe,  0x05,  0x11,  0x9a,  0x01,  0x43,  0x11,  0xfe,  0xe5,  0x00,  0x05,  0x50,  0xb4,  0x0c,
+  0x50,  0x05,  0xc6,  0x28,  0xfe,  0x62,  0x12,  0x05,  0x3f,  0x28,  0xfe,  0x5a,  0x13,  0x01,  0xfe,  0x14,
+  0x18,  0x01,  0xfe,  0x66,  0x18,  0xfe,  0x43,  0x48,  0xb7,  0x19,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,
+  0x48,  0x8b,  0x1c,  0x3d,  0x85,  0xb7,  0x69,  0x47,  0x01,  0xa7,  0x26,  0xfe,  0x72,  0x06,  0x49,  0x04,
+  0x1b,  0xdf,  0x89,  0x0a,  0x4d,  0x01,  0xfe,  0xd8,  0x14,  0x1f,  0xfe,  0x68,  0x06,  0x11,  0x9a,  0x01,
+  0x43,  0x11,  0xfe,  0xe5,  0x00,  0x05,  0x3f,  0xb4,  0x0c,  0x3f,  0x17,  0x06,  0x01,  0xa7,  0xec,  0x72,
+  0x70,  0x01,  0x6e,  0x87,  0x11,  0xfe,  0xe2,  0x00,  0x01,  0x08,  0x25,  0x32,  0xfe,  0x0a,  0xf0,  0xfe,
+  0xa6,  0x06,  0x8c,  0xfe,  0x5c,  0x07,  0xfe,  0x06,  0xf0,  0xfe,  0x64,  0x07,  0x8d,  0x81,  0x02,  0x22,
+  0x09,  0x04,  0x0b,  0xfe,  0x2e,  0x12,  0x15,  0x1a,  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x00,
+  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0xfe,  0x99,  0xa4,  0x01,  0x08,  0x15,  0x00,  0x02,  0xfe,  0x32,
+  0x08,  0x61,  0x04,  0x1b,  0xfe,  0x38,  0x12,  0x09,  0x04,  0x1b,  0x6e,  0x15,  0xfe,  0x1b,  0x00,  0x01,
+  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x00,  0x01,  0x08,  0x15,  0x06,  0x01,
+  0x08,  0x15,  0x00,  0x02,  0xd9,  0x66,  0x4c,  0xfe,  0x3a,  0x55,  0x5f,  0xfe,  0x9a,  0x81,  0x4b,  0x1d,
+  0xba,  0xfe,  0x32,  0x07,  0x0a,  0x1d,  0xfe,  0x09,  0x6f,  0xaf,  0xfe,  0xca,  0x45,  0xfe,  0x32,  0x12,
+  0x62,  0x2c,  0x85,  0x66,  0x7b,  0x01,  0x08,  0x25,  0x32,  0xfe,  0x0a,  0xf0,  0xfe,  0x32,  0x07,  0x8d,
+  0x81,  0x8c,  0xfe,  0x5c,  0x07,  0x02,  0x22,  0x01,  0x43,  0x02,  0xfe,  0x8a,  0x06,  0x15,  0x19,  0x02,
+  0xfe,  0x8a,  0x06,  0xfe,  0x9c,  0xf7,  0xd4,  0xfe,  0x2c,  0x90,  0xfe,  0xae,  0x90,  0x77,  0xfe,  0xca,
+  0x07,  0x0c,  0x54,  0x18,  0x55,  0x09,  0x4a,  0x6a,  0x35,  0x1e,  0x20,  0x07,  0x10,  0xfe,  0x0e,  0x12,
+  0x74,  0xfe,  0x80,  0x80,  0x37,  0x20,  0x63,  0x27,  0xfe,  0x06,  0x10,  0xfe,  0x83,  0xe7,  0xc4,  0xa1,
+  0xfe,  0x03,  0x40,  0x09,  0x4a,  0x4f,  0x35,  0x01,  0xa8,  0xad,  0xfe,  0x1f,  0x40,  0x12,  0x58,  0x01,
+  0xa5,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0xfe,  0x44,  0x51,  0xfe,  0xc6,  0x51,  0x83,  0xfb,  0xfe,
+  0x8a,  0x90,  0x0c,  0x52,  0x18,  0x53,  0xfe,  0x0c,  0x90,  0xfe,  0x8e,  0x90,  0xfe,  0x40,  0x50,  0xfe,
+  0xc2,  0x50,  0x0c,  0x39,  0x18,  0x3a,  0xfe,  0x4a,  0x10,  0x09,  0x04,  0x6a,  0xfe,  0x2a,  0x12,  0xfe,
+  0x2c,  0x90,  0xfe,  0xae,  0x90,  0x0c,  0x54,  0x18,  0x55,  0x09,  0x04,  0x4f,  0x85,  0x01,  0xa8,  0xfe,
+  0x1f,  0x80,  0x12,  0x58,  0xfe,  0x44,  0x90,  0xfe,  0xc6,  0x90,  0x0c,  0x56,  0x18,  0x57,  0xfb,  0xfe,
+  0x8a,  0x90,  0x0c,  0x52,  0x18,  0x53,  0xfe,  0x40,  0x90,  0xfe,  0xc2,  0x90,  0x0c,  0x39,  0x18,  0x3a,
+  0x0c,  0x38,  0x18,  0x4e,  0x09,  0x4a,  0x19,  0x35,  0x2a,  0x13,  0xfe,  0x4e,  0x11,  0x65,  0xfe,  0x48,
+  0x08,  0xfe,  0x9e,  0xf0,  0xfe,  0x5c,  0x08,  0xb1,  0x16,  0x32,  0x2a,  0x73,  0xdd,  0xb8,  0xfe,  0x80,
+  0x08,  0xb9,  0xfe,  0x9e,  0x08,  0x8c,  0xfe,  0x74,  0x08,  0xfe,  0x06,  0xf0,  0xfe,  0x7a,  0x08,  0x8d,
+  0x81,  0x02,  0x22,  0x01,  0x43,  0xfe,  0xc9,  0x10,  0x15,  0x19,  0xfe,  0xc9,  0x10,  0x61,  0x04,  0x06,
+  0xfe,  0x10,  0x12,  0x61,  0x04,  0x0b,  0x45,  0x09,  0x04,  0x0b,  0xfe,  0x68,  0x12,  0xfe,  0x2e,  0x1c,
+  0x02,  0xfe,  0x24,  0x0a,  0x61,  0x04,  0x06,  0x45,  0x61,  0x04,  0x0b,  0xfe,  0x52,  0x12,  0xfe,  0x2c,
+  0x1c,  0xfe,  0xaa,  0xf0,  0xfe,  0x1e,  0x09,  0xfe,  0xac,  0xf0,  0xfe,  0xbe,  0x08,  0xfe,  0x8a,  0x10,
+  0xaa,  0xfe,  0xf3,  0x10,  0xfe,  0xad,  0xf0,  0xfe,  0xca,  0x08,  0x02,  0xfe,  0x24,  0x0a,  0xab,  0xfe,
+  0xe7,  0x10,  0xfe,  0x2b,  0xf0,  0x9d,  0xe9,  0x1c,  0xfe,  0x00,  0xfe,  0xfe,  0x1c,  0x12,  0xb5,  0xfe,
+  0xd2,  0xf0,  0x9d,  0xfe,  0x76,  0x18,  0x1c,  0x1a,  0x16,  0x9d,  0x05,  0xcb,  0x1c,  0x06,  0x16,  0x9d,
+  0xb8,  0x6d,  0xb9,  0x6d,  0xaa,  0xab,  0xfe,  0xb1,  0x10,  0x70,  0x5e,  0x2b,  0x14,  0x92,  0x01,  0x33,
+  0x0f,  0xfe,  0x35,  0x00,  0xfe,  0x01,  0xf0,  0x5a,  0x0f,  0x7c,  0x02,  0x5a,  0xfe,  0x74,  0x18,  0x1c,
+  0xfe,  0x00,  0xf8,  0x16,  0x6d,  0x67,  0x1b,  0x01,  0xfe,  0x44,  0x0d,  0x3b,  0x01,  0xe6,  0x1e,  0x27,
+  0x74,  0x67,  0x1a,  0x02,  0x6d,  0x09,  0x04,  0x0b,  0x21,  0xfe,  0x06,  0x0a,  0x09,  0x04,  0x6a,  0xfe,
+  0x82,  0x12,  0x09,  0x04,  0x19,  0xfe,  0x66,  0x13,  0x1e,  0x58,  0xac,  0xfc,  0xfe,  0x83,  0x80,  0xfe,
+  0xc8,  0x44,  0xfe,  0x2e,  0x13,  0xfe,  0x04,  0x91,  0xfe,  0x86,  0x91,  0x63,  0x27,  0xfe,  0x40,  0x59,
+  0xfe,  0xc1,  0x59,  0x77,  0xd7,  0x05,  0x54,  0x31,  0x55,  0x0c,  0x7b,  0x18,  0x7c,  0xbe,  0x54,  0xbf,
+  0x55,  0x01,  0xa8,  0xad,  0x63,  0x27,  0x12,  0x58,  0xc0,  0x38,  0xc1,  0x4e,  0x79,  0x56,  0x68,  0x57,
+  0xf4,  0xf5,  0xfe,  0x04,  0xfa,  0x38,  0xfe,  0x05,  0xfa,  0x4e,  0x01,  0xa5,  0xa2,  0x23,  0x0c,  0x7b,
+  0x0c,  0x7c,  0x79,  0x56,  0x68,  0x57,  0xfe,  0x12,  0x10,  0x09,  0x04,  0x19,  0x16,  0xd7,  0x79,  0x39,
+  0x68,  0x3a,  0x09,  0x04,  0xfe,  0xf7,  0x00,  0x35,  0x05,  0x52,  0x31,  0x53,  0xfe,  0x10,  0x58,  0xfe,
+  0x91,  0x58,  0xfe,  0x14,  0x59,  0xfe,  0x95,  0x59,  0x02,  0x6d,  0x09,  0x04,  0x19,  0x16,  0xd7,  0x09,
+  0x04,  0xfe,  0xf7,  0x00,  0x35,  0xfe,  0x3a,  0x55,  0xfe,  0x19,  0x81,  0x5f,  0xfe,  0x10,  0x90,  0xfe,
+  0x92,  0x90,  0xfe,  0xd7,  0x10,  0x2f,  0x07,  0x9b,  0x16,  0xfe,  0xc6,  0x08,  0x11,  0x9b,  0x09,  0x04,
+  0x0b,  0xfe,  0x14,  0x13,  0x05,  0x39,  0x31,  0x3a,  0x77,  0xfe,  0xc6,  0x08,  0xfe,  0x0c,  0x58,  0xfe,
+  0x8d,  0x58,  0x02,  0x6d,  0x23,  0x47,  0xfe,  0x19,  0x80,  0xde,  0x09,  0x04,  0x0b,  0xfe,  0x1a,  0x12,
+  0xfe,  0x6c,  0x19,  0xfe,  0x19,  0x41,  0xe9,  0xb5,  0xfe,  0xd1,  0xf0,  0xd9,  0x14,  0x7a,  0x01,  0x33,
+  0x0f,  0xfe,  0x44,  0x00,  0xfe,  0x8e,  0x10,  0xfe,  0x6c,  0x19,  0xbe,  0x39,  0xfe,  0xed,  0x19,  0xbf,
+  0x3a,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0xe9,  0x1c,  0xfe,  0x00,  0xff,  0x34,  0xfe,  0x74,  0x10,
+  0xb5,  0xfe,  0xd2,  0xf0,  0xfe,  0xb2,  0x0a,  0xfe,  0x76,  0x18,  0x1c,  0x1a,  0x84,  0x05,  0xcb,  0x1c,
+  0x06,  0xfe,  0x08,  0x13,  0x0f,  0xfe,  0x16,  0x00,  0x02,  0x5a,  0xfe,  0xd1,  0xf0,  0xfe,  0xc4,  0x0a,
+  0x14,  0x7a,  0x01,  0x33,  0x0f,  0xfe,  0x17,  0x00,  0xfe,  0x42,  0x10,  0xfe,  0xce,  0xf0,  0xfe,  0xca,
+  0x0a,  0xfe,  0x3c,  0x10,  0xfe,  0xcd,  0xf0,  0xfe,  0xd6,  0x0a,  0x0f,  0xfe,  0x22,  0x00,  0x02,  0x5a,
+  0xfe,  0xcb,  0xf0,  0xfe,  0xe2,  0x0a,  0x0f,  0xfe,  0x24,  0x00,  0x02,  0x5a,  0xfe,  0xd0,  0xf0,  0xfe,
+  0xec,  0x0a,  0x0f,  0x93,  0xdc,  0xfe,  0xcf,  0xf0,  0xfe,  0xf6,  0x0a,  0x0f,  0x4c,  0xfe,  0x10,  0x10,
+  0xfe,  0xcc,  0xf0,  0xd9,  0x61,  0x04,  0x19,  0x3b,  0x0f,  0xfe,  0x12,  0x00,  0x2a,  0x13,  0xfe,  0x4e,
+  0x11,  0x65,  0xfe,  0x0c,  0x0b,  0xfe,  0x9e,  0xf0,  0xfe,  0x20,  0x0b,  0xb1,  0x16,  0x32,  0x2a,  0x73,
+  0xdd,  0xb8,  0x22,  0xb9,  0x22,  0x2a,  0xec,  0x65,  0xfe,  0x2c,  0x0b,  0x25,  0x32,  0x8c,  0xfe,  0x48,
+  0x0b,  0x8d,  0x81,  0xb8,  0xd4,  0xb9,  0xd4,  0x02,  0x22,  0x01,  0x43,  0xfe,  0xdb,  0x10,  0x11,  0xfe,
+  0xe8,  0x00,  0xaa,  0xab,  0x70,  0xbc,  0x7d,  0xbd,  0x7f,  0xfe,  0x89,  0xf0,  0x22,  0x30,  0x2e,  0xd8,
+  0xbc,  0x7d,  0xbd,  0x7f,  0x01,  0x08,  0x1f,  0x22,  0x30,  0x2e,  0xd6,  0xb1,  0x45,  0x0f,  0xfe,  0x42,
+  0x00,  0x02,  0x5a,  0x78,  0x06,  0xfe,  0x81,  0x49,  0x16,  0xfe,  0x38,  0x0c,  0x09,  0x04,  0x0b,  0xfe,
+  0x44,  0x13,  0x0f,  0x00,  0x4b,  0x0b,  0xfe,  0x54,  0x12,  0x4b,  0xfe,  0x28,  0x00,  0x21,  0xfe,  0xa6,
+  0x0c,  0x0a,  0x40,  0x01,  0x0e,  0x07,  0x00,  0x5d,  0x3e,  0xfe,  0x28,  0x00,  0xfe,  0xe2,  0x10,  0x01,
+  0xe7,  0x01,  0xe8,  0x0a,  0x99,  0x01,  0xfe,  0x32,  0x0e,  0x59,  0x11,  0x2d,  0x01,  0x6f,  0x02,  0x29,
+  0x0f,  0xfe,  0x44,  0x00,  0x4b,  0x0b,  0xdf,  0x3e,  0x0b,  0xfe,  0xb4,  0x10,  0x01,  0x86,  0x3e,  0x0b,
+  0xfe,  0xaa,  0x10,  0x01,  0x86,  0xfe,  0x19,  0x82,  0xfe,  0x34,  0x46,  0xa3,  0x3e,  0x0b,  0x0f,  0xfe,
+  0x43,  0x00,  0xfe,  0x96,  0x10,  0x09,  0x4a,  0x0b,  0x35,  0x01,  0xe7,  0x01,  0xe8,  0x59,  0x11,  0x2d,
+  0x01,  0x6f,  0x67,  0x0b,  0x59,  0x3c,  0x8a,  0x02,  0xfe,  0x2a,  0x03,  0x09,  0x04,  0x0b,  0x84,  0x3e,
+  0x0b,  0x0f,  0x00,  0xfe,  0x5c,  0x10,  0x61,  0x04,  0x1b,  0xfe,  0x58,  0x12,  0x09,  0x04,  0x1b,  0xfe,
+  0x50,  0x13,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x5c,  0x0c,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,
+  0xf0,  0xfe,  0x62,  0x0c,  0x09,  0x4a,  0x1b,  0x35,  0xfe,  0xa9,  0x10,  0x0f,  0xfe,  0x15,  0x00,  0xfe,
+  0x04,  0xe6,  0x0b,  0x5f,  0x5c,  0x0f,  0xfe,  0x13,  0x00,  0xfe,  0x10,  0x10,  0x0f,  0xfe,  0x47,  0x00,
+  0xa1,  0x0f,  0xfe,  0x41,  0x00,  0xa0,  0x0f,  0xfe,  0x24,  0x00,  0x87,  0xaa,  0xab,  0x70,  0x05,  0x6b,
+  0x28,  0x21,  0xd1,  0x5f,  0xfe,  0x04,  0xe6,  0x1b,  0xfe,  0x9d,  0x41,  0xfe,  0x1c,  0x42,  0x59,  0x01,
+  0xda,  0x02,  0x29,  0xea,  0x14,  0x0b,  0x37,  0x95,  0xa9,  0x14,  0xfe,  0x31,  0x00,  0x37,  0x97,  0x01,
+  0xfe,  0x54,  0x0f,  0x02,  0xd0,  0x3c,  0xfe,  0x06,  0xec,  0xc9,  0xee,  0x3e,  0x1d,  0xfe,  0xce,  0x45,
+  0x34,  0x3c,  0xfe,  0x06,  0xea,  0xc9,  0xfe,  0x47,  0x4b,  0x89,  0xfe,  0x75,  0x57,  0x05,  0x51,  0xfe,
+  0x98,  0x56,  0xfe,  0x38,  0x12,  0x0a,  0x42,  0x01,  0x0e,  0xfe,  0x44,  0x48,  0x46,  0x09,  0x04,  0x1d,
+  0xfe,  0x1a,  0x13,  0x0a,  0x40,  0x01,  0x0e,  0x47,  0xfe,  0x41,  0x58,  0x0a,  0x99,  0x01,  0x0e,  0xfe,
+  0x49,  0x54,  0x8e,  0xfe,  0x2a,  0x0d,  0x02,  0xfe,  0x2a,  0x03,  0x0a,  0x51,  0xfe,  0xee,  0x14,  0xee,
+  0x3e,  0x1d,  0xfe,  0xce,  0x45,  0x34,  0x3c,  0xfe,  0xce,  0x47,  0xfe,  0xad,  0x13,  0x02,  0x29,  0x1e,
+  0x20,  0x07,  0x10,  0xfe,  0x9e,  0x12,  0x23,  0x12,  0x4d,  0x12,  0x94,  0x12,  0xce,  0x1e,  0x2d,  0x47,
+  0x37,  0x2d,  0xb1,  0xe0,  0xfe,  0xbc,  0xf0,  0xfe,  0xec,  0x0d,  0x13,  0x06,  0x12,  0x4d,  0x01,  0xfe,
+  0xe2,  0x15,  0x05,  0xfe,  0x38,  0x01,  0x31,  0xfe,  0x3a,  0x01,  0x77,  0xfe,  0xf0,  0x0d,  0xfe,  0x02,
+  0xec,  0xce,  0x62,  0x00,  0x5d,  0xfe,  0x04,  0xec,  0x20,  0x46,  0xfe,  0x05,  0xf6,  0xfe,  0x34,  0x01,
+  0x01,  0xfe,  0x52,  0x16,  0xfb,  0xfe,  0x48,  0xf4,  0x0d,  0xfe,  0x18,  0x13,  0xaf,  0xfe,  0x02,  0xea,
+  0xce,  0x62,  0x7a,  0xfe,  0xc5,  0x13,  0x14,  0x1b,  0x37,  0x95,  0xa9,  0x5c,  0x05,  0xfe,  0x38,  0x01,
+  0x1c,  0xfe,  0xf0,  0xff,  0x0c,  0xfe,  0x60,  0x01,  0x05,  0xfe,  0x3a,  0x01,  0x0c,  0xfe,  0x62,  0x01,
+  0x3d,  0x12,  0x20,  0x24,  0x06,  0x12,  0x2d,  0x11,  0x2d,  0x8a,  0x13,  0x06,  0x03,  0x23,  0x03,  0x1e,
+  0x4d,  0xfe,  0xf7,  0x12,  0x1e,  0x94,  0xac,  0x12,  0x94,  0x07,  0x7a,  0xfe,  0x71,  0x13,  0xfe,  0x24,
+  0x1c,  0x14,  0x1a,  0x37,  0x95,  0xa9,  0xfe,  0xd9,  0x10,  0xb6,  0xfe,  0x03,  0xdc,  0xfe,  0x73,  0x57,
+  0xfe,  0x80,  0x5d,  0x03,  0xb6,  0xfe,  0x03,  0xdc,  0xfe,  0x5b,  0x57,  0xfe,  0x80,  0x5d,  0x03,  0xfe,
+  0x03,  0x57,  0xb6,  0x23,  0xfe,  0x00,  0xcc,  0x03,  0xfe,  0x03,  0x57,  0xb6,  0x75,  0x03,  0x09,  0x04,
+  0x4c,  0xfe,  0x22,  0x13,  0xfe,  0x1c,  0x80,  0x07,  0x06,  0xfe,  0x1a,  0x13,  0xfe,  0x1e,  0x80,  0xe1,
+  0xfe,  0x1d,  0x80,  0xa4,  0xfe,  0x0c,  0x90,  0xfe,  0x0e,  0x13,  0xfe,  0x0e,  0x90,  0xa3,  0xfe,  0x3c,
+  0x90,  0xfe,  0x30,  0xf4,  0x0b,  0xfe,  0x3c,  0x50,  0xa0,  0x01,  0xfe,  0x82,  0x16,  0x2f,  0x07,  0x2d,
+  0xe0,  0x01,  0xfe,  0xbc,  0x15,  0x09,  0x04,  0x1d,  0x45,  0x01,  0xe7,  0x01,  0xe8,  0x11,  0xfe,  0xe9,
+  0x00,  0x09,  0x04,  0x4c,  0xfe,  0x2c,  0x13,  0x01,  0xfe,  0x14,  0x16,  0xfe,  0x1e,  0x1c,  0xfe,  0x14,
+  0x90,  0xfe,  0x96,  0x90,  0x0c,  0xfe,  0x64,  0x01,  0x18,  0xfe,  0x66,  0x01,  0x09,  0x04,  0x4f,  0xfe,
+  0x12,  0x12,  0xfe,  0x03,  0x80,  0x74,  0xfe,  0x01,  0xec,  0x20,  0xfe,  0x80,  0x40,  0x12,  0x20,  0x63,
+  0x27,  0x11,  0xc8,  0x59,  0x1e,  0x20,  0xed,  0x76,  0x20,  0x03,  0xfe,  0x08,  0x1c,  0x05,  0xfe,  0xac,
+  0x00,  0xfe,  0x06,  0x58,  0x05,  0xfe,  0xae,  0x00,  0xfe,  0x07,  0x58,  0x05,  0xfe,  0xb0,  0x00,  0xfe,
+  0x08,  0x58,  0x05,  0xfe,  0xb2,  0x00,  0xfe,  0x09,  0x58,  0xfe,  0x0a,  0x1c,  0x24,  0x69,  0x12,  0xc9,
+  0x23,  0x0c,  0x50,  0x0c,  0x3f,  0x13,  0x40,  0x48,  0x5f,  0x17,  0x1d,  0xfe,  0x90,  0x4d,  0xfe,  0x91,
+  0x54,  0x21,  0xfe,  0x08,  0x0f,  0x3e,  0x10,  0x13,  0x42,  0x48,  0x17,  0x4c,  0xfe,  0x90,  0x4d,  0xfe,
+  0x91,  0x54,  0x21,  0xfe,  0x1e,  0x0f,  0x24,  0x10,  0x12,  0x20,  0x78,  0x2c,  0x46,  0x1e,  0x20,  0xed,
+  0x76,  0x20,  0x11,  0xc8,  0xf6,  0xfe,  0xd6,  0xf0,  0xfe,  0x32,  0x0f,  0xea,  0x70,  0xfe,  0x14,  0x1c,
+  0xfe,  0x10,  0x1c,  0xfe,  0x18,  0x1c,  0x03,  0x3c,  0xfe,  0x0c,  0x14,  0xee,  0xfe,  0x07,  0xe6,  0x1d,
+  0xfe,  0xce,  0x47,  0xfe,  0xf5,  0x13,  0x03,  0x01,  0x86,  0x78,  0x2c,  0x46,  0xfa,  0xef,  0xfe,  0x42,
+  0x13,  0x2f,  0x07,  0x2d,  0xfe,  0x34,  0x13,  0x0a,  0x42,  0x01,  0x0e,  0xb0,  0xfe,  0x36,  0x12,  0xf0,
+  0xfe,  0x45,  0x48,  0x01,  0xe3,  0xfe,  0x00,  0xcc,  0xb0,  0xfe,  0xf3,  0x13,  0x3d,  0x75,  0x07,  0x10,
+  0xa3,  0x0a,  0x80,  0x01,  0x0e,  0xfe,  0x80,  0x5c,  0x01,  0x6f,  0xfe,  0x0e,  0x10,  0x07,  0x7e,  0x45,
+  0xf6,  0xfe,  0xd6,  0xf0,  0xfe,  0x6c,  0x0f,  0x03,  0xfe,  0x44,  0x58,  0x74,  0xfe,  0x01,  0xec,  0x97,
+  0xfe,  0x9e,  0x40,  0xfe,  0x9d,  0xe7,  0x00,  0xfe,  0x9c,  0xe7,  0x1b,  0x76,  0x27,  0x01,  0xda,  0xfe,
+  0xdd,  0x10,  0x2a,  0xbc,  0x7d,  0xbd,  0x7f,  0x30,  0x2e,  0xd5,  0x07,  0x1b,  0xfe,  0x48,  0x12,  0x07,
+  0x0b,  0xfe,  0x56,  0x12,  0x07,  0x1a,  0xfe,  0x30,  0x12,  0x07,  0xc2,  0x16,  0xfe,  0x3e,  0x11,  0x07,
+  0xfe,  0x23,  0x00,  0x16,  0xfe,  0x4a,  0x11,  0x07,  0x06,  0x16,  0xfe,  0xa8,  0x11,  0x07,  0x19,  0xfe,
+  0x12,  0x12,  0x07,  0x00,  0x16,  0x22,  0x14,  0xc2,  0x01,  0x33,  0x9f,  0x2b,  0x01,  0x08,  0x8c,  0x43,
+  0x03,  0x2b,  0xfe,  0x62,  0x08,  0x0a,  0xca,  0x01,  0xfe,  0x32,  0x0e,  0x11,  0x7e,  0x02,  0x29,  0x2b,
+  0x2f,  0x07,  0x9b,  0xfe,  0xd9,  0x13,  0x79,  0x39,  0x68,  0x3a,  0x77,  0xfe,  0xfc,  0x10,  0x09,  0x04,
+  0x6a,  0xfe,  0x72,  0x12,  0xc0,  0x38,  0xc1,  0x4e,  0xf4,  0xf5,  0x8e,  0xfe,  0xc6,  0x10,  0x1e,  0x58,
+  0xfe,  0x26,  0x13,  0x05,  0x7b,  0x31,  0x7c,  0x77,  0xfe,  0x82,  0x0c,  0x0c,  0x54,  0x18,  0x55,  0x23,
+  0x0c,  0x7b,  0x0c,  0x7c,  0x01,  0xa8,  0x24,  0x69,  0x73,  0x12,  0x58,  0x01,  0xa5,  0xc0,  0x38,  0xc1,
+  0x4e,  0xfe,  0x04,  0x55,  0xfe,  0xa5,  0x55,  0xfe,  0x04,  0xfa,  0x38,  0xfe,  0x05,  0xfa,  0x4e,  0xfe,
+  0x91,  0x10,  0x05,  0x56,  0x31,  0x57,  0xfe,  0x40,  0x56,  0xfe,  0xe1,  0x56,  0x0c,  0x56,  0x18,  0x57,
+  0x83,  0xc0,  0x38,  0xc1,  0x4e,  0xf4,  0xf5,  0x05,  0x52,  0x31,  0x53,  0xfe,  0x00,  0x56,  0xfe,  0xa1,
+  0x56,  0x0c,  0x52,  0x18,  0x53,  0x09,  0x04,  0x6a,  0xfe,  0x1e,  0x12,  0x1e,  0x58,  0xfe,  0x1f,  0x40,
+  0x05,  0x54,  0x31,  0x55,  0xfe,  0x2c,  0x50,  0xfe,  0xae,  0x50,  0x05,  0x56,  0x31,  0x57,  0xfe,  0x44,
+  0x50,  0xfe,  0xc6,  0x50,  0x05,  0x52,  0x31,  0x53,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0x05,  0x39,
+  0x31,  0x3a,  0xfe,  0x40,  0x50,  0xfe,  0xc2,  0x50,  0x02,  0x5c,  0x24,  0x06,  0x12,  0xcd,  0x02,  0x5b,
+  0x2b,  0x01,  0x08,  0x1f,  0x44,  0x30,  0x2e,  0xd5,  0x07,  0x06,  0x21,  0x44,  0x2f,  0x07,  0x9b,  0x21,
+  0x5b,  0x01,  0x6e,  0x1c,  0x3d,  0x16,  0x44,  0x09,  0x04,  0x0b,  0xe2,  0x79,  0x39,  0x68,  0x3a,  0xfe,
+  0x0a,  0x55,  0x34,  0xfe,  0x8b,  0x55,  0xbe,  0x39,  0xbf,  0x3a,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,
+  0x02,  0x5b,  0xfe,  0x19,  0x81,  0xaf,  0xfe,  0x19,  0x41,  0x02,  0x5b,  0x2b,  0x01,  0x08,  0x25,  0x32,
+  0x1f,  0xa2,  0x30,  0x2e,  0xd8,  0x4b,  0x1a,  0xfe,  0xa6,  0x12,  0x4b,  0x0b,  0x3b,  0x02,  0x44,  0x01,
+  0x08,  0x25,  0x32,  0x1f,  0xa2,  0x30,  0x2e,  0xd6,  0x07,  0x1a,  0x21,  0x44,  0x01,  0x08,  0x1f,  0xa2,
+  0x30,  0x2e,  0xfe,  0xe8,  0x09,  0xfe,  0xc2,  0x49,  0x60,  0x05,  0xfe,  0x9c,  0x00,  0x28,  0x84,  0x49,
+  0x04,  0x19,  0x34,  0x9f,  0xfe,  0xbb,  0x45,  0x4b,  0x00,  0x45,  0x3e,  0x06,  0x78,  0x3d,  0xfe,  0xda,
+  0x14,  0x01,  0x6e,  0x87,  0xfe,  0x4b,  0x45,  0xe2,  0x2f,  0x07,  0x9a,  0xe1,  0x05,  0xc6,  0x28,  0x84,
+  0x05,  0x3f,  0x28,  0x34,  0x5e,  0x02,  0x5b,  0xfe,  0xc0,  0x5d,  0xfe,  0xf8,  0x14,  0xfe,  0x03,  0x17,
+  0x05,  0x50,  0xb4,  0x0c,  0x50,  0x5e,  0x2b,  0x01,  0x08,  0x26,  0x5c,  0x01,  0xfe,  0xaa,  0x14,  0x02,
+  0x5c,  0x01,  0x08,  0x25,  0x32,  0x1f,  0x44,  0x30,  0x2e,  0xd6,  0x07,  0x06,  0x21,  0x44,  0x01,  0xfe,
+  0x8e,  0x13,  0xfe,  0x42,  0x58,  0xfe,  0x82,  0x14,  0xfe,  0xa4,  0x14,  0x87,  0xfe,  0x4a,  0xf4,  0x0b,
+  0x16,  0x44,  0xfe,  0x4a,  0xf4,  0x06,  0xfe,  0x0c,  0x12,  0x2f,  0x07,  0x9a,  0x85,  0x02,  0x5b,  0x05,
+  0x3f,  0xb4,  0x0c,  0x3f,  0x5e,  0x2b,  0x01,  0x08,  0x26,  0x5c,  0x01,  0xfe,  0xd8,  0x14,  0x02,  0x5c,
+  0x13,  0x06,  0x65,  0xfe,  0xca,  0x12,  0x26,  0xfe,  0xe0,  0x12,  0x72,  0xf1,  0x01,  0x08,  0x23,  0x72,
+  0x03,  0x8f,  0xfe,  0xdc,  0x12,  0x25,  0xfe,  0xdc,  0x12,  0x1f,  0xfe,  0xca,  0x12,  0x5e,  0x2b,  0x01,
+  0x08,  0xfe,  0xd5,  0x10,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,  0x1c,  0xfe,  0xff,  0x7f,
+  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x03,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,  0x1c,
+  0x3d,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x03,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,
+  0x03,  0x13,  0x6c,  0xff,  0x02,  0x00,  0x57,  0x48,  0x8b,  0xfe,  0x0b,  0x58,  0x03,  0x0a,  0x50,  0x01,
+  0x82,  0x0a,  0x3f,  0x01,  0x82,  0x03,  0xfc,  0x1c,  0x10,  0xff,  0x03,  0x00,  0x54,  0xfe,  0x00,  0xf4,
+  0x19,  0x48,  0xfe,  0x00,  0x7d,  0xfe,  0x01,  0x7d,  0xfe,  0x02,  0x7d,  0xfe,  0x03,  0x7c,  0x63,  0x27,
+  0x0c,  0x52,  0x18,  0x53,  0xbe,  0x56,  0xbf,  0x57,  0x03,  0xfe,  0x62,  0x08,  0xfe,  0x82,  0x4a,  0xfe,
+  0xe1,  0x1a,  0xfe,  0x83,  0x5a,  0x74,  0x03,  0x01,  0xfe,  0x14,  0x18,  0xfe,  0x42,  0x48,  0x5f,  0x60,
+  0x89,  0x01,  0x08,  0x1f,  0xfe,  0xa2,  0x14,  0x30,  0x2e,  0xd8,  0x01,  0x08,  0x1f,  0xfe,  0xa2,  0x14,
+  0x30,  0x2e,  0xfe,  0xe8,  0x0a,  0xfe,  0xc1,  0x59,  0x05,  0xc6,  0x28,  0xfe,  0xcc,  0x12,  0x49,  0x04,
+  0x1b,  0xfe,  0xc4,  0x13,  0x23,  0x62,  0x1b,  0xe2,  0x4b,  0xc3,  0x64,  0xfe,  0xe8,  0x13,  0x3b,  0x13,
+  0x06,  0x17,  0xc3,  0x78,  0xdb,  0xfe,  0x78,  0x10,  0xff,  0x02,  0x83,  0x55,  0xa1,  0xff,  0x02,  0x83,
+  0x55,  0x62,  0x1a,  0xa4,  0xbb,  0xfe,  0x30,  0x00,  0x8e,  0xe4,  0x17,  0x2c,  0x13,  0x06,  0xfe,  0x56,
+  0x10,  0x62,  0x0b,  0xe1,  0xbb,  0xfe,  0x64,  0x00,  0x8e,  0xe4,  0x0a,  0xfe,  0x64,  0x00,  0x17,  0x93,
+  0x13,  0x06,  0xfe,  0x28,  0x10,  0x62,  0x06,  0xfe,  0x60,  0x13,  0xbb,  0xfe,  0xc8,  0x00,  0x8e,  0xe4,
+  0x0a,  0xfe,  0xc8,  0x00,  0x17,  0x4d,  0x13,  0x06,  0x83,  0xbb,  0xfe,  0x90,  0x01,  0xba,  0xfe,  0x4e,
+  0x14,  0x89,  0xfe,  0x12,  0x10,  0xfe,  0x43,  0xf4,  0x94,  0xfe,  0x56,  0xf0,  0xfe,  0x60,  0x14,  0xfe,
+  0x04,  0xf4,  0x6c,  0xfe,  0x43,  0xf4,  0x93,  0xfe,  0xf3,  0x10,  0xf9,  0x01,  0xfe,  0x22,  0x13,  0x1c,
+  0x3d,  0xfe,  0x10,  0x13,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,  0x69,  0xba,  0xfe,  0x9c,  0x14,  0xb7,
+  0x69,  0xfe,  0x1c,  0x10,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,  0x19,  0xba,  0xfe,  0x9c,  0x14,  0xb7,
+  0x19,  0x83,  0x60,  0x23,  0xfe,  0x4d,  0xf4,  0x00,  0xdf,  0x89,  0x13,  0x06,  0xfe,  0xb4,  0x56,  0xfe,
+  0xc3,  0x58,  0x03,  0x60,  0x13,  0x0b,  0x03,  0x15,  0x06,  0x01,  0x08,  0x26,  0xe5,  0x15,  0x0b,  0x01,
+  0x08,  0x26,  0xe5,  0x15,  0x1a,  0x01,  0x08,  0x26,  0xe5,  0x72,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x03,
+  0x15,  0x06,  0x01,  0x08,  0x26,  0xa6,  0x15,  0x1a,  0x01,  0x08,  0x26,  0xa6,  0x15,  0x06,  0x01,  0x08,
+  0x26,  0xa6,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x26,  0xa6,  0x72,  0xfe,  0x89,  0x4a,  0x01,  0x08,  0x03,
+  0x60,  0x03,  0x1e,  0xcc,  0x07,  0x06,  0xfe,  0x44,  0x13,  0xad,  0x12,  0xcc,  0xfe,  0x49,  0xf4,  0x00,
+  0x3b,  0x72,  0x9f,  0x5e,  0xfe,  0x01,  0xec,  0xfe,  0x27,  0x01,  0xf1,  0x01,  0x08,  0x2f,  0x07,  0xfe,
+  0xe3,  0x00,  0xfe,  0x20,  0x13,  0x1f,  0xfe,  0x5a,  0x15,  0x23,  0x12,  0xcd,  0x01,  0x43,  0x1e,  0xcd,
+  0x07,  0x06,  0x45,  0x09,  0x4a,  0x06,  0x35,  0x03,  0x0a,  0x42,  0x01,  0x0e,  0xed,  0x88,  0x07,  0x10,
+  0xa4,  0x0a,  0x80,  0x01,  0x0e,  0x88,  0x0a,  0x51,  0x01,  0x9e,  0x03,  0x0a,  0x80,  0x01,  0x0e,  0x88,
+  0xfe,  0x80,  0xe7,  0x10,  0x07,  0x10,  0x84,  0xfe,  0x45,  0x58,  0x01,  0xe3,  0x88,  0x03,  0x0a,  0x42,
+  0x01,  0x0e,  0x88,  0x0a,  0x51,  0x01,  0x9e,  0x03,  0x0a,  0x42,  0x01,  0x0e,  0xfe,  0x80,  0x80,  0xf2,
+  0xfe,  0x49,  0xe4,  0x10,  0xa4,  0x0a,  0x80,  0x01,  0x0e,  0xf2,  0x0a,  0x51,  0x01,  0x82,  0x03,  0x17,
+  0x10,  0x71,  0x66,  0xfe,  0x60,  0x01,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x24,  0x1c,  0xfe,
+  0x1d,  0xf7,  0x1d,  0x90,  0xfe,  0xf6,  0x15,  0x01,  0xfe,  0xfc,  0x16,  0xe0,  0x91,  0x1d,  0x66,  0xfe,
+  0x2c,  0x01,  0xfe,  0x2f,  0x19,  0x03,  0xae,  0x21,  0xfe,  0xe6,  0x15,  0xfe,  0xda,  0x10,  0x17,  0x10,
+  0x71,  0x05,  0xfe,  0x64,  0x01,  0xfe,  0x00,  0xf4,  0x19,  0xfe,  0x18,  0x58,  0x05,  0xfe,  0x66,  0x01,
+  0xfe,  0x19,  0x58,  0x91,  0x19,  0xfe,  0x3c,  0x90,  0xfe,  0x30,  0xf4,  0x06,  0xfe,  0x3c,  0x50,  0x66,
+  0xfe,  0x38,  0x00,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0x19,  0x90,  0xfe,  0x40,  0x16,  0xfe,  0xb6,
+  0x14,  0x34,  0x03,  0xae,  0x21,  0xfe,  0x18,  0x16,  0xfe,  0x9c,  0x10,  0x17,  0x10,  0x71,  0xfe,  0x83,
+  0x5a,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x1d,  0xf7,  0x38,  0x90,  0xfe,  0x62,  0x16,  0xfe,
+  0x94,  0x14,  0xfe,  0x10,  0x13,  0x91,  0x38,  0x66,  0x1b,  0xfe,  0xaf,  0x19,  0xfe,  0x98,  0xe7,  0x00,
+  0x03,  0xae,  0x21,  0xfe,  0x56,  0x16,  0xfe,  0x6c,  0x10,  0x17,  0x10,  0x71,  0xfe,  0x30,  0xbc,  0xfe,
+  0xb2,  0xbc,  0x91,  0xc5,  0x66,  0x1b,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0xc5,  0x90,  0xfe,  0x9a,
+  0x16,  0xfe,  0x5c,  0x14,  0x34,  0x03,  0xae,  0x21,  0xfe,  0x86,  0x16,  0xfe,  0x42,  0x10,  0xfe,  0x02,
+  0xf6,  0x10,  0x71,  0xfe,  0x18,  0xfe,  0x54,  0xfe,  0x19,  0xfe,  0x55,  0xfc,  0xfe,  0x1d,  0xf7,  0x4f,
+  0x90,  0xfe,  0xc0,  0x16,  0xfe,  0x36,  0x14,  0xfe,  0x1c,  0x13,  0x91,  0x4f,  0x47,  0xfe,  0x83,  0x58,
+  0xfe,  0xaf,  0x19,  0xfe,  0x80,  0xe7,  0x10,  0xfe,  0x81,  0xe7,  0x10,  0x11,  0xfe,  0xdd,  0x00,  0x63,
+  0x27,  0x03,  0x63,  0x27,  0xfe,  0x12,  0x45,  0x21,  0xfe,  0xb0,  0x16,  0x14,  0x06,  0x37,  0x95,  0xa9,
+  0x02,  0x29,  0xfe,  0x39,  0xf0,  0xfe,  0x04,  0x17,  0x23,  0x03,  0xfe,  0x7e,  0x18,  0x1c,  0x1a,  0x5d,
+  0x13,  0x0d,  0x03,  0x71,  0x05,  0xcb,  0x1c,  0x06,  0xfe,  0xef,  0x12,  0xfe,  0xe1,  0x10,  0x78,  0x2c,
+  0x46,  0x2f,  0x07,  0x2d,  0xfe,  0x3c,  0x13,  0xfe,  0x82,  0x14,  0xfe,  0x42,  0x13,  0x3c,  0x8a,  0x0a,
+  0x42,  0x01,  0x0e,  0xb0,  0xfe,  0x3e,  0x12,  0xf0,  0xfe,  0x45,  0x48,  0x01,  0xe3,  0xfe,  0x00,  0xcc,
+  0xb0,  0xfe,  0xf3,  0x13,  0x3d,  0x75,  0x07,  0x10,  0xa3,  0x0a,  0x80,  0x01,  0x0e,  0xf2,  0x01,  0x6f,
+  0xfe,  0x16,  0x10,  0x07,  0x7e,  0x85,  0xfe,  0x40,  0x14,  0xfe,  0x24,  0x12,  0xf6,  0xfe,  0xd6,  0xf0,
+  0xfe,  0x24,  0x17,  0x17,  0x0b,  0x03,  0xfe,  0x9c,  0xe7,  0x0b,  0x0f,  0xfe,  0x15,  0x00,  0x59,  0x76,
+  0x27,  0x01,  0xda,  0x17,  0x06,  0x03,  0x3c,  0x8a,  0x09,  0x4a,  0x1d,  0x35,  0x11,  0x2d,  0x01,  0x6f,
+  0x17,  0x06,  0x03,  0xfe,  0x38,  0x90,  0xfe,  0xba,  0x90,  0x79,  0xc7,  0x68,  0xc8,  0xfe,  0x48,  0x55,
+  0x34,  0xfe,  0xc9,  0x55,  0x03,  0x1e,  0x98,  0x73,  0x12,  0x98,  0x03,  0x0a,  0x99,  0x01,  0x0e,  0xf0,
+  0x0a,  0x40,  0x01,  0x0e,  0xfe,  0x49,  0x44,  0x16,  0xfe,  0xf0,  0x17,  0x73,  0x75,  0x03,  0x0a,  0x42,
+  0x01,  0x0e,  0x07,  0x10,  0x45,  0x0a,  0x51,  0x01,  0x9e,  0x0a,  0x40,  0x01,  0x0e,  0x73,  0x75,  0x03,
+  0xfe,  0x4e,  0xe4,  0x1a,  0x64,  0xfe,  0x24,  0x18,  0x05,  0xfe,  0x90,  0x00,  0xfe,  0x3a,  0x45,  0x5b,
+  0xfe,  0x4e,  0xe4,  0xc2,  0x64,  0xfe,  0x36,  0x18,  0x05,  0xfe,  0x92,  0x00,  0xfe,  0x02,  0xe6,  0x1b,
+  0xdc,  0xfe,  0x4e,  0xe4,  0xfe,  0x0b,  0x00,  0x64,  0xfe,  0x48,  0x18,  0x05,  0xfe,  0x94,  0x00,  0xfe,
+  0x02,  0xe6,  0x19,  0xfe,  0x08,  0x10,  0x05,  0xfe,  0x96,  0x00,  0xfe,  0x02,  0xe6,  0x2c,  0xfe,  0x4e,
+  0x45,  0xfe,  0x0c,  0x12,  0xaf,  0xff,  0x04,  0x68,  0x54,  0xde,  0x1c,  0x69,  0x03,  0x07,  0x7a,  0xfe,
+  0x5a,  0xf0,  0xfe,  0x74,  0x18,  0x24,  0xfe,  0x09,  0x00,  0xfe,  0x34,  0x10,  0x07,  0x1b,  0xfe,  0x5a,
+  0xf0,  0xfe,  0x82,  0x18,  0x24,  0xc3,  0xfe,  0x26,  0x10,  0x07,  0x1a,  0x5d,  0x24,  0x2c,  0xdc,  0x07,
+  0x0b,  0x5d,  0x24,  0x93,  0xfe,  0x0e,  0x10,  0x07,  0x06,  0x5d,  0x24,  0x4d,  0x9f,  0xad,  0x03,  0x14,
+  0xfe,  0x09,  0x00,  0x01,  0x33,  0xfe,  0x04,  0xfe,  0x7d,  0x05,  0x7f,  0xf9,  0x03,  0x25,  0xfe,  0xca,
+  0x18,  0xfe,  0x14,  0xf0,  0x08,  0x65,  0xfe,  0xc6,  0x18,  0x03,  0xff,  0x1a,  0x00,  0x00,
+};
+
+STATIC unsigned short _adv_asc3550_size =
+        sizeof(_adv_asc3550_buf); /* 0x13AD */
+STATIC ADV_DCNT _adv_asc3550_chksum =
+        0x04D52DDDUL; /* Expanded little-endian checksum. */
+
+/* Microcode buffer is kept after initialization for error recovery. */
+STATIC unsigned char _adv_asc38C0800_buf[] = {
+  0x00,  0x00,  0x00,  0xf2,  0x00,  0xf0,  0x00,  0xfc,  0x00,  0x16,  0x18,  0xe4,  0x01,  0x00,  0x48,  0xe4,
+  0x18,  0x80,  0x03,  0xf6,  0x02,  0x00,  0xce,  0x19,  0x00,  0xfa,  0xff,  0xff,  0x1c,  0x0f,  0x00,  0xf6,
+  0x9e,  0xe7,  0xff,  0x00,  0x82,  0xe7,  0x00,  0xea,  0x01,  0xfa,  0x01,  0xe6,  0x09,  0xe7,  0x55,  0xf0,
+  0x01,  0xf6,  0x03,  0x00,  0x04,  0x00,  0x10,  0x00,  0x1e,  0xf0,  0x85,  0xf0,  0x18,  0xf4,  0x08,  0x00,
+  0xbc,  0x00,  0x38,  0x54,  0x00,  0xec,  0xd5,  0xf0,  0x82,  0x0d,  0x00,  0xe6,  0x86,  0xf0,  0xb1,  0xf0,
+  0x98,  0x57,  0x01,  0xfc,  0xb4,  0x00,  0xd4,  0x01,  0x0c,  0x1c,  0x3e,  0x1c,  0x3c,  0x00,  0xbb,  0x00,
+  0x00,  0x10,  0xba,  0x19,  0x02,  0x80,  0x32,  0xf0,  0x7c,  0x0d,  0x02,  0x13,  0xba,  0x13,  0x18,  0x40,
+  0x00,  0x57,  0x01,  0xea,  0x02,  0xfc,  0x03,  0xfc,  0x3e,  0x00,  0x6c,  0x01,  0x6e,  0x01,  0x74,  0x01,
+  0x76,  0x01,  0xb9,  0x54,  0x3e,  0x57,  0x00,  0x80,  0x03,  0xe6,  0xb6,  0x00,  0xc0,  0x00,  0x01,  0x01,
+  0x3e,  0x01,  0x7a,  0x01,  0xca,  0x08,  0xce,  0x10,  0x16,  0x11,  0x04,  0x12,  0x08,  0x12,  0x02,  0x4a,
+  0xbb,  0x55,  0x3c,  0x56,  0x03,  0x58,  0x1b,  0x80,  0x30,  0xe4,  0x4b,  0xe4,  0x5d,  0xf0,  0x02,  0xfa,
+  0x20,  0x00,  0x32,  0x00,  0x40,  0x00,  0x80,  0x00,  0x24,  0x01,  0x3c,  0x01,  0x68,  0x01,  0x6a,  0x01,
+  0x70,  0x01,  0x72,  0x01,  0x78,  0x01,  0x7c,  0x01,  0x62,  0x0a,  0x86,  0x0d,  0x06,  0x13,  0x4c,  0x1c,
+  0x04,  0x80,  0x4a,  0xe4,  0x02,  0xee,  0x5b,  0xf0,  0x03,  0xf7,  0x0c,  0x00,  0x0f,  0x00,  0x47,  0x00,
+  0xbe,  0x00,  0x00,  0x01,  0x20,  0x11,  0x5c,  0x16,  0x32,  0x1c,  0x38,  0x1c,  0x4e,  0x1c,  0x10,  0x44,
+  0x00,  0x4c,  0x04,  0xea,  0x5c,  0xf0,  0xa7,  0xf0,  0x04,  0xf6,  0x03,  0xfa,  0x05,  0x00,  0x34,  0x00,
+  0x36,  0x00,  0x98,  0x00,  0xcc,  0x00,  0x20,  0x01,  0x4e,  0x01,  0x4a,  0x0b,  0x42,  0x0c,  0x12,  0x0f,
+  0x0c,  0x10,  0x22,  0x11,  0x0a,  0x12,  0x04,  0x13,  0x30,  0x1c,  0x02,  0x48,  0x00,  0x4e,  0x42,  0x54,
+  0x44,  0x55,  0xbd,  0x56,  0x06,  0x83,  0x00,  0xdc,  0x05,  0xf0,  0x09,  0xf0,  0x59,  0xf0,  0xb8,  0xf0,
+  0x4b,  0xf4,  0x06,  0xf7,  0x0e,  0xf7,  0x04,  0xfc,  0x05,  0xfc,  0x06,  0x00,  0x19,  0x00,  0x33,  0x00,
+  0x9b,  0x00,  0xa4,  0x00,  0xb5,  0x00,  0xba,  0x00,  0xd0,  0x00,  0xe1,  0x00,  0xe7,  0x00,  0xe2,  0x03,
+  0x08,  0x0f,  0x02,  0x10,  0x04,  0x10,  0x0a,  0x10,  0x0a,  0x13,  0x0c,  0x13,  0x12,  0x13,  0x24,  0x14,
+  0x34,  0x14,  0x04,  0x16,  0x08,  0x16,  0xa4,  0x17,  0x20,  0x1c,  0x34,  0x1c,  0x36,  0x1c,  0x08,  0x44,
+  0x38,  0x44,  0x91,  0x44,  0x0a,  0x45,  0x48,  0x46,  0x01,  0x48,  0x68,  0x54,  0x3a,  0x55,  0x83,  0x55,
+  0xe5,  0x55,  0xb0,  0x57,  0x01,  0x58,  0x83,  0x59,  0x05,  0xe6,  0x0b,  0xf0,  0x0c,  0xf0,  0x04,  0xf8,
+  0x05,  0xf8,  0x07,  0x00,  0x0a,  0x00,  0x1c,  0x00,  0x1e,  0x00,  0x9e,  0x00,  0xa8,  0x00,  0xaa,  0x00,
+  0xb9,  0x00,  0xe0,  0x00,  0x22,  0x01,  0x26,  0x01,  0x79,  0x01,  0x7e,  0x01,  0xc4,  0x01,  0xc6,  0x01,
+  0x80,  0x02,  0x5e,  0x03,  0xee,  0x04,  0x9a,  0x06,  0xf8,  0x07,  0x62,  0x08,  0x68,  0x08,  0x69,  0x08,
+  0xd6,  0x08,  0xe9,  0x09,  0xfa,  0x0b,  0x2e,  0x0f,  0x12,  0x10,  0x1a,  0x10,  0xed,  0x10,  0xf1,  0x10,
+  0x2a,  0x11,  0x06,  0x12,  0x0c,  0x12,  0x3e,  0x12,  0x10,  0x13,  0x16,  0x13,  0x1e,  0x13,  0x46,  0x14,
+  0x76,  0x14,  0x82,  0x14,  0x36,  0x15,  0xca,  0x15,  0x6b,  0x18,  0xbe,  0x18,  0xca,  0x18,  0xe6,  0x19,
+  0x12,  0x1c,  0x46,  0x1c,  0x9c,  0x32,  0x00,  0x40,  0x0e,  0x47,  0xfe,  0x9c,  0xf0,  0x2b,  0x02,  0xfe,
+  0xac,  0x0d,  0xff,  0x10,  0x00,  0x00,  0xd7,  0xfe,  0xe8,  0x19,  0x00,  0xd6,  0xfe,  0x84,  0x01,  0xff,
+  0x03,  0x00,  0x00,  0xfe,  0x93,  0x15,  0xfe,  0x0f,  0x05,  0xff,  0x38,  0x00,  0x00,  0xfe,  0x57,  0x24,
+  0x00,  0xfe,  0x4c,  0x00,  0x5b,  0xff,  0x04,  0x00,  0x00,  0x11,  0xff,  0x09,  0x00,  0x00,  0xff,  0x08,
+  0x01,  0x01,  0xff,  0x08,  0xff,  0xff,  0xff,  0x27,  0x00,  0x00,  0xff,  0x10,  0xff,  0xff,  0xff,  0x11,
+  0x00,  0x00,  0xfe,  0x78,  0x56,  0xfe,  0x34,  0x12,  0xff,  0x21,  0x00,  0x00,  0xfe,  0x04,  0xf7,  0xd6,
+  0x2c,  0x99,  0x0a,  0x01,  0xfe,  0xc2,  0x0f,  0xfe,  0x04,  0xf7,  0xd6,  0x99,  0x0a,  0x42,  0x2c,  0xfe,
+  0x3d,  0xf0,  0xfe,  0x06,  0x02,  0xfe,  0x20,  0xf0,  0xa7,  0xfe,  0x91,  0xf0,  0xfe,  0xf4,  0x01,  0xfe,
+  0x90,  0xf0,  0xfe,  0xf4,  0x01,  0xfe,  0x8f,  0xf0,  0xa7,  0x03,  0x5d,  0x4d,  0x02,  0xfe,  0xc8,  0x0d,
+  0x01,  0xfe,  0x38,  0x0e,  0xfe,  0xdd,  0x12,  0xfe,  0xfc,  0x10,  0xfe,  0x28,  0x1c,  0x03,  0xfe,  0xa6,
+  0x00,  0xfe,  0xd3,  0x12,  0x41,  0x14,  0xfe,  0xa6,  0x00,  0xc2,  0xfe,  0x48,  0xf0,  0xfe,  0x8a,  0x02,
+  0xfe,  0x49,  0xf0,  0xfe,  0xa4,  0x02,  0xfe,  0x4a,  0xf0,  0xfe,  0xc2,  0x02,  0xfe,  0x46,  0xf0,  0xfe,
+  0x54,  0x02,  0xfe,  0x47,  0xf0,  0xfe,  0x5a,  0x02,  0xfe,  0x43,  0xf0,  0xfe,  0x48,  0x02,  0xfe,  0x44,
+  0xf0,  0xfe,  0x4c,  0x02,  0xfe,  0x45,  0xf0,  0xfe,  0x50,  0x02,  0x18,  0x0a,  0xaa,  0x18,  0x06,  0x14,
+  0xa1,  0x02,  0x2b,  0xfe,  0x00,  0x1c,  0xe7,  0xfe,  0x02,  0x1c,  0xe6,  0xfe,  0x1e,  0x1c,  0xfe,  0xe9,
+  0x10,  0x01,  0xfe,  0x18,  0x18,  0xfe,  0xe7,  0x10,  0xfe,  0x06,  0xfc,  0xce,  0x09,  0x70,  0x01,  0xa8,
+  0x02,  0x2b,  0x15,  0x59,  0x39,  0xa2,  0x01,  0xfe,  0x58,  0x10,  0x09,  0x70,  0x01,  0x87,  0xfe,  0xbd,
+  0x10,  0x09,  0x70,  0x01,  0x87,  0xfe,  0xad,  0x10,  0xfe,  0x16,  0x1c,  0xfe,  0x58,  0x1c,  0x18,  0x06,
+  0x14,  0xa1,  0x2c,  0x1c,  0x2b,  0xfe,  0x3d,  0xf0,  0xfe,  0x06,  0x02,  0x23,  0xfe,  0x98,  0x02,  0xfe,
+  0x5a,  0x1c,  0xf8,  0xfe,  0x14,  0x1c,  0x15,  0xfe,  0x30,  0x00,  0x39,  0xa2,  0x01,  0xfe,  0x48,  0x10,
+  0x18,  0x06,  0x14,  0xa1,  0x02,  0xd7,  0x22,  0x20,  0x07,  0x11,  0x35,  0xfe,  0x69,  0x10,  0x18,  0x06,
+  0x14,  0xa1,  0xfe,  0x04,  0xec,  0x20,  0x4f,  0x43,  0x13,  0x20,  0xfe,  0x05,  0xf6,  0xce,  0x01,  0xfe,
+  0x4a,  0x17,  0x08,  0x54,  0x58,  0x37,  0x12,  0x2f,  0x42,  0x92,  0x01,  0xfe,  0x82,  0x16,  0x02,  0x2b,
+  0x09,  0x46,  0x01,  0x0e,  0x07,  0x00,  0x66,  0x01,  0x73,  0xfe,  0x18,  0x10,  0xfe,  0x41,  0x58,  0x09,
+  0xa4,  0x01,  0x0e,  0xfe,  0xc8,  0x54,  0x6b,  0xfe,  0x10,  0x03,  0x01,  0xfe,  0x82,  0x16,  0x02,  0x2b,
+  0x2c,  0x4f,  0xfe,  0x02,  0xe8,  0x2a,  0xfe,  0xbf,  0x57,  0xfe,  0x9e,  0x43,  0xfe,  0x77,  0x57,  0xfe,
+  0x27,  0xf0,  0xfe,  0xe0,  0x01,  0xfe,  0x07,  0x4b,  0xfe,  0x20,  0xf0,  0xa7,  0xfe,  0x40,  0x1c,  0x1c,
+  0xd9,  0xfe,  0x26,  0xf0,  0xfe,  0x5a,  0x03,  0xfe,  0xa0,  0xf0,  0xfe,  0x48,  0x03,  0xfe,  0x11,  0xf0,
+  0xa7,  0xfe,  0xef,  0x10,  0xfe,  0x9f,  0xf0,  0xfe,  0x68,  0x03,  0xf9,  0x10,  0xfe,  0x11,  0x00,  0x02,
+  0x65,  0x2c,  0xfe,  0x48,  0x1c,  0xf9,  0x08,  0x05,  0x1b,  0xfe,  0x18,  0x13,  0x21,  0x22,  0xa3,  0xb7,
+  0x13,  0xa3,  0x09,  0x46,  0x01,  0x0e,  0xb7,  0x78,  0x01,  0xfe,  0xb4,  0x16,  0x12,  0xd1,  0x1c,  0xd9,
+  0xfe,  0x01,  0xf0,  0xd9,  0xfe,  0x82,  0xf0,  0xfe,  0x96,  0x03,  0xfa,  0x12,  0xfe,  0xe4,  0x00,  0x27,
+  0xfe,  0xa8,  0x03,  0x1c,  0x34,  0x1d,  0xfe,  0xb8,  0x03,  0x01,  0x4b,  0xfe,  0x06,  0xf0,  0xfe,  0xc8,
+  0x03,  0x95,  0x86,  0xfe,  0x0a,  0xf0,  0xfe,  0x8a,  0x06,  0x02,  0x24,  0x03,  0x70,  0x28,  0x17,  0xfe,
+  0xfa,  0x04,  0x15,  0x6d,  0x01,  0x36,  0x7b,  0xfe,  0x6a,  0x02,  0x02,  0xd8,  0xf9,  0x2c,  0x99,  0x19,
+  0xfe,  0x67,  0x1b,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0xfe,  0x48,  0x1c,  0x74,  0x01,  0xaf,  0x8c,
+  0x09,  0x46,  0x01,  0x0e,  0x07,  0x00,  0x17,  0xda,  0x09,  0xd1,  0x01,  0x0e,  0x8d,  0x51,  0x64,  0x79,
+  0x2a,  0x03,  0x70,  0x28,  0xfe,  0x10,  0x12,  0x15,  0x6d,  0x01,  0x36,  0x7b,  0xfe,  0x6a,  0x02,  0x02,
+  0xd8,  0xc7,  0x81,  0xc8,  0x83,  0x1c,  0x24,  0x27,  0xfe,  0x40,  0x04,  0x1d,  0xfe,  0x3c,  0x04,  0x3b,
+  0xfe,  0xa0,  0x00,  0xfe,  0x9b,  0x57,  0xfe,  0x4e,  0x12,  0x2d,  0xff,  0x02,  0x00,  0x10,  0x01,  0x0b,
+  0x1d,  0xfe,  0xe4,  0x04,  0x2d,  0x01,  0x0b,  0x1d,  0x24,  0x33,  0x31,  0xde,  0xfe,  0x4c,  0x44,  0xfe,
+  0x4c,  0x12,  0x51,  0xfe,  0x44,  0x48,  0x0f,  0x6f,  0xfe,  0x4c,  0x54,  0x6b,  0xda,  0x4f,  0x79,  0x2a,
+  0xfe,  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x62,  0x13,  0x08,  0x05,  0x1b,  0xfe,  0x2a,  0x13,  0x32,
+  0x07,  0x82,  0xfe,  0x52,  0x13,  0xfe,  0x20,  0x10,  0x0f,  0x6f,  0xfe,  0x4c,  0x54,  0x6b,  0xda,  0xfe,
+  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x40,  0x13,  0x08,  0x05,  0x1b,  0xfe,  0x08,  0x13,  0x32,  0x07,
+  0x82,  0xfe,  0x30,  0x13,  0x08,  0x05,  0x1b,  0xfe,  0x1c,  0x12,  0x15,  0x9d,  0x08,  0x05,  0x06,  0x4d,
+  0x15,  0xfe,  0x0d,  0x00,  0x01,  0x36,  0x7b,  0xfe,  0x64,  0x0d,  0x02,  0x24,  0x2d,  0x12,  0xfe,  0xe6,
+  0x00,  0xfe,  0x1c,  0x90,  0xfe,  0x40,  0x5c,  0x04,  0x15,  0x9d,  0x01,  0x36,  0x02,  0x2b,  0xfe,  0x42,
+  0x5b,  0x99,  0x19,  0xfe,  0x46,  0x59,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0xfe,  0x87,  0x80,  0xfe,
+  0x31,  0xe4,  0x5b,  0x08,  0x05,  0x0a,  0xfe,  0x84,  0x13,  0xfe,  0x20,  0x80,  0x07,  0x19,  0xfe,  0x7c,
+  0x12,  0x53,  0x05,  0x06,  0xfe,  0x6c,  0x13,  0x03,  0xfe,  0xa2,  0x00,  0x28,  0x17,  0xfe,  0x90,  0x05,
+  0xfe,  0x31,  0xe4,  0x5a,  0x53,  0x05,  0x0a,  0xfe,  0x56,  0x13,  0x03,  0xfe,  0xa0,  0x00,  0x28,  0xfe,
+  0x4e,  0x12,  0x67,  0xff,  0x02,  0x00,  0x10,  0x27,  0xfe,  0x48,  0x05,  0x1c,  0x34,  0xfe,  0x89,  0x48,
+  0xff,  0x02,  0x00,  0x10,  0x27,  0xfe,  0x56,  0x05,  0x26,  0xfe,  0xa8,  0x05,  0x12,  0xfe,  0xe3,  0x00,
+  0x21,  0x53,  0xfe,  0x4a,  0xf0,  0xfe,  0x76,  0x05,  0xfe,  0x49,  0xf0,  0xfe,  0x70,  0x05,  0x88,  0x25,
+  0xfe,  0x21,  0x00,  0xab,  0x25,  0xfe,  0x22,  0x00,  0xaa,  0x25,  0x58,  0xfe,  0x09,  0x48,  0xff,  0x02,
+  0x00,  0x10,  0x27,  0xfe,  0x86,  0x05,  0x26,  0xfe,  0xa8,  0x05,  0xfe,  0xe2,  0x08,  0x53,  0x05,  0xcb,
+  0x4d,  0x01,  0xb0,  0x25,  0x06,  0x13,  0xd3,  0x39,  0xfe,  0x27,  0x01,  0x08,  0x05,  0x1b,  0xfe,  0x22,
+  0x12,  0x41,  0x01,  0xb2,  0x15,  0x9d,  0x08,  0x05,  0x06,  0x4d,  0x15,  0xfe,  0x0d,  0x00,  0x01,  0x36,
+  0x7b,  0xfe,  0x64,  0x0d,  0x02,  0x24,  0x03,  0xfe,  0x9c,  0x00,  0x28,  0xeb,  0x03,  0x5c,  0x28,  0xfe,
+  0x36,  0x13,  0x41,  0x01,  0xb2,  0x26,  0xfe,  0x18,  0x06,  0x09,  0x06,  0x53,  0x05,  0x1f,  0xfe,  0x02,
+  0x12,  0x50,  0x01,  0xfe,  0x9e,  0x15,  0x1d,  0xfe,  0x0e,  0x06,  0x12,  0xa5,  0x01,  0x4b,  0x12,  0xfe,
+  0xe5,  0x00,  0x03,  0x5c,  0xc1,  0x0c,  0x5c,  0x03,  0xcd,  0x28,  0xfe,  0x62,  0x12,  0x03,  0x45,  0x28,
+  0xfe,  0x5a,  0x13,  0x01,  0xfe,  0x0c,  0x19,  0x01,  0xfe,  0x76,  0x19,  0xfe,  0x43,  0x48,  0xc4,  0xcc,
+  0x0f,  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,  0x93,  0x1e,  0x43,  0x8b,  0xc4,  0x6e,  0x41,  0x01,  0xb2,
+  0x26,  0xfe,  0x82,  0x06,  0x53,  0x05,  0x1a,  0xe9,  0x91,  0x09,  0x59,  0x01,  0xfe,  0xcc,  0x15,  0x1d,
+  0xfe,  0x78,  0x06,  0x12,  0xa5,  0x01,  0x4b,  0x12,  0xfe,  0xe5,  0x00,  0x03,  0x45,  0xc1,  0x0c,  0x45,
+  0x18,  0x06,  0x01,  0xb2,  0xfa,  0x76,  0x74,  0x01,  0xaf,  0x8c,  0x12,  0xfe,  0xe2,  0x00,  0x27,  0xdb,
+  0x1c,  0x34,  0xfe,  0x0a,  0xf0,  0xfe,  0xb6,  0x06,  0x94,  0xfe,  0x6c,  0x07,  0xfe,  0x06,  0xf0,  0xfe,
+  0x74,  0x07,  0x95,  0x86,  0x02,  0x24,  0x08,  0x05,  0x0a,  0xfe,  0x2e,  0x12,  0x16,  0x19,  0x01,  0x0b,
+  0x16,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,  0x0b,  0xfe,  0x99,  0xa4,  0x01,
+  0x0b,  0x16,  0x00,  0x02,  0xfe,  0x42,  0x08,  0x68,  0x05,  0x1a,  0xfe,  0x38,  0x12,  0x08,  0x05,  0x1a,
+  0xfe,  0x30,  0x13,  0x16,  0xfe,  0x1b,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,  0x0b,  0x16,  0x00,  0x01,
+  0x0b,  0x16,  0x00,  0x01,  0x0b,  0x16,  0x06,  0x01,  0x0b,  0x16,  0x00,  0x02,  0xe2,  0x6c,  0x58,  0xbe,
+  0x50,  0xfe,  0x9a,  0x81,  0x55,  0x1b,  0x7a,  0xfe,  0x42,  0x07,  0x09,  0x1b,  0xfe,  0x09,  0x6f,  0xba,
+  0xfe,  0xca,  0x45,  0xfe,  0x32,  0x12,  0x69,  0x6d,  0x8b,  0x6c,  0x7f,  0x27,  0xfe,  0x54,  0x07,  0x1c,
+  0x34,  0xfe,  0x0a,  0xf0,  0xfe,  0x42,  0x07,  0x95,  0x86,  0x94,  0xfe,  0x6c,  0x07,  0x02,  0x24,  0x01,
+  0x4b,  0x02,  0xdb,  0x16,  0x1f,  0x02,  0xdb,  0xfe,  0x9c,  0xf7,  0xdc,  0xfe,  0x2c,  0x90,  0xfe,  0xae,
+  0x90,  0x56,  0xfe,  0xda,  0x07,  0x0c,  0x60,  0x14,  0x61,  0x08,  0x54,  0x5a,  0x37,  0x22,  0x20,  0x07,
+  0x11,  0xfe,  0x0e,  0x12,  0x8d,  0xfe,  0x80,  0x80,  0x39,  0x20,  0x6a,  0x2a,  0xfe,  0x06,  0x10,  0xfe,
+  0x83,  0xe7,  0xfe,  0x48,  0x00,  0xab,  0xfe,  0x03,  0x40,  0x08,  0x54,  0x5b,  0x37,  0x01,  0xb3,  0xb8,
+  0xfe,  0x1f,  0x40,  0x13,  0x62,  0x01,  0xef,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0xfe,  0x44,  0x51,
+  0xfe,  0xc6,  0x51,  0x88,  0xfe,  0x08,  0x90,  0xfe,  0x8a,  0x90,  0x0c,  0x5e,  0x14,  0x5f,  0xfe,  0x0c,
+  0x90,  0xfe,  0x8e,  0x90,  0xfe,  0x40,  0x50,  0xfe,  0xc2,  0x50,  0x0c,  0x3d,  0x14,  0x3e,  0xfe,  0x4a,
+  0x10,  0x08,  0x05,  0x5a,  0xfe,  0x2a,  0x12,  0xfe,  0x2c,  0x90,  0xfe,  0xae,  0x90,  0x0c,  0x60,  0x14,
+  0x61,  0x08,  0x05,  0x5b,  0x8b,  0x01,  0xb3,  0xfe,  0x1f,  0x80,  0x13,  0x62,  0xfe,  0x44,  0x90,  0xfe,
+  0xc6,  0x90,  0x0c,  0x3f,  0x14,  0x40,  0xfe,  0x08,  0x90,  0xfe,  0x8a,  0x90,  0x0c,  0x5e,  0x14,  0x5f,
+  0xfe,  0x40,  0x90,  0xfe,  0xc2,  0x90,  0x0c,  0x3d,  0x14,  0x3e,  0x0c,  0x2e,  0x14,  0x3c,  0x21,  0x0c,
+  0x49,  0x0c,  0x63,  0x08,  0x54,  0x1f,  0x37,  0x2c,  0x0f,  0xfe,  0x4e,  0x11,  0x27,  0xdd,  0xfe,  0x9e,
+  0xf0,  0xfe,  0x76,  0x08,  0xbc,  0x17,  0x34,  0x2c,  0x77,  0xe6,  0xc5,  0xfe,  0x9a,  0x08,  0xc6,  0xfe,
+  0xb8,  0x08,  0x94,  0xfe,  0x8e,  0x08,  0xfe,  0x06,  0xf0,  0xfe,  0x94,  0x08,  0x95,  0x86,  0x02,  0x24,
+  0x01,  0x4b,  0xfe,  0xc9,  0x10,  0x16,  0x1f,  0xfe,  0xc9,  0x10,  0x68,  0x05,  0x06,  0xfe,  0x10,  0x12,
+  0x68,  0x05,  0x0a,  0x4e,  0x08,  0x05,  0x0a,  0xfe,  0x90,  0x12,  0xfe,  0x2e,  0x1c,  0x02,  0xfe,  0x18,
+  0x0b,  0x68,  0x05,  0x06,  0x4e,  0x68,  0x05,  0x0a,  0xfe,  0x7a,  0x12,  0xfe,  0x2c,  0x1c,  0xfe,  0xaa,
+  0xf0,  0xfe,  0xd2,  0x09,  0xfe,  0xac,  0xf0,  0xfe,  0x00,  0x09,  0x02,  0xfe,  0xde,  0x09,  0xfe,  0xb7,
+  0xf0,  0xfe,  0xfc,  0x08,  0xfe,  0x02,  0xf6,  0x1a,  0x50,  0xfe,  0x70,  0x18,  0xfe,  0xf1,  0x18,  0xfe,
+  0x40,  0x55,  0xfe,  0xe1,  0x55,  0xfe,  0x10,  0x58,  0xfe,  0x91,  0x58,  0xfe,  0x14,  0x59,  0xfe,  0x95,
+  0x59,  0x1c,  0x85,  0xfe,  0x8c,  0xf0,  0xfe,  0xfc,  0x08,  0xfe,  0xac,  0xf0,  0xfe,  0xf0,  0x08,  0xb5,
+  0xfe,  0xcb,  0x10,  0xfe,  0xad,  0xf0,  0xfe,  0x0c,  0x09,  0x02,  0xfe,  0x18,  0x0b,  0xb6,  0xfe,  0xbf,
+  0x10,  0xfe,  0x2b,  0xf0,  0x85,  0xf4,  0x1e,  0xfe,  0x00,  0xfe,  0xfe,  0x1c,  0x12,  0xc2,  0xfe,  0xd2,
+  0xf0,  0x85,  0xfe,  0x76,  0x18,  0x1e,  0x19,  0x17,  0x85,  0x03,  0xd2,  0x1e,  0x06,  0x17,  0x85,  0xc5,
+  0x4a,  0xc6,  0x4a,  0xb5,  0xb6,  0xfe,  0x89,  0x10,  0x74,  0x67,  0x2d,  0x15,  0x9d,  0x01,  0x36,  0x10,
+  0xfe,  0x35,  0x00,  0xfe,  0x01,  0xf0,  0x65,  0x10,  0x80,  0x02,  0x65,  0xfe,  0x98,  0x80,  0xfe,  0x19,
+  0xe4,  0x0a,  0xfe,  0x1a,  0x12,  0x51,  0xfe,  0x19,  0x82,  0xfe,  0x6c,  0x18,  0xfe,  0x44,  0x54,  0xbe,
+  0xfe,  0x19,  0x81,  0xfe,  0x74,  0x18,  0x8f,  0x90,  0x17,  0xfe,  0xce,  0x08,  0x02,  0x4a,  0x08,  0x05,
+  0x5a,  0xec,  0x03,  0x2e,  0x29,  0x3c,  0x0c,  0x3f,  0x14,  0x40,  0x9b,  0x2e,  0x9c,  0x3c,  0xfe,  0x6c,
+  0x18,  0xfe,  0xed,  0x18,  0xfe,  0x44,  0x54,  0xfe,  0xe5,  0x54,  0x3a,  0x3f,  0x3b,  0x40,  0x03,  0x49,
+  0x29,  0x63,  0x8f,  0xfe,  0xe3,  0x54,  0xfe,  0x74,  0x18,  0xfe,  0xf5,  0x18,  0x8f,  0xfe,  0xe3,  0x54,
+  0x90,  0xc0,  0x56,  0xfe,  0xce,  0x08,  0x02,  0x4a,  0xfe,  0x37,  0xf0,  0xfe,  0xda,  0x09,  0xfe,  0x8b,
+  0xf0,  0xfe,  0x60,  0x09,  0x02,  0x4a,  0x08,  0x05,  0x0a,  0x23,  0xfe,  0xfa,  0x0a,  0x3a,  0x49,  0x3b,
+  0x63,  0x56,  0xfe,  0x3e,  0x0a,  0x0f,  0xfe,  0xc0,  0x07,  0x41,  0x98,  0x00,  0xad,  0xfe,  0x01,  0x59,
+  0xfe,  0x52,  0xf0,  0xfe,  0x0c,  0x0a,  0x8f,  0x7a,  0xfe,  0x24,  0x0a,  0x3a,  0x49,  0x8f,  0xfe,  0xe3,
+  0x54,  0x57,  0x49,  0x7d,  0x63,  0xfe,  0x14,  0x58,  0xfe,  0x95,  0x58,  0x02,  0x4a,  0x3a,  0x49,  0x3b,
+  0x63,  0xfe,  0x14,  0x59,  0xfe,  0x95,  0x59,  0xbe,  0x57,  0x49,  0x57,  0x63,  0x02,  0x4a,  0x08,  0x05,
+  0x5a,  0xfe,  0x82,  0x12,  0x08,  0x05,  0x1f,  0xfe,  0x66,  0x13,  0x22,  0x62,  0xb7,  0xfe,  0x03,  0xa1,
+  0xfe,  0x83,  0x80,  0xfe,  0xc8,  0x44,  0xfe,  0x2e,  0x13,  0xfe,  0x04,  0x91,  0xfe,  0x86,  0x91,  0x6a,
+  0x2a,  0xfe,  0x40,  0x59,  0xfe,  0xc1,  0x59,  0x56,  0xe0,  0x03,  0x60,  0x29,  0x61,  0x0c,  0x7f,  0x14,
+  0x80,  0x57,  0x60,  0x7d,  0x61,  0x01,  0xb3,  0xb8,  0x6a,  0x2a,  0x13,  0x62,  0x9b,  0x2e,  0x9c,  0x3c,
+  0x3a,  0x3f,  0x3b,  0x40,  0x90,  0xc0,  0xfe,  0x04,  0xfa,  0x2e,  0xfe,  0x05,  0xfa,  0x3c,  0x01,  0xef,
+  0xfe,  0x36,  0x10,  0x21,  0x0c,  0x7f,  0x0c,  0x80,  0x3a,  0x3f,  0x3b,  0x40,  0xe4,  0x08,  0x05,  0x1f,
+  0x17,  0xe0,  0x3a,  0x3d,  0x3b,  0x3e,  0x08,  0x05,  0xfe,  0xf7,  0x00,  0x37,  0x03,  0x5e,  0x29,  0x5f,
+  0xfe,  0x10,  0x58,  0xfe,  0x91,  0x58,  0x57,  0x49,  0x7d,  0x63,  0x02,  0xfe,  0xf4,  0x09,  0x08,  0x05,
+  0x1f,  0x17,  0xe0,  0x08,  0x05,  0xfe,  0xf7,  0x00,  0x37,  0xbe,  0xfe,  0x19,  0x81,  0x50,  0xfe,  0x10,
+  0x90,  0xfe,  0x92,  0x90,  0xfe,  0xd3,  0x10,  0x32,  0x07,  0xa6,  0x17,  0xfe,  0x08,  0x09,  0x12,  0xa6,
+  0x08,  0x05,  0x0a,  0xfe,  0x14,  0x13,  0x03,  0x3d,  0x29,  0x3e,  0x56,  0xfe,  0x08,  0x09,  0xfe,  0x0c,
+  0x58,  0xfe,  0x8d,  0x58,  0x02,  0x4a,  0x21,  0x41,  0xfe,  0x19,  0x80,  0xe7,  0x08,  0x05,  0x0a,  0xfe,
+  0x1a,  0x12,  0xfe,  0x6c,  0x19,  0xfe,  0x19,  0x41,  0xf4,  0xc2,  0xfe,  0xd1,  0xf0,  0xe2,  0x15,  0x7e,
+  0x01,  0x36,  0x10,  0xfe,  0x44,  0x00,  0xfe,  0x8e,  0x10,  0xfe,  0x6c,  0x19,  0x57,  0x3d,  0xfe,  0xed,
+  0x19,  0x7d,  0x3e,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0xf4,  0x1e,  0xfe,  0x00,  0xff,  0x35,  0xfe,
+  0x74,  0x10,  0xc2,  0xfe,  0xd2,  0xf0,  0xfe,  0xa6,  0x0b,  0xfe,  0x76,  0x18,  0x1e,  0x19,  0x8a,  0x03,
+  0xd2,  0x1e,  0x06,  0xfe,  0x08,  0x13,  0x10,  0xfe,  0x16,  0x00,  0x02,  0x65,  0xfe,  0xd1,  0xf0,  0xfe,
+  0xb8,  0x0b,  0x15,  0x7e,  0x01,  0x36,  0x10,  0xfe,  0x17,  0x00,  0xfe,  0x42,  0x10,  0xfe,  0xce,  0xf0,
+  0xfe,  0xbe,  0x0b,  0xfe,  0x3c,  0x10,  0xfe,  0xcd,  0xf0,  0xfe,  0xca,  0x0b,  0x10,  0xfe,  0x22,  0x00,
+  0x02,  0x65,  0xfe,  0xcb,  0xf0,  0xfe,  0xd6,  0x0b,  0x10,  0xfe,  0x24,  0x00,  0x02,  0x65,  0xfe,  0xd0,
+  0xf0,  0xfe,  0xe0,  0x0b,  0x10,  0x9e,  0xe5,  0xfe,  0xcf,  0xf0,  0xfe,  0xea,  0x0b,  0x10,  0x58,  0xfe,
+  0x10,  0x10,  0xfe,  0xcc,  0xf0,  0xe2,  0x68,  0x05,  0x1f,  0x4d,  0x10,  0xfe,  0x12,  0x00,  0x2c,  0x0f,
+  0xfe,  0x4e,  0x11,  0x27,  0xfe,  0x00,  0x0c,  0xfe,  0x9e,  0xf0,  0xfe,  0x14,  0x0c,  0xbc,  0x17,  0x34,
+  0x2c,  0x77,  0xe6,  0xc5,  0x24,  0xc6,  0x24,  0x2c,  0xfa,  0x27,  0xfe,  0x20,  0x0c,  0x1c,  0x34,  0x94,
+  0xfe,  0x3c,  0x0c,  0x95,  0x86,  0xc5,  0xdc,  0xc6,  0xdc,  0x02,  0x24,  0x01,  0x4b,  0xfe,  0xdb,  0x10,
+  0x12,  0xfe,  0xe8,  0x00,  0xb5,  0xb6,  0x74,  0xc7,  0x81,  0xc8,  0x83,  0xfe,  0x89,  0xf0,  0x24,  0x33,
+  0x31,  0xe1,  0xc7,  0x81,  0xc8,  0x83,  0x27,  0xfe,  0x66,  0x0c,  0x1d,  0x24,  0x33,  0x31,  0xdf,  0xbc,
+  0x4e,  0x10,  0xfe,  0x42,  0x00,  0x02,  0x65,  0x7c,  0x06,  0xfe,  0x81,  0x49,  0x17,  0xfe,  0x2c,  0x0d,
+  0x08,  0x05,  0x0a,  0xfe,  0x44,  0x13,  0x10,  0x00,  0x55,  0x0a,  0xfe,  0x54,  0x12,  0x55,  0xfe,  0x28,
+  0x00,  0x23,  0xfe,  0x9a,  0x0d,  0x09,  0x46,  0x01,  0x0e,  0x07,  0x00,  0x66,  0x44,  0xfe,  0x28,  0x00,
+  0xfe,  0xe2,  0x10,  0x01,  0xf5,  0x01,  0xf6,  0x09,  0xa4,  0x01,  0xfe,  0x26,  0x0f,  0x64,  0x12,  0x2f,
+  0x01,  0x73,  0x02,  0x2b,  0x10,  0xfe,  0x44,  0x00,  0x55,  0x0a,  0xe9,  0x44,  0x0a,  0xfe,  0xb4,  0x10,
+  0x01,  0xb0,  0x44,  0x0a,  0xfe,  0xaa,  0x10,  0x01,  0xb0,  0xfe,  0x19,  0x82,  0xfe,  0x34,  0x46,  0xac,
+  0x44,  0x0a,  0x10,  0xfe,  0x43,  0x00,  0xfe,  0x96,  0x10,  0x08,  0x54,  0x0a,  0x37,  0x01,  0xf5,  0x01,
+  0xf6,  0x64,  0x12,  0x2f,  0x01,  0x73,  0x99,  0x0a,  0x64,  0x42,  0x92,  0x02,  0xfe,  0x2e,  0x03,  0x08,
+  0x05,  0x0a,  0x8a,  0x44,  0x0a,  0x10,  0x00,  0xfe,  0x5c,  0x10,  0x68,  0x05,  0x1a,  0xfe,  0x58,  0x12,
+  0x08,  0x05,  0x1a,  0xfe,  0x50,  0x13,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x50,  0x0d,  0xfe,
+  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x56,  0x0d,  0x08,  0x54,  0x1a,  0x37,  0xfe,  0xa9,  0x10,  0x10,
+  0xfe,  0x15,  0x00,  0xfe,  0x04,  0xe6,  0x0a,  0x50,  0xfe,  0x2e,  0x10,  0x10,  0xfe,  0x13,  0x00,  0xfe,
+  0x10,  0x10,  0x10,  0x6f,  0xab,  0x10,  0xfe,  0x41,  0x00,  0xaa,  0x10,  0xfe,  0x24,  0x00,  0x8c,  0xb5,
+  0xb6,  0x74,  0x03,  0x70,  0x28,  0x23,  0xd8,  0x50,  0xfe,  0x04,  0xe6,  0x1a,  0xfe,  0x9d,  0x41,  0xfe,
+  0x1c,  0x42,  0x64,  0x01,  0xe3,  0x02,  0x2b,  0xf8,  0x15,  0x0a,  0x39,  0xa0,  0xb4,  0x15,  0xfe,  0x31,
+  0x00,  0x39,  0xa2,  0x01,  0xfe,  0x48,  0x10,  0x02,  0xd7,  0x42,  0xfe,  0x06,  0xec,  0xd0,  0xfc,  0x44,
+  0x1b,  0xfe,  0xce,  0x45,  0x35,  0x42,  0xfe,  0x06,  0xea,  0xd0,  0xfe,  0x47,  0x4b,  0x91,  0xfe,  0x75,
+  0x57,  0x03,  0x5d,  0xfe,  0x98,  0x56,  0xfe,  0x38,  0x12,  0x09,  0x48,  0x01,  0x0e,  0xfe,  0x44,  0x48,
+  0x4f,  0x08,  0x05,  0x1b,  0xfe,  0x1a,  0x13,  0x09,  0x46,  0x01,  0x0e,  0x41,  0xfe,  0x41,  0x58,  0x09,
+  0xa4,  0x01,  0x0e,  0xfe,  0x49,  0x54,  0x96,  0xfe,  0x1e,  0x0e,  0x02,  0xfe,  0x2e,  0x03,  0x09,  0x5d,
+  0xfe,  0xee,  0x14,  0xfc,  0x44,  0x1b,  0xfe,  0xce,  0x45,  0x35,  0x42,  0xfe,  0xce,  0x47,  0xfe,  0xad,
+  0x13,  0x02,  0x2b,  0x22,  0x20,  0x07,  0x11,  0xfe,  0x9e,  0x12,  0x21,  0x13,  0x59,  0x13,  0x9f,  0x13,
+  0xd5,  0x22,  0x2f,  0x41,  0x39,  0x2f,  0xbc,  0xad,  0xfe,  0xbc,  0xf0,  0xfe,  0xe0,  0x0e,  0x0f,  0x06,
+  0x13,  0x59,  0x01,  0xfe,  0xda,  0x16,  0x03,  0xfe,  0x38,  0x01,  0x29,  0xfe,  0x3a,  0x01,  0x56,  0xfe,
+  0xe4,  0x0e,  0xfe,  0x02,  0xec,  0xd5,  0x69,  0x00,  0x66,  0xfe,  0x04,  0xec,  0x20,  0x4f,  0xfe,  0x05,
+  0xf6,  0xfe,  0x34,  0x01,  0x01,  0xfe,  0x4a,  0x17,  0xfe,  0x08,  0x90,  0xfe,  0x48,  0xf4,  0x0d,  0xfe,
+  0x18,  0x13,  0xba,  0xfe,  0x02,  0xea,  0xd5,  0x69,  0x7e,  0xfe,  0xc5,  0x13,  0x15,  0x1a,  0x39,  0xa0,
+  0xb4,  0xfe,  0x2e,  0x10,  0x03,  0xfe,  0x38,  0x01,  0x1e,  0xfe,  0xf0,  0xff,  0x0c,  0xfe,  0x60,  0x01,
+  0x03,  0xfe,  0x3a,  0x01,  0x0c,  0xfe,  0x62,  0x01,  0x43,  0x13,  0x20,  0x25,  0x06,  0x13,  0x2f,  0x12,
+  0x2f,  0x92,  0x0f,  0x06,  0x04,  0x21,  0x04,  0x22,  0x59,  0xfe,  0xf7,  0x12,  0x22,  0x9f,  0xb7,  0x13,
+  0x9f,  0x07,  0x7e,  0xfe,  0x71,  0x13,  0xfe,  0x24,  0x1c,  0x15,  0x19,  0x39,  0xa0,  0xb4,  0xfe,  0xd9,
+  0x10,  0xc3,  0xfe,  0x03,  0xdc,  0xfe,  0x73,  0x57,  0xfe,  0x80,  0x5d,  0x04,  0xc3,  0xfe,  0x03,  0xdc,
+  0xfe,  0x5b,  0x57,  0xfe,  0x80,  0x5d,  0x04,  0xfe,  0x03,  0x57,  0xc3,  0x21,  0xfe,  0x00,  0xcc,  0x04,
+  0xfe,  0x03,  0x57,  0xc3,  0x78,  0x04,  0x08,  0x05,  0x58,  0xfe,  0x22,  0x13,  0xfe,  0x1c,  0x80,  0x07,
+  0x06,  0xfe,  0x1a,  0x13,  0xfe,  0x1e,  0x80,  0xed,  0xfe,  0x1d,  0x80,  0xae,  0xfe,  0x0c,  0x90,  0xfe,
+  0x0e,  0x13,  0xfe,  0x0e,  0x90,  0xac,  0xfe,  0x3c,  0x90,  0xfe,  0x30,  0xf4,  0x0a,  0xfe,  0x3c,  0x50,
+  0xaa,  0x01,  0xfe,  0x7a,  0x17,  0x32,  0x07,  0x2f,  0xad,  0x01,  0xfe,  0xb4,  0x16,  0x08,  0x05,  0x1b,
+  0x4e,  0x01,  0xf5,  0x01,  0xf6,  0x12,  0xfe,  0xe9,  0x00,  0x08,  0x05,  0x58,  0xfe,  0x2c,  0x13,  0x01,
+  0xfe,  0x0c,  0x17,  0xfe,  0x1e,  0x1c,  0xfe,  0x14,  0x90,  0xfe,  0x96,  0x90,  0x0c,  0xfe,  0x64,  0x01,
+  0x14,  0xfe,  0x66,  0x01,  0x08,  0x05,  0x5b,  0xfe,  0x12,  0x12,  0xfe,  0x03,  0x80,  0x8d,  0xfe,  0x01,
+  0xec,  0x20,  0xfe,  0x80,  0x40,  0x13,  0x20,  0x6a,  0x2a,  0x12,  0xcf,  0x64,  0x22,  0x20,  0xfb,  0x79,
+  0x20,  0x04,  0xfe,  0x08,  0x1c,  0x03,  0xfe,  0xac,  0x00,  0xfe,  0x06,  0x58,  0x03,  0xfe,  0xae,  0x00,
+
+  0xfe,  0x07,  0x58,  0x03,  0xfe,  0xb0,  0x00,  0xfe,  0x08,  0x58,  0x03,  0xfe,  0xb2,  0x00,  0xfe,  0x09,
+  0x58,  0xfe,  0x0a,  0x1c,  0x25,  0x6e,  0x13,  0xd0,  0x21,  0x0c,  0x5c,  0x0c,  0x45,  0x0f,  0x46,  0x52,
+  0x50,  0x18,  0x1b,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x23,  0xfe,  0xfc,  0x0f,  0x44,  0x11,  0x0f,
+  0x48,  0x52,  0x18,  0x58,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x23,  0xe4,  0x25,  0x11,  0x13,  0x20,
+  0x7c,  0x6f,  0x4f,  0x22,  0x20,  0xfb,  0x79,  0x20,  0x12,  0xcf,  0xfe,  0x14,  0x56,  0xfe,  0xd6,  0xf0,
+  0xfe,  0x26,  0x10,  0xf8,  0x74,  0xfe,  0x14,  0x1c,  0xfe,  0x10,  0x1c,  0xfe,  0x18,  0x1c,  0x04,  0x42,
+  0xfe,  0x0c,  0x14,  0xfc,  0xfe,  0x07,  0xe6,  0x1b,  0xfe,  0xce,  0x47,  0xfe,  0xf5,  0x13,  0x04,  0x01,
+  0xb0,  0x7c,  0x6f,  0x4f,  0xfe,  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x42,  0x13,  0x32,  0x07,  0x2f,
+  0xfe,  0x34,  0x13,  0x09,  0x48,  0x01,  0x0e,  0xbb,  0xfe,  0x36,  0x12,  0xfe,  0x41,  0x48,  0xfe,  0x45,
+  0x48,  0x01,  0xf0,  0xfe,  0x00,  0xcc,  0xbb,  0xfe,  0xf3,  0x13,  0x43,  0x78,  0x07,  0x11,  0xac,  0x09,
+  0x84,  0x01,  0x0e,  0xfe,  0x80,  0x5c,  0x01,  0x73,  0xfe,  0x0e,  0x10,  0x07,  0x82,  0x4e,  0xfe,  0x14,
+  0x56,  0xfe,  0xd6,  0xf0,  0xfe,  0x60,  0x10,  0x04,  0xfe,  0x44,  0x58,  0x8d,  0xfe,  0x01,  0xec,  0xa2,
+  0xfe,  0x9e,  0x40,  0xfe,  0x9d,  0xe7,  0x00,  0xfe,  0x9c,  0xe7,  0x1a,  0x79,  0x2a,  0x01,  0xe3,  0xfe,
+  0xdd,  0x10,  0x2c,  0xc7,  0x81,  0xc8,  0x83,  0x33,  0x31,  0xde,  0x07,  0x1a,  0xfe,  0x48,  0x12,  0x07,
+  0x0a,  0xfe,  0x56,  0x12,  0x07,  0x19,  0xfe,  0x30,  0x12,  0x07,  0xc9,  0x17,  0xfe,  0x32,  0x12,  0x07,
+  0xfe,  0x23,  0x00,  0x17,  0xeb,  0x07,  0x06,  0x17,  0xfe,  0x9c,  0x12,  0x07,  0x1f,  0xfe,  0x12,  0x12,
+  0x07,  0x00,  0x17,  0x24,  0x15,  0xc9,  0x01,  0x36,  0xa9,  0x2d,  0x01,  0x0b,  0x94,  0x4b,  0x04,  0x2d,
+  0xdd,  0x09,  0xd1,  0x01,  0xfe,  0x26,  0x0f,  0x12,  0x82,  0x02,  0x2b,  0x2d,  0x32,  0x07,  0xa6,  0xfe,
+  0xd9,  0x13,  0x3a,  0x3d,  0x3b,  0x3e,  0x56,  0xfe,  0xf0,  0x11,  0x08,  0x05,  0x5a,  0xfe,  0x72,  0x12,
+  0x9b,  0x2e,  0x9c,  0x3c,  0x90,  0xc0,  0x96,  0xfe,  0xba,  0x11,  0x22,  0x62,  0xfe,  0x26,  0x13,  0x03,
+  0x7f,  0x29,  0x80,  0x56,  0xfe,  0x76,  0x0d,  0x0c,  0x60,  0x14,  0x61,  0x21,  0x0c,  0x7f,  0x0c,  0x80,
+  0x01,  0xb3,  0x25,  0x6e,  0x77,  0x13,  0x62,  0x01,  0xef,  0x9b,  0x2e,  0x9c,  0x3c,  0xfe,  0x04,  0x55,
+  0xfe,  0xa5,  0x55,  0xfe,  0x04,  0xfa,  0x2e,  0xfe,  0x05,  0xfa,  0x3c,  0xfe,  0x91,  0x10,  0x03,  0x3f,
+  0x29,  0x40,  0xfe,  0x40,  0x56,  0xfe,  0xe1,  0x56,  0x0c,  0x3f,  0x14,  0x40,  0x88,  0x9b,  0x2e,  0x9c,
+  0x3c,  0x90,  0xc0,  0x03,  0x5e,  0x29,  0x5f,  0xfe,  0x00,  0x56,  0xfe,  0xa1,  0x56,  0x0c,  0x5e,  0x14,
+  0x5f,  0x08,  0x05,  0x5a,  0xfe,  0x1e,  0x12,  0x22,  0x62,  0xfe,  0x1f,  0x40,  0x03,  0x60,  0x29,  0x61,
+  0xfe,  0x2c,  0x50,  0xfe,  0xae,  0x50,  0x03,  0x3f,  0x29,  0x40,  0xfe,  0x44,  0x50,  0xfe,  0xc6,  0x50,
+  0x03,  0x5e,  0x29,  0x5f,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0x03,  0x3d,  0x29,  0x3e,  0xfe,  0x40,
+  0x50,  0xfe,  0xc2,  0x50,  0x02,  0x89,  0x25,  0x06,  0x13,  0xd4,  0x02,  0x72,  0x2d,  0x01,  0x0b,  0x1d,
+  0x4c,  0x33,  0x31,  0xde,  0x07,  0x06,  0x23,  0x4c,  0x32,  0x07,  0xa6,  0x23,  0x72,  0x01,  0xaf,  0x1e,
+  0x43,  0x17,  0x4c,  0x08,  0x05,  0x0a,  0xee,  0x3a,  0x3d,  0x3b,  0x3e,  0xfe,  0x0a,  0x55,  0x35,  0xfe,
+  0x8b,  0x55,  0x57,  0x3d,  0x7d,  0x3e,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0x02,  0x72,  0xfe,  0x19,
+  0x81,  0xba,  0xfe,  0x19,  0x41,  0x02,  0x72,  0x2d,  0x01,  0x0b,  0x1c,  0x34,  0x1d,  0xe8,  0x33,  0x31,
+  0xe1,  0x55,  0x19,  0xfe,  0xa6,  0x12,  0x55,  0x0a,  0x4d,  0x02,  0x4c,  0x01,  0x0b,  0x1c,  0x34,  0x1d,
+  0xe8,  0x33,  0x31,  0xdf,  0x07,  0x19,  0x23,  0x4c,  0x01,  0x0b,  0x1d,  0xe8,  0x33,  0x31,  0xfe,  0xe8,
+  0x09,  0xfe,  0xc2,  0x49,  0x51,  0x03,  0xfe,  0x9c,  0x00,  0x28,  0x8a,  0x53,  0x05,  0x1f,  0x35,  0xa9,
+  0xfe,  0xbb,  0x45,  0x55,  0x00,  0x4e,  0x44,  0x06,  0x7c,  0x43,  0xfe,  0xda,  0x14,  0x01,  0xaf,  0x8c,
+  0xfe,  0x4b,  0x45,  0xee,  0x32,  0x07,  0xa5,  0xed,  0x03,  0xcd,  0x28,  0x8a,  0x03,  0x45,  0x28,  0x35,
+  0x67,  0x02,  0x72,  0xfe,  0xc0,  0x5d,  0xfe,  0xf8,  0x14,  0xfe,  0x03,  0x17,  0x03,  0x5c,  0xc1,  0x0c,
+  0x5c,  0x67,  0x2d,  0x01,  0x0b,  0x26,  0x89,  0x01,  0xfe,  0x9e,  0x15,  0x02,  0x89,  0x01,  0x0b,  0x1c,
+  0x34,  0x1d,  0x4c,  0x33,  0x31,  0xdf,  0x07,  0x06,  0x23,  0x4c,  0x01,  0xf1,  0xfe,  0x42,  0x58,  0xf1,
+  0xfe,  0xa4,  0x14,  0x8c,  0xfe,  0x4a,  0xf4,  0x0a,  0x17,  0x4c,  0xfe,  0x4a,  0xf4,  0x06,  0xea,  0x32,
+  0x07,  0xa5,  0x8b,  0x02,  0x72,  0x03,  0x45,  0xc1,  0x0c,  0x45,  0x67,  0x2d,  0x01,  0x0b,  0x26,  0x89,
+  0x01,  0xfe,  0xcc,  0x15,  0x02,  0x89,  0x0f,  0x06,  0x27,  0xfe,  0xbe,  0x13,  0x26,  0xfe,  0xd4,  0x13,
+  0x76,  0xfe,  0x89,  0x48,  0x01,  0x0b,  0x21,  0x76,  0x04,  0x7b,  0xfe,  0xd0,  0x13,  0x1c,  0xfe,  0xd0,
+  0x13,  0x1d,  0xfe,  0xbe,  0x13,  0x67,  0x2d,  0x01,  0x0b,  0xfe,  0xd5,  0x10,  0x0f,  0x71,  0xff,  0x02,
+  0x00,  0x57,  0x52,  0x93,  0x1e,  0xfe,  0xff,  0x7f,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x04,  0x0f,
+  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,  0x93,  0x1e,  0x43,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x04,
+  0x0f,  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,  0x93,  0x04,  0x0f,  0x71,  0xff,  0x02,  0x00,  0x57,  0x52,
+  0x93,  0xfe,  0x0b,  0x58,  0x04,  0x09,  0x5c,  0x01,  0x87,  0x09,  0x45,  0x01,  0x87,  0x04,  0xfe,  0x03,
+  0xa1,  0x1e,  0x11,  0xff,  0x03,  0x00,  0x54,  0xfe,  0x00,  0xf4,  0x1f,  0x52,  0xfe,  0x00,  0x7d,  0xfe,
+  0x01,  0x7d,  0xfe,  0x02,  0x7d,  0xfe,  0x03,  0x7c,  0x6a,  0x2a,  0x0c,  0x5e,  0x14,  0x5f,  0x57,  0x3f,
+  0x7d,  0x40,  0x04,  0xdd,  0xfe,  0x82,  0x4a,  0xfe,  0xe1,  0x1a,  0xfe,  0x83,  0x5a,  0x8d,  0x04,  0x01,
+  0xfe,  0x0c,  0x19,  0xfe,  0x42,  0x48,  0x50,  0x51,  0x91,  0x01,  0x0b,  0x1d,  0xfe,  0x96,  0x15,  0x33,
+  0x31,  0xe1,  0x01,  0x0b,  0x1d,  0xfe,  0x96,  0x15,  0x33,  0x31,  0xfe,  0xe8,  0x0a,  0xfe,  0xc1,  0x59,
+  0x03,  0xcd,  0x28,  0xfe,  0xcc,  0x12,  0x53,  0x05,  0x1a,  0xfe,  0xc4,  0x13,  0x21,  0x69,  0x1a,  0xee,
+  0x55,  0xca,  0x6b,  0xfe,  0xdc,  0x14,  0x4d,  0x0f,  0x06,  0x18,  0xca,  0x7c,  0x30,  0xfe,  0x78,  0x10,
+  0xff,  0x02,  0x83,  0x55,  0xab,  0xff,  0x02,  0x83,  0x55,  0x69,  0x19,  0xae,  0x98,  0xfe,  0x30,  0x00,
+  0x96,  0xf2,  0x18,  0x6d,  0x0f,  0x06,  0xfe,  0x56,  0x10,  0x69,  0x0a,  0xed,  0x98,  0xfe,  0x64,  0x00,
+  0x96,  0xf2,  0x09,  0xfe,  0x64,  0x00,  0x18,  0x9e,  0x0f,  0x06,  0xfe,  0x28,  0x10,  0x69,  0x06,  0xfe,
+  0x60,  0x13,  0x98,  0xfe,  0xc8,  0x00,  0x96,  0xf2,  0x09,  0xfe,  0xc8,  0x00,  0x18,  0x59,  0x0f,  0x06,
+  0x88,  0x98,  0xfe,  0x90,  0x01,  0x7a,  0xfe,  0x42,  0x15,  0x91,  0xe4,  0xfe,  0x43,  0xf4,  0x9f,  0xfe,
+  0x56,  0xf0,  0xfe,  0x54,  0x15,  0xfe,  0x04,  0xf4,  0x71,  0xfe,  0x43,  0xf4,  0x9e,  0xfe,  0xf3,  0x10,
+  0xfe,  0x40,  0x5c,  0x01,  0xfe,  0x16,  0x14,  0x1e,  0x43,  0xec,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,
+  0x6e,  0x7a,  0xfe,  0x90,  0x15,  0xc4,  0x6e,  0xfe,  0x1c,  0x10,  0xfe,  0x00,  0x17,  0xfe,  0x4d,  0xe4,
+  0xcc,  0x7a,  0xfe,  0x90,  0x15,  0xc4,  0xcc,  0x88,  0x51,  0x21,  0xfe,  0x4d,  0xf4,  0x00,  0xe9,  0x91,
+  0x0f,  0x06,  0xfe,  0xb4,  0x56,  0xfe,  0xc3,  0x58,  0x04,  0x51,  0x0f,  0x0a,  0x04,  0x16,  0x06,  0x01,
+  0x0b,  0x26,  0xf3,  0x16,  0x0a,  0x01,  0x0b,  0x26,  0xf3,  0x16,  0x19,  0x01,  0x0b,  0x26,  0xf3,  0x76,
+  0xfe,  0x89,  0x49,  0x01,  0x0b,  0x04,  0x16,  0x06,  0x01,  0x0b,  0x26,  0xb1,  0x16,  0x19,  0x01,  0x0b,
+  0x26,  0xb1,  0x16,  0x06,  0x01,  0x0b,  0x26,  0xb1,  0xfe,  0x89,  0x49,  0x01,  0x0b,  0x26,  0xb1,  0x76,
+  0xfe,  0x89,  0x4a,  0x01,  0x0b,  0x04,  0x51,  0x04,  0x22,  0xd3,  0x07,  0x06,  0xfe,  0x48,  0x13,  0xb8,
+  0x13,  0xd3,  0xfe,  0x49,  0xf4,  0x00,  0x4d,  0x76,  0xa9,  0x67,  0xfe,  0x01,  0xec,  0xfe,  0x27,  0x01,
+  0xfe,  0x89,  0x48,  0xff,  0x02,  0x00,  0x10,  0x27,  0xfe,  0x2e,  0x16,  0x32,  0x07,  0xfe,  0xe3,  0x00,
+  0xfe,  0x20,  0x13,  0x1d,  0xfe,  0x52,  0x16,  0x21,  0x13,  0xd4,  0x01,  0x4b,  0x22,  0xd4,  0x07,  0x06,
+  0x4e,  0x08,  0x54,  0x06,  0x37,  0x04,  0x09,  0x48,  0x01,  0x0e,  0xfb,  0x8e,  0x07,  0x11,  0xae,  0x09,
+  0x84,  0x01,  0x0e,  0x8e,  0x09,  0x5d,  0x01,  0xa8,  0x04,  0x09,  0x84,  0x01,  0x0e,  0x8e,  0xfe,  0x80,
+  0xe7,  0x11,  0x07,  0x11,  0x8a,  0xfe,  0x45,  0x58,  0x01,  0xf0,  0x8e,  0x04,  0x09,  0x48,  0x01,  0x0e,
+  0x8e,  0x09,  0x5d,  0x01,  0xa8,  0x04,  0x09,  0x48,  0x01,  0x0e,  0xfe,  0x80,  0x80,  0xfe,  0x80,  0x4c,
+  0xfe,  0x49,  0xe4,  0x11,  0xae,  0x09,  0x84,  0x01,  0x0e,  0xfe,  0x80,  0x4c,  0x09,  0x5d,  0x01,  0x87,
+  0x04,  0x18,  0x11,  0x75,  0x6c,  0xfe,  0x60,  0x01,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x24,
+  0x1c,  0xfe,  0x1d,  0xf7,  0x1b,  0x97,  0xfe,  0xee,  0x16,  0x01,  0xfe,  0xf4,  0x17,  0xad,  0x9a,  0x1b,
+  0x6c,  0xfe,  0x2c,  0x01,  0xfe,  0x2f,  0x19,  0x04,  0xb9,  0x23,  0xfe,  0xde,  0x16,  0xfe,  0xda,  0x10,
+  0x18,  0x11,  0x75,  0x03,  0xfe,  0x64,  0x01,  0xfe,  0x00,  0xf4,  0x1f,  0xfe,  0x18,  0x58,  0x03,  0xfe,
+  0x66,  0x01,  0xfe,  0x19,  0x58,  0x9a,  0x1f,  0xfe,  0x3c,  0x90,  0xfe,  0x30,  0xf4,  0x06,  0xfe,  0x3c,
+  0x50,  0x6c,  0xfe,  0x38,  0x00,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0x1f,  0x97,  0xfe,  0x38,  0x17,
+  0xfe,  0xb6,  0x14,  0x35,  0x04,  0xb9,  0x23,  0xfe,  0x10,  0x17,  0xfe,  0x9c,  0x10,  0x18,  0x11,  0x75,
+  0xfe,  0x83,  0x5a,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x1d,  0xf7,  0x2e,  0x97,  0xfe,  0x5a,
+  0x17,  0xfe,  0x94,  0x14,  0xec,  0x9a,  0x2e,  0x6c,  0x1a,  0xfe,  0xaf,  0x19,  0xfe,  0x98,  0xe7,  0x00,
+  0x04,  0xb9,  0x23,  0xfe,  0x4e,  0x17,  0xfe,  0x6c,  0x10,  0x18,  0x11,  0x75,  0xfe,  0x30,  0xbc,  0xfe,
+  0xb2,  0xbc,  0x9a,  0xcb,  0x6c,  0x1a,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0xcb,  0x97,  0xfe,  0x92,
+  0x17,  0xfe,  0x5c,  0x14,  0x35,  0x04,  0xb9,  0x23,  0xfe,  0x7e,  0x17,  0xfe,  0x42,  0x10,  0xfe,  0x02,
+  0xf6,  0x11,  0x75,  0xfe,  0x18,  0xfe,  0x60,  0xfe,  0x19,  0xfe,  0x61,  0xfe,  0x03,  0xa1,  0xfe,  0x1d,
+  0xf7,  0x5b,  0x97,  0xfe,  0xb8,  0x17,  0xfe,  0x36,  0x14,  0xfe,  0x1c,  0x13,  0x9a,  0x5b,  0x41,  0xfe,
+  0x83,  0x58,  0xfe,  0xaf,  0x19,  0xfe,  0x80,  0xe7,  0x11,  0xfe,  0x81,  0xe7,  0x11,  0x12,  0xfe,  0xdd,
+  0x00,  0x6a,  0x2a,  0x04,  0x6a,  0x2a,  0xfe,  0x12,  0x45,  0x23,  0xfe,  0xa8,  0x17,  0x15,  0x06,  0x39,
+  0xa0,  0xb4,  0x02,  0x2b,  0xfe,  0x39,  0xf0,  0xfe,  0xfc,  0x17,  0x21,  0x04,  0xfe,  0x7e,  0x18,  0x1e,
+  0x19,  0x66,  0x0f,  0x0d,  0x04,  0x75,  0x03,  0xd2,  0x1e,  0x06,  0xfe,  0xef,  0x12,  0xfe,  0xe1,  0x10,
+  0x7c,  0x6f,  0x4f,  0x32,  0x07,  0x2f,  0xfe,  0x3c,  0x13,  0xf1,  0xfe,  0x42,  0x13,  0x42,  0x92,  0x09,
+  0x48,  0x01,  0x0e,  0xbb,  0xeb,  0xfe,  0x41,  0x48,  0xfe,  0x45,  0x48,  0x01,  0xf0,  0xfe,  0x00,  0xcc,
+  0xbb,  0xfe,  0xf3,  0x13,  0x43,  0x78,  0x07,  0x11,  0xac,  0x09,  0x84,  0x01,  0x0e,  0xfe,  0x80,  0x4c,
+  0x01,  0x73,  0xfe,  0x16,  0x10,  0x07,  0x82,  0x8b,  0xfe,  0x40,  0x14,  0xfe,  0x24,  0x12,  0xfe,  0x14,
+  0x56,  0xfe,  0xd6,  0xf0,  0xfe,  0x1c,  0x18,  0x18,  0x0a,  0x04,  0xfe,  0x9c,  0xe7,  0x0a,  0x10,  0xfe,
+  0x15,  0x00,  0x64,  0x79,  0x2a,  0x01,  0xe3,  0x18,  0x06,  0x04,  0x42,  0x92,  0x08,  0x54,  0x1b,  0x37,
+  0x12,  0x2f,  0x01,  0x73,  0x18,  0x06,  0x04,  0xfe,  0x38,  0x90,  0xfe,  0xba,  0x90,  0x3a,  0xce,  0x3b,
+  0xcf,  0xfe,  0x48,  0x55,  0x35,  0xfe,  0xc9,  0x55,  0x04,  0x22,  0xa3,  0x77,  0x13,  0xa3,  0x04,  0x09,
+  0xa4,  0x01,  0x0e,  0xfe,  0x41,  0x48,  0x09,  0x46,  0x01,  0x0e,  0xfe,  0x49,  0x44,  0x17,  0xfe,  0xe8,
+  0x18,  0x77,  0x78,  0x04,  0x09,  0x48,  0x01,  0x0e,  0x07,  0x11,  0x4e,  0x09,  0x5d,  0x01,  0xa8,  0x09,
+  0x46,  0x01,  0x0e,  0x77,  0x78,  0x04,  0xfe,  0x4e,  0xe4,  0x19,  0x6b,  0xfe,  0x1c,  0x19,  0x03,  0xfe,
+  0x90,  0x00,  0xfe,  0x3a,  0x45,  0xfe,  0x2c,  0x10,  0xfe,  0x4e,  0xe4,  0xc9,  0x6b,  0xfe,  0x2e,  0x19,
+  0x03,  0xfe,  0x92,  0x00,  0xfe,  0x02,  0xe6,  0x1a,  0xe5,  0xfe,  0x4e,  0xe4,  0xfe,  0x0b,  0x00,  0x6b,
+  0xfe,  0x40,  0x19,  0x03,  0xfe,  0x94,  0x00,  0xfe,  0x02,  0xe6,  0x1f,  0xfe,  0x08,  0x10,  0x03,  0xfe,
+  0x96,  0x00,  0xfe,  0x02,  0xe6,  0x6d,  0xfe,  0x4e,  0x45,  0xea,  0xba,  0xff,  0x04,  0x68,  0x54,  0xe7,
+  0x1e,  0x6e,  0xfe,  0x08,  0x1c,  0xfe,  0x67,  0x19,  0xfe,  0x0a,  0x1c,  0xfe,  0x1a,  0xf4,  0xfe,  0x00,
+  0x04,  0xea,  0xfe,  0x48,  0xf4,  0x19,  0x7a,  0xfe,  0x74,  0x19,  0x0f,  0x19,  0x04,  0x07,  0x7e,  0xfe,
+  0x5a,  0xf0,  0xfe,  0x84,  0x19,  0x25,  0xfe,  0x09,  0x00,  0xfe,  0x34,  0x10,  0x07,  0x1a,  0xfe,  0x5a,
+  0xf0,  0xfe,  0x92,  0x19,  0x25,  0xca,  0xfe,  0x26,  0x10,  0x07,  0x19,  0x66,  0x25,  0x6d,  0xe5,  0x07,
+  0x0a,  0x66,  0x25,  0x9e,  0xfe,  0x0e,  0x10,  0x07,  0x06,  0x66,  0x25,  0x59,  0xa9,  0xb8,  0x04,  0x15,
+  0xfe,  0x09,  0x00,  0x01,  0x36,  0xfe,  0x04,  0xfe,  0x81,  0x03,  0x83,  0xfe,  0x40,  0x5c,  0x04,  0x1c,
+  0xf7,  0xfe,  0x14,  0xf0,  0x0b,  0x27,  0xfe,  0xd6,  0x19,  0x1c,  0xf7,  0x7b,  0xf7,  0xfe,  0x82,  0xf0,
+  0xfe,  0xda,  0x19,  0x04,  0xff,  0xcc,  0x00,  0x00,
+};
+
+STATIC unsigned short _adv_asc38C0800_size =
+        sizeof(_adv_asc38C0800_buf); /* 0x14E1 */
+STATIC ADV_DCNT _adv_asc38C0800_chksum =
+        0x050D3FD8UL; /* Expanded little-endian checksum. */
+
+/* Microcode buffer is kept after initialization for error recovery. */
+STATIC unsigned char _adv_asc38C1600_buf[] = {
+  0x00,  0x00,  0x00,  0xf2,  0x00,  0x16,  0x00,  0xfc,  0x00,  0x10,  0x00,  0xf0,  0x18,  0xe4,  0x01,  0x00,
+  0x04,  0x1e,  0x48,  0xe4,  0x03,  0xf6,  0xf7,  0x13,  0x2e,  0x1e,  0x02,  0x00,  0x07,  0x17,  0xc0,  0x5f,
+  0x00,  0xfa,  0xff,  0xff,  0x04,  0x00,  0x00,  0xf6,  0x09,  0xe7,  0x82,  0xe7,  0x85,  0xf0,  0x86,  0xf0,
+  0x4e,  0x10,  0x9e,  0xe7,  0xff,  0x00,  0x55,  0xf0,  0x01,  0xf6,  0x03,  0x00,  0x98,  0x57,  0x01,  0xe6,
+  0x00,  0xea,  0x00,  0xec,  0x01,  0xfa,  0x18,  0xf4,  0x08,  0x00,  0xf0,  0x1d,  0x38,  0x54,  0x32,  0xf0,
+  0x10,  0x00,  0xc2,  0x0e,  0x1e,  0xf0,  0xd5,  0xf0,  0xbc,  0x00,  0x4b,  0xe4,  0x00,  0xe6,  0xb1,  0xf0,
+  0xb4,  0x00,  0x02,  0x13,  0x3e,  0x1c,  0xc8,  0x47,  0x3e,  0x00,  0xd8,  0x01,  0x06,  0x13,  0x0c,  0x1c,
+  0x5e,  0x1e,  0x00,  0x57,  0xc8,  0x57,  0x01,  0xfc,  0xbc,  0x0e,  0xa2,  0x12,  0xb9,  0x54,  0x00,  0x80,
+  0x62,  0x0a,  0x5a,  0x12,  0xc8,  0x15,  0x3e,  0x1e,  0x18,  0x40,  0xbd,  0x56,  0x03,  0xe6,  0x01,  0xea,
+  0x5c,  0xf0,  0x0f,  0x00,  0x20,  0x00,  0x6c,  0x01,  0x6e,  0x01,  0x04,  0x12,  0x04,  0x13,  0xbb,  0x55,
+  0x3c,  0x56,  0x3e,  0x57,  0x03,  0x58,  0x4a,  0xe4,  0x40,  0x00,  0xb6,  0x00,  0xbb,  0x00,  0xc0,  0x00,
+  0x00,  0x01,  0x01,  0x01,  0x3e,  0x01,  0x58,  0x0a,  0x44,  0x10,  0x0a,  0x12,  0x4c,  0x1c,  0x4e,  0x1c,
+  0x02,  0x4a,  0x30,  0xe4,  0x05,  0xe6,  0x0c,  0x00,  0x3c,  0x00,  0x80,  0x00,  0x24,  0x01,  0x3c,  0x01,
+  0x68,  0x01,  0x6a,  0x01,  0x70,  0x01,  0x72,  0x01,  0x74,  0x01,  0x76,  0x01,  0x78,  0x01,  0x7c,  0x01,
+  0xc6,  0x0e,  0x0c,  0x10,  0xac,  0x12,  0xae,  0x12,  0x16,  0x1a,  0x32,  0x1c,  0x6e,  0x1e,  0x02,  0x48,
+  0x3a,  0x55,  0xc9,  0x57,  0x02,  0xee,  0x5b,  0xf0,  0x03,  0xf7,  0x06,  0xf7,  0x03,  0xfc,  0x06,  0x00,
+  0x1e,  0x00,  0xbe,  0x00,  0xe1,  0x00,  0x0c,  0x12,  0x18,  0x1a,  0x70,  0x1a,  0x30,  0x1c,  0x38,  0x1c,
+  0x10,  0x44,  0x00,  0x4c,  0xb0,  0x57,  0x40,  0x5c,  0x4d,  0xe4,  0x04,  0xea,  0x5d,  0xf0,  0xa7,  0xf0,
+  0x04,  0xf6,  0x02,  0xfc,  0x05,  0x00,  0x09,  0x00,  0x19,  0x00,  0x32,  0x00,  0x33,  0x00,  0x34,  0x00,
+  0x36,  0x00,  0x98,  0x00,  0x9e,  0x00,  0xcc,  0x00,  0x20,  0x01,  0x4e,  0x01,  0x79,  0x01,  0x3c,  0x09,
+  0x68,  0x0d,  0x02,  0x10,  0x04,  0x10,  0x3a,  0x10,  0x08,  0x12,  0x0a,  0x13,  0x40,  0x16,  0x50,  0x16,
+  0x00,  0x17,  0x4a,  0x19,  0x00,  0x4e,  0x00,  0x54,  0x01,  0x58,  0x00,  0xdc,  0x05,  0xf0,  0x09,  0xf0,
+  0x59,  0xf0,  0xb8,  0xf0,  0x48,  0xf4,  0x0e,  0xf7,  0x0a,  0x00,  0x9b,  0x00,  0x9c,  0x00,  0xa4,  0x00,
+  0xb5,  0x00,  0xba,  0x00,  0xd0,  0x00,  0xe7,  0x00,  0xf0,  0x03,  0x69,  0x08,  0xe9,  0x09,  0x5c,  0x0c,
+  0xb6,  0x12,  0xbc,  0x19,  0xd8,  0x1b,  0x20,  0x1c,  0x34,  0x1c,  0x36,  0x1c,  0x42,  0x1d,  0x08,  0x44,
+  0x38,  0x44,  0x91,  0x44,  0x0a,  0x45,  0x48,  0x46,  0x89,  0x48,  0x68,  0x54,  0x83,  0x55,  0x83,  0x59,
+  0x31,  0xe4,  0x02,  0xe6,  0x07,  0xf0,  0x08,  0xf0,  0x0b,  0xf0,  0x0c,  0xf0,  0x4b,  0xf4,  0x04,  0xf8,
+  0x05,  0xf8,  0x02,  0xfa,  0x03,  0xfa,  0x04,  0xfc,  0x05,  0xfc,  0x07,  0x00,  0xa8,  0x00,  0xaa,  0x00,
+  0xb9,  0x00,  0xe0,  0x00,  0xe5,  0x00,  0x22,  0x01,  0x26,  0x01,  0x60,  0x01,  0x7a,  0x01,  0x82,  0x01,
+  0xc8,  0x01,  0xca,  0x01,  0x86,  0x02,  0x6a,  0x03,  0x18,  0x05,  0xb2,  0x07,  0x68,  0x08,  0x10,  0x0d,
+  0x06,  0x10,  0x0a,  0x10,  0x0e,  0x10,  0x12,  0x10,  0x60,  0x10,  0xed,  0x10,  0xf3,  0x10,  0x06,  0x12,
+  0x10,  0x12,  0x1e,  0x12,  0x0c,  0x13,  0x0e,  0x13,  0x10,  0x13,  0xfe,  0x9c,  0xf0,  0x35,  0x05,  0xfe,
+  0xec,  0x0e,  0xff,  0x10,  0x00,  0x00,  0xe9,  0xfe,  0x34,  0x1f,  0x00,  0xe8,  0xfe,  0x88,  0x01,  0xff,
+  0x03,  0x00,  0x00,  0xfe,  0x93,  0x15,  0xfe,  0x0f,  0x05,  0xff,  0x38,  0x00,  0x00,  0xfe,  0x57,  0x24,
+  0x00,  0xfe,  0x4c,  0x00,  0x65,  0xff,  0x04,  0x00,  0x00,  0x1a,  0xff,  0x09,  0x00,  0x00,  0xff,  0x08,
+  0x01,  0x01,  0xff,  0x08,  0xff,  0xff,  0xff,  0x27,  0x00,  0x00,  0xff,  0x10,  0xff,  0xff,  0xff,  0x13,
+  0x00,  0x00,  0xfe,  0x78,  0x56,  0xfe,  0x34,  0x12,  0xff,  0x21,  0x00,  0x00,  0xfe,  0x04,  0xf7,  0xe8,
+  0x37,  0x7d,  0x0d,  0x01,  0xfe,  0x4a,  0x11,  0xfe,  0x04,  0xf7,  0xe8,  0x7d,  0x0d,  0x51,  0x37,  0xfe,
+  0x3d,  0xf0,  0xfe,  0x0c,  0x02,  0xfe,  0x20,  0xf0,  0xbc,  0xfe,  0x91,  0xf0,  0xfe,  0xf8,  0x01,  0xfe,
+  0x90,  0xf0,  0xfe,  0xf8,  0x01,  0xfe,  0x8f,  0xf0,  0xbc,  0x03,  0x67,  0x4d,  0x05,  0xfe,  0x08,  0x0f,
+  0x01,  0xfe,  0x78,  0x0f,  0xfe,  0xdd,  0x12,  0x05,  0xfe,  0x0e,  0x03,  0xfe,  0x28,  0x1c,  0x03,  0xfe,
+  0xa6,  0x00,  0xfe,  0xd1,  0x12,  0x3e,  0x22,  0xfe,  0xa6,  0x00,  0xac,  0xfe,  0x48,  0xf0,  0xfe,  0x90,
+  0x02,  0xfe,  0x49,  0xf0,  0xfe,  0xaa,  0x02,  0xfe,  0x4a,  0xf0,  0xfe,  0xc8,  0x02,  0xfe,  0x46,  0xf0,
+  0xfe,  0x5a,  0x02,  0xfe,  0x47,  0xf0,  0xfe,  0x60,  0x02,  0xfe,  0x43,  0xf0,  0xfe,  0x4e,  0x02,  0xfe,
+  0x44,  0xf0,  0xfe,  0x52,  0x02,  0xfe,  0x45,  0xf0,  0xfe,  0x56,  0x02,  0x1c,  0x0d,  0xa2,  0x1c,  0x07,
+  0x22,  0xb7,  0x05,  0x35,  0xfe,  0x00,  0x1c,  0xfe,  0xf1,  0x10,  0xfe,  0x02,  0x1c,  0xf5,  0xfe,  0x1e,
+  0x1c,  0xfe,  0xe9,  0x10,  0x01,  0x5f,  0xfe,  0xe7,  0x10,  0xfe,  0x06,  0xfc,  0xde,  0x0a,  0x81,  0x01,
+  0xa3,  0x05,  0x35,  0x1f,  0x95,  0x47,  0xb8,  0x01,  0xfe,  0xe4,  0x11,  0x0a,  0x81,  0x01,  0x5c,  0xfe,
+  0xbd,  0x10,  0x0a,  0x81,  0x01,  0x5c,  0xfe,  0xad,  0x10,  0xfe,  0x16,  0x1c,  0xfe,  0x58,  0x1c,  0x1c,
+  0x07,  0x22,  0xb7,  0x37,  0x2a,  0x35,  0xfe,  0x3d,  0xf0,  0xfe,  0x0c,  0x02,  0x2b,  0xfe,  0x9e,  0x02,
+  0xfe,  0x5a,  0x1c,  0xfe,  0x12,  0x1c,  0xfe,  0x14,  0x1c,  0x1f,  0xfe,  0x30,  0x00,  0x47,  0xb8,  0x01,
+  0xfe,  0xd4,  0x11,  0x1c,  0x07,  0x22,  0xb7,  0x05,  0xe9,  0x21,  0x2c,  0x09,  0x1a,  0x31,  0xfe,  0x69,
+  0x10,  0x1c,  0x07,  0x22,  0xb7,  0xfe,  0x04,  0xec,  0x2c,  0x60,  0x01,  0xfe,  0x1e,  0x1e,  0x20,  0x2c,
+  0xfe,  0x05,  0xf6,  0xde,  0x01,  0xfe,  0x62,  0x1b,  0x01,  0x0c,  0x61,  0x4a,  0x44,  0x15,  0x56,  0x51,
+  0x01,  0xfe,  0x9e,  0x1e,  0x01,  0xfe,  0x96,  0x1a,  0x05,  0x35,  0x0a,  0x57,  0x01,  0x18,  0x09,  0x00,
+  0x36,  0x01,  0x85,  0xfe,  0x18,  0x10,  0xfe,  0x41,  0x58,  0x0a,  0xba,  0x01,  0x18,  0xfe,  0xc8,  0x54,
+  0x7b,  0xfe,  0x1c,  0x03,  0x01,  0xfe,  0x96,  0x1a,  0x05,  0x35,  0x37,  0x60,  0xfe,  0x02,  0xe8,  0x30,
+  0xfe,  0xbf,  0x57,  0xfe,  0x9e,  0x43,  0xfe,  0x77,  0x57,  0xfe,  0x27,  0xf0,  0xfe,  0xe4,  0x01,  0xfe,
+  0x07,  0x4b,  0xfe,  0x20,  0xf0,  0xbc,  0xfe,  0x40,  0x1c,  0x2a,  0xeb,  0xfe,  0x26,  0xf0,  0xfe,  0x66,
+  0x03,  0xfe,  0xa0,  0xf0,  0xfe,  0x54,  0x03,  0xfe,  0x11,  0xf0,  0xbc,  0xfe,  0xef,  0x10,  0xfe,  0x9f,
+  0xf0,  0xfe,  0x74,  0x03,  0xfe,  0x46,  0x1c,  0x19,  0xfe,  0x11,  0x00,  0x05,  0x70,  0x37,  0xfe,  0x48,
+  0x1c,  0xfe,  0x46,  0x1c,  0x01,  0x0c,  0x06,  0x28,  0xfe,  0x18,  0x13,  0x26,  0x21,  0xb9,  0xc7,  0x20,
+  0xb9,  0x0a,  0x57,  0x01,  0x18,  0xc7,  0x89,  0x01,  0xfe,  0xc8,  0x1a,  0x15,  0xe1,  0x2a,  0xeb,  0xfe,
+  0x01,  0xf0,  0xeb,  0xfe,  0x82,  0xf0,  0xfe,  0xa4,  0x03,  0xfe,  0x9c,  0x32,  0x15,  0xfe,  0xe4,  0x00,
+  0x2f,  0xfe,  0xb6,  0x03,  0x2a,  0x3c,  0x16,  0xfe,  0xc6,  0x03,  0x01,  0x41,  0xfe,  0x06,  0xf0,  0xfe,
+  0xd6,  0x03,  0xaf,  0xa0,  0xfe,  0x0a,  0xf0,  0xfe,  0xa2,  0x07,  0x05,  0x29,  0x03,  0x81,  0x1e,  0x1b,
+  0xfe,  0x24,  0x05,  0x1f,  0x63,  0x01,  0x42,  0x8f,  0xfe,  0x70,  0x02,  0x05,  0xea,  0xfe,  0x46,  0x1c,
+  0x37,  0x7d,  0x1d,  0xfe,  0x67,  0x1b,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0xfe,  0x48,  0x1c,  0x75,
+  0x01,  0xa6,  0x86,  0x0a,  0x57,  0x01,  0x18,  0x09,  0x00,  0x1b,  0xec,  0x0a,  0xe1,  0x01,  0x18,  0x77,
+  0x50,  0x40,  0x8d,  0x30,  0x03,  0x81,  0x1e,  0xf8,  0x1f,  0x63,  0x01,  0x42,  0x8f,  0xfe,  0x70,  0x02,
+  0x05,  0xea,  0xd7,  0x99,  0xd8,  0x9c,  0x2a,  0x29,  0x2f,  0xfe,  0x4e,  0x04,  0x16,  0xfe,  0x4a,  0x04,
+  0x7e,  0xfe,  0xa0,  0x00,  0xfe,  0x9b,  0x57,  0xfe,  0x54,  0x12,  0x32,  0xff,  0x02,  0x00,  0x10,  0x01,
+  0x08,  0x16,  0xfe,  0x02,  0x05,  0x32,  0x01,  0x08,  0x16,  0x29,  0x27,  0x25,  0xee,  0xfe,  0x4c,  0x44,
+  0xfe,  0x58,  0x12,  0x50,  0xfe,  0x44,  0x48,  0x13,  0x34,  0xfe,  0x4c,  0x54,  0x7b,  0xec,  0x60,  0x8d,
+  0x30,  0x01,  0xfe,  0x4e,  0x1e,  0xfe,  0x48,  0x47,  0xfe,  0x7c,  0x13,  0x01,  0x0c,  0x06,  0x28,  0xfe,
+  0x32,  0x13,  0x01,  0x43,  0x09,  0x9b,  0xfe,  0x68,  0x13,  0xfe,  0x26,  0x10,  0x13,  0x34,  0xfe,  0x4c,
+  0x54,  0x7b,  0xec,  0x01,  0xfe,  0x4e,  0x1e,  0xfe,  0x48,  0x47,  0xfe,  0x54,  0x13,  0x01,  0x0c,  0x06,
+  0x28,  0xa5,  0x01,  0x43,  0x09,  0x9b,  0xfe,  0x40,  0x13,  0x01,  0x0c,  0x06,  0x28,  0xf9,  0x1f,  0x7f,
+  0x01,  0x0c,  0x06,  0x07,  0x4d,  0x1f,  0xfe,  0x0d,  0x00,  0x01,  0x42,  0x8f,  0xfe,  0xa4,  0x0e,  0x05,
+  0x29,  0x32,  0x15,  0xfe,  0xe6,  0x00,  0x0f,  0xfe,  0x1c,  0x90,  0x04,  0xfe,  0x9c,  0x93,  0x3a,  0x0b,
+  0x0e,  0x8b,  0x02,  0x1f,  0x7f,  0x01,  0x42,  0x05,  0x35,  0xfe,  0x42,  0x5b,  0x7d,  0x1d,  0xfe,  0x46,
+  0x59,  0xfe,  0xbf,  0x57,  0xfe,  0x77,  0x57,  0x0f,  0xfe,  0x87,  0x80,  0x04,  0xfe,  0x87,  0x83,  0xfe,
+  0xc9,  0x47,  0x0b,  0x0e,  0xd0,  0x65,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x98,  0x13,  0x0f,  0xfe,  0x20,
+  0x80,  0x04,  0xfe,  0xa0,  0x83,  0x33,  0x0b,  0x0e,  0x09,  0x1d,  0xfe,  0x84,  0x12,  0x01,  0x38,  0x06,
+  0x07,  0xfe,  0x70,  0x13,  0x03,  0xfe,  0xa2,  0x00,  0x1e,  0x1b,  0xfe,  0xda,  0x05,  0xd0,  0x54,  0x01,
+  0x38,  0x06,  0x0d,  0xfe,  0x58,  0x13,  0x03,  0xfe,  0xa0,  0x00,  0x1e,  0xfe,  0x50,  0x12,  0x5e,  0xff,
+  0x02,  0x00,  0x10,  0x2f,  0xfe,  0x90,  0x05,  0x2a,  0x3c,  0xcc,  0xff,  0x02,  0x00,  0x10,  0x2f,  0xfe,
+  0x9e,  0x05,  0x17,  0xfe,  0xf4,  0x05,  0x15,  0xfe,  0xe3,  0x00,  0x26,  0x01,  0x38,  0xfe,  0x4a,  0xf0,
+  0xfe,  0xc0,  0x05,  0xfe,  0x49,  0xf0,  0xfe,  0xba,  0x05,  0x71,  0x2e,  0xfe,  0x21,  0x00,  0xf1,  0x2e,
+  0xfe,  0x22,  0x00,  0xa2,  0x2e,  0x4a,  0xfe,  0x09,  0x48,  0xff,  0x02,  0x00,  0x10,  0x2f,  0xfe,  0xd0,
+  0x05,  0x17,  0xfe,  0xf4,  0x05,  0xfe,  0xe2,  0x08,  0x01,  0x38,  0x06,  0xfe,  0x1c,  0x00,  0x4d,  0x01,
+  0xa7,  0x2e,  0x07,  0x20,  0xe4,  0x47,  0xfe,  0x27,  0x01,  0x01,  0x0c,  0x06,  0x28,  0xfe,  0x24,  0x12,
+  0x3e,  0x01,  0x84,  0x1f,  0x7f,  0x01,  0x0c,  0x06,  0x07,  0x4d,  0x1f,  0xfe,  0x0d,  0x00,  0x01,  0x42,
+  0x8f,  0xfe,  0xa4,  0x0e,  0x05,  0x29,  0x03,  0xe6,  0x1e,  0xfe,  0xca,  0x13,  0x03,  0xb6,  0x1e,  0xfe,
+  0x40,  0x12,  0x03,  0x66,  0x1e,  0xfe,  0x38,  0x13,  0x3e,  0x01,  0x84,  0x17,  0xfe,  0x72,  0x06,  0x0a,
+  0x07,  0x01,  0x38,  0x06,  0x24,  0xfe,  0x02,  0x12,  0x4f,  0x01,  0xfe,  0x56,  0x19,  0x16,  0xfe,  0x68,
+  0x06,  0x15,  0x82,  0x01,  0x41,  0x15,  0xe2,  0x03,  0x66,  0x8a,  0x10,  0x66,  0x03,  0x9a,  0x1e,  0xfe,
+  0x70,  0x12,  0x03,  0x55,  0x1e,  0xfe,  0x68,  0x13,  0x01,  0xc6,  0x09,  0x12,  0x48,  0xfe,  0x92,  0x06,
+  0x2e,  0x12,  0x01,  0xfe,  0xac,  0x1d,  0xfe,  0x43,  0x48,  0x62,  0x80,  0x13,  0x58,  0xff,  0x02,  0x00,
+  0x57,  0x52,  0xad,  0x23,  0x3f,  0x4e,  0x62,  0x49,  0x3e,  0x01,  0x84,  0x17,  0xfe,  0xea,  0x06,  0x01,
+  0x38,  0x06,  0x12,  0xf7,  0x45,  0x0a,  0x95,  0x01,  0xfe,  0x84,  0x19,  0x16,  0xfe,  0xe0,  0x06,  0x15,
+  0x82,  0x01,  0x41,  0x15,  0xe2,  0x03,  0x55,  0x8a,  0x10,  0x55,  0x1c,  0x07,  0x01,  0x84,  0xfe,  0xae,
+  0x10,  0x03,  0x6f,  0x1e,  0xfe,  0x9e,  0x13,  0x3e,  0x01,  0x84,  0x03,  0x9a,  0x1e,  0xfe,  0x1a,  0x12,
+  0x01,  0x38,  0x06,  0x12,  0xfc,  0x01,  0xc6,  0x01,  0xfe,  0xac,  0x1d,  0xfe,  0x43,  0x48,  0x62,  0x80,
+  0xf0,  0x45,  0x0a,  0x95,  0x03,  0xb6,  0x1e,  0xf8,  0x01,  0x38,  0x06,  0x24,  0x36,  0xfe,  0x02,  0xf6,
+  0x07,  0x71,  0x78,  0x8c,  0x00,  0x4d,  0x62,  0x49,  0x3e,  0x2d,  0x93,  0x4e,  0xd0,  0x0d,  0x17,  0xfe,
+  0x9a,  0x07,  0x01,  0xfe,  0xc0,  0x19,  0x16,  0xfe,  0x90,  0x07,  0x26,  0x20,  0x9e,  0x15,  0x82,  0x01,
+  0x41,  0x15,  0xe2,  0x21,  0x9e,  0x09,  0x07,  0xfb,  0x03,  0xe6,  0xfe,  0x58,  0x57,  0x10,  0xe6,  0x05,
+  0xfe,  0x2a,  0x06,  0x03,  0x6f,  0x8a,  0x10,  0x6f,  0x1c,  0x07,  0x01,  0x84,  0xfe,  0x9c,  0x32,  0x5f,
+  0x75,  0x01,  0xa6,  0x86,  0x15,  0xfe,  0xe2,  0x00,  0x2f,  0xed,  0x2a,  0x3c,  0xfe,  0x0a,  0xf0,  0xfe,
+  0xce,  0x07,  0xae,  0xfe,  0x96,  0x08,  0xfe,  0x06,  0xf0,  0xfe,  0x9e,  0x08,  0xaf,  0xa0,  0x05,  0x29,
+  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x2e,  0x12,  0x14,  0x1d,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0x14,
+  0x00,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0xfe,  0x99,  0xa4,  0x01,  0x08,  0x14,  0x00,  0x05,  0xfe,
+  0xc6,  0x09,  0x01,  0x76,  0x06,  0x12,  0xfe,  0x3a,  0x12,  0x01,  0x0c,  0x06,  0x12,  0xfe,  0x30,  0x13,
+  0x14,  0xfe,  0x1b,  0x00,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0x14,  0x00,  0x01,  0x08,  0x14,  0x00,
+  0x01,  0x08,  0x14,  0x07,  0x01,  0x08,  0x14,  0x00,  0x05,  0xef,  0x7c,  0x4a,  0x78,  0x4f,  0x0f,  0xfe,
+  0x9a,  0x81,  0x04,  0xfe,  0x9a,  0x83,  0xfe,  0xcb,  0x47,  0x0b,  0x0e,  0x2d,  0x28,  0x48,  0xfe,  0x6c,
+  0x08,  0x0a,  0x28,  0xfe,  0x09,  0x6f,  0xca,  0xfe,  0xca,  0x45,  0xfe,  0x32,  0x12,  0x53,  0x63,  0x4e,
+  0x7c,  0x97,  0x2f,  0xfe,  0x7e,  0x08,  0x2a,  0x3c,  0xfe,  0x0a,  0xf0,  0xfe,  0x6c,  0x08,  0xaf,  0xa0,
+  0xae,  0xfe,  0x96,  0x08,  0x05,  0x29,  0x01,  0x41,  0x05,  0xed,  0x14,  0x24,  0x05,  0xed,  0xfe,  0x9c,
+  0xf7,  0x9f,  0x01,  0xfe,  0xae,  0x1e,  0xfe,  0x18,  0x58,  0x01,  0xfe,  0xbe,  0x1e,  0xfe,  0x99,  0x58,
+  0xfe,  0x78,  0x18,  0xfe,  0xf9,  0x18,  0x8e,  0xfe,  0x16,  0x09,  0x10,  0x6a,  0x22,  0x6b,  0x01,  0x0c,
+  0x61,  0x54,  0x44,  0x21,  0x2c,  0x09,  0x1a,  0xf8,  0x77,  0x01,  0xfe,  0x7e,  0x1e,  0x47,  0x2c,  0x7a,
+  0x30,  0xf0,  0xfe,  0x83,  0xe7,  0xfe,  0x3f,  0x00,  0x71,  0xfe,  0x03,  0x40,  0x01,  0x0c,  0x61,  0x65,
+  0x44,  0x01,  0xc2,  0xc8,  0xfe,  0x1f,  0x40,  0x20,  0x6e,  0x01,  0xfe,  0x6a,  0x16,  0xfe,  0x08,  0x50,
+  0xfe,  0x8a,  0x50,  0xfe,  0x44,  0x51,  0xfe,  0xc6,  0x51,  0xfe,  0x10,  0x10,  0x01,  0xfe,  0xce,  0x1e,
+  0x01,  0xfe,  0xde,  0x1e,  0x10,  0x68,  0x22,  0x69,  0x01,  0xfe,  0xee,  0x1e,  0x01,  0xfe,  0xfe,  0x1e,
+  0xfe,  0x40,  0x50,  0xfe,  0xc2,  0x50,  0x10,  0x4b,  0x22,  0x4c,  0xfe,  0x8a,  0x10,  0x01,  0x0c,  0x06,
+  0x54,  0xfe,  0x50,  0x12,  0x01,  0xfe,  0xae,  0x1e,  0x01,  0xfe,  0xbe,  0x1e,  0x10,  0x6a,  0x22,  0x6b,
+  0x01,  0x0c,  0x06,  0x65,  0x4e,  0x01,  0xc2,  0x0f,  0xfe,  0x1f,  0x80,  0x04,  0xfe,  0x9f,  0x83,  0x33,
+  0x0b,  0x0e,  0x20,  0x6e,  0x0f,  0xfe,  0x44,  0x90,  0x04,  0xfe,  0xc4,  0x93,  0x3a,  0x0b,  0xfe,  0xc6,
+  0x90,  0x04,  0xfe,  0xc6,  0x93,  0x79,  0x0b,  0x0e,  0x10,  0x6c,  0x22,  0x6d,  0x01,  0xfe,  0xce,  0x1e,
+  0x01,  0xfe,  0xde,  0x1e,  0x10,  0x68,  0x22,  0x69,  0x0f,  0xfe,  0x40,  0x90,  0x04,  0xfe,  0xc0,  0x93,
+  0x3a,  0x0b,  0xfe,  0xc2,  0x90,  0x04,  0xfe,  0xc2,  0x93,  0x79,  0x0b,  0x0e,  0x10,  0x4b,  0x22,  0x4c,
+  0x10,  0x64,  0x22,  0x34,  0x01,  0x0c,  0x61,  0x24,  0x44,  0x37,  0x13,  0xfe,  0x4e,  0x11,  0x2f,  0xfe,
+  0xde,  0x09,  0xfe,  0x9e,  0xf0,  0xfe,  0xf2,  0x09,  0xfe,  0x01,  0x48,  0x1b,  0x3c,  0x37,  0x88,  0xf5,
+  0xd4,  0xfe,  0x1e,  0x0a,  0xd5,  0xfe,  0x42,  0x0a,  0xd2,  0xfe,  0x1e,  0x0a,  0xd3,  0xfe,  0x42,  0x0a,
+  0xae,  0xfe,  0x12,  0x0a,  0xfe,  0x06,  0xf0,  0xfe,  0x18,  0x0a,  0xaf,  0xa0,  0x05,  0x29,  0x01,  0x41,
+  0xfe,  0xc1,  0x10,  0x14,  0x24,  0xfe,  0xc1,  0x10,  0x01,  0x76,  0x06,  0x07,  0xfe,  0x14,  0x12,  0x01,
+  0x76,  0x06,  0x0d,  0x5d,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x74,  0x12,  0xfe,  0x2e,  0x1c,  0x05,  0xfe,
+  0x1a,  0x0c,  0x01,  0x76,  0x06,  0x07,  0x5d,  0x01,  0x76,  0x06,  0x0d,  0x41,  0xfe,  0x2c,  0x1c,  0xfe,
+  0xaa,  0xf0,  0xfe,  0xce,  0x0a,  0xfe,  0xac,  0xf0,  0xfe,  0x66,  0x0a,  0xfe,  0x92,  0x10,  0xc4,  0xf6,
+  0xfe,  0xad,  0xf0,  0xfe,  0x72,  0x0a,  0x05,  0xfe,  0x1a,  0x0c,  0xc5,  0xfe,  0xe7,  0x10,  0xfe,  0x2b,
+  0xf0,  0xbf,  0xfe,  0x6b,  0x18,  0x23,  0xfe,  0x00,  0xfe,  0xfe,  0x1c,  0x12,  0xac,  0xfe,  0xd2,  0xf0,
+  0xbf,  0xfe,  0x76,  0x18,  0x23,  0x1d,  0x1b,  0xbf,  0x03,  0xe3,  0x23,  0x07,  0x1b,  0xbf,  0xd4,  0x5b,
+  0xd5,  0x5b,  0xd2,  0x5b,  0xd3,  0x5b,  0xc4,  0xc5,  0xfe,  0xa9,  0x10,  0x75,  0x5e,  0x32,  0x1f,  0x7f,
+  0x01,  0x42,  0x19,  0xfe,  0x35,  0x00,  0xfe,  0x01,  0xf0,  0x70,  0x19,  0x98,  0x05,  0x70,  0xfe,  0x74,
+  0x18,  0x23,  0xfe,  0x00,  0xf8,  0x1b,  0x5b,  0x7d,  0x12,  0x01,  0xfe,  0x78,  0x0f,  0x4d,  0x01,  0xfe,
+  0x96,  0x1a,  0x21,  0x30,  0x77,  0x7d,  0x1d,  0x05,  0x5b,  0x01,  0x0c,  0x06,  0x0d,  0x2b,  0xfe,  0xe2,
+  0x0b,  0x01,  0x0c,  0x06,  0x54,  0xfe,  0xa6,  0x12,  0x01,  0x0c,  0x06,  0x24,  0xfe,  0x88,  0x13,  0x21,
+  0x6e,  0xc7,  0x01,  0xfe,  0x1e,  0x1f,  0x0f,  0xfe,  0x83,  0x80,  0x04,  0xfe,  0x83,  0x83,  0xfe,  0xc9,
+  0x47,  0x0b,  0x0e,  0xfe,  0xc8,  0x44,  0xfe,  0x42,  0x13,  0x0f,  0xfe,  0x04,  0x91,  0x04,  0xfe,  0x84,
+  0x93,  0xfe,  0xca,  0x57,  0x0b,  0xfe,  0x86,  0x91,  0x04,  0xfe,  0x86,  0x93,  0xfe,  0xcb,  0x57,  0x0b,
+  0x0e,  0x7a,  0x30,  0xfe,  0x40,  0x59,  0xfe,  0xc1,  0x59,  0x8e,  0x40,  0x03,  0x6a,  0x3b,  0x6b,  0x10,
+  0x97,  0x22,  0x98,  0xd9,  0x6a,  0xda,  0x6b,  0x01,  0xc2,  0xc8,  0x7a,  0x30,  0x20,  0x6e,  0xdb,  0x64,
+  0xdc,  0x34,  0x91,  0x6c,  0x7e,  0x6d,  0xfe,  0x44,  0x55,  0xfe,  0xe5,  0x55,  0xfe,  0x04,  0xfa,  0x64,
+  0xfe,  0x05,  0xfa,  0x34,  0x01,  0xfe,  0x6a,  0x16,  0xa3,  0x26,  0x10,  0x97,  0x10,  0x98,  0x91,  0x6c,
+  0x7e,  0x6d,  0xfe,  0x14,  0x10,  0x01,  0x0c,  0x06,  0x24,  0x1b,  0x40,  0x91,  0x4b,  0x7e,  0x4c,  0x01,
+  0x0c,  0x06,  0xfe,  0xf7,  0x00,  0x44,  0x03,  0x68,  0x3b,  0x69,  0xfe,  0x10,  0x58,  0xfe,  0x91,  0x58,
+  0xfe,  0x14,  0x59,  0xfe,  0x95,  0x59,  0x05,  0x5b,  0x01,  0x0c,  0x06,  0x24,  0x1b,  0x40,  0x01,  0x0c,
+  0x06,  0xfe,  0xf7,  0x00,  0x44,  0x78,  0x01,  0xfe,  0x8e,  0x1e,  0x4f,  0x0f,  0xfe,  0x10,  0x90,  0x04,
+  0xfe,  0x90,  0x93,  0x3a,  0x0b,  0xfe,  0x92,  0x90,  0x04,  0xfe,  0x92,  0x93,  0x79,  0x0b,  0x0e,  0xfe,
+  0xbd,  0x10,  0x01,  0x43,  0x09,  0xbb,  0x1b,  0xfe,  0x6e,  0x0a,  0x15,  0xbb,  0x01,  0x0c,  0x06,  0x0d,
+  0xfe,  0x14,  0x13,  0x03,  0x4b,  0x3b,  0x4c,  0x8e,  0xfe,  0x6e,  0x0a,  0xfe,  0x0c,  0x58,  0xfe,  0x8d,
+  0x58,  0x05,  0x5b,  0x26,  0x3e,  0x0f,  0xfe,  0x19,  0x80,  0x04,  0xfe,  0x99,  0x83,  0x33,  0x0b,  0x0e,
+  0xfe,  0xe5,  0x10,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x1a,  0x12,  0xfe,  0x6c,  0x19,  0xfe,  0x19,  0x41,
+  0xfe,  0x6b,  0x18,  0xac,  0xfe,  0xd1,  0xf0,  0xef,  0x1f,  0x92,  0x01,  0x42,  0x19,  0xfe,  0x44,  0x00,
+  0xfe,  0x90,  0x10,  0xfe,  0x6c,  0x19,  0xd9,  0x4b,  0xfe,  0xed,  0x19,  0xda,  0x4c,  0xfe,  0x0c,  0x51,
+  0xfe,  0x8e,  0x51,  0xfe,  0x6b,  0x18,  0x23,  0xfe,  0x00,  0xff,  0x31,  0xfe,  0x76,  0x10,  0xac,  0xfe,
+  0xd2,  0xf0,  0xfe,  0xba,  0x0c,  0xfe,  0x76,  0x18,  0x23,  0x1d,  0x5d,  0x03,  0xe3,  0x23,  0x07,  0xfe,
+  0x08,  0x13,  0x19,  0xfe,  0x16,  0x00,  0x05,  0x70,  0xfe,  0xd1,  0xf0,  0xfe,  0xcc,  0x0c,  0x1f,  0x92,
+  0x01,  0x42,  0x19,  0xfe,  0x17,  0x00,  0x5c,  0xfe,  0xce,  0xf0,  0xfe,  0xd2,  0x0c,  0xfe,  0x3e,  0x10,
+  0xfe,  0xcd,  0xf0,  0xfe,  0xde,  0x0c,  0x19,  0xfe,  0x22,  0x00,  0x05,  0x70,  0xfe,  0xcb,  0xf0,  0xfe,
+  0xea,  0x0c,  0x19,  0xfe,  0x24,  0x00,  0x05,  0x70,  0xfe,  0xd0,  0xf0,  0xfe,  0xf4,  0x0c,  0x19,  0x94,
+  0xfe,  0x1c,  0x10,  0xfe,  0xcf,  0xf0,  0xfe,  0xfe,  0x0c,  0x19,  0x4a,  0xf3,  0xfe,  0xcc,  0xf0,  0xef,
+  0x01,  0x76,  0x06,  0x24,  0x4d,  0x19,  0xfe,  0x12,  0x00,  0x37,  0x13,  0xfe,  0x4e,  0x11,  0x2f,  0xfe,
+  0x16,  0x0d,  0xfe,  0x9e,  0xf0,  0xfe,  0x2a,  0x0d,  0xfe,  0x01,  0x48,  0x1b,  0x3c,  0x37,  0x88,  0xf5,
+  0xd4,  0x29,  0xd5,  0x29,  0xd2,  0x29,  0xd3,  0x29,  0x37,  0xfe,  0x9c,  0x32,  0x2f,  0xfe,  0x3e,  0x0d,
+  0x2a,  0x3c,  0xae,  0xfe,  0x62,  0x0d,  0xaf,  0xa0,  0xd4,  0x9f,  0xd5,  0x9f,  0xd2,  0x9f,  0xd3,  0x9f,
+  0x05,  0x29,  0x01,  0x41,  0xfe,  0xd3,  0x10,  0x15,  0xfe,  0xe8,  0x00,  0xc4,  0xc5,  0x75,  0xd7,  0x99,
+  0xd8,  0x9c,  0xfe,  0x89,  0xf0,  0x29,  0x27,  0x25,  0xbe,  0xd7,  0x99,  0xd8,  0x9c,  0x2f,  0xfe,  0x8c,
+  0x0d,  0x16,  0x29,  0x27,  0x25,  0xbd,  0xfe,  0x01,  0x48,  0xa4,  0x19,  0xfe,  0x42,  0x00,  0x05,  0x70,
+  0x90,  0x07,  0xfe,  0x81,  0x49,  0x1b,  0xfe,  0x64,  0x0e,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x44,  0x13,
+  0x19,  0x00,  0x2d,  0x0d,  0xfe,  0x54,  0x12,  0x2d,  0xfe,  0x28,  0x00,  0x2b,  0xfe,  0xda,  0x0e,  0x0a,
+  0x57,  0x01,  0x18,  0x09,  0x00,  0x36,  0x46,  0xfe,  0x28,  0x00,  0xfe,  0xfa,  0x10,  0x01,  0xfe,  0xf4,
+  0x1c,  0x01,  0xfe,  0x00,  0x1d,  0x0a,  0xba,  0x01,  0xfe,  0x58,  0x10,  0x40,  0x15,  0x56,  0x01,  0x85,
+  0x05,  0x35,  0x19,  0xfe,  0x44,  0x00,  0x2d,  0x0d,  0xf7,  0x46,  0x0d,  0xfe,  0xcc,  0x10,  0x01,  0xa7,
+  0x46,  0x0d,  0xfe,  0xc2,  0x10,  0x01,  0xa7,  0x0f,  0xfe,  0x19,  0x82,  0x04,  0xfe,  0x99,  0x83,  0xfe,
+  0xcc,  0x47,  0x0b,  0x0e,  0xfe,  0x34,  0x46,  0xa5,  0x46,  0x0d,  0x19,  0xfe,  0x43,  0x00,  0xfe,  0xa2,
+  0x10,  0x01,  0x0c,  0x61,  0x0d,  0x44,  0x01,  0xfe,  0xf4,  0x1c,  0x01,  0xfe,  0x00,  0x1d,  0x40,  0x15,
+  0x56,  0x01,  0x85,  0x7d,  0x0d,  0x40,  0x51,  0x01,  0xfe,  0x9e,  0x1e,  0x05,  0xfe,  0x3a,  0x03,  0x01,
+  0x0c,  0x06,  0x0d,  0x5d,  0x46,  0x0d,  0x19,  0x00,  0xfe,  0x62,  0x10,  0x01,  0x76,  0x06,  0x12,  0xfe,
+  0x5c,  0x12,  0x01,  0x0c,  0x06,  0x12,  0xfe,  0x52,  0x13,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,
+  0x8e,  0x0e,  0xfe,  0x1c,  0x1c,  0xfe,  0x9d,  0xf0,  0xfe,  0x94,  0x0e,  0x01,  0x0c,  0x61,  0x12,  0x44,
+  0xfe,  0x9f,  0x10,  0x19,  0xfe,  0x15,  0x00,  0xfe,  0x04,  0xe6,  0x0d,  0x4f,  0xfe,  0x2e,  0x10,  0x19,
+  0xfe,  0x13,  0x00,  0xfe,  0x10,  0x10,  0x19,  0xfe,  0x47,  0x00,  0xf1,  0x19,  0xfe,  0x41,  0x00,  0xa2,
+  0x19,  0xfe,  0x24,  0x00,  0x86,  0xc4,  0xc5,  0x75,  0x03,  0x81,  0x1e,  0x2b,  0xea,  0x4f,  0xfe,  0x04,
+  0xe6,  0x12,  0xfe,  0x9d,  0x41,  0xfe,  0x1c,  0x42,  0x40,  0x01,  0xf4,  0x05,  0x35,  0xfe,  0x12,  0x1c,
+  0x1f,  0x0d,  0x47,  0xb5,  0xc3,  0x1f,  0xfe,  0x31,  0x00,  0x47,  0xb8,  0x01,  0xfe,  0xd4,  0x11,  0x05,
+  0xe9,  0x51,  0xfe,  0x06,  0xec,  0xe0,  0xfe,  0x0e,  0x47,  0x46,  0x28,  0xfe,  0xce,  0x45,  0x31,  0x51,
+  0xfe,  0x06,  0xea,  0xe0,  0xfe,  0x47,  0x4b,  0x45,  0xfe,  0x75,  0x57,  0x03,  0x67,  0xfe,  0x98,  0x56,
+  0xfe,  0x38,  0x12,  0x0a,  0x5a,  0x01,  0x18,  0xfe,  0x44,  0x48,  0x60,  0x01,  0x0c,  0x06,  0x28,  0xfe,
+  0x18,  0x13,  0x0a,  0x57,  0x01,  0x18,  0x3e,  0xfe,  0x41,  0x58,  0x0a,  0xba,  0xfe,  0xfa,  0x14,  0xfe,
+  0x49,  0x54,  0xb0,  0xfe,  0x5e,  0x0f,  0x05,  0xfe,  0x3a,  0x03,  0x0a,  0x67,  0xfe,  0xe0,  0x14,  0xfe,
+  0x0e,  0x47,  0x46,  0x28,  0xfe,  0xce,  0x45,  0x31,  0x51,  0xfe,  0xce,  0x47,  0xfe,  0xad,  0x13,  0x05,
+  0x35,  0x21,  0x2c,  0x09,  0x1a,  0xfe,  0x98,  0x12,  0x26,  0x20,  0x96,  0x20,  0xe7,  0xfe,  0x08,  0x1c,
+  0xfe,  0x7c,  0x19,  0xfe,  0xfd,  0x19,  0xfe,  0x0a,  0x1c,  0x03,  0xe5,  0xfe,  0x48,  0x55,  0xa5,  0x3b,
+  0xfe,  0x62,  0x01,  0xfe,  0xc9,  0x55,  0x31,  0xfe,  0x74,  0x10,  0x01,  0xfe,  0xf0,  0x1a,  0x03,  0xfe,
+  0x38,  0x01,  0x3b,  0xfe,  0x3a,  0x01,  0x8e,  0xfe,  0x1e,  0x10,  0xfe,  0x02,  0xec,  0xe7,  0x53,  0x00,
+  0x36,  0xfe,  0x04,  0xec,  0x2c,  0x60,  0xfe,  0x05,  0xf6,  0xfe,  0x34,  0x01,  0x01,  0xfe,  0x62,  0x1b,
+  0x01,  0xfe,  0xce,  0x1e,  0xb2,  0x11,  0xfe,  0x18,  0x13,  0xca,  0xfe,  0x02,  0xea,  0xe7,  0x53,  0x92,
+  0xfe,  0xc3,  0x13,  0x1f,  0x12,  0x47,  0xb5,  0xc3,  0xfe,  0x2a,  0x10,  0x03,  0xfe,  0x38,  0x01,  0x23,
+  0xfe,  0xf0,  0xff,  0x10,  0xe5,  0x03,  0xfe,  0x3a,  0x01,  0x10,  0xfe,  0x62,  0x01,  0x01,  0xfe,  0x1e,
+  0x1e,  0x20,  0x2c,  0x15,  0x56,  0x01,  0xfe,  0x9e,  0x1e,  0x13,  0x07,  0x02,  0x26,  0x02,  0x21,  0x96,
+  0xc7,  0x20,  0x96,  0x09,  0x92,  0xfe,  0x79,  0x13,  0x1f,  0x1d,  0x47,  0xb5,  0xc3,  0xfe,  0xe1,  0x10,
+  0xcf,  0xfe,  0x03,  0xdc,  0xfe,  0x73,  0x57,  0xfe,  0x80,  0x5d,  0x02,  0xcf,  0xfe,  0x03,  0xdc,  0xfe,
+  0x5b,  0x57,  0xfe,  0x80,  0x5d,  0x02,  0xfe,  0x03,  0x57,  0xcf,  0x26,  0xfe,  0x00,  0xcc,  0x02,  0xfe,
+  0x03,  0x57,  0xcf,  0x89,  0x02,  0x01,  0x0c,  0x06,  0x4a,  0xfe,  0x4e,  0x13,  0x0f,  0xfe,  0x1c,  0x80,
+  0x04,  0xfe,  0x9c,  0x83,  0x33,  0x0b,  0x0e,  0x09,  0x07,  0xfe,  0x3a,  0x13,  0x0f,  0xfe,  0x1e,  0x80,
+  0x04,  0xfe,  0x9e,  0x83,  0x33,  0x0b,  0x0e,  0xfe,  0x2a,  0x13,  0x0f,  0xfe,  0x1d,  0x80,  0x04,  0xfe,
+  0x9d,  0x83,  0xfe,  0xf9,  0x13,  0x0e,  0xfe,  0x1c,  0x13,  0x01,  0xfe,  0xee,  0x1e,  0xac,  0xfe,  0x14,
+  0x13,  0x01,  0xfe,  0xfe,  0x1e,  0xfe,  0x81,  0x58,  0xfa,  0x01,  0xfe,  0x0e,  0x1f,  0xfe,  0x30,  0xf4,
+  0x0d,  0xfe,  0x3c,  0x50,  0xa2,  0x01,  0xfe,  0x92,  0x1b,  0x01,  0x43,  0x09,  0x56,  0xfb,  0x01,  0xfe,
+  0xc8,  0x1a,  0x01,  0x0c,  0x06,  0x28,  0xa4,  0x01,  0xfe,  0xf4,  0x1c,  0x01,  0xfe,  0x00,  0x1d,  0x15,
+  0xfe,  0xe9,  0x00,  0x01,  0x0c,  0x06,  0x4a,  0xfe,  0x4e,  0x13,  0x01,  0xfe,  0x22,  0x1b,  0xfe,  0x1e,
+  0x1c,  0x0f,  0xfe,  0x14,  0x90,  0x04,  0xfe,  0x94,  0x93,  0x3a,  0x0b,  0xfe,  0x96,  0x90,  0x04,  0xfe,
+  0x96,  0x93,  0x79,  0x0b,  0x0e,  0x10,  0xfe,  0x64,  0x01,  0x22,  0xfe,  0x66,  0x01,  0x01,  0x0c,  0x06,
+  0x65,  0xf9,  0x0f,  0xfe,  0x03,  0x80,  0x04,  0xfe,  0x83,  0x83,  0x33,  0x0b,  0x0e,  0x77,  0xfe,  0x01,
+  0xec,  0x2c,  0xfe,  0x80,  0x40,  0x20,  0x2c,  0x7a,  0x30,  0x15,  0xdf,  0x40,  0x21,  0x2c,  0xfe,  0x00,
+  0x40,  0x8d,  0x2c,  0x02,  0xfe,  0x08,  0x1c,  0x03,  0xfe,  0xac,  0x00,  0xfe,  0x06,  0x58,  0x03,  0xfe,
+  0xae,  0x00,  0xfe,  0x07,  0x58,  0x03,  0xfe,  0xb0,  0x00,  0xfe,  0x08,  0x58,  0x03,  0xfe,  0xb2,  0x00,
+  0xfe,  0x09,  0x58,  0xfe,  0x0a,  0x1c,  0x2e,  0x49,  0x20,  0xe0,  0x26,  0x10,  0x66,  0x10,  0x55,  0x10,
+  0x6f,  0x13,  0x57,  0x52,  0x4f,  0x1c,  0x28,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x2b,  0xfe,  0x88,
+  0x11,  0x46,  0x1a,  0x13,  0x5a,  0x52,  0x1c,  0x4a,  0xfe,  0x90,  0x4d,  0xfe,  0x91,  0x54,  0x2b,  0xfe,
+  0x9e,  0x11,  0x2e,  0x1a,  0x20,  0x2c,  0x90,  0x34,  0x60,  0x21,  0x2c,  0xfe,  0x00,  0x40,  0x8d,  0x2c,
+  0x15,  0xdf,  0xfe,  0x14,  0x56,  0xfe,  0xd6,  0xf0,  0xfe,  0xb2,  0x11,  0xfe,  0x12,  0x1c,  0x75,  0xfe,
+  0x14,  0x1c,  0xfe,  0x10,  0x1c,  0xfe,  0x18,  0x1c,  0x02,  0x51,  0xfe,  0x0c,  0x14,  0xfe,  0x0e,  0x47,
+  0xfe,  0x07,  0xe6,  0x28,  0xfe,  0xce,  0x47,  0xfe,  0xf5,  0x13,  0x02,  0x01,  0xa7,  0x90,  0x34,  0x60,
+  0xfe,  0x06,  0x80,  0xfe,  0x48,  0x47,  0xfe,  0x42,  0x13,  0xfe,  0x02,  0x80,  0x09,  0x56,  0xfe,  0x34,
+  0x13,  0x0a,  0x5a,  0x01,  0x18,  0xcb,  0xfe,  0x36,  0x12,  0xfe,  0x41,  0x48,  0xfe,  0x45,  0x48,  0x01,
+  0xfe,  0xb2,  0x16,  0xfe,  0x00,  0xcc,  0xcb,  0xfe,  0xf3,  0x13,  0x3f,  0x89,  0x09,  0x1a,  0xa5,  0x0a,
+  0x9d,  0x01,  0x18,  0xfe,  0x80,  0x5c,  0x01,  0x85,  0xf2,  0x09,  0x9b,  0xa4,  0xfe,  0x14,  0x56,  0xfe,
+  0xd6,  0xf0,  0xfe,  0xec,  0x11,  0x02,  0xfe,  0x44,  0x58,  0x77,  0xfe,  0x01,  0xec,  0xb8,  0xfe,  0x9e,
+  0x40,  0xfe,  0x9d,  0xe7,  0x00,  0xfe,  0x9c,  0xe7,  0x12,  0x8d,  0x30,  0x01,  0xf4,  0xfe,  0xdd,  0x10,
+  0x37,  0xd7,  0x99,  0xd8,  0x9c,  0x27,  0x25,  0xee,  0x09,  0x12,  0xfe,  0x48,  0x12,  0x09,  0x0d,  0xfe,
+  0x56,  0x12,  0x09,  0x1d,  0xfe,  0x30,  0x12,  0x09,  0xdd,  0x1b,  0xfe,  0xc4,  0x13,  0x09,  0xfe,  0x23,
+  0x00,  0x1b,  0xfe,  0xd0,  0x13,  0x09,  0x07,  0x1b,  0xfe,  0x34,  0x14,  0x09,  0x24,  0xfe,  0x12,  0x12,
+  0x09,  0x00,  0x1b,  0x29,  0x1f,  0xdd,  0x01,  0x42,  0xa1,  0x32,  0x01,  0x08,  0xae,  0x41,  0x02,  0x32,
+  0xfe,  0x62,  0x08,  0x0a,  0xe1,  0x01,  0xfe,  0x58,  0x10,  0x15,  0x9b,  0x05,  0x35,  0x32,  0x01,  0x43,
+  0x09,  0xbb,  0xfe,  0xd7,  0x13,  0x91,  0x4b,  0x7e,  0x4c,  0x8e,  0xfe,  0x80,  0x13,  0x01,  0x0c,  0x06,
+  0x54,  0xfe,  0x72,  0x12,  0xdb,  0x64,  0xdc,  0x34,  0xfe,  0x44,  0x55,  0xfe,  0xe5,  0x55,  0xb0,  0xfe,
+  0x4a,  0x13,  0x21,  0x6e,  0xfe,  0x26,  0x13,  0x03,  0x97,  0x3b,  0x98,  0x8e,  0xfe,  0xb6,  0x0e,  0x10,
+  0x6a,  0x22,  0x6b,  0x26,  0x10,  0x97,  0x10,  0x98,  0x01,  0xc2,  0x2e,  0x49,  0x88,  0x20,  0x6e,  0x01,
+  0xfe,  0x6a,  0x16,  0xdb,  0x64,  0xdc,  0x34,  0xfe,  0x04,  0x55,  0xfe,  0xa5,  0x55,  0xfe,  0x04,  0xfa,
+  0x64,  0xfe,  0x05,  0xfa,  0x34,  0xfe,  0x8f,  0x10,  0x03,  0x6c,  0x3b,  0x6d,  0xfe,  0x40,  0x56,  0xfe,
+  0xe1,  0x56,  0x10,  0x6c,  0x22,  0x6d,  0x71,  0xdb,  0x64,  0xdc,  0x34,  0xfe,  0x44,  0x55,  0xfe,  0xe5,
+  0x55,  0x03,  0x68,  0x3b,  0x69,  0xfe,  0x00,  0x56,  0xfe,  0xa1,  0x56,  0x10,  0x68,  0x22,  0x69,  0x01,
+  0x0c,  0x06,  0x54,  0xf9,  0x21,  0x6e,  0xfe,  0x1f,  0x40,  0x03,  0x6a,  0x3b,  0x6b,  0xfe,  0x2c,  0x50,
+  0xfe,  0xae,  0x50,  0x03,  0x6c,  0x3b,  0x6d,  0xfe,  0x44,  0x50,  0xfe,  0xc6,  0x50,  0x03,  0x68,  0x3b,
+  0x69,  0xfe,  0x08,  0x50,  0xfe,  0x8a,  0x50,  0x03,  0x4b,  0x3b,  0x4c,  0xfe,  0x40,  0x50,  0xfe,  0xc2,
+  0x50,  0x05,  0x73,  0x2e,  0x07,  0x20,  0x9e,  0x05,  0x72,  0x32,  0x01,  0x08,  0x16,  0x3d,  0x27,  0x25,
+  0xee,  0x09,  0x07,  0x2b,  0x3d,  0x01,  0x43,  0x09,  0xbb,  0x2b,  0x72,  0x01,  0xa6,  0x23,  0x3f,  0x1b,
+  0x3d,  0x01,  0x0c,  0x06,  0x0d,  0xfe,  0x1e,  0x13,  0x91,  0x4b,  0x7e,  0x4c,  0xfe,  0x0a,  0x55,  0x31,
+  0xfe,  0x8b,  0x55,  0xd9,  0x4b,  0xda,  0x4c,  0xfe,  0x0c,  0x51,  0xfe,  0x8e,  0x51,  0x05,  0x72,  0x01,
+  0xfe,  0x8e,  0x1e,  0xca,  0xfe,  0x19,  0x41,  0x05,  0x72,  0x32,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0xc0,
+  0x27,  0x25,  0xbe,  0x2d,  0x1d,  0xc0,  0x2d,  0x0d,  0x83,  0x2d,  0x7f,  0x1b,  0xfe,  0x66,  0x15,  0x05,
+  0x3d,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0xc0,  0x27,  0x25,  0xbd,  0x09,  0x1d,  0x2b,  0x3d,  0x01,  0x08,
+  0x16,  0xc0,  0x27,  0x25,  0xfe,  0xe8,  0x09,  0xfe,  0xc2,  0x49,  0x50,  0x03,  0xb6,  0x1e,  0x83,  0x01,
+  0x38,  0x06,  0x24,  0x31,  0xa1,  0xfe,  0xbb,  0x45,  0x2d,  0x00,  0xa4,  0x46,  0x07,  0x90,  0x3f,  0x01,
+  0xfe,  0xf8,  0x15,  0x01,  0xa6,  0x86,  0xfe,  0x4b,  0x45,  0xfe,  0x20,  0x13,  0x01,  0x43,  0x09,  0x82,
+  0xfe,  0x16,  0x13,  0x03,  0x9a,  0x1e,  0x5d,  0x03,  0x55,  0x1e,  0x31,  0x5e,  0x05,  0x72,  0xfe,  0xc0,
+  0x5d,  0x01,  0xa7,  0xfe,  0x03,  0x17,  0x03,  0x66,  0x8a,  0x10,  0x66,  0x5e,  0x32,  0x01,  0x08,  0x17,
+  0x73,  0x01,  0xfe,  0x56,  0x19,  0x05,  0x73,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0x3d,  0x27,  0x25,  0xbd,
+  0x09,  0x07,  0x2b,  0x3d,  0x01,  0xfe,  0xbe,  0x16,  0xfe,  0x42,  0x58,  0xfe,  0xe8,  0x14,  0x01,  0xa6,
+  0x86,  0xfe,  0x4a,  0xf4,  0x0d,  0x1b,  0x3d,  0xfe,  0x4a,  0xf4,  0x07,  0xfe,  0x0e,  0x12,  0x01,  0x43,
+  0x09,  0x82,  0x4e,  0x05,  0x72,  0x03,  0x55,  0x8a,  0x10,  0x55,  0x5e,  0x32,  0x01,  0x08,  0x17,  0x73,
+  0x01,  0xfe,  0x84,  0x19,  0x05,  0x73,  0x01,  0x08,  0x2a,  0x3c,  0x16,  0x3d,  0x27,  0x25,  0xbd,  0x09,
+  0x12,  0x2b,  0x3d,  0x01,  0xfe,  0xe8,  0x17,  0x8b,  0xfe,  0xaa,  0x14,  0xfe,  0xb6,  0x14,  0x86,  0xa8,
+  0xb2,  0x0d,  0x1b,  0x3d,  0xb2,  0x07,  0xfe,  0x0e,  0x12,  0x01,  0x43,  0x09,  0x82,  0x4e,  0x05,  0x72,
+  0x03,  0x6f,  0x8a,  0x10,  0x6f,  0x5e,  0x32,  0x01,  0x08,  0x17,  0x73,  0x01,  0xfe,  0xc0,  0x19,  0x05,
+  0x73,  0x13,  0x07,  0x2f,  0xfe,  0xcc,  0x15,  0x17,  0xfe,  0xe2,  0x15,  0x5f,  0xcc,  0x01,  0x08,  0x26,
+  0x5f,  0x02,  0x8f,  0xfe,  0xde,  0x15,  0x2a,  0xfe,  0xde,  0x15,  0x16,  0xfe,  0xcc,  0x15,  0x5e,  0x32,
+  0x01,  0x08,  0xfe,  0xd5,  0x10,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,  0xad,  0x23,  0xfe,  0xff,
+  0x7f,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x02,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,  0xad,
+  0x23,  0x3f,  0xfe,  0x30,  0x56,  0xfe,  0x00,  0x5c,  0x02,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,
+  0xad,  0x02,  0x13,  0x58,  0xff,  0x02,  0x00,  0x57,  0x52,  0xfe,  0x00,  0x5e,  0x02,  0x13,  0x58,  0xff,
+  0x02,  0x00,  0x57,  0x52,  0xad,  0xfe,  0x0b,  0x58,  0x02,  0x0a,  0x66,  0x01,  0x5c,  0x0a,  0x55,  0x01,
+  0x5c,  0x0a,  0x6f,  0x01,  0x5c,  0x02,  0x01,  0xfe,  0x1e,  0x1f,  0x23,  0x1a,  0xff,  0x03,  0x00,  0x54,
+  0xfe,  0x00,  0xf4,  0x24,  0x52,  0x0f,  0xfe,  0x00,  0x7c,  0x04,  0xfe,  0x07,  0x7c,  0x3a,  0x0b,  0x0e,
+  0xfe,  0x00,  0x71,  0xfe,  0xf9,  0x18,  0xfe,  0x7a,  0x19,  0xfe,  0xfb,  0x19,  0xfe,  0x1a,  0xf7,  0x00,
+  0xfe,  0x1b,  0xf7,  0x00,  0x7a,  0x30,  0x10,  0x68,  0x22,  0x69,  0xd9,  0x6c,  0xda,  0x6d,  0x02,  0xfe,
+  0x62,  0x08,  0xfe,  0x82,  0x4a,  0xfe,  0xe1,  0x1a,  0xfe,  0x83,  0x5a,  0x77,  0x02,  0x01,  0xc6,  0xfe,
+  0x42,  0x48,  0x4f,  0x50,  0x45,  0x01,  0x08,  0x16,  0xfe,  0xe0,  0x17,  0x27,  0x25,  0xbe,  0x01,  0x08,
+  0x16,  0xfe,  0xe0,  0x17,  0x27,  0x25,  0xfe,  0xe8,  0x0a,  0xfe,  0xc1,  0x59,  0x03,  0x9a,  0x1e,  0xfe,
+  0xda,  0x12,  0x01,  0x38,  0x06,  0x12,  0xfe,  0xd0,  0x13,  0x26,  0x53,  0x12,  0x48,  0xfe,  0x08,  0x17,
+  0xd1,  0x12,  0x53,  0x12,  0xfe,  0x1e,  0x13,  0x2d,  0xb4,  0x7b,  0xfe,  0x26,  0x17,  0x4d,  0x13,  0x07,
+  0x1c,  0xb4,  0x90,  0x04,  0xfe,  0x78,  0x10,  0xff,  0x02,  0x83,  0x55,  0xf1,  0xff,  0x02,  0x83,  0x55,
+  0x53,  0x1d,  0xfe,  0x12,  0x13,  0xd6,  0xfe,  0x30,  0x00,  0xb0,  0xfe,  0x80,  0x17,  0x1c,  0x63,  0x13,
+  0x07,  0xfe,  0x56,  0x10,  0x53,  0x0d,  0xfe,  0x16,  0x13,  0xd6,  0xfe,  0x64,  0x00,  0xb0,  0xfe,  0x80,
+  0x17,  0x0a,  0xfe,  0x64,  0x00,  0x1c,  0x94,  0x13,  0x07,  0xfe,  0x28,  0x10,  0x53,  0x07,  0xfe,  0x60,
+  0x13,  0xd6,  0xfe,  0xc8,  0x00,  0xb0,  0xfe,  0x80,  0x17,  0x0a,  0xfe,  0xc8,  0x00,  0x1c,  0x95,  0x13,
+  0x07,  0x71,  0xd6,  0xfe,  0x90,  0x01,  0x48,  0xfe,  0x8c,  0x17,  0x45,  0xf3,  0xfe,  0x43,  0xf4,  0x96,
+  0xfe,  0x56,  0xf0,  0xfe,  0x9e,  0x17,  0xfe,  0x04,  0xf4,  0x58,  0xfe,  0x43,  0xf4,  0x94,  0xf6,  0x8b,
+  0x01,  0xfe,  0x24,  0x16,  0x23,  0x3f,  0xfc,  0xa8,  0x8c,  0x49,  0x48,  0xfe,  0xda,  0x17,  0x62,  0x49,
+  0xfe,  0x1c,  0x10,  0xa8,  0x8c,  0x80,  0x48,  0xfe,  0xda,  0x17,  0x62,  0x80,  0x71,  0x50,  0x26,  0xfe,
+  0x4d,  0xf4,  0x00,  0xf7,  0x45,  0x13,  0x07,  0xfe,  0xb4,  0x56,  0xfe,  0xc3,  0x58,  0x02,  0x50,  0x13,
+  0x0d,  0x02,  0x50,  0x3e,  0x78,  0x4f,  0x45,  0x01,  0x08,  0x16,  0xa9,  0x27,  0x25,  0xbe,  0xfe,  0x03,
+  0xea,  0xfe,  0x7e,  0x01,  0x01,  0x08,  0x16,  0xa9,  0x27,  0x25,  0xfe,  0xe9,  0x0a,  0x01,  0x08,  0x16,
+  0xa9,  0x27,  0x25,  0xfe,  0xe9,  0x0a,  0xfe,  0x05,  0xea,  0xfe,  0x7f,  0x01,  0x01,  0x08,  0x16,  0xa9,
+  0x27,  0x25,  0xfe,  0x69,  0x09,  0xfe,  0x02,  0xea,  0xfe,  0x80,  0x01,  0x01,  0x08,  0x16,  0xa9,  0x27,
+  0x25,  0xfe,  0xe8,  0x08,  0x47,  0xfe,  0x81,  0x01,  0x03,  0xb6,  0x1e,  0x83,  0x01,  0x38,  0x06,  0x24,
+  0x31,  0xa2,  0x78,  0xf2,  0x53,  0x07,  0x36,  0xfe,  0x34,  0xf4,  0x3f,  0xa1,  0x78,  0x03,  0x9a,  0x1e,
+  0x83,  0x01,  0x38,  0x06,  0x12,  0x31,  0xf0,  0x4f,  0x45,  0xfe,  0x90,  0x10,  0xfe,  0x40,  0x5a,  0x23,
+  0x3f,  0xfb,  0x8c,  0x49,  0x48,  0xfe,  0xaa,  0x18,  0x62,  0x49,  0x71,  0x8c,  0x80,  0x48,  0xfe,  0xaa,
+  0x18,  0x62,  0x80,  0xfe,  0xb4,  0x56,  0xfe,  0x40,  0x5d,  0x01,  0xc6,  0x01,  0xfe,  0xac,  0x1d,  0xfe,
+  0x02,  0x17,  0xfe,  0xc8,  0x45,  0xfe,  0x5a,  0xf0,  0xfe,  0xc0,  0x18,  0xfe,  0x43,  0x48,  0x2d,  0x93,
+  0x36,  0xfe,  0x34,  0xf4,  0xfe,  0x00,  0x11,  0xfe,  0x40,  0x10,  0x2d,  0xb4,  0x36,  0xfe,  0x34,  0xf4,
+  0x04,  0xfe,  0x34,  0x10,  0x2d,  0xfe,  0x0b,  0x00,  0x36,  0x46,  0x63,  0xfe,  0x28,  0x10,  0xfe,  0xc0,
+  0x49,  0xff,  0x02,  0x00,  0x54,  0xb2,  0xfe,  0x90,  0x01,  0x48,  0xfe,  0xfa,  0x18,  0x45,  0xfe,  0x1c,
+  0xf4,  0x3f,  0xf3,  0xfe,  0x40,  0xf4,  0x96,  0xfe,  0x56,  0xf0,  0xfe,  0x0c,  0x19,  0xfe,  0x04,  0xf4,
+  0x58,  0xfe,  0x40,  0xf4,  0x94,  0xf6,  0x3e,  0x2d,  0x93,  0x4e,  0xd0,  0x0d,  0x21,  0xfe,  0x7f,  0x01,
+  0xfe,  0xc8,  0x46,  0xfe,  0x24,  0x13,  0x8c,  0x00,  0x5d,  0x26,  0x21,  0xfe,  0x7e,  0x01,  0xfe,  0xc8,
+  0x45,  0xfe,  0x14,  0x13,  0x21,  0xfe,  0x80,  0x01,  0xfe,  0x48,  0x45,  0xfa,  0x21,  0xfe,  0x81,  0x01,
+  0xfe,  0xc8,  0x44,  0x4e,  0x26,  0x02,  0x13,  0x07,  0x02,  0x78,  0x45,  0x50,  0x13,  0x0d,  0x02,  0x14,
+  0x07,  0x01,  0x08,  0x17,  0xfe,  0x82,  0x19,  0x14,  0x0d,  0x01,  0x08,  0x17,  0xfe,  0x82,  0x19,  0x14,
+  0x1d,  0x01,  0x08,  0x17,  0xfe,  0x82,  0x19,  0x5f,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x02,  0x14,  0x07,
+  0x01,  0x08,  0x17,  0xc1,  0x14,  0x1d,  0x01,  0x08,  0x17,  0xc1,  0x14,  0x07,  0x01,  0x08,  0x17,  0xc1,
+  0xfe,  0x89,  0x49,  0x01,  0x08,  0x17,  0xc1,  0x5f,  0xfe,  0x89,  0x4a,  0x01,  0x08,  0x02,  0x50,  0x02,
+  0x14,  0x07,  0x01,  0x08,  0x17,  0x74,  0x14,  0x7f,  0x01,  0x08,  0x17,  0x74,  0x14,  0x12,  0x01,  0x08,
+  0x17,  0x74,  0xfe,  0x89,  0x49,  0x01,  0x08,  0x17,  0x74,  0x14,  0x00,  0x01,  0x08,  0x17,  0x74,  0xfe,
+  0x89,  0x4a,  0x01,  0x08,  0x17,  0x74,  0xfe,  0x09,  0x49,  0x01,  0x08,  0x17,  0x74,  0x5f,  0xcc,  0x01,
+  0x08,  0x02,  0x21,  0xe4,  0x09,  0x07,  0xfe,  0x4c,  0x13,  0xc8,  0x20,  0xe4,  0xfe,  0x49,  0xf4,  0x00,
+  0x4d,  0x5f,  0xa1,  0x5e,  0xfe,  0x01,  0xec,  0xfe,  0x27,  0x01,  0xcc,  0xff,  0x02,  0x00,  0x10,  0x2f,
+  0xfe,  0x3e,  0x1a,  0x01,  0x43,  0x09,  0xfe,  0xe3,  0x00,  0xfe,  0x22,  0x13,  0x16,  0xfe,  0x64,  0x1a,
+  0x26,  0x20,  0x9e,  0x01,  0x41,  0x21,  0x9e,  0x09,  0x07,  0x5d,  0x01,  0x0c,  0x61,  0x07,  0x44,  0x02,
+  0x0a,  0x5a,  0x01,  0x18,  0xfe,  0x00,  0x40,  0xaa,  0x09,  0x1a,  0xfe,  0x12,  0x13,  0x0a,  0x9d,  0x01,
+  0x18,  0xaa,  0x0a,  0x67,  0x01,  0xa3,  0x02,  0x0a,  0x9d,  0x01,  0x18,  0xaa,  0xfe,  0x80,  0xe7,  0x1a,
+  0x09,  0x1a,  0x5d,  0xfe,  0x45,  0x58,  0x01,  0xfe,  0xb2,  0x16,  0xaa,  0x02,  0x0a,  0x5a,  0x01,  0x18,
+  0xaa,  0x0a,  0x67,  0x01,  0xa3,  0x02,  0x0a,  0x5a,  0x01,  0x18,  0x01,  0xfe,  0x7e,  0x1e,  0xfe,  0x80,
+  0x4c,  0xfe,  0x49,  0xe4,  0x1a,  0xfe,  0x12,  0x13,  0x0a,  0x9d,  0x01,  0x18,  0xfe,  0x80,  0x4c,  0x0a,
+  0x67,  0x01,  0x5c,  0x02,  0x1c,  0x1a,  0x87,  0x7c,  0xe5,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,
+  0x24,  0x1c,  0xfe,  0x1d,  0xf7,  0x28,  0xb1,  0xfe,  0x04,  0x1b,  0x01,  0xfe,  0x2a,  0x1c,  0xfa,  0xb3,
+  0x28,  0x7c,  0xfe,  0x2c,  0x01,  0xfe,  0x2f,  0x19,  0x02,  0xc9,  0x2b,  0xfe,  0xf4,  0x1a,  0xfe,  0xfa,
+  0x10,  0x1c,  0x1a,  0x87,  0x03,  0xfe,  0x64,  0x01,  0xfe,  0x00,  0xf4,  0x24,  0xfe,  0x18,  0x58,  0x03,
+  0xfe,  0x66,  0x01,  0xfe,  0x19,  0x58,  0xb3,  0x24,  0x01,  0xfe,  0x0e,  0x1f,  0xfe,  0x30,  0xf4,  0x07,
+  0xfe,  0x3c,  0x50,  0x7c,  0xfe,  0x38,  0x00,  0xfe,  0x0f,  0x79,  0xfe,  0x1c,  0xf7,  0x24,  0xb1,  0xfe,
+  0x50,  0x1b,  0xfe,  0xd4,  0x14,  0x31,  0x02,  0xc9,  0x2b,  0xfe,  0x26,  0x1b,  0xfe,  0xba,  0x10,  0x1c,
+  0x1a,  0x87,  0xfe,  0x83,  0x5a,  0xfe,  0x18,  0xdf,  0xfe,  0x19,  0xde,  0xfe,  0x1d,  0xf7,  0x54,  0xb1,
+  0xfe,  0x72,  0x1b,  0xfe,  0xb2,  0x14,  0xfc,  0xb3,  0x54,  0x7c,  0x12,  0xfe,  0xaf,  0x19,  0xfe,  0x98,
+  0xe7,  0x00,  0x02,  0xc9,  0x2b,  0xfe,  0x66,  0x1b,  0xfe,  0x8a,  0x10,  0x1c,  0x1a,  0x87,  0x8b,  0x0f,
+  0xfe,  0x30,  0x90,  0x04,  0xfe,  0xb0,  0x93,  0x3a,  0x0b,  0xfe,  0x18,  0x58,  0xfe,  0x32,  0x90,  0x04,
+  0xfe,  0xb2,  0x93,  0x3a,  0x0b,  0xfe,  0x19,  0x58,  0x0e,  0xa8,  0xb3,  0x4a,  0x7c,  0x12,  0xfe,  0x0f,
+  0x79,  0xfe,  0x1c,  0xf7,  0x4a,  0xb1,  0xfe,  0xc6,  0x1b,  0xfe,  0x5e,  0x14,  0x31,  0x02,  0xc9,  0x2b,
+  0xfe,  0x96,  0x1b,  0x5c,  0xfe,  0x02,  0xf6,  0x1a,  0x87,  0xfe,  0x18,  0xfe,  0x6a,  0xfe,  0x19,  0xfe,
+  0x6b,  0x01,  0xfe,  0x1e,  0x1f,  0xfe,  0x1d,  0xf7,  0x65,  0xb1,  0xfe,  0xee,  0x1b,  0xfe,  0x36,  0x14,
+  0xfe,  0x1c,  0x13,  0xb3,  0x65,  0x3e,  0xfe,  0x83,  0x58,  0xfe,  0xaf,  0x19,  0xfe,  0x80,  0xe7,  0x1a,
+  0xfe,  0x81,  0xe7,  0x1a,  0x15,  0xfe,  0xdd,  0x00,  0x7a,  0x30,  0x02,  0x7a,  0x30,  0xfe,  0x12,  0x45,
+  0x2b,  0xfe,  0xdc,  0x1b,  0x1f,  0x07,  0x47,  0xb5,  0xc3,  0x05,  0x35,  0xfe,  0x39,  0xf0,  0x75,  0x26,
+  0x02,  0xfe,  0x7e,  0x18,  0x23,  0x1d,  0x36,  0x13,  0x11,  0x02,  0x87,  0x03,  0xe3,  0x23,  0x07,  0xfe,
+  0xef,  0x12,  0xfe,  0xe1,  0x10,  0x90,  0x34,  0x60,  0xfe,  0x02,  0x80,  0x09,  0x56,  0xfe,  0x3c,  0x13,
+  0xfe,  0x82,  0x14,  0xfe,  0x42,  0x13,  0x51,  0xfe,  0x06,  0x83,  0x0a,  0x5a,  0x01,  0x18,  0xcb,  0xfe,
+  0x3e,  0x12,  0xfe,  0x41,  0x48,  0xfe,  0x45,  0x48,  0x01,  0xfe,  0xb2,  0x16,  0xfe,  0x00,  0xcc,  0xcb,
+  0xfe,  0xf3,  0x13,  0x3f,  0x89,  0x09,  0x1a,  0xa5,  0x0a,  0x9d,  0x01,  0x18,  0xfe,  0x80,  0x4c,  0x01,
+  0x85,  0xfe,  0x16,  0x10,  0x09,  0x9b,  0x4e,  0xfe,  0x40,  0x14,  0xfe,  0x24,  0x12,  0xfe,  0x14,  0x56,
+  0xfe,  0xd6,  0xf0,  0xfe,  0x52,  0x1c,  0x1c,  0x0d,  0x02,  0xfe,  0x9c,  0xe7,  0x0d,  0x19,  0xfe,  0x15,
+  0x00,  0x40,  0x8d,  0x30,  0x01,  0xf4,  0x1c,  0x07,  0x02,  0x51,  0xfe,  0x06,  0x83,  0xfe,  0x18,  0x80,
+  0x61,  0x28,  0x44,  0x15,  0x56,  0x01,  0x85,  0x1c,  0x07,  0x02,  0xfe,  0x38,  0x90,  0xfe,  0xba,  0x90,
+  0x91,  0xde,  0x7e,  0xdf,  0xfe,  0x48,  0x55,  0x31,  0xfe,  0xc9,  0x55,  0x02,  0x21,  0xb9,  0x88,  0x20,
+  0xb9,  0x02,  0x0a,  0xba,  0x01,  0x18,  0xfe,  0x41,  0x48,  0x0a,  0x57,  0x01,  0x18,  0xfe,  0x49,  0x44,
+  0x1b,  0xfe,  0x1e,  0x1d,  0x88,  0x89,  0x02,  0x0a,  0x5a,  0x01,  0x18,  0x09,  0x1a,  0xa4,  0x0a,  0x67,
+  0x01,  0xa3,  0x0a,  0x57,  0x01,  0x18,  0x88,  0x89,  0x02,  0xfe,  0x4e,  0xe4,  0x1d,  0x7b,  0xfe,  0x52,
+  0x1d,  0x03,  0xfe,  0x90,  0x00,  0xfe,  0x3a,  0x45,  0xfe,  0x2c,  0x10,  0xfe,  0x4e,  0xe4,  0xdd,  0x7b,
+  0xfe,  0x64,  0x1d,  0x03,  0xfe,  0x92,  0x00,  0xd1,  0x12,  0xfe,  0x1a,  0x10,  0xfe,  0x4e,  0xe4,  0xfe,
+  0x0b,  0x00,  0x7b,  0xfe,  0x76,  0x1d,  0x03,  0xfe,  0x94,  0x00,  0xd1,  0x24,  0xfe,  0x08,  0x10,  0x03,
+  0xfe,  0x96,  0x00,  0xd1,  0x63,  0xfe,  0x4e,  0x45,  0x83,  0xca,  0xff,  0x04,  0x68,  0x54,  0xfe,  0xf1,
+  0x10,  0x23,  0x49,  0xfe,  0x08,  0x1c,  0xfe,  0x67,  0x19,  0xfe,  0x0a,  0x1c,  0xfe,  0x1a,  0xf4,  0xfe,
+  0x00,  0x04,  0x83,  0xb2,  0x1d,  0x48,  0xfe,  0xaa,  0x1d,  0x13,  0x1d,  0x02,  0x09,  0x92,  0xfe,  0x5a,
+  0xf0,  0xfe,  0xba,  0x1d,  0x2e,  0x93,  0xfe,  0x34,  0x10,  0x09,  0x12,  0xfe,  0x5a,  0xf0,  0xfe,  0xc8,
+  0x1d,  0x2e,  0xb4,  0xfe,  0x26,  0x10,  0x09,  0x1d,  0x36,  0x2e,  0x63,  0xfe,  0x1a,  0x10,  0x09,  0x0d,
+  0x36,  0x2e,  0x94,  0xf2,  0x09,  0x07,  0x36,  0x2e,  0x95,  0xa1,  0xc8,  0x02,  0x1f,  0x93,  0x01,  0x42,
+  0xfe,  0x04,  0xfe,  0x99,  0x03,  0x9c,  0x8b,  0x02,  0x2a,  0xfe,  0x1c,  0x1e,  0xfe,  0x14,  0xf0,  0x08,
+  0x2f,  0xfe,  0x0c,  0x1e,  0x2a,  0xfe,  0x1c,  0x1e,  0x8f,  0xfe,  0x1c,  0x1e,  0xfe,  0x82,  0xf0,  0xfe,
+  0x10,  0x1e,  0x02,  0x0f,  0x3f,  0x04,  0xfe,  0x80,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x18,
+  0x80,  0x04,  0xfe,  0x98,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x02,  0x80,  0x04,  0xfe,  0x82,
+  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x06,  0x80,  0x04,  0xfe,  0x86,  0x83,  0x33,  0x0b,  0x0e,
+  0x02,  0x0f,  0xfe,  0x1b,  0x80,  0x04,  0xfe,  0x9b,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x04,
+  0x80,  0x04,  0xfe,  0x84,  0x83,  0x33,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x80,  0x80,  0x04,  0xfe,  0x80,
+  0x83,  0xfe,  0xc9,  0x47,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x19,  0x81,  0x04,  0xfe,  0x99,  0x83,  0xfe,
+  0xca,  0x47,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x06,  0x83,  0x04,  0xfe,  0x86,  0x83,  0xfe,  0xce,  0x47,
+  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x2c,  0x90,  0x04,  0xfe,  0xac,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x0f,
+  0xfe,  0xae,  0x90,  0x04,  0xfe,  0xae,  0x93,  0x79,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x08,  0x90,  0x04,
+  0xfe,  0x88,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x8a,  0x90,  0x04,  0xfe,  0x8a,  0x93,  0x79,
+  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x0c,  0x90,  0x04,  0xfe,  0x8c,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x0f,
+  0xfe,  0x8e,  0x90,  0x04,  0xfe,  0x8e,  0x93,  0x79,  0x0b,  0x0e,  0x02,  0x0f,  0xfe,  0x3c,  0x90,  0x04,
+  0xfe,  0xbc,  0x93,  0x3a,  0x0b,  0x0e,  0x02,  0x8b,  0x0f,  0xfe,  0x03,  0x80,  0x04,  0xfe,  0x83,  0x83,
+  0x33,  0x0b,  0x77,  0x0e,  0xa8,  0x02,  0xff,  0x66,  0x00,  0x00,
+};
+
+STATIC unsigned short _adv_asc38C1600_size =
+        sizeof(_adv_asc38C1600_buf); /* 0x1673 */
+STATIC ADV_DCNT _adv_asc38C1600_chksum =
+        0x0604EF77UL; /* Expanded little-endian checksum. */
+
+/* a_init.c */
+/*
+ * EEPROM Configuration.
+ *
+ * All drivers should use this structure to set the default EEPROM
+ * configuration. The BIOS now uses this structure when it is built.
+ * Additional structure information can be found in a_condor.h where
+ * the structure is defined.
+ *
+ * The *_Field_IsChar structs are needed to correct for endianness.
+ * These values are read from the board 16 bits at a time directly
+ * into the structs. Because some fields are char, the values will be
+ * in the wrong order. The *_Field_IsChar tells when to flip the
+ * bytes. Data read and written to PCI memory is automatically swapped
+ * on big-endian platforms so char fields read as words are actually being
+ * unswapped on big-endian platforms.
+ */
+STATIC ADVEEP_3550_CONFIG
+Default_3550_EEPROM_Config __initdata = {
+    ADV_EEPROM_BIOS_ENABLE,     /* cfg_lsw */
+    0x0000,                     /* cfg_msw */
+    0xFFFF,                     /* disc_enable */
+    0xFFFF,                     /* wdtr_able */
+    0xFFFF,                     /* sdtr_able */
+    0xFFFF,                     /* start_motor */
+    0xFFFF,                     /* tagqng_able */
+    0xFFFF,                     /* bios_scan */
+    0,                          /* scam_tolerant */
+    7,                          /* adapter_scsi_id */
+    0,                          /* bios_boot_delay */
+    3,                          /* scsi_reset_delay */
+    0,                          /* bios_id_lun */
+    0,                          /* termination */
+    0,                          /* reserved1 */
+    0xFFE7,                     /* bios_ctrl */
+    0xFFFF,                     /* ultra_able */
+    0,                          /* reserved2 */
+    ASC_DEF_MAX_HOST_QNG,       /* max_host_qng */
+    ASC_DEF_MAX_DVC_QNG,        /* max_dvc_qng */
+    0,                          /* dvc_cntl */
+    0,                          /* bug_fix */
+    0,                          /* serial_number_word1 */
+    0,                          /* serial_number_word2 */
+    0,                          /* serial_number_word3 */
+    0,                          /* check_sum */
+    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* oem_name[16] */
+    0,                          /* dvc_err_code */
+    0,                          /* adv_err_code */
+    0,                          /* adv_err_addr */
+    0,                          /* saved_dvc_err_code */
+    0,                          /* saved_adv_err_code */
+    0,                          /* saved_adv_err_addr */
+    0                           /* num_of_err */
+};
+
+STATIC ADVEEP_3550_CONFIG
+ADVEEP_3550_Config_Field_IsChar __initdata = {
+    0,                          /* cfg_lsw */
+    0,                          /* cfg_msw */
+    0,                          /* -disc_enable */
+    0,                          /* wdtr_able */
+    0,                          /* sdtr_able */
+    0,                          /* start_motor */
+    0,                          /* tagqng_able */
+    0,                          /* bios_scan */
+    0,                          /* scam_tolerant */
+    1,                          /* adapter_scsi_id */
+    1,                          /* bios_boot_delay */
+    1,                          /* scsi_reset_delay */
+    1,                          /* bios_id_lun */
+    1,                          /* termination */
+    1,                          /* reserved1 */
+    0,                          /* bios_ctrl */
+    0,                          /* ultra_able */
+    0,                          /* reserved2 */
+    1,                          /* max_host_qng */
+    1,                          /* max_dvc_qng */
+    0,                          /* dvc_cntl */
+    0,                          /* bug_fix */
+    0,                          /* serial_number_word1 */
+    0,                          /* serial_number_word2 */
+    0,                          /* serial_number_word3 */
+    0,                          /* check_sum */
+    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, /* oem_name[16] */
+    0,                          /* dvc_err_code */
+    0,                          /* adv_err_code */
+    0,                          /* adv_err_addr */
+    0,                          /* saved_dvc_err_code */
+    0,                          /* saved_adv_err_code */
+    0,                          /* saved_adv_err_addr */
+    0                           /* num_of_err */
+};
+
+STATIC ADVEEP_38C0800_CONFIG
+Default_38C0800_EEPROM_Config __initdata = {
+    ADV_EEPROM_BIOS_ENABLE,     /* 00 cfg_lsw */
+    0x0000,                     /* 01 cfg_msw */
+    0xFFFF,                     /* 02 disc_enable */
+    0xFFFF,                     /* 03 wdtr_able */
+    0x4444,                     /* 04 sdtr_speed1 */
+    0xFFFF,                     /* 05 start_motor */
+    0xFFFF,                     /* 06 tagqng_able */
+    0xFFFF,                     /* 07 bios_scan */
+    0,                          /* 08 scam_tolerant */
+    7,                          /* 09 adapter_scsi_id */
+    0,                          /*    bios_boot_delay */
+    3,                          /* 10 scsi_reset_delay */
+    0,                          /*    bios_id_lun */
+    0,                          /* 11 termination_se */
+    0,                          /*    termination_lvd */
+    0xFFE7,                     /* 12 bios_ctrl */
+    0x4444,                     /* 13 sdtr_speed2 */
+    0x4444,                     /* 14 sdtr_speed3 */
+    ASC_DEF_MAX_HOST_QNG,       /* 15 max_host_qng */
+    ASC_DEF_MAX_DVC_QNG,        /*    max_dvc_qng */
+    0,                          /* 16 dvc_cntl */
+    0x4444,                     /* 17 sdtr_speed4 */
+    0,                          /* 18 serial_number_word1 */
+    0,                          /* 19 serial_number_word2 */
+    0,                          /* 20 serial_number_word3 */
+    0,                          /* 21 check_sum */
+    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */
+    0,                          /* 30 dvc_err_code */
+    0,                          /* 31 adv_err_code */
+    0,                          /* 32 adv_err_addr */
+    0,                          /* 33 saved_dvc_err_code */
+    0,                          /* 34 saved_adv_err_code */
+    0,                          /* 35 saved_adv_err_addr */
+    0,                          /* 36 reserved */
+    0,                          /* 37 reserved */
+    0,                          /* 38 reserved */
+    0,                          /* 39 reserved */
+    0,                          /* 40 reserved */
+    0,                          /* 41 reserved */
+    0,                          /* 42 reserved */
+    0,                          /* 43 reserved */
+    0,                          /* 44 reserved */
+    0,                          /* 45 reserved */
+    0,                          /* 46 reserved */
+    0,                          /* 47 reserved */
+    0,                          /* 48 reserved */
+    0,                          /* 49 reserved */
+    0,                          /* 50 reserved */
+    0,                          /* 51 reserved */
+    0,                          /* 52 reserved */
+    0,                          /* 53 reserved */
+    0,                          /* 54 reserved */
+    0,                          /* 55 reserved */
+    0,                          /* 56 cisptr_lsw */
+    0,                          /* 57 cisprt_msw */
+    ADV_PCI_VENDOR_ID,          /* 58 subsysvid */
+    ADV_PCI_DEVID_38C0800_REV1, /* 59 subsysid */
+    0,                          /* 60 reserved */
+    0,                          /* 61 reserved */
+    0,                          /* 62 reserved */
+    0                           /* 63 reserved */
+};
+
+STATIC ADVEEP_38C0800_CONFIG
+ADVEEP_38C0800_Config_Field_IsChar __initdata = {
+    0,                          /* 00 cfg_lsw */
+    0,                          /* 01 cfg_msw */
+    0,                          /* 02 disc_enable */
+    0,                          /* 03 wdtr_able */
+    0,                          /* 04 sdtr_speed1 */
+    0,                          /* 05 start_motor */
+    0,                          /* 06 tagqng_able */
+    0,                          /* 07 bios_scan */
+    0,                          /* 08 scam_tolerant */
+    1,                          /* 09 adapter_scsi_id */
+    1,                          /*    bios_boot_delay */
+    1,                          /* 10 scsi_reset_delay */
+    1,                          /*    bios_id_lun */
+    1,                          /* 11 termination_se */
+    1,                          /*    termination_lvd */
+    0,                          /* 12 bios_ctrl */
+    0,                          /* 13 sdtr_speed2 */
+    0,                          /* 14 sdtr_speed3 */
+    1,                          /* 15 max_host_qng */
+    1,                          /*    max_dvc_qng */
+    0,                          /* 16 dvc_cntl */
+    0,                          /* 17 sdtr_speed4 */
+    0,                          /* 18 serial_number_word1 */
+    0,                          /* 19 serial_number_word2 */
+    0,                          /* 20 serial_number_word3 */
+    0,                          /* 21 check_sum */
+    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, /* 22-29 oem_name[16] */
+    0,                          /* 30 dvc_err_code */
+    0,                          /* 31 adv_err_code */
+    0,                          /* 32 adv_err_addr */
+    0,                          /* 33 saved_dvc_err_code */
+    0,                          /* 34 saved_adv_err_code */
+    0,                          /* 35 saved_adv_err_addr */
+    0,                          /* 36 reserved */
+    0,                          /* 37 reserved */
+    0,                          /* 38 reserved */
+    0,                          /* 39 reserved */
+    0,                          /* 40 reserved */
+    0,                          /* 41 reserved */
+    0,                          /* 42 reserved */
+    0,                          /* 43 reserved */
+    0,                          /* 44 reserved */
+    0,                          /* 45 reserved */
+    0,                          /* 46 reserved */
+    0,                          /* 47 reserved */
+    0,                          /* 48 reserved */
+    0,                          /* 49 reserved */
+    0,                          /* 50 reserved */
+    0,                          /* 51 reserved */
+    0,                          /* 52 reserved */
+    0,                          /* 53 reserved */
+    0,                          /* 54 reserved */
+    0,                          /* 55 reserved */
+    0,                          /* 56 cisptr_lsw */
+    0,                          /* 57 cisprt_msw */
+    0,                          /* 58 subsysvid */
+    0,                          /* 59 subsysid */
+    0,                          /* 60 reserved */
+    0,                          /* 61 reserved */
+    0,                          /* 62 reserved */
+    0                           /* 63 reserved */
+};
+
+STATIC ADVEEP_38C1600_CONFIG
+Default_38C1600_EEPROM_Config __initdata = {
+    ADV_EEPROM_BIOS_ENABLE,     /* 00 cfg_lsw */
+    0x0000,                     /* 01 cfg_msw */
+    0xFFFF,                     /* 02 disc_enable */
+    0xFFFF,                     /* 03 wdtr_able */
+    0x5555,                     /* 04 sdtr_speed1 */
+    0xFFFF,                     /* 05 start_motor */
+    0xFFFF,                     /* 06 tagqng_able */
+    0xFFFF,                     /* 07 bios_scan */
+    0,                          /* 08 scam_tolerant */
+    7,                          /* 09 adapter_scsi_id */
+    0,                          /*    bios_boot_delay */
+    3,                          /* 10 scsi_reset_delay */
+    0,                          /*    bios_id_lun */
+    0,                          /* 11 termination_se */
+    0,                          /*    termination_lvd */
+    0xFFE7,                     /* 12 bios_ctrl */
+    0x5555,                     /* 13 sdtr_speed2 */
+    0x5555,                     /* 14 sdtr_speed3 */
+    ASC_DEF_MAX_HOST_QNG,       /* 15 max_host_qng */
+    ASC_DEF_MAX_DVC_QNG,        /*    max_dvc_qng */
+    0,                          /* 16 dvc_cntl */
+    0x5555,                     /* 17 sdtr_speed4 */
+    0,                          /* 18 serial_number_word1 */
+    0,                          /* 19 serial_number_word2 */
+    0,                          /* 20 serial_number_word3 */
+    0,                          /* 21 check_sum */
+    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* 22-29 oem_name[16] */
+    0,                          /* 30 dvc_err_code */
+    0,                          /* 31 adv_err_code */
+    0,                          /* 32 adv_err_addr */
+    0,                          /* 33 saved_dvc_err_code */
+    0,                          /* 34 saved_adv_err_code */
+    0,                          /* 35 saved_adv_err_addr */
+    0,                          /* 36 reserved */
+    0,                          /* 37 reserved */
+    0,                          /* 38 reserved */
+    0,                          /* 39 reserved */
+    0,                          /* 40 reserved */
+    0,                          /* 41 reserved */
+    0,                          /* 42 reserved */
+    0,                          /* 43 reserved */
+    0,                          /* 44 reserved */
+    0,                          /* 45 reserved */
+    0,                          /* 46 reserved */
+    0,                          /* 47 reserved */
+    0,                          /* 48 reserved */
+    0,                          /* 49 reserved */
+    0,                          /* 50 reserved */
+    0,                          /* 51 reserved */
+    0,                          /* 52 reserved */
+    0,                          /* 53 reserved */
+    0,                          /* 54 reserved */
+    0,                          /* 55 reserved */
+    0,                          /* 56 cisptr_lsw */
+    0,                          /* 57 cisprt_msw */
+    ADV_PCI_VENDOR_ID,          /* 58 subsysvid */
+    ADV_PCI_DEVID_38C1600_REV1, /* 59 subsysid */
+    0,                          /* 60 reserved */
+    0,                          /* 61 reserved */
+    0,                          /* 62 reserved */
+    0                           /* 63 reserved */
+};
+
+STATIC ADVEEP_38C1600_CONFIG
+ADVEEP_38C1600_Config_Field_IsChar __initdata = {
+    0,                          /* 00 cfg_lsw */
+    0,                          /* 01 cfg_msw */
+    0,                          /* 02 disc_enable */
+    0,                          /* 03 wdtr_able */
+    0,                          /* 04 sdtr_speed1 */
+    0,                          /* 05 start_motor */
+    0,                          /* 06 tagqng_able */
+    0,                          /* 07 bios_scan */
+    0,                          /* 08 scam_tolerant */
+    1,                          /* 09 adapter_scsi_id */
+    1,                          /*    bios_boot_delay */
+    1,                          /* 10 scsi_reset_delay */
+    1,                          /*    bios_id_lun */
+    1,                          /* 11 termination_se */
+    1,                          /*    termination_lvd */
+    0,                          /* 12 bios_ctrl */
+    0,                          /* 13 sdtr_speed2 */
+    0,                          /* 14 sdtr_speed3 */
+    1,                          /* 15 max_host_qng */
+    1,                          /*    max_dvc_qng */
+    0,                          /* 16 dvc_cntl */
+    0,                          /* 17 sdtr_speed4 */
+    0,                          /* 18 serial_number_word1 */
+    0,                          /* 19 serial_number_word2 */
+    0,                          /* 20 serial_number_word3 */
+    0,                          /* 21 check_sum */
+    { 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 }, /* 22-29 oem_name[16] */
+    0,                          /* 30 dvc_err_code */
+    0,                          /* 31 adv_err_code */
+    0,                          /* 32 adv_err_addr */
+    0,                          /* 33 saved_dvc_err_code */
+    0,                          /* 34 saved_adv_err_code */
+    0,                          /* 35 saved_adv_err_addr */
+    0,                          /* 36 reserved */
+    0,                          /* 37 reserved */
+    0,                          /* 38 reserved */
+    0,                          /* 39 reserved */
+    0,                          /* 40 reserved */
+    0,                          /* 41 reserved */
+    0,                          /* 42 reserved */
+    0,                          /* 43 reserved */
+    0,                          /* 44 reserved */
+    0,                          /* 45 reserved */
+    0,                          /* 46 reserved */
+    0,                          /* 47 reserved */
+    0,                          /* 48 reserved */
+    0,                          /* 49 reserved */
+    0,                          /* 50 reserved */
+    0,                          /* 51 reserved */
+    0,                          /* 52 reserved */
+    0,                          /* 53 reserved */
+    0,                          /* 54 reserved */
+    0,                          /* 55 reserved */
+    0,                          /* 56 cisptr_lsw */
+    0,                          /* 57 cisprt_msw */
+    0,                          /* 58 subsysvid */
+    0,                          /* 59 subsysid */
+    0,                          /* 60 reserved */
+    0,                          /* 61 reserved */
+    0,                          /* 62 reserved */
+    0                           /* 63 reserved */
+};
+
+/*
+ * Initialize the ADV_DVC_VAR structure.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ */
+STATIC int __init
+AdvInitGetConfig(ADV_DVC_VAR *asc_dvc)
+{
+    ushort      warn_code;
+    AdvPortAddr iop_base;
+    uchar       pci_cmd_reg;
+    int         status;
+
+    warn_code = 0;
+    asc_dvc->err_code = 0;
+    iop_base = asc_dvc->iop_base;
+
+    /*
+     * PCI Command Register
+     *
+     * Note: AscPCICmdRegBits_BusMastering definition (0x0007) includes
+     * I/O Space Control, Memory Space Control and Bus Master Control bits.
+     */
+
+    if (((pci_cmd_reg = DvcAdvReadPCIConfigByte(asc_dvc,
+                            AscPCIConfigCommandRegister))
+         & AscPCICmdRegBits_BusMastering)
+        != AscPCICmdRegBits_BusMastering)
+    {
+        pci_cmd_reg |= AscPCICmdRegBits_BusMastering;
+
+        DvcAdvWritePCIConfigByte(asc_dvc,
+                AscPCIConfigCommandRegister, pci_cmd_reg);
+
+        if (((DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister))
+             & AscPCICmdRegBits_BusMastering)
+            != AscPCICmdRegBits_BusMastering)
+        {
+            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+        }
+    }
+
+    /*
+     * PCI Latency Timer
+     *
+     * If the "latency timer" register is 0x20 or above, then we don't need
+     * to change it.  Otherwise, set it to 0x20 (i.e. set it to 0x20 if it
+     * comes up less than 0x20).
+     */
+    if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20) {
+        DvcAdvWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer, 0x20);
+        if (DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20)
+        {
+            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
+        }
+    }
+
+    /*
+     * Save the state of the PCI Configuration Command Register
+     * "Parity Error Response Control" Bit. If the bit is clear (0),
+     * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore
+     * DMA parity errors.
+     */
+    asc_dvc->cfg->control_flag = 0;
+    if (((DvcAdvReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
+         & AscPCICmdRegBits_ParErrRespCtrl)) == 0)
+    {
+        asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
+    }
+
+    asc_dvc->cfg->lib_version = (ADV_LIB_VERSION_MAJOR << 8) |
+      ADV_LIB_VERSION_MINOR;
+    asc_dvc->cfg->chip_version =
+      AdvGetChipVersion(iop_base, asc_dvc->bus_type);
+
+    ASC_DBG2(1, "AdvInitGetConfig: iopb_chip_id_1: 0x%x 0x%x\n",
+        (ushort) AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),
+        (ushort) ADV_CHIP_ID_BYTE);
+
+    ASC_DBG2(1, "AdvInitGetConfig: iopw_chip_id_0: 0x%x 0x%x\n",
+        (ushort) AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),
+        (ushort) ADV_CHIP_ID_WORD);
+
+    /*
+     * Reset the chip to start and allow register writes.
+     */
+    if (AdvFindSignature(iop_base) == 0)
+    {
+        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
+        return ADV_ERROR;
+    }
+    else {
+        /*
+         * The caller must set 'chip_type' to a valid setting.
+         */
+        if (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&
+            asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&
+            asc_dvc->chip_type != ADV_CHIP_ASC38C1600)
+        {
+            asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
+            return ADV_ERROR;
+        }
+
+        /*
+         * Reset Chip.
+         */
+        AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+            ADV_CTRL_REG_CMD_RESET);
+        DvcSleepMilliSecond(100);
+        AdvWriteWordRegister(iop_base, IOPW_CTRL_REG,
+            ADV_CTRL_REG_CMD_WR_IO_REG);
+
+        if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
+        {
+            if ((status = AdvInitFrom38C1600EEP(asc_dvc)) == ADV_ERROR)
+            {
+                return ADV_ERROR;
+            }
+        } else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
+        {
+            if ((status = AdvInitFrom38C0800EEP(asc_dvc)) == ADV_ERROR)
+            {
+                return ADV_ERROR;
+            }
+        } else
+        {
+            if ((status = AdvInitFrom3550EEP(asc_dvc)) == ADV_ERROR)
+            {
+                return ADV_ERROR;
+            }
+        }
+        warn_code |= status;
+    }
+
+    return warn_code;
+}
+
+/*
+ * Initialize the ASC-3550.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+STATIC int
+AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr iop_base;
+    ushort      warn_code;
+    ADV_DCNT    sum;
+    int         begin_addr;
+    int         end_addr;
+    ushort      code_sum;
+    int         word;
+    int         j;
+    int         adv_asc3550_expanded_size;
+    ADV_CARR_T  *carrp;
+    ADV_DCNT    contig_len;
+    ADV_SDCNT   buf_size;
+    ADV_PADDR   carr_paddr;
+    int         i;
+    ushort      scsi_cfg1;
+    uchar       tid;
+    ushort      bios_mem[ASC_MC_BIOSLEN/2]; /* BIOS RISC Memory 0x40-0x8F. */
+    ushort      wdtr_able = 0, sdtr_able, tagqng_able;
+    uchar       max_cmd[ADV_MAX_TID + 1];
+
+    /* If there is already an error, don't continue. */
+    if (asc_dvc->err_code != 0)
+    {
+        return ADV_ERROR;
+    }
+
+    /*
+     * The caller must set 'chip_type' to ADV_CHIP_ASC3550.
+     */
+    if (asc_dvc->chip_type != ADV_CHIP_ASC3550)
+    {
+        asc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;
+        return ADV_ERROR;
+    }
+
+    warn_code = 0;
+    iop_base = asc_dvc->iop_base;
+
+    /*
+     * Save the RISC memory BIOS region before writing the microcode.
+     * The BIOS may already be loaded and using its RISC LRAM region
+     * so its region must be saved and restored.
+     *
+     * Note: This code makes the assumption, which is currently true,
+     * that a chip reset does not clear RISC LRAM.
+     */
+    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
+    }
+
+    /*
+     * Save current per TID negotiated values.
+     */
+    if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
+    {
+        ushort  bios_version, major, minor;
+
+        bios_version = bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM)/2];
+        major = (bios_version  >> 12) & 0xF;
+        minor = (bios_version  >> 8) & 0xF;
+        if (major < 3 || (major == 3 && minor == 1))
+        {
+            /* BIOS 3.1 and earlier location of 'wdtr_able' variable. */
+            AdvReadWordLram(iop_base, 0x120, wdtr_able);
+        } else
+        {
+            AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+        }
+    }
+    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+    for (tid = 0; tid <= ADV_MAX_TID; tid++)
+    {
+        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+            max_cmd[tid]);
+    }
+
+    /*
+     * Load the Microcode
+     *
+     * Write the microcode image to RISC memory starting at address 0.
+     */
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+    /* Assume the following compressed format of the microcode buffer:
+     *
+     *  254 word (508 byte) table indexed by byte code followed
+     *  by the following byte codes:
+     *
+     *    1-Byte Code:
+     *      00: Emit word 0 in table.
+     *      01: Emit word 1 in table.
+     *      .
+     *      FD: Emit word 253 in table.
+     *
+     *    Multi-Byte Code:
+     *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+     *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+     */
+    word = 0;
+    for (i = 253 * 2; i < _adv_asc3550_size; i++)
+    {
+        if (_adv_asc3550_buf[i] == 0xff)
+        {
+            for (j = 0; j < _adv_asc3550_buf[i + 1]; j++)
+            {
+                AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                    _adv_asc3550_buf[i + 3] << 8) |
+                _adv_asc3550_buf[i + 2]));
+                word++;
+            }
+            i += 3;
+        } else if (_adv_asc3550_buf[i] == 0xfe)
+        {
+            AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                _adv_asc3550_buf[i + 2] << 8) |
+                _adv_asc3550_buf[i + 1]));
+            i += 2;
+            word++;
+        } else
+        {
+            AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                _adv_asc3550_buf[(_adv_asc3550_buf[i] * 2) + 1] << 8) |
+                _adv_asc3550_buf[_adv_asc3550_buf[i] * 2]));
+            word++;
+        }
+    }
+
+    /*
+     * Set 'word' for later use to clear the rest of memory and save
+     * the expanded mcode size.
+     */
+    word *= 2;
+    adv_asc3550_expanded_size = word;
+
+    /*
+     * Clear the rest of ASC-3550 Internal RAM (8KB).
+     */
+    for (; word < ADV_3550_MEMSIZE; word += 2)
+    {
+        AdvWriteWordAutoIncLram(iop_base, 0);
+    }
+
+    /*
+     * Verify the microcode checksum.
+     */
+    sum = 0;
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+    for (word = 0; word < adv_asc3550_expanded_size; word += 2)
+    {
+        sum += AdvReadWordAutoIncLram(iop_base);
+    }
+
+    if (sum != _adv_asc3550_chksum)
+    {
+        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+        return ADV_ERROR;
+    }
+
+    /*
+     * Restore the RISC memory BIOS region.
+     */
+    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
+    }
+
+    /*
+     * Calculate and write the microcode code checksum to the microcode
+     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+     */
+    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+    AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+    code_sum = 0;
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+    for (word = begin_addr; word < end_addr; word += 2)
+    {
+        code_sum += AdvReadWordAutoIncLram(iop_base);
+    }
+    AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+    /*
+     * Read and save microcode version and date.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE, asc_dvc->cfg->mcode_date);
+    AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM, asc_dvc->cfg->mcode_version);
+
+    /*
+     * Set the chip type to indicate the ASC3550.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);
+
+    /*
+     * If the PCI Configuration Command Register "Parity Error Response
+     * Control" Bit was clear (0), then set the microcode variable
+     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+     * to ignore DMA parity errors.
+     */
+    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+        word |= CONTROL_FLAG_IGNORE_PERR;
+        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+    }
+
+    /*
+     * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO
+     * threshold of 128 bytes. This register is only accessible to the host.
+     */
+    AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+        START_CTL_EMFU | READ_CMD_MRM);
+
+    /*
+     * Microcode operating variables for WDTR, SDTR, and command tag
+     * queuing will be set in AdvInquiryHandling() based on what a
+     * device reports it is capable of in Inquiry byte 7.
+     *
+     * If SCSI Bus Resets have been disabled, then directly set
+     * SDTR and WDTR from the EEPROM configuration. This will allow
+     * the BIOS and warm boot to work without a SCSI bus hang on
+     * the Inquiry caused by host and target mismatched DTR values.
+     * Without the SCSI Bus Reset, before an Inquiry a device can't
+     * be assumed to be in Asynchronous, Narrow mode.
+     */
+    if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, asc_dvc->wdtr_able);
+        AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, asc_dvc->sdtr_able);
+    }
+
+    /*
+     * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,
+     * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID
+     * bitmask. These values determine the maximum SDTR speed negotiated
+     * with a device.
+     *
+     * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+     * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+     * without determining here whether the device supports SDTR.
+     *
+     * 4-bit speed  SDTR speed name
+     * ===========  ===============
+     * 0000b (0x0)  SDTR disabled
+     * 0001b (0x1)  5 Mhz
+     * 0010b (0x2)  10 Mhz
+     * 0011b (0x3)  20 Mhz (Ultra)
+     * 0100b (0x4)  40 Mhz (LVD/Ultra2)
+     * 0101b (0x5)  80 Mhz (LVD2/Ultra3)
+     * 0110b (0x6)  Undefined
+     * .
+     * 1111b (0xF)  Undefined
+     */
+    word = 0;
+    for (tid = 0; tid <= ADV_MAX_TID; tid++)
+    {
+        if (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able)
+        {
+            /* Set Ultra speed for TID 'tid'. */
+            word |= (0x3 << (4 * (tid % 4)));
+        } else
+        {
+            /* Set Fast speed for TID 'tid'. */
+            word |= (0x2 << (4 * (tid % 4)));
+        }
+        if (tid == 3) /* Check if done with sdtr_speed1. */
+        {
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);
+            word = 0;
+        } else if (tid == 7) /* Check if done with sdtr_speed2. */
+        {
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);
+            word = 0;
+        } else if (tid == 11) /* Check if done with sdtr_speed3. */
+        {
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);
+            word = 0;
+        } else if (tid == 15) /* Check if done with sdtr_speed4. */
+        {
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);
+            /* End of loop. */
+        }
+    }
+
+    /*
+     * Set microcode operating variable for the disconnect per TID bitmask.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);
+
+    /*
+     * Set SCSI_CFG0 Microcode Default Value.
+     *
+     * The microcode will set the SCSI_CFG0 register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+        PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+        asc_dvc->chip_scsi_id);
+
+    /*
+     * Determine SCSI_CFG1 Microcode Default Value.
+     *
+     * The microcode will set the SCSI_CFG1 register using this value
+     * after it is started below.
+     */
+
+    /* Read current SCSI_CFG1 Register value. */
+    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+    /*
+     * If all three connectors are in use, return an error.
+     */
+    if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
+        (scsi_cfg1 & CABLE_ILLEGAL_B) == 0)
+    {
+            asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
+            return ADV_ERROR;
+    }
+
+    /*
+     * If the internal narrow cable is reversed all of the SCSI_CTRL
+     * register signals will be set. Check for and return an error if
+     * this condition is found.
+     */
+    if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
+    {
+        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+        return ADV_ERROR;
+    }
+
+    /*
+     * If this is a differential board and a single-ended device
+     * is attached to one of the connectors, return an error.
+     */
+    if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0)
+    {
+        asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
+        return ADV_ERROR;
+    }
+
+    /*
+     * If automatic termination control is enabled, then set the
+     * termination value based on a table listed in a_condor.h.
+     *
+     * If manual termination was specified with an EEPROM setting
+     * then 'termination' was set-up in AdvInitFrom3550EEPROM() and
+     * is ready to be 'ored' into SCSI_CFG1.
+     */
+    if (asc_dvc->cfg->termination == 0)
+    {
+        /*
+         * The software always controls termination by setting TERM_CTL_SEL.
+         * If TERM_CTL_SEL were set to 0, the hardware would set termination.
+         */
+        asc_dvc->cfg->termination |= TERM_CTL_SEL;
+
+        switch(scsi_cfg1 & CABLE_DETECT)
+        {
+            /* TERM_CTL_H: on, TERM_CTL_L: on */
+            case 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:
+                asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
+                break;
+
+            /* TERM_CTL_H: on, TERM_CTL_L: off */
+            case 0x1: case 0x5: case 0x9: case 0xA: case 0xC:
+                asc_dvc->cfg->termination |= TERM_CTL_H;
+                break;
+
+            /* TERM_CTL_H: off, TERM_CTL_L: off */
+            case 0x2: case 0x6:
+                break;
+        }
+    }
+
+    /*
+     * Clear any set TERM_CTL_H and TERM_CTL_L bits.
+     */
+    scsi_cfg1 &= ~TERM_CTL;
+
+    /*
+     * Invert the TERM_CTL_H and TERM_CTL_L bits and then
+     * set 'scsi_cfg1'. The TERM_POL bit does not need to be
+     * referenced, because the hardware internally inverts
+     * the Termination High and Low bits if TERM_POL is set.
+     */
+    scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));
+
+    /*
+     * Set SCSI_CFG1 Microcode Default Value
+     *
+     * Set filter value and possibly modified termination control
+     * bits in the Microcode SCSI_CFG1 Register Value.
+     *
+     * The microcode will set the SCSI_CFG1 register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
+        FLTR_DISABLE | scsi_cfg1);
+
+    /*
+     * Set MEM_CFG Microcode Default Value
+     *
+     * The microcode will set the MEM_CFG register using this value
+     * after it is started below.
+     *
+     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+     * are defined.
+     *
+     * ASC-3550 has 8KB internal memory.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+        BIOS_EN | RAM_SZ_8KB);
+
+    /*
+     * Set SEL_MASK Microcode Default Value
+     *
+     * The microcode will set the SEL_MASK register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+    /*
+     * Build carrier freelist.
+     *
+     * Driver must have already allocated memory and set 'carrier_buf'.
+     */
+    ASC_ASSERT(asc_dvc->carrier_buf != NULL);
+
+    carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+    asc_dvc->carr_freelist = NULL;
+    if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf)
+    {
+        buf_size = ADV_CARRIER_BUFSIZE;
+    } else
+    {
+        buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+    }
+
+    do {
+        /*
+         * Get physical address of the carrier 'carrp'.
+         */
+        contig_len = sizeof(ADV_CARR_T);
+        carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL, (uchar *) carrp,
+            (ADV_SDCNT *) &contig_len, ADV_IS_CARRIER_FLAG));
+
+        buf_size -= sizeof(ADV_CARR_T);
+
+        /*
+         * If the current carrier is not physically contiguous, then
+         * maybe there was a page crossing. Try the next carrier aligned
+         * start address.
+         */
+        if (contig_len < sizeof(ADV_CARR_T))
+        {
+            carrp++;
+            continue;
+        }
+
+        carrp->carr_pa = carr_paddr;
+        carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+
+        /*
+         * Insert the carrier at the beginning of the freelist.
+         */
+        carrp->next_vpa = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+        asc_dvc->carr_freelist = carrp;
+
+        carrp++;
+    }
+    while (buf_size > 0);
+
+    /*
+     * Set-up the Host->RISC Initiator Command Queue (ICQ).
+     */
+
+    if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL)
+    {
+        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+        return ADV_ERROR;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+    /*
+     * The first command issued will be placed in the stopper carrier.
+     */
+    asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Set RISC ICQ physical address start value.
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+
+    /*
+     * Set-up the RISC->Host Initiator Response Queue (IRQ).
+     */
+    if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL)
+    {
+        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+        return ADV_ERROR;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+         ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+    /*
+     * The first command completed by the RISC will be placed in
+     * the stopper.
+     *
+     * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+     * completed the RISC will set the ASC_RQ_STOPPER bit.
+     */
+    asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Set RISC IRQ physical address start value.
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+    asc_dvc->carr_pending_cnt = 0;
+
+    AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+        (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
+
+    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+    AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+    /* finally, finally, gentlemen, start your engine */
+    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+    /*
+     * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+     * Resets should be performed. The RISC has to be running
+     * to issue a SCSI Bus Reset.
+     */
+    if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
+    {
+        /*
+         * If the BIOS Signature is present in memory, restore the
+         * BIOS Handshake Configuration Table and do not perform
+         * a SCSI Bus Reset.
+         */
+        if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
+        {
+            /*
+             * Restore per TID negotiated values.
+             */
+            AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+            for (tid = 0; tid <= ADV_MAX_TID; tid++)
+            {
+                AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+                    max_cmd[tid]);
+            }
+        } else
+        {
+            if (AdvResetSB(asc_dvc) != ADV_TRUE)
+            {
+                warn_code = ASC_WARN_BUSRESET_ERROR;
+            }
+        }
+    }
+
+    return warn_code;
+}
+
+/*
+ * Initialize the ASC-38C0800.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+STATIC int
+AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr iop_base;
+    ushort      warn_code;
+    ADV_DCNT    sum;
+    int         begin_addr;
+    int         end_addr;
+    ushort      code_sum;
+    int         word;
+    int         j;
+    int         adv_asc38C0800_expanded_size;
+    ADV_CARR_T  *carrp;
+    ADV_DCNT    contig_len;
+    ADV_SDCNT   buf_size;
+    ADV_PADDR   carr_paddr;
+    int         i;
+    ushort      scsi_cfg1;
+    uchar       byte;
+    uchar       tid;
+    ushort      bios_mem[ASC_MC_BIOSLEN/2]; /* BIOS RISC Memory 0x40-0x8F. */
+    ushort      wdtr_able, sdtr_able, tagqng_able;
+    uchar       max_cmd[ADV_MAX_TID + 1];
+
+    /* If there is already an error, don't continue. */
+    if (asc_dvc->err_code != 0)
+    {
+        return ADV_ERROR;
+    }
+
+    /*
+     * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.
+     */
+    if (asc_dvc->chip_type != ADV_CHIP_ASC38C0800)
+    {
+        asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+        return ADV_ERROR;
+    }
+
+    warn_code = 0;
+    iop_base = asc_dvc->iop_base;
+
+    /*
+     * Save the RISC memory BIOS region before writing the microcode.
+     * The BIOS may already be loaded and using its RISC LRAM region
+     * so its region must be saved and restored.
+     *
+     * Note: This code makes the assumption, which is currently true,
+     * that a chip reset does not clear RISC LRAM.
+     */
+    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
+    }
+
+    /*
+     * Save current per TID negotiated values.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+    for (tid = 0; tid <= ADV_MAX_TID; tid++)
+    {
+        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+            max_cmd[tid]);
+    }
+
+    /*
+     * RAM BIST (RAM Built-In Self Test)
+     *
+     * Address : I/O base + offset 0x38h register (byte).
+     * Function: Bit 7-6(RW) : RAM mode
+     *                          Normal Mode   : 0x00
+     *                          Pre-test Mode : 0x40
+     *                          RAM Test Mode : 0x80
+     *           Bit 5       : unused
+     *           Bit 4(RO)   : Done bit
+     *           Bit 3-0(RO) : Status
+     *                          Host Error    : 0x08
+     *                          Int_RAM Error : 0x04
+     *                          RISC Error    : 0x02
+     *                          SCSI Error    : 0x01
+     *                          No Error      : 0x00
+     *
+     * Note: RAM BIST code should be put right here, before loading the
+     * microcode and after saving the RISC memory BIOS region.
+     */
+
+    /*
+     * LRAM Pre-test
+     *
+     * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
+     * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
+     * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
+     * to NORMAL_MODE, return an error too.
+     */
+    for (i = 0; i < 2; i++)
+    {
+        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
+        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
+        byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+        if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) != PRE_TEST_VALUE)
+        {
+            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+            return ADV_ERROR;
+        }
+
+        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
+        if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
+            != NORMAL_VALUE)
+        {
+            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+            return ADV_ERROR;
+        }
+    }
+
+    /*
+     * LRAM Test - It takes about 1.5 ms to run through the test.
+     *
+     * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
+     * If Done bit not set or Status not 0, save register byte, set the
+     * err_code, and return an error.
+     */
+    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
+    DvcSleepMilliSecond(10);  /* Wait for 10ms before checking status. */
+
+    byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+    if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0)
+    {
+        /* Get here if Done bit not set or Status not 0. */
+        asc_dvc->bist_err_code = byte;  /* for BIOS display message */
+        asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
+        return ADV_ERROR;
+    }
+
+    /* We need to reset back to normal mode after LRAM test passes. */
+    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+
+    /*
+     * Load the Microcode
+     *
+     * Write the microcode image to RISC memory starting at address 0.
+     *
+     */
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+    /* Assume the following compressed format of the microcode buffer:
+     *
+     *  254 word (508 byte) table indexed by byte code followed
+     *  by the following byte codes:
+     *
+     *    1-Byte Code:
+     *      00: Emit word 0 in table.
+     *      01: Emit word 1 in table.
+     *      .
+     *      FD: Emit word 253 in table.
+     *
+     *    Multi-Byte Code:
+     *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+     *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+     */
+    word = 0;
+    for (i = 253 * 2; i < _adv_asc38C0800_size; i++)
+    {
+        if (_adv_asc38C0800_buf[i] == 0xff)
+        {
+            for (j = 0; j < _adv_asc38C0800_buf[i + 1]; j++)
+            {
+                AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                    _adv_asc38C0800_buf[i + 3] << 8) |
+                    _adv_asc38C0800_buf[i + 2]));
+                word++;
+            }
+            i += 3;
+        } else if (_adv_asc38C0800_buf[i] == 0xfe)
+        {
+            AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                _adv_asc38C0800_buf[i + 2] << 8) |
+                _adv_asc38C0800_buf[i + 1]));
+            i += 2;
+            word++;
+        } else
+        {
+            AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                _adv_asc38C0800_buf[(_adv_asc38C0800_buf[i] * 2) + 1] << 8) |
+                _adv_asc38C0800_buf[_adv_asc38C0800_buf[i] * 2]));
+            word++;
+        }
+    }
+
+    /*
+     * Set 'word' for later use to clear the rest of memory and save
+     * the expanded mcode size.
+     */
+    word *= 2;
+    adv_asc38C0800_expanded_size = word;
+
+    /*
+     * Clear the rest of ASC-38C0800 Internal RAM (16KB).
+     */
+    for (; word < ADV_38C0800_MEMSIZE; word += 2)
+    {
+        AdvWriteWordAutoIncLram(iop_base, 0);
+    }
+
+    /*
+     * Verify the microcode checksum.
+     */
+    sum = 0;
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+    for (word = 0; word < adv_asc38C0800_expanded_size; word += 2)
+    {
+        sum += AdvReadWordAutoIncLram(iop_base);
+    }
+    ASC_DBG2(1, "AdvInitAsc38C0800Driver: word %d, i %d\n", word, i);
+
+    ASC_DBG2(1,
+        "AdvInitAsc38C0800Driver: sum 0x%lx, _adv_asc38C0800_chksum 0x%lx\n",
+        (ulong) sum, (ulong) _adv_asc38C0800_chksum);
+
+    if (sum != _adv_asc38C0800_chksum)
+    {
+        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+        return ADV_ERROR;
+    }
+
+    /*
+     * Restore the RISC memory BIOS region.
+     */
+    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
+    }
+
+    /*
+     * Calculate and write the microcode code checksum to the microcode
+     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+     */
+    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+    AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+    code_sum = 0;
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+    for (word = begin_addr; word < end_addr; word += 2)
+    {
+        code_sum += AdvReadWordAutoIncLram(iop_base);
+    }
+    AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+    /*
+     * Read microcode version and date.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE, asc_dvc->cfg->mcode_date);
+    AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM, asc_dvc->cfg->mcode_version);
+
+    /*
+     * Set the chip type to indicate the ASC38C0800.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);
+
+    /*
+     * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
+     * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
+     * cable detection and then we are able to read C_DET[3:0].
+     *
+     * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
+     * Microcode Default Value' section below.
+     */
+    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+    AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1, scsi_cfg1 | DIS_TERM_DRV);
+
+    /*
+     * If the PCI Configuration Command Register "Parity Error Response
+     * Control" Bit was clear (0), then set the microcode variable
+     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+     * to ignore DMA parity errors.
+     */
+    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+        word |= CONTROL_FLAG_IGNORE_PERR;
+        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+    }
+
+    /*
+     * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]
+     * bits for the default FIFO threshold.
+     *
+     * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.
+     *
+     * For DMA Errata #4 set the BC_THRESH_ENB bit.
+     */
+    AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+        BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
+
+    /*
+     * Microcode operating variables for WDTR, SDTR, and command tag
+     * queuing will be set in AdvInquiryHandling() based on what a
+     * device reports it is capable of in Inquiry byte 7.
+     *
+     * If SCSI Bus Resets have been disabled, then directly set
+     * SDTR and WDTR from the EEPROM configuration. This will allow
+     * the BIOS and warm boot to work without a SCSI bus hang on
+     * the Inquiry caused by host and target mismatched DTR values.
+     * Without the SCSI Bus Reset, before an Inquiry a device can't
+     * be assumed to be in Asynchronous, Narrow mode.
+     */
+    if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, asc_dvc->wdtr_able);
+        AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, asc_dvc->sdtr_able);
+    }
+
+    /*
+     * Set microcode operating variables for DISC and SDTR_SPEED1,
+     * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
+     * configuration values.
+     *
+     * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+     * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+     * without determining here whether the device supports SDTR.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+
+    /*
+     * Set SCSI_CFG0 Microcode Default Value.
+     *
+     * The microcode will set the SCSI_CFG0 register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+        PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+        asc_dvc->chip_scsi_id);
+
+    /*
+     * Determine SCSI_CFG1 Microcode Default Value.
+     *
+     * The microcode will set the SCSI_CFG1 register using this value
+     * after it is started below.
+     */
+
+    /* Read current SCSI_CFG1 Register value. */
+    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+    /*
+     * If the internal narrow cable is reversed all of the SCSI_CTRL
+     * register signals will be set. Check for and return an error if
+     * this condition is found.
+     */
+    if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
+    {
+        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+        return ADV_ERROR;
+    }
+
+    /*
+     * All kind of combinations of devices attached to one of four connectors
+     * are acceptable except HVD device attached. For example, LVD device can
+     * be attached to SE connector while SE device attached to LVD connector.
+     * If LVD device attached to SE connector, it only runs up to Ultra speed.
+     *
+     * If an HVD device is attached to one of LVD connectors, return an error.
+     * However, there is no way to detect HVD device attached to SE connectors.
+     */
+    if (scsi_cfg1 & HVD)
+    {
+        asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
+        return ADV_ERROR;
+    }
+
+    /*
+     * If either SE or LVD automatic termination control is enabled, then
+     * set the termination value based on a table listed in a_condor.h.
+     *
+     * If manual termination was specified with an EEPROM setting then
+     * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready to
+     * be 'ored' into SCSI_CFG1.
+     */
+    if ((asc_dvc->cfg->termination & TERM_SE) == 0)
+    {
+        /* SE automatic termination control is enabled. */
+        switch(scsi_cfg1 & C_DET_SE)
+        {
+            /* TERM_SE_HI: on, TERM_SE_LO: on */
+            case 0x1: case 0x2: case 0x3:
+                asc_dvc->cfg->termination |= TERM_SE;
+                break;
+
+            /* TERM_SE_HI: on, TERM_SE_LO: off */
+            case 0x0:
+                asc_dvc->cfg->termination |= TERM_SE_HI;
+                break;
+        }
+    }
+
+    if ((asc_dvc->cfg->termination & TERM_LVD) == 0)
+    {
+        /* LVD automatic termination control is enabled. */
+        switch(scsi_cfg1 & C_DET_LVD)
+        {
+            /* TERM_LVD_HI: on, TERM_LVD_LO: on */
+            case 0x4: case 0x8: case 0xC:
+                asc_dvc->cfg->termination |= TERM_LVD;
+                break;
+
+            /* TERM_LVD_HI: off, TERM_LVD_LO: off */
+            case 0x0:
+                break;
+        }
+    }
+
+    /*
+     * Clear any set TERM_SE and TERM_LVD bits.
+     */
+    scsi_cfg1 &= (~TERM_SE & ~TERM_LVD);
+
+    /*
+     * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.
+     */
+    scsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);
+
+    /*
+     * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE bits
+     * and set possibly modified termination control bits in the Microcode
+     * SCSI_CFG1 Register Value.
+     */
+    scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);
+
+    /*
+     * Set SCSI_CFG1 Microcode Default Value
+     *
+     * Set possibly modified termination control and reset DIS_TERM_DRV
+     * bits in the Microcode SCSI_CFG1 Register Value.
+     *
+     * The microcode will set the SCSI_CFG1 register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+
+    /*
+     * Set MEM_CFG Microcode Default Value
+     *
+     * The microcode will set the MEM_CFG register using this value
+     * after it is started below.
+     *
+     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+     * are defined.
+     *
+     * ASC-38C0800 has 16KB internal memory.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+        BIOS_EN | RAM_SZ_16KB);
+
+    /*
+     * Set SEL_MASK Microcode Default Value
+     *
+     * The microcode will set the SEL_MASK register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+    /*
+     * Build the carrier freelist.
+     *
+     * Driver must have already allocated memory and set 'carrier_buf'.
+     */
+    ASC_ASSERT(asc_dvc->carrier_buf != NULL);
+
+    carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+    asc_dvc->carr_freelist = NULL;
+    if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf)
+    {
+        buf_size = ADV_CARRIER_BUFSIZE;
+    } else
+    {
+        buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+    }
+
+    do {
+        /*
+         * Get physical address for the carrier 'carrp'.
+         */
+        contig_len = sizeof(ADV_CARR_T);
+        carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL, (uchar *) carrp,
+            (ADV_SDCNT *) &contig_len, ADV_IS_CARRIER_FLAG));
+
+        buf_size -= sizeof(ADV_CARR_T);
+
+        /*
+         * If the current carrier is not physically contiguous, then
+         * maybe there was a page crossing. Try the next carrier aligned
+         * start address.
+         */
+        if (contig_len < sizeof(ADV_CARR_T))
+        {
+            carrp++;
+            continue;
+        }
+
+        carrp->carr_pa = carr_paddr;
+        carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+
+        /*
+         * Insert the carrier at the beginning of the freelist.
+         */
+        carrp->next_vpa = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+        asc_dvc->carr_freelist = carrp;
+
+        carrp++;
+    }
+    while (buf_size > 0);
+
+    /*
+     * Set-up the Host->RISC Initiator Command Queue (ICQ).
+     */
+
+    if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL)
+    {
+        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+        return ADV_ERROR;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+    /*
+     * The first command issued will be placed in the stopper carrier.
+     */
+    asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Set RISC ICQ physical address start value.
+     * carr_pa is LE, must be native before write
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+
+    /*
+     * Set-up the RISC->Host Initiator Response Queue (IRQ).
+     */
+    if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL)
+    {
+        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+        return ADV_ERROR;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+    /*
+     * The first command completed by the RISC will be placed in
+     * the stopper.
+     *
+     * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+     * completed the RISC will set the ASC_RQ_STOPPER bit.
+     */
+    asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Set RISC IRQ physical address start value.
+     *
+     * carr_pa is LE, must be native before write *
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+    asc_dvc->carr_pending_cnt = 0;
+
+    AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+        (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
+
+    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+    AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+    /* finally, finally, gentlemen, start your engine */
+    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+    /*
+     * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+     * Resets should be performed. The RISC has to be running
+     * to issue a SCSI Bus Reset.
+     */
+    if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
+    {
+        /*
+         * If the BIOS Signature is present in memory, restore the
+         * BIOS Handshake Configuration Table and do not perform
+         * a SCSI Bus Reset.
+         */
+        if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
+        {
+            /*
+             * Restore per TID negotiated values.
+             */
+            AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+            for (tid = 0; tid <= ADV_MAX_TID; tid++)
+            {
+                AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+                    max_cmd[tid]);
+            }
+        } else
+        {
+            if (AdvResetSB(asc_dvc) != ADV_TRUE)
+            {
+                warn_code = ASC_WARN_BUSRESET_ERROR;
+            }
+        }
+    }
+
+    return warn_code;
+}
+
+/*
+ * Initialize the ASC-38C1600.
+ *
+ * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Needed after initialization for error recovery.
+ */
+STATIC int
+AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr iop_base;
+    ushort      warn_code;
+    ADV_DCNT    sum;
+    int         begin_addr;
+    int         end_addr;
+    ushort      code_sum;
+    long        word;
+    int         j;
+    int         adv_asc38C1600_expanded_size;
+    ADV_CARR_T  *carrp;
+    ADV_DCNT    contig_len;
+    ADV_SDCNT   buf_size;
+    ADV_PADDR   carr_paddr;
+    int         i;
+    ushort      scsi_cfg1;
+    uchar       byte;
+    uchar       tid;
+    ushort      bios_mem[ASC_MC_BIOSLEN/2]; /* BIOS RISC Memory 0x40-0x8F. */
+    ushort      wdtr_able, sdtr_able, ppr_able, tagqng_able;
+    uchar       max_cmd[ASC_MAX_TID + 1];
+
+    /* If there is already an error, don't continue. */
+    if (asc_dvc->err_code != 0)
+    {
+        return ADV_ERROR;
+    }
+
+    /*
+     * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.
+     */
+    if (asc_dvc->chip_type != ADV_CHIP_ASC38C1600)
+    {
+        asc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;
+        return ADV_ERROR;
+    }
+
+    warn_code = 0;
+    iop_base = asc_dvc->iop_base;
+
+    /*
+     * Save the RISC memory BIOS region before writing the microcode.
+     * The BIOS may already be loaded and using its RISC LRAM region
+     * so its region must be saved and restored.
+     *
+     * Note: This code makes the assumption, which is currently true,
+     * that a chip reset does not clear RISC LRAM.
+     */
+    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
+    }
+
+    /*
+     * Save current per TID negotiated values.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+    AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+    for (tid = 0; tid <= ASC_MAX_TID; tid++)
+    {
+        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+            max_cmd[tid]);
+    }
+
+    /*
+     * RAM BIST (Built-In Self Test)
+     *
+     * Address : I/O base + offset 0x38h register (byte).
+     * Function: Bit 7-6(RW) : RAM mode
+     *                          Normal Mode   : 0x00
+     *                          Pre-test Mode : 0x40
+     *                          RAM Test Mode : 0x80
+     *           Bit 5       : unused
+     *           Bit 4(RO)   : Done bit
+     *           Bit 3-0(RO) : Status
+     *                          Host Error    : 0x08
+     *                          Int_RAM Error : 0x04
+     *                          RISC Error    : 0x02
+     *                          SCSI Error    : 0x01
+     *                          No Error      : 0x00
+     *
+     * Note: RAM BIST code should be put right here, before loading the
+     * microcode and after saving the RISC memory BIOS region.
+     */
+
+    /*
+     * LRAM Pre-test
+     *
+     * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.
+     * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return
+     * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset
+     * to NORMAL_MODE, return an error too.
+     */
+    for (i = 0; i < 2; i++)
+    {
+        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);
+        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
+        byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+        if ((byte & RAM_TEST_DONE) == 0 || (byte & 0x0F) != PRE_TEST_VALUE)
+        {
+            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+            return ADV_ERROR;
+        }
+
+        AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+        DvcSleepMilliSecond(10);  /* Wait for 10ms before reading back. */
+        if (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)
+            != NORMAL_VALUE)
+        {
+            asc_dvc->err_code |= ASC_IERR_BIST_PRE_TEST;
+            return ADV_ERROR;
+        }
+    }
+
+    /*
+     * LRAM Test - It takes about 1.5 ms to run through the test.
+     *
+     * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.
+     * If Done bit not set or Status not 0, save register byte, set the
+     * err_code, and return an error.
+     */
+    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);
+    DvcSleepMilliSecond(10);  /* Wait for 10ms before checking status. */
+
+    byte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);
+    if ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0)
+    {
+        /* Get here if Done bit not set or Status not 0. */
+        asc_dvc->bist_err_code = byte;  /* for BIOS display message */
+        asc_dvc->err_code |= ASC_IERR_BIST_RAM_TEST;
+        return ADV_ERROR;
+    }
+
+    /* We need to reset back to normal mode after LRAM test passes. */
+    AdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);
+
+    /*
+     * Load the Microcode
+     *
+     * Write the microcode image to RISC memory starting at address 0.
+     *
+     */
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+    /*
+     * Assume the following compressed format of the microcode buffer:
+     *
+     *  254 word (508 byte) table indexed by byte code followed
+     *  by the following byte codes:
+     *
+     *    1-Byte Code:
+     *      00: Emit word 0 in table.
+     *      01: Emit word 1 in table.
+     *      .
+     *      FD: Emit word 253 in table.
+     *
+     *    Multi-Byte Code:
+     *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.
+     *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.
+     */
+    word = 0;
+    for (i = 253 * 2; i < _adv_asc38C1600_size; i++)
+    {
+        if (_adv_asc38C1600_buf[i] == 0xff)
+        {
+            for (j = 0; j < _adv_asc38C1600_buf[i + 1]; j++)
+            {
+                AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                     _adv_asc38C1600_buf[i + 3] << 8) |
+                     _adv_asc38C1600_buf[i + 2]));
+                word++;
+            }
+           i += 3;
+        } else if (_adv_asc38C1600_buf[i] == 0xfe)
+        {
+                AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                     _adv_asc38C1600_buf[i + 2] << 8) |
+                     _adv_asc38C1600_buf[i + 1]));
+            i += 2;
+            word++;
+        } else
+        {
+            AdvWriteWordAutoIncLram(iop_base, (((ushort)
+                 _adv_asc38C1600_buf[(_adv_asc38C1600_buf[i] * 2) + 1] << 8) |
+                 _adv_asc38C1600_buf[_adv_asc38C1600_buf[i] * 2]));
+            word++;
+        }
+    }
+
+    /*
+     * Set 'word' for later use to clear the rest of memory and save
+     * the expanded mcode size.
+     */
+    word *= 2;
+    adv_asc38C1600_expanded_size = word;
+
+    /*
+     * Clear the rest of ASC-38C1600 Internal RAM (32KB).
+     */
+    for (; word < ADV_38C1600_MEMSIZE; word += 2)
+    {
+        AdvWriteWordAutoIncLram(iop_base, 0);
+    }
+
+    /*
+     * Verify the microcode checksum.
+     */
+    sum = 0;
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
+
+    for (word = 0; word < adv_asc38C1600_expanded_size; word += 2)
+    {
+        sum += AdvReadWordAutoIncLram(iop_base);
+    }
+
+    if (sum != _adv_asc38C1600_chksum)
+    {
+        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
+        return ADV_ERROR;
+    }
+
+    /*
+     * Restore the RISC memory BIOS region.
+     */
+    for (i = 0; i < ASC_MC_BIOSLEN/2; i++)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i), bios_mem[i]);
+    }
+
+    /*
+     * Calculate and write the microcode code checksum to the microcode
+     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
+     */
+    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);
+    AdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);
+    code_sum = 0;
+    AdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);
+    for (word = begin_addr; word < end_addr; word += 2)
+    {
+        code_sum += AdvReadWordAutoIncLram(iop_base);
+    }
+    AdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);
+
+    /*
+     * Read microcode version and date.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_VERSION_DATE, asc_dvc->cfg->mcode_date);
+    AdvReadWordLram(iop_base, ASC_MC_VERSION_NUM, asc_dvc->cfg->mcode_version);
+
+    /*
+     * Set the chip type to indicate the ASC38C1600.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);
+
+    /*
+     * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.
+     * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current
+     * cable detection and then we are able to read C_DET[3:0].
+     *
+     * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1
+     * Microcode Default Value' section below.
+     */
+    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+    AdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1, scsi_cfg1 | DIS_TERM_DRV);
+
+    /*
+     * If the PCI Configuration Command Register "Parity Error Response
+     * Control" Bit was clear (0), then set the microcode variable
+     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
+     * to ignore DMA parity errors.
+     */
+    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+        word |= CONTROL_FLAG_IGNORE_PERR;
+        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+    }
+
+    /*
+     * If the BIOS control flag AIPP (Asynchronous Information
+     * Phase Protection) disable bit is not set, then set the firmware
+     * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable
+     * AIPP checking and encoding.
+     */
+    if ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+        word |= CONTROL_FLAG_ENABLE_AIPP;
+        AdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
+    }
+
+    /*
+     * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],
+     * and START_CTL_TH [3:2].
+     */
+    AdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,
+        FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);
+
+    /*
+     * Microcode operating variables for WDTR, SDTR, and command tag
+     * queuing will be set in AdvInquiryHandling() based on what a
+     * device reports it is capable of in Inquiry byte 7.
+     *
+     * If SCSI Bus Resets have been disabled, then directly set
+     * SDTR and WDTR from the EEPROM configuration. This will allow
+     * the BIOS and warm boot to work without a SCSI bus hang on
+     * the Inquiry caused by host and target mismatched DTR values.
+     * Without the SCSI Bus Reset, before an Inquiry a device can't
+     * be assumed to be in Asynchronous, Narrow mode.
+     */
+    if ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, asc_dvc->wdtr_able);
+        AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, asc_dvc->sdtr_able);
+    }
+
+    /*
+     * Set microcode operating variables for DISC and SDTR_SPEED1,
+     * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM
+     * configuration values.
+     *
+     * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,
+     * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them
+     * without determining here whether the device supports SDTR.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);
+
+    /*
+     * Set SCSI_CFG0 Microcode Default Value.
+     *
+     * The microcode will set the SCSI_CFG0 register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
+        PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |
+        asc_dvc->chip_scsi_id);
+
+    /*
+     * Calculate SCSI_CFG1 Microcode Default Value.
+     *
+     * The microcode will set the SCSI_CFG1 register using this value
+     * after it is started below.
+     *
+     * Each ASC-38C1600 function has only two cable detect bits.
+     * The bus mode override bits are in IOPB_SOFT_OVER_WR.
+     */
+    scsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);
+
+    /*
+     * If the cable is reversed all of the SCSI_CTRL register signals
+     * will be set. Check for and return an error if this condition is
+     * found.
+     */
+    if ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
+    {
+        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
+        return ADV_ERROR;
+    }
+
+    /*
+     * Each ASC-38C1600 function has two connectors. Only an HVD device
+     * can not be connected to either connector. An LVD device or SE device
+     * may be connected to either connecor. If an SE device is connected,
+     * then at most Ultra speed (20 Mhz) can be used on both connectors.
+     *
+     * If an HVD device is attached, return an error.
+     */
+    if (scsi_cfg1 & HVD)
+    {
+        asc_dvc->err_code |= ASC_IERR_HVD_DEVICE;
+        return ADV_ERROR;
+    }
+
+    /*
+     * Each function in the ASC-38C1600 uses only the SE cable detect and
+     * termination because there are two connectors for each function. Each
+     * function may use either LVD or SE mode. Corresponding the SE automatic
+     * termination control EEPROM bits are used for each function. Each
+     * function has its own EEPROM. If SE automatic control is enabled for
+     * the function, then set the termination value based on a table listed
+     * in a_condor.h.
+     *
+     * If manual termination is specified in the EEPROM for the function,
+     * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is
+     * ready to be 'ored' into SCSI_CFG1.
+     */
+    if ((asc_dvc->cfg->termination & TERM_SE) == 0)
+    {
+        /* SE automatic termination control is enabled. */
+        switch(scsi_cfg1 & C_DET_SE)
+        {
+            /* TERM_SE_HI: on, TERM_SE_LO: on */
+            case 0x1: case 0x2: case 0x3:
+                asc_dvc->cfg->termination |= TERM_SE;
+                break;
+
+            case 0x0:
+                if (ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) == 0)
+                {
+                    /* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */
+                }
+                else
+                {
+                    /* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */
+                    asc_dvc->cfg->termination |= TERM_SE_HI;
+                }
+                break;
+        }
+    }
+
+    /*
+     * Clear any set TERM_SE bits.
+     */
+    scsi_cfg1 &= ~TERM_SE;
+
+    /*
+     * Invert the TERM_SE bits and then set 'scsi_cfg1'.
+     */
+    scsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);
+
+    /*
+     * Clear Big Endian and Terminator Polarity bits and set possibly
+     * modified termination control bits in the Microcode SCSI_CFG1
+     * Register Value.
+     *
+     * Big Endian bit is not used even on big endian machines.
+     */
+    scsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);
+
+    /*
+     * Set SCSI_CFG1 Microcode Default Value
+     *
+     * Set possibly modified termination control bits in the Microcode
+     * SCSI_CFG1 Register Value.
+     *
+     * The microcode will set the SCSI_CFG1 register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);
+
+    /*
+     * Set MEM_CFG Microcode Default Value
+     *
+     * The microcode will set the MEM_CFG register using this value
+     * after it is started below.
+     *
+     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
+     * are defined.
+     *
+     * ASC-38C1600 has 32KB internal memory.
+     *
+     * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come
+     * out a special 16K Adv Library and Microcode version. After the issue
+     * resolved, we should turn back to the 32K support. Both a_condor.h and
+     * mcode.sas files also need to be updated.
+     *
+     * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
+     *  BIOS_EN | RAM_SZ_32KB);
+     */
+     AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG, BIOS_EN | RAM_SZ_16KB);
+
+    /*
+     * Set SEL_MASK Microcode Default Value
+     *
+     * The microcode will set the SEL_MASK register using this value
+     * after it is started below.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
+        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));
+
+    /*
+     * Build the carrier freelist.
+     *
+     * Driver must have already allocated memory and set 'carrier_buf'.
+     */
+
+    ASC_ASSERT(asc_dvc->carrier_buf != NULL);
+
+    carrp = (ADV_CARR_T *) ADV_16BALIGN(asc_dvc->carrier_buf);
+    asc_dvc->carr_freelist = NULL;
+    if (carrp == (ADV_CARR_T *) asc_dvc->carrier_buf)
+    {
+        buf_size = ADV_CARRIER_BUFSIZE;
+    } else
+    {
+        buf_size = ADV_CARRIER_BUFSIZE - sizeof(ADV_CARR_T);
+    }
+
+    do {
+        /*
+         * Get physical address for the carrier 'carrp'.
+         */
+        contig_len = sizeof(ADV_CARR_T);
+        carr_paddr = cpu_to_le32(DvcGetPhyAddr(asc_dvc, NULL, (uchar *) carrp,
+            (ADV_SDCNT *) &contig_len, ADV_IS_CARRIER_FLAG));
+
+        buf_size -= sizeof(ADV_CARR_T);
+
+        /*
+         * If the current carrier is not physically contiguous, then
+         * maybe there was a page crossing. Try the next carrier aligned
+         * start address.
+         */
+        if (contig_len < sizeof(ADV_CARR_T))
+        {
+            carrp++;
+            continue;
+        }
+
+        carrp->carr_pa = carr_paddr;
+        carrp->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(carrp));
+
+        /*
+         * Insert the carrier at the beginning of the freelist.
+         */
+        carrp->next_vpa = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+        asc_dvc->carr_freelist = carrp;
+
+        carrp++;
+    }
+    while (buf_size > 0);
+
+    /*
+     * Set-up the Host->RISC Initiator Command Queue (ICQ).
+     */
+    if ((asc_dvc->icq_sp = asc_dvc->carr_freelist) == NULL)
+    {
+        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+        return ADV_ERROR;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->icq_sp->next_vpa));
+
+    /*
+     * The first command issued will be placed in the stopper carrier.
+     */
+    asc_dvc->icq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Set RISC ICQ physical address start value. Initialize the
+     * COMMA register to the same value otherwise the RISC will
+     * prematurely detect a command is available.
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);
+    AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
+        le32_to_cpu(asc_dvc->icq_sp->carr_pa));
+
+    /*
+     * Set-up the RISC->Host Initiator Response Queue (IRQ).
+     */
+    if ((asc_dvc->irq_sp = asc_dvc->carr_freelist) == NULL)
+    {
+        asc_dvc->err_code |= ASC_IERR_NO_CARRIER;
+        return ADV_ERROR;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+        ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->next_vpa));
+
+    /*
+     * The first command completed by the RISC will be placed in
+     * the stopper.
+     *
+     * Note: Set 'next_vpa' to ASC_CQ_STOPPER. When the request is
+     * completed the RISC will set the ASC_RQ_STOPPER bit.
+     */
+    asc_dvc->irq_sp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Set RISC IRQ physical address start value.
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);
+    asc_dvc->carr_pending_cnt = 0;
+
+    AdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
+        (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
+    AdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);
+    AdvWriteWordRegister(iop_base, IOPW_PC, word);
+
+    /* finally, finally, gentlemen, start your engine */
+    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);
+
+    /*
+     * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
+     * Resets should be performed. The RISC has to be running
+     * to issue a SCSI Bus Reset.
+     */
+    if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
+    {
+        /*
+         * If the BIOS Signature is present in memory, restore the
+         * per TID microcode operating variables.
+         */
+        if (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM)/2] == 0x55AA)
+        {
+            /*
+             * Restore per TID negotiated values.
+             */
+            AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+            for (tid = 0; tid <= ASC_MAX_TID; tid++)
+            {
+                AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+                    max_cmd[tid]);
+            }
+        } else
+        {
+            if (AdvResetSB(asc_dvc) != ADV_TRUE)
+            {
+                warn_code = ASC_WARN_BUSRESET_ERROR;
+            }
+        }
+    }
+
+    return warn_code;
+}
+
+/*
+ * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
+ * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Note: Chip is stopped on entry.
+ */
+STATIC int __init
+AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr         iop_base;
+    ushort              warn_code;
+    ADVEEP_3550_CONFIG  eep_config;
+    int                 i;
+
+    iop_base = asc_dvc->iop_base;
+
+    warn_code = 0;
+
+    /*
+     * Read the board's EEPROM configuration.
+     *
+     * Set default values if a bad checksum is found.
+     */
+    if (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum)
+    {
+        warn_code |= ASC_WARN_EEPROM_CHKSUM;
+
+        /*
+         * Set EEPROM default values.
+         */
+        for (i = 0; i < sizeof(ADVEEP_3550_CONFIG); i++)
+        {
+            *((uchar *) &eep_config + i) =
+                *((uchar *) &Default_3550_EEPROM_Config + i);
+        }
+
+        /*
+         * Assume the 6 byte board serial number that was read
+         * from EEPROM is correct even if the EEPROM checksum
+         * failed.
+         */
+        eep_config.serial_number_word3 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
+
+        eep_config.serial_number_word2 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
+
+        eep_config.serial_number_word1 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+
+        AdvSet3550EEPConfig(iop_base, &eep_config);
+    }
+    /*
+     * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
+     * EEPROM configuration that was read.
+     *
+     * This is the mapping of EEPROM fields to Adv Library fields.
+     */
+    asc_dvc->wdtr_able = eep_config.wdtr_able;
+    asc_dvc->sdtr_able = eep_config.sdtr_able;
+    asc_dvc->ultra_able = eep_config.ultra_able;
+    asc_dvc->tagqng_able = eep_config.tagqng_able;
+    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+    asc_dvc->max_host_qng = eep_config.max_host_qng;
+    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
+    asc_dvc->start_motor = eep_config.start_motor;
+    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+    asc_dvc->no_scam = eep_config.scam_tolerant;
+    asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
+    asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
+    asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
+
+    /*
+     * Set the host maximum queuing (max. 253, min. 16) and the per device
+     * maximum queuing (max. 63, min. 4).
+     */
+    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
+    {
+        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
+    {
+        /* If the value is zero, assume it is uninitialized. */
+        if (eep_config.max_host_qng == 0)
+        {
+            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+        } else
+        {
+            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+        }
+    }
+
+    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
+    {
+        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
+    {
+        /* If the value is zero, assume it is uninitialized. */
+        if (eep_config.max_dvc_qng == 0)
+        {
+            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+        } else
+        {
+            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+        }
+    }
+
+    /*
+     * If 'max_dvc_qng' is greater than 'max_host_qng', then
+     * set 'max_dvc_qng' to 'max_host_qng'.
+     */
+    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
+    {
+        eep_config.max_dvc_qng = eep_config.max_host_qng;
+    }
+
+    /*
+     * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
+     * values based on possibly adjusted EEPROM values.
+     */
+    asc_dvc->max_host_qng = eep_config.max_host_qng;
+    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+
+    /*
+     * If the EEPROM 'termination' field is set to automatic (0), then set
+     * the ADV_DVC_CFG 'termination' field to automatic also.
+     *
+     * If the termination is specified with a non-zero 'termination'
+     * value check that a legal value is set and set the ADV_DVC_CFG
+     * 'termination' field appropriately.
+     */
+    if (eep_config.termination == 0)
+    {
+        asc_dvc->cfg->termination = 0;    /* auto termination */
+    } else
+    {
+        /* Enable manual control with low off / high off. */
+        if (eep_config.termination == 1)
+        {
+            asc_dvc->cfg->termination = TERM_CTL_SEL;
+
+        /* Enable manual control with low off / high on. */
+        } else if (eep_config.termination == 2)
+        {
+            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;
+
+        /* Enable manual control with low on / high on. */
+        } else if (eep_config.termination == 3)
+        {
+            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
+        } else
+        {
+            /*
+             * The EEPROM 'termination' field contains a bad value. Use
+             * automatic termination instead.
+             */
+            asc_dvc->cfg->termination = 0;
+            warn_code |= ASC_WARN_EEPROM_TERMINATION;
+        }
+    }
+
+    return warn_code;
+}
+
+/*
+ * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and
+ * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
+ *
+ * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Note: Chip is stopped on entry.
+ */
+STATIC int __init
+AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr              iop_base;
+    ushort                   warn_code;
+    ADVEEP_38C0800_CONFIG    eep_config;
+    int                      i;
+    uchar                    tid, termination;
+    ushort                   sdtr_speed = 0;
+
+    iop_base = asc_dvc->iop_base;
+
+    warn_code = 0;
+
+    /*
+     * Read the board's EEPROM configuration.
+     *
+     * Set default values if a bad checksum is found.
+     */
+    if (AdvGet38C0800EEPConfig(iop_base, &eep_config) != eep_config.check_sum)
+    {
+        warn_code |= ASC_WARN_EEPROM_CHKSUM;
+
+        /*
+         * Set EEPROM default values.
+         */
+        for (i = 0; i < sizeof(ADVEEP_38C0800_CONFIG); i++)
+        {
+            *((uchar *) &eep_config + i) =
+                *((uchar *) &Default_38C0800_EEPROM_Config + i);
+        }
+
+        /*
+         * Assume the 6 byte board serial number that was read
+         * from EEPROM is correct even if the EEPROM checksum
+         * failed.
+         */
+        eep_config.serial_number_word3 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
+
+        eep_config.serial_number_word2 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
+
+        eep_config.serial_number_word1 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+
+        AdvSet38C0800EEPConfig(iop_base, &eep_config);
+    }
+    /*
+     * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the
+     * EEPROM configuration that was read.
+     *
+     * This is the mapping of EEPROM fields to Adv Library fields.
+     */
+    asc_dvc->wdtr_able = eep_config.wdtr_able;
+    asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
+    asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
+    asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
+    asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
+    asc_dvc->tagqng_able = eep_config.tagqng_able;
+    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+    asc_dvc->max_host_qng = eep_config.max_host_qng;
+    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);
+    asc_dvc->start_motor = eep_config.start_motor;
+    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+    asc_dvc->no_scam = eep_config.scam_tolerant;
+    asc_dvc->cfg->serial1 = eep_config.serial_number_word1;
+    asc_dvc->cfg->serial2 = eep_config.serial_number_word2;
+    asc_dvc->cfg->serial3 = eep_config.serial_number_word3;
+
+    /*
+     * For every Target ID if any of its 'sdtr_speed[1234]' bits
+     * are set, then set an 'sdtr_able' bit for it.
+     */
+    asc_dvc->sdtr_able = 0;
+    for (tid = 0; tid <= ADV_MAX_TID; tid++)
+    {
+        if (tid == 0)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed1;
+        } else if (tid == 4)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed2;
+        } else if (tid == 8)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed3;
+        } else if (tid == 12)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed4;
+        }
+        if (sdtr_speed & ADV_MAX_TID)
+        {
+            asc_dvc->sdtr_able |= (1 << tid);
+        }
+        sdtr_speed >>= 4;
+    }
+
+    /*
+     * Set the host maximum queuing (max. 253, min. 16) and the per device
+     * maximum queuing (max. 63, min. 4).
+     */
+    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
+    {
+        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
+    {
+        /* If the value is zero, assume it is uninitialized. */
+        if (eep_config.max_host_qng == 0)
+        {
+            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+        } else
+        {
+            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+        }
+    }
+
+    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
+    {
+        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
+    {
+        /* If the value is zero, assume it is uninitialized. */
+        if (eep_config.max_dvc_qng == 0)
+        {
+            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+        } else
+        {
+            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+        }
+    }
+
+    /*
+     * If 'max_dvc_qng' is greater than 'max_host_qng', then
+     * set 'max_dvc_qng' to 'max_host_qng'.
+     */
+    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
+    {
+        eep_config.max_dvc_qng = eep_config.max_host_qng;
+    }
+
+    /*
+     * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'
+     * values based on possibly adjusted EEPROM values.
+     */
+    asc_dvc->max_host_qng = eep_config.max_host_qng;
+    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+    /*
+     * If the EEPROM 'termination' field is set to automatic (0), then set
+     * the ADV_DVC_CFG 'termination' field to automatic also.
+     *
+     * If the termination is specified with a non-zero 'termination'
+     * value check that a legal value is set and set the ADV_DVC_CFG
+     * 'termination' field appropriately.
+     */
+    if (eep_config.termination_se == 0)
+    {
+        termination = 0;                         /* auto termination for SE */
+    } else
+    {
+        /* Enable manual control with low off / high off. */
+        if (eep_config.termination_se == 1)
+        {
+            termination = 0;
+
+        /* Enable manual control with low off / high on. */
+        } else if (eep_config.termination_se == 2)
+        {
+            termination = TERM_SE_HI;
+
+        /* Enable manual control with low on / high on. */
+        } else if (eep_config.termination_se == 3)
+        {
+            termination = TERM_SE;
+        } else
+        {
+            /*
+             * The EEPROM 'termination_se' field contains a bad value.
+             * Use automatic termination instead.
+             */
+            termination = 0;
+            warn_code |= ASC_WARN_EEPROM_TERMINATION;
+        }
+    }
+
+    if (eep_config.termination_lvd == 0)
+    {
+        asc_dvc->cfg->termination = termination; /* auto termination for LVD */
+    } else
+    {
+        /* Enable manual control with low off / high off. */
+        if (eep_config.termination_lvd == 1)
+        {
+            asc_dvc->cfg->termination = termination;
+
+        /* Enable manual control with low off / high on. */
+        } else if (eep_config.termination_lvd == 2)
+        {
+            asc_dvc->cfg->termination = termination | TERM_LVD_HI;
+
+        /* Enable manual control with low on / high on. */
+        } else if (eep_config.termination_lvd == 3)
+        {
+            asc_dvc->cfg->termination =
+                termination | TERM_LVD;
+        } else
+        {
+            /*
+             * The EEPROM 'termination_lvd' field contains a bad value.
+             * Use automatic termination instead.
+             */
+            asc_dvc->cfg->termination = termination;
+            warn_code |= ASC_WARN_EEPROM_TERMINATION;
+        }
+    }
+
+    return warn_code;
+}
+
+/*
+ * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and
+ * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
+ * all of this is done.
+ *
+ * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
+ *
+ * For a non-fatal error return a warning code. If there are no warnings
+ * then 0 is returned.
+ *
+ * Note: Chip is stopped on entry.
+ */
+STATIC int __init
+AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr              iop_base;
+    ushort                   warn_code;
+    ADVEEP_38C1600_CONFIG    eep_config;
+    int                      i;
+    uchar                    tid, termination;
+    ushort                   sdtr_speed = 0;
+
+    iop_base = asc_dvc->iop_base;
+
+    warn_code = 0;
+
+    /*
+     * Read the board's EEPROM configuration.
+     *
+     * Set default values if a bad checksum is found.
+     */
+    if (AdvGet38C1600EEPConfig(iop_base, &eep_config) != eep_config.check_sum)
+    {
+        warn_code |= ASC_WARN_EEPROM_CHKSUM;
+
+        /*
+         * Set EEPROM default values.
+         */
+        for (i = 0; i < sizeof(ADVEEP_38C1600_CONFIG); i++)
+        {
+            if (i == 1 && ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info) != 0)
+            {
+                /*
+                 * Set Function 1 EEPROM Word 0 MSB
+                 *
+                 * Clear the BIOS_ENABLE (bit 14) and INTAB (bit 11)
+                 * EEPROM bits.
+                 *
+                 * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60 and
+                 * old Mac system booting problem. The Expansion ROM must
+                 * be disabled in Function 1 for these systems.
+                 *
+                 */
+                *((uchar *) &eep_config + i) =
+                ((*((uchar *) &Default_38C1600_EEPROM_Config + i)) &
+                    (~(((ADV_EEPROM_BIOS_ENABLE | ADV_EEPROM_INTAB) >> 8) &
+                     0xFF)));
+
+                /*
+                 * Set the INTAB (bit 11) if the GPIO 0 input indicates
+                 * the Function 1 interrupt line is wired to INTA.
+                 *
+                 * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:
+                 *   1 - Function 1 interrupt line wired to INT A.
+                 *   0 - Function 1 interrupt line wired to INT B.
+                 *
+                 * Note: Adapter boards always have Function 0 wired to INTA.
+                 * Put all 5 GPIO bits in input mode and then read
+                 * their input values.
+                 */
+                AdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);
+                if (AdvReadByteRegister(iop_base, IOPB_GPIO_DATA) & 0x01)
+                {
+                    /* Function 1 interrupt wired to INTA; Set EEPROM bit. */
+                *((uchar *) &eep_config + i) |=
+                    ((ADV_EEPROM_INTAB >> 8) & 0xFF);
+                }
+            }
+            else
+            {
+                *((uchar *) &eep_config + i) =
+                *((uchar *) &Default_38C1600_EEPROM_Config + i);
+            }
+        }
+
+        /*
+         * Assume the 6 byte board serial number that was read
+         * from EEPROM is correct even if the EEPROM checksum
+         * failed.
+         */
+        eep_config.serial_number_word3 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);
+
+        eep_config.serial_number_word2 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);
+
+        eep_config.serial_number_word1 =
+            AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);
+
+        AdvSet38C1600EEPConfig(iop_base, &eep_config);
+    }
+
+    /*
+     * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
+     * EEPROM configuration that was read.
+     *
+     * This is the mapping of EEPROM fields to Adv Library fields.
+     */
+    asc_dvc->wdtr_able = eep_config.wdtr_able;
+    asc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;
+    asc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;
+    asc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;
+    asc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;
+    asc_dvc->ppr_able = 0;
+    asc_dvc->tagqng_able = eep_config.tagqng_able;
+    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
+    asc_dvc->max_host_qng = eep_config.max_host_qng;
+    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
+    asc_dvc->start_motor = eep_config.start_motor;
+    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
+    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
+    asc_dvc->no_scam = eep_config.scam_tolerant;
+
+    /*
+     * For every Target ID if any of its 'sdtr_speed[1234]' bits
+     * are set, then set an 'sdtr_able' bit for it.
+     */
+    asc_dvc->sdtr_able = 0;
+    for (tid = 0; tid <= ASC_MAX_TID; tid++)
+    {
+        if (tid == 0)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed1;
+        } else if (tid == 4)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed2;
+        } else if (tid == 8)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed3;
+        } else if (tid == 12)
+        {
+            sdtr_speed = asc_dvc->sdtr_speed4;
+        }
+        if (sdtr_speed & ASC_MAX_TID)
+        {
+            asc_dvc->sdtr_able |= (1 << tid);
+        }
+        sdtr_speed >>= 4;
+    }
+
+    /*
+     * Set the host maximum queuing (max. 253, min. 16) and the per device
+     * maximum queuing (max. 63, min. 4).
+     */
+    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
+    {
+        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
+    {
+        /* If the value is zero, assume it is uninitialized. */
+        if (eep_config.max_host_qng == 0)
+        {
+            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
+        } else
+        {
+            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
+        }
+    }
+
+    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
+    {
+        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
+    {
+        /* If the value is zero, assume it is uninitialized. */
+        if (eep_config.max_dvc_qng == 0)
+        {
+            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
+        } else
+        {
+            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
+        }
+    }
+
+    /*
+     * If 'max_dvc_qng' is greater than 'max_host_qng', then
+     * set 'max_dvc_qng' to 'max_host_qng'.
+     */
+    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
+    {
+        eep_config.max_dvc_qng = eep_config.max_host_qng;
+    }
+
+    /*
+     * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'
+     * values based on possibly adjusted EEPROM values.
+     */
+    asc_dvc->max_host_qng = eep_config.max_host_qng;
+    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
+
+    /*
+     * If the EEPROM 'termination' field is set to automatic (0), then set
+     * the ASC_DVC_CFG 'termination' field to automatic also.
+     *
+     * If the termination is specified with a non-zero 'termination'
+     * value check that a legal value is set and set the ASC_DVC_CFG
+     * 'termination' field appropriately.
+     */
+    if (eep_config.termination_se == 0)
+    {
+        termination = 0;                         /* auto termination for SE */
+    } else
+    {
+        /* Enable manual control with low off / high off. */
+        if (eep_config.termination_se == 1)
+        {
+            termination = 0;
+
+        /* Enable manual control with low off / high on. */
+        } else if (eep_config.termination_se == 2)
+        {
+            termination = TERM_SE_HI;
+
+        /* Enable manual control with low on / high on. */
+        } else if (eep_config.termination_se == 3)
+        {
+            termination = TERM_SE;
+        } else
+        {
+            /*
+             * The EEPROM 'termination_se' field contains a bad value.
+             * Use automatic termination instead.
+             */
+            termination = 0;
+            warn_code |= ASC_WARN_EEPROM_TERMINATION;
+        }
+    }
+
+    if (eep_config.termination_lvd == 0)
+    {
+        asc_dvc->cfg->termination = termination; /* auto termination for LVD */
+    } else
+    {
+        /* Enable manual control with low off / high off. */
+        if (eep_config.termination_lvd == 1)
+        {
+            asc_dvc->cfg->termination = termination;
+
+        /* Enable manual control with low off / high on. */
+        } else if (eep_config.termination_lvd == 2)
+        {
+            asc_dvc->cfg->termination = termination | TERM_LVD_HI;
+
+        /* Enable manual control with low on / high on. */
+        } else if (eep_config.termination_lvd == 3)
+        {
+            asc_dvc->cfg->termination =
+                termination | TERM_LVD;
+        } else
+        {
+            /*
+             * The EEPROM 'termination_lvd' field contains a bad value.
+             * Use automatic termination instead.
+             */
+            asc_dvc->cfg->termination = termination;
+            warn_code |= ASC_WARN_EEPROM_TERMINATION;
+        }
+    }
+
+    return warn_code;
+}
+
+/*
+ * Read EEPROM configuration into the specified buffer.
+ *
+ * Return a checksum based on the EEPROM configuration read.
+ */
+STATIC ushort __init
+AdvGet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
+{
+    ushort              wval, chksum;
+    ushort              *wbuf;
+    int                 eep_addr;
+    ushort              *charfields;
+
+    charfields = (ushort *) &ADVEEP_3550_Config_Field_IsChar;
+    wbuf = (ushort *) cfg_buf;
+    chksum = 0;
+
+    for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+         eep_addr < ADV_EEP_DVC_CFG_END;
+         eep_addr++, wbuf++)
+    {
+        wval = AdvReadEEPWord(iop_base, eep_addr);
+        chksum += wval; /* Checksum is calculated from word values. */
+        if (*charfields++) {
+            *wbuf = le16_to_cpu(wval);
+        } else {
+            *wbuf = wval;
+        }
+    }
+    /* Read checksum word. */
+    *wbuf = AdvReadEEPWord(iop_base, eep_addr);
+    wbuf++; charfields++;
+
+    /* Read rest of EEPROM not covered by the checksum. */
+    for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+         eep_addr < ADV_EEP_MAX_WORD_ADDR;
+         eep_addr++, wbuf++)
+    {
+        *wbuf = AdvReadEEPWord(iop_base, eep_addr);
+        if (*charfields++) {
+            *wbuf = le16_to_cpu(*wbuf);
+        }
+    }
+    return chksum;
+}
+
+/*
+ * Read EEPROM configuration into the specified buffer.
+ *
+ * Return a checksum based on the EEPROM configuration read.
+ */
+STATIC ushort __init
+AdvGet38C0800EEPConfig(AdvPortAddr iop_base,
+                       ADVEEP_38C0800_CONFIG *cfg_buf)
+{
+    ushort              wval, chksum;
+    ushort              *wbuf;
+    int                 eep_addr;
+    ushort              *charfields;
+
+    charfields = (ushort *) &ADVEEP_38C0800_Config_Field_IsChar;
+    wbuf = (ushort *) cfg_buf;
+    chksum = 0;
+
+    for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+         eep_addr < ADV_EEP_DVC_CFG_END;
+         eep_addr++, wbuf++)
+    {
+        wval = AdvReadEEPWord(iop_base, eep_addr);
+        chksum += wval; /* Checksum is calculated from word values. */
+        if (*charfields++) {
+            *wbuf = le16_to_cpu(wval);
+        } else {
+            *wbuf = wval;
+        }
+    }
+    /* Read checksum word. */
+    *wbuf = AdvReadEEPWord(iop_base, eep_addr);
+    wbuf++; charfields++;
+
+    /* Read rest of EEPROM not covered by the checksum. */
+    for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+         eep_addr < ADV_EEP_MAX_WORD_ADDR;
+         eep_addr++, wbuf++)
+    {
+        *wbuf = AdvReadEEPWord(iop_base, eep_addr);
+        if (*charfields++) {
+            *wbuf = le16_to_cpu(*wbuf);
+        }
+    }
+    return chksum;
+}
+
+/*
+ * Read EEPROM configuration into the specified buffer.
+ *
+ * Return a checksum based on the EEPROM configuration read.
+ */
+STATIC ushort __init
+AdvGet38C1600EEPConfig(AdvPortAddr iop_base,
+                       ADVEEP_38C1600_CONFIG *cfg_buf)
+{
+    ushort              wval, chksum;
+    ushort              *wbuf;
+    int                 eep_addr;
+    ushort              *charfields;
+
+    charfields = (ushort*) &ADVEEP_38C1600_Config_Field_IsChar;
+    wbuf = (ushort *) cfg_buf;
+    chksum = 0;
+
+    for (eep_addr = ADV_EEP_DVC_CFG_BEGIN;
+         eep_addr < ADV_EEP_DVC_CFG_END;
+         eep_addr++, wbuf++)
+    {
+        wval = AdvReadEEPWord(iop_base, eep_addr);
+        chksum += wval; /* Checksum is calculated from word values. */
+        if (*charfields++) {
+            *wbuf = le16_to_cpu(wval);
+        } else {
+            *wbuf = wval;
+        }
+    }
+    /* Read checksum word. */
+    *wbuf = AdvReadEEPWord(iop_base, eep_addr);
+    wbuf++; charfields++;
+
+    /* Read rest of EEPROM not covered by the checksum. */
+    for (eep_addr = ADV_EEP_DVC_CTL_BEGIN;
+         eep_addr < ADV_EEP_MAX_WORD_ADDR;
+         eep_addr++, wbuf++)
+    {
+        *wbuf = AdvReadEEPWord(iop_base, eep_addr);
+        if (*charfields++) {
+            *wbuf = le16_to_cpu(*wbuf);
+        }
+    }
+    return chksum;
+}
+
+/*
+ * Read the EEPROM from specified location
+ */
+STATIC ushort __init
+AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)
+{
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD,
+        ASC_EEP_CMD_READ | eep_word_addr);
+    AdvWaitEEPCmd(iop_base);
+    return AdvReadWordRegister(iop_base, IOPW_EE_DATA);
+}
+
+/*
+ * Wait for EEPROM command to complete
+ */
+STATIC void __init
+AdvWaitEEPCmd(AdvPortAddr iop_base)
+{
+    int eep_delay_ms;
+
+    for (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++)
+    {
+        if (AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE)
+        {
+            break;
+        }
+        DvcSleepMilliSecond(1);
+    }
+    if ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) == 0)
+    {
+        ASC_ASSERT(0);
+    }
+    return;
+}
+
+/*
+ * Write the EEPROM from 'cfg_buf'.
+ */
+void
+AdvSet3550EEPConfig(AdvPortAddr iop_base, ADVEEP_3550_CONFIG *cfg_buf)
+{
+    ushort *wbuf;
+    ushort addr, chksum;
+    ushort *charfields;
+
+    wbuf = (ushort *) cfg_buf;
+    charfields = (ushort *) &ADVEEP_3550_Config_Field_IsChar;
+    chksum = 0;
+
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+    AdvWaitEEPCmd(iop_base);
+
+    /*
+     * Write EEPROM from word 0 to word 20.
+     */
+    for (addr = ADV_EEP_DVC_CFG_BEGIN;
+         addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++)
+    {
+        ushort word;
+
+        if (*charfields++) {
+            word = cpu_to_le16(*wbuf);
+        } else {
+            word = *wbuf;
+        }
+        chksum += *wbuf; /* Checksum is calculated from word values. */
+        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+        AdvWaitEEPCmd(iop_base);
+        DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+    }
+
+    /*
+     * Write EEPROM checksum at word 21.
+     */
+    AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+    AdvWaitEEPCmd(iop_base);
+    wbuf++; charfields++;
+
+    /*
+     * Write EEPROM OEM name at words 22 to 29.
+     */
+    for (addr = ADV_EEP_DVC_CTL_BEGIN;
+         addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++)
+    {
+        ushort word;
+
+        if (*charfields++) {
+            word = cpu_to_le16(*wbuf);
+        } else {
+            word = *wbuf;
+        }
+        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+        AdvWaitEEPCmd(iop_base);
+    }
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+    AdvWaitEEPCmd(iop_base);
+    return;
+}
+
+/*
+ * Write the EEPROM from 'cfg_buf'.
+ */
+void
+AdvSet38C0800EEPConfig(AdvPortAddr iop_base,
+                       ADVEEP_38C0800_CONFIG *cfg_buf)
+{
+    ushort *wbuf;
+    ushort *charfields;
+    ushort addr, chksum;
+
+    wbuf = (ushort *) cfg_buf;
+    charfields = (ushort *) &ADVEEP_38C0800_Config_Field_IsChar;
+    chksum = 0;
+
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+    AdvWaitEEPCmd(iop_base);
+
+    /*
+     * Write EEPROM from word 0 to word 20.
+     */
+    for (addr = ADV_EEP_DVC_CFG_BEGIN;
+         addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++)
+    {
+        ushort word;
+
+        if (*charfields++) {
+            word = cpu_to_le16(*wbuf);
+        } else {
+            word = *wbuf;
+        }
+        chksum += *wbuf; /* Checksum is calculated from word values. */
+        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+        AdvWaitEEPCmd(iop_base);
+        DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+    }
+
+    /*
+     * Write EEPROM checksum at word 21.
+     */
+    AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+    AdvWaitEEPCmd(iop_base);
+    wbuf++; charfields++;
+
+    /*
+     * Write EEPROM OEM name at words 22 to 29.
+     */
+    for (addr = ADV_EEP_DVC_CTL_BEGIN;
+         addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++)
+    {
+        ushort word;
+
+        if (*charfields++) {
+            word = cpu_to_le16(*wbuf);
+        } else {
+            word = *wbuf;
+        }
+        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+        AdvWaitEEPCmd(iop_base);
+    }
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+    AdvWaitEEPCmd(iop_base);
+    return;
+}
+
+/*
+ * Write the EEPROM from 'cfg_buf'.
+ */
+void
+AdvSet38C1600EEPConfig(AdvPortAddr iop_base,
+                       ADVEEP_38C1600_CONFIG *cfg_buf)
+{
+    ushort              *wbuf;
+    ushort              *charfields;
+    ushort              addr, chksum;
+
+    wbuf = (ushort *) cfg_buf;
+    charfields = (ushort *) &ADVEEP_38C1600_Config_Field_IsChar;
+    chksum = 0;
+
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
+    AdvWaitEEPCmd(iop_base);
+
+    /*
+     * Write EEPROM from word 0 to word 20.
+     */
+    for (addr = ADV_EEP_DVC_CFG_BEGIN;
+         addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++)
+    {
+        ushort word;
+
+        if (*charfields++) {
+            word = cpu_to_le16(*wbuf);
+        } else {
+            word = *wbuf;
+        }
+        chksum += *wbuf; /* Checksum is calculated from word values. */
+        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+        AdvWaitEEPCmd(iop_base);
+        DvcSleepMilliSecond(ADV_EEP_DELAY_MS);
+    }
+
+    /*
+     * Write EEPROM checksum at word 21.
+     */
+    AdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+    AdvWaitEEPCmd(iop_base);
+    wbuf++; charfields++;
+
+    /*
+     * Write EEPROM OEM name at words 22 to 29.
+     */
+    for (addr = ADV_EEP_DVC_CTL_BEGIN;
+         addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++)
+    {
+        ushort word;
+
+        if (*charfields++) {
+            word = cpu_to_le16(*wbuf);
+        } else {
+            word = *wbuf;
+        }
+        AdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);
+        AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
+        AdvWaitEEPCmd(iop_base);
+    }
+    AdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
+    AdvWaitEEPCmd(iop_base);
+    return;
+}
+
+/* a_advlib.c */
+/*
+ * AdvExeScsiQueue() - Send a request to the RISC microcode program.
+ *
+ *   Allocate a carrier structure, point the carrier to the ADV_SCSI_REQ_Q,
+ *   add the carrier to the ICQ (Initiator Command Queue), and tickle the
+ *   RISC to notify it a new command is ready to be executed.
+ *
+ * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
+ * set to SCSI_MAX_RETRY.
+ *
+ * Multi-byte fields in the ASC_SCSI_REQ_Q that are used by the microcode
+ * for DMA addresses or math operations are byte swapped to little-endian
+ * order.
+ *
+ * Return:
+ *      ADV_SUCCESS(1) - The request was successfully queued.
+ *      ADV_BUSY(0) -    Resource unavailable; Retry again after pending
+ *                       request completes.
+ *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure
+ *                       host IC error.
+ */
+STATIC int
+AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc,
+                ADV_SCSI_REQ_Q *scsiq)
+{
+    ulong                  last_int_level;
+    AdvPortAddr            iop_base;
+    ADV_DCNT               req_size;
+    ADV_PADDR              req_paddr;
+    ADV_CARR_T             *new_carrp;
+
+    ASC_ASSERT(scsiq != NULL); /* 'scsiq' should never be NULL. */
+
+    /*
+     * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.
+     */
+    if (scsiq->target_id > ADV_MAX_TID)
+    {
+        scsiq->host_status = QHSTA_M_INVALID_DEVICE;
+        scsiq->done_status = QD_WITH_ERROR;
+        return ADV_ERROR;
+    }
+
+    iop_base = asc_dvc->iop_base;
+
+    last_int_level = DvcEnterCritical();
+
+    /*
+     * Allocate a carrier ensuring at least one carrier always
+     * remains on the freelist and initialize fields.
+     */
+    if ((new_carrp = asc_dvc->carr_freelist) == NULL)
+    {
+       DvcLeaveCritical(last_int_level);
+       return ADV_BUSY;
+    }
+    asc_dvc->carr_freelist = (ADV_CARR_T *)
+        ADV_U32_TO_VADDR(le32_to_cpu(new_carrp->next_vpa));
+    asc_dvc->carr_pending_cnt++;
+
+    /*
+     * Set the carrier to be a stopper by setting 'next_vpa'
+     * to the stopper value. The current stopper will be changed
+     * below to point to the new stopper.
+     */
+    new_carrp->next_vpa = cpu_to_le32(ASC_CQ_STOPPER);
+
+    /*
+     * Clear the ADV_SCSI_REQ_Q done flag.
+     */
+    scsiq->a_flag &= ~ADV_SCSIQ_DONE;
+
+    req_size = sizeof(ADV_SCSI_REQ_Q);
+    req_paddr = DvcGetPhyAddr(asc_dvc, scsiq, (uchar *) scsiq,
+        (ADV_SDCNT *) &req_size, ADV_IS_SCSIQ_FLAG);
+
+    ASC_ASSERT(ADV_32BALIGN(req_paddr) == req_paddr);
+    ASC_ASSERT(req_size >= sizeof(ADV_SCSI_REQ_Q));
+
+    /* Wait for assertion before making little-endian */
+    req_paddr = cpu_to_le32(req_paddr);
+
+    /* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */
+    scsiq->scsiq_ptr = cpu_to_le32(ADV_VADDR_TO_U32(scsiq));
+    scsiq->scsiq_rptr = req_paddr;
+
+    scsiq->carr_va = cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->icq_sp));
+    /*
+     * Every ADV_CARR_T.carr_pa is byte swapped to little-endian
+     * order during initialization.
+     */
+    scsiq->carr_pa = asc_dvc->icq_sp->carr_pa;
+
+   /*
+    * Use the current stopper to send the ADV_SCSI_REQ_Q command to
+    * the microcode. The newly allocated stopper will become the new
+    * stopper.
+    */
+    asc_dvc->icq_sp->areq_vpa = req_paddr;
+
+    /*
+     * Set the 'next_vpa' pointer for the old stopper to be the
+     * physical address of the new stopper. The RISC can only
+     * follow physical addresses.
+     */
+    asc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;
+
+    /*
+     * Set the host adapter stopper pointer to point to the new carrier.
+     */
+    asc_dvc->icq_sp = new_carrp;
+
+    if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
+        asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        /*
+         * Tickle the RISC to tell it to read its Command Queue Head pointer.
+         */
+        AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
+        if (asc_dvc->chip_type == ADV_CHIP_ASC3550)
+        {
+            /*
+             * Clear the tickle value. In the ASC-3550 the RISC flag
+             * command 'clr_tickle_a' does not work unless the host
+             * value is cleared.
+             */
+            AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
+        }
+    } else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
+    {
+        /*
+         * Notify the RISC a carrier is ready by writing the physical
+         * address of the new carrier stopper to the COMMA register.
+         */
+        AdvWriteDWordRegister(iop_base, IOPDW_COMMA,
+                le32_to_cpu(new_carrp->carr_pa));
+    }
+
+    DvcLeaveCritical(last_int_level);
+
+    return ADV_SUCCESS;
+}
+
+/*
+ * Reset SCSI Bus and purge all outstanding requests.
+ *
+ * Return Value:
+ *      ADV_TRUE(1) -   All requests are purged and SCSI Bus is reset.
+ *      ADV_FALSE(0) -  Microcode command failed.
+ *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC
+ *                      may be hung which requires driver recovery.
+ */
+STATIC int
+AdvResetSB(ADV_DVC_VAR *asc_dvc)
+{
+    int         status;
+
+    /*
+     * Send the SCSI Bus Reset idle start idle command which asserts
+     * the SCSI Bus Reset signal.
+     */
+    status = AdvSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_SCSI_RESET_START, 0L);
+    if (status != ADV_TRUE)
+    {
+        return status;
+    }
+
+    /*
+     * Delay for the specified SCSI Bus Reset hold time.
+     *
+     * The hold time delay is done on the host because the RISC has no
+     * microsecond accurate timer.
+     */
+    DvcDelayMicroSecond(asc_dvc, (ushort) ASC_SCSI_RESET_HOLD_TIME_US);
+
+    /*
+     * Send the SCSI Bus Reset end idle command which de-asserts
+     * the SCSI Bus Reset signal and purges any pending requests.
+     */
+    status = AdvSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_SCSI_RESET_END, 0L);
+    if (status != ADV_TRUE)
+    {
+        return status;
+    }
+
+    DvcSleepMilliSecond((ADV_DCNT) asc_dvc->scsi_reset_wait * 1000);
+
+    return status;
+}
+
+/*
+ * Reset chip and SCSI Bus.
+ *
+ * Return Value:
+ *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.
+ *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.
+ */
+STATIC int
+AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)
+{
+    int         status;
+    ushort      wdtr_able, sdtr_able, tagqng_able;
+    ushort      ppr_able = 0;
+    uchar       tid, max_cmd[ADV_MAX_TID + 1];
+    AdvPortAddr iop_base;
+    ushort      bios_sig;
+
+    iop_base = asc_dvc->iop_base;
+
+    /*
+     * Save current per TID negotiated values.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+    AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+    if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
+    {
+        AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+    }
+    AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+    for (tid = 0; tid <= ADV_MAX_TID; tid++)
+    {
+        AdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+            max_cmd[tid]);
+    }
+
+    /*
+     * Force the AdvInitAsc3550/38C0800Driver() function to
+     * perform a SCSI Bus Reset by clearing the BIOS signature word.
+     * The initialization functions assumes a SCSI Bus Reset is not
+     * needed if the BIOS signature word is present.
+     */
+    AdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+    AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);
+
+    /*
+     * Stop chip and reset it.
+     */
+    AdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);
+    AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
+    DvcSleepMilliSecond(100);
+    AdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_WR_IO_REG);
+
+    /*
+     * Reset Adv Library error code, if any, and try
+     * re-initializing the chip.
+     */
+    asc_dvc->err_code = 0;
+    if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
+    {
+        status = AdvInitAsc38C1600Driver(asc_dvc);
+    }
+    else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
+    {
+        status = AdvInitAsc38C0800Driver(asc_dvc);
+    } else
+    {
+        status = AdvInitAsc3550Driver(asc_dvc);
+    }
+
+    /* Translate initialization return value to status value. */
+    if (status == 0)
+    {
+        status = ADV_TRUE;
+    } else
+    {
+        status = ADV_FALSE;
+    }
+
+    /*
+     * Restore the BIOS signature word.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);
+
+    /*
+     * Restore per TID negotiated values.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);
+    AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);
+    if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600)
+    {
+        AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);
+    }
+    AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);
+    for (tid = 0; tid <= ADV_MAX_TID; tid++)
+    {
+        AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+            max_cmd[tid]);
+    }
+
+    return status;
+}
+
+/*
+ * Adv Library Interrupt Service Routine
+ *
+ *  This function is called by a driver's interrupt service routine.
+ *  The function disables and re-enables interrupts.
+ *
+ *  When a microcode idle command is completed, the ADV_DVC_VAR
+ *  'idle_cmd_done' field is set to ADV_TRUE.
+ *
+ *  Note: AdvISR() can be called when interrupts are disabled or even
+ *  when there is no hardware interrupt condition present. It will
+ *  always check for completed idle commands and microcode requests.
+ *  This is an important feature that shouldn't be changed because it
+ *  allows commands to be completed from polling mode loops.
+ *
+ * Return:
+ *   ADV_TRUE(1) - interrupt was pending
+ *   ADV_FALSE(0) - no interrupt was pending
+ */
+STATIC int
+AdvISR(ADV_DVC_VAR *asc_dvc)
+{
+    AdvPortAddr                 iop_base;
+    uchar                       int_stat;
+    ushort                      target_bit;
+    ADV_CARR_T                  *free_carrp;
+    ADV_VADDR                   irq_next_vpa;
+    int                         flags;
+    ADV_SCSI_REQ_Q              *scsiq;
+
+    flags = DvcEnterCritical();
+
+    iop_base = asc_dvc->iop_base;
+
+    /* Reading the register clears the interrupt. */
+    int_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);
+
+    if ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |
+         ADV_INTR_STATUS_INTRC)) == 0)
+    {
+        DvcLeaveCritical(flags);
+        return ADV_FALSE;
+    }
+
+    /*
+     * Notify the driver of an asynchronous microcode condition by
+     * calling the ADV_DVC_VAR.async_callback function. The function
+     * is passed the microcode ASC_MC_INTRB_CODE byte value.
+     */
+    if (int_stat & ADV_INTR_STATUS_INTRB)
+    {
+        uchar intrb_code;
+
+        AdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);
+
+        if (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||
+            asc_dvc->chip_type == ADV_CHIP_ASC38C0800)
+        {
+            if (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&
+                asc_dvc->carr_pending_cnt != 0)
+            {
+                AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);
+                if (asc_dvc->chip_type == ADV_CHIP_ASC3550)
+                {
+                    AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
+                }
+            }
+        }
+
+        if (asc_dvc->async_callback != 0)
+        {
+            (*asc_dvc->async_callback)(asc_dvc, intrb_code);
+        }
+    }
+
+    /*
+     * Check if the IRQ stopper carrier contains a completed request.
+     */
+    while (((irq_next_vpa =
+             le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ASC_RQ_DONE) != 0)
+    {
+        /*
+         * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.
+         * The RISC will have set 'areq_vpa' to a virtual address.
+         *
+         * The firmware will have copied the ASC_SCSI_REQ_Q.scsiq_ptr
+         * field to the carrier ADV_CARR_T.areq_vpa field. The conversion
+         * below complements the conversion of ASC_SCSI_REQ_Q.scsiq_ptr'
+         * in AdvExeScsiQueue().
+         */
+        scsiq = (ADV_SCSI_REQ_Q *)
+            ADV_U32_TO_VADDR(le32_to_cpu(asc_dvc->irq_sp->areq_vpa));
+
+        /*
+         * Request finished with good status and the queue was not
+         * DMAed to host memory by the firmware. Set all status fields
+         * to indicate good status.
+         */
+        if ((irq_next_vpa & ASC_RQ_GOOD) != 0)
+        {
+            scsiq->done_status = QD_NO_ERROR;
+            scsiq->host_status = scsiq->scsi_status = 0;
+            scsiq->data_cnt = 0L;
+        }
+
+        /*
+         * Advance the stopper pointer to the next carrier
+         * ignoring the lower four bits. Free the previous
+         * stopper carrier.
+         */
+        free_carrp = asc_dvc->irq_sp;
+        asc_dvc->irq_sp = (ADV_CARR_T *)
+            ADV_U32_TO_VADDR(ASC_GET_CARRP(irq_next_vpa));
+
+        free_carrp->next_vpa =
+                cpu_to_le32(ADV_VADDR_TO_U32(asc_dvc->carr_freelist));
+        asc_dvc->carr_freelist = free_carrp;
+        asc_dvc->carr_pending_cnt--;
+
+        ASC_ASSERT(scsiq != NULL);
+        target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);
+
+        /*
+         * Clear request microcode control flag.
+         */
+        scsiq->cntl = 0;
+
+        /*
+         * If the command that completed was a SCSI INQUIRY and
+         * LUN 0 was sent the command, then process the INQUIRY
+         * command information for the device.
+         *
+         * Note: If data returned were either VPD or CmdDt data,
+         * don't process the INQUIRY command information for
+         * the device, otherwise may erroneously set *_able bits.
+         */
+        if (scsiq->done_status == QD_NO_ERROR &&
+            scsiq->cdb[0] == INQUIRY &&
+            scsiq->target_lun == 0 &&
+            (scsiq->cdb[1] & ADV_INQ_RTN_VPD_AND_CMDDT)
+                == ADV_INQ_RTN_STD_INQUIRY_DATA)
+        {
+            AdvInquiryHandling(asc_dvc, scsiq);
+        }
+
+        /*
+         * Notify the driver of the completed request by passing
+         * the ADV_SCSI_REQ_Q pointer to its callback function.
+         */
+        scsiq->a_flag |= ADV_SCSIQ_DONE;
+        (*asc_dvc->isr_callback)(asc_dvc, scsiq);
+        /*
+         * Note: After the driver callback function is called, 'scsiq'
+         * can no longer be referenced.
+         *
+         * Fall through and continue processing other completed
+         * requests...
+         */
+
+        /*
+         * Disable interrupts again in case the driver inadvertently
+         * enabled interrupts in its callback function.
+         *
+         * The DvcEnterCritical() return value is ignored, because
+         * the 'flags' saved when AdvISR() was first entered will be
+         * used to restore the interrupt flag on exit.
+         */
+        (void) DvcEnterCritical();
+    }
+    DvcLeaveCritical(flags);
+    return ADV_TRUE;
+}
+
+/*
+ * Send an idle command to the chip and wait for completion.
+ *
+ * Command completion is polled for once per microsecond.
+ *
+ * The function can be called from anywhere including an interrupt handler.
+ * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()
+ * functions to prevent reentrancy.
+ *
+ * Return Values:
+ *   ADV_TRUE - command completed successfully
+ *   ADV_FALSE - command failed
+ *   ADV_ERROR - command timed out
+ */
+STATIC int
+AdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,
+               ushort idle_cmd,
+               ADV_DCNT idle_cmd_parameter)
+{
+    ulong       last_int_level;
+    int         result;
+    ADV_DCNT    i, j;
+    AdvPortAddr iop_base;
+
+    last_int_level = DvcEnterCritical();
+
+    iop_base = asc_dvc->iop_base;
+
+    /*
+     * Clear the idle command status which is set by the microcode
+     * to a non-zero value to indicate when the command is completed.
+     * The non-zero result is one of the IDLE_CMD_STATUS_* values
+     * defined in a_advlib.h.
+     */
+    AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort) 0);
+
+    /*
+     * Write the idle command value after the idle command parameter
+     * has been written to avoid a race condition. If the order is not
+     * followed, the microcode may process the idle command before the
+     * parameters have been written to LRAM.
+     */
+    AdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,
+        cpu_to_le32(idle_cmd_parameter));
+    AdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
+
+    /*
+     * Tickle the RISC to tell it to process the idle command.
+     */
+    AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);
+    if (asc_dvc->chip_type == ADV_CHIP_ASC3550)
+    {
+        /*
+         * Clear the tickle value. In the ASC-3550 the RISC flag
+         * command 'clr_tickle_b' does not work unless the host
+         * value is cleared.
+         */
+        AdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);
+    }
+
+    /* Wait for up to 100 millisecond for the idle command to timeout. */
+    for (i = 0; i < SCSI_WAIT_100_MSEC; i++)
+    {
+        /* Poll once each microsecond for command completion. */
+        for (j = 0; j < SCSI_US_PER_MSEC; j++)
+        {
+            AdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, result);
+            if (result != 0)
+            {
+                DvcLeaveCritical(last_int_level);
+                return result;
+            }
+            DvcDelayMicroSecond(asc_dvc, (ushort) 1);
+        }
+    }
+
+    ASC_ASSERT(0); /* The idle command should never timeout. */
+    DvcLeaveCritical(last_int_level);
+    return ADV_ERROR;
+}
+
+/*
+ * Inquiry Information Byte 7 Handling
+ *
+ * Handle SCSI Inquiry Command information for a device by setting
+ * microcode operating variables that affect WDTR, SDTR, and Tag
+ * Queuing.
+ */
+STATIC void
+AdvInquiryHandling(
+    ADV_DVC_VAR                 *asc_dvc,
+    ADV_SCSI_REQ_Q              *scsiq)
+{
+    AdvPortAddr                 iop_base;
+    uchar                       tid;
+    ADV_SCSI_INQUIRY            *inq;
+    ushort                      tidmask;
+    ushort                      cfg_word;
+
+    /*
+     * AdvInquiryHandling() requires up to INQUIRY information Byte 7
+     * to be available.
+     *
+     * If less than 8 bytes of INQUIRY information were requested or less
+     * than 8 bytes were transferred, then return. cdb[4] is the request
+     * length and the ADV_SCSI_REQ_Q 'data_cnt' field is set by the
+     * microcode to the transfer residual count.
+     */
+
+    if (scsiq->cdb[4] < 8 ||
+        (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) < 8)
+    {
+        return;
+    }
+
+    iop_base = asc_dvc->iop_base;
+    tid = scsiq->target_id;
+
+    inq = (ADV_SCSI_INQUIRY *) scsiq->vdata_addr;
+
+    /*
+     * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
+     */
+    if (ADV_INQ_RESPONSE_FMT(inq) < 2 && ADV_INQ_ANSI_VER(inq) < 2)
+    {
+        return;
+    } else
+    {
+        /*
+         * INQUIRY Byte 7 Handling
+         *
+         * Use a device's INQUIRY byte 7 to determine whether it
+         * supports WDTR, SDTR, and Tag Queuing. If the feature
+         * is enabled in the EEPROM and the device supports the
+         * feature, then enable it in the microcode.
+         */
+
+        tidmask = ADV_TID_TO_TIDMASK(tid);
+
+        /*
+         * Wide Transfers
+         *
+         * If the EEPROM enabled WDTR for the device and the device
+         * supports wide bus (16 bit) transfers, then turn on the
+         * device's 'wdtr_able' bit and write the new value to the
+         * microcode.
+         */
+        if ((asc_dvc->wdtr_able & tidmask) && ADV_INQ_WIDE16(inq))
+        {
+            AdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
+            if ((cfg_word & tidmask) == 0)
+            {
+                cfg_word |= tidmask;
+                AdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);
+
+                /*
+                 * Clear the microcode "SDTR negotiation" and "WDTR
+                 * negotiation" done indicators for the target to cause
+                 * it to negotiate with the new setting set above.
+                 * WDTR when accepted causes the target to enter
+                 * asynchronous mode, so SDTR must be negotiated.
+                 */
+                AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+                cfg_word &= ~tidmask;
+                AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+                AdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+                cfg_word &= ~tidmask;
+                AdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
+            }
+        }
+
+        /*
+         * Synchronous Transfers
+         *
+         * If the EEPROM enabled SDTR for the device and the device
+         * supports synchronous transfers, then turn on the device's
+         * 'sdtr_able' bit. Write the new value to the microcode.
+         */
+        if ((asc_dvc->sdtr_able & tidmask) && ADV_INQ_SYNC(inq))
+        {
+            AdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+            if ((cfg_word & tidmask) == 0)
+            {
+                cfg_word |= tidmask;
+                AdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);
+
+                /*
+                 * Clear the microcode "SDTR negotiation" done indicator
+                 * for the target to cause it to negotiate with the new
+                 * setting set above.
+                 */
+                AdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+                cfg_word &= ~tidmask;
+                AdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
+            }
+        }
+        /*
+         * If the Inquiry data included enough space for the SPI-3
+         * Clocking field, then check if DT mode is supported.
+         */
+        if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600 &&
+            (scsiq->cdb[4] >= 57 ||
+            (scsiq->cdb[4] - le32_to_cpu(scsiq->data_cnt)) >= 57))
+        {
+            /*
+             * PPR (Parallel Protocol Request) Capable
+             *
+             * If the device supports DT mode, then it must be PPR capable.
+             * The PPR message will be used in place of the SDTR and WDTR
+             * messages to negotiate synchronous speed and offset, transfer
+             * width, and protocol options.
+             */
+            if (ADV_INQ_CLOCKING(inq) & ADV_INQ_CLOCKING_DT_ONLY)
+            {
+                AdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, asc_dvc->ppr_able);
+                asc_dvc->ppr_able |= tidmask;
+                AdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, asc_dvc->ppr_able);
+            }
+        }
+
+        /*
+         * If the EEPROM enabled Tag Queuing for the device and the
+         * device supports Tag Queueing, then turn on the device's
+         * 'tagqng_enable' bit in the microcode and set the microcode
+         * maximum command count to the ADV_DVC_VAR 'max_dvc_qng'
+         * value.
+         *
+         * Tag Queuing is disabled for the BIOS which runs in polled
+         * mode and would see no benefit from Tag Queuing. Also by
+         * disabling Tag Queuing in the BIOS devices with Tag Queuing
+         * bugs will at least work with the BIOS.
+         */
+        if ((asc_dvc->tagqng_able & tidmask) && ADV_INQ_CMD_QUEUE(inq))
+        {
+            AdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
+            cfg_word |= tidmask;
+            AdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);
+
+            AdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
+                asc_dvc->max_dvc_qng);
+        }
+    }
+}
+MODULE_LICENSE("Dual BSD/GPL");
