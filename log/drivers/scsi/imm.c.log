commit 1f7563f743d7081710a9d186a8b203997d09f383
Merge: ba6d10ab8014 3e99b3b13a1f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 15:17:41 2019 -0700

    Merge tag 'scsi-sg' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI scatter-gather list updates from James Bottomley:
     "This topic branch covers a fundamental change in how our sg lists are
      allocated to make mq more efficient by reducing the size of the
      preallocated sg list.
    
      This necessitates a large number of driver changes because the
      previous guarantee that if a driver specified SG_ALL as the size of
      its scatter list, it would get a non-chained list and didn't need to
      bother with scatterlist iterators is now broken and every driver
      *must* use scatterlist iterators.
    
      This was broken out as a separate topic because we need to convert all
      the drivers before pulling the trigger and unconverted drivers kept
      being found, necessitating a rebase"
    
    * tag 'scsi-sg' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (21 commits)
      scsi: core: don't preallocate small SGL in case of NO_SG_CHAIN
      scsi: lib/sg_pool.c: clear 'first_chunk' in case of no preallocation
      scsi: core: avoid preallocating big SGL for data
      scsi: core: avoid preallocating big SGL for protection information
      scsi: lib/sg_pool.c: improve APIs for allocating sg pool
      scsi: esp: use sg helper to iterate over scatterlist
      scsi: NCR5380: use sg helper to iterate over scatterlist
      scsi: wd33c93: use sg helper to iterate over scatterlist
      scsi: ppa: use sg helper to iterate over scatterlist
      scsi: pcmcia: nsp_cs: use sg helper to iterate over scatterlist
      scsi: imm: use sg helper to iterate over scatterlist
      scsi: aha152x: use sg helper to iterate over scatterlist
      scsi: s390: zfcp_fc: use sg helper to iterate over scatterlist
      scsi: staging: unisys: visorhba: use sg helper to iterate over scatterlist
      scsi: usb: image: microtek: use sg helper to iterate over scatterlist
      scsi: pmcraid: use sg helper to iterate over scatterlist
      scsi: ipr: use sg helper to iterate over scatterlist
      scsi: mvumi: use sg helper to iterate over scatterlist
      scsi: lpfc: use sg helper to iterate over scatterlist
      scsi: advansys: use sg helper to iterate over scatterlist
      ...

commit 79da19b48fc188f6b5186e9ed605e10e5bef3ad6
Author: Ming Lei <ming.lei@redhat.com>
Date:   Tue Jun 18 09:37:53 2019 +0800

    scsi: imm: use sg helper to iterate over scatterlist
    
    Unlike the legacy I/O path, scsi-mq preallocates a large array to hold
    the scatterlist for each request. This static allocation can consume
    substantial amounts of memory on modern controllers which support a
    large number of concurrently outstanding requests.
    
    To facilitate a switch to a smaller static allocation combined with a
    dynamic allocation for requests that need it, we need to make sure all
    SCSI drivers handle chained scatterlists correctly.
    
    Convert remaining drivers that directly dereference the scatterlist
    array to using the iterator functions.
    
    [mkp: clarified commit message]
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 64ae418d29f3..56d29f157749 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -686,7 +686,7 @@ static int imm_completion(struct scsi_cmnd *cmd)
 		if (cmd->SCp.buffer && !cmd->SCp.this_residual) {
 			/* if scatter/gather, advance to the next segment */
 			if (cmd->SCp.buffers_residual--) {
-				cmd->SCp.buffer++;
+				cmd->SCp.buffer = sg_next(cmd->SCp.buffer);
 				cmd->SCp.this_residual =
 				    cmd->SCp.buffer->length;
 				cmd->SCp.ptr = sg_virt(cmd->SCp.buffer);

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 64ae418d29f3..9751309f8b8c 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* imm.c   --  low level driver for the IOMEGA MatchMaker
  * parallel port SCSI host adapter.
  * 

commit 9fa29a670bb8e887b40e95d4ce79a8e0d21d47ac
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Nov 26 12:31:53 2018 -0600

    scsi: imm: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Notice that, in this particular case, I placed all the "Phase N - ..."
    comments on the same line as its corresponding switch case. The same
    way in which similar comments appear in drivers/scsi/ppa.c. This makes
    it possible to place the "fall through" annotations at the bottom of
    each switch case, which is what GCC is expecting to find.
    
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index cea7f502e8ca..64ae418d29f3 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -796,21 +796,21 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 			return 0;
 		}
 		return 1;	/* wait until imm_wakeup claims parport */
-		/* Phase 1 - Connected */
-	case 1:
+
+	case 1:		/* Phase 1 - Connected */
 		imm_connect(dev, CONNECT_EPP_MAYBE);
 		cmd->SCp.phase++;
+		/* fall through */
 
-		/* Phase 2 - We are now talking to the scsi bus */
-	case 2:
+	case 2:		/* Phase 2 - We are now talking to the scsi bus */
 		if (!imm_select(dev, scmd_id(cmd))) {
 			imm_fail(dev, DID_NO_CONNECT);
 			return 0;
 		}
 		cmd->SCp.phase++;
+		/* fall through */
 
-		/* Phase 3 - Ready to accept a command */
-	case 3:
+	case 3:		/* Phase 3 - Ready to accept a command */
 		w_ctr(ppb, 0x0c);
 		if (!(r_str(ppb) & 0x80))
 			return 1;
@@ -818,9 +818,9 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 		if (!imm_send_command(cmd))
 			return 0;
 		cmd->SCp.phase++;
+		/* fall through */
 
-		/* Phase 4 - Setup scatter/gather buffers */
-	case 4:
+	case 4:		/* Phase 4 - Setup scatter/gather buffers */
 		if (scsi_bufflen(cmd)) {
 			cmd->SCp.buffer = scsi_sglist(cmd);
 			cmd->SCp.this_residual = cmd->SCp.buffer->length;
@@ -834,8 +834,9 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 		cmd->SCp.phase++;
 		if (cmd->SCp.this_residual & 0x01)
 			cmd->SCp.this_residual++;
-		/* Phase 5 - Pre-Data transfer stage */
-	case 5:
+		/* fall through */
+
+	case 5:		/* Phase 5 - Pre-Data transfer stage */
 		/* Spin lock for BUSY */
 		w_ctr(ppb, 0x0c);
 		if (!(r_str(ppb) & 0x80))
@@ -850,9 +851,9 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 			if (imm_negotiate(dev))
 				return 0;
 		cmd->SCp.phase++;
+		/* fall through */
 
-		/* Phase 6 - Data transfer stage */
-	case 6:
+	case 6:		/* Phase 6 - Data transfer stage */
 		/* Spin lock for BUSY */
 		w_ctr(ppb, 0x0c);
 		if (!(r_str(ppb) & 0x80))
@@ -866,9 +867,9 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 				return 1;
 		}
 		cmd->SCp.phase++;
+		/* fall through */
 
-		/* Phase 7 - Post data transfer stage */
-	case 7:
+	case 7:		/* Phase 7 - Post data transfer stage */
 		if ((dev->dp) && (dev->rd)) {
 			if ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {
 				w_ctr(ppb, 0x4);
@@ -878,9 +879,9 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 			}
 		}
 		cmd->SCp.phase++;
+		/* fall through */
 
-		/* Phase 8 - Read status/message */
-	case 8:
+	case 8:		/* Phase 8 - Read status/message */
 		/* Check for data overrun */
 		if (imm_wait(dev) != (unsigned char) 0xb8) {
 			imm_fail(dev, DID_ERROR);

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 8c6627bc8a39..cea7f502e8ca 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1110,7 +1110,6 @@ static struct scsi_host_template imm_template = {
 	.bios_param		= imm_biosparam,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
-	.use_clustering		= ENABLE_CLUSTERING,
 	.can_queue		= 1,
 	.slave_alloc		= imm_adjust_queue,
 };

commit 6bec4c3842cd7338973839683bbf96273c3b85f7
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Jun 25 13:20:59 2018 +0200

    scsi: don't add scsi command result bytes
    
    Some drivers are ADDing the scsi command's result bytes instead of ORing
    them.
    
    While this can produce correct results it has unexpected side effects.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 87c94191033b..8c6627bc8a39 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -892,7 +892,7 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 			/* Check for optional message byte */
 			if (imm_wait(dev) == (unsigned char) 0xb8)
 				imm_in(dev, &h, 1);
-			cmd->result = (DID_OK << 16) + (l & STATUS_MASK);
+			cmd->result = (DID_OK << 16) | (l & STATUS_MASK);
 		}
 		if ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {
 			w_ctr(ppb, 0x4);

commit 3e0273a860458a51f4f93157725eb81f9d4db5da
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:12 2017 +0200

    scsi: imm: drop duplicate bus_reset handler
    
    host_reset and bus_reset is the same function, so drop bus reset.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 9164ce1249c1..87c94191033b 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1106,7 +1106,6 @@ static struct scsi_host_template imm_template = {
 	.name			= "Iomega VPI2 (imm) interface",
 	.queuecommand		= imm_queuecommand,
 	.eh_abort_handler	= imm_abort,
-	.eh_bus_reset_handler	= imm_reset,
 	.eh_host_reset_handler	= imm_reset,
 	.bios_param		= imm_biosparam,
 	.this_id		= 7,

commit 9ffeca3e576b9f8b18071ca03f7562d198c2f68b
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Feb 24 16:27:11 2016 +0530

    imm: check parport_claim
    
    parport_claim() can fail and we should be checking if we were able to
    claim the port.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index f8b88fa78e62..9164ce1249c1 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -77,9 +77,10 @@ static void imm_wakeup(void *ref)
 
 	spin_lock_irqsave(&arbitration_lock, flags);
 	if (dev->wanted) {
-		parport_claim(dev->dev);
-		got_it(dev);
-		dev->wanted = 0;
+		if (parport_claim(dev->dev) == 0) {
+			got_it(dev);
+			dev->wanted = 0;
+		}
 	}
 	spin_unlock_irqrestore(&arbitration_lock, flags);
 }

commit a290dd57926cb0c54eec7ea506885119e296b755
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Tue Jan 5 18:10:50 2016 +0530

    imm: Use new parport device model
    
    Modify imm driver to use the new parallel port device model.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 4e1a632ccf16..f8b88fa78e62 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -43,6 +43,7 @@ typedef struct {
 	unsigned dp:1;		/* Data phase present           */
 	unsigned rd:1;		/* Read data in data phase      */
 	unsigned wanted:1;	/* Parport sharing busy flag    */
+	unsigned int dev_no;	/* Device number		*/
 	wait_queue_head_t *waiting;
 	struct Scsi_Host *host;
 	struct list_head list;
@@ -1120,15 +1121,40 @@ static struct scsi_host_template imm_template = {
 
 static LIST_HEAD(imm_hosts);
 
+/*
+ * Finds the first available device number that can be alloted to the
+ * new imm device and returns the address of the previous node so that
+ * we can add to the tail and have a list in the ascending order.
+ */
+
+static inline imm_struct *find_parent(void)
+{
+	imm_struct *dev, *par = NULL;
+	unsigned int cnt = 0;
+
+	if (list_empty(&imm_hosts))
+		return NULL;
+
+	list_for_each_entry(dev, &imm_hosts, list) {
+		if (dev->dev_no != cnt)
+			return par;
+		cnt++;
+		par = dev;
+	}
+
+	return par;
+}
+
 static int __imm_attach(struct parport *pb)
 {
 	struct Scsi_Host *host;
-	imm_struct *dev;
+	imm_struct *dev, *temp;
 	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(waiting);
 	DEFINE_WAIT(wait);
 	int ports;
 	int modes, ppb;
 	int err = -ENOMEM;
+	struct pardev_cb imm_cb;
 
 	init_waitqueue_head(&waiting);
 
@@ -1141,9 +1167,15 @@ static int __imm_attach(struct parport *pb)
 	dev->mode = IMM_AUTODETECT;
 	INIT_LIST_HEAD(&dev->list);
 
-	dev->dev = parport_register_device(pb, "imm", NULL, imm_wakeup,
-						NULL, 0, dev);
+	temp = find_parent();
+	if (temp)
+		dev->dev_no = temp->dev_no + 1;
+
+	memset(&imm_cb, 0, sizeof(imm_cb));
+	imm_cb.private = dev;
+	imm_cb.wakeup = imm_wakeup;
 
+	dev->dev = parport_register_dev_model(pb, "imm", &imm_cb, dev->dev_no);
 	if (!dev->dev)
 		goto out;
 
@@ -1207,7 +1239,10 @@ static int __imm_attach(struct parport *pb)
 	host->unique_id = pb->number;
 	*(imm_struct **)&host->hostdata = dev;
 	dev->host = host;
-	list_add_tail(&dev->list, &imm_hosts);
+	if (!temp)
+		list_add_tail(&dev->list, &imm_hosts);
+	else
+		list_add_tail(&dev->list, &temp->list);
 	err = scsi_add_host(host, NULL);
 	if (err)
 		goto out2;
@@ -1245,9 +1280,10 @@ static void imm_detach(struct parport *pb)
 }
 
 static struct parport_driver imm_driver = {
-	.name	= "imm",
-	.attach	= imm_attach,
-	.detach	= imm_detach,
+	.name		= "imm",
+	.match_port	= imm_attach,
+	.detach		= imm_detach,
+	.devmodel	= true,
 };
 
 static int __init imm_driver_init(void)

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 89a8266560d0..4e1a632ccf16 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1109,7 +1109,6 @@ static struct scsi_host_template imm_template = {
 	.bios_param		= imm_biosparam,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 	.can_queue		= 1,
 	.slave_alloc		= imm_adjust_queue,

commit fa5fd36820efdc82fc9ac8ac9bd47ddc2fee3d37
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 00:55:40 2013 -0400

    imm: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 26cd9d1d7571..89a8266560d0 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -121,45 +121,26 @@ static inline void imm_pb_release(imm_struct *dev)
  * testing...
  * Also gives a method to use a script to obtain optimum timings (TODO)
  */
-static inline int imm_proc_write(imm_struct *dev, char *buffer, int length)
+static int imm_write_info(struct Scsi_Host *host, char *buffer, int length)
 {
-	unsigned long x;
+	imm_struct *dev = imm_dev(host);
 
 	if ((length > 5) && (strncmp(buffer, "mode=", 5) == 0)) {
-		x = simple_strtoul(buffer + 5, NULL, 0);
-		dev->mode = x;
+		dev->mode = simple_strtoul(buffer + 5, NULL, 0);
 		return length;
 	}
 	printk("imm /proc: invalid variable\n");
-	return (-EINVAL);
+	return -EINVAL;
 }
 
-static int imm_proc_info(struct Scsi_Host *host, char *buffer, char **start,
-			off_t offset, int length, int inout)
+static int imm_show_info(struct seq_file *m, struct Scsi_Host *host)
 {
 	imm_struct *dev = imm_dev(host);
-	int len = 0;
-
-	if (inout)
-		return imm_proc_write(dev, buffer, length);
-
-	len += sprintf(buffer + len, "Version : %s\n", IMM_VERSION);
-	len +=
-	    sprintf(buffer + len, "Parport : %s\n",
-		    dev->dev->port->name);
-	len +=
-	    sprintf(buffer + len, "Mode    : %s\n",
-		    IMM_MODE_STRING[dev->mode]);
 
-	/* Request for beyond end of buffer */
-	if (offset > len)
-		return 0;
-
-	*start = buffer + offset;
-	len -= offset;
-	if (len > length)
-		len = length;
-	return len;
+	seq_printf(m, "Version : %s\n", IMM_VERSION);
+	seq_printf(m, "Parport : %s\n", dev->dev->port->name);
+	seq_printf(m, "Mode    : %s\n", IMM_MODE_STRING[dev->mode]);
+	return 0;
 }
 
 #if IMM_DEBUG > 0
@@ -1118,7 +1099,8 @@ static int imm_adjust_queue(struct scsi_device *device)
 static struct scsi_host_template imm_template = {
 	.module			= THIS_MODULE,
 	.proc_name		= "imm",
-	.proc_info		= imm_proc_info,
+	.show_info		= imm_show_info,
+	.write_info		= imm_write_info,
 	.name			= "Iomega VPI2 (imm) interface",
 	.queuecommand		= imm_queuecommand,
 	.eh_abort_handler	= imm_abort,

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 99aa0e5699bc..26cd9d1d7571 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -3,7 +3,7 @@
  * 
  * (The IMM is the embedded controller in the ZIP Plus drive.)
  * 
- * My unoffical company acronym list is 21 pages long:
+ * My unofficial company acronym list is 21 pages long:
  *      FLA:    Four letter acronym with built in facility for
  *              future expansion to five letters.
  */

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 4734ab0b3ff6..99aa0e5699bc 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -926,7 +926,7 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 	return 0;
 }
 
-static int imm_queuecommand(struct scsi_cmnd *cmd,
+static int imm_queuecommand_lck(struct scsi_cmnd *cmd,
 		void (*done)(struct scsi_cmnd *))
 {
 	imm_struct *dev = imm_dev(cmd->device->host);
@@ -949,6 +949,8 @@ static int imm_queuecommand(struct scsi_cmnd *cmd,
 	return 0;
 }
 
+static DEF_SCSI_QCMD(imm_queuecommand)
+
 /*
  * Apparently the disk->capacity attribute is off by 1 sector 
  * for all disk drives.  We add the one here, but it should really

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index c2a9a13d788f..4734ab0b3ff6 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -15,6 +15,7 @@
 #include <linux/parport.h>
 #include <linux/workqueue.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 #include <asm/io.h>
 
 #include <scsi/scsi.h>

commit cadbd4a5e36dde7e6c49b587b2c419103c0b7218
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:47:27 2008 -0700

    [SCSI] replace __FUNCTION__ with __func__
    
    [jejb: fixed up a ton of missed conversions.
    
     All of you are on notice this has happened, driver trees will now
     need to be rebased]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: SCSI List <linux-scsi@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index f97d172844be..c2a9a13d788f 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -163,7 +163,7 @@ static int imm_proc_info(struct Scsi_Host *host, char *buffer, char **start,
 
 #if IMM_DEBUG > 0
 #define imm_fail(x,y) printk("imm: imm_fail(%i) from %s at line %d\n",\
-	   y, __FUNCTION__, __LINE__); imm_fail_func(x,y);
+	   y, __func__, __LINE__); imm_fail_func(x,y);
 static inline void
 imm_fail_func(imm_struct *dev, int error_code)
 #else

commit 3ce7c6588637614b00072569679791a04898c790
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Sun Sep 9 21:13:42 2007 +0300

    [SCSI] imm: convert to accessors and !use_sg cleanup
    
     - convert to accessors and !use_sg cleanup
     - Not ready for sg-chaining
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Tested-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index a3d0c6b14958..f97d172844be 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -837,19 +837,16 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 
 		/* Phase 4 - Setup scatter/gather buffers */
 	case 4:
-		if (cmd->use_sg) {
-			/* if many buffers are available, start filling the first */
-			cmd->SCp.buffer =
-			    (struct scatterlist *) cmd->request_buffer;
+		if (scsi_bufflen(cmd)) {
+			cmd->SCp.buffer = scsi_sglist(cmd);
 			cmd->SCp.this_residual = cmd->SCp.buffer->length;
 			cmd->SCp.ptr = sg_virt(cmd->SCp.buffer);
 		} else {
-			/* else fill the only available buffer */
 			cmd->SCp.buffer = NULL;
-			cmd->SCp.this_residual = cmd->request_bufflen;
-			cmd->SCp.ptr = cmd->request_buffer;
+			cmd->SCp.this_residual = 0;
+			cmd->SCp.ptr = NULL;
 		}
-		cmd->SCp.buffers_residual = cmd->use_sg - 1;
+		cmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;
 		cmd->SCp.phase++;
 		if (cmd->SCp.this_residual & 0x01)
 			cmd->SCp.this_residual++;

commit 45711f1af6eff1a6d010703b4862e0d2b9afd056
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Oct 22 21:19:53 2007 +0200

    [SG] Update drivers to use sg helpers
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 74cdc1f0a78f..a3d0c6b14958 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -705,9 +705,7 @@ static int imm_completion(struct scsi_cmnd *cmd)
 				cmd->SCp.buffer++;
 				cmd->SCp.this_residual =
 				    cmd->SCp.buffer->length;
-				cmd->SCp.ptr =
-				    page_address(cmd->SCp.buffer->page) +
-				    cmd->SCp.buffer->offset;
+				cmd->SCp.ptr = sg_virt(cmd->SCp.buffer);
 
 				/*
 				 * Make sure that we transfer even number of bytes
@@ -844,9 +842,7 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 			cmd->SCp.buffer =
 			    (struct scatterlist *) cmd->request_buffer;
 			cmd->SCp.this_residual = cmd->SCp.buffer->length;
-			cmd->SCp.ptr =
-			    page_address(cmd->SCp.buffer->page) +
-			    cmd->SCp.buffer->offset;
+			cmd->SCp.ptr = sg_virt(cmd->SCp.buffer);
 		} else {
 			/* else fill the only available buffer */
 			cmd->SCp.buffer = NULL;

commit f01f9d59433dd9d244664c19771e078a194e7984
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 2 14:38:09 2007 -0700

    [SCSI] imm: fix check-after-use
    
    The Coverity checker spotted that we have already oops'ed if "cmd"
    was NULL.
    
    Since "cmd" being NULL doesn't seem to be possible at this point this
    patch removes the NULL check.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 005d2b05f32d..74cdc1f0a78f 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -740,10 +740,6 @@ static void imm_interrupt(struct work_struct *work)
 	struct Scsi_Host *host = cmd->device->host;
 	unsigned long flags;
 
-	if (!cmd) {
-		printk("IMM: bug in imm_interrupt\n");
-		return;
-	}
 	if (imm_engine(dev, cmd)) {
 		schedule_delayed_work(&dev->imm_tq, 1);
 		return;

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 0464c182c577..005d2b05f32d 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1159,11 +1159,10 @@ static int __imm_attach(struct parport *pb)
 
 	init_waitqueue_head(&waiting);
 
-	dev = kmalloc(sizeof(imm_struct), GFP_KERNEL);
+	dev = kzalloc(sizeof(imm_struct), GFP_KERNEL);
 	if (!dev)
 		return -ENOMEM;
 
-	memset(dev, 0, sizeof(imm_struct));
 
 	dev->base = -1;
 	dev->mode = IMM_AUTODETECT;

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index e31f6122106f..0464c182c577 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -36,7 +36,7 @@ typedef struct {
 	int base_hi;		/* Hi Base address for ECP-ISA chipset */
 	int mode;		/* Transfer mode                */
 	struct scsi_cmnd *cur_cmd;	/* Current queued command       */
-	struct work_struct imm_tq;	/* Polling interrupt stuff       */
+	struct delayed_work imm_tq;	/* Polling interrupt stuff       */
 	unsigned long jstart;	/* Jiffies at start             */
 	unsigned failed:1;	/* Failure flag                 */
 	unsigned dp:1;		/* Data phase present           */
@@ -733,9 +733,9 @@ static int imm_completion(struct scsi_cmnd *cmd)
  * the scheduler's task queue to generate a stream of call-backs and
  * complete the request when the drive is ready.
  */
-static void imm_interrupt(void *data)
+static void imm_interrupt(struct work_struct *work)
 {
-	imm_struct *dev = (imm_struct *) data;
+	imm_struct *dev = container_of(work, imm_struct, imm_tq.work);
 	struct scsi_cmnd *cmd = dev->cur_cmd;
 	struct Scsi_Host *host = cmd->device->host;
 	unsigned long flags;
@@ -745,7 +745,6 @@ static void imm_interrupt(void *data)
 		return;
 	}
 	if (imm_engine(dev, cmd)) {
-		INIT_WORK(&dev->imm_tq, imm_interrupt, (void *) dev);
 		schedule_delayed_work(&dev->imm_tq, 1);
 		return;
 	}
@@ -953,8 +952,7 @@ static int imm_queuecommand(struct scsi_cmnd *cmd,
 	cmd->result = DID_ERROR << 16;	/* default return code */
 	cmd->SCp.phase = 0;	/* bus free */
 
-	INIT_WORK(&dev->imm_tq, imm_interrupt, dev);
-	schedule_work(&dev->imm_tq);
+	schedule_delayed_work(&dev->imm_tq, 0);
 
 	imm_pb_claim(dev);
 
@@ -1225,7 +1223,7 @@ static int __imm_attach(struct parport *pb)
 	else
 		ports = 8;
 
-	INIT_WORK(&dev->imm_tq, imm_interrupt, dev);
+	INIT_DELAYED_WORK(&dev->imm_tq, imm_interrupt);
 
 	err = -ENOMEM;
 	host = scsi_host_alloc(&imm_template, sizeof(imm_struct *));

commit 7259f0d05d595b73ef312a082e628627c6414969
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Sun Oct 29 22:46:36 2006 -0800

    [PATCH] lockdep: annotate DECLARE_WAIT_QUEUE_HEAD
    
    kernel: INFO: trying to register non-static key.
    kernel: the code is fine but needs lockdep annotation.
    kernel: turning off the locking correctness validator.
    kernel:  [<c04051ed>] show_trace_log_lvl+0x58/0x16a
    kernel:  [<c04057fa>] show_trace+0xd/0x10
    kernel:  [<c0405913>] dump_stack+0x19/0x1b
    kernel:  [<c043b1e2>] __lock_acquire+0xf0/0x90d
    kernel:  [<c043bf70>] lock_acquire+0x4b/0x6b
    kernel:  [<c061472f>] _spin_lock_irqsave+0x22/0x32
    kernel:  [<c04363d3>] prepare_to_wait+0x17/0x4b
    kernel:  [<f89a24b6>] lpfc_do_work+0xdd/0xcc2 [lpfc]
    kernel:  [<c04361b9>] kthread+0xc3/0xf2
    kernel:  [<c0402005>] kernel_thread_helper+0x5/0xb
    
    Another case of non-static lockdep keys; duplicate the paradigm set by
    DECLARE_COMPLETION_ONSTACK and introduce DECLARE_WAIT_QUEUE_HEAD_ONSTACK.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Greg KH <gregkh@suse.de>
    Cc: Markus Lidel <markus.lidel@shadowconnect.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 2d95ac9c32c1..e31f6122106f 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1153,7 +1153,7 @@ static int __imm_attach(struct parport *pb)
 {
 	struct Scsi_Host *host;
 	imm_struct *dev;
-	DECLARE_WAIT_QUEUE_HEAD(waiting);
+	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(waiting);
 	DEFINE_WAIT(wait);
 	int ports;
 	int modes, ppb;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 681bd18493f3..2d95ac9c32c1 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -8,7 +8,6 @@
  *              future expansion to five letters.
  */
 
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>

commit bdca3f202dbeaca2fcc4fb47219476286c999b0d
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jun 26 18:19:23 2006 +0200

    remove the bouncing email address of David Campbell
    
    This patch removes a bouncing email address from the kernel sources.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index cd2dffdab77a..681bd18493f3 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -3,9 +3,6 @@
  * 
  * (The IMM is the embedded controller in the ZIP Plus drive.)
  * 
- * Current Maintainer: David Campbell (Perth, Western Australia)
- *                     campbell@torque.net
- *
  * My unoffical company acronym list is 21 pages long:
  *      FLA:    Four letter acronym with built in facility for
  *              future expansion to five letters.

commit 979dca3826841e5dc9170c28f20bd75ece266a9a
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Fri May 19 11:55:58 2006 -0700

    [SCSI] imm: no need for unchecked_isa_dma
    
    Relax the lowmem bounce buffer requirement for imm so that any
    low memory page will do -- they don't need to be below the
    ISA 16 MB limit, just need to be mapped in low memory.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index fc0f30ae0f77..cd2dffdab77a 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -1119,6 +1119,10 @@ static int device_check(imm_struct *dev)
 	return -ENODEV;
 }
 
+/*
+ * imm cannot deal with highmem, so this causes all IO pages for this host
+ * to reside in low memory (hence mapped)
+ */
 static int imm_adjust_queue(struct scsi_device *device)
 {
 	blk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);
@@ -1141,10 +1145,6 @@ static struct scsi_host_template imm_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 	.can_queue		= 1,
 	.slave_alloc		= imm_adjust_queue,
-	.unchecked_isa_dma	= 1, /* imm cannot deal with highmem, so
-				      * this is an easy trick to ensure
-				      * all io pages for this host reside
-				      * in low memory */
 };
 
 /***************************************************************************

commit 422c0d61d591cbfb70f029e13505fb437e169d68
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:05:09 2005 -0400

    [SCSI] use scmd_id(), scmd_channel() throughout code
    
    Wrap a highly common idiom.  Makes the code easier to read, helps pave
    the way for sdev->{id,channel} removal, and adds a token that can easily
    by grepped-for in the future.
    
    There are a couple sdev_id() and scmd_printk() updates thrown in as well.
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index 65e845665b85..fc0f30ae0f77 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -830,7 +830,7 @@ static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
 
 		/* Phase 2 - We are now talking to the scsi bus */
 	case 2:
-		if (!imm_select(dev, cmd->device->id)) {
+		if (!imm_select(dev, scmd_id(cmd))) {
 			imm_fail(dev, DID_NO_CONNECT);
 			return 0;
 		}

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
index be7f2ca0183f..65e845665b85 100644
--- a/drivers/scsi/imm.c
+++ b/drivers/scsi/imm.c
@@ -18,6 +18,7 @@
 #include <linux/blkdev.h>
 #include <linux/parport.h>
 #include <linux/workqueue.h>
+#include <linux/delay.h>
 #include <asm/io.h>
 
 #include <scsi/scsi.h>
@@ -610,9 +611,9 @@ static int imm_init(imm_struct *dev)
 	if (imm_connect(dev, 0) != 1)
 		return -EIO;
 	imm_reset_pulse(dev->base);
-	udelay(1000);	/* Delay to allow devices to settle */
+	mdelay(1);	/* Delay to allow devices to settle */
 	imm_disconnect(dev);
-	udelay(1000);	/* Another delay to allow devices to settle */
+	mdelay(1);	/* Another delay to allow devices to settle */
 	return device_check(dev);
 }
 
@@ -1026,9 +1027,9 @@ static int imm_reset(struct scsi_cmnd *cmd)
 
 	imm_connect(dev, CONNECT_NORMAL);
 	imm_reset_pulse(dev->base);
-	udelay(1000);		/* device settle delay */
+	mdelay(1);		/* device settle delay */
 	imm_disconnect(dev);
-	udelay(1000);		/* device settle delay */
+	mdelay(1);		/* device settle delay */
 	return SUCCESS;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/imm.c b/drivers/scsi/imm.c
new file mode 100644
index 000000000000..be7f2ca0183f
--- /dev/null
+++ b/drivers/scsi/imm.c
@@ -0,0 +1,1300 @@
+/* imm.c   --  low level driver for the IOMEGA MatchMaker
+ * parallel port SCSI host adapter.
+ * 
+ * (The IMM is the embedded controller in the ZIP Plus drive.)
+ * 
+ * Current Maintainer: David Campbell (Perth, Western Australia)
+ *                     campbell@torque.net
+ *
+ * My unoffical company acronym list is 21 pages long:
+ *      FLA:    Four letter acronym with built in facility for
+ *              future expansion to five letters.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/blkdev.h>
+#include <linux/parport.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+
+/* The following #define is to avoid a clash with hosts.c */
+#define IMM_PROBE_SPP   0x0001
+#define IMM_PROBE_PS2   0x0002
+#define IMM_PROBE_ECR   0x0010
+#define IMM_PROBE_EPP17 0x0100
+#define IMM_PROBE_EPP19 0x0200
+
+
+typedef struct {
+	struct pardevice *dev;	/* Parport device entry         */
+	int base;		/* Actual port address          */
+	int base_hi;		/* Hi Base address for ECP-ISA chipset */
+	int mode;		/* Transfer mode                */
+	struct scsi_cmnd *cur_cmd;	/* Current queued command       */
+	struct work_struct imm_tq;	/* Polling interrupt stuff       */
+	unsigned long jstart;	/* Jiffies at start             */
+	unsigned failed:1;	/* Failure flag                 */
+	unsigned dp:1;		/* Data phase present           */
+	unsigned rd:1;		/* Read data in data phase      */
+	unsigned wanted:1;	/* Parport sharing busy flag    */
+	wait_queue_head_t *waiting;
+	struct Scsi_Host *host;
+	struct list_head list;
+} imm_struct;
+
+static void imm_reset_pulse(unsigned int base);
+static int device_check(imm_struct *dev);
+
+#include "imm.h"
+
+static inline imm_struct *imm_dev(struct Scsi_Host *host)
+{
+	return *(imm_struct **)&host->hostdata;
+}
+
+static DEFINE_SPINLOCK(arbitration_lock);
+
+static void got_it(imm_struct *dev)
+{
+	dev->base = dev->dev->port->base;
+	if (dev->cur_cmd)
+		dev->cur_cmd->SCp.phase = 1;
+	else
+		wake_up(dev->waiting);
+}
+
+static void imm_wakeup(void *ref)
+{
+	imm_struct *dev = (imm_struct *) ref;
+	unsigned long flags;
+
+	spin_lock_irqsave(&arbitration_lock, flags);
+	if (dev->wanted) {
+		parport_claim(dev->dev);
+		got_it(dev);
+		dev->wanted = 0;
+	}
+	spin_unlock_irqrestore(&arbitration_lock, flags);
+}
+
+static int imm_pb_claim(imm_struct *dev)
+{
+	unsigned long flags;
+	int res = 1;
+	spin_lock_irqsave(&arbitration_lock, flags);
+	if (parport_claim(dev->dev) == 0) {
+		got_it(dev);
+		res = 0;
+	}
+	dev->wanted = res;
+	spin_unlock_irqrestore(&arbitration_lock, flags);
+	return res;
+}
+
+static void imm_pb_dismiss(imm_struct *dev)
+{
+	unsigned long flags;
+	int wanted;
+	spin_lock_irqsave(&arbitration_lock, flags);
+	wanted = dev->wanted;
+	dev->wanted = 0;
+	spin_unlock_irqrestore(&arbitration_lock, flags);
+	if (!wanted)
+		parport_release(dev->dev);
+}
+
+static inline void imm_pb_release(imm_struct *dev)
+{
+	parport_release(dev->dev);
+}
+
+/* This is to give the imm driver a way to modify the timings (and other
+ * parameters) by writing to the /proc/scsi/imm/0 file.
+ * Very simple method really... (Too simple, no error checking :( )
+ * Reason: Kernel hackers HATE having to unload and reload modules for
+ * testing...
+ * Also gives a method to use a script to obtain optimum timings (TODO)
+ */
+static inline int imm_proc_write(imm_struct *dev, char *buffer, int length)
+{
+	unsigned long x;
+
+	if ((length > 5) && (strncmp(buffer, "mode=", 5) == 0)) {
+		x = simple_strtoul(buffer + 5, NULL, 0);
+		dev->mode = x;
+		return length;
+	}
+	printk("imm /proc: invalid variable\n");
+	return (-EINVAL);
+}
+
+static int imm_proc_info(struct Scsi_Host *host, char *buffer, char **start,
+			off_t offset, int length, int inout)
+{
+	imm_struct *dev = imm_dev(host);
+	int len = 0;
+
+	if (inout)
+		return imm_proc_write(dev, buffer, length);
+
+	len += sprintf(buffer + len, "Version : %s\n", IMM_VERSION);
+	len +=
+	    sprintf(buffer + len, "Parport : %s\n",
+		    dev->dev->port->name);
+	len +=
+	    sprintf(buffer + len, "Mode    : %s\n",
+		    IMM_MODE_STRING[dev->mode]);
+
+	/* Request for beyond end of buffer */
+	if (offset > len)
+		return 0;
+
+	*start = buffer + offset;
+	len -= offset;
+	if (len > length)
+		len = length;
+	return len;
+}
+
+#if IMM_DEBUG > 0
+#define imm_fail(x,y) printk("imm: imm_fail(%i) from %s at line %d\n",\
+	   y, __FUNCTION__, __LINE__); imm_fail_func(x,y);
+static inline void
+imm_fail_func(imm_struct *dev, int error_code)
+#else
+static inline void
+imm_fail(imm_struct *dev, int error_code)
+#endif
+{
+	/* If we fail a device then we trash status / message bytes */
+	if (dev->cur_cmd) {
+		dev->cur_cmd->result = error_code << 16;
+		dev->failed = 1;
+	}
+}
+
+/*
+ * Wait for the high bit to be set.
+ * 
+ * In principle, this could be tied to an interrupt, but the adapter
+ * doesn't appear to be designed to support interrupts.  We spin on
+ * the 0x80 ready bit. 
+ */
+static unsigned char imm_wait(imm_struct *dev)
+{
+	int k;
+	unsigned short ppb = dev->base;
+	unsigned char r;
+
+	w_ctr(ppb, 0x0c);
+
+	k = IMM_SPIN_TMO;
+	do {
+		r = r_str(ppb);
+		k--;
+		udelay(1);
+	}
+	while (!(r & 0x80) && (k));
+
+	/*
+	 * STR register (LPT base+1) to SCSI mapping:
+	 *
+	 * STR      imm     imm
+	 * ===================================
+	 * 0x80     S_REQ   S_REQ
+	 * 0x40     !S_BSY  (????)
+	 * 0x20     !S_CD   !S_CD
+	 * 0x10     !S_IO   !S_IO
+	 * 0x08     (????)  !S_BSY
+	 *
+	 * imm      imm     meaning
+	 * ==================================
+	 * 0xf0     0xb8    Bit mask
+	 * 0xc0     0x88    ZIP wants more data
+	 * 0xd0     0x98    ZIP wants to send more data
+	 * 0xe0     0xa8    ZIP is expecting SCSI command data
+	 * 0xf0     0xb8    end of transfer, ZIP is sending status
+	 */
+	w_ctr(ppb, 0x04);
+	if (k)
+		return (r & 0xb8);
+
+	/* Counter expired - Time out occurred */
+	imm_fail(dev, DID_TIME_OUT);
+	printk("imm timeout in imm_wait\n");
+	return 0;		/* command timed out */
+}
+
+static int imm_negotiate(imm_struct * tmp)
+{
+	/*
+	 * The following is supposedly the IEEE 1284-1994 negotiate
+	 * sequence. I have yet to obtain a copy of the above standard
+	 * so this is a bit of a guess...
+	 *
+	 * A fair chunk of this is based on the Linux parport implementation
+	 * of IEEE 1284.
+	 *
+	 * Return 0 if data available
+	 *        1 if no data available
+	 */
+
+	unsigned short base = tmp->base;
+	unsigned char a, mode;
+
+	switch (tmp->mode) {
+	case IMM_NIBBLE:
+		mode = 0x00;
+		break;
+	case IMM_PS2:
+		mode = 0x01;
+		break;
+	default:
+		return 0;
+	}
+
+	w_ctr(base, 0x04);
+	udelay(5);
+	w_dtr(base, mode);
+	udelay(100);
+	w_ctr(base, 0x06);
+	udelay(5);
+	a = (r_str(base) & 0x20) ? 0 : 1;
+	udelay(5);
+	w_ctr(base, 0x07);
+	udelay(5);
+	w_ctr(base, 0x06);
+
+	if (a) {
+		printk
+		    ("IMM: IEEE1284 negotiate indicates no data available.\n");
+		imm_fail(tmp, DID_ERROR);
+	}
+	return a;
+}
+
+/* 
+ * Clear EPP timeout bit. 
+ */
+static inline void epp_reset(unsigned short ppb)
+{
+	int i;
+
+	i = r_str(ppb);
+	w_str(ppb, i);
+	w_str(ppb, i & 0xfe);
+}
+
+/* 
+ * Wait for empty ECP fifo (if we are in ECP fifo mode only)
+ */
+static inline void ecp_sync(imm_struct *dev)
+{
+	int i, ppb_hi = dev->base_hi;
+
+	if (ppb_hi == 0)
+		return;
+
+	if ((r_ecr(ppb_hi) & 0xe0) == 0x60) {	/* mode 011 == ECP fifo mode */
+		for (i = 0; i < 100; i++) {
+			if (r_ecr(ppb_hi) & 0x01)
+				return;
+			udelay(5);
+		}
+		printk("imm: ECP sync failed as data still present in FIFO.\n");
+	}
+}
+
+static int imm_byte_out(unsigned short base, const char *buffer, int len)
+{
+	int i;
+
+	w_ctr(base, 0x4);	/* apparently a sane mode */
+	for (i = len >> 1; i; i--) {
+		w_dtr(base, *buffer++);
+		w_ctr(base, 0x5);	/* Drop STROBE low */
+		w_dtr(base, *buffer++);
+		w_ctr(base, 0x0);	/* STROBE high + INIT low */
+	}
+	w_ctr(base, 0x4);	/* apparently a sane mode */
+	return 1;		/* All went well - we hope! */
+}
+
+static int imm_nibble_in(unsigned short base, char *buffer, int len)
+{
+	unsigned char l;
+	int i;
+
+	/*
+	 * The following is based on documented timing signals
+	 */
+	w_ctr(base, 0x4);
+	for (i = len; i; i--) {
+		w_ctr(base, 0x6);
+		l = (r_str(base) & 0xf0) >> 4;
+		w_ctr(base, 0x5);
+		*buffer++ = (r_str(base) & 0xf0) | l;
+		w_ctr(base, 0x4);
+	}
+	return 1;		/* All went well - we hope! */
+}
+
+static int imm_byte_in(unsigned short base, char *buffer, int len)
+{
+	int i;
+
+	/*
+	 * The following is based on documented timing signals
+	 */
+	w_ctr(base, 0x4);
+	for (i = len; i; i--) {
+		w_ctr(base, 0x26);
+		*buffer++ = r_dtr(base);
+		w_ctr(base, 0x25);
+	}
+	return 1;		/* All went well - we hope! */
+}
+
+static int imm_out(imm_struct *dev, char *buffer, int len)
+{
+	unsigned short ppb = dev->base;
+	int r = imm_wait(dev);
+
+	/*
+	 * Make sure that:
+	 * a) the SCSI bus is BUSY (device still listening)
+	 * b) the device is listening
+	 */
+	if ((r & 0x18) != 0x08) {
+		imm_fail(dev, DID_ERROR);
+		printk("IMM: returned SCSI status %2x\n", r);
+		return 0;
+	}
+	switch (dev->mode) {
+	case IMM_EPP_32:
+	case IMM_EPP_16:
+	case IMM_EPP_8:
+		epp_reset(ppb);
+		w_ctr(ppb, 0x4);
+#ifdef CONFIG_SCSI_IZIP_EPP16
+		if (!(((long) buffer | len) & 0x01))
+			outsw(ppb + 4, buffer, len >> 1);
+#else
+		if (!(((long) buffer | len) & 0x03))
+			outsl(ppb + 4, buffer, len >> 2);
+#endif
+		else
+			outsb(ppb + 4, buffer, len);
+		w_ctr(ppb, 0xc);
+		r = !(r_str(ppb) & 0x01);
+		w_ctr(ppb, 0xc);
+		ecp_sync(dev);
+		break;
+
+	case IMM_NIBBLE:
+	case IMM_PS2:
+		/* 8 bit output, with a loop */
+		r = imm_byte_out(ppb, buffer, len);
+		break;
+
+	default:
+		printk("IMM: bug in imm_out()\n");
+		r = 0;
+	}
+	return r;
+}
+
+static int imm_in(imm_struct *dev, char *buffer, int len)
+{
+	unsigned short ppb = dev->base;
+	int r = imm_wait(dev);
+
+	/*
+	 * Make sure that:
+	 * a) the SCSI bus is BUSY (device still listening)
+	 * b) the device is sending data
+	 */
+	if ((r & 0x18) != 0x18) {
+		imm_fail(dev, DID_ERROR);
+		return 0;
+	}
+	switch (dev->mode) {
+	case IMM_NIBBLE:
+		/* 4 bit input, with a loop */
+		r = imm_nibble_in(ppb, buffer, len);
+		w_ctr(ppb, 0xc);
+		break;
+
+	case IMM_PS2:
+		/* 8 bit input, with a loop */
+		r = imm_byte_in(ppb, buffer, len);
+		w_ctr(ppb, 0xc);
+		break;
+
+	case IMM_EPP_32:
+	case IMM_EPP_16:
+	case IMM_EPP_8:
+		epp_reset(ppb);
+		w_ctr(ppb, 0x24);
+#ifdef CONFIG_SCSI_IZIP_EPP16
+		if (!(((long) buffer | len) & 0x01))
+			insw(ppb + 4, buffer, len >> 1);
+#else
+		if (!(((long) buffer | len) & 0x03))
+			insl(ppb + 4, buffer, len >> 2);
+#endif
+		else
+			insb(ppb + 4, buffer, len);
+		w_ctr(ppb, 0x2c);
+		r = !(r_str(ppb) & 0x01);
+		w_ctr(ppb, 0x2c);
+		ecp_sync(dev);
+		break;
+
+	default:
+		printk("IMM: bug in imm_ins()\n");
+		r = 0;
+		break;
+	}
+	return r;
+}
+
+static int imm_cpp(unsigned short ppb, unsigned char b)
+{
+	/*
+	 * Comments on udelay values refer to the
+	 * Command Packet Protocol (CPP) timing diagram.
+	 */
+
+	unsigned char s1, s2, s3;
+	w_ctr(ppb, 0x0c);
+	udelay(2);		/* 1 usec - infinite */
+	w_dtr(ppb, 0xaa);
+	udelay(10);		/* 7 usec - infinite */
+	w_dtr(ppb, 0x55);
+	udelay(10);		/* 7 usec - infinite */
+	w_dtr(ppb, 0x00);
+	udelay(10);		/* 7 usec - infinite */
+	w_dtr(ppb, 0xff);
+	udelay(10);		/* 7 usec - infinite */
+	s1 = r_str(ppb) & 0xb8;
+	w_dtr(ppb, 0x87);
+	udelay(10);		/* 7 usec - infinite */
+	s2 = r_str(ppb) & 0xb8;
+	w_dtr(ppb, 0x78);
+	udelay(10);		/* 7 usec - infinite */
+	s3 = r_str(ppb) & 0x38;
+	/*
+	 * Values for b are:
+	 * 0000 00aa    Assign address aa to current device
+	 * 0010 00aa    Select device aa in EPP Winbond mode
+	 * 0010 10aa    Select device aa in EPP mode
+	 * 0011 xxxx    Deselect all devices
+	 * 0110 00aa    Test device aa
+	 * 1101 00aa    Select device aa in ECP mode
+	 * 1110 00aa    Select device aa in Compatible mode
+	 */
+	w_dtr(ppb, b);
+	udelay(2);		/* 1 usec - infinite */
+	w_ctr(ppb, 0x0c);
+	udelay(10);		/* 7 usec - infinite */
+	w_ctr(ppb, 0x0d);
+	udelay(2);		/* 1 usec - infinite */
+	w_ctr(ppb, 0x0c);
+	udelay(10);		/* 7 usec - infinite */
+	w_dtr(ppb, 0xff);
+	udelay(10);		/* 7 usec - infinite */
+
+	/*
+	 * The following table is electrical pin values.
+	 * (BSY is inverted at the CTR register)
+	 *
+	 *       BSY  ACK  POut SEL  Fault
+	 * S1    0    X    1    1    1
+	 * S2    1    X    0    1    1
+	 * S3    L    X    1    1    S
+	 *
+	 * L => Last device in chain
+	 * S => Selected
+	 *
+	 * Observered values for S1,S2,S3 are:
+	 * Disconnect => f8/58/78
+	 * Connect    => f8/58/70
+	 */
+	if ((s1 == 0xb8) && (s2 == 0x18) && (s3 == 0x30))
+		return 1;	/* Connected */
+	if ((s1 == 0xb8) && (s2 == 0x18) && (s3 == 0x38))
+		return 0;	/* Disconnected */
+
+	return -1;		/* No device present */
+}
+
+static inline int imm_connect(imm_struct *dev, int flag)
+{
+	unsigned short ppb = dev->base;
+
+	imm_cpp(ppb, 0xe0);	/* Select device 0 in compatible mode */
+	imm_cpp(ppb, 0x30);	/* Disconnect all devices */
+
+	if ((dev->mode == IMM_EPP_8) ||
+	    (dev->mode == IMM_EPP_16) ||
+	    (dev->mode == IMM_EPP_32))
+		return imm_cpp(ppb, 0x28);	/* Select device 0 in EPP mode */
+	return imm_cpp(ppb, 0xe0);	/* Select device 0 in compatible mode */
+}
+
+static void imm_disconnect(imm_struct *dev)
+{
+	imm_cpp(dev->base, 0x30);	/* Disconnect all devices */
+}
+
+static int imm_select(imm_struct *dev, int target)
+{
+	int k;
+	unsigned short ppb = dev->base;
+
+	/*
+	 * Firstly we want to make sure there is nothing
+	 * holding onto the SCSI bus.
+	 */
+	w_ctr(ppb, 0xc);
+
+	k = IMM_SELECT_TMO;
+	do {
+		k--;
+	} while ((r_str(ppb) & 0x08) && (k));
+
+	if (!k)
+		return 0;
+
+	/*
+	 * Now assert the SCSI ID (HOST and TARGET) on the data bus
+	 */
+	w_ctr(ppb, 0x4);
+	w_dtr(ppb, 0x80 | (1 << target));
+	udelay(1);
+
+	/*
+	 * Deassert SELIN first followed by STROBE
+	 */
+	w_ctr(ppb, 0xc);
+	w_ctr(ppb, 0xd);
+
+	/*
+	 * ACK should drop low while SELIN is deasserted.
+	 * FAULT should drop low when the SCSI device latches the bus.
+	 */
+	k = IMM_SELECT_TMO;
+	do {
+		k--;
+	}
+	while (!(r_str(ppb) & 0x08) && (k));
+
+	/*
+	 * Place the interface back into a sane state (status mode)
+	 */
+	w_ctr(ppb, 0xc);
+	return (k) ? 1 : 0;
+}
+
+static int imm_init(imm_struct *dev)
+{
+	if (imm_connect(dev, 0) != 1)
+		return -EIO;
+	imm_reset_pulse(dev->base);
+	udelay(1000);	/* Delay to allow devices to settle */
+	imm_disconnect(dev);
+	udelay(1000);	/* Another delay to allow devices to settle */
+	return device_check(dev);
+}
+
+static inline int imm_send_command(struct scsi_cmnd *cmd)
+{
+	imm_struct *dev = imm_dev(cmd->device->host);
+	int k;
+
+	/* NOTE: IMM uses byte pairs */
+	for (k = 0; k < cmd->cmd_len; k += 2)
+		if (!imm_out(dev, &cmd->cmnd[k], 2))
+			return 0;
+	return 1;
+}
+
+/*
+ * The bulk flag enables some optimisations in the data transfer loops,
+ * it should be true for any command that transfers data in integral
+ * numbers of sectors.
+ * 
+ * The driver appears to remain stable if we speed up the parallel port
+ * i/o in this function, but not elsewhere.
+ */
+static int imm_completion(struct scsi_cmnd *cmd)
+{
+	/* Return codes:
+	 * -1     Error
+	 *  0     Told to schedule
+	 *  1     Finished data transfer
+	 */
+	imm_struct *dev = imm_dev(cmd->device->host);
+	unsigned short ppb = dev->base;
+	unsigned long start_jiffies = jiffies;
+
+	unsigned char r, v;
+	int fast, bulk, status;
+
+	v = cmd->cmnd[0];
+	bulk = ((v == READ_6) ||
+		(v == READ_10) || (v == WRITE_6) || (v == WRITE_10));
+
+	/*
+	 * We only get here if the drive is ready to comunicate,
+	 * hence no need for a full imm_wait.
+	 */
+	w_ctr(ppb, 0x0c);
+	r = (r_str(ppb) & 0xb8);
+
+	/*
+	 * while (device is not ready to send status byte)
+	 *     loop;
+	 */
+	while (r != (unsigned char) 0xb8) {
+		/*
+		 * If we have been running for more than a full timer tick
+		 * then take a rest.
+		 */
+		if (time_after(jiffies, start_jiffies + 1))
+			return 0;
+
+		/*
+		 * FAIL if:
+		 * a) Drive status is screwy (!ready && !present)
+		 * b) Drive is requesting/sending more data than expected
+		 */
+		if (((r & 0x88) != 0x88) || (cmd->SCp.this_residual <= 0)) {
+			imm_fail(dev, DID_ERROR);
+			return -1;	/* ERROR_RETURN */
+		}
+		/* determine if we should use burst I/O */
+		if (dev->rd == 0) {
+			fast = (bulk
+				&& (cmd->SCp.this_residual >=
+				    IMM_BURST_SIZE)) ? IMM_BURST_SIZE : 2;
+			status = imm_out(dev, cmd->SCp.ptr, fast);
+		} else {
+			fast = (bulk
+				&& (cmd->SCp.this_residual >=
+				    IMM_BURST_SIZE)) ? IMM_BURST_SIZE : 1;
+			status = imm_in(dev, cmd->SCp.ptr, fast);
+		}
+
+		cmd->SCp.ptr += fast;
+		cmd->SCp.this_residual -= fast;
+
+		if (!status) {
+			imm_fail(dev, DID_BUS_BUSY);
+			return -1;	/* ERROR_RETURN */
+		}
+		if (cmd->SCp.buffer && !cmd->SCp.this_residual) {
+			/* if scatter/gather, advance to the next segment */
+			if (cmd->SCp.buffers_residual--) {
+				cmd->SCp.buffer++;
+				cmd->SCp.this_residual =
+				    cmd->SCp.buffer->length;
+				cmd->SCp.ptr =
+				    page_address(cmd->SCp.buffer->page) +
+				    cmd->SCp.buffer->offset;
+
+				/*
+				 * Make sure that we transfer even number of bytes
+				 * otherwise it makes imm_byte_out() messy.
+				 */
+				if (cmd->SCp.this_residual & 0x01)
+					cmd->SCp.this_residual++;
+			}
+		}
+		/* Now check to see if the drive is ready to comunicate */
+		w_ctr(ppb, 0x0c);
+		r = (r_str(ppb) & 0xb8);
+
+		/* If not, drop back down to the scheduler and wait a timer tick */
+		if (!(r & 0x80))
+			return 0;
+	}
+	return 1;		/* FINISH_RETURN */
+}
+
+/*
+ * Since the IMM itself doesn't generate interrupts, we use
+ * the scheduler's task queue to generate a stream of call-backs and
+ * complete the request when the drive is ready.
+ */
+static void imm_interrupt(void *data)
+{
+	imm_struct *dev = (imm_struct *) data;
+	struct scsi_cmnd *cmd = dev->cur_cmd;
+	struct Scsi_Host *host = cmd->device->host;
+	unsigned long flags;
+
+	if (!cmd) {
+		printk("IMM: bug in imm_interrupt\n");
+		return;
+	}
+	if (imm_engine(dev, cmd)) {
+		INIT_WORK(&dev->imm_tq, imm_interrupt, (void *) dev);
+		schedule_delayed_work(&dev->imm_tq, 1);
+		return;
+	}
+	/* Command must of completed hence it is safe to let go... */
+#if IMM_DEBUG > 0
+	switch ((cmd->result >> 16) & 0xff) {
+	case DID_OK:
+		break;
+	case DID_NO_CONNECT:
+		printk("imm: no device at SCSI ID %i\n", cmd->device->id);
+		break;
+	case DID_BUS_BUSY:
+		printk("imm: BUS BUSY - EPP timeout detected\n");
+		break;
+	case DID_TIME_OUT:
+		printk("imm: unknown timeout\n");
+		break;
+	case DID_ABORT:
+		printk("imm: told to abort\n");
+		break;
+	case DID_PARITY:
+		printk("imm: parity error (???)\n");
+		break;
+	case DID_ERROR:
+		printk("imm: internal driver error\n");
+		break;
+	case DID_RESET:
+		printk("imm: told to reset device\n");
+		break;
+	case DID_BAD_INTR:
+		printk("imm: bad interrupt (???)\n");
+		break;
+	default:
+		printk("imm: bad return code (%02x)\n",
+		       (cmd->result >> 16) & 0xff);
+	}
+#endif
+
+	if (cmd->SCp.phase > 1)
+		imm_disconnect(dev);
+
+	imm_pb_dismiss(dev);
+
+	spin_lock_irqsave(host->host_lock, flags);
+	dev->cur_cmd = NULL;
+	cmd->scsi_done(cmd);
+	spin_unlock_irqrestore(host->host_lock, flags);
+	return;
+}
+
+static int imm_engine(imm_struct *dev, struct scsi_cmnd *cmd)
+{
+	unsigned short ppb = dev->base;
+	unsigned char l = 0, h = 0;
+	int retv, x;
+
+	/* First check for any errors that may have occurred
+	 * Here we check for internal errors
+	 */
+	if (dev->failed)
+		return 0;
+
+	switch (cmd->SCp.phase) {
+	case 0:		/* Phase 0 - Waiting for parport */
+		if (time_after(jiffies, dev->jstart + HZ)) {
+			/*
+			 * We waited more than a second
+			 * for parport to call us
+			 */
+			imm_fail(dev, DID_BUS_BUSY);
+			return 0;
+		}
+		return 1;	/* wait until imm_wakeup claims parport */
+		/* Phase 1 - Connected */
+	case 1:
+		imm_connect(dev, CONNECT_EPP_MAYBE);
+		cmd->SCp.phase++;
+
+		/* Phase 2 - We are now talking to the scsi bus */
+	case 2:
+		if (!imm_select(dev, cmd->device->id)) {
+			imm_fail(dev, DID_NO_CONNECT);
+			return 0;
+		}
+		cmd->SCp.phase++;
+
+		/* Phase 3 - Ready to accept a command */
+	case 3:
+		w_ctr(ppb, 0x0c);
+		if (!(r_str(ppb) & 0x80))
+			return 1;
+
+		if (!imm_send_command(cmd))
+			return 0;
+		cmd->SCp.phase++;
+
+		/* Phase 4 - Setup scatter/gather buffers */
+	case 4:
+		if (cmd->use_sg) {
+			/* if many buffers are available, start filling the first */
+			cmd->SCp.buffer =
+			    (struct scatterlist *) cmd->request_buffer;
+			cmd->SCp.this_residual = cmd->SCp.buffer->length;
+			cmd->SCp.ptr =
+			    page_address(cmd->SCp.buffer->page) +
+			    cmd->SCp.buffer->offset;
+		} else {
+			/* else fill the only available buffer */
+			cmd->SCp.buffer = NULL;
+			cmd->SCp.this_residual = cmd->request_bufflen;
+			cmd->SCp.ptr = cmd->request_buffer;
+		}
+		cmd->SCp.buffers_residual = cmd->use_sg - 1;
+		cmd->SCp.phase++;
+		if (cmd->SCp.this_residual & 0x01)
+			cmd->SCp.this_residual++;
+		/* Phase 5 - Pre-Data transfer stage */
+	case 5:
+		/* Spin lock for BUSY */
+		w_ctr(ppb, 0x0c);
+		if (!(r_str(ppb) & 0x80))
+			return 1;
+
+		/* Require negotiation for read requests */
+		x = (r_str(ppb) & 0xb8);
+		dev->rd = (x & 0x10) ? 1 : 0;
+		dev->dp = (x & 0x20) ? 0 : 1;
+
+		if ((dev->dp) && (dev->rd))
+			if (imm_negotiate(dev))
+				return 0;
+		cmd->SCp.phase++;
+
+		/* Phase 6 - Data transfer stage */
+	case 6:
+		/* Spin lock for BUSY */
+		w_ctr(ppb, 0x0c);
+		if (!(r_str(ppb) & 0x80))
+			return 1;
+
+		if (dev->dp) {
+			retv = imm_completion(cmd);
+			if (retv == -1)
+				return 0;
+			if (retv == 0)
+				return 1;
+		}
+		cmd->SCp.phase++;
+
+		/* Phase 7 - Post data transfer stage */
+	case 7:
+		if ((dev->dp) && (dev->rd)) {
+			if ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {
+				w_ctr(ppb, 0x4);
+				w_ctr(ppb, 0xc);
+				w_ctr(ppb, 0xe);
+				w_ctr(ppb, 0x4);
+			}
+		}
+		cmd->SCp.phase++;
+
+		/* Phase 8 - Read status/message */
+	case 8:
+		/* Check for data overrun */
+		if (imm_wait(dev) != (unsigned char) 0xb8) {
+			imm_fail(dev, DID_ERROR);
+			return 0;
+		}
+		if (imm_negotiate(dev))
+			return 0;
+		if (imm_in(dev, &l, 1)) {	/* read status byte */
+			/* Check for optional message byte */
+			if (imm_wait(dev) == (unsigned char) 0xb8)
+				imm_in(dev, &h, 1);
+			cmd->result = (DID_OK << 16) + (l & STATUS_MASK);
+		}
+		if ((dev->mode == IMM_NIBBLE) || (dev->mode == IMM_PS2)) {
+			w_ctr(ppb, 0x4);
+			w_ctr(ppb, 0xc);
+			w_ctr(ppb, 0xe);
+			w_ctr(ppb, 0x4);
+		}
+		return 0;	/* Finished */
+		break;
+
+	default:
+		printk("imm: Invalid scsi phase\n");
+	}
+	return 0;
+}
+
+static int imm_queuecommand(struct scsi_cmnd *cmd,
+		void (*done)(struct scsi_cmnd *))
+{
+	imm_struct *dev = imm_dev(cmd->device->host);
+
+	if (dev->cur_cmd) {
+		printk("IMM: bug in imm_queuecommand\n");
+		return 0;
+	}
+	dev->failed = 0;
+	dev->jstart = jiffies;
+	dev->cur_cmd = cmd;
+	cmd->scsi_done = done;
+	cmd->result = DID_ERROR << 16;	/* default return code */
+	cmd->SCp.phase = 0;	/* bus free */
+
+	INIT_WORK(&dev->imm_tq, imm_interrupt, dev);
+	schedule_work(&dev->imm_tq);
+
+	imm_pb_claim(dev);
+
+	return 0;
+}
+
+/*
+ * Apparently the disk->capacity attribute is off by 1 sector 
+ * for all disk drives.  We add the one here, but it should really
+ * be done in sd.c.  Even if it gets fixed there, this will still
+ * work.
+ */
+static int imm_biosparam(struct scsi_device *sdev, struct block_device *dev,
+			 sector_t capacity, int ip[])
+{
+	ip[0] = 0x40;
+	ip[1] = 0x20;
+	ip[2] = ((unsigned long) capacity + 1) / (ip[0] * ip[1]);
+	if (ip[2] > 1024) {
+		ip[0] = 0xff;
+		ip[1] = 0x3f;
+		ip[2] = ((unsigned long) capacity + 1) / (ip[0] * ip[1]);
+	}
+	return 0;
+}
+
+static int imm_abort(struct scsi_cmnd *cmd)
+{
+	imm_struct *dev = imm_dev(cmd->device->host);
+	/*
+	 * There is no method for aborting commands since Iomega
+	 * have tied the SCSI_MESSAGE line high in the interface
+	 */
+
+	switch (cmd->SCp.phase) {
+	case 0:		/* Do not have access to parport */
+	case 1:		/* Have not connected to interface */
+		dev->cur_cmd = NULL;	/* Forget the problem */
+		return SUCCESS;
+		break;
+	default:		/* SCSI command sent, can not abort */
+		return FAILED;
+		break;
+	}
+}
+
+static void imm_reset_pulse(unsigned int base)
+{
+	w_ctr(base, 0x04);
+	w_dtr(base, 0x40);
+	udelay(1);
+	w_ctr(base, 0x0c);
+	w_ctr(base, 0x0d);
+	udelay(50);
+	w_ctr(base, 0x0c);
+	w_ctr(base, 0x04);
+}
+
+static int imm_reset(struct scsi_cmnd *cmd)
+{
+	imm_struct *dev = imm_dev(cmd->device->host);
+
+	if (cmd->SCp.phase)
+		imm_disconnect(dev);
+	dev->cur_cmd = NULL;	/* Forget the problem */
+
+	imm_connect(dev, CONNECT_NORMAL);
+	imm_reset_pulse(dev->base);
+	udelay(1000);		/* device settle delay */
+	imm_disconnect(dev);
+	udelay(1000);		/* device settle delay */
+	return SUCCESS;
+}
+
+static int device_check(imm_struct *dev)
+{
+	/* This routine looks for a device and then attempts to use EPP
+	   to send a command. If all goes as planned then EPP is available. */
+
+	static char cmd[6] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	int loop, old_mode, status, k, ppb = dev->base;
+	unsigned char l;
+
+	old_mode = dev->mode;
+	for (loop = 0; loop < 8; loop++) {
+		/* Attempt to use EPP for Test Unit Ready */
+		if ((ppb & 0x0007) == 0x0000)
+			dev->mode = IMM_EPP_32;
+
+	      second_pass:
+		imm_connect(dev, CONNECT_EPP_MAYBE);
+		/* Select SCSI device */
+		if (!imm_select(dev, loop)) {
+			imm_disconnect(dev);
+			continue;
+		}
+		printk("imm: Found device at ID %i, Attempting to use %s\n",
+		       loop, IMM_MODE_STRING[dev->mode]);
+
+		/* Send SCSI command */
+		status = 1;
+		w_ctr(ppb, 0x0c);
+		for (l = 0; (l < 3) && (status); l++)
+			status = imm_out(dev, &cmd[l << 1], 2);
+
+		if (!status) {
+			imm_disconnect(dev);
+			imm_connect(dev, CONNECT_EPP_MAYBE);
+			imm_reset_pulse(dev->base);
+			udelay(1000);
+			imm_disconnect(dev);
+			udelay(1000);
+			if (dev->mode == IMM_EPP_32) {
+				dev->mode = old_mode;
+				goto second_pass;
+			}
+			printk("imm: Unable to establish communication\n");
+			return -EIO;
+		}
+		w_ctr(ppb, 0x0c);
+
+		k = 1000000;	/* 1 Second */
+		do {
+			l = r_str(ppb);
+			k--;
+			udelay(1);
+		} while (!(l & 0x80) && (k));
+
+		l &= 0xb8;
+
+		if (l != 0xb8) {
+			imm_disconnect(dev);
+			imm_connect(dev, CONNECT_EPP_MAYBE);
+			imm_reset_pulse(dev->base);
+			udelay(1000);
+			imm_disconnect(dev);
+			udelay(1000);
+			if (dev->mode == IMM_EPP_32) {
+				dev->mode = old_mode;
+				goto second_pass;
+			}
+			printk
+			    ("imm: Unable to establish communication\n");
+			return -EIO;
+		}
+		imm_disconnect(dev);
+		printk
+		    ("imm: Communication established at 0x%x with ID %i using %s\n",
+		     ppb, loop, IMM_MODE_STRING[dev->mode]);
+		imm_connect(dev, CONNECT_EPP_MAYBE);
+		imm_reset_pulse(dev->base);
+		udelay(1000);
+		imm_disconnect(dev);
+		udelay(1000);
+		return 0;
+	}
+	printk("imm: No devices found\n");
+	return -ENODEV;
+}
+
+static int imm_adjust_queue(struct scsi_device *device)
+{
+	blk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);
+	return 0;
+}
+
+static struct scsi_host_template imm_template = {
+	.module			= THIS_MODULE,
+	.proc_name		= "imm",
+	.proc_info		= imm_proc_info,
+	.name			= "Iomega VPI2 (imm) interface",
+	.queuecommand		= imm_queuecommand,
+	.eh_abort_handler	= imm_abort,
+	.eh_bus_reset_handler	= imm_reset,
+	.eh_host_reset_handler	= imm_reset,
+	.bios_param		= imm_biosparam,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.can_queue		= 1,
+	.slave_alloc		= imm_adjust_queue,
+	.unchecked_isa_dma	= 1, /* imm cannot deal with highmem, so
+				      * this is an easy trick to ensure
+				      * all io pages for this host reside
+				      * in low memory */
+};
+
+/***************************************************************************
+ *                   Parallel port probing routines                        *
+ ***************************************************************************/
+
+static LIST_HEAD(imm_hosts);
+
+static int __imm_attach(struct parport *pb)
+{
+	struct Scsi_Host *host;
+	imm_struct *dev;
+	DECLARE_WAIT_QUEUE_HEAD(waiting);
+	DEFINE_WAIT(wait);
+	int ports;
+	int modes, ppb;
+	int err = -ENOMEM;
+
+	init_waitqueue_head(&waiting);
+
+	dev = kmalloc(sizeof(imm_struct), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	memset(dev, 0, sizeof(imm_struct));
+
+	dev->base = -1;
+	dev->mode = IMM_AUTODETECT;
+	INIT_LIST_HEAD(&dev->list);
+
+	dev->dev = parport_register_device(pb, "imm", NULL, imm_wakeup,
+						NULL, 0, dev);
+
+	if (!dev->dev)
+		goto out;
+
+
+	/* Claim the bus so it remembers what we do to the control
+	 * registers. [ CTR and ECP ]
+	 */
+	err = -EBUSY;
+	dev->waiting = &waiting;
+	prepare_to_wait(&waiting, &wait, TASK_UNINTERRUPTIBLE);
+	if (imm_pb_claim(dev))
+		schedule_timeout(3 * HZ);
+	if (dev->wanted) {
+		printk(KERN_ERR "imm%d: failed to claim parport because "
+			"a pardevice is owning the port for too long "
+			"time!\n", pb->number);
+		imm_pb_dismiss(dev);
+		dev->waiting = NULL;
+		finish_wait(&waiting, &wait);
+		goto out1;
+	}
+	dev->waiting = NULL;
+	finish_wait(&waiting, &wait);
+	ppb = dev->base = dev->dev->port->base;
+	dev->base_hi = dev->dev->port->base_hi;
+	w_ctr(ppb, 0x0c);
+	modes = dev->dev->port->modes;
+
+	/* Mode detection works up the chain of speed
+	 * This avoids a nasty if-then-else-if-... tree
+	 */
+	dev->mode = IMM_NIBBLE;
+
+	if (modes & PARPORT_MODE_TRISTATE)
+		dev->mode = IMM_PS2;
+
+	/* Done configuration */
+
+	err = imm_init(dev);
+
+	imm_pb_release(dev);
+
+	if (err)
+		goto out1;
+
+	/* now the glue ... */
+	if (dev->mode == IMM_NIBBLE || dev->mode == IMM_PS2)
+		ports = 3;
+	else
+		ports = 8;
+
+	INIT_WORK(&dev->imm_tq, imm_interrupt, dev);
+
+	err = -ENOMEM;
+	host = scsi_host_alloc(&imm_template, sizeof(imm_struct *));
+	if (!host)
+		goto out1;
+	host->io_port = pb->base;
+	host->n_io_port = ports;
+	host->dma_channel = -1;
+	host->unique_id = pb->number;
+	*(imm_struct **)&host->hostdata = dev;
+	dev->host = host;
+	list_add_tail(&dev->list, &imm_hosts);
+	err = scsi_add_host(host, NULL);
+	if (err)
+		goto out2;
+	scsi_scan_host(host);
+	return 0;
+
+out2:
+	list_del_init(&dev->list);
+	scsi_host_put(host);
+out1:
+	parport_unregister_device(dev->dev);
+out:
+	kfree(dev);
+	return err;
+}
+
+static void imm_attach(struct parport *pb)
+{
+	__imm_attach(pb);
+}
+
+static void imm_detach(struct parport *pb)
+{
+	imm_struct *dev;
+	list_for_each_entry(dev, &imm_hosts, list) {
+		if (dev->dev->port == pb) {
+			list_del_init(&dev->list);
+			scsi_remove_host(dev->host);
+			scsi_host_put(dev->host);
+			parport_unregister_device(dev->dev);
+			kfree(dev);
+			break;
+		}
+	}
+}
+
+static struct parport_driver imm_driver = {
+	.name	= "imm",
+	.attach	= imm_attach,
+	.detach	= imm_detach,
+};
+
+static int __init imm_driver_init(void)
+{
+	printk("imm: Version %s\n", IMM_VERSION);
+	return parport_register_driver(&imm_driver);
+}
+
+static void __exit imm_driver_exit(void)
+{
+	parport_unregister_driver(&imm_driver);
+}
+
+module_init(imm_driver_init);
+module_exit(imm_driver_exit);
+
+MODULE_LICENSE("GPL");
