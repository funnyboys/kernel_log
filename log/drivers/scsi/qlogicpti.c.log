commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 61949d91c25b..3790e8b70bba 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -30,6 +30,7 @@
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/firmware.h>
+#include <linux/pgtable.h>
 
 #include <asm/byteorder.h>
 
@@ -37,7 +38,6 @@
 
 #include <asm/dma.h>
 #include <asm/ptrace.h>
-#include <linux/pgtable.h>
 #include <asm/oplib.h>
 #include <asm/io.h>
 #include <asm/irq.h>

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index d539beef3ce8..61949d91c25b 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -37,7 +37,7 @@
 
 #include <asm/dma.h>
 #include <asm/ptrace.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/oplib.h>
 #include <asm/io.h>
 #include <asm/irq.h>

commit 6d44c692c12c33bab92d3e0f524f66c3e97b7bdd
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Jul 29 06:03:45 2019 -0500

    scsi: qlogicpti: Mark expected switch fall-throughs
    
    Mark switch cases where we are expecting to fall through.
    
    This patch fixes the following warnings (Building: sparc defconfig):
    
    drivers/scsi/qlogicpti.c: In function 'qlogicpti_mbox_command':
    drivers/scsi/qlogicpti.c:202:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 6: sbus_writew(param[5], qpti->qregs + MBOX5);
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:203:2: note: here
      case 5: sbus_writew(param[4], qpti->qregs + MBOX4);
      ^~~~
    drivers/scsi/qlogicpti.c:203:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 5: sbus_writew(param[4], qpti->qregs + MBOX4);
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:204:2: note: here
      case 4: sbus_writew(param[3], qpti->qregs + MBOX3);
      ^~~~
    drivers/scsi/qlogicpti.c:204:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 4: sbus_writew(param[3], qpti->qregs + MBOX3);
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:205:2: note: here
      case 3: sbus_writew(param[2], qpti->qregs + MBOX2);
      ^~~~
    drivers/scsi/qlogicpti.c:205:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 3: sbus_writew(param[2], qpti->qregs + MBOX2);
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:206:2: note: here
      case 2: sbus_writew(param[1], qpti->qregs + MBOX1);
      ^~~~
    drivers/scsi/qlogicpti.c:206:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 2: sbus_writew(param[1], qpti->qregs + MBOX1);
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:207:2: note: here
      case 1: sbus_writew(param[0], qpti->qregs + MBOX0);
      ^~~~
    drivers/scsi/qlogicpti.c:256:19: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 6: param[5] = sbus_readw(qpti->qregs + MBOX5);
              ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:257:2: note: here
      case 5: param[4] = sbus_readw(qpti->qregs + MBOX4);
      ^~~~
    drivers/scsi/qlogicpti.c:257:19: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 5: param[4] = sbus_readw(qpti->qregs + MBOX4);
              ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:258:2: note: here
      case 4: param[3] = sbus_readw(qpti->qregs + MBOX3);
      ^~~~
    drivers/scsi/qlogicpti.c:258:19: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 4: param[3] = sbus_readw(qpti->qregs + MBOX3);
              ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:259:2: note: here
      case 3: param[2] = sbus_readw(qpti->qregs + MBOX2);
      ^~~~
    drivers/scsi/qlogicpti.c:259:19: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 3: param[2] = sbus_readw(qpti->qregs + MBOX2);
              ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:260:2: note: here
      case 2: param[1] = sbus_readw(qpti->qregs + MBOX1);
      ^~~~
    drivers/scsi/qlogicpti.c:260:19: warning: this statement may fall through [-Wimplicit-fallthrough=]
      case 2: param[1] = sbus_readw(qpti->qregs + MBOX1);
              ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/qlogicpti.c:261:2: note: here
      case 1: param[0] = sbus_readw(qpti->qregs + MBOX0);
      ^~~~
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 9335849f6bea..d539beef3ce8 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -200,10 +200,15 @@ static int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int f
 	/* Write mailbox command registers. */
 	switch (mbox_param[param[0]] >> 4) {
 	case 6: sbus_writew(param[5], qpti->qregs + MBOX5);
+		/* Fall through */
 	case 5: sbus_writew(param[4], qpti->qregs + MBOX4);
+		/* Fall through */
 	case 4: sbus_writew(param[3], qpti->qregs + MBOX3);
+		/* Fall through */
 	case 3: sbus_writew(param[2], qpti->qregs + MBOX2);
+		/* Fall through */
 	case 2: sbus_writew(param[1], qpti->qregs + MBOX1);
+		/* Fall through */
 	case 1: sbus_writew(param[0], qpti->qregs + MBOX0);
 	}
 
@@ -254,10 +259,15 @@ static int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int f
 	/* Read back output parameters. */
 	switch (mbox_param[param[0]] & 0xf) {
 	case 6: param[5] = sbus_readw(qpti->qregs + MBOX5);
+		/* Fall through */
 	case 5: param[4] = sbus_readw(qpti->qregs + MBOX4);
+		/* Fall through */
 	case 4: param[3] = sbus_readw(qpti->qregs + MBOX3);
+		/* Fall through */
 	case 3: param[2] = sbus_readw(qpti->qregs + MBOX2);
+		/* Fall through */
 	case 2: param[1] = sbus_readw(qpti->qregs + MBOX1);
+		/* Fall through */
 	case 1: param[0] = sbus_readw(qpti->qregs + MBOX0);
 	}
 

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 0e22512bd3e4..9335849f6bea 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* qlogicpti.c: Performance Technologies QlogicISP sbus card driver.
  *
  * Copyright (C) 1996, 2006, 2008 David S. Miller (davem@davemloft.net)

commit 7f8e12f1e21524bd498477893b235e908843f1b7
Author: Rob Herring <robh@kernel.org>
Date:   Wed Feb 13 10:08:29 2019 -0600

    scsi: qlogicpti: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    As prom_name is not used for anything else, remove it.
    
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index e35ce762d454..0e22512bd3e4 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1314,8 +1314,7 @@ static int qpti_sbus_probe(struct platform_device *op)
 	qpti->qhost = host;
 	qpti->op = op;
 	qpti->qpti_id = nqptis;
-	strcpy(qpti->prom_name, op->dev.of_node->name);
-	qpti->is_pti = strcmp(qpti->prom_name, "QLGC,isp");
+	qpti->is_pti = !of_node_name_eq(op->dev.of_node, "QLGC,isp");
 
 	if (qpti_map_regs(qpti) < 0)
 		goto fail_unlink;

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 9d09228eee28..e35ce762d454 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1287,7 +1287,6 @@ static struct scsi_host_template qpti_template = {
 	.can_queue		= QLOGICPTI_REQ_QUEUE_LEN,
 	.this_id		= 7,
 	.sg_tablesize		= QLOGICPTI_MAX_SG(QLOGICPTI_REQ_QUEUE_LEN),
-	.use_clustering		= ENABLE_CLUSTERING,
 };
 
 static const struct of_device_id qpti_match[];

commit c84b023a4c1461498abf0eda54f60e2fd64a1ca2
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jun 24 22:03:26 2018 +0800

    scsi: read host_busy via scsi_host_busy()
    
    No functional change.
    
    Just introduce scsi_host_busy() and replace the direct read of
    scsi_host->host_busy with this new API.
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 8578e566ab41..9d09228eee28 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -959,7 +959,7 @@ static inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int
 	/* Temporary workaround until bug is found and fixed (one bug has been found
 	   already, but fixing it makes things even worse) -jj */
 	int num_free = QLOGICPTI_REQ_QUEUE_LEN - REQ_QUEUE_DEPTH(in_ptr, out_ptr) - 64;
-	host->can_queue = atomic_read(&host->host_busy) + num_free;
+	host->can_queue = scsi_host_busy(host) + num_free;
 	host->sg_tablesize = QLOGICPTI_MAX_SG(num_free);
 }
 

commit 51b910c3c70986a5a0a84eea11cb8e904e37ba8b
Author: Christophe Jaillet <christophe.jaillet@wanadoo.fr>
Date:   Thu May 10 13:45:58 2018 +0200

    scsi: qlogicpti: Fix an error handling path in 'qpti_sbus_probe()'
    
    The 'free_irq()' call is not at the right place in the error handling
    path.  The changed order has been introduced in commit 3d4253d9afab
    ("[SCSI] qlogicpti: Convert to new SBUS device framework.")
    
    Fixes: 3d4253d9afab ("[SCSI] qlogicpti: Convert to new SBUS device framework.")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index cec9a14982e6..8578e566ab41 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1385,6 +1385,9 @@ static int qpti_sbus_probe(struct platform_device *op)
 			  qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE
 
+fail_free_irq:
+	free_irq(qpti->irq, qpti);
+
 fail_unmap_regs:
 	of_iounmap(&op->resource[0], qpti->qregs,
 		   resource_size(&op->resource[0]));
@@ -1392,9 +1395,6 @@ static int qpti_sbus_probe(struct platform_device *op)
 		of_iounmap(&op->resource[0], qpti->sreg,
 			   sizeof(unsigned char));
 
-fail_free_irq:
-	free_irq(qpti->irq, qpti);
-
 fail_unlink:
 	scsi_host_put(host);
 

commit fbf252335f8e2bd39d4ce59b1db0836a40ab227b
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Aug 28 10:14:26 2017 +0200

    scsi: qlogicpti: fixup qlogicpti_reset() definition
    
    A merge error crept in when formatting commit af167bc ("scsi: qlogicpti:
    move bus reset to host reset")
    
    Fixes: af167bc ("scsi: qlogicpti: move bus reset to host reset")
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 274ee1ccfea8..cec9a14982e6 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1250,9 +1250,10 @@ static int qlogicpti_abort(struct scsi_cmnd *Cmnd)
 	return return_status;
 }
 
-static int qlogicpti_reset(struct Scsi_Host *host)
+static int qlogicpti_reset(struct scsi_cmnd *Cmnd)
 {
 	u_short param[6];
+	struct Scsi_Host *host = Cmnd->device->host;
 	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
 	int return_status = SUCCESS;
 

commit af167bc42d86907a39a761539cb2990120ebbc8e
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:08 2017 +0200

    scsi: qlogicpti: move bus reset to host reset
    
    The bus reset function really is a host reset, so move it to
    eh_host_reset_handler().
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 69bfc0a1aea3..274ee1ccfea8 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1250,10 +1250,9 @@ static int qlogicpti_abort(struct scsi_cmnd *Cmnd)
 	return return_status;
 }
 
-static int qlogicpti_reset(struct scsi_cmnd *Cmnd)
+static int qlogicpti_reset(struct Scsi_Host *host)
 {
 	u_short param[6];
-	struct Scsi_Host *host = Cmnd->device->host;
 	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
 	int return_status = SUCCESS;
 
@@ -1283,7 +1282,7 @@ static struct scsi_host_template qpti_template = {
 	.queuecommand		= qlogicpti_queuecommand,
 	.slave_configure	= qlogicpti_slave_configure,
 	.eh_abort_handler	= qlogicpti_abort,
-	.eh_bus_reset_handler	= qlogicpti_reset,
+	.eh_host_reset_handler	= qlogicpti_reset,
 	.can_queue		= QLOGICPTI_REQ_QUEUE_LEN,
 	.this_id		= 7,
 	.sg_tablesize		= QLOGICPTI_MAX_SG(QLOGICPTI_REQ_QUEUE_LEN),

commit a6d24143fca421c836f78538705c8e5b3ef04e3d
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Feb 17 19:02:54 2016 +0530

    qlogicpti: Return correct error code
    
    The return value of of_ioremap on failure should be -ENODEV and not
    -1.
    
    Found using Coccinelle. A simplified version of the semantic patch
    used is:
    
    //<smpl>
    @@
    expression *e;
    @@
    
    e = of_ioremap(...);
    if (e == NULL) {
    ...
    return
    - -1
    + -ENODEV
    ;
    }
    //</smpl>
    
    The single call site only checks that the return value is less than 0,
    hence no change is required at the call site.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Reviewed-by: Shane Seymour <shane.seymour@hpe.com>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 676385ff28ef..69bfc0a1aea3 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -710,7 +710,7 @@ static int qpti_map_regs(struct qlogicpti *qpti)
 				 "PTI Qlogic/ISP");
 	if (!qpti->qregs) {
 		printk("PTI: Qlogic/ISP registers are unmappable\n");
-		return -1;
+		return -ENODEV;
 	}
 	if (qpti->is_pti) {
 		qpti->sreg = of_ioremap(&op->resource[0], (16 * 4096),
@@ -718,7 +718,7 @@ static int qpti_map_regs(struct qlogicpti *qpti)
 					"PTI Qlogic/ISP statreg");
 		if (!qpti->sreg) {
 			printk("PTI: Qlogic/ISP status register is unmappable\n");
-			return -1;
+			return -ENODEV;
 		}
 	}
 	return 0;

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index fe122700cad8..676385ff28ef 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1287,7 +1287,6 @@ static struct scsi_host_template qpti_template = {
 	.can_queue		= QLOGICPTI_REQ_QUEUE_LEN,
 	.this_id		= 7,
 	.sg_tablesize		= QLOGICPTI_MAX_SG(QLOGICPTI_REQ_QUEUE_LEN),
-	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 

commit b36069c833d9440774d5daab143ec15ea026f34a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:33 2014 +0200

    scsi: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 740ae495aa77..fe122700cad8 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1455,7 +1455,6 @@ MODULE_DEVICE_TABLE(of, qpti_match);
 static struct platform_driver qpti_sbus_driver = {
 	.driver = {
 		.name = "qpti",
-		.owner = THIS_MODULE,
 		.of_match_table = qpti_match,
 	},
 	.probe		= qpti_sbus_probe,

commit 74665016086615bbaa3fa6f83af410a0a4e029ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 22 15:29:29 2014 +0100

    scsi: convert host_busy to atomic_t
    
    Avoid taking the host-wide host_lock to check the per-host queue limit.
    Instead we do an atomic_inc_return early on to grab our slot in the queue,
    and if necessary decrement it after finishing all checks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Robert Elliott <elliott@hp.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 6d48d30bed05..740ae495aa77 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -959,7 +959,7 @@ static inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int
 	/* Temporary workaround until bug is found and fixed (one bug has been found
 	   already, but fixing it makes things even worse) -jj */
 	int num_free = QLOGICPTI_REQ_QUEUE_LEN - REQ_QUEUE_DEPTH(in_ptr, out_ptr) - 64;
-	host->can_queue = host->host_busy + num_free;
+	host->can_queue = atomic_read(&host->host_busy) + num_free;
 	host->sg_tablesize = QLOGICPTI_MAX_SG(num_free);
 }
 

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 71fddbc60f18..6d48d30bed05 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -461,7 +461,7 @@ static int qlogicpti_reset_hardware(struct Scsi_Host *host)
 
 #define PTI_RESET_LIMIT 400
 
-static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
+static int qlogicpti_load_firmware(struct qlogicpti *qpti)
 {
 	const struct firmware *fw;
 	const char fwname[] = "qlogic/isp1000.bin";
@@ -670,7 +670,7 @@ static int qlogicpti_verify_tmon(struct qlogicpti *qpti)
 
 static irqreturn_t qpti_intr(int irq, void *dev_id);
 
-static void __devinit qpti_chain_add(struct qlogicpti *qpti)
+static void qpti_chain_add(struct qlogicpti *qpti)
 {
 	spin_lock_irq(&qptichain_lock);
 	if (qptichain != NULL) {
@@ -686,7 +686,7 @@ static void __devinit qpti_chain_add(struct qlogicpti *qpti)
 	spin_unlock_irq(&qptichain_lock);
 }
 
-static void __devexit qpti_chain_del(struct qlogicpti *qpti)
+static void qpti_chain_del(struct qlogicpti *qpti)
 {
 	spin_lock_irq(&qptichain_lock);
 	if (qptichain == qpti) {
@@ -701,7 +701,7 @@ static void __devexit qpti_chain_del(struct qlogicpti *qpti)
 	spin_unlock_irq(&qptichain_lock);
 }
 
-static int __devinit qpti_map_regs(struct qlogicpti *qpti)
+static int qpti_map_regs(struct qlogicpti *qpti)
 {
 	struct platform_device *op = qpti->op;
 
@@ -724,7 +724,7 @@ static int __devinit qpti_map_regs(struct qlogicpti *qpti)
 	return 0;
 }
 
-static int __devinit qpti_register_irq(struct qlogicpti *qpti)
+static int qpti_register_irq(struct qlogicpti *qpti)
 {
 	struct platform_device *op = qpti->op;
 
@@ -749,7 +749,7 @@ static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 	return -1;
 }
 
-static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
+static void qpti_get_scsi_id(struct qlogicpti *qpti)
 {
 	struct platform_device *op = qpti->op;
 	struct device_node *dp;
@@ -803,7 +803,7 @@ static void qpti_get_clock(struct qlogicpti *qpti)
 /* The request and response queues must each be aligned
  * on a page boundary.
  */
-static int __devinit qpti_map_queues(struct qlogicpti *qpti)
+static int qpti_map_queues(struct qlogicpti *qpti)
 {
 	struct platform_device *op = qpti->op;
 
@@ -1292,7 +1292,7 @@ static struct scsi_host_template qpti_template = {
 };
 
 static const struct of_device_id qpti_match[];
-static int __devinit qpti_sbus_probe(struct platform_device *op)
+static int qpti_sbus_probe(struct platform_device *op)
 {
 	struct device_node *dp = op->dev.of_node;
 	struct Scsi_Host *host;
@@ -1402,7 +1402,7 @@ static int __devinit qpti_sbus_probe(struct platform_device *op)
 	return -ENODEV;
 }
 
-static int __devexit qpti_sbus_remove(struct platform_device *op)
+static int qpti_sbus_remove(struct platform_device *op)
 {
 	struct qlogicpti *qpti = dev_get_drvdata(&op->dev);
 
@@ -1459,7 +1459,7 @@ static struct platform_driver qpti_sbus_driver = {
 		.of_match_table = qpti_match,
 	},
 	.probe		= qpti_sbus_probe,
-	.remove		= __devexit_p(qpti_sbus_remove),
+	.remove		= qpti_sbus_remove,
 };
 
 static int __init qpti_init(void)

commit f7e8d9f830b118cfe757140d910834afd1710001
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Oct 28 13:26:37 2012 -0700

    qlogicpti: Fix build warning.
    
    The build warns:
    
    drivers/scsi/qlogicpti.c: In function 'qpti_sbus_probe':
    drivers/scsi/qlogicpti.c:1316:45: warning: passing argument 1 of 'scsi_host_alloc' discards 'const' qualifier from pointer target type [enabled by default]
    include/scsi/scsi_host.h:778:26: note: expected 'struct scsi_host_template *' but argument is of type 'const struct scsi_host_template *'
    
    The problem is that of_device_id->data is a const void pointer.
    
    This is pretty silly in this specific instance, because for all
    matched device IDs we set match->data to the same value,
    &qpti_template.
    
    So just use that directly instead of the unnecessary and improperly
    typed abstraction.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index b191dd549207..71fddbc60f18 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1294,26 +1294,19 @@ static struct scsi_host_template qpti_template = {
 static const struct of_device_id qpti_match[];
 static int __devinit qpti_sbus_probe(struct platform_device *op)
 {
-	const struct of_device_id *match;
-	struct scsi_host_template *tpnt;
 	struct device_node *dp = op->dev.of_node;
 	struct Scsi_Host *host;
 	struct qlogicpti *qpti;
 	static int nqptis;
 	const char *fcode;
 
-	match = of_match_device(qpti_match, &op->dev);
-	if (!match)
-		return -EINVAL;
-	tpnt = match->data;
-
 	/* Sometimes Antares cards come up not completely
 	 * setup, and we get a report of a zero IRQ.
 	 */
 	if (op->archdata.irqs[0] == 0)
 		return -ENODEV;
 
-	host = scsi_host_alloc(tpnt, sizeof(struct qlogicpti));
+	host = scsi_host_alloc(&qpti_template, sizeof(struct qlogicpti));
 	if (!host)
 		return -ENOMEM;
 
@@ -1445,19 +1438,15 @@ static int __devexit qpti_sbus_remove(struct platform_device *op)
 static const struct of_device_id qpti_match[] = {
 	{
 		.name = "ptisp",
-		.data = &qpti_template,
 	},
 	{
 		.name = "PTI,ptisp",
-		.data = &qpti_template,
 	},
 	{
 		.name = "QLGC,isp",
-		.data = &qpti_template,
 	},
 	{
 		.name = "SUNW,isp",
-		.data = &qpti_template,
 	},
 	{},
 };

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index e40dc1cb09a0..b191dd549207 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -35,7 +35,6 @@
 #include "qlogicpti.h"
 
 #include <asm/dma.h>
-#include <asm/system.h>
 #include <asm/ptrace.h>
 #include <asm/pgtable.h>
 #include <asm/oplib.h>

commit 528c04ee6dcdb4591aab94a003e77e41cd7d2d23
Author: Meelis Roos <mroos@linux.ee>
Date:   Fri Oct 7 18:05:08 2011 +0300

    [SCSI] qlogicpti: fix timeout
    
    qlogicpti times out for some tape library operations (like mtx
    inventory). It seems SCSI command timeout is hardcoded into the driver.
    Fix it by propagating the timeout from scsi request to the controller as
    suggested by James Bottomley.
    
    Tested on Sun Ultra 1 with Sun StorEdge L8 Autoloader.
    
    Signed-off-by: Meelis Roos <mroos@linux.ee>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 9689d41c7888..e40dc1cb09a0 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -880,7 +880,7 @@ static inline void cmd_frob(struct Command_Entry *cmd, struct scsi_cmnd *Cmnd,
 		cmd->control_flags |= CFLAG_WRITE;
 	else
 		cmd->control_flags |= CFLAG_READ;
-	cmd->time_out = 30;
+	cmd->time_out = Cmnd->request->timeout/HZ;
 	memcpy(cmd->cdb, Cmnd->cmnd, Cmnd->cmd_len);
 }
 

commit b1608d69cb804e414d0887140ba08a9398e4e638
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed May 18 11:19:24 2011 -0600

    drivercore: revert addition of of_match to struct device
    
    Commit b826291c, "drivercore/dt: add a match table pointer to struct
    device" added an of_match pointer to struct device to cache the
    of_match_table entry discovered at driver match time.  This was unsafe
    because matching is not an atomic operation with probing a driver.  If
    two or more drivers are attempted to be matched to a driver at the
    same time, then the cached matching entry pointer could get
    overwritten.
    
    This patch reverts the of_match cache pointer and reworks all users to
    call of_match_device() directly instead.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index e2d45c91b8e8..9689d41c7888 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1292,8 +1292,10 @@ static struct scsi_host_template qpti_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 
+static const struct of_device_id qpti_match[];
 static int __devinit qpti_sbus_probe(struct platform_device *op)
 {
+	const struct of_device_id *match;
 	struct scsi_host_template *tpnt;
 	struct device_node *dp = op->dev.of_node;
 	struct Scsi_Host *host;
@@ -1301,9 +1303,10 @@ static int __devinit qpti_sbus_probe(struct platform_device *op)
 	static int nqptis;
 	const char *fcode;
 
-	if (!op->dev.of_match)
+	match = of_match_device(qpti_match, &op->dev);
+	if (!match)
 		return -EINVAL;
-	tpnt = op->dev.of_match->data;
+	tpnt = match->data;
 
 	/* Sometimes Antares cards come up not completely
 	 * setup, and we get a report of a zero IRQ.

commit 4ebb24f707187196937607c60810d42f7112d7aa
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 20:01:33 2011 -0700

    dt/sparc: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of old users of of_platform_driver in arch/sparc.  Most
    of_platform_driver users can be converted to use the platform_bus
    directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 664c9572d0c9..e2d45c91b8e8 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1292,15 +1292,19 @@ static struct scsi_host_template qpti_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 
-static int __devinit qpti_sbus_probe(struct platform_device *op, const struct of_device_id *match)
+static int __devinit qpti_sbus_probe(struct platform_device *op)
 {
-	struct scsi_host_template *tpnt = match->data;
+	struct scsi_host_template *tpnt;
 	struct device_node *dp = op->dev.of_node;
 	struct Scsi_Host *host;
 	struct qlogicpti *qpti;
 	static int nqptis;
 	const char *fcode;
 
+	if (!op->dev.of_match)
+		return -EINVAL;
+	tpnt = op->dev.of_match->data;
+
 	/* Sometimes Antares cards come up not completely
 	 * setup, and we get a report of a zero IRQ.
 	 */
@@ -1457,7 +1461,7 @@ static const struct of_device_id qpti_match[] = {
 };
 MODULE_DEVICE_TABLE(of, qpti_match);
 
-static struct of_platform_driver qpti_sbus_driver = {
+static struct platform_driver qpti_sbus_driver = {
 	.driver = {
 		.name = "qpti",
 		.owner = THIS_MODULE,
@@ -1469,12 +1473,12 @@ static struct of_platform_driver qpti_sbus_driver = {
 
 static int __init qpti_init(void)
 {
-	return of_register_platform_driver(&qpti_sbus_driver);
+	return platform_driver_register(&qpti_sbus_driver);
 }
 
 static void __exit qpti_exit(void)
 {
-	of_unregister_platform_driver(&qpti_sbus_driver);
+	platform_driver_unregister(&qpti_sbus_driver);
 }
 
 MODULE_DESCRIPTION("QlogicISP SBUS driver");

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index f8c561cf751e..664c9572d0c9 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1003,7 +1003,7 @@ static int qlogicpti_slave_configure(struct scsi_device *sdev)
  *
  * "This code must fly." -davem
  */
-static int qlogicpti_queuecommand(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *))
+static int qlogicpti_queuecommand_lck(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = Cmnd->device->host;
 	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
@@ -1052,6 +1052,8 @@ static int qlogicpti_queuecommand(struct scsi_cmnd *Cmnd, void (*done)(struct sc
 	return 1;
 }
 
+static DEF_SCSI_QCMD(qlogicpti_queuecommand)
+
 static int qlogicpti_return_status(struct Status_Entry *sts, int id)
 {
 	int host_status = DID_ERROR;

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 53d7ed0dc169..f8c561cf751e 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -704,7 +704,7 @@ static void __devexit qpti_chain_del(struct qlogicpti *qpti)
 
 static int __devinit qpti_map_regs(struct qlogicpti *qpti)
 {
-	struct of_device *op = qpti->op;
+	struct platform_device *op = qpti->op;
 
 	qpti->qregs = of_ioremap(&op->resource[0], 0,
 				 resource_size(&op->resource[0]),
@@ -727,7 +727,7 @@ static int __devinit qpti_map_regs(struct qlogicpti *qpti)
 
 static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 {
-	struct of_device *op = qpti->op;
+	struct platform_device *op = qpti->op;
 
 	qpti->qhost->irq = qpti->irq = op->archdata.irqs[0];
 
@@ -752,7 +752,7 @@ static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 
 static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
 {
-	struct of_device *op = qpti->op;
+	struct platform_device *op = qpti->op;
 	struct device_node *dp;
 
 	dp = op->dev.of_node;
@@ -773,7 +773,7 @@ static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
 
 static void qpti_get_bursts(struct qlogicpti *qpti)
 {
-	struct of_device *op = qpti->op;
+	struct platform_device *op = qpti->op;
 	u8 bursts, bmask;
 
 	bursts = of_getintprop_default(op->dev.of_node, "burst-sizes", 0xff);
@@ -806,7 +806,7 @@ static void qpti_get_clock(struct qlogicpti *qpti)
  */
 static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 {
-	struct of_device *op = qpti->op;
+	struct platform_device *op = qpti->op;
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
 	qpti->res_cpu = dma_alloc_coherent(&op->dev,
@@ -1290,7 +1290,7 @@ static struct scsi_host_template qpti_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 
-static int __devinit qpti_sbus_probe(struct of_device *op, const struct of_device_id *match)
+static int __devinit qpti_sbus_probe(struct platform_device *op, const struct of_device_id *match)
 {
 	struct scsi_host_template *tpnt = match->data;
 	struct device_node *dp = op->dev.of_node;
@@ -1401,7 +1401,7 @@ static int __devinit qpti_sbus_probe(struct of_device *op, const struct of_devic
 	return -ENODEV;
 }
 
-static int __devexit qpti_sbus_remove(struct of_device *op)
+static int __devexit qpti_sbus_remove(struct platform_device *op)
 {
 	struct qlogicpti *qpti = dev_get_drvdata(&op->dev);
 

commit 1ab1d63a85cee2545272f63a7644e9f855cb65d0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jun 24 15:14:37 2010 -0600

    of/platform: remove all of_bus_type and of_platform_bus_type references
    
    Both of_bus_type and of_platform_bus_type are just #define aliases
    for the platform bus.  This patch removes all references to them and
    switches to the of_register_platform_driver()/of_unregister_platform_driver()
    API for registering.
    
    Subsequent patches will convert each user of of_register_platform_driver()
    into plain platform_drivers without the of_platform_driver shim.  At which
    point the of_register_platform_driver()/of_unregister_platform_driver()
    functions can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 3f5b5411e6bc..53d7ed0dc169 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1467,12 +1467,12 @@ static struct of_platform_driver qpti_sbus_driver = {
 
 static int __init qpti_init(void)
 {
-	return of_register_driver(&qpti_sbus_driver, &of_bus_type);
+	return of_register_platform_driver(&qpti_sbus_driver);
 }
 
 static void __exit qpti_exit(void)
 {
-	of_unregister_driver(&qpti_sbus_driver);
+	of_unregister_platform_driver(&qpti_sbus_driver);
 }
 
 MODULE_DESCRIPTION("QlogicISP SBUS driver");

commit 1636f8ac2b08410df4766449f7c86b912443cd99
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:58 2010 -0600

    sparc/of: Move of_device fields into struct pdev_archdata
    
    This patch moves SPARC architecture specific data members out of
    struct of_device and into the pdev_archdata structure.  The reason
    for this change is to unify the struct of_device definition amongst
    all the architectures.  It also remvoes the .sysdata, .slot, .portid
    and .clock_freq properties because they aren't actually used by
    anything.
    
    A subsequent patch will replace struct of_device entirely with struct
    platform_device and the of_platform support code will share common
    routines with the platform bus (but the bus instances themselves can
    remain separate).
    
    This patch also adds 'struct resources *resource' and num_resources
    to match the fields defined in struct platform_device.  After this
    change, 'struct platform_device' can be used as a drop-in replacement
    for 'struct of_platform'.
    
    This change is in preparation for merging the of_platform_bus_type
    with the platform_bus_type.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index ca5c15c779cf..3f5b5411e6bc 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -729,7 +729,7 @@ static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 {
 	struct of_device *op = qpti->op;
 
-	qpti->qhost->irq = qpti->irq = op->irqs[0];
+	qpti->qhost->irq = qpti->irq = op->archdata.irqs[0];
 
 	/* We used to try various overly-clever things to
 	 * reduce the interrupt processing overhead on
@@ -1302,7 +1302,7 @@ static int __devinit qpti_sbus_probe(struct of_device *op, const struct of_devic
 	/* Sometimes Antares cards come up not completely
 	 * setup, and we get a report of a zero IRQ.
 	 */
-	if (op->irqs[0] == 0)
+	if (op->archdata.irqs[0] == 0)
 		return -ENODEV;
 
 	host = scsi_host_alloc(tpnt, sizeof(struct qlogicpti));

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 35433d23b7ce..ca5c15c779cf 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1456,8 +1456,11 @@ static const struct of_device_id qpti_match[] = {
 MODULE_DEVICE_TABLE(of, qpti_match);
 
 static struct of_platform_driver qpti_sbus_driver = {
-	.name		= "qpti",
-	.match_table	= qpti_match,
+	.driver = {
+		.name = "qpti",
+		.owner = THIS_MODULE,
+		.of_match_table = qpti_match,
+	},
 	.probe		= qpti_sbus_probe,
 	.remove		= __devexit_p(qpti_sbus_remove),
 };

commit 61c7a080a5a061c976988fd4b844dfb468dda255
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:29 2010 -0700

    of: Always use 'struct device.of_node' to get device node pointer.
    
    The following structure elements duplicate the information in
    'struct device.of_node' and so are being eliminated.  This patch
    makes all readers of these elements use device.of_node instead.
    
    (struct of_device *)->node
    (struct dev_archdata *)->prom_node (sparc)
    (struct dev_archdata *)->of_node (powerpc & microblaze)
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index aa406497eebc..35433d23b7ce 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -755,7 +755,7 @@ static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
 	struct of_device *op = qpti->op;
 	struct device_node *dp;
 
-	dp = op->node;
+	dp = op->dev.of_node;
 
 	qpti->scsi_id = of_getintprop_default(dp, "initiator-id", -1);
 	if (qpti->scsi_id == -1)
@@ -776,8 +776,8 @@ static void qpti_get_bursts(struct qlogicpti *qpti)
 	struct of_device *op = qpti->op;
 	u8 bursts, bmask;
 
-	bursts = of_getintprop_default(op->node, "burst-sizes", 0xff);
-	bmask = of_getintprop_default(op->node->parent, "burst-sizes", 0xff);
+	bursts = of_getintprop_default(op->dev.of_node, "burst-sizes", 0xff);
+	bmask = of_getintprop_default(op->dev.of_node->parent, "burst-sizes", 0xff);
 	if (bmask != 0xff)
 		bursts &= bmask;
 	if (bursts == 0xff ||
@@ -1293,7 +1293,7 @@ static struct scsi_host_template qpti_template = {
 static int __devinit qpti_sbus_probe(struct of_device *op, const struct of_device_id *match)
 {
 	struct scsi_host_template *tpnt = match->data;
-	struct device_node *dp = op->node;
+	struct device_node *dp = op->dev.of_node;
 	struct Scsi_Host *host;
 	struct qlogicpti *qpti;
 	static int nqptis;
@@ -1315,7 +1315,7 @@ static int __devinit qpti_sbus_probe(struct of_device *op, const struct of_devic
 	qpti->qhost = host;
 	qpti->op = op;
 	qpti->qpti_id = nqptis;
-	strcpy(qpti->prom_name, op->node->name);
+	strcpy(qpti->prom_name, op->dev.of_node->name);
 	qpti->is_pti = strcmp(qpti->prom_name, "QLGC,isp");
 
 	if (qpti_map_regs(qpti) < 0)

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 1b8217076b0e..aa406497eebc 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -16,7 +16,7 @@
 #include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/string.h>
-#include <linux/slab.h>
+#include <linux/gfp.h>
 #include <linux/blkdev.h>
 #include <linux/proc_fs.h>
 #include <linux/stat.h>

commit 77d3926306bf4eecac50150ba5625797219f14ba
Author: Meelis Roos <mroos@linux.ee>
Date:   Mon Mar 8 10:53:08 2010 -0800

    qlogicpti: Remove slash in QlogicPTI irq name
    
    qlogicpti driver registers its irq with a name containing slash.
    This results in
    
    [   71.049735] WARNING: at fs/proc/generic.c:316 __xlate_proc_name+0xa8/0xb8()
    [   71.132815] name 'Qlogic/PTI'
    
    because proc_mkdir with the name of the irq fails. Fix it by just
    removing the slash from irq name. Discovered and tested on real hardware
    (Sun Ultra 1).
    
    Signed-off-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index fa34b92850a6..1b8217076b0e 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -738,7 +738,7 @@ static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 	 * sanely maintain.
 	 */
 	if (request_irq(qpti->irq, qpti_intr,
-			IRQF_SHARED, "Qlogic/PTI", qpti))
+			IRQF_SHARED, "QlogicPTI", qpti))
 		goto fail;
 
 	printk("qlogicpti%d: IRQ %d ", qpti->qpti_id, qpti->irq);

commit f894e74dc1983062d30d4e1b79bdb90b8a847f52
Author: Jaswinder Singh Rajput <jaswinder@kernel.org>
Date:   Fri Apr 3 01:42:50 2009 +0530

    [SCSI] qlogicpti: use request_firmware
    
    Firmware blob is little endian
    
    Thanks to Stephen Rothwell for fixing typos
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 69d6ad862b60..fa34b92850a6 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -28,6 +28,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/firmware.h>
 
 #include <asm/byteorder.h>
 
@@ -53,8 +54,6 @@
 
 #define DEFAULT_LOOP_COUNT	10000
 
-#include "qlogicpti_asm.c"
-
 static struct qlogicpti *qptichain = NULL;
 static DEFINE_SPINLOCK(qptichain_lock);
 
@@ -465,16 +464,32 @@ static int qlogicpti_reset_hardware(struct Scsi_Host *host)
 
 static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 {
+	const struct firmware *fw;
+	const char fwname[] = "qlogic/isp1000.bin";
+	const __le16 *fw_data;
 	struct Scsi_Host *host = qpti->qhost;
 	unsigned short csum = 0;
 	unsigned short param[6];
-	unsigned short *risc_code, risc_code_addr, risc_code_length;
+	unsigned short risc_code_addr, risc_code_length;
+	int err;
 	unsigned long flags;
 	int i, timeout;
 
-	risc_code = &sbus_risc_code01[0];
+	err = request_firmware(&fw, fwname, &qpti->op->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       fwname, err);
+		return err;
+	}
+	if (fw->size % 2) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, fwname);
+		err = -EINVAL;
+		goto outfirm;
+	}
+	fw_data = (const __le16 *)&fw->data[0];
 	risc_code_addr = 0x1000;	/* all f/w modules load at 0x1000 */
-	risc_code_length = sbus_risc_code_length01;
+	risc_code_length = fw->size / 2;
 
 	spin_lock_irqsave(host->host_lock, flags);
 
@@ -482,12 +497,12 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 	 * afterwards via the mailbox commands.
 	 */
 	for (i = 0; i < risc_code_length; i++)
-		csum += risc_code[i];
+		csum += __le16_to_cpu(fw_data[i]);
 	if (csum) {
-		spin_unlock_irqrestore(host->host_lock, flags);
 		printk(KERN_EMERG "qlogicpti%d: Aieee, firmware checksum failed!",
 		       qpti->qpti_id);
-		return 1;
+		err = 1;
+		goto out;
 	}		
 	sbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);
 	sbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);
@@ -496,9 +511,9 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 	while (--timeout && (sbus_readw(qpti->qregs + SBUS_CTRL) & SBUS_CTRL_RESET))
 		udelay(20);
 	if (!timeout) {
-		spin_unlock_irqrestore(host->host_lock, flags);
 		printk(KERN_EMERG "qlogicpti%d: Cannot reset the ISP.", qpti->qpti_id);
-		return 1;
+		err = 1;
+		goto out;
 	}
 
 	sbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);
@@ -536,21 +551,21 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 	if (qlogicpti_mbox_command(qpti, param, 1)) {
 		printk(KERN_EMERG "qlogicpti%d: Cannot stop firmware for reload.\n",
 		       qpti->qpti_id);
-		spin_unlock_irqrestore(host->host_lock, flags);
-		return 1;
+		err = 1;
+		goto out;
 	}		
 
 	/* Load it up.. */
 	for (i = 0; i < risc_code_length; i++) {
 		param[0] = MBOX_WRITE_RAM_WORD;
 		param[1] = risc_code_addr + i;
-		param[2] = risc_code[i];
+		param[2] = __le16_to_cpu(fw_data[i]);
 		if (qlogicpti_mbox_command(qpti, param, 1) ||
 		    param[0] != MBOX_COMMAND_COMPLETE) {
 			printk("qlogicpti%d: Firmware dload failed, I'm bolixed!\n",
 			       qpti->qpti_id);
-			spin_unlock_irqrestore(host->host_lock, flags);
-			return 1;
+			err = 1;
+			goto out;
 		}
 	}
 
@@ -569,8 +584,8 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 	    (param[0] != MBOX_COMMAND_COMPLETE)) {
 		printk(KERN_EMERG "qlogicpti%d: New firmware csum failure!\n",
 		       qpti->qpti_id);
-		spin_unlock_irqrestore(host->host_lock, flags);
-		return 1;
+		err = 1;
+		goto out;
 	}
 
 	/* Start using newly downloaded firmware. */
@@ -583,8 +598,8 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 	    (param[0] != MBOX_COMMAND_COMPLETE)) {
 		printk(KERN_EMERG "qlogicpti%d: AboutFirmware cmd fails.\n",
 		       qpti->qpti_id);
-		spin_unlock_irqrestore(host->host_lock, flags);
-		return 1;
+		err = 1;
+		goto out;
 	}
 
 	/* Snag the major and minor revisions from the result. */
@@ -599,8 +614,8 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 	    (param[0] != MBOX_COMMAND_COMPLETE)) {
 		printk(KERN_EMERG "qlogicpti%d: could not set clock rate.\n",
 		       qpti->qpti_id);
-		spin_unlock_irqrestore(host->host_lock, flags);
-		return 1;
+		err = 1;
+		goto out;
 	}
 
 	if (qpti->is_pti != 0) {
@@ -616,8 +631,11 @@ static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 		qlogicpti_mbox_command(qpti, param, 1);
 	}
 
+out:
 	spin_unlock_irqrestore(host->host_lock, flags);
-	return 0;
+outfirm:
+	release_firmware(fw);
+	return err;
 }
 
 static int qlogicpti_verify_tmon(struct qlogicpti *qpti)
@@ -1458,6 +1476,7 @@ MODULE_DESCRIPTION("QlogicISP SBUS driver");
 MODULE_AUTHOR("David S. Miller (davem@davemloft.net)");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("2.1");
+MODULE_FIRMWARE("qlogic/isp1000.bin");
 
 module_init(qpti_init);
 module_exit(qpti_exit);

commit 56c5d900dbb8e042bfad035d18433476931d8f93
Merge: 4dd95b63ae25 ead9d23d803e
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Oct 11 12:39:35 2008 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            sound/core/memalloc.c

commit 7e6cfb54b1ff4b64d74aa8cd191204c9598c073d
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Mon Sep 29 09:38:55 2008 +0200

    scsi: fix fall out of sg-chaining patch in qlogicpti
    
    Boaz writes:
    
    "I've reviewed all patches since Matthew's, and I find one small
    problem.
    
    In the load_cmd() there is a compound loop where the first 4 sg's are
    set then the rest are set into a memory structure in group of 7 sg's.
    
    Well the second 7-group and on is a bug because sg pointer does not advance.
    This is a fall out from Jens's patch."
    
    The reporter, Meelis Roos <mroos@ut.ee>, verified that this patch
    does indeed fix his problem with qlogicpti.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 4a1cf6377f6c..905350896725 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -914,6 +914,7 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 				ds[i].d_count = sg_dma_len(s);
 			}
 			sg_count -= n;
+			sg = s;
 		}
 	} else {
 		cmd->dataseg[0].d_base = 0;

commit fd098316ef533e8441576f020ead4beab93154ce
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 31 01:23:17 2008 -0700

    sparc: Annotate of_device_id arrays with const or __initdata.
    
    As suggested by Stephen Rothwell.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index b6ce82d3de3d..42807671512b 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1415,7 +1415,7 @@ static int __devexit qpti_sbus_remove(struct of_device *op)
 	return 0;
 }
 
-static struct of_device_id qpti_match[] = {
+static const struct of_device_id qpti_match[] = {
 	{
 		.name = "ptisp",
 		.data = &qpti_template,

commit 5dc2536bb8d8adb5fdfbe76cd6fdcdf9de3f40f8
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 00:24:00 2008 -0700

    qlogicpti: Convert to pure OF driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index e16c56c515f1..b6ce82d3de3d 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1,6 +1,6 @@
 /* qlogicpti.c: Performance Technologies QlogicISP sbus card driver.
  *
- * Copyright (C) 1996, 2006 David S. Miller (davem@davemloft.net)
+ * Copyright (C) 1996, 2006, 2008 David S. Miller (davem@davemloft.net)
  *
  * A lot of this driver was directly stolen from Erik H. Moe's PCI
  * Qlogic ISP driver.  Mucho kudos to him for this code.
@@ -26,12 +26,13 @@
 #include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include <asm/byteorder.h>
 
 #include "qlogicpti.h"
 
-#include <asm/sbus.h>
 #include <asm/dma.h>
 #include <asm/system.h>
 #include <asm/ptrace.h>
@@ -685,19 +686,19 @@ static void __devexit qpti_chain_del(struct qlogicpti *qpti)
 
 static int __devinit qpti_map_regs(struct qlogicpti *qpti)
 {
-	struct sbus_dev *sdev = qpti->sdev;
+	struct of_device *op = qpti->op;
 
-	qpti->qregs = sbus_ioremap(&sdev->resource[0], 0,
-				   sdev->reg_addrs[0].reg_size,
-				   "PTI Qlogic/ISP");
+	qpti->qregs = of_ioremap(&op->resource[0], 0,
+				 resource_size(&op->resource[0]),
+				 "PTI Qlogic/ISP");
 	if (!qpti->qregs) {
 		printk("PTI: Qlogic/ISP registers are unmappable\n");
 		return -1;
 	}
 	if (qpti->is_pti) {
-		qpti->sreg = sbus_ioremap(&sdev->resource[0], (16 * 4096),
-					  sizeof(unsigned char),
-					  "PTI Qlogic/ISP statreg");
+		qpti->sreg = of_ioremap(&op->resource[0], (16 * 4096),
+					sizeof(unsigned char),
+					"PTI Qlogic/ISP statreg");
 		if (!qpti->sreg) {
 			printk("PTI: Qlogic/ISP status register is unmappable\n");
 			return -1;
@@ -708,9 +709,9 @@ static int __devinit qpti_map_regs(struct qlogicpti *qpti)
 
 static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 {
-	struct sbus_dev *sdev = qpti->sdev;
+	struct of_device *op = qpti->op;
 
-	qpti->qhost->irq = qpti->irq = sdev->irqs[0];
+	qpti->qhost->irq = qpti->irq = op->irqs[0];
 
 	/* We used to try various overly-clever things to
 	 * reduce the interrupt processing overhead on
@@ -733,17 +734,19 @@ static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 
 static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
 {
-	qpti->scsi_id = prom_getintdefault(qpti->prom_node,
-					   "initiator-id",
-					   -1);
+	struct of_device *op = qpti->op;
+	struct device_node *dp;
+
+	dp = op->node;
+
+	qpti->scsi_id = of_getintprop_default(dp, "initiator-id", -1);
 	if (qpti->scsi_id == -1)
-		qpti->scsi_id = prom_getintdefault(qpti->prom_node,
-						   "scsi-initiator-id",
-						   -1);
+		qpti->scsi_id = of_getintprop_default(dp, "scsi-initiator-id",
+						      -1);
 	if (qpti->scsi_id == -1)
 		qpti->scsi_id =
-			prom_getintdefault(qpti->sdev->bus->prom_node,
-					   "scsi-initiator-id", 7);
+			of_getintprop_default(dp->parent,
+					      "scsi-initiator-id", 7);
 	qpti->qhost->this_id = qpti->scsi_id;
 	qpti->qhost->max_sectors = 64;
 
@@ -752,12 +755,11 @@ static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
 
 static void qpti_get_bursts(struct qlogicpti *qpti)
 {
-	struct sbus_dev *sdev = qpti->sdev;
+	struct of_device *op = qpti->op;
 	u8 bursts, bmask;
 
-	bursts = prom_getintdefault(qpti->prom_node, "burst-sizes", 0xff);
-	bmask = prom_getintdefault(sdev->bus->prom_node,
-				   "burst-sizes", 0xff);
+	bursts = of_getintprop_default(op->node, "burst-sizes", 0xff);
+	bmask = of_getintprop_default(op->node->parent, "burst-sizes", 0xff);
 	if (bmask != 0xff)
 		bursts &= bmask;
 	if (bursts == 0xff ||
@@ -786,10 +788,10 @@ static void qpti_get_clock(struct qlogicpti *qpti)
  */
 static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 {
-	struct sbus_dev *sdev = qpti->sdev;
+	struct of_device *op = qpti->op;
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	qpti->res_cpu = dma_alloc_coherent(&sdev->ofdev.dev,
+	qpti->res_cpu = dma_alloc_coherent(&op->dev,
 					   QSIZE(RES_QUEUE_LEN),
 					   &qpti->res_dvma, GFP_ATOMIC);
 	if (qpti->res_cpu == NULL ||
@@ -798,12 +800,12 @@ static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 		return -1;
 	}
 
-	qpti->req_cpu = dma_alloc_coherent(&sdev->ofdev.dev,
+	qpti->req_cpu = dma_alloc_coherent(&op->dev,
 					   QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
 					   &qpti->req_dvma, GFP_ATOMIC);
 	if (qpti->req_cpu == NULL ||
 	    qpti->req_dvma == 0) {
-		dma_free_coherent(&sdev->ofdev.dev, QSIZE(RES_QUEUE_LEN),
+		dma_free_coherent(&op->dev, QSIZE(RES_QUEUE_LEN),
 				  qpti->res_cpu, qpti->res_dvma);
 		printk("QPTI: Cannot map request queue.\n");
 		return -1;
@@ -876,7 +878,7 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 		int sg_count;
 
 		sg = scsi_sglist(Cmnd);
-		sg_count = dma_map_sg(&qpti->sdev->ofdev.dev, sg,
+		sg_count = dma_map_sg(&qpti->op->dev, sg,
 				      scsi_sg_count(Cmnd),
 				      Cmnd->sc_data_direction);
 
@@ -1153,7 +1155,7 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 			Cmnd->result = DID_ERROR << 16;
 
 		if (scsi_bufflen(Cmnd))
-			dma_unmap_sg(&qpti->sdev->ofdev.dev,
+			dma_unmap_sg(&qpti->op->dev,
 				     scsi_sglist(Cmnd), scsi_sg_count(Cmnd),
 				     Cmnd->sc_data_direction);
 
@@ -1269,34 +1271,32 @@ static struct scsi_host_template qpti_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 
-static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_device_id *match)
+static int __devinit qpti_sbus_probe(struct of_device *op, const struct of_device_id *match)
 {
-	static int nqptis;
-	struct sbus_dev *sdev = to_sbus_device(&dev->dev);
-	struct device_node *dp = dev->node;
 	struct scsi_host_template *tpnt = match->data;
+	struct device_node *dp = op->node;
 	struct Scsi_Host *host;
 	struct qlogicpti *qpti;
+	static int nqptis;
 	const char *fcode;
 
 	/* Sometimes Antares cards come up not completely
 	 * setup, and we get a report of a zero IRQ.
 	 */
-	if (sdev->irqs[0] == 0)
+	if (op->irqs[0] == 0)
 		return -ENODEV;
 
 	host = scsi_host_alloc(tpnt, sizeof(struct qlogicpti));
 	if (!host)
 		return -ENOMEM;
 
-	qpti = (struct qlogicpti *) host->hostdata;
+	qpti = shost_priv(host);
 
 	host->max_id = MAX_TARGETS;
 	qpti->qhost = host;
-	qpti->sdev = sdev;
+	qpti->op = op;
 	qpti->qpti_id = nqptis;
-	qpti->prom_node = sdev->prom_node;
-	strcpy(qpti->prom_name, sdev->ofdev.node->name);
+	strcpy(qpti->prom_name, op->node->name);
 	qpti->is_pti = strcmp(qpti->prom_name, "QLGC,isp");
 
 	if (qpti_map_regs(qpti) < 0)
@@ -1342,12 +1342,12 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 		(qpti->ultra ? "Ultra" : "Fast"),
 		(qpti->differential ? "differential" : "single ended"));
 
-	if (scsi_add_host(host, &dev->dev)) {
+	if (scsi_add_host(host, &op->dev)) {
 		printk("qlogicpti%d: Failed scsi_add_host\n", qpti->qpti_id);
 		goto fail_unmap_queues;
 	}
 
-	dev_set_drvdata(&sdev->ofdev.dev, qpti);
+	dev_set_drvdata(&op->dev, qpti);
 
 	qpti_chain_add(qpti);
 
@@ -1358,19 +1358,20 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 
 fail_unmap_queues:
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	dma_free_coherent(&qpti->sdev->ofdev.dev,
+	dma_free_coherent(&op->dev,
 			  QSIZE(RES_QUEUE_LEN),
 			  qpti->res_cpu, qpti->res_dvma);
-	dma_free_coherent(&qpti->sdev->ofdev.dev,
+	dma_free_coherent(&op->dev,
 			  QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
 			  qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE
 
 fail_unmap_regs:
-	sbus_iounmap(qpti->qregs,
-		     qpti->sdev->reg_addrs[0].reg_size);
+	of_iounmap(&op->resource[0], qpti->qregs,
+		   resource_size(&op->resource[0]));
 	if (qpti->is_pti)
-		sbus_iounmap(qpti->sreg, sizeof(unsigned char));
+		of_iounmap(&op->resource[0], qpti->sreg,
+			   sizeof(unsigned char));
 
 fail_free_irq:
 	free_irq(qpti->irq, qpti);
@@ -1381,9 +1382,9 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 	return -ENODEV;
 }
 
-static int __devexit qpti_sbus_remove(struct of_device *dev)
+static int __devexit qpti_sbus_remove(struct of_device *op)
 {
-	struct qlogicpti *qpti = dev_get_drvdata(&dev->dev);
+	struct qlogicpti *qpti = dev_get_drvdata(&op->dev);
 
 	qpti_chain_del(qpti);
 
@@ -1396,17 +1397,18 @@ static int __devexit qpti_sbus_remove(struct of_device *dev)
 	free_irq(qpti->irq, qpti);
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	dma_free_coherent(&qpti->sdev->ofdev.dev,
+	dma_free_coherent(&op->dev,
 			  QSIZE(RES_QUEUE_LEN),
 			  qpti->res_cpu, qpti->res_dvma);
-	dma_free_coherent(&qpti->sdev->ofdev.dev,
+	dma_free_coherent(&op->dev,
 			  QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
 			  qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE
 
-	sbus_iounmap(qpti->qregs, qpti->sdev->reg_addrs[0].reg_size);
+	of_iounmap(&op->resource[0], qpti->qregs,
+		   resource_size(&op->resource[0]));
 	if (qpti->is_pti)
-		sbus_iounmap(qpti->sreg, sizeof(unsigned char));
+		of_iounmap(&op->resource[0], qpti->sreg, sizeof(unsigned char));
 
 	scsi_host_put(qpti->qhost);
 
@@ -1443,7 +1445,7 @@ static struct of_platform_driver qpti_sbus_driver = {
 
 static int __init qpti_init(void)
 {
-	return of_register_driver(&qpti_sbus_driver, &sbus_bus_type);
+	return of_register_driver(&qpti_sbus_driver, &of_bus_type);
 }
 
 static void __exit qpti_exit(void)
@@ -1454,7 +1456,7 @@ static void __exit qpti_exit(void)
 MODULE_DESCRIPTION("QlogicISP SBUS driver");
 MODULE_AUTHOR("David S. Miller (davem@davemloft.net)");
 MODULE_LICENSE("GPL");
-MODULE_VERSION("2.0");
+MODULE_VERSION("2.1");
 
 module_init(qpti_init);
 module_exit(qpti_exit);

commit 63237eeb5ac92d618a0a6055f4b1f65c5d14682b
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 26 23:33:42 2008 -0700

    sparc: Move SBUS DMA attribute interfaces out of asm/sbus.h
    
    This is in preparation for the subsequent asm/sbus.h removal.
    
    Also, make these routines take a "struct device" or no
    arguments, as appropriate.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 1559d455b2b7..e16c56c515f1 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -158,7 +158,7 @@ static inline void set_sbus_cfg1(struct qlogicpti *qpti)
 	 * is a nop and the chip ends up using the smallest burst
 	 * size. -DaveM
 	 */
-	if (sbus_can_burst64(qpti->sdev) && (bursts & DMA_BURST64)) {
+	if (sbus_can_burst64() && (bursts & DMA_BURST64)) {
 		val = (SBUS_CFG1_BENAB | SBUS_CFG1_B64);
 	} else
 #endif

commit 738f2b7b813913e651f39387d007dd961755dee2
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 18:09:11 2008 -0700

    sparc: Convert all SBUS drivers to dma_*() interfaces.
    
    And all the SBUS dma interfaces are deleted.
    
    A private implementation remains inside of the 32-bit sparc port which
    exists only for the sake of the implementation of dma_*().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index f010506af884..1559d455b2b7 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -25,6 +25,7 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/jiffies.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/byteorder.h>
 
@@ -788,22 +789,22 @@ static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 	struct sbus_dev *sdev = qpti->sdev;
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	qpti->res_cpu = sbus_alloc_consistent(&sdev->ofdev.dev,
-					      QSIZE(RES_QUEUE_LEN),
-					      &qpti->res_dvma);
+	qpti->res_cpu = dma_alloc_coherent(&sdev->ofdev.dev,
+					   QSIZE(RES_QUEUE_LEN),
+					   &qpti->res_dvma, GFP_ATOMIC);
 	if (qpti->res_cpu == NULL ||
 	    qpti->res_dvma == 0) {
 		printk("QPTI: Cannot map response queue.\n");
 		return -1;
 	}
 
-	qpti->req_cpu = sbus_alloc_consistent(&sdev->ofdev.dev,
-					      QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
-					      &qpti->req_dvma);
+	qpti->req_cpu = dma_alloc_coherent(&sdev->ofdev.dev,
+					   QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+					   &qpti->req_dvma, GFP_ATOMIC);
 	if (qpti->req_cpu == NULL ||
 	    qpti->req_dvma == 0) {
-		sbus_free_consistent(&sdev->ofdev.dev, QSIZE(RES_QUEUE_LEN),
-				     qpti->res_cpu, qpti->res_dvma);
+		dma_free_coherent(&sdev->ofdev.dev, QSIZE(RES_QUEUE_LEN),
+				  qpti->res_cpu, qpti->res_dvma);
 		printk("QPTI: Cannot map request queue.\n");
 		return -1;
 	}
@@ -875,9 +876,9 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 		int sg_count;
 
 		sg = scsi_sglist(Cmnd);
-		sg_count = sbus_map_sg(&qpti->sdev->ofdev.dev, sg,
-				       scsi_sg_count(Cmnd),
-				       Cmnd->sc_data_direction);
+		sg_count = dma_map_sg(&qpti->sdev->ofdev.dev, sg,
+				      scsi_sg_count(Cmnd),
+				      Cmnd->sc_data_direction);
 
 		ds = cmd->dataseg;
 		cmd->segment_cnt = sg_count;
@@ -1152,9 +1153,9 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 			Cmnd->result = DID_ERROR << 16;
 
 		if (scsi_bufflen(Cmnd))
-			sbus_unmap_sg(&qpti->sdev->ofdev.dev,
-				      scsi_sglist(Cmnd), scsi_sg_count(Cmnd),
-				      Cmnd->sc_data_direction);
+			dma_unmap_sg(&qpti->sdev->ofdev.dev,
+				     scsi_sglist(Cmnd), scsi_sg_count(Cmnd),
+				     Cmnd->sc_data_direction);
 
 		qpti->cmd_count[Cmnd->device->id]--;
 		sbus_writew(out_ptr, qpti->qregs + MBOX5);
@@ -1357,12 +1358,12 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 
 fail_unmap_queues:
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	sbus_free_consistent(&qpti->sdev->ofdev.dev,
-			     QSIZE(RES_QUEUE_LEN),
-			     qpti->res_cpu, qpti->res_dvma);
-	sbus_free_consistent(&qpti->sdev->ofdev.dev,
-			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
-			     qpti->req_cpu, qpti->req_dvma);
+	dma_free_coherent(&qpti->sdev->ofdev.dev,
+			  QSIZE(RES_QUEUE_LEN),
+			  qpti->res_cpu, qpti->res_dvma);
+	dma_free_coherent(&qpti->sdev->ofdev.dev,
+			  QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+			  qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE
 
 fail_unmap_regs:
@@ -1395,12 +1396,12 @@ static int __devexit qpti_sbus_remove(struct of_device *dev)
 	free_irq(qpti->irq, qpti);
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	sbus_free_consistent(&qpti->sdev->ofdev.dev,
-			     QSIZE(RES_QUEUE_LEN),
-			     qpti->res_cpu, qpti->res_dvma);
-	sbus_free_consistent(&qpti->sdev->ofdev.dev,
-			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
-			     qpti->req_cpu, qpti->req_dvma);
+	dma_free_coherent(&qpti->sdev->ofdev.dev,
+			  QSIZE(RES_QUEUE_LEN),
+			  qpti->res_cpu, qpti->res_dvma);
+	dma_free_coherent(&qpti->sdev->ofdev.dev,
+			  QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+			  qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE
 
 	sbus_iounmap(qpti->qregs, qpti->sdev->reg_addrs[0].reg_size);

commit 7a715f46012f3552294154978aed59cba9804928
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 18:37:58 2008 -0700

    sparc: Make SBUS DMA interfaces take struct device.
    
    This is the first step in converting all the SBUS drivers
    over to generic dma_*().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 4a1cf6377f6c..f010506af884 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -788,7 +788,7 @@ static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 	struct sbus_dev *sdev = qpti->sdev;
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	qpti->res_cpu = sbus_alloc_consistent(sdev,
+	qpti->res_cpu = sbus_alloc_consistent(&sdev->ofdev.dev,
 					      QSIZE(RES_QUEUE_LEN),
 					      &qpti->res_dvma);
 	if (qpti->res_cpu == NULL ||
@@ -797,12 +797,12 @@ static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 		return -1;
 	}
 
-	qpti->req_cpu = sbus_alloc_consistent(sdev,
+	qpti->req_cpu = sbus_alloc_consistent(&sdev->ofdev.dev,
 					      QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
 					      &qpti->req_dvma);
 	if (qpti->req_cpu == NULL ||
 	    qpti->req_dvma == 0) {
-		sbus_free_consistent(sdev, QSIZE(RES_QUEUE_LEN),
+		sbus_free_consistent(&sdev->ofdev.dev, QSIZE(RES_QUEUE_LEN),
 				     qpti->res_cpu, qpti->res_dvma);
 		printk("QPTI: Cannot map request queue.\n");
 		return -1;
@@ -875,8 +875,9 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 		int sg_count;
 
 		sg = scsi_sglist(Cmnd);
-		sg_count = sbus_map_sg(qpti->sdev, sg, scsi_sg_count(Cmnd),
-		                                      Cmnd->sc_data_direction);
+		sg_count = sbus_map_sg(&qpti->sdev->ofdev.dev, sg,
+				       scsi_sg_count(Cmnd),
+				       Cmnd->sc_data_direction);
 
 		ds = cmd->dataseg;
 		cmd->segment_cnt = sg_count;
@@ -1151,7 +1152,7 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 			Cmnd->result = DID_ERROR << 16;
 
 		if (scsi_bufflen(Cmnd))
-			sbus_unmap_sg(qpti->sdev,
+			sbus_unmap_sg(&qpti->sdev->ofdev.dev,
 				      scsi_sglist(Cmnd), scsi_sg_count(Cmnd),
 				      Cmnd->sc_data_direction);
 
@@ -1356,10 +1357,10 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 
 fail_unmap_queues:
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	sbus_free_consistent(qpti->sdev,
+	sbus_free_consistent(&qpti->sdev->ofdev.dev,
 			     QSIZE(RES_QUEUE_LEN),
 			     qpti->res_cpu, qpti->res_dvma);
-	sbus_free_consistent(qpti->sdev,
+	sbus_free_consistent(&qpti->sdev->ofdev.dev,
 			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
 			     qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE
@@ -1394,10 +1395,10 @@ static int __devexit qpti_sbus_remove(struct of_device *dev)
 	free_irq(qpti->irq, qpti);
 
 #define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	sbus_free_consistent(qpti->sdev,
+	sbus_free_consistent(&qpti->sdev->ofdev.dev,
 			     QSIZE(RES_QUEUE_LEN),
 			     qpti->res_cpu, qpti->res_dvma);
-	sbus_free_consistent(qpti->sdev,
+	sbus_free_consistent(&qpti->sdev->ofdev.dev,
 			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
 			     qpti->req_cpu, qpti->req_dvma);
 #undef QSIZE

commit cfb37ae1e9d31fe2c1d21734ab51405e0c3afb7e
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jan 30 22:03:36 2008 +0200

    [SCSI] qlogicpt: section fixes
    
    In current mainline, __devinit qpti_sbus_probe() still is calling __init
    qpti_chain_add().  Change occurrences of __init to __devinit to fix.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 65455ab1f3b9..4a1cf6377f6c 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -651,7 +651,7 @@ static int qlogicpti_verify_tmon(struct qlogicpti *qpti)
 
 static irqreturn_t qpti_intr(int irq, void *dev_id);
 
-static void __init qpti_chain_add(struct qlogicpti *qpti)
+static void __devinit qpti_chain_add(struct qlogicpti *qpti)
 {
 	spin_lock_irq(&qptichain_lock);
 	if (qptichain != NULL) {
@@ -667,7 +667,7 @@ static void __init qpti_chain_add(struct qlogicpti *qpti)
 	spin_unlock_irq(&qptichain_lock);
 }
 
-static void __init qpti_chain_del(struct qlogicpti *qpti)
+static void __devexit qpti_chain_del(struct qlogicpti *qpti)
 {
 	spin_lock_irq(&qptichain_lock);
 	if (qptichain == qpti) {
@@ -682,7 +682,7 @@ static void __init qpti_chain_del(struct qlogicpti *qpti)
 	spin_unlock_irq(&qptichain_lock);
 }
 
-static int __init qpti_map_regs(struct qlogicpti *qpti)
+static int __devinit qpti_map_regs(struct qlogicpti *qpti)
 {
 	struct sbus_dev *sdev = qpti->sdev;
 
@@ -705,7 +705,7 @@ static int __init qpti_map_regs(struct qlogicpti *qpti)
 	return 0;
 }
 
-static int __init qpti_register_irq(struct qlogicpti *qpti)
+static int __devinit qpti_register_irq(struct qlogicpti *qpti)
 {
 	struct sbus_dev *sdev = qpti->sdev;
 
@@ -730,7 +730,7 @@ static int __init qpti_register_irq(struct qlogicpti *qpti)
 	return -1;
 }
 
-static void __init qpti_get_scsi_id(struct qlogicpti *qpti)
+static void __devinit qpti_get_scsi_id(struct qlogicpti *qpti)
 {
 	qpti->scsi_id = prom_getintdefault(qpti->prom_node,
 					   "initiator-id",
@@ -783,7 +783,7 @@ static void qpti_get_clock(struct qlogicpti *qpti)
 /* The request and response queues must each be aligned
  * on a page boundary.
  */
-static int __init qpti_map_queues(struct qlogicpti *qpti)
+static int __devinit qpti_map_queues(struct qlogicpti *qpti)
 {
 	struct sbus_dev *sdev = qpti->sdev;
 

commit b80ca4f7ee36c26d300c5a8f429e73372d153379
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jan 13 15:46:13 2008 +0900

    [SCSI] replace sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE
    
    This replaces sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE in
    several LLDs. It's a preparation for the future changes to remove
    sense_buffer array in scsi_cmnd structure.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 5bc883182b97..65455ab1f3b9 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1142,7 +1142,7 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 
 		if (sts->state_flags & SF_GOT_SENSE)
 			memcpy(Cmnd->sense_buffer, sts->req_sense_data,
-			       sizeof(Cmnd->sense_buffer));
+			       SCSI_SENSE_BUFFERSIZE);
 
 		if (sts->hdr.entry_type == ENTRY_STATUS)
 			Cmnd->result =

commit dfb104ff5d8215e09892aad3cd094ad6597b1cfe
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Sun Sep 9 21:21:35 2007 +0300

    [SCSI] qlogicpti: convert to accessors and !use_sg cleanup
    
     - convert to accessors and !use_sg cleanup
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 7a2e7986b038..5bc883182b97 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -871,11 +871,12 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 	struct scatterlist *sg, *s;
 	int i, n;
 
-	if (Cmnd->use_sg) {
+	if (scsi_bufflen(Cmnd)) {
 		int sg_count;
 
-		sg = (struct scatterlist *) Cmnd->request_buffer;
-		sg_count = sbus_map_sg(qpti->sdev, sg, Cmnd->use_sg, Cmnd->sc_data_direction);
+		sg = scsi_sglist(Cmnd);
+		sg_count = sbus_map_sg(qpti->sdev, sg, scsi_sg_count(Cmnd),
+		                                      Cmnd->sc_data_direction);
 
 		ds = cmd->dataseg;
 		cmd->segment_cnt = sg_count;
@@ -914,16 +915,6 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 			}
 			sg_count -= n;
 		}
-	} else if (Cmnd->request_bufflen) {
-		Cmnd->SCp.ptr = (char *)(unsigned long)
-			sbus_map_single(qpti->sdev,
-					Cmnd->request_buffer,
-					Cmnd->request_bufflen,
-					Cmnd->sc_data_direction);
-
-		cmd->dataseg[0].d_base = (u32) ((unsigned long)Cmnd->SCp.ptr);
-		cmd->dataseg[0].d_count = Cmnd->request_bufflen;
-		cmd->segment_cnt = 1;
 	} else {
 		cmd->dataseg[0].d_base = 0;
 		cmd->dataseg[0].d_count = 0;
@@ -1159,17 +1150,11 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 		else
 			Cmnd->result = DID_ERROR << 16;
 
-		if (Cmnd->use_sg) {
+		if (scsi_bufflen(Cmnd))
 			sbus_unmap_sg(qpti->sdev,
-				      (struct scatterlist *)Cmnd->request_buffer,
-				      Cmnd->use_sg,
+				      scsi_sglist(Cmnd), scsi_sg_count(Cmnd),
 				      Cmnd->sc_data_direction);
-		} else if (Cmnd->request_bufflen) {
-			sbus_unmap_single(qpti->sdev,
-					  (__u32)((unsigned long)Cmnd->SCp.ptr),
-					  Cmnd->request_bufflen,
-					  Cmnd->sc_data_direction);
-		}
+
 		qpti->cmd_count[Cmnd->device->id]--;
 		sbus_writew(out_ptr, qpti->qregs + MBOX5);
 		Cmnd->host_scribble = (unsigned char *) done_queue;

commit 2f08fe5221b79aa1e240aa3938e9de6ab0baf1d3
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed May 9 13:43:12 2007 +0200

    qlogicpti: sg chaining support
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index e93f80316a19..7a2e7986b038 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -868,7 +868,7 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 			   struct qlogicpti *qpti, u_int in_ptr, u_int out_ptr)
 {
 	struct dataseg *ds;
-	struct scatterlist *sg;
+	struct scatterlist *sg, *s;
 	int i, n;
 
 	if (Cmnd->use_sg) {
@@ -884,11 +884,12 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 		n = sg_count;
 		if (n > 4)
 			n = 4;
-		for (i = 0; i < n; i++, sg++) {
-			ds[i].d_base = sg_dma_address(sg);
-			ds[i].d_count = sg_dma_len(sg);
+		for_each_sg(sg, s, n, i) {
+			ds[i].d_base = sg_dma_address(s);
+			ds[i].d_count = sg_dma_len(s);
 		}
 		sg_count -= 4;
+		sg = s;
 		while (sg_count > 0) {
 			struct Continuation_Entry *cont;
 
@@ -907,9 +908,9 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 			n = sg_count;
 			if (n > 7)
 				n = 7;
-			for (i = 0; i < n; i++, sg++) {
-				ds[i].d_base = sg_dma_address(sg);
-				ds[i].d_count = sg_dma_len(sg);
+			for_each_sg(sg, s, n, i) {
+				ds[i].d_base = sg_dma_address(s);
+				ds[i].d_count = sg_dma_len(s);
 			}
 			sg_count -= n;
 		}

commit 9ec76fbf7d6da3e98070a7059699d0ca019b0c9b
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Oct 1 08:07:52 2007 -0600

    [SCSI] qlogicpti: Add a slave_configure method
    
    By configuring targets in slave_configure, we can eliminate a shadow
    queuecommand, a shadow scsi_done, a write to the host template, abuse of
    SCp->Message and SCp->Status, a use of kmap_atomic() and sniffing the
    results of INQUIRY.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 594887205b0f..e93f80316a19 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -310,8 +310,6 @@ static inline void qlogicpti_set_hostdev_defaults(struct qlogicpti *qpti)
 		}
 		qpti->dev_param[i].device_enable = 1;
 	}
-	/* this is very important to set! */
-	qpti->sbits = 1 << qpti->scsi_id;
 }
 
 static int qlogicpti_reset_hardware(struct Scsi_Host *host)
@@ -951,153 +949,35 @@ static inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int
 	host->sg_tablesize = QLOGICPTI_MAX_SG(num_free);
 }
 
-static unsigned int scsi_rbuf_get(struct scsi_cmnd *cmd, unsigned char **buf_out)
+static int qlogicpti_slave_configure(struct scsi_device *sdev)
 {
-	unsigned char *buf;
-	unsigned int buflen;
-
-	if (cmd->use_sg) {
-		struct scatterlist *sg;
+	struct qlogicpti *qpti = shost_priv(sdev->host);
+	int tgt = sdev->id;
+	u_short param[6];
 
-		sg = (struct scatterlist *) cmd->request_buffer;
-		buf = kmap_atomic(sg->page, KM_IRQ0) + sg->offset;
-		buflen = sg->length;
+	/* tags handled in midlayer */
+	/* enable sync mode? */
+	if (sdev->sdtr) {
+		qpti->dev_param[tgt].device_flags |= 0x10;
 	} else {
-		buf = cmd->request_buffer;
-		buflen = cmd->request_bufflen;
+		qpti->dev_param[tgt].synchronous_offset = 0;
+		qpti->dev_param[tgt].synchronous_period = 0;
 	}
-
-	*buf_out = buf;
-	return buflen;
-}
-
-static void scsi_rbuf_put(struct scsi_cmnd *cmd, unsigned char *buf)
-{
-	if (cmd->use_sg) {
-		struct scatterlist *sg;
-
-		sg = (struct scatterlist *) cmd->request_buffer;
-		kunmap_atomic(buf - sg->offset, KM_IRQ0);
-	}
-}
-
-/*
- * Until we scan the entire bus with inquiries, go throught this fella...
- */
-static void ourdone(struct scsi_cmnd *Cmnd)
-{
-	struct qlogicpti *qpti = (struct qlogicpti *) Cmnd->device->host->hostdata;
-	int tgt = Cmnd->device->id;
-	void (*done) (struct scsi_cmnd *);
-
-	/* This grot added by DaveM, blame him for ugliness.
-	 * The issue is that in the 2.3.x driver we use the
-	 * host_scribble portion of the scsi command as a
-	 * completion linked list at interrupt service time,
-	 * so we have to store the done function pointer elsewhere.
-	 */
-	done = (void (*)(struct scsi_cmnd *))
-		(((unsigned long) Cmnd->SCp.Message)
-#ifdef __sparc_v9__
-		 | ((unsigned long) Cmnd->SCp.Status << 32UL)
-#endif
-		 );
-
-	if ((qpti->sbits & (1 << tgt)) == 0) {
-		int ok = host_byte(Cmnd->result) == DID_OK;
-		if (Cmnd->cmnd[0] == 0x12 && ok) {
-			unsigned char *iqd;
-			unsigned int iqd_len;
-
-			iqd_len = scsi_rbuf_get(Cmnd, &iqd);
-
-			/* tags handled in midlayer */
-			/* enable sync mode? */
-			if (iqd[7] & 0x10) {
-				qpti->dev_param[tgt].device_flags |= 0x10;
-			} else {
-				qpti->dev_param[tgt].synchronous_offset = 0;
-				qpti->dev_param[tgt].synchronous_period = 0;
-			}
-			/* are we wide capable? */
-			if (iqd[7] & 0x20) {
-				qpti->dev_param[tgt].device_flags |= 0x20;
-			}
-
-			scsi_rbuf_put(Cmnd, iqd);
-
-			qpti->sbits |= (1 << tgt);
-		} else if (!ok) {
-			qpti->sbits |= (1 << tgt);
-		}
-	}
-	done(Cmnd);
-}
-
-static int qlogicpti_queuecommand(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *));
-
-static int qlogicpti_queuecommand_slow(struct scsi_cmnd *Cmnd,
-				       void (*done)(struct scsi_cmnd *))
-{
-	struct qlogicpti *qpti = (struct qlogicpti *) Cmnd->device->host->hostdata;
-
-	/*
-	 * done checking this host adapter?
-	 * If not, then rewrite the command
-	 * to finish through ourdone so we
-	 * can peek at Inquiry data results.
-	 */
-	if (qpti->sbits && qpti->sbits != 0xffff) {
-		/* See above about in ourdone this ugliness... */
-		Cmnd->SCp.Message = ((unsigned long)done) & 0xffffffff;
-#ifdef CONFIG_SPARC64
-		Cmnd->SCp.Status = ((unsigned long)done >> 32UL) & 0xffffffff;
-#endif
-		return qlogicpti_queuecommand(Cmnd, ourdone);
-	}
-
-	/*
-	 * We've peeked at all targets for this bus- time
-	 * to set parameters for devices for real now.
-	 */
-	if (qpti->sbits == 0xffff) {
-		int i;
-		for(i = 0; i < MAX_TARGETS; i++) {
-			u_short param[6];
-			param[0] = MBOX_SET_TARGET_PARAMS;
-			param[1] = (i << 8);
-			param[2] = (qpti->dev_param[i].device_flags << 8);
-			if (qpti->dev_param[i].device_flags & 0x10) {
-				param[3] = (qpti->dev_param[i].synchronous_offset << 8) |
-					qpti->dev_param[i].synchronous_period;
-			} else {
-				param[3] = 0;
-			}
-			(void) qlogicpti_mbox_command(qpti, param, 0);
-		}
-		/*
-		 * set to zero so any traverse through ourdone
-		 * doesn't start the whole process again,
-		 */
-		qpti->sbits = 0;
-	}
-
-	/* check to see if we're done with all adapters... */
-	for (qpti = qptichain; qpti != NULL; qpti = qpti->next) {
-		if (qpti->sbits) {
-			break;
-		}
+	/* are we wide capable? */
+	if (sdev->wdtr)
+		qpti->dev_param[tgt].device_flags |= 0x20;
+
+	param[0] = MBOX_SET_TARGET_PARAMS;
+	param[1] = (tgt << 8);
+	param[2] = (qpti->dev_param[tgt].device_flags << 8);
+	if (qpti->dev_param[tgt].device_flags & 0x10) {
+		param[3] = (qpti->dev_param[tgt].synchronous_offset << 8) |
+			qpti->dev_param[tgt].synchronous_period;
+	} else {
+		param[3] = 0;
 	}
-
-	/*
-	 * if we hit the end of the chain w/o finding adapters still
-	 * capability-configuring, then we're done with all adapters
-	 * and can rock on..
-	 */
-	if (qpti == NULL)
-		Cmnd->device->host->hostt->queuecommand = qlogicpti_queuecommand;
-
-	return qlogicpti_queuecommand(Cmnd, done);
+	qlogicpti_mbox_command(qpti, param, 0);
+	return 0;
 }
 
 /*
@@ -1390,7 +1270,8 @@ static struct scsi_host_template qpti_template = {
 	.module			= THIS_MODULE,
 	.name			= "qlogicpti",
 	.info			= qlogicpti_info,
-	.queuecommand		= qlogicpti_queuecommand_slow,
+	.queuecommand		= qlogicpti_queuecommand,
+	.slave_configure	= qlogicpti_slave_configure,
 	.eh_abort_handler	= qlogicpti_abort,
 	.eh_bus_reset_handler	= qlogicpti_reset,
 	.can_queue		= QLOGICPTI_REQ_QUEUE_LEN,

commit 585a8a59ebfc81327e1c4f2c0e80730bdd2e5d8e
Author: Mark Fortescue <mark@mtfhpc.demon.co.uk>
Date:   Tue Jul 31 20:10:45 2007 +0100

    [SCSI] qlogicpti: Some cosmetic changes
    
    Change a printk sequencing issue where <6> ... was coming up in the middle
    of a line when scsi_add_host was being called.
    Reduce the length of some printk messages and make the messages
    more consistant. All cosmetic but it makes it easier to read as it
    scrolles off the screen during boot.
    
    Signed-off-by: Mark Fortescue <mark@mtfhpc.demon.co.uk>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index c4195ea869e9..594887205b0f 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -193,7 +193,8 @@ static int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int f
 		cpu_relax();
 	}
 	if (!loop_count)
-		printk(KERN_EMERG "qlogicpti: mbox_command loop timeout #1\n");
+		printk(KERN_EMERG "qlogicpti%d: mbox_command loop timeout #1\n",
+		       qpti->qpti_id);
 
 	/* Write mailbox command registers. */
 	switch (mbox_param[param[0]] >> 4) {
@@ -224,8 +225,8 @@ static int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int f
 	       (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_CRIRQ))
 		udelay(20);
 	if (!loop_count)
-		printk(KERN_EMERG "qlogicpti: mbox_command[%04x] loop timeout #2\n",
-		       param[0]);
+		printk(KERN_EMERG "qlogicpti%d: mbox_command[%04x] loop timeout #2\n",
+		       qpti->qpti_id, param[0]);
 
 	/* Wait for SBUS semaphore to get set. */
 	loop_count = DEFAULT_LOOP_COUNT;
@@ -238,16 +239,16 @@ static int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int f
 			break;
 	}
 	if (!loop_count)
-		printk(KERN_EMERG "qlogicpti: mbox_command[%04x] loop timeout #3\n",
-		       param[0]);
+		printk(KERN_EMERG "qlogicpti%d: mbox_command[%04x] loop timeout #3\n",
+		       qpti->qpti_id, param[0]);
 
 	/* Wait for MBOX busy condition to go away. */
 	loop_count = DEFAULT_LOOP_COUNT;
 	while (--loop_count && (sbus_readw(qpti->qregs + MBOX0) == 0x04))
 		udelay(20);
 	if (!loop_count)
-		printk(KERN_EMERG "qlogicpti: mbox_command[%04x] loop timeout #4\n",
-		       param[0]);
+		printk(KERN_EMERG "qlogicpti%d: mbox_command[%04x] loop timeout #4\n",
+		       qpti->qpti_id, param[0]);
 
 	/* Read back output parameters. */
 	switch (mbox_param[param[0]] & 0xf) {
@@ -342,7 +343,8 @@ static int qlogicpti_reset_hardware(struct Scsi_Host *host)
 	while (--loop_count && ((sbus_readw(qpti->qregs + MBOX0) & 0xff) == 0x04))
 		udelay(20);
 	if (!loop_count)
-		printk(KERN_EMERG "qlogicpti: reset_hardware loop timeout\n");
+		printk(KERN_EMERG "qlogicpti%d: reset_hardware loop timeout\n",
+		       qpti->qpti_id);
 
 	sbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);
 	set_sbus_cfg1(qpti);
@@ -721,12 +723,12 @@ static int __init qpti_register_irq(struct qlogicpti *qpti)
 			IRQF_SHARED, "Qlogic/PTI", qpti))
 		goto fail;
 
-	printk("qpti%d: IRQ %d ", qpti->qpti_id, qpti->irq);
+	printk("qlogicpti%d: IRQ %d ", qpti->qpti_id, qpti->irq);
 
 	return 0;
 
 fail:
-	printk("qpti%d: Cannot acquire irq line\n", qpti->qpti_id);
+	printk("qlogicpti%d: Cannot acquire irq line\n", qpti->qpti_id);
 	return -1;
 }
 
@@ -1210,7 +1212,7 @@ static int qlogicpti_return_status(struct Status_Entry *sts, int id)
 		host_status = DID_OK;
 		break;
 	      default:
-		printk(KERN_EMERG "qpti%d: unknown completion status 0x%04x\n",
+		printk(KERN_EMERG "qlogicpti%d: unknown completion status 0x%04x\n",
 		       id, sts->completion_status);
 		host_status = DID_ERROR;
 		break;
@@ -1329,8 +1331,8 @@ static int qlogicpti_abort(struct scsi_cmnd *Cmnd)
 	u32 cmd_cookie;
 	int i;
 
-	printk(KERN_WARNING "qlogicpti : Aborting cmd for tgt[%d] lun[%d]\n",
-	       (int)Cmnd->device->id, (int)Cmnd->device->lun);
+	printk(KERN_WARNING "qlogicpti%d: Aborting cmd for tgt[%d] lun[%d]\n",
+	       qpti->qpti_id, (int)Cmnd->device->id, (int)Cmnd->device->lun);
 
 	qlogicpti_disable_irqs(qpti);
 
@@ -1348,7 +1350,8 @@ static int qlogicpti_abort(struct scsi_cmnd *Cmnd)
 	param[3] = cmd_cookie & 0xffff;
 	if (qlogicpti_mbox_command(qpti, param, 0) ||
 	    (param[0] != MBOX_COMMAND_COMPLETE)) {
-		printk(KERN_EMERG "qlogicpti : scsi abort failure: %x\n", param[0]);
+		printk(KERN_EMERG "qlogicpti%d: scsi abort failure: %x\n",
+		       qpti->qpti_id, param[0]);
 		return_status = FAILED;
 	}
 
@@ -1364,7 +1367,8 @@ static int qlogicpti_reset(struct scsi_cmnd *Cmnd)
 	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
 	int return_status = SUCCESS;
 
-	printk(KERN_WARNING "qlogicpti : Resetting SCSI bus!\n");
+	printk(KERN_WARNING "qlogicpti%d: Resetting SCSI bus!\n",
+	       qpti->qpti_id);
 
 	qlogicpti_disable_irqs(qpti);
 
@@ -1372,7 +1376,8 @@ static int qlogicpti_reset(struct scsi_cmnd *Cmnd)
 	param[1] = qpti->host_param.bus_reset_delay;
 	if (qlogicpti_mbox_command(qpti, param, 0) ||
 	   (param[0] != MBOX_COMMAND_COMPLETE)) {
-		printk(KERN_EMERG "qlogicisp : scsi bus reset failure: %x\n", param[0]);
+		printk(KERN_EMERG "qlogicisp%d: scsi bus reset failure: %x\n",
+		       qpti->qpti_id, param[0]);
 		return_status = FAILED;
 	}
 
@@ -1454,22 +1459,25 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 	if (qlogicpti_reset_hardware(host))
 		goto fail_unmap_queues;
 
-	if (scsi_add_host(host, &dev->dev))
-		goto fail_unmap_queues;
-
 	printk("(Firmware v%d.%d.%d)", qpti->fware_majrev,
 	       qpti->fware_minrev, qpti->fware_micrev);
 
 	fcode = of_get_property(dp, "isp-fcode", NULL);
 	if (fcode && fcode[0])
-		printk("(Firmware %s)", fcode);
+		printk("(FCode %s)", fcode);
 	if (of_find_property(dp, "differential", NULL) != NULL)
 		qpti->differential = 1;
 			
-	printk (" [%s Wide, using %s interface]\n",
+	printk("\nqlogicpti%d: [%s Wide, using %s interface]\n",
+		qpti->qpti_id,
 		(qpti->ultra ? "Ultra" : "Fast"),
 		(qpti->differential ? "differential" : "single ended"));
 
+	if (scsi_add_host(host, &dev->dev)) {
+		printk("qlogicpti%d: Failed scsi_add_host\n", qpti->qpti_id);
+		goto fail_unmap_queues;
+	}
+
 	dev_set_drvdata(&sdev->ofdev.dev, qpti);
 
 	qpti_chain_add(qpti);

commit ccf0dec6fcadb4e1c877b9bafb031a6bdb7112b9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 29 00:49:54 2007 -0700

    [SPARC/64] constify of_get_property return: drivers
    
    The only unfortunate bit here is that the name field of struct map_info
    is not const, so for now we put a cast on the assignment of it.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 9f10689905a8..c4195ea869e9 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1403,7 +1403,7 @@ static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_devi
 	struct scsi_host_template *tpnt = match->data;
 	struct Scsi_Host *host;
 	struct qlogicpti *qpti;
-	char *fcode;
+	const char *fcode;
 
 	/* Sometimes Antares cards come up not completely
 	 * setup, and we get a report of a zero IRQ.

commit 8d3ee2cb0ab59f78fdc801ede7db15ef47387bd0
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Sat Apr 14 10:29:10 2007 -0700

    [SCSI] QLOGICPTI: Do not unmap DMA unless we actually mapped something.
    
    We only map DMA when cmd->request_bufflen is non-zero for non-sg
    buffers, we thus should make the same check when unmapping.
    
    Based upon a report from Pasi Pirhonen.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 9b827ceec501..9f10689905a8 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1281,7 +1281,7 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 				      (struct scatterlist *)Cmnd->request_buffer,
 				      Cmnd->use_sg,
 				      Cmnd->sc_data_direction);
-		} else {
+		} else if (Cmnd->request_bufflen) {
 			sbus_unmap_single(qpti->sdev,
 					  (__u32)((unsigned long)Cmnd->SCp.ptr),
 					  Cmnd->request_bufflen,

commit b48194bf0dc0f8e2b617fab10df885513fbb3bad
Author: Ben Collins <ben.collins@ubuntu.com>
Date:   Tue Oct 17 19:11:31 2006 -0700

    [SPARC]: Fix some section mismatch warnings in sparc drivers.
    
    Signed-off-by: Ben Collins <ben.collins@ubuntu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index ed58bb489889..9b827ceec501 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -461,7 +461,7 @@ static int qlogicpti_reset_hardware(struct Scsi_Host *host)
 
 #define PTI_RESET_LIMIT 400
 
-static int __init qlogicpti_load_firmware(struct qlogicpti *qpti)
+static int __devinit qlogicpti_load_firmware(struct qlogicpti *qpti)
 {
 	struct Scsi_Host *host = qpti->qhost;
 	unsigned short csum = 0;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 5b2f0741a55b..ed58bb489889 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -649,7 +649,7 @@ static int qlogicpti_verify_tmon(struct qlogicpti *qpti)
 	return 0;
 }
 
-static irqreturn_t qpti_intr(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t qpti_intr(int irq, void *dev_id);
 
 static void __init qpti_chain_add(struct qlogicpti *qpti)
 {
@@ -1297,7 +1297,7 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 	return done_queue;
 }
 
-static irqreturn_t qpti_intr(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t qpti_intr(int irq, void *dev_id)
 {
 	struct qlogicpti *qpti = dev_id;
 	unsigned long flags;

commit 79bd3f8563a275d1d068bbb9189a746dc6e96f3e
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jul 14 10:29:34 2006 +0200

    [SCSI] More buffer->request_buffer changes
    
    Seem like quite a few splipped through the cracks.  Here's a patch to
    update all references I could find:
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 69e0551a81d2..5b2f0741a55b 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -874,7 +874,7 @@ static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
 	if (Cmnd->use_sg) {
 		int sg_count;
 
-		sg = (struct scatterlist *) Cmnd->buffer;
+		sg = (struct scatterlist *) Cmnd->request_buffer;
 		sg_count = sbus_map_sg(qpti->sdev, sg, Cmnd->use_sg, Cmnd->sc_data_direction);
 
 		ds = cmd->dataseg;
@@ -1278,7 +1278,7 @@ static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
 
 		if (Cmnd->use_sg) {
 			sbus_unmap_sg(qpti->sdev,
-				      (struct scatterlist *)Cmnd->buffer,
+				      (struct scatterlist *)Cmnd->request_buffer,
 				      Cmnd->use_sg,
 				      Cmnd->sc_data_direction);
 		} else {

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 329ead263714..69e0551a81d2 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -718,7 +718,7 @@ static int __init qpti_register_irq(struct qlogicpti *qpti)
 	 * sanely maintain.
 	 */
 	if (request_irq(qpti->irq, qpti_intr,
-			SA_SHIRQ, "Qlogic/PTI", qpti))
+			IRQF_SHARED, "Qlogic/PTI", qpti))
 		goto fail;
 
 	printk("qpti%d: IRQ %d ", qpti->qpti_id, qpti->irq);

commit 3d4253d9afabd6d42c33812a839ba67b8c9bbe49
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Jun 23 22:00:34 2006 -0700

    [SCSI] qlogicpti: Convert to new SBUS device framework.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 2203103adced..329ead263714 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1,6 +1,6 @@
 /* qlogicpti.c: Performance Technologies QlogicISP sbus card driver.
  *
- * Copyright (C) 1996 David S. Miller (davem@caipfs.rutgers.edu)
+ * Copyright (C) 1996, 2006 David S. Miller (davem@davemloft.net)
  *
  * A lot of this driver was directly stolen from Erik H. Moe's PCI
  * Qlogic ISP driver.  Mucho kudos to him for this code.
@@ -46,8 +46,6 @@
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi_host.h>
 
-
-
 #define MAX_TARGETS	16
 #define MAX_LUNS	8	/* 32 for 1.31 F/W */
 
@@ -57,7 +55,6 @@
 
 static struct qlogicpti *qptichain = NULL;
 static DEFINE_SPINLOCK(qptichain_lock);
-static int qptis_running = 0;
 
 #define PACKB(a, b)			(((a)<<4)|(b))
 
@@ -815,173 +812,6 @@ static int __init qpti_map_queues(struct qlogicpti *qpti)
 	return 0;
 }
 
-/* Detect all PTI Qlogic ISP's in the machine. */
-static int __init qlogicpti_detect(struct scsi_host_template *tpnt)
-{
-	struct qlogicpti *qpti;
-	struct Scsi_Host *qpti_host;
-	struct sbus_bus *sbus;
-	struct sbus_dev *sdev;
-	int nqptis = 0, nqptis_in_use = 0;
-
-	tpnt->proc_name = "qlogicpti";
-	for_each_sbus(sbus) {
-		for_each_sbusdev(sdev, sbus) {
-			/* Is this a red snapper? */
-			if (strcmp(sdev->prom_name, "ptisp") &&
-			    strcmp(sdev->prom_name, "PTI,ptisp") &&
-			    strcmp(sdev->prom_name, "QLGC,isp") &&
-			    strcmp(sdev->prom_name, "SUNW,isp"))
-				continue;
-
-			/* Sometimes Antares cards come up not completely
-			 * setup, and we get a report of a zero IRQ.
-			 * Skip over them in such cases so we survive.
-			 */
-			if (sdev->irqs[0] == 0) {
-				printk("qpti%d: Adapter reports no interrupt, "
-				       "skipping over this card.", nqptis);
-				continue;
-			}
-
-			/* Yep, register and allocate software state. */
-			qpti_host = scsi_register(tpnt, sizeof(struct qlogicpti));
-			if (!qpti_host) {
-				printk("QPTI: Cannot register PTI Qlogic ISP SCSI host");
-				continue;
-			}
-			qpti = (struct qlogicpti *) qpti_host->hostdata;
-
-			/* We are wide capable, 16 targets. */
-			qpti_host->max_id = MAX_TARGETS;
-
-			/* Setup back pointers and misc. state. */
-			qpti->qhost = qpti_host;
-			qpti->sdev = sdev;
-			qpti->qpti_id = nqptis++;
-			qpti->prom_node = sdev->prom_node;
-			prom_getstring(qpti->prom_node, "name",
-				       qpti->prom_name,
-				       sizeof(qpti->prom_name));
-
-			/* This is not correct, actually. There's a switch
-			 * on the PTI cards that put them into "emulation"
-			 * mode- i.e., report themselves as QLGC,isp
-			 * instead of PTI,ptisp. The only real substantive
-			 * difference between non-pti and pti cards is
-			 * the tmon register. Which is possibly even
-			 * there for Qlogic cards, but non-functional.
-			 */
-			qpti->is_pti = (strcmp (qpti->prom_name, "QLGC,isp") != 0);
-
-			qpti_chain_add(qpti);
-			if (qpti_map_regs(qpti) < 0)
-				goto fail_unlink;
-
-			if (qpti_register_irq(qpti) < 0)
-				goto fail_unmap_regs;
-
-			qpti_get_scsi_id(qpti);
-			qpti_get_bursts(qpti);
-			qpti_get_clock(qpti);
-
-			/* Clear out scsi_cmnd array. */
-			memset(qpti->cmd_slots, 0, sizeof(qpti->cmd_slots));
-
-			if (qpti_map_queues(qpti) < 0)
-				goto fail_free_irq;
-
-			/* Load the firmware. */
-			if (qlogicpti_load_firmware(qpti))
-				goto fail_unmap_queues;
-			if (qpti->is_pti) {
-				/* Check the PTI status reg. */
-				if (qlogicpti_verify_tmon(qpti))
-					goto fail_unmap_queues;
-			}
-
-			/* Reset the ISP and init res/req queues. */
-			if (qlogicpti_reset_hardware(qpti_host))
-				goto fail_unmap_queues;
-
-			printk("(Firmware v%d.%d.%d)", qpti->fware_majrev,
-			    qpti->fware_minrev, qpti->fware_micrev);
-			{
-				char buffer[60];
-				
-				prom_getstring (qpti->prom_node,
-						"isp-fcode", buffer, 60);
-				if (buffer[0])
-					printk("(Firmware %s)", buffer);
-				if (prom_getbool(qpti->prom_node, "differential"))
-					qpti->differential = 1;
-			}
-			
-			printk (" [%s Wide, using %s interface]\n",
-			       (qpti->ultra ? "Ultra" : "Fast"),
-			       (qpti->differential ? "differential" : "single ended"));
-
-			nqptis_in_use++;
-			continue;
-
-		fail_unmap_queues:
-#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-			sbus_free_consistent(qpti->sdev,
-					     QSIZE(RES_QUEUE_LEN),
-					     qpti->res_cpu, qpti->res_dvma);
-			sbus_free_consistent(qpti->sdev,
-					     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
-					     qpti->req_cpu, qpti->req_dvma);
-#undef QSIZE
-		fail_free_irq:
-			free_irq(qpti->irq, qpti);
-
-		fail_unmap_regs:
-			sbus_iounmap(qpti->qregs,
-				     qpti->sdev->reg_addrs[0].reg_size);
-			if (qpti->is_pti)
-				sbus_iounmap(qpti->sreg, sizeof(unsigned char));
-		fail_unlink:
-			qpti_chain_del(qpti);
-			scsi_unregister(qpti->qhost);
-		}
-	}
-	if (nqptis)
-		printk("QPTI: Total of %d PTI Qlogic/ISP hosts found, %d actually in use.\n",
-		       nqptis, nqptis_in_use);
-	qptis_running = nqptis_in_use;
-	return nqptis;
-}
-
-static int qlogicpti_release(struct Scsi_Host *host)
-{
-	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
-
-	/* Remove visibility from IRQ handlers. */
-	qpti_chain_del(qpti);
-
-	/* Shut up the card. */
-	sbus_writew(0, qpti->qregs + SBUS_CTRL);
-
-	/* Free IRQ handler and unmap Qlogic,ISP and PTI status regs. */
-	free_irq(qpti->irq, qpti);
-
-#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
-	sbus_free_consistent(qpti->sdev,
-			     QSIZE(RES_QUEUE_LEN),
-			     qpti->res_cpu, qpti->res_dvma);
-	sbus_free_consistent(qpti->sdev,
-			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
-			     qpti->req_cpu, qpti->req_dvma);
-#undef QSIZE
-
-	sbus_iounmap(qpti->qregs, qpti->sdev->reg_addrs[0].reg_size);
-	if (qpti->is_pti)
-		sbus_iounmap(qpti->sreg, sizeof(unsigned char));
-
-	return 0;
-}
-
 const char *qlogicpti_info(struct Scsi_Host *host)
 {
 	static char buf[80];
@@ -1551,9 +1381,9 @@ static int qlogicpti_reset(struct scsi_cmnd *Cmnd)
 	return return_status;
 }
 
-static struct scsi_host_template driver_template = {
-	.detect			= qlogicpti_detect,
-	.release		= qlogicpti_release,
+static struct scsi_host_template qpti_template = {
+	.module			= THIS_MODULE,
+	.name			= "qlogicpti",
 	.info			= qlogicpti_info,
 	.queuecommand		= qlogicpti_queuecommand_slow,
 	.eh_abort_handler	= qlogicpti_abort,
@@ -1565,8 +1395,189 @@ static struct scsi_host_template driver_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 
+static int __devinit qpti_sbus_probe(struct of_device *dev, const struct of_device_id *match)
+{
+	static int nqptis;
+	struct sbus_dev *sdev = to_sbus_device(&dev->dev);
+	struct device_node *dp = dev->node;
+	struct scsi_host_template *tpnt = match->data;
+	struct Scsi_Host *host;
+	struct qlogicpti *qpti;
+	char *fcode;
+
+	/* Sometimes Antares cards come up not completely
+	 * setup, and we get a report of a zero IRQ.
+	 */
+	if (sdev->irqs[0] == 0)
+		return -ENODEV;
+
+	host = scsi_host_alloc(tpnt, sizeof(struct qlogicpti));
+	if (!host)
+		return -ENOMEM;
+
+	qpti = (struct qlogicpti *) host->hostdata;
+
+	host->max_id = MAX_TARGETS;
+	qpti->qhost = host;
+	qpti->sdev = sdev;
+	qpti->qpti_id = nqptis;
+	qpti->prom_node = sdev->prom_node;
+	strcpy(qpti->prom_name, sdev->ofdev.node->name);
+	qpti->is_pti = strcmp(qpti->prom_name, "QLGC,isp");
+
+	if (qpti_map_regs(qpti) < 0)
+		goto fail_unlink;
+
+	if (qpti_register_irq(qpti) < 0)
+		goto fail_unmap_regs;
+
+	qpti_get_scsi_id(qpti);
+	qpti_get_bursts(qpti);
+	qpti_get_clock(qpti);
+
+	/* Clear out scsi_cmnd array. */
+	memset(qpti->cmd_slots, 0, sizeof(qpti->cmd_slots));
+
+	if (qpti_map_queues(qpti) < 0)
+		goto fail_free_irq;
+
+	/* Load the firmware. */
+	if (qlogicpti_load_firmware(qpti))
+		goto fail_unmap_queues;
+	if (qpti->is_pti) {
+		/* Check the PTI status reg. */
+		if (qlogicpti_verify_tmon(qpti))
+			goto fail_unmap_queues;
+	}
+
+	/* Reset the ISP and init res/req queues. */
+	if (qlogicpti_reset_hardware(host))
+		goto fail_unmap_queues;
+
+	if (scsi_add_host(host, &dev->dev))
+		goto fail_unmap_queues;
+
+	printk("(Firmware v%d.%d.%d)", qpti->fware_majrev,
+	       qpti->fware_minrev, qpti->fware_micrev);
+
+	fcode = of_get_property(dp, "isp-fcode", NULL);
+	if (fcode && fcode[0])
+		printk("(Firmware %s)", fcode);
+	if (of_find_property(dp, "differential", NULL) != NULL)
+		qpti->differential = 1;
+			
+	printk (" [%s Wide, using %s interface]\n",
+		(qpti->ultra ? "Ultra" : "Fast"),
+		(qpti->differential ? "differential" : "single ended"));
+
+	dev_set_drvdata(&sdev->ofdev.dev, qpti);
+
+	qpti_chain_add(qpti);
+
+	scsi_scan_host(host);
+	nqptis++;
+
+	return 0;
+
+fail_unmap_queues:
+#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
+	sbus_free_consistent(qpti->sdev,
+			     QSIZE(RES_QUEUE_LEN),
+			     qpti->res_cpu, qpti->res_dvma);
+	sbus_free_consistent(qpti->sdev,
+			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+			     qpti->req_cpu, qpti->req_dvma);
+#undef QSIZE
+
+fail_unmap_regs:
+	sbus_iounmap(qpti->qregs,
+		     qpti->sdev->reg_addrs[0].reg_size);
+	if (qpti->is_pti)
+		sbus_iounmap(qpti->sreg, sizeof(unsigned char));
+
+fail_free_irq:
+	free_irq(qpti->irq, qpti);
+
+fail_unlink:
+	scsi_host_put(host);
+
+	return -ENODEV;
+}
+
+static int __devexit qpti_sbus_remove(struct of_device *dev)
+{
+	struct qlogicpti *qpti = dev_get_drvdata(&dev->dev);
+
+	qpti_chain_del(qpti);
+
+	scsi_remove_host(qpti->qhost);
+
+	/* Shut up the card. */
+	sbus_writew(0, qpti->qregs + SBUS_CTRL);
+
+	/* Free IRQ handler and unmap Qlogic,ISP and PTI status regs. */
+	free_irq(qpti->irq, qpti);
+
+#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
+	sbus_free_consistent(qpti->sdev,
+			     QSIZE(RES_QUEUE_LEN),
+			     qpti->res_cpu, qpti->res_dvma);
+	sbus_free_consistent(qpti->sdev,
+			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+			     qpti->req_cpu, qpti->req_dvma);
+#undef QSIZE
+
+	sbus_iounmap(qpti->qregs, qpti->sdev->reg_addrs[0].reg_size);
+	if (qpti->is_pti)
+		sbus_iounmap(qpti->sreg, sizeof(unsigned char));
+
+	scsi_host_put(qpti->qhost);
+
+	return 0;
+}
+
+static struct of_device_id qpti_match[] = {
+	{
+		.name = "ptisp",
+		.data = &qpti_template,
+	},
+	{
+		.name = "PTI,ptisp",
+		.data = &qpti_template,
+	},
+	{
+		.name = "QLGC,isp",
+		.data = &qpti_template,
+	},
+	{
+		.name = "SUNW,isp",
+		.data = &qpti_template,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, qpti_match);
+
+static struct of_platform_driver qpti_sbus_driver = {
+	.name		= "qpti",
+	.match_table	= qpti_match,
+	.probe		= qpti_sbus_probe,
+	.remove		= __devexit_p(qpti_sbus_remove),
+};
 
-#include "scsi_module.c"
+static int __init qpti_init(void)
+{
+	return of_register_driver(&qpti_sbus_driver, &sbus_bus_type);
+}
+
+static void __exit qpti_exit(void)
+{
+	of_unregister_driver(&qpti_sbus_driver);
+}
 
+MODULE_DESCRIPTION("QlogicISP SBUS driver");
+MODULE_AUTHOR("David S. Miller (davem@davemloft.net)");
 MODULE_LICENSE("GPL");
+MODULE_VERSION("2.0");
 
+module_init(qpti_init);
+module_exit(qpti_exit);

commit 28e4b224955cbe30275b2a7842e729023a4f4b03
Merge: 22ae813b85df 67d59dfdeb21
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Jun 21 11:18:25 2006 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (85 commits)
      [SCSI] 53c700: remove reliance on deprecated cmnd fields
      [SCSI] hptiop: don't use cmnd->bufflen
      [SCSI] hptiop: HighPoint RocketRAID 3xxx controller driver
      [SCSI] aacraid: small misc. cleanups
      [SCSI] aacraid: Update supported product information
      [SCSI] aacraid: Fix return code interpretation
      [SCSI] scsi_transport_sas: fix panic in sas_free_rphy
      [SCSI] remove RQ_SCSI_* flags
      [SCSI] remove scsi_request infrastructure
      [SCSI] mptfusion: change driver revision to 3.03.10
      [SCSI] mptfc: abort of board reset leaves port dead requiring reboot
      [SCSI] mptfc: fix fibre channel infinite request/response loop
      [SCSI] mptfc: set fibre channel fw target missing timers to one second
      [SCSI] mptfusion: move fc event/reset handling to mptfc
      [SCSI] spi transport: don't allow dt to be set on SE or HVD buses
      [SCSI] aic7xxx: expose the bus setting to sysfs
      [SCSI] scsi: remove Documentation/scsi/cpqfc.txt
      [SCSI] drivers/scsi: Use ARRAY_SIZE macro
      [SCSI] Remove last page_address from dc395x.c
      [SCSI] hptiop: HighPoint RocketRAID 3xxx controller driver
      ...
    
    Fixed up conflicts in drivers/message/fusion/mptbase.c manually (due to
    the sparc interrupt cleanups)

commit c6387a48cf5958e43c201fc27a158c328927531a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 20 01:21:29 2006 -0700

    [SPARC]: Kill __irq_itoa().
    
    This ugly hack was long overdue to die.
    
    It was a way to print out Sparc interrupts in a more freindly format,
    since IRQ numbers were arbitrary opaque 32-bit integers which vectored
    into PIL levels.  These 32-bit integers were not necessarily in the
    0-->NR_IRQS range, but the PILs they vectored to were.
    
    The idea now is that we will increase NR_IRQS a little bit and use a
    virtual<-->real IRQ number mapping scheme similar to PowerPC.
    
    That makes this IRQ printing hack irrelevant, and furthermore only a
    handful of drivers actually used __irq_itoa() making it even less
    useful.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index c7e78dcf09df..7c27ecc6fb5d 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -725,7 +725,7 @@ static int __init qpti_register_irq(struct qlogicpti *qpti)
 			SA_SHIRQ, "Qlogic/PTI", qpti))
 		goto fail;
 
-	printk("qpti%d: IRQ %s ", qpti->qpti_id, __irq_itoa(qpti->irq));
+	printk("qpti%d: IRQ %d ", qpti->qpti_id, qpti->irq);
 
 	return 0;
 
@@ -988,8 +988,8 @@ const char *qlogicpti_info(struct Scsi_Host *host)
 	static char buf[80];
 	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
 
-	sprintf(buf, "PTI Qlogic,ISP SBUS SCSI irq %s regs at %p",
-		__irq_itoa(qpti->qhost->irq), qpti->qregs);
+	sprintf(buf, "PTI Qlogic,ISP SBUS SCSI irq %d regs at %p",
+		qpti->qhost->irq, qpti->qregs);
 	return buf;
 }
 

commit beb40487508290f5d6565598c60a3f44261beef2
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 10 18:01:03 2006 +0200

    [SCSI] remove scsi_request infrastructure
    
    With Achim patch the last user (gdth) is switched away from scsi_request
    so we an kill it now.  Also disables some code in i2o_scsi that was
    broken since the sg driver stopped using scsi_requests.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 00f4b846360e..417a121fcd42 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -43,7 +43,6 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_eh.h>
-#include <scsi/scsi_request.h>
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi_host.h>
 

commit 6391a11375de5e2bb1eb8481e54619761dc65d9f
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu Jun 8 22:23:48 2006 -0700

    [SCSI] drivers/scsi: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of the macro.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index c7e78dcf09df..00f4b846360e 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -132,7 +132,7 @@ static const u_char mbox_param[] = {
 	PACKB(0, 0)	/* 0x0042 */
 };
 
-#define MAX_MBOX_COMMAND	(sizeof(mbox_param)/sizeof(u_short))
+#define MAX_MBOX_COMMAND	ARRAY_SIZE(mbox_param)
 
 /* queue length's _must_ be power of two: */
 #define QUEUE_DEPTH(in, out, ql)	((in - out) & (ql))

commit 60c904ae5bded8bb71f7bff7d63f2a6959d2a8e4
Author: Marcelo Feitoza Parisi <marcelo@feitoza.com.br>
Date:   Tue Mar 28 01:56:47 2006 -0800

    [PATCH] drivers/scsi/*: use time_after() and friends
    
    They deal with wrapping correctly and are nicer to read.
    
    Signed-off-by: Marcelo Feitoza Parisi <marcelo@feitoza.com.br>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index 1fd5fc6d0fe3..c7e78dcf09df 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -24,6 +24,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/jiffies.h>
 
 #include <asm/byteorder.h>
 
@@ -1017,7 +1018,7 @@ static inline void cmd_frob(struct Command_Entry *cmd, struct scsi_cmnd *Cmnd,
 	if (Cmnd->device->tagged_supported) {
 		if (qpti->cmd_count[Cmnd->device->id] == 0)
 			qpti->tag_ages[Cmnd->device->id] = jiffies;
-		if ((jiffies - qpti->tag_ages[Cmnd->device->id]) > (5*HZ)) {
+		if (time_after(jiffies, qpti->tag_ages[Cmnd->device->id] + (5*HZ))) {
 			cmd->control_flags = CFLAG_ORDERED_TAG;
 			qpti->tag_ages[Cmnd->device->id] = jiffies;
 		} else

commit f75884d28a6eae5a422d0454b982da3842f777af
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Oct 14 13:44:32 2005 -0700

    [QLOGICPTI]: Handle INQUIRY response sniffing correctly.
    
    These days, in 2.6.x, even INQUIRY commands are sent using
    scatter gather lists.
    
    Bug reported by Tom 'spot' Callaway.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
index a917ab7475ac..1fd5fc6d0fe3 100644
--- a/drivers/scsi/qlogicpti.c
+++ b/drivers/scsi/qlogicpti.c
@@ -1119,6 +1119,36 @@ static inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int
 	host->sg_tablesize = QLOGICPTI_MAX_SG(num_free);
 }
 
+static unsigned int scsi_rbuf_get(struct scsi_cmnd *cmd, unsigned char **buf_out)
+{
+	unsigned char *buf;
+	unsigned int buflen;
+
+	if (cmd->use_sg) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *) cmd->request_buffer;
+		buf = kmap_atomic(sg->page, KM_IRQ0) + sg->offset;
+		buflen = sg->length;
+	} else {
+		buf = cmd->request_buffer;
+		buflen = cmd->request_bufflen;
+	}
+
+	*buf_out = buf;
+	return buflen;
+}
+
+static void scsi_rbuf_put(struct scsi_cmnd *cmd, unsigned char *buf)
+{
+	if (cmd->use_sg) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *) cmd->request_buffer;
+		kunmap_atomic(buf - sg->offset, KM_IRQ0);
+	}
+}
+
 /*
  * Until we scan the entire bus with inquiries, go throught this fella...
  */
@@ -1145,11 +1175,9 @@ static void ourdone(struct scsi_cmnd *Cmnd)
 		int ok = host_byte(Cmnd->result) == DID_OK;
 		if (Cmnd->cmnd[0] == 0x12 && ok) {
 			unsigned char *iqd;
+			unsigned int iqd_len;
 
-			if (Cmnd->use_sg != 0)
-				BUG();
-
-			iqd = ((unsigned char *)Cmnd->buffer);
+			iqd_len = scsi_rbuf_get(Cmnd, &iqd);
 
 			/* tags handled in midlayer */
 			/* enable sync mode? */
@@ -1163,6 +1191,9 @@ static void ourdone(struct scsi_cmnd *Cmnd)
 			if (iqd[7] & 0x20) {
 				qpti->dev_param[tgt].device_flags |= 0x20;
 			}
+
+			scsi_rbuf_put(Cmnd, iqd);
+
 			qpti->sbits |= (1 << tgt);
 		} else if (!ok) {
 			qpti->sbits |= (1 << tgt);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
new file mode 100644
index 000000000000..a917ab7475ac
--- /dev/null
+++ b/drivers/scsi/qlogicpti.c
@@ -0,0 +1,1541 @@
+/* qlogicpti.c: Performance Technologies QlogicISP sbus card driver.
+ *
+ * Copyright (C) 1996 David S. Miller (davem@caipfs.rutgers.edu)
+ *
+ * A lot of this driver was directly stolen from Erik H. Moe's PCI
+ * Qlogic ISP driver.  Mucho kudos to him for this code.
+ *
+ * An even bigger kudos to John Grana at Performance Technologies
+ * for providing me with the hardware to write this driver, you rule
+ * John you really do.
+ *
+ * May, 2, 1997: Added support for QLGC,isp --jj
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <asm/byteorder.h>
+
+#include "qlogicpti.h"
+
+#include <asm/sbus.h>
+#include <asm/dma.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/pgtable.h>
+#include <asm/oplib.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
+#include <scsi/scsi_request.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_host.h>
+
+
+
+#define MAX_TARGETS	16
+#define MAX_LUNS	8	/* 32 for 1.31 F/W */
+
+#define DEFAULT_LOOP_COUNT	10000
+
+#include "qlogicpti_asm.c"
+
+static struct qlogicpti *qptichain = NULL;
+static DEFINE_SPINLOCK(qptichain_lock);
+static int qptis_running = 0;
+
+#define PACKB(a, b)			(((a)<<4)|(b))
+
+static const u_char mbox_param[] = {
+	PACKB(1, 1),	/* MBOX_NO_OP */
+	PACKB(5, 5),	/* MBOX_LOAD_RAM */
+	PACKB(2, 0),	/* MBOX_EXEC_FIRMWARE */
+	PACKB(5, 5),	/* MBOX_DUMP_RAM */
+	PACKB(3, 3),	/* MBOX_WRITE_RAM_WORD */
+	PACKB(2, 3),	/* MBOX_READ_RAM_WORD */
+	PACKB(6, 6),	/* MBOX_MAILBOX_REG_TEST */
+	PACKB(2, 3),	/* MBOX_VERIFY_CHECKSUM	*/
+	PACKB(1, 3),	/* MBOX_ABOUT_FIRMWARE */
+	PACKB(0, 0),	/* 0x0009 */
+	PACKB(0, 0),	/* 0x000a */
+	PACKB(0, 0),	/* 0x000b */
+	PACKB(0, 0),	/* 0x000c */
+	PACKB(0, 0),	/* 0x000d */
+	PACKB(1, 2),	/* MBOX_CHECK_FIRMWARE */
+	PACKB(0, 0),	/* 0x000f */
+	PACKB(5, 5),	/* MBOX_INIT_REQ_QUEUE */
+	PACKB(6, 6),	/* MBOX_INIT_RES_QUEUE */
+	PACKB(4, 4),	/* MBOX_EXECUTE_IOCB */
+	PACKB(2, 2),	/* MBOX_WAKE_UP	*/
+	PACKB(1, 6),	/* MBOX_STOP_FIRMWARE */
+	PACKB(4, 4),	/* MBOX_ABORT */
+	PACKB(2, 2),	/* MBOX_ABORT_DEVICE */
+	PACKB(3, 3),	/* MBOX_ABORT_TARGET */
+	PACKB(2, 2),	/* MBOX_BUS_RESET */
+	PACKB(2, 3),	/* MBOX_STOP_QUEUE */
+	PACKB(2, 3),	/* MBOX_START_QUEUE */
+	PACKB(2, 3),	/* MBOX_SINGLE_STEP_QUEUE */
+	PACKB(2, 3),	/* MBOX_ABORT_QUEUE */
+	PACKB(2, 4),	/* MBOX_GET_DEV_QUEUE_STATUS */
+	PACKB(0, 0),	/* 0x001e */
+	PACKB(1, 3),	/* MBOX_GET_FIRMWARE_STATUS */
+	PACKB(1, 2),	/* MBOX_GET_INIT_SCSI_ID */
+	PACKB(1, 2),	/* MBOX_GET_SELECT_TIMEOUT */
+	PACKB(1, 3),	/* MBOX_GET_RETRY_COUNT	*/
+	PACKB(1, 2),	/* MBOX_GET_TAG_AGE_LIMIT */
+	PACKB(1, 2),	/* MBOX_GET_CLOCK_RATE */
+	PACKB(1, 2),	/* MBOX_GET_ACT_NEG_STATE */
+	PACKB(1, 2),	/* MBOX_GET_ASYNC_DATA_SETUP_TIME */
+	PACKB(1, 3),	/* MBOX_GET_SBUS_PARAMS */
+	PACKB(2, 4),	/* MBOX_GET_TARGET_PARAMS */
+	PACKB(2, 4),	/* MBOX_GET_DEV_QUEUE_PARAMS */
+	PACKB(0, 0),	/* 0x002a */
+	PACKB(0, 0),	/* 0x002b */
+	PACKB(0, 0),	/* 0x002c */
+	PACKB(0, 0),	/* 0x002d */
+	PACKB(0, 0),	/* 0x002e */
+	PACKB(0, 0),	/* 0x002f */
+	PACKB(2, 2),	/* MBOX_SET_INIT_SCSI_ID */
+	PACKB(2, 2),	/* MBOX_SET_SELECT_TIMEOUT */
+	PACKB(3, 3),	/* MBOX_SET_RETRY_COUNT	*/
+	PACKB(2, 2),	/* MBOX_SET_TAG_AGE_LIMIT */
+	PACKB(2, 2),	/* MBOX_SET_CLOCK_RATE */
+	PACKB(2, 2),	/* MBOX_SET_ACTIVE_NEG_STATE */
+	PACKB(2, 2),	/* MBOX_SET_ASYNC_DATA_SETUP_TIME */
+	PACKB(3, 3),	/* MBOX_SET_SBUS_CONTROL_PARAMS */
+	PACKB(4, 4),	/* MBOX_SET_TARGET_PARAMS */
+	PACKB(4, 4),	/* MBOX_SET_DEV_QUEUE_PARAMS */
+	PACKB(0, 0),	/* 0x003a */
+	PACKB(0, 0),	/* 0x003b */
+	PACKB(0, 0),	/* 0x003c */
+	PACKB(0, 0),	/* 0x003d */
+	PACKB(0, 0),	/* 0x003e */
+	PACKB(0, 0),	/* 0x003f */
+	PACKB(0, 0),	/* 0x0040 */
+	PACKB(0, 0),	/* 0x0041 */
+	PACKB(0, 0)	/* 0x0042 */
+};
+
+#define MAX_MBOX_COMMAND	(sizeof(mbox_param)/sizeof(u_short))
+
+/* queue length's _must_ be power of two: */
+#define QUEUE_DEPTH(in, out, ql)	((in - out) & (ql))
+#define REQ_QUEUE_DEPTH(in, out)	QUEUE_DEPTH(in, out, 		     \
+						    QLOGICPTI_REQ_QUEUE_LEN)
+#define RES_QUEUE_DEPTH(in, out)	QUEUE_DEPTH(in, out, RES_QUEUE_LEN)
+
+static inline void qlogicpti_enable_irqs(struct qlogicpti *qpti)
+{
+	sbus_writew(SBUS_CTRL_ERIRQ | SBUS_CTRL_GENAB,
+		    qpti->qregs + SBUS_CTRL);
+}
+
+static inline void qlogicpti_disable_irqs(struct qlogicpti *qpti)
+{
+	sbus_writew(0, qpti->qregs + SBUS_CTRL);
+}
+
+static inline void set_sbus_cfg1(struct qlogicpti *qpti)
+{
+	u16 val;
+	u8 bursts = qpti->bursts;
+
+#if 0	/* It appears that at least PTI cards do not support
+	 * 64-byte bursts and that setting the B64 bit actually
+	 * is a nop and the chip ends up using the smallest burst
+	 * size. -DaveM
+	 */
+	if (sbus_can_burst64(qpti->sdev) && (bursts & DMA_BURST64)) {
+		val = (SBUS_CFG1_BENAB | SBUS_CFG1_B64);
+	} else
+#endif
+	if (bursts & DMA_BURST32) {
+		val = (SBUS_CFG1_BENAB | SBUS_CFG1_B32);
+	} else if (bursts & DMA_BURST16) {
+		val = (SBUS_CFG1_BENAB | SBUS_CFG1_B16);
+	} else if (bursts & DMA_BURST8) {
+		val = (SBUS_CFG1_BENAB | SBUS_CFG1_B8);
+	} else {
+		val = 0; /* No sbus bursts for you... */
+	}
+	sbus_writew(val, qpti->qregs + SBUS_CFG1);
+}
+
+static int qlogicpti_mbox_command(struct qlogicpti *qpti, u_short param[], int force)
+{
+	int loop_count;
+	u16 tmp;
+
+	if (mbox_param[param[0]] == 0)
+		return 1;
+
+	/* Set SBUS semaphore. */
+	tmp = sbus_readw(qpti->qregs + SBUS_SEMAPHORE);
+	tmp |= SBUS_SEMAPHORE_LCK;
+	sbus_writew(tmp, qpti->qregs + SBUS_SEMAPHORE);
+
+	/* Wait for host IRQ bit to clear. */
+	loop_count = DEFAULT_LOOP_COUNT;
+	while (--loop_count && (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_HIRQ)) {
+		barrier();
+		cpu_relax();
+	}
+	if (!loop_count)
+		printk(KERN_EMERG "qlogicpti: mbox_command loop timeout #1\n");
+
+	/* Write mailbox command registers. */
+	switch (mbox_param[param[0]] >> 4) {
+	case 6: sbus_writew(param[5], qpti->qregs + MBOX5);
+	case 5: sbus_writew(param[4], qpti->qregs + MBOX4);
+	case 4: sbus_writew(param[3], qpti->qregs + MBOX3);
+	case 3: sbus_writew(param[2], qpti->qregs + MBOX2);
+	case 2: sbus_writew(param[1], qpti->qregs + MBOX1);
+	case 1: sbus_writew(param[0], qpti->qregs + MBOX0);
+	}
+
+	/* Clear RISC interrupt. */
+	tmp = sbus_readw(qpti->qregs + HCCTRL);
+	tmp |= HCCTRL_CRIRQ;
+	sbus_writew(tmp, qpti->qregs + HCCTRL);
+
+	/* Clear SBUS semaphore. */
+	sbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);
+
+	/* Set HOST interrupt. */
+	tmp = sbus_readw(qpti->qregs + HCCTRL);
+	tmp |= HCCTRL_SHIRQ;
+	sbus_writew(tmp, qpti->qregs + HCCTRL);
+
+	/* Wait for HOST interrupt clears. */
+	loop_count = DEFAULT_LOOP_COUNT;
+	while (--loop_count &&
+	       (sbus_readw(qpti->qregs + HCCTRL) & HCCTRL_CRIRQ))
+		udelay(20);
+	if (!loop_count)
+		printk(KERN_EMERG "qlogicpti: mbox_command[%04x] loop timeout #2\n",
+		       param[0]);
+
+	/* Wait for SBUS semaphore to get set. */
+	loop_count = DEFAULT_LOOP_COUNT;
+	while (--loop_count &&
+	       !(sbus_readw(qpti->qregs + SBUS_SEMAPHORE) & SBUS_SEMAPHORE_LCK)) {
+		udelay(20);
+
+		/* Workaround for some buggy chips. */
+		if (sbus_readw(qpti->qregs + MBOX0) & 0x4000)
+			break;
+	}
+	if (!loop_count)
+		printk(KERN_EMERG "qlogicpti: mbox_command[%04x] loop timeout #3\n",
+		       param[0]);
+
+	/* Wait for MBOX busy condition to go away. */
+	loop_count = DEFAULT_LOOP_COUNT;
+	while (--loop_count && (sbus_readw(qpti->qregs + MBOX0) == 0x04))
+		udelay(20);
+	if (!loop_count)
+		printk(KERN_EMERG "qlogicpti: mbox_command[%04x] loop timeout #4\n",
+		       param[0]);
+
+	/* Read back output parameters. */
+	switch (mbox_param[param[0]] & 0xf) {
+	case 6: param[5] = sbus_readw(qpti->qregs + MBOX5);
+	case 5: param[4] = sbus_readw(qpti->qregs + MBOX4);
+	case 4: param[3] = sbus_readw(qpti->qregs + MBOX3);
+	case 3: param[2] = sbus_readw(qpti->qregs + MBOX2);
+	case 2: param[1] = sbus_readw(qpti->qregs + MBOX1);
+	case 1: param[0] = sbus_readw(qpti->qregs + MBOX0);
+	}
+
+	/* Clear RISC interrupt. */
+	tmp = sbus_readw(qpti->qregs + HCCTRL);
+	tmp |= HCCTRL_CRIRQ;
+	sbus_writew(tmp, qpti->qregs + HCCTRL);
+
+	/* Release SBUS semaphore. */
+	tmp = sbus_readw(qpti->qregs + SBUS_SEMAPHORE);
+	tmp &= ~(SBUS_SEMAPHORE_LCK);
+	sbus_writew(tmp, qpti->qregs + SBUS_SEMAPHORE);
+
+	/* We're done. */
+	return 0;
+}
+
+static inline void qlogicpti_set_hostdev_defaults(struct qlogicpti *qpti)
+{
+	int i;
+
+	qpti->host_param.initiator_scsi_id = qpti->scsi_id;
+	qpti->host_param.bus_reset_delay = 3;
+	qpti->host_param.retry_count = 0;
+	qpti->host_param.retry_delay = 5;
+	qpti->host_param.async_data_setup_time = 3;
+	qpti->host_param.req_ack_active_negation = 1;
+	qpti->host_param.data_line_active_negation = 1;
+	qpti->host_param.data_dma_burst_enable = 1;
+	qpti->host_param.command_dma_burst_enable = 1;
+	qpti->host_param.tag_aging = 8;
+	qpti->host_param.selection_timeout = 250;
+	qpti->host_param.max_queue_depth = 256;
+
+	for(i = 0; i < MAX_TARGETS; i++) {
+		/*
+		 * disconnect, parity, arq, reneg on reset, and, oddly enough
+		 * tags...the midlayer's notion of tagged support has to match
+		 * our device settings, and since we base whether we enable a
+		 * tag on a  per-cmnd basis upon what the midlayer sez, we
+		 * actually enable the capability here.
+		 */
+		qpti->dev_param[i].device_flags = 0xcd;
+		qpti->dev_param[i].execution_throttle = 16;
+		if (qpti->ultra) {
+			qpti->dev_param[i].synchronous_period = 12;
+			qpti->dev_param[i].synchronous_offset = 8;
+		} else {
+			qpti->dev_param[i].synchronous_period = 25;
+			qpti->dev_param[i].synchronous_offset = 12;
+		}
+		qpti->dev_param[i].device_enable = 1;
+	}
+	/* this is very important to set! */
+	qpti->sbits = 1 << qpti->scsi_id;
+}
+
+static int qlogicpti_reset_hardware(struct Scsi_Host *host)
+{
+	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
+	u_short param[6];
+	unsigned short risc_code_addr;
+	int loop_count, i;
+	unsigned long flags;
+
+	risc_code_addr = 0x1000;	/* all load addresses are at 0x1000 */
+
+	spin_lock_irqsave(host->host_lock, flags);
+
+	sbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);
+
+	/* Only reset the scsi bus if it is not free. */
+	if (sbus_readw(qpti->qregs + CPU_PCTRL) & CPU_PCTRL_BSY) {
+		sbus_writew(CPU_ORIDE_RMOD, qpti->qregs + CPU_ORIDE);
+		sbus_writew(CPU_CMD_BRESET, qpti->qregs + CPU_CMD);
+		udelay(400);
+	}
+
+	sbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);
+	sbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);
+	sbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + DATA_DMA_CTRL);
+
+	loop_count = DEFAULT_LOOP_COUNT;
+	while (--loop_count && ((sbus_readw(qpti->qregs + MBOX0) & 0xff) == 0x04))
+		udelay(20);
+	if (!loop_count)
+		printk(KERN_EMERG "qlogicpti: reset_hardware loop timeout\n");
+
+	sbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);
+	set_sbus_cfg1(qpti);
+	qlogicpti_enable_irqs(qpti);
+
+	if (sbus_readw(qpti->qregs + RISC_PSR) & RISC_PSR_ULTRA) {
+		qpti->ultra = 1;
+		sbus_writew((RISC_MTREG_P0ULTRA | RISC_MTREG_P1ULTRA),
+			    qpti->qregs + RISC_MTREG);
+	} else {
+		qpti->ultra = 0;
+		sbus_writew((RISC_MTREG_P0DFLT | RISC_MTREG_P1DFLT),
+			    qpti->qregs + RISC_MTREG);
+	}
+
+	/* reset adapter and per-device default values. */
+	/* do it after finding out whether we're ultra mode capable */
+	qlogicpti_set_hostdev_defaults(qpti);
+
+	/* Release the RISC processor. */
+	sbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);
+
+	/* Get RISC to start executing the firmware code. */
+	param[0] = MBOX_EXEC_FIRMWARE;
+	param[1] = risc_code_addr;
+	if (qlogicpti_mbox_command(qpti, param, 1)) {
+		printk(KERN_EMERG "qlogicpti%d: Cannot execute ISP firmware.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	/* Set initiator scsi ID. */
+	param[0] = MBOX_SET_INIT_SCSI_ID;
+	param[1] = qpti->host_param.initiator_scsi_id;
+	if (qlogicpti_mbox_command(qpti, param, 1) ||
+	   (param[0] != MBOX_COMMAND_COMPLETE)) {
+		printk(KERN_EMERG "qlogicpti%d: Cannot set initiator SCSI ID.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	/* Initialize state of the queues, both hw and sw. */
+	qpti->req_in_ptr = qpti->res_out_ptr = 0;
+
+	param[0] = MBOX_INIT_RES_QUEUE;
+	param[1] = RES_QUEUE_LEN + 1;
+	param[2] = (u_short) (qpti->res_dvma >> 16);
+	param[3] = (u_short) (qpti->res_dvma & 0xffff);
+	param[4] = param[5] = 0;
+	if (qlogicpti_mbox_command(qpti, param, 1)) {
+		printk(KERN_EMERG "qlogicpti%d: Cannot init response queue.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	param[0] = MBOX_INIT_REQ_QUEUE;
+	param[1] = QLOGICPTI_REQ_QUEUE_LEN + 1;
+	param[2] = (u_short) (qpti->req_dvma >> 16);
+	param[3] = (u_short) (qpti->req_dvma & 0xffff);
+	param[4] = param[5] = 0;
+	if (qlogicpti_mbox_command(qpti, param, 1)) {
+		printk(KERN_EMERG "qlogicpti%d: Cannot init request queue.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	param[0] = MBOX_SET_RETRY_COUNT;
+	param[1] = qpti->host_param.retry_count;
+	param[2] = qpti->host_param.retry_delay;
+	qlogicpti_mbox_command(qpti, param, 0);
+
+	param[0] = MBOX_SET_TAG_AGE_LIMIT;
+	param[1] = qpti->host_param.tag_aging;
+	qlogicpti_mbox_command(qpti, param, 0);
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		param[0] = MBOX_GET_DEV_QUEUE_PARAMS;
+		param[1] = (i << 8);
+		qlogicpti_mbox_command(qpti, param, 0);
+	}
+
+	param[0] = MBOX_GET_FIRMWARE_STATUS;
+	qlogicpti_mbox_command(qpti, param, 0);
+
+	param[0] = MBOX_SET_SELECT_TIMEOUT;
+	param[1] = qpti->host_param.selection_timeout;
+	qlogicpti_mbox_command(qpti, param, 0);
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		param[0] = MBOX_SET_TARGET_PARAMS;
+		param[1] = (i << 8);
+		param[2] = (qpti->dev_param[i].device_flags << 8);
+		/*
+		 * Since we're now loading 1.31 f/w, force narrow/async.
+		 */
+		param[2] |= 0xc0;
+		param[3] = 0;	/* no offset, we do not have sync mode yet */
+		qlogicpti_mbox_command(qpti, param, 0);
+	}
+
+	/*
+	 * Always (sigh) do an initial bus reset (kicks f/w).
+	 */
+	param[0] = MBOX_BUS_RESET;
+	param[1] = qpti->host_param.bus_reset_delay;
+	qlogicpti_mbox_command(qpti, param, 0);
+	qpti->send_marker = 1;
+
+	spin_unlock_irqrestore(host->host_lock, flags);
+	return 0;
+}
+
+#define PTI_RESET_LIMIT 400
+
+static int __init qlogicpti_load_firmware(struct qlogicpti *qpti)
+{
+	struct Scsi_Host *host = qpti->qhost;
+	unsigned short csum = 0;
+	unsigned short param[6];
+	unsigned short *risc_code, risc_code_addr, risc_code_length;
+	unsigned long flags;
+	int i, timeout;
+
+	risc_code = &sbus_risc_code01[0];
+	risc_code_addr = 0x1000;	/* all f/w modules load at 0x1000 */
+	risc_code_length = sbus_risc_code_length01;
+
+	spin_lock_irqsave(host->host_lock, flags);
+
+	/* Verify the checksum twice, one before loading it, and once
+	 * afterwards via the mailbox commands.
+	 */
+	for (i = 0; i < risc_code_length; i++)
+		csum += risc_code[i];
+	if (csum) {
+		spin_unlock_irqrestore(host->host_lock, flags);
+		printk(KERN_EMERG "qlogicpti%d: Aieee, firmware checksum failed!",
+		       qpti->qpti_id);
+		return 1;
+	}		
+	sbus_writew(SBUS_CTRL_RESET, qpti->qregs + SBUS_CTRL);
+	sbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + CMD_DMA_CTRL);
+	sbus_writew((DMA_CTRL_CCLEAR | DMA_CTRL_CIRQ), qpti->qregs + DATA_DMA_CTRL);
+	timeout = PTI_RESET_LIMIT;
+	while (--timeout && (sbus_readw(qpti->qregs + SBUS_CTRL) & SBUS_CTRL_RESET))
+		udelay(20);
+	if (!timeout) {
+		spin_unlock_irqrestore(host->host_lock, flags);
+		printk(KERN_EMERG "qlogicpti%d: Cannot reset the ISP.", qpti->qpti_id);
+		return 1;
+	}
+
+	sbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);
+	mdelay(1);
+
+	sbus_writew((SBUS_CTRL_GENAB | SBUS_CTRL_ERIRQ), qpti->qregs + SBUS_CTRL);
+	set_sbus_cfg1(qpti);
+	sbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);
+
+	if (sbus_readw(qpti->qregs + RISC_PSR) & RISC_PSR_ULTRA) {
+		qpti->ultra = 1;
+		sbus_writew((RISC_MTREG_P0ULTRA | RISC_MTREG_P1ULTRA),
+			    qpti->qregs + RISC_MTREG);
+	} else {
+		qpti->ultra = 0;
+		sbus_writew((RISC_MTREG_P0DFLT | RISC_MTREG_P1DFLT),
+			    qpti->qregs + RISC_MTREG);
+	}
+
+	sbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);
+
+	/* Pin lines are only stable while RISC is paused. */
+	sbus_writew(HCCTRL_PAUSE, qpti->qregs + HCCTRL);
+	if (sbus_readw(qpti->qregs + CPU_PDIFF) & CPU_PDIFF_MODE)
+		qpti->differential = 1;
+	else
+		qpti->differential = 0;
+	sbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);
+
+	/* This shouldn't be necessary- we've reset things so we should be
+	   running from the ROM now.. */
+
+	param[0] = MBOX_STOP_FIRMWARE;
+	param[1] = param[2] = param[3] = param[4] = param[5] = 0;
+	if (qlogicpti_mbox_command(qpti, param, 1)) {
+		printk(KERN_EMERG "qlogicpti%d: Cannot stop firmware for reload.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}		
+
+	/* Load it up.. */
+	for (i = 0; i < risc_code_length; i++) {
+		param[0] = MBOX_WRITE_RAM_WORD;
+		param[1] = risc_code_addr + i;
+		param[2] = risc_code[i];
+		if (qlogicpti_mbox_command(qpti, param, 1) ||
+		    param[0] != MBOX_COMMAND_COMPLETE) {
+			printk("qlogicpti%d: Firmware dload failed, I'm bolixed!\n",
+			       qpti->qpti_id);
+			spin_unlock_irqrestore(host->host_lock, flags);
+			return 1;
+		}
+	}
+
+	/* Reset the ISP again. */
+	sbus_writew(HCCTRL_RESET, qpti->qregs + HCCTRL);
+	mdelay(1);
+
+	qlogicpti_enable_irqs(qpti);
+	sbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);
+	sbus_writew(HCCTRL_REL, qpti->qregs + HCCTRL);
+
+	/* Ask ISP to verify the checksum of the new code. */
+	param[0] = MBOX_VERIFY_CHECKSUM;
+	param[1] = risc_code_addr;
+	if (qlogicpti_mbox_command(qpti, param, 1) ||
+	    (param[0] != MBOX_COMMAND_COMPLETE)) {
+		printk(KERN_EMERG "qlogicpti%d: New firmware csum failure!\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	/* Start using newly downloaded firmware. */
+	param[0] = MBOX_EXEC_FIRMWARE;
+	param[1] = risc_code_addr;
+	qlogicpti_mbox_command(qpti, param, 1);
+
+	param[0] = MBOX_ABOUT_FIRMWARE;
+	if (qlogicpti_mbox_command(qpti, param, 1) ||
+	    (param[0] != MBOX_COMMAND_COMPLETE)) {
+		printk(KERN_EMERG "qlogicpti%d: AboutFirmware cmd fails.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	/* Snag the major and minor revisions from the result. */
+	qpti->fware_majrev = param[1];
+	qpti->fware_minrev = param[2];
+	qpti->fware_micrev = param[3];
+
+	/* Set the clock rate */
+	param[0] = MBOX_SET_CLOCK_RATE;
+	param[1] = qpti->clock;
+	if (qlogicpti_mbox_command(qpti, param, 1) ||
+	    (param[0] != MBOX_COMMAND_COMPLETE)) {
+		printk(KERN_EMERG "qlogicpti%d: could not set clock rate.\n",
+		       qpti->qpti_id);
+		spin_unlock_irqrestore(host->host_lock, flags);
+		return 1;
+	}
+
+	if (qpti->is_pti != 0) {
+		/* Load scsi initiator ID and interrupt level into sbus static ram. */
+		param[0] = MBOX_WRITE_RAM_WORD;
+		param[1] = 0xff80;
+		param[2] = (unsigned short) qpti->scsi_id;
+		qlogicpti_mbox_command(qpti, param, 1);
+
+		param[0] = MBOX_WRITE_RAM_WORD;
+		param[1] = 0xff00;
+		param[2] = (unsigned short) 3;
+		qlogicpti_mbox_command(qpti, param, 1);
+	}
+
+	spin_unlock_irqrestore(host->host_lock, flags);
+	return 0;
+}
+
+static int qlogicpti_verify_tmon(struct qlogicpti *qpti)
+{
+	int curstat = sbus_readb(qpti->sreg);
+
+	curstat &= 0xf0;
+	if (!(curstat & SREG_FUSE) && (qpti->swsreg & SREG_FUSE))
+		printk("qlogicpti%d: Fuse returned to normal state.\n", qpti->qpti_id);
+	if (!(curstat & SREG_TPOWER) && (qpti->swsreg & SREG_TPOWER))
+		printk("qlogicpti%d: termpwr back to normal state.\n", qpti->qpti_id);
+	if (curstat != qpti->swsreg) {
+		int error = 0;
+		if (curstat & SREG_FUSE) {
+			error++;
+			printk("qlogicpti%d: Fuse is open!\n", qpti->qpti_id);
+		}
+		if (curstat & SREG_TPOWER) {
+			error++;
+			printk("qlogicpti%d: termpwr failure\n", qpti->qpti_id);
+		}
+		if (qpti->differential &&
+		    (curstat & SREG_DSENSE) != SREG_DSENSE) {
+			error++;
+			printk("qlogicpti%d: You have a single ended device on a "
+			       "differential bus!  Please fix!\n", qpti->qpti_id);
+		}
+		qpti->swsreg = curstat;
+		return error;
+	}
+	return 0;
+}
+
+static irqreturn_t qpti_intr(int irq, void *dev_id, struct pt_regs *regs);
+
+static void __init qpti_chain_add(struct qlogicpti *qpti)
+{
+	spin_lock_irq(&qptichain_lock);
+	if (qptichain != NULL) {
+		struct qlogicpti *qlink = qptichain;
+
+		while(qlink->next)
+			qlink = qlink->next;
+		qlink->next = qpti;
+	} else {
+		qptichain = qpti;
+	}
+	qpti->next = NULL;
+	spin_unlock_irq(&qptichain_lock);
+}
+
+static void __init qpti_chain_del(struct qlogicpti *qpti)
+{
+	spin_lock_irq(&qptichain_lock);
+	if (qptichain == qpti) {
+		qptichain = qpti->next;
+	} else {
+		struct qlogicpti *qlink = qptichain;
+		while(qlink->next != qpti)
+			qlink = qlink->next;
+		qlink->next = qpti->next;
+	}
+	qpti->next = NULL;
+	spin_unlock_irq(&qptichain_lock);
+}
+
+static int __init qpti_map_regs(struct qlogicpti *qpti)
+{
+	struct sbus_dev *sdev = qpti->sdev;
+
+	qpti->qregs = sbus_ioremap(&sdev->resource[0], 0,
+				   sdev->reg_addrs[0].reg_size,
+				   "PTI Qlogic/ISP");
+	if (!qpti->qregs) {
+		printk("PTI: Qlogic/ISP registers are unmappable\n");
+		return -1;
+	}
+	if (qpti->is_pti) {
+		qpti->sreg = sbus_ioremap(&sdev->resource[0], (16 * 4096),
+					  sizeof(unsigned char),
+					  "PTI Qlogic/ISP statreg");
+		if (!qpti->sreg) {
+			printk("PTI: Qlogic/ISP status register is unmappable\n");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static int __init qpti_register_irq(struct qlogicpti *qpti)
+{
+	struct sbus_dev *sdev = qpti->sdev;
+
+	qpti->qhost->irq = qpti->irq = sdev->irqs[0];
+
+	/* We used to try various overly-clever things to
+	 * reduce the interrupt processing overhead on
+	 * sun4c/sun4m when multiple PTI's shared the
+	 * same IRQ.  It was too complex and messy to
+	 * sanely maintain.
+	 */
+	if (request_irq(qpti->irq, qpti_intr,
+			SA_SHIRQ, "Qlogic/PTI", qpti))
+		goto fail;
+
+	printk("qpti%d: IRQ %s ", qpti->qpti_id, __irq_itoa(qpti->irq));
+
+	return 0;
+
+fail:
+	printk("qpti%d: Cannot acquire irq line\n", qpti->qpti_id);
+	return -1;
+}
+
+static void __init qpti_get_scsi_id(struct qlogicpti *qpti)
+{
+	qpti->scsi_id = prom_getintdefault(qpti->prom_node,
+					   "initiator-id",
+					   -1);
+	if (qpti->scsi_id == -1)
+		qpti->scsi_id = prom_getintdefault(qpti->prom_node,
+						   "scsi-initiator-id",
+						   -1);
+	if (qpti->scsi_id == -1)
+		qpti->scsi_id =
+			prom_getintdefault(qpti->sdev->bus->prom_node,
+					   "scsi-initiator-id", 7);
+	qpti->qhost->this_id = qpti->scsi_id;
+	qpti->qhost->max_sectors = 64;
+
+	printk("SCSI ID %d ", qpti->scsi_id);
+}
+
+static void qpti_get_bursts(struct qlogicpti *qpti)
+{
+	struct sbus_dev *sdev = qpti->sdev;
+	u8 bursts, bmask;
+
+	bursts = prom_getintdefault(qpti->prom_node, "burst-sizes", 0xff);
+	bmask = prom_getintdefault(sdev->bus->prom_node,
+				   "burst-sizes", 0xff);
+	if (bmask != 0xff)
+		bursts &= bmask;
+	if (bursts == 0xff ||
+	    (bursts & DMA_BURST16) == 0 ||
+	    (bursts & DMA_BURST32) == 0)
+		bursts = (DMA_BURST32 - 1);
+
+	qpti->bursts = bursts;
+}
+
+static void qpti_get_clock(struct qlogicpti *qpti)
+{
+	unsigned int cfreq;
+
+	/* Check for what the clock input to this card is.
+	 * Default to 40Mhz.
+	 */
+	cfreq = prom_getintdefault(qpti->prom_node,"clock-frequency",40000000);
+	qpti->clock = (cfreq + 500000)/1000000;
+	if (qpti->clock == 0) /* bullshit */
+		qpti->clock = 40;
+}
+
+/* The request and response queues must each be aligned
+ * on a page boundary.
+ */
+static int __init qpti_map_queues(struct qlogicpti *qpti)
+{
+	struct sbus_dev *sdev = qpti->sdev;
+
+#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
+	qpti->res_cpu = sbus_alloc_consistent(sdev,
+					      QSIZE(RES_QUEUE_LEN),
+					      &qpti->res_dvma);
+	if (qpti->res_cpu == NULL ||
+	    qpti->res_dvma == 0) {
+		printk("QPTI: Cannot map response queue.\n");
+		return -1;
+	}
+
+	qpti->req_cpu = sbus_alloc_consistent(sdev,
+					      QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+					      &qpti->req_dvma);
+	if (qpti->req_cpu == NULL ||
+	    qpti->req_dvma == 0) {
+		sbus_free_consistent(sdev, QSIZE(RES_QUEUE_LEN),
+				     qpti->res_cpu, qpti->res_dvma);
+		printk("QPTI: Cannot map request queue.\n");
+		return -1;
+	}
+	memset(qpti->res_cpu, 0, QSIZE(RES_QUEUE_LEN));
+	memset(qpti->req_cpu, 0, QSIZE(QLOGICPTI_REQ_QUEUE_LEN));
+	return 0;
+}
+
+/* Detect all PTI Qlogic ISP's in the machine. */
+static int __init qlogicpti_detect(struct scsi_host_template *tpnt)
+{
+	struct qlogicpti *qpti;
+	struct Scsi_Host *qpti_host;
+	struct sbus_bus *sbus;
+	struct sbus_dev *sdev;
+	int nqptis = 0, nqptis_in_use = 0;
+
+	tpnt->proc_name = "qlogicpti";
+	for_each_sbus(sbus) {
+		for_each_sbusdev(sdev, sbus) {
+			/* Is this a red snapper? */
+			if (strcmp(sdev->prom_name, "ptisp") &&
+			    strcmp(sdev->prom_name, "PTI,ptisp") &&
+			    strcmp(sdev->prom_name, "QLGC,isp") &&
+			    strcmp(sdev->prom_name, "SUNW,isp"))
+				continue;
+
+			/* Sometimes Antares cards come up not completely
+			 * setup, and we get a report of a zero IRQ.
+			 * Skip over them in such cases so we survive.
+			 */
+			if (sdev->irqs[0] == 0) {
+				printk("qpti%d: Adapter reports no interrupt, "
+				       "skipping over this card.", nqptis);
+				continue;
+			}
+
+			/* Yep, register and allocate software state. */
+			qpti_host = scsi_register(tpnt, sizeof(struct qlogicpti));
+			if (!qpti_host) {
+				printk("QPTI: Cannot register PTI Qlogic ISP SCSI host");
+				continue;
+			}
+			qpti = (struct qlogicpti *) qpti_host->hostdata;
+
+			/* We are wide capable, 16 targets. */
+			qpti_host->max_id = MAX_TARGETS;
+
+			/* Setup back pointers and misc. state. */
+			qpti->qhost = qpti_host;
+			qpti->sdev = sdev;
+			qpti->qpti_id = nqptis++;
+			qpti->prom_node = sdev->prom_node;
+			prom_getstring(qpti->prom_node, "name",
+				       qpti->prom_name,
+				       sizeof(qpti->prom_name));
+
+			/* This is not correct, actually. There's a switch
+			 * on the PTI cards that put them into "emulation"
+			 * mode- i.e., report themselves as QLGC,isp
+			 * instead of PTI,ptisp. The only real substantive
+			 * difference between non-pti and pti cards is
+			 * the tmon register. Which is possibly even
+			 * there for Qlogic cards, but non-functional.
+			 */
+			qpti->is_pti = (strcmp (qpti->prom_name, "QLGC,isp") != 0);
+
+			qpti_chain_add(qpti);
+			if (qpti_map_regs(qpti) < 0)
+				goto fail_unlink;
+
+			if (qpti_register_irq(qpti) < 0)
+				goto fail_unmap_regs;
+
+			qpti_get_scsi_id(qpti);
+			qpti_get_bursts(qpti);
+			qpti_get_clock(qpti);
+
+			/* Clear out scsi_cmnd array. */
+			memset(qpti->cmd_slots, 0, sizeof(qpti->cmd_slots));
+
+			if (qpti_map_queues(qpti) < 0)
+				goto fail_free_irq;
+
+			/* Load the firmware. */
+			if (qlogicpti_load_firmware(qpti))
+				goto fail_unmap_queues;
+			if (qpti->is_pti) {
+				/* Check the PTI status reg. */
+				if (qlogicpti_verify_tmon(qpti))
+					goto fail_unmap_queues;
+			}
+
+			/* Reset the ISP and init res/req queues. */
+			if (qlogicpti_reset_hardware(qpti_host))
+				goto fail_unmap_queues;
+
+			printk("(Firmware v%d.%d.%d)", qpti->fware_majrev,
+			    qpti->fware_minrev, qpti->fware_micrev);
+			{
+				char buffer[60];
+				
+				prom_getstring (qpti->prom_node,
+						"isp-fcode", buffer, 60);
+				if (buffer[0])
+					printk("(Firmware %s)", buffer);
+				if (prom_getbool(qpti->prom_node, "differential"))
+					qpti->differential = 1;
+			}
+			
+			printk (" [%s Wide, using %s interface]\n",
+			       (qpti->ultra ? "Ultra" : "Fast"),
+			       (qpti->differential ? "differential" : "single ended"));
+
+			nqptis_in_use++;
+			continue;
+
+		fail_unmap_queues:
+#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
+			sbus_free_consistent(qpti->sdev,
+					     QSIZE(RES_QUEUE_LEN),
+					     qpti->res_cpu, qpti->res_dvma);
+			sbus_free_consistent(qpti->sdev,
+					     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+					     qpti->req_cpu, qpti->req_dvma);
+#undef QSIZE
+		fail_free_irq:
+			free_irq(qpti->irq, qpti);
+
+		fail_unmap_regs:
+			sbus_iounmap(qpti->qregs,
+				     qpti->sdev->reg_addrs[0].reg_size);
+			if (qpti->is_pti)
+				sbus_iounmap(qpti->sreg, sizeof(unsigned char));
+		fail_unlink:
+			qpti_chain_del(qpti);
+			scsi_unregister(qpti->qhost);
+		}
+	}
+	if (nqptis)
+		printk("QPTI: Total of %d PTI Qlogic/ISP hosts found, %d actually in use.\n",
+		       nqptis, nqptis_in_use);
+	qptis_running = nqptis_in_use;
+	return nqptis;
+}
+
+static int qlogicpti_release(struct Scsi_Host *host)
+{
+	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
+
+	/* Remove visibility from IRQ handlers. */
+	qpti_chain_del(qpti);
+
+	/* Shut up the card. */
+	sbus_writew(0, qpti->qregs + SBUS_CTRL);
+
+	/* Free IRQ handler and unmap Qlogic,ISP and PTI status regs. */
+	free_irq(qpti->irq, qpti);
+
+#define QSIZE(entries)	(((entries) + 1) * QUEUE_ENTRY_LEN)
+	sbus_free_consistent(qpti->sdev,
+			     QSIZE(RES_QUEUE_LEN),
+			     qpti->res_cpu, qpti->res_dvma);
+	sbus_free_consistent(qpti->sdev,
+			     QSIZE(QLOGICPTI_REQ_QUEUE_LEN),
+			     qpti->req_cpu, qpti->req_dvma);
+#undef QSIZE
+
+	sbus_iounmap(qpti->qregs, qpti->sdev->reg_addrs[0].reg_size);
+	if (qpti->is_pti)
+		sbus_iounmap(qpti->sreg, sizeof(unsigned char));
+
+	return 0;
+}
+
+const char *qlogicpti_info(struct Scsi_Host *host)
+{
+	static char buf[80];
+	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
+
+	sprintf(buf, "PTI Qlogic,ISP SBUS SCSI irq %s regs at %p",
+		__irq_itoa(qpti->qhost->irq), qpti->qregs);
+	return buf;
+}
+
+/* I am a certified frobtronicist. */
+static inline void marker_frob(struct Command_Entry *cmd)
+{
+	struct Marker_Entry *marker = (struct Marker_Entry *) cmd;
+
+	memset(marker, 0, sizeof(struct Marker_Entry));
+	marker->hdr.entry_cnt = 1;
+	marker->hdr.entry_type = ENTRY_MARKER;
+	marker->modifier = SYNC_ALL;
+	marker->rsvd = 0;
+}
+
+static inline void cmd_frob(struct Command_Entry *cmd, struct scsi_cmnd *Cmnd,
+			    struct qlogicpti *qpti)
+{
+	memset(cmd, 0, sizeof(struct Command_Entry));
+	cmd->hdr.entry_cnt = 1;
+	cmd->hdr.entry_type = ENTRY_COMMAND;
+	cmd->target_id = Cmnd->device->id;
+	cmd->target_lun = Cmnd->device->lun;
+	cmd->cdb_length = Cmnd->cmd_len;
+	cmd->control_flags = 0;
+	if (Cmnd->device->tagged_supported) {
+		if (qpti->cmd_count[Cmnd->device->id] == 0)
+			qpti->tag_ages[Cmnd->device->id] = jiffies;
+		if ((jiffies - qpti->tag_ages[Cmnd->device->id]) > (5*HZ)) {
+			cmd->control_flags = CFLAG_ORDERED_TAG;
+			qpti->tag_ages[Cmnd->device->id] = jiffies;
+		} else
+			cmd->control_flags = CFLAG_SIMPLE_TAG;
+	}
+	if ((Cmnd->cmnd[0] == WRITE_6) ||
+	    (Cmnd->cmnd[0] == WRITE_10) ||
+	    (Cmnd->cmnd[0] == WRITE_12))
+		cmd->control_flags |= CFLAG_WRITE;
+	else
+		cmd->control_flags |= CFLAG_READ;
+	cmd->time_out = 30;
+	memcpy(cmd->cdb, Cmnd->cmnd, Cmnd->cmd_len);
+}
+
+/* Do it to it baby. */
+static inline int load_cmd(struct scsi_cmnd *Cmnd, struct Command_Entry *cmd,
+			   struct qlogicpti *qpti, u_int in_ptr, u_int out_ptr)
+{
+	struct dataseg *ds;
+	struct scatterlist *sg;
+	int i, n;
+
+	if (Cmnd->use_sg) {
+		int sg_count;
+
+		sg = (struct scatterlist *) Cmnd->buffer;
+		sg_count = sbus_map_sg(qpti->sdev, sg, Cmnd->use_sg, Cmnd->sc_data_direction);
+
+		ds = cmd->dataseg;
+		cmd->segment_cnt = sg_count;
+
+		/* Fill in first four sg entries: */
+		n = sg_count;
+		if (n > 4)
+			n = 4;
+		for (i = 0; i < n; i++, sg++) {
+			ds[i].d_base = sg_dma_address(sg);
+			ds[i].d_count = sg_dma_len(sg);
+		}
+		sg_count -= 4;
+		while (sg_count > 0) {
+			struct Continuation_Entry *cont;
+
+			++cmd->hdr.entry_cnt;
+			cont = (struct Continuation_Entry *) &qpti->req_cpu[in_ptr];
+			in_ptr = NEXT_REQ_PTR(in_ptr);
+			if (in_ptr == out_ptr)
+				return -1;
+
+			cont->hdr.entry_type = ENTRY_CONTINUATION;
+			cont->hdr.entry_cnt = 0;
+			cont->hdr.sys_def_1 = 0;
+			cont->hdr.flags = 0;
+			cont->reserved = 0;
+			ds = cont->dataseg;
+			n = sg_count;
+			if (n > 7)
+				n = 7;
+			for (i = 0; i < n; i++, sg++) {
+				ds[i].d_base = sg_dma_address(sg);
+				ds[i].d_count = sg_dma_len(sg);
+			}
+			sg_count -= n;
+		}
+	} else if (Cmnd->request_bufflen) {
+		Cmnd->SCp.ptr = (char *)(unsigned long)
+			sbus_map_single(qpti->sdev,
+					Cmnd->request_buffer,
+					Cmnd->request_bufflen,
+					Cmnd->sc_data_direction);
+
+		cmd->dataseg[0].d_base = (u32) ((unsigned long)Cmnd->SCp.ptr);
+		cmd->dataseg[0].d_count = Cmnd->request_bufflen;
+		cmd->segment_cnt = 1;
+	} else {
+		cmd->dataseg[0].d_base = 0;
+		cmd->dataseg[0].d_count = 0;
+		cmd->segment_cnt = 1; /* Shouldn't this be 0? */
+	}
+
+	/* Committed, record Scsi_Cmd so we can find it later. */
+	cmd->handle = in_ptr;
+	qpti->cmd_slots[in_ptr] = Cmnd;
+
+	qpti->cmd_count[Cmnd->device->id]++;
+	sbus_writew(in_ptr, qpti->qregs + MBOX4);
+	qpti->req_in_ptr = in_ptr;
+
+	return in_ptr;
+}
+
+static inline void update_can_queue(struct Scsi_Host *host, u_int in_ptr, u_int out_ptr)
+{
+	/* Temporary workaround until bug is found and fixed (one bug has been found
+	   already, but fixing it makes things even worse) -jj */
+	int num_free = QLOGICPTI_REQ_QUEUE_LEN - REQ_QUEUE_DEPTH(in_ptr, out_ptr) - 64;
+	host->can_queue = host->host_busy + num_free;
+	host->sg_tablesize = QLOGICPTI_MAX_SG(num_free);
+}
+
+/*
+ * Until we scan the entire bus with inquiries, go throught this fella...
+ */
+static void ourdone(struct scsi_cmnd *Cmnd)
+{
+	struct qlogicpti *qpti = (struct qlogicpti *) Cmnd->device->host->hostdata;
+	int tgt = Cmnd->device->id;
+	void (*done) (struct scsi_cmnd *);
+
+	/* This grot added by DaveM, blame him for ugliness.
+	 * The issue is that in the 2.3.x driver we use the
+	 * host_scribble portion of the scsi command as a
+	 * completion linked list at interrupt service time,
+	 * so we have to store the done function pointer elsewhere.
+	 */
+	done = (void (*)(struct scsi_cmnd *))
+		(((unsigned long) Cmnd->SCp.Message)
+#ifdef __sparc_v9__
+		 | ((unsigned long) Cmnd->SCp.Status << 32UL)
+#endif
+		 );
+
+	if ((qpti->sbits & (1 << tgt)) == 0) {
+		int ok = host_byte(Cmnd->result) == DID_OK;
+		if (Cmnd->cmnd[0] == 0x12 && ok) {
+			unsigned char *iqd;
+
+			if (Cmnd->use_sg != 0)
+				BUG();
+
+			iqd = ((unsigned char *)Cmnd->buffer);
+
+			/* tags handled in midlayer */
+			/* enable sync mode? */
+			if (iqd[7] & 0x10) {
+				qpti->dev_param[tgt].device_flags |= 0x10;
+			} else {
+				qpti->dev_param[tgt].synchronous_offset = 0;
+				qpti->dev_param[tgt].synchronous_period = 0;
+			}
+			/* are we wide capable? */
+			if (iqd[7] & 0x20) {
+				qpti->dev_param[tgt].device_flags |= 0x20;
+			}
+			qpti->sbits |= (1 << tgt);
+		} else if (!ok) {
+			qpti->sbits |= (1 << tgt);
+		}
+	}
+	done(Cmnd);
+}
+
+static int qlogicpti_queuecommand(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *));
+
+static int qlogicpti_queuecommand_slow(struct scsi_cmnd *Cmnd,
+				       void (*done)(struct scsi_cmnd *))
+{
+	struct qlogicpti *qpti = (struct qlogicpti *) Cmnd->device->host->hostdata;
+
+	/*
+	 * done checking this host adapter?
+	 * If not, then rewrite the command
+	 * to finish through ourdone so we
+	 * can peek at Inquiry data results.
+	 */
+	if (qpti->sbits && qpti->sbits != 0xffff) {
+		/* See above about in ourdone this ugliness... */
+		Cmnd->SCp.Message = ((unsigned long)done) & 0xffffffff;
+#ifdef CONFIG_SPARC64
+		Cmnd->SCp.Status = ((unsigned long)done >> 32UL) & 0xffffffff;
+#endif
+		return qlogicpti_queuecommand(Cmnd, ourdone);
+	}
+
+	/*
+	 * We've peeked at all targets for this bus- time
+	 * to set parameters for devices for real now.
+	 */
+	if (qpti->sbits == 0xffff) {
+		int i;
+		for(i = 0; i < MAX_TARGETS; i++) {
+			u_short param[6];
+			param[0] = MBOX_SET_TARGET_PARAMS;
+			param[1] = (i << 8);
+			param[2] = (qpti->dev_param[i].device_flags << 8);
+			if (qpti->dev_param[i].device_flags & 0x10) {
+				param[3] = (qpti->dev_param[i].synchronous_offset << 8) |
+					qpti->dev_param[i].synchronous_period;
+			} else {
+				param[3] = 0;
+			}
+			(void) qlogicpti_mbox_command(qpti, param, 0);
+		}
+		/*
+		 * set to zero so any traverse through ourdone
+		 * doesn't start the whole process again,
+		 */
+		qpti->sbits = 0;
+	}
+
+	/* check to see if we're done with all adapters... */
+	for (qpti = qptichain; qpti != NULL; qpti = qpti->next) {
+		if (qpti->sbits) {
+			break;
+		}
+	}
+
+	/*
+	 * if we hit the end of the chain w/o finding adapters still
+	 * capability-configuring, then we're done with all adapters
+	 * and can rock on..
+	 */
+	if (qpti == NULL)
+		Cmnd->device->host->hostt->queuecommand = qlogicpti_queuecommand;
+
+	return qlogicpti_queuecommand(Cmnd, done);
+}
+
+/*
+ * The middle SCSI layer ensures that queuecommand never gets invoked
+ * concurrently with itself or the interrupt handler (though the
+ * interrupt handler may call this routine as part of
+ * request-completion handling).
+ *
+ * "This code must fly." -davem
+ */
+static int qlogicpti_queuecommand(struct scsi_cmnd *Cmnd, void (*done)(struct scsi_cmnd *))
+{
+	struct Scsi_Host *host = Cmnd->device->host;
+	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
+	struct Command_Entry *cmd;
+	u_int out_ptr;
+	int in_ptr;
+
+	Cmnd->scsi_done = done;
+
+	in_ptr = qpti->req_in_ptr;
+	cmd = (struct Command_Entry *) &qpti->req_cpu[in_ptr];
+	out_ptr = sbus_readw(qpti->qregs + MBOX4);
+	in_ptr = NEXT_REQ_PTR(in_ptr);
+	if (in_ptr == out_ptr)
+		goto toss_command;
+
+	if (qpti->send_marker) {
+		marker_frob(cmd);
+		qpti->send_marker = 0;
+		if (NEXT_REQ_PTR(in_ptr) == out_ptr) {
+			sbus_writew(in_ptr, qpti->qregs + MBOX4);
+			qpti->req_in_ptr = in_ptr;
+			goto toss_command;
+		}
+		cmd = (struct Command_Entry *) &qpti->req_cpu[in_ptr];
+		in_ptr = NEXT_REQ_PTR(in_ptr);
+	}
+	cmd_frob(cmd, Cmnd, qpti);
+	if ((in_ptr = load_cmd(Cmnd, cmd, qpti, in_ptr, out_ptr)) == -1)
+		goto toss_command;
+
+	update_can_queue(host, in_ptr, out_ptr);
+
+	return 0;
+
+toss_command:
+	printk(KERN_EMERG "qlogicpti%d: request queue overflow\n",
+	       qpti->qpti_id);
+
+	/* Unfortunately, unless you use the new EH code, which
+	 * we don't, the midlayer will ignore the return value,
+	 * which is insane.  We pick up the pieces like this.
+	 */
+	Cmnd->result = DID_BUS_BUSY;
+	done(Cmnd);
+	return 1;
+}
+
+static int qlogicpti_return_status(struct Status_Entry *sts, int id)
+{
+	int host_status = DID_ERROR;
+
+	switch (sts->completion_status) {
+	      case CS_COMPLETE:
+		host_status = DID_OK;
+		break;
+	      case CS_INCOMPLETE:
+		if (!(sts->state_flags & SF_GOT_BUS))
+			host_status = DID_NO_CONNECT;
+		else if (!(sts->state_flags & SF_GOT_TARGET))
+			host_status = DID_BAD_TARGET;
+		else if (!(sts->state_flags & SF_SENT_CDB))
+			host_status = DID_ERROR;
+		else if (!(sts->state_flags & SF_TRANSFERRED_DATA))
+			host_status = DID_ERROR;
+		else if (!(sts->state_flags & SF_GOT_STATUS))
+			host_status = DID_ERROR;
+		else if (!(sts->state_flags & SF_GOT_SENSE))
+			host_status = DID_ERROR;
+		break;
+	      case CS_DMA_ERROR:
+	      case CS_TRANSPORT_ERROR:
+		host_status = DID_ERROR;
+		break;
+	      case CS_RESET_OCCURRED:
+	      case CS_BUS_RESET:
+		host_status = DID_RESET;
+		break;
+	      case CS_ABORTED:
+		host_status = DID_ABORT;
+		break;
+	      case CS_TIMEOUT:
+		host_status = DID_TIME_OUT;
+		break;
+	      case CS_DATA_OVERRUN:
+	      case CS_COMMAND_OVERRUN:
+	      case CS_STATUS_OVERRUN:
+	      case CS_BAD_MESSAGE:
+	      case CS_NO_MESSAGE_OUT:
+	      case CS_EXT_ID_FAILED:
+	      case CS_IDE_MSG_FAILED:
+	      case CS_ABORT_MSG_FAILED:
+	      case CS_NOP_MSG_FAILED:
+	      case CS_PARITY_ERROR_MSG_FAILED:
+	      case CS_DEVICE_RESET_MSG_FAILED:
+	      case CS_ID_MSG_FAILED:
+	      case CS_UNEXP_BUS_FREE:
+		host_status = DID_ERROR;
+		break;
+	      case CS_DATA_UNDERRUN:
+		host_status = DID_OK;
+		break;
+	      default:
+		printk(KERN_EMERG "qpti%d: unknown completion status 0x%04x\n",
+		       id, sts->completion_status);
+		host_status = DID_ERROR;
+		break;
+	}
+
+	return (sts->scsi_status & STATUS_MASK) | (host_status << 16);
+}
+
+static struct scsi_cmnd *qlogicpti_intr_handler(struct qlogicpti *qpti)
+{
+	struct scsi_cmnd *Cmnd, *done_queue = NULL;
+	struct Status_Entry *sts;
+	u_int in_ptr, out_ptr;
+
+	if (!(sbus_readw(qpti->qregs + SBUS_STAT) & SBUS_STAT_RINT))
+		return NULL;
+		
+	in_ptr = sbus_readw(qpti->qregs + MBOX5);
+	sbus_writew(HCCTRL_CRIRQ, qpti->qregs + HCCTRL);
+	if (sbus_readw(qpti->qregs + SBUS_SEMAPHORE) & SBUS_SEMAPHORE_LCK) {
+		switch (sbus_readw(qpti->qregs + MBOX0)) {
+		case ASYNC_SCSI_BUS_RESET:
+		case EXECUTION_TIMEOUT_RESET:
+			qpti->send_marker = 1;
+			break;
+		case INVALID_COMMAND:
+		case HOST_INTERFACE_ERROR:
+		case COMMAND_ERROR:
+		case COMMAND_PARAM_ERROR:
+			break;
+		};
+		sbus_writew(0, qpti->qregs + SBUS_SEMAPHORE);
+	}
+
+	/* This looks like a network driver! */
+	out_ptr = qpti->res_out_ptr;
+	while (out_ptr != in_ptr) {
+		u_int cmd_slot;
+
+		sts = (struct Status_Entry *) &qpti->res_cpu[out_ptr];
+		out_ptr = NEXT_RES_PTR(out_ptr);
+
+		/* We store an index in the handle, not the pointer in
+		 * some form.  This avoids problems due to the fact
+		 * that the handle provided is only 32-bits. -DaveM
+		 */
+		cmd_slot = sts->handle;
+		Cmnd = qpti->cmd_slots[cmd_slot];
+		qpti->cmd_slots[cmd_slot] = NULL;
+
+		if (sts->completion_status == CS_RESET_OCCURRED ||
+		    sts->completion_status == CS_ABORTED ||
+		    (sts->status_flags & STF_BUS_RESET))
+			qpti->send_marker = 1;
+
+		if (sts->state_flags & SF_GOT_SENSE)
+			memcpy(Cmnd->sense_buffer, sts->req_sense_data,
+			       sizeof(Cmnd->sense_buffer));
+
+		if (sts->hdr.entry_type == ENTRY_STATUS)
+			Cmnd->result =
+			    qlogicpti_return_status(sts, qpti->qpti_id);
+		else
+			Cmnd->result = DID_ERROR << 16;
+
+		if (Cmnd->use_sg) {
+			sbus_unmap_sg(qpti->sdev,
+				      (struct scatterlist *)Cmnd->buffer,
+				      Cmnd->use_sg,
+				      Cmnd->sc_data_direction);
+		} else {
+			sbus_unmap_single(qpti->sdev,
+					  (__u32)((unsigned long)Cmnd->SCp.ptr),
+					  Cmnd->request_bufflen,
+					  Cmnd->sc_data_direction);
+		}
+		qpti->cmd_count[Cmnd->device->id]--;
+		sbus_writew(out_ptr, qpti->qregs + MBOX5);
+		Cmnd->host_scribble = (unsigned char *) done_queue;
+		done_queue = Cmnd;
+	}
+	qpti->res_out_ptr = out_ptr;
+
+	return done_queue;
+}
+
+static irqreturn_t qpti_intr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct qlogicpti *qpti = dev_id;
+	unsigned long flags;
+	struct scsi_cmnd *dq;
+
+	spin_lock_irqsave(qpti->qhost->host_lock, flags);
+	dq = qlogicpti_intr_handler(qpti);
+
+	if (dq != NULL) {
+		do {
+			struct scsi_cmnd *next;
+
+			next = (struct scsi_cmnd *) dq->host_scribble;
+			dq->scsi_done(dq);
+			dq = next;
+		} while (dq != NULL);
+	}
+	spin_unlock_irqrestore(qpti->qhost->host_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int qlogicpti_abort(struct scsi_cmnd *Cmnd)
+{
+	u_short param[6];
+	struct Scsi_Host *host = Cmnd->device->host;
+	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
+	int return_status = SUCCESS;
+	u32 cmd_cookie;
+	int i;
+
+	printk(KERN_WARNING "qlogicpti : Aborting cmd for tgt[%d] lun[%d]\n",
+	       (int)Cmnd->device->id, (int)Cmnd->device->lun);
+
+	qlogicpti_disable_irqs(qpti);
+
+	/* Find the 32-bit cookie we gave to the firmware for
+	 * this command.
+	 */
+	for (i = 0; i < QLOGICPTI_REQ_QUEUE_LEN + 1; i++)
+		if (qpti->cmd_slots[i] == Cmnd)
+			break;
+	cmd_cookie = i;
+
+	param[0] = MBOX_ABORT;
+	param[1] = (((u_short) Cmnd->device->id) << 8) | Cmnd->device->lun;
+	param[2] = cmd_cookie >> 16;
+	param[3] = cmd_cookie & 0xffff;
+	if (qlogicpti_mbox_command(qpti, param, 0) ||
+	    (param[0] != MBOX_COMMAND_COMPLETE)) {
+		printk(KERN_EMERG "qlogicpti : scsi abort failure: %x\n", param[0]);
+		return_status = FAILED;
+	}
+
+	qlogicpti_enable_irqs(qpti);
+
+	return return_status;
+}
+
+static int qlogicpti_reset(struct scsi_cmnd *Cmnd)
+{
+	u_short param[6];
+	struct Scsi_Host *host = Cmnd->device->host;
+	struct qlogicpti *qpti = (struct qlogicpti *) host->hostdata;
+	int return_status = SUCCESS;
+
+	printk(KERN_WARNING "qlogicpti : Resetting SCSI bus!\n");
+
+	qlogicpti_disable_irqs(qpti);
+
+	param[0] = MBOX_BUS_RESET;
+	param[1] = qpti->host_param.bus_reset_delay;
+	if (qlogicpti_mbox_command(qpti, param, 0) ||
+	   (param[0] != MBOX_COMMAND_COMPLETE)) {
+		printk(KERN_EMERG "qlogicisp : scsi bus reset failure: %x\n", param[0]);
+		return_status = FAILED;
+	}
+
+	qlogicpti_enable_irqs(qpti);
+
+	return return_status;
+}
+
+static struct scsi_host_template driver_template = {
+	.detect			= qlogicpti_detect,
+	.release		= qlogicpti_release,
+	.info			= qlogicpti_info,
+	.queuecommand		= qlogicpti_queuecommand_slow,
+	.eh_abort_handler	= qlogicpti_abort,
+	.eh_bus_reset_handler	= qlogicpti_reset,
+	.can_queue		= QLOGICPTI_REQ_QUEUE_LEN,
+	.this_id		= 7,
+	.sg_tablesize		= QLOGICPTI_MAX_SG(QLOGICPTI_REQ_QUEUE_LEN),
+	.cmd_per_lun		= 1,
+	.use_clustering		= ENABLE_CLUSTERING,
+};
+
+
+#include "scsi_module.c"
+
+MODULE_LICENSE("GPL");
+
