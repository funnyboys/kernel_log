commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index d32f4415e503..f9f8f4921654 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -31,9 +31,9 @@
 #include <linux/reboot.h>
 #include <linux/spinlock.h>
 #include <linux/pci.h>
+#include <linux/pgtable.h>
 #include <asm/dbdma.h>
 #include <asm/io.h>
-#include <linux/pgtable.h>
 #include <asm/prom.h>
 #include <asm/irq.h>
 #include <asm/hydra.h>

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 74fb50644678..d32f4415e503 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -33,7 +33,7 @@
 #include <linux/pci.h>
 #include <asm/dbdma.h>
 #include <asm/io.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/prom.h>
 #include <asm/irq.h>
 #include <asm/hydra.h>

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index c9dc7740e9e7..74fb50644678 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * SCSI low-level driver for the MESH (Macintosh Enhanced SCSI Hardware)
  * bus adaptor found on Power Macintosh computers.

commit 750afb08ca71310fcf0c4e2cb1565c63b8235b60
Author: Luis Chamberlain <mcgrof@kernel.org>
Date:   Fri Jan 4 09:23:09 2019 +0100

    cross-tree: phase out dma_zalloc_coherent()
    
    We already need to zero out memory for dma_alloc_coherent(), as such
    using dma_zalloc_coherent() is superflous. Phase it out.
    
    This change was generated with the following Coccinelle SmPL patch:
    
    @ replace_dma_zalloc_coherent @
    expression dev, size, data, handle, flags;
    @@
    
    -dma_zalloc_coherent(dev, size, handle, flags)
    +dma_alloc_coherent(dev, size, handle, flags)
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Luis Chamberlain <mcgrof@kernel.org>
    [hch: re-ran the script on the latest tree]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index f3e182eb0970..c9dc7740e9e7 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1915,8 +1915,9 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	/* We use the PCI APIs for now until the generic one gets fixed
 	 * enough or until we get some macio-specific versions
 	 */
-	dma_cmd_space = dma_zalloc_coherent(&macio_get_pci_dev(mdev)->dev,
-			ms->dma_cmd_size, &dma_cmd_bus, GFP_KERNEL);
+	dma_cmd_space = dma_alloc_coherent(&macio_get_pci_dev(mdev)->dev,
+					   ms->dma_cmd_size, &dma_cmd_bus,
+					   GFP_KERNEL);
 	if (dma_cmd_space == NULL) {
 		printk(KERN_ERR "mesh: can't allocate DMA table\n");
 		goto out_unmap;

commit 5bd6cd54bd01171176e8be510d429720a3fd2dce
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:07 2018 +0100

    scsi: mesh: remove DISABLE_CLUSTERING
    
    mesh has no limitations on crossing pages for segments.  Just make
    the 65535 byte segment size limit explicit, even if it matches the
    current block layer limit.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Paul Mackerras <paulus@ozlabs.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index ec6940f2fcb3..f3e182eb0970 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1838,7 +1838,7 @@ static struct scsi_host_template mesh_template = {
 	.this_id			= 7,
 	.sg_tablesize			= SG_ALL,
 	.cmd_per_lun			= 2,
-	.use_clustering			= DISABLE_CLUSTERING,
+	.max_segment_size		= 65535,
 };
 
 static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)

commit 6c714d44259494b4d593dd88d2b5a43ff1730680
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 11 10:17:35 2018 +0200

    scsi: mesh: switch to generic DMA API
    
    Switch from the legacy PCI DMA API to the generic DMA API.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 82e01dbe90af..ec6940f2fcb3 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1915,8 +1915,8 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	/* We use the PCI APIs for now until the generic one gets fixed
 	 * enough or until we get some macio-specific versions
 	 */
-	dma_cmd_space = pci_zalloc_consistent(macio_get_pci_dev(mdev),
-					      ms->dma_cmd_size, &dma_cmd_bus);
+	dma_cmd_space = dma_zalloc_coherent(&macio_get_pci_dev(mdev)->dev,
+			ms->dma_cmd_size, &dma_cmd_bus, GFP_KERNEL);
 	if (dma_cmd_space == NULL) {
 		printk(KERN_ERR "mesh: can't allocate DMA table\n");
 		goto out_unmap;
@@ -1974,7 +1974,7 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	 */
 	mesh_shutdown(mdev);
 	set_mesh_power(ms, 0);
-	pci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,
+	dma_free_coherent(&macio_get_pci_dev(mdev)->dev, ms->dma_cmd_size,
 			    ms->dma_cmd_space, ms->dma_cmd_bus);
  out_unmap:
 	iounmap(ms->dma);
@@ -2007,7 +2007,7 @@ static int mesh_remove(struct macio_dev *mdev)
        	iounmap(ms->dma);
 
 	/* Free DMA commands memory */
-	pci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,
+	dma_free_coherent(&macio_get_pci_dev(mdev)->dev, ms->dma_cmd_size,
 			    ms->dma_cmd_space, ms->dma_cmd_bus);
 
 	/* Release memory resources */

commit 6bec4c3842cd7338973839683bbf96273c3b85f7
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Mon Jun 25 13:20:59 2018 +0200

    scsi: don't add scsi command result bytes
    
    Some drivers are ADDing the scsi command's result bytes instead of ORing
    them.
    
    While this can produce correct results it has unexpected side effects.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 1753e42826dd..82e01dbe90af 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -594,9 +594,9 @@ static void mesh_done(struct mesh_state *ms, int start_next)
 	ms->current_req = NULL;
 	tp->current_req = NULL;
 	if (cmd) {
-		cmd->result = (ms->stat << 16) + cmd->SCp.Status;
+		cmd->result = (ms->stat << 16) | cmd->SCp.Status;
 		if (ms->stat == DID_OK)
-			cmd->result += (cmd->SCp.Message << 8);
+			cmd->result |= cmd->SCp.Message << 8;
 		if (DEBUG_TARGET(cmd)) {
 			printk(KERN_DEBUG "mesh_done: result = %x, data_ptr=%d, buflen=%d\n",
 			       cmd->result, ms->data_ptr, scsi_bufflen(cmd));

commit 952bbcb0781bd1341f6a9f5c96fc32737392c04a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:58:12 2016 -0600

    PCI: Remove includes of asm/pci-bridge.h
    
    Drivers should include asm/pci-bridge.h only when they need the arch-
    specific things provided there.  Outside of the arch/ directories, the only
    drivers that actually need things provided by asm/pci-bridge.h are the
    powerpc RPA hotplug drivers in drivers/pci/hotplug/rpa*.
    
    Remove the includes of asm/pci-bridge.h from the other drivers, adding an
    include of linux/pci.h if necessary.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 555367f00228..1753e42826dd 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -29,6 +29,7 @@
 #include <linux/interrupt.h>
 #include <linux/reboot.h>
 #include <linux/spinlock.h>
+#include <linux/pci.h>
 #include <asm/dbdma.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>
@@ -38,7 +39,6 @@
 #include <asm/processor.h>
 #include <asm/machdep.h>
 #include <asm/pmac_feature.h>
-#include <asm/pci-bridge.h>
 #include <asm/macio.h>
 
 #include <scsi/scsi.h>

commit f5718726714cd6114876c4e3ca9b6992ab81176c
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Tue Feb 3 16:36:21 2015 +1100

    powerpc: Move Power Macintosh drivers to generic byteswappers
    
    ppc has special instruction forms to efficiently load and store values
    in non-native endianness.  These can be accessed via the arch-specific
    {ld,st}_le{16,32}() inlines in arch/powerpc/include/asm/swab.h.
    
    However, gcc is perfectly capable of generating the byte-reversing
    load/store instructions when using the normal, generic cpu_to_le*() and
    le*_to_cpu() functions eaning the arch-specific functions don't have much
    point.
    
    Worse the "le" in the names of the arch specific functions is now
    misleading, because they always generate byte-reversing forms, but some
    ppc machines can now run a little-endian kernel.
    
    To start getting rid of the arch-specific forms, this patch removes them
    from all the old Power Macintosh drivers, replacing them with the
    generic byteswappers.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 57a95e2c3442..555367f00228 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1287,9 +1287,9 @@ static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)
 				}
 				if (dma_len > 0xffff)
 					panic("mesh: scatterlist element >= 64k");
-				st_le16(&dcmds->req_count, dma_len - off);
-				st_le16(&dcmds->command, dma_cmd);
-				st_le32(&dcmds->phy_addr, dma_addr + off);
+				dcmds->req_count = cpu_to_le16(dma_len - off);
+				dcmds->command = cpu_to_le16(dma_cmd);
+				dcmds->phy_addr = cpu_to_le32(dma_addr + off);
 				dcmds->xfer_status = 0;
 				++dcmds;
 				dtot += dma_len - off;
@@ -1303,15 +1303,15 @@ static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)
 		static char mesh_extra_buf[64];
 
 		dtot = sizeof(mesh_extra_buf);
-		st_le16(&dcmds->req_count, dtot);
-		st_le32(&dcmds->phy_addr, virt_to_phys(mesh_extra_buf));
+		dcmds->req_count = cpu_to_le16(dtot);
+		dcmds->phy_addr = cpu_to_le32(virt_to_phys(mesh_extra_buf));
 		dcmds->xfer_status = 0;
 		++dcmds;
 	}
 	dma_cmd += OUTPUT_LAST - OUTPUT_MORE;
-	st_le16(&dcmds[-1].command, dma_cmd);
+	dcmds[-1].command = cpu_to_le16(dma_cmd);
 	memset(dcmds, 0, sizeof(*dcmds));
-	st_le16(&dcmds->command, DBDMA_STOP);
+	dcmds->command = cpu_to_le16(DBDMA_STOP);
 	ms->dma_count = dtot;
 }
 

commit 7c845eb5e184977d9c7135ae20d012b59f8cc729
Author: Joe Perches <joe@perches.com>
Date:   Fri Aug 8 14:24:46 2014 -0700

    scsi: use pci_zalloc_consistent
    
    Remove the now unnecessary memset too.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: Jayamohan Kallickal <jayamohan.kallickal@emulex.com>
    Cc: Dario Ballabio <ballabio_dario@emc.com>
    Cc: Michael Neuffer <mike@i-Connect.Net>
    Cc: "Stephen M. Cameron" <scameron@beardog.cce.hp.com>
    Cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 7a6160f172ce..57a95e2c3442 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1915,14 +1915,12 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	/* We use the PCI APIs for now until the generic one gets fixed
 	 * enough or until we get some macio-specific versions
 	 */
-	dma_cmd_space = pci_alloc_consistent(macio_get_pci_dev(mdev),
-					     ms->dma_cmd_size,
-					     &dma_cmd_bus);
+	dma_cmd_space = pci_zalloc_consistent(macio_get_pci_dev(mdev),
+					      ms->dma_cmd_size, &dma_cmd_bus);
 	if (dma_cmd_space == NULL) {
 		printk(KERN_ERR "mesh: can't allocate DMA table\n");
 		goto out_unmap;
 	}
-	memset(dma_cmd_space, 0, ms->dma_cmd_size);
 
 	ms->dma_cmds = (struct dbdma_cmd *) DBDMA_ALIGN(dma_cmd_space);
        	ms->dma_cmd_space = dma_cmd_space;

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index e8a04ae3276a..7a6160f172ce 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1230,7 +1230,7 @@ static void handle_msgin(struct mesh_state *ms)
 				ms->msgphase = msg_out;
 			} else if (code != cmd->device->lun + IDENTIFY_BASE) {
 				printk(KERN_WARNING "mesh: lun mismatch "
-				       "(%d != %d) on reselection from "
+				       "(%d != %llu) on reselection from "
 				       "target %d\n", code - IDENTIFY_BASE,
 				       cmd->device->lun, ms->conn_tgt);
 			}

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 494474779532..e8a04ae3276a 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -33,7 +33,6 @@
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/prom.h>
-#include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/hydra.h>
 #include <asm/processor.h>

commit 5cd049a59913f359e7d30c11d2dc6187822e77b1
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Apr 4 09:42:14 2011 -0400

    [SCSI] remove cmd->serial_number litter
    
    Stop using cmd->serial_number in printks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 197aa1b3f0f3..494474779532 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -415,8 +415,7 @@ static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
 #if 1
 	if (DEBUG_TARGET(cmd)) {
 		int i;
-		printk(KERN_DEBUG "mesh_start: %p ser=%lu tgt=%d cmd=",
-		       cmd, cmd->serial_number, id);
+		printk(KERN_DEBUG "mesh_start: %p tgt=%d cmd=", cmd, id);
 		for (i = 0; i < cmd->cmd_len; ++i)
 			printk(" %x", cmd->cmnd[i]);
 		printk(" use_sg=%d buffer=%p bufflen=%u\n",

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 1f784fde2510..197aa1b3f0f3 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1627,7 +1627,7 @@ static void cmd_complete(struct mesh_state *ms)
  * Called by midlayer with host locked to queue a new
  * request
  */
-static int mesh_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+static int mesh_queue_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 {
 	struct mesh_state *ms;
 
@@ -1648,6 +1648,8 @@ static int mesh_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
 	return 0;
 }
 
+static DEF_SCSI_QCMD(mesh_queue)
+
 /*
  * Called to handle interrupts, either call by the interrupt
  * handler (do_mesh_interrupt) or by other functions in

commit c2cdf6aba0dfcfb54be646ab630c1bccd180e890
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Jun 2 17:09:18 2010 +1000

    powerpc/macio: Fix probing of macio devices by using the right of match table
    
    Grant patches added an of mach table to struct device_driver. However,
    while he changed the macio device code to use that, he left the match
    table pointer in struct macio_driver and didn't update drivers to use
    the "new" one, thus breaking the probing.
    
    This completes the change by moving all drivers to setup the "new"
    one, removing all traces of the old one, and while at it (since it
    changes the exact same locations), I also remove two other duplicates
    from struct driver which are the name and owner fields.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index a1c97e88068a..1f784fde2510 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -2036,8 +2036,11 @@ MODULE_DEVICE_TABLE (of, mesh_match);
 
 static struct macio_driver mesh_driver = 
 {
-	.name 		= "mesh",
-	.match_table	= mesh_match,
+	.driver = {
+		.name 		= "mesh",
+		.owner		= THIS_MODULE,
+		.of_match_table	= mesh_match,
+	},
 	.probe		= mesh_probe,
 	.remove		= mesh_remove,
 	.shutdown	= mesh_shutdown,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 11aa917629ac..a1c97e88068a 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -23,7 +23,6 @@
 #include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/string.h>
-#include <linux/slab.h>
 #include <linux/blkdev.h>
 #include <linux/proc_fs.h>
 #include <linux/stat.h>

commit 19c4158bcdf42ee3b2394342caf14f8471d2c78e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 7 11:20:25 2008 -0500

    [SCSI] SCSI: remove dev->power.power_state from mesh driver
    
    power.power_state is scheduled for removal.  This patch (as1055)
    removes all uses of that field from the SCSI mesh driver.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Paul Mackerras <paulus@au.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index fd63b06d9ef1..11aa917629ac 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1765,7 +1765,7 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 	default:
 		return 0;
 	}
-	if (mesg.event == mdev->ofdev.dev.power.power_state.event)
+	if (ms->phase == sleeping)
 		return 0;
 
 	scsi_block_requests(ms->host);
@@ -1780,8 +1780,6 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 	disable_irq(ms->meshintr);
 	set_mesh_power(ms, 0);
 
-	mdev->ofdev.dev.power.power_state = mesg;
-
 	return 0;
 }
 
@@ -1790,7 +1788,7 @@ static int mesh_resume(struct macio_dev *mdev)
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;
 
-	if (mdev->ofdev.dev.power.power_state.event == PM_EVENT_ON)
+	if (ms->phase != sleeping)
 		return 0;
 
 	set_mesh_power(ms, 1);
@@ -1801,8 +1799,6 @@ static int mesh_resume(struct macio_dev *mdev)
 	enable_irq(ms->meshintr);
 	scsi_unblock_requests(ms->host);
 
-	mdev->ofdev.dev.power.power_state.event = PM_EVENT_ON;
-
 	return 0;
 }
 

commit 3a2d5b700132f35401f1d9e22fe3c2cab02c2549
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 23 19:13:25 2008 +0100

    PM: Introduce PM_EVENT_HIBERNATE callback state
    
    During the last step of hibernation in the "platform" mode (with the
    help of ACPI) we use the suspend code, including the devices'
    ->suspend() methods, to prepare the system for entering the ACPI S4
    system sleep state.
    
    But at least for some devices the operations performed by the
    ->suspend() callback in that case must be different from its operations
    during regular suspend.
    
    For this reason, introduce the new PM event type PM_EVENT_HIBERNATE and
    pass it to the device drivers' ->suspend() methods during the last phase
    of hibernation, so that they can distinguish this case and handle it as
    appropriate.  Modify the drivers that handle PM_EVENT_SUSPEND in a
    special way and need to handle PM_EVENT_HIBERNATE in the same way.
    
    These changes are necessary to fix a hibernation regression related
    to the i915 driver (ref. http://lkml.org/lkml/2008/2/22/488).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Jeff Chua <jeff.chua.linux@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 651d09b08f2a..fd63b06d9ef1 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1759,6 +1759,7 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 
 	switch (mesg.event) {
 	case PM_EVENT_SUSPEND:
+	case PM_EVENT_HIBERNATE:
 	case PM_EVENT_FREEZE:
 		break;
 	default:

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 7470ff39ab22..651d09b08f2a 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1843,7 +1843,6 @@ static struct scsi_host_template mesh_template = {
 	.sg_tablesize			= SG_ALL,
 	.cmd_per_lun			= 2,
 	.use_clustering			= DISABLE_CLUSTERING,
-	.use_sg_chaining		= ENABLE_SG_CHAINING,
 };
 
 static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)

commit 9cb83c7529d929c00f37d821daed1942a1b20602
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Oct 16 11:24:32 2007 +0200

    [SCSI] add use_sg_chaining option to scsi_host_template
    
    This option is true if a low-level driver can support sg
    chaining. This will be removed eventually when all the drivers are
    converted to support sg chaining. q->max_phys_segments is set to
    SCSI_MAX_SG_SEGMENTS if false.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 651d09b08f2a..7470ff39ab22 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1843,6 +1843,7 @@ static struct scsi_host_template mesh_template = {
 	.sg_tablesize			= SG_ALL,
 	.cmd_per_lun			= 2,
 	.use_clustering			= DISABLE_CLUSTERING,
+	.use_sg_chaining		= ENABLE_SG_CHAINING,
 };
 
 static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)

commit f0002c4e1fe22d74a43d4ba3379257ee612e2724
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat May 26 13:07:28 2007 +0900

    [SCSI] mesh: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Jens Axboe <jens.axboe@oracle.com> did the for_each_sg cleanup.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index e64d1a19d8d7..651d09b08f2a 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -421,7 +421,7 @@ static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
 		for (i = 0; i < cmd->cmd_len; ++i)
 			printk(" %x", cmd->cmnd[i]);
 		printk(" use_sg=%d buffer=%p bufflen=%u\n",
-		       cmd->use_sg, cmd->request_buffer, cmd->request_bufflen);
+		       scsi_sg_count(cmd), scsi_sglist(cmd), scsi_bufflen(cmd));
 	}
 #endif
 	if (ms->dma_started)
@@ -602,13 +602,16 @@ static void mesh_done(struct mesh_state *ms, int start_next)
 			cmd->result += (cmd->SCp.Message << 8);
 		if (DEBUG_TARGET(cmd)) {
 			printk(KERN_DEBUG "mesh_done: result = %x, data_ptr=%d, buflen=%d\n",
-			       cmd->result, ms->data_ptr, cmd->request_bufflen);
+			       cmd->result, ms->data_ptr, scsi_bufflen(cmd));
+#if 0
+			/* needs to use sg? */
 			if ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12 || cmd->cmnd[0] == 3)
 			    && cmd->request_buffer != 0) {
 				unsigned char *b = cmd->request_buffer;
 				printk(KERN_DEBUG "buffer = %x %x %x %x %x %x %x %x\n",
 				       b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
 			}
+#endif
 		}
 		cmd->SCp.this_residual -= ms->data_ptr;
 		mesh_completed(ms, cmd);
@@ -1265,15 +1268,18 @@ static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)
 	dcmds = ms->dma_cmds;
 	dtot = 0;
 	if (cmd) {
-		cmd->SCp.this_residual = cmd->request_bufflen;
-		if (cmd->use_sg > 0) {
-			int nseg;
+		int nseg;
+
+		cmd->SCp.this_residual = scsi_bufflen(cmd);
+
+		nseg = scsi_dma_map(cmd);
+		BUG_ON(nseg < 0);
+
+		if (nseg) {
 			total = 0;
-			scl = (struct scatterlist *) cmd->request_buffer;
 			off = ms->data_ptr;
-			nseg = pci_map_sg(ms->pdev, scl, cmd->use_sg,
-					  cmd->sc_data_direction);
-			for (i = 0; i <nseg; ++i, ++scl) {
+
+			scsi_for_each_sg(cmd, scl, nseg, i) {
 				u32 dma_addr = sg_dma_address(scl);
 				u32 dma_len = sg_dma_len(scl);
 				
@@ -1292,16 +1298,6 @@ static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)
 				dtot += dma_len - off;
 				off = 0;
 			}
-		} else if (ms->data_ptr < cmd->request_bufflen) {
-			dtot = cmd->request_bufflen - ms->data_ptr;
-			if (dtot > 0xffff)
-				panic("mesh: transfer size >= 64k");
-			st_le16(&dcmds->req_count, dtot);
-			/* XXX Use pci DMA API here ... */
-			st_le32(&dcmds->phy_addr,
-				virt_to_phys(cmd->request_buffer) + ms->data_ptr);
-			dcmds->xfer_status = 0;
-			++dcmds;
 		}
 	}
 	if (dtot == 0) {
@@ -1356,18 +1352,14 @@ static void halt_dma(struct mesh_state *ms)
 		dumplog(ms, ms->conn_tgt);
 		dumpslog(ms);
 #endif /* MESH_DBG */
-	} else if (cmd && cmd->request_bufflen != 0 &&
-		   ms->data_ptr > cmd->request_bufflen) {
+	} else if (cmd && scsi_bufflen(cmd) &&
+		   ms->data_ptr > scsi_bufflen(cmd)) {
 		printk(KERN_DEBUG "mesh: target %d overrun, "
 		       "data_ptr=%x total=%x goes_out=%d\n",
-		       ms->conn_tgt, ms->data_ptr, cmd->request_bufflen,
+		       ms->conn_tgt, ms->data_ptr, scsi_bufflen(cmd),
 		       ms->tgts[ms->conn_tgt].data_goes_out);
 	}
-	if (cmd->use_sg != 0) {
-		struct scatterlist *sg;
-		sg = (struct scatterlist *)cmd->request_buffer;
-		pci_unmap_sg(ms->pdev, sg, cmd->use_sg, cmd->sc_data_direction);
-	}
+	scsi_dma_unmap(cmd);
 	ms->dma_started = 0;
 }
 

commit 6ec129c3a2f8b38bc37e42348470ccfcb7460146
Merge: 01e73be3c8f2 b64ddf96456c
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Tue May 8 20:32:16 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (58 commits)
      [SCSI] zfcp: clear boxed flag on unit reopen.
      [SCSI] zfcp: clear adapter failed flag if an fsf request times out.
      [SCSI] zfcp: rework request ID management.
      [SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI
      [SCSI] zfcp: Locking for req_no and req_seq_no
      [SCSI] zfcp: print S_ID and D_ID with 3 bytes
      [SCSI] ipr: Use PCI-E reset API for new ipr adapter
      [SCSI] qla2xxx: Update version number to 8.01.07-k7.
      [SCSI] qla2xxx: Add MSI support.
      [SCSI] qla2xxx: Correct pci_set_msi() usage semantics.
      [SCSI] qla2xxx: Attempt to stop firmware only if it had been previously executed.
      [SCSI] qla2xxx: Honor NVRAM port-down-retry-count settings.
      [SCSI] qla2xxx: Error-out during probe() if we're unable to complete HBA initialization.
      [SCSI] zfcp: Stop system after memory corruption
      [SCSI] mesh: cleanup variable usage in interrupt handler
      [SCSI] megaraid: replace yield() with cond_resched()
      [SCSI] megaraid: fix warnings when CONFIG_PROC_FS=n
      [SCSI] aacraid: correct SUN products to README
      [SCSI] aacraid: superfluous adapter reset for IBM 8 series ServeRAID controllers
      [SCSI] aacraid: kexec fix (reset interrupt handler)
      ...

commit 2135be5f24ee6620ea6f2a594087d51b6a67ce7e
Author: Olaf Hering <olaf@aepfle.de>
Date:   Thu Apr 26 00:35:19 2007 -0700

    [SCSI] mesh: cleanup variable usage in interrupt handler
    
    _ convert void* to struct mesh_state*
    
    - remove unused irq argument from mesh_interrupt()
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 1fd3c7590d31..6f50a5b3e4ce 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -185,7 +185,7 @@ struct mesh_state {
  * Driver is too messy, we need a few prototypes...
  */
 static void mesh_done(struct mesh_state *ms, int start_next);
-static void mesh_interrupt(int irq, void *dev_id);
+static void mesh_interrupt(struct mesh_state *ms);
 static void cmd_complete(struct mesh_state *ms);
 static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd);
 static void halt_dma(struct mesh_state *ms);
@@ -466,7 +466,7 @@ static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
 				dlog(ms, "intr b4 arb, intr/exc/err/fc=%.8x",
 				     MKWORD(mr->interrupt, mr->exception,
 					    mr->error, mr->fifo_count));
-				mesh_interrupt(0, (void *)ms);
+				mesh_interrupt(ms);
 				if (ms->phase != arbitrating)
 					return;
 			}
@@ -504,7 +504,7 @@ static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
 		dlog(ms, "intr after disresel, intr/exc/err/fc=%.8x",
 		     MKWORD(mr->interrupt, mr->exception,
 			    mr->error, mr->fifo_count));
-		mesh_interrupt(0, (void *)ms);
+		mesh_interrupt(ms);
 		if (ms->phase != arbitrating)
 			return;
 		dlog(ms, "after intr after disresel, intr/exc/err/fc=%.8x",
@@ -1018,10 +1018,11 @@ static void handle_reset(struct mesh_state *ms)
 static irqreturn_t do_mesh_interrupt(int irq, void *dev_id)
 {
 	unsigned long flags;
-	struct Scsi_Host *dev = ((struct mesh_state *)dev_id)->host;
+	struct mesh_state *ms = dev_id;
+	struct Scsi_Host *dev = ms->host;
 	
 	spin_lock_irqsave(dev->host_lock, flags);
-	mesh_interrupt(irq, dev_id);
+	mesh_interrupt(ms);
 	spin_unlock_irqrestore(dev->host_lock, flags);
 	return IRQ_HANDLED;
 }
@@ -1661,9 +1662,8 @@ static int mesh_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
  * handler (do_mesh_interrupt) or by other functions in
  * exceptional circumstances
  */
-static void mesh_interrupt(int irq, void *dev_id)
+static void mesh_interrupt(struct mesh_state *ms)
 {
-	struct mesh_state *ms = (struct mesh_state *) dev_id;
 	volatile struct mesh_regs __iomem *mr = ms->mesh;
 	int intr;
 

commit 40cd3a4564ed6b7bc0279430120ca0e9b83cf486
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue May 1 13:54:02 2007 +1000

    [POWERPC] Rename get_property to of_get_property: drivers
    
    These are all the remaining instances of get_property.  Simple rename of
    get_property to of_get_property.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 1fd3c7590d31..cf3666d7d97a 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1947,7 +1947,7 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	       	ms->tgts[tgt].current_req = NULL;
        	}
 
-	if ((cfp = get_property(mesh, "clock-frequency", NULL)))
+	if ((cfp = of_get_property(mesh, "clock-frequency", NULL)))
        		ms->clk_freq = *cfp;
 	else {
        		printk(KERN_INFO "mesh: assuming 50MHz clock frequency\n");

commit b7696ee3c050a76a6cebccdbadfc93896b336e44
Author: Olaf Hering <olaf@aepfle.de>
Date:   Fri Oct 6 20:53:10 2006 +0200

    [PATCH] fix mesh compile errors after irq changes
    
    drivers/scsi/mesh.c:469: error: too many arguments to function 'mesh_interrupt'
    drivers/scsi/mesh.c:507: error: too many arguments to function 'mesh_interrupt'
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index c773e35dace7..1fd3c7590d31 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -466,7 +466,7 @@ static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
 				dlog(ms, "intr b4 arb, intr/exc/err/fc=%.8x",
 				     MKWORD(mr->interrupt, mr->exception,
 					    mr->error, mr->fifo_count));
-				mesh_interrupt(0, (void *)ms, NULL);
+				mesh_interrupt(0, (void *)ms);
 				if (ms->phase != arbitrating)
 					return;
 			}
@@ -504,7 +504,7 @@ static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
 		dlog(ms, "intr after disresel, intr/exc/err/fc=%.8x",
 		     MKWORD(mr->interrupt, mr->exception,
 			    mr->error, mr->fifo_count));
-		mesh_interrupt(0, (void *)ms, NULL);
+		mesh_interrupt(0, (void *)ms);
 		if (ms->phase != arbitrating)
 			return;
 		dlog(ms, "after intr after disresel, intr/exc/err/fc=%.8x",

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 683fc7ae4b8f..c773e35dace7 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -185,7 +185,7 @@ struct mesh_state {
  * Driver is too messy, we need a few prototypes...
  */
 static void mesh_done(struct mesh_state *ms, int start_next);
-static void mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs);
+static void mesh_interrupt(int irq, void *dev_id);
 static void cmd_complete(struct mesh_state *ms);
 static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd);
 static void halt_dma(struct mesh_state *ms);
@@ -1015,13 +1015,13 @@ static void handle_reset(struct mesh_state *ms)
 	out_8(&mr->sequence, SEQ_ENBRESEL);
 }
 
-static irqreturn_t do_mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+static irqreturn_t do_mesh_interrupt(int irq, void *dev_id)
 {
 	unsigned long flags;
 	struct Scsi_Host *dev = ((struct mesh_state *)dev_id)->host;
 	
 	spin_lock_irqsave(dev->host_lock, flags);
-	mesh_interrupt(irq, dev_id, ptregs);
+	mesh_interrupt(irq, dev_id);
 	spin_unlock_irqrestore(dev->host_lock, flags);
 	return IRQ_HANDLED;
 }
@@ -1661,7 +1661,7 @@ static int mesh_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
  * handler (do_mesh_interrupt) or by other functions in
  * exceptional circumstances
  */
-static void mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+static void mesh_interrupt(int irq, void *dev_id)
 {
 	struct mesh_state *ms = (struct mesh_state *) dev_id;
 	volatile struct mesh_regs __iomem *mr = ms->mesh;

commit 8b4b8a24e4e49dc9fe36d4d079f6d2c23f942b03
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Aug 14 23:11:03 2006 -0700

    fix broken/dubious driver suspend() methods
    
    Small driver suspend() fixes in preparation for the PRETHAW events:
    
     - Only compare message events for equality against PM_EVENT_* codes;
       not against integers, or using greater/less-than comparisons.
       (PM_EVENT_* should really become a __bitwise thing.)
    
     - Explicitly test for SUSPEND events (rather than not-something-else)
       before suspending devices.
    
     - Removes more of the confusion between a pm_message_t (wraps event code)
       and a "state" ... suspend() originally took a target system state.
    
    These updates are correct and appropriate even without new PM_EVENT codes.
    
    benh: "I think in the Mesh case, we should handle the freeze case as well or
    we might get wild DMA."
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Greg KH <greg@kroah.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 592b52afe658..683fc7ae4b8f 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1756,16 +1756,23 @@ static void set_mesh_power(struct mesh_state *ms, int state)
 		pmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 0);
 		msleep(10);
 	}
-}			
+}
 
 
 #ifdef CONFIG_PM
-static int mesh_suspend(struct macio_dev *mdev, pm_message_t state)
+static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 {
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;
 
-	if (state.event == mdev->ofdev.dev.power.power_state.event || state.event < 2)
+	switch (mesg.event) {
+	case PM_EVENT_SUSPEND:
+	case PM_EVENT_FREEZE:
+		break;
+	default:
+		return 0;
+	}
+	if (mesg.event == mdev->ofdev.dev.power.power_state.event)
 		return 0;
 
 	scsi_block_requests(ms->host);
@@ -1780,7 +1787,7 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t state)
 	disable_irq(ms->meshintr);
 	set_mesh_power(ms, 0);
 
-	mdev->ofdev.dev.power.power_state = state;
+	mdev->ofdev.dev.power.power_state = mesg;
 
 	return 0;
 }

commit 57cad8084e0837e0f2c97da789ec9b3f36809be9
Merge: cb18bd40030c 49b1e3ea19b1
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Aug 1 10:37:25 2006 +1000

    Merge branch 'merge'

commit 294ef16a2ee34d0d94aa63616f7552d3bc66c982
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Jul 12 15:40:51 2006 +1000

    [POWERPC] scsi: Constify & voidify get_property()
    
    Now that get_property() returns a void *, there's no need to cast its
    return value. Also, treat the return value as const, so we can
    constify get_property later.
    
    powerpc-specific scsi driver changes.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index c88717727be8..cee9758b9278 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1850,7 +1850,8 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 {
 	struct device_node *mesh = macio_get_of_node(mdev);
 	struct pci_dev* pdev = macio_get_pci_dev(mdev);
-	int tgt, *cfp, minper;
+	int tgt, minper;
+	const int *cfp;
 	struct mesh_state *ms;
 	struct Scsi_Host *mesh_host;
 	void *dma_cmd_space;
@@ -1939,7 +1940,7 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	       	ms->tgts[tgt].current_req = NULL;
        	}
 
-	if ((cfp = (int *) get_property(mesh, "clock-frequency", NULL)))
+	if ((cfp = get_property(mesh, "clock-frequency", NULL)))
        		ms->clk_freq = *cfp;
 	else {
        		printk(KERN_INFO "mesh: assuming 50MHz clock frequency\n");

commit 79bd3f8563a275d1d068bbb9189a746dc6e96f3e
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jul 14 10:29:34 2006 +0200

    [SCSI] More buffer->request_buffer changes
    
    Seem like quite a few splipped through the cracks.  Here's a patch to
    update all references I could find:
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index c88717727be8..5572981a9f92 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1268,7 +1268,7 @@ static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)
 		if (cmd->use_sg > 0) {
 			int nseg;
 			total = 0;
-			scl = (struct scatterlist *) cmd->buffer;
+			scl = (struct scatterlist *) cmd->request_buffer;
 			off = ms->data_ptr;
 			nseg = pci_map_sg(ms->pdev, scl, cmd->use_sg,
 					  cmd->sc_data_direction);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index f852421002ef..c88717727be8 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -18,7 +18,6 @@
  * - retry arbitration if lost (unless higher levels do this for us)
  * - power down the chip when no device is detected
  */
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>

commit e8222502ee6157e2713da9e0792c21f4ad458d50
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Mar 28 23:15:54 2006 +1100

    [PATCH] powerpc: Kill _machine and hard-coded platform numbers
    
    This removes statically assigned platform numbers and reworks the
    powerpc platform probe code to use a better mechanism.  With this,
    board support files can simply declare a new machine type with a
    macro, and implement a probe() function that uses the flattened
    device-tree to detect if they apply for a given machine.
    
    We now have a machine_is() macro that replaces the comparisons of
    _machine with the various PLATFORM_* constants.  This commit also
    changes various drivers to use the new macro instead of looking at
    _machine.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index d6d2125f9044..f852421002ef 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1748,7 +1748,7 @@ static int mesh_host_reset(struct scsi_cmnd *cmd)
 
 static void set_mesh_power(struct mesh_state *ms, int state)
 {
-	if (_machine != _MACH_Pmac)
+	if (!machine_is(powermac))
 		return;
 	if (state) {
 		pmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 1);

commit cc5d0189b9ba95260857a5018a1c2fef90008507
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 13 18:01:21 2005 +1100

    [PATCH] powerpc: Remove device_node addrs/n_addr
    
    The pre-parsed addrs/n_addrs fields in struct device_node are finally
    gone. Remove the dodgy heuristics that did that parsing at boot and
    remove the fields themselves since we now have a good replacement with
    the new OF parsing code. This patch also fixes a bunch of drivers to use
    the new code instead, so that at least pmac32, pseries, iseries and g5
    defconfigs build.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index bdccf73cf9fe..d6d2125f9044 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1869,7 +1869,8 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 
 	if (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {
        		printk(KERN_ERR "mesh: expected 2 addrs and 2 intrs"
-	       	       " (got %d,%d)\n", mesh->n_addrs, mesh->n_intrs);
+	       	       " (got %d,%d)\n", macio_resource_count(mdev),
+		       macio_irq_count(mdev));
 		return -ENODEV;
 	}
 

commit 33430dc593f866f5d67ff6a6213b6dd6d7ea3ce1
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Oct 30 15:02:20 2005 -0800

    [PATCH] Typo fix: explictly -> explicitly
    
    (akpm: I don't do typo patches, but one of these is in a printk string)
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index b235556b7b65..bdccf73cf9fe 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -730,7 +730,7 @@ static void start_phase(struct mesh_state *ms)
 		 * issue a SEQ_MSGOUT to get the mesh to drop ACK.
 		 */
 		if ((in_8(&mr->bus_status0) & BS0_ATN) == 0) {
-			dlog(ms, "bus0 was %.2x explictly asserting ATN", mr->bus_status0);
+			dlog(ms, "bus0 was %.2x explicitly asserting ATN", mr->bus_status0);
 			out_8(&mr->bus_status0, BS0_ATN); /* explicit ATN */
 			mesh_flush_io(mr);
 			udelay(1);

commit 0cdc82ee1ae36c1ae4631fc3a782faeb0b90df38
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Sep 22 21:44:09 2005 -0700

    [PATCH] mesh scsi: fix error handling
    
    The PowerMac mesh SCSI driver had some missing error handling which would
    trigger warnings due to lack of handling of return value from
    scsi_add_host.  This fixes it.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index a4857db4f9b8..b235556b7b65 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1959,22 +1959,35 @@ static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 	/* Set it up */
        	mesh_init(ms);
 
-	/* XXX FIXME: error should be fatal */
-       	if (request_irq(ms->meshintr, do_mesh_interrupt, 0, "MESH", ms))
+	/* Request interrupt */
+       	if (request_irq(ms->meshintr, do_mesh_interrupt, 0, "MESH", ms)) {
 	       	printk(KERN_ERR "MESH: can't get irq %d\n", ms->meshintr);
+		goto out_shutdown;
+	}
 
-	/* XXX FIXME: handle failure */
-	scsi_add_host(mesh_host, &mdev->ofdev.dev);
+	/* Add scsi host & scan */
+	if (scsi_add_host(mesh_host, &mdev->ofdev.dev))
+		goto out_release_irq;
 	scsi_scan_host(mesh_host);
 
 	return 0;
 
-out_unmap:
+ out_release_irq:
+	free_irq(ms->meshintr, ms);
+ out_shutdown:
+	/* shutdown & reset bus in case of error or macos can be confused
+	 * at reboot if the bus was set to synchronous mode already
+	 */
+	mesh_shutdown(mdev);
+	set_mesh_power(ms, 0);
+	pci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,
+			    ms->dma_cmd_space, ms->dma_cmd_bus);
+ out_unmap:
 	iounmap(ms->dma);
 	iounmap(ms->mesh);
-out_free:
+ out_free:
 	scsi_host_put(mesh_host);
-out_release:
+ out_release:
 	macio_release_resources(mdev);
 
 	return -ENODEV;
@@ -2001,7 +2014,7 @@ static int mesh_remove(struct macio_dev *mdev)
 
 	/* Free DMA commands memory */
 	pci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,
-			  ms->dma_cmd_space, ms->dma_cmd_bus);
+			    ms->dma_cmd_space, ms->dma_cmd_bus);
 
 	/* Release memory resources */
 	macio_release_resources(mdev);

commit ca078bae813dd46c0f9b102fdfb4a3384641ff48
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Sep 3 15:56:57 2005 -0700

    [PATCH] swsusp: switch pm_message_t to struct
    
    This adds type-checking to pm_message_t, so that people can't confuse it
    with int or u32.  It also allows us to fix "disk yoyo" during suspend (disk
    spinning down/up/down).
    
    [We've tried that before; since that cpufreq problems were fixed and I've
    tried make allyes config and fixed resulting damage.]
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index ff1933298da6..a4857db4f9b8 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1766,7 +1766,7 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t state)
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;
 
-	if (state == mdev->ofdev.dev.power.power_state || state < 2)
+	if (state.event == mdev->ofdev.dev.power.power_state.event || state.event < 2)
 		return 0;
 
 	scsi_block_requests(ms->host);
@@ -1791,7 +1791,7 @@ static int mesh_resume(struct macio_dev *mdev)
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;
 
-	if (mdev->ofdev.dev.power.power_state == 0)
+	if (mdev->ofdev.dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
 	set_mesh_power(ms, 1);
@@ -1802,7 +1802,7 @@ static int mesh_resume(struct macio_dev *mdev)
 	enable_irq(ms->meshintr);
 	scsi_unblock_requests(ms->host);
 
-	mdev->ofdev.dev.power.power_state = 0;
+	mdev->ofdev.dev.power.power_state.event = PM_EVENT_ON;
 
 	return 0;
 }

commit 5e6557722e69840506eb8bc5a1edcdb4e447a917
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Wed Jul 6 15:44:41 2005 -0400

    [PATCH] openfirmware: generate device table for userspace
    
    This converts the usage of struct of_match to struct of_device_id,
    similar to pci_device_id.  This allows a device table to be generated,
    which can be parsed by depmod(8) to generate a map file for module
    loading.
    
    In order for hotplug to work with macio devices, patches to
    module-init-tools and hotplug must be applied.  Those patches are
    available at:
    
     ftp://ftp.suse.com/pub/people/jeffm/linux/macio-hotplug/
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index b05737ae5eff..ff1933298da6 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1847,7 +1847,7 @@ static struct scsi_host_template mesh_template = {
 	.use_clustering			= DISABLE_CLUSTERING,
 };
 
-static int mesh_probe(struct macio_dev *mdev, const struct of_match *match)
+static int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)
 {
 	struct device_node *mesh = macio_get_of_node(mdev);
 	struct pci_dev* pdev = macio_get_pci_dev(mdev);
@@ -2012,20 +2012,18 @@ static int mesh_remove(struct macio_dev *mdev)
 }
 
 
-static struct of_match mesh_match[] = 
+static struct of_device_id mesh_match[] = 
 {
 	{
 	.name 		= "mesh",
-	.type		= OF_ANY_MATCH,
-	.compatible	= OF_ANY_MATCH
 	},
 	{
-	.name 		= OF_ANY_MATCH,
 	.type		= "scsi",
 	.compatible	= "chrp,mesh0"
 	},
 	{},
 };
+MODULE_DEVICE_TABLE (of, mesh_match);
 
 static struct macio_driver mesh_driver = 
 {

commit df0ae2497ddefd72a87f3a3b34ff32455d7d4ae0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:57:14 2005 -0400

    [SCSI] allow sleeping in ->eh_host_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index f6da46d672f1..b05737ae5eff 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1715,9 +1715,12 @@ static int mesh_host_reset(struct scsi_cmnd *cmd)
 	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
 	volatile struct mesh_regs __iomem *mr = ms->mesh;
 	volatile struct dbdma_regs __iomem *md = ms->dma;
+	unsigned long flags;
 
 	printk(KERN_DEBUG "mesh_host_reset\n");
 
+	spin_lock_irqsave(ms->host->host_lock, flags);
+
 	/* Reset the controller & dbdma channel */
 	out_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);	/* stop dma */
 	out_8(&mr->exception, 0xff);	/* clear all exception bits */
@@ -1739,6 +1742,7 @@ static int mesh_host_reset(struct scsi_cmnd *cmd)
 	/* Complete pending commands */
 	handle_reset(ms);
 	
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
 	return SUCCESS;
 }
 

commit e5378ca8c0ab684bd9339dc6827dd5a042f9e6fc
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Apr 16 15:25:29 2005 -0700

    [PATCH] fix u32 vs. pm_message_t in drivers/mmc,mtd,scsi
    
    This fixes u32 vs.  pm_message_t in drivers/mmc, drivers/mtd and
    drivers/scsi.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index 85f3a74ac421..f6da46d672f1 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1757,7 +1757,7 @@ static void set_mesh_power(struct mesh_state *ms, int state)
 
 
 #ifdef CONFIG_PM
-static int mesh_suspend(struct macio_dev *mdev, u32 state)
+static int mesh_suspend(struct macio_dev *mdev, pm_message_t state)
 {
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
new file mode 100644
index 000000000000..85f3a74ac421
--- /dev/null
+++ b/drivers/scsi/mesh.c
@@ -0,0 +1,2062 @@
+/*
+ * SCSI low-level driver for the MESH (Macintosh Enhanced SCSI Hardware)
+ * bus adaptor found on Power Macintosh computers.
+ * We assume the MESH is connected to a DBDMA (descriptor-based DMA)
+ * controller.
+ *
+ * Paul Mackerras, August 1996.
+ * Copyright (C) 1996 Paul Mackerras.
+ *
+ * Apr. 21 2002  - BenH		Rework bus reset code for new error handler
+ *                              Add delay after initial bus reset
+ *                              Add module parameters
+ *
+ * Sep. 27 2003  - BenH		Move to new driver model, fix some write posting
+ *				issues
+ * To do:
+ * - handle aborts correctly
+ * - retry arbitration if lost (unless higher levels do this for us)
+ * - power down the chip when no device is detected
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/spinlock.h>
+#include <asm/dbdma.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/prom.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/hydra.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/pmac_feature.h>
+#include <asm/pci-bridge.h>
+#include <asm/macio.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+
+#include "mesh.h"
+
+#if 1
+#undef KERN_DEBUG
+#define KERN_DEBUG KERN_WARNING
+#endif
+
+MODULE_AUTHOR("Paul Mackerras (paulus@samba.org)");
+MODULE_DESCRIPTION("PowerMac MESH SCSI driver");
+MODULE_LICENSE("GPL");
+
+static int sync_rate = CONFIG_SCSI_MESH_SYNC_RATE;
+static int sync_targets = 0xff;
+static int resel_targets = 0xff;
+static int debug_targets = 0;	/* print debug for these targets */
+static int init_reset_delay = CONFIG_SCSI_MESH_RESET_DELAY_MS;
+
+module_param(sync_rate, int, 0);
+MODULE_PARM_DESC(sync_rate, "Synchronous rate (0..10, 0=async)");
+module_param(sync_targets, int, 0);
+MODULE_PARM_DESC(sync_targets, "Bitmask of targets allowed to set synchronous");
+module_param(resel_targets, int, 0);
+MODULE_PARM_DESC(resel_targets, "Bitmask of targets allowed to set disconnect");
+module_param(debug_targets, int, 0644);
+MODULE_PARM_DESC(debug_targets, "Bitmask of debugged targets");
+module_param(init_reset_delay, int, 0);
+MODULE_PARM_DESC(init_reset_delay, "Initial bus reset delay (0=no reset)");
+
+static int mesh_sync_period = 100;
+static int mesh_sync_offset = 0;
+static unsigned char use_active_neg = 0;  /* bit mask for SEQ_ACTIVE_NEG if used */
+
+#define ALLOW_SYNC(tgt)		((sync_targets >> (tgt)) & 1)
+#define ALLOW_RESEL(tgt)	((resel_targets >> (tgt)) & 1)
+#define ALLOW_DEBUG(tgt)	((debug_targets >> (tgt)) & 1)
+#define DEBUG_TARGET(cmd)	((cmd) && ALLOW_DEBUG((cmd)->device->id))
+
+#undef MESH_DBG
+#define N_DBG_LOG	50
+#define N_DBG_SLOG	20
+#define NUM_DBG_EVENTS	13
+#undef	DBG_USE_TB		/* bombs on 601 */
+
+struct dbglog {
+	char	*fmt;
+	u32	tb;
+	u8	phase;
+	u8	bs0;
+	u8	bs1;
+	u8	tgt;
+	int	d;
+};
+
+enum mesh_phase {
+	idle,
+	arbitrating,
+	selecting,
+	commanding,
+	dataing,
+	statusing,
+	busfreeing,
+	disconnecting,
+	reselecting,
+	sleeping
+};
+
+enum msg_phase {
+	msg_none,
+	msg_out,
+	msg_out_xxx,
+	msg_out_last,
+	msg_in,
+	msg_in_bad,
+};
+
+enum sdtr_phase {
+	do_sdtr,
+	sdtr_sent,
+	sdtr_done
+};
+
+struct mesh_target {
+	enum sdtr_phase sdtr_state;
+	int	sync_params;
+	int	data_goes_out;		/* guess as to data direction */
+	struct scsi_cmnd *current_req;
+	u32	saved_ptr;
+#ifdef MESH_DBG
+	int	log_ix;
+	int	n_log;
+	struct dbglog log[N_DBG_LOG];
+#endif
+};
+
+struct mesh_state {
+	volatile struct	mesh_regs __iomem *mesh;
+	int	meshintr;
+	volatile struct	dbdma_regs __iomem *dma;
+	int	dmaintr;
+	struct	Scsi_Host *host;
+	struct	mesh_state *next;
+	struct scsi_cmnd *request_q;
+	struct scsi_cmnd *request_qtail;
+	enum mesh_phase phase;		/* what we're currently trying to do */
+	enum msg_phase msgphase;
+	int	conn_tgt;		/* target we're connected to */
+	struct scsi_cmnd *current_req;		/* req we're currently working on */
+	int	data_ptr;
+	int	dma_started;
+	int	dma_count;
+	int	stat;
+	int	aborting;
+	int	expect_reply;
+	int	n_msgin;
+	u8	msgin[16];
+	int	n_msgout;
+	int	last_n_msgout;
+	u8	msgout[16];
+	struct dbdma_cmd *dma_cmds;	/* space for dbdma commands, aligned */
+	dma_addr_t dma_cmd_bus;
+	void	*dma_cmd_space;
+	int	dma_cmd_size;
+	int	clk_freq;
+	struct mesh_target tgts[8];
+	struct macio_dev *mdev;
+	struct pci_dev* pdev;
+#ifdef MESH_DBG
+	int	log_ix;
+	int	n_log;
+	struct dbglog log[N_DBG_SLOG];
+#endif
+};
+
+/*
+ * Driver is too messy, we need a few prototypes...
+ */
+static void mesh_done(struct mesh_state *ms, int start_next);
+static void mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs);
+static void cmd_complete(struct mesh_state *ms);
+static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd);
+static void halt_dma(struct mesh_state *ms);
+static void phase_mismatch(struct mesh_state *ms);
+
+
+/*
+ * Some debugging & logging routines
+ */
+
+#ifdef MESH_DBG
+
+static inline u32 readtb(void)
+{
+	u32 tb;
+
+#ifdef DBG_USE_TB
+	/* Beware: if you enable this, it will crash on 601s. */
+	asm ("mftb %0" : "=r" (tb) : );
+#else
+	tb = 0;
+#endif
+	return tb;
+}
+
+static void dlog(struct mesh_state *ms, char *fmt, int a)
+{
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+	struct dbglog *tlp, *slp;
+
+	tlp = &tp->log[tp->log_ix];
+	slp = &ms->log[ms->log_ix];
+	tlp->fmt = fmt;
+	tlp->tb = readtb();
+	tlp->phase = (ms->msgphase << 4) + ms->phase;
+	tlp->bs0 = ms->mesh->bus_status0;
+	tlp->bs1 = ms->mesh->bus_status1;
+	tlp->tgt = ms->conn_tgt;
+	tlp->d = a;
+	*slp = *tlp;
+	if (++tp->log_ix >= N_DBG_LOG)
+		tp->log_ix = 0;
+	if (tp->n_log < N_DBG_LOG)
+		++tp->n_log;
+	if (++ms->log_ix >= N_DBG_SLOG)
+		ms->log_ix = 0;
+	if (ms->n_log < N_DBG_SLOG)
+		++ms->n_log;
+}
+
+static void dumplog(struct mesh_state *ms, int t)
+{
+	struct mesh_target *tp = &ms->tgts[t];
+	struct dbglog *lp;
+	int i;
+
+	if (tp->n_log == 0)
+		return;
+	i = tp->log_ix - tp->n_log;
+	if (i < 0)
+		i += N_DBG_LOG;
+	tp->n_log = 0;
+	do {
+		lp = &tp->log[i];
+		printk(KERN_DEBUG "mesh log %d: bs=%.2x%.2x ph=%.2x ",
+		       t, lp->bs1, lp->bs0, lp->phase);
+#ifdef DBG_USE_TB
+		printk("tb=%10u ", lp->tb);
+#endif
+		printk(lp->fmt, lp->d);
+		printk("\n");
+		if (++i >= N_DBG_LOG)
+			i = 0;
+	} while (i != tp->log_ix);
+}
+
+static void dumpslog(struct mesh_state *ms)
+{
+	struct dbglog *lp;
+	int i;
+
+	if (ms->n_log == 0)
+		return;
+	i = ms->log_ix - ms->n_log;
+	if (i < 0)
+		i += N_DBG_SLOG;
+	ms->n_log = 0;
+	do {
+		lp = &ms->log[i];
+		printk(KERN_DEBUG "mesh log: bs=%.2x%.2x ph=%.2x t%d ",
+		       lp->bs1, lp->bs0, lp->phase, lp->tgt);
+#ifdef DBG_USE_TB
+		printk("tb=%10u ", lp->tb);
+#endif
+		printk(lp->fmt, lp->d);
+		printk("\n");
+		if (++i >= N_DBG_SLOG)
+			i = 0;
+	} while (i != ms->log_ix);
+}
+
+#else
+
+static inline void dlog(struct mesh_state *ms, char *fmt, int a)
+{}
+static inline void dumplog(struct mesh_state *ms, int tgt)
+{}
+static inline void dumpslog(struct mesh_state *ms)
+{}
+
+#endif /* MESH_DBG */
+
+#define MKWORD(a, b, c, d)	(((a) << 24) + ((b) << 16) + ((c) << 8) + (d))
+
+static void
+mesh_dump_regs(struct mesh_state *ms)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	volatile struct dbdma_regs __iomem *md = ms->dma;
+	int t;
+	struct mesh_target *tp;
+
+	printk(KERN_DEBUG "mesh: state at %p, regs at %p, dma at %p\n",
+	       ms, mr, md);
+	printk(KERN_DEBUG "    ct=%4x seq=%2x bs=%4x fc=%2x "
+	       "exc=%2x err=%2x im=%2x int=%2x sp=%2x\n",
+	       (mr->count_hi << 8) + mr->count_lo, mr->sequence,
+	       (mr->bus_status1 << 8) + mr->bus_status0, mr->fifo_count,
+	       mr->exception, mr->error, mr->intr_mask, mr->interrupt,
+	       mr->sync_params);
+	while(in_8(&mr->fifo_count))
+		printk(KERN_DEBUG " fifo data=%.2x\n",in_8(&mr->fifo));
+	printk(KERN_DEBUG "    dma stat=%x cmdptr=%x\n",
+	       in_le32(&md->status), in_le32(&md->cmdptr));
+	printk(KERN_DEBUG "    phase=%d msgphase=%d conn_tgt=%d data_ptr=%d\n",
+	       ms->phase, ms->msgphase, ms->conn_tgt, ms->data_ptr);
+	printk(KERN_DEBUG "    dma_st=%d dma_ct=%d n_msgout=%d\n",
+	       ms->dma_started, ms->dma_count, ms->n_msgout);
+	for (t = 0; t < 8; ++t) {
+		tp = &ms->tgts[t];
+		if (tp->current_req == NULL)
+			continue;
+		printk(KERN_DEBUG "    target %d: req=%p goes_out=%d saved_ptr=%d\n",
+		       t, tp->current_req, tp->data_goes_out, tp->saved_ptr);
+	}
+}
+
+
+/*
+ * Flush write buffers on the bus path to the mesh
+ */
+static inline void mesh_flush_io(volatile struct mesh_regs __iomem *mr)
+{
+	(void)in_8(&mr->mesh_id);
+}
+
+
+/*
+ * Complete a SCSI command
+ */
+static void mesh_completed(struct mesh_state *ms, struct scsi_cmnd *cmd)
+{
+	(*cmd->scsi_done)(cmd);
+}
+
+
+/* Called with  meshinterrupt disabled, initialize the chipset
+ * and eventually do the initial bus reset. The lock must not be
+ * held since we can schedule.
+ */
+static void mesh_init(struct mesh_state *ms)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	volatile struct dbdma_regs __iomem *md = ms->dma;
+
+	mesh_flush_io(mr);
+	udelay(100);
+
+	/* Reset controller */
+	out_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);	/* stop dma */
+	out_8(&mr->exception, 0xff);	/* clear all exception bits */
+	out_8(&mr->error, 0xff);	/* clear all error bits */
+	out_8(&mr->sequence, SEQ_RESETMESH);
+	mesh_flush_io(mr);
+	udelay(10);
+	out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	out_8(&mr->source_id, ms->host->this_id);
+	out_8(&mr->sel_timeout, 25);	/* 250ms */
+	out_8(&mr->sync_params, ASYNC_PARAMS);
+
+	if (init_reset_delay) {
+		printk(KERN_INFO "mesh: performing initial bus reset...\n");
+		
+		/* Reset bus */
+		out_8(&mr->bus_status1, BS1_RST);	/* assert RST */
+		mesh_flush_io(mr);
+		udelay(30);			/* leave it on for >= 25us */
+		out_8(&mr->bus_status1, 0);	/* negate RST */
+		mesh_flush_io(mr);
+
+		/* Wait for bus to come back */
+		msleep(init_reset_delay);
+	}
+	
+	/* Reconfigure controller */
+	out_8(&mr->interrupt, 0xff);	/* clear all interrupt bits */
+	out_8(&mr->sequence, SEQ_FLUSHFIFO);
+	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->sync_params, ASYNC_PARAMS);
+	out_8(&mr->sequence, SEQ_ENBRESEL);
+
+	ms->phase = idle;
+	ms->msgphase = msg_none;
+}
+
+
+static void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	int t, id;
+
+	id = cmd->device->id;
+	ms->current_req = cmd;
+	ms->tgts[id].data_goes_out = cmd->sc_data_direction == DMA_TO_DEVICE;
+	ms->tgts[id].current_req = cmd;
+
+#if 1
+	if (DEBUG_TARGET(cmd)) {
+		int i;
+		printk(KERN_DEBUG "mesh_start: %p ser=%lu tgt=%d cmd=",
+		       cmd, cmd->serial_number, id);
+		for (i = 0; i < cmd->cmd_len; ++i)
+			printk(" %x", cmd->cmnd[i]);
+		printk(" use_sg=%d buffer=%p bufflen=%u\n",
+		       cmd->use_sg, cmd->request_buffer, cmd->request_bufflen);
+	}
+#endif
+	if (ms->dma_started)
+		panic("mesh: double DMA start !\n");
+
+	ms->phase = arbitrating;
+	ms->msgphase = msg_none;
+	ms->data_ptr = 0;
+	ms->dma_started = 0;
+	ms->n_msgout = 0;
+	ms->last_n_msgout = 0;
+	ms->expect_reply = 0;
+	ms->conn_tgt = id;
+	ms->tgts[id].saved_ptr = 0;
+	ms->stat = DID_OK;
+	ms->aborting = 0;
+#ifdef MESH_DBG
+	ms->tgts[id].n_log = 0;
+	dlog(ms, "start cmd=%x", (int) cmd);
+#endif
+
+	/* Off we go */
+	dlog(ms, "about to arb, intr/exc/err/fc=%.8x",
+	     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
+	out_8(&mr->interrupt, INT_CMDDONE);
+	out_8(&mr->sequence, SEQ_ENBRESEL);
+	mesh_flush_io(mr);
+	udelay(1);
+
+	if (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {
+		/*
+		 * Some other device has the bus or is arbitrating for it -
+		 * probably a target which is about to reselect us.
+		 */
+		dlog(ms, "busy b4 arb, intr/exc/err/fc=%.8x",
+		     MKWORD(mr->interrupt, mr->exception,
+			    mr->error, mr->fifo_count));
+		for (t = 100; t > 0; --t) {
+			if ((in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) == 0)
+				break;
+			if (in_8(&mr->interrupt) != 0) {
+				dlog(ms, "intr b4 arb, intr/exc/err/fc=%.8x",
+				     MKWORD(mr->interrupt, mr->exception,
+					    mr->error, mr->fifo_count));
+				mesh_interrupt(0, (void *)ms, NULL);
+				if (ms->phase != arbitrating)
+					return;
+			}
+			udelay(1);
+		}
+		if (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {
+			/* XXX should try again in a little while */
+			ms->stat = DID_BUS_BUSY;
+			ms->phase = idle;
+			mesh_done(ms, 0);
+			return;
+		}
+	}
+
+	/*
+	 * Apparently the mesh has a bug where it will assert both its
+	 * own bit and the target's bit on the bus during arbitration.
+	 */
+	out_8(&mr->dest_id, mr->source_id);
+
+	/*
+	 * There appears to be a race with reselection sometimes,
+	 * where a target reselects us just as we issue the
+	 * arbitrate command.  It seems that then the arbitrate
+	 * command just hangs waiting for the bus to be free
+	 * without giving us a reselection exception.
+	 * The only way I have found to get it to respond correctly
+	 * is this: disable reselection before issuing the arbitrate
+	 * command, then after issuing it, if it looks like a target
+	 * is trying to reselect us, reset the mesh and then enable
+	 * reselection.
+	 */
+	out_8(&mr->sequence, SEQ_DISRESEL);
+	if (in_8(&mr->interrupt) != 0) {
+		dlog(ms, "intr after disresel, intr/exc/err/fc=%.8x",
+		     MKWORD(mr->interrupt, mr->exception,
+			    mr->error, mr->fifo_count));
+		mesh_interrupt(0, (void *)ms, NULL);
+		if (ms->phase != arbitrating)
+			return;
+		dlog(ms, "after intr after disresel, intr/exc/err/fc=%.8x",
+		     MKWORD(mr->interrupt, mr->exception,
+			    mr->error, mr->fifo_count));
+	}
+
+	out_8(&mr->sequence, SEQ_ARBITRATE);
+
+	for (t = 230; t > 0; --t) {
+		if (in_8(&mr->interrupt) != 0)
+			break;
+		udelay(1);
+	}
+	dlog(ms, "after arb, intr/exc/err/fc=%.8x",
+	     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
+	if (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)
+	    && (in_8(&mr->bus_status0) & BS0_IO)) {
+		/* looks like a reselection - try resetting the mesh */
+		dlog(ms, "resel? after arb, intr/exc/err/fc=%.8x",
+		     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
+		out_8(&mr->sequence, SEQ_RESETMESH);
+		mesh_flush_io(mr);
+		udelay(10);
+		out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+		out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+		out_8(&mr->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(mr);
+		for (t = 10; t > 0 && in_8(&mr->interrupt) == 0; --t)
+			udelay(1);
+		dlog(ms, "tried reset after arb, intr/exc/err/fc=%.8x",
+		     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
+#ifndef MESH_MULTIPLE_HOSTS
+		if (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)
+		    && (in_8(&mr->bus_status0) & BS0_IO)) {
+			printk(KERN_ERR "mesh: controller not responding"
+			       " to reselection!\n");
+			/*
+			 * If this is a target reselecting us, and the
+			 * mesh isn't responding, the higher levels of
+			 * the scsi code will eventually time out and
+			 * reset the bus.
+			 */
+		}
+#endif
+	}
+}
+
+/*
+ * Start the next command for a MESH.
+ * Should be called with interrupts disabled.
+ */
+static void mesh_start(struct mesh_state *ms)
+{
+	struct scsi_cmnd *cmd, *prev, *next;
+
+	if (ms->phase != idle || ms->current_req != NULL) {
+		printk(KERN_ERR "inappropriate mesh_start (phase=%d, ms=%p)",
+		       ms->phase, ms);
+		return;
+	}
+
+	while (ms->phase == idle) {
+		prev = NULL;
+		for (cmd = ms->request_q; ; cmd = (struct scsi_cmnd *) cmd->host_scribble) {
+			if (cmd == NULL)
+				return;
+			if (ms->tgts[cmd->device->id].current_req == NULL)
+				break;
+			prev = cmd;
+		}
+		next = (struct scsi_cmnd *) cmd->host_scribble;
+		if (prev == NULL)
+			ms->request_q = next;
+		else
+			prev->host_scribble = (void *) next;
+		if (next == NULL)
+			ms->request_qtail = prev;
+
+		mesh_start_cmd(ms, cmd);
+	}
+}
+
+static void mesh_done(struct mesh_state *ms, int start_next)
+{
+	struct scsi_cmnd *cmd;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+
+	cmd = ms->current_req;
+	ms->current_req = NULL;
+	tp->current_req = NULL;
+	if (cmd) {
+		cmd->result = (ms->stat << 16) + cmd->SCp.Status;
+		if (ms->stat == DID_OK)
+			cmd->result += (cmd->SCp.Message << 8);
+		if (DEBUG_TARGET(cmd)) {
+			printk(KERN_DEBUG "mesh_done: result = %x, data_ptr=%d, buflen=%d\n",
+			       cmd->result, ms->data_ptr, cmd->request_bufflen);
+			if ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12 || cmd->cmnd[0] == 3)
+			    && cmd->request_buffer != 0) {
+				unsigned char *b = cmd->request_buffer;
+				printk(KERN_DEBUG "buffer = %x %x %x %x %x %x %x %x\n",
+				       b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
+			}
+		}
+		cmd->SCp.this_residual -= ms->data_ptr;
+		mesh_completed(ms, cmd);
+	}
+	if (start_next) {
+		out_8(&ms->mesh->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(ms->mesh);
+		udelay(1);
+		ms->phase = idle;
+		mesh_start(ms);
+	}
+}
+
+static inline void add_sdtr_msg(struct mesh_state *ms)
+{
+	int i = ms->n_msgout;
+
+	ms->msgout[i] = EXTENDED_MESSAGE;
+	ms->msgout[i+1] = 3;
+	ms->msgout[i+2] = EXTENDED_SDTR;
+	ms->msgout[i+3] = mesh_sync_period/4;
+	ms->msgout[i+4] = (ALLOW_SYNC(ms->conn_tgt)? mesh_sync_offset: 0);
+	ms->n_msgout = i + 5;
+}
+
+static void set_sdtr(struct mesh_state *ms, int period, int offset)
+{
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	int v, tr;
+
+	tp->sdtr_state = sdtr_done;
+	if (offset == 0) {
+		/* asynchronous */
+		if (SYNC_OFF(tp->sync_params))
+			printk(KERN_INFO "mesh: target %d now asynchronous\n",
+			       ms->conn_tgt);
+		tp->sync_params = ASYNC_PARAMS;
+		out_8(&mr->sync_params, ASYNC_PARAMS);
+		return;
+	}
+	/*
+	 * We need to compute ceil(clk_freq * period / 500e6) - 2
+	 * without incurring overflow.
+	 */
+	v = (ms->clk_freq / 5000) * period;
+	if (v <= 250000) {
+		/* special case: sync_period == 5 * clk_period */
+		v = 0;
+		/* units of tr are 100kB/s */
+		tr = (ms->clk_freq + 250000) / 500000;
+	} else {
+		/* sync_period == (v + 2) * 2 * clk_period */
+		v = (v + 99999) / 100000 - 2;
+		if (v > 15)
+			v = 15;	/* oops */
+		tr = ((ms->clk_freq / (v + 2)) + 199999) / 200000;
+	}
+	if (offset > 15)
+		offset = 15;	/* can't happen */
+	tp->sync_params = SYNC_PARAMS(offset, v);
+	out_8(&mr->sync_params, tp->sync_params);
+	printk(KERN_INFO "mesh: target %d synchronous at %d.%d MB/s\n",
+	       ms->conn_tgt, tr/10, tr%10);
+}
+
+static void start_phase(struct mesh_state *ms)
+{
+	int i, seq, nb;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	volatile struct dbdma_regs __iomem *md = ms->dma;
+	struct scsi_cmnd *cmd = ms->current_req;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+
+	dlog(ms, "start_phase nmo/exc/fc/seq = %.8x",
+	     MKWORD(ms->n_msgout, mr->exception, mr->fifo_count, mr->sequence));
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	seq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);
+	switch (ms->msgphase) {
+	case msg_none:
+		break;
+
+	case msg_in:
+		out_8(&mr->count_hi, 0);
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGIN + seq);
+		ms->n_msgin = 0;
+		return;
+
+	case msg_out:
+		/*
+		 * To make sure ATN drops before we assert ACK for
+		 * the last byte of the message, we have to do the
+		 * last byte specially.
+		 */
+		if (ms->n_msgout <= 0) {
+			printk(KERN_ERR "mesh: msg_out but n_msgout=%d\n",
+			       ms->n_msgout);
+			mesh_dump_regs(ms);
+			ms->msgphase = msg_none;
+			break;
+		}
+		if (ALLOW_DEBUG(ms->conn_tgt)) {
+			printk(KERN_DEBUG "mesh: sending %d msg bytes:",
+			       ms->n_msgout);
+			for (i = 0; i < ms->n_msgout; ++i)
+				printk(" %x", ms->msgout[i]);
+			printk("\n");
+		}
+		dlog(ms, "msgout msg=%.8x", MKWORD(ms->n_msgout, ms->msgout[0],
+						ms->msgout[1], ms->msgout[2]));
+		out_8(&mr->count_hi, 0);
+		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+		mesh_flush_io(mr);
+		udelay(1);
+		/*
+		 * If ATN is not already asserted, we assert it, then
+		 * issue a SEQ_MSGOUT to get the mesh to drop ACK.
+		 */
+		if ((in_8(&mr->bus_status0) & BS0_ATN) == 0) {
+			dlog(ms, "bus0 was %.2x explictly asserting ATN", mr->bus_status0);
+			out_8(&mr->bus_status0, BS0_ATN); /* explicit ATN */
+			mesh_flush_io(mr);
+			udelay(1);
+			out_8(&mr->count_lo, 1);
+			out_8(&mr->sequence, SEQ_MSGOUT + seq);
+			out_8(&mr->bus_status0, 0); /* release explicit ATN */
+			dlog(ms,"hace: after explicit ATN bus0=%.2x",mr->bus_status0);
+		}
+		if (ms->n_msgout == 1) {
+			/*
+			 * We can't issue the SEQ_MSGOUT without ATN
+			 * until the target has asserted REQ.  The logic
+			 * in cmd_complete handles both situations:
+			 * REQ already asserted or not.
+			 */
+			cmd_complete(ms);
+		} else {
+			out_8(&mr->count_lo, ms->n_msgout - 1);
+			out_8(&mr->sequence, SEQ_MSGOUT + seq);
+			for (i = 0; i < ms->n_msgout - 1; ++i)
+				out_8(&mr->fifo, ms->msgout[i]);
+		}
+		return;
+
+	default:
+		printk(KERN_ERR "mesh bug: start_phase msgphase=%d\n",
+		       ms->msgphase);
+	}
+
+	switch (ms->phase) {
+	case selecting:
+		out_8(&mr->dest_id, ms->conn_tgt);
+		out_8(&mr->sequence, SEQ_SELECT + SEQ_ATN);
+		break;
+	case commanding:
+		out_8(&mr->sync_params, tp->sync_params);
+		out_8(&mr->count_hi, 0);
+		if (cmd) {
+			out_8(&mr->count_lo, cmd->cmd_len);
+			out_8(&mr->sequence, SEQ_COMMAND + seq);
+			for (i = 0; i < cmd->cmd_len; ++i)
+				out_8(&mr->fifo, cmd->cmnd[i]);
+		} else {
+			out_8(&mr->count_lo, 6);
+			out_8(&mr->sequence, SEQ_COMMAND + seq);
+			for (i = 0; i < 6; ++i)
+				out_8(&mr->fifo, 0);
+		}
+		break;
+	case dataing:
+		/* transfer data, if any */
+		if (!ms->dma_started) {
+			set_dma_cmds(ms, cmd);
+			out_le32(&md->cmdptr, virt_to_phys(ms->dma_cmds));
+			out_le32(&md->control, (RUN << 16) | RUN);
+			ms->dma_started = 1;
+		}
+		nb = ms->dma_count;
+		if (nb > 0xfff0)
+			nb = 0xfff0;
+		ms->dma_count -= nb;
+		ms->data_ptr += nb;
+		out_8(&mr->count_lo, nb);
+		out_8(&mr->count_hi, nb >> 8);
+		out_8(&mr->sequence, (tp->data_goes_out?
+				SEQ_DATAOUT: SEQ_DATAIN) + SEQ_DMA_MODE + seq);
+		break;
+	case statusing:
+		out_8(&mr->count_hi, 0);
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_STATUS + seq);
+		break;
+	case busfreeing:
+	case disconnecting:
+		out_8(&mr->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(mr);
+		udelay(1);
+		dlog(ms, "enbresel intr/exc/err/fc=%.8x",
+		     MKWORD(mr->interrupt, mr->exception, mr->error,
+			    mr->fifo_count));
+		out_8(&mr->sequence, SEQ_BUSFREE);
+		break;
+	default:
+		printk(KERN_ERR "mesh: start_phase called with phase=%d\n",
+		       ms->phase);
+		dumpslog(ms);
+	}
+
+}
+
+static inline void get_msgin(struct mesh_state *ms)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	int i, n;
+
+	n = mr->fifo_count;
+	if (n != 0) {
+		i = ms->n_msgin;
+		ms->n_msgin = i + n;
+		for (; n > 0; --n)
+			ms->msgin[i++] = in_8(&mr->fifo);
+	}
+}
+
+static inline int msgin_length(struct mesh_state *ms)
+{
+	int b, n;
+
+	n = 1;
+	if (ms->n_msgin > 0) {
+		b = ms->msgin[0];
+		if (b == 1) {
+			/* extended message */
+			n = ms->n_msgin < 2? 2: ms->msgin[1] + 2;
+		} else if (0x20 <= b && b <= 0x2f) {
+			/* 2-byte message */
+			n = 2;
+		}
+	}
+	return n;
+}
+
+static void reselected(struct mesh_state *ms)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	struct scsi_cmnd *cmd;
+	struct mesh_target *tp;
+	int b, t, prev;
+
+	switch (ms->phase) {
+	case idle:
+		break;
+	case arbitrating:
+		if ((cmd = ms->current_req) != NULL) {
+			/* put the command back on the queue */
+			cmd->host_scribble = (void *) ms->request_q;
+			if (ms->request_q == NULL)
+				ms->request_qtail = cmd;
+			ms->request_q = cmd;
+			tp = &ms->tgts[cmd->device->id];
+			tp->current_req = NULL;
+		}
+		break;
+	case busfreeing:
+		ms->phase = reselecting;
+		mesh_done(ms, 0);
+		break;
+	case disconnecting:
+		break;
+	default:
+		printk(KERN_ERR "mesh: reselected in phase %d/%d tgt %d\n",
+		       ms->msgphase, ms->phase, ms->conn_tgt);
+		dumplog(ms, ms->conn_tgt);
+		dumpslog(ms);
+	}
+
+	if (ms->dma_started) {
+		printk(KERN_ERR "mesh: reselected with DMA started !\n");
+		halt_dma(ms);
+	}
+	ms->current_req = NULL;
+	ms->phase = dataing;
+	ms->msgphase = msg_in;
+	ms->n_msgout = 0;
+	ms->last_n_msgout = 0;
+	prev = ms->conn_tgt;
+
+	/*
+	 * We seem to get abortive reselections sometimes.
+	 */
+	while ((in_8(&mr->bus_status1) & BS1_BSY) == 0) {
+		static int mesh_aborted_resels;
+		mesh_aborted_resels++;
+		out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+		mesh_flush_io(mr);
+		udelay(1);
+		out_8(&mr->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(mr);
+		udelay(5);
+		dlog(ms, "extra resel err/exc/fc = %.6x",
+		     MKWORD(0, mr->error, mr->exception, mr->fifo_count));
+	}
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->sequence, SEQ_ENBRESEL);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->sync_params, ASYNC_PARAMS);
+
+	/*
+	 * Find out who reselected us.
+	 */
+	if (in_8(&mr->fifo_count) == 0) {
+		printk(KERN_ERR "mesh: reselection but nothing in fifo?\n");
+		ms->conn_tgt = ms->host->this_id;
+		goto bogus;
+	}
+	/* get the last byte in the fifo */
+	do {
+		b = in_8(&mr->fifo);
+		dlog(ms, "reseldata %x", b);
+	} while (in_8(&mr->fifo_count));
+	for (t = 0; t < 8; ++t)
+		if ((b & (1 << t)) != 0 && t != ms->host->this_id)
+			break;
+	if (b != (1 << t) + (1 << ms->host->this_id)) {
+		printk(KERN_ERR "mesh: bad reselection data %x\n", b);
+		ms->conn_tgt = ms->host->this_id;
+		goto bogus;
+	}
+
+
+	/*
+	 * Set up to continue with that target's transfer.
+	 */
+	ms->conn_tgt = t;
+	tp = &ms->tgts[t];
+	out_8(&mr->sync_params, tp->sync_params);
+	if (ALLOW_DEBUG(t)) {
+		printk(KERN_DEBUG "mesh: reselected by target %d\n", t);
+		printk(KERN_DEBUG "mesh: saved_ptr=%x goes_out=%d cmd=%p\n",
+		       tp->saved_ptr, tp->data_goes_out, tp->current_req);
+	}
+	ms->current_req = tp->current_req;
+	if (tp->current_req == NULL) {
+		printk(KERN_ERR "mesh: reselected by tgt %d but no cmd!\n", t);
+		goto bogus;
+	}
+	ms->data_ptr = tp->saved_ptr;
+	dlog(ms, "resel prev tgt=%d", prev);
+	dlog(ms, "resel err/exc=%.4x", MKWORD(0, 0, mr->error, mr->exception));
+	start_phase(ms);
+	return;
+
+bogus:
+	dumplog(ms, ms->conn_tgt);
+	dumpslog(ms);
+	ms->data_ptr = 0;
+	ms->aborting = 1;
+	start_phase(ms);
+}
+
+static void do_abort(struct mesh_state *ms)
+{
+	ms->msgout[0] = ABORT;
+	ms->n_msgout = 1;
+	ms->aborting = 1;
+	ms->stat = DID_ABORT;
+	dlog(ms, "abort", 0);
+}
+
+static void handle_reset(struct mesh_state *ms)
+{
+	int tgt;
+	struct mesh_target *tp;
+	struct scsi_cmnd *cmd;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+
+	for (tgt = 0; tgt < 8; ++tgt) {
+		tp = &ms->tgts[tgt];
+		if ((cmd = tp->current_req) != NULL) {
+			cmd->result = DID_RESET << 16;
+			tp->current_req = NULL;
+			mesh_completed(ms, cmd);
+		}
+		ms->tgts[tgt].sdtr_state = do_sdtr;
+		ms->tgts[tgt].sync_params = ASYNC_PARAMS;
+	}
+	ms->current_req = NULL;
+	while ((cmd = ms->request_q) != NULL) {
+		ms->request_q = (struct scsi_cmnd *) cmd->host_scribble;
+		cmd->result = DID_RESET << 16;
+		mesh_completed(ms, cmd);
+	}
+	ms->phase = idle;
+	ms->msgphase = msg_none;
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	out_8(&mr->sequence, SEQ_FLUSHFIFO);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->sync_params, ASYNC_PARAMS);
+	out_8(&mr->sequence, SEQ_ENBRESEL);
+}
+
+static irqreturn_t do_mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+{
+	unsigned long flags;
+	struct Scsi_Host *dev = ((struct mesh_state *)dev_id)->host;
+	
+	spin_lock_irqsave(dev->host_lock, flags);
+	mesh_interrupt(irq, dev_id, ptregs);
+	spin_unlock_irqrestore(dev->host_lock, flags);
+	return IRQ_HANDLED;
+}
+
+static void handle_error(struct mesh_state *ms)
+{
+	int err, exc, count;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+
+	err = in_8(&mr->error);
+	exc = in_8(&mr->exception);
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	dlog(ms, "error err/exc/fc/cl=%.8x",
+	     MKWORD(err, exc, mr->fifo_count, mr->count_lo));
+	if (err & ERR_SCSIRESET) {
+		/* SCSI bus was reset */
+		printk(KERN_INFO "mesh: SCSI bus reset detected: "
+		       "waiting for end...");
+		while ((in_8(&mr->bus_status1) & BS1_RST) != 0)
+			udelay(1);
+		printk("done\n");
+		handle_reset(ms);
+		/* request_q is empty, no point in mesh_start() */
+		return;
+	}
+	if (err & ERR_UNEXPDISC) {
+		/* Unexpected disconnect */
+		if (exc & EXC_RESELECTED) {
+			reselected(ms);
+			return;
+		}
+		if (!ms->aborting) {
+			printk(KERN_WARNING "mesh: target %d aborted\n",
+			       ms->conn_tgt);
+			dumplog(ms, ms->conn_tgt);
+			dumpslog(ms);
+		}
+		out_8(&mr->interrupt, INT_CMDDONE);
+		ms->stat = DID_ABORT;
+		mesh_done(ms, 1);
+		return;
+	}
+	if (err & ERR_PARITY) {
+		if (ms->msgphase == msg_in) {
+			printk(KERN_ERR "mesh: msg parity error, target %d\n",
+			       ms->conn_tgt);
+			ms->msgout[0] = MSG_PARITY_ERROR;
+			ms->n_msgout = 1;
+			ms->msgphase = msg_in_bad;
+			cmd_complete(ms);
+			return;
+		}
+		if (ms->stat == DID_OK) {
+			printk(KERN_ERR "mesh: parity error, target %d\n",
+			       ms->conn_tgt);
+			ms->stat = DID_PARITY;
+		}
+		count = (mr->count_hi << 8) + mr->count_lo;
+		if (count == 0) {
+			cmd_complete(ms);
+		} else {
+			/* reissue the data transfer command */
+			out_8(&mr->sequence, mr->sequence);
+		}
+		return;
+	}
+	if (err & ERR_SEQERR) {
+		if (exc & EXC_RESELECTED) {
+			/* This can happen if we issue a command to
+			   get the bus just after the target reselects us. */
+			static int mesh_resel_seqerr;
+			mesh_resel_seqerr++;
+			reselected(ms);
+			return;
+		}
+		if (exc == EXC_PHASEMM) {
+			static int mesh_phasemm_seqerr;
+			mesh_phasemm_seqerr++;
+			phase_mismatch(ms);
+			return;
+		}
+		printk(KERN_ERR "mesh: sequence error (err=%x exc=%x)\n",
+		       err, exc);
+	} else {
+		printk(KERN_ERR "mesh: unknown error %x (exc=%x)\n", err, exc);
+	}
+	mesh_dump_regs(ms);
+	dumplog(ms, ms->conn_tgt);
+	if (ms->phase > selecting && (in_8(&mr->bus_status1) & BS1_BSY)) {
+		/* try to do what the target wants */
+		do_abort(ms);
+		phase_mismatch(ms);
+		return;
+	}
+	ms->stat = DID_ERROR;
+	mesh_done(ms, 1);
+}
+
+static void handle_exception(struct mesh_state *ms)
+{
+	int exc;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+
+	exc = in_8(&mr->exception);
+	out_8(&mr->interrupt, INT_EXCEPTION | INT_CMDDONE);
+	if (exc & EXC_RESELECTED) {
+		static int mesh_resel_exc;
+		mesh_resel_exc++;
+		reselected(ms);
+	} else if (exc == EXC_ARBLOST) {
+		printk(KERN_DEBUG "mesh: lost arbitration\n");
+		ms->stat = DID_BUS_BUSY;
+		mesh_done(ms, 1);
+	} else if (exc == EXC_SELTO) {
+		/* selection timed out */
+		ms->stat = DID_BAD_TARGET;
+		mesh_done(ms, 1);
+	} else if (exc == EXC_PHASEMM) {
+		/* target wants to do something different:
+		   find out what it wants and do it. */
+		phase_mismatch(ms);
+	} else {
+		printk(KERN_ERR "mesh: can't cope with exception %x\n", exc);
+		mesh_dump_regs(ms);
+		dumplog(ms, ms->conn_tgt);
+		do_abort(ms);
+		phase_mismatch(ms);
+	}
+}
+
+static void handle_msgin(struct mesh_state *ms)
+{
+	int i, code;
+	struct scsi_cmnd *cmd = ms->current_req;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+
+	if (ms->n_msgin == 0)
+		return;
+	code = ms->msgin[0];
+	if (ALLOW_DEBUG(ms->conn_tgt)) {
+		printk(KERN_DEBUG "got %d message bytes:", ms->n_msgin);
+		for (i = 0; i < ms->n_msgin; ++i)
+			printk(" %x", ms->msgin[i]);
+		printk("\n");
+	}
+	dlog(ms, "msgin msg=%.8x",
+	     MKWORD(ms->n_msgin, code, ms->msgin[1], ms->msgin[2]));
+
+	ms->expect_reply = 0;
+	ms->n_msgout = 0;
+	if (ms->n_msgin < msgin_length(ms))
+		goto reject;
+	if (cmd)
+		cmd->SCp.Message = code;
+	switch (code) {
+	case COMMAND_COMPLETE:
+		break;
+	case EXTENDED_MESSAGE:
+		switch (ms->msgin[2]) {
+		case EXTENDED_MODIFY_DATA_POINTER:
+			ms->data_ptr += (ms->msgin[3] << 24) + ms->msgin[6]
+				+ (ms->msgin[4] << 16) + (ms->msgin[5] << 8);
+			break;
+		case EXTENDED_SDTR:
+			if (tp->sdtr_state != sdtr_sent) {
+				/* reply with an SDTR */
+				add_sdtr_msg(ms);
+				/* limit period to at least his value,
+				   offset to no more than his */
+				if (ms->msgout[3] < ms->msgin[3])
+					ms->msgout[3] = ms->msgin[3];
+				if (ms->msgout[4] > ms->msgin[4])
+					ms->msgout[4] = ms->msgin[4];
+				set_sdtr(ms, ms->msgout[3], ms->msgout[4]);
+				ms->msgphase = msg_out;
+			} else {
+				set_sdtr(ms, ms->msgin[3], ms->msgin[4]);
+			}
+			break;
+		default:
+			goto reject;
+		}
+		break;
+	case SAVE_POINTERS:
+		tp->saved_ptr = ms->data_ptr;
+		break;
+	case RESTORE_POINTERS:
+		ms->data_ptr = tp->saved_ptr;
+		break;
+	case DISCONNECT:
+		ms->phase = disconnecting;
+		break;
+	case ABORT:
+		break;
+	case MESSAGE_REJECT:
+		if (tp->sdtr_state == sdtr_sent)
+			set_sdtr(ms, 0, 0);
+		break;
+	case NOP:
+		break;
+	default:
+		if (IDENTIFY_BASE <= code && code <= IDENTIFY_BASE + 7) {
+			if (cmd == NULL) {
+				do_abort(ms);
+				ms->msgphase = msg_out;
+			} else if (code != cmd->device->lun + IDENTIFY_BASE) {
+				printk(KERN_WARNING "mesh: lun mismatch "
+				       "(%d != %d) on reselection from "
+				       "target %d\n", code - IDENTIFY_BASE,
+				       cmd->device->lun, ms->conn_tgt);
+			}
+			break;
+		}
+		goto reject;
+	}
+	return;
+
+ reject:
+	printk(KERN_WARNING "mesh: rejecting message from target %d:",
+	       ms->conn_tgt);
+	for (i = 0; i < ms->n_msgin; ++i)
+		printk(" %x", ms->msgin[i]);
+	printk("\n");
+	ms->msgout[0] = MESSAGE_REJECT;
+	ms->n_msgout = 1;
+	ms->msgphase = msg_out;
+}
+
+/*
+ * Set up DMA commands for transferring data.
+ */
+static void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)
+{
+	int i, dma_cmd, total, off, dtot;
+	struct scatterlist *scl;
+	struct dbdma_cmd *dcmds;
+
+	dma_cmd = ms->tgts[ms->conn_tgt].data_goes_out?
+		OUTPUT_MORE: INPUT_MORE;
+	dcmds = ms->dma_cmds;
+	dtot = 0;
+	if (cmd) {
+		cmd->SCp.this_residual = cmd->request_bufflen;
+		if (cmd->use_sg > 0) {
+			int nseg;
+			total = 0;
+			scl = (struct scatterlist *) cmd->buffer;
+			off = ms->data_ptr;
+			nseg = pci_map_sg(ms->pdev, scl, cmd->use_sg,
+					  cmd->sc_data_direction);
+			for (i = 0; i <nseg; ++i, ++scl) {
+				u32 dma_addr = sg_dma_address(scl);
+				u32 dma_len = sg_dma_len(scl);
+				
+				total += scl->length;
+				if (off >= dma_len) {
+					off -= dma_len;
+					continue;
+				}
+				if (dma_len > 0xffff)
+					panic("mesh: scatterlist element >= 64k");
+				st_le16(&dcmds->req_count, dma_len - off);
+				st_le16(&dcmds->command, dma_cmd);
+				st_le32(&dcmds->phy_addr, dma_addr + off);
+				dcmds->xfer_status = 0;
+				++dcmds;
+				dtot += dma_len - off;
+				off = 0;
+			}
+		} else if (ms->data_ptr < cmd->request_bufflen) {
+			dtot = cmd->request_bufflen - ms->data_ptr;
+			if (dtot > 0xffff)
+				panic("mesh: transfer size >= 64k");
+			st_le16(&dcmds->req_count, dtot);
+			/* XXX Use pci DMA API here ... */
+			st_le32(&dcmds->phy_addr,
+				virt_to_phys(cmd->request_buffer) + ms->data_ptr);
+			dcmds->xfer_status = 0;
+			++dcmds;
+		}
+	}
+	if (dtot == 0) {
+		/* Either the target has overrun our buffer,
+		   or the caller didn't provide a buffer. */
+		static char mesh_extra_buf[64];
+
+		dtot = sizeof(mesh_extra_buf);
+		st_le16(&dcmds->req_count, dtot);
+		st_le32(&dcmds->phy_addr, virt_to_phys(mesh_extra_buf));
+		dcmds->xfer_status = 0;
+		++dcmds;
+	}
+	dma_cmd += OUTPUT_LAST - OUTPUT_MORE;
+	st_le16(&dcmds[-1].command, dma_cmd);
+	memset(dcmds, 0, sizeof(*dcmds));
+	st_le16(&dcmds->command, DBDMA_STOP);
+	ms->dma_count = dtot;
+}
+
+static void halt_dma(struct mesh_state *ms)
+{
+	volatile struct dbdma_regs __iomem *md = ms->dma;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	struct scsi_cmnd *cmd = ms->current_req;
+	int t, nb;
+
+	if (!ms->tgts[ms->conn_tgt].data_goes_out) {
+		/* wait a little while until the fifo drains */
+		t = 50;
+		while (t > 0 && in_8(&mr->fifo_count) != 0
+		       && (in_le32(&md->status) & ACTIVE) != 0) {
+			--t;
+			udelay(1);
+		}
+	}
+	out_le32(&md->control, RUN << 16);	/* turn off RUN bit */
+	nb = (mr->count_hi << 8) + mr->count_lo;
+	dlog(ms, "halt_dma fc/count=%.6x",
+	     MKWORD(0, mr->fifo_count, 0, nb));
+	if (ms->tgts[ms->conn_tgt].data_goes_out)
+		nb += mr->fifo_count;
+	/* nb is the number of bytes not yet transferred
+	   to/from the target. */
+	ms->data_ptr -= nb;
+	dlog(ms, "data_ptr %x", ms->data_ptr);
+	if (ms->data_ptr < 0) {
+		printk(KERN_ERR "mesh: halt_dma: data_ptr=%d (nb=%d, ms=%p)\n",
+		       ms->data_ptr, nb, ms);
+		ms->data_ptr = 0;
+#ifdef MESH_DBG
+		dumplog(ms, ms->conn_tgt);
+		dumpslog(ms);
+#endif /* MESH_DBG */
+	} else if (cmd && cmd->request_bufflen != 0 &&
+		   ms->data_ptr > cmd->request_bufflen) {
+		printk(KERN_DEBUG "mesh: target %d overrun, "
+		       "data_ptr=%x total=%x goes_out=%d\n",
+		       ms->conn_tgt, ms->data_ptr, cmd->request_bufflen,
+		       ms->tgts[ms->conn_tgt].data_goes_out);
+	}
+	if (cmd->use_sg != 0) {
+		struct scatterlist *sg;
+		sg = (struct scatterlist *)cmd->request_buffer;
+		pci_unmap_sg(ms->pdev, sg, cmd->use_sg, cmd->sc_data_direction);
+	}
+	ms->dma_started = 0;
+}
+
+static void phase_mismatch(struct mesh_state *ms)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	int phase;
+
+	dlog(ms, "phasemm ch/cl/seq/fc=%.8x",
+	     MKWORD(mr->count_hi, mr->count_lo, mr->sequence, mr->fifo_count));
+	phase = in_8(&mr->bus_status0) & BS0_PHASE;
+	if (ms->msgphase == msg_out_xxx && phase == BP_MSGOUT) {
+		/* output the last byte of the message, without ATN */
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);
+		mesh_flush_io(mr);
+		udelay(1);
+		out_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);
+		ms->msgphase = msg_out_last;
+		return;
+	}
+
+	if (ms->msgphase == msg_in) {
+		get_msgin(ms);
+		if (ms->n_msgin)
+			handle_msgin(ms);
+	}
+
+	if (ms->dma_started)
+		halt_dma(ms);
+	if (mr->fifo_count) {
+		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+		mesh_flush_io(mr);
+		udelay(1);
+	}
+
+	ms->msgphase = msg_none;
+	switch (phase) {
+	case BP_DATAIN:
+		ms->tgts[ms->conn_tgt].data_goes_out = 0;
+		ms->phase = dataing;
+		break;
+	case BP_DATAOUT:
+		ms->tgts[ms->conn_tgt].data_goes_out = 1;
+		ms->phase = dataing;
+		break;
+	case BP_COMMAND:
+		ms->phase = commanding;
+		break;
+	case BP_STATUS:
+		ms->phase = statusing;
+		break;
+	case BP_MSGIN:
+		ms->msgphase = msg_in;
+		ms->n_msgin = 0;
+		break;
+	case BP_MSGOUT:
+		ms->msgphase = msg_out;
+		if (ms->n_msgout == 0) {
+			if (ms->aborting) {
+				do_abort(ms);
+			} else {
+				if (ms->last_n_msgout == 0) {
+					printk(KERN_DEBUG
+					       "mesh: no msg to repeat\n");
+					ms->msgout[0] = NOP;
+					ms->last_n_msgout = 1;
+				}
+				ms->n_msgout = ms->last_n_msgout;
+			}
+		}
+		break;
+	default:
+		printk(KERN_DEBUG "mesh: unknown scsi phase %x\n", phase);
+		ms->stat = DID_ERROR;
+		mesh_done(ms, 1);
+		return;
+	}
+
+	start_phase(ms);
+}
+
+static void cmd_complete(struct mesh_state *ms)
+{
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	struct scsi_cmnd *cmd = ms->current_req;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+	int seq, n, t;
+
+	dlog(ms, "cmd_complete fc=%x", mr->fifo_count);
+	seq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);
+	switch (ms->msgphase) {
+	case msg_out_xxx:
+		/* huh?  we expected a phase mismatch */
+		ms->n_msgin = 0;
+		ms->msgphase = msg_in;
+		/* fall through */
+
+	case msg_in:
+		/* should have some message bytes in fifo */
+		get_msgin(ms);
+		n = msgin_length(ms);
+		if (ms->n_msgin < n) {
+			out_8(&mr->count_lo, n - ms->n_msgin);
+			out_8(&mr->sequence, SEQ_MSGIN + seq);
+		} else {
+			ms->msgphase = msg_none;
+			handle_msgin(ms);
+			start_phase(ms);
+		}
+		break;
+
+	case msg_in_bad:
+		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+		mesh_flush_io(mr);
+		udelay(1);
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGIN + SEQ_ATN + use_active_neg);
+		break;
+
+	case msg_out:
+		/*
+		 * To get the right timing on ATN wrt ACK, we have
+		 * to get the MESH to drop ACK, wait until REQ gets
+		 * asserted, then drop ATN.  To do this we first
+		 * issue a SEQ_MSGOUT with ATN and wait for REQ,
+		 * then change the command to a SEQ_MSGOUT w/o ATN.
+		 * If we don't see REQ in a reasonable time, we
+		 * change the command to SEQ_MSGIN with ATN,
+		 * wait for the phase mismatch interrupt, then
+		 * issue the SEQ_MSGOUT without ATN.
+		 */
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg + SEQ_ATN);
+		t = 30;		/* wait up to 30us */
+		while ((in_8(&mr->bus_status0) & BS0_REQ) == 0 && --t >= 0)
+			udelay(1);
+		dlog(ms, "last_mbyte err/exc/fc/cl=%.8x",
+		     MKWORD(mr->error, mr->exception,
+			    mr->fifo_count, mr->count_lo));
+		if (in_8(&mr->interrupt) & (INT_ERROR | INT_EXCEPTION)) {
+			/* whoops, target didn't do what we expected */
+			ms->last_n_msgout = ms->n_msgout;
+			ms->n_msgout = 0;
+			if (in_8(&mr->interrupt) & INT_ERROR) {
+				printk(KERN_ERR "mesh: error %x in msg_out\n",
+				       in_8(&mr->error));
+				handle_error(ms);
+				return;
+			}
+			if (in_8(&mr->exception) != EXC_PHASEMM)
+				printk(KERN_ERR "mesh: exc %x in msg_out\n",
+				       in_8(&mr->exception));
+			else
+				printk(KERN_DEBUG "mesh: bs0=%x in msg_out\n",
+				       in_8(&mr->bus_status0));
+			handle_exception(ms);
+			return;
+		}
+		if (in_8(&mr->bus_status0) & BS0_REQ) {
+			out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);
+			mesh_flush_io(mr);
+			udelay(1);
+			out_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);
+			ms->msgphase = msg_out_last;
+		} else {
+			out_8(&mr->sequence, SEQ_MSGIN + use_active_neg + SEQ_ATN);
+			ms->msgphase = msg_out_xxx;
+		}
+		break;
+
+	case msg_out_last:
+		ms->last_n_msgout = ms->n_msgout;
+		ms->n_msgout = 0;
+		ms->msgphase = ms->expect_reply? msg_in: msg_none;
+		start_phase(ms);
+		break;
+
+	case msg_none:
+		switch (ms->phase) {
+		case idle:
+			printk(KERN_ERR "mesh: interrupt in idle phase?\n");
+			dumpslog(ms);
+			return;
+		case selecting:
+			dlog(ms, "Selecting phase at command completion",0);
+			ms->msgout[0] = IDENTIFY(ALLOW_RESEL(ms->conn_tgt),
+						 (cmd? cmd->device->lun: 0));
+			ms->n_msgout = 1;
+			ms->expect_reply = 0;
+			if (ms->aborting) {
+				ms->msgout[0] = ABORT;
+				ms->n_msgout++;
+			} else if (tp->sdtr_state == do_sdtr) {
+				/* add SDTR message */
+				add_sdtr_msg(ms);
+				ms->expect_reply = 1;
+				tp->sdtr_state = sdtr_sent;
+			}
+			ms->msgphase = msg_out;
+			/*
+			 * We need to wait for REQ before dropping ATN.
+			 * We wait for at most 30us, then fall back to
+			 * a scheme where we issue a SEQ_COMMAND with ATN,
+			 * which will give us a phase mismatch interrupt
+			 * when REQ does come, and then we send the message.
+			 */
+			t = 230;		/* wait up to 230us */
+			while ((in_8(&mr->bus_status0) & BS0_REQ) == 0) {
+				if (--t < 0) {
+					dlog(ms, "impatient for req", ms->n_msgout);
+					ms->msgphase = msg_none;
+					break;
+				}
+				udelay(1);
+			}
+			break;
+		case dataing:
+			if (ms->dma_count != 0) {
+				start_phase(ms);
+				return;
+			}
+			/*
+			 * We can get a phase mismatch here if the target
+			 * changes to the status phase, even though we have
+			 * had a command complete interrupt.  Then, if we
+			 * issue the SEQ_STATUS command, we'll get a sequence
+			 * error interrupt.  Which isn't so bad except that
+			 * occasionally the mesh actually executes the
+			 * SEQ_STATUS *as well as* giving us the sequence
+			 * error and phase mismatch exception.
+			 */
+			out_8(&mr->sequence, 0);
+			out_8(&mr->interrupt,
+			      INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+			halt_dma(ms);
+			break;
+		case statusing:
+			if (cmd) {
+				cmd->SCp.Status = mr->fifo;
+				if (DEBUG_TARGET(cmd))
+					printk(KERN_DEBUG "mesh: status is %x\n",
+					       cmd->SCp.Status);
+			}
+			ms->msgphase = msg_in;
+			break;
+		case busfreeing:
+			mesh_done(ms, 1);
+			return;
+		case disconnecting:
+			ms->current_req = NULL;
+			ms->phase = idle;
+			mesh_start(ms);
+			return;
+		default:
+			break;
+		}
+		++ms->phase;
+		start_phase(ms);
+		break;
+	}
+}
+
+
+/*
+ * Called by midlayer with host locked to queue a new
+ * request
+ */
+static int mesh_queue(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))
+{
+	struct mesh_state *ms;
+
+	cmd->scsi_done = done;
+	cmd->host_scribble = NULL;
+
+	ms = (struct mesh_state *) cmd->device->host->hostdata;
+
+	if (ms->request_q == NULL)
+		ms->request_q = cmd;
+	else
+		ms->request_qtail->host_scribble = (void *) cmd;
+	ms->request_qtail = cmd;
+
+	if (ms->phase == idle)
+		mesh_start(ms);
+
+	return 0;
+}
+
+/*
+ * Called to handle interrupts, either call by the interrupt
+ * handler (do_mesh_interrupt) or by other functions in
+ * exceptional circumstances
+ */
+static void mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+{
+	struct mesh_state *ms = (struct mesh_state *) dev_id;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	int intr;
+
+#if 0
+	if (ALLOW_DEBUG(ms->conn_tgt))
+		printk(KERN_DEBUG "mesh_intr, bs0=%x int=%x exc=%x err=%x "
+		       "phase=%d msgphase=%d\n", mr->bus_status0,
+		       mr->interrupt, mr->exception, mr->error,
+		       ms->phase, ms->msgphase);
+#endif
+	while ((intr = in_8(&mr->interrupt)) != 0) {
+		dlog(ms, "interrupt intr/err/exc/seq=%.8x", 
+		     MKWORD(intr, mr->error, mr->exception, mr->sequence));
+		if (intr & INT_ERROR) {
+			handle_error(ms);
+		} else if (intr & INT_EXCEPTION) {
+			handle_exception(ms);
+		} else if (intr & INT_CMDDONE) {
+			out_8(&mr->interrupt, INT_CMDDONE);
+			cmd_complete(ms);
+		}
+	}
+}
+
+/* Todo: here we can at least try to remove the command from the
+ * queue if it isn't connected yet, and for pending command, assert
+ * ATN until the bus gets freed.
+ */
+static int mesh_abort(struct scsi_cmnd *cmd)
+{
+	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
+
+	printk(KERN_DEBUG "mesh_abort(%p)\n", cmd);
+	mesh_dump_regs(ms);
+	dumplog(ms, cmd->device->id);
+	dumpslog(ms);
+	return FAILED;
+}
+
+/*
+ * Called by the midlayer with the lock held to reset the
+ * SCSI host and bus.
+ * The midlayer will wait for devices to come back, we don't need
+ * to do that ourselves
+ */
+static int mesh_host_reset(struct scsi_cmnd *cmd)
+{
+	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
+	volatile struct mesh_regs __iomem *mr = ms->mesh;
+	volatile struct dbdma_regs __iomem *md = ms->dma;
+
+	printk(KERN_DEBUG "mesh_host_reset\n");
+
+	/* Reset the controller & dbdma channel */
+	out_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);	/* stop dma */
+	out_8(&mr->exception, 0xff);	/* clear all exception bits */
+	out_8(&mr->error, 0xff);	/* clear all error bits */
+	out_8(&mr->sequence, SEQ_RESETMESH);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	out_8(&mr->source_id, ms->host->this_id);
+	out_8(&mr->sel_timeout, 25);	/* 250ms */
+	out_8(&mr->sync_params, ASYNC_PARAMS);
+
+	/* Reset the bus */
+	out_8(&mr->bus_status1, BS1_RST);	/* assert RST */
+       	mesh_flush_io(mr);
+	udelay(30);			/* leave it on for >= 25us */
+	out_8(&mr->bus_status1, 0);	/* negate RST */
+
+	/* Complete pending commands */
+	handle_reset(ms);
+	
+	return SUCCESS;
+}
+
+static void set_mesh_power(struct mesh_state *ms, int state)
+{
+	if (_machine != _MACH_Pmac)
+		return;
+	if (state) {
+		pmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 1);
+		msleep(200);
+	} else {
+		pmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 0);
+		msleep(10);
+	}
+}			
+
+
+#ifdef CONFIG_PM
+static int mesh_suspend(struct macio_dev *mdev, u32 state)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	unsigned long flags;
+
+	if (state == mdev->ofdev.dev.power.power_state || state < 2)
+		return 0;
+
+	scsi_block_requests(ms->host);
+	spin_lock_irqsave(ms->host->host_lock, flags);
+	while(ms->phase != idle) {
+		spin_unlock_irqrestore(ms->host->host_lock, flags);
+		msleep(10);
+		spin_lock_irqsave(ms->host->host_lock, flags);
+	}
+	ms->phase = sleeping;
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
+	disable_irq(ms->meshintr);
+	set_mesh_power(ms, 0);
+
+	mdev->ofdev.dev.power.power_state = state;
+
+	return 0;
+}
+
+static int mesh_resume(struct macio_dev *mdev)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	unsigned long flags;
+
+	if (mdev->ofdev.dev.power.power_state == 0)
+		return 0;
+
+	set_mesh_power(ms, 1);
+	mesh_init(ms);
+	spin_lock_irqsave(ms->host->host_lock, flags);
+	mesh_start(ms);
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
+	enable_irq(ms->meshintr);
+	scsi_unblock_requests(ms->host);
+
+	mdev->ofdev.dev.power.power_state = 0;
+
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+/*
+ * If we leave drives set for synchronous transfers (especially
+ * CDROMs), and reboot to MacOS, it gets confused, poor thing.
+ * So, on reboot we reset the SCSI bus.
+ */
+static int mesh_shutdown(struct macio_dev *mdev)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	volatile struct mesh_regs __iomem *mr;
+	unsigned long flags;
+
+       	printk(KERN_INFO "resetting MESH scsi bus(es)\n");
+	spin_lock_irqsave(ms->host->host_lock, flags);
+       	mr = ms->mesh;
+	out_8(&mr->intr_mask, 0);
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	out_8(&mr->bus_status1, BS1_RST);
+	mesh_flush_io(mr);
+	udelay(30);
+	out_8(&mr->bus_status1, 0);
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
+
+	return 0;
+}
+
+static struct scsi_host_template mesh_template = {
+	.proc_name			= "mesh",
+	.name				= "MESH",
+	.queuecommand			= mesh_queue,
+	.eh_abort_handler		= mesh_abort,
+	.eh_host_reset_handler		= mesh_host_reset,
+	.can_queue			= 20,
+	.this_id			= 7,
+	.sg_tablesize			= SG_ALL,
+	.cmd_per_lun			= 2,
+	.use_clustering			= DISABLE_CLUSTERING,
+};
+
+static int mesh_probe(struct macio_dev *mdev, const struct of_match *match)
+{
+	struct device_node *mesh = macio_get_of_node(mdev);
+	struct pci_dev* pdev = macio_get_pci_dev(mdev);
+	int tgt, *cfp, minper;
+	struct mesh_state *ms;
+	struct Scsi_Host *mesh_host;
+	void *dma_cmd_space;
+	dma_addr_t dma_cmd_bus;
+
+	switch (mdev->bus->chip->type) {
+	case macio_heathrow:
+	case macio_gatwick:
+	case macio_paddington:
+		use_active_neg = 0;
+		break;
+	default:
+		use_active_neg = SEQ_ACTIVE_NEG;
+	}
+
+	if (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {
+       		printk(KERN_ERR "mesh: expected 2 addrs and 2 intrs"
+	       	       " (got %d,%d)\n", mesh->n_addrs, mesh->n_intrs);
+		return -ENODEV;
+	}
+
+	if (macio_request_resources(mdev, "mesh") != 0) {
+       		printk(KERN_ERR "mesh: unable to request memory resources");
+		return -EBUSY;
+	}
+       	mesh_host = scsi_host_alloc(&mesh_template, sizeof(struct mesh_state));
+	if (mesh_host == NULL) {
+		printk(KERN_ERR "mesh: couldn't register host");
+		goto out_release;
+	}
+	
+	/* Old junk for root discovery, that will die ultimately */
+#if !defined(MODULE)
+       	note_scsi_host(mesh, mesh_host);
+#endif
+
+	mesh_host->base = macio_resource_start(mdev, 0);
+	mesh_host->irq = macio_irq(mdev, 0);
+       	ms = (struct mesh_state *) mesh_host->hostdata;
+	macio_set_drvdata(mdev, ms);
+	ms->host = mesh_host;
+	ms->mdev = mdev;
+	ms->pdev = pdev;
+	
+	ms->mesh = ioremap(macio_resource_start(mdev, 0), 0x1000);
+	if (ms->mesh == NULL) {
+		printk(KERN_ERR "mesh: can't map registers\n");
+		goto out_free;
+	}		
+	ms->dma = ioremap(macio_resource_start(mdev, 1), 0x1000);
+	if (ms->dma == NULL) {
+		printk(KERN_ERR "mesh: can't map registers\n");
+		iounmap(ms->mesh);
+		goto out_free;
+	}
+
+       	ms->meshintr = macio_irq(mdev, 0);
+       	ms->dmaintr = macio_irq(mdev, 1);
+
+       	/* Space for dma command list: +1 for stop command,
+       	 * +1 to allow for aligning.
+	 */
+	ms->dma_cmd_size = (mesh_host->sg_tablesize + 2) * sizeof(struct dbdma_cmd);
+
+	/* We use the PCI APIs for now until the generic one gets fixed
+	 * enough or until we get some macio-specific versions
+	 */
+	dma_cmd_space = pci_alloc_consistent(macio_get_pci_dev(mdev),
+					     ms->dma_cmd_size,
+					     &dma_cmd_bus);
+	if (dma_cmd_space == NULL) {
+		printk(KERN_ERR "mesh: can't allocate DMA table\n");
+		goto out_unmap;
+	}
+	memset(dma_cmd_space, 0, ms->dma_cmd_size);
+
+	ms->dma_cmds = (struct dbdma_cmd *) DBDMA_ALIGN(dma_cmd_space);
+       	ms->dma_cmd_space = dma_cmd_space;
+	ms->dma_cmd_bus = dma_cmd_bus + ((unsigned long)ms->dma_cmds)
+		- (unsigned long)dma_cmd_space;
+	ms->current_req = NULL;
+       	for (tgt = 0; tgt < 8; ++tgt) {
+	       	ms->tgts[tgt].sdtr_state = do_sdtr;
+	       	ms->tgts[tgt].sync_params = ASYNC_PARAMS;
+	       	ms->tgts[tgt].current_req = NULL;
+       	}
+
+	if ((cfp = (int *) get_property(mesh, "clock-frequency", NULL)))
+       		ms->clk_freq = *cfp;
+	else {
+       		printk(KERN_INFO "mesh: assuming 50MHz clock frequency\n");
+	       	ms->clk_freq = 50000000;
+       	}
+
+       	/* The maximum sync rate is clock / 5; increase
+       	 * mesh_sync_period if necessary.
+	 */
+	minper = 1000000000 / (ms->clk_freq / 5); /* ns */
+	if (mesh_sync_period < minper)
+		mesh_sync_period = minper;
+
+	/* Power up the chip */
+	set_mesh_power(ms, 1);
+
+	/* Set it up */
+       	mesh_init(ms);
+
+	/* XXX FIXME: error should be fatal */
+       	if (request_irq(ms->meshintr, do_mesh_interrupt, 0, "MESH", ms))
+	       	printk(KERN_ERR "MESH: can't get irq %d\n", ms->meshintr);
+
+	/* XXX FIXME: handle failure */
+	scsi_add_host(mesh_host, &mdev->ofdev.dev);
+	scsi_scan_host(mesh_host);
+
+	return 0;
+
+out_unmap:
+	iounmap(ms->dma);
+	iounmap(ms->mesh);
+out_free:
+	scsi_host_put(mesh_host);
+out_release:
+	macio_release_resources(mdev);
+
+	return -ENODEV;
+}
+
+static int mesh_remove(struct macio_dev *mdev)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	struct Scsi_Host *mesh_host = ms->host;
+
+	scsi_remove_host(mesh_host);
+
+	free_irq(ms->meshintr, ms);
+
+	/* Reset scsi bus */
+	mesh_shutdown(mdev);
+
+	/* Shut down chip & termination */
+	set_mesh_power(ms, 0);
+
+	/* Unmap registers & dma controller */
+	iounmap(ms->mesh);
+       	iounmap(ms->dma);
+
+	/* Free DMA commands memory */
+	pci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,
+			  ms->dma_cmd_space, ms->dma_cmd_bus);
+
+	/* Release memory resources */
+	macio_release_resources(mdev);
+
+	scsi_host_put(mesh_host);
+
+	return 0;
+}
+
+
+static struct of_match mesh_match[] = 
+{
+	{
+	.name 		= "mesh",
+	.type		= OF_ANY_MATCH,
+	.compatible	= OF_ANY_MATCH
+	},
+	{
+	.name 		= OF_ANY_MATCH,
+	.type		= "scsi",
+	.compatible	= "chrp,mesh0"
+	},
+	{},
+};
+
+static struct macio_driver mesh_driver = 
+{
+	.name 		= "mesh",
+	.match_table	= mesh_match,
+	.probe		= mesh_probe,
+	.remove		= mesh_remove,
+	.shutdown	= mesh_shutdown,
+#ifdef CONFIG_PM
+	.suspend	= mesh_suspend,
+	.resume		= mesh_resume,
+#endif
+};
+
+
+static int __init init_mesh(void)
+{
+
+	/* Calculate sync rate from module parameters */
+	if (sync_rate > 10)
+		sync_rate = 10;
+	if (sync_rate > 0) {
+		printk(KERN_INFO "mesh: configured for synchronous %d MB/s\n", sync_rate);
+		mesh_sync_period = 1000 / sync_rate;	/* ns */
+		mesh_sync_offset = 15;
+	} else
+		printk(KERN_INFO "mesh: configured for asynchronous\n");
+
+	return macio_register_driver(&mesh_driver);
+}
+
+static void __exit exit_mesh(void)
+{
+	return macio_unregister_driver(&mesh_driver);
+}
+
+module_init(init_mesh);
+module_exit(exit_mesh);
