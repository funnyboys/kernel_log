commit ed830385a2b1fbfcd1d08744b00587df5592162b
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Feb 26 19:45:43 2020 -0600

    scsi: ibmvfc: Avoid loss of all paths during SVC node reboot
    
    When an SVC node goes down as part of a node reboot, its WWPNs are moved to
    the remaining node. When the node is back online, its WWPNs are moved
    back. The result is that the WWPN moves from one NPort_ID to another, then
    back again.  The ibmvfc driver was forcing the old port to be removed, but
    not sending an implicit logout. When the WWPN showed up at the new
    location, the PLOGI failed as there was already a login established for the
    old scsi id. The patch below fixes this by ensuring we always send an
    implicit logout for any scsi id associated with an rport prior to calling
    fc_remote_port_delete.
    
    Link: https://lore.kernel.org/r/1582767943-16611-1-git-send-email-brking@linux.vnet.ibm.com
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 7da89f4d26b2..907889f1fa9d 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -596,6 +596,8 @@ enum ibmvfc_target_action {
 	IBMVFC_TGT_ACTION_NONE = 0,
 	IBMVFC_TGT_ACTION_INIT,
 	IBMVFC_TGT_ACTION_INIT_WAIT,
+	IBMVFC_TGT_ACTION_LOGOUT_RPORT,
+	IBMVFC_TGT_ACTION_LOGOUT_RPORT_WAIT,
 	IBMVFC_TGT_ACTION_DEL_RPORT,
 	IBMVFC_TGT_ACTION_DELETED_RPORT,
 };
@@ -604,7 +606,6 @@ struct ibmvfc_target {
 	struct list_head queue;
 	struct ibmvfc_host *vhost;
 	u64 scsi_id;
-	u64 new_scsi_id;
 	struct fc_rport *rport;
 	int target_id;
 	enum ibmvfc_target_action action;

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 459cc288ba1d..7da89f4d26b2 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -1,24 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * ibmvfc.h -- driver for IBM Power Virtual Fibre Channel Adapter
  *
  * Written By: Brian King <brking@linux.vnet.ibm.com>, IBM Corporation
  *
  * Copyright (C) IBM Corporation, 2008
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  */
 
 #ifndef _IBMVFC_H

commit d6e2635b9cf7982102750c5d9e4ba1474afa0981
Author: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
Date:   Wed Mar 20 14:56:54 2019 -0500

    scsi: ibmvfc: Clean up transport events
    
    No change to functionality. Simply make transport event messages a little
    clearer, and rework CRQ format enums such that we have separate enums for
    INIT messages and XPORT events.
    
    [mkp: typo]
    
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index b81a53c4a9a8..459cc288ba1d 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -78,9 +78,14 @@ enum ibmvfc_crq_valid {
 	IBMVFC_CRQ_XPORT_EVENT		= 0xFF,
 };
 
-enum ibmvfc_crq_format {
+enum ibmvfc_crq_init_msg {
 	IBMVFC_CRQ_INIT			= 0x01,
 	IBMVFC_CRQ_INIT_COMPLETE	= 0x02,
+};
+
+enum ibmvfc_crq_xport_evts {
+	IBMVFC_PARTNER_FAILED		= 0x01,
+	IBMVFC_PARTNER_DEREGISTER	= 0x02,
 	IBMVFC_PARTITION_MIGRATED	= 0x06,
 };
 

commit c39813652700f3df552b6557530f1e5f782dbe2f
Author: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
Date:   Tue Jan 23 20:11:32 2018 -0600

    scsi: ibmvfc: fix misdefined reserved field in ibmvfc_fcp_rsp_info
    
    The fcp_rsp_info structure as defined in the FC spec has an initial 3
    bytes reserved field. The ibmvfc driver mistakenly defined this field as
    4 bytes resulting in the rsp_code field being defined in what should be
    the start of the second reserved field and thus always being reported as
    zero by the driver.
    
    Ideally, we should wire ibmvfc up with libfc for the sake of code
    deduplication, and ease of maintaining standardized structures in a
    single place. However, for now simply fixup the definition in ibmvfc for
    backporting to distros on older kernels. Wiring up with libfc will be
    done in a followup patch.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 9a0696f68f37..b81a53c4a9a8 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -367,7 +367,7 @@ enum ibmvfc_fcp_rsp_info_codes {
 };
 
 struct ibmvfc_fcp_rsp_info {
-	__be16 reserved;
+	u8 reserved[3];
 	u8 rsp_code;
 	u8 reserved2[4];
 }__attribute__((packed, aligned (2)));

commit a6104b1e1846273d52b9230d700939fef0a9da80
Author: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
Date:   Wed Aug 3 16:36:53 2016 -0500

    scsi: ibmvfc: add FC Class 3 Error Recovery support
    
    The ibmvfc driver currently doesn't support FC Class 3 Error Recovery.
    However, it is simply a matter of informing the VIOS that the payload
    expects to use sequence level error recovery via a bit flag in the
    ibmvfc_cmd structure.
    
    This patch adds a module parameter to enable error recovery support at
    boot time. When enabled the RETRY service parameter bit is set during
    PRLI, and ibmvfc_cmd->flags includes the IBMVFC_CLASS_3_ERR bit.
    
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 5c70a52ad346..9a0696f68f37 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -54,6 +54,7 @@
 #define IBMVFC_DEV_LOSS_TMO		(5 * 60)
 #define IBMVFC_DEFAULT_LOG_LEVEL	2
 #define IBMVFC_MAX_CDB_LEN		16
+#define IBMVFC_CLS3_ERROR		0
 
 /*
  * Ensure we have resources for ERP and initialization:

commit 88a678bbc34cecce36bf2c7a8af4cba38f9f77ce
Author: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
Date:   Tue Jun 28 17:05:35 2016 -0500

    ibmvscsis: Initial commit of IBM VSCSI Tgt Driver
    
    This driver is a pick up of the old IBM VIO scsi Target Driver
    that was started by Nick and Fujita 2-4 years ago.
    http://comments.gmane.org/gmane.linux.scsi/90119
    
    The driver provides a virtual SCSI device on IBM Power Servers.
    
    This patch contains the fifth version for an initial merge of the
    tcm ibmvscsis driver. More information on this driver and config
    can be found:
    
    https://github.com/powervm/ibmvscsis/wiki/Configuration
    http://www.linux-iscsi.org/wiki/IBM_vSCSI
    
    (Drop extra libsrp review breakage + Fix kconfig typo - nab)
    
    Signed-off-by: Steven Royer <seroyer@linux.vnet.ibm.com>
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Michael Cyr <mikecyr@linux.vnet.ibm.com>
    Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
    Cc: FUJITA Tomonori <tomof@acm.org>
    Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 8fae03215a85..5c70a52ad346 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -26,7 +26,7 @@
 
 #include <linux/list.h>
 #include <linux/types.h>
-#include "viosrp.h"
+#include <scsi/viosrp.h>
 
 #define IBMVFC_NAME	"ibmvfc"
 #define IBMVFC_DRIVER_VERSION		"1.0.11"

commit 0aab6c3f125e9efcc493caae0cffefe501202a71
Author: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
Date:   Thu Jun 26 19:03:55 2014 -0500

    ibmvfc: fix little endian issues
    
    Added big endian annotations to relevant data structure fields, and necessary
    byte swappings to support little endian builds.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 017a5290e8c1..8fae03215a85 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -135,12 +135,12 @@ enum ibmvfc_mad_types {
 };
 
 struct ibmvfc_mad_common {
-	u32 version;
-	u32 reserved;
-	u32 opcode;
-	u16 status;
-	u16 length;
-	u64 tag;
+	__be32 version;
+	__be32 reserved;
+	__be32 opcode;
+	__be16 status;
+	__be16 length;
+	__be64 tag;
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_npiv_login_mad {
@@ -155,76 +155,76 @@ struct ibmvfc_npiv_logout_mad {
 #define IBMVFC_MAX_NAME 256
 
 struct ibmvfc_npiv_login {
-	u32 ostype;
+	__be32 ostype;
 #define IBMVFC_OS_LINUX	0x02
-	u32 pad;
-	u64 max_dma_len;
-	u32 max_payload;
-	u32 max_response;
-	u32 partition_num;
-	u32 vfc_frame_version;
-	u16 fcp_version;
-	u16 flags;
+	__be32 pad;
+	__be64 max_dma_len;
+	__be32 max_payload;
+	__be32 max_response;
+	__be32 partition_num;
+	__be32 vfc_frame_version;
+	__be16 fcp_version;
+	__be16 flags;
 #define IBMVFC_CLIENT_MIGRATED	0x01
 #define IBMVFC_FLUSH_ON_HALT		0x02
-	u32 max_cmds;
-	u64 capabilities;
+	__be32 max_cmds;
+	__be64 capabilities;
 #define IBMVFC_CAN_MIGRATE		0x01
-	u64 node_name;
+	__be64 node_name;
 	struct srp_direct_buf async;
 	u8 partition_name[IBMVFC_MAX_NAME];
 	u8 device_name[IBMVFC_MAX_NAME];
 	u8 drc_name[IBMVFC_MAX_NAME];
-	u64 reserved2[2];
+	__be64 reserved2[2];
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_common_svc_parms {
-	u16 fcph_version;
-	u16 b2b_credit;
-	u16 features;
-	u16 bb_rcv_sz; /* upper nibble is BB_SC_N */
-	u32 ratov;
-	u32 edtov;
+	__be16 fcph_version;
+	__be16 b2b_credit;
+	__be16 features;
+	__be16 bb_rcv_sz; /* upper nibble is BB_SC_N */
+	__be32 ratov;
+	__be32 edtov;
 }__attribute__((packed, aligned (4)));
 
 struct ibmvfc_service_parms {
 	struct ibmvfc_common_svc_parms common;
 	u8 port_name[8];
 	u8 node_name[8];
-	u32 class1_parms[4];
-	u32 class2_parms[4];
-	u32 class3_parms[4];
-	u32 obsolete[4];
-	u32 vendor_version[4];
-	u32 services_avail[2];
-	u32 ext_len;
-	u32 reserved[30];
-	u32 clk_sync_qos[2];
+	__be32 class1_parms[4];
+	__be32 class2_parms[4];
+	__be32 class3_parms[4];
+	__be32 obsolete[4];
+	__be32 vendor_version[4];
+	__be32 services_avail[2];
+	__be32 ext_len;
+	__be32 reserved[30];
+	__be32 clk_sync_qos[2];
 }__attribute__((packed, aligned (4)));
 
 struct ibmvfc_npiv_login_resp {
-	u32 version;
-	u16 status;
-	u16 error;
-	u32 flags;
+	__be32 version;
+	__be16 status;
+	__be16 error;
+	__be32 flags;
 #define IBMVFC_NATIVE_FC		0x01
-	u32 reserved;
-	u64 capabilities;
+	__be32 reserved;
+	__be64 capabilities;
 #define IBMVFC_CAN_FLUSH_ON_HALT	0x08
 #define IBMVFC_CAN_SUPPRESS_ABTS	0x10
-	u32 max_cmds;
-	u32 scsi_id_sz;
-	u64 max_dma_len;
-	u64 scsi_id;
-	u64 port_name;
-	u64 node_name;
-	u64 link_speed;
+	__be32 max_cmds;
+	__be32 scsi_id_sz;
+	__be64 max_dma_len;
+	__be64 scsi_id;
+	__be64 port_name;
+	__be64 node_name;
+	__be64 link_speed;
 	u8 partition_name[IBMVFC_MAX_NAME];
 	u8 device_name[IBMVFC_MAX_NAME];
 	u8 port_loc_code[IBMVFC_MAX_NAME];
 	u8 drc_name[IBMVFC_MAX_NAME];
 	struct ibmvfc_service_parms service_parms;
-	u64 reserved2;
+	__be64 reserved2;
 }__attribute__((packed, aligned (8)));
 
 union ibmvfc_npiv_login_data {
@@ -233,20 +233,20 @@ union ibmvfc_npiv_login_data {
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_discover_targets_buf {
-	u32 scsi_id[1];
+	__be32 scsi_id[1];
 #define IBMVFC_DISC_TGT_SCSI_ID_MASK	0x00ffffff
 };
 
 struct ibmvfc_discover_targets {
 	struct ibmvfc_mad_common common;
 	struct srp_direct_buf buffer;
-	u32 flags;
-	u16 status;
-	u16 error;
-	u32 bufflen;
-	u32 num_avail;
-	u32 num_written;
-	u64 reserved[2];
+	__be32 flags;
+	__be16 status;
+	__be16 error;
+	__be32 bufflen;
+	__be32 num_avail;
+	__be32 num_written;
+	__be64 reserved[2];
 }__attribute__((packed, aligned (8)));
 
 enum ibmvfc_fc_reason {
@@ -278,32 +278,32 @@ enum ibmvfc_gs_explain {
 
 struct ibmvfc_port_login {
 	struct ibmvfc_mad_common common;
-	u64 scsi_id;
-	u16 reserved;
-	u16 fc_service_class;
-	u32 blksz;
-	u32 hdr_per_blk;
-	u16 status;
-	u16 error;		/* also fc_reason */
-	u16 fc_explain;
-	u16 fc_type;
-	u32 reserved2;
+	__be64 scsi_id;
+	__be16 reserved;
+	__be16 fc_service_class;
+	__be32 blksz;
+	__be32 hdr_per_blk;
+	__be16 status;
+	__be16 error;		/* also fc_reason */
+	__be16 fc_explain;
+	__be16 fc_type;
+	__be32 reserved2;
 	struct ibmvfc_service_parms service_parms;
 	struct ibmvfc_service_parms service_parms_change;
-	u64 reserved3[2];
+	__be64 reserved3[2];
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_prli_svc_parms {
 	u8 type;
 #define IBMVFC_SCSI_FCP_TYPE		0x08
 	u8 type_ext;
-	u16 flags;
+	__be16 flags;
 #define IBMVFC_PRLI_ORIG_PA_VALID			0x8000
 #define IBMVFC_PRLI_RESP_PA_VALID			0x4000
 #define IBMVFC_PRLI_EST_IMG_PAIR			0x2000
-	u32 orig_pa;
-	u32 resp_pa;
-	u32 service_parms;
+	__be32 orig_pa;
+	__be32 resp_pa;
+	__be32 service_parms;
 #define IBMVFC_PRLI_TASK_RETRY			0x00000200
 #define IBMVFC_PRLI_RETRY				0x00000100
 #define IBMVFC_PRLI_DATA_OVERLAY			0x00000040
@@ -315,47 +315,47 @@ struct ibmvfc_prli_svc_parms {
 
 struct ibmvfc_process_login {
 	struct ibmvfc_mad_common common;
-	u64 scsi_id;
+	__be64 scsi_id;
 	struct ibmvfc_prli_svc_parms parms;
 	u8 reserved[48];
-	u16 status;
-	u16 error;			/* also fc_reason */
-	u32 reserved2;
-	u64 reserved3[2];
+	__be16 status;
+	__be16 error;			/* also fc_reason */
+	__be32 reserved2;
+	__be64 reserved3[2];
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_query_tgt {
 	struct ibmvfc_mad_common common;
-	u64 wwpn;
-	u64 scsi_id;
-	u16 status;
-	u16 error;
-	u16 fc_explain;
-	u16 fc_type;
-	u64 reserved[2];
+	__be64 wwpn;
+	__be64 scsi_id;
+	__be16 status;
+	__be16 error;
+	__be16 fc_explain;
+	__be16 fc_type;
+	__be64 reserved[2];
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_implicit_logout {
 	struct ibmvfc_mad_common common;
-	u64 old_scsi_id;
-	u64 reserved[2];
+	__be64 old_scsi_id;
+	__be64 reserved[2];
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_tmf {
 	struct ibmvfc_mad_common common;
-	u64 scsi_id;
+	__be64 scsi_id;
 	struct scsi_lun lun;
-	u32 flags;
+	__be32 flags;
 #define IBMVFC_TMF_ABORT_TASK		0x02
 #define IBMVFC_TMF_ABORT_TASK_SET	0x04
 #define IBMVFC_TMF_LUN_RESET		0x10
 #define IBMVFC_TMF_TGT_RESET		0x20
 #define IBMVFC_TMF_LUA_VALID		0x40
 #define IBMVFC_TMF_SUPPRESS_ABTS	0x80
-	u32 cancel_key;
-	u32 my_cancel_key;
-	u32 pad;
-	u64 reserved[2];
+	__be32 cancel_key;
+	__be32 my_cancel_key;
+	__be32 pad;
+	__be64 reserved[2];
 }__attribute__((packed, aligned (8)));
 
 enum ibmvfc_fcp_rsp_info_codes {
@@ -366,7 +366,7 @@ enum ibmvfc_fcp_rsp_info_codes {
 };
 
 struct ibmvfc_fcp_rsp_info {
-	u16 reserved;
+	__be16 reserved;
 	u8 rsp_code;
 	u8 reserved2[4];
 }__attribute__((packed, aligned (2)));
@@ -388,13 +388,13 @@ union ibmvfc_fcp_rsp_data {
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_fcp_rsp {
-	u64 reserved;
-	u16 retry_delay_timer;
+	__be64 reserved;
+	__be16 retry_delay_timer;
 	u8 flags;
 	u8 scsi_status;
-	u32 fcp_resid;
-	u32 fcp_sense_len;
-	u32 fcp_rsp_len;
+	__be32 fcp_resid;
+	__be32 fcp_sense_len;
+	__be32 fcp_rsp_len;
 	union ibmvfc_fcp_rsp_data data;
 }__attribute__((packed, aligned (8)));
 
@@ -429,58 +429,58 @@ struct ibmvfc_fcp_cmd_iu {
 #define IBMVFC_RDDATA		0x02
 #define IBMVFC_WRDATA		0x01
 	u8 cdb[IBMVFC_MAX_CDB_LEN];
-	u32 xfer_len;
+	__be32 xfer_len;
 }__attribute__((packed, aligned (4)));
 
 struct ibmvfc_cmd {
-	u64 task_tag;
-	u32 frame_type;
-	u32 payload_len;
-	u32 resp_len;
-	u32 adapter_resid;
-	u16 status;
-	u16 error;
-	u16 flags;
-	u16 response_flags;
+	__be64 task_tag;
+	__be32 frame_type;
+	__be32 payload_len;
+	__be32 resp_len;
+	__be32 adapter_resid;
+	__be16 status;
+	__be16 error;
+	__be16 flags;
+	__be16 response_flags;
 #define IBMVFC_ADAPTER_RESID_VALID	0x01
-	u32 cancel_key;
-	u32 exchange_id;
+	__be32 cancel_key;
+	__be32 exchange_id;
 	struct srp_direct_buf ext_func;
 	struct srp_direct_buf ioba;
 	struct srp_direct_buf resp;
-	u64 correlation;
-	u64 tgt_scsi_id;
-	u64 tag;
-	u64 reserved3[2];
+	__be64 correlation;
+	__be64 tgt_scsi_id;
+	__be64 tag;
+	__be64 reserved3[2];
 	struct ibmvfc_fcp_cmd_iu iu;
 	struct ibmvfc_fcp_rsp rsp;
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_passthru_fc_iu {
-	u32 payload[7];
+	__be32 payload[7];
 #define IBMVFC_ADISC	0x52000000
-	u32 response[7];
+	__be32 response[7];
 };
 
 struct ibmvfc_passthru_iu {
-	u64 task_tag;
-	u32 cmd_len;
-	u32 rsp_len;
-	u16 status;
-	u16 error;
-	u32 flags;
+	__be64 task_tag;
+	__be32 cmd_len;
+	__be32 rsp_len;
+	__be16 status;
+	__be16 error;
+	__be32 flags;
 #define IBMVFC_FC_ELS		0x01
 #define IBMVFC_FC_CT_IU		0x02
-	u32 cancel_key;
+	__be32 cancel_key;
 #define IBMVFC_PASSTHRU_CANCEL_KEY	0x80000000
 #define IBMVFC_INTERNAL_CANCEL_KEY	0x80000001
-	u32 reserved;
+	__be32 reserved;
 	struct srp_direct_buf cmd;
 	struct srp_direct_buf rsp;
-	u64 correlation;
-	u64 scsi_id;
-	u64 tag;
-	u64 reserved2[2];
+	__be64 correlation;
+	__be64 scsi_id;
+	__be64 tag;
+	__be64 reserved2[2];
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_passthru_mad {
@@ -552,7 +552,7 @@ struct ibmvfc_crq {
 	volatile u8 valid;
 	volatile u8 format;
 	u8 reserved[6];
-	volatile u64 ioba;
+	volatile __be64 ioba;
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_crq_queue {
@@ -572,12 +572,12 @@ struct ibmvfc_async_crq {
 	volatile u8 valid;
 	u8 link_state;
 	u8 pad[2];
-	u32 pad2;
-	volatile u64 event;
-	volatile u64 scsi_id;
-	volatile u64 wwpn;
-	volatile u64 node_name;
-	u64 reserved;
+	__be32 pad2;
+	volatile __be64 event;
+	volatile __be64 scsi_id;
+	volatile __be64 wwpn;
+	volatile __be64 node_name;
+	__be64 reserved;
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_async_crq_queue {

commit 883467871c60125765e0674199ef34a9b8d203bd
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Apr 12 08:25:19 2013 -0500

    [SCSI] ibmvfc: Driver version 1.0.11
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Acked-by: Robert Jennings <rcj@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 219005da37c0..017a5290e8c1 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.10"
-#define IBMVFC_DRIVER_DATE		"(August 24, 2012)"
+#define IBMVFC_DRIVER_VERSION		"1.0.11"
+#define IBMVFC_DRIVER_DATE		"(April 12, 2013)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit 90f725dbb20557d30e6eb20959bb08cae2661a70
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Apr 12 08:25:18 2013 -0500

    [SCSI] ibmvfc: Suppress ABTS if target gone
    
    Adds support for a new VIOS feature that allows ibmvfc to
    optimize terminate_rport_io by telling the VIOS the target
    is no longer accessible on the fabric and that it should
    not send an ABTS out on the fabric to the device.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Acked-by: Robert Jennings <rcj@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 3be8af624e6f..219005da37c0 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -208,10 +208,10 @@ struct ibmvfc_npiv_login_resp {
 	u16 error;
 	u32 flags;
 #define IBMVFC_NATIVE_FC		0x01
-#define IBMVFC_CAN_FLUSH_ON_HALT	0x08
 	u32 reserved;
 	u64 capabilities;
 #define IBMVFC_CAN_FLUSH_ON_HALT	0x08
+#define IBMVFC_CAN_SUPPRESS_ABTS	0x10
 	u32 max_cmds;
 	u32 scsi_id_sz;
 	u64 max_dma_len;
@@ -351,6 +351,7 @@ struct ibmvfc_tmf {
 #define IBMVFC_TMF_LUN_RESET		0x10
 #define IBMVFC_TMF_TGT_RESET		0x20
 #define IBMVFC_TMF_LUA_VALID		0x40
+#define IBMVFC_TMF_SUPPRESS_ABTS	0x80
 	u32 cancel_key;
 	u32 my_cancel_key;
 	u32 pad;

commit f2b0599de5450e11bc41be2432a161f86d816ae3
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Aug 24 16:51:03 2012 -0500

    [SCSI] ibmvfc: Driver version 1.0.10
    
    Bump driver version.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 834c37fc7ce9..3be8af624e6f 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.9"
-#define IBMVFC_DRIVER_DATE		"(August 5, 2010)"
+#define IBMVFC_DRIVER_VERSION		"1.0.10"
+#define IBMVFC_DRIVER_DATE		"(August 24, 2012)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit 402c6eec1bd04581c04de758e4efddc020b78f91
Author: Robert Jennings <rcj@linux.vnet.ibm.com>
Date:   Thu Dec 9 14:03:59 2010 -0600

    [SCSI] ibmvfc: Improve ibmvfc_async_desc memory layout
    
    By changing field ordering we can avoid a couple of memory holes in
    the tables that use the ibmvfc_async_desc structure.
    
    Signed-off-by: Robert Jennings <rcj@linux.vnet.ibm.com>
    Acked-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index ef663e7c9bbc..834c37fc7ce9 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -542,8 +542,8 @@ enum ibmvfc_async_event {
 };
 
 struct ibmvfc_async_desc {
-	enum ibmvfc_async_event ae;
 	const char *desc;
+	enum ibmvfc_async_event ae;
 	int log_level;
 };
 

commit d99e5f488ae28d9dfccc84435f4fd29bd1fe1b9b
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Sep 9 16:20:42 2010 -0500

    [SCSI] ibmvfc: Log link up/down events
    
    By default, ibmvfc does not log any async events in order
    to avoid flooding the log with them. Improve on this by
    logging by default events that are not likely to flood the
    log, such as link up/down. Having these events in the log
    will improve the ability to debug issues with ibmvfc.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 608af394c8cf..ef663e7c9bbc 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -541,6 +541,12 @@ enum ibmvfc_async_event {
 	IBMVFC_AE_ADAPTER_FAILED	= 0x1000,
 };
 
+struct ibmvfc_async_desc {
+	enum ibmvfc_async_event ae;
+	const char *desc;
+	int log_level;
+};
+
 struct ibmvfc_crq {
 	volatile u8 valid;
 	volatile u8 format;

commit 7e41dfdaf11a45ab4f4dfc444a7d42bf79dd9356
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Aug 5 16:38:36 2010 -0500

    [SCSI] ibmvfc: Driver version 1.0.9
    
    Bump driver version.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index d47cefc22ed3..608af394c8cf 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.8"
-#define IBMVFC_DRIVER_DATE		"(June 17, 2010)"
+#define IBMVFC_DRIVER_VERSION		"1.0.9"
+#define IBMVFC_DRIVER_DATE		"(August 5, 2010)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit d2fab5cf3979c55f802c96616daf96e9e8de1c80
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Aug 5 16:38:34 2010 -0500

    [SCSI] ibmvfc: Fix terminate_rport_io
    
    The ibmvfc driver was incorrectly obtaining a scsi_target pointer
    from an fc_rport. The way it is coded ensures that ibmvfc's
    terminate_rport_io handler does absolutely nothing. Fix this up
    to iterate through affected devices differently, sending cancel
    and abort task set as appropriate. Without this patch,
    fast_io_fail_tmo is broken for ibmvfc.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index af48172112fa..d47cefc22ed3 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -38,6 +38,7 @@
 #define IBMVFC_ADISC_PLUS_CANCEL_TIMEOUT	\
 		(IBMVFC_ADISC_TIMEOUT + IBMVFC_ADISC_CANCEL_TIMEOUT)
 #define IBMVFC_INIT_TIMEOUT		120
+#define IBMVFC_ABORT_TIMEOUT		8
 #define IBMVFC_ABORT_WAIT_TIMEOUT	40
 #define IBMVFC_MAX_REQUESTS_DEFAULT	100
 

commit d5da3040d798df4bbb62579b97f8b6b83749da22
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Aug 5 16:38:31 2010 -0500

    [SCSI] ibmvfc: Fix rport add/delete race resulting in oops
    
    Commit 43c8da907ccc656935d1085701f4db83385d8a59 introduced a race
    condition which can occur when adding/deleting rports. There are
    two possible threads now that can be deleting rports in the ibmvfc
    driver, which can result in list_del being called twice, resulting
    in an oops. This patch adds a new state to the ibmvfc_target struct
    to indicate the target has been removed from the list and is in
    the process of being deleted.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index d7e8dcd90650..af48172112fa 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -597,6 +597,7 @@ enum ibmvfc_target_action {
 	IBMVFC_TGT_ACTION_INIT,
 	IBMVFC_TGT_ACTION_INIT_WAIT,
 	IBMVFC_TGT_ACTION_DEL_RPORT,
+	IBMVFC_TGT_ACTION_DELETED_RPORT,
 };
 
 struct ibmvfc_target {

commit 06395193b20124663b83b2894da827aec7e9d920
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Jun 17 13:55:16 2010 -0500

    [SCSI] ibmvfc: Driver version 1.0.8
    
    Bump driver version.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 2010d73aca81..d7e8dcd90650 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.7"
-#define IBMVFC_DRIVER_DATE		"(October 16, 2009)"
+#define IBMVFC_DRIVER_VERSION		"1.0.8"
+#define IBMVFC_DRIVER_DATE		"(June 17, 2010)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit 73ee5d8672871bd69077ca71e7208a36bfa6343c
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Jun 17 13:55:13 2010 -0500

    [SCSI] ibmvfc: Fix soft lockup on resume
    
    This fixes a softlockup seen on resume. During resume, the CRQ
    must be reenabled. However, the H_ENABLE_CRQ hcall used to do
    this may return H_BUSY or H_LONG_BUSY. When this happens, the
    caller is expected to retry later. Normally the H_ENABLE_CRQ
    succeeds relatively soon. However, we have seen cases where
    this can take long enough to see softlockup warnings.
    This patch changes a simple loop, which was causing the
    softlockup, to a loop at task level which sleeps between
    retries rather than simply spinning.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 7e9742764e4b..2010d73aca81 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -649,6 +649,8 @@ struct ibmvfc_event_pool {
 
 enum ibmvfc_host_action {
 	IBMVFC_HOST_ACTION_NONE = 0,
+	IBMVFC_HOST_ACTION_RESET,
+	IBMVFC_HOST_ACTION_REENABLE,
 	IBMVFC_HOST_ACTION_LOGO,
 	IBMVFC_HOST_ACTION_LOGO_WAIT,
 	IBMVFC_HOST_ACTION_INIT,

commit daa142d1773dd3a986f02a8a4da929608d24daaa
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Tue Apr 20 14:21:35 2010 -0500

    [SCSI] ibmvfc: Reduce error recovery timeout
    
    If a command times out resulting in EH getting invoked, we wait for the
    aborted commands to come back after sending the abort. Shorten
    the amount of time we wait for these responses, to ensure we don't
    get stuck in EH for several minutes.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index d25106a958d7..7e9742764e4b 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -38,6 +38,7 @@
 #define IBMVFC_ADISC_PLUS_CANCEL_TIMEOUT	\
 		(IBMVFC_ADISC_TIMEOUT + IBMVFC_ADISC_CANCEL_TIMEOUT)
 #define IBMVFC_INIT_TIMEOUT		120
+#define IBMVFC_ABORT_WAIT_TIMEOUT	40
 #define IBMVFC_MAX_REQUESTS_DEFAULT	100
 
 #define IBMVFC_DEBUG			0

commit 8da85e451d1e9c37bd2846f032c9d5ffa1234d1f
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Mon Oct 19 15:07:55 2009 -0500

    [SCSI] ibmvfc: Driver version 1.0.7
    
    Bump driver version to 1.0.7.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 77513b4dd9ae..d25106a958d7 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.6"
-#define IBMVFC_DRIVER_DATE		"(May 28, 2009)"
+#define IBMVFC_DRIVER_VERSION		"1.0.7"
+#define IBMVFC_DRIVER_DATE		"(October 16, 2009)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit d31429e1517c007781dfc68aed9b39cb5d3350a1
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Mon Oct 19 15:07:54 2009 -0500

    [SCSI] ibmvfc: Add FC Passthru support
    
    Adds support for FC passthru via BSG.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 007fa1c9ef14..77513b4dd9ae 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -58,9 +58,10 @@
  * 1 for ERP
  * 1 for initialization
  * 1 for NPIV Logout
+ * 2 for BSG passthru
  * 2 for each discovery thread
  */
-#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + 1 + (disc_threads * 2))
+#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + 1 + 2 + (disc_threads * 2))
 
 #define IBMVFC_MAD_SUCCESS		0x00
 #define IBMVFC_MAD_NOT_SUPPORTED	0xF1
@@ -466,7 +467,10 @@ struct ibmvfc_passthru_iu {
 	u16 error;
 	u32 flags;
 #define IBMVFC_FC_ELS		0x01
+#define IBMVFC_FC_CT_IU		0x02
 	u32 cancel_key;
+#define IBMVFC_PASSTHRU_CANCEL_KEY	0x80000000
+#define IBMVFC_INTERNAL_CANCEL_KEY	0x80000001
 	u32 reserved;
 	struct srp_direct_buf cmd;
 	struct srp_direct_buf rsp;
@@ -693,6 +697,7 @@ struct ibmvfc_host {
 	int disc_buf_sz;
 	int log_level;
 	struct ibmvfc_discover_targets_buf *disc_buf;
+	struct mutex passthru_mutex;
 	int task_set;
 	int init_retries;
 	int discovery_threads;
@@ -702,6 +707,7 @@ struct ibmvfc_host {
 	int delay_init;
 	int scan_complete;
 	int logged_in;
+	int aborting_passthru;
 	int events_to_log;
 #define IBMVFC_AE_LINKUP	0x0001
 #define IBMVFC_AE_LINKDOWN	0x0002

commit 017b2ae33c0fc7d70320cc7f1cce0efb6ce8d929
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Jun 18 09:06:55 2009 -0500

    ibmvfc: Fix endless PRLI loop in discovery
    
    Fixes a problem seen where sending a PRLI to a target
    resulted in it sending a LOGO. This caused the ibmvfc
    driver to go back through discovery again, which caused
    another PRLI attempt, which caused another LOGO. Fix this
    behavior by ignoring LOGO if we haven't even logged into
    the target yet.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index c2668d7d67f5..007fa1c9ef14 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -605,6 +605,7 @@ struct ibmvfc_target {
 	int need_login;
 	int add_rport;
 	int init_retries;
+	int logo_rcvd;
 	u32 cancel_key;
 	struct ibmvfc_service_parms service_parms;
 	struct ibmvfc_service_parms service_parms_change;

commit cbbf58f2e2cb73dbed660fdc7b741a010d6bdbef
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu May 28 16:17:34 2009 -0500

    [SCSI] ibmvfc: Driver version 1.0.6
    
    Bump driver version
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index cf26380820fb..c2668d7d67f5 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.5"
-#define IBMVFC_DRIVER_DATE		"(March 19, 2009)"
+#define IBMVFC_DRIVER_VERSION		"1.0.6"
+#define IBMVFC_DRIVER_DATE		"(May 28, 2009)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit 497f9c504f76e7a751cd370604e1c8521743746d
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu May 28 16:17:30 2009 -0500

    [SCSI] ibmvfc: Add flush on halt support
    
    The virtual I/O server controlling the NPIV adapter associated with
    a virtual fibre channel adapter can send a HALT event to the client.
    When this occurs, the client can no longer send commands until a RESUME
    is received. By adding support for flush on halt, we will get all of
    our outstanding commands flushed back before the Virtual I/O server
    enters the halt state, eliminating potential command timeouts for
    outstanding commands which might occur if we did not support this feature.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 6adaad80565d..cf26380820fb 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -207,7 +207,8 @@ struct ibmvfc_npiv_login_resp {
 #define IBMVFC_NATIVE_FC		0x01
 #define IBMVFC_CAN_FLUSH_ON_HALT	0x08
 	u32 reserved;
-	u64 capabilites;
+	u64 capabilities;
+#define IBMVFC_CAN_FLUSH_ON_HALT	0x08
 	u32 max_cmds;
 	u32 scsi_id_sz;
 	u64 max_dma_len;
@@ -547,9 +548,17 @@ struct ibmvfc_crq_queue {
 	dma_addr_t msg_token;
 };
 
+enum ibmvfc_ae_link_state {
+	IBMVFC_AE_LS_LINK_UP		= 0x01,
+	IBMVFC_AE_LS_LINK_BOUNCED	= 0x02,
+	IBMVFC_AE_LS_LINK_DOWN		= 0x04,
+	IBMVFC_AE_LS_LINK_DEAD		= 0x08,
+};
+
 struct ibmvfc_async_crq {
 	volatile u8 valid;
-	u8 pad[3];
+	u8 link_state;
+	u8 pad[2];
 	u32 pad2;
 	volatile u64 event;
 	volatile u64 scsi_id;

commit 79111d0899a122fa3cf0a2921292c3e6a25452d0
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu May 28 16:17:29 2009 -0500

    [SCSI] ibmvfc: Add support for NPIV Logout
    
    This patch adds support for a new command supported by the Virtual I/O
    Server, NPIV Logout. The command will abort all outstanding commands
    and log out of the fabric. Currently, the only way to do this is
    by breaking the CRQ, which can take a fairly long time when lots of
    commands are outstanding. The NPIV Logout commands provides a mechanism
    to accomplish virtually the same function, but is much faster.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 3a6a725fd396..6adaad80565d 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -57,9 +57,10 @@
  * Ensure we have resources for ERP and initialization:
  * 1 for ERP
  * 1 for initialization
+ * 1 for NPIV Logout
  * 2 for each discovery thread
  */
-#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + (disc_threads * 2))
+#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + 1 + (disc_threads * 2))
 
 #define IBMVFC_MAD_SUCCESS		0x00
 #define IBMVFC_MAD_NOT_SUPPORTED	0xF1
@@ -127,6 +128,7 @@ enum ibmvfc_mad_types {
 	IBMVFC_IMPLICIT_LOGOUT	= 0x0040,
 	IBMVFC_PASSTHRU		= 0x0200,
 	IBMVFC_TMF_MAD		= 0x0100,
+	IBMVFC_NPIV_LOGOUT	= 0x0800,
 };
 
 struct ibmvfc_mad_common {
@@ -143,6 +145,10 @@ struct ibmvfc_npiv_login_mad {
 	struct srp_direct_buf buffer;
 }__attribute__((packed, aligned (8)));
 
+struct ibmvfc_npiv_logout_mad {
+	struct ibmvfc_mad_common common;
+}__attribute__((packed, aligned (8)));
+
 #define IBMVFC_MAX_NAME 256
 
 struct ibmvfc_npiv_login {
@@ -561,6 +567,7 @@ struct ibmvfc_async_crq_queue {
 union ibmvfc_iu {
 	struct ibmvfc_mad_common mad_common;
 	struct ibmvfc_npiv_login_mad npiv_login;
+	struct ibmvfc_npiv_logout_mad npiv_logout;
 	struct ibmvfc_discover_targets discover_targets;
 	struct ibmvfc_port_login plogi;
 	struct ibmvfc_process_login prli;
@@ -627,6 +634,8 @@ struct ibmvfc_event_pool {
 
 enum ibmvfc_host_action {
 	IBMVFC_HOST_ACTION_NONE = 0,
+	IBMVFC_HOST_ACTION_LOGO,
+	IBMVFC_HOST_ACTION_LOGO_WAIT,
 	IBMVFC_HOST_ACTION_INIT,
 	IBMVFC_HOST_ACTION_INIT_WAIT,
 	IBMVFC_HOST_ACTION_QUERY,
@@ -682,6 +691,7 @@ struct ibmvfc_host {
 	int reinit;
 	int delay_init;
 	int scan_complete;
+	int logged_in;
 	int events_to_log;
 #define IBMVFC_AE_LINKUP	0x0001
 #define IBMVFC_AE_LINKDOWN	0x0002

commit 43c8da907ccc656935d1085701f4db83385d8a59
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu May 28 16:17:28 2009 -0500

    [SCSI] ibmvfc: Fix deadlock in EH
    
    Fixes the following deadlock scenario shown below. We currently allow
    queuecommand to send commands when the ibmvfc workqueue is scanning for
    new rports, so we should also allow EH to function at this time as well.
    
    scsi_eh_3     D 0000000000000000 12304  1279      2
    Call Trace:
    [c0000002f7257730] [c0000002f72577e0] 0xc0000002f72577e0 (unreliable)
    [c0000002f7257900] [c0000000000118f4] .__switch_to+0x158/0x1a0
    [c0000002f72579a0] [c0000000004f8b40] .schedule+0x8d4/0x9dc
    [c0000002f7257b60] [c0000000004f8f08] .schedule_timeout+0xa8/0xe8
    [c0000002f7257c50] [d0000000001d23e0] .ibmvfc_wait_while_resetting+0xe4/0x140 [ibmvfc]
    [c0000002f7257d20] [d0000000001d3984] .ibmvfc_eh_abort_handler+0x60/0xe4 [ibmvfc]
    [c0000002f7257dc0] [d000000000366714] .scsi_error_handler+0x38c/0x674 [scsi_mod]
    [c0000002f7257f00] [c0000000000a7470] .kthread+0x78/0xc4
    [c0000002f7257f90] [c000000000029b8c] .kernel_thread+0x4c/0x68
    ibmvfc_3      D 0000000000000000 12432  1280      2
    Call Trace:
    [c0000002f7253540] [c0000002f72535f0] 0xc0000002f72535f0 (unreliable)
    [c0000002f7253710] [c0000000000118f4] .__switch_to+0x158/0x1a0
    [c0000002f72537b0] [c0000000004f8b40] .schedule+0x8d4/0x9dc
    [c0000002f7253970] [c0000000004f8e98] .schedule_timeout+0x38/0xe8
    [c0000002f7253a60] [c0000000004f80cc] .wait_for_common+0x138/0x220
    [c0000002f7253b40] [c0000000000a2784] .flush_cpu_workqueue+0xac/0xcc
    [c0000002f7253c10] [c0000000000a2960] .flush_workqueue+0x58/0xa0
    [c0000002f7253ca0] [d0000000000827fc] .fc_flush_work+0x4c/0x64 [scsi_transport_fc]
    [c0000002f7253d20] [d000000000082db4] .fc_remote_port_add+0x48/0x6c4 [scsi_transport_fc]
    [c0000002f7253dd0] [d0000000001d7d04] .ibmvfc_work+0x820/0xa7c [ibmvfc]
    [c0000002f7253f00] [c0000000000a7470] .kthread+0x78/0xc4
    [c0000002f7253f90] [c000000000029b8c] .kernel_thread+0x4c/0x68
    fc_wq_3       D 0000000000000000 10720  1283      2
    Call Trace:
    [c0000002f559ac30] [c0000002f559ace0] 0xc0000002f559ace0 (unreliable)
    [c0000002f559ae00] [c0000000000118f4] .__switch_to+0x158/0x1a0
    [c0000002f559aea0] [c0000000004f8b40] .schedule+0x8d4/0x9dc
    [c0000002f559b060] [c0000000004f8e98] .schedule_timeout+0x38/0xe8
    [c0000002f559b150] [c0000000004f80cc] .wait_for_common+0x138/0x220
    [c0000002f559b230] [c0000000002721c4] .blk_execute_rq+0xb4/0x100
    [c0000002f559b360] [d00000000036a1f8] .scsi_execute+0x118/0x194 [scsi_mod]
    [c0000002f559b420] [d00000000036a32c] .scsi_execute_req+0xb8/0x124 [scsi_mod]
    [c0000002f559b500] [d0000000000c1330] .sd_sync_cache+0x8c/0x108 [sd_mod]
    [c0000002f559b5e0] [d0000000000c15b4] .sd_shutdown+0x9c/0x158 [sd_mod]
    [c0000002f559b660] [d0000000000c16d0] .sd_remove+0x60/0xb4 [sd_mod]
    [c0000002f559b700] [c000000000392ecc] .__device_release_driver+0xd0/0x118
    [c0000002f559b7a0] [c000000000393080] .device_release_driver+0x30/0x54
    [c0000002f559b830] [c000000000392108] .bus_remove_device+0x128/0x16c
    [c0000002f559b8d0] [c00000000038f94c] .device_del+0x158/0x234
    [c0000002f559b960] [d00000000036f078] .__scsi_remove_device+0x5c/0xd4 [scsi_mod]
    [c0000002f559b9f0] [d00000000036f124] .scsi_remove_device+0x34/0x58 [scsi_mod]
    [c0000002f559ba80] [d00000000036f204] .__scsi_remove_target+0xb4/0x120 [scsi_mod]
    [c0000002f559bb10] [d00000000036f338] .__remove_child+0x2c/0x44 [scsi_mod]
    [c0000002f559bb90] [c00000000038f11c] .device_for_each_child+0x54/0xb4
    [c0000002f559bc50] [d00000000036f2e0] .scsi_remove_target+0x70/0x9c [scsi_mod]
    [c0000002f559bce0] [d000000000083454] .fc_starget_delete+0x24/0x3c [scsi_transport_fc]
    [c0000002f559bd70] [c0000000000a2368] .run_workqueue+0x118/0x208
    [c0000002f559be30] [c0000000000a2580] .worker_thread+0x128/0x154
    [c0000002f559bf00] [c0000000000a7470] .kthread+0x78/0xc4
    [c0000002f559bf90] [c000000000029b8c] .kernel_thread+0x4c/0x68
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 4dac3560c1a4..3a6a725fd396 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -575,7 +575,6 @@ enum ibmvfc_target_action {
 	IBMVFC_TGT_ACTION_NONE = 0,
 	IBMVFC_TGT_ACTION_INIT,
 	IBMVFC_TGT_ACTION_INIT_WAIT,
-	IBMVFC_TGT_ACTION_ADD_RPORT,
 	IBMVFC_TGT_ACTION_DEL_RPORT,
 };
 
@@ -588,6 +587,7 @@ struct ibmvfc_target {
 	int target_id;
 	enum ibmvfc_target_action action;
 	int need_login;
+	int add_rport;
 	int init_retries;
 	u32 cancel_key;
 	struct ibmvfc_service_parms service_parms;
@@ -635,7 +635,6 @@ enum ibmvfc_host_action {
 	IBMVFC_HOST_ACTION_ALLOC_TGTS,
 	IBMVFC_HOST_ACTION_TGT_INIT,
 	IBMVFC_HOST_ACTION_TGT_DEL_FAILED,
-	IBMVFC_HOST_ACTION_TGT_ADD,
 };
 
 enum ibmvfc_host_state {
@@ -682,6 +681,7 @@ struct ibmvfc_host {
 	int client_migrated;
 	int reinit;
 	int delay_init;
+	int scan_complete;
 	int events_to_log;
 #define IBMVFC_AE_LINKUP	0x0001
 #define IBMVFC_AE_LINKDOWN	0x0002
@@ -692,6 +692,7 @@ struct ibmvfc_host {
 	void (*job_step) (struct ibmvfc_host *);
 	struct task_struct *work_thread;
 	struct tasklet_struct tasklet;
+	struct work_struct rport_add_work_q;
 	wait_queue_head_t init_wait_q;
 	wait_queue_head_t work_wait_q;
 };

commit 7d0e462247241b8ec2d377306203b58c7f423553
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu May 28 16:17:26 2009 -0500

    [SCSI] ibmvfc: Reduce error logging noise
    
    The ibmvfc driver currently logs errors during discovery for several
    transient fabric errors, which generally get retried. If retries
    do not work, we see multiple errors in the log. If retries do work,
    we see errors in the log which may be confusing since the retry worked.
    This patch enhances the discovery time error logging to only log errors
    for command failures during discovery if all allowed retries have been
    used up. The existing behavior of logging all failures can be restored
    by setting the hosts log_level to a value of 3 or greater.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index ca1dcf7a7568..4dac3560c1a4 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -707,6 +707,12 @@ struct ibmvfc_host {
 #define tgt_err(t, fmt, ...)		\
 	dev_err((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
 
+#define tgt_log(t, level, fmt, ...) \
+	do { \
+		if ((t)->vhost->log_level >= level) \
+			tgt_err(t, fmt, ##__VA_ARGS__); \
+	} while (0)
+
 #define ibmvfc_dbg(vhost, ...) \
 	DBG_CMD(dev_info((vhost)->dev, ##__VA_ARGS__))
 

commit 534841b3c110b0f149513c7695751879951d3f22
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Mar 20 15:44:40 2009 -0500

    [SCSI] ibmvfc: Driver version 1.0.5
    
    Bump driver version to 1.0.5.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 0f14fd3c40d2..ca1dcf7a7568 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.4"
-#define IBMVFC_DRIVER_DATE		"(November 14, 2008)"
+#define IBMVFC_DRIVER_VERSION		"1.0.5"
+#define IBMVFC_DRIVER_DATE		"(March 19, 2009)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_ADISC_CANCEL_TIMEOUT	45

commit 10501e1ce3d97cc84a8e29a3a139f74601b59b0f
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Mar 20 15:44:39 2009 -0500

    [SCSI] ibmvfc: Improve ADISC timeout handling
    
    The ibmvfc driver currently breaks the CRQ and essentially
    resets the entire virtual FC adapter, killing all outstanding
    ops to all attached targets, if an ADISC times out during target
    discover/rediscovery. This patch adds some code to cancel the
    ADISC if it times out, which prevents a single ADISC timeout from
    affecting the other devices attached to the fabric.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 70107522e3a9..0f14fd3c40d2 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -33,6 +33,10 @@
 #define IBMVFC_DRIVER_DATE		"(November 14, 2008)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	60
+#define IBMVFC_ADISC_CANCEL_TIMEOUT	45
+#define IBMVFC_ADISC_TIMEOUT		15
+#define IBMVFC_ADISC_PLUS_CANCEL_TIMEOUT	\
+		(IBMVFC_ADISC_TIMEOUT + IBMVFC_ADISC_CANCEL_TIMEOUT)
 #define IBMVFC_INIT_TIMEOUT		120
 #define IBMVFC_MAX_REQUESTS_DEFAULT	100
 
@@ -53,9 +57,9 @@
  * Ensure we have resources for ERP and initialization:
  * 1 for ERP
  * 1 for initialization
- * 1 for each discovery thread
+ * 2 for each discovery thread
  */
-#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + disc_threads)
+#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + (disc_threads * 2))
 
 #define IBMVFC_MAD_SUCCESS		0x00
 #define IBMVFC_MAD_NOT_SUPPORTED	0xF1
@@ -585,10 +589,12 @@ struct ibmvfc_target {
 	enum ibmvfc_target_action action;
 	int need_login;
 	int init_retries;
+	u32 cancel_key;
 	struct ibmvfc_service_parms service_parms;
 	struct ibmvfc_service_parms service_parms_change;
 	struct fc_rport_identifiers ids;
 	void (*job_step) (struct ibmvfc_target *);
+	struct timer_list timer;
 	struct kref kref;
 };
 
@@ -672,6 +678,7 @@ struct ibmvfc_host {
 	int task_set;
 	int init_retries;
 	int discovery_threads;
+	int abort_threads;
 	int client_migrated;
 	int reinit;
 	int delay_init;

commit 039a08981a49e05f09db969cdd3f38f05a5df46f
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Mar 20 15:44:35 2009 -0500

    [SCSI] ibmvfc: Fix dropped interrupts
    
    This patch fixes a problem of possible dropped interrupts. Currently,
    the ibmvfc driver has a race condition where after ibmvfc_interrupt
    gets run, the platform code clears the interrupt. This can result in
    lost interrupts and, in worst case scenarios, result in command
    timeouts. Fix this by implementing a tasklet similar to what the
    ibmvscsi driver does so that interrupt processing is no longer done in
    the actual interrupt handler, which eliminates the race.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index b21e071b9862..70107522e3a9 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -684,6 +684,7 @@ struct ibmvfc_host {
 	char partition_name[97];
 	void (*job_step) (struct ibmvfc_host *);
 	struct task_struct *work_thread;
+	struct tasklet_struct tasklet;
 	wait_queue_head_t init_wait_q;
 	wait_queue_head_t work_wait_q;
 };

commit 14ae6faca11889d80f795993dbe932d82305b564
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Feb 4 16:13:13 2009 -0600

    [SCSI] ibmvfc: Increase cancel timeout
    
    During cancel testing it has been shown that 15 seconds is not
    nearly long enough for the VIOS to respond to a cancel under
    loaded situations. Increasing this timeout to 60 seconds allows
    time for the VIOS to cancel the outstanding commands and prevents
    us from escalating to a full host reset, which can take much longer.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 87dafd0f8d44..b21e071b9862 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -32,7 +32,7 @@
 #define IBMVFC_DRIVER_VERSION		"1.0.4"
 #define IBMVFC_DRIVER_DATE		"(November 14, 2008)"
 
-#define IBMVFC_DEFAULT_TIMEOUT	15
+#define IBMVFC_DEFAULT_TIMEOUT	60
 #define IBMVFC_INIT_TIMEOUT		120
 #define IBMVFC_MAX_REQUESTS_DEFAULT	100
 

commit 775a42ecf8b8a86b55173da27e6cc874af5b944d
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Jan 6 14:59:00 2009 +0000

    powerpc: Cleanup from l64 to ll64 change drivers/scsi
    
    This is a powerpc specific driver.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index babdf3db59df..87dafd0f8d44 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -691,13 +691,13 @@ struct ibmvfc_host {
 #define DBG_CMD(CMD) do { if (ibmvfc_debug) CMD; } while (0)
 
 #define tgt_dbg(t, fmt, ...)			\
-	DBG_CMD(dev_info((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__))
+	DBG_CMD(dev_info((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__))
 
 #define tgt_info(t, fmt, ...)		\
-	dev_info((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
+	dev_info((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
 
 #define tgt_err(t, fmt, ...)		\
-	dev_err((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
+	dev_err((t)->vhost->dev, "%llX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
 
 #define ibmvfc_dbg(vhost, ...) \
 	DBG_CMD(dev_info((vhost)->dev, ##__VA_ARGS__))

commit d2131b33c7e07c2905ee2f2321cc4dae1928c483
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Thu Dec 18 09:26:51 2008 -0600

    [SCSI] ibmvfc: Improve async event handling
    
    While doing various error injection testing, such as cable
    pulls and target moves, some issues were observed in handling
    these events. This patch improves the way these events are handled
    by increasing the delay waiting for the fabric to settle and also
    changes the behavior of Link Up to break the CRQ to ensure everything
    gets cleaned up properly on the VIOS.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index cf02216dc8db..babdf3db59df 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -33,7 +33,7 @@
 #define IBMVFC_DRIVER_DATE		"(November 14, 2008)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	15
-#define IBMVFC_INIT_TIMEOUT		30
+#define IBMVFC_INIT_TIMEOUT		120
 #define IBMVFC_MAX_REQUESTS_DEFAULT	100
 
 #define IBMVFC_DEBUG			0

commit 1c41fa8288277e76785acb50f52bb2f39509f903
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Dec 3 11:02:54 2008 -0600

    [SCSI] ibmvfc: Delay NPIV login retry and add retries
    
    Adds a delay prior to retrying a failed NPIV login. This fixes
    a scenario if the backing fibre channel adapter is getting reset
    due to an EEH event, NPIV login will fail. Currently, ibmvfc
    retries three times very quickly, resets the CRQ and tries one
    more time. If the adapter is getting reset due to EEH, this isn't
    enough time. This adds a delay prior to retrying a failed NPIV
    login and also increments the number of retries.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index d6bae941c566..cf02216dc8db 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -43,7 +43,8 @@
 #define IBMVFC_MAX_DISC_THREADS	4
 #define IBMVFC_TGT_MEMPOOL_SZ		64
 #define IBMVFC_MAX_CMDS_PER_LUN	64
-#define IBMVFC_MAX_INIT_RETRIES	3
+#define IBMVFC_MAX_HOST_INIT_RETRIES	6
+#define IBMVFC_MAX_TGT_INIT_RETRIES		3
 #define IBMVFC_DEV_LOSS_TMO		(5 * 60)
 #define IBMVFC_DEFAULT_LOG_LEVEL	2
 #define IBMVFC_MAX_CDB_LEN		16
@@ -673,6 +674,7 @@ struct ibmvfc_host {
 	int discovery_threads;
 	int client_migrated;
 	int reinit;
+	int delay_init;
 	int events_to_log;
 #define IBMVFC_AE_LINKUP	0x0001
 #define IBMVFC_AE_LINKDOWN	0x0002

commit 67e6d58d812ec3e95918266076d4c836cdec849a
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Nov 14 13:33:54 2008 -0600

    [SCSI] ibmvfc: Driver version 1.0.4
    
    Bump driver version
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 6b86e1f69f69..d6bae941c566 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.3"
-#define IBMVFC_DRIVER_DATE		"(October 28, 2008)"
+#define IBMVFC_DRIVER_VERSION		"1.0.4"
+#define IBMVFC_DRIVER_DATE		"(November 14, 2008)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	15
 #define IBMVFC_INIT_TIMEOUT		30

commit 646d3857b95e8e310aae7a4594f43d7f3b100a1f
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Nov 14 13:33:53 2008 -0600

    [SCSI] ibmvfc: Handle port login required response
    
    The virtual fibre channel stack can return a failure response for a command
    indicating the port login has been invalidated without sending the client
    an async event. Add code to handle this response and initiate a PLOGI.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 526bca743c81..6b86e1f69f69 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -109,6 +109,7 @@ enum ibmvfc_vios_errors {
 	IBMVFC_TRANS_CANCELLED			= 0x0006,
 	IBMVFC_TRANS_CANCELLED_IMPLICIT	= 0x0007,
 	IBMVFC_INSUFFICIENT_RESOURCE		= 0x0008,
+	IBMVFC_PLOGI_REQUIRED			= 0x0010,
 	IBMVFC_COMMAND_FAILED			= 0x8000,
 };
 

commit 5919ce29085f4ca080054fde5feef8f8b3405261
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Nov 14 13:33:52 2008 -0600

    [SCSI] ibmvfc: Fix command timeouts due to cached CRQ access
    
    The CRQs used by the ibmvfc driver are read and written by both
    the client and the server. Therefore, we need to mark them volatile
    so that we do not cache their contents when handling an interrupt.
    This fixes a problem which can surface as occasional command timeouts.
    No commands were actually timing out, but due to accessing cached data
    for the CRQ in the interrupt handler, the interrupt was not processing
    all command completions as it should.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index f0c0212a7460..526bca743c81 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -523,10 +523,10 @@ enum ibmvfc_async_event {
 };
 
 struct ibmvfc_crq {
-	u8 valid;
-	u8 format;
+	volatile u8 valid;
+	volatile u8 format;
 	u8 reserved[6];
-	u64 ioba;
+	volatile u64 ioba;
 }__attribute__((packed, aligned (8)));
 
 struct ibmvfc_crq_queue {
@@ -536,13 +536,13 @@ struct ibmvfc_crq_queue {
 };
 
 struct ibmvfc_async_crq {
-	u8 valid;
+	volatile u8 valid;
 	u8 pad[3];
 	u32 pad2;
-	u64 event;
-	u64 scsi_id;
-	u64 wwpn;
-	u64 node_name;
+	volatile u64 event;
+	volatile u64 scsi_id;
+	volatile u64 wwpn;
+	volatile u64 node_name;
 	u64 reserved;
 }__attribute__((packed, aligned (8)));
 

commit 973b73605cc2ac1f51457809c5f1f1f8ab760c47
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Oct 29 08:46:49 2008 -0500

    [SCSI] ibmvfc: Driver version 1.0.3
    
    Bump driver version.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 2d723df5b18c..f0c0212a7460 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.2"
-#define IBMVFC_DRIVER_DATE		"(August 14, 2008)"
+#define IBMVFC_DRIVER_VERSION		"1.0.3"
+#define IBMVFC_DRIVER_DATE		"(October 28, 2008)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	15
 #define IBMVFC_INIT_TIMEOUT		30

commit 10e794996ed00a0f09ff0745f87e3a3dd5de4606
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Oct 29 08:46:45 2008 -0500

    [SCSI] ibmvfc: Fix target initialization failure retry handling
    
    If the ibmvfc driver is in discovery attempting to log into a target
    and it encounters an error, the command may get retried one or more
    times, depending on the error received. If the retries are
    unsuccessful such that the discovery thread gives up on discovery to
    that target, the target ends up in a state where, if SCSI core had
    previously known about the device, the host will get unblocked but the
    host will not be logged into the target, causing any commands sent to
    the target to fail. This patch fixes this so that if this occurs, the
    target is deleted such that the normal dev_loss processing can occur
    instead.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index c3696ce470bd..2d723df5b18c 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -626,6 +626,7 @@ enum ibmvfc_host_action {
 	IBMVFC_HOST_ACTION_TGT_DEL,
 	IBMVFC_HOST_ACTION_ALLOC_TGTS,
 	IBMVFC_HOST_ACTION_TGT_INIT,
+	IBMVFC_HOST_ACTION_TGT_DEL_FAILED,
 	IBMVFC_HOST_ACTION_TGT_ADD,
 };
 

commit ad8dcffaf9bc1d7eb86dabf591e95f4ffb86cf1b
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Oct 29 08:46:41 2008 -0500

    [SCSI] ibmvfc: Error handling fixes
    
    Due to an ambiguity in the VIOS VFC interface specification,
    abort/cancel handling is not done correctly and can result in double
    completion of commands. In order to cancel all outstanding commands to
    a device, a cancel must be sent, followed by an abort task set. After
    the responses are received for these commands, there may still be
    commands outstanding, in the process of getting flushed back, in which
    case, we need to wait for them. This patch removes the assumption that
    if the abort and the cancel both complete successfully that the device
    queue has been flushed and waits for all the responses to come back.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 1d18a4c48a9c..c3696ce470bd 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -337,7 +337,6 @@ struct ibmvfc_tmf {
 #define IBMVFC_TMF_LUA_VALID		0x40
 	u32 cancel_key;
 	u32 my_cancel_key;
-#define IBMVFC_TMF_CANCEL_KEY		0x80000000
 	u32 pad;
 	u64 reserved[2];
 }__attribute__((packed, aligned (8)));
@@ -606,6 +605,7 @@ struct ibmvfc_event {
 	struct srp_direct_buf *ext_list;
 	dma_addr_t ext_list_token;
 	struct completion comp;
+	struct completion *eh_comp;
 	struct timer_list timer;
 };
 

commit 596891acd774f515c2a43adda9322d6a9b2b51b9
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Oct 29 08:46:33 2008 -0500

    [SCSI] ibmvfc: Fix log level filtering
    
    The ibmvfc log level filtering logic was reversed. The log_level scsi
    host parameter should result in more verbose logs when log_level is
    larger, not smaller.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index fb3177ab6691..1d18a4c48a9c 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -700,7 +700,7 @@ struct ibmvfc_host {
 
 #define ibmvfc_log(vhost, level, ...) \
 	do { \
-		if (level >= (vhost)->log_level) \
+		if ((vhost)->log_level >= level) \
 			dev_err((vhost)->dev, ##__VA_ARGS__); \
 	} while (0)
 

commit 7d0e367ab3f3ad345bd3e121c4c5f511e8b274fa
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Aug 15 10:59:28 2008 -0500

    [SCSI] ibmvfc: Driver version 1.0.2
    
    Bump driver version to 1.0.2.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 4bf6e374f076..fb3177ab6691 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.1"
-#define IBMVFC_DRIVER_DATE		"(July 11, 2008)"
+#define IBMVFC_DRIVER_VERSION		"1.0.2"
+#define IBMVFC_DRIVER_DATE		"(August 14, 2008)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	15
 #define IBMVFC_INIT_TIMEOUT		30

commit cadbd4a5e36dde7e6c49b587b2c419103c0b7218
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:47:27 2008 -0700

    [SCSI] replace __FUNCTION__ with __func__
    
    [jejb: fixed up a ton of missed conversions.
    
     All of you are on notice this has happened, driver trees will now
     need to be rebased]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: SCSI List <linux-scsi@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index de2c34abddf4..4bf6e374f076 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -704,8 +704,8 @@ struct ibmvfc_host {
 			dev_err((vhost)->dev, ##__VA_ARGS__); \
 	} while (0)
 
-#define ENTER DBG_CMD(printk(KERN_INFO IBMVFC_NAME": Entering %s\n", __FUNCTION__))
-#define LEAVE DBG_CMD(printk(KERN_INFO IBMVFC_NAME": Leaving %s\n", __FUNCTION__))
+#define ENTER DBG_CMD(printk(KERN_INFO IBMVFC_NAME": Entering %s\n", __func__))
+#define LEAVE DBG_CMD(printk(KERN_INFO IBMVFC_NAME": Leaving %s\n", __func__))
 
 #ifdef CONFIG_SCSI_IBMVFC_TRACE
 #define ibmvfc_create_trace_file(kobj, attr) sysfs_create_bin_file(kobj, attr)

commit b7b1a35ea563a8f1219dc3fdf12f37937cb83245
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Tue Jul 22 08:31:48 2008 -0500

    [SCSI] ibmvfc: Update driver version to 1.0.1
    
    Update driver version to 1.0.1.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 6a48e5bb94e7..de2c34abddf4 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -29,8 +29,8 @@
 #include "viosrp.h"
 
 #define IBMVFC_NAME	"ibmvfc"
-#define IBMVFC_DRIVER_VERSION		"1.0.0"
-#define IBMVFC_DRIVER_DATE		"(July 1, 2008)"
+#define IBMVFC_DRIVER_VERSION		"1.0.1"
+#define IBMVFC_DRIVER_DATE		"(July 11, 2008)"
 
 #define IBMVFC_DEFAULT_TIMEOUT	15
 #define IBMVFC_INIT_TIMEOUT		30

commit 989b854579875b38d45fffa7f8c89177f7698cd3
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Tue Jul 22 08:31:47 2008 -0500

    [SCSI] ibmvfc: Add ADISC support
    
    Add an ADISC to the target discovery job in order to sanity check whether or
    not we need to re-login to the target.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
index 057f3c01ed61..6a48e5bb94e7 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.h
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -119,6 +119,7 @@ enum ibmvfc_mad_types {
 	IBMVFC_PROCESS_LOGIN	= 0x0008,
 	IBMVFC_QUERY_TARGET	= 0x0010,
 	IBMVFC_IMPLICIT_LOGOUT	= 0x0040,
+	IBMVFC_PASSTHRU		= 0x0200,
 	IBMVFC_TMF_MAD		= 0x0100,
 };
 
@@ -439,6 +440,37 @@ struct ibmvfc_cmd {
 	struct ibmvfc_fcp_rsp rsp;
 }__attribute__((packed, aligned (8)));
 
+struct ibmvfc_passthru_fc_iu {
+	u32 payload[7];
+#define IBMVFC_ADISC	0x52000000
+	u32 response[7];
+};
+
+struct ibmvfc_passthru_iu {
+	u64 task_tag;
+	u32 cmd_len;
+	u32 rsp_len;
+	u16 status;
+	u16 error;
+	u32 flags;
+#define IBMVFC_FC_ELS		0x01
+	u32 cancel_key;
+	u32 reserved;
+	struct srp_direct_buf cmd;
+	struct srp_direct_buf rsp;
+	u64 correlation;
+	u64 scsi_id;
+	u64 tag;
+	u64 reserved2[2];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_passthru_mad {
+	struct ibmvfc_mad_common common;
+	struct srp_direct_buf cmd_ioba;
+	struct ibmvfc_passthru_iu iu;
+	struct ibmvfc_passthru_fc_iu fc_iu;
+}__attribute__((packed, aligned (8)));
+
 struct ibmvfc_trace_start_entry {
 	u32 xfer_len;
 }__attribute__((packed));
@@ -531,6 +563,7 @@ union ibmvfc_iu {
 	struct ibmvfc_implicit_logout implicit_logout;
 	struct ibmvfc_tmf tmf;
 	struct ibmvfc_cmd cmd;
+	struct ibmvfc_passthru_mad passthru;
 }__attribute__((packed, aligned (8)));
 
 enum ibmvfc_target_action {
@@ -656,6 +689,9 @@ struct ibmvfc_host {
 #define tgt_dbg(t, fmt, ...)			\
 	DBG_CMD(dev_info((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__))
 
+#define tgt_info(t, fmt, ...)		\
+	dev_info((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
+
 #define tgt_err(t, fmt, ...)		\
 	dev_err((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
 

commit 072b91f9c6510d0ec4a49d07dbc318760c7da7b3
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Tue Jul 1 13:14:30 2008 -0500

    [SCSI] ibmvfc: IBM Power Virtual Fibre Channel Adapter Client Driver
    
    This patch adds a new device driver to support the Virtual Fibre Channel
    interface on IBM Power based servers. The Virtual I/O Server on IBM Power
    servers utilizes N-Port ID Virtualization to export a Virtual Fibre Channel
    adapter to the client. This driver is the client device driver.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.h b/drivers/scsi/ibmvscsi/ibmvfc.h
new file mode 100644
index 000000000000..057f3c01ed61
--- /dev/null
+++ b/drivers/scsi/ibmvscsi/ibmvfc.h
@@ -0,0 +1,682 @@
+/*
+ * ibmvfc.h -- driver for IBM Power Virtual Fibre Channel Adapter
+ *
+ * Written By: Brian King <brking@linux.vnet.ibm.com>, IBM Corporation
+ *
+ * Copyright (C) IBM Corporation, 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _IBMVFC_H
+#define _IBMVFC_H
+
+#include <linux/list.h>
+#include <linux/types.h>
+#include "viosrp.h"
+
+#define IBMVFC_NAME	"ibmvfc"
+#define IBMVFC_DRIVER_VERSION		"1.0.0"
+#define IBMVFC_DRIVER_DATE		"(July 1, 2008)"
+
+#define IBMVFC_DEFAULT_TIMEOUT	15
+#define IBMVFC_INIT_TIMEOUT		30
+#define IBMVFC_MAX_REQUESTS_DEFAULT	100
+
+#define IBMVFC_DEBUG			0
+#define IBMVFC_MAX_TARGETS		1024
+#define IBMVFC_MAX_LUN			0xffffffff
+#define IBMVFC_MAX_SECTORS		0xffffu
+#define IBMVFC_MAX_DISC_THREADS	4
+#define IBMVFC_TGT_MEMPOOL_SZ		64
+#define IBMVFC_MAX_CMDS_PER_LUN	64
+#define IBMVFC_MAX_INIT_RETRIES	3
+#define IBMVFC_DEV_LOSS_TMO		(5 * 60)
+#define IBMVFC_DEFAULT_LOG_LEVEL	2
+#define IBMVFC_MAX_CDB_LEN		16
+
+/*
+ * Ensure we have resources for ERP and initialization:
+ * 1 for ERP
+ * 1 for initialization
+ * 1 for each discovery thread
+ */
+#define IBMVFC_NUM_INTERNAL_REQ	(1 + 1 + disc_threads)
+
+#define IBMVFC_MAD_SUCCESS		0x00
+#define IBMVFC_MAD_NOT_SUPPORTED	0xF1
+#define IBMVFC_MAD_FAILED		0xF7
+#define IBMVFC_MAD_DRIVER_FAILED	0xEE
+#define IBMVFC_MAD_CRQ_ERROR		0xEF
+
+enum ibmvfc_crq_valid {
+	IBMVFC_CRQ_CMD_RSP		= 0x80,
+	IBMVFC_CRQ_INIT_RSP		= 0xC0,
+	IBMVFC_CRQ_XPORT_EVENT		= 0xFF,
+};
+
+enum ibmvfc_crq_format {
+	IBMVFC_CRQ_INIT			= 0x01,
+	IBMVFC_CRQ_INIT_COMPLETE	= 0x02,
+	IBMVFC_PARTITION_MIGRATED	= 0x06,
+};
+
+enum ibmvfc_cmd_status_flags {
+	IBMVFC_FABRIC_MAPPED		= 0x0001,
+	IBMVFC_VIOS_FAILURE		= 0x0002,
+	IBMVFC_FC_FAILURE			= 0x0004,
+	IBMVFC_FC_SCSI_ERROR		= 0x0008,
+	IBMVFC_HW_EVENT_LOGGED		= 0x0010,
+	IBMVFC_VIOS_LOGGED		= 0x0020,
+};
+
+enum ibmvfc_fabric_mapped_errors {
+	IBMVFC_UNABLE_TO_ESTABLISH	= 0x0001,
+	IBMVFC_XPORT_FAULT		= 0x0002,
+	IBMVFC_CMD_TIMEOUT		= 0x0003,
+	IBMVFC_ENETDOWN			= 0x0004,
+	IBMVFC_HW_FAILURE			= 0x0005,
+	IBMVFC_LINK_DOWN_ERR		= 0x0006,
+	IBMVFC_LINK_DEAD_ERR		= 0x0007,
+	IBMVFC_UNABLE_TO_REGISTER	= 0x0008,
+	IBMVFC_XPORT_BUSY			= 0x000A,
+	IBMVFC_XPORT_DEAD			= 0x000B,
+	IBMVFC_CONFIG_ERROR		= 0x000C,
+	IBMVFC_NAME_SERVER_FAIL		= 0x000D,
+	IBMVFC_LINK_HALTED		= 0x000E,
+	IBMVFC_XPORT_GENERAL		= 0x8000,
+};
+
+enum ibmvfc_vios_errors {
+	IBMVFC_CRQ_FAILURE			= 0x0001,
+	IBMVFC_SW_FAILURE				= 0x0002,
+	IBMVFC_INVALID_PARAMETER		= 0x0003,
+	IBMVFC_MISSING_PARAMETER		= 0x0004,
+	IBMVFC_HOST_IO_BUS			= 0x0005,
+	IBMVFC_TRANS_CANCELLED			= 0x0006,
+	IBMVFC_TRANS_CANCELLED_IMPLICIT	= 0x0007,
+	IBMVFC_INSUFFICIENT_RESOURCE		= 0x0008,
+	IBMVFC_COMMAND_FAILED			= 0x8000,
+};
+
+enum ibmvfc_mad_types {
+	IBMVFC_NPIV_LOGIN		= 0x0001,
+	IBMVFC_DISC_TARGETS	= 0x0002,
+	IBMVFC_PORT_LOGIN		= 0x0004,
+	IBMVFC_PROCESS_LOGIN	= 0x0008,
+	IBMVFC_QUERY_TARGET	= 0x0010,
+	IBMVFC_IMPLICIT_LOGOUT	= 0x0040,
+	IBMVFC_TMF_MAD		= 0x0100,
+};
+
+struct ibmvfc_mad_common {
+	u32 version;
+	u32 reserved;
+	u32 opcode;
+	u16 status;
+	u16 length;
+	u64 tag;
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_npiv_login_mad {
+	struct ibmvfc_mad_common common;
+	struct srp_direct_buf buffer;
+}__attribute__((packed, aligned (8)));
+
+#define IBMVFC_MAX_NAME 256
+
+struct ibmvfc_npiv_login {
+	u32 ostype;
+#define IBMVFC_OS_LINUX	0x02
+	u32 pad;
+	u64 max_dma_len;
+	u32 max_payload;
+	u32 max_response;
+	u32 partition_num;
+	u32 vfc_frame_version;
+	u16 fcp_version;
+	u16 flags;
+#define IBMVFC_CLIENT_MIGRATED	0x01
+#define IBMVFC_FLUSH_ON_HALT		0x02
+	u32 max_cmds;
+	u64 capabilities;
+#define IBMVFC_CAN_MIGRATE		0x01
+	u64 node_name;
+	struct srp_direct_buf async;
+	u8 partition_name[IBMVFC_MAX_NAME];
+	u8 device_name[IBMVFC_MAX_NAME];
+	u8 drc_name[IBMVFC_MAX_NAME];
+	u64 reserved2[2];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_common_svc_parms {
+	u16 fcph_version;
+	u16 b2b_credit;
+	u16 features;
+	u16 bb_rcv_sz; /* upper nibble is BB_SC_N */
+	u32 ratov;
+	u32 edtov;
+}__attribute__((packed, aligned (4)));
+
+struct ibmvfc_service_parms {
+	struct ibmvfc_common_svc_parms common;
+	u8 port_name[8];
+	u8 node_name[8];
+	u32 class1_parms[4];
+	u32 class2_parms[4];
+	u32 class3_parms[4];
+	u32 obsolete[4];
+	u32 vendor_version[4];
+	u32 services_avail[2];
+	u32 ext_len;
+	u32 reserved[30];
+	u32 clk_sync_qos[2];
+}__attribute__((packed, aligned (4)));
+
+struct ibmvfc_npiv_login_resp {
+	u32 version;
+	u16 status;
+	u16 error;
+	u32 flags;
+#define IBMVFC_NATIVE_FC		0x01
+#define IBMVFC_CAN_FLUSH_ON_HALT	0x08
+	u32 reserved;
+	u64 capabilites;
+	u32 max_cmds;
+	u32 scsi_id_sz;
+	u64 max_dma_len;
+	u64 scsi_id;
+	u64 port_name;
+	u64 node_name;
+	u64 link_speed;
+	u8 partition_name[IBMVFC_MAX_NAME];
+	u8 device_name[IBMVFC_MAX_NAME];
+	u8 port_loc_code[IBMVFC_MAX_NAME];
+	u8 drc_name[IBMVFC_MAX_NAME];
+	struct ibmvfc_service_parms service_parms;
+	u64 reserved2;
+}__attribute__((packed, aligned (8)));
+
+union ibmvfc_npiv_login_data {
+	struct ibmvfc_npiv_login login;
+	struct ibmvfc_npiv_login_resp resp;
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_discover_targets_buf {
+	u32 scsi_id[1];
+#define IBMVFC_DISC_TGT_SCSI_ID_MASK	0x00ffffff
+};
+
+struct ibmvfc_discover_targets {
+	struct ibmvfc_mad_common common;
+	struct srp_direct_buf buffer;
+	u32 flags;
+	u16 status;
+	u16 error;
+	u32 bufflen;
+	u32 num_avail;
+	u32 num_written;
+	u64 reserved[2];
+}__attribute__((packed, aligned (8)));
+
+enum ibmvfc_fc_reason {
+	IBMVFC_INVALID_ELS_CMD_CODE	= 0x01,
+	IBMVFC_INVALID_VERSION		= 0x02,
+	IBMVFC_LOGICAL_ERROR		= 0x03,
+	IBMVFC_INVALID_CT_IU_SIZE	= 0x04,
+	IBMVFC_LOGICAL_BUSY		= 0x05,
+	IBMVFC_PROTOCOL_ERROR		= 0x07,
+	IBMVFC_UNABLE_TO_PERFORM_REQ	= 0x09,
+	IBMVFC_CMD_NOT_SUPPORTED	= 0x0B,
+	IBMVFC_SERVER_NOT_AVAIL		= 0x0D,
+	IBMVFC_CMD_IN_PROGRESS		= 0x0E,
+	IBMVFC_VENDOR_SPECIFIC		= 0xFF,
+};
+
+enum ibmvfc_fc_type {
+	IBMVFC_FABRIC_REJECT	= 0x01,
+	IBMVFC_PORT_REJECT	= 0x02,
+	IBMVFC_LS_REJECT		= 0x03,
+	IBMVFC_FABRIC_BUSY	= 0x04,
+	IBMVFC_PORT_BUSY		= 0x05,
+	IBMVFC_BASIC_REJECT	= 0x06,
+};
+
+enum ibmvfc_gs_explain {
+	IBMVFC_PORT_NAME_NOT_REG	= 0x02,
+};
+
+struct ibmvfc_port_login {
+	struct ibmvfc_mad_common common;
+	u64 scsi_id;
+	u16 reserved;
+	u16 fc_service_class;
+	u32 blksz;
+	u32 hdr_per_blk;
+	u16 status;
+	u16 error;		/* also fc_reason */
+	u16 fc_explain;
+	u16 fc_type;
+	u32 reserved2;
+	struct ibmvfc_service_parms service_parms;
+	struct ibmvfc_service_parms service_parms_change;
+	u64 reserved3[2];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_prli_svc_parms {
+	u8 type;
+#define IBMVFC_SCSI_FCP_TYPE		0x08
+	u8 type_ext;
+	u16 flags;
+#define IBMVFC_PRLI_ORIG_PA_VALID			0x8000
+#define IBMVFC_PRLI_RESP_PA_VALID			0x4000
+#define IBMVFC_PRLI_EST_IMG_PAIR			0x2000
+	u32 orig_pa;
+	u32 resp_pa;
+	u32 service_parms;
+#define IBMVFC_PRLI_TASK_RETRY			0x00000200
+#define IBMVFC_PRLI_RETRY				0x00000100
+#define IBMVFC_PRLI_DATA_OVERLAY			0x00000040
+#define IBMVFC_PRLI_INITIATOR_FUNC			0x00000020
+#define IBMVFC_PRLI_TARGET_FUNC			0x00000010
+#define IBMVFC_PRLI_READ_FCP_XFER_RDY_DISABLED	0x00000002
+#define IBMVFC_PRLI_WR_FCP_XFER_RDY_DISABLED	0x00000001
+}__attribute__((packed, aligned (4)));
+
+struct ibmvfc_process_login {
+	struct ibmvfc_mad_common common;
+	u64 scsi_id;
+	struct ibmvfc_prli_svc_parms parms;
+	u8 reserved[48];
+	u16 status;
+	u16 error;			/* also fc_reason */
+	u32 reserved2;
+	u64 reserved3[2];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_query_tgt {
+	struct ibmvfc_mad_common common;
+	u64 wwpn;
+	u64 scsi_id;
+	u16 status;
+	u16 error;
+	u16 fc_explain;
+	u16 fc_type;
+	u64 reserved[2];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_implicit_logout {
+	struct ibmvfc_mad_common common;
+	u64 old_scsi_id;
+	u64 reserved[2];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_tmf {
+	struct ibmvfc_mad_common common;
+	u64 scsi_id;
+	struct scsi_lun lun;
+	u32 flags;
+#define IBMVFC_TMF_ABORT_TASK		0x02
+#define IBMVFC_TMF_ABORT_TASK_SET	0x04
+#define IBMVFC_TMF_LUN_RESET		0x10
+#define IBMVFC_TMF_TGT_RESET		0x20
+#define IBMVFC_TMF_LUA_VALID		0x40
+	u32 cancel_key;
+	u32 my_cancel_key;
+#define IBMVFC_TMF_CANCEL_KEY		0x80000000
+	u32 pad;
+	u64 reserved[2];
+}__attribute__((packed, aligned (8)));
+
+enum ibmvfc_fcp_rsp_info_codes {
+	RSP_NO_FAILURE		= 0x00,
+	RSP_TMF_REJECTED		= 0x04,
+	RSP_TMF_FAILED		= 0x05,
+	RSP_TMF_INVALID_LUN	= 0x09,
+};
+
+struct ibmvfc_fcp_rsp_info {
+	u16 reserved;
+	u8 rsp_code;
+	u8 reserved2[4];
+}__attribute__((packed, aligned (2)));
+
+enum ibmvfc_fcp_rsp_flags {
+	FCP_BIDI_RSP			= 0x80,
+	FCP_BIDI_READ_RESID_UNDER	= 0x40,
+	FCP_BIDI_READ_RESID_OVER	= 0x20,
+	FCP_CONF_REQ			= 0x10,
+	FCP_RESID_UNDER			= 0x08,
+	FCP_RESID_OVER			= 0x04,
+	FCP_SNS_LEN_VALID			= 0x02,
+	FCP_RSP_LEN_VALID			= 0x01,
+};
+
+union ibmvfc_fcp_rsp_data {
+	struct ibmvfc_fcp_rsp_info info;
+	u8 sense[SCSI_SENSE_BUFFERSIZE + sizeof(struct ibmvfc_fcp_rsp_info)];
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_fcp_rsp {
+	u64 reserved;
+	u16 retry_delay_timer;
+	u8 flags;
+	u8 scsi_status;
+	u32 fcp_resid;
+	u32 fcp_sense_len;
+	u32 fcp_rsp_len;
+	union ibmvfc_fcp_rsp_data data;
+}__attribute__((packed, aligned (8)));
+
+enum ibmvfc_cmd_flags {
+	IBMVFC_SCATTERLIST	= 0x0001,
+	IBMVFC_NO_MEM_DESC	= 0x0002,
+	IBMVFC_READ			= 0x0004,
+	IBMVFC_WRITE		= 0x0008,
+	IBMVFC_TMF			= 0x0080,
+	IBMVFC_CLASS_3_ERR	= 0x0100,
+};
+
+enum ibmvfc_fc_task_attr {
+	IBMVFC_SIMPLE_TASK	= 0x00,
+	IBMVFC_HEAD_OF_QUEUE	= 0x01,
+	IBMVFC_ORDERED_TASK	= 0x02,
+	IBMVFC_ACA_TASK		= 0x04,
+};
+
+enum ibmvfc_fc_tmf_flags {
+	IBMVFC_ABORT_TASK_SET	= 0x02,
+	IBMVFC_LUN_RESET		= 0x10,
+	IBMVFC_TARGET_RESET	= 0x20,
+};
+
+struct ibmvfc_fcp_cmd_iu {
+	struct scsi_lun lun;
+	u8 crn;
+	u8 pri_task_attr;
+	u8 tmf_flags;
+	u8 add_cdb_len;
+#define IBMVFC_RDDATA		0x02
+#define IBMVFC_WRDATA		0x01
+	u8 cdb[IBMVFC_MAX_CDB_LEN];
+	u32 xfer_len;
+}__attribute__((packed, aligned (4)));
+
+struct ibmvfc_cmd {
+	u64 task_tag;
+	u32 frame_type;
+	u32 payload_len;
+	u32 resp_len;
+	u32 adapter_resid;
+	u16 status;
+	u16 error;
+	u16 flags;
+	u16 response_flags;
+#define IBMVFC_ADAPTER_RESID_VALID	0x01
+	u32 cancel_key;
+	u32 exchange_id;
+	struct srp_direct_buf ext_func;
+	struct srp_direct_buf ioba;
+	struct srp_direct_buf resp;
+	u64 correlation;
+	u64 tgt_scsi_id;
+	u64 tag;
+	u64 reserved3[2];
+	struct ibmvfc_fcp_cmd_iu iu;
+	struct ibmvfc_fcp_rsp rsp;
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_trace_start_entry {
+	u32 xfer_len;
+}__attribute__((packed));
+
+struct ibmvfc_trace_end_entry {
+	u16 status;
+	u16 error;
+	u8 fcp_rsp_flags;
+	u8 rsp_code;
+	u8 scsi_status;
+	u8 reserved;
+}__attribute__((packed));
+
+struct ibmvfc_trace_entry {
+	struct ibmvfc_event *evt;
+	u32 time;
+	u32 scsi_id;
+	u32 lun;
+	u8 fmt;
+	u8 op_code;
+	u8 tmf_flags;
+	u8 type;
+#define IBMVFC_TRC_START	0x00
+#define IBMVFC_TRC_END		0xff
+	union {
+		struct ibmvfc_trace_start_entry start;
+		struct ibmvfc_trace_end_entry end;
+	} u;
+}__attribute__((packed, aligned (8)));
+
+enum ibmvfc_crq_formats {
+	IBMVFC_CMD_FORMAT		= 0x01,
+	IBMVFC_ASYNC_EVENT	= 0x02,
+	IBMVFC_MAD_FORMAT		= 0x04,
+};
+
+enum ibmvfc_async_event {
+	IBMVFC_AE_ELS_PLOGI		= 0x0001,
+	IBMVFC_AE_ELS_LOGO		= 0x0002,
+	IBMVFC_AE_ELS_PRLO		= 0x0004,
+	IBMVFC_AE_SCN_NPORT		= 0x0008,
+	IBMVFC_AE_SCN_GROUP		= 0x0010,
+	IBMVFC_AE_SCN_DOMAIN		= 0x0020,
+	IBMVFC_AE_SCN_FABRIC		= 0x0040,
+	IBMVFC_AE_LINK_UP			= 0x0080,
+	IBMVFC_AE_LINK_DOWN		= 0x0100,
+	IBMVFC_AE_LINK_DEAD		= 0x0200,
+	IBMVFC_AE_HALT			= 0x0400,
+	IBMVFC_AE_RESUME			= 0x0800,
+	IBMVFC_AE_ADAPTER_FAILED	= 0x1000,
+};
+
+struct ibmvfc_crq {
+	u8 valid;
+	u8 format;
+	u8 reserved[6];
+	u64 ioba;
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_crq_queue {
+	struct ibmvfc_crq *msgs;
+	int size, cur;
+	dma_addr_t msg_token;
+};
+
+struct ibmvfc_async_crq {
+	u8 valid;
+	u8 pad[3];
+	u32 pad2;
+	u64 event;
+	u64 scsi_id;
+	u64 wwpn;
+	u64 node_name;
+	u64 reserved;
+}__attribute__((packed, aligned (8)));
+
+struct ibmvfc_async_crq_queue {
+	struct ibmvfc_async_crq *msgs;
+	int size, cur;
+	dma_addr_t msg_token;
+};
+
+union ibmvfc_iu {
+	struct ibmvfc_mad_common mad_common;
+	struct ibmvfc_npiv_login_mad npiv_login;
+	struct ibmvfc_discover_targets discover_targets;
+	struct ibmvfc_port_login plogi;
+	struct ibmvfc_process_login prli;
+	struct ibmvfc_query_tgt query_tgt;
+	struct ibmvfc_implicit_logout implicit_logout;
+	struct ibmvfc_tmf tmf;
+	struct ibmvfc_cmd cmd;
+}__attribute__((packed, aligned (8)));
+
+enum ibmvfc_target_action {
+	IBMVFC_TGT_ACTION_NONE = 0,
+	IBMVFC_TGT_ACTION_INIT,
+	IBMVFC_TGT_ACTION_INIT_WAIT,
+	IBMVFC_TGT_ACTION_ADD_RPORT,
+	IBMVFC_TGT_ACTION_DEL_RPORT,
+};
+
+struct ibmvfc_target {
+	struct list_head queue;
+	struct ibmvfc_host *vhost;
+	u64 scsi_id;
+	u64 new_scsi_id;
+	struct fc_rport *rport;
+	int target_id;
+	enum ibmvfc_target_action action;
+	int need_login;
+	int init_retries;
+	struct ibmvfc_service_parms service_parms;
+	struct ibmvfc_service_parms service_parms_change;
+	struct fc_rport_identifiers ids;
+	void (*job_step) (struct ibmvfc_target *);
+	struct kref kref;
+};
+
+/* a unit of work for the hosting partition */
+struct ibmvfc_event {
+	struct list_head queue;
+	struct ibmvfc_host *vhost;
+	struct ibmvfc_target *tgt;
+	struct scsi_cmnd *cmnd;
+	atomic_t free;
+	union ibmvfc_iu *xfer_iu;
+	void (*done) (struct ibmvfc_event *);
+	struct ibmvfc_crq crq;
+	union ibmvfc_iu iu;
+	union ibmvfc_iu *sync_iu;
+	struct srp_direct_buf *ext_list;
+	dma_addr_t ext_list_token;
+	struct completion comp;
+	struct timer_list timer;
+};
+
+/* a pool of event structs for use */
+struct ibmvfc_event_pool {
+	struct ibmvfc_event *events;
+	u32 size;
+	union ibmvfc_iu *iu_storage;
+	dma_addr_t iu_token;
+};
+
+enum ibmvfc_host_action {
+	IBMVFC_HOST_ACTION_NONE = 0,
+	IBMVFC_HOST_ACTION_INIT,
+	IBMVFC_HOST_ACTION_INIT_WAIT,
+	IBMVFC_HOST_ACTION_QUERY,
+	IBMVFC_HOST_ACTION_QUERY_TGTS,
+	IBMVFC_HOST_ACTION_TGT_DEL,
+	IBMVFC_HOST_ACTION_ALLOC_TGTS,
+	IBMVFC_HOST_ACTION_TGT_INIT,
+	IBMVFC_HOST_ACTION_TGT_ADD,
+};
+
+enum ibmvfc_host_state {
+	IBMVFC_NO_CRQ = 0,
+	IBMVFC_INITIALIZING,
+	IBMVFC_ACTIVE,
+	IBMVFC_HALTED,
+	IBMVFC_LINK_DOWN,
+	IBMVFC_LINK_DEAD,
+	IBMVFC_HOST_OFFLINE,
+};
+
+struct ibmvfc_host {
+	char name[8];
+	struct list_head queue;
+	struct Scsi_Host *host;
+	enum ibmvfc_host_state state;
+	enum ibmvfc_host_action action;
+#define IBMVFC_NUM_TRACE_INDEX_BITS		8
+#define IBMVFC_NUM_TRACE_ENTRIES		(1 << IBMVFC_NUM_TRACE_INDEX_BITS)
+#define IBMVFC_TRACE_SIZE	(sizeof(struct ibmvfc_trace_entry) * IBMVFC_NUM_TRACE_ENTRIES)
+	struct ibmvfc_trace_entry *trace;
+	u32 trace_index:IBMVFC_NUM_TRACE_INDEX_BITS;
+	int num_targets;
+	struct list_head targets;
+	struct list_head sent;
+	struct list_head free;
+	struct device *dev;
+	struct ibmvfc_event_pool pool;
+	struct dma_pool *sg_pool;
+	mempool_t *tgt_pool;
+	struct ibmvfc_crq_queue crq;
+	struct ibmvfc_async_crq_queue async_crq;
+	struct ibmvfc_npiv_login login_info;
+	union ibmvfc_npiv_login_data *login_buf;
+	dma_addr_t login_buf_dma;
+	int disc_buf_sz;
+	int log_level;
+	struct ibmvfc_discover_targets_buf *disc_buf;
+	int task_set;
+	int init_retries;
+	int discovery_threads;
+	int client_migrated;
+	int reinit;
+	int events_to_log;
+#define IBMVFC_AE_LINKUP	0x0001
+#define IBMVFC_AE_LINKDOWN	0x0002
+#define IBMVFC_AE_RSCN		0x0004
+	dma_addr_t disc_buf_dma;
+	unsigned int partition_number;
+	char partition_name[97];
+	void (*job_step) (struct ibmvfc_host *);
+	struct task_struct *work_thread;
+	wait_queue_head_t init_wait_q;
+	wait_queue_head_t work_wait_q;
+};
+
+#define DBG_CMD(CMD) do { if (ibmvfc_debug) CMD; } while (0)
+
+#define tgt_dbg(t, fmt, ...)			\
+	DBG_CMD(dev_info((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__))
+
+#define tgt_err(t, fmt, ...)		\
+	dev_err((t)->vhost->dev, "%lX: " fmt, (t)->scsi_id, ##__VA_ARGS__)
+
+#define ibmvfc_dbg(vhost, ...) \
+	DBG_CMD(dev_info((vhost)->dev, ##__VA_ARGS__))
+
+#define ibmvfc_log(vhost, level, ...) \
+	do { \
+		if (level >= (vhost)->log_level) \
+			dev_err((vhost)->dev, ##__VA_ARGS__); \
+	} while (0)
+
+#define ENTER DBG_CMD(printk(KERN_INFO IBMVFC_NAME": Entering %s\n", __FUNCTION__))
+#define LEAVE DBG_CMD(printk(KERN_INFO IBMVFC_NAME": Leaving %s\n", __FUNCTION__))
+
+#ifdef CONFIG_SCSI_IBMVFC_TRACE
+#define ibmvfc_create_trace_file(kobj, attr) sysfs_create_bin_file(kobj, attr)
+#define ibmvfc_remove_trace_file(kobj, attr) sysfs_remove_bin_file(kobj, attr)
+#else
+#define ibmvfc_create_trace_file(kobj, attr) 0
+#define ibmvfc_remove_trace_file(kobj, attr) do { } while (0)
+#endif
+
+#endif
