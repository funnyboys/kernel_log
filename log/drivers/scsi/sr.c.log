commit 3df83e164f1f39c614a3f31e39164756945ae2ea
Merge: 91fa58840ae2 42c76c9848e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 13 13:17:49 2020 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull more SCSI updates from James Bottomley:
     "This is the set of changes collected since just before the merge
      window opened. It's mostly minor fixes in drivers.
    
      The one non-driver set is the three optical disk (sr) changes where
      two are error path fixes and one is a helper conversion.
    
      The big driver change is the hpsa compat_alloc_userspace rework by Al
      so he can kill the remaining user. This has been tested and acked by
      the maintainer"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (21 commits)
      scsi: acornscsi: Fix an error handling path in acornscsi_probe()
      scsi: storvsc: Remove memset before memory freeing in storvsc_suspend()
      scsi: cxlflash: Remove an unnecessary NULL check
      scsi: ibmvscsi: Don't send host info in adapter info MAD after LPM
      scsi: sr: Fix sr_probe() missing deallocate of device minor
      scsi: sr: Fix sr_probe() missing mutex_destroy
      scsi: st: Convert convert get_user_pages() --> pin_user_pages()
      scsi: target: Rename target_setup_cmd_from_cdb() to target_cmd_parse_cdb()
      scsi: target: Fix NULL pointer dereference
      scsi: target: Initialize LUN in transport_init_se_cmd()
      scsi: target: Factor out a new helper, target_cmd_init_cdb()
      scsi: hpsa: hpsa_ioctl(): Tidy up a bit
      scsi: hpsa: Get rid of compat_alloc_user_space()
      scsi: hpsa: Don't bother with vmalloc for BIG_IOCTL_Command_struct
      scsi: hpsa: Lift {BIG_,}IOCTL_Command_struct copy{in,out} into hpsa_ioctl()
      scsi: ufs: Remove redundant urgent_bkop_lvl initialization
      scsi: ufs: Don't update urgent bkops level when toggling auto bkops
      scsi: qedf: Remove redundant initialization of variable rc
      scsi: mpt3sas: Fix memset() in non-RDPQ mode
      scsi: iscsi: Fix reference count leak in iscsi_boot_create_kobj
      ...

commit 6555781b3fdec5e94e6914511496144241df7dee
Author: Simon Arlott <simon@octiron.net>
Date:   Sat May 30 18:59:44 2020 +0100

    scsi: sr: Fix sr_probe() missing deallocate of device minor
    
    If the cdrom fails to be registered then the device minor should be
    deallocated.
    
    Link: https://lore.kernel.org/r/072dac4b-8402-4de8-36bd-47e7588969cd@0882a8b5-c6c3-11e9-b005-00805fc181fe
    Signed-off-by: Simon Arlott <simon@octiron.net>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 59718903e1ef..b9cff27e2c81 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -793,7 +793,7 @@ static int sr_probe(struct device *dev)
 	cd->cdi.disk = disk;
 
 	if (register_cdrom(&cd->cdi))
-		goto fail_put;
+		goto fail_minor;
 
 	/*
 	 * Initialize block layer runtime PM stuffs before the
@@ -811,6 +811,10 @@ static int sr_probe(struct device *dev)
 
 	return 0;
 
+fail_minor:
+	spin_lock(&sr_index_lock);
+	clear_bit(minor, sr_index_bits);
+	spin_unlock(&sr_index_lock);
 fail_put:
 	put_disk(disk);
 	mutex_destroy(&cd->lock);

commit a247e07f8dadba5da9f188aaf4f96db0302146d9
Author: Simon Arlott <simon@octiron.net>
Date:   Sat May 30 18:58:25 2020 +0100

    scsi: sr: Fix sr_probe() missing mutex_destroy
    
    If the device minor cannot be allocated or the cdrom fails to be registered
    then the mutex should be destroyed.
    
    Link: https://lore.kernel.org/r/06e9de38-eeed-1cab-5e08-e889288935b3@0882a8b5-c6c3-11e9-b005-00805fc181fe
    Fixes: 51a858817dcd ("scsi: sr: get rid of sr global mutex")
    Signed-off-by: Simon Arlott <simon@octiron.net>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 7727893238c7..59718903e1ef 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -813,6 +813,7 @@ static int sr_probe(struct device *dev)
 
 fail_put:
 	put_disk(disk);
+	mutex_destroy(&cd->lock);
 fail_free:
 	kfree(cd);
 fail:

commit 818dbde78e0f4f11c9f804c36913a7ccfc2e87ad
Merge: 242b23319809 22617e216331
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 5 15:11:50 2020 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     :This series consists of the usual driver updates (qla2xxx, ufs, zfcp,
      target, scsi_debug, lpfc, qedi, qedf, hisi_sas, mpt3sas) plus a host
      of other minor updates.
    
      There are no major core changes in this series apart from a
      refactoring in scsi_lib.c"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (207 commits)
      scsi: ufs: ti-j721e-ufs: Fix unwinding of pm_runtime changes
      scsi: cxgb3i: Fix some leaks in init_act_open()
      scsi: ibmvscsi: Make some functions static
      scsi: iscsi: Fix deadlock on recovery path during GFP_IO reclaim
      scsi: ufs: Fix WriteBooster flush during runtime suspend
      scsi: ufs: Fix index of attributes query for WriteBooster feature
      scsi: ufs: Allow WriteBooster on UFS 2.2 devices
      scsi: ufs: Remove unnecessary memset for dev_info
      scsi: ufs-qcom: Fix scheduling while atomic issue
      scsi: mpt3sas: Fix reply queue count in non RDPQ mode
      scsi: lpfc: Fix lpfc_nodelist leak when processing unsolicited event
      scsi: target: tcmu: Fix a use after free in tcmu_check_expired_queue_cmd()
      scsi: vhost: Notify TCM about the maximum sg entries supported per command
      scsi: qla2xxx: Remove return value from qla_nvme_ls()
      scsi: qla2xxx: Remove an unused function
      scsi: iscsi: Register sysfs for iscsi workqueue
      scsi: scsi_debug: Parser tables and code interaction
      scsi: core: Refactor scsi_mq_setup_tags function
      scsi: core: Fix incorrect usage of shost_for_each_device
      scsi: qla2xxx: Fix endianness annotations in source files
      ...

commit a711d91cd97e6c9a554ccd1652527a7f36661857
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 25 09:57:00 2020 +0200

    block: add a cdrom_device_info pointer to struct gendisk
    
    Add a pointer to the CDROM information structure to struct gendisk.
    This will allow various removable media file systems to call directly
    into the CDROM layer instead of abusing ioctls with kernel pointers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d2fe3fa470f9..f9b589d60a46 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -794,9 +794,8 @@ static int sr_probe(struct device *dev)
 	set_capacity(disk, cd->capacity);
 	disk->private_data = &cd->driver;
 	disk->queue = sdev->request_queue;
-	cd->cdi.disk = disk;
 
-	if (register_cdrom(&cd->cdi))
+	if (register_cdrom(disk, &cd->cdi))
 		goto fail_put;
 
 	/*

commit 655da8e57a46c009a07373c4fdcf9221b5a9b9a6
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sun Apr 26 18:48:44 2020 -0700

    scsi: sr: Use {get,put}_unaligned_be*() instead of open-coding these functions
    
    This patch makes the sr code slightly easier to read.
    
    Link: https://lore.kernel.org/r/20200427014844.12109-1-bvanassche@acm.org
    Cc: Merlijn Wajer <merlijn@archive.org>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d2fe3fa470f9..7727893238c7 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -51,6 +51,8 @@
 #include <linux/pm_runtime.h>
 #include <linux/uaccess.h>
 
+#include <asm/unaligned.h>
+
 #include <scsi/scsi.h>
 #include <scsi/scsi_dbg.h>
 #include <scsi/scsi_device.h>
@@ -344,10 +346,8 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 		case ILLEGAL_REQUEST:
 			if (!(SCpnt->sense_buffer[0] & 0x90))
 				break;
-			error_sector = (SCpnt->sense_buffer[3] << 24) |
-				(SCpnt->sense_buffer[4] << 16) |
-				(SCpnt->sense_buffer[5] << 8) |
-				SCpnt->sense_buffer[6];
+			error_sector =
+				get_unaligned_be32(&SCpnt->sense_buffer[3]);
 			if (SCpnt->request->bio != NULL)
 				block_sectors =
 					bio_sectors(SCpnt->request->bio);
@@ -495,13 +495,9 @@ static blk_status_t sr_init_command(struct scsi_cmnd *SCpnt)
 		SCpnt->sdb.length = this_count * s_size;
 	}
 
-	SCpnt->cmnd[2] = (unsigned char) (block >> 24) & 0xff;
-	SCpnt->cmnd[3] = (unsigned char) (block >> 16) & 0xff;
-	SCpnt->cmnd[4] = (unsigned char) (block >> 8) & 0xff;
-	SCpnt->cmnd[5] = (unsigned char) block & 0xff;
+	put_unaligned_be32(block, &SCpnt->cmnd[2]);
 	SCpnt->cmnd[6] = SCpnt->cmnd[9] = 0;
-	SCpnt->cmnd[7] = (unsigned char) (this_count >> 8) & 0xff;
-	SCpnt->cmnd[8] = (unsigned char) this_count & 0xff;
+	put_unaligned_be16(this_count, &SCpnt->cmnd[7]);
 
 	/*
 	 * We shouldn't disconnect in the middle of a sector, so with a dumb
@@ -854,8 +850,7 @@ static void get_sectorsize(struct scsi_cd *cd)
 	} else {
 		long last_written;
 
-		cd->capacity = 1 + ((buffer[0] << 24) | (buffer[1] << 16) |
-				    (buffer[2] << 8) | buffer[3]);
+		cd->capacity = 1 + get_unaligned_be32(&buffer[0]);
 		/*
 		 * READ_CAPACITY doesn't return the correct size on
 		 * certain UDF media.  If last_written is larger, use
@@ -866,8 +861,7 @@ static void get_sectorsize(struct scsi_cd *cd)
 		if (!cdrom_get_last_written(&cd->cdi, &last_written))
 			cd->capacity = max_t(long, cd->capacity, last_written);
 
-		sector_size = (buffer[4] << 24) |
-		    (buffer[5] << 16) | (buffer[6] << 8) | buffer[7];
+		sector_size = get_unaligned_be32(&buffer[4]);
 		switch (sector_size) {
 			/*
 			 * HP 4020i CD-Recorder reports 2340 byte sectors
@@ -955,13 +949,13 @@ static void get_capabilities(struct scsi_cd *cd)
 	}
 
 	n = data.header_length + data.block_descriptor_length;
-	cd->cdi.speed = ((buffer[n + 8] << 8) + buffer[n + 9]) / 176;
+	cd->cdi.speed = get_unaligned_be16(&buffer[n + 8]) / 176;
 	cd->readcd_known = 1;
 	cd->readcd_cdda = buffer[n + 5] & 0x01;
 	/* print some capability bits */
 	sr_printk(KERN_INFO, cd,
 		  "scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s\n",
-		  ((buffer[n + 14] << 8) + buffer[n + 15]) / 176,
+		  get_unaligned_be16(&buffer[n + 14]) / 176,
 		  cd->cdi.speed,
 		  buffer[n + 3] & 0x01 ? "writer " : "", /* CD Writer */
 		  buffer[n + 3] & 0x20 ? "dvd-ram " : "",

commit 93f3321f650c5e700478ee8ed2e118d8255095cd
Merge: f8693b3eb59f 1b55940b9bcc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 10 12:21:11 2020 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull more SCSI updates from James Bottomley:
     "This is a batch of changes that didn't make it in the initial pull
      request because the lpfc series had to be rebased to redo an incorrect
      split.
    
      It's basically driver updates to lpfc, target, bnx2fc and ufs with the
      rest being minor updates except the sr_block_release one which fixes a
      use after free introduced by the removal of the global mutex in the
      first patch set"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (35 commits)
      scsi: core: Add DID_ALLOC_FAILURE and DID_MEDIUM_ERROR to hostbyte_table
      scsi: ufs: Use ufshcd_config_pwr_mode() when scaling gear
      scsi: bnx2fc: fix boolreturn.cocci warnings
      scsi: zfcp: use fallthrough;
      scsi: aacraid: do not overwrite retval in aac_reset_adapter()
      scsi: sr: Fix sr_block_release()
      scsi: aic7xxx: Remove more FreeBSD-specific code
      scsi: mpt3sas: Fix kernel panic observed on soft HBA unplug
      scsi: ufs: set device as active power mode after resetting device
      scsi: iscsi: Report unbind session event when the target has been removed
      scsi: lpfc: Change default SCSI LUN QD to 64
      scsi: libfc: rport state move to PLOGI if all PRLI retry exhausted
      scsi: libfc: If PRLI rejected, move rport to PLOGI state
      scsi: bnx2fc: Update the driver version to 2.12.13
      scsi: bnx2fc: Fix SCSI command completion after cleanup is posted
      scsi: bnx2fc: Process the RQE with CQE in interrupt context
      scsi: target: use the stack for XCOPY passthrough cmds
      scsi: target: increase XCOPY I/O size
      scsi: target: avoid per-loop XCOPY buffer allocations
      scsi: target: drop xcopy DISK BLOCK LENGTH debug
      ...

commit 79f51b7b9c4719303f758ae8406c4e5997ed6aa3
Merge: e109f5060741 ff275db92c93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 2 17:03:53 2020 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This series has a huge amount of churn because it pulls in Mauro's doc
      update changing all our txt files to rst ones.
    
      Excluding that, we have the usual driver updates (qla2xxx, ufs, lpfc,
      zfcp, ibmvfc, pm80xx, aacraid), a treewide update for scnprintf and
      some other minor updates.
    
      The major core change is Hannes moving functions out of the aacraid
      driver and into the core"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (223 commits)
      scsi: aic7xxx: aic97xx: Remove FreeBSD-specific code
      scsi: ufs: Do not rely on prefetched data
      scsi: dc395x: remove dc395x_bios_param
      scsi: libiscsi: Fix error count for active session
      scsi: hpsa: correct race condition in offload enabled
      scsi: message: fusion: Replace zero-length array with flexible-array member
      scsi: qedi: Add PCI shutdown handler support
      scsi: qedi: Add MFW error recovery process
      scsi: ufs: Enable block layer runtime PM for well-known logical units
      scsi: ufs-qcom: Override devfreq parameters
      scsi: ufshcd: Let vendor override devfreq parameters
      scsi: ufshcd: Update the set frequency to devfreq
      scsi: ufs: Resume ufs host before accessing ufs device
      scsi: ufs-mediatek: customize the delay for enabling host
      scsi: ufs: make HCE polling more compact to improve initialization latency
      scsi: ufs: allow custom delay prior to host enabling
      scsi: ufs-mediatek: use common delay function
      scsi: ufs: introduce common and flexible delay function
      scsi: ufs: use an enum for host capabilities
      scsi: ufs: fix uninitialized tx_lanes in ufshcd_disable_tx_lcc()
      ...

commit 72655c0ebd1d941d80f47bf614b02d563a1e61ae
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Sun Mar 29 19:51:51 2020 -0700

    scsi: sr: Fix sr_block_release()
    
    This patch fixes the following two complaints:
    
    WARNING: CPU: 3 PID: 1326 at kernel/locking/mutex-debug.c:103 mutex_destroy+0x74/0x80
    Modules linked in: scsi_debug sd_mod t10_pi brd scsi_transport_iscsi af_packet crct10dif_pclmul sg aesni_intel glue_helper virtio_balloon button crypto_simd cryptd intel_agp intel_gtt agpgart ip_tables x_tables ipv6 nf_defrag_ipv6 autofs4 ext4 crc16 mbcache jbd2 hid_generic usbhid hid sr_mod cdrom ata_generic pata_acpi virtio_blk virtio_net net_failover failover ata_piix xhci_pci ahci libahci xhci_hcd i2c_piix4 libata virtio_pci usbcore i2c_core virtio_ring scsi_mod usb_common virtio [last unloaded: scsi_debug]
    CPU: 3 PID: 1326 Comm: systemd-udevd Not tainted 5.6.0-rc1-dbg+ #1
    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    RIP: 0010:mutex_destroy+0x74/0x80
    Call Trace:
     sr_kref_release+0xb9/0xd0 [sr_mod]
     scsi_cd_put+0x79/0x90 [sr_mod]
     sr_block_release+0x54/0x70 [sr_mod]
     __blkdev_put+0x2ce/0x3c0
     blkdev_put+0x68/0x220
     blkdev_close+0x4d/0x60
     __fput+0x170/0x3b0
     ____fput+0x12/0x20
     task_work_run+0xa2/0xf0
     exit_to_usermode_loop+0xeb/0xf0
     do_syscall_64+0x2be/0x300
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x7fa16d40aab7
    
    BUG: KASAN: use-after-free in __mutex_unlock_slowpath+0x98/0x420
    Read of size 8 at addr ffff8881c6e4f4b0 by task systemd-udevd/1326
    
    CPU: 3 PID: 1326 Comm: systemd-udevd Tainted: G        W         5.6.0-rc1-dbg+ #1
    Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
    Call Trace:
     dump_stack+0xa5/0xe6
     print_address_description.constprop.0+0x46/0x60
     __kasan_report.cold+0x7b/0x94
     kasan_report+0x16/0x20
     check_memory_region+0x140/0x1b0
     __kasan_check_read+0x15/0x20
     __mutex_unlock_slowpath+0x98/0x420
     mutex_unlock+0x16/0x20
     sr_block_release+0x5c/0x70 [sr_mod]
     __blkdev_put+0x2ce/0x3c0
    hardirqs last  enabled at (1875522): [<ffffffff81bb0696>] _raw_spin_unlock_irqrestore+0x56/0x70
     blkdev_put+0x68/0x220
     blkdev_close+0x4d/0x60
     __fput+0x170/0x3b0
     ____fput+0x12/0x20
     task_work_run+0xa2/0xf0
     exit_to_usermode_loop+0xeb/0xf0
     do_syscall_64+0x2be/0x300
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x7fa16d40aab7
    
    Allocated by task 3201:
     save_stack+0x23/0x90
     __kasan_kmalloc.constprop.0+0xcf/0xe0
     kasan_kmalloc+0xd/0x10
     kmem_cache_alloc_trace+0x161/0x3c0
     sr_probe+0x12f/0xb60 [sr_mod]
     really_probe+0x183/0x5d0
     driver_probe_device+0x13f/0x1a0
     __device_attach_driver+0xe6/0x150
     bus_for_each_drv+0x101/0x160
     __device_attach+0x183/0x230
     device_initial_probe+0x17/0x20
     bus_probe_device+0x110/0x130
     device_add+0xb7b/0xd40
     scsi_sysfs_add_sdev+0xe8/0x360 [scsi_mod]
     scsi_probe_and_add_lun+0xdc4/0x14c0 [scsi_mod]
     __scsi_scan_target+0x12d/0x850 [scsi_mod]
     scsi_scan_channel+0xcd/0xe0 [scsi_mod]
     scsi_scan_host_selected+0x182/0x190 [scsi_mod]
     store_scan+0x1e9/0x200 [scsi_mod]
     dev_attr_store+0x42/0x60
     sysfs_kf_write+0x8b/0xb0
     kernfs_fop_write+0x158/0x250
     __vfs_write+0x4c/0x90
     vfs_write+0x145/0x2c0
     ksys_write+0xd7/0x180
     __x64_sys_write+0x47/0x50
     do_syscall_64+0x6f/0x300
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Freed by task 1326:
     save_stack+0x23/0x90
     __kasan_slab_free+0x13a/0x190
     kasan_slab_free+0x12/0x20
     kfree+0x109/0x410
     sr_kref_release+0xc1/0xd0 [sr_mod]
     scsi_cd_put+0x79/0x90 [sr_mod]
     sr_block_release+0x54/0x70 [sr_mod]
     __blkdev_put+0x2ce/0x3c0
     blkdev_put+0x68/0x220
     blkdev_close+0x4d/0x60
     __fput+0x170/0x3b0
     ____fput+0x12/0x20
     task_work_run+0xa2/0xf0
     exit_to_usermode_loop+0xeb/0xf0
     do_syscall_64+0x2be/0x300
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Link: https://lore.kernel.org/r/20200330025151.10535-1-bvanassche@acm.org
    Fixes: 51a858817dcd ("scsi: sr: get rid of sr global mutex")
    Cc: Merlijn Wajer <merlijn@archive.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: <stable@kernel.org>
    Acked-by: Merlijn Wajer <merlijn@archive.org>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index fe0e1c721a99..2483100dc144 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -550,10 +550,12 @@ static int sr_block_open(struct block_device *bdev, fmode_t mode)
 static void sr_block_release(struct gendisk *disk, fmode_t mode)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
+
 	mutex_lock(&cd->lock);
 	cdrom_release(&cd->cdi, mode);
-	scsi_cd_put(cd);
 	mutex_unlock(&cd->lock);
+
+	scsi_cd_put(cd);
 }
 
 static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,

commit 03264ddde2453f6877a7d637d84068079632a3c5
Author: Adam Williamson <awilliam@redhat.com>
Date:   Wed Feb 19 17:50:07 2020 +0100

    scsi: compat_ioctl: cdrom: Replace .ioctl with .compat_ioctl in four appropriate places
    
    Arnd Bergmann inadvertently typoed these in d320a9551e394 and 64cbfa96551a;
    they seem to be the cause of
    https://bugzilla.redhat.com/show_bug.cgi?id=1801353 , invalid SCSI commands
    when udev tries to query a DVD drive.
    
    [arnd] Found another instance of the same bug, also introduced in my
    compat_ioctl series.
    
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1801353
    Link: https://lore.kernel.org/r/20200219165139.3467320-1-arnd@arndb.de
    Fixes: c103d6ee69f9 ("compat_ioctl: ide: floppy: add handler")
    Fixes: 64cbfa96551a ("compat_ioctl: move cdrom commands into cdrom.c")
    Fixes: d320a9551e39 ("compat_ioctl: scsi: move ioctl handling into drivers")
    Bisected-by: Chris Murphy <bugzilla@colorremedies.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Adam Williamson <awilliam@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0fbb8fe6e521..e4240e4ae8bb 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -688,7 +688,7 @@ static const struct block_device_operations sr_bdops =
 	.release	= sr_block_release,
 	.ioctl		= sr_block_ioctl,
 #ifdef CONFIG_COMPAT
-	.ioctl		= sr_block_compat_ioctl,
+	.compat_ioctl	= sr_block_compat_ioctl,
 #endif
 	.check_events	= sr_block_check_events,
 	.revalidate_disk = sr_block_revalidate_disk,

commit 51a858817dcdbbdee22cb54b0b2b26eb145ca5b6
Author: Merlijn Wajer <merlijn@archive.org>
Date:   Tue Feb 18 15:39:17 2020 +0100

    scsi: sr: get rid of sr global mutex
    
    When replacing the Big Kernel Lock in commit 2a48fc0ab242 ("block:
    autoconvert trivial BKL users to private mutex"), the lock was replaced
    with a sr-wide lock.
    
    This causes very poor performance when using multiple sr devices, as the sr
    driver was not able to execute more than one command to one drive at any
    given time, even when there were many CD drives available.
    
    Replace the global mutex with per-sr-device mutex.
    
    Someone tried this patch at the time, but it never made it upstream, due to
    possible concerns with race conditions, but it's not clear the patch
    actually caused those:
    
    https://www.spinics.net/lists/linux-scsi/msg63706.html
    https://www.spinics.net/lists/linux-scsi/msg63750.html
    
    Also see
    
    http://lists.xiph.org/pipermail/paranoia/2019-December/001647.html
    
    Link: https://lore.kernel.org/r/20200218143918.30267-1-merlijn@archive.org
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Merlijn Wajer <merlijn@archive.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0fbb8fe6e521..fe0e1c721a99 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -79,7 +79,6 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 	 CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_DVD_RAM|CDC_GENERIC_PACKET| \
 	 CDC_MRW|CDC_MRW_W|CDC_RAM)
 
-static DEFINE_MUTEX(sr_mutex);
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
 static blk_status_t sr_init_command(struct scsi_cmnd *SCpnt);
@@ -536,9 +535,9 @@ static int sr_block_open(struct block_device *bdev, fmode_t mode)
 	scsi_autopm_get_device(sdev);
 	check_disk_change(bdev);
 
-	mutex_lock(&sr_mutex);
+	mutex_lock(&cd->lock);
 	ret = cdrom_open(&cd->cdi, bdev, mode);
-	mutex_unlock(&sr_mutex);
+	mutex_unlock(&cd->lock);
 
 	scsi_autopm_put_device(sdev);
 	if (ret)
@@ -551,10 +550,10 @@ static int sr_block_open(struct block_device *bdev, fmode_t mode)
 static void sr_block_release(struct gendisk *disk, fmode_t mode)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
-	mutex_lock(&sr_mutex);
+	mutex_lock(&cd->lock);
 	cdrom_release(&cd->cdi, mode);
 	scsi_cd_put(cd);
-	mutex_unlock(&sr_mutex);
+	mutex_unlock(&cd->lock);
 }
 
 static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
@@ -565,7 +564,7 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	void __user *argp = (void __user *)arg;
 	int ret;
 
-	mutex_lock(&sr_mutex);
+	mutex_lock(&cd->lock);
 
 	ret = scsi_ioctl_block_when_processing_errors(sdev, cmd,
 			(mode & FMODE_NDELAY) != 0);
@@ -595,7 +594,7 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	scsi_autopm_put_device(sdev);
 
 out:
-	mutex_unlock(&sr_mutex);
+	mutex_unlock(&cd->lock);
 	return ret;
 }
 
@@ -608,7 +607,7 @@ static int sr_block_compat_ioctl(struct block_device *bdev, fmode_t mode, unsign
 	void __user *argp = compat_ptr(arg);
 	int ret;
 
-	mutex_lock(&sr_mutex);
+	mutex_lock(&cd->lock);
 
 	ret = scsi_ioctl_block_when_processing_errors(sdev, cmd,
 			(mode & FMODE_NDELAY) != 0);
@@ -638,7 +637,7 @@ static int sr_block_compat_ioctl(struct block_device *bdev, fmode_t mode, unsign
 	scsi_autopm_put_device(sdev);
 
 out:
-	mutex_unlock(&sr_mutex);
+	mutex_unlock(&cd->lock);
 	return ret;
 
 }
@@ -745,6 +744,7 @@ static int sr_probe(struct device *dev)
 	disk = alloc_disk(1);
 	if (!disk)
 		goto fail_free;
+	mutex_init(&cd->lock);
 
 	spin_lock(&sr_index_lock);
 	minor = find_first_zero_bit(sr_index_bits, SR_DISKS);
@@ -1055,6 +1055,8 @@ static void sr_kref_release(struct kref *kref)
 
 	put_disk(disk);
 
+	mutex_destroy(&cd->lock);
+
 	kfree(cd);
 }
 

commit 64cbfa96551a1511b9babef06afa06a1c6c4e8f5
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 28 15:55:17 2019 +0100

    compat_ioctl: move cdrom commands into cdrom.c
    
    There is no need for the special cases for the cdrom ioctls any more now,
    so make sure that each cdrom driver has a .compat_ioctl() callback and
    calls cdrom_compat_ioctl() directly there.
    
    Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index f1e7aab00ce3..0fbb8fe6e521 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -628,12 +628,8 @@ static int sr_block_compat_ioctl(struct block_device *bdev, fmode_t mode, unsign
 		goto put;
 	}
 
-	/*
-	 * CDROM ioctls are handled in the block layer, but
-	 * do the scsi blk ioctls here.
-	 */
-	ret = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);
-	if (ret != -ENOTTY)
+	ret = cdrom_ioctl(&cd->cdi, bdev, mode, cmd, (unsigned long)argp);
+	if (ret != -ENOSYS)
 		goto put;
 
 	ret = scsi_compat_ioctl(sdev, cmd, argp);

commit d320a9551e394cb2d842fd32d28e9805c2a18fbb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 15 17:39:44 2019 +0100

    compat_ioctl: scsi: move ioctl handling into drivers
    
    Each driver calling scsi_ioctl() gets an equivalent compat_ioctl()
    handler that implements the same commands by calling scsi_compat_ioctl().
    
    The scsi_cmd_ioctl() and scsi_cmd_blk_ioctl() functions are compatible
    at this point, so any driver that calls those can do so for both native
    and compat mode, with the argument passed through compat_ptr().
    
    With this, we can remove the entries from fs/compat_ioctl.c.  The new
    code is larger, but should be easier to maintain and keep updated with
    newly added commands.
    
    Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 4664fdf75c0f..f1e7aab00ce3 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -38,6 +38,7 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/bio.h>
+#include <linux/compat.h>
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/cdrom.h>
@@ -598,6 +599,55 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	return ret;
 }
 
+#ifdef CONFIG_COMPAT
+static int sr_block_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
+			  unsigned long arg)
+{
+	struct scsi_cd *cd = scsi_cd(bdev->bd_disk);
+	struct scsi_device *sdev = cd->device;
+	void __user *argp = compat_ptr(arg);
+	int ret;
+
+	mutex_lock(&sr_mutex);
+
+	ret = scsi_ioctl_block_when_processing_errors(sdev, cmd,
+			(mode & FMODE_NDELAY) != 0);
+	if (ret)
+		goto out;
+
+	scsi_autopm_get_device(sdev);
+
+	/*
+	 * Send SCSI addressing ioctls directly to mid level, send other
+	 * ioctls to cdrom/block level.
+	 */
+	switch (cmd) {
+	case SCSI_IOCTL_GET_IDLUN:
+	case SCSI_IOCTL_GET_BUS_NUMBER:
+		ret = scsi_compat_ioctl(sdev, cmd, argp);
+		goto put;
+	}
+
+	/*
+	 * CDROM ioctls are handled in the block layer, but
+	 * do the scsi blk ioctls here.
+	 */
+	ret = scsi_cmd_blk_ioctl(bdev, mode, cmd, argp);
+	if (ret != -ENOTTY)
+		goto put;
+
+	ret = scsi_compat_ioctl(sdev, cmd, argp);
+
+put:
+	scsi_autopm_put_device(sdev);
+
+out:
+	mutex_unlock(&sr_mutex);
+	return ret;
+
+}
+#endif
+
 static unsigned int sr_block_check_events(struct gendisk *disk,
 					  unsigned int clearing)
 {
@@ -641,12 +691,11 @@ static const struct block_device_operations sr_bdops =
 	.open		= sr_block_open,
 	.release	= sr_block_release,
 	.ioctl		= sr_block_ioctl,
+#ifdef CONFIG_COMPAT
+	.ioctl		= sr_block_compat_ioctl,
+#endif
 	.check_events	= sr_block_check_events,
 	.revalidate_disk = sr_block_revalidate_disk,
-	/* 
-	 * No compat_ioctl for now because sr_block_ioctl never
-	 * seems to pass arbitrary ioctls down to host drivers.
-	 */
 };
 
 static int sr_open(struct cdrom_device_info *cdi, int purpose)

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index c3f443d5aea8..4664fdf75c0f 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  sr.c Copyright (C) 1992 David Giller
  *           Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale

commit c92e2f04b35938da23eb9a7f7101cbdd5ac7cdc4
Author: Martin Wilck <mwilck@suse.com>
Date:   Wed Mar 27 14:51:02 2019 +0100

    block: disk_events: introduce event flags
    
    Currently, an empty disk->events field tells the block layer not to
    forward media change events to user space. This was done in commit
    7c88a168da80 ("block: don't propagate unlisted DISK_EVENTs to userland")
    in order to avoid events from "fringe" drivers to be forwarded to user
    space. By doing so, the block layer lost the information which events
    were supported by a particular block device, and most importantly,
    whether or not a given device supports media change events at all.
    
    Prepare for not interpreting the "events" field this way in the future
    any more. This is done by adding an additional field "event_flags" to
    struct gendisk, and two flag bits that can be set to have the device
    treated like one that had the "events" field set to a non-zero value
    before. This applies only to the sd and sr drivers, which are changed to
    set the new flags.
    
    The new flags are DISK_EVENT_FLAG_POLL to enforce polling of the device
    for synchronous events, and DISK_EVENT_FLAG_UEVENT to tell the
    blocklayer to generate udev events from kernel events.
    
    In order to add the event_flags field to struct gendisk, the events
    field is converted to an "unsigned short"; it doesn't need to hold
    values bigger than 2 anyway.
    
    This patch doesn't change behavior.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin Wilck <mwilck@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 039c27c2d7b3..c3f443d5aea8 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -716,6 +716,7 @@ static int sr_probe(struct device *dev)
 	disk->fops = &sr_bdops;
 	disk->flags = GENHD_FL_CD | GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
 	disk->events = DISK_EVENT_MEDIA_CHANGE | DISK_EVENT_EJECT_REQUEST;
+	disk->event_flags = DISK_EVENT_FLAG_POLL | DISK_EVENT_FLAG_UEVENT;
 
 	blk_queue_rq_timeout(sdev->request_queue, SR_TIMEOUT);
 

commit b9f91992991b27e72d93113095b9b92919ed0b71
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 8 09:32:43 2018 +0100

    scsi: stop setting up request->special
    
    No more need in a blk-mq world where the scsi command and request are
    allocated together.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 38ddbbfe5f3c..039c27c2d7b3 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -394,7 +394,6 @@ static blk_status_t sr_init_command(struct scsi_cmnd *SCpnt)
 	ret = scsi_init_io(SCpnt);
 	if (ret != BLK_STS_OK)
 		goto out;
-	WARN_ON_ONCE(SCpnt != rq->special);
 	cd = scsi_cd(rq->rq_disk);
 
 	/* from here on until we're complete, any goto out

commit 159b2cbf59f44f2a0c005c1f323f8f05fb0a19f8
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Nov 9 14:42:39 2018 +0100

    scsi: return blk_status_t from scsi_init_io and ->init_command
    
    Replace the old BLKPREP_* values with the BLK_STS_ ones that they are
    converted to later anyway.
    
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 54dd70ae9731..38ddbbfe5f3c 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -80,7 +80,7 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 static DEFINE_MUTEX(sr_mutex);
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
-static int sr_init_command(struct scsi_cmnd *SCpnt);
+static blk_status_t sr_init_command(struct scsi_cmnd *SCpnt);
 static int sr_done(struct scsi_cmnd *);
 static int sr_runtime_suspend(struct device *dev);
 
@@ -384,22 +384,22 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 	return good_bytes;
 }
 
-static int sr_init_command(struct scsi_cmnd *SCpnt)
+static blk_status_t sr_init_command(struct scsi_cmnd *SCpnt)
 {
 	int block = 0, this_count, s_size;
 	struct scsi_cd *cd;
 	struct request *rq = SCpnt->request;
-	int ret;
+	blk_status_t ret;
 
 	ret = scsi_init_io(SCpnt);
-	if (ret != BLKPREP_OK)
+	if (ret != BLK_STS_OK)
 		goto out;
 	WARN_ON_ONCE(SCpnt != rq->special);
 	cd = scsi_cd(rq->rq_disk);
 
 	/* from here on until we're complete, any goto out
 	 * is used for a killable error condition */
-	ret = BLKPREP_KILL;
+	ret = BLK_STS_IOERR;
 
 	SCSI_LOG_HLQUEUE(1, scmd_printk(KERN_INFO, SCpnt,
 		"Doing sr request, block = %d\n", block));
@@ -516,7 +516,7 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	 * This indicates that the command is ready from our end to be
 	 * queued.
 	 */
-	ret = BLKPREP_OK;
+	ret = BLK_STS_OK;
  out:
 	return ret;
 }

commit fef912bf860e8e7e48a2bfb978a356bba743a8b7
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Sep 28 08:17:19 2018 +0200

    block: genhd: add 'groups' argument to device_add_disk
    
    Update device_add_disk() to take an 'groups' argument so that
    individual drivers can register a device with additional sysfs
    attributes.
    This avoids race condition the driver would otherwise have if these
    groups were to be created with sysfs_add_groups().
    
    Signed-off-by: Martin Wilck <martin.wilck@suse.com>
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 4f07b3410595..54dd70ae9731 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -759,7 +759,7 @@ static int sr_probe(struct device *dev)
 
 	dev_set_drvdata(dev, cd);
 	disk->flags |= GENHD_FL_REMOVABLE;
-	device_add_disk(&sdev->sdev_gendev, disk);
+	device_add_disk(&sdev->sdev_gendev, disk, NULL);
 
 	sdev_printk(KERN_DEBUG, sdev,
 		    "Attached scsi CD-ROM %s\n", cd->cdi.name);

commit bca6b067b0b269a7b8ba129e2a918309ca8b4a55
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Wed Sep 26 14:01:03 2018 -0700

    block: Move power management code into a new source file
    
    Move the code for runtime power management from blk-core.c into the
    new source file blk-pm.c. Move the corresponding declarations from
    <linux/blkdev.h> into <linux/blk-pm.h>. For CONFIG_PM=n, leave out
    the declarations of the functions that are not used in that mode.
    This patch not only reduces the number of #ifdefs in the block layer
    core code but also reduces the size of header file <linux/blkdev.h>
    and hence should help to reduce the build time of the Linux kernel
    if CONFIG_PM is not defined.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Jianchao Wang <jianchao.w.wang@oracle.com>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d0389b20574d..4f07b3410595 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -43,6 +43,7 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
+#include <linux/blk-pm.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>

commit 1214fd7b497400d200e3f4e64e2338b303a20949
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Thu Aug 2 10:44:42 2018 -0700

    scsi: sr: Avoid that opening a CD-ROM hangs with runtime power management enabled
    
    Surround scsi_execute() calls with scsi_autopm_get_device() and
    scsi_autopm_put_device(). Note: removing sr_mutex protection from the
    scsi_cd_get() and scsi_cd_put() calls is safe because the purpose of
    sr_mutex is to serialize cdrom_*() calls.
    
    This patch avoids that complaints similar to the following appear in the
    kernel log if runtime power management is enabled:
    
    INFO: task systemd-udevd:650 blocked for more than 120 seconds.
         Not tainted 4.18.0-rc7-dbg+ #1
    "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    systemd-udevd   D28176   650    513 0x00000104
    Call Trace:
    __schedule+0x444/0xfe0
    schedule+0x4e/0xe0
    schedule_preempt_disabled+0x18/0x30
    __mutex_lock+0x41c/0xc70
    mutex_lock_nested+0x1b/0x20
    __blkdev_get+0x106/0x970
    blkdev_get+0x22c/0x5a0
    blkdev_open+0xe9/0x100
    do_dentry_open.isra.19+0x33e/0x570
    vfs_open+0x7c/0xd0
    path_openat+0x6e3/0x1120
    do_filp_open+0x11c/0x1c0
    do_sys_open+0x208/0x2d0
    __x64_sys_openat+0x59/0x70
    do_syscall_64+0x77/0x230
    entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Cc: Maurizio Lombardi <mlombard@redhat.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: <stable@vger.kernel.org>
    Tested-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 3f3cb72e0c0c..d0389b20574d 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -523,18 +523,26 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 static int sr_block_open(struct block_device *bdev, fmode_t mode)
 {
 	struct scsi_cd *cd;
+	struct scsi_device *sdev;
 	int ret = -ENXIO;
 
+	cd = scsi_cd_get(bdev->bd_disk);
+	if (!cd)
+		goto out;
+
+	sdev = cd->device;
+	scsi_autopm_get_device(sdev);
 	check_disk_change(bdev);
 
 	mutex_lock(&sr_mutex);
-	cd = scsi_cd_get(bdev->bd_disk);
-	if (cd) {
-		ret = cdrom_open(&cd->cdi, bdev, mode);
-		if (ret)
-			scsi_cd_put(cd);
-	}
+	ret = cdrom_open(&cd->cdi, bdev, mode);
 	mutex_unlock(&sr_mutex);
+
+	scsi_autopm_put_device(sdev);
+	if (ret)
+		scsi_cd_put(cd);
+
+out:
 	return ret;
 }
 
@@ -562,6 +570,8 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	if (ret)
 		goto out;
 
+	scsi_autopm_get_device(sdev);
+
 	/*
 	 * Send SCSI addressing ioctls directly to mid level, send other
 	 * ioctls to cdrom/block level.
@@ -570,15 +580,18 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	case SCSI_IOCTL_GET_IDLUN:
 	case SCSI_IOCTL_GET_BUS_NUMBER:
 		ret = scsi_ioctl(sdev, cmd, argp);
-		goto out;
+		goto put;
 	}
 
 	ret = cdrom_ioctl(&cd->cdi, bdev, mode, cmd, arg);
 	if (ret != -ENOSYS)
-		goto out;
+		goto put;
 
 	ret = scsi_ioctl(sdev, cmd, argp);
 
+put:
+	scsi_autopm_put_device(sdev);
+
 out:
 	mutex_unlock(&sr_mutex);
 	return ret;

commit 2d097c50212e137e7b53ffe3b37561153eeba87d
Author: Jens Axboe <axboe@kernel.dk>
Date:   Wed Apr 11 11:26:09 2018 -0600

    sr: get/drop reference to device in revalidate and check_events
    
    We can't just use scsi_cd() to get the scsi_cd structure, we have
    to grab a live reference to the device. For both callbacks, we're
    not inside an open where we already hold a reference to the device.
    
    This fixes device removal/addition under concurrent device access,
    which otherwise could result in the below oops.
    
    NULL pointer dereference at 0000000000000010
    PGD 0 P4D 0
    Oops: 0000 [#1] PREEMPT SMP
    Modules linked in:
    sr 12:0:0:0: [sr2] scsi-1 drive
     scsi_debug crc_t10dif crct10dif_generic crct10dif_common nvme nvme_core sb_edac xl
    sr 12:0:0:0: Attached scsi CD-ROM sr2
     sr_mod cdrom btrfs xor zstd_decompress zstd_compress xxhash lzo_compress zlib_defc
    sr 12:0:0:0: Attached scsi generic sg7 type 5
     igb ahci libahci i2c_algo_bit libata dca [last unloaded: crc_t10dif]
    CPU: 43 PID: 4629 Comm: systemd-udevd Not tainted 4.16.0+ #650
    Hardware name: Dell Inc. PowerEdge T630/0NT78X, BIOS 2.3.4 11/09/2016
    RIP: 0010:sr_block_revalidate_disk+0x23/0x190 [sr_mod]
    RSP: 0018:ffff883ff357bb58 EFLAGS: 00010292
    RAX: ffffffffa00b07d0 RBX: ffff883ff3058000 RCX: ffff883ff357bb66
    RDX: 0000000000000003 RSI: 0000000000007530 RDI: ffff881fea631000
    RBP: 0000000000000000 R08: ffff881fe4d38400 R09: 0000000000000000
    R10: 0000000000000000 R11: 00000000000001b6 R12: 000000000800005d
    R13: 000000000800005d R14: ffff883ffd9b3790 R15: 0000000000000000
    FS:  00007f7dc8e6d8c0(0000) GS:ffff883fff340000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000000000000010 CR3: 0000003ffda98005 CR4: 00000000003606e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     ? __invalidate_device+0x48/0x60
     check_disk_change+0x4c/0x60
     sr_block_open+0x16/0xd0 [sr_mod]
     __blkdev_get+0xb9/0x450
     ? iget5_locked+0x1c0/0x1e0
     blkdev_get+0x11e/0x320
     ? bdget+0x11d/0x150
     ? _raw_spin_unlock+0xa/0x20
     ? bd_acquire+0xc0/0xc0
     do_dentry_open+0x1b0/0x320
     ? inode_permission+0x24/0xc0
     path_openat+0x4e6/0x1420
     ? cpumask_any_but+0x1f/0x40
     ? flush_tlb_mm_range+0xa0/0x120
     do_filp_open+0x8c/0xf0
     ? __seccomp_filter+0x28/0x230
     ? _raw_spin_unlock+0xa/0x20
     ? __handle_mm_fault+0x7d6/0x9b0
     ? list_lru_add+0xa8/0xc0
     ? _raw_spin_unlock+0xa/0x20
     ? __alloc_fd+0xaf/0x160
     ? do_sys_open+0x1a6/0x230
     do_sys_open+0x1a6/0x230
     do_syscall_64+0x5a/0x100
     entry_SYSCALL_64_after_hwframe+0x3d/0xa2
    
    Reviewed-by: Lee Duncan <lduncan@suse.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0cf25d789d05..3f3cb72e0c0c 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -587,18 +587,28 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 static unsigned int sr_block_check_events(struct gendisk *disk,
 					  unsigned int clearing)
 {
-	struct scsi_cd *cd = scsi_cd(disk);
+	unsigned int ret = 0;
+	struct scsi_cd *cd;
 
-	if (atomic_read(&cd->device->disk_events_disable_depth))
+	cd = scsi_cd_get(disk);
+	if (!cd)
 		return 0;
 
-	return cdrom_check_events(&cd->cdi, clearing);
+	if (!atomic_read(&cd->device->disk_events_disable_depth))
+		ret = cdrom_check_events(&cd->cdi, clearing);
+
+	scsi_cd_put(cd);
+	return ret;
 }
 
 static int sr_block_revalidate_disk(struct gendisk *disk)
 {
-	struct scsi_cd *cd = scsi_cd(disk);
 	struct scsi_sense_hdr sshdr;
+	struct scsi_cd *cd;
+
+	cd = scsi_cd_get(disk);
+	if (!cd)
+		return -ENXIO;
 
 	/* if the unit is not ready, nothing more to do */
 	if (scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))
@@ -607,6 +617,7 @@ static int sr_block_revalidate_disk(struct gendisk *disk)
 	sr_cd_check(&cd->cdi);
 	get_sectorsize(cd);
 out:
+	scsi_cd_put(cd);
 	return 0;
 }
 

commit 2bbea6e117357d17842114c65e9a9cf2d13ae8a3
Author: Maurizio Lombardi <mlombard@redhat.com>
Date:   Fri Mar 9 13:59:06 2018 +0100

    cdrom: do not call check_disk_change() inside cdrom_open()
    
    when mounting an ISO filesystem sometimes (very rarely)
    the system hangs because of a race condition between two tasks.
    
    PID: 6766   TASK: ffff88007b2a6dd0  CPU: 0   COMMAND: "mount"
     #0 [ffff880078447ae0] __schedule at ffffffff8168d605
     #1 [ffff880078447b48] schedule_preempt_disabled at ffffffff8168ed49
     #2 [ffff880078447b58] __mutex_lock_slowpath at ffffffff8168c995
     #3 [ffff880078447bb8] mutex_lock at ffffffff8168bdef
     #4 [ffff880078447bd0] sr_block_ioctl at ffffffffa00b6818 [sr_mod]
     #5 [ffff880078447c10] blkdev_ioctl at ffffffff812fea50
     #6 [ffff880078447c70] ioctl_by_bdev at ffffffff8123a8b3
     #7 [ffff880078447c90] isofs_fill_super at ffffffffa04fb1e1 [isofs]
     #8 [ffff880078447da8] mount_bdev at ffffffff81202570
     #9 [ffff880078447e18] isofs_mount at ffffffffa04f9828 [isofs]
    #10 [ffff880078447e28] mount_fs at ffffffff81202d09
    #11 [ffff880078447e70] vfs_kern_mount at ffffffff8121ea8f
    #12 [ffff880078447ea8] do_mount at ffffffff81220fee
    #13 [ffff880078447f28] sys_mount at ffffffff812218d6
    #14 [ffff880078447f80] system_call_fastpath at ffffffff81698c49
        RIP: 00007fd9ea914e9a  RSP: 00007ffd5d9bf648  RFLAGS: 00010246
        RAX: 00000000000000a5  RBX: ffffffff81698c49  RCX: 0000000000000010
        RDX: 00007fd9ec2bc210  RSI: 00007fd9ec2bc290  RDI: 00007fd9ec2bcf30
        RBP: 0000000000000000   R8: 0000000000000000   R9: 0000000000000010
        R10: 00000000c0ed0001  R11: 0000000000000206  R12: 00007fd9ec2bc040
        R13: 00007fd9eb6b2380  R14: 00007fd9ec2bc210  R15: 00007fd9ec2bcf30
        ORIG_RAX: 00000000000000a5  CS: 0033  SS: 002b
    
    This task was trying to mount the cdrom.  It allocated and configured a
    super_block struct and owned the write-lock for the super_block->s_umount
    rwsem. While exclusively owning the s_umount lock, it called
    sr_block_ioctl and waited to acquire the global sr_mutex lock.
    
    PID: 6785   TASK: ffff880078720fb0  CPU: 0   COMMAND: "systemd-udevd"
     #0 [ffff880078417898] __schedule at ffffffff8168d605
     #1 [ffff880078417900] schedule at ffffffff8168dc59
     #2 [ffff880078417910] rwsem_down_read_failed at ffffffff8168f605
     #3 [ffff880078417980] call_rwsem_down_read_failed at ffffffff81328838
     #4 [ffff8800784179d0] down_read at ffffffff8168cde0
     #5 [ffff8800784179e8] get_super at ffffffff81201cc7
     #6 [ffff880078417a10] __invalidate_device at ffffffff8123a8de
     #7 [ffff880078417a40] flush_disk at ffffffff8123a94b
     #8 [ffff880078417a88] check_disk_change at ffffffff8123ab50
     #9 [ffff880078417ab0] cdrom_open at ffffffffa00a29e1 [cdrom]
    #10 [ffff880078417b68] sr_block_open at ffffffffa00b6f9b [sr_mod]
    #11 [ffff880078417b98] __blkdev_get at ffffffff8123ba86
    #12 [ffff880078417bf0] blkdev_get at ffffffff8123bd65
    #13 [ffff880078417c78] blkdev_open at ffffffff8123bf9b
    #14 [ffff880078417c90] do_dentry_open at ffffffff811fc7f7
    #15 [ffff880078417cd8] vfs_open at ffffffff811fc9cf
    #16 [ffff880078417d00] do_last at ffffffff8120d53d
    #17 [ffff880078417db0] path_openat at ffffffff8120e6b2
    #18 [ffff880078417e48] do_filp_open at ffffffff8121082b
    #19 [ffff880078417f18] do_sys_open at ffffffff811fdd33
    #20 [ffff880078417f70] sys_open at ffffffff811fde4e
    #21 [ffff880078417f80] system_call_fastpath at ffffffff81698c49
        RIP: 00007f29438b0c20  RSP: 00007ffc76624b78  RFLAGS: 00010246
        RAX: 0000000000000002  RBX: ffffffff81698c49  RCX: 0000000000000000
        RDX: 00007f2944a5fa70  RSI: 00000000000a0800  RDI: 00007f2944a5fa70
        RBP: 00007f2944a5f540   R8: 0000000000000000   R9: 0000000000000020
        R10: 00007f2943614c40  R11: 0000000000000246  R12: ffffffff811fde4e
        R13: ffff880078417f78  R14: 000000000000000c  R15: 00007f2944a4b010
        ORIG_RAX: 0000000000000002  CS: 0033  SS: 002b
    
    This task tried to open the cdrom device, the sr_block_open function
    acquired the global sr_mutex lock. The call to check_disk_change()
    then saw an event flag indicating a possible media change and tried
    to flush any cached data for the device.
    As part of the flush, it tried to acquire the super_block->s_umount
    lock associated with the cdrom device.
    This was the same super_block as created and locked by the previous task.
    
    The first task acquires the s_umount lock and then the sr_mutex_lock;
    the second task acquires the sr_mutex_lock and then the s_umount lock.
    
    This patch fixes the issue by moving check_disk_change() out of
    cdrom_open() and let the caller take care of it.
    
    Signed-off-by: Maurizio Lombardi <mlombard@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 9be34d37c356..0cf25d789d05 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -525,6 +525,8 @@ static int sr_block_open(struct block_device *bdev, fmode_t mode)
 	struct scsi_cd *cd;
 	int ret = -ENXIO;
 
+	check_disk_change(bdev);
+
 	mutex_lock(&sr_mutex);
 	cd = scsi_cd_get(bdev->bd_disk);
 	if (cd) {

commit 0624cbb1e2e64ae4d7d55dc81fc39a0af87a2bd7
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Fri Aug 25 13:46:33 2017 -0700

    scsi: sd: sr: Convert two assignments into warning statements
    
    Before scsi_prep_fn() calls the ULP .init_command() callback
    function it stores the SCSI command pointer in request.special.
    This means that the SCpnt = rq->special assignments in the sd
    and sr drivers assign a pointer to itself. Hence convert these
    two assignment statements into warning statements.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index a8f630213a1a..9be34d37c356 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -393,7 +393,7 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	ret = scsi_init_io(SCpnt);
 	if (ret != BLKPREP_OK)
 		goto out;
-	SCpnt = rq->special;
+	WARN_ON_ONCE(SCpnt != rq->special);
 	cd = scsi_cd(rq->rq_disk);
 
 	/* from here on until we're complete, any goto out

commit a00a7862513089f17209b732f230922f1942e0b9
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Mar 17 08:47:14 2017 -0400

    scsi: sr: Sanity check returned mode data
    
    Kefeng Wang discovered that old versions of the QEMU CD driver would
    return mangled mode data causing us to walk off the end of the buffer in
    an attempt to parse it. Sanity check the returned mode sense data.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0b29b9329b1c..a8f630213a1a 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -836,6 +836,7 @@ static void get_capabilities(struct scsi_cd *cd)
 	unsigned char *buffer;
 	struct scsi_mode_data data;
 	struct scsi_sense_hdr sshdr;
+	unsigned int ms_len = 128;
 	int rc, n;
 
 	static const char *loadmech[] =
@@ -862,10 +863,11 @@ static void get_capabilities(struct scsi_cd *cd)
 	scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);
 
 	/* ask for mode page 0x2a */
-	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,
+	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, ms_len,
 			     SR_TIMEOUT, 3, &data, NULL);
 
-	if (!scsi_status_is_good(rc)) {
+	if (!scsi_status_is_good(rc) || data.length > ms_len ||
+	    data.header_length + data.block_descriptor_length > data.length) {
 		/* failed, drive doesn't have capabilities mode page */
 		cd->cdi.speed = 1;
 		cd->cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |

commit 818551e2b2c662a1b26de6b4f7d6b8411a838d18
Merge: 6010720da8aa 7520872c0cf4
Author: Jens Axboe <axboe@fb.com>
Date:   Fri Feb 17 14:08:19 2017 -0700

    Merge branch 'for-4.11/next' into for-4.11/linus-merge
    
    Signed-off-by: Jens Axboe <axboe@fb.com>

commit 853fe1bf7554155376bb3b231112cdff9ff79177
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Feb 13 16:25:26 2017 -0800

    cdrom: Make device operations read-only
    
    Since function tables are a common target for attackers, it's best to keep
    them in read-only memory. As such, this makes the CDROM device ops tables
    const. This drops additionally n_minors, since it isn't used meaningfully,
    and sets the only user of cdrom_dummy_generic_packet explicitly so the
    variables can all be const.
    
    Inspired by similar changes in grsecurity/PaX.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 94352e4df831..013bfe049a48 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -117,7 +117,7 @@ static unsigned int sr_check_events(struct cdrom_device_info *cdi,
 				    unsigned int clearing, int slot);
 static int sr_packet(struct cdrom_device_info *, struct packet_command *);
 
-static struct cdrom_device_ops sr_dops = {
+static const struct cdrom_device_ops sr_dops = {
 	.open			= sr_open,
 	.release	 	= sr_release,
 	.drive_status	 	= sr_drive_status,

commit aebf526b53aea164508730427597d45f3e06b376
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 31 16:57:31 2017 +0100

    block: fold cmd_type into the REQ_OP_ space
    
    Instead of keeping two levels of indirection for requests types, fold it
    all into the operations.  The little caveat here is that previously
    cmd_type only applied to struct request, while the request and bio op
    fields were set to plain REQ_OP_READ/WRITE even for passthrough
    operations.
    
    Instead this patch adds new REQ_OP_* for SCSI passthrough and driver
    private requests, althought it has to add two for each so that we
    can communicate the data in/out nature of the request.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 94352e4df831..2e1d910092d8 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -437,14 +437,17 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 		goto out;
 	}
 
-	if (rq_data_dir(rq) == WRITE) {
+	switch (req_op(rq)) {
+	case REQ_OP_WRITE:
 		if (!cd->writeable)
 			goto out;
 		SCpnt->cmnd[0] = WRITE_10;
 		cd->cdi.media_written = 1;
-	} else if (rq_data_dir(rq) == READ) {
+		break;
+	case REQ_OP_READ:
 		SCpnt->cmnd[0] = READ_10;
-	} else {
+		break;
+	default:
 		blk_dump_rq_flags(rq, "Unknown sr command");
 		goto out;
 	}

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index bed2bbd6b923..94352e4df831 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -46,7 +46,7 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_dbg.h>

commit a816b4c67ae68a36a8775484b09ad727e4a28e3d
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Aug 28 22:17:38 2016 +0200

    scsi: sr: constify sr_pm_ops structure
    
    sr_pm_ops, of type struct dev_pm_ops, is never modified, so declare it
    as const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index ed179348de80..bed2bbd6b923 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -83,7 +83,7 @@ static int sr_init_command(struct scsi_cmnd *SCpnt);
 static int sr_done(struct scsi_cmnd *);
 static int sr_runtime_suspend(struct device *dev);
 
-static struct dev_pm_ops sr_pm_ops = {
+static const struct dev_pm_ops sr_pm_ops = {
 	.runtime_suspend	= sr_runtime_suspend,
 };
 

commit 0d52c756a665adc032c791307bc55e392b0186b3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 15 19:44:20 2016 -0700

    block: convert to device_add_disk()
    
    For block drivers that specify a parent device, convert them to use
    device_add_disk().
    
    This conversion was done with the following semantic patch:
    
        @@
        struct gendisk *disk;
        expression E;
        @@
    
        - disk->driverfs_dev = E;
        ...
        - add_disk(disk);
        + device_add_disk(E, disk);
    
        @@
        struct gendisk *disk;
        expression E1, E2;
        @@
    
        - disk->driverfs_dev = E1;
        ...
        E2 = disk;
        ...
        - add_disk(E2);
        + device_add_disk(E1, E2);
    
    ...plus some manual fixups for a few missed conversions.
    
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: James Bottomley <James.Bottomley@hansenpartnership.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 64c867405ad4..ed179348de80 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -713,7 +713,6 @@ static int sr_probe(struct device *dev)
 	get_capabilities(cd);
 	sr_vendor_init(cd);
 
-	disk->driverfs_dev = &sdev->sdev_gendev;
 	set_capacity(disk, cd->capacity);
 	disk->private_data = &cd->driver;
 	disk->queue = sdev->request_queue;
@@ -730,7 +729,7 @@ static int sr_probe(struct device *dev)
 
 	dev_set_drvdata(dev, cd);
 	disk->flags |= GENHD_FL_REMOVABLE;
-	add_disk(disk);
+	device_add_disk(&sdev->sdev_gendev, disk);
 
 	sdev_printk(KERN_DEBUG, sdev,
 		    "Attached scsi CD-ROM %s\n", cd->cdi.name);

commit 13b4389143413a1f18127c07f72c74cad5b563e8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jan 20 11:26:01 2016 -0500

    SCSI: fix crashes in sd and sr runtime PM
    
    Runtime suspend during driver probe and removal can cause problems.
    The driver's runtime_suspend or runtime_resume callbacks may invoked
    before the driver has finished binding to the device or after the
    driver has unbound from the device.
    
    This problem shows up with the sd and sr drivers, and can cause disk
    or CD/DVD drives to become unusable as a result.  The fix is simple.
    The drivers store a pointer to the scsi_disk or scsi_cd structure as
    their private device data when probing is finished, so we simply have
    to be sure to clear the private data during removal and test it during
    runtime suspend/resume.
    
    This fixes <https://bugs.debian.org/801925>.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Paul Menzel <paul.menzel@giantmonkey.de>
    Reported-by: Erich Schubert <erich@debian.org>
    Reported-by: Alexandre Rossi <alexandre.rossi@gmail.com>
    Tested-by: Paul Menzel <paul.menzel@giantmonkey.de>
    Tested-by: Erich Schubert <erich@debian.org>
    CC: <stable@vger.kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 8bd54a64efd6..64c867405ad4 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -144,6 +144,9 @@ static int sr_runtime_suspend(struct device *dev)
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
+	if (!cd)	/* E.g.: runtime suspend following sr_remove() */
+		return 0;
+
 	if (cd->media_present)
 		return -EBUSY;
 	else
@@ -985,6 +988,7 @@ static int sr_remove(struct device *dev)
 	scsi_autopm_get_device(cd->device);
 
 	del_gendisk(cd->disk);
+	dev_set_drvdata(dev, NULL);
 
 	mutex_lock(&sr_ref_mutex);
 	kref_put(&cd->kref, sr_kref_release);

commit 3af6b35261182ff185db1f0fd271254147e2663e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 12 18:34:51 2014 +0100

    scsi: remove scsi_driver owner field
    
    The driver core driver structure has grown an owner field and now
    requires it to be set for all modular drivers.  Set it up for
    all scsi_driver instances and get rid of the now superflous
    scsi_driver owner field.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reported-by: Shane M Seymour <shane.seymour@hp.com>
    Reviewed-by: Ewan D. Milne <emilne@redhat.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 5ebadc2ace9b..8bd54a64efd6 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -88,9 +88,9 @@ static struct dev_pm_ops sr_pm_ops = {
 };
 
 static struct scsi_driver sr_template = {
-	.owner			= THIS_MODULE,
 	.gendrv = {
 		.name   	= "sr",
+		.owner		= THIS_MODULE,
 		.probe		= sr_probe,
 		.remove		= sr_remove,
 		.pm		= &sr_pm_ops,

commit 3c356bde19e9a728b26a231a23099c8057dbe881
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 5 18:20:23 2014 -0700

    scsi: stop passing a gfp_mask argument down the command setup path
    
    There is no reason for ULDs to pass in a flag on how to allocate the S/G
    lists.  While we don't need GFP_ATOMIC for the blk-mq case because we
    don't hold locks, that decision can be made way down the chain without
    having to pass a pointless gfp_mask argument.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 3d5399e341af..5ebadc2ace9b 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -387,7 +387,7 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	struct request *rq = SCpnt->request;
 	int ret;
 
-	ret = scsi_init_io(SCpnt, GFP_ATOMIC);
+	ret = scsi_init_io(SCpnt);
 	if (ret != BLKPREP_OK)
 		goto out;
 	SCpnt = rq->special;

commit 906d15fbd23c1267addab361063c1c8119992215
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 11 16:25:31 2014 +0200

    scsi: split scsi_nonblockable_ioctl
    
    The calling conventions for this function are bad as it could return
    -ENODEV both for a device not currently online and a not recognized ioctl.
    
    Add a new scsi_ioctl_block_when_processing_errors function that wraps
    scsi_block_when_processing_errors with the a special case for the
    SG_SCSI_RESET ioctl command, and handle the SG_SCSI_RESET case itself
    in scsi_ioctl.  All callers of scsi_ioctl now must call the above helper
    to check for the EH state, so that the ioctl handler itself doesn't
    have to.
    
    Reported-by: Robert Elliott <Elliott@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 2de44cc58b1a..3d5399e341af 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -549,6 +549,11 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 
 	mutex_lock(&sr_mutex);
 
+	ret = scsi_ioctl_block_when_processing_errors(sdev, cmd,
+			(mode & FMODE_NDELAY) != 0);
+	if (ret)
+		goto out;
+
 	/*
 	 * Send SCSI addressing ioctls directly to mid level, send other
 	 * ioctls to cdrom/block level.
@@ -564,16 +569,6 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	if (ret != -ENOSYS)
 		goto out;
 
-	/*
-	 * ENODEV means that we didn't recognise the ioctl, or that we
-	 * cannot execute it in the current device state.  In either
-	 * case fall through to scsi_ioctl, which will return ENDOEV again
-	 * if it doesn't recognise the ioctl
-	 */
-	ret = scsi_nonblockable_ioctl(sdev, cmd, argp,
-					(mode & FMODE_NDELAY) != 0);
-	if (ret != -ENODEV)
-		goto out;
 	ret = scsi_ioctl(sdev, cmd, argp);
 
 out:

commit 6fe8c1dbefd63ef3988edb745d9eb81fc6d0513c
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Wed Sep 10 14:54:09 2014 +0300

    scsi: balance out autopm get/put calls in scsi_sysfs_add_sdev()
    
    SCSI Well-known logical units generally don't have any scsi driver
    associated with it which means no one will call scsi_autopm_put_device()
    on these wlun scsi devices and this would result in keeping the
    corresponding scsi device always active (hence LLD can't be suspended as
    well). Same exact problem can be seen for other scsi device representing
    normal logical unit whose driver is yet to be loaded. This patch fixes
    the above problem with this approach:
    
    - make the scsi_autopm_put_device call at the end of scsi_sysfs_add_sdev
      to make it balance out the get earlier in the function.
    - let drivers do paired get/put calls in their probe methods.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 7eeb93627beb..2de44cc58b1a 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -657,6 +657,7 @@ static int sr_probe(struct device *dev)
 	struct scsi_cd *cd;
 	int minor, error;
 
+	scsi_autopm_get_device(sdev);
 	error = -ENODEV;
 	if (sdev->type != TYPE_ROM && sdev->type != TYPE_WORM)
 		goto fail;
@@ -744,6 +745,7 @@ static int sr_probe(struct device *dev)
 fail_free:
 	kfree(cd);
 fail:
+	scsi_autopm_put_device(sdev);
 	return error;
 }
 

commit fd2eb9034e48cdca358dc06a833a736e7c6f68dd
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jul 18 16:59:19 2014 +0200

    scsi: move the writeable field from struct scsi_device to struct scsi_cd
    
    We currently set the field in common code based on the device type,
    but then only use it in the cdrom driver which also overrides the
    value previously set in the generic code.
    
    Just leave this entirely to the CDROM driver to make everyones life
    simpler.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index cce4771281d9..7eeb93627beb 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -435,7 +435,7 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	}
 
 	if (rq_data_dir(rq) == WRITE) {
-		if (!cd->device->writeable)
+		if (!cd->writeable)
 			goto out;
 		SCpnt->cmnd[0] = WRITE_10;
 		cd->cdi.media_written = 1;
@@ -927,7 +927,7 @@ static void get_capabilities(struct scsi_cd *cd)
 	 */
 	if ((cd->cdi.mask & (CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) !=
 			(CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) {
-		cd->device->writeable = 1;
+		cd->writeable = 1;
 	}
 
 	kfree(buffer);

commit 5158a899d8f24f74cad29b6aaad2b0f86499e5d5
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 28 16:41:43 2014 +0200

    scsi: set sc_data_direction in common code
    
    The data direction fiel in the SCSI command is derived only from the block
    request structure.  Move setting it up into common code instead of
    duplicating it in the ULDs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 9feeb3766d7d..cce4771281d9 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -438,11 +438,9 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 		if (!cd->device->writeable)
 			goto out;
 		SCpnt->cmnd[0] = WRITE_10;
-		SCpnt->sc_data_direction = DMA_TO_DEVICE;
 		cd->cdi.media_written = 1;
 	} else if (rq_data_dir(rq) == READ) {
 		SCpnt->cmnd[0] = READ_10;
-		SCpnt->sc_data_direction = DMA_FROM_DEVICE;
 	} else {
 		blk_dump_rq_flags(rq, "Unknown sr command");
 		goto out;

commit 3868cf8ea70a57fc3f927872d8296f287ce4b96a
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 28 11:58:42 2014 +0200

    scsi: restructure command initialization for TYPE_FS requests
    
    We should call the device handler prep_fn for all TYPE_FS requests,
    not just simple read/write calls that are handled by the disk driver.
    
    Restructure the common I/O code to call the prep_fn handler and zero
    out the CDB, and just leave the call to scsi_init_io to the ULDs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index a7ea27c01286..9feeb3766d7d 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -385,10 +385,9 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	int block = 0, this_count, s_size;
 	struct scsi_cd *cd;
 	struct request *rq = SCpnt->request;
-	struct scsi_device *sdp = SCpnt->device;
 	int ret;
 
-	ret = scsi_setup_fs_cmnd(sdp, rq);
+	ret = scsi_init_io(SCpnt, GFP_ATOMIC);
 	if (ret != BLKPREP_OK)
 		goto out;
 	SCpnt = rq->special;

commit 96eefad2d9e5a0d988cdfee85193b6154c0ae1d2
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 16:39:54 2014 +0200

    scsi: Implement sr_printk()
    
    Update the sr driver to use dev_printk() variants instead of
    plain printk(); this will prefix logging messages with the
    appropriate device.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 93cbd36c990b..a7ea27c01286 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -292,8 +292,8 @@ static unsigned int sr_check_events(struct cdrom_device_info *cdi,
 	if (!cd->tur_changed) {
 		if (cd->get_event_changed) {
 			if (cd->tur_mismatch++ > 8) {
-				sdev_printk(KERN_WARNING, cd->device,
-					    "GET_EVENT and TUR disagree continuously, suppress GET_EVENT events\n");
+				sr_printk(KERN_WARNING, cd,
+					  "GET_EVENT and TUR disagree continuously, suppress GET_EVENT events\n");
 				cd->ignore_get_event = true;
 			}
 		} else {
@@ -322,7 +322,7 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 	struct scsi_cd *cd = scsi_cd(SCpnt->request->rq_disk);
 
 #ifdef DEBUG
-	printk("sr.c done: %x\n", result);
+	scmd_printk(KERN_INFO, SCpnt, "done: %x\n", result);
 #endif
 
 	/*
@@ -398,13 +398,14 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	 * is used for a killable error condition */
 	ret = BLKPREP_KILL;
 
-	SCSI_LOG_HLQUEUE(1, printk("Doing sr request, dev = %s, block = %d\n",
-				cd->disk->disk_name, block));
+	SCSI_LOG_HLQUEUE(1, scmd_printk(KERN_INFO, SCpnt,
+		"Doing sr request, block = %d\n", block));
 
 	if (!cd->device || !scsi_device_online(cd->device)) {
-		SCSI_LOG_HLQUEUE(2, printk("Finishing %u sectors\n",
-					   blk_rq_sectors(rq)));
-		SCSI_LOG_HLQUEUE(2, printk("Retry with 0x%p\n", SCpnt));
+		SCSI_LOG_HLQUEUE(2, scmd_printk(KERN_INFO, SCpnt,
+			"Finishing %u sectors\n", blk_rq_sectors(rq)));
+		SCSI_LOG_HLQUEUE(2, scmd_printk(KERN_INFO, SCpnt,
+			"Retry with 0x%p\n", SCpnt));
 		goto out;
 	}
 
@@ -425,7 +426,8 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 		if (!in_interrupt())
 			sr_set_blocklength(cd, 2048);
 		else
-			printk("sr: can't switch blocksize: in interrupt\n");
+			scmd_printk(KERN_INFO, SCpnt,
+				    "can't switch blocksize: in interrupt\n");
 	}
 
 	if (s_size != 512 && s_size != 1024 && s_size != 2048) {
@@ -438,7 +440,7 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 			goto out;
 		SCpnt->cmnd[0] = WRITE_10;
 		SCpnt->sc_data_direction = DMA_TO_DEVICE;
- 	 	cd->cdi.media_written = 1;
+		cd->cdi.media_written = 1;
 	} else if (rq_data_dir(rq) == READ) {
 		SCpnt->cmnd[0] = READ_10;
 		SCpnt->sc_data_direction = DMA_FROM_DEVICE;
@@ -475,11 +477,11 @@ static int sr_init_command(struct scsi_cmnd *SCpnt)
 	this_count = (scsi_bufflen(SCpnt) >> 9) / (s_size >> 9);
 
 
-	SCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%u 512 byte blocks.\n",
-				cd->cdi.name,
-				(rq_data_dir(rq) == WRITE) ?
+	SCSI_LOG_HLQUEUE(2, scmd_printk(KERN_INFO, SCpnt,
+					"%s %d/%u 512 byte blocks.\n",
+					(rq_data_dir(rq) == WRITE) ?
 					"writing" : "reading",
-				this_count, blk_rq_sectors(rq)));
+					this_count, blk_rq_sectors(rq)));
 
 	SCpnt->cmnd[1] = 0;
 	block = (unsigned int)blk_rq_pos(rq) / (s_size >> 9);
@@ -810,8 +812,8 @@ static void get_sectorsize(struct scsi_cd *cd)
 		case 512:
 			break;
 		default:
-			printk("%s: unsupported sector size %d.\n",
-			       cd->cdi.name, sector_size);
+			sr_printk(KERN_INFO, cd,
+				  "unsupported sector size %d.", sector_size);
 			cd->capacity = 0;
 		}
 
@@ -853,7 +855,7 @@ static void get_capabilities(struct scsi_cd *cd)
 	/* allocate transfer buffer */
 	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
 	if (!buffer) {
-		printk(KERN_ERR "sr: out of memory.\n");
+		sr_printk(KERN_ERR, cd, "out of memory.\n");
 		return;
 	}
 
@@ -872,7 +874,7 @@ static void get_capabilities(struct scsi_cd *cd)
 				 CDC_SELECT_DISC | CDC_SELECT_SPEED |
 				 CDC_MRW | CDC_MRW_W | CDC_RAM);
 		kfree(buffer);
-		printk("%s: scsi-1 drive\n", cd->cdi.name);
+		sr_printk(KERN_INFO, cd, "scsi-1 drive");
 		return;
 	}
 
@@ -881,22 +883,23 @@ static void get_capabilities(struct scsi_cd *cd)
 	cd->readcd_known = 1;
 	cd->readcd_cdda = buffer[n + 5] & 0x01;
 	/* print some capability bits */
-	printk("%s: scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s\n", cd->cdi.name,
-	       ((buffer[n + 14] << 8) + buffer[n + 15]) / 176,
-	       cd->cdi.speed,
-	       buffer[n + 3] & 0x01 ? "writer " : "", /* CD Writer */
-	       buffer[n + 3] & 0x20 ? "dvd-ram " : "",
-	       buffer[n + 2] & 0x02 ? "cd/rw " : "", /* can read rewriteable */
-	       buffer[n + 4] & 0x20 ? "xa/form2 " : "",	/* can read xa/from2 */
-	       buffer[n + 5] & 0x01 ? "cdda " : "", /* can read audio data */
-	       loadmech[buffer[n + 6] >> 5]);
+	sr_printk(KERN_INFO, cd,
+		  "scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s\n",
+		  ((buffer[n + 14] << 8) + buffer[n + 15]) / 176,
+		  cd->cdi.speed,
+		  buffer[n + 3] & 0x01 ? "writer " : "", /* CD Writer */
+		  buffer[n + 3] & 0x20 ? "dvd-ram " : "",
+		  buffer[n + 2] & 0x02 ? "cd/rw " : "", /* can read rewriteable */
+		  buffer[n + 4] & 0x20 ? "xa/form2 " : "",	/* can read xa/from2 */
+		  buffer[n + 5] & 0x01 ? "cdda " : "", /* can read audio data */
+		  loadmech[buffer[n + 6] >> 5]);
 	if ((buffer[n + 6] >> 5) == 0)
 		/* caddy drives can't close tray... */
 		cd->cdi.mask |= CDC_CLOSE_TRAY;
 	if ((buffer[n + 2] & 0x8) == 0)
 		/* not a DVD drive */
 		cd->cdi.mask |= CDC_DVD;
-	if ((buffer[n + 3] & 0x20) == 0) 
+	if ((buffer[n + 3] & 0x20) == 0)
 		/* can't write DVD-RAM media */
 		cd->cdi.mask |= CDC_DVD_RAM;
 	if ((buffer[n + 3] & 0x10) == 0)
@@ -935,7 +938,7 @@ static void get_capabilities(struct scsi_cd *cd)
 
 /*
  * sr_packet() is the entry point for the generic commands generated
- * by the Uniform CD-ROM layer. 
+ * by the Uniform CD-ROM layer.
  */
 static int sr_packet(struct cdrom_device_info *cdi,
 		struct packet_command *cgc)

commit a1b73fc194e73ed33c8b77bf09374cb05b58151b
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 1 16:51:04 2014 +0200

    scsi: reintroduce scsi_driver.init_command
    
    Instead of letting the ULD play games with the prep_fn move back to
    the model of a central prep_fn with a callback to the ULD.  This
    already cleans up and shortens the code by itself, and will be required
    to properly support blk-mq in the SCSI midlayer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Nicholas Bellinger <nab@linux-iscsi.org>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 40d85929aefe..93cbd36c990b 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -79,6 +79,7 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 static DEFINE_MUTEX(sr_mutex);
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
+static int sr_init_command(struct scsi_cmnd *SCpnt);
 static int sr_done(struct scsi_cmnd *);
 static int sr_runtime_suspend(struct device *dev);
 
@@ -94,6 +95,7 @@ static struct scsi_driver sr_template = {
 		.remove		= sr_remove,
 		.pm		= &sr_pm_ops,
 	},
+	.init_command		= sr_init_command,
 	.done			= sr_done,
 };
 
@@ -378,21 +380,14 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 	return good_bytes;
 }
 
-static int sr_prep_fn(struct request_queue *q, struct request *rq)
+static int sr_init_command(struct scsi_cmnd *SCpnt)
 {
 	int block = 0, this_count, s_size;
 	struct scsi_cd *cd;
-	struct scsi_cmnd *SCpnt;
-	struct scsi_device *sdp = q->queuedata;
+	struct request *rq = SCpnt->request;
+	struct scsi_device *sdp = SCpnt->device;
 	int ret;
 
-	if (rq->cmd_type == REQ_TYPE_BLOCK_PC) {
-		ret = scsi_setup_blk_pc_cmnd(sdp, rq);
-		goto out;
-	} else if (rq->cmd_type != REQ_TYPE_FS) {
-		ret = BLKPREP_KILL;
-		goto out;
-	}
 	ret = scsi_setup_fs_cmnd(sdp, rq);
 	if (ret != BLKPREP_OK)
 		goto out;
@@ -517,7 +512,7 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	 */
 	ret = BLKPREP_OK;
  out:
-	return scsi_prep_return(q, rq, ret);
+	return ret;
 }
 
 static int sr_block_open(struct block_device *bdev, fmode_t mode)
@@ -718,7 +713,6 @@ static int sr_probe(struct device *dev)
 
 	/* FIXME: need to handle a get_capabilities failure properly ?? */
 	get_capabilities(cd);
-	blk_queue_prep_rq(sdev->request_queue, sr_prep_fn);
 	sr_vendor_init(cd);
 
 	disk->driverfs_dev = &sdev->sdev_gendev;
@@ -993,7 +987,6 @@ static int sr_remove(struct device *dev)
 
 	scsi_autopm_get_device(cd->device);
 
-	blk_queue_prep_rq(cd->device->request_queue, scsi_prep_fn);
 	del_gendisk(cd->disk);
 
 	mutex_lock(&sr_ref_mutex);

commit 6627b38fd902cd31c6ad52f9be12a17a38f0faef
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Mon Oct 28 15:27:49 2013 +0800

    [SCSI] sr: use block layer runtime PM
    
    Migrate sr to make use of block layer runtime PM. Accordingly, the
    SCSI bus layer runtime PM callback is simplified as all SCSI drivers
    implementing runtime PM now use the block layer's request-based
    mechanism.
    
    Note that due to the device will be polled by kernel at a constant
    interval, if the autosuspend delay is set longer than the polling
    interval then the device will never suspend.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 119d67f9c47e..40d85929aefe 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -161,14 +161,10 @@ static inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)
 		goto out;
 	cd = scsi_cd(disk);
 	kref_get(&cd->kref);
-	if (scsi_device_get(cd->device))
-		goto out_put;
-	if (!scsi_autopm_get_device(cd->device))
-		goto out;
-
- out_put:
-	kref_put(&cd->kref, sr_kref_release);
-	cd = NULL;
+	if (scsi_device_get(cd->device)) {
+		kref_put(&cd->kref, sr_kref_release);
+		cd = NULL;
+	}
  out:
 	mutex_unlock(&sr_ref_mutex);
 	return cd;
@@ -180,7 +176,6 @@ static void scsi_cd_put(struct scsi_cd *cd)
 
 	mutex_lock(&sr_ref_mutex);
 	kref_put(&cd->kref, sr_kref_release);
-	scsi_autopm_put_device(sdev);
 	scsi_device_put(sdev);
 	mutex_unlock(&sr_ref_mutex);
 }
@@ -558,8 +553,6 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	void __user *argp = (void __user *)arg;
 	int ret;
 
-	scsi_autopm_get_device(cd->device);
-
 	mutex_lock(&sr_mutex);
 
 	/*
@@ -591,7 +584,6 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 
 out:
 	mutex_unlock(&sr_mutex);
-	scsi_autopm_put_device(cd->device);
 	return ret;
 }
 
@@ -599,17 +591,11 @@ static unsigned int sr_block_check_events(struct gendisk *disk,
 					  unsigned int clearing)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
-	unsigned int ret;
 
-	if (atomic_read(&cd->device->disk_events_disable_depth) == 0) {
-		scsi_autopm_get_device(cd->device);
-		ret = cdrom_check_events(&cd->cdi, clearing);
-		scsi_autopm_put_device(cd->device);
-	} else {
-		ret = 0;
-	}
+	if (atomic_read(&cd->device->disk_events_disable_depth))
+		return 0;
 
-	return ret;
+	return cdrom_check_events(&cd->cdi, clearing);
 }
 
 static int sr_block_revalidate_disk(struct gendisk *disk)
@@ -617,8 +603,6 @@ static int sr_block_revalidate_disk(struct gendisk *disk)
 	struct scsi_cd *cd = scsi_cd(disk);
 	struct scsi_sense_hdr sshdr;
 
-	scsi_autopm_get_device(cd->device);
-
 	/* if the unit is not ready, nothing more to do */
 	if (scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))
 		goto out;
@@ -626,7 +610,6 @@ static int sr_block_revalidate_disk(struct gendisk *disk)
 	sr_cd_check(&cd->cdi);
 	get_sectorsize(cd);
 out:
-	scsi_autopm_put_device(cd->device);
 	return 0;
 }
 
@@ -747,6 +730,12 @@ static int sr_probe(struct device *dev)
 	if (register_cdrom(&cd->cdi))
 		goto fail_put;
 
+	/*
+	 * Initialize block layer runtime PM stuffs before the
+	 * periodic event checking request gets started in add_disk.
+	 */
+	blk_pm_runtime_init(sdev->request_queue, dev);
+
 	dev_set_drvdata(dev, cd);
 	disk->flags |= GENHD_FL_REMOVABLE;
 	add_disk(disk);

commit db2a144bedd58b3dcf19950c2f476c58c9f39d18
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 5 21:52:57 2013 -0400

    block_device_operations->release() should return void
    
    The value passed is 0 in all but "it can never happen" cases (and those
    only in a couple of drivers) *and* it would've been lost on the way
    out anyway, even if something tried to pass something meaningful.
    Just don't bother.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index f2884ee90710..119d67f9c47e 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -541,14 +541,13 @@ static int sr_block_open(struct block_device *bdev, fmode_t mode)
 	return ret;
 }
 
-static int sr_block_release(struct gendisk *disk, fmode_t mode)
+static void sr_block_release(struct gendisk *disk, fmode_t mode)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
 	mutex_lock(&sr_mutex);
 	cdrom_release(&cd->cdi, mode);
 	scsi_cd_put(cd);
 	mutex_unlock(&sr_mutex);
-	return 0;
 }
 
 static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,

commit 6f4c827e68a78731c6c75df69bf7b75b029ec70c
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Wed Jan 23 15:09:32 2013 +0800

    [libata] scsi: no poll when ODD is powered off
    
    When the ODD is powered off, any action the user did to the ODD that
    would generate a media event will trigger an ACPI interrupt, so the
    poll for media event is no longer necessary. And the poll will also
    cause a runtime status change, which will stop the ODD from staying in
    powered off state, so the poll should better be stopped.
    
    But since we don't have access to the gendisk structure in LLDs, here
    comes the disk_events_disable_depth for scsi device. This field is a
    hint set by LLDs to convey information to upper layer drivers. A value
    of 0 means media poll is necessary for the device, while values above 0
    means media poll is not needed and should better be skipped. So we can
    increase its value when we are to power off the ODD in ATA layer and
    decrease its value when the ODD is powered on, effectively silence the
    media events poll.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 2e8ddd77366f..f2884ee90710 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -602,9 +602,13 @@ static unsigned int sr_block_check_events(struct gendisk *disk,
 	struct scsi_cd *cd = scsi_cd(disk);
 	unsigned int ret;
 
-	scsi_autopm_get_device(cd->device);
-	ret = cdrom_check_events(&cd->cdi, clearing);
-	scsi_autopm_put_device(cd->device);
+	if (atomic_read(&cd->device->disk_events_disable_depth) == 0) {
+		scsi_autopm_get_device(cd->device);
+		ret = cdrom_check_events(&cd->cdi, clearing);
+		scsi_autopm_put_device(cd->device);
+	} else {
+		ret = 0;
+	}
 
 	return ret;
 }

commit 6c7f1e2f12f6f37ddda01180c9e5c407eccce616
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Wed Jan 23 15:09:31 2013 +0800

    [SCSI] sr: support runtime pm
    
    This patch adds runtime pm support for sr.
    
    It did this by increasing the runtime usage_count of the device when
    its block device is accessed. And decreasing the runtime usage_count
    of the device when the access is done.
    
    If there is media inside, runtime suspend is not allowed as we don't
    always know if the ODD is being used or not.
    
    The idea is discussed here:
    http://thread.gmane.org/gmane.linux.acpi.devel/55243/focus=52703
    and the restriction to check media inside is discussed here:
    http://thread.gmane.org/gmane.linux.ide/53665/focus=58836
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 5fc97d2ba2fd..2e8ddd77366f 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -45,6 +45,7 @@
 #include <linux/blkdev.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
+#include <linux/pm_runtime.h>
 #include <asm/uaccess.h>
 
 #include <scsi/scsi.h>
@@ -79,6 +80,11 @@ static DEFINE_MUTEX(sr_mutex);
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
 static int sr_done(struct scsi_cmnd *);
+static int sr_runtime_suspend(struct device *dev);
+
+static struct dev_pm_ops sr_pm_ops = {
+	.runtime_suspend	= sr_runtime_suspend,
+};
 
 static struct scsi_driver sr_template = {
 	.owner			= THIS_MODULE,
@@ -86,6 +92,7 @@ static struct scsi_driver sr_template = {
 		.name   	= "sr",
 		.probe		= sr_probe,
 		.remove		= sr_remove,
+		.pm		= &sr_pm_ops,
 	},
 	.done			= sr_done,
 };
@@ -131,6 +138,16 @@ static inline struct scsi_cd *scsi_cd(struct gendisk *disk)
 	return container_of(disk->private_data, struct scsi_cd, driver);
 }
 
+static int sr_runtime_suspend(struct device *dev)
+{
+	struct scsi_cd *cd = dev_get_drvdata(dev);
+
+	if (cd->media_present)
+		return -EBUSY;
+	else
+		return 0;
+}
+
 /*
  * The get and put routines for the struct scsi_cd.  Note this entity
  * has a scsi_device pointer and owns a reference to this.
@@ -146,7 +163,8 @@ static inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)
 	kref_get(&cd->kref);
 	if (scsi_device_get(cd->device))
 		goto out_put;
-	goto out;
+	if (!scsi_autopm_get_device(cd->device))
+		goto out;
 
  out_put:
 	kref_put(&cd->kref, sr_kref_release);
@@ -162,6 +180,7 @@ static void scsi_cd_put(struct scsi_cd *cd)
 
 	mutex_lock(&sr_ref_mutex);
 	kref_put(&cd->kref, sr_kref_release);
+	scsi_autopm_put_device(sdev);
 	scsi_device_put(sdev);
 	mutex_unlock(&sr_ref_mutex);
 }
@@ -540,6 +559,8 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	void __user *argp = (void __user *)arg;
 	int ret;
 
+	scsi_autopm_get_device(cd->device);
+
 	mutex_lock(&sr_mutex);
 
 	/*
@@ -571,6 +592,7 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 
 out:
 	mutex_unlock(&sr_mutex);
+	scsi_autopm_put_device(cd->device);
 	return ret;
 }
 
@@ -578,7 +600,13 @@ static unsigned int sr_block_check_events(struct gendisk *disk,
 					  unsigned int clearing)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
-	return cdrom_check_events(&cd->cdi, clearing);
+	unsigned int ret;
+
+	scsi_autopm_get_device(cd->device);
+	ret = cdrom_check_events(&cd->cdi, clearing);
+	scsi_autopm_put_device(cd->device);
+
+	return ret;
 }
 
 static int sr_block_revalidate_disk(struct gendisk *disk)
@@ -586,12 +614,16 @@ static int sr_block_revalidate_disk(struct gendisk *disk)
 	struct scsi_cd *cd = scsi_cd(disk);
 	struct scsi_sense_hdr sshdr;
 
+	scsi_autopm_get_device(cd->device);
+
 	/* if the unit is not ready, nothing more to do */
 	if (scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))
-		return 0;
+		goto out;
 
 	sr_cd_check(&cd->cdi);
 	get_sectorsize(cd);
+out:
+	scsi_autopm_put_device(cd->device);
 	return 0;
 }
 
@@ -718,6 +750,8 @@ static int sr_probe(struct device *dev)
 
 	sdev_printk(KERN_DEBUG, sdev,
 		    "Attached scsi CD-ROM %s\n", cd->cdi.name);
+	scsi_autopm_put_device(cd->device);
+
 	return 0;
 
 fail_put:
@@ -965,6 +999,8 @@ static int sr_remove(struct device *dev)
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
+	scsi_autopm_get_device(cd->device);
+
 	blk_queue_prep_rq(cd->device->request_queue, scsi_prep_fn);
 	del_gendisk(cd->disk);
 

commit 79b9677d885d1a792bc103f2febb06f91f92de43
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Jun 30 15:03:48 2011 +0200

    [SCSI] sr: check_events() ignore GET_EVENT when TUR says otherwise
    
    Some broken devices indicates that media has changed on every
    GET_EVENT_STATUS_NOTIFICATION.  This translates into MEDIA_CHANGE
    uevent on every open() which lets udev run into a loop.
    
    Verify GET_EVENT result against TUR and if it generates spurious
    events for several times in a row, ignore the GET_EVENT events, and
    trust only the TUR status.
    
    This is the log of a USB stick with a (broken) fake CDROM drive:
    
     scsi 5:0:0:0: Direct-Access     SanDisk  U3 Cruzer Micro  8.02 PQ: 0 ANSI: 0 CCS
     sd 5:0:0:0: Attached scsi generic sg3 type 0
     scsi 5:0:0:1: CD-ROM            SanDisk  U3 Cruzer Micro  8.02 PQ: 0 ANSI: 0
     sd 5:0:0:0: [sdb] Attached SCSI removable disk
     sr2: scsi3-mmc drive: 48x/48x tray
     sr 5:0:0:1: Attached scsi CD-ROM sr2
     sr 5:0:0:1: Attached scsi generic sg4 type 5
     sr2: GET_EVENT and TUR disagree continuously, suppress GET_EVENT events
     sd 5:0:0:0: [sdb] 31777279 512-byte logical blocks: (16.2 GB/15.1 GiB)
     sd 5:0:0:0: [sdb] No Caching mode page present
     sd 5:0:0:0: [sdb] Assuming drive cache: write through
     sd 5:0:0:0: [sdb] No Caching mode page present
     sd 5:0:0:0: [sdb] Assuming drive cache: write through
     sdb: sdb1
    
    -tj: Updated to consider only spurious GET_EVENT events among
         different types of disagreement and allow using TUR for kernel
         event polling after GET_EVENT is ignored.
    
    Reported-By: Markus Rathgeb maggu2810@googlemail.com
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@kernel.org   # >= v2.6.38, fixes udev busy looping w/ certain devices
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 4778e2707168..5fc97d2ba2fd 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -221,14 +221,33 @@ static unsigned int sr_check_events(struct cdrom_device_info *cdi,
 		return 0;
 
 	events = sr_get_events(cd->device);
+	cd->get_event_changed |= events & DISK_EVENT_MEDIA_CHANGE;
+
+	/*
+	 * If earlier GET_EVENT_STATUS_NOTIFICATION and TUR did not agree
+	 * for several times in a row.  We rely on TUR only for this likely
+	 * broken device, to prevent generating incorrect media changed
+	 * events for every open().
+	 */
+	if (cd->ignore_get_event) {
+		events &= ~DISK_EVENT_MEDIA_CHANGE;
+		goto do_tur;
+	}
+
 	/*
 	 * GET_EVENT_STATUS_NOTIFICATION is enough unless MEDIA_CHANGE
 	 * is being cleared.  Note that there are devices which hang
 	 * if asked to execute TUR repeatedly.
 	 */
-	if (!(clearing & DISK_EVENT_MEDIA_CHANGE))
-		goto skip_tur;
+	if (cd->device->changed) {
+		events |= DISK_EVENT_MEDIA_CHANGE;
+		cd->device->changed = 0;
+		cd->tur_changed = true;
+	}
 
+	if (!(clearing & DISK_EVENT_MEDIA_CHANGE))
+		return events;
+do_tur:
 	/* let's see whether the media is there with TUR */
 	last_present = cd->media_present;
 	ret = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);
@@ -242,12 +261,31 @@ static unsigned int sr_check_events(struct cdrom_device_info *cdi,
 		(scsi_sense_valid(&sshdr) && sshdr.asc != 0x3a);
 
 	if (last_present != cd->media_present)
-		events |= DISK_EVENT_MEDIA_CHANGE;
-skip_tur:
+		cd->device->changed = 1;
+
 	if (cd->device->changed) {
 		events |= DISK_EVENT_MEDIA_CHANGE;
 		cd->device->changed = 0;
+		cd->tur_changed = true;
+	}
+
+	if (cd->ignore_get_event)
+		return events;
+
+	/* check whether GET_EVENT is reporting spurious MEDIA_CHANGE */
+	if (!cd->tur_changed) {
+		if (cd->get_event_changed) {
+			if (cd->tur_mismatch++ > 8) {
+				sdev_printk(KERN_WARNING, cd->device,
+					    "GET_EVENT and TUR disagree continuously, suppress GET_EVENT events\n");
+				cd->ignore_get_event = true;
+			}
+		} else {
+			cd->tur_mismatch = 0;
+		}
 	}
+	cd->tur_changed = false;
+	cd->get_event_changed = false;
 
 	return events;
 }

commit d4dc210f69bcb0b4bef5a83b1c323817be89bad1
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Apr 21 20:54:46 2011 +0200

    block: don't block events on excl write for non-optical devices
    
    Disk event code automatically blocks events on excl write.  This is
    primarily to avoid issuing polling commands while burning is in
    progress.  This behavior doesn't fit other types of devices with
    removeable media where polling commands don't have adverse side
    effects and door locking usually doesn't exist.
    
    This patch introduces new genhd flag which controls the auto-blocking
    behavior and uses it to enable auto-blocking only on optical devices.
    
    Note for stable: 2.6.38 and later only
    
    Cc: stable@kernel.org
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 95019c747cc1..4778e2707168 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -636,7 +636,7 @@ static int sr_probe(struct device *dev)
 	disk->first_minor = minor;
 	sprintf(disk->disk_name, "sr%d", minor);
 	disk->fops = &sr_bdops;
-	disk->flags = GENHD_FL_CD;
+	disk->flags = GENHD_FL_CD | GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
 	disk->events = DISK_EVENT_MEDIA_CHANGE | DISK_EVENT_EJECT_REQUEST;
 
 	blk_queue_rq_timeout(sdev->request_queue, SR_TIMEOUT);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index aefadc6a1607..95019c747cc1 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -567,7 +567,7 @@ static const struct block_device_operations sr_bdops =
 	.revalidate_disk = sr_block_revalidate_disk,
 	/* 
 	 * No compat_ioctl for now because sr_block_ioctl never
-	 * seems to pass arbitary ioctls down to host drivers.
+	 * seems to pass arbitrary ioctls down to host drivers.
 	 */
 };
 

commit f4013c3879d1bbd9f3ab8351185decd049502368
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Dec 28 16:20:47 2010 +0100

    [SCSI] sd,sr: kill compat SDEV_MEDIA_CHANGE event
    
    SDEV_MEDIA_CHANGE event was first added by commit a341cd0f (SCSI: add
    asynchronous event notification API) for SATA AN support and then
    extended to cover generic media change events by commit 285e9670
    ([SCSI] sr,sd: send media state change modification events).
    
    This event was mapped to block device in userland with all properties
    stripped to simulate CHANGE event on the block device, which, in turn,
    was used to trigger further userspace action on media change.
    
    The recent addition of disk event framework kept this event for
    backward compatibility but it turns out to be unnecessary and causes
    erratic and inefficient behavior.  The new disk event generates proper
    events on the block devices and the compat events are mapped to block
    device with all properties stripped, so the block device ends up
    generating multiple duplicate events for single actual event.
    
    This patch removes the compat event generation from both sr and sd as
    suggested by Kay Sievers.  Both existing and newer versions of udev
    and the associated tools will behave better with the removal of these
    events as they from the beginning were expecting events on the block
    devices.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index be6baf8ad704..aefadc6a1607 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -249,10 +249,6 @@ static unsigned int sr_check_events(struct cdrom_device_info *cdi,
 		cd->device->changed = 0;
 	}
 
-	/* for backward compatibility */
-	if (events & DISK_EVENT_MEDIA_CHANGE)
-		sdev_evt_send_simple(cd->device, SDEV_EVT_MEDIA_CHANGE,
-				     GFP_KERNEL);
 	return events;
 }
 

commit 93aae17af1172c40c6f74b7294e93a90c3cfaa5d
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Dec 16 17:52:17 2010 +0100

    sr: implement sr_check_events()
    
    Replace sr_media_change() with sr_check_events().  It normally only
    uses GET_EVENT_STATUS_NOTIFICATION to check both media change and
    eject request.  If @clearing includes DISK_EVENT_MEDIA_CHANGE, it
    issues TUR and compares whether media presence has changed.  The SCSI
    specific media change uevent is kept for compatibility.
    
    sr_media_change() was doing both media change check and revalidation.
    The revalidation part is split into sr_block_revalidate_disk().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 310b3fac6313..be6baf8ad704 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -104,14 +104,15 @@ static void sr_release(struct cdrom_device_info *);
 static void get_sectorsize(struct scsi_cd *);
 static void get_capabilities(struct scsi_cd *);
 
-static int sr_media_change(struct cdrom_device_info *, int);
+static unsigned int sr_check_events(struct cdrom_device_info *cdi,
+				    unsigned int clearing, int slot);
 static int sr_packet(struct cdrom_device_info *, struct packet_command *);
 
 static struct cdrom_device_ops sr_dops = {
 	.open			= sr_open,
 	.release	 	= sr_release,
 	.drive_status	 	= sr_drive_status,
-	.media_changed		= sr_media_change,
+	.check_events		= sr_check_events,
 	.tray_move		= sr_tray_move,
 	.lock_door		= sr_lock_door,
 	.select_speed		= sr_select_speed,
@@ -165,69 +166,96 @@ static void scsi_cd_put(struct scsi_cd *cd)
 	mutex_unlock(&sr_ref_mutex);
 }
 
+static unsigned int sr_get_events(struct scsi_device *sdev)
+{
+	u8 buf[8];
+	u8 cmd[] = { GET_EVENT_STATUS_NOTIFICATION,
+		     1,			/* polled */
+		     0, 0,		/* reserved */
+		     1 << 4,		/* notification class: media */
+		     0, 0,		/* reserved */
+		     0, sizeof(buf),	/* allocation length */
+		     0,			/* control */
+	};
+	struct event_header *eh = (void *)buf;
+	struct media_event_desc *med = (void *)(buf + 4);
+	struct scsi_sense_hdr sshdr;
+	int result;
+
+	result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, sizeof(buf),
+				  &sshdr, SR_TIMEOUT, MAX_RETRIES, NULL);
+	if (scsi_sense_valid(&sshdr) && sshdr.sense_key == UNIT_ATTENTION)
+		return DISK_EVENT_MEDIA_CHANGE;
+
+	if (result || be16_to_cpu(eh->data_len) < sizeof(*med))
+		return 0;
+
+	if (eh->nea || eh->notification_class != 0x4)
+		return 0;
+
+	if (med->media_event_code == 1)
+		return DISK_EVENT_EJECT_REQUEST;
+	else if (med->media_event_code == 2)
+		return DISK_EVENT_MEDIA_CHANGE;
+	return 0;
+}
+
 /*
- * This function checks to see if the media has been changed in the
- * CDROM drive.  It is possible that we have already sensed a change,
- * or the drive may have sensed one and not yet reported it.  We must
- * be ready for either case. This function always reports the current
- * value of the changed bit.  If flag is 0, then the changed bit is reset.
- * This function could be done as an ioctl, but we would need to have
- * an inode for that to work, and we do not always have one.
+ * This function checks to see if the media has been changed or eject
+ * button has been pressed.  It is possible that we have already
+ * sensed a change, or the drive may have sensed one and not yet
+ * reported it.  The past events are accumulated in sdev->changed and
+ * returned together with the current state.
  */
-
-static int sr_media_change(struct cdrom_device_info *cdi, int slot)
+static unsigned int sr_check_events(struct cdrom_device_info *cdi,
+				    unsigned int clearing, int slot)
 {
 	struct scsi_cd *cd = cdi->handle;
-	int retval;
-	struct scsi_sense_hdr *sshdr;
+	bool last_present;
+	struct scsi_sense_hdr sshdr;
+	unsigned int events;
+	int ret;
 
-	if (CDSL_CURRENT != slot) {
-		/* no changer support */
-		return -EINVAL;
-	}
+	/* no changer support */
+	if (CDSL_CURRENT != slot)
+		return 0;
+
+	events = sr_get_events(cd->device);
+	/*
+	 * GET_EVENT_STATUS_NOTIFICATION is enough unless MEDIA_CHANGE
+	 * is being cleared.  Note that there are devices which hang
+	 * if asked to execute TUR repeatedly.
+	 */
+	if (!(clearing & DISK_EVENT_MEDIA_CHANGE))
+		goto skip_tur;
+
+	/* let's see whether the media is there with TUR */
+	last_present = cd->media_present;
+	ret = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);
 
-	sshdr =  kzalloc(sizeof(*sshdr), GFP_KERNEL);
-	retval = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES,
-				      sshdr);
 	/*
 	 * Media is considered to be present if TUR succeeds or fails with
 	 * sense data indicating something other than media-not-present
 	 * (ASC 0x3a).
 	 */
-	if (!scsi_status_is_good(retval) &&
-	    (!scsi_sense_valid(sshdr) || sshdr->asc == 0x3a)) {
-		/*
-		 * Probably no media in the device.  Mark as changed, and
-		 * we will figure it out later once the drive is available
-		 * again.
-		 */
-		cd->device->changed = 1;
-		/* This will force a flush, if called from check_disk_change */
-		retval = 1;
-		goto out;
-	};
+	cd->media_present = scsi_status_is_good(ret) ||
+		(scsi_sense_valid(&sshdr) && sshdr.asc != 0x3a);
 
-	retval = cd->device->changed;
-	cd->device->changed = 0;
-	/* If the disk changed, the capacity will now be different,
-	 * so we force a re-read of this information */
-	if (retval) {
-		/* check multisession offset etc */
-		sr_cd_check(cdi);
-		get_sectorsize(cd);
+	if (last_present != cd->media_present)
+		events |= DISK_EVENT_MEDIA_CHANGE;
+skip_tur:
+	if (cd->device->changed) {
+		events |= DISK_EVENT_MEDIA_CHANGE;
+		cd->device->changed = 0;
 	}
 
-out:
-	/* Notify userspace, that media has changed. */
-	if (retval != cd->previous_state)
+	/* for backward compatibility */
+	if (events & DISK_EVENT_MEDIA_CHANGE)
 		sdev_evt_send_simple(cd->device, SDEV_EVT_MEDIA_CHANGE,
 				     GFP_KERNEL);
-	cd->previous_state = retval;
-	kfree(sshdr);
-
-	return retval;
+	return events;
 }
- 
+
 /*
  * sr_done is the interrupt routine for the device driver.
  *
@@ -512,10 +540,25 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	return ret;
 }
 
-static int sr_block_media_changed(struct gendisk *disk)
+static unsigned int sr_block_check_events(struct gendisk *disk,
+					  unsigned int clearing)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
-	return cdrom_media_changed(&cd->cdi);
+	return cdrom_check_events(&cd->cdi, clearing);
+}
+
+static int sr_block_revalidate_disk(struct gendisk *disk)
+{
+	struct scsi_cd *cd = scsi_cd(disk);
+	struct scsi_sense_hdr sshdr;
+
+	/* if the unit is not ready, nothing more to do */
+	if (scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr))
+		return 0;
+
+	sr_cd_check(&cd->cdi);
+	get_sectorsize(cd);
+	return 0;
 }
 
 static const struct block_device_operations sr_bdops =
@@ -524,7 +567,8 @@ static const struct block_device_operations sr_bdops =
 	.open		= sr_block_open,
 	.release	= sr_block_release,
 	.ioctl		= sr_block_ioctl,
-	.media_changed	= sr_block_media_changed,
+	.check_events	= sr_block_check_events,
+	.revalidate_disk = sr_block_revalidate_disk,
 	/* 
 	 * No compat_ioctl for now because sr_block_ioctl never
 	 * seems to pass arbitary ioctls down to host drivers.
@@ -597,6 +641,7 @@ static int sr_probe(struct device *dev)
 	sprintf(disk->disk_name, "sr%d", minor);
 	disk->fops = &sr_bdops;
 	disk->flags = GENHD_FL_CD;
+	disk->events = DISK_EVENT_MEDIA_CHANGE | DISK_EVENT_EJECT_REQUEST;
 
 	blk_queue_rq_timeout(sdev->request_queue, SR_TIMEOUT);
 
@@ -606,7 +651,7 @@ static int sr_probe(struct device *dev)
 	cd->disk = disk;
 	cd->capacity = 0x1fffff;
 	cd->device->changed = 1;	/* force recheck CD type */
-	cd->previous_state = 1;
+	cd->media_present = 1;
 	cd->use = 1;
 	cd->readcd_known = 0;
 	cd->readcd_cdda = 0;

commit 9f8a2c23c6c1140f515f601265c4dff7522110b7
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 8 20:57:40 2010 +0100

    scsi: replace sr_test_unit_ready() with scsi_test_unit_ready()
    
    The usage of TUR has been confusing involving several different
    commits updating different parts over time.  Currently, the only
    differences between scsi_test_unit_ready() and sr_test_unit_ready()
    are,
    
    * scsi_test_unit_ready() also sets sdev->changed on NOT_READY.
    
    * scsi_test_unit_ready() returns 0 if TUR ended with UNIT_ATTENTION or
      NOT_READY.
    
    Due to the above two differences, sr is using its own
    sr_test_unit_ready(), but sd - the sole user of the above extra
    handling - doesn't even need them.
    
    Where scsi_test_unit_ready() is used in sd_media_changed(), the code
    is looking for device ready w/ media present state which is true iff
    TUR succeeds w/o sense data or UA, and when the device is not ready
    for whatever reason sd_media_changed() explicitly marks media as
    missing so there's no reason to set sdev->changed automatically from
    scsi_test_unit_ready() on NOT_READY.
    
    Drop both special handlings from scsi_test_unit_ready(), which makes
    it equivalant to sr_test_unit_ready(), and replace
    sr_test_unit_ready() with scsi_test_unit_ready().  Also, drop the
    unnecessary explicit NOT_READY check from sd_media_changed().
    Checking return value is enough for testing device readiness.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index c7e29bdec2cd..310b3fac6313 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -165,32 +165,6 @@ static void scsi_cd_put(struct scsi_cd *cd)
 	mutex_unlock(&sr_ref_mutex);
 }
 
-/* identical to scsi_test_unit_ready except that it doesn't
- * eat the NOT_READY returns for removable media */
-int sr_test_unit_ready(struct scsi_device *sdev, struct scsi_sense_hdr *sshdr)
-{
-	int retries = MAX_RETRIES;
-	int the_result;
-	u8 cmd[] = {TEST_UNIT_READY, 0, 0, 0, 0, 0 };
-
-	/* issue TEST_UNIT_READY until the initial startup UNIT_ATTENTION
-	 * conditions are gone, or a timeout happens
-	 */
-	do {
-		the_result = scsi_execute_req(sdev, cmd, DMA_NONE, NULL,
-					      0, sshdr, SR_TIMEOUT,
-					      retries--, NULL);
-		if (scsi_sense_valid(sshdr) &&
-		    sshdr->sense_key == UNIT_ATTENTION)
-			sdev->changed = 1;
-
-	} while (retries > 0 &&
-		 (!scsi_status_is_good(the_result) ||
-		  (scsi_sense_valid(sshdr) &&
-		   sshdr->sense_key == UNIT_ATTENTION)));
-	return the_result;
-}
-
 /*
  * This function checks to see if the media has been changed in the
  * CDROM drive.  It is possible that we have already sensed a change,
@@ -213,7 +187,8 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 	}
 
 	sshdr =  kzalloc(sizeof(*sshdr), GFP_KERNEL);
-	retval = sr_test_unit_ready(cd->device, sshdr);
+	retval = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES,
+				      sshdr);
 	/*
 	 * Media is considered to be present if TUR succeeds or fails with
 	 * sense data indicating something other than media-not-present
@@ -784,7 +759,7 @@ static void get_capabilities(struct scsi_cd *cd)
 	}
 
 	/* eat unit attentions */
-	sr_test_unit_ready(cd->device, &sshdr);
+	scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES, &sshdr);
 
 	/* ask for mode page 0x2a */
 	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,

commit 638428ece619495edc9579b1e21493eb00f9687c
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Dec 9 11:18:42 2010 +0100

    scsi: fix TUR error handling in sr_media_change()
    
    sr_test_unit_ready() returns 0 iff TUR succeeded - IOW, when media is
    present and the device is actually ready, so the return value wouldn't
    be zero when TUR ends with sense data. sr_media_change() incorrectly
    tests (retval || (scsi_sense_valid(sshdr)...)) when it tries to test
    whether TUR failed without sense data or with sense data indicating
    media-not-present.
    
    Fix the test using scsi_status_is_good() and update comments.
    
    - Fixed a comment typo spotted by Eike.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Rolf Eike Beer <eike-kernel@sf-tec.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d7b383c96d5d..c7e29bdec2cd 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -214,13 +214,17 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 
 	sshdr =  kzalloc(sizeof(*sshdr), GFP_KERNEL);
 	retval = sr_test_unit_ready(cd->device, sshdr);
-	if (retval || (scsi_sense_valid(sshdr) &&
-		       /* 0x3a is medium not present */
-		       sshdr->asc == 0x3a)) {
-		/* Media not present or unable to test, unit probably not
-		 * ready. This usually means there is no disc in the drive.
-		 * Mark as changed, and we will figure it out later once
-		 * the drive is available again.
+	/*
+	 * Media is considered to be present if TUR succeeds or fails with
+	 * sense data indicating something other than media-not-present
+	 * (ASC 0x3a).
+	 */
+	if (!scsi_status_is_good(retval) &&
+	    (!scsi_sense_valid(sshdr) || sshdr->asc == 0x3a)) {
+		/*
+		 * Probably no media in the device.  Mark as changed, and
+		 * we will figure it out later once the drive is available
+		 * again.
 		 */
 		cd->device->changed = 1;
 		/* This will force a flush, if called from check_disk_change */

commit 5cc103506289de7ee0a0b526ae0381541990cad4
Merge: 73ecf3a6e3f0 92ca0dc5ee02
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 20:30:48 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (141 commits)
      USB: mct_u232: fix broken close
      USB: gadget: amd5536udc.c: fix error path
      USB: imx21-hcd - fix off by one resource size calculation
      usb: gadget: fix Kconfig warning
      usb: r8a66597-udc: Add processing when USB was removed.
      mxc_udc: add workaround for ENGcm09152 for i.MX35
      USB: ftdi_sio: add device ids for ScienceScope
      USB: musb: AM35x: Workaround for fifo read issue
      USB: musb: add musb support for AM35x
      USB: AM35x: Add musb support
      usb: Fix linker errors with CONFIG_PM=n
      USB: ohci-sh - use resource_size instead of defining its own resource_len macro
      USB: isp1362-hcd - use resource_size instead of defining its own resource_len macro
      USB: isp116x-hcd - use resource_size instead of defining its own resource_len macro
      USB: xhci: Fix compile error when CONFIG_PM=n
      USB: accept some invalid ep0-maxpacket values
      USB: xHCI: PCI power management implementation
      USB: xHCI: bus power management implementation
      USB: xHCI: port remote wakeup implementation
      USB: xHCI: port power management implementation
      ...
    
    Manually fix up (non-data) conflict: the SCSI merge gad renamed the
    'hw_sector_size' member to 'physical_block_size', and the USB tree
    brought a new use of it.

commit 8e04d8056c1ea0e0aab730994b74756f0526cda8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Oct 1 14:20:08 2010 -0700

    scsi/sr: add no_read_disc_info scsi_device flag
    
    Some USB devices emulate a usb-mass-storage attached (scsi) cdrom device,
    usually this fake cdrom contains the windows software for the device.
    While working on supporting Appotech ax3003 based photoframes, which do
    this I discovered that they will go of into lala land when ever they see a
    READ_DISC_INFO scsi command.
    
    Thus this patch adds a scsi_device flag (which can then be set by the
    usb-storage driver through an unsual-devs entry), to indicate this, and
    makes the sr driver honor this flag.
    
    I know this sucks, but as discussed on linux-scsi list there is no other
    way to make this device work properly.
    
    Looking at usb traces made under windows, windows never sends a
    READ_DISC_INFO during normal interactions with a usb cdrom device.  So as
    this cdrom emulation thingie becomes more common we might see more of this
    problem.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index ba9c3e0387ce..b811dd0eb240 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -862,10 +862,16 @@ static void get_capabilities(struct scsi_cd *cd)
 static int sr_packet(struct cdrom_device_info *cdi,
 		struct packet_command *cgc)
 {
+	struct scsi_cd *cd = cdi->handle;
+	struct scsi_device *sdev = cd->device;
+
+	if (cgc->cmd[0] == GPCMD_READ_DISC_INFO && sdev->no_read_disc_info)
+		return -EDRIVE_CANT_DO_THIS;
+
 	if (cgc->timeout <= 0)
 		cgc->timeout = IOCTL_TIMEOUT;
 
-	sr_do_ioctl(cdi->handle, cgc);
+	sr_do_ioctl(cd, cgc);
 
 	return cgc->stat;
 }

commit 2a48fc0ab24241755dc93bfd4f01d68efab47f5a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 2 14:28:52 2010 +0200

    block: autoconvert trivial BKL users to private mutex
    
    The block device drivers have all gained new lock_kernel
    calls from a recent pushdown, and some of the drivers
    were already using the BKL before.
    
    This turns the BKL into a set of per-driver mutexes.
    Still need to check whether this is safe to do.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index ba9c3e0387ce..e148341079b5 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -44,7 +44,6 @@
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/mutex.h>
-#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
 
@@ -76,6 +75,7 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 	 CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_DVD_RAM|CDC_GENERIC_PACKET| \
 	 CDC_MRW|CDC_MRW_W|CDC_RAM)
 
+static DEFINE_MUTEX(sr_mutex);
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
 static int sr_done(struct scsi_cmnd *);
@@ -470,24 +470,24 @@ static int sr_block_open(struct block_device *bdev, fmode_t mode)
 	struct scsi_cd *cd;
 	int ret = -ENXIO;
 
-	lock_kernel();
+	mutex_lock(&sr_mutex);
 	cd = scsi_cd_get(bdev->bd_disk);
 	if (cd) {
 		ret = cdrom_open(&cd->cdi, bdev, mode);
 		if (ret)
 			scsi_cd_put(cd);
 	}
-	unlock_kernel();
+	mutex_unlock(&sr_mutex);
 	return ret;
 }
 
 static int sr_block_release(struct gendisk *disk, fmode_t mode)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
-	lock_kernel();
+	mutex_lock(&sr_mutex);
 	cdrom_release(&cd->cdi, mode);
 	scsi_cd_put(cd);
-	unlock_kernel();
+	mutex_unlock(&sr_mutex);
 	return 0;
 }
 
@@ -499,7 +499,7 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	void __user *argp = (void __user *)arg;
 	int ret;
 
-	lock_kernel();
+	mutex_lock(&sr_mutex);
 
 	/*
 	 * Send SCSI addressing ioctls directly to mid level, send other
@@ -529,7 +529,7 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	ret = scsi_ioctl(sdev, cmd, argp);
 
 out:
-	unlock_kernel();
+	mutex_unlock(&sr_mutex);
 	return ret;
 }
 

commit 6e9624b8caec290d28b4c6d9ec75749df6372b87
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Aug 7 18:25:34 2010 +0200

    block: push down BKL into .open and .release
    
    The open and release block_device_operations are currently
    called with the BKL held. In order to change that, we must
    first make sure that all drivers that currently rely
    on this have no regressions.
    
    This blindly pushes the BKL into all .open and .release
    operations for all block drivers to prepare for the
    next step. The drivers can subsequently replace the BKL
    with their own locks or remove it completely when it can
    be shown that it is not needed.
    
    The functions blkdev_get and blkdev_put are the only
    remaining users of the big kernel lock in the block
    layer, besides a few uses in the ioctl code, none
    of which need to serialize with blkdev_{get,put}.
    
    Most of these two functions is also under the protection
    of bdev->bd_mutex, including the actual calls to
    ->open and ->release, and the common code does not
    access any global data structures that need the BKL.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d42fa6468f41..ba9c3e0387ce 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -467,22 +467,27 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 
 static int sr_block_open(struct block_device *bdev, fmode_t mode)
 {
-	struct scsi_cd *cd = scsi_cd_get(bdev->bd_disk);
+	struct scsi_cd *cd;
 	int ret = -ENXIO;
 
+	lock_kernel();
+	cd = scsi_cd_get(bdev->bd_disk);
 	if (cd) {
 		ret = cdrom_open(&cd->cdi, bdev, mode);
 		if (ret)
 			scsi_cd_put(cd);
 	}
+	unlock_kernel();
 	return ret;
 }
 
 static int sr_block_release(struct gendisk *disk, fmode_t mode)
 {
 	struct scsi_cd *cd = scsi_cd(disk);
+	lock_kernel();
 	cdrom_release(&cd->cdi, mode);
 	scsi_cd_put(cd);
+	unlock_kernel();
 	return 0;
 }
 

commit 8a6cfeb6deca3a8fefd639d898b0d163c0b5d368
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jul 8 10:18:46 2010 +0200

    block: push down BKL into .locked_ioctl
    
    As a preparation for the removal of the big kernel
    lock in the block layer, this removes the BKL
    from the common ioctl handling code, moving it
    into every single driver still using it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0a90abc7f140..d42fa6468f41 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -44,6 +44,7 @@
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/mutex.h>
+#include <linux/smp_lock.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
 
@@ -493,6 +494,8 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	void __user *argp = (void __user *)arg;
 	int ret;
 
+	lock_kernel();
+
 	/*
 	 * Send SCSI addressing ioctls directly to mid level, send other
 	 * ioctls to cdrom/block level.
@@ -500,12 +503,13 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	switch (cmd) {
 	case SCSI_IOCTL_GET_IDLUN:
 	case SCSI_IOCTL_GET_BUS_NUMBER:
-		return scsi_ioctl(sdev, cmd, argp);
+		ret = scsi_ioctl(sdev, cmd, argp);
+		goto out;
 	}
 
 	ret = cdrom_ioctl(&cd->cdi, bdev, mode, cmd, arg);
 	if (ret != -ENOSYS)
-		return ret;
+		goto out;
 
 	/*
 	 * ENODEV means that we didn't recognise the ioctl, or that we
@@ -516,8 +520,12 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	ret = scsi_nonblockable_ioctl(sdev, cmd, argp,
 					(mode & FMODE_NDELAY) != 0);
 	if (ret != -ENODEV)
-		return ret;
-	return scsi_ioctl(sdev, cmd, argp);
+		goto out;
+	ret = scsi_ioctl(sdev, cmd, argp);
+
+out:
+	unlock_kernel();
+	return ret;
 }
 
 static int sr_block_media_changed(struct gendisk *disk)
@@ -531,7 +539,7 @@ static const struct block_device_operations sr_bdops =
 	.owner		= THIS_MODULE,
 	.open		= sr_block_open,
 	.release	= sr_block_release,
-	.locked_ioctl	= sr_block_ioctl,
+	.ioctl		= sr_block_ioctl,
 	.media_changed	= sr_block_media_changed,
 	/* 
 	 * No compat_ioctl for now because sr_block_ioctl never

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d6f340f48a3b..0a90abc7f140 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -44,6 +44,7 @@
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/mutex.h>
+#include <linux/slab.h>
 #include <asm/uaccess.h>
 
 #include <scsi/scsi.h>

commit 5915136d4d3954867cced8a2297bddd16caf36a1
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Sep 4 11:38:02 2009 +0900

    [SCSI] sr: consider the last written sector when determining media size
    
    On certain cases, UDF disc doesn't report capacity correctly via
    READ_CAPACITY but TOC or trackinfo contains valid information which
    can be obtained using cdrom_get_last_written().  ide-cd considers both
    values and uses the larger one.  Do the same in sr.  This fixes
    bko#9668.
    
     http://bugzilla.kernel.org/show_bug.cgi?id=9668
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Milan Kocian <milan.kocian@wq.cz>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index eb61f7a70e1d..d6f340f48a3b 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -684,14 +684,20 @@ static void get_sectorsize(struct scsi_cd *cd)
 		cd->capacity = 0x1fffff;
 		sector_size = 2048;	/* A guess, just in case */
 	} else {
-#if 0
-		if (cdrom_get_last_written(&cd->cdi,
-					   &cd->capacity))
-#endif
-			cd->capacity = 1 + ((buffer[0] << 24) |
-						    (buffer[1] << 16) |
-						    (buffer[2] << 8) |
-						    buffer[3]);
+		long last_written;
+
+		cd->capacity = 1 + ((buffer[0] << 24) | (buffer[1] << 16) |
+				    (buffer[2] << 8) | buffer[3]);
+		/*
+		 * READ_CAPACITY doesn't return the correct size on
+		 * certain UDF media.  If last_written is larger, use
+		 * it instead.
+		 *
+		 * http://bugzilla.kernel.org/show_bug.cgi?id=9668
+		 */
+		if (!cdrom_get_last_written(&cd->cdi, &last_written))
+			cd->capacity = max_t(long, cd->capacity, last_written);
+
 		sector_size = (buffer[4] << 24) |
 		    (buffer[5] << 16) | (buffer[6] << 8) | buffer[7];
 		switch (sector_size) {

commit 83d5cde47dedf01b6a4a4331882cbc0a7eea3c2e
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:13 2009 -0700

    const: make block_device_operations const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index cce0fe4c8a3b..eb61f7a70e1d 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -525,7 +525,7 @@ static int sr_block_media_changed(struct gendisk *disk)
 	return cdrom_media_changed(&cd->cdi);
 }
 
-static struct block_device_operations sr_bdops =
+static const struct block_device_operations sr_bdops =
 {
 	.owner		= THIS_MODULE,
 	.open		= sr_block_open,

commit b391277a56b9eaaff4474339c703e574ed7fab5b
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Jun 18 09:57:18 2009 +0200

    sd, sr: fix Driver 'sd' needs updating message
    
    If a SCSI ULD driver sets blk_queue_prep_rq(), it should clean it
    up itself on remove(), and not from the bus callbacks. This
    removes the need to hook into bus->remove(), which should not
    be used at the same time as driver->remove().
    
    [jejb: fix sdkp initialisation problem due to mismerge]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index cd350dfc1216..cce0fe4c8a3b 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -881,6 +881,7 @@ static int sr_remove(struct device *dev)
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
+	blk_queue_prep_rq(cd->device->request_queue, scsi_prep_fn);
 	del_gendisk(cd->disk);
 
 	mutex_lock(&sr_ref_mutex);

commit e1defc4ff0cf57aca6c5e3ff99fa503f5943c1f1
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri May 22 17:17:49 2009 -0400

    block: Do away with the notion of hardsect_size
    
    Until now we have had a 1:1 mapping between storage device physical
    block size and the logical block sized used when addressing the device.
    With SATA 4KB drives coming out that will no longer be the case.  The
    sector size will be 4KB but the logical block size will remain
    512-bytes.  Hence we need to distinguish between the physical block size
    and the logical ditto.
    
    This patch renames hardsect_size to logical_block_size.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index fddba53c7fe5..cd350dfc1216 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -727,7 +727,7 @@ static void get_sectorsize(struct scsi_cd *cd)
 	}
 
 	queue = cd->device->request_queue;
-	blk_queue_hardsect_size(queue, sector_size);
+	blk_queue_logical_block_size(queue, sector_size);
 
 	return;
 }

commit 83096ebf1263b2c1ee5e653ba37d993d02e3eb7b
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 7 22:24:39 2009 +0900

    block: convert to pos and nr_sectors accessors
    
    With recent cleanups, there is no place where low level driver
    directly manipulates request fields.  This means that the 'hard'
    request fields always equal the !hard fields.  Convert all
    rq->sectors, nr_sectors and current_nr_sectors references to
    accessors.
    
    While at it, drop superflous blk_rq_pos() < 0 test in swim.c.
    
    [ Impact: use pos and nr_sectors accessors ]
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
    Tested-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Adrian McMenamin <adrian@mcmen.demon.co.uk>
    Acked-by: Adrian McMenamin <adrian@mcmen.demon.co.uk>
    Acked-by: Mike Miller <mike.miller@hp.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Borislav Petkov <petkovbb@googlemail.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Eric Moore <Eric.Moore@lsi.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Pete Zaitcev <zaitcev@redhat.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Paul Clements <paul.clements@steeleye.com>
    Cc: Tim Waugh <tim@cyberelk.net>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: Alex Dubov <oakad@yahoo.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Dario Ballabio <ballabio_dario@emc.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: unsik Kim <donari75@gmail.com>
    Cc: Laurent Vivier <Laurent@lvivier.info>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0e1a0f2d2ad5..fddba53c7fe5 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -292,7 +292,8 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 			if (cd->device->sector_size == 2048)
 				error_sector <<= 2;
 			error_sector &= ~(block_sectors - 1);
-			good_bytes = (error_sector - SCpnt->request->sector) << 9;
+			good_bytes = (error_sector -
+				      blk_rq_pos(SCpnt->request)) << 9;
 			if (good_bytes < 0 || good_bytes >= this_count)
 				good_bytes = 0;
 			/*
@@ -349,8 +350,8 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 				cd->disk->disk_name, block));
 
 	if (!cd->device || !scsi_device_online(cd->device)) {
-		SCSI_LOG_HLQUEUE(2, printk("Finishing %ld sectors\n",
-					rq->nr_sectors));
+		SCSI_LOG_HLQUEUE(2, printk("Finishing %u sectors\n",
+					   blk_rq_sectors(rq)));
 		SCSI_LOG_HLQUEUE(2, printk("Retry with 0x%p\n", SCpnt));
 		goto out;
 	}
@@ -413,7 +414,7 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	/*
 	 * request doesn't start on hw block boundary, add scatter pads
 	 */
-	if (((unsigned int)rq->sector % (s_size >> 9)) ||
+	if (((unsigned int)blk_rq_pos(rq) % (s_size >> 9)) ||
 	    (scsi_bufflen(SCpnt) % s_size)) {
 		scmd_printk(KERN_NOTICE, SCpnt, "unaligned transfer\n");
 		goto out;
@@ -422,14 +423,14 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	this_count = (scsi_bufflen(SCpnt) >> 9) / (s_size >> 9);
 
 
-	SCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%ld 512 byte blocks.\n",
+	SCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%u 512 byte blocks.\n",
 				cd->cdi.name,
 				(rq_data_dir(rq) == WRITE) ?
 					"writing" : "reading",
-				this_count, rq->nr_sectors));
+				this_count, blk_rq_sectors(rq)));
 
 	SCpnt->cmnd[1] = 0;
-	block = (unsigned int)rq->sector / (s_size >> 9);
+	block = (unsigned int)blk_rq_pos(rq) / (s_size >> 9);
 
 	if (this_count > 0xffff) {
 		this_count = 0xffff;

commit a9bddd74630b2a1f2dedc537417c372b2d9edc76
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Mon Mar 30 16:55:51 2009 +0000

    [SCSI] fix recovered error handling
    
    We have a problem with recovered error handling in that any command
    which goes down as BLOCK_PC but which returns a sense code of RECOVERED
    ERROR gets completed with -EIO.  For actual SG_IO commands, this doesn't
    matter at all, since the error return code gets dropped in favour of
    req->errors which contain the SCSI completion code.
    
    However, if this command is part of the block system, then it will pay
    attention to the returned error code.  In particularly if a SYNCHRONIZE
    CACHE from a barrier command completes with RECOVERED ERROR, the
    resulting -EIO on the barrier causes block to error the request and
    return it to the filesystem.  Fix this by converting the -EIO for
    recovered error to zero, plus remove the printing of this from sd and sr
    so the message isn't double printed.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index e7fa3caead79..0e1a0f2d2ad5 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -309,15 +309,6 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 			break;
 
 		case RECOVERED_ERROR:
-
-			/*
-			 * An error occured, but it recovered.  Inform the
-			 * user, but make sure that it's not treated as a
-			 * hard error.
-			 */
-			scsi_print_sense("sr", SCpnt);
-			SCpnt->result = 0;
-			SCpnt->sense_buffer[0] = 0x0;
 			good_bytes = this_count;
 			break;
 

commit f4f4e47e4af6b02dd1c425b931c65d0165356e33
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Thu Dec 4 14:24:39 2008 +0900

    [SCSI] add residual argument to scsi_execute and scsi_execute_req
    
    scsi_execute() and scsi_execute_req() discard the residual length
    information. Some callers need it. This adds residual argument
    (optional) to scsi_execute and scsi_execute_req.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 45b66b98a516..e7fa3caead79 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -177,7 +177,7 @@ int sr_test_unit_ready(struct scsi_device *sdev, struct scsi_sense_hdr *sshdr)
 	do {
 		the_result = scsi_execute_req(sdev, cmd, DMA_NONE, NULL,
 					      0, sshdr, SR_TIMEOUT,
-					      retries--);
+					      retries--, NULL);
 		if (scsi_sense_valid(sshdr) &&
 		    sshdr->sense_key == UNIT_ATTENTION)
 			sdev->changed = 1;
@@ -681,7 +681,7 @@ static void get_sectorsize(struct scsi_cd *cd)
 		/* Do the command and wait.. */
 		the_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,
 					      buffer, sizeof(buffer), NULL,
-					      SR_TIMEOUT, MAX_RETRIES);
+					      SR_TIMEOUT, MAX_RETRIES, NULL);
 
 		retries--;
 

commit fd4ce1acd0f8558033b1a6968001552bd7671e6d
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 5 14:58:42 2008 +0100

    [PATCH 1/2] kill FMODE_NDELAY_NOW
    
    Update FMODE_NDELAY before each ioctl call so that we can kill the
    magic FMODE_NDELAY_NOW.  It would be even better to do this directly
    in setfl(), but for that we'd need to have FMODE_NDELAY for all files,
    not just block special files.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 62b6633e3a97..45b66b98a516 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -521,7 +521,7 @@ static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 	 * if it doesn't recognise the ioctl
 	 */
 	ret = scsi_nonblockable_ioctl(sdev, cmd, argp,
-					(mode & FMODE_NDELAY_NOW) != 0);
+					(mode & FMODE_NDELAY) != 0);
 	if (ret != -ENODEV)
 		return ret;
 	return scsi_ioctl(sdev, cmd, argp);

commit 40cc51be699e37b78102ce7b2196ec9c32fe1908
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 2 10:41:28 2008 -0500

    [PATCH] switch sr
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 9446cbf4de84..62b6633e3a97 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -471,34 +471,31 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	return scsi_prep_return(q, rq, ret);
 }
 
-static int sr_block_open(struct inode *inode, struct file *file)
+static int sr_block_open(struct block_device *bdev, fmode_t mode)
 {
-	struct gendisk *disk = inode->i_bdev->bd_disk;
-	struct scsi_cd *cd;
-	int ret = 0;
-
-	if(!(cd = scsi_cd_get(disk)))
-		return -ENXIO;
-
-	if((ret = cdrom_open(&cd->cdi, inode->i_bdev, file->f_mode)) != 0)
-		scsi_cd_put(cd);
+	struct scsi_cd *cd = scsi_cd_get(bdev->bd_disk);
+	int ret = -ENXIO;
 
+	if (cd) {
+		ret = cdrom_open(&cd->cdi, bdev, mode);
+		if (ret)
+			scsi_cd_put(cd);
+	}
 	return ret;
 }
 
-static int sr_block_release(struct inode *inode, struct file *file)
+static int sr_block_release(struct gendisk *disk, fmode_t mode)
 {
-	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
-	cdrom_release(&cd->cdi, file ? file->f_mode : 0);
+	struct scsi_cd *cd = scsi_cd(disk);
+	cdrom_release(&cd->cdi, mode);
 	scsi_cd_put(cd);
-
 	return 0;
 }
 
-static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
+static int sr_block_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd,
 			  unsigned long arg)
 {
-	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
+	struct scsi_cd *cd = scsi_cd(bdev->bd_disk);
 	struct scsi_device *sdev = cd->device;
 	void __user *argp = (void __user *)arg;
 	int ret;
@@ -513,8 +510,7 @@ static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
 		return scsi_ioctl(sdev, cmd, argp);
 	}
 
-	ret = cdrom_ioctl(&cd->cdi, inode->i_bdev,
-			  file ? file->f_mode : 0, cmd, arg);
+	ret = cdrom_ioctl(&cd->cdi, bdev, mode, cmd, arg);
 	if (ret != -ENOSYS)
 		return ret;
 
@@ -525,7 +521,7 @@ static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
 	 * if it doesn't recognise the ioctl
 	 */
 	ret = scsi_nonblockable_ioctl(sdev, cmd, argp,
-					file ? file->f_flags & O_NDELAY : 0);
+					(mode & FMODE_NDELAY_NOW) != 0);
 	if (ret != -ENODEV)
 		return ret;
 	return scsi_ioctl(sdev, cmd, argp);
@@ -540,9 +536,9 @@ static int sr_block_media_changed(struct gendisk *disk)
 static struct block_device_operations sr_bdops =
 {
 	.owner		= THIS_MODULE,
-	.__open		= sr_block_open,
-	.__release	= sr_block_release,
-	.__ioctl		= sr_block_ioctl,
+	.open		= sr_block_open,
+	.release	= sr_block_release,
+	.locked_ioctl	= sr_block_ioctl,
 	.media_changed	= sr_block_media_changed,
 	/* 
 	 * No compat_ioctl for now because sr_block_ioctl never

commit d4430d62fa77208824a37fe6f85ab2831d274769
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 2 09:09:22 2008 -0500

    [PATCH] beginning of methods conversion
    
    To keep the size of changesets sane we split the switch by drivers;
    to keep the damn thing bisectable we do the following:
            1) rename the affected methods, add ones with correct
    prototypes, make (few) callers handle both.  That's this changeset.
            2) for each driver convert to new methods.  *ALL* drivers
    are converted in this series.
            3) kill the old (renamed) methods.
    
    Note that it _is_ a flagday; all in-tree drivers are converted and by the
    end of this series no trace of old methods remain.  The only reason why
    we do that this way is to keep the damn thing bisectable and allow per-driver
    debugging if anything goes wrong.
    
    New methods:
            open(bdev, mode)
            release(disk, mode)
            ioctl(bdev, mode, cmd, arg)             /* Called without BKL */
            compat_ioctl(bdev, mode, cmd, arg)
            locked_ioctl(bdev, mode, cmd, arg)      /* Called with BKL, legacy */
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 2fb8d4d2d6f6..9446cbf4de84 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -540,9 +540,9 @@ static int sr_block_media_changed(struct gendisk *disk)
 static struct block_device_operations sr_bdops =
 {
 	.owner		= THIS_MODULE,
-	.open		= sr_block_open,
-	.release	= sr_block_release,
-	.ioctl		= sr_block_ioctl,
+	.__open		= sr_block_open,
+	.__release	= sr_block_release,
+	.__ioctl		= sr_block_ioctl,
 	.media_changed	= sr_block_media_changed,
 	/* 
 	 * No compat_ioctl for now because sr_block_ioctl never

commit 83ff6fe8580a7c834dba4389d742332fff9b9929
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 2 08:15:49 2008 -0500

    [PATCH] don't mess with file in scsi_nonblockable_ioctl()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index b92e2dac9aa9..2fb8d4d2d6f6 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -524,7 +524,8 @@ static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
 	 * case fall through to scsi_ioctl, which will return ENDOEV again
 	 * if it doesn't recognise the ioctl
 	 */
-	ret = scsi_nonblockable_ioctl(sdev, cmd, argp, NULL);
+	ret = scsi_nonblockable_ioctl(sdev, cmd, argp,
+					file ? file->f_flags & O_NDELAY : 0);
 	if (ret != -ENODEV)
 		return ret;
 	return scsi_ioctl(sdev, cmd, argp);

commit bbc1cc978404105da23d505163ce9fd5598ed5b1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 7 17:54:28 2007 -0400

    [PATCH] switch cdrom_{open,release,ioctl} to sane APIs
    
    ... convert to it in callers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 0f17009c99d2..b92e2dac9aa9 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -480,7 +480,7 @@ static int sr_block_open(struct inode *inode, struct file *file)
 	if(!(cd = scsi_cd_get(disk)))
 		return -ENXIO;
 
-	if((ret = cdrom_open(&cd->cdi, inode, file)) != 0)
+	if((ret = cdrom_open(&cd->cdi, inode->i_bdev, file->f_mode)) != 0)
 		scsi_cd_put(cd);
 
 	return ret;
@@ -488,12 +488,8 @@ static int sr_block_open(struct inode *inode, struct file *file)
 
 static int sr_block_release(struct inode *inode, struct file *file)
 {
-	int ret;
 	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
-	ret = cdrom_release(&cd->cdi, file);
-	if(ret)
-		return ret;
-	
+	cdrom_release(&cd->cdi, file ? file->f_mode : 0);
 	scsi_cd_put(cd);
 
 	return 0;
@@ -517,7 +513,8 @@ static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
 		return scsi_ioctl(sdev, cmd, argp);
 	}
 
-	ret = cdrom_ioctl(file, &cd->cdi, inode, cmd, arg);
+	ret = cdrom_ioctl(&cd->cdi, inode->i_bdev,
+			  file ? file->f_mode : 0, cmd, arg);
 	if (ret != -ENOSYS)
 		return ret;
 

commit 242f9dcb8ba6f68fcd217a119a7648a4f69290e9
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Sun Sep 14 05:55:09 2008 -0700

    block: unify request timeout handling
    
    Right now SCSI and others do their own command timeout handling.
    Move those bits to the block layer.
    
    Instead of having a timer per command, we try to be a bit more clever
    and simply have one per-queue. This avoids the overhead of having to
    tear down and setup a timer for each command, so it will result in a lot
    less timer fiddling.
    
    Signed-off-by: Mike Anderson <andmike@linux.vnet.ibm.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 8dbe3798d5fd..0f17009c99d2 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -331,7 +331,7 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 
 static int sr_prep_fn(struct request_queue *q, struct request *rq)
 {
-	int block=0, this_count, s_size, timeout = SR_TIMEOUT;
+	int block = 0, this_count, s_size;
 	struct scsi_cd *cd;
 	struct scsi_cmnd *SCpnt;
 	struct scsi_device *sdp = q->queuedata;
@@ -461,7 +461,6 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	SCpnt->transfersize = cd->device->sector_size;
 	SCpnt->underflow = this_count << 9;
 	SCpnt->allowed = MAX_RETRIES;
-	SCpnt->timeout_per_command = timeout;
 
 	/*
 	 * This indicates that the command is ready from our end to be
@@ -620,6 +619,8 @@ static int sr_probe(struct device *dev)
 	disk->fops = &sr_bdops;
 	disk->flags = GENHD_FL_CD;
 
+	blk_queue_rq_timeout(sdev->request_queue, SR_TIMEOUT);
+
 	cd->device = sdev;
 	cd->disk = disk;
 	cd->driver = &sr_template;

commit f331c0296f2a9fee0d396a70598b954062603015
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 3 09:01:48 2008 +0200

    block: don't depend on consecutive minor space
    
    * Implement disk_devt() and part_devt() and use them to directly
      access devt instead of computing it from ->major and ->first_minor.
    
      Note that all references to ->major and ->first_minor outside of
      block layer is used to determine devt of the disk (the part0) and as
      ->major and ->first_minor will continue to represent devt for the
      disk, converting these users aren't strictly necessary.  However,
      convert them for consistency.
    
    * Implement disk_max_parts() to avoid directly deferencing
      genhd->minors.
    
    * Update bdget_disk() such that it doesn't assume consecutive minor
      space.
    
    * Move devt computation from register_disk() to add_disk() and make it
      the only one (all other usages use the initially determined value).
    
    These changes clean up the code and will help disk->part dereference
    fix and extended block device numbers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 27f5bfd1def3..8dbe3798d5fd 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -878,7 +878,7 @@ static void sr_kref_release(struct kref *kref)
 	struct gendisk *disk = cd->disk;
 
 	spin_lock(&sr_index_lock);
-	clear_bit(disk->first_minor, sr_index_bits);
+	clear_bit(MINOR(disk_devt(disk)), sr_index_bits);
 	spin_unlock(&sr_index_lock);
 
 	unregister_cdrom(&cd->cdi);

commit 2dc75d3c3b49c64fd26b4832a7efb75546cb3fc5
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Thu Sep 11 14:20:23 2008 +0200

    block: disable sysfs parts of the disk command filter
    
    We still have life time issues with the sysfs command filter kobject,
    so disable it for 2.6.27 release. We can revisit this and make it work
    properly for 2.6.28, for 2.6.27 release it's too risky.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 3292965bfd84..27f5bfd1def3 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -656,7 +656,6 @@ static int sr_probe(struct device *dev)
 	dev_set_drvdata(dev, cd);
 	disk->flags |= GENHD_FL_REMOVABLE;
 	add_disk(disk);
-	blk_register_filter(disk);
 
 	sdev_printk(KERN_DEBUG, sdev,
 		    "Attached scsi CD-ROM %s\n", cd->cdi.name);
@@ -895,7 +894,6 @@ static int sr_remove(struct device *dev)
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
-	blk_unregister_filter(cd->disk);
 	del_gendisk(cd->disk);
 
 	mutex_lock(&sr_ref_mutex);

commit bb23b431db7405f6d79f989ad0236bf6428ba1cb
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Aug 29 11:47:07 2008 +0200

    remove blk_register_filter and blk_unregister_filter in gendisk
    
    This patch remove blk_register_filter and blk_unregister_filter in
    gendisk, and adds them to sd.c, sr.c. and ide-cd.c
    
    The commit abf5439370491dd6fbb4fe1a7939680d2a9bc9d4 moved cmdfilter
    from gendisk to request_queue. It turned out that in some subsystems
    multiple gendisks share a single request_queue. So we get:
    
    Using physmap partition information
    Creating 3 MTD partitions on "physmap-flash":
    0x00000000-0x01c00000 : "User FS"
    0x01c00000-0x01c40000 : "booter"
    kobject (8511c410): tried to init an initialized object, something is seriously wrong.
    Call Trace:
    [<8036644c>] dump_stack+0x8/0x34
    [<8021f050>] kobject_init+0x50/0xcc
    [<8021fa18>] kobject_init_and_add+0x24/0x58
    [<8021d20c>] blk_register_filter+0x4c/0x64
    [<8021c194>] add_disk+0x78/0xe0
    [<8027d14c>] add_mtd_blktrans_dev+0x254/0x278
    [<8027c8f0>] blktrans_notify_add+0x40/0x78
    [<80279c00>] add_mtd_device+0xd0/0x150
    [<8027b090>] add_mtd_partitions+0x568/0x5d8
    [<80285458>] physmap_flash_probe+0x2ac/0x334
    [<802644f8>] driver_probe_device+0x12c/0x244
    [<8026465c>] __driver_attach+0x4c/0x84
    [<80263c64>] bus_for_each_dev+0x58/0xac
    [<802633ec>] bus_add_driver+0xc4/0x24c
    [<802648e0>] driver_register+0xcc/0x184
    [<80100460>] _stext+0x60/0x1bc
    
    In the long term, we need to fix such subsystems but we need a quick
    fix now. This patch add the command filter support to only sd and sr
    though it might be useful for other SG_IO users (such as cciss).
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Reported-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 27f5bfd1def3..3292965bfd84 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -656,6 +656,7 @@ static int sr_probe(struct device *dev)
 	dev_set_drvdata(dev, cd);
 	disk->flags |= GENHD_FL_REMOVABLE;
 	add_disk(disk);
+	blk_register_filter(disk);
 
 	sdev_printk(KERN_DEBUG, sdev,
 		    "Attached scsi CD-ROM %s\n", cd->cdi.name);
@@ -894,6 +895,7 @@ static int sr_remove(struct device *dev)
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
+	blk_unregister_filter(cd->disk);
 	del_gendisk(cd->disk);
 
 	mutex_lock(&sr_ref_mutex);

commit 62858dacc8dea55c5bdb474ccd8acb0657e23dd0
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Jul 4 09:31:50 2008 +0200

    scsi: sr avoids useless buffer allocation
    
    blk_rq_map_kern can handle the stack buffers correctly (avoid DMA
    from/to the stack buffers by using the bounce buffer) so we don't need
    to complicate the code by allocating just 8 bytes.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index c82df8bd4d89..27f5bfd1def3 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -673,24 +673,20 @@ static int sr_probe(struct device *dev)
 static void get_sectorsize(struct scsi_cd *cd)
 {
 	unsigned char cmd[10];
-	unsigned char *buffer;
+	unsigned char buffer[8];
 	int the_result, retries = 3;
 	int sector_size;
 	struct request_queue *queue;
 
-	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
-	if (!buffer)
-		goto Enomem;
-
 	do {
 		cmd[0] = READ_CAPACITY;
 		memset((void *) &cmd[1], 0, 9);
-		memset(buffer, 0, 8);
+		memset(buffer, 0, sizeof(buffer));
 
 		/* Do the command and wait.. */
 		the_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,
-					      buffer, 8, NULL, SR_TIMEOUT,
-					      MAX_RETRIES);
+					      buffer, sizeof(buffer), NULL,
+					      SR_TIMEOUT, MAX_RETRIES);
 
 		retries--;
 
@@ -745,14 +741,8 @@ static void get_sectorsize(struct scsi_cd *cd)
 
 	queue = cd->device->request_queue;
 	blk_queue_hardsect_size(queue, sector_size);
-out:
-	kfree(buffer);
-	return;
 
-Enomem:
-	cd->capacity = 0x1fffff;
-	cd->device->sector_size = 2048;	/* A guess, just in case */
-	goto out;
+	return;
 }
 
 static void get_capabilities(struct scsi_cd *cd)

commit d1daeabf0da5bfa1943272ce508e2ba785730bf0
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jun 10 10:20:53 2008 -0500

    [SCSI] sr: fix corrupt CD data after media change and delay
    
    Reported-by: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
    
    If you delay 30s or more before mounting a CD after inserting it then
    the kernel has the wrong value for the CD size.
    
    http://marc.info/?t=121276133000001
    
    The problem is in sr_test_unit_ready(): the function eats unit
    attentions without adjusting the sdev->changed status.  This means
    that when the CD signals changed media via unit attention, we can
    ignore it.  Fix by making sr_test_unit_ready() adjust the changed
    status.
    
    Tested-by: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 7ee86d4a7618..c82df8bd4d89 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -178,6 +178,9 @@ int sr_test_unit_ready(struct scsi_device *sdev, struct scsi_sense_hdr *sshdr)
 		the_result = scsi_execute_req(sdev, cmd, DMA_NONE, NULL,
 					      0, sshdr, SR_TIMEOUT,
 					      retries--);
+		if (scsi_sense_valid(sshdr) &&
+		    sshdr->sense_key == UNIT_ATTENTION)
+			sdev->changed = 1;
 
 	} while (retries > 0 &&
 		 (!scsi_status_is_good(the_result) ||

commit c02e600280c605c761190ef82a6e6fa6aa7fb248
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Mar 19 13:09:56 2008 +0100

    [SCSI] sd, sr: do not emit change event at device add
    
    Initialize the "state changed" flag, so we do not send a change event
    immediately after registering a new device.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 208565bdbe8e..7ee86d4a7618 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -623,6 +623,7 @@ static int sr_probe(struct device *dev)
 	cd->disk = disk;
 	cd->capacity = 0x1fffff;
 	cd->device->changed = 1;	/* force recheck CD type */
+	cd->previous_state = 1;
 	cd->use = 1;
 	cd->readcd_known = 0;
 	cd->readcd_cdda = 0;

commit 38582a62ecd337de4212004c7d4844899dc57890
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Feb 6 13:01:58 2008 -0600

    [SCSI] sr: fix test unit ready responses
    
    Commit 210ba1d1724f5c4ed87a2ab1a21ca861a915f734 updated sr.c to use
    the scsi_test_unit_ready() function.  Unfortunately, this has the
    wrong characteristic of eating NOT_READY returns which sr.c relies on
    for tray status.
    
    Fix by rolling an internal sr_test_unit_ready() that doesn't do this.
    
    Tested-by: Daniel Drake <dsd@gentoo.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 50ba49250203..208565bdbe8e 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -163,6 +163,29 @@ static void scsi_cd_put(struct scsi_cd *cd)
 	mutex_unlock(&sr_ref_mutex);
 }
 
+/* identical to scsi_test_unit_ready except that it doesn't
+ * eat the NOT_READY returns for removable media */
+int sr_test_unit_ready(struct scsi_device *sdev, struct scsi_sense_hdr *sshdr)
+{
+	int retries = MAX_RETRIES;
+	int the_result;
+	u8 cmd[] = {TEST_UNIT_READY, 0, 0, 0, 0, 0 };
+
+	/* issue TEST_UNIT_READY until the initial startup UNIT_ATTENTION
+	 * conditions are gone, or a timeout happens
+	 */
+	do {
+		the_result = scsi_execute_req(sdev, cmd, DMA_NONE, NULL,
+					      0, sshdr, SR_TIMEOUT,
+					      retries--);
+
+	} while (retries > 0 &&
+		 (!scsi_status_is_good(the_result) ||
+		  (scsi_sense_valid(sshdr) &&
+		   sshdr->sense_key == UNIT_ATTENTION)));
+	return the_result;
+}
+
 /*
  * This function checks to see if the media has been changed in the
  * CDROM drive.  It is possible that we have already sensed a change,
@@ -185,8 +208,7 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 	}
 
 	sshdr =  kzalloc(sizeof(*sshdr), GFP_KERNEL);
-	retval = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES,
-				      sshdr);
+	retval = sr_test_unit_ready(cd->device, sshdr);
 	if (retval || (scsi_sense_valid(sshdr) &&
 		       /* 0x3a is medium not present */
 		       sshdr->asc == 0x3a)) {
@@ -733,10 +755,8 @@ static void get_capabilities(struct scsi_cd *cd)
 {
 	unsigned char *buffer;
 	struct scsi_mode_data data;
-	unsigned char cmd[MAX_COMMAND_SIZE];
 	struct scsi_sense_hdr sshdr;
-	unsigned int the_result;
-	int retries, rc, n;
+	int rc, n;
 
 	static const char *loadmech[] =
 	{
@@ -758,23 +778,8 @@ static void get_capabilities(struct scsi_cd *cd)
 		return;
 	}
 
-	/* issue TEST_UNIT_READY until the initial startup UNIT_ATTENTION
-	 * conditions are gone, or a timeout happens
-	 */
-	retries = 0;
-	do {
-		memset((void *)cmd, 0, MAX_COMMAND_SIZE);
-		cmd[0] = TEST_UNIT_READY;
-
-		the_result = scsi_execute_req (cd->device, cmd, DMA_NONE, NULL,
-					       0, &sshdr, SR_TIMEOUT,
-					       MAX_RETRIES);
-
-		retries++;
-	} while (retries < 5 && 
-		 (!scsi_status_is_good(the_result) ||
-		  (scsi_sense_valid(&sshdr) &&
-		   sshdr.sense_key == UNIT_ATTENTION)));
+	/* eat unit attentions */
+	sr_test_unit_ready(cd->device, &sshdr);
 
 	/* ask for mode page 0x2a */
 	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,

commit 30b0c37b27485a9cb897bfe3824f6f517b8c80d6
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Thu Dec 13 13:47:40 2007 +0200

    [SCSI] implement scsi_data_buffer
    
    In preparation for bidi we abstract all IO members of scsi_cmnd,
    that will need to duplicate, into a substructure.
    
    - Group all IO members of scsi_cmnd into a scsi_data_buffer
      structure.
    - Adjust accessors to new members.
    - scsi_{alloc,free}_sgtable receive a scsi_data_buffer instead of
      scsi_cmnd. And work on it.
    - Adjust scsi_init_io() and  scsi_release_buffers() for above
      change.
    - Fix other parts of scsi_lib/scsi.c to members migration. Use
      accessors where appropriate.
    
    - fix Documentation about scsi_cmnd in scsi_host.h
    
    - scsi_error.c
      * Changed needed members of struct scsi_eh_save.
      * Careful considerations in scsi_eh_prep/restore_cmnd.
    
    - sd.c and sr.c
      * sd and sr would adjust IO size to align on device's block
        size so code needs to change once we move to scsi_data_buff
        implementation.
      * Convert code to use scsi_for_each_sg
      * Use data accessors where appropriate.
    
    - tgt: convert libsrp to use scsi_data_buffer
    
    - isd200: This driver still bangs on scsi_cmnd IO members,
      so need changing
    
    [jejb: rebased on top of sg_table patches fixed up conflicts
    and used the synergy to eliminate use_sg and sg_count]
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 1fcee16fa36d..50ba49250203 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -231,7 +231,7 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 static int sr_done(struct scsi_cmnd *SCpnt)
 {
 	int result = SCpnt->result;
-	int this_count = SCpnt->request_bufflen;
+	int this_count = scsi_bufflen(SCpnt);
 	int good_bytes = (result == 0 ? this_count : 0);
 	int block_sectors = 0;
 	long error_sector;
@@ -379,17 +379,18 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	}
 
 	{
-		struct scatterlist *sg = SCpnt->request_buffer;
-		int i, size = 0;
-		for (i = 0; i < SCpnt->use_sg; i++)
-			size += sg[i].length;
+		struct scatterlist *sg;
+		int i, size = 0, sg_count = scsi_sg_count(SCpnt);
 
-		if (size != SCpnt->request_bufflen && SCpnt->use_sg) {
+		scsi_for_each_sg(SCpnt, sg, sg_count, i)
+			size += sg->length;
+
+		if (size != scsi_bufflen(SCpnt)) {
 			scmd_printk(KERN_ERR, SCpnt,
 				"mismatch count %d, bytes %d\n",
-				size, SCpnt->request_bufflen);
-			if (SCpnt->request_bufflen > size)
-				SCpnt->request_bufflen = size;
+				size, scsi_bufflen(SCpnt));
+			if (scsi_bufflen(SCpnt) > size)
+				SCpnt->sdb.length = size;
 		}
 	}
 
@@ -397,12 +398,12 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	 * request doesn't start on hw block boundary, add scatter pads
 	 */
 	if (((unsigned int)rq->sector % (s_size >> 9)) ||
-	    (SCpnt->request_bufflen % s_size)) {
+	    (scsi_bufflen(SCpnt) % s_size)) {
 		scmd_printk(KERN_NOTICE, SCpnt, "unaligned transfer\n");
 		goto out;
 	}
 
-	this_count = (SCpnt->request_bufflen >> 9) / (s_size >> 9);
+	this_count = (scsi_bufflen(SCpnt) >> 9) / (s_size >> 9);
 
 
 	SCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%ld 512 byte blocks.\n",
@@ -416,7 +417,7 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 
 	if (this_count > 0xffff) {
 		this_count = 0xffff;
-		SCpnt->request_bufflen = this_count * s_size;
+		SCpnt->sdb.length = this_count * s_size;
 	}
 
 	SCpnt->cmnd[2] = (unsigned char) (block >> 24) & 0xff;

commit 210ba1d1724f5c4ed87a2ab1a21ca861a915f734
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sat Jan 5 10:39:51 2008 -0600

    [SCSI] sr: update to follow tray status correctly
    
    Based on an original patch from: David Martin <tasio@tasio.net>
    
    When trying to get the drive status via ioctl CDROM_DRIVE_STATUS, with
    no disk it gives CDS_TRAY_OPEN even if the tray is closed.
    
    ioctl works as expected with ide-cd driver.
    
    Gentoo bug report: http://bugs.gentoo.org/show_bug.cgi?id=196879
    
    Cc: Maarten Bressers <mbres@gentoo.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 896be4ab285d..1fcee16fa36d 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -67,8 +67,6 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 
 #define SR_DISKS	256
 
-#define MAX_RETRIES	3
-#define SR_TIMEOUT	(30 * HZ)
 #define SR_CAPABILITIES \
 	(CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|CDC_SELECT_SPEED| \
 	 CDC_SELECT_DISC|CDC_MULTI_SESSION|CDC_MCN|CDC_MEDIA_CHANGED| \

commit 001aac257cf8adbe90cdcba6e07f8d12dfc8fa6b
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Sun Dec 2 19:10:40 2007 +0200

    [SCSI] sd,sr: add early detection of medium not present
    
    The current scsi_test_unit_ready() is updated to return sense code
    information (in struct scsi_sense_hdr).  The sd and sr drivers are
    changed to interpret the sense code return asc 0x3a as no media and
    adjust the device status accordingly.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 7702681d93f9..896be4ab285d 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -179,18 +179,24 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 {
 	struct scsi_cd *cd = cdi->handle;
 	int retval;
+	struct scsi_sense_hdr *sshdr;
 
 	if (CDSL_CURRENT != slot) {
 		/* no changer support */
 		return -EINVAL;
 	}
 
-	retval = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES);
-	if (retval) {
-		/* Unable to test, unit probably not ready.  This usually
-		 * means there is no disc in the drive.  Mark as changed,
-		 * and we will figure it out later once the drive is
-		 * available again.  */
+	sshdr =  kzalloc(sizeof(*sshdr), GFP_KERNEL);
+	retval = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES,
+				      sshdr);
+	if (retval || (scsi_sense_valid(sshdr) &&
+		       /* 0x3a is medium not present */
+		       sshdr->asc == 0x3a)) {
+		/* Media not present or unable to test, unit probably not
+		 * ready. This usually means there is no disc in the drive.
+		 * Mark as changed, and we will figure it out later once
+		 * the drive is available again.
+		 */
 		cd->device->changed = 1;
 		/* This will force a flush, if called from check_disk_change */
 		retval = 1;
@@ -213,6 +219,7 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 		sdev_evt_send_simple(cd->device, SDEV_EVT_MEDIA_CHANGE,
 				     GFP_KERNEL);
 	cd->previous_state = retval;
+	kfree(sshdr);
 
 	return retval;
 }

commit 285e9670d91cdeb6b6693729950339cb45410fdc
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 14:10:39 2007 +0200

    [SCSI] sr,sd: send media state change modification events
    
    This will send for a card reader slot (remove/add media):
      UEVENT[1187091572.155884] change   /devices/pci0000:00/0000:00:1d.7/usb5/5-2/5-2:1.0/host7/target7:0:0/7:0:0:0 (scsi)
      UEVENT[1187091572.162314] remove   /block/sdb/sdb1 (block)
      UEVENT[1187091572.172464] add      /block/sdb/sdb1 (block)
      UEVENT[1187091572.175408] change   /devices/pci0000:00/0000:00:1d.7/usb5/5-2/5-2:1.0/host7/target7:0:0/7:0:0:0 (scsi)
    
    and for a DVD drive (add/eject media):
      UEVENT[1187091590.189159] change   /devices/pci0000:00/0000:00:1f.1/host4/target4:0:0/4:0:0:0 (scsi)
      UEVENT[1187091590.957124] add      /module/isofs (module)
      UEVENT[1187091604.468207] change   /devices/pci0000:00/0000:00:1f.1/host4/target4:0:0/4:0:0:0 (scsi)
    
    Userspace gets events, even for unpartitioned media. This unifies
    the event handling for asynchronoous events (AN) and events caused by
    perodical polling the device from userspace.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    
    [jejb: modified for new event API]
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index c61999031141..7702681d93f9 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -192,8 +192,9 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 		 * and we will figure it out later once the drive is
 		 * available again.  */
 		cd->device->changed = 1;
-		return 1;	/* This will force a flush, if called from
-				 * check_disk_change */
+		/* This will force a flush, if called from check_disk_change */
+		retval = 1;
+		goto out;
 	};
 
 	retval = cd->device->changed;
@@ -203,9 +204,16 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 	if (retval) {
 		/* check multisession offset etc */
 		sr_cd_check(cdi);
-
 		get_sectorsize(cd);
 	}
+
+out:
+	/* Notify userspace, that media has changed. */
+	if (retval != cd->previous_state)
+		sdev_evt_send_simple(cd->device, SDEV_EVT_MEDIA_CHANGE,
+				     GFP_KERNEL);
+	cd->previous_state = retval;
+
 	return retval;
 }
  

commit 7b3d9545f9ac8b31528dd2d6d8ec8d19922917b8
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun Jan 6 10:17:12 2008 -0800

    Revert "scsi: revert "[SCSI] Get rid of scsi_cmnd->done""
    
    This reverts commit ac40532ef0b8649e6f7f83859ea0de1c4ed08a19, which gets
    us back the original cleanup of 6f5391c283d7fdcf24bf40786ea79061919d1e1d.
    
    It turns out that the bug that was triggered by that commit was
    apparently not actually triggered by that commit at all, and just the
    testing conditions had changed enough to make it appear to be due to it.
    
    The real problem seems to have been found by Peter Osterlund:
    
      "pktcdvd sets it [block device size] when opening the /dev/pktcdvd
       device, but when the drive is later opened as /dev/scd0, there is
       nothing that sets it back.  (Btw, 40944 is possible if the disk is a
       CDRW that was formatted with "cdrwtool -m 10236".)
    
       The problem is that pktcdvd opens the cd device in non-blocking mode
       when pktsetup is run, and doesn't close it again until pktsetup -d is
       run.  The effect is that if you meanwhile open the cd device,
       blkdev.c:do_open() doesn't call bd_set_size() because
       bdev->bd_openers is non-zero."
    
    In particular, to repeat the bug (regardless of whether commit
    6f5391c283d7fdcf24bf40786ea79061919d1e1d is applied or not):
    
      " 1. Start with an empty drive.
        2. pktsetup 0 /dev/scd0
        3. Insert a CD containing an isofs filesystem.
        4. mount /dev/pktcdvd/0 /mnt/tmp
        5. umount /mnt/tmp
        6. Press the eject button.
        7. Insert a DVD containing a non-writable filesystem.
        8. mount /dev/scd0 /mnt/tmp
        9. find /mnt/tmp -type f -print0 | xargs -0 sha1sum >/dev/null
        10. If the DVD contains data beyond the physical size of a CD, you
            get I/O errors in the terminal, and dmesg reports lots of
            "attempt to access beyond end of device" errors."
    
    which in turn is because the nested open after the media change won't
    cause the size to be set properly (because the original open still holds
    the block device, and we only do the bd_set_size() when we don't have
    other people holding the device open).
    
    The proper fix for that is probably to just do something like
    
            bdev->bd_inode->i_size = (loff_t)get_capacity(disk)<<9;
    
    in fs/block_dev.c:do_open() even for the cases where we're not the
    original opener (but *not* call bd_set_size(), since that will also
    change the block size of the device).
    
    Cc: Peter Osterlund <petero2@telia.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index a0c4e13d4dab..c61999031141 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -78,6 +78,7 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
+static int sr_done(struct scsi_cmnd *);
 
 static struct scsi_driver sr_template = {
 	.owner			= THIS_MODULE,
@@ -86,6 +87,7 @@ static struct scsi_driver sr_template = {
 		.probe		= sr_probe,
 		.remove		= sr_remove,
 	},
+	.done			= sr_done,
 };
 
 static unsigned long sr_index_bits[SR_DISKS / BITS_PER_LONG];
@@ -208,12 +210,12 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 }
  
 /*
- * rw_intr is the interrupt routine for the device driver.
+ * sr_done is the interrupt routine for the device driver.
  *
- * It will be notified on the end of a SCSI read / write, and will take on
+ * It will be notified on the end of a SCSI read / write, and will take one
  * of several actions based on success or failure.
  */
-static void rw_intr(struct scsi_cmnd * SCpnt)
+static int sr_done(struct scsi_cmnd *SCpnt)
 {
 	int result = SCpnt->result;
 	int this_count = SCpnt->request_bufflen;
@@ -286,12 +288,7 @@ static void rw_intr(struct scsi_cmnd * SCpnt)
 		}
 	}
 
-	/*
-	 * This calls the generic completion function, now that we know
-	 * how many actual sectors finished, and how many sectors we need
-	 * to say have failed.
-	 */
-	scsi_io_completion(SCpnt, good_bytes);
+	return good_bytes;
 }
 
 static int sr_prep_fn(struct request_queue *q, struct request *rq)
@@ -427,12 +424,6 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	SCpnt->allowed = MAX_RETRIES;
 	SCpnt->timeout_per_command = timeout;
 
-	/*
-	 * This is the completion routine we use.  This is matched in terms
-	 * of capability to this function.
-	 */
-	SCpnt->done = rw_intr;
-
 	/*
 	 * This indicates that the command is ready from our end to be
 	 * queued.

commit ac40532ef0b8649e6f7f83859ea0de1c4ed08a19
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 2 17:25:34 2008 +0100

    scsi: revert "[SCSI] Get rid of scsi_cmnd->done"
    
    This reverts commit 6f5391c283d7fdcf24bf40786ea79061919d1e1d ("[SCSI]
    Get rid of scsi_cmnd->done") that was supposed to be a cleanup commit,
    but apparently it causes regressions:
    
      Bug 9370 - v2.6.24-rc2-409-g9418d5d: attempt to access beyond end of device
      http://bugzilla.kernel.org/show_bug.cgi?id=9370
    
    this patch should be reintroduced in a more split-up form to make
    testing of it easier.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Matthew Wilcox <matthew@wil.cx>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index c61999031141..a0c4e13d4dab 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -78,7 +78,6 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
-static int sr_done(struct scsi_cmnd *);
 
 static struct scsi_driver sr_template = {
 	.owner			= THIS_MODULE,
@@ -87,7 +86,6 @@ static struct scsi_driver sr_template = {
 		.probe		= sr_probe,
 		.remove		= sr_remove,
 	},
-	.done			= sr_done,
 };
 
 static unsigned long sr_index_bits[SR_DISKS / BITS_PER_LONG];
@@ -210,12 +208,12 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 }
  
 /*
- * sr_done is the interrupt routine for the device driver.
+ * rw_intr is the interrupt routine for the device driver.
  *
- * It will be notified on the end of a SCSI read / write, and will take one
+ * It will be notified on the end of a SCSI read / write, and will take on
  * of several actions based on success or failure.
  */
-static int sr_done(struct scsi_cmnd *SCpnt)
+static void rw_intr(struct scsi_cmnd * SCpnt)
 {
 	int result = SCpnt->result;
 	int this_count = SCpnt->request_bufflen;
@@ -288,7 +286,12 @@ static int sr_done(struct scsi_cmnd *SCpnt)
 		}
 	}
 
-	return good_bytes;
+	/*
+	 * This calls the generic completion function, now that we know
+	 * how many actual sectors finished, and how many sectors we need
+	 * to say have failed.
+	 */
+	scsi_io_completion(SCpnt, good_bytes);
 }
 
 static int sr_prep_fn(struct request_queue *q, struct request *rq)
@@ -424,6 +427,12 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	SCpnt->allowed = MAX_RETRIES;
 	SCpnt->timeout_per_command = timeout;
 
+	/*
+	 * This is the completion routine we use.  This is matched in terms
+	 * of capability to this function.
+	 */
+	SCpnt->done = rw_intr;
+
 	/*
 	 * This indicates that the command is ready from our end to be
 	 * queued.

commit 6f5391c283d7fdcf24bf40786ea79061919d1e1d
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Sep 25 12:42:04 2007 -0400

    [SCSI] Get rid of scsi_cmnd->done
    
    The ULD ->done callback moves into the scsi_driver.  By moving the call
    to scsi_io_completion() from scsi_blk_pc_done() to scsi_finish_command(),
    we can eliminate the latter entirely.  By returning 'good_bytes' from
    the ->done callback (rather than invoking scsi_io_completion()), we can
    stop exporting scsi_io_completion().
    
    Also move the prototypes from sd.h to sd.c as they're all internal anyway.
    Rename sd_rw_intr to sd_done and rw_intr to sr_done.
    
    Inspired-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index a0c4e13d4dab..c61999031141 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -78,6 +78,7 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
+static int sr_done(struct scsi_cmnd *);
 
 static struct scsi_driver sr_template = {
 	.owner			= THIS_MODULE,
@@ -86,6 +87,7 @@ static struct scsi_driver sr_template = {
 		.probe		= sr_probe,
 		.remove		= sr_remove,
 	},
+	.done			= sr_done,
 };
 
 static unsigned long sr_index_bits[SR_DISKS / BITS_PER_LONG];
@@ -208,12 +210,12 @@ static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 }
  
 /*
- * rw_intr is the interrupt routine for the device driver.
+ * sr_done is the interrupt routine for the device driver.
  *
- * It will be notified on the end of a SCSI read / write, and will take on
+ * It will be notified on the end of a SCSI read / write, and will take one
  * of several actions based on success or failure.
  */
-static void rw_intr(struct scsi_cmnd * SCpnt)
+static int sr_done(struct scsi_cmnd *SCpnt)
 {
 	int result = SCpnt->result;
 	int this_count = SCpnt->request_bufflen;
@@ -286,12 +288,7 @@ static void rw_intr(struct scsi_cmnd * SCpnt)
 		}
 	}
 
-	/*
-	 * This calls the generic completion function, now that we know
-	 * how many actual sectors finished, and how many sectors we need
-	 * to say have failed.
-	 */
-	scsi_io_completion(SCpnt, good_bytes);
+	return good_bytes;
 }
 
 static int sr_prep_fn(struct request_queue *q, struct request *rq)
@@ -427,12 +424,6 @@ static int sr_prep_fn(struct request_queue *q, struct request *rq)
 	SCpnt->allowed = MAX_RETRIES;
 	SCpnt->timeout_per_command = timeout;
 
-	/*
-	 * This is the completion routine we use.  This is matched in terms
-	 * of capability to this function.
-	 */
-	SCpnt->done = rw_intr;
-
 	/*
 	 * This indicates that the command is ready from our end to be
 	 * queued.

commit 7f9a6bc4e9d59e7fcf03ed23f60cd81ca5d80b65
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sat Aug 4 10:06:25 2007 -0500

    [SCSI] move ULD attachment into the prep function
    
    One of the intents of the block prep function was to allow ULDs to use
    it for preprocessing.  The original SCSI model was to have a single prep
    function and add a pointer indirect filter to build the necessary
    commands.  This patch reverses that, does away with the init_command
    field of the scsi_driver structure and makes ULDs attach directly to the
    prep function instead.  The value is really that it allows us to begin
    to separate the ULDs from the SCSI mid layer (as long as they don't use
    any core functions---which is hard at the moment---a ULD doesn't even
    need SCSI to bind).
    
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 902eb11ffe8a..a0c4e13d4dab 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -78,7 +78,6 @@ MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 
 static int sr_probe(struct device *);
 static int sr_remove(struct device *);
-static int sr_init_command(struct scsi_cmnd *);
 
 static struct scsi_driver sr_template = {
 	.owner			= THIS_MODULE,
@@ -87,7 +86,6 @@ static struct scsi_driver sr_template = {
 		.probe		= sr_probe,
 		.remove		= sr_remove,
 	},
-	.init_command		= sr_init_command,
 };
 
 static unsigned long sr_index_bits[SR_DISKS / BITS_PER_LONG];
@@ -296,19 +294,39 @@ static void rw_intr(struct scsi_cmnd * SCpnt)
 	scsi_io_completion(SCpnt, good_bytes);
 }
 
-static int sr_init_command(struct scsi_cmnd * SCpnt)
+static int sr_prep_fn(struct request_queue *q, struct request *rq)
 {
 	int block=0, this_count, s_size, timeout = SR_TIMEOUT;
-	struct scsi_cd *cd = scsi_cd(SCpnt->request->rq_disk);
+	struct scsi_cd *cd;
+	struct scsi_cmnd *SCpnt;
+	struct scsi_device *sdp = q->queuedata;
+	int ret;
+
+	if (rq->cmd_type == REQ_TYPE_BLOCK_PC) {
+		ret = scsi_setup_blk_pc_cmnd(sdp, rq);
+		goto out;
+	} else if (rq->cmd_type != REQ_TYPE_FS) {
+		ret = BLKPREP_KILL;
+		goto out;
+	}
+	ret = scsi_setup_fs_cmnd(sdp, rq);
+	if (ret != BLKPREP_OK)
+		goto out;
+	SCpnt = rq->special;
+	cd = scsi_cd(rq->rq_disk);
+
+	/* from here on until we're complete, any goto out
+	 * is used for a killable error condition */
+	ret = BLKPREP_KILL;
 
 	SCSI_LOG_HLQUEUE(1, printk("Doing sr request, dev = %s, block = %d\n",
 				cd->disk->disk_name, block));
 
 	if (!cd->device || !scsi_device_online(cd->device)) {
 		SCSI_LOG_HLQUEUE(2, printk("Finishing %ld sectors\n",
-					SCpnt->request->nr_sectors));
+					rq->nr_sectors));
 		SCSI_LOG_HLQUEUE(2, printk("Retry with 0x%p\n", SCpnt));
-		return 0;
+		goto out;
 	}
 
 	if (cd->device->changed) {
@@ -316,7 +334,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 		 * quietly refuse to do anything to a changed disc until the
 		 * changed bit has been reset
 		 */
-		return 0;
+		goto out;
 	}
 
 	/*
@@ -333,21 +351,21 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 
 	if (s_size != 512 && s_size != 1024 && s_size != 2048) {
 		scmd_printk(KERN_ERR, SCpnt, "bad sector size %d\n", s_size);
-		return 0;
+		goto out;
 	}
 
-	if (rq_data_dir(SCpnt->request) == WRITE) {
+	if (rq_data_dir(rq) == WRITE) {
 		if (!cd->device->writeable)
-			return 0;
+			goto out;
 		SCpnt->cmnd[0] = WRITE_10;
 		SCpnt->sc_data_direction = DMA_TO_DEVICE;
  	 	cd->cdi.media_written = 1;
-	} else if (rq_data_dir(SCpnt->request) == READ) {
+	} else if (rq_data_dir(rq) == READ) {
 		SCpnt->cmnd[0] = READ_10;
 		SCpnt->sc_data_direction = DMA_FROM_DEVICE;
 	} else {
-		blk_dump_rq_flags(SCpnt->request, "Unknown sr command");
-		return 0;
+		blk_dump_rq_flags(rq, "Unknown sr command");
+		goto out;
 	}
 
 	{
@@ -368,10 +386,10 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	/*
 	 * request doesn't start on hw block boundary, add scatter pads
 	 */
-	if (((unsigned int)SCpnt->request->sector % (s_size >> 9)) ||
+	if (((unsigned int)rq->sector % (s_size >> 9)) ||
 	    (SCpnt->request_bufflen % s_size)) {
 		scmd_printk(KERN_NOTICE, SCpnt, "unaligned transfer\n");
-		return 0;
+		goto out;
 	}
 
 	this_count = (SCpnt->request_bufflen >> 9) / (s_size >> 9);
@@ -379,12 +397,12 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 
 	SCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%ld 512 byte blocks.\n",
 				cd->cdi.name,
-				(rq_data_dir(SCpnt->request) == WRITE) ?
+				(rq_data_dir(rq) == WRITE) ?
 					"writing" : "reading",
-				this_count, SCpnt->request->nr_sectors));
+				this_count, rq->nr_sectors));
 
 	SCpnt->cmnd[1] = 0;
-	block = (unsigned int)SCpnt->request->sector / (s_size >> 9);
+	block = (unsigned int)rq->sector / (s_size >> 9);
 
 	if (this_count > 0xffff) {
 		this_count = 0xffff;
@@ -419,7 +437,9 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	 * This indicates that the command is ready from our end to be
 	 * queued.
 	 */
-	return 1;
+	ret = BLKPREP_OK;
+ out:
+	return scsi_prep_return(q, rq, ret);
 }
 
 static int sr_block_open(struct inode *inode, struct file *file)
@@ -590,6 +610,7 @@ static int sr_probe(struct device *dev)
 
 	/* FIXME: need to handle a get_capabilities failure properly ?? */
 	get_capabilities(cd);
+	blk_queue_prep_rq(sdev->request_queue, sr_prep_fn);
 	sr_vendor_init(cd);
 
 	disk->driverfs_dev = &sdev->sdev_gendev;

commit 165125e1e480f9510a5ffcfbfee4e3ee38c05f23
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Jul 24 09:28:11 2007 +0200

    [BLOCK] Get rid of request_queue_t typedef
    
    Some of the code has been gradually transitioned to using the proper
    struct request_queue, but there's lots left. So do a full sweet of
    the kernel and get rid of this typedef and replace its uses with
    the proper type.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index e7b6a7fde1cb..902eb11ffe8a 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -624,7 +624,7 @@ static void get_sectorsize(struct scsi_cd *cd)
 	unsigned char *buffer;
 	int the_result, retries = 3;
 	int sector_size;
-	request_queue_t *queue;
+	struct request_queue *queue;
 
 	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
 	if (!buffer)

commit 44818efbad185eea75adad0e8cab97650a7370ab
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jul 9 11:59:59 2007 -0700

    [SCSI] small cleanups
    
    This patch contains the following cleanups:
    - make needlessly global functions static
    - every file should #include the headers containing the prototypes for
      it's global functions
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 5143c8990845..e7b6a7fde1cb 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -175,7 +175,7 @@ static void scsi_cd_put(struct scsi_cd *cd)
  * an inode for that to work, and we do not always have one.
  */
 
-int sr_media_change(struct cdrom_device_info *cdi, int slot)
+static int sr_media_change(struct cdrom_device_info *cdi, int slot)
 {
 	struct scsi_cd *cd = cdi->handle;
 	int retval;

commit da3962fe63eae4f490356cb54e4700eac752541b
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Tue Jun 26 00:39:33 2007 +0900

    [SCSI] sr: fix error handling in module_init
    
    Sweep registered blkdev when scsi_register_driver has failed.
    
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index f9a52af7f5b4..5143c8990845 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -885,7 +885,11 @@ static int __init init_sr(void)
 	rc = register_blkdev(SCSI_CDROM_MAJOR, "sr");
 	if (rc)
 		return rc;
-	return scsi_register_driver(&sr_template.gendrv);
+	rc = scsi_register_driver(&sr_template.gendrv);
+	if (rc)
+		unregister_blkdev(SCSI_CDROM_MAJOR, "sr");
+
+	return rc;
 }
 
 static void __exit exit_sr(void)

commit d7b8bcb0a0819315a51cae620ff7ae0c1704c069
Author: Michael Tokarev <mjt@tls.msk.ru>
Date:   Fri Oct 27 16:02:37 2006 +0400

    [SCSI] modalias for scsi devices
    
    The following patch adds support for sysfs/uevent modalias
    attribute for scsi devices (like disks, tapes, cdroms etc),
    based on whatever current sd.c, sr.c, st.c and osst.c drivers
    supports.
    
    The modalias format is like this:
    
     scsi:type-0x04
    
    (for TYPE_WORM, handled by sr.c now).
    
    Several comments.
    
    o This hexadecimal type value is because all TYPE_XXX constants
      in include/scsi/scsi.h are given in hex, but __stringify() will
      not convert them to decimal (so it will NOT be scsi:type-4).
      Since it does not really matter in which format it is, while
      both modalias in module and modalias attribute match each other,
      I descided to go for that 0x%02x format (and added a comment in
      include/scsi/scsi.h to keep them that way), instead of changing
      them all to decimal.
    
    o There was no .uevent routine for SCSI bus.  It might be a good
      idea to add some more ueven environment variables in there.
    
    o osst.c driver handles tapes too, like st.c, but only SOME tapes.
      With this setup, hotplug scripts (or whatever is used by the
      user) will try to load both st and osst modules for all SCSI
      tapes found, because both modules have scsi:type-0x01 alias).
      It is not harmful, but one extra module is no good either.
      It is possible to solve this, by exporting more info in
      modalias attribute, including vendor and device identification
      strings, so that modalias becomes something like
        scsi:type-0x12:vendor-Adaptec LTD:device-OnStream Tape Drive
      and having that, match for all 3 attributes, not only device
      type.  But oh well, vendor and device strings may be large,
      and they do contain spaces and whatnot.
      So I left them for now, awaiting for comments first.
    
    Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 1857d68e7195..f9a52af7f5b4 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -62,6 +62,8 @@
 MODULE_DESCRIPTION("SCSI cdrom (sr) driver");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_CDROM_MAJOR);
+MODULE_ALIAS_SCSI_DEVICE(TYPE_ROM);
+MODULE_ALIAS_SCSI_DEVICE(TYPE_WORM);
 
 #define SR_DISKS	256
 

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 89e9b36b1788..1857d68e7195 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -35,7 +35,6 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/bio.h>
 #include <linux/string.h>

commit 6397256b0af52082db3b7f804aa3b612a17dcbc9
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jan 2 17:41:04 2007 +0900

    [SCSI] sr: fix error code check in sr_block_ioctl()
    
    sr_block_ioctl() should proceed to SCSI ioctls if cdrom_ioctl()
    returns -ENOSYS.  However it tested for ENOSYS instead of -ENOSYS
    rendering all SCSI ioctls other than GET_IDLUN and GET_BUS_NUMBER
    inaccessible.  Fix it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index fae6e95a6298..89e9b36b1788 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -468,7 +468,7 @@ static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
 	}
 
 	ret = cdrom_ioctl(file, &cd->cdi, inode, cmd, arg);
-	if (ret != ENOSYS)
+	if (ret != -ENOSYS)
 		return ret;
 
 	/*

commit 631c228cd09bd5b93090fa60bd9803ec14aa0586
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 8 20:42:15 2006 +0200

    [SCSI] hide EH backup data outside the scsi_cmnd
    
    Currently struct scsi_cmnd has various fields that are used to backup
    original data after the corresponding fields have been overridden for
    EH commands.  This means drivers can easily get at it and misuse it.
    Due to the old_ naming this doesn't happen for most of them, but two
    that have different names have been used wrong a lot (see previous
    patch).  Another downside is that they unessecarily bloat the scsi_cmnd
    size.
    
    This patch moves them onstack in scsi_send_eh_cmnd to fix those two
    issues aswell as allowing future EH fixes like moving the EH command
    submissions to use SG lists like everything else.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index fd94408577e5..fae6e95a6298 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -360,7 +360,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 				"mismatch count %d, bytes %d\n",
 				size, SCpnt->request_bufflen);
 			if (SCpnt->request_bufflen > size)
-				SCpnt->request_bufflen = SCpnt->bufflen = size;
+				SCpnt->request_bufflen = size;
 		}
 	}
 
@@ -387,8 +387,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 
 	if (this_count > 0xffff) {
 		this_count = 0xffff;
-		SCpnt->request_bufflen = SCpnt->bufflen =
-				this_count * s_size;
+		SCpnt->request_bufflen = this_count * s_size;
 	}
 
 	SCpnt->cmnd[2] = (unsigned char) (block >> 24) & 0xff;

commit 03aba2f79594ca94d159c8bab454de9bcc385b76
Author: Luben Tuikov <ltuikov@yahoo.com>
Date:   Fri Jun 23 09:39:09 2006 -0700

    [SCSI] sd/scsi_lib simplify sd_rw_intr and scsi_io_completion
    
    This patch simplifies "good_bytes" computation in sd_rw_intr().
    sd: "good_bytes" computation is always done in terms of the resolution
    of the device's medium, since after that it is the number of good bytes
    we pass around and other layers/contexts (as opposed ot sd) can translate
    that to their own resolution (block layer:512).  It also makes
    scsi_io_completion() processing more straightforward, eliminating the
    3rd argument to the function.
    
    It also fixes a couple of bugs like not checking return value,
    using "break" instead of "return;", etc.
    
    I've been running with this patch for some time now on a
    test (do-it-all) system.
    
    Signed-off-by: Luben Tuikov <ltuikov@yahoo.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index ebf6579ed698..fd94408577e5 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -292,7 +292,7 @@ static void rw_intr(struct scsi_cmnd * SCpnt)
 	 * how many actual sectors finished, and how many sectors we need
 	 * to say have failed.
 	 */
-	scsi_io_completion(SCpnt, good_bytes, block_sectors << 9);
+	scsi_io_completion(SCpnt, good_bytes);
 }
 
 static int sr_init_command(struct scsi_cmnd * SCpnt)

commit 5d5ff44fe6775ccb922fd1f7d478b2ba9ca95068
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 13:21:13 2006 +0200

    [SCSI] fix up request buffer reference in various scsi drivers
    
    Various scsi drivers use scsi_cmnd.buffer and scsi_cmnd.bufflen in their
    queuecommand functions.  Those fields are internal storage for the
    midlayer only and are used to restore the original payload after
    request_buffer and request_bufflen have been overwritten for EH.  Using
    the buffer and bufflen fields means they do very broken things in error
    handling.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 7c80711e18ed..ebf6579ed698 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -217,7 +217,7 @@ int sr_media_change(struct cdrom_device_info *cdi, int slot)
 static void rw_intr(struct scsi_cmnd * SCpnt)
 {
 	int result = SCpnt->result;
-	int this_count = SCpnt->bufflen;
+	int this_count = SCpnt->request_bufflen;
 	int good_bytes = (result == 0 ? this_count : 0);
 	int block_sectors = 0;
 	long error_sector;

commit 6a2900b67652421b51fe25e4b86ecfec742b1f30
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Mar 23 03:00:15 2006 -0800

    [PATCH] kill cdrom ->dev_ioctl method
    
    Since early 2.4.x all cdrom drivers implement the block_device methods
    themselves, so they can handle additional ioctls directly instead of going
    through the cdrom layer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index f9c1192dc15e..7c80711e18ed 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -71,7 +71,7 @@ MODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_CDROM_MAJOR);
 #define SR_CAPABILITIES \
 	(CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|CDC_SELECT_SPEED| \
 	 CDC_SELECT_DISC|CDC_MULTI_SESSION|CDC_MCN|CDC_MEDIA_CHANGED| \
-	 CDC_PLAY_AUDIO|CDC_RESET|CDC_IOCTLS|CDC_DRIVE_STATUS| \
+	 CDC_PLAY_AUDIO|CDC_RESET|CDC_DRIVE_STATUS| \
 	 CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_DVD_RAM|CDC_GENERIC_PACKET| \
 	 CDC_MRW|CDC_MRW_W|CDC_RAM)
 
@@ -118,7 +118,6 @@ static struct cdrom_device_ops sr_dops = {
 	.get_mcn		= sr_get_mcn,
 	.reset			= sr_reset,
 	.audio_ioctl		= sr_audio_ioctl,
-	.dev_ioctl		= sr_dev_ioctl,
 	.capability		= SR_CAPABILITIES,
 	.generic_packet		= sr_packet,
 };
@@ -456,17 +455,33 @@ static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
 {
 	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
 	struct scsi_device *sdev = cd->device;
+	void __user *argp = (void __user *)arg;
+	int ret;
 
-        /*
-         * Send SCSI addressing ioctls directly to mid level, send other
-         * ioctls to cdrom/block level.
-         */
-        switch (cmd) {
-                case SCSI_IOCTL_GET_IDLUN:
-                case SCSI_IOCTL_GET_BUS_NUMBER:
-                        return scsi_ioctl(sdev, cmd, (void __user *)arg);
+	/*
+	 * Send SCSI addressing ioctls directly to mid level, send other
+	 * ioctls to cdrom/block level.
+	 */
+	switch (cmd) {
+	case SCSI_IOCTL_GET_IDLUN:
+	case SCSI_IOCTL_GET_BUS_NUMBER:
+		return scsi_ioctl(sdev, cmd, argp);
 	}
-	return cdrom_ioctl(file, &cd->cdi, inode, cmd, arg);
+
+	ret = cdrom_ioctl(file, &cd->cdi, inode, cmd, arg);
+	if (ret != ENOSYS)
+		return ret;
+
+	/*
+	 * ENODEV means that we didn't recognise the ioctl, or that we
+	 * cannot execute it in the current device state.  In either
+	 * case fall through to scsi_ioctl, which will return ENDOEV again
+	 * if it doesn't recognise the ioctl
+	 */
+	ret = scsi_nonblockable_ioctl(sdev, cmd, argp, NULL);
+	if (ret != -ENODEV)
+		return ret;
+	return scsi_ioctl(sdev, cmd, argp);
 }
 
 static int sr_block_media_changed(struct gendisk *disk)

commit f018fa552c52642a6b9db2bda90477762e42163f
Author: Rene Herman <rene.herman@keyaccess.nl>
Date:   Wed Mar 8 00:14:20 2006 -0800

    [SCSI] MODULE_ALIAS_{BLOCK,CHAR}DEV_MAJOR for drivers/scsi
    
    Add device-major aliases in drivers/scsi, allowing kmod autoload:
    
    MODULE_ALIAS_CHARDEV_MAJOR(SCSI_CHANGER_MAJOR)
    MODULE_ALIAS_CHARDEV_MAJOR(OSST_MAJOR)
    MODULE_ALIAS_CHARDEV_MAJOR(SCSI_TAPE_MAJOR)
    MODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_CDROM_MAJOR)
    MODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISKN_MAJOR)
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Acked-by: Kai Makisara <kai.makisara@kolumbus.fi>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 328837b7ccb9..f9c1192dc15e 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -60,6 +60,10 @@
 #include "sr.h"
 
 
+MODULE_DESCRIPTION("SCSI cdrom (sr) driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_CDROM_MAJOR);
+
 #define SR_DISKS	256
 
 #define MAX_RETRIES	3

commit 5e3c34c1e988a0dfe177c38cf324e8e321c55ef5
Author: Greg KH <gregkh@suse.de>
Date:   Wed Jan 18 16:17:46 2006 -0800

    [SCSI] Remove devfs support from the SCSI subsystem
    
    As devfs has been disabled from the kernel tree for a number of months
    now (5 to be exact), here's a patch against 2.6.16-rc1-git1 that removes
    support for it from the SCSI subsystem.
    
    The patch also removes the scsi_disk devfs_name field as it's no longer
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d8d12a1718bf..328837b7ccb9 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -573,8 +573,6 @@ static int sr_probe(struct device *dev)
 	get_capabilities(cd);
 	sr_vendor_init(cd);
 
-	snprintf(disk->devfs_name, sizeof(disk->devfs_name),
-			"%s/cd", sdev->devfs_name);
 	disk->driverfs_dev = &sdev->sdev_gendev;
 	set_capacity(disk, cd->capacity);
 	disk->private_data = &cd->driver;

commit 24669f75a3231fa37444977c92d1f4838bec1233
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 16 10:31:18 2006 -0500

    [SCSI] SCSI core kmalloc2kzalloc
    
    Change the core SCSI code to use kzalloc rather than kmalloc+memset
    where possible.
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 997f8e30509b..d8d12a1718bf 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -525,10 +525,9 @@ static int sr_probe(struct device *dev)
 		goto fail;
 
 	error = -ENOMEM;
-	cd = kmalloc(sizeof(*cd), GFP_KERNEL);
+	cd = kzalloc(sizeof(*cd), GFP_KERNEL);
 	if (!cd)
 		goto fail;
-	memset(cd, 0, sizeof(*cd));
 
 	kref_init(&cd->kref);
 

commit 858119e159384308a5dde67776691a2ebf70df0f
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Sat Jan 14 13:20:43 2006 -0800

    [PATCH] Unlinline a bunch of other functions
    
    Remove the "inline" keyword from a bunch of big functions in the kernel with
    the goal of shrinking it by 30kb to 40kb
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index dd8050392d01..997f8e30509b 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -151,7 +151,7 @@ static inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)
 	return cd;
 }
 
-static inline void scsi_cd_put(struct scsi_cd *cd)
+static void scsi_cd_put(struct scsi_cd *cd)
 {
 	struct scsi_device *sdev = cd->device;
 

commit 776b23a0363d99ca402edc1aba1db8099b747b33
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 6 18:34:07 2006 +0100

    [SCSI] always handle REQ_BLOCK_PC requests in common code
    
    LLDDs should never see REQ_BLOCK_PC requests, we can handle them just
    fine in the core code.  There is a small behaviour change in that some
    check in sr's rw_intr are bypassed, but I consider the old behaviour
    a bug.
    
    Mike found this cleanup opportunity and provdided early patches, so all
    the credit goes to him, even if I redid the patches from scratch beause
    that was easier than forward-porting the old patches.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 18a3b756c63c..dd8050392d01 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -238,8 +238,6 @@ static void rw_intr(struct scsi_cmnd * SCpnt)
 		case ILLEGAL_REQUEST:
 			if (!(SCpnt->sense_buffer[0] & 0x90))
 				break;
-			if (!blk_fs_request(SCpnt->request))
-				break;
 			error_sector = (SCpnt->sense_buffer[3] << 24) |
 				(SCpnt->sense_buffer[4] << 16) |
 				(SCpnt->sense_buffer[5] << 8) |
@@ -317,23 +315,6 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 		return 0;
 	}
 
-	/*
-	 * these are already setup, just copy cdb basically
-	 */
-	if (SCpnt->request->flags & REQ_BLOCK_PC) {
-		scsi_setup_blk_pc_cmnd(SCpnt);
-
-		if (SCpnt->timeout_per_command)
-			timeout = SCpnt->timeout_per_command;
-
-		goto queue;
-	}
-
-	if (!(SCpnt->request->flags & REQ_CMD)) {
-		blk_dump_rq_flags(SCpnt->request, "sr unsup command");
-		return 0;
-	}
-
 	/*
 	 * we do lazy blocksize switching (when reading XA sectors,
 	 * see CDROMREADMODE2 ioctl) 
@@ -422,8 +403,6 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	 */
 	SCpnt->transfersize = cd->device->sector_size;
 	SCpnt->underflow = this_count << 9;
-
-queue:
 	SCpnt->allowed = MAX_RETRIES;
 	SCpnt->timeout_per_command = timeout;
 

commit bcc1e382bce8de4f26182c6447916f9c82b0fbe5
Author: Chuck Ebbert <76306.1226@compuserve.com>
Date:   Wed Jan 11 23:58:40 2006 -0500

    [SCSI] Mask capabilities for SCSI-1 CD drive
    
    SCSI-1 CD drives can't do MRW or be opened for writing, so mask off
    those capabilities.
    
    Signed-off-by: Chuck Ebbert <76306.1226@compuserve.com>
    Acked-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index ec73223ad2ea..18a3b756c63c 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -763,8 +763,9 @@ static void get_capabilities(struct scsi_cd *cd)
 		/* failed, drive doesn't have capabilities mode page */
 		cd->cdi.speed = 1;
 		cd->cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |
-					 CDC_DVD | CDC_DVD_RAM |
-					 CDC_SELECT_DISC | CDC_SELECT_SPEED);
+				 CDC_DVD | CDC_DVD_RAM |
+				 CDC_SELECT_DISC | CDC_SELECT_SPEED |
+				 CDC_MRW | CDC_MRW_W | CDC_RAM);
 		kfree(buffer);
 		printk("%s: scsi-1 drive\n", cd->cdi.name);
 		return;

commit 0b9506723826c68b50fa33e345700ddcac1bed36
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 13:16:10 2006 +0100

    [SCSI] turn most scsi semaphores into mutexes
    
    the scsi layer is using semaphores in a mutex way, this patch converts
    these into using mutexes instead
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index a4d9be7c6874..ec73223ad2ea 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -44,6 +44,7 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
+#include <linux/mutex.h>
 #include <asm/uaccess.h>
 
 #include <scsi/scsi.h>
@@ -90,7 +91,7 @@ static DEFINE_SPINLOCK(sr_index_lock);
 /* This semaphore is used to mediate the 0->1 reference get in the
  * face of object destruction (i.e. we can't allow a get on an
  * object after last put) */
-static DECLARE_MUTEX(sr_ref_sem);
+static DEFINE_MUTEX(sr_ref_mutex);
 
 static int sr_open(struct cdrom_device_info *, int);
 static void sr_release(struct cdrom_device_info *);
@@ -133,7 +134,7 @@ static inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)
 {
 	struct scsi_cd *cd = NULL;
 
-	down(&sr_ref_sem);
+	mutex_lock(&sr_ref_mutex);
 	if (disk->private_data == NULL)
 		goto out;
 	cd = scsi_cd(disk);
@@ -146,7 +147,7 @@ static inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)
 	kref_put(&cd->kref, sr_kref_release);
 	cd = NULL;
  out:
-	up(&sr_ref_sem);
+	mutex_unlock(&sr_ref_mutex);
 	return cd;
 }
 
@@ -154,10 +155,10 @@ static inline void scsi_cd_put(struct scsi_cd *cd)
 {
 	struct scsi_device *sdev = cd->device;
 
-	down(&sr_ref_sem);
+	mutex_lock(&sr_ref_mutex);
 	kref_put(&cd->kref, sr_kref_release);
 	scsi_device_put(sdev);
-	up(&sr_ref_sem);
+	mutex_unlock(&sr_ref_mutex);
 }
 
 /*
@@ -845,7 +846,7 @@ static int sr_packet(struct cdrom_device_info *cdi,
  *	sr_kref_release - Called to free the scsi_cd structure
  *	@kref: pointer to embedded kref
  *
- *	sr_ref_sem must be held entering this routine.  Because it is
+ *	sr_ref_mutex must be held entering this routine.  Because it is
  *	called on last put, you should always use the scsi_cd_get()
  *	scsi_cd_put() helpers which manipulate the semaphore directly
  *	and never do a direct kref_put().
@@ -874,9 +875,9 @@ static int sr_remove(struct device *dev)
 
 	del_gendisk(cd->disk);
 
-	down(&sr_ref_sem);
+	mutex_lock(&sr_ref_mutex);
 	kref_put(&cd->kref, sr_kref_release);
-	up(&sr_ref_sem);
+	mutex_unlock(&sr_ref_mutex);
 
 	return 0;
 }

commit 7b16318dea8d9840dac567a2ae8c50ecdea36aea
Author: James Bottomley <jejb@titanic.(none)>
Date:   Thu Dec 15 20:17:02 2005 -0600

    Fix up SCSI mismerge
    
    I forgot to do a git-update-cache on the merged files ...

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 7e7398d563cc..a4d9be7c6874 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -320,7 +320,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	 * these are already setup, just copy cdb basically
 	 */
 	if (SCpnt->request->flags & REQ_BLOCK_PC) {
-		scsi_setup_blk_pc_cmnd(SCpnt, MAX_RETRIES);
+		scsi_setup_blk_pc_cmnd(SCpnt);
 
 		if (SCpnt->timeout_per_command)
 			timeout = SCpnt->timeout_per_command;

commit 2a1e1379bae53f647c463a677cc2ec71b591c348
Merge: 787926b1b2d2 7b6666530e27
Author: James Bottomley <jejb@titanic.(none)>
Date:   Thu Dec 15 17:35:24 2005 -0600

    Merge by hand (conflicts in scsi_lib.c)
    
    This merge is pretty extensive.  The conflict is over the new
    req->retries parameter, so I had to change the prototype to
    scsi_setup_blk_pc_cmnd() and the usage in sd, sr and st.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

commit c9526497cf03ee775c3a6f8ba62335735f98de7a
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Dec 9 17:45:22 2005 -0500

    [SCSI] Consolidate REQ_BLOCK_PC handling path (fix ipod panic)
    
    This follows on from Jens' patch and consolidates all of the ULD
    separate handlers for REQ_BLOCK_PC into a single call which has his
    fix for our direction bug.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d68cea753bb2..fb4012b5c188 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -320,25 +320,11 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	 * these are already setup, just copy cdb basically
 	 */
 	if (SCpnt->request->flags & REQ_BLOCK_PC) {
-		struct request *rq = SCpnt->request;
+		scsi_setup_blk_pc_cmnd(SCpnt, MAX_RETRIES);
 
-		if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
-			return 0;
-
-		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
-		SCpnt->cmd_len = rq->cmd_len;
-		if (!rq->data_len)
-			SCpnt->sc_data_direction = DMA_NONE;
-		else if (rq_data_dir(rq) == WRITE)
-			SCpnt->sc_data_direction = DMA_TO_DEVICE;
-		else
-			SCpnt->sc_data_direction = DMA_FROM_DEVICE;
-
-		this_count = rq->data_len;
-		if (rq->timeout)
-			timeout = rq->timeout;
+		if (SCpnt->timeout_per_command)
+			timeout = SCpnt->timeout_per_command;
 
-		SCpnt->transfersize = rq->data_len;
 		goto queue;
 	}
 

commit 0ad78200baf1f85a21e6b26c225717ad80980d8f
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Nov 28 16:22:25 2005 +0100

    [SCSI] Mark some core scsi data structures const
    
    patch below marks a few scsi core datastructures as const, so that they end up
    in the .rodata section and don't cacheline share with things that get dirtied
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index d68cea753bb2..a3fa64cf6650 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -730,7 +730,7 @@ static void get_capabilities(struct scsi_cd *cd)
 	unsigned int the_result;
 	int retries, rc, n;
 
-	static char *loadmech[] =
+	static const char *loadmech[] =
 	{
 		"caddy",
 		"tray",

commit 3bf743e7c891d8be8295650b7a6a9b5af083b096
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:04:06 2005 -0400

    [SCSI] use {sdev,scmd,starget,shost}_printk in generic code
    
    rejections fixed and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 3067e5a7b75e..d68cea753bb2 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -360,7 +360,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	}
 
 	if (s_size != 512 && s_size != 1024 && s_size != 2048) {
-		sdev_printk(KERN_ERR, SCpnt->device, "bad sector size %d\n", s_size);
+		scmd_printk(KERN_ERR, SCpnt, "bad sector size %d\n", s_size);
 		return 0;
 	}
 
@@ -385,9 +385,9 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 			size += sg[i].length;
 
 		if (size != SCpnt->request_bufflen && SCpnt->use_sg) {
-			sdev_printk(KERN_ERR, SCpnt->device,
-				    "mismatch count %d, bytes %d\n",
-				    size, SCpnt->request_bufflen);
+			scmd_printk(KERN_ERR, SCpnt,
+				"mismatch count %d, bytes %d\n",
+				size, SCpnt->request_bufflen);
 			if (SCpnt->request_bufflen > size)
 				SCpnt->request_bufflen = SCpnt->bufflen = size;
 		}
@@ -398,7 +398,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	 */
 	if (((unsigned int)SCpnt->request->sector % (s_size >> 9)) ||
 	    (SCpnt->request_bufflen % s_size)) {
-		sdev_printk(KERN_NOTICE, SCpnt->device, "unaligned transfer\n");
+		scmd_printk(KERN_NOTICE, SCpnt, "unaligned transfer\n");
 		return 0;
 	}
 

commit 80d904c43b11105c16395b240078ccc2f7ac6074
Author: Jayachandran C <jchandra@digeo.com>
Date:   Tue Oct 18 17:11:16 2005 -0700

    [SCSI] sr: remove dead code
    
    This patch fixes an issue reported in drivers/scsi/sr.c by Coverity
    
    Error reported: Pointer returned from "scsi_cd" is never used
    
    Patch description:
     Remove the scsi_cd() call as it does not have any effect.
    
    Signed-off-by: Jayachandran C. <c.jayachandran@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 9e267c6d3a43..3067e5a7b75e 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -456,7 +456,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 static int sr_block_open(struct inode *inode, struct file *file)
 {
 	struct gendisk *disk = inode->i_bdev->bd_disk;
-	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
+	struct scsi_cd *cd;
 	int ret = 0;
 
 	if(!(cd = scsi_cd_get(disk)))

commit 9ccfc756a70d454dfa82f48897e2883560c01a0e
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Oct 2 11:45:08 2005 -0500

    [SCSI] move the mid-layer printk's over to shost/starget/sdev_printk
    
    This should eliminate (at least in the mid layer) to make numeric
    assumptions about any of the enumeration variables.  As a side effect,
    it will also make all the messages consistent and line us up nicely for
    the error logging strategy (if it ever shows itself again).
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 561901b1cf11..9e267c6d3a43 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -360,7 +360,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	}
 
 	if (s_size != 512 && s_size != 1024 && s_size != 2048) {
-		printk("sr: bad sector size %d\n", s_size);
+		sdev_printk(KERN_ERR, SCpnt->device, "bad sector size %d\n", s_size);
 		return 0;
 	}
 
@@ -385,8 +385,9 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 			size += sg[i].length;
 
 		if (size != SCpnt->request_bufflen && SCpnt->use_sg) {
-			printk(KERN_ERR "sr: mismatch count %d, bytes %d\n",
-					size, SCpnt->request_bufflen);
+			sdev_printk(KERN_ERR, SCpnt->device,
+				    "mismatch count %d, bytes %d\n",
+				    size, SCpnt->request_bufflen);
 			if (SCpnt->request_bufflen > size)
 				SCpnt->request_bufflen = SCpnt->bufflen = size;
 		}
@@ -397,7 +398,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 	 */
 	if (((unsigned int)SCpnt->request->sector % (s_size >> 9)) ||
 	    (SCpnt->request_bufflen % s_size)) {
-		printk("sr: unaligned transfer\n");
+		sdev_printk(KERN_NOTICE, SCpnt->device, "unaligned transfer\n");
 		return 0;
 	}
 
@@ -622,10 +623,8 @@ static int sr_probe(struct device *dev)
 	disk->flags |= GENHD_FL_REMOVABLE;
 	add_disk(disk);
 
-	printk(KERN_DEBUG
-	    "Attached scsi CD-ROM %s at scsi%d, channel %d, id %d, lun %d\n",
-	    cd->cdi.name, sdev->host->host_no, sdev->channel,
-	    sdev->id, sdev->lun);
+	sdev_printk(KERN_DEBUG, sdev,
+		    "Attached scsi CD-ROM %s\n", cd->cdi.name);
 	return 0;
 
 fail_put:

commit 186d330e682210100c671355580a8592e4a21692
Author: Timothy Thelin <Timothy.Thelin@wdc.com>
Date:   Tue Sep 13 19:56:28 2005 -0700

    [SCSI] scsi: sd, sr, st, and scsi_lib all fail to copy cmd_len to new cmd
    
    This fixes an issue in scsi command initialization from a request
    where sd, sr, st, and scsi_lib all fail to copy the request's
    cmd_len to the scsi command's cmd_len field.
    
    Signed-off-by: Timothy Thelin <timothy.thelin@wdc.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index ce63fc8312dc..561901b1cf11 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -326,6 +326,7 @@ static int sr_init_command(struct scsi_cmnd * SCpnt)
 			return 0;
 
 		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
+		SCpnt->cmd_len = rq->cmd_len;
 		if (!rq->data_len)
 			SCpnt->sc_data_direction = DMA_NONE;
 		else if (rq_data_dir(rq) == WRITE)

commit ba482ef4b16bad5172d2be693d4b2420b84c84e7
Merge: e514385be2b3 51490c89f95b
Author: James Bottomley <jejb@titanic.(none)>
Date:   Sun Aug 28 11:40:00 2005 -0500

    Merge by hand (conflicts in sr.c)

commit 820732b501a5bbdd3bde1263f391891e21b5ed8c
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Jun 12 22:21:29 2005 -0500

    [SCSI] convert sr to scsi_execute_req
    
    This follows almost the identical model to sd, except that there's one
    ioctl which returns raw sense data, so it had to use scsi_execute()
    instead.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 8cbe6e004187..39fc5b0fbc18 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -50,10 +50,10 @@
 #include <scsi/scsi_dbg.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_driver.h>
+#include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_ioctl.h>	/* For the door lock/unlock commands */
-#include <scsi/scsi_request.h>
 
 #include "scsi_logging.h"
 #include "sr.h"
@@ -658,39 +658,27 @@ static void get_sectorsize(struct scsi_cd *cd)
 	unsigned char *buffer;
 	int the_result, retries = 3;
 	int sector_size;
-	struct scsi_request *SRpnt = NULL;
 	request_queue_t *queue;
 
 	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
 	if (!buffer)
 		goto Enomem;
-	SRpnt = scsi_allocate_request(cd->device, GFP_KERNEL);
-	if (!SRpnt)
-		goto Enomem;
 
 	do {
 		cmd[0] = READ_CAPACITY;
 		memset((void *) &cmd[1], 0, 9);
-		/* Mark as really busy */
-		SRpnt->sr_request->rq_status = RQ_SCSI_BUSY;
-		SRpnt->sr_cmd_len = 0;
-
 		memset(buffer, 0, 8);
 
 		/* Do the command and wait.. */
-		SRpnt->sr_data_direction = DMA_FROM_DEVICE;
-		scsi_wait_req(SRpnt, (void *) cmd, (void *) buffer,
-			      8, SR_TIMEOUT, MAX_RETRIES);
+		the_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,
+					      buffer, 8, NULL, SR_TIMEOUT,
+					      MAX_RETRIES);
 
-		the_result = SRpnt->sr_result;
 		retries--;
 
 	} while (the_result && retries);
 
 
-	scsi_release_request(SRpnt);
-	SRpnt = NULL;
-
 	if (the_result) {
 		cd->capacity = 0x1fffff;
 		sector_size = 2048;	/* A guess, just in case */
@@ -750,8 +738,6 @@ static void get_sectorsize(struct scsi_cd *cd)
 	cd->capacity = 0x1fffff;
 	sector_size = 2048;	/* A guess, just in case */
 	cd->needs_sector_size = 1;
-	if (SRpnt)
-		scsi_release_request(SRpnt);
 	goto out;
 }
 
@@ -759,8 +745,8 @@ static void get_capabilities(struct scsi_cd *cd)
 {
 	unsigned char *buffer;
 	struct scsi_mode_data data;
-	struct scsi_request *SRpnt;
 	unsigned char cmd[MAX_COMMAND_SIZE];
+	struct scsi_sense_hdr sshdr;
 	unsigned int the_result;
 	int retries, rc, n;
 
@@ -776,19 +762,11 @@ static void get_capabilities(struct scsi_cd *cd)
 		""
 	};
 
-	/* allocate a request for the TEST_UNIT_READY */
-	SRpnt = scsi_allocate_request(cd->device, GFP_KERNEL);
-	if (!SRpnt) {
-		printk(KERN_WARNING "(get_capabilities:) Request allocation "
-		       "failure.\n");
-		return;
-	}
 
 	/* allocate transfer buffer */
 	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
 	if (!buffer) {
 		printk(KERN_ERR "sr: out of memory.\n");
-		scsi_release_request(SRpnt);
 		return;
 	}
 
@@ -800,20 +778,15 @@ static void get_capabilities(struct scsi_cd *cd)
 		memset((void *)cmd, 0, MAX_COMMAND_SIZE);
 		cmd[0] = TEST_UNIT_READY;
 
-		SRpnt->sr_cmd_len = 0;
-		SRpnt->sr_sense_buffer[0] = 0;
-		SRpnt->sr_sense_buffer[2] = 0;
-		SRpnt->sr_data_direction = DMA_NONE;
-
-		scsi_wait_req (SRpnt, (void *) cmd, buffer,
-			       0, SR_TIMEOUT, MAX_RETRIES);
+		the_result = scsi_execute_req (cd->device, cmd, DMA_NONE, NULL,
+					       0, &sshdr, SR_TIMEOUT,
+					       MAX_RETRIES);
 
-		the_result = SRpnt->sr_result;
 		retries++;
 	} while (retries < 5 && 
 		 (!scsi_status_is_good(the_result) ||
-		  ((driver_byte(the_result) & DRIVER_SENSE) &&
-		   SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION)));
+		  (scsi_sense_valid(&sshdr) &&
+		   sshdr.sense_key == UNIT_ATTENTION)));
 
 	/* ask for mode page 0x2a */
 	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,
@@ -825,7 +798,6 @@ static void get_capabilities(struct scsi_cd *cd)
 		cd->cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |
 					 CDC_DVD | CDC_DVD_RAM |
 					 CDC_SELECT_DISC | CDC_SELECT_SPEED);
-		scsi_release_request(SRpnt);
 		kfree(buffer);
 		printk("%s: scsi-1 drive\n", cd->cdi.name);
 		return;
@@ -885,7 +857,6 @@ static void get_capabilities(struct scsi_cd *cd)
 		cd->device->writeable = 1;
 	}
 
-	scsi_release_request(SRpnt);
 	kfree(buffer);
 }
 

commit 1cf72699c1530c3e4ac3d58344f6a6a40a2f46d3
Author: James Bottomley <jejb@titanic.(none)>
Date:   Sun Aug 28 11:27:01 2005 -0500

    [SCSI] convert the remaining mid-layer pieces to scsi_execute_req
    
    After this, we just have some drivers, all the ULDs and the SPI
    transport class using scsi_wait_req().
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 2f259f249522..8cbe6e004187 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -817,7 +817,7 @@ static void get_capabilities(struct scsi_cd *cd)
 
 	/* ask for mode page 0x2a */
 	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,
-			     SR_TIMEOUT, 3, &data);
+			     SR_TIMEOUT, 3, &data, NULL);
 
 	if (!scsi_status_is_good(rc)) {
 		/* failed, drive doesn't have capabilities mode page */

commit 51490c89f95b8581782e9baa855da166441852be
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Tue Jul 5 18:18:08 2005 -0700

    [SCSI] sr.c: Fix getting wrong size
    
    Here's the problem. Try to do this on 2.6.12:
    - Kill udev and HAL
    - Insert a CD-ROM into a SCSI or USB CD-ROM drive
    - Run dd if=/dev/scd0
    - cat /sys/block/sr0/size
    - Eject the CD, insert a different one
    - Run dd if=/dev/scd0
    This is likely to do "access beyond the end of device", if you let it
    - cat /sys/block/sr0/size
    This shows the size of a previous CD, even though dd was supposed
    to revalidate the device.
    - Run dd if=/dev/scd0
    The second run of dd works correctly!
    
    The bug was introduced in 2.5.31, when Al fixes the recursive opens
    in partitioning. Before, the code worked like this:
    - Block layer called cdrom_open directly
    - cdrom_open called sr_open
    - sr_open called check_disk_change
    - check_disk_change called sr_media_change
    - sr_media_change did cd->needs_disk_change=1
    - before returning sr_open tested cd->needs_disk_change
      and called get_sector_size.
    
    In 2.6.12, the check_disk_change is called from cdrom_open only. Thus:
    - Block layer calls sr_bd_open
    - sr_bd_open calls cdrom_open
    - cdrom_open calls sr_open
    - sr_open tests cd->needs_disk_change, which wasn't set yet; returns
    - cdrom_open calls check_disk_change
    - check_disk_change calls sr_media_change
    - sr_media_change does cd->needs_disk_change=1, but nobody cares
    
    Acked by: Alexander Viro <aviro@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 2f259f249522..f63d8c6c2a33 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -199,15 +199,7 @@ int sr_media_change(struct cdrom_device_info *cdi, int slot)
 		/* check multisession offset etc */
 		sr_cd_check(cdi);
 
-		/* 
-		 * If the disk changed, the capacity will now be different,
-		 * so we force a re-read of this information 
-		 * Force 2048 for the sector size so that filesystems won't
-		 * be trying to use something that is too small if the disc
-		 * has changed.
-		 */
-		cd->needs_sector_size = 1;
-		cd->device->sector_size = 2048;
+		get_sectorsize(cd);
 	}
 	return retval;
 }
@@ -538,13 +530,6 @@ static int sr_open(struct cdrom_device_info *cdi, int purpose)
 	if (!scsi_block_when_processing_errors(sdev))
 		goto error_out;
 
-	/*
-	 * If this device did not have media in the drive at boot time, then
-	 * we would have been unable to get the sector size.  Check to see if
-	 * this is the case, and try again.
-	 */
-	if (cd->needs_sector_size)
-		get_sectorsize(cd);
 	return 0;
 
 error_out:
@@ -604,7 +589,6 @@ static int sr_probe(struct device *dev)
 	cd->driver = &sr_template;
 	cd->disk = disk;
 	cd->capacity = 0x1fffff;
-	cd->needs_sector_size = 1;
 	cd->device->changed = 1;	/* force recheck CD type */
 	cd->use = 1;
 	cd->readcd_known = 0;
@@ -694,7 +678,6 @@ static void get_sectorsize(struct scsi_cd *cd)
 	if (the_result) {
 		cd->capacity = 0x1fffff;
 		sector_size = 2048;	/* A guess, just in case */
-		cd->needs_sector_size = 1;
 	} else {
 #if 0
 		if (cdrom_get_last_written(&cd->cdi,
@@ -727,7 +710,6 @@ static void get_sectorsize(struct scsi_cd *cd)
 			printk("%s: unsupported sector size %d.\n",
 			       cd->cdi.name, sector_size);
 			cd->capacity = 0;
-			cd->needs_sector_size = 1;
 		}
 
 		cd->device->sector_size = sector_size;
@@ -736,7 +718,6 @@ static void get_sectorsize(struct scsi_cd *cd)
 		 * Add this so that we have the ability to correctly gauge
 		 * what the device is capable of.
 		 */
-		cd->needs_sector_size = 0;
 		set_capacity(cd->disk, cd->capacity);
 	}
 
@@ -748,8 +729,7 @@ static void get_sectorsize(struct scsi_cd *cd)
 
 Enomem:
 	cd->capacity = 0x1fffff;
-	sector_size = 2048;	/* A guess, just in case */
-	cd->needs_sector_size = 1;
+	cd->device->sector_size = 2048;	/* A guess, just in case */
 	if (SRpnt)
 		scsi_release_request(SRpnt);
 	goto out;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
new file mode 100644
index 000000000000..2f259f249522
--- /dev/null
+++ b/drivers/scsi/sr.c
@@ -0,0 +1,965 @@
+/*
+ *  sr.c Copyright (C) 1992 David Giller
+ *           Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale
+ *
+ *  adapted from:
+ *      sd.c Copyright (C) 1992 Drew Eckhardt
+ *      Linux scsi disk driver by
+ *              Drew Eckhardt <drew@colorado.edu>
+ *
+ *	Modified by Eric Youngdale ericy@andante.org to
+ *	add scatter-gather, multiple outstanding request, and other
+ *	enhancements.
+ *
+ *      Modified by Eric Youngdale eric@andante.org to support loadable
+ *      low-level scsi drivers.
+ *
+ *      Modified by Thomas Quinot thomas@melchior.cuivre.fdn.fr to
+ *      provide auto-eject.
+ *
+ *      Modified by Gerd Knorr <kraxel@cs.tu-berlin.de> to support the
+ *      generic cdrom interface
+ *
+ *      Modified by Jens Axboe <axboe@suse.de> - Uniform sr_packet()
+ *      interface, capabilities probe additions, ioctl cleanups, etc.
+ *
+ *	Modified by Richard Gooch <rgooch@atnf.csiro.au> to support devfs
+ *
+ *	Modified by Jens Axboe <axboe@suse.de> - support DVD-RAM
+ *	transparently and lose the GHOST hack
+ *
+ *	Modified by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *	check resource allocation in sr_init and some cleanups
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/bio.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/cdrom.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <asm/uaccess.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_driver.h>
+#include <scsi/scsi_eh.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_ioctl.h>	/* For the door lock/unlock commands */
+#include <scsi/scsi_request.h>
+
+#include "scsi_logging.h"
+#include "sr.h"
+
+
+#define SR_DISKS	256
+
+#define MAX_RETRIES	3
+#define SR_TIMEOUT	(30 * HZ)
+#define SR_CAPABILITIES \
+	(CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|CDC_SELECT_SPEED| \
+	 CDC_SELECT_DISC|CDC_MULTI_SESSION|CDC_MCN|CDC_MEDIA_CHANGED| \
+	 CDC_PLAY_AUDIO|CDC_RESET|CDC_IOCTLS|CDC_DRIVE_STATUS| \
+	 CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_DVD_RAM|CDC_GENERIC_PACKET| \
+	 CDC_MRW|CDC_MRW_W|CDC_RAM)
+
+static int sr_probe(struct device *);
+static int sr_remove(struct device *);
+static int sr_init_command(struct scsi_cmnd *);
+
+static struct scsi_driver sr_template = {
+	.owner			= THIS_MODULE,
+	.gendrv = {
+		.name   	= "sr",
+		.probe		= sr_probe,
+		.remove		= sr_remove,
+	},
+	.init_command		= sr_init_command,
+};
+
+static unsigned long sr_index_bits[SR_DISKS / BITS_PER_LONG];
+static DEFINE_SPINLOCK(sr_index_lock);
+
+/* This semaphore is used to mediate the 0->1 reference get in the
+ * face of object destruction (i.e. we can't allow a get on an
+ * object after last put) */
+static DECLARE_MUTEX(sr_ref_sem);
+
+static int sr_open(struct cdrom_device_info *, int);
+static void sr_release(struct cdrom_device_info *);
+
+static void get_sectorsize(struct scsi_cd *);
+static void get_capabilities(struct scsi_cd *);
+
+static int sr_media_change(struct cdrom_device_info *, int);
+static int sr_packet(struct cdrom_device_info *, struct packet_command *);
+
+static struct cdrom_device_ops sr_dops = {
+	.open			= sr_open,
+	.release	 	= sr_release,
+	.drive_status	 	= sr_drive_status,
+	.media_changed		= sr_media_change,
+	.tray_move		= sr_tray_move,
+	.lock_door		= sr_lock_door,
+	.select_speed		= sr_select_speed,
+	.get_last_session	= sr_get_last_session,
+	.get_mcn		= sr_get_mcn,
+	.reset			= sr_reset,
+	.audio_ioctl		= sr_audio_ioctl,
+	.dev_ioctl		= sr_dev_ioctl,
+	.capability		= SR_CAPABILITIES,
+	.generic_packet		= sr_packet,
+};
+
+static void sr_kref_release(struct kref *kref);
+
+static inline struct scsi_cd *scsi_cd(struct gendisk *disk)
+{
+	return container_of(disk->private_data, struct scsi_cd, driver);
+}
+
+/*
+ * The get and put routines for the struct scsi_cd.  Note this entity
+ * has a scsi_device pointer and owns a reference to this.
+ */
+static inline struct scsi_cd *scsi_cd_get(struct gendisk *disk)
+{
+	struct scsi_cd *cd = NULL;
+
+	down(&sr_ref_sem);
+	if (disk->private_data == NULL)
+		goto out;
+	cd = scsi_cd(disk);
+	kref_get(&cd->kref);
+	if (scsi_device_get(cd->device))
+		goto out_put;
+	goto out;
+
+ out_put:
+	kref_put(&cd->kref, sr_kref_release);
+	cd = NULL;
+ out:
+	up(&sr_ref_sem);
+	return cd;
+}
+
+static inline void scsi_cd_put(struct scsi_cd *cd)
+{
+	struct scsi_device *sdev = cd->device;
+
+	down(&sr_ref_sem);
+	kref_put(&cd->kref, sr_kref_release);
+	scsi_device_put(sdev);
+	up(&sr_ref_sem);
+}
+
+/*
+ * This function checks to see if the media has been changed in the
+ * CDROM drive.  It is possible that we have already sensed a change,
+ * or the drive may have sensed one and not yet reported it.  We must
+ * be ready for either case. This function always reports the current
+ * value of the changed bit.  If flag is 0, then the changed bit is reset.
+ * This function could be done as an ioctl, but we would need to have
+ * an inode for that to work, and we do not always have one.
+ */
+
+int sr_media_change(struct cdrom_device_info *cdi, int slot)
+{
+	struct scsi_cd *cd = cdi->handle;
+	int retval;
+
+	if (CDSL_CURRENT != slot) {
+		/* no changer support */
+		return -EINVAL;
+	}
+
+	retval = scsi_test_unit_ready(cd->device, SR_TIMEOUT, MAX_RETRIES);
+	if (retval) {
+		/* Unable to test, unit probably not ready.  This usually
+		 * means there is no disc in the drive.  Mark as changed,
+		 * and we will figure it out later once the drive is
+		 * available again.  */
+		cd->device->changed = 1;
+		return 1;	/* This will force a flush, if called from
+				 * check_disk_change */
+	};
+
+	retval = cd->device->changed;
+	cd->device->changed = 0;
+	/* If the disk changed, the capacity will now be different,
+	 * so we force a re-read of this information */
+	if (retval) {
+		/* check multisession offset etc */
+		sr_cd_check(cdi);
+
+		/* 
+		 * If the disk changed, the capacity will now be different,
+		 * so we force a re-read of this information 
+		 * Force 2048 for the sector size so that filesystems won't
+		 * be trying to use something that is too small if the disc
+		 * has changed.
+		 */
+		cd->needs_sector_size = 1;
+		cd->device->sector_size = 2048;
+	}
+	return retval;
+}
+ 
+/*
+ * rw_intr is the interrupt routine for the device driver.
+ *
+ * It will be notified on the end of a SCSI read / write, and will take on
+ * of several actions based on success or failure.
+ */
+static void rw_intr(struct scsi_cmnd * SCpnt)
+{
+	int result = SCpnt->result;
+	int this_count = SCpnt->bufflen;
+	int good_bytes = (result == 0 ? this_count : 0);
+	int block_sectors = 0;
+	long error_sector;
+	struct scsi_cd *cd = scsi_cd(SCpnt->request->rq_disk);
+
+#ifdef DEBUG
+	printk("sr.c done: %x\n", result);
+#endif
+
+	/*
+	 * Handle MEDIUM ERRORs or VOLUME OVERFLOWs that indicate partial
+	 * success.  Since this is a relatively rare error condition, no
+	 * care is taken to avoid unnecessary additional work such as
+	 * memcpy's that could be avoided.
+	 */
+	if (driver_byte(result) != 0 &&		/* An error occurred */
+	    (SCpnt->sense_buffer[0] & 0x7f) == 0x70) { /* Sense current */
+		switch (SCpnt->sense_buffer[2]) {
+		case MEDIUM_ERROR:
+		case VOLUME_OVERFLOW:
+		case ILLEGAL_REQUEST:
+			if (!(SCpnt->sense_buffer[0] & 0x90))
+				break;
+			if (!blk_fs_request(SCpnt->request))
+				break;
+			error_sector = (SCpnt->sense_buffer[3] << 24) |
+				(SCpnt->sense_buffer[4] << 16) |
+				(SCpnt->sense_buffer[5] << 8) |
+				SCpnt->sense_buffer[6];
+			if (SCpnt->request->bio != NULL)
+				block_sectors =
+					bio_sectors(SCpnt->request->bio);
+			if (block_sectors < 4)
+				block_sectors = 4;
+			if (cd->device->sector_size == 2048)
+				error_sector <<= 2;
+			error_sector &= ~(block_sectors - 1);
+			good_bytes = (error_sector - SCpnt->request->sector) << 9;
+			if (good_bytes < 0 || good_bytes >= this_count)
+				good_bytes = 0;
+			/*
+			 * The SCSI specification allows for the value
+			 * returned by READ CAPACITY to be up to 75 2K
+			 * sectors past the last readable block.
+			 * Therefore, if we hit a medium error within the
+			 * last 75 2K sectors, we decrease the saved size
+			 * value.
+			 */
+			if (error_sector < get_capacity(cd->disk) &&
+			    cd->capacity - error_sector < 4 * 75)
+				set_capacity(cd->disk, error_sector);
+			break;
+
+		case RECOVERED_ERROR:
+
+			/*
+			 * An error occured, but it recovered.  Inform the
+			 * user, but make sure that it's not treated as a
+			 * hard error.
+			 */
+			scsi_print_sense("sr", SCpnt);
+			SCpnt->result = 0;
+			SCpnt->sense_buffer[0] = 0x0;
+			good_bytes = this_count;
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/*
+	 * This calls the generic completion function, now that we know
+	 * how many actual sectors finished, and how many sectors we need
+	 * to say have failed.
+	 */
+	scsi_io_completion(SCpnt, good_bytes, block_sectors << 9);
+}
+
+static int sr_init_command(struct scsi_cmnd * SCpnt)
+{
+	int block=0, this_count, s_size, timeout = SR_TIMEOUT;
+	struct scsi_cd *cd = scsi_cd(SCpnt->request->rq_disk);
+
+	SCSI_LOG_HLQUEUE(1, printk("Doing sr request, dev = %s, block = %d\n",
+				cd->disk->disk_name, block));
+
+	if (!cd->device || !scsi_device_online(cd->device)) {
+		SCSI_LOG_HLQUEUE(2, printk("Finishing %ld sectors\n",
+					SCpnt->request->nr_sectors));
+		SCSI_LOG_HLQUEUE(2, printk("Retry with 0x%p\n", SCpnt));
+		return 0;
+	}
+
+	if (cd->device->changed) {
+		/*
+		 * quietly refuse to do anything to a changed disc until the
+		 * changed bit has been reset
+		 */
+		return 0;
+	}
+
+	/*
+	 * these are already setup, just copy cdb basically
+	 */
+	if (SCpnt->request->flags & REQ_BLOCK_PC) {
+		struct request *rq = SCpnt->request;
+
+		if (sizeof(rq->cmd) > sizeof(SCpnt->cmnd))
+			return 0;
+
+		memcpy(SCpnt->cmnd, rq->cmd, sizeof(SCpnt->cmnd));
+		if (!rq->data_len)
+			SCpnt->sc_data_direction = DMA_NONE;
+		else if (rq_data_dir(rq) == WRITE)
+			SCpnt->sc_data_direction = DMA_TO_DEVICE;
+		else
+			SCpnt->sc_data_direction = DMA_FROM_DEVICE;
+
+		this_count = rq->data_len;
+		if (rq->timeout)
+			timeout = rq->timeout;
+
+		SCpnt->transfersize = rq->data_len;
+		goto queue;
+	}
+
+	if (!(SCpnt->request->flags & REQ_CMD)) {
+		blk_dump_rq_flags(SCpnt->request, "sr unsup command");
+		return 0;
+	}
+
+	/*
+	 * we do lazy blocksize switching (when reading XA sectors,
+	 * see CDROMREADMODE2 ioctl) 
+	 */
+	s_size = cd->device->sector_size;
+	if (s_size > 2048) {
+		if (!in_interrupt())
+			sr_set_blocklength(cd, 2048);
+		else
+			printk("sr: can't switch blocksize: in interrupt\n");
+	}
+
+	if (s_size != 512 && s_size != 1024 && s_size != 2048) {
+		printk("sr: bad sector size %d\n", s_size);
+		return 0;
+	}
+
+	if (rq_data_dir(SCpnt->request) == WRITE) {
+		if (!cd->device->writeable)
+			return 0;
+		SCpnt->cmnd[0] = WRITE_10;
+		SCpnt->sc_data_direction = DMA_TO_DEVICE;
+ 	 	cd->cdi.media_written = 1;
+	} else if (rq_data_dir(SCpnt->request) == READ) {
+		SCpnt->cmnd[0] = READ_10;
+		SCpnt->sc_data_direction = DMA_FROM_DEVICE;
+	} else {
+		blk_dump_rq_flags(SCpnt->request, "Unknown sr command");
+		return 0;
+	}
+
+	{
+		struct scatterlist *sg = SCpnt->request_buffer;
+		int i, size = 0;
+		for (i = 0; i < SCpnt->use_sg; i++)
+			size += sg[i].length;
+
+		if (size != SCpnt->request_bufflen && SCpnt->use_sg) {
+			printk(KERN_ERR "sr: mismatch count %d, bytes %d\n",
+					size, SCpnt->request_bufflen);
+			if (SCpnt->request_bufflen > size)
+				SCpnt->request_bufflen = SCpnt->bufflen = size;
+		}
+	}
+
+	/*
+	 * request doesn't start on hw block boundary, add scatter pads
+	 */
+	if (((unsigned int)SCpnt->request->sector % (s_size >> 9)) ||
+	    (SCpnt->request_bufflen % s_size)) {
+		printk("sr: unaligned transfer\n");
+		return 0;
+	}
+
+	this_count = (SCpnt->request_bufflen >> 9) / (s_size >> 9);
+
+
+	SCSI_LOG_HLQUEUE(2, printk("%s : %s %d/%ld 512 byte blocks.\n",
+				cd->cdi.name,
+				(rq_data_dir(SCpnt->request) == WRITE) ?
+					"writing" : "reading",
+				this_count, SCpnt->request->nr_sectors));
+
+	SCpnt->cmnd[1] = 0;
+	block = (unsigned int)SCpnt->request->sector / (s_size >> 9);
+
+	if (this_count > 0xffff) {
+		this_count = 0xffff;
+		SCpnt->request_bufflen = SCpnt->bufflen =
+				this_count * s_size;
+	}
+
+	SCpnt->cmnd[2] = (unsigned char) (block >> 24) & 0xff;
+	SCpnt->cmnd[3] = (unsigned char) (block >> 16) & 0xff;
+	SCpnt->cmnd[4] = (unsigned char) (block >> 8) & 0xff;
+	SCpnt->cmnd[5] = (unsigned char) block & 0xff;
+	SCpnt->cmnd[6] = SCpnt->cmnd[9] = 0;
+	SCpnt->cmnd[7] = (unsigned char) (this_count >> 8) & 0xff;
+	SCpnt->cmnd[8] = (unsigned char) this_count & 0xff;
+
+	/*
+	 * We shouldn't disconnect in the middle of a sector, so with a dumb
+	 * host adapter, it's safe to assume that we can at least transfer
+	 * this many bytes between each connect / disconnect.
+	 */
+	SCpnt->transfersize = cd->device->sector_size;
+	SCpnt->underflow = this_count << 9;
+
+queue:
+	SCpnt->allowed = MAX_RETRIES;
+	SCpnt->timeout_per_command = timeout;
+
+	/*
+	 * This is the completion routine we use.  This is matched in terms
+	 * of capability to this function.
+	 */
+	SCpnt->done = rw_intr;
+
+	/*
+	 * This indicates that the command is ready from our end to be
+	 * queued.
+	 */
+	return 1;
+}
+
+static int sr_block_open(struct inode *inode, struct file *file)
+{
+	struct gendisk *disk = inode->i_bdev->bd_disk;
+	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
+	int ret = 0;
+
+	if(!(cd = scsi_cd_get(disk)))
+		return -ENXIO;
+
+	if((ret = cdrom_open(&cd->cdi, inode, file)) != 0)
+		scsi_cd_put(cd);
+
+	return ret;
+}
+
+static int sr_block_release(struct inode *inode, struct file *file)
+{
+	int ret;
+	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
+	ret = cdrom_release(&cd->cdi, file);
+	if(ret)
+		return ret;
+	
+	scsi_cd_put(cd);
+
+	return 0;
+}
+
+static int sr_block_ioctl(struct inode *inode, struct file *file, unsigned cmd,
+			  unsigned long arg)
+{
+	struct scsi_cd *cd = scsi_cd(inode->i_bdev->bd_disk);
+	struct scsi_device *sdev = cd->device;
+
+        /*
+         * Send SCSI addressing ioctls directly to mid level, send other
+         * ioctls to cdrom/block level.
+         */
+        switch (cmd) {
+                case SCSI_IOCTL_GET_IDLUN:
+                case SCSI_IOCTL_GET_BUS_NUMBER:
+                        return scsi_ioctl(sdev, cmd, (void __user *)arg);
+	}
+	return cdrom_ioctl(file, &cd->cdi, inode, cmd, arg);
+}
+
+static int sr_block_media_changed(struct gendisk *disk)
+{
+	struct scsi_cd *cd = scsi_cd(disk);
+	return cdrom_media_changed(&cd->cdi);
+}
+
+static struct block_device_operations sr_bdops =
+{
+	.owner		= THIS_MODULE,
+	.open		= sr_block_open,
+	.release	= sr_block_release,
+	.ioctl		= sr_block_ioctl,
+	.media_changed	= sr_block_media_changed,
+	/* 
+	 * No compat_ioctl for now because sr_block_ioctl never
+	 * seems to pass arbitary ioctls down to host drivers.
+	 */
+};
+
+static int sr_open(struct cdrom_device_info *cdi, int purpose)
+{
+	struct scsi_cd *cd = cdi->handle;
+	struct scsi_device *sdev = cd->device;
+	int retval;
+
+	/*
+	 * If the device is in error recovery, wait until it is done.
+	 * If the device is offline, then disallow any access to it.
+	 */
+	retval = -ENXIO;
+	if (!scsi_block_when_processing_errors(sdev))
+		goto error_out;
+
+	/*
+	 * If this device did not have media in the drive at boot time, then
+	 * we would have been unable to get the sector size.  Check to see if
+	 * this is the case, and try again.
+	 */
+	if (cd->needs_sector_size)
+		get_sectorsize(cd);
+	return 0;
+
+error_out:
+	return retval;	
+}
+
+static void sr_release(struct cdrom_device_info *cdi)
+{
+	struct scsi_cd *cd = cdi->handle;
+
+	if (cd->device->sector_size > 2048)
+		sr_set_blocklength(cd, 2048);
+
+}
+
+static int sr_probe(struct device *dev)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+	struct gendisk *disk;
+	struct scsi_cd *cd;
+	int minor, error;
+
+	error = -ENODEV;
+	if (sdev->type != TYPE_ROM && sdev->type != TYPE_WORM)
+		goto fail;
+
+	error = -ENOMEM;
+	cd = kmalloc(sizeof(*cd), GFP_KERNEL);
+	if (!cd)
+		goto fail;
+	memset(cd, 0, sizeof(*cd));
+
+	kref_init(&cd->kref);
+
+	disk = alloc_disk(1);
+	if (!disk)
+		goto fail_free;
+
+	spin_lock(&sr_index_lock);
+	minor = find_first_zero_bit(sr_index_bits, SR_DISKS);
+	if (minor == SR_DISKS) {
+		spin_unlock(&sr_index_lock);
+		error = -EBUSY;
+		goto fail_put;
+	}
+	__set_bit(minor, sr_index_bits);
+	spin_unlock(&sr_index_lock);
+
+	disk->major = SCSI_CDROM_MAJOR;
+	disk->first_minor = minor;
+	sprintf(disk->disk_name, "sr%d", minor);
+	disk->fops = &sr_bdops;
+	disk->flags = GENHD_FL_CD;
+
+	cd->device = sdev;
+	cd->disk = disk;
+	cd->driver = &sr_template;
+	cd->disk = disk;
+	cd->capacity = 0x1fffff;
+	cd->needs_sector_size = 1;
+	cd->device->changed = 1;	/* force recheck CD type */
+	cd->use = 1;
+	cd->readcd_known = 0;
+	cd->readcd_cdda = 0;
+
+	cd->cdi.ops = &sr_dops;
+	cd->cdi.handle = cd;
+	cd->cdi.mask = 0;
+	cd->cdi.capacity = 1;
+	sprintf(cd->cdi.name, "sr%d", minor);
+
+	sdev->sector_size = 2048;	/* A guess, just in case */
+
+	/* FIXME: need to handle a get_capabilities failure properly ?? */
+	get_capabilities(cd);
+	sr_vendor_init(cd);
+
+	snprintf(disk->devfs_name, sizeof(disk->devfs_name),
+			"%s/cd", sdev->devfs_name);
+	disk->driverfs_dev = &sdev->sdev_gendev;
+	set_capacity(disk, cd->capacity);
+	disk->private_data = &cd->driver;
+	disk->queue = sdev->request_queue;
+	cd->cdi.disk = disk;
+
+	if (register_cdrom(&cd->cdi))
+		goto fail_put;
+
+	dev_set_drvdata(dev, cd);
+	disk->flags |= GENHD_FL_REMOVABLE;
+	add_disk(disk);
+
+	printk(KERN_DEBUG
+	    "Attached scsi CD-ROM %s at scsi%d, channel %d, id %d, lun %d\n",
+	    cd->cdi.name, sdev->host->host_no, sdev->channel,
+	    sdev->id, sdev->lun);
+	return 0;
+
+fail_put:
+	put_disk(disk);
+fail_free:
+	kfree(cd);
+fail:
+	return error;
+}
+
+
+static void get_sectorsize(struct scsi_cd *cd)
+{
+	unsigned char cmd[10];
+	unsigned char *buffer;
+	int the_result, retries = 3;
+	int sector_size;
+	struct scsi_request *SRpnt = NULL;
+	request_queue_t *queue;
+
+	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		goto Enomem;
+	SRpnt = scsi_allocate_request(cd->device, GFP_KERNEL);
+	if (!SRpnt)
+		goto Enomem;
+
+	do {
+		cmd[0] = READ_CAPACITY;
+		memset((void *) &cmd[1], 0, 9);
+		/* Mark as really busy */
+		SRpnt->sr_request->rq_status = RQ_SCSI_BUSY;
+		SRpnt->sr_cmd_len = 0;
+
+		memset(buffer, 0, 8);
+
+		/* Do the command and wait.. */
+		SRpnt->sr_data_direction = DMA_FROM_DEVICE;
+		scsi_wait_req(SRpnt, (void *) cmd, (void *) buffer,
+			      8, SR_TIMEOUT, MAX_RETRIES);
+
+		the_result = SRpnt->sr_result;
+		retries--;
+
+	} while (the_result && retries);
+
+
+	scsi_release_request(SRpnt);
+	SRpnt = NULL;
+
+	if (the_result) {
+		cd->capacity = 0x1fffff;
+		sector_size = 2048;	/* A guess, just in case */
+		cd->needs_sector_size = 1;
+	} else {
+#if 0
+		if (cdrom_get_last_written(&cd->cdi,
+					   &cd->capacity))
+#endif
+			cd->capacity = 1 + ((buffer[0] << 24) |
+						    (buffer[1] << 16) |
+						    (buffer[2] << 8) |
+						    buffer[3]);
+		sector_size = (buffer[4] << 24) |
+		    (buffer[5] << 16) | (buffer[6] << 8) | buffer[7];
+		switch (sector_size) {
+			/*
+			 * HP 4020i CD-Recorder reports 2340 byte sectors
+			 * Philips CD-Writers report 2352 byte sectors
+			 *
+			 * Use 2k sectors for them..
+			 */
+		case 0:
+		case 2340:
+		case 2352:
+			sector_size = 2048;
+			/* fall through */
+		case 2048:
+			cd->capacity *= 4;
+			/* fall through */
+		case 512:
+			break;
+		default:
+			printk("%s: unsupported sector size %d.\n",
+			       cd->cdi.name, sector_size);
+			cd->capacity = 0;
+			cd->needs_sector_size = 1;
+		}
+
+		cd->device->sector_size = sector_size;
+
+		/*
+		 * Add this so that we have the ability to correctly gauge
+		 * what the device is capable of.
+		 */
+		cd->needs_sector_size = 0;
+		set_capacity(cd->disk, cd->capacity);
+	}
+
+	queue = cd->device->request_queue;
+	blk_queue_hardsect_size(queue, sector_size);
+out:
+	kfree(buffer);
+	return;
+
+Enomem:
+	cd->capacity = 0x1fffff;
+	sector_size = 2048;	/* A guess, just in case */
+	cd->needs_sector_size = 1;
+	if (SRpnt)
+		scsi_release_request(SRpnt);
+	goto out;
+}
+
+static void get_capabilities(struct scsi_cd *cd)
+{
+	unsigned char *buffer;
+	struct scsi_mode_data data;
+	struct scsi_request *SRpnt;
+	unsigned char cmd[MAX_COMMAND_SIZE];
+	unsigned int the_result;
+	int retries, rc, n;
+
+	static char *loadmech[] =
+	{
+		"caddy",
+		"tray",
+		"pop-up",
+		"",
+		"changer",
+		"cartridge changer",
+		"",
+		""
+	};
+
+	/* allocate a request for the TEST_UNIT_READY */
+	SRpnt = scsi_allocate_request(cd->device, GFP_KERNEL);
+	if (!SRpnt) {
+		printk(KERN_WARNING "(get_capabilities:) Request allocation "
+		       "failure.\n");
+		return;
+	}
+
+	/* allocate transfer buffer */
+	buffer = kmalloc(512, GFP_KERNEL | GFP_DMA);
+	if (!buffer) {
+		printk(KERN_ERR "sr: out of memory.\n");
+		scsi_release_request(SRpnt);
+		return;
+	}
+
+	/* issue TEST_UNIT_READY until the initial startup UNIT_ATTENTION
+	 * conditions are gone, or a timeout happens
+	 */
+	retries = 0;
+	do {
+		memset((void *)cmd, 0, MAX_COMMAND_SIZE);
+		cmd[0] = TEST_UNIT_READY;
+
+		SRpnt->sr_cmd_len = 0;
+		SRpnt->sr_sense_buffer[0] = 0;
+		SRpnt->sr_sense_buffer[2] = 0;
+		SRpnt->sr_data_direction = DMA_NONE;
+
+		scsi_wait_req (SRpnt, (void *) cmd, buffer,
+			       0, SR_TIMEOUT, MAX_RETRIES);
+
+		the_result = SRpnt->sr_result;
+		retries++;
+	} while (retries < 5 && 
+		 (!scsi_status_is_good(the_result) ||
+		  ((driver_byte(the_result) & DRIVER_SENSE) &&
+		   SRpnt->sr_sense_buffer[2] == UNIT_ATTENTION)));
+
+	/* ask for mode page 0x2a */
+	rc = scsi_mode_sense(cd->device, 0, 0x2a, buffer, 128,
+			     SR_TIMEOUT, 3, &data);
+
+	if (!scsi_status_is_good(rc)) {
+		/* failed, drive doesn't have capabilities mode page */
+		cd->cdi.speed = 1;
+		cd->cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |
+					 CDC_DVD | CDC_DVD_RAM |
+					 CDC_SELECT_DISC | CDC_SELECT_SPEED);
+		scsi_release_request(SRpnt);
+		kfree(buffer);
+		printk("%s: scsi-1 drive\n", cd->cdi.name);
+		return;
+	}
+
+	n = data.header_length + data.block_descriptor_length;
+	cd->cdi.speed = ((buffer[n + 8] << 8) + buffer[n + 9]) / 176;
+	cd->readcd_known = 1;
+	cd->readcd_cdda = buffer[n + 5] & 0x01;
+	/* print some capability bits */
+	printk("%s: scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s\n", cd->cdi.name,
+	       ((buffer[n + 14] << 8) + buffer[n + 15]) / 176,
+	       cd->cdi.speed,
+	       buffer[n + 3] & 0x01 ? "writer " : "", /* CD Writer */
+	       buffer[n + 3] & 0x20 ? "dvd-ram " : "",
+	       buffer[n + 2] & 0x02 ? "cd/rw " : "", /* can read rewriteable */
+	       buffer[n + 4] & 0x20 ? "xa/form2 " : "",	/* can read xa/from2 */
+	       buffer[n + 5] & 0x01 ? "cdda " : "", /* can read audio data */
+	       loadmech[buffer[n + 6] >> 5]);
+	if ((buffer[n + 6] >> 5) == 0)
+		/* caddy drives can't close tray... */
+		cd->cdi.mask |= CDC_CLOSE_TRAY;
+	if ((buffer[n + 2] & 0x8) == 0)
+		/* not a DVD drive */
+		cd->cdi.mask |= CDC_DVD;
+	if ((buffer[n + 3] & 0x20) == 0) 
+		/* can't write DVD-RAM media */
+		cd->cdi.mask |= CDC_DVD_RAM;
+	if ((buffer[n + 3] & 0x10) == 0)
+		/* can't write DVD-R media */
+		cd->cdi.mask |= CDC_DVD_R;
+	if ((buffer[n + 3] & 0x2) == 0)
+		/* can't write CD-RW media */
+		cd->cdi.mask |= CDC_CD_RW;
+	if ((buffer[n + 3] & 0x1) == 0)
+		/* can't write CD-R media */
+		cd->cdi.mask |= CDC_CD_R;
+	if ((buffer[n + 6] & 0x8) == 0)
+		/* can't eject */
+		cd->cdi.mask |= CDC_OPEN_TRAY;
+
+	if ((buffer[n + 6] >> 5) == mechtype_individual_changer ||
+	    (buffer[n + 6] >> 5) == mechtype_cartridge_changer)
+		cd->cdi.capacity =
+		    cdrom_number_of_slots(&cd->cdi);
+	if (cd->cdi.capacity <= 1)
+		/* not a changer */
+		cd->cdi.mask |= CDC_SELECT_DISC;
+	/*else    I don't think it can close its tray
+		cd->cdi.mask |= CDC_CLOSE_TRAY; */
+
+	/*
+	 * if DVD-RAM, MRW-W or CD-RW, we are randomly writable
+	 */
+	if ((cd->cdi.mask & (CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) !=
+			(CDC_DVD_RAM | CDC_MRW_W | CDC_RAM | CDC_CD_RW)) {
+		cd->device->writeable = 1;
+	}
+
+	scsi_release_request(SRpnt);
+	kfree(buffer);
+}
+
+/*
+ * sr_packet() is the entry point for the generic commands generated
+ * by the Uniform CD-ROM layer. 
+ */
+static int sr_packet(struct cdrom_device_info *cdi,
+		struct packet_command *cgc)
+{
+	if (cgc->timeout <= 0)
+		cgc->timeout = IOCTL_TIMEOUT;
+
+	sr_do_ioctl(cdi->handle, cgc);
+
+	return cgc->stat;
+}
+
+/**
+ *	sr_kref_release - Called to free the scsi_cd structure
+ *	@kref: pointer to embedded kref
+ *
+ *	sr_ref_sem must be held entering this routine.  Because it is
+ *	called on last put, you should always use the scsi_cd_get()
+ *	scsi_cd_put() helpers which manipulate the semaphore directly
+ *	and never do a direct kref_put().
+ **/
+static void sr_kref_release(struct kref *kref)
+{
+	struct scsi_cd *cd = container_of(kref, struct scsi_cd, kref);
+	struct gendisk *disk = cd->disk;
+
+	spin_lock(&sr_index_lock);
+	clear_bit(disk->first_minor, sr_index_bits);
+	spin_unlock(&sr_index_lock);
+
+	unregister_cdrom(&cd->cdi);
+
+	disk->private_data = NULL;
+
+	put_disk(disk);
+
+	kfree(cd);
+}
+
+static int sr_remove(struct device *dev)
+{
+	struct scsi_cd *cd = dev_get_drvdata(dev);
+
+	del_gendisk(cd->disk);
+
+	down(&sr_ref_sem);
+	kref_put(&cd->kref, sr_kref_release);
+	up(&sr_ref_sem);
+
+	return 0;
+}
+
+static int __init init_sr(void)
+{
+	int rc;
+
+	rc = register_blkdev(SCSI_CDROM_MAJOR, "sr");
+	if (rc)
+		return rc;
+	return scsi_register_driver(&sr_template.gendrv);
+}
+
+static void __exit exit_sr(void)
+{
+	scsi_unregister_driver(&sr_template.gendrv);
+	unregister_blkdev(SCSI_CDROM_MAJOR, "sr");
+}
+
+module_init(init_sr);
+module_exit(exit_sr);
+MODULE_LICENSE("GPL");
