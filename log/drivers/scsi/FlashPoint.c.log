commit adb11023a5987db78d5aa58cebd158d99c547850
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Sep 20 14:10:32 2018 -0700

    scsi: FlashPoint: Remove unnecessary parentheses
    
    Clang warns when multiple pairs of parentheses are used for a single
    conditional statement.
    
    In file included from drivers/scsi/BusLogic.c:57:
    drivers/scsi/FlashPoint.c:2947:34: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
                                    if ((currSCCB->Sccb_scsistat == SELECT_SN_ST)) {
                                         ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
    drivers/scsi/FlashPoint.c:2947:34: note: remove extraneous parentheses around the comparison to silence this warning
                                    if ((currSCCB->Sccb_scsistat == SELECT_SN_ST)) {
                                        ~                        ^              ~
    drivers/scsi/FlashPoint.c:2947:34: note: use '=' to turn this equality comparison into an assignment
                                    if ((currSCCB->Sccb_scsistat == SELECT_SN_ST)) {
                                                                 ^~
                                                                 =
    drivers/scsi/FlashPoint.c:2956:39: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
                                    else if ((currSCCB->Sccb_scsistat ==
                                              ~~~~~~~~~~~~~~~~~~~~~~~~^~
    drivers/scsi/FlashPoint.c:2956:39: note: remove extraneous parentheses around the comparison to silence this warning
                                    else if ((currSCCB->Sccb_scsistat ==
                                             ~                        ^
    drivers/scsi/FlashPoint.c:2956:39: note: use '=' to turn this equality comparison into an assignment
                                    else if ((currSCCB->Sccb_scsistat ==
                                                                      ^~
                                                                      =
    2 warnings generated.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/156
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Khalid Aziz <khalid@gonehiking.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 867b864f5047..0f17bd51088a 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -2944,7 +2944,7 @@ static void FPT_sdecm(unsigned char message, u32 port, unsigned char p_card)
 			}
 
 			if (currSCCB->Lun == 0x00) {
-				if ((currSCCB->Sccb_scsistat == SELECT_SN_ST)) {
+				if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
 
 					currTar_Info->TarStatus |=
 					    (unsigned char)SYNC_SUPPORTED;
@@ -2953,8 +2953,8 @@ static void FPT_sdecm(unsigned char message, u32 port, unsigned char p_card)
 					    ~EE_SYNC_MASK;
 				}
 
-				else if ((currSCCB->Sccb_scsistat ==
-					  SELECT_WN_ST)) {
+				else if (currSCCB->Sccb_scsistat ==
+					  SELECT_WN_ST) {
 
 					currTar_Info->TarStatus =
 					    (currTar_Info->

commit cd9d715c28d0320acb53df68ebecc035cfe60913
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Sep 16 19:36:20 2015 +0530

    FlashPoint: fix build warning
    
    We have been getting a warning about non ANSI function.
    warning: non-ANSI function declaration of function 'FPT_SccbMgrTableInitAll'
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Acked-by: Khalid Aziz <khalid@gonehiking.org>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 5c74e4c52fe4..867b864f5047 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -2136,7 +2136,7 @@ static unsigned char FPT_SccbMgr_bad_isr(u32 p_port, unsigned char p_card,
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_SccbMgrTableInitAll()
+static void FPT_SccbMgrTableInitAll(void)
 {
 	unsigned char thisCard;
 

commit 391e2f25601e34a7d7e5dc155e487bc58dffd8c6
Author: Khalid Aziz <khalid.aziz@oracle.com>
Date:   Thu May 16 19:44:14 2013 -0600

    [SCSI] BusLogic: Port driver to 64-bit.
    
    [jejb: fix up pointer to int cast warning]
    Signed-off-by: Khalid Aziz <khalid.aziz@oracle.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 902972050063..5c74e4c52fe4 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -29,27 +29,27 @@ struct sccb;
 typedef void (*CALL_BK_FN) (struct sccb *);
 
 struct sccb_mgr_info {
-	unsigned long si_baseaddr;
+	u32 si_baseaddr;
 	unsigned char si_present;
 	unsigned char si_intvect;
 	unsigned char si_id;
 	unsigned char si_lun;
-	unsigned short si_fw_revision;
-	unsigned short si_per_targ_init_sync;
-	unsigned short si_per_targ_fast_nego;
-	unsigned short si_per_targ_ultra_nego;
-	unsigned short si_per_targ_no_disc;
-	unsigned short si_per_targ_wide_nego;
-	unsigned short si_flags;
+	u16 si_fw_revision;
+	u16 si_per_targ_init_sync;
+	u16 si_per_targ_fast_nego;
+	u16 si_per_targ_ultra_nego;
+	u16 si_per_targ_no_disc;
+	u16 si_per_targ_wide_nego;
+	u16 si_flags;
 	unsigned char si_card_family;
 	unsigned char si_bustype;
 	unsigned char si_card_model[3];
 	unsigned char si_relative_cardnum;
 	unsigned char si_reserved[4];
-	unsigned long si_OS_reserved;
+	u32 si_OS_reserved;
 	unsigned char si_XlatInfo[4];
-	unsigned long si_reserved2[5];
-	unsigned long si_secondary_range;
+	u32 si_reserved2[5];
+	u32 si_secondary_range;
 };
 
 #define SCSI_PARITY_ENA		  0x0001
@@ -70,14 +70,14 @@ struct sccb_mgr_info {
  * The UCB Manager treats the SCCB as it's 'native hardware structure' 
  */
 
-#pragma pack(1)
+/*#pragma pack(1)*/
 struct sccb {
 	unsigned char OperationCode;
 	unsigned char ControlByte;
 	unsigned char CdbLength;
 	unsigned char RequestSenseLength;
-	unsigned long DataLength;
-	unsigned long DataPointer;
+	u32 DataLength;
+	void *DataPointer;
 	unsigned char CcbRes[2];
 	unsigned char HostStatus;
 	unsigned char TargetStatus;
@@ -86,32 +86,32 @@ struct sccb {
 	unsigned char Cdb[12];
 	unsigned char CcbRes1;
 	unsigned char Reserved1;
-	unsigned long Reserved2;
-	unsigned long SensePointer;
+	u32 Reserved2;
+	u32 SensePointer;
 
 	CALL_BK_FN SccbCallback;	/* VOID (*SccbCallback)(); */
-	unsigned long SccbIOPort;	/* Identifies board base port */
+	u32 SccbIOPort;			/* Identifies board base port */
 	unsigned char SccbStatus;
 	unsigned char SCCBRes2;
-	unsigned short SccbOSFlags;
-
-	unsigned long Sccb_XferCnt;	/* actual transfer count */
-	unsigned long Sccb_ATC;
-	unsigned long SccbVirtDataPtr;	/* virtual addr for OS/2 */
-	unsigned long Sccb_res1;
-	unsigned short Sccb_MGRFlags;
-	unsigned short Sccb_sgseg;
+	u16 SccbOSFlags;
+
+	u32 Sccb_XferCnt;	/* actual transfer count */
+	u32 Sccb_ATC;
+	u32 SccbVirtDataPtr;	/* virtual addr for OS/2 */
+	u32 Sccb_res1;
+	u16 Sccb_MGRFlags;
+	u16 Sccb_sgseg;
 	unsigned char Sccb_scsimsg;	/* identify msg for selection */
 	unsigned char Sccb_tag;
 	unsigned char Sccb_scsistat;
 	unsigned char Sccb_idmsg;	/* image of last msg in */
 	struct sccb *Sccb_forwardlink;
 	struct sccb *Sccb_backlink;
-	unsigned long Sccb_savedATC;
+	u32 Sccb_savedATC;
 	unsigned char Save_Cdb[6];
 	unsigned char Save_CdbLen;
 	unsigned char Sccb_XferState;
-	unsigned long Sccb_SGoffset;
+	u32 Sccb_SGoffset;
 };
 
 #pragma pack()
@@ -223,15 +223,21 @@ struct sccb_mgr_tar_info {
 };
 
 struct nvram_info {
-	unsigned char niModel;	/* Model No. of card */
-	unsigned char niCardNo;	/* Card no. */
-	unsigned long niBaseAddr;	/* Port Address of card */
-	unsigned char niSysConf;	/* Adapter Configuration byte - Byte 16 of eeprom map */
-	unsigned char niScsiConf;	/* SCSI Configuration byte - Byte 17 of eeprom map */
-	unsigned char niScamConf;	/* SCAM Configuration byte - Byte 20 of eeprom map */
-	unsigned char niAdapId;	/* Host Adapter ID - Byte 24 of eerpom map */
-	unsigned char niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
-	unsigned char niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
+	unsigned char niModel;		/* Model No. of card */
+	unsigned char niCardNo;		/* Card no. */
+	u32 niBaseAddr;			/* Port Address of card */
+	unsigned char niSysConf;	/* Adapter Configuration byte -
+					   Byte 16 of eeprom map */
+	unsigned char niScsiConf;	/* SCSI Configuration byte -
+					   Byte 17 of eeprom map */
+	unsigned char niScamConf;	/* SCAM Configuration byte -
+					   Byte 20 of eeprom map */
+	unsigned char niAdapId;		/* Host Adapter ID -
+					   Byte 24 of eerpom map */
+	unsigned char niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte
+							   of targets */
+	unsigned char niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name
+							   string of Targets */
 };
 
 #define	MODEL_LT		1
@@ -243,7 +249,7 @@ struct sccb_card {
 	struct sccb *currentSCCB;
 	struct sccb_mgr_info *cardInfo;
 
-	unsigned long ioPort;
+	u32 ioPort;
 
 	unsigned short cmdCounter;
 	unsigned char discQCount;
@@ -780,37 +786,37 @@ typedef struct SCCBscam_info {
 #define MENABLE_INT(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \
                              (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE)))
 
-static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card,
+static unsigned char FPT_sisyncn(u32 port, unsigned char p_card,
 				 unsigned char syncFlag);
-static void FPT_ssel(unsigned long port, unsigned char p_card);
-static void FPT_sres(unsigned long port, unsigned char p_card,
+static void FPT_ssel(u32 port, unsigned char p_card);
+static void FPT_sres(u32 port, unsigned char p_card,
 		     struct sccb_card *pCurrCard);
-static void FPT_shandem(unsigned long port, unsigned char p_card,
+static void FPT_shandem(u32 port, unsigned char p_card,
 			struct sccb *pCurrSCCB);
-static void FPT_stsyncn(unsigned long port, unsigned char p_card);
-static void FPT_sisyncr(unsigned long port, unsigned char sync_pulse,
+static void FPT_stsyncn(u32 port, unsigned char p_card);
+static void FPT_sisyncr(u32 port, unsigned char sync_pulse,
 			unsigned char offset);
-static void FPT_sssyncv(unsigned long p_port, unsigned char p_id,
+static void FPT_sssyncv(u32 p_port, unsigned char p_id,
 			unsigned char p_sync_value,
 			struct sccb_mgr_tar_info *currTar_Info);
-static void FPT_sresb(unsigned long port, unsigned char p_card);
-static void FPT_sxfrp(unsigned long p_port, unsigned char p_card);
-static void FPT_schkdd(unsigned long port, unsigned char p_card);
-static unsigned char FPT_RdStack(unsigned long port, unsigned char index);
-static void FPT_WrStack(unsigned long portBase, unsigned char index,
+static void FPT_sresb(u32 port, unsigned char p_card);
+static void FPT_sxfrp(u32 p_port, unsigned char p_card);
+static void FPT_schkdd(u32 port, unsigned char p_card);
+static unsigned char FPT_RdStack(u32 port, unsigned char index);
+static void FPT_WrStack(u32 portBase, unsigned char index,
 			unsigned char data);
-static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort);
+static unsigned char FPT_ChkIfChipInitialized(u32 ioPort);
 
-static void FPT_SendMsg(unsigned long port, unsigned char message);
+static void FPT_SendMsg(u32 port, unsigned char message);
 static void FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
 				   unsigned char error_code);
 
 static void FPT_sinits(struct sccb *p_sccb, unsigned char p_card);
 static void FPT_RNVRamData(struct nvram_info *pNvRamInfo);
 
-static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card);
-static void FPT_stwidn(unsigned long port, unsigned char p_card);
-static void FPT_siwidr(unsigned long port, unsigned char width);
+static unsigned char FPT_siwidn(u32 port, unsigned char p_card);
+static void FPT_stwidn(u32 port, unsigned char p_card);
+static void FPT_siwidr(u32 port, unsigned char width);
 
 static void FPT_queueSelectFail(struct sccb_card *pCurrCard,
 				unsigned char p_card);
@@ -827,45 +833,45 @@ static void FPT_utilUpdateResidual(struct sccb *p_SCCB);
 static unsigned short FPT_CalcCrc16(unsigned char buffer[]);
 static unsigned char FPT_CalcLrc(unsigned char buffer[]);
 
-static void FPT_Wait1Second(unsigned long p_port);
-static void FPT_Wait(unsigned long p_port, unsigned char p_delay);
-static void FPT_utilEEWriteOnOff(unsigned long p_port, unsigned char p_mode);
-static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data,
+static void FPT_Wait1Second(u32 p_port);
+static void FPT_Wait(u32 p_port, unsigned char p_delay);
+static void FPT_utilEEWriteOnOff(u32 p_port, unsigned char p_mode);
+static void FPT_utilEEWrite(u32 p_port, unsigned short ee_data,
 			    unsigned short ee_addr);
-static unsigned short FPT_utilEERead(unsigned long p_port,
+static unsigned short FPT_utilEERead(u32 p_port,
 				     unsigned short ee_addr);
-static unsigned short FPT_utilEEReadOrg(unsigned long p_port,
+static unsigned short FPT_utilEEReadOrg(u32 p_port,
 					unsigned short ee_addr);
-static void FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd,
+static void FPT_utilEESendCmdAddr(u32 p_port, unsigned char ee_cmd,
 				  unsigned short ee_addr);
 
-static void FPT_phaseDataOut(unsigned long port, unsigned char p_card);
-static void FPT_phaseDataIn(unsigned long port, unsigned char p_card);
-static void FPT_phaseCommand(unsigned long port, unsigned char p_card);
-static void FPT_phaseStatus(unsigned long port, unsigned char p_card);
-static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card);
-static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card);
-static void FPT_phaseIllegal(unsigned long port, unsigned char p_card);
+static void FPT_phaseDataOut(u32 port, unsigned char p_card);
+static void FPT_phaseDataIn(u32 port, unsigned char p_card);
+static void FPT_phaseCommand(u32 port, unsigned char p_card);
+static void FPT_phaseStatus(u32 port, unsigned char p_card);
+static void FPT_phaseMsgOut(u32 port, unsigned char p_card);
+static void FPT_phaseMsgIn(u32 port, unsigned char p_card);
+static void FPT_phaseIllegal(u32 port, unsigned char p_card);
 
-static void FPT_phaseDecode(unsigned long port, unsigned char p_card);
-static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card);
-static void FPT_phaseBusFree(unsigned long p_port, unsigned char p_card);
+static void FPT_phaseDecode(u32 port, unsigned char p_card);
+static void FPT_phaseChkFifo(u32 port, unsigned char p_card);
+static void FPT_phaseBusFree(u32 p_port, unsigned char p_card);
 
-static void FPT_XbowInit(unsigned long port, unsigned char scamFlg);
-static void FPT_BusMasterInit(unsigned long p_port);
-static void FPT_DiagEEPROM(unsigned long p_port);
+static void FPT_XbowInit(u32 port, unsigned char scamFlg);
+static void FPT_BusMasterInit(u32 p_port);
+static void FPT_DiagEEPROM(u32 p_port);
 
-static void FPT_dataXferProcessor(unsigned long port,
+static void FPT_dataXferProcessor(u32 port,
 				  struct sccb_card *pCurrCard);
-static void FPT_busMstrSGDataXferStart(unsigned long port,
+static void FPT_busMstrSGDataXferStart(u32 port,
 				       struct sccb *pCurrSCCB);
-static void FPT_busMstrDataXferStart(unsigned long port,
+static void FPT_busMstrDataXferStart(u32 port,
 				     struct sccb *pCurrSCCB);
-static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
+static void FPT_hostDataXferAbort(u32 port, unsigned char p_card,
 				  struct sccb *pCurrSCCB);
 static void FPT_hostDataXferRestart(struct sccb *currSCCB);
 
-static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port,
+static unsigned char FPT_SccbMgr_bad_isr(u32 p_port,
 					 unsigned char p_card,
 					 struct sccb_card *pCurrCard,
 					 unsigned short p_int);
@@ -879,28 +885,28 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card,
 static void FPT_scini(unsigned char p_card, unsigned char p_our_id,
 		      unsigned char p_power_up);
 
-static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type);
-static void FPT_scbusf(unsigned long p_port);
-static void FPT_scsel(unsigned long p_port);
-static void FPT_scasid(unsigned char p_card, unsigned long p_port);
-static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data);
-static unsigned char FPT_scsendi(unsigned long p_port,
+static int FPT_scarb(u32 p_port, unsigned char p_sel_type);
+static void FPT_scbusf(u32 p_port);
+static void FPT_scsel(u32 p_port);
+static void FPT_scasid(unsigned char p_card, u32 p_port);
+static unsigned char FPT_scxferc(u32 p_port, unsigned char p_data);
+static unsigned char FPT_scsendi(u32 p_port,
 				 unsigned char p_id_string[]);
-static unsigned char FPT_sciso(unsigned long p_port,
+static unsigned char FPT_sciso(u32 p_port,
 			       unsigned char p_id_string[]);
-static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit);
-static void FPT_scwiros(unsigned long p_port, unsigned char p_data_bit);
+static void FPT_scwirod(u32 p_port, unsigned char p_data_bit);
+static void FPT_scwiros(u32 p_port, unsigned char p_data_bit);
 static unsigned char FPT_scvalq(unsigned char p_quintet);
-static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id);
-static void FPT_scwtsel(unsigned long p_port);
-static void FPT_inisci(unsigned char p_card, unsigned long p_port,
+static unsigned char FPT_scsell(u32 p_port, unsigned char targ_id);
+static void FPT_scwtsel(u32 p_port);
+static void FPT_inisci(unsigned char p_card, u32 p_port,
 		       unsigned char p_our_id);
-static void FPT_scsavdi(unsigned char p_card, unsigned long p_port);
+static void FPT_scsavdi(unsigned char p_card, u32 p_port);
 static unsigned char FPT_scmachid(unsigned char p_card,
 				  unsigned char p_id_string[]);
 
-static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card);
-static void FPT_autoLoadDefaultMap(unsigned long p_port);
+static void FPT_autoCmdCmplt(u32 p_port, unsigned char p_card);
+static void FPT_autoLoadDefaultMap(u32 p_port);
 
 static struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] =
     { {{0}} };
@@ -918,7 +924,7 @@ static unsigned char FPT_scamHAString[] =
 
 static unsigned short FPT_default_intena = 0;
 
-static void (*FPT_s_PhaseTbl[8]) (unsigned long, unsigned char) = {
+static void (*FPT_s_PhaseTbl[8]) (u32, unsigned char) = {
 0};
 
 /*---------------------------------------------------------------------
@@ -935,7 +941,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 
 	unsigned char i, j, id, ScamFlg;
 	unsigned short temp, temp2, temp3, temp4, temp5, temp6;
-	unsigned long ioport;
+	u32 ioport;
 	struct nvram_info *pCurrNvRam;
 
 	ioport = pCardInfo->si_baseaddr;
@@ -1201,23 +1207,21 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info
+static void *FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info
 							 *pCardInfo)
 {
 	struct sccb_card *CurrCard = NULL;
 	struct nvram_info *pCurrNvRam;
 	unsigned char i, j, thisCard, ScamFlg;
 	unsigned short temp, sync_bit_map, id;
-	unsigned long ioport;
+	u32 ioport;
 
 	ioport = pCardInfo->si_baseaddr;
 
 	for (thisCard = 0; thisCard <= MAX_CARDS; thisCard++) {
 
-		if (thisCard == MAX_CARDS) {
-
-			return FAILURE;
-		}
+		if (thisCard == MAX_CARDS)
+			return (void *)FAILURE;
 
 		if (FPT_BL_Card[thisCard].ioPort == ioport) {
 
@@ -1384,16 +1388,16 @@ static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info
 		   (unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |
 				   SCCB_MGR_PRESENT));
 
-	return (unsigned long)CurrCard;
+	return (void *)CurrCard;
 }
 
-static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
+static void FlashPoint_ReleaseHostAdapter(void *pCurrCard)
 {
 	unsigned char i;
-	unsigned long portBase;
-	unsigned long regOffset;
-	unsigned long scamData;
-	unsigned long *pScamTbl;
+	u32 portBase;
+	u32 regOffset;
+	u32 scamData;
+	u32 *pScamTbl;
 	struct nvram_info *pCurrNvRam;
 
 	pCurrNvRam = ((struct sccb_card *)pCurrCard)->pNvRamInfo;
@@ -1414,7 +1418,7 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 
 		for (i = 0; i < MAX_SCSI_TAR; i++) {
 			regOffset = hp_aramBase + 64 + i * 4;
-			pScamTbl = (unsigned long *)&pCurrNvRam->niScamTbl[i];
+			pScamTbl = (u32 *)&pCurrNvRam->niScamTbl[i];
 			scamData = *pScamTbl;
 			WR_HARP32(portBase, regOffset, scamData);
 		}
@@ -1427,10 +1431,10 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 static void FPT_RNVRamData(struct nvram_info *pNvRamInfo)
 {
 	unsigned char i;
-	unsigned long portBase;
-	unsigned long regOffset;
-	unsigned long scamData;
-	unsigned long *pScamTbl;
+	u32 portBase;
+	u32 regOffset;
+	u32 scamData;
+	u32 *pScamTbl;
 
 	pNvRamInfo->niModel = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);
 	pNvRamInfo->niSysConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);
@@ -1447,26 +1451,25 @@ static void FPT_RNVRamData(struct nvram_info *pNvRamInfo)
 	for (i = 0; i < MAX_SCSI_TAR; i++) {
 		regOffset = hp_aramBase + 64 + i * 4;
 		RD_HARP32(portBase, regOffset, scamData);
-		pScamTbl = (unsigned long *)&pNvRamInfo->niScamTbl[i];
+		pScamTbl = (u32 *)&pNvRamInfo->niScamTbl[i];
 		*pScamTbl = scamData;
 	}
 
 }
 
-static unsigned char FPT_RdStack(unsigned long portBase, unsigned char index)
+static unsigned char FPT_RdStack(u32 portBase, unsigned char index)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	return RD_HARPOON(portBase + hp_stack_data);
 }
 
-static void FPT_WrStack(unsigned long portBase, unsigned char index,
-			unsigned char data)
+static void FPT_WrStack(u32 portBase, unsigned char index, unsigned char data)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	WR_HARPOON(portBase + hp_stack_data, data);
 }
 
-static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
+static unsigned char FPT_ChkIfChipInitialized(u32 ioPort)
 {
 	if ((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
 		return 0;
@@ -1489,15 +1492,16 @@ static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
+static void FlashPoint_StartCCB(void *curr_card, struct sccb *p_Sccb)
 {
-	unsigned long ioport;
+	u32 ioport;
 	unsigned char thisCard, lun;
 	struct sccb *pSaveSccb;
 	CALL_BK_FN callback;
+	struct sccb_card *pCurrCard = curr_card;
 
-	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
-	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
+	thisCard = pCurrCard->cardIndex;
+	ioport = pCurrCard->ioPort;
 
 	if ((p_Sccb->TargID >= MAX_SCSI_TAR) || (p_Sccb->Lun >= MAX_LUN)) {
 
@@ -1512,18 +1516,18 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 
 	FPT_sinits(p_Sccb, thisCard);
 
-	if (!((struct sccb_card *)pCurrCard)->cmdCounter) {
+	if (!pCurrCard->cmdCounter) {
 		WR_HARPOON(ioport + hp_semaphore,
 			   (RD_HARPOON(ioport + hp_semaphore)
 			    | SCCB_MGR_ACTIVE));
 
-		if (((struct sccb_card *)pCurrCard)->globalFlags & F_GREEN_PC) {
+		if (pCurrCard->globalFlags & F_GREEN_PC) {
 			WR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);
 			WR_HARPOON(ioport + hp_sys_ctrl, 0x00);
 		}
 	}
 
-	((struct sccb_card *)pCurrCard)->cmdCounter++;
+	pCurrCard->cmdCounter++;
 
 	if (RD_HARPOON(ioport + hp_semaphore) & BIOS_IN_USE) {
 
@@ -1532,10 +1536,10 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 			    | TICKLE_ME));
 		if (p_Sccb->OperationCode == RESET_COMMAND) {
 			pSaveSccb =
-			    ((struct sccb_card *)pCurrCard)->currentSCCB;
-			((struct sccb_card *)pCurrCard)->currentSCCB = p_Sccb;
+			    pCurrCard->currentSCCB;
+			pCurrCard->currentSCCB = p_Sccb;
 			FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-			((struct sccb_card *)pCurrCard)->currentSCCB =
+			pCurrCard->currentSCCB =
 			    pSaveSccb;
 		} else {
 			FPT_queueAddSccb(p_Sccb, thisCard);
@@ -1546,10 +1550,10 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 
 		if (p_Sccb->OperationCode == RESET_COMMAND) {
 			pSaveSccb =
-			    ((struct sccb_card *)pCurrCard)->currentSCCB;
-			((struct sccb_card *)pCurrCard)->currentSCCB = p_Sccb;
+			    pCurrCard->currentSCCB;
+			pCurrCard->currentSCCB = p_Sccb;
 			FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-			((struct sccb_card *)pCurrCard)->currentSCCB =
+			pCurrCard->currentSCCB =
 			    pSaveSccb;
 		} else {
 			FPT_queueAddSccb(p_Sccb, thisCard);
@@ -1560,34 +1564,29 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 
 		MDISABLE_INT(ioport);
 
-		if ((((struct sccb_card *)pCurrCard)->globalFlags & F_CONLUN_IO)
-		    &&
+		if ((pCurrCard->globalFlags & F_CONLUN_IO) &&
 		    ((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].
 		      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
 			lun = p_Sccb->Lun;
 		else
 			lun = 0;
-		if ((((struct sccb_card *)pCurrCard)->currentSCCB == NULL) &&
+		if ((pCurrCard->currentSCCB == NULL) &&
 		    (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0)
 		    && (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
 			== 0)) {
 
-			((struct sccb_card *)pCurrCard)->currentSCCB = p_Sccb;
+			pCurrCard->currentSCCB = p_Sccb;
 			FPT_ssel(p_Sccb->SccbIOPort, thisCard);
 		}
 
 		else {
 
 			if (p_Sccb->OperationCode == RESET_COMMAND) {
-				pSaveSccb =
-				    ((struct sccb_card *)pCurrCard)->
-				    currentSCCB;
-				((struct sccb_card *)pCurrCard)->currentSCCB =
-				    p_Sccb;
+				pSaveSccb = pCurrCard->currentSCCB;
+				pCurrCard->currentSCCB = p_Sccb;
 				FPT_queueSelectFail(&FPT_BL_Card[thisCard],
 						    thisCard);
-				((struct sccb_card *)pCurrCard)->currentSCCB =
-				    pSaveSccb;
+				pCurrCard->currentSCCB = pSaveSccb;
 			} else {
 				FPT_queueAddSccb(p_Sccb, thisCard);
 			}
@@ -1607,9 +1606,9 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
+static int FlashPoint_AbortCCB(void *pCurrCard, struct sccb *p_Sccb)
 {
-	unsigned long ioport;
+	u32 ioport;
 
 	unsigned char thisCard;
 	CALL_BK_FN callback;
@@ -1715,9 +1714,9 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
  *              interrupt for this card and disable the IRQ Pin if so.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
+static unsigned char FlashPoint_InterruptPending(void *pCurrCard)
 {
-	unsigned long ioport;
+	u32 ioport;
 
 	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
@@ -1739,38 +1738,36 @@ static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
  *              us.
  *
  *---------------------------------------------------------------------*/
-static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
+static int FlashPoint_HandleInterrupt(void *pcard)
 {
 	struct sccb *currSCCB;
 	unsigned char thisCard, result, bm_status, bm_int_st;
 	unsigned short hp_int;
 	unsigned char i, target;
-	unsigned long ioport;
+	struct sccb_card *pCurrCard = pcard;
+	u32 ioport;
 
-	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
-	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
+	thisCard = pCurrCard->cardIndex;
+	ioport = pCurrCard->ioPort;
 
 	MDISABLE_INT(ioport);
 
 	if ((bm_int_st = RD_HARPOON(ioport + hp_int_status)) & EXT_STATUS_ON)
-		bm_status =
-		    RD_HARPOON(ioport +
-			       hp_ext_status) & (unsigned char)BAD_EXT_STATUS;
+		bm_status = RD_HARPOON(ioport + hp_ext_status) &
+					(unsigned char)BAD_EXT_STATUS;
 	else
 		bm_status = 0;
 
 	WR_HARPOON(ioport + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
 
-	while ((hp_int =
-		RDW_HARPOON((ioport +
-			     hp_intstat)) & FPT_default_intena) | bm_status) {
+	while ((hp_int = RDW_HARPOON((ioport + hp_intstat)) &
+				FPT_default_intena) | bm_status) {
 
-		currSCCB = ((struct sccb_card *)pCurrCard)->currentSCCB;
+		currSCCB = pCurrCard->currentSCCB;
 
 		if (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {
 			result =
-			    FPT_SccbMgr_bad_isr(ioport, thisCard,
-						((struct sccb_card *)pCurrCard),
+			    FPT_SccbMgr_bad_isr(ioport, thisCard, pCurrCard,
 						hp_int);
 			WRW_HARPOON((ioport + hp_intstat),
 				    (FIFO | TIMEOUT | RESET | SCAM_SEL));
@@ -1796,8 +1793,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 					(BUS_FREE | RSEL))) ;
 			}
 
-			if (((struct sccb_card *)pCurrCard)->
-			    globalFlags & F_HOST_XFER_ACT)
+			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
 
 				FPT_phaseChkFifo(ioport, thisCard);
 
@@ -1813,14 +1809,11 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 
 		else if (hp_int & ITAR_DISC) {
 
-			if (((struct sccb_card *)pCurrCard)->
-			    globalFlags & F_HOST_XFER_ACT) {
-
+			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
 				FPT_phaseChkFifo(ioport, thisCard);
 
-			}
-
-			if (RD_HARPOON(ioport + hp_gp_reg_1) == SMSAVE_DATA_PTR) {
+			if (RD_HARPOON(ioport + hp_gp_reg_1) ==
+					SMSAVE_DATA_PTR) {
 
 				WR_HARPOON(ioport + hp_gp_reg_1, 0x00);
 				currSCCB->Sccb_XferState |= F_NO_DATA_YET;
@@ -1859,8 +1852,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 			WRW_HARPOON((ioport + hp_intstat),
 				    (BUS_FREE | ITAR_DISC));
 
-			((struct sccb_card *)pCurrCard)->globalFlags |=
-			    F_NEW_SCCB_CMD;
+			pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
 
 		}
 
@@ -1870,10 +1862,8 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 				    (PROG_HLT | RSEL | PHASE | BUS_FREE));
 
 			if (RDW_HARPOON((ioport + hp_intstat)) & ITAR_DISC) {
-				if (((struct sccb_card *)pCurrCard)->
-				    globalFlags & F_HOST_XFER_ACT) {
+				if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
 					FPT_phaseChkFifo(ioport, thisCard);
-				}
 
 				if (RD_HARPOON(ioport + hp_gp_reg_1) ==
 				    SMSAVE_DATA_PTR) {
@@ -1890,8 +1880,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 				FPT_queueDisconnect(currSCCB, thisCard);
 			}
 
-			FPT_sres(ioport, thisCard,
-				 ((struct sccb_card *)pCurrCard));
+			FPT_sres(ioport, thisCard, pCurrCard);
 			FPT_phaseDecode(ioport, thisCard);
 
 		}
@@ -1948,8 +1937,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 
 			WRW_HARPOON((ioport + hp_intstat), BUS_FREE);
 
-			if (((struct sccb_card *)pCurrCard)->
-			    globalFlags & F_HOST_XFER_ACT) {
+			if (pCurrCard->globalFlags & F_HOST_XFER_ACT) {
 
 				FPT_hostDataXferAbort(ioport, thisCard,
 						      currSCCB);
@@ -1961,27 +1949,19 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 		else if (hp_int & ITICKLE) {
 
 			WRW_HARPOON((ioport + hp_intstat), ITICKLE);
-			((struct sccb_card *)pCurrCard)->globalFlags |=
-			    F_NEW_SCCB_CMD;
+			pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
 		}
 
 		if (((struct sccb_card *)pCurrCard)->
 		    globalFlags & F_NEW_SCCB_CMD) {
 
-			((struct sccb_card *)pCurrCard)->globalFlags &=
-			    ~F_NEW_SCCB_CMD;
+			pCurrCard->globalFlags &= ~F_NEW_SCCB_CMD;
 
-			if (((struct sccb_card *)pCurrCard)->currentSCCB ==
-			    NULL) {
-
-				FPT_queueSearchSelect(((struct sccb_card *)
-						       pCurrCard), thisCard);
-			}
+			if (pCurrCard->currentSCCB == NULL)
+				FPT_queueSearchSelect(pCurrCard, thisCard);
 
-			if (((struct sccb_card *)pCurrCard)->currentSCCB !=
-			    NULL) {
-				((struct sccb_card *)pCurrCard)->globalFlags &=
-				    ~F_NEW_SCCB_CMD;
+			if (pCurrCard->currentSCCB != NULL) {
+				pCurrCard->globalFlags &= ~F_NEW_SCCB_CMD;
 				FPT_ssel(ioport, thisCard);
 			}
 
@@ -2006,8 +1986,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
  *              processing time.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port,
-					 unsigned char p_card,
+static unsigned char FPT_SccbMgr_bad_isr(u32 p_port, unsigned char p_card,
 					 struct sccb_card *pCurrCard,
 					 unsigned short p_int)
 {
@@ -2254,7 +2233,7 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card,
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sfm(unsigned long port, struct sccb *pCurrSCCB)
+static unsigned char FPT_sfm(u32 port, struct sccb *pCurrSCCB)
 {
 	unsigned char message;
 	unsigned short TimeOutLoop;
@@ -2322,12 +2301,12 @@ static unsigned char FPT_sfm(unsigned long port, struct sccb *pCurrSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_ssel(unsigned long port, unsigned char p_card)
+static void FPT_ssel(u32 port, unsigned char p_card)
 {
 
 	unsigned char auto_loaded, i, target, *theCCB;
 
-	unsigned long cdb_reg;
+	u32 cdb_reg;
 	struct sccb_card *CurrCard;
 	struct sccb *currSCCB;
 	struct sccb_mgr_tar_info *currTar_Info;
@@ -2621,7 +2600,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sres(unsigned long port, unsigned char p_card,
+static void FPT_sres(u32 port, unsigned char p_card,
 		     struct sccb_card *pCurrCard)
 {
 
@@ -2857,7 +2836,7 @@ static void FPT_sres(unsigned long port, unsigned char p_card,
 	       (RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;
 }
 
-static void FPT_SendMsg(unsigned long port, unsigned char message)
+static void FPT_SendMsg(u32 port, unsigned char message)
 {
 	while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
 		if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
@@ -2904,8 +2883,7 @@ static void FPT_SendMsg(unsigned long port, unsigned char message)
  *              target device.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sdecm(unsigned char message, unsigned long port,
-		      unsigned char p_card)
+static void FPT_sdecm(unsigned char message, u32 port, unsigned char p_card)
 {
 	struct sccb *currSCCB;
 	struct sccb_card *CurrCard;
@@ -3085,8 +3063,7 @@ static void FPT_sdecm(unsigned char message, unsigned long port,
  * Description: Decide what to do with the extended message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_shandem(unsigned long port, unsigned char p_card,
-			struct sccb *pCurrSCCB)
+static void FPT_shandem(u32 port, unsigned char p_card, struct sccb *pCurrSCCB)
 {
 	unsigned char length, message;
 
@@ -3153,7 +3130,7 @@ static void FPT_shandem(unsigned long port, unsigned char p_card,
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card,
+static unsigned char FPT_sisyncn(u32 port, unsigned char p_card,
 				 unsigned char syncFlag)
 {
 	struct sccb *currSCCB;
@@ -3234,7 +3211,7 @@ static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card,
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-static void FPT_stsyncn(unsigned long port, unsigned char p_card)
+static void FPT_stsyncn(u32 port, unsigned char p_card)
 {
 	unsigned char sync_msg, offset, sync_reg, our_sync_msg;
 	struct sccb *currSCCB;
@@ -3363,7 +3340,7 @@ static void FPT_stsyncn(unsigned long port, unsigned char p_card)
  * Description: Answer the targets sync message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sisyncr(unsigned long port, unsigned char sync_pulse,
+static void FPT_sisyncr(u32 port, unsigned char sync_pulse,
 			unsigned char offset)
 {
 	ARAM_ACCESS(port);
@@ -3394,7 +3371,7 @@ static void FPT_sisyncr(unsigned long port, unsigned char sync_pulse,
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
+static unsigned char FPT_siwidn(u32 port, unsigned char p_card)
 {
 	struct sccb *currSCCB;
 	struct sccb_mgr_tar_info *currTar_Info;
@@ -3449,7 +3426,7 @@ static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-static void FPT_stwidn(unsigned long port, unsigned char p_card)
+static void FPT_stwidn(u32 port, unsigned char p_card)
 {
 	unsigned char width;
 	struct sccb *currSCCB;
@@ -3520,7 +3497,7 @@ static void FPT_stwidn(unsigned long port, unsigned char p_card)
  * Description: Answer the targets Wide nego message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_siwidr(unsigned long port, unsigned char width)
+static void FPT_siwidr(u32 port, unsigned char width)
 {
 	ARAM_ACCESS(port);
 	WRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT + SMEXT));
@@ -3548,7 +3525,7 @@ static void FPT_siwidr(unsigned long port, unsigned char width)
  *              ID specified.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sssyncv(unsigned long p_port, unsigned char p_id,
+static void FPT_sssyncv(u32 p_port, unsigned char p_id,
 			unsigned char p_sync_value,
 			struct sccb_mgr_tar_info *currTar_Info)
 {
@@ -3620,7 +3597,7 @@ static void FPT_sssyncv(unsigned long p_port, unsigned char p_id,
  * Description: Reset the desired card's SCSI bus.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sresb(unsigned long port, unsigned char p_card)
+static void FPT_sresb(u32 port, unsigned char p_card)
 {
 	unsigned char scsiID, i;
 
@@ -3713,7 +3690,7 @@ static void FPT_ssenss(struct sccb_card *pCurrCard)
 	currSCCB->Cdb[4] = currSCCB->RequestSenseLength;
 	currSCCB->Cdb[5] = 0x00;
 
-	currSCCB->Sccb_XferCnt = (unsigned long)currSCCB->RequestSenseLength;
+	currSCCB->Sccb_XferCnt = (u32)currSCCB->RequestSenseLength;
 
 	currSCCB->Sccb_ATC = 0x00;
 
@@ -3737,7 +3714,7 @@ static void FPT_ssenss(struct sccb_card *pCurrCard)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sxfrp(unsigned long p_port, unsigned char p_card)
+static void FPT_sxfrp(u32 p_port, unsigned char p_card)
 {
 	unsigned char curr_phz;
 
@@ -3819,7 +3796,7 @@ static void FPT_sxfrp(unsigned long p_port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_schkdd(unsigned long port, unsigned char p_card)
+static void FPT_schkdd(u32 port, unsigned char p_card)
 {
 	unsigned short TimeOutLoop;
 	unsigned char sPhase;
@@ -3998,10 +3975,10 @@ static void FPT_sinits(struct sccb *p_sccb, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDecode(unsigned long p_port, unsigned char p_card)
+static void FPT_phaseDecode(u32 p_port, unsigned char p_card)
 {
 	unsigned char phase_ref;
-	void (*phase) (unsigned long, unsigned char);
+	void (*phase) (u32, unsigned char);
 
 	DISABLE_AUTO(p_port);
 
@@ -4021,7 +3998,7 @@ static void FPT_phaseDecode(unsigned long p_port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
+static void FPT_phaseDataOut(u32 port, unsigned char p_card)
 {
 
 	struct sccb *currSCCB;
@@ -4062,7 +4039,7 @@ static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
+static void FPT_phaseDataIn(u32 port, unsigned char p_card)
 {
 
 	struct sccb *currSCCB;
@@ -4106,10 +4083,10 @@ static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseCommand(unsigned long p_port, unsigned char p_card)
+static void FPT_phaseCommand(u32 p_port, unsigned char p_card)
 {
 	struct sccb *currSCCB;
-	unsigned long cdb_reg;
+	u32 cdb_reg;
 	unsigned char i;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -4157,7 +4134,7 @@ static void FPT_phaseCommand(unsigned long p_port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseStatus(unsigned long port, unsigned char p_card)
+static void FPT_phaseStatus(u32 port, unsigned char p_card)
 {
 	/* Start-up the automation to finish off this command and let the
 	   isr handle the interrupt for command complete when it comes in.
@@ -4178,7 +4155,7 @@ static void FPT_phaseStatus(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
+static void FPT_phaseMsgOut(u32 port, unsigned char p_card)
 {
 	unsigned char message, scsiID;
 	struct sccb *currSCCB;
@@ -4317,7 +4294,7 @@ static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
+static void FPT_phaseMsgIn(u32 port, unsigned char p_card)
 {
 	unsigned char message;
 	struct sccb *currSCCB;
@@ -4364,7 +4341,7 @@ static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
+static void FPT_phaseIllegal(u32 port, unsigned char p_card)
 {
 	struct sccb *currSCCB;
 
@@ -4390,9 +4367,9 @@ static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
+static void FPT_phaseChkFifo(u32 port, unsigned char p_card)
 {
-	unsigned long xfercnt;
+	u32 xfercnt;
 	struct sccb *currSCCB;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -4461,7 +4438,7 @@ static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
  *              because of command complete or from a disconnect.
  *
  *---------------------------------------------------------------------*/
-static void FPT_phaseBusFree(unsigned long port, unsigned char p_card)
+static void FPT_phaseBusFree(u32 port, unsigned char p_card)
 {
 	struct sccb *currSCCB;
 
@@ -4557,9 +4534,9 @@ static void FPT_phaseBusFree(unsigned long port, unsigned char p_card)
  * Description: Load the Automation RAM with the defualt map values.
  *
  *---------------------------------------------------------------------*/
-static void FPT_autoLoadDefaultMap(unsigned long p_port)
+static void FPT_autoLoadDefaultMap(u32 p_port)
 {
-	unsigned long map_addr;
+	u32 map_addr;
 
 	ARAM_ACCESS(p_port);
 	map_addr = p_port + hp_aramBase;
@@ -4663,7 +4640,7 @@ static void FPT_autoLoadDefaultMap(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
+static void FPT_autoCmdCmplt(u32 p_port, unsigned char p_card)
 {
 	struct sccb *currSCCB;
 	unsigned char status_byte;
@@ -4936,8 +4913,7 @@ static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
  *              
  *---------------------------------------------------------------------*/
 
-static void FPT_dataXferProcessor(unsigned long port,
-				  struct sccb_card *pCurrCard)
+static void FPT_dataXferProcessor(u32 port, struct sccb_card *pCurrCard)
 {
 	struct sccb *currSCCB;
 
@@ -4970,22 +4946,18 @@ static void FPT_dataXferProcessor(unsigned long port,
  * Description:
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrSGDataXferStart(unsigned long p_port,
-				       struct sccb *pcurrSCCB)
+static void FPT_busMstrSGDataXferStart(u32 p_port, struct sccb *pcurrSCCB)
 {
-	unsigned long count, addr, tmpSGCnt;
+	u32 count, addr, tmpSGCnt;
 	unsigned int sg_index;
 	unsigned char sg_count, i;
-	unsigned long reg_offset;
-
-	if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+	u32 reg_offset;
+	struct blogic_sg_seg *segp;
 
-		count = ((unsigned long)HOST_RD_CMD) << 24;
-	}
-
-	else {
-		count = ((unsigned long)HOST_WRT_CMD) << 24;
-	}
+	if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)
+		count = ((u32)HOST_RD_CMD) << 24;
+	else
+		count = ((u32)HOST_WRT_CMD) << 24;
 
 	sg_count = 0;
 	tmpSGCnt = 0;
@@ -4998,25 +4970,20 @@ static void FPT_busMstrSGDataXferStart(unsigned long p_port,
 	WR_HARPOON(p_port + hp_page_ctrl, i);
 
 	while ((sg_count < (unsigned char)SG_BUF_CNT) &&
-	       ((unsigned long)(sg_index * (unsigned int)SG_ELEMENT_SIZE) <
-		pcurrSCCB->DataLength)) {
-
-		tmpSGCnt += *(((unsigned long *)pcurrSCCB->DataPointer) +
-			      (sg_index * 2));
-
-		count |= *(((unsigned long *)pcurrSCCB->DataPointer) +
-			   (sg_index * 2));
+			((sg_index * (unsigned int)SG_ELEMENT_SIZE) <
+			pcurrSCCB->DataLength)) {
 
-		addr = *(((unsigned long *)pcurrSCCB->DataPointer) +
-			 ((sg_index * 2) + 1));
+		segp = (struct blogic_sg_seg *)(pcurrSCCB->DataPointer) +
+				sg_index;
+		tmpSGCnt += segp->segbytes;
+		count |= segp->segbytes;
+		addr = segp->segdata;
 
 		if ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {
-
 			addr +=
 			    ((count & 0x00FFFFFFL) - pcurrSCCB->Sccb_SGoffset);
 			count =
 			    (count & 0xFF000000L) | pcurrSCCB->Sccb_SGoffset;
-
 			tmpSGCnt = count & 0x00FFFFFFL;
 		}
 
@@ -5072,17 +5039,15 @@ static void FPT_busMstrSGDataXferStart(unsigned long p_port,
  * Description: 
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrDataXferStart(unsigned long p_port,
-				     struct sccb *pcurrSCCB)
+static void FPT_busMstrDataXferStart(u32 p_port, struct sccb *pcurrSCCB)
 {
-	unsigned long addr, count;
+	u32 addr, count;
 
 	if (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {
 
 		count = pcurrSCCB->Sccb_XferCnt;
 
-		addr =
-		    (unsigned long)pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
+		addr = (u32)(unsigned long)pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
 	}
 
 	else {
@@ -5127,7 +5092,7 @@ static void FPT_busMstrDataXferStart(unsigned long p_port,
  *               command busy is also time out, it'll just give up.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
+static unsigned char FPT_busMstrTimeOut(u32 p_port)
 {
 	unsigned long timeout;
 
@@ -5166,13 +5131,14 @@ static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
  * Description: Abort any in progress transfer.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
+static void FPT_hostDataXferAbort(u32 port, unsigned char p_card,
 				  struct sccb *pCurrSCCB)
 {
 
 	unsigned long timeout;
 	unsigned long remain_cnt;
-	unsigned int sg_ptr;
+	u32 sg_ptr;
+	struct blogic_sg_seg *segp;
 
 	FPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
 
@@ -5236,9 +5202,8 @@ static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
 			    (unsigned int)(pCurrSCCB->DataLength /
 					   SG_ELEMENT_SIZE)) {
 
-				sg_ptr =
-				    (unsigned int)(pCurrSCCB->DataLength /
-						   SG_ELEMENT_SIZE);
+				sg_ptr = (u32)(pCurrSCCB->DataLength /
+							SG_ELEMENT_SIZE);
 			}
 
 			remain_cnt = pCurrSCCB->Sccb_XferCnt;
@@ -5246,23 +5211,13 @@ static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
 			while (remain_cnt < 0x01000000L) {
 
 				sg_ptr--;
-
-				if (remain_cnt >
-				    (unsigned
-				     long)(*(((unsigned long *)pCurrSCCB->
-					      DataPointer) + (sg_ptr * 2)))) {
-
+				segp = (struct blogic_sg_seg *)(pCurrSCCB->
+						DataPointer) + (sg_ptr * 2);
+				if (remain_cnt > (unsigned long)segp->segbytes)
 					remain_cnt -=
-					    (unsigned
-					     long)(*(((unsigned long *)
-						      pCurrSCCB->DataPointer) +
-						     (sg_ptr * 2)));
-				}
-
-				else {
-
+						(unsigned long)segp->segbytes;
+				else
 					break;
-				}
 			}
 
 			if (remain_cnt < 0x01000000L) {
@@ -5418,23 +5373,18 @@ static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
 
 			pCurrSCCB->Sccb_SGoffset = 0x00;
 
-			if ((unsigned long)(pCurrSCCB->Sccb_sgseg *
-					    SG_ELEMENT_SIZE) >=
-			    pCurrSCCB->DataLength) {
+			if ((u32)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=
+					pCurrSCCB->DataLength) {
 
 				pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
-
 				pCurrSCCB->Sccb_sgseg =
 				    (unsigned short)(pCurrSCCB->DataLength /
 						     SG_ELEMENT_SIZE);
-
 			}
 		}
 
 		else {
-
 			if (!(pCurrSCCB->Sccb_XferState & F_AUTO_SENSE))
-
 				pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
 		}
 	}
@@ -5454,21 +5404,22 @@ static void FPT_hostDataXferRestart(struct sccb *currSCCB)
 {
 	unsigned long data_count;
 	unsigned int sg_index;
-	unsigned long *sg_ptr;
+	struct blogic_sg_seg *segp;
 
 	if (currSCCB->Sccb_XferState & F_SG_XFER) {
 
 		currSCCB->Sccb_XferCnt = 0;
 
 		sg_index = 0xffff;	/*Index by long words into sg list. */
-		data_count = 0;	/*Running count of SG xfer counts. */
+		data_count = 0;		/*Running count of SG xfer counts. */
 
-		sg_ptr = (unsigned long *)currSCCB->DataPointer;
 
 		while (data_count < currSCCB->Sccb_ATC) {
 
 			sg_index++;
-			data_count += *(sg_ptr + (sg_index * 2));
+			segp = (struct blogic_sg_seg *)(currSCCB->DataPointer) +
+						(sg_index * 2);
+			data_count += segp->segbytes;
 		}
 
 		if (data_count == currSCCB->Sccb_ATC) {
@@ -5504,7 +5455,7 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id,
 {
 
 	unsigned char loser, assigned_id;
-	unsigned long p_port;
+	u32 p_port;
 
 	unsigned char i, k, ScamFlg;
 	struct sccb_card *currCard;
@@ -5709,7 +5660,7 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id,
  *
  *---------------------------------------------------------------------*/
 
-static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
+static int FPT_scarb(u32 p_port, unsigned char p_sel_type)
 {
 	if (p_sel_type == INIT_SELTD) {
 
@@ -5771,7 +5722,7 @@ static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scbusf(unsigned long p_port)
+static void FPT_scbusf(u32 p_port)
 {
 	WR_HARPOON(p_port + hp_page_ctrl,
 		   (RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));
@@ -5803,7 +5754,7 @@ static void FPT_scbusf(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scasid(unsigned char p_card, unsigned long p_port)
+static void FPT_scasid(unsigned char p_card, u32 p_port)
 {
 	unsigned char temp_id_string[ID_STRING_LENGTH];
 
@@ -5880,7 +5831,7 @@ static void FPT_scasid(unsigned char p_card, unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scsel(unsigned long p_port)
+static void FPT_scsel(u32 p_port)
 {
 
 	WR_HARPOON(p_port + hp_scsisig, SCSI_SEL);
@@ -5914,7 +5865,7 @@ static void FPT_scsel(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data)
+static unsigned char FPT_scxferc(u32 p_port, unsigned char p_data)
 {
 	unsigned char curr_data, ret_data;
 
@@ -5964,8 +5915,7 @@ static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scsendi(unsigned long p_port,
-				 unsigned char p_id_string[])
+static unsigned char FPT_scsendi(u32 p_port, unsigned char p_id_string[])
 {
 	unsigned char ret_data, byte_cnt, bit_cnt, defer;
 
@@ -6016,8 +5966,7 @@ static unsigned char FPT_scsendi(unsigned long p_port,
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sciso(unsigned long p_port,
-			       unsigned char p_id_string[])
+static unsigned char FPT_sciso(u32 p_port, unsigned char p_id_string[])
 {
 	unsigned char ret_data, the_data, byte_cnt, bit_cnt;
 
@@ -6075,7 +6024,7 @@ static unsigned char FPT_sciso(unsigned long p_port,
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit)
+static void FPT_scwirod(u32 p_port, unsigned char p_data_bit)
 {
 	unsigned char i;
 
@@ -6102,7 +6051,7 @@ static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwiros(unsigned long p_port, unsigned char p_data_bit)
+static void FPT_scwiros(u32 p_port, unsigned char p_data_bit)
 {
 	unsigned char i;
 
@@ -6154,7 +6103,7 @@ static unsigned char FPT_scvalq(unsigned char p_quintet)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
+static unsigned char FPT_scsell(u32 p_port, unsigned char targ_id)
 {
 	unsigned long i;
 
@@ -6236,7 +6185,7 @@ static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwtsel(unsigned long p_port)
+static void FPT_scwtsel(u32 p_port)
 {
 	while (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {
 	}
@@ -6250,8 +6199,7 @@ static void FPT_scwtsel(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_inisci(unsigned char p_card, unsigned long p_port,
-		       unsigned char p_our_id)
+static void FPT_inisci(unsigned char p_card, u32 p_port, unsigned char p_our_id)
 {
 	unsigned char i, k, max_id;
 	unsigned short ee_data;
@@ -6437,7 +6385,7 @@ static unsigned char FPT_scmachid(unsigned char p_card,
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scsavdi(unsigned char p_card, unsigned long p_port)
+static void FPT_scsavdi(unsigned char p_card, u32 p_port)
 {
 	unsigned char i, k, max_id;
 	unsigned short ee_data, sum_data;
@@ -6482,7 +6430,7 @@ static void FPT_scsavdi(unsigned char p_card, unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_XbowInit(unsigned long port, unsigned char ScamFlg)
+static void FPT_XbowInit(u32 port, unsigned char ScamFlg)
 {
 	unsigned char i;
 
@@ -6531,7 +6479,7 @@ static void FPT_XbowInit(unsigned long port, unsigned char ScamFlg)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_BusMasterInit(unsigned long p_port)
+static void FPT_BusMasterInit(u32 p_port)
 {
 
 	WR_HARPOON(p_port + hp_sys_ctrl, DRVR_RST);
@@ -6558,7 +6506,7 @@ static void FPT_BusMasterInit(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_DiagEEPROM(unsigned long p_port)
+static void FPT_DiagEEPROM(u32 p_port)
 {
 	unsigned short index, temp, max_wd_cnt;
 
@@ -7206,7 +7154,7 @@ static void FPT_utilUpdateResidual(struct sccb *p_SCCB)
 {
 	unsigned long partial_cnt;
 	unsigned int sg_index;
-	unsigned long *sg_ptr;
+	struct blogic_sg_seg *segp;
 
 	if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {
 
@@ -7219,7 +7167,6 @@ static void FPT_utilUpdateResidual(struct sccb *p_SCCB)
 
 		sg_index = p_SCCB->Sccb_sgseg;
 
-		sg_ptr = (unsigned long *)p_SCCB->DataPointer;
 
 		if (p_SCCB->Sccb_SGoffset) {
 
@@ -7229,8 +7176,9 @@ static void FPT_utilUpdateResidual(struct sccb *p_SCCB)
 
 		while (((unsigned long)sg_index *
 			(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {
-
-			partial_cnt += *(sg_ptr + (sg_index * 2));
+			segp = (struct blogic_sg_seg *)(p_SCCB->DataPointer) +
+					(sg_index * 2);
+			partial_cnt += segp->segbytes;
 			sg_index++;
 		}
 
@@ -7251,7 +7199,7 @@ static void FPT_utilUpdateResidual(struct sccb *p_SCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_Wait1Second(unsigned long p_port)
+static void FPT_Wait1Second(u32 p_port)
 {
 	unsigned char i;
 
@@ -7275,7 +7223,7 @@ static void FPT_Wait1Second(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_Wait(unsigned long p_port, unsigned char p_delay)
+static void FPT_Wait(u32 p_port, unsigned char p_delay)
 {
 	unsigned char old_timer;
 	unsigned char green_flag;
@@ -7321,7 +7269,7 @@ static void FPT_Wait(unsigned long p_port, unsigned char p_delay)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWriteOnOff(unsigned long p_port, unsigned char p_mode)
+static void FPT_utilEEWriteOnOff(u32 p_port, unsigned char p_mode)
 {
 	unsigned char ee_value;
 
@@ -7350,7 +7298,7 @@ static void FPT_utilEEWriteOnOff(unsigned long p_port, unsigned char p_mode)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data,
+static void FPT_utilEEWrite(u32 p_port, unsigned short ee_data,
 			    unsigned short ee_addr)
 {
 
@@ -7401,7 +7349,7 @@ static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data,
  *
  *---------------------------------------------------------------------*/
 
-static unsigned short FPT_utilEERead(unsigned long p_port,
+static unsigned short FPT_utilEERead(u32 p_port,
 				     unsigned short ee_addr)
 {
 	unsigned short i, ee_data1, ee_data2;
@@ -7431,8 +7379,7 @@ static unsigned short FPT_utilEERead(unsigned long p_port,
  *
  *---------------------------------------------------------------------*/
 
-static unsigned short FPT_utilEEReadOrg(unsigned long p_port,
-					unsigned short ee_addr)
+static unsigned short FPT_utilEEReadOrg(u32 p_port, unsigned short ee_addr)
 {
 
 	unsigned char ee_value;
@@ -7479,7 +7426,7 @@ static unsigned short FPT_utilEEReadOrg(unsigned long p_port,
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd,
+static void FPT_utilEESendCmdAddr(u32 p_port, unsigned char ee_cmd,
 				  unsigned short ee_addr)
 {
 	unsigned char ee_value;
@@ -7579,7 +7526,7 @@ FlashPoint__ProbeHostAdapter(struct fpoint_info *FlashPointInfo)
 					   FlashPointInfo);
 }
 
-static inline unsigned int
+static inline void *
 FlashPoint__HardwareResetHostAdapter(struct fpoint_info *FlashPointInfo)
 {
 	return FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *)
@@ -7587,33 +7534,31 @@ FlashPoint__HardwareResetHostAdapter(struct fpoint_info *FlashPointInfo)
 }
 
 static inline void
-FlashPoint__ReleaseHostAdapter(unsigned int CardHandle)
+FlashPoint__ReleaseHostAdapter(void *CardHandle)
 {
 	FlashPoint_ReleaseHostAdapter(CardHandle);
 }
 
 static inline void
-FlashPoint__StartCCB(unsigned int CardHandle,
-		     struct blogic_ccb *CCB)
+FlashPoint__StartCCB(void *CardHandle, struct blogic_ccb *CCB)
 {
 	FlashPoint_StartCCB(CardHandle, (struct sccb *)CCB);
 }
 
 static inline void
-FlashPoint__AbortCCB(unsigned int CardHandle,
-		     struct blogic_ccb *CCB)
+FlashPoint__AbortCCB(void *CardHandle, struct blogic_ccb *CCB)
 {
 	FlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);
 }
 
 static inline bool
-FlashPoint__InterruptPending(unsigned int CardHandle)
+FlashPoint__InterruptPending(void *CardHandle)
 {
 	return FlashPoint_InterruptPending(CardHandle);
 }
 
 static inline int
-FlashPoint__HandleInterrupt(unsigned int CardHandle)
+FlashPoint__HandleInterrupt(void *CardHandle)
 {
 	return FlashPoint_HandleInterrupt(CardHandle);
 }
@@ -7633,11 +7578,11 @@ FlashPoint__HandleInterrupt(unsigned int CardHandle)
 */
 
 extern unsigned char FlashPoint_ProbeHostAdapter(struct fpoint_info *);
-extern unsigned int FlashPoint_HardwareResetHostAdapter(struct fpoint_info *);
-extern void FlashPoint_StartCCB(unsigned int, struct blogic_ccb *);
-extern int FlashPoint_AbortCCB(unsigned int, struct blogic_ccb *);
-extern bool FlashPoint_InterruptPending(unsigned int);
-extern int FlashPoint_HandleInterrupt(unsigned int);
-extern void FlashPoint_ReleaseHostAdapter(unsigned int);
+extern void *FlashPoint_HardwareResetHostAdapter(struct fpoint_info *);
+extern void FlashPoint_StartCCB(void *, struct blogic_ccb *);
+extern int FlashPoint_AbortCCB(void *, struct blogic_ccb *);
+extern bool FlashPoint_InterruptPending(void *);
+extern int FlashPoint_HandleInterrupt(void *);
+extern void FlashPoint_ReleaseHostAdapter(void *);
 
 #endif				/* CONFIG_SCSI_FLASHPOINT */

commit 839cb99e8f748391059d10388c8aea48a88c142c
Author: Khalid Aziz <khalid.aziz@oracle.com>
Date:   Thu May 16 19:44:13 2013 -0600

    [SCSI] BusLogic: Fix style issues
    
    Fix CamelCase and extra long lines in the buslogic driver.
    
    Signed-off-by: Khalid Aziz <khalid.aziz@oracle.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index dcd716d68600..902972050063 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -7573,47 +7573,47 @@ static unsigned char FPT_CalcLrc(unsigned char buffer[])
 */
 
 static inline unsigned char
-FlashPoint__ProbeHostAdapter(struct FlashPoint_Info *FlashPointInfo)
+FlashPoint__ProbeHostAdapter(struct fpoint_info *FlashPointInfo)
 {
 	return FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *)
 					   FlashPointInfo);
 }
 
-static inline FlashPoint_CardHandle_T
-FlashPoint__HardwareResetHostAdapter(struct FlashPoint_Info *FlashPointInfo)
+static inline unsigned int
+FlashPoint__HardwareResetHostAdapter(struct fpoint_info *FlashPointInfo)
 {
 	return FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *)
 						   FlashPointInfo);
 }
 
 static inline void
-FlashPoint__ReleaseHostAdapter(FlashPoint_CardHandle_T CardHandle)
+FlashPoint__ReleaseHostAdapter(unsigned int CardHandle)
 {
 	FlashPoint_ReleaseHostAdapter(CardHandle);
 }
 
 static inline void
-FlashPoint__StartCCB(FlashPoint_CardHandle_T CardHandle,
-		     struct BusLogic_CCB *CCB)
+FlashPoint__StartCCB(unsigned int CardHandle,
+		     struct blogic_ccb *CCB)
 {
 	FlashPoint_StartCCB(CardHandle, (struct sccb *)CCB);
 }
 
 static inline void
-FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle,
-		     struct BusLogic_CCB *CCB)
+FlashPoint__AbortCCB(unsigned int CardHandle,
+		     struct blogic_ccb *CCB)
 {
 	FlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);
 }
 
 static inline bool
-FlashPoint__InterruptPending(FlashPoint_CardHandle_T CardHandle)
+FlashPoint__InterruptPending(unsigned int CardHandle)
 {
 	return FlashPoint_InterruptPending(CardHandle);
 }
 
 static inline int
-FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
+FlashPoint__HandleInterrupt(unsigned int CardHandle)
 {
 	return FlashPoint_HandleInterrupt(CardHandle);
 }
@@ -7632,13 +7632,12 @@ FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
   Define prototypes for the FlashPoint SCCB Manager Functions.
 */
 
-extern unsigned char FlashPoint_ProbeHostAdapter(struct FlashPoint_Info *);
-extern FlashPoint_CardHandle_T
-FlashPoint_HardwareResetHostAdapter(struct FlashPoint_Info *);
-extern void FlashPoint_StartCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
-extern int FlashPoint_AbortCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
-extern bool FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
-extern int FlashPoint_HandleInterrupt(FlashPoint_CardHandle_T);
-extern void FlashPoint_ReleaseHostAdapter(FlashPoint_CardHandle_T);
+extern unsigned char FlashPoint_ProbeHostAdapter(struct fpoint_info *);
+extern unsigned int FlashPoint_HardwareResetHostAdapter(struct fpoint_info *);
+extern void FlashPoint_StartCCB(unsigned int, struct blogic_ccb *);
+extern int FlashPoint_AbortCCB(unsigned int, struct blogic_ccb *);
+extern bool FlashPoint_InterruptPending(unsigned int);
+extern int FlashPoint_HandleInterrupt(unsigned int);
+extern void FlashPoint_ReleaseHostAdapter(unsigned int);
 
 #endif				/* CONFIG_SCSI_FLASHPOINT */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index e40cdfb7541f..dcd716d68600 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -2509,7 +2509,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
 				WR_HARPOON(port + hp_autostart_3,
 					   (SELECT + SELCHK_STRT));
 
-				/* Setup our STATE so we know what happend when
+				/* Setup our STATE so we know what happened when
 				   the wheels fall off. */
 				currSCCB->Sccb_scsistat = SELECT_ST;
 
@@ -2900,7 +2900,7 @@ static void FPT_SendMsg(unsigned long port, unsigned char message)
  *
  * Function: FPT_sdecm
  *
- * Description: Determine the proper responce to the message from the
+ * Description: Determine the proper response to the message from the
  *              target device.
  *
  *---------------------------------------------------------------------*/

commit 5d7ebb9c7a04d29efce1099024944dfd94d9f63c
Author: Dan Carpenter <error27@gmail.com>
Date:   Mon Dec 28 20:08:39 2009 +0200

    [SCSI] FlashPoint: fix off by one tests
    
    The check on MAX_SCSI_TAR should be >= instead of > or we could go past the
    end of the array.
    
    Joe Eykholt aslo correctly points out that the check on MAX_LUN should be
    >= as well.  That matches with how it is used in the rest of the file.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index b898d382b7b0..e40cdfb7541f 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -3924,7 +3924,7 @@ static void FPT_sinits(struct sccb *p_sccb, unsigned char p_card)
 {
 	struct sccb_mgr_tar_info *currTar_Info;
 
-	if ((p_sccb->TargID > MAX_SCSI_TAR) || (p_sccb->Lun > MAX_LUN)) {
+	if ((p_sccb->TargID >= MAX_SCSI_TAR) || (p_sccb->Lun >= MAX_LUN)) {
 		return;
 	}
 	currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];

commit 1377d8dd7e1b5526637958aabb5427bbee5a68d7
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Apr 23 12:51:10 2008 +0300

    [SCSI] FlashPoint: fix off-by-one errors
    
    This patch fixes off-by-one errors in error checks (the variables are
    used as array indexes for arrays with MAX_SCSI_TAR resp. MAX_LUN
    elements) spotted by the Coverity checker.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index b374e457e5e2..b898d382b7b0 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -1499,7 +1499,7 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
 	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
-	if ((p_Sccb->TargID > MAX_SCSI_TAR) || (p_Sccb->Lun > MAX_LUN)) {
+	if ((p_Sccb->TargID >= MAX_SCSI_TAR) || (p_Sccb->Lun >= MAX_LUN)) {
 
 		p_Sccb->HostStatus = SCCB_COMPLETE;
 		p_Sccb->SccbStatus = SCCB_ERROR;

commit 78b4b05db57b04b3ed17dc71259bf1402c04abfa
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Mar 13 06:55:08 2008 -0600

    [SCSI] BusLogic: make FlashPoint support x86-32 only
    
    We've verified that there are 64 bit and endianness problems in the
    flashpoint driver.  Reverse the logic of CONFIG_OMIT_FLASHPOINT (make
    it CONFIG_SCSI_FLASHPOINT) and make it depend on X86_32 so it can't
    appear for any other architectures.  Long term, if someone chooses,
    they could make FlashPoint 64 bit compliant (it looks like its a
    question of fixing up the sizes in some of the packed descriptors)
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 1c9078191d9e..b374e457e5e2 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -16,7 +16,7 @@
 */
 
 
-#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
+#ifdef CONFIG_SCSI_FLASHPOINT
 
 #define MAX_CARDS	8
 #undef BUSTYPE_PCI
@@ -7626,7 +7626,7 @@ FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
 #define FlashPoint_InterruptPending	    FlashPoint__InterruptPending
 #define FlashPoint_HandleInterrupt	    FlashPoint__HandleInterrupt
 
-#else				/* CONFIG_SCSI_OMIT_FLASHPOINT */
+#else				/* !CONFIG_SCSI_FLASHPOINT */
 
 /*
   Define prototypes for the FlashPoint SCCB Manager Functions.
@@ -7641,4 +7641,4 @@ extern bool FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
 extern int FlashPoint_HandleInterrupt(FlashPoint_CardHandle_T);
 extern void FlashPoint_ReleaseHostAdapter(FlashPoint_CardHandle_T);
 
-#endif				/* CONFIG_SCSI_OMIT_FLASHPOINT */
+#endif				/* CONFIG_SCSI_FLASHPOINT */

commit 1cafc30f43696e8b1b6f7ef4fed354cb3e3af2e6
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Oct 18 23:40:36 2007 -0700

    FlashPoint, use BIT instead of BITW
    
    FlashPoint, use BIT instead of BITW
    
    BITW was an ushort variant of BIT, use BIT instead
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index cf549ffe4baa..1c9078191d9e 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -25,8 +25,6 @@
 
 #define FAILURE         0xFFFFFFFFL
 
-#define BITW(x)          ((unsigned short)(1<<(x)))	/* single-bit mask in bit position x */
-
 struct sccb;
 typedef void (*CALL_BK_FN) (struct sccb *);
 
@@ -373,9 +371,9 @@ typedef struct SCCBscam_info {
 #define  SCAM_ENABLED   BIT(2)
 #define  SCAM_LEVEL2    BIT(3)
 
-#define	RENEGO_ENA		BITW(10)
-#define	CONNIO_ENA		BITW(11)
-#define  GREEN_PC_ENA   BITW(12)
+#define	RENEGO_ENA		BIT(10)
+#define	CONNIO_ENA		BIT(11)
+#define  GREEN_PC_ENA   BIT(12)
 
 #define  AUTO_RATE_00   00
 #define  AUTO_RATE_05   01
@@ -510,23 +508,23 @@ typedef struct SCCBscam_info {
 
 #define  hp_intena		 0x40
 
-#define  RESET		 BITW(7)
-#define  PROG_HLT		 BITW(6)
-#define  PARITY		 BITW(5)
-#define  FIFO		 BITW(4)
-#define  SEL		 BITW(3)
-#define  SCAM_SEL		 BITW(2)
-#define  RSEL		 BITW(1)
-#define  TIMEOUT		 BITW(0)
-#define  BUS_FREE		 BITW(15)
-#define  XFER_CNT_0	 BITW(14)
-#define  PHASE		 BITW(13)
-#define  IUNKWN		 BITW(12)
-#define  ICMD_COMP	 BITW(11)
-#define  ITICKLE		 BITW(10)
-#define  IDO_STRT		 BITW(9)
-#define  ITAR_DISC	 BITW(8)
-#define  AUTO_INT		 (BITW(12)+BITW(11)+BITW(10)+BITW(9)+BITW(8))
+#define  RESET		 BIT(7)
+#define  PROG_HLT		 BIT(6)
+#define  PARITY		 BIT(5)
+#define  FIFO		 BIT(4)
+#define  SEL		 BIT(3)
+#define  SCAM_SEL		 BIT(2)
+#define  RSEL		 BIT(1)
+#define  TIMEOUT		 BIT(0)
+#define  BUS_FREE		 BIT(15)
+#define  XFER_CNT_0	 BIT(14)
+#define  PHASE		 BIT(13)
+#define  IUNKWN		 BIT(12)
+#define  ICMD_COMP	 BIT(11)
+#define  ITICKLE		 BIT(10)
+#define  IDO_STRT		 BIT(9)
+#define  ITAR_DISC	 BIT(8)
+#define  AUTO_INT		 (BIT(12)+BIT(11)+BIT(10)+BIT(9)+BIT(8))
 #define  CLR_ALL_INT	 0xFFFF
 #define  CLR_ALL_INT_1	 0xFF00
 
@@ -673,37 +671,37 @@ typedef struct SCCBscam_info {
 #define  BIOS_DATA_OFFSET     0x60
 #define  BIOS_RELATIVE_CARD   0x64
 
-#define  AR3      (BITW(9) + BITW(8))
-#define  SDATA    BITW(10)
+#define  AR3      (BIT(9) + BIT(8))
+#define  SDATA    BIT(10)
 
-#define  CRD_OP   BITW(11)	/* Cmp Reg. w/ Data */
+#define  CRD_OP   BIT(11)	/* Cmp Reg. w/ Data */
 
-#define  CRR_OP   BITW(12)	/* Cmp Reg. w. Reg. */
+#define  CRR_OP   BIT(12)	/* Cmp Reg. w. Reg. */
 
-#define  CPE_OP   (BITW(14)+BITW(11))	/* Cmp SCSI phs & Branch EQ */
+#define  CPE_OP   (BIT(14)+BIT(11))	/* Cmp SCSI phs & Branch EQ */
 
-#define  CPN_OP   (BITW(14)+BITW(12))	/* Cmp SCSI phs & Branch NOT EQ */
+#define  CPN_OP   (BIT(14)+BIT(12))	/* Cmp SCSI phs & Branch NOT EQ */
 
 #define  ADATA_OUT   0x00
-#define  ADATA_IN    BITW(8)
-#define  ACOMMAND    BITW(10)
-#define  ASTATUS     (BITW(10)+BITW(8))
-#define  AMSG_OUT    (BITW(10)+BITW(9))
-#define  AMSG_IN     (BITW(10)+BITW(9)+BITW(8))
+#define  ADATA_IN    BIT(8)
+#define  ACOMMAND    BIT(10)
+#define  ASTATUS     (BIT(10)+BIT(8))
+#define  AMSG_OUT    (BIT(10)+BIT(9))
+#define  AMSG_IN     (BIT(10)+BIT(9)+BIT(8))
 
-#define  BRH_OP   BITW(13)	/* Branch */
+#define  BRH_OP   BIT(13)	/* Branch */
 
 #define  ALWAYS   0x00
-#define  EQUAL    BITW(8)
-#define  NOT_EQ   BITW(9)
+#define  EQUAL    BIT(8)
+#define  NOT_EQ   BIT(9)
 
-#define  TCB_OP   (BITW(13)+BITW(11))	/* Test condition & branch */
+#define  TCB_OP   (BIT(13)+BIT(11))	/* Test condition & branch */
 
-#define  FIFO_0      BITW(10)
+#define  FIFO_0      BIT(10)
 
-#define  MPM_OP   BITW(15)	/* Match phase and move data */
+#define  MPM_OP   BIT(15)	/* Match phase and move data */
 
-#define  MRR_OP   BITW(14)	/* Move DReg. to Reg. */
+#define  MRR_OP   BIT(14)	/* Move DReg. to Reg. */
 
 #define  S_IDREG  (BIT(2)+BIT(1)+BIT(0))
 
@@ -711,9 +709,9 @@ typedef struct SCCBscam_info {
 #define  D_AR1    BIT(0)
 #define  D_BUCKET (BIT(2) + BIT(1) + BIT(0))
 
-#define  RAT_OP      (BITW(14)+BITW(13)+BITW(11))
+#define  RAT_OP      (BIT(14)+BIT(13)+BIT(11))
 
-#define  SSI_OP      (BITW(15)+BITW(11))
+#define  SSI_OP      (BIT(15)+BIT(11))
 
 #define  SSI_ITAR_DISC	(ITAR_DISC >> 8)
 #define  SSI_IDO_STRT	(IDO_STRT >> 8)

commit 93043ece030af58529e3e1367502461d265ab4e2
Author: Jiri Slaby <jirislaby@gmail.com>
Date:   Thu Oct 18 23:40:35 2007 -0700

    define global BIT macro
    
    define global BIT macro
    
    move all local BIT defines to the new globally define macro.
    
    Signed-off-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Kumar Gala <galak@gate.crashing.org>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index a7f916c0c9cd..cf549ffe4baa 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -25,7 +25,6 @@
 
 #define FAILURE         0xFFFFFFFFL
 
-#define BIT(x)          ((unsigned char)(1<<(x)))	/* single-bit mask in bit position x */
 #define BITW(x)          ((unsigned short)(1<<(x)))	/* single-bit mask in bit position x */
 
 struct sccb;

commit 2065e310cc116e4b2b0f42faaf27f0c9baaca9cd
Author: Richard Knutsson <ricknu-0@student.ltu.se>
Date:   Mon Feb 5 16:39:01 2007 -0800

    [SCSI] BusLogic: Replace 'boolean' by 'bool'
    
    Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 7c0068049586..a7f916c0c9cd 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -7609,7 +7609,7 @@ FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle,
 	FlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);
 }
 
-static inline boolean
+static inline bool
 FlashPoint__InterruptPending(FlashPoint_CardHandle_T CardHandle)
 {
 	return FlashPoint_InterruptPending(CardHandle);
@@ -7640,7 +7640,7 @@ extern FlashPoint_CardHandle_T
 FlashPoint_HardwareResetHostAdapter(struct FlashPoint_Info *);
 extern void FlashPoint_StartCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
 extern int FlashPoint_AbortCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
-extern boolean FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
+extern bool FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
 extern int FlashPoint_HandleInterrupt(FlashPoint_CardHandle_T);
 extern void FlashPoint_ReleaseHostAdapter(FlashPoint_CardHandle_T);
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 8e3d949b7118..7c0068049586 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -15,7 +15,6 @@
 
 */
 
-#include <linux/config.h>
 
 #ifndef CONFIG_SCSI_OMIT_FLASHPOINT
 

commit 5c1b85e209af41c7e99a2bfd21dc8fe840b342d8
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:37 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: don't use parenthesis with "return"
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index ce49fbcafbb6..8e3d949b7118 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -945,16 +945,16 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 	ioport = pCardInfo->si_baseaddr;
 
 	if (RD_HARPOON(ioport + hp_vendor_id_0) != ORION_VEND_0)
-		return ((int)FAILURE);
+		return (int)FAILURE;
 
 	if ((RD_HARPOON(ioport + hp_vendor_id_1) != ORION_VEND_1))
-		return ((int)FAILURE);
+		return (int)FAILURE;
 
 	if ((RD_HARPOON(ioport + hp_device_id_0) != ORION_DEV_0))
-		return ((int)FAILURE);
+		return (int)FAILURE;
 
 	if ((RD_HARPOON(ioport + hp_device_id_1) != ORION_DEV_1))
-		return ((int)FAILURE);
+		return (int)FAILURE;
 
 	if (RD_HARPOON(ioport + hp_rev_num) != 0x0f) {
 
@@ -964,7 +964,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 	device. */
 
 		if (RD_HARPOON(ioport + hp_sub_device_id_0) & 0x0f)
-			return ((int)FAILURE);
+			return (int)FAILURE;
 	}
 
 	if (first_time) {
@@ -986,7 +986,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 				pCurrNvRam->niBaseAddr = ioport;
 				FPT_RNVRamData(pCurrNvRam);
 			} else
-				return ((int)FAILURE);
+				return (int)FAILURE;
 		}
 	} else
 		pCurrNvRam = NULL;
@@ -1194,7 +1194,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 
 	pCardInfo->si_present = 0x01;
 
-	return (0);
+	return 0;
 }
 
 /*---------------------------------------------------------------------
@@ -1220,7 +1220,7 @@ static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info
 
 		if (thisCard == MAX_CARDS) {
 
-			return (FAILURE);
+			return FAILURE;
 		}
 
 		if (FPT_BL_Card[thisCard].ioPort == ioport) {
@@ -1388,7 +1388,7 @@ static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info
 		   (unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |
 				   SCCB_MGR_PRESENT));
 
-	return ((unsigned long)CurrCard);
+	return (unsigned long)CurrCard;
 }
 
 static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
@@ -1460,7 +1460,7 @@ static void FPT_RNVRamData(struct nvram_info *pNvRamInfo)
 static unsigned char FPT_RdStack(unsigned long portBase, unsigned char index)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
-	return (RD_HARPOON(portBase + hp_stack_data));
+	return RD_HARPOON(portBase + hp_stack_data);
 }
 
 static void FPT_WrStack(unsigned long portBase, unsigned char index,
@@ -1473,14 +1473,14 @@ static void FPT_WrStack(unsigned long portBase, unsigned char index,
 static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
 {
 	if ((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
-		return (0);
+		return 0;
 	if ((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)
 	    != CLKCTRL_DEFAULT)
-		return (0);
+		return 0;
 	if ((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||
 	    (RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))
-		return (1);
-	return (0);
+		return 1;
+	return 0;
 
 }
 
@@ -1642,14 +1642,14 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 			callback = p_Sccb->SccbCallback;
 			callback(p_Sccb);
 
-			return (0);
+			return 0;
 		}
 
 		else {
 			if (((struct sccb_card *)pCurrCard)->currentSCCB ==
 			    p_Sccb) {
 				p_Sccb->SccbStatus = SCCB_ABORT;
-				return (0);
+				return 0;
 
 			}
 
@@ -1691,7 +1691,7 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 						}
 					}
 					MENABLE_INT(ioport);
-					return (0);
+					return 0;
 				} else {
 					currTar_Info =
 					    &FPT_sccbMgrTbl[thisCard][p_Sccb->
@@ -1702,13 +1702,13 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 						      LunDiscQ_Idx[p_Sccb->Lun]]
 					    == p_Sccb) {
 						p_Sccb->SccbStatus = SCCB_ABORT;
-						return (0);
+						return 0;
 					}
 				}
 			}
 		}
 	}
-	return (-1);
+	return -1;
 }
 
 /*---------------------------------------------------------------------
@@ -1726,12 +1726,12 @@ static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
 	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
 	if (RD_HARPOON(ioport + hp_int_status) & INT_ASSERTED) {
-		return (1);
+		return 1;
 	}
 
 	else
 
-		return (0);
+		return 0;
 }
 
 /*---------------------------------------------------------------------
@@ -1783,7 +1783,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 			if (result) {
 
 				MENABLE_INT(ioport);
-				return (result);
+				return result;
 			}
 		}
 
@@ -1997,7 +1997,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 
 	MENABLE_INT(ioport);
 
-	return (0);
+	return 0;
 }
 
 /*---------------------------------------------------------------------
@@ -2092,7 +2092,7 @@ static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port,
 
 		FPT_scini(p_card, pCurrCard->ourId, 0);
 
-		return (0xFF);
+		return 0xFF;
 	}
 
 	else if (p_int & FIFO) {
@@ -2150,7 +2150,7 @@ static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port,
 		WRW_HARPOON((p_port + hp_intstat), SCAM_SEL);
 	}
 
-	return (0x00);
+	return 0x00;
 }
 
 /*---------------------------------------------------------------------
@@ -2295,12 +2295,12 @@ static unsigned char FPT_sfm(unsigned long port, struct sccb *pCurrSCCB)
 			}
 			if (TimeOutLoop > 20000) {
 				WRW_HARPOON((port + hp_intstat), PARITY);
-				return (message);
+				return message;
 			}
 			if ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) !=
 			    S_MSGI_PH) {
 				WRW_HARPOON((port + hp_intstat), PARITY);
-				return (message);
+				return message;
 			}
 			WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
 
@@ -2315,7 +2315,7 @@ static unsigned char FPT_sfm(unsigned long port, struct sccb *pCurrSCCB)
 	WR_HARPOON(port + hp_xferstat, 0);
 	WR_HARPOON(port + hp_fiforead, 0);
 	WR_HARPOON(port + hp_fifowrite, 0);
-	return (message);
+	return message;
 }
 
 /*---------------------------------------------------------------------
@@ -3219,14 +3219,14 @@ static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card,
 				   (AUTO_IMMED + CMD_ONLY_STRT));
 		}
 
-		return (1);
+		return 1;
 	}
 
 	else {
 
 		currTar_Info->TarStatus |= (unsigned char)SYNC_SUPPORTED;
 		currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
-		return (0);
+		return 0;
 	}
 }
 
@@ -3431,7 +3431,7 @@ static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 					    ~(unsigned char)TAR_WIDE_MASK) |
 					   (unsigned char)WIDE_ENABLED);
 
-		return (1);
+		return 1;
 	}
 
 	else {
@@ -3441,7 +3441,7 @@ static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 					   WIDE_NEGOCIATED);
 
 		currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
-		return (0);
+		return 0;
 	}
 }
 
@@ -5155,11 +5155,11 @@ static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
 	RD_HARPOON(p_port + hp_int_status);	/*Clear command complete */
 
 	if (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {
-		return (1);
+		return 1;
 	}
 
 	else {
-		return (0);
+		return 0;
 	}
 }
 
@@ -5721,10 +5721,10 @@ static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 		}
 
 		if (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL)
-			return (0);
+			return 0;
 
 		if (RD_HARPOON(p_port + hp_scsidata_0) != 00)
-			return (0);
+			return 0;
 
 		WR_HARPOON(p_port + hp_scsisig,
 			   (RD_HARPOON(p_port + hp_scsisig) | SCSI_BSY));
@@ -5734,7 +5734,7 @@ static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 			WR_HARPOON(p_port + hp_scsisig,
 				   (RD_HARPOON(p_port + hp_scsisig) &
 				    ~SCSI_BSY));
-			return (0);
+			return 0;
 		}
 
 		WR_HARPOON(p_port + hp_scsisig,
@@ -5745,7 +5745,7 @@ static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 			WR_HARPOON(p_port + hp_scsisig,
 				   (RD_HARPOON(p_port + hp_scsisig) &
 				    ~(SCSI_BSY | SCSI_SEL)));
-			return (0);
+			return 0;
 		}
 	}
 
@@ -5764,7 +5764,7 @@ static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 
 	FPT_Wait(p_port, TO_250ms);
 
-	return (1);
+	return 1;
 }
 
 /*---------------------------------------------------------------------
@@ -5956,7 +5956,7 @@ static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data)
 
 	FPT_scwirod(p_port, BIT(6));	/*Wait for DB6 to be released. */
 
-	return (ret_data);
+	return ret_data;
 }
 
 /*---------------------------------------------------------------------
@@ -5994,22 +5994,22 @@ static unsigned char FPT_scsendi(unsigned long p_port,
 			}
 
 			if ((ret_data & 0x1C) == 0x10)
-				return (0x00);	/*End of isolation stage, we won! */
+				return 0x00;	/*End of isolation stage, we won! */
 
 			if (ret_data & 0x1C)
-				return (0xFF);
+				return 0xFF;
 
 			if ((defer) && (!(ret_data & 0x1F)))
-				return (0x01);	/*End of isolation stage, we lost. */
+				return 0x01;	/*End of isolation stage, we lost. */
 
 		}		/*bit loop */
 
 	}			/*byte loop */
 
 	if (defer)
-		return (0x01);	/*We lost */
+		return 0x01;	/*We lost */
 	else
-		return (0);	/*We WON! Yeeessss! */
+		return 0;	/*We WON! Yeeessss! */
 }
 
 /*---------------------------------------------------------------------
@@ -6034,7 +6034,7 @@ static unsigned char FPT_sciso(unsigned long p_port,
 			ret_data = FPT_scxferc(p_port, 0);
 
 			if (ret_data & 0xFC)
-				return (0xFF);
+				return 0xFF;
 
 			else {
 
@@ -6056,9 +6056,9 @@ static unsigned char FPT_sciso(unsigned long p_port,
 				}
 */
 				if (byte_cnt)
-					return (0x00);
+					return 0x00;
 				else
-					return (0xFF);
+					return 0xFF;
 			}
 
 		}		/*bit loop */
@@ -6067,7 +6067,7 @@ static unsigned char FPT_sciso(unsigned long p_port,
 
 	}			/*byte loop */
 
-	return (0);
+	return 0;
 }
 
 /*---------------------------------------------------------------------
@@ -6142,10 +6142,10 @@ static unsigned char FPT_scvalq(unsigned char p_quintet)
 	}
 
 	if (p_quintet & 0x18)
-		return (0);
+		return 0;
 
 	else
-		return (1);
+		return 1;
 }
 
 /*---------------------------------------------------------------------
@@ -6209,7 +6209,7 @@ static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
 			   (RD_HARPOON(p_port + hp_page_ctrl) &
 			    ~G_INT_DISABLE));
 
-		return (0);	/*No legacy device */
+		return 0;	/*No legacy device */
 	}
 
 	else {
@@ -6228,7 +6228,7 @@ static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
 			   (RD_HARPOON(p_port + hp_page_ctrl) &
 			    ~G_INT_DISABLE));
 
-		return (1);	/*Found one of them oldies! */
+		return 1;	/*Found one of them oldies! */
 	}
 }
 
@@ -6342,7 +6342,7 @@ static unsigned char FPT_scmachid(unsigned char p_card,
 
 		if (match) {
 			FPT_scamInfo[i].state = ID_ASSIGNED;
-			return (i);
+			return i;
 		}
 
 	}
@@ -6372,7 +6372,7 @@ static unsigned char FPT_scmachid(unsigned char p_card,
 			if (FPT_BL_Card[p_card].pNvRamInfo == NULL)
 				FPT_BL_Card[p_card].globalFlags |=
 				    F_UPDATE_EEPROM;
-			return (match);
+			return match;
 
 		}
 
@@ -6387,7 +6387,7 @@ static unsigned char FPT_scmachid(unsigned char p_card,
 	}
 
 	if (p_id_string[0] & BIT(7)) {
-		return (CLR_PRIORITY);
+		return CLR_PRIORITY;
 	}
 
 	if (p_id_string[0] & BIT(5))
@@ -6416,7 +6416,7 @@ static unsigned char FPT_scmachid(unsigned char p_card,
 			if (FPT_BL_Card[p_card].pNvRamInfo == NULL)
 				FPT_BL_Card[p_card].globalFlags |=
 				    F_UPDATE_EEPROM;
-			return (match);
+			return match;
 
 		}
 
@@ -6430,7 +6430,7 @@ static unsigned char FPT_scmachid(unsigned char p_card,
 		}
 	}
 
-	return (NO_ID_AVAIL);
+	return NO_ID_AVAIL;
 }
 
 /*---------------------------------------------------------------------
@@ -7181,7 +7181,7 @@ static unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,
 
 			currTar_Info->TarSelQ_Cnt--;
 
-			return (1);
+			return 1;
 		}
 
 		else {
@@ -7189,7 +7189,7 @@ static unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,
 		}
 	}
 
-	return (0);
+	return 0;
 
 }
 
@@ -7416,14 +7416,14 @@ static unsigned short FPT_utilEERead(unsigned long p_port,
 		ee_data2 = FPT_utilEEReadOrg(p_port, ee_addr);
 
 		if (ee_data1 == ee_data2)
-			return (ee_data1);
+			return ee_data1;
 
 		ee_data1 = ee_data2;
 		i++;
 
 	} while (i < 4);
 
-	return (ee_data1);
+	return ee_data1;
 }
 
 /*---------------------------------------------------------------------
@@ -7471,7 +7471,7 @@ static unsigned short FPT_utilEEReadOrg(unsigned long p_port,
 	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));	/*Turn off CS */
 	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);	/*Turn off Master Select */
 
-	return (ee_data);
+	return ee_data;
 }
 
 /*---------------------------------------------------------------------
@@ -7559,7 +7559,7 @@ static unsigned short FPT_CalcCrc16(unsigned char buffer[])
 			ch >>= 1;
 		}
 	}
-	return (crc);
+	return crc;
 }
 
 static unsigned char FPT_CalcLrc(unsigned char buffer[])
@@ -7569,7 +7569,7 @@ static unsigned char FPT_CalcLrc(unsigned char buffer[])
 	lrc = 0;
 	for (i = 0; i < ID_STRING_LENGTH; i++)
 		lrc ^= buffer[i];
-	return (lrc);
+	return lrc;
 }
 
 /*

commit 5c04a7b8981f2855869bf04c881553135445d701
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:35 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: Lindent
    
    It's much, much more readable now.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 37ee2cb60d20..ce49fbcafbb6 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -15,74 +15,47 @@
 
 */
 
-
 #include <linux/config.h>
 
-
 #ifndef CONFIG_SCSI_OMIT_FLASHPOINT
 
-
 #define MAX_CARDS	8
 #undef BUSTYPE_PCI
 
-
-
-
-
-
-
-
-
 #define CRCMASK	0xA001
 
-
-
 #define FAILURE         0xFFFFFFFFL
 
-
-
-
-
-
-
-
-
-
-#define BIT(x)          ((unsigned char)(1<<(x)))    /* single-bit mask in bit position x */
-#define BITW(x)          ((unsigned short)(1<<(x)))  /* single-bit mask in bit position x */
-
-
+#define BIT(x)          ((unsigned char)(1<<(x)))	/* single-bit mask in bit position x */
+#define BITW(x)          ((unsigned short)(1<<(x)))	/* single-bit mask in bit position x */
 
 struct sccb;
-typedef void (*CALL_BK_FN)(struct sccb *);
-
+typedef void (*CALL_BK_FN) (struct sccb *);
 
 struct sccb_mgr_info {
-   unsigned long    si_baseaddr;
-   unsigned char    si_present;
-   unsigned char    si_intvect;
-   unsigned char    si_id;
-   unsigned char    si_lun;
-   unsigned short   si_fw_revision;
-   unsigned short   si_per_targ_init_sync;
-   unsigned short   si_per_targ_fast_nego;
-   unsigned short   si_per_targ_ultra_nego;
-   unsigned short   si_per_targ_no_disc;
-   unsigned short   si_per_targ_wide_nego;
-   unsigned short   si_flags;
-   unsigned char    si_card_family;
-   unsigned char    si_bustype;
-   unsigned char    si_card_model[3];
-   unsigned char    si_relative_cardnum;
-   unsigned char    si_reserved[4];
-   unsigned long    si_OS_reserved;
-   unsigned char    si_XlatInfo[4];
-   unsigned long    si_reserved2[5];
-   unsigned long    si_secondary_range;
+	unsigned long si_baseaddr;
+	unsigned char si_present;
+	unsigned char si_intvect;
+	unsigned char si_id;
+	unsigned char si_lun;
+	unsigned short si_fw_revision;
+	unsigned short si_per_targ_init_sync;
+	unsigned short si_per_targ_fast_nego;
+	unsigned short si_per_targ_ultra_nego;
+	unsigned short si_per_targ_no_disc;
+	unsigned short si_per_targ_wide_nego;
+	unsigned short si_flags;
+	unsigned char si_card_family;
+	unsigned char si_bustype;
+	unsigned char si_card_model[3];
+	unsigned char si_relative_cardnum;
+	unsigned char si_reserved[4];
+	unsigned long si_OS_reserved;
+	unsigned char si_XlatInfo[4];
+	unsigned long si_reserved2[5];
+	unsigned long si_secondary_range;
 };
 
-
-
 #define SCSI_PARITY_ENA		  0x0001
 #define LOW_BYTE_TERM		  0x0010
 #define HIGH_BYTE_TERM		  0x0020
@@ -95,97 +68,82 @@ struct sccb_mgr_info {
 #define FLAG_SCAM_ENABLED	  0x0080
 #define FLAG_SCAM_LEVEL2	  0x0100
 
-
-
-
 #define HARPOON_FAMILY        0x02
 
-
-
 /* SCCB struct used for both SCCB and UCB manager compiles! 
  * The UCB Manager treats the SCCB as it's 'native hardware structure' 
  */
 
-
 #pragma pack(1)
 struct sccb {
-   unsigned char OperationCode;
-   unsigned char ControlByte;
-   unsigned char CdbLength;
-   unsigned char RequestSenseLength;
-   unsigned long DataLength;
-   unsigned long DataPointer;
-   unsigned char CcbRes[2];
-   unsigned char HostStatus;
-   unsigned char TargetStatus;
-   unsigned char TargID;
-   unsigned char Lun;
-   unsigned char Cdb[12];
-   unsigned char CcbRes1;
-   unsigned char Reserved1;
-   unsigned long Reserved2;
-   unsigned long SensePointer;
-
-
-   CALL_BK_FN SccbCallback;                  /* VOID (*SccbCallback)(); */
-   unsigned long  SccbIOPort;                        /* Identifies board base port */
-   unsigned char  SccbStatus;
-   unsigned char  SCCBRes2;
-   unsigned short SccbOSFlags;
-
-
-   unsigned long   Sccb_XferCnt;            /* actual transfer count */
-   unsigned long   Sccb_ATC;
-   unsigned long   SccbVirtDataPtr;         /* virtual addr for OS/2 */
-   unsigned long   Sccb_res1;
-   unsigned short  Sccb_MGRFlags;
-   unsigned short  Sccb_sgseg;
-   unsigned char   Sccb_scsimsg;            /* identify msg for selection */
-   unsigned char   Sccb_tag;
-   unsigned char   Sccb_scsistat;
-   unsigned char   Sccb_idmsg;              /* image of last msg in */
-   struct sccb *   Sccb_forwardlink;
-   struct sccb *   Sccb_backlink;
-   unsigned long   Sccb_savedATC;
-   unsigned char   Save_Cdb[6];
-   unsigned char   Save_CdbLen;
-   unsigned char   Sccb_XferState;
-   unsigned long   Sccb_SGoffset;
-   };
-
+	unsigned char OperationCode;
+	unsigned char ControlByte;
+	unsigned char CdbLength;
+	unsigned char RequestSenseLength;
+	unsigned long DataLength;
+	unsigned long DataPointer;
+	unsigned char CcbRes[2];
+	unsigned char HostStatus;
+	unsigned char TargetStatus;
+	unsigned char TargID;
+	unsigned char Lun;
+	unsigned char Cdb[12];
+	unsigned char CcbRes1;
+	unsigned char Reserved1;
+	unsigned long Reserved2;
+	unsigned long SensePointer;
+
+	CALL_BK_FN SccbCallback;	/* VOID (*SccbCallback)(); */
+	unsigned long SccbIOPort;	/* Identifies board base port */
+	unsigned char SccbStatus;
+	unsigned char SCCBRes2;
+	unsigned short SccbOSFlags;
+
+	unsigned long Sccb_XferCnt;	/* actual transfer count */
+	unsigned long Sccb_ATC;
+	unsigned long SccbVirtDataPtr;	/* virtual addr for OS/2 */
+	unsigned long Sccb_res1;
+	unsigned short Sccb_MGRFlags;
+	unsigned short Sccb_sgseg;
+	unsigned char Sccb_scsimsg;	/* identify msg for selection */
+	unsigned char Sccb_tag;
+	unsigned char Sccb_scsistat;
+	unsigned char Sccb_idmsg;	/* image of last msg in */
+	struct sccb *Sccb_forwardlink;
+	struct sccb *Sccb_backlink;
+	unsigned long Sccb_savedATC;
+	unsigned char Save_Cdb[6];
+	unsigned char Save_CdbLen;
+	unsigned char Sccb_XferState;
+	unsigned long Sccb_SGoffset;
+};
 
 #pragma pack()
 
-
-
 #define SCATTER_GATHER_COMMAND    0x02
 #define RESIDUAL_COMMAND          0x03
 #define RESIDUAL_SG_COMMAND       0x04
 #define RESET_COMMAND             0x81
 
+#define F_USE_CMD_Q              0x20	/*Inidcates TAGGED command. */
+#define TAG_TYPE_MASK            0xC0	/*Type of tag msg to send. */
+#define SCCB_DATA_XFER_OUT       0x10	/* Write */
+#define SCCB_DATA_XFER_IN        0x08	/* Read */
 
-#define F_USE_CMD_Q              0x20     /*Inidcates TAGGED command. */
-#define TAG_TYPE_MASK            0xC0     /*Type of tag msg to send. */
-#define SCCB_DATA_XFER_OUT       0x10     /* Write */
-#define SCCB_DATA_XFER_IN        0x08     /* Read */
-
-
-#define NO_AUTO_REQUEST_SENSE    0x01     /* No Request Sense Buffer */
+#define NO_AUTO_REQUEST_SENSE    0x01	/* No Request Sense Buffer */
 
-
-#define BUS_FREE_ST     0       
+#define BUS_FREE_ST     0
 #define SELECT_ST       1
-#define SELECT_BDR_ST   2     /* Select w\ Bus Device Reset */
-#define SELECT_SN_ST    3     /* Select w\ Sync Nego */
-#define SELECT_WN_ST    4     /* Select w\ Wide Data Nego */
-#define SELECT_Q_ST     5     /* Select w\ Tagged Q'ing */
+#define SELECT_BDR_ST   2	/* Select w\ Bus Device Reset */
+#define SELECT_SN_ST    3	/* Select w\ Sync Nego */
+#define SELECT_WN_ST    4	/* Select w\ Wide Data Nego */
+#define SELECT_Q_ST     5	/* Select w\ Tagged Q'ing */
 #define COMMAND_ST      6
 #define DATA_OUT_ST     7
 #define DATA_IN_ST      8
 #define DISCONNECT_ST   9
 #define ABORT_ST        11
 
-
 #define F_HOST_XFER_DIR                0x01
 #define F_ALL_XFERRED                  0x02
 #define F_SG_XFER                      0x04
@@ -193,49 +151,37 @@ struct sccb {
 #define F_ODD_BALL_CNT                 0x10
 #define F_NO_DATA_YET                  0x80
 
-
 #define F_STATUSLOADED                 0x01
 #define F_DEV_SELECTED                 0x04
 
-
-#define SCCB_COMPLETE               0x00  /* SCCB completed without error */
+#define SCCB_COMPLETE               0x00	/* SCCB completed without error */
 #define SCCB_DATA_UNDER_RUN         0x0C
-#define SCCB_SELECTION_TIMEOUT      0x11  /* Set SCSI selection timed out */
+#define SCCB_SELECTION_TIMEOUT      0x11	/* Set SCSI selection timed out */
 #define SCCB_DATA_OVER_RUN          0x12
-#define SCCB_PHASE_SEQUENCE_FAIL    0x14  /* Target bus phase sequence failure */
-
-#define SCCB_GROSS_FW_ERR           0x27  /* Major problem! */
-#define SCCB_BM_ERR                 0x30  /* BusMaster error. */
-#define SCCB_PARITY_ERR             0x34  /* SCSI parity error */
-
-
-
+#define SCCB_PHASE_SEQUENCE_FAIL    0x14	/* Target bus phase sequence failure */
 
+#define SCCB_GROSS_FW_ERR           0x27	/* Major problem! */
+#define SCCB_BM_ERR                 0x30	/* BusMaster error. */
+#define SCCB_PARITY_ERR             0x34	/* SCSI parity error */
 
 #define SCCB_IN_PROCESS            0x00
 #define SCCB_SUCCESS               0x01
 #define SCCB_ABORT                 0x02
 #define SCCB_ERROR                 0x04
 
-
-
 #define  ORION_FW_REV      3110
 
+#define QUEUE_DEPTH     254+1	/*1 for Normal disconnect 32 for Q'ing. */
 
-
-#define QUEUE_DEPTH     254+1            /*1 for Normal disconnect 32 for Q'ing. */
-
-#define	MAX_MB_CARDS	4					/* Max. no of cards suppoerted on Mother Board */
-
+#define	MAX_MB_CARDS	4	/* Max. no of cards suppoerted on Mother Board */
 
 #define MAX_SCSI_TAR    16
 #define MAX_LUN         32
 #define LUN_MASK			0x1f
 
-#define SG_BUF_CNT      16             /*Number of prefetched elements. */
-
-#define SG_ELEMENT_SIZE 8              /*Eight byte per element. */
+#define SG_BUF_CNT      16	/*Number of prefetched elements. */
 
+#define SG_ELEMENT_SIZE 8	/*Eight byte per element. */
 
 #define RD_HARPOON(ioport)          inb((u32)ioport)
 #define RDW_HARPOON(ioport)         inw((u32)ioport)
@@ -244,7 +190,6 @@ struct sccb {
 #define WRW_HARPOON(ioport,val)       outw((u16)val, (u32)ioport)
 #define WR_HARP32(ioport,offset,data)  outl(data, (u32)(ioport + offset))
 
-
 #define  TAR_SYNC_MASK     (BIT(7)+BIT(6))
 #define  SYNC_TRYING               BIT(6)
 #define  SYNC_SUPPORTED    (BIT(7)+BIT(6))
@@ -259,7 +204,6 @@ struct sccb {
 
 #define  TAR_ALLOW_DISC    BIT(0)
 
-
 #define  EE_SYNC_MASK      (BIT(0)+BIT(1))
 #define  EE_SYNC_5MB       BIT(0)
 #define  EE_SYNC_10MB      BIT(1)
@@ -267,62 +211,55 @@ struct sccb {
 
 #define  EE_WIDE_SCSI      BIT(7)
 
-
-
-
 struct sccb_mgr_tar_info {
 
-   struct sccb *    TarSelQ_Head;
-   struct sccb *    TarSelQ_Tail;
-   unsigned char    TarLUN_CA;        /*Contingent Allgiance */
-   unsigned char    TarTagQ_Cnt;
-   unsigned char    TarSelQ_Cnt;
-   unsigned char    TarStatus;
-   unsigned char    TarEEValue;
-   unsigned char 	TarSyncCtrl;
-   unsigned char 	TarReserved[2];			/* for alignment */
-   unsigned char 	LunDiscQ_Idx[MAX_LUN];
-   unsigned char    TarLUNBusy[MAX_LUN];
+	struct sccb *TarSelQ_Head;
+	struct sccb *TarSelQ_Tail;
+	unsigned char TarLUN_CA;	/*Contingent Allgiance */
+	unsigned char TarTagQ_Cnt;
+	unsigned char TarSelQ_Cnt;
+	unsigned char TarStatus;
+	unsigned char TarEEValue;
+	unsigned char TarSyncCtrl;
+	unsigned char TarReserved[2];	/* for alignment */
+	unsigned char LunDiscQ_Idx[MAX_LUN];
+	unsigned char TarLUNBusy[MAX_LUN];
 };
 
 struct nvram_info {
-	unsigned char		niModel;								/* Model No. of card */
-	unsigned char		niCardNo;							/* Card no. */
-	unsigned long		niBaseAddr;							/* Port Address of card */
-	unsigned char		niSysConf;							/* Adapter Configuration byte - Byte 16 of eeprom map */
-	unsigned char		niScsiConf;							/* SCSI Configuration byte - Byte 17 of eeprom map */
-	unsigned char		niScamConf;							/* SCAM Configuration byte - Byte 20 of eeprom map */
-	unsigned char		niAdapId;							/* Host Adapter ID - Byte 24 of eerpom map */
-	unsigned char		niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
-	unsigned char		niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
+	unsigned char niModel;	/* Model No. of card */
+	unsigned char niCardNo;	/* Card no. */
+	unsigned long niBaseAddr;	/* Port Address of card */
+	unsigned char niSysConf;	/* Adapter Configuration byte - Byte 16 of eeprom map */
+	unsigned char niScsiConf;	/* SCSI Configuration byte - Byte 17 of eeprom map */
+	unsigned char niScamConf;	/* SCAM Configuration byte - Byte 20 of eeprom map */
+	unsigned char niAdapId;	/* Host Adapter ID - Byte 24 of eerpom map */
+	unsigned char niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
+	unsigned char niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
 };
 
-
 #define	MODEL_LT		1
 #define	MODEL_DL		2
 #define	MODEL_LW		3
 #define	MODEL_DW		4
 
-
 struct sccb_card {
-   struct sccb * currentSCCB;
-   struct sccb_mgr_info * cardInfo;
-
-   unsigned long ioPort;
-
-   unsigned short cmdCounter;
-   unsigned char  discQCount;
-   unsigned char  tagQ_Lst;
-   unsigned char cardIndex;
-   unsigned char scanIndex;
-   unsigned char globalFlags;
-   unsigned char ourId;
-   struct nvram_info * pNvRamInfo;
-   struct sccb * discQ_Tbl[QUEUE_DEPTH];
-      
-};
+	struct sccb *currentSCCB;
+	struct sccb_mgr_info *cardInfo;
+
+	unsigned long ioPort;
 
+	unsigned short cmdCounter;
+	unsigned char discQCount;
+	unsigned char tagQ_Lst;
+	unsigned char cardIndex;
+	unsigned char scanIndex;
+	unsigned char globalFlags;
+	unsigned char ourId;
+	struct nvram_info *pNvRamInfo;
+	struct sccb *discQ_Tbl[QUEUE_DEPTH];
 
+};
 
 #define F_TAG_STARTED		0x01
 #define F_CONLUN_IO			0x02
@@ -333,12 +270,10 @@ struct sccb_card {
 #define F_NEW_SCCB_CMD		0x40
 #define F_UPDATE_EEPROM		0x80
 
-
 #define  ID_STRING_LENGTH  32
-#define  TYPE_CODE0        0x63           /*Level2 Mstr (bits 7-6),  */
-
+#define  TYPE_CODE0        0x63	/*Level2 Mstr (bits 7-6),  */
 
-#define  SLV_TYPE_CODE0    0xA3           /*Priority Bit set (bits 7-6),  */
+#define  SLV_TYPE_CODE0    0xA3	/*Priority Bit set (bits 7-6),  */
 
 #define  ASSIGN_ID   0x00
 #define  SET_P_FLAG  0x01
@@ -351,23 +286,21 @@ struct sccb_card {
 #define  MISC_CODE   0x14
 #define  CLR_P_FLAG  0x18
 
-
-
 #define  INIT_SELTD  0x01
 #define  LEVEL2_TAR  0x02
 
-
-enum scam_id_st { ID0,ID1,ID2,ID3,ID4,ID5,ID6,ID7,ID8,ID9,ID10,ID11,ID12,
-                  ID13,ID14,ID15,ID_UNUSED,ID_UNASSIGNED,ID_ASSIGNED,LEGACY,
-                  CLR_PRIORITY,NO_ID_AVAIL };
+enum scam_id_st { ID0, ID1, ID2, ID3, ID4, ID5, ID6, ID7, ID8, ID9, ID10, ID11,
+	    ID12,
+	ID13, ID14, ID15, ID_UNUSED, ID_UNASSIGNED, ID_ASSIGNED, LEGACY,
+	CLR_PRIORITY, NO_ID_AVAIL
+};
 
 typedef struct SCCBscam_info {
 
-   unsigned char    id_string[ID_STRING_LENGTH];
-   enum scam_id_st state;
-    
-} SCCBSCAM_INFO;
+	unsigned char id_string[ID_STRING_LENGTH];
+	enum scam_id_st state;
 
+} SCCBSCAM_INFO;
 
 #define  SCSI_REQUEST_SENSE      0x03
 #define  SCSI_READ               0x08
@@ -377,15 +310,10 @@ typedef struct SCCBscam_info {
 #define  SCSI_WRITE_EXTENDED     0x2A
 #define  SCSI_WRITE_AND_VERIFY   0x2E
 
-
-
 #define  SSGOOD                  0x00
 #define  SSCHECK                 0x02
 #define  SSQ_FULL                0x28
 
-
-
-
 #define  SMCMD_COMP              0x00
 #define  SMEXT                   0x01
 #define  SMSAVE_DATA_PTR         0x02
@@ -403,26 +331,17 @@ typedef struct SCCBscam_info {
 #define  SMIDENT                 0x80
 #define  DISC_PRIV               0x40
 
-
 #define  SMSYNC                  0x01
 #define  SMWDTR                  0x03
 #define  SM8BIT                  0x00
 #define  SM16BIT                 0x01
-#define  SMIGNORWR               0x23     /* Ignore Wide Residue */
-
-
-
-
-
-
-
+#define  SMIGNORWR               0x23	/* Ignore Wide Residue */
 
 #define  SIX_BYTE_CMD            0x06
 #define  TWELVE_BYTE_CMD         0x0C
 
 #define  ASYNC                   0x00
-#define  MAX_OFFSET              0x0F  /* Maxbyteoffset for Sync Xfers */
-
+#define  MAX_OFFSET              0x0F	/* Maxbyteoffset for Sync Xfers */
 
 #define  EEPROM_WD_CNT     256
 
@@ -437,7 +356,6 @@ typedef struct SCCBscam_info {
 #define  SCAM_CONFIG       20
 #define  ADAPTER_SCSI_ID   24
 
-
 #define  IGNORE_B_SCAN     32
 #define  SEND_START_ENA    34
 #define  DEVICE_ENABLE     36
@@ -452,478 +370,385 @@ typedef struct SCCBscam_info {
 #define  SYNC_RATE_TBLcd   50
 #define  SYNC_RATE_TBLef   52
 
+#define  EE_SCAMBASE      256
 
+#define  SCAM_ENABLED   BIT(2)
+#define  SCAM_LEVEL2    BIT(3)
 
-#define  EE_SCAMBASE      256 
-
-
-
-   #define  SCAM_ENABLED   BIT(2)
-   #define  SCAM_LEVEL2    BIT(3)
-
-
-	#define	RENEGO_ENA		BITW(10)
-	#define	CONNIO_ENA		BITW(11)
-   #define  GREEN_PC_ENA   BITW(12)
+#define	RENEGO_ENA		BITW(10)
+#define	CONNIO_ENA		BITW(11)
+#define  GREEN_PC_ENA   BITW(12)
 
+#define  AUTO_RATE_00   00
+#define  AUTO_RATE_05   01
+#define  AUTO_RATE_10   02
+#define  AUTO_RATE_20   03
 
-   #define  AUTO_RATE_00   00
-   #define  AUTO_RATE_05   01
-   #define  AUTO_RATE_10   02
-   #define  AUTO_RATE_20   03
+#define  WIDE_NEGO_BIT     BIT(7)
+#define  DISC_ENABLE_BIT   BIT(6)
 
-   #define  WIDE_NEGO_BIT     BIT(7)
-   #define  DISC_ENABLE_BIT   BIT(6)
+#define  hp_vendor_id_0       0x00	/* LSB */
+#define  ORION_VEND_0   0x4B
 
+#define  hp_vendor_id_1       0x01	/* MSB */
+#define  ORION_VEND_1   0x10
 
+#define  hp_device_id_0       0x02	/* LSB */
+#define  ORION_DEV_0    0x30
 
-   #define  hp_vendor_id_0       0x00		/* LSB */
-      #define  ORION_VEND_0   0x4B
- 
-   #define  hp_vendor_id_1       0x01		/* MSB */
-      #define  ORION_VEND_1   0x10
-
-   #define  hp_device_id_0       0x02		/* LSB */
-      #define  ORION_DEV_0    0x30 
-
-   #define  hp_device_id_1       0x03		/* MSB */
-      #define  ORION_DEV_1    0x81 
+#define  hp_device_id_1       0x03	/* MSB */
+#define  ORION_DEV_1    0x81
 
 	/* Sub Vendor ID and Sub Device ID only available in
-		Harpoon Version 2 and higher */
-
-   #define  hp_sub_device_id_0   0x06		/* LSB */
-
-
-
-   #define  hp_semaphore         0x0C
-      #define SCCB_MGR_ACTIVE    BIT(0)
-      #define TICKLE_ME          BIT(1)
-      #define SCCB_MGR_PRESENT   BIT(3)
-      #define BIOS_IN_USE        BIT(4)
-
-
-
-   #define  hp_sys_ctrl          0x0F
-
-      #define  STOP_CLK          BIT(0)      /*Turn off BusMaster Clock */
-      #define  DRVR_RST          BIT(1)      /*Firmware Reset to 80C15 chip */
-      #define  HALT_MACH         BIT(3)      /*Halt State Machine      */
-      #define  HARD_ABORT        BIT(4)      /*Hard Abort              */
-
-
-
-
-
-
-
-
-
-   #define  hp_host_blk_cnt      0x13
-
-      #define  XFER_BLK64        0x06     /*     1 1 0 64 byte per block*/
-   
-      #define  BM_THRESHOLD      0x40     /* PCI mode can only xfer 16 bytes*/
-
+	   Harpoon Version 2 and higher */
 
+#define  hp_sub_device_id_0   0x06	/* LSB */
 
-   #define  hp_int_mask          0x17
+#define  hp_semaphore         0x0C
+#define SCCB_MGR_ACTIVE    BIT(0)
+#define TICKLE_ME          BIT(1)
+#define SCCB_MGR_PRESENT   BIT(3)
+#define BIOS_IN_USE        BIT(4)
 
-      #define  INT_CMD_COMPL     BIT(0)   /* DMA command complete   */
-      #define  INT_EXT_STATUS    BIT(1)   /* Extended Status Set    */
+#define  hp_sys_ctrl          0x0F
 
+#define  STOP_CLK          BIT(0)	/*Turn off BusMaster Clock */
+#define  DRVR_RST          BIT(1)	/*Firmware Reset to 80C15 chip */
+#define  HALT_MACH         BIT(3)	/*Halt State Machine      */
+#define  HARD_ABORT        BIT(4)	/*Hard Abort              */
 
-   #define  hp_xfer_cnt_lo       0x18
-   #define  hp_xfer_cnt_hi       0x1A
-   #define  hp_xfer_cmd          0x1B
+#define  hp_host_blk_cnt      0x13
 
-      #define  XFER_HOST_DMA     0x00     /*     0 0 0 Transfer Host -> DMA */
-      #define  XFER_DMA_HOST     0x01     /*     0 0 1 Transfer DMA  -> Host */
+#define  XFER_BLK64        0x06	/*     1 1 0 64 byte per block */
 
+#define  BM_THRESHOLD      0x40	/* PCI mode can only xfer 16 bytes */
 
-      #define  XFER_HOST_AUTO    0x00     /*     0 0 Auto Transfer Size   */
+#define  hp_int_mask          0x17
 
-      #define  XFER_DMA_8BIT     0x20     /*     0 1 8 BIT  Transfer Size */
+#define  INT_CMD_COMPL     BIT(0)	/* DMA command complete   */
+#define  INT_EXT_STATUS    BIT(1)	/* Extended Status Set    */
 
-      #define  DISABLE_INT       BIT(7)   /*Do not interrupt at end of cmd. */
+#define  hp_xfer_cnt_lo       0x18
+#define  hp_xfer_cnt_hi       0x1A
+#define  hp_xfer_cmd          0x1B
 
-      #define  HOST_WRT_CMD      ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_8BIT))
-      #define  HOST_RD_CMD       ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_8BIT))
+#define  XFER_HOST_DMA     0x00	/*     0 0 0 Transfer Host -> DMA */
+#define  XFER_DMA_HOST     0x01	/*     0 0 1 Transfer DMA  -> Host */
 
-   #define  hp_host_addr_lo      0x1C
-   #define  hp_host_addr_hmi     0x1E
+#define  XFER_HOST_AUTO    0x00	/*     0 0 Auto Transfer Size   */
 
-   #define  hp_ee_ctrl           0x22
+#define  XFER_DMA_8BIT     0x20	/*     0 1 8 BIT  Transfer Size */
 
-      #define  EXT_ARB_ACK       BIT(7)
-      #define  SCSI_TERM_ENA_H   BIT(6)   /* SCSI high byte terminator */
-      #define  SEE_MS            BIT(5)
-      #define  SEE_CS            BIT(3)
-      #define  SEE_CLK           BIT(2)
-      #define  SEE_DO            BIT(1)
-      #define  SEE_DI            BIT(0)
+#define  DISABLE_INT       BIT(7)	/*Do not interrupt at end of cmd. */
 
-      #define  EE_READ           0x06
-      #define  EE_WRITE          0x05
-      #define  EWEN              0x04
-      #define  EWEN_ADDR         0x03C0
-      #define  EWDS              0x04
-      #define  EWDS_ADDR         0x0000
+#define  HOST_WRT_CMD      ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_8BIT))
+#define  HOST_RD_CMD       ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_8BIT))
 
+#define  hp_host_addr_lo      0x1C
+#define  hp_host_addr_hmi     0x1E
 
+#define  hp_ee_ctrl           0x22
 
+#define  EXT_ARB_ACK       BIT(7)
+#define  SCSI_TERM_ENA_H   BIT(6)	/* SCSI high byte terminator */
+#define  SEE_MS            BIT(5)
+#define  SEE_CS            BIT(3)
+#define  SEE_CLK           BIT(2)
+#define  SEE_DO            BIT(1)
+#define  SEE_DI            BIT(0)
 
+#define  EE_READ           0x06
+#define  EE_WRITE          0x05
+#define  EWEN              0x04
+#define  EWEN_ADDR         0x03C0
+#define  EWDS              0x04
+#define  EWDS_ADDR         0x0000
 
+#define  hp_bm_ctrl           0x26
 
+#define  SCSI_TERM_ENA_L   BIT(0)	/*Enable/Disable external terminators */
+#define  FLUSH_XFER_CNTR   BIT(1)	/*Flush transfer counter */
+#define  FORCE1_XFER       BIT(5)	/*Always xfer one byte in byte mode */
+#define  FAST_SINGLE       BIT(6)	/*?? */
 
-   #define  hp_bm_ctrl           0x26
+#define  BMCTRL_DEFAULT    (FORCE1_XFER|FAST_SINGLE|SCSI_TERM_ENA_L)
 
-      #define  SCSI_TERM_ENA_L   BIT(0)   /*Enable/Disable external terminators */
-      #define  FLUSH_XFER_CNTR   BIT(1)   /*Flush transfer counter */
-      #define  FORCE1_XFER       BIT(5)   /*Always xfer one byte in byte mode */
-      #define  FAST_SINGLE       BIT(6)   /*?? */
+#define  hp_sg_addr           0x28
+#define  hp_page_ctrl         0x29
 
-      #define  BMCTRL_DEFAULT    (FORCE1_XFER|FAST_SINGLE|SCSI_TERM_ENA_L)
+#define  SCATTER_EN        BIT(0)
+#define  SGRAM_ARAM        BIT(1)
+#define  G_INT_DISABLE     BIT(3)	/* Enable/Disable all Interrupts */
+#define  NARROW_SCSI_CARD  BIT(4)	/* NARROW/WIDE SCSI config pin */
 
+#define  hp_pci_stat_cfg      0x2D
 
-   #define  hp_sg_addr           0x28
-   #define  hp_page_ctrl         0x29
+#define  REC_MASTER_ABORT  BIT(5)	/*received Master abort */
 
-      #define  SCATTER_EN        BIT(0)   
-      #define  SGRAM_ARAM        BIT(1)   
-      #define  G_INT_DISABLE     BIT(3)   /* Enable/Disable all Interrupts */
-      #define  NARROW_SCSI_CARD  BIT(4)   /* NARROW/WIDE SCSI config pin */
+#define  hp_rev_num           0x33
 
+#define  hp_stack_data        0x34
+#define  hp_stack_addr        0x35
 
+#define  hp_ext_status        0x36
 
-
-   #define  hp_pci_stat_cfg      0x2D
-
-      #define  REC_MASTER_ABORT  BIT(5)   /*received Master abort */
-
-
-
-
-
-
-
-
-   #define  hp_rev_num           0x33
-
-
-   #define  hp_stack_data        0x34
-   #define  hp_stack_addr        0x35
-
-   #define  hp_ext_status        0x36
-
-      #define  BM_FORCE_OFF      BIT(0)   /*Bus Master is forced to get off */
-      #define  PCI_TGT_ABORT     BIT(0)   /*PCI bus master transaction aborted */
-      #define  PCI_DEV_TMOUT     BIT(1)   /*PCI Device Time out */
-      #define  CMD_ABORTED       BIT(4)   /*Command aborted */
-      #define  BM_PARITY_ERR     BIT(5)   /*parity error on data received   */
-      #define  PIO_OVERRUN       BIT(6)   /*Slave data overrun */
-      #define  BM_CMD_BUSY       BIT(7)   /*Bus master transfer command busy */
-      #define  BAD_EXT_STATUS    (BM_FORCE_OFF | PCI_DEV_TMOUT | CMD_ABORTED | \
+#define  BM_FORCE_OFF      BIT(0)	/*Bus Master is forced to get off */
+#define  PCI_TGT_ABORT     BIT(0)	/*PCI bus master transaction aborted */
+#define  PCI_DEV_TMOUT     BIT(1)	/*PCI Device Time out */
+#define  CMD_ABORTED       BIT(4)	/*Command aborted */
+#define  BM_PARITY_ERR     BIT(5)	/*parity error on data received   */
+#define  PIO_OVERRUN       BIT(6)	/*Slave data overrun */
+#define  BM_CMD_BUSY       BIT(7)	/*Bus master transfer command busy */
+#define  BAD_EXT_STATUS    (BM_FORCE_OFF | PCI_DEV_TMOUT | CMD_ABORTED | \
                                   BM_PARITY_ERR | PIO_OVERRUN)
 
-   #define  hp_int_status        0x37
-      
-      #define  EXT_STATUS_ON     BIT(1)   /*Extended status is valid */
-      #define  SCSI_INTERRUPT    BIT(2)   /*Global indication of a SCSI int. */
-      #define  INT_ASSERTED      BIT(5)   /* */
-
-
-   #define  hp_fifo_cnt          0x38
-
-
-
-
-   #define  hp_intena		 0x40
-
-      #define  RESET		 BITW(7)
-      #define  PROG_HLT		 BITW(6)  
-      #define  PARITY		 BITW(5)
-      #define  FIFO		 BITW(4)
-      #define  SEL		 BITW(3)
-      #define  SCAM_SEL		 BITW(2) 
-      #define  RSEL		 BITW(1)
-      #define  TIMEOUT		 BITW(0)
-      #define  BUS_FREE		 BITW(15)
-      #define  XFER_CNT_0	 BITW(14)
-      #define  PHASE		 BITW(13)
-      #define  IUNKWN		 BITW(12)
-      #define  ICMD_COMP	 BITW(11)
-      #define  ITICKLE		 BITW(10)
-      #define  IDO_STRT		 BITW(9)
-      #define  ITAR_DISC	 BITW(8)
-      #define  AUTO_INT		 (BITW(12)+BITW(11)+BITW(10)+BITW(9)+BITW(8))
-      #define  CLR_ALL_INT	 0xFFFF
-      #define  CLR_ALL_INT_1	 0xFF00
-
-   #define  hp_intstat		 0x42
-
-   #define  hp_scsisig           0x44
-
-      #define  SCSI_SEL          BIT(7)
-      #define  SCSI_BSY          BIT(6)
-      #define  SCSI_REQ          BIT(5)
-      #define  SCSI_ACK          BIT(4)
-      #define  SCSI_ATN          BIT(3)
-      #define  SCSI_CD           BIT(2)
-      #define  SCSI_MSG          BIT(1)
-      #define  SCSI_IOBIT        BIT(0)
-
-      #define  S_SCSI_PHZ        (BIT(2)+BIT(1)+BIT(0))
-      #define  S_MSGO_PH         (BIT(2)+BIT(1)       )
-      #define  S_MSGI_PH         (BIT(2)+BIT(1)+BIT(0))
-      #define  S_DATAI_PH        (              BIT(0))
-      #define  S_DATAO_PH        0x00
-      #define  S_ILL_PH          (       BIT(1)       )
-
-   #define  hp_scsictrl_0        0x45
-
-      #define  SEL_TAR           BIT(6)
-      #define  ENA_ATN           BIT(4)
-      #define  ENA_RESEL         BIT(2)
-      #define  SCSI_RST          BIT(1)
-      #define  ENA_SCAM_SEL      BIT(0)
-
-
-
-   #define  hp_portctrl_0        0x46
-
-      #define  SCSI_PORT         BIT(7)
-      #define  SCSI_INBIT        BIT(6)
-      #define  DMA_PORT          BIT(5)
-      #define  DMA_RD            BIT(4)
-      #define  HOST_PORT         BIT(3)
-      #define  HOST_WRT          BIT(2)
-      #define  SCSI_BUS_EN       BIT(1)
-      #define  START_TO          BIT(0)
-
-   #define  hp_scsireset         0x47
-
-      #define  SCSI_INI          BIT(6)
-      #define  SCAM_EN           BIT(5)
-      #define  DMA_RESET         BIT(3)
-      #define  HPSCSI_RESET      BIT(2)
-      #define  PROG_RESET        BIT(1)
-      #define  FIFO_CLR          BIT(0)
-
-   #define  hp_xfercnt_0         0x48
-   #define  hp_xfercnt_2         0x4A
-
-   #define  hp_fifodata_0        0x4C
-   #define  hp_addstat           0x4E
-
-      #define  SCAM_TIMER        BIT(7)
-      #define  SCSI_MODE8        BIT(3)
-      #define  SCSI_PAR_ERR      BIT(0)
-
-   #define  hp_prgmcnt_0         0x4F
-
-
-   #define  hp_selfid_0          0x50
-   #define  hp_selfid_1          0x51
-   #define  hp_arb_id            0x52
-
-
-   #define  hp_select_id         0x53
-
-
-   #define  hp_synctarg_base     0x54
-   #define  hp_synctarg_12       0x54
-   #define  hp_synctarg_13       0x55
-   #define  hp_synctarg_14       0x56
-   #define  hp_synctarg_15       0x57
-
-   #define  hp_synctarg_8        0x58
-   #define  hp_synctarg_9        0x59
-   #define  hp_synctarg_10       0x5A
-   #define  hp_synctarg_11       0x5B
-
-   #define  hp_synctarg_4        0x5C
-   #define  hp_synctarg_5        0x5D
-   #define  hp_synctarg_6        0x5E
-   #define  hp_synctarg_7        0x5F
-
-   #define  hp_synctarg_0        0x60
-   #define  hp_synctarg_1        0x61
-   #define  hp_synctarg_2        0x62
-   #define  hp_synctarg_3        0x63
-
-      #define  NARROW_SCSI       BIT(4)
-      #define  DEFAULT_OFFSET    0x0F
-
-   #define  hp_autostart_0       0x64
-   #define  hp_autostart_1       0x65
-   #define  hp_autostart_3       0x67
-
-
-
-      #define  AUTO_IMMED    BIT(5)
-      #define  SELECT   BIT(6)
-      #define  END_DATA (BIT(7)+BIT(6))
-
-   #define  hp_gp_reg_0          0x68
-   #define  hp_gp_reg_1          0x69
-   #define  hp_gp_reg_3          0x6B
-
-   #define  hp_seltimeout        0x6C
-
-
-      #define  TO_4ms            0x67      /* 3.9959ms */
-
-      #define  TO_5ms            0x03      /* 4.9152ms */
-      #define  TO_10ms           0x07      /* 11.xxxms */
-      #define  TO_250ms          0x99      /* 250.68ms */
-      #define  TO_290ms          0xB1      /* 289.99ms */
+#define  hp_int_status        0x37
+
+#define  EXT_STATUS_ON     BIT(1)	/*Extended status is valid */
+#define  SCSI_INTERRUPT    BIT(2)	/*Global indication of a SCSI int. */
+#define  INT_ASSERTED      BIT(5)	/* */
+
+#define  hp_fifo_cnt          0x38
+
+#define  hp_intena		 0x40
+
+#define  RESET		 BITW(7)
+#define  PROG_HLT		 BITW(6)
+#define  PARITY		 BITW(5)
+#define  FIFO		 BITW(4)
+#define  SEL		 BITW(3)
+#define  SCAM_SEL		 BITW(2)
+#define  RSEL		 BITW(1)
+#define  TIMEOUT		 BITW(0)
+#define  BUS_FREE		 BITW(15)
+#define  XFER_CNT_0	 BITW(14)
+#define  PHASE		 BITW(13)
+#define  IUNKWN		 BITW(12)
+#define  ICMD_COMP	 BITW(11)
+#define  ITICKLE		 BITW(10)
+#define  IDO_STRT		 BITW(9)
+#define  ITAR_DISC	 BITW(8)
+#define  AUTO_INT		 (BITW(12)+BITW(11)+BITW(10)+BITW(9)+BITW(8))
+#define  CLR_ALL_INT	 0xFFFF
+#define  CLR_ALL_INT_1	 0xFF00
+
+#define  hp_intstat		 0x42
+
+#define  hp_scsisig           0x44
+
+#define  SCSI_SEL          BIT(7)
+#define  SCSI_BSY          BIT(6)
+#define  SCSI_REQ          BIT(5)
+#define  SCSI_ACK          BIT(4)
+#define  SCSI_ATN          BIT(3)
+#define  SCSI_CD           BIT(2)
+#define  SCSI_MSG          BIT(1)
+#define  SCSI_IOBIT        BIT(0)
+
+#define  S_SCSI_PHZ        (BIT(2)+BIT(1)+BIT(0))
+#define  S_MSGO_PH         (BIT(2)+BIT(1)       )
+#define  S_MSGI_PH         (BIT(2)+BIT(1)+BIT(0))
+#define  S_DATAI_PH        (              BIT(0))
+#define  S_DATAO_PH        0x00
+#define  S_ILL_PH          (       BIT(1)       )
+
+#define  hp_scsictrl_0        0x45
+
+#define  SEL_TAR           BIT(6)
+#define  ENA_ATN           BIT(4)
+#define  ENA_RESEL         BIT(2)
+#define  SCSI_RST          BIT(1)
+#define  ENA_SCAM_SEL      BIT(0)
 
-   #define  hp_clkctrl_0         0x6D
+#define  hp_portctrl_0        0x46
 
-      #define  PWR_DWN           BIT(6)
-      #define  ACTdeassert       BIT(4)
-      #define  CLK_40MHZ         (BIT(1) + BIT(0))
+#define  SCSI_PORT         BIT(7)
+#define  SCSI_INBIT        BIT(6)
+#define  DMA_PORT          BIT(5)
+#define  DMA_RD            BIT(4)
+#define  HOST_PORT         BIT(3)
+#define  HOST_WRT          BIT(2)
+#define  SCSI_BUS_EN       BIT(1)
+#define  START_TO          BIT(0)
 
-      #define  CLKCTRL_DEFAULT   (ACTdeassert | CLK_40MHZ)
+#define  hp_scsireset         0x47
 
-   #define  hp_fiforead          0x6E
-   #define  hp_fifowrite         0x6F
+#define  SCSI_INI          BIT(6)
+#define  SCAM_EN           BIT(5)
+#define  DMA_RESET         BIT(3)
+#define  HPSCSI_RESET      BIT(2)
+#define  PROG_RESET        BIT(1)
+#define  FIFO_CLR          BIT(0)
 
-   #define  hp_offsetctr         0x70
-   #define  hp_xferstat          0x71
+#define  hp_xfercnt_0         0x48
+#define  hp_xfercnt_2         0x4A
 
-      #define  FIFO_EMPTY        BIT(6)
+#define  hp_fifodata_0        0x4C
+#define  hp_addstat           0x4E
 
-   #define  hp_portctrl_1        0x72
+#define  SCAM_TIMER        BIT(7)
+#define  SCSI_MODE8        BIT(3)
+#define  SCSI_PAR_ERR      BIT(0)
 
-      #define  CHK_SCSI_P        BIT(3)
-      #define  HOST_MODE8        BIT(0)
+#define  hp_prgmcnt_0         0x4F
 
-   #define  hp_xfer_pad          0x73
+#define  hp_selfid_0          0x50
+#define  hp_selfid_1          0x51
+#define  hp_arb_id            0x52
 
-      #define  ID_UNLOCK         BIT(3)
+#define  hp_select_id         0x53
 
-   #define  hp_scsidata_0        0x74
-   #define  hp_scsidata_1        0x75
+#define  hp_synctarg_base     0x54
+#define  hp_synctarg_12       0x54
+#define  hp_synctarg_13       0x55
+#define  hp_synctarg_14       0x56
+#define  hp_synctarg_15       0x57
 
+#define  hp_synctarg_8        0x58
+#define  hp_synctarg_9        0x59
+#define  hp_synctarg_10       0x5A
+#define  hp_synctarg_11       0x5B
 
+#define  hp_synctarg_4        0x5C
+#define  hp_synctarg_5        0x5D
+#define  hp_synctarg_6        0x5E
+#define  hp_synctarg_7        0x5F
 
-   #define  hp_aramBase          0x80
-   #define  BIOS_DATA_OFFSET     0x60
-   #define  BIOS_RELATIVE_CARD   0x64
+#define  hp_synctarg_0        0x60
+#define  hp_synctarg_1        0x61
+#define  hp_synctarg_2        0x62
+#define  hp_synctarg_3        0x63
 
+#define  NARROW_SCSI       BIT(4)
+#define  DEFAULT_OFFSET    0x0F
 
+#define  hp_autostart_0       0x64
+#define  hp_autostart_1       0x65
+#define  hp_autostart_3       0x67
 
+#define  AUTO_IMMED    BIT(5)
+#define  SELECT   BIT(6)
+#define  END_DATA (BIT(7)+BIT(6))
 
-      #define  AR3      (BITW(9) + BITW(8))
-      #define  SDATA    BITW(10)
+#define  hp_gp_reg_0          0x68
+#define  hp_gp_reg_1          0x69
+#define  hp_gp_reg_3          0x6B
 
+#define  hp_seltimeout        0x6C
 
-      #define  CRD_OP   BITW(11)     /* Cmp Reg. w/ Data */
+#define  TO_4ms            0x67	/* 3.9959ms */
 
-      #define  CRR_OP   BITW(12)     /* Cmp Reg. w. Reg. */
+#define  TO_5ms            0x03	/* 4.9152ms */
+#define  TO_10ms           0x07	/* 11.xxxms */
+#define  TO_250ms          0x99	/* 250.68ms */
+#define  TO_290ms          0xB1	/* 289.99ms */
 
-      
-      
-      #define  CPE_OP   (BITW(14)+BITW(11))  /* Cmp SCSI phs & Branch EQ */
+#define  hp_clkctrl_0         0x6D
 
-      #define  CPN_OP   (BITW(14)+BITW(12))  /* Cmp SCSI phs & Branch NOT EQ */
+#define  PWR_DWN           BIT(6)
+#define  ACTdeassert       BIT(4)
+#define  CLK_40MHZ         (BIT(1) + BIT(0))
 
+#define  CLKCTRL_DEFAULT   (ACTdeassert | CLK_40MHZ)
 
-      #define  ADATA_OUT   0x00     
-      #define  ADATA_IN    BITW(8)
-      #define  ACOMMAND    BITW(10)
-      #define  ASTATUS     (BITW(10)+BITW(8))
-      #define  AMSG_OUT    (BITW(10)+BITW(9))
-      #define  AMSG_IN     (BITW(10)+BITW(9)+BITW(8))
+#define  hp_fiforead          0x6E
+#define  hp_fifowrite         0x6F
 
+#define  hp_offsetctr         0x70
+#define  hp_xferstat          0x71
 
-      #define  BRH_OP   BITW(13)   /* Branch */
+#define  FIFO_EMPTY        BIT(6)
 
-      
-      #define  ALWAYS   0x00
-      #define  EQUAL    BITW(8)
-      #define  NOT_EQ   BITW(9)
+#define  hp_portctrl_1        0x72
 
-      #define  TCB_OP   (BITW(13)+BITW(11))    /* Test condition & branch */
+#define  CHK_SCSI_P        BIT(3)
+#define  HOST_MODE8        BIT(0)
 
-      
-      #define  FIFO_0      BITW(10)
+#define  hp_xfer_pad          0x73
 
+#define  ID_UNLOCK         BIT(3)
 
-      #define  MPM_OP   BITW(15)        /* Match phase and move data */
+#define  hp_scsidata_0        0x74
+#define  hp_scsidata_1        0x75
 
+#define  hp_aramBase          0x80
+#define  BIOS_DATA_OFFSET     0x60
+#define  BIOS_RELATIVE_CARD   0x64
 
-      #define  MRR_OP   BITW(14)        /* Move DReg. to Reg. */
+#define  AR3      (BITW(9) + BITW(8))
+#define  SDATA    BITW(10)
 
+#define  CRD_OP   BITW(11)	/* Cmp Reg. w/ Data */
 
-      #define  S_IDREG  (BIT(2)+BIT(1)+BIT(0))
+#define  CRR_OP   BITW(12)	/* Cmp Reg. w. Reg. */
 
+#define  CPE_OP   (BITW(14)+BITW(11))	/* Cmp SCSI phs & Branch EQ */
 
-      #define  D_AR0    0x00
-      #define  D_AR1    BIT(0)
-      #define  D_BUCKET (BIT(2) + BIT(1) + BIT(0))
+#define  CPN_OP   (BITW(14)+BITW(12))	/* Cmp SCSI phs & Branch NOT EQ */
 
+#define  ADATA_OUT   0x00
+#define  ADATA_IN    BITW(8)
+#define  ACOMMAND    BITW(10)
+#define  ASTATUS     (BITW(10)+BITW(8))
+#define  AMSG_OUT    (BITW(10)+BITW(9))
+#define  AMSG_IN     (BITW(10)+BITW(9)+BITW(8))
 
+#define  BRH_OP   BITW(13)	/* Branch */
 
+#define  ALWAYS   0x00
+#define  EQUAL    BITW(8)
+#define  NOT_EQ   BITW(9)
 
+#define  TCB_OP   (BITW(13)+BITW(11))	/* Test condition & branch */
 
+#define  FIFO_0      BITW(10)
 
+#define  MPM_OP   BITW(15)	/* Match phase and move data */
 
+#define  MRR_OP   BITW(14)	/* Move DReg. to Reg. */
 
+#define  S_IDREG  (BIT(2)+BIT(1)+BIT(0))
 
-      #define  RAT_OP      (BITW(14)+BITW(13)+BITW(11))
-
-      #define  SSI_OP      (BITW(15)+BITW(11))
-
-
-      #define  SSI_ITAR_DISC	(ITAR_DISC >> 8)
-      #define  SSI_IDO_STRT	(IDO_STRT >> 8)
-
-      #define  SSI_ICMD_COMP	(ICMD_COMP >> 8)
-      #define  SSI_ITICKLE	(ITICKLE >> 8)
-
-      #define  SSI_IUNKWN	(IUNKWN >> 8)
-      #define  SSI_INO_CC	(IUNKWN >> 8)
-      #define  SSI_IRFAIL	(IUNKWN >> 8)
-
-
-      #define  NP    0x10     /*Next Phase */
-      #define  NTCMD 0x02     /*Non- Tagged Command start */
-      #define  CMDPZ 0x04     /*Command phase */
-      #define  DINT  0x12     /*Data Out/In interrupt */
-      #define  DI    0x13     /*Data Out */
-      #define  DC    0x19     /*Disconnect Message */
-      #define  ST    0x1D     /*Status Phase */
-      #define  UNKNWN 0x24    /*Unknown bus action */
-      #define  CC    0x25     /*Command Completion failure */
-      #define  TICK  0x26     /*New target reselected us. */
-      #define  SELCHK 0x28     /*Select & Check SCSI ID latch reg */
-
-
-      #define  ID_MSG_STRT    hp_aramBase + 0x00
-      #define  NON_TAG_ID_MSG hp_aramBase + 0x06
-      #define  CMD_STRT       hp_aramBase + 0x08
-      #define  SYNC_MSGS      hp_aramBase + 0x08
-
-
-
-
-
-      #define  TAG_STRT          0x00
-      #define  DISCONNECT_START  0x10/2
-      #define  END_DATA_START    0x14/2
-      #define  CMD_ONLY_STRT     CMDPZ/2
-      #define  SELCHK_STRT     SELCHK/2
+#define  D_AR0    0x00
+#define  D_AR1    BIT(0)
+#define  D_BUCKET (BIT(2) + BIT(1) + BIT(0))
 
+#define  RAT_OP      (BITW(14)+BITW(13)+BITW(11))
 
+#define  SSI_OP      (BITW(15)+BITW(11))
 
+#define  SSI_ITAR_DISC	(ITAR_DISC >> 8)
+#define  SSI_IDO_STRT	(IDO_STRT >> 8)
 
+#define  SSI_ICMD_COMP	(ICMD_COMP >> 8)
+#define  SSI_ITICKLE	(ITICKLE >> 8)
 
+#define  SSI_IUNKWN	(IUNKWN >> 8)
+#define  SSI_INO_CC	(IUNKWN >> 8)
+#define  SSI_IRFAIL	(IUNKWN >> 8)
 
+#define  NP    0x10		/*Next Phase */
+#define  NTCMD 0x02		/*Non- Tagged Command start */
+#define  CMDPZ 0x04		/*Command phase */
+#define  DINT  0x12		/*Data Out/In interrupt */
+#define  DI    0x13		/*Data Out */
+#define  DC    0x19		/*Disconnect Message */
+#define  ST    0x1D		/*Status Phase */
+#define  UNKNWN 0x24		/*Unknown bus action */
+#define  CC    0x25		/*Command Completion failure */
+#define  TICK  0x26		/*New target reselected us. */
+#define  SELCHK 0x28		/*Select & Check SCSI ID latch reg */
 
+#define  ID_MSG_STRT    hp_aramBase + 0x00
+#define  NON_TAG_ID_MSG hp_aramBase + 0x06
+#define  CMD_STRT       hp_aramBase + 0x08
+#define  SYNC_MSGS      hp_aramBase + 0x08
 
+#define  TAG_STRT          0x00
+#define  DISCONNECT_START  0x10/2
+#define  END_DATA_START    0x14/2
+#define  CMD_ONLY_STRT     CMDPZ/2
+#define  SELCHK_STRT     SELCHK/2
 
 #define GET_XFER_CNT(port, xfercnt) {RD_HARP32(port,hp_xfercnt_0,xfercnt); xfercnt &= 0xFFFFFF;}
 /* #define GET_XFER_CNT(port, xfercnt) (xfercnt = RD_HARPOON(port+hp_xfercnt_2), \
@@ -941,12 +766,9 @@ typedef struct SCCBscam_info {
 #define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
                           WR_HARPOON(port+hp_scsisig, S_ILL_PH);}
 
-
 #define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
                           WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}
 
-
-
 #define DISABLE_AUTO(port) (WR_HARPOON(port+hp_scsireset, PROG_RESET),\
                         WR_HARPOON(port+hp_scsireset, 0x00))
 
@@ -962,139 +784,146 @@ typedef struct SCCBscam_info {
 #define MENABLE_INT(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \
                              (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE)))
 
-
-
-
-static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag);
-static void  FPT_ssel(unsigned long port, unsigned char p_card);
-static void  FPT_sres(unsigned long port, unsigned char p_card, struct sccb_card * pCurrCard);
-static void  FPT_shandem(unsigned long port, unsigned char p_card,struct sccb * pCurrSCCB);
-static void  FPT_stsyncn(unsigned long port, unsigned char p_card);
-static void  FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset);
-static void  FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
-			 struct sccb_mgr_tar_info * currTar_Info);
-static void  FPT_sresb(unsigned long port, unsigned char p_card);
-static void  FPT_sxfrp(unsigned long p_port, unsigned char p_card);
-static void  FPT_schkdd(unsigned long port, unsigned char p_card);
+static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card,
+				 unsigned char syncFlag);
+static void FPT_ssel(unsigned long port, unsigned char p_card);
+static void FPT_sres(unsigned long port, unsigned char p_card,
+		     struct sccb_card *pCurrCard);
+static void FPT_shandem(unsigned long port, unsigned char p_card,
+			struct sccb *pCurrSCCB);
+static void FPT_stsyncn(unsigned long port, unsigned char p_card);
+static void FPT_sisyncr(unsigned long port, unsigned char sync_pulse,
+			unsigned char offset);
+static void FPT_sssyncv(unsigned long p_port, unsigned char p_id,
+			unsigned char p_sync_value,
+			struct sccb_mgr_tar_info *currTar_Info);
+static void FPT_sresb(unsigned long port, unsigned char p_card);
+static void FPT_sxfrp(unsigned long p_port, unsigned char p_card);
+static void FPT_schkdd(unsigned long port, unsigned char p_card);
 static unsigned char FPT_RdStack(unsigned long port, unsigned char index);
-static void  FPT_WrStack(unsigned long portBase, unsigned char index, unsigned char data);
+static void FPT_WrStack(unsigned long portBase, unsigned char index,
+			unsigned char data);
 static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort);
 
 static void FPT_SendMsg(unsigned long port, unsigned char message);
-static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
-				    unsigned char error_code);
+static void FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
+				   unsigned char error_code);
 
-static void  FPT_sinits(struct sccb * p_sccb, unsigned char p_card);
-static void  FPT_RNVRamData(struct nvram_info * pNvRamInfo);
+static void FPT_sinits(struct sccb *p_sccb, unsigned char p_card);
+static void FPT_RNVRamData(struct nvram_info *pNvRamInfo);
 
 static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card);
-static void  FPT_stwidn(unsigned long port, unsigned char p_card);
-static void  FPT_siwidr(unsigned long port, unsigned char width);
-
-
-static void  FPT_queueSelectFail(struct sccb_card * pCurrCard, unsigned char p_card);
-static void  FPT_queueDisconnect(struct sccb * p_SCCB, unsigned char p_card);
-static void  FPT_queueCmdComplete(struct sccb_card * pCurrCard, struct sccb * p_SCCB,
+static void FPT_stwidn(unsigned long port, unsigned char p_card);
+static void FPT_siwidr(unsigned long port, unsigned char width);
+
+static void FPT_queueSelectFail(struct sccb_card *pCurrCard,
+				unsigned char p_card);
+static void FPT_queueDisconnect(struct sccb *p_SCCB, unsigned char p_card);
+static void FPT_queueCmdComplete(struct sccb_card *pCurrCard,
+				 struct sccb *p_SCCB, unsigned char p_card);
+static void FPT_queueSearchSelect(struct sccb_card *pCurrCard,
 				  unsigned char p_card);
-static void  FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_card);
-static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);
-static void  FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char card);
-static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_card);
-static void  FPT_utilUpdateResidual(struct sccb * p_SCCB);
+static void FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);
+static void FPT_queueAddSccb(struct sccb *p_SCCB, unsigned char card);
+static unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,
+				       unsigned char p_card);
+static void FPT_utilUpdateResidual(struct sccb *p_SCCB);
 static unsigned short FPT_CalcCrc16(unsigned char buffer[]);
-static unsigned char  FPT_CalcLrc(unsigned char buffer[]);
-
-
-static void  FPT_Wait1Second(unsigned long p_port);
-static void  FPT_Wait(unsigned long p_port, unsigned char p_delay);
-static void  FPT_utilEEWriteOnOff(unsigned long p_port,unsigned char p_mode);
-static void  FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data, unsigned short ee_addr);
-static unsigned short FPT_utilEERead(unsigned long p_port, unsigned short ee_addr);
-static unsigned short FPT_utilEEReadOrg(unsigned long p_port, unsigned short ee_addr);
-static void  FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd, unsigned short ee_addr);
-
-
-
-static void  FPT_phaseDataOut(unsigned long port, unsigned char p_card);
-static void  FPT_phaseDataIn(unsigned long port, unsigned char p_card);
-static void  FPT_phaseCommand(unsigned long port, unsigned char p_card);
-static void  FPT_phaseStatus(unsigned long port, unsigned char p_card);
-static void  FPT_phaseMsgOut(unsigned long port, unsigned char p_card);
-static void  FPT_phaseMsgIn(unsigned long port, unsigned char p_card);
-static void  FPT_phaseIllegal(unsigned long port, unsigned char p_card);
-
-static void  FPT_phaseDecode(unsigned long port, unsigned char p_card);
-static void  FPT_phaseChkFifo(unsigned long port, unsigned char p_card);
-static void  FPT_phaseBusFree(unsigned long p_port, unsigned char p_card);
-
-
-
-
-static void  FPT_XbowInit(unsigned long port, unsigned char scamFlg);
-static void  FPT_BusMasterInit(unsigned long p_port);
-static void  FPT_DiagEEPROM(unsigned long p_port);
-
-
-
-
-static void  FPT_dataXferProcessor(unsigned long port, struct sccb_card * pCurrCard);
-static void  FPT_busMstrSGDataXferStart(unsigned long port, struct sccb * pCurrSCCB);
-static void  FPT_busMstrDataXferStart(unsigned long port, struct sccb * pCurrSCCB);
-static void  FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB);
-static void  FPT_hostDataXferRestart(struct sccb * currSCCB);
-
-
-static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
-				 struct sccb_card * pCurrCard, unsigned short p_int);
-
-static void  FPT_SccbMgrTableInitAll(void);
-static void  FPT_SccbMgrTableInitCard(struct sccb_card * pCurrCard, unsigned char p_card);
-static void  FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char target);
-
-
-
-static void  FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned char p_power_up);
-
-static int   FPT_scarb(unsigned long p_port, unsigned char p_sel_type);
-static void  FPT_scbusf(unsigned long p_port);
-static void  FPT_scsel(unsigned long p_port);
-static void  FPT_scasid(unsigned char p_card, unsigned long p_port);
+static unsigned char FPT_CalcLrc(unsigned char buffer[]);
+
+static void FPT_Wait1Second(unsigned long p_port);
+static void FPT_Wait(unsigned long p_port, unsigned char p_delay);
+static void FPT_utilEEWriteOnOff(unsigned long p_port, unsigned char p_mode);
+static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data,
+			    unsigned short ee_addr);
+static unsigned short FPT_utilEERead(unsigned long p_port,
+				     unsigned short ee_addr);
+static unsigned short FPT_utilEEReadOrg(unsigned long p_port,
+					unsigned short ee_addr);
+static void FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd,
+				  unsigned short ee_addr);
+
+static void FPT_phaseDataOut(unsigned long port, unsigned char p_card);
+static void FPT_phaseDataIn(unsigned long port, unsigned char p_card);
+static void FPT_phaseCommand(unsigned long port, unsigned char p_card);
+static void FPT_phaseStatus(unsigned long port, unsigned char p_card);
+static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card);
+static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card);
+static void FPT_phaseIllegal(unsigned long port, unsigned char p_card);
+
+static void FPT_phaseDecode(unsigned long port, unsigned char p_card);
+static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card);
+static void FPT_phaseBusFree(unsigned long p_port, unsigned char p_card);
+
+static void FPT_XbowInit(unsigned long port, unsigned char scamFlg);
+static void FPT_BusMasterInit(unsigned long p_port);
+static void FPT_DiagEEPROM(unsigned long p_port);
+
+static void FPT_dataXferProcessor(unsigned long port,
+				  struct sccb_card *pCurrCard);
+static void FPT_busMstrSGDataXferStart(unsigned long port,
+				       struct sccb *pCurrSCCB);
+static void FPT_busMstrDataXferStart(unsigned long port,
+				     struct sccb *pCurrSCCB);
+static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
+				  struct sccb *pCurrSCCB);
+static void FPT_hostDataXferRestart(struct sccb *currSCCB);
+
+static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port,
+					 unsigned char p_card,
+					 struct sccb_card *pCurrCard,
+					 unsigned short p_int);
+
+static void FPT_SccbMgrTableInitAll(void);
+static void FPT_SccbMgrTableInitCard(struct sccb_card *pCurrCard,
+				     unsigned char p_card);
+static void FPT_SccbMgrTableInitTarget(unsigned char p_card,
+				       unsigned char target);
+
+static void FPT_scini(unsigned char p_card, unsigned char p_our_id,
+		      unsigned char p_power_up);
+
+static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type);
+static void FPT_scbusf(unsigned long p_port);
+static void FPT_scsel(unsigned long p_port);
+static void FPT_scasid(unsigned char p_card, unsigned long p_port);
 static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data);
-static unsigned char FPT_scsendi(unsigned long p_port, unsigned char p_id_string[]);
-static unsigned char FPT_sciso(unsigned long p_port, unsigned char p_id_string[]);
-static void  FPT_scwirod(unsigned long p_port, unsigned char p_data_bit);
-static void  FPT_scwiros(unsigned long p_port, unsigned char p_data_bit);
+static unsigned char FPT_scsendi(unsigned long p_port,
+				 unsigned char p_id_string[]);
+static unsigned char FPT_sciso(unsigned long p_port,
+			       unsigned char p_id_string[]);
+static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit);
+static void FPT_scwiros(unsigned long p_port, unsigned char p_data_bit);
 static unsigned char FPT_scvalq(unsigned char p_quintet);
 static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id);
-static void  FPT_scwtsel(unsigned long p_port);
-static void  FPT_inisci(unsigned char p_card, unsigned long p_port, unsigned char p_our_id);
-static void  FPT_scsavdi(unsigned char p_card, unsigned long p_port);
-static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_string[]);
-
-
-static void  FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card);
-static void  FPT_autoLoadDefaultMap(unsigned long p_port);
-
-
-
-
-static struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
-static struct sccb_card FPT_BL_Card[MAX_CARDS] = { { 0 } };
-static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
-static struct nvram_info FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
-
+static void FPT_scwtsel(unsigned long p_port);
+static void FPT_inisci(unsigned char p_card, unsigned long p_port,
+		       unsigned char p_our_id);
+static void FPT_scsavdi(unsigned char p_card, unsigned long p_port);
+static unsigned char FPT_scmachid(unsigned char p_card,
+				  unsigned char p_id_string[]);
+
+static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card);
+static void FPT_autoLoadDefaultMap(unsigned long p_port);
+
+static struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] =
+    { {{0}} };
+static struct sccb_card FPT_BL_Card[MAX_CARDS] = { {0} };
+static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { {{0}} };
+static struct nvram_info FPT_nvRamInfo[MAX_MB_CARDS] = { {0} };
 
 static unsigned char FPT_mbCards = 0;
-static unsigned char FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C', \
-				   ' ', 'B', 'T', '-', '9', '3', '0', \
-				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \
-				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
+static unsigned char FPT_scamHAString[] =
+    { 0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C',
+	' ', 'B', 'T', '-', '9', '3', '0',
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
+};
 
 static unsigned short FPT_default_intena = 0;
 
-
-static void (*FPT_s_PhaseTbl[8]) (unsigned long, unsigned char)= { 0 };
-
+static void (*FPT_s_PhaseTbl[8]) (unsigned long, unsigned char) = {
+0};
 
 /*---------------------------------------------------------------------
  *
@@ -1104,276 +933,270 @@ static void (*FPT_s_PhaseTbl[8]) (unsigned long, unsigned char)= { 0 };
  *
  *---------------------------------------------------------------------*/
 
-static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info * pCardInfo)
+static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)
 {
-   static unsigned char first_time = 1;
-
-   unsigned char i,j,id,ScamFlg;
-   unsigned short temp,temp2,temp3,temp4,temp5,temp6;
-   unsigned long ioport;
-	struct nvram_info * pCurrNvRam;
-
-   ioport = pCardInfo->si_baseaddr;
+	static unsigned char first_time = 1;
 
+	unsigned char i, j, id, ScamFlg;
+	unsigned short temp, temp2, temp3, temp4, temp5, temp6;
+	unsigned long ioport;
+	struct nvram_info *pCurrNvRam;
 
-   if (RD_HARPOON(ioport+hp_vendor_id_0) != ORION_VEND_0)
-      return((int)FAILURE);
+	ioport = pCardInfo->si_baseaddr;
 
-   if ((RD_HARPOON(ioport+hp_vendor_id_1) != ORION_VEND_1))
-      return((int)FAILURE);
+	if (RD_HARPOON(ioport + hp_vendor_id_0) != ORION_VEND_0)
+		return ((int)FAILURE);
 
-   if ((RD_HARPOON(ioport+hp_device_id_0) != ORION_DEV_0))
-      return((int)FAILURE);
+	if ((RD_HARPOON(ioport + hp_vendor_id_1) != ORION_VEND_1))
+		return ((int)FAILURE);
 
-   if ((RD_HARPOON(ioport+hp_device_id_1) != ORION_DEV_1))
-      return((int)FAILURE);
+	if ((RD_HARPOON(ioport + hp_device_id_0) != ORION_DEV_0))
+		return ((int)FAILURE);
 
+	if ((RD_HARPOON(ioport + hp_device_id_1) != ORION_DEV_1))
+		return ((int)FAILURE);
 
-   if (RD_HARPOON(ioport+hp_rev_num) != 0x0f){
+	if (RD_HARPOON(ioport + hp_rev_num) != 0x0f) {
 
 /* For new Harpoon then check for sub_device ID LSB
    the bits(0-3) must be all ZERO for compatible with
    current version of SCCBMgr, else skip this Harpoon
 	device. */
 
-	   if (RD_HARPOON(ioport+hp_sub_device_id_0) & 0x0f)
-	      return((int)FAILURE);
+		if (RD_HARPOON(ioport + hp_sub_device_id_0) & 0x0f)
+			return ((int)FAILURE);
 	}
 
-   if (first_time)
-      {
-      FPT_SccbMgrTableInitAll();
-      first_time = 0;
+	if (first_time) {
+		FPT_SccbMgrTableInitAll();
+		first_time = 0;
 		FPT_mbCards = 0;
-      }
+	}
 
-	if(FPT_RdStack(ioport, 0) != 0x00) {
-		if(FPT_ChkIfChipInitialized(ioport) == 0)
-		{
+	if (FPT_RdStack(ioport, 0) != 0x00) {
+		if (FPT_ChkIfChipInitialized(ioport) == 0) {
 			pCurrNvRam = NULL;
-		   WR_HARPOON(ioport+hp_semaphore, 0x00);
-			FPT_XbowInit(ioport, 0);             /*Must Init the SCSI before attempting */
+			WR_HARPOON(ioport + hp_semaphore, 0x00);
+			FPT_XbowInit(ioport, 0);	/*Must Init the SCSI before attempting */
 			FPT_DiagEEPROM(ioport);
-		}
-		else
-		{
-			if(FPT_mbCards < MAX_MB_CARDS) {
+		} else {
+			if (FPT_mbCards < MAX_MB_CARDS) {
 				pCurrNvRam = &FPT_nvRamInfo[FPT_mbCards];
 				FPT_mbCards++;
 				pCurrNvRam->niBaseAddr = ioport;
 				FPT_RNVRamData(pCurrNvRam);
-			}else
-				return((int) FAILURE);
+			} else
+				return ((int)FAILURE);
 		}
-	}else
+	} else
 		pCurrNvRam = NULL;
 
-   WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
-   WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
+	WR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);
+	WR_HARPOON(ioport + hp_sys_ctrl, 0x00);
 
-	if(pCurrNvRam)
+	if (pCurrNvRam)
 		pCardInfo->si_id = pCurrNvRam->niAdapId;
 	else
-	   pCardInfo->si_id = (unsigned char)(FPT_utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
-   	   (unsigned char)0x0FF);
+		pCardInfo->si_id =
+		    (unsigned
+		     char)(FPT_utilEERead(ioport,
+					  (ADAPTER_SCSI_ID /
+					   2)) & (unsigned char)0x0FF);
+
+	pCardInfo->si_lun = 0x00;
+	pCardInfo->si_fw_revision = ORION_FW_REV;
+	temp2 = 0x0000;
+	temp3 = 0x0000;
+	temp4 = 0x0000;
+	temp5 = 0x0000;
+	temp6 = 0x0000;
+
+	for (id = 0; id < (16 / 2); id++) {
+
+		if (pCurrNvRam) {
+			temp = (unsigned short)pCurrNvRam->niSyncTbl[id];
+			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
+			    (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		} else
+			temp =
+			    FPT_utilEERead(ioport,
+					   (unsigned short)((SYNC_RATE_TBL / 2)
+							    + id));
+
+		for (i = 0; i < 2; temp >>= 8, i++) {
+
+			temp2 >>= 1;
+			temp3 >>= 1;
+			temp4 >>= 1;
+			temp5 >>= 1;
+			temp6 >>= 1;
+			switch (temp & 0x3) {
+			case AUTO_RATE_20:	/* Synchronous, 20 mega-transfers/second */
+				temp6 |= 0x8000;	/* Fall through */
+			case AUTO_RATE_10:	/* Synchronous, 10 mega-transfers/second */
+				temp5 |= 0x8000;	/* Fall through */
+			case AUTO_RATE_05:	/* Synchronous, 5 mega-transfers/second */
+				temp2 |= 0x8000;	/* Fall through */
+			case AUTO_RATE_00:	/* Asynchronous */
+				break;
+			}
 
-   pCardInfo->si_lun = 0x00;
-   pCardInfo->si_fw_revision = ORION_FW_REV;
-   temp2 = 0x0000;
-   temp3 = 0x0000;
-   temp4 = 0x0000;
-   temp5 = 0x0000;
-   temp6 = 0x0000;
+			if (temp & DISC_ENABLE_BIT)
+				temp3 |= 0x8000;
 
-   for (id = 0; id < (16/2); id++) {
+			if (temp & WIDE_NEGO_BIT)
+				temp4 |= 0x8000;
 
-		if(pCurrNvRam){
-			temp = (unsigned short) pCurrNvRam->niSyncTbl[id];
-			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
-					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
-		}else
-	      temp = FPT_utilEERead(ioport, (unsigned short)((SYNC_RATE_TBL/2)+id));
-
-      for (i = 0; i < 2; temp >>=8,i++) {
-
-         temp2 >>= 1;
-         temp3 >>= 1;
-         temp4 >>= 1;
-         temp5 >>= 1;
-         temp6 >>= 1;
-	 switch (temp & 0x3)
-	   {
-	   case AUTO_RATE_20:	/* Synchronous, 20 mega-transfers/second */
-	     temp6 |= 0x8000;	/* Fall through */
-	   case AUTO_RATE_10:	/* Synchronous, 10 mega-transfers/second */
-	     temp5 |= 0x8000;	/* Fall through */
-	   case AUTO_RATE_05:	/* Synchronous, 5 mega-transfers/second */
-	     temp2 |= 0x8000;	/* Fall through */
-	   case AUTO_RATE_00:	/* Asynchronous */
-	     break;
-	   }
-
-         if (temp & DISC_ENABLE_BIT)
-	   temp3 |= 0x8000;
-
-         if (temp & WIDE_NEGO_BIT)
-	   temp4 |= 0x8000;
-
-         }
-      }
+		}
+	}
 
-   pCardInfo->si_per_targ_init_sync = temp2;
-   pCardInfo->si_per_targ_no_disc = temp3;
-   pCardInfo->si_per_targ_wide_nego = temp4;
-   pCardInfo->si_per_targ_fast_nego = temp5;
-   pCardInfo->si_per_targ_ultra_nego = temp6;
+	pCardInfo->si_per_targ_init_sync = temp2;
+	pCardInfo->si_per_targ_no_disc = temp3;
+	pCardInfo->si_per_targ_wide_nego = temp4;
+	pCardInfo->si_per_targ_fast_nego = temp5;
+	pCardInfo->si_per_targ_ultra_nego = temp6;
 
-	if(pCurrNvRam)
+	if (pCurrNvRam)
 		i = pCurrNvRam->niSysConf;
 	else
-	   i = (unsigned char)(FPT_utilEERead(ioport, (SYSTEM_CONFIG/2)));
+		i = (unsigned
+		     char)(FPT_utilEERead(ioport, (SYSTEM_CONFIG / 2)));
 
-	if(pCurrNvRam)
+	if (pCurrNvRam)
 		ScamFlg = pCurrNvRam->niScamConf;
 	else
-	   ScamFlg = (unsigned char) FPT_utilEERead(ioport, SCAM_CONFIG/2);
+		ScamFlg =
+		    (unsigned char)FPT_utilEERead(ioport, SCAM_CONFIG / 2);
 
-   pCardInfo->si_flags = 0x0000;
+	pCardInfo->si_flags = 0x0000;
 
-   if (i & 0x01)
-      pCardInfo->si_flags |= SCSI_PARITY_ENA;
+	if (i & 0x01)
+		pCardInfo->si_flags |= SCSI_PARITY_ENA;
 
-   if (!(i & 0x02))
-      pCardInfo->si_flags |= SOFT_RESET;
+	if (!(i & 0x02))
+		pCardInfo->si_flags |= SOFT_RESET;
 
-   if (i & 0x10)
-      pCardInfo->si_flags |= EXTENDED_TRANSLATION;
+	if (i & 0x10)
+		pCardInfo->si_flags |= EXTENDED_TRANSLATION;
 
-   if (ScamFlg & SCAM_ENABLED)
-     pCardInfo->si_flags |= FLAG_SCAM_ENABLED;
+	if (ScamFlg & SCAM_ENABLED)
+		pCardInfo->si_flags |= FLAG_SCAM_ENABLED;
 
-   if (ScamFlg & SCAM_LEVEL2)
-     pCardInfo->si_flags |= FLAG_SCAM_LEVEL2;
+	if (ScamFlg & SCAM_LEVEL2)
+		pCardInfo->si_flags |= FLAG_SCAM_LEVEL2;
 
-   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
-   if (i & 0x04) {
-      j |= SCSI_TERM_ENA_L;
-      }
-   WR_HARPOON(ioport+hp_bm_ctrl, j );
+	j = (RD_HARPOON(ioport + hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
+	if (i & 0x04) {
+		j |= SCSI_TERM_ENA_L;
+	}
+	WR_HARPOON(ioport + hp_bm_ctrl, j);
 
-   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
-   if (i & 0x08) {
-      j |= SCSI_TERM_ENA_H;
-      }
-   WR_HARPOON(ioport+hp_ee_ctrl, j );
+	j = (RD_HARPOON(ioport + hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
+	if (i & 0x08) {
+		j |= SCSI_TERM_ENA_H;
+	}
+	WR_HARPOON(ioport + hp_ee_ctrl, j);
+
+	if (!(RD_HARPOON(ioport + hp_page_ctrl) & NARROW_SCSI_CARD))
+
+		pCardInfo->si_flags |= SUPPORT_16TAR_32LUN;
+
+	pCardInfo->si_card_family = HARPOON_FAMILY;
+	pCardInfo->si_bustype = BUSTYPE_PCI;
+
+	if (pCurrNvRam) {
+		pCardInfo->si_card_model[0] = '9';
+		switch (pCurrNvRam->niModel & 0x0f) {
+		case MODEL_LT:
+			pCardInfo->si_card_model[1] = '3';
+			pCardInfo->si_card_model[2] = '0';
+			break;
+		case MODEL_LW:
+			pCardInfo->si_card_model[1] = '5';
+			pCardInfo->si_card_model[2] = '0';
+			break;
+		case MODEL_DL:
+			pCardInfo->si_card_model[1] = '3';
+			pCardInfo->si_card_model[2] = '2';
+			break;
+		case MODEL_DW:
+			pCardInfo->si_card_model[1] = '5';
+			pCardInfo->si_card_model[2] = '2';
+			break;
+		}
+	} else {
+		temp = FPT_utilEERead(ioport, (MODEL_NUMB_0 / 2));
+		pCardInfo->si_card_model[0] = (unsigned char)(temp >> 8);
+		temp = FPT_utilEERead(ioport, (MODEL_NUMB_2 / 2));
 
-   if (!(RD_HARPOON(ioport+hp_page_ctrl) & NARROW_SCSI_CARD))
+		pCardInfo->si_card_model[1] = (unsigned char)(temp & 0x00FF);
+		pCardInfo->si_card_model[2] = (unsigned char)(temp >> 8);
+	}
 
-      pCardInfo->si_flags |= SUPPORT_16TAR_32LUN;
+	if (pCardInfo->si_card_model[1] == '3') {
+		if (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))
+			pCardInfo->si_flags |= LOW_BYTE_TERM;
+	} else if (pCardInfo->si_card_model[2] == '0') {
+		temp = RD_HARPOON(ioport + hp_xfer_pad);
+		WR_HARPOON(ioport + hp_xfer_pad, (temp & ~BIT(4)));
+		if (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))
+			pCardInfo->si_flags |= LOW_BYTE_TERM;
+		WR_HARPOON(ioport + hp_xfer_pad, (temp | BIT(4)));
+		if (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))
+			pCardInfo->si_flags |= HIGH_BYTE_TERM;
+		WR_HARPOON(ioport + hp_xfer_pad, temp);
+	} else {
+		temp = RD_HARPOON(ioport + hp_ee_ctrl);
+		temp2 = RD_HARPOON(ioport + hp_xfer_pad);
+		WR_HARPOON(ioport + hp_ee_ctrl, (temp | SEE_CS));
+		WR_HARPOON(ioport + hp_xfer_pad, (temp2 | BIT(4)));
+		temp3 = 0;
+		for (i = 0; i < 8; i++) {
+			temp3 <<= 1;
+			if (!(RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7)))
+				temp3 |= 1;
+			WR_HARPOON(ioport + hp_xfer_pad, (temp2 & ~BIT(4)));
+			WR_HARPOON(ioport + hp_xfer_pad, (temp2 | BIT(4)));
+		}
+		WR_HARPOON(ioport + hp_ee_ctrl, temp);
+		WR_HARPOON(ioport + hp_xfer_pad, temp2);
+		if (!(temp3 & BIT(7)))
+			pCardInfo->si_flags |= LOW_BYTE_TERM;
+		if (!(temp3 & BIT(6)))
+			pCardInfo->si_flags |= HIGH_BYTE_TERM;
+	}
 
-   pCardInfo->si_card_family = HARPOON_FAMILY;
-   pCardInfo->si_bustype = BUSTYPE_PCI;
+	ARAM_ACCESS(ioport);
 
-	if(pCurrNvRam){
-   	pCardInfo->si_card_model[0] = '9';
-		switch(pCurrNvRam->niModel & 0x0f){
-			case MODEL_LT:
-		   	pCardInfo->si_card_model[1] = '3';
-		   	pCardInfo->si_card_model[2] = '0';
-				break;
-			case MODEL_LW:
-		   	pCardInfo->si_card_model[1] = '5';
-		   	pCardInfo->si_card_model[2] = '0';
-				break;
-			case MODEL_DL:
-		   	pCardInfo->si_card_model[1] = '3';
-		   	pCardInfo->si_card_model[2] = '2';
-				break;
-			case MODEL_DW:
-		   	pCardInfo->si_card_model[1] = '5';
-		   	pCardInfo->si_card_model[2] = '2';
-				break;
-		}
-	}else{
-	   temp = FPT_utilEERead(ioport, (MODEL_NUMB_0/2));
-   	pCardInfo->si_card_model[0] = (unsigned char)(temp >> 8);
-	   temp = FPT_utilEERead(ioport, (MODEL_NUMB_2/2));
-
-   	pCardInfo->si_card_model[1] = (unsigned char)(temp & 0x00FF);
-	   pCardInfo->si_card_model[2] = (unsigned char)(temp >> 8);
-	}
-
-   if (pCardInfo->si_card_model[1] == '3')
-     {
-       if (RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7))
-	 pCardInfo->si_flags |= LOW_BYTE_TERM;
-     }
-   else if (pCardInfo->si_card_model[2] == '0')
-     {
-       temp = RD_HARPOON(ioport+hp_xfer_pad);
-       WR_HARPOON(ioport+hp_xfer_pad, (temp & ~BIT(4)));
-       if (RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7))
-	 pCardInfo->si_flags |= LOW_BYTE_TERM;
-       WR_HARPOON(ioport+hp_xfer_pad, (temp | BIT(4)));
-       if (RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7))
-	 pCardInfo->si_flags |= HIGH_BYTE_TERM;
-       WR_HARPOON(ioport+hp_xfer_pad, temp);
-     }
-   else
-     {
-       temp = RD_HARPOON(ioport+hp_ee_ctrl);
-       temp2 = RD_HARPOON(ioport+hp_xfer_pad);
-       WR_HARPOON(ioport+hp_ee_ctrl, (temp | SEE_CS));
-       WR_HARPOON(ioport+hp_xfer_pad, (temp2 | BIT(4)));
-       temp3 = 0;
-       for (i = 0; i < 8; i++)
-	 {
-	   temp3 <<= 1;
-	   if (!(RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7)))
-	     temp3 |= 1;
-	   WR_HARPOON(ioport+hp_xfer_pad, (temp2 & ~BIT(4)));
-	   WR_HARPOON(ioport+hp_xfer_pad, (temp2 | BIT(4)));
-	 }
-       WR_HARPOON(ioport+hp_ee_ctrl, temp);
-       WR_HARPOON(ioport+hp_xfer_pad, temp2);
-       if (!(temp3 & BIT(7)))
-	 pCardInfo->si_flags |= LOW_BYTE_TERM;
-       if (!(temp3 & BIT(6)))
-	 pCardInfo->si_flags |= HIGH_BYTE_TERM;
-     }
-
-
-   ARAM_ACCESS(ioport);
-
-   for ( i = 0; i < 4; i++ ) {
-
-      pCardInfo->si_XlatInfo[i] =
-         RD_HARPOON(ioport+hp_aramBase+BIOS_DATA_OFFSET+i);
-      }
+	for (i = 0; i < 4; i++) {
+
+		pCardInfo->si_XlatInfo[i] =
+		    RD_HARPOON(ioport + hp_aramBase + BIOS_DATA_OFFSET + i);
+	}
 
 	/* return with -1 if no sort, else return with
 	   logical card number sorted by BIOS (zero-based) */
 
 	pCardInfo->si_relative_cardnum =
-	(unsigned char)(RD_HARPOON(ioport+hp_aramBase+BIOS_RELATIVE_CARD)-1);
+	    (unsigned
+	     char)(RD_HARPOON(ioport + hp_aramBase + BIOS_RELATIVE_CARD) - 1);
 
-   SGRAM_ACCESS(ioport);
+	SGRAM_ACCESS(ioport);
 
-   FPT_s_PhaseTbl[0] = FPT_phaseDataOut;
-   FPT_s_PhaseTbl[1] = FPT_phaseDataIn;
-   FPT_s_PhaseTbl[2] = FPT_phaseIllegal;
-   FPT_s_PhaseTbl[3] = FPT_phaseIllegal;
-   FPT_s_PhaseTbl[4] = FPT_phaseCommand;
-   FPT_s_PhaseTbl[5] = FPT_phaseStatus;
-   FPT_s_PhaseTbl[6] = FPT_phaseMsgOut;
-   FPT_s_PhaseTbl[7] = FPT_phaseMsgIn;
+	FPT_s_PhaseTbl[0] = FPT_phaseDataOut;
+	FPT_s_PhaseTbl[1] = FPT_phaseDataIn;
+	FPT_s_PhaseTbl[2] = FPT_phaseIllegal;
+	FPT_s_PhaseTbl[3] = FPT_phaseIllegal;
+	FPT_s_PhaseTbl[4] = FPT_phaseCommand;
+	FPT_s_PhaseTbl[5] = FPT_phaseStatus;
+	FPT_s_PhaseTbl[6] = FPT_phaseMsgOut;
+	FPT_s_PhaseTbl[7] = FPT_phaseMsgIn;
 
-   pCardInfo->si_present = 0x01;
+	pCardInfo->si_present = 0x01;
 
-   return(0);
+	return (0);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FlashPoint_HardwareResetHostAdapter
@@ -1382,185 +1205,190 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info * pCardInfo)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info * pCardInfo)
+static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info
+							 *pCardInfo)
 {
-   struct sccb_card * CurrCard = NULL;
-	struct nvram_info * pCurrNvRam;
-   unsigned char i,j,thisCard, ScamFlg;
-   unsigned short temp,sync_bit_map,id;
-   unsigned long ioport;
+	struct sccb_card *CurrCard = NULL;
+	struct nvram_info *pCurrNvRam;
+	unsigned char i, j, thisCard, ScamFlg;
+	unsigned short temp, sync_bit_map, id;
+	unsigned long ioport;
 
-   ioport = pCardInfo->si_baseaddr;
+	ioport = pCardInfo->si_baseaddr;
 
-   for(thisCard =0; thisCard <= MAX_CARDS; thisCard++) {
+	for (thisCard = 0; thisCard <= MAX_CARDS; thisCard++) {
 
-      if (thisCard == MAX_CARDS) {
+		if (thisCard == MAX_CARDS) {
 
-	 return(FAILURE);
-         }
+			return (FAILURE);
+		}
 
-      if (FPT_BL_Card[thisCard].ioPort == ioport) {
+		if (FPT_BL_Card[thisCard].ioPort == ioport) {
 
-         CurrCard = &FPT_BL_Card[thisCard];
-         FPT_SccbMgrTableInitCard(CurrCard,thisCard);
-         break;
-         }
+			CurrCard = &FPT_BL_Card[thisCard];
+			FPT_SccbMgrTableInitCard(CurrCard, thisCard);
+			break;
+		}
 
-      else if (FPT_BL_Card[thisCard].ioPort == 0x00) {
+		else if (FPT_BL_Card[thisCard].ioPort == 0x00) {
 
-         FPT_BL_Card[thisCard].ioPort = ioport;
-         CurrCard = &FPT_BL_Card[thisCard];
+			FPT_BL_Card[thisCard].ioPort = ioport;
+			CurrCard = &FPT_BL_Card[thisCard];
 
-			if(FPT_mbCards)
-				for(i = 0; i < FPT_mbCards; i++){
-					if(CurrCard->ioPort == FPT_nvRamInfo[i].niBaseAddr)
-						CurrCard->pNvRamInfo = &FPT_nvRamInfo[i];
+			if (FPT_mbCards)
+				for (i = 0; i < FPT_mbCards; i++) {
+					if (CurrCard->ioPort ==
+					    FPT_nvRamInfo[i].niBaseAddr)
+						CurrCard->pNvRamInfo =
+						    &FPT_nvRamInfo[i];
 				}
-         FPT_SccbMgrTableInitCard(CurrCard,thisCard);
-         CurrCard->cardIndex = thisCard;
-         CurrCard->cardInfo = pCardInfo;
+			FPT_SccbMgrTableInitCard(CurrCard, thisCard);
+			CurrCard->cardIndex = thisCard;
+			CurrCard->cardInfo = pCardInfo;
 
-	 break;
-         }
-      }
+			break;
+		}
+	}
 
 	pCurrNvRam = CurrCard->pNvRamInfo;
 
-	if(pCurrNvRam){
+	if (pCurrNvRam) {
 		ScamFlg = pCurrNvRam->niScamConf;
+	} else {
+		ScamFlg =
+		    (unsigned char)FPT_utilEERead(ioport, SCAM_CONFIG / 2);
 	}
-	else{
-	   ScamFlg = (unsigned char) FPT_utilEERead(ioport, SCAM_CONFIG/2);
-	}
-
-
-   FPT_BusMasterInit(ioport);
-   FPT_XbowInit(ioport, ScamFlg);
 
-   FPT_autoLoadDefaultMap(ioport);
+	FPT_BusMasterInit(ioport);
+	FPT_XbowInit(ioport, ScamFlg);
 
+	FPT_autoLoadDefaultMap(ioport);
 
-   for (i = 0,id = 0x01; i != pCardInfo->si_id; i++,id <<= 1){}
-
-   WR_HARPOON(ioport+hp_selfid_0, id);
-   WR_HARPOON(ioport+hp_selfid_1, 0x00);
-   WR_HARPOON(ioport+hp_arb_id, pCardInfo->si_id);
-   CurrCard->ourId = pCardInfo->si_id;
-
-   i = (unsigned char) pCardInfo->si_flags;
-   if (i & SCSI_PARITY_ENA)
-       WR_HARPOON(ioport+hp_portctrl_1,(HOST_MODE8 | CHK_SCSI_P));
+	for (i = 0, id = 0x01; i != pCardInfo->si_id; i++, id <<= 1) {
+	}
 
-   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
-   if (i & LOW_BYTE_TERM)
-      j |= SCSI_TERM_ENA_L;
-   WR_HARPOON(ioport+hp_bm_ctrl, j);
+	WR_HARPOON(ioport + hp_selfid_0, id);
+	WR_HARPOON(ioport + hp_selfid_1, 0x00);
+	WR_HARPOON(ioport + hp_arb_id, pCardInfo->si_id);
+	CurrCard->ourId = pCardInfo->si_id;
 
-   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
-   if (i & HIGH_BYTE_TERM)
-      j |= SCSI_TERM_ENA_H;
-   WR_HARPOON(ioport+hp_ee_ctrl, j );
+	i = (unsigned char)pCardInfo->si_flags;
+	if (i & SCSI_PARITY_ENA)
+		WR_HARPOON(ioport + hp_portctrl_1, (HOST_MODE8 | CHK_SCSI_P));
 
+	j = (RD_HARPOON(ioport + hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
+	if (i & LOW_BYTE_TERM)
+		j |= SCSI_TERM_ENA_L;
+	WR_HARPOON(ioport + hp_bm_ctrl, j);
 
-   if (!(pCardInfo->si_flags & SOFT_RESET)) {
+	j = (RD_HARPOON(ioport + hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
+	if (i & HIGH_BYTE_TERM)
+		j |= SCSI_TERM_ENA_H;
+	WR_HARPOON(ioport + hp_ee_ctrl, j);
 
-      FPT_sresb(ioport,thisCard);
-
-         FPT_scini(thisCard, pCardInfo->si_id, 0);
-      }
+	if (!(pCardInfo->si_flags & SOFT_RESET)) {
 
+		FPT_sresb(ioport, thisCard);
 
+		FPT_scini(thisCard, pCardInfo->si_id, 0);
+	}
 
-   if (pCardInfo->si_flags & POST_ALL_UNDERRRUNS)
-      CurrCard->globalFlags |= F_NO_FILTER;
+	if (pCardInfo->si_flags & POST_ALL_UNDERRRUNS)
+		CurrCard->globalFlags |= F_NO_FILTER;
 
-	if(pCurrNvRam){
-		if(pCurrNvRam->niSysConf & 0x10)
+	if (pCurrNvRam) {
+		if (pCurrNvRam->niSysConf & 0x10)
+			CurrCard->globalFlags |= F_GREEN_PC;
+	} else {
+		if (FPT_utilEERead(ioport, (SYSTEM_CONFIG / 2)) & GREEN_PC_ENA)
 			CurrCard->globalFlags |= F_GREEN_PC;
-	}
-	else{
-	   if (FPT_utilEERead(ioport, (SYSTEM_CONFIG/2)) & GREEN_PC_ENA)
-   	   CurrCard->globalFlags |= F_GREEN_PC;
 	}
 
 	/* Set global flag to indicate Re-Negotiation to be done on all
-		ckeck condition */
-	if(pCurrNvRam){
-		if(pCurrNvRam->niScsiConf & 0x04)
+	   ckeck condition */
+	if (pCurrNvRam) {
+		if (pCurrNvRam->niScsiConf & 0x04)
+			CurrCard->globalFlags |= F_DO_RENEGO;
+	} else {
+		if (FPT_utilEERead(ioport, (SCSI_CONFIG / 2)) & RENEGO_ENA)
 			CurrCard->globalFlags |= F_DO_RENEGO;
-	}
-	else{
-	   if (FPT_utilEERead(ioport, (SCSI_CONFIG/2)) & RENEGO_ENA)
-   	   CurrCard->globalFlags |= F_DO_RENEGO;
 	}
 
-	if(pCurrNvRam){
-		if(pCurrNvRam->niScsiConf & 0x08)
+	if (pCurrNvRam) {
+		if (pCurrNvRam->niScsiConf & 0x08)
+			CurrCard->globalFlags |= F_CONLUN_IO;
+	} else {
+		if (FPT_utilEERead(ioport, (SCSI_CONFIG / 2)) & CONNIO_ENA)
 			CurrCard->globalFlags |= F_CONLUN_IO;
 	}
-	else{
-	   if (FPT_utilEERead(ioport, (SCSI_CONFIG/2)) & CONNIO_ENA)
-   	   CurrCard->globalFlags |= F_CONLUN_IO;
-	}
-
 
-   temp = pCardInfo->si_per_targ_no_disc;
+	temp = pCardInfo->si_per_targ_no_disc;
 
-   for (i = 0,id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
+	for (i = 0, id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
 
-      if (temp & id)
-	 FPT_sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
-      }
+		if (temp & id)
+			FPT_sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
+	}
 
-   sync_bit_map = 0x0001;
+	sync_bit_map = 0x0001;
 
-   for (id = 0; id < (MAX_SCSI_TAR/2); id++) {
+	for (id = 0; id < (MAX_SCSI_TAR / 2); id++) {
 
-		if(pCurrNvRam){
-			temp = (unsigned short) pCurrNvRam->niSyncTbl[id];
+		if (pCurrNvRam) {
+			temp = (unsigned short)pCurrNvRam->niSyncTbl[id];
 			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
-					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
-		}else
-	      temp = FPT_utilEERead(ioport, (unsigned short)((SYNC_RATE_TBL/2)+id));
+			    (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		} else
+			temp =
+			    FPT_utilEERead(ioport,
+					   (unsigned short)((SYNC_RATE_TBL / 2)
+							    + id));
 
-      for (i = 0; i < 2; temp >>=8,i++) {
+		for (i = 0; i < 2; temp >>= 8, i++) {
 
-         if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
+			if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
 
-            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue = (unsigned char)temp;
-            }
+				FPT_sccbMgrTbl[thisCard][id * 2 +
+							 i].TarEEValue =
+				    (unsigned char)temp;
+			}
 
-         else {
-	    FPT_sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
-            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue =
-               (unsigned char)(temp & ~EE_SYNC_MASK);
-            }
+			else {
+				FPT_sccbMgrTbl[thisCard][id * 2 +
+							 i].TarStatus |=
+				    SYNC_SUPPORTED;
+				FPT_sccbMgrTbl[thisCard][id * 2 +
+							 i].TarEEValue =
+				    (unsigned char)(temp & ~EE_SYNC_MASK);
+			}
 
 /*         if ((pCardInfo->si_per_targ_wide_nego & sync_bit_map) ||
             (id*2+i >= 8)){
 */
-         if (pCardInfo->si_per_targ_wide_nego & sync_bit_map){
-
-            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue |= EE_WIDE_SCSI;
+			if (pCardInfo->si_per_targ_wide_nego & sync_bit_map) {
 
-            }
+				FPT_sccbMgrTbl[thisCard][id * 2 +
+							 i].TarEEValue |=
+				    EE_WIDE_SCSI;
 
-         else { /* NARROW SCSI */
-            FPT_sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
-            }
-
-
-	 sync_bit_map <<= 1;
+			}
 
+			else {	/* NARROW SCSI */
+				FPT_sccbMgrTbl[thisCard][id * 2 +
+							 i].TarStatus |=
+				    WIDE_NEGOCIATED;
+			}
 
+			sync_bit_map <<= 1;
 
-         }
-      }
+		}
+	}
 
-   WR_HARPOON((ioport+hp_semaphore),
-      (unsigned char)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
+	WR_HARPOON((ioport + hp_semaphore),
+		   (unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |
+				   SCCB_MGR_PRESENT));
 
-   return((unsigned long)CurrCard);
+	return ((unsigned long)CurrCard);
 }
 
 static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
@@ -1570,36 +1398,37 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 	unsigned long regOffset;
 	unsigned long scamData;
 	unsigned long *pScamTbl;
-	struct nvram_info * pCurrNvRam;
+	struct nvram_info *pCurrNvRam;
 
 	pCurrNvRam = ((struct sccb_card *)pCurrCard)->pNvRamInfo;
 
-	if(pCurrNvRam){
+	if (pCurrNvRam) {
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 1, pCurrNvRam->niSysConf);
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 2, pCurrNvRam->niScsiConf);
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 3, pCurrNvRam->niScamConf);
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);
 
-		for(i = 0; i < MAX_SCSI_TAR / 2; i++)
-			FPT_WrStack(pCurrNvRam->niBaseAddr, (unsigned char)(i+5), pCurrNvRam->niSyncTbl[i]);
+		for (i = 0; i < MAX_SCSI_TAR / 2; i++)
+			FPT_WrStack(pCurrNvRam->niBaseAddr,
+				    (unsigned char)(i + 5),
+				    pCurrNvRam->niSyncTbl[i]);
 
 		portBase = pCurrNvRam->niBaseAddr;
 
-		for(i = 0; i < MAX_SCSI_TAR; i++){
-			regOffset = hp_aramBase + 64 + i*4;
-			pScamTbl = (unsigned long *) &pCurrNvRam->niScamTbl[i];
+		for (i = 0; i < MAX_SCSI_TAR; i++) {
+			regOffset = hp_aramBase + 64 + i * 4;
+			pScamTbl = (unsigned long *)&pCurrNvRam->niScamTbl[i];
 			scamData = *pScamTbl;
 			WR_HARP32(portBase, regOffset, scamData);
 		}
 
-	}else{
+	} else {
 		FPT_WrStack(((struct sccb_card *)pCurrCard)->ioPort, 0, 0);
 	}
 }
 
-
-static void FPT_RNVRamData(struct nvram_info * pNvRamInfo)
+static void FPT_RNVRamData(struct nvram_info *pNvRamInfo)
 {
 	unsigned char i;
 	unsigned long portBase;
@@ -1607,21 +1436,22 @@ static void FPT_RNVRamData(struct nvram_info * pNvRamInfo)
 	unsigned long scamData;
 	unsigned long *pScamTbl;
 
-	pNvRamInfo->niModel    = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);
-	pNvRamInfo->niSysConf  = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);
+	pNvRamInfo->niModel = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);
+	pNvRamInfo->niSysConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);
 	pNvRamInfo->niScsiConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 2);
 	pNvRamInfo->niScamConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 3);
-	pNvRamInfo->niAdapId   = FPT_RdStack(pNvRamInfo->niBaseAddr, 4);
+	pNvRamInfo->niAdapId = FPT_RdStack(pNvRamInfo->niBaseAddr, 4);
 
-	for(i = 0; i < MAX_SCSI_TAR / 2; i++)
-		pNvRamInfo->niSyncTbl[i] = FPT_RdStack(pNvRamInfo->niBaseAddr, (unsigned char)(i+5));
+	for (i = 0; i < MAX_SCSI_TAR / 2; i++)
+		pNvRamInfo->niSyncTbl[i] =
+		    FPT_RdStack(pNvRamInfo->niBaseAddr, (unsigned char)(i + 5));
 
 	portBase = pNvRamInfo->niBaseAddr;
 
-	for(i = 0; i < MAX_SCSI_TAR; i++){
-		regOffset = hp_aramBase + 64 + i*4;
+	for (i = 0; i < MAX_SCSI_TAR; i++) {
+		regOffset = hp_aramBase + 64 + i * 4;
 		RD_HARP32(portBase, regOffset, scamData);
-		pScamTbl = (unsigned long *) &pNvRamInfo->niScamTbl[i];
+		pScamTbl = (unsigned long *)&pNvRamInfo->niScamTbl[i];
 		*pScamTbl = scamData;
 	}
 
@@ -1630,29 +1460,30 @@ static void FPT_RNVRamData(struct nvram_info * pNvRamInfo)
 static unsigned char FPT_RdStack(unsigned long portBase, unsigned char index)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
-	return(RD_HARPOON(portBase + hp_stack_data));
+	return (RD_HARPOON(portBase + hp_stack_data));
 }
 
-static void FPT_WrStack(unsigned long portBase, unsigned char index, unsigned char data)
+static void FPT_WrStack(unsigned long portBase, unsigned char index,
+			unsigned char data)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	WR_HARPOON(portBase + hp_stack_data, data);
 }
 
-
 static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
 {
-	if((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
-		return(0);
-	if((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)
-								!= CLKCTRL_DEFAULT)
-		return(0);
-	if((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||
-		(RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))
-		return(1);
-	return(0);
+	if ((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
+		return (0);
+	if ((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)
+	    != CLKCTRL_DEFAULT)
+		return (0);
+	if ((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||
+	    (RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))
+		return (1);
+	return (0);
 
 }
+
 /*---------------------------------------------------------------------
  *
  * Function: FlashPoint_StartCCB
@@ -1662,117 +1493,115 @@ static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
+static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 {
-   unsigned long ioport;
-   unsigned char thisCard, lun;
-	struct sccb * pSaveSccb;
-   CALL_BK_FN callback;
+	unsigned long ioport;
+	unsigned char thisCard, lun;
+	struct sccb *pSaveSccb;
+	CALL_BK_FN callback;
 
-   thisCard = ((struct sccb_card *) pCurrCard)->cardIndex;
-   ioport = ((struct sccb_card *) pCurrCard)->ioPort;
+	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
+	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
-	if((p_Sccb->TargID > MAX_SCSI_TAR) || (p_Sccb->Lun > MAX_LUN))
-	{
+	if ((p_Sccb->TargID > MAX_SCSI_TAR) || (p_Sccb->Lun > MAX_LUN)) {
 
 		p_Sccb->HostStatus = SCCB_COMPLETE;
 		p_Sccb->SccbStatus = SCCB_ERROR;
-		callback = (CALL_BK_FN)p_Sccb->SccbCallback;
+		callback = (CALL_BK_FN) p_Sccb->SccbCallback;
 		if (callback)
 			callback(p_Sccb);
 
 		return;
 	}
 
-   FPT_sinits(p_Sccb,thisCard);
-
-
-   if (!((struct sccb_card *) pCurrCard)->cmdCounter)
-      {
-      WR_HARPOON(ioport+hp_semaphore, (RD_HARPOON(ioport+hp_semaphore)
-         | SCCB_MGR_ACTIVE));
-
-      if (((struct sccb_card *) pCurrCard)->globalFlags & F_GREEN_PC)
-         {
-		 WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
-		 WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
-         }
-      }
-
-   ((struct sccb_card *)pCurrCard)->cmdCounter++;
+	FPT_sinits(p_Sccb, thisCard);
 
-   if (RD_HARPOON(ioport+hp_semaphore) & BIOS_IN_USE) {
+	if (!((struct sccb_card *)pCurrCard)->cmdCounter) {
+		WR_HARPOON(ioport + hp_semaphore,
+			   (RD_HARPOON(ioport + hp_semaphore)
+			    | SCCB_MGR_ACTIVE));
 
-      WR_HARPOON(ioport+hp_semaphore, (RD_HARPOON(ioport+hp_semaphore)
-         | TICKLE_ME));
-		if(p_Sccb->OperationCode == RESET_COMMAND)
-			{
-				pSaveSccb = ((struct sccb_card *) pCurrCard)->currentSCCB;
-				((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
-				FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-				((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSccb;
-			}
-		else
-			{
-	      FPT_queueAddSccb(p_Sccb,thisCard);
-			}
-      }
+		if (((struct sccb_card *)pCurrCard)->globalFlags & F_GREEN_PC) {
+			WR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);
+			WR_HARPOON(ioport + hp_sys_ctrl, 0x00);
+		}
+	}
 
-   else if ((RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE)) {
+	((struct sccb_card *)pCurrCard)->cmdCounter++;
+
+	if (RD_HARPOON(ioport + hp_semaphore) & BIOS_IN_USE) {
+
+		WR_HARPOON(ioport + hp_semaphore,
+			   (RD_HARPOON(ioport + hp_semaphore)
+			    | TICKLE_ME));
+		if (p_Sccb->OperationCode == RESET_COMMAND) {
+			pSaveSccb =
+			    ((struct sccb_card *)pCurrCard)->currentSCCB;
+			((struct sccb_card *)pCurrCard)->currentSCCB = p_Sccb;
+			FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
+			((struct sccb_card *)pCurrCard)->currentSCCB =
+			    pSaveSccb;
+		} else {
+			FPT_queueAddSccb(p_Sccb, thisCard);
+		}
+	}
 
-			if(p_Sccb->OperationCode == RESET_COMMAND)
-				{
-					pSaveSccb = ((struct sccb_card *) pCurrCard)->currentSCCB;
-					((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
-					FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-					((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSccb;
-				}
-			else
-				{
-		      FPT_queueAddSccb(p_Sccb,thisCard);
-				}
-      }
+	else if ((RD_HARPOON(ioport + hp_page_ctrl) & G_INT_DISABLE)) {
+
+		if (p_Sccb->OperationCode == RESET_COMMAND) {
+			pSaveSccb =
+			    ((struct sccb_card *)pCurrCard)->currentSCCB;
+			((struct sccb_card *)pCurrCard)->currentSCCB = p_Sccb;
+			FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
+			((struct sccb_card *)pCurrCard)->currentSCCB =
+			    pSaveSccb;
+		} else {
+			FPT_queueAddSccb(p_Sccb, thisCard);
+		}
+	}
 
-   else {
+	else {
 
-      MDISABLE_INT(ioport);
+		MDISABLE_INT(ioport);
 
-		if((((struct sccb_card *) pCurrCard)->globalFlags & F_CONLUN_IO) &&
-			((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+		if ((((struct sccb_card *)pCurrCard)->globalFlags & F_CONLUN_IO)
+		    &&
+		    ((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].
+		      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
 			lun = p_Sccb->Lun;
 		else
 			lun = 0;
-      if ((((struct sccb_card *) pCurrCard)->currentSCCB == NULL) &&
-         (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0) &&
-         (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
-         == 0)) {
-
-            ((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
-	    FPT_ssel(p_Sccb->SccbIOPort,thisCard);
-         }
+		if ((((struct sccb_card *)pCurrCard)->currentSCCB == NULL) &&
+		    (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0)
+		    && (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
+			== 0)) {
 
-      else {
-
-			if(p_Sccb->OperationCode == RESET_COMMAND)
-				{
-					pSaveSccb = ((struct sccb_card *) pCurrCard)->currentSCCB;
-					((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
-					FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-					((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSccb;
-				}
-			else
-				{
-	         	FPT_queueAddSccb(p_Sccb,thisCard);
-				}
-         }
+			((struct sccb_card *)pCurrCard)->currentSCCB = p_Sccb;
+			FPT_ssel(p_Sccb->SccbIOPort, thisCard);
+		}
 
+		else {
+
+			if (p_Sccb->OperationCode == RESET_COMMAND) {
+				pSaveSccb =
+				    ((struct sccb_card *)pCurrCard)->
+				    currentSCCB;
+				((struct sccb_card *)pCurrCard)->currentSCCB =
+				    p_Sccb;
+				FPT_queueSelectFail(&FPT_BL_Card[thisCard],
+						    thisCard);
+				((struct sccb_card *)pCurrCard)->currentSCCB =
+				    pSaveSccb;
+			} else {
+				FPT_queueAddSccb(p_Sccb, thisCard);
+			}
+		}
 
-      MENABLE_INT(ioport);
-      }
+		MENABLE_INT(ioport);
+	}
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FlashPoint_AbortCCB
@@ -1782,98 +1611,106 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
+static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb *p_Sccb)
 {
 	unsigned long ioport;
 
 	unsigned char thisCard;
 	CALL_BK_FN callback;
 	unsigned char TID;
-	struct sccb * pSaveSCCB;
-	struct sccb_mgr_tar_info * currTar_Info;
-
+	struct sccb *pSaveSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-	ioport = ((struct sccb_card *) pCurrCard)->ioPort;
+	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
 	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
 
-	if (!(RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE))
-	{
+	if (!(RD_HARPOON(ioport + hp_page_ctrl) & G_INT_DISABLE)) {
 
-		if (FPT_queueFindSccb(p_Sccb,thisCard))
-		{
+		if (FPT_queueFindSccb(p_Sccb, thisCard)) {
 
 			((struct sccb_card *)pCurrCard)->cmdCounter--;
 
 			if (!((struct sccb_card *)pCurrCard)->cmdCounter)
-				WR_HARPOON(ioport+hp_semaphore,(RD_HARPOON(ioport+hp_semaphore)
-					& (unsigned char)(~(SCCB_MGR_ACTIVE | TICKLE_ME)) ));
+				WR_HARPOON(ioport + hp_semaphore,
+					   (RD_HARPOON(ioport + hp_semaphore)
+					    & (unsigned
+					       char)(~(SCCB_MGR_ACTIVE |
+						       TICKLE_ME))));
 
 			p_Sccb->SccbStatus = SCCB_ABORT;
 			callback = p_Sccb->SccbCallback;
 			callback(p_Sccb);
 
-			return(0);
+			return (0);
 		}
 
-		else
-		{
-			if (((struct sccb_card *)pCurrCard)->currentSCCB == p_Sccb)
-			{
+		else {
+			if (((struct sccb_card *)pCurrCard)->currentSCCB ==
+			    p_Sccb) {
 				p_Sccb->SccbStatus = SCCB_ABORT;
-				return(0);
+				return (0);
 
 			}
 
-			else
-			{
+			else {
 
 				TID = p_Sccb->TargID;
 
-
-				if(p_Sccb->Sccb_tag)
-				{
+				if (p_Sccb->Sccb_tag) {
 					MDISABLE_INT(ioport);
-					if (((struct sccb_card *) pCurrCard)->discQ_Tbl[p_Sccb->Sccb_tag]==p_Sccb)
-					{
+					if (((struct sccb_card *)pCurrCard)->
+					    discQ_Tbl[p_Sccb->Sccb_tag] ==
+					    p_Sccb) {
 						p_Sccb->SccbStatus = SCCB_ABORT;
-						p_Sccb->Sccb_scsistat = ABORT_ST;
-						p_Sccb->Sccb_scsimsg = SMABORT_TAG;
-
-						if(((struct sccb_card *) pCurrCard)->currentSCCB == NULL)
-						{
-							((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
-							FPT_ssel(ioport, thisCard);
-						}
-						else
-						{
-							pSaveSCCB = ((struct sccb_card *) pCurrCard)->currentSCCB;
-							((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
-							FPT_queueSelectFail((struct sccb_card *) pCurrCard, thisCard);
-							((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSCCB;
+						p_Sccb->Sccb_scsistat =
+						    ABORT_ST;
+						p_Sccb->Sccb_scsimsg =
+						    SMABORT_TAG;
+
+						if (((struct sccb_card *)
+						     pCurrCard)->currentSCCB ==
+						    NULL) {
+							((struct sccb_card *)
+							 pCurrCard)->
+					currentSCCB = p_Sccb;
+							FPT_ssel(ioport,
+								 thisCard);
+						} else {
+							pSaveSCCB =
+							    ((struct sccb_card
+							      *)pCurrCard)->
+							    currentSCCB;
+							((struct sccb_card *)
+							 pCurrCard)->
+					currentSCCB = p_Sccb;
+							FPT_queueSelectFail((struct sccb_card *)pCurrCard, thisCard);
+							((struct sccb_card *)
+							 pCurrCard)->
+					currentSCCB = pSaveSCCB;
 						}
 					}
 					MENABLE_INT(ioport);
-					return(0);
-				}
-				else
-				{
-					currTar_Info = &FPT_sccbMgrTbl[thisCard][p_Sccb->TargID];
-
-					if(FPT_BL_Card[thisCard].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_Sccb->Lun]] 
-							== p_Sccb)
-					{
+					return (0);
+				} else {
+					currTar_Info =
+					    &FPT_sccbMgrTbl[thisCard][p_Sccb->
+								      TargID];
+
+					if (FPT_BL_Card[thisCard].
+					    discQ_Tbl[currTar_Info->
+						      LunDiscQ_Idx[p_Sccb->Lun]]
+					    == p_Sccb) {
 						p_Sccb->SccbStatus = SCCB_ABORT;
-						return(0);
+						return (0);
 					}
 				}
 			}
 		}
 	}
-	return(-1);
+	return (-1);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FlashPoint_InterruptPending
@@ -1884,22 +1721,19 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
  *---------------------------------------------------------------------*/
 static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
 {
-   unsigned long ioport;
+	unsigned long ioport;
 
-   ioport = ((struct sccb_card *)pCurrCard)->ioPort;
+	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
-   if (RD_HARPOON(ioport+hp_int_status) & INT_ASSERTED)
-   {
-      return(1);
-   }
+	if (RD_HARPOON(ioport + hp_int_status) & INT_ASSERTED) {
+		return (1);
+	}
 
-   else
+	else
 
-      return(0);
+		return (0);
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FlashPoint_HandleInterrupt
@@ -1911,237 +1745,259 @@ static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
  *---------------------------------------------------------------------*/
 static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 {
-   struct sccb * currSCCB;
-   unsigned char thisCard,result,bm_status, bm_int_st;
-   unsigned short hp_int;
-   unsigned char i, target;
-   unsigned long ioport;
-
-   thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
-   ioport = ((struct sccb_card *)pCurrCard)->ioPort;
-
-   MDISABLE_INT(ioport);
+	struct sccb *currSCCB;
+	unsigned char thisCard, result, bm_status, bm_int_st;
+	unsigned short hp_int;
+	unsigned char i, target;
+	unsigned long ioport;
 
-   if ((bm_int_st=RD_HARPOON(ioport+hp_int_status)) & EXT_STATUS_ON)
-		bm_status = RD_HARPOON(ioport+hp_ext_status) & (unsigned char)BAD_EXT_STATUS;
-   else
-      bm_status = 0;
+	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
+	ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
-   WR_HARPOON(ioport+hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
+	MDISABLE_INT(ioport);
 
-   while ((hp_int = RDW_HARPOON((ioport+hp_intstat)) & FPT_default_intena) |
-	  bm_status)
-     {
+	if ((bm_int_st = RD_HARPOON(ioport + hp_int_status)) & EXT_STATUS_ON)
+		bm_status =
+		    RD_HARPOON(ioport +
+			       hp_ext_status) & (unsigned char)BAD_EXT_STATUS;
+	else
+		bm_status = 0;
 
-       currSCCB = ((struct sccb_card *)pCurrCard)->currentSCCB;
+	WR_HARPOON(ioport + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
 
-      if (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {
-         result = FPT_SccbMgr_bad_isr(ioport,thisCard,((struct sccb_card *)pCurrCard),hp_int);
-         WRW_HARPOON((ioport+hp_intstat), (FIFO | TIMEOUT | RESET | SCAM_SEL));
-         bm_status = 0;
+	while ((hp_int =
+		RDW_HARPOON((ioport +
+			     hp_intstat)) & FPT_default_intena) | bm_status) {
 
-         if (result) {
+		currSCCB = ((struct sccb_card *)pCurrCard)->currentSCCB;
 
-            MENABLE_INT(ioport);
-            return(result);
-            }
-         }
+		if (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {
+			result =
+			    FPT_SccbMgr_bad_isr(ioport, thisCard,
+						((struct sccb_card *)pCurrCard),
+						hp_int);
+			WRW_HARPOON((ioport + hp_intstat),
+				    (FIFO | TIMEOUT | RESET | SCAM_SEL));
+			bm_status = 0;
 
+			if (result) {
 
-      else if (hp_int & ICMD_COMP) {
+				MENABLE_INT(ioport);
+				return (result);
+			}
+		}
 
-         if ( !(hp_int & BUS_FREE) ) {
-            /* Wait for the BusFree before starting a new command.  We
-               must also check for being reselected since the BusFree
-               may not show up if another device reselects us in 1.5us or
-               less.  SRR Wednesday, 3/8/1995.
-	         */
-	   while (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL))) ;
-	 }
+		else if (hp_int & ICMD_COMP) {
+
+			if (!(hp_int & BUS_FREE)) {
+				/* Wait for the BusFree before starting a new command.  We
+				   must also check for being reselected since the BusFree
+				   may not show up if another device reselects us in 1.5us or
+				   less.  SRR Wednesday, 3/8/1995.
+				 */
+				while (!
+				       (RDW_HARPOON((ioport + hp_intstat)) &
+					(BUS_FREE | RSEL))) ;
+			}
 
-         if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
+			if (((struct sccb_card *)pCurrCard)->
+			    globalFlags & F_HOST_XFER_ACT)
 
-            FPT_phaseChkFifo(ioport, thisCard);
+				FPT_phaseChkFifo(ioport, thisCard);
 
 /*         WRW_HARPOON((ioport+hp_intstat),
             (BUS_FREE | ICMD_COMP | ITAR_DISC | XFER_CNT_0));
          */
 
-		 WRW_HARPOON((ioport+hp_intstat), CLR_ALL_INT_1);
-
-         FPT_autoCmdCmplt(ioport,thisCard);
-
-         }
-
-
-      else if (hp_int & ITAR_DISC)
-         {
-
-         if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
-
-            FPT_phaseChkFifo(ioport, thisCard);
-
-            }
-
-         if (RD_HARPOON(ioport+hp_gp_reg_1) == SMSAVE_DATA_PTR) {
-
-            WR_HARPOON(ioport+hp_gp_reg_1, 0x00);
-            currSCCB->Sccb_XferState |= F_NO_DATA_YET;
+			WRW_HARPOON((ioport + hp_intstat), CLR_ALL_INT_1);
 
-            currSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;
-            }
+			FPT_autoCmdCmplt(ioport, thisCard);
 
-         currSCCB->Sccb_scsistat = DISCONNECT_ST;
-         FPT_queueDisconnect(currSCCB,thisCard);
+		}
 
-            /* Wait for the BusFree before starting a new command.  We
-               must also check for being reselected since the BusFree
-               may not show up if another device reselects us in 1.5us or
-               less.  SRR Wednesday, 3/8/1995.
-             */
-	   while (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL)) &&
-		  !((RDW_HARPOON((ioport+hp_intstat)) & PHASE) &&
-		    RD_HARPOON((ioport+hp_scsisig)) ==
-		    (SCSI_BSY | SCSI_REQ | SCSI_CD | SCSI_MSG | SCSI_IOBIT))) ;
+		else if (hp_int & ITAR_DISC) {
 
-	   /*
-	     The additional loop exit condition above detects a timing problem
-	     with the revision D/E harpoon chips.  The caller should reset the
-	     host adapter to recover when 0xFE is returned.
-	   */
-	   if (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL)))
-	     {
-	       MENABLE_INT(ioport);
-	       return 0xFE;
-	     }
+			if (((struct sccb_card *)pCurrCard)->
+			    globalFlags & F_HOST_XFER_ACT) {
 
-         WRW_HARPOON((ioport+hp_intstat), (BUS_FREE | ITAR_DISC));
+				FPT_phaseChkFifo(ioport, thisCard);
 
+			}
 
-         ((struct sccb_card *)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
+			if (RD_HARPOON(ioport + hp_gp_reg_1) == SMSAVE_DATA_PTR) {
 
-      	}
+				WR_HARPOON(ioport + hp_gp_reg_1, 0x00);
+				currSCCB->Sccb_XferState |= F_NO_DATA_YET;
 
+				currSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;
+			}
 
-      else if (hp_int & RSEL) {
+			currSCCB->Sccb_scsistat = DISCONNECT_ST;
+			FPT_queueDisconnect(currSCCB, thisCard);
+
+			/* Wait for the BusFree before starting a new command.  We
+			   must also check for being reselected since the BusFree
+			   may not show up if another device reselects us in 1.5us or
+			   less.  SRR Wednesday, 3/8/1995.
+			 */
+			while (!
+			       (RDW_HARPOON((ioport + hp_intstat)) &
+				(BUS_FREE | RSEL))
+			       && !((RDW_HARPOON((ioport + hp_intstat)) & PHASE)
+				    && RD_HARPOON((ioport + hp_scsisig)) ==
+				    (SCSI_BSY | SCSI_REQ | SCSI_CD | SCSI_MSG |
+				     SCSI_IOBIT))) ;
+
+			/*
+			   The additional loop exit condition above detects a timing problem
+			   with the revision D/E harpoon chips.  The caller should reset the
+			   host adapter to recover when 0xFE is returned.
+			 */
+			if (!
+			    (RDW_HARPOON((ioport + hp_intstat)) &
+			     (BUS_FREE | RSEL))) {
+				MENABLE_INT(ioport);
+				return 0xFE;
+			}
 
-         WRW_HARPOON((ioport+hp_intstat), (PROG_HLT | RSEL | PHASE | BUS_FREE));
+			WRW_HARPOON((ioport + hp_intstat),
+				    (BUS_FREE | ITAR_DISC));
 
-         if (RDW_HARPOON((ioport+hp_intstat)) & ITAR_DISC)
-		      {
-            if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
-			      {
-               FPT_phaseChkFifo(ioport, thisCard);
-               }
+			((struct sccb_card *)pCurrCard)->globalFlags |=
+			    F_NEW_SCCB_CMD;
 
-            if (RD_HARPOON(ioport+hp_gp_reg_1) == SMSAVE_DATA_PTR)
-			      {
-               WR_HARPOON(ioport+hp_gp_reg_1, 0x00);
-               currSCCB->Sccb_XferState |= F_NO_DATA_YET;
-               currSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;
-               }
+		}
 
-            WRW_HARPOON((ioport+hp_intstat), (BUS_FREE | ITAR_DISC));
-            currSCCB->Sccb_scsistat = DISCONNECT_ST;
-            FPT_queueDisconnect(currSCCB,thisCard);
-            }
+		else if (hp_int & RSEL) {
 
-         FPT_sres(ioport,thisCard,((struct sccb_card *)pCurrCard));
-         FPT_phaseDecode(ioport,thisCard);
+			WRW_HARPOON((ioport + hp_intstat),
+				    (PROG_HLT | RSEL | PHASE | BUS_FREE));
 
-         }
+			if (RDW_HARPOON((ioport + hp_intstat)) & ITAR_DISC) {
+				if (((struct sccb_card *)pCurrCard)->
+				    globalFlags & F_HOST_XFER_ACT) {
+					FPT_phaseChkFifo(ioport, thisCard);
+				}
 
+				if (RD_HARPOON(ioport + hp_gp_reg_1) ==
+				    SMSAVE_DATA_PTR) {
+					WR_HARPOON(ioport + hp_gp_reg_1, 0x00);
+					currSCCB->Sccb_XferState |=
+					    F_NO_DATA_YET;
+					currSCCB->Sccb_savedATC =
+					    currSCCB->Sccb_ATC;
+				}
 
-      else if ((hp_int & IDO_STRT) && (!(hp_int & BUS_FREE)))
-         {
+				WRW_HARPOON((ioport + hp_intstat),
+					    (BUS_FREE | ITAR_DISC));
+				currSCCB->Sccb_scsistat = DISCONNECT_ST;
+				FPT_queueDisconnect(currSCCB, thisCard);
+			}
 
-            WRW_HARPOON((ioport+hp_intstat), (IDO_STRT | XFER_CNT_0));
-            FPT_phaseDecode(ioport,thisCard);
+			FPT_sres(ioport, thisCard,
+				 ((struct sccb_card *)pCurrCard));
+			FPT_phaseDecode(ioport, thisCard);
 
-         }
+		}
 
+		else if ((hp_int & IDO_STRT) && (!(hp_int & BUS_FREE))) {
 
-      else if ( (hp_int & IUNKWN) || (hp_int & PROG_HLT) )
-		   {
-	 	   WRW_HARPOON((ioport+hp_intstat), (PHASE | IUNKWN | PROG_HLT));
-	 	   if ((RD_HARPOON(ioport+hp_prgmcnt_0) & (unsigned char)0x3f)< (unsigned char)SELCHK)
-	    		{
-	    		FPT_phaseDecode(ioport,thisCard);
-	    		}
-	 	   else
-	    		{
-   /* Harpoon problem some SCSI target device respond to selection
-   with short BUSY pulse (<400ns) this will make the Harpoon is not able
-   to latch the correct Target ID into reg. x53.
-   The work around require to correct this reg. But when write to this
-   reg. (0x53) also increment the FIFO write addr reg (0x6f), thus we
-   need to read this reg first then restore it later. After update to 0x53 */
+			WRW_HARPOON((ioport + hp_intstat),
+				    (IDO_STRT | XFER_CNT_0));
+			FPT_phaseDecode(ioport, thisCard);
 
-	    		i = (unsigned char)(RD_HARPOON(ioport+hp_fifowrite));
-	    		target = (unsigned char)(RD_HARPOON(ioport+hp_gp_reg_3));
-	    		WR_HARPOON(ioport+hp_xfer_pad, (unsigned char) ID_UNLOCK);
-	    		WR_HARPOON(ioport+hp_select_id, (unsigned char)(target | target<<4));
-	    		WR_HARPOON(ioport+hp_xfer_pad, (unsigned char) 0x00);
-	    		WR_HARPOON(ioport+hp_fifowrite, i);
-	    		WR_HARPOON(ioport+hp_autostart_3, (AUTO_IMMED+TAG_STRT));
-	    		}
-	 	   }
+		}
 
-      else if (hp_int & XFER_CNT_0) {
+		else if ((hp_int & IUNKWN) || (hp_int & PROG_HLT)) {
+			WRW_HARPOON((ioport + hp_intstat),
+				    (PHASE | IUNKWN | PROG_HLT));
+			if ((RD_HARPOON(ioport + hp_prgmcnt_0) & (unsigned char)
+			     0x3f) < (unsigned char)SELCHK) {
+				FPT_phaseDecode(ioport, thisCard);
+			} else {
+				/* Harpoon problem some SCSI target device respond to selection
+				   with short BUSY pulse (<400ns) this will make the Harpoon is not able
+				   to latch the correct Target ID into reg. x53.
+				   The work around require to correct this reg. But when write to this
+				   reg. (0x53) also increment the FIFO write addr reg (0x6f), thus we
+				   need to read this reg first then restore it later. After update to 0x53 */
+
+				i = (unsigned
+				     char)(RD_HARPOON(ioport + hp_fifowrite));
+				target =
+				    (unsigned
+				     char)(RD_HARPOON(ioport + hp_gp_reg_3));
+				WR_HARPOON(ioport + hp_xfer_pad,
+					   (unsigned char)ID_UNLOCK);
+				WR_HARPOON(ioport + hp_select_id,
+					   (unsigned char)(target | target <<
+							   4));
+				WR_HARPOON(ioport + hp_xfer_pad,
+					   (unsigned char)0x00);
+				WR_HARPOON(ioport + hp_fifowrite, i);
+				WR_HARPOON(ioport + hp_autostart_3,
+					   (AUTO_IMMED + TAG_STRT));
+			}
+		}
 
-         WRW_HARPOON((ioport+hp_intstat), XFER_CNT_0);
+		else if (hp_int & XFER_CNT_0) {
 
-         FPT_schkdd(ioport,thisCard);
+			WRW_HARPOON((ioport + hp_intstat), XFER_CNT_0);
 
-         }
+			FPT_schkdd(ioport, thisCard);
 
+		}
 
-      else if (hp_int & BUS_FREE) {
+		else if (hp_int & BUS_FREE) {
 
-         WRW_HARPOON((ioport+hp_intstat), BUS_FREE);
+			WRW_HARPOON((ioport + hp_intstat), BUS_FREE);
 
-        	if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
+			if (((struct sccb_card *)pCurrCard)->
+			    globalFlags & F_HOST_XFER_ACT) {
 
-           	FPT_hostDataXferAbort(ioport,thisCard,currSCCB);
-				}
-
-         FPT_phaseBusFree(ioport,thisCard);
+				FPT_hostDataXferAbort(ioport, thisCard,
+						      currSCCB);
 			}
 
+			FPT_phaseBusFree(ioport, thisCard);
+		}
 
-      else if (hp_int & ITICKLE) {
-
-         WRW_HARPOON((ioport+hp_intstat), ITICKLE);
-         ((struct sccb_card *)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
-         }
-
-
-
-      if (((struct sccb_card *)pCurrCard)->globalFlags & F_NEW_SCCB_CMD) {
+		else if (hp_int & ITICKLE) {
 
+			WRW_HARPOON((ioport + hp_intstat), ITICKLE);
+			((struct sccb_card *)pCurrCard)->globalFlags |=
+			    F_NEW_SCCB_CMD;
+		}
 
-         ((struct sccb_card *)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
+		if (((struct sccb_card *)pCurrCard)->
+		    globalFlags & F_NEW_SCCB_CMD) {
 
+			((struct sccb_card *)pCurrCard)->globalFlags &=
+			    ~F_NEW_SCCB_CMD;
 
-         if (((struct sccb_card *)pCurrCard)->currentSCCB == NULL) {
+			if (((struct sccb_card *)pCurrCard)->currentSCCB ==
+			    NULL) {
 
-            FPT_queueSearchSelect(((struct sccb_card *)pCurrCard),thisCard);
-            }
+				FPT_queueSearchSelect(((struct sccb_card *)
+						       pCurrCard), thisCard);
+			}
 
-         if (((struct sccb_card *)pCurrCard)->currentSCCB != NULL) {
-            ((struct sccb_card *)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
-            FPT_ssel(ioport,thisCard);
-            }
+			if (((struct sccb_card *)pCurrCard)->currentSCCB !=
+			    NULL) {
+				((struct sccb_card *)pCurrCard)->globalFlags &=
+				    ~F_NEW_SCCB_CMD;
+				FPT_ssel(ioport, thisCard);
+			}
 
-         break;
+			break;
 
-         }
+		}
 
-      }  /*end while */
+	}			/*end while */
 
-   MENABLE_INT(ioport);
+	MENABLE_INT(ioport);
 
-   return(0);
+	return (0);
 }
 
 /*---------------------------------------------------------------------
@@ -2154,150 +2010,149 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
  *              processing time.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
-				 struct sccb_card * pCurrCard, unsigned short p_int)
+static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port,
+					 unsigned char p_card,
+					 struct sccb_card *pCurrCard,
+					 unsigned short p_int)
 {
-   unsigned char temp, ScamFlg;
-   struct sccb_mgr_tar_info * currTar_Info;
-   struct nvram_info * pCurrNvRam;
-
-
-   if (RD_HARPOON(p_port+hp_ext_status) &
-         (BM_FORCE_OFF | PCI_DEV_TMOUT | BM_PARITY_ERR | PIO_OVERRUN) )
-      {
-
-      if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
-         {
+	unsigned char temp, ScamFlg;
+	struct sccb_mgr_tar_info *currTar_Info;
+	struct nvram_info *pCurrNvRam;
 
-         FPT_hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
-         }
+	if (RD_HARPOON(p_port + hp_ext_status) &
+	    (BM_FORCE_OFF | PCI_DEV_TMOUT | BM_PARITY_ERR | PIO_OVERRUN)) {
 
-      if (RD_HARPOON(p_port+hp_pci_stat_cfg) & REC_MASTER_ABORT)
+		if (pCurrCard->globalFlags & F_HOST_XFER_ACT) {
 
-         {
-         WR_HARPOON(p_port+hp_pci_stat_cfg,
-            (RD_HARPOON(p_port+hp_pci_stat_cfg) & ~REC_MASTER_ABORT));
-
-         WR_HARPOON(p_port+hp_host_blk_cnt, 0x00);
-
-         }
-
-      if (pCurrCard->currentSCCB != NULL)
-         {
+			FPT_hostDataXferAbort(p_port, p_card,
+					      pCurrCard->currentSCCB);
+		}
 
-         if (!pCurrCard->currentSCCB->HostStatus)
-            pCurrCard->currentSCCB->HostStatus = SCCB_BM_ERR;
+		if (RD_HARPOON(p_port + hp_pci_stat_cfg) & REC_MASTER_ABORT)
+		{
+			WR_HARPOON(p_port + hp_pci_stat_cfg,
+				   (RD_HARPOON(p_port + hp_pci_stat_cfg) &
+				    ~REC_MASTER_ABORT));
 
-         FPT_sxfrp(p_port,p_card);
+			WR_HARPOON(p_port + hp_host_blk_cnt, 0x00);
 
-	     temp = (unsigned char)(RD_HARPOON(p_port+hp_ee_ctrl) &
-							(EXT_ARB_ACK | SCSI_TERM_ENA_H));
-      	WR_HARPOON(p_port+hp_ee_ctrl, ((unsigned char)temp | SEE_MS | SEE_CS));
-         WR_HARPOON(p_port+hp_ee_ctrl, temp);
+		}
 
-         if (!(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
-            {
-            FPT_phaseDecode(p_port,p_card);
-            }
-         }
-      }
+		if (pCurrCard->currentSCCB != NULL) {
 
+			if (!pCurrCard->currentSCCB->HostStatus)
+				pCurrCard->currentSCCB->HostStatus =
+				    SCCB_BM_ERR;
 
-   else if (p_int & RESET)
-         {
+			FPT_sxfrp(p_port, p_card);
 
-				WR_HARPOON(p_port+hp_clkctrl_0, CLKCTRL_DEFAULT);
-				WR_HARPOON(p_port+hp_sys_ctrl, 0x00);
-           if (pCurrCard->currentSCCB != NULL) {
+			temp = (unsigned char)(RD_HARPOON(p_port + hp_ee_ctrl) &
+					       (EXT_ARB_ACK | SCSI_TERM_ENA_H));
+			WR_HARPOON(p_port + hp_ee_ctrl,
+				   ((unsigned char)temp | SEE_MS | SEE_CS));
+			WR_HARPOON(p_port + hp_ee_ctrl, temp);
 
-               if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
+			if (!
+			    (RDW_HARPOON((p_port + hp_intstat)) &
+			     (BUS_FREE | RESET))) {
+				FPT_phaseDecode(p_port, p_card);
+			}
+		}
+	}
 
-               FPT_hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
-               }
+	else if (p_int & RESET) {
 
+		WR_HARPOON(p_port + hp_clkctrl_0, CLKCTRL_DEFAULT);
+		WR_HARPOON(p_port + hp_sys_ctrl, 0x00);
+		if (pCurrCard->currentSCCB != NULL) {
 
-           DISABLE_AUTO(p_port);
+			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
 
-           FPT_sresb(p_port,p_card);
+				FPT_hostDataXferAbort(p_port, p_card,
+						      pCurrCard->currentSCCB);
+		}
 
-           while(RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST) {}
+		DISABLE_AUTO(p_port);
 
-				pCurrNvRam = pCurrCard->pNvRamInfo;
-				if(pCurrNvRam){
-					ScamFlg = pCurrNvRam->niScamConf;
-				}
-				else{
-				   ScamFlg = (unsigned char) FPT_utilEERead(p_port, SCAM_CONFIG/2);
-				}
+		FPT_sresb(p_port, p_card);
 
-           FPT_XbowInit(p_port, ScamFlg);
+		while (RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST) {
+		}
 
-               FPT_scini(p_card, pCurrCard->ourId, 0);
+		pCurrNvRam = pCurrCard->pNvRamInfo;
+		if (pCurrNvRam) {
+			ScamFlg = pCurrNvRam->niScamConf;
+		} else {
+			ScamFlg =
+			    (unsigned char)FPT_utilEERead(p_port,
+							  SCAM_CONFIG / 2);
+		}
 
-           return(0xFF);
-         }
+		FPT_XbowInit(p_port, ScamFlg);
 
+		FPT_scini(p_card, pCurrCard->ourId, 0);
 
-   else if (p_int & FIFO) {
+		return (0xFF);
+	}
 
-      WRW_HARPOON((p_port+hp_intstat), FIFO);
+	else if (p_int & FIFO) {
 
-      if (pCurrCard->currentSCCB != NULL)
-         FPT_sxfrp(p_port,p_card);
-      }
+		WRW_HARPOON((p_port + hp_intstat), FIFO);
 
-   else if (p_int & TIMEOUT)
-      {
+		if (pCurrCard->currentSCCB != NULL)
+			FPT_sxfrp(p_port, p_card);
+	}
 
-      DISABLE_AUTO(p_port);
+	else if (p_int & TIMEOUT) {
 
-      WRW_HARPOON((p_port+hp_intstat),
-		  (PROG_HLT | TIMEOUT | SEL |BUS_FREE | PHASE | IUNKWN));
+		DISABLE_AUTO(p_port);
 
-      pCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;
+		WRW_HARPOON((p_port + hp_intstat),
+			    (PROG_HLT | TIMEOUT | SEL | BUS_FREE | PHASE |
+			     IUNKWN));
 
+		pCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;
 
-		currTar_Info = &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
-		if((pCurrCard->globalFlags & F_CONLUN_IO) &&
-			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	      currTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] = 0;
+		currTar_Info =
+		    &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
+		if ((pCurrCard->globalFlags & F_CONLUN_IO)
+		    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=
+			TAG_Q_TRYING))
+			currTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] =
+			    0;
 		else
-	      currTar_Info->TarLUNBusy[0] = 0;
+			currTar_Info->TarLUNBusy[0] = 0;
 
+		if (currTar_Info->TarEEValue & EE_SYNC_MASK) {
+			currTar_Info->TarSyncCtrl = 0;
+			currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+		}
 
-      if (currTar_Info->TarEEValue & EE_SYNC_MASK)
-         {
-	       currTar_Info->TarSyncCtrl = 0;
-         currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
-         }
+		if (currTar_Info->TarEEValue & EE_WIDE_SCSI) {
+			currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+		}
 
-      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
-         {
-         currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
-         }
+		FPT_sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,
+			    currTar_Info);
 
-      FPT_sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,currTar_Info);
+		FPT_queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);
 
-      FPT_queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);
+	}
 
-      }
+	else if (p_int & SCAM_SEL) {
 
-   else if (p_int & SCAM_SEL)
-      {
+		FPT_scarb(p_port, LEVEL2_TAR);
+		FPT_scsel(p_port);
+		FPT_scasid(p_card, p_port);
 
-      FPT_scarb(p_port,LEVEL2_TAR);
-      FPT_scsel(p_port);
-      FPT_scasid(p_card, p_port);
+		FPT_scbusf(p_port);
 
-      FPT_scbusf(p_port);
-
-      WRW_HARPOON((p_port+hp_intstat), SCAM_SEL);
-      }
+		WRW_HARPOON((p_port + hp_intstat), SCAM_SEL);
+	}
 
-   return(0x00);
+	return (0x00);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: SccbMgrTableInit
@@ -2308,21 +2163,19 @@ static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_c
 
 static void FPT_SccbMgrTableInitAll()
 {
-   unsigned char thisCard;
+	unsigned char thisCard;
 
-   for (thisCard = 0; thisCard < MAX_CARDS; thisCard++)
-      {
-      FPT_SccbMgrTableInitCard(&FPT_BL_Card[thisCard],thisCard);
+	for (thisCard = 0; thisCard < MAX_CARDS; thisCard++) {
+		FPT_SccbMgrTableInitCard(&FPT_BL_Card[thisCard], thisCard);
 
-      FPT_BL_Card[thisCard].ioPort      = 0x00;
-      FPT_BL_Card[thisCard].cardInfo    = NULL;
-      FPT_BL_Card[thisCard].cardIndex   = 0xFF;
-      FPT_BL_Card[thisCard].ourId       = 0x00;
-		FPT_BL_Card[thisCard].pNvRamInfo	= NULL;
-      }
+		FPT_BL_Card[thisCard].ioPort = 0x00;
+		FPT_BL_Card[thisCard].cardInfo = NULL;
+		FPT_BL_Card[thisCard].cardIndex = 0xFF;
+		FPT_BL_Card[thisCard].ourId = 0x00;
+		FPT_BL_Card[thisCard].pNvRamInfo = NULL;
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: SccbMgrTableInit
@@ -2331,33 +2184,30 @@ static void FPT_SccbMgrTableInitAll()
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_SccbMgrTableInitCard(struct sccb_card * pCurrCard, unsigned char p_card)
+static void FPT_SccbMgrTableInitCard(struct sccb_card *pCurrCard,
+				     unsigned char p_card)
 {
-   unsigned char scsiID, qtag;
+	unsigned char scsiID, qtag;
 
-	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
-	{
+	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {
 		FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
 	}
 
-   for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++)
-      {
-      FPT_sccbMgrTbl[p_card][scsiID].TarStatus = 0;
-      FPT_sccbMgrTbl[p_card][scsiID].TarEEValue = 0;
-      FPT_SccbMgrTableInitTarget(p_card, scsiID);
-      }
+	for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++) {
+		FPT_sccbMgrTbl[p_card][scsiID].TarStatus = 0;
+		FPT_sccbMgrTbl[p_card][scsiID].TarEEValue = 0;
+		FPT_SccbMgrTableInitTarget(p_card, scsiID);
+	}
 
-   pCurrCard->scanIndex = 0x00;
-   pCurrCard->currentSCCB = NULL;
-   pCurrCard->globalFlags = 0x00;
-   pCurrCard->cmdCounter  = 0x00;
+	pCurrCard->scanIndex = 0x00;
+	pCurrCard->currentSCCB = NULL;
+	pCurrCard->globalFlags = 0x00;
+	pCurrCard->cmdCounter = 0x00;
 	pCurrCard->tagQ_Lst = 0x01;
-	pCurrCard->discQCount = 0; 
-
+	pCurrCard->discQCount = 0;
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: SccbMgrTableInit
@@ -2366,11 +2216,12 @@ static void FPT_SccbMgrTableInitCard(struct sccb_card * pCurrCard, unsigned char
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char target)
+static void FPT_SccbMgrTableInitTarget(unsigned char p_card,
+				       unsigned char target)
 {
 
 	unsigned char lun, qtag;
-	struct sccb_mgr_tar_info * currTar_Info;
+	struct sccb_mgr_tar_info *currTar_Info;
 
 	currTar_Info = &FPT_sccbMgrTbl[p_card][target];
 
@@ -2382,19 +2233,15 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
 	currTar_Info->TarTagQ_Cnt = 0;
 	currTar_Info->TarLUN_CA = 0;
 
-
-	for (lun = 0; lun < MAX_LUN; lun++)
-	{
+	for (lun = 0; lun < MAX_LUN; lun++) {
 		currTar_Info->TarLUNBusy[lun] = 0;
 		currTar_Info->LunDiscQ_Idx[lun] = 0;
 	}
 
-	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
-	{
-		if(FPT_BL_Card[p_card].discQ_Tbl[qtag] != NULL)
-		{
-			if(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == target)
-			{
+	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {
+		if (FPT_BL_Card[p_card].discQ_Tbl[qtag] != NULL) {
+			if (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID ==
+			    target) {
 				FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
 				FPT_BL_Card[p_card].discQCount--;
 			}
@@ -2402,7 +2249,6 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
 	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: sfetm
@@ -2412,71 +2258,66 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sfm(unsigned long port, struct sccb * pCurrSCCB)
+static unsigned char FPT_sfm(unsigned long port, struct sccb *pCurrSCCB)
 {
 	unsigned char message;
 	unsigned short TimeOutLoop;
 
 	TimeOutLoop = 0;
-	while( (!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
-			(TimeOutLoop++ < 20000) ){}
-
-
-	WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+	while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
+	       (TimeOutLoop++ < 20000)) {
+	}
 
-	message = RD_HARPOON(port+hp_scsidata_0);
+	WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
 
-	WR_HARPOON(port+hp_scsisig, SCSI_ACK + S_MSGI_PH);
+	message = RD_HARPOON(port + hp_scsidata_0);
 
+	WR_HARPOON(port + hp_scsisig, SCSI_ACK + S_MSGI_PH);
 
 	if (TimeOutLoop > 20000)
-		message = 0x00;   /* force message byte = 0 if Time Out on Req */
-
-	if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
-		(RD_HARPOON(port+hp_addstat) & SCSI_PAR_ERR))
-	{
-		WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
-		WR_HARPOON(port+hp_xferstat, 0);
-		WR_HARPOON(port+hp_fiforead, 0);
-		WR_HARPOON(port+hp_fifowrite, 0);
-		if (pCurrSCCB != NULL)
-		{
+		message = 0x00;	/* force message byte = 0 if Time Out on Req */
+
+	if ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&
+	    (RD_HARPOON(port + hp_addstat) & SCSI_PAR_ERR)) {
+		WR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));
+		WR_HARPOON(port + hp_xferstat, 0);
+		WR_HARPOON(port + hp_fiforead, 0);
+		WR_HARPOON(port + hp_fifowrite, 0);
+		if (pCurrSCCB != NULL) {
 			pCurrSCCB->Sccb_scsimsg = SMPARITY;
 		}
 		message = 0x00;
-		do
-		{
+		do {
 			ACCEPT_MSG_ATN(port);
 			TimeOutLoop = 0;
-			while( (!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
-				(TimeOutLoop++ < 20000) ){}
-			if (TimeOutLoop > 20000)
-			{
-				WRW_HARPOON((port+hp_intstat), PARITY);
-				return(message);
+			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
+			       (TimeOutLoop++ < 20000)) {
 			}
-			if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) != S_MSGI_PH)
-			{
-				WRW_HARPOON((port+hp_intstat), PARITY);
-				return(message);
+			if (TimeOutLoop > 20000) {
+				WRW_HARPOON((port + hp_intstat), PARITY);
+				return (message);
+			}
+			if ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) !=
+			    S_MSGI_PH) {
+				WRW_HARPOON((port + hp_intstat), PARITY);
+				return (message);
 			}
-			WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+			WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
 
-			RD_HARPOON(port+hp_scsidata_0);
+			RD_HARPOON(port + hp_scsidata_0);
 
-			WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+			WR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));
 
-		}while(1);
+		} while (1);
 
 	}
-	WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
-	WR_HARPOON(port+hp_xferstat, 0);
-	WR_HARPOON(port+hp_fiforead, 0);
-	WR_HARPOON(port+hp_fifowrite, 0);
-	return(message);
+	WR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));
+	WR_HARPOON(port + hp_xferstat, 0);
+	WR_HARPOON(port + hp_fiforead, 0);
+	WR_HARPOON(port + hp_fifowrite, 0);
+	return (message);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_ssel
@@ -2488,99 +2329,87 @@ static unsigned char FPT_sfm(unsigned long port, struct sccb * pCurrSCCB)
 static void FPT_ssel(unsigned long port, unsigned char p_card)
 {
 
-   unsigned char auto_loaded, i, target, *theCCB;
-
-   unsigned long cdb_reg;
-   struct sccb_card * CurrCard;
-   struct sccb * currSCCB;
-   struct sccb_mgr_tar_info * currTar_Info;
-   unsigned char lastTag, lun;
+	unsigned char auto_loaded, i, target, *theCCB;
 
-   CurrCard = &FPT_BL_Card[p_card];
-   currSCCB = CurrCard->currentSCCB;
-   target = currSCCB->TargID;
-   currTar_Info = &FPT_sccbMgrTbl[p_card][target];
-   lastTag = CurrCard->tagQ_Lst;
+	unsigned long cdb_reg;
+	struct sccb_card *CurrCard;
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
+	unsigned char lastTag, lun;
 
-   ARAM_ACCESS(port);
+	CurrCard = &FPT_BL_Card[p_card];
+	currSCCB = CurrCard->currentSCCB;
+	target = currSCCB->TargID;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][target];
+	lastTag = CurrCard->tagQ_Lst;
 
+	ARAM_ACCESS(port);
 
 	if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)
 		currSCCB->ControlByte &= ~F_USE_CMD_Q;
 
-	if(((CurrCard->globalFlags & F_CONLUN_IO) && 
-		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+	if (((CurrCard->globalFlags & F_CONLUN_IO) &&
+	     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 
-	   lun = currSCCB->Lun;
+		lun = currSCCB->Lun;
 	else
 		lun = 0;
 
+	if (CurrCard->globalFlags & F_TAG_STARTED) {
+		if (!(currSCCB->ControlByte & F_USE_CMD_Q)) {
+			if ((currTar_Info->TarLUN_CA == 0)
+			    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
+				== TAG_Q_TRYING)) {
+
+				if (currTar_Info->TarTagQ_Cnt != 0) {
+					currTar_Info->TarLUNBusy[lun] = 1;
+					FPT_queueSelectFail(CurrCard, p_card);
+					SGRAM_ACCESS(port);
+					return;
+				}
 
-   if (CurrCard->globalFlags & F_TAG_STARTED)
-      {
-      if (!(currSCCB->ControlByte & F_USE_CMD_Q))
-         {
-      	if ((currTar_Info->TarLUN_CA == 0)
-      	    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
-      	    == TAG_Q_TRYING))
-            {
-
-	         if (currTar_Info->TarTagQ_Cnt !=0)
-                  {
-         		   currTar_Info->TarLUNBusy[lun] = 1;
-            		FPT_queueSelectFail(CurrCard,p_card);
-					   SGRAM_ACCESS(port);
-         		   return;
-         		   }
-
-            else {
-         		  currTar_Info->TarLUNBusy[lun] = 1;
-         		  }
-
-   	      }  /*End non-tagged */
-
-	      else {
-	         currTar_Info->TarLUNBusy[lun] = 1;
-	         }
-
-	      }  /*!Use cmd Q Tagged */
-
-	   else {
-   	     if (currTar_Info->TarLUN_CA == 1)
-               {
-      	      FPT_queueSelectFail(CurrCard,p_card);
-				   SGRAM_ACCESS(port);
-      	      return;
-	            }
-
-	        currTar_Info->TarLUNBusy[lun] = 1;
+				else {
+					currTar_Info->TarLUNBusy[lun] = 1;
+				}
 
-   	     }  /*else use cmd Q tagged */
+			}
+			/*End non-tagged */
+			else {
+				currTar_Info->TarLUNBusy[lun] = 1;
+			}
 
-      }  /*if glob tagged started */
+		}
+		/*!Use cmd Q Tagged */
+		else {
+			if (currTar_Info->TarLUN_CA == 1) {
+				FPT_queueSelectFail(CurrCard, p_card);
+				SGRAM_ACCESS(port);
+				return;
+			}
 
-   else {
-        currTar_Info->TarLUNBusy[lun] = 1;
-        }
+			currTar_Info->TarLUNBusy[lun] = 1;
 
+		}		/*else use cmd Q tagged */
 
+	}
+	/*if glob tagged started */
+	else {
+		currTar_Info->TarLUNBusy[lun] = 1;
+	}
 
-	if((((CurrCard->globalFlags & F_CONLUN_IO) && 
-		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)) 
-		|| (!(currSCCB->ControlByte & F_USE_CMD_Q))))
-	{
-		if(CurrCard->discQCount >= QUEUE_DEPTH)
-		{
+	if ((((CurrCard->globalFlags & F_CONLUN_IO) &&
+	      ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	     || (!(currSCCB->ControlByte & F_USE_CMD_Q)))) {
+		if (CurrCard->discQCount >= QUEUE_DEPTH) {
 			currTar_Info->TarLUNBusy[lun] = 1;
-			FPT_queueSelectFail(CurrCard,p_card);
+			FPT_queueSelectFail(CurrCard, p_card);
 			SGRAM_ACCESS(port);
 			return;
 		}
-		for (i = 1; i < QUEUE_DEPTH; i++)
-		{
-			if (++lastTag >= QUEUE_DEPTH) lastTag = 1;
-			if (CurrCard->discQ_Tbl[lastTag] == NULL)
-			{
+		for (i = 1; i < QUEUE_DEPTH; i++) {
+			if (++lastTag >= QUEUE_DEPTH)
+				lastTag = 1;
+			if (CurrCard->discQ_Tbl[lastTag] == NULL) {
 				CurrCard->tagQ_Lst = lastTag;
 				currTar_Info->LunDiscQ_Idx[lun] = lastTag;
 				CurrCard->discQ_Tbl[lastTag] = currSCCB;
@@ -2588,206 +2417,206 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
 				break;
 			}
 		}
-		if(i == QUEUE_DEPTH)
-		{
+		if (i == QUEUE_DEPTH) {
 			currTar_Info->TarLUNBusy[lun] = 1;
-			FPT_queueSelectFail(CurrCard,p_card);
+			FPT_queueSelectFail(CurrCard, p_card);
 			SGRAM_ACCESS(port);
 			return;
 		}
 	}
 
+	auto_loaded = 0;
 
+	WR_HARPOON(port + hp_select_id, target);
+	WR_HARPOON(port + hp_gp_reg_3, target);	/* Use by new automation logic */
 
-   auto_loaded = 0;
-
-   WR_HARPOON(port+hp_select_id, target);
-   WR_HARPOON(port+hp_gp_reg_3, target);  /* Use by new automation logic */
+	if (currSCCB->OperationCode == RESET_COMMAND) {
+		WRW_HARPOON((port + ID_MSG_STRT), (MPM_OP + AMSG_OUT +
+						   (currSCCB->
+						    Sccb_idmsg & ~DISC_PRIV)));
 
-   if (currSCCB->OperationCode == RESET_COMMAND) {
-      WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+
-               	 (currSCCB->Sccb_idmsg & ~DISC_PRIV)));
+		WRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + NP);
 
-      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+NP);
+		currSCCB->Sccb_scsimsg = SMDEV_RESET;
 
-      currSCCB->Sccb_scsimsg = SMDEV_RESET;
+		WR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));
+		auto_loaded = 1;
+		currSCCB->Sccb_scsistat = SELECT_BDR_ST;
 
-      WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-      auto_loaded = 1;
-      currSCCB->Sccb_scsistat = SELECT_BDR_ST;
-
-      if (currTar_Info->TarEEValue & EE_SYNC_MASK)
-         {
-	       currTar_Info->TarSyncCtrl = 0;
-	      currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
-	      }
-
-      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
-         {
-      	currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
-      	}
-
-      FPT_sssyncv(port, target, NARROW_SCSI,currTar_Info);
-      FPT_SccbMgrTableInitTarget(p_card, target);
+		if (currTar_Info->TarEEValue & EE_SYNC_MASK) {
+			currTar_Info->TarSyncCtrl = 0;
+			currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+		}
 
-      }
+		if (currTar_Info->TarEEValue & EE_WIDE_SCSI) {
+			currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+		}
 
-		else if(currSCCB->Sccb_scsistat == ABORT_ST)
-		{
-			WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+
-								(currSCCB->Sccb_idmsg & ~DISC_PRIV)));
+		FPT_sssyncv(port, target, NARROW_SCSI, currTar_Info);
+		FPT_SccbMgrTableInitTarget(p_card, target);
 
-      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
+	}
 
-			WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+
-								(((unsigned char)(currSCCB->ControlByte & TAG_TYPE_MASK)
-								>> 6) | (unsigned char)0x20)));
-			WRW_HARPOON((port+SYNC_MSGS+2),
-							(MPM_OP+AMSG_OUT+currSCCB->Sccb_tag));
-			WRW_HARPOON((port+SYNC_MSGS+4), (BRH_OP+ALWAYS+NP ));
+	else if (currSCCB->Sccb_scsistat == ABORT_ST) {
+		WRW_HARPOON((port + ID_MSG_STRT), (MPM_OP + AMSG_OUT +
+						   (currSCCB->
+						    Sccb_idmsg & ~DISC_PRIV)));
 
-			WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-			auto_loaded = 1;
-		
-		}
+		WRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);
 
-   else if (!(currTar_Info->TarStatus & WIDE_NEGOCIATED))  {
-      auto_loaded = FPT_siwidn(port,p_card);
-      currSCCB->Sccb_scsistat = SELECT_WN_ST;
-      }
+		WRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT +
+						     (((unsigned
+							char)(currSCCB->
+							      ControlByte &
+							      TAG_TYPE_MASK)
+						       >> 6) | (unsigned char)
+						      0x20)));
+		WRW_HARPOON((port + SYNC_MSGS + 2),
+			    (MPM_OP + AMSG_OUT + currSCCB->Sccb_tag));
+		WRW_HARPOON((port + SYNC_MSGS + 4), (BRH_OP + ALWAYS + NP));
 
-   else if (!((currTar_Info->TarStatus & TAR_SYNC_MASK)
-      == SYNC_SUPPORTED))  {
-      auto_loaded = FPT_sisyncn(port,p_card, 0);
-      currSCCB->Sccb_scsistat = SELECT_SN_ST;
-      }
+		WR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));
+		auto_loaded = 1;
 
+	}
 
-   if (!auto_loaded)
-      {
+	else if (!(currTar_Info->TarStatus & WIDE_NEGOCIATED)) {
+		auto_loaded = FPT_siwidn(port, p_card);
+		currSCCB->Sccb_scsistat = SELECT_WN_ST;
+	}
 
-      if (currSCCB->ControlByte & F_USE_CMD_Q)
-         {
+	else if (!((currTar_Info->TarStatus & TAR_SYNC_MASK)
+		   == SYNC_SUPPORTED)) {
+		auto_loaded = FPT_sisyncn(port, p_card, 0);
+		currSCCB->Sccb_scsistat = SELECT_SN_ST;
+	}
 
-         CurrCard->globalFlags |= F_TAG_STARTED;
+	if (!auto_loaded) {
 
-         if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
-            == TAG_Q_REJECT)
-            {
-            currSCCB->ControlByte &= ~F_USE_CMD_Q;
+		if (currSCCB->ControlByte & F_USE_CMD_Q) {
 
-            /* Fix up the start instruction with a jump to
-               Non-Tag-CMD handling */
-            WRW_HARPOON((port+ID_MSG_STRT),BRH_OP+ALWAYS+NTCMD);
+			CurrCard->globalFlags |= F_TAG_STARTED;
 
-            WRW_HARPOON((port+NON_TAG_ID_MSG),
-	                     (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
+			if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
+			    == TAG_Q_REJECT) {
+				currSCCB->ControlByte &= ~F_USE_CMD_Q;
 
-	         WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+				/* Fix up the start instruction with a jump to
+				   Non-Tag-CMD handling */
+				WRW_HARPOON((port + ID_MSG_STRT),
+					    BRH_OP + ALWAYS + NTCMD);
 
-	         /* Setup our STATE so we know what happend when
-               the wheels fall off. */
-            currSCCB->Sccb_scsistat = SELECT_ST;
+				WRW_HARPOON((port + NON_TAG_ID_MSG),
+					    (MPM_OP + AMSG_OUT +
+					     currSCCB->Sccb_idmsg));
 
-	         currTar_Info->TarLUNBusy[lun] = 1;
-            }
+				WR_HARPOON(port + hp_autostart_3,
+					   (SELECT + SELCHK_STRT));
 
-         else
-            {
-            WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
+				/* Setup our STATE so we know what happend when
+				   the wheels fall off. */
+				currSCCB->Sccb_scsistat = SELECT_ST;
 
-            WRW_HARPOON((port+ID_MSG_STRT+2), (MPM_OP+AMSG_OUT+
-                        (((unsigned char)(currSCCB->ControlByte & TAG_TYPE_MASK)
-                        >> 6) | (unsigned char)0x20)));
+				currTar_Info->TarLUNBusy[lun] = 1;
+			}
 
-				for (i = 1; i < QUEUE_DEPTH; i++)
-				{
-					if (++lastTag >= QUEUE_DEPTH) lastTag = 1;
-					if (CurrCard->discQ_Tbl[lastTag] == NULL)
-					{
-						WRW_HARPOON((port+ID_MSG_STRT+6),
-							(MPM_OP+AMSG_OUT+lastTag));
+			else {
+				WRW_HARPOON((port + ID_MSG_STRT),
+					    (MPM_OP + AMSG_OUT +
+					     currSCCB->Sccb_idmsg));
+
+				WRW_HARPOON((port + ID_MSG_STRT + 2),
+					    (MPM_OP + AMSG_OUT +
+					     (((unsigned char)(currSCCB->
+							       ControlByte &
+							       TAG_TYPE_MASK)
+					       >> 6) | (unsigned char)0x20)));
+
+				for (i = 1; i < QUEUE_DEPTH; i++) {
+					if (++lastTag >= QUEUE_DEPTH)
+						lastTag = 1;
+					if (CurrCard->discQ_Tbl[lastTag] ==
+					    NULL) {
+						WRW_HARPOON((port +
+							     ID_MSG_STRT + 6),
+							    (MPM_OP + AMSG_OUT +
+							     lastTag));
 						CurrCard->tagQ_Lst = lastTag;
 						currSCCB->Sccb_tag = lastTag;
-						CurrCard->discQ_Tbl[lastTag] = currSCCB;
+						CurrCard->discQ_Tbl[lastTag] =
+						    currSCCB;
 						CurrCard->discQCount++;
 						break;
 					}
 				}
 
+				if (i == QUEUE_DEPTH) {
+					currTar_Info->TarLUNBusy[lun] = 1;
+					FPT_queueSelectFail(CurrCard, p_card);
+					SGRAM_ACCESS(port);
+					return;
+				}
 
-            if ( i == QUEUE_DEPTH )
-               {
-   	         currTar_Info->TarLUNBusy[lun] = 1;
-               FPT_queueSelectFail(CurrCard,p_card);
-				   SGRAM_ACCESS(port);
-   	         return;
-   	         }
-
-            currSCCB->Sccb_scsistat = SELECT_Q_ST;
-
-   	      WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-            }
-         }
-
-      else
-         {
-
-         WRW_HARPOON((port+ID_MSG_STRT),BRH_OP+ALWAYS+NTCMD);
+				currSCCB->Sccb_scsistat = SELECT_Q_ST;
 
-      	WRW_HARPOON((port+NON_TAG_ID_MSG),
-            (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
+				WR_HARPOON(port + hp_autostart_3,
+					   (SELECT + SELCHK_STRT));
+			}
+		}
 
-         currSCCB->Sccb_scsistat = SELECT_ST;
+		else {
 
-         WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-         }
+			WRW_HARPOON((port + ID_MSG_STRT),
+				    BRH_OP + ALWAYS + NTCMD);
 
+			WRW_HARPOON((port + NON_TAG_ID_MSG),
+				    (MPM_OP + AMSG_OUT + currSCCB->Sccb_idmsg));
 
-      theCCB = (unsigned char *)&currSCCB->Cdb[0];
+			currSCCB->Sccb_scsistat = SELECT_ST;
 
-      cdb_reg = port + CMD_STRT;
+			WR_HARPOON(port + hp_autostart_3,
+				   (SELECT + SELCHK_STRT));
+		}
 
-      for (i=0; i < currSCCB->CdbLength; i++)
-         {
-         WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + *theCCB));
-         cdb_reg +=2;
-         theCCB++;
-         }
+		theCCB = (unsigned char *)&currSCCB->Cdb[0];
 
-      if (currSCCB->CdbLength != TWELVE_BYTE_CMD)
-         WRW_HARPOON(cdb_reg, (BRH_OP+ALWAYS+    NP));
+		cdb_reg = port + CMD_STRT;
 
-      }  /* auto_loaded */
+		for (i = 0; i < currSCCB->CdbLength; i++) {
+			WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + *theCCB));
+			cdb_reg += 2;
+			theCCB++;
+		}
 
-   WRW_HARPOON((port+hp_fiforead), (unsigned short) 0x00);
-   WR_HARPOON(port+hp_xferstat, 0x00);
+		if (currSCCB->CdbLength != TWELVE_BYTE_CMD)
+			WRW_HARPOON(cdb_reg, (BRH_OP + ALWAYS + NP));
 
-   WRW_HARPOON((port+hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));
+	}
+	/* auto_loaded */
+	WRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);
+	WR_HARPOON(port + hp_xferstat, 0x00);
 
-   WR_HARPOON(port+hp_portctrl_0,(SCSI_PORT));
+	WRW_HARPOON((port + hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));
 
+	WR_HARPOON(port + hp_portctrl_0, (SCSI_PORT));
 
-   if (!(currSCCB->Sccb_MGRFlags & F_DEV_SELECTED))
-      {
-      WR_HARPOON(port+hp_scsictrl_0, (SEL_TAR | ENA_ATN | ENA_RESEL | ENA_SCAM_SEL));
-      }
-   else
-      {
+	if (!(currSCCB->Sccb_MGRFlags & F_DEV_SELECTED)) {
+		WR_HARPOON(port + hp_scsictrl_0,
+			   (SEL_TAR | ENA_ATN | ENA_RESEL | ENA_SCAM_SEL));
+	} else {
 
 /*      auto_loaded =  (RD_HARPOON(port+hp_autostart_3) & (unsigned char)0x1F);
       auto_loaded |= AUTO_IMMED; */
-      auto_loaded = AUTO_IMMED;
+		auto_loaded = AUTO_IMMED;
 
-      DISABLE_AUTO(port);
+		DISABLE_AUTO(port);
 
-      WR_HARPOON(port+hp_autostart_3, auto_loaded);
-      }
+		WR_HARPOON(port + hp_autostart_3, auto_loaded);
+	}
 
-   SGRAM_ACCESS(port);
+	SGRAM_ACCESS(port);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sres
@@ -2796,303 +2625,276 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sres(unsigned long port, unsigned char p_card, struct sccb_card * pCurrCard)
+static void FPT_sres(unsigned long port, unsigned char p_card,
+		     struct sccb_card *pCurrCard)
 {
 
-   unsigned char our_target, message, lun = 0, tag, msgRetryCount;
-
-
-   struct sccb_mgr_tar_info * currTar_Info;
-	struct sccb * currSCCB;
+	unsigned char our_target, message, lun = 0, tag, msgRetryCount;
 
+	struct sccb_mgr_tar_info *currTar_Info;
+	struct sccb *currSCCB;
 
-
-
-	if(pCurrCard->currentSCCB != NULL)
-	{
-		currTar_Info = &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
+	if (pCurrCard->currentSCCB != NULL) {
+		currTar_Info =
+		    &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
 		DISABLE_AUTO(port);
 
-
-		WR_HARPOON((port+hp_scsictrl_0),(ENA_RESEL | ENA_SCAM_SEL));
-
+		WR_HARPOON((port + hp_scsictrl_0), (ENA_RESEL | ENA_SCAM_SEL));
 
 		currSCCB = pCurrCard->currentSCCB;
-		if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
-		{
+		if (currSCCB->Sccb_scsistat == SELECT_WN_ST) {
 			currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
 			currSCCB->Sccb_scsistat = BUS_FREE_ST;
 		}
-		if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
-		{
+		if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
 			currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
 			currSCCB->Sccb_scsistat = BUS_FREE_ST;
 		}
-		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
-			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-		{
-      	currTar_Info->TarLUNBusy[currSCCB->Lun] = 0;
-			if(currSCCB->Sccb_scsistat != ABORT_ST)
-			{
+		if (((pCurrCard->globalFlags & F_CONLUN_IO) &&
+		     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=
+		      TAG_Q_TRYING))) {
+			currTar_Info->TarLUNBusy[currSCCB->Lun] = 0;
+			if (currSCCB->Sccb_scsistat != ABORT_ST) {
 				pCurrCard->discQCount--;
-				pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[currSCCB->Lun]] 
-													= NULL;
+				pCurrCard->discQ_Tbl[currTar_Info->
+						     LunDiscQ_Idx[currSCCB->
+								  Lun]]
+				    = NULL;
 			}
-		}
-		else
-		{
-	      currTar_Info->TarLUNBusy[0] = 0;
-			if(currSCCB->Sccb_tag)
-			{
-				if(currSCCB->Sccb_scsistat != ABORT_ST)
-				{
+		} else {
+			currTar_Info->TarLUNBusy[0] = 0;
+			if (currSCCB->Sccb_tag) {
+				if (currSCCB->Sccb_scsistat != ABORT_ST) {
 					pCurrCard->discQCount--;
-					pCurrCard->discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+					pCurrCard->discQ_Tbl[currSCCB->
+							     Sccb_tag] = NULL;
 				}
-			}else
-			{
-				if(currSCCB->Sccb_scsistat != ABORT_ST)
-				{
+			} else {
+				if (currSCCB->Sccb_scsistat != ABORT_ST) {
 					pCurrCard->discQCount--;
-					pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = NULL;
+					pCurrCard->discQ_Tbl[currTar_Info->
+							     LunDiscQ_Idx[0]] =
+					    NULL;
 				}
 			}
 		}
 
-      FPT_queueSelectFail(&FPT_BL_Card[p_card],p_card);
+		FPT_queueSelectFail(&FPT_BL_Card[p_card], p_card);
 	}
 
-	WRW_HARPOON((port+hp_fiforead), (unsigned short) 0x00);
+	WRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);
 
-
-	our_target = (unsigned char)(RD_HARPOON(port+hp_select_id) >> 4);
+	our_target = (unsigned char)(RD_HARPOON(port + hp_select_id) >> 4);
 	currTar_Info = &FPT_sccbMgrTbl[p_card][our_target];
 
-
 	msgRetryCount = 0;
-	do
-	{
+	do {
 
 		currTar_Info = &FPT_sccbMgrTbl[p_card][our_target];
 		tag = 0;
 
+		while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
+			if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
-		while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
-		{
-			if (! (RD_HARPOON(port+hp_scsisig) & SCSI_BSY))
-			{
-
-				WRW_HARPOON((port+hp_intstat), PHASE);
+				WRW_HARPOON((port + hp_intstat), PHASE);
 				return;
 			}
 		}
 
-		WRW_HARPOON((port+hp_intstat), PHASE);
-		if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH)
-		{
+		WRW_HARPOON((port + hp_intstat), PHASE);
+		if ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH) {
 
-			message = FPT_sfm(port,pCurrCard->currentSCCB);
-			if (message)
-			{
+			message = FPT_sfm(port, pCurrCard->currentSCCB);
+			if (message) {
 
-				if (message <= (0x80 | LUN_MASK))
-				{
+				if (message <= (0x80 | LUN_MASK)) {
 					lun = message & (unsigned char)LUN_MASK;
 
-					if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING)
-					{
-						if (currTar_Info->TarTagQ_Cnt != 0)
-						{
-
-							if (!(currTar_Info->TarLUN_CA))
-							{
-								ACCEPT_MSG(port);    /*Release the ACK for ID msg. */
-
-
-								message = FPT_sfm(port,pCurrCard->currentSCCB);
-								if (message)
-								{
-									ACCEPT_MSG(port);
+					if ((currTar_Info->
+					     TarStatus & TAR_TAG_Q_MASK) ==
+					    TAG_Q_TRYING) {
+						if (currTar_Info->TarTagQ_Cnt !=
+						    0) {
+
+							if (!
+							    (currTar_Info->
+							     TarLUN_CA)) {
+								ACCEPT_MSG(port);	/*Release the ACK for ID msg. */
+
+								message =
+								    FPT_sfm
+								    (port,
+								     pCurrCard->
+								     currentSCCB);
+								if (message) {
+									ACCEPT_MSG
+									    (port);
 								}
 
 								else
-   								message = 0;
-
-								if(message != 0)
-								{
-									tag = FPT_sfm(port,pCurrCard->currentSCCB);
-
-									if (!(tag)) 
-										message = 0;
+									message
+									    = 0;
+
+								if (message !=
+								    0) {
+									tag =
+									    FPT_sfm
+									    (port,
+									     pCurrCard->
+									     currentSCCB);
+
+									if (!
+									    (tag))
+										message
+										    =
+										    0;
 								}
 
-							} /*C.A. exists! */
-
-						} /*End Q cnt != 0 */
-
-					} /*End Tag cmds supported! */
-
-				} /*End valid ID message.  */
-
-				else
-				{
+							}
+							/*C.A. exists! */
+						}
+						/*End Q cnt != 0 */
+					}
+					/*End Tag cmds supported! */
+				}
+				/*End valid ID message.  */
+				else {
 
 					ACCEPT_MSG_ATN(port);
 				}
 
-			} /* End good id message. */
-
-			else
-			{
+			}
+			/* End good id message. */
+			else {
 
 				message = 0;
 			}
-		}
-		else
-		{
+		} else {
 			ACCEPT_MSG_ATN(port);
 
-		   while (!(RDW_HARPOON((port+hp_intstat)) & (PHASE | RESET)) &&
-			  !(RD_HARPOON(port+hp_scsisig) & SCSI_REQ) &&
-			  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
+			while (!
+			       (RDW_HARPOON((port + hp_intstat)) &
+				(PHASE | RESET))
+			       && !(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)
+			       && (RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;
 
 			return;
 		}
 
-		if(message == 0)
-		{
+		if (message == 0) {
 			msgRetryCount++;
-			if(msgRetryCount == 1)
-			{
+			if (msgRetryCount == 1) {
 				FPT_SendMsg(port, SMPARITY);
-			}
-			else
-			{
+			} else {
 				FPT_SendMsg(port, SMDEV_RESET);
 
-				FPT_sssyncv(port, our_target, NARROW_SCSI,currTar_Info);
+				FPT_sssyncv(port, our_target, NARROW_SCSI,
+					    currTar_Info);
 
-				if (FPT_sccbMgrTbl[p_card][our_target].TarEEValue & EE_SYNC_MASK) 
-				{
-			
-					FPT_sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_SYNC_MASK;
+				if (FPT_sccbMgrTbl[p_card][our_target].
+				    TarEEValue & EE_SYNC_MASK) {
+
+					FPT_sccbMgrTbl[p_card][our_target].
+					    TarStatus &= ~TAR_SYNC_MASK;
 
 				}
 
-				if (FPT_sccbMgrTbl[p_card][our_target].TarEEValue & EE_WIDE_SCSI) 
-				{
+				if (FPT_sccbMgrTbl[p_card][our_target].
+				    TarEEValue & EE_WIDE_SCSI) {
 
-					FPT_sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_WIDE_MASK;
+					FPT_sccbMgrTbl[p_card][our_target].
+					    TarStatus &= ~TAR_WIDE_MASK;
 				}
 
-
-				FPT_queueFlushTargSccb(p_card, our_target, SCCB_COMPLETE);
-				FPT_SccbMgrTableInitTarget(p_card,our_target);
+				FPT_queueFlushTargSccb(p_card, our_target,
+						       SCCB_COMPLETE);
+				FPT_SccbMgrTableInitTarget(p_card, our_target);
 				return;
 			}
 		}
-	}while(message == 0);
-
+	} while (message == 0);
 
-
-	if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
-		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-	{
+	if (((pCurrCard->globalFlags & F_CONLUN_IO) &&
+	     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {
 		currTar_Info->TarLUNBusy[lun] = 1;
-		pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];
-		if(pCurrCard->currentSCCB != NULL)
-		{
+		pCurrCard->currentSCCB =
+		    pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];
+		if (pCurrCard->currentSCCB != NULL) {
 			ACCEPT_MSG(port);
-		}
-		else 
-		{
+		} else {
 			ACCEPT_MSG_ATN(port);
 		}
-	}
-	else
-	{
+	} else {
 		currTar_Info->TarLUNBusy[0] = 1;
 
-
-		if (tag)
-		{
-			if (pCurrCard->discQ_Tbl[tag] != NULL)
-			{
-				pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[tag];
-		 		currTar_Info->TarTagQ_Cnt--;
+		if (tag) {
+			if (pCurrCard->discQ_Tbl[tag] != NULL) {
+				pCurrCard->currentSCCB =
+				    pCurrCard->discQ_Tbl[tag];
+				currTar_Info->TarTagQ_Cnt--;
 				ACCEPT_MSG(port);
+			} else {
+				ACCEPT_MSG_ATN(port);
 			}
-			else
-			{
-			ACCEPT_MSG_ATN(port);
-			}
-		}else
-		{
-			pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]];
-			if(pCurrCard->currentSCCB != NULL)
-			{
+		} else {
+			pCurrCard->currentSCCB =
+			    pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]];
+			if (pCurrCard->currentSCCB != NULL) {
 				ACCEPT_MSG(port);
-			}
-			else 
-			{
+			} else {
 				ACCEPT_MSG_ATN(port);
 			}
 		}
 	}
 
-	if(pCurrCard->currentSCCB != NULL)
-	{
-		if(pCurrCard->currentSCCB->Sccb_scsistat == ABORT_ST)
-		{
-		/* During Abort Tag command, the target could have got re-selected
-			and completed the command. Check the select Q and remove the CCB
-			if it is in the Select Q */
+	if (pCurrCard->currentSCCB != NULL) {
+		if (pCurrCard->currentSCCB->Sccb_scsistat == ABORT_ST) {
+			/* During Abort Tag command, the target could have got re-selected
+			   and completed the command. Check the select Q and remove the CCB
+			   if it is in the Select Q */
 			FPT_queueFindSccb(pCurrCard->currentSCCB, p_card);
 		}
 	}
 
-
-   while (!(RDW_HARPOON((port+hp_intstat)) & (PHASE | RESET)) &&
-	  !(RD_HARPOON(port+hp_scsisig) & SCSI_REQ) &&
-	  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
+	while (!(RDW_HARPOON((port + hp_intstat)) & (PHASE | RESET)) &&
+	       !(RD_HARPOON(port + hp_scsisig) & SCSI_REQ) &&
+	       (RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;
 }
 
 static void FPT_SendMsg(unsigned long port, unsigned char message)
 {
-	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
-	{
-		if (! (RD_HARPOON(port+hp_scsisig) & SCSI_BSY))
-		{
+	while (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {
+		if (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {
 
-			WRW_HARPOON((port+hp_intstat), PHASE);
+			WRW_HARPOON((port + hp_intstat), PHASE);
 			return;
 		}
 	}
 
-	WRW_HARPOON((port+hp_intstat), PHASE);
-	if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGO_PH)
-	{
-		WRW_HARPOON((port+hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));
-
+	WRW_HARPOON((port + hp_intstat), PHASE);
+	if ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) == S_MSGO_PH) {
+		WRW_HARPOON((port + hp_intstat),
+			    (BUS_FREE | PHASE | XFER_CNT_0));
 
-		WR_HARPOON(port+hp_portctrl_0, SCSI_BUS_EN);
+		WR_HARPOON(port + hp_portctrl_0, SCSI_BUS_EN);
 
-		WR_HARPOON(port+hp_scsidata_0,message);
+		WR_HARPOON(port + hp_scsidata_0, message);
 
-		WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+		WR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));
 
 		ACCEPT_MSG(port);
 
-		WR_HARPOON(port+hp_portctrl_0, 0x00);
+		WR_HARPOON(port + hp_portctrl_0, 0x00);
 
 		if ((message == SMABORT) || (message == SMDEV_RESET) ||
-				(message == SMABORT_TAG) )
-		{
-			while(!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | PHASE))) {}
+		    (message == SMABORT_TAG)) {
+			while (!
+			       (RDW_HARPOON((port + hp_intstat)) &
+				(BUS_FREE | PHASE))) {
+			}
 
-			if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE)
-			{
-			WRW_HARPOON((port+hp_intstat), BUS_FREE);
+			if (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {
+				WRW_HARPOON((port + hp_intstat), BUS_FREE);
 			}
 		}
 	}
@@ -3106,37 +2908,35 @@ static void FPT_SendMsg(unsigned long port, unsigned char message)
  *              target device.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p_card)
+static void FPT_sdecm(unsigned char message, unsigned long port,
+		      unsigned char p_card)
 {
-	struct sccb * currSCCB;
-	struct sccb_card * CurrCard;
-	struct sccb_mgr_tar_info * currTar_Info;
+	struct sccb *currSCCB;
+	struct sccb_card *CurrCard;
+	struct sccb_mgr_tar_info *currTar_Info;
 
 	CurrCard = &FPT_BL_Card[p_card];
 	currSCCB = CurrCard->currentSCCB;
 
 	currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-	if (message == SMREST_DATA_PTR)
-	{
-		if (!(currSCCB->Sccb_XferState & F_NO_DATA_YET))
-		{
+	if (message == SMREST_DATA_PTR) {
+		if (!(currSCCB->Sccb_XferState & F_NO_DATA_YET)) {
 			currSCCB->Sccb_ATC = currSCCB->Sccb_savedATC;
 
 			FPT_hostDataXferRestart(currSCCB);
 		}
 
 		ACCEPT_MSG(port);
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 	}
 
-	else if (message == SMCMD_COMP)
-	{
-
+	else if (message == SMCMD_COMP) {
 
-		if (currSCCB->Sccb_scsistat == SELECT_Q_ST)
-		{
-			currTar_Info->TarStatus &= ~(unsigned char)TAR_TAG_Q_MASK;
+		if (currSCCB->Sccb_scsistat == SELECT_Q_ST) {
+			currTar_Info->TarStatus &=
+			    ~(unsigned char)TAR_TAG_Q_MASK;
 			currTar_Info->TarStatus |= (unsigned char)TAG_Q_REJECT;
 		}
 
@@ -3144,140 +2944,144 @@ static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p
 
 	}
 
-	else if ((message == SMNO_OP) || (message >= SMIDENT) 
-			|| (message == SMINIT_RECOVERY) || (message == SMREL_RECOVERY))
-	{
+	else if ((message == SMNO_OP) || (message >= SMIDENT)
+		 || (message == SMINIT_RECOVERY) || (message == SMREL_RECOVERY)) {
 
 		ACCEPT_MSG(port);
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 	}
 
-	else if (message == SMREJECT)
-	{
+	else if (message == SMREJECT) {
 
 		if ((currSCCB->Sccb_scsistat == SELECT_SN_ST) ||
-				(currSCCB->Sccb_scsistat == SELECT_WN_ST) ||
-				((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING ) ||
-				((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING ) )
-
+		    (currSCCB->Sccb_scsistat == SELECT_WN_ST) ||
+		    ((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)
+		    || ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) ==
+			TAG_Q_TRYING))
 		{
-			WRW_HARPOON((port+hp_intstat), BUS_FREE);
+			WRW_HARPOON((port + hp_intstat), BUS_FREE);
 
 			ACCEPT_MSG(port);
 
-
-			while ((!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
-				(!(RDW_HARPOON((port+hp_intstat)) & BUS_FREE))) {}
-
-			if(currSCCB->Lun == 0x00)
+			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
+			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
-				if ((currSCCB->Sccb_scsistat == SELECT_SN_ST))
-				{
+			}
 
-					currTar_Info->TarStatus |= (unsigned char)SYNC_SUPPORTED;
+			if (currSCCB->Lun == 0x00) {
+				if ((currSCCB->Sccb_scsistat == SELECT_SN_ST)) {
 
-					currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
-				}
+					currTar_Info->TarStatus |=
+					    (unsigned char)SYNC_SUPPORTED;
 
-				else if ((currSCCB->Sccb_scsistat == SELECT_WN_ST))
-				{
+					currTar_Info->TarEEValue &=
+					    ~EE_SYNC_MASK;
+				}
 
+				else if ((currSCCB->Sccb_scsistat ==
+					  SELECT_WN_ST)) {
 
-					currTar_Info->TarStatus = (currTar_Info->TarStatus &
-													~WIDE_ENABLED) | WIDE_NEGOCIATED;
+					currTar_Info->TarStatus =
+					    (currTar_Info->
+					     TarStatus & ~WIDE_ENABLED) |
+					    WIDE_NEGOCIATED;
 
-					currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
+					currTar_Info->TarEEValue &=
+					    ~EE_WIDE_SCSI;
 
 				}
 
-				else if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING )
-				{
-					currTar_Info->TarStatus = (currTar_Info->TarStatus &
-													~(unsigned char)TAR_TAG_Q_MASK) | TAG_Q_REJECT;
-
+				else if ((currTar_Info->
+					  TarStatus & TAR_TAG_Q_MASK) ==
+					 TAG_Q_TRYING) {
+					currTar_Info->TarStatus =
+					    (currTar_Info->
+					     TarStatus & ~(unsigned char)
+					     TAR_TAG_Q_MASK) | TAG_Q_REJECT;
 
 					currSCCB->ControlByte &= ~F_USE_CMD_Q;
 					CurrCard->discQCount--;
-					CurrCard->discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+					CurrCard->discQ_Tbl[currSCCB->
+							    Sccb_tag] = NULL;
 					currSCCB->Sccb_tag = 0x00;
 
 				}
 			}
 
-			if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE)
-			{
-
+			if (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {
 
-				if(currSCCB->Lun == 0x00)
-				{
-					WRW_HARPOON((port+hp_intstat), BUS_FREE);
+				if (currSCCB->Lun == 0x00) {
+					WRW_HARPOON((port + hp_intstat),
+						    BUS_FREE);
 					CurrCard->globalFlags |= F_NEW_SCCB_CMD;
 				}
 			}
 
-			else 
-			{
+			else {
 
-				if((CurrCard->globalFlags & F_CONLUN_IO) &&
-					((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-					currTar_Info->TarLUNBusy[currSCCB->Lun] = 1;
+				if ((CurrCard->globalFlags & F_CONLUN_IO) &&
+				    ((currTar_Info->
+				      TarStatus & TAR_TAG_Q_MASK) !=
+				     TAG_Q_TRYING))
+					currTar_Info->TarLUNBusy[currSCCB->
+								 Lun] = 1;
 				else
 					currTar_Info->TarLUNBusy[0] = 1;
 
+				currSCCB->ControlByte &=
+				    ~(unsigned char)F_USE_CMD_Q;
 
-				currSCCB->ControlByte &= ~(unsigned char)F_USE_CMD_Q;
-
-				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+				WR_HARPOON(port + hp_autostart_1,
+					   (AUTO_IMMED + DISCONNECT_START));
 
 			}
 		}
 
-		else
-		{
+		else {
 			ACCEPT_MSG(port);
 
-			while ((!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
-				(!(RDW_HARPOON((port+hp_intstat)) & BUS_FREE))) {}
-	
-			if (!(RDW_HARPOON((port+hp_intstat)) & BUS_FREE))
+			while ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&
+			       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))
 			{
-				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+			}
+
+			if (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)) {
+				WR_HARPOON(port + hp_autostart_1,
+					   (AUTO_IMMED + DISCONNECT_START));
 			}
 		}
 	}
 
-	else if (message == SMEXT)
-	{
+	else if (message == SMEXT) {
 
 		ACCEPT_MSG(port);
-		FPT_shandem(port,p_card,currSCCB);
+		FPT_shandem(port, p_card, currSCCB);
 	}
 
-	else if (message == SMIGNORWR)
-	{
+	else if (message == SMIGNORWR) {
 
-		ACCEPT_MSG(port);          /* ACK the RESIDUE MSG */
+		ACCEPT_MSG(port);	/* ACK the RESIDUE MSG */
 
-		message = FPT_sfm(port,currSCCB);
+		message = FPT_sfm(port, currSCCB);
 
-		if(currSCCB->Sccb_scsimsg != SMPARITY)
+		if (currSCCB->Sccb_scsimsg != SMPARITY)
 			ACCEPT_MSG(port);
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 	}
 
-
-	else
-	{
+	else {
 
 		currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
 		currSCCB->Sccb_scsimsg = SMREJECT;
 
 		ACCEPT_MSG_ATN(port);
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_shandem
@@ -3285,76 +3089,65 @@ static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p
  * Description: Decide what to do with the extended message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_shandem(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB)
+static void FPT_shandem(unsigned long port, unsigned char p_card,
+			struct sccb *pCurrSCCB)
 {
-	unsigned char length,message;
+	unsigned char length, message;
 
-	length = FPT_sfm(port,pCurrSCCB);
-	if (length) 
-	{
+	length = FPT_sfm(port, pCurrSCCB);
+	if (length) {
 
 		ACCEPT_MSG(port);
-		message = FPT_sfm(port,pCurrSCCB);
-		if (message) 
-		{
+		message = FPT_sfm(port, pCurrSCCB);
+		if (message) {
 
-			if (message == SMSYNC) 
-			{
+			if (message == SMSYNC) {
 
-				if (length == 0x03)
-				{
+				if (length == 0x03) {
 
 					ACCEPT_MSG(port);
-					FPT_stsyncn(port,p_card);
-				}
-				else 
-				{
+					FPT_stsyncn(port, p_card);
+				} else {
 
 					pCurrSCCB->Sccb_scsimsg = SMREJECT;
 					ACCEPT_MSG_ATN(port);
 				}
-			}
-			else if (message == SMWDTR) 
-			{
+			} else if (message == SMWDTR) {
 
-				if (length == 0x02)
-				{
+				if (length == 0x02) {
 
 					ACCEPT_MSG(port);
-					FPT_stwidn(port,p_card);
-				}
-				else 
-				{
+					FPT_stwidn(port, p_card);
+				} else {
 
 					pCurrSCCB->Sccb_scsimsg = SMREJECT;
 					ACCEPT_MSG_ATN(port);
 
-					WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+					WR_HARPOON(port + hp_autostart_1,
+						   (AUTO_IMMED +
+						    DISCONNECT_START));
 				}
-			}
-			else 
-			{
+			} else {
 
 				pCurrSCCB->Sccb_scsimsg = SMREJECT;
 				ACCEPT_MSG_ATN(port);
 
-				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+				WR_HARPOON(port + hp_autostart_1,
+					   (AUTO_IMMED + DISCONNECT_START));
 			}
-		}
-		else
-		{
-			if(pCurrSCCB->Sccb_scsimsg != SMPARITY)
+		} else {
+			if (pCurrSCCB->Sccb_scsimsg != SMPARITY)
 				ACCEPT_MSG(port);
-			WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+			WR_HARPOON(port + hp_autostart_1,
+				   (AUTO_IMMED + DISCONNECT_START));
 		}
-	}else
-	{
-			if(pCurrSCCB->Sccb_scsimsg == SMPARITY)
-				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	} else {
+		if (pCurrSCCB->Sccb_scsimsg == SMPARITY)
+			WR_HARPOON(port + hp_autostart_1,
+				   (AUTO_IMMED + DISCONNECT_START));
 	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sisyncn
@@ -3364,73 +3157,79 @@ static void FPT_shandem(unsigned long port, unsigned char p_card, struct sccb *
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag)
+static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card,
+				 unsigned char syncFlag)
 {
-   struct sccb * currSCCB;
-   struct sccb_mgr_tar_info * currTar_Info;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
-
-   if (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)) {
-
-
-      WRW_HARPOON((port+ID_MSG_STRT),
-                 (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV)));
-
-      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
-
-      WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
-      WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x03  ));
-      WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMSYNC));
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-      if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)
+	if (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)) {
 
-	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 12));
+		WRW_HARPOON((port + ID_MSG_STRT),
+			    (MPM_OP + AMSG_OUT +
+			     (currSCCB->
+			      Sccb_idmsg & ~(unsigned char)DISC_PRIV)));
 
-      else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)
+		WRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);
 
-	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 25));
+		WRW_HARPOON((port + SYNC_MSGS + 0),
+			    (MPM_OP + AMSG_OUT + SMEXT));
+		WRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x03));
+		WRW_HARPOON((port + SYNC_MSGS + 4),
+			    (MPM_OP + AMSG_OUT + SMSYNC));
 
-      else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)
+		if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)
 
-	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 50));
+			WRW_HARPOON((port + SYNC_MSGS + 6),
+				    (MPM_OP + AMSG_OUT + 12));
 
-      else
-	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 00));
+		else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) ==
+			 EE_SYNC_10MB)
 
+			WRW_HARPOON((port + SYNC_MSGS + 6),
+				    (MPM_OP + AMSG_OUT + 25));
 
-      WRW_HARPOON((port+SYNC_MSGS+8), (RAT_OP                ));
-      WRW_HARPOON((port+SYNC_MSGS+10),(MPM_OP+AMSG_OUT+DEFAULT_OFFSET));
-      WRW_HARPOON((port+SYNC_MSGS+12),(BRH_OP+ALWAYS+NP      ));
+		else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) ==
+			 EE_SYNC_5MB)
 
+			WRW_HARPOON((port + SYNC_MSGS + 6),
+				    (MPM_OP + AMSG_OUT + 50));
 
-		if(syncFlag == 0)
-		{
-		   WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-	      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-   	      ~(unsigned char)TAR_SYNC_MASK) | (unsigned char)SYNC_TRYING);
-		}
 		else
-		{
-		   WR_HARPOON(port+hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));
+			WRW_HARPOON((port + SYNC_MSGS + 6),
+				    (MPM_OP + AMSG_OUT + 00));
+
+		WRW_HARPOON((port + SYNC_MSGS + 8), (RAT_OP));
+		WRW_HARPOON((port + SYNC_MSGS + 10),
+			    (MPM_OP + AMSG_OUT + DEFAULT_OFFSET));
+		WRW_HARPOON((port + SYNC_MSGS + 12), (BRH_OP + ALWAYS + NP));
+
+		if (syncFlag == 0) {
+			WR_HARPOON(port + hp_autostart_3,
+				   (SELECT + SELCHK_STRT));
+			currTar_Info->TarStatus =
+			    ((currTar_Info->
+			      TarStatus & ~(unsigned char)TAR_SYNC_MASK) |
+			     (unsigned char)SYNC_TRYING);
+		} else {
+			WR_HARPOON(port + hp_autostart_3,
+				   (AUTO_IMMED + CMD_ONLY_STRT));
 		}
 
+		return (1);
+	}
 
-      return(1);
-      }
-
-   else {
+	else {
 
-      currTar_Info->TarStatus |=	 (unsigned char)SYNC_SUPPORTED;
-      currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
-      return(0);
-      }
+		currTar_Info->TarStatus |= (unsigned char)SYNC_SUPPORTED;
+		currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
+		return (0);
+	}
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_stsyncn
@@ -3441,129 +3240,126 @@ static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsig
  *---------------------------------------------------------------------*/
 static void FPT_stsyncn(unsigned long port, unsigned char p_card)
 {
-   unsigned char sync_msg,offset,sync_reg,our_sync_msg;
-   struct sccb * currSCCB;
-   struct sccb_mgr_tar_info * currTar_Info;
+	unsigned char sync_msg, offset, sync_reg, our_sync_msg;
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-   sync_msg = FPT_sfm(port,currSCCB);
+	sync_msg = FPT_sfm(port, currSCCB);
 
-	if((sync_msg == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
-	{
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	if ((sync_msg == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY)) {
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 		return;
 	}
 
-   ACCEPT_MSG(port);
-
+	ACCEPT_MSG(port);
 
-   offset = FPT_sfm(port,currSCCB);
+	offset = FPT_sfm(port, currSCCB);
 
-	if((offset == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
-	{
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	if ((offset == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY)) {
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 		return;
 	}
 
-   if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)
-
-      our_sync_msg = 12;              /* Setup our Message to 20mb/s */
-
-   else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)
+	if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)
 
-      our_sync_msg = 25;              /* Setup our Message to 10mb/s */
+		our_sync_msg = 12;	/* Setup our Message to 20mb/s */
 
-   else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)
+	else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)
 
-      our_sync_msg = 50;              /* Setup our Message to 5mb/s */
-   else
-
-      our_sync_msg = 0;               /* Message = Async */
-
-   if (sync_msg < our_sync_msg) {
-      sync_msg = our_sync_msg;    /*if faster, then set to max. */
-      }
+		our_sync_msg = 25;	/* Setup our Message to 10mb/s */
 
-   if (offset == ASYNC)
-      sync_msg = ASYNC;
+	else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)
 
-   if (offset > MAX_OFFSET)
-      offset = MAX_OFFSET;
+		our_sync_msg = 50;	/* Setup our Message to 5mb/s */
+	else
 
-   sync_reg = 0x00;
+		our_sync_msg = 0;	/* Message = Async */
 
-   if (sync_msg > 12)
+	if (sync_msg < our_sync_msg) {
+		sync_msg = our_sync_msg;	/*if faster, then set to max. */
+	}
 
-      sync_reg = 0x20;        /* Use 10MB/s */
+	if (offset == ASYNC)
+		sync_msg = ASYNC;
 
-   if (sync_msg > 25)
+	if (offset > MAX_OFFSET)
+		offset = MAX_OFFSET;
 
-      sync_reg = 0x40;        /* Use 6.6MB/s */
+	sync_reg = 0x00;
 
-   if (sync_msg > 38)
+	if (sync_msg > 12)
 
-      sync_reg = 0x60;        /* Use 5MB/s */
+		sync_reg = 0x20;	/* Use 10MB/s */
 
-   if (sync_msg > 50)
+	if (sync_msg > 25)
 
-      sync_reg = 0x80;        /* Use 4MB/s */
+		sync_reg = 0x40;	/* Use 6.6MB/s */
 
-   if (sync_msg > 62)
+	if (sync_msg > 38)
 
-      sync_reg = 0xA0;        /* Use 3.33MB/s */
+		sync_reg = 0x60;	/* Use 5MB/s */
 
-   if (sync_msg > 75)
+	if (sync_msg > 50)
 
-      sync_reg = 0xC0;        /* Use 2.85MB/s */
+		sync_reg = 0x80;	/* Use 4MB/s */
 
-   if (sync_msg > 87)
+	if (sync_msg > 62)
 
-      sync_reg = 0xE0;        /* Use 2.5MB/s */
+		sync_reg = 0xA0;	/* Use 3.33MB/s */
 
-   if (sync_msg > 100) {
+	if (sync_msg > 75)
 
-      sync_reg = 0x00;        /* Use ASYNC */
-      offset = 0x00;
-      }
+		sync_reg = 0xC0;	/* Use 2.85MB/s */
 
+	if (sync_msg > 87)
 
-   if (currTar_Info->TarStatus & WIDE_ENABLED)
+		sync_reg = 0xE0;	/* Use 2.5MB/s */
 
-      sync_reg |= offset;
+	if (sync_msg > 100) {
 
-   else
+		sync_reg = 0x00;	/* Use ASYNC */
+		offset = 0x00;
+	}
 
-      sync_reg |= (offset | NARROW_SCSI);
+	if (currTar_Info->TarStatus & WIDE_ENABLED)
 
-   FPT_sssyncv(port,currSCCB->TargID,sync_reg,currTar_Info);
+		sync_reg |= offset;
 
+	else
 
-   if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
+		sync_reg |= (offset | NARROW_SCSI);
 
+	FPT_sssyncv(port, currSCCB->TargID, sync_reg, currTar_Info);
 
-      ACCEPT_MSG(port);
+	if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
 
-      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-         ~(unsigned char)TAR_SYNC_MASK) | (unsigned char)SYNC_SUPPORTED);
+		ACCEPT_MSG(port);
 
-      WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
-      }
+		currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+					    ~(unsigned char)TAR_SYNC_MASK) |
+					   (unsigned char)SYNC_SUPPORTED);
 
-   else {
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
+	}
 
+	else {
 
-      ACCEPT_MSG_ATN(port);
+		ACCEPT_MSG_ATN(port);
 
-      FPT_sisyncr(port,sync_msg,offset);
+		FPT_sisyncr(port, sync_msg, offset);
 
-      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-         ~(unsigned char)TAR_SYNC_MASK) | (unsigned char)SYNC_SUPPORTED);
-      }
+		currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+					    ~(unsigned char)TAR_SYNC_MASK) |
+					   (unsigned char)SYNC_SUPPORTED);
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sisyncr
@@ -3571,28 +3367,28 @@ static void FPT_stsyncn(unsigned long port, unsigned char p_card)
  * Description: Answer the targets sync message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset)
+static void FPT_sisyncr(unsigned long port, unsigned char sync_pulse,
+			unsigned char offset)
 {
-   ARAM_ACCESS(port);
-   WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
-   WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x03  ));
-   WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMSYNC));
-   WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+sync_pulse));
-   WRW_HARPOON((port+SYNC_MSGS+8), (RAT_OP                ));
-   WRW_HARPOON((port+SYNC_MSGS+10),(MPM_OP+AMSG_OUT+offset));
-   WRW_HARPOON((port+SYNC_MSGS+12),(BRH_OP+ALWAYS+NP      ));
-   SGRAM_ACCESS(port);
-
-   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT_1);
-
-   WR_HARPOON(port+hp_autostart_3, (AUTO_IMMED+CMD_ONLY_STRT));
-
-   while (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | AUTO_INT))) {}
+	ARAM_ACCESS(port);
+	WRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT + SMEXT));
+	WRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x03));
+	WRW_HARPOON((port + SYNC_MSGS + 4), (MPM_OP + AMSG_OUT + SMSYNC));
+	WRW_HARPOON((port + SYNC_MSGS + 6), (MPM_OP + AMSG_OUT + sync_pulse));
+	WRW_HARPOON((port + SYNC_MSGS + 8), (RAT_OP));
+	WRW_HARPOON((port + SYNC_MSGS + 10), (MPM_OP + AMSG_OUT + offset));
+	WRW_HARPOON((port + SYNC_MSGS + 12), (BRH_OP + ALWAYS + NP));
+	SGRAM_ACCESS(port);
+
+	WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
+	WRW_HARPOON((port + hp_intstat), CLR_ALL_INT_1);
+
+	WR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));
+
+	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+	}
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_siwidn
@@ -3604,48 +3400,51 @@ static void FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned ch
 
 static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 {
-   struct sccb * currSCCB;
-   struct sccb_mgr_tar_info * currTar_Info;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
-
-   if (!((currTar_Info->TarStatus & TAR_WIDE_MASK) == WIDE_NEGOCIATED)) {
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-      WRW_HARPOON((port+ID_MSG_STRT),
-	              (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV)));
+	if (!((currTar_Info->TarStatus & TAR_WIDE_MASK) == WIDE_NEGOCIATED)) {
 
-      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
+		WRW_HARPOON((port + ID_MSG_STRT),
+			    (MPM_OP + AMSG_OUT +
+			     (currSCCB->
+			      Sccb_idmsg & ~(unsigned char)DISC_PRIV)));
 
-      WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
-      WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x02  ));
-      WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMWDTR));
-      WRW_HARPOON((port+SYNC_MSGS+6), (RAT_OP                ));
-      WRW_HARPOON((port+SYNC_MSGS+8), (MPM_OP+AMSG_OUT+ SM16BIT));
-      WRW_HARPOON((port+SYNC_MSGS+10),(BRH_OP+ALWAYS+NP      ));
+		WRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);
 
-      WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+		WRW_HARPOON((port + SYNC_MSGS + 0),
+			    (MPM_OP + AMSG_OUT + SMEXT));
+		WRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x02));
+		WRW_HARPOON((port + SYNC_MSGS + 4),
+			    (MPM_OP + AMSG_OUT + SMWDTR));
+		WRW_HARPOON((port + SYNC_MSGS + 6), (RAT_OP));
+		WRW_HARPOON((port + SYNC_MSGS + 8),
+			    (MPM_OP + AMSG_OUT + SM16BIT));
+		WRW_HARPOON((port + SYNC_MSGS + 10), (BRH_OP + ALWAYS + NP));
 
+		WR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));
 
-      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-         ~(unsigned char)TAR_WIDE_MASK) | (unsigned char)WIDE_ENABLED);
+		currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+					    ~(unsigned char)TAR_WIDE_MASK) |
+					   (unsigned char)WIDE_ENABLED);
 
-      return(1);
-      }
+		return (1);
+	}
 
-   else {
+	else {
 
-      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-               ~(unsigned char)TAR_WIDE_MASK) | WIDE_NEGOCIATED);
+		currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+					    ~(unsigned char)TAR_WIDE_MASK) |
+					   WIDE_NEGOCIATED);
 
-      currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
-      return(0);
-      }
+		currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
+		return (0);
+	}
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_stwidn
@@ -3656,77 +3455,68 @@ static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
  *---------------------------------------------------------------------*/
 static void FPT_stwidn(unsigned long port, unsigned char p_card)
 {
-   unsigned char width;
-   struct sccb * currSCCB;
-   struct sccb_mgr_tar_info * currTar_Info;
+	unsigned char width;
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-   width = FPT_sfm(port,currSCCB);
+	width = FPT_sfm(port, currSCCB);
 
-	if((width == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
-	{
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	if ((width == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY)) {
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + DISCONNECT_START));
 		return;
 	}
 
+	if (!(currTar_Info->TarEEValue & EE_WIDE_SCSI))
+		width = 0;
 
-   if (!(currTar_Info->TarEEValue & EE_WIDE_SCSI))
-      width = 0;
-
-   if (width) {
-      currTar_Info->TarStatus |= WIDE_ENABLED;
-      width = 0;
-      }
-   else {
-      width = NARROW_SCSI;
-      currTar_Info->TarStatus &= ~WIDE_ENABLED;
-      }
-
-
-   FPT_sssyncv(port,currSCCB->TargID,width,currTar_Info);
-
-
-   if (currSCCB->Sccb_scsistat == SELECT_WN_ST)
-	{
+	if (width) {
+		currTar_Info->TarStatus |= WIDE_ENABLED;
+		width = 0;
+	} else {
+		width = NARROW_SCSI;
+		currTar_Info->TarStatus &= ~WIDE_ENABLED;
+	}
 
+	FPT_sssyncv(port, currSCCB->TargID, width, currTar_Info);
 
+	if (currSCCB->Sccb_scsistat == SELECT_WN_ST) {
 
-      currTar_Info->TarStatus |=	 WIDE_NEGOCIATED;
+		currTar_Info->TarStatus |= WIDE_NEGOCIATED;
 
-	   if (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_SUPPORTED))
-		{
-	      ACCEPT_MSG_ATN(port);
-		   ARAM_ACCESS(port);
-	     	FPT_sisyncn(port,p_card, 1);
-	      currSCCB->Sccb_scsistat = SELECT_SN_ST;
-		   SGRAM_ACCESS(port);
-		}
-		else
-		{
-	      ACCEPT_MSG(port);
-  		   WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		if (!
+		    ((currTar_Info->TarStatus & TAR_SYNC_MASK) ==
+		     SYNC_SUPPORTED)) {
+			ACCEPT_MSG_ATN(port);
+			ARAM_ACCESS(port);
+			FPT_sisyncn(port, p_card, 1);
+			currSCCB->Sccb_scsistat = SELECT_SN_ST;
+			SGRAM_ACCESS(port);
+		} else {
+			ACCEPT_MSG(port);
+			WR_HARPOON(port + hp_autostart_1,
+				   (AUTO_IMMED + DISCONNECT_START));
 		}
-   }
-
-   else {
+	}
 
+	else {
 
-      ACCEPT_MSG_ATN(port);
+		ACCEPT_MSG_ATN(port);
 
-      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
-      	 width = SM16BIT;
-      else
-      	 width = SM8BIT;
+		if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
+			width = SM16BIT;
+		else
+			width = SM8BIT;
 
-      FPT_siwidr(port,width);
+		FPT_siwidr(port, width);
 
-      currTar_Info->TarStatus |= (WIDE_NEGOCIATED | WIDE_ENABLED);
-      }
+		currTar_Info->TarStatus |= (WIDE_NEGOCIATED | WIDE_ENABLED);
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_siwidr
@@ -3736,25 +3526,24 @@ static void FPT_stwidn(unsigned long port, unsigned char p_card)
  *---------------------------------------------------------------------*/
 static void FPT_siwidr(unsigned long port, unsigned char width)
 {
-   ARAM_ACCESS(port);
-   WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
-   WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x02  ));
-   WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMWDTR));
-   WRW_HARPOON((port+SYNC_MSGS+6), (RAT_OP                ));
-   WRW_HARPOON((port+SYNC_MSGS+8),(MPM_OP+AMSG_OUT+width));
-   WRW_HARPOON((port+SYNC_MSGS+10),(BRH_OP+ALWAYS+NP      ));
-   SGRAM_ACCESS(port);
+	ARAM_ACCESS(port);
+	WRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT + SMEXT));
+	WRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x02));
+	WRW_HARPOON((port + SYNC_MSGS + 4), (MPM_OP + AMSG_OUT + SMWDTR));
+	WRW_HARPOON((port + SYNC_MSGS + 6), (RAT_OP));
+	WRW_HARPOON((port + SYNC_MSGS + 8), (MPM_OP + AMSG_OUT + width));
+	WRW_HARPOON((port + SYNC_MSGS + 10), (BRH_OP + ALWAYS + NP));
+	SGRAM_ACCESS(port);
 
-   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT_1);
+	WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
+	WRW_HARPOON((port + hp_intstat), CLR_ALL_INT_1);
 
-   WR_HARPOON(port+hp_autostart_3, (AUTO_IMMED+CMD_ONLY_STRT));
+	WR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));
 
-   while (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | AUTO_INT))) {}
+	while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {
+	}
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sssyncv
@@ -3763,71 +3552,71 @@ static void FPT_siwidr(unsigned long port, unsigned char width)
  *              ID specified.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
-			struct sccb_mgr_tar_info * currTar_Info)
+static void FPT_sssyncv(unsigned long p_port, unsigned char p_id,
+			unsigned char p_sync_value,
+			struct sccb_mgr_tar_info *currTar_Info)
 {
-   unsigned char index;
-
-   index = p_id;
-
-   switch (index) {
-
-      case 0:
-	 index = 12;             /* hp_synctarg_0 */
-	 break;
-      case 1:
-	 index = 13;             /* hp_synctarg_1 */
-	 break;
-      case 2:
-	 index = 14;             /* hp_synctarg_2 */
-	 break;
-      case 3:
-	 index = 15;             /* hp_synctarg_3 */
-	 break;
-      case 4:
-	 index = 8;              /* hp_synctarg_4 */
-	 break;
-      case 5:
-	 index = 9;              /* hp_synctarg_5 */
-	 break;
-      case 6:
-	 index = 10;             /* hp_synctarg_6 */
-	 break;
-      case 7:
-	 index = 11;             /* hp_synctarg_7 */
-	 break;
-      case 8:
-	 index = 4;              /* hp_synctarg_8 */
-	 break;
-      case 9:
-	 index = 5;              /* hp_synctarg_9 */
-	 break;
-      case 10:
-	 index = 6;              /* hp_synctarg_10 */
-	 break;
-      case 11:
-	 index = 7;              /* hp_synctarg_11 */
-	 break;
-      case 12:
-	 index = 0;              /* hp_synctarg_12 */
-	 break;
-      case 13:
-	 index = 1;              /* hp_synctarg_13 */
-	 break;
-      case 14:
-	 index = 2;              /* hp_synctarg_14 */
-	 break;
-      case 15:
-	 index = 3;              /* hp_synctarg_15 */
+	unsigned char index;
+
+	index = p_id;
+
+	switch (index) {
+
+	case 0:
+		index = 12;	/* hp_synctarg_0 */
+		break;
+	case 1:
+		index = 13;	/* hp_synctarg_1 */
+		break;
+	case 2:
+		index = 14;	/* hp_synctarg_2 */
+		break;
+	case 3:
+		index = 15;	/* hp_synctarg_3 */
+		break;
+	case 4:
+		index = 8;	/* hp_synctarg_4 */
+		break;
+	case 5:
+		index = 9;	/* hp_synctarg_5 */
+		break;
+	case 6:
+		index = 10;	/* hp_synctarg_6 */
+		break;
+	case 7:
+		index = 11;	/* hp_synctarg_7 */
+		break;
+	case 8:
+		index = 4;	/* hp_synctarg_8 */
+		break;
+	case 9:
+		index = 5;	/* hp_synctarg_9 */
+		break;
+	case 10:
+		index = 6;	/* hp_synctarg_10 */
+		break;
+	case 11:
+		index = 7;	/* hp_synctarg_11 */
+		break;
+	case 12:
+		index = 0;	/* hp_synctarg_12 */
+		break;
+	case 13:
+		index = 1;	/* hp_synctarg_13 */
+		break;
+	case 14:
+		index = 2;	/* hp_synctarg_14 */
+		break;
+	case 15:
+		index = 3;	/* hp_synctarg_15 */
 
-      }
+	}
 
-   WR_HARPOON(p_port+hp_synctarg_base+index, p_sync_value);
+	WR_HARPOON(p_port + hp_synctarg_base + index, p_sync_value);
 
 	currTar_Info->TarSyncCtrl = p_sync_value;
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sresb
@@ -3837,67 +3626,65 @@ static void FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char
  *---------------------------------------------------------------------*/
 static void FPT_sresb(unsigned long port, unsigned char p_card)
 {
-   unsigned char scsiID, i;
+	unsigned char scsiID, i;
 
-   struct sccb_mgr_tar_info * currTar_Info;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   WR_HARPOON(port+hp_page_ctrl,
-      (RD_HARPOON(port+hp_page_ctrl) | G_INT_DISABLE));
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+	WR_HARPOON(port + hp_page_ctrl,
+		   (RD_HARPOON(port + hp_page_ctrl) | G_INT_DISABLE));
+	WRW_HARPOON((port + hp_intstat), CLR_ALL_INT);
 
-   WR_HARPOON(port+hp_scsictrl_0, SCSI_RST);
+	WR_HARPOON(port + hp_scsictrl_0, SCSI_RST);
 
-   scsiID = RD_HARPOON(port+hp_seltimeout);
-   WR_HARPOON(port+hp_seltimeout,TO_5ms);
-   WRW_HARPOON((port+hp_intstat), TIMEOUT);
+	scsiID = RD_HARPOON(port + hp_seltimeout);
+	WR_HARPOON(port + hp_seltimeout, TO_5ms);
+	WRW_HARPOON((port + hp_intstat), TIMEOUT);
 
-   WR_HARPOON(port+hp_portctrl_0,(SCSI_PORT | START_TO));
+	WR_HARPOON(port + hp_portctrl_0, (SCSI_PORT | START_TO));
 
-   while (!(RDW_HARPOON((port+hp_intstat)) & TIMEOUT)) {}
+	while (!(RDW_HARPOON((port + hp_intstat)) & TIMEOUT)) {
+	}
 
-   WR_HARPOON(port+hp_seltimeout,scsiID);
+	WR_HARPOON(port + hp_seltimeout, scsiID);
 
-   WR_HARPOON(port+hp_scsictrl_0, ENA_SCAM_SEL);
+	WR_HARPOON(port + hp_scsictrl_0, ENA_SCAM_SEL);
 
-   FPT_Wait(port, TO_5ms);
+	FPT_Wait(port, TO_5ms);
 
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+	WRW_HARPOON((port + hp_intstat), CLR_ALL_INT);
 
-   WR_HARPOON(port+hp_int_mask, (RD_HARPOON(port+hp_int_mask) | 0x00));
+	WR_HARPOON(port + hp_int_mask, (RD_HARPOON(port + hp_int_mask) | 0x00));
 
-   for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++)
-      {
-      currTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];
+	for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++) {
+		currTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];
 
-      if (currTar_Info->TarEEValue & EE_SYNC_MASK)
-         {
-	      	currTar_Info->TarSyncCtrl = 0;
-	      	currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
-	      }
+		if (currTar_Info->TarEEValue & EE_SYNC_MASK) {
+			currTar_Info->TarSyncCtrl = 0;
+			currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+		}
 
-      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
-         {
-      	currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
-      	}
+		if (currTar_Info->TarEEValue & EE_WIDE_SCSI) {
+			currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+		}
 
-      FPT_sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
+		FPT_sssyncv(port, scsiID, NARROW_SCSI, currTar_Info);
 
-      FPT_SccbMgrTableInitTarget(p_card, scsiID);
-      }
+		FPT_SccbMgrTableInitTarget(p_card, scsiID);
+	}
 
-   FPT_BL_Card[p_card].scanIndex = 0x00;
-   FPT_BL_Card[p_card].currentSCCB = NULL;
-   FPT_BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT 
-													| F_NEW_SCCB_CMD);
-   FPT_BL_Card[p_card].cmdCounter  = 0x00;
+	FPT_BL_Card[p_card].scanIndex = 0x00;
+	FPT_BL_Card[p_card].currentSCCB = NULL;
+	FPT_BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT
+					     | F_NEW_SCCB_CMD);
+	FPT_BL_Card[p_card].cmdCounter = 0x00;
 	FPT_BL_Card[p_card].discQCount = 0x00;
-   FPT_BL_Card[p_card].tagQ_Lst = 0x01; 
+	FPT_BL_Card[p_card].tagQ_Lst = 0x01;
 
-	for(i = 0; i < QUEUE_DEPTH; i++)
+	for (i = 0; i < QUEUE_DEPTH; i++)
 		FPT_BL_Card[p_card].discQ_Tbl[i] = NULL;
 
-   WR_HARPOON(port+hp_page_ctrl,
-      (RD_HARPOON(port+hp_page_ctrl) & ~G_INT_DISABLE));
+	WR_HARPOON(port + hp_page_ctrl,
+		   (RD_HARPOON(port + hp_page_ctrl) & ~G_INT_DISABLE));
 
 }
 
@@ -3908,46 +3695,43 @@ static void FPT_sresb(unsigned long port, unsigned char p_card)
  * Description: Setup for the Auto Sense command.
  *
  *---------------------------------------------------------------------*/
-static void FPT_ssenss(struct sccb_card * pCurrCard)
+static void FPT_ssenss(struct sccb_card *pCurrCard)
 {
-   unsigned char i;
-   struct sccb * currSCCB;
-
-   currSCCB = pCurrCard->currentSCCB;
+	unsigned char i;
+	struct sccb *currSCCB;
 
+	currSCCB = pCurrCard->currentSCCB;
 
-   currSCCB->Save_CdbLen = currSCCB->CdbLength;
+	currSCCB->Save_CdbLen = currSCCB->CdbLength;
 
-   for (i = 0; i < 6; i++) {
+	for (i = 0; i < 6; i++) {
 
-      currSCCB->Save_Cdb[i] = currSCCB->Cdb[i];
-      }
+		currSCCB->Save_Cdb[i] = currSCCB->Cdb[i];
+	}
 
-   currSCCB->CdbLength = SIX_BYTE_CMD;
-   currSCCB->Cdb[0]    = SCSI_REQUEST_SENSE;
-   currSCCB->Cdb[1]    = currSCCB->Cdb[1] & (unsigned char)0xE0; /*Keep LUN. */
-   currSCCB->Cdb[2]    = 0x00;
-   currSCCB->Cdb[3]    = 0x00;
-   currSCCB->Cdb[4]    = currSCCB->RequestSenseLength;
-   currSCCB->Cdb[5]    = 0x00;
+	currSCCB->CdbLength = SIX_BYTE_CMD;
+	currSCCB->Cdb[0] = SCSI_REQUEST_SENSE;
+	currSCCB->Cdb[1] = currSCCB->Cdb[1] & (unsigned char)0xE0;	/*Keep LUN. */
+	currSCCB->Cdb[2] = 0x00;
+	currSCCB->Cdb[3] = 0x00;
+	currSCCB->Cdb[4] = currSCCB->RequestSenseLength;
+	currSCCB->Cdb[5] = 0x00;
 
-   currSCCB->Sccb_XferCnt = (unsigned long)currSCCB->RequestSenseLength;
+	currSCCB->Sccb_XferCnt = (unsigned long)currSCCB->RequestSenseLength;
 
-   currSCCB->Sccb_ATC = 0x00;
+	currSCCB->Sccb_ATC = 0x00;
 
-   currSCCB->Sccb_XferState |= F_AUTO_SENSE;
+	currSCCB->Sccb_XferState |= F_AUTO_SENSE;
 
-   currSCCB->Sccb_XferState &= ~F_SG_XFER;
+	currSCCB->Sccb_XferState &= ~F_SG_XFER;
 
-   currSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV;
+	currSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV;
 
-   currSCCB->ControlByte = 0x00;
+	currSCCB->ControlByte = 0x00;
 
-   currSCCB->Sccb_MGRFlags &= F_STATUSLOADED;
+	currSCCB->Sccb_MGRFlags &= F_STATUSLOADED;
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sxfrp
@@ -3959,77 +3743,77 @@ static void FPT_ssenss(struct sccb_card * pCurrCard)
 
 static void FPT_sxfrp(unsigned long p_port, unsigned char p_card)
 {
-   unsigned char curr_phz;
+	unsigned char curr_phz;
 
+	DISABLE_AUTO(p_port);
 
-   DISABLE_AUTO(p_port);
+	if (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {
 
-   if (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {
+		FPT_hostDataXferAbort(p_port, p_card,
+				      FPT_BL_Card[p_card].currentSCCB);
 
-      FPT_hostDataXferAbort(p_port,p_card,FPT_BL_Card[p_card].currentSCCB);
+	}
 
-      }
+	/* If the Automation handled the end of the transfer then do not
+	   match the phase or we will get out of sync with the ISR.       */
+
+	if (RDW_HARPOON((p_port + hp_intstat)) &
+	    (BUS_FREE | XFER_CNT_0 | AUTO_INT))
+		return;
+
+	WR_HARPOON(p_port + hp_xfercnt_0, 0x00);
+
+	curr_phz = RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ;
 
-   /* If the Automation handled the end of the transfer then do not
-      match the phase or we will get out of sync with the ISR.       */
+	WRW_HARPOON((p_port + hp_intstat), XFER_CNT_0);
 
-   if (RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | XFER_CNT_0 | AUTO_INT))
-      return;
+	WR_HARPOON(p_port + hp_scsisig, curr_phz);
 
-   WR_HARPOON(p_port+hp_xfercnt_0, 0x00);
+	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET)) &&
+	       (curr_phz ==
+		(RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ)))
+	{
+		if (curr_phz & (unsigned char)SCSI_IOBIT) {
+			WR_HARPOON(p_port + hp_portctrl_0,
+				   (SCSI_PORT | HOST_PORT | SCSI_INBIT));
 
-   curr_phz = RD_HARPOON(p_port+hp_scsisig) & (unsigned char)S_SCSI_PHZ;
+			if (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {
+				RD_HARPOON(p_port + hp_fifodata_0);
+			}
+		} else {
+			WR_HARPOON(p_port + hp_portctrl_0,
+				   (SCSI_PORT | HOST_PORT | HOST_WRT));
+			if (RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY) {
+				WR_HARPOON(p_port + hp_fifodata_0, 0xFA);
+			}
+		}
+	}			/* End of While loop for padding data I/O phase */
 
-   WRW_HARPOON((p_port+hp_intstat), XFER_CNT_0);
+	while (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {
+		if (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ)
+			break;
+	}
 
+	WR_HARPOON(p_port + hp_portctrl_0,
+		   (SCSI_PORT | HOST_PORT | SCSI_INBIT));
+	while (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {
+		RD_HARPOON(p_port + hp_fifodata_0);
+	}
 
-   WR_HARPOON(p_port+hp_scsisig, curr_phz);
+	if (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {
+		WR_HARPOON(p_port + hp_autostart_0,
+			   (AUTO_IMMED + DISCONNECT_START));
+		while (!(RDW_HARPOON((p_port + hp_intstat)) & AUTO_INT)) {
+		}
 
-   while ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)) &&
-      (curr_phz == (RD_HARPOON(p_port+hp_scsisig) & (unsigned char)S_SCSI_PHZ)) )
-      {
-      if (curr_phz & (unsigned char)SCSI_IOBIT)
-         {
-      	WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | SCSI_INBIT));
-
-	      if (!(RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY))
-            {
-	         RD_HARPOON(p_port+hp_fifodata_0);
-	         }
-	      }
-      else
-         {
-      	WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | HOST_WRT));
-   	   if (RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY)
-            {
-	         WR_HARPOON(p_port+hp_fifodata_0,0xFA);
-	         }
-	      }
-      } /* End of While loop for padding data I/O phase */
-
-      while ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
-         {
-         if (RD_HARPOON(p_port+hp_scsisig) & SCSI_REQ)
-      	   break;
-         }
-
-      WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | SCSI_INBIT));
-      while (!(RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY))
-         {
-         RD_HARPOON(p_port+hp_fifodata_0);
-         }
-
-      if ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
-         {
-         WR_HARPOON(p_port+hp_autostart_0, (AUTO_IMMED+DISCONNECT_START));
-         while (!(RDW_HARPOON((p_port+hp_intstat)) & AUTO_INT)) {}
-
-         if (RDW_HARPOON((p_port+hp_intstat)) & (ICMD_COMP | ITAR_DISC))
-   	   while (!(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RSEL))) ;
-         }
+		if (RDW_HARPOON((p_port + hp_intstat)) &
+		    (ICMD_COMP | ITAR_DISC))
+			while (!
+			       (RDW_HARPOON((p_port + hp_intstat)) &
+				(BUS_FREE | RSEL))) ;
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_schkdd
@@ -4041,109 +3825,97 @@ static void FPT_sxfrp(unsigned long p_port, unsigned char p_card)
 
 static void FPT_schkdd(unsigned long port, unsigned char p_card)
 {
-   unsigned short TimeOutLoop;
+	unsigned short TimeOutLoop;
 	unsigned char sPhase;
 
-   struct sccb * currSCCB;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-
-
-   if ((currSCCB->Sccb_scsistat != DATA_OUT_ST) &&
-       (currSCCB->Sccb_scsistat != DATA_IN_ST)) {
-      return;
-      }
+	struct sccb *currSCCB;
 
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
+	if ((currSCCB->Sccb_scsistat != DATA_OUT_ST) &&
+	    (currSCCB->Sccb_scsistat != DATA_IN_ST)) {
+		return;
+	}
 
-   if (currSCCB->Sccb_XferState & F_ODD_BALL_CNT)
-      {
+	if (currSCCB->Sccb_XferState & F_ODD_BALL_CNT) {
 
-      currSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt-1);
+		currSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - 1);
 
-      currSCCB->Sccb_XferCnt = 1;
+		currSCCB->Sccb_XferCnt = 1;
 
-      currSCCB->Sccb_XferState &= ~F_ODD_BALL_CNT;
-      WRW_HARPOON((port+hp_fiforead), (unsigned short) 0x00);
-      WR_HARPOON(port+hp_xferstat, 0x00);
-      }
+		currSCCB->Sccb_XferState &= ~F_ODD_BALL_CNT;
+		WRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);
+		WR_HARPOON(port + hp_xferstat, 0x00);
+	}
 
-   else
-      {
+	else {
 
-      currSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;
+		currSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;
 
-      currSCCB->Sccb_XferCnt = 0;
-      }
+		currSCCB->Sccb_XferCnt = 0;
+	}
 
-   if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
-      (currSCCB->HostStatus == SCCB_COMPLETE)) {
+	if ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&
+	    (currSCCB->HostStatus == SCCB_COMPLETE)) {
 
-      currSCCB->HostStatus = SCCB_PARITY_ERR;
-      WRW_HARPOON((port+hp_intstat), PARITY);
-      }
+		currSCCB->HostStatus = SCCB_PARITY_ERR;
+		WRW_HARPOON((port + hp_intstat), PARITY);
+	}
 
+	FPT_hostDataXferAbort(port, p_card, currSCCB);
 
-   FPT_hostDataXferAbort(port,p_card,currSCCB);
+	while (RD_HARPOON(port + hp_scsisig) & SCSI_ACK) {
+	}
 
+	TimeOutLoop = 0;
 
-   while (RD_HARPOON(port+hp_scsisig) & SCSI_ACK) {}
+	while (RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY) {
+		if (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {
+			return;
+		}
+		if (RD_HARPOON(port + hp_offsetctr) & (unsigned char)0x1F) {
+			break;
+		}
+		if (RDW_HARPOON((port + hp_intstat)) & RESET) {
+			return;
+		}
+		if ((RD_HARPOON(port + hp_scsisig) & SCSI_REQ)
+		    || (TimeOutLoop++ > 0x3000))
+			break;
+	}
 
-   TimeOutLoop = 0;
+	sPhase = RD_HARPOON(port + hp_scsisig) & (SCSI_BSY | S_SCSI_PHZ);
+	if ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) ||
+	    (RD_HARPOON(port + hp_offsetctr) & (unsigned char)0x1F) ||
+	    (sPhase == (SCSI_BSY | S_DATAO_PH)) ||
+	    (sPhase == (SCSI_BSY | S_DATAI_PH))) {
 
-   while(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)
-      {
-      if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE) {
-	      return;
-   	   }
-      if (RD_HARPOON(port+hp_offsetctr) & (unsigned char)0x1F) {
-	      break;
-   	   }
-      if (RDW_HARPOON((port+hp_intstat)) & RESET) {
-	      return;
-   	   }
-      if ((RD_HARPOON(port+hp_scsisig) & SCSI_REQ) || (TimeOutLoop++>0x3000) )
-   	   break;
-      }
+		WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
 
-	sPhase = RD_HARPOON(port+hp_scsisig) & (SCSI_BSY | S_SCSI_PHZ);
-   if ((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))                     ||
-      (RD_HARPOON(port+hp_offsetctr) & (unsigned char)0x1F)                       ||
-      (sPhase == (SCSI_BSY | S_DATAO_PH)) ||
-      (sPhase == (SCSI_BSY | S_DATAI_PH)))
-      {
+		if (!(currSCCB->Sccb_XferState & F_ALL_XFERRED)) {
+			if (currSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+				FPT_phaseDataIn(port, p_card);
+			}
 
-	   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+			else {
+				FPT_phaseDataOut(port, p_card);
+			}
+		} else {
+			FPT_sxfrp(port, p_card);
+			if (!(RDW_HARPOON((port + hp_intstat)) &
+			      (BUS_FREE | ICMD_COMP | ITAR_DISC | RESET))) {
+				WRW_HARPOON((port + hp_intstat), AUTO_INT);
+				FPT_phaseDecode(port, p_card);
+			}
+		}
 
-	   if (!(currSCCB->Sccb_XferState & F_ALL_XFERRED))
-         {
-	      if (currSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
-	         FPT_phaseDataIn(port,p_card);
-	      	}
+	}
 
-	   	else {
-	       FPT_phaseDataOut(port,p_card);
-	       	}
-	   	}
-		else
-      	{
-	   	FPT_sxfrp(port,p_card);
-	   	if (!(RDW_HARPOON((port+hp_intstat)) &
-		      (BUS_FREE | ICMD_COMP | ITAR_DISC | RESET)))
-         {
-   		WRW_HARPOON((port+hp_intstat), AUTO_INT);
-		   FPT_phaseDecode(port,p_card);
-		   }
-	   }
-
-   }
-
-   else {
-      WR_HARPOON(port+hp_portctrl_0, 0x00);
-      }
+	else {
+		WR_HARPOON(port + hp_portctrl_0, 0x00);
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sinits
@@ -4152,39 +3924,37 @@ static void FPT_schkdd(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sinits(struct sccb * p_sccb, unsigned char p_card)
+static void FPT_sinits(struct sccb *p_sccb, unsigned char p_card)
 {
-   struct sccb_mgr_tar_info * currTar_Info;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-	if((p_sccb->TargID > MAX_SCSI_TAR) || (p_sccb->Lun > MAX_LUN))
-	{
+	if ((p_sccb->TargID > MAX_SCSI_TAR) || (p_sccb->Lun > MAX_LUN)) {
 		return;
 	}
-   currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
+	currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
 
-   p_sccb->Sccb_XferState     = 0x00;
-   p_sccb->Sccb_XferCnt       = p_sccb->DataLength;
+	p_sccb->Sccb_XferState = 0x00;
+	p_sccb->Sccb_XferCnt = p_sccb->DataLength;
 
-   if ((p_sccb->OperationCode == SCATTER_GATHER_COMMAND) ||
-      (p_sccb->OperationCode == RESIDUAL_SG_COMMAND)) {
+	if ((p_sccb->OperationCode == SCATTER_GATHER_COMMAND) ||
+	    (p_sccb->OperationCode == RESIDUAL_SG_COMMAND)) {
 
-      p_sccb->Sccb_SGoffset   = 0;
-      p_sccb->Sccb_XferState  = F_SG_XFER;
-      p_sccb->Sccb_XferCnt    = 0x00;
-      }
+		p_sccb->Sccb_SGoffset = 0;
+		p_sccb->Sccb_XferState = F_SG_XFER;
+		p_sccb->Sccb_XferCnt = 0x00;
+	}
 
-   if (p_sccb->DataLength == 0x00)
+	if (p_sccb->DataLength == 0x00)
 
-      p_sccb->Sccb_XferState |= F_ALL_XFERRED;
+		p_sccb->Sccb_XferState |= F_ALL_XFERRED;
 
-   if (p_sccb->ControlByte & F_USE_CMD_Q)
-      {
-      if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)
-         p_sccb->ControlByte &= ~F_USE_CMD_Q;
+	if (p_sccb->ControlByte & F_USE_CMD_Q) {
+		if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)
+			p_sccb->ControlByte &= ~F_USE_CMD_Q;
 
-      else
-	      currTar_Info->TarStatus |= TAG_Q_TRYING;
-      }
+		else
+			currTar_Info->TarStatus |= TAG_Q_TRYING;
+	}
 
 /*      For !single SCSI device in system  & device allow Disconnect
 	or command is tag_q type then send Cmd with Disconnect Enable
@@ -4195,35 +3965,35 @@ static void FPT_sinits(struct sccb * p_sccb, unsigned char p_card)
       (currTar_Info->TarStatus & TAR_ALLOW_DISC)) ||
       (currTar_Info->TarStatus & TAG_Q_TRYING)) {
 */
-   if ((currTar_Info->TarStatus & TAR_ALLOW_DISC) ||
-      (currTar_Info->TarStatus & TAG_Q_TRYING)) {
-      p_sccb->Sccb_idmsg      = (unsigned char)(SMIDENT | DISC_PRIV) | p_sccb->Lun;
-      }
+	if ((currTar_Info->TarStatus & TAR_ALLOW_DISC) ||
+	    (currTar_Info->TarStatus & TAG_Q_TRYING)) {
+		p_sccb->Sccb_idmsg =
+		    (unsigned char)(SMIDENT | DISC_PRIV) | p_sccb->Lun;
+	}
 
-   else {
+	else {
 
-      p_sccb->Sccb_idmsg      = (unsigned char)SMIDENT | p_sccb->Lun;
-      }
+		p_sccb->Sccb_idmsg = (unsigned char)SMIDENT | p_sccb->Lun;
+	}
 
-   p_sccb->HostStatus         = 0x00;
-   p_sccb->TargetStatus       = 0x00;
-   p_sccb->Sccb_tag           = 0x00;
-   p_sccb->Sccb_MGRFlags      = 0x00;
-   p_sccb->Sccb_sgseg         = 0x00;
-   p_sccb->Sccb_ATC           = 0x00;
-   p_sccb->Sccb_savedATC      = 0x00;
+	p_sccb->HostStatus = 0x00;
+	p_sccb->TargetStatus = 0x00;
+	p_sccb->Sccb_tag = 0x00;
+	p_sccb->Sccb_MGRFlags = 0x00;
+	p_sccb->Sccb_sgseg = 0x00;
+	p_sccb->Sccb_ATC = 0x00;
+	p_sccb->Sccb_savedATC = 0x00;
 /*
    p_sccb->SccbVirtDataPtr    = 0x00;
    p_sccb->Sccb_forwardlink   = NULL;
    p_sccb->Sccb_backlink      = NULL;
  */
-   p_sccb->Sccb_scsistat      = BUS_FREE_ST;
-   p_sccb->SccbStatus         = SCCB_IN_PROCESS;
-   p_sccb->Sccb_scsimsg       = SMNO_OP;
+	p_sccb->Sccb_scsistat = BUS_FREE_ST;
+	p_sccb->SccbStatus = SCCB_IN_PROCESS;
+	p_sccb->Sccb_scsimsg = SMNO_OP;
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Phase Decode
@@ -4234,21 +4004,19 @@ static void FPT_sinits(struct sccb * p_sccb, unsigned char p_card)
 
 static void FPT_phaseDecode(unsigned long p_port, unsigned char p_card)
 {
-   unsigned char phase_ref;
-   void (*phase) (unsigned long, unsigned char);
-
+	unsigned char phase_ref;
+	void (*phase) (unsigned long, unsigned char);
 
-   DISABLE_AUTO(p_port);
+	DISABLE_AUTO(p_port);
 
-   phase_ref = (unsigned char) (RD_HARPOON(p_port+hp_scsisig) & S_SCSI_PHZ);
+	phase_ref =
+	    (unsigned char)(RD_HARPOON(p_port + hp_scsisig) & S_SCSI_PHZ);
 
-   phase = FPT_s_PhaseTbl[phase_ref];
+	phase = FPT_s_PhaseTbl[phase_ref];
 
-   (*phase)(p_port, p_card);           /* Call the correct phase func */
+	(*phase) (p_port, p_card);	/* Call the correct phase func */
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: Data Out Phase
@@ -4260,39 +4028,36 @@ static void FPT_phaseDecode(unsigned long p_port, unsigned char p_card)
 static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
 {
 
-   struct sccb * currSCCB;
+	struct sccb *currSCCB;
 
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-   if (currSCCB == NULL)
-      {
-      return;  /* Exit if No SCCB record */
-      }
-
-   currSCCB->Sccb_scsistat = DATA_OUT_ST;
-   currSCCB->Sccb_XferState &= ~(F_HOST_XFER_DIR | F_NO_DATA_YET);
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	if (currSCCB == NULL) {
+		return;		/* Exit if No SCCB record */
+	}
 
-   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+	currSCCB->Sccb_scsistat = DATA_OUT_ST;
+	currSCCB->Sccb_XferState &= ~(F_HOST_XFER_DIR | F_NO_DATA_YET);
 
-   WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+	WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
 
-   WR_HARPOON(port+hp_autostart_0, (END_DATA+END_DATA_START));
+	WRW_HARPOON((port + hp_intstat), XFER_CNT_0);
 
-   FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
+	WR_HARPOON(port + hp_autostart_0, (END_DATA + END_DATA_START));
 
-   if (currSCCB->Sccb_XferCnt == 0) {
+	FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
+	if (currSCCB->Sccb_XferCnt == 0) {
 
-      if ((currSCCB->ControlByte & SCCB_DATA_XFER_OUT) &&
-	 (currSCCB->HostStatus == SCCB_COMPLETE))
-	 currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
+		if ((currSCCB->ControlByte & SCCB_DATA_XFER_OUT) &&
+		    (currSCCB->HostStatus == SCCB_COMPLETE))
+			currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
 
-      FPT_sxfrp(port,p_card);
-      if (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | RESET)))
-	    FPT_phaseDecode(port,p_card);
-      }
+		FPT_sxfrp(port, p_card);
+		if (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | RESET)))
+			FPT_phaseDecode(port, p_card);
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Data In Phase
@@ -4304,40 +4069,37 @@ static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
 static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
 {
 
-   struct sccb * currSCCB;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-
-   if (currSCCB == NULL)
-      {
-      return;  /* Exit if No SCCB record */
-      }
+	struct sccb *currSCCB;
 
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-   currSCCB->Sccb_scsistat = DATA_IN_ST;
-   currSCCB->Sccb_XferState |= F_HOST_XFER_DIR;
-   currSCCB->Sccb_XferState &= ~F_NO_DATA_YET;
+	if (currSCCB == NULL) {
+		return;		/* Exit if No SCCB record */
+	}
 
-   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+	currSCCB->Sccb_scsistat = DATA_IN_ST;
+	currSCCB->Sccb_XferState |= F_HOST_XFER_DIR;
+	currSCCB->Sccb_XferState &= ~F_NO_DATA_YET;
 
-   WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+	WR_HARPOON(port + hp_portctrl_0, SCSI_PORT);
 
-   WR_HARPOON(port+hp_autostart_0, (END_DATA+END_DATA_START));
+	WRW_HARPOON((port + hp_intstat), XFER_CNT_0);
 
-   FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
+	WR_HARPOON(port + hp_autostart_0, (END_DATA + END_DATA_START));
 
-   if (currSCCB->Sccb_XferCnt == 0) {
+	FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
+	if (currSCCB->Sccb_XferCnt == 0) {
 
-      if ((currSCCB->ControlByte & SCCB_DATA_XFER_IN) &&
-	 (currSCCB->HostStatus == SCCB_COMPLETE))
-	 currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
+		if ((currSCCB->ControlByte & SCCB_DATA_XFER_IN) &&
+		    (currSCCB->HostStatus == SCCB_COMPLETE))
+			currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
 
-      FPT_sxfrp(port,p_card);
-      if (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | RESET)))
-	    FPT_phaseDecode(port,p_card);
+		FPT_sxfrp(port, p_card);
+		if (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | RESET)))
+			FPT_phaseDecode(port, p_card);
 
-      }
+	}
 }
 
 /*---------------------------------------------------------------------
@@ -4350,48 +4112,47 @@ static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
 
 static void FPT_phaseCommand(unsigned long p_port, unsigned char p_card)
 {
-   struct sccb * currSCCB;
-   unsigned long cdb_reg;
-   unsigned char i;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	struct sccb *currSCCB;
+	unsigned long cdb_reg;
+	unsigned char i;
 
-   if (currSCCB->OperationCode == RESET_COMMAND) {
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-      currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
-      currSCCB->CdbLength = SIX_BYTE_CMD;
-      }
+	if (currSCCB->OperationCode == RESET_COMMAND) {
 
-   WR_HARPOON(p_port+hp_scsisig, 0x00);
+		currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+		currSCCB->CdbLength = SIX_BYTE_CMD;
+	}
 
-   ARAM_ACCESS(p_port);
+	WR_HARPOON(p_port + hp_scsisig, 0x00);
 
+	ARAM_ACCESS(p_port);
 
-   cdb_reg = p_port + CMD_STRT;
+	cdb_reg = p_port + CMD_STRT;
 
-   for (i=0; i < currSCCB->CdbLength; i++) {
+	for (i = 0; i < currSCCB->CdbLength; i++) {
 
-      if (currSCCB->OperationCode == RESET_COMMAND)
+		if (currSCCB->OperationCode == RESET_COMMAND)
 
-	 WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + 0x00));
+			WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + 0x00));
 
-      else
-	 WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + currSCCB->Cdb[i]));
-      cdb_reg +=2;
-      }
+		else
+			WRW_HARPOON(cdb_reg,
+				    (MPM_OP + ACOMMAND + currSCCB->Cdb[i]));
+		cdb_reg += 2;
+	}
 
-   if (currSCCB->CdbLength != TWELVE_BYTE_CMD)
-      WRW_HARPOON(cdb_reg, (BRH_OP+ALWAYS+    NP));
+	if (currSCCB->CdbLength != TWELVE_BYTE_CMD)
+		WRW_HARPOON(cdb_reg, (BRH_OP + ALWAYS + NP));
 
-   WR_HARPOON(p_port+hp_portctrl_0,(SCSI_PORT));
+	WR_HARPOON(p_port + hp_portctrl_0, (SCSI_PORT));
 
-   currSCCB->Sccb_scsistat = COMMAND_ST;
+	currSCCB->Sccb_scsistat = COMMAND_ST;
 
-   WR_HARPOON(p_port+hp_autostart_3, (AUTO_IMMED | CMD_ONLY_STRT));
-   SGRAM_ACCESS(p_port);
+	WR_HARPOON(p_port + hp_autostart_3, (AUTO_IMMED | CMD_ONLY_STRT));
+	SGRAM_ACCESS(p_port);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Status phase
@@ -4402,17 +4163,16 @@ static void FPT_phaseCommand(unsigned long p_port, unsigned char p_card)
 
 static void FPT_phaseStatus(unsigned long port, unsigned char p_card)
 {
-   /* Start-up the automation to finish off this command and let the
-      isr handle the interrupt for command complete when it comes in.
-      We could wait here for the interrupt to be generated?
-    */
+	/* Start-up the automation to finish off this command and let the
+	   isr handle the interrupt for command complete when it comes in.
+	   We could wait here for the interrupt to be generated?
+	 */
 
-   WR_HARPOON(port+hp_scsisig, 0x00);
+	WR_HARPOON(port + hp_scsisig, 0x00);
 
-   WR_HARPOON(port+hp_autostart_0, (AUTO_IMMED+END_DATA_START));
+	WR_HARPOON(port + hp_autostart_0, (AUTO_IMMED + END_DATA_START));
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Phase Message Out
@@ -4424,9 +4184,9 @@ static void FPT_phaseStatus(unsigned long port, unsigned char p_card)
 
 static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 {
-	unsigned char message,scsiID;
-	struct sccb * currSCCB;
-	struct sccb_mgr_tar_info * currTar_Info;
+	unsigned char message, scsiID;
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4435,133 +4195,124 @@ static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 		message = currSCCB->Sccb_scsimsg;
 		scsiID = currSCCB->TargID;
 
-		if (message == SMDEV_RESET) 
-		{
-
+		if (message == SMDEV_RESET) {
 
 			currTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];
 			currTar_Info->TarSyncCtrl = 0;
-			FPT_sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
+			FPT_sssyncv(port, scsiID, NARROW_SCSI, currTar_Info);
 
-			if (FPT_sccbMgrTbl[p_card][scsiID].TarEEValue & EE_SYNC_MASK) 
-			{
+			if (FPT_sccbMgrTbl[p_card][scsiID].
+			    TarEEValue & EE_SYNC_MASK) {
 
-				FPT_sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_SYNC_MASK;
+				FPT_sccbMgrTbl[p_card][scsiID].TarStatus &=
+				    ~TAR_SYNC_MASK;
 
 			}
 
-			if (FPT_sccbMgrTbl[p_card][scsiID].TarEEValue & EE_WIDE_SCSI) 
-			{
+			if (FPT_sccbMgrTbl[p_card][scsiID].
+			    TarEEValue & EE_WIDE_SCSI) {
 
-				FPT_sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_WIDE_MASK;
+				FPT_sccbMgrTbl[p_card][scsiID].TarStatus &=
+				    ~TAR_WIDE_MASK;
 			}
 
-
-			FPT_queueFlushSccb(p_card,SCCB_COMPLETE);
-			FPT_SccbMgrTableInitTarget(p_card,scsiID);
-		}
-		else if (currSCCB->Sccb_scsistat == ABORT_ST)
-		{
+			FPT_queueFlushSccb(p_card, SCCB_COMPLETE);
+			FPT_SccbMgrTableInitTarget(p_card, scsiID);
+		} else if (currSCCB->Sccb_scsistat == ABORT_ST) {
 			currSCCB->HostStatus = SCCB_COMPLETE;
-			if(FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] != NULL)
-			{
-				FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+			if (FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] !=
+			    NULL) {
+				FPT_BL_Card[p_card].discQ_Tbl[currSCCB->
+							      Sccb_tag] = NULL;
 				FPT_sccbMgrTbl[p_card][scsiID].TarTagQ_Cnt--;
 			}
-					
-		}
 
-		else if (currSCCB->Sccb_scsistat < COMMAND_ST) 
-		{
+		}
 
+		else if (currSCCB->Sccb_scsistat < COMMAND_ST) {
 
-			if(message == SMNO_OP)
-			{
+			if (message == SMNO_OP) {
 				currSCCB->Sccb_MGRFlags |= F_DEV_SELECTED;
-		
-				FPT_ssel(port,p_card);
+
+				FPT_ssel(port, p_card);
 				return;
 			}
-		}
-		else 
-		{
-
+		} else {
 
 			if (message == SMABORT)
 
-				FPT_queueFlushSccb(p_card,SCCB_COMPLETE);
+				FPT_queueFlushSccb(p_card, SCCB_COMPLETE);
 		}
 
-	}
-	else 
-	{
+	} else {
 		message = SMABORT;
 	}
 
-	WRW_HARPOON((port+hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));
-
+	WRW_HARPOON((port + hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));
 
-	WR_HARPOON(port+hp_portctrl_0, SCSI_BUS_EN);
+	WR_HARPOON(port + hp_portctrl_0, SCSI_BUS_EN);
 
-	WR_HARPOON(port+hp_scsidata_0,message);
+	WR_HARPOON(port + hp_scsidata_0, message);
 
-	WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+	WR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));
 
 	ACCEPT_MSG(port);
 
-	WR_HARPOON(port+hp_portctrl_0, 0x00);
+	WR_HARPOON(port + hp_portctrl_0, 0x00);
 
-	if ((message == SMABORT) || (message == SMDEV_RESET) || 
-				(message == SMABORT_TAG) ) 
-	{
+	if ((message == SMABORT) || (message == SMDEV_RESET) ||
+	    (message == SMABORT_TAG)) {
 
-		while(!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | PHASE))) {}
+		while (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | PHASE))) {
+		}
 
-		if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE) 
-		{
-			WRW_HARPOON((port+hp_intstat), BUS_FREE);
+		if (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {
+			WRW_HARPOON((port + hp_intstat), BUS_FREE);
 
-			if (currSCCB != NULL) 
-			{
+			if (currSCCB != NULL) {
 
-				if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-					((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
+				if ((FPT_BL_Card[p_card].
+				     globalFlags & F_CONLUN_IO)
+				    &&
+				    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				      TarStatus & TAR_TAG_Q_MASK) !=
+				     TAG_Q_TRYING))
+					FPT_sccbMgrTbl[p_card][currSCCB->
+							       TargID].
+					    TarLUNBusy[currSCCB->Lun] = 0;
 				else
-					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
+					FPT_sccbMgrTbl[p_card][currSCCB->
+							       TargID].
+					    TarLUNBusy[0] = 0;
 
-				FPT_queueCmdComplete(&FPT_BL_Card[p_card],currSCCB, p_card);
+				FPT_queueCmdComplete(&FPT_BL_Card[p_card],
+						     currSCCB, p_card);
 			}
 
-			else 
-			{
-				FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+			else {
+				FPT_BL_Card[p_card].globalFlags |=
+				    F_NEW_SCCB_CMD;
 			}
 		}
 
-		else 
-		{
+		else {
 
-			FPT_sxfrp(port,p_card);
+			FPT_sxfrp(port, p_card);
 		}
 	}
 
-	else 
-	{
+	else {
 
-		if(message == SMPARITY)
-		{
+		if (message == SMPARITY) {
 			currSCCB->Sccb_scsimsg = SMNO_OP;
-			WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
-		}
-		else
-		{
-			FPT_sxfrp(port,p_card);
+			WR_HARPOON(port + hp_autostart_1,
+				   (AUTO_IMMED + DISCONNECT_START));
+		} else {
+			FPT_sxfrp(port, p_card);
 		}
 	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Message In phase
@@ -4573,46 +4324,40 @@ static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
 {
 	unsigned char message;
-	struct sccb * currSCCB;
+	struct sccb *currSCCB;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-	if (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) 
-	{
+	if (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {
 
 		FPT_phaseChkFifo(port, p_card);
 	}
 
-	message = RD_HARPOON(port+hp_scsidata_0);
-	if ((message == SMDISC) || (message == SMSAVE_DATA_PTR)) 
-	{
+	message = RD_HARPOON(port + hp_scsidata_0);
+	if ((message == SMDISC) || (message == SMSAVE_DATA_PTR)) {
 
-		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+END_DATA_START));
+		WR_HARPOON(port + hp_autostart_1,
+			   (AUTO_IMMED + END_DATA_START));
 
 	}
 
-	else 
-	{
-
-		message = FPT_sfm(port,currSCCB);
-		if (message) 
-		{
+	else {
 
+		message = FPT_sfm(port, currSCCB);
+		if (message) {
 
-			FPT_sdecm(message,port,p_card);
+			FPT_sdecm(message, port, p_card);
 
-		}
-		else
-		{
-			if(currSCCB->Sccb_scsimsg != SMPARITY)
+		} else {
+			if (currSCCB->Sccb_scsimsg != SMPARITY)
 				ACCEPT_MSG(port);
-			WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+			WR_HARPOON(port + hp_autostart_1,
+				   (AUTO_IMMED + DISCONNECT_START));
 		}
 	}
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Illegal phase
@@ -4625,23 +4370,21 @@ static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
 
 static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
 {
-   struct sccb * currSCCB;
+	struct sccb *currSCCB;
 
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-   WR_HARPOON(port+hp_scsisig, RD_HARPOON(port+hp_scsisig));
-   if (currSCCB != NULL) {
+	WR_HARPOON(port + hp_scsisig, RD_HARPOON(port + hp_scsisig));
+	if (currSCCB != NULL) {
 
-      currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
-      currSCCB->Sccb_scsistat = ABORT_ST;
-      currSCCB->Sccb_scsimsg = SMABORT;
-      }
+		currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+		currSCCB->Sccb_scsistat = ABORT_ST;
+		currSCCB->Sccb_scsimsg = SMABORT;
+	}
 
-   ACCEPT_MSG_ATN(port);
+	ACCEPT_MSG_ATN(port);
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: Phase Check FIFO
@@ -4653,74 +4396,67 @@ static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
 
 static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
 {
-   unsigned long xfercnt;
-   struct sccb * currSCCB;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-
-   if (currSCCB->Sccb_scsistat == DATA_IN_ST)
-      {
-
-      while((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)) &&
-	      (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY)) {}
-
-
-      if (!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))
-         {
-	      currSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;
+	unsigned long xfercnt;
+	struct sccb *currSCCB;
 
-	      currSCCB->Sccb_XferCnt = 0;
-
-	      if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
-	            (currSCCB->HostStatus == SCCB_COMPLETE))
-            {
-	         currSCCB->HostStatus = SCCB_PARITY_ERR;
-	         WRW_HARPOON((port+hp_intstat), PARITY);
-	         }
-
-	      FPT_hostDataXferAbort(port,p_card,currSCCB);
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-	      FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
+	if (currSCCB->Sccb_scsistat == DATA_IN_ST) {
 
-	      while((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)) &&
-	         (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY)) {}
+		while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) &&
+		       (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)) {
+		}
 
-	      }
-      }  /*End Data In specific code. */
+		if (!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) {
+			currSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;
 
+			currSCCB->Sccb_XferCnt = 0;
 
+			if ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&
+			    (currSCCB->HostStatus == SCCB_COMPLETE)) {
+				currSCCB->HostStatus = SCCB_PARITY_ERR;
+				WRW_HARPOON((port + hp_intstat), PARITY);
+			}
 
-   GET_XFER_CNT(port,xfercnt);
+			FPT_hostDataXferAbort(port, p_card, currSCCB);
 
+			FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
-   WR_HARPOON(port+hp_xfercnt_0, 0x00);
+			while ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY))
+			       && (RD_HARPOON(port + hp_ext_status) &
+				   BM_CMD_BUSY)) {
+			}
 
+		}
+	}
 
-   WR_HARPOON(port+hp_portctrl_0, 0x00);
+	/*End Data In specific code. */
+	GET_XFER_CNT(port, xfercnt);
 
-   currSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - xfercnt);
+	WR_HARPOON(port + hp_xfercnt_0, 0x00);
 
-   currSCCB->Sccb_XferCnt = xfercnt;
+	WR_HARPOON(port + hp_portctrl_0, 0x00);
 
-   if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
-      (currSCCB->HostStatus == SCCB_COMPLETE)) {
+	currSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - xfercnt);
 
-      currSCCB->HostStatus = SCCB_PARITY_ERR;
-      WRW_HARPOON((port+hp_intstat), PARITY);
-      }
+	currSCCB->Sccb_XferCnt = xfercnt;
 
+	if ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&
+	    (currSCCB->HostStatus == SCCB_COMPLETE)) {
 
-   FPT_hostDataXferAbort(port,p_card,currSCCB);
+		currSCCB->HostStatus = SCCB_PARITY_ERR;
+		WRW_HARPOON((port + hp_intstat), PARITY);
+	}
 
+	FPT_hostDataXferAbort(port, p_card, currSCCB);
 
-   WR_HARPOON(port+hp_fifowrite, 0x00);
-   WR_HARPOON(port+hp_fiforead, 0x00);
-   WR_HARPOON(port+hp_xferstat, 0x00);
+	WR_HARPOON(port + hp_fifowrite, 0x00);
+	WR_HARPOON(port + hp_fiforead, 0x00);
+	WR_HARPOON(port + hp_xferstat, 0x00);
 
-   WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+	WRW_HARPOON((port + hp_intstat), XFER_CNT_0);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Phase Bus Free
@@ -4731,94 +4467,92 @@ static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
  *---------------------------------------------------------------------*/
 static void FPT_phaseBusFree(unsigned long port, unsigned char p_card)
 {
-   struct sccb * currSCCB;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	struct sccb *currSCCB;
 
-   if (currSCCB != NULL)
-      {
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-      DISABLE_AUTO(port);
+	if (currSCCB != NULL) {
 
+		DISABLE_AUTO(port);
 
-      if (currSCCB->OperationCode == RESET_COMMAND)
-         {
+		if (currSCCB->OperationCode == RESET_COMMAND) {
 
-			if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	   		 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
+			if ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+			    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[currSCCB->Lun] = 0;
 			else
-		   	 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
-
-	      FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
-
-	      FPT_queueSearchSelect(&FPT_BL_Card[p_card],p_card);
-
-	      }
-
-      else if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
-	      {
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
-			         (unsigned char)SYNC_SUPPORTED;
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
-	      }
-
-      else if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
-	      {
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
-		            (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
-		   TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
-
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
-	      }
-
-      else if(currSCCB->Sccb_scsistat == SELECT_Q_ST)
-	      {
-	      /* Make sure this is not a phony BUS_FREE.  If we were
-	      reselected or if BUSY is NOT on then this is a
-	      valid BUS FREE.  SRR Wednesday, 5/10/1995.     */
-
-	      if ((!(RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ||
-	         (RDW_HARPOON((port+hp_intstat)) & RSEL))
-	         {
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_TAG_Q_MASK;
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |= TAG_Q_REJECT;
-	         }
-
-	      else
-            {
-	         return;
-	         }
-         }
-
-      else
-	      {
-
-	      currSCCB->Sccb_scsistat = BUS_FREE_ST;
-
-         if (!currSCCB->HostStatus)
-	         {
-	         currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
-	         }
-
-			if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	   		 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
-			else
-		   	 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[0] = 0;
+
+			FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB,
+					     p_card);
+
+			FPT_queueSearchSelect(&FPT_BL_Card[p_card], p_card);
+
+		}
+
+		else if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
+			    (unsigned char)SYNC_SUPPORTED;
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=
+			    ~EE_SYNC_MASK;
+		}
+
+		else if (currSCCB->Sccb_scsistat == SELECT_WN_ST) {
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
+			    (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			     TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
+
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=
+			    ~EE_WIDE_SCSI;
+		}
+
+		else if (currSCCB->Sccb_scsistat == SELECT_Q_ST) {
+			/* Make sure this is not a phony BUS_FREE.  If we were
+			   reselected or if BUSY is NOT on then this is a
+			   valid BUS FREE.  SRR Wednesday, 5/10/1995.     */
+
+			if ((!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ||
+			    (RDW_HARPOON((port + hp_intstat)) & RSEL)) {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarStatus &= ~TAR_TAG_Q_MASK;
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarStatus |= TAG_Q_REJECT;
+			}
+
+			else {
+				return;
+			}
+		}
 
-	      FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
-	      return;
-	      }
+		else {
 
+			currSCCB->Sccb_scsistat = BUS_FREE_ST;
 
-      FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+			if (!currSCCB->HostStatus) {
+				currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+			}
 
-      } /*end if !=null */
-}
+			if ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+			    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[currSCCB->Lun] = 0;
+			else
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[0] = 0;
 
+			FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB,
+					     p_card);
+			return;
+		}
 
+		FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
+	}			/*end if !=null */
+}
 
 /*---------------------------------------------------------------------
  *
@@ -4829,101 +4563,99 @@ static void FPT_phaseBusFree(unsigned long port, unsigned char p_card)
  *---------------------------------------------------------------------*/
 static void FPT_autoLoadDefaultMap(unsigned long p_port)
 {
-   unsigned long map_addr;
-
-   ARAM_ACCESS(p_port);
-   map_addr = p_port + hp_aramBase;
-
-   WRW_HARPOON(map_addr, (MPM_OP+AMSG_OUT+ 0xC0));  /*ID MESSAGE */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+AMSG_OUT+ 0x20));  /*SIMPLE TAG QUEUEING MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, RAT_OP);                   /*RESET ATTENTION */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+AMSG_OUT+ 0x00));  /*TAG ID MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 0 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 1 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 2 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 3 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 4 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 5 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 6 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 7 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 8 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 9 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 10 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 11 */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CPE_OP+ADATA_OUT+ DINT)); /*JUMP IF DATA OUT */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (TCB_OP+FIFO_0+ DI));     /*JUMP IF NO DATA IN FIFO */
-   map_addr +=2;                                   /*This means AYNC DATA IN */
-   WRW_HARPOON(map_addr, (SSI_OP+   SSI_IDO_STRT)); /*STOP AND INTERRUPT */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CPE_OP+ADATA_IN+DINT));   /*JUMP IF NOT DATA IN PHZ */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CPN_OP+AMSG_IN+  ST));    /*IF NOT MSG IN CHECK 4 DATA IN */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CRD_OP+SDATA+    0x02));  /*SAVE DATA PTR MSG? */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (BRH_OP+NOT_EQ+   DC));    /*GO CHECK FOR DISCONNECT MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MRR_OP+SDATA+    D_AR1)); /*SAVE DATA PTRS MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CPN_OP+AMSG_IN+  ST));    /*IF NOT MSG IN CHECK DATA IN */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CRD_OP+SDATA+    0x04));  /*DISCONNECT MSG? */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (BRH_OP+NOT_EQ+   UNKNWN));/*UKNKNOWN MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MRR_OP+SDATA+    D_BUCKET));/*XFER DISCONNECT MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (SSI_OP+          SSI_ITAR_DISC));/*STOP AND INTERRUPT */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CPN_OP+ASTATUS+  UNKNWN));/*JUMP IF NOT STATUS PHZ. */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MRR_OP+SDATA+  D_AR0));   /*GET STATUS BYTE */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CPN_OP+AMSG_IN+  CC));    /*ERROR IF NOT MSG IN PHZ */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (CRD_OP+SDATA+    0x00));  /*CHECK FOR CMD COMPLETE MSG. */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (BRH_OP+NOT_EQ+   CC));    /*ERROR IF NOT CMD COMPLETE MSG. */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (MRR_OP+SDATA+  D_BUCKET));/*GET CMD COMPLETE MSG */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (SSI_OP+       SSI_ICMD_COMP));/*END OF COMMAND */
-   map_addr +=2;
-
-   WRW_HARPOON(map_addr, (SSI_OP+ SSI_IUNKWN));  /*RECEIVED UNKNOWN MSG BYTE */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (SSI_OP+ SSI_INO_CC));  /*NO COMMAND COMPLETE AFTER STATUS */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (SSI_OP+ SSI_ITICKLE)); /*BIOS Tickled the Mgr */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (SSI_OP+ SSI_IRFAIL));  /*EXPECTED ID/TAG MESSAGES AND */
-   map_addr +=2;                             /* DIDN'T GET ONE */
-   WRW_HARPOON(map_addr, (CRR_OP+AR3+  S_IDREG)); /* comp SCSI SEL ID & AR3*/
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (BRH_OP+EQUAL+   0x00));    /*SEL ID OK then Conti. */
-   map_addr +=2;
-   WRW_HARPOON(map_addr, (SSI_OP+ SSI_INO_CC));  /*NO COMMAND COMPLETE AFTER STATUS */
-
-
-
-   SGRAM_ACCESS(p_port);
+	unsigned long map_addr;
+
+	ARAM_ACCESS(p_port);
+	map_addr = p_port + hp_aramBase;
+
+	WRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0xC0));	/*ID MESSAGE */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0x20));	/*SIMPLE TAG QUEUEING MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, RAT_OP);	/*RESET ATTENTION */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0x00));	/*TAG ID MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 0 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 1 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 2 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 3 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 4 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 5 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 6 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 7 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 8 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 9 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 10 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));	/*CDB BYTE 11 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CPE_OP + ADATA_OUT + DINT));	/*JUMP IF DATA OUT */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (TCB_OP + FIFO_0 + DI));	/*JUMP IF NO DATA IN FIFO */
+	map_addr += 2;		/*This means AYNC DATA IN */
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_IDO_STRT));	/*STOP AND INTERRUPT */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CPE_OP + ADATA_IN + DINT));	/*JUMP IF NOT DATA IN PHZ */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + ST));	/*IF NOT MSG IN CHECK 4 DATA IN */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x02));	/*SAVE DATA PTR MSG? */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + DC));	/*GO CHECK FOR DISCONNECT MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MRR_OP + SDATA + D_AR1));	/*SAVE DATA PTRS MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + ST));	/*IF NOT MSG IN CHECK DATA IN */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x04));	/*DISCONNECT MSG? */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + UNKNWN));	/*UKNKNOWN MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MRR_OP + SDATA + D_BUCKET));	/*XFER DISCONNECT MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_ITAR_DISC));	/*STOP AND INTERRUPT */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CPN_OP + ASTATUS + UNKNWN));	/*JUMP IF NOT STATUS PHZ. */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MRR_OP + SDATA + D_AR0));	/*GET STATUS BYTE */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + CC));	/*ERROR IF NOT MSG IN PHZ */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x00));	/*CHECK FOR CMD COMPLETE MSG. */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + CC));	/*ERROR IF NOT CMD COMPLETE MSG. */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (MRR_OP + SDATA + D_BUCKET));	/*GET CMD COMPLETE MSG */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_ICMD_COMP));	/*END OF COMMAND */
+	map_addr += 2;
+
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_IUNKWN));	/*RECEIVED UNKNOWN MSG BYTE */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_INO_CC));	/*NO COMMAND COMPLETE AFTER STATUS */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_ITICKLE));	/*BIOS Tickled the Mgr */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_IRFAIL));	/*EXPECTED ID/TAG MESSAGES AND */
+	map_addr += 2;		/* DIDN'T GET ONE */
+	WRW_HARPOON(map_addr, (CRR_OP + AR3 + S_IDREG));	/* comp SCSI SEL ID & AR3 */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (BRH_OP + EQUAL + 0x00));	/*SEL ID OK then Conti. */
+	map_addr += 2;
+	WRW_HARPOON(map_addr, (SSI_OP + SSI_INO_CC));	/*NO COMMAND COMPLETE AFTER STATUS */
+
+	SGRAM_ACCESS(p_port);
 }
 
 /*---------------------------------------------------------------------
@@ -4937,201 +4669,259 @@ static void FPT_autoLoadDefaultMap(unsigned long p_port)
 
 static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
 {
-   struct sccb * currSCCB;
-   unsigned char status_byte;
-
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	struct sccb *currSCCB;
+	unsigned char status_byte;
 
-   status_byte = RD_HARPOON(p_port+hp_gp_reg_0);
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-   FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = 0;
+	status_byte = RD_HARPOON(p_port + hp_gp_reg_0);
 
-   if (status_byte != SSGOOD) {
+	FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = 0;
 
-      if (status_byte == SSQ_FULL) {
+	if (status_byte != SSGOOD) {
 
+		if (status_byte == SSQ_FULL) {
 
-			if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-			{
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
-				if(FPT_BL_Card[p_card].discQCount != 0)
+			if (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+			     ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			       TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[currSCCB->Lun] = 1;
+				if (FPT_BL_Card[p_card].discQCount != 0)
 					FPT_BL_Card[p_card].discQCount--;
-				FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
-			}
-			else
-			{
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
-				if(currSCCB->Sccb_tag)
-				{
-					if(FPT_BL_Card[p_card].discQCount != 0)
-						FPT_BL_Card[p_card].discQCount--;
-					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
-				}else
-				{
-					if(FPT_BL_Card[p_card].discQCount != 0)
-						FPT_BL_Card[p_card].discQCount--;
-					FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+				FPT_BL_Card[p_card].
+				    discQ_Tbl[FPT_sccbMgrTbl[p_card]
+					      [currSCCB->TargID].
+					      LunDiscQ_Idx[currSCCB->Lun]] =
+				    NULL;
+			} else {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[0] = 1;
+				if (currSCCB->Sccb_tag) {
+					if (FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].
+						    discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->
+								      Sccb_tag]
+					    = NULL;
+				} else {
+					if (FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].
+						    discQCount--;
+					FPT_BL_Card[p_card].
+					    discQ_Tbl[FPT_sccbMgrTbl[p_card]
+						      [currSCCB->TargID].
+						      LunDiscQ_Idx[0]] = NULL;
 				}
 			}
 
-         currSCCB->Sccb_MGRFlags |= F_STATUSLOADED;
+			currSCCB->Sccb_MGRFlags |= F_STATUSLOADED;
 
-         FPT_queueSelectFail(&FPT_BL_Card[p_card],p_card);
+			FPT_queueSelectFail(&FPT_BL_Card[p_card], p_card);
 
-         return;
-         }
+			return;
+		}
 
-      if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
-         {
-         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
-            (unsigned char)SYNC_SUPPORTED;
+		if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
+			    (unsigned char)SYNC_SUPPORTED;
 
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
-         FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=
+			    ~EE_SYNC_MASK;
+			FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
-			if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-			{
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
-				if(FPT_BL_Card[p_card].discQCount != 0)
+			if (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+			     ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			       TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[currSCCB->Lun] = 1;
+				if (FPT_BL_Card[p_card].discQCount != 0)
 					FPT_BL_Card[p_card].discQCount--;
-				FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
-			}
-			else
-			{
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
-				if(currSCCB->Sccb_tag)
-				{
-					if(FPT_BL_Card[p_card].discQCount != 0)
-						FPT_BL_Card[p_card].discQCount--;
-					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
-				}else
-				{
-					if(FPT_BL_Card[p_card].discQCount != 0)
-						FPT_BL_Card[p_card].discQCount--;
-					FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+				FPT_BL_Card[p_card].
+				    discQ_Tbl[FPT_sccbMgrTbl[p_card]
+					      [currSCCB->TargID].
+					      LunDiscQ_Idx[currSCCB->Lun]] =
+				    NULL;
+			} else {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[0] = 1;
+				if (currSCCB->Sccb_tag) {
+					if (FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].
+						    discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->
+								      Sccb_tag]
+					    = NULL;
+				} else {
+					if (FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].
+						    discQCount--;
+					FPT_BL_Card[p_card].
+					    discQ_Tbl[FPT_sccbMgrTbl[p_card]
+						      [currSCCB->TargID].
+						      LunDiscQ_Idx[0]] = NULL;
 				}
 			}
-         return;
+			return;
 
-         }
+		}
 
-      if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
-         {
+		if (currSCCB->Sccb_scsistat == SELECT_WN_ST) {
 
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
-	         (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
-	         TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
+			    (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			     TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
 
-	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
-         FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+			FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=
+			    ~EE_WIDE_SCSI;
+			FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
-			if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-			{
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
-				if(FPT_BL_Card[p_card].discQCount != 0)
+			if (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+			     ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+			       TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[currSCCB->Lun] = 1;
+				if (FPT_BL_Card[p_card].discQCount != 0)
 					FPT_BL_Card[p_card].discQCount--;
-				FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
-			}
-			else
-			{
-	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
-				if(currSCCB->Sccb_tag)
-				{
-					if(FPT_BL_Card[p_card].discQCount != 0)
-						FPT_BL_Card[p_card].discQCount--;
-					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
-				}else
-				{
-					if(FPT_BL_Card[p_card].discQCount != 0)
-						FPT_BL_Card[p_card].discQCount--;
-					FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+				FPT_BL_Card[p_card].
+				    discQ_Tbl[FPT_sccbMgrTbl[p_card]
+					      [currSCCB->TargID].
+					      LunDiscQ_Idx[currSCCB->Lun]] =
+				    NULL;
+			} else {
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUNBusy[0] = 1;
+				if (currSCCB->Sccb_tag) {
+					if (FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].
+						    discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->
+								      Sccb_tag]
+					    = NULL;
+				} else {
+					if (FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].
+						    discQCount--;
+					FPT_BL_Card[p_card].
+					    discQ_Tbl[FPT_sccbMgrTbl[p_card]
+						      [currSCCB->TargID].
+						      LunDiscQ_Idx[0]] = NULL;
 				}
 			}
-         return;
-      
-         }
-     
-	   if (status_byte == SSCHECK) 
-		{
-			if(FPT_BL_Card[p_card].globalFlags & F_DO_RENEGO)
-			{
-				if (FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_SYNC_MASK)
-				{
-					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_SYNC_MASK;
+			return;
+
+		}
+
+		if (status_byte == SSCHECK) {
+			if (FPT_BL_Card[p_card].globalFlags & F_DO_RENEGO) {
+				if (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarEEValue & EE_SYNC_MASK) {
+					FPT_sccbMgrTbl[p_card][currSCCB->
+							       TargID].
+					    TarStatus &= ~TAR_SYNC_MASK;
 				}
-				if (FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_WIDE_SCSI)
-				{
-					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_WIDE_MASK;
+				if (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarEEValue & EE_WIDE_SCSI) {
+					FPT_sccbMgrTbl[p_card][currSCCB->
+							       TargID].
+					    TarStatus &= ~TAR_WIDE_MASK;
 				}
 			}
 		}
 
-      if (!(currSCCB->Sccb_XferState & F_AUTO_SENSE)) {
-
-         currSCCB->SccbStatus = SCCB_ERROR;
-         currSCCB->TargetStatus = status_byte;
-
-         if (status_byte == SSCHECK) {
-
-            FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA
-               = 1;
-     
-
-            if (currSCCB->RequestSenseLength != NO_AUTO_REQUEST_SENSE) {
-
-               if (currSCCB->RequestSenseLength == 0)
-                  currSCCB->RequestSenseLength = 14;
-
-               FPT_ssenss(&FPT_BL_Card[p_card]);
-               FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
-
- 					if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-						((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-					{
-			         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
-						if(FPT_BL_Card[p_card].discQCount != 0)
-							FPT_BL_Card[p_card].discQCount--;
-						FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
-					}
-					else
-					{
-	   		      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
-						if(currSCCB->Sccb_tag)
-						{
-							if(FPT_BL_Card[p_card].discQCount != 0)
-								FPT_BL_Card[p_card].discQCount--;
-							FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
-						}else
-						{
-							if(FPT_BL_Card[p_card].discQCount != 0)
-								FPT_BL_Card[p_card].discQCount--;
-							FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+		if (!(currSCCB->Sccb_XferState & F_AUTO_SENSE)) {
+
+			currSCCB->SccbStatus = SCCB_ERROR;
+			currSCCB->TargetStatus = status_byte;
+
+			if (status_byte == SSCHECK) {
+
+				FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+				    TarLUN_CA = 1;
+
+				if (currSCCB->RequestSenseLength !=
+				    NO_AUTO_REQUEST_SENSE) {
+
+					if (currSCCB->RequestSenseLength == 0)
+						currSCCB->RequestSenseLength =
+						    14;
+
+					FPT_ssenss(&FPT_BL_Card[p_card]);
+					FPT_BL_Card[p_card].globalFlags |=
+					    F_NEW_SCCB_CMD;
+
+					if (((FPT_BL_Card[p_card].
+					      globalFlags & F_CONLUN_IO)
+					     &&
+					     ((FPT_sccbMgrTbl[p_card]
+					       [currSCCB->TargID].
+					       TarStatus & TAR_TAG_Q_MASK) !=
+					      TAG_Q_TRYING))) {
+						FPT_sccbMgrTbl[p_card]
+						    [currSCCB->TargID].
+						    TarLUNBusy[currSCCB->Lun] =
+						    1;
+						if (FPT_BL_Card[p_card].
+						    discQCount != 0)
+							FPT_BL_Card[p_card].
+							    discQCount--;
+						FPT_BL_Card[p_card].
+						    discQ_Tbl[FPT_sccbMgrTbl
+							      [p_card]
+							      [currSCCB->
+							       TargID].
+							      LunDiscQ_Idx
+							      [currSCCB->Lun]] =
+						    NULL;
+					} else {
+						FPT_sccbMgrTbl[p_card]
+						    [currSCCB->TargID].
+						    TarLUNBusy[0] = 1;
+						if (currSCCB->Sccb_tag) {
+							if (FPT_BL_Card[p_card].
+							    discQCount != 0)
+								FPT_BL_Card
+								    [p_card].
+								    discQCount--;
+							FPT_BL_Card[p_card].
+							    discQ_Tbl[currSCCB->
+								      Sccb_tag]
+							    = NULL;
+						} else {
+							if (FPT_BL_Card[p_card].
+							    discQCount != 0)
+								FPT_BL_Card
+								    [p_card].
+								    discQCount--;
+							FPT_BL_Card[p_card].
+							    discQ_Tbl
+							    [FPT_sccbMgrTbl
+							     [p_card][currSCCB->
+								      TargID].
+							     LunDiscQ_Idx[0]] =
+							    NULL;
 						}
 					}
-               return;
-               }
-            }
-         }
-      }
-
+					return;
+				}
+			}
+		}
+	}
 
-	if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-		((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	   FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
+	if ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+	    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].
+	      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+		FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->
+								    Lun] = 0;
 	else
-	   FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
-
+		FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
 
-   FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
+	FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
 }
 
 #define SHORT_WAIT   0x0000000F
 #define LONG_WAIT    0x0000FFFFL
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Data Transfer Processor
@@ -5150,37 +4940,33 @@ static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
  *              
  *---------------------------------------------------------------------*/
 
-static void FPT_dataXferProcessor(unsigned long port, struct sccb_card * pCurrCard)
+static void FPT_dataXferProcessor(unsigned long port,
+				  struct sccb_card *pCurrCard)
 {
-   struct sccb * currSCCB;
+	struct sccb *currSCCB;
 
-   currSCCB = pCurrCard->currentSCCB;
+	currSCCB = pCurrCard->currentSCCB;
 
-      if (currSCCB->Sccb_XferState & F_SG_XFER)
-			{
-			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
+	if (currSCCB->Sccb_XferState & F_SG_XFER) {
+		if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
+		{
+			currSCCB->Sccb_sgseg += (unsigned char)SG_BUF_CNT;
+			currSCCB->Sccb_SGoffset = 0x00;
+		}
+		pCurrCard->globalFlags |= F_HOST_XFER_ACT;
 
-				{
-		   	currSCCB->Sccb_sgseg += (unsigned char)SG_BUF_CNT;
-         	currSCCB->Sccb_SGoffset = 0x00; 
- 				}
+		FPT_busMstrSGDataXferStart(port, currSCCB);
+	}
+
+	else {
+		if (!(pCurrCard->globalFlags & F_HOST_XFER_ACT)) {
 			pCurrCard->globalFlags |= F_HOST_XFER_ACT;
-         
-         FPT_busMstrSGDataXferStart(port, currSCCB);
-			}
 
-      else
-			{
-			if (!(pCurrCard->globalFlags & F_HOST_XFER_ACT))
-				{
-				pCurrCard->globalFlags |= F_HOST_XFER_ACT;
-         
-         	FPT_busMstrDataXferStart(port, currSCCB);
-         	}
-			}
+			FPT_busMstrDataXferStart(port, currSCCB);
+		}
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: BusMaster Scatter Gather Data Transfer Start
@@ -5188,104 +4974,101 @@ static void FPT_dataXferProcessor(unsigned long port, struct sccb_card * pCurrCa
  * Description:
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrSGDataXferStart(unsigned long p_port, struct sccb * pcurrSCCB)
+static void FPT_busMstrSGDataXferStart(unsigned long p_port,
+				       struct sccb *pcurrSCCB)
 {
-   unsigned long count,addr,tmpSGCnt;
-   unsigned int sg_index;
-   unsigned char sg_count, i;
-   unsigned long reg_offset;
-
-
-   if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
-
-      count =  ((unsigned long) HOST_RD_CMD)<<24;
-      }
-
-   else {
-      count =  ((unsigned long) HOST_WRT_CMD)<<24;
-      }
-
-   sg_count = 0;
-   tmpSGCnt = 0;
-   sg_index = pcurrSCCB->Sccb_sgseg;
-   reg_offset = hp_aramBase;
-
-
-	i = (unsigned char) (RD_HARPOON(p_port+hp_page_ctrl) & ~(SGRAM_ARAM|SCATTER_EN));
+	unsigned long count, addr, tmpSGCnt;
+	unsigned int sg_index;
+	unsigned char sg_count, i;
+	unsigned long reg_offset;
 
+	if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
 
-	WR_HARPOON(p_port+hp_page_ctrl, i);
-
-   while ((sg_count < (unsigned char)SG_BUF_CNT) &&
-      ((unsigned long)(sg_index * (unsigned int)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
+		count = ((unsigned long)HOST_RD_CMD) << 24;
+	}
 
-      tmpSGCnt += *(((unsigned long *)pcurrSCCB->DataPointer)+
-         (sg_index * 2));
+	else {
+		count = ((unsigned long)HOST_WRT_CMD) << 24;
+	}
 
-      count |= *(((unsigned long *)pcurrSCCB->DataPointer)+
-         (sg_index * 2));
+	sg_count = 0;
+	tmpSGCnt = 0;
+	sg_index = pcurrSCCB->Sccb_sgseg;
+	reg_offset = hp_aramBase;
 
-      addr = *(((unsigned long *)pcurrSCCB->DataPointer)+
-         ((sg_index * 2) + 1));
+	i = (unsigned char)(RD_HARPOON(p_port + hp_page_ctrl) &
+			    ~(SGRAM_ARAM | SCATTER_EN));
 
+	WR_HARPOON(p_port + hp_page_ctrl, i);
 
-      if ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {
+	while ((sg_count < (unsigned char)SG_BUF_CNT) &&
+	       ((unsigned long)(sg_index * (unsigned int)SG_ELEMENT_SIZE) <
+		pcurrSCCB->DataLength)) {
 
-         addr += ((count & 0x00FFFFFFL) - pcurrSCCB->Sccb_SGoffset);
-         count = (count & 0xFF000000L) | pcurrSCCB->Sccb_SGoffset;
+		tmpSGCnt += *(((unsigned long *)pcurrSCCB->DataPointer) +
+			      (sg_index * 2));
 
-         tmpSGCnt = count & 0x00FFFFFFL;
-         }
+		count |= *(((unsigned long *)pcurrSCCB->DataPointer) +
+			   (sg_index * 2));
 
-      WR_HARP32(p_port,reg_offset,addr);
-      reg_offset +=4;
+		addr = *(((unsigned long *)pcurrSCCB->DataPointer) +
+			 ((sg_index * 2) + 1));
 
-      WR_HARP32(p_port,reg_offset,count);
-      reg_offset +=4;
+		if ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {
 
-      count &= 0xFF000000L;
-      sg_index++;
-      sg_count++;
+			addr +=
+			    ((count & 0x00FFFFFFL) - pcurrSCCB->Sccb_SGoffset);
+			count =
+			    (count & 0xFF000000L) | pcurrSCCB->Sccb_SGoffset;
 
-      } /*End While */
+			tmpSGCnt = count & 0x00FFFFFFL;
+		}
 
-   pcurrSCCB->Sccb_XferCnt = tmpSGCnt;
+		WR_HARP32(p_port, reg_offset, addr);
+		reg_offset += 4;
 
-   WR_HARPOON(p_port+hp_sg_addr,(sg_count<<4));
+		WR_HARP32(p_port, reg_offset, count);
+		reg_offset += 4;
 
-   if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+		count &= 0xFF000000L;
+		sg_index++;
+		sg_count++;
 
-      WR_HARP32(p_port,hp_xfercnt_0,tmpSGCnt);
+	}			/*End While */
 
+	pcurrSCCB->Sccb_XferCnt = tmpSGCnt;
 
-      WR_HARPOON(p_port+hp_portctrl_0,(DMA_PORT | SCSI_PORT | SCSI_INBIT));
-      WR_HARPOON(p_port+hp_scsisig, S_DATAI_PH);
-      }
+	WR_HARPOON(p_port + hp_sg_addr, (sg_count << 4));
 
-   else {
+	if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
 
+		WR_HARP32(p_port, hp_xfercnt_0, tmpSGCnt);
 
-      if ((!(RD_HARPOON(p_port+hp_synctarg_0) & NARROW_SCSI)) &&
-         (tmpSGCnt & 0x000000001))
-         {
+		WR_HARPOON(p_port + hp_portctrl_0,
+			   (DMA_PORT | SCSI_PORT | SCSI_INBIT));
+		WR_HARPOON(p_port + hp_scsisig, S_DATAI_PH);
+	}
 
-         pcurrSCCB->Sccb_XferState |= F_ODD_BALL_CNT;
-         tmpSGCnt--;
-         }
+	else {
 
+		if ((!(RD_HARPOON(p_port + hp_synctarg_0) & NARROW_SCSI)) &&
+		    (tmpSGCnt & 0x000000001)) {
 
-      WR_HARP32(p_port,hp_xfercnt_0,tmpSGCnt);
+			pcurrSCCB->Sccb_XferState |= F_ODD_BALL_CNT;
+			tmpSGCnt--;
+		}
 
-      WR_HARPOON(p_port+hp_portctrl_0,(SCSI_PORT | DMA_PORT | DMA_RD));
-      WR_HARPOON(p_port+hp_scsisig, S_DATAO_PH);
-      }
+		WR_HARP32(p_port, hp_xfercnt_0, tmpSGCnt);
 
+		WR_HARPOON(p_port + hp_portctrl_0,
+			   (SCSI_PORT | DMA_PORT | DMA_RD));
+		WR_HARPOON(p_port + hp_scsisig, S_DATAO_PH);
+	}
 
-   WR_HARPOON(p_port+hp_page_ctrl, (unsigned char) (i | SCATTER_EN));
+	WR_HARPOON(p_port + hp_page_ctrl, (unsigned char)(i | SCATTER_EN));
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: BusMaster Data Transfer Start
@@ -5293,47 +5076,49 @@ static void FPT_busMstrSGDataXferStart(unsigned long p_port, struct sccb * pcurr
  * Description: 
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrDataXferStart(unsigned long p_port, struct sccb * pcurrSCCB)
+static void FPT_busMstrDataXferStart(unsigned long p_port,
+				     struct sccb *pcurrSCCB)
 {
-   unsigned long addr,count;
+	unsigned long addr, count;
 
-   if (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {
+	if (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {
 
-      count = pcurrSCCB->Sccb_XferCnt;
-
-      addr = (unsigned long) pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
-      }
+		count = pcurrSCCB->Sccb_XferCnt;
 
-   else {
-      addr = pcurrSCCB->SensePointer;
-      count = pcurrSCCB->RequestSenseLength;
+		addr =
+		    (unsigned long)pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
+	}
 
-      }
+	else {
+		addr = pcurrSCCB->SensePointer;
+		count = pcurrSCCB->RequestSenseLength;
 
-   HP_SETUP_ADDR_CNT(p_port,addr,count);
+	}
 
+	HP_SETUP_ADDR_CNT(p_port, addr, count);
 
-   if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+	if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
 
-      WR_HARPOON(p_port+hp_portctrl_0,(DMA_PORT | SCSI_PORT | SCSI_INBIT));
-      WR_HARPOON(p_port+hp_scsisig, S_DATAI_PH);
+		WR_HARPOON(p_port + hp_portctrl_0,
+			   (DMA_PORT | SCSI_PORT | SCSI_INBIT));
+		WR_HARPOON(p_port + hp_scsisig, S_DATAI_PH);
 
-      WR_HARPOON(p_port+hp_xfer_cmd,
-         (XFER_DMA_HOST | XFER_HOST_AUTO | XFER_DMA_8BIT));
-      }
+		WR_HARPOON(p_port + hp_xfer_cmd,
+			   (XFER_DMA_HOST | XFER_HOST_AUTO | XFER_DMA_8BIT));
+	}
 
-   else {
+	else {
 
-      WR_HARPOON(p_port+hp_portctrl_0,(SCSI_PORT | DMA_PORT | DMA_RD));
-      WR_HARPOON(p_port+hp_scsisig, S_DATAO_PH);
+		WR_HARPOON(p_port + hp_portctrl_0,
+			   (SCSI_PORT | DMA_PORT | DMA_RD));
+		WR_HARPOON(p_port + hp_scsisig, S_DATAO_PH);
 
-      WR_HARPOON(p_port+hp_xfer_cmd,
-         (XFER_HOST_DMA | XFER_HOST_AUTO | XFER_DMA_8BIT));
+		WR_HARPOON(p_port + hp_xfer_cmd,
+			   (XFER_HOST_DMA | XFER_HOST_AUTO | XFER_DMA_8BIT));
 
-      }
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: BusMaster Timeout Handler
@@ -5348,35 +5133,36 @@ static void FPT_busMstrDataXferStart(unsigned long p_port, struct sccb * pcurrSC
  *---------------------------------------------------------------------*/
 static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
 {
-   unsigned long timeout;
+	unsigned long timeout;
 
-   timeout = LONG_WAIT;
+	timeout = LONG_WAIT;
 
-   WR_HARPOON(p_port+hp_sys_ctrl, HALT_MACH);
+	WR_HARPOON(p_port + hp_sys_ctrl, HALT_MACH);
 
-   while ((!(RD_HARPOON(p_port+hp_ext_status) & CMD_ABORTED)) && timeout--) {}
+	while ((!(RD_HARPOON(p_port + hp_ext_status) & CMD_ABORTED))
+	       && timeout--) {
+	}
 
-   
-   
-   if (RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) {
-      WR_HARPOON(p_port+hp_sys_ctrl, HARD_ABORT);
+	if (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {
+		WR_HARPOON(p_port + hp_sys_ctrl, HARD_ABORT);
 
-      timeout = LONG_WAIT;
-      while ((RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) && timeout--) {}
-      }
+		timeout = LONG_WAIT;
+		while ((RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY)
+		       && timeout--) {
+		}
+	}
 
-   RD_HARPOON(p_port+hp_int_status);           /*Clear command complete */
+	RD_HARPOON(p_port + hp_int_status);	/*Clear command complete */
 
-   if (RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) {
-      return(1);
-      }
+	if (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {
+		return (1);
+	}
 
-   else {
-      return(0);
-      }
+	else {
+		return (0);
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Host Data Transfer Abort
@@ -5384,256 +5170,282 @@ static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
  * Description: Abort any in progress transfer.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB)
+static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card,
+				  struct sccb *pCurrSCCB)
 {
 
-   unsigned long timeout;
-   unsigned long remain_cnt;
-   unsigned int sg_ptr;
-
-   FPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
-
-   if (pCurrSCCB->Sccb_XferState & F_AUTO_SENSE) {
-
+	unsigned long timeout;
+	unsigned long remain_cnt;
+	unsigned int sg_ptr;
 
-      if (!(RD_HARPOON(port+hp_int_status) & INT_CMD_COMPL)) {
+	FPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
 
-         WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) | FLUSH_XFER_CNTR));
-         timeout = LONG_WAIT;
+	if (pCurrSCCB->Sccb_XferState & F_AUTO_SENSE) {
 
-         while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) && timeout--) {}
+		if (!(RD_HARPOON(port + hp_int_status) & INT_CMD_COMPL)) {
 
-         WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) & ~FLUSH_XFER_CNTR));
+			WR_HARPOON(port + hp_bm_ctrl,
+				   (RD_HARPOON(port + hp_bm_ctrl) |
+				    FLUSH_XFER_CNTR));
+			timeout = LONG_WAIT;
 
-         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
-
-            if (FPT_busMstrTimeOut(port)) {
-
-               if (pCurrSCCB->HostStatus == 0x00)
-
-                  pCurrSCCB->HostStatus = SCCB_BM_ERR;
-
-               }
-
-            if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) 
-
-               if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) 
-
-                  if (pCurrSCCB->HostStatus == 0x00)
-
-                     {
-                     pCurrSCCB->HostStatus = SCCB_BM_ERR;
-                     }
-            }
-         }
-      }
-
-   else if (pCurrSCCB->Sccb_XferCnt) {
-
-      if (pCurrSCCB->Sccb_XferState & F_SG_XFER) {
-
-
-              WR_HARPOON(port+hp_page_ctrl, (RD_HARPOON(port+hp_page_ctrl) &
-            ~SCATTER_EN));
+			while ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)
+			       && timeout--) {
+			}
 
-         WR_HARPOON(port+hp_sg_addr,0x00);
+			WR_HARPOON(port + hp_bm_ctrl,
+				   (RD_HARPOON(port + hp_bm_ctrl) &
+				    ~FLUSH_XFER_CNTR));
 
-         sg_ptr = pCurrSCCB->Sccb_sgseg + SG_BUF_CNT;
+			if (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {
 
-         if (sg_ptr > (unsigned int)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE)) {
+				if (FPT_busMstrTimeOut(port)) {
 
-            sg_ptr = (unsigned int)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
-            }
+					if (pCurrSCCB->HostStatus == 0x00)
 
-         remain_cnt = pCurrSCCB->Sccb_XferCnt;
+						pCurrSCCB->HostStatus =
+						    SCCB_BM_ERR;
 
-         while (remain_cnt < 0x01000000L) {
+				}
 
-            sg_ptr--;
+				if (RD_HARPOON(port + hp_int_status) &
+				    INT_EXT_STATUS)
 
-            if (remain_cnt > (unsigned long)(*(((unsigned long *)pCurrSCCB->
-               DataPointer) + (sg_ptr * 2)))) {
+					if (RD_HARPOON(port + hp_ext_status) &
+					    BAD_EXT_STATUS)
 
-               remain_cnt -= (unsigned long)(*(((unsigned long *)pCurrSCCB->
-                  DataPointer) + (sg_ptr * 2)));
-               }
+						if (pCurrSCCB->HostStatus ==
+						    0x00)
+						{
+							pCurrSCCB->HostStatus =
+							    SCCB_BM_ERR;
+						}
+			}
+		}
+	}
 
-            else {
+	else if (pCurrSCCB->Sccb_XferCnt) {
 
-               break;
-               }
-            }
+		if (pCurrSCCB->Sccb_XferState & F_SG_XFER) {
 
+			WR_HARPOON(port + hp_page_ctrl,
+				   (RD_HARPOON(port + hp_page_ctrl) &
+				    ~SCATTER_EN));
 
+			WR_HARPOON(port + hp_sg_addr, 0x00);
 
-         if (remain_cnt < 0x01000000L) {
+			sg_ptr = pCurrSCCB->Sccb_sgseg + SG_BUF_CNT;
 
+			if (sg_ptr >
+			    (unsigned int)(pCurrSCCB->DataLength /
+					   SG_ELEMENT_SIZE)) {
 
-            pCurrSCCB->Sccb_SGoffset = remain_cnt;
+				sg_ptr =
+				    (unsigned int)(pCurrSCCB->DataLength /
+						   SG_ELEMENT_SIZE);
+			}
 
-            pCurrSCCB->Sccb_sgseg = (unsigned short)sg_ptr;
+			remain_cnt = pCurrSCCB->Sccb_XferCnt;
 
+			while (remain_cnt < 0x01000000L) {
 
-            if ((unsigned long)(sg_ptr * SG_ELEMENT_SIZE) == pCurrSCCB->DataLength
-                && (remain_cnt == 0))
+				sg_ptr--;
 
-               pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
-            }
+				if (remain_cnt >
+				    (unsigned
+				     long)(*(((unsigned long *)pCurrSCCB->
+					      DataPointer) + (sg_ptr * 2)))) {
 
-         else {
+					remain_cnt -=
+					    (unsigned
+					     long)(*(((unsigned long *)
+						      pCurrSCCB->DataPointer) +
+						     (sg_ptr * 2)));
+				}
 
+				else {
 
-            if (pCurrSCCB->HostStatus == 0x00) {
+					break;
+				}
+			}
 
-               pCurrSCCB->HostStatus = SCCB_GROSS_FW_ERR;
-               }
-            }
-         }
+			if (remain_cnt < 0x01000000L) {
 
+				pCurrSCCB->Sccb_SGoffset = remain_cnt;
 
-      if (!(pCurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)) {
+				pCurrSCCB->Sccb_sgseg = (unsigned short)sg_ptr;
 
+				if ((unsigned long)(sg_ptr * SG_ELEMENT_SIZE) ==
+				    pCurrSCCB->DataLength && (remain_cnt == 0))
 
-         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+					pCurrSCCB->Sccb_XferState |=
+					    F_ALL_XFERRED;
+			}
 
-            FPT_busMstrTimeOut(port);
-            }
+			else {
 
-         else {
+				if (pCurrSCCB->HostStatus == 0x00) {
 
-            if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) {
+					pCurrSCCB->HostStatus =
+					    SCCB_GROSS_FW_ERR;
+				}
+			}
+		}
 
-               if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) {
+		if (!(pCurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)) {
 
-                  if (pCurrSCCB->HostStatus == 0x00) {
+			if (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {
 
-                     pCurrSCCB->HostStatus = SCCB_BM_ERR;
-                     }
-                  }
-               }
+				FPT_busMstrTimeOut(port);
+			}
 
-            }
-         }
+			else {
 
-      else {
+				if (RD_HARPOON(port + hp_int_status) &
+				    INT_EXT_STATUS) {
 
+					if (RD_HARPOON(port + hp_ext_status) &
+					    BAD_EXT_STATUS) {
 
-         if ((RD_HARPOON(port+hp_fifo_cnt)) >= BM_THRESHOLD) {
+						if (pCurrSCCB->HostStatus ==
+						    0x00) {
 
-            timeout = SHORT_WAIT;
+							pCurrSCCB->HostStatus =
+							    SCCB_BM_ERR;
+						}
+					}
+				}
 
-            while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) &&
-               ((RD_HARPOON(port+hp_fifo_cnt)) >= BM_THRESHOLD) &&
-               timeout--) {}
-            }
+			}
+		}
 
-         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+		else {
 
-            WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) |
-               FLUSH_XFER_CNTR));
+			if ((RD_HARPOON(port + hp_fifo_cnt)) >= BM_THRESHOLD) {
 
-            timeout = LONG_WAIT;
+				timeout = SHORT_WAIT;
 
-            while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) &&
-               timeout--) {}
+				while ((RD_HARPOON(port + hp_ext_status) &
+					BM_CMD_BUSY)
+				       && ((RD_HARPOON(port + hp_fifo_cnt)) >=
+					   BM_THRESHOLD) && timeout--) {
+				}
+			}
 
-            WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) &
-               ~FLUSH_XFER_CNTR));
+			if (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {
 
+				WR_HARPOON(port + hp_bm_ctrl,
+					   (RD_HARPOON(port + hp_bm_ctrl) |
+					    FLUSH_XFER_CNTR));
 
-            if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+				timeout = LONG_WAIT;
 
-               if (pCurrSCCB->HostStatus == 0x00) {
+				while ((RD_HARPOON(port + hp_ext_status) &
+					BM_CMD_BUSY) && timeout--) {
+				}
 
-                  pCurrSCCB->HostStatus = SCCB_BM_ERR;
-                  }
+				WR_HARPOON(port + hp_bm_ctrl,
+					   (RD_HARPOON(port + hp_bm_ctrl) &
+					    ~FLUSH_XFER_CNTR));
 
-               FPT_busMstrTimeOut(port);
-               }
-            }
+				if (RD_HARPOON(port + hp_ext_status) &
+				    BM_CMD_BUSY) {
 
-         if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) {
+					if (pCurrSCCB->HostStatus == 0x00) {
 
-            if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) {
+						pCurrSCCB->HostStatus =
+						    SCCB_BM_ERR;
+					}
 
-               if (pCurrSCCB->HostStatus == 0x00) {
+					FPT_busMstrTimeOut(port);
+				}
+			}
 
-                  pCurrSCCB->HostStatus = SCCB_BM_ERR;
-                  }
-               }
-            }
-         }
+			if (RD_HARPOON(port + hp_int_status) & INT_EXT_STATUS) {
 
-      }
+				if (RD_HARPOON(port + hp_ext_status) &
+				    BAD_EXT_STATUS) {
 
-   else {
+					if (pCurrSCCB->HostStatus == 0x00) {
 
+						pCurrSCCB->HostStatus =
+						    SCCB_BM_ERR;
+					}
+				}
+			}
+		}
 
-      if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+	}
 
-         timeout = LONG_WAIT;
+	else {
 
-         while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) && timeout--) {}
+		if (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {
 
-         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+			timeout = LONG_WAIT;
 
-            if (pCurrSCCB->HostStatus == 0x00) {
+			while ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)
+			       && timeout--) {
+			}
 
-               pCurrSCCB->HostStatus = SCCB_BM_ERR;
-               }
+			if (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {
 
-            FPT_busMstrTimeOut(port);
-            }
-         }
+				if (pCurrSCCB->HostStatus == 0x00) {
 
+					pCurrSCCB->HostStatus = SCCB_BM_ERR;
+				}
 
-      if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) {
+				FPT_busMstrTimeOut(port);
+			}
+		}
 
-         if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) {
+		if (RD_HARPOON(port + hp_int_status) & INT_EXT_STATUS) {
 
-            if (pCurrSCCB->HostStatus == 0x00) {
+			if (RD_HARPOON(port + hp_ext_status) & BAD_EXT_STATUS) {
 
-               pCurrSCCB->HostStatus = SCCB_BM_ERR;
-               }
-            }
+				if (pCurrSCCB->HostStatus == 0x00) {
 
-         }
+					pCurrSCCB->HostStatus = SCCB_BM_ERR;
+				}
+			}
 
-      if (pCurrSCCB->Sccb_XferState & F_SG_XFER) {
+		}
 
-         WR_HARPOON(port+hp_page_ctrl, (RD_HARPOON(port+hp_page_ctrl) &
-                 ~SCATTER_EN));
+		if (pCurrSCCB->Sccb_XferState & F_SG_XFER) {
 
-         WR_HARPOON(port+hp_sg_addr,0x00);
+			WR_HARPOON(port + hp_page_ctrl,
+				   (RD_HARPOON(port + hp_page_ctrl) &
+				    ~SCATTER_EN));
 
-         pCurrSCCB->Sccb_sgseg += SG_BUF_CNT;
+			WR_HARPOON(port + hp_sg_addr, 0x00);
 
-         pCurrSCCB->Sccb_SGoffset = 0x00; 
+			pCurrSCCB->Sccb_sgseg += SG_BUF_CNT;
 
+			pCurrSCCB->Sccb_SGoffset = 0x00;
 
-         if ((unsigned long)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=
-            pCurrSCCB->DataLength) {
+			if ((unsigned long)(pCurrSCCB->Sccb_sgseg *
+					    SG_ELEMENT_SIZE) >=
+			    pCurrSCCB->DataLength) {
 
-            pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
+				pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
 
-            pCurrSCCB->Sccb_sgseg = (unsigned short)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
+				pCurrSCCB->Sccb_sgseg =
+				    (unsigned short)(pCurrSCCB->DataLength /
+						     SG_ELEMENT_SIZE);
 
-            }
-         }
+			}
+		}
 
-      else {
+		else {
 
-         if (!(pCurrSCCB->Sccb_XferState & F_AUTO_SENSE))
+			if (!(pCurrSCCB->Sccb_XferState & F_AUTO_SENSE))
 
-            pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
-         }
-      }
+				pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
+		}
+	}
 
-   WR_HARPOON(port+hp_int_mask,(INT_CMD_COMPL | SCSI_INTERRUPT));
+	WR_HARPOON(port + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: Host Data Transfer Restart
@@ -5642,47 +5454,47 @@ static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, stru
  *              pointers message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferRestart(struct sccb * currSCCB)
+static void FPT_hostDataXferRestart(struct sccb *currSCCB)
 {
-   unsigned long data_count;
-   unsigned int  sg_index;
-   unsigned long *sg_ptr;
+	unsigned long data_count;
+	unsigned int sg_index;
+	unsigned long *sg_ptr;
 
-   if (currSCCB->Sccb_XferState & F_SG_XFER) {
+	if (currSCCB->Sccb_XferState & F_SG_XFER) {
 
-      currSCCB->Sccb_XferCnt = 0;
+		currSCCB->Sccb_XferCnt = 0;
 
-      sg_index = 0xffff;         /*Index by long words into sg list. */
-      data_count = 0;            /*Running count of SG xfer counts. */
+		sg_index = 0xffff;	/*Index by long words into sg list. */
+		data_count = 0;	/*Running count of SG xfer counts. */
 
-      sg_ptr = (unsigned long *)currSCCB->DataPointer;
+		sg_ptr = (unsigned long *)currSCCB->DataPointer;
 
-      while (data_count < currSCCB->Sccb_ATC) {
+		while (data_count < currSCCB->Sccb_ATC) {
 
-         sg_index++;
-         data_count += *(sg_ptr+(sg_index * 2));
-         }
+			sg_index++;
+			data_count += *(sg_ptr + (sg_index * 2));
+		}
 
-      if (data_count == currSCCB->Sccb_ATC) {
+		if (data_count == currSCCB->Sccb_ATC) {
 
-         currSCCB->Sccb_SGoffset = 0;
-         sg_index++;
-         }
+			currSCCB->Sccb_SGoffset = 0;
+			sg_index++;
+		}
 
-      else {
-         currSCCB->Sccb_SGoffset = data_count - currSCCB->Sccb_ATC;
-         }
+		else {
+			currSCCB->Sccb_SGoffset =
+			    data_count - currSCCB->Sccb_ATC;
+		}
 
-      currSCCB->Sccb_sgseg = (unsigned short)sg_index;
-      }
+		currSCCB->Sccb_sgseg = (unsigned short)sg_index;
+	}
 
-   else {
-      currSCCB->Sccb_XferCnt = currSCCB->DataLength - currSCCB->Sccb_ATC;
-      }
+	else {
+		currSCCB->Sccb_XferCnt =
+		    currSCCB->DataLength - currSCCB->Sccb_ATC;
+	}
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scini
@@ -5691,177 +5503,192 @@ static void FPT_hostDataXferRestart(struct sccb * currSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned char p_power_up)
+static void FPT_scini(unsigned char p_card, unsigned char p_our_id,
+		      unsigned char p_power_up)
 {
 
-   unsigned char loser,assigned_id;
-   unsigned long p_port;
+	unsigned char loser, assigned_id;
+	unsigned long p_port;
 
-   unsigned char i,k,ScamFlg ;
-   struct sccb_card * currCard;
-	struct nvram_info * pCurrNvRam;
+	unsigned char i, k, ScamFlg;
+	struct sccb_card *currCard;
+	struct nvram_info *pCurrNvRam;
 
-   currCard = &FPT_BL_Card[p_card];
-   p_port = currCard->ioPort;
+	currCard = &FPT_BL_Card[p_card];
+	p_port = currCard->ioPort;
 	pCurrNvRam = currCard->pNvRamInfo;
 
-
-	if(pCurrNvRam){
+	if (pCurrNvRam) {
 		ScamFlg = pCurrNvRam->niScamConf;
 		i = pCurrNvRam->niSysConf;
+	} else {
+		ScamFlg =
+		    (unsigned char)FPT_utilEERead(p_port, SCAM_CONFIG / 2);
+		i = (unsigned
+		     char)(FPT_utilEERead(p_port, (SYSTEM_CONFIG / 2)));
 	}
-	else{
-	   ScamFlg = (unsigned char) FPT_utilEERead(p_port, SCAM_CONFIG/2);
-	   i = (unsigned char)(FPT_utilEERead(p_port, (SYSTEM_CONFIG/2)));
-	}
-	if(!(i & 0x02))	/* check if reset bus in AutoSCSI parameter set */
+	if (!(i & 0x02))	/* check if reset bus in AutoSCSI parameter set */
 		return;
 
-   FPT_inisci(p_card,p_port, p_our_id);
+	FPT_inisci(p_card, p_port, p_our_id);
 
-   /* Force to wait 1 sec after SCSI bus reset. Some SCAM device FW
-      too slow to return to SCAM selection */
+	/* Force to wait 1 sec after SCSI bus reset. Some SCAM device FW
+	   too slow to return to SCAM selection */
 
-   /* if (p_power_up)
-         FPT_Wait1Second(p_port);
-      else
-         FPT_Wait(p_port, TO_250ms); */
-
-   FPT_Wait1Second(p_port);
+	/* if (p_power_up)
+	   FPT_Wait1Second(p_port);
+	   else
+	   FPT_Wait(p_port, TO_250ms); */
 
-   if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
-      {
-      while (!(FPT_scarb(p_port,INIT_SELTD))) {}
+	FPT_Wait1Second(p_port);
 
-      FPT_scsel(p_port);
+	if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2)) {
+		while (!(FPT_scarb(p_port, INIT_SELTD))) {
+		}
 
-      do {
-         FPT_scxferc(p_port,SYNC_PTRN);
-         FPT_scxferc(p_port,DOM_MSTR);
-         loser = FPT_scsendi(p_port,&FPT_scamInfo[p_our_id].id_string[0]);
-         } while ( loser == 0xFF );
+		FPT_scsel(p_port);
 
-      FPT_scbusf(p_port);
+		do {
+			FPT_scxferc(p_port, SYNC_PTRN);
+			FPT_scxferc(p_port, DOM_MSTR);
+			loser =
+			    FPT_scsendi(p_port,
+					&FPT_scamInfo[p_our_id].id_string[0]);
+		} while (loser == 0xFF);
 
-      if ((p_power_up) && (!loser))
-         {
-         FPT_sresb(p_port,p_card);
-         FPT_Wait(p_port, TO_250ms);
+		FPT_scbusf(p_port);
 
-         while (!(FPT_scarb(p_port,INIT_SELTD))) {}
+		if ((p_power_up) && (!loser)) {
+			FPT_sresb(p_port, p_card);
+			FPT_Wait(p_port, TO_250ms);
 
-         FPT_scsel(p_port);
+			while (!(FPT_scarb(p_port, INIT_SELTD))) {
+			}
 
-         do {
-            FPT_scxferc(p_port, SYNC_PTRN);
-            FPT_scxferc(p_port, DOM_MSTR);
-            loser = FPT_scsendi(p_port,&FPT_scamInfo[p_our_id].
-               id_string[0]);
-            } while ( loser == 0xFF );
+			FPT_scsel(p_port);
 
-         FPT_scbusf(p_port);
-         }
-      }
+			do {
+				FPT_scxferc(p_port, SYNC_PTRN);
+				FPT_scxferc(p_port, DOM_MSTR);
+				loser =
+				    FPT_scsendi(p_port,
+						&FPT_scamInfo[p_our_id].
+						id_string[0]);
+			} while (loser == 0xFF);
 
-   else
-      {
-      loser = 0;
-      }
+			FPT_scbusf(p_port);
+		}
+	}
 
+	else {
+		loser = 0;
+	}
 
-   if (!loser)
-      {
+	if (!loser) {
+
+		FPT_scamInfo[p_our_id].state = ID_ASSIGNED;
+
+		if (ScamFlg & SCAM_ENABLED) {
+
+			for (i = 0; i < MAX_SCSI_TAR; i++) {
+				if ((FPT_scamInfo[i].state == ID_UNASSIGNED) ||
+				    (FPT_scamInfo[i].state == ID_UNUSED)) {
+					if (FPT_scsell(p_port, i)) {
+						FPT_scamInfo[i].state = LEGACY;
+						if ((FPT_scamInfo[i].
+						     id_string[0] != 0xFF)
+						    || (FPT_scamInfo[i].
+							id_string[1] != 0xFA)) {
+
+							FPT_scamInfo[i].
+							    id_string[0] = 0xFF;
+							FPT_scamInfo[i].
+							    id_string[1] = 0xFA;
+							if (pCurrNvRam == NULL)
+								currCard->
+								    globalFlags
+								    |=
+								    F_UPDATE_EEPROM;
+						}
+					}
+				}
+			}
 
-      FPT_scamInfo[p_our_id].state = ID_ASSIGNED;
+			FPT_sresb(p_port, p_card);
+			FPT_Wait1Second(p_port);
+			while (!(FPT_scarb(p_port, INIT_SELTD))) {
+			}
+			FPT_scsel(p_port);
+			FPT_scasid(p_card, p_port);
+		}
 
+	}
 
-		if (ScamFlg & SCAM_ENABLED)
-		{
+	else if ((loser) && (ScamFlg & SCAM_ENABLED)) {
+		FPT_scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;
+		assigned_id = 0;
+		FPT_scwtsel(p_port);
 
-	      for (i=0; i < MAX_SCSI_TAR; i++)
-  		   {
-      	   if ((FPT_scamInfo[i].state == ID_UNASSIGNED) ||
-  	      	   (FPT_scamInfo[i].state == ID_UNUSED))
-	  	      {
-   	     	   if (FPT_scsell(p_port,i))
-      	  	   {
-            	   FPT_scamInfo[i].state = LEGACY;
-  	            	if ((FPT_scamInfo[i].id_string[0] != 0xFF) ||
-     	            	(FPT_scamInfo[i].id_string[1] != 0xFA))
-	     	         {
-
-   	        	      FPT_scamInfo[i].id_string[0] = 0xFF;
-      	        	   FPT_scamInfo[i].id_string[1] = 0xFA;
-							if(pCurrNvRam == NULL)
-	         	         currCard->globalFlags |= F_UPDATE_EEPROM;
-               	}
-	  	         }
-   	  	   }
-      	}
-
-	      FPT_sresb(p_port,p_card);
-      	FPT_Wait1Second(p_port);
-         while (!(FPT_scarb(p_port,INIT_SELTD))) {}
-         FPT_scsel(p_port);
-         FPT_scasid(p_card, p_port);
-         }
+		do {
+			while (FPT_scxferc(p_port, 0x00) != SYNC_PTRN) {
+			}
 
-      }
+			i = FPT_scxferc(p_port, 0x00);
+			if (i == ASSIGN_ID) {
+				if (!
+				    (FPT_scsendi
+				     (p_port,
+				      &FPT_scamInfo[p_our_id].id_string[0]))) {
+					i = FPT_scxferc(p_port, 0x00);
+					if (FPT_scvalq(i)) {
+						k = FPT_scxferc(p_port, 0x00);
+
+						if (FPT_scvalq(k)) {
+							currCard->ourId =
+							    ((unsigned char)(i
+									     <<
+									     3)
+							     +
+							     (k &
+							      (unsigned char)7))
+							    & (unsigned char)
+							    0x3F;
+							FPT_inisci(p_card,
+								   p_port,
+								   p_our_id);
+							FPT_scamInfo[currCard->
+								     ourId].
+							    state = ID_ASSIGNED;
+							FPT_scamInfo[currCard->
+								     ourId].
+							    id_string[0]
+							    = SLV_TYPE_CODE0;
+							assigned_id = 1;
+						}
+					}
+				}
+			}
 
-   else if ((loser) && (ScamFlg & SCAM_ENABLED))
-      {
-      FPT_scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;
-      assigned_id = 0;
-      FPT_scwtsel(p_port);
-
-      do {
-         while (FPT_scxferc(p_port,0x00) != SYNC_PTRN) {}
-
-         i = FPT_scxferc(p_port,0x00);
-         if (i == ASSIGN_ID)
-            {
-            if (!(FPT_scsendi(p_port,&FPT_scamInfo[p_our_id].id_string[0])))
-                  {
-                  i = FPT_scxferc(p_port,0x00);
-                  if (FPT_scvalq(i))
-                     {
-                     k = FPT_scxferc(p_port,0x00);
-
-                     if (FPT_scvalq(k))
-                        {
-                        currCard->ourId =
-                           ((unsigned char)(i<<3)+(k & (unsigned char)7)) & (unsigned char) 0x3F;
-                        FPT_inisci(p_card, p_port, p_our_id);
-                        FPT_scamInfo[currCard->ourId].state = ID_ASSIGNED;
-                        FPT_scamInfo[currCard->ourId].id_string[0]
-                           = SLV_TYPE_CODE0;
-                        assigned_id = 1;
-                        }
-                     }
-                  }
-            }
-
-         else if (i == SET_P_FLAG)
-            {
-               if (!(FPT_scsendi(p_port,
-                        &FPT_scamInfo[p_our_id].id_string[0])))
-                        FPT_scamInfo[p_our_id].id_string[0] |= 0x80;
-            }
-         }while (!assigned_id);
-
-      while (FPT_scxferc(p_port,0x00) != CFG_CMPLT) {}
-      }
+			else if (i == SET_P_FLAG) {
+				if (!(FPT_scsendi(p_port,
+						  &FPT_scamInfo[p_our_id].
+						  id_string[0])))
+					FPT_scamInfo[p_our_id].id_string[0] |=
+					    0x80;
+			}
+		} while (!assigned_id);
 
-   if (ScamFlg & SCAM_ENABLED)
-      {
-      FPT_scbusf(p_port);
-      if (currCard->globalFlags & F_UPDATE_EEPROM)
-         {
-         FPT_scsavdi(p_card, p_port);
-         currCard->globalFlags &= ~F_UPDATE_EEPROM;
-         }
-      }
+		while (FPT_scxferc(p_port, 0x00) != CFG_CMPLT) {
+		}
+	}
 
+	if (ScamFlg & SCAM_ENABLED) {
+		FPT_scbusf(p_port);
+		if (currCard->globalFlags & F_UPDATE_EEPROM) {
+			FPT_scsavdi(p_card, p_port);
+			currCard->globalFlags &= ~F_UPDATE_EEPROM;
+		}
+	}
 
 /*
    for (i=0,k=0; i < MAX_SCSI_TAR; i++)
@@ -5878,7 +5705,6 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned cha
 */
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scarb
@@ -5889,57 +5715,58 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned cha
 
 static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 {
-   if (p_sel_type == INIT_SELTD)
-      {
+	if (p_sel_type == INIT_SELTD) {
 
-      while (RD_HARPOON(p_port+hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {}
-
-
-      if (RD_HARPOON(p_port+hp_scsisig) & SCSI_SEL)
-         return(0);
-
-      if (RD_HARPOON(p_port+hp_scsidata_0) != 00)
-         return(0);
+		while (RD_HARPOON(p_port + hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {
+		}
 
-      WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_BSY));
+		if (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL)
+			return (0);
 
-      if (RD_HARPOON(p_port+hp_scsisig) & SCSI_SEL) {
+		if (RD_HARPOON(p_port + hp_scsidata_0) != 00)
+			return (0);
 
-         WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) &
-            ~SCSI_BSY));
-         return(0);
-         }
+		WR_HARPOON(p_port + hp_scsisig,
+			   (RD_HARPOON(p_port + hp_scsisig) | SCSI_BSY));
 
+		if (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL) {
 
-      WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_SEL));
+			WR_HARPOON(p_port + hp_scsisig,
+				   (RD_HARPOON(p_port + hp_scsisig) &
+				    ~SCSI_BSY));
+			return (0);
+		}
 
-      if (RD_HARPOON(p_port+hp_scsidata_0) != 00) {
+		WR_HARPOON(p_port + hp_scsisig,
+			   (RD_HARPOON(p_port + hp_scsisig) | SCSI_SEL));
 
-         WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) &
-            ~(SCSI_BSY | SCSI_SEL)));
-         return(0);
-         }
-      }
+		if (RD_HARPOON(p_port + hp_scsidata_0) != 00) {
 
+			WR_HARPOON(p_port + hp_scsisig,
+				   (RD_HARPOON(p_port + hp_scsisig) &
+				    ~(SCSI_BSY | SCSI_SEL)));
+			return (0);
+		}
+	}
 
-   WR_HARPOON(p_port+hp_clkctrl_0, (RD_HARPOON(p_port+hp_clkctrl_0)
-      & ~ACTdeassert));
-   WR_HARPOON(p_port+hp_scsireset, SCAM_EN);
-   WR_HARPOON(p_port+hp_scsidata_0, 0x00);
-   WR_HARPOON(p_port+hp_scsidata_1, 0x00);
-   WR_HARPOON(p_port+hp_portctrl_0, SCSI_BUS_EN);
+	WR_HARPOON(p_port + hp_clkctrl_0, (RD_HARPOON(p_port + hp_clkctrl_0)
+					   & ~ACTdeassert));
+	WR_HARPOON(p_port + hp_scsireset, SCAM_EN);
+	WR_HARPOON(p_port + hp_scsidata_0, 0x00);
+	WR_HARPOON(p_port + hp_scsidata_1, 0x00);
+	WR_HARPOON(p_port + hp_portctrl_0, SCSI_BUS_EN);
 
-   WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_MSG));
+	WR_HARPOON(p_port + hp_scsisig,
+		   (RD_HARPOON(p_port + hp_scsisig) | SCSI_MSG));
 
-   WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig)
-      & ~SCSI_BSY));
+	WR_HARPOON(p_port + hp_scsisig, (RD_HARPOON(p_port + hp_scsisig)
+					 & ~SCSI_BSY));
 
-   FPT_Wait(p_port,TO_250ms);
+	FPT_Wait(p_port, TO_250ms);
 
-   return(1);
+	return (1);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scbusf
@@ -5950,32 +5777,28 @@ static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 
 static void FPT_scbusf(unsigned long p_port)
 {
-   WR_HARPOON(p_port+hp_page_ctrl,
-      (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
-
+	WR_HARPOON(p_port + hp_page_ctrl,
+		   (RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));
 
-   WR_HARPOON(p_port+hp_scsidata_0, 0x00);
+	WR_HARPOON(p_port + hp_scsidata_0, 0x00);
 
-   WR_HARPOON(p_port+hp_portctrl_0, (RD_HARPOON(p_port+hp_portctrl_0)
-      & ~SCSI_BUS_EN));
+	WR_HARPOON(p_port + hp_portctrl_0, (RD_HARPOON(p_port + hp_portctrl_0)
+					    & ~SCSI_BUS_EN));
 
-   WR_HARPOON(p_port+hp_scsisig, 0x00);
+	WR_HARPOON(p_port + hp_scsisig, 0x00);
 
+	WR_HARPOON(p_port + hp_scsireset, (RD_HARPOON(p_port + hp_scsireset)
+					   & ~SCAM_EN));
 
-   WR_HARPOON(p_port+hp_scsireset,  (RD_HARPOON(p_port+hp_scsireset)
-      & ~SCAM_EN));
+	WR_HARPOON(p_port + hp_clkctrl_0, (RD_HARPOON(p_port + hp_clkctrl_0)
+					   | ACTdeassert));
 
-   WR_HARPOON(p_port+hp_clkctrl_0, (RD_HARPOON(p_port+hp_clkctrl_0)
-      | ACTdeassert));
+	WRW_HARPOON((p_port + hp_intstat), (BUS_FREE | AUTO_INT | SCAM_SEL));
 
-   WRW_HARPOON((p_port+hp_intstat), (BUS_FREE | AUTO_INT | SCAM_SEL));
-
-   WR_HARPOON(p_port+hp_page_ctrl,
-      (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+	WR_HARPOON(p_port + hp_page_ctrl,
+		   (RD_HARPOON(p_port + hp_page_ctrl) & ~G_INT_DISABLE));
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scasid
@@ -5986,84 +5809,73 @@ static void FPT_scbusf(unsigned long p_port)
 
 static void FPT_scasid(unsigned char p_card, unsigned long p_port)
 {
-   unsigned char temp_id_string[ID_STRING_LENGTH];
+	unsigned char temp_id_string[ID_STRING_LENGTH];
 
-   unsigned char i,k,scam_id;
+	unsigned char i, k, scam_id;
 	unsigned char crcBytes[3];
-	struct nvram_info * pCurrNvRam;
-	unsigned short * pCrcBytes;
+	struct nvram_info *pCurrNvRam;
+	unsigned short *pCrcBytes;
 
 	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
 
-   i=0;
+	i = 0;
 
-   while (!i)
-      {
+	while (!i) {
 
-      for (k=0; k < ID_STRING_LENGTH; k++)
-         {
-         temp_id_string[k] = (unsigned char) 0x00;
-         }
+		for (k = 0; k < ID_STRING_LENGTH; k++) {
+			temp_id_string[k] = (unsigned char)0x00;
+		}
 
-      FPT_scxferc(p_port,SYNC_PTRN);
-      FPT_scxferc(p_port,ASSIGN_ID);
+		FPT_scxferc(p_port, SYNC_PTRN);
+		FPT_scxferc(p_port, ASSIGN_ID);
 
-      if (!(FPT_sciso(p_port,&temp_id_string[0])))
-         {
-			if(pCurrNvRam){
+		if (!(FPT_sciso(p_port, &temp_id_string[0]))) {
+			if (pCurrNvRam) {
 				pCrcBytes = (unsigned short *)&crcBytes[0];
 				*pCrcBytes = FPT_CalcCrc16(&temp_id_string[0]);
 				crcBytes[2] = FPT_CalcLrc(&temp_id_string[0]);
 				temp_id_string[1] = crcBytes[2];
 				temp_id_string[2] = crcBytes[0];
 				temp_id_string[3] = crcBytes[1];
-				for(k = 4; k < ID_STRING_LENGTH; k++)
-					temp_id_string[k] = (unsigned char) 0x00;
+				for (k = 4; k < ID_STRING_LENGTH; k++)
+					temp_id_string[k] = (unsigned char)0x00;
 			}
-         i = FPT_scmachid(p_card,temp_id_string);
+			i = FPT_scmachid(p_card, temp_id_string);
 
-         if (i == CLR_PRIORITY)
-            {
-            FPT_scxferc(p_port,MISC_CODE);
-            FPT_scxferc(p_port,CLR_P_FLAG);
-            i = 0;  /*Not the last ID yet. */
-            }
-
-         else if (i != NO_ID_AVAIL)
-            {
-            if (i < 8 )
-               FPT_scxferc(p_port,ID_0_7);
-            else
-               FPT_scxferc(p_port,ID_8_F);
+			if (i == CLR_PRIORITY) {
+				FPT_scxferc(p_port, MISC_CODE);
+				FPT_scxferc(p_port, CLR_P_FLAG);
+				i = 0;	/*Not the last ID yet. */
+			}
 
-            scam_id = (i & (unsigned char) 0x07);
+			else if (i != NO_ID_AVAIL) {
+				if (i < 8)
+					FPT_scxferc(p_port, ID_0_7);
+				else
+					FPT_scxferc(p_port, ID_8_F);
 
+				scam_id = (i & (unsigned char)0x07);
 
-            for (k=1; k < 0x08; k <<= 1)
-               if (!( k & i ))
-                  scam_id += 0x08;        /*Count number of zeros in DB0-3. */
+				for (k = 1; k < 0x08; k <<= 1)
+					if (!(k & i))
+						scam_id += 0x08;	/*Count number of zeros in DB0-3. */
 
-            FPT_scxferc(p_port,scam_id);
+				FPT_scxferc(p_port, scam_id);
 
-            i = 0;  /*Not the last ID yet. */
-            }
-         }
+				i = 0;	/*Not the last ID yet. */
+			}
+		}
 
-      else
-         {
-         i = 1;
-         }
+		else {
+			i = 1;
+		}
 
-      }  /*End while */
+	}			/*End while */
 
-   FPT_scxferc(p_port,SYNC_PTRN);
-   FPT_scxferc(p_port,CFG_CMPLT);
+	FPT_scxferc(p_port, SYNC_PTRN);
+	FPT_scxferc(p_port, CFG_CMPLT);
 }
 
-
-
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scsel
@@ -6075,29 +5887,29 @@ static void FPT_scasid(unsigned char p_card, unsigned long p_port)
 static void FPT_scsel(unsigned long p_port)
 {
 
-   WR_HARPOON(p_port+hp_scsisig, SCSI_SEL);
-   FPT_scwiros(p_port, SCSI_MSG);
-
-   WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY));
-
+	WR_HARPOON(p_port + hp_scsisig, SCSI_SEL);
+	FPT_scwiros(p_port, SCSI_MSG);
 
-   WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
-   WR_HARPOON(p_port+hp_scsidata_0, (unsigned char)(RD_HARPOON(p_port+hp_scsidata_0) |
-      (unsigned char)(BIT(7)+BIT(6))));
+	WR_HARPOON(p_port + hp_scsisig, (SCSI_SEL | SCSI_BSY));
 
+	WR_HARPOON(p_port + hp_scsisig,
+		   (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
+	WR_HARPOON(p_port + hp_scsidata_0,
+		   (unsigned char)(RD_HARPOON(p_port + hp_scsidata_0) |
+				   (unsigned char)(BIT(7) + BIT(6))));
 
-   WR_HARPOON(p_port+hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));
-   FPT_scwiros(p_port, SCSI_SEL);
+	WR_HARPOON(p_port + hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));
+	FPT_scwiros(p_port, SCSI_SEL);
 
-   WR_HARPOON(p_port+hp_scsidata_0, (unsigned char)(RD_HARPOON(p_port+hp_scsidata_0) &
-      ~(unsigned char)BIT(6)));
-   FPT_scwirod(p_port, BIT(6));
+	WR_HARPOON(p_port + hp_scsidata_0,
+		   (unsigned char)(RD_HARPOON(p_port + hp_scsidata_0) &
+				   ~(unsigned char)BIT(6)));
+	FPT_scwirod(p_port, BIT(6));
 
-   WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
+	WR_HARPOON(p_port + hp_scsisig,
+		   (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scxferc
@@ -6108,46 +5920,45 @@ static void FPT_scsel(unsigned long p_port)
 
 static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data)
 {
-   unsigned char curr_data, ret_data;
+	unsigned char curr_data, ret_data;
 
-   curr_data = p_data | BIT(7) | BIT(5);   /*Start with DB7 & DB5 asserted. */
+	curr_data = p_data | BIT(7) | BIT(5);	/*Start with DB7 & DB5 asserted. */
 
-   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+	WR_HARPOON(p_port + hp_scsidata_0, curr_data);
 
-   curr_data &= ~BIT(7);
+	curr_data &= ~BIT(7);
 
-   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+	WR_HARPOON(p_port + hp_scsidata_0, curr_data);
 
-   FPT_scwirod(p_port,BIT(7));              /*Wait for DB7 to be released. */
-	while (!(RD_HARPOON(p_port+hp_scsidata_0) & BIT(5)));
+	FPT_scwirod(p_port, BIT(7));	/*Wait for DB7 to be released. */
+	while (!(RD_HARPOON(p_port + hp_scsidata_0) & BIT(5))) ;
 
-   ret_data = (RD_HARPOON(p_port+hp_scsidata_0) & (unsigned char) 0x1F);
+	ret_data = (RD_HARPOON(p_port + hp_scsidata_0) & (unsigned char)0x1F);
 
-   curr_data |= BIT(6);
+	curr_data |= BIT(6);
 
-   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+	WR_HARPOON(p_port + hp_scsidata_0, curr_data);
 
-   curr_data &= ~BIT(5);
+	curr_data &= ~BIT(5);
 
-   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+	WR_HARPOON(p_port + hp_scsidata_0, curr_data);
 
-   FPT_scwirod(p_port,BIT(5));              /*Wait for DB5 to be released. */
+	FPT_scwirod(p_port, BIT(5));	/*Wait for DB5 to be released. */
 
-   curr_data &= ~(BIT(4)|BIT(3)|BIT(2)|BIT(1)|BIT(0)); /*Release data bits */
-   curr_data |= BIT(7);
+	curr_data &= ~(BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0));	/*Release data bits */
+	curr_data |= BIT(7);
 
-   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+	WR_HARPOON(p_port + hp_scsidata_0, curr_data);
 
-   curr_data &= ~BIT(6);
+	curr_data &= ~BIT(6);
 
-   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+	WR_HARPOON(p_port + hp_scsidata_0, curr_data);
 
-   FPT_scwirod(p_port,BIT(6));              /*Wait for DB6 to be released. */
+	FPT_scwirod(p_port, BIT(6));	/*Wait for DB6 to be released. */
 
-   return(ret_data);
+	return (ret_data);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scsendi
@@ -6157,51 +5968,50 @@ static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scsendi(unsigned long p_port, unsigned char p_id_string[])
+static unsigned char FPT_scsendi(unsigned long p_port,
+				 unsigned char p_id_string[])
 {
-   unsigned char ret_data,byte_cnt,bit_cnt,defer;
+	unsigned char ret_data, byte_cnt, bit_cnt, defer;
 
-   defer = 0;
+	defer = 0;
 
-   for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
+	for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
 
-      for (bit_cnt = 0x80; bit_cnt != 0 ; bit_cnt >>= 1) {
+		for (bit_cnt = 0x80; bit_cnt != 0; bit_cnt >>= 1) {
 
-         if (defer)
-            ret_data = FPT_scxferc(p_port,00);
+			if (defer)
+				ret_data = FPT_scxferc(p_port, 00);
 
-         else if (p_id_string[byte_cnt] & bit_cnt)
+			else if (p_id_string[byte_cnt] & bit_cnt)
 
-               ret_data = FPT_scxferc(p_port,02);
+				ret_data = FPT_scxferc(p_port, 02);
 
-            else {
+			else {
 
-               ret_data = FPT_scxferc(p_port,01);
-               if (ret_data & 02)
-                  defer = 1;
-               }
+				ret_data = FPT_scxferc(p_port, 01);
+				if (ret_data & 02)
+					defer = 1;
+			}
 
-         if ((ret_data & 0x1C) == 0x10)
-            return(0x00);  /*End of isolation stage, we won! */
+			if ((ret_data & 0x1C) == 0x10)
+				return (0x00);	/*End of isolation stage, we won! */
 
-         if (ret_data & 0x1C)
-            return(0xFF);
+			if (ret_data & 0x1C)
+				return (0xFF);
 
-         if ((defer) && (!(ret_data & 0x1F)))
-            return(0x01);  /*End of isolation stage, we lost. */
+			if ((defer) && (!(ret_data & 0x1F)))
+				return (0x01);	/*End of isolation stage, we lost. */
 
-         } /*bit loop */
+		}		/*bit loop */
 
-      } /*byte loop */
+	}			/*byte loop */
 
-   if (defer)
-      return(0x01);  /*We lost */
-   else
-      return(0);  /*We WON! Yeeessss! */
+	if (defer)
+		return (0x01);	/*We lost */
+	else
+		return (0);	/*We WON! Yeeessss! */
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_sciso
@@ -6210,31 +6020,31 @@ static unsigned char FPT_scsendi(unsigned long p_port, unsigned char p_id_string
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sciso(unsigned long p_port, unsigned char p_id_string[])
+static unsigned char FPT_sciso(unsigned long p_port,
+			       unsigned char p_id_string[])
 {
-   unsigned char ret_data,the_data,byte_cnt,bit_cnt;
+	unsigned char ret_data, the_data, byte_cnt, bit_cnt;
 
-   the_data = 0;
+	the_data = 0;
 
-   for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
+	for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
 
-      for (bit_cnt = 0; bit_cnt < 8; bit_cnt++) {
+		for (bit_cnt = 0; bit_cnt < 8; bit_cnt++) {
 
-         ret_data = FPT_scxferc(p_port,0);
+			ret_data = FPT_scxferc(p_port, 0);
 
-         if (ret_data & 0xFC)
-            return(0xFF);
+			if (ret_data & 0xFC)
+				return (0xFF);
 
-         else {
+			else {
 
-            the_data <<= 1;
-            if (ret_data & BIT(1)) {
-               the_data |= 1;
-               }
-            }
+				the_data <<= 1;
+				if (ret_data & BIT(1)) {
+					the_data |= 1;
+				}
+			}
 
-         if ((ret_data & 0x1F) == 0)
-	   {
+			if ((ret_data & 0x1F) == 0) {
 /*
 				if(bit_cnt != 0 || bit_cnt != 8)
 				{
@@ -6245,23 +6055,21 @@ static unsigned char FPT_sciso(unsigned long p_port, unsigned char p_id_string[]
 					continue;
 				}
 */
-            if (byte_cnt)
-               return(0x00);
-            else
-               return(0xFF);
-	   }
+				if (byte_cnt)
+					return (0x00);
+				else
+					return (0xFF);
+			}
 
-         } /*bit loop */
+		}		/*bit loop */
 
-      p_id_string[byte_cnt] = the_data;
+		p_id_string[byte_cnt] = the_data;
 
-      } /*byte loop */
+	}			/*byte loop */
 
-   return(0);
+	return (0);
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scwirod
@@ -6273,24 +6081,22 @@ static unsigned char FPT_sciso(unsigned long p_port, unsigned char p_id_string[]
 
 static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit)
 {
-   unsigned char i;
+	unsigned char i;
 
-   i = 0;
-   while ( i < MAX_SCSI_TAR ) {
+	i = 0;
+	while (i < MAX_SCSI_TAR) {
 
-      if (RD_HARPOON(p_port+hp_scsidata_0) & p_data_bit)
+		if (RD_HARPOON(p_port + hp_scsidata_0) & p_data_bit)
 
-         i = 0;
+			i = 0;
 
-      else
+		else
 
-         i++;
+			i++;
 
-      }
+	}
 }
 
-
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scwiros
@@ -6302,23 +6108,22 @@ static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit)
 
 static void FPT_scwiros(unsigned long p_port, unsigned char p_data_bit)
 {
-   unsigned char i;
+	unsigned char i;
 
-   i = 0;
-   while ( i < MAX_SCSI_TAR ) {
+	i = 0;
+	while (i < MAX_SCSI_TAR) {
 
-      if (RD_HARPOON(p_port+hp_scsisig) & p_data_bit)
+		if (RD_HARPOON(p_port + hp_scsisig) & p_data_bit)
 
-         i = 0;
+			i = 0;
 
-      else
+		else
 
-         i++;
+			i++;
 
-      }
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scvalq
@@ -6329,21 +6134,20 @@ static void FPT_scwiros(unsigned long p_port, unsigned char p_data_bit)
 
 static unsigned char FPT_scvalq(unsigned char p_quintet)
 {
-   unsigned char count;
+	unsigned char count;
 
-   for (count=1; count < 0x08; count<<=1) {
-      if (!(p_quintet & count))
-         p_quintet -= 0x80;
-      }
+	for (count = 1; count < 0x08; count <<= 1) {
+		if (!(p_quintet & count))
+			p_quintet -= 0x80;
+	}
 
-   if (p_quintet & 0x18)
-      return(0);
+	if (p_quintet & 0x18)
+		return (0);
 
-   else
-      return(1);
+	else
+		return (1);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scsell
@@ -6356,73 +6160,76 @@ static unsigned char FPT_scvalq(unsigned char p_quintet)
 
 static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
 {
-   unsigned long i;
+	unsigned long i;
 
-   WR_HARPOON(p_port+hp_page_ctrl,
-      (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
+	WR_HARPOON(p_port + hp_page_ctrl,
+		   (RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));
 
-   ARAM_ACCESS(p_port);
+	ARAM_ACCESS(p_port);
 
-   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) | SCAM_TIMER));
-   WR_HARPOON(p_port+hp_seltimeout,TO_4ms);
+	WR_HARPOON(p_port + hp_addstat,
+		   (RD_HARPOON(p_port + hp_addstat) | SCAM_TIMER));
+	WR_HARPOON(p_port + hp_seltimeout, TO_4ms);
 
+	for (i = p_port + CMD_STRT; i < p_port + CMD_STRT + 12; i += 2) {
+		WRW_HARPOON(i, (MPM_OP + ACOMMAND));
+	}
+	WRW_HARPOON(i, (BRH_OP + ALWAYS + NP));
 
-   for (i = p_port+CMD_STRT; i < p_port+CMD_STRT+12; i+=2) {
-      WRW_HARPOON(i, (MPM_OP+ACOMMAND));
-      }
-   WRW_HARPOON(i, (BRH_OP+ALWAYS+    NP));
-
-   WRW_HARPOON((p_port+hp_intstat),
-	       (RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));
-
-   WR_HARPOON(p_port+hp_select_id, targ_id);
+	WRW_HARPOON((p_port + hp_intstat),
+		    (RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));
 
-   WR_HARPOON(p_port+hp_portctrl_0, SCSI_PORT);
-   WR_HARPOON(p_port+hp_autostart_3, (SELECT | CMD_ONLY_STRT));
-   WR_HARPOON(p_port+hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
+	WR_HARPOON(p_port + hp_select_id, targ_id);
 
+	WR_HARPOON(p_port + hp_portctrl_0, SCSI_PORT);
+	WR_HARPOON(p_port + hp_autostart_3, (SELECT | CMD_ONLY_STRT));
+	WR_HARPOON(p_port + hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
 
-   while (!(RDW_HARPOON((p_port+hp_intstat)) &
-	    (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {}
+	while (!(RDW_HARPOON((p_port + hp_intstat)) &
+		 (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {
+	}
 
-   if (RDW_HARPOON((p_port+hp_intstat)) & RESET)
-         FPT_Wait(p_port, TO_250ms);
+	if (RDW_HARPOON((p_port + hp_intstat)) & RESET)
+		FPT_Wait(p_port, TO_250ms);
 
-   DISABLE_AUTO(p_port);
+	DISABLE_AUTO(p_port);
 
-   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) & ~SCAM_TIMER));
-   WR_HARPOON(p_port+hp_seltimeout,TO_290ms);
+	WR_HARPOON(p_port + hp_addstat,
+		   (RD_HARPOON(p_port + hp_addstat) & ~SCAM_TIMER));
+	WR_HARPOON(p_port + hp_seltimeout, TO_290ms);
 
-   SGRAM_ACCESS(p_port);
+	SGRAM_ACCESS(p_port);
 
-   if (RDW_HARPOON((p_port+hp_intstat)) & (RESET | TIMEOUT) ) {
+	if (RDW_HARPOON((p_port + hp_intstat)) & (RESET | TIMEOUT)) {
 
-      WRW_HARPOON((p_port+hp_intstat),
-		  (RESET | TIMEOUT | SEL | BUS_FREE | PHASE));
+		WRW_HARPOON((p_port + hp_intstat),
+			    (RESET | TIMEOUT | SEL | BUS_FREE | PHASE));
 
-      WR_HARPOON(p_port+hp_page_ctrl,
-         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+		WR_HARPOON(p_port + hp_page_ctrl,
+			   (RD_HARPOON(p_port + hp_page_ctrl) &
+			    ~G_INT_DISABLE));
 
-      return(0);  /*No legacy device */
-      }
+		return (0);	/*No legacy device */
+	}
 
-   else {
+	else {
 
-      while(!(RDW_HARPOON((p_port+hp_intstat)) & BUS_FREE)) {
-				if (RD_HARPOON(p_port+hp_scsisig) & SCSI_REQ)
-					{
-					WR_HARPOON(p_port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
-      			ACCEPT_MSG(p_port);
-					}
+		while (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {
+			if (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ) {
+				WR_HARPOON(p_port + hp_scsisig,
+					   (SCSI_ACK + S_ILL_PH));
+				ACCEPT_MSG(p_port);
+			}
 		}
 
-      WRW_HARPOON((p_port+hp_intstat), CLR_ALL_INT_1);
+		WRW_HARPOON((p_port + hp_intstat), CLR_ALL_INT_1);
 
-      WR_HARPOON(p_port+hp_page_ctrl,
-         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+		WR_HARPOON(p_port + hp_page_ctrl,
+			   (RD_HARPOON(p_port + hp_page_ctrl) &
+			    ~G_INT_DISABLE));
 
-      return(1);  /*Found one of them oldies! */
-      }
+		return (1);	/*Found one of them oldies! */
+	}
 }
 
 /*---------------------------------------------------------------------
@@ -6435,10 +6242,10 @@ static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
 
 static void FPT_scwtsel(unsigned long p_port)
 {
-   while(!(RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL)) {}
+	while (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_inisci
@@ -6447,57 +6254,64 @@ static void FPT_scwtsel(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_inisci(unsigned char p_card, unsigned long p_port, unsigned char p_our_id)
+static void FPT_inisci(unsigned char p_card, unsigned long p_port,
+		       unsigned char p_our_id)
 {
-   unsigned char i,k,max_id;
-   unsigned short ee_data;
-	struct nvram_info * pCurrNvRam;
+	unsigned char i, k, max_id;
+	unsigned short ee_data;
+	struct nvram_info *pCurrNvRam;
 
 	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
 
-   if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
-      max_id = 0x08;
+	if (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)
+		max_id = 0x08;
 
-   else
-      max_id = 0x10;
+	else
+		max_id = 0x10;
 
-	if(pCurrNvRam){
-		for(i = 0; i < max_id; i++){
+	if (pCurrNvRam) {
+		for (i = 0; i < max_id; i++) {
 
-			for(k = 0; k < 4; k++)
-				FPT_scamInfo[i].id_string[k] = pCurrNvRam->niScamTbl[i][k];
-			for(k = 4; k < ID_STRING_LENGTH; k++)
-				FPT_scamInfo[i].id_string[k] = (unsigned char) 0x00;
+			for (k = 0; k < 4; k++)
+				FPT_scamInfo[i].id_string[k] =
+				    pCurrNvRam->niScamTbl[i][k];
+			for (k = 4; k < ID_STRING_LENGTH; k++)
+				FPT_scamInfo[i].id_string[k] =
+				    (unsigned char)0x00;
 
-	      if(FPT_scamInfo[i].id_string[0] == 0x00)
-      	   FPT_scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
-	      else
-   	      FPT_scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
+			if (FPT_scamInfo[i].id_string[0] == 0x00)
+				FPT_scamInfo[i].state = ID_UNUSED;	/*Default to unused ID. */
+			else
+				FPT_scamInfo[i].state = ID_UNASSIGNED;	/*Default to unassigned ID. */
 
 		}
-	}else {
-	   for (i=0; i < max_id; i++)
-   	   {
-      	for (k=0; k < ID_STRING_LENGTH; k+=2)
-	         {
-   	      ee_data = FPT_utilEERead(p_port, (unsigned short)((EE_SCAMBASE/2) +
-      	     (unsigned short) (i*((unsigned short)ID_STRING_LENGTH/2)) + (unsigned short)(k/2)));
-         	FPT_scamInfo[i].id_string[k] = (unsigned char) ee_data;
-	         ee_data >>= 8;
-   	      FPT_scamInfo[i].id_string[k+1] = (unsigned char) ee_data;
-      	   }
+	} else {
+		for (i = 0; i < max_id; i++) {
+			for (k = 0; k < ID_STRING_LENGTH; k += 2) {
+				ee_data =
+				    FPT_utilEERead(p_port,
+						   (unsigned
+						    short)((EE_SCAMBASE / 2) +
+							   (unsigned short)(i *
+									    ((unsigned short)ID_STRING_LENGTH / 2)) + (unsigned short)(k / 2)));
+				FPT_scamInfo[i].id_string[k] =
+				    (unsigned char)ee_data;
+				ee_data >>= 8;
+				FPT_scamInfo[i].id_string[k + 1] =
+				    (unsigned char)ee_data;
+			}
 
-	      if ((FPT_scamInfo[i].id_string[0] == 0x00) ||
-   	       (FPT_scamInfo[i].id_string[0] == 0xFF))
+			if ((FPT_scamInfo[i].id_string[0] == 0x00) ||
+			    (FPT_scamInfo[i].id_string[0] == 0xFF))
 
-      	   FPT_scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
+				FPT_scamInfo[i].state = ID_UNUSED;	/*Default to unused ID. */
 
-	      else
-   	      FPT_scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
+			else
+				FPT_scamInfo[i].state = ID_UNASSIGNED;	/*Default to unassigned ID. */
 
-      	}
+		}
 	}
-	for(k = 0; k < ID_STRING_LENGTH; k++)
+	for (k = 0; k < ID_STRING_LENGTH; k++)
 		FPT_scamInfo[p_our_id].id_string[k] = FPT_scamHAString[k];
 
 }
@@ -6511,127 +6325,114 @@ static void FPT_inisci(unsigned char p_card, unsigned long p_port, unsigned char
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_string[])
+static unsigned char FPT_scmachid(unsigned char p_card,
+				  unsigned char p_id_string[])
 {
 
-   unsigned char i,k,match;
-
+	unsigned char i, k, match;
 
-   for (i=0; i < MAX_SCSI_TAR; i++) {
+	for (i = 0; i < MAX_SCSI_TAR; i++) {
 
-         match = 1;
-
-         for (k=0; k < ID_STRING_LENGTH; k++)
-            {
-            if (p_id_string[k] != FPT_scamInfo[i].id_string[k])
-               match = 0;
-            }
-
-         if (match)
-            {
-            FPT_scamInfo[i].state = ID_ASSIGNED;
-            return(i);
-            }
-
-      }
+		match = 1;
 
+		for (k = 0; k < ID_STRING_LENGTH; k++) {
+			if (p_id_string[k] != FPT_scamInfo[i].id_string[k])
+				match = 0;
+		}
 
+		if (match) {
+			FPT_scamInfo[i].state = ID_ASSIGNED;
+			return (i);
+		}
 
-   if (p_id_string[0] & BIT(5))
-      i = 8;
-   else
-      i = MAX_SCSI_TAR;
+	}
 
-   if (((p_id_string[0] & 0x06) == 0x02) || ((p_id_string[0] & 0x06) == 0x04))
-      match = p_id_string[1] & (unsigned char) 0x1F;
-   else
-      match = 7;
+	if (p_id_string[0] & BIT(5))
+		i = 8;
+	else
+		i = MAX_SCSI_TAR;
 
-   while (i > 0)
-      {
-      i--;
+	if (((p_id_string[0] & 0x06) == 0x02)
+	    || ((p_id_string[0] & 0x06) == 0x04))
+		match = p_id_string[1] & (unsigned char)0x1F;
+	else
+		match = 7;
 
-      if (FPT_scamInfo[match].state == ID_UNUSED)
-         {
-         for (k=0; k < ID_STRING_LENGTH; k++)
-            {
-            FPT_scamInfo[match].id_string[k] = p_id_string[k];
-            }
+	while (i > 0) {
+		i--;
 
-         FPT_scamInfo[match].state = ID_ASSIGNED;
+		if (FPT_scamInfo[match].state == ID_UNUSED) {
+			for (k = 0; k < ID_STRING_LENGTH; k++) {
+				FPT_scamInfo[match].id_string[k] =
+				    p_id_string[k];
+			}
 
-			if(FPT_BL_Card[p_card].pNvRamInfo == NULL)
-	         FPT_BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
-         return(match);
+			FPT_scamInfo[match].state = ID_ASSIGNED;
 
-         }
+			if (FPT_BL_Card[p_card].pNvRamInfo == NULL)
+				FPT_BL_Card[p_card].globalFlags |=
+				    F_UPDATE_EEPROM;
+			return (match);
 
+		}
 
-      match--;
+		match--;
 
-      if (match == 0xFF)
-	{
-         if (p_id_string[0] & BIT(5))
-            match = 7;
-         else
-            match = MAX_SCSI_TAR-1;
+		if (match == 0xFF) {
+			if (p_id_string[0] & BIT(5))
+				match = 7;
+			else
+				match = MAX_SCSI_TAR - 1;
+		}
 	}
-      }
-
-
-
-   if (p_id_string[0] & BIT(7))
-      {
-      return(CLR_PRIORITY);
-      }
-
 
-   if (p_id_string[0] & BIT(5))
-      i = 8;
-   else
-      i = MAX_SCSI_TAR;
+	if (p_id_string[0] & BIT(7)) {
+		return (CLR_PRIORITY);
+	}
 
-   if (((p_id_string[0] & 0x06) == 0x02) || ((p_id_string[0] & 0x06) == 0x04))
-      match = p_id_string[1] & (unsigned char) 0x1F;
-   else
-      match = 7;
+	if (p_id_string[0] & BIT(5))
+		i = 8;
+	else
+		i = MAX_SCSI_TAR;
 
-   while (i > 0)
-      {
+	if (((p_id_string[0] & 0x06) == 0x02)
+	    || ((p_id_string[0] & 0x06) == 0x04))
+		match = p_id_string[1] & (unsigned char)0x1F;
+	else
+		match = 7;
 
-      i--;
+	while (i > 0) {
 
-      if (FPT_scamInfo[match].state == ID_UNASSIGNED)
-         {
-         for (k=0; k < ID_STRING_LENGTH; k++)
-            {
-            FPT_scamInfo[match].id_string[k] = p_id_string[k];
-            }
+		i--;
 
-         FPT_scamInfo[match].id_string[0] |= BIT(7);
-         FPT_scamInfo[match].state = ID_ASSIGNED;
-			if(FPT_BL_Card[p_card].pNvRamInfo == NULL)
-	         FPT_BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
-         return(match);
+		if (FPT_scamInfo[match].state == ID_UNASSIGNED) {
+			for (k = 0; k < ID_STRING_LENGTH; k++) {
+				FPT_scamInfo[match].id_string[k] =
+				    p_id_string[k];
+			}
 
-         }
+			FPT_scamInfo[match].id_string[0] |= BIT(7);
+			FPT_scamInfo[match].state = ID_ASSIGNED;
+			if (FPT_BL_Card[p_card].pNvRamInfo == NULL)
+				FPT_BL_Card[p_card].globalFlags |=
+				    F_UPDATE_EEPROM;
+			return (match);
 
+		}
 
-      match--;
+		match--;
 
-      if (match == 0xFF)
-	{
-         if (p_id_string[0] & BIT(5))
-            match = 7;
-         else
-            match = MAX_SCSI_TAR-1;
+		if (match == 0xFF) {
+			if (p_id_string[0] & BIT(5))
+				match = 7;
+			else
+				match = MAX_SCSI_TAR - 1;
+		}
 	}
-      }
 
-   return(NO_ID_AVAIL);
+	return (NO_ID_AVAIL);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_scsavdi
@@ -6642,43 +6443,39 @@ static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_strin
 
 static void FPT_scsavdi(unsigned char p_card, unsigned long p_port)
 {
-   unsigned char i,k,max_id;
-   unsigned short ee_data,sum_data;
-
-
-   sum_data = 0x0000;
-
-   for (i = 1; i < EE_SCAMBASE/2; i++)
-      {
-      sum_data += FPT_utilEERead(p_port, i);
-      }
-
-
-   FPT_utilEEWriteOnOff(p_port,1);   /* Enable write access to the EEPROM */
+	unsigned char i, k, max_id;
+	unsigned short ee_data, sum_data;
 
-   if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
-      max_id = 0x08;
+	sum_data = 0x0000;
 
-   else
-      max_id = 0x10;
+	for (i = 1; i < EE_SCAMBASE / 2; i++) {
+		sum_data += FPT_utilEERead(p_port, i);
+	}
 
-   for (i=0; i < max_id; i++)
-      {
+	FPT_utilEEWriteOnOff(p_port, 1);	/* Enable write access to the EEPROM */
 
-      for (k=0; k < ID_STRING_LENGTH; k+=2)
-         {
-         ee_data = FPT_scamInfo[i].id_string[k+1];
-         ee_data <<= 8;
-         ee_data |= FPT_scamInfo[i].id_string[k];
-         sum_data += ee_data;
-         FPT_utilEEWrite(p_port, ee_data, (unsigned short)((EE_SCAMBASE/2) +
-            (unsigned short)(i*((unsigned short)ID_STRING_LENGTH/2)) + (unsigned short)(k/2)));
-         }
-      }
+	if (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)
+		max_id = 0x08;
 
+	else
+		max_id = 0x10;
+
+	for (i = 0; i < max_id; i++) {
+
+		for (k = 0; k < ID_STRING_LENGTH; k += 2) {
+			ee_data = FPT_scamInfo[i].id_string[k + 1];
+			ee_data <<= 8;
+			ee_data |= FPT_scamInfo[i].id_string[k];
+			sum_data += ee_data;
+			FPT_utilEEWrite(p_port, ee_data,
+					(unsigned short)((EE_SCAMBASE / 2) +
+							 (unsigned short)(i *
+									  ((unsigned short)ID_STRING_LENGTH / 2)) + (unsigned short)(k / 2)));
+		}
+	}
 
-   FPT_utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM/2);
-   FPT_utilEEWriteOnOff(p_port,0);   /* Turn off write access */
+	FPT_utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM / 2);
+	FPT_utilEEWriteOnOff(p_port, 0);	/* Turn off write access */
 }
 
 /*---------------------------------------------------------------------
@@ -6691,46 +6488,45 @@ static void FPT_scsavdi(unsigned char p_card, unsigned long p_port)
 
 static void FPT_XbowInit(unsigned long port, unsigned char ScamFlg)
 {
-unsigned char i;
+	unsigned char i;
 
-	i = RD_HARPOON(port+hp_page_ctrl);
-	WR_HARPOON(port+hp_page_ctrl, (unsigned char) (i | G_INT_DISABLE));
+	i = RD_HARPOON(port + hp_page_ctrl);
+	WR_HARPOON(port + hp_page_ctrl, (unsigned char)(i | G_INT_DISABLE));
 
-   WR_HARPOON(port+hp_scsireset,0x00);
-   WR_HARPOON(port+hp_portctrl_1,HOST_MODE8);
+	WR_HARPOON(port + hp_scsireset, 0x00);
+	WR_HARPOON(port + hp_portctrl_1, HOST_MODE8);
 
-   WR_HARPOON(port+hp_scsireset,(DMA_RESET | HPSCSI_RESET | PROG_RESET | \
-				 FIFO_CLR));
+	WR_HARPOON(port + hp_scsireset, (DMA_RESET | HPSCSI_RESET | PROG_RESET |
+					 FIFO_CLR));
 
-   WR_HARPOON(port+hp_scsireset,SCSI_INI);
+	WR_HARPOON(port + hp_scsireset, SCSI_INI);
 
-   WR_HARPOON(port+hp_clkctrl_0,CLKCTRL_DEFAULT);
+	WR_HARPOON(port + hp_clkctrl_0, CLKCTRL_DEFAULT);
 
-   WR_HARPOON(port+hp_scsisig,0x00);         /*  Clear any signals we might */
-   WR_HARPOON(port+hp_scsictrl_0,ENA_SCAM_SEL);
+	WR_HARPOON(port + hp_scsisig, 0x00);	/*  Clear any signals we might */
+	WR_HARPOON(port + hp_scsictrl_0, ENA_SCAM_SEL);
 
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+	WRW_HARPOON((port + hp_intstat), CLR_ALL_INT);
 
-   FPT_default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
-		    BUS_FREE | XFER_CNT_0 | AUTO_INT;
+	FPT_default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
+	    BUS_FREE | XFER_CNT_0 | AUTO_INT;
 
-   if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
+	if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
 		FPT_default_intena |= SCAM_SEL;
 
-   WRW_HARPOON((port+hp_intena), FPT_default_intena);
+	WRW_HARPOON((port + hp_intena), FPT_default_intena);
 
-   WR_HARPOON(port+hp_seltimeout,TO_290ms);
+	WR_HARPOON(port + hp_seltimeout, TO_290ms);
 
-   /* Turn on SCSI_MODE8 for narrow cards to fix the
-      strapping issue with the DUAL CHANNEL card */
-   if (RD_HARPOON(port+hp_page_ctrl) & NARROW_SCSI_CARD)
-      WR_HARPOON(port+hp_addstat,SCSI_MODE8);
+	/* Turn on SCSI_MODE8 for narrow cards to fix the
+	   strapping issue with the DUAL CHANNEL card */
+	if (RD_HARPOON(port + hp_page_ctrl) & NARROW_SCSI_CARD)
+		WR_HARPOON(port + hp_addstat, SCSI_MODE8);
 
-	WR_HARPOON(port+hp_page_ctrl, i);
+	WR_HARPOON(port + hp_page_ctrl, i);
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_BusMasterInit
@@ -6742,25 +6538,21 @@ unsigned char i;
 static void FPT_BusMasterInit(unsigned long p_port)
 {
 
+	WR_HARPOON(p_port + hp_sys_ctrl, DRVR_RST);
+	WR_HARPOON(p_port + hp_sys_ctrl, 0x00);
 
-   WR_HARPOON(p_port+hp_sys_ctrl, DRVR_RST);
-   WR_HARPOON(p_port+hp_sys_ctrl, 0x00);
-
-   WR_HARPOON(p_port+hp_host_blk_cnt, XFER_BLK64);
-
-
-   WR_HARPOON(p_port+hp_bm_ctrl, (BMCTRL_DEFAULT));
+	WR_HARPOON(p_port + hp_host_blk_cnt, XFER_BLK64);
 
-   WR_HARPOON(p_port+hp_ee_ctrl, (SCSI_TERM_ENA_H));
+	WR_HARPOON(p_port + hp_bm_ctrl, (BMCTRL_DEFAULT));
 
+	WR_HARPOON(p_port + hp_ee_ctrl, (SCSI_TERM_ENA_H));
 
-   RD_HARPOON(p_port+hp_int_status);        /*Clear interrupts. */
-   WR_HARPOON(p_port+hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
-   WR_HARPOON(p_port+hp_page_ctrl, (RD_HARPOON(p_port+hp_page_ctrl) &
-      ~SCATTER_EN));
+	RD_HARPOON(p_port + hp_int_status);	/*Clear interrupts. */
+	WR_HARPOON(p_port + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
+	WR_HARPOON(p_port + hp_page_ctrl, (RD_HARPOON(p_port + hp_page_ctrl) &
+					   ~SCATTER_EN));
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_DiagEEPROM
@@ -6772,156 +6564,151 @@ static void FPT_BusMasterInit(unsigned long p_port)
 
 static void FPT_DiagEEPROM(unsigned long p_port)
 {
-   unsigned short index,temp,max_wd_cnt;
-
-   if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
-      max_wd_cnt = EEPROM_WD_CNT;
-   else
-      max_wd_cnt = EEPROM_WD_CNT * 2;
+	unsigned short index, temp, max_wd_cnt;
 
-   temp = FPT_utilEERead(p_port, FW_SIGNATURE/2);
+	if (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)
+		max_wd_cnt = EEPROM_WD_CNT;
+	else
+		max_wd_cnt = EEPROM_WD_CNT * 2;
 
-   if (temp == 0x4641) {
+	temp = FPT_utilEERead(p_port, FW_SIGNATURE / 2);
 
-      for (index = 2; index < max_wd_cnt; index++) {
+	if (temp == 0x4641) {
 
-         temp += FPT_utilEERead(p_port, index);
+		for (index = 2; index < max_wd_cnt; index++) {
 
-         }
+			temp += FPT_utilEERead(p_port, index);
 
-      if (temp == FPT_utilEERead(p_port, EEPROM_CHECK_SUM/2)) {
+		}
 
-         return;          /*EEPROM is Okay so return now! */
-         }
-      }
+		if (temp == FPT_utilEERead(p_port, EEPROM_CHECK_SUM / 2)) {
 
+			return;	/*EEPROM is Okay so return now! */
+		}
+	}
 
-   FPT_utilEEWriteOnOff(p_port,(unsigned char)1);
+	FPT_utilEEWriteOnOff(p_port, (unsigned char)1);
 
-   for (index = 0; index < max_wd_cnt; index++) {
+	for (index = 0; index < max_wd_cnt; index++) {
 
-      FPT_utilEEWrite(p_port, 0x0000, index);
-      }
+		FPT_utilEEWrite(p_port, 0x0000, index);
+	}
 
-   temp = 0;
-
-   FPT_utilEEWrite(p_port, 0x4641, FW_SIGNATURE/2);
-   temp += 0x4641;
-   FPT_utilEEWrite(p_port, 0x3920, MODEL_NUMB_0/2);
-   temp += 0x3920;
-   FPT_utilEEWrite(p_port, 0x3033, MODEL_NUMB_2/2);
-   temp += 0x3033;
-   FPT_utilEEWrite(p_port, 0x2020, MODEL_NUMB_4/2);
-   temp += 0x2020;
-   FPT_utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG/2);
-   temp += 0x70D3;
-   FPT_utilEEWrite(p_port, 0x0010, BIOS_CONFIG/2);
-   temp += 0x0010;
-   FPT_utilEEWrite(p_port, 0x0003, SCAM_CONFIG/2);
-   temp += 0x0003;
-   FPT_utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID/2);
-   temp += 0x0007;
-
-   FPT_utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN/2);
-   temp += 0x0000;
-   FPT_utilEEWrite(p_port, 0x0000, SEND_START_ENA/2);
-   temp += 0x0000;
-   FPT_utilEEWrite(p_port, 0x0000, DEVICE_ENABLE/2);
-   temp += 0x0000;
-
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd/2);
-   temp += 0x4242;
-   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef/2);
-   temp += 0x4242;
-
-
-   FPT_utilEEWrite(p_port, 0x6C46, 64/2);  /*PRODUCT ID */
-   temp += 0x6C46;
-   FPT_utilEEWrite(p_port, 0x7361, 66/2);  /* FlashPoint LT   */
-   temp += 0x7361;
-   FPT_utilEEWrite(p_port, 0x5068, 68/2);
-   temp += 0x5068;
-   FPT_utilEEWrite(p_port, 0x696F, 70/2);
-   temp += 0x696F;
-   FPT_utilEEWrite(p_port, 0x746E, 72/2);
-   temp += 0x746E;
-   FPT_utilEEWrite(p_port, 0x4C20, 74/2);
-   temp += 0x4C20;
-   FPT_utilEEWrite(p_port, 0x2054, 76/2);
-   temp += 0x2054;
-   FPT_utilEEWrite(p_port, 0x2020, 78/2);
-   temp += 0x2020;
-
-   index = ((EE_SCAMBASE/2)+(7*16));
-   FPT_utilEEWrite(p_port, (0x0700+TYPE_CODE0), index);
-   temp += (0x0700+TYPE_CODE0);
-   index++;
-   FPT_utilEEWrite(p_port, 0x5542, index);            /*Vendor ID code */
-   temp += 0x5542;                                /* BUSLOGIC      */
-   index++;
-   FPT_utilEEWrite(p_port, 0x4C53, index);
-   temp += 0x4C53;
-   index++;
-   FPT_utilEEWrite(p_port, 0x474F, index);
-   temp += 0x474F;
-   index++;
-   FPT_utilEEWrite(p_port, 0x4349, index);
-   temp += 0x4349;
-   index++;
-   FPT_utilEEWrite(p_port, 0x5442, index);            /*Vendor unique code */
-   temp += 0x5442;                         /* BT- 930           */
-   index++;
-   FPT_utilEEWrite(p_port, 0x202D, index);
-   temp += 0x202D;
-   index++;
-   FPT_utilEEWrite(p_port, 0x3339, index);
-   temp += 0x3339;
-   index++;                                 /*Serial #          */
-   FPT_utilEEWrite(p_port, 0x2030, index);             /* 01234567         */
-   temp += 0x2030;
-   index++;
-   FPT_utilEEWrite(p_port, 0x5453, index);
-   temp += 0x5453;
-   index++;
-   FPT_utilEEWrite(p_port, 0x5645, index);
-   temp += 0x5645;
-   index++;
-   FPT_utilEEWrite(p_port, 0x2045, index);
-   temp += 0x2045;
-   index++;
-   FPT_utilEEWrite(p_port, 0x202F, index);
-   temp += 0x202F;
-   index++;
-   FPT_utilEEWrite(p_port, 0x4F4A, index);
-   temp += 0x4F4A;
-   index++;
-   FPT_utilEEWrite(p_port, 0x204E, index);
-   temp += 0x204E;
-   index++;
-   FPT_utilEEWrite(p_port, 0x3539, index);
-   temp += 0x3539;
-
-
-
-   FPT_utilEEWrite(p_port, temp, EEPROM_CHECK_SUM/2);
-
-   FPT_utilEEWriteOnOff(p_port,(unsigned char)0);
+	temp = 0;
+
+	FPT_utilEEWrite(p_port, 0x4641, FW_SIGNATURE / 2);
+	temp += 0x4641;
+	FPT_utilEEWrite(p_port, 0x3920, MODEL_NUMB_0 / 2);
+	temp += 0x3920;
+	FPT_utilEEWrite(p_port, 0x3033, MODEL_NUMB_2 / 2);
+	temp += 0x3033;
+	FPT_utilEEWrite(p_port, 0x2020, MODEL_NUMB_4 / 2);
+	temp += 0x2020;
+	FPT_utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG / 2);
+	temp += 0x70D3;
+	FPT_utilEEWrite(p_port, 0x0010, BIOS_CONFIG / 2);
+	temp += 0x0010;
+	FPT_utilEEWrite(p_port, 0x0003, SCAM_CONFIG / 2);
+	temp += 0x0003;
+	FPT_utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID / 2);
+	temp += 0x0007;
+
+	FPT_utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN / 2);
+	temp += 0x0000;
+	FPT_utilEEWrite(p_port, 0x0000, SEND_START_ENA / 2);
+	temp += 0x0000;
+	FPT_utilEEWrite(p_port, 0x0000, DEVICE_ENABLE / 2);
+	temp += 0x0000;
+
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01 / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23 / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45 / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67 / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89 / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd / 2);
+	temp += 0x4242;
+	FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef / 2);
+	temp += 0x4242;
+
+	FPT_utilEEWrite(p_port, 0x6C46, 64 / 2);	/*PRODUCT ID */
+	temp += 0x6C46;
+	FPT_utilEEWrite(p_port, 0x7361, 66 / 2);	/* FlashPoint LT   */
+	temp += 0x7361;
+	FPT_utilEEWrite(p_port, 0x5068, 68 / 2);
+	temp += 0x5068;
+	FPT_utilEEWrite(p_port, 0x696F, 70 / 2);
+	temp += 0x696F;
+	FPT_utilEEWrite(p_port, 0x746E, 72 / 2);
+	temp += 0x746E;
+	FPT_utilEEWrite(p_port, 0x4C20, 74 / 2);
+	temp += 0x4C20;
+	FPT_utilEEWrite(p_port, 0x2054, 76 / 2);
+	temp += 0x2054;
+	FPT_utilEEWrite(p_port, 0x2020, 78 / 2);
+	temp += 0x2020;
+
+	index = ((EE_SCAMBASE / 2) + (7 * 16));
+	FPT_utilEEWrite(p_port, (0x0700 + TYPE_CODE0), index);
+	temp += (0x0700 + TYPE_CODE0);
+	index++;
+	FPT_utilEEWrite(p_port, 0x5542, index);	/*Vendor ID code */
+	temp += 0x5542;		/* BUSLOGIC      */
+	index++;
+	FPT_utilEEWrite(p_port, 0x4C53, index);
+	temp += 0x4C53;
+	index++;
+	FPT_utilEEWrite(p_port, 0x474F, index);
+	temp += 0x474F;
+	index++;
+	FPT_utilEEWrite(p_port, 0x4349, index);
+	temp += 0x4349;
+	index++;
+	FPT_utilEEWrite(p_port, 0x5442, index);	/*Vendor unique code */
+	temp += 0x5442;		/* BT- 930           */
+	index++;
+	FPT_utilEEWrite(p_port, 0x202D, index);
+	temp += 0x202D;
+	index++;
+	FPT_utilEEWrite(p_port, 0x3339, index);
+	temp += 0x3339;
+	index++;		/*Serial #          */
+	FPT_utilEEWrite(p_port, 0x2030, index);	/* 01234567         */
+	temp += 0x2030;
+	index++;
+	FPT_utilEEWrite(p_port, 0x5453, index);
+	temp += 0x5453;
+	index++;
+	FPT_utilEEWrite(p_port, 0x5645, index);
+	temp += 0x5645;
+	index++;
+	FPT_utilEEWrite(p_port, 0x2045, index);
+	temp += 0x2045;
+	index++;
+	FPT_utilEEWrite(p_port, 0x202F, index);
+	temp += 0x202F;
+	index++;
+	FPT_utilEEWrite(p_port, 0x4F4A, index);
+	temp += 0x4F4A;
+	index++;
+	FPT_utilEEWrite(p_port, 0x204E, index);
+	temp += 0x204E;
+	index++;
+	FPT_utilEEWrite(p_port, 0x3539, index);
+	temp += 0x3539;
+
+	FPT_utilEEWrite(p_port, temp, EEPROM_CHECK_SUM / 2);
+
+	FPT_utilEEWriteOnOff(p_port, (unsigned char)0);
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Queue Search Select
@@ -6930,103 +6717,127 @@ static void FPT_DiagEEPROM(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_card)
+static void FPT_queueSearchSelect(struct sccb_card *pCurrCard,
+				  unsigned char p_card)
 {
-   unsigned char scan_ptr, lun;
-   struct sccb_mgr_tar_info * currTar_Info;
-	struct sccb * pOldSccb;
+	unsigned char scan_ptr, lun;
+	struct sccb_mgr_tar_info *currTar_Info;
+	struct sccb *pOldSccb;
 
-   scan_ptr = pCurrCard->scanIndex;
-	do 
-	{
+	scan_ptr = pCurrCard->scanIndex;
+	do {
 		currTar_Info = &FPT_sccbMgrTbl[p_card][scan_ptr];
-		if((pCurrCard->globalFlags & F_CONLUN_IO) && 
-			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-		{
-			if (currTar_Info->TarSelQ_Cnt != 0)
-			{
+		if ((pCurrCard->globalFlags & F_CONLUN_IO) &&
+		    ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=
+		     TAG_Q_TRYING)) {
+			if (currTar_Info->TarSelQ_Cnt != 0) {
 
 				scan_ptr++;
 				if (scan_ptr == MAX_SCSI_TAR)
 					scan_ptr = 0;
-				
-				for(lun=0; lun < MAX_LUN; lun++)
-				{
-					if(currTar_Info->TarLUNBusy[lun] == 0)
-					{
 
-						pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
+				for (lun = 0; lun < MAX_LUN; lun++) {
+					if (currTar_Info->TarLUNBusy[lun] == 0) {
+
+						pCurrCard->currentSCCB =
+						    currTar_Info->TarSelQ_Head;
 						pOldSccb = NULL;
 
-						while((pCurrCard->currentSCCB != NULL) &&
-								 (lun != pCurrCard->currentSCCB->Lun))
-						{
-							pOldSccb = pCurrCard->currentSCCB;
-							pCurrCard->currentSCCB = (struct sccb *)(pCurrCard->currentSCCB)->
-																	Sccb_forwardlink;
+						while ((pCurrCard->
+							currentSCCB != NULL)
+						       && (lun !=
+							   pCurrCard->
+							   currentSCCB->Lun)) {
+							pOldSccb =
+							    pCurrCard->
+							    currentSCCB;
+							pCurrCard->currentSCCB =
+							    (struct sccb
+							     *)(pCurrCard->
+								currentSCCB)->
+							    Sccb_forwardlink;
 						}
-						if(pCurrCard->currentSCCB == NULL)
+						if (pCurrCard->currentSCCB ==
+						    NULL)
 							continue;
-						if(pOldSccb != NULL)
-						{
-							pOldSccb->Sccb_forwardlink = (struct sccb *)(pCurrCard->currentSCCB)->
-																	Sccb_forwardlink;
-							pOldSccb->Sccb_backlink = (struct sccb *)(pCurrCard->currentSCCB)->
-																	Sccb_backlink;
-							currTar_Info->TarSelQ_Cnt--;
-						}
-						else
-						{
-							currTar_Info->TarSelQ_Head = (struct sccb *)(pCurrCard->currentSCCB)->Sccb_forwardlink;
-					
-							if (currTar_Info->TarSelQ_Head == NULL)
-							{
-								currTar_Info->TarSelQ_Tail = NULL;
-								currTar_Info->TarSelQ_Cnt = 0;
-							}
-							else
-							{
-								currTar_Info->TarSelQ_Cnt--;
-								currTar_Info->TarSelQ_Head->Sccb_backlink = (struct sccb *)NULL;
+						if (pOldSccb != NULL) {
+							pOldSccb->
+							    Sccb_forwardlink =
+							    (struct sccb
+							     *)(pCurrCard->
+								currentSCCB)->
+							    Sccb_forwardlink;
+							pOldSccb->
+							    Sccb_backlink =
+							    (struct sccb
+							     *)(pCurrCard->
+								currentSCCB)->
+							    Sccb_backlink;
+							currTar_Info->
+							    TarSelQ_Cnt--;
+						} else {
+							currTar_Info->
+							    TarSelQ_Head =
+							    (struct sccb
+							     *)(pCurrCard->
+								currentSCCB)->
+							    Sccb_forwardlink;
+
+							if (currTar_Info->
+							    TarSelQ_Head ==
+							    NULL) {
+								currTar_Info->
+								    TarSelQ_Tail
+								    = NULL;
+								currTar_Info->
+								    TarSelQ_Cnt
+								    = 0;
+							} else {
+								currTar_Info->
+								    TarSelQ_Cnt--;
+								currTar_Info->
+								    TarSelQ_Head->
+								    Sccb_backlink
+								    =
+								    (struct sccb
+								     *)NULL;
 							}
 						}
-					pCurrCard->scanIndex = scan_ptr;
+						pCurrCard->scanIndex = scan_ptr;
 
-					pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
+						pCurrCard->globalFlags |=
+						    F_NEW_SCCB_CMD;
 
-					break;
+						break;
 					}
 				}
 			}
 
-			else 
-			{
+			else {
 				scan_ptr++;
 				if (scan_ptr == MAX_SCSI_TAR) {
 					scan_ptr = 0;
 				}
 			}
 
-		}
-		else
-		{
+		} else {
 			if ((currTar_Info->TarSelQ_Cnt != 0) &&
-				(currTar_Info->TarLUNBusy[0] == 0))
-			{
+			    (currTar_Info->TarLUNBusy[0] == 0)) {
 
-				pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
+				pCurrCard->currentSCCB =
+				    currTar_Info->TarSelQ_Head;
 
-				currTar_Info->TarSelQ_Head = (struct sccb *)(pCurrCard->currentSCCB)->Sccb_forwardlink;
+				currTar_Info->TarSelQ_Head =
+				    (struct sccb *)(pCurrCard->currentSCCB)->
+				    Sccb_forwardlink;
 
-				if (currTar_Info->TarSelQ_Head == NULL)
-				{
+				if (currTar_Info->TarSelQ_Head == NULL) {
 					currTar_Info->TarSelQ_Tail = NULL;
 					currTar_Info->TarSelQ_Cnt = 0;
-				}
-				else
-				{
+				} else {
 					currTar_Info->TarSelQ_Cnt--;
-					currTar_Info->TarSelQ_Head->Sccb_backlink = (struct sccb *)NULL;
+					currTar_Info->TarSelQ_Head->
+					    Sccb_backlink = (struct sccb *)NULL;
 				}
 
 				scan_ptr++;
@@ -7040,11 +6851,9 @@ static void FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_
 				break;
 			}
 
-			else 
-			{
+			else {
 				scan_ptr++;
-				if (scan_ptr == MAX_SCSI_TAR) 
-				{
+				if (scan_ptr == MAX_SCSI_TAR) {
 					scan_ptr = 0;
 				}
 			}
@@ -7052,7 +6861,6 @@ static void FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_
 	} while (scan_ptr != pCurrCard->scanIndex);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Queue Select Fail
@@ -7061,37 +6869,39 @@ static void FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueSelectFail(struct sccb_card * pCurrCard, unsigned char p_card)
+static void FPT_queueSelectFail(struct sccb_card *pCurrCard,
+				unsigned char p_card)
 {
-   unsigned char thisTarg;
-   struct sccb_mgr_tar_info * currTar_Info;
+	unsigned char thisTarg;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   if (pCurrCard->currentSCCB != NULL)
-	  {
-	  thisTarg = (unsigned char)(((struct sccb *)(pCurrCard->currentSCCB))->TargID);
-      currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
+	if (pCurrCard->currentSCCB != NULL) {
+		thisTarg =
+		    (unsigned char)(((struct sccb *)(pCurrCard->currentSCCB))->
+				    TargID);
+		currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
-      pCurrCard->currentSCCB->Sccb_backlink = (struct sccb *)NULL;
+		pCurrCard->currentSCCB->Sccb_backlink = (struct sccb *)NULL;
 
-      pCurrCard->currentSCCB->Sccb_forwardlink = currTar_Info->TarSelQ_Head;
+		pCurrCard->currentSCCB->Sccb_forwardlink =
+		    currTar_Info->TarSelQ_Head;
 
-	  if (currTar_Info->TarSelQ_Cnt == 0)
-		 {
-		 currTar_Info->TarSelQ_Tail = pCurrCard->currentSCCB;
-		 }
-
-	  else
-		 {
-		 currTar_Info->TarSelQ_Head->Sccb_backlink = pCurrCard->currentSCCB;
-		 }
+		if (currTar_Info->TarSelQ_Cnt == 0) {
+			currTar_Info->TarSelQ_Tail = pCurrCard->currentSCCB;
+		}
 
+		else {
+			currTar_Info->TarSelQ_Head->Sccb_backlink =
+			    pCurrCard->currentSCCB;
+		}
 
-	  currTar_Info->TarSelQ_Head = pCurrCard->currentSCCB;
+		currTar_Info->TarSelQ_Head = pCurrCard->currentSCCB;
 
-	  pCurrCard->currentSCCB = NULL;
-	  currTar_Info->TarSelQ_Cnt++;
-	  }
+		pCurrCard->currentSCCB = NULL;
+		currTar_Info->TarSelQ_Cnt++;
+	}
 }
+
 /*---------------------------------------------------------------------
  *
  * Function: Queue Command Complete
@@ -7100,101 +6910,97 @@ static void FPT_queueSelectFail(struct sccb_card * pCurrCard, unsigned char p_ca
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueCmdComplete(struct sccb_card * pCurrCard, struct sccb * p_sccb,
-				 unsigned char p_card)
+static void FPT_queueCmdComplete(struct sccb_card *pCurrCard,
+				 struct sccb *p_sccb, unsigned char p_card)
 {
 
-   unsigned char i, SCSIcmd;
-   CALL_BK_FN callback;
-   struct sccb_mgr_tar_info * currTar_Info;
-
-   SCSIcmd = p_sccb->Cdb[0];
-
-
-   if (!(p_sccb->Sccb_XferState & F_ALL_XFERRED)) {
-
-	  if ((p_sccb->ControlByte & (SCCB_DATA_XFER_OUT | SCCB_DATA_XFER_IN)) &&
-		 (p_sccb->HostStatus == SCCB_COMPLETE)                             &&
-		 (p_sccb->TargetStatus != SSCHECK))
-
-		 if ((SCSIcmd == SCSI_READ)             ||
-			 (SCSIcmd == SCSI_WRITE)            ||
-			 (SCSIcmd == SCSI_READ_EXTENDED)    ||
-			 (SCSIcmd == SCSI_WRITE_EXTENDED)   ||
-			 (SCSIcmd == SCSI_WRITE_AND_VERIFY) ||
-			 (SCSIcmd == SCSI_START_STOP_UNIT)  ||
-			 (pCurrCard->globalFlags & F_NO_FILTER)
-			)
-			   p_sccb->HostStatus = SCCB_DATA_UNDER_RUN;
-	  }
-
+	unsigned char i, SCSIcmd;
+	CALL_BK_FN callback;
+	struct sccb_mgr_tar_info *currTar_Info;
+
+	SCSIcmd = p_sccb->Cdb[0];
+
+	if (!(p_sccb->Sccb_XferState & F_ALL_XFERRED)) {
+
+		if ((p_sccb->
+		     ControlByte & (SCCB_DATA_XFER_OUT | SCCB_DATA_XFER_IN))
+		    && (p_sccb->HostStatus == SCCB_COMPLETE)
+		    && (p_sccb->TargetStatus != SSCHECK))
+
+			if ((SCSIcmd == SCSI_READ) ||
+			    (SCSIcmd == SCSI_WRITE) ||
+			    (SCSIcmd == SCSI_READ_EXTENDED) ||
+			    (SCSIcmd == SCSI_WRITE_EXTENDED) ||
+			    (SCSIcmd == SCSI_WRITE_AND_VERIFY) ||
+			    (SCSIcmd == SCSI_START_STOP_UNIT) ||
+			    (pCurrCard->globalFlags & F_NO_FILTER)
+			    )
+				p_sccb->HostStatus = SCCB_DATA_UNDER_RUN;
+	}
 
-	if(p_sccb->SccbStatus == SCCB_IN_PROCESS)
-	{
-	   if (p_sccb->HostStatus || p_sccb->TargetStatus)
-		  p_sccb->SccbStatus = SCCB_ERROR;
-	   else
-		  p_sccb->SccbStatus = SCCB_SUCCESS;
+	if (p_sccb->SccbStatus == SCCB_IN_PROCESS) {
+		if (p_sccb->HostStatus || p_sccb->TargetStatus)
+			p_sccb->SccbStatus = SCCB_ERROR;
+		else
+			p_sccb->SccbStatus = SCCB_SUCCESS;
 	}
 
-   if (p_sccb->Sccb_XferState & F_AUTO_SENSE) {
+	if (p_sccb->Sccb_XferState & F_AUTO_SENSE) {
 
-	  p_sccb->CdbLength = p_sccb->Save_CdbLen;
-	  for (i=0; i < 6; i++) {
-		 p_sccb->Cdb[i] = p_sccb->Save_Cdb[i];
-		 }
-	  }
+		p_sccb->CdbLength = p_sccb->Save_CdbLen;
+		for (i = 0; i < 6; i++) {
+			p_sccb->Cdb[i] = p_sccb->Save_Cdb[i];
+		}
+	}
 
-   if ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||
-	  (p_sccb->OperationCode == RESIDUAL_COMMAND)) {
+	if ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||
+	    (p_sccb->OperationCode == RESIDUAL_COMMAND)) {
 
-		 FPT_utilUpdateResidual(p_sccb);
-		 }
+		FPT_utilUpdateResidual(p_sccb);
+	}
 
-   pCurrCard->cmdCounter--;
-   if (!pCurrCard->cmdCounter) {
+	pCurrCard->cmdCounter--;
+	if (!pCurrCard->cmdCounter) {
 
-	  if (pCurrCard->globalFlags & F_GREEN_PC) {
-		 WR_HARPOON(pCurrCard->ioPort+hp_clkctrl_0,(PWR_DWN | CLKCTRL_DEFAULT));
-		 WR_HARPOON(pCurrCard->ioPort+hp_sys_ctrl, STOP_CLK);
-		 }
+		if (pCurrCard->globalFlags & F_GREEN_PC) {
+			WR_HARPOON(pCurrCard->ioPort + hp_clkctrl_0,
+				   (PWR_DWN | CLKCTRL_DEFAULT));
+			WR_HARPOON(pCurrCard->ioPort + hp_sys_ctrl, STOP_CLK);
+		}
 
-	  WR_HARPOON(pCurrCard->ioPort+hp_semaphore,
-	  (RD_HARPOON(pCurrCard->ioPort+hp_semaphore) & ~SCCB_MGR_ACTIVE));
+		WR_HARPOON(pCurrCard->ioPort + hp_semaphore,
+			   (RD_HARPOON(pCurrCard->ioPort + hp_semaphore) &
+			    ~SCCB_MGR_ACTIVE));
 
-	  }
+	}
 
-	if(pCurrCard->discQCount != 0)
-	{
-      currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
-		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
-			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-		{
+	if (pCurrCard->discQCount != 0) {
+		currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
+		if (((pCurrCard->globalFlags & F_CONLUN_IO) &&
+		     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=
+		      TAG_Q_TRYING))) {
 			pCurrCard->discQCount--;
-			pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = NULL;
-		}
-		else
-		{
-			if(p_sccb->Sccb_tag)
-			{
+			pCurrCard->discQ_Tbl[currTar_Info->
+					     LunDiscQ_Idx[p_sccb->Lun]] = NULL;
+		} else {
+			if (p_sccb->Sccb_tag) {
 				pCurrCard->discQCount--;
 				pCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;
-			}else
-			{
+			} else {
 				pCurrCard->discQCount--;
-				pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = NULL;
+				pCurrCard->discQ_Tbl[currTar_Info->
+						     LunDiscQ_Idx[0]] = NULL;
 			}
 		}
 
 	}
 
-	callback = (CALL_BK_FN)p_sccb->SccbCallback;
-   callback(p_sccb);
-   pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
-   pCurrCard->currentSCCB = NULL;
+	callback = (CALL_BK_FN) p_sccb->SccbCallback;
+	callback(p_sccb);
+	pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
+	pCurrCard->currentSCCB = NULL;
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Queue Disconnect
@@ -7202,33 +7008,32 @@ static void FPT_queueCmdComplete(struct sccb_card * pCurrCard, struct sccb * p_s
  * Description: Add SCCB to our disconnect array.
  *
  *---------------------------------------------------------------------*/
-static void FPT_queueDisconnect(struct sccb * p_sccb, unsigned char p_card)
+static void FPT_queueDisconnect(struct sccb *p_sccb, unsigned char p_card)
 {
-   struct sccb_mgr_tar_info * currTar_Info;
+	struct sccb_mgr_tar_info *currTar_Info;
 
 	currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
 
-	if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-	{
-		FPT_BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = p_sccb;
-	}
-	else
-	{
-		if (p_sccb->Sccb_tag)
-		{
-			FPT_BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] = p_sccb;
-			FPT_sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] = 0;
+	if (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+	     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {
+		FPT_BL_Card[p_card].discQ_Tbl[currTar_Info->
+					      LunDiscQ_Idx[p_sccb->Lun]] =
+		    p_sccb;
+	} else {
+		if (p_sccb->Sccb_tag) {
+			FPT_BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] =
+			    p_sccb;
+			FPT_sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] =
+			    0;
 			FPT_sccbMgrTbl[p_card][p_sccb->TargID].TarTagQ_Cnt++;
-		}else
-		{
-			FPT_BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = p_sccb;
+		} else {
+			FPT_BL_Card[p_card].discQ_Tbl[currTar_Info->
+						      LunDiscQ_Idx[0]] = p_sccb;
 		}
 	}
 	FPT_BL_Card[p_card].currentSCCB = NULL;
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Queue Flush SCCB
@@ -7237,33 +7042,35 @@ static void FPT_queueDisconnect(struct sccb * p_sccb, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)
+static void FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)
 {
-   unsigned char qtag,thisTarg;
-   struct sccb * currSCCB;
-   struct sccb_mgr_tar_info * currTar_Info;
+	unsigned char qtag, thisTarg;
+	struct sccb *currSCCB;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   currSCCB = FPT_BL_Card[p_card].currentSCCB;
-	if(currSCCB != NULL)
-	{
-	   thisTarg = (unsigned char)currSCCB->TargID;
-   	currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
+	if (currSCCB != NULL) {
+		thisTarg = (unsigned char)currSCCB->TargID;
+		currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
+
+		for (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {
 
-	   for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
+			if (FPT_BL_Card[p_card].discQ_Tbl[qtag] &&
+			    (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID ==
+			     thisTarg)) {
 
-		  if (FPT_BL_Card[p_card].discQ_Tbl[qtag] && 
-					(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
-			 {
+				FPT_BL_Card[p_card].discQ_Tbl[qtag]->
+				    HostStatus = (unsigned char)error_code;
 
-			 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (unsigned char)error_code;
-			
-			 FPT_queueCmdComplete(&FPT_BL_Card[p_card],FPT_BL_Card[p_card].discQ_Tbl[qtag], p_card);
+				FPT_queueCmdComplete(&FPT_BL_Card[p_card],
+						     FPT_BL_Card[p_card].
+						     discQ_Tbl[qtag], p_card);
 
-			 FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
-			 currTar_Info->TarTagQ_Cnt--;
+				FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+				currTar_Info->TarTagQ_Cnt--;
 
-			 }
-		  }
+			}
+		}
 	}
 
 }
@@ -7276,61 +7083,57 @@ static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)
  *
  *---------------------------------------------------------------------*/
 
-static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
-				    unsigned char error_code)
+static void FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
+				   unsigned char error_code)
 {
-   unsigned char qtag;
-   struct sccb_mgr_tar_info * currTar_Info;
+	unsigned char qtag;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
+	currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
-   for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
+	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {
 
-	  if (FPT_BL_Card[p_card].discQ_Tbl[qtag] && 
-				(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
-		 {
+		if (FPT_BL_Card[p_card].discQ_Tbl[qtag] &&
+		    (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg)) {
 
-		 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (unsigned char)error_code;
+			FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus =
+			    (unsigned char)error_code;
 
-		 FPT_queueCmdComplete(&FPT_BL_Card[p_card],FPT_BL_Card[p_card].discQ_Tbl[qtag], p_card);
+			FPT_queueCmdComplete(&FPT_BL_Card[p_card],
+					     FPT_BL_Card[p_card].
+					     discQ_Tbl[qtag], p_card);
 
-		 FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
-		 currTar_Info->TarTagQ_Cnt--;
+			FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+			currTar_Info->TarTagQ_Cnt--;
 
-		 }
-	  }
+		}
+	}
 
 }
 
-
-
-
-
-static void FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char p_card)
+static void FPT_queueAddSccb(struct sccb *p_SCCB, unsigned char p_card)
 {
-   struct sccb_mgr_tar_info * currTar_Info;
-   currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
-
-   p_SCCB->Sccb_forwardlink = NULL;
+	struct sccb_mgr_tar_info *currTar_Info;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
 
-   p_SCCB->Sccb_backlink = currTar_Info->TarSelQ_Tail;
+	p_SCCB->Sccb_forwardlink = NULL;
 
-   if (currTar_Info->TarSelQ_Cnt == 0) {
+	p_SCCB->Sccb_backlink = currTar_Info->TarSelQ_Tail;
 
-	  currTar_Info->TarSelQ_Head = p_SCCB;
-	  }
+	if (currTar_Info->TarSelQ_Cnt == 0) {
 
-   else {
+		currTar_Info->TarSelQ_Head = p_SCCB;
+	}
 
-	  currTar_Info->TarSelQ_Tail->Sccb_forwardlink = p_SCCB;
-	  }
+	else {
 
+		currTar_Info->TarSelQ_Tail->Sccb_forwardlink = p_SCCB;
+	}
 
-   currTar_Info->TarSelQ_Tail = p_SCCB;
-   currTar_Info->TarSelQ_Cnt++;
+	currTar_Info->TarSelQ_Tail = p_SCCB;
+	currTar_Info->TarSelQ_Cnt++;
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Queue Find SCCB
@@ -7340,54 +7143,56 @@ static void FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_card)
+static unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,
+				       unsigned char p_card)
 {
-   struct sccb * q_ptr;
-   struct sccb_mgr_tar_info * currTar_Info;
-
-   currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
+	struct sccb *q_ptr;
+	struct sccb_mgr_tar_info *currTar_Info;
 
-   q_ptr = currTar_Info->TarSelQ_Head;
+	currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
 
-   while(q_ptr != NULL) {
+	q_ptr = currTar_Info->TarSelQ_Head;
 
-	  if (q_ptr == p_SCCB) {
+	while (q_ptr != NULL) {
 
+		if (q_ptr == p_SCCB) {
 
-		 if (currTar_Info->TarSelQ_Head == q_ptr) {
+			if (currTar_Info->TarSelQ_Head == q_ptr) {
 
-			currTar_Info->TarSelQ_Head = q_ptr->Sccb_forwardlink;
+				currTar_Info->TarSelQ_Head =
+				    q_ptr->Sccb_forwardlink;
 			}
 
-		 if (currTar_Info->TarSelQ_Tail == q_ptr) {
+			if (currTar_Info->TarSelQ_Tail == q_ptr) {
 
-			currTar_Info->TarSelQ_Tail = q_ptr->Sccb_backlink;
+				currTar_Info->TarSelQ_Tail =
+				    q_ptr->Sccb_backlink;
 			}
 
-		 if (q_ptr->Sccb_forwardlink != NULL) {
-			q_ptr->Sccb_forwardlink->Sccb_backlink = q_ptr->Sccb_backlink;
+			if (q_ptr->Sccb_forwardlink != NULL) {
+				q_ptr->Sccb_forwardlink->Sccb_backlink =
+				    q_ptr->Sccb_backlink;
 			}
 
-		 if (q_ptr->Sccb_backlink != NULL) {
-			q_ptr->Sccb_backlink->Sccb_forwardlink = q_ptr->Sccb_forwardlink;
+			if (q_ptr->Sccb_backlink != NULL) {
+				q_ptr->Sccb_backlink->Sccb_forwardlink =
+				    q_ptr->Sccb_forwardlink;
 			}
 
-		 currTar_Info->TarSelQ_Cnt--;
+			currTar_Info->TarSelQ_Cnt--;
 
-		 return(1);
-		 }
-
-	  else {
-		 q_ptr = q_ptr->Sccb_forwardlink;
-		 }
-	  }
+			return (1);
+		}
 
+		else {
+			q_ptr = q_ptr->Sccb_forwardlink;
+		}
+	}
 
-   return(0);
+	return (0);
 
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Utility Update Residual Count
@@ -7401,48 +7206,47 @@ static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_car
  *
  *---------------------------------------------------------------------*/
 
-static void  FPT_utilUpdateResidual(struct sccb * p_SCCB)
+static void FPT_utilUpdateResidual(struct sccb *p_SCCB)
 {
-   unsigned long partial_cnt;
-   unsigned int  sg_index;
-   unsigned long *sg_ptr;
+	unsigned long partial_cnt;
+	unsigned int sg_index;
+	unsigned long *sg_ptr;
 
-   if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {
+	if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {
 
-	  p_SCCB->DataLength = 0x0000;
-	  }
+		p_SCCB->DataLength = 0x0000;
+	}
 
-   else if (p_SCCB->Sccb_XferState & F_SG_XFER) {
+	else if (p_SCCB->Sccb_XferState & F_SG_XFER) {
 
-		 partial_cnt = 0x0000;
+		partial_cnt = 0x0000;
 
-		 sg_index = p_SCCB->Sccb_sgseg;
+		sg_index = p_SCCB->Sccb_sgseg;
 
-		 sg_ptr = (unsigned long *)p_SCCB->DataPointer;
+		sg_ptr = (unsigned long *)p_SCCB->DataPointer;
 
-		 if (p_SCCB->Sccb_SGoffset) {
+		if (p_SCCB->Sccb_SGoffset) {
 
 			partial_cnt = p_SCCB->Sccb_SGoffset;
 			sg_index++;
-			}
+		}
 
-		 while ( ((unsigned long)sg_index * (unsigned long)SG_ELEMENT_SIZE) <
-			p_SCCB->DataLength ) {
+		while (((unsigned long)sg_index *
+			(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {
 
-			partial_cnt += *(sg_ptr+(sg_index * 2));
+			partial_cnt += *(sg_ptr + (sg_index * 2));
 			sg_index++;
-			}
+		}
 
-		 p_SCCB->DataLength = partial_cnt;
-		 }
+		p_SCCB->DataLength = partial_cnt;
+	}
 
-	  else {
+	else {
 
-		 p_SCCB->DataLength -= p_SCCB->Sccb_ATC;
-		 }
+		p_SCCB->DataLength -= p_SCCB->Sccb_ATC;
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Wait 1 Second
@@ -7453,21 +7257,20 @@ static void  FPT_utilUpdateResidual(struct sccb * p_SCCB)
 
 static void FPT_Wait1Second(unsigned long p_port)
 {
-   unsigned char i;
+	unsigned char i;
 
-   for(i=0; i < 4; i++) {
+	for (i = 0; i < 4; i++) {
 
-	  FPT_Wait(p_port, TO_250ms);
+		FPT_Wait(p_port, TO_250ms);
 
-	  if ((RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST))
-		 break;
+		if ((RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST))
+			break;
 
-	  if((RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL))
-		 break;
-	  }
+		if ((RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL))
+			break;
+	}
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: FPT_Wait
@@ -7478,43 +7281,41 @@ static void FPT_Wait1Second(unsigned long p_port)
 
 static void FPT_Wait(unsigned long p_port, unsigned char p_delay)
 {
-   unsigned char old_timer;
-   unsigned char green_flag;
+	unsigned char old_timer;
+	unsigned char green_flag;
 
-   old_timer = RD_HARPOON(p_port+hp_seltimeout);
+	old_timer = RD_HARPOON(p_port + hp_seltimeout);
 
-   green_flag=RD_HARPOON(p_port+hp_clkctrl_0);
-   WR_HARPOON(p_port+hp_clkctrl_0, CLKCTRL_DEFAULT);
+	green_flag = RD_HARPOON(p_port + hp_clkctrl_0);
+	WR_HARPOON(p_port + hp_clkctrl_0, CLKCTRL_DEFAULT);
 
-   WR_HARPOON(p_port+hp_seltimeout,p_delay);
-   WRW_HARPOON((p_port+hp_intstat), TIMEOUT);
-   WRW_HARPOON((p_port+hp_intena), (FPT_default_intena & ~TIMEOUT));
+	WR_HARPOON(p_port + hp_seltimeout, p_delay);
+	WRW_HARPOON((p_port + hp_intstat), TIMEOUT);
+	WRW_HARPOON((p_port + hp_intena), (FPT_default_intena & ~TIMEOUT));
 
+	WR_HARPOON(p_port + hp_portctrl_0,
+		   (RD_HARPOON(p_port + hp_portctrl_0) | START_TO));
 
-   WR_HARPOON(p_port+hp_portctrl_0,
-	  (RD_HARPOON(p_port+hp_portctrl_0) | START_TO));
+	while (!(RDW_HARPOON((p_port + hp_intstat)) & TIMEOUT)) {
 
-   while (!(RDW_HARPOON((p_port+hp_intstat)) & TIMEOUT)) {
+		if ((RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST))
+			break;
 
-	  if ((RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST))
-		 break;
-
-	  if ((RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL))
-		 break;
-	  }
+		if ((RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL))
+			break;
+	}
 
-   WR_HARPOON(p_port+hp_portctrl_0,
-	  (RD_HARPOON(p_port+hp_portctrl_0) & ~START_TO));
+	WR_HARPOON(p_port + hp_portctrl_0,
+		   (RD_HARPOON(p_port + hp_portctrl_0) & ~START_TO));
 
-   WRW_HARPOON((p_port+hp_intstat), TIMEOUT);
-   WRW_HARPOON((p_port+hp_intena), FPT_default_intena);
+	WRW_HARPOON((p_port + hp_intstat), TIMEOUT);
+	WRW_HARPOON((p_port + hp_intena), FPT_default_intena);
 
-   WR_HARPOON(p_port+hp_clkctrl_0,green_flag);
+	WR_HARPOON(p_port + hp_clkctrl_0, green_flag);
 
-   WR_HARPOON(p_port+hp_seltimeout,old_timer);
+	WR_HARPOON(p_port + hp_seltimeout, old_timer);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Enable/Disable Write to EEPROM
@@ -7524,26 +7325,26 @@ static void FPT_Wait(unsigned long p_port, unsigned char p_delay)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWriteOnOff(unsigned long p_port,unsigned char p_mode)
+static void FPT_utilEEWriteOnOff(unsigned long p_port, unsigned char p_mode)
 {
-   unsigned char ee_value;
-
-   ee_value = (unsigned char)(RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H));
+	unsigned char ee_value;
 
-   if (p_mode)
+	ee_value =
+	    (unsigned char)(RD_HARPOON(p_port + hp_ee_ctrl) &
+			    (EXT_ARB_ACK | SCSI_TERM_ENA_H));
 
-	  FPT_utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);
+	if (p_mode)
 
-   else
+		FPT_utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);
 
+	else
 
-	  FPT_utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);
+		FPT_utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);
 
-   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS)); /*Turn off CS */
-   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);       /*Turn off Master Select */
+	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));	/*Turn off CS */
+	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);	/*Turn off Master Select */
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Write EEPROM
@@ -7553,46 +7354,46 @@ static void FPT_utilEEWriteOnOff(unsigned long p_port,unsigned char p_mode)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data, unsigned short ee_addr)
+static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data,
+			    unsigned short ee_addr)
 {
 
-   unsigned char ee_value;
-   unsigned short i;
-
-   ee_value = (unsigned char)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
-		   (SEE_MS | SEE_CS));
-
-
+	unsigned char ee_value;
+	unsigned short i;
 
-   FPT_utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);
+	ee_value =
+	    (unsigned
+	     char)((RD_HARPOON(p_port + hp_ee_ctrl) &
+		    (EXT_ARB_ACK | SCSI_TERM_ENA_H)) | (SEE_MS | SEE_CS));
 
+	FPT_utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);
 
-   ee_value |= (SEE_MS + SEE_CS);
+	ee_value |= (SEE_MS + SEE_CS);
 
-   for(i = 0x8000; i != 0; i>>=1) {
+	for (i = 0x8000; i != 0; i >>= 1) {
 
-	  if (i & ee_data)
-	 ee_value |= SEE_DO;
-	  else
-	 ee_value &= ~SEE_DO;
-
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value |= SEE_CLK;          /* Clock  data! */
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value &= ~SEE_CLK;
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  }
-   ee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);
-   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS));
+		if (i & ee_data)
+			ee_value |= SEE_DO;
+		else
+			ee_value &= ~SEE_DO;
+
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value |= SEE_CLK;	/* Clock  data! */
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value &= ~SEE_CLK;
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+	}
+	ee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);
+	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));
 
-   FPT_Wait(p_port, TO_10ms);
+	FPT_Wait(p_port, TO_10ms);
 
-   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS | SEE_CS)); /* Set CS to EEPROM */
-   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS));       /* Turn off CS */
-   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);       /* Turn off Master Select */
+	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS | SEE_CS));	/* Set CS to EEPROM */
+	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));	/* Turn off CS */
+	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);	/* Turn off Master Select */
 }
 
 /*---------------------------------------------------------------------
@@ -7604,25 +7405,25 @@ static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data, unsign
  *
  *---------------------------------------------------------------------*/
 
-static unsigned short FPT_utilEERead(unsigned long p_port, unsigned short ee_addr)
+static unsigned short FPT_utilEERead(unsigned long p_port,
+				     unsigned short ee_addr)
 {
-   unsigned short i, ee_data1, ee_data2;
+	unsigned short i, ee_data1, ee_data2;
 
 	i = 0;
 	ee_data1 = FPT_utilEEReadOrg(p_port, ee_addr);
-	do
-	{
+	do {
 		ee_data2 = FPT_utilEEReadOrg(p_port, ee_addr);
 
-		if(ee_data1 == ee_data2)
-			return(ee_data1);
+		if (ee_data1 == ee_data2)
+			return (ee_data1);
 
 		ee_data1 = ee_data2;
 		i++;
 
-	}while(i < 4);
+	} while (i < 4);
 
-	return(ee_data1);
+	return (ee_data1);
 }
 
 /*---------------------------------------------------------------------
@@ -7634,45 +7435,45 @@ static unsigned short FPT_utilEERead(unsigned long p_port, unsigned short ee_add
  *
  *---------------------------------------------------------------------*/
 
-static unsigned short FPT_utilEEReadOrg(unsigned long p_port, unsigned short ee_addr)
+static unsigned short FPT_utilEEReadOrg(unsigned long p_port,
+					unsigned short ee_addr)
 {
 
-   unsigned char ee_value;
-   unsigned short i, ee_data;
+	unsigned char ee_value;
+	unsigned short i, ee_data;
 
-   ee_value = (unsigned char)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
-		   (SEE_MS | SEE_CS));
+	ee_value =
+	    (unsigned
+	     char)((RD_HARPOON(p_port + hp_ee_ctrl) &
+		    (EXT_ARB_ACK | SCSI_TERM_ENA_H)) | (SEE_MS | SEE_CS));
 
+	FPT_utilEESendCmdAddr(p_port, EE_READ, ee_addr);
 
-   FPT_utilEESendCmdAddr(p_port, EE_READ, ee_addr);
+	ee_value |= (SEE_MS + SEE_CS);
+	ee_data = 0;
 
+	for (i = 1; i <= 16; i++) {
 
-   ee_value |= (SEE_MS + SEE_CS);
-   ee_data = 0;
+		ee_value |= SEE_CLK;	/* Clock  data! */
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value &= ~SEE_CLK;
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
 
-   for(i = 1; i <= 16; i++) {
+		ee_data <<= 1;
 
-	  ee_value |= SEE_CLK;          /* Clock  data! */
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value &= ~SEE_CLK;
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-
-	  ee_data <<= 1;
-
-	  if (RD_HARPOON(p_port+hp_ee_ctrl) & SEE_DI)
-		 ee_data |= 1;
-	  }
+		if (RD_HARPOON(p_port + hp_ee_ctrl) & SEE_DI)
+			ee_data |= 1;
+	}
 
-   ee_value &= ~(SEE_MS + SEE_CS);
-   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS)); /*Turn off CS */
-   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);   /*Turn off Master Select */
+	ee_value &= ~(SEE_MS + SEE_CS);
+	WR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));	/*Turn off CS */
+	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);	/*Turn off Master Select */
 
-   return(ee_data);
+	return (ee_data);
 }
 
-
 /*---------------------------------------------------------------------
  *
  * Function: Send EE command and Address to the EEPROM
@@ -7682,87 +7483,83 @@ static unsigned short FPT_utilEEReadOrg(unsigned long p_port, unsigned short ee_
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd, unsigned short ee_addr)
+static void FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd,
+				  unsigned short ee_addr)
 {
-   unsigned char ee_value;
-   unsigned char narrow_flg;
-
-   unsigned short i;
-
-
-   narrow_flg= (unsigned char)(RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD);
-
+	unsigned char ee_value;
+	unsigned char narrow_flg;
 
-   ee_value = SEE_MS;
-   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	unsigned short i;
 
-   ee_value |= SEE_CS;                             /* Set CS to EEPROM */
-   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	narrow_flg =
+	    (unsigned char)(RD_HARPOON(p_port + hp_page_ctrl) &
+			    NARROW_SCSI_CARD);
 
+	ee_value = SEE_MS;
+	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
 
-   for(i = 0x04; i != 0; i>>=1) {
+	ee_value |= SEE_CS;	/* Set CS to EEPROM */
+	WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
 
-	  if (i & ee_cmd)
-		 ee_value |= SEE_DO;
-	  else
-		 ee_value &= ~SEE_DO;
-
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value |= SEE_CLK;                         /* Clock  data! */
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value &= ~SEE_CLK;
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  }
-
-
-   if (narrow_flg)
-	  i = 0x0080;
-
-   else
-	  i = 0x0200;
+	for (i = 0x04; i != 0; i >>= 1) {
 
+		if (i & ee_cmd)
+			ee_value |= SEE_DO;
+		else
+			ee_value &= ~SEE_DO;
+
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value |= SEE_CLK;	/* Clock  data! */
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value &= ~SEE_CLK;
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+	}
 
-   while (i != 0) {
+	if (narrow_flg)
+		i = 0x0080;
 
-	  if (i & ee_addr)
-		 ee_value |= SEE_DO;
-	  else
-		 ee_value &= ~SEE_DO;
+	else
+		i = 0x0200;
 
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value |= SEE_CLK;                         /* Clock  data! */
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  ee_value &= ~SEE_CLK;
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
-	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	while (i != 0) {
 
-	  i >>= 1;
-	  }
+		if (i & ee_addr)
+			ee_value |= SEE_DO;
+		else
+			ee_value &= ~SEE_DO;
+
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value |= SEE_CLK;	/* Clock  data! */
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		ee_value &= ~SEE_CLK;
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+		WR_HARPOON(p_port + hp_ee_ctrl, ee_value);
+
+		i >>= 1;
+	}
 }
 
 static unsigned short FPT_CalcCrc16(unsigned char buffer[])
 {
-   unsigned short crc=0;
-	int i,j;
-   unsigned short ch;
-   for (i=0; i < ID_STRING_LENGTH; i++)
-   {
-      ch = (unsigned short) buffer[i];
-	   for(j=0; j < 8; j++)
-	   {
-		   if ((crc ^ ch) & 1)
-            crc = (crc >> 1) ^ CRCMASK;
-		   else
-            crc >>= 1;
-		   ch >>= 1;
-	   }
-   }
-	return(crc);
+	unsigned short crc = 0;
+	int i, j;
+	unsigned short ch;
+	for (i = 0; i < ID_STRING_LENGTH; i++) {
+		ch = (unsigned short)buffer[i];
+		for (j = 0; j < 8; j++) {
+			if ((crc ^ ch) & 1)
+				crc = (crc >> 1) ^ CRCMASK;
+			else
+				crc >>= 1;
+			ch >>= 1;
+		}
+	}
+	return (crc);
 }
 
 static unsigned char FPT_CalcLrc(unsigned char buffer[])
@@ -7770,13 +7567,11 @@ static unsigned char FPT_CalcLrc(unsigned char buffer[])
 	int i;
 	unsigned char lrc;
 	lrc = 0;
-	for(i = 0; i < ID_STRING_LENGTH; i++)
+	for (i = 0; i < ID_STRING_LENGTH; i++)
 		lrc ^= buffer[i];
-	return(lrc);
+	return (lrc);
 }
 
-
-
 /*
   The following inline definitions avoid type conflicts.
 */
@@ -7784,51 +7579,49 @@ static unsigned char FPT_CalcLrc(unsigned char buffer[])
 static inline unsigned char
 FlashPoint__ProbeHostAdapter(struct FlashPoint_Info *FlashPointInfo)
 {
-  return FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *) FlashPointInfo);
+	return FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *)
+					   FlashPointInfo);
 }
 
-
 static inline FlashPoint_CardHandle_T
 FlashPoint__HardwareResetHostAdapter(struct FlashPoint_Info *FlashPointInfo)
 {
-  return FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *) FlashPointInfo);
+	return FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *)
+						   FlashPointInfo);
 }
 
 static inline void
 FlashPoint__ReleaseHostAdapter(FlashPoint_CardHandle_T CardHandle)
 {
-  FlashPoint_ReleaseHostAdapter(CardHandle);
+	FlashPoint_ReleaseHostAdapter(CardHandle);
 }
 
-
 static inline void
-FlashPoint__StartCCB(FlashPoint_CardHandle_T CardHandle, struct BusLogic_CCB *CCB)
+FlashPoint__StartCCB(FlashPoint_CardHandle_T CardHandle,
+		     struct BusLogic_CCB *CCB)
 {
-  FlashPoint_StartCCB(CardHandle, (struct sccb *) CCB);
+	FlashPoint_StartCCB(CardHandle, (struct sccb *)CCB);
 }
 
-
 static inline void
-FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle, struct BusLogic_CCB *CCB)
+FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle,
+		     struct BusLogic_CCB *CCB)
 {
-  FlashPoint_AbortCCB(CardHandle, (struct sccb *) CCB);
+	FlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);
 }
 
-
 static inline boolean
 FlashPoint__InterruptPending(FlashPoint_CardHandle_T CardHandle)
 {
-  return FlashPoint_InterruptPending(CardHandle);
+	return FlashPoint_InterruptPending(CardHandle);
 }
 
-
 static inline int
 FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
 {
-  return FlashPoint_HandleInterrupt(CardHandle);
+	return FlashPoint_HandleInterrupt(CardHandle);
 }
 
-
 #define FlashPoint_ProbeHostAdapter	    FlashPoint__ProbeHostAdapter
 #define FlashPoint_HardwareResetHostAdapter FlashPoint__HardwareResetHostAdapter
 #define FlashPoint_ReleaseHostAdapter	    FlashPoint__ReleaseHostAdapter
@@ -7837,9 +7630,7 @@ FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
 #define FlashPoint_InterruptPending	    FlashPoint__InterruptPending
 #define FlashPoint_HandleInterrupt	    FlashPoint__HandleInterrupt
 
-
-#else  /* CONFIG_SCSI_OMIT_FLASHPOINT */
-
+#else				/* CONFIG_SCSI_OMIT_FLASHPOINT */
 
 /*
   Define prototypes for the FlashPoint SCCB Manager Functions.
@@ -7847,12 +7638,11 @@ FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
 
 extern unsigned char FlashPoint_ProbeHostAdapter(struct FlashPoint_Info *);
 extern FlashPoint_CardHandle_T
-       FlashPoint_HardwareResetHostAdapter(struct FlashPoint_Info *);
+FlashPoint_HardwareResetHostAdapter(struct FlashPoint_Info *);
 extern void FlashPoint_StartCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
 extern int FlashPoint_AbortCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
 extern boolean FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
 extern int FlashPoint_HandleInterrupt(FlashPoint_CardHandle_T);
 extern void FlashPoint_ReleaseHostAdapter(FlashPoint_CardHandle_T);
 
-
-#endif /* CONFIG_SCSI_OMIT_FLASHPOINT */
+#endif				/* CONFIG_SCSI_OMIT_FLASHPOINT */

commit 13e6851aa1e8f7db0e9f0cc8567394a9fe451357
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:34 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: untypedef struct SCCBcard
    
    * struct SCCBcard => struct sccb_card
    * PSCCBcard => struct sccb_card *
    * SCCBCARD => struct sccb_card
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 696f31c5df76..37ee2cb60d20 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -304,7 +304,7 @@ struct nvram_info {
 #define	MODEL_DW		4
 
 
-typedef struct SCCBcard {
+struct sccb_card {
    struct sccb * currentSCCB;
    struct sccb_mgr_info * cardInfo;
 
@@ -320,9 +320,8 @@ typedef struct SCCBcard {
    struct nvram_info * pNvRamInfo;
    struct sccb * discQ_Tbl[QUEUE_DEPTH];
       
-}SCCBCARD;
+};
 
-typedef struct SCCBcard *PSCCBcard;
 
 
 #define F_TAG_STARTED		0x01
@@ -968,7 +967,7 @@ typedef struct SCCBscam_info {
 
 static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag);
 static void  FPT_ssel(unsigned long port, unsigned char p_card);
-static void  FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCard);
+static void  FPT_sres(unsigned long port, unsigned char p_card, struct sccb_card * pCurrCard);
 static void  FPT_shandem(unsigned long port, unsigned char p_card,struct sccb * pCurrSCCB);
 static void  FPT_stsyncn(unsigned long port, unsigned char p_card);
 static void  FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset);
@@ -993,11 +992,11 @@ static void  FPT_stwidn(unsigned long port, unsigned char p_card);
 static void  FPT_siwidr(unsigned long port, unsigned char width);
 
 
-static void  FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card);
+static void  FPT_queueSelectFail(struct sccb_card * pCurrCard, unsigned char p_card);
 static void  FPT_queueDisconnect(struct sccb * p_SCCB, unsigned char p_card);
-static void  FPT_queueCmdComplete(PSCCBcard pCurrCard, struct sccb * p_SCCB,
+static void  FPT_queueCmdComplete(struct sccb_card * pCurrCard, struct sccb * p_SCCB,
 				  unsigned char p_card);
-static void  FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card);
+static void  FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_card);
 static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);
 static void  FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char card);
 static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_card);
@@ -1038,7 +1037,7 @@ static void  FPT_DiagEEPROM(unsigned long p_port);
 
 
 
-static void  FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard);
+static void  FPT_dataXferProcessor(unsigned long port, struct sccb_card * pCurrCard);
 static void  FPT_busMstrSGDataXferStart(unsigned long port, struct sccb * pCurrSCCB);
 static void  FPT_busMstrDataXferStart(unsigned long port, struct sccb * pCurrSCCB);
 static void  FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB);
@@ -1046,10 +1045,10 @@ static void  FPT_hostDataXferRestart(struct sccb * currSCCB);
 
 
 static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
-				 PSCCBcard pCurrCard, unsigned short p_int);
+				 struct sccb_card * pCurrCard, unsigned short p_int);
 
 static void  FPT_SccbMgrTableInitAll(void);
-static void  FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, unsigned char p_card);
+static void  FPT_SccbMgrTableInitCard(struct sccb_card * pCurrCard, unsigned char p_card);
 static void  FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char target);
 
 
@@ -1080,7 +1079,7 @@ static void  FPT_autoLoadDefaultMap(unsigned long p_port);
 
 
 static struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
-static SCCBCARD FPT_BL_Card[MAX_CARDS] = { { 0 } };
+static struct sccb_card FPT_BL_Card[MAX_CARDS] = { { 0 } };
 static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
 static struct nvram_info FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
 
@@ -1385,7 +1384,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info * pCardInfo)
 
 static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info * pCardInfo)
 {
-   PSCCBcard CurrCard = NULL;
+   struct sccb_card * CurrCard = NULL;
 	struct nvram_info * pCurrNvRam;
    unsigned char i,j,thisCard, ScamFlg;
    unsigned short temp,sync_bit_map,id;
@@ -1573,7 +1572,7 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 	unsigned long *pScamTbl;
 	struct nvram_info * pCurrNvRam;
 
-	pCurrNvRam = ((PSCCBcard)pCurrCard)->pNvRamInfo;
+	pCurrNvRam = ((struct sccb_card *)pCurrCard)->pNvRamInfo;
 
 	if(pCurrNvRam){
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);
@@ -1595,7 +1594,7 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 		}
 
 	}else{
-		FPT_WrStack(((PSCCBcard)pCurrCard)->ioPort, 0, 0);
+		FPT_WrStack(((struct sccb_card *)pCurrCard)->ioPort, 0, 0);
 	}
 }
 
@@ -1670,8 +1669,8 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 	struct sccb * pSaveSccb;
    CALL_BK_FN callback;
 
-   thisCard = ((PSCCBcard) pCurrCard)->cardIndex;
-   ioport = ((PSCCBcard) pCurrCard)->ioPort;
+   thisCard = ((struct sccb_card *) pCurrCard)->cardIndex;
+   ioport = ((struct sccb_card *) pCurrCard)->ioPort;
 
 	if((p_Sccb->TargID > MAX_SCSI_TAR) || (p_Sccb->Lun > MAX_LUN))
 	{
@@ -1688,19 +1687,19 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
    FPT_sinits(p_Sccb,thisCard);
 
 
-   if (!((PSCCBcard) pCurrCard)->cmdCounter)
+   if (!((struct sccb_card *) pCurrCard)->cmdCounter)
       {
       WR_HARPOON(ioport+hp_semaphore, (RD_HARPOON(ioport+hp_semaphore)
          | SCCB_MGR_ACTIVE));
 
-      if (((PSCCBcard) pCurrCard)->globalFlags & F_GREEN_PC)
+      if (((struct sccb_card *) pCurrCard)->globalFlags & F_GREEN_PC)
          {
 		 WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
 		 WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
          }
       }
 
-   ((PSCCBcard)pCurrCard)->cmdCounter++;
+   ((struct sccb_card *)pCurrCard)->cmdCounter++;
 
    if (RD_HARPOON(ioport+hp_semaphore) & BIOS_IN_USE) {
 
@@ -1708,10 +1707,10 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
          | TICKLE_ME));
 		if(p_Sccb->OperationCode == RESET_COMMAND)
 			{
-				pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
-				((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+				pSaveSccb = ((struct sccb_card *) pCurrCard)->currentSCCB;
+				((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
 				FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-				((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
+				((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSccb;
 			}
 		else
 			{
@@ -1723,10 +1722,10 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 
 			if(p_Sccb->OperationCode == RESET_COMMAND)
 				{
-					pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
-					((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+					pSaveSccb = ((struct sccb_card *) pCurrCard)->currentSCCB;
+					((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
 					FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-					((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
+					((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSccb;
 				}
 			else
 				{
@@ -1738,17 +1737,17 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 
       MDISABLE_INT(ioport);
 
-		if((((PSCCBcard) pCurrCard)->globalFlags & F_CONLUN_IO) && 
+		if((((struct sccb_card *) pCurrCard)->globalFlags & F_CONLUN_IO) &&
 			((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
 			lun = p_Sccb->Lun;
 		else
 			lun = 0;
-      if ((((PSCCBcard) pCurrCard)->currentSCCB == NULL) &&
+      if ((((struct sccb_card *) pCurrCard)->currentSCCB == NULL) &&
          (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0) &&
          (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
          == 0)) {
 
-            ((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+            ((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
 	    FPT_ssel(p_Sccb->SccbIOPort,thisCard);
          }
 
@@ -1756,10 +1755,10 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 
 			if(p_Sccb->OperationCode == RESET_COMMAND)
 				{
-					pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
-					((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+					pSaveSccb = ((struct sccb_card *) pCurrCard)->currentSCCB;
+					((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
 					FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
-					((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
+					((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSccb;
 				}
 			else
 				{
@@ -1794,9 +1793,9 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 	struct sccb_mgr_tar_info * currTar_Info;
 
 
-	ioport = ((PSCCBcard) pCurrCard)->ioPort;
+	ioport = ((struct sccb_card *) pCurrCard)->ioPort;
 
-	thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
+	thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
 
 	if (!(RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE))
 	{
@@ -1804,9 +1803,9 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 		if (FPT_queueFindSccb(p_Sccb,thisCard))
 		{
 
-			((PSCCBcard)pCurrCard)->cmdCounter--;
+			((struct sccb_card *)pCurrCard)->cmdCounter--;
 
-			if (!((PSCCBcard)pCurrCard)->cmdCounter)
+			if (!((struct sccb_card *)pCurrCard)->cmdCounter)
 				WR_HARPOON(ioport+hp_semaphore,(RD_HARPOON(ioport+hp_semaphore)
 					& (unsigned char)(~(SCCB_MGR_ACTIVE | TICKLE_ME)) ));
 
@@ -1819,7 +1818,7 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 
 		else
 		{
-			if (((PSCCBcard)pCurrCard)->currentSCCB == p_Sccb)
+			if (((struct sccb_card *)pCurrCard)->currentSCCB == p_Sccb)
 			{
 				p_Sccb->SccbStatus = SCCB_ABORT;
 				return(0);
@@ -1835,23 +1834,23 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 				if(p_Sccb->Sccb_tag)
 				{
 					MDISABLE_INT(ioport);
-					if (((PSCCBcard) pCurrCard)->discQ_Tbl[p_Sccb->Sccb_tag]==p_Sccb)
+					if (((struct sccb_card *) pCurrCard)->discQ_Tbl[p_Sccb->Sccb_tag]==p_Sccb)
 					{
 						p_Sccb->SccbStatus = SCCB_ABORT;
 						p_Sccb->Sccb_scsistat = ABORT_ST;
 						p_Sccb->Sccb_scsimsg = SMABORT_TAG;
 
-						if(((PSCCBcard) pCurrCard)->currentSCCB == NULL)
+						if(((struct sccb_card *) pCurrCard)->currentSCCB == NULL)
 						{
-							((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+							((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
 							FPT_ssel(ioport, thisCard);
 						}
 						else
 						{
-							pSaveSCCB = ((PSCCBcard) pCurrCard)->currentSCCB;
-							((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-							FPT_queueSelectFail((PSCCBcard) pCurrCard, thisCard);
-							((PSCCBcard) pCurrCard)->currentSCCB = pSaveSCCB;
+							pSaveSCCB = ((struct sccb_card *) pCurrCard)->currentSCCB;
+							((struct sccb_card *) pCurrCard)->currentSCCB = p_Sccb;
+							FPT_queueSelectFail((struct sccb_card *) pCurrCard, thisCard);
+							((struct sccb_card *) pCurrCard)->currentSCCB = pSaveSCCB;
 						}
 					}
 					MENABLE_INT(ioport);
@@ -1887,7 +1886,7 @@ static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
 {
    unsigned long ioport;
 
-   ioport = ((PSCCBcard)pCurrCard)->ioPort;
+   ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
    if (RD_HARPOON(ioport+hp_int_status) & INT_ASSERTED)
    {
@@ -1918,8 +1917,8 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
    unsigned char i, target;
    unsigned long ioport;
 
-   thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
-   ioport = ((PSCCBcard)pCurrCard)->ioPort;
+   thisCard = ((struct sccb_card *)pCurrCard)->cardIndex;
+   ioport = ((struct sccb_card *)pCurrCard)->ioPort;
 
    MDISABLE_INT(ioport);
 
@@ -1934,10 +1933,10 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 	  bm_status)
      {
 
-       currSCCB = ((PSCCBcard)pCurrCard)->currentSCCB;
+       currSCCB = ((struct sccb_card *)pCurrCard)->currentSCCB;
 
       if (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {
-         result = FPT_SccbMgr_bad_isr(ioport,thisCard,((PSCCBcard)pCurrCard),hp_int);
+         result = FPT_SccbMgr_bad_isr(ioport,thisCard,((struct sccb_card *)pCurrCard),hp_int);
          WRW_HARPOON((ioport+hp_intstat), (FIFO | TIMEOUT | RESET | SCAM_SEL));
          bm_status = 0;
 
@@ -1960,7 +1959,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 	   while (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL))) ;
 	 }
 
-         if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
+         if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
 
             FPT_phaseChkFifo(ioport, thisCard);
 
@@ -1978,7 +1977,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
       else if (hp_int & ITAR_DISC)
          {
 
-         if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
+         if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
 
             FPT_phaseChkFifo(ioport, thisCard);
 
@@ -2019,7 +2018,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
          WRW_HARPOON((ioport+hp_intstat), (BUS_FREE | ITAR_DISC));
 
 
-         ((PSCCBcard)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
+         ((struct sccb_card *)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
 
       	}
 
@@ -2030,7 +2029,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 
          if (RDW_HARPOON((ioport+hp_intstat)) & ITAR_DISC)
 		      {
-            if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
+            if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
 			      {
                FPT_phaseChkFifo(ioport, thisCard);
                }
@@ -2047,7 +2046,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
             FPT_queueDisconnect(currSCCB,thisCard);
             }
 
-         FPT_sres(ioport,thisCard,((PSCCBcard)pCurrCard));
+         FPT_sres(ioport,thisCard,((struct sccb_card *)pCurrCard));
          FPT_phaseDecode(ioport,thisCard);
 
          }
@@ -2101,7 +2100,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 
          WRW_HARPOON((ioport+hp_intstat), BUS_FREE);
 
-        	if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
+        	if (((struct sccb_card *)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
 
            	FPT_hostDataXferAbort(ioport,thisCard,currSCCB);
 				}
@@ -2113,24 +2112,24 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
       else if (hp_int & ITICKLE) {
 
          WRW_HARPOON((ioport+hp_intstat), ITICKLE);
-         ((PSCCBcard)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
+         ((struct sccb_card *)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
          }
 
 
 
-      if (((PSCCBcard)pCurrCard)->globalFlags & F_NEW_SCCB_CMD) {
+      if (((struct sccb_card *)pCurrCard)->globalFlags & F_NEW_SCCB_CMD) {
 
 
-         ((PSCCBcard)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
+         ((struct sccb_card *)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
 
 
-         if (((PSCCBcard)pCurrCard)->currentSCCB == NULL) {
+         if (((struct sccb_card *)pCurrCard)->currentSCCB == NULL) {
 
-            FPT_queueSearchSelect(((PSCCBcard)pCurrCard),thisCard);
+            FPT_queueSearchSelect(((struct sccb_card *)pCurrCard),thisCard);
             }
 
-         if (((PSCCBcard)pCurrCard)->currentSCCB != NULL) {
-            ((PSCCBcard)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
+         if (((struct sccb_card *)pCurrCard)->currentSCCB != NULL) {
+            ((struct sccb_card *)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
             FPT_ssel(ioport,thisCard);
             }
 
@@ -2156,7 +2155,7 @@ static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
  *
  *---------------------------------------------------------------------*/
 static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
-				 PSCCBcard pCurrCard, unsigned short p_int)
+				 struct sccb_card * pCurrCard, unsigned short p_int)
 {
    unsigned char temp, ScamFlg;
    struct sccb_mgr_tar_info * currTar_Info;
@@ -2332,7 +2331,7 @@ static void FPT_SccbMgrTableInitAll()
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, unsigned char p_card)
+static void FPT_SccbMgrTableInitCard(struct sccb_card * pCurrCard, unsigned char p_card)
 {
    unsigned char scsiID, qtag;
 
@@ -2492,7 +2491,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
    unsigned char auto_loaded, i, target, *theCCB;
 
    unsigned long cdb_reg;
-   PSCCBcard CurrCard;
+   struct sccb_card * CurrCard;
    struct sccb * currSCCB;
    struct sccb_mgr_tar_info * currTar_Info;
    unsigned char lastTag, lun;
@@ -2797,7 +2796,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCard)
+static void FPT_sres(unsigned long port, unsigned char p_card, struct sccb_card * pCurrCard)
 {
 
    unsigned char our_target, message, lun = 0, tag, msgRetryCount;
@@ -3110,7 +3109,7 @@ static void FPT_SendMsg(unsigned long port, unsigned char message)
 static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p_card)
 {
 	struct sccb * currSCCB;
-	PSCCBcard CurrCard;
+	struct sccb_card * CurrCard;
 	struct sccb_mgr_tar_info * currTar_Info;
 
 	CurrCard = &FPT_BL_Card[p_card];
@@ -3909,7 +3908,7 @@ static void FPT_sresb(unsigned long port, unsigned char p_card)
  * Description: Setup for the Auto Sense command.
  *
  *---------------------------------------------------------------------*/
-static void FPT_ssenss(PSCCBcard pCurrCard)
+static void FPT_ssenss(struct sccb_card * pCurrCard)
 {
    unsigned char i;
    struct sccb * currSCCB;
@@ -5151,7 +5150,7 @@ static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
  *              
  *---------------------------------------------------------------------*/
 
-static void FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard)
+static void FPT_dataXferProcessor(unsigned long port, struct sccb_card * pCurrCard)
 {
    struct sccb * currSCCB;
 
@@ -5699,7 +5698,7 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned cha
    unsigned long p_port;
 
    unsigned char i,k,ScamFlg ;
-   PSCCBcard currCard;
+   struct sccb_card * currCard;
 	struct nvram_info * pCurrNvRam;
 
    currCard = &FPT_BL_Card[p_card];
@@ -6931,7 +6930,7 @@ static void FPT_DiagEEPROM(unsigned long p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
+static void FPT_queueSearchSelect(struct sccb_card * pCurrCard, unsigned char p_card)
 {
    unsigned char scan_ptr, lun;
    struct sccb_mgr_tar_info * currTar_Info;
@@ -7062,7 +7061,7 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card)
+static void FPT_queueSelectFail(struct sccb_card * pCurrCard, unsigned char p_card)
 {
    unsigned char thisTarg;
    struct sccb_mgr_tar_info * currTar_Info;
@@ -7101,7 +7100,7 @@ static void FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueCmdComplete(PSCCBcard pCurrCard, struct sccb * p_sccb,
+static void FPT_queueCmdComplete(struct sccb_card * pCurrCard, struct sccb * p_sccb,
 				 unsigned char p_card)
 {
 

commit 68d0c1ae66413ef553b1132269129003cea668ed
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:33 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: untypedef struct NVRAMInfo
    
    * struct NVRAMInfo => struct nvram_info
    * PNVRamInfo => struct nvram_info *
    * NVRAMINFO => struct nvram_info
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 895e4ff7be1d..696f31c5df76 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -285,7 +285,7 @@ struct sccb_mgr_tar_info {
    unsigned char    TarLUNBusy[MAX_LUN];
 };
 
-typedef struct NVRAMInfo {
+struct nvram_info {
 	unsigned char		niModel;								/* Model No. of card */
 	unsigned char		niCardNo;							/* Card no. */
 	unsigned long		niBaseAddr;							/* Port Address of card */
@@ -295,9 +295,8 @@ typedef struct NVRAMInfo {
 	unsigned char		niAdapId;							/* Host Adapter ID - Byte 24 of eerpom map */
 	unsigned char		niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
 	unsigned char		niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
-}NVRAMINFO;
+};
 
-typedef NVRAMINFO *PNVRamInfo;
 
 #define	MODEL_LT		1
 #define	MODEL_DL		2
@@ -318,7 +317,7 @@ typedef struct SCCBcard {
    unsigned char scanIndex;
    unsigned char globalFlags;
    unsigned char ourId;
-   PNVRamInfo pNvRamInfo;
+   struct nvram_info * pNvRamInfo;
    struct sccb * discQ_Tbl[QUEUE_DEPTH];
       
 }SCCBCARD;
@@ -987,7 +986,7 @@ static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg
 				    unsigned char error_code);
 
 static void  FPT_sinits(struct sccb * p_sccb, unsigned char p_card);
-static void  FPT_RNVRamData(PNVRamInfo pNvRamInfo);
+static void  FPT_RNVRamData(struct nvram_info * pNvRamInfo);
 
 static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card);
 static void  FPT_stwidn(unsigned long port, unsigned char p_card);
@@ -1083,7 +1082,7 @@ static void  FPT_autoLoadDefaultMap(unsigned long p_port);
 static struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
 static SCCBCARD FPT_BL_Card[MAX_CARDS] = { { 0 } };
 static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
-static NVRAMINFO FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
+static struct nvram_info FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
 
 
 static unsigned char FPT_mbCards = 0;
@@ -1113,7 +1112,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info * pCardInfo)
    unsigned char i,j,id,ScamFlg;
    unsigned short temp,temp2,temp3,temp4,temp5,temp6;
    unsigned long ioport;
-	PNVRamInfo pCurrNvRam;
+	struct nvram_info * pCurrNvRam;
 
    ioport = pCardInfo->si_baseaddr;
 
@@ -1387,7 +1386,7 @@ static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info * pCardInfo)
 static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info * pCardInfo)
 {
    PSCCBcard CurrCard = NULL;
-	PNVRamInfo pCurrNvRam;
+	struct nvram_info * pCurrNvRam;
    unsigned char i,j,thisCard, ScamFlg;
    unsigned short temp,sync_bit_map,id;
    unsigned long ioport;
@@ -1572,7 +1571,7 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 	unsigned long regOffset;
 	unsigned long scamData;
 	unsigned long *pScamTbl;
-	PNVRamInfo pCurrNvRam;
+	struct nvram_info * pCurrNvRam;
 
 	pCurrNvRam = ((PSCCBcard)pCurrCard)->pNvRamInfo;
 
@@ -1601,7 +1600,7 @@ static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 }
 
 
-static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
+static void FPT_RNVRamData(struct nvram_info * pNvRamInfo)
 {
 	unsigned char i;
 	unsigned long portBase;
@@ -2161,7 +2160,7 @@ static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_c
 {
    unsigned char temp, ScamFlg;
    struct sccb_mgr_tar_info * currTar_Info;
-   PNVRamInfo pCurrNvRam;
+   struct nvram_info * pCurrNvRam;
 
 
    if (RD_HARPOON(p_port+hp_ext_status) &
@@ -5701,7 +5700,7 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned cha
 
    unsigned char i,k,ScamFlg ;
    PSCCBcard currCard;
-	PNVRamInfo pCurrNvRam;
+	struct nvram_info * pCurrNvRam;
 
    currCard = &FPT_BL_Card[p_card];
    p_port = currCard->ioPort;
@@ -5992,7 +5991,7 @@ static void FPT_scasid(unsigned char p_card, unsigned long p_port)
 
    unsigned char i,k,scam_id;
 	unsigned char crcBytes[3];
-	PNVRamInfo pCurrNvRam;
+	struct nvram_info * pCurrNvRam;
 	unsigned short * pCrcBytes;
 
 	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
@@ -6453,7 +6452,7 @@ static void FPT_inisci(unsigned char p_card, unsigned long p_port, unsigned char
 {
    unsigned char i,k,max_id;
    unsigned short ee_data;
-	PNVRamInfo pCurrNvRam;
+	struct nvram_info * pCurrNvRam;
 
 	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
 

commit f31dc0cde69761dca05687addfd233accd393d1c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:31 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: untypedef struct SCCBMgr_tar_info
    
    * struct SCCBMgr_tar_info => struct sccb_mgr_tar_info
    * PSCCBMgr_tar_info => struct sccb_mgr_tar_info *
    * SCCBMGR_TAR_INFO => struct sccb_mgr_tar_info
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 9969fef8fd52..895e4ff7be1d 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -268,10 +268,9 @@ struct sccb {
 #define  EE_WIDE_SCSI      BIT(7)
 
 
-typedef struct SCCBMgr_tar_info *PSCCBMgr_tar_info;
 
 
-typedef struct SCCBMgr_tar_info {
+struct sccb_mgr_tar_info {
 
    struct sccb *    TarSelQ_Head;
    struct sccb *    TarSelQ_Tail;
@@ -284,7 +283,7 @@ typedef struct SCCBMgr_tar_info {
    unsigned char 	TarReserved[2];			/* for alignment */
    unsigned char 	LunDiscQ_Idx[MAX_LUN];
    unsigned char    TarLUNBusy[MAX_LUN];
-} SCCBMGR_TAR_INFO;
+};
 
 typedef struct NVRAMInfo {
 	unsigned char		niModel;								/* Model No. of card */
@@ -975,7 +974,7 @@ static void  FPT_shandem(unsigned long port, unsigned char p_card,struct sccb *
 static void  FPT_stsyncn(unsigned long port, unsigned char p_card);
 static void  FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset);
 static void  FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
-			 PSCCBMgr_tar_info currTar_Info);
+			 struct sccb_mgr_tar_info * currTar_Info);
 static void  FPT_sresb(unsigned long port, unsigned char p_card);
 static void  FPT_sxfrp(unsigned long p_port, unsigned char p_card);
 static void  FPT_schkdd(unsigned long port, unsigned char p_card);
@@ -1081,7 +1080,7 @@ static void  FPT_autoLoadDefaultMap(unsigned long p_port);
 
 
 
-static SCCBMGR_TAR_INFO FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
+static struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
 static SCCBCARD FPT_BL_Card[MAX_CARDS] = { { 0 } };
 static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
 static NVRAMINFO FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
@@ -1793,7 +1792,7 @@ static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 	CALL_BK_FN callback;
 	unsigned char TID;
 	struct sccb * pSaveSCCB;
-	PSCCBMgr_tar_info currTar_Info;
+	struct sccb_mgr_tar_info * currTar_Info;
 
 
 	ioport = ((PSCCBcard) pCurrCard)->ioPort;
@@ -2161,7 +2160,7 @@ static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_c
 				 PSCCBcard pCurrCard, unsigned short p_int)
 {
    unsigned char temp, ScamFlg;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
    PNVRamInfo pCurrNvRam;
 
 
@@ -2373,7 +2372,7 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
 {
 
 	unsigned char lun, qtag;
-	PSCCBMgr_tar_info currTar_Info;
+	struct sccb_mgr_tar_info * currTar_Info;
 
 	currTar_Info = &FPT_sccbMgrTbl[p_card][target];
 
@@ -2496,7 +2495,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
    unsigned long cdb_reg;
    PSCCBcard CurrCard;
    struct sccb * currSCCB;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
    unsigned char lastTag, lun;
 
    CurrCard = &FPT_BL_Card[p_card];
@@ -2805,7 +2804,7 @@ static void FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCa
    unsigned char our_target, message, lun = 0, tag, msgRetryCount;
 
 
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 	struct sccb * currSCCB;
 
 
@@ -3113,7 +3112,7 @@ static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p
 {
 	struct sccb * currSCCB;
 	PSCCBcard CurrCard;
-	PSCCBMgr_tar_info currTar_Info;
+	struct sccb_mgr_tar_info * currTar_Info;
 
 	CurrCard = &FPT_BL_Card[p_card];
 	currSCCB = CurrCard->currentSCCB;
@@ -3370,7 +3369,7 @@ static void FPT_shandem(unsigned long port, unsigned char p_card, struct sccb *
 static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag)
 {
    struct sccb * currSCCB;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
    currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
@@ -3446,7 +3445,7 @@ static void FPT_stsyncn(unsigned long port, unsigned char p_card)
 {
    unsigned char sync_msg,offset,sync_reg,our_sync_msg;
    struct sccb * currSCCB;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
    currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
@@ -3608,7 +3607,7 @@ static void FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned ch
 static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 {
    struct sccb * currSCCB;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
    currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
@@ -3661,7 +3660,7 @@ static void FPT_stwidn(unsigned long port, unsigned char p_card)
 {
    unsigned char width;
    struct sccb * currSCCB;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
    currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
@@ -3767,7 +3766,7 @@ static void FPT_siwidr(unsigned long port, unsigned char width)
  *
  *---------------------------------------------------------------------*/
 static void FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
-			PSCCBMgr_tar_info currTar_Info)
+			struct sccb_mgr_tar_info * currTar_Info)
 {
    unsigned char index;
 
@@ -3842,7 +3841,7 @@ static void FPT_sresb(unsigned long port, unsigned char p_card)
 {
    unsigned char scsiID, i;
 
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    WR_HARPOON(port+hp_page_ctrl,
       (RD_HARPOON(port+hp_page_ctrl) | G_INT_DISABLE));
@@ -4157,7 +4156,7 @@ static void FPT_schkdd(unsigned long port, unsigned char p_card)
 
 static void FPT_sinits(struct sccb * p_sccb, unsigned char p_card)
 {
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
 	if((p_sccb->TargID > MAX_SCSI_TAR) || (p_sccb->Lun > MAX_LUN))
 	{
@@ -4429,7 +4428,7 @@ static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 {
 	unsigned char message,scsiID;
 	struct sccb * currSCCB;
-	PSCCBMgr_tar_info currTar_Info;
+	struct sccb_mgr_tar_info * currTar_Info;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -6936,7 +6935,7 @@ static void FPT_DiagEEPROM(unsigned long p_port)
 static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 {
    unsigned char scan_ptr, lun;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 	struct sccb * pOldSccb;
 
    scan_ptr = pCurrCard->scanIndex;
@@ -7067,7 +7066,7 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 static void FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card)
 {
    unsigned char thisTarg;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    if (pCurrCard->currentSCCB != NULL)
 	  {
@@ -7109,7 +7108,7 @@ static void FPT_queueCmdComplete(PSCCBcard pCurrCard, struct sccb * p_sccb,
 
    unsigned char i, SCSIcmd;
    CALL_BK_FN callback;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    SCSIcmd = p_sccb->Cdb[0];
 
@@ -7207,7 +7206,7 @@ static void FPT_queueCmdComplete(PSCCBcard pCurrCard, struct sccb * p_sccb,
  *---------------------------------------------------------------------*/
 static void FPT_queueDisconnect(struct sccb * p_sccb, unsigned char p_card)
 {
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
 	currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
 
@@ -7244,7 +7243,7 @@ static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)
 {
    unsigned char qtag,thisTarg;
    struct sccb * currSCCB;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 	if(currSCCB != NULL)
@@ -7283,7 +7282,7 @@ static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg
 				    unsigned char error_code)
 {
    unsigned char qtag;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
@@ -7311,7 +7310,7 @@ static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg
 
 static void FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char p_card)
 {
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
    currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
 
    p_SCCB->Sccb_forwardlink = NULL;
@@ -7346,7 +7345,7 @@ static void FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char p_card)
 static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_card)
 {
    struct sccb * q_ptr;
-   PSCCBMgr_tar_info currTar_Info;
+   struct sccb_mgr_tar_info * currTar_Info;
 
    currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
 

commit 7f101662dd55aa16852ff6228ac496f56a259f5e
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:30 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: untypedef struct SCCBMgr_info
    
    * struct SCCBMgr_info => struct sccb_mgr_info
    * PSCCBMGR_INFO => struct sccb_mgr_info *
    * SCCBMGR_INFO => struct sccb_mgr_info
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 88b7da371399..9969fef8fd52 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -57,7 +57,7 @@ struct sccb;
 typedef void (*CALL_BK_FN)(struct sccb *);
 
 
-typedef struct SCCBMgr_info {
+struct sccb_mgr_info {
    unsigned long    si_baseaddr;
    unsigned char    si_present;
    unsigned char    si_intvect;
@@ -79,9 +79,8 @@ typedef struct SCCBMgr_info {
    unsigned char    si_XlatInfo[4];
    unsigned long    si_reserved2[5];
    unsigned long    si_secondary_range;
-} SCCBMGR_INFO;
+};
 
-typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
 
 
 #define SCSI_PARITY_ENA		  0x0001
@@ -309,7 +308,7 @@ typedef NVRAMINFO *PNVRamInfo;
 
 typedef struct SCCBcard {
    struct sccb * currentSCCB;
-   PSCCBMGR_INFO cardInfo;
+   struct sccb_mgr_info * cardInfo;
 
    unsigned long ioPort;
 
@@ -1108,7 +1107,7 @@ static void (*FPT_s_PhaseTbl[8]) (unsigned long, unsigned char)= { 0 };
  *
  *---------------------------------------------------------------------*/
 
-static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
+static int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info * pCardInfo)
 {
    static unsigned char first_time = 1;
 
@@ -1386,7 +1385,7 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned long FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
+static unsigned long FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info * pCardInfo)
 {
    PSCCBcard CurrCard = NULL;
 	PNVRamInfo pCurrNvRam;
@@ -7788,14 +7787,14 @@ static unsigned char FPT_CalcLrc(unsigned char buffer[])
 static inline unsigned char
 FlashPoint__ProbeHostAdapter(struct FlashPoint_Info *FlashPointInfo)
 {
-  return FlashPoint_ProbeHostAdapter((PSCCBMGR_INFO) FlashPointInfo);
+  return FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *) FlashPointInfo);
 }
 
 
 static inline FlashPoint_CardHandle_T
 FlashPoint__HardwareResetHostAdapter(struct FlashPoint_Info *FlashPointInfo)
 {
-  return FlashPoint_HardwareResetHostAdapter((PSCCBMGR_INFO) FlashPointInfo);
+  return FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *) FlashPointInfo);
 }
 
 static inline void

commit 69eb2ea47793366f59bfbc6e3c655b9c5047badd
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:29 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: untypedef struct _SCCB
    
    * struct _SCCB => struct sccb
    * PSCCB => struct sccb *
    * SCCB => struct sccb
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 022a4c0da7e1..88b7da371399 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -53,9 +53,8 @@
 
 
 
-
-typedef struct _SCCB *PSCCB;
-typedef void (*CALL_BK_FN)(PSCCB);
+struct sccb;
+typedef void (*CALL_BK_FN)(struct sccb *);
 
 
 typedef struct SCCBMgr_info {
@@ -110,7 +109,7 @@ typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
 
 
 #pragma pack(1)
-typedef struct _SCCB {
+struct sccb {
    unsigned char OperationCode;
    unsigned char ControlByte;
    unsigned char CdbLength;
@@ -146,14 +145,14 @@ typedef struct _SCCB {
    unsigned char   Sccb_tag;
    unsigned char   Sccb_scsistat;
    unsigned char   Sccb_idmsg;              /* image of last msg in */
-   PSCCB   Sccb_forwardlink;
-   PSCCB   Sccb_backlink;
+   struct sccb *   Sccb_forwardlink;
+   struct sccb *   Sccb_backlink;
    unsigned long   Sccb_savedATC;
    unsigned char   Save_Cdb[6];
    unsigned char   Save_CdbLen;
    unsigned char   Sccb_XferState;
    unsigned long   Sccb_SGoffset;
-   } SCCB;
+   };
 
 
 #pragma pack()
@@ -275,8 +274,8 @@ typedef struct SCCBMgr_tar_info *PSCCBMgr_tar_info;
 
 typedef struct SCCBMgr_tar_info {
 
-   PSCCB    TarSelQ_Head;
-   PSCCB    TarSelQ_Tail;
+   struct sccb *    TarSelQ_Head;
+   struct sccb *    TarSelQ_Tail;
    unsigned char    TarLUN_CA;        /*Contingent Allgiance */
    unsigned char    TarTagQ_Cnt;
    unsigned char    TarSelQ_Cnt;
@@ -309,7 +308,7 @@ typedef NVRAMINFO *PNVRamInfo;
 
 
 typedef struct SCCBcard {
-   PSCCB currentSCCB;
+   struct sccb * currentSCCB;
    PSCCBMGR_INFO cardInfo;
 
    unsigned long ioPort;
@@ -322,7 +321,7 @@ typedef struct SCCBcard {
    unsigned char globalFlags;
    unsigned char ourId;
    PNVRamInfo pNvRamInfo;
-   PSCCB discQ_Tbl[QUEUE_DEPTH]; 
+   struct sccb * discQ_Tbl[QUEUE_DEPTH];
       
 }SCCBCARD;
 
@@ -973,7 +972,7 @@ typedef struct SCCBscam_info {
 static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag);
 static void  FPT_ssel(unsigned long port, unsigned char p_card);
 static void  FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCard);
-static void  FPT_shandem(unsigned long port, unsigned char p_card,PSCCB pCurrSCCB);
+static void  FPT_shandem(unsigned long port, unsigned char p_card,struct sccb * pCurrSCCB);
 static void  FPT_stsyncn(unsigned long port, unsigned char p_card);
 static void  FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset);
 static void  FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
@@ -989,7 +988,7 @@ static void FPT_SendMsg(unsigned long port, unsigned char message);
 static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
 				    unsigned char error_code);
 
-static void  FPT_sinits(PSCCB p_sccb, unsigned char p_card);
+static void  FPT_sinits(struct sccb * p_sccb, unsigned char p_card);
 static void  FPT_RNVRamData(PNVRamInfo pNvRamInfo);
 
 static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card);
@@ -998,14 +997,14 @@ static void  FPT_siwidr(unsigned long port, unsigned char width);
 
 
 static void  FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card);
-static void  FPT_queueDisconnect(PSCCB p_SCCB, unsigned char p_card);
-static void  FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_SCCB,
+static void  FPT_queueDisconnect(struct sccb * p_SCCB, unsigned char p_card);
+static void  FPT_queueCmdComplete(PSCCBcard pCurrCard, struct sccb * p_SCCB,
 				  unsigned char p_card);
 static void  FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card);
 static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);
-static void  FPT_queueAddSccb(PSCCB p_SCCB, unsigned char card);
-static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card);
-static void  FPT_utilUpdateResidual(PSCCB p_SCCB);
+static void  FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char card);
+static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_card);
+static void  FPT_utilUpdateResidual(struct sccb * p_SCCB);
 static unsigned short FPT_CalcCrc16(unsigned char buffer[]);
 static unsigned char  FPT_CalcLrc(unsigned char buffer[]);
 
@@ -1043,10 +1042,10 @@ static void  FPT_DiagEEPROM(unsigned long p_port);
 
 
 static void  FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard);
-static void  FPT_busMstrSGDataXferStart(unsigned long port, PSCCB pCurrSCCB);
-static void  FPT_busMstrDataXferStart(unsigned long port, PSCCB pCurrSCCB);
-static void  FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, PSCCB pCurrSCCB);
-static void  FPT_hostDataXferRestart(PSCCB currSCCB);
+static void  FPT_busMstrSGDataXferStart(unsigned long port, struct sccb * pCurrSCCB);
+static void  FPT_busMstrDataXferStart(unsigned long port, struct sccb * pCurrSCCB);
+static void  FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB);
+static void  FPT_hostDataXferRestart(struct sccb * currSCCB);
 
 
 static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
@@ -1667,11 +1666,11 @@ static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static void FlashPoint_StartCCB(unsigned long pCurrCard, PSCCB p_Sccb)
+static void FlashPoint_StartCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 {
    unsigned long ioport;
    unsigned char thisCard, lun;
-	PSCCB pSaveSccb;
+	struct sccb * pSaveSccb;
    CALL_BK_FN callback;
 
    thisCard = ((PSCCBcard) pCurrCard)->cardIndex;
@@ -1787,14 +1786,14 @@ static void FlashPoint_StartCCB(unsigned long pCurrCard, PSCCB p_Sccb)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static int FlashPoint_AbortCCB(unsigned long pCurrCard, PSCCB p_Sccb)
+static int FlashPoint_AbortCCB(unsigned long pCurrCard, struct sccb * p_Sccb)
 {
 	unsigned long ioport;
 
 	unsigned char thisCard;
 	CALL_BK_FN callback;
 	unsigned char TID;
-	PSCCB pSaveSCCB;
+	struct sccb * pSaveSCCB;
 	PSCCBMgr_tar_info currTar_Info;
 
 
@@ -1916,7 +1915,7 @@ static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
  *---------------------------------------------------------------------*/
 static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    unsigned char thisCard,result,bm_status, bm_int_st;
    unsigned short hp_int;
    unsigned char i, target;
@@ -2417,7 +2416,7 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sfm(unsigned long port, PSCCB pCurrSCCB)
+static unsigned char FPT_sfm(unsigned long port, struct sccb * pCurrSCCB)
 {
 	unsigned char message;
 	unsigned short TimeOutLoop;
@@ -2497,7 +2496,7 @@ static void FPT_ssel(unsigned long port, unsigned char p_card)
 
    unsigned long cdb_reg;
    PSCCBcard CurrCard;
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    PSCCBMgr_tar_info currTar_Info;
    unsigned char lastTag, lun;
 
@@ -2808,7 +2807,7 @@ static void FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCa
 
 
    PSCCBMgr_tar_info currTar_Info;
-	PSCCB currSCCB;
+	struct sccb * currSCCB;
 
 
 
@@ -3113,7 +3112,7 @@ static void FPT_SendMsg(unsigned long port, unsigned char message)
  *---------------------------------------------------------------------*/
 static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p_card)
 {
-	PSCCB currSCCB;
+	struct sccb * currSCCB;
 	PSCCBcard CurrCard;
 	PSCCBMgr_tar_info currTar_Info;
 
@@ -3290,7 +3289,7 @@ static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p
  * Description: Decide what to do with the extended message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_shandem(unsigned long port, unsigned char p_card, PSCCB pCurrSCCB)
+static void FPT_shandem(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB)
 {
 	unsigned char length,message;
 
@@ -3371,7 +3370,7 @@ static void FPT_shandem(unsigned long port, unsigned char p_card, PSCCB pCurrSCC
 
 static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -3447,7 +3446,7 @@ static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsig
 static void FPT_stsyncn(unsigned long port, unsigned char p_card)
 {
    unsigned char sync_msg,offset,sync_reg,our_sync_msg;
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -3609,7 +3608,7 @@ static void FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned ch
 
 static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -3662,7 +3661,7 @@ static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 static void FPT_stwidn(unsigned long port, unsigned char p_card)
 {
    unsigned char width;
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -3916,7 +3915,7 @@ static void FPT_sresb(unsigned long port, unsigned char p_card)
 static void FPT_ssenss(PSCCBcard pCurrCard)
 {
    unsigned char i;
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = pCurrCard->currentSCCB;
 
@@ -4049,7 +4048,7 @@ static void FPT_schkdd(unsigned long port, unsigned char p_card)
    unsigned short TimeOutLoop;
 	unsigned char sPhase;
 
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4157,7 +4156,7 @@ static void FPT_schkdd(unsigned long port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sinits(PSCCB p_sccb, unsigned char p_card)
+static void FPT_sinits(struct sccb * p_sccb, unsigned char p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
 
@@ -4265,7 +4264,7 @@ static void FPT_phaseDecode(unsigned long p_port, unsigned char p_card)
 static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
 {
 
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
    if (currSCCB == NULL)
@@ -4309,7 +4308,7 @@ static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
 static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
 {
 
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4355,7 +4354,7 @@ static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
 
 static void FPT_phaseCommand(unsigned long p_port, unsigned char p_card)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    unsigned long cdb_reg;
    unsigned char i;
 
@@ -4430,7 +4429,7 @@ static void FPT_phaseStatus(unsigned long port, unsigned char p_card)
 static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 {
 	unsigned char message,scsiID;
-	PSCCB currSCCB;
+	struct sccb * currSCCB;
 	PSCCBMgr_tar_info currTar_Info;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -4578,7 +4577,7 @@ static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
 {
 	unsigned char message;
-	PSCCB currSCCB;
+	struct sccb * currSCCB;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4630,7 +4629,7 @@ static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
 
 static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4659,7 +4658,7 @@ static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
 static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
 {
    unsigned long xfercnt;
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4736,7 +4735,7 @@ static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
  *---------------------------------------------------------------------*/
 static void FPT_phaseBusFree(unsigned long port, unsigned char p_card)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4942,7 +4941,7 @@ static void FPT_autoLoadDefaultMap(unsigned long p_port)
 
 static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    unsigned char status_byte;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -5157,7 +5156,7 @@ static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
 
 static void FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard)
 {
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
 
    currSCCB = pCurrCard->currentSCCB;
 
@@ -5193,7 +5192,7 @@ static void FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard)
  * Description:
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrSGDataXferStart(unsigned long p_port, PSCCB pcurrSCCB)
+static void FPT_busMstrSGDataXferStart(unsigned long p_port, struct sccb * pcurrSCCB)
 {
    unsigned long count,addr,tmpSGCnt;
    unsigned int sg_index;
@@ -5298,7 +5297,7 @@ static void FPT_busMstrSGDataXferStart(unsigned long p_port, PSCCB pcurrSCCB)
  * Description: 
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrDataXferStart(unsigned long p_port, PSCCB pcurrSCCB)
+static void FPT_busMstrDataXferStart(unsigned long p_port, struct sccb * pcurrSCCB)
 {
    unsigned long addr,count;
 
@@ -5389,7 +5388,7 @@ static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
  * Description: Abort any in progress transfer.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, PSCCB pCurrSCCB)
+static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, struct sccb * pCurrSCCB)
 {
 
    unsigned long timeout;
@@ -5647,7 +5646,7 @@ static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, PSCC
  *              pointers message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferRestart(PSCCB currSCCB)
+static void FPT_hostDataXferRestart(struct sccb * currSCCB)
 {
    unsigned long data_count;
    unsigned int  sg_index;
@@ -6939,7 +6938,7 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 {
    unsigned char scan_ptr, lun;
    PSCCBMgr_tar_info currTar_Info;
-	PSCCB pOldSccb;
+	struct sccb * pOldSccb;
 
    scan_ptr = pCurrCard->scanIndex;
 	do 
@@ -6967,22 +6966,22 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 								 (lun != pCurrCard->currentSCCB->Lun))
 						{
 							pOldSccb = pCurrCard->currentSCCB;
-							pCurrCard->currentSCCB = (PSCCB)(pCurrCard->currentSCCB)->
+							pCurrCard->currentSCCB = (struct sccb *)(pCurrCard->currentSCCB)->
 																	Sccb_forwardlink;
 						}
 						if(pCurrCard->currentSCCB == NULL)
 							continue;
 						if(pOldSccb != NULL)
 						{
-							pOldSccb->Sccb_forwardlink = (PSCCB)(pCurrCard->currentSCCB)->
+							pOldSccb->Sccb_forwardlink = (struct sccb *)(pCurrCard->currentSCCB)->
 																	Sccb_forwardlink;
-							pOldSccb->Sccb_backlink = (PSCCB)(pCurrCard->currentSCCB)->
+							pOldSccb->Sccb_backlink = (struct sccb *)(pCurrCard->currentSCCB)->
 																	Sccb_backlink;
 							currTar_Info->TarSelQ_Cnt--;
 						}
 						else
 						{
-							currTar_Info->TarSelQ_Head = (PSCCB)(pCurrCard->currentSCCB)->Sccb_forwardlink;
+							currTar_Info->TarSelQ_Head = (struct sccb *)(pCurrCard->currentSCCB)->Sccb_forwardlink;
 					
 							if (currTar_Info->TarSelQ_Head == NULL)
 							{
@@ -6992,7 +6991,7 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 							else
 							{
 								currTar_Info->TarSelQ_Cnt--;
-								currTar_Info->TarSelQ_Head->Sccb_backlink = (PSCCB)NULL;
+								currTar_Info->TarSelQ_Head->Sccb_backlink = (struct sccb *)NULL;
 							}
 						}
 					pCurrCard->scanIndex = scan_ptr;
@@ -7021,7 +7020,7 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 
 				pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
 
-				currTar_Info->TarSelQ_Head = (PSCCB)(pCurrCard->currentSCCB)->Sccb_forwardlink;
+				currTar_Info->TarSelQ_Head = (struct sccb *)(pCurrCard->currentSCCB)->Sccb_forwardlink;
 
 				if (currTar_Info->TarSelQ_Head == NULL)
 				{
@@ -7031,7 +7030,7 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 				else
 				{
 					currTar_Info->TarSelQ_Cnt--;
-					currTar_Info->TarSelQ_Head->Sccb_backlink = (PSCCB)NULL;
+					currTar_Info->TarSelQ_Head->Sccb_backlink = (struct sccb *)NULL;
 				}
 
 				scan_ptr++;
@@ -7073,10 +7072,10 @@ static void FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card)
 
    if (pCurrCard->currentSCCB != NULL)
 	  {
-	  thisTarg = (unsigned char)(((PSCCB)(pCurrCard->currentSCCB))->TargID);
+	  thisTarg = (unsigned char)(((struct sccb *)(pCurrCard->currentSCCB))->TargID);
       currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
-      pCurrCard->currentSCCB->Sccb_backlink = (PSCCB)NULL;
+      pCurrCard->currentSCCB->Sccb_backlink = (struct sccb *)NULL;
 
       pCurrCard->currentSCCB->Sccb_forwardlink = currTar_Info->TarSelQ_Head;
 
@@ -7105,7 +7104,7 @@ static void FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb,
+static void FPT_queueCmdComplete(PSCCBcard pCurrCard, struct sccb * p_sccb,
 				 unsigned char p_card)
 {
 
@@ -7207,7 +7206,7 @@ static void FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb,
  * Description: Add SCCB to our disconnect array.
  *
  *---------------------------------------------------------------------*/
-static void FPT_queueDisconnect(PSCCB p_sccb, unsigned char p_card)
+static void FPT_queueDisconnect(struct sccb * p_sccb, unsigned char p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
 
@@ -7245,7 +7244,7 @@ static void FPT_queueDisconnect(PSCCB p_sccb, unsigned char p_card)
 static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)
 {
    unsigned char qtag,thisTarg;
-   PSCCB currSCCB;
+   struct sccb * currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -7311,7 +7310,7 @@ static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg
 
 
 
-static void FPT_queueAddSccb(PSCCB p_SCCB, unsigned char p_card)
+static void FPT_queueAddSccb(struct sccb * p_SCCB, unsigned char p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
    currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
@@ -7345,9 +7344,9 @@ static void FPT_queueAddSccb(PSCCB p_SCCB, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card)
+static unsigned char FPT_queueFindSccb(struct sccb * p_SCCB, unsigned char p_card)
 {
-   PSCCB q_ptr;
+   struct sccb * q_ptr;
    PSCCBMgr_tar_info currTar_Info;
 
    currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
@@ -7406,7 +7405,7 @@ static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
+static void  FPT_utilUpdateResidual(struct sccb * p_SCCB)
 {
    unsigned long partial_cnt;
    unsigned int  sg_index;
@@ -7809,14 +7808,14 @@ FlashPoint__ReleaseHostAdapter(FlashPoint_CardHandle_T CardHandle)
 static inline void
 FlashPoint__StartCCB(FlashPoint_CardHandle_T CardHandle, struct BusLogic_CCB *CCB)
 {
-  FlashPoint_StartCCB(CardHandle, (PSCCB) CCB);
+  FlashPoint_StartCCB(CardHandle, (struct sccb *) CCB);
 }
 
 
 static inline void
 FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle, struct BusLogic_CCB *CCB)
 {
-  FlashPoint_AbortCCB(CardHandle, (PSCCB) CCB);
+  FlashPoint_AbortCCB(CardHandle, (struct sccb *) CCB);
 }
 
 

commit ad0e1d9f0155073cffb74755fb21c0fb82b1b094
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:28 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: use standard fixed size types
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 6089af003130..022a4c0da7e1 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -44,13 +44,7 @@
 
 
 
-#define s08bits	char
-#define s16bits 	short
-#define s32bits	long
 
-#define u08bits	unsigned s08bits
-#define u16bits	unsigned s16bits
-#define u32bits	unsigned s32bits
 
 
 
@@ -245,12 +239,12 @@ typedef struct _SCCB {
 #define SG_ELEMENT_SIZE 8              /*Eight byte per element. */
 
 
-#define RD_HARPOON(ioport)          inb((u32bits)ioport)
-#define RDW_HARPOON(ioport)         inw((u32bits)ioport)
-#define RD_HARP32(ioport,offset,data) (data = inl((u32bits)(ioport + offset)))
-#define WR_HARPOON(ioport,val)      outb((u08bits) val, (u32bits)ioport)
-#define WRW_HARPOON(ioport,val)       outw((u16bits)val, (u32bits)ioport)
-#define WR_HARP32(ioport,offset,data)  outl(data, (u32bits)(ioport + offset))
+#define RD_HARPOON(ioport)          inb((u32)ioport)
+#define RDW_HARPOON(ioport)         inw((u32)ioport)
+#define RD_HARP32(ioport,offset,data) (data = inl((u32)(ioport + offset)))
+#define WR_HARPOON(ioport,val)      outb((u8) val, (u32)ioport)
+#define WRW_HARPOON(ioport,val)       outw((u16)val, (u32)ioport)
+#define WR_HARP32(ioport,offset,data)  outl(data, (u32)(ioport + offset))
 
 
 #define  TAR_SYNC_MASK     (BIT(7)+BIT(6))

commit fd1e29ed62cc307281d1a62f73ebac059ac6b6a1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:27 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove ushort_ptr
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index d877a6a12aca..6089af003130 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -42,7 +42,6 @@
 
 
 
-typedef unsigned short          * ushort_ptr;
 
 
 #define s08bits	char
@@ -6003,7 +6002,7 @@ static void FPT_scasid(unsigned char p_card, unsigned long p_port)
    unsigned char i,k,scam_id;
 	unsigned char crcBytes[3];
 	PNVRamInfo pCurrNvRam;
-	ushort_ptr pCrcBytes;
+	unsigned short * pCrcBytes;
 
 	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
 
@@ -6023,7 +6022,7 @@ static void FPT_scasid(unsigned char p_card, unsigned long p_port)
       if (!(FPT_sciso(p_port,&temp_id_string[0])))
          {
 			if(pCurrNvRam){
-				pCrcBytes = (ushort_ptr)&crcBytes[0];
+				pCrcBytes = (unsigned short *)&crcBytes[0];
 				*pCrcBytes = FPT_CalcCrc16(&temp_id_string[0]);
 				crcBytes[2] = FPT_CalcLrc(&temp_id_string[0]);
 				temp_id_string[1] = crcBytes[2];

commit d63a4cccf387a8e6210cfd818c1ea717beefc531
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:26 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove ULONG
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index a981dea3bbfb..d877a6a12aca 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -40,7 +40,6 @@
 #define FAILURE         0xFFFFFFFFL
 
 
-typedef unsigned long   ULONG;
 
 
 typedef unsigned short          * ushort_ptr;
@@ -67,7 +66,7 @@ typedef void (*CALL_BK_FN)(PSCCB);
 
 
 typedef struct SCCBMgr_info {
-   ULONG    si_baseaddr;
+   unsigned long    si_baseaddr;
    unsigned char    si_present;
    unsigned char    si_intvect;
    unsigned char    si_id;
@@ -84,10 +83,10 @@ typedef struct SCCBMgr_info {
    unsigned char    si_card_model[3];
    unsigned char    si_relative_cardnum;
    unsigned char    si_reserved[4];
-   ULONG    si_OS_reserved;
+   unsigned long    si_OS_reserved;
    unsigned char    si_XlatInfo[4];
-   ULONG    si_reserved2[5];
-   ULONG    si_secondary_range;
+   unsigned long    si_reserved2[5];
+   unsigned long    si_secondary_range;
 } SCCBMGR_INFO;
 
 typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
@@ -123,8 +122,8 @@ typedef struct _SCCB {
    unsigned char ControlByte;
    unsigned char CdbLength;
    unsigned char RequestSenseLength;
-   ULONG DataLength;
-   ULONG DataPointer;
+   unsigned long DataLength;
+   unsigned long DataPointer;
    unsigned char CcbRes[2];
    unsigned char HostStatus;
    unsigned char TargetStatus;
@@ -133,21 +132,21 @@ typedef struct _SCCB {
    unsigned char Cdb[12];
    unsigned char CcbRes1;
    unsigned char Reserved1;
-   ULONG Reserved2;
-   ULONG SensePointer;
+   unsigned long Reserved2;
+   unsigned long SensePointer;
 
 
    CALL_BK_FN SccbCallback;                  /* VOID (*SccbCallback)(); */
-   ULONG  SccbIOPort;                        /* Identifies board base port */
+   unsigned long  SccbIOPort;                        /* Identifies board base port */
    unsigned char  SccbStatus;
    unsigned char  SCCBRes2;
    unsigned short SccbOSFlags;
 
 
-   ULONG   Sccb_XferCnt;            /* actual transfer count */
-   ULONG   Sccb_ATC;
-   ULONG   SccbVirtDataPtr;         /* virtual addr for OS/2 */
-   ULONG   Sccb_res1;
+   unsigned long   Sccb_XferCnt;            /* actual transfer count */
+   unsigned long   Sccb_ATC;
+   unsigned long   SccbVirtDataPtr;         /* virtual addr for OS/2 */
+   unsigned long   Sccb_res1;
    unsigned short  Sccb_MGRFlags;
    unsigned short  Sccb_sgseg;
    unsigned char   Sccb_scsimsg;            /* identify msg for selection */
@@ -156,11 +155,11 @@ typedef struct _SCCB {
    unsigned char   Sccb_idmsg;              /* image of last msg in */
    PSCCB   Sccb_forwardlink;
    PSCCB   Sccb_backlink;
-   ULONG   Sccb_savedATC;
+   unsigned long   Sccb_savedATC;
    unsigned char   Save_Cdb[6];
    unsigned char   Save_CdbLen;
    unsigned char   Sccb_XferState;
-   ULONG   Sccb_SGoffset;
+   unsigned long   Sccb_SGoffset;
    } SCCB;
 
 
@@ -299,7 +298,7 @@ typedef struct SCCBMgr_tar_info {
 typedef struct NVRAMInfo {
 	unsigned char		niModel;								/* Model No. of card */
 	unsigned char		niCardNo;							/* Card no. */
-	ULONG		niBaseAddr;							/* Port Address of card */
+	unsigned long		niBaseAddr;							/* Port Address of card */
 	unsigned char		niSysConf;							/* Adapter Configuration byte - Byte 16 of eeprom map */
 	unsigned char		niScsiConf;							/* SCSI Configuration byte - Byte 17 of eeprom map */
 	unsigned char		niScamConf;							/* SCAM Configuration byte - Byte 20 of eeprom map */
@@ -320,7 +319,7 @@ typedef struct SCCBcard {
    PSCCB currentSCCB;
    PSCCBMGR_INFO cardInfo;
 
-   ULONG ioPort;
+   unsigned long ioPort;
 
    unsigned short cmdCounter;
    unsigned char  discQCount;
@@ -978,31 +977,31 @@ typedef struct SCCBscam_info {
 
 
 
-static unsigned char FPT_sisyncn(ULONG port, unsigned char p_card, unsigned char syncFlag);
-static void  FPT_ssel(ULONG port, unsigned char p_card);
-static void  FPT_sres(ULONG port, unsigned char p_card, PSCCBcard pCurrCard);
-static void  FPT_shandem(ULONG port, unsigned char p_card,PSCCB pCurrSCCB);
-static void  FPT_stsyncn(ULONG port, unsigned char p_card);
-static void  FPT_sisyncr(ULONG port,unsigned char sync_pulse, unsigned char offset);
-static void  FPT_sssyncv(ULONG p_port, unsigned char p_id, unsigned char p_sync_value,
+static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag);
+static void  FPT_ssel(unsigned long port, unsigned char p_card);
+static void  FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCard);
+static void  FPT_shandem(unsigned long port, unsigned char p_card,PSCCB pCurrSCCB);
+static void  FPT_stsyncn(unsigned long port, unsigned char p_card);
+static void  FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset);
+static void  FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
 			 PSCCBMgr_tar_info currTar_Info);
-static void  FPT_sresb(ULONG port, unsigned char p_card);
-static void  FPT_sxfrp(ULONG p_port, unsigned char p_card);
-static void  FPT_schkdd(ULONG port, unsigned char p_card);
-static unsigned char FPT_RdStack(ULONG port, unsigned char index);
-static void  FPT_WrStack(ULONG portBase, unsigned char index, unsigned char data);
-static unsigned char FPT_ChkIfChipInitialized(ULONG ioPort);
-
-static void FPT_SendMsg(ULONG port, unsigned char message);
+static void  FPT_sresb(unsigned long port, unsigned char p_card);
+static void  FPT_sxfrp(unsigned long p_port, unsigned char p_card);
+static void  FPT_schkdd(unsigned long port, unsigned char p_card);
+static unsigned char FPT_RdStack(unsigned long port, unsigned char index);
+static void  FPT_WrStack(unsigned long portBase, unsigned char index, unsigned char data);
+static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort);
+
+static void FPT_SendMsg(unsigned long port, unsigned char message);
 static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
 				    unsigned char error_code);
 
 static void  FPT_sinits(PSCCB p_sccb, unsigned char p_card);
 static void  FPT_RNVRamData(PNVRamInfo pNvRamInfo);
 
-static unsigned char FPT_siwidn(ULONG port, unsigned char p_card);
-static void  FPT_stwidn(ULONG port, unsigned char p_card);
-static void  FPT_siwidr(ULONG port, unsigned char width);
+static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card);
+static void  FPT_stwidn(unsigned long port, unsigned char p_card);
+static void  FPT_siwidr(unsigned long port, unsigned char width);
 
 
 static void  FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card);
@@ -1018,46 +1017,46 @@ static unsigned short FPT_CalcCrc16(unsigned char buffer[]);
 static unsigned char  FPT_CalcLrc(unsigned char buffer[]);
 
 
-static void  FPT_Wait1Second(ULONG p_port);
-static void  FPT_Wait(ULONG p_port, unsigned char p_delay);
-static void  FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode);
-static void  FPT_utilEEWrite(ULONG p_port, unsigned short ee_data, unsigned short ee_addr);
-static unsigned short FPT_utilEERead(ULONG p_port, unsigned short ee_addr);
-static unsigned short FPT_utilEEReadOrg(ULONG p_port, unsigned short ee_addr);
-static void  FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, unsigned short ee_addr);
+static void  FPT_Wait1Second(unsigned long p_port);
+static void  FPT_Wait(unsigned long p_port, unsigned char p_delay);
+static void  FPT_utilEEWriteOnOff(unsigned long p_port,unsigned char p_mode);
+static void  FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data, unsigned short ee_addr);
+static unsigned short FPT_utilEERead(unsigned long p_port, unsigned short ee_addr);
+static unsigned short FPT_utilEEReadOrg(unsigned long p_port, unsigned short ee_addr);
+static void  FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd, unsigned short ee_addr);
 
 
 
-static void  FPT_phaseDataOut(ULONG port, unsigned char p_card);
-static void  FPT_phaseDataIn(ULONG port, unsigned char p_card);
-static void  FPT_phaseCommand(ULONG port, unsigned char p_card);
-static void  FPT_phaseStatus(ULONG port, unsigned char p_card);
-static void  FPT_phaseMsgOut(ULONG port, unsigned char p_card);
-static void  FPT_phaseMsgIn(ULONG port, unsigned char p_card);
-static void  FPT_phaseIllegal(ULONG port, unsigned char p_card);
+static void  FPT_phaseDataOut(unsigned long port, unsigned char p_card);
+static void  FPT_phaseDataIn(unsigned long port, unsigned char p_card);
+static void  FPT_phaseCommand(unsigned long port, unsigned char p_card);
+static void  FPT_phaseStatus(unsigned long port, unsigned char p_card);
+static void  FPT_phaseMsgOut(unsigned long port, unsigned char p_card);
+static void  FPT_phaseMsgIn(unsigned long port, unsigned char p_card);
+static void  FPT_phaseIllegal(unsigned long port, unsigned char p_card);
 
-static void  FPT_phaseDecode(ULONG port, unsigned char p_card);
-static void  FPT_phaseChkFifo(ULONG port, unsigned char p_card);
-static void  FPT_phaseBusFree(ULONG p_port, unsigned char p_card);
+static void  FPT_phaseDecode(unsigned long port, unsigned char p_card);
+static void  FPT_phaseChkFifo(unsigned long port, unsigned char p_card);
+static void  FPT_phaseBusFree(unsigned long p_port, unsigned char p_card);
 
 
 
 
-static void  FPT_XbowInit(ULONG port, unsigned char scamFlg);
-static void  FPT_BusMasterInit(ULONG p_port);
-static void  FPT_DiagEEPROM(ULONG p_port);
+static void  FPT_XbowInit(unsigned long port, unsigned char scamFlg);
+static void  FPT_BusMasterInit(unsigned long p_port);
+static void  FPT_DiagEEPROM(unsigned long p_port);
 
 
 
 
-static void  FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard);
-static void  FPT_busMstrSGDataXferStart(ULONG port, PSCCB pCurrSCCB);
-static void  FPT_busMstrDataXferStart(ULONG port, PSCCB pCurrSCCB);
-static void  FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrSCCB);
+static void  FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard);
+static void  FPT_busMstrSGDataXferStart(unsigned long port, PSCCB pCurrSCCB);
+static void  FPT_busMstrDataXferStart(unsigned long port, PSCCB pCurrSCCB);
+static void  FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, PSCCB pCurrSCCB);
 static void  FPT_hostDataXferRestart(PSCCB currSCCB);
 
 
-static unsigned char FPT_SccbMgr_bad_isr(ULONG p_port, unsigned char p_card,
+static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
 				 PSCCBcard pCurrCard, unsigned short p_int);
 
 static void  FPT_SccbMgrTableInitAll(void);
@@ -1068,25 +1067,25 @@ static void  FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targ
 
 static void  FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned char p_power_up);
 
-static int   FPT_scarb(ULONG p_port, unsigned char p_sel_type);
-static void  FPT_scbusf(ULONG p_port);
-static void  FPT_scsel(ULONG p_port);
-static void  FPT_scasid(unsigned char p_card, ULONG p_port);
-static unsigned char FPT_scxferc(ULONG p_port, unsigned char p_data);
-static unsigned char FPT_scsendi(ULONG p_port, unsigned char p_id_string[]);
-static unsigned char FPT_sciso(ULONG p_port, unsigned char p_id_string[]);
-static void  FPT_scwirod(ULONG p_port, unsigned char p_data_bit);
-static void  FPT_scwiros(ULONG p_port, unsigned char p_data_bit);
+static int   FPT_scarb(unsigned long p_port, unsigned char p_sel_type);
+static void  FPT_scbusf(unsigned long p_port);
+static void  FPT_scsel(unsigned long p_port);
+static void  FPT_scasid(unsigned char p_card, unsigned long p_port);
+static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data);
+static unsigned char FPT_scsendi(unsigned long p_port, unsigned char p_id_string[]);
+static unsigned char FPT_sciso(unsigned long p_port, unsigned char p_id_string[]);
+static void  FPT_scwirod(unsigned long p_port, unsigned char p_data_bit);
+static void  FPT_scwiros(unsigned long p_port, unsigned char p_data_bit);
 static unsigned char FPT_scvalq(unsigned char p_quintet);
-static unsigned char FPT_scsell(ULONG p_port, unsigned char targ_id);
-static void  FPT_scwtsel(ULONG p_port);
-static void  FPT_inisci(unsigned char p_card, ULONG p_port, unsigned char p_our_id);
-static void  FPT_scsavdi(unsigned char p_card, ULONG p_port);
+static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id);
+static void  FPT_scwtsel(unsigned long p_port);
+static void  FPT_inisci(unsigned char p_card, unsigned long p_port, unsigned char p_our_id);
+static void  FPT_scsavdi(unsigned char p_card, unsigned long p_port);
 static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_string[]);
 
 
-static void  FPT_autoCmdCmplt(ULONG p_port, unsigned char p_card);
-static void  FPT_autoLoadDefaultMap(ULONG p_port);
+static void  FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card);
+static void  FPT_autoLoadDefaultMap(unsigned long p_port);
 
 
 
@@ -1106,7 +1105,7 @@ static unsigned char FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O',
 static unsigned short FPT_default_intena = 0;
 
 
-static void (*FPT_s_PhaseTbl[8]) (ULONG, unsigned char)= { 0 };
+static void (*FPT_s_PhaseTbl[8]) (unsigned long, unsigned char)= { 0 };
 
 
 /*---------------------------------------------------------------------
@@ -1123,7 +1122,7 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 
    unsigned char i,j,id,ScamFlg;
    unsigned short temp,temp2,temp3,temp4,temp5,temp6;
-   ULONG ioport;
+   unsigned long ioport;
 	PNVRamInfo pCurrNvRam;
 
    ioport = pCardInfo->si_baseaddr;
@@ -1395,13 +1394,13 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
  *
  *---------------------------------------------------------------------*/
 
-static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
+static unsigned long FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
 {
    PSCCBcard CurrCard = NULL;
 	PNVRamInfo pCurrNvRam;
    unsigned char i,j,thisCard, ScamFlg;
    unsigned short temp,sync_bit_map,id;
-   ULONG ioport;
+   unsigned long ioport;
 
    ioport = pCardInfo->si_baseaddr;
 
@@ -1573,16 +1572,16 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
    WR_HARPOON((ioport+hp_semaphore),
       (unsigned char)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
 
-   return((ULONG)CurrCard);
+   return((unsigned long)CurrCard);
 }
 
-static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
+static void FlashPoint_ReleaseHostAdapter(unsigned long pCurrCard)
 {
 	unsigned char i;
-	ULONG portBase;
-	ULONG regOffset;
-	ULONG scamData;
-	ULONG *pScamTbl;
+	unsigned long portBase;
+	unsigned long regOffset;
+	unsigned long scamData;
+	unsigned long *pScamTbl;
 	PNVRamInfo pCurrNvRam;
 
 	pCurrNvRam = ((PSCCBcard)pCurrCard)->pNvRamInfo;
@@ -1601,7 +1600,7 @@ static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
 
 		for(i = 0; i < MAX_SCSI_TAR; i++){
 			regOffset = hp_aramBase + 64 + i*4;
-			pScamTbl = (ULONG *) &pCurrNvRam->niScamTbl[i];
+			pScamTbl = (unsigned long *) &pCurrNvRam->niScamTbl[i];
 			scamData = *pScamTbl;
 			WR_HARP32(portBase, regOffset, scamData);
 		}
@@ -1615,10 +1614,10 @@ static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
 static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
 {
 	unsigned char i;
-	ULONG portBase;
-	ULONG regOffset;
-	ULONG scamData;
-	ULONG *pScamTbl;
+	unsigned long portBase;
+	unsigned long regOffset;
+	unsigned long scamData;
+	unsigned long *pScamTbl;
 
 	pNvRamInfo->niModel    = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);
 	pNvRamInfo->niSysConf  = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);
@@ -1634,26 +1633,26 @@ static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
 	for(i = 0; i < MAX_SCSI_TAR; i++){
 		regOffset = hp_aramBase + 64 + i*4;
 		RD_HARP32(portBase, regOffset, scamData);
-		pScamTbl = (ULONG *) &pNvRamInfo->niScamTbl[i];
+		pScamTbl = (unsigned long *) &pNvRamInfo->niScamTbl[i];
 		*pScamTbl = scamData;
 	}
 
 }
 
-static unsigned char FPT_RdStack(ULONG portBase, unsigned char index)
+static unsigned char FPT_RdStack(unsigned long portBase, unsigned char index)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	return(RD_HARPOON(portBase + hp_stack_data));
 }
 
-static void FPT_WrStack(ULONG portBase, unsigned char index, unsigned char data)
+static void FPT_WrStack(unsigned long portBase, unsigned char index, unsigned char data)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	WR_HARPOON(portBase + hp_stack_data, data);
 }
 
 
-static unsigned char FPT_ChkIfChipInitialized(ULONG ioPort)
+static unsigned char FPT_ChkIfChipInitialized(unsigned long ioPort)
 {
 	if((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
 		return(0);
@@ -1675,9 +1674,9 @@ static unsigned char FPT_ChkIfChipInitialized(ULONG ioPort)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static void FlashPoint_StartCCB(ULONG pCurrCard, PSCCB p_Sccb)
+static void FlashPoint_StartCCB(unsigned long pCurrCard, PSCCB p_Sccb)
 {
-   ULONG ioport;
+   unsigned long ioport;
    unsigned char thisCard, lun;
 	PSCCB pSaveSccb;
    CALL_BK_FN callback;
@@ -1795,9 +1794,9 @@ static void FlashPoint_StartCCB(ULONG pCurrCard, PSCCB p_Sccb)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static int FlashPoint_AbortCCB(ULONG pCurrCard, PSCCB p_Sccb)
+static int FlashPoint_AbortCCB(unsigned long pCurrCard, PSCCB p_Sccb)
 {
-	ULONG ioport;
+	unsigned long ioport;
 
 	unsigned char thisCard;
 	CALL_BK_FN callback;
@@ -1895,9 +1894,9 @@ static int FlashPoint_AbortCCB(ULONG pCurrCard, PSCCB p_Sccb)
  *              interrupt for this card and disable the IRQ Pin if so.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FlashPoint_InterruptPending(ULONG pCurrCard)
+static unsigned char FlashPoint_InterruptPending(unsigned long pCurrCard)
 {
-   ULONG ioport;
+   unsigned long ioport;
 
    ioport = ((PSCCBcard)pCurrCard)->ioPort;
 
@@ -1922,13 +1921,13 @@ static unsigned char FlashPoint_InterruptPending(ULONG pCurrCard)
  *              us.
  *
  *---------------------------------------------------------------------*/
-static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
+static int FlashPoint_HandleInterrupt(unsigned long pCurrCard)
 {
    PSCCB currSCCB;
    unsigned char thisCard,result,bm_status, bm_int_st;
    unsigned short hp_int;
    unsigned char i, target;
-   ULONG ioport;
+   unsigned long ioport;
 
    thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
    ioport = ((PSCCBcard)pCurrCard)->ioPort;
@@ -2167,7 +2166,7 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
  *              processing time.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FPT_SccbMgr_bad_isr(ULONG p_port, unsigned char p_card,
+static unsigned char FPT_SccbMgr_bad_isr(unsigned long p_port, unsigned char p_card,
 				 PSCCBcard pCurrCard, unsigned short p_int)
 {
    unsigned char temp, ScamFlg;
@@ -2425,7 +2424,7 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sfm(ULONG port, PSCCB pCurrSCCB)
+static unsigned char FPT_sfm(unsigned long port, PSCCB pCurrSCCB)
 {
 	unsigned char message;
 	unsigned short TimeOutLoop;
@@ -2498,12 +2497,12 @@ static unsigned char FPT_sfm(ULONG port, PSCCB pCurrSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_ssel(ULONG port, unsigned char p_card)
+static void FPT_ssel(unsigned long port, unsigned char p_card)
 {
 
    unsigned char auto_loaded, i, target, *theCCB;
 
-   ULONG cdb_reg;
+   unsigned long cdb_reg;
    PSCCBcard CurrCard;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
@@ -2809,7 +2808,7 @@ static void FPT_ssel(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sres(ULONG port, unsigned char p_card, PSCCBcard pCurrCard)
+static void FPT_sres(unsigned long port, unsigned char p_card, PSCCBcard pCurrCard)
 {
 
    unsigned char our_target, message, lun = 0, tag, msgRetryCount;
@@ -3070,7 +3069,7 @@ static void FPT_sres(ULONG port, unsigned char p_card, PSCCBcard pCurrCard)
 	  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
 }
 
-static void FPT_SendMsg(ULONG port, unsigned char message)
+static void FPT_SendMsg(unsigned long port, unsigned char message)
 {
 	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
 	{
@@ -3119,7 +3118,7 @@ static void FPT_SendMsg(ULONG port, unsigned char message)
  *              target device.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sdecm(unsigned char message, ULONG port, unsigned char p_card)
+static void FPT_sdecm(unsigned char message, unsigned long port, unsigned char p_card)
 {
 	PSCCB currSCCB;
 	PSCCBcard CurrCard;
@@ -3298,7 +3297,7 @@ static void FPT_sdecm(unsigned char message, ULONG port, unsigned char p_card)
  * Description: Decide what to do with the extended message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_shandem(ULONG port, unsigned char p_card, PSCCB pCurrSCCB)
+static void FPT_shandem(unsigned long port, unsigned char p_card, PSCCB pCurrSCCB)
 {
 	unsigned char length,message;
 
@@ -3377,7 +3376,7 @@ static void FPT_shandem(ULONG port, unsigned char p_card, PSCCB pCurrSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sisyncn(ULONG port, unsigned char p_card, unsigned char syncFlag)
+static unsigned char FPT_sisyncn(unsigned long port, unsigned char p_card, unsigned char syncFlag)
 {
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
@@ -3452,7 +3451,7 @@ static unsigned char FPT_sisyncn(ULONG port, unsigned char p_card, unsigned char
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-static void FPT_stsyncn(ULONG port, unsigned char p_card)
+static void FPT_stsyncn(unsigned long port, unsigned char p_card)
 {
    unsigned char sync_msg,offset,sync_reg,our_sync_msg;
    PSCCB currSCCB;
@@ -3584,7 +3583,7 @@ static void FPT_stsyncn(ULONG port, unsigned char p_card)
  * Description: Answer the targets sync message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sisyncr(ULONG port,unsigned char sync_pulse, unsigned char offset)
+static void FPT_sisyncr(unsigned long port,unsigned char sync_pulse, unsigned char offset)
 {
    ARAM_ACCESS(port);
    WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
@@ -3615,7 +3614,7 @@ static void FPT_sisyncr(ULONG port,unsigned char sync_pulse, unsigned char offse
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_siwidn(ULONG port, unsigned char p_card)
+static unsigned char FPT_siwidn(unsigned long port, unsigned char p_card)
 {
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
@@ -3667,7 +3666,7 @@ static unsigned char FPT_siwidn(ULONG port, unsigned char p_card)
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-static void FPT_stwidn(ULONG port, unsigned char p_card)
+static void FPT_stwidn(unsigned long port, unsigned char p_card)
 {
    unsigned char width;
    PSCCB currSCCB;
@@ -3747,7 +3746,7 @@ static void FPT_stwidn(ULONG port, unsigned char p_card)
  * Description: Answer the targets Wide nego message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_siwidr(ULONG port, unsigned char width)
+static void FPT_siwidr(unsigned long port, unsigned char width)
 {
    ARAM_ACCESS(port);
    WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
@@ -3776,7 +3775,7 @@ static void FPT_siwidr(ULONG port, unsigned char width)
  *              ID specified.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sssyncv(ULONG p_port, unsigned char p_id, unsigned char p_sync_value,
+static void FPT_sssyncv(unsigned long p_port, unsigned char p_id, unsigned char p_sync_value,
 			PSCCBMgr_tar_info currTar_Info)
 {
    unsigned char index;
@@ -3848,7 +3847,7 @@ static void FPT_sssyncv(ULONG p_port, unsigned char p_id, unsigned char p_sync_v
  * Description: Reset the desired card's SCSI bus.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sresb(ULONG port, unsigned char p_card)
+static void FPT_sresb(unsigned long port, unsigned char p_card)
 {
    unsigned char scsiID, i;
 
@@ -3970,7 +3969,7 @@ static void FPT_ssenss(PSCCBcard pCurrCard)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sxfrp(ULONG p_port, unsigned char p_card)
+static void FPT_sxfrp(unsigned long p_port, unsigned char p_card)
 {
    unsigned char curr_phz;
 
@@ -4052,7 +4051,7 @@ static void FPT_sxfrp(ULONG p_port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_schkdd(ULONG port, unsigned char p_card)
+static void FPT_schkdd(unsigned long port, unsigned char p_card)
 {
    unsigned short TimeOutLoop;
 	unsigned char sPhase;
@@ -4245,10 +4244,10 @@ static void FPT_sinits(PSCCB p_sccb, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDecode(ULONG p_port, unsigned char p_card)
+static void FPT_phaseDecode(unsigned long p_port, unsigned char p_card)
 {
    unsigned char phase_ref;
-   void (*phase) (ULONG, unsigned char);
+   void (*phase) (unsigned long, unsigned char);
 
 
    DISABLE_AUTO(p_port);
@@ -4270,7 +4269,7 @@ static void FPT_phaseDecode(ULONG p_port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDataOut(ULONG port, unsigned char p_card)
+static void FPT_phaseDataOut(unsigned long port, unsigned char p_card)
 {
 
    PSCCB currSCCB;
@@ -4314,7 +4313,7 @@ static void FPT_phaseDataOut(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDataIn(ULONG port, unsigned char p_card)
+static void FPT_phaseDataIn(unsigned long port, unsigned char p_card)
 {
 
    PSCCB currSCCB;
@@ -4361,10 +4360,10 @@ static void FPT_phaseDataIn(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseCommand(ULONG p_port, unsigned char p_card)
+static void FPT_phaseCommand(unsigned long p_port, unsigned char p_card)
 {
    PSCCB currSCCB;
-   ULONG cdb_reg;
+   unsigned long cdb_reg;
    unsigned char i;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -4413,7 +4412,7 @@ static void FPT_phaseCommand(ULONG p_port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseStatus(ULONG port, unsigned char p_card)
+static void FPT_phaseStatus(unsigned long port, unsigned char p_card)
 {
    /* Start-up the automation to finish off this command and let the
       isr handle the interrupt for command complete when it comes in.
@@ -4435,7 +4434,7 @@ static void FPT_phaseStatus(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseMsgOut(ULONG port, unsigned char p_card)
+static void FPT_phaseMsgOut(unsigned long port, unsigned char p_card)
 {
 	unsigned char message,scsiID;
 	PSCCB currSCCB;
@@ -4583,7 +4582,7 @@ static void FPT_phaseMsgOut(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseMsgIn(ULONG port, unsigned char p_card)
+static void FPT_phaseMsgIn(unsigned long port, unsigned char p_card)
 {
 	unsigned char message;
 	PSCCB currSCCB;
@@ -4636,7 +4635,7 @@ static void FPT_phaseMsgIn(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseIllegal(ULONG port, unsigned char p_card)
+static void FPT_phaseIllegal(unsigned long port, unsigned char p_card)
 {
    PSCCB currSCCB;
 
@@ -4664,9 +4663,9 @@ static void FPT_phaseIllegal(ULONG port, unsigned char p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseChkFifo(ULONG port, unsigned char p_card)
+static void FPT_phaseChkFifo(unsigned long port, unsigned char p_card)
 {
-   ULONG xfercnt;
+   unsigned long xfercnt;
    PSCCB currSCCB;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -4742,7 +4741,7 @@ static void FPT_phaseChkFifo(ULONG port, unsigned char p_card)
  *              because of command complete or from a disconnect.
  *
  *---------------------------------------------------------------------*/
-static void FPT_phaseBusFree(ULONG port, unsigned char p_card)
+static void FPT_phaseBusFree(unsigned long port, unsigned char p_card)
 {
    PSCCB currSCCB;
 
@@ -4840,9 +4839,9 @@ static void FPT_phaseBusFree(ULONG port, unsigned char p_card)
  * Description: Load the Automation RAM with the defualt map values.
  *
  *---------------------------------------------------------------------*/
-static void FPT_autoLoadDefaultMap(ULONG p_port)
+static void FPT_autoLoadDefaultMap(unsigned long p_port)
 {
-   ULONG map_addr;
+   unsigned long map_addr;
 
    ARAM_ACCESS(p_port);
    map_addr = p_port + hp_aramBase;
@@ -4948,7 +4947,7 @@ static void FPT_autoLoadDefaultMap(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_autoCmdCmplt(ULONG p_port, unsigned char p_card)
+static void FPT_autoCmdCmplt(unsigned long p_port, unsigned char p_card)
 {
    PSCCB currSCCB;
    unsigned char status_byte;
@@ -5163,7 +5162,7 @@ static void FPT_autoCmdCmplt(ULONG p_port, unsigned char p_card)
  *              
  *---------------------------------------------------------------------*/
 
-static void FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
+static void FPT_dataXferProcessor(unsigned long port, PSCCBcard pCurrCard)
 {
    PSCCB currSCCB;
 
@@ -5201,21 +5200,21 @@ static void FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
  * Description:
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
+static void FPT_busMstrSGDataXferStart(unsigned long p_port, PSCCB pcurrSCCB)
 {
-   ULONG count,addr,tmpSGCnt;
+   unsigned long count,addr,tmpSGCnt;
    unsigned int sg_index;
    unsigned char sg_count, i;
-   ULONG reg_offset;
+   unsigned long reg_offset;
 
 
    if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
 
-      count =  ((ULONG) HOST_RD_CMD)<<24;
+      count =  ((unsigned long) HOST_RD_CMD)<<24;
       }
 
    else {
-      count =  ((ULONG) HOST_WRT_CMD)<<24;
+      count =  ((unsigned long) HOST_WRT_CMD)<<24;
       }
 
    sg_count = 0;
@@ -5230,15 +5229,15 @@ static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 	WR_HARPOON(p_port+hp_page_ctrl, i);
 
    while ((sg_count < (unsigned char)SG_BUF_CNT) &&
-      ((ULONG)(sg_index * (unsigned int)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
+      ((unsigned long)(sg_index * (unsigned int)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
 
-      tmpSGCnt += *(((ULONG *)pcurrSCCB->DataPointer)+
+      tmpSGCnt += *(((unsigned long *)pcurrSCCB->DataPointer)+
          (sg_index * 2));
 
-      count |= *(((ULONG *)pcurrSCCB->DataPointer)+
+      count |= *(((unsigned long *)pcurrSCCB->DataPointer)+
          (sg_index * 2));
 
-      addr = *(((ULONG *)pcurrSCCB->DataPointer)+
+      addr = *(((unsigned long *)pcurrSCCB->DataPointer)+
          ((sg_index * 2) + 1));
 
 
@@ -5306,15 +5305,15 @@ static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
  * Description: 
  *
  *---------------------------------------------------------------------*/
-static void FPT_busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
+static void FPT_busMstrDataXferStart(unsigned long p_port, PSCCB pcurrSCCB)
 {
-   ULONG addr,count;
+   unsigned long addr,count;
 
    if (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {
 
       count = pcurrSCCB->Sccb_XferCnt;
 
-      addr = (ULONG) pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
+      addr = (unsigned long) pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
       }
 
    else {
@@ -5359,9 +5358,9 @@ static void FPT_busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
  *               command busy is also time out, it'll just give up.
  *
  *---------------------------------------------------------------------*/
-static unsigned char FPT_busMstrTimeOut(ULONG p_port)
+static unsigned char FPT_busMstrTimeOut(unsigned long p_port)
 {
-   ULONG timeout;
+   unsigned long timeout;
 
    timeout = LONG_WAIT;
 
@@ -5397,11 +5396,11 @@ static unsigned char FPT_busMstrTimeOut(ULONG p_port)
  * Description: Abort any in progress transfer.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrSCCB)
+static void FPT_hostDataXferAbort(unsigned long port, unsigned char p_card, PSCCB pCurrSCCB)
 {
 
-   ULONG timeout;
-   ULONG remain_cnt;
+   unsigned long timeout;
+   unsigned long remain_cnt;
    unsigned int sg_ptr;
 
    FPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
@@ -5464,10 +5463,10 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
 
             sg_ptr--;
 
-            if (remain_cnt > (ULONG)(*(((ULONG *)pCurrSCCB->
+            if (remain_cnt > (unsigned long)(*(((unsigned long *)pCurrSCCB->
                DataPointer) + (sg_ptr * 2)))) {
 
-               remain_cnt -= (ULONG)(*(((ULONG *)pCurrSCCB->
+               remain_cnt -= (unsigned long)(*(((unsigned long *)pCurrSCCB->
                   DataPointer) + (sg_ptr * 2)));
                }
 
@@ -5487,7 +5486,7 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
             pCurrSCCB->Sccb_sgseg = (unsigned short)sg_ptr;
 
 
-            if ((ULONG)(sg_ptr * SG_ELEMENT_SIZE) == pCurrSCCB->DataLength 
+            if ((unsigned long)(sg_ptr * SG_ELEMENT_SIZE) == pCurrSCCB->DataLength
                 && (remain_cnt == 0))
 
                pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
@@ -5624,7 +5623,7 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
          pCurrSCCB->Sccb_SGoffset = 0x00; 
 
 
-         if ((ULONG)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=
+         if ((unsigned long)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=
             pCurrSCCB->DataLength) {
 
             pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
@@ -5657,9 +5656,9 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
  *---------------------------------------------------------------------*/
 static void FPT_hostDataXferRestart(PSCCB currSCCB)
 {
-   ULONG data_count;
+   unsigned long data_count;
    unsigned int  sg_index;
-   ULONG *sg_ptr;
+   unsigned long *sg_ptr;
 
    if (currSCCB->Sccb_XferState & F_SG_XFER) {
 
@@ -5668,7 +5667,7 @@ static void FPT_hostDataXferRestart(PSCCB currSCCB)
       sg_index = 0xffff;         /*Index by long words into sg list. */
       data_count = 0;            /*Running count of SG xfer counts. */
 
-      sg_ptr = (ULONG *)currSCCB->DataPointer;
+      sg_ptr = (unsigned long *)currSCCB->DataPointer;
 
       while (data_count < currSCCB->Sccb_ATC) {
 
@@ -5708,7 +5707,7 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned cha
 {
 
    unsigned char loser,assigned_id;
-   ULONG p_port;
+   unsigned long p_port;
 
    unsigned char i,k,ScamFlg ;
    PSCCBcard currCard;
@@ -5900,7 +5899,7 @@ static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned cha
  *
  *---------------------------------------------------------------------*/
 
-static int FPT_scarb(ULONG p_port, unsigned char p_sel_type)
+static int FPT_scarb(unsigned long p_port, unsigned char p_sel_type)
 {
    if (p_sel_type == INIT_SELTD)
       {
@@ -5961,7 +5960,7 @@ static int FPT_scarb(ULONG p_port, unsigned char p_sel_type)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scbusf(ULONG p_port)
+static void FPT_scbusf(unsigned long p_port)
 {
    WR_HARPOON(p_port+hp_page_ctrl,
       (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
@@ -5997,7 +5996,7 @@ static void FPT_scbusf(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scasid(unsigned char p_card, ULONG p_port)
+static void FPT_scasid(unsigned char p_card, unsigned long p_port)
 {
    unsigned char temp_id_string[ID_STRING_LENGTH];
 
@@ -6085,7 +6084,7 @@ static void FPT_scasid(unsigned char p_card, ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scsel(ULONG p_port)
+static void FPT_scsel(unsigned long p_port)
 {
 
    WR_HARPOON(p_port+hp_scsisig, SCSI_SEL);
@@ -6119,7 +6118,7 @@ static void FPT_scsel(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scxferc(ULONG p_port, unsigned char p_data)
+static unsigned char FPT_scxferc(unsigned long p_port, unsigned char p_data)
 {
    unsigned char curr_data, ret_data;
 
@@ -6170,7 +6169,7 @@ static unsigned char FPT_scxferc(ULONG p_port, unsigned char p_data)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scsendi(ULONG p_port, unsigned char p_id_string[])
+static unsigned char FPT_scsendi(unsigned long p_port, unsigned char p_id_string[])
 {
    unsigned char ret_data,byte_cnt,bit_cnt,defer;
 
@@ -6223,7 +6222,7 @@ static unsigned char FPT_scsendi(ULONG p_port, unsigned char p_id_string[])
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_sciso(ULONG p_port, unsigned char p_id_string[])
+static unsigned char FPT_sciso(unsigned long p_port, unsigned char p_id_string[])
 {
    unsigned char ret_data,the_data,byte_cnt,bit_cnt;
 
@@ -6284,7 +6283,7 @@ static unsigned char FPT_sciso(ULONG p_port, unsigned char p_id_string[])
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwirod(ULONG p_port, unsigned char p_data_bit)
+static void FPT_scwirod(unsigned long p_port, unsigned char p_data_bit)
 {
    unsigned char i;
 
@@ -6313,7 +6312,7 @@ static void FPT_scwirod(ULONG p_port, unsigned char p_data_bit)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwiros(ULONG p_port, unsigned char p_data_bit)
+static void FPT_scwiros(unsigned long p_port, unsigned char p_data_bit)
 {
    unsigned char i;
 
@@ -6367,9 +6366,9 @@ static unsigned char FPT_scvalq(unsigned char p_quintet)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned char FPT_scsell(ULONG p_port, unsigned char targ_id)
+static unsigned char FPT_scsell(unsigned long p_port, unsigned char targ_id)
 {
-   ULONG i;
+   unsigned long i;
 
    WR_HARPOON(p_port+hp_page_ctrl,
       (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
@@ -6446,7 +6445,7 @@ static unsigned char FPT_scsell(ULONG p_port, unsigned char targ_id)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwtsel(ULONG p_port)
+static void FPT_scwtsel(unsigned long p_port)
 {
    while(!(RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL)) {}
 }
@@ -6460,7 +6459,7 @@ static void FPT_scwtsel(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_inisci(unsigned char p_card, ULONG p_port, unsigned char p_our_id)
+static void FPT_inisci(unsigned char p_card, unsigned long p_port, unsigned char p_our_id)
 {
    unsigned char i,k,max_id;
    unsigned short ee_data;
@@ -6653,7 +6652,7 @@ static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_strin
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scsavdi(unsigned char p_card, ULONG p_port)
+static void FPT_scsavdi(unsigned char p_card, unsigned long p_port)
 {
    unsigned char i,k,max_id;
    unsigned short ee_data,sum_data;
@@ -6702,7 +6701,7 @@ static void FPT_scsavdi(unsigned char p_card, ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_XbowInit(ULONG port, unsigned char ScamFlg)
+static void FPT_XbowInit(unsigned long port, unsigned char ScamFlg)
 {
 unsigned char i;
 
@@ -6752,7 +6751,7 @@ unsigned char i;
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_BusMasterInit(ULONG p_port)
+static void FPT_BusMasterInit(unsigned long p_port)
 {
 
 
@@ -6783,7 +6782,7 @@ static void FPT_BusMasterInit(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_DiagEEPROM(ULONG p_port)
+static void FPT_DiagEEPROM(unsigned long p_port)
 {
    unsigned short index,temp,max_wd_cnt;
 
@@ -7416,9 +7415,9 @@ static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card)
 
 static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
 {
-   ULONG partial_cnt;
+   unsigned long partial_cnt;
    unsigned int  sg_index;
-   ULONG *sg_ptr;
+   unsigned long *sg_ptr;
 
    if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {
 
@@ -7431,7 +7430,7 @@ static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
 
 		 sg_index = p_SCCB->Sccb_sgseg;
 
-		 sg_ptr = (ULONG *)p_SCCB->DataPointer;
+		 sg_ptr = (unsigned long *)p_SCCB->DataPointer;
 
 		 if (p_SCCB->Sccb_SGoffset) {
 
@@ -7439,7 +7438,7 @@ static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
 			sg_index++;
 			}
 
-		 while ( ((ULONG)sg_index * (ULONG)SG_ELEMENT_SIZE) <
+		 while ( ((unsigned long)sg_index * (unsigned long)SG_ELEMENT_SIZE) <
 			p_SCCB->DataLength ) {
 
 			partial_cnt += *(sg_ptr+(sg_index * 2));
@@ -7464,7 +7463,7 @@ static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_Wait1Second(ULONG p_port)
+static void FPT_Wait1Second(unsigned long p_port)
 {
    unsigned char i;
 
@@ -7489,7 +7488,7 @@ static void FPT_Wait1Second(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_Wait(ULONG p_port, unsigned char p_delay)
+static void FPT_Wait(unsigned long p_port, unsigned char p_delay)
 {
    unsigned char old_timer;
    unsigned char green_flag;
@@ -7537,7 +7536,7 @@ static void FPT_Wait(ULONG p_port, unsigned char p_delay)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode)
+static void FPT_utilEEWriteOnOff(unsigned long p_port,unsigned char p_mode)
 {
    unsigned char ee_value;
 
@@ -7566,7 +7565,7 @@ static void FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWrite(ULONG p_port, unsigned short ee_data, unsigned short ee_addr)
+static void FPT_utilEEWrite(unsigned long p_port, unsigned short ee_data, unsigned short ee_addr)
 {
 
    unsigned char ee_value;
@@ -7617,7 +7616,7 @@ static void FPT_utilEEWrite(ULONG p_port, unsigned short ee_data, unsigned short
  *
  *---------------------------------------------------------------------*/
 
-static unsigned short FPT_utilEERead(ULONG p_port, unsigned short ee_addr)
+static unsigned short FPT_utilEERead(unsigned long p_port, unsigned short ee_addr)
 {
    unsigned short i, ee_data1, ee_data2;
 
@@ -7647,7 +7646,7 @@ static unsigned short FPT_utilEERead(ULONG p_port, unsigned short ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-static unsigned short FPT_utilEEReadOrg(ULONG p_port, unsigned short ee_addr)
+static unsigned short FPT_utilEEReadOrg(unsigned long p_port, unsigned short ee_addr)
 {
 
    unsigned char ee_value;
@@ -7695,7 +7694,7 @@ static unsigned short FPT_utilEEReadOrg(ULONG p_port, unsigned short ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, unsigned short ee_addr)
+static void FPT_utilEESendCmdAddr(unsigned long p_port, unsigned char ee_cmd, unsigned short ee_addr)
 {
    unsigned char ee_value;
    unsigned char narrow_flg;

commit ce793215b428ae7650b39d87702efa3d5b26ba28
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:26 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove UINT
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 02af5fb73147..a981dea3bbfb 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -40,7 +40,6 @@
 #define FAILURE         0xFFFFFFFFL
 
 
-typedef unsigned int    UINT;
 typedef unsigned long   ULONG;
 
 
@@ -5205,7 +5204,7 @@ static void FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
 static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 {
    ULONG count,addr,tmpSGCnt;
-   UINT sg_index;
+   unsigned int sg_index;
    unsigned char sg_count, i;
    ULONG reg_offset;
 
@@ -5231,7 +5230,7 @@ static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 	WR_HARPOON(p_port+hp_page_ctrl, i);
 
    while ((sg_count < (unsigned char)SG_BUF_CNT) &&
-      ((ULONG)(sg_index * (UINT)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
+      ((ULONG)(sg_index * (unsigned int)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
 
       tmpSGCnt += *(((ULONG *)pcurrSCCB->DataPointer)+
          (sg_index * 2));
@@ -5403,7 +5402,7 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
 
    ULONG timeout;
    ULONG remain_cnt;
-   UINT sg_ptr;
+   unsigned int sg_ptr;
 
    FPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
 
@@ -5454,9 +5453,9 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
 
          sg_ptr = pCurrSCCB->Sccb_sgseg + SG_BUF_CNT;
 
-         if (sg_ptr > (UINT)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE)) {
+         if (sg_ptr > (unsigned int)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE)) {
 
-            sg_ptr = (UINT)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
+            sg_ptr = (unsigned int)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
             }
 
          remain_cnt = pCurrSCCB->Sccb_XferCnt;
@@ -5659,7 +5658,7 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
 static void FPT_hostDataXferRestart(PSCCB currSCCB)
 {
    ULONG data_count;
-   UINT  sg_index;
+   unsigned int  sg_index;
    ULONG *sg_ptr;
 
    if (currSCCB->Sccb_XferState & F_SG_XFER) {
@@ -7418,7 +7417,7 @@ static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card)
 static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
 {
    ULONG partial_cnt;
-   UINT  sg_index;
+   unsigned int  sg_index;
    ULONG *sg_ptr;
 
    if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {

commit c823feeb33161c09e83ee4e68c822d6b9ececbc4
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:25 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove USHORT
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index e98bbef485b8..02af5fb73147 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -40,7 +40,6 @@
 #define FAILURE         0xFFFFFFFFL
 
 
-typedef unsigned short  USHORT;
 typedef unsigned int    UINT;
 typedef unsigned long   ULONG;
 
@@ -59,7 +58,7 @@ typedef unsigned short          * ushort_ptr;
 
 
 #define BIT(x)          ((unsigned char)(1<<(x)))    /* single-bit mask in bit position x */
-#define BITW(x)          ((USHORT)(1<<(x)))  /* single-bit mask in bit position x */
+#define BITW(x)          ((unsigned short)(1<<(x)))  /* single-bit mask in bit position x */
 
 
 
@@ -74,13 +73,13 @@ typedef struct SCCBMgr_info {
    unsigned char    si_intvect;
    unsigned char    si_id;
    unsigned char    si_lun;
-   USHORT   si_fw_revision;
-   USHORT   si_per_targ_init_sync;
-   USHORT   si_per_targ_fast_nego;
-   USHORT   si_per_targ_ultra_nego;
-   USHORT   si_per_targ_no_disc;
-   USHORT   si_per_targ_wide_nego;
-   USHORT   si_flags;
+   unsigned short   si_fw_revision;
+   unsigned short   si_per_targ_init_sync;
+   unsigned short   si_per_targ_fast_nego;
+   unsigned short   si_per_targ_ultra_nego;
+   unsigned short   si_per_targ_no_disc;
+   unsigned short   si_per_targ_wide_nego;
+   unsigned short   si_flags;
    unsigned char    si_card_family;
    unsigned char    si_bustype;
    unsigned char    si_card_model[3];
@@ -143,15 +142,15 @@ typedef struct _SCCB {
    ULONG  SccbIOPort;                        /* Identifies board base port */
    unsigned char  SccbStatus;
    unsigned char  SCCBRes2;
-   USHORT SccbOSFlags;
+   unsigned short SccbOSFlags;
 
 
    ULONG   Sccb_XferCnt;            /* actual transfer count */
    ULONG   Sccb_ATC;
    ULONG   SccbVirtDataPtr;         /* virtual addr for OS/2 */
    ULONG   Sccb_res1;
-   USHORT  Sccb_MGRFlags;
-   USHORT  Sccb_sgseg;
+   unsigned short  Sccb_MGRFlags;
+   unsigned short  Sccb_sgseg;
    unsigned char   Sccb_scsimsg;            /* identify msg for selection */
    unsigned char   Sccb_tag;
    unsigned char   Sccb_scsistat;
@@ -324,7 +323,7 @@ typedef struct SCCBcard {
 
    ULONG ioPort;
 
-   USHORT cmdCounter;
+   unsigned short cmdCounter;
    unsigned char  discQCount;
    unsigned char  tagQ_Lst;
    unsigned char cardIndex;
@@ -943,13 +942,13 @@ typedef struct SCCBscam_info {
 #define GET_XFER_CNT(port, xfercnt) {RD_HARP32(port,hp_xfercnt_0,xfercnt); xfercnt &= 0xFFFFFF;}
 /* #define GET_XFER_CNT(port, xfercnt) (xfercnt = RD_HARPOON(port+hp_xfercnt_2), \
                                  xfercnt <<= 16,\
-                                 xfercnt |= RDW_HARPOON((USHORT)(port+hp_xfercnt_0)))
+                                 xfercnt |= RDW_HARPOON((unsigned short)(port+hp_xfercnt_0)))
  */
-#define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((port+hp_host_addr_lo), (USHORT)(addr & 0x0000FFFFL)),\
+#define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((port+hp_host_addr_lo), (unsigned short)(addr & 0x0000FFFFL)),\
          addr >>= 16,\
-         WRW_HARPOON((port+hp_host_addr_hmi), (USHORT)(addr & 0x0000FFFFL)),\
+         WRW_HARPOON((port+hp_host_addr_hmi), (unsigned short)(addr & 0x0000FFFFL)),\
          WR_HARP32(port,hp_xfercnt_0,count),\
-         WRW_HARPOON((port+hp_xfer_cnt_lo), (USHORT)(count & 0x0000FFFFL)),\
+         WRW_HARPOON((port+hp_xfer_cnt_lo), (unsigned short)(count & 0x0000FFFFL)),\
          count >>= 16,\
          WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))
 
@@ -1016,17 +1015,17 @@ static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);
 static void  FPT_queueAddSccb(PSCCB p_SCCB, unsigned char card);
 static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card);
 static void  FPT_utilUpdateResidual(PSCCB p_SCCB);
-static USHORT FPT_CalcCrc16(unsigned char buffer[]);
+static unsigned short FPT_CalcCrc16(unsigned char buffer[]);
 static unsigned char  FPT_CalcLrc(unsigned char buffer[]);
 
 
 static void  FPT_Wait1Second(ULONG p_port);
 static void  FPT_Wait(ULONG p_port, unsigned char p_delay);
 static void  FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode);
-static void  FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr);
-static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr);
-static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr);
-static void  FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, USHORT ee_addr);
+static void  FPT_utilEEWrite(ULONG p_port, unsigned short ee_data, unsigned short ee_addr);
+static unsigned short FPT_utilEERead(ULONG p_port, unsigned short ee_addr);
+static unsigned short FPT_utilEEReadOrg(ULONG p_port, unsigned short ee_addr);
+static void  FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, unsigned short ee_addr);
 
 
 
@@ -1060,7 +1059,7 @@ static void  FPT_hostDataXferRestart(PSCCB currSCCB);
 
 
 static unsigned char FPT_SccbMgr_bad_isr(ULONG p_port, unsigned char p_card,
-				 PSCCBcard pCurrCard, USHORT p_int);
+				 PSCCBcard pCurrCard, unsigned short p_int);
 
 static void  FPT_SccbMgrTableInitAll(void);
 static void  FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, unsigned char p_card);
@@ -1105,7 +1104,7 @@ static unsigned char FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O',
 				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \
 				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
 
-static USHORT FPT_default_intena = 0;
+static unsigned short FPT_default_intena = 0;
 
 
 static void (*FPT_s_PhaseTbl[8]) (ULONG, unsigned char)= { 0 };
@@ -1124,7 +1123,7 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
    static unsigned char first_time = 1;
 
    unsigned char i,j,id,ScamFlg;
-   USHORT temp,temp2,temp3,temp4,temp5,temp6;
+   unsigned short temp,temp2,temp3,temp4,temp5,temp6;
    ULONG ioport;
 	PNVRamInfo pCurrNvRam;
 
@@ -1203,11 +1202,11 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
    for (id = 0; id < (16/2); id++) {
 
 		if(pCurrNvRam){
-			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = (unsigned short) pCurrNvRam->niSyncTbl[id];
 			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
 					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
 		}else
-	      temp = FPT_utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
+	      temp = FPT_utilEERead(ioport, (unsigned short)((SYNC_RATE_TBL/2)+id));
 
       for (i = 0; i < 2; temp >>=8,i++) {
 
@@ -1402,7 +1401,7 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
    PSCCBcard CurrCard = NULL;
 	PNVRamInfo pCurrNvRam;
    unsigned char i,j,thisCard, ScamFlg;
-   USHORT temp,sync_bit_map,id;
+   unsigned short temp,sync_bit_map,id;
    ULONG ioport;
 
    ioport = pCardInfo->si_baseaddr;
@@ -1532,11 +1531,11 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
    for (id = 0; id < (MAX_SCSI_TAR/2); id++) {
 
 		if(pCurrNvRam){
-			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = (unsigned short) pCurrNvRam->niSyncTbl[id];
 			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
 					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
 		}else
-	      temp = FPT_utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
+	      temp = FPT_utilEERead(ioport, (unsigned short)((SYNC_RATE_TBL/2)+id));
 
       for (i = 0; i < 2; temp >>=8,i++) {
 
@@ -1928,7 +1927,7 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
 {
    PSCCB currSCCB;
    unsigned char thisCard,result,bm_status, bm_int_st;
-   USHORT hp_int;
+   unsigned short hp_int;
    unsigned char i, target;
    ULONG ioport;
 
@@ -2170,7 +2169,7 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
  *
  *---------------------------------------------------------------------*/
 static unsigned char FPT_SccbMgr_bad_isr(ULONG p_port, unsigned char p_card,
-				 PSCCBcard pCurrCard, USHORT p_int)
+				 PSCCBcard pCurrCard, unsigned short p_int)
 {
    unsigned char temp, ScamFlg;
    PSCCBMgr_tar_info currTar_Info;
@@ -2430,7 +2429,7 @@ static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char targe
 static unsigned char FPT_sfm(ULONG port, PSCCB pCurrSCCB)
 {
 	unsigned char message;
-	USHORT TimeOutLoop;
+	unsigned short TimeOutLoop;
 
 	TimeOutLoop = 0;
 	while( (!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
@@ -2775,7 +2774,7 @@ static void FPT_ssel(ULONG port, unsigned char p_card)
 
       }  /* auto_loaded */
 
-   WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
+   WRW_HARPOON((port+hp_fiforead), (unsigned short) 0x00);
    WR_HARPOON(port+hp_xferstat, 0x00);
 
    WRW_HARPOON((port+hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));
@@ -2877,7 +2876,7 @@ static void FPT_sres(ULONG port, unsigned char p_card, PSCCBcard pCurrCard)
       FPT_queueSelectFail(&FPT_BL_Card[p_card],p_card);
 	}
 
-	WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
+	WRW_HARPOON((port+hp_fiforead), (unsigned short) 0x00);
 
 
 	our_target = (unsigned char)(RD_HARPOON(port+hp_select_id) >> 4);
@@ -4056,7 +4055,7 @@ static void FPT_sxfrp(ULONG p_port, unsigned char p_card)
 
 static void FPT_schkdd(ULONG port, unsigned char p_card)
 {
-   USHORT TimeOutLoop;
+   unsigned short TimeOutLoop;
 	unsigned char sPhase;
 
    PSCCB currSCCB;
@@ -4079,7 +4078,7 @@ static void FPT_schkdd(ULONG port, unsigned char p_card)
       currSCCB->Sccb_XferCnt = 1;
 
       currSCCB->Sccb_XferState &= ~F_ODD_BALL_CNT;
-      WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
+      WRW_HARPOON((port+hp_fiforead), (unsigned short) 0x00);
       WR_HARPOON(port+hp_xferstat, 0x00);
       }
 
@@ -5486,7 +5485,7 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
 
             pCurrSCCB->Sccb_SGoffset = remain_cnt;
 
-            pCurrSCCB->Sccb_sgseg = (USHORT)sg_ptr;
+            pCurrSCCB->Sccb_sgseg = (unsigned short)sg_ptr;
 
 
             if ((ULONG)(sg_ptr * SG_ELEMENT_SIZE) == pCurrSCCB->DataLength 
@@ -5631,7 +5630,7 @@ static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrS
 
             pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
 
-            pCurrSCCB->Sccb_sgseg = (USHORT)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
+            pCurrSCCB->Sccb_sgseg = (unsigned short)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
 
             }
          }
@@ -5688,7 +5687,7 @@ static void FPT_hostDataXferRestart(PSCCB currSCCB)
          currSCCB->Sccb_SGoffset = data_count - currSCCB->Sccb_ATC;
          }
 
-      currSCCB->Sccb_sgseg = (USHORT)sg_index;
+      currSCCB->Sccb_sgseg = (unsigned short)sg_index;
       }
 
    else {
@@ -6465,7 +6464,7 @@ static void FPT_scwtsel(ULONG p_port)
 static void FPT_inisci(unsigned char p_card, ULONG p_port, unsigned char p_our_id)
 {
    unsigned char i,k,max_id;
-   USHORT ee_data;
+   unsigned short ee_data;
 	PNVRamInfo pCurrNvRam;
 
 	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
@@ -6495,8 +6494,8 @@ static void FPT_inisci(unsigned char p_card, ULONG p_port, unsigned char p_our_i
    	   {
       	for (k=0; k < ID_STRING_LENGTH; k+=2)
 	         {
-   	      ee_data = FPT_utilEERead(p_port, (USHORT)((EE_SCAMBASE/2) +
-      	     (USHORT) (i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
+   	      ee_data = FPT_utilEERead(p_port, (unsigned short)((EE_SCAMBASE/2) +
+      	     (unsigned short) (i*((unsigned short)ID_STRING_LENGTH/2)) + (unsigned short)(k/2)));
          	FPT_scamInfo[i].id_string[k] = (unsigned char) ee_data;
 	         ee_data >>= 8;
    	      FPT_scamInfo[i].id_string[k+1] = (unsigned char) ee_data;
@@ -6658,7 +6657,7 @@ static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_strin
 static void FPT_scsavdi(unsigned char p_card, ULONG p_port)
 {
    unsigned char i,k,max_id;
-   USHORT ee_data,sum_data;
+   unsigned short ee_data,sum_data;
 
 
    sum_data = 0x0000;
@@ -6686,8 +6685,8 @@ static void FPT_scsavdi(unsigned char p_card, ULONG p_port)
          ee_data <<= 8;
          ee_data |= FPT_scamInfo[i].id_string[k];
          sum_data += ee_data;
-         FPT_utilEEWrite(p_port, ee_data, (USHORT)((EE_SCAMBASE/2) +
-            (USHORT)(i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
+         FPT_utilEEWrite(p_port, ee_data, (unsigned short)((EE_SCAMBASE/2) +
+            (unsigned short)(i*((unsigned short)ID_STRING_LENGTH/2)) + (unsigned short)(k/2)));
          }
       }
 
@@ -6787,7 +6786,7 @@ static void FPT_BusMasterInit(ULONG p_port)
 
 static void FPT_DiagEEPROM(ULONG p_port)
 {
-   USHORT index,temp,max_wd_cnt;
+   unsigned short index,temp,max_wd_cnt;
 
    if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
       max_wd_cnt = EEPROM_WD_CNT;
@@ -7568,11 +7567,11 @@ static void FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
+static void FPT_utilEEWrite(ULONG p_port, unsigned short ee_data, unsigned short ee_addr)
 {
 
    unsigned char ee_value;
-   USHORT i;
+   unsigned short i;
 
    ee_value = (unsigned char)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
 		   (SEE_MS | SEE_CS));
@@ -7619,9 +7618,9 @@ static void FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr)
+static unsigned short FPT_utilEERead(ULONG p_port, unsigned short ee_addr)
 {
-   USHORT i, ee_data1, ee_data2;
+   unsigned short i, ee_data1, ee_data2;
 
 	i = 0;
 	ee_data1 = FPT_utilEEReadOrg(p_port, ee_addr);
@@ -7649,11 +7648,11 @@ static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr)
+static unsigned short FPT_utilEEReadOrg(ULONG p_port, unsigned short ee_addr)
 {
 
    unsigned char ee_value;
-   USHORT i, ee_data;
+   unsigned short i, ee_data;
 
    ee_value = (unsigned char)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
 		   (SEE_MS | SEE_CS));
@@ -7697,12 +7696,12 @@ static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, USHORT ee_addr)
+static void FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, unsigned short ee_addr)
 {
    unsigned char ee_value;
    unsigned char narrow_flg;
 
-   USHORT i;
+   unsigned short i;
 
 
    narrow_flg= (unsigned char)(RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD);
@@ -7760,14 +7759,14 @@ static void FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, USHORT ee_
 	  }
 }
 
-static USHORT FPT_CalcCrc16(unsigned char buffer[])
+static unsigned short FPT_CalcCrc16(unsigned char buffer[])
 {
-   USHORT crc=0;
+   unsigned short crc=0;
 	int i,j;
-   USHORT ch;
+   unsigned short ch;
    for (i=0; i < ID_STRING_LENGTH; i++)
    {
-      ch = (USHORT) buffer[i];
+      ch = (unsigned short) buffer[i];
 	   for(j=0; j < 8; j++)
 	   {
 		   if ((crc ^ ch) & 1)

commit db038cf86fc63d336fc9d8e57712dee1d726e2e9
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:24 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove UCHAR
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 1d1e4413c8d1..e98bbef485b8 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -40,7 +40,6 @@
 #define FAILURE         0xFFFFFFFFL
 
 
-typedef unsigned char   UCHAR;
 typedef unsigned short  USHORT;
 typedef unsigned int    UINT;
 typedef unsigned long   ULONG;
@@ -59,7 +58,7 @@ typedef unsigned short          * ushort_ptr;
 
 
 
-#define BIT(x)          ((UCHAR)(1<<(x)))    /* single-bit mask in bit position x */
+#define BIT(x)          ((unsigned char)(1<<(x)))    /* single-bit mask in bit position x */
 #define BITW(x)          ((USHORT)(1<<(x)))  /* single-bit mask in bit position x */
 
 
@@ -71,10 +70,10 @@ typedef void (*CALL_BK_FN)(PSCCB);
 
 typedef struct SCCBMgr_info {
    ULONG    si_baseaddr;
-   UCHAR    si_present;
-   UCHAR    si_intvect;
-   UCHAR    si_id;
-   UCHAR    si_lun;
+   unsigned char    si_present;
+   unsigned char    si_intvect;
+   unsigned char    si_id;
+   unsigned char    si_lun;
    USHORT   si_fw_revision;
    USHORT   si_per_targ_init_sync;
    USHORT   si_per_targ_fast_nego;
@@ -82,13 +81,13 @@ typedef struct SCCBMgr_info {
    USHORT   si_per_targ_no_disc;
    USHORT   si_per_targ_wide_nego;
    USHORT   si_flags;
-   UCHAR    si_card_family;
-   UCHAR    si_bustype;
-   UCHAR    si_card_model[3];
-   UCHAR    si_relative_cardnum;
-   UCHAR    si_reserved[4];
+   unsigned char    si_card_family;
+   unsigned char    si_bustype;
+   unsigned char    si_card_model[3];
+   unsigned char    si_relative_cardnum;
+   unsigned char    si_reserved[4];
    ULONG    si_OS_reserved;
-   UCHAR    si_XlatInfo[4];
+   unsigned char    si_XlatInfo[4];
    ULONG    si_reserved2[5];
    ULONG    si_secondary_range;
 } SCCBMGR_INFO;
@@ -122,28 +121,28 @@ typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
 
 #pragma pack(1)
 typedef struct _SCCB {
-   UCHAR OperationCode;
-   UCHAR ControlByte;
-   UCHAR CdbLength;
-   UCHAR RequestSenseLength;
+   unsigned char OperationCode;
+   unsigned char ControlByte;
+   unsigned char CdbLength;
+   unsigned char RequestSenseLength;
    ULONG DataLength;
    ULONG DataPointer;
-   UCHAR CcbRes[2];
-   UCHAR HostStatus;
-   UCHAR TargetStatus;
-   UCHAR TargID;
-   UCHAR Lun;
-   UCHAR Cdb[12];
-   UCHAR CcbRes1;
-   UCHAR Reserved1;
+   unsigned char CcbRes[2];
+   unsigned char HostStatus;
+   unsigned char TargetStatus;
+   unsigned char TargID;
+   unsigned char Lun;
+   unsigned char Cdb[12];
+   unsigned char CcbRes1;
+   unsigned char Reserved1;
    ULONG Reserved2;
    ULONG SensePointer;
 
 
    CALL_BK_FN SccbCallback;                  /* VOID (*SccbCallback)(); */
    ULONG  SccbIOPort;                        /* Identifies board base port */
-   UCHAR  SccbStatus;
-   UCHAR  SCCBRes2;
+   unsigned char  SccbStatus;
+   unsigned char  SCCBRes2;
    USHORT SccbOSFlags;
 
 
@@ -153,16 +152,16 @@ typedef struct _SCCB {
    ULONG   Sccb_res1;
    USHORT  Sccb_MGRFlags;
    USHORT  Sccb_sgseg;
-   UCHAR   Sccb_scsimsg;            /* identify msg for selection */
-   UCHAR   Sccb_tag;
-   UCHAR   Sccb_scsistat;
-   UCHAR   Sccb_idmsg;              /* image of last msg in */
+   unsigned char   Sccb_scsimsg;            /* identify msg for selection */
+   unsigned char   Sccb_tag;
+   unsigned char   Sccb_scsistat;
+   unsigned char   Sccb_idmsg;              /* image of last msg in */
    PSCCB   Sccb_forwardlink;
    PSCCB   Sccb_backlink;
    ULONG   Sccb_savedATC;
-   UCHAR   Save_Cdb[6];
-   UCHAR   Save_CdbLen;
-   UCHAR   Sccb_XferState;
+   unsigned char   Save_Cdb[6];
+   unsigned char   Save_CdbLen;
+   unsigned char   Sccb_XferState;
    ULONG   Sccb_SGoffset;
    } SCCB;
 
@@ -288,27 +287,27 @@ typedef struct SCCBMgr_tar_info {
 
    PSCCB    TarSelQ_Head;
    PSCCB    TarSelQ_Tail;
-   UCHAR    TarLUN_CA;        /*Contingent Allgiance */
-   UCHAR    TarTagQ_Cnt;
-   UCHAR    TarSelQ_Cnt;
-   UCHAR    TarStatus;
-   UCHAR    TarEEValue;
-   UCHAR 	TarSyncCtrl;
-   UCHAR 	TarReserved[2];			/* for alignment */ 
-   UCHAR 	LunDiscQ_Idx[MAX_LUN];
-   UCHAR    TarLUNBusy[MAX_LUN];
+   unsigned char    TarLUN_CA;        /*Contingent Allgiance */
+   unsigned char    TarTagQ_Cnt;
+   unsigned char    TarSelQ_Cnt;
+   unsigned char    TarStatus;
+   unsigned char    TarEEValue;
+   unsigned char 	TarSyncCtrl;
+   unsigned char 	TarReserved[2];			/* for alignment */
+   unsigned char 	LunDiscQ_Idx[MAX_LUN];
+   unsigned char    TarLUNBusy[MAX_LUN];
 } SCCBMGR_TAR_INFO;
 
 typedef struct NVRAMInfo {
-	UCHAR		niModel;								/* Model No. of card */
-	UCHAR		niCardNo;							/* Card no. */
+	unsigned char		niModel;								/* Model No. of card */
+	unsigned char		niCardNo;							/* Card no. */
 	ULONG		niBaseAddr;							/* Port Address of card */
-	UCHAR		niSysConf;							/* Adapter Configuration byte - Byte 16 of eeprom map */
-	UCHAR		niScsiConf;							/* SCSI Configuration byte - Byte 17 of eeprom map */
-	UCHAR		niScamConf;							/* SCAM Configuration byte - Byte 20 of eeprom map */
-	UCHAR		niAdapId;							/* Host Adapter ID - Byte 24 of eerpom map */
-	UCHAR		niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
-	UCHAR		niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
+	unsigned char		niSysConf;							/* Adapter Configuration byte - Byte 16 of eeprom map */
+	unsigned char		niScsiConf;							/* SCSI Configuration byte - Byte 17 of eeprom map */
+	unsigned char		niScamConf;							/* SCAM Configuration byte - Byte 20 of eeprom map */
+	unsigned char		niAdapId;							/* Host Adapter ID - Byte 24 of eerpom map */
+	unsigned char		niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
+	unsigned char		niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
 }NVRAMINFO;
 
 typedef NVRAMINFO *PNVRamInfo;
@@ -326,12 +325,12 @@ typedef struct SCCBcard {
    ULONG ioPort;
 
    USHORT cmdCounter;
-   UCHAR  discQCount;
-   UCHAR  tagQ_Lst; 
-   UCHAR cardIndex;
-   UCHAR scanIndex;
-   UCHAR globalFlags;
-   UCHAR ourId;
+   unsigned char  discQCount;
+   unsigned char  tagQ_Lst;
+   unsigned char cardIndex;
+   unsigned char scanIndex;
+   unsigned char globalFlags;
+   unsigned char ourId;
    PNVRamInfo pNvRamInfo;
    PSCCB discQ_Tbl[QUEUE_DEPTH]; 
       
@@ -379,7 +378,7 @@ enum scam_id_st { ID0,ID1,ID2,ID3,ID4,ID5,ID6,ID7,ID8,ID9,ID10,ID11,ID12,
 
 typedef struct SCCBscam_info {
 
-   UCHAR    id_string[ID_STRING_LENGTH];
+   unsigned char    id_string[ID_STRING_LENGTH];
    enum scam_id_st state;
     
 } SCCBSCAM_INFO;
@@ -981,72 +980,72 @@ typedef struct SCCBscam_info {
 
 
 
-static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag);
-static void  FPT_ssel(ULONG port, UCHAR p_card);
-static void  FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard);
-static void  FPT_shandem(ULONG port, UCHAR p_card,PSCCB pCurrSCCB);
-static void  FPT_stsyncn(ULONG port, UCHAR p_card);
-static void  FPT_sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset);
-static void  FPT_sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,
+static unsigned char FPT_sisyncn(ULONG port, unsigned char p_card, unsigned char syncFlag);
+static void  FPT_ssel(ULONG port, unsigned char p_card);
+static void  FPT_sres(ULONG port, unsigned char p_card, PSCCBcard pCurrCard);
+static void  FPT_shandem(ULONG port, unsigned char p_card,PSCCB pCurrSCCB);
+static void  FPT_stsyncn(ULONG port, unsigned char p_card);
+static void  FPT_sisyncr(ULONG port,unsigned char sync_pulse, unsigned char offset);
+static void  FPT_sssyncv(ULONG p_port, unsigned char p_id, unsigned char p_sync_value,
 			 PSCCBMgr_tar_info currTar_Info);
-static void  FPT_sresb(ULONG port, UCHAR p_card);
-static void  FPT_sxfrp(ULONG p_port, UCHAR p_card);
-static void  FPT_schkdd(ULONG port, UCHAR p_card);
-static UCHAR FPT_RdStack(ULONG port, UCHAR index);
-static void  FPT_WrStack(ULONG portBase, UCHAR index, UCHAR data);
-static UCHAR FPT_ChkIfChipInitialized(ULONG ioPort);
-
-static void FPT_SendMsg(ULONG port, UCHAR message);
-static void  FPT_queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg,
-				    UCHAR error_code);
-
-static void  FPT_sinits(PSCCB p_sccb, UCHAR p_card);
+static void  FPT_sresb(ULONG port, unsigned char p_card);
+static void  FPT_sxfrp(ULONG p_port, unsigned char p_card);
+static void  FPT_schkdd(ULONG port, unsigned char p_card);
+static unsigned char FPT_RdStack(ULONG port, unsigned char index);
+static void  FPT_WrStack(ULONG portBase, unsigned char index, unsigned char data);
+static unsigned char FPT_ChkIfChipInitialized(ULONG ioPort);
+
+static void FPT_SendMsg(ULONG port, unsigned char message);
+static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
+				    unsigned char error_code);
+
+static void  FPT_sinits(PSCCB p_sccb, unsigned char p_card);
 static void  FPT_RNVRamData(PNVRamInfo pNvRamInfo);
 
-static UCHAR FPT_siwidn(ULONG port, UCHAR p_card);
-static void  FPT_stwidn(ULONG port, UCHAR p_card);
-static void  FPT_siwidr(ULONG port, UCHAR width);
+static unsigned char FPT_siwidn(ULONG port, unsigned char p_card);
+static void  FPT_stwidn(ULONG port, unsigned char p_card);
+static void  FPT_siwidr(ULONG port, unsigned char width);
 
 
-static void  FPT_queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card);
-static void  FPT_queueDisconnect(PSCCB p_SCCB, UCHAR p_card);
+static void  FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card);
+static void  FPT_queueDisconnect(PSCCB p_SCCB, unsigned char p_card);
 static void  FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_SCCB,
-				  UCHAR p_card);
-static void  FPT_queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card);
-static void  FPT_queueFlushSccb(UCHAR p_card, UCHAR error_code);
-static void  FPT_queueAddSccb(PSCCB p_SCCB, UCHAR card);
-static UCHAR FPT_queueFindSccb(PSCCB p_SCCB, UCHAR p_card);
+				  unsigned char p_card);
+static void  FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card);
+static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);
+static void  FPT_queueAddSccb(PSCCB p_SCCB, unsigned char card);
+static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card);
 static void  FPT_utilUpdateResidual(PSCCB p_SCCB);
-static USHORT FPT_CalcCrc16(UCHAR buffer[]);
-static UCHAR  FPT_CalcLrc(UCHAR buffer[]);
+static USHORT FPT_CalcCrc16(unsigned char buffer[]);
+static unsigned char  FPT_CalcLrc(unsigned char buffer[]);
 
 
 static void  FPT_Wait1Second(ULONG p_port);
-static void  FPT_Wait(ULONG p_port, UCHAR p_delay);
-static void  FPT_utilEEWriteOnOff(ULONG p_port,UCHAR p_mode);
+static void  FPT_Wait(ULONG p_port, unsigned char p_delay);
+static void  FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode);
 static void  FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr);
 static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr);
 static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr);
-static void  FPT_utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr);
+static void  FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, USHORT ee_addr);
 
 
 
-static void  FPT_phaseDataOut(ULONG port, UCHAR p_card);
-static void  FPT_phaseDataIn(ULONG port, UCHAR p_card);
-static void  FPT_phaseCommand(ULONG port, UCHAR p_card);
-static void  FPT_phaseStatus(ULONG port, UCHAR p_card);
-static void  FPT_phaseMsgOut(ULONG port, UCHAR p_card);
-static void  FPT_phaseMsgIn(ULONG port, UCHAR p_card);
-static void  FPT_phaseIllegal(ULONG port, UCHAR p_card);
+static void  FPT_phaseDataOut(ULONG port, unsigned char p_card);
+static void  FPT_phaseDataIn(ULONG port, unsigned char p_card);
+static void  FPT_phaseCommand(ULONG port, unsigned char p_card);
+static void  FPT_phaseStatus(ULONG port, unsigned char p_card);
+static void  FPT_phaseMsgOut(ULONG port, unsigned char p_card);
+static void  FPT_phaseMsgIn(ULONG port, unsigned char p_card);
+static void  FPT_phaseIllegal(ULONG port, unsigned char p_card);
 
-static void  FPT_phaseDecode(ULONG port, UCHAR p_card);
-static void  FPT_phaseChkFifo(ULONG port, UCHAR p_card);
-static void  FPT_phaseBusFree(ULONG p_port, UCHAR p_card);
+static void  FPT_phaseDecode(ULONG port, unsigned char p_card);
+static void  FPT_phaseChkFifo(ULONG port, unsigned char p_card);
+static void  FPT_phaseBusFree(ULONG p_port, unsigned char p_card);
 
 
 
 
-static void  FPT_XbowInit(ULONG port, UCHAR scamFlg);
+static void  FPT_XbowInit(ULONG port, unsigned char scamFlg);
 static void  FPT_BusMasterInit(ULONG p_port);
 static void  FPT_DiagEEPROM(ULONG p_port);
 
@@ -1056,39 +1055,39 @@ static void  FPT_DiagEEPROM(ULONG p_port);
 static void  FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard);
 static void  FPT_busMstrSGDataXferStart(ULONG port, PSCCB pCurrSCCB);
 static void  FPT_busMstrDataXferStart(ULONG port, PSCCB pCurrSCCB);
-static void  FPT_hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB);
+static void  FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrSCCB);
 static void  FPT_hostDataXferRestart(PSCCB currSCCB);
 
 
-static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
+static unsigned char FPT_SccbMgr_bad_isr(ULONG p_port, unsigned char p_card,
 				 PSCCBcard pCurrCard, USHORT p_int);
 
 static void  FPT_SccbMgrTableInitAll(void);
-static void  FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card);
-static void  FPT_SccbMgrTableInitTarget(UCHAR p_card, UCHAR target);
+static void  FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, unsigned char p_card);
+static void  FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char target);
 
 
 
-static void  FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up);
+static void  FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned char p_power_up);
 
-static int   FPT_scarb(ULONG p_port, UCHAR p_sel_type);
+static int   FPT_scarb(ULONG p_port, unsigned char p_sel_type);
 static void  FPT_scbusf(ULONG p_port);
 static void  FPT_scsel(ULONG p_port);
-static void  FPT_scasid(UCHAR p_card, ULONG p_port);
-static UCHAR FPT_scxferc(ULONG p_port, UCHAR p_data);
-static UCHAR FPT_scsendi(ULONG p_port, UCHAR p_id_string[]);
-static UCHAR FPT_sciso(ULONG p_port, UCHAR p_id_string[]);
-static void  FPT_scwirod(ULONG p_port, UCHAR p_data_bit);
-static void  FPT_scwiros(ULONG p_port, UCHAR p_data_bit);
-static UCHAR FPT_scvalq(UCHAR p_quintet);
-static UCHAR FPT_scsell(ULONG p_port, UCHAR targ_id);
+static void  FPT_scasid(unsigned char p_card, ULONG p_port);
+static unsigned char FPT_scxferc(ULONG p_port, unsigned char p_data);
+static unsigned char FPT_scsendi(ULONG p_port, unsigned char p_id_string[]);
+static unsigned char FPT_sciso(ULONG p_port, unsigned char p_id_string[]);
+static void  FPT_scwirod(ULONG p_port, unsigned char p_data_bit);
+static void  FPT_scwiros(ULONG p_port, unsigned char p_data_bit);
+static unsigned char FPT_scvalq(unsigned char p_quintet);
+static unsigned char FPT_scsell(ULONG p_port, unsigned char targ_id);
 static void  FPT_scwtsel(ULONG p_port);
-static void  FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id);
-static void  FPT_scsavdi(UCHAR p_card, ULONG p_port);
-static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[]);
+static void  FPT_inisci(unsigned char p_card, ULONG p_port, unsigned char p_our_id);
+static void  FPT_scsavdi(unsigned char p_card, ULONG p_port);
+static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_string[]);
 
 
-static void  FPT_autoCmdCmplt(ULONG p_port, UCHAR p_card);
+static void  FPT_autoCmdCmplt(ULONG p_port, unsigned char p_card);
 static void  FPT_autoLoadDefaultMap(ULONG p_port);
 
 
@@ -1100,8 +1099,8 @@ static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
 static NVRAMINFO FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
 
 
-static UCHAR FPT_mbCards = 0;
-static UCHAR FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C', \
+static unsigned char FPT_mbCards = 0;
+static unsigned char FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C', \
 				   ' ', 'B', 'T', '-', '9', '3', '0', \
 				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \
 				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
@@ -1109,7 +1108,7 @@ static UCHAR FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I'
 static USHORT FPT_default_intena = 0;
 
 
-static void (*FPT_s_PhaseTbl[8]) (ULONG, UCHAR)= { 0 };
+static void (*FPT_s_PhaseTbl[8]) (ULONG, unsigned char)= { 0 };
 
 
 /*---------------------------------------------------------------------
@@ -1122,9 +1121,9 @@ static void (*FPT_s_PhaseTbl[8]) (ULONG, UCHAR)= { 0 };
 
 static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 {
-   static UCHAR first_time = 1;
+   static unsigned char first_time = 1;
 
-   UCHAR i,j,id,ScamFlg;
+   unsigned char i,j,id,ScamFlg;
    USHORT temp,temp2,temp3,temp4,temp5,temp6;
    ULONG ioport;
 	PNVRamInfo pCurrNvRam;
@@ -1190,8 +1189,8 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 	if(pCurrNvRam)
 		pCardInfo->si_id = pCurrNvRam->niAdapId;
 	else
-	   pCardInfo->si_id = (UCHAR)(FPT_utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
-   	   (UCHAR)0x0FF);
+	   pCardInfo->si_id = (unsigned char)(FPT_utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
+   	   (unsigned char)0x0FF);
 
    pCardInfo->si_lun = 0x00;
    pCardInfo->si_fw_revision = ORION_FW_REV;
@@ -1247,12 +1246,12 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 	if(pCurrNvRam)
 		i = pCurrNvRam->niSysConf;
 	else
-	   i = (UCHAR)(FPT_utilEERead(ioport, (SYSTEM_CONFIG/2)));
+	   i = (unsigned char)(FPT_utilEERead(ioport, (SYSTEM_CONFIG/2)));
 
 	if(pCurrNvRam)
 		ScamFlg = pCurrNvRam->niScamConf;
 	else
-	   ScamFlg = (UCHAR) FPT_utilEERead(ioport, SCAM_CONFIG/2);
+	   ScamFlg = (unsigned char) FPT_utilEERead(ioport, SCAM_CONFIG/2);
 
    pCardInfo->si_flags = 0x0000;
 
@@ -1312,11 +1311,11 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 		}
 	}else{
 	   temp = FPT_utilEERead(ioport, (MODEL_NUMB_0/2));
-   	pCardInfo->si_card_model[0] = (UCHAR)(temp >> 8);
+   	pCardInfo->si_card_model[0] = (unsigned char)(temp >> 8);
 	   temp = FPT_utilEERead(ioport, (MODEL_NUMB_2/2));
 
-   	pCardInfo->si_card_model[1] = (UCHAR)(temp & 0x00FF);
-	   pCardInfo->si_card_model[2] = (UCHAR)(temp >> 8);
+   	pCardInfo->si_card_model[1] = (unsigned char)(temp & 0x00FF);
+	   pCardInfo->si_card_model[2] = (unsigned char)(temp >> 8);
 	}
 
    if (pCardInfo->si_card_model[1] == '3')
@@ -1371,7 +1370,7 @@ static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 	   logical card number sorted by BIOS (zero-based) */
 
 	pCardInfo->si_relative_cardnum =
-	(UCHAR)(RD_HARPOON(ioport+hp_aramBase+BIOS_RELATIVE_CARD)-1);
+	(unsigned char)(RD_HARPOON(ioport+hp_aramBase+BIOS_RELATIVE_CARD)-1);
 
    SGRAM_ACCESS(ioport);
 
@@ -1402,7 +1401,7 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
 {
    PSCCBcard CurrCard = NULL;
 	PNVRamInfo pCurrNvRam;
-   UCHAR i,j,thisCard, ScamFlg;
+   unsigned char i,j,thisCard, ScamFlg;
    USHORT temp,sync_bit_map,id;
    ULONG ioport;
 
@@ -1446,7 +1445,7 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
 		ScamFlg = pCurrNvRam->niScamConf;
 	}
 	else{
-	   ScamFlg = (UCHAR) FPT_utilEERead(ioport, SCAM_CONFIG/2);
+	   ScamFlg = (unsigned char) FPT_utilEERead(ioport, SCAM_CONFIG/2);
 	}
 
 
@@ -1463,7 +1462,7 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
    WR_HARPOON(ioport+hp_arb_id, pCardInfo->si_id);
    CurrCard->ourId = pCardInfo->si_id;
 
-   i = (UCHAR) pCardInfo->si_flags;
+   i = (unsigned char) pCardInfo->si_flags;
    if (i & SCSI_PARITY_ENA)
        WR_HARPOON(ioport+hp_portctrl_1,(HOST_MODE8 | CHK_SCSI_P));
 
@@ -1543,13 +1542,13 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
 
          if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
 
-            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue = (UCHAR)temp;
+            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue = (unsigned char)temp;
             }
 
          else {
 	    FPT_sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
             FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue =
-               (UCHAR)(temp & ~EE_SYNC_MASK);
+               (unsigned char)(temp & ~EE_SYNC_MASK);
             }
 
 /*         if ((pCardInfo->si_per_targ_wide_nego & sync_bit_map) ||
@@ -1574,14 +1573,14 @@ static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
       }
 
    WR_HARPOON((ioport+hp_semaphore),
-      (UCHAR)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
+      (unsigned char)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
 
    return((ULONG)CurrCard);
 }
 
 static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
 {
-	UCHAR i;
+	unsigned char i;
 	ULONG portBase;
 	ULONG regOffset;
 	ULONG scamData;
@@ -1598,7 +1597,7 @@ static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
 		FPT_WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);
 
 		for(i = 0; i < MAX_SCSI_TAR / 2; i++)
-			FPT_WrStack(pCurrNvRam->niBaseAddr, (UCHAR)(i+5), pCurrNvRam->niSyncTbl[i]);
+			FPT_WrStack(pCurrNvRam->niBaseAddr, (unsigned char)(i+5), pCurrNvRam->niSyncTbl[i]);
 
 		portBase = pCurrNvRam->niBaseAddr;
 
@@ -1617,7 +1616,7 @@ static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
 
 static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
 {
-	UCHAR i;
+	unsigned char i;
 	ULONG portBase;
 	ULONG regOffset;
 	ULONG scamData;
@@ -1630,7 +1629,7 @@ static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
 	pNvRamInfo->niAdapId   = FPT_RdStack(pNvRamInfo->niBaseAddr, 4);
 
 	for(i = 0; i < MAX_SCSI_TAR / 2; i++)
-		pNvRamInfo->niSyncTbl[i] = FPT_RdStack(pNvRamInfo->niBaseAddr, (UCHAR)(i+5));
+		pNvRamInfo->niSyncTbl[i] = FPT_RdStack(pNvRamInfo->niBaseAddr, (unsigned char)(i+5));
 
 	portBase = pNvRamInfo->niBaseAddr;
 
@@ -1643,20 +1642,20 @@ static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
 
 }
 
-static UCHAR FPT_RdStack(ULONG portBase, UCHAR index)
+static unsigned char FPT_RdStack(ULONG portBase, unsigned char index)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	return(RD_HARPOON(portBase + hp_stack_data));
 }
 
-static void FPT_WrStack(ULONG portBase, UCHAR index, UCHAR data)
+static void FPT_WrStack(ULONG portBase, unsigned char index, unsigned char data)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	WR_HARPOON(portBase + hp_stack_data, data);
 }
 
 
-static UCHAR FPT_ChkIfChipInitialized(ULONG ioPort)
+static unsigned char FPT_ChkIfChipInitialized(ULONG ioPort)
 {
 	if((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
 		return(0);
@@ -1681,7 +1680,7 @@ static UCHAR FPT_ChkIfChipInitialized(ULONG ioPort)
 static void FlashPoint_StartCCB(ULONG pCurrCard, PSCCB p_Sccb)
 {
    ULONG ioport;
-   UCHAR thisCard, lun;
+   unsigned char thisCard, lun;
 	PSCCB pSaveSccb;
    CALL_BK_FN callback;
 
@@ -1802,9 +1801,9 @@ static int FlashPoint_AbortCCB(ULONG pCurrCard, PSCCB p_Sccb)
 {
 	ULONG ioport;
 
-	UCHAR thisCard;
+	unsigned char thisCard;
 	CALL_BK_FN callback;
-	UCHAR TID;
+	unsigned char TID;
 	PSCCB pSaveSCCB;
 	PSCCBMgr_tar_info currTar_Info;
 
@@ -1823,7 +1822,7 @@ static int FlashPoint_AbortCCB(ULONG pCurrCard, PSCCB p_Sccb)
 
 			if (!((PSCCBcard)pCurrCard)->cmdCounter)
 				WR_HARPOON(ioport+hp_semaphore,(RD_HARPOON(ioport+hp_semaphore)
-					& (UCHAR)(~(SCCB_MGR_ACTIVE | TICKLE_ME)) ));
+					& (unsigned char)(~(SCCB_MGR_ACTIVE | TICKLE_ME)) ));
 
 			p_Sccb->SccbStatus = SCCB_ABORT;
 			callback = p_Sccb->SccbCallback;
@@ -1898,7 +1897,7 @@ static int FlashPoint_AbortCCB(ULONG pCurrCard, PSCCB p_Sccb)
  *              interrupt for this card and disable the IRQ Pin if so.
  *
  *---------------------------------------------------------------------*/
-static UCHAR FlashPoint_InterruptPending(ULONG pCurrCard)
+static unsigned char FlashPoint_InterruptPending(ULONG pCurrCard)
 {
    ULONG ioport;
 
@@ -1928,9 +1927,9 @@ static UCHAR FlashPoint_InterruptPending(ULONG pCurrCard)
 static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
 {
    PSCCB currSCCB;
-   UCHAR thisCard,result,bm_status, bm_int_st;
+   unsigned char thisCard,result,bm_status, bm_int_st;
    USHORT hp_int;
-   UCHAR i, target;
+   unsigned char i, target;
    ULONG ioport;
 
    thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
@@ -1939,7 +1938,7 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
    MDISABLE_INT(ioport);
 
    if ((bm_int_st=RD_HARPOON(ioport+hp_int_status)) & EXT_STATUS_ON)
-		bm_status = RD_HARPOON(ioport+hp_ext_status) & (UCHAR)BAD_EXT_STATUS;
+		bm_status = RD_HARPOON(ioport+hp_ext_status) & (unsigned char)BAD_EXT_STATUS;
    else
       bm_status = 0;
 
@@ -2080,7 +2079,7 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
       else if ( (hp_int & IUNKWN) || (hp_int & PROG_HLT) )
 		   {
 	 	   WRW_HARPOON((ioport+hp_intstat), (PHASE | IUNKWN | PROG_HLT));
-	 	   if ((RD_HARPOON(ioport+hp_prgmcnt_0) & (UCHAR)0x3f)< (UCHAR)SELCHK)
+	 	   if ((RD_HARPOON(ioport+hp_prgmcnt_0) & (unsigned char)0x3f)< (unsigned char)SELCHK)
 	    		{
 	    		FPT_phaseDecode(ioport,thisCard);
 	    		}
@@ -2093,11 +2092,11 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
    reg. (0x53) also increment the FIFO write addr reg (0x6f), thus we
    need to read this reg first then restore it later. After update to 0x53 */
 
-	    		i = (UCHAR)(RD_HARPOON(ioport+hp_fifowrite));
-	    		target = (UCHAR)(RD_HARPOON(ioport+hp_gp_reg_3));
-	    		WR_HARPOON(ioport+hp_xfer_pad, (UCHAR) ID_UNLOCK);
-	    		WR_HARPOON(ioport+hp_select_id, (UCHAR)(target | target<<4));
-	    		WR_HARPOON(ioport+hp_xfer_pad, (UCHAR) 0x00);
+	    		i = (unsigned char)(RD_HARPOON(ioport+hp_fifowrite));
+	    		target = (unsigned char)(RD_HARPOON(ioport+hp_gp_reg_3));
+	    		WR_HARPOON(ioport+hp_xfer_pad, (unsigned char) ID_UNLOCK);
+	    		WR_HARPOON(ioport+hp_select_id, (unsigned char)(target | target<<4));
+	    		WR_HARPOON(ioport+hp_xfer_pad, (unsigned char) 0x00);
 	    		WR_HARPOON(ioport+hp_fifowrite, i);
 	    		WR_HARPOON(ioport+hp_autostart_3, (AUTO_IMMED+TAG_STRT));
 	    		}
@@ -2170,10 +2169,10 @@ static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
  *              processing time.
  *
  *---------------------------------------------------------------------*/
-static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
+static unsigned char FPT_SccbMgr_bad_isr(ULONG p_port, unsigned char p_card,
 				 PSCCBcard pCurrCard, USHORT p_int)
 {
-   UCHAR temp, ScamFlg;
+   unsigned char temp, ScamFlg;
    PSCCBMgr_tar_info currTar_Info;
    PNVRamInfo pCurrNvRam;
 
@@ -2206,9 +2205,9 @@ static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
 
          FPT_sxfrp(p_port,p_card);
 
-	     temp = (UCHAR)(RD_HARPOON(p_port+hp_ee_ctrl) &
+	     temp = (unsigned char)(RD_HARPOON(p_port+hp_ee_ctrl) &
 							(EXT_ARB_ACK | SCSI_TERM_ENA_H));
-      	WR_HARPOON(p_port+hp_ee_ctrl, ((UCHAR)temp | SEE_MS | SEE_CS));
+      	WR_HARPOON(p_port+hp_ee_ctrl, ((unsigned char)temp | SEE_MS | SEE_CS));
          WR_HARPOON(p_port+hp_ee_ctrl, temp);
 
          if (!(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
@@ -2243,7 +2242,7 @@ static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
 					ScamFlg = pCurrNvRam->niScamConf;
 				}
 				else{
-				   ScamFlg = (UCHAR) FPT_utilEERead(p_port, SCAM_CONFIG/2);
+				   ScamFlg = (unsigned char) FPT_utilEERead(p_port, SCAM_CONFIG/2);
 				}
 
            FPT_XbowInit(p_port, ScamFlg);
@@ -2324,7 +2323,7 @@ static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
 
 static void FPT_SccbMgrTableInitAll()
 {
-   UCHAR thisCard;
+   unsigned char thisCard;
 
    for (thisCard = 0; thisCard < MAX_CARDS; thisCard++)
       {
@@ -2347,9 +2346,9 @@ static void FPT_SccbMgrTableInitAll()
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card)
+static void FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, unsigned char p_card)
 {
-   UCHAR scsiID, qtag;
+   unsigned char scsiID, qtag;
 
 	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
 	{
@@ -2382,10 +2381,10 @@ static void FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_SccbMgrTableInitTarget(UCHAR p_card, UCHAR target)
+static void FPT_SccbMgrTableInitTarget(unsigned char p_card, unsigned char target)
 {
 
-	UCHAR lun, qtag;
+	unsigned char lun, qtag;
 	PSCCBMgr_tar_info currTar_Info;
 
 	currTar_Info = &FPT_sccbMgrTbl[p_card][target];
@@ -2428,9 +2427,9 @@ static void FPT_SccbMgrTableInitTarget(UCHAR p_card, UCHAR target)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_sfm(ULONG port, PSCCB pCurrSCCB)
+static unsigned char FPT_sfm(ULONG port, PSCCB pCurrSCCB)
 {
-	UCHAR message;
+	unsigned char message;
 	USHORT TimeOutLoop;
 
 	TimeOutLoop = 0;
@@ -2501,16 +2500,16 @@ static UCHAR FPT_sfm(ULONG port, PSCCB pCurrSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_ssel(ULONG port, UCHAR p_card)
+static void FPT_ssel(ULONG port, unsigned char p_card)
 {
 
-   UCHAR auto_loaded, i, target, *theCCB;
+   unsigned char auto_loaded, i, target, *theCCB;
 
    ULONG cdb_reg;
    PSCCBcard CurrCard;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
-   UCHAR lastTag, lun;
+   unsigned char lastTag, lun;
 
    CurrCard = &FPT_BL_Card[p_card];
    currSCCB = CurrCard->currentSCCB;
@@ -2656,8 +2655,8 @@ static void FPT_ssel(ULONG port, UCHAR p_card)
       WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
 
 			WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+
-								(((UCHAR)(currSCCB->ControlByte & TAG_TYPE_MASK)
-								>> 6) | (UCHAR)0x20)));
+								(((unsigned char)(currSCCB->ControlByte & TAG_TYPE_MASK)
+								>> 6) | (unsigned char)0x20)));
 			WRW_HARPOON((port+SYNC_MSGS+2),
 							(MPM_OP+AMSG_OUT+currSCCB->Sccb_tag));
 			WRW_HARPOON((port+SYNC_MSGS+4), (BRH_OP+ALWAYS+NP ));
@@ -2713,8 +2712,8 @@ static void FPT_ssel(ULONG port, UCHAR p_card)
             WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
 
             WRW_HARPOON((port+ID_MSG_STRT+2), (MPM_OP+AMSG_OUT+
-                        (((UCHAR)(currSCCB->ControlByte & TAG_TYPE_MASK)
-                        >> 6) | (UCHAR)0x20)));
+                        (((unsigned char)(currSCCB->ControlByte & TAG_TYPE_MASK)
+                        >> 6) | (unsigned char)0x20)));
 
 				for (i = 1; i < QUEUE_DEPTH; i++)
 				{
@@ -2760,7 +2759,7 @@ static void FPT_ssel(ULONG port, UCHAR p_card)
          }
 
 
-      theCCB = (UCHAR *)&currSCCB->Cdb[0];
+      theCCB = (unsigned char *)&currSCCB->Cdb[0];
 
       cdb_reg = port + CMD_STRT;
 
@@ -2791,7 +2790,7 @@ static void FPT_ssel(ULONG port, UCHAR p_card)
    else
       {
 
-/*      auto_loaded =  (RD_HARPOON(port+hp_autostart_3) & (UCHAR)0x1F);
+/*      auto_loaded =  (RD_HARPOON(port+hp_autostart_3) & (unsigned char)0x1F);
       auto_loaded |= AUTO_IMMED; */
       auto_loaded = AUTO_IMMED;
 
@@ -2812,10 +2811,10 @@ static void FPT_ssel(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
+static void FPT_sres(ULONG port, unsigned char p_card, PSCCBcard pCurrCard)
 {
 
-   UCHAR our_target, message, lun = 0, tag, msgRetryCount;
+   unsigned char our_target, message, lun = 0, tag, msgRetryCount;
 
 
    PSCCBMgr_tar_info currTar_Info;
@@ -2881,7 +2880,7 @@ static void FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 	WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
 
 
-	our_target = (UCHAR)(RD_HARPOON(port+hp_select_id) >> 4);
+	our_target = (unsigned char)(RD_HARPOON(port+hp_select_id) >> 4);
 	currTar_Info = &FPT_sccbMgrTbl[p_card][our_target];
 
 
@@ -2913,7 +2912,7 @@ static void FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 
 				if (message <= (0x80 | LUN_MASK))
 				{
-					lun = message & (UCHAR)LUN_MASK;
+					lun = message & (unsigned char)LUN_MASK;
 
 					if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING)
 					{
@@ -3073,7 +3072,7 @@ static void FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 	  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
 }
 
-static void FPT_SendMsg(ULONG port, UCHAR message)
+static void FPT_SendMsg(ULONG port, unsigned char message)
 {
 	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
 	{
@@ -3122,7 +3121,7 @@ static void FPT_SendMsg(ULONG port, UCHAR message)
  *              target device.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
+static void FPT_sdecm(unsigned char message, ULONG port, unsigned char p_card)
 {
 	PSCCB currSCCB;
 	PSCCBcard CurrCard;
@@ -3152,8 +3151,8 @@ static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
 
 		if (currSCCB->Sccb_scsistat == SELECT_Q_ST)
 		{
-			currTar_Info->TarStatus &= ~(UCHAR)TAR_TAG_Q_MASK;
-			currTar_Info->TarStatus |= (UCHAR)TAG_Q_REJECT;
+			currTar_Info->TarStatus &= ~(unsigned char)TAR_TAG_Q_MASK;
+			currTar_Info->TarStatus |= (unsigned char)TAG_Q_REJECT;
 		}
 
 		ACCEPT_MSG(port);
@@ -3190,7 +3189,7 @@ static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
 				if ((currSCCB->Sccb_scsistat == SELECT_SN_ST))
 				{
 
-					currTar_Info->TarStatus |= (UCHAR)SYNC_SUPPORTED;
+					currTar_Info->TarStatus |= (unsigned char)SYNC_SUPPORTED;
 
 					currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
 				}
@@ -3209,7 +3208,7 @@ static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
 				else if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING )
 				{
 					currTar_Info->TarStatus = (currTar_Info->TarStatus &
-													~(UCHAR)TAR_TAG_Q_MASK) | TAG_Q_REJECT;
+													~(unsigned char)TAR_TAG_Q_MASK) | TAG_Q_REJECT;
 
 
 					currSCCB->ControlByte &= ~F_USE_CMD_Q;
@@ -3241,7 +3240,7 @@ static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
 					currTar_Info->TarLUNBusy[0] = 1;
 
 
-				currSCCB->ControlByte &= ~(UCHAR)F_USE_CMD_Q;
+				currSCCB->ControlByte &= ~(unsigned char)F_USE_CMD_Q;
 
 				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
 
@@ -3301,9 +3300,9 @@ static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
  * Description: Decide what to do with the extended message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
+static void FPT_shandem(ULONG port, unsigned char p_card, PSCCB pCurrSCCB)
 {
-	UCHAR length,message;
+	unsigned char length,message;
 
 	length = FPT_sfm(port,pCurrSCCB);
 	if (length) 
@@ -3380,7 +3379,7 @@ static void FPT_shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
+static unsigned char FPT_sisyncn(ULONG port, unsigned char p_card, unsigned char syncFlag)
 {
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
@@ -3392,7 +3391,7 @@ static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
 
 
       WRW_HARPOON((port+ID_MSG_STRT),
-                 (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(UCHAR)DISC_PRIV)));
+                 (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV)));
 
       WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
 
@@ -3426,7 +3425,7 @@ static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
 		{
 		   WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
 	      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-   	      ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_TRYING);
+   	      ~(unsigned char)TAR_SYNC_MASK) | (unsigned char)SYNC_TRYING);
 		}
 		else
 		{
@@ -3439,7 +3438,7 @@ static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
 
    else {
 
-      currTar_Info->TarStatus |=	 (UCHAR)SYNC_SUPPORTED;
+      currTar_Info->TarStatus |=	 (unsigned char)SYNC_SUPPORTED;
       currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
       return(0);
       }
@@ -3455,9 +3454,9 @@ static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-static void FPT_stsyncn(ULONG port, UCHAR p_card)
+static void FPT_stsyncn(ULONG port, unsigned char p_card)
 {
-   UCHAR sync_msg,offset,sync_reg,our_sync_msg;
+   unsigned char sync_msg,offset,sync_reg,our_sync_msg;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
@@ -3562,7 +3561,7 @@ static void FPT_stsyncn(ULONG port, UCHAR p_card)
       ACCEPT_MSG(port);
 
       currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-         ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_SUPPORTED);
+         ~(unsigned char)TAR_SYNC_MASK) | (unsigned char)SYNC_SUPPORTED);
 
       WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
       }
@@ -3575,7 +3574,7 @@ static void FPT_stsyncn(ULONG port, UCHAR p_card)
       FPT_sisyncr(port,sync_msg,offset);
 
       currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-         ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_SUPPORTED);
+         ~(unsigned char)TAR_SYNC_MASK) | (unsigned char)SYNC_SUPPORTED);
       }
 }
 
@@ -3587,7 +3586,7 @@ static void FPT_stsyncn(ULONG port, UCHAR p_card)
  * Description: Answer the targets sync message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset)
+static void FPT_sisyncr(ULONG port,unsigned char sync_pulse, unsigned char offset)
 {
    ARAM_ACCESS(port);
    WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
@@ -3618,7 +3617,7 @@ static void FPT_sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_siwidn(ULONG port, UCHAR p_card)
+static unsigned char FPT_siwidn(ULONG port, unsigned char p_card)
 {
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
@@ -3630,7 +3629,7 @@ static UCHAR FPT_siwidn(ULONG port, UCHAR p_card)
 
 
       WRW_HARPOON((port+ID_MSG_STRT),
-	              (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(UCHAR)DISC_PRIV)));
+	              (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV)));
 
       WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
 
@@ -3645,7 +3644,7 @@ static UCHAR FPT_siwidn(ULONG port, UCHAR p_card)
 
 
       currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-         ~(UCHAR)TAR_WIDE_MASK) | (UCHAR)WIDE_ENABLED);
+         ~(unsigned char)TAR_WIDE_MASK) | (unsigned char)WIDE_ENABLED);
 
       return(1);
       }
@@ -3653,7 +3652,7 @@ static UCHAR FPT_siwidn(ULONG port, UCHAR p_card)
    else {
 
       currTar_Info->TarStatus = ((currTar_Info->TarStatus &
-               ~(UCHAR)TAR_WIDE_MASK) | WIDE_NEGOCIATED);
+               ~(unsigned char)TAR_WIDE_MASK) | WIDE_NEGOCIATED);
 
       currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
       return(0);
@@ -3670,9 +3669,9 @@ static UCHAR FPT_siwidn(ULONG port, UCHAR p_card)
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-static void FPT_stwidn(ULONG port, UCHAR p_card)
+static void FPT_stwidn(ULONG port, unsigned char p_card)
 {
-   UCHAR width;
+   unsigned char width;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
@@ -3750,7 +3749,7 @@ static void FPT_stwidn(ULONG port, UCHAR p_card)
  * Description: Answer the targets Wide nego message.
  *
  *---------------------------------------------------------------------*/
-static void FPT_siwidr(ULONG port, UCHAR width)
+static void FPT_siwidr(ULONG port, unsigned char width)
 {
    ARAM_ACCESS(port);
    WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
@@ -3779,10 +3778,10 @@ static void FPT_siwidr(ULONG port, UCHAR width)
  *              ID specified.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,
+static void FPT_sssyncv(ULONG p_port, unsigned char p_id, unsigned char p_sync_value,
 			PSCCBMgr_tar_info currTar_Info)
 {
-   UCHAR index;
+   unsigned char index;
 
    index = p_id;
 
@@ -3851,9 +3850,9 @@ static void FPT_sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,
  * Description: Reset the desired card's SCSI bus.
  *
  *---------------------------------------------------------------------*/
-static void FPT_sresb(ULONG port, UCHAR p_card)
+static void FPT_sresb(ULONG port, unsigned char p_card)
 {
-   UCHAR scsiID, i;
+   unsigned char scsiID, i;
 
    PSCCBMgr_tar_info currTar_Info;
 
@@ -3926,7 +3925,7 @@ static void FPT_sresb(ULONG port, UCHAR p_card)
  *---------------------------------------------------------------------*/
 static void FPT_ssenss(PSCCBcard pCurrCard)
 {
-   UCHAR i;
+   unsigned char i;
    PSCCB currSCCB;
 
    currSCCB = pCurrCard->currentSCCB;
@@ -3941,7 +3940,7 @@ static void FPT_ssenss(PSCCBcard pCurrCard)
 
    currSCCB->CdbLength = SIX_BYTE_CMD;
    currSCCB->Cdb[0]    = SCSI_REQUEST_SENSE;
-   currSCCB->Cdb[1]    = currSCCB->Cdb[1] & (UCHAR)0xE0; /*Keep LUN. */
+   currSCCB->Cdb[1]    = currSCCB->Cdb[1] & (unsigned char)0xE0; /*Keep LUN. */
    currSCCB->Cdb[2]    = 0x00;
    currSCCB->Cdb[3]    = 0x00;
    currSCCB->Cdb[4]    = currSCCB->RequestSenseLength;
@@ -3955,7 +3954,7 @@ static void FPT_ssenss(PSCCBcard pCurrCard)
 
    currSCCB->Sccb_XferState &= ~F_SG_XFER;
 
-   currSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(UCHAR)DISC_PRIV;
+   currSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV;
 
    currSCCB->ControlByte = 0x00;
 
@@ -3973,9 +3972,9 @@ static void FPT_ssenss(PSCCBcard pCurrCard)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sxfrp(ULONG p_port, UCHAR p_card)
+static void FPT_sxfrp(ULONG p_port, unsigned char p_card)
 {
-   UCHAR curr_phz;
+   unsigned char curr_phz;
 
 
    DISABLE_AUTO(p_port);
@@ -3994,7 +3993,7 @@ static void FPT_sxfrp(ULONG p_port, UCHAR p_card)
 
    WR_HARPOON(p_port+hp_xfercnt_0, 0x00);
 
-   curr_phz = RD_HARPOON(p_port+hp_scsisig) & (UCHAR)S_SCSI_PHZ;
+   curr_phz = RD_HARPOON(p_port+hp_scsisig) & (unsigned char)S_SCSI_PHZ;
 
    WRW_HARPOON((p_port+hp_intstat), XFER_CNT_0);
 
@@ -4002,9 +4001,9 @@ static void FPT_sxfrp(ULONG p_port, UCHAR p_card)
    WR_HARPOON(p_port+hp_scsisig, curr_phz);
 
    while ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)) &&
-      (curr_phz == (RD_HARPOON(p_port+hp_scsisig) & (UCHAR)S_SCSI_PHZ)) )
+      (curr_phz == (RD_HARPOON(p_port+hp_scsisig) & (unsigned char)S_SCSI_PHZ)) )
       {
-      if (curr_phz & (UCHAR)SCSI_IOBIT)
+      if (curr_phz & (unsigned char)SCSI_IOBIT)
          {
       	WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | SCSI_INBIT));
 
@@ -4055,10 +4054,10 @@ static void FPT_sxfrp(ULONG p_port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_schkdd(ULONG port, UCHAR p_card)
+static void FPT_schkdd(ULONG port, unsigned char p_card)
 {
    USHORT TimeOutLoop;
-	UCHAR sPhase;
+	unsigned char sPhase;
 
    PSCCB currSCCB;
 
@@ -4112,7 +4111,7 @@ static void FPT_schkdd(ULONG port, UCHAR p_card)
       if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE) {
 	      return;
    	   }
-      if (RD_HARPOON(port+hp_offsetctr) & (UCHAR)0x1F) {
+      if (RD_HARPOON(port+hp_offsetctr) & (unsigned char)0x1F) {
 	      break;
    	   }
       if (RDW_HARPOON((port+hp_intstat)) & RESET) {
@@ -4124,7 +4123,7 @@ static void FPT_schkdd(ULONG port, UCHAR p_card)
 
 	sPhase = RD_HARPOON(port+hp_scsisig) & (SCSI_BSY | S_SCSI_PHZ);
    if ((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))                     ||
-      (RD_HARPOON(port+hp_offsetctr) & (UCHAR)0x1F)                       ||
+      (RD_HARPOON(port+hp_offsetctr) & (unsigned char)0x1F)                       ||
       (sPhase == (SCSI_BSY | S_DATAO_PH)) ||
       (sPhase == (SCSI_BSY | S_DATAI_PH)))
       {
@@ -4168,7 +4167,7 @@ static void FPT_schkdd(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_sinits(PSCCB p_sccb, UCHAR p_card)
+static void FPT_sinits(PSCCB p_sccb, unsigned char p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
 
@@ -4213,12 +4212,12 @@ static void FPT_sinits(PSCCB p_sccb, UCHAR p_card)
 */
    if ((currTar_Info->TarStatus & TAR_ALLOW_DISC) ||
       (currTar_Info->TarStatus & TAG_Q_TRYING)) {
-      p_sccb->Sccb_idmsg      = (UCHAR)(SMIDENT | DISC_PRIV) | p_sccb->Lun;
+      p_sccb->Sccb_idmsg      = (unsigned char)(SMIDENT | DISC_PRIV) | p_sccb->Lun;
       }
 
    else {
 
-      p_sccb->Sccb_idmsg      = (UCHAR)SMIDENT | p_sccb->Lun;
+      p_sccb->Sccb_idmsg      = (unsigned char)SMIDENT | p_sccb->Lun;
       }
 
    p_sccb->HostStatus         = 0x00;
@@ -4248,15 +4247,15 @@ static void FPT_sinits(PSCCB p_sccb, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDecode(ULONG p_port, UCHAR p_card)
+static void FPT_phaseDecode(ULONG p_port, unsigned char p_card)
 {
    unsigned char phase_ref;
-   void (*phase) (ULONG, UCHAR);
+   void (*phase) (ULONG, unsigned char);
 
 
    DISABLE_AUTO(p_port);
 
-   phase_ref = (UCHAR) (RD_HARPOON(p_port+hp_scsisig) & S_SCSI_PHZ);
+   phase_ref = (unsigned char) (RD_HARPOON(p_port+hp_scsisig) & S_SCSI_PHZ);
 
    phase = FPT_s_PhaseTbl[phase_ref];
 
@@ -4273,7 +4272,7 @@ static void FPT_phaseDecode(ULONG p_port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDataOut(ULONG port, UCHAR p_card)
+static void FPT_phaseDataOut(ULONG port, unsigned char p_card)
 {
 
    PSCCB currSCCB;
@@ -4317,7 +4316,7 @@ static void FPT_phaseDataOut(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseDataIn(ULONG port, UCHAR p_card)
+static void FPT_phaseDataIn(ULONG port, unsigned char p_card)
 {
 
    PSCCB currSCCB;
@@ -4364,11 +4363,11 @@ static void FPT_phaseDataIn(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseCommand(ULONG p_port, UCHAR p_card)
+static void FPT_phaseCommand(ULONG p_port, unsigned char p_card)
 {
    PSCCB currSCCB;
    ULONG cdb_reg;
-   UCHAR i;
+   unsigned char i;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -4416,7 +4415,7 @@ static void FPT_phaseCommand(ULONG p_port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseStatus(ULONG port, UCHAR p_card)
+static void FPT_phaseStatus(ULONG port, unsigned char p_card)
 {
    /* Start-up the automation to finish off this command and let the
       isr handle the interrupt for command complete when it comes in.
@@ -4438,9 +4437,9 @@ static void FPT_phaseStatus(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseMsgOut(ULONG port, UCHAR p_card)
+static void FPT_phaseMsgOut(ULONG port, unsigned char p_card)
 {
-	UCHAR message,scsiID;
+	unsigned char message,scsiID;
 	PSCCB currSCCB;
 	PSCCBMgr_tar_info currTar_Info;
 
@@ -4586,9 +4585,9 @@ static void FPT_phaseMsgOut(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseMsgIn(ULONG port, UCHAR p_card)
+static void FPT_phaseMsgIn(ULONG port, unsigned char p_card)
 {
-	UCHAR message;
+	unsigned char message;
 	PSCCB currSCCB;
 
 	currSCCB = FPT_BL_Card[p_card].currentSCCB;
@@ -4639,7 +4638,7 @@ static void FPT_phaseMsgIn(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseIllegal(ULONG port, UCHAR p_card)
+static void FPT_phaseIllegal(ULONG port, unsigned char p_card)
 {
    PSCCB currSCCB;
 
@@ -4667,7 +4666,7 @@ static void FPT_phaseIllegal(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_phaseChkFifo(ULONG port, UCHAR p_card)
+static void FPT_phaseChkFifo(ULONG port, unsigned char p_card)
 {
    ULONG xfercnt;
    PSCCB currSCCB;
@@ -4745,7 +4744,7 @@ static void FPT_phaseChkFifo(ULONG port, UCHAR p_card)
  *              because of command complete or from a disconnect.
  *
  *---------------------------------------------------------------------*/
-static void FPT_phaseBusFree(ULONG port, UCHAR p_card)
+static void FPT_phaseBusFree(ULONG port, unsigned char p_card)
 {
    PSCCB currSCCB;
 
@@ -4775,7 +4774,7 @@ static void FPT_phaseBusFree(ULONG port, UCHAR p_card)
       else if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
 	      {
 	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
-			         (UCHAR)SYNC_SUPPORTED;
+			         (unsigned char)SYNC_SUPPORTED;
 	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
 	      }
 
@@ -4951,10 +4950,10 @@ static void FPT_autoLoadDefaultMap(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_autoCmdCmplt(ULONG p_port, UCHAR p_card)
+static void FPT_autoCmdCmplt(ULONG p_port, unsigned char p_card)
 {
    PSCCB currSCCB;
-   UCHAR status_byte;
+   unsigned char status_byte;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
@@ -5001,7 +5000,7 @@ static void FPT_autoCmdCmplt(ULONG p_port, UCHAR p_card)
       if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
          {
          FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
-            (UCHAR)SYNC_SUPPORTED;
+            (unsigned char)SYNC_SUPPORTED;
 
 	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
          FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
@@ -5177,7 +5176,7 @@ static void FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
 			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
 
 				{
-		   	currSCCB->Sccb_sgseg += (UCHAR)SG_BUF_CNT;
+		   	currSCCB->Sccb_sgseg += (unsigned char)SG_BUF_CNT;
          	currSCCB->Sccb_SGoffset = 0x00; 
  				}
 			pCurrCard->globalFlags |= F_HOST_XFER_ACT;
@@ -5208,7 +5207,7 @@ static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 {
    ULONG count,addr,tmpSGCnt;
    UINT sg_index;
-   UCHAR sg_count, i;
+   unsigned char sg_count, i;
    ULONG reg_offset;
 
 
@@ -5227,12 +5226,12 @@ static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
    reg_offset = hp_aramBase;
 
 
-	i = (UCHAR) (RD_HARPOON(p_port+hp_page_ctrl) & ~(SGRAM_ARAM|SCATTER_EN));
+	i = (unsigned char) (RD_HARPOON(p_port+hp_page_ctrl) & ~(SGRAM_ARAM|SCATTER_EN));
 
 
 	WR_HARPOON(p_port+hp_page_ctrl, i);
 
-   while ((sg_count < (UCHAR)SG_BUF_CNT) &&
+   while ((sg_count < (unsigned char)SG_BUF_CNT) &&
       ((ULONG)(sg_index * (UINT)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
 
       tmpSGCnt += *(((ULONG *)pcurrSCCB->DataPointer)+
@@ -5297,7 +5296,7 @@ static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
       }
 
 
-   WR_HARPOON(p_port+hp_page_ctrl, (UCHAR) (i | SCATTER_EN));
+   WR_HARPOON(p_port+hp_page_ctrl, (unsigned char) (i | SCATTER_EN));
 
 }
 
@@ -5362,7 +5361,7 @@ static void FPT_busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
  *               command busy is also time out, it'll just give up.
  *
  *---------------------------------------------------------------------*/
-static UCHAR FPT_busMstrTimeOut(ULONG p_port)
+static unsigned char FPT_busMstrTimeOut(ULONG p_port)
 {
    ULONG timeout;
 
@@ -5400,7 +5399,7 @@ static UCHAR FPT_busMstrTimeOut(ULONG p_port)
  * Description: Abort any in progress transfer.
  *
  *---------------------------------------------------------------------*/
-static void FPT_hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
+static void FPT_hostDataXferAbort(ULONG port, unsigned char p_card, PSCCB pCurrSCCB)
 {
 
    ULONG timeout;
@@ -5707,13 +5706,13 @@ static void FPT_hostDataXferRestart(PSCCB currSCCB)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
+static void FPT_scini(unsigned char p_card, unsigned char p_our_id, unsigned char p_power_up)
 {
 
-   UCHAR loser,assigned_id;
+   unsigned char loser,assigned_id;
    ULONG p_port;
 
-   UCHAR i,k,ScamFlg ;
+   unsigned char i,k,ScamFlg ;
    PSCCBcard currCard;
 	PNVRamInfo pCurrNvRam;
 
@@ -5727,8 +5726,8 @@ static void FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
 		i = pCurrNvRam->niSysConf;
 	}
 	else{
-	   ScamFlg = (UCHAR) FPT_utilEERead(p_port, SCAM_CONFIG/2);
-	   i = (UCHAR)(FPT_utilEERead(p_port, (SYSTEM_CONFIG/2)));
+	   ScamFlg = (unsigned char) FPT_utilEERead(p_port, SCAM_CONFIG/2);
+	   i = (unsigned char)(FPT_utilEERead(p_port, (SYSTEM_CONFIG/2)));
 	}
 	if(!(i & 0x02))	/* check if reset bus in AutoSCSI parameter set */
 		return;
@@ -5846,7 +5845,7 @@ static void FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
                      if (FPT_scvalq(k))
                         {
                         currCard->ourId =
-                           ((UCHAR)(i<<3)+(k & (UCHAR)7)) & (UCHAR) 0x3F;
+                           ((unsigned char)(i<<3)+(k & (unsigned char)7)) & (unsigned char) 0x3F;
                         FPT_inisci(p_card, p_port, p_our_id);
                         FPT_scamInfo[currCard->ourId].state = ID_ASSIGNED;
                         FPT_scamInfo[currCard->ourId].id_string[0]
@@ -5903,7 +5902,7 @@ static void FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
  *
  *---------------------------------------------------------------------*/
 
-static int FPT_scarb(ULONG p_port, UCHAR p_sel_type)
+static int FPT_scarb(ULONG p_port, unsigned char p_sel_type)
 {
    if (p_sel_type == INIT_SELTD)
       {
@@ -6000,12 +5999,12 @@ static void FPT_scbusf(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scasid(UCHAR p_card, ULONG p_port)
+static void FPT_scasid(unsigned char p_card, ULONG p_port)
 {
-   UCHAR temp_id_string[ID_STRING_LENGTH];
+   unsigned char temp_id_string[ID_STRING_LENGTH];
 
-   UCHAR i,k,scam_id;
-	UCHAR crcBytes[3];
+   unsigned char i,k,scam_id;
+	unsigned char crcBytes[3];
 	PNVRamInfo pCurrNvRam;
 	ushort_ptr pCrcBytes;
 
@@ -6018,7 +6017,7 @@ static void FPT_scasid(UCHAR p_card, ULONG p_port)
 
       for (k=0; k < ID_STRING_LENGTH; k++)
          {
-         temp_id_string[k] = (UCHAR) 0x00;
+         temp_id_string[k] = (unsigned char) 0x00;
          }
 
       FPT_scxferc(p_port,SYNC_PTRN);
@@ -6034,7 +6033,7 @@ static void FPT_scasid(UCHAR p_card, ULONG p_port)
 				temp_id_string[2] = crcBytes[0];
 				temp_id_string[3] = crcBytes[1];
 				for(k = 4; k < ID_STRING_LENGTH; k++)
-					temp_id_string[k] = (UCHAR) 0x00;
+					temp_id_string[k] = (unsigned char) 0x00;
 			}
          i = FPT_scmachid(p_card,temp_id_string);
 
@@ -6052,7 +6051,7 @@ static void FPT_scasid(UCHAR p_card, ULONG p_port)
             else
                FPT_scxferc(p_port,ID_8_F);
 
-            scam_id = (i & (UCHAR) 0x07);
+            scam_id = (i & (unsigned char) 0x07);
 
 
             for (k=1; k < 0x08; k <<= 1)
@@ -6098,15 +6097,15 @@ static void FPT_scsel(ULONG p_port)
 
 
    WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
-   WR_HARPOON(p_port+hp_scsidata_0, (UCHAR)(RD_HARPOON(p_port+hp_scsidata_0) |
-      (UCHAR)(BIT(7)+BIT(6))));
+   WR_HARPOON(p_port+hp_scsidata_0, (unsigned char)(RD_HARPOON(p_port+hp_scsidata_0) |
+      (unsigned char)(BIT(7)+BIT(6))));
 
 
    WR_HARPOON(p_port+hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));
    FPT_scwiros(p_port, SCSI_SEL);
 
-   WR_HARPOON(p_port+hp_scsidata_0, (UCHAR)(RD_HARPOON(p_port+hp_scsidata_0) &
-      ~(UCHAR)BIT(6)));
+   WR_HARPOON(p_port+hp_scsidata_0, (unsigned char)(RD_HARPOON(p_port+hp_scsidata_0) &
+      ~(unsigned char)BIT(6)));
    FPT_scwirod(p_port, BIT(6));
 
    WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
@@ -6122,9 +6121,9 @@ static void FPT_scsel(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_scxferc(ULONG p_port, UCHAR p_data)
+static unsigned char FPT_scxferc(ULONG p_port, unsigned char p_data)
 {
-   UCHAR curr_data, ret_data;
+   unsigned char curr_data, ret_data;
 
    curr_data = p_data | BIT(7) | BIT(5);   /*Start with DB7 & DB5 asserted. */
 
@@ -6137,7 +6136,7 @@ static UCHAR FPT_scxferc(ULONG p_port, UCHAR p_data)
    FPT_scwirod(p_port,BIT(7));              /*Wait for DB7 to be released. */
 	while (!(RD_HARPOON(p_port+hp_scsidata_0) & BIT(5)));
 
-   ret_data = (RD_HARPOON(p_port+hp_scsidata_0) & (UCHAR) 0x1F);
+   ret_data = (RD_HARPOON(p_port+hp_scsidata_0) & (unsigned char) 0x1F);
 
    curr_data |= BIT(6);
 
@@ -6173,9 +6172,9 @@ static UCHAR FPT_scxferc(ULONG p_port, UCHAR p_data)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_scsendi(ULONG p_port, UCHAR p_id_string[])
+static unsigned char FPT_scsendi(ULONG p_port, unsigned char p_id_string[])
 {
-   UCHAR ret_data,byte_cnt,bit_cnt,defer;
+   unsigned char ret_data,byte_cnt,bit_cnt,defer;
 
    defer = 0;
 
@@ -6226,9 +6225,9 @@ static UCHAR FPT_scsendi(ULONG p_port, UCHAR p_id_string[])
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_sciso(ULONG p_port, UCHAR p_id_string[])
+static unsigned char FPT_sciso(ULONG p_port, unsigned char p_id_string[])
 {
-   UCHAR ret_data,the_data,byte_cnt,bit_cnt;
+   unsigned char ret_data,the_data,byte_cnt,bit_cnt;
 
    the_data = 0;
 
@@ -6287,9 +6286,9 @@ static UCHAR FPT_sciso(ULONG p_port, UCHAR p_id_string[])
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwirod(ULONG p_port, UCHAR p_data_bit)
+static void FPT_scwirod(ULONG p_port, unsigned char p_data_bit)
 {
-   UCHAR i;
+   unsigned char i;
 
    i = 0;
    while ( i < MAX_SCSI_TAR ) {
@@ -6316,9 +6315,9 @@ static void FPT_scwirod(ULONG p_port, UCHAR p_data_bit)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scwiros(ULONG p_port, UCHAR p_data_bit)
+static void FPT_scwiros(ULONG p_port, unsigned char p_data_bit)
 {
-   UCHAR i;
+   unsigned char i;
 
    i = 0;
    while ( i < MAX_SCSI_TAR ) {
@@ -6343,9 +6342,9 @@ static void FPT_scwiros(ULONG p_port, UCHAR p_data_bit)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_scvalq(UCHAR p_quintet)
+static unsigned char FPT_scvalq(unsigned char p_quintet)
 {
-   UCHAR count;
+   unsigned char count;
 
    for (count=1; count < 0x08; count<<=1) {
       if (!(p_quintet & count))
@@ -6370,7 +6369,7 @@ static UCHAR FPT_scvalq(UCHAR p_quintet)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_scsell(ULONG p_port, UCHAR targ_id)
+static unsigned char FPT_scsell(ULONG p_port, unsigned char targ_id)
 {
    ULONG i;
 
@@ -6463,9 +6462,9 @@ static void FPT_scwtsel(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
+static void FPT_inisci(unsigned char p_card, ULONG p_port, unsigned char p_our_id)
 {
-   UCHAR i,k,max_id;
+   unsigned char i,k,max_id;
    USHORT ee_data;
 	PNVRamInfo pCurrNvRam;
 
@@ -6483,7 +6482,7 @@ static void FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
 			for(k = 0; k < 4; k++)
 				FPT_scamInfo[i].id_string[k] = pCurrNvRam->niScamTbl[i][k];
 			for(k = 4; k < ID_STRING_LENGTH; k++)
-				FPT_scamInfo[i].id_string[k] = (UCHAR) 0x00;
+				FPT_scamInfo[i].id_string[k] = (unsigned char) 0x00;
 
 	      if(FPT_scamInfo[i].id_string[0] == 0x00)
       	   FPT_scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
@@ -6498,9 +6497,9 @@ static void FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
 	         {
    	      ee_data = FPT_utilEERead(p_port, (USHORT)((EE_SCAMBASE/2) +
       	     (USHORT) (i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
-         	FPT_scamInfo[i].id_string[k] = (UCHAR) ee_data;
+         	FPT_scamInfo[i].id_string[k] = (unsigned char) ee_data;
 	         ee_data >>= 8;
-   	      FPT_scamInfo[i].id_string[k+1] = (UCHAR) ee_data;
+   	      FPT_scamInfo[i].id_string[k+1] = (unsigned char) ee_data;
       	   }
 
 	      if ((FPT_scamInfo[i].id_string[0] == 0x00) ||
@@ -6527,10 +6526,10 @@ static void FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[])
+static unsigned char FPT_scmachid(unsigned char p_card, unsigned char p_id_string[])
 {
 
-   UCHAR i,k,match;
+   unsigned char i,k,match;
 
 
    for (i=0; i < MAX_SCSI_TAR; i++) {
@@ -6559,7 +6558,7 @@ static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[])
       i = MAX_SCSI_TAR;
 
    if (((p_id_string[0] & 0x06) == 0x02) || ((p_id_string[0] & 0x06) == 0x04))
-      match = p_id_string[1] & (UCHAR) 0x1F;
+      match = p_id_string[1] & (unsigned char) 0x1F;
    else
       match = 7;
 
@@ -6608,7 +6607,7 @@ static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[])
       i = MAX_SCSI_TAR;
 
    if (((p_id_string[0] & 0x06) == 0x02) || ((p_id_string[0] & 0x06) == 0x04))
-      match = p_id_string[1] & (UCHAR) 0x1F;
+      match = p_id_string[1] & (unsigned char) 0x1F;
    else
       match = 7;
 
@@ -6656,9 +6655,9 @@ static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[])
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_scsavdi(UCHAR p_card, ULONG p_port)
+static void FPT_scsavdi(unsigned char p_card, ULONG p_port)
 {
-   UCHAR i,k,max_id;
+   unsigned char i,k,max_id;
    USHORT ee_data,sum_data;
 
 
@@ -6705,12 +6704,12 @@ static void FPT_scsavdi(UCHAR p_card, ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_XbowInit(ULONG port, UCHAR ScamFlg)
+static void FPT_XbowInit(ULONG port, unsigned char ScamFlg)
 {
-UCHAR i;
+unsigned char i;
 
 	i = RD_HARPOON(port+hp_page_ctrl);
-	WR_HARPOON(port+hp_page_ctrl, (UCHAR) (i | G_INT_DISABLE));
+	WR_HARPOON(port+hp_page_ctrl, (unsigned char) (i | G_INT_DISABLE));
 
    WR_HARPOON(port+hp_scsireset,0x00);
    WR_HARPOON(port+hp_portctrl_1,HOST_MODE8);
@@ -6812,7 +6811,7 @@ static void FPT_DiagEEPROM(ULONG p_port)
       }
 
 
-   FPT_utilEEWriteOnOff(p_port,(UCHAR)1);
+   FPT_utilEEWriteOnOff(p_port,(unsigned char)1);
 
    for (index = 0; index < max_wd_cnt; index++) {
 
@@ -6933,7 +6932,7 @@ static void FPT_DiagEEPROM(ULONG p_port)
 
    FPT_utilEEWrite(p_port, temp, EEPROM_CHECK_SUM/2);
 
-   FPT_utilEEWriteOnOff(p_port,(UCHAR)0);
+   FPT_utilEEWriteOnOff(p_port,(unsigned char)0);
 
 }
 
@@ -6946,9 +6945,9 @@ static void FPT_DiagEEPROM(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
+static void FPT_queueSearchSelect(PSCCBcard pCurrCard, unsigned char p_card)
 {
-   UCHAR scan_ptr, lun;
+   unsigned char scan_ptr, lun;
    PSCCBMgr_tar_info currTar_Info;
 	PSCCB pOldSccb;
 
@@ -7077,14 +7076,14 @@ static void FPT_queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
+static void FPT_queueSelectFail(PSCCBcard pCurrCard, unsigned char p_card)
 {
-   UCHAR thisTarg;
+   unsigned char thisTarg;
    PSCCBMgr_tar_info currTar_Info;
 
    if (pCurrCard->currentSCCB != NULL)
 	  {
-	  thisTarg = (UCHAR)(((PSCCB)(pCurrCard->currentSCCB))->TargID);
+	  thisTarg = (unsigned char)(((PSCCB)(pCurrCard->currentSCCB))->TargID);
       currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
       pCurrCard->currentSCCB->Sccb_backlink = (PSCCB)NULL;
@@ -7117,10 +7116,10 @@ static void FPT_queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
  *---------------------------------------------------------------------*/
 
 static void FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb,
-				 UCHAR p_card)
+				 unsigned char p_card)
 {
 
-   UCHAR i, SCSIcmd;
+   unsigned char i, SCSIcmd;
    CALL_BK_FN callback;
    PSCCBMgr_tar_info currTar_Info;
 
@@ -7218,7 +7217,7 @@ static void FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb,
  * Description: Add SCCB to our disconnect array.
  *
  *---------------------------------------------------------------------*/
-static void FPT_queueDisconnect(PSCCB p_sccb, UCHAR p_card)
+static void FPT_queueDisconnect(PSCCB p_sccb, unsigned char p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
 
@@ -7253,16 +7252,16 @@ static void FPT_queueDisconnect(PSCCB p_sccb, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static void  FPT_queueFlushSccb(UCHAR p_card, UCHAR error_code)
+static void  FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)
 {
-   UCHAR qtag,thisTarg;
+   unsigned char qtag,thisTarg;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
    currSCCB = FPT_BL_Card[p_card].currentSCCB;
 	if(currSCCB != NULL)
 	{
-	   thisTarg = (UCHAR)currSCCB->TargID;
+	   thisTarg = (unsigned char)currSCCB->TargID;
    	currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
 	   for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
@@ -7271,7 +7270,7 @@ static void  FPT_queueFlushSccb(UCHAR p_card, UCHAR error_code)
 					(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
 			 {
 
-			 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
+			 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (unsigned char)error_code;
 			
 			 FPT_queueCmdComplete(&FPT_BL_Card[p_card],FPT_BL_Card[p_card].discQ_Tbl[qtag], p_card);
 
@@ -7292,10 +7291,10 @@ static void  FPT_queueFlushSccb(UCHAR p_card, UCHAR error_code)
  *
  *---------------------------------------------------------------------*/
 
-static void  FPT_queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg,
-				    UCHAR error_code)
+static void  FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,
+				    unsigned char error_code)
 {
-   UCHAR qtag;
+   unsigned char qtag;
    PSCCBMgr_tar_info currTar_Info;
 
    currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
@@ -7306,7 +7305,7 @@ static void  FPT_queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg,
 				(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
 		 {
 
-		 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
+		 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (unsigned char)error_code;
 
 		 FPT_queueCmdComplete(&FPT_BL_Card[p_card],FPT_BL_Card[p_card].discQ_Tbl[qtag], p_card);
 
@@ -7322,7 +7321,7 @@ static void  FPT_queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg,
 
 
 
-static void FPT_queueAddSccb(PSCCB p_SCCB, UCHAR p_card)
+static void FPT_queueAddSccb(PSCCB p_SCCB, unsigned char p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
    currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
@@ -7356,7 +7355,7 @@ static void FPT_queueAddSccb(PSCCB p_SCCB, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-static UCHAR FPT_queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
+static unsigned char FPT_queueFindSccb(PSCCB p_SCCB, unsigned char p_card)
 {
    PSCCB q_ptr;
    PSCCBMgr_tar_info currTar_Info;
@@ -7469,7 +7468,7 @@ static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
 
 static void FPT_Wait1Second(ULONG p_port)
 {
-   UCHAR i;
+   unsigned char i;
 
    for(i=0; i < 4; i++) {
 
@@ -7492,10 +7491,10 @@ static void FPT_Wait1Second(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_Wait(ULONG p_port, UCHAR p_delay)
+static void FPT_Wait(ULONG p_port, unsigned char p_delay)
 {
-   UCHAR old_timer;
-   UCHAR green_flag;
+   unsigned char old_timer;
+   unsigned char green_flag;
 
    old_timer = RD_HARPOON(p_port+hp_seltimeout);
 
@@ -7540,11 +7539,11 @@ static void FPT_Wait(ULONG p_port, UCHAR p_delay)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
+static void FPT_utilEEWriteOnOff(ULONG p_port,unsigned char p_mode)
 {
-   UCHAR ee_value;
+   unsigned char ee_value;
 
-   ee_value = (UCHAR)(RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H));
+   ee_value = (unsigned char)(RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H));
 
    if (p_mode)
 
@@ -7572,10 +7571,10 @@ static void FPT_utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
 static void FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
 {
 
-   UCHAR ee_value;
+   unsigned char ee_value;
    USHORT i;
 
-   ee_value = (UCHAR)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
+   ee_value = (unsigned char)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
 		   (SEE_MS | SEE_CS));
 
 
@@ -7653,10 +7652,10 @@ static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr)
 static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr)
 {
 
-   UCHAR ee_value;
+   unsigned char ee_value;
    USHORT i, ee_data;
 
-   ee_value = (UCHAR)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
+   ee_value = (unsigned char)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
 		   (SEE_MS | SEE_CS));
 
 
@@ -7698,15 +7697,15 @@ static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-static void FPT_utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr)
+static void FPT_utilEESendCmdAddr(ULONG p_port, unsigned char ee_cmd, USHORT ee_addr)
 {
-   UCHAR ee_value;
-   UCHAR narrow_flg;
+   unsigned char ee_value;
+   unsigned char narrow_flg;
 
    USHORT i;
 
 
-   narrow_flg= (UCHAR)(RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD);
+   narrow_flg= (unsigned char)(RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD);
 
 
    ee_value = SEE_MS;
@@ -7761,7 +7760,7 @@ static void FPT_utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr)
 	  }
 }
 
-static USHORT FPT_CalcCrc16(UCHAR buffer[])
+static USHORT FPT_CalcCrc16(unsigned char buffer[])
 {
    USHORT crc=0;
 	int i,j;
@@ -7781,10 +7780,10 @@ static USHORT FPT_CalcCrc16(UCHAR buffer[])
 	return(crc);
 }
 
-static UCHAR FPT_CalcLrc(UCHAR buffer[])
+static unsigned char FPT_CalcLrc(unsigned char buffer[])
 {
 	int i;
-	UCHAR lrc;
+	unsigned char lrc;
 	lrc = 0;
 	for(i = 0; i < ID_STRING_LENGTH; i++)
 		lrc ^= buffer[i];

commit d8b6b8bd8a99ee91843381d51e8e619463721aed
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:23 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove trivial wrappers
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 38e6b71484b7..1d1e4413c8d1 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -26,25 +26,9 @@
 #undef BUSTYPE_PCI
 
 
-#define OS_InPortByte(port)		inb(port)
-#define OS_InPortWord(port)		inw(port)
-#define OS_InPortLong(port)		inl(port)
-#define OS_OutPortByte(port, value)	outb(value, port)
-#define OS_OutPortWord(port, value)	outw(value, port)
-#define OS_OutPortLong(port, value)	outl(value, port)
 
 
-/*
-  Define name replacements for compatibility with the Linux BusLogic Driver.
-*/
 
-#define SccbMgr_sense_adapter		FlashPoint_ProbeHostAdapter
-#define SccbMgr_config_adapter		FlashPoint_HardwareResetHostAdapter
-#define SccbMgr_unload_card		FlashPoint_ReleaseHostAdapter
-#define SccbMgr_start_sccb		FlashPoint_StartCCB
-#define SccbMgr_abort_sccb		FlashPoint_AbortCCB
-#define SccbMgr_my_int			FlashPoint_InterruptPending
-#define SccbMgr_isr			FlashPoint_HandleInterrupt
 
 
 
@@ -266,12 +250,12 @@ typedef struct _SCCB {
 #define SG_ELEMENT_SIZE 8              /*Eight byte per element. */
 
 
-#define RD_HARPOON(ioport)          OS_InPortByte((u32bits)ioport)
-#define RDW_HARPOON(ioport)         OS_InPortWord((u32bits)ioport)
-#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((u32bits)(ioport + offset)))
-#define WR_HARPOON(ioport,val)      OS_OutPortByte((u32bits)ioport,(u08bits) val)
-#define WRW_HARPOON(ioport,val)       OS_OutPortWord((u32bits)ioport,(u16bits)val)
-#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((u32bits)(ioport + offset), data)
+#define RD_HARPOON(ioport)          inb((u32bits)ioport)
+#define RDW_HARPOON(ioport)         inw((u32bits)ioport)
+#define RD_HARP32(ioport,offset,data) (data = inl((u32bits)(ioport + offset)))
+#define WR_HARPOON(ioport,val)      outb((u08bits) val, (u32bits)ioport)
+#define WRW_HARPOON(ioport,val)       outw((u16bits)val, (u32bits)ioport)
+#define WR_HARP32(ioport,offset,data)  outl(data, (u32bits)(ioport + offset))
 
 
 #define  TAR_SYNC_MASK     (BIT(7)+BIT(6))
@@ -1130,13 +1114,13 @@ static void (*FPT_s_PhaseTbl[8]) (ULONG, UCHAR)= { 0 };
 
 /*---------------------------------------------------------------------
  *
- * Function: SccbMgr_sense_adapter
+ * Function: FlashPoint_ProbeHostAdapter
  *
  * Description: Setup and/or Search for cards and return info to caller.
  *
  *---------------------------------------------------------------------*/
 
-static int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
+static int FlashPoint_ProbeHostAdapter(PSCCBMGR_INFO pCardInfo)
 {
    static UCHAR first_time = 1;
 
@@ -1408,13 +1392,13 @@ static int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 
 /*---------------------------------------------------------------------
  *
- * Function: SccbMgr_config_adapter
+ * Function: FlashPoint_HardwareResetHostAdapter
  *
  * Description: Setup adapter for normal operation (hard reset).
  *
  *---------------------------------------------------------------------*/
 
-static ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
+static ULONG FlashPoint_HardwareResetHostAdapter(PSCCBMGR_INFO pCardInfo)
 {
    PSCCBcard CurrCard = NULL;
 	PNVRamInfo pCurrNvRam;
@@ -1595,7 +1579,7 @@ static ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
    return((ULONG)CurrCard);
 }
 
-static void SccbMgr_unload_card(ULONG pCurrCard)
+static void FlashPoint_ReleaseHostAdapter(ULONG pCurrCard)
 {
 	UCHAR i;
 	ULONG portBase;
@@ -1687,14 +1671,14 @@ static UCHAR FPT_ChkIfChipInitialized(ULONG ioPort)
 }
 /*---------------------------------------------------------------------
  *
- * Function: SccbMgr_start_sccb
+ * Function: FlashPoint_StartCCB
  *
  * Description: Start a command pointed to by p_Sccb. When the
  *              command is completed it will be returned via the
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
+static void FlashPoint_StartCCB(ULONG pCurrCard, PSCCB p_Sccb)
 {
    ULONG ioport;
    UCHAR thisCard, lun;
@@ -1807,14 +1791,14 @@ static void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 
 /*---------------------------------------------------------------------
  *
- * Function: SccbMgr_abort_sccb
+ * Function: FlashPoint_AbortCCB
  *
  * Description: Abort the command pointed to by p_Sccb.  When the
  *              command is completed it will be returned via the
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-static int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
+static int FlashPoint_AbortCCB(ULONG pCurrCard, PSCCB p_Sccb)
 {
 	ULONG ioport;
 
@@ -1908,13 +1892,13 @@ static int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 
 /*---------------------------------------------------------------------
  *
- * Function: SccbMgr_my_int
+ * Function: FlashPoint_InterruptPending
  *
  * Description: Do a quick check to determine if there is a pending
  *              interrupt for this card and disable the IRQ Pin if so.
  *
  *---------------------------------------------------------------------*/
-static UCHAR SccbMgr_my_int(ULONG pCurrCard)
+static UCHAR FlashPoint_InterruptPending(ULONG pCurrCard)
 {
    ULONG ioport;
 
@@ -1934,14 +1918,14 @@ static UCHAR SccbMgr_my_int(ULONG pCurrCard)
 
 /*---------------------------------------------------------------------
  *
- * Function: SccbMgr_isr
+ * Function: FlashPoint_HandleInterrupt
  *
  * Description: This is our entry point when an interrupt is generated
  *              by the card and the upper level driver passes it on to
  *              us.
  *
  *---------------------------------------------------------------------*/
-static int SccbMgr_isr(ULONG pCurrCard)
+static int FlashPoint_HandleInterrupt(ULONG pCurrCard)
 {
    PSCCB currSCCB;
    UCHAR thisCard,result,bm_status, bm_int_st;

commit 85ae97d816da3f8af9dcfbc4197a2950b55c3b0d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Mar 8 00:14:22 2006 -0800

    [SCSI] drivers/scsi/FlashPoint.c: remove unused things
    
    * Remove unused #define's
    * Remove unused typedefs.
    * Remove prototypes for non-existing functions.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 8d64f0bed628..38e6b71484b7 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -47,15 +47,10 @@
 #define SccbMgr_isr			FlashPoint_HandleInterrupt
 
 
-#define MAX_CDBLEN  12
 
-#define SCAM_LEV_2	1
 
 #define CRCMASK	0xA001
 
-#define     BL_VENDOR_ID      0x104B
-#define     FP_DEVICE_ID      0x8130
-#define     MM_DEVICE_ID      0x1040
 
 
 #define FAILURE         0xFFFFFFFFL
@@ -65,15 +60,9 @@ typedef unsigned char   UCHAR;
 typedef unsigned short  USHORT;
 typedef unsigned int    UINT;
 typedef unsigned long   ULONG;
-typedef unsigned char * PUCHAR;
-typedef unsigned short* PUSHORT;
-typedef unsigned long * PULONG;
-typedef void *          PVOID;
 
 
-typedef unsigned char           * uchar_ptr;
 typedef unsigned short          * ushort_ptr;
-typedef unsigned long           * ulong_ptr;
 
 
 #define s08bits	char
@@ -84,9 +73,6 @@ typedef unsigned long           * ulong_ptr;
 #define u16bits	unsigned s16bits
 #define u32bits	unsigned s32bits
 
-typedef u08bits 	* pu08bits;
-typedef u16bits 	* pu16bits;
-typedef u32bits 	* pu32bits;
 
 
 #define BIT(x)          ((UCHAR)(1<<(x)))    /* single-bit mask in bit position x */
@@ -144,10 +130,6 @@ typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
 #define HARPOON_FAMILY        0x02
 
 
-#define ISA_BUS_CARD          0x01
-#define EISA_BUS_CARD         0x02
-#define PCI_BUS_CARD          0x03
-#define VESA_BUS_CARD         0x04
 
 /* SCCB struct used for both SCCB and UCB manager compiles! 
  * The UCB Manager treats the SCCB as it's 'native hardware structure' 
@@ -200,14 +182,11 @@ typedef struct _SCCB {
    ULONG   Sccb_SGoffset;
    } SCCB;
 
-#define SCCB_SIZE sizeof(SCCB)
 
 #pragma pack()
 
 
 
-#define SCSI_INITIATOR_COMMAND    0x00
-#define TARGET_MODE_COMMAND       0x01
 #define SCATTER_GATHER_COMMAND    0x02
 #define RESIDUAL_COMMAND          0x03
 #define RESIDUAL_SG_COMMAND       0x04
@@ -216,12 +195,10 @@ typedef struct _SCCB {
 
 #define F_USE_CMD_Q              0x20     /*Inidcates TAGGED command. */
 #define TAG_TYPE_MASK            0xC0     /*Type of tag msg to send. */
-#define TAG_Q_MASK               0xE0
 #define SCCB_DATA_XFER_OUT       0x10     /* Write */
 #define SCCB_DATA_XFER_IN        0x08     /* Read */
 
 
-#define FOURTEEN_BYTES           0x00     /* Request Sense Buffer size */
 #define NO_AUTO_REQUEST_SENSE    0x01     /* No Request Sense Buffer */
 
 
@@ -235,9 +212,7 @@ typedef struct _SCCB {
 #define DATA_OUT_ST     7
 #define DATA_IN_ST      8
 #define DISCONNECT_ST   9
-#define STATUS_ST       10
 #define ABORT_ST        11
-#define MESSAGE_ST      12
 
 
 #define F_HOST_XFER_DIR                0x01
@@ -249,7 +224,6 @@ typedef struct _SCCB {
 
 
 #define F_STATUSLOADED                 0x01
-#define F_MSGLOADED                    0x02
 #define F_DEV_SELECTED                 0x04
 
 
@@ -257,56 +231,39 @@ typedef struct _SCCB {
 #define SCCB_DATA_UNDER_RUN         0x0C
 #define SCCB_SELECTION_TIMEOUT      0x11  /* Set SCSI selection timed out */
 #define SCCB_DATA_OVER_RUN          0x12
-#define SCCB_UNEXPECTED_BUS_FREE    0x13  /* Target dropped SCSI BSY */
 #define SCCB_PHASE_SEQUENCE_FAIL    0x14  /* Target bus phase sequence failure */
 
-#define SCCB_INVALID_OP_CODE        0x16  /* SCCB invalid operation code */
-#define SCCB_INVALID_SCCB           0x1A  /* Invalid SCCB - bad parameter */
 #define SCCB_GROSS_FW_ERR           0x27  /* Major problem! */
 #define SCCB_BM_ERR                 0x30  /* BusMaster error. */
 #define SCCB_PARITY_ERR             0x34  /* SCSI parity error */
 
 
 
-#define SCCB_INVALID_DIRECTION      0x18  /* Invalid target direction */
-#define SCCB_DUPLICATE_SCCB         0x19  /* Duplicate SCCB */
-#define SCCB_SCSI_RST               0x35  /* SCSI RESET detected. */
 
 
 #define SCCB_IN_PROCESS            0x00
 #define SCCB_SUCCESS               0x01
 #define SCCB_ABORT                 0x02
-#define SCCB_NOT_FOUND             0x03
 #define SCCB_ERROR                 0x04
-#define SCCB_INVALID               0x05
 
-#define SCCB_SIZE sizeof(SCCB)
 
 
 #define  ORION_FW_REV      3110
 
-#define HARP_REVD    1
 
 
 #define QUEUE_DEPTH     254+1            /*1 for Normal disconnect 32 for Q'ing. */
 
 #define	MAX_MB_CARDS	4					/* Max. no of cards suppoerted on Mother Board */
 
-#define WIDE_SCSI       1
 
 #define MAX_SCSI_TAR    16
 #define MAX_LUN         32
 #define LUN_MASK			0x1f
 
-#if defined(HARP_REVA)
-#define SG_BUF_CNT      15             /*Number of prefetched elements. */
-#else
 #define SG_BUF_CNT      16             /*Number of prefetched elements. */
-#endif
 
 #define SG_ELEMENT_SIZE 8              /*Eight byte per element. */
-#define SG_LOCAL_MASK   0x00000000L
-#define SG_ELEMENT_MASK 0xFFFFFFFFL
 
 
 #define RD_HARPOON(ioport)          OS_InPortByte((u32bits)ioport)
@@ -318,31 +275,25 @@ typedef struct _SCCB {
 
 
 #define  TAR_SYNC_MASK     (BIT(7)+BIT(6))
-#define  SYNC_UNKNOWN      0x00
 #define  SYNC_TRYING               BIT(6)
 #define  SYNC_SUPPORTED    (BIT(7)+BIT(6))
 
 #define  TAR_WIDE_MASK     (BIT(5)+BIT(4))
-#define  WIDE_DISABLED     0x00
 #define  WIDE_ENABLED              BIT(4)
 #define  WIDE_NEGOCIATED   BIT(5)
 
 #define  TAR_TAG_Q_MASK    (BIT(3)+BIT(2))
-#define  TAG_Q_UNKNOWN     0x00
 #define  TAG_Q_TRYING              BIT(2)
 #define  TAG_Q_REJECT      BIT(3)
-#define  TAG_Q_SUPPORTED   (BIT(3)+BIT(2))
 
 #define  TAR_ALLOW_DISC    BIT(0)
 
 
 #define  EE_SYNC_MASK      (BIT(0)+BIT(1))
-#define  EE_SYNC_ASYNC     0x00
 #define  EE_SYNC_5MB       BIT(0)
 #define  EE_SYNC_10MB      BIT(1)
 #define  EE_SYNC_20MB      (BIT(0)+BIT(1))
 
-#define  EE_ALLOW_DISC     BIT(6)
 #define  EE_WIDE_SCSI      BIT(7)
 
 
@@ -418,7 +369,6 @@ typedef struct SCCBcard *PSCCBcard;
 #define  ID_STRING_LENGTH  32
 #define  TYPE_CODE0        0x63           /*Level2 Mstr (bits 7-6),  */
 
-#define  TYPE_CODE1        00             /*No ID yet */
 
 #define  SLV_TYPE_CODE0    0xA3           /*Priority Bit set (bits 7-6),  */
 
@@ -430,16 +380,9 @@ typedef struct SCCBcard *PSCCBcard;
 
 #define  ID_0_7      0x18
 #define  ID_8_F      0x11
-#define  ID_10_17    0x12
-#define  ID_18_1F    0x0B
 #define  MISC_CODE   0x14
 #define  CLR_P_FLAG  0x18
-#define  LOCATE_ON   0x12
-#define  LOCATE_OFF  0x0B
 
-#define  LVL_1_MST   0x00
-#define  LVL_2_MST   0x40
-#define  DOM_LVL_2   0xC0
 
 
 #define  INIT_SELTD  0x01
@@ -455,64 +398,24 @@ typedef struct SCCBscam_info {
    UCHAR    id_string[ID_STRING_LENGTH];
    enum scam_id_st state;
     
-} SCCBSCAM_INFO, *PSCCBSCAM_INFO;
+} SCCBSCAM_INFO;
 
 
-#define  SCSI_TEST_UNIT_READY    0x00
-#define  SCSI_REZERO_UNIT        0x01
 #define  SCSI_REQUEST_SENSE      0x03
-#define  SCSI_FORMAT_UNIT        0x04
-#define  SCSI_REASSIGN           0x07
 #define  SCSI_READ               0x08
 #define  SCSI_WRITE              0x0A
-#define  SCSI_SEEK               0x0B
-#define  SCSI_INQUIRY            0x12
-#define  SCSI_MODE_SELECT        0x15
-#define  SCSI_RESERVE_UNIT       0x16
-#define  SCSI_RELEASE_UNIT       0x17
-#define  SCSI_MODE_SENSE         0x1A
 #define  SCSI_START_STOP_UNIT    0x1B
-#define  SCSI_SEND_DIAGNOSTIC    0x1D
-#define  SCSI_READ_CAPACITY      0x25
 #define  SCSI_READ_EXTENDED      0x28
 #define  SCSI_WRITE_EXTENDED     0x2A
-#define  SCSI_SEEK_EXTENDED      0x2B
 #define  SCSI_WRITE_AND_VERIFY   0x2E
-#define  SCSI_VERIFY             0x2F
-#define  SCSI_READ_DEFECT_DATA   0x37
-#define  SCSI_WRITE_BUFFER       0x3B
-#define  SCSI_READ_BUFFER        0x3C
-#define  SCSI_RECV_DIAGNOSTIC    0x1C
-#define  SCSI_READ_LONG          0x3E
-#define  SCSI_WRITE_LONG         0x3F
-#define  SCSI_LAST_SCSI_CMND     SCSI_WRITE_LONG
-#define  SCSI_INVALID_CMND       0xFF
 
 
 
 #define  SSGOOD                  0x00
 #define  SSCHECK                 0x02
-#define  SSCOND_MET              0x04
-#define  SSBUSY                  0x08
-#define  SSRESERVATION_CONFLICT  0x18
-#define  SSCMD_TERM              0x22
 #define  SSQ_FULL                0x28
 
 
-#define  SKNO_SEN                0x00
-#define  SKRECOV_ERR             0x01
-#define  SKNOT_RDY               0x02
-#define  SKMED_ERR               0x03
-#define  SKHW_ERR                0x04
-#define  SKILL_REQ               0x05
-#define  SKUNIT_ATTN             0x06
-#define  SKDATA_PROTECT          0x07
-#define  SKBLNK_CHK              0x08
-#define  SKCPY_ABORT             0x0A
-#define  SKABORT_CMD             0x0B
-#define  SKEQUAL                 0x0C
-#define  SKVOL_OVF               0x0D
-#define  SKMIS_CMP               0x0E
 
 
 #define  SMCMD_COMP              0x00
@@ -520,7 +423,6 @@ typedef struct SCCBscam_info {
 #define  SMSAVE_DATA_PTR         0x02
 #define  SMREST_DATA_PTR         0x03
 #define  SMDISC                  0x04
-#define  SMINIT_DETEC_ERR        0x05
 #define  SMABORT                 0x06
 #define  SMREJECT                0x07
 #define  SMNO_OP                 0x08
@@ -535,35 +437,22 @@ typedef struct SCCBscam_info {
 
 
 #define  SMSYNC                  0x01
-#define  SM10MBS                 0x19     /* 100ns           */
-#define  SM5MBS                  0x32     /* 200ns           */
-#define  SMOFFSET                0x0F     /* Maxoffset value */
 #define  SMWDTR                  0x03
 #define  SM8BIT                  0x00
 #define  SM16BIT                 0x01
-#define  SM32BIT                 0x02
 #define  SMIGNORWR               0x23     /* Ignore Wide Residue */
 
 
-#define  ARBITRATION_DELAY       0x01     /* 2.4us using a 40Mhz clock */
-#define  BUS_SETTLE_DELAY        0x01     /* 400ns */
-#define  BUS_CLEAR_DELAY         0x01     /* 800ns */
 
 
 
-#define  SPHASE_TO               0x0A  /* 10 second timeout waiting for */
-#define  SCMD_TO                 0x0F  /* Overall command timeout */
 
 
 
 #define  SIX_BYTE_CMD            0x06
-#define  TEN_BYTE_CMD            0x0A
 #define  TWELVE_BYTE_CMD         0x0C
 
 #define  ASYNC                   0x00
-#define  PERI25NS                0x06  /* 25/4ns to next clock for xbow. */
-#define  SYNC10MBS               0x19
-#define  SYNC5MBS                0x32
 #define  MAX_OFFSET              0x0F  /* Maxbyteoffset for Sync Xfers */
 
 
@@ -572,19 +461,11 @@ typedef struct SCCBscam_info {
 #define  EEPROM_CHECK_SUM  0
 #define  FW_SIGNATURE      2
 #define  MODEL_NUMB_0      4
-#define  MODEL_NUMB_1      5
 #define  MODEL_NUMB_2      6
-#define  MODEL_NUMB_3      7
 #define  MODEL_NUMB_4      8
-#define  MODEL_NUMB_5      9
-#define  IO_BASE_ADDR      10
-#define  IRQ_NUMBER        12
-#define  PCI_INT_PIN       13
-#define  BUS_DELAY         14       /*On time in byte 14 off delay in 15 */
 #define  SYSTEM_CONFIG     16
 #define  SCSI_CONFIG       17
 #define  BIOS_CONFIG       18
-#define  SPIN_UP_DELAY     19
 #define  SCAM_CONFIG       20
 #define  ADAPTER_SCSI_ID   24
 
@@ -609,7 +490,6 @@ typedef struct SCCBscam_info {
 
 
 
-   #define  DOM_MASTER     (BIT(0) + BIT(1))
    #define  SCAM_ENABLED   BIT(2)
    #define  SCAM_LEVEL2    BIT(3)
 
@@ -644,16 +524,9 @@ typedef struct SCCBscam_info {
 	/* Sub Vendor ID and Sub Device ID only available in
 		Harpoon Version 2 and higher */
 
-   #define  hp_sub_vendor_id_0   0x04		/* LSB */
-   #define  hp_sub_vendor_id_1   0x05		/* MSB */
    #define  hp_sub_device_id_0   0x06		/* LSB */
-   #define  hp_sub_device_id_1   0x07		/* MSB */
 
 
-   #define  hp_dual_addr_lo      0x08
-   #define  hp_dual_addr_lmi     0x09
-   #define  hp_dual_addr_hmi     0x0A
-   #define  hp_dual_addr_hi      0x0B
 
    #define  hp_semaphore         0x0C
       #define SCCB_MGR_ACTIVE    BIT(0)
@@ -661,9 +534,7 @@ typedef struct SCCBscam_info {
       #define SCCB_MGR_PRESENT   BIT(3)
       #define BIOS_IN_USE        BIT(4)
 
-   #define  hp_user_defined_D    0x0D
 
-   #define  hp_reserved_E        0x0E
 
    #define  hp_sys_ctrl          0x0F
 
@@ -671,95 +542,49 @@ typedef struct SCCBscam_info {
       #define  DRVR_RST          BIT(1)      /*Firmware Reset to 80C15 chip */
       #define  HALT_MACH         BIT(3)      /*Halt State Machine      */
       #define  HARD_ABORT        BIT(4)      /*Hard Abort              */
-      #define  DIAG_MODE         BIT(5)      /*Diagnostic Mode         */
 
-      #define  BM_ABORT_TMOUT    0x50        /*Halt State machine time out */
 
-   #define  hp_sys_cfg           0x10
 
-      #define  DONT_RST_FIFO     BIT(7)      /*Don't reset FIFO      */
 
 
-   #define  hp_host_ctrl0        0x11
 
-      #define  DUAL_ADDR_MODE    BIT(0)   /*Enable 64-bit addresses */
-      #define  IO_MEM_SPACE      BIT(1)   /*I/O Memory Space    */
-      #define  RESOURCE_LOCK     BIT(2)   /*Enable Resource Lock */
-      #define  IGNOR_ACCESS_ERR  BIT(3)   /*Ignore Access Error */
-      #define  HOST_INT_EDGE     BIT(4)   /*Host interrupt level/edge mode sel */
-      #define  SIX_CLOCKS        BIT(5)   /*6 Clocks between Strobe   */
-      #define  DMA_EVEN_PARITY   BIT(6)   /*Enable DMA Enen Parity */
 
-/*
-      #define  BURST_MODE        BIT(0)
-*/
 
-   #define  hp_reserved_12       0x12
 
    #define  hp_host_blk_cnt      0x13
 
-      #define  XFER_BLK1         0x00     /*     0 0 0  1 byte per block*/
-      #define  XFER_BLK2         0x01     /*     0 0 1  2 byte per block*/
-      #define  XFER_BLK4         0x02     /*     0 1 0  4 byte per block*/
-      #define  XFER_BLK8         0x03     /*     0 1 1  8 byte per block*/
-      #define  XFER_BLK16        0x04     /*     1 0 0 16 byte per block*/
-      #define  XFER_BLK32        0x05     /*     1 0 1 32 byte per block*/
       #define  XFER_BLK64        0x06     /*     1 1 0 64 byte per block*/
    
       #define  BM_THRESHOLD      0x40     /* PCI mode can only xfer 16 bytes*/
 
 
-   #define  hp_reserved_14       0x14
-   #define  hp_reserved_15       0x15
-   #define  hp_reserved_16       0x16
 
    #define  hp_int_mask          0x17
 
       #define  INT_CMD_COMPL     BIT(0)   /* DMA command complete   */
       #define  INT_EXT_STATUS    BIT(1)   /* Extended Status Set    */
-      #define  INT_SCSI          BIT(2)   /* Scsi block interrupt   */
-      #define  INT_FIFO_RDY      BIT(4)   /* FIFO data ready        */
 
 
    #define  hp_xfer_cnt_lo       0x18
-   #define  hp_xfer_cnt_mi       0x19
    #define  hp_xfer_cnt_hi       0x1A
    #define  hp_xfer_cmd          0x1B
 
       #define  XFER_HOST_DMA     0x00     /*     0 0 0 Transfer Host -> DMA */
       #define  XFER_DMA_HOST     0x01     /*     0 0 1 Transfer DMA  -> Host */
-      #define  XFER_HOST_MPU     0x02     /*     0 1 0 Transfer Host -> MPU  */
-      #define  XFER_MPU_HOST     0x03     /*     0 1 1 Transfer MPU  -> Host */
-      #define  XFER_DMA_MPU      0x04     /*     1 0 0 Transfer DMA  -> MPU  */
-      #define  XFER_MPU_DMA      0x05     /*     1 0 1 Transfer MPU  -> DMA  */
-      #define  SET_SEMAPHORE     0x06     /*     1 1 0 Set Semaphore         */
-      #define  XFER_NOP          0x07     /*     1 1 1 Transfer NOP          */
-      #define  XFER_MB_MPU       0x06     /*     1 1 0 Transfer MB -> MPU */
-      #define  XFER_MB_DMA       0x07     /*     1 1 1 Transfer MB -> DMA */
 
 
       #define  XFER_HOST_AUTO    0x00     /*     0 0 Auto Transfer Size   */
-      #define  XFER_HOST_8BIT    0x08     /*     0 1 8 BIT Transfer Size  */
-      #define  XFER_HOST_16BIT   0x10     /*     1 0 16 BIT Transfer Size */
-      #define  XFER_HOST_32BIT   0x18     /*     1 1 32 BIT Transfer Size */
 
       #define  XFER_DMA_8BIT     0x20     /*     0 1 8 BIT  Transfer Size */
-      #define  XFER_DMA_16BIT    0x40     /*     1 0 16 BIT Transfer Size */
 
       #define  DISABLE_INT       BIT(7)   /*Do not interrupt at end of cmd. */
 
       #define  HOST_WRT_CMD      ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_8BIT))
       #define  HOST_RD_CMD       ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_8BIT))
-      #define  WIDE_HOST_WRT_CMD ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_16BIT))
-      #define  WIDE_HOST_RD_CMD  ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_16BIT))
 
    #define  hp_host_addr_lo      0x1C
-   #define  hp_host_addr_lmi     0x1D
    #define  hp_host_addr_hmi     0x1E
-   #define  hp_host_addr_hi      0x1F
 
-   #define  hp_pio_data          0x20
-   #define  hp_reserved_21       0x21
    #define  hp_ee_ctrl           0x22
 
       #define  EXT_ARB_ACK       BIT(7)
@@ -777,17 +602,8 @@ typedef struct SCCBscam_info {
       #define  EWDS              0x04
       #define  EWDS_ADDR         0x0000
 
-   #define  hp_brdctl            0x23
 
-      #define  DAT_7             BIT(7)
-      #define  DAT_6             BIT(6)
-      #define  DAT_5             BIT(5)
-      #define  BRD_STB           BIT(4)
-      #define  BRD_CS            BIT(3)
-      #define  BRD_WR            BIT(2)
 
-   #define  hp_reserved_24       0x24
-   #define  hp_reserved_25       0x25
 
 
 
@@ -796,70 +612,36 @@ typedef struct SCCBscam_info {
 
       #define  SCSI_TERM_ENA_L   BIT(0)   /*Enable/Disable external terminators */
       #define  FLUSH_XFER_CNTR   BIT(1)   /*Flush transfer counter */
-      #define  BM_XFER_MIN_8     BIT(2)   /*Enable bus master transfer of 9 */
-      #define  BIOS_ENA          BIT(3)   /*Enable BIOS/FLASH Enable */
       #define  FORCE1_XFER       BIT(5)   /*Always xfer one byte in byte mode */
       #define  FAST_SINGLE       BIT(6)   /*?? */
 
       #define  BMCTRL_DEFAULT    (FORCE1_XFER|FAST_SINGLE|SCSI_TERM_ENA_L)
 
-   #define  hp_reserved_27       0x27
 
    #define  hp_sg_addr           0x28
    #define  hp_page_ctrl         0x29
 
       #define  SCATTER_EN        BIT(0)   
       #define  SGRAM_ARAM        BIT(1)   
-      #define  BIOS_SHADOW       BIT(2)   
       #define  G_INT_DISABLE     BIT(3)   /* Enable/Disable all Interrupts */
       #define  NARROW_SCSI_CARD  BIT(4)   /* NARROW/WIDE SCSI config pin */
 
-   #define  hp_reserved_2A       0x2A
-   #define  hp_pci_cmd_cfg       0x2B
 
-      #define  IO_SPACE_ENA      BIT(0)   /*enable I/O space */
-      #define  MEM_SPACE_ENA     BIT(1)   /*enable memory space */
-      #define  BUS_MSTR_ENA      BIT(2)   /*enable bus master operation */
-      #define  MEM_WI_ENA        BIT(4)   /*enable Write and Invalidate */
-      #define  PAR_ERR_RESP      BIT(6)   /*enable parity error responce. */
 
-   #define  hp_reserved_2C       0x2C
 
    #define  hp_pci_stat_cfg      0x2D
 
-      #define  DATA_PARITY_ERR   BIT(0)   
-      #define  REC_TARGET_ABORT  BIT(4)   /*received Target abort */
       #define  REC_MASTER_ABORT  BIT(5)   /*received Master abort */
-      #define  SIG_SYSTEM_ERR    BIT(6)   
-      #define  DETECTED_PAR_ERR  BIT(7)   
 
-   #define  hp_reserved_2E       0x2E
 
-   #define  hp_sys_status        0x2F
 
-      #define  SLV_DATA_RDY      BIT(0)   /*Slave data ready */
-      #define  XFER_CNT_ZERO     BIT(1)   /*Transfer counter = 0 */
-      #define  BM_FIFO_EMPTY     BIT(2)   /*FIFO empty */
-      #define  BM_FIFO_FULL      BIT(3)   /*FIFO full */
-      #define  HOST_OP_DONE      BIT(4)   /*host operation done */
-      #define  DMA_OP_DONE       BIT(5)   /*DMA operation done */
-      #define  SLV_OP_DONE       BIT(6)   /*Slave operation done */
-      #define  PWR_ON_FLAG       BIT(7)   /*Power on flag */
 
-   #define  hp_reserved_30       0x30
 
-   #define  hp_host_status0      0x31
 
-      #define  HOST_TERM         BIT(5)   /*Host Terminal Count */
-      #define  HOST_TRSHLD       BIT(6)   /*Host Threshold      */
-      #define  CONNECTED_2_HOST  BIT(7)   /*Connected to Host   */
 
-   #define  hp_reserved_32       0x32
 
    #define  hp_rev_num           0x33
 
-      #define  REV_A_CONST       0x0E
-      #define  REV_B_CONST       0x0E
 
    #define  hp_stack_data        0x34
    #define  hp_stack_addr        0x35
@@ -869,8 +651,6 @@ typedef struct SCCBscam_info {
       #define  BM_FORCE_OFF      BIT(0)   /*Bus Master is forced to get off */
       #define  PCI_TGT_ABORT     BIT(0)   /*PCI bus master transaction aborted */
       #define  PCI_DEV_TMOUT     BIT(1)   /*PCI Device Time out */
-      #define  FIFO_TC_NOT_ZERO  BIT(2)   /*FIFO or transfer counter not zero */
-      #define  CHIP_RST_OCCUR    BIT(3)   /*Chip reset occurs */
       #define  CMD_ABORTED       BIT(4)   /*Command aborted */
       #define  BM_PARITY_ERR     BIT(5)   /*parity error on data received   */
       #define  PIO_OVERRUN       BIT(6)   /*Slave data overrun */
@@ -880,24 +660,13 @@ typedef struct SCCBscam_info {
 
    #define  hp_int_status        0x37
       
-      #define  BM_CMD_CMPL       BIT(0)   /*Bus Master command complete */
       #define  EXT_STATUS_ON     BIT(1)   /*Extended status is valid */
       #define  SCSI_INTERRUPT    BIT(2)   /*Global indication of a SCSI int. */
-      #define  BM_FIFO_RDY       BIT(4)   
       #define  INT_ASSERTED      BIT(5)   /* */
-      #define  SRAM_BUSY         BIT(6)   /*Scatter/Gather RAM busy */
-      #define  CMD_REG_BUSY      BIT(7)                                       
 
 
    #define  hp_fifo_cnt          0x38
-   #define  hp_curr_host_cnt     0x39
-   #define  hp_reserved_3A       0x3A
-   #define  hp_fifo_in_addr      0x3B
 
-   #define  hp_fifo_out_addr     0x3C
-   #define  hp_reserved_3D       0x3D
-   #define  hp_reserved_3E       0x3E
-   #define  hp_reserved_3F       0x3F
 
 
 
@@ -937,9 +706,7 @@ typedef struct SCCBscam_info {
       #define  SCSI_IOBIT        BIT(0)
 
       #define  S_SCSI_PHZ        (BIT(2)+BIT(1)+BIT(0))
-      #define  S_CMD_PH          (BIT(2)              )
       #define  S_MSGO_PH         (BIT(2)+BIT(1)       )
-      #define  S_STAT_PH         (BIT(2)       +BIT(0))
       #define  S_MSGI_PH         (BIT(2)+BIT(1)+BIT(0))
       #define  S_DATAI_PH        (              BIT(0))
       #define  S_DATAO_PH        0x00
@@ -947,7 +714,6 @@ typedef struct SCCBscam_info {
 
    #define  hp_scsictrl_0        0x45
 
-      #define  NO_ARB            BIT(7)
       #define  SEL_TAR           BIT(6)
       #define  ENA_ATN           BIT(4)
       #define  ENA_RESEL         BIT(2)
@@ -969,44 +735,33 @@ typedef struct SCCBscam_info {
 
    #define  hp_scsireset         0x47
 
-      #define  SCSI_TAR          BIT(7)
       #define  SCSI_INI          BIT(6)
       #define  SCAM_EN           BIT(5)
-      #define  ACK_HOLD          BIT(4)
       #define  DMA_RESET         BIT(3)
       #define  HPSCSI_RESET      BIT(2)
       #define  PROG_RESET        BIT(1)
       #define  FIFO_CLR          BIT(0)
 
    #define  hp_xfercnt_0         0x48
-   #define  hp_xfercnt_1         0x49
    #define  hp_xfercnt_2         0x4A
-   #define  hp_xfercnt_3         0x4B
 
    #define  hp_fifodata_0        0x4C
-   #define  hp_fifodata_1        0x4D
    #define  hp_addstat           0x4E
 
       #define  SCAM_TIMER        BIT(7)
-      #define  AUTO_RUNNING      BIT(6)
-      #define  FAST_SYNC         BIT(5)
       #define  SCSI_MODE8        BIT(3)
       #define  SCSI_PAR_ERR      BIT(0)
 
    #define  hp_prgmcnt_0         0x4F
 
-      #define  AUTO_PC_MASK      0x3F
 
    #define  hp_selfid_0          0x50
    #define  hp_selfid_1          0x51
    #define  hp_arb_id            0x52
 
-      #define  ARB_ID            (BIT(3) + BIT(2) + BIT(1) + BIT(0))
 
    #define  hp_select_id         0x53
 
-      #define  RESEL_ID          (BIT(7) + BIT(6) + BIT(5) + BIT(4))
-      #define  SELECT_ID         (BIT(3) + BIT(2) + BIT(1) + BIT(0))
 
    #define  hp_synctarg_base     0x54
    #define  hp_synctarg_12       0x54
@@ -1029,63 +784,38 @@ typedef struct SCCBscam_info {
    #define  hp_synctarg_2        0x62
    #define  hp_synctarg_3        0x63
 
-      #define  RATE_20MB         0x00
-      #define  RATE_10MB         (              BIT(5))
-      #define  RATE_6_6MB        (       BIT(6)       )   
-      #define  RATE_5MB          (       BIT(6)+BIT(5))
-      #define  RATE_4MB          (BIT(7)              )
-      #define  RATE_3_33MB       (BIT(7)       +BIT(5))
-      #define  RATE_2_85MB       (BIT(7)+BIT(6)       )
-      #define  RATE_2_5MB        (BIT(7)+BIT(5)+BIT(6))
-      #define  NEXT_CLK          BIT(5)
-      #define  SLOWEST_SYNC      (BIT(7)+BIT(6)+BIT(5))
       #define  NARROW_SCSI       BIT(4)
-      #define  SYNC_OFFSET       (BIT(3) + BIT(2) + BIT(1) + BIT(0))
-      #define  DEFAULT_ASYNC     0x00
       #define  DEFAULT_OFFSET    0x0F
 
    #define  hp_autostart_0       0x64
    #define  hp_autostart_1       0x65
-   #define  hp_autostart_2       0x66
    #define  hp_autostart_3       0x67
 
 
 
-      #define  DISABLE  0x00
       #define  AUTO_IMMED    BIT(5)
       #define  SELECT   BIT(6)
-      #define  RESELECT (BIT(6)+BIT(5))
-      #define  BUSFREE  BIT(7)
-      #define  XFER_0   (BIT(7)+BIT(5))
       #define  END_DATA (BIT(7)+BIT(6))
-      #define  MSG_PHZ  (BIT(7)+BIT(6)+BIT(5))
 
    #define  hp_gp_reg_0          0x68
    #define  hp_gp_reg_1          0x69
-   #define  hp_gp_reg_2          0x6A
    #define  hp_gp_reg_3          0x6B
 
    #define  hp_seltimeout        0x6C
 
 
-      #define  TO_2ms            0x54      /* 2.0503ms */
       #define  TO_4ms            0x67      /* 3.9959ms */
 
       #define  TO_5ms            0x03      /* 4.9152ms */
       #define  TO_10ms           0x07      /* 11.xxxms */
       #define  TO_250ms          0x99      /* 250.68ms */
       #define  TO_290ms          0xB1      /* 289.99ms */
-      #define  TO_350ms          0xD6      /* 350.62ms */
-      #define  TO_417ms          0xFF      /* 417.79ms */
 
    #define  hp_clkctrl_0         0x6D
 
       #define  PWR_DWN           BIT(6)
       #define  ACTdeassert       BIT(4)
-      #define  ATNonErr          BIT(3)
-      #define  CLK_30MHZ         BIT(1)
       #define  CLK_40MHZ         (BIT(1) + BIT(0))
-      #define  CLK_50MHZ         BIT(2)
 
       #define  CLKCTRL_DEFAULT   (ACTdeassert | CLK_40MHZ)
 
@@ -1095,38 +825,21 @@ typedef struct SCCBscam_info {
    #define  hp_offsetctr         0x70
    #define  hp_xferstat          0x71
 
-      #define  FIFO_FULL         BIT(7)
       #define  FIFO_EMPTY        BIT(6)
-      #define  FIFO_MASK         0x3F   /* Mask for the FIFO count value. */
-      #define  FIFO_LEN          0x20
 
    #define  hp_portctrl_1        0x72
 
-      #define  EVEN_HOST_P       BIT(5)
-      #define  INVT_SCSI         BIT(4)
       #define  CHK_SCSI_P        BIT(3)
       #define  HOST_MODE8        BIT(0)
-      #define  HOST_MODE16       0x00
 
    #define  hp_xfer_pad          0x73
 
       #define  ID_UNLOCK         BIT(3)
-      #define  XFER_PAD          BIT(2)
 
    #define  hp_scsidata_0        0x74
    #define  hp_scsidata_1        0x75
-   #define  hp_timer_0           0x76
-   #define  hp_timer_1           0x77
 
-   #define  hp_reserved_78       0x78
-   #define  hp_reserved_79       0x79
-   #define  hp_reserved_7A       0x7A
-   #define  hp_reserved_7B       0x7B
 
-   #define  hp_reserved_7C       0x7C
-   #define  hp_reserved_7D       0x7D
-   #define  hp_reserved_7E       0x7E
-   #define  hp_reserved_7F       0x7F
 
    #define  hp_aramBase          0x80
    #define  BIOS_DATA_OFFSET     0x60
@@ -1135,22 +848,15 @@ typedef struct SCCBscam_info {
 
 
 
-      #define  AUTO_LEN 0x80
-      #define  AR0      0x00
-      #define  AR1      BITW(8)
-      #define  AR2      BITW(9)
       #define  AR3      (BITW(9) + BITW(8))
       #define  SDATA    BITW(10)
 
-      #define  NOP_OP   0x00        /* Nop command */
 
       #define  CRD_OP   BITW(11)     /* Cmp Reg. w/ Data */
 
       #define  CRR_OP   BITW(12)     /* Cmp Reg. w. Reg. */
 
-      #define  CBE_OP   (BITW(14)+BITW(12)+BITW(11)) /* Cmp SCSI cmd class & Branch EQ */
       
-      #define  CBN_OP   (BITW(14)+BITW(13))  /* Cmp SCSI cmd class & Branch NOT EQ */
       
       #define  CPE_OP   (BITW(14)+BITW(11))  /* Cmp SCSI phs & Branch EQ */
 
@@ -1163,7 +869,6 @@ typedef struct SCCBscam_info {
       #define  ASTATUS     (BITW(10)+BITW(8))
       #define  AMSG_OUT    (BITW(10)+BITW(9))
       #define  AMSG_IN     (BITW(10)+BITW(9)+BITW(8))
-      #define  AILLEGAL    (BITW(9)+BITW(8))
 
 
       #define  BRH_OP   BITW(13)   /* Branch */
@@ -1176,17 +881,11 @@ typedef struct SCCBscam_info {
       #define  TCB_OP   (BITW(13)+BITW(11))    /* Test condition & branch */
 
       
-      #define  ATN_SET     BITW(8)
-      #define  ATN_RESET   BITW(9)
-      #define  XFER_CNT    (BITW(9)+BITW(8))
       #define  FIFO_0      BITW(10)
-      #define  FIFO_NOT0   (BITW(10)+BITW(8))
-      #define  T_USE_SYNC0 (BITW(10)+BITW(9))
 
 
       #define  MPM_OP   BITW(15)        /* Match phase and move data */
 
-      #define  MDR_OP   (BITW(12)+BITW(11)) /* Move data to Reg. */
 
       #define  MRR_OP   BITW(14)        /* Move DReg. to Reg. */
 
@@ -1196,34 +895,14 @@ typedef struct SCCBscam_info {
 
       #define  D_AR0    0x00
       #define  D_AR1    BIT(0)
-      #define  D_AR2    BIT(1)
-      #define  D_AR3    (BIT(1) + BIT(0))
-      #define  D_SDATA  BIT(2)
       #define  D_BUCKET (BIT(2) + BIT(1) + BIT(0))
 
 
-      #define  ADR_OP   (BITW(13)+BITW(12)) /* Logical AND Reg. w. Data */
 
-      #define  ADS_OP   (BITW(14)+BITW(13)+BITW(12)) 
 
-      #define  ODR_OP   (BITW(13)+BITW(12)+BITW(11))  
 
-      #define  ODS_OP   (BITW(14)+BITW(13)+BITW(12)+BITW(11))  
 
-      #define  STR_OP   (BITW(15)+BITW(14)) /* Store to A_Reg. */
 
-      #define  AINT_ENA1   0x00
-      #define  AINT_STAT1  BITW(8)
-      #define  ASCSI_SIG   BITW(9)
-      #define  ASCSI_CNTL  (BITW(9)+BITW(8))
-      #define  APORT_CNTL  BITW(10)
-      #define  ARST_CNTL   (BITW(10)+BITW(8))
-      #define  AXFERCNT0   (BITW(10)+BITW(9))
-      #define  AXFERCNT1   (BITW(10)+BITW(9)+BITW(8))
-      #define  AXFERCNT2   BITW(11)
-      #define  AFIFO_DATA  (BITW(11)+BITW(8))
-      #define  ASCSISELID  (BITW(11)+BITW(9))
-      #define  ASCSISYNC0  (BITW(11)+BITW(9)+BITW(8))
 
 
       #define  RAT_OP      (BITW(14)+BITW(13)+BITW(11))
@@ -1233,7 +912,6 @@ typedef struct SCCBscam_info {
 
       #define  SSI_ITAR_DISC	(ITAR_DISC >> 8)
       #define  SSI_IDO_STRT	(IDO_STRT >> 8)
-      #define  SSI_IDI_STRT	(IDO_STRT >> 8)
 
       #define  SSI_ICMD_COMP	(ICMD_COMP >> 8)
       #define  SSI_ITICKLE	(ITICKLE >> 8)
@@ -1248,13 +926,11 @@ typedef struct SCCBscam_info {
       #define  CMDPZ 0x04     /*Command phase */
       #define  DINT  0x12     /*Data Out/In interrupt */
       #define  DI    0x13     /*Data Out */
-      #define  MI    0x14     /*Message In */
       #define  DC    0x19     /*Disconnect Message */
       #define  ST    0x1D     /*Status Phase */
       #define  UNKNWN 0x24    /*Unknown bus action */
       #define  CC    0x25     /*Command Completion failure */
       #define  TICK  0x26     /*New target reselected us. */
-      #define  RFAIL 0x27     /*Reselection failed */
       #define  SELCHK 0x28     /*Select & Check SCSI ID latch reg */
 
 
@@ -1268,25 +944,18 @@ typedef struct SCCBscam_info {
 
 
       #define  TAG_STRT          0x00
-      #define  SELECTION_START   0x00
       #define  DISCONNECT_START  0x10/2
       #define  END_DATA_START    0x14/2
-      #define  NONTAG_STRT       0x02/2
       #define  CMD_ONLY_STRT     CMDPZ/2
-      #define  TICKLE_STRT     TICK/2
       #define  SELCHK_STRT     SELCHK/2
 
 
 
 
-#define mEEPROM_CLK_DELAY(port) (RD_HARPOON(port+hp_intstat_1))
 
-#define mWAIT_10MS(port) (RD_HARPOON(port+hp_intstat_1))
 
 
-#define CLR_XFER_CNT(port) (WR_HARPOON(port+hp_xfercnt_0, 0x00))
 
-#define SET_XFER_CNT(port, data) (WR_HARP32(port,hp_xfercnt_0,data))
 
 #define GET_XFER_CNT(port, xfercnt) {RD_HARP32(port,hp_xfercnt_0,xfercnt); xfercnt &= 0xFFFFFF;}
 /* #define GET_XFER_CNT(port, xfercnt) (xfercnt = RD_HARPOON(port+hp_xfercnt_2), \
@@ -1308,11 +977,7 @@ typedef struct SCCBscam_info {
 #define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
                           WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}
 
-#define ACCEPT_STAT(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
-                          WR_HARPOON(port+hp_scsisig, S_ILL_PH);}
 
-#define ACCEPT_STAT_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
-                          WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}
 
 #define DISABLE_AUTO(port) (WR_HARPOON(port+hp_scsireset, PROG_RESET),\
                         WR_HARPOON(port+hp_scsireset, 0x00))
@@ -1332,7 +997,6 @@ typedef struct SCCBscam_info {
 
 
 
-void  scsiStartAuto(ULONG port);
 static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag);
 static void  FPT_ssel(ULONG port, UCHAR p_card);
 static void  FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard);
@@ -1405,7 +1069,6 @@ static void  FPT_DiagEEPROM(ULONG p_port);
 
 
 
-void  busMstrAbort(ULONG port);
 static void  FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard);
 static void  FPT_busMstrSGDataXferStart(ULONG port, PSCCB pCurrSCCB);
 static void  FPT_busMstrDataXferStart(ULONG port, PSCCB pCurrSCCB);
@@ -1446,12 +1109,6 @@ static void  FPT_autoLoadDefaultMap(ULONG p_port);
 
 
 
-void  OS_start_timer(unsigned long ioport, unsigned long timeout);
-void  OS_stop_timer(unsigned long ioport, unsigned long timeout);
-void  OS_disable_int(unsigned char intvec);
-void  OS_enable_int(unsigned char intvec);
-void  OS_delay(unsigned long count);
-int   OS_VirtToPhys(u32bits CardHandle, u32bits *physaddr, u32bits *virtaddr);
 
 static SCCBMGR_TAR_INFO FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
 static SCCBCARD FPT_BL_Card[MAX_CARDS] = { { 0 } };

commit 3235798804ee75f09d45aee5003197930de57689
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sun Jan 15 02:12:54 2006 +0100

    Fix "stuct", "strut", "struc" typos
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 5beed4f6d985..8d64f0bed628 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -149,7 +149,7 @@ typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
 #define PCI_BUS_CARD          0x03
 #define VESA_BUS_CARD         0x04
 
-/* SCCB struc used for both SCCB and UCB manager compiles! 
+/* SCCB struct used for both SCCB and UCB manager compiles! 
  * The UCB Manager treats the SCCB as it's 'native hardware structure' 
  */
 

commit 47b5d69c4aa753fcfc9b2b8d28c0660a1e25c129
Author: James Bottomley <jejb@mulgrave.(none)>
Date:   Sun Apr 24 02:38:05 2005 -0500

    [SCSI] drivers/scsi/FlashPoint.c: cleanups
    
    From: Adrian Bunk <bunk@stusta.de>
    
    This patch contains cleanups including the following:
    - remove #ifdef'ed code for other OS's
    - remove other unused code
    - make needlessly global code static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
index 56a695c6ab52..5beed4f6d985 100644
--- a/drivers/scsi/FlashPoint.c
+++ b/drivers/scsi/FlashPoint.c
@@ -22,8 +22,6 @@
 #ifndef CONFIG_SCSI_OMIT_FLASHPOINT
 
 
-#define UNIX
-#define FW_TYPE		_SCCB_MGR_
 #define MAX_CARDS	8
 #undef BUSTYPE_PCI
 
@@ -34,8 +32,6 @@
 #define OS_OutPortByte(port, value)	outb(value, port)
 #define OS_OutPortWord(port, value)	outw(value, port)
 #define OS_OutPortLong(port, value)	outl(value, port)
-#define OS_Lock(x)
-#define OS_UnLock(x)
 
 
 /*
@@ -51,164 +47,17 @@
 #define SccbMgr_isr			FlashPoint_HandleInterrupt
 
 
-/*
-  Define name replacements to avoid kernel namespace pollution.
-*/
-
-#define BL_Card				FPT_BL_Card
-#define BusMasterInit			FPT_BusMasterInit
-#define CalcCrc16			FPT_CalcCrc16
-#define CalcLrc				FPT_CalcLrc
-#define ChkIfChipInitialized		FPT_ChkIfChipInitialized
-#define DiagBusMaster			FPT_DiagBusMaster
-#define DiagEEPROM			FPT_DiagEEPROM
-#define DiagXbow			FPT_DiagXbow
-#define GetTarLun			FPT_GetTarLun
-#define RNVRamData			FPT_RNVRamData
-#define RdStack				FPT_RdStack
-#define SccbMgrTableInitAll		FPT_SccbMgrTableInitAll
-#define SccbMgrTableInitCard		FPT_SccbMgrTableInitCard
-#define SccbMgrTableInitTarget		FPT_SccbMgrTableInitTarget
-#define SccbMgr_bad_isr			FPT_SccbMgr_bad_isr
-#define SccbMgr_scsi_reset		FPT_SccbMgr_scsi_reset
-#define SccbMgr_timer_expired		FPT_SccbMgr_timer_expired
-#define SendMsg				FPT_SendMsg
-#define Wait				FPT_Wait
-#define Wait1Second			FPT_Wait1Second
-#define WrStack				FPT_WrStack
-#define XbowInit			FPT_XbowInit
-#define autoCmdCmplt			FPT_autoCmdCmplt
-#define autoLoadDefaultMap		FPT_autoLoadDefaultMap
-#define busMstrDataXferStart		FPT_busMstrDataXferStart
-#define busMstrSGDataXferStart		FPT_busMstrSGDataXferStart
-#define busMstrTimeOut			FPT_busMstrTimeOut
-#define dataXferProcessor		FPT_dataXferProcessor
-#define default_intena			FPT_default_intena
-#define hostDataXferAbort		FPT_hostDataXferAbort
-#define hostDataXferRestart		FPT_hostDataXferRestart
-#define inisci				FPT_inisci
-#define mbCards				FPT_mbCards
-#define nvRamInfo			FPT_nvRamInfo
-#define phaseBusFree			FPT_phaseBusFree
-#define phaseChkFifo			FPT_phaseChkFifo
-#define phaseCommand			FPT_phaseCommand
-#define phaseDataIn			FPT_phaseDataIn
-#define phaseDataOut			FPT_phaseDataOut
-#define phaseDecode			FPT_phaseDecode
-#define phaseIllegal			FPT_phaseIllegal
-#define phaseMsgIn			FPT_phaseMsgIn
-#define phaseMsgOut			FPT_phaseMsgOut
-#define phaseStatus			FPT_phaseStatus
-#define queueAddSccb			FPT_queueAddSccb
-#define queueCmdComplete		FPT_queueCmdComplete
-#define queueDisconnect			FPT_queueDisconnect
-#define queueFindSccb			FPT_queueFindSccb
-#define queueFlushSccb			FPT_queueFlushSccb
-#define queueFlushTargSccb		FPT_queueFlushTargSccb
-#define queueSearchSelect		FPT_queueSearchSelect
-#define queueSelectFail			FPT_queueSelectFail
-#define s_PhaseTbl			FPT_s_PhaseTbl
-#define scamHAString			FPT_scamHAString
-#define scamInfo			FPT_scamInfo
-#define scarb				FPT_scarb
-#define scasid				FPT_scasid
-#define scbusf				FPT_scbusf
-#define sccbMgrTbl			FPT_sccbMgrTbl
-#define schkdd				FPT_schkdd
-#define scini				FPT_scini
-#define sciso				FPT_sciso
-#define scmachid			FPT_scmachid
-#define scsavdi				FPT_scsavdi
-#define scsel				FPT_scsel
-#define scsell				FPT_scsell
-#define scsendi				FPT_scsendi
-#define scvalq				FPT_scvalq
-#define scwirod				FPT_scwirod
-#define scwiros				FPT_scwiros
-#define scwtsel				FPT_scwtsel
-#define scxferc				FPT_scxferc
-#define sdecm				FPT_sdecm
-#define sfm				FPT_sfm
-#define shandem				FPT_shandem
-#define sinits				FPT_sinits
-#define sisyncn				FPT_sisyncn
-#define sisyncr				FPT_sisyncr
-#define siwidn				FPT_siwidn
-#define siwidr				FPT_siwidr
-#define sres				FPT_sres
-#define sresb				FPT_sresb
-#define ssel				FPT_ssel
-#define ssenss				FPT_ssenss
-#define sssyncv				FPT_sssyncv
-#define stsyncn				FPT_stsyncn
-#define stwidn				FPT_stwidn
-#define sxfrp				FPT_sxfrp
-#define utilEERead			FPT_utilEERead
-#define utilEEReadOrg			FPT_utilEEReadOrg
-#define utilEESendCmdAddr		FPT_utilEESendCmdAddr
-#define utilEEWrite			FPT_utilEEWrite
-#define utilEEWriteOnOff		FPT_utilEEWriteOnOff
-#define utilUpdateResidual		FPT_utilUpdateResidual
-
-
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   globals.h  $
- *
- *   Description:  Common shared global defines.
- *
- *   $Date: 1996/09/04 01:26:13 $
- *
- *   $Revision: 1.11 $
- *
- *----------------------------------------------------------------------*/
-#ifndef __GLOBALS_H__
-#define __GLOBALS_H__
-
-#define _UCB_MGR_  1
-#define _SCCB_MGR_ 2
-
-/*#include <osflags.h>*/
-
 #define MAX_CDBLEN  12
 
 #define SCAM_LEV_2	1
 
 #define CRCMASK	0xA001
 
-/*  In your osflags.h file, please ENSURE that only ONE OS FLAG 
-    is on at a time !!! Also, please make sure you turn set the 
- 	 variable FW_TYPE to either _UCB_MGR_ or _SCCB_MGR_  !!! */
-
-#if defined(DOS) || defined(WIN95_16) || defined(OS2) || defined(OTHER_16)
-   #define       COMPILER_16_BIT 1
-#elif defined(NETWARE) || defined(NT) || defined(WIN95_32) || defined(UNIX) || defined(OTHER_32) || defined(SOLARIS_REAL_MODE)
-   #define       COMPILER_32_BIT 1
-#endif
-
-
 #define     BL_VENDOR_ID      0x104B
 #define     FP_DEVICE_ID      0x8130
 #define     MM_DEVICE_ID      0x1040
 
 
-#ifndef FALSE
-#define FALSE           0
-#endif
-#ifndef TRUE
-#define TRUE            (!(FALSE))
-#endif
-
-#ifndef NULL
-#define NULL            0
-#endif
-
 #define FAILURE         0xFFFFFFFFL
 
 
@@ -222,26 +71,10 @@ typedef unsigned long * PULONG;
 typedef void *          PVOID;
 
 
-#if defined(COMPILER_16_BIT)
-typedef unsigned char far       * uchar_ptr;
-typedef unsigned short far      * ushort_ptr;
-typedef unsigned long far       * ulong_ptr;
-#endif  /* 16_BIT_COMPILER */
-
-#if defined(COMPILER_32_BIT)
 typedef unsigned char           * uchar_ptr;
 typedef unsigned short          * ushort_ptr;
 typedef unsigned long           * ulong_ptr;
-#endif  /* 32_BIT_COMPILER */
-
-
-/*	 			NEW TYPE DEFINITIONS (shared with Mylex North)
 
-**  Use following type defines to avoid confusion in 16 and 32-bit
-**  environments.  Avoid using 'int' as it denotes 16 bits in 16-bit
-**  environment and 32 in 32-bit environments.
-
-*/
 
 #define s08bits	char
 #define s16bits 	short
@@ -251,195 +84,19 @@ typedef unsigned long           * ulong_ptr;
 #define u16bits	unsigned s16bits
 #define u32bits	unsigned s32bits
 
-#if defined(COMPILER_16_BIT)
-
-typedef u08bits far 	* pu08bits;
-typedef u16bits far 	* pu16bits;
-typedef u32bits far	* pu32bits;
-
-#endif	/* COMPILER_16_BIT */
-
-#if defined(COMPILER_32_BIT)
-
 typedef u08bits 	* pu08bits;
 typedef u16bits 	* pu16bits;
 typedef u32bits 	* pu32bits;
 
-#endif	/* COMPILER_32_BIT */
-
 
 #define BIT(x)          ((UCHAR)(1<<(x)))    /* single-bit mask in bit position x */
 #define BITW(x)          ((USHORT)(1<<(x)))  /* single-bit mask in bit position x */
 
 
 
-#if defined(DOS)
-/*#include <dos.h>*/
-	#undef inportb          /* undefine for Borland Lib */
-	#undef inport           /* they may have define I/O function in LIB */
-	#undef outportb
-	#undef outport
-
-	#define OS_InPortByte(ioport) 		inportb(ioport)
-	#define OS_InPortWord(ioport) 		inport(ioport)
-	#define OS_InPortLong(ioport)			inportq(ioport, val)
-	#define OS_OutPortByte(ioport, val) outportb(ioport, val)
-	#define OS_OutPortWord(ioport, val)	outport(ioport, val)
-	#define OS_OutPortLong(ioport)		outportq(ioport, val)
-#endif	/* DOS */
-
-#if defined(NETWARE) || defined(OTHER_32) ||  defined(OTHER_16)
-	extern u08bits	OS_InPortByte(u32bits ioport);
-	extern u16bits	OS_InPortWord(u32bits ioport);
-	extern u32bits	OS_InPortLong(u32bits ioport);
-
-	extern OS_InPortByteBuffer(u32bits ioport, pu08bits buffer, u32bits count);
-	extern OS_InPortWordBuffer(u32bits ioport, pu16bits buffer, u32bits count);
-	extern OS_OutPortByte(u32bits ioport, u08bits val);
-	extern OS_OutPortWord(u32bits ioport, u16bits val);
-	extern OS_OutPortLong(u32bits ioport, u32bits val);
-	extern OS_OutPortByteBuffer(u32bits ioport, pu08bits buffer, u32bits count);
-	extern OS_OutPortWordBuffer(u32bits ioport, pu16bits buffer, u32bits count);
-#endif	/* NETWARE || OTHER_32 || OTHER_16 */
-
-#if defined (NT) || defined(WIN95_32) || defined(WIN95_16)
-	#if defined(NT)
-
-		extern __declspec(dllimport) u08bits ScsiPortReadPortUchar(pu08bits ioport);
-		extern __declspec(dllimport) u16bits ScsiPortReadPortUshort(pu16bits ioport);
-		extern __declspec(dllimport) u32bits ScsiPortReadPortUlong(pu32bits ioport);
-		extern __declspec(dllimport) void ScsiPortWritePortUchar(pu08bits ioport, u08bits val);
-		extern __declspec(dllimport) void ScsiPortWritePortUshort(pu16bits port, u16bits val);
-		extern __declspec(dllimport) void ScsiPortWritePortUlong(pu32bits port, u32bits val);
-
-	#else
-
-		extern u08bits ScsiPortReadPortUchar(pu08bits ioport);
-		extern u16bits ScsiPortReadPortUshort(pu16bits ioport);
-		extern u32bits ScsiPortReadPortUlong(pu32bits ioport);
-		extern void ScsiPortWritePortUchar(pu08bits ioport, u08bits val);
-		extern void ScsiPortWritePortUshort(pu16bits port, u16bits val);
-		extern void ScsiPortWritePortUlong(pu32bits port, u32bits val);
-	#endif
-
-
-	#define OS_InPortByte(ioport) ScsiPortReadPortUchar((pu08bits) ioport)
-	#define OS_InPortWord(ioport) ScsiPortReadPortUshort((pu16bits) ioport)
-	#define OS_InPortLong(ioport) ScsiPortReadPortUlong((pu32bits) ioport)
-
-	#define OS_OutPortByte(ioport, val) ScsiPortWritePortUchar((pu08bits) ioport, (u08bits) val)
-	#define OS_OutPortWord(ioport, val) ScsiPortWritePortUshort((pu16bits) ioport, (u16bits) val)
-	#define OS_OutPortLong(ioport, val) ScsiPortWritePortUlong((pu32bits) ioport, (u32bits) val)
-	#define OS_OutPortByteBuffer(ioport, buffer, count) \
-		ScsiPortWritePortBufferUchar((pu08bits)&port, (pu08bits) buffer, (u32bits) count)
-	#define OS_OutPortWordBuffer(ioport, buffer, count) \
-		ScsiPortWritePortBufferUshort((pu16bits)&port, (pu16bits) buffer, (u32bits) count)
-
-	#define OS_Lock(x)
-	#define OS_UnLock(x)
-#endif /* NT || WIN95_32 || WIN95_16 */
-
-#if defined (UNIX) && !defined(OS_InPortByte)
-	#define OS_InPortByte(ioport)    inb((u16bits)ioport)
-	#define OS_InPortWord(ioport)    inw((u16bits)ioport)
-	#define OS_InPortLong(ioport)    inl((u16bits)ioport)
-	#define OS_OutPortByte(ioport,val)  outb((u16bits)ioport, (u08bits)val)
-	#define OS_OutPortWord(ioport,val)  outw((u16bits)ioport, (u16bits)val)
-	#define OS_OutPortLong(ioport,val)  outl((u16bits)ioport, (u32bits)val)
-
-	#define OS_Lock(x)
-	#define OS_UnLock(x)
-#endif /* UNIX */
-
-
-#if defined(OS2)
-	extern u08bits	inb(u32bits ioport);
-	extern u16bits	inw(u32bits ioport);
-	extern void	outb(u32bits ioport, u08bits val);
-	extern void	outw(u32bits ioport, u16bits val);
-
-	#define OS_InPortByte(ioport)			inb(ioport)
-	#define OS_InPortWord(ioport)			inw(ioport)
-	#define OS_OutPortByte(ioport, val)	outb(ioport, val)
-	#define OS_OutPortWord(ioport, val)	outw(ioport, val)
-	extern u32bits	OS_InPortLong(u32bits ioport);
-	extern void	OS_OutPortLong(u32bits ioport, u32bits val);
-
-	#define OS_Lock(x)
-	#define OS_UnLock(x)
-#endif /* OS2 */
-
-#if defined(SOLARIS_REAL_MODE)
-
-extern unsigned char    inb(unsigned long ioport);
-extern unsigned short   inw(unsigned long ioport);
-
-#define OS_InPortByte(ioport)    inb(ioport)
-#define OS_InPortWord(ioport)    inw(ioport)
-
-extern void OS_OutPortByte(unsigned long ioport, unsigned char val);
-extern void OS_OutPortWord(unsigned long ioport, unsigned short val);
-extern unsigned long  OS_InPortLong(unsigned long ioport);
-extern void     OS_OutPortLong(unsigned long ioport, unsigned long val);
-
-#define OS_Lock(x)
-#define OS_UnLock(x)
-
-#endif  /* SOLARIS_REAL_MODE */
-
-#endif  /* __GLOBALS_H__ */
-
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   sccbmgr.h  $
- *
- *   Description:  Common shared SCCB Interface defines and SCCB 
- *						 Manager specifics defines.
- *
- *   $Date: 1996/10/24 23:09:33 $
- *
- *   $Revision: 1.14 $
- *
- *----------------------------------------------------------------------*/
-
-#ifndef __SCCB_H__
-#define __SCCB_H__
-
-/*#include <osflags.h>*/
-/*#include <globals.h>*/
-
-#if defined(BUGBUG)
-#define debug_size 32
-#endif
-
-#if defined(DOS)
-
-   typedef struct _SCCB near *PSCCB;
-	#if (FW_TYPE == _SCCB_MGR_)
-   	typedef void (*CALL_BK_FN)(PSCCB);
-	#endif
-
-#elif defined(OS2)
-
-   typedef struct _SCCB far *PSCCB;
-	#if (FW_TYPE == _SCCB_MGR_)
-   	typedef void (far *CALL_BK_FN)(PSCCB);
-	#endif
-
-#else
-
-   typedef struct _SCCB *PSCCB;
-	#if (FW_TYPE == _SCCB_MGR_)
-   	typedef void (*CALL_BK_FN)(PSCCB);
-	#endif
 
-#endif
+typedef struct _SCCB *PSCCB;
+typedef void (*CALL_BK_FN)(PSCCB);
 
 
 typedef struct SCCBMgr_info {
@@ -466,25 +123,13 @@ typedef struct SCCBMgr_info {
    ULONG    si_secondary_range;
 } SCCBMGR_INFO;
 
-#if defined(DOS)
-   typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
-#else
-   #if defined (COMPILER_16_BIT)
-   typedef SCCBMGR_INFO far *  PSCCBMGR_INFO;
-   #else
-   typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
-   #endif
-#endif // defined(DOS)
-
+typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
 
 
-
-#if (FW_TYPE==_SCCB_MGR_)
-	#define SCSI_PARITY_ENA		  0x0001
-	#define LOW_BYTE_TERM		  0x0010
-	#define HIGH_BYTE_TERM		  0x0020
-	#define BUSTYPE_PCI	  0x3
-#endif
+#define SCSI_PARITY_ENA		  0x0001
+#define LOW_BYTE_TERM		  0x0010
+#define HIGH_BYTE_TERM		  0x0020
+#define BUSTYPE_PCI	  0x3
 
 #define SUPPORT_16TAR_32LUN	  0x0002
 #define SOFT_RESET		  0x0004
@@ -553,9 +198,6 @@ typedef struct _SCCB {
    UCHAR   Save_CdbLen;
    UCHAR   Sccb_XferState;
    ULONG   Sccb_SGoffset;
-#if (FW_TYPE == _UCB_MGR_)
-   PUCB    Sccb_ucb_ptr;
-#endif
    } SCCB;
 
 #define SCCB_SIZE sizeof(SCCB)
@@ -626,25 +268,9 @@ typedef struct _SCCB {
 
 
 
-#if (FW_TYPE==_UCB_MGR_)  
-   #define  HBA_AUTO_SENSE_FAIL        0x1B  
-   #define  HBA_TQ_REJECTED            0x1C  
-   #define  HBA_UNSUPPORTED_MSG         0x1D  
-   #define  HBA_HW_ERROR               0x20  
-   #define  HBA_ATN_NOT_RESPONDED      0x21  
-   #define  HBA_SCSI_RESET_BY_ADAPTER  0x22
-   #define  HBA_SCSI_RESET_BY_TARGET   0x23
-   #define  HBA_WRONG_CONNECTION       0x24
-   #define  HBA_BUS_DEVICE_RESET       0x25
-   #define  HBA_ABORT_QUEUE            0x26
-
-#else // these are not defined in BUDI/UCB
-
-   #define SCCB_INVALID_DIRECTION      0x18  /* Invalid target direction */
-   #define SCCB_DUPLICATE_SCCB         0x19  /* Duplicate SCCB */
-   #define SCCB_SCSI_RST               0x35  /* SCSI RESET detected. */
-
-#endif // (FW_TYPE==_UCB_MGR_)  
+#define SCCB_INVALID_DIRECTION      0x18  /* Invalid target direction */
+#define SCCB_DUPLICATE_SCCB         0x19  /* Duplicate SCCB */
+#define SCCB_SCSI_RST               0x35  /* SCSI RESET detected. */
 
 
 #define SCCB_IN_PROCESS            0x00
@@ -657,115 +283,20 @@ typedef struct _SCCB {
 #define SCCB_SIZE sizeof(SCCB)
 
 
-
-
-#if (FW_TYPE == _UCB_MGR_)
-	void SccbMgr_start_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb);
-	s32bits SccbMgr_abort_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb);
-	u08bits SccbMgr_my_int(CARD_HANDLE pCurrCard);
-	s32bits SccbMgr_isr(CARD_HANDLE pCurrCard);
-	void SccbMgr_scsi_reset(CARD_HANDLE pCurrCard);
-	void SccbMgr_timer_expired(CARD_HANDLE pCurrCard);
-	void SccbMgr_unload_card(CARD_HANDLE pCurrCard);
-	void SccbMgr_restore_foreign_state(CARD_HANDLE pCurrCard);
-	void SccbMgr_restore_native_state(CARD_HANDLE pCurrCard);
-	void SccbMgr_save_foreign_state(PADAPTER_INFO pAdapterInfo);
-
-#endif
-
-
-#if (FW_TYPE == _SCCB_MGR_)
-
- #if defined (DOS)
-	int    SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo);
-	USHORT SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo);
-	void  SccbMgr_start_sccb(USHORT pCurrCard, PSCCB p_SCCB);
-	int   SccbMgr_abort_sccb(USHORT pCurrCard, PSCCB p_SCCB);
-	UCHAR SccbMgr_my_int(USHORT pCurrCard);
-	int   SccbMgr_isr(USHORT pCurrCard);
-	void  SccbMgr_scsi_reset(USHORT pCurrCard);
-	void  SccbMgr_timer_expired(USHORT pCurrCard);
-	USHORT SccbMgr_status(USHORT pCurrCard);
-	void SccbMgr_unload_card(USHORT pCurrCard);
-
- #else    //non-DOS
-
-	int   SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo);
-	ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo);
-	void  SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_SCCB);
-	int   SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_SCCB);
-	UCHAR SccbMgr_my_int(ULONG pCurrCard);
-	int   SccbMgr_isr(ULONG pCurrCard);
-	void  SccbMgr_scsi_reset(ULONG pCurrCard);
-	void  SccbMgr_enable_int(ULONG pCurrCard);
-	void  SccbMgr_disable_int(ULONG pCurrCard);
-	void  SccbMgr_timer_expired(ULONG pCurrCard);
-	void SccbMgr_unload_card(ULONG pCurrCard);
-
-  #endif
-#endif  // (FW_TYPE == _SCCB_MGR_)
-
-#endif  /* __SCCB_H__ */
-
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   blx30.h  $
- *
- *   Description: This module contains SCCB/UCB Manager implementation
- *                specific stuff.
- *
- *   $Date: 1996/11/13 18:34:22 $
- *
- *   $Revision: 1.10 $
- *
- *----------------------------------------------------------------------*/
-
-
-#ifndef __blx30_H__
-#define __blx30_H__
-
-/*#include <globals.h>*/
-
 #define  ORION_FW_REV      3110
 
-
-
-
 #define HARP_REVD    1
 
 
-#if defined(DOS)
-#define QUEUE_DEPTH     8+1            /*1 for Normal disconnect 0 for Q'ing. */
-#else
 #define QUEUE_DEPTH     254+1            /*1 for Normal disconnect 32 for Q'ing. */
-#endif   // defined(DOS)
 
 #define	MAX_MB_CARDS	4					/* Max. no of cards suppoerted on Mother Board */
 
 #define WIDE_SCSI       1
 
-#if defined(WIDE_SCSI)
-   #if defined(DOS)
-      #define MAX_SCSI_TAR    16
-      #define MAX_LUN         8
-		#define LUN_MASK			0x07
-   #else
-      #define MAX_SCSI_TAR    16
-      #define MAX_LUN         32
-		#define LUN_MASK			0x1f
-	
-   #endif
-#else
-   #define MAX_SCSI_TAR    8
-   #define MAX_LUN         8
-	#define LUN_MASK			0x07
-#endif 
+#define MAX_SCSI_TAR    16
+#define MAX_LUN         32
+#define LUN_MASK			0x1f
 
 #if defined(HARP_REVA)
 #define SG_BUF_CNT      15             /*Number of prefetched elements. */
@@ -778,116 +309,12 @@ typedef struct _SCCB {
 #define SG_ELEMENT_MASK 0xFFFFFFFFL
 
 
-#if (FW_TYPE == _UCB_MGR_)
-	#define OPC_DECODE_NORMAL       0x0f7f
-#endif   // _UCB_MGR_
-
-
-
-#if defined(DOS)
-
-/*#include <dos.h>*/
-	#define RD_HARPOON(ioport)          (OS_InPortByte(ioport))
-	#define RDW_HARPOON(ioport)         (OS_InPortWord(ioport))
-	#define WR_HARPOON(ioport,val)      (OS_OutPortByte(ioport,val))
-	#define WRW_HARPOON(ioport,val)     (OS_OutPortWord(ioport,val))
-
-	#define RD_HARP32(port,offset,data)  asm{db 66h;         \
-                                       push ax;             \
-                                       mov dx,port;         \
-                                       add dx, offset;      \
-                                       db 66h;              \
-                                       in ax,dx;            \
-                                       db 66h;              \
-                                       mov word ptr data,ax;\
-                                       db 66h;              \
-                                       pop ax}
-
-	#define WR_HARP32(port,offset,data) asm{db 66h;          \
-                                       push ax;             \
-                                       mov dx,port;         \
-                                       add dx, offset;      \
-                                       db 66h;              \
-                                       mov ax,word ptr data;\
-                                       db 66h;              \
-                                       out dx,ax;           \
-                                       db 66h;              \
-                                       pop ax}
-#endif	/* DOS */
-
-#if defined(NETWARE) || defined(OTHER_32) ||  defined(OTHER_16)
-	#define RD_HARPOON(ioport)     OS_InPortByte((unsigned long)ioport)
-	#define RDW_HARPOON(ioport)    OS_InPortWord((unsigned long)ioport)
-	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong(ioport + offset))
-	#define WR_HARPOON(ioport,val) OS_OutPortByte((ULONG)ioport,(UCHAR) val)
-	#define WRW_HARPOON(ioport,val)  OS_OutPortWord((ULONG)ioport,(USHORT)val)
-	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((ioport + offset), data)
-#endif	/* NETWARE || OTHER_32 || OTHER_16 */
-
-#if defined(NT) || defined(WIN95_32) || defined(WIN95_16)
-	#define RD_HARPOON(ioport)          OS_InPortByte((ULONG)ioport)
-	#define RDW_HARPOON(ioport)         OS_InPortWord((ULONG)ioport)
-	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((ULONG)(ioport + offset)))
-	#define WR_HARPOON(ioport,val)      OS_OutPortByte((ULONG)ioport,(UCHAR) val)
-	#define WRW_HARPOON(ioport,val)     OS_OutPortWord((ULONG)ioport,(USHORT)val)
-	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((ULONG)(ioport + offset), data)
-#endif /* NT || WIN95_32 || WIN95_16 */
-
-#if defined (UNIX)
-	#define RD_HARPOON(ioport)          OS_InPortByte((u32bits)ioport)
-	#define RDW_HARPOON(ioport)         OS_InPortWord((u32bits)ioport)
-	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((u32bits)(ioport + offset)))
-	#define WR_HARPOON(ioport,val)      OS_OutPortByte((u32bits)ioport,(u08bits) val)
-	#define WRW_HARPOON(ioport,val)       OS_OutPortWord((u32bits)ioport,(u16bits)val)
-	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((u32bits)(ioport + offset), data)
-#endif /* UNIX */
-
-#if defined(OS2)
-	#define RD_HARPOON(ioport)          OS_InPortByte((unsigned long)ioport)
-	#define RDW_HARPOON(ioport)         OS_InPortWord((unsigned long)ioport)
-	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((ULONG)(ioport + offset)))
-	#define WR_HARPOON(ioport,val)      OS_OutPortByte((ULONG)ioport,(UCHAR) val)
-	#define WRW_HARPOON(ioport,val)       OS_OutPortWord((ULONG)ioport,(USHORT)val)
-	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong(((ULONG)(ioport + offset)), data)
-#endif /* OS2 */
-
-#if defined(SOLARIS_REAL_MODE)
-
-	#define RD_HARPOON(ioport)          OS_InPortByte((unsigned long)ioport)
-	#define RDW_HARPOON(ioport)         OS_InPortWord((unsigned long)ioport)
-	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((ULONG)(ioport + offset)))
-	#define WR_HARPOON(ioport,val)      OS_OutPortByte((ULONG)ioport,(UCHAR) val)
-	#define WRW_HARPOON(ioport,val)       OS_OutPortWord((ULONG)ioport,(USHORT)val)
-	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((ULONG)(ioport + offset), (ULONG)data)
-
-#endif  /* SOLARIS_REAL_MODE */
-
-#endif  /* __BLX30_H__ */
-
-
-/*----------------------------------------------------------------------
- * 
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   target.h  $
- *
- *   Description:  Definitions for Target related structures
- *
- *   $Date: 1996/12/11 22:06:20 $
- *
- *   $Revision: 1.9 $
- *
- *----------------------------------------------------------------------*/
-
-#ifndef __TARGET__
-#define __TARGET__
-
-/*#include <globals.h>*/
-/*#include <blx30.h>*/
+#define RD_HARPOON(ioport)          OS_InPortByte((u32bits)ioport)
+#define RDW_HARPOON(ioport)         OS_InPortWord((u32bits)ioport)
+#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((u32bits)(ioport + offset)))
+#define WR_HARPOON(ioport,val)      OS_OutPortByte((u32bits)ioport,(u08bits) val)
+#define WRW_HARPOON(ioport,val)       OS_OutPortWord((u32bits)ioport,(u16bits)val)
+#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((u32bits)(ioport + offset), data)
 
 
 #define  TAR_SYNC_MASK     (BIT(7)+BIT(6))
@@ -919,16 +346,7 @@ typedef struct _SCCB {
 #define  EE_WIDE_SCSI      BIT(7)
 
 
-#if defined(DOS)
-   typedef struct SCCBMgr_tar_info near *PSCCBMgr_tar_info;
-
-#elif defined(OS2)
-   typedef struct SCCBMgr_tar_info far *PSCCBMgr_tar_info;
-
-#else
-   typedef struct SCCBMgr_tar_info *PSCCBMgr_tar_info;
-
-#endif
+typedef struct SCCBMgr_tar_info *PSCCBMgr_tar_info;
 
 
 typedef struct SCCBMgr_tar_info {
@@ -949,11 +367,7 @@ typedef struct SCCBMgr_tar_info {
 typedef struct NVRAMInfo {
 	UCHAR		niModel;								/* Model No. of card */
 	UCHAR		niCardNo;							/* Card no. */
-#if defined(DOS)
-	USHORT	niBaseAddr;							/* Port Address of card */
-#else
 	ULONG		niBaseAddr;							/* Port Address of card */
-#endif
 	UCHAR		niSysConf;							/* Adapter Configuration byte - Byte 16 of eeprom map */
 	UCHAR		niScsiConf;							/* SCSI Configuration byte - Byte 17 of eeprom map */
 	UCHAR		niScamConf;							/* SCAM Configuration byte - Byte 20 of eeprom map */
@@ -962,13 +376,7 @@ typedef struct NVRAMInfo {
 	UCHAR		niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
 }NVRAMINFO;
 
-#if defined(DOS)
-typedef NVRAMINFO near *PNVRamInfo;
-#elif defined (OS2)
-typedef NVRAMINFO far *PNVRamInfo;
-#else
 typedef NVRAMINFO *PNVRamInfo;
-#endif
 
 #define	MODEL_LT		1
 #define	MODEL_DL		2
@@ -978,17 +386,9 @@ typedef NVRAMINFO *PNVRamInfo;
 
 typedef struct SCCBcard {
    PSCCB currentSCCB;
-#if (FW_TYPE==_SCCB_MGR_)
    PSCCBMGR_INFO cardInfo;
-#else
-   PADAPTER_INFO cardInfo;
-#endif
 
-#if defined(DOS)
-   USHORT ioPort;
-#else
    ULONG ioPort;
-#endif
 
    USHORT cmdCounter;
    UCHAR  discQCount;
@@ -1002,13 +402,7 @@ typedef struct SCCBcard {
       
 }SCCBCARD;
 
-#if defined(DOS)
-typedef struct SCCBcard near *PSCCBcard;
-#elif defined (OS2)
-typedef struct SCCBcard far *PSCCBcard;
-#else
 typedef struct SCCBcard *PSCCBcard;
-#endif
 
 
 #define F_TAG_STARTED		0x01
@@ -1063,29 +457,6 @@ typedef struct SCCBscam_info {
     
 } SCCBSCAM_INFO, *PSCCBSCAM_INFO;
 
-#endif
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   scsi2.h  $
- *
- *   Description:  Register definitions for HARPOON ASIC.
- *
- *   $Date: 1996/11/13 18:32:57 $
- *
- *   $Revision: 1.4 $
- *
- *----------------------------------------------------------------------*/
-
-#ifndef __SCSI_H__
-#define __SCSI_H__
-
-
 
 #define  SCSI_TEST_UNIT_READY    0x00
 #define  SCSI_REZERO_UNIT        0x01
@@ -1195,29 +566,6 @@ typedef struct SCCBscam_info {
 #define  SYNC5MBS                0x32
 #define  MAX_OFFSET              0x0F  /* Maxbyteoffset for Sync Xfers */
 
-#endif
-/*----------------------------------------------------------------------
- *  
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   eeprom.h  $
- *
- *   Description:  Definitions for EEPROM related structures
- *
- *   $Date: 1996/11/13 18:28:39 $
- *
- *   $Revision: 1.4 $
- *
- *----------------------------------------------------------------------*/
-
-#ifndef __EEPROM__
-#define __EEPROM__
-
-/*#include <globals.h>*/
 
 #define  EEPROM_WD_CNT     256
 
@@ -1280,31 +628,6 @@ typedef struct SCCBscam_info {
    #define  DISC_ENABLE_BIT   BIT(6)
 
 
-#endif
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   harpoon.h  $
- *
- *   Description:  Register definitions for HARPOON ASIC.
- *
- *   $Date: 1997/07/09 21:44:36 $
- *
- *   $Revision: 1.9 $
- *
- *----------------------------------------------------------------------*/
-
-
-/*#include <globals.h>*/
-
-#ifndef __HARPOON__
-#define __HARPOON__
-
 
    #define  hp_vendor_id_0       0x00		/* LSB */
       #define  ORION_VEND_0   0x4B
@@ -1578,8 +901,6 @@ typedef struct SCCBscam_info {
 
 
 
-   extern USHORT default_intena;
-
    #define  hp_intena		 0x40
 
       #define  RESET		 BITW(7)
@@ -1972,15 +1293,6 @@ typedef struct SCCBscam_info {
                                  xfercnt <<= 16,\
                                  xfercnt |= RDW_HARPOON((USHORT)(port+hp_xfercnt_0)))
  */
-#if defined(DOS)
-#define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((USHORT)(port+hp_host_addr_lo), (USHORT)(addr & 0x0000FFFFL)),\
-         addr >>= 16,\
-         WRW_HARPOON((USHORT)(port+hp_host_addr_hmi), (USHORT)(addr & 0x0000FFFFL)),\
-         WR_HARP32(port,hp_xfercnt_0,count),\
-         WRW_HARPOON((USHORT)(port+hp_xfer_cnt_lo), (USHORT)(count & 0x0000FFFFL)),\
-         count >>= 16,\
-         WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))
-#else
 #define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((port+hp_host_addr_lo), (USHORT)(addr & 0x0000FFFFL)),\
          addr >>= 16,\
          WRW_HARPOON((port+hp_host_addr_hmi), (USHORT)(addr & 0x0000FFFFL)),\
@@ -1988,7 +1300,6 @@ typedef struct SCCBscam_info {
          WRW_HARPOON((port+hp_xfer_cnt_lo), (USHORT)(count & 0x0000FFFFL)),\
          count >>= 16,\
          WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))
-#endif
 
 #define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
                           WR_HARPOON(port+hp_scsisig, S_ILL_PH);}
@@ -2020,383 +1331,145 @@ typedef struct SCCBscam_info {
 
 
 
-#endif
-
-
-#if (FW_TYPE==_UCB_MGR_)
-void ReadNVRam(PSCCBcard pCurrCard,PUCB p_ucb);
-void WriteNVRam(PSCCBcard pCurrCard,PUCB p_ucb);
-void UpdateCheckSum(u32bits baseport);
-#endif // (FW_TYPE==_UCB_MGR_)
-
-#if defined(DOS)
-UCHAR sfm(USHORT port, PSCCB pcurrSCCB);
-void  scsiStartAuto(USHORT port);
-UCHAR sisyncn(USHORT port, UCHAR p_card, UCHAR syncFlag);
-void  ssel(USHORT port, UCHAR p_card);
-void  sres(USHORT port, UCHAR p_card, PSCCBcard pCurrCard);
-void  sdecm(UCHAR message, USHORT port, UCHAR p_card);
-void  shandem(USHORT port, UCHAR p_card,PSCCB pCurrSCCB);
-void  stsyncn(USHORT port, UCHAR p_card);
-void  sisyncr(USHORT port,UCHAR sync_pulse, UCHAR offset);
-void  sssyncv(USHORT p_port, UCHAR p_id, UCHAR p_sync_value, PSCCBMgr_tar_info currTar_Info);
-void  sresb(USHORT port, UCHAR p_card);
-void  sxfrp(USHORT p_port, UCHAR p_card);
-void  schkdd(USHORT port, UCHAR p_card);
-UCHAR RdStack(USHORT port, UCHAR index);
-void  WrStack(USHORT portBase, UCHAR index, UCHAR data);
-UCHAR ChkIfChipInitialized(USHORT ioPort);
-
-#if defined(V302)
-UCHAR GetTarLun(USHORT port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tag, PUCHAR lun);
-#endif
 
-void SendMsg(USHORT port, UCHAR message);
-void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code);
-UCHAR scsellDOS(USHORT p_port, UCHAR targ_id);
-#else
-UCHAR sfm(ULONG port, PSCCB pcurrSCCB);
 void  scsiStartAuto(ULONG port);
-UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag);
-void  ssel(ULONG port, UCHAR p_card);
-void  sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard);
-void  sdecm(UCHAR message, ULONG port, UCHAR p_card);
-void  shandem(ULONG port, UCHAR p_card,PSCCB pCurrSCCB);
-void  stsyncn(ULONG port, UCHAR p_card);
-void  sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset);
-void  sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value, PSCCBMgr_tar_info currTar_Info);
-void  sresb(ULONG port, UCHAR p_card);
-void  sxfrp(ULONG p_port, UCHAR p_card);
-void  schkdd(ULONG port, UCHAR p_card);
-UCHAR RdStack(ULONG port, UCHAR index);
-void  WrStack(ULONG portBase, UCHAR index, UCHAR data);
-UCHAR ChkIfChipInitialized(ULONG ioPort);
-
-#if defined(V302)
-UCHAR GetTarLun(ULONG port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tar, PUCHAR lun);
-#endif
-
-void SendMsg(ULONG port, UCHAR message);
-void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code);
-#endif
-
-void  ssenss(PSCCBcard pCurrCard);
-void  sinits(PSCCB p_sccb, UCHAR p_card);
-void  RNVRamData(PNVRamInfo pNvRamInfo);
-
-#if defined(WIDE_SCSI)
-   #if defined(DOS)
-   UCHAR siwidn(USHORT port, UCHAR p_card);
-   void  stwidn(USHORT port, UCHAR p_card);
-   void  siwidr(USHORT port, UCHAR width);
-   #else
-   UCHAR siwidn(ULONG port, UCHAR p_card);
-   void  stwidn(ULONG port, UCHAR p_card);
-   void  siwidr(ULONG port, UCHAR width);
-   #endif
-#endif
-
+static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag);
+static void  FPT_ssel(ULONG port, UCHAR p_card);
+static void  FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard);
+static void  FPT_shandem(ULONG port, UCHAR p_card,PSCCB pCurrSCCB);
+static void  FPT_stsyncn(ULONG port, UCHAR p_card);
+static void  FPT_sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset);
+static void  FPT_sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,
+			 PSCCBMgr_tar_info currTar_Info);
+static void  FPT_sresb(ULONG port, UCHAR p_card);
+static void  FPT_sxfrp(ULONG p_port, UCHAR p_card);
+static void  FPT_schkdd(ULONG port, UCHAR p_card);
+static UCHAR FPT_RdStack(ULONG port, UCHAR index);
+static void  FPT_WrStack(ULONG portBase, UCHAR index, UCHAR data);
+static UCHAR FPT_ChkIfChipInitialized(ULONG ioPort);
 
-void  queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card);
-void  queueDisconnect(PSCCB p_SCCB, UCHAR p_card);
-void  queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_SCCB, UCHAR p_card);
-void  queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card);
-void  queueFlushSccb(UCHAR p_card, UCHAR error_code);
-void  queueAddSccb(PSCCB p_SCCB, UCHAR card);
-UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card);
-void  utilUpdateResidual(PSCCB p_SCCB);
-USHORT CalcCrc16(UCHAR buffer[]);
-UCHAR  CalcLrc(UCHAR buffer[]);
-
-
-#if defined(DOS)
-void  Wait1Second(USHORT p_port);
-void  Wait(USHORT p_port, UCHAR p_delay);
-void  utilEEWriteOnOff(USHORT p_port,UCHAR p_mode);
-void  utilEEWrite(USHORT p_port, USHORT ee_data, USHORT ee_addr);
-USHORT utilEERead(USHORT p_port, USHORT ee_addr);
-USHORT utilEEReadOrg(USHORT p_port, USHORT ee_addr);
-void  utilEESendCmdAddr(USHORT p_port, UCHAR ee_cmd, USHORT ee_addr);
-#else
-void  Wait1Second(ULONG p_port);
-void  Wait(ULONG p_port, UCHAR p_delay);
-void  utilEEWriteOnOff(ULONG p_port,UCHAR p_mode);
-void  utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr);
-USHORT utilEERead(ULONG p_port, USHORT ee_addr);
-USHORT utilEEReadOrg(ULONG p_port, USHORT ee_addr);
-void  utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr);
-#endif
-
-
-
-#if defined(OS2)
-   void  far phaseDataOut(ULONG port, UCHAR p_card);
-   void  far phaseDataIn(ULONG port, UCHAR p_card);
-   void  far phaseCommand(ULONG port, UCHAR p_card);
-   void  far phaseStatus(ULONG port, UCHAR p_card);
-   void  far phaseMsgOut(ULONG port, UCHAR p_card);
-   void  far phaseMsgIn(ULONG port, UCHAR p_card);
-   void  far phaseIllegal(ULONG port, UCHAR p_card);
-#else
-   #if defined(DOS)
-      void  phaseDataOut(USHORT port, UCHAR p_card);
-      void  phaseDataIn(USHORT port, UCHAR p_card);
-      void  phaseCommand(USHORT port, UCHAR p_card);
-      void  phaseStatus(USHORT port, UCHAR p_card);
-      void  phaseMsgOut(USHORT port, UCHAR p_card);
-      void  phaseMsgIn(USHORT port, UCHAR p_card);
-      void  phaseIllegal(USHORT port, UCHAR p_card);
-   #else
-      void  phaseDataOut(ULONG port, UCHAR p_card);
-      void  phaseDataIn(ULONG port, UCHAR p_card);
-      void  phaseCommand(ULONG port, UCHAR p_card);
-      void  phaseStatus(ULONG port, UCHAR p_card);
-      void  phaseMsgOut(ULONG port, UCHAR p_card);
-      void  phaseMsgIn(ULONG port, UCHAR p_card);
-      void  phaseIllegal(ULONG port, UCHAR p_card);
-   #endif
-#endif
-
-#if defined(DOS)
-void  phaseDecode(USHORT port, UCHAR p_card);
-void  phaseChkFifo(USHORT port, UCHAR p_card);
-void  phaseBusFree(USHORT p_port, UCHAR p_card);
-#else
-void  phaseDecode(ULONG port, UCHAR p_card);
-void  phaseChkFifo(ULONG port, UCHAR p_card);
-void  phaseBusFree(ULONG p_port, UCHAR p_card);
-#endif
-
-
-
-
-#if defined(DOS)
-void  XbowInit(USHORT port, UCHAR scamFlg);
-void  BusMasterInit(USHORT p_port);
-int   DiagXbow(USHORT port);
-int   DiagBusMaster(USHORT port);
-void  DiagEEPROM(USHORT p_port);
-#else
-void  XbowInit(ULONG port, UCHAR scamFlg);
-void  BusMasterInit(ULONG p_port);
-int   DiagXbow(ULONG port);
-int   DiagBusMaster(ULONG port);
-void  DiagEEPROM(ULONG p_port);
-#endif
+static void FPT_SendMsg(ULONG port, UCHAR message);
+static void  FPT_queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg,
+				    UCHAR error_code);
 
+static void  FPT_sinits(PSCCB p_sccb, UCHAR p_card);
+static void  FPT_RNVRamData(PNVRamInfo pNvRamInfo);
 
+static UCHAR FPT_siwidn(ULONG port, UCHAR p_card);
+static void  FPT_stwidn(ULONG port, UCHAR p_card);
+static void  FPT_siwidr(ULONG port, UCHAR width);
 
 
-#if defined(DOS)
-void  busMstrAbort(USHORT port);
-UCHAR busMstrTimeOut(USHORT port);
-void  dataXferProcessor(USHORT port, PSCCBcard pCurrCard);
-void  busMstrSGDataXferStart(USHORT port, PSCCB pCurrSCCB);
-void  busMstrDataXferStart(USHORT port, PSCCB pCurrSCCB);
-void  hostDataXferAbort(USHORT port, UCHAR p_card, PSCCB pCurrSCCB);
-#else
-void  busMstrAbort(ULONG port);
-UCHAR busMstrTimeOut(ULONG port);
-void  dataXferProcessor(ULONG port, PSCCBcard pCurrCard);
-void  busMstrSGDataXferStart(ULONG port, PSCCB pCurrSCCB);
-void  busMstrDataXferStart(ULONG port, PSCCB pCurrSCCB);
-void  hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB);
-#endif
-void  hostDataXferRestart(PSCCB currSCCB);
-
+static void  FPT_queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card);
+static void  FPT_queueDisconnect(PSCCB p_SCCB, UCHAR p_card);
+static void  FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_SCCB,
+				  UCHAR p_card);
+static void  FPT_queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card);
+static void  FPT_queueFlushSccb(UCHAR p_card, UCHAR error_code);
+static void  FPT_queueAddSccb(PSCCB p_SCCB, UCHAR card);
+static UCHAR FPT_queueFindSccb(PSCCB p_SCCB, UCHAR p_card);
+static void  FPT_utilUpdateResidual(PSCCB p_SCCB);
+static USHORT FPT_CalcCrc16(UCHAR buffer[]);
+static UCHAR  FPT_CalcLrc(UCHAR buffer[]);
 
-#if defined (DOS)
-UCHAR SccbMgr_bad_isr(USHORT p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int);
-#else
-UCHAR SccbMgr_bad_isr(ULONG p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int);
-
-#endif
 
-void  SccbMgrTableInitAll(void);
-void  SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card);
-void  SccbMgrTableInitTarget(UCHAR p_card, UCHAR target);
-
-
-
-void  scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up);
-
-#if defined(DOS)
-int   scarb(USHORT p_port, UCHAR p_sel_type);
-void  scbusf(USHORT p_port);
-void  scsel(USHORT p_port);
-void  scasid(UCHAR p_card, USHORT p_port);
-UCHAR scxferc(USHORT p_port, UCHAR p_data);
-UCHAR scsendi(USHORT p_port, UCHAR p_id_string[]);
-UCHAR sciso(USHORT p_port, UCHAR p_id_string[]);
-void  scwirod(USHORT p_port, UCHAR p_data_bit);
-void  scwiros(USHORT p_port, UCHAR p_data_bit);
-UCHAR scvalq(UCHAR p_quintet);
-UCHAR scsell(USHORT p_port, UCHAR targ_id);
-void  scwtsel(USHORT p_port);
-void  inisci(UCHAR p_card, USHORT p_port, UCHAR p_our_id);
-void  scsavdi(UCHAR p_card, USHORT p_port);
-#else
-int   scarb(ULONG p_port, UCHAR p_sel_type);
-void  scbusf(ULONG p_port);
-void  scsel(ULONG p_port);
-void  scasid(UCHAR p_card, ULONG p_port);
-UCHAR scxferc(ULONG p_port, UCHAR p_data);
-UCHAR scsendi(ULONG p_port, UCHAR p_id_string[]);
-UCHAR sciso(ULONG p_port, UCHAR p_id_string[]);
-void  scwirod(ULONG p_port, UCHAR p_data_bit);
-void  scwiros(ULONG p_port, UCHAR p_data_bit);
-UCHAR scvalq(UCHAR p_quintet);
-UCHAR scsell(ULONG p_port, UCHAR targ_id);
-void  scwtsel(ULONG p_port);
-void  inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id);
-void  scsavdi(UCHAR p_card, ULONG p_port);
-#endif
-UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[]);
+static void  FPT_Wait1Second(ULONG p_port);
+static void  FPT_Wait(ULONG p_port, UCHAR p_delay);
+static void  FPT_utilEEWriteOnOff(ULONG p_port,UCHAR p_mode);
+static void  FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr);
+static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr);
+static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr);
+static void  FPT_utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr);
 
 
-#if defined(DOS)
-void  autoCmdCmplt(USHORT p_port, UCHAR p_card);
-void  autoLoadDefaultMap(USHORT p_port);
-#else
-void  autoCmdCmplt(ULONG p_port, UCHAR p_card);
-void  autoLoadDefaultMap(ULONG p_port);
-#endif
 
+static void  FPT_phaseDataOut(ULONG port, UCHAR p_card);
+static void  FPT_phaseDataIn(ULONG port, UCHAR p_card);
+static void  FPT_phaseCommand(ULONG port, UCHAR p_card);
+static void  FPT_phaseStatus(ULONG port, UCHAR p_card);
+static void  FPT_phaseMsgOut(ULONG port, UCHAR p_card);
+static void  FPT_phaseMsgIn(ULONG port, UCHAR p_card);
+static void  FPT_phaseIllegal(ULONG port, UCHAR p_card);
 
+static void  FPT_phaseDecode(ULONG port, UCHAR p_card);
+static void  FPT_phaseChkFifo(ULONG port, UCHAR p_card);
+static void  FPT_phaseBusFree(ULONG p_port, UCHAR p_card);
 
-#if (FW_TYPE==_SCCB_MGR_)
-	void  OS_start_timer(unsigned long ioport, unsigned long timeout);
-	void  OS_stop_timer(unsigned long ioport, unsigned long timeout);
-	void  OS_disable_int(unsigned char intvec);
-	void  OS_enable_int(unsigned char intvec);
-	void  OS_delay(unsigned long count);
-	int   OS_VirtToPhys(u32bits CardHandle, u32bits *physaddr, u32bits *virtaddr);
-	#if !(defined(UNIX) || defined(OS2) || defined(SOLARIS_REAL_MODE)) 
-	void  OS_Lock(PSCCBMGR_INFO pCardInfo);
-	void  OS_UnLock(PSCCBMGR_INFO pCardInfo);
-#endif // if FW_TYPE == ...
 
-#endif
 
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
 
+static void  FPT_XbowInit(ULONG port, UCHAR scamFlg);
+static void  FPT_BusMasterInit(ULONG p_port);
+static void  FPT_DiagEEPROM(ULONG p_port);
 
-#if defined(OS2)
-   extern void (far *s_PhaseTbl[8]) (ULONG, UCHAR);
-#else
-   #if defined(DOS)
-      extern void (*s_PhaseTbl[8]) (USHORT, UCHAR);
-   #else
-      extern void (*s_PhaseTbl[8]) (ULONG, UCHAR);
-   #endif
-#endif
 
-extern SCCBSCAM_INFO scamInfo[MAX_SCSI_TAR];
-extern NVRAMINFO nvRamInfo[MAX_MB_CARDS];
-#if defined(DOS) || defined(OS2)
-extern UCHAR temp_id_string[ID_STRING_LENGTH];
-#endif
-extern UCHAR scamHAString[];
 
 
-extern UCHAR mbCards;
-#if defined(BUGBUG)
-extern UCHAR debug_int[MAX_CARDS][debug_size];
-extern UCHAR debug_index[MAX_CARDS];
-void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
-#endif
+void  busMstrAbort(ULONG port);
+static void  FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard);
+static void  FPT_busMstrSGDataXferStart(ULONG port, PSCCB pCurrSCCB);
+static void  FPT_busMstrDataXferStart(ULONG port, PSCCB pCurrSCCB);
+static void  FPT_hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB);
+static void  FPT_hostDataXferRestart(PSCCB currSCCB);
 
-#if (FW_TYPE==_SCCB_MGR_)
-#if defined(DOS)
-   extern UCHAR first_time;
-#endif
-#endif /* (FW_TYPE==_SCCB_MGR_) */
 
-#if (FW_TYPE==_UCB_MGR_)
-#if defined(DOS)
-   extern u08bits first_time;
-#endif
-#endif /* (FW_TYPE==_UCB_MGR_) */
+static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
+				 PSCCBcard pCurrCard, USHORT p_int);
 
-#if defined(BUGBUG)
-void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
-#endif
+static void  FPT_SccbMgrTableInitAll(void);
+static void  FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card);
+static void  FPT_SccbMgrTableInitTarget(UCHAR p_card, UCHAR target);
 
-extern unsigned int SccbGlobalFlags;
 
 
-#ident "$Id: sccb.c 1.18 1997/06/10 16:47:04 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   sccb.c  $
- *
- *   Description:  Functions relating to handling of the SCCB interface
- *                 between the device driver and the HARPOON.
- *
- *   $Date: 1997/06/10 16:47:04 $
- *
- *   $Revision: 1.18 $
- *
- *----------------------------------------------------------------------*/
+static void  FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up);
 
-/*#include <globals.h>*/
+static int   FPT_scarb(ULONG p_port, UCHAR p_sel_type);
+static void  FPT_scbusf(ULONG p_port);
+static void  FPT_scsel(ULONG p_port);
+static void  FPT_scasid(UCHAR p_card, ULONG p_port);
+static UCHAR FPT_scxferc(ULONG p_port, UCHAR p_data);
+static UCHAR FPT_scsendi(ULONG p_port, UCHAR p_id_string[]);
+static UCHAR FPT_sciso(ULONG p_port, UCHAR p_id_string[]);
+static void  FPT_scwirod(ULONG p_port, UCHAR p_data_bit);
+static void  FPT_scwiros(ULONG p_port, UCHAR p_data_bit);
+static UCHAR FPT_scvalq(UCHAR p_quintet);
+static UCHAR FPT_scsell(ULONG p_port, UCHAR targ_id);
+static void  FPT_scwtsel(ULONG p_port);
+static void  FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id);
+static void  FPT_scsavdi(UCHAR p_card, ULONG p_port);
+static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[]);
 
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-	/*#include <budioctl.h>*/
-#endif
 
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <eeprom.h>*/
-/*#include <scsi2.h>*/
-/*#include <harpoon.h>*/
+static void  FPT_autoCmdCmplt(ULONG p_port, UCHAR p_card);
+static void  FPT_autoLoadDefaultMap(ULONG p_port);
 
 
 
-#if (FW_TYPE==_SCCB_MGR_)
-#define mOS_Lock(card)    OS_Lock((PSCCBMGR_INFO)(((PSCCBcard)card)->cardInfo))
-#define mOS_UnLock(card)  OS_UnLock((PSCCBMGR_INFO)(((PSCCBcard)card)->cardInfo))
-#else /* FW_TYPE==_UCB_MGR_ */
-#define mOS_Lock(card)    OS_Lock((u32bits)(((PSCCBcard)card)->ioPort))
-#define mOS_UnLock(card)  OS_UnLock((u32bits)(((PSCCBcard)card)->ioPort))
-#endif
+void  OS_start_timer(unsigned long ioport, unsigned long timeout);
+void  OS_stop_timer(unsigned long ioport, unsigned long timeout);
+void  OS_disable_int(unsigned char intvec);
+void  OS_enable_int(unsigned char intvec);
+void  OS_delay(unsigned long count);
+int   OS_VirtToPhys(u32bits CardHandle, u32bits *physaddr, u32bits *virtaddr);
 
+static SCCBMGR_TAR_INFO FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
+static SCCBCARD FPT_BL_Card[MAX_CARDS] = { { 0 } };
+static SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
+static NVRAMINFO FPT_nvRamInfo[MAX_MB_CARDS] = { { 0 } };
 
-/*
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-extern SCCBCARD BL_Card[MAX_CARDS];
 
-extern NVRAMINFO nvRamInfo[MAX_MB_CARDS];
-extern UCHAR mbCards;
+static UCHAR FPT_mbCards = 0;
+static UCHAR FPT_scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C', \
+				   ' ', 'B', 'T', '-', '9', '3', '0', \
+				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \
+				   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
 
-#if defined (OS2)
-   extern void (far *s_PhaseTbl[8]) (ULONG, UCHAR);
-#else
-   #if defined(DOS)
-      extern void (*s_PhaseTbl[8]) (USHORT, UCHAR);
-   #else
-      extern void (*s_PhaseTbl[8]) (ULONG, UCHAR);
-   #endif
-#endif
+static USHORT FPT_default_intena = 0;
 
 
-#if defined(BUGBUG)
-extern UCHAR debug_int[MAX_CARDS][debug_size];
-extern UCHAR debug_index[MAX_CARDS];
-void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
-#endif
-*/
+static void (*FPT_s_PhaseTbl[8]) (ULONG, UCHAR)= { 0 };
 
-#if (FW_TYPE==_SCCB_MGR_)
 
 /*---------------------------------------------------------------------
  *
@@ -2406,27 +1479,16 @@ void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
  *
  *---------------------------------------------------------------------*/
 
-int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
+static int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 {
-#if defined(DOS)
-#else
    static UCHAR first_time = 1;
-#endif
 
    UCHAR i,j,id,ScamFlg;
    USHORT temp,temp2,temp3,temp4,temp5,temp6;
-#if defined(DOS)
-   USHORT ioport;
-#else
    ULONG ioport;
-#endif
 	PNVRamInfo pCurrNvRam;
 
-#if defined(DOS)
-   ioport = (USHORT)pCardInfo->si_baseaddr;
-#else
    ioport = pCardInfo->si_baseaddr;
-#endif
 
 
    if (RD_HARPOON(ioport+hp_vendor_id_0) != ORION_VEND_0)
@@ -2455,36 +1517,31 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 
    if (first_time)
       {
-      SccbMgrTableInitAll();
+      FPT_SccbMgrTableInitAll();
       first_time = 0;
-		mbCards = 0;
+		FPT_mbCards = 0;
       }
 
-	if(RdStack(ioport, 0) != 0x00) {
-		if(ChkIfChipInitialized(ioport) == FALSE)
+	if(FPT_RdStack(ioport, 0) != 0x00) {
+		if(FPT_ChkIfChipInitialized(ioport) == 0)
 		{
 			pCurrNvRam = NULL;
 		   WR_HARPOON(ioport+hp_semaphore, 0x00);
-			XbowInit(ioport, 0);             /*Must Init the SCSI before attempting */
-			DiagEEPROM(ioport);
+			FPT_XbowInit(ioport, 0);             /*Must Init the SCSI before attempting */
+			FPT_DiagEEPROM(ioport);
 		}
 		else
 		{
-			if(mbCards < MAX_MB_CARDS) {
-				pCurrNvRam = &nvRamInfo[mbCards];
-				mbCards++;
+			if(FPT_mbCards < MAX_MB_CARDS) {
+				pCurrNvRam = &FPT_nvRamInfo[FPT_mbCards];
+				FPT_mbCards++;
 				pCurrNvRam->niBaseAddr = ioport;
-				RNVRamData(pCurrNvRam);
+				FPT_RNVRamData(pCurrNvRam);
 			}else
 				return((int) FAILURE);
 		}
 	}else
 		pCurrNvRam = NULL;
-#if defined (NO_BIOS_OPTION)
-	pCurrNvRam = NULL;
-   XbowInit(ioport, 0);                /*Must Init the SCSI before attempting */
-   DiagEEPROM(ioport);
-#endif  /* No BIOS Option */
 
    WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
    WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
@@ -2492,7 +1549,7 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 	if(pCurrNvRam)
 		pCardInfo->si_id = pCurrNvRam->niAdapId;
 	else
-	   pCardInfo->si_id = (UCHAR)(utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
+	   pCardInfo->si_id = (UCHAR)(FPT_utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
    	   (UCHAR)0x0FF);
 
    pCardInfo->si_lun = 0x00;
@@ -2510,7 +1567,7 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
 					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
 		}else
-	      temp = utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
+	      temp = FPT_utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
 
       for (i = 0; i < 2; temp >>=8,i++) {
 
@@ -2549,12 +1606,12 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 	if(pCurrNvRam)
 		i = pCurrNvRam->niSysConf;
 	else
-	   i = (UCHAR)(utilEERead(ioport, (SYSTEM_CONFIG/2)));
+	   i = (UCHAR)(FPT_utilEERead(ioport, (SYSTEM_CONFIG/2)));
 
 	if(pCurrNvRam)
 		ScamFlg = pCurrNvRam->niScamConf;
 	else
-	   ScamFlg = (UCHAR) utilEERead(ioport, SCAM_CONFIG/2);
+	   ScamFlg = (UCHAR) FPT_utilEERead(ioport, SCAM_CONFIG/2);
 
    pCardInfo->si_flags = 0x0000;
 
@@ -2613,9 +1670,9 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 				break;
 		}
 	}else{
-	   temp = utilEERead(ioport, (MODEL_NUMB_0/2));
+	   temp = FPT_utilEERead(ioport, (MODEL_NUMB_0/2));
    	pCardInfo->si_card_model[0] = (UCHAR)(temp >> 8);
-	   temp = utilEERead(ioport, (MODEL_NUMB_2/2));
+	   temp = FPT_utilEERead(ioport, (MODEL_NUMB_2/2));
 
    	pCardInfo->si_card_model[1] = (UCHAR)(temp & 0x00FF);
 	   pCardInfo->si_card_model[2] = (UCHAR)(temp >> 8);
@@ -2677,29 +1734,17 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
 
    SGRAM_ACCESS(ioport);
 
-   s_PhaseTbl[0] = phaseDataOut;
-   s_PhaseTbl[1] = phaseDataIn;
-   s_PhaseTbl[2] = phaseIllegal;
-   s_PhaseTbl[3] = phaseIllegal;
-   s_PhaseTbl[4] = phaseCommand;
-   s_PhaseTbl[5] = phaseStatus;
-   s_PhaseTbl[6] = phaseMsgOut;
-   s_PhaseTbl[7] = phaseMsgIn;
+   FPT_s_PhaseTbl[0] = FPT_phaseDataOut;
+   FPT_s_PhaseTbl[1] = FPT_phaseDataIn;
+   FPT_s_PhaseTbl[2] = FPT_phaseIllegal;
+   FPT_s_PhaseTbl[3] = FPT_phaseIllegal;
+   FPT_s_PhaseTbl[4] = FPT_phaseCommand;
+   FPT_s_PhaseTbl[5] = FPT_phaseStatus;
+   FPT_s_PhaseTbl[6] = FPT_phaseMsgOut;
+   FPT_s_PhaseTbl[7] = FPT_phaseMsgIn;
 
    pCardInfo->si_present = 0x01;
 
-#if defined(BUGBUG)
-
-
-   for (i = 0; i < MAX_CARDS; i++) {
-
-      for (id=0; id<debug_size; id++)
-         debug_int[i][id] =  (UCHAR)0x00;
-      debug_index[i] = 0;
-      }
-
-#endif
-
    return(0);
 }
 
@@ -2712,27 +1757,15 @@ int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-USHORT SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
-#else
-ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
-#endif
+static ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
 {
    PSCCBcard CurrCard = NULL;
 	PNVRamInfo pCurrNvRam;
    UCHAR i,j,thisCard, ScamFlg;
    USHORT temp,sync_bit_map,id;
-#if defined(DOS)
-   USHORT ioport;
-#else
    ULONG ioport;
-#endif
 
-#if defined(DOS)
-   ioport = (USHORT)pCardInfo->si_baseaddr;
-#else
    ioport = pCardInfo->si_baseaddr;
-#endif
 
    for(thisCard =0; thisCard <= MAX_CARDS; thisCard++) {
 
@@ -2741,24 +1774,24 @@ ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
 	 return(FAILURE);
          }
 
-      if (BL_Card[thisCard].ioPort == ioport) {
+      if (FPT_BL_Card[thisCard].ioPort == ioport) {
 
-         CurrCard = &BL_Card[thisCard];
-         SccbMgrTableInitCard(CurrCard,thisCard);
+         CurrCard = &FPT_BL_Card[thisCard];
+         FPT_SccbMgrTableInitCard(CurrCard,thisCard);
          break;
          }
 
-      else if (BL_Card[thisCard].ioPort == 0x00) {
+      else if (FPT_BL_Card[thisCard].ioPort == 0x00) {
 
-         BL_Card[thisCard].ioPort = ioport;
-         CurrCard = &BL_Card[thisCard];
+         FPT_BL_Card[thisCard].ioPort = ioport;
+         CurrCard = &FPT_BL_Card[thisCard];
 
-			if(mbCards)
-				for(i = 0; i < mbCards; i++){
-					if(CurrCard->ioPort == nvRamInfo[i].niBaseAddr)
-						CurrCard->pNvRamInfo = &nvRamInfo[i];
+			if(FPT_mbCards)
+				for(i = 0; i < FPT_mbCards; i++){
+					if(CurrCard->ioPort == FPT_nvRamInfo[i].niBaseAddr)
+						CurrCard->pNvRamInfo = &FPT_nvRamInfo[i];
 				}
-         SccbMgrTableInitCard(CurrCard,thisCard);
+         FPT_SccbMgrTableInitCard(CurrCard,thisCard);
          CurrCard->cardIndex = thisCard;
          CurrCard->cardInfo = pCardInfo;
 
@@ -2772,22 +1805,14 @@ ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
 		ScamFlg = pCurrNvRam->niScamConf;
 	}
 	else{
-	   ScamFlg = (UCHAR) utilEERead(ioport, SCAM_CONFIG/2);
+	   ScamFlg = (UCHAR) FPT_utilEERead(ioport, SCAM_CONFIG/2);
 	}
 
 
-   BusMasterInit(ioport);
-   XbowInit(ioport, ScamFlg);
-
-#if defined (NO_BIOS_OPTION)
-
+   FPT_BusMasterInit(ioport);
+   FPT_XbowInit(ioport, ScamFlg);
 
-   if (DiagXbow(ioport)) return(FAILURE);
-   if (DiagBusMaster(ioport)) return(FAILURE);
-
-#endif  /* No BIOS Option */
-
-   autoLoadDefaultMap(ioport);
+   FPT_autoLoadDefaultMap(ioport);
 
 
    for (i = 0,id = 0x01; i != pCardInfo->si_id; i++,id <<= 1){}
@@ -2814,1386 +1839,193 @@ ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
 
    if (!(pCardInfo->si_flags & SOFT_RESET)) {
 
-      sresb(ioport,thisCard);
-
-         scini(thisCard, pCardInfo->si_id, 0);
-      }
-
-
-
-   if (pCardInfo->si_flags & POST_ALL_UNDERRRUNS)
-      CurrCard->globalFlags |= F_NO_FILTER;
-
-	if(pCurrNvRam){
-		if(pCurrNvRam->niSysConf & 0x10)
-			CurrCard->globalFlags |= F_GREEN_PC;
-	}
-	else{
-	   if (utilEERead(ioport, (SYSTEM_CONFIG/2)) & GREEN_PC_ENA)
-   	   CurrCard->globalFlags |= F_GREEN_PC;
-	}
-
-	/* Set global flag to indicate Re-Negotiation to be done on all
-		ckeck condition */
-	if(pCurrNvRam){
-		if(pCurrNvRam->niScsiConf & 0x04)
-			CurrCard->globalFlags |= F_DO_RENEGO;
-	}
-	else{
-	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & RENEGO_ENA)
-   	   CurrCard->globalFlags |= F_DO_RENEGO;
-	}
-
-	if(pCurrNvRam){
-		if(pCurrNvRam->niScsiConf & 0x08)
-			CurrCard->globalFlags |= F_CONLUN_IO;
-	}
-	else{
-	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & CONNIO_ENA)
-   	   CurrCard->globalFlags |= F_CONLUN_IO;
-	}
-
-
-   temp = pCardInfo->si_per_targ_no_disc;
-
-   for (i = 0,id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
-
-      if (temp & id)
-	 sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
-      }
-
-   sync_bit_map = 0x0001;
-
-   for (id = 0; id < (MAX_SCSI_TAR/2); id++) {
-
-		if(pCurrNvRam){
-			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
-			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
-					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
-		}else
-	      temp = utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
-
-      for (i = 0; i < 2; temp >>=8,i++) {
-
-         if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
-
-            sccbMgrTbl[thisCard][id*2+i].TarEEValue = (UCHAR)temp;
-            }
-
-         else {
-	    sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
-            sccbMgrTbl[thisCard][id*2+i].TarEEValue =
-               (UCHAR)(temp & ~EE_SYNC_MASK);
-            }
-
-#if defined(WIDE_SCSI)
-/*         if ((pCardInfo->si_per_targ_wide_nego & sync_bit_map) ||
-            (id*2+i >= 8)){
-*/
-         if (pCardInfo->si_per_targ_wide_nego & sync_bit_map){
-
-            sccbMgrTbl[thisCard][id*2+i].TarEEValue |= EE_WIDE_SCSI;
-
-            }
-
-         else { /* NARROW SCSI */
-            sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
-            }
-
-#else
-         sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
-#endif
-
-
-	 sync_bit_map <<= 1;
-
-
-
-         }
-      }
-
-   WR_HARPOON((ioport+hp_semaphore),
-      (UCHAR)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
-
-#if defined(DOS)
-   return((USHORT)CurrCard);
-#else
-   return((ULONG)CurrCard);
-#endif
-}
-
-#else  			/* end (FW_TYPE==_SCCB_MGR_)  */
-
-
-
-STATIC s16bits FP_PresenceCheck(PMGR_INFO pMgrInfo)
-{
-	PMGR_ENTRYPNTS	pMgr_EntryPnts = &pMgrInfo->mi_Functions;
-
-      pMgr_EntryPnts->UCBMgr_probe_adapter = probe_adapter;
-      pMgr_EntryPnts->UCBMgr_init_adapter = init_adapter;
-      pMgr_EntryPnts->UCBMgr_start_UCB = SccbMgr_start_sccb;
-      pMgr_EntryPnts->UCBMgr_build_UCB = build_UCB;
-      pMgr_EntryPnts->UCBMgr_abort_UCB = SccbMgr_abort_sccb;
-      pMgr_EntryPnts->UCBMgr_my_int = SccbMgr_my_int;
-      pMgr_EntryPnts->UCBMgr_isr = SccbMgr_isr;
-      pMgr_EntryPnts->UCBMgr_scsi_reset = SccbMgr_scsi_reset;
-      pMgr_EntryPnts->UCBMgr_timer_expired = SccbMgr_timer_expired;
-#ifndef NO_IOCTLS
-	  pMgr_EntryPnts->UCBMgr_unload_card = SccbMgr_unload_card;
-	  pMgr_EntryPnts->UCBMgr_save_foreign_state =
-	  									SccbMgr_save_foreign_state;
-	  pMgr_EntryPnts->UCBMgr_restore_foreign_state =
-	  									SccbMgr_restore_foreign_state;
-	  pMgr_EntryPnts->UCBMgr_restore_native_state =
-	  									SccbMgr_restore_native_state;
-#endif /*NO_IOCTLS*/
-
-      pMgrInfo->mi_SGListFormat=0x01;
-      pMgrInfo->mi_DataPtrFormat=0x01;
-      pMgrInfo->mi_MaxSGElements= (u16bits) 0xffffffff;
-      pMgrInfo->mi_MgrPrivateLen=sizeof(SCCB);
-      pMgrInfo->mi_PCIVendorID=BL_VENDOR_ID;
-      pMgrInfo->mi_PCIDeviceID=FP_DEVICE_ID;
-      pMgrInfo->mi_MgrAttributes= ATTR_IO_MAPPED +
-											 ATTR_PHYSICAL_ADDRESS +
-											 ATTR_VIRTUAL_ADDRESS +
-											 ATTR_OVERLAPPED_IO_IOCTLS_OK;
-      pMgrInfo->mi_IoRangeLen = 256;
-      return(0);
-}
-
-
-
-/*---------------------------------------------------------------------
- *
- * Function: probe_adapter
- *
- * Description: Setup and/or Search for cards and return info to caller.
- *
- *---------------------------------------------------------------------*/
-STATIC s32bits probe_adapter(PADAPTER_INFO pAdapterInfo)
-{
-   u16bits temp,temp2,temp3,temp4;
-   u08bits i,j,id;
-
-#if defined(DOS)
-#else
-   static u08bits first_time = 1;
-#endif
-   BASE_PORT ioport;
-	PNVRamInfo pCurrNvRam;
-
-   ioport = (BASE_PORT)pAdapterInfo->ai_baseaddr;
-
-
-
-   if (RD_HARPOON(ioport+hp_vendor_id_0) != ORION_VEND_0)
-      return(1);
-
-   if ((RD_HARPOON(ioport+hp_vendor_id_1) != ORION_VEND_1))
-      return(2);
-
-   if ((RD_HARPOON(ioport+hp_device_id_0) != ORION_DEV_0))
-      return(3);
-
-   if ((RD_HARPOON(ioport+hp_device_id_1) != ORION_DEV_1))
-      return(4);
-
-
-   if (RD_HARPOON(ioport+hp_rev_num) != 0x0f){
-
-
-/* For new Harpoon then check for sub_device ID LSB
-   the bits(0-3) must be all ZERO for compatible with
-   current version of SCCBMgr, else skip this Harpoon
-	device. */
-
-	   if (RD_HARPOON(ioport+hp_sub_device_id_0) & 0x0f)
-	      return(5);
-	}
-
-   if (first_time) {
-
-      SccbMgrTableInitAll();
-      first_time = 0;
-		mbCards = 0;
-      }
-
-	if(RdStack(ioport, 0) != 0x00) {
-		if(ChkIfChipInitialized(ioport) == FALSE)
-		{
-			pCurrNvRam = NULL;
-		   WR_HARPOON(ioport+hp_semaphore, 0x00);
-			XbowInit(ioport, 0);                /*Must Init the SCSI before attempting */
-			DiagEEPROM(ioport);
-		}
-		else
-		{
-			if(mbCards < MAX_MB_CARDS) {
-				pCurrNvRam = &nvRamInfo[mbCards];
-				mbCards++;
-				pCurrNvRam->niBaseAddr = ioport;
-				RNVRamData(pCurrNvRam);
-			}else
-				return((int) FAILURE);
-		}
-	}else
-		pCurrNvRam = NULL;
-
-#if defined (NO_BIOS_OPTION)
-	pCurrNvRam = NULL;
-   XbowInit(ioport, 0);                /*Must Init the SCSI before attempting */
-   DiagEEPROM(ioport);
-#endif  /* No BIOS Option */
-
-   WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
-   WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
-
-	if(pCurrNvRam)
-		pAdapterInfo->ai_id = pCurrNvRam->niAdapId;
-	else
-   	pAdapterInfo->ai_id = (u08bits)(utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
-      	(u08bits)0x0FF);
-
-   pAdapterInfo->ai_lun = 0x00;
-   pAdapterInfo->ai_fw_revision[0] = '3';
-   pAdapterInfo->ai_fw_revision[1] = '1';
-   pAdapterInfo->ai_fw_revision[2] = '1';
-   pAdapterInfo->ai_fw_revision[3] = ' ';
-   pAdapterInfo->ai_NumChannels = 1;
-
-   temp2 = 0x0000;
-   temp3 = 0x0000;
-   temp4 = 0x0000;
-
-   for (id = 0; id < (16/2); id++) {
-
-		if(pCurrNvRam){
-			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
-			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
-					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
-		}else
-	      temp = utilEERead(ioport, (u16bits)((SYNC_RATE_TBL/2)+id));
-
-      for (i = 0; i < 2; temp >>=8,i++) {
-
-         if ((temp & 0x03) != AUTO_RATE_00) {
-
-            temp2 >>= 0x01;
-            temp2 |= 0x8000;
-            }
-
-         else {
-            temp2 >>= 0x01;
-            }
-
-         if (temp & DISC_ENABLE_BIT) {
+      FPT_sresb(ioport,thisCard);
 
-            temp3 >>= 0x01;
-            temp3 |= 0x8000;
-            }
-
-         else {
-            temp3 >>= 0x01;
-            }
-
-         if (temp & WIDE_NEGO_BIT) {
-
-            temp4 >>= 0x01;
-            temp4 |= 0x8000;
-            }
-
-         else {
-            temp4 >>= 0x01;
-            }
-
-         }
-      }
-
-   pAdapterInfo->ai_per_targ_init_sync = temp2;
-   pAdapterInfo->ai_per_targ_no_disc = temp3;
-   pAdapterInfo->ai_per_targ_wide_nego = temp4;
-	if(pCurrNvRam)
-		i = pCurrNvRam->niSysConf;
-	else
-   	i = (u08bits)(utilEERead(ioport, (SYSTEM_CONFIG/2)));
-
-   /*
-   ** interrupts always level-triggered for FlashPoint
-   */
-   pAdapterInfo->ai_stateinfo |= LEVEL_TRIG;
-
-   if (i & 0x01)
-      pAdapterInfo->ai_stateinfo |= SCSI_PARITY_ENA;
-
-	if (i & 0x02)	/* SCSI Bus reset in AutoSCSI Set ? */
-	{
-		if(pCurrNvRam)
-		{
-			j = pCurrNvRam->niScamConf;
-		}
-		else
-		{
-		j = (u08bits) utilEERead(ioport, SCAM_CONFIG/2);
-		}
-		if(j & SCAM_ENABLED)
-		{
-			if(j & SCAM_LEVEL2)
-			{
-				pAdapterInfo->ai_stateinfo |= SCAM2_ENA;
-			}
-			else
-			{
-				pAdapterInfo->ai_stateinfo |= SCAM1_ENA;
-			}
-		}
-	}
-   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
-   if (i & 0x04) {
-      j |= SCSI_TERM_ENA_L;
-      pAdapterInfo->ai_stateinfo |= LOW_BYTE_TERM_ENA;
-      }
-   WR_HARPOON(ioport+hp_bm_ctrl, j );
-
-   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
-   if (i & 0x08) {
-      j |= SCSI_TERM_ENA_H;
-      pAdapterInfo->ai_stateinfo |= HIGH_BYTE_TERM_ENA;
+         FPT_scini(thisCard, pCardInfo->si_id, 0);
       }
-   WR_HARPOON(ioport+hp_ee_ctrl, j );
-
-	if(RD_HARPOON(ioport + hp_page_ctrl) & BIOS_SHADOW)
-	{
-		pAdapterInfo->ai_FlashRomSize = 64 * 1024;	/* 64k ROM */
-	}
-	else
-	{
-		pAdapterInfo->ai_FlashRomSize = 32 * 1024;	/* 32k ROM */
-	}
-
-   pAdapterInfo->ai_stateinfo |= (FAST20_ENA | TAG_QUEUE_ENA);
-   if (!(RD_HARPOON(ioport+hp_page_ctrl) & NARROW_SCSI_CARD))
-	{
-      pAdapterInfo->ai_attributes |= (WIDE_CAPABLE | FAST20_CAPABLE
-													| SCAM2_CAPABLE
-													| TAG_QUEUE_CAPABLE
-													| SUPRESS_UNDERRRUNS_CAPABLE
-													| SCSI_PARITY_CAPABLE);
-		pAdapterInfo->ai_MaxTarg = 16;
-		pAdapterInfo->ai_MaxLun  = 32;
-	}
-	else
-	{
-      pAdapterInfo->ai_attributes |= (FAST20_CAPABLE | SCAM2_CAPABLE
-													| TAG_QUEUE_CAPABLE
-													| SUPRESS_UNDERRRUNS_CAPABLE
-													| SCSI_PARITY_CAPABLE);
-		pAdapterInfo->ai_MaxTarg = 8;
-		pAdapterInfo->ai_MaxLun  = 8;
-	}
-
-   pAdapterInfo->ai_product_family = HARPOON_FAMILY;
-   pAdapterInfo->ai_HBAbustype = BUSTYPE_PCI;
-
-   for (i=0;i<CARD_MODEL_NAMELEN;i++)
-   {
-      pAdapterInfo->ai_card_model[i]=' '; /* initialize the ai_card_model */
-   }
 
-	if(pCurrNvRam){
-	pAdapterInfo->ai_card_model[0] = '9';
-		switch(pCurrNvRam->niModel & 0x0f){
-			case MODEL_LT:
-			pAdapterInfo->ai_card_model[1] = '3';
-			pAdapterInfo->ai_card_model[2] = '0';
-				break;
-			case MODEL_LW:
-			pAdapterInfo->ai_card_model[1] = '5';
-			pAdapterInfo->ai_card_model[2] = '0';
-				break;
-			case MODEL_DL:
-			pAdapterInfo->ai_card_model[1] = '3';
-			pAdapterInfo->ai_card_model[2] = '2';
-				break;
-			case MODEL_DW:
-			pAdapterInfo->ai_card_model[1] = '5';
-			pAdapterInfo->ai_card_model[2] = '2';
-				break;
-		}
-	}else{
-	   temp = utilEERead(ioport, (MODEL_NUMB_0/2));
-		pAdapterInfo->ai_card_model[0] = (u08bits)(temp >> 8);
-	   temp = utilEERead(ioport, (MODEL_NUMB_2/2));
-
-		pAdapterInfo->ai_card_model[1] = (u08bits)(temp & 0x00FF);
-	   pAdapterInfo->ai_card_model[2] = (u08bits)(temp >> 8);
-	}
-
-
-
-   pAdapterInfo->ai_FiberProductType = 0;
-
-   pAdapterInfo->ai_secondary_range = 0;
-
-   for (i=0;i<WORLD_WIDE_NAMELEN;i++)
-   {
-      pAdapterInfo->ai_worldwidename[i]='\0';
-   }
-
-   for (i=0;i<VENDOR_NAMELEN;i++)
-   {
-      pAdapterInfo->ai_vendorstring[i]='\0';
-   }
-   	pAdapterInfo->ai_vendorstring[0]='B';
-   	pAdapterInfo->ai_vendorstring[1]='U';
-   	pAdapterInfo->ai_vendorstring[2]='S';
-   	pAdapterInfo->ai_vendorstring[3]='L';
-   	pAdapterInfo->ai_vendorstring[4]='O';
-   	pAdapterInfo->ai_vendorstring[5]='G';
-   	pAdapterInfo->ai_vendorstring[6]='I';
-   	pAdapterInfo->ai_vendorstring[7]='C';
-
-	for (i=0;i<FAMILY_NAMELEN;i++)
-	{
-	   pAdapterInfo->ai_AdapterFamilyString[i]='\0';
-	}
-   	pAdapterInfo->ai_AdapterFamilyString[0]='F';
-   	pAdapterInfo->ai_AdapterFamilyString[1]='L';
-   	pAdapterInfo->ai_AdapterFamilyString[2]='A';
-   	pAdapterInfo->ai_AdapterFamilyString[3]='S';
-   	pAdapterInfo->ai_AdapterFamilyString[4]='H';
-   	pAdapterInfo->ai_AdapterFamilyString[5]='P';
-   	pAdapterInfo->ai_AdapterFamilyString[6]='O';
-   	pAdapterInfo->ai_AdapterFamilyString[7]='I';
-   	pAdapterInfo->ai_AdapterFamilyString[8]='N';
-   	pAdapterInfo->ai_AdapterFamilyString[9]='T';
-
-   ARAM_ACCESS(ioport);
-
-   for ( i = 0; i < 4; i++ ) {
-
-      pAdapterInfo->ai_XlatInfo[i] =
-         RD_HARPOON(ioport+hp_aramBase+BIOS_DATA_OFFSET+i);
-      }
-
-	/* return with -1 if no sort, else return with
-	   logical card number sorted by BIOS (zero-based) */
-
-
-	pAdapterInfo->ai_relative_cardnum = 
-      (u08bits)(RD_HARPOON(ioport+hp_aramBase+BIOS_RELATIVE_CARD)-1); 
-
-   SGRAM_ACCESS(ioport);
-
-   s_PhaseTbl[0] = phaseDataOut;
-   s_PhaseTbl[1] = phaseDataIn;
-   s_PhaseTbl[2] = phaseIllegal;
-   s_PhaseTbl[3] = phaseIllegal;
-   s_PhaseTbl[4] = phaseCommand;
-   s_PhaseTbl[5] = phaseStatus;
-   s_PhaseTbl[6] = phaseMsgOut;
-   s_PhaseTbl[7] = phaseMsgIn;
-
-   pAdapterInfo->ai_present = 0x01;
-
-#if defined(BUGBUG)
-
-
-   for (i = 0; i < MAX_CARDS; i++) {
-
-      for (id=0; id<debug_size; id++)
-         debug_int[i][id] =  (u08bits)0x00;
-      debug_index[i] = 0;
-      }
-
-#endif
-
-   return(0);
-}
-
-
-
-
-
-/*---------------------------------------------------------------------
- *
- * Function: init_adapter, exported to BUDI via UCBMgr_init_adapter entry
- *
- *
- * Description: Setup adapter for normal operation (hard reset).
- *
- *---------------------------------------------------------------------*/
-STATIC CARD_HANDLE init_adapter(PADAPTER_INFO pCardInfo)
-{
-   PSCCBcard CurrCard;
-	PNVRamInfo pCurrNvRam;
-   u08bits i,j,thisCard, ScamFlg;
-   u16bits temp,sync_bit_map,id;
-   BASE_PORT ioport;
-
-   ioport = (BASE_PORT)pCardInfo->ai_baseaddr;
-
-   for(thisCard =0; thisCard <= MAX_CARDS; thisCard++) {
-
-      if (thisCard == MAX_CARDS) {
-
-         return(FAILURE);
-         }
-
-      if (BL_Card[thisCard].ioPort == ioport) {
-
-         CurrCard = &BL_Card[thisCard];
-         SccbMgrTableInitCard(CurrCard,thisCard);
-         break;
-         }
-
-      else if (BL_Card[thisCard].ioPort == 0x00) {
-
-         BL_Card[thisCard].ioPort = ioport;
-         CurrCard = &BL_Card[thisCard];
-
-			if(mbCards)
-				for(i = 0; i < mbCards; i++){
-					if(CurrCard->ioPort == nvRamInfo[i].niBaseAddr)
-						CurrCard->pNvRamInfo = &nvRamInfo[i];
-				}
-         SccbMgrTableInitCard(CurrCard,thisCard);
-         CurrCard->cardIndex = thisCard;
-         CurrCard->cardInfo = pCardInfo;
-
-         break;
-         }
-      }
-
-	pCurrNvRam = CurrCard->pNvRamInfo;
-
-   
-	if(pCurrNvRam){
-		ScamFlg = pCurrNvRam->niScamConf;
-	}
-	else{
-	   ScamFlg = (UCHAR) utilEERead(ioport, SCAM_CONFIG/2);
-	}
-	
-
-   BusMasterInit(ioport);
-   XbowInit(ioport, ScamFlg);
-
-#if defined (NO_BIOS_OPTION)
-
-
-   if (DiagXbow(ioport)) return(FAILURE);
-   if (DiagBusMaster(ioport)) return(FAILURE);
-
-#endif  /* No BIOS Option */
-
-   autoLoadDefaultMap(ioport);
-
-
-   for (i = 0,id = 0x01; i != pCardInfo->ai_id; i++,id <<= 1){}
-
-   WR_HARPOON(ioport+hp_selfid_0, id);
-   WR_HARPOON(ioport+hp_selfid_1, 0x00);
-   WR_HARPOON(ioport+hp_arb_id, pCardInfo->ai_id);
-   CurrCard->ourId = (unsigned char) pCardInfo->ai_id;
-
-   i = (u08bits) pCardInfo->ai_stateinfo;
-   if (i & SCSI_PARITY_ENA)
-       WR_HARPOON(ioport+hp_portctrl_1,(HOST_MODE8 | CHK_SCSI_P));
-
-   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
-   if (i & LOW_BYTE_TERM_ENA)
-      j |= SCSI_TERM_ENA_L;
-   WR_HARPOON(ioport+hp_bm_ctrl, j);
-
-   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
-   if (i & HIGH_BYTE_TERM_ENA)
-      j |= SCSI_TERM_ENA_H;
-   WR_HARPOON(ioport+hp_ee_ctrl, j );
-
-
-   if (!(pCardInfo->ai_stateinfo & NO_RESET_IN_INIT)) {
-
-      sresb(ioport,thisCard);
-
-         scini(thisCard, (u08bits) pCardInfo->ai_id, 0);
-      }
-
-
-
-   if (pCardInfo->ai_stateinfo & SUPRESS_UNDERRRUNS_ENA)
-      CurrCard->globalFlags |= F_NO_FILTER;
-
-	if(pCurrNvRam){
-		if(pCurrNvRam->niSysConf & 0x10)
-			CurrCard->globalFlags |= F_GREEN_PC;
-	}
-	else{
-	   if (utilEERead(ioport, (SYSTEM_CONFIG/2)) & GREEN_PC_ENA)
-   	   CurrCard->globalFlags |= F_GREEN_PC;
-	}
-
-	/* Set global flag to indicate Re-Negotiation to be done on all
-		ckeck condition */
-	if(pCurrNvRam){
-		if(pCurrNvRam->niScsiConf & 0x04)
-			CurrCard->globalFlags |= F_DO_RENEGO;
-	}
-	else{
-	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & RENEGO_ENA)
-   	   CurrCard->globalFlags |= F_DO_RENEGO;
-	}
-
-	if(pCurrNvRam){
-		if(pCurrNvRam->niScsiConf & 0x08)
-			CurrCard->globalFlags |= F_CONLUN_IO;
-	}
-	else{
-	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & CONNIO_ENA)
-   	   CurrCard->globalFlags |= F_CONLUN_IO;
-	}
-
-   temp = pCardInfo->ai_per_targ_no_disc;
-
-   for (i = 0,id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
-
-      if (temp & id)
-         sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
-      }
-
-   sync_bit_map = 0x0001;
-
-   for (id = 0; id < (MAX_SCSI_TAR/2); id++){
-
-		if(pCurrNvRam){
-			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
-			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
-					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
-		}else
-	      temp = utilEERead(ioport, (u16bits)((SYNC_RATE_TBL/2)+id));
-
-      for (i = 0; i < 2; temp >>=8,i++){
-
-         if (pCardInfo->ai_per_targ_init_sync & sync_bit_map){
-
-            sccbMgrTbl[thisCard][id*2+i].TarEEValue = (u08bits)temp;
-            }
-
-         else {
-            sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
-            sccbMgrTbl[thisCard][id*2+i].TarEEValue =
-               (u08bits)(temp & ~EE_SYNC_MASK);
-            }
-
-#if defined(WIDE_SCSI)
-/*         if ((pCardInfo->ai_per_targ_wide_nego & sync_bit_map) ||
-            (id*2+i >= 8)){
-*/
-         if (pCardInfo->ai_per_targ_wide_nego & sync_bit_map){
-
-            sccbMgrTbl[thisCard][id*2+i].TarEEValue |= EE_WIDE_SCSI;
-
-            }
-
-         else { /* NARROW SCSI */
-            sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
-            }
-
-#else
-         sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
-#endif
-
-
-         sync_bit_map <<= 1;
-         }
-      }
-
-
-   pCardInfo->ai_SGListFormat=0x01;
-   pCardInfo->ai_DataPtrFormat=0x01;
-   pCardInfo->ai_AEN_mask &= SCSI_RESET_COMPLETE;
-
-   WR_HARPOON((ioport+hp_semaphore),
-      (u08bits)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
-
-   return((u32bits)CurrCard);
-
-}
-
-
-/*---------------------------------------------------------------------
- *
- * Function: build_ucb, exported to BUDI via UCBMgr_build_ucb entry
- *
- * Description: prepare fw portion of ucb. do not start, resource not guaranteed
- *             so don't manipulate anything that's derived from states which
- *             may change
- *
- *---------------------------------------------------------------------*/
-void build_UCB(CARD_HANDLE pCurrCard, PUCB p_ucb)
-{
-
-   u08bits thisCard;
-   u08bits i,j;
-
-   PSCCB p_sccb;
-
-
-   thisCard = ((PSCCBcard) pCurrCard)->cardIndex;
-
-
-   p_sccb=(PSCCB)p_ucb->UCB_MgrPrivatePtr;
-
-
-   p_sccb->Sccb_ucb_ptr=p_ucb;
-
-   switch (p_ucb->UCB_opcode & (OPC_DEVICE_RESET+OPC_XFER_SG+OPC_CHK_RESIDUAL))
-   {
-      case OPC_DEVICE_RESET:
-         p_sccb->OperationCode=RESET_COMMAND;
-         break;
-      case OPC_XFER_SG:
-         p_sccb->OperationCode=SCATTER_GATHER_COMMAND;
-         break;
-      case OPC_XFER_SG+OPC_CHK_RESIDUAL:
-         p_sccb->OperationCode=RESIDUAL_SG_COMMAND;
-         break;
-      case OPC_CHK_RESIDUAL:
-
-	      p_sccb->OperationCode=RESIDUAL_COMMAND;
-	      break;
-      default:
-	      p_sccb->OperationCode=SCSI_INITIATOR_COMMAND;
-	      break;
-   }
-
-   if (p_ucb->UCB_opcode & OPC_TQ_ENABLE)
-   {
-      p_sccb->ControlByte = (u08bits)((p_ucb->UCB_opcode & OPC_TQ_MASK)>>2) | F_USE_CMD_Q;
-   }
-   else
-   {
-      p_sccb->ControlByte = 0;
-   }
-
-
-   p_sccb->CdbLength = (u08bits)p_ucb->UCB_cdblen;
-
-   if (p_ucb->UCB_opcode & OPC_NO_AUTO_SENSE)
-   {
-      p_sccb->RequestSenseLength = 0;
-   }
-   else
-   {
-      p_sccb->RequestSenseLength = (unsigned char) p_ucb->UCB_senselen;
-   }
-
-
-   if (p_ucb->UCB_opcode & OPC_XFER_SG)
-   {
-      p_sccb->DataPointer=p_ucb->UCB_virt_dataptr;
-      p_sccb->DataLength = (((u32bits)p_ucb->UCB_NumSgElements)<<3);
-   }
-   else
-   {
-      p_sccb->DataPointer=p_ucb->UCB_phys_dataptr;
-      p_sccb->DataLength=p_ucb->UCB_datalen;
-   };
-
-   p_sccb->HostStatus=0;
-   p_sccb->TargetStatus=0;
-   p_sccb->TargID=(unsigned char)p_ucb->UCB_targid;
-   p_sccb->Lun=(unsigned char) p_ucb->UCB_lun;
-   p_sccb->SccbIOPort=((PSCCBcard)pCurrCard)->ioPort;
-
-   j=p_ucb->UCB_cdblen;
-   for (i=0;i<j;i++)
-   {
-      p_sccb->Cdb[i] = p_ucb->UCB_cdb[i];
-   }
-
-   p_sccb->SensePointer=p_ucb->UCB_phys_senseptr;
-
-   sinits(p_sccb,thisCard);
-
-}
-#ifndef NO_IOCTLS
-
-/*---------------------------------------------------------------------
- *
- * Function: GetDevSyncRate
- *
- *---------------------------------------------------------------------*/
-STATIC  int GetDevSyncRate(PSCCBcard pCurrCard,PUCB p_ucb)
-{
-	struct _SYNC_RATE_INFO * pSyncStr;
-   PSCCBMgr_tar_info currTar_Info;
-	BASE_PORT ioport;
-	u08bits scsiID, j;
-
-#if (FW_TYPE != _SCCB_MGR_)
-	if( p_ucb->UCB_targid >= pCurrCard->cardInfo->ai_MaxTarg )
-	{
-		return(1);
-	}
-#endif
-
-	ioport  = pCurrCard->ioPort;
-	pSyncStr	= (struct _SYNC_RATE_INFO *) p_ucb->UCB_virt_dataptr;
-	scsiID = (u08bits) p_ucb->UCB_targid;
-   currTar_Info = &sccbMgrTbl[pCurrCard->cardIndex][scsiID];
-	j = currTar_Info->TarSyncCtrl;
-
-	switch (currTar_Info->TarEEValue & EE_SYNC_MASK)
-	{
-		case EE_SYNC_ASYNC:
-			pSyncStr->RequestMegaXferRate = 0x00;
-			break;
-		case EE_SYNC_5MB:
-			pSyncStr->RequestMegaXferRate = (j & NARROW_SCSI) ? 50 : 100;
-			break;
-		case EE_SYNC_10MB:
-			pSyncStr->RequestMegaXferRate = (j & NARROW_SCSI) ? 100 : 200;
-			break;
-		case EE_SYNC_20MB:
-			pSyncStr->RequestMegaXferRate = (j & NARROW_SCSI) ? 200 : 400;
-			break;
-	}
-
-	switch ((j >> 5) & 0x07)
-	{
-		case 0x00:
-			if((j & 0x07) == 0x00)
-			{
-				pSyncStr->ActualMegaXferRate = 0x00;	/* Async Mode */
-			}
-			else
-			{
-				pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 200 : 400;
-			}
-			break;
-		case 0x01:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 100 : 200;
-			break;
-		case 0x02:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 66 : 122;
-			break;
-		case 0x03:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 50 : 100;
-			break;
-		case 0x04:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 40 : 80;
-			break;
-		case 0x05:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 33 : 66;
-			break;
-		case 0x06:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 28 : 56;
-			break;
-		case 0x07:
-			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 25 : 50;
-			break;
-	}
-	pSyncStr->NegotiatedOffset = j & 0x0f;
-
-	return(0);
-}
-
-/*---------------------------------------------------------------------
- *
- * Function: SetDevSyncRate
- *
- *---------------------------------------------------------------------*/
-STATIC int SetDevSyncRate(PSCCBcard pCurrCard, PUCB p_ucb)
-{
-	struct _SYNC_RATE_INFO * pSyncStr;
-   PSCCBMgr_tar_info currTar_Info;
-	BASE_PORT ioPort;
-	u08bits scsiID, i, j, syncVal;
-	u16bits syncOffset, actualXferRate;
-	union {
-		u08bits tempb[2];
-		u16bits tempw;
-	}temp2;
-
-#if (FW_TYPE != _SCCB_MGR_)
-	if( p_ucb->UCB_targid >= pCurrCard->cardInfo->ai_MaxTarg )
-	{
-		return(1);
-	}
-#endif
-
-	ioPort  = pCurrCard->ioPort;
-	pSyncStr	= (struct _SYNC_RATE_INFO *) p_ucb->UCB_virt_dataptr;
-	scsiID = (u08bits) p_ucb->UCB_targid;
-   currTar_Info = &sccbMgrTbl[pCurrCard->cardIndex][scsiID];
-	i = RD_HARPOON(ioPort+hp_xfer_pad);		/* Save current value */
-	WR_HARPOON(ioPort+hp_xfer_pad, (i | ID_UNLOCK));
-	WR_HARPOON(ioPort+hp_select_id, ((scsiID << 4) | scsiID));
-	j = RD_HARPOON(ioPort+hp_synctarg_0);
-	WR_HARPOON(ioPort+hp_xfer_pad, i);		/* restore value */
-
-	actualXferRate = pSyncStr->ActualMegaXferRate;
-	if(!(j & NARROW_SCSI))
-	{
-		actualXferRate <<= 1;
-	}
-	if(actualXferRate == 0x00)
-	{
-		syncVal = EE_SYNC_ASYNC;			/* Async Mode */
-	}
-	if(actualXferRate == 0x0200)
-	{
-		syncVal = EE_SYNC_20MB;				/* 20/40 MB Mode */
-	}
-	if(actualXferRate > 0x0050 && actualXferRate < 0x0200 )
-	{
-		syncVal = EE_SYNC_10MB;				/* 10/20 MB Mode */
-	}
-	else
-	{
-		syncVal = EE_SYNC_5MB;				/* 5/10 MB Mode */
-	}
-	if(currTar_Info->TarEEValue && EE_SYNC_MASK == syncVal)
-		return(0);
-	currTar_Info->TarEEValue = (currTar_Info->TarEEValue & !EE_SYNC_MASK)
-											| syncVal;
-	syncOffset = (SYNC_RATE_TBL + scsiID) / 2;
-	temp2.tempw = utilEERead(ioPort, syncOffset);
-	if(scsiID & 0x01)
-	{
-		temp2.tempb[0] = (temp2.tempb[0] & !EE_SYNC_MASK) | syncVal;
-	}
-	else
-	{
-		temp2.tempb[1] = (temp2.tempb[1] & !EE_SYNC_MASK) | syncVal;
-	}
-	utilEEWriteOnOff(ioPort, 1);
-	utilEEWrite(ioPort, temp2.tempw, syncOffset);
-	utilEEWriteOnOff(ioPort, 0);
-	UpdateCheckSum(ioPort);
-
-	return(0);
-}
-/*---------------------------------------------------------------------
- *
- * Function: GetDevWideMode
- *
- *---------------------------------------------------------------------*/
-int GetDevWideMode(PSCCBcard pCurrCard,PUCB p_ucb)
-{
-	u08bits *pData;
-
-	pData = (u08bits *)p_ucb->UCB_virt_dataptr;
-	if(sccbMgrTbl[pCurrCard->cardIndex][p_ucb->UCB_targid].TarEEValue
-				& EE_WIDE_SCSI)
-	{
-		*pData = 1;
-	}
-	else
-	{
-		*pData = 0;
-	}
-
-	return(0);
-}
-
-/*---------------------------------------------------------------------
- *
- * Function: SetDevWideMode
- *
- *---------------------------------------------------------------------*/
-int SetDevWideMode(PSCCBcard pCurrCard,PUCB p_ucb)
-{
-	u08bits *pData;
-   PSCCBMgr_tar_info currTar_Info;
-	BASE_PORT ioPort;
-	u08bits scsiID, scsiWideMode;
-	u16bits syncOffset;
-	union {
-		u08bits tempb[2];
-		u16bits tempw;
-	}temp2;
-
-#if (FW_TYPE != _SCCB_MGR_)
-	if( !(pCurrCard->cardInfo->ai_attributes & WIDE_CAPABLE) )
-	{
-		return(1);
-	}
-
-	if( p_ucb->UCB_targid >= pCurrCard->cardInfo->ai_MaxTarg )
-	{
-		return(1);
-	}
-#endif
-
-	ioPort  = pCurrCard->ioPort;
-	pData = (u08bits *)p_ucb->UCB_virt_dataptr;
-	scsiID = (u08bits) p_ucb->UCB_targid;
-	currTar_Info = &sccbMgrTbl[pCurrCard->cardIndex][scsiID];
-
-	if(*pData)
-	{
-		if(currTar_Info->TarEEValue & EE_WIDE_SCSI)
-		{
-			return(0);
-		}
-		else
-		{
-			scsiWideMode = EE_WIDE_SCSI;
-		}
-	}
-	else
-	{
-		if(!(currTar_Info->TarEEValue & EE_WIDE_SCSI))
-		{
-			return(0);
-		}
-		else
-		{
-			scsiWideMode = 0;
-		}
-	}
-	currTar_Info->TarEEValue = (currTar_Info->TarEEValue & !EE_WIDE_SCSI)
-											| scsiWideMode;
-
-	syncOffset = (SYNC_RATE_TBL + scsiID) / 2;
-	temp2.tempw = utilEERead(ioPort, syncOffset);
-	if(scsiID & 0x01)
-	{
-		temp2.tempb[0] = (temp2.tempb[0] & !EE_WIDE_SCSI) | scsiWideMode;
-	}
-	else
-	{
-		temp2.tempb[1] = (temp2.tempb[1] & !EE_WIDE_SCSI) | scsiWideMode;
-	}
-	utilEEWriteOnOff(ioPort, 1);
-	utilEEWrite(ioPort, temp2.tempw, syncOffset);
-	utilEEWriteOnOff(ioPort, 0);
-	UpdateCheckSum(ioPort);
-
-	return(0);
-}
-
-/*---------------------------------------------------------------------
- *
- * Function: ReadNVRam
- *
- *---------------------------------------------------------------------*/
-void ReadNVRam(PSCCBcard pCurrCard,PUCB p_ucb)
-{
-	u08bits *pdata;
-	u16bits i,numwrds,numbytes,offset,temp;
-	u08bits OneMore = FALSE;
-#if defined(DOS)
-	u16bits ioport;
-#else
-	u32bits ioport;
-#endif
-
-	numbytes = (u16bits) p_ucb->UCB_datalen;
-	ioport  = pCurrCard->ioPort;
-   pdata   = (u08bits *) p_ucb->UCB_virt_dataptr;
-	offset  = (u16bits) (p_ucb->UCB_IOCTLParams[0]);
-
-
-
-   if (offset & 0x1)
-	{
-	    *((u16bits*) pdata) = utilEERead(ioport,(u16bits)((offset - 1) / 2)); /* 16 bit read */
-		 *pdata = *(pdata + 1);
-		 ++offset;
-   	 ++pdata;
-		 --numbytes;
-	}
-
-	numwrds = numbytes / 2;
-	if (numbytes & 1)
-	 	OneMore = TRUE;
-
-	for (i = 0; i < numwrds; i++)
-	{
-   	*((u16bits*) pdata) = utilEERead(ioport,(u16bits)(offset / 2));
-		pdata += 2;
-		offset += 2;
-   }
-	if (OneMore)
-	{
-		--pdata;
-		-- offset;
-   	temp = utilEERead(ioport,(u16bits)(offset / 2));
-		*pdata = (u08bits) (temp);
-	}
-
-} /* end proc ReadNVRam */
-
-
-/*---------------------------------------------------------------------
- *
- * Function: WriteNVRam
- *
- *---------------------------------------------------------------------*/
-void WriteNVRam(PSCCBcard pCurrCard,PUCB p_ucb)
-{
-	u08bits *pdata;
-	u16bits i,numwrds,numbytes,offset, eeprom_end;
-	u08bits OneMore = FALSE;
-	union {
-		u08bits  tempb[2];
-		u16bits  tempw;
-	} temp2;
-
-#if defined(DOS)
-	u16bits ioport;
-#else
-	u32bits ioport;
-#endif
-
-	numbytes = (u16bits) p_ucb->UCB_datalen;
-	ioport  = pCurrCard->ioPort;
-   pdata   = (u08bits *) p_ucb->UCB_virt_dataptr;
-	offset  = (u16bits) (p_ucb->UCB_IOCTLParams[0]);
-
-   if (RD_HARPOON(ioport+hp_page_ctrl) & NARROW_SCSI_CARD)
-      eeprom_end = 512;
-   else
-      eeprom_end = 768;
-	
-	if(offset > eeprom_end)
-		return;
 
-	if((offset + numbytes) > eeprom_end)
-		numbytes = eeprom_end - offset;
 
-    utilEEWriteOnOff(ioport,1);   /* Enable write access to the EEPROM */
+   if (pCardInfo->si_flags & POST_ALL_UNDERRRUNS)
+      CurrCard->globalFlags |= F_NO_FILTER;
 
+	if(pCurrNvRam){
+		if(pCurrNvRam->niSysConf & 0x10)
+			CurrCard->globalFlags |= F_GREEN_PC;
+	}
+	else{
+	   if (FPT_utilEERead(ioport, (SYSTEM_CONFIG/2)) & GREEN_PC_ENA)
+   	   CurrCard->globalFlags |= F_GREEN_PC;
+	}
 
+	/* Set global flag to indicate Re-Negotiation to be done on all
+		ckeck condition */
+	if(pCurrNvRam){
+		if(pCurrNvRam->niScsiConf & 0x04)
+			CurrCard->globalFlags |= F_DO_RENEGO;
+	}
+	else{
+	   if (FPT_utilEERead(ioport, (SCSI_CONFIG/2)) & RENEGO_ENA)
+   	   CurrCard->globalFlags |= F_DO_RENEGO;
+	}
 
-   if (offset & 0x1)
-	{
-	    temp2.tempw = utilEERead(ioport,(u16bits)((offset - 1) / 2)); /* 16 bit read */
-		 temp2.tempb[1] = *pdata;
-	    utilEEWrite(ioport, temp2.tempw, (u16bits)((offset -1) / 2));
-		 *pdata = *(pdata + 1);
-		 ++offset;
-   	 ++pdata;
-		 --numbytes;
+	if(pCurrNvRam){
+		if(pCurrNvRam->niScsiConf & 0x08)
+			CurrCard->globalFlags |= F_CONLUN_IO;
+	}
+	else{
+	   if (FPT_utilEERead(ioport, (SCSI_CONFIG/2)) & CONNIO_ENA)
+   	   CurrCard->globalFlags |= F_CONLUN_IO;
 	}
 
-	numwrds = numbytes / 2;
-	if (numbytes & 1)
-	 	OneMore = TRUE;
 
-	for (i = 0; i < numwrds; i++)
-	{
-   	utilEEWrite(ioport, *((pu16bits)pdata),(u16bits)(offset / 2));
-		pdata += 2;
-		offset += 2;
-   }
-	if (OneMore)
-	{
+   temp = pCardInfo->si_per_targ_no_disc;
 
-   	temp2.tempw = utilEERead(ioport,(u16bits)(offset / 2));
-		temp2.tempb[0] = *pdata;
-   	utilEEWrite(ioport, temp2.tempw, (u16bits)(offset / 2));
-	}
-   utilEEWriteOnOff(ioport,0);   /* Turn off write access */
-   UpdateCheckSum((u32bits)ioport);
+   for (i = 0,id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
 
-} /* end proc WriteNVRam */
+      if (temp & id)
+	 FPT_sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
+      }
 
+   sync_bit_map = 0x0001;
 
+   for (id = 0; id < (MAX_SCSI_TAR/2); id++) {
 
-/*---------------------------------------------------------------------
- *
- * Function: UpdateCheckSum
- *
- * Description: Update Check Sum in EEPROM
- *
- *---------------------------------------------------------------------*/
+		if(pCurrNvRam){
+			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
+					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		}else
+	      temp = FPT_utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
 
+      for (i = 0; i < 2; temp >>=8,i++) {
 
-void UpdateCheckSum(u32bits baseport)
-{
-	USHORT i,sum_data, eeprom_end;
+         if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
 
-	sum_data = 0x0000;
+            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue = (UCHAR)temp;
+            }
 
+         else {
+	    FPT_sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
+            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue =
+               (UCHAR)(temp & ~EE_SYNC_MASK);
+            }
 
-   if (RD_HARPOON(baseport+hp_page_ctrl) & NARROW_SCSI_CARD)
-      eeprom_end = 512;
-   else
-      eeprom_end = 768;
+/*         if ((pCardInfo->si_per_targ_wide_nego & sync_bit_map) ||
+            (id*2+i >= 8)){
+*/
+         if (pCardInfo->si_per_targ_wide_nego & sync_bit_map){
 
-	for (i = 1; i < eeprom_end/2; i++)
-	{
-		sum_data += utilEERead(baseport, i);
-	}
+            FPT_sccbMgrTbl[thisCard][id*2+i].TarEEValue |= EE_WIDE_SCSI;
 
-   utilEEWriteOnOff(baseport,1);   /* Enable write access to the EEPROM */
+            }
 
-   utilEEWrite(baseport, sum_data, EEPROM_CHECK_SUM/2);
-   utilEEWriteOnOff(baseport,0);   /* Turn off write access */
-}
+         else { /* NARROW SCSI */
+            FPT_sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
+            }
 
-void SccbMgr_save_foreign_state(PADAPTER_INFO pAdapterInfo)
-{
-}
 
+	 sync_bit_map <<= 1;
 
-void SccbMgr_restore_foreign_state(CARD_HANDLE pCurrCard)
-{
-}
 
-void SccbMgr_restore_native_state(CARD_HANDLE pCurrCard)
-{
-}
 
-#endif /* NO_IOCTLS */
+         }
+      }
 
-#endif /* (FW_TYPE==_UCB_MGR_)   */
+   WR_HARPOON((ioport+hp_semaphore),
+      (UCHAR)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
 
-#ifndef NO_IOCTLS
-#if (FW_TYPE==_UCB_MGR_)
-void SccbMgr_unload_card(CARD_HANDLE pCurrCard)
-#else
-#if defined(DOS)
-void SccbMgr_unload_card(USHORT pCurrCard)
-#else
-void SccbMgr_unload_card(ULONG pCurrCard)
-#endif
-#endif
+   return((ULONG)CurrCard);
+}
+
+static void SccbMgr_unload_card(ULONG pCurrCard)
 {
 	UCHAR i;
-#if defined(DOS)
-	USHORT portBase;
-	USHORT regOffset;
-#else
 	ULONG portBase;
 	ULONG regOffset;
-#endif
 	ULONG scamData;
-#if defined(OS2)
-	ULONG far *pScamTbl;
-#else
 	ULONG *pScamTbl;
-#endif
 	PNVRamInfo pCurrNvRam;
 
 	pCurrNvRam = ((PSCCBcard)pCurrCard)->pNvRamInfo;
 
 	if(pCurrNvRam){
-		WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);
-		WrStack(pCurrNvRam->niBaseAddr, 1, pCurrNvRam->niSysConf);
-		WrStack(pCurrNvRam->niBaseAddr, 2, pCurrNvRam->niScsiConf);
-		WrStack(pCurrNvRam->niBaseAddr, 3, pCurrNvRam->niScamConf);
-		WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);
+		FPT_WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);
+		FPT_WrStack(pCurrNvRam->niBaseAddr, 1, pCurrNvRam->niSysConf);
+		FPT_WrStack(pCurrNvRam->niBaseAddr, 2, pCurrNvRam->niScsiConf);
+		FPT_WrStack(pCurrNvRam->niBaseAddr, 3, pCurrNvRam->niScamConf);
+		FPT_WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);
 
 		for(i = 0; i < MAX_SCSI_TAR / 2; i++)
-			WrStack(pCurrNvRam->niBaseAddr, (UCHAR)(i+5), pCurrNvRam->niSyncTbl[i]);
+			FPT_WrStack(pCurrNvRam->niBaseAddr, (UCHAR)(i+5), pCurrNvRam->niSyncTbl[i]);
 
 		portBase = pCurrNvRam->niBaseAddr;
 
 		for(i = 0; i < MAX_SCSI_TAR; i++){
 			regOffset = hp_aramBase + 64 + i*4;
-#if defined(OS2)
-			pScamTbl = (ULONG far *) &pCurrNvRam->niScamTbl[i];
-#else
 			pScamTbl = (ULONG *) &pCurrNvRam->niScamTbl[i];
-#endif
 			scamData = *pScamTbl;
 			WR_HARP32(portBase, regOffset, scamData);
 		}
 
 	}else{
-		WrStack(((PSCCBcard)pCurrCard)->ioPort, 0, 0);
+		FPT_WrStack(((PSCCBcard)pCurrCard)->ioPort, 0, 0);
 	}
 }
-#endif /* NO_IOCTLS */
 
 
-void RNVRamData(PNVRamInfo pNvRamInfo)
+static void FPT_RNVRamData(PNVRamInfo pNvRamInfo)
 {
 	UCHAR i;
-#if defined(DOS)
-	USHORT portBase;
-	USHORT regOffset;
-#else
 	ULONG portBase;
 	ULONG regOffset;
-#endif
 	ULONG scamData;
-#if defined (OS2)
-	ULONG far *pScamTbl;
-#else
 	ULONG *pScamTbl;
-#endif
 
-	pNvRamInfo->niModel    = RdStack(pNvRamInfo->niBaseAddr, 0);
-	pNvRamInfo->niSysConf  = RdStack(pNvRamInfo->niBaseAddr, 1);
-	pNvRamInfo->niScsiConf = RdStack(pNvRamInfo->niBaseAddr, 2);
-	pNvRamInfo->niScamConf = RdStack(pNvRamInfo->niBaseAddr, 3);
-	pNvRamInfo->niAdapId   = RdStack(pNvRamInfo->niBaseAddr, 4);
+	pNvRamInfo->niModel    = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);
+	pNvRamInfo->niSysConf  = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);
+	pNvRamInfo->niScsiConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 2);
+	pNvRamInfo->niScamConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 3);
+	pNvRamInfo->niAdapId   = FPT_RdStack(pNvRamInfo->niBaseAddr, 4);
 
 	for(i = 0; i < MAX_SCSI_TAR / 2; i++)
-		pNvRamInfo->niSyncTbl[i] = RdStack(pNvRamInfo->niBaseAddr, (UCHAR)(i+5));
+		pNvRamInfo->niSyncTbl[i] = FPT_RdStack(pNvRamInfo->niBaseAddr, (UCHAR)(i+5));
 
 	portBase = pNvRamInfo->niBaseAddr;
 
 	for(i = 0; i < MAX_SCSI_TAR; i++){
 		regOffset = hp_aramBase + 64 + i*4;
 		RD_HARP32(portBase, regOffset, scamData);
-#if defined(OS2)
-		pScamTbl = (ULONG far *) &pNvRamInfo->niScamTbl[i];
-#else
 		pScamTbl = (ULONG *) &pNvRamInfo->niScamTbl[i];
-#endif
 		*pScamTbl = scamData;
 	}
 
 }
 
-#if defined(DOS)
-UCHAR RdStack(USHORT portBase, UCHAR index)
-#else
-UCHAR RdStack(ULONG portBase, UCHAR index)
-#endif
+static UCHAR FPT_RdStack(ULONG portBase, UCHAR index)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	return(RD_HARPOON(portBase + hp_stack_data));
 }
 
-#if defined(DOS)
-void WrStack(USHORT portBase, UCHAR index, UCHAR data)
-#else
-void WrStack(ULONG portBase, UCHAR index, UCHAR data)
-#endif
+static void FPT_WrStack(ULONG portBase, UCHAR index, UCHAR data)
 {
 	WR_HARPOON(portBase + hp_stack_addr, index);
 	WR_HARPOON(portBase + hp_stack_data, data);
 }
 
 
-#if (FW_TYPE==_UCB_MGR_)
-u08bits ChkIfChipInitialized(BASE_PORT ioPort)
-#else
-#if defined(DOS)
-UCHAR ChkIfChipInitialized(USHORT ioPort)
-#else
-UCHAR ChkIfChipInitialized(ULONG ioPort)
-#endif
-#endif
+static UCHAR FPT_ChkIfChipInitialized(ULONG ioPort)
 {
-	if((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != RdStack(ioPort, 4))
-		return(FALSE);
+	if((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))
+		return(0);
 	if((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)
 								!= CLKCTRL_DEFAULT)
-		return(FALSE);
+		return(0);
 	if((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||
 		(RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))
-		return(TRUE);
-	return(FALSE);
+		return(1);
+	return(0);
 
 }
 /*---------------------------------------------------------------------
@@ -4205,185 +2037,29 @@ UCHAR ChkIfChipInitialized(ULONG ioPort)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-#if (FW_TYPE==_UCB_MGR_)
-void SccbMgr_start_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb)
-#else
-#if defined(DOS)
-void SccbMgr_start_sccb(USHORT pCurrCard, PSCCB p_Sccb)
-#else
-void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
-#endif
-#endif
+static void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 {
-#if defined(DOS)
-   USHORT ioport;
-#else
    ULONG ioport;
-#endif
    UCHAR thisCard, lun;
 	PSCCB pSaveSccb;
    CALL_BK_FN callback;
 
-#if (FW_TYPE==_UCB_MGR_)
-   PSCCB p_Sccb;
-#endif
-
-   mOS_Lock((PSCCBcard)pCurrCard);
    thisCard = ((PSCCBcard) pCurrCard)->cardIndex;
    ioport = ((PSCCBcard) pCurrCard)->ioPort;
 
-#if (FW_TYPE==_UCB_MGR_)
-   p_Sccb = (PSCCB)p_ucb->UCB_MgrPrivatePtr;
-#endif
-
 	if((p_Sccb->TargID > MAX_SCSI_TAR) || (p_Sccb->Lun > MAX_LUN))
 	{
 
-#if (FW_TYPE==_UCB_MGR_)
-		p_ucb->UCB_hbastat = SCCB_COMPLETE;
-		p_ucb->UCB_status=SCCB_ERROR;
-		callback = (CALL_BK_FN)p_ucb->UCB_callback;
-		if (callback)
-			callback(p_ucb);
-#endif
-
-#if (FW_TYPE==_SCCB_MGR_)
 		p_Sccb->HostStatus = SCCB_COMPLETE;
 		p_Sccb->SccbStatus = SCCB_ERROR;
 		callback = (CALL_BK_FN)p_Sccb->SccbCallback;
 		if (callback)
 			callback(p_Sccb);
-#endif
 
-		mOS_UnLock((PSCCBcard)pCurrCard);
 		return;
 	}
 
-#if (FW_TYPE==_SCCB_MGR_)
-   sinits(p_Sccb,thisCard);
-#endif
-
-
-#if (FW_TYPE==_UCB_MGR_)
-#ifndef NO_IOCTLS
-
-   if (p_ucb->UCB_opcode & OPC_IOCTL)
-	{
-
-		switch (p_ucb->UCB_IOCTLCommand) 
-		{
-			case READ_NVRAM:
-				ReadNVRam((PSCCBcard)pCurrCard,p_ucb);
-				p_ucb->UCB_status=UCB_SUCCESS;
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-
-			case WRITE_NVRAM:
-				WriteNVRam((PSCCBcard)pCurrCard,p_ucb);
-				p_ucb->UCB_status=UCB_SUCCESS;
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-
-			case SEND_SCSI_PASSTHRU:
-#if (FW_TYPE != _SCCB_MGR_)
-				if( p_ucb->UCB_targid >=
-				    ((PSCCBcard)pCurrCard)->cardInfo->ai_MaxTarg )
-				{
-					p_ucb->UCB_status = UCB_ERROR;
-					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
-					callback = (CALL_BK_FN)p_ucb->UCB_callback;
-					if (callback)
-						callback(p_ucb);
-					mOS_UnLock((PSCCBcard)pCurrCard);
-					return;
-				}
-#endif
-				break;
-
-			case HARD_RESET:
-				p_ucb->UCB_status = UCB_INVALID;
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-			case GET_DEVICE_SYNCRATE:
-				if( !GetDevSyncRate((PSCCBcard)pCurrCard,p_ucb) )
-				{
-					p_ucb->UCB_status = UCB_SUCCESS;
-				}
-				else
-				{
-					p_ucb->UCB_status = UCB_ERROR;
-					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
-				}
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-			case SET_DEVICE_SYNCRATE:
-				if( !SetDevSyncRate((PSCCBcard)pCurrCard,p_ucb) )
-				{
-					p_ucb->UCB_status = UCB_SUCCESS;
-				}
-				else
-				{
-					p_ucb->UCB_status = UCB_ERROR;
-					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
-				}
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-			case GET_WIDE_MODE:
-				if( !GetDevWideMode((PSCCBcard)pCurrCard,p_ucb) )
-				{
-					p_ucb->UCB_status = UCB_SUCCESS;
-				}
-				else
-				{
-					p_ucb->UCB_status = UCB_ERROR;
-					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
-				}
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-			case SET_WIDE_MODE:
-				if( !SetDevWideMode((PSCCBcard)pCurrCard,p_ucb) )
-				{
-					p_ucb->UCB_status = UCB_SUCCESS;
-				}
-				else
-				{
-					p_ucb->UCB_status = UCB_ERROR;
-					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
-				}
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-			default:
-				p_ucb->UCB_status=UCB_INVALID;
-				callback = (CALL_BK_FN)p_ucb->UCB_callback;
-				if (callback)
-					callback(p_ucb);
-				mOS_UnLock((PSCCBcard)pCurrCard);
-				return;
-		}
-	}
-#endif /* NO_IOCTLS */
-#endif /* (FW_TYPE==_UCB_MGR_) */
+   FPT_sinits(p_Sccb,thisCard);
 
 
    if (!((PSCCBcard) pCurrCard)->cmdCounter)
@@ -4408,12 +2084,12 @@ void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 			{
 				pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
 				((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-				queueSelectFail(&BL_Card[thisCard], thisCard);
+				FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
 				((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
 			}
 		else
 			{
-	      queueAddSccb(p_Sccb,thisCard);
+	      FPT_queueAddSccb(p_Sccb,thisCard);
 			}
       }
 
@@ -4423,12 +2099,12 @@ void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 				{
 					pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
 					((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-					queueSelectFail(&BL_Card[thisCard], thisCard);
+					FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
 					((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
 				}
 			else
 				{
-		      queueAddSccb(p_Sccb,thisCard);
+		      FPT_queueAddSccb(p_Sccb,thisCard);
 				}
       }
 
@@ -4437,23 +2113,17 @@ void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
       MDISABLE_INT(ioport);
 
 		if((((PSCCBcard) pCurrCard)->globalFlags & F_CONLUN_IO) && 
-			((sccbMgrTbl[thisCard][p_Sccb->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+			((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
 			lun = p_Sccb->Lun;
 		else
 			lun = 0;
       if ((((PSCCBcard) pCurrCard)->currentSCCB == NULL) &&
-         (sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0) &&
-         (sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
-         == FALSE)) {
+         (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0) &&
+         (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
+         == 0)) {
 
             ((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-			   mOS_UnLock((PSCCBcard)pCurrCard);
-#if defined(DOS)
-            ssel((USHORT)p_Sccb->SccbIOPort,thisCard);
-#else
-	    ssel(p_Sccb->SccbIOPort,thisCard);
-#endif
-			   mOS_Lock((PSCCBcard)pCurrCard);
+	    FPT_ssel(p_Sccb->SccbIOPort,thisCard);
          }
 
       else {
@@ -4462,12 +2132,12 @@ void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 				{
 					pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
 					((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-					queueSelectFail(&BL_Card[thisCard], thisCard);
+					FPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);
 					((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
 				}
 			else
 				{
-	         	queueAddSccb(p_Sccb,thisCard);
+	         	FPT_queueAddSccb(p_Sccb,thisCard);
 				}
          }
 
@@ -4475,7 +2145,6 @@ void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
       MENABLE_INT(ioport);
       }
 
-   mOS_UnLock((PSCCBcard)pCurrCard);
 }
 
 
@@ -4488,22 +2157,9 @@ void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
  *              callback function.
  *
  *---------------------------------------------------------------------*/
-#if (FW_TYPE==_UCB_MGR_)
-s32bits SccbMgr_abort_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb)
-#else
-#if defined(DOS)
-int SccbMgr_abort_sccb(USHORT pCurrCard, PSCCB p_Sccb)
-#else
-int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
-#endif
-#endif
-
+static int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 {
-#if defined(DOS)
-	USHORT ioport;
-#else
 	ULONG ioport;
-#endif
 
 	UCHAR thisCard;
 	CALL_BK_FN callback;
@@ -4512,53 +2168,31 @@ int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 	PSCCBMgr_tar_info currTar_Info;
 
 
-#if (FW_TYPE==_UCB_MGR_)
-	PSCCB    p_Sccb;
-	p_Sccb=(PSCCB)p_ucb->UCB_MgrPrivatePtr;
-#endif
-
 	ioport = ((PSCCBcard) pCurrCard)->ioPort;
 
 	thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
 
-	mOS_Lock((PSCCBcard)pCurrCard);
-
-	if (RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE)
-	{
-		mOS_UnLock((PSCCBcard)pCurrCard);
-	}
-
-	else
+	if (!(RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE))
 	{
 
-		if (queueFindSccb(p_Sccb,thisCard))
+		if (FPT_queueFindSccb(p_Sccb,thisCard))
 		{
 
-			mOS_UnLock((PSCCBcard)pCurrCard);
-
 			((PSCCBcard)pCurrCard)->cmdCounter--;
 
 			if (!((PSCCBcard)pCurrCard)->cmdCounter)
 				WR_HARPOON(ioport+hp_semaphore,(RD_HARPOON(ioport+hp_semaphore)
 					& (UCHAR)(~(SCCB_MGR_ACTIVE | TICKLE_ME)) ));
 
-#if (FW_TYPE==_SCCB_MGR_)
 			p_Sccb->SccbStatus = SCCB_ABORT;
 			callback = p_Sccb->SccbCallback;
 			callback(p_Sccb);
-#else
-			p_ucb->UCB_status=SCCB_ABORT;
-			callback = (CALL_BK_FN)p_ucb->UCB_callback;
-			callback(p_ucb);
-#endif
 
 			return(0);
 		}
 
 		else
 		{
-			mOS_UnLock((PSCCBcard)pCurrCard);
-
 			if (((PSCCBcard)pCurrCard)->currentSCCB == p_Sccb)
 			{
 				p_Sccb->SccbStatus = SCCB_ABORT;
@@ -4579,21 +2213,18 @@ int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 					{
 						p_Sccb->SccbStatus = SCCB_ABORT;
 						p_Sccb->Sccb_scsistat = ABORT_ST;
-#if (FW_TYPE==_UCB_MGR_)
-						p_ucb->UCB_status=SCCB_ABORT;
-#endif
 						p_Sccb->Sccb_scsimsg = SMABORT_TAG;
 
 						if(((PSCCBcard) pCurrCard)->currentSCCB == NULL)
 						{
 							((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-							ssel(ioport, thisCard);
+							FPT_ssel(ioport, thisCard);
 						}
 						else
 						{
 							pSaveSCCB = ((PSCCBcard) pCurrCard)->currentSCCB;
 							((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
-							queueSelectFail((PSCCBcard) pCurrCard, thisCard);
+							FPT_queueSelectFail((PSCCBcard) pCurrCard, thisCard);
 							((PSCCBcard) pCurrCard)->currentSCCB = pSaveSCCB;
 						}
 					}
@@ -4602,9 +2233,9 @@ int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
 				}
 				else
 				{
-					currTar_Info = &sccbMgrTbl[thisCard][p_Sccb->TargID];
+					currTar_Info = &FPT_sccbMgrTbl[thisCard][p_Sccb->TargID];
 
-					if(BL_Card[thisCard].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_Sccb->Lun]] 
+					if(FPT_BL_Card[thisCard].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_Sccb->Lun]] 
 							== p_Sccb)
 					{
 						p_Sccb->SccbStatus = SCCB_ABORT;
@@ -4626,37 +2257,20 @@ int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
  *              interrupt for this card and disable the IRQ Pin if so.
  *
  *---------------------------------------------------------------------*/
-#if (FW_TYPE==_UCB_MGR_)
-u08bits SccbMgr_my_int(CARD_HANDLE pCurrCard)
-#else
-#if defined(DOS)
-UCHAR SccbMgr_my_int(USHORT pCurrCard)
-#else
-UCHAR SccbMgr_my_int(ULONG pCurrCard)
-#endif
-#endif
+static UCHAR SccbMgr_my_int(ULONG pCurrCard)
 {
-#if defined(DOS)
-   USHORT ioport;
-#else
    ULONG ioport;
-#endif
 
    ioport = ((PSCCBcard)pCurrCard)->ioPort;
 
    if (RD_HARPOON(ioport+hp_int_status) & INT_ASSERTED)
    {
-
-#if defined(DOS)
-      MDISABLE_INT(ioport);
-#endif
-
-      return(TRUE);
+      return(1);
    }
 
    else
 
-      return(FALSE);
+      return(0);
 }
 
 
@@ -4670,37 +2284,19 @@ UCHAR SccbMgr_my_int(ULONG pCurrCard)
  *              us.
  *
  *---------------------------------------------------------------------*/
-#if (FW_TYPE==_UCB_MGR_)
-s32bits SccbMgr_isr(CARD_HANDLE pCurrCard)
-#else
-#if defined(DOS)
-int SccbMgr_isr(USHORT pCurrCard)
-#else
-int SccbMgr_isr(ULONG pCurrCard)
-#endif
-#endif
+static int SccbMgr_isr(ULONG pCurrCard)
 {
    PSCCB currSCCB;
    UCHAR thisCard,result,bm_status, bm_int_st;
    USHORT hp_int;
    UCHAR i, target;
-#if defined(DOS)
-   USHORT ioport;
-#else
    ULONG ioport;
-#endif
-
-   mOS_Lock((PSCCBcard)pCurrCard);
 
    thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
    ioport = ((PSCCBcard)pCurrCard)->ioPort;
 
    MDISABLE_INT(ioport);
 
-#if defined(BUGBUG)
-   WR_HARPOON(ioport+hp_user_defined_D, RD_HARPOON(ioport+hp_int_status));
-#endif
-
    if ((bm_int_st=RD_HARPOON(ioport+hp_int_status)) & EXT_STATUS_ON)
 		bm_status = RD_HARPOON(ioport+hp_ext_status) & (UCHAR)BAD_EXT_STATUS;
    else
@@ -4708,33 +2304,20 @@ int SccbMgr_isr(ULONG pCurrCard)
 
    WR_HARPOON(ioport+hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
 
-   mOS_UnLock((PSCCBcard)pCurrCard);
-
-   while ((hp_int = RDW_HARPOON((ioport+hp_intstat)) & default_intena) |
+   while ((hp_int = RDW_HARPOON((ioport+hp_intstat)) & FPT_default_intena) |
 	  bm_status)
      {
 
        currSCCB = ((PSCCBcard)pCurrCard)->currentSCCB;
 
-#if defined(BUGBUG)
-   Debug_Load(thisCard,(UCHAR) 0XFF);
-   Debug_Load(thisCard,bm_int_st);
-
-   Debug_Load(thisCard,hp_int_0);
-   Debug_Load(thisCard,hp_int_1);
-#endif
-
-
       if (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {
-         result = SccbMgr_bad_isr(ioport,thisCard,((PSCCBcard)pCurrCard),hp_int);
+         result = FPT_SccbMgr_bad_isr(ioport,thisCard,((PSCCBcard)pCurrCard),hp_int);
          WRW_HARPOON((ioport+hp_intstat), (FIFO | TIMEOUT | RESET | SCAM_SEL));
          bm_status = 0;
 
          if (result) {
 
-			   mOS_Lock((PSCCBcard)pCurrCard);
             MENABLE_INT(ioport);
-			   mOS_UnLock((PSCCBcard)pCurrCard);
             return(result);
             }
          }
@@ -4753,7 +2336,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 
          if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
 
-            phaseChkFifo(ioport, thisCard);
+            FPT_phaseChkFifo(ioport, thisCard);
 
 /*         WRW_HARPOON((ioport+hp_intstat),
             (BUS_FREE | ICMD_COMP | ITAR_DISC | XFER_CNT_0));
@@ -4761,7 +2344,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 
 		 WRW_HARPOON((ioport+hp_intstat), CLR_ALL_INT_1);
 
-         autoCmdCmplt(ioport,thisCard);
+         FPT_autoCmdCmplt(ioport,thisCard);
 
          }
 
@@ -4771,7 +2354,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 
          if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
 
-            phaseChkFifo(ioport, thisCard);
+            FPT_phaseChkFifo(ioport, thisCard);
 
             }
 
@@ -4784,7 +2367,7 @@ int SccbMgr_isr(ULONG pCurrCard)
             }
 
          currSCCB->Sccb_scsistat = DISCONNECT_ST;
-         queueDisconnect(currSCCB,thisCard);
+         FPT_queueDisconnect(currSCCB,thisCard);
 
             /* Wait for the BusFree before starting a new command.  We
                must also check for being reselected since the BusFree
@@ -4803,9 +2386,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 	   */
 	   if (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL)))
 	     {
-	       mOS_Lock((PSCCBcard)pCurrCard);
 	       MENABLE_INT(ioport);
-	       mOS_UnLock((PSCCBcard)pCurrCard);
 	       return 0xFE;
 	     }
 
@@ -4825,7 +2406,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 		      {
             if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
 			      {
-               phaseChkFifo(ioport, thisCard);
+               FPT_phaseChkFifo(ioport, thisCard);
                }
 
             if (RD_HARPOON(ioport+hp_gp_reg_1) == SMSAVE_DATA_PTR)
@@ -4837,11 +2418,11 @@ int SccbMgr_isr(ULONG pCurrCard)
 
             WRW_HARPOON((ioport+hp_intstat), (BUS_FREE | ITAR_DISC));
             currSCCB->Sccb_scsistat = DISCONNECT_ST;
-            queueDisconnect(currSCCB,thisCard);
+            FPT_queueDisconnect(currSCCB,thisCard);
             }
 
-         sres(ioport,thisCard,((PSCCBcard)pCurrCard));
-         phaseDecode(ioport,thisCard);
+         FPT_sres(ioport,thisCard,((PSCCBcard)pCurrCard));
+         FPT_phaseDecode(ioport,thisCard);
 
          }
 
@@ -4850,7 +2431,7 @@ int SccbMgr_isr(ULONG pCurrCard)
          {
 
             WRW_HARPOON((ioport+hp_intstat), (IDO_STRT | XFER_CNT_0));
-            phaseDecode(ioport,thisCard);
+            FPT_phaseDecode(ioport,thisCard);
 
          }
 
@@ -4860,7 +2441,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 	 	   WRW_HARPOON((ioport+hp_intstat), (PHASE | IUNKWN | PROG_HLT));
 	 	   if ((RD_HARPOON(ioport+hp_prgmcnt_0) & (UCHAR)0x3f)< (UCHAR)SELCHK)
 	    		{
-	    		phaseDecode(ioport,thisCard);
+	    		FPT_phaseDecode(ioport,thisCard);
 	    		}
 	 	   else
 	    		{
@@ -4885,7 +2466,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 
          WRW_HARPOON((ioport+hp_intstat), XFER_CNT_0);
 
-         schkdd(ioport,thisCard);
+         FPT_schkdd(ioport,thisCard);
 
          }
 
@@ -4896,10 +2477,10 @@ int SccbMgr_isr(ULONG pCurrCard)
 
         	if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
 
-           	hostDataXferAbort(ioport,thisCard,currSCCB);
+           	FPT_hostDataXferAbort(ioport,thisCard,currSCCB);
 				}
 
-         phaseBusFree(ioport,thisCard);
+         FPT_phaseBusFree(ioport,thisCard);
 			}
 
 
@@ -4919,12 +2500,12 @@ int SccbMgr_isr(ULONG pCurrCard)
 
          if (((PSCCBcard)pCurrCard)->currentSCCB == NULL) {
 
-            queueSearchSelect(((PSCCBcard)pCurrCard),thisCard);
+            FPT_queueSearchSelect(((PSCCBcard)pCurrCard),thisCard);
             }
 
          if (((PSCCBcard)pCurrCard)->currentSCCB != NULL) {
             ((PSCCBcard)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
-            ssel(ioport,thisCard);
+            FPT_ssel(ioport,thisCard);
             }
 
          break;
@@ -4933,9 +2514,7 @@ int SccbMgr_isr(ULONG pCurrCard)
 
       }  /*end while */
 
-   mOS_Lock((PSCCBcard)pCurrCard);
    MENABLE_INT(ioport);
-   mOS_UnLock((PSCCBcard)pCurrCard);
 
    return(0);
 }
@@ -4950,18 +2529,12 @@ int SccbMgr_isr(ULONG pCurrCard)
  *              processing time.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-UCHAR SccbMgr_bad_isr(USHORT p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int)
-#else
-UCHAR SccbMgr_bad_isr(ULONG p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int)
-#endif
+static UCHAR FPT_SccbMgr_bad_isr(ULONG p_port, UCHAR p_card,
+				 PSCCBcard pCurrCard, USHORT p_int)
 {
-#if defined(HARP_REVX)
-   ULONG timer;
-#endif
-UCHAR temp, ScamFlg;
-PSCCBMgr_tar_info currTar_Info;
-PNVRamInfo pCurrNvRam;
+   UCHAR temp, ScamFlg;
+   PSCCBMgr_tar_info currTar_Info;
+   PNVRamInfo pCurrNvRam;
 
 
    if (RD_HARPOON(p_port+hp_ext_status) &
@@ -4971,7 +2544,7 @@ PNVRamInfo pCurrNvRam;
       if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
          {
 
-         hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
+         FPT_hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
          }
 
       if (RD_HARPOON(p_port+hp_pci_stat_cfg) & REC_MASTER_ABORT)
@@ -4990,7 +2563,7 @@ PNVRamInfo pCurrNvRam;
          if (!pCurrCard->currentSCCB->HostStatus)
             pCurrCard->currentSCCB->HostStatus = SCCB_BM_ERR;
 
-         sxfrp(p_port,p_card);
+         FPT_sxfrp(p_port,p_card);
 
 	     temp = (UCHAR)(RD_HARPOON(p_port+hp_ee_ctrl) &
 							(EXT_ARB_ACK | SCSI_TERM_ENA_H));
@@ -4999,7 +2572,7 @@ PNVRamInfo pCurrNvRam;
 
          if (!(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
             {
-            phaseDecode(p_port,p_card);
+            FPT_phaseDecode(p_port,p_card);
             }
          }
       }
@@ -5014,13 +2587,13 @@ PNVRamInfo pCurrNvRam;
 
                if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
 
-               hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
+               FPT_hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
                }
 
 
            DISABLE_AUTO(p_port);
 
-           sresb(p_port,p_card);
+           FPT_sresb(p_port,p_card);
 
            while(RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST) {}
 
@@ -5029,12 +2602,12 @@ PNVRamInfo pCurrNvRam;
 					ScamFlg = pCurrNvRam->niScamConf;
 				}
 				else{
-				   ScamFlg = (UCHAR) utilEERead(p_port, SCAM_CONFIG/2);
+				   ScamFlg = (UCHAR) FPT_utilEERead(p_port, SCAM_CONFIG/2);
 				}
 
-           XbowInit(p_port, ScamFlg);
+           FPT_XbowInit(p_port, ScamFlg);
 
-               scini(p_card, pCurrCard->ourId, 0);
+               FPT_scini(p_card, pCurrCard->ourId, 0);
 
            return(0xFF);
          }
@@ -5044,34 +2617,8 @@ PNVRamInfo pCurrNvRam;
 
       WRW_HARPOON((p_port+hp_intstat), FIFO);
 
-#if defined(HARP_REVX)
-
-      for (timer=0x00FFFFFFL; timer != 0x00000000L; timer--) {
-
-         if (RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY)
-            break;
-
-         if (RDW_HARPOON((p_port+hp_intstat)) & BUS_FREE)
-            break;
-         }
-
-
-      if ( (RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY) &&
-           (RD_HARPOON(p_port+hp_fiforead) !=
-            RD_HARPOON(p_port+hp_fifowrite)) &&
-           (RD_HARPOON(p_port+hp_xfercnt_0))
-         )
-
-            WR_HARPOON((p_port+hp_xferstat), 0x01);
-
-/*      else
- */
-/*         sxfrp(p_port,p_card);
- */
-#else
       if (pCurrCard->currentSCCB != NULL)
-         sxfrp(p_port,p_card);
-#endif
+         FPT_sxfrp(p_port,p_card);
       }
 
    else if (p_int & TIMEOUT)
@@ -5085,12 +2632,12 @@ PNVRamInfo pCurrNvRam;
       pCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;
 
 
-		currTar_Info = &sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
+		currTar_Info = &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
 		if((pCurrCard->globalFlags & F_CONLUN_IO) &&
 			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	      currTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] = FALSE;
+	      currTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] = 0;
 		else
-	      currTar_Info->TarLUNBusy[0] = FALSE;
+	      currTar_Info->TarLUNBusy[0] = 0;
 
 
       if (currTar_Info->TarEEValue & EE_SYNC_MASK)
@@ -5104,131 +2651,27 @@ PNVRamInfo pCurrNvRam;
          currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
          }
 
-      sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,currTar_Info);
-
-      queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);
-
-      }
-
-#if defined(SCAM_LEV_2)
-
-   else if (p_int & SCAM_SEL)
-      {
-
-      scarb(p_port,LEVEL2_TAR);
-      scsel(p_port);
-      scasid(p_card, p_port);
-
-      scbusf(p_port);
-
-      WRW_HARPOON((p_port+hp_intstat), SCAM_SEL);
-      }
-#endif
-
-   return(0x00);
-}
-
-
-/*---------------------------------------------------------------------
- *
- * Function: SccbMgr_scsi_reset
- *
- * Description: A SCSI bus reset will be generated and all outstanding
- *              Sccbs will be returned via the callback.
- *
- *---------------------------------------------------------------------*/
-#if (FW_TYPE==_UCB_MGR_)
-void SccbMgr_scsi_reset(CARD_HANDLE pCurrCard)
-#else
-#if defined(DOS)
-void SccbMgr_scsi_reset(USHORT pCurrCard)
-#else
-void SccbMgr_scsi_reset(ULONG pCurrCard)
-#endif
-#endif
-{
-   UCHAR thisCard;
-
-   thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
+      FPT_sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,currTar_Info);
 
-   mOS_Lock((PSCCBcard)pCurrCard);
+      FPT_queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);
 
-   if (((PSCCBcard) pCurrCard)->globalFlags & F_GREEN_PC)
-      {
-      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_clkctrl_0, CLKCTRL_DEFAULT);
-      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_sys_ctrl, 0x00);
       }
 
-   sresb(((PSCCBcard)pCurrCard)->ioPort,thisCard);
-
-   if (RD_HARPOON(((PSCCBcard)pCurrCard)->ioPort+hp_ext_status) & BM_CMD_BUSY)
+   else if (p_int & SCAM_SEL)
       {
-      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_page_ctrl,
-         (RD_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_page_ctrl)
-         & ~SCATTER_EN));
 
-      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_sg_addr,0x00);
+      FPT_scarb(p_port,LEVEL2_TAR);
+      FPT_scsel(p_port);
+      FPT_scasid(p_card, p_port);
 
-      ((PSCCBcard) pCurrCard)->globalFlags &= ~F_HOST_XFER_ACT;
-      busMstrTimeOut(((PSCCBcard) pCurrCard)->ioPort);
+      FPT_scbusf(p_port);
 
-      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_int_mask,
-         (INT_CMD_COMPL | SCSI_INTERRUPT));
+      WRW_HARPOON((p_port+hp_intstat), SCAM_SEL);
       }
 
-/*
-      if (utilEERead(((PSCCBcard)pCurrCard)->ioPort, (SCAM_CONFIG/2))
-            & SCAM_ENABLED)
-*/
-         scini(thisCard, ((PSCCBcard)pCurrCard)->ourId, 0);
-
-#if (FW_TYPE==_UCB_MGR_)
-   ((PSCCBcard)pCurrCard)->cardInfo->ai_AEN_routine(0x01,pCurrCard,0,0,0,0);
-#endif
-
-   mOS_UnLock((PSCCBcard)pCurrCard);
-}
-
-
-/*---------------------------------------------------------------------
- *
- * Function: SccbMgr_timer_expired
- *
- * Description: This function allow me to kill my own job that has not
- *              yet completed, and has cause a timeout to occur.  This
- *              timeout has caused the upper level driver to call this
- *              function.
- *
- *---------------------------------------------------------------------*/
-
-#if (FW_TYPE==_UCB_MGR_)
-void SccbMgr_timer_expired(CARD_HANDLE pCurrCard)
-#else
-#if defined(DOS)
-void SccbMgr_timer_expired(USHORT pCurrCard)
-#else
-void SccbMgr_timer_expired(ULONG pCurrCard)
-#endif
-#endif
-{
+   return(0x00);
 }
 
-#if defined(DOS)
-/*---------------------------------------------------------------------
- *
- * Function: SccbMgr_status
- *
- * Description: This function returns the number of outstanding SCCB's.
- *              This is specific to the DOS enviroment, which needs this
- *              to help them keep protected and real mode commands staight.
- *
- *---------------------------------------------------------------------*/
-
-USHORT SccbMgr_status(USHORT pCurrCard)
-{
-   return(BL_Card[pCurrCard].cmdCounter);
-}
-#endif
 
 /*---------------------------------------------------------------------
  *
@@ -5238,19 +2681,19 @@ USHORT SccbMgr_status(USHORT pCurrCard)
  *
  *---------------------------------------------------------------------*/
 
-void SccbMgrTableInitAll()
+static void FPT_SccbMgrTableInitAll()
 {
    UCHAR thisCard;
 
    for (thisCard = 0; thisCard < MAX_CARDS; thisCard++)
       {
-      SccbMgrTableInitCard(&BL_Card[thisCard],thisCard);
+      FPT_SccbMgrTableInitCard(&FPT_BL_Card[thisCard],thisCard);
 
-      BL_Card[thisCard].ioPort      = 0x00;
-      BL_Card[thisCard].cardInfo    = NULL;
-      BL_Card[thisCard].cardIndex   = 0xFF;
-      BL_Card[thisCard].ourId       = 0x00;
-		BL_Card[thisCard].pNvRamInfo	= NULL;
+      FPT_BL_Card[thisCard].ioPort      = 0x00;
+      FPT_BL_Card[thisCard].cardInfo    = NULL;
+      FPT_BL_Card[thisCard].cardIndex   = 0xFF;
+      FPT_BL_Card[thisCard].ourId       = 0x00;
+		FPT_BL_Card[thisCard].pNvRamInfo	= NULL;
       }
 }
 
@@ -5263,20 +2706,20 @@ void SccbMgrTableInitAll()
  *
  *---------------------------------------------------------------------*/
 
-void SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card)
+static void FPT_SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card)
 {
    UCHAR scsiID, qtag;
 
 	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
 	{
-		BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+		FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
 	}
 
    for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++)
       {
-      sccbMgrTbl[p_card][scsiID].TarStatus = 0;
-      sccbMgrTbl[p_card][scsiID].TarEEValue = 0;
-      SccbMgrTableInitTarget(p_card, scsiID);
+      FPT_sccbMgrTbl[p_card][scsiID].TarStatus = 0;
+      FPT_sccbMgrTbl[p_card][scsiID].TarEEValue = 0;
+      FPT_SccbMgrTableInitTarget(p_card, scsiID);
       }
 
    pCurrCard->scanIndex = 0x00;
@@ -5298,13 +2741,13 @@ void SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-void SccbMgrTableInitTarget(UCHAR p_card, UCHAR target)
+static void FPT_SccbMgrTableInitTarget(UCHAR p_card, UCHAR target)
 {
 
 	UCHAR lun, qtag;
 	PSCCBMgr_tar_info currTar_Info;
 
-	currTar_Info = &sccbMgrTbl[p_card][target];
+	currTar_Info = &FPT_sccbMgrTbl[p_card][target];
 
 	currTar_Info->TarSelQ_Cnt = 0;
 	currTar_Info->TarSyncCtrl = 0;
@@ -5312,160 +2755,28 @@ void SccbMgrTableInitTarget(UCHAR p_card, UCHAR target)
 	currTar_Info->TarSelQ_Head = NULL;
 	currTar_Info->TarSelQ_Tail = NULL;
 	currTar_Info->TarTagQ_Cnt = 0;
-	currTar_Info->TarLUN_CA = FALSE;
+	currTar_Info->TarLUN_CA = 0;
 
 
 	for (lun = 0; lun < MAX_LUN; lun++)
 	{
-		currTar_Info->TarLUNBusy[lun] = FALSE;
+		currTar_Info->TarLUNBusy[lun] = 0;
 		currTar_Info->LunDiscQ_Idx[lun] = 0;
 	}
 
 	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
 	{
-		if(BL_Card[p_card].discQ_Tbl[qtag] != NULL)
+		if(FPT_BL_Card[p_card].discQ_Tbl[qtag] != NULL)
 		{
-			if(BL_Card[p_card].discQ_Tbl[qtag]->TargID == target)
+			if(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == target)
 			{
-				BL_Card[p_card].discQ_Tbl[qtag] = NULL;
-				BL_Card[p_card].discQCount--;
+				FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+				FPT_BL_Card[p_card].discQCount--;
 			}
 		}
 	}
 }
 
-#if defined(BUGBUG)
-
-/*****************************************************************
- * Save the current byte in the debug array
- *****************************************************************/
-
-
-void Debug_Load(UCHAR p_card, UCHAR p_bug_data)
-{
-   debug_int[p_card][debug_index[p_card]] = p_bug_data;
-   debug_index[p_card]++;
-
-   if (debug_index[p_card] == debug_size)
-
-      debug_index[p_card] = 0;
-}
-
-#endif
-#ident "$Id: sccb_dat.c 1.10 1997/02/22 03:16:02 awin Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   sccb_dat.c  $
- *
- *   Description:  Functions relating to handling of the SCCB interface 
- *                 between the device driver and the HARPOON.
- *
- *   $Date: 1997/02/22 03:16:02 $
- *
- *   $Revision: 1.10 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <harpoon.h>*/
-
-/*
-**  IMPORTANT NOTE!!!
-**
-**  You MUST preassign all data to a valid value or zero.  This is
-**  required due to the MS compiler bug under OS/2 and Solaris Real-Mode
-**  driver environment.
-*/
-
-
-SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
-SCCBCARD BL_Card[MAX_CARDS] = { { 0 } };
-SCCBSCAM_INFO scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
-NVRAMINFO nvRamInfo[MAX_MB_CARDS] = { { 0 } };
-
-
-#if defined(OS2)
-void (far *s_PhaseTbl[8]) (ULONG, UCHAR) = { 0 };
-UCHAR temp_id_string[ID_STRING_LENGTH] = { 0 };
-#elif defined(SOLARIS_REAL_MODE) || defined(__STDC__)
-void (*s_PhaseTbl[8]) (ULONG, UCHAR) = { 0 };
-#else
-void (*s_PhaseTbl[8]) ();
-#endif
-
-#if defined(DOS)
-UCHAR first_time = 0;
-#endif
-
-UCHAR mbCards = 0;
-UCHAR scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C', \
-								' ', 'B', 'T', '-', '9', '3', '0', \
-								0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \
-								0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
-
-USHORT default_intena = 0;
-
-#if defined(BUGBUG)
-UCHAR    debug_int[MAX_CARDS][debug_size] = { 0 };
-UCHAR    debug_index[MAX_CARDS] = { 0 };
-UCHAR    reserved_1[3] = { 0 };
-#endif
-#ident "$Id: scsi.c 1.23 1997/07/09 21:42:54 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   scsi.c  $
- *
- *   Description:  Functions for handling SCSI bus functions such as
- *                 selection/reselection, sync negotiation, message-in
- *                 decoding.
- *
- *   $Date: 1997/07/09 21:42:54 $
- *
- *   $Revision: 1.23 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <scsi2.h>*/
-/*#include <eeprom.h>*/
-/*#include <harpoon.h>*/
-
-
-/*
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-#if defined(BUGBUG)
-void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
-#endif
-*/
 
 /*---------------------------------------------------------------------
  *
@@ -5476,11 +2787,7 @@ void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-UCHAR sfm(USHORT port, PSCCB pCurrSCCB)
-#else
-UCHAR sfm(ULONG port, PSCCB pCurrSCCB)
-#endif
+static UCHAR FPT_sfm(ULONG port, PSCCB pCurrSCCB)
 {
 	UCHAR message;
 	USHORT TimeOutLoop;
@@ -5547,42 +2854,27 @@ UCHAR sfm(ULONG port, PSCCB pCurrSCCB)
 
 /*---------------------------------------------------------------------
  *
- * Function: ssel
+ * Function: FPT_ssel
  *
  * Description: Load up automation and select target device.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void ssel(USHORT port, UCHAR p_card)
-#else
-void ssel(ULONG port, UCHAR p_card)
-#endif
+static void FPT_ssel(ULONG port, UCHAR p_card)
 {
 
-#if defined(DOS)
-   UCHAR auto_loaded, i, target, *theCCB;
-#elif defined(OS2)
-   UCHAR auto_loaded, i, target;
-   UCHAR far *theCCB;
-#else
    UCHAR auto_loaded, i, target, *theCCB;
-#endif
 
-#if defined(DOS)
-   USHORT cdb_reg;
-#else
    ULONG cdb_reg;
-#endif
    PSCCBcard CurrCard;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
    UCHAR lastTag, lun;
 
-   CurrCard = &BL_Card[p_card];
+   CurrCard = &FPT_BL_Card[p_card];
    currSCCB = CurrCard->currentSCCB;
    target = currSCCB->TargID;
-   currTar_Info = &sccbMgrTbl[p_card][target];
+   currTar_Info = &FPT_sccbMgrTbl[p_card][target];
    lastTag = CurrCard->tagQ_Lst;
 
    ARAM_ACCESS(port);
@@ -5599,60 +2891,53 @@ void ssel(ULONG port, UCHAR p_card)
 		lun = 0;
 
 
-#if defined(DOS)
-   currTar_Info->TarLUNBusy[lun] = TRUE;
-
-#else
-
    if (CurrCard->globalFlags & F_TAG_STARTED)
       {
       if (!(currSCCB->ControlByte & F_USE_CMD_Q))
          {
-      	if ((currTar_Info->TarLUN_CA == FALSE)
+      	if ((currTar_Info->TarLUN_CA == 0)
       	    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
       	    == TAG_Q_TRYING))
             {
 
 	         if (currTar_Info->TarTagQ_Cnt !=0)
                   {
-         		   currTar_Info->TarLUNBusy[lun] = TRUE;
-            		queueSelectFail(CurrCard,p_card);
+         		   currTar_Info->TarLUNBusy[lun] = 1;
+            		FPT_queueSelectFail(CurrCard,p_card);
 					   SGRAM_ACCESS(port);
          		   return;
          		   }
 
             else {
-         		  currTar_Info->TarLUNBusy[lun] = TRUE;
+         		  currTar_Info->TarLUNBusy[lun] = 1;
          		  }
 
    	      }  /*End non-tagged */
 
 	      else {
-	         currTar_Info->TarLUNBusy[lun] = TRUE;
+	         currTar_Info->TarLUNBusy[lun] = 1;
 	         }
 
 	      }  /*!Use cmd Q Tagged */
 
 	   else {
-   	     if (currTar_Info->TarLUN_CA == TRUE)
+   	     if (currTar_Info->TarLUN_CA == 1)
                {
-      	      queueSelectFail(CurrCard,p_card);
+      	      FPT_queueSelectFail(CurrCard,p_card);
 				   SGRAM_ACCESS(port);
       	      return;
 	            }
 
-	        currTar_Info->TarLUNBusy[lun] = TRUE;
+	        currTar_Info->TarLUNBusy[lun] = 1;
 
    	     }  /*else use cmd Q tagged */
 
       }  /*if glob tagged started */
 
    else {
-        currTar_Info->TarLUNBusy[lun] = TRUE;
+        currTar_Info->TarLUNBusy[lun] = 1;
         }
 
-#endif /* DOS */
-
 
 
 	if((((CurrCard->globalFlags & F_CONLUN_IO) && 
@@ -5661,8 +2946,8 @@ void ssel(ULONG port, UCHAR p_card)
 	{
 		if(CurrCard->discQCount >= QUEUE_DEPTH)
 		{
-			currTar_Info->TarLUNBusy[lun] = TRUE;
-			queueSelectFail(CurrCard,p_card);
+			currTar_Info->TarLUNBusy[lun] = 1;
+			FPT_queueSelectFail(CurrCard,p_card);
 			SGRAM_ACCESS(port);
 			return;
 		}
@@ -5680,8 +2965,8 @@ void ssel(ULONG port, UCHAR p_card)
 		}
 		if(i == QUEUE_DEPTH)
 		{
-			currTar_Info->TarLUNBusy[lun] = TRUE;
-			queueSelectFail(CurrCard,p_card);
+			currTar_Info->TarLUNBusy[lun] = 1;
+			FPT_queueSelectFail(CurrCard,p_card);
 			SGRAM_ACCESS(port);
 			return;
 		}
@@ -5689,7 +2974,7 @@ void ssel(ULONG port, UCHAR p_card)
 
 
 
-   auto_loaded = FALSE;
+   auto_loaded = 0;
 
    WR_HARPOON(port+hp_select_id, target);
    WR_HARPOON(port+hp_gp_reg_3, target);  /* Use by new automation logic */
@@ -5703,7 +2988,7 @@ void ssel(ULONG port, UCHAR p_card)
       currSCCB->Sccb_scsimsg = SMDEV_RESET;
 
       WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-      auto_loaded = TRUE;
+      auto_loaded = 1;
       currSCCB->Sccb_scsistat = SELECT_BDR_ST;
 
       if (currTar_Info->TarEEValue & EE_SYNC_MASK)
@@ -5712,16 +2997,13 @@ void ssel(ULONG port, UCHAR p_card)
 	      currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
 	      }
 
-#if defined(WIDE_SCSI)
-
       if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
          {
       	currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
       	}
-#endif
 
-      sssyncv(port, target, NARROW_SCSI,currTar_Info);
-      SccbMgrTableInitTarget(p_card, target);
+      FPT_sssyncv(port, target, NARROW_SCSI,currTar_Info);
+      FPT_SccbMgrTableInitTarget(p_card, target);
 
       }
 
@@ -5740,24 +3022,18 @@ void ssel(ULONG port, UCHAR p_card)
 			WRW_HARPOON((port+SYNC_MSGS+4), (BRH_OP+ALWAYS+NP ));
 
 			WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-			auto_loaded = TRUE;
+			auto_loaded = 1;
 		
 		}
 
-#if defined(WIDE_SCSI)
-
-
    else if (!(currTar_Info->TarStatus & WIDE_NEGOCIATED))  {
-      auto_loaded = siwidn(port,p_card);
+      auto_loaded = FPT_siwidn(port,p_card);
       currSCCB->Sccb_scsistat = SELECT_WN_ST;
       }
 
-#endif
-
-
    else if (!((currTar_Info->TarStatus & TAR_SYNC_MASK)
       == SYNC_SUPPORTED))  {
-      auto_loaded = sisyncn(port,p_card, FALSE);
+      auto_loaded = FPT_sisyncn(port,p_card, 0);
       currSCCB->Sccb_scsistat = SELECT_SN_ST;
       }
 
@@ -5765,7 +3041,6 @@ void ssel(ULONG port, UCHAR p_card)
    if (!auto_loaded)
       {
 
-#if !defined(DOS)
       if (currSCCB->ControlByte & F_USE_CMD_Q)
          {
 
@@ -5789,7 +3064,7 @@ void ssel(ULONG port, UCHAR p_card)
                the wheels fall off. */
             currSCCB->Sccb_scsistat = SELECT_ST;
 
-	         currTar_Info->TarLUNBusy[lun] = TRUE;
+	         currTar_Info->TarLUNBusy[lun] = 1;
             }
 
          else
@@ -5818,8 +3093,8 @@ void ssel(ULONG port, UCHAR p_card)
 
             if ( i == QUEUE_DEPTH )
                {
-   	         currTar_Info->TarLUNBusy[lun] = TRUE;
-               queueSelectFail(CurrCard,p_card);
+   	         currTar_Info->TarLUNBusy[lun] = 1;
+               FPT_queueSelectFail(CurrCard,p_card);
 				   SGRAM_ACCESS(port);
    	         return;
    	         }
@@ -5832,7 +3107,6 @@ void ssel(ULONG port, UCHAR p_card)
 
       else
          {
-#endif   /* !DOS */
 
          WRW_HARPOON((port+ID_MSG_STRT),BRH_OP+ALWAYS+NTCMD);
 
@@ -5842,16 +3116,10 @@ void ssel(ULONG port, UCHAR p_card)
          currSCCB->Sccb_scsistat = SELECT_ST;
 
          WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
-#if !defined(DOS)
          }
-#endif
 
 
-#if defined(OS2)
-      theCCB = (UCHAR far *)&currSCCB->Cdb[0];
-#else
       theCCB = (UCHAR *)&currSCCB->Cdb[0];
-#endif
 
       cdb_reg = port + CMD_STRT;
 
@@ -5867,10 +3135,8 @@ void ssel(ULONG port, UCHAR p_card)
 
       }  /* auto_loaded */
 
-#if defined(WIDE_SCSI)
    WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
    WR_HARPOON(port+hp_xferstat, 0x00);
-#endif
 
    WRW_HARPOON((port+hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));
 
@@ -5899,30 +3165,16 @@ void ssel(ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: sres
+ * Function: FPT_sres
  *
  * Description: Hookup the correct CCB and handle the incoming messages.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void sres(USHORT port, UCHAR p_card, PSCCBcard pCurrCard)
-#else
-void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
-#endif
+static void FPT_sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 {
 
-#if defined(V302)
-#ifdef DOS
-   UCHAR our_target,message, msgRetryCount;
-   extern UCHAR lun, tag;
-#else
-   UCHAR our_target,message,lun,tag, msgRetryCount;
-#endif
-
-#else  /* V302 */
    UCHAR our_target, message, lun = 0, tag, msgRetryCount;
-#endif /* V302 */
 
 
    PSCCBMgr_tar_info currTar_Info;
@@ -5933,7 +3185,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 
 	if(pCurrCard->currentSCCB != NULL)
 	{
-		currTar_Info = &sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
+		currTar_Info = &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
 		DISABLE_AUTO(port);
 
 
@@ -5954,7 +3206,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
 			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 		{
-      	currTar_Info->TarLUNBusy[currSCCB->Lun] = FALSE;
+      	currTar_Info->TarLUNBusy[currSCCB->Lun] = 0;
 			if(currSCCB->Sccb_scsistat != ABORT_ST)
 			{
 				pCurrCard->discQCount--;
@@ -5964,7 +3216,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 		}
 		else
 		{
-	      currTar_Info->TarLUNBusy[0] = FALSE;
+	      currTar_Info->TarLUNBusy[0] = 0;
 			if(currSCCB->Sccb_tag)
 			{
 				if(currSCCB->Sccb_scsistat != ABORT_ST)
@@ -5982,29 +3234,21 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 			}
 		}
 
-      queueSelectFail(&BL_Card[p_card],p_card);
+      FPT_queueSelectFail(&FPT_BL_Card[p_card],p_card);
 	}
 
-#if defined(WIDE_SCSI)
 	WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
-#endif
 
 
 	our_target = (UCHAR)(RD_HARPOON(port+hp_select_id) >> 4);
-	currTar_Info = &sccbMgrTbl[p_card][our_target];
+	currTar_Info = &FPT_sccbMgrTbl[p_card][our_target];
 
 
 	msgRetryCount = 0;
 	do
 	{
 
-#if defined(V302)
-
-		message = GetTarLun(port, p_card, our_target, pCurrCard, &tag, &lun);
-
-#else /* V302 */
-
-		currTar_Info = &sccbMgrTbl[p_card][our_target];
+		currTar_Info = &FPT_sccbMgrTbl[p_card][our_target];
 		tag = 0;
 
 
@@ -6022,7 +3266,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 		if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH)
 		{
 
-			message = sfm(port,pCurrCard->currentSCCB);
+			message = FPT_sfm(port,pCurrCard->currentSCCB);
 			if (message)
 			{
 
@@ -6030,7 +3274,6 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 				{
 					lun = message & (UCHAR)LUN_MASK;
 
-#if !defined(DOS)
 					if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING)
 					{
 						if (currTar_Info->TarTagQ_Cnt != 0)
@@ -6041,21 +3284,21 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 								ACCEPT_MSG(port);    /*Release the ACK for ID msg. */
 
 
-								message = sfm(port,pCurrCard->currentSCCB);
+								message = FPT_sfm(port,pCurrCard->currentSCCB);
 								if (message)
 								{
 									ACCEPT_MSG(port);
 								}
 
 								else
-   								message = FALSE;
+   								message = 0;
 
-								if(message != FALSE)
+								if(message != 0)
 								{
-									tag = sfm(port,pCurrCard->currentSCCB);
+									tag = FPT_sfm(port,pCurrCard->currentSCCB);
 
 									if (!(tag)) 
-										message = FALSE;
+										message = 0;
 								}
 
 							} /*C.A. exists! */
@@ -6063,7 +3306,6 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 						} /*End Q cnt != 0 */
 
 					} /*End Tag cmds supported! */
-#endif /* !DOS */
 
 				} /*End valid ID message.  */
 
@@ -6078,7 +3320,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 			else
 			{
 
-				message = FALSE;
+				message = 0;
 			}
 		}
 		else
@@ -6091,49 +3333,47 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 
 			return;
 		}
-	
-#endif /* V302 */
 
-		if(message == FALSE)
+		if(message == 0)
 		{
 			msgRetryCount++;
 			if(msgRetryCount == 1)
 			{
-				SendMsg(port, SMPARITY);
+				FPT_SendMsg(port, SMPARITY);
 			}
 			else
 			{
-				SendMsg(port, SMDEV_RESET);
+				FPT_SendMsg(port, SMDEV_RESET);
 
-				sssyncv(port, our_target, NARROW_SCSI,currTar_Info);
+				FPT_sssyncv(port, our_target, NARROW_SCSI,currTar_Info);
 
-				if (sccbMgrTbl[p_card][our_target].TarEEValue & EE_SYNC_MASK) 
+				if (FPT_sccbMgrTbl[p_card][our_target].TarEEValue & EE_SYNC_MASK) 
 				{
 			
-					sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_SYNC_MASK;
+					FPT_sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_SYNC_MASK;
 
 				}
 
-				if (sccbMgrTbl[p_card][our_target].TarEEValue & EE_WIDE_SCSI) 
+				if (FPT_sccbMgrTbl[p_card][our_target].TarEEValue & EE_WIDE_SCSI) 
 				{
 
-					sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_WIDE_MASK;
+					FPT_sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_WIDE_MASK;
 				}
 
 
-				queueFlushTargSccb(p_card, our_target, SCCB_COMPLETE);
-				SccbMgrTableInitTarget(p_card,our_target);
+				FPT_queueFlushTargSccb(p_card, our_target, SCCB_COMPLETE);
+				FPT_SccbMgrTableInitTarget(p_card,our_target);
 				return;
 			}
 		}
-	}while(message == FALSE);
+	}while(message == 0);
 
 
 
 	if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
 		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 	{
-		currTar_Info->TarLUNBusy[lun] = TRUE;
+		currTar_Info->TarLUNBusy[lun] = 1;
 		pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];
 		if(pCurrCard->currentSCCB != NULL)
 		{
@@ -6146,7 +3386,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 	}
 	else
 	{
-		currTar_Info->TarLUNBusy[0] = TRUE;
+		currTar_Info->TarLUNBusy[0] = 1;
 
 
 		if (tag)
@@ -6182,7 +3422,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 		/* During Abort Tag command, the target could have got re-selected
 			and completed the command. Check the select Q and remove the CCB
 			if it is in the Select Q */
-			queueFindSccb(pCurrCard->currentSCCB, p_card);
+			FPT_queueFindSccb(pCurrCard->currentSCCB, p_card);
 		}
 	}
 
@@ -6192,106 +3432,7 @@ void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
 	  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
 }
 
-#if defined(V302)
-
-#if defined(DOS)
-UCHAR GetTarLun(USHORT port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tag, PUCHAR lun)
-#else
-UCHAR GetTarLun(ULONG port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tag, PUCHAR lun)
-#endif
-{
-   UCHAR message;
-   PSCCBMgr_tar_info currTar_Info;
-
-
-	currTar_Info = &sccbMgrTbl[p_card][our_target];
-	*tag = 0;
-
-
-	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
-	{
-		if (! (RD_HARPOON(port+hp_scsisig) & SCSI_BSY))
-		{
-
-			WRW_HARPOON((port+hp_intstat), PHASE);
-			return(TRUE);
-		}
-	}
-
-	WRW_HARPOON((port+hp_intstat), PHASE);
-	if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH)
-	{
-
-		message = sfm(port,pCurrCard->currentSCCB);
-		if (message)
-		{
-
-			if (message <= (0x80 | LUN_MASK))
-			{
-				*lun = message & (UCHAR)LUN_MASK;
-
-#if !defined(DOS)
-				if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING)
-				{
-					if (currTar_Info->TarTagQ_Cnt != 0)
-					{
-
-						if (!(currTar_Info->TarLUN_CA))
-						{
-							ACCEPT_MSG(port);    /*Release the ACK for ID msg. */
-
-
-							message = sfm(port,pCurrCard->currentSCCB);
-							if (message)
-							{
-								ACCEPT_MSG(port);
-							}
-
-							else
-   							return(FALSE);
-
-							*tag = sfm(port,pCurrCard->currentSCCB);
-
-							if (!(*tag)) return(FALSE);
-
-						} /*C.A. exists! */
-
-					} /*End Q cnt != 0 */
-
-				} /*End Tag cmds supported! */
-#endif /* !DOS */
-
-			} /*End valid ID message.  */
-
-			else
-			{
-
-				ACCEPT_MSG_ATN(port);
-			}
-
-		} /* End good id message. */
-
-		else
-		{
-
-			return(FALSE);
-		}
-	}
-	else
-	{
-		ACCEPT_MSG_ATN(port);
-		return(TRUE);
-	}
-	return(TRUE);
-}
-
-#endif /* V302 */
-
-#if defined(DOS)
-void SendMsg(USHORT port, UCHAR message)
-#else
-void SendMsg(ULONG port, UCHAR message)
-#endif
+static void FPT_SendMsg(ULONG port, UCHAR message)
 {
 	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
 	{
@@ -6334,26 +3475,22 @@ void SendMsg(ULONG port, UCHAR message)
 
 /*---------------------------------------------------------------------
  *
- * Function: sdecm
+ * Function: FPT_sdecm
  *
  * Description: Determine the proper responce to the message from the
  *              target device.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void sdecm(UCHAR message, USHORT port, UCHAR p_card)
-#else
-void sdecm(UCHAR message, ULONG port, UCHAR p_card)
-#endif
+static void FPT_sdecm(UCHAR message, ULONG port, UCHAR p_card)
 {
 	PSCCB currSCCB;
 	PSCCBcard CurrCard;
 	PSCCBMgr_tar_info currTar_Info;
 
-	CurrCard = &BL_Card[p_card];
+	CurrCard = &FPT_BL_Card[p_card];
 	currSCCB = CurrCard->currentSCCB;
 
-	currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+	currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
 	if (message == SMREST_DATA_PTR)
 	{
@@ -6361,7 +3498,7 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 		{
 			currSCCB->Sccb_ATC = currSCCB->Sccb_savedATC;
 
-			hostDataXferRestart(currSCCB);
+			FPT_hostDataXferRestart(currSCCB);
 		}
 
 		ACCEPT_MSG(port);
@@ -6417,7 +3554,6 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 					currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
 				}
 
-#if defined(WIDE_SCSI)
 				else if ((currSCCB->Sccb_scsistat == SELECT_WN_ST))
 				{
 
@@ -6428,7 +3564,6 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 					currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
 
 				}
-#endif
 
 				else if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING )
 				{
@@ -6460,9 +3595,9 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 
 				if((CurrCard->globalFlags & F_CONLUN_IO) &&
 					((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-					currTar_Info->TarLUNBusy[currSCCB->Lun] = TRUE;
+					currTar_Info->TarLUNBusy[currSCCB->Lun] = 1;
 				else
-					currTar_Info->TarLUNBusy[0] = TRUE;
+					currTar_Info->TarLUNBusy[0] = 1;
 
 
 				currSCCB->ControlByte &= ~(UCHAR)F_USE_CMD_Q;
@@ -6490,7 +3625,7 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 	{
 
 		ACCEPT_MSG(port);
-		shandem(port,p_card,currSCCB);
+		FPT_shandem(port,p_card,currSCCB);
 	}
 
 	else if (message == SMIGNORWR)
@@ -6498,7 +3633,7 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 
 		ACCEPT_MSG(port);          /* ACK the RESIDUE MSG */
 
-		message = sfm(port,currSCCB);
+		message = FPT_sfm(port,currSCCB);
 
 		if(currSCCB->Sccb_scsimsg != SMPARITY)
 			ACCEPT_MSG(port);
@@ -6520,25 +3655,21 @@ void sdecm(UCHAR message, ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: shandem
+ * Function: FPT_shandem
  *
  * Description: Decide what to do with the extended message.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void shandem(USHORT port, UCHAR p_card, PSCCB pCurrSCCB)
-#else
-void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
-#endif
+static void FPT_shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 {
 	UCHAR length,message;
 
-	length = sfm(port,pCurrSCCB);
+	length = FPT_sfm(port,pCurrSCCB);
 	if (length) 
 	{
 
 		ACCEPT_MSG(port);
-		message = sfm(port,pCurrSCCB);
+		message = FPT_sfm(port,pCurrSCCB);
 		if (message) 
 		{
 
@@ -6549,7 +3680,7 @@ void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 				{
 
 					ACCEPT_MSG(port);
-					stsyncn(port,p_card);
+					FPT_stsyncn(port,p_card);
 				}
 				else 
 				{
@@ -6558,7 +3689,6 @@ void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 					ACCEPT_MSG_ATN(port);
 				}
 			}
-#if defined(WIDE_SCSI)
 			else if (message == SMWDTR) 
 			{
 
@@ -6566,7 +3696,7 @@ void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 				{
 
 					ACCEPT_MSG(port);
-					stwidn(port,p_card);
+					FPT_stwidn(port,p_card);
 				}
 				else 
 				{
@@ -6577,7 +3707,6 @@ void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 					WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
 				}
 			}
-#endif
 			else 
 			{
 
@@ -6603,24 +3732,20 @@ void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 
 /*---------------------------------------------------------------------
  *
- * Function: sisyncn
+ * Function: FPT_sisyncn
  *
  * Description: Read in a message byte from the SCSI bus, and check
  *              for a parity error.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-UCHAR sisyncn(USHORT port, UCHAR p_card, UCHAR syncFlag)
-#else
-UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
-#endif
+static UCHAR FPT_sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
 {
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
-   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
    if (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)) {
 
@@ -6656,7 +3781,7 @@ UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
       WRW_HARPOON((port+SYNC_MSGS+12),(BRH_OP+ALWAYS+NP      ));
 
 
-		if(syncFlag == FALSE)
+		if(syncFlag == 0)
 		{
 		   WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
 	      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
@@ -6668,14 +3793,14 @@ UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
 		}
 
 
-      return(TRUE);
+      return(1);
       }
 
    else {
 
       currTar_Info->TarStatus |=	 (UCHAR)SYNC_SUPPORTED;
       currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
-      return(FALSE);
+      return(0);
       }
 }
 
@@ -6683,26 +3808,22 @@ UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
 
 /*---------------------------------------------------------------------
  *
- * Function: stsyncn
+ * Function: FPT_stsyncn
  *
  * Description: The has sent us a Sync Nego message so handle it as
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void stsyncn(USHORT port, UCHAR p_card)
-#else
-void stsyncn(ULONG port, UCHAR p_card)
-#endif
+static void FPT_stsyncn(ULONG port, UCHAR p_card)
 {
    UCHAR sync_msg,offset,sync_reg,our_sync_msg;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
-   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-   sync_msg = sfm(port,currSCCB);
+   sync_msg = FPT_sfm(port,currSCCB);
 
 	if((sync_msg == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
 	{
@@ -6713,7 +3834,7 @@ void stsyncn(ULONG port, UCHAR p_card)
    ACCEPT_MSG(port);
 
 
-   offset = sfm(port,currSCCB);
+   offset = FPT_sfm(port,currSCCB);
 
 	if((offset == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
 	{
@@ -6783,7 +3904,6 @@ void stsyncn(ULONG port, UCHAR p_card)
       }
 
 
-#if defined(WIDE_SCSI)
    if (currTar_Info->TarStatus & WIDE_ENABLED)
 
       sync_reg |= offset;
@@ -6792,11 +3912,7 @@ void stsyncn(ULONG port, UCHAR p_card)
 
       sync_reg |= (offset | NARROW_SCSI);
 
-#else
-   sync_reg |= (offset | NARROW_SCSI);
-#endif
-
-   sssyncv(port,currSCCB->TargID,sync_reg,currTar_Info);
+   FPT_sssyncv(port,currSCCB->TargID,sync_reg,currTar_Info);
 
 
    if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
@@ -6815,7 +3931,7 @@ void stsyncn(ULONG port, UCHAR p_card)
 
       ACCEPT_MSG_ATN(port);
 
-      sisyncr(port,sync_msg,offset);
+      FPT_sisyncr(port,sync_msg,offset);
 
       currTar_Info->TarStatus = ((currTar_Info->TarStatus &
          ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_SUPPORTED);
@@ -6825,16 +3941,12 @@ void stsyncn(ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: sisyncr
+ * Function: FPT_sisyncr
  *
  * Description: Answer the targets sync message.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void sisyncr(USHORT port,UCHAR sync_pulse, UCHAR offset)
-#else
-void sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset)
-#endif
+static void FPT_sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset)
 {
    ARAM_ACCESS(port);
    WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
@@ -6856,28 +3968,22 @@ void sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset)
 
 
 
-#if defined(WIDE_SCSI)
-
 /*---------------------------------------------------------------------
  *
- * Function: siwidn
+ * Function: FPT_siwidn
  *
  * Description: Read in a message byte from the SCSI bus, and check
  *              for a parity error.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-UCHAR siwidn(USHORT port, UCHAR p_card)
-#else
-UCHAR siwidn(ULONG port, UCHAR p_card)
-#endif
+static UCHAR FPT_siwidn(ULONG port, UCHAR p_card)
 {
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
-   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
    if (!((currTar_Info->TarStatus & TAR_WIDE_MASK) == WIDE_NEGOCIATED)) {
 
@@ -6900,7 +4006,7 @@ UCHAR siwidn(ULONG port, UCHAR p_card)
       currTar_Info->TarStatus = ((currTar_Info->TarStatus &
          ~(UCHAR)TAR_WIDE_MASK) | (UCHAR)WIDE_ENABLED);
 
-      return(TRUE);
+      return(1);
       }
 
    else {
@@ -6909,7 +4015,7 @@ UCHAR siwidn(ULONG port, UCHAR p_card)
                ~(UCHAR)TAR_WIDE_MASK) | WIDE_NEGOCIATED);
 
       currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
-      return(FALSE);
+      return(0);
       }
 }
 
@@ -6917,26 +4023,22 @@ UCHAR siwidn(ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: stwidn
+ * Function: FPT_stwidn
  *
  * Description: The has sent us a Wide Nego message so handle it as
  *              necessary.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void stwidn(USHORT port, UCHAR p_card)
-#else
-void stwidn(ULONG port, UCHAR p_card)
-#endif
+static void FPT_stwidn(ULONG port, UCHAR p_card)
 {
    UCHAR width;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
-   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
+   currTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];
 
-   width = sfm(port,currSCCB);
+   width = FPT_sfm(port,currSCCB);
 
 	if((width == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
 	{
@@ -6958,7 +4060,7 @@ void stwidn(ULONG port, UCHAR p_card)
       }
 
 
-   sssyncv(port,currSCCB->TargID,width,currTar_Info);
+   FPT_sssyncv(port,currSCCB->TargID,width,currTar_Info);
 
 
    if (currSCCB->Sccb_scsistat == SELECT_WN_ST)
@@ -6972,7 +4074,7 @@ void stwidn(ULONG port, UCHAR p_card)
 		{
 	      ACCEPT_MSG_ATN(port);
 		   ARAM_ACCESS(port);
-	     	sisyncn(port,p_card, TRUE);
+	     	FPT_sisyncn(port,p_card, 1);
 	      currSCCB->Sccb_scsistat = SELECT_SN_ST;
 		   SGRAM_ACCESS(port);
 		}
@@ -6993,7 +4095,7 @@ void stwidn(ULONG port, UCHAR p_card)
       else
       	 width = SM8BIT;
 
-      siwidr(port,width);
+      FPT_siwidr(port,width);
 
       currTar_Info->TarStatus |= (WIDE_NEGOCIATED | WIDE_ENABLED);
       }
@@ -7002,16 +4104,12 @@ void stwidn(ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: siwidr
+ * Function: FPT_siwidr
  *
  * Description: Answer the targets Wide nego message.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void siwidr(USHORT port, UCHAR width)
-#else
-void siwidr(ULONG port, UCHAR width)
-#endif
+static void FPT_siwidr(ULONG port, UCHAR width)
 {
    ARAM_ACCESS(port);
    WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
@@ -7030,23 +4128,18 @@ void siwidr(ULONG port, UCHAR width)
    while (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | AUTO_INT))) {}
 }
 
-#endif
-
 
 
 /*---------------------------------------------------------------------
  *
- * Function: sssyncv
+ * Function: FPT_sssyncv
  *
  * Description: Write the desired value to the Sync Register for the
  *              ID specified.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void sssyncv(USHORT p_port, UCHAR p_id, UCHAR p_sync_value,PSCCBMgr_tar_info currTar_Info)
-#else
-void sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,PSCCBMgr_tar_info currTar_Info)
-#endif
+static void FPT_sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,
+			PSCCBMgr_tar_info currTar_Info)
 {
    UCHAR index;
 
@@ -7112,16 +4205,12 @@ void sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,PSCCBMgr_tar_info curr
 
 /*---------------------------------------------------------------------
  *
- * Function: sresb
+ * Function: FPT_sresb
  *
  * Description: Reset the desired card's SCSI bus.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void sresb(USHORT port, UCHAR p_card)
-#else
-void sresb(ULONG port, UCHAR p_card)
-#endif
+static void FPT_sresb(ULONG port, UCHAR p_card)
 {
    UCHAR scsiID, i;
 
@@ -7145,7 +4234,7 @@ void sresb(ULONG port, UCHAR p_card)
 
    WR_HARPOON(port+hp_scsictrl_0, ENA_SCAM_SEL);
 
-   Wait(port, TO_5ms);
+   FPT_Wait(port, TO_5ms);
 
    WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
 
@@ -7153,7 +4242,7 @@ void sresb(ULONG port, UCHAR p_card)
 
    for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++)
       {
-      currTar_Info = &sccbMgrTbl[p_card][scsiID];
+      currTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];
 
       if (currTar_Info->TarEEValue & EE_SYNC_MASK)
          {
@@ -7166,21 +4255,21 @@ void sresb(ULONG port, UCHAR p_card)
       	currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
       	}
 
-      sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
+      FPT_sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
 
-      SccbMgrTableInitTarget(p_card, scsiID);
+      FPT_SccbMgrTableInitTarget(p_card, scsiID);
       }
 
-   BL_Card[p_card].scanIndex = 0x00;
-   BL_Card[p_card].currentSCCB = NULL;
-   BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT 
+   FPT_BL_Card[p_card].scanIndex = 0x00;
+   FPT_BL_Card[p_card].currentSCCB = NULL;
+   FPT_BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT 
 													| F_NEW_SCCB_CMD);
-   BL_Card[p_card].cmdCounter  = 0x00;
-	BL_Card[p_card].discQCount = 0x00;
-   BL_Card[p_card].tagQ_Lst = 0x01; 
+   FPT_BL_Card[p_card].cmdCounter  = 0x00;
+	FPT_BL_Card[p_card].discQCount = 0x00;
+   FPT_BL_Card[p_card].tagQ_Lst = 0x01; 
 
 	for(i = 0; i < QUEUE_DEPTH; i++)
-		BL_Card[p_card].discQ_Tbl[i] = NULL;
+		FPT_BL_Card[p_card].discQ_Tbl[i] = NULL;
 
    WR_HARPOON(port+hp_page_ctrl,
       (RD_HARPOON(port+hp_page_ctrl) & ~G_INT_DISABLE));
@@ -7189,12 +4278,12 @@ void sresb(ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: ssenss
+ * Function: FPT_ssenss
  *
  * Description: Setup for the Auto Sense command.
  *
  *---------------------------------------------------------------------*/
-void ssenss(PSCCBcard pCurrCard)
+static void FPT_ssenss(PSCCBcard pCurrCard)
 {
    UCHAR i;
    PSCCB currSCCB;
@@ -7236,27 +4325,23 @@ void ssenss(PSCCBcard pCurrCard)
 
 /*---------------------------------------------------------------------
  *
- * Function: sxfrp
+ * Function: FPT_sxfrp
  *
  * Description: Transfer data into the bit bucket until the device
  *              decides to switch phase.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void sxfrp(USHORT p_port, UCHAR p_card)
-#else
-void sxfrp(ULONG p_port, UCHAR p_card)
-#endif
+static void FPT_sxfrp(ULONG p_port, UCHAR p_card)
 {
    UCHAR curr_phz;
 
 
    DISABLE_AUTO(p_port);
 
-   if (BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {
+   if (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {
 
-      hostDataXferAbort(p_port,p_card,BL_Card[p_card].currentSCCB);
+      FPT_hostDataXferAbort(p_port,p_card,FPT_BL_Card[p_card].currentSCCB);
 
       }
 
@@ -7322,25 +4407,21 @@ void sxfrp(ULONG p_port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: schkdd
+ * Function: FPT_schkdd
  *
  * Description: Make sure data has been flushed from both FIFOs and abort
  *              the operations if necessary.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void schkdd(USHORT port, UCHAR p_card)
-#else
-void schkdd(ULONG port, UCHAR p_card)
-#endif
+static void FPT_schkdd(ULONG port, UCHAR p_card)
 {
    USHORT TimeOutLoop;
 	UCHAR sPhase;
 
    PSCCB currSCCB;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
 
    if ((currSCCB->Sccb_scsistat != DATA_OUT_ST) &&
@@ -7378,7 +4459,7 @@ void schkdd(ULONG port, UCHAR p_card)
       }
 
 
-   hostDataXferAbort(port,p_card,currSCCB);
+   FPT_hostDataXferAbort(port,p_card,currSCCB);
 
 
    while (RD_HARPOON(port+hp_scsisig) & SCSI_ACK) {}
@@ -7412,21 +4493,21 @@ void schkdd(ULONG port, UCHAR p_card)
 	   if (!(currSCCB->Sccb_XferState & F_ALL_XFERRED))
          {
 	      if (currSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
-	         phaseDataIn(port,p_card);
+	         FPT_phaseDataIn(port,p_card);
 	      	}
 
 	   	else {
-	       phaseDataOut(port,p_card);
+	       FPT_phaseDataOut(port,p_card);
 	       	}
 	   	}
 		else
       	{
-	   	sxfrp(port,p_card);
+	   	FPT_sxfrp(port,p_card);
 	   	if (!(RDW_HARPOON((port+hp_intstat)) &
 		      (BUS_FREE | ICMD_COMP | ITAR_DISC | RESET)))
          {
    		WRW_HARPOON((port+hp_intstat), AUTO_INT);
-		   phaseDecode(port,p_card);
+		   FPT_phaseDecode(port,p_card);
 		   }
 	   }
 
@@ -7440,13 +4521,13 @@ void schkdd(ULONG port, UCHAR p_card)
 
 /*---------------------------------------------------------------------
  *
- * Function: sinits
+ * Function: FPT_sinits
  *
  * Description: Setup SCCB manager fields in this SCCB.
  *
  *---------------------------------------------------------------------*/
 
-void sinits(PSCCB p_sccb, UCHAR p_card)
+static void FPT_sinits(PSCCB p_sccb, UCHAR p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
 
@@ -7454,7 +4535,7 @@ void sinits(PSCCB p_sccb, UCHAR p_card)
 	{
 		return;
 	}
-   currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+   currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
 
    p_sccb->Sccb_XferState     = 0x00;
    p_sccb->Sccb_XferCnt       = p_sccb->DataLength;
@@ -7485,7 +4566,7 @@ void sinits(PSCCB p_sccb, UCHAR p_card)
 	else send Cmd with Disconnect Disable */
 
 /*
-   if (((!(BL_Card[p_card].globalFlags & F_SINGLE_DEVICE)) &&
+   if (((!(FPT_BL_Card[p_card].globalFlags & F_SINGLE_DEVICE)) &&
       (currTar_Info->TarStatus & TAR_ALLOW_DISC)) ||
       (currTar_Info->TarStatus & TAG_Q_TRYING)) {
 */
@@ -7518,55 +4599,6 @@ void sinits(PSCCB p_sccb, UCHAR p_card)
 }
 
 
-#ident "$Id: phase.c 1.11 1997/01/31 02:08:49 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   phase.c  $
- *
- *   Description:  Functions to initially handle the SCSI bus phase when
- *                 the target asserts request (and the automation is not
- *                 enabled to handle the situation).
- *
- *   $Date: 1997/01/31 02:08:49 $
- *
- *   $Revision: 1.11 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <scsi2.h>*/
-/*#include <harpoon.h>*/
-
-
-/*
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-
-#if defined(OS2)
-   extern void (far *s_PhaseTbl[8]) (ULONG, UCHAR);
-#else
-   #if defined(DOS)
-      extern void (*s_PhaseTbl[8]) (USHORT, UCHAR);
-   #else
-      extern void (*s_PhaseTbl[8]) (ULONG, UCHAR);
-   #endif
-#endif
-*/
-
 /*---------------------------------------------------------------------
  *
  * Function: Phase Decode
@@ -7575,29 +4607,17 @@ extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void phaseDecode(USHORT p_port, UCHAR p_card)
-#else
-void phaseDecode(ULONG p_port, UCHAR p_card)
-#endif
+static void FPT_phaseDecode(ULONG p_port, UCHAR p_card)
 {
    unsigned char phase_ref;
-#if defined(OS2)
-   void (far *phase) (ULONG, UCHAR);
-#else
-   #if defined(DOS)
-      void (*phase) (USHORT, UCHAR);
-   #else
-      void (*phase) (ULONG, UCHAR);
-   #endif
-#endif
+   void (*phase) (ULONG, UCHAR);
 
 
    DISABLE_AUTO(p_port);
 
    phase_ref = (UCHAR) (RD_HARPOON(p_port+hp_scsisig) & S_SCSI_PHZ);
 
-   phase = s_PhaseTbl[phase_ref];
+   phase = FPT_s_PhaseTbl[phase_ref];
 
    (*phase)(p_port, p_card);           /* Call the correct phase func */
 }
@@ -7612,20 +4632,12 @@ void phaseDecode(ULONG p_port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseDataOut(ULONG port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseDataOut(USHORT port, UCHAR p_card)
-#else
-void phaseDataOut(ULONG port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseDataOut(ULONG port, UCHAR p_card)
 {
 
    PSCCB currSCCB;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
    if (currSCCB == NULL)
       {
       return;  /* Exit if No SCCB record */
@@ -7640,14 +4652,7 @@ void phaseDataOut(ULONG port, UCHAR p_card)
 
    WR_HARPOON(port+hp_autostart_0, (END_DATA+END_DATA_START));
 
-   dataXferProcessor(port, &BL_Card[p_card]);
-
-#if defined(NOBUGBUG)
-   if (RDW_HARPOON((port+hp_intstat)) & XFER_CNT_0)
-      WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
-
-#endif
-
+   FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
    if (currSCCB->Sccb_XferCnt == 0) {
 
@@ -7656,9 +4661,9 @@ void phaseDataOut(ULONG port, UCHAR p_card)
 	 (currSCCB->HostStatus == SCCB_COMPLETE))
 	 currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
 
-      sxfrp(port,p_card);
+      FPT_sxfrp(port,p_card);
       if (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | RESET)))
-	    phaseDecode(port,p_card);
+	    FPT_phaseDecode(port,p_card);
       }
 }
 
@@ -7671,20 +4676,12 @@ void phaseDataOut(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseDataIn(ULONG port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseDataIn(USHORT port, UCHAR p_card)
-#else
-void phaseDataIn(ULONG port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseDataIn(ULONG port, UCHAR p_card)
 {
 
    PSCCB currSCCB;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
    if (currSCCB == NULL)
       {
@@ -7702,7 +4699,7 @@ void phaseDataIn(ULONG port, UCHAR p_card)
 
    WR_HARPOON(port+hp_autostart_0, (END_DATA+END_DATA_START));
 
-   dataXferProcessor(port, &BL_Card[p_card]);
+   FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
    if (currSCCB->Sccb_XferCnt == 0) {
 
@@ -7711,9 +4708,9 @@ void phaseDataIn(ULONG port, UCHAR p_card)
 	 (currSCCB->HostStatus == SCCB_COMPLETE))
 	 currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
 
-      sxfrp(port,p_card);
+      FPT_sxfrp(port,p_card);
       if (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | RESET)))
-	    phaseDecode(port,p_card);
+	    FPT_phaseDecode(port,p_card);
 
       }
 }
@@ -7726,25 +4723,13 @@ void phaseDataIn(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseCommand(ULONG p_port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseCommand(USHORT p_port, UCHAR p_card)
-#else
-void phaseCommand(ULONG p_port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseCommand(ULONG p_port, UCHAR p_card)
 {
    PSCCB currSCCB;
-#if defined(DOS)
-   USHORT cdb_reg;
-#else
    ULONG cdb_reg;
-#endif
    UCHAR i;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
    if (currSCCB->OperationCode == RESET_COMMAND) {
 
@@ -7790,15 +4775,7 @@ void phaseCommand(ULONG p_port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseStatus(ULONG port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseStatus(USHORT port, UCHAR p_card)
-#else
-void phaseStatus(ULONG port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseStatus(ULONG port, UCHAR p_card)
 {
    /* Start-up the automation to finish off this command and let the
       isr handle the interrupt for command complete when it comes in.
@@ -7820,21 +4797,13 @@ void phaseStatus(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseMsgOut(ULONG port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseMsgOut(USHORT port, UCHAR p_card)
-#else
-void phaseMsgOut(ULONG port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseMsgOut(ULONG port, UCHAR p_card)
 {
 	UCHAR message,scsiID;
 	PSCCB currSCCB;
 	PSCCBMgr_tar_info currTar_Info;
 
-	currSCCB = BL_Card[p_card].currentSCCB;
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
 	if (currSCCB != NULL) {
 
@@ -7845,34 +4814,34 @@ void phaseMsgOut(ULONG port, UCHAR p_card)
 		{
 
 
-			currTar_Info = &sccbMgrTbl[p_card][scsiID];
+			currTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];
 			currTar_Info->TarSyncCtrl = 0;
-			sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
+			FPT_sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
 
-			if (sccbMgrTbl[p_card][scsiID].TarEEValue & EE_SYNC_MASK) 
+			if (FPT_sccbMgrTbl[p_card][scsiID].TarEEValue & EE_SYNC_MASK) 
 			{
 
-				sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_SYNC_MASK;
+				FPT_sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_SYNC_MASK;
 
 			}
 
-			if (sccbMgrTbl[p_card][scsiID].TarEEValue & EE_WIDE_SCSI) 
+			if (FPT_sccbMgrTbl[p_card][scsiID].TarEEValue & EE_WIDE_SCSI) 
 			{
 
-				sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_WIDE_MASK;
+				FPT_sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_WIDE_MASK;
 			}
 
 
-			queueFlushSccb(p_card,SCCB_COMPLETE);
-			SccbMgrTableInitTarget(p_card,scsiID);
+			FPT_queueFlushSccb(p_card,SCCB_COMPLETE);
+			FPT_SccbMgrTableInitTarget(p_card,scsiID);
 		}
 		else if (currSCCB->Sccb_scsistat == ABORT_ST)
 		{
 			currSCCB->HostStatus = SCCB_COMPLETE;
-			if(BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] != NULL)
+			if(FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] != NULL)
 			{
-				BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
-				sccbMgrTbl[p_card][scsiID].TarTagQ_Cnt--;
+				FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+				FPT_sccbMgrTbl[p_card][scsiID].TarTagQ_Cnt--;
 			}
 					
 		}
@@ -7885,7 +4854,7 @@ void phaseMsgOut(ULONG port, UCHAR p_card)
 			{
 				currSCCB->Sccb_MGRFlags |= F_DEV_SELECTED;
 		
-				ssel(port,p_card);
+				FPT_ssel(port,p_card);
 				return;
 			}
 		}
@@ -7895,7 +4864,7 @@ void phaseMsgOut(ULONG port, UCHAR p_card)
 
 			if (message == SMABORT)
 
-				queueFlushSccb(p_card,SCCB_COMPLETE);
+				FPT_queueFlushSccb(p_card,SCCB_COMPLETE);
 		}
 
 	}
@@ -7930,25 +4899,25 @@ void phaseMsgOut(ULONG port, UCHAR p_card)
 			if (currSCCB != NULL) 
 			{
 
-				if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-					((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-					sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+				if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+					((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
 				else
-					sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
 
-				queueCmdComplete(&BL_Card[p_card],currSCCB, p_card);
+				FPT_queueCmdComplete(&FPT_BL_Card[p_card],currSCCB, p_card);
 			}
 
 			else 
 			{
-				BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+				FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 			}
 		}
 
 		else 
 		{
 
-			sxfrp(port,p_card);
+			FPT_sxfrp(port,p_card);
 		}
 	}
 
@@ -7962,7 +4931,7 @@ void phaseMsgOut(ULONG port, UCHAR p_card)
 		}
 		else
 		{
-			sxfrp(port,p_card);
+			FPT_sxfrp(port,p_card);
 		}
 	}
 }
@@ -7976,25 +4945,17 @@ void phaseMsgOut(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseMsgIn(ULONG port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseMsgIn(USHORT port, UCHAR p_card)
-#else
-void phaseMsgIn(ULONG port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseMsgIn(ULONG port, UCHAR p_card)
 {
 	UCHAR message;
 	PSCCB currSCCB;
 
-	currSCCB = BL_Card[p_card].currentSCCB;
+	currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
-	if (BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) 
+	if (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) 
 	{
 
-		phaseChkFifo(port, p_card);
+		FPT_phaseChkFifo(port, p_card);
 	}
 
 	message = RD_HARPOON(port+hp_scsidata_0);
@@ -8008,12 +4969,12 @@ void phaseMsgIn(ULONG port, UCHAR p_card)
 	else 
 	{
 
-		message = sfm(port,currSCCB);
+		message = FPT_sfm(port,currSCCB);
 		if (message) 
 		{
 
 
-			sdecm(message,port,p_card);
+			FPT_sdecm(message,port,p_card);
 
 		}
 		else
@@ -8037,19 +4998,11 @@ void phaseMsgIn(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(OS2)
-void far phaseIllegal(ULONG port, UCHAR p_card)
-#else
-#if defined(DOS)
-void phaseIllegal(USHORT port, UCHAR p_card)
-#else
-void phaseIllegal(ULONG port, UCHAR p_card)
-#endif
-#endif
+static void FPT_phaseIllegal(ULONG port, UCHAR p_card)
 {
    PSCCB currSCCB;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
    WR_HARPOON(port+hp_scsisig, RD_HARPOON(port+hp_scsisig));
    if (currSCCB != NULL) {
@@ -8073,16 +5026,12 @@ void phaseIllegal(ULONG port, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void phaseChkFifo(USHORT port, UCHAR p_card)
-#else
-void phaseChkFifo(ULONG port, UCHAR p_card)
-#endif
+static void FPT_phaseChkFifo(ULONG port, UCHAR p_card)
 {
    ULONG xfercnt;
    PSCCB currSCCB;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
    if (currSCCB->Sccb_scsistat == DATA_IN_ST)
       {
@@ -8104,9 +5053,9 @@ void phaseChkFifo(ULONG port, UCHAR p_card)
 	         WRW_HARPOON((port+hp_intstat), PARITY);
 	         }
 
-	      hostDataXferAbort(port,p_card,currSCCB);
+	      FPT_hostDataXferAbort(port,p_card,currSCCB);
 
-	      dataXferProcessor(port, &BL_Card[p_card]);
+	      FPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);
 
 	      while((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)) &&
 	         (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY)) {}
@@ -8116,22 +5065,7 @@ void phaseChkFifo(ULONG port, UCHAR p_card)
 
 
 
-#if defined(DOS)
-   asm { mov dx,port;
-      add dx,hp_xfercnt_2;
-      in  al,dx;
-      dec dx;
-      xor ah,ah;
-      mov word ptr xfercnt+2,ax;
-      in  al,dx;
-      dec dx;
-      mov ah,al;
-      in  al,dx;
-      mov word ptr xfercnt,ax;
-      }
-#else
    GET_XFER_CNT(port,xfercnt);
-#endif
 
 
    WR_HARPOON(port+hp_xfercnt_0, 0x00);
@@ -8151,7 +5085,7 @@ void phaseChkFifo(ULONG port, UCHAR p_card)
       }
 
 
-   hostDataXferAbort(port,p_card,currSCCB);
+   FPT_hostDataXferAbort(port,p_card,currSCCB);
 
 
    WR_HARPOON(port+hp_fifowrite, 0x00);
@@ -8170,15 +5104,11 @@ void phaseChkFifo(ULONG port, UCHAR p_card)
  *              because of command complete or from a disconnect.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void phaseBusFree(USHORT port, UCHAR p_card)
-#else
-void phaseBusFree(ULONG port, UCHAR p_card)
-#endif
+static void FPT_phaseBusFree(ULONG port, UCHAR p_card)
 {
    PSCCB currSCCB;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
    if (currSCCB != NULL)
       {
@@ -8189,35 +5119,34 @@ void phaseBusFree(ULONG port, UCHAR p_card)
       if (currSCCB->OperationCode == RESET_COMMAND)
          {
 
-			if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	   		 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+			if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	   		 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
 			else
-		   	 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+		   	 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
 
-	      queueCmdComplete(&BL_Card[p_card], currSCCB, p_card);
+	      FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
 
-	      queueSearchSelect(&BL_Card[p_card],p_card);
+	      FPT_queueSearchSelect(&FPT_BL_Card[p_card],p_card);
 
 	      }
 
       else if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
 	      {
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
 			         (UCHAR)SYNC_SUPPORTED;
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
 	      }
 
       else if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
 	      {
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
-		            (sccbMgrTbl[p_card][currSCCB->TargID].
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
+		            (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
 		   TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
 
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
 	      }
 
-#if !defined(DOS)
       else if(currSCCB->Sccb_scsistat == SELECT_Q_ST)
 	      {
 	      /* Make sure this is not a phony BUS_FREE.  If we were
@@ -8227,8 +5156,8 @@ void phaseBusFree(ULONG port, UCHAR p_card)
 	      if ((!(RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ||
 	         (RDW_HARPOON((port+hp_intstat)) & RSEL))
 	         {
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_TAG_Q_MASK;
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |= TAG_Q_REJECT;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_TAG_Q_MASK;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |= TAG_Q_REJECT;
 	         }
 
 	      else
@@ -8236,7 +5165,6 @@ void phaseBusFree(ULONG port, UCHAR p_card)
 	         return;
 	         }
          }
-#endif
 
       else
 	      {
@@ -8248,18 +5176,18 @@ void phaseBusFree(ULONG port, UCHAR p_card)
 	         currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
 	         }
 
-			if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	   		 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+			if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	   		 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
 			else
-		   	 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+		   	 FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
 
-	      queueCmdComplete(&BL_Card[p_card], currSCCB, p_card);
+	      FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
 	      return;
 	      }
 
 
-      BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+      FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
       } /*end if !=null */
 }
@@ -8267,44 +5195,6 @@ void phaseBusFree(ULONG port, UCHAR p_card)
 
 
 
-#ident "$Id: automate.c 1.14 1997/01/31 02:11:46 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   automate.c  $
- *
- *   Description:  Functions relating to programming the automation of
- *                 the HARPOON.
- *
- *   $Date: 1997/01/31 02:11:46 $
- *
- *   $Revision: 1.14 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <scsi2.h>*/
-/*#include <harpoon.h>*/
-
-/*
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-extern SCCBCARD BL_Card[MAX_CARDS];
-*/
-
 /*---------------------------------------------------------------------
  *
  * Function: Auto Load Default Map
@@ -8312,17 +5202,9 @@ extern SCCBCARD BL_Card[MAX_CARDS];
  * Description: Load the Automation RAM with the defualt map values.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void autoLoadDefaultMap(USHORT p_port)
-#else
-void autoLoadDefaultMap(ULONG p_port)
-#endif
+static void FPT_autoLoadDefaultMap(ULONG p_port)
 {
-#if defined(DOS)
-   USHORT map_addr;
-#else
    ULONG map_addr;
-#endif
 
    ARAM_ACCESS(p_port);
    map_addr = p_port + hp_aramBase;
@@ -8428,86 +5310,82 @@ void autoLoadDefaultMap(ULONG p_port)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void autoCmdCmplt(USHORT p_port, UCHAR p_card)
-#else
-void autoCmdCmplt(ULONG p_port, UCHAR p_card)
-#endif
+static void FPT_autoCmdCmplt(ULONG p_port, UCHAR p_card)
 {
    PSCCB currSCCB;
    UCHAR status_byte;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 
    status_byte = RD_HARPOON(p_port+hp_gp_reg_0);
 
-   sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = FALSE;
+   FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = 0;
 
    if (status_byte != SSGOOD) {
 
       if (status_byte == SSQ_FULL) {
 
 
-			if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+			if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 			{
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
-				if(BL_Card[p_card].discQCount != 0)
-					BL_Card[p_card].discQCount--;
-				BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
+				if(FPT_BL_Card[p_card].discQCount != 0)
+					FPT_BL_Card[p_card].discQCount--;
+				FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
 			}
 			else
 			{
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
 				if(currSCCB->Sccb_tag)
 				{
-					if(BL_Card[p_card].discQCount != 0)
-						BL_Card[p_card].discQCount--;
-					BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+					if(FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
 				}else
 				{
-					if(BL_Card[p_card].discQCount != 0)
-						BL_Card[p_card].discQCount--;
-					BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+					if(FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
 				}
 			}
 
          currSCCB->Sccb_MGRFlags |= F_STATUSLOADED;
 
-         queueSelectFail(&BL_Card[p_card],p_card);
+         FPT_queueSelectFail(&FPT_BL_Card[p_card],p_card);
 
          return;
          }
 
       if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
          {
-         sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
+         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
             (UCHAR)SYNC_SUPPORTED;
 
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
-         BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
+         FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
-			if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+			if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 			{
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
-				if(BL_Card[p_card].discQCount != 0)
-					BL_Card[p_card].discQCount--;
-				BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
+				if(FPT_BL_Card[p_card].discQCount != 0)
+					FPT_BL_Card[p_card].discQCount--;
+				FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
 			}
 			else
 			{
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
 				if(currSCCB->Sccb_tag)
 				{
-					if(BL_Card[p_card].discQCount != 0)
-						BL_Card[p_card].discQCount--;
-					BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+					if(FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
 				}else
 				{
-					if(BL_Card[p_card].discQCount != 0)
-						BL_Card[p_card].discQCount--;
-					BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+					if(FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
 				}
 			}
          return;
@@ -8517,34 +5395,34 @@ void autoCmdCmplt(ULONG p_port, UCHAR p_card)
       if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
          {
 
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
-	         (sccbMgrTbl[p_card][currSCCB->TargID].
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
+	         (FPT_sccbMgrTbl[p_card][currSCCB->TargID].
 	         TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
 
-	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
-         BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+	      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
+         FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
-			if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+			if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 			{
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
-				if(BL_Card[p_card].discQCount != 0)
-					BL_Card[p_card].discQCount--;
-				BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
+				if(FPT_BL_Card[p_card].discQCount != 0)
+					FPT_BL_Card[p_card].discQCount--;
+				FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
 			}
 			else
 			{
-	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+	         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
 				if(currSCCB->Sccb_tag)
 				{
-					if(BL_Card[p_card].discQCount != 0)
-						BL_Card[p_card].discQCount--;
-					BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+					if(FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
 				}else
 				{
-					if(BL_Card[p_card].discQCount != 0)
-						BL_Card[p_card].discQCount--;
-					BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+					if(FPT_BL_Card[p_card].discQCount != 0)
+						FPT_BL_Card[p_card].discQCount--;
+					FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
 				}
 			}
          return;
@@ -8553,15 +5431,15 @@ void autoCmdCmplt(ULONG p_port, UCHAR p_card)
      
 	   if (status_byte == SSCHECK) 
 		{
-			if(BL_Card[p_card].globalFlags & F_DO_RENEGO)
+			if(FPT_BL_Card[p_card].globalFlags & F_DO_RENEGO)
 			{
-				if (sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_SYNC_MASK)
+				if (FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_SYNC_MASK)
 				{
-					sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_SYNC_MASK;
+					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_SYNC_MASK;
 				}
-				if (sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_WIDE_SCSI)
+				if (FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_WIDE_SCSI)
 				{
-					sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_WIDE_MASK;
+					FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_WIDE_MASK;
 				}
 			}
 		}
@@ -8573,135 +5451,61 @@ void autoCmdCmplt(ULONG p_port, UCHAR p_card)
 
          if (status_byte == SSCHECK) {
 
-            sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA
-               = TRUE;
+            FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA
+               = 1;
      
 
-#if (FW_TYPE==_SCCB_MGR_)
             if (currSCCB->RequestSenseLength != NO_AUTO_REQUEST_SENSE) {
 
                if (currSCCB->RequestSenseLength == 0)
                   currSCCB->RequestSenseLength = 14;
 
-               ssenss(&BL_Card[p_card]);
-               BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+               FPT_ssenss(&FPT_BL_Card[p_card]);
+               FPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
 
- 					if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-						((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+ 					if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+						((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 					{
-			         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
-						if(BL_Card[p_card].discQCount != 0)
-							BL_Card[p_card].discQCount--;
-						BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+			         FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 1;
+						if(FPT_BL_Card[p_card].discQCount != 0)
+							FPT_BL_Card[p_card].discQCount--;
+						FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
 					}
 					else
 					{
-	   		      sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+	   		      FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 1;
 						if(currSCCB->Sccb_tag)
 						{
-							if(BL_Card[p_card].discQCount != 0)
-								BL_Card[p_card].discQCount--;
-							BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+							if(FPT_BL_Card[p_card].discQCount != 0)
+								FPT_BL_Card[p_card].discQCount--;
+							FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
 						}else
 						{
-							if(BL_Card[p_card].discQCount != 0)
-								BL_Card[p_card].discQCount--;
-							BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+							if(FPT_BL_Card[p_card].discQCount != 0)
+								FPT_BL_Card[p_card].discQCount--;
+							FPT_BL_Card[p_card].discQ_Tbl[FPT_sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
 						}
 					}
                return;
                }
-#else
-				   if ((!(currSCCB->Sccb_ucb_ptr->UCB_opcode & OPC_NO_AUTO_SENSE)) &&
-			   		(currSCCB->RequestSenseLength))
-				   {
-				   	ssenss(&BL_Card[p_card]);
-				      BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
-
-						if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-							((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-						{
-	      			   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
-							if(BL_Card[p_card].discQCount != 0)
-								BL_Card[p_card].discQCount--;
-							BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
-						}
-						else
-						{
-	      			   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
-							if(currSCCB->Sccb_tag)
-							{
-								if(BL_Card[p_card].discQCount != 0)
-									BL_Card[p_card].discQCount--;
-								BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
-							}else
-							{
-								if(BL_Card[p_card].discQCount != 0)
-									BL_Card[p_card].discQCount--;
-								BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
-							}
-						}
-				      return;
-				   }
-
-#endif
             }
          }
       }
 
 
-	if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
-		((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
-	   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+	if((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+		((FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	   FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = 0;
 	else
-	   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+	   FPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;
 
 
-   queueCmdComplete(&BL_Card[p_card], currSCCB, p_card);
+   FPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);
 }
-#ident "$Id: busmstr.c 1.8 1997/01/31 02:10:27 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   busmstr.c  $
- *
- *   Description:  Functions to start, stop, and abort BusMaster operations.
- *
- *   $Date: 1997/01/31 02:10:27 $
- *
- *   $Revision: 1.8 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <scsi2.h>*/
-/*#include <harpoon.h>*/
-
-
-/*
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-*/
 
 #define SHORT_WAIT   0x0000000F
 #define LONG_WAIT    0x0000FFFFL
 
-#if defined(BUGBUG)
-void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
-#endif
 
 /*---------------------------------------------------------------------
  *
@@ -8721,11 +5525,7 @@ void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
  *              
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void dataXferProcessor(USHORT port, PSCCBcard pCurrCard)
-#else
-void dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
-#endif
+static void FPT_dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
 {
    PSCCB currSCCB;
 
@@ -8741,7 +5541,7 @@ void dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
  				}
 			pCurrCard->globalFlags |= F_HOST_XFER_ACT;
          
-         busMstrSGDataXferStart(port, currSCCB);
+         FPT_busMstrSGDataXferStart(port, currSCCB);
 			}
 
       else
@@ -8750,7 +5550,7 @@ void dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
 				{
 				pCurrCard->globalFlags |= F_HOST_XFER_ACT;
          
-         	busMstrDataXferStart(port, currSCCB);
+         	FPT_busMstrDataXferStart(port, currSCCB);
          	}
 			}
 }
@@ -8763,20 +5563,12 @@ void dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
  * Description:
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void busMstrSGDataXferStart(USHORT p_port, PSCCB pcurrSCCB)
-#else
-void busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
-#endif
+static void FPT_busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 {
    ULONG count,addr,tmpSGCnt;
    UINT sg_index;
    UCHAR sg_count, i;
-#if defined(DOS)
-   USHORT reg_offset;
-#else
    ULONG reg_offset;
-#endif
 
 
    if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
@@ -8802,17 +5594,6 @@ void busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
    while ((sg_count < (UCHAR)SG_BUF_CNT) &&
       ((ULONG)(sg_index * (UINT)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
 
-#if defined(COMPILER_16_BIT) && !defined(DOS)
-      tmpSGCnt += *(((ULONG far *)pcurrSCCB->DataPointer)+
-         (sg_index * 2));
-
-      count |= *(((ULONG far *)pcurrSCCB->DataPointer)+
-         (sg_index * 2));
-
-      addr = *(((ULONG far *)pcurrSCCB->DataPointer)+
-         ((sg_index * 2) + 1));
-
-#else
       tmpSGCnt += *(((ULONG *)pcurrSCCB->DataPointer)+
          (sg_index * 2));
 
@@ -8821,7 +5602,6 @@ void busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 
       addr = *(((ULONG *)pcurrSCCB->DataPointer)+
          ((sg_index * 2) + 1));
-#endif
 
 
       if ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {
@@ -8888,11 +5668,7 @@ void busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
  * Description: 
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void busMstrDataXferStart(USHORT p_port, PSCCB pcurrSCCB)
-#else
-void busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
-#endif
+static void FPT_busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 {
    ULONG addr,count;
 
@@ -8909,37 +5685,7 @@ void busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
 
       }
 
-#if defined(DOS)
-   asm { mov dx,p_port;
-         mov ax,word ptr count;
-         add dx,hp_xfer_cnt_lo;
-         out dx,al;
-         inc dx;
-         xchg ah,al
-         out dx,al;
-         inc dx;
-         mov ax,word ptr count+2;
-         out dx,al;
-         inc dx;
-         inc dx;
-         mov ax,word ptr addr;
-         out dx,al;
-         inc dx;
-         xchg ah,al
-         out dx,al;
-         inc dx;
-         mov ax,word ptr addr+2;
-         out dx,al;
-         inc dx;
-         xchg ah,al
-         out dx,al;
-         }
-
-   WR_HARP32(p_port,hp_xfercnt_0,count);
-
-#else
    HP_SETUP_ADDR_CNT(p_port,addr,count);
-#endif
 
 
    if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
@@ -8975,11 +5721,7 @@ void busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
  *               command busy is also time out, it'll just give up.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-UCHAR busMstrTimeOut(USHORT p_port)
-#else
-UCHAR busMstrTimeOut(ULONG p_port)
-#endif
+static UCHAR FPT_busMstrTimeOut(ULONG p_port)
 {
    ULONG timeout;
 
@@ -9001,11 +5743,11 @@ UCHAR busMstrTimeOut(ULONG p_port)
    RD_HARPOON(p_port+hp_int_status);           /*Clear command complete */
 
    if (RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) {
-      return(TRUE);
+      return(1);
       }
 
    else {
-      return(FALSE);
+      return(0);
       }
 }
 
@@ -9017,18 +5759,14 @@ UCHAR busMstrTimeOut(ULONG p_port)
  * Description: Abort any in progress transfer.
  *
  *---------------------------------------------------------------------*/
-#if defined(DOS)
-void hostDataXferAbort(USHORT port, UCHAR p_card, PSCCB pCurrSCCB)
-#else
-void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
-#endif
+static void FPT_hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 {
 
    ULONG timeout;
    ULONG remain_cnt;
    UINT sg_ptr;
 
-   BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
+   FPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
 
    if (pCurrSCCB->Sccb_XferState & F_AUTO_SENSE) {
 
@@ -9044,7 +5782,7 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 
          if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
 
-            if (busMstrTimeOut(port)) {
+            if (FPT_busMstrTimeOut(port)) {
 
                if (pCurrSCCB->HostStatus == 0x00)
 
@@ -9060,10 +5798,6 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 
                      {
                      pCurrSCCB->HostStatus = SCCB_BM_ERR;
-#if defined(BUGBUG)
-                     WR_HARPOON(port+hp_dual_addr_lo,
-                        RD_HARPOON(port+hp_ext_status));
-#endif
                      }
             }
          }
@@ -9092,22 +5826,12 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 
             sg_ptr--;
 
-#if defined(COMPILER_16_BIT) && !defined(DOS)
-            if (remain_cnt > (ULONG)(*(((ULONG far *)pCurrSCCB->
-               DataPointer) + (sg_ptr * 2)))) {
-
-               remain_cnt -= (ULONG)(*(((ULONG far *)pCurrSCCB->
-                  DataPointer) + (sg_ptr * 2)));
-               }
-
-#else
             if (remain_cnt > (ULONG)(*(((ULONG *)pCurrSCCB->
                DataPointer) + (sg_ptr * 2)))) {
 
                remain_cnt -= (ULONG)(*(((ULONG *)pCurrSCCB->
                   DataPointer) + (sg_ptr * 2)));
                }
-#endif
 
             else {
 
@@ -9147,7 +5871,7 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
 
          if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
 
-            busMstrTimeOut(port);
+            FPT_busMstrTimeOut(port);
             }
 
          else {
@@ -9159,10 +5883,6 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
                   if (pCurrSCCB->HostStatus == 0x00) {
 
                      pCurrSCCB->HostStatus = SCCB_BM_ERR;
-#if defined(BUGBUG)
-                     WR_HARPOON(port+hp_dual_addr_lo,
-                        RD_HARPOON(port+hp_ext_status));
-#endif
                      }
                   }
                }
@@ -9203,7 +5923,7 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
                   pCurrSCCB->HostStatus = SCCB_BM_ERR;
                   }
 
-               busMstrTimeOut(port);
+               FPT_busMstrTimeOut(port);
                }
             }
 
@@ -9214,10 +5934,6 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
                if (pCurrSCCB->HostStatus == 0x00) {
 
                   pCurrSCCB->HostStatus = SCCB_BM_ERR;
-#if defined(BUGBUG)
-                  WR_HARPOON(port+hp_dual_addr_lo,
-                     RD_HARPOON(port+hp_ext_status));
-#endif
                   }
                }
             }
@@ -9241,7 +5957,7 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
                pCurrSCCB->HostStatus = SCCB_BM_ERR;
                }
 
-            busMstrTimeOut(port);
+            FPT_busMstrTimeOut(port);
             }
          }
 
@@ -9253,10 +5969,6 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
             if (pCurrSCCB->HostStatus == 0x00) {
 
                pCurrSCCB->HostStatus = SCCB_BM_ERR;
-#if defined(BUGBUG)
-               WR_HARPOON(port+hp_dual_addr_lo,
-                  RD_HARPOON(port+hp_ext_status));
-#endif
                }
             }
 
@@ -9305,15 +6017,11 @@ void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
  *              pointers message.
  *
  *---------------------------------------------------------------------*/
-void hostDataXferRestart(PSCCB currSCCB)
+static void FPT_hostDataXferRestart(PSCCB currSCCB)
 {
    ULONG data_count;
    UINT  sg_index;
-#if defined(COMPILER_16_BIT) && !defined(DOS)
-   ULONG far *sg_ptr;
-#else
    ULONG *sg_ptr;
-#endif
 
    if (currSCCB->Sccb_XferState & F_SG_XFER) {
 
@@ -9322,11 +6030,7 @@ void hostDataXferRestart(PSCCB currSCCB)
       sg_index = 0xffff;         /*Index by long words into sg list. */
       data_count = 0;            /*Running count of SG xfer counts. */
 
-#if defined(COMPILER_16_BIT) && !defined(DOS)
-      sg_ptr = (ULONG far *)currSCCB->DataPointer;
-#else
       sg_ptr = (ULONG *)currSCCB->DataPointer;
-#endif
 
       while (data_count < currSCCB->Sccb_ATC) {
 
@@ -9351,78 +6055,28 @@ void hostDataXferRestart(PSCCB currSCCB)
       currSCCB->Sccb_XferCnt = currSCCB->DataLength - currSCCB->Sccb_ATC;
       }
 }
-#ident "$Id: scam.c 1.17 1997/03/20 23:49:37 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   scam.c  $
- *
- *   Description:  Functions relating to handling of the SCAM selection
- *                 and the determination of the SCSI IDs to be assigned
- *                 to all perspective SCSI targets.
- *
- *   $Date: 1997/03/20 23:49:37 $
- *
- *   $Revision: 1.17 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <scsi2.h>*/
-/*#include <eeprom.h>*/
-/*#include <harpoon.h>*/
 
 
 
-/*
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBSCAM_INFO scamInfo[MAX_SCSI_TAR];
-extern NVRAMINFO nvRamInfo[MAX_MB_CARDS];
-#if defined(DOS) || defined(OS2)
-extern UCHAR temp_id_string[ID_STRING_LENGTH];
-#endif
-extern UCHAR scamHAString[];
-*/
 /*---------------------------------------------------------------------
  *
- * Function: scini
+ * Function: FPT_scini
  *
  * Description: Setup all data structures necessary for SCAM selection.
  *
  *---------------------------------------------------------------------*/
 
-void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
+static void FPT_scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
 {
 
-#if defined(SCAM_LEV_2)
    UCHAR loser,assigned_id;
-#endif
-#if defined(DOS)
-
-   USHORT p_port;
-#else
    ULONG p_port;
-#endif
 
    UCHAR i,k,ScamFlg ;
    PSCCBcard currCard;
 	PNVRamInfo pCurrNvRam;
 
-   currCard = &BL_Card[p_card];
+   currCard = &FPT_BL_Card[p_card];
    p_port = currCard->ioPort;
 	pCurrNvRam = currCard->pNvRamInfo;
 
@@ -9432,72 +6086,68 @@ void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
 		i = pCurrNvRam->niSysConf;
 	}
 	else{
-	   ScamFlg = (UCHAR) utilEERead(p_port, SCAM_CONFIG/2);
-	   i = (UCHAR)(utilEERead(p_port, (SYSTEM_CONFIG/2)));
+	   ScamFlg = (UCHAR) FPT_utilEERead(p_port, SCAM_CONFIG/2);
+	   i = (UCHAR)(FPT_utilEERead(p_port, (SYSTEM_CONFIG/2)));
 	}
 	if(!(i & 0x02))	/* check if reset bus in AutoSCSI parameter set */
 		return;
 
-   inisci(p_card,p_port, p_our_id);
+   FPT_inisci(p_card,p_port, p_our_id);
 
    /* Force to wait 1 sec after SCSI bus reset. Some SCAM device FW
       too slow to return to SCAM selection */
 
    /* if (p_power_up)
-         Wait1Second(p_port);
+         FPT_Wait1Second(p_port);
       else
-         Wait(p_port, TO_250ms); */
-
-   Wait1Second(p_port);
+         FPT_Wait(p_port, TO_250ms); */
 
-#if defined(SCAM_LEV_2)
+   FPT_Wait1Second(p_port);
 
    if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
       {
-      while (!(scarb(p_port,INIT_SELTD))) {}
+      while (!(FPT_scarb(p_port,INIT_SELTD))) {}
 
-      scsel(p_port);
+      FPT_scsel(p_port);
 
       do {
-         scxferc(p_port,SYNC_PTRN);
-         scxferc(p_port,DOM_MSTR);
-         loser = scsendi(p_port,&scamInfo[p_our_id].id_string[0]);
+         FPT_scxferc(p_port,SYNC_PTRN);
+         FPT_scxferc(p_port,DOM_MSTR);
+         loser = FPT_scsendi(p_port,&FPT_scamInfo[p_our_id].id_string[0]);
          } while ( loser == 0xFF );
 
-      scbusf(p_port);
+      FPT_scbusf(p_port);
 
       if ((p_power_up) && (!loser))
          {
-         sresb(p_port,p_card);
-         Wait(p_port, TO_250ms);
+         FPT_sresb(p_port,p_card);
+         FPT_Wait(p_port, TO_250ms);
 
-         while (!(scarb(p_port,INIT_SELTD))) {}
+         while (!(FPT_scarb(p_port,INIT_SELTD))) {}
 
-         scsel(p_port);
+         FPT_scsel(p_port);
 
          do {
-            scxferc(p_port, SYNC_PTRN);
-            scxferc(p_port, DOM_MSTR);
-            loser = scsendi(p_port,&scamInfo[p_our_id].
+            FPT_scxferc(p_port, SYNC_PTRN);
+            FPT_scxferc(p_port, DOM_MSTR);
+            loser = FPT_scsendi(p_port,&FPT_scamInfo[p_our_id].
                id_string[0]);
             } while ( loser == 0xFF );
 
-         scbusf(p_port);
+         FPT_scbusf(p_port);
          }
       }
 
    else
       {
-      loser = FALSE;
+      loser = 0;
       }
 
 
    if (!loser)
       {
 
-#endif  /* SCAM_LEV_2 */
-
-      scamInfo[p_our_id].state = ID_ASSIGNED;
+      FPT_scamInfo[p_our_id].state = ID_ASSIGNED;
 
 
 		if (ScamFlg & SCAM_ENABLED)
@@ -9505,18 +6155,18 @@ void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
 
 	      for (i=0; i < MAX_SCSI_TAR; i++)
   		   {
-      	   if ((scamInfo[i].state == ID_UNASSIGNED) ||
-  	      	   (scamInfo[i].state == ID_UNUSED))
+      	   if ((FPT_scamInfo[i].state == ID_UNASSIGNED) ||
+  	      	   (FPT_scamInfo[i].state == ID_UNUSED))
 	  	      {
-   	     	   if (scsell(p_port,i))
+   	     	   if (FPT_scsell(p_port,i))
       	  	   {
-            	   scamInfo[i].state = LEGACY;
-  	            	if ((scamInfo[i].id_string[0] != 0xFF) ||
-     	            	(scamInfo[i].id_string[1] != 0xFA))
+            	   FPT_scamInfo[i].state = LEGACY;
+  	            	if ((FPT_scamInfo[i].id_string[0] != 0xFF) ||
+     	            	(FPT_scamInfo[i].id_string[1] != 0xFA))
 	     	         {
 
-   	        	      scamInfo[i].id_string[0] = 0xFF;
-      	        	   scamInfo[i].id_string[1] = 0xFA;
+   	        	      FPT_scamInfo[i].id_string[0] = 0xFF;
+      	        	   FPT_scamInfo[i].id_string[1] = 0xFA;
 							if(pCurrNvRam == NULL)
 	         	         currCard->globalFlags |= F_UPDATE_EEPROM;
                	}
@@ -9524,45 +6174,43 @@ void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
    	  	   }
       	}
 
-	      sresb(p_port,p_card);
-      	Wait1Second(p_port);
-         while (!(scarb(p_port,INIT_SELTD))) {}
-         scsel(p_port);
-         scasid(p_card, p_port);
+	      FPT_sresb(p_port,p_card);
+      	FPT_Wait1Second(p_port);
+         while (!(FPT_scarb(p_port,INIT_SELTD))) {}
+         FPT_scsel(p_port);
+         FPT_scasid(p_card, p_port);
          }
 
-#if defined(SCAM_LEV_2)
-
       }
 
    else if ((loser) && (ScamFlg & SCAM_ENABLED))
       {
-      scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;
-      assigned_id = FALSE;
-      scwtsel(p_port);
+      FPT_scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;
+      assigned_id = 0;
+      FPT_scwtsel(p_port);
 
       do {
-         while (scxferc(p_port,0x00) != SYNC_PTRN) {}
+         while (FPT_scxferc(p_port,0x00) != SYNC_PTRN) {}
 
-         i = scxferc(p_port,0x00);
+         i = FPT_scxferc(p_port,0x00);
          if (i == ASSIGN_ID)
             {
-            if (!(scsendi(p_port,&scamInfo[p_our_id].id_string[0])))
+            if (!(FPT_scsendi(p_port,&FPT_scamInfo[p_our_id].id_string[0])))
                   {
-                  i = scxferc(p_port,0x00);
-                  if (scvalq(i))
+                  i = FPT_scxferc(p_port,0x00);
+                  if (FPT_scvalq(i))
                      {
-                     k = scxferc(p_port,0x00);
+                     k = FPT_scxferc(p_port,0x00);
 
-                     if (scvalq(k))
+                     if (FPT_scvalq(k))
                         {
                         currCard->ourId =
                            ((UCHAR)(i<<3)+(k & (UCHAR)7)) & (UCHAR) 0x3F;
-                        inisci(p_card, p_port, p_our_id);
-                        scamInfo[currCard->ourId].state = ID_ASSIGNED;
-                        scamInfo[currCard->ourId].id_string[0]
+                        FPT_inisci(p_card, p_port, p_our_id);
+                        FPT_scamInfo[currCard->ourId].state = ID_ASSIGNED;
+                        FPT_scamInfo[currCard->ourId].id_string[0]
                            = SLV_TYPE_CODE0;
-                        assigned_id = TRUE;
+                        assigned_id = 1;
                         }
                      }
                   }
@@ -9570,43 +6218,31 @@ void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
 
          else if (i == SET_P_FLAG)
             {
-               if (!(scsendi(p_port,
-                        &scamInfo[p_our_id].id_string[0])))
-                        scamInfo[p_our_id].id_string[0] |= 0x80;
+               if (!(FPT_scsendi(p_port,
+                        &FPT_scamInfo[p_our_id].id_string[0])))
+                        FPT_scamInfo[p_our_id].id_string[0] |= 0x80;
             }
          }while (!assigned_id);
 
-      while (scxferc(p_port,0x00) != CFG_CMPLT) {}
+      while (FPT_scxferc(p_port,0x00) != CFG_CMPLT) {}
       }
 
-#endif   /* SCAM_LEV_2 */
    if (ScamFlg & SCAM_ENABLED)
       {
-      scbusf(p_port);
+      FPT_scbusf(p_port);
       if (currCard->globalFlags & F_UPDATE_EEPROM)
          {
-         scsavdi(p_card, p_port);
+         FPT_scsavdi(p_card, p_port);
          currCard->globalFlags &= ~F_UPDATE_EEPROM;
          }
       }
 
 
-#if defined(DOS)
-   for (i=0; i < MAX_SCSI_TAR; i++)
-   {
-     	if (((ScamFlg & SCAM_ENABLED) && (scamInfo[i].state == LEGACY))
-			|| (i != p_our_id))
-        	{
-         scsellDOS(p_port,i);
-  	      }
-  	}
-#endif
-
 /*
    for (i=0,k=0; i < MAX_SCSI_TAR; i++)
       {
-      if ((scamInfo[i].state == ID_ASSIGNED) ||
-         (scamInfo[i].state == LEGACY))
+      if ((FPT_scamInfo[i].state == ID_ASSIGNED) ||
+         (FPT_scamInfo[i].state == LEGACY))
          k++;
       }
 
@@ -9620,17 +6256,13 @@ void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
 
 /*---------------------------------------------------------------------
  *
- * Function: scarb
+ * Function: FPT_scarb
  *
  * Description: Gain control of the bus and wait SCAM select time (250ms)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-int scarb(USHORT p_port, UCHAR p_sel_type)
-#else
-int scarb(ULONG p_port, UCHAR p_sel_type)
-#endif
+static int FPT_scarb(ULONG p_port, UCHAR p_sel_type)
 {
    if (p_sel_type == INIT_SELTD)
       {
@@ -9639,10 +6271,10 @@ int scarb(ULONG p_port, UCHAR p_sel_type)
 
 
       if (RD_HARPOON(p_port+hp_scsisig) & SCSI_SEL)
-         return(FALSE);
+         return(0);
 
       if (RD_HARPOON(p_port+hp_scsidata_0) != 00)
-         return(FALSE);
+         return(0);
 
       WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_BSY));
 
@@ -9650,7 +6282,7 @@ int scarb(ULONG p_port, UCHAR p_sel_type)
 
          WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) &
             ~SCSI_BSY));
-         return(FALSE);
+         return(0);
          }
 
 
@@ -9660,7 +6292,7 @@ int scarb(ULONG p_port, UCHAR p_sel_type)
 
          WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) &
             ~(SCSI_BSY | SCSI_SEL)));
-         return(FALSE);
+         return(0);
          }
       }
 
@@ -9669,9 +6301,7 @@ int scarb(ULONG p_port, UCHAR p_sel_type)
       & ~ACTdeassert));
    WR_HARPOON(p_port+hp_scsireset, SCAM_EN);
    WR_HARPOON(p_port+hp_scsidata_0, 0x00);
-#if defined(WIDE_SCSI)
    WR_HARPOON(p_port+hp_scsidata_1, 0x00);
-#endif
    WR_HARPOON(p_port+hp_portctrl_0, SCSI_BUS_EN);
 
    WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_MSG));
@@ -9679,25 +6309,21 @@ int scarb(ULONG p_port, UCHAR p_sel_type)
    WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig)
       & ~SCSI_BSY));
 
-   Wait(p_port,TO_250ms);
+   FPT_Wait(p_port,TO_250ms);
 
-   return(TRUE);
+   return(1);
 }
 
 
 /*---------------------------------------------------------------------
  *
- * Function: scbusf
+ * Function: FPT_scbusf
  *
  * Description: Release the SCSI bus and disable SCAM selection.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scbusf(USHORT p_port)
-#else
-void scbusf(ULONG p_port)
-#endif
+static void FPT_scbusf(ULONG p_port)
 {
    WR_HARPOON(p_port+hp_page_ctrl,
       (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
@@ -9717,11 +6343,7 @@ void scbusf(ULONG p_port)
    WR_HARPOON(p_port+hp_clkctrl_0, (RD_HARPOON(p_port+hp_clkctrl_0)
       | ACTdeassert));
 
-#if defined(SCAM_LEV_2)
    WRW_HARPOON((p_port+hp_intstat), (BUS_FREE | AUTO_INT | SCAM_SEL));
-#else
-   WRW_HARPOON((p_port+hp_intstat), (BUS_FREE | AUTO_INT));
-#endif
 
    WR_HARPOON(p_port+hp_page_ctrl,
       (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
@@ -9731,35 +6353,24 @@ void scbusf(ULONG p_port)
 
 /*---------------------------------------------------------------------
  *
- * Function: scasid
+ * Function: FPT_scasid
  *
  * Description: Assign an ID to all the SCAM devices.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scasid(UCHAR p_card, USHORT p_port)
-#else
-void scasid(UCHAR p_card, ULONG p_port)
-#endif
+static void FPT_scasid(UCHAR p_card, ULONG p_port)
 {
-#if defined(DOS) || defined(OS2)
-   /* Use external defined in global space area, instead of Stack
-      space. WIN/95 DOS doesnot work TINY mode. The OS doesnot intialize
-      SS equal to DS. Thus the array allocated on stack doesnot get
-      access correctly */
-#else
    UCHAR temp_id_string[ID_STRING_LENGTH];
-#endif
 
    UCHAR i,k,scam_id;
 	UCHAR crcBytes[3];
 	PNVRamInfo pCurrNvRam;
 	ushort_ptr pCrcBytes;
 
-	pCurrNvRam = BL_Card[p_card].pNvRamInfo;
+	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
 
-   i=FALSE;
+   i=0;
 
    while (!i)
       {
@@ -9769,36 +6380,36 @@ void scasid(UCHAR p_card, ULONG p_port)
          temp_id_string[k] = (UCHAR) 0x00;
          }
 
-      scxferc(p_port,SYNC_PTRN);
-      scxferc(p_port,ASSIGN_ID);
+      FPT_scxferc(p_port,SYNC_PTRN);
+      FPT_scxferc(p_port,ASSIGN_ID);
 
-      if (!(sciso(p_port,&temp_id_string[0])))
+      if (!(FPT_sciso(p_port,&temp_id_string[0])))
          {
 			if(pCurrNvRam){
 				pCrcBytes = (ushort_ptr)&crcBytes[0];
-				*pCrcBytes = CalcCrc16(&temp_id_string[0]);
-				crcBytes[2] = CalcLrc(&temp_id_string[0]);
+				*pCrcBytes = FPT_CalcCrc16(&temp_id_string[0]);
+				crcBytes[2] = FPT_CalcLrc(&temp_id_string[0]);
 				temp_id_string[1] = crcBytes[2];
 				temp_id_string[2] = crcBytes[0];
 				temp_id_string[3] = crcBytes[1];
 				for(k = 4; k < ID_STRING_LENGTH; k++)
 					temp_id_string[k] = (UCHAR) 0x00;
 			}
-         i = scmachid(p_card,temp_id_string);
+         i = FPT_scmachid(p_card,temp_id_string);
 
          if (i == CLR_PRIORITY)
             {
-            scxferc(p_port,MISC_CODE);
-            scxferc(p_port,CLR_P_FLAG);
-            i = FALSE;  /*Not the last ID yet. */
+            FPT_scxferc(p_port,MISC_CODE);
+            FPT_scxferc(p_port,CLR_P_FLAG);
+            i = 0;  /*Not the last ID yet. */
             }
 
          else if (i != NO_ID_AVAIL)
             {
             if (i < 8 )
-               scxferc(p_port,ID_0_7);
+               FPT_scxferc(p_port,ID_0_7);
             else
-               scxferc(p_port,ID_8_F);
+               FPT_scxferc(p_port,ID_8_F);
 
             scam_id = (i & (UCHAR) 0x07);
 
@@ -9807,21 +6418,21 @@ void scasid(UCHAR p_card, ULONG p_port)
                if (!( k & i ))
                   scam_id += 0x08;        /*Count number of zeros in DB0-3. */
 
-            scxferc(p_port,scam_id);
+            FPT_scxferc(p_port,scam_id);
 
-            i = FALSE;  /*Not the last ID yet. */
+            i = 0;  /*Not the last ID yet. */
             }
          }
 
       else
          {
-         i = TRUE;
+         i = 1;
          }
 
       }  /*End while */
 
-   scxferc(p_port,SYNC_PTRN);
-   scxferc(p_port,CFG_CMPLT);
+   FPT_scxferc(p_port,SYNC_PTRN);
+   FPT_scxferc(p_port,CFG_CMPLT);
 }
 
 
@@ -9830,21 +6441,17 @@ void scasid(UCHAR p_card, ULONG p_port)
 
 /*---------------------------------------------------------------------
  *
- * Function: scsel
+ * Function: FPT_scsel
  *
  * Description: Select all the SCAM devices.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scsel(USHORT p_port)
-#else
-void scsel(ULONG p_port)
-#endif
+static void FPT_scsel(ULONG p_port)
 {
 
    WR_HARPOON(p_port+hp_scsisig, SCSI_SEL);
-   scwiros(p_port, SCSI_MSG);
+   FPT_scwiros(p_port, SCSI_MSG);
 
    WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY));
 
@@ -9855,11 +6462,11 @@ void scsel(ULONG p_port)
 
 
    WR_HARPOON(p_port+hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));
-   scwiros(p_port, SCSI_SEL);
+   FPT_scwiros(p_port, SCSI_SEL);
 
    WR_HARPOON(p_port+hp_scsidata_0, (UCHAR)(RD_HARPOON(p_port+hp_scsidata_0) &
       ~(UCHAR)BIT(6)));
-   scwirod(p_port, BIT(6));
+   FPT_scwirod(p_port, BIT(6));
 
    WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
 }
@@ -9868,17 +6475,13 @@ void scsel(ULONG p_port)
 
 /*---------------------------------------------------------------------
  *
- * Function: scxferc
+ * Function: FPT_scxferc
  *
  * Description: Handshake the p_data (DB4-0) across the bus.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-UCHAR scxferc(USHORT p_port, UCHAR p_data)
-#else
-UCHAR scxferc(ULONG p_port, UCHAR p_data)
-#endif
+static UCHAR FPT_scxferc(ULONG p_port, UCHAR p_data)
 {
    UCHAR curr_data, ret_data;
 
@@ -9890,7 +6493,7 @@ UCHAR scxferc(ULONG p_port, UCHAR p_data)
 
    WR_HARPOON(p_port+hp_scsidata_0, curr_data);
 
-   scwirod(p_port,BIT(7));              /*Wait for DB7 to be released. */
+   FPT_scwirod(p_port,BIT(7));              /*Wait for DB7 to be released. */
 	while (!(RD_HARPOON(p_port+hp_scsidata_0) & BIT(5)));
 
    ret_data = (RD_HARPOON(p_port+hp_scsidata_0) & (UCHAR) 0x1F);
@@ -9903,7 +6506,7 @@ UCHAR scxferc(ULONG p_port, UCHAR p_data)
 
    WR_HARPOON(p_port+hp_scsidata_0, curr_data);
 
-   scwirod(p_port,BIT(5));              /*Wait for DB5 to be released. */
+   FPT_scwirod(p_port,BIT(5));              /*Wait for DB5 to be released. */
 
    curr_data &= ~(BIT(4)|BIT(3)|BIT(2)|BIT(1)|BIT(0)); /*Release data bits */
    curr_data |= BIT(7);
@@ -9914,7 +6517,7 @@ UCHAR scxferc(ULONG p_port, UCHAR p_data)
 
    WR_HARPOON(p_port+hp_scsidata_0, curr_data);
 
-   scwirod(p_port,BIT(6));              /*Wait for DB6 to be released. */
+   FPT_scwirod(p_port,BIT(6));              /*Wait for DB6 to be released. */
 
    return(ret_data);
 }
@@ -9922,39 +6525,35 @@ UCHAR scxferc(ULONG p_port, UCHAR p_data)
 
 /*---------------------------------------------------------------------
  *
- * Function: scsendi
+ * Function: FPT_scsendi
  *
  * Description: Transfer our Identification string to determine if we
  *              will be the dominant master.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-UCHAR scsendi(USHORT p_port, UCHAR p_id_string[])
-#else
-UCHAR scsendi(ULONG p_port, UCHAR p_id_string[])
-#endif
+static UCHAR FPT_scsendi(ULONG p_port, UCHAR p_id_string[])
 {
    UCHAR ret_data,byte_cnt,bit_cnt,defer;
 
-   defer = FALSE;
+   defer = 0;
 
    for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
 
       for (bit_cnt = 0x80; bit_cnt != 0 ; bit_cnt >>= 1) {
 
          if (defer)
-            ret_data = scxferc(p_port,00);
+            ret_data = FPT_scxferc(p_port,00);
 
          else if (p_id_string[byte_cnt] & bit_cnt)
 
-               ret_data = scxferc(p_port,02);
+               ret_data = FPT_scxferc(p_port,02);
 
             else {
 
-               ret_data = scxferc(p_port,01);
+               ret_data = FPT_scxferc(p_port,01);
                if (ret_data & 02)
-                  defer = TRUE;
+                  defer = 1;
                }
 
          if ((ret_data & 0x1C) == 0x10)
@@ -9980,17 +6579,13 @@ UCHAR scsendi(ULONG p_port, UCHAR p_id_string[])
 
 /*---------------------------------------------------------------------
  *
- * Function: sciso
+ * Function: FPT_sciso
  *
  * Description: Transfer the Identification string.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-UCHAR sciso(USHORT p_port, UCHAR p_id_string[])
-#else
-UCHAR sciso(ULONG p_port, UCHAR p_id_string[])
-#endif
+static UCHAR FPT_sciso(ULONG p_port, UCHAR p_id_string[])
 {
    UCHAR ret_data,the_data,byte_cnt,bit_cnt;
 
@@ -10000,7 +6595,7 @@ UCHAR sciso(ULONG p_port, UCHAR p_id_string[])
 
       for (bit_cnt = 0; bit_cnt < 8; bit_cnt++) {
 
-         ret_data = scxferc(p_port,0);
+         ret_data = FPT_scxferc(p_port,0);
 
          if (ret_data & 0xFC)
             return(0xFF);
@@ -10020,8 +6615,8 @@ UCHAR sciso(ULONG p_port, UCHAR p_id_string[])
 				{
 					byte_cnt = 0;
 					bit_cnt = 0;
-					scxferc(p_port, SYNC_PTRN);
-					scxferc(p_port, ASSIGN_ID);
+					FPT_scxferc(p_port, SYNC_PTRN);
+					FPT_scxferc(p_port, ASSIGN_ID);
 					continue;
 				}
 */
@@ -10044,18 +6639,14 @@ UCHAR sciso(ULONG p_port, UCHAR p_id_string[])
 
 /*---------------------------------------------------------------------
  *
- * Function: scwirod
+ * Function: FPT_scwirod
  *
  * Description: Sample the SCSI data bus making sure the signal has been
  *              deasserted for the correct number of consecutive samples.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scwirod(USHORT p_port, UCHAR p_data_bit)
-#else
-void scwirod(ULONG p_port, UCHAR p_data_bit)
-#endif
+static void FPT_scwirod(ULONG p_port, UCHAR p_data_bit)
 {
    UCHAR i;
 
@@ -10077,166 +6668,70 @@ void scwirod(ULONG p_port, UCHAR p_data_bit)
 
 /*---------------------------------------------------------------------
  *
- * Function: scwiros
+ * Function: FPT_scwiros
  *
  * Description: Sample the SCSI Signal lines making sure the signal has been
  *              deasserted for the correct number of consecutive samples.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scwiros(USHORT p_port, UCHAR p_data_bit)
-#else
-void scwiros(ULONG p_port, UCHAR p_data_bit)
-#endif
+static void FPT_scwiros(ULONG p_port, UCHAR p_data_bit)
 {
    UCHAR i;
 
-   i = 0;
-   while ( i < MAX_SCSI_TAR ) {
-
-      if (RD_HARPOON(p_port+hp_scsisig) & p_data_bit)
-
-         i = 0;
-
-      else
-
-         i++;
-
-      }
-}
-
-
-/*---------------------------------------------------------------------
- *
- * Function: scvalq
- *
- * Description: Make sure we received a valid data byte.
- *
- *---------------------------------------------------------------------*/
-
-UCHAR scvalq(UCHAR p_quintet)
-{
-   UCHAR count;
-
-   for (count=1; count < 0x08; count<<=1) {
-      if (!(p_quintet & count))
-         p_quintet -= 0x80;
-      }
-
-   if (p_quintet & 0x18)
-      return(FALSE);
-
-   else
-      return(TRUE);
-}
-
-
-/*---------------------------------------------------------------------
- *
- * Function: scsell
- *
- * Description: Select the specified device ID using a selection timeout
- *              less than 4ms.  If somebody responds then it is a legacy
- *              drive and this ID must be marked as such.
- *
- *---------------------------------------------------------------------*/
-
-#if defined(DOS)
-UCHAR scsell(USHORT p_port, UCHAR targ_id)
-#else
-UCHAR scsell(ULONG p_port, UCHAR targ_id)
-#endif
-{
-#if defined(DOS)
-   USHORT i;
-#else
-   ULONG i;
-#endif
-
-   WR_HARPOON(p_port+hp_page_ctrl,
-      (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
-
-   ARAM_ACCESS(p_port);
-
-   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) | SCAM_TIMER));
-   WR_HARPOON(p_port+hp_seltimeout,TO_4ms);
-
-
-   for (i = p_port+CMD_STRT; i < p_port+CMD_STRT+12; i+=2) {
-      WRW_HARPOON(i, (MPM_OP+ACOMMAND));
-      }
-   WRW_HARPOON(i, (BRH_OP+ALWAYS+    NP));
-
-   WRW_HARPOON((p_port+hp_intstat),
-	       (RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));
-
-   WR_HARPOON(p_port+hp_select_id, targ_id);
-
-   WR_HARPOON(p_port+hp_portctrl_0, SCSI_PORT);
-   WR_HARPOON(p_port+hp_autostart_3, (SELECT | CMD_ONLY_STRT));
-   WR_HARPOON(p_port+hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
-
-
-   while (!(RDW_HARPOON((p_port+hp_intstat)) &
-	    (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {}
-
-   if (RDW_HARPOON((p_port+hp_intstat)) & RESET)
-         Wait(p_port, TO_250ms);
-
-   DISABLE_AUTO(p_port);
-
-   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) & ~SCAM_TIMER));
-   WR_HARPOON(p_port+hp_seltimeout,TO_290ms);
+   i = 0;
+   while ( i < MAX_SCSI_TAR ) {
 
-   SGRAM_ACCESS(p_port);
+      if (RD_HARPOON(p_port+hp_scsisig) & p_data_bit)
 
-   if (RDW_HARPOON((p_port+hp_intstat)) & (RESET | TIMEOUT) ) {
+         i = 0;
 
-      WRW_HARPOON((p_port+hp_intstat),
-		  (RESET | TIMEOUT | SEL | BUS_FREE | PHASE));
+      else
 
-      WR_HARPOON(p_port+hp_page_ctrl,
-         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+         i++;
 
-      return(FALSE);  /*No legacy device */
       }
+}
 
-   else {
-
-      while(!(RDW_HARPOON((p_port+hp_intstat)) & BUS_FREE)) {
-				if (RD_HARPOON(p_port+hp_scsisig) & SCSI_REQ)
-					{
-					WR_HARPOON(p_port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
-      			ACCEPT_MSG(p_port);
-					}
-		}
 
-      WRW_HARPOON((p_port+hp_intstat), CLR_ALL_INT_1);
+/*---------------------------------------------------------------------
+ *
+ * Function: FPT_scvalq
+ *
+ * Description: Make sure we received a valid data byte.
+ *
+ *---------------------------------------------------------------------*/
 
-      WR_HARPOON(p_port+hp_page_ctrl,
-         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+static UCHAR FPT_scvalq(UCHAR p_quintet)
+{
+   UCHAR count;
 
-      return(TRUE);  /*Found one of them oldies! */
+   for (count=1; count < 0x08; count<<=1) {
+      if (!(p_quintet & count))
+         p_quintet -= 0x80;
       }
+
+   if (p_quintet & 0x18)
+      return(0);
+
+   else
+      return(1);
 }
 
-#if defined(DOS)
+
 /*---------------------------------------------------------------------
  *
- * Function: scsell for DOS
+ * Function: FPT_scsell
  *
  * Description: Select the specified device ID using a selection timeout
- *              less than 2ms.  This was specially required to solve
- *              the problem with Plextor 12X CD-ROM drive. This drive
- *					 was responding the Selection at the end of 4ms and 
- *					 hanging the system.
+ *              less than 4ms.  If somebody responds then it is a legacy
+ *              drive and this ID must be marked as such.
  *
  *---------------------------------------------------------------------*/
 
-UCHAR scsellDOS(USHORT p_port, UCHAR targ_id)
+static UCHAR FPT_scsell(ULONG p_port, UCHAR targ_id)
 {
-   USHORT i;
+   ULONG i;
 
    WR_HARPOON(p_port+hp_page_ctrl,
       (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
@@ -10244,7 +6739,7 @@ UCHAR scsellDOS(USHORT p_port, UCHAR targ_id)
    ARAM_ACCESS(p_port);
 
    WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) | SCAM_TIMER));
-   WR_HARPOON(p_port+hp_seltimeout,TO_2ms);
+   WR_HARPOON(p_port+hp_seltimeout,TO_4ms);
 
 
    for (i = p_port+CMD_STRT; i < p_port+CMD_STRT+12; i+=2) {
@@ -10266,7 +6761,7 @@ UCHAR scsellDOS(USHORT p_port, UCHAR targ_id)
 	    (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {}
 
    if (RDW_HARPOON((p_port+hp_intstat)) & RESET)
-         Wait(p_port, TO_250ms);
+         FPT_Wait(p_port, TO_250ms);
 
    DISABLE_AUTO(p_port);
 
@@ -10283,7 +6778,7 @@ UCHAR scsellDOS(USHORT p_port, UCHAR targ_id)
       WR_HARPOON(p_port+hp_page_ctrl,
          (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
 
-      return(FALSE);  /*No legacy device */
+      return(0);  /*No legacy device */
       }
 
    else {
@@ -10301,24 +6796,19 @@ UCHAR scsellDOS(USHORT p_port, UCHAR targ_id)
       WR_HARPOON(p_port+hp_page_ctrl,
          (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
 
-      return(TRUE);  /*Found one of them oldies! */
+      return(1);  /*Found one of them oldies! */
       }
 }
-#endif  /* DOS */
 
 /*---------------------------------------------------------------------
  *
- * Function: scwtsel
+ * Function: FPT_scwtsel
  *
  * Description: Wait to be selected by another SCAM initiator.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scwtsel(USHORT p_port)
-#else
-void scwtsel(ULONG p_port)
-#endif
+static void FPT_scwtsel(ULONG p_port)
 {
    while(!(RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL)) {}
 }
@@ -10326,23 +6816,19 @@ void scwtsel(ULONG p_port)
 
 /*---------------------------------------------------------------------
  *
- * Function: inisci
+ * Function: FPT_inisci
  *
  * Description: Setup the data Structure with the info from the EEPROM.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void inisci(UCHAR p_card, USHORT p_port, UCHAR p_our_id)
-#else
-void inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
-#endif
+static void FPT_inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
 {
    UCHAR i,k,max_id;
    USHORT ee_data;
 	PNVRamInfo pCurrNvRam;
 
-	pCurrNvRam = BL_Card[p_card].pNvRamInfo;
+	pCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;
 
    if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
       max_id = 0x08;
@@ -10354,14 +6840,14 @@ void inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
 		for(i = 0; i < max_id; i++){
 
 			for(k = 0; k < 4; k++)
-				scamInfo[i].id_string[k] = pCurrNvRam->niScamTbl[i][k];
+				FPT_scamInfo[i].id_string[k] = pCurrNvRam->niScamTbl[i][k];
 			for(k = 4; k < ID_STRING_LENGTH; k++)
-				scamInfo[i].id_string[k] = (UCHAR) 0x00;
+				FPT_scamInfo[i].id_string[k] = (UCHAR) 0x00;
 
-	      if(scamInfo[i].id_string[0] == 0x00)
-      	   scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
+	      if(FPT_scamInfo[i].id_string[0] == 0x00)
+      	   FPT_scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
 	      else
-   	      scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
+   	      FPT_scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
 
 		}
 	}else {
@@ -10369,38 +6855,38 @@ void inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
    	   {
       	for (k=0; k < ID_STRING_LENGTH; k+=2)
 	         {
-   	      ee_data = utilEERead(p_port, (USHORT)((EE_SCAMBASE/2) +
+   	      ee_data = FPT_utilEERead(p_port, (USHORT)((EE_SCAMBASE/2) +
       	     (USHORT) (i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
-         	scamInfo[i].id_string[k] = (UCHAR) ee_data;
+         	FPT_scamInfo[i].id_string[k] = (UCHAR) ee_data;
 	         ee_data >>= 8;
-   	      scamInfo[i].id_string[k+1] = (UCHAR) ee_data;
+   	      FPT_scamInfo[i].id_string[k+1] = (UCHAR) ee_data;
       	   }
 
-	      if ((scamInfo[i].id_string[0] == 0x00) ||
-   	       (scamInfo[i].id_string[0] == 0xFF))
+	      if ((FPT_scamInfo[i].id_string[0] == 0x00) ||
+   	       (FPT_scamInfo[i].id_string[0] == 0xFF))
 
-      	   scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
+      	   FPT_scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
 
 	      else
-   	      scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
+   	      FPT_scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
 
       	}
 	}
 	for(k = 0; k < ID_STRING_LENGTH; k++)
-		scamInfo[p_our_id].id_string[k] = scamHAString[k];
+		FPT_scamInfo[p_our_id].id_string[k] = FPT_scamHAString[k];
 
 }
 
 /*---------------------------------------------------------------------
  *
- * Function: scmachid
+ * Function: FPT_scmachid
  *
  * Description: Match the Device ID string with our values stored in
  *              the EEPROM.
  *
  *---------------------------------------------------------------------*/
 
-UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[])
+static UCHAR FPT_scmachid(UCHAR p_card, UCHAR p_id_string[])
 {
 
    UCHAR i,k,match;
@@ -10408,28 +6894,20 @@ UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[])
 
    for (i=0; i < MAX_SCSI_TAR; i++) {
 
-#if !defined(SCAM_LEV_2)
-      if (scamInfo[i].state == ID_UNASSIGNED)
-         {
-#endif
-         match = TRUE;
+         match = 1;
 
          for (k=0; k < ID_STRING_LENGTH; k++)
             {
-            if (p_id_string[k] != scamInfo[i].id_string[k])
-               match = FALSE;
+            if (p_id_string[k] != FPT_scamInfo[i].id_string[k])
+               match = 0;
             }
 
          if (match)
             {
-            scamInfo[i].state = ID_ASSIGNED;
+            FPT_scamInfo[i].state = ID_ASSIGNED;
             return(i);
             }
 
-#if !defined(SCAM_LEV_2)
-         }
-#endif
-
       }
 
 
@@ -10448,17 +6926,17 @@ UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[])
       {
       i--;
 
-      if (scamInfo[match].state == ID_UNUSED)
+      if (FPT_scamInfo[match].state == ID_UNUSED)
          {
          for (k=0; k < ID_STRING_LENGTH; k++)
             {
-            scamInfo[match].id_string[k] = p_id_string[k];
+            FPT_scamInfo[match].id_string[k] = p_id_string[k];
             }
 
-         scamInfo[match].state = ID_ASSIGNED;
+         FPT_scamInfo[match].state = ID_ASSIGNED;
 
-			if(BL_Card[p_card].pNvRamInfo == NULL)
-	         BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
+			if(FPT_BL_Card[p_card].pNvRamInfo == NULL)
+	         FPT_BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
          return(match);
 
          }
@@ -10498,17 +6976,17 @@ UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[])
 
       i--;
 
-      if (scamInfo[match].state == ID_UNASSIGNED)
+      if (FPT_scamInfo[match].state == ID_UNASSIGNED)
          {
          for (k=0; k < ID_STRING_LENGTH; k++)
             {
-            scamInfo[match].id_string[k] = p_id_string[k];
+            FPT_scamInfo[match].id_string[k] = p_id_string[k];
             }
 
-         scamInfo[match].id_string[0] |= BIT(7);
-         scamInfo[match].state = ID_ASSIGNED;
-			if(BL_Card[p_card].pNvRamInfo == NULL)
-	         BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
+         FPT_scamInfo[match].id_string[0] |= BIT(7);
+         FPT_scamInfo[match].state = ID_ASSIGNED;
+			if(FPT_BL_Card[p_card].pNvRamInfo == NULL)
+	         FPT_BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
          return(match);
 
          }
@@ -10531,17 +7009,13 @@ UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[])
 
 /*---------------------------------------------------------------------
  *
- * Function: scsavdi
+ * Function: FPT_scsavdi
  *
  * Description: Save off the device SCAM ID strings.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void scsavdi(UCHAR p_card, USHORT p_port)
-#else
-void scsavdi(UCHAR p_card, ULONG p_port)
-#endif
+static void FPT_scsavdi(UCHAR p_card, ULONG p_port)
 {
    UCHAR i,k,max_id;
    USHORT ee_data,sum_data;
@@ -10551,11 +7025,11 @@ void scsavdi(UCHAR p_card, ULONG p_port)
 
    for (i = 1; i < EE_SCAMBASE/2; i++)
       {
-      sum_data += utilEERead(p_port, i);
+      sum_data += FPT_utilEERead(p_port, i);
       }
 
 
-   utilEEWriteOnOff(p_port,1);   /* Enable write access to the EEPROM */
+   FPT_utilEEWriteOnOff(p_port,1);   /* Enable write access to the EEPROM */
 
    if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
       max_id = 0x08;
@@ -10568,64 +7042,29 @@ void scsavdi(UCHAR p_card, ULONG p_port)
 
       for (k=0; k < ID_STRING_LENGTH; k+=2)
          {
-         ee_data = scamInfo[i].id_string[k+1];
+         ee_data = FPT_scamInfo[i].id_string[k+1];
          ee_data <<= 8;
-         ee_data |= scamInfo[i].id_string[k];
+         ee_data |= FPT_scamInfo[i].id_string[k];
          sum_data += ee_data;
-         utilEEWrite(p_port, ee_data, (USHORT)((EE_SCAMBASE/2) +
+         FPT_utilEEWrite(p_port, ee_data, (USHORT)((EE_SCAMBASE/2) +
             (USHORT)(i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
          }
       }
 
 
-   utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM/2);
-   utilEEWriteOnOff(p_port,0);   /* Turn off write access */
+   FPT_utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM/2);
+   FPT_utilEEWriteOnOff(p_port,0);   /* Turn off write access */
 }
-#ident "$Id: diagnose.c 1.10 1997/06/10 16:51:47 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   diagnose.c  $
- *
- *   Description:  Diagnostic funtions for testing the integrity of
- *                 the HARPOON.
- *
- *   $Date: 1997/06/10 16:51:47 $
- *
- *   $Revision: 1.10 $
- *
- *----------------------------------------------------------------------*/
-
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <eeprom.h>*/
-/*#include <harpoon.h>*/
 
 /*---------------------------------------------------------------------
  *
- * Function: XbowInit
+ * Function: FPT_XbowInit
  *
  * Description: Setup the Xbow for normal operation.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void XbowInit(USHORT port, UCHAR ScamFlg)
-#else
-void XbowInit(ULONG port, UCHAR ScamFlg)
-#endif
+static void FPT_XbowInit(ULONG port, UCHAR ScamFlg)
 {
 UCHAR i;
 
@@ -10647,18 +7086,13 @@ UCHAR i;
 
    WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
 
-#if defined(SCAM_LEV_2)
-   default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
+   FPT_default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
 		    BUS_FREE | XFER_CNT_0 | AUTO_INT;
 
    if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
-		default_intena |= SCAM_SEL;
+		FPT_default_intena |= SCAM_SEL;
 
-#else
-   default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
-		    BUS_FREE | XFER_CNT_0 | AUTO_INT;
-#endif
-   WRW_HARPOON((port+hp_intena), default_intena);
+   WRW_HARPOON((port+hp_intena), FPT_default_intena);
 
    WR_HARPOON(port+hp_seltimeout,TO_290ms);
 
@@ -10667,26 +7101,6 @@ UCHAR i;
    if (RD_HARPOON(port+hp_page_ctrl) & NARROW_SCSI_CARD)
       WR_HARPOON(port+hp_addstat,SCSI_MODE8);
 
-#if defined(NO_BIOS_OPTION)
-
-   WR_HARPOON(port+hp_synctarg_0,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_1,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_2,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_3,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_4,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_5,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_6,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_7,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_8,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_9,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_10,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_11,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_12,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_13,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_14,NARROW_SCSI);
-   WR_HARPOON(port+hp_synctarg_15,NARROW_SCSI);
-
-#endif
 	WR_HARPOON(port+hp_page_ctrl, i);
 
 }
@@ -10694,17 +7108,13 @@ UCHAR i;
 
 /*---------------------------------------------------------------------
  *
- * Function: BusMasterInit
+ * Function: FPT_BusMasterInit
  *
  * Description: Initialize the BusMaster for normal operations.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void BusMasterInit(USHORT p_port)
-#else
-void BusMasterInit(ULONG p_port)
-#endif
+static void FPT_BusMasterInit(ULONG p_port)
 {
 
 
@@ -10719,13 +7129,6 @@ void BusMasterInit(ULONG p_port)
    WR_HARPOON(p_port+hp_ee_ctrl, (SCSI_TERM_ENA_H));
 
 
-#if defined(NT)
-
-   WR_HARPOON(p_port+hp_pci_cmd_cfg, (RD_HARPOON(p_port+hp_pci_cmd_cfg)
-      & ~MEM_SPACE_ENA));
-
-#endif
-
    RD_HARPOON(p_port+hp_int_status);        /*Clear interrupts. */
    WR_HARPOON(p_port+hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
    WR_HARPOON(p_port+hp_page_ctrl, (RD_HARPOON(p_port+hp_page_ctrl) &
@@ -10735,147 +7138,14 @@ void BusMasterInit(ULONG p_port)
 
 /*---------------------------------------------------------------------
  *
- * Function: DiagXbow
- *
- * Description: Test Xbow integrity.  Non-zero return indicates an error.
- *
- *---------------------------------------------------------------------*/
-
-#if defined(DOS)
-int DiagXbow(USHORT port)
-#else
-int DiagXbow(ULONG port)
-#endif
-{
-   unsigned char fifo_cnt,loop_cnt;
-
-   unsigned char fifodata[5];
-   fifodata[0] = 0x00;
-   fifodata[1] = 0xFF;
-   fifodata[2] = 0x55;
-   fifodata[3] = 0xAA;
-   fifodata[4] = 0x00;
-
-
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
-   WRW_HARPOON((port+hp_intena), 0x0000);
-
-   WR_HARPOON(port+hp_seltimeout,TO_5ms);
-
-   WR_HARPOON(port+hp_portctrl_0,START_TO);
-
-
-   for(fifodata[4] = 0x01; fifodata[4] != (UCHAR) 0; fifodata[4] = fifodata[4] << 1) {
-
-      WR_HARPOON(port+hp_selfid_0,fifodata[4]);
-      WR_HARPOON(port+hp_selfid_1,fifodata[4]);
-
-      if ((RD_HARPOON(port+hp_selfid_0) != fifodata[4]) ||
-          (RD_HARPOON(port+hp_selfid_1) != fifodata[4]))
-         return(1);
-      }
-
-
-   for(loop_cnt = 0; loop_cnt < 4; loop_cnt++) {
-
-      WR_HARPOON(port+hp_portctrl_0,(HOST_PORT | HOST_WRT | START_TO));
-
-
-      for (fifo_cnt = 0; fifo_cnt < FIFO_LEN; fifo_cnt++) {
-
-         WR_HARPOON(port+hp_fifodata_0, fifodata[loop_cnt]);
-         }
-
-
-      if (!(RD_HARPOON(port+hp_xferstat) & FIFO_FULL))
-         return(1);
-
-
-      WR_HARPOON(port+hp_portctrl_0,(HOST_PORT | START_TO));
-
-      for (fifo_cnt = 0; fifo_cnt < FIFO_LEN; fifo_cnt++) {
-
-         if (RD_HARPOON(port+hp_fifodata_0) != fifodata[loop_cnt])
-            return(1);
-         }
-
-
-      if (!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))
-         return(1);
-      }
-
-
-   while(!(RDW_HARPOON((port+hp_intstat)) & TIMEOUT)) {}
-
-
-   WR_HARPOON(port+hp_seltimeout,TO_290ms);
-
-   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
-
-   WRW_HARPOON((port+hp_intena), default_intena);
-
-   return(0);
-}
-
-
-/*---------------------------------------------------------------------
- *
- * Function: DiagBusMaster
- *
- * Description: Test BusMaster integrity.  Non-zero return indicates an
- *              error.
- *
- *---------------------------------------------------------------------*/
-
-#if defined(DOS)
-int DiagBusMaster(USHORT port)
-#else
-int DiagBusMaster(ULONG port)
-#endif
-{
-   UCHAR testdata;
-
-   for(testdata = (UCHAR) 1; testdata != (UCHAR)0; testdata = testdata << 1) {
-
-      WR_HARPOON(port+hp_xfer_cnt_lo,testdata);
-      WR_HARPOON(port+hp_xfer_cnt_mi,testdata);
-      WR_HARPOON(port+hp_xfer_cnt_hi,testdata);
-      WR_HARPOON(port+hp_host_addr_lo,testdata);
-      WR_HARPOON(port+hp_host_addr_lmi,testdata);
-      WR_HARPOON(port+hp_host_addr_hmi,testdata);
-      WR_HARPOON(port+hp_host_addr_hi,testdata);
-
-      if ((RD_HARPOON(port+hp_xfer_cnt_lo) != testdata)   ||
-          (RD_HARPOON(port+hp_xfer_cnt_mi) != testdata)   ||
-          (RD_HARPOON(port+hp_xfer_cnt_hi) != testdata)   ||
-          (RD_HARPOON(port+hp_host_addr_lo) != testdata)  ||
-          (RD_HARPOON(port+hp_host_addr_lmi) != testdata) ||
-          (RD_HARPOON(port+hp_host_addr_hmi) != testdata) ||
-          (RD_HARPOON(port+hp_host_addr_hi) != testdata))
-
-         return(1);
-      }
-   RD_HARPOON(port+hp_int_status);        /*Clear interrupts. */
-   return(0);
-}
-
-
-
-/*---------------------------------------------------------------------
- *
- * Function: DiagEEPROM
+ * Function: FPT_DiagEEPROM
  *
  * Description: Verfiy checksum and 'Key' and initialize the EEPROM if
  *              necessary.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void DiagEEPROM(USHORT p_port)
-#else
-void DiagEEPROM(ULONG p_port)
-#endif
-
+static void FPT_DiagEEPROM(ULONG p_port)
 {
    USHORT index,temp,max_wd_cnt;
 
@@ -10884,185 +7154,148 @@ void DiagEEPROM(ULONG p_port)
    else
       max_wd_cnt = EEPROM_WD_CNT * 2;
 
-   temp = utilEERead(p_port, FW_SIGNATURE/2);
+   temp = FPT_utilEERead(p_port, FW_SIGNATURE/2);
 
    if (temp == 0x4641) {
 
       for (index = 2; index < max_wd_cnt; index++) {
 
-         temp += utilEERead(p_port, index);
+         temp += FPT_utilEERead(p_port, index);
 
          }
 
-      if (temp == utilEERead(p_port, EEPROM_CHECK_SUM/2)) {
+      if (temp == FPT_utilEERead(p_port, EEPROM_CHECK_SUM/2)) {
 
          return;          /*EEPROM is Okay so return now! */
          }
       }
 
 
-   utilEEWriteOnOff(p_port,(UCHAR)1);
+   FPT_utilEEWriteOnOff(p_port,(UCHAR)1);
 
    for (index = 0; index < max_wd_cnt; index++) {
 
-      utilEEWrite(p_port, 0x0000, index);
+      FPT_utilEEWrite(p_port, 0x0000, index);
       }
 
    temp = 0;
 
-   utilEEWrite(p_port, 0x4641, FW_SIGNATURE/2);
+   FPT_utilEEWrite(p_port, 0x4641, FW_SIGNATURE/2);
    temp += 0x4641;
-   utilEEWrite(p_port, 0x3920, MODEL_NUMB_0/2);
+   FPT_utilEEWrite(p_port, 0x3920, MODEL_NUMB_0/2);
    temp += 0x3920;
-   utilEEWrite(p_port, 0x3033, MODEL_NUMB_2/2);
+   FPT_utilEEWrite(p_port, 0x3033, MODEL_NUMB_2/2);
    temp += 0x3033;
-   utilEEWrite(p_port, 0x2020, MODEL_NUMB_4/2);
+   FPT_utilEEWrite(p_port, 0x2020, MODEL_NUMB_4/2);
    temp += 0x2020;
-   utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG/2);
+   FPT_utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG/2);
    temp += 0x70D3;
-   utilEEWrite(p_port, 0x0010, BIOS_CONFIG/2);
+   FPT_utilEEWrite(p_port, 0x0010, BIOS_CONFIG/2);
    temp += 0x0010;
-   utilEEWrite(p_port, 0x0003, SCAM_CONFIG/2);
+   FPT_utilEEWrite(p_port, 0x0003, SCAM_CONFIG/2);
    temp += 0x0003;
-   utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID/2);
+   FPT_utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID/2);
    temp += 0x0007;
 
-   utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN/2);
+   FPT_utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN/2);
    temp += 0x0000;
-   utilEEWrite(p_port, 0x0000, SEND_START_ENA/2);
+   FPT_utilEEWrite(p_port, 0x0000, SEND_START_ENA/2);
    temp += 0x0000;
-   utilEEWrite(p_port, 0x0000, DEVICE_ENABLE/2);
+   FPT_utilEEWrite(p_port, 0x0000, DEVICE_ENABLE/2);
    temp += 0x0000;
 
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd/2);
    temp += 0x4242;
-   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef/2);
+   FPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef/2);
    temp += 0x4242;
 
 
-   utilEEWrite(p_port, 0x6C46, 64/2);  /*PRODUCT ID */
+   FPT_utilEEWrite(p_port, 0x6C46, 64/2);  /*PRODUCT ID */
    temp += 0x6C46;
-   utilEEWrite(p_port, 0x7361, 66/2);  /* FlashPoint LT   */
+   FPT_utilEEWrite(p_port, 0x7361, 66/2);  /* FlashPoint LT   */
    temp += 0x7361;
-   utilEEWrite(p_port, 0x5068, 68/2);
+   FPT_utilEEWrite(p_port, 0x5068, 68/2);
    temp += 0x5068;
-   utilEEWrite(p_port, 0x696F, 70/2);
+   FPT_utilEEWrite(p_port, 0x696F, 70/2);
    temp += 0x696F;
-   utilEEWrite(p_port, 0x746E, 72/2);
+   FPT_utilEEWrite(p_port, 0x746E, 72/2);
    temp += 0x746E;
-   utilEEWrite(p_port, 0x4C20, 74/2);
+   FPT_utilEEWrite(p_port, 0x4C20, 74/2);
    temp += 0x4C20;
-   utilEEWrite(p_port, 0x2054, 76/2);
+   FPT_utilEEWrite(p_port, 0x2054, 76/2);
    temp += 0x2054;
-   utilEEWrite(p_port, 0x2020, 78/2);
+   FPT_utilEEWrite(p_port, 0x2020, 78/2);
    temp += 0x2020;
 
    index = ((EE_SCAMBASE/2)+(7*16));
-   utilEEWrite(p_port, (0x0700+TYPE_CODE0), index);
+   FPT_utilEEWrite(p_port, (0x0700+TYPE_CODE0), index);
    temp += (0x0700+TYPE_CODE0);
    index++;
-   utilEEWrite(p_port, 0x5542, index);            /*Vendor ID code */
+   FPT_utilEEWrite(p_port, 0x5542, index);            /*Vendor ID code */
    temp += 0x5542;                                /* BUSLOGIC      */
    index++;
-   utilEEWrite(p_port, 0x4C53, index);
+   FPT_utilEEWrite(p_port, 0x4C53, index);
    temp += 0x4C53;
    index++;
-   utilEEWrite(p_port, 0x474F, index);
+   FPT_utilEEWrite(p_port, 0x474F, index);
    temp += 0x474F;
    index++;
-   utilEEWrite(p_port, 0x4349, index);
+   FPT_utilEEWrite(p_port, 0x4349, index);
    temp += 0x4349;
    index++;
-   utilEEWrite(p_port, 0x5442, index);            /*Vendor unique code */
+   FPT_utilEEWrite(p_port, 0x5442, index);            /*Vendor unique code */
    temp += 0x5442;                         /* BT- 930           */
    index++;
-   utilEEWrite(p_port, 0x202D, index);
+   FPT_utilEEWrite(p_port, 0x202D, index);
    temp += 0x202D;
    index++;
-   utilEEWrite(p_port, 0x3339, index);
+   FPT_utilEEWrite(p_port, 0x3339, index);
    temp += 0x3339;
    index++;                                 /*Serial #          */
-   utilEEWrite(p_port, 0x2030, index);             /* 01234567         */
+   FPT_utilEEWrite(p_port, 0x2030, index);             /* 01234567         */
    temp += 0x2030;
    index++;
-   utilEEWrite(p_port, 0x5453, index);
+   FPT_utilEEWrite(p_port, 0x5453, index);
    temp += 0x5453;
    index++;
-   utilEEWrite(p_port, 0x5645, index);
+   FPT_utilEEWrite(p_port, 0x5645, index);
    temp += 0x5645;
    index++;
-   utilEEWrite(p_port, 0x2045, index);
+   FPT_utilEEWrite(p_port, 0x2045, index);
    temp += 0x2045;
    index++;
-   utilEEWrite(p_port, 0x202F, index);
+   FPT_utilEEWrite(p_port, 0x202F, index);
    temp += 0x202F;
    index++;
-   utilEEWrite(p_port, 0x4F4A, index);
+   FPT_utilEEWrite(p_port, 0x4F4A, index);
    temp += 0x4F4A;
    index++;
-   utilEEWrite(p_port, 0x204E, index);
+   FPT_utilEEWrite(p_port, 0x204E, index);
    temp += 0x204E;
    index++;
-   utilEEWrite(p_port, 0x3539, index);
+   FPT_utilEEWrite(p_port, 0x3539, index);
    temp += 0x3539;
 
 
 
-   utilEEWrite(p_port, temp, EEPROM_CHECK_SUM/2);
+   FPT_utilEEWrite(p_port, temp, EEPROM_CHECK_SUM/2);
 
-   utilEEWriteOnOff(p_port,(UCHAR)0);
+   FPT_utilEEWriteOnOff(p_port,(UCHAR)0);
 
 }
 
-#ident "$Id: utility.c 1.23 1997/06/10 16:55:06 mohan Exp $"
-/*----------------------------------------------------------------------
- *
- *
- *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
- *
- *   This file is available under both the GNU General Public License
- *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
- *
- *   $Workfile:   utility.c  $
- *
- *   Description:  Utility functions relating to queueing and EEPROM
- *                 manipulation and any other garbage functions.
- *
- *   $Date: 1997/06/10 16:55:06 $
- *
- *   $Revision: 1.23 $
- *
- *----------------------------------------------------------------------*/
-/*#include <globals.h>*/
-
-#if (FW_TYPE==_UCB_MGR_)
-	/*#include <budi.h>*/
-#endif
-
-/*#include <sccbmgr.h>*/
-/*#include <blx30.h>*/
-/*#include <target.h>*/
-/*#include <scsi2.h>*/
-/*#include <harpoon.h>*/
-
-
-/*
-extern SCCBCARD BL_Card[MAX_CARDS];
-extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
-extern unsigned int SccbGlobalFlags;
-*/
 
 /*---------------------------------------------------------------------
  *
@@ -11072,7 +7305,7 @@ extern unsigned int SccbGlobalFlags;
  *
  *---------------------------------------------------------------------*/
 
-void queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
+static void FPT_queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
 {
    UCHAR scan_ptr, lun;
    PSCCBMgr_tar_info currTar_Info;
@@ -11081,7 +7314,7 @@ void queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
    scan_ptr = pCurrCard->scanIndex;
 	do 
 	{
-		currTar_Info = &sccbMgrTbl[p_card][scan_ptr];
+		currTar_Info = &FPT_sccbMgrTbl[p_card][scan_ptr];
 		if((pCurrCard->globalFlags & F_CONLUN_IO) && 
 			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
 		{
@@ -11094,7 +7327,7 @@ void queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
 				
 				for(lun=0; lun < MAX_LUN; lun++)
 				{
-					if(currTar_Info->TarLUNBusy[lun] == FALSE)
+					if(currTar_Info->TarLUNBusy[lun] == 0)
 					{
 
 						pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
@@ -11153,7 +7386,7 @@ void queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
 		else
 		{
 			if ((currTar_Info->TarSelQ_Cnt != 0) &&
-				(currTar_Info->TarLUNBusy[0] == FALSE))
+				(currTar_Info->TarLUNBusy[0] == 0))
 			{
 
 				pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
@@ -11203,7 +7436,7 @@ void queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-void queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
+static void FPT_queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
 {
    UCHAR thisTarg;
    PSCCBMgr_tar_info currTar_Info;
@@ -11211,7 +7444,7 @@ void queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
    if (pCurrCard->currentSCCB != NULL)
 	  {
 	  thisTarg = (UCHAR)(((PSCCB)(pCurrCard->currentSCCB))->TargID);
-      currTar_Info = &sccbMgrTbl[p_card][thisTarg];
+      currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
       pCurrCard->currentSCCB->Sccb_backlink = (PSCCB)NULL;
 
@@ -11242,103 +7475,10 @@ void queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-void queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb, UCHAR p_card)
+static void FPT_queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb,
+				 UCHAR p_card)
 {
 
-#if (FW_TYPE==_UCB_MGR_)
-
-   u08bits SCSIcmd;
-   CALL_BK_FN callback;
-   PSCCBMgr_tar_info currTar_Info;
-
-   PUCB p_ucb;
-   p_ucb=p_sccb->Sccb_ucb_ptr;
-
-   SCSIcmd = p_sccb->Cdb[0];
-
-
-   if (!(p_sccb->Sccb_XferState & F_ALL_XFERRED))
-   {
-
-      if ((p_ucb->UCB_opcode & OPC_CHK_UNDER_OVER_RUN)                     &&
-         (p_sccb->HostStatus == SCCB_COMPLETE)                             &&
-         (p_sccb->TargetStatus != SSCHECK))
-
-         if ((SCSIcmd == SCSI_READ)             ||
-             (SCSIcmd == SCSI_WRITE)            ||
-             (SCSIcmd == SCSI_READ_EXTENDED)    ||
-             (SCSIcmd == SCSI_WRITE_EXTENDED)   ||
-             (SCSIcmd == SCSI_WRITE_AND_VERIFY) ||
-             (SCSIcmd == SCSI_START_STOP_UNIT)  ||
-             (pCurrCard->globalFlags & F_NO_FILTER)
-            )
-               p_sccb->HostStatus = SCCB_DATA_UNDER_RUN;
-   }
-
-   p_ucb->UCB_status=SCCB_SUCCESS;
-
-   if ((p_ucb->UCB_hbastat=p_sccb->HostStatus) || (p_ucb->UCB_scsistat=p_sccb->TargetStatus))
-   {
-      p_ucb->UCB_status=SCCB_ERROR;
-   }
-
-   if ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||
-      (p_sccb->OperationCode == RESIDUAL_COMMAND))
-   {
-
-         utilUpdateResidual(p_sccb);
-
-         p_ucb->UCB_datalen=p_sccb->DataLength;
-   }
-
-   pCurrCard->cmdCounter--;
-   if (!pCurrCard->cmdCounter)
-   {
-
-      if (pCurrCard->globalFlags & F_GREEN_PC)
-      {
-         WR_HARPOON(pCurrCard->ioPort+hp_clkctrl_0,(PWR_DWN | CLKCTRL_DEFAULT));
-         WR_HARPOON(pCurrCard->ioPort+hp_sys_ctrl, STOP_CLK);
-      }
-
-      WR_HARPOON(pCurrCard->ioPort+hp_semaphore,
-      (RD_HARPOON(pCurrCard->ioPort+hp_semaphore) & ~SCCB_MGR_ACTIVE));
-   }
-
-	if(pCurrCard->discQCount != 0)
-	{
-      currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
-		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
-			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
-		{
-			pCurrCard->discQCount--;
-			pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = NULL;
-		}
-		else
-		{
-			if(p_sccb->Sccb_tag)
-			{
-				pCurrCard->discQCount--;
-				pCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;
-			}else
-			{
-				pCurrCard->discQCount--;
-				pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = NULL;
-			}
-		}
-
-	}
-   callback = (CALL_BK_FN)p_ucb->UCB_callback;
-   callback(p_ucb);
-   pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
-   pCurrCard->currentSCCB = NULL;
-}
-
-
-
-
-#else
-
    UCHAR i, SCSIcmd;
    CALL_BK_FN callback;
    PSCCBMgr_tar_info currTar_Info;
@@ -11383,7 +7523,7 @@ void queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb, UCHAR p_card)
    if ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||
 	  (p_sccb->OperationCode == RESIDUAL_COMMAND)) {
 
-		 utilUpdateResidual(p_sccb);
+		 FPT_utilUpdateResidual(p_sccb);
 		 }
 
    pCurrCard->cmdCounter--;
@@ -11401,7 +7541,7 @@ void queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb, UCHAR p_card)
 
 	if(pCurrCard->discQCount != 0)
 	{
-      currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+      currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
 		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
 			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 		{
@@ -11428,7 +7568,6 @@ void queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb, UCHAR p_card)
    pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
    pCurrCard->currentSCCB = NULL;
 }
-#endif /* ( if FW_TYPE==...) */
 
 
 /*---------------------------------------------------------------------
@@ -11438,30 +7577,30 @@ void queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb, UCHAR p_card)
  * Description: Add SCCB to our disconnect array.
  *
  *---------------------------------------------------------------------*/
-void queueDisconnect(PSCCB p_sccb, UCHAR p_card)
+static void FPT_queueDisconnect(PSCCB p_sccb, UCHAR p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
 
-	currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+	currTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];
 
-	if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+	if(((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
 		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
 	{
-		BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = p_sccb;
+		FPT_BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = p_sccb;
 	}
 	else
 	{
 		if (p_sccb->Sccb_tag)
 		{
-			BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] = p_sccb;
-			sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] = FALSE;
-			sccbMgrTbl[p_card][p_sccb->TargID].TarTagQ_Cnt++;
+			FPT_BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] = p_sccb;
+			FPT_sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] = 0;
+			FPT_sccbMgrTbl[p_card][p_sccb->TargID].TarTagQ_Cnt++;
 		}else
 		{
-			BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = p_sccb;
+			FPT_BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = p_sccb;
 		}
 	}
-	BL_Card[p_card].currentSCCB = NULL;
+	FPT_BL_Card[p_card].currentSCCB = NULL;
 }
 
 
@@ -11473,29 +7612,29 @@ void queueDisconnect(PSCCB p_sccb, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-void  queueFlushSccb(UCHAR p_card, UCHAR error_code)
+static void  FPT_queueFlushSccb(UCHAR p_card, UCHAR error_code)
 {
    UCHAR qtag,thisTarg;
    PSCCB currSCCB;
    PSCCBMgr_tar_info currTar_Info;
 
-   currSCCB = BL_Card[p_card].currentSCCB;
+   currSCCB = FPT_BL_Card[p_card].currentSCCB;
 	if(currSCCB != NULL)
 	{
 	   thisTarg = (UCHAR)currSCCB->TargID;
-   	currTar_Info = &sccbMgrTbl[p_card][thisTarg];
+   	currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
 	   for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
 
-		  if (BL_Card[p_card].discQ_Tbl[qtag] && 
-					(BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
+		  if (FPT_BL_Card[p_card].discQ_Tbl[qtag] && 
+					(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
 			 {
 
-			 BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
+			 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
 			
-			 queueCmdComplete(&BL_Card[p_card],BL_Card[p_card].discQ_Tbl[qtag], p_card);
+			 FPT_queueCmdComplete(&FPT_BL_Card[p_card],FPT_BL_Card[p_card].discQ_Tbl[qtag], p_card);
 
-			 BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+			 FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
 			 currTar_Info->TarTagQ_Cnt--;
 
 			 }
@@ -11512,24 +7651,25 @@ void  queueFlushSccb(UCHAR p_card, UCHAR error_code)
  *
  *---------------------------------------------------------------------*/
 
-void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code)
+static void  FPT_queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg,
+				    UCHAR error_code)
 {
    UCHAR qtag;
    PSCCBMgr_tar_info currTar_Info;
 
-   currTar_Info = &sccbMgrTbl[p_card][thisTarg];
+   currTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];
 
    for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
 
-	  if (BL_Card[p_card].discQ_Tbl[qtag] && 
-				(BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
+	  if (FPT_BL_Card[p_card].discQ_Tbl[qtag] && 
+				(FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
 		 {
 
-		 BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
+		 FPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
 
-		 queueCmdComplete(&BL_Card[p_card],BL_Card[p_card].discQ_Tbl[qtag], p_card);
+		 FPT_queueCmdComplete(&FPT_BL_Card[p_card],FPT_BL_Card[p_card].discQ_Tbl[qtag], p_card);
 
-		 BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+		 FPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;
 		 currTar_Info->TarTagQ_Cnt--;
 
 		 }
@@ -11541,10 +7681,10 @@ void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code)
 
 
 
-void queueAddSccb(PSCCB p_SCCB, UCHAR p_card)
+static void FPT_queueAddSccb(PSCCB p_SCCB, UCHAR p_card)
 {
    PSCCBMgr_tar_info currTar_Info;
-   currTar_Info = &sccbMgrTbl[p_card][p_SCCB->TargID];
+   currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
 
    p_SCCB->Sccb_forwardlink = NULL;
 
@@ -11575,12 +7715,12 @@ void queueAddSccb(PSCCB p_SCCB, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
+static UCHAR FPT_queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
 {
    PSCCB q_ptr;
    PSCCBMgr_tar_info currTar_Info;
 
-   currTar_Info = &sccbMgrTbl[p_card][p_SCCB->TargID];
+   currTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];
 
    q_ptr = currTar_Info->TarSelQ_Head;
 
@@ -11609,7 +7749,7 @@ UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
 
 		 currTar_Info->TarSelQ_Cnt--;
 
-		 return(TRUE);
+		 return(1);
 		 }
 
 	  else {
@@ -11618,7 +7758,7 @@ UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
 	  }
 
 
-   return(FALSE);
+   return(0);
 
 }
 
@@ -11636,15 +7776,11 @@ UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
  *
  *---------------------------------------------------------------------*/
 
-void  utilUpdateResidual(PSCCB p_SCCB)
+static void  FPT_utilUpdateResidual(PSCCB p_SCCB)
 {
    ULONG partial_cnt;
    UINT  sg_index;
-#if defined(COMPILER_16_BIT) && !defined(DOS)
-   ULONG far *sg_ptr;
-#else
    ULONG *sg_ptr;
-#endif
 
    if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {
 
@@ -11657,11 +7793,7 @@ void  utilUpdateResidual(PSCCB p_SCCB)
 
 		 sg_index = p_SCCB->Sccb_sgseg;
 
-#if defined(COMPILER_16_BIT) && !defined(DOS)
-		 sg_ptr = (ULONG far *)p_SCCB->DataPointer;
-#else
 		 sg_ptr = (ULONG *)p_SCCB->DataPointer;
-#endif
 
 		 if (p_SCCB->Sccb_SGoffset) {
 
@@ -11694,17 +7826,13 @@ void  utilUpdateResidual(PSCCB p_SCCB)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void Wait1Second(USHORT p_port)
-#else
-void Wait1Second(ULONG p_port)
-#endif
+static void FPT_Wait1Second(ULONG p_port)
 {
    UCHAR i;
 
    for(i=0; i < 4; i++) {
 
-	  Wait(p_port, TO_250ms);
+	  FPT_Wait(p_port, TO_250ms);
 
 	  if ((RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST))
 		 break;
@@ -11717,17 +7845,13 @@ void Wait1Second(ULONG p_port)
 
 /*---------------------------------------------------------------------
  *
- * Function: Wait
+ * Function: FPT_Wait
  *
  * Description: Wait the desired delay.
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void Wait(USHORT p_port, UCHAR p_delay)
-#else
-void Wait(ULONG p_port, UCHAR p_delay)
-#endif
+static void FPT_Wait(ULONG p_port, UCHAR p_delay)
 {
    UCHAR old_timer;
    UCHAR green_flag;
@@ -11739,7 +7863,7 @@ void Wait(ULONG p_port, UCHAR p_delay)
 
    WR_HARPOON(p_port+hp_seltimeout,p_delay);
    WRW_HARPOON((p_port+hp_intstat), TIMEOUT);
-   WRW_HARPOON((p_port+hp_intena), (default_intena & ~TIMEOUT));
+   WRW_HARPOON((p_port+hp_intena), (FPT_default_intena & ~TIMEOUT));
 
 
    WR_HARPOON(p_port+hp_portctrl_0,
@@ -11758,7 +7882,7 @@ void Wait(ULONG p_port, UCHAR p_delay)
 	  (RD_HARPOON(p_port+hp_portctrl_0) & ~START_TO));
 
    WRW_HARPOON((p_port+hp_intstat), TIMEOUT);
-   WRW_HARPOON((p_port+hp_intena), default_intena);
+   WRW_HARPOON((p_port+hp_intena), FPT_default_intena);
 
    WR_HARPOON(p_port+hp_clkctrl_0,green_flag);
 
@@ -11775,11 +7899,7 @@ void Wait(ULONG p_port, UCHAR p_delay)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void utilEEWriteOnOff(USHORT p_port,UCHAR p_mode)
-#else
-void utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
-#endif
+static void FPT_utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
 {
    UCHAR ee_value;
 
@@ -11787,12 +7907,12 @@ void utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
 
    if (p_mode)
 
-	  utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);
+	  FPT_utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);
 
    else
 
 
-	  utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);
+	  FPT_utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);
 
    WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS)); /*Turn off CS */
    WR_HARPOON(p_port+hp_ee_ctrl, ee_value);       /*Turn off Master Select */
@@ -11808,11 +7928,7 @@ void utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void utilEEWrite(USHORT p_port, USHORT ee_data, USHORT ee_addr)
-#else
-void utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
-#endif
+static void FPT_utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
 {
 
    UCHAR ee_value;
@@ -11823,7 +7939,7 @@ void utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
 
 
 
-   utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);
+   FPT_utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);
 
 
    ee_value |= (SEE_MS + SEE_CS);
@@ -11847,7 +7963,7 @@ void utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
    ee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);
    WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS));
 
-   Wait(p_port, TO_10ms);
+   FPT_Wait(p_port, TO_10ms);
 
    WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS | SEE_CS)); /* Set CS to EEPROM */
    WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS));       /* Turn off CS */
@@ -11863,19 +7979,15 @@ void utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-USHORT utilEERead(USHORT p_port, USHORT ee_addr)
-#else
-USHORT utilEERead(ULONG p_port, USHORT ee_addr)
-#endif
+static USHORT FPT_utilEERead(ULONG p_port, USHORT ee_addr)
 {
    USHORT i, ee_data1, ee_data2;
 
 	i = 0;
-	ee_data1 = utilEEReadOrg(p_port, ee_addr);
+	ee_data1 = FPT_utilEEReadOrg(p_port, ee_addr);
 	do
 	{
-		ee_data2 = utilEEReadOrg(p_port, ee_addr);
+		ee_data2 = FPT_utilEEReadOrg(p_port, ee_addr);
 
 		if(ee_data1 == ee_data2)
 			return(ee_data1);
@@ -11897,11 +8009,7 @@ USHORT utilEERead(ULONG p_port, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-USHORT utilEEReadOrg(USHORT p_port, USHORT ee_addr)
-#else
-USHORT utilEEReadOrg(ULONG p_port, USHORT ee_addr)
-#endif
+static USHORT FPT_utilEEReadOrg(ULONG p_port, USHORT ee_addr)
 {
 
    UCHAR ee_value;
@@ -11911,7 +8019,7 @@ USHORT utilEEReadOrg(ULONG p_port, USHORT ee_addr)
 		   (SEE_MS | SEE_CS));
 
 
-   utilEESendCmdAddr(p_port, EE_READ, ee_addr);
+   FPT_utilEESendCmdAddr(p_port, EE_READ, ee_addr);
 
 
    ee_value |= (SEE_MS + SEE_CS);
@@ -11949,11 +8057,7 @@ USHORT utilEEReadOrg(ULONG p_port, USHORT ee_addr)
  *
  *---------------------------------------------------------------------*/
 
-#if defined(DOS)
-void utilEESendCmdAddr(USHORT p_port, UCHAR ee_cmd, USHORT ee_addr)
-#else
-void utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr)
-#endif
+static void FPT_utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr)
 {
    UCHAR ee_value;
    UCHAR narrow_flg;
@@ -12016,7 +8120,7 @@ void utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr)
 	  }
 }
 
-USHORT CalcCrc16(UCHAR buffer[])
+static USHORT FPT_CalcCrc16(UCHAR buffer[])
 {
    USHORT crc=0;
 	int i,j;
@@ -12036,7 +8140,7 @@ USHORT CalcCrc16(UCHAR buffer[])
 	return(crc);
 }
 
-UCHAR CalcLrc(UCHAR buffer[])
+static UCHAR FPT_CalcLrc(UCHAR buffer[])
 {
 	int i;
 	UCHAR lrc;
@@ -12109,33 +8213,6 @@ FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
 #define FlashPoint_HandleInterrupt	    FlashPoint__HandleInterrupt
 
 
-/*
-  FlashPoint_InquireTargetInfo returns the Synchronous Period, Synchronous
-  Offset, and Wide Transfers Active information for TargetID on CardHandle.
-*/
-
-void FlashPoint_InquireTargetInfo(FlashPoint_CardHandle_T CardHandle,
-				  int TargetID,
-				  unsigned char *SynchronousPeriod,
-				  unsigned char *SynchronousOffset,
-				  unsigned char *WideTransfersActive)
-{
-  SCCBMGR_TAR_INFO *TargetInfo =
-    &sccbMgrTbl[((SCCBCARD *)CardHandle)->cardIndex][TargetID];
-  if ((TargetInfo->TarSyncCtrl & SYNC_OFFSET) > 0)
-    {
-      *SynchronousPeriod = 5 * ((TargetInfo->TarSyncCtrl >> 5) + 1);
-      *SynchronousOffset = TargetInfo->TarSyncCtrl & SYNC_OFFSET;
-    }
-  else
-    {
-      *SynchronousPeriod = 0;
-      *SynchronousOffset = 0;
-    }
-  *WideTransfersActive = (TargetInfo->TarSyncCtrl & NARROW_SCSI ? 0 : 1);
-}
-
-
 #else  /* CONFIG_SCSI_OMIT_FLASHPOINT */
 
 
@@ -12151,9 +8228,6 @@ extern int FlashPoint_AbortCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
 extern boolean FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
 extern int FlashPoint_HandleInterrupt(FlashPoint_CardHandle_T);
 extern void FlashPoint_ReleaseHostAdapter(FlashPoint_CardHandle_T);
-extern void FlashPoint_InquireTargetInfo(FlashPoint_CardHandle_T,
-					 int, unsigned char *,
-					 unsigned char *, unsigned char *);
 
 
 #endif /* CONFIG_SCSI_OMIT_FLASHPOINT */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/FlashPoint.c b/drivers/scsi/FlashPoint.c
new file mode 100644
index 000000000000..56a695c6ab52
--- /dev/null
+++ b/drivers/scsi/FlashPoint.c
@@ -0,0 +1,12159 @@
+/*
+
+  FlashPoint.c -- FlashPoint SCCB Manager for Linux
+
+  This file contains the FlashPoint SCCB Manager from BusLogic's FlashPoint
+  Driver Developer's Kit, with minor modifications by Leonard N. Zubkoff for
+  Linux compatibility.  It was provided by BusLogic in the form of 16 separate
+  source files, which would have unnecessarily cluttered the scsi directory, so
+  the individual files have been combined into this single file.
+
+  Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+
+  This file is available under both the GNU General Public License
+  and a BSD-style copyright; see LICENSE.FlashPoint for details.
+
+*/
+
+
+#include <linux/config.h>
+
+
+#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
+
+
+#define UNIX
+#define FW_TYPE		_SCCB_MGR_
+#define MAX_CARDS	8
+#undef BUSTYPE_PCI
+
+
+#define OS_InPortByte(port)		inb(port)
+#define OS_InPortWord(port)		inw(port)
+#define OS_InPortLong(port)		inl(port)
+#define OS_OutPortByte(port, value)	outb(value, port)
+#define OS_OutPortWord(port, value)	outw(value, port)
+#define OS_OutPortLong(port, value)	outl(value, port)
+#define OS_Lock(x)
+#define OS_UnLock(x)
+
+
+/*
+  Define name replacements for compatibility with the Linux BusLogic Driver.
+*/
+
+#define SccbMgr_sense_adapter		FlashPoint_ProbeHostAdapter
+#define SccbMgr_config_adapter		FlashPoint_HardwareResetHostAdapter
+#define SccbMgr_unload_card		FlashPoint_ReleaseHostAdapter
+#define SccbMgr_start_sccb		FlashPoint_StartCCB
+#define SccbMgr_abort_sccb		FlashPoint_AbortCCB
+#define SccbMgr_my_int			FlashPoint_InterruptPending
+#define SccbMgr_isr			FlashPoint_HandleInterrupt
+
+
+/*
+  Define name replacements to avoid kernel namespace pollution.
+*/
+
+#define BL_Card				FPT_BL_Card
+#define BusMasterInit			FPT_BusMasterInit
+#define CalcCrc16			FPT_CalcCrc16
+#define CalcLrc				FPT_CalcLrc
+#define ChkIfChipInitialized		FPT_ChkIfChipInitialized
+#define DiagBusMaster			FPT_DiagBusMaster
+#define DiagEEPROM			FPT_DiagEEPROM
+#define DiagXbow			FPT_DiagXbow
+#define GetTarLun			FPT_GetTarLun
+#define RNVRamData			FPT_RNVRamData
+#define RdStack				FPT_RdStack
+#define SccbMgrTableInitAll		FPT_SccbMgrTableInitAll
+#define SccbMgrTableInitCard		FPT_SccbMgrTableInitCard
+#define SccbMgrTableInitTarget		FPT_SccbMgrTableInitTarget
+#define SccbMgr_bad_isr			FPT_SccbMgr_bad_isr
+#define SccbMgr_scsi_reset		FPT_SccbMgr_scsi_reset
+#define SccbMgr_timer_expired		FPT_SccbMgr_timer_expired
+#define SendMsg				FPT_SendMsg
+#define Wait				FPT_Wait
+#define Wait1Second			FPT_Wait1Second
+#define WrStack				FPT_WrStack
+#define XbowInit			FPT_XbowInit
+#define autoCmdCmplt			FPT_autoCmdCmplt
+#define autoLoadDefaultMap		FPT_autoLoadDefaultMap
+#define busMstrDataXferStart		FPT_busMstrDataXferStart
+#define busMstrSGDataXferStart		FPT_busMstrSGDataXferStart
+#define busMstrTimeOut			FPT_busMstrTimeOut
+#define dataXferProcessor		FPT_dataXferProcessor
+#define default_intena			FPT_default_intena
+#define hostDataXferAbort		FPT_hostDataXferAbort
+#define hostDataXferRestart		FPT_hostDataXferRestart
+#define inisci				FPT_inisci
+#define mbCards				FPT_mbCards
+#define nvRamInfo			FPT_nvRamInfo
+#define phaseBusFree			FPT_phaseBusFree
+#define phaseChkFifo			FPT_phaseChkFifo
+#define phaseCommand			FPT_phaseCommand
+#define phaseDataIn			FPT_phaseDataIn
+#define phaseDataOut			FPT_phaseDataOut
+#define phaseDecode			FPT_phaseDecode
+#define phaseIllegal			FPT_phaseIllegal
+#define phaseMsgIn			FPT_phaseMsgIn
+#define phaseMsgOut			FPT_phaseMsgOut
+#define phaseStatus			FPT_phaseStatus
+#define queueAddSccb			FPT_queueAddSccb
+#define queueCmdComplete		FPT_queueCmdComplete
+#define queueDisconnect			FPT_queueDisconnect
+#define queueFindSccb			FPT_queueFindSccb
+#define queueFlushSccb			FPT_queueFlushSccb
+#define queueFlushTargSccb		FPT_queueFlushTargSccb
+#define queueSearchSelect		FPT_queueSearchSelect
+#define queueSelectFail			FPT_queueSelectFail
+#define s_PhaseTbl			FPT_s_PhaseTbl
+#define scamHAString			FPT_scamHAString
+#define scamInfo			FPT_scamInfo
+#define scarb				FPT_scarb
+#define scasid				FPT_scasid
+#define scbusf				FPT_scbusf
+#define sccbMgrTbl			FPT_sccbMgrTbl
+#define schkdd				FPT_schkdd
+#define scini				FPT_scini
+#define sciso				FPT_sciso
+#define scmachid			FPT_scmachid
+#define scsavdi				FPT_scsavdi
+#define scsel				FPT_scsel
+#define scsell				FPT_scsell
+#define scsendi				FPT_scsendi
+#define scvalq				FPT_scvalq
+#define scwirod				FPT_scwirod
+#define scwiros				FPT_scwiros
+#define scwtsel				FPT_scwtsel
+#define scxferc				FPT_scxferc
+#define sdecm				FPT_sdecm
+#define sfm				FPT_sfm
+#define shandem				FPT_shandem
+#define sinits				FPT_sinits
+#define sisyncn				FPT_sisyncn
+#define sisyncr				FPT_sisyncr
+#define siwidn				FPT_siwidn
+#define siwidr				FPT_siwidr
+#define sres				FPT_sres
+#define sresb				FPT_sresb
+#define ssel				FPT_ssel
+#define ssenss				FPT_ssenss
+#define sssyncv				FPT_sssyncv
+#define stsyncn				FPT_stsyncn
+#define stwidn				FPT_stwidn
+#define sxfrp				FPT_sxfrp
+#define utilEERead			FPT_utilEERead
+#define utilEEReadOrg			FPT_utilEEReadOrg
+#define utilEESendCmdAddr		FPT_utilEESendCmdAddr
+#define utilEEWrite			FPT_utilEEWrite
+#define utilEEWriteOnOff		FPT_utilEEWriteOnOff
+#define utilUpdateResidual		FPT_utilUpdateResidual
+
+
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   globals.h  $
+ *
+ *   Description:  Common shared global defines.
+ *
+ *   $Date: 1996/09/04 01:26:13 $
+ *
+ *   $Revision: 1.11 $
+ *
+ *----------------------------------------------------------------------*/
+#ifndef __GLOBALS_H__
+#define __GLOBALS_H__
+
+#define _UCB_MGR_  1
+#define _SCCB_MGR_ 2
+
+/*#include <osflags.h>*/
+
+#define MAX_CDBLEN  12
+
+#define SCAM_LEV_2	1
+
+#define CRCMASK	0xA001
+
+/*  In your osflags.h file, please ENSURE that only ONE OS FLAG 
+    is on at a time !!! Also, please make sure you turn set the 
+ 	 variable FW_TYPE to either _UCB_MGR_ or _SCCB_MGR_  !!! */
+
+#if defined(DOS) || defined(WIN95_16) || defined(OS2) || defined(OTHER_16)
+   #define       COMPILER_16_BIT 1
+#elif defined(NETWARE) || defined(NT) || defined(WIN95_32) || defined(UNIX) || defined(OTHER_32) || defined(SOLARIS_REAL_MODE)
+   #define       COMPILER_32_BIT 1
+#endif
+
+
+#define     BL_VENDOR_ID      0x104B
+#define     FP_DEVICE_ID      0x8130
+#define     MM_DEVICE_ID      0x1040
+
+
+#ifndef FALSE
+#define FALSE           0
+#endif
+#ifndef TRUE
+#define TRUE            (!(FALSE))
+#endif
+
+#ifndef NULL
+#define NULL            0
+#endif
+
+#define FAILURE         0xFFFFFFFFL
+
+
+typedef unsigned char   UCHAR;
+typedef unsigned short  USHORT;
+typedef unsigned int    UINT;
+typedef unsigned long   ULONG;
+typedef unsigned char * PUCHAR;
+typedef unsigned short* PUSHORT;
+typedef unsigned long * PULONG;
+typedef void *          PVOID;
+
+
+#if defined(COMPILER_16_BIT)
+typedef unsigned char far       * uchar_ptr;
+typedef unsigned short far      * ushort_ptr;
+typedef unsigned long far       * ulong_ptr;
+#endif  /* 16_BIT_COMPILER */
+
+#if defined(COMPILER_32_BIT)
+typedef unsigned char           * uchar_ptr;
+typedef unsigned short          * ushort_ptr;
+typedef unsigned long           * ulong_ptr;
+#endif  /* 32_BIT_COMPILER */
+
+
+/*	 			NEW TYPE DEFINITIONS (shared with Mylex North)
+
+**  Use following type defines to avoid confusion in 16 and 32-bit
+**  environments.  Avoid using 'int' as it denotes 16 bits in 16-bit
+**  environment and 32 in 32-bit environments.
+
+*/
+
+#define s08bits	char
+#define s16bits 	short
+#define s32bits	long
+
+#define u08bits	unsigned s08bits
+#define u16bits	unsigned s16bits
+#define u32bits	unsigned s32bits
+
+#if defined(COMPILER_16_BIT)
+
+typedef u08bits far 	* pu08bits;
+typedef u16bits far 	* pu16bits;
+typedef u32bits far	* pu32bits;
+
+#endif	/* COMPILER_16_BIT */
+
+#if defined(COMPILER_32_BIT)
+
+typedef u08bits 	* pu08bits;
+typedef u16bits 	* pu16bits;
+typedef u32bits 	* pu32bits;
+
+#endif	/* COMPILER_32_BIT */
+
+
+#define BIT(x)          ((UCHAR)(1<<(x)))    /* single-bit mask in bit position x */
+#define BITW(x)          ((USHORT)(1<<(x)))  /* single-bit mask in bit position x */
+
+
+
+#if defined(DOS)
+/*#include <dos.h>*/
+	#undef inportb          /* undefine for Borland Lib */
+	#undef inport           /* they may have define I/O function in LIB */
+	#undef outportb
+	#undef outport
+
+	#define OS_InPortByte(ioport) 		inportb(ioport)
+	#define OS_InPortWord(ioport) 		inport(ioport)
+	#define OS_InPortLong(ioport)			inportq(ioport, val)
+	#define OS_OutPortByte(ioport, val) outportb(ioport, val)
+	#define OS_OutPortWord(ioport, val)	outport(ioport, val)
+	#define OS_OutPortLong(ioport)		outportq(ioport, val)
+#endif	/* DOS */
+
+#if defined(NETWARE) || defined(OTHER_32) ||  defined(OTHER_16)
+	extern u08bits	OS_InPortByte(u32bits ioport);
+	extern u16bits	OS_InPortWord(u32bits ioport);
+	extern u32bits	OS_InPortLong(u32bits ioport);
+
+	extern OS_InPortByteBuffer(u32bits ioport, pu08bits buffer, u32bits count);
+	extern OS_InPortWordBuffer(u32bits ioport, pu16bits buffer, u32bits count);
+	extern OS_OutPortByte(u32bits ioport, u08bits val);
+	extern OS_OutPortWord(u32bits ioport, u16bits val);
+	extern OS_OutPortLong(u32bits ioport, u32bits val);
+	extern OS_OutPortByteBuffer(u32bits ioport, pu08bits buffer, u32bits count);
+	extern OS_OutPortWordBuffer(u32bits ioport, pu16bits buffer, u32bits count);
+#endif	/* NETWARE || OTHER_32 || OTHER_16 */
+
+#if defined (NT) || defined(WIN95_32) || defined(WIN95_16)
+	#if defined(NT)
+
+		extern __declspec(dllimport) u08bits ScsiPortReadPortUchar(pu08bits ioport);
+		extern __declspec(dllimport) u16bits ScsiPortReadPortUshort(pu16bits ioport);
+		extern __declspec(dllimport) u32bits ScsiPortReadPortUlong(pu32bits ioport);
+		extern __declspec(dllimport) void ScsiPortWritePortUchar(pu08bits ioport, u08bits val);
+		extern __declspec(dllimport) void ScsiPortWritePortUshort(pu16bits port, u16bits val);
+		extern __declspec(dllimport) void ScsiPortWritePortUlong(pu32bits port, u32bits val);
+
+	#else
+
+		extern u08bits ScsiPortReadPortUchar(pu08bits ioport);
+		extern u16bits ScsiPortReadPortUshort(pu16bits ioport);
+		extern u32bits ScsiPortReadPortUlong(pu32bits ioport);
+		extern void ScsiPortWritePortUchar(pu08bits ioport, u08bits val);
+		extern void ScsiPortWritePortUshort(pu16bits port, u16bits val);
+		extern void ScsiPortWritePortUlong(pu32bits port, u32bits val);
+	#endif
+
+
+	#define OS_InPortByte(ioport) ScsiPortReadPortUchar((pu08bits) ioport)
+	#define OS_InPortWord(ioport) ScsiPortReadPortUshort((pu16bits) ioport)
+	#define OS_InPortLong(ioport) ScsiPortReadPortUlong((pu32bits) ioport)
+
+	#define OS_OutPortByte(ioport, val) ScsiPortWritePortUchar((pu08bits) ioport, (u08bits) val)
+	#define OS_OutPortWord(ioport, val) ScsiPortWritePortUshort((pu16bits) ioport, (u16bits) val)
+	#define OS_OutPortLong(ioport, val) ScsiPortWritePortUlong((pu32bits) ioport, (u32bits) val)
+	#define OS_OutPortByteBuffer(ioport, buffer, count) \
+		ScsiPortWritePortBufferUchar((pu08bits)&port, (pu08bits) buffer, (u32bits) count)
+	#define OS_OutPortWordBuffer(ioport, buffer, count) \
+		ScsiPortWritePortBufferUshort((pu16bits)&port, (pu16bits) buffer, (u32bits) count)
+
+	#define OS_Lock(x)
+	#define OS_UnLock(x)
+#endif /* NT || WIN95_32 || WIN95_16 */
+
+#if defined (UNIX) && !defined(OS_InPortByte)
+	#define OS_InPortByte(ioport)    inb((u16bits)ioport)
+	#define OS_InPortWord(ioport)    inw((u16bits)ioport)
+	#define OS_InPortLong(ioport)    inl((u16bits)ioport)
+	#define OS_OutPortByte(ioport,val)  outb((u16bits)ioport, (u08bits)val)
+	#define OS_OutPortWord(ioport,val)  outw((u16bits)ioport, (u16bits)val)
+	#define OS_OutPortLong(ioport,val)  outl((u16bits)ioport, (u32bits)val)
+
+	#define OS_Lock(x)
+	#define OS_UnLock(x)
+#endif /* UNIX */
+
+
+#if defined(OS2)
+	extern u08bits	inb(u32bits ioport);
+	extern u16bits	inw(u32bits ioport);
+	extern void	outb(u32bits ioport, u08bits val);
+	extern void	outw(u32bits ioport, u16bits val);
+
+	#define OS_InPortByte(ioport)			inb(ioport)
+	#define OS_InPortWord(ioport)			inw(ioport)
+	#define OS_OutPortByte(ioport, val)	outb(ioport, val)
+	#define OS_OutPortWord(ioport, val)	outw(ioport, val)
+	extern u32bits	OS_InPortLong(u32bits ioport);
+	extern void	OS_OutPortLong(u32bits ioport, u32bits val);
+
+	#define OS_Lock(x)
+	#define OS_UnLock(x)
+#endif /* OS2 */
+
+#if defined(SOLARIS_REAL_MODE)
+
+extern unsigned char    inb(unsigned long ioport);
+extern unsigned short   inw(unsigned long ioport);
+
+#define OS_InPortByte(ioport)    inb(ioport)
+#define OS_InPortWord(ioport)    inw(ioport)
+
+extern void OS_OutPortByte(unsigned long ioport, unsigned char val);
+extern void OS_OutPortWord(unsigned long ioport, unsigned short val);
+extern unsigned long  OS_InPortLong(unsigned long ioport);
+extern void     OS_OutPortLong(unsigned long ioport, unsigned long val);
+
+#define OS_Lock(x)
+#define OS_UnLock(x)
+
+#endif  /* SOLARIS_REAL_MODE */
+
+#endif  /* __GLOBALS_H__ */
+
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   sccbmgr.h  $
+ *
+ *   Description:  Common shared SCCB Interface defines and SCCB 
+ *						 Manager specifics defines.
+ *
+ *   $Date: 1996/10/24 23:09:33 $
+ *
+ *   $Revision: 1.14 $
+ *
+ *----------------------------------------------------------------------*/
+
+#ifndef __SCCB_H__
+#define __SCCB_H__
+
+/*#include <osflags.h>*/
+/*#include <globals.h>*/
+
+#if defined(BUGBUG)
+#define debug_size 32
+#endif
+
+#if defined(DOS)
+
+   typedef struct _SCCB near *PSCCB;
+	#if (FW_TYPE == _SCCB_MGR_)
+   	typedef void (*CALL_BK_FN)(PSCCB);
+	#endif
+
+#elif defined(OS2)
+
+   typedef struct _SCCB far *PSCCB;
+	#if (FW_TYPE == _SCCB_MGR_)
+   	typedef void (far *CALL_BK_FN)(PSCCB);
+	#endif
+
+#else
+
+   typedef struct _SCCB *PSCCB;
+	#if (FW_TYPE == _SCCB_MGR_)
+   	typedef void (*CALL_BK_FN)(PSCCB);
+	#endif
+
+#endif
+
+
+typedef struct SCCBMgr_info {
+   ULONG    si_baseaddr;
+   UCHAR    si_present;
+   UCHAR    si_intvect;
+   UCHAR    si_id;
+   UCHAR    si_lun;
+   USHORT   si_fw_revision;
+   USHORT   si_per_targ_init_sync;
+   USHORT   si_per_targ_fast_nego;
+   USHORT   si_per_targ_ultra_nego;
+   USHORT   si_per_targ_no_disc;
+   USHORT   si_per_targ_wide_nego;
+   USHORT   si_flags;
+   UCHAR    si_card_family;
+   UCHAR    si_bustype;
+   UCHAR    si_card_model[3];
+   UCHAR    si_relative_cardnum;
+   UCHAR    si_reserved[4];
+   ULONG    si_OS_reserved;
+   UCHAR    si_XlatInfo[4];
+   ULONG    si_reserved2[5];
+   ULONG    si_secondary_range;
+} SCCBMGR_INFO;
+
+#if defined(DOS)
+   typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
+#else
+   #if defined (COMPILER_16_BIT)
+   typedef SCCBMGR_INFO far *  PSCCBMGR_INFO;
+   #else
+   typedef SCCBMGR_INFO *      PSCCBMGR_INFO;
+   #endif
+#endif // defined(DOS)
+
+
+
+
+#if (FW_TYPE==_SCCB_MGR_)
+	#define SCSI_PARITY_ENA		  0x0001
+	#define LOW_BYTE_TERM		  0x0010
+	#define HIGH_BYTE_TERM		  0x0020
+	#define BUSTYPE_PCI	  0x3
+#endif
+
+#define SUPPORT_16TAR_32LUN	  0x0002
+#define SOFT_RESET		  0x0004
+#define EXTENDED_TRANSLATION	  0x0008
+#define POST_ALL_UNDERRRUNS	  0x0040
+#define FLAG_SCAM_ENABLED	  0x0080
+#define FLAG_SCAM_LEVEL2	  0x0100
+
+
+
+
+#define HARPOON_FAMILY        0x02
+
+
+#define ISA_BUS_CARD          0x01
+#define EISA_BUS_CARD         0x02
+#define PCI_BUS_CARD          0x03
+#define VESA_BUS_CARD         0x04
+
+/* SCCB struc used for both SCCB and UCB manager compiles! 
+ * The UCB Manager treats the SCCB as it's 'native hardware structure' 
+ */
+
+
+#pragma pack(1)
+typedef struct _SCCB {
+   UCHAR OperationCode;
+   UCHAR ControlByte;
+   UCHAR CdbLength;
+   UCHAR RequestSenseLength;
+   ULONG DataLength;
+   ULONG DataPointer;
+   UCHAR CcbRes[2];
+   UCHAR HostStatus;
+   UCHAR TargetStatus;
+   UCHAR TargID;
+   UCHAR Lun;
+   UCHAR Cdb[12];
+   UCHAR CcbRes1;
+   UCHAR Reserved1;
+   ULONG Reserved2;
+   ULONG SensePointer;
+
+
+   CALL_BK_FN SccbCallback;                  /* VOID (*SccbCallback)(); */
+   ULONG  SccbIOPort;                        /* Identifies board base port */
+   UCHAR  SccbStatus;
+   UCHAR  SCCBRes2;
+   USHORT SccbOSFlags;
+
+
+   ULONG   Sccb_XferCnt;            /* actual transfer count */
+   ULONG   Sccb_ATC;
+   ULONG   SccbVirtDataPtr;         /* virtual addr for OS/2 */
+   ULONG   Sccb_res1;
+   USHORT  Sccb_MGRFlags;
+   USHORT  Sccb_sgseg;
+   UCHAR   Sccb_scsimsg;            /* identify msg for selection */
+   UCHAR   Sccb_tag;
+   UCHAR   Sccb_scsistat;
+   UCHAR   Sccb_idmsg;              /* image of last msg in */
+   PSCCB   Sccb_forwardlink;
+   PSCCB   Sccb_backlink;
+   ULONG   Sccb_savedATC;
+   UCHAR   Save_Cdb[6];
+   UCHAR   Save_CdbLen;
+   UCHAR   Sccb_XferState;
+   ULONG   Sccb_SGoffset;
+#if (FW_TYPE == _UCB_MGR_)
+   PUCB    Sccb_ucb_ptr;
+#endif
+   } SCCB;
+
+#define SCCB_SIZE sizeof(SCCB)
+
+#pragma pack()
+
+
+
+#define SCSI_INITIATOR_COMMAND    0x00
+#define TARGET_MODE_COMMAND       0x01
+#define SCATTER_GATHER_COMMAND    0x02
+#define RESIDUAL_COMMAND          0x03
+#define RESIDUAL_SG_COMMAND       0x04
+#define RESET_COMMAND             0x81
+
+
+#define F_USE_CMD_Q              0x20     /*Inidcates TAGGED command. */
+#define TAG_TYPE_MASK            0xC0     /*Type of tag msg to send. */
+#define TAG_Q_MASK               0xE0
+#define SCCB_DATA_XFER_OUT       0x10     /* Write */
+#define SCCB_DATA_XFER_IN        0x08     /* Read */
+
+
+#define FOURTEEN_BYTES           0x00     /* Request Sense Buffer size */
+#define NO_AUTO_REQUEST_SENSE    0x01     /* No Request Sense Buffer */
+
+
+#define BUS_FREE_ST     0       
+#define SELECT_ST       1
+#define SELECT_BDR_ST   2     /* Select w\ Bus Device Reset */
+#define SELECT_SN_ST    3     /* Select w\ Sync Nego */
+#define SELECT_WN_ST    4     /* Select w\ Wide Data Nego */
+#define SELECT_Q_ST     5     /* Select w\ Tagged Q'ing */
+#define COMMAND_ST      6
+#define DATA_OUT_ST     7
+#define DATA_IN_ST      8
+#define DISCONNECT_ST   9
+#define STATUS_ST       10
+#define ABORT_ST        11
+#define MESSAGE_ST      12
+
+
+#define F_HOST_XFER_DIR                0x01
+#define F_ALL_XFERRED                  0x02
+#define F_SG_XFER                      0x04
+#define F_AUTO_SENSE                   0x08
+#define F_ODD_BALL_CNT                 0x10
+#define F_NO_DATA_YET                  0x80
+
+
+#define F_STATUSLOADED                 0x01
+#define F_MSGLOADED                    0x02
+#define F_DEV_SELECTED                 0x04
+
+
+#define SCCB_COMPLETE               0x00  /* SCCB completed without error */
+#define SCCB_DATA_UNDER_RUN         0x0C
+#define SCCB_SELECTION_TIMEOUT      0x11  /* Set SCSI selection timed out */
+#define SCCB_DATA_OVER_RUN          0x12
+#define SCCB_UNEXPECTED_BUS_FREE    0x13  /* Target dropped SCSI BSY */
+#define SCCB_PHASE_SEQUENCE_FAIL    0x14  /* Target bus phase sequence failure */
+
+#define SCCB_INVALID_OP_CODE        0x16  /* SCCB invalid operation code */
+#define SCCB_INVALID_SCCB           0x1A  /* Invalid SCCB - bad parameter */
+#define SCCB_GROSS_FW_ERR           0x27  /* Major problem! */
+#define SCCB_BM_ERR                 0x30  /* BusMaster error. */
+#define SCCB_PARITY_ERR             0x34  /* SCSI parity error */
+
+
+
+#if (FW_TYPE==_UCB_MGR_)  
+   #define  HBA_AUTO_SENSE_FAIL        0x1B  
+   #define  HBA_TQ_REJECTED            0x1C  
+   #define  HBA_UNSUPPORTED_MSG         0x1D  
+   #define  HBA_HW_ERROR               0x20  
+   #define  HBA_ATN_NOT_RESPONDED      0x21  
+   #define  HBA_SCSI_RESET_BY_ADAPTER  0x22
+   #define  HBA_SCSI_RESET_BY_TARGET   0x23
+   #define  HBA_WRONG_CONNECTION       0x24
+   #define  HBA_BUS_DEVICE_RESET       0x25
+   #define  HBA_ABORT_QUEUE            0x26
+
+#else // these are not defined in BUDI/UCB
+
+   #define SCCB_INVALID_DIRECTION      0x18  /* Invalid target direction */
+   #define SCCB_DUPLICATE_SCCB         0x19  /* Duplicate SCCB */
+   #define SCCB_SCSI_RST               0x35  /* SCSI RESET detected. */
+
+#endif // (FW_TYPE==_UCB_MGR_)  
+
+
+#define SCCB_IN_PROCESS            0x00
+#define SCCB_SUCCESS               0x01
+#define SCCB_ABORT                 0x02
+#define SCCB_NOT_FOUND             0x03
+#define SCCB_ERROR                 0x04
+#define SCCB_INVALID               0x05
+
+#define SCCB_SIZE sizeof(SCCB)
+
+
+
+
+#if (FW_TYPE == _UCB_MGR_)
+	void SccbMgr_start_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb);
+	s32bits SccbMgr_abort_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb);
+	u08bits SccbMgr_my_int(CARD_HANDLE pCurrCard);
+	s32bits SccbMgr_isr(CARD_HANDLE pCurrCard);
+	void SccbMgr_scsi_reset(CARD_HANDLE pCurrCard);
+	void SccbMgr_timer_expired(CARD_HANDLE pCurrCard);
+	void SccbMgr_unload_card(CARD_HANDLE pCurrCard);
+	void SccbMgr_restore_foreign_state(CARD_HANDLE pCurrCard);
+	void SccbMgr_restore_native_state(CARD_HANDLE pCurrCard);
+	void SccbMgr_save_foreign_state(PADAPTER_INFO pAdapterInfo);
+
+#endif
+
+
+#if (FW_TYPE == _SCCB_MGR_)
+
+ #if defined (DOS)
+	int    SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo);
+	USHORT SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo);
+	void  SccbMgr_start_sccb(USHORT pCurrCard, PSCCB p_SCCB);
+	int   SccbMgr_abort_sccb(USHORT pCurrCard, PSCCB p_SCCB);
+	UCHAR SccbMgr_my_int(USHORT pCurrCard);
+	int   SccbMgr_isr(USHORT pCurrCard);
+	void  SccbMgr_scsi_reset(USHORT pCurrCard);
+	void  SccbMgr_timer_expired(USHORT pCurrCard);
+	USHORT SccbMgr_status(USHORT pCurrCard);
+	void SccbMgr_unload_card(USHORT pCurrCard);
+
+ #else    //non-DOS
+
+	int   SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo);
+	ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo);
+	void  SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_SCCB);
+	int   SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_SCCB);
+	UCHAR SccbMgr_my_int(ULONG pCurrCard);
+	int   SccbMgr_isr(ULONG pCurrCard);
+	void  SccbMgr_scsi_reset(ULONG pCurrCard);
+	void  SccbMgr_enable_int(ULONG pCurrCard);
+	void  SccbMgr_disable_int(ULONG pCurrCard);
+	void  SccbMgr_timer_expired(ULONG pCurrCard);
+	void SccbMgr_unload_card(ULONG pCurrCard);
+
+  #endif
+#endif  // (FW_TYPE == _SCCB_MGR_)
+
+#endif  /* __SCCB_H__ */
+
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   blx30.h  $
+ *
+ *   Description: This module contains SCCB/UCB Manager implementation
+ *                specific stuff.
+ *
+ *   $Date: 1996/11/13 18:34:22 $
+ *
+ *   $Revision: 1.10 $
+ *
+ *----------------------------------------------------------------------*/
+
+
+#ifndef __blx30_H__
+#define __blx30_H__
+
+/*#include <globals.h>*/
+
+#define  ORION_FW_REV      3110
+
+
+
+
+#define HARP_REVD    1
+
+
+#if defined(DOS)
+#define QUEUE_DEPTH     8+1            /*1 for Normal disconnect 0 for Q'ing. */
+#else
+#define QUEUE_DEPTH     254+1            /*1 for Normal disconnect 32 for Q'ing. */
+#endif   // defined(DOS)
+
+#define	MAX_MB_CARDS	4					/* Max. no of cards suppoerted on Mother Board */
+
+#define WIDE_SCSI       1
+
+#if defined(WIDE_SCSI)
+   #if defined(DOS)
+      #define MAX_SCSI_TAR    16
+      #define MAX_LUN         8
+		#define LUN_MASK			0x07
+   #else
+      #define MAX_SCSI_TAR    16
+      #define MAX_LUN         32
+		#define LUN_MASK			0x1f
+	
+   #endif
+#else
+   #define MAX_SCSI_TAR    8
+   #define MAX_LUN         8
+	#define LUN_MASK			0x07
+#endif 
+
+#if defined(HARP_REVA)
+#define SG_BUF_CNT      15             /*Number of prefetched elements. */
+#else
+#define SG_BUF_CNT      16             /*Number of prefetched elements. */
+#endif
+
+#define SG_ELEMENT_SIZE 8              /*Eight byte per element. */
+#define SG_LOCAL_MASK   0x00000000L
+#define SG_ELEMENT_MASK 0xFFFFFFFFL
+
+
+#if (FW_TYPE == _UCB_MGR_)
+	#define OPC_DECODE_NORMAL       0x0f7f
+#endif   // _UCB_MGR_
+
+
+
+#if defined(DOS)
+
+/*#include <dos.h>*/
+	#define RD_HARPOON(ioport)          (OS_InPortByte(ioport))
+	#define RDW_HARPOON(ioport)         (OS_InPortWord(ioport))
+	#define WR_HARPOON(ioport,val)      (OS_OutPortByte(ioport,val))
+	#define WRW_HARPOON(ioport,val)     (OS_OutPortWord(ioport,val))
+
+	#define RD_HARP32(port,offset,data)  asm{db 66h;         \
+                                       push ax;             \
+                                       mov dx,port;         \
+                                       add dx, offset;      \
+                                       db 66h;              \
+                                       in ax,dx;            \
+                                       db 66h;              \
+                                       mov word ptr data,ax;\
+                                       db 66h;              \
+                                       pop ax}
+
+	#define WR_HARP32(port,offset,data) asm{db 66h;          \
+                                       push ax;             \
+                                       mov dx,port;         \
+                                       add dx, offset;      \
+                                       db 66h;              \
+                                       mov ax,word ptr data;\
+                                       db 66h;              \
+                                       out dx,ax;           \
+                                       db 66h;              \
+                                       pop ax}
+#endif	/* DOS */
+
+#if defined(NETWARE) || defined(OTHER_32) ||  defined(OTHER_16)
+	#define RD_HARPOON(ioport)     OS_InPortByte((unsigned long)ioport)
+	#define RDW_HARPOON(ioport)    OS_InPortWord((unsigned long)ioport)
+	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong(ioport + offset))
+	#define WR_HARPOON(ioport,val) OS_OutPortByte((ULONG)ioport,(UCHAR) val)
+	#define WRW_HARPOON(ioport,val)  OS_OutPortWord((ULONG)ioport,(USHORT)val)
+	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((ioport + offset), data)
+#endif	/* NETWARE || OTHER_32 || OTHER_16 */
+
+#if defined(NT) || defined(WIN95_32) || defined(WIN95_16)
+	#define RD_HARPOON(ioport)          OS_InPortByte((ULONG)ioport)
+	#define RDW_HARPOON(ioport)         OS_InPortWord((ULONG)ioport)
+	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((ULONG)(ioport + offset)))
+	#define WR_HARPOON(ioport,val)      OS_OutPortByte((ULONG)ioport,(UCHAR) val)
+	#define WRW_HARPOON(ioport,val)     OS_OutPortWord((ULONG)ioport,(USHORT)val)
+	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((ULONG)(ioport + offset), data)
+#endif /* NT || WIN95_32 || WIN95_16 */
+
+#if defined (UNIX)
+	#define RD_HARPOON(ioport)          OS_InPortByte((u32bits)ioport)
+	#define RDW_HARPOON(ioport)         OS_InPortWord((u32bits)ioport)
+	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((u32bits)(ioport + offset)))
+	#define WR_HARPOON(ioport,val)      OS_OutPortByte((u32bits)ioport,(u08bits) val)
+	#define WRW_HARPOON(ioport,val)       OS_OutPortWord((u32bits)ioport,(u16bits)val)
+	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((u32bits)(ioport + offset), data)
+#endif /* UNIX */
+
+#if defined(OS2)
+	#define RD_HARPOON(ioport)          OS_InPortByte((unsigned long)ioport)
+	#define RDW_HARPOON(ioport)         OS_InPortWord((unsigned long)ioport)
+	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((ULONG)(ioport + offset)))
+	#define WR_HARPOON(ioport,val)      OS_OutPortByte((ULONG)ioport,(UCHAR) val)
+	#define WRW_HARPOON(ioport,val)       OS_OutPortWord((ULONG)ioport,(USHORT)val)
+	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong(((ULONG)(ioport + offset)), data)
+#endif /* OS2 */
+
+#if defined(SOLARIS_REAL_MODE)
+
+	#define RD_HARPOON(ioport)          OS_InPortByte((unsigned long)ioport)
+	#define RDW_HARPOON(ioport)         OS_InPortWord((unsigned long)ioport)
+	#define RD_HARP32(ioport,offset,data) (data = OS_InPortLong((ULONG)(ioport + offset)))
+	#define WR_HARPOON(ioport,val)      OS_OutPortByte((ULONG)ioport,(UCHAR) val)
+	#define WRW_HARPOON(ioport,val)       OS_OutPortWord((ULONG)ioport,(USHORT)val)
+	#define WR_HARP32(ioport,offset,data)  OS_OutPortLong((ULONG)(ioport + offset), (ULONG)data)
+
+#endif  /* SOLARIS_REAL_MODE */
+
+#endif  /* __BLX30_H__ */
+
+
+/*----------------------------------------------------------------------
+ * 
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   target.h  $
+ *
+ *   Description:  Definitions for Target related structures
+ *
+ *   $Date: 1996/12/11 22:06:20 $
+ *
+ *   $Revision: 1.9 $
+ *
+ *----------------------------------------------------------------------*/
+
+#ifndef __TARGET__
+#define __TARGET__
+
+/*#include <globals.h>*/
+/*#include <blx30.h>*/
+
+
+#define  TAR_SYNC_MASK     (BIT(7)+BIT(6))
+#define  SYNC_UNKNOWN      0x00
+#define  SYNC_TRYING               BIT(6)
+#define  SYNC_SUPPORTED    (BIT(7)+BIT(6))
+
+#define  TAR_WIDE_MASK     (BIT(5)+BIT(4))
+#define  WIDE_DISABLED     0x00
+#define  WIDE_ENABLED              BIT(4)
+#define  WIDE_NEGOCIATED   BIT(5)
+
+#define  TAR_TAG_Q_MASK    (BIT(3)+BIT(2))
+#define  TAG_Q_UNKNOWN     0x00
+#define  TAG_Q_TRYING              BIT(2)
+#define  TAG_Q_REJECT      BIT(3)
+#define  TAG_Q_SUPPORTED   (BIT(3)+BIT(2))
+
+#define  TAR_ALLOW_DISC    BIT(0)
+
+
+#define  EE_SYNC_MASK      (BIT(0)+BIT(1))
+#define  EE_SYNC_ASYNC     0x00
+#define  EE_SYNC_5MB       BIT(0)
+#define  EE_SYNC_10MB      BIT(1)
+#define  EE_SYNC_20MB      (BIT(0)+BIT(1))
+
+#define  EE_ALLOW_DISC     BIT(6)
+#define  EE_WIDE_SCSI      BIT(7)
+
+
+#if defined(DOS)
+   typedef struct SCCBMgr_tar_info near *PSCCBMgr_tar_info;
+
+#elif defined(OS2)
+   typedef struct SCCBMgr_tar_info far *PSCCBMgr_tar_info;
+
+#else
+   typedef struct SCCBMgr_tar_info *PSCCBMgr_tar_info;
+
+#endif
+
+
+typedef struct SCCBMgr_tar_info {
+
+   PSCCB    TarSelQ_Head;
+   PSCCB    TarSelQ_Tail;
+   UCHAR    TarLUN_CA;        /*Contingent Allgiance */
+   UCHAR    TarTagQ_Cnt;
+   UCHAR    TarSelQ_Cnt;
+   UCHAR    TarStatus;
+   UCHAR    TarEEValue;
+   UCHAR 	TarSyncCtrl;
+   UCHAR 	TarReserved[2];			/* for alignment */ 
+   UCHAR 	LunDiscQ_Idx[MAX_LUN];
+   UCHAR    TarLUNBusy[MAX_LUN];
+} SCCBMGR_TAR_INFO;
+
+typedef struct NVRAMInfo {
+	UCHAR		niModel;								/* Model No. of card */
+	UCHAR		niCardNo;							/* Card no. */
+#if defined(DOS)
+	USHORT	niBaseAddr;							/* Port Address of card */
+#else
+	ULONG		niBaseAddr;							/* Port Address of card */
+#endif
+	UCHAR		niSysConf;							/* Adapter Configuration byte - Byte 16 of eeprom map */
+	UCHAR		niScsiConf;							/* SCSI Configuration byte - Byte 17 of eeprom map */
+	UCHAR		niScamConf;							/* SCAM Configuration byte - Byte 20 of eeprom map */
+	UCHAR		niAdapId;							/* Host Adapter ID - Byte 24 of eerpom map */
+	UCHAR		niSyncTbl[MAX_SCSI_TAR / 2];	/* Sync/Wide byte of targets */
+	UCHAR		niScamTbl[MAX_SCSI_TAR][4];	/* Compressed Scam name string of Targets */
+}NVRAMINFO;
+
+#if defined(DOS)
+typedef NVRAMINFO near *PNVRamInfo;
+#elif defined (OS2)
+typedef NVRAMINFO far *PNVRamInfo;
+#else
+typedef NVRAMINFO *PNVRamInfo;
+#endif
+
+#define	MODEL_LT		1
+#define	MODEL_DL		2
+#define	MODEL_LW		3
+#define	MODEL_DW		4
+
+
+typedef struct SCCBcard {
+   PSCCB currentSCCB;
+#if (FW_TYPE==_SCCB_MGR_)
+   PSCCBMGR_INFO cardInfo;
+#else
+   PADAPTER_INFO cardInfo;
+#endif
+
+#if defined(DOS)
+   USHORT ioPort;
+#else
+   ULONG ioPort;
+#endif
+
+   USHORT cmdCounter;
+   UCHAR  discQCount;
+   UCHAR  tagQ_Lst; 
+   UCHAR cardIndex;
+   UCHAR scanIndex;
+   UCHAR globalFlags;
+   UCHAR ourId;
+   PNVRamInfo pNvRamInfo;
+   PSCCB discQ_Tbl[QUEUE_DEPTH]; 
+      
+}SCCBCARD;
+
+#if defined(DOS)
+typedef struct SCCBcard near *PSCCBcard;
+#elif defined (OS2)
+typedef struct SCCBcard far *PSCCBcard;
+#else
+typedef struct SCCBcard *PSCCBcard;
+#endif
+
+
+#define F_TAG_STARTED		0x01
+#define F_CONLUN_IO			0x02
+#define F_DO_RENEGO			0x04
+#define F_NO_FILTER			0x08
+#define F_GREEN_PC			0x10
+#define F_HOST_XFER_ACT		0x20
+#define F_NEW_SCCB_CMD		0x40
+#define F_UPDATE_EEPROM		0x80
+
+
+#define  ID_STRING_LENGTH  32
+#define  TYPE_CODE0        0x63           /*Level2 Mstr (bits 7-6),  */
+
+#define  TYPE_CODE1        00             /*No ID yet */
+
+#define  SLV_TYPE_CODE0    0xA3           /*Priority Bit set (bits 7-6),  */
+
+#define  ASSIGN_ID   0x00
+#define  SET_P_FLAG  0x01
+#define  CFG_CMPLT   0x03
+#define  DOM_MSTR    0x0F
+#define  SYNC_PTRN   0x1F
+
+#define  ID_0_7      0x18
+#define  ID_8_F      0x11
+#define  ID_10_17    0x12
+#define  ID_18_1F    0x0B
+#define  MISC_CODE   0x14
+#define  CLR_P_FLAG  0x18
+#define  LOCATE_ON   0x12
+#define  LOCATE_OFF  0x0B
+
+#define  LVL_1_MST   0x00
+#define  LVL_2_MST   0x40
+#define  DOM_LVL_2   0xC0
+
+
+#define  INIT_SELTD  0x01
+#define  LEVEL2_TAR  0x02
+
+
+enum scam_id_st { ID0,ID1,ID2,ID3,ID4,ID5,ID6,ID7,ID8,ID9,ID10,ID11,ID12,
+                  ID13,ID14,ID15,ID_UNUSED,ID_UNASSIGNED,ID_ASSIGNED,LEGACY,
+                  CLR_PRIORITY,NO_ID_AVAIL };
+
+typedef struct SCCBscam_info {
+
+   UCHAR    id_string[ID_STRING_LENGTH];
+   enum scam_id_st state;
+    
+} SCCBSCAM_INFO, *PSCCBSCAM_INFO;
+
+#endif
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   scsi2.h  $
+ *
+ *   Description:  Register definitions for HARPOON ASIC.
+ *
+ *   $Date: 1996/11/13 18:32:57 $
+ *
+ *   $Revision: 1.4 $
+ *
+ *----------------------------------------------------------------------*/
+
+#ifndef __SCSI_H__
+#define __SCSI_H__
+
+
+
+#define  SCSI_TEST_UNIT_READY    0x00
+#define  SCSI_REZERO_UNIT        0x01
+#define  SCSI_REQUEST_SENSE      0x03
+#define  SCSI_FORMAT_UNIT        0x04
+#define  SCSI_REASSIGN           0x07
+#define  SCSI_READ               0x08
+#define  SCSI_WRITE              0x0A
+#define  SCSI_SEEK               0x0B
+#define  SCSI_INQUIRY            0x12
+#define  SCSI_MODE_SELECT        0x15
+#define  SCSI_RESERVE_UNIT       0x16
+#define  SCSI_RELEASE_UNIT       0x17
+#define  SCSI_MODE_SENSE         0x1A
+#define  SCSI_START_STOP_UNIT    0x1B
+#define  SCSI_SEND_DIAGNOSTIC    0x1D
+#define  SCSI_READ_CAPACITY      0x25
+#define  SCSI_READ_EXTENDED      0x28
+#define  SCSI_WRITE_EXTENDED     0x2A
+#define  SCSI_SEEK_EXTENDED      0x2B
+#define  SCSI_WRITE_AND_VERIFY   0x2E
+#define  SCSI_VERIFY             0x2F
+#define  SCSI_READ_DEFECT_DATA   0x37
+#define  SCSI_WRITE_BUFFER       0x3B
+#define  SCSI_READ_BUFFER        0x3C
+#define  SCSI_RECV_DIAGNOSTIC    0x1C
+#define  SCSI_READ_LONG          0x3E
+#define  SCSI_WRITE_LONG         0x3F
+#define  SCSI_LAST_SCSI_CMND     SCSI_WRITE_LONG
+#define  SCSI_INVALID_CMND       0xFF
+
+
+
+#define  SSGOOD                  0x00
+#define  SSCHECK                 0x02
+#define  SSCOND_MET              0x04
+#define  SSBUSY                  0x08
+#define  SSRESERVATION_CONFLICT  0x18
+#define  SSCMD_TERM              0x22
+#define  SSQ_FULL                0x28
+
+
+#define  SKNO_SEN                0x00
+#define  SKRECOV_ERR             0x01
+#define  SKNOT_RDY               0x02
+#define  SKMED_ERR               0x03
+#define  SKHW_ERR                0x04
+#define  SKILL_REQ               0x05
+#define  SKUNIT_ATTN             0x06
+#define  SKDATA_PROTECT          0x07
+#define  SKBLNK_CHK              0x08
+#define  SKCPY_ABORT             0x0A
+#define  SKABORT_CMD             0x0B
+#define  SKEQUAL                 0x0C
+#define  SKVOL_OVF               0x0D
+#define  SKMIS_CMP               0x0E
+
+
+#define  SMCMD_COMP              0x00
+#define  SMEXT                   0x01
+#define  SMSAVE_DATA_PTR         0x02
+#define  SMREST_DATA_PTR         0x03
+#define  SMDISC                  0x04
+#define  SMINIT_DETEC_ERR        0x05
+#define  SMABORT                 0x06
+#define  SMREJECT                0x07
+#define  SMNO_OP                 0x08
+#define  SMPARITY                0x09
+#define  SMDEV_RESET             0x0C
+#define	SMABORT_TAG					0x0D
+#define	SMINIT_RECOVERY			0x0F
+#define	SMREL_RECOVERY				0x10
+
+#define  SMIDENT                 0x80
+#define  DISC_PRIV               0x40
+
+
+#define  SMSYNC                  0x01
+#define  SM10MBS                 0x19     /* 100ns           */
+#define  SM5MBS                  0x32     /* 200ns           */
+#define  SMOFFSET                0x0F     /* Maxoffset value */
+#define  SMWDTR                  0x03
+#define  SM8BIT                  0x00
+#define  SM16BIT                 0x01
+#define  SM32BIT                 0x02
+#define  SMIGNORWR               0x23     /* Ignore Wide Residue */
+
+
+#define  ARBITRATION_DELAY       0x01     /* 2.4us using a 40Mhz clock */
+#define  BUS_SETTLE_DELAY        0x01     /* 400ns */
+#define  BUS_CLEAR_DELAY         0x01     /* 800ns */
+
+
+
+#define  SPHASE_TO               0x0A  /* 10 second timeout waiting for */
+#define  SCMD_TO                 0x0F  /* Overall command timeout */
+
+
+
+#define  SIX_BYTE_CMD            0x06
+#define  TEN_BYTE_CMD            0x0A
+#define  TWELVE_BYTE_CMD         0x0C
+
+#define  ASYNC                   0x00
+#define  PERI25NS                0x06  /* 25/4ns to next clock for xbow. */
+#define  SYNC10MBS               0x19
+#define  SYNC5MBS                0x32
+#define  MAX_OFFSET              0x0F  /* Maxbyteoffset for Sync Xfers */
+
+#endif
+/*----------------------------------------------------------------------
+ *  
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   eeprom.h  $
+ *
+ *   Description:  Definitions for EEPROM related structures
+ *
+ *   $Date: 1996/11/13 18:28:39 $
+ *
+ *   $Revision: 1.4 $
+ *
+ *----------------------------------------------------------------------*/
+
+#ifndef __EEPROM__
+#define __EEPROM__
+
+/*#include <globals.h>*/
+
+#define  EEPROM_WD_CNT     256
+
+#define  EEPROM_CHECK_SUM  0
+#define  FW_SIGNATURE      2
+#define  MODEL_NUMB_0      4
+#define  MODEL_NUMB_1      5
+#define  MODEL_NUMB_2      6
+#define  MODEL_NUMB_3      7
+#define  MODEL_NUMB_4      8
+#define  MODEL_NUMB_5      9
+#define  IO_BASE_ADDR      10
+#define  IRQ_NUMBER        12
+#define  PCI_INT_PIN       13
+#define  BUS_DELAY         14       /*On time in byte 14 off delay in 15 */
+#define  SYSTEM_CONFIG     16
+#define  SCSI_CONFIG       17
+#define  BIOS_CONFIG       18
+#define  SPIN_UP_DELAY     19
+#define  SCAM_CONFIG       20
+#define  ADAPTER_SCSI_ID   24
+
+
+#define  IGNORE_B_SCAN     32
+#define  SEND_START_ENA    34
+#define  DEVICE_ENABLE     36
+
+#define  SYNC_RATE_TBL     38
+#define  SYNC_RATE_TBL01   38
+#define  SYNC_RATE_TBL23   40
+#define  SYNC_RATE_TBL45   42
+#define  SYNC_RATE_TBL67   44
+#define  SYNC_RATE_TBL89   46
+#define  SYNC_RATE_TBLab   48
+#define  SYNC_RATE_TBLcd   50
+#define  SYNC_RATE_TBLef   52
+
+
+
+#define  EE_SCAMBASE      256 
+
+
+
+   #define  DOM_MASTER     (BIT(0) + BIT(1))
+   #define  SCAM_ENABLED   BIT(2)
+   #define  SCAM_LEVEL2    BIT(3)
+
+
+	#define	RENEGO_ENA		BITW(10)
+	#define	CONNIO_ENA		BITW(11)
+   #define  GREEN_PC_ENA   BITW(12)
+
+
+   #define  AUTO_RATE_00   00
+   #define  AUTO_RATE_05   01
+   #define  AUTO_RATE_10   02
+   #define  AUTO_RATE_20   03
+
+   #define  WIDE_NEGO_BIT     BIT(7)
+   #define  DISC_ENABLE_BIT   BIT(6)
+
+
+#endif
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   harpoon.h  $
+ *
+ *   Description:  Register definitions for HARPOON ASIC.
+ *
+ *   $Date: 1997/07/09 21:44:36 $
+ *
+ *   $Revision: 1.9 $
+ *
+ *----------------------------------------------------------------------*/
+
+
+/*#include <globals.h>*/
+
+#ifndef __HARPOON__
+#define __HARPOON__
+
+
+   #define  hp_vendor_id_0       0x00		/* LSB */
+      #define  ORION_VEND_0   0x4B
+ 
+   #define  hp_vendor_id_1       0x01		/* MSB */
+      #define  ORION_VEND_1   0x10
+
+   #define  hp_device_id_0       0x02		/* LSB */
+      #define  ORION_DEV_0    0x30 
+
+   #define  hp_device_id_1       0x03		/* MSB */
+      #define  ORION_DEV_1    0x81 
+
+	/* Sub Vendor ID and Sub Device ID only available in
+		Harpoon Version 2 and higher */
+
+   #define  hp_sub_vendor_id_0   0x04		/* LSB */
+   #define  hp_sub_vendor_id_1   0x05		/* MSB */
+   #define  hp_sub_device_id_0   0x06		/* LSB */
+   #define  hp_sub_device_id_1   0x07		/* MSB */
+
+
+   #define  hp_dual_addr_lo      0x08
+   #define  hp_dual_addr_lmi     0x09
+   #define  hp_dual_addr_hmi     0x0A
+   #define  hp_dual_addr_hi      0x0B
+
+   #define  hp_semaphore         0x0C
+      #define SCCB_MGR_ACTIVE    BIT(0)
+      #define TICKLE_ME          BIT(1)
+      #define SCCB_MGR_PRESENT   BIT(3)
+      #define BIOS_IN_USE        BIT(4)
+
+   #define  hp_user_defined_D    0x0D
+
+   #define  hp_reserved_E        0x0E
+
+   #define  hp_sys_ctrl          0x0F
+
+      #define  STOP_CLK          BIT(0)      /*Turn off BusMaster Clock */
+      #define  DRVR_RST          BIT(1)      /*Firmware Reset to 80C15 chip */
+      #define  HALT_MACH         BIT(3)      /*Halt State Machine      */
+      #define  HARD_ABORT        BIT(4)      /*Hard Abort              */
+      #define  DIAG_MODE         BIT(5)      /*Diagnostic Mode         */
+
+      #define  BM_ABORT_TMOUT    0x50        /*Halt State machine time out */
+
+   #define  hp_sys_cfg           0x10
+
+      #define  DONT_RST_FIFO     BIT(7)      /*Don't reset FIFO      */
+
+
+   #define  hp_host_ctrl0        0x11
+
+      #define  DUAL_ADDR_MODE    BIT(0)   /*Enable 64-bit addresses */
+      #define  IO_MEM_SPACE      BIT(1)   /*I/O Memory Space    */
+      #define  RESOURCE_LOCK     BIT(2)   /*Enable Resource Lock */
+      #define  IGNOR_ACCESS_ERR  BIT(3)   /*Ignore Access Error */
+      #define  HOST_INT_EDGE     BIT(4)   /*Host interrupt level/edge mode sel */
+      #define  SIX_CLOCKS        BIT(5)   /*6 Clocks between Strobe   */
+      #define  DMA_EVEN_PARITY   BIT(6)   /*Enable DMA Enen Parity */
+
+/*
+      #define  BURST_MODE        BIT(0)
+*/
+
+   #define  hp_reserved_12       0x12
+
+   #define  hp_host_blk_cnt      0x13
+
+      #define  XFER_BLK1         0x00     /*     0 0 0  1 byte per block*/
+      #define  XFER_BLK2         0x01     /*     0 0 1  2 byte per block*/
+      #define  XFER_BLK4         0x02     /*     0 1 0  4 byte per block*/
+      #define  XFER_BLK8         0x03     /*     0 1 1  8 byte per block*/
+      #define  XFER_BLK16        0x04     /*     1 0 0 16 byte per block*/
+      #define  XFER_BLK32        0x05     /*     1 0 1 32 byte per block*/
+      #define  XFER_BLK64        0x06     /*     1 1 0 64 byte per block*/
+   
+      #define  BM_THRESHOLD      0x40     /* PCI mode can only xfer 16 bytes*/
+
+
+   #define  hp_reserved_14       0x14
+   #define  hp_reserved_15       0x15
+   #define  hp_reserved_16       0x16
+
+   #define  hp_int_mask          0x17
+
+      #define  INT_CMD_COMPL     BIT(0)   /* DMA command complete   */
+      #define  INT_EXT_STATUS    BIT(1)   /* Extended Status Set    */
+      #define  INT_SCSI          BIT(2)   /* Scsi block interrupt   */
+      #define  INT_FIFO_RDY      BIT(4)   /* FIFO data ready        */
+
+
+   #define  hp_xfer_cnt_lo       0x18
+   #define  hp_xfer_cnt_mi       0x19
+   #define  hp_xfer_cnt_hi       0x1A
+   #define  hp_xfer_cmd          0x1B
+
+      #define  XFER_HOST_DMA     0x00     /*     0 0 0 Transfer Host -> DMA */
+      #define  XFER_DMA_HOST     0x01     /*     0 0 1 Transfer DMA  -> Host */
+      #define  XFER_HOST_MPU     0x02     /*     0 1 0 Transfer Host -> MPU  */
+      #define  XFER_MPU_HOST     0x03     /*     0 1 1 Transfer MPU  -> Host */
+      #define  XFER_DMA_MPU      0x04     /*     1 0 0 Transfer DMA  -> MPU  */
+      #define  XFER_MPU_DMA      0x05     /*     1 0 1 Transfer MPU  -> DMA  */
+      #define  SET_SEMAPHORE     0x06     /*     1 1 0 Set Semaphore         */
+      #define  XFER_NOP          0x07     /*     1 1 1 Transfer NOP          */
+      #define  XFER_MB_MPU       0x06     /*     1 1 0 Transfer MB -> MPU */
+      #define  XFER_MB_DMA       0x07     /*     1 1 1 Transfer MB -> DMA */
+
+
+      #define  XFER_HOST_AUTO    0x00     /*     0 0 Auto Transfer Size   */
+      #define  XFER_HOST_8BIT    0x08     /*     0 1 8 BIT Transfer Size  */
+      #define  XFER_HOST_16BIT   0x10     /*     1 0 16 BIT Transfer Size */
+      #define  XFER_HOST_32BIT   0x18     /*     1 1 32 BIT Transfer Size */
+
+      #define  XFER_DMA_8BIT     0x20     /*     0 1 8 BIT  Transfer Size */
+      #define  XFER_DMA_16BIT    0x40     /*     1 0 16 BIT Transfer Size */
+
+      #define  DISABLE_INT       BIT(7)   /*Do not interrupt at end of cmd. */
+
+      #define  HOST_WRT_CMD      ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_8BIT))
+      #define  HOST_RD_CMD       ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_8BIT))
+      #define  WIDE_HOST_WRT_CMD ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_16BIT))
+      #define  WIDE_HOST_RD_CMD  ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_16BIT))
+
+   #define  hp_host_addr_lo      0x1C
+   #define  hp_host_addr_lmi     0x1D
+   #define  hp_host_addr_hmi     0x1E
+   #define  hp_host_addr_hi      0x1F
+
+   #define  hp_pio_data          0x20
+   #define  hp_reserved_21       0x21
+   #define  hp_ee_ctrl           0x22
+
+      #define  EXT_ARB_ACK       BIT(7)
+      #define  SCSI_TERM_ENA_H   BIT(6)   /* SCSI high byte terminator */
+      #define  SEE_MS            BIT(5)
+      #define  SEE_CS            BIT(3)
+      #define  SEE_CLK           BIT(2)
+      #define  SEE_DO            BIT(1)
+      #define  SEE_DI            BIT(0)
+
+      #define  EE_READ           0x06
+      #define  EE_WRITE          0x05
+      #define  EWEN              0x04
+      #define  EWEN_ADDR         0x03C0
+      #define  EWDS              0x04
+      #define  EWDS_ADDR         0x0000
+
+   #define  hp_brdctl            0x23
+
+      #define  DAT_7             BIT(7)
+      #define  DAT_6             BIT(6)
+      #define  DAT_5             BIT(5)
+      #define  BRD_STB           BIT(4)
+      #define  BRD_CS            BIT(3)
+      #define  BRD_WR            BIT(2)
+
+   #define  hp_reserved_24       0x24
+   #define  hp_reserved_25       0x25
+
+
+
+
+   #define  hp_bm_ctrl           0x26
+
+      #define  SCSI_TERM_ENA_L   BIT(0)   /*Enable/Disable external terminators */
+      #define  FLUSH_XFER_CNTR   BIT(1)   /*Flush transfer counter */
+      #define  BM_XFER_MIN_8     BIT(2)   /*Enable bus master transfer of 9 */
+      #define  BIOS_ENA          BIT(3)   /*Enable BIOS/FLASH Enable */
+      #define  FORCE1_XFER       BIT(5)   /*Always xfer one byte in byte mode */
+      #define  FAST_SINGLE       BIT(6)   /*?? */
+
+      #define  BMCTRL_DEFAULT    (FORCE1_XFER|FAST_SINGLE|SCSI_TERM_ENA_L)
+
+   #define  hp_reserved_27       0x27
+
+   #define  hp_sg_addr           0x28
+   #define  hp_page_ctrl         0x29
+
+      #define  SCATTER_EN        BIT(0)   
+      #define  SGRAM_ARAM        BIT(1)   
+      #define  BIOS_SHADOW       BIT(2)   
+      #define  G_INT_DISABLE     BIT(3)   /* Enable/Disable all Interrupts */
+      #define  NARROW_SCSI_CARD  BIT(4)   /* NARROW/WIDE SCSI config pin */
+
+   #define  hp_reserved_2A       0x2A
+   #define  hp_pci_cmd_cfg       0x2B
+
+      #define  IO_SPACE_ENA      BIT(0)   /*enable I/O space */
+      #define  MEM_SPACE_ENA     BIT(1)   /*enable memory space */
+      #define  BUS_MSTR_ENA      BIT(2)   /*enable bus master operation */
+      #define  MEM_WI_ENA        BIT(4)   /*enable Write and Invalidate */
+      #define  PAR_ERR_RESP      BIT(6)   /*enable parity error responce. */
+
+   #define  hp_reserved_2C       0x2C
+
+   #define  hp_pci_stat_cfg      0x2D
+
+      #define  DATA_PARITY_ERR   BIT(0)   
+      #define  REC_TARGET_ABORT  BIT(4)   /*received Target abort */
+      #define  REC_MASTER_ABORT  BIT(5)   /*received Master abort */
+      #define  SIG_SYSTEM_ERR    BIT(6)   
+      #define  DETECTED_PAR_ERR  BIT(7)   
+
+   #define  hp_reserved_2E       0x2E
+
+   #define  hp_sys_status        0x2F
+
+      #define  SLV_DATA_RDY      BIT(0)   /*Slave data ready */
+      #define  XFER_CNT_ZERO     BIT(1)   /*Transfer counter = 0 */
+      #define  BM_FIFO_EMPTY     BIT(2)   /*FIFO empty */
+      #define  BM_FIFO_FULL      BIT(3)   /*FIFO full */
+      #define  HOST_OP_DONE      BIT(4)   /*host operation done */
+      #define  DMA_OP_DONE       BIT(5)   /*DMA operation done */
+      #define  SLV_OP_DONE       BIT(6)   /*Slave operation done */
+      #define  PWR_ON_FLAG       BIT(7)   /*Power on flag */
+
+   #define  hp_reserved_30       0x30
+
+   #define  hp_host_status0      0x31
+
+      #define  HOST_TERM         BIT(5)   /*Host Terminal Count */
+      #define  HOST_TRSHLD       BIT(6)   /*Host Threshold      */
+      #define  CONNECTED_2_HOST  BIT(7)   /*Connected to Host   */
+
+   #define  hp_reserved_32       0x32
+
+   #define  hp_rev_num           0x33
+
+      #define  REV_A_CONST       0x0E
+      #define  REV_B_CONST       0x0E
+
+   #define  hp_stack_data        0x34
+   #define  hp_stack_addr        0x35
+
+   #define  hp_ext_status        0x36
+
+      #define  BM_FORCE_OFF      BIT(0)   /*Bus Master is forced to get off */
+      #define  PCI_TGT_ABORT     BIT(0)   /*PCI bus master transaction aborted */
+      #define  PCI_DEV_TMOUT     BIT(1)   /*PCI Device Time out */
+      #define  FIFO_TC_NOT_ZERO  BIT(2)   /*FIFO or transfer counter not zero */
+      #define  CHIP_RST_OCCUR    BIT(3)   /*Chip reset occurs */
+      #define  CMD_ABORTED       BIT(4)   /*Command aborted */
+      #define  BM_PARITY_ERR     BIT(5)   /*parity error on data received   */
+      #define  PIO_OVERRUN       BIT(6)   /*Slave data overrun */
+      #define  BM_CMD_BUSY       BIT(7)   /*Bus master transfer command busy */
+      #define  BAD_EXT_STATUS    (BM_FORCE_OFF | PCI_DEV_TMOUT | CMD_ABORTED | \
+                                  BM_PARITY_ERR | PIO_OVERRUN)
+
+   #define  hp_int_status        0x37
+      
+      #define  BM_CMD_CMPL       BIT(0)   /*Bus Master command complete */
+      #define  EXT_STATUS_ON     BIT(1)   /*Extended status is valid */
+      #define  SCSI_INTERRUPT    BIT(2)   /*Global indication of a SCSI int. */
+      #define  BM_FIFO_RDY       BIT(4)   
+      #define  INT_ASSERTED      BIT(5)   /* */
+      #define  SRAM_BUSY         BIT(6)   /*Scatter/Gather RAM busy */
+      #define  CMD_REG_BUSY      BIT(7)                                       
+
+
+   #define  hp_fifo_cnt          0x38
+   #define  hp_curr_host_cnt     0x39
+   #define  hp_reserved_3A       0x3A
+   #define  hp_fifo_in_addr      0x3B
+
+   #define  hp_fifo_out_addr     0x3C
+   #define  hp_reserved_3D       0x3D
+   #define  hp_reserved_3E       0x3E
+   #define  hp_reserved_3F       0x3F
+
+
+
+   extern USHORT default_intena;
+
+   #define  hp_intena		 0x40
+
+      #define  RESET		 BITW(7)
+      #define  PROG_HLT		 BITW(6)  
+      #define  PARITY		 BITW(5)
+      #define  FIFO		 BITW(4)
+      #define  SEL		 BITW(3)
+      #define  SCAM_SEL		 BITW(2) 
+      #define  RSEL		 BITW(1)
+      #define  TIMEOUT		 BITW(0)
+      #define  BUS_FREE		 BITW(15)
+      #define  XFER_CNT_0	 BITW(14)
+      #define  PHASE		 BITW(13)
+      #define  IUNKWN		 BITW(12)
+      #define  ICMD_COMP	 BITW(11)
+      #define  ITICKLE		 BITW(10)
+      #define  IDO_STRT		 BITW(9)
+      #define  ITAR_DISC	 BITW(8)
+      #define  AUTO_INT		 (BITW(12)+BITW(11)+BITW(10)+BITW(9)+BITW(8))
+      #define  CLR_ALL_INT	 0xFFFF
+      #define  CLR_ALL_INT_1	 0xFF00
+
+   #define  hp_intstat		 0x42
+
+   #define  hp_scsisig           0x44
+
+      #define  SCSI_SEL          BIT(7)
+      #define  SCSI_BSY          BIT(6)
+      #define  SCSI_REQ          BIT(5)
+      #define  SCSI_ACK          BIT(4)
+      #define  SCSI_ATN          BIT(3)
+      #define  SCSI_CD           BIT(2)
+      #define  SCSI_MSG          BIT(1)
+      #define  SCSI_IOBIT        BIT(0)
+
+      #define  S_SCSI_PHZ        (BIT(2)+BIT(1)+BIT(0))
+      #define  S_CMD_PH          (BIT(2)              )
+      #define  S_MSGO_PH         (BIT(2)+BIT(1)       )
+      #define  S_STAT_PH         (BIT(2)       +BIT(0))
+      #define  S_MSGI_PH         (BIT(2)+BIT(1)+BIT(0))
+      #define  S_DATAI_PH        (              BIT(0))
+      #define  S_DATAO_PH        0x00
+      #define  S_ILL_PH          (       BIT(1)       )
+
+   #define  hp_scsictrl_0        0x45
+
+      #define  NO_ARB            BIT(7)
+      #define  SEL_TAR           BIT(6)
+      #define  ENA_ATN           BIT(4)
+      #define  ENA_RESEL         BIT(2)
+      #define  SCSI_RST          BIT(1)
+      #define  ENA_SCAM_SEL      BIT(0)
+
+
+
+   #define  hp_portctrl_0        0x46
+
+      #define  SCSI_PORT         BIT(7)
+      #define  SCSI_INBIT        BIT(6)
+      #define  DMA_PORT          BIT(5)
+      #define  DMA_RD            BIT(4)
+      #define  HOST_PORT         BIT(3)
+      #define  HOST_WRT          BIT(2)
+      #define  SCSI_BUS_EN       BIT(1)
+      #define  START_TO          BIT(0)
+
+   #define  hp_scsireset         0x47
+
+      #define  SCSI_TAR          BIT(7)
+      #define  SCSI_INI          BIT(6)
+      #define  SCAM_EN           BIT(5)
+      #define  ACK_HOLD          BIT(4)
+      #define  DMA_RESET         BIT(3)
+      #define  HPSCSI_RESET      BIT(2)
+      #define  PROG_RESET        BIT(1)
+      #define  FIFO_CLR          BIT(0)
+
+   #define  hp_xfercnt_0         0x48
+   #define  hp_xfercnt_1         0x49
+   #define  hp_xfercnt_2         0x4A
+   #define  hp_xfercnt_3         0x4B
+
+   #define  hp_fifodata_0        0x4C
+   #define  hp_fifodata_1        0x4D
+   #define  hp_addstat           0x4E
+
+      #define  SCAM_TIMER        BIT(7)
+      #define  AUTO_RUNNING      BIT(6)
+      #define  FAST_SYNC         BIT(5)
+      #define  SCSI_MODE8        BIT(3)
+      #define  SCSI_PAR_ERR      BIT(0)
+
+   #define  hp_prgmcnt_0         0x4F
+
+      #define  AUTO_PC_MASK      0x3F
+
+   #define  hp_selfid_0          0x50
+   #define  hp_selfid_1          0x51
+   #define  hp_arb_id            0x52
+
+      #define  ARB_ID            (BIT(3) + BIT(2) + BIT(1) + BIT(0))
+
+   #define  hp_select_id         0x53
+
+      #define  RESEL_ID          (BIT(7) + BIT(6) + BIT(5) + BIT(4))
+      #define  SELECT_ID         (BIT(3) + BIT(2) + BIT(1) + BIT(0))
+
+   #define  hp_synctarg_base     0x54
+   #define  hp_synctarg_12       0x54
+   #define  hp_synctarg_13       0x55
+   #define  hp_synctarg_14       0x56
+   #define  hp_synctarg_15       0x57
+
+   #define  hp_synctarg_8        0x58
+   #define  hp_synctarg_9        0x59
+   #define  hp_synctarg_10       0x5A
+   #define  hp_synctarg_11       0x5B
+
+   #define  hp_synctarg_4        0x5C
+   #define  hp_synctarg_5        0x5D
+   #define  hp_synctarg_6        0x5E
+   #define  hp_synctarg_7        0x5F
+
+   #define  hp_synctarg_0        0x60
+   #define  hp_synctarg_1        0x61
+   #define  hp_synctarg_2        0x62
+   #define  hp_synctarg_3        0x63
+
+      #define  RATE_20MB         0x00
+      #define  RATE_10MB         (              BIT(5))
+      #define  RATE_6_6MB        (       BIT(6)       )   
+      #define  RATE_5MB          (       BIT(6)+BIT(5))
+      #define  RATE_4MB          (BIT(7)              )
+      #define  RATE_3_33MB       (BIT(7)       +BIT(5))
+      #define  RATE_2_85MB       (BIT(7)+BIT(6)       )
+      #define  RATE_2_5MB        (BIT(7)+BIT(5)+BIT(6))
+      #define  NEXT_CLK          BIT(5)
+      #define  SLOWEST_SYNC      (BIT(7)+BIT(6)+BIT(5))
+      #define  NARROW_SCSI       BIT(4)
+      #define  SYNC_OFFSET       (BIT(3) + BIT(2) + BIT(1) + BIT(0))
+      #define  DEFAULT_ASYNC     0x00
+      #define  DEFAULT_OFFSET    0x0F
+
+   #define  hp_autostart_0       0x64
+   #define  hp_autostart_1       0x65
+   #define  hp_autostart_2       0x66
+   #define  hp_autostart_3       0x67
+
+
+
+      #define  DISABLE  0x00
+      #define  AUTO_IMMED    BIT(5)
+      #define  SELECT   BIT(6)
+      #define  RESELECT (BIT(6)+BIT(5))
+      #define  BUSFREE  BIT(7)
+      #define  XFER_0   (BIT(7)+BIT(5))
+      #define  END_DATA (BIT(7)+BIT(6))
+      #define  MSG_PHZ  (BIT(7)+BIT(6)+BIT(5))
+
+   #define  hp_gp_reg_0          0x68
+   #define  hp_gp_reg_1          0x69
+   #define  hp_gp_reg_2          0x6A
+   #define  hp_gp_reg_3          0x6B
+
+   #define  hp_seltimeout        0x6C
+
+
+      #define  TO_2ms            0x54      /* 2.0503ms */
+      #define  TO_4ms            0x67      /* 3.9959ms */
+
+      #define  TO_5ms            0x03      /* 4.9152ms */
+      #define  TO_10ms           0x07      /* 11.xxxms */
+      #define  TO_250ms          0x99      /* 250.68ms */
+      #define  TO_290ms          0xB1      /* 289.99ms */
+      #define  TO_350ms          0xD6      /* 350.62ms */
+      #define  TO_417ms          0xFF      /* 417.79ms */
+
+   #define  hp_clkctrl_0         0x6D
+
+      #define  PWR_DWN           BIT(6)
+      #define  ACTdeassert       BIT(4)
+      #define  ATNonErr          BIT(3)
+      #define  CLK_30MHZ         BIT(1)
+      #define  CLK_40MHZ         (BIT(1) + BIT(0))
+      #define  CLK_50MHZ         BIT(2)
+
+      #define  CLKCTRL_DEFAULT   (ACTdeassert | CLK_40MHZ)
+
+   #define  hp_fiforead          0x6E
+   #define  hp_fifowrite         0x6F
+
+   #define  hp_offsetctr         0x70
+   #define  hp_xferstat          0x71
+
+      #define  FIFO_FULL         BIT(7)
+      #define  FIFO_EMPTY        BIT(6)
+      #define  FIFO_MASK         0x3F   /* Mask for the FIFO count value. */
+      #define  FIFO_LEN          0x20
+
+   #define  hp_portctrl_1        0x72
+
+      #define  EVEN_HOST_P       BIT(5)
+      #define  INVT_SCSI         BIT(4)
+      #define  CHK_SCSI_P        BIT(3)
+      #define  HOST_MODE8        BIT(0)
+      #define  HOST_MODE16       0x00
+
+   #define  hp_xfer_pad          0x73
+
+      #define  ID_UNLOCK         BIT(3)
+      #define  XFER_PAD          BIT(2)
+
+   #define  hp_scsidata_0        0x74
+   #define  hp_scsidata_1        0x75
+   #define  hp_timer_0           0x76
+   #define  hp_timer_1           0x77
+
+   #define  hp_reserved_78       0x78
+   #define  hp_reserved_79       0x79
+   #define  hp_reserved_7A       0x7A
+   #define  hp_reserved_7B       0x7B
+
+   #define  hp_reserved_7C       0x7C
+   #define  hp_reserved_7D       0x7D
+   #define  hp_reserved_7E       0x7E
+   #define  hp_reserved_7F       0x7F
+
+   #define  hp_aramBase          0x80
+   #define  BIOS_DATA_OFFSET     0x60
+   #define  BIOS_RELATIVE_CARD   0x64
+
+
+
+
+      #define  AUTO_LEN 0x80
+      #define  AR0      0x00
+      #define  AR1      BITW(8)
+      #define  AR2      BITW(9)
+      #define  AR3      (BITW(9) + BITW(8))
+      #define  SDATA    BITW(10)
+
+      #define  NOP_OP   0x00        /* Nop command */
+
+      #define  CRD_OP   BITW(11)     /* Cmp Reg. w/ Data */
+
+      #define  CRR_OP   BITW(12)     /* Cmp Reg. w. Reg. */
+
+      #define  CBE_OP   (BITW(14)+BITW(12)+BITW(11)) /* Cmp SCSI cmd class & Branch EQ */
+      
+      #define  CBN_OP   (BITW(14)+BITW(13))  /* Cmp SCSI cmd class & Branch NOT EQ */
+      
+      #define  CPE_OP   (BITW(14)+BITW(11))  /* Cmp SCSI phs & Branch EQ */
+
+      #define  CPN_OP   (BITW(14)+BITW(12))  /* Cmp SCSI phs & Branch NOT EQ */
+
+
+      #define  ADATA_OUT   0x00     
+      #define  ADATA_IN    BITW(8)
+      #define  ACOMMAND    BITW(10)
+      #define  ASTATUS     (BITW(10)+BITW(8))
+      #define  AMSG_OUT    (BITW(10)+BITW(9))
+      #define  AMSG_IN     (BITW(10)+BITW(9)+BITW(8))
+      #define  AILLEGAL    (BITW(9)+BITW(8))
+
+
+      #define  BRH_OP   BITW(13)   /* Branch */
+
+      
+      #define  ALWAYS   0x00
+      #define  EQUAL    BITW(8)
+      #define  NOT_EQ   BITW(9)
+
+      #define  TCB_OP   (BITW(13)+BITW(11))    /* Test condition & branch */
+
+      
+      #define  ATN_SET     BITW(8)
+      #define  ATN_RESET   BITW(9)
+      #define  XFER_CNT    (BITW(9)+BITW(8))
+      #define  FIFO_0      BITW(10)
+      #define  FIFO_NOT0   (BITW(10)+BITW(8))
+      #define  T_USE_SYNC0 (BITW(10)+BITW(9))
+
+
+      #define  MPM_OP   BITW(15)        /* Match phase and move data */
+
+      #define  MDR_OP   (BITW(12)+BITW(11)) /* Move data to Reg. */
+
+      #define  MRR_OP   BITW(14)        /* Move DReg. to Reg. */
+
+
+      #define  S_IDREG  (BIT(2)+BIT(1)+BIT(0))
+
+
+      #define  D_AR0    0x00
+      #define  D_AR1    BIT(0)
+      #define  D_AR2    BIT(1)
+      #define  D_AR3    (BIT(1) + BIT(0))
+      #define  D_SDATA  BIT(2)
+      #define  D_BUCKET (BIT(2) + BIT(1) + BIT(0))
+
+
+      #define  ADR_OP   (BITW(13)+BITW(12)) /* Logical AND Reg. w. Data */
+
+      #define  ADS_OP   (BITW(14)+BITW(13)+BITW(12)) 
+
+      #define  ODR_OP   (BITW(13)+BITW(12)+BITW(11))  
+
+      #define  ODS_OP   (BITW(14)+BITW(13)+BITW(12)+BITW(11))  
+
+      #define  STR_OP   (BITW(15)+BITW(14)) /* Store to A_Reg. */
+
+      #define  AINT_ENA1   0x00
+      #define  AINT_STAT1  BITW(8)
+      #define  ASCSI_SIG   BITW(9)
+      #define  ASCSI_CNTL  (BITW(9)+BITW(8))
+      #define  APORT_CNTL  BITW(10)
+      #define  ARST_CNTL   (BITW(10)+BITW(8))
+      #define  AXFERCNT0   (BITW(10)+BITW(9))
+      #define  AXFERCNT1   (BITW(10)+BITW(9)+BITW(8))
+      #define  AXFERCNT2   BITW(11)
+      #define  AFIFO_DATA  (BITW(11)+BITW(8))
+      #define  ASCSISELID  (BITW(11)+BITW(9))
+      #define  ASCSISYNC0  (BITW(11)+BITW(9)+BITW(8))
+
+
+      #define  RAT_OP      (BITW(14)+BITW(13)+BITW(11))
+
+      #define  SSI_OP      (BITW(15)+BITW(11))
+
+
+      #define  SSI_ITAR_DISC	(ITAR_DISC >> 8)
+      #define  SSI_IDO_STRT	(IDO_STRT >> 8)
+      #define  SSI_IDI_STRT	(IDO_STRT >> 8)
+
+      #define  SSI_ICMD_COMP	(ICMD_COMP >> 8)
+      #define  SSI_ITICKLE	(ITICKLE >> 8)
+
+      #define  SSI_IUNKWN	(IUNKWN >> 8)
+      #define  SSI_INO_CC	(IUNKWN >> 8)
+      #define  SSI_IRFAIL	(IUNKWN >> 8)
+
+
+      #define  NP    0x10     /*Next Phase */
+      #define  NTCMD 0x02     /*Non- Tagged Command start */
+      #define  CMDPZ 0x04     /*Command phase */
+      #define  DINT  0x12     /*Data Out/In interrupt */
+      #define  DI    0x13     /*Data Out */
+      #define  MI    0x14     /*Message In */
+      #define  DC    0x19     /*Disconnect Message */
+      #define  ST    0x1D     /*Status Phase */
+      #define  UNKNWN 0x24    /*Unknown bus action */
+      #define  CC    0x25     /*Command Completion failure */
+      #define  TICK  0x26     /*New target reselected us. */
+      #define  RFAIL 0x27     /*Reselection failed */
+      #define  SELCHK 0x28     /*Select & Check SCSI ID latch reg */
+
+
+      #define  ID_MSG_STRT    hp_aramBase + 0x00
+      #define  NON_TAG_ID_MSG hp_aramBase + 0x06
+      #define  CMD_STRT       hp_aramBase + 0x08
+      #define  SYNC_MSGS      hp_aramBase + 0x08
+
+
+
+
+
+      #define  TAG_STRT          0x00
+      #define  SELECTION_START   0x00
+      #define  DISCONNECT_START  0x10/2
+      #define  END_DATA_START    0x14/2
+      #define  NONTAG_STRT       0x02/2
+      #define  CMD_ONLY_STRT     CMDPZ/2
+      #define  TICKLE_STRT     TICK/2
+      #define  SELCHK_STRT     SELCHK/2
+
+
+
+
+#define mEEPROM_CLK_DELAY(port) (RD_HARPOON(port+hp_intstat_1))
+
+#define mWAIT_10MS(port) (RD_HARPOON(port+hp_intstat_1))
+
+
+#define CLR_XFER_CNT(port) (WR_HARPOON(port+hp_xfercnt_0, 0x00))
+
+#define SET_XFER_CNT(port, data) (WR_HARP32(port,hp_xfercnt_0,data))
+
+#define GET_XFER_CNT(port, xfercnt) {RD_HARP32(port,hp_xfercnt_0,xfercnt); xfercnt &= 0xFFFFFF;}
+/* #define GET_XFER_CNT(port, xfercnt) (xfercnt = RD_HARPOON(port+hp_xfercnt_2), \
+                                 xfercnt <<= 16,\
+                                 xfercnt |= RDW_HARPOON((USHORT)(port+hp_xfercnt_0)))
+ */
+#if defined(DOS)
+#define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((USHORT)(port+hp_host_addr_lo), (USHORT)(addr & 0x0000FFFFL)),\
+         addr >>= 16,\
+         WRW_HARPOON((USHORT)(port+hp_host_addr_hmi), (USHORT)(addr & 0x0000FFFFL)),\
+         WR_HARP32(port,hp_xfercnt_0,count),\
+         WRW_HARPOON((USHORT)(port+hp_xfer_cnt_lo), (USHORT)(count & 0x0000FFFFL)),\
+         count >>= 16,\
+         WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))
+#else
+#define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((port+hp_host_addr_lo), (USHORT)(addr & 0x0000FFFFL)),\
+         addr >>= 16,\
+         WRW_HARPOON((port+hp_host_addr_hmi), (USHORT)(addr & 0x0000FFFFL)),\
+         WR_HARP32(port,hp_xfercnt_0,count),\
+         WRW_HARPOON((port+hp_xfer_cnt_lo), (USHORT)(count & 0x0000FFFFL)),\
+         count >>= 16,\
+         WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))
+#endif
+
+#define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+                          WR_HARPOON(port+hp_scsisig, S_ILL_PH);}
+
+
+#define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+                          WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}
+
+#define ACCEPT_STAT(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+                          WR_HARPOON(port+hp_scsisig, S_ILL_PH);}
+
+#define ACCEPT_STAT_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\
+                          WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}
+
+#define DISABLE_AUTO(port) (WR_HARPOON(port+hp_scsireset, PROG_RESET),\
+                        WR_HARPOON(port+hp_scsireset, 0x00))
+
+#define ARAM_ACCESS(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \
+                             (RD_HARPOON(p_port+hp_page_ctrl) | SGRAM_ARAM)))
+
+#define SGRAM_ACCESS(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \
+                             (RD_HARPOON(p_port+hp_page_ctrl) & ~SGRAM_ARAM)))
+
+#define MDISABLE_INT(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \
+                             (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE)))
+
+#define MENABLE_INT(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \
+                             (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE)))
+
+
+
+#endif
+
+
+#if (FW_TYPE==_UCB_MGR_)
+void ReadNVRam(PSCCBcard pCurrCard,PUCB p_ucb);
+void WriteNVRam(PSCCBcard pCurrCard,PUCB p_ucb);
+void UpdateCheckSum(u32bits baseport);
+#endif // (FW_TYPE==_UCB_MGR_)
+
+#if defined(DOS)
+UCHAR sfm(USHORT port, PSCCB pcurrSCCB);
+void  scsiStartAuto(USHORT port);
+UCHAR sisyncn(USHORT port, UCHAR p_card, UCHAR syncFlag);
+void  ssel(USHORT port, UCHAR p_card);
+void  sres(USHORT port, UCHAR p_card, PSCCBcard pCurrCard);
+void  sdecm(UCHAR message, USHORT port, UCHAR p_card);
+void  shandem(USHORT port, UCHAR p_card,PSCCB pCurrSCCB);
+void  stsyncn(USHORT port, UCHAR p_card);
+void  sisyncr(USHORT port,UCHAR sync_pulse, UCHAR offset);
+void  sssyncv(USHORT p_port, UCHAR p_id, UCHAR p_sync_value, PSCCBMgr_tar_info currTar_Info);
+void  sresb(USHORT port, UCHAR p_card);
+void  sxfrp(USHORT p_port, UCHAR p_card);
+void  schkdd(USHORT port, UCHAR p_card);
+UCHAR RdStack(USHORT port, UCHAR index);
+void  WrStack(USHORT portBase, UCHAR index, UCHAR data);
+UCHAR ChkIfChipInitialized(USHORT ioPort);
+
+#if defined(V302)
+UCHAR GetTarLun(USHORT port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tag, PUCHAR lun);
+#endif
+
+void SendMsg(USHORT port, UCHAR message);
+void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code);
+UCHAR scsellDOS(USHORT p_port, UCHAR targ_id);
+#else
+UCHAR sfm(ULONG port, PSCCB pcurrSCCB);
+void  scsiStartAuto(ULONG port);
+UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag);
+void  ssel(ULONG port, UCHAR p_card);
+void  sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard);
+void  sdecm(UCHAR message, ULONG port, UCHAR p_card);
+void  shandem(ULONG port, UCHAR p_card,PSCCB pCurrSCCB);
+void  stsyncn(ULONG port, UCHAR p_card);
+void  sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset);
+void  sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value, PSCCBMgr_tar_info currTar_Info);
+void  sresb(ULONG port, UCHAR p_card);
+void  sxfrp(ULONG p_port, UCHAR p_card);
+void  schkdd(ULONG port, UCHAR p_card);
+UCHAR RdStack(ULONG port, UCHAR index);
+void  WrStack(ULONG portBase, UCHAR index, UCHAR data);
+UCHAR ChkIfChipInitialized(ULONG ioPort);
+
+#if defined(V302)
+UCHAR GetTarLun(ULONG port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tar, PUCHAR lun);
+#endif
+
+void SendMsg(ULONG port, UCHAR message);
+void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code);
+#endif
+
+void  ssenss(PSCCBcard pCurrCard);
+void  sinits(PSCCB p_sccb, UCHAR p_card);
+void  RNVRamData(PNVRamInfo pNvRamInfo);
+
+#if defined(WIDE_SCSI)
+   #if defined(DOS)
+   UCHAR siwidn(USHORT port, UCHAR p_card);
+   void  stwidn(USHORT port, UCHAR p_card);
+   void  siwidr(USHORT port, UCHAR width);
+   #else
+   UCHAR siwidn(ULONG port, UCHAR p_card);
+   void  stwidn(ULONG port, UCHAR p_card);
+   void  siwidr(ULONG port, UCHAR width);
+   #endif
+#endif
+
+
+void  queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card);
+void  queueDisconnect(PSCCB p_SCCB, UCHAR p_card);
+void  queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_SCCB, UCHAR p_card);
+void  queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card);
+void  queueFlushSccb(UCHAR p_card, UCHAR error_code);
+void  queueAddSccb(PSCCB p_SCCB, UCHAR card);
+UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card);
+void  utilUpdateResidual(PSCCB p_SCCB);
+USHORT CalcCrc16(UCHAR buffer[]);
+UCHAR  CalcLrc(UCHAR buffer[]);
+
+
+#if defined(DOS)
+void  Wait1Second(USHORT p_port);
+void  Wait(USHORT p_port, UCHAR p_delay);
+void  utilEEWriteOnOff(USHORT p_port,UCHAR p_mode);
+void  utilEEWrite(USHORT p_port, USHORT ee_data, USHORT ee_addr);
+USHORT utilEERead(USHORT p_port, USHORT ee_addr);
+USHORT utilEEReadOrg(USHORT p_port, USHORT ee_addr);
+void  utilEESendCmdAddr(USHORT p_port, UCHAR ee_cmd, USHORT ee_addr);
+#else
+void  Wait1Second(ULONG p_port);
+void  Wait(ULONG p_port, UCHAR p_delay);
+void  utilEEWriteOnOff(ULONG p_port,UCHAR p_mode);
+void  utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr);
+USHORT utilEERead(ULONG p_port, USHORT ee_addr);
+USHORT utilEEReadOrg(ULONG p_port, USHORT ee_addr);
+void  utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr);
+#endif
+
+
+
+#if defined(OS2)
+   void  far phaseDataOut(ULONG port, UCHAR p_card);
+   void  far phaseDataIn(ULONG port, UCHAR p_card);
+   void  far phaseCommand(ULONG port, UCHAR p_card);
+   void  far phaseStatus(ULONG port, UCHAR p_card);
+   void  far phaseMsgOut(ULONG port, UCHAR p_card);
+   void  far phaseMsgIn(ULONG port, UCHAR p_card);
+   void  far phaseIllegal(ULONG port, UCHAR p_card);
+#else
+   #if defined(DOS)
+      void  phaseDataOut(USHORT port, UCHAR p_card);
+      void  phaseDataIn(USHORT port, UCHAR p_card);
+      void  phaseCommand(USHORT port, UCHAR p_card);
+      void  phaseStatus(USHORT port, UCHAR p_card);
+      void  phaseMsgOut(USHORT port, UCHAR p_card);
+      void  phaseMsgIn(USHORT port, UCHAR p_card);
+      void  phaseIllegal(USHORT port, UCHAR p_card);
+   #else
+      void  phaseDataOut(ULONG port, UCHAR p_card);
+      void  phaseDataIn(ULONG port, UCHAR p_card);
+      void  phaseCommand(ULONG port, UCHAR p_card);
+      void  phaseStatus(ULONG port, UCHAR p_card);
+      void  phaseMsgOut(ULONG port, UCHAR p_card);
+      void  phaseMsgIn(ULONG port, UCHAR p_card);
+      void  phaseIllegal(ULONG port, UCHAR p_card);
+   #endif
+#endif
+
+#if defined(DOS)
+void  phaseDecode(USHORT port, UCHAR p_card);
+void  phaseChkFifo(USHORT port, UCHAR p_card);
+void  phaseBusFree(USHORT p_port, UCHAR p_card);
+#else
+void  phaseDecode(ULONG port, UCHAR p_card);
+void  phaseChkFifo(ULONG port, UCHAR p_card);
+void  phaseBusFree(ULONG p_port, UCHAR p_card);
+#endif
+
+
+
+
+#if defined(DOS)
+void  XbowInit(USHORT port, UCHAR scamFlg);
+void  BusMasterInit(USHORT p_port);
+int   DiagXbow(USHORT port);
+int   DiagBusMaster(USHORT port);
+void  DiagEEPROM(USHORT p_port);
+#else
+void  XbowInit(ULONG port, UCHAR scamFlg);
+void  BusMasterInit(ULONG p_port);
+int   DiagXbow(ULONG port);
+int   DiagBusMaster(ULONG port);
+void  DiagEEPROM(ULONG p_port);
+#endif
+
+
+
+
+#if defined(DOS)
+void  busMstrAbort(USHORT port);
+UCHAR busMstrTimeOut(USHORT port);
+void  dataXferProcessor(USHORT port, PSCCBcard pCurrCard);
+void  busMstrSGDataXferStart(USHORT port, PSCCB pCurrSCCB);
+void  busMstrDataXferStart(USHORT port, PSCCB pCurrSCCB);
+void  hostDataXferAbort(USHORT port, UCHAR p_card, PSCCB pCurrSCCB);
+#else
+void  busMstrAbort(ULONG port);
+UCHAR busMstrTimeOut(ULONG port);
+void  dataXferProcessor(ULONG port, PSCCBcard pCurrCard);
+void  busMstrSGDataXferStart(ULONG port, PSCCB pCurrSCCB);
+void  busMstrDataXferStart(ULONG port, PSCCB pCurrSCCB);
+void  hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB);
+#endif
+void  hostDataXferRestart(PSCCB currSCCB);
+
+
+#if defined (DOS)
+UCHAR SccbMgr_bad_isr(USHORT p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int);
+#else
+UCHAR SccbMgr_bad_isr(ULONG p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int);
+
+#endif
+
+void  SccbMgrTableInitAll(void);
+void  SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card);
+void  SccbMgrTableInitTarget(UCHAR p_card, UCHAR target);
+
+
+
+void  scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up);
+
+#if defined(DOS)
+int   scarb(USHORT p_port, UCHAR p_sel_type);
+void  scbusf(USHORT p_port);
+void  scsel(USHORT p_port);
+void  scasid(UCHAR p_card, USHORT p_port);
+UCHAR scxferc(USHORT p_port, UCHAR p_data);
+UCHAR scsendi(USHORT p_port, UCHAR p_id_string[]);
+UCHAR sciso(USHORT p_port, UCHAR p_id_string[]);
+void  scwirod(USHORT p_port, UCHAR p_data_bit);
+void  scwiros(USHORT p_port, UCHAR p_data_bit);
+UCHAR scvalq(UCHAR p_quintet);
+UCHAR scsell(USHORT p_port, UCHAR targ_id);
+void  scwtsel(USHORT p_port);
+void  inisci(UCHAR p_card, USHORT p_port, UCHAR p_our_id);
+void  scsavdi(UCHAR p_card, USHORT p_port);
+#else
+int   scarb(ULONG p_port, UCHAR p_sel_type);
+void  scbusf(ULONG p_port);
+void  scsel(ULONG p_port);
+void  scasid(UCHAR p_card, ULONG p_port);
+UCHAR scxferc(ULONG p_port, UCHAR p_data);
+UCHAR scsendi(ULONG p_port, UCHAR p_id_string[]);
+UCHAR sciso(ULONG p_port, UCHAR p_id_string[]);
+void  scwirod(ULONG p_port, UCHAR p_data_bit);
+void  scwiros(ULONG p_port, UCHAR p_data_bit);
+UCHAR scvalq(UCHAR p_quintet);
+UCHAR scsell(ULONG p_port, UCHAR targ_id);
+void  scwtsel(ULONG p_port);
+void  inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id);
+void  scsavdi(UCHAR p_card, ULONG p_port);
+#endif
+UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[]);
+
+
+#if defined(DOS)
+void  autoCmdCmplt(USHORT p_port, UCHAR p_card);
+void  autoLoadDefaultMap(USHORT p_port);
+#else
+void  autoCmdCmplt(ULONG p_port, UCHAR p_card);
+void  autoLoadDefaultMap(ULONG p_port);
+#endif
+
+
+
+#if (FW_TYPE==_SCCB_MGR_)
+	void  OS_start_timer(unsigned long ioport, unsigned long timeout);
+	void  OS_stop_timer(unsigned long ioport, unsigned long timeout);
+	void  OS_disable_int(unsigned char intvec);
+	void  OS_enable_int(unsigned char intvec);
+	void  OS_delay(unsigned long count);
+	int   OS_VirtToPhys(u32bits CardHandle, u32bits *physaddr, u32bits *virtaddr);
+	#if !(defined(UNIX) || defined(OS2) || defined(SOLARIS_REAL_MODE)) 
+	void  OS_Lock(PSCCBMGR_INFO pCardInfo);
+	void  OS_UnLock(PSCCBMGR_INFO pCardInfo);
+#endif // if FW_TYPE == ...
+
+#endif
+
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+
+
+#if defined(OS2)
+   extern void (far *s_PhaseTbl[8]) (ULONG, UCHAR);
+#else
+   #if defined(DOS)
+      extern void (*s_PhaseTbl[8]) (USHORT, UCHAR);
+   #else
+      extern void (*s_PhaseTbl[8]) (ULONG, UCHAR);
+   #endif
+#endif
+
+extern SCCBSCAM_INFO scamInfo[MAX_SCSI_TAR];
+extern NVRAMINFO nvRamInfo[MAX_MB_CARDS];
+#if defined(DOS) || defined(OS2)
+extern UCHAR temp_id_string[ID_STRING_LENGTH];
+#endif
+extern UCHAR scamHAString[];
+
+
+extern UCHAR mbCards;
+#if defined(BUGBUG)
+extern UCHAR debug_int[MAX_CARDS][debug_size];
+extern UCHAR debug_index[MAX_CARDS];
+void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
+#endif
+
+#if (FW_TYPE==_SCCB_MGR_)
+#if defined(DOS)
+   extern UCHAR first_time;
+#endif
+#endif /* (FW_TYPE==_SCCB_MGR_) */
+
+#if (FW_TYPE==_UCB_MGR_)
+#if defined(DOS)
+   extern u08bits first_time;
+#endif
+#endif /* (FW_TYPE==_UCB_MGR_) */
+
+#if defined(BUGBUG)
+void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
+#endif
+
+extern unsigned int SccbGlobalFlags;
+
+
+#ident "$Id: sccb.c 1.18 1997/06/10 16:47:04 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   sccb.c  $
+ *
+ *   Description:  Functions relating to handling of the SCCB interface
+ *                 between the device driver and the HARPOON.
+ *
+ *   $Date: 1997/06/10 16:47:04 $
+ *
+ *   $Revision: 1.18 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+	/*#include <budioctl.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <eeprom.h>*/
+/*#include <scsi2.h>*/
+/*#include <harpoon.h>*/
+
+
+
+#if (FW_TYPE==_SCCB_MGR_)
+#define mOS_Lock(card)    OS_Lock((PSCCBMGR_INFO)(((PSCCBcard)card)->cardInfo))
+#define mOS_UnLock(card)  OS_UnLock((PSCCBMGR_INFO)(((PSCCBcard)card)->cardInfo))
+#else /* FW_TYPE==_UCB_MGR_ */
+#define mOS_Lock(card)    OS_Lock((u32bits)(((PSCCBcard)card)->ioPort))
+#define mOS_UnLock(card)  OS_UnLock((u32bits)(((PSCCBcard)card)->ioPort))
+#endif
+
+
+/*
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+extern SCCBCARD BL_Card[MAX_CARDS];
+
+extern NVRAMINFO nvRamInfo[MAX_MB_CARDS];
+extern UCHAR mbCards;
+
+#if defined (OS2)
+   extern void (far *s_PhaseTbl[8]) (ULONG, UCHAR);
+#else
+   #if defined(DOS)
+      extern void (*s_PhaseTbl[8]) (USHORT, UCHAR);
+   #else
+      extern void (*s_PhaseTbl[8]) (ULONG, UCHAR);
+   #endif
+#endif
+
+
+#if defined(BUGBUG)
+extern UCHAR debug_int[MAX_CARDS][debug_size];
+extern UCHAR debug_index[MAX_CARDS];
+void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
+#endif
+*/
+
+#if (FW_TYPE==_SCCB_MGR_)
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_sense_adapter
+ *
+ * Description: Setup and/or Search for cards and return info to caller.
+ *
+ *---------------------------------------------------------------------*/
+
+int SccbMgr_sense_adapter(PSCCBMGR_INFO pCardInfo)
+{
+#if defined(DOS)
+#else
+   static UCHAR first_time = 1;
+#endif
+
+   UCHAR i,j,id,ScamFlg;
+   USHORT temp,temp2,temp3,temp4,temp5,temp6;
+#if defined(DOS)
+   USHORT ioport;
+#else
+   ULONG ioport;
+#endif
+	PNVRamInfo pCurrNvRam;
+
+#if defined(DOS)
+   ioport = (USHORT)pCardInfo->si_baseaddr;
+#else
+   ioport = pCardInfo->si_baseaddr;
+#endif
+
+
+   if (RD_HARPOON(ioport+hp_vendor_id_0) != ORION_VEND_0)
+      return((int)FAILURE);
+
+   if ((RD_HARPOON(ioport+hp_vendor_id_1) != ORION_VEND_1))
+      return((int)FAILURE);
+
+   if ((RD_HARPOON(ioport+hp_device_id_0) != ORION_DEV_0))
+      return((int)FAILURE);
+
+   if ((RD_HARPOON(ioport+hp_device_id_1) != ORION_DEV_1))
+      return((int)FAILURE);
+
+
+   if (RD_HARPOON(ioport+hp_rev_num) != 0x0f){
+
+/* For new Harpoon then check for sub_device ID LSB
+   the bits(0-3) must be all ZERO for compatible with
+   current version of SCCBMgr, else skip this Harpoon
+	device. */
+
+	   if (RD_HARPOON(ioport+hp_sub_device_id_0) & 0x0f)
+	      return((int)FAILURE);
+	}
+
+   if (first_time)
+      {
+      SccbMgrTableInitAll();
+      first_time = 0;
+		mbCards = 0;
+      }
+
+	if(RdStack(ioport, 0) != 0x00) {
+		if(ChkIfChipInitialized(ioport) == FALSE)
+		{
+			pCurrNvRam = NULL;
+		   WR_HARPOON(ioport+hp_semaphore, 0x00);
+			XbowInit(ioport, 0);             /*Must Init the SCSI before attempting */
+			DiagEEPROM(ioport);
+		}
+		else
+		{
+			if(mbCards < MAX_MB_CARDS) {
+				pCurrNvRam = &nvRamInfo[mbCards];
+				mbCards++;
+				pCurrNvRam->niBaseAddr = ioport;
+				RNVRamData(pCurrNvRam);
+			}else
+				return((int) FAILURE);
+		}
+	}else
+		pCurrNvRam = NULL;
+#if defined (NO_BIOS_OPTION)
+	pCurrNvRam = NULL;
+   XbowInit(ioport, 0);                /*Must Init the SCSI before attempting */
+   DiagEEPROM(ioport);
+#endif  /* No BIOS Option */
+
+   WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
+   WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
+
+	if(pCurrNvRam)
+		pCardInfo->si_id = pCurrNvRam->niAdapId;
+	else
+	   pCardInfo->si_id = (UCHAR)(utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
+   	   (UCHAR)0x0FF);
+
+   pCardInfo->si_lun = 0x00;
+   pCardInfo->si_fw_revision = ORION_FW_REV;
+   temp2 = 0x0000;
+   temp3 = 0x0000;
+   temp4 = 0x0000;
+   temp5 = 0x0000;
+   temp6 = 0x0000;
+
+   for (id = 0; id < (16/2); id++) {
+
+		if(pCurrNvRam){
+			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
+					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		}else
+	      temp = utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
+
+      for (i = 0; i < 2; temp >>=8,i++) {
+
+         temp2 >>= 1;
+         temp3 >>= 1;
+         temp4 >>= 1;
+         temp5 >>= 1;
+         temp6 >>= 1;
+	 switch (temp & 0x3)
+	   {
+	   case AUTO_RATE_20:	/* Synchronous, 20 mega-transfers/second */
+	     temp6 |= 0x8000;	/* Fall through */
+	   case AUTO_RATE_10:	/* Synchronous, 10 mega-transfers/second */
+	     temp5 |= 0x8000;	/* Fall through */
+	   case AUTO_RATE_05:	/* Synchronous, 5 mega-transfers/second */
+	     temp2 |= 0x8000;	/* Fall through */
+	   case AUTO_RATE_00:	/* Asynchronous */
+	     break;
+	   }
+
+         if (temp & DISC_ENABLE_BIT)
+	   temp3 |= 0x8000;
+
+         if (temp & WIDE_NEGO_BIT)
+	   temp4 |= 0x8000;
+
+         }
+      }
+
+   pCardInfo->si_per_targ_init_sync = temp2;
+   pCardInfo->si_per_targ_no_disc = temp3;
+   pCardInfo->si_per_targ_wide_nego = temp4;
+   pCardInfo->si_per_targ_fast_nego = temp5;
+   pCardInfo->si_per_targ_ultra_nego = temp6;
+
+	if(pCurrNvRam)
+		i = pCurrNvRam->niSysConf;
+	else
+	   i = (UCHAR)(utilEERead(ioport, (SYSTEM_CONFIG/2)));
+
+	if(pCurrNvRam)
+		ScamFlg = pCurrNvRam->niScamConf;
+	else
+	   ScamFlg = (UCHAR) utilEERead(ioport, SCAM_CONFIG/2);
+
+   pCardInfo->si_flags = 0x0000;
+
+   if (i & 0x01)
+      pCardInfo->si_flags |= SCSI_PARITY_ENA;
+
+   if (!(i & 0x02))
+      pCardInfo->si_flags |= SOFT_RESET;
+
+   if (i & 0x10)
+      pCardInfo->si_flags |= EXTENDED_TRANSLATION;
+
+   if (ScamFlg & SCAM_ENABLED)
+     pCardInfo->si_flags |= FLAG_SCAM_ENABLED;
+
+   if (ScamFlg & SCAM_LEVEL2)
+     pCardInfo->si_flags |= FLAG_SCAM_LEVEL2;
+
+   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
+   if (i & 0x04) {
+      j |= SCSI_TERM_ENA_L;
+      }
+   WR_HARPOON(ioport+hp_bm_ctrl, j );
+
+   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
+   if (i & 0x08) {
+      j |= SCSI_TERM_ENA_H;
+      }
+   WR_HARPOON(ioport+hp_ee_ctrl, j );
+
+   if (!(RD_HARPOON(ioport+hp_page_ctrl) & NARROW_SCSI_CARD))
+
+      pCardInfo->si_flags |= SUPPORT_16TAR_32LUN;
+
+   pCardInfo->si_card_family = HARPOON_FAMILY;
+   pCardInfo->si_bustype = BUSTYPE_PCI;
+
+	if(pCurrNvRam){
+   	pCardInfo->si_card_model[0] = '9';
+		switch(pCurrNvRam->niModel & 0x0f){
+			case MODEL_LT:
+		   	pCardInfo->si_card_model[1] = '3';
+		   	pCardInfo->si_card_model[2] = '0';
+				break;
+			case MODEL_LW:
+		   	pCardInfo->si_card_model[1] = '5';
+		   	pCardInfo->si_card_model[2] = '0';
+				break;
+			case MODEL_DL:
+		   	pCardInfo->si_card_model[1] = '3';
+		   	pCardInfo->si_card_model[2] = '2';
+				break;
+			case MODEL_DW:
+		   	pCardInfo->si_card_model[1] = '5';
+		   	pCardInfo->si_card_model[2] = '2';
+				break;
+		}
+	}else{
+	   temp = utilEERead(ioport, (MODEL_NUMB_0/2));
+   	pCardInfo->si_card_model[0] = (UCHAR)(temp >> 8);
+	   temp = utilEERead(ioport, (MODEL_NUMB_2/2));
+
+   	pCardInfo->si_card_model[1] = (UCHAR)(temp & 0x00FF);
+	   pCardInfo->si_card_model[2] = (UCHAR)(temp >> 8);
+	}
+
+   if (pCardInfo->si_card_model[1] == '3')
+     {
+       if (RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7))
+	 pCardInfo->si_flags |= LOW_BYTE_TERM;
+     }
+   else if (pCardInfo->si_card_model[2] == '0')
+     {
+       temp = RD_HARPOON(ioport+hp_xfer_pad);
+       WR_HARPOON(ioport+hp_xfer_pad, (temp & ~BIT(4)));
+       if (RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7))
+	 pCardInfo->si_flags |= LOW_BYTE_TERM;
+       WR_HARPOON(ioport+hp_xfer_pad, (temp | BIT(4)));
+       if (RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7))
+	 pCardInfo->si_flags |= HIGH_BYTE_TERM;
+       WR_HARPOON(ioport+hp_xfer_pad, temp);
+     }
+   else
+     {
+       temp = RD_HARPOON(ioport+hp_ee_ctrl);
+       temp2 = RD_HARPOON(ioport+hp_xfer_pad);
+       WR_HARPOON(ioport+hp_ee_ctrl, (temp | SEE_CS));
+       WR_HARPOON(ioport+hp_xfer_pad, (temp2 | BIT(4)));
+       temp3 = 0;
+       for (i = 0; i < 8; i++)
+	 {
+	   temp3 <<= 1;
+	   if (!(RD_HARPOON(ioport+hp_ee_ctrl) & BIT(7)))
+	     temp3 |= 1;
+	   WR_HARPOON(ioport+hp_xfer_pad, (temp2 & ~BIT(4)));
+	   WR_HARPOON(ioport+hp_xfer_pad, (temp2 | BIT(4)));
+	 }
+       WR_HARPOON(ioport+hp_ee_ctrl, temp);
+       WR_HARPOON(ioport+hp_xfer_pad, temp2);
+       if (!(temp3 & BIT(7)))
+	 pCardInfo->si_flags |= LOW_BYTE_TERM;
+       if (!(temp3 & BIT(6)))
+	 pCardInfo->si_flags |= HIGH_BYTE_TERM;
+     }
+
+
+   ARAM_ACCESS(ioport);
+
+   for ( i = 0; i < 4; i++ ) {
+
+      pCardInfo->si_XlatInfo[i] =
+         RD_HARPOON(ioport+hp_aramBase+BIOS_DATA_OFFSET+i);
+      }
+
+	/* return with -1 if no sort, else return with
+	   logical card number sorted by BIOS (zero-based) */
+
+	pCardInfo->si_relative_cardnum =
+	(UCHAR)(RD_HARPOON(ioport+hp_aramBase+BIOS_RELATIVE_CARD)-1);
+
+   SGRAM_ACCESS(ioport);
+
+   s_PhaseTbl[0] = phaseDataOut;
+   s_PhaseTbl[1] = phaseDataIn;
+   s_PhaseTbl[2] = phaseIllegal;
+   s_PhaseTbl[3] = phaseIllegal;
+   s_PhaseTbl[4] = phaseCommand;
+   s_PhaseTbl[5] = phaseStatus;
+   s_PhaseTbl[6] = phaseMsgOut;
+   s_PhaseTbl[7] = phaseMsgIn;
+
+   pCardInfo->si_present = 0x01;
+
+#if defined(BUGBUG)
+
+
+   for (i = 0; i < MAX_CARDS; i++) {
+
+      for (id=0; id<debug_size; id++)
+         debug_int[i][id] =  (UCHAR)0x00;
+      debug_index[i] = 0;
+      }
+
+#endif
+
+   return(0);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_config_adapter
+ *
+ * Description: Setup adapter for normal operation (hard reset).
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+USHORT SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
+#else
+ULONG SccbMgr_config_adapter(PSCCBMGR_INFO pCardInfo)
+#endif
+{
+   PSCCBcard CurrCard = NULL;
+	PNVRamInfo pCurrNvRam;
+   UCHAR i,j,thisCard, ScamFlg;
+   USHORT temp,sync_bit_map,id;
+#if defined(DOS)
+   USHORT ioport;
+#else
+   ULONG ioport;
+#endif
+
+#if defined(DOS)
+   ioport = (USHORT)pCardInfo->si_baseaddr;
+#else
+   ioport = pCardInfo->si_baseaddr;
+#endif
+
+   for(thisCard =0; thisCard <= MAX_CARDS; thisCard++) {
+
+      if (thisCard == MAX_CARDS) {
+
+	 return(FAILURE);
+         }
+
+      if (BL_Card[thisCard].ioPort == ioport) {
+
+         CurrCard = &BL_Card[thisCard];
+         SccbMgrTableInitCard(CurrCard,thisCard);
+         break;
+         }
+
+      else if (BL_Card[thisCard].ioPort == 0x00) {
+
+         BL_Card[thisCard].ioPort = ioport;
+         CurrCard = &BL_Card[thisCard];
+
+			if(mbCards)
+				for(i = 0; i < mbCards; i++){
+					if(CurrCard->ioPort == nvRamInfo[i].niBaseAddr)
+						CurrCard->pNvRamInfo = &nvRamInfo[i];
+				}
+         SccbMgrTableInitCard(CurrCard,thisCard);
+         CurrCard->cardIndex = thisCard;
+         CurrCard->cardInfo = pCardInfo;
+
+	 break;
+         }
+      }
+
+	pCurrNvRam = CurrCard->pNvRamInfo;
+
+	if(pCurrNvRam){
+		ScamFlg = pCurrNvRam->niScamConf;
+	}
+	else{
+	   ScamFlg = (UCHAR) utilEERead(ioport, SCAM_CONFIG/2);
+	}
+
+
+   BusMasterInit(ioport);
+   XbowInit(ioport, ScamFlg);
+
+#if defined (NO_BIOS_OPTION)
+
+
+   if (DiagXbow(ioport)) return(FAILURE);
+   if (DiagBusMaster(ioport)) return(FAILURE);
+
+#endif  /* No BIOS Option */
+
+   autoLoadDefaultMap(ioport);
+
+
+   for (i = 0,id = 0x01; i != pCardInfo->si_id; i++,id <<= 1){}
+
+   WR_HARPOON(ioport+hp_selfid_0, id);
+   WR_HARPOON(ioport+hp_selfid_1, 0x00);
+   WR_HARPOON(ioport+hp_arb_id, pCardInfo->si_id);
+   CurrCard->ourId = pCardInfo->si_id;
+
+   i = (UCHAR) pCardInfo->si_flags;
+   if (i & SCSI_PARITY_ENA)
+       WR_HARPOON(ioport+hp_portctrl_1,(HOST_MODE8 | CHK_SCSI_P));
+
+   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
+   if (i & LOW_BYTE_TERM)
+      j |= SCSI_TERM_ENA_L;
+   WR_HARPOON(ioport+hp_bm_ctrl, j);
+
+   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
+   if (i & HIGH_BYTE_TERM)
+      j |= SCSI_TERM_ENA_H;
+   WR_HARPOON(ioport+hp_ee_ctrl, j );
+
+
+   if (!(pCardInfo->si_flags & SOFT_RESET)) {
+
+      sresb(ioport,thisCard);
+
+         scini(thisCard, pCardInfo->si_id, 0);
+      }
+
+
+
+   if (pCardInfo->si_flags & POST_ALL_UNDERRRUNS)
+      CurrCard->globalFlags |= F_NO_FILTER;
+
+	if(pCurrNvRam){
+		if(pCurrNvRam->niSysConf & 0x10)
+			CurrCard->globalFlags |= F_GREEN_PC;
+	}
+	else{
+	   if (utilEERead(ioport, (SYSTEM_CONFIG/2)) & GREEN_PC_ENA)
+   	   CurrCard->globalFlags |= F_GREEN_PC;
+	}
+
+	/* Set global flag to indicate Re-Negotiation to be done on all
+		ckeck condition */
+	if(pCurrNvRam){
+		if(pCurrNvRam->niScsiConf & 0x04)
+			CurrCard->globalFlags |= F_DO_RENEGO;
+	}
+	else{
+	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & RENEGO_ENA)
+   	   CurrCard->globalFlags |= F_DO_RENEGO;
+	}
+
+	if(pCurrNvRam){
+		if(pCurrNvRam->niScsiConf & 0x08)
+			CurrCard->globalFlags |= F_CONLUN_IO;
+	}
+	else{
+	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & CONNIO_ENA)
+   	   CurrCard->globalFlags |= F_CONLUN_IO;
+	}
+
+
+   temp = pCardInfo->si_per_targ_no_disc;
+
+   for (i = 0,id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
+
+      if (temp & id)
+	 sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
+      }
+
+   sync_bit_map = 0x0001;
+
+   for (id = 0; id < (MAX_SCSI_TAR/2); id++) {
+
+		if(pCurrNvRam){
+			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
+					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		}else
+	      temp = utilEERead(ioport, (USHORT)((SYNC_RATE_TBL/2)+id));
+
+      for (i = 0; i < 2; temp >>=8,i++) {
+
+         if (pCardInfo->si_per_targ_init_sync & sync_bit_map) {
+
+            sccbMgrTbl[thisCard][id*2+i].TarEEValue = (UCHAR)temp;
+            }
+
+         else {
+	    sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
+            sccbMgrTbl[thisCard][id*2+i].TarEEValue =
+               (UCHAR)(temp & ~EE_SYNC_MASK);
+            }
+
+#if defined(WIDE_SCSI)
+/*         if ((pCardInfo->si_per_targ_wide_nego & sync_bit_map) ||
+            (id*2+i >= 8)){
+*/
+         if (pCardInfo->si_per_targ_wide_nego & sync_bit_map){
+
+            sccbMgrTbl[thisCard][id*2+i].TarEEValue |= EE_WIDE_SCSI;
+
+            }
+
+         else { /* NARROW SCSI */
+            sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
+            }
+
+#else
+         sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
+#endif
+
+
+	 sync_bit_map <<= 1;
+
+
+
+         }
+      }
+
+   WR_HARPOON((ioport+hp_semaphore),
+      (UCHAR)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
+
+#if defined(DOS)
+   return((USHORT)CurrCard);
+#else
+   return((ULONG)CurrCard);
+#endif
+}
+
+#else  			/* end (FW_TYPE==_SCCB_MGR_)  */
+
+
+
+STATIC s16bits FP_PresenceCheck(PMGR_INFO pMgrInfo)
+{
+	PMGR_ENTRYPNTS	pMgr_EntryPnts = &pMgrInfo->mi_Functions;
+
+      pMgr_EntryPnts->UCBMgr_probe_adapter = probe_adapter;
+      pMgr_EntryPnts->UCBMgr_init_adapter = init_adapter;
+      pMgr_EntryPnts->UCBMgr_start_UCB = SccbMgr_start_sccb;
+      pMgr_EntryPnts->UCBMgr_build_UCB = build_UCB;
+      pMgr_EntryPnts->UCBMgr_abort_UCB = SccbMgr_abort_sccb;
+      pMgr_EntryPnts->UCBMgr_my_int = SccbMgr_my_int;
+      pMgr_EntryPnts->UCBMgr_isr = SccbMgr_isr;
+      pMgr_EntryPnts->UCBMgr_scsi_reset = SccbMgr_scsi_reset;
+      pMgr_EntryPnts->UCBMgr_timer_expired = SccbMgr_timer_expired;
+#ifndef NO_IOCTLS
+	  pMgr_EntryPnts->UCBMgr_unload_card = SccbMgr_unload_card;
+	  pMgr_EntryPnts->UCBMgr_save_foreign_state =
+	  									SccbMgr_save_foreign_state;
+	  pMgr_EntryPnts->UCBMgr_restore_foreign_state =
+	  									SccbMgr_restore_foreign_state;
+	  pMgr_EntryPnts->UCBMgr_restore_native_state =
+	  									SccbMgr_restore_native_state;
+#endif /*NO_IOCTLS*/
+
+      pMgrInfo->mi_SGListFormat=0x01;
+      pMgrInfo->mi_DataPtrFormat=0x01;
+      pMgrInfo->mi_MaxSGElements= (u16bits) 0xffffffff;
+      pMgrInfo->mi_MgrPrivateLen=sizeof(SCCB);
+      pMgrInfo->mi_PCIVendorID=BL_VENDOR_ID;
+      pMgrInfo->mi_PCIDeviceID=FP_DEVICE_ID;
+      pMgrInfo->mi_MgrAttributes= ATTR_IO_MAPPED +
+											 ATTR_PHYSICAL_ADDRESS +
+											 ATTR_VIRTUAL_ADDRESS +
+											 ATTR_OVERLAPPED_IO_IOCTLS_OK;
+      pMgrInfo->mi_IoRangeLen = 256;
+      return(0);
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: probe_adapter
+ *
+ * Description: Setup and/or Search for cards and return info to caller.
+ *
+ *---------------------------------------------------------------------*/
+STATIC s32bits probe_adapter(PADAPTER_INFO pAdapterInfo)
+{
+   u16bits temp,temp2,temp3,temp4;
+   u08bits i,j,id;
+
+#if defined(DOS)
+#else
+   static u08bits first_time = 1;
+#endif
+   BASE_PORT ioport;
+	PNVRamInfo pCurrNvRam;
+
+   ioport = (BASE_PORT)pAdapterInfo->ai_baseaddr;
+
+
+
+   if (RD_HARPOON(ioport+hp_vendor_id_0) != ORION_VEND_0)
+      return(1);
+
+   if ((RD_HARPOON(ioport+hp_vendor_id_1) != ORION_VEND_1))
+      return(2);
+
+   if ((RD_HARPOON(ioport+hp_device_id_0) != ORION_DEV_0))
+      return(3);
+
+   if ((RD_HARPOON(ioport+hp_device_id_1) != ORION_DEV_1))
+      return(4);
+
+
+   if (RD_HARPOON(ioport+hp_rev_num) != 0x0f){
+
+
+/* For new Harpoon then check for sub_device ID LSB
+   the bits(0-3) must be all ZERO for compatible with
+   current version of SCCBMgr, else skip this Harpoon
+	device. */
+
+	   if (RD_HARPOON(ioport+hp_sub_device_id_0) & 0x0f)
+	      return(5);
+	}
+
+   if (first_time) {
+
+      SccbMgrTableInitAll();
+      first_time = 0;
+		mbCards = 0;
+      }
+
+	if(RdStack(ioport, 0) != 0x00) {
+		if(ChkIfChipInitialized(ioport) == FALSE)
+		{
+			pCurrNvRam = NULL;
+		   WR_HARPOON(ioport+hp_semaphore, 0x00);
+			XbowInit(ioport, 0);                /*Must Init the SCSI before attempting */
+			DiagEEPROM(ioport);
+		}
+		else
+		{
+			if(mbCards < MAX_MB_CARDS) {
+				pCurrNvRam = &nvRamInfo[mbCards];
+				mbCards++;
+				pCurrNvRam->niBaseAddr = ioport;
+				RNVRamData(pCurrNvRam);
+			}else
+				return((int) FAILURE);
+		}
+	}else
+		pCurrNvRam = NULL;
+
+#if defined (NO_BIOS_OPTION)
+	pCurrNvRam = NULL;
+   XbowInit(ioport, 0);                /*Must Init the SCSI before attempting */
+   DiagEEPROM(ioport);
+#endif  /* No BIOS Option */
+
+   WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
+   WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
+
+	if(pCurrNvRam)
+		pAdapterInfo->ai_id = pCurrNvRam->niAdapId;
+	else
+   	pAdapterInfo->ai_id = (u08bits)(utilEERead(ioport, (ADAPTER_SCSI_ID/2)) &
+      	(u08bits)0x0FF);
+
+   pAdapterInfo->ai_lun = 0x00;
+   pAdapterInfo->ai_fw_revision[0] = '3';
+   pAdapterInfo->ai_fw_revision[1] = '1';
+   pAdapterInfo->ai_fw_revision[2] = '1';
+   pAdapterInfo->ai_fw_revision[3] = ' ';
+   pAdapterInfo->ai_NumChannels = 1;
+
+   temp2 = 0x0000;
+   temp3 = 0x0000;
+   temp4 = 0x0000;
+
+   for (id = 0; id < (16/2); id++) {
+
+		if(pCurrNvRam){
+			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
+					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		}else
+	      temp = utilEERead(ioport, (u16bits)((SYNC_RATE_TBL/2)+id));
+
+      for (i = 0; i < 2; temp >>=8,i++) {
+
+         if ((temp & 0x03) != AUTO_RATE_00) {
+
+            temp2 >>= 0x01;
+            temp2 |= 0x8000;
+            }
+
+         else {
+            temp2 >>= 0x01;
+            }
+
+         if (temp & DISC_ENABLE_BIT) {
+
+            temp3 >>= 0x01;
+            temp3 |= 0x8000;
+            }
+
+         else {
+            temp3 >>= 0x01;
+            }
+
+         if (temp & WIDE_NEGO_BIT) {
+
+            temp4 >>= 0x01;
+            temp4 |= 0x8000;
+            }
+
+         else {
+            temp4 >>= 0x01;
+            }
+
+         }
+      }
+
+   pAdapterInfo->ai_per_targ_init_sync = temp2;
+   pAdapterInfo->ai_per_targ_no_disc = temp3;
+   pAdapterInfo->ai_per_targ_wide_nego = temp4;
+	if(pCurrNvRam)
+		i = pCurrNvRam->niSysConf;
+	else
+   	i = (u08bits)(utilEERead(ioport, (SYSTEM_CONFIG/2)));
+
+   /*
+   ** interrupts always level-triggered for FlashPoint
+   */
+   pAdapterInfo->ai_stateinfo |= LEVEL_TRIG;
+
+   if (i & 0x01)
+      pAdapterInfo->ai_stateinfo |= SCSI_PARITY_ENA;
+
+	if (i & 0x02)	/* SCSI Bus reset in AutoSCSI Set ? */
+	{
+		if(pCurrNvRam)
+		{
+			j = pCurrNvRam->niScamConf;
+		}
+		else
+		{
+		j = (u08bits) utilEERead(ioport, SCAM_CONFIG/2);
+		}
+		if(j & SCAM_ENABLED)
+		{
+			if(j & SCAM_LEVEL2)
+			{
+				pAdapterInfo->ai_stateinfo |= SCAM2_ENA;
+			}
+			else
+			{
+				pAdapterInfo->ai_stateinfo |= SCAM1_ENA;
+			}
+		}
+	}
+   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
+   if (i & 0x04) {
+      j |= SCSI_TERM_ENA_L;
+      pAdapterInfo->ai_stateinfo |= LOW_BYTE_TERM_ENA;
+      }
+   WR_HARPOON(ioport+hp_bm_ctrl, j );
+
+   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
+   if (i & 0x08) {
+      j |= SCSI_TERM_ENA_H;
+      pAdapterInfo->ai_stateinfo |= HIGH_BYTE_TERM_ENA;
+      }
+   WR_HARPOON(ioport+hp_ee_ctrl, j );
+
+	if(RD_HARPOON(ioport + hp_page_ctrl) & BIOS_SHADOW)
+	{
+		pAdapterInfo->ai_FlashRomSize = 64 * 1024;	/* 64k ROM */
+	}
+	else
+	{
+		pAdapterInfo->ai_FlashRomSize = 32 * 1024;	/* 32k ROM */
+	}
+
+   pAdapterInfo->ai_stateinfo |= (FAST20_ENA | TAG_QUEUE_ENA);
+   if (!(RD_HARPOON(ioport+hp_page_ctrl) & NARROW_SCSI_CARD))
+	{
+      pAdapterInfo->ai_attributes |= (WIDE_CAPABLE | FAST20_CAPABLE
+													| SCAM2_CAPABLE
+													| TAG_QUEUE_CAPABLE
+													| SUPRESS_UNDERRRUNS_CAPABLE
+													| SCSI_PARITY_CAPABLE);
+		pAdapterInfo->ai_MaxTarg = 16;
+		pAdapterInfo->ai_MaxLun  = 32;
+	}
+	else
+	{
+      pAdapterInfo->ai_attributes |= (FAST20_CAPABLE | SCAM2_CAPABLE
+													| TAG_QUEUE_CAPABLE
+													| SUPRESS_UNDERRRUNS_CAPABLE
+													| SCSI_PARITY_CAPABLE);
+		pAdapterInfo->ai_MaxTarg = 8;
+		pAdapterInfo->ai_MaxLun  = 8;
+	}
+
+   pAdapterInfo->ai_product_family = HARPOON_FAMILY;
+   pAdapterInfo->ai_HBAbustype = BUSTYPE_PCI;
+
+   for (i=0;i<CARD_MODEL_NAMELEN;i++)
+   {
+      pAdapterInfo->ai_card_model[i]=' '; /* initialize the ai_card_model */
+   }
+
+	if(pCurrNvRam){
+	pAdapterInfo->ai_card_model[0] = '9';
+		switch(pCurrNvRam->niModel & 0x0f){
+			case MODEL_LT:
+			pAdapterInfo->ai_card_model[1] = '3';
+			pAdapterInfo->ai_card_model[2] = '0';
+				break;
+			case MODEL_LW:
+			pAdapterInfo->ai_card_model[1] = '5';
+			pAdapterInfo->ai_card_model[2] = '0';
+				break;
+			case MODEL_DL:
+			pAdapterInfo->ai_card_model[1] = '3';
+			pAdapterInfo->ai_card_model[2] = '2';
+				break;
+			case MODEL_DW:
+			pAdapterInfo->ai_card_model[1] = '5';
+			pAdapterInfo->ai_card_model[2] = '2';
+				break;
+		}
+	}else{
+	   temp = utilEERead(ioport, (MODEL_NUMB_0/2));
+		pAdapterInfo->ai_card_model[0] = (u08bits)(temp >> 8);
+	   temp = utilEERead(ioport, (MODEL_NUMB_2/2));
+
+		pAdapterInfo->ai_card_model[1] = (u08bits)(temp & 0x00FF);
+	   pAdapterInfo->ai_card_model[2] = (u08bits)(temp >> 8);
+	}
+
+
+
+   pAdapterInfo->ai_FiberProductType = 0;
+
+   pAdapterInfo->ai_secondary_range = 0;
+
+   for (i=0;i<WORLD_WIDE_NAMELEN;i++)
+   {
+      pAdapterInfo->ai_worldwidename[i]='\0';
+   }
+
+   for (i=0;i<VENDOR_NAMELEN;i++)
+   {
+      pAdapterInfo->ai_vendorstring[i]='\0';
+   }
+   	pAdapterInfo->ai_vendorstring[0]='B';
+   	pAdapterInfo->ai_vendorstring[1]='U';
+   	pAdapterInfo->ai_vendorstring[2]='S';
+   	pAdapterInfo->ai_vendorstring[3]='L';
+   	pAdapterInfo->ai_vendorstring[4]='O';
+   	pAdapterInfo->ai_vendorstring[5]='G';
+   	pAdapterInfo->ai_vendorstring[6]='I';
+   	pAdapterInfo->ai_vendorstring[7]='C';
+
+	for (i=0;i<FAMILY_NAMELEN;i++)
+	{
+	   pAdapterInfo->ai_AdapterFamilyString[i]='\0';
+	}
+   	pAdapterInfo->ai_AdapterFamilyString[0]='F';
+   	pAdapterInfo->ai_AdapterFamilyString[1]='L';
+   	pAdapterInfo->ai_AdapterFamilyString[2]='A';
+   	pAdapterInfo->ai_AdapterFamilyString[3]='S';
+   	pAdapterInfo->ai_AdapterFamilyString[4]='H';
+   	pAdapterInfo->ai_AdapterFamilyString[5]='P';
+   	pAdapterInfo->ai_AdapterFamilyString[6]='O';
+   	pAdapterInfo->ai_AdapterFamilyString[7]='I';
+   	pAdapterInfo->ai_AdapterFamilyString[8]='N';
+   	pAdapterInfo->ai_AdapterFamilyString[9]='T';
+
+   ARAM_ACCESS(ioport);
+
+   for ( i = 0; i < 4; i++ ) {
+
+      pAdapterInfo->ai_XlatInfo[i] =
+         RD_HARPOON(ioport+hp_aramBase+BIOS_DATA_OFFSET+i);
+      }
+
+	/* return with -1 if no sort, else return with
+	   logical card number sorted by BIOS (zero-based) */
+
+
+	pAdapterInfo->ai_relative_cardnum = 
+      (u08bits)(RD_HARPOON(ioport+hp_aramBase+BIOS_RELATIVE_CARD)-1); 
+
+   SGRAM_ACCESS(ioport);
+
+   s_PhaseTbl[0] = phaseDataOut;
+   s_PhaseTbl[1] = phaseDataIn;
+   s_PhaseTbl[2] = phaseIllegal;
+   s_PhaseTbl[3] = phaseIllegal;
+   s_PhaseTbl[4] = phaseCommand;
+   s_PhaseTbl[5] = phaseStatus;
+   s_PhaseTbl[6] = phaseMsgOut;
+   s_PhaseTbl[7] = phaseMsgIn;
+
+   pAdapterInfo->ai_present = 0x01;
+
+#if defined(BUGBUG)
+
+
+   for (i = 0; i < MAX_CARDS; i++) {
+
+      for (id=0; id<debug_size; id++)
+         debug_int[i][id] =  (u08bits)0x00;
+      debug_index[i] = 0;
+      }
+
+#endif
+
+   return(0);
+}
+
+
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: init_adapter, exported to BUDI via UCBMgr_init_adapter entry
+ *
+ *
+ * Description: Setup adapter for normal operation (hard reset).
+ *
+ *---------------------------------------------------------------------*/
+STATIC CARD_HANDLE init_adapter(PADAPTER_INFO pCardInfo)
+{
+   PSCCBcard CurrCard;
+	PNVRamInfo pCurrNvRam;
+   u08bits i,j,thisCard, ScamFlg;
+   u16bits temp,sync_bit_map,id;
+   BASE_PORT ioport;
+
+   ioport = (BASE_PORT)pCardInfo->ai_baseaddr;
+
+   for(thisCard =0; thisCard <= MAX_CARDS; thisCard++) {
+
+      if (thisCard == MAX_CARDS) {
+
+         return(FAILURE);
+         }
+
+      if (BL_Card[thisCard].ioPort == ioport) {
+
+         CurrCard = &BL_Card[thisCard];
+         SccbMgrTableInitCard(CurrCard,thisCard);
+         break;
+         }
+
+      else if (BL_Card[thisCard].ioPort == 0x00) {
+
+         BL_Card[thisCard].ioPort = ioport;
+         CurrCard = &BL_Card[thisCard];
+
+			if(mbCards)
+				for(i = 0; i < mbCards; i++){
+					if(CurrCard->ioPort == nvRamInfo[i].niBaseAddr)
+						CurrCard->pNvRamInfo = &nvRamInfo[i];
+				}
+         SccbMgrTableInitCard(CurrCard,thisCard);
+         CurrCard->cardIndex = thisCard;
+         CurrCard->cardInfo = pCardInfo;
+
+         break;
+         }
+      }
+
+	pCurrNvRam = CurrCard->pNvRamInfo;
+
+   
+	if(pCurrNvRam){
+		ScamFlg = pCurrNvRam->niScamConf;
+	}
+	else{
+	   ScamFlg = (UCHAR) utilEERead(ioport, SCAM_CONFIG/2);
+	}
+	
+
+   BusMasterInit(ioport);
+   XbowInit(ioport, ScamFlg);
+
+#if defined (NO_BIOS_OPTION)
+
+
+   if (DiagXbow(ioport)) return(FAILURE);
+   if (DiagBusMaster(ioport)) return(FAILURE);
+
+#endif  /* No BIOS Option */
+
+   autoLoadDefaultMap(ioport);
+
+
+   for (i = 0,id = 0x01; i != pCardInfo->ai_id; i++,id <<= 1){}
+
+   WR_HARPOON(ioport+hp_selfid_0, id);
+   WR_HARPOON(ioport+hp_selfid_1, 0x00);
+   WR_HARPOON(ioport+hp_arb_id, pCardInfo->ai_id);
+   CurrCard->ourId = (unsigned char) pCardInfo->ai_id;
+
+   i = (u08bits) pCardInfo->ai_stateinfo;
+   if (i & SCSI_PARITY_ENA)
+       WR_HARPOON(ioport+hp_portctrl_1,(HOST_MODE8 | CHK_SCSI_P));
+
+   j = (RD_HARPOON(ioport+hp_bm_ctrl) & ~SCSI_TERM_ENA_L);
+   if (i & LOW_BYTE_TERM_ENA)
+      j |= SCSI_TERM_ENA_L;
+   WR_HARPOON(ioport+hp_bm_ctrl, j);
+
+   j = (RD_HARPOON(ioport+hp_ee_ctrl) & ~SCSI_TERM_ENA_H);
+   if (i & HIGH_BYTE_TERM_ENA)
+      j |= SCSI_TERM_ENA_H;
+   WR_HARPOON(ioport+hp_ee_ctrl, j );
+
+
+   if (!(pCardInfo->ai_stateinfo & NO_RESET_IN_INIT)) {
+
+      sresb(ioport,thisCard);
+
+         scini(thisCard, (u08bits) pCardInfo->ai_id, 0);
+      }
+
+
+
+   if (pCardInfo->ai_stateinfo & SUPRESS_UNDERRRUNS_ENA)
+      CurrCard->globalFlags |= F_NO_FILTER;
+
+	if(pCurrNvRam){
+		if(pCurrNvRam->niSysConf & 0x10)
+			CurrCard->globalFlags |= F_GREEN_PC;
+	}
+	else{
+	   if (utilEERead(ioport, (SYSTEM_CONFIG/2)) & GREEN_PC_ENA)
+   	   CurrCard->globalFlags |= F_GREEN_PC;
+	}
+
+	/* Set global flag to indicate Re-Negotiation to be done on all
+		ckeck condition */
+	if(pCurrNvRam){
+		if(pCurrNvRam->niScsiConf & 0x04)
+			CurrCard->globalFlags |= F_DO_RENEGO;
+	}
+	else{
+	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & RENEGO_ENA)
+   	   CurrCard->globalFlags |= F_DO_RENEGO;
+	}
+
+	if(pCurrNvRam){
+		if(pCurrNvRam->niScsiConf & 0x08)
+			CurrCard->globalFlags |= F_CONLUN_IO;
+	}
+	else{
+	   if (utilEERead(ioport, (SCSI_CONFIG/2)) & CONNIO_ENA)
+   	   CurrCard->globalFlags |= F_CONLUN_IO;
+	}
+
+   temp = pCardInfo->ai_per_targ_no_disc;
+
+   for (i = 0,id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {
+
+      if (temp & id)
+         sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;
+      }
+
+   sync_bit_map = 0x0001;
+
+   for (id = 0; id < (MAX_SCSI_TAR/2); id++){
+
+		if(pCurrNvRam){
+			temp = (USHORT) pCurrNvRam->niSyncTbl[id];
+			temp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +
+					 (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));
+		}else
+	      temp = utilEERead(ioport, (u16bits)((SYNC_RATE_TBL/2)+id));
+
+      for (i = 0; i < 2; temp >>=8,i++){
+
+         if (pCardInfo->ai_per_targ_init_sync & sync_bit_map){
+
+            sccbMgrTbl[thisCard][id*2+i].TarEEValue = (u08bits)temp;
+            }
+
+         else {
+            sccbMgrTbl[thisCard][id*2+i].TarStatus |= SYNC_SUPPORTED;
+            sccbMgrTbl[thisCard][id*2+i].TarEEValue =
+               (u08bits)(temp & ~EE_SYNC_MASK);
+            }
+
+#if defined(WIDE_SCSI)
+/*         if ((pCardInfo->ai_per_targ_wide_nego & sync_bit_map) ||
+            (id*2+i >= 8)){
+*/
+         if (pCardInfo->ai_per_targ_wide_nego & sync_bit_map){
+
+            sccbMgrTbl[thisCard][id*2+i].TarEEValue |= EE_WIDE_SCSI;
+
+            }
+
+         else { /* NARROW SCSI */
+            sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
+            }
+
+#else
+         sccbMgrTbl[thisCard][id*2+i].TarStatus |= WIDE_NEGOCIATED;
+#endif
+
+
+         sync_bit_map <<= 1;
+         }
+      }
+
+
+   pCardInfo->ai_SGListFormat=0x01;
+   pCardInfo->ai_DataPtrFormat=0x01;
+   pCardInfo->ai_AEN_mask &= SCSI_RESET_COMPLETE;
+
+   WR_HARPOON((ioport+hp_semaphore),
+      (u08bits)(RD_HARPOON((ioport+hp_semaphore)) | SCCB_MGR_PRESENT));
+
+   return((u32bits)CurrCard);
+
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: build_ucb, exported to BUDI via UCBMgr_build_ucb entry
+ *
+ * Description: prepare fw portion of ucb. do not start, resource not guaranteed
+ *             so don't manipulate anything that's derived from states which
+ *             may change
+ *
+ *---------------------------------------------------------------------*/
+void build_UCB(CARD_HANDLE pCurrCard, PUCB p_ucb)
+{
+
+   u08bits thisCard;
+   u08bits i,j;
+
+   PSCCB p_sccb;
+
+
+   thisCard = ((PSCCBcard) pCurrCard)->cardIndex;
+
+
+   p_sccb=(PSCCB)p_ucb->UCB_MgrPrivatePtr;
+
+
+   p_sccb->Sccb_ucb_ptr=p_ucb;
+
+   switch (p_ucb->UCB_opcode & (OPC_DEVICE_RESET+OPC_XFER_SG+OPC_CHK_RESIDUAL))
+   {
+      case OPC_DEVICE_RESET:
+         p_sccb->OperationCode=RESET_COMMAND;
+         break;
+      case OPC_XFER_SG:
+         p_sccb->OperationCode=SCATTER_GATHER_COMMAND;
+         break;
+      case OPC_XFER_SG+OPC_CHK_RESIDUAL:
+         p_sccb->OperationCode=RESIDUAL_SG_COMMAND;
+         break;
+      case OPC_CHK_RESIDUAL:
+
+	      p_sccb->OperationCode=RESIDUAL_COMMAND;
+	      break;
+      default:
+	      p_sccb->OperationCode=SCSI_INITIATOR_COMMAND;
+	      break;
+   }
+
+   if (p_ucb->UCB_opcode & OPC_TQ_ENABLE)
+   {
+      p_sccb->ControlByte = (u08bits)((p_ucb->UCB_opcode & OPC_TQ_MASK)>>2) | F_USE_CMD_Q;
+   }
+   else
+   {
+      p_sccb->ControlByte = 0;
+   }
+
+
+   p_sccb->CdbLength = (u08bits)p_ucb->UCB_cdblen;
+
+   if (p_ucb->UCB_opcode & OPC_NO_AUTO_SENSE)
+   {
+      p_sccb->RequestSenseLength = 0;
+   }
+   else
+   {
+      p_sccb->RequestSenseLength = (unsigned char) p_ucb->UCB_senselen;
+   }
+
+
+   if (p_ucb->UCB_opcode & OPC_XFER_SG)
+   {
+      p_sccb->DataPointer=p_ucb->UCB_virt_dataptr;
+      p_sccb->DataLength = (((u32bits)p_ucb->UCB_NumSgElements)<<3);
+   }
+   else
+   {
+      p_sccb->DataPointer=p_ucb->UCB_phys_dataptr;
+      p_sccb->DataLength=p_ucb->UCB_datalen;
+   };
+
+   p_sccb->HostStatus=0;
+   p_sccb->TargetStatus=0;
+   p_sccb->TargID=(unsigned char)p_ucb->UCB_targid;
+   p_sccb->Lun=(unsigned char) p_ucb->UCB_lun;
+   p_sccb->SccbIOPort=((PSCCBcard)pCurrCard)->ioPort;
+
+   j=p_ucb->UCB_cdblen;
+   for (i=0;i<j;i++)
+   {
+      p_sccb->Cdb[i] = p_ucb->UCB_cdb[i];
+   }
+
+   p_sccb->SensePointer=p_ucb->UCB_phys_senseptr;
+
+   sinits(p_sccb,thisCard);
+
+}
+#ifndef NO_IOCTLS
+
+/*---------------------------------------------------------------------
+ *
+ * Function: GetDevSyncRate
+ *
+ *---------------------------------------------------------------------*/
+STATIC  int GetDevSyncRate(PSCCBcard pCurrCard,PUCB p_ucb)
+{
+	struct _SYNC_RATE_INFO * pSyncStr;
+   PSCCBMgr_tar_info currTar_Info;
+	BASE_PORT ioport;
+	u08bits scsiID, j;
+
+#if (FW_TYPE != _SCCB_MGR_)
+	if( p_ucb->UCB_targid >= pCurrCard->cardInfo->ai_MaxTarg )
+	{
+		return(1);
+	}
+#endif
+
+	ioport  = pCurrCard->ioPort;
+	pSyncStr	= (struct _SYNC_RATE_INFO *) p_ucb->UCB_virt_dataptr;
+	scsiID = (u08bits) p_ucb->UCB_targid;
+   currTar_Info = &sccbMgrTbl[pCurrCard->cardIndex][scsiID];
+	j = currTar_Info->TarSyncCtrl;
+
+	switch (currTar_Info->TarEEValue & EE_SYNC_MASK)
+	{
+		case EE_SYNC_ASYNC:
+			pSyncStr->RequestMegaXferRate = 0x00;
+			break;
+		case EE_SYNC_5MB:
+			pSyncStr->RequestMegaXferRate = (j & NARROW_SCSI) ? 50 : 100;
+			break;
+		case EE_SYNC_10MB:
+			pSyncStr->RequestMegaXferRate = (j & NARROW_SCSI) ? 100 : 200;
+			break;
+		case EE_SYNC_20MB:
+			pSyncStr->RequestMegaXferRate = (j & NARROW_SCSI) ? 200 : 400;
+			break;
+	}
+
+	switch ((j >> 5) & 0x07)
+	{
+		case 0x00:
+			if((j & 0x07) == 0x00)
+			{
+				pSyncStr->ActualMegaXferRate = 0x00;	/* Async Mode */
+			}
+			else
+			{
+				pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 200 : 400;
+			}
+			break;
+		case 0x01:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 100 : 200;
+			break;
+		case 0x02:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 66 : 122;
+			break;
+		case 0x03:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 50 : 100;
+			break;
+		case 0x04:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 40 : 80;
+			break;
+		case 0x05:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 33 : 66;
+			break;
+		case 0x06:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 28 : 56;
+			break;
+		case 0x07:
+			pSyncStr->ActualMegaXferRate = (j & NARROW_SCSI) ? 25 : 50;
+			break;
+	}
+	pSyncStr->NegotiatedOffset = j & 0x0f;
+
+	return(0);
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SetDevSyncRate
+ *
+ *---------------------------------------------------------------------*/
+STATIC int SetDevSyncRate(PSCCBcard pCurrCard, PUCB p_ucb)
+{
+	struct _SYNC_RATE_INFO * pSyncStr;
+   PSCCBMgr_tar_info currTar_Info;
+	BASE_PORT ioPort;
+	u08bits scsiID, i, j, syncVal;
+	u16bits syncOffset, actualXferRate;
+	union {
+		u08bits tempb[2];
+		u16bits tempw;
+	}temp2;
+
+#if (FW_TYPE != _SCCB_MGR_)
+	if( p_ucb->UCB_targid >= pCurrCard->cardInfo->ai_MaxTarg )
+	{
+		return(1);
+	}
+#endif
+
+	ioPort  = pCurrCard->ioPort;
+	pSyncStr	= (struct _SYNC_RATE_INFO *) p_ucb->UCB_virt_dataptr;
+	scsiID = (u08bits) p_ucb->UCB_targid;
+   currTar_Info = &sccbMgrTbl[pCurrCard->cardIndex][scsiID];
+	i = RD_HARPOON(ioPort+hp_xfer_pad);		/* Save current value */
+	WR_HARPOON(ioPort+hp_xfer_pad, (i | ID_UNLOCK));
+	WR_HARPOON(ioPort+hp_select_id, ((scsiID << 4) | scsiID));
+	j = RD_HARPOON(ioPort+hp_synctarg_0);
+	WR_HARPOON(ioPort+hp_xfer_pad, i);		/* restore value */
+
+	actualXferRate = pSyncStr->ActualMegaXferRate;
+	if(!(j & NARROW_SCSI))
+	{
+		actualXferRate <<= 1;
+	}
+	if(actualXferRate == 0x00)
+	{
+		syncVal = EE_SYNC_ASYNC;			/* Async Mode */
+	}
+	if(actualXferRate == 0x0200)
+	{
+		syncVal = EE_SYNC_20MB;				/* 20/40 MB Mode */
+	}
+	if(actualXferRate > 0x0050 && actualXferRate < 0x0200 )
+	{
+		syncVal = EE_SYNC_10MB;				/* 10/20 MB Mode */
+	}
+	else
+	{
+		syncVal = EE_SYNC_5MB;				/* 5/10 MB Mode */
+	}
+	if(currTar_Info->TarEEValue && EE_SYNC_MASK == syncVal)
+		return(0);
+	currTar_Info->TarEEValue = (currTar_Info->TarEEValue & !EE_SYNC_MASK)
+											| syncVal;
+	syncOffset = (SYNC_RATE_TBL + scsiID) / 2;
+	temp2.tempw = utilEERead(ioPort, syncOffset);
+	if(scsiID & 0x01)
+	{
+		temp2.tempb[0] = (temp2.tempb[0] & !EE_SYNC_MASK) | syncVal;
+	}
+	else
+	{
+		temp2.tempb[1] = (temp2.tempb[1] & !EE_SYNC_MASK) | syncVal;
+	}
+	utilEEWriteOnOff(ioPort, 1);
+	utilEEWrite(ioPort, temp2.tempw, syncOffset);
+	utilEEWriteOnOff(ioPort, 0);
+	UpdateCheckSum(ioPort);
+
+	return(0);
+}
+/*---------------------------------------------------------------------
+ *
+ * Function: GetDevWideMode
+ *
+ *---------------------------------------------------------------------*/
+int GetDevWideMode(PSCCBcard pCurrCard,PUCB p_ucb)
+{
+	u08bits *pData;
+
+	pData = (u08bits *)p_ucb->UCB_virt_dataptr;
+	if(sccbMgrTbl[pCurrCard->cardIndex][p_ucb->UCB_targid].TarEEValue
+				& EE_WIDE_SCSI)
+	{
+		*pData = 1;
+	}
+	else
+	{
+		*pData = 0;
+	}
+
+	return(0);
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SetDevWideMode
+ *
+ *---------------------------------------------------------------------*/
+int SetDevWideMode(PSCCBcard pCurrCard,PUCB p_ucb)
+{
+	u08bits *pData;
+   PSCCBMgr_tar_info currTar_Info;
+	BASE_PORT ioPort;
+	u08bits scsiID, scsiWideMode;
+	u16bits syncOffset;
+	union {
+		u08bits tempb[2];
+		u16bits tempw;
+	}temp2;
+
+#if (FW_TYPE != _SCCB_MGR_)
+	if( !(pCurrCard->cardInfo->ai_attributes & WIDE_CAPABLE) )
+	{
+		return(1);
+	}
+
+	if( p_ucb->UCB_targid >= pCurrCard->cardInfo->ai_MaxTarg )
+	{
+		return(1);
+	}
+#endif
+
+	ioPort  = pCurrCard->ioPort;
+	pData = (u08bits *)p_ucb->UCB_virt_dataptr;
+	scsiID = (u08bits) p_ucb->UCB_targid;
+	currTar_Info = &sccbMgrTbl[pCurrCard->cardIndex][scsiID];
+
+	if(*pData)
+	{
+		if(currTar_Info->TarEEValue & EE_WIDE_SCSI)
+		{
+			return(0);
+		}
+		else
+		{
+			scsiWideMode = EE_WIDE_SCSI;
+		}
+	}
+	else
+	{
+		if(!(currTar_Info->TarEEValue & EE_WIDE_SCSI))
+		{
+			return(0);
+		}
+		else
+		{
+			scsiWideMode = 0;
+		}
+	}
+	currTar_Info->TarEEValue = (currTar_Info->TarEEValue & !EE_WIDE_SCSI)
+											| scsiWideMode;
+
+	syncOffset = (SYNC_RATE_TBL + scsiID) / 2;
+	temp2.tempw = utilEERead(ioPort, syncOffset);
+	if(scsiID & 0x01)
+	{
+		temp2.tempb[0] = (temp2.tempb[0] & !EE_WIDE_SCSI) | scsiWideMode;
+	}
+	else
+	{
+		temp2.tempb[1] = (temp2.tempb[1] & !EE_WIDE_SCSI) | scsiWideMode;
+	}
+	utilEEWriteOnOff(ioPort, 1);
+	utilEEWrite(ioPort, temp2.tempw, syncOffset);
+	utilEEWriteOnOff(ioPort, 0);
+	UpdateCheckSum(ioPort);
+
+	return(0);
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: ReadNVRam
+ *
+ *---------------------------------------------------------------------*/
+void ReadNVRam(PSCCBcard pCurrCard,PUCB p_ucb)
+{
+	u08bits *pdata;
+	u16bits i,numwrds,numbytes,offset,temp;
+	u08bits OneMore = FALSE;
+#if defined(DOS)
+	u16bits ioport;
+#else
+	u32bits ioport;
+#endif
+
+	numbytes = (u16bits) p_ucb->UCB_datalen;
+	ioport  = pCurrCard->ioPort;
+   pdata   = (u08bits *) p_ucb->UCB_virt_dataptr;
+	offset  = (u16bits) (p_ucb->UCB_IOCTLParams[0]);
+
+
+
+   if (offset & 0x1)
+	{
+	    *((u16bits*) pdata) = utilEERead(ioport,(u16bits)((offset - 1) / 2)); /* 16 bit read */
+		 *pdata = *(pdata + 1);
+		 ++offset;
+   	 ++pdata;
+		 --numbytes;
+	}
+
+	numwrds = numbytes / 2;
+	if (numbytes & 1)
+	 	OneMore = TRUE;
+
+	for (i = 0; i < numwrds; i++)
+	{
+   	*((u16bits*) pdata) = utilEERead(ioport,(u16bits)(offset / 2));
+		pdata += 2;
+		offset += 2;
+   }
+	if (OneMore)
+	{
+		--pdata;
+		-- offset;
+   	temp = utilEERead(ioport,(u16bits)(offset / 2));
+		*pdata = (u08bits) (temp);
+	}
+
+} /* end proc ReadNVRam */
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: WriteNVRam
+ *
+ *---------------------------------------------------------------------*/
+void WriteNVRam(PSCCBcard pCurrCard,PUCB p_ucb)
+{
+	u08bits *pdata;
+	u16bits i,numwrds,numbytes,offset, eeprom_end;
+	u08bits OneMore = FALSE;
+	union {
+		u08bits  tempb[2];
+		u16bits  tempw;
+	} temp2;
+
+#if defined(DOS)
+	u16bits ioport;
+#else
+	u32bits ioport;
+#endif
+
+	numbytes = (u16bits) p_ucb->UCB_datalen;
+	ioport  = pCurrCard->ioPort;
+   pdata   = (u08bits *) p_ucb->UCB_virt_dataptr;
+	offset  = (u16bits) (p_ucb->UCB_IOCTLParams[0]);
+
+   if (RD_HARPOON(ioport+hp_page_ctrl) & NARROW_SCSI_CARD)
+      eeprom_end = 512;
+   else
+      eeprom_end = 768;
+	
+	if(offset > eeprom_end)
+		return;
+
+	if((offset + numbytes) > eeprom_end)
+		numbytes = eeprom_end - offset;
+
+    utilEEWriteOnOff(ioport,1);   /* Enable write access to the EEPROM */
+
+
+
+   if (offset & 0x1)
+	{
+	    temp2.tempw = utilEERead(ioport,(u16bits)((offset - 1) / 2)); /* 16 bit read */
+		 temp2.tempb[1] = *pdata;
+	    utilEEWrite(ioport, temp2.tempw, (u16bits)((offset -1) / 2));
+		 *pdata = *(pdata + 1);
+		 ++offset;
+   	 ++pdata;
+		 --numbytes;
+	}
+
+	numwrds = numbytes / 2;
+	if (numbytes & 1)
+	 	OneMore = TRUE;
+
+	for (i = 0; i < numwrds; i++)
+	{
+   	utilEEWrite(ioport, *((pu16bits)pdata),(u16bits)(offset / 2));
+		pdata += 2;
+		offset += 2;
+   }
+	if (OneMore)
+	{
+
+   	temp2.tempw = utilEERead(ioport,(u16bits)(offset / 2));
+		temp2.tempb[0] = *pdata;
+   	utilEEWrite(ioport, temp2.tempw, (u16bits)(offset / 2));
+	}
+   utilEEWriteOnOff(ioport,0);   /* Turn off write access */
+   UpdateCheckSum((u32bits)ioport);
+
+} /* end proc WriteNVRam */
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: UpdateCheckSum
+ *
+ * Description: Update Check Sum in EEPROM
+ *
+ *---------------------------------------------------------------------*/
+
+
+void UpdateCheckSum(u32bits baseport)
+{
+	USHORT i,sum_data, eeprom_end;
+
+	sum_data = 0x0000;
+
+
+   if (RD_HARPOON(baseport+hp_page_ctrl) & NARROW_SCSI_CARD)
+      eeprom_end = 512;
+   else
+      eeprom_end = 768;
+
+	for (i = 1; i < eeprom_end/2; i++)
+	{
+		sum_data += utilEERead(baseport, i);
+	}
+
+   utilEEWriteOnOff(baseport,1);   /* Enable write access to the EEPROM */
+
+   utilEEWrite(baseport, sum_data, EEPROM_CHECK_SUM/2);
+   utilEEWriteOnOff(baseport,0);   /* Turn off write access */
+}
+
+void SccbMgr_save_foreign_state(PADAPTER_INFO pAdapterInfo)
+{
+}
+
+
+void SccbMgr_restore_foreign_state(CARD_HANDLE pCurrCard)
+{
+}
+
+void SccbMgr_restore_native_state(CARD_HANDLE pCurrCard)
+{
+}
+
+#endif /* NO_IOCTLS */
+
+#endif /* (FW_TYPE==_UCB_MGR_)   */
+
+#ifndef NO_IOCTLS
+#if (FW_TYPE==_UCB_MGR_)
+void SccbMgr_unload_card(CARD_HANDLE pCurrCard)
+#else
+#if defined(DOS)
+void SccbMgr_unload_card(USHORT pCurrCard)
+#else
+void SccbMgr_unload_card(ULONG pCurrCard)
+#endif
+#endif
+{
+	UCHAR i;
+#if defined(DOS)
+	USHORT portBase;
+	USHORT regOffset;
+#else
+	ULONG portBase;
+	ULONG regOffset;
+#endif
+	ULONG scamData;
+#if defined(OS2)
+	ULONG far *pScamTbl;
+#else
+	ULONG *pScamTbl;
+#endif
+	PNVRamInfo pCurrNvRam;
+
+	pCurrNvRam = ((PSCCBcard)pCurrCard)->pNvRamInfo;
+
+	if(pCurrNvRam){
+		WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);
+		WrStack(pCurrNvRam->niBaseAddr, 1, pCurrNvRam->niSysConf);
+		WrStack(pCurrNvRam->niBaseAddr, 2, pCurrNvRam->niScsiConf);
+		WrStack(pCurrNvRam->niBaseAddr, 3, pCurrNvRam->niScamConf);
+		WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);
+
+		for(i = 0; i < MAX_SCSI_TAR / 2; i++)
+			WrStack(pCurrNvRam->niBaseAddr, (UCHAR)(i+5), pCurrNvRam->niSyncTbl[i]);
+
+		portBase = pCurrNvRam->niBaseAddr;
+
+		for(i = 0; i < MAX_SCSI_TAR; i++){
+			regOffset = hp_aramBase + 64 + i*4;
+#if defined(OS2)
+			pScamTbl = (ULONG far *) &pCurrNvRam->niScamTbl[i];
+#else
+			pScamTbl = (ULONG *) &pCurrNvRam->niScamTbl[i];
+#endif
+			scamData = *pScamTbl;
+			WR_HARP32(portBase, regOffset, scamData);
+		}
+
+	}else{
+		WrStack(((PSCCBcard)pCurrCard)->ioPort, 0, 0);
+	}
+}
+#endif /* NO_IOCTLS */
+
+
+void RNVRamData(PNVRamInfo pNvRamInfo)
+{
+	UCHAR i;
+#if defined(DOS)
+	USHORT portBase;
+	USHORT regOffset;
+#else
+	ULONG portBase;
+	ULONG regOffset;
+#endif
+	ULONG scamData;
+#if defined (OS2)
+	ULONG far *pScamTbl;
+#else
+	ULONG *pScamTbl;
+#endif
+
+	pNvRamInfo->niModel    = RdStack(pNvRamInfo->niBaseAddr, 0);
+	pNvRamInfo->niSysConf  = RdStack(pNvRamInfo->niBaseAddr, 1);
+	pNvRamInfo->niScsiConf = RdStack(pNvRamInfo->niBaseAddr, 2);
+	pNvRamInfo->niScamConf = RdStack(pNvRamInfo->niBaseAddr, 3);
+	pNvRamInfo->niAdapId   = RdStack(pNvRamInfo->niBaseAddr, 4);
+
+	for(i = 0; i < MAX_SCSI_TAR / 2; i++)
+		pNvRamInfo->niSyncTbl[i] = RdStack(pNvRamInfo->niBaseAddr, (UCHAR)(i+5));
+
+	portBase = pNvRamInfo->niBaseAddr;
+
+	for(i = 0; i < MAX_SCSI_TAR; i++){
+		regOffset = hp_aramBase + 64 + i*4;
+		RD_HARP32(portBase, regOffset, scamData);
+#if defined(OS2)
+		pScamTbl = (ULONG far *) &pNvRamInfo->niScamTbl[i];
+#else
+		pScamTbl = (ULONG *) &pNvRamInfo->niScamTbl[i];
+#endif
+		*pScamTbl = scamData;
+	}
+
+}
+
+#if defined(DOS)
+UCHAR RdStack(USHORT portBase, UCHAR index)
+#else
+UCHAR RdStack(ULONG portBase, UCHAR index)
+#endif
+{
+	WR_HARPOON(portBase + hp_stack_addr, index);
+	return(RD_HARPOON(portBase + hp_stack_data));
+}
+
+#if defined(DOS)
+void WrStack(USHORT portBase, UCHAR index, UCHAR data)
+#else
+void WrStack(ULONG portBase, UCHAR index, UCHAR data)
+#endif
+{
+	WR_HARPOON(portBase + hp_stack_addr, index);
+	WR_HARPOON(portBase + hp_stack_data, data);
+}
+
+
+#if (FW_TYPE==_UCB_MGR_)
+u08bits ChkIfChipInitialized(BASE_PORT ioPort)
+#else
+#if defined(DOS)
+UCHAR ChkIfChipInitialized(USHORT ioPort)
+#else
+UCHAR ChkIfChipInitialized(ULONG ioPort)
+#endif
+#endif
+{
+	if((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != RdStack(ioPort, 4))
+		return(FALSE);
+	if((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)
+								!= CLKCTRL_DEFAULT)
+		return(FALSE);
+	if((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||
+		(RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))
+		return(TRUE);
+	return(FALSE);
+
+}
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_start_sccb
+ *
+ * Description: Start a command pointed to by p_Sccb. When the
+ *              command is completed it will be returned via the
+ *              callback function.
+ *
+ *---------------------------------------------------------------------*/
+#if (FW_TYPE==_UCB_MGR_)
+void SccbMgr_start_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb)
+#else
+#if defined(DOS)
+void SccbMgr_start_sccb(USHORT pCurrCard, PSCCB p_Sccb)
+#else
+void SccbMgr_start_sccb(ULONG pCurrCard, PSCCB p_Sccb)
+#endif
+#endif
+{
+#if defined(DOS)
+   USHORT ioport;
+#else
+   ULONG ioport;
+#endif
+   UCHAR thisCard, lun;
+	PSCCB pSaveSccb;
+   CALL_BK_FN callback;
+
+#if (FW_TYPE==_UCB_MGR_)
+   PSCCB p_Sccb;
+#endif
+
+   mOS_Lock((PSCCBcard)pCurrCard);
+   thisCard = ((PSCCBcard) pCurrCard)->cardIndex;
+   ioport = ((PSCCBcard) pCurrCard)->ioPort;
+
+#if (FW_TYPE==_UCB_MGR_)
+   p_Sccb = (PSCCB)p_ucb->UCB_MgrPrivatePtr;
+#endif
+
+	if((p_Sccb->TargID > MAX_SCSI_TAR) || (p_Sccb->Lun > MAX_LUN))
+	{
+
+#if (FW_TYPE==_UCB_MGR_)
+		p_ucb->UCB_hbastat = SCCB_COMPLETE;
+		p_ucb->UCB_status=SCCB_ERROR;
+		callback = (CALL_BK_FN)p_ucb->UCB_callback;
+		if (callback)
+			callback(p_ucb);
+#endif
+
+#if (FW_TYPE==_SCCB_MGR_)
+		p_Sccb->HostStatus = SCCB_COMPLETE;
+		p_Sccb->SccbStatus = SCCB_ERROR;
+		callback = (CALL_BK_FN)p_Sccb->SccbCallback;
+		if (callback)
+			callback(p_Sccb);
+#endif
+
+		mOS_UnLock((PSCCBcard)pCurrCard);
+		return;
+	}
+
+#if (FW_TYPE==_SCCB_MGR_)
+   sinits(p_Sccb,thisCard);
+#endif
+
+
+#if (FW_TYPE==_UCB_MGR_)
+#ifndef NO_IOCTLS
+
+   if (p_ucb->UCB_opcode & OPC_IOCTL)
+	{
+
+		switch (p_ucb->UCB_IOCTLCommand) 
+		{
+			case READ_NVRAM:
+				ReadNVRam((PSCCBcard)pCurrCard,p_ucb);
+				p_ucb->UCB_status=UCB_SUCCESS;
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+
+			case WRITE_NVRAM:
+				WriteNVRam((PSCCBcard)pCurrCard,p_ucb);
+				p_ucb->UCB_status=UCB_SUCCESS;
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+
+			case SEND_SCSI_PASSTHRU:
+#if (FW_TYPE != _SCCB_MGR_)
+				if( p_ucb->UCB_targid >=
+				    ((PSCCBcard)pCurrCard)->cardInfo->ai_MaxTarg )
+				{
+					p_ucb->UCB_status = UCB_ERROR;
+					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
+					callback = (CALL_BK_FN)p_ucb->UCB_callback;
+					if (callback)
+						callback(p_ucb);
+					mOS_UnLock((PSCCBcard)pCurrCard);
+					return;
+				}
+#endif
+				break;
+
+			case HARD_RESET:
+				p_ucb->UCB_status = UCB_INVALID;
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+			case GET_DEVICE_SYNCRATE:
+				if( !GetDevSyncRate((PSCCBcard)pCurrCard,p_ucb) )
+				{
+					p_ucb->UCB_status = UCB_SUCCESS;
+				}
+				else
+				{
+					p_ucb->UCB_status = UCB_ERROR;
+					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
+				}
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+			case SET_DEVICE_SYNCRATE:
+				if( !SetDevSyncRate((PSCCBcard)pCurrCard,p_ucb) )
+				{
+					p_ucb->UCB_status = UCB_SUCCESS;
+				}
+				else
+				{
+					p_ucb->UCB_status = UCB_ERROR;
+					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
+				}
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+			case GET_WIDE_MODE:
+				if( !GetDevWideMode((PSCCBcard)pCurrCard,p_ucb) )
+				{
+					p_ucb->UCB_status = UCB_SUCCESS;
+				}
+				else
+				{
+					p_ucb->UCB_status = UCB_ERROR;
+					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
+				}
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+			case SET_WIDE_MODE:
+				if( !SetDevWideMode((PSCCBcard)pCurrCard,p_ucb) )
+				{
+					p_ucb->UCB_status = UCB_SUCCESS;
+				}
+				else
+				{
+					p_ucb->UCB_status = UCB_ERROR;
+					p_ucb->UCB_hbastat = HASTAT_HW_ERROR;
+				}
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+			default:
+				p_ucb->UCB_status=UCB_INVALID;
+				callback = (CALL_BK_FN)p_ucb->UCB_callback;
+				if (callback)
+					callback(p_ucb);
+				mOS_UnLock((PSCCBcard)pCurrCard);
+				return;
+		}
+	}
+#endif /* NO_IOCTLS */
+#endif /* (FW_TYPE==_UCB_MGR_) */
+
+
+   if (!((PSCCBcard) pCurrCard)->cmdCounter)
+      {
+      WR_HARPOON(ioport+hp_semaphore, (RD_HARPOON(ioport+hp_semaphore)
+         | SCCB_MGR_ACTIVE));
+
+      if (((PSCCBcard) pCurrCard)->globalFlags & F_GREEN_PC)
+         {
+		 WR_HARPOON(ioport+hp_clkctrl_0, CLKCTRL_DEFAULT);
+		 WR_HARPOON(ioport+hp_sys_ctrl, 0x00);
+         }
+      }
+
+   ((PSCCBcard)pCurrCard)->cmdCounter++;
+
+   if (RD_HARPOON(ioport+hp_semaphore) & BIOS_IN_USE) {
+
+      WR_HARPOON(ioport+hp_semaphore, (RD_HARPOON(ioport+hp_semaphore)
+         | TICKLE_ME));
+		if(p_Sccb->OperationCode == RESET_COMMAND)
+			{
+				pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
+				((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+				queueSelectFail(&BL_Card[thisCard], thisCard);
+				((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
+			}
+		else
+			{
+	      queueAddSccb(p_Sccb,thisCard);
+			}
+      }
+
+   else if ((RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE)) {
+
+			if(p_Sccb->OperationCode == RESET_COMMAND)
+				{
+					pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
+					((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+					queueSelectFail(&BL_Card[thisCard], thisCard);
+					((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
+				}
+			else
+				{
+		      queueAddSccb(p_Sccb,thisCard);
+				}
+      }
+
+   else {
+
+      MDISABLE_INT(ioport);
+
+		if((((PSCCBcard) pCurrCard)->globalFlags & F_CONLUN_IO) && 
+			((sccbMgrTbl[thisCard][p_Sccb->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+			lun = p_Sccb->Lun;
+		else
+			lun = 0;
+      if ((((PSCCBcard) pCurrCard)->currentSCCB == NULL) &&
+         (sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0) &&
+         (sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]
+         == FALSE)) {
+
+            ((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+			   mOS_UnLock((PSCCBcard)pCurrCard);
+#if defined(DOS)
+            ssel((USHORT)p_Sccb->SccbIOPort,thisCard);
+#else
+	    ssel(p_Sccb->SccbIOPort,thisCard);
+#endif
+			   mOS_Lock((PSCCBcard)pCurrCard);
+         }
+
+      else {
+
+			if(p_Sccb->OperationCode == RESET_COMMAND)
+				{
+					pSaveSccb = ((PSCCBcard) pCurrCard)->currentSCCB;
+					((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+					queueSelectFail(&BL_Card[thisCard], thisCard);
+					((PSCCBcard) pCurrCard)->currentSCCB = pSaveSccb;
+				}
+			else
+				{
+	         	queueAddSccb(p_Sccb,thisCard);
+				}
+         }
+
+
+      MENABLE_INT(ioport);
+      }
+
+   mOS_UnLock((PSCCBcard)pCurrCard);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_abort_sccb
+ *
+ * Description: Abort the command pointed to by p_Sccb.  When the
+ *              command is completed it will be returned via the
+ *              callback function.
+ *
+ *---------------------------------------------------------------------*/
+#if (FW_TYPE==_UCB_MGR_)
+s32bits SccbMgr_abort_sccb(CARD_HANDLE pCurrCard, PUCB p_ucb)
+#else
+#if defined(DOS)
+int SccbMgr_abort_sccb(USHORT pCurrCard, PSCCB p_Sccb)
+#else
+int SccbMgr_abort_sccb(ULONG pCurrCard, PSCCB p_Sccb)
+#endif
+#endif
+
+{
+#if defined(DOS)
+	USHORT ioport;
+#else
+	ULONG ioport;
+#endif
+
+	UCHAR thisCard;
+	CALL_BK_FN callback;
+	UCHAR TID;
+	PSCCB pSaveSCCB;
+	PSCCBMgr_tar_info currTar_Info;
+
+
+#if (FW_TYPE==_UCB_MGR_)
+	PSCCB    p_Sccb;
+	p_Sccb=(PSCCB)p_ucb->UCB_MgrPrivatePtr;
+#endif
+
+	ioport = ((PSCCBcard) pCurrCard)->ioPort;
+
+	thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
+
+	mOS_Lock((PSCCBcard)pCurrCard);
+
+	if (RD_HARPOON(ioport+hp_page_ctrl) & G_INT_DISABLE)
+	{
+		mOS_UnLock((PSCCBcard)pCurrCard);
+	}
+
+	else
+	{
+
+		if (queueFindSccb(p_Sccb,thisCard))
+		{
+
+			mOS_UnLock((PSCCBcard)pCurrCard);
+
+			((PSCCBcard)pCurrCard)->cmdCounter--;
+
+			if (!((PSCCBcard)pCurrCard)->cmdCounter)
+				WR_HARPOON(ioport+hp_semaphore,(RD_HARPOON(ioport+hp_semaphore)
+					& (UCHAR)(~(SCCB_MGR_ACTIVE | TICKLE_ME)) ));
+
+#if (FW_TYPE==_SCCB_MGR_)
+			p_Sccb->SccbStatus = SCCB_ABORT;
+			callback = p_Sccb->SccbCallback;
+			callback(p_Sccb);
+#else
+			p_ucb->UCB_status=SCCB_ABORT;
+			callback = (CALL_BK_FN)p_ucb->UCB_callback;
+			callback(p_ucb);
+#endif
+
+			return(0);
+		}
+
+		else
+		{
+			mOS_UnLock((PSCCBcard)pCurrCard);
+
+			if (((PSCCBcard)pCurrCard)->currentSCCB == p_Sccb)
+			{
+				p_Sccb->SccbStatus = SCCB_ABORT;
+				return(0);
+
+			}
+
+			else
+			{
+
+				TID = p_Sccb->TargID;
+
+
+				if(p_Sccb->Sccb_tag)
+				{
+					MDISABLE_INT(ioport);
+					if (((PSCCBcard) pCurrCard)->discQ_Tbl[p_Sccb->Sccb_tag]==p_Sccb)
+					{
+						p_Sccb->SccbStatus = SCCB_ABORT;
+						p_Sccb->Sccb_scsistat = ABORT_ST;
+#if (FW_TYPE==_UCB_MGR_)
+						p_ucb->UCB_status=SCCB_ABORT;
+#endif
+						p_Sccb->Sccb_scsimsg = SMABORT_TAG;
+
+						if(((PSCCBcard) pCurrCard)->currentSCCB == NULL)
+						{
+							((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+							ssel(ioport, thisCard);
+						}
+						else
+						{
+							pSaveSCCB = ((PSCCBcard) pCurrCard)->currentSCCB;
+							((PSCCBcard) pCurrCard)->currentSCCB = p_Sccb;
+							queueSelectFail((PSCCBcard) pCurrCard, thisCard);
+							((PSCCBcard) pCurrCard)->currentSCCB = pSaveSCCB;
+						}
+					}
+					MENABLE_INT(ioport);
+					return(0);
+				}
+				else
+				{
+					currTar_Info = &sccbMgrTbl[thisCard][p_Sccb->TargID];
+
+					if(BL_Card[thisCard].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_Sccb->Lun]] 
+							== p_Sccb)
+					{
+						p_Sccb->SccbStatus = SCCB_ABORT;
+						return(0);
+					}
+				}
+			}
+		}
+	}
+	return(-1);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_my_int
+ *
+ * Description: Do a quick check to determine if there is a pending
+ *              interrupt for this card and disable the IRQ Pin if so.
+ *
+ *---------------------------------------------------------------------*/
+#if (FW_TYPE==_UCB_MGR_)
+u08bits SccbMgr_my_int(CARD_HANDLE pCurrCard)
+#else
+#if defined(DOS)
+UCHAR SccbMgr_my_int(USHORT pCurrCard)
+#else
+UCHAR SccbMgr_my_int(ULONG pCurrCard)
+#endif
+#endif
+{
+#if defined(DOS)
+   USHORT ioport;
+#else
+   ULONG ioport;
+#endif
+
+   ioport = ((PSCCBcard)pCurrCard)->ioPort;
+
+   if (RD_HARPOON(ioport+hp_int_status) & INT_ASSERTED)
+   {
+
+#if defined(DOS)
+      MDISABLE_INT(ioport);
+#endif
+
+      return(TRUE);
+   }
+
+   else
+
+      return(FALSE);
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_isr
+ *
+ * Description: This is our entry point when an interrupt is generated
+ *              by the card and the upper level driver passes it on to
+ *              us.
+ *
+ *---------------------------------------------------------------------*/
+#if (FW_TYPE==_UCB_MGR_)
+s32bits SccbMgr_isr(CARD_HANDLE pCurrCard)
+#else
+#if defined(DOS)
+int SccbMgr_isr(USHORT pCurrCard)
+#else
+int SccbMgr_isr(ULONG pCurrCard)
+#endif
+#endif
+{
+   PSCCB currSCCB;
+   UCHAR thisCard,result,bm_status, bm_int_st;
+   USHORT hp_int;
+   UCHAR i, target;
+#if defined(DOS)
+   USHORT ioport;
+#else
+   ULONG ioport;
+#endif
+
+   mOS_Lock((PSCCBcard)pCurrCard);
+
+   thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
+   ioport = ((PSCCBcard)pCurrCard)->ioPort;
+
+   MDISABLE_INT(ioport);
+
+#if defined(BUGBUG)
+   WR_HARPOON(ioport+hp_user_defined_D, RD_HARPOON(ioport+hp_int_status));
+#endif
+
+   if ((bm_int_st=RD_HARPOON(ioport+hp_int_status)) & EXT_STATUS_ON)
+		bm_status = RD_HARPOON(ioport+hp_ext_status) & (UCHAR)BAD_EXT_STATUS;
+   else
+      bm_status = 0;
+
+   WR_HARPOON(ioport+hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
+
+   mOS_UnLock((PSCCBcard)pCurrCard);
+
+   while ((hp_int = RDW_HARPOON((ioport+hp_intstat)) & default_intena) |
+	  bm_status)
+     {
+
+       currSCCB = ((PSCCBcard)pCurrCard)->currentSCCB;
+
+#if defined(BUGBUG)
+   Debug_Load(thisCard,(UCHAR) 0XFF);
+   Debug_Load(thisCard,bm_int_st);
+
+   Debug_Load(thisCard,hp_int_0);
+   Debug_Load(thisCard,hp_int_1);
+#endif
+
+
+      if (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {
+         result = SccbMgr_bad_isr(ioport,thisCard,((PSCCBcard)pCurrCard),hp_int);
+         WRW_HARPOON((ioport+hp_intstat), (FIFO | TIMEOUT | RESET | SCAM_SEL));
+         bm_status = 0;
+
+         if (result) {
+
+			   mOS_Lock((PSCCBcard)pCurrCard);
+            MENABLE_INT(ioport);
+			   mOS_UnLock((PSCCBcard)pCurrCard);
+            return(result);
+            }
+         }
+
+
+      else if (hp_int & ICMD_COMP) {
+
+         if ( !(hp_int & BUS_FREE) ) {
+            /* Wait for the BusFree before starting a new command.  We
+               must also check for being reselected since the BusFree
+               may not show up if another device reselects us in 1.5us or
+               less.  SRR Wednesday, 3/8/1995.
+	         */
+	   while (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL))) ;
+	 }
+
+         if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
+
+            phaseChkFifo(ioport, thisCard);
+
+/*         WRW_HARPOON((ioport+hp_intstat),
+            (BUS_FREE | ICMD_COMP | ITAR_DISC | XFER_CNT_0));
+         */
+
+		 WRW_HARPOON((ioport+hp_intstat), CLR_ALL_INT_1);
+
+         autoCmdCmplt(ioport,thisCard);
+
+         }
+
+
+      else if (hp_int & ITAR_DISC)
+         {
+
+         if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
+
+            phaseChkFifo(ioport, thisCard);
+
+            }
+
+         if (RD_HARPOON(ioport+hp_gp_reg_1) == SMSAVE_DATA_PTR) {
+
+            WR_HARPOON(ioport+hp_gp_reg_1, 0x00);
+            currSCCB->Sccb_XferState |= F_NO_DATA_YET;
+
+            currSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;
+            }
+
+         currSCCB->Sccb_scsistat = DISCONNECT_ST;
+         queueDisconnect(currSCCB,thisCard);
+
+            /* Wait for the BusFree before starting a new command.  We
+               must also check for being reselected since the BusFree
+               may not show up if another device reselects us in 1.5us or
+               less.  SRR Wednesday, 3/8/1995.
+             */
+	   while (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL)) &&
+		  !((RDW_HARPOON((ioport+hp_intstat)) & PHASE) &&
+		    RD_HARPOON((ioport+hp_scsisig)) ==
+		    (SCSI_BSY | SCSI_REQ | SCSI_CD | SCSI_MSG | SCSI_IOBIT))) ;
+
+	   /*
+	     The additional loop exit condition above detects a timing problem
+	     with the revision D/E harpoon chips.  The caller should reset the
+	     host adapter to recover when 0xFE is returned.
+	   */
+	   if (!(RDW_HARPOON((ioport+hp_intstat)) & (BUS_FREE | RSEL)))
+	     {
+	       mOS_Lock((PSCCBcard)pCurrCard);
+	       MENABLE_INT(ioport);
+	       mOS_UnLock((PSCCBcard)pCurrCard);
+	       return 0xFE;
+	     }
+
+         WRW_HARPOON((ioport+hp_intstat), (BUS_FREE | ITAR_DISC));
+
+
+         ((PSCCBcard)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
+
+      	}
+
+
+      else if (hp_int & RSEL) {
+
+         WRW_HARPOON((ioport+hp_intstat), (PROG_HLT | RSEL | PHASE | BUS_FREE));
+
+         if (RDW_HARPOON((ioport+hp_intstat)) & ITAR_DISC)
+		      {
+            if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT)
+			      {
+               phaseChkFifo(ioport, thisCard);
+               }
+
+            if (RD_HARPOON(ioport+hp_gp_reg_1) == SMSAVE_DATA_PTR)
+			      {
+               WR_HARPOON(ioport+hp_gp_reg_1, 0x00);
+               currSCCB->Sccb_XferState |= F_NO_DATA_YET;
+               currSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;
+               }
+
+            WRW_HARPOON((ioport+hp_intstat), (BUS_FREE | ITAR_DISC));
+            currSCCB->Sccb_scsistat = DISCONNECT_ST;
+            queueDisconnect(currSCCB,thisCard);
+            }
+
+         sres(ioport,thisCard,((PSCCBcard)pCurrCard));
+         phaseDecode(ioport,thisCard);
+
+         }
+
+
+      else if ((hp_int & IDO_STRT) && (!(hp_int & BUS_FREE)))
+         {
+
+            WRW_HARPOON((ioport+hp_intstat), (IDO_STRT | XFER_CNT_0));
+            phaseDecode(ioport,thisCard);
+
+         }
+
+
+      else if ( (hp_int & IUNKWN) || (hp_int & PROG_HLT) )
+		   {
+	 	   WRW_HARPOON((ioport+hp_intstat), (PHASE | IUNKWN | PROG_HLT));
+	 	   if ((RD_HARPOON(ioport+hp_prgmcnt_0) & (UCHAR)0x3f)< (UCHAR)SELCHK)
+	    		{
+	    		phaseDecode(ioport,thisCard);
+	    		}
+	 	   else
+	    		{
+   /* Harpoon problem some SCSI target device respond to selection
+   with short BUSY pulse (<400ns) this will make the Harpoon is not able
+   to latch the correct Target ID into reg. x53.
+   The work around require to correct this reg. But when write to this
+   reg. (0x53) also increment the FIFO write addr reg (0x6f), thus we
+   need to read this reg first then restore it later. After update to 0x53 */
+
+	    		i = (UCHAR)(RD_HARPOON(ioport+hp_fifowrite));
+	    		target = (UCHAR)(RD_HARPOON(ioport+hp_gp_reg_3));
+	    		WR_HARPOON(ioport+hp_xfer_pad, (UCHAR) ID_UNLOCK);
+	    		WR_HARPOON(ioport+hp_select_id, (UCHAR)(target | target<<4));
+	    		WR_HARPOON(ioport+hp_xfer_pad, (UCHAR) 0x00);
+	    		WR_HARPOON(ioport+hp_fifowrite, i);
+	    		WR_HARPOON(ioport+hp_autostart_3, (AUTO_IMMED+TAG_STRT));
+	    		}
+	 	   }
+
+      else if (hp_int & XFER_CNT_0) {
+
+         WRW_HARPOON((ioport+hp_intstat), XFER_CNT_0);
+
+         schkdd(ioport,thisCard);
+
+         }
+
+
+      else if (hp_int & BUS_FREE) {
+
+         WRW_HARPOON((ioport+hp_intstat), BUS_FREE);
+
+        	if (((PSCCBcard)pCurrCard)->globalFlags & F_HOST_XFER_ACT) {
+
+           	hostDataXferAbort(ioport,thisCard,currSCCB);
+				}
+
+         phaseBusFree(ioport,thisCard);
+			}
+
+
+      else if (hp_int & ITICKLE) {
+
+         WRW_HARPOON((ioport+hp_intstat), ITICKLE);
+         ((PSCCBcard)pCurrCard)->globalFlags |= F_NEW_SCCB_CMD;
+         }
+
+
+
+      if (((PSCCBcard)pCurrCard)->globalFlags & F_NEW_SCCB_CMD) {
+
+
+         ((PSCCBcard)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
+
+
+         if (((PSCCBcard)pCurrCard)->currentSCCB == NULL) {
+
+            queueSearchSelect(((PSCCBcard)pCurrCard),thisCard);
+            }
+
+         if (((PSCCBcard)pCurrCard)->currentSCCB != NULL) {
+            ((PSCCBcard)pCurrCard)->globalFlags &= ~F_NEW_SCCB_CMD;
+            ssel(ioport,thisCard);
+            }
+
+         break;
+
+         }
+
+      }  /*end while */
+
+   mOS_Lock((PSCCBcard)pCurrCard);
+   MENABLE_INT(ioport);
+   mOS_UnLock((PSCCBcard)pCurrCard);
+
+   return(0);
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Sccb_bad_isr
+ *
+ * Description: Some type of interrupt has occurred which is slightly
+ *              out of the ordinary.  We will now decode it fully, in
+ *              this routine.  This is broken up in an attempt to save
+ *              processing time.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+UCHAR SccbMgr_bad_isr(USHORT p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int)
+#else
+UCHAR SccbMgr_bad_isr(ULONG p_port, UCHAR p_card, PSCCBcard pCurrCard, USHORT p_int)
+#endif
+{
+#if defined(HARP_REVX)
+   ULONG timer;
+#endif
+UCHAR temp, ScamFlg;
+PSCCBMgr_tar_info currTar_Info;
+PNVRamInfo pCurrNvRam;
+
+
+   if (RD_HARPOON(p_port+hp_ext_status) &
+         (BM_FORCE_OFF | PCI_DEV_TMOUT | BM_PARITY_ERR | PIO_OVERRUN) )
+      {
+
+      if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
+         {
+
+         hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
+         }
+
+      if (RD_HARPOON(p_port+hp_pci_stat_cfg) & REC_MASTER_ABORT)
+
+         {
+         WR_HARPOON(p_port+hp_pci_stat_cfg,
+            (RD_HARPOON(p_port+hp_pci_stat_cfg) & ~REC_MASTER_ABORT));
+
+         WR_HARPOON(p_port+hp_host_blk_cnt, 0x00);
+
+         }
+
+      if (pCurrCard->currentSCCB != NULL)
+         {
+
+         if (!pCurrCard->currentSCCB->HostStatus)
+            pCurrCard->currentSCCB->HostStatus = SCCB_BM_ERR;
+
+         sxfrp(p_port,p_card);
+
+	     temp = (UCHAR)(RD_HARPOON(p_port+hp_ee_ctrl) &
+							(EXT_ARB_ACK | SCSI_TERM_ENA_H));
+      	WR_HARPOON(p_port+hp_ee_ctrl, ((UCHAR)temp | SEE_MS | SEE_CS));
+         WR_HARPOON(p_port+hp_ee_ctrl, temp);
+
+         if (!(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
+            {
+            phaseDecode(p_port,p_card);
+            }
+         }
+      }
+
+
+   else if (p_int & RESET)
+         {
+
+				WR_HARPOON(p_port+hp_clkctrl_0, CLKCTRL_DEFAULT);
+				WR_HARPOON(p_port+hp_sys_ctrl, 0x00);
+           if (pCurrCard->currentSCCB != NULL) {
+
+               if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
+
+               hostDataXferAbort(p_port,p_card, pCurrCard->currentSCCB);
+               }
+
+
+           DISABLE_AUTO(p_port);
+
+           sresb(p_port,p_card);
+
+           while(RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST) {}
+
+				pCurrNvRam = pCurrCard->pNvRamInfo;
+				if(pCurrNvRam){
+					ScamFlg = pCurrNvRam->niScamConf;
+				}
+				else{
+				   ScamFlg = (UCHAR) utilEERead(p_port, SCAM_CONFIG/2);
+				}
+
+           XbowInit(p_port, ScamFlg);
+
+               scini(p_card, pCurrCard->ourId, 0);
+
+           return(0xFF);
+         }
+
+
+   else if (p_int & FIFO) {
+
+      WRW_HARPOON((p_port+hp_intstat), FIFO);
+
+#if defined(HARP_REVX)
+
+      for (timer=0x00FFFFFFL; timer != 0x00000000L; timer--) {
+
+         if (RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY)
+            break;
+
+         if (RDW_HARPOON((p_port+hp_intstat)) & BUS_FREE)
+            break;
+         }
+
+
+      if ( (RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY) &&
+           (RD_HARPOON(p_port+hp_fiforead) !=
+            RD_HARPOON(p_port+hp_fifowrite)) &&
+           (RD_HARPOON(p_port+hp_xfercnt_0))
+         )
+
+            WR_HARPOON((p_port+hp_xferstat), 0x01);
+
+/*      else
+ */
+/*         sxfrp(p_port,p_card);
+ */
+#else
+      if (pCurrCard->currentSCCB != NULL)
+         sxfrp(p_port,p_card);
+#endif
+      }
+
+   else if (p_int & TIMEOUT)
+      {
+
+      DISABLE_AUTO(p_port);
+
+      WRW_HARPOON((p_port+hp_intstat),
+		  (PROG_HLT | TIMEOUT | SEL |BUS_FREE | PHASE | IUNKWN));
+
+      pCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;
+
+
+		currTar_Info = &sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
+		if((pCurrCard->globalFlags & F_CONLUN_IO) &&
+			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	      currTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] = FALSE;
+		else
+	      currTar_Info->TarLUNBusy[0] = FALSE;
+
+
+      if (currTar_Info->TarEEValue & EE_SYNC_MASK)
+         {
+	       currTar_Info->TarSyncCtrl = 0;
+         currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+         }
+
+      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
+         {
+         currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+         }
+
+      sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,currTar_Info);
+
+      queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);
+
+      }
+
+#if defined(SCAM_LEV_2)
+
+   else if (p_int & SCAM_SEL)
+      {
+
+      scarb(p_port,LEVEL2_TAR);
+      scsel(p_port);
+      scasid(p_card, p_port);
+
+      scbusf(p_port);
+
+      WRW_HARPOON((p_port+hp_intstat), SCAM_SEL);
+      }
+#endif
+
+   return(0x00);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_scsi_reset
+ *
+ * Description: A SCSI bus reset will be generated and all outstanding
+ *              Sccbs will be returned via the callback.
+ *
+ *---------------------------------------------------------------------*/
+#if (FW_TYPE==_UCB_MGR_)
+void SccbMgr_scsi_reset(CARD_HANDLE pCurrCard)
+#else
+#if defined(DOS)
+void SccbMgr_scsi_reset(USHORT pCurrCard)
+#else
+void SccbMgr_scsi_reset(ULONG pCurrCard)
+#endif
+#endif
+{
+   UCHAR thisCard;
+
+   thisCard = ((PSCCBcard)pCurrCard)->cardIndex;
+
+   mOS_Lock((PSCCBcard)pCurrCard);
+
+   if (((PSCCBcard) pCurrCard)->globalFlags & F_GREEN_PC)
+      {
+      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_clkctrl_0, CLKCTRL_DEFAULT);
+      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_sys_ctrl, 0x00);
+      }
+
+   sresb(((PSCCBcard)pCurrCard)->ioPort,thisCard);
+
+   if (RD_HARPOON(((PSCCBcard)pCurrCard)->ioPort+hp_ext_status) & BM_CMD_BUSY)
+      {
+      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_page_ctrl,
+         (RD_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_page_ctrl)
+         & ~SCATTER_EN));
+
+      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_sg_addr,0x00);
+
+      ((PSCCBcard) pCurrCard)->globalFlags &= ~F_HOST_XFER_ACT;
+      busMstrTimeOut(((PSCCBcard) pCurrCard)->ioPort);
+
+      WR_HARPOON(((PSCCBcard) pCurrCard)->ioPort+hp_int_mask,
+         (INT_CMD_COMPL | SCSI_INTERRUPT));
+      }
+
+/*
+      if (utilEERead(((PSCCBcard)pCurrCard)->ioPort, (SCAM_CONFIG/2))
+            & SCAM_ENABLED)
+*/
+         scini(thisCard, ((PSCCBcard)pCurrCard)->ourId, 0);
+
+#if (FW_TYPE==_UCB_MGR_)
+   ((PSCCBcard)pCurrCard)->cardInfo->ai_AEN_routine(0x01,pCurrCard,0,0,0,0);
+#endif
+
+   mOS_UnLock((PSCCBcard)pCurrCard);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_timer_expired
+ *
+ * Description: This function allow me to kill my own job that has not
+ *              yet completed, and has cause a timeout to occur.  This
+ *              timeout has caused the upper level driver to call this
+ *              function.
+ *
+ *---------------------------------------------------------------------*/
+
+#if (FW_TYPE==_UCB_MGR_)
+void SccbMgr_timer_expired(CARD_HANDLE pCurrCard)
+#else
+#if defined(DOS)
+void SccbMgr_timer_expired(USHORT pCurrCard)
+#else
+void SccbMgr_timer_expired(ULONG pCurrCard)
+#endif
+#endif
+{
+}
+
+#if defined(DOS)
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgr_status
+ *
+ * Description: This function returns the number of outstanding SCCB's.
+ *              This is specific to the DOS enviroment, which needs this
+ *              to help them keep protected and real mode commands staight.
+ *
+ *---------------------------------------------------------------------*/
+
+USHORT SccbMgr_status(USHORT pCurrCard)
+{
+   return(BL_Card[pCurrCard].cmdCounter);
+}
+#endif
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgrTableInit
+ *
+ * Description: Initialize all Sccb manager data structures.
+ *
+ *---------------------------------------------------------------------*/
+
+void SccbMgrTableInitAll()
+{
+   UCHAR thisCard;
+
+   for (thisCard = 0; thisCard < MAX_CARDS; thisCard++)
+      {
+      SccbMgrTableInitCard(&BL_Card[thisCard],thisCard);
+
+      BL_Card[thisCard].ioPort      = 0x00;
+      BL_Card[thisCard].cardInfo    = NULL;
+      BL_Card[thisCard].cardIndex   = 0xFF;
+      BL_Card[thisCard].ourId       = 0x00;
+		BL_Card[thisCard].pNvRamInfo	= NULL;
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgrTableInit
+ *
+ * Description: Initialize all Sccb manager data structures.
+ *
+ *---------------------------------------------------------------------*/
+
+void SccbMgrTableInitCard(PSCCBcard pCurrCard, UCHAR p_card)
+{
+   UCHAR scsiID, qtag;
+
+	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
+	{
+		BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+	}
+
+   for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++)
+      {
+      sccbMgrTbl[p_card][scsiID].TarStatus = 0;
+      sccbMgrTbl[p_card][scsiID].TarEEValue = 0;
+      SccbMgrTableInitTarget(p_card, scsiID);
+      }
+
+   pCurrCard->scanIndex = 0x00;
+   pCurrCard->currentSCCB = NULL;
+   pCurrCard->globalFlags = 0x00;
+   pCurrCard->cmdCounter  = 0x00;
+	pCurrCard->tagQ_Lst = 0x01;
+	pCurrCard->discQCount = 0; 
+
+
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: SccbMgrTableInit
+ *
+ * Description: Initialize all Sccb manager data structures.
+ *
+ *---------------------------------------------------------------------*/
+
+void SccbMgrTableInitTarget(UCHAR p_card, UCHAR target)
+{
+
+	UCHAR lun, qtag;
+	PSCCBMgr_tar_info currTar_Info;
+
+	currTar_Info = &sccbMgrTbl[p_card][target];
+
+	currTar_Info->TarSelQ_Cnt = 0;
+	currTar_Info->TarSyncCtrl = 0;
+
+	currTar_Info->TarSelQ_Head = NULL;
+	currTar_Info->TarSelQ_Tail = NULL;
+	currTar_Info->TarTagQ_Cnt = 0;
+	currTar_Info->TarLUN_CA = FALSE;
+
+
+	for (lun = 0; lun < MAX_LUN; lun++)
+	{
+		currTar_Info->TarLUNBusy[lun] = FALSE;
+		currTar_Info->LunDiscQ_Idx[lun] = 0;
+	}
+
+	for (qtag = 0; qtag < QUEUE_DEPTH; qtag++)
+	{
+		if(BL_Card[p_card].discQ_Tbl[qtag] != NULL)
+		{
+			if(BL_Card[p_card].discQ_Tbl[qtag]->TargID == target)
+			{
+				BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+				BL_Card[p_card].discQCount--;
+			}
+		}
+	}
+}
+
+#if defined(BUGBUG)
+
+/*****************************************************************
+ * Save the current byte in the debug array
+ *****************************************************************/
+
+
+void Debug_Load(UCHAR p_card, UCHAR p_bug_data)
+{
+   debug_int[p_card][debug_index[p_card]] = p_bug_data;
+   debug_index[p_card]++;
+
+   if (debug_index[p_card] == debug_size)
+
+      debug_index[p_card] = 0;
+}
+
+#endif
+#ident "$Id: sccb_dat.c 1.10 1997/02/22 03:16:02 awin Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   sccb_dat.c  $
+ *
+ *   Description:  Functions relating to handling of the SCCB interface 
+ *                 between the device driver and the HARPOON.
+ *
+ *   $Date: 1997/02/22 03:16:02 $
+ *
+ *   $Revision: 1.10 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <harpoon.h>*/
+
+/*
+**  IMPORTANT NOTE!!!
+**
+**  You MUST preassign all data to a valid value or zero.  This is
+**  required due to the MS compiler bug under OS/2 and Solaris Real-Mode
+**  driver environment.
+*/
+
+
+SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] = { { { 0 } } };
+SCCBCARD BL_Card[MAX_CARDS] = { { 0 } };
+SCCBSCAM_INFO scamInfo[MAX_SCSI_TAR] = { { { 0 } } };
+NVRAMINFO nvRamInfo[MAX_MB_CARDS] = { { 0 } };
+
+
+#if defined(OS2)
+void (far *s_PhaseTbl[8]) (ULONG, UCHAR) = { 0 };
+UCHAR temp_id_string[ID_STRING_LENGTH] = { 0 };
+#elif defined(SOLARIS_REAL_MODE) || defined(__STDC__)
+void (*s_PhaseTbl[8]) (ULONG, UCHAR) = { 0 };
+#else
+void (*s_PhaseTbl[8]) ();
+#endif
+
+#if defined(DOS)
+UCHAR first_time = 0;
+#endif
+
+UCHAR mbCards = 0;
+UCHAR scamHAString[] = {0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C', \
+								' ', 'B', 'T', '-', '9', '3', '0', \
+								0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \
+								0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20};
+
+USHORT default_intena = 0;
+
+#if defined(BUGBUG)
+UCHAR    debug_int[MAX_CARDS][debug_size] = { 0 };
+UCHAR    debug_index[MAX_CARDS] = { 0 };
+UCHAR    reserved_1[3] = { 0 };
+#endif
+#ident "$Id: scsi.c 1.23 1997/07/09 21:42:54 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   scsi.c  $
+ *
+ *   Description:  Functions for handling SCSI bus functions such as
+ *                 selection/reselection, sync negotiation, message-in
+ *                 decoding.
+ *
+ *   $Date: 1997/07/09 21:42:54 $
+ *
+ *   $Revision: 1.23 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <scsi2.h>*/
+/*#include <eeprom.h>*/
+/*#include <harpoon.h>*/
+
+
+/*
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+#if defined(BUGBUG)
+void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
+#endif
+*/
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sfetm
+ *
+ * Description: Read in a message byte from the SCSI bus, and check
+ *              for a parity error.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR sfm(USHORT port, PSCCB pCurrSCCB)
+#else
+UCHAR sfm(ULONG port, PSCCB pCurrSCCB)
+#endif
+{
+	UCHAR message;
+	USHORT TimeOutLoop;
+
+	TimeOutLoop = 0;
+	while( (!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
+			(TimeOutLoop++ < 20000) ){}
+
+
+	WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+
+	message = RD_HARPOON(port+hp_scsidata_0);
+
+	WR_HARPOON(port+hp_scsisig, SCSI_ACK + S_MSGI_PH);
+
+
+	if (TimeOutLoop > 20000)
+		message = 0x00;   /* force message byte = 0 if Time Out on Req */
+
+	if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
+		(RD_HARPOON(port+hp_addstat) & SCSI_PAR_ERR))
+	{
+		WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+		WR_HARPOON(port+hp_xferstat, 0);
+		WR_HARPOON(port+hp_fiforead, 0);
+		WR_HARPOON(port+hp_fifowrite, 0);
+		if (pCurrSCCB != NULL)
+		{
+			pCurrSCCB->Sccb_scsimsg = SMPARITY;
+		}
+		message = 0x00;
+		do
+		{
+			ACCEPT_MSG_ATN(port);
+			TimeOutLoop = 0;
+			while( (!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
+				(TimeOutLoop++ < 20000) ){}
+			if (TimeOutLoop > 20000)
+			{
+				WRW_HARPOON((port+hp_intstat), PARITY);
+				return(message);
+			}
+			if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) != S_MSGI_PH)
+			{
+				WRW_HARPOON((port+hp_intstat), PARITY);
+				return(message);
+			}
+			WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+
+			RD_HARPOON(port+hp_scsidata_0);
+
+			WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+
+		}while(1);
+
+	}
+	WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+	WR_HARPOON(port+hp_xferstat, 0);
+	WR_HARPOON(port+hp_fiforead, 0);
+	WR_HARPOON(port+hp_fifowrite, 0);
+	return(message);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: ssel
+ *
+ * Description: Load up automation and select target device.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void ssel(USHORT port, UCHAR p_card)
+#else
+void ssel(ULONG port, UCHAR p_card)
+#endif
+{
+
+#if defined(DOS)
+   UCHAR auto_loaded, i, target, *theCCB;
+#elif defined(OS2)
+   UCHAR auto_loaded, i, target;
+   UCHAR far *theCCB;
+#else
+   UCHAR auto_loaded, i, target, *theCCB;
+#endif
+
+#if defined(DOS)
+   USHORT cdb_reg;
+#else
+   ULONG cdb_reg;
+#endif
+   PSCCBcard CurrCard;
+   PSCCB currSCCB;
+   PSCCBMgr_tar_info currTar_Info;
+   UCHAR lastTag, lun;
+
+   CurrCard = &BL_Card[p_card];
+   currSCCB = CurrCard->currentSCCB;
+   target = currSCCB->TargID;
+   currTar_Info = &sccbMgrTbl[p_card][target];
+   lastTag = CurrCard->tagQ_Lst;
+
+   ARAM_ACCESS(port);
+
+
+	if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)
+		currSCCB->ControlByte &= ~F_USE_CMD_Q;
+
+	if(((CurrCard->globalFlags & F_CONLUN_IO) && 
+		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+
+	   lun = currSCCB->Lun;
+	else
+		lun = 0;
+
+
+#if defined(DOS)
+   currTar_Info->TarLUNBusy[lun] = TRUE;
+
+#else
+
+   if (CurrCard->globalFlags & F_TAG_STARTED)
+      {
+      if (!(currSCCB->ControlByte & F_USE_CMD_Q))
+         {
+      	if ((currTar_Info->TarLUN_CA == FALSE)
+      	    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
+      	    == TAG_Q_TRYING))
+            {
+
+	         if (currTar_Info->TarTagQ_Cnt !=0)
+                  {
+         		   currTar_Info->TarLUNBusy[lun] = TRUE;
+            		queueSelectFail(CurrCard,p_card);
+					   SGRAM_ACCESS(port);
+         		   return;
+         		   }
+
+            else {
+         		  currTar_Info->TarLUNBusy[lun] = TRUE;
+         		  }
+
+   	      }  /*End non-tagged */
+
+	      else {
+	         currTar_Info->TarLUNBusy[lun] = TRUE;
+	         }
+
+	      }  /*!Use cmd Q Tagged */
+
+	   else {
+   	     if (currTar_Info->TarLUN_CA == TRUE)
+               {
+      	      queueSelectFail(CurrCard,p_card);
+				   SGRAM_ACCESS(port);
+      	      return;
+	            }
+
+	        currTar_Info->TarLUNBusy[lun] = TRUE;
+
+   	     }  /*else use cmd Q tagged */
+
+      }  /*if glob tagged started */
+
+   else {
+        currTar_Info->TarLUNBusy[lun] = TRUE;
+        }
+
+#endif /* DOS */
+
+
+
+	if((((CurrCard->globalFlags & F_CONLUN_IO) && 
+		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)) 
+		|| (!(currSCCB->ControlByte & F_USE_CMD_Q))))
+	{
+		if(CurrCard->discQCount >= QUEUE_DEPTH)
+		{
+			currTar_Info->TarLUNBusy[lun] = TRUE;
+			queueSelectFail(CurrCard,p_card);
+			SGRAM_ACCESS(port);
+			return;
+		}
+		for (i = 1; i < QUEUE_DEPTH; i++)
+		{
+			if (++lastTag >= QUEUE_DEPTH) lastTag = 1;
+			if (CurrCard->discQ_Tbl[lastTag] == NULL)
+			{
+				CurrCard->tagQ_Lst = lastTag;
+				currTar_Info->LunDiscQ_Idx[lun] = lastTag;
+				CurrCard->discQ_Tbl[lastTag] = currSCCB;
+				CurrCard->discQCount++;
+				break;
+			}
+		}
+		if(i == QUEUE_DEPTH)
+		{
+			currTar_Info->TarLUNBusy[lun] = TRUE;
+			queueSelectFail(CurrCard,p_card);
+			SGRAM_ACCESS(port);
+			return;
+		}
+	}
+
+
+
+   auto_loaded = FALSE;
+
+   WR_HARPOON(port+hp_select_id, target);
+   WR_HARPOON(port+hp_gp_reg_3, target);  /* Use by new automation logic */
+
+   if (currSCCB->OperationCode == RESET_COMMAND) {
+      WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+
+               	 (currSCCB->Sccb_idmsg & ~DISC_PRIV)));
+
+      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+NP);
+
+      currSCCB->Sccb_scsimsg = SMDEV_RESET;
+
+      WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+      auto_loaded = TRUE;
+      currSCCB->Sccb_scsistat = SELECT_BDR_ST;
+
+      if (currTar_Info->TarEEValue & EE_SYNC_MASK)
+         {
+	       currTar_Info->TarSyncCtrl = 0;
+	      currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+	      }
+
+#if defined(WIDE_SCSI)
+
+      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
+         {
+      	currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+      	}
+#endif
+
+      sssyncv(port, target, NARROW_SCSI,currTar_Info);
+      SccbMgrTableInitTarget(p_card, target);
+
+      }
+
+		else if(currSCCB->Sccb_scsistat == ABORT_ST)
+		{
+			WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+
+								(currSCCB->Sccb_idmsg & ~DISC_PRIV)));
+
+      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
+
+			WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+
+								(((UCHAR)(currSCCB->ControlByte & TAG_TYPE_MASK)
+								>> 6) | (UCHAR)0x20)));
+			WRW_HARPOON((port+SYNC_MSGS+2),
+							(MPM_OP+AMSG_OUT+currSCCB->Sccb_tag));
+			WRW_HARPOON((port+SYNC_MSGS+4), (BRH_OP+ALWAYS+NP ));
+
+			WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+			auto_loaded = TRUE;
+		
+		}
+
+#if defined(WIDE_SCSI)
+
+
+   else if (!(currTar_Info->TarStatus & WIDE_NEGOCIATED))  {
+      auto_loaded = siwidn(port,p_card);
+      currSCCB->Sccb_scsistat = SELECT_WN_ST;
+      }
+
+#endif
+
+
+   else if (!((currTar_Info->TarStatus & TAR_SYNC_MASK)
+      == SYNC_SUPPORTED))  {
+      auto_loaded = sisyncn(port,p_card, FALSE);
+      currSCCB->Sccb_scsistat = SELECT_SN_ST;
+      }
+
+
+   if (!auto_loaded)
+      {
+
+#if !defined(DOS)
+      if (currSCCB->ControlByte & F_USE_CMD_Q)
+         {
+
+         CurrCard->globalFlags |= F_TAG_STARTED;
+
+         if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)
+            == TAG_Q_REJECT)
+            {
+            currSCCB->ControlByte &= ~F_USE_CMD_Q;
+
+            /* Fix up the start instruction with a jump to
+               Non-Tag-CMD handling */
+            WRW_HARPOON((port+ID_MSG_STRT),BRH_OP+ALWAYS+NTCMD);
+
+            WRW_HARPOON((port+NON_TAG_ID_MSG),
+	                     (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
+
+	         WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+
+	         /* Setup our STATE so we know what happend when
+               the wheels fall off. */
+            currSCCB->Sccb_scsistat = SELECT_ST;
+
+	         currTar_Info->TarLUNBusy[lun] = TRUE;
+            }
+
+         else
+            {
+            WRW_HARPOON((port+ID_MSG_STRT), (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
+
+            WRW_HARPOON((port+ID_MSG_STRT+2), (MPM_OP+AMSG_OUT+
+                        (((UCHAR)(currSCCB->ControlByte & TAG_TYPE_MASK)
+                        >> 6) | (UCHAR)0x20)));
+
+				for (i = 1; i < QUEUE_DEPTH; i++)
+				{
+					if (++lastTag >= QUEUE_DEPTH) lastTag = 1;
+					if (CurrCard->discQ_Tbl[lastTag] == NULL)
+					{
+						WRW_HARPOON((port+ID_MSG_STRT+6),
+							(MPM_OP+AMSG_OUT+lastTag));
+						CurrCard->tagQ_Lst = lastTag;
+						currSCCB->Sccb_tag = lastTag;
+						CurrCard->discQ_Tbl[lastTag] = currSCCB;
+						CurrCard->discQCount++;
+						break;
+					}
+				}
+
+
+            if ( i == QUEUE_DEPTH )
+               {
+   	         currTar_Info->TarLUNBusy[lun] = TRUE;
+               queueSelectFail(CurrCard,p_card);
+				   SGRAM_ACCESS(port);
+   	         return;
+   	         }
+
+            currSCCB->Sccb_scsistat = SELECT_Q_ST;
+
+   	      WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+            }
+         }
+
+      else
+         {
+#endif   /* !DOS */
+
+         WRW_HARPOON((port+ID_MSG_STRT),BRH_OP+ALWAYS+NTCMD);
+
+      	WRW_HARPOON((port+NON_TAG_ID_MSG),
+            (MPM_OP+AMSG_OUT+currSCCB->Sccb_idmsg));
+
+         currSCCB->Sccb_scsistat = SELECT_ST;
+
+         WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+#if !defined(DOS)
+         }
+#endif
+
+
+#if defined(OS2)
+      theCCB = (UCHAR far *)&currSCCB->Cdb[0];
+#else
+      theCCB = (UCHAR *)&currSCCB->Cdb[0];
+#endif
+
+      cdb_reg = port + CMD_STRT;
+
+      for (i=0; i < currSCCB->CdbLength; i++)
+         {
+         WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + *theCCB));
+         cdb_reg +=2;
+         theCCB++;
+         }
+
+      if (currSCCB->CdbLength != TWELVE_BYTE_CMD)
+         WRW_HARPOON(cdb_reg, (BRH_OP+ALWAYS+    NP));
+
+      }  /* auto_loaded */
+
+#if defined(WIDE_SCSI)
+   WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
+   WR_HARPOON(port+hp_xferstat, 0x00);
+#endif
+
+   WRW_HARPOON((port+hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));
+
+   WR_HARPOON(port+hp_portctrl_0,(SCSI_PORT));
+
+
+   if (!(currSCCB->Sccb_MGRFlags & F_DEV_SELECTED))
+      {
+      WR_HARPOON(port+hp_scsictrl_0, (SEL_TAR | ENA_ATN | ENA_RESEL | ENA_SCAM_SEL));
+      }
+   else
+      {
+
+/*      auto_loaded =  (RD_HARPOON(port+hp_autostart_3) & (UCHAR)0x1F);
+      auto_loaded |= AUTO_IMMED; */
+      auto_loaded = AUTO_IMMED;
+
+      DISABLE_AUTO(port);
+
+      WR_HARPOON(port+hp_autostart_3, auto_loaded);
+      }
+
+   SGRAM_ACCESS(port);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sres
+ *
+ * Description: Hookup the correct CCB and handle the incoming messages.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void sres(USHORT port, UCHAR p_card, PSCCBcard pCurrCard)
+#else
+void sres(ULONG port, UCHAR p_card, PSCCBcard pCurrCard)
+#endif
+{
+
+#if defined(V302)
+#ifdef DOS
+   UCHAR our_target,message, msgRetryCount;
+   extern UCHAR lun, tag;
+#else
+   UCHAR our_target,message,lun,tag, msgRetryCount;
+#endif
+
+#else  /* V302 */
+   UCHAR our_target, message, lun = 0, tag, msgRetryCount;
+#endif /* V302 */
+
+
+   PSCCBMgr_tar_info currTar_Info;
+	PSCCB currSCCB;
+
+
+
+
+	if(pCurrCard->currentSCCB != NULL)
+	{
+		currTar_Info = &sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
+		DISABLE_AUTO(port);
+
+
+		WR_HARPOON((port+hp_scsictrl_0),(ENA_RESEL | ENA_SCAM_SEL));
+
+
+		currSCCB = pCurrCard->currentSCCB;
+		if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
+		{
+			currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+			currSCCB->Sccb_scsistat = BUS_FREE_ST;
+		}
+		if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
+		{
+			currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+			currSCCB->Sccb_scsistat = BUS_FREE_ST;
+		}
+		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
+			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+		{
+      	currTar_Info->TarLUNBusy[currSCCB->Lun] = FALSE;
+			if(currSCCB->Sccb_scsistat != ABORT_ST)
+			{
+				pCurrCard->discQCount--;
+				pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[currSCCB->Lun]] 
+													= NULL;
+			}
+		}
+		else
+		{
+	      currTar_Info->TarLUNBusy[0] = FALSE;
+			if(currSCCB->Sccb_tag)
+			{
+				if(currSCCB->Sccb_scsistat != ABORT_ST)
+				{
+					pCurrCard->discQCount--;
+					pCurrCard->discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+				}
+			}else
+			{
+				if(currSCCB->Sccb_scsistat != ABORT_ST)
+				{
+					pCurrCard->discQCount--;
+					pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = NULL;
+				}
+			}
+		}
+
+      queueSelectFail(&BL_Card[p_card],p_card);
+	}
+
+#if defined(WIDE_SCSI)
+	WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
+#endif
+
+
+	our_target = (UCHAR)(RD_HARPOON(port+hp_select_id) >> 4);
+	currTar_Info = &sccbMgrTbl[p_card][our_target];
+
+
+	msgRetryCount = 0;
+	do
+	{
+
+#if defined(V302)
+
+		message = GetTarLun(port, p_card, our_target, pCurrCard, &tag, &lun);
+
+#else /* V302 */
+
+		currTar_Info = &sccbMgrTbl[p_card][our_target];
+		tag = 0;
+
+
+		while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
+		{
+			if (! (RD_HARPOON(port+hp_scsisig) & SCSI_BSY))
+			{
+
+				WRW_HARPOON((port+hp_intstat), PHASE);
+				return;
+			}
+		}
+
+		WRW_HARPOON((port+hp_intstat), PHASE);
+		if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH)
+		{
+
+			message = sfm(port,pCurrCard->currentSCCB);
+			if (message)
+			{
+
+				if (message <= (0x80 | LUN_MASK))
+				{
+					lun = message & (UCHAR)LUN_MASK;
+
+#if !defined(DOS)
+					if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING)
+					{
+						if (currTar_Info->TarTagQ_Cnt != 0)
+						{
+
+							if (!(currTar_Info->TarLUN_CA))
+							{
+								ACCEPT_MSG(port);    /*Release the ACK for ID msg. */
+
+
+								message = sfm(port,pCurrCard->currentSCCB);
+								if (message)
+								{
+									ACCEPT_MSG(port);
+								}
+
+								else
+   								message = FALSE;
+
+								if(message != FALSE)
+								{
+									tag = sfm(port,pCurrCard->currentSCCB);
+
+									if (!(tag)) 
+										message = FALSE;
+								}
+
+							} /*C.A. exists! */
+
+						} /*End Q cnt != 0 */
+
+					} /*End Tag cmds supported! */
+#endif /* !DOS */
+
+				} /*End valid ID message.  */
+
+				else
+				{
+
+					ACCEPT_MSG_ATN(port);
+				}
+
+			} /* End good id message. */
+
+			else
+			{
+
+				message = FALSE;
+			}
+		}
+		else
+		{
+			ACCEPT_MSG_ATN(port);
+
+		   while (!(RDW_HARPOON((port+hp_intstat)) & (PHASE | RESET)) &&
+			  !(RD_HARPOON(port+hp_scsisig) & SCSI_REQ) &&
+			  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
+
+			return;
+		}
+	
+#endif /* V302 */
+
+		if(message == FALSE)
+		{
+			msgRetryCount++;
+			if(msgRetryCount == 1)
+			{
+				SendMsg(port, SMPARITY);
+			}
+			else
+			{
+				SendMsg(port, SMDEV_RESET);
+
+				sssyncv(port, our_target, NARROW_SCSI,currTar_Info);
+
+				if (sccbMgrTbl[p_card][our_target].TarEEValue & EE_SYNC_MASK) 
+				{
+			
+					sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_SYNC_MASK;
+
+				}
+
+				if (sccbMgrTbl[p_card][our_target].TarEEValue & EE_WIDE_SCSI) 
+				{
+
+					sccbMgrTbl[p_card][our_target].TarStatus &= ~TAR_WIDE_MASK;
+				}
+
+
+				queueFlushTargSccb(p_card, our_target, SCCB_COMPLETE);
+				SccbMgrTableInitTarget(p_card,our_target);
+				return;
+			}
+		}
+	}while(message == FALSE);
+
+
+
+	if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
+		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+	{
+		currTar_Info->TarLUNBusy[lun] = TRUE;
+		pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];
+		if(pCurrCard->currentSCCB != NULL)
+		{
+			ACCEPT_MSG(port);
+		}
+		else 
+		{
+			ACCEPT_MSG_ATN(port);
+		}
+	}
+	else
+	{
+		currTar_Info->TarLUNBusy[0] = TRUE;
+
+
+		if (tag)
+		{
+			if (pCurrCard->discQ_Tbl[tag] != NULL)
+			{
+				pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[tag];
+		 		currTar_Info->TarTagQ_Cnt--;
+				ACCEPT_MSG(port);
+			}
+			else
+			{
+			ACCEPT_MSG_ATN(port);
+			}
+		}else
+		{
+			pCurrCard->currentSCCB = pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]];
+			if(pCurrCard->currentSCCB != NULL)
+			{
+				ACCEPT_MSG(port);
+			}
+			else 
+			{
+				ACCEPT_MSG_ATN(port);
+			}
+		}
+	}
+
+	if(pCurrCard->currentSCCB != NULL)
+	{
+		if(pCurrCard->currentSCCB->Sccb_scsistat == ABORT_ST)
+		{
+		/* During Abort Tag command, the target could have got re-selected
+			and completed the command. Check the select Q and remove the CCB
+			if it is in the Select Q */
+			queueFindSccb(pCurrCard->currentSCCB, p_card);
+		}
+	}
+
+
+   while (!(RDW_HARPOON((port+hp_intstat)) & (PHASE | RESET)) &&
+	  !(RD_HARPOON(port+hp_scsisig) & SCSI_REQ) &&
+	  (RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ;
+}
+
+#if defined(V302)
+
+#if defined(DOS)
+UCHAR GetTarLun(USHORT port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tag, PUCHAR lun)
+#else
+UCHAR GetTarLun(ULONG port, UCHAR p_card, UCHAR our_target, PSCCBcard pCurrCard, PUCHAR tag, PUCHAR lun)
+#endif
+{
+   UCHAR message;
+   PSCCBMgr_tar_info currTar_Info;
+
+
+	currTar_Info = &sccbMgrTbl[p_card][our_target];
+	*tag = 0;
+
+
+	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
+	{
+		if (! (RD_HARPOON(port+hp_scsisig) & SCSI_BSY))
+		{
+
+			WRW_HARPOON((port+hp_intstat), PHASE);
+			return(TRUE);
+		}
+	}
+
+	WRW_HARPOON((port+hp_intstat), PHASE);
+	if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH)
+	{
+
+		message = sfm(port,pCurrCard->currentSCCB);
+		if (message)
+		{
+
+			if (message <= (0x80 | LUN_MASK))
+			{
+				*lun = message & (UCHAR)LUN_MASK;
+
+#if !defined(DOS)
+				if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING)
+				{
+					if (currTar_Info->TarTagQ_Cnt != 0)
+					{
+
+						if (!(currTar_Info->TarLUN_CA))
+						{
+							ACCEPT_MSG(port);    /*Release the ACK for ID msg. */
+
+
+							message = sfm(port,pCurrCard->currentSCCB);
+							if (message)
+							{
+								ACCEPT_MSG(port);
+							}
+
+							else
+   							return(FALSE);
+
+							*tag = sfm(port,pCurrCard->currentSCCB);
+
+							if (!(*tag)) return(FALSE);
+
+						} /*C.A. exists! */
+
+					} /*End Q cnt != 0 */
+
+				} /*End Tag cmds supported! */
+#endif /* !DOS */
+
+			} /*End valid ID message.  */
+
+			else
+			{
+
+				ACCEPT_MSG_ATN(port);
+			}
+
+		} /* End good id message. */
+
+		else
+		{
+
+			return(FALSE);
+		}
+	}
+	else
+	{
+		ACCEPT_MSG_ATN(port);
+		return(TRUE);
+	}
+	return(TRUE);
+}
+
+#endif /* V302 */
+
+#if defined(DOS)
+void SendMsg(USHORT port, UCHAR message)
+#else
+void SendMsg(ULONG port, UCHAR message)
+#endif
+{
+	while(!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ))
+	{
+		if (! (RD_HARPOON(port+hp_scsisig) & SCSI_BSY))
+		{
+
+			WRW_HARPOON((port+hp_intstat), PHASE);
+			return;
+		}
+	}
+
+	WRW_HARPOON((port+hp_intstat), PHASE);
+	if ((RD_HARPOON(port+hp_scsisig) & S_SCSI_PHZ) == S_MSGO_PH)
+	{
+		WRW_HARPOON((port+hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));
+
+
+		WR_HARPOON(port+hp_portctrl_0, SCSI_BUS_EN);
+
+		WR_HARPOON(port+hp_scsidata_0,message);
+
+		WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+
+		ACCEPT_MSG(port);
+
+		WR_HARPOON(port+hp_portctrl_0, 0x00);
+
+		if ((message == SMABORT) || (message == SMDEV_RESET) ||
+				(message == SMABORT_TAG) )
+		{
+			while(!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | PHASE))) {}
+
+			if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE)
+			{
+			WRW_HARPOON((port+hp_intstat), BUS_FREE);
+			}
+		}
+	}
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sdecm
+ *
+ * Description: Determine the proper responce to the message from the
+ *              target device.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void sdecm(UCHAR message, USHORT port, UCHAR p_card)
+#else
+void sdecm(UCHAR message, ULONG port, UCHAR p_card)
+#endif
+{
+	PSCCB currSCCB;
+	PSCCBcard CurrCard;
+	PSCCBMgr_tar_info currTar_Info;
+
+	CurrCard = &BL_Card[p_card];
+	currSCCB = CurrCard->currentSCCB;
+
+	currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+
+	if (message == SMREST_DATA_PTR)
+	{
+		if (!(currSCCB->Sccb_XferState & F_NO_DATA_YET))
+		{
+			currSCCB->Sccb_ATC = currSCCB->Sccb_savedATC;
+
+			hostDataXferRestart(currSCCB);
+		}
+
+		ACCEPT_MSG(port);
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	}
+
+	else if (message == SMCMD_COMP)
+	{
+
+
+		if (currSCCB->Sccb_scsistat == SELECT_Q_ST)
+		{
+			currTar_Info->TarStatus &= ~(UCHAR)TAR_TAG_Q_MASK;
+			currTar_Info->TarStatus |= (UCHAR)TAG_Q_REJECT;
+		}
+
+		ACCEPT_MSG(port);
+
+	}
+
+	else if ((message == SMNO_OP) || (message >= SMIDENT) 
+			|| (message == SMINIT_RECOVERY) || (message == SMREL_RECOVERY))
+	{
+
+		ACCEPT_MSG(port);
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	}
+
+	else if (message == SMREJECT)
+	{
+
+		if ((currSCCB->Sccb_scsistat == SELECT_SN_ST) ||
+				(currSCCB->Sccb_scsistat == SELECT_WN_ST) ||
+				((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING ) ||
+				((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING ) )
+
+		{
+			WRW_HARPOON((port+hp_intstat), BUS_FREE);
+
+			ACCEPT_MSG(port);
+
+
+			while ((!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
+				(!(RDW_HARPOON((port+hp_intstat)) & BUS_FREE))) {}
+
+			if(currSCCB->Lun == 0x00)
+			{
+				if ((currSCCB->Sccb_scsistat == SELECT_SN_ST))
+				{
+
+					currTar_Info->TarStatus |= (UCHAR)SYNC_SUPPORTED;
+
+					currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
+				}
+
+#if defined(WIDE_SCSI)
+				else if ((currSCCB->Sccb_scsistat == SELECT_WN_ST))
+				{
+
+
+					currTar_Info->TarStatus = (currTar_Info->TarStatus &
+													~WIDE_ENABLED) | WIDE_NEGOCIATED;
+
+					currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
+
+				}
+#endif
+
+				else if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_TRYING )
+				{
+					currTar_Info->TarStatus = (currTar_Info->TarStatus &
+													~(UCHAR)TAR_TAG_Q_MASK) | TAG_Q_REJECT;
+
+
+					currSCCB->ControlByte &= ~F_USE_CMD_Q;
+					CurrCard->discQCount--;
+					CurrCard->discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+					currSCCB->Sccb_tag = 0x00;
+
+				}
+			}
+
+			if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE)
+			{
+
+
+				if(currSCCB->Lun == 0x00)
+				{
+					WRW_HARPOON((port+hp_intstat), BUS_FREE);
+					CurrCard->globalFlags |= F_NEW_SCCB_CMD;
+				}
+			}
+
+			else 
+			{
+
+				if((CurrCard->globalFlags & F_CONLUN_IO) &&
+					((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+					currTar_Info->TarLUNBusy[currSCCB->Lun] = TRUE;
+				else
+					currTar_Info->TarLUNBusy[0] = TRUE;
+
+
+				currSCCB->ControlByte &= ~(UCHAR)F_USE_CMD_Q;
+
+				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+
+			}
+		}
+
+		else
+		{
+			ACCEPT_MSG(port);
+
+			while ((!(RD_HARPOON(port+hp_scsisig) & SCSI_REQ)) &&
+				(!(RDW_HARPOON((port+hp_intstat)) & BUS_FREE))) {}
+	
+			if (!(RDW_HARPOON((port+hp_intstat)) & BUS_FREE))
+			{
+				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+			}
+		}
+	}
+
+	else if (message == SMEXT)
+	{
+
+		ACCEPT_MSG(port);
+		shandem(port,p_card,currSCCB);
+	}
+
+	else if (message == SMIGNORWR)
+	{
+
+		ACCEPT_MSG(port);          /* ACK the RESIDUE MSG */
+
+		message = sfm(port,currSCCB);
+
+		if(currSCCB->Sccb_scsimsg != SMPARITY)
+			ACCEPT_MSG(port);
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	}
+
+
+	else
+	{
+
+		currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+		currSCCB->Sccb_scsimsg = SMREJECT;
+
+		ACCEPT_MSG_ATN(port);
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	}
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: shandem
+ *
+ * Description: Decide what to do with the extended message.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void shandem(USHORT port, UCHAR p_card, PSCCB pCurrSCCB)
+#else
+void shandem(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
+#endif
+{
+	UCHAR length,message;
+
+	length = sfm(port,pCurrSCCB);
+	if (length) 
+	{
+
+		ACCEPT_MSG(port);
+		message = sfm(port,pCurrSCCB);
+		if (message) 
+		{
+
+			if (message == SMSYNC) 
+			{
+
+				if (length == 0x03)
+				{
+
+					ACCEPT_MSG(port);
+					stsyncn(port,p_card);
+				}
+				else 
+				{
+
+					pCurrSCCB->Sccb_scsimsg = SMREJECT;
+					ACCEPT_MSG_ATN(port);
+				}
+			}
+#if defined(WIDE_SCSI)
+			else if (message == SMWDTR) 
+			{
+
+				if (length == 0x02)
+				{
+
+					ACCEPT_MSG(port);
+					stwidn(port,p_card);
+				}
+				else 
+				{
+
+					pCurrSCCB->Sccb_scsimsg = SMREJECT;
+					ACCEPT_MSG_ATN(port);
+
+					WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+				}
+			}
+#endif
+			else 
+			{
+
+				pCurrSCCB->Sccb_scsimsg = SMREJECT;
+				ACCEPT_MSG_ATN(port);
+
+				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+			}
+		}
+		else
+		{
+			if(pCurrSCCB->Sccb_scsimsg != SMPARITY)
+				ACCEPT_MSG(port);
+			WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		}
+	}else
+	{
+			if(pCurrSCCB->Sccb_scsimsg == SMPARITY)
+				WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+	}
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sisyncn
+ *
+ * Description: Read in a message byte from the SCSI bus, and check
+ *              for a parity error.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR sisyncn(USHORT port, UCHAR p_card, UCHAR syncFlag)
+#else
+UCHAR sisyncn(ULONG port, UCHAR p_card, UCHAR syncFlag)
+#endif
+{
+   PSCCB currSCCB;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+
+   if (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)) {
+
+
+      WRW_HARPOON((port+ID_MSG_STRT),
+                 (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(UCHAR)DISC_PRIV)));
+
+      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
+
+      WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
+      WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x03  ));
+      WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMSYNC));
+
+
+      if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)
+
+	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 12));
+
+      else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)
+
+	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 25));
+
+      else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)
+
+	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 50));
+
+      else
+	 WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+ 00));
+
+
+      WRW_HARPOON((port+SYNC_MSGS+8), (RAT_OP                ));
+      WRW_HARPOON((port+SYNC_MSGS+10),(MPM_OP+AMSG_OUT+DEFAULT_OFFSET));
+      WRW_HARPOON((port+SYNC_MSGS+12),(BRH_OP+ALWAYS+NP      ));
+
+
+		if(syncFlag == FALSE)
+		{
+		   WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+	      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+   	      ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_TRYING);
+		}
+		else
+		{
+		   WR_HARPOON(port+hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));
+		}
+
+
+      return(TRUE);
+      }
+
+   else {
+
+      currTar_Info->TarStatus |=	 (UCHAR)SYNC_SUPPORTED;
+      currTar_Info->TarEEValue &= ~EE_SYNC_MASK;
+      return(FALSE);
+      }
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: stsyncn
+ *
+ * Description: The has sent us a Sync Nego message so handle it as
+ *              necessary.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void stsyncn(USHORT port, UCHAR p_card)
+#else
+void stsyncn(ULONG port, UCHAR p_card)
+#endif
+{
+   UCHAR sync_msg,offset,sync_reg,our_sync_msg;
+   PSCCB currSCCB;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+
+   sync_msg = sfm(port,currSCCB);
+
+	if((sync_msg == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
+	{
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		return;
+	}
+
+   ACCEPT_MSG(port);
+
+
+   offset = sfm(port,currSCCB);
+
+	if((offset == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
+	{
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		return;
+	}
+
+   if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)
+
+      our_sync_msg = 12;              /* Setup our Message to 20mb/s */
+
+   else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)
+
+      our_sync_msg = 25;              /* Setup our Message to 10mb/s */
+
+   else if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)
+
+      our_sync_msg = 50;              /* Setup our Message to 5mb/s */
+   else
+
+      our_sync_msg = 0;               /* Message = Async */
+
+   if (sync_msg < our_sync_msg) {
+      sync_msg = our_sync_msg;    /*if faster, then set to max. */
+      }
+
+   if (offset == ASYNC)
+      sync_msg = ASYNC;
+
+   if (offset > MAX_OFFSET)
+      offset = MAX_OFFSET;
+
+   sync_reg = 0x00;
+
+   if (sync_msg > 12)
+
+      sync_reg = 0x20;        /* Use 10MB/s */
+
+   if (sync_msg > 25)
+
+      sync_reg = 0x40;        /* Use 6.6MB/s */
+
+   if (sync_msg > 38)
+
+      sync_reg = 0x60;        /* Use 5MB/s */
+
+   if (sync_msg > 50)
+
+      sync_reg = 0x80;        /* Use 4MB/s */
+
+   if (sync_msg > 62)
+
+      sync_reg = 0xA0;        /* Use 3.33MB/s */
+
+   if (sync_msg > 75)
+
+      sync_reg = 0xC0;        /* Use 2.85MB/s */
+
+   if (sync_msg > 87)
+
+      sync_reg = 0xE0;        /* Use 2.5MB/s */
+
+   if (sync_msg > 100) {
+
+      sync_reg = 0x00;        /* Use ASYNC */
+      offset = 0x00;
+      }
+
+
+#if defined(WIDE_SCSI)
+   if (currTar_Info->TarStatus & WIDE_ENABLED)
+
+      sync_reg |= offset;
+
+   else
+
+      sync_reg |= (offset | NARROW_SCSI);
+
+#else
+   sync_reg |= (offset | NARROW_SCSI);
+#endif
+
+   sssyncv(port,currSCCB->TargID,sync_reg,currTar_Info);
+
+
+   if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {
+
+
+      ACCEPT_MSG(port);
+
+      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+         ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_SUPPORTED);
+
+      WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+      }
+
+   else {
+
+
+      ACCEPT_MSG_ATN(port);
+
+      sisyncr(port,sync_msg,offset);
+
+      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+         ~(UCHAR)TAR_SYNC_MASK) | (UCHAR)SYNC_SUPPORTED);
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sisyncr
+ *
+ * Description: Answer the targets sync message.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void sisyncr(USHORT port,UCHAR sync_pulse, UCHAR offset)
+#else
+void sisyncr(ULONG port,UCHAR sync_pulse, UCHAR offset)
+#endif
+{
+   ARAM_ACCESS(port);
+   WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
+   WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x03  ));
+   WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMSYNC));
+   WRW_HARPOON((port+SYNC_MSGS+6), (MPM_OP+AMSG_OUT+sync_pulse));
+   WRW_HARPOON((port+SYNC_MSGS+8), (RAT_OP                ));
+   WRW_HARPOON((port+SYNC_MSGS+10),(MPM_OP+AMSG_OUT+offset));
+   WRW_HARPOON((port+SYNC_MSGS+12),(BRH_OP+ALWAYS+NP      ));
+   SGRAM_ACCESS(port);
+
+   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT_1);
+
+   WR_HARPOON(port+hp_autostart_3, (AUTO_IMMED+CMD_ONLY_STRT));
+
+   while (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | AUTO_INT))) {}
+}
+
+
+
+#if defined(WIDE_SCSI)
+
+/*---------------------------------------------------------------------
+ *
+ * Function: siwidn
+ *
+ * Description: Read in a message byte from the SCSI bus, and check
+ *              for a parity error.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR siwidn(USHORT port, UCHAR p_card)
+#else
+UCHAR siwidn(ULONG port, UCHAR p_card)
+#endif
+{
+   PSCCB currSCCB;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+
+   if (!((currTar_Info->TarStatus & TAR_WIDE_MASK) == WIDE_NEGOCIATED)) {
+
+
+      WRW_HARPOON((port+ID_MSG_STRT),
+	              (MPM_OP+AMSG_OUT+(currSCCB->Sccb_idmsg & ~(UCHAR)DISC_PRIV)));
+
+      WRW_HARPOON((port+ID_MSG_STRT+2),BRH_OP+ALWAYS+CMDPZ);
+
+      WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
+      WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x02  ));
+      WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMWDTR));
+      WRW_HARPOON((port+SYNC_MSGS+6), (RAT_OP                ));
+      WRW_HARPOON((port+SYNC_MSGS+8), (MPM_OP+AMSG_OUT+ SM16BIT));
+      WRW_HARPOON((port+SYNC_MSGS+10),(BRH_OP+ALWAYS+NP      ));
+
+      WR_HARPOON(port+hp_autostart_3, (SELECT+SELCHK_STRT));
+
+
+      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+         ~(UCHAR)TAR_WIDE_MASK) | (UCHAR)WIDE_ENABLED);
+
+      return(TRUE);
+      }
+
+   else {
+
+      currTar_Info->TarStatus = ((currTar_Info->TarStatus &
+               ~(UCHAR)TAR_WIDE_MASK) | WIDE_NEGOCIATED);
+
+      currTar_Info->TarEEValue &= ~EE_WIDE_SCSI;
+      return(FALSE);
+      }
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: stwidn
+ *
+ * Description: The has sent us a Wide Nego message so handle it as
+ *              necessary.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void stwidn(USHORT port, UCHAR p_card)
+#else
+void stwidn(ULONG port, UCHAR p_card)
+#endif
+{
+   UCHAR width;
+   PSCCB currSCCB;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+   currTar_Info = &sccbMgrTbl[p_card][currSCCB->TargID];
+
+   width = sfm(port,currSCCB);
+
+	if((width == 0x00) && (currSCCB->Sccb_scsimsg == SMPARITY))
+	{
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		return;
+	}
+
+
+   if (!(currTar_Info->TarEEValue & EE_WIDE_SCSI))
+      width = 0;
+
+   if (width) {
+      currTar_Info->TarStatus |= WIDE_ENABLED;
+      width = 0;
+      }
+   else {
+      width = NARROW_SCSI;
+      currTar_Info->TarStatus &= ~WIDE_ENABLED;
+      }
+
+
+   sssyncv(port,currSCCB->TargID,width,currTar_Info);
+
+
+   if (currSCCB->Sccb_scsistat == SELECT_WN_ST)
+	{
+
+
+
+      currTar_Info->TarStatus |=	 WIDE_NEGOCIATED;
+
+	   if (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_SUPPORTED))
+		{
+	      ACCEPT_MSG_ATN(port);
+		   ARAM_ACCESS(port);
+	     	sisyncn(port,p_card, TRUE);
+	      currSCCB->Sccb_scsistat = SELECT_SN_ST;
+		   SGRAM_ACCESS(port);
+		}
+		else
+		{
+	      ACCEPT_MSG(port);
+  		   WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		}
+   }
+
+   else {
+
+
+      ACCEPT_MSG_ATN(port);
+
+      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
+      	 width = SM16BIT;
+      else
+      	 width = SM8BIT;
+
+      siwidr(port,width);
+
+      currTar_Info->TarStatus |= (WIDE_NEGOCIATED | WIDE_ENABLED);
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: siwidr
+ *
+ * Description: Answer the targets Wide nego message.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void siwidr(USHORT port, UCHAR width)
+#else
+void siwidr(ULONG port, UCHAR width)
+#endif
+{
+   ARAM_ACCESS(port);
+   WRW_HARPOON((port+SYNC_MSGS+0), (MPM_OP+AMSG_OUT+SMEXT ));
+   WRW_HARPOON((port+SYNC_MSGS+2), (MPM_OP+AMSG_OUT+0x02  ));
+   WRW_HARPOON((port+SYNC_MSGS+4), (MPM_OP+AMSG_OUT+SMWDTR));
+   WRW_HARPOON((port+SYNC_MSGS+6), (RAT_OP                ));
+   WRW_HARPOON((port+SYNC_MSGS+8),(MPM_OP+AMSG_OUT+width));
+   WRW_HARPOON((port+SYNC_MSGS+10),(BRH_OP+ALWAYS+NP      ));
+   SGRAM_ACCESS(port);
+
+   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT_1);
+
+   WR_HARPOON(port+hp_autostart_3, (AUTO_IMMED+CMD_ONLY_STRT));
+
+   while (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | AUTO_INT))) {}
+}
+
+#endif
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sssyncv
+ *
+ * Description: Write the desired value to the Sync Register for the
+ *              ID specified.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void sssyncv(USHORT p_port, UCHAR p_id, UCHAR p_sync_value,PSCCBMgr_tar_info currTar_Info)
+#else
+void sssyncv(ULONG p_port, UCHAR p_id, UCHAR p_sync_value,PSCCBMgr_tar_info currTar_Info)
+#endif
+{
+   UCHAR index;
+
+   index = p_id;
+
+   switch (index) {
+
+      case 0:
+	 index = 12;             /* hp_synctarg_0 */
+	 break;
+      case 1:
+	 index = 13;             /* hp_synctarg_1 */
+	 break;
+      case 2:
+	 index = 14;             /* hp_synctarg_2 */
+	 break;
+      case 3:
+	 index = 15;             /* hp_synctarg_3 */
+	 break;
+      case 4:
+	 index = 8;              /* hp_synctarg_4 */
+	 break;
+      case 5:
+	 index = 9;              /* hp_synctarg_5 */
+	 break;
+      case 6:
+	 index = 10;             /* hp_synctarg_6 */
+	 break;
+      case 7:
+	 index = 11;             /* hp_synctarg_7 */
+	 break;
+      case 8:
+	 index = 4;              /* hp_synctarg_8 */
+	 break;
+      case 9:
+	 index = 5;              /* hp_synctarg_9 */
+	 break;
+      case 10:
+	 index = 6;              /* hp_synctarg_10 */
+	 break;
+      case 11:
+	 index = 7;              /* hp_synctarg_11 */
+	 break;
+      case 12:
+	 index = 0;              /* hp_synctarg_12 */
+	 break;
+      case 13:
+	 index = 1;              /* hp_synctarg_13 */
+	 break;
+      case 14:
+	 index = 2;              /* hp_synctarg_14 */
+	 break;
+      case 15:
+	 index = 3;              /* hp_synctarg_15 */
+
+      }
+
+   WR_HARPOON(p_port+hp_synctarg_base+index, p_sync_value);
+
+	currTar_Info->TarSyncCtrl = p_sync_value;
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sresb
+ *
+ * Description: Reset the desired card's SCSI bus.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void sresb(USHORT port, UCHAR p_card)
+#else
+void sresb(ULONG port, UCHAR p_card)
+#endif
+{
+   UCHAR scsiID, i;
+
+   PSCCBMgr_tar_info currTar_Info;
+
+   WR_HARPOON(port+hp_page_ctrl,
+      (RD_HARPOON(port+hp_page_ctrl) | G_INT_DISABLE));
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+
+   WR_HARPOON(port+hp_scsictrl_0, SCSI_RST);
+
+   scsiID = RD_HARPOON(port+hp_seltimeout);
+   WR_HARPOON(port+hp_seltimeout,TO_5ms);
+   WRW_HARPOON((port+hp_intstat), TIMEOUT);
+
+   WR_HARPOON(port+hp_portctrl_0,(SCSI_PORT | START_TO));
+
+   while (!(RDW_HARPOON((port+hp_intstat)) & TIMEOUT)) {}
+
+   WR_HARPOON(port+hp_seltimeout,scsiID);
+
+   WR_HARPOON(port+hp_scsictrl_0, ENA_SCAM_SEL);
+
+   Wait(port, TO_5ms);
+
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+
+   WR_HARPOON(port+hp_int_mask, (RD_HARPOON(port+hp_int_mask) | 0x00));
+
+   for (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++)
+      {
+      currTar_Info = &sccbMgrTbl[p_card][scsiID];
+
+      if (currTar_Info->TarEEValue & EE_SYNC_MASK)
+         {
+	      	currTar_Info->TarSyncCtrl = 0;
+	      	currTar_Info->TarStatus &= ~TAR_SYNC_MASK;
+	      }
+
+      if (currTar_Info->TarEEValue & EE_WIDE_SCSI)
+         {
+      	currTar_Info->TarStatus &= ~TAR_WIDE_MASK;
+      	}
+
+      sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
+
+      SccbMgrTableInitTarget(p_card, scsiID);
+      }
+
+   BL_Card[p_card].scanIndex = 0x00;
+   BL_Card[p_card].currentSCCB = NULL;
+   BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT 
+													| F_NEW_SCCB_CMD);
+   BL_Card[p_card].cmdCounter  = 0x00;
+	BL_Card[p_card].discQCount = 0x00;
+   BL_Card[p_card].tagQ_Lst = 0x01; 
+
+	for(i = 0; i < QUEUE_DEPTH; i++)
+		BL_Card[p_card].discQ_Tbl[i] = NULL;
+
+   WR_HARPOON(port+hp_page_ctrl,
+      (RD_HARPOON(port+hp_page_ctrl) & ~G_INT_DISABLE));
+
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: ssenss
+ *
+ * Description: Setup for the Auto Sense command.
+ *
+ *---------------------------------------------------------------------*/
+void ssenss(PSCCBcard pCurrCard)
+{
+   UCHAR i;
+   PSCCB currSCCB;
+
+   currSCCB = pCurrCard->currentSCCB;
+
+
+   currSCCB->Save_CdbLen = currSCCB->CdbLength;
+
+   for (i = 0; i < 6; i++) {
+
+      currSCCB->Save_Cdb[i] = currSCCB->Cdb[i];
+      }
+
+   currSCCB->CdbLength = SIX_BYTE_CMD;
+   currSCCB->Cdb[0]    = SCSI_REQUEST_SENSE;
+   currSCCB->Cdb[1]    = currSCCB->Cdb[1] & (UCHAR)0xE0; /*Keep LUN. */
+   currSCCB->Cdb[2]    = 0x00;
+   currSCCB->Cdb[3]    = 0x00;
+   currSCCB->Cdb[4]    = currSCCB->RequestSenseLength;
+   currSCCB->Cdb[5]    = 0x00;
+
+   currSCCB->Sccb_XferCnt = (unsigned long)currSCCB->RequestSenseLength;
+
+   currSCCB->Sccb_ATC = 0x00;
+
+   currSCCB->Sccb_XferState |= F_AUTO_SENSE;
+
+   currSCCB->Sccb_XferState &= ~F_SG_XFER;
+
+   currSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(UCHAR)DISC_PRIV;
+
+   currSCCB->ControlByte = 0x00;
+
+   currSCCB->Sccb_MGRFlags &= F_STATUSLOADED;
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sxfrp
+ *
+ * Description: Transfer data into the bit bucket until the device
+ *              decides to switch phase.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void sxfrp(USHORT p_port, UCHAR p_card)
+#else
+void sxfrp(ULONG p_port, UCHAR p_card)
+#endif
+{
+   UCHAR curr_phz;
+
+
+   DISABLE_AUTO(p_port);
+
+   if (BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {
+
+      hostDataXferAbort(p_port,p_card,BL_Card[p_card].currentSCCB);
+
+      }
+
+   /* If the Automation handled the end of the transfer then do not
+      match the phase or we will get out of sync with the ISR.       */
+
+   if (RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | XFER_CNT_0 | AUTO_INT))
+      return;
+
+   WR_HARPOON(p_port+hp_xfercnt_0, 0x00);
+
+   curr_phz = RD_HARPOON(p_port+hp_scsisig) & (UCHAR)S_SCSI_PHZ;
+
+   WRW_HARPOON((p_port+hp_intstat), XFER_CNT_0);
+
+
+   WR_HARPOON(p_port+hp_scsisig, curr_phz);
+
+   while ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)) &&
+      (curr_phz == (RD_HARPOON(p_port+hp_scsisig) & (UCHAR)S_SCSI_PHZ)) )
+      {
+      if (curr_phz & (UCHAR)SCSI_IOBIT)
+         {
+      	WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | SCSI_INBIT));
+
+	      if (!(RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY))
+            {
+	         RD_HARPOON(p_port+hp_fifodata_0);
+	         }
+	      }
+      else
+         {
+      	WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | HOST_WRT));
+   	   if (RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY)
+            {
+	         WR_HARPOON(p_port+hp_fifodata_0,0xFA);
+	         }
+	      }
+      } /* End of While loop for padding data I/O phase */
+
+      while ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
+         {
+         if (RD_HARPOON(p_port+hp_scsisig) & SCSI_REQ)
+      	   break;
+         }
+
+      WR_HARPOON(p_port+hp_portctrl_0, (SCSI_PORT | HOST_PORT | SCSI_INBIT));
+      while (!(RD_HARPOON(p_port+hp_xferstat) & FIFO_EMPTY))
+         {
+         RD_HARPOON(p_port+hp_fifodata_0);
+         }
+
+      if ( !(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RESET)))
+         {
+         WR_HARPOON(p_port+hp_autostart_0, (AUTO_IMMED+DISCONNECT_START));
+         while (!(RDW_HARPOON((p_port+hp_intstat)) & AUTO_INT)) {}
+
+         if (RDW_HARPOON((p_port+hp_intstat)) & (ICMD_COMP | ITAR_DISC))
+   	   while (!(RDW_HARPOON((p_port+hp_intstat)) & (BUS_FREE | RSEL))) ;
+         }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: schkdd
+ *
+ * Description: Make sure data has been flushed from both FIFOs and abort
+ *              the operations if necessary.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void schkdd(USHORT port, UCHAR p_card)
+#else
+void schkdd(ULONG port, UCHAR p_card)
+#endif
+{
+   USHORT TimeOutLoop;
+	UCHAR sPhase;
+
+   PSCCB currSCCB;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+
+   if ((currSCCB->Sccb_scsistat != DATA_OUT_ST) &&
+       (currSCCB->Sccb_scsistat != DATA_IN_ST)) {
+      return;
+      }
+
+
+
+   if (currSCCB->Sccb_XferState & F_ODD_BALL_CNT)
+      {
+
+      currSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt-1);
+
+      currSCCB->Sccb_XferCnt = 1;
+
+      currSCCB->Sccb_XferState &= ~F_ODD_BALL_CNT;
+      WRW_HARPOON((port+hp_fiforead), (USHORT) 0x00);
+      WR_HARPOON(port+hp_xferstat, 0x00);
+      }
+
+   else
+      {
+
+      currSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;
+
+      currSCCB->Sccb_XferCnt = 0;
+      }
+
+   if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
+      (currSCCB->HostStatus == SCCB_COMPLETE)) {
+
+      currSCCB->HostStatus = SCCB_PARITY_ERR;
+      WRW_HARPOON((port+hp_intstat), PARITY);
+      }
+
+
+   hostDataXferAbort(port,p_card,currSCCB);
+
+
+   while (RD_HARPOON(port+hp_scsisig) & SCSI_ACK) {}
+
+   TimeOutLoop = 0;
+
+   while(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)
+      {
+      if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE) {
+	      return;
+   	   }
+      if (RD_HARPOON(port+hp_offsetctr) & (UCHAR)0x1F) {
+	      break;
+   	   }
+      if (RDW_HARPOON((port+hp_intstat)) & RESET) {
+	      return;
+   	   }
+      if ((RD_HARPOON(port+hp_scsisig) & SCSI_REQ) || (TimeOutLoop++>0x3000) )
+   	   break;
+      }
+
+	sPhase = RD_HARPOON(port+hp_scsisig) & (SCSI_BSY | S_SCSI_PHZ);
+   if ((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))                     ||
+      (RD_HARPOON(port+hp_offsetctr) & (UCHAR)0x1F)                       ||
+      (sPhase == (SCSI_BSY | S_DATAO_PH)) ||
+      (sPhase == (SCSI_BSY | S_DATAI_PH)))
+      {
+
+	   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+
+	   if (!(currSCCB->Sccb_XferState & F_ALL_XFERRED))
+         {
+	      if (currSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+	         phaseDataIn(port,p_card);
+	      	}
+
+	   	else {
+	       phaseDataOut(port,p_card);
+	       	}
+	   	}
+		else
+      	{
+	   	sxfrp(port,p_card);
+	   	if (!(RDW_HARPOON((port+hp_intstat)) &
+		      (BUS_FREE | ICMD_COMP | ITAR_DISC | RESET)))
+         {
+   		WRW_HARPOON((port+hp_intstat), AUTO_INT);
+		   phaseDecode(port,p_card);
+		   }
+	   }
+
+   }
+
+   else {
+      WR_HARPOON(port+hp_portctrl_0, 0x00);
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sinits
+ *
+ * Description: Setup SCCB manager fields in this SCCB.
+ *
+ *---------------------------------------------------------------------*/
+
+void sinits(PSCCB p_sccb, UCHAR p_card)
+{
+   PSCCBMgr_tar_info currTar_Info;
+
+	if((p_sccb->TargID > MAX_SCSI_TAR) || (p_sccb->Lun > MAX_LUN))
+	{
+		return;
+	}
+   currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+
+   p_sccb->Sccb_XferState     = 0x00;
+   p_sccb->Sccb_XferCnt       = p_sccb->DataLength;
+
+   if ((p_sccb->OperationCode == SCATTER_GATHER_COMMAND) ||
+      (p_sccb->OperationCode == RESIDUAL_SG_COMMAND)) {
+
+      p_sccb->Sccb_SGoffset   = 0;
+      p_sccb->Sccb_XferState  = F_SG_XFER;
+      p_sccb->Sccb_XferCnt    = 0x00;
+      }
+
+   if (p_sccb->DataLength == 0x00)
+
+      p_sccb->Sccb_XferState |= F_ALL_XFERRED;
+
+   if (p_sccb->ControlByte & F_USE_CMD_Q)
+      {
+      if ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)
+         p_sccb->ControlByte &= ~F_USE_CMD_Q;
+
+      else
+	      currTar_Info->TarStatus |= TAG_Q_TRYING;
+      }
+
+/*      For !single SCSI device in system  & device allow Disconnect
+	or command is tag_q type then send Cmd with Disconnect Enable
+	else send Cmd with Disconnect Disable */
+
+/*
+   if (((!(BL_Card[p_card].globalFlags & F_SINGLE_DEVICE)) &&
+      (currTar_Info->TarStatus & TAR_ALLOW_DISC)) ||
+      (currTar_Info->TarStatus & TAG_Q_TRYING)) {
+*/
+   if ((currTar_Info->TarStatus & TAR_ALLOW_DISC) ||
+      (currTar_Info->TarStatus & TAG_Q_TRYING)) {
+      p_sccb->Sccb_idmsg      = (UCHAR)(SMIDENT | DISC_PRIV) | p_sccb->Lun;
+      }
+
+   else {
+
+      p_sccb->Sccb_idmsg      = (UCHAR)SMIDENT | p_sccb->Lun;
+      }
+
+   p_sccb->HostStatus         = 0x00;
+   p_sccb->TargetStatus       = 0x00;
+   p_sccb->Sccb_tag           = 0x00;
+   p_sccb->Sccb_MGRFlags      = 0x00;
+   p_sccb->Sccb_sgseg         = 0x00;
+   p_sccb->Sccb_ATC           = 0x00;
+   p_sccb->Sccb_savedATC      = 0x00;
+/*
+   p_sccb->SccbVirtDataPtr    = 0x00;
+   p_sccb->Sccb_forwardlink   = NULL;
+   p_sccb->Sccb_backlink      = NULL;
+ */
+   p_sccb->Sccb_scsistat      = BUS_FREE_ST;
+   p_sccb->SccbStatus         = SCCB_IN_PROCESS;
+   p_sccb->Sccb_scsimsg       = SMNO_OP;
+
+}
+
+
+#ident "$Id: phase.c 1.11 1997/01/31 02:08:49 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   phase.c  $
+ *
+ *   Description:  Functions to initially handle the SCSI bus phase when
+ *                 the target asserts request (and the automation is not
+ *                 enabled to handle the situation).
+ *
+ *   $Date: 1997/01/31 02:08:49 $
+ *
+ *   $Revision: 1.11 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <scsi2.h>*/
+/*#include <harpoon.h>*/
+
+
+/*
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+
+#if defined(OS2)
+   extern void (far *s_PhaseTbl[8]) (ULONG, UCHAR);
+#else
+   #if defined(DOS)
+      extern void (*s_PhaseTbl[8]) (USHORT, UCHAR);
+   #else
+      extern void (*s_PhaseTbl[8]) (ULONG, UCHAR);
+   #endif
+#endif
+*/
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Phase Decode
+ *
+ * Description: Determine the phase and call the appropriate function.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void phaseDecode(USHORT p_port, UCHAR p_card)
+#else
+void phaseDecode(ULONG p_port, UCHAR p_card)
+#endif
+{
+   unsigned char phase_ref;
+#if defined(OS2)
+   void (far *phase) (ULONG, UCHAR);
+#else
+   #if defined(DOS)
+      void (*phase) (USHORT, UCHAR);
+   #else
+      void (*phase) (ULONG, UCHAR);
+   #endif
+#endif
+
+
+   DISABLE_AUTO(p_port);
+
+   phase_ref = (UCHAR) (RD_HARPOON(p_port+hp_scsisig) & S_SCSI_PHZ);
+
+   phase = s_PhaseTbl[phase_ref];
+
+   (*phase)(p_port, p_card);           /* Call the correct phase func */
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Data Out Phase
+ *
+ * Description: Start up both the BusMaster and Xbow.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseDataOut(ULONG port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseDataOut(USHORT port, UCHAR p_card)
+#else
+void phaseDataOut(ULONG port, UCHAR p_card)
+#endif
+#endif
+{
+
+   PSCCB currSCCB;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+   if (currSCCB == NULL)
+      {
+      return;  /* Exit if No SCCB record */
+      }
+
+   currSCCB->Sccb_scsistat = DATA_OUT_ST;
+   currSCCB->Sccb_XferState &= ~(F_HOST_XFER_DIR | F_NO_DATA_YET);
+
+   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+
+   WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+
+   WR_HARPOON(port+hp_autostart_0, (END_DATA+END_DATA_START));
+
+   dataXferProcessor(port, &BL_Card[p_card]);
+
+#if defined(NOBUGBUG)
+   if (RDW_HARPOON((port+hp_intstat)) & XFER_CNT_0)
+      WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+
+#endif
+
+
+   if (currSCCB->Sccb_XferCnt == 0) {
+
+
+      if ((currSCCB->ControlByte & SCCB_DATA_XFER_OUT) &&
+	 (currSCCB->HostStatus == SCCB_COMPLETE))
+	 currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
+
+      sxfrp(port,p_card);
+      if (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | RESET)))
+	    phaseDecode(port,p_card);
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Data In Phase
+ *
+ * Description: Startup the BusMaster and the XBOW.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseDataIn(ULONG port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseDataIn(USHORT port, UCHAR p_card)
+#else
+void phaseDataIn(ULONG port, UCHAR p_card)
+#endif
+#endif
+{
+
+   PSCCB currSCCB;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+   if (currSCCB == NULL)
+      {
+      return;  /* Exit if No SCCB record */
+      }
+
+
+   currSCCB->Sccb_scsistat = DATA_IN_ST;
+   currSCCB->Sccb_XferState |= F_HOST_XFER_DIR;
+   currSCCB->Sccb_XferState &= ~F_NO_DATA_YET;
+
+   WR_HARPOON(port+hp_portctrl_0, SCSI_PORT);
+
+   WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+
+   WR_HARPOON(port+hp_autostart_0, (END_DATA+END_DATA_START));
+
+   dataXferProcessor(port, &BL_Card[p_card]);
+
+   if (currSCCB->Sccb_XferCnt == 0) {
+
+
+      if ((currSCCB->ControlByte & SCCB_DATA_XFER_IN) &&
+	 (currSCCB->HostStatus == SCCB_COMPLETE))
+	 currSCCB->HostStatus = SCCB_DATA_OVER_RUN;
+
+      sxfrp(port,p_card);
+      if (!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | RESET)))
+	    phaseDecode(port,p_card);
+
+      }
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Command Phase
+ *
+ * Description: Load the CDB into the automation and start it up.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseCommand(ULONG p_port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseCommand(USHORT p_port, UCHAR p_card)
+#else
+void phaseCommand(ULONG p_port, UCHAR p_card)
+#endif
+#endif
+{
+   PSCCB currSCCB;
+#if defined(DOS)
+   USHORT cdb_reg;
+#else
+   ULONG cdb_reg;
+#endif
+   UCHAR i;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+   if (currSCCB->OperationCode == RESET_COMMAND) {
+
+      currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+      currSCCB->CdbLength = SIX_BYTE_CMD;
+      }
+
+   WR_HARPOON(p_port+hp_scsisig, 0x00);
+
+   ARAM_ACCESS(p_port);
+
+
+   cdb_reg = p_port + CMD_STRT;
+
+   for (i=0; i < currSCCB->CdbLength; i++) {
+
+      if (currSCCB->OperationCode == RESET_COMMAND)
+
+	 WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + 0x00));
+
+      else
+	 WRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + currSCCB->Cdb[i]));
+      cdb_reg +=2;
+      }
+
+   if (currSCCB->CdbLength != TWELVE_BYTE_CMD)
+      WRW_HARPOON(cdb_reg, (BRH_OP+ALWAYS+    NP));
+
+   WR_HARPOON(p_port+hp_portctrl_0,(SCSI_PORT));
+
+   currSCCB->Sccb_scsistat = COMMAND_ST;
+
+   WR_HARPOON(p_port+hp_autostart_3, (AUTO_IMMED | CMD_ONLY_STRT));
+   SGRAM_ACCESS(p_port);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Status phase
+ *
+ * Description: Bring in the status and command complete message bytes
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseStatus(ULONG port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseStatus(USHORT port, UCHAR p_card)
+#else
+void phaseStatus(ULONG port, UCHAR p_card)
+#endif
+#endif
+{
+   /* Start-up the automation to finish off this command and let the
+      isr handle the interrupt for command complete when it comes in.
+      We could wait here for the interrupt to be generated?
+    */
+
+   WR_HARPOON(port+hp_scsisig, 0x00);
+
+   WR_HARPOON(port+hp_autostart_0, (AUTO_IMMED+END_DATA_START));
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Phase Message Out
+ *
+ * Description: Send out our message (if we have one) and handle whatever
+ *              else is involed.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseMsgOut(ULONG port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseMsgOut(USHORT port, UCHAR p_card)
+#else
+void phaseMsgOut(ULONG port, UCHAR p_card)
+#endif
+#endif
+{
+	UCHAR message,scsiID;
+	PSCCB currSCCB;
+	PSCCBMgr_tar_info currTar_Info;
+
+	currSCCB = BL_Card[p_card].currentSCCB;
+
+	if (currSCCB != NULL) {
+
+		message = currSCCB->Sccb_scsimsg;
+		scsiID = currSCCB->TargID;
+
+		if (message == SMDEV_RESET) 
+		{
+
+
+			currTar_Info = &sccbMgrTbl[p_card][scsiID];
+			currTar_Info->TarSyncCtrl = 0;
+			sssyncv(port, scsiID, NARROW_SCSI,currTar_Info);
+
+			if (sccbMgrTbl[p_card][scsiID].TarEEValue & EE_SYNC_MASK) 
+			{
+
+				sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_SYNC_MASK;
+
+			}
+
+			if (sccbMgrTbl[p_card][scsiID].TarEEValue & EE_WIDE_SCSI) 
+			{
+
+				sccbMgrTbl[p_card][scsiID].TarStatus &= ~TAR_WIDE_MASK;
+			}
+
+
+			queueFlushSccb(p_card,SCCB_COMPLETE);
+			SccbMgrTableInitTarget(p_card,scsiID);
+		}
+		else if (currSCCB->Sccb_scsistat == ABORT_ST)
+		{
+			currSCCB->HostStatus = SCCB_COMPLETE;
+			if(BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] != NULL)
+			{
+				BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+				sccbMgrTbl[p_card][scsiID].TarTagQ_Cnt--;
+			}
+					
+		}
+
+		else if (currSCCB->Sccb_scsistat < COMMAND_ST) 
+		{
+
+
+			if(message == SMNO_OP)
+			{
+				currSCCB->Sccb_MGRFlags |= F_DEV_SELECTED;
+		
+				ssel(port,p_card);
+				return;
+			}
+		}
+		else 
+		{
+
+
+			if (message == SMABORT)
+
+				queueFlushSccb(p_card,SCCB_COMPLETE);
+		}
+
+	}
+	else 
+	{
+		message = SMABORT;
+	}
+
+	WRW_HARPOON((port+hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));
+
+
+	WR_HARPOON(port+hp_portctrl_0, SCSI_BUS_EN);
+
+	WR_HARPOON(port+hp_scsidata_0,message);
+
+	WR_HARPOON(port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+
+	ACCEPT_MSG(port);
+
+	WR_HARPOON(port+hp_portctrl_0, 0x00);
+
+	if ((message == SMABORT) || (message == SMDEV_RESET) || 
+				(message == SMABORT_TAG) ) 
+	{
+
+		while(!(RDW_HARPOON((port+hp_intstat)) & (BUS_FREE | PHASE))) {}
+
+		if (RDW_HARPOON((port+hp_intstat)) & BUS_FREE) 
+		{
+			WRW_HARPOON((port+hp_intstat), BUS_FREE);
+
+			if (currSCCB != NULL) 
+			{
+
+				if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+					((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+					sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+				else
+					sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+
+				queueCmdComplete(&BL_Card[p_card],currSCCB, p_card);
+			}
+
+			else 
+			{
+				BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+			}
+		}
+
+		else 
+		{
+
+			sxfrp(port,p_card);
+		}
+	}
+
+	else 
+	{
+
+		if(message == SMPARITY)
+		{
+			currSCCB->Sccb_scsimsg = SMNO_OP;
+			WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		}
+		else
+		{
+			sxfrp(port,p_card);
+		}
+	}
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Message In phase
+ *
+ * Description: Bring in the message and determine what to do with it.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseMsgIn(ULONG port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseMsgIn(USHORT port, UCHAR p_card)
+#else
+void phaseMsgIn(ULONG port, UCHAR p_card)
+#endif
+#endif
+{
+	UCHAR message;
+	PSCCB currSCCB;
+
+	currSCCB = BL_Card[p_card].currentSCCB;
+
+	if (BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) 
+	{
+
+		phaseChkFifo(port, p_card);
+	}
+
+	message = RD_HARPOON(port+hp_scsidata_0);
+	if ((message == SMDISC) || (message == SMSAVE_DATA_PTR)) 
+	{
+
+		WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+END_DATA_START));
+
+	}
+
+	else 
+	{
+
+		message = sfm(port,currSCCB);
+		if (message) 
+		{
+
+
+			sdecm(message,port,p_card);
+
+		}
+		else
+		{
+			if(currSCCB->Sccb_scsimsg != SMPARITY)
+				ACCEPT_MSG(port);
+			WR_HARPOON(port+hp_autostart_1, (AUTO_IMMED+DISCONNECT_START));
+		}
+	}
+
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Illegal phase
+ *
+ * Description: Target switched to some illegal phase, so all we can do
+ *              is report an error back to the host (if that is possible)
+ *              and send an ABORT message to the misbehaving target.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(OS2)
+void far phaseIllegal(ULONG port, UCHAR p_card)
+#else
+#if defined(DOS)
+void phaseIllegal(USHORT port, UCHAR p_card)
+#else
+void phaseIllegal(ULONG port, UCHAR p_card)
+#endif
+#endif
+{
+   PSCCB currSCCB;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+   WR_HARPOON(port+hp_scsisig, RD_HARPOON(port+hp_scsisig));
+   if (currSCCB != NULL) {
+
+      currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+      currSCCB->Sccb_scsistat = ABORT_ST;
+      currSCCB->Sccb_scsimsg = SMABORT;
+      }
+
+   ACCEPT_MSG_ATN(port);
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Phase Check FIFO
+ *
+ * Description: Make sure data has been flushed from both FIFOs and abort
+ *              the operations if necessary.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void phaseChkFifo(USHORT port, UCHAR p_card)
+#else
+void phaseChkFifo(ULONG port, UCHAR p_card)
+#endif
+{
+   ULONG xfercnt;
+   PSCCB currSCCB;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+   if (currSCCB->Sccb_scsistat == DATA_IN_ST)
+      {
+
+      while((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)) &&
+	      (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY)) {}
+
+
+      if (!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))
+         {
+	      currSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;
+
+	      currSCCB->Sccb_XferCnt = 0;
+
+	      if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
+	            (currSCCB->HostStatus == SCCB_COMPLETE))
+            {
+	         currSCCB->HostStatus = SCCB_PARITY_ERR;
+	         WRW_HARPOON((port+hp_intstat), PARITY);
+	         }
+
+	      hostDataXferAbort(port,p_card,currSCCB);
+
+	      dataXferProcessor(port, &BL_Card[p_card]);
+
+	      while((!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY)) &&
+	         (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY)) {}
+
+	      }
+      }  /*End Data In specific code. */
+
+
+
+#if defined(DOS)
+   asm { mov dx,port;
+      add dx,hp_xfercnt_2;
+      in  al,dx;
+      dec dx;
+      xor ah,ah;
+      mov word ptr xfercnt+2,ax;
+      in  al,dx;
+      dec dx;
+      mov ah,al;
+      in  al,dx;
+      mov word ptr xfercnt,ax;
+      }
+#else
+   GET_XFER_CNT(port,xfercnt);
+#endif
+
+
+   WR_HARPOON(port+hp_xfercnt_0, 0x00);
+
+
+   WR_HARPOON(port+hp_portctrl_0, 0x00);
+
+   currSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - xfercnt);
+
+   currSCCB->Sccb_XferCnt = xfercnt;
+
+   if ((RDW_HARPOON((port+hp_intstat)) & PARITY) &&
+      (currSCCB->HostStatus == SCCB_COMPLETE)) {
+
+      currSCCB->HostStatus = SCCB_PARITY_ERR;
+      WRW_HARPOON((port+hp_intstat), PARITY);
+      }
+
+
+   hostDataXferAbort(port,p_card,currSCCB);
+
+
+   WR_HARPOON(port+hp_fifowrite, 0x00);
+   WR_HARPOON(port+hp_fiforead, 0x00);
+   WR_HARPOON(port+hp_xferstat, 0x00);
+
+   WRW_HARPOON((port+hp_intstat), XFER_CNT_0);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Phase Bus Free
+ *
+ * Description: We just went bus free so figure out if it was
+ *              because of command complete or from a disconnect.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void phaseBusFree(USHORT port, UCHAR p_card)
+#else
+void phaseBusFree(ULONG port, UCHAR p_card)
+#endif
+{
+   PSCCB currSCCB;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+   if (currSCCB != NULL)
+      {
+
+      DISABLE_AUTO(port);
+
+
+      if (currSCCB->OperationCode == RESET_COMMAND)
+         {
+
+			if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	   		 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+			else
+		   	 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+
+	      queueCmdComplete(&BL_Card[p_card], currSCCB, p_card);
+
+	      queueSearchSelect(&BL_Card[p_card],p_card);
+
+	      }
+
+      else if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
+	      {
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
+			         (UCHAR)SYNC_SUPPORTED;
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
+	      }
+
+      else if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
+	      {
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
+		            (sccbMgrTbl[p_card][currSCCB->TargID].
+		   TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
+
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
+	      }
+
+#if !defined(DOS)
+      else if(currSCCB->Sccb_scsistat == SELECT_Q_ST)
+	      {
+	      /* Make sure this is not a phony BUS_FREE.  If we were
+	      reselected or if BUSY is NOT on then this is a
+	      valid BUS FREE.  SRR Wednesday, 5/10/1995.     */
+
+	      if ((!(RD_HARPOON(port+hp_scsisig) & SCSI_BSY)) ||
+	         (RDW_HARPOON((port+hp_intstat)) & RSEL))
+	         {
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_TAG_Q_MASK;
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |= TAG_Q_REJECT;
+	         }
+
+	      else
+            {
+	         return;
+	         }
+         }
+#endif
+
+      else
+	      {
+
+	      currSCCB->Sccb_scsistat = BUS_FREE_ST;
+
+         if (!currSCCB->HostStatus)
+	         {
+	         currSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;
+	         }
+
+			if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	   		 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+			else
+		   	 sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+
+	      queueCmdComplete(&BL_Card[p_card], currSCCB, p_card);
+	      return;
+	      }
+
+
+      BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+
+      } /*end if !=null */
+}
+
+
+
+
+#ident "$Id: automate.c 1.14 1997/01/31 02:11:46 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   automate.c  $
+ *
+ *   Description:  Functions relating to programming the automation of
+ *                 the HARPOON.
+ *
+ *   $Date: 1997/01/31 02:11:46 $
+ *
+ *   $Revision: 1.14 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <scsi2.h>*/
+/*#include <harpoon.h>*/
+
+/*
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+extern SCCBCARD BL_Card[MAX_CARDS];
+*/
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Auto Load Default Map
+ *
+ * Description: Load the Automation RAM with the defualt map values.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void autoLoadDefaultMap(USHORT p_port)
+#else
+void autoLoadDefaultMap(ULONG p_port)
+#endif
+{
+#if defined(DOS)
+   USHORT map_addr;
+#else
+   ULONG map_addr;
+#endif
+
+   ARAM_ACCESS(p_port);
+   map_addr = p_port + hp_aramBase;
+
+   WRW_HARPOON(map_addr, (MPM_OP+AMSG_OUT+ 0xC0));  /*ID MESSAGE */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+AMSG_OUT+ 0x20));  /*SIMPLE TAG QUEUEING MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, RAT_OP);                   /*RESET ATTENTION */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+AMSG_OUT+ 0x00));  /*TAG ID MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 0 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 1 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 2 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 3 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 4 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 5 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 6 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 7 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 8 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 9 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 10 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MPM_OP+ACOMMAND+ 0x00));  /*CDB BYTE 11 */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CPE_OP+ADATA_OUT+ DINT)); /*JUMP IF DATA OUT */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (TCB_OP+FIFO_0+ DI));     /*JUMP IF NO DATA IN FIFO */
+   map_addr +=2;                                   /*This means AYNC DATA IN */
+   WRW_HARPOON(map_addr, (SSI_OP+   SSI_IDO_STRT)); /*STOP AND INTERRUPT */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CPE_OP+ADATA_IN+DINT));   /*JUMP IF NOT DATA IN PHZ */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CPN_OP+AMSG_IN+  ST));    /*IF NOT MSG IN CHECK 4 DATA IN */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CRD_OP+SDATA+    0x02));  /*SAVE DATA PTR MSG? */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (BRH_OP+NOT_EQ+   DC));    /*GO CHECK FOR DISCONNECT MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MRR_OP+SDATA+    D_AR1)); /*SAVE DATA PTRS MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CPN_OP+AMSG_IN+  ST));    /*IF NOT MSG IN CHECK DATA IN */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CRD_OP+SDATA+    0x04));  /*DISCONNECT MSG? */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (BRH_OP+NOT_EQ+   UNKNWN));/*UKNKNOWN MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MRR_OP+SDATA+    D_BUCKET));/*XFER DISCONNECT MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (SSI_OP+          SSI_ITAR_DISC));/*STOP AND INTERRUPT */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CPN_OP+ASTATUS+  UNKNWN));/*JUMP IF NOT STATUS PHZ. */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MRR_OP+SDATA+  D_AR0));   /*GET STATUS BYTE */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CPN_OP+AMSG_IN+  CC));    /*ERROR IF NOT MSG IN PHZ */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (CRD_OP+SDATA+    0x00));  /*CHECK FOR CMD COMPLETE MSG. */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (BRH_OP+NOT_EQ+   CC));    /*ERROR IF NOT CMD COMPLETE MSG. */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (MRR_OP+SDATA+  D_BUCKET));/*GET CMD COMPLETE MSG */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (SSI_OP+       SSI_ICMD_COMP));/*END OF COMMAND */
+   map_addr +=2;
+
+   WRW_HARPOON(map_addr, (SSI_OP+ SSI_IUNKWN));  /*RECEIVED UNKNOWN MSG BYTE */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (SSI_OP+ SSI_INO_CC));  /*NO COMMAND COMPLETE AFTER STATUS */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (SSI_OP+ SSI_ITICKLE)); /*BIOS Tickled the Mgr */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (SSI_OP+ SSI_IRFAIL));  /*EXPECTED ID/TAG MESSAGES AND */
+   map_addr +=2;                             /* DIDN'T GET ONE */
+   WRW_HARPOON(map_addr, (CRR_OP+AR3+  S_IDREG)); /* comp SCSI SEL ID & AR3*/
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (BRH_OP+EQUAL+   0x00));    /*SEL ID OK then Conti. */
+   map_addr +=2;
+   WRW_HARPOON(map_addr, (SSI_OP+ SSI_INO_CC));  /*NO COMMAND COMPLETE AFTER STATUS */
+
+
+
+   SGRAM_ACCESS(p_port);
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Auto Command Complete
+ *
+ * Description: Post command back to host and find another command
+ *              to execute.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void autoCmdCmplt(USHORT p_port, UCHAR p_card)
+#else
+void autoCmdCmplt(ULONG p_port, UCHAR p_card)
+#endif
+{
+   PSCCB currSCCB;
+   UCHAR status_byte;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+
+   status_byte = RD_HARPOON(p_port+hp_gp_reg_0);
+
+   sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = FALSE;
+
+   if (status_byte != SSGOOD) {
+
+      if (status_byte == SSQ_FULL) {
+
+
+			if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+			{
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
+				if(BL_Card[p_card].discQCount != 0)
+					BL_Card[p_card].discQCount--;
+				BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+			}
+			else
+			{
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+				if(currSCCB->Sccb_tag)
+				{
+					if(BL_Card[p_card].discQCount != 0)
+						BL_Card[p_card].discQCount--;
+					BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+				}else
+				{
+					if(BL_Card[p_card].discQCount != 0)
+						BL_Card[p_card].discQCount--;
+					BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+				}
+			}
+
+         currSCCB->Sccb_MGRFlags |= F_STATUSLOADED;
+
+         queueSelectFail(&BL_Card[p_card],p_card);
+
+         return;
+         }
+
+      if(currSCCB->Sccb_scsistat == SELECT_SN_ST)
+         {
+         sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=
+            (UCHAR)SYNC_SUPPORTED;
+
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_SYNC_MASK;
+         BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+
+			if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+			{
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
+				if(BL_Card[p_card].discQCount != 0)
+					BL_Card[p_card].discQCount--;
+				BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+			}
+			else
+			{
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+				if(currSCCB->Sccb_tag)
+				{
+					if(BL_Card[p_card].discQCount != 0)
+						BL_Card[p_card].discQCount--;
+					BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+				}else
+				{
+					if(BL_Card[p_card].discQCount != 0)
+						BL_Card[p_card].discQCount--;
+					BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+				}
+			}
+         return;
+
+         }
+
+      if(currSCCB->Sccb_scsistat == SELECT_WN_ST)
+         {
+
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =
+	         (sccbMgrTbl[p_card][currSCCB->TargID].
+	         TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;
+
+	      sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &= ~EE_WIDE_SCSI;
+         BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+
+			if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+				((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+			{
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
+				if(BL_Card[p_card].discQCount != 0)
+					BL_Card[p_card].discQCount--;
+				BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+			}
+			else
+			{
+	         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+				if(currSCCB->Sccb_tag)
+				{
+					if(BL_Card[p_card].discQCount != 0)
+						BL_Card[p_card].discQCount--;
+					BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+				}else
+				{
+					if(BL_Card[p_card].discQCount != 0)
+						BL_Card[p_card].discQCount--;
+					BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+				}
+			}
+         return;
+      
+         }
+     
+	   if (status_byte == SSCHECK) 
+		{
+			if(BL_Card[p_card].globalFlags & F_DO_RENEGO)
+			{
+				if (sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_SYNC_MASK)
+				{
+					sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_SYNC_MASK;
+				}
+				if (sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue & EE_WIDE_SCSI)
+				{
+					sccbMgrTbl[p_card][currSCCB->TargID].TarStatus &= ~TAR_WIDE_MASK;
+				}
+			}
+		}
+
+      if (!(currSCCB->Sccb_XferState & F_AUTO_SENSE)) {
+
+         currSCCB->SccbStatus = SCCB_ERROR;
+         currSCCB->TargetStatus = status_byte;
+
+         if (status_byte == SSCHECK) {
+
+            sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA
+               = TRUE;
+     
+
+#if (FW_TYPE==_SCCB_MGR_)
+            if (currSCCB->RequestSenseLength != NO_AUTO_REQUEST_SENSE) {
+
+               if (currSCCB->RequestSenseLength == 0)
+                  currSCCB->RequestSenseLength = 14;
+
+               ssenss(&BL_Card[p_card]);
+               BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+
+ 					if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+						((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+					{
+			         sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
+						if(BL_Card[p_card].discQCount != 0)
+							BL_Card[p_card].discQCount--;
+						BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+					}
+					else
+					{
+	   		      sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+						if(currSCCB->Sccb_tag)
+						{
+							if(BL_Card[p_card].discQCount != 0)
+								BL_Card[p_card].discQCount--;
+							BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+						}else
+						{
+							if(BL_Card[p_card].discQCount != 0)
+								BL_Card[p_card].discQCount--;
+							BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+						}
+					}
+               return;
+               }
+#else
+				   if ((!(currSCCB->Sccb_ucb_ptr->UCB_opcode & OPC_NO_AUTO_SENSE)) &&
+			   		(currSCCB->RequestSenseLength))
+				   {
+				   	ssenss(&BL_Card[p_card]);
+				      BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;
+
+						if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+							((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+						{
+	      			   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = TRUE;
+							if(BL_Card[p_card].discQCount != 0)
+								BL_Card[p_card].discQCount--;
+							BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[currSCCB->Lun]] = NULL;
+						}
+						else
+						{
+	      			   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = TRUE;
+							if(currSCCB->Sccb_tag)
+							{
+								if(BL_Card[p_card].discQCount != 0)
+									BL_Card[p_card].discQCount--;
+								BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] = NULL;
+							}else
+							{
+								if(BL_Card[p_card].discQCount != 0)
+									BL_Card[p_card].discQCount--;
+								BL_Card[p_card].discQ_Tbl[sccbMgrTbl[p_card][currSCCB->TargID].LunDiscQ_Idx[0]] = NULL;
+							}
+						}
+				      return;
+				   }
+
+#endif
+            }
+         }
+      }
+
+
+	if((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+		((sccbMgrTbl[p_card][currSCCB->TargID].TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+	   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->Lun] = FALSE;
+	else
+	   sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = FALSE;
+
+
+   queueCmdComplete(&BL_Card[p_card], currSCCB, p_card);
+}
+#ident "$Id: busmstr.c 1.8 1997/01/31 02:10:27 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   busmstr.c  $
+ *
+ *   Description:  Functions to start, stop, and abort BusMaster operations.
+ *
+ *   $Date: 1997/01/31 02:10:27 $
+ *
+ *   $Revision: 1.8 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <scsi2.h>*/
+/*#include <harpoon.h>*/
+
+
+/*
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+*/
+
+#define SHORT_WAIT   0x0000000F
+#define LONG_WAIT    0x0000FFFFL
+
+#if defined(BUGBUG)
+void Debug_Load(UCHAR p_card, UCHAR p_bug_data);
+#endif
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Data Transfer Processor
+ *
+ * Description: This routine performs two tasks.
+ *              (1) Start data transfer by calling HOST_DATA_XFER_START
+ *              function.  Once data transfer is started, (2) Depends
+ *              on the type of data transfer mode Scatter/Gather mode
+ *              or NON Scatter/Gather mode.  In NON Scatter/Gather mode,
+ *              this routine checks Sccb_MGRFlag (F_HOST_XFER_ACT bit) for
+ *              data transfer done.  In Scatter/Gather mode, this routine
+ *              checks bus master command complete and dual rank busy
+ *              bit to keep chaining SC transfer command.  Similarly,
+ *              in Scatter/Gather mode, it checks Sccb_MGRFlag
+ *              (F_HOST_XFER_ACT bit) for data transfer done.
+ *              
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void dataXferProcessor(USHORT port, PSCCBcard pCurrCard)
+#else
+void dataXferProcessor(ULONG port, PSCCBcard pCurrCard)
+#endif
+{
+   PSCCB currSCCB;
+
+   currSCCB = pCurrCard->currentSCCB;
+
+      if (currSCCB->Sccb_XferState & F_SG_XFER)
+			{
+			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
+
+				{
+		   	currSCCB->Sccb_sgseg += (UCHAR)SG_BUF_CNT;
+         	currSCCB->Sccb_SGoffset = 0x00; 
+ 				}
+			pCurrCard->globalFlags |= F_HOST_XFER_ACT;
+         
+         busMstrSGDataXferStart(port, currSCCB);
+			}
+
+      else
+			{
+			if (!(pCurrCard->globalFlags & F_HOST_XFER_ACT))
+				{
+				pCurrCard->globalFlags |= F_HOST_XFER_ACT;
+         
+         	busMstrDataXferStart(port, currSCCB);
+         	}
+			}
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: BusMaster Scatter Gather Data Transfer Start
+ *
+ * Description:
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void busMstrSGDataXferStart(USHORT p_port, PSCCB pcurrSCCB)
+#else
+void busMstrSGDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
+#endif
+{
+   ULONG count,addr,tmpSGCnt;
+   UINT sg_index;
+   UCHAR sg_count, i;
+#if defined(DOS)
+   USHORT reg_offset;
+#else
+   ULONG reg_offset;
+#endif
+
+
+   if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+
+      count =  ((ULONG) HOST_RD_CMD)<<24;
+      }
+
+   else {
+      count =  ((ULONG) HOST_WRT_CMD)<<24;
+      }
+
+   sg_count = 0;
+   tmpSGCnt = 0;
+   sg_index = pcurrSCCB->Sccb_sgseg;
+   reg_offset = hp_aramBase;
+
+
+	i = (UCHAR) (RD_HARPOON(p_port+hp_page_ctrl) & ~(SGRAM_ARAM|SCATTER_EN));
+
+
+	WR_HARPOON(p_port+hp_page_ctrl, i);
+
+   while ((sg_count < (UCHAR)SG_BUF_CNT) &&
+      ((ULONG)(sg_index * (UINT)SG_ELEMENT_SIZE) < pcurrSCCB->DataLength) ) {
+
+#if defined(COMPILER_16_BIT) && !defined(DOS)
+      tmpSGCnt += *(((ULONG far *)pcurrSCCB->DataPointer)+
+         (sg_index * 2));
+
+      count |= *(((ULONG far *)pcurrSCCB->DataPointer)+
+         (sg_index * 2));
+
+      addr = *(((ULONG far *)pcurrSCCB->DataPointer)+
+         ((sg_index * 2) + 1));
+
+#else
+      tmpSGCnt += *(((ULONG *)pcurrSCCB->DataPointer)+
+         (sg_index * 2));
+
+      count |= *(((ULONG *)pcurrSCCB->DataPointer)+
+         (sg_index * 2));
+
+      addr = *(((ULONG *)pcurrSCCB->DataPointer)+
+         ((sg_index * 2) + 1));
+#endif
+
+
+      if ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {
+
+         addr += ((count & 0x00FFFFFFL) - pcurrSCCB->Sccb_SGoffset);
+         count = (count & 0xFF000000L) | pcurrSCCB->Sccb_SGoffset;
+
+         tmpSGCnt = count & 0x00FFFFFFL;
+         }
+
+      WR_HARP32(p_port,reg_offset,addr);
+      reg_offset +=4;
+
+      WR_HARP32(p_port,reg_offset,count);
+      reg_offset +=4;
+
+      count &= 0xFF000000L;
+      sg_index++;
+      sg_count++;
+
+      } /*End While */
+
+   pcurrSCCB->Sccb_XferCnt = tmpSGCnt;
+
+   WR_HARPOON(p_port+hp_sg_addr,(sg_count<<4));
+
+   if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+
+      WR_HARP32(p_port,hp_xfercnt_0,tmpSGCnt);
+
+
+      WR_HARPOON(p_port+hp_portctrl_0,(DMA_PORT | SCSI_PORT | SCSI_INBIT));
+      WR_HARPOON(p_port+hp_scsisig, S_DATAI_PH);
+      }
+
+   else {
+
+
+      if ((!(RD_HARPOON(p_port+hp_synctarg_0) & NARROW_SCSI)) &&
+         (tmpSGCnt & 0x000000001))
+         {
+
+         pcurrSCCB->Sccb_XferState |= F_ODD_BALL_CNT;
+         tmpSGCnt--;
+         }
+
+
+      WR_HARP32(p_port,hp_xfercnt_0,tmpSGCnt);
+
+      WR_HARPOON(p_port+hp_portctrl_0,(SCSI_PORT | DMA_PORT | DMA_RD));
+      WR_HARPOON(p_port+hp_scsisig, S_DATAO_PH);
+      }
+
+
+   WR_HARPOON(p_port+hp_page_ctrl, (UCHAR) (i | SCATTER_EN));
+
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: BusMaster Data Transfer Start
+ *
+ * Description: 
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void busMstrDataXferStart(USHORT p_port, PSCCB pcurrSCCB)
+#else
+void busMstrDataXferStart(ULONG p_port, PSCCB pcurrSCCB)
+#endif
+{
+   ULONG addr,count;
+
+   if (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {
+
+      count = pcurrSCCB->Sccb_XferCnt;
+
+      addr = (ULONG) pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;
+      }
+
+   else {
+      addr = pcurrSCCB->SensePointer;
+      count = pcurrSCCB->RequestSenseLength;
+
+      }
+
+#if defined(DOS)
+   asm { mov dx,p_port;
+         mov ax,word ptr count;
+         add dx,hp_xfer_cnt_lo;
+         out dx,al;
+         inc dx;
+         xchg ah,al
+         out dx,al;
+         inc dx;
+         mov ax,word ptr count+2;
+         out dx,al;
+         inc dx;
+         inc dx;
+         mov ax,word ptr addr;
+         out dx,al;
+         inc dx;
+         xchg ah,al
+         out dx,al;
+         inc dx;
+         mov ax,word ptr addr+2;
+         out dx,al;
+         inc dx;
+         xchg ah,al
+         out dx,al;
+         }
+
+   WR_HARP32(p_port,hp_xfercnt_0,count);
+
+#else
+   HP_SETUP_ADDR_CNT(p_port,addr,count);
+#endif
+
+
+   if (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {
+
+      WR_HARPOON(p_port+hp_portctrl_0,(DMA_PORT | SCSI_PORT | SCSI_INBIT));
+      WR_HARPOON(p_port+hp_scsisig, S_DATAI_PH);
+
+      WR_HARPOON(p_port+hp_xfer_cmd,
+         (XFER_DMA_HOST | XFER_HOST_AUTO | XFER_DMA_8BIT));
+      }
+
+   else {
+
+      WR_HARPOON(p_port+hp_portctrl_0,(SCSI_PORT | DMA_PORT | DMA_RD));
+      WR_HARPOON(p_port+hp_scsisig, S_DATAO_PH);
+
+      WR_HARPOON(p_port+hp_xfer_cmd,
+         (XFER_HOST_DMA | XFER_HOST_AUTO | XFER_DMA_8BIT));
+
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: BusMaster Timeout Handler
+ *
+ * Description: This function is called after a bus master command busy time
+ *               out is detected.  This routines issue halt state machine
+ *               with a software time out for command busy.  If command busy
+ *               is still asserted at the end of the time out, it issues
+ *               hard abort with another software time out.  It hard abort
+ *               command busy is also time out, it'll just give up.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+UCHAR busMstrTimeOut(USHORT p_port)
+#else
+UCHAR busMstrTimeOut(ULONG p_port)
+#endif
+{
+   ULONG timeout;
+
+   timeout = LONG_WAIT;
+
+   WR_HARPOON(p_port+hp_sys_ctrl, HALT_MACH);
+
+   while ((!(RD_HARPOON(p_port+hp_ext_status) & CMD_ABORTED)) && timeout--) {}
+
+   
+   
+   if (RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) {
+      WR_HARPOON(p_port+hp_sys_ctrl, HARD_ABORT);
+
+      timeout = LONG_WAIT;
+      while ((RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) && timeout--) {}
+      }
+
+   RD_HARPOON(p_port+hp_int_status);           /*Clear command complete */
+
+   if (RD_HARPOON(p_port+hp_ext_status) & BM_CMD_BUSY) {
+      return(TRUE);
+      }
+
+   else {
+      return(FALSE);
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Host Data Transfer Abort
+ *
+ * Description: Abort any in progress transfer.
+ *
+ *---------------------------------------------------------------------*/
+#if defined(DOS)
+void hostDataXferAbort(USHORT port, UCHAR p_card, PSCCB pCurrSCCB)
+#else
+void hostDataXferAbort(ULONG port, UCHAR p_card, PSCCB pCurrSCCB)
+#endif
+{
+
+   ULONG timeout;
+   ULONG remain_cnt;
+   UINT sg_ptr;
+
+   BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;
+
+   if (pCurrSCCB->Sccb_XferState & F_AUTO_SENSE) {
+
+
+      if (!(RD_HARPOON(port+hp_int_status) & INT_CMD_COMPL)) {
+
+         WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) | FLUSH_XFER_CNTR));
+         timeout = LONG_WAIT;
+
+         while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) && timeout--) {}
+
+         WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) & ~FLUSH_XFER_CNTR));
+
+         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+
+            if (busMstrTimeOut(port)) {
+
+               if (pCurrSCCB->HostStatus == 0x00)
+
+                  pCurrSCCB->HostStatus = SCCB_BM_ERR;
+
+               }
+
+            if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) 
+
+               if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) 
+
+                  if (pCurrSCCB->HostStatus == 0x00)
+
+                     {
+                     pCurrSCCB->HostStatus = SCCB_BM_ERR;
+#if defined(BUGBUG)
+                     WR_HARPOON(port+hp_dual_addr_lo,
+                        RD_HARPOON(port+hp_ext_status));
+#endif
+                     }
+            }
+         }
+      }
+
+   else if (pCurrSCCB->Sccb_XferCnt) {
+
+      if (pCurrSCCB->Sccb_XferState & F_SG_XFER) {
+
+
+              WR_HARPOON(port+hp_page_ctrl, (RD_HARPOON(port+hp_page_ctrl) &
+            ~SCATTER_EN));
+
+         WR_HARPOON(port+hp_sg_addr,0x00);
+
+         sg_ptr = pCurrSCCB->Sccb_sgseg + SG_BUF_CNT;
+
+         if (sg_ptr > (UINT)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE)) {
+
+            sg_ptr = (UINT)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
+            }
+
+         remain_cnt = pCurrSCCB->Sccb_XferCnt;
+
+         while (remain_cnt < 0x01000000L) {
+
+            sg_ptr--;
+
+#if defined(COMPILER_16_BIT) && !defined(DOS)
+            if (remain_cnt > (ULONG)(*(((ULONG far *)pCurrSCCB->
+               DataPointer) + (sg_ptr * 2)))) {
+
+               remain_cnt -= (ULONG)(*(((ULONG far *)pCurrSCCB->
+                  DataPointer) + (sg_ptr * 2)));
+               }
+
+#else
+            if (remain_cnt > (ULONG)(*(((ULONG *)pCurrSCCB->
+               DataPointer) + (sg_ptr * 2)))) {
+
+               remain_cnt -= (ULONG)(*(((ULONG *)pCurrSCCB->
+                  DataPointer) + (sg_ptr * 2)));
+               }
+#endif
+
+            else {
+
+               break;
+               }
+            }
+
+
+
+         if (remain_cnt < 0x01000000L) {
+
+
+            pCurrSCCB->Sccb_SGoffset = remain_cnt;
+
+            pCurrSCCB->Sccb_sgseg = (USHORT)sg_ptr;
+
+
+            if ((ULONG)(sg_ptr * SG_ELEMENT_SIZE) == pCurrSCCB->DataLength 
+                && (remain_cnt == 0))
+
+               pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
+            }
+
+         else {
+
+
+            if (pCurrSCCB->HostStatus == 0x00) {
+
+               pCurrSCCB->HostStatus = SCCB_GROSS_FW_ERR;
+               }
+            }
+         }
+
+
+      if (!(pCurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)) {
+
+
+         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+
+            busMstrTimeOut(port);
+            }
+
+         else {
+
+            if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) {
+
+               if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) {
+
+                  if (pCurrSCCB->HostStatus == 0x00) {
+
+                     pCurrSCCB->HostStatus = SCCB_BM_ERR;
+#if defined(BUGBUG)
+                     WR_HARPOON(port+hp_dual_addr_lo,
+                        RD_HARPOON(port+hp_ext_status));
+#endif
+                     }
+                  }
+               }
+
+            }
+         }
+
+      else {
+
+
+         if ((RD_HARPOON(port+hp_fifo_cnt)) >= BM_THRESHOLD) {
+
+            timeout = SHORT_WAIT;
+
+            while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) &&
+               ((RD_HARPOON(port+hp_fifo_cnt)) >= BM_THRESHOLD) &&
+               timeout--) {}
+            }
+
+         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+
+            WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) |
+               FLUSH_XFER_CNTR));
+
+            timeout = LONG_WAIT;
+
+            while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) &&
+               timeout--) {}
+
+            WR_HARPOON(port+hp_bm_ctrl, (RD_HARPOON(port+hp_bm_ctrl) &
+               ~FLUSH_XFER_CNTR));
+
+
+            if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+
+               if (pCurrSCCB->HostStatus == 0x00) {
+
+                  pCurrSCCB->HostStatus = SCCB_BM_ERR;
+                  }
+
+               busMstrTimeOut(port);
+               }
+            }
+
+         if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) {
+
+            if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) {
+
+               if (pCurrSCCB->HostStatus == 0x00) {
+
+                  pCurrSCCB->HostStatus = SCCB_BM_ERR;
+#if defined(BUGBUG)
+                  WR_HARPOON(port+hp_dual_addr_lo,
+                     RD_HARPOON(port+hp_ext_status));
+#endif
+                  }
+               }
+            }
+         }
+
+      }
+
+   else {
+
+
+      if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+
+         timeout = LONG_WAIT;
+
+         while ((RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) && timeout--) {}
+
+         if (RD_HARPOON(port+hp_ext_status) & BM_CMD_BUSY) {
+
+            if (pCurrSCCB->HostStatus == 0x00) {
+
+               pCurrSCCB->HostStatus = SCCB_BM_ERR;
+               }
+
+            busMstrTimeOut(port);
+            }
+         }
+
+
+      if (RD_HARPOON(port+hp_int_status) & INT_EXT_STATUS) {
+
+         if (RD_HARPOON(port+hp_ext_status) & BAD_EXT_STATUS) {
+
+            if (pCurrSCCB->HostStatus == 0x00) {
+
+               pCurrSCCB->HostStatus = SCCB_BM_ERR;
+#if defined(BUGBUG)
+               WR_HARPOON(port+hp_dual_addr_lo,
+                  RD_HARPOON(port+hp_ext_status));
+#endif
+               }
+            }
+
+         }
+
+      if (pCurrSCCB->Sccb_XferState & F_SG_XFER) {
+
+         WR_HARPOON(port+hp_page_ctrl, (RD_HARPOON(port+hp_page_ctrl) &
+                 ~SCATTER_EN));
+
+         WR_HARPOON(port+hp_sg_addr,0x00);
+
+         pCurrSCCB->Sccb_sgseg += SG_BUF_CNT;
+
+         pCurrSCCB->Sccb_SGoffset = 0x00; 
+
+
+         if ((ULONG)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=
+            pCurrSCCB->DataLength) {
+
+            pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
+
+            pCurrSCCB->Sccb_sgseg = (USHORT)(pCurrSCCB->DataLength / SG_ELEMENT_SIZE);
+
+            }
+         }
+
+      else {
+
+         if (!(pCurrSCCB->Sccb_XferState & F_AUTO_SENSE))
+
+            pCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;
+         }
+      }
+
+   WR_HARPOON(port+hp_int_mask,(INT_CMD_COMPL | SCSI_INTERRUPT));
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Host Data Transfer Restart
+ *
+ * Description: Reset the available count due to a restore data
+ *              pointers message.
+ *
+ *---------------------------------------------------------------------*/
+void hostDataXferRestart(PSCCB currSCCB)
+{
+   ULONG data_count;
+   UINT  sg_index;
+#if defined(COMPILER_16_BIT) && !defined(DOS)
+   ULONG far *sg_ptr;
+#else
+   ULONG *sg_ptr;
+#endif
+
+   if (currSCCB->Sccb_XferState & F_SG_XFER) {
+
+      currSCCB->Sccb_XferCnt = 0;
+
+      sg_index = 0xffff;         /*Index by long words into sg list. */
+      data_count = 0;            /*Running count of SG xfer counts. */
+
+#if defined(COMPILER_16_BIT) && !defined(DOS)
+      sg_ptr = (ULONG far *)currSCCB->DataPointer;
+#else
+      sg_ptr = (ULONG *)currSCCB->DataPointer;
+#endif
+
+      while (data_count < currSCCB->Sccb_ATC) {
+
+         sg_index++;
+         data_count += *(sg_ptr+(sg_index * 2));
+         }
+
+      if (data_count == currSCCB->Sccb_ATC) {
+
+         currSCCB->Sccb_SGoffset = 0;
+         sg_index++;
+         }
+
+      else {
+         currSCCB->Sccb_SGoffset = data_count - currSCCB->Sccb_ATC;
+         }
+
+      currSCCB->Sccb_sgseg = (USHORT)sg_index;
+      }
+
+   else {
+      currSCCB->Sccb_XferCnt = currSCCB->DataLength - currSCCB->Sccb_ATC;
+      }
+}
+#ident "$Id: scam.c 1.17 1997/03/20 23:49:37 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   scam.c  $
+ *
+ *   Description:  Functions relating to handling of the SCAM selection
+ *                 and the determination of the SCSI IDs to be assigned
+ *                 to all perspective SCSI targets.
+ *
+ *   $Date: 1997/03/20 23:49:37 $
+ *
+ *   $Revision: 1.17 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <scsi2.h>*/
+/*#include <eeprom.h>*/
+/*#include <harpoon.h>*/
+
+
+
+/*
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBSCAM_INFO scamInfo[MAX_SCSI_TAR];
+extern NVRAMINFO nvRamInfo[MAX_MB_CARDS];
+#if defined(DOS) || defined(OS2)
+extern UCHAR temp_id_string[ID_STRING_LENGTH];
+#endif
+extern UCHAR scamHAString[];
+*/
+/*---------------------------------------------------------------------
+ *
+ * Function: scini
+ *
+ * Description: Setup all data structures necessary for SCAM selection.
+ *
+ *---------------------------------------------------------------------*/
+
+void scini(UCHAR p_card, UCHAR p_our_id, UCHAR p_power_up)
+{
+
+#if defined(SCAM_LEV_2)
+   UCHAR loser,assigned_id;
+#endif
+#if defined(DOS)
+
+   USHORT p_port;
+#else
+   ULONG p_port;
+#endif
+
+   UCHAR i,k,ScamFlg ;
+   PSCCBcard currCard;
+	PNVRamInfo pCurrNvRam;
+
+   currCard = &BL_Card[p_card];
+   p_port = currCard->ioPort;
+	pCurrNvRam = currCard->pNvRamInfo;
+
+
+	if(pCurrNvRam){
+		ScamFlg = pCurrNvRam->niScamConf;
+		i = pCurrNvRam->niSysConf;
+	}
+	else{
+	   ScamFlg = (UCHAR) utilEERead(p_port, SCAM_CONFIG/2);
+	   i = (UCHAR)(utilEERead(p_port, (SYSTEM_CONFIG/2)));
+	}
+	if(!(i & 0x02))	/* check if reset bus in AutoSCSI parameter set */
+		return;
+
+   inisci(p_card,p_port, p_our_id);
+
+   /* Force to wait 1 sec after SCSI bus reset. Some SCAM device FW
+      too slow to return to SCAM selection */
+
+   /* if (p_power_up)
+         Wait1Second(p_port);
+      else
+         Wait(p_port, TO_250ms); */
+
+   Wait1Second(p_port);
+
+#if defined(SCAM_LEV_2)
+
+   if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
+      {
+      while (!(scarb(p_port,INIT_SELTD))) {}
+
+      scsel(p_port);
+
+      do {
+         scxferc(p_port,SYNC_PTRN);
+         scxferc(p_port,DOM_MSTR);
+         loser = scsendi(p_port,&scamInfo[p_our_id].id_string[0]);
+         } while ( loser == 0xFF );
+
+      scbusf(p_port);
+
+      if ((p_power_up) && (!loser))
+         {
+         sresb(p_port,p_card);
+         Wait(p_port, TO_250ms);
+
+         while (!(scarb(p_port,INIT_SELTD))) {}
+
+         scsel(p_port);
+
+         do {
+            scxferc(p_port, SYNC_PTRN);
+            scxferc(p_port, DOM_MSTR);
+            loser = scsendi(p_port,&scamInfo[p_our_id].
+               id_string[0]);
+            } while ( loser == 0xFF );
+
+         scbusf(p_port);
+         }
+      }
+
+   else
+      {
+      loser = FALSE;
+      }
+
+
+   if (!loser)
+      {
+
+#endif  /* SCAM_LEV_2 */
+
+      scamInfo[p_our_id].state = ID_ASSIGNED;
+
+
+		if (ScamFlg & SCAM_ENABLED)
+		{
+
+	      for (i=0; i < MAX_SCSI_TAR; i++)
+  		   {
+      	   if ((scamInfo[i].state == ID_UNASSIGNED) ||
+  	      	   (scamInfo[i].state == ID_UNUSED))
+	  	      {
+   	     	   if (scsell(p_port,i))
+      	  	   {
+            	   scamInfo[i].state = LEGACY;
+  	            	if ((scamInfo[i].id_string[0] != 0xFF) ||
+     	            	(scamInfo[i].id_string[1] != 0xFA))
+	     	         {
+
+   	        	      scamInfo[i].id_string[0] = 0xFF;
+      	        	   scamInfo[i].id_string[1] = 0xFA;
+							if(pCurrNvRam == NULL)
+	         	         currCard->globalFlags |= F_UPDATE_EEPROM;
+               	}
+	  	         }
+   	  	   }
+      	}
+
+	      sresb(p_port,p_card);
+      	Wait1Second(p_port);
+         while (!(scarb(p_port,INIT_SELTD))) {}
+         scsel(p_port);
+         scasid(p_card, p_port);
+         }
+
+#if defined(SCAM_LEV_2)
+
+      }
+
+   else if ((loser) && (ScamFlg & SCAM_ENABLED))
+      {
+      scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;
+      assigned_id = FALSE;
+      scwtsel(p_port);
+
+      do {
+         while (scxferc(p_port,0x00) != SYNC_PTRN) {}
+
+         i = scxferc(p_port,0x00);
+         if (i == ASSIGN_ID)
+            {
+            if (!(scsendi(p_port,&scamInfo[p_our_id].id_string[0])))
+                  {
+                  i = scxferc(p_port,0x00);
+                  if (scvalq(i))
+                     {
+                     k = scxferc(p_port,0x00);
+
+                     if (scvalq(k))
+                        {
+                        currCard->ourId =
+                           ((UCHAR)(i<<3)+(k & (UCHAR)7)) & (UCHAR) 0x3F;
+                        inisci(p_card, p_port, p_our_id);
+                        scamInfo[currCard->ourId].state = ID_ASSIGNED;
+                        scamInfo[currCard->ourId].id_string[0]
+                           = SLV_TYPE_CODE0;
+                        assigned_id = TRUE;
+                        }
+                     }
+                  }
+            }
+
+         else if (i == SET_P_FLAG)
+            {
+               if (!(scsendi(p_port,
+                        &scamInfo[p_our_id].id_string[0])))
+                        scamInfo[p_our_id].id_string[0] |= 0x80;
+            }
+         }while (!assigned_id);
+
+      while (scxferc(p_port,0x00) != CFG_CMPLT) {}
+      }
+
+#endif   /* SCAM_LEV_2 */
+   if (ScamFlg & SCAM_ENABLED)
+      {
+      scbusf(p_port);
+      if (currCard->globalFlags & F_UPDATE_EEPROM)
+         {
+         scsavdi(p_card, p_port);
+         currCard->globalFlags &= ~F_UPDATE_EEPROM;
+         }
+      }
+
+
+#if defined(DOS)
+   for (i=0; i < MAX_SCSI_TAR; i++)
+   {
+     	if (((ScamFlg & SCAM_ENABLED) && (scamInfo[i].state == LEGACY))
+			|| (i != p_our_id))
+        	{
+         scsellDOS(p_port,i);
+  	      }
+  	}
+#endif
+
+/*
+   for (i=0,k=0; i < MAX_SCSI_TAR; i++)
+      {
+      if ((scamInfo[i].state == ID_ASSIGNED) ||
+         (scamInfo[i].state == LEGACY))
+         k++;
+      }
+
+   if (k==2)
+      currCard->globalFlags |= F_SINGLE_DEVICE;
+   else
+      currCard->globalFlags &= ~F_SINGLE_DEVICE;
+*/
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scarb
+ *
+ * Description: Gain control of the bus and wait SCAM select time (250ms)
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+int scarb(USHORT p_port, UCHAR p_sel_type)
+#else
+int scarb(ULONG p_port, UCHAR p_sel_type)
+#endif
+{
+   if (p_sel_type == INIT_SELTD)
+      {
+
+      while (RD_HARPOON(p_port+hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {}
+
+
+      if (RD_HARPOON(p_port+hp_scsisig) & SCSI_SEL)
+         return(FALSE);
+
+      if (RD_HARPOON(p_port+hp_scsidata_0) != 00)
+         return(FALSE);
+
+      WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_BSY));
+
+      if (RD_HARPOON(p_port+hp_scsisig) & SCSI_SEL) {
+
+         WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) &
+            ~SCSI_BSY));
+         return(FALSE);
+         }
+
+
+      WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_SEL));
+
+      if (RD_HARPOON(p_port+hp_scsidata_0) != 00) {
+
+         WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) &
+            ~(SCSI_BSY | SCSI_SEL)));
+         return(FALSE);
+         }
+      }
+
+
+   WR_HARPOON(p_port+hp_clkctrl_0, (RD_HARPOON(p_port+hp_clkctrl_0)
+      & ~ACTdeassert));
+   WR_HARPOON(p_port+hp_scsireset, SCAM_EN);
+   WR_HARPOON(p_port+hp_scsidata_0, 0x00);
+#if defined(WIDE_SCSI)
+   WR_HARPOON(p_port+hp_scsidata_1, 0x00);
+#endif
+   WR_HARPOON(p_port+hp_portctrl_0, SCSI_BUS_EN);
+
+   WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig) | SCSI_MSG));
+
+   WR_HARPOON(p_port+hp_scsisig, (RD_HARPOON(p_port+hp_scsisig)
+      & ~SCSI_BSY));
+
+   Wait(p_port,TO_250ms);
+
+   return(TRUE);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scbusf
+ *
+ * Description: Release the SCSI bus and disable SCAM selection.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scbusf(USHORT p_port)
+#else
+void scbusf(ULONG p_port)
+#endif
+{
+   WR_HARPOON(p_port+hp_page_ctrl,
+      (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
+
+
+   WR_HARPOON(p_port+hp_scsidata_0, 0x00);
+
+   WR_HARPOON(p_port+hp_portctrl_0, (RD_HARPOON(p_port+hp_portctrl_0)
+      & ~SCSI_BUS_EN));
+
+   WR_HARPOON(p_port+hp_scsisig, 0x00);
+
+
+   WR_HARPOON(p_port+hp_scsireset,  (RD_HARPOON(p_port+hp_scsireset)
+      & ~SCAM_EN));
+
+   WR_HARPOON(p_port+hp_clkctrl_0, (RD_HARPOON(p_port+hp_clkctrl_0)
+      | ACTdeassert));
+
+#if defined(SCAM_LEV_2)
+   WRW_HARPOON((p_port+hp_intstat), (BUS_FREE | AUTO_INT | SCAM_SEL));
+#else
+   WRW_HARPOON((p_port+hp_intstat), (BUS_FREE | AUTO_INT));
+#endif
+
+   WR_HARPOON(p_port+hp_page_ctrl,
+      (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scasid
+ *
+ * Description: Assign an ID to all the SCAM devices.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scasid(UCHAR p_card, USHORT p_port)
+#else
+void scasid(UCHAR p_card, ULONG p_port)
+#endif
+{
+#if defined(DOS) || defined(OS2)
+   /* Use external defined in global space area, instead of Stack
+      space. WIN/95 DOS doesnot work TINY mode. The OS doesnot intialize
+      SS equal to DS. Thus the array allocated on stack doesnot get
+      access correctly */
+#else
+   UCHAR temp_id_string[ID_STRING_LENGTH];
+#endif
+
+   UCHAR i,k,scam_id;
+	UCHAR crcBytes[3];
+	PNVRamInfo pCurrNvRam;
+	ushort_ptr pCrcBytes;
+
+	pCurrNvRam = BL_Card[p_card].pNvRamInfo;
+
+   i=FALSE;
+
+   while (!i)
+      {
+
+      for (k=0; k < ID_STRING_LENGTH; k++)
+         {
+         temp_id_string[k] = (UCHAR) 0x00;
+         }
+
+      scxferc(p_port,SYNC_PTRN);
+      scxferc(p_port,ASSIGN_ID);
+
+      if (!(sciso(p_port,&temp_id_string[0])))
+         {
+			if(pCurrNvRam){
+				pCrcBytes = (ushort_ptr)&crcBytes[0];
+				*pCrcBytes = CalcCrc16(&temp_id_string[0]);
+				crcBytes[2] = CalcLrc(&temp_id_string[0]);
+				temp_id_string[1] = crcBytes[2];
+				temp_id_string[2] = crcBytes[0];
+				temp_id_string[3] = crcBytes[1];
+				for(k = 4; k < ID_STRING_LENGTH; k++)
+					temp_id_string[k] = (UCHAR) 0x00;
+			}
+         i = scmachid(p_card,temp_id_string);
+
+         if (i == CLR_PRIORITY)
+            {
+            scxferc(p_port,MISC_CODE);
+            scxferc(p_port,CLR_P_FLAG);
+            i = FALSE;  /*Not the last ID yet. */
+            }
+
+         else if (i != NO_ID_AVAIL)
+            {
+            if (i < 8 )
+               scxferc(p_port,ID_0_7);
+            else
+               scxferc(p_port,ID_8_F);
+
+            scam_id = (i & (UCHAR) 0x07);
+
+
+            for (k=1; k < 0x08; k <<= 1)
+               if (!( k & i ))
+                  scam_id += 0x08;        /*Count number of zeros in DB0-3. */
+
+            scxferc(p_port,scam_id);
+
+            i = FALSE;  /*Not the last ID yet. */
+            }
+         }
+
+      else
+         {
+         i = TRUE;
+         }
+
+      }  /*End while */
+
+   scxferc(p_port,SYNC_PTRN);
+   scxferc(p_port,CFG_CMPLT);
+}
+
+
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scsel
+ *
+ * Description: Select all the SCAM devices.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scsel(USHORT p_port)
+#else
+void scsel(ULONG p_port)
+#endif
+{
+
+   WR_HARPOON(p_port+hp_scsisig, SCSI_SEL);
+   scwiros(p_port, SCSI_MSG);
+
+   WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY));
+
+
+   WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
+   WR_HARPOON(p_port+hp_scsidata_0, (UCHAR)(RD_HARPOON(p_port+hp_scsidata_0) |
+      (UCHAR)(BIT(7)+BIT(6))));
+
+
+   WR_HARPOON(p_port+hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));
+   scwiros(p_port, SCSI_SEL);
+
+   WR_HARPOON(p_port+hp_scsidata_0, (UCHAR)(RD_HARPOON(p_port+hp_scsidata_0) &
+      ~(UCHAR)BIT(6)));
+   scwirod(p_port, BIT(6));
+
+   WR_HARPOON(p_port+hp_scsisig, (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scxferc
+ *
+ * Description: Handshake the p_data (DB4-0) across the bus.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR scxferc(USHORT p_port, UCHAR p_data)
+#else
+UCHAR scxferc(ULONG p_port, UCHAR p_data)
+#endif
+{
+   UCHAR curr_data, ret_data;
+
+   curr_data = p_data | BIT(7) | BIT(5);   /*Start with DB7 & DB5 asserted. */
+
+   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+
+   curr_data &= ~BIT(7);
+
+   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+
+   scwirod(p_port,BIT(7));              /*Wait for DB7 to be released. */
+	while (!(RD_HARPOON(p_port+hp_scsidata_0) & BIT(5)));
+
+   ret_data = (RD_HARPOON(p_port+hp_scsidata_0) & (UCHAR) 0x1F);
+
+   curr_data |= BIT(6);
+
+   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+
+   curr_data &= ~BIT(5);
+
+   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+
+   scwirod(p_port,BIT(5));              /*Wait for DB5 to be released. */
+
+   curr_data &= ~(BIT(4)|BIT(3)|BIT(2)|BIT(1)|BIT(0)); /*Release data bits */
+   curr_data |= BIT(7);
+
+   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+
+   curr_data &= ~BIT(6);
+
+   WR_HARPOON(p_port+hp_scsidata_0, curr_data);
+
+   scwirod(p_port,BIT(6));              /*Wait for DB6 to be released. */
+
+   return(ret_data);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scsendi
+ *
+ * Description: Transfer our Identification string to determine if we
+ *              will be the dominant master.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR scsendi(USHORT p_port, UCHAR p_id_string[])
+#else
+UCHAR scsendi(ULONG p_port, UCHAR p_id_string[])
+#endif
+{
+   UCHAR ret_data,byte_cnt,bit_cnt,defer;
+
+   defer = FALSE;
+
+   for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
+
+      for (bit_cnt = 0x80; bit_cnt != 0 ; bit_cnt >>= 1) {
+
+         if (defer)
+            ret_data = scxferc(p_port,00);
+
+         else if (p_id_string[byte_cnt] & bit_cnt)
+
+               ret_data = scxferc(p_port,02);
+
+            else {
+
+               ret_data = scxferc(p_port,01);
+               if (ret_data & 02)
+                  defer = TRUE;
+               }
+
+         if ((ret_data & 0x1C) == 0x10)
+            return(0x00);  /*End of isolation stage, we won! */
+
+         if (ret_data & 0x1C)
+            return(0xFF);
+
+         if ((defer) && (!(ret_data & 0x1F)))
+            return(0x01);  /*End of isolation stage, we lost. */
+
+         } /*bit loop */
+
+      } /*byte loop */
+
+   if (defer)
+      return(0x01);  /*We lost */
+   else
+      return(0);  /*We WON! Yeeessss! */
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: sciso
+ *
+ * Description: Transfer the Identification string.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR sciso(USHORT p_port, UCHAR p_id_string[])
+#else
+UCHAR sciso(ULONG p_port, UCHAR p_id_string[])
+#endif
+{
+   UCHAR ret_data,the_data,byte_cnt,bit_cnt;
+
+   the_data = 0;
+
+   for (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {
+
+      for (bit_cnt = 0; bit_cnt < 8; bit_cnt++) {
+
+         ret_data = scxferc(p_port,0);
+
+         if (ret_data & 0xFC)
+            return(0xFF);
+
+         else {
+
+            the_data <<= 1;
+            if (ret_data & BIT(1)) {
+               the_data |= 1;
+               }
+            }
+
+         if ((ret_data & 0x1F) == 0)
+	   {
+/*
+				if(bit_cnt != 0 || bit_cnt != 8)
+				{
+					byte_cnt = 0;
+					bit_cnt = 0;
+					scxferc(p_port, SYNC_PTRN);
+					scxferc(p_port, ASSIGN_ID);
+					continue;
+				}
+*/
+            if (byte_cnt)
+               return(0x00);
+            else
+               return(0xFF);
+	   }
+
+         } /*bit loop */
+
+      p_id_string[byte_cnt] = the_data;
+
+      } /*byte loop */
+
+   return(0);
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scwirod
+ *
+ * Description: Sample the SCSI data bus making sure the signal has been
+ *              deasserted for the correct number of consecutive samples.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scwirod(USHORT p_port, UCHAR p_data_bit)
+#else
+void scwirod(ULONG p_port, UCHAR p_data_bit)
+#endif
+{
+   UCHAR i;
+
+   i = 0;
+   while ( i < MAX_SCSI_TAR ) {
+
+      if (RD_HARPOON(p_port+hp_scsidata_0) & p_data_bit)
+
+         i = 0;
+
+      else
+
+         i++;
+
+      }
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scwiros
+ *
+ * Description: Sample the SCSI Signal lines making sure the signal has been
+ *              deasserted for the correct number of consecutive samples.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scwiros(USHORT p_port, UCHAR p_data_bit)
+#else
+void scwiros(ULONG p_port, UCHAR p_data_bit)
+#endif
+{
+   UCHAR i;
+
+   i = 0;
+   while ( i < MAX_SCSI_TAR ) {
+
+      if (RD_HARPOON(p_port+hp_scsisig) & p_data_bit)
+
+         i = 0;
+
+      else
+
+         i++;
+
+      }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scvalq
+ *
+ * Description: Make sure we received a valid data byte.
+ *
+ *---------------------------------------------------------------------*/
+
+UCHAR scvalq(UCHAR p_quintet)
+{
+   UCHAR count;
+
+   for (count=1; count < 0x08; count<<=1) {
+      if (!(p_quintet & count))
+         p_quintet -= 0x80;
+      }
+
+   if (p_quintet & 0x18)
+      return(FALSE);
+
+   else
+      return(TRUE);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scsell
+ *
+ * Description: Select the specified device ID using a selection timeout
+ *              less than 4ms.  If somebody responds then it is a legacy
+ *              drive and this ID must be marked as such.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+UCHAR scsell(USHORT p_port, UCHAR targ_id)
+#else
+UCHAR scsell(ULONG p_port, UCHAR targ_id)
+#endif
+{
+#if defined(DOS)
+   USHORT i;
+#else
+   ULONG i;
+#endif
+
+   WR_HARPOON(p_port+hp_page_ctrl,
+      (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
+
+   ARAM_ACCESS(p_port);
+
+   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) | SCAM_TIMER));
+   WR_HARPOON(p_port+hp_seltimeout,TO_4ms);
+
+
+   for (i = p_port+CMD_STRT; i < p_port+CMD_STRT+12; i+=2) {
+      WRW_HARPOON(i, (MPM_OP+ACOMMAND));
+      }
+   WRW_HARPOON(i, (BRH_OP+ALWAYS+    NP));
+
+   WRW_HARPOON((p_port+hp_intstat),
+	       (RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));
+
+   WR_HARPOON(p_port+hp_select_id, targ_id);
+
+   WR_HARPOON(p_port+hp_portctrl_0, SCSI_PORT);
+   WR_HARPOON(p_port+hp_autostart_3, (SELECT | CMD_ONLY_STRT));
+   WR_HARPOON(p_port+hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
+
+
+   while (!(RDW_HARPOON((p_port+hp_intstat)) &
+	    (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {}
+
+   if (RDW_HARPOON((p_port+hp_intstat)) & RESET)
+         Wait(p_port, TO_250ms);
+
+   DISABLE_AUTO(p_port);
+
+   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) & ~SCAM_TIMER));
+   WR_HARPOON(p_port+hp_seltimeout,TO_290ms);
+
+   SGRAM_ACCESS(p_port);
+
+   if (RDW_HARPOON((p_port+hp_intstat)) & (RESET | TIMEOUT) ) {
+
+      WRW_HARPOON((p_port+hp_intstat),
+		  (RESET | TIMEOUT | SEL | BUS_FREE | PHASE));
+
+      WR_HARPOON(p_port+hp_page_ctrl,
+         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+
+      return(FALSE);  /*No legacy device */
+      }
+
+   else {
+
+      while(!(RDW_HARPOON((p_port+hp_intstat)) & BUS_FREE)) {
+				if (RD_HARPOON(p_port+hp_scsisig) & SCSI_REQ)
+					{
+					WR_HARPOON(p_port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+      			ACCEPT_MSG(p_port);
+					}
+		}
+
+      WRW_HARPOON((p_port+hp_intstat), CLR_ALL_INT_1);
+
+      WR_HARPOON(p_port+hp_page_ctrl,
+         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+
+      return(TRUE);  /*Found one of them oldies! */
+      }
+}
+
+#if defined(DOS)
+/*---------------------------------------------------------------------
+ *
+ * Function: scsell for DOS
+ *
+ * Description: Select the specified device ID using a selection timeout
+ *              less than 2ms.  This was specially required to solve
+ *              the problem with Plextor 12X CD-ROM drive. This drive
+ *					 was responding the Selection at the end of 4ms and 
+ *					 hanging the system.
+ *
+ *---------------------------------------------------------------------*/
+
+UCHAR scsellDOS(USHORT p_port, UCHAR targ_id)
+{
+   USHORT i;
+
+   WR_HARPOON(p_port+hp_page_ctrl,
+      (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE));
+
+   ARAM_ACCESS(p_port);
+
+   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) | SCAM_TIMER));
+   WR_HARPOON(p_port+hp_seltimeout,TO_2ms);
+
+
+   for (i = p_port+CMD_STRT; i < p_port+CMD_STRT+12; i+=2) {
+      WRW_HARPOON(i, (MPM_OP+ACOMMAND));
+      }
+   WRW_HARPOON(i, (BRH_OP+ALWAYS+    NP));
+
+   WRW_HARPOON((p_port+hp_intstat),
+	       (RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));
+
+   WR_HARPOON(p_port+hp_select_id, targ_id);
+
+   WR_HARPOON(p_port+hp_portctrl_0, SCSI_PORT);
+   WR_HARPOON(p_port+hp_autostart_3, (SELECT | CMD_ONLY_STRT));
+   WR_HARPOON(p_port+hp_scsictrl_0, (SEL_TAR | ENA_RESEL));
+
+
+   while (!(RDW_HARPOON((p_port+hp_intstat)) &
+	    (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {}
+
+   if (RDW_HARPOON((p_port+hp_intstat)) & RESET)
+         Wait(p_port, TO_250ms);
+
+   DISABLE_AUTO(p_port);
+
+   WR_HARPOON(p_port+hp_addstat,(RD_HARPOON(p_port+hp_addstat) & ~SCAM_TIMER));
+   WR_HARPOON(p_port+hp_seltimeout,TO_290ms);
+
+   SGRAM_ACCESS(p_port);
+
+   if (RDW_HARPOON((p_port+hp_intstat)) & (RESET | TIMEOUT) ) {
+
+      WRW_HARPOON((p_port+hp_intstat),
+		  (RESET | TIMEOUT | SEL | BUS_FREE | PHASE));
+
+      WR_HARPOON(p_port+hp_page_ctrl,
+         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+
+      return(FALSE);  /*No legacy device */
+      }
+
+   else {
+
+      while(!(RDW_HARPOON((p_port+hp_intstat)) & BUS_FREE)) {
+				if (RD_HARPOON(p_port+hp_scsisig) & SCSI_REQ)
+					{
+					WR_HARPOON(p_port+hp_scsisig, (SCSI_ACK + S_ILL_PH));
+      			ACCEPT_MSG(p_port);
+					}
+		}
+
+      WRW_HARPOON((p_port+hp_intstat), CLR_ALL_INT_1);
+
+      WR_HARPOON(p_port+hp_page_ctrl,
+         (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE));
+
+      return(TRUE);  /*Found one of them oldies! */
+      }
+}
+#endif  /* DOS */
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scwtsel
+ *
+ * Description: Wait to be selected by another SCAM initiator.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scwtsel(USHORT p_port)
+#else
+void scwtsel(ULONG p_port)
+#endif
+{
+   while(!(RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL)) {}
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: inisci
+ *
+ * Description: Setup the data Structure with the info from the EEPROM.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void inisci(UCHAR p_card, USHORT p_port, UCHAR p_our_id)
+#else
+void inisci(UCHAR p_card, ULONG p_port, UCHAR p_our_id)
+#endif
+{
+   UCHAR i,k,max_id;
+   USHORT ee_data;
+	PNVRamInfo pCurrNvRam;
+
+	pCurrNvRam = BL_Card[p_card].pNvRamInfo;
+
+   if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
+      max_id = 0x08;
+
+   else
+      max_id = 0x10;
+
+	if(pCurrNvRam){
+		for(i = 0; i < max_id; i++){
+
+			for(k = 0; k < 4; k++)
+				scamInfo[i].id_string[k] = pCurrNvRam->niScamTbl[i][k];
+			for(k = 4; k < ID_STRING_LENGTH; k++)
+				scamInfo[i].id_string[k] = (UCHAR) 0x00;
+
+	      if(scamInfo[i].id_string[0] == 0x00)
+      	   scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
+	      else
+   	      scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
+
+		}
+	}else {
+	   for (i=0; i < max_id; i++)
+   	   {
+      	for (k=0; k < ID_STRING_LENGTH; k+=2)
+	         {
+   	      ee_data = utilEERead(p_port, (USHORT)((EE_SCAMBASE/2) +
+      	     (USHORT) (i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
+         	scamInfo[i].id_string[k] = (UCHAR) ee_data;
+	         ee_data >>= 8;
+   	      scamInfo[i].id_string[k+1] = (UCHAR) ee_data;
+      	   }
+
+	      if ((scamInfo[i].id_string[0] == 0x00) ||
+   	       (scamInfo[i].id_string[0] == 0xFF))
+
+      	   scamInfo[i].state = ID_UNUSED;  /*Default to unused ID. */
+
+	      else
+   	      scamInfo[i].state = ID_UNASSIGNED;  /*Default to unassigned ID. */
+
+      	}
+	}
+	for(k = 0; k < ID_STRING_LENGTH; k++)
+		scamInfo[p_our_id].id_string[k] = scamHAString[k];
+
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scmachid
+ *
+ * Description: Match the Device ID string with our values stored in
+ *              the EEPROM.
+ *
+ *---------------------------------------------------------------------*/
+
+UCHAR scmachid(UCHAR p_card, UCHAR p_id_string[])
+{
+
+   UCHAR i,k,match;
+
+
+   for (i=0; i < MAX_SCSI_TAR; i++) {
+
+#if !defined(SCAM_LEV_2)
+      if (scamInfo[i].state == ID_UNASSIGNED)
+         {
+#endif
+         match = TRUE;
+
+         for (k=0; k < ID_STRING_LENGTH; k++)
+            {
+            if (p_id_string[k] != scamInfo[i].id_string[k])
+               match = FALSE;
+            }
+
+         if (match)
+            {
+            scamInfo[i].state = ID_ASSIGNED;
+            return(i);
+            }
+
+#if !defined(SCAM_LEV_2)
+         }
+#endif
+
+      }
+
+
+
+   if (p_id_string[0] & BIT(5))
+      i = 8;
+   else
+      i = MAX_SCSI_TAR;
+
+   if (((p_id_string[0] & 0x06) == 0x02) || ((p_id_string[0] & 0x06) == 0x04))
+      match = p_id_string[1] & (UCHAR) 0x1F;
+   else
+      match = 7;
+
+   while (i > 0)
+      {
+      i--;
+
+      if (scamInfo[match].state == ID_UNUSED)
+         {
+         for (k=0; k < ID_STRING_LENGTH; k++)
+            {
+            scamInfo[match].id_string[k] = p_id_string[k];
+            }
+
+         scamInfo[match].state = ID_ASSIGNED;
+
+			if(BL_Card[p_card].pNvRamInfo == NULL)
+	         BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
+         return(match);
+
+         }
+
+
+      match--;
+
+      if (match == 0xFF)
+	{
+         if (p_id_string[0] & BIT(5))
+            match = 7;
+         else
+            match = MAX_SCSI_TAR-1;
+	}
+      }
+
+
+
+   if (p_id_string[0] & BIT(7))
+      {
+      return(CLR_PRIORITY);
+      }
+
+
+   if (p_id_string[0] & BIT(5))
+      i = 8;
+   else
+      i = MAX_SCSI_TAR;
+
+   if (((p_id_string[0] & 0x06) == 0x02) || ((p_id_string[0] & 0x06) == 0x04))
+      match = p_id_string[1] & (UCHAR) 0x1F;
+   else
+      match = 7;
+
+   while (i > 0)
+      {
+
+      i--;
+
+      if (scamInfo[match].state == ID_UNASSIGNED)
+         {
+         for (k=0; k < ID_STRING_LENGTH; k++)
+            {
+            scamInfo[match].id_string[k] = p_id_string[k];
+            }
+
+         scamInfo[match].id_string[0] |= BIT(7);
+         scamInfo[match].state = ID_ASSIGNED;
+			if(BL_Card[p_card].pNvRamInfo == NULL)
+	         BL_Card[p_card].globalFlags |= F_UPDATE_EEPROM;
+         return(match);
+
+         }
+
+
+      match--;
+
+      if (match == 0xFF)
+	{
+         if (p_id_string[0] & BIT(5))
+            match = 7;
+         else
+            match = MAX_SCSI_TAR-1;
+	}
+      }
+
+   return(NO_ID_AVAIL);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: scsavdi
+ *
+ * Description: Save off the device SCAM ID strings.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void scsavdi(UCHAR p_card, USHORT p_port)
+#else
+void scsavdi(UCHAR p_card, ULONG p_port)
+#endif
+{
+   UCHAR i,k,max_id;
+   USHORT ee_data,sum_data;
+
+
+   sum_data = 0x0000;
+
+   for (i = 1; i < EE_SCAMBASE/2; i++)
+      {
+      sum_data += utilEERead(p_port, i);
+      }
+
+
+   utilEEWriteOnOff(p_port,1);   /* Enable write access to the EEPROM */
+
+   if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
+      max_id = 0x08;
+
+   else
+      max_id = 0x10;
+
+   for (i=0; i < max_id; i++)
+      {
+
+      for (k=0; k < ID_STRING_LENGTH; k+=2)
+         {
+         ee_data = scamInfo[i].id_string[k+1];
+         ee_data <<= 8;
+         ee_data |= scamInfo[i].id_string[k];
+         sum_data += ee_data;
+         utilEEWrite(p_port, ee_data, (USHORT)((EE_SCAMBASE/2) +
+            (USHORT)(i*((USHORT)ID_STRING_LENGTH/2)) + (USHORT)(k/2)));
+         }
+      }
+
+
+   utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM/2);
+   utilEEWriteOnOff(p_port,0);   /* Turn off write access */
+}
+#ident "$Id: diagnose.c 1.10 1997/06/10 16:51:47 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   diagnose.c  $
+ *
+ *   Description:  Diagnostic funtions for testing the integrity of
+ *                 the HARPOON.
+ *
+ *   $Date: 1997/06/10 16:51:47 $
+ *
+ *   $Revision: 1.10 $
+ *
+ *----------------------------------------------------------------------*/
+
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <eeprom.h>*/
+/*#include <harpoon.h>*/
+
+/*---------------------------------------------------------------------
+ *
+ * Function: XbowInit
+ *
+ * Description: Setup the Xbow for normal operation.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void XbowInit(USHORT port, UCHAR ScamFlg)
+#else
+void XbowInit(ULONG port, UCHAR ScamFlg)
+#endif
+{
+UCHAR i;
+
+	i = RD_HARPOON(port+hp_page_ctrl);
+	WR_HARPOON(port+hp_page_ctrl, (UCHAR) (i | G_INT_DISABLE));
+
+   WR_HARPOON(port+hp_scsireset,0x00);
+   WR_HARPOON(port+hp_portctrl_1,HOST_MODE8);
+
+   WR_HARPOON(port+hp_scsireset,(DMA_RESET | HPSCSI_RESET | PROG_RESET | \
+				 FIFO_CLR));
+
+   WR_HARPOON(port+hp_scsireset,SCSI_INI);
+
+   WR_HARPOON(port+hp_clkctrl_0,CLKCTRL_DEFAULT);
+
+   WR_HARPOON(port+hp_scsisig,0x00);         /*  Clear any signals we might */
+   WR_HARPOON(port+hp_scsictrl_0,ENA_SCAM_SEL);
+
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+
+#if defined(SCAM_LEV_2)
+   default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
+		    BUS_FREE | XFER_CNT_0 | AUTO_INT;
+
+   if ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))
+		default_intena |= SCAM_SEL;
+
+#else
+   default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |
+		    BUS_FREE | XFER_CNT_0 | AUTO_INT;
+#endif
+   WRW_HARPOON((port+hp_intena), default_intena);
+
+   WR_HARPOON(port+hp_seltimeout,TO_290ms);
+
+   /* Turn on SCSI_MODE8 for narrow cards to fix the
+      strapping issue with the DUAL CHANNEL card */
+   if (RD_HARPOON(port+hp_page_ctrl) & NARROW_SCSI_CARD)
+      WR_HARPOON(port+hp_addstat,SCSI_MODE8);
+
+#if defined(NO_BIOS_OPTION)
+
+   WR_HARPOON(port+hp_synctarg_0,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_1,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_2,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_3,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_4,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_5,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_6,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_7,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_8,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_9,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_10,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_11,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_12,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_13,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_14,NARROW_SCSI);
+   WR_HARPOON(port+hp_synctarg_15,NARROW_SCSI);
+
+#endif
+	WR_HARPOON(port+hp_page_ctrl, i);
+
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: BusMasterInit
+ *
+ * Description: Initialize the BusMaster for normal operations.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void BusMasterInit(USHORT p_port)
+#else
+void BusMasterInit(ULONG p_port)
+#endif
+{
+
+
+   WR_HARPOON(p_port+hp_sys_ctrl, DRVR_RST);
+   WR_HARPOON(p_port+hp_sys_ctrl, 0x00);
+
+   WR_HARPOON(p_port+hp_host_blk_cnt, XFER_BLK64);
+
+
+   WR_HARPOON(p_port+hp_bm_ctrl, (BMCTRL_DEFAULT));
+
+   WR_HARPOON(p_port+hp_ee_ctrl, (SCSI_TERM_ENA_H));
+
+
+#if defined(NT)
+
+   WR_HARPOON(p_port+hp_pci_cmd_cfg, (RD_HARPOON(p_port+hp_pci_cmd_cfg)
+      & ~MEM_SPACE_ENA));
+
+#endif
+
+   RD_HARPOON(p_port+hp_int_status);        /*Clear interrupts. */
+   WR_HARPOON(p_port+hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));
+   WR_HARPOON(p_port+hp_page_ctrl, (RD_HARPOON(p_port+hp_page_ctrl) &
+      ~SCATTER_EN));
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: DiagXbow
+ *
+ * Description: Test Xbow integrity.  Non-zero return indicates an error.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+int DiagXbow(USHORT port)
+#else
+int DiagXbow(ULONG port)
+#endif
+{
+   unsigned char fifo_cnt,loop_cnt;
+
+   unsigned char fifodata[5];
+   fifodata[0] = 0x00;
+   fifodata[1] = 0xFF;
+   fifodata[2] = 0x55;
+   fifodata[3] = 0xAA;
+   fifodata[4] = 0x00;
+
+
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+   WRW_HARPOON((port+hp_intena), 0x0000);
+
+   WR_HARPOON(port+hp_seltimeout,TO_5ms);
+
+   WR_HARPOON(port+hp_portctrl_0,START_TO);
+
+
+   for(fifodata[4] = 0x01; fifodata[4] != (UCHAR) 0; fifodata[4] = fifodata[4] << 1) {
+
+      WR_HARPOON(port+hp_selfid_0,fifodata[4]);
+      WR_HARPOON(port+hp_selfid_1,fifodata[4]);
+
+      if ((RD_HARPOON(port+hp_selfid_0) != fifodata[4]) ||
+          (RD_HARPOON(port+hp_selfid_1) != fifodata[4]))
+         return(1);
+      }
+
+
+   for(loop_cnt = 0; loop_cnt < 4; loop_cnt++) {
+
+      WR_HARPOON(port+hp_portctrl_0,(HOST_PORT | HOST_WRT | START_TO));
+
+
+      for (fifo_cnt = 0; fifo_cnt < FIFO_LEN; fifo_cnt++) {
+
+         WR_HARPOON(port+hp_fifodata_0, fifodata[loop_cnt]);
+         }
+
+
+      if (!(RD_HARPOON(port+hp_xferstat) & FIFO_FULL))
+         return(1);
+
+
+      WR_HARPOON(port+hp_portctrl_0,(HOST_PORT | START_TO));
+
+      for (fifo_cnt = 0; fifo_cnt < FIFO_LEN; fifo_cnt++) {
+
+         if (RD_HARPOON(port+hp_fifodata_0) != fifodata[loop_cnt])
+            return(1);
+         }
+
+
+      if (!(RD_HARPOON(port+hp_xferstat) & FIFO_EMPTY))
+         return(1);
+      }
+
+
+   while(!(RDW_HARPOON((port+hp_intstat)) & TIMEOUT)) {}
+
+
+   WR_HARPOON(port+hp_seltimeout,TO_290ms);
+
+   WRW_HARPOON((port+hp_intstat), CLR_ALL_INT);
+
+   WRW_HARPOON((port+hp_intena), default_intena);
+
+   return(0);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: DiagBusMaster
+ *
+ * Description: Test BusMaster integrity.  Non-zero return indicates an
+ *              error.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+int DiagBusMaster(USHORT port)
+#else
+int DiagBusMaster(ULONG port)
+#endif
+{
+   UCHAR testdata;
+
+   for(testdata = (UCHAR) 1; testdata != (UCHAR)0; testdata = testdata << 1) {
+
+      WR_HARPOON(port+hp_xfer_cnt_lo,testdata);
+      WR_HARPOON(port+hp_xfer_cnt_mi,testdata);
+      WR_HARPOON(port+hp_xfer_cnt_hi,testdata);
+      WR_HARPOON(port+hp_host_addr_lo,testdata);
+      WR_HARPOON(port+hp_host_addr_lmi,testdata);
+      WR_HARPOON(port+hp_host_addr_hmi,testdata);
+      WR_HARPOON(port+hp_host_addr_hi,testdata);
+
+      if ((RD_HARPOON(port+hp_xfer_cnt_lo) != testdata)   ||
+          (RD_HARPOON(port+hp_xfer_cnt_mi) != testdata)   ||
+          (RD_HARPOON(port+hp_xfer_cnt_hi) != testdata)   ||
+          (RD_HARPOON(port+hp_host_addr_lo) != testdata)  ||
+          (RD_HARPOON(port+hp_host_addr_lmi) != testdata) ||
+          (RD_HARPOON(port+hp_host_addr_hmi) != testdata) ||
+          (RD_HARPOON(port+hp_host_addr_hi) != testdata))
+
+         return(1);
+      }
+   RD_HARPOON(port+hp_int_status);        /*Clear interrupts. */
+   return(0);
+}
+
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: DiagEEPROM
+ *
+ * Description: Verfiy checksum and 'Key' and initialize the EEPROM if
+ *              necessary.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void DiagEEPROM(USHORT p_port)
+#else
+void DiagEEPROM(ULONG p_port)
+#endif
+
+{
+   USHORT index,temp,max_wd_cnt;
+
+   if (RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD)
+      max_wd_cnt = EEPROM_WD_CNT;
+   else
+      max_wd_cnt = EEPROM_WD_CNT * 2;
+
+   temp = utilEERead(p_port, FW_SIGNATURE/2);
+
+   if (temp == 0x4641) {
+
+      for (index = 2; index < max_wd_cnt; index++) {
+
+         temp += utilEERead(p_port, index);
+
+         }
+
+      if (temp == utilEERead(p_port, EEPROM_CHECK_SUM/2)) {
+
+         return;          /*EEPROM is Okay so return now! */
+         }
+      }
+
+
+   utilEEWriteOnOff(p_port,(UCHAR)1);
+
+   for (index = 0; index < max_wd_cnt; index++) {
+
+      utilEEWrite(p_port, 0x0000, index);
+      }
+
+   temp = 0;
+
+   utilEEWrite(p_port, 0x4641, FW_SIGNATURE/2);
+   temp += 0x4641;
+   utilEEWrite(p_port, 0x3920, MODEL_NUMB_0/2);
+   temp += 0x3920;
+   utilEEWrite(p_port, 0x3033, MODEL_NUMB_2/2);
+   temp += 0x3033;
+   utilEEWrite(p_port, 0x2020, MODEL_NUMB_4/2);
+   temp += 0x2020;
+   utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG/2);
+   temp += 0x70D3;
+   utilEEWrite(p_port, 0x0010, BIOS_CONFIG/2);
+   temp += 0x0010;
+   utilEEWrite(p_port, 0x0003, SCAM_CONFIG/2);
+   temp += 0x0003;
+   utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID/2);
+   temp += 0x0007;
+
+   utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN/2);
+   temp += 0x0000;
+   utilEEWrite(p_port, 0x0000, SEND_START_ENA/2);
+   temp += 0x0000;
+   utilEEWrite(p_port, 0x0000, DEVICE_ENABLE/2);
+   temp += 0x0000;
+
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd/2);
+   temp += 0x4242;
+   utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef/2);
+   temp += 0x4242;
+
+
+   utilEEWrite(p_port, 0x6C46, 64/2);  /*PRODUCT ID */
+   temp += 0x6C46;
+   utilEEWrite(p_port, 0x7361, 66/2);  /* FlashPoint LT   */
+   temp += 0x7361;
+   utilEEWrite(p_port, 0x5068, 68/2);
+   temp += 0x5068;
+   utilEEWrite(p_port, 0x696F, 70/2);
+   temp += 0x696F;
+   utilEEWrite(p_port, 0x746E, 72/2);
+   temp += 0x746E;
+   utilEEWrite(p_port, 0x4C20, 74/2);
+   temp += 0x4C20;
+   utilEEWrite(p_port, 0x2054, 76/2);
+   temp += 0x2054;
+   utilEEWrite(p_port, 0x2020, 78/2);
+   temp += 0x2020;
+
+   index = ((EE_SCAMBASE/2)+(7*16));
+   utilEEWrite(p_port, (0x0700+TYPE_CODE0), index);
+   temp += (0x0700+TYPE_CODE0);
+   index++;
+   utilEEWrite(p_port, 0x5542, index);            /*Vendor ID code */
+   temp += 0x5542;                                /* BUSLOGIC      */
+   index++;
+   utilEEWrite(p_port, 0x4C53, index);
+   temp += 0x4C53;
+   index++;
+   utilEEWrite(p_port, 0x474F, index);
+   temp += 0x474F;
+   index++;
+   utilEEWrite(p_port, 0x4349, index);
+   temp += 0x4349;
+   index++;
+   utilEEWrite(p_port, 0x5442, index);            /*Vendor unique code */
+   temp += 0x5442;                         /* BT- 930           */
+   index++;
+   utilEEWrite(p_port, 0x202D, index);
+   temp += 0x202D;
+   index++;
+   utilEEWrite(p_port, 0x3339, index);
+   temp += 0x3339;
+   index++;                                 /*Serial #          */
+   utilEEWrite(p_port, 0x2030, index);             /* 01234567         */
+   temp += 0x2030;
+   index++;
+   utilEEWrite(p_port, 0x5453, index);
+   temp += 0x5453;
+   index++;
+   utilEEWrite(p_port, 0x5645, index);
+   temp += 0x5645;
+   index++;
+   utilEEWrite(p_port, 0x2045, index);
+   temp += 0x2045;
+   index++;
+   utilEEWrite(p_port, 0x202F, index);
+   temp += 0x202F;
+   index++;
+   utilEEWrite(p_port, 0x4F4A, index);
+   temp += 0x4F4A;
+   index++;
+   utilEEWrite(p_port, 0x204E, index);
+   temp += 0x204E;
+   index++;
+   utilEEWrite(p_port, 0x3539, index);
+   temp += 0x3539;
+
+
+
+   utilEEWrite(p_port, temp, EEPROM_CHECK_SUM/2);
+
+   utilEEWriteOnOff(p_port,(UCHAR)0);
+
+}
+
+#ident "$Id: utility.c 1.23 1997/06/10 16:55:06 mohan Exp $"
+/*----------------------------------------------------------------------
+ *
+ *
+ *   Copyright 1995-1996 by Mylex Corporation.  All Rights Reserved
+ *
+ *   This file is available under both the GNU General Public License
+ *   and a BSD-style copyright; see LICENSE.FlashPoint for details.
+ *
+ *   $Workfile:   utility.c  $
+ *
+ *   Description:  Utility functions relating to queueing and EEPROM
+ *                 manipulation and any other garbage functions.
+ *
+ *   $Date: 1997/06/10 16:55:06 $
+ *
+ *   $Revision: 1.23 $
+ *
+ *----------------------------------------------------------------------*/
+/*#include <globals.h>*/
+
+#if (FW_TYPE==_UCB_MGR_)
+	/*#include <budi.h>*/
+#endif
+
+/*#include <sccbmgr.h>*/
+/*#include <blx30.h>*/
+/*#include <target.h>*/
+/*#include <scsi2.h>*/
+/*#include <harpoon.h>*/
+
+
+/*
+extern SCCBCARD BL_Card[MAX_CARDS];
+extern SCCBMGR_TAR_INFO sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR];
+extern unsigned int SccbGlobalFlags;
+*/
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Search Select
+ *
+ * Description: Try to find a new command to execute.
+ *
+ *---------------------------------------------------------------------*/
+
+void queueSearchSelect(PSCCBcard pCurrCard, UCHAR p_card)
+{
+   UCHAR scan_ptr, lun;
+   PSCCBMgr_tar_info currTar_Info;
+	PSCCB pOldSccb;
+
+   scan_ptr = pCurrCard->scanIndex;
+	do 
+	{
+		currTar_Info = &sccbMgrTbl[p_card][scan_ptr];
+		if((pCurrCard->globalFlags & F_CONLUN_IO) && 
+			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))
+		{
+			if (currTar_Info->TarSelQ_Cnt != 0)
+			{
+
+				scan_ptr++;
+				if (scan_ptr == MAX_SCSI_TAR)
+					scan_ptr = 0;
+				
+				for(lun=0; lun < MAX_LUN; lun++)
+				{
+					if(currTar_Info->TarLUNBusy[lun] == FALSE)
+					{
+
+						pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
+						pOldSccb = NULL;
+
+						while((pCurrCard->currentSCCB != NULL) &&
+								 (lun != pCurrCard->currentSCCB->Lun))
+						{
+							pOldSccb = pCurrCard->currentSCCB;
+							pCurrCard->currentSCCB = (PSCCB)(pCurrCard->currentSCCB)->
+																	Sccb_forwardlink;
+						}
+						if(pCurrCard->currentSCCB == NULL)
+							continue;
+						if(pOldSccb != NULL)
+						{
+							pOldSccb->Sccb_forwardlink = (PSCCB)(pCurrCard->currentSCCB)->
+																	Sccb_forwardlink;
+							pOldSccb->Sccb_backlink = (PSCCB)(pCurrCard->currentSCCB)->
+																	Sccb_backlink;
+							currTar_Info->TarSelQ_Cnt--;
+						}
+						else
+						{
+							currTar_Info->TarSelQ_Head = (PSCCB)(pCurrCard->currentSCCB)->Sccb_forwardlink;
+					
+							if (currTar_Info->TarSelQ_Head == NULL)
+							{
+								currTar_Info->TarSelQ_Tail = NULL;
+								currTar_Info->TarSelQ_Cnt = 0;
+							}
+							else
+							{
+								currTar_Info->TarSelQ_Cnt--;
+								currTar_Info->TarSelQ_Head->Sccb_backlink = (PSCCB)NULL;
+							}
+						}
+					pCurrCard->scanIndex = scan_ptr;
+
+					pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
+
+					break;
+					}
+				}
+			}
+
+			else 
+			{
+				scan_ptr++;
+				if (scan_ptr == MAX_SCSI_TAR) {
+					scan_ptr = 0;
+				}
+			}
+
+		}
+		else
+		{
+			if ((currTar_Info->TarSelQ_Cnt != 0) &&
+				(currTar_Info->TarLUNBusy[0] == FALSE))
+			{
+
+				pCurrCard->currentSCCB = currTar_Info->TarSelQ_Head;
+
+				currTar_Info->TarSelQ_Head = (PSCCB)(pCurrCard->currentSCCB)->Sccb_forwardlink;
+
+				if (currTar_Info->TarSelQ_Head == NULL)
+				{
+					currTar_Info->TarSelQ_Tail = NULL;
+					currTar_Info->TarSelQ_Cnt = 0;
+				}
+				else
+				{
+					currTar_Info->TarSelQ_Cnt--;
+					currTar_Info->TarSelQ_Head->Sccb_backlink = (PSCCB)NULL;
+				}
+
+				scan_ptr++;
+				if (scan_ptr == MAX_SCSI_TAR)
+					scan_ptr = 0;
+
+				pCurrCard->scanIndex = scan_ptr;
+
+				pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
+
+				break;
+			}
+
+			else 
+			{
+				scan_ptr++;
+				if (scan_ptr == MAX_SCSI_TAR) 
+				{
+					scan_ptr = 0;
+				}
+			}
+		}
+	} while (scan_ptr != pCurrCard->scanIndex);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Select Fail
+ *
+ * Description: Add the current SCCB to the head of the Queue.
+ *
+ *---------------------------------------------------------------------*/
+
+void queueSelectFail(PSCCBcard pCurrCard, UCHAR p_card)
+{
+   UCHAR thisTarg;
+   PSCCBMgr_tar_info currTar_Info;
+
+   if (pCurrCard->currentSCCB != NULL)
+	  {
+	  thisTarg = (UCHAR)(((PSCCB)(pCurrCard->currentSCCB))->TargID);
+      currTar_Info = &sccbMgrTbl[p_card][thisTarg];
+
+      pCurrCard->currentSCCB->Sccb_backlink = (PSCCB)NULL;
+
+      pCurrCard->currentSCCB->Sccb_forwardlink = currTar_Info->TarSelQ_Head;
+
+	  if (currTar_Info->TarSelQ_Cnt == 0)
+		 {
+		 currTar_Info->TarSelQ_Tail = pCurrCard->currentSCCB;
+		 }
+
+	  else
+		 {
+		 currTar_Info->TarSelQ_Head->Sccb_backlink = pCurrCard->currentSCCB;
+		 }
+
+
+	  currTar_Info->TarSelQ_Head = pCurrCard->currentSCCB;
+
+	  pCurrCard->currentSCCB = NULL;
+	  currTar_Info->TarSelQ_Cnt++;
+	  }
+}
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Command Complete
+ *
+ * Description: Call the callback function with the current SCCB.
+ *
+ *---------------------------------------------------------------------*/
+
+void queueCmdComplete(PSCCBcard pCurrCard, PSCCB p_sccb, UCHAR p_card)
+{
+
+#if (FW_TYPE==_UCB_MGR_)
+
+   u08bits SCSIcmd;
+   CALL_BK_FN callback;
+   PSCCBMgr_tar_info currTar_Info;
+
+   PUCB p_ucb;
+   p_ucb=p_sccb->Sccb_ucb_ptr;
+
+   SCSIcmd = p_sccb->Cdb[0];
+
+
+   if (!(p_sccb->Sccb_XferState & F_ALL_XFERRED))
+   {
+
+      if ((p_ucb->UCB_opcode & OPC_CHK_UNDER_OVER_RUN)                     &&
+         (p_sccb->HostStatus == SCCB_COMPLETE)                             &&
+         (p_sccb->TargetStatus != SSCHECK))
+
+         if ((SCSIcmd == SCSI_READ)             ||
+             (SCSIcmd == SCSI_WRITE)            ||
+             (SCSIcmd == SCSI_READ_EXTENDED)    ||
+             (SCSIcmd == SCSI_WRITE_EXTENDED)   ||
+             (SCSIcmd == SCSI_WRITE_AND_VERIFY) ||
+             (SCSIcmd == SCSI_START_STOP_UNIT)  ||
+             (pCurrCard->globalFlags & F_NO_FILTER)
+            )
+               p_sccb->HostStatus = SCCB_DATA_UNDER_RUN;
+   }
+
+   p_ucb->UCB_status=SCCB_SUCCESS;
+
+   if ((p_ucb->UCB_hbastat=p_sccb->HostStatus) || (p_ucb->UCB_scsistat=p_sccb->TargetStatus))
+   {
+      p_ucb->UCB_status=SCCB_ERROR;
+   }
+
+   if ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||
+      (p_sccb->OperationCode == RESIDUAL_COMMAND))
+   {
+
+         utilUpdateResidual(p_sccb);
+
+         p_ucb->UCB_datalen=p_sccb->DataLength;
+   }
+
+   pCurrCard->cmdCounter--;
+   if (!pCurrCard->cmdCounter)
+   {
+
+      if (pCurrCard->globalFlags & F_GREEN_PC)
+      {
+         WR_HARPOON(pCurrCard->ioPort+hp_clkctrl_0,(PWR_DWN | CLKCTRL_DEFAULT));
+         WR_HARPOON(pCurrCard->ioPort+hp_sys_ctrl, STOP_CLK);
+      }
+
+      WR_HARPOON(pCurrCard->ioPort+hp_semaphore,
+      (RD_HARPOON(pCurrCard->ioPort+hp_semaphore) & ~SCCB_MGR_ACTIVE));
+   }
+
+	if(pCurrCard->discQCount != 0)
+	{
+      currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
+			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+		{
+			pCurrCard->discQCount--;
+			pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = NULL;
+		}
+		else
+		{
+			if(p_sccb->Sccb_tag)
+			{
+				pCurrCard->discQCount--;
+				pCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;
+			}else
+			{
+				pCurrCard->discQCount--;
+				pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = NULL;
+			}
+		}
+
+	}
+   callback = (CALL_BK_FN)p_ucb->UCB_callback;
+   callback(p_ucb);
+   pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
+   pCurrCard->currentSCCB = NULL;
+}
+
+
+
+
+#else
+
+   UCHAR i, SCSIcmd;
+   CALL_BK_FN callback;
+   PSCCBMgr_tar_info currTar_Info;
+
+   SCSIcmd = p_sccb->Cdb[0];
+
+
+   if (!(p_sccb->Sccb_XferState & F_ALL_XFERRED)) {
+
+	  if ((p_sccb->ControlByte & (SCCB_DATA_XFER_OUT | SCCB_DATA_XFER_IN)) &&
+		 (p_sccb->HostStatus == SCCB_COMPLETE)                             &&
+		 (p_sccb->TargetStatus != SSCHECK))
+
+		 if ((SCSIcmd == SCSI_READ)             ||
+			 (SCSIcmd == SCSI_WRITE)            ||
+			 (SCSIcmd == SCSI_READ_EXTENDED)    ||
+			 (SCSIcmd == SCSI_WRITE_EXTENDED)   ||
+			 (SCSIcmd == SCSI_WRITE_AND_VERIFY) ||
+			 (SCSIcmd == SCSI_START_STOP_UNIT)  ||
+			 (pCurrCard->globalFlags & F_NO_FILTER)
+			)
+			   p_sccb->HostStatus = SCCB_DATA_UNDER_RUN;
+	  }
+
+
+	if(p_sccb->SccbStatus == SCCB_IN_PROCESS)
+	{
+	   if (p_sccb->HostStatus || p_sccb->TargetStatus)
+		  p_sccb->SccbStatus = SCCB_ERROR;
+	   else
+		  p_sccb->SccbStatus = SCCB_SUCCESS;
+	}
+
+   if (p_sccb->Sccb_XferState & F_AUTO_SENSE) {
+
+	  p_sccb->CdbLength = p_sccb->Save_CdbLen;
+	  for (i=0; i < 6; i++) {
+		 p_sccb->Cdb[i] = p_sccb->Save_Cdb[i];
+		 }
+	  }
+
+   if ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||
+	  (p_sccb->OperationCode == RESIDUAL_COMMAND)) {
+
+		 utilUpdateResidual(p_sccb);
+		 }
+
+   pCurrCard->cmdCounter--;
+   if (!pCurrCard->cmdCounter) {
+
+	  if (pCurrCard->globalFlags & F_GREEN_PC) {
+		 WR_HARPOON(pCurrCard->ioPort+hp_clkctrl_0,(PWR_DWN | CLKCTRL_DEFAULT));
+		 WR_HARPOON(pCurrCard->ioPort+hp_sys_ctrl, STOP_CLK);
+		 }
+
+	  WR_HARPOON(pCurrCard->ioPort+hp_semaphore,
+	  (RD_HARPOON(pCurrCard->ioPort+hp_semaphore) & ~SCCB_MGR_ACTIVE));
+
+	  }
+
+	if(pCurrCard->discQCount != 0)
+	{
+      currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+		if(((pCurrCard->globalFlags & F_CONLUN_IO) &&
+			((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+		{
+			pCurrCard->discQCount--;
+			pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = NULL;
+		}
+		else
+		{
+			if(p_sccb->Sccb_tag)
+			{
+				pCurrCard->discQCount--;
+				pCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;
+			}else
+			{
+				pCurrCard->discQCount--;
+				pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = NULL;
+			}
+		}
+
+	}
+
+	callback = (CALL_BK_FN)p_sccb->SccbCallback;
+   callback(p_sccb);
+   pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
+   pCurrCard->currentSCCB = NULL;
+}
+#endif /* ( if FW_TYPE==...) */
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Disconnect
+ *
+ * Description: Add SCCB to our disconnect array.
+ *
+ *---------------------------------------------------------------------*/
+void queueDisconnect(PSCCB p_sccb, UCHAR p_card)
+{
+   PSCCBMgr_tar_info currTar_Info;
+
+	currTar_Info = &sccbMgrTbl[p_card][p_sccb->TargID];
+
+	if(((BL_Card[p_card].globalFlags & F_CONLUN_IO) &&
+		((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))
+	{
+		BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[p_sccb->Lun]] = p_sccb;
+	}
+	else
+	{
+		if (p_sccb->Sccb_tag)
+		{
+			BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] = p_sccb;
+			sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] = FALSE;
+			sccbMgrTbl[p_card][p_sccb->TargID].TarTagQ_Cnt++;
+		}else
+		{
+			BL_Card[p_card].discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]] = p_sccb;
+		}
+	}
+	BL_Card[p_card].currentSCCB = NULL;
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Flush SCCB
+ *
+ * Description: Flush all SCCB's back to the host driver for this target.
+ *
+ *---------------------------------------------------------------------*/
+
+void  queueFlushSccb(UCHAR p_card, UCHAR error_code)
+{
+   UCHAR qtag,thisTarg;
+   PSCCB currSCCB;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currSCCB = BL_Card[p_card].currentSCCB;
+	if(currSCCB != NULL)
+	{
+	   thisTarg = (UCHAR)currSCCB->TargID;
+   	currTar_Info = &sccbMgrTbl[p_card][thisTarg];
+
+	   for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
+
+		  if (BL_Card[p_card].discQ_Tbl[qtag] && 
+					(BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
+			 {
+
+			 BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
+			
+			 queueCmdComplete(&BL_Card[p_card],BL_Card[p_card].discQ_Tbl[qtag], p_card);
+
+			 BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+			 currTar_Info->TarTagQ_Cnt--;
+
+			 }
+		  }
+	}
+
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Flush Target SCCB
+ *
+ * Description: Flush all SCCB's back to the host driver for this target.
+ *
+ *---------------------------------------------------------------------*/
+
+void  queueFlushTargSccb(UCHAR p_card, UCHAR thisTarg, UCHAR error_code)
+{
+   UCHAR qtag;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currTar_Info = &sccbMgrTbl[p_card][thisTarg];
+
+   for (qtag=0; qtag<QUEUE_DEPTH; qtag++) {
+
+	  if (BL_Card[p_card].discQ_Tbl[qtag] && 
+				(BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg))
+		 {
+
+		 BL_Card[p_card].discQ_Tbl[qtag]->HostStatus = (UCHAR)error_code;
+
+		 queueCmdComplete(&BL_Card[p_card],BL_Card[p_card].discQ_Tbl[qtag], p_card);
+
+		 BL_Card[p_card].discQ_Tbl[qtag] = NULL;
+		 currTar_Info->TarTagQ_Cnt--;
+
+		 }
+	  }
+
+}
+
+
+
+
+
+void queueAddSccb(PSCCB p_SCCB, UCHAR p_card)
+{
+   PSCCBMgr_tar_info currTar_Info;
+   currTar_Info = &sccbMgrTbl[p_card][p_SCCB->TargID];
+
+   p_SCCB->Sccb_forwardlink = NULL;
+
+   p_SCCB->Sccb_backlink = currTar_Info->TarSelQ_Tail;
+
+   if (currTar_Info->TarSelQ_Cnt == 0) {
+
+	  currTar_Info->TarSelQ_Head = p_SCCB;
+	  }
+
+   else {
+
+	  currTar_Info->TarSelQ_Tail->Sccb_forwardlink = p_SCCB;
+	  }
+
+
+   currTar_Info->TarSelQ_Tail = p_SCCB;
+   currTar_Info->TarSelQ_Cnt++;
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Queue Find SCCB
+ *
+ * Description: Search the target select Queue for this SCCB, and
+ *              remove it if found.
+ *
+ *---------------------------------------------------------------------*/
+
+UCHAR queueFindSccb(PSCCB p_SCCB, UCHAR p_card)
+{
+   PSCCB q_ptr;
+   PSCCBMgr_tar_info currTar_Info;
+
+   currTar_Info = &sccbMgrTbl[p_card][p_SCCB->TargID];
+
+   q_ptr = currTar_Info->TarSelQ_Head;
+
+   while(q_ptr != NULL) {
+
+	  if (q_ptr == p_SCCB) {
+
+
+		 if (currTar_Info->TarSelQ_Head == q_ptr) {
+
+			currTar_Info->TarSelQ_Head = q_ptr->Sccb_forwardlink;
+			}
+
+		 if (currTar_Info->TarSelQ_Tail == q_ptr) {
+
+			currTar_Info->TarSelQ_Tail = q_ptr->Sccb_backlink;
+			}
+
+		 if (q_ptr->Sccb_forwardlink != NULL) {
+			q_ptr->Sccb_forwardlink->Sccb_backlink = q_ptr->Sccb_backlink;
+			}
+
+		 if (q_ptr->Sccb_backlink != NULL) {
+			q_ptr->Sccb_backlink->Sccb_forwardlink = q_ptr->Sccb_forwardlink;
+			}
+
+		 currTar_Info->TarSelQ_Cnt--;
+
+		 return(TRUE);
+		 }
+
+	  else {
+		 q_ptr = q_ptr->Sccb_forwardlink;
+		 }
+	  }
+
+
+   return(FALSE);
+
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Utility Update Residual Count
+ *
+ * Description: Update the XferCnt to the remaining byte count.
+ *              If we transferred all the data then just write zero.
+ *              If Non-SG transfer then report Total Cnt - Actual Transfer
+ *              Cnt.  For SG transfers add the count fields of all
+ *              remaining SG elements, as well as any partial remaining
+ *              element.
+ *
+ *---------------------------------------------------------------------*/
+
+void  utilUpdateResidual(PSCCB p_SCCB)
+{
+   ULONG partial_cnt;
+   UINT  sg_index;
+#if defined(COMPILER_16_BIT) && !defined(DOS)
+   ULONG far *sg_ptr;
+#else
+   ULONG *sg_ptr;
+#endif
+
+   if (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {
+
+	  p_SCCB->DataLength = 0x0000;
+	  }
+
+   else if (p_SCCB->Sccb_XferState & F_SG_XFER) {
+
+		 partial_cnt = 0x0000;
+
+		 sg_index = p_SCCB->Sccb_sgseg;
+
+#if defined(COMPILER_16_BIT) && !defined(DOS)
+		 sg_ptr = (ULONG far *)p_SCCB->DataPointer;
+#else
+		 sg_ptr = (ULONG *)p_SCCB->DataPointer;
+#endif
+
+		 if (p_SCCB->Sccb_SGoffset) {
+
+			partial_cnt = p_SCCB->Sccb_SGoffset;
+			sg_index++;
+			}
+
+		 while ( ((ULONG)sg_index * (ULONG)SG_ELEMENT_SIZE) <
+			p_SCCB->DataLength ) {
+
+			partial_cnt += *(sg_ptr+(sg_index * 2));
+			sg_index++;
+			}
+
+		 p_SCCB->DataLength = partial_cnt;
+		 }
+
+	  else {
+
+		 p_SCCB->DataLength -= p_SCCB->Sccb_ATC;
+		 }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Wait 1 Second
+ *
+ * Description: Wait for 1 second.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void Wait1Second(USHORT p_port)
+#else
+void Wait1Second(ULONG p_port)
+#endif
+{
+   UCHAR i;
+
+   for(i=0; i < 4; i++) {
+
+	  Wait(p_port, TO_250ms);
+
+	  if ((RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST))
+		 break;
+
+	  if((RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL))
+		 break;
+	  }
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Wait
+ *
+ * Description: Wait the desired delay.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void Wait(USHORT p_port, UCHAR p_delay)
+#else
+void Wait(ULONG p_port, UCHAR p_delay)
+#endif
+{
+   UCHAR old_timer;
+   UCHAR green_flag;
+
+   old_timer = RD_HARPOON(p_port+hp_seltimeout);
+
+   green_flag=RD_HARPOON(p_port+hp_clkctrl_0);
+   WR_HARPOON(p_port+hp_clkctrl_0, CLKCTRL_DEFAULT);
+
+   WR_HARPOON(p_port+hp_seltimeout,p_delay);
+   WRW_HARPOON((p_port+hp_intstat), TIMEOUT);
+   WRW_HARPOON((p_port+hp_intena), (default_intena & ~TIMEOUT));
+
+
+   WR_HARPOON(p_port+hp_portctrl_0,
+	  (RD_HARPOON(p_port+hp_portctrl_0) | START_TO));
+
+   while (!(RDW_HARPOON((p_port+hp_intstat)) & TIMEOUT)) {
+
+	  if ((RD_HARPOON(p_port+hp_scsictrl_0) & SCSI_RST))
+		 break;
+
+	  if ((RDW_HARPOON((p_port+hp_intstat)) & SCAM_SEL))
+		 break;
+	  }
+
+   WR_HARPOON(p_port+hp_portctrl_0,
+	  (RD_HARPOON(p_port+hp_portctrl_0) & ~START_TO));
+
+   WRW_HARPOON((p_port+hp_intstat), TIMEOUT);
+   WRW_HARPOON((p_port+hp_intena), default_intena);
+
+   WR_HARPOON(p_port+hp_clkctrl_0,green_flag);
+
+   WR_HARPOON(p_port+hp_seltimeout,old_timer);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Enable/Disable Write to EEPROM
+ *
+ * Description: The EEPROM must first be enabled for writes
+ *              A total of 9 clocks are needed.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void utilEEWriteOnOff(USHORT p_port,UCHAR p_mode)
+#else
+void utilEEWriteOnOff(ULONG p_port,UCHAR p_mode)
+#endif
+{
+   UCHAR ee_value;
+
+   ee_value = (UCHAR)(RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H));
+
+   if (p_mode)
+
+	  utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);
+
+   else
+
+
+	  utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);
+
+   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS)); /*Turn off CS */
+   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);       /*Turn off Master Select */
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Write EEPROM
+ *
+ * Description: Write a word to the EEPROM at the specified
+ *              address.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void utilEEWrite(USHORT p_port, USHORT ee_data, USHORT ee_addr)
+#else
+void utilEEWrite(ULONG p_port, USHORT ee_data, USHORT ee_addr)
+#endif
+{
+
+   UCHAR ee_value;
+   USHORT i;
+
+   ee_value = (UCHAR)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
+		   (SEE_MS | SEE_CS));
+
+
+
+   utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);
+
+
+   ee_value |= (SEE_MS + SEE_CS);
+
+   for(i = 0x8000; i != 0; i>>=1) {
+
+	  if (i & ee_data)
+	 ee_value |= SEE_DO;
+	  else
+	 ee_value &= ~SEE_DO;
+
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value |= SEE_CLK;          /* Clock  data! */
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value &= ~SEE_CLK;
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  }
+   ee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);
+   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS));
+
+   Wait(p_port, TO_10ms);
+
+   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS | SEE_CS)); /* Set CS to EEPROM */
+   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS));       /* Turn off CS */
+   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);       /* Turn off Master Select */
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Read EEPROM
+ *
+ * Description: Read a word from the EEPROM at the desired
+ *              address.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+USHORT utilEERead(USHORT p_port, USHORT ee_addr)
+#else
+USHORT utilEERead(ULONG p_port, USHORT ee_addr)
+#endif
+{
+   USHORT i, ee_data1, ee_data2;
+
+	i = 0;
+	ee_data1 = utilEEReadOrg(p_port, ee_addr);
+	do
+	{
+		ee_data2 = utilEEReadOrg(p_port, ee_addr);
+
+		if(ee_data1 == ee_data2)
+			return(ee_data1);
+
+		ee_data1 = ee_data2;
+		i++;
+
+	}while(i < 4);
+
+	return(ee_data1);
+}
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Read EEPROM Original 
+ *
+ * Description: Read a word from the EEPROM at the desired
+ *              address.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+USHORT utilEEReadOrg(USHORT p_port, USHORT ee_addr)
+#else
+USHORT utilEEReadOrg(ULONG p_port, USHORT ee_addr)
+#endif
+{
+
+   UCHAR ee_value;
+   USHORT i, ee_data;
+
+   ee_value = (UCHAR)((RD_HARPOON(p_port+hp_ee_ctrl) & (EXT_ARB_ACK | SCSI_TERM_ENA_H))|
+		   (SEE_MS | SEE_CS));
+
+
+   utilEESendCmdAddr(p_port, EE_READ, ee_addr);
+
+
+   ee_value |= (SEE_MS + SEE_CS);
+   ee_data = 0;
+
+   for(i = 1; i <= 16; i++) {
+
+	  ee_value |= SEE_CLK;          /* Clock  data! */
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value &= ~SEE_CLK;
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+
+	  ee_data <<= 1;
+
+	  if (RD_HARPOON(p_port+hp_ee_ctrl) & SEE_DI)
+		 ee_data |= 1;
+	  }
+
+   ee_value &= ~(SEE_MS + SEE_CS);
+   WR_HARPOON(p_port+hp_ee_ctrl, (ee_value | SEE_MS)); /*Turn off CS */
+   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);   /*Turn off Master Select */
+
+   return(ee_data);
+}
+
+
+/*---------------------------------------------------------------------
+ *
+ * Function: Send EE command and Address to the EEPROM
+ *
+ * Description: Transfers the correct command and sends the address
+ *              to the eeprom.
+ *
+ *---------------------------------------------------------------------*/
+
+#if defined(DOS)
+void utilEESendCmdAddr(USHORT p_port, UCHAR ee_cmd, USHORT ee_addr)
+#else
+void utilEESendCmdAddr(ULONG p_port, UCHAR ee_cmd, USHORT ee_addr)
+#endif
+{
+   UCHAR ee_value;
+   UCHAR narrow_flg;
+
+   USHORT i;
+
+
+   narrow_flg= (UCHAR)(RD_HARPOON(p_port+hp_page_ctrl) & NARROW_SCSI_CARD);
+
+
+   ee_value = SEE_MS;
+   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+
+   ee_value |= SEE_CS;                             /* Set CS to EEPROM */
+   WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+
+
+   for(i = 0x04; i != 0; i>>=1) {
+
+	  if (i & ee_cmd)
+		 ee_value |= SEE_DO;
+	  else
+		 ee_value &= ~SEE_DO;
+
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value |= SEE_CLK;                         /* Clock  data! */
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value &= ~SEE_CLK;
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  }
+
+
+   if (narrow_flg)
+	  i = 0x0080;
+
+   else
+	  i = 0x0200;
+
+
+   while (i != 0) {
+
+	  if (i & ee_addr)
+		 ee_value |= SEE_DO;
+	  else
+		 ee_value &= ~SEE_DO;
+
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value |= SEE_CLK;                         /* Clock  data! */
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  ee_value &= ~SEE_CLK;
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+	  WR_HARPOON(p_port+hp_ee_ctrl, ee_value);
+
+	  i >>= 1;
+	  }
+}
+
+USHORT CalcCrc16(UCHAR buffer[])
+{
+   USHORT crc=0;
+	int i,j;
+   USHORT ch;
+   for (i=0; i < ID_STRING_LENGTH; i++)
+   {
+      ch = (USHORT) buffer[i];
+	   for(j=0; j < 8; j++)
+	   {
+		   if ((crc ^ ch) & 1)
+            crc = (crc >> 1) ^ CRCMASK;
+		   else
+            crc >>= 1;
+		   ch >>= 1;
+	   }
+   }
+	return(crc);
+}
+
+UCHAR CalcLrc(UCHAR buffer[])
+{
+	int i;
+	UCHAR lrc;
+	lrc = 0;
+	for(i = 0; i < ID_STRING_LENGTH; i++)
+		lrc ^= buffer[i];
+	return(lrc);
+}
+
+
+
+/*
+  The following inline definitions avoid type conflicts.
+*/
+
+static inline unsigned char
+FlashPoint__ProbeHostAdapter(struct FlashPoint_Info *FlashPointInfo)
+{
+  return FlashPoint_ProbeHostAdapter((PSCCBMGR_INFO) FlashPointInfo);
+}
+
+
+static inline FlashPoint_CardHandle_T
+FlashPoint__HardwareResetHostAdapter(struct FlashPoint_Info *FlashPointInfo)
+{
+  return FlashPoint_HardwareResetHostAdapter((PSCCBMGR_INFO) FlashPointInfo);
+}
+
+static inline void
+FlashPoint__ReleaseHostAdapter(FlashPoint_CardHandle_T CardHandle)
+{
+  FlashPoint_ReleaseHostAdapter(CardHandle);
+}
+
+
+static inline void
+FlashPoint__StartCCB(FlashPoint_CardHandle_T CardHandle, struct BusLogic_CCB *CCB)
+{
+  FlashPoint_StartCCB(CardHandle, (PSCCB) CCB);
+}
+
+
+static inline void
+FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle, struct BusLogic_CCB *CCB)
+{
+  FlashPoint_AbortCCB(CardHandle, (PSCCB) CCB);
+}
+
+
+static inline boolean
+FlashPoint__InterruptPending(FlashPoint_CardHandle_T CardHandle)
+{
+  return FlashPoint_InterruptPending(CardHandle);
+}
+
+
+static inline int
+FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
+{
+  return FlashPoint_HandleInterrupt(CardHandle);
+}
+
+
+#define FlashPoint_ProbeHostAdapter	    FlashPoint__ProbeHostAdapter
+#define FlashPoint_HardwareResetHostAdapter FlashPoint__HardwareResetHostAdapter
+#define FlashPoint_ReleaseHostAdapter	    FlashPoint__ReleaseHostAdapter
+#define FlashPoint_StartCCB		    FlashPoint__StartCCB
+#define FlashPoint_AbortCCB		    FlashPoint__AbortCCB
+#define FlashPoint_InterruptPending	    FlashPoint__InterruptPending
+#define FlashPoint_HandleInterrupt	    FlashPoint__HandleInterrupt
+
+
+/*
+  FlashPoint_InquireTargetInfo returns the Synchronous Period, Synchronous
+  Offset, and Wide Transfers Active information for TargetID on CardHandle.
+*/
+
+void FlashPoint_InquireTargetInfo(FlashPoint_CardHandle_T CardHandle,
+				  int TargetID,
+				  unsigned char *SynchronousPeriod,
+				  unsigned char *SynchronousOffset,
+				  unsigned char *WideTransfersActive)
+{
+  SCCBMGR_TAR_INFO *TargetInfo =
+    &sccbMgrTbl[((SCCBCARD *)CardHandle)->cardIndex][TargetID];
+  if ((TargetInfo->TarSyncCtrl & SYNC_OFFSET) > 0)
+    {
+      *SynchronousPeriod = 5 * ((TargetInfo->TarSyncCtrl >> 5) + 1);
+      *SynchronousOffset = TargetInfo->TarSyncCtrl & SYNC_OFFSET;
+    }
+  else
+    {
+      *SynchronousPeriod = 0;
+      *SynchronousOffset = 0;
+    }
+  *WideTransfersActive = (TargetInfo->TarSyncCtrl & NARROW_SCSI ? 0 : 1);
+}
+
+
+#else  /* CONFIG_SCSI_OMIT_FLASHPOINT */
+
+
+/*
+  Define prototypes for the FlashPoint SCCB Manager Functions.
+*/
+
+extern unsigned char FlashPoint_ProbeHostAdapter(struct FlashPoint_Info *);
+extern FlashPoint_CardHandle_T
+       FlashPoint_HardwareResetHostAdapter(struct FlashPoint_Info *);
+extern void FlashPoint_StartCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
+extern int FlashPoint_AbortCCB(FlashPoint_CardHandle_T, struct BusLogic_CCB *);
+extern boolean FlashPoint_InterruptPending(FlashPoint_CardHandle_T);
+extern int FlashPoint_HandleInterrupt(FlashPoint_CardHandle_T);
+extern void FlashPoint_ReleaseHostAdapter(FlashPoint_CardHandle_T);
+extern void FlashPoint_InquireTargetInfo(FlashPoint_CardHandle_T,
+					 int, unsigned char *,
+					 unsigned char *, unsigned char *);
+
+
+#endif /* CONFIG_SCSI_OMIT_FLASHPOINT */
