commit 25fcf94a2fa89dd3e73e965ebb0b38a2a4f72aa4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jun 9 11:19:11 2019 +1000

    Revert "scsi: ncr5380: Increase register polling limit"
    
    This reverts commit 4822827a69d7cd3bc5a07b7637484ebd2cf88db6.
    
    The purpose of that commit was to suppress a timeout warning message which
    appeared to be caused by target latency. But suppressing the warning is
    undesirable as the warning may indicate a messed up transfer count.
    
    Another problem with that commit is that 15 ms is too long to keep
    interrupts disabled as interrupt latency can cause system clock drift and
    other problems.
    
    Cc: Michael Schmitz <schmitzmic@gmail.com>
    Cc: stable@vger.kernel.org
    Fixes: 4822827a69d7 ("scsi: ncr5380: Increase register polling limit")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index efca509b92b0..5935fd6d1a05 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -235,7 +235,7 @@ struct NCR5380_cmd {
 #define NCR5380_PIO_CHUNK_SIZE		256
 
 /* Time limit (ms) to poll registers when IRQs are disabled, e.g. during PDMA */
-#define NCR5380_REG_POLL_TIME		15
+#define NCR5380_REG_POLL_TIME		10
 
 static inline struct scsi_cmnd *NCR5380_to_scmd(struct NCR5380_cmd *ncmd_ptr)
 {

commit dad8261e643849ea134c7cd5c8e794e31d93b9eb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Sep 27 11:17:11 2018 +1000

    scsi: NCR5380: Have NCR5380_select() return a bool
    
    The return value is taken to mean "retry" or "don't retry". Change it to bool
    to improve readability. Fix related comments. No functional change.
    
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 31096a0b0fdd..efca509b92b0 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -275,7 +275,7 @@ static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 static void NCR5380_main(struct work_struct *work);
 static const char *NCR5380_info(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);
-static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
+static bool NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 static int NCR5380_poll_politely2(struct NCR5380_hostdata *,

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index d78f0957d865..31096a0b0fdd 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* 
  * NCR 5380 defines
  *

commit 9507037304e581493bcd8bf76e013e44be71470e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Clean up dead code and redundant macro usage
    
    Remove dead code inside #if 0 conditionals.
    
    Remove the #ifdef __KERNEL__ test, since NCR5380.h has no definitions
    that relate to userspace code.
    
    Remove two redundant macro definitions which were overlooked in
    commit e9db3198e08b ("sun3_scsi: Adopt NCR5380.c core driver").
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index e61d9f9987fa..d78f0957d865 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -166,11 +166,7 @@
 #define CSR_SCSI_BUF_RDY       0x02	/* ro  SCSI buffer read */
 #define CSR_GATED_53C80_IRQ    0x01	/* ro  Last block xferred */
 
-#if 0
-#define CSR_BASE CSR_SCSI_BUFF_INTR | CSR_53C80_INTR
-#else
 #define CSR_BASE CSR_53C80_INTR
-#endif
 
 /* Note : PHASE_* macros are based on the values of the STATUS register */
 #define PHASE_MASK 	(SR_MSG | SR_CD | SR_IO)
@@ -229,8 +225,6 @@ struct NCR5380_hostdata {
 	char info[168];				/* Host banner message */
 };
 
-#ifdef __KERNEL__
-
 struct NCR5380_cmd {
 	struct list_head list;
 };
@@ -323,5 +317,4 @@ static inline int NCR5380_dma_residual_none(struct NCR5380_hostdata *hostdata)
 	return 0;
 }
 
-#endif				/* __KERNEL__ */
 #endif				/* NCR5380_H */

commit 090284610632bb32a5d2eea41420ee7c2b6975ca
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Shorten host info string by removing unused option macros
    
    The DIFFERENTIAL and PARITY option macros are unused: no supported
    hardware uses differential signalling and the core driver never
    implemented parity checking. These options just waste space in the host
    info string.
    
    While we are here, fix a typo in the NCR5380_info() kernel-doc comment.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 51a3567a6fb2..e61d9f9987fa 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -81,11 +81,7 @@
 #define ICR_ASSERT_ATN		0x02	/* rw Set to assert ATN */
 #define ICR_ASSERT_DATA		0x01	/* rw SCSI_DATA_REG is asserted */
 
-#ifdef DIFFERENTIAL
-#define ICR_BASE		ICR_DIFF_ENABLE
-#else
 #define ICR_BASE		0
-#endif
 
 #define MODE_REG		2
 /*
@@ -102,11 +98,7 @@
 #define MR_DMA_MODE		0x02	/* rw DMA / pseudo DMA mode */
 #define MR_ARBITRATE		0x01	/* rw start arbitration */
 
-#ifdef PARITY
-#define MR_BASE			MR_ENABLE_PAR_CHECK
-#else
 #define MR_BASE			0
-#endif
 
 #define TARGET_COMMAND_REG	3
 #define TCR_LAST_BYTE_SENT	0x80	/* ro DMA done */
@@ -234,7 +226,7 @@ struct NCR5380_hostdata {
 	unsigned char id_higher_mask;		/* All bits above id_mask */
 	unsigned char last_message;		/* Last Message Out */
 	unsigned long region_size;		/* Size of address/port range */
-	char info[256];
+	char info[168];				/* Host banner message */
 };
 
 #ifdef __KERNEL__

commit 906e4a3c7e03701008d343daec8952d6cf49f82b
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Dec 5 01:07:20 2016 -0500

    scsi: g_NCR5380: Use probe_irq_*() for IRQ probing
    
    Use standard probe_irq_on() and probe_irq_off() functions instead of own
    implementation.  This prevents warning messages like this in the kernel
    log: genirq: Flags mismatch irq 1. 00000000 (NCR-probe) vs. 00000080
    (i8042)
    
    Move the IRQ trigger code from NCR5380 to g_NCR5380 where it is used.
    
    Also clear interrupt flag before and after the probe.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 3c6ce5434449..51a3567a6fb2 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -199,16 +199,6 @@
 
 #define PHASE_SR_TO_TCR(phase) ((phase) >> 2)
 
-/*
- * These are "special" values for the irq and dma_channel fields of the 
- * Scsi_Host structure
- */
-
-#define DMA_NONE	255
-#define IRQ_AUTO	254
-#define DMA_AUTO	254
-#define PORT_AUTO	0xffff	/* autoprobe io port for 53c400a */
-
 #ifndef NO_IRQ
 #define NO_IRQ		0
 #endif
@@ -290,7 +280,6 @@ static void NCR5380_print(struct Scsi_Host *instance);
 #define NCR5380_dprint_phase(flg, arg) do {} while (0)
 #endif
 
-static int NCR5380_probe_irq(struct Scsi_Host *instance, int possible);
 static int NCR5380_init(struct Scsi_Host *instance, int flags);
 static int NCR5380_maybe_reset_bus(struct Scsi_Host *);
 static void NCR5380_exit(struct Scsi_Host *instance);

commit 4a98f896bf2c66a69517fc5e10dc67288cb8da93
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for DMA routines
    
    Apply prototypes to get consistent function signatures for the DMA
    functions implemented in the board-specific drivers. To avoid using
    macros to alter actual parameters, some of those functions are reworked
    slightly.
    
    This is a step toward the goal of passing the board-specific routines
    to the core driver using an ops struct (as in a platform driver or
    library module).
    
    This also helps fix some inconsistent types: where the core driver uses
    ints (cmd->SCp.this_residual and hostdata->dma_len) for keeping track of
    transfers, certain board-specific routines used unsigned long.
    
    While we are fixing these function signatures, pass the hostdata pointer
    to DMA routines instead of a Scsi_Host pointer, for shorter and faster
    code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index b2c560cb0218..3c6ce5434449 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -317,5 +317,30 @@ static inline int NCR5380_poll_politely(struct NCR5380_hostdata *hostdata,
 						reg, bit, val, wait);
 }
 
+static int NCR5380_dma_xfer_len(struct NCR5380_hostdata *,
+                                struct scsi_cmnd *);
+static int NCR5380_dma_send_setup(struct NCR5380_hostdata *,
+                                  unsigned char *, int);
+static int NCR5380_dma_recv_setup(struct NCR5380_hostdata *,
+                                  unsigned char *, int);
+static int NCR5380_dma_residual(struct NCR5380_hostdata *);
+
+static inline int NCR5380_dma_xfer_none(struct NCR5380_hostdata *hostdata,
+                                        struct scsi_cmnd *cmd)
+{
+	return 0;
+}
+
+static inline int NCR5380_dma_setup_none(struct NCR5380_hostdata *hostdata,
+                                         unsigned char *data, int count)
+{
+	return 0;
+}
+
+static inline int NCR5380_dma_residual_none(struct NCR5380_hostdata *hostdata)
+{
+	return 0;
+}
+
 #endif				/* __KERNEL__ */
 #endif				/* NCR5380_H */

commit 7c60663143c29ea64f51e692f950f8619e0e4c77
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Expedite register polling
    
    Avoid the call to NCR5380_poll_politely2() when possible. The call is
    easily short-circuited on the PIO fast path, using the inline wrapper.
    This requires that the NCR5380_read macro be made available before
    any #include "NCR5380.h" so a few declarations have to be moved too.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 4682baab07ed..b2c560cb0218 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -310,6 +310,9 @@ static inline int NCR5380_poll_politely(struct NCR5380_hostdata *hostdata,
                                         unsigned int reg, u8 bit, u8 val,
                                         unsigned long wait)
 {
+	if ((NCR5380_read(reg) & bit) == val)
+		return 0;
+
 	return NCR5380_poll_politely2(hostdata, reg, bit, val,
 						reg, bit, val, wait);
 }

commit d5d37a0ab13b8f4ccfa58a4e852e19bcbf47ed5e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Pass hostdata pointer to register polling routines
    
    Pass a NCR5380_hostdata struct pointer to the board-specific routines
    instead of a Scsi_Host struct pointer. This reduces pointer chasing in
    the PIO and PDMA fast paths. The old way was a mistake because it is
    slow and the board-specific code is not concerned with the mid-layer.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index c2d8b78d1a38..4682baab07ed 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -302,15 +302,15 @@ static void NCR5380_reselect(struct Scsi_Host *instance);
 static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
-static int NCR5380_poll_politely2(struct Scsi_Host *,
+static int NCR5380_poll_politely2(struct NCR5380_hostdata *,
                                   unsigned int, u8, u8,
                                   unsigned int, u8, u8, unsigned long);
 
-static inline int NCR5380_poll_politely(struct Scsi_Host *instance,
+static inline int NCR5380_poll_politely(struct NCR5380_hostdata *hostdata,
                                         unsigned int reg, u8 bit, u8 val,
                                         unsigned long wait)
 {
-	return NCR5380_poll_politely2(instance, reg, bit, val,
+	return NCR5380_poll_politely2(hostdata, reg, bit, val,
 						reg, bit, val, wait);
 }
 

commit 61e1ce588b101f13a4c6f713b95d65551c8572e3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for device register accessors
    
    For timeout values adopt unsigned long, which is the type of jiffies etc.
    
    For chip register values and bit masks pass u8, which is the return type
    of readb, inb etc.
    
    For device register offsets adopt unsigned int, as it is suitable for
    adding to base addresses.
    
    Pass the NCR5380_hostdata pointer to the board-specific routines instead
    of the Scsi_Host pointer. The board-specific code is concerned with
    hardware and not with SCSI protocol or the mid-layer.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 02f20ff757ae..c2d8b78d1a38 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -302,10 +302,13 @@ static void NCR5380_reselect(struct Scsi_Host *instance);
 static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
-static int NCR5380_poll_politely2(struct Scsi_Host *, int, int, int, int, int, int, int);
+static int NCR5380_poll_politely2(struct Scsi_Host *,
+                                  unsigned int, u8, u8,
+                                  unsigned int, u8, u8, unsigned long);
 
 static inline int NCR5380_poll_politely(struct Scsi_Host *instance,
-					int reg, int bit, int val, int wait)
+                                        unsigned int reg, u8 bit, u8 val,
+                                        unsigned long wait)
 {
 	return NCR5380_poll_politely2(instance, reg, bit, val,
 						reg, bit, val, wait);

commit 820682b1b34ebb97434c4abc00c744870364e2be
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Store IO ports and addresses in host private data
    
    The various 5380 drivers inconsistently store register pointers
    either in the Scsi_Host struct "legacy crap" area or in special,
    board-specific members of the NCR5380_hostdata struct. Uniform
    use of the latter struct makes for simpler and faster code (see
    the following patches) and helps to reduce use of the
    NCR5380_implementation_fields macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index ceafa0cd80be..02f20ff757ae 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -220,6 +220,8 @@
 
 struct NCR5380_hostdata {
 	NCR5380_implementation_fields;		/* Board-specific data */
+	u8 __iomem *io;				/* Remapped 5380 address */
+	u8 __iomem *pdma_io;			/* Remapped PDMA address */
 	unsigned long poll_loops;		/* Register polling limit */
 	spinlock_t lock;			/* Protects this struct */
 	struct scsi_cmnd *connected;		/* Currently connected cmnd */
@@ -230,6 +232,8 @@ struct NCR5380_hostdata {
 	int flags;				/* Board-specific quirks */
 	int dma_len;				/* Requested length of DMA */
 	int read_overruns;	/* Transfer size reduction for DMA erratum */
+	unsigned long io_port;			/* Device IO port */
+	unsigned long base;			/* Device base address */
 	struct list_head unissued;		/* Waiting to be issued */
 	struct scsi_cmnd *selecting;		/* Cmnd to be connected */
 	struct list_head autosense;		/* Priority cmnd queue */
@@ -239,6 +243,7 @@ struct NCR5380_hostdata {
 	unsigned char id_mask;			/* 1 << Host ID */
 	unsigned char id_higher_mask;		/* All bits above id_mask */
 	unsigned char last_message;		/* Last Message Out */
+	unsigned long region_size;		/* Size of address/port range */
 	char info[256];
 };
 

commit 25894d1f98aed363bf03e2509d0237c69ab0c8ec
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Improve hostdata struct member alignment and cache-ability
    
    Re-order struct members so that hot data lies at the beginning of the
    struct and cold data at the end. Improve the comments while we're here.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index f0eea44107d2..ceafa0cd80be 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -219,27 +219,27 @@
 #define FLAG_TOSHIBA_DELAY		128	/* Allow for borken CD-ROMs */
 
 struct NCR5380_hostdata {
-	NCR5380_implementation_fields;		/* implementation specific */
-	struct Scsi_Host *host;			/* Host backpointer */
-	unsigned char id_mask, id_higher_mask;	/* 1 << id, all bits greater */
-	unsigned char busy[8];			/* index = target, bit = lun */
-	int dma_len;				/* requested length of DMA */
-	unsigned char last_message;		/* last message OUT */
-	struct scsi_cmnd *connected;		/* currently connected cmnd */
-	struct scsi_cmnd *selecting;		/* cmnd to be connected */
-	struct list_head unissued;		/* waiting to be issued */
-	struct list_head autosense;		/* priority issue queue */
-	struct list_head disconnected;		/* waiting for reconnect */
-	spinlock_t lock;			/* protects this struct */
-	int flags;
-	struct scsi_eh_save ses;
-	struct scsi_cmnd *sensing;
+	NCR5380_implementation_fields;		/* Board-specific data */
+	unsigned long poll_loops;		/* Register polling limit */
+	spinlock_t lock;			/* Protects this struct */
+	struct scsi_cmnd *connected;		/* Currently connected cmnd */
+	struct list_head disconnected;		/* Waiting for reconnect */
+	struct Scsi_Host *host;			/* SCSI host backpointer */
+	struct workqueue_struct *work_q;	/* SCSI host work queue */
+	struct work_struct main_task;		/* Work item for main loop */
+	int flags;				/* Board-specific quirks */
+	int dma_len;				/* Requested length of DMA */
+	int read_overruns;	/* Transfer size reduction for DMA erratum */
+	struct list_head unissued;		/* Waiting to be issued */
+	struct scsi_cmnd *selecting;		/* Cmnd to be connected */
+	struct list_head autosense;		/* Priority cmnd queue */
+	struct scsi_cmnd *sensing;		/* Cmnd needing autosense */
+	struct scsi_eh_save ses;		/* Cmnd state saved for EH */
+	unsigned char busy[8];			/* Index = target, bit = lun */
+	unsigned char id_mask;			/* 1 << Host ID */
+	unsigned char id_higher_mask;		/* All bits above id_mask */
+	unsigned char last_message;		/* Last Message Out */
 	char info[256];
-	int read_overruns;                /* number of bytes to cut from a
-	                                   * transfer to handle chip overruns */
-	struct work_struct main_task;
-	struct workqueue_struct *work_q;
-	unsigned long poll_loops;		/* register polling limit */
 };
 
 #ifdef __KERNEL__

commit 4822827a69d7cd3bc5a07b7637484ebd2cf88db6
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:52 2016 -0400

    scsi: ncr5380: Increase register polling limit
    
    If NCR5380_poll_politely() is called under irq lock, the polling time
    limit is clamped to avoid a spike in interrupt latency. When not under
    irq lock, the same polling time limit acts as the worst case delay
    between schedule() calls.
    
    During PDMA (under irq lock) I've found that the 10 ms time limit is
    sometimes too short, and leads to the error message,
    sd 0:0:0:0: [sda] tag#1 macscsi_pread: !REQ and !ACK
    
    This particular target identifies itself as a QUANTUM DAYTONA514S. It
    seems to be slower to assert ACK than the other targets I've tested.
    This patch solves the problem by increasing the polling timeout.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index cbb29d604fe0..f0eea44107d2 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -253,7 +253,7 @@ struct NCR5380_cmd {
 #define NCR5380_PIO_CHUNK_SIZE		256
 
 /* Time limit (ms) to poll registers when IRQs are disabled, e.g. during PDMA */
-#define NCR5380_REG_POLL_TIME		10
+#define NCR5380_REG_POLL_TIME		15
 
 static inline struct scsi_cmnd *NCR5380_to_scmd(struct NCR5380_cmd *ncmd_ptr)
 {

commit d4408dd7ecff6ed3561f155923738474c585f31d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:52 2016 -0400

    scsi: ncr5380: Simplify register polling limit
    
    When polling a device register under irq lock the polling loop terminates
    after a given number of jiffies. Make this timeout independent of the HZ
    setting.
    
    All 5380 drivers benefit from this patch, which optimizes the PIO fast
    path, because they all use PIO transfers (for phases other than DATA IN
    and DATA OUT). Some cards support only PIO transfers (even for DATA
    phases). CPU cycles are scarce on some of these systems, so a small
    improvement here makes a big difference.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 965d92339455..cbb29d604fe0 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -239,7 +239,7 @@ struct NCR5380_hostdata {
 	                                   * transfer to handle chip overruns */
 	struct work_struct main_task;
 	struct workqueue_struct *work_q;
-	unsigned long accesses_per_ms;	/* chip register accesses per ms */
+	unsigned long poll_loops;		/* register polling limit */
 };
 
 #ifdef __KERNEL__
@@ -252,6 +252,9 @@ struct NCR5380_cmd {
 
 #define NCR5380_PIO_CHUNK_SIZE		256
 
+/* Time limit (ms) to poll registers when IRQs are disabled, e.g. during PDMA */
+#define NCR5380_REG_POLL_TIME		10
+
 static inline struct scsi_cmnd *NCR5380_to_scmd(struct NCR5380_cmd *ncmd_ptr)
 {
 	return ((struct scsi_cmnd *)ncmd_ptr) - 1;

commit 08348b1c9b6f78430fecb120fd0c4b8c044d3639
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Aug 31 14:44:56 2016 +1000

    scsi: ncr5380: Improve interrupt latency during PIO tranfers
    
    Large PIO transfers are broken up into chunks to try to avoid disabling
    local IRQs for long periods. But IRQs are still disabled for too long
    and this causes SCC FIFO overruns during serial port transfers.
    
    This patch reduces the PIO chunk size to reduce interrupt latency to
    something on the order of milliseconds, at the expense of additional CPU
    overhead from extra iterations of the NCR5380_main() loop.
    
    That CPU overhead is a problem for slow machines (e.g. mac_scsi on 25
    MHz 68030) but these machines generally use PDMA not PIO. This patch
    doesn't make the overhead any worse on my Mac LC III (because it only
    gets about 510 accesses per ms).
    
    This patch decreases disk performance by a fraction of one percent for
    dmx3191d on my 333 MHz PowerPC 750. Other affected hardware (such as
    g_NCR5380 on x86) was not tested but 5380 ISA cards generally use PDMA
    and not PIO.
    
    [mkp: fix whitespace]
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 2ed61b5d40e6..965d92339455 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -250,6 +250,8 @@ struct NCR5380_cmd {
 
 #define NCR5380_CMD_SIZE		(sizeof(struct NCR5380_cmd))
 
+#define NCR5380_PIO_CHUNK_SIZE		256
+
 static inline struct scsi_cmnd *NCR5380_to_scmd(struct NCR5380_cmd *ncmd_ptr)
 {
 	return ((struct scsi_cmnd *)ncmd_ptr) - 1;

commit 01f17641c4c6e7468bbd3d3f382c151db01dc0e8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Aug 27 12:30:00 2016 +1000

    scsi: ncr5380: Avoid a compiler warning
    
    With commit 3a0f64bfa907 ("mac_scsi: Fix pseudo DMA implementation")
    some versions of gcc now warn:
    
    In file included from drivers/scsi/mac_scsi.c:335:
    drivers/scsi/NCR5380.h:295: warning: `NCR5380_poll_politely' declared inline after being called
    drivers/scsi/NCR5380.h:295: warning: previous declaration of `NCR5380_poll_politely' was here
    
    Avoid this by defining NCR5380_poll_politely() in NCR5380.h.
    
    [mkp: checkpatch warnings]
    
    Suggested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index c60728785d89..2ed61b5d40e6 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -292,8 +292,14 @@ static void NCR5380_reselect(struct Scsi_Host *instance);
 static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
-static int NCR5380_poll_politely(struct Scsi_Host *, int, int, int, int);
 static int NCR5380_poll_politely2(struct Scsi_Host *, int, int, int, int, int, int, int);
 
+static inline int NCR5380_poll_politely(struct Scsi_Host *instance,
+					int reg, int bit, int val, int wait)
+{
+	return NCR5380_poll_politely2(instance, reg, bit, val,
+						reg, bit, val, wait);
+}
+
 #endif				/* __KERNEL__ */
 #endif				/* NCR5380_H */

commit 3a0f64bfa90700c4fa9db0ed2d701300edd9a0b3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:31 2016 +1100

    mac_scsi: Fix pseudo DMA implementation
    
    Fix various issues: Comments about bus errors are incorrect. The
    PDMA asm must return the size of the memory access that faulted so the
    transfer count can be adjusted accordingly. A phase change may cause a
    bus error but should not be treated as failure. A bus error does not
    always imply a phase change and generally the transfer may continue.
    Scatter/gather doesn't seem to work with PDMA due to overruns. This is
    a pity because peak throughput seems to double with SG_ALL.
    Tested on a Mac LC III and a PowerBook 520.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 076f8969dd22..c60728785d89 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -292,6 +292,8 @@ static void NCR5380_reselect(struct Scsi_Host *instance);
 static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
+static int NCR5380_poll_politely(struct Scsi_Host *, int, int, int, int);
+static int NCR5380_poll_politely2(struct Scsi_Host *, int, int, int, int, int, int, int);
 
 #endif				/* __KERNEL__ */
 #endif				/* NCR5380_H */

commit a46865dcf1f7166808664ab096678f81d4fbb853
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:27 2016 +1100

    ncr5380: Remove DONT_USE_INTR and AUTOPROBE_IRQ macros
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 5c2411f05852..076f8969dd22 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -280,16 +280,12 @@ static void NCR5380_print(struct Scsi_Host *instance);
 #define NCR5380_dprint_phase(flg, arg) do {} while (0)
 #endif
 
-#if defined(AUTOPROBE_IRQ)
 static int NCR5380_probe_irq(struct Scsi_Host *instance, int possible);
-#endif
 static int NCR5380_init(struct Scsi_Host *instance, int flags);
 static int NCR5380_maybe_reset_bus(struct Scsi_Host *);
 static void NCR5380_exit(struct Scsi_Host *instance);
 static void NCR5380_information_transfer(struct Scsi_Host *instance);
-#ifndef DONT_USE_INTR
 static irqreturn_t NCR5380_intr(int irq, void *dev_id);
-#endif
 static void NCR5380_main(struct work_struct *work);
 static const char *NCR5380_info(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);

commit c4ec6f924f0682e1f40107204152e977d6b1bd07
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:22 2016 +1100

    ncr5380: Remove disused atari_NCR5380.c core driver
    
    Now that atari_scsi and sun3_scsi have been converted to use the NCR5380.c
    core driver, remove atari_NCR5380.c. Also remove the last vestiges of its
    Tagged Command Queueing implementation from the wrapper drivers.
    
    The TCQ support in atari_NCR5380.c is abandoned by this patch. It is not
    merged into the remaining core driver because,
    
    1) atari_scsi defines SUPPORT_TAGS but leaves FLAG_TAGGED_QUEUING disabled
    by default, which indicates that it is mostly undesirable.
    
    2) I'm told that it doesn't work correctly when enabled.
    
    3) The algorithm does not make use of block layer tags which it will have
    to do because scmd->tag is deprecated.
    
    4) sun3_scsi doesn't define SUPPORT_TAGS at all, yet the the SUPPORT_TAGS
    macro interacts with the CONFIG_SUN3 macro in 'interesting' ways.
    
    5) Compile-time configuration with macros like SUPPORT_TAGS caused the
    configuration space to explode, leading to untestable and unmaintainable
    code that is too hard to reason about.
    
    The merge_contiguous_buffers() code is also abandoned. This was unused
    by sun3_scsi. Only atari_scsi used it and then only on TT, because only TT
    supports scatter/gather. I suspect that the TT would work fine with
    ENABLE_CLUSTERING instead. If someone can benchmark the difference then
    perhaps the merge_contiguous_buffers() code can be be justified. Until
    then we are better off without the extra complexity.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 8adf7377de4c..5c2411f05852 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -199,13 +199,6 @@
 
 #define PHASE_SR_TO_TCR(phase) ((phase) >> 2)
 
-/* 
- * "Special" value for the (unsigned char) command tag, to indicate
- * I_T_L nexus instead of I_T_L_Q.
- */
-
-#define TAG_NONE	0xff
-
 /*
  * These are "special" values for the irq and dma_channel fields of the 
  * Scsi_Host structure
@@ -223,17 +216,8 @@
 #define FLAG_DMA_FIXUP			1	/* Use DMA errata workarounds */
 #define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
-#define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */
 #define FLAG_TOSHIBA_DELAY		128	/* Allow for borken CD-ROMs */
 
-#ifdef SUPPORT_TAGS
-struct tag_alloc {
-	DECLARE_BITMAP(allocated, MAX_TAGS);
-	int nr_allocated;
-	int queue_size;
-};
-#endif
-
 struct NCR5380_hostdata {
 	NCR5380_implementation_fields;		/* implementation specific */
 	struct Scsi_Host *host;			/* Host backpointer */
@@ -254,9 +238,6 @@ struct NCR5380_hostdata {
 	int read_overruns;                /* number of bytes to cut from a
 	                                   * transfer to handle chip overruns */
 	struct work_struct main_task;
-#ifdef SUPPORT_TAGS
-	struct tag_alloc TagAlloc[8][8];	/* 8 targets and 8 LUNs */
-#endif
 	struct workqueue_struct *work_q;
 	unsigned long accesses_per_ms;	/* chip register accesses per ms */
 };

commit f825e40b235f4daf1c9017366809d34c7f5c8c7f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:15 2016 +1100

    ncr5380: Remove PSEUDO_DMA macro
    
    For those wrapper drivers which only implement Programmed IO, have
    NCR5380_dma_xfer_len() evaluate to zero. That allows PDMA to be easily
    disabled at run-time and so the PSEUDO_DMA macro is no longer needed.
    
    Also remove the spin counters used for debugging pseudo DMA drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 7b488a082462..8adf7377de4c 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -256,10 +256,6 @@ struct NCR5380_hostdata {
 	struct work_struct main_task;
 #ifdef SUPPORT_TAGS
 	struct tag_alloc TagAlloc[8][8];	/* 8 targets and 8 LUNs */
-#endif
-#ifdef PSEUDO_DMA
-	unsigned spin_max_r;
-	unsigned spin_max_w;
 #endif
 	struct workqueue_struct *work_q;
 	unsigned long accesses_per_ms;	/* chip register accesses per ms */

commit 1bb4600245d4d40245dd505ca17528e0b9a9ba8c
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:14 2016 +1100

    ncr5380: Disable the DMA errata workaround flag by default
    
    The only chip that needs the workarounds enabled is an early NMOS
    device. That means that the common case is to disable them.
    
    Unfortunately the sense of the flag is such that it has to be set
    for the common case.
    
    Rename the flag so that zero can be used to mean "no errata workarounds
    needed". This simplifies the code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 0b03ba25bd66..7b488a082462 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -220,7 +220,7 @@
 #define NO_IRQ		0
 #endif
 
-#define FLAG_NO_DMA_FIXUP		1	/* No DMA errata workarounds */
+#define FLAG_DMA_FIXUP			1	/* Use DMA errata workarounds */
 #define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
 #define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */

commit e4dec6806aceca768b74c1c6402e6d31ecf3c960
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:12 2016 +1100

    ncr5380: Remove REAL_DMA and REAL_DMA_POLL macros
    
    For the NCR5380.c core driver, these macros are never used.
    If REAL_DMA were to be defined, compilation would fail.
    
    For the atari_NCR5380.c core driver, REAL_DMA is always defined.
    
    Hence these macros are pointless.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index a79288682a74..0b03ba25bd66 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -239,9 +239,7 @@ struct NCR5380_hostdata {
 	struct Scsi_Host *host;			/* Host backpointer */
 	unsigned char id_mask, id_higher_mask;	/* 1 << id, all bits greater */
 	unsigned char busy[8];			/* index = target, bit = lun */
-#if defined(REAL_DMA) || defined(REAL_DMA_POLL)
 	int dma_len;				/* requested length of DMA */
-#endif
 	unsigned char last_message;		/* last message OUT */
 	struct scsi_cmnd *connected;		/* currently connected cmnd */
 	struct scsi_cmnd *selecting;		/* cmnd to be connected */
@@ -319,118 +317,8 @@ static void NCR5380_main(struct work_struct *work);
 static const char *NCR5380_info(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);
 static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
-#if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
-#endif
 static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 
-#if (defined(REAL_DMA) || defined(REAL_DMA_POLL))
-
-#if defined(i386) || defined(__alpha__)
-
-/**
- *	NCR5380_pc_dma_setup		-	setup ISA DMA
- *	@instance: adapter to set up
- *	@ptr: block to transfer (virtual address)
- *	@count: number of bytes to transfer
- *	@mode: DMA controller mode to use
- *
- *	Program the DMA controller ready to perform an ISA DMA transfer
- *	on this chip.
- *
- *	Locks: takes and releases the ISA DMA lock.
- */
- 
-static __inline__ int NCR5380_pc_dma_setup(struct Scsi_Host *instance, unsigned char *ptr, unsigned int count, unsigned char mode)
-{
-	unsigned limit;
-	unsigned long bus_addr = virt_to_bus(ptr);
-	unsigned long flags;
-
-	if (instance->dma_channel <= 3) {
-		if (count > 65536)
-			count = 65536;
-		limit = 65536 - (bus_addr & 0xFFFF);
-	} else {
-		if (count > 65536 * 2)
-			count = 65536 * 2;
-		limit = 65536 * 2 - (bus_addr & 0x1FFFF);
-	}
-
-	if (count > limit)
-		count = limit;
-
-	if ((count & 1) || (bus_addr & 1))
-		panic("scsi%d : attempted unaligned DMA transfer\n", instance->host_no);
-	
-	flags=claim_dma_lock();
-	disable_dma(instance->dma_channel);
-	clear_dma_ff(instance->dma_channel);
-	set_dma_addr(instance->dma_channel, bus_addr);
-	set_dma_count(instance->dma_channel, count);
-	set_dma_mode(instance->dma_channel, mode);
-	enable_dma(instance->dma_channel);
-	release_dma_lock(flags);
-	
-	return count;
-}
-
-/**
- *	NCR5380_pc_dma_write_setup		-	setup ISA DMA write
- *	@instance: adapter to set up
- *	@ptr: block to transfer (virtual address)
- *	@count: number of bytes to transfer
- *
- *	Program the DMA controller ready to perform an ISA DMA write to the
- *	SCSI controller.
- *
- *	Locks: called routines take and release the ISA DMA lock.
- */
-
-static __inline__ int NCR5380_pc_dma_write_setup(struct Scsi_Host *instance, unsigned char *src, unsigned int count)
-{
-	return NCR5380_pc_dma_setup(instance, src, count, DMA_MODE_WRITE);
-}
-
-/**
- *	NCR5380_pc_dma_read_setup		-	setup ISA DMA read
- *	@instance: adapter to set up
- *	@ptr: block to transfer (virtual address)
- *	@count: number of bytes to transfer
- *
- *	Program the DMA controller ready to perform an ISA DMA read from the
- *	SCSI controller.
- *
- *	Locks: called routines take and release the ISA DMA lock.
- */
-
-static __inline__ int NCR5380_pc_dma_read_setup(struct Scsi_Host *instance, unsigned char *src, unsigned int count)
-{
-	return NCR5380_pc_dma_setup(instance, src, count, DMA_MODE_READ);
-}
-
-/**
- *	NCR5380_pc_dma_residual		-	return bytes left 
- *	@instance: adapter
- *
- *	Reports the number of bytes left over after the DMA was terminated.
- *
- *	Locks: takes and releases the ISA DMA lock.
- */
-
-static __inline__ int NCR5380_pc_dma_residual(struct Scsi_Host *instance)
-{
-	unsigned long flags;
-	int tmp;
-
-	flags = claim_dma_lock();
-	clear_dma_ff(instance->dma_channel);
-	tmp = get_dma_residue(instance->dma_channel);
-	release_dma_lock(flags);
-	
-	return tmp;
-}
-#endif				/* defined(i386) || defined(__alpha__) */
-#endif				/* defined(REAL_DMA)  */
 #endif				/* __KERNEL__ */
 #endif				/* NCR5380_H */

commit 12150797d064e2936154a8c01be24ce1b0115cfe
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:15 2016 +1100

    ncr5380: Use runtime register mapping
    
    Convert compile-time C400_ register mapping to runtime mapping.
    This removes the weird negative register offsets and allows adding
    additional mappings.
    
    While at it, convert read/write loops into insb/outsb.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index ee83ab5f32e8..a79288682a74 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -163,8 +163,7 @@
 /* Write any value to this register to start an ini mode DMA receive */
 #define START_DMA_INITIATOR_RECEIVE_REG 7	/* wo */
 
-#define C400_CONTROL_STATUS_REG NCR53C400_register_offset-8	/* rw */
-
+/* NCR 53C400(A) Control Status Register bits: */
 #define CSR_RESET              0x80	/* wo  Resets 53c400 */
 #define CSR_53C80_REG          0x80	/* ro  5380 registers busy */
 #define CSR_TRANS_DIR          0x40	/* rw  Data transfer direction */
@@ -181,16 +180,6 @@
 #define CSR_BASE CSR_53C80_INTR
 #endif
 
-/* Number of 128-byte blocks to be transferred */
-#define C400_BLOCK_COUNTER_REG   NCR53C400_register_offset-7	/* rw */
-
-/* Resume transfer after disconnect */
-#define C400_RESUME_TRANSFER_REG NCR53C400_register_offset-6	/* wo */
-
-/* Access to host buffer stack */
-#define C400_HOST_BUFFER         NCR53C400_register_offset-4	/* rw */
-
-
 /* Note : PHASE_* macros are based on the values of the STATUS register */
 #define PHASE_MASK 	(SR_MSG | SR_CD | SR_IO)
 

commit 707d62b37fbb1de74da6e5cf263bcd8223ae3cf7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:06:02 2016 +1100

    ncr5380: Fix EH during arbitration and selection
    
    During arbitration and selection, the relevant command is invisible to
    exception handlers and can be found only in a pointer on the stack of a
    different thread.
    
    When eh_abort_handler can't find a given command, it can't decide whether
    that command was completed already or is still in arbitration or selection
    phase. But it must return either SUCCESS (e.g. command completed earlier)
    or FAILED (could not abort the nexus, try bus reset).
    
    The solution is to make sure all commands belonging to the LLD are always
    visible to exception handlers. Add another scsi_cmnd pointer to the
    hostdata struct to track the command in arbitration or selection phase.
    
    Replace 'retain_dma_irq' with the new 'selecting' pointer, to bring
    atari_NCR5380.c into line with NCR5380.c.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 81e077afa8db..ee83ab5f32e8 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -255,6 +255,7 @@ struct NCR5380_hostdata {
 #endif
 	unsigned char last_message;		/* last message OUT */
 	struct scsi_cmnd *connected;		/* currently connected cmnd */
+	struct scsi_cmnd *selecting;		/* cmnd to be connected */
 	struct list_head unissued;		/* waiting to be issued */
 	struct list_head autosense;		/* priority issue queue */
 	struct list_head disconnected;		/* waiting for reconnect */
@@ -265,7 +266,6 @@ struct NCR5380_hostdata {
 	char info[256];
 	int read_overruns;                /* number of bytes to cut from a
 	                                   * transfer to handle chip overruns */
-	int retain_dma_intr;
 	struct work_struct main_task;
 #ifdef SUPPORT_TAGS
 	struct tag_alloc TagAlloc[8][8];	/* 8 targets and 8 LUNs */
@@ -329,7 +329,7 @@ static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 static void NCR5380_main(struct work_struct *work);
 static const char *NCR5380_info(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);
-static int NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd);
+static struct scsi_cmnd *NCR5380_select(struct Scsi_Host *, struct scsi_cmnd *);
 #if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 #endif

commit f27db8eb98a19e0f1b5748f8aad9fb4a98301eb0
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:06:00 2016 +1100

    ncr5380: Fix autosense bugs
    
    NCR5380_information_transfer() may re-queue a command for autosense,
    after calling scsi_eh_prep_cmnd(). This creates several possibilities:
    
    1. Reselection may intervene before the re-queued command gets processed.
       If the reconnected command then undergoes autosense, this causes the
       scsi_eh_save data from the previous command to be overwritten.
    
    2. After NCR5380_information_transfer() calls scsi_eh_prep_cmnd(),
       a new REQUEST SENSE command may arrive. This would be queued ahead
       of any command already undergoing autosense, which means the
       scsi_eh_save data might be restored to the wrong command.
    
    3. After NCR5380_information_transfer() calls scsi_eh_prep_cmnd(),
       eh_abort_handler() may abort the command. But the scsi_eh_save data is
       not discarded, which means the scsi_eh_save data might be incorrectly
       restored to the next REQUEST SENSE command issued.
    
    This patch adds a new autosense list so that commands that are re-queued
    because of a CHECK CONDITION result can be kept apart from the REQUEST
    SENSE commands that arrive via queuecommand.
    
    This patch also adds a function dedicated to dequeueing and preparing the
    next command for processing. By refactoring the main loop in this way,
    scsi_eh_save takes place when an autosense command is dequeued rather
    than when re-queued.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 56252a5516d7..81e077afa8db 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -256,10 +256,12 @@ struct NCR5380_hostdata {
 	unsigned char last_message;		/* last message OUT */
 	struct scsi_cmnd *connected;		/* currently connected cmnd */
 	struct list_head unissued;		/* waiting to be issued */
+	struct list_head autosense;		/* priority issue queue */
 	struct list_head disconnected;		/* waiting for reconnect */
 	spinlock_t lock;			/* protects this struct */
 	int flags;
 	struct scsi_eh_save ses;
+	struct scsi_cmnd *sensing;
 	char info[256];
 	int read_overruns;                /* number of bytes to cut from a
 	                                   * transfer to handle chip overruns */

commit 32b26a104237c1ba3575a6c8d47e46060cc416fb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:58 2016 +1100

    ncr5380: Use standard list data structure
    
    The NCR5380 drivers have a home-spun linked list implementation for
    scsi_cmnd structs that uses cmd->host_scribble as a 'next' pointer. Adopt
    the standard list_head data structure and list operations instead. Remove
    the eh_abort_handler rather than convert it. Doing the conversion would
    only be churn because the existing EH handlers don't work and get replaced
    in a subsequent patch.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 87c2f2104e68..56252a5516d7 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -24,6 +24,7 @@
 
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/list.h>
 #include <linux/workqueue.h>
 #include <scsi/scsi_dbg.h>
 #include <scsi/scsi_eh.h>
@@ -254,8 +255,8 @@ struct NCR5380_hostdata {
 #endif
 	unsigned char last_message;		/* last message OUT */
 	struct scsi_cmnd *connected;		/* currently connected cmnd */
-	struct scsi_cmnd *issue_queue;		/* waiting to be issued */
-	struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
+	struct list_head unissued;		/* waiting to be issued */
+	struct list_head disconnected;		/* waiting for reconnect */
 	spinlock_t lock;			/* protects this struct */
 	int flags;
 	struct scsi_eh_save ses;
@@ -277,6 +278,17 @@ struct NCR5380_hostdata {
 
 #ifdef __KERNEL__
 
+struct NCR5380_cmd {
+	struct list_head list;
+};
+
+#define NCR5380_CMD_SIZE		(sizeof(struct NCR5380_cmd))
+
+static inline struct scsi_cmnd *NCR5380_to_scmd(struct NCR5380_cmd *ncmd_ptr)
+{
+	return ((struct scsi_cmnd *)ncmd_ptr) - 1;
+}
+
 #ifndef NDEBUG
 #define NDEBUG (0)
 #endif

commit 5299b3caf525c5a6cdebbe162733c8ff1692c4d0
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:57 2016 +1100

    ncr5380: Remove redundant volatile qualifiers
    
    The hostdata struct is now protected by a spin lock so the volatile
    qualifiers are redundant. Remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 3cfbd3dd9436..87c2f2104e68 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -248,14 +248,14 @@ struct NCR5380_hostdata {
 	NCR5380_implementation_fields;		/* implementation specific */
 	struct Scsi_Host *host;			/* Host backpointer */
 	unsigned char id_mask, id_higher_mask;	/* 1 << id, all bits greater */
-	volatile unsigned char busy[8];		/* index = target, bit = lun */
+	unsigned char busy[8];			/* index = target, bit = lun */
 #if defined(REAL_DMA) || defined(REAL_DMA_POLL)
-	volatile int dma_len;			/* requested length of DMA */
+	int dma_len;				/* requested length of DMA */
 #endif
-	volatile unsigned char last_message;	/* last message OUT */
-	volatile struct scsi_cmnd *connected;	/* currently connected command */
-	volatile struct scsi_cmnd *issue_queue;	/* waiting to be issued */
-	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
+	unsigned char last_message;		/* last message OUT */
+	struct scsi_cmnd *connected;		/* currently connected cmnd */
+	struct scsi_cmnd *issue_queue;		/* waiting to be issued */
+	struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
 	spinlock_t lock;			/* protects this struct */
 	int flags;
 	struct scsi_eh_save ses;

commit dbb6b350695186b340e621f5edf4c31420f9ab23
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:53 2016 +1100

    ncr5380: Remove H_NO macro and introduce dsprintk
    
    Replace all H_NO and some HOSTNO macros (both peculiar to atari_NCR5380.c)
    with a new dsprintk macro that's more useful and more consistent. The new
    macro avoids a lot of boilerplate in new code in subsequent patches. Keep
    NCR5380.c in sync. Remaining HOSTNO macros are removed as side-effects
    of subsequent patches.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index aab360810c43..3cfbd3dd9436 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -285,6 +285,11 @@ struct NCR5380_hostdata {
 	do { if ((NDEBUG) & (flg)) \
 		printk(KERN_DEBUG fmt, ## __VA_ARGS__); } while (0)
 
+#define dsprintk(flg, host, fmt, ...) \
+	do { if ((NDEBUG) & (flg)) \
+		shost_printk(KERN_DEBUG, host, fmt, ## __VA_ARGS__); \
+	} while (0)
+
 #if NDEBUG
 #define NCR5380_dprint(flg, arg) \
 	do { if ((NDEBUG) & (flg)) NCR5380_print(arg); } while (0)

commit 11d2f63b9cf5665ce9dc425236b326dd327c4aa3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:51 2016 +1100

    ncr5380: Change instance->host_lock to hostdata->lock
    
    NCR5380.c presently uses the instance->host_lock spin lock. Convert this
    to a new spin lock that protects the NCR5380_hostdata struct.
    
    atari_NCR5380.c previously used local_irq_save/restore() rather than a
    spin lock. Convert this to hostdata->lock in irq mode. For SMP platforms,
    the interrupt handler now also acquires the spin lock.
    
    This brings all locking in the two core drivers into agreement.
    
    Adding this locking also means that a bunch of volatile qualifiers can be
    removed from the members of the NCR5380_hostdata struct. This is done in
    a subsequent patch.
    
    Proper locking will allow the abort handler to locate a command being
    aborted. This is presently impossible if the abort handler is invoked when
    the command has been moved from a queue to a pointer on the stack. (If
    eh_abort_handler can't determine whether a command has been completed
    or is still being processed then it can't decide whether to return
    success or failure.)
    
    The hostdata spin lock is now held when calling NCR5380_select() and
    NCR5380_information_transfer(). Where possible, the lock is dropped for
    polling and PIO transfers.
    
    Clean up the now-redundant SELECT_ENABLE_REG writes, that used to provide
    limited mutual exclusion between information_transfer() and reselect().
    
    Accessing hostdata->connected without data races means taking the lock;
    cleanup these accesses.
    
    The new spin lock falls away for m68k and other UP builds, so this should
    have little impact there. In the SMP case the new lock should be
    uncontested even when the SCSI bus is contested.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 96fced9e6064..aab360810c43 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -256,6 +256,7 @@ struct NCR5380_hostdata {
 	volatile struct scsi_cmnd *connected;	/* currently connected command */
 	volatile struct scsi_cmnd *issue_queue;	/* waiting to be issued */
 	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
+	spinlock_t lock;			/* protects this struct */
 	int flags;
 	struct scsi_eh_save ses;
 	char info[256];

commit be3f4121aa352d8fef77a57df4b5e106d7f9a917
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:50 2016 +1100

    ncr5380: Remove redundant ICR_ARBITRATION_LOST test and eliminate FLAG_DTC3181E
    
    Remove FLAG_DTC3181E. It was used to suppress a final Arbitration Lost
    (SEL asserted) test that isn't actually needed. The test was suppressed
    because it causes problems for DTC436 and DTC536 chips. It takes place
    after the host wins arbitration, so SEL has been asserted. These chips
    can't seem to tell whether it was the host or another bus device that
    did so.
    
    This questionable final test appears in a flow chart in an early NCR5380
    datasheet. It was removed from later documents like the DP5380 datasheet.
    
    By the time this final test takes place, the driver has already tested
    the Arbitration Lost bit several times. The first test happens 3 us after
    BUS FREE (or longer due to register access delays). The protocol requires
    that a device stop signalling within 1.8 us after BUS FREE unless it won
    arbitration, in which case it must assert SEL, which is detected 1.2 us
    later by the first Arbitration Lost test.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 9777602daa3d..96fced9e6064 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -232,7 +232,6 @@
 
 #define FLAG_NO_DMA_FIXUP		1	/* No DMA errata workarounds */
 #define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
-#define FLAG_DTC3181E			16	/* DTC3181E */
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
 #define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */
 #define FLAG_TOSHIBA_DELAY		128	/* Allow for borken CD-ROMs */

commit 161c0059a2a80aefe7000d9ab7ce5c36e5463b5f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:46 2016 +1100

    ncr5380: Cleanup #include directives
    
    Remove unused includes (stat.h, signal.h, proc_fs.h) and move includes
    needed by the core drivers into the common header (delay.h etc).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index e8a26eab32dd..9777602daa3d 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -22,8 +22,12 @@
 #ifndef NCR5380_H
 #define NCR5380_H
 
+#include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <scsi/scsi_dbg.h>
 #include <scsi/scsi_eh.h>
+#include <scsi/scsi_transport_spi.h>
 
 #define NDEBUG_ARBITRATION	0x1
 #define NDEBUG_AUTOSENSE	0x2

commit 55181be8ced18697e48f75d53028b9ee36522dba
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:42 2016 +1100

    ncr5380: Replace redundant flags with FLAG_NO_DMA_FIXUP
    
    The flags DMA_WORKS_RIGHT, FLAG_NCR53C400 and FLAG_HAS_LAST_BYTE_SENT
    all mean the same thing, i.e. the chip is not a 538[01]. (More recent
    devices such as the 53C80 have a 'Last Byte Sent' bit in the Target
    Command Register as well as other fixes for End-of-DMA errata.)
    
    These flags have no additional meanings since previous cleanup patches
    eliminated the NCR53C400 macro, moved g_NCR5380-specific code out of the
    core driver and standardized interrupt handling.
    
    Use the FLAG_NO_DMA_FIXUP flag to suppress End-of-DMA errata workarounds,
    for those cards and drivers that make use of the TCR_LAST_BYTE_SENT bit.
    Remove the old flags.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 78af75142342..e8a26eab32dd 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -226,9 +226,7 @@
 #define NO_IRQ		0
 #endif
 
-#define FLAG_HAS_LAST_BYTE_SENT		1	/* NCR53c81 or better */
-#define FLAG_CHECK_LAST_BYTE_SENT	2	/* Only test once */
-#define FLAG_NCR53C400			4	/* NCR53c400 */
+#define FLAG_NO_DMA_FIXUP		1	/* No DMA errata workarounds */
 #define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
 #define FLAG_DTC3181E			16	/* DTC3181E */
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */

commit 010e89d18c4e66ab69d64bab439eba988d16fcc9
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:38 2016 +1100

    ncr5380: Standardize work queueing algorithm
    
    The complex main_running/queue_main mechanism is peculiar to
    atari_NCR5380.c. It isn't SMP safe and offers little value given that
    the work queue already offers concurrency management. Remove this
    complexity to bring atari_NCR5380.c closer to NCR5380.c.
    
    It is not a good idea to call the information transfer state machine from
    queuecommand because, according to Documentation/scsi/scsi_mid_low_api.txt
    that could happen in soft irq context. Fix this.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 7ffcb0c33a22..78af75142342 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -262,7 +262,6 @@ struct NCR5380_hostdata {
 	                                   * transfer to handle chip overruns */
 	int retain_dma_intr;
 	struct work_struct main_task;
-	volatile int main_running;
 #ifdef SUPPORT_TAGS
 	struct tag_alloc TagAlloc[8][8];	/* 8 targets and 8 LUNs */
 #endif

commit 8d8601a757688386e914b922cc267a9244e0fdc9
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:37 2016 +1100

    ncr5380: Use work_struct instead of delayed_work
    
    Each host instance now has it's own work queue so the main() work item can
    sleep when necessary. That means we can use a simple work item rather than
    a delayed work item. This brings NCR5380.c closer to atari_NCR5380.c.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 9b7d7671d123..7ffcb0c33a22 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -256,7 +256,6 @@ struct NCR5380_hostdata {
 	volatile struct scsi_cmnd *issue_queue;	/* waiting to be issued */
 	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
 	int flags;
-	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
 	char info[256];
 	int read_overruns;                /* number of bytes to cut from a

commit 686f3990e6a9111f97f2d385f4d1c1a5b0628c15
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:26 2016 +1100

    ncr5380: Rework disconnect versus poll logic
    
    The atari_NCR5380.c and NCR5380.c core drivers differ in their handling of
    target disconnection. This is partly because atari_NCR5380.c had all of
    the polling and sleeping removed to become entirely interrupt-driven, and
    it is partly because of damage done to NCR5380.c after atari_NCR5380.c was
    forked. See commit 37cd23b44929 ("Linux 2.1.105") in history/history.git.
    
    The polling changes that were made in v2.1.105 are questionable at best:
    if REQ is not already asserted when NCR5380_transfer_pio() is invoked, and
    if the expected phase is DATA IN or DATA OUT, the function will schedule
    main() to execute after USLEEP_SLEEP jiffies and then return. The problems
    here are the expected REQ timing and the sleep interval*. Avoid this issue
    by using NCR5380_poll_politely() instead of scheduling main().
    
    The atari_NCR5380.c core driver requires the use of the chip interrupt and
    always permits target disconnection. It sets the cmd->device->disconnect
    flag when a device disconnects, but never tests this flag.
    
    The NCR5380.c core driver permits disconnection only when
    instance->irq != NO_IRQ. It sets the cmd->device->disconnect flag when
    a device disconnects and it tests this flag in a couple of places:
    
    1. During NCR5380_information_transfer(), following COMMAND OUT phase,
       if !cmd->device->disconnect, the initiator will take a guess as to
       whether or not the target will then choose to go to MESSAGE IN phase
       and disconnect. If the driver guesses "yes", it will schedule main()
       to execute after USLEEP_SLEEP jiffies and then return there.
    
       Unfortunately the driver may guess "yes" even after it has denied
       the target the disconnection privilege. When the target does not
       disconnect, the sleep can be beneficial, assuming the sleep interval
       is appropriate (mostly it is not*).
    
       And even if the driver guesses "yes" correctly, and the target would
       then disconnect, the driver still has to go through the MESSAGE IN
       phase in order to get to BUS FREE phase. The main loop can do nothing
       useful until BUS FREE, and sleeping just delays the phase transition.
    
    2. If !cmd->device->disconnect and REQ is not already asserted when
       NCR5380_information_transfer() is invoked, the function polls for REQ
       for USLEEP_POLL jiffies. If REQ is not asserted, it then schedules
       main() to execute after USLEEP_SLEEP jiffies and returns.
    
       The idea is apparently to yeild the CPU while waiting for REQ.
       This is conditional upon !cmd->device->disconnect, but there seems
       to be no rhyme or reason for that. For example, the flag may be
       unset because disconnection privilege was denied because the driver
       has no IRQ. Or the flag may be unset because the device has never
       needed to disconnect before. Or if the flag is set, disconnection
       may have no relevance to the present bus phase.
    
    Another deficiency of the existing algorithm is as follows. When the
    driver has no IRQ, it prevents disconnection, and generally polls and
    sleeps more than it would normally. Now, if the driver is going to poll
    anyway, why not allow the target to disconnect? That way the driver can do
    something useful with the bus instead of polling unproductively!
    
    Avoid this pointless latency, complexity and guesswork by using
    NCR5380_poll_politely() instead of scheduling main().
    
    * For g_NCR5380, the time intervals for USLEEP_SLEEP and USLEEP_POLL are
      200 ms and 10 ms, respectively. They are 20 ms and 200 ms respectively
      for the other NCR5380 drivers. There doesn't seem to be any reason for
      this discrepancy. The timing seems to have no relation to the type of
      adapter. Bizarrely, the timing in g_NCR5380 seems to relate only to one
      particular type of target device. This patch attempts to solve the
      problem for all NCR5380 drivers and all target devices.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index ee084e90e25c..9b7d7671d123 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -205,16 +205,6 @@
 
 #define PHASE_SR_TO_TCR(phase) ((phase) >> 2)
 
-/*
- * The internal should_disconnect() function returns these based on the 
- * expected length of a disconnect if a device supports disconnect/
- * reconnect.
- */
-
-#define DISCONNECT_NONE		0
-#define DISCONNECT_TIME_TO_DATA	1
-#define DISCONNECT_LONG		2
-
 /* 
  * "Special" value for the (unsigned char) command tag, to indicate
  * I_T_L nexus instead of I_T_L_Q.
@@ -266,7 +256,6 @@ struct NCR5380_hostdata {
 	volatile struct scsi_cmnd *issue_queue;	/* waiting to be issued */
 	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
 	int flags;
-	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
 	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
 	char info[256];

commit ae753a3387504daa11b8779a00d37923f971c6d0
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:23 2016 +1100

    ncr5380: Eliminate selecting state
    
    Linux v2.1.105 changed the algorithm for polling for the BSY signal
    in NCR5380_select() and NCR5380_main().
    
    Presently, this code has a bug. Back then, NCR5380_set_timer(hostdata, 1)
    meant reschedule main() after sleeping for 10 ms. Repeated 25 times this
    provided the recommended 250 ms selection time-out delay. This got broken
    when HZ became configurable.
    
    We could fix this but there's no need to reschedule the main loop. This
    BSY polling presently happens when the NCR5380_main() work queue item
    calls NCR5380_select(), which in turn schedules NCR5380_main(), which
    calls NCR5380_select() again, and so on.
    
    This algorithm is a deviation from the simpler one in atari_NCR5380.c.
    The extra complexity and state is pointless. There's no reason to
    stop selection half-way and return to to the main loop when the main
    loop can do nothing useful until selection completes.
    
    So just poll for BSY. We can sleep while polling now that we have a
    suitable workqueue.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 412a344ac676..ee084e90e25c 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -267,8 +267,6 @@ struct NCR5380_hostdata {
 	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
 	int flags;
 	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
-	int select_time;			/* timer in select for target response */
-	volatile struct scsi_cmnd *selecting;
 	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
 	char info[256];

commit 2f854b82b001b5d05b4e1c81acb947f7bd9cee9f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:22 2016 +1100

    ncr5380: Sleep when polling, if possible
    
    When in process context, sleep during polling if doing so won't add
    significant latency. In interrupt context or if the lock is held, poll
    briefly then give up. Keep both core drivers in sync.
    
    Calibrate busy-wait iterations to allow for variation in chip register
    access times between different 5380 hardware implementations.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index f9c861d083d0..412a344ac676 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -285,6 +285,7 @@ struct NCR5380_hostdata {
 	unsigned spin_max_w;
 #endif
 	struct workqueue_struct *work_q;
+	unsigned long accesses_per_ms;	/* chip register accesses per ms */
 };
 
 #ifdef __KERNEL__

commit 0ad0eff98fec3c940ec199047ff580abaaa5bb1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:21 2016 +1100

    ncr5380: Introduce unbound workqueue
    
    Allocate a work queue that will permit busy waiting and sleeping. This
    means NCR5380_init() can potentially fail, so add this error path.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 25e28add0db8..f9c861d083d0 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -284,6 +284,7 @@ struct NCR5380_hostdata {
 	unsigned spin_max_r;
 	unsigned spin_max_w;
 #endif
+	struct workqueue_struct *work_q;
 };
 
 #ifdef __KERNEL__

commit ac9399d09544525ff4713ab942cb44a7cea29a84
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:16 2016 +1100

    ncr5380: Always escalate bad target time-out in NCR5380_select()
    
    Remove the restart_select and targets_present variables introduced in
    Linux v1.1.38. The former was used only for a questionable debug printk
    and the latter "so we can call a select failure a retryable condition".
    Well, retrying select failure in general is a different problem to a
    target that doesn't assert BSY. We need to handle these two cases
    differently; the latter case can be left to the SCSI ML.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 4a31f41b6027..25e28add0db8 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -257,9 +257,6 @@ struct NCR5380_hostdata {
 	NCR5380_implementation_fields;		/* implementation specific */
 	struct Scsi_Host *host;			/* Host backpointer */
 	unsigned char id_mask, id_higher_mask;	/* 1 << id, all bits greater */
-	unsigned char targets_present;		/* targets we have connected
-						   to, so we can call a select
-						   failure a retryable condition */
 	volatile unsigned char busy[8];		/* index = target, bit = lun */
 #if defined(REAL_DMA) || defined(REAL_DMA_POLL)
 	volatile int dma_len;			/* requested length of DMA */
@@ -268,9 +265,6 @@ struct NCR5380_hostdata {
 	volatile struct scsi_cmnd *connected;	/* currently connected command */
 	volatile struct scsi_cmnd *issue_queue;	/* waiting to be issued */
 	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
-	volatile int restart_select;		/* we have disconnected,
-						   used to restart 
-						   NCR5380_select() */
 	int flags;
 	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
 	int select_time;			/* timer in select for target response */

commit 9b68d3415b0838a80f9a32dbedd385bf5d83bef8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:13 2016 +1100

    ncr5380: Remove unused hostdata->aborted flag
    
    The aborted flag was introduced in v1.1.38 but never used. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index f2f737a5f75a..4a31f41b6027 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -271,7 +271,6 @@ struct NCR5380_hostdata {
 	volatile int restart_select;		/* we have disconnected,
 						   used to restart 
 						   NCR5380_select() */
-	volatile unsigned aborted:1;		/* flag, says aborted */
 	int flags;
 	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
 	int select_time;			/* timer in select for target response */

commit 9c3f0e2b52ada30fe72beec27b83e91e12566609
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:11 2016 +1100

    atari_NCR5380: Remove RESET_BOOT, CONFIG_ATARI_SCSI_TOSHIBA_DELAY and CONFIG_ATARI_SCSI_RESET_BOOT
    
    The atari_NCR5380.c core driver now takes care of bus reset upon driver
    initialization if required (same as NCR5380.c). Move the Toshiba CD-ROM
    support into the core driver, enabled with a host flag, so that all
    NCR5380 drivers can make use of it.
    
    Drop the RESET_BOOT macros and the ATARI_SCSI_RESET_BOOT and
    ATARI_SCSI_TOSHIBA_DELAY Kconfig symbols, which are now redundant.
    
    Remove the atari_scsi_reset_boot(), mac_scsi_reset_boot() and
    sun3_scsi_reset_boot() routines. None of this duplicated code is needed
    now that all drivers can use NCR5380_maybe_reset_bus().
    
    This brings atari_scsi, mac_scsi and sun3_scsi into line with all of the
    other NCR5380 drivers.
    
    The bus reset may raise an interrupt. That would be new behaviour for
    atari_scsi only when CONFIG_ATARI_SCSI_RESET_BOOT=n. The ST DMA interrupt
    is not assigned to atari_scsi at this stage, so
    CONFIG_ATARI_SCSI_RESET_BOOT=y may well be problematic already.
    Regardless, do_reset() now raises and clears the interrupt within
    local_irq_save/restore which should avoid problems.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 2057eaa66c20..f2f737a5f75a 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -243,6 +243,7 @@
 #define FLAG_DTC3181E			16	/* DTC3181E */
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
 #define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */
+#define FLAG_TOSHIBA_DELAY		128	/* Allow for borken CD-ROMs */
 
 #ifdef SUPPORT_TAGS
 struct tag_alloc {

commit b6488f97d3b5b602a066956e58a1ba282456d79b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:08 2016 +1100

    ncr5380: Split NCR5380_init() into two functions
    
    This patch splits the NCR5380_init() function into two parts, similar
    to the scheme used with atari_NCR5380.c. This avoids two problems.
    
    Firstly, NCR5380_init() may perform a bus reset, which would cause the
    chip to assert IRQ. The chip is unable to mask its bus reset interrupt.
    Drivers can't call request_irq() before calling NCR5380_init(), because
    initialization must happen before the interrupt handler executes. If
    driver initialization causes an interrupt it may be problematic on some
    platforms. To avoid that, first move the bus reset code into
    NCR5380_maybe_reset_bus().
    
    Secondly, NCR5380_init() contains some board-specific interrupt setup code
    for the NCR53C400 that does not belong in the core driver. In moving this
    code, better not re-order interrupt initialization and bus reset. Again,
    the solution is to move the bus reset code into NCR5380_maybe_reset_bus().
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 24c784140db6..2057eaa66c20 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -318,6 +318,7 @@ static void NCR5380_print(struct Scsi_Host *instance);
 static int NCR5380_probe_irq(struct Scsi_Host *instance, int possible);
 #endif
 static int NCR5380_init(struct Scsi_Host *instance, int flags);
+static int NCR5380_maybe_reset_bus(struct Scsi_Host *);
 static void NCR5380_exit(struct Scsi_Host *instance);
 static void NCR5380_information_transfer(struct Scsi_Host *instance);
 #ifndef DONT_USE_INTR

commit c0965e6371fa50fdf5cc2291915de97412fb1ec9
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:05 2016 +1100

    ncr5380: Remove more pointless macros
    
    ASM macro is never defined. rtrc in pas16.c is not used.
    NCR5380_map_config, do_NCR5380_intr, do_t128_intr and do_pas16_intr
    are unused. NCR_NOT_SET harms readability. Remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 162112dd1bf8..24c784140db6 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -244,8 +244,6 @@
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
 #define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */
 
-#ifndef ASM
-
 #ifdef SUPPORT_TAGS
 struct tag_alloc {
 	DECLARE_BITMAP(allocated, MAX_TAGS);
@@ -443,5 +441,4 @@ static __inline__ int NCR5380_pc_dma_residual(struct Scsi_Host *instance)
 #endif				/* defined(i386) || defined(__alpha__) */
 #endif				/* defined(REAL_DMA)  */
 #endif				/* __KERNEL__ */
-#endif				/* ndef ASM */
 #endif				/* NCR5380_H */

commit a53a21e4662fd2ed27863f511715898459312393
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:21 2014 +1100

    atari_NCR5380: Move static co-routine variables to host data
    
    Unlike NCR5380.c, the atari_NCR5380.c core driver is limited to a single
    instance because co-routine state is stored globally.
    
    Fix this by removing the static scsi host pointer. For the co-routine,
    obtain this pointer from the work_struct pointer instead. For the interrupt
    handler, obtain it from the dev_id argument.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index a6946f2d1dc0..162112dd1bf8 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -283,6 +283,8 @@ struct NCR5380_hostdata {
 	int read_overruns;                /* number of bytes to cut from a
 	                                   * transfer to handle chip overruns */
 	int retain_dma_intr;
+	struct work_struct main_task;
+	volatile int main_running;
 #ifdef SUPPORT_TAGS
 	struct tag_alloc TagAlloc[8][8];	/* 8 targets and 8 LUNs */
 #endif

commit 61d739a4976424af0d2a62d8e8d0b2159702fb45
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:20 2014 +1100

    atari_NCR5380: Move static TagAlloc array to host data
    
    The atari_NCR5380.c core driver keeps some per-host data in a static
    variable which limits the driver to a single instance. Fix this by moving
    TagAlloc to the hostdata struct.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 2fafe1d54fb8..a6946f2d1dc0 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -245,6 +245,15 @@
 #define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */
 
 #ifndef ASM
+
+#ifdef SUPPORT_TAGS
+struct tag_alloc {
+	DECLARE_BITMAP(allocated, MAX_TAGS);
+	int nr_allocated;
+	int queue_size;
+};
+#endif
+
 struct NCR5380_hostdata {
 	NCR5380_implementation_fields;		/* implementation specific */
 	struct Scsi_Host *host;			/* Host backpointer */
@@ -274,6 +283,9 @@ struct NCR5380_hostdata {
 	int read_overruns;                /* number of bytes to cut from a
 	                                   * transfer to handle chip overruns */
 	int retain_dma_intr;
+#ifdef SUPPORT_TAGS
+	struct tag_alloc TagAlloc[8][8];	/* 8 targets and 8 LUNs */
+#endif
 #ifdef PSEUDO_DMA
 	unsigned spin_max_r;
 	unsigned spin_max_w;

commit ca513fc948e66ecdd3c75cca9371762bb4c06776
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:19 2014 +1100

    atari_NCR5380: Introduce FLAG_TAGGED_QUEUING
    
    The static variable setup_use_tagged_queuing is declared in mac_scsi.c,
    sun3_scsi.c and atari_scsi.c and doesn't belong in the core driver.
    None of the other NCR5380 drivers suffer from this layering issue which
    makes merging the core drivers more difficult and will likely hinder plans
    for future use of platform data to configure the driver.
    
    Replace the static variable with a host flag. This way it can be reported
    along with the other flags.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 7b1a0913d94c..2fafe1d54fb8 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -242,6 +242,7 @@
 #define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
 #define FLAG_DTC3181E			16	/* DTC3181E */
 #define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
+#define FLAG_TAGGED_QUEUING		64	/* as X3T9.2 spelled it */
 
 #ifndef ASM
 struct NCR5380_hostdata {

commit ef1081cbf05b22d3d0e05b267a5559a8cd8e8d4a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:14 2014 +1100

    atari_NCR5380: Refactor Falcon special cases
    
    Make the atari_NCR5380.c core driver usable by sun3_scsi, mac_scsi and
    others by moving some of the Falcon-specific code out of the core driver:
    !IS_A_TT, atari_read_overruns and falcon_dont_release. Replace these with
    hostdata variables and flags. FLAG_CHECK_LAST_BYTE_SENT is unused in
    atari_NCR5380.c so don't set it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 11257784b2d7..7b1a0913d94c 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -241,6 +241,7 @@
 #define FLAG_NCR53C400			4	/* NCR53c400 */
 #define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
 #define FLAG_DTC3181E			16	/* DTC3181E */
+#define FLAG_LATE_DMA_SETUP		32	/* Setup NCR before DMA H/W */
 
 #ifndef ASM
 struct NCR5380_hostdata {
@@ -269,6 +270,9 @@ struct NCR5380_hostdata {
 	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
 	char info[256];
+	int read_overruns;                /* number of bytes to cut from a
+	                                   * transfer to handle chip overruns */
+	int retain_dma_intr;
 #ifdef PSEUDO_DMA
 	unsigned spin_max_r;
 	unsigned spin_max_w;

commit 710ddd0d50d22b40e3b644ea35966489ad178978
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:02 2014 +1100

    ncr5380: Drop legacy scsi.h include
    
    Convert Scsi_Cmnd to struct scsi_cmnd and drop the #include "scsi.h".
    The sun3_NCR5380.c core driver already uses struct scsi_cmnd so converting
    the other core drivers reduces the diff which makes them easier to unify.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 81e9c26184c0..11257784b2d7 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -255,9 +255,9 @@ struct NCR5380_hostdata {
 	volatile int dma_len;			/* requested length of DMA */
 #endif
 	volatile unsigned char last_message;	/* last message OUT */
-	volatile Scsi_Cmnd *connected;		/* currently connected command */
-	volatile Scsi_Cmnd *issue_queue;	/* waiting to be issued */
-	volatile Scsi_Cmnd *disconnected_queue;	/* waiting for reconnect */
+	volatile struct scsi_cmnd *connected;	/* currently connected command */
+	volatile struct scsi_cmnd *issue_queue;	/* waiting to be issued */
+	volatile struct scsi_cmnd *disconnected_queue;	/* waiting for reconnect */
 	volatile int restart_select;		/* we have disconnected,
 						   used to restart 
 						   NCR5380_select() */
@@ -265,7 +265,7 @@ struct NCR5380_hostdata {
 	int flags;
 	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
 	int select_time;			/* timer in select for target response */
-	volatile Scsi_Cmnd *selecting;
+	volatile struct scsi_cmnd *selecting;
 	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
 	char info[256];
@@ -309,7 +309,7 @@ static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 static void NCR5380_main(struct work_struct *work);
 static const char *NCR5380_info(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);
-static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd *cmd);
+static int NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd);
 #if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 #endif

commit 96068e6b4d86a397f50ae401723f315110874e1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:01 2014 +1100

    ncr5380: Remove *_RELEASE macros
    
    The *_RELEASE macros don't tell me anything. In some cases the version in
    the macro contradicts the version in the comments. Anyway, the Linux kernel
    version is sufficient information. Remove these macros to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 6bd90eef4460..81e9c26184c0 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -7,8 +7,6 @@
  * 	drew@colorado.edu
  *      +1 (303) 666-5836
  *
- * DISTRIBUTION RELEASE 7
- *
  * For more information, please consult 
  *
  * NCR 5380 Family
@@ -27,9 +25,6 @@
 #include <linux/interrupt.h>
 #include <scsi/scsi_eh.h>
 
-#define NCR5380_PUBLIC_RELEASE 7
-#define NCR53C400_PUBLIC_RELEASE 2
-
 #define NDEBUG_ARBITRATION	0x1
 #define NDEBUG_AUTOSENSE	0x2
 #define NDEBUG_DMA		0x4

commit a9c2dc43c14cc9e9333d451bc4db8a827a695332
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:59 2014 +1100

    ncr5380: Move static PDMA spin counters to host data
    
    Static variables from dtc.c and pas16.c should not appear in the core
    NCR5380.c driver. Aside from being a layering issue this worsens the
    divergence between the three core driver variants (atari_NCR5380.c and
    sun3_NCR5380.c don't support PSEUDO_DMA) and it can mean multiple hosts
    share the same counters.
    
    Fix this by making the pseudo DMA spin counters in the core more generic.
    This also avoids the abuse of the {DTC,PAS16}_PUBLIC_RELEASE macros, so
    they can be removed.
    
    oak.c doesn't use PDMA and hence it doesn't use the counters and hence it
    needs no write_info() method. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index dc37da49656b..6bd90eef4460 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -274,6 +274,10 @@ struct NCR5380_hostdata {
 	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
 	char info[256];
+#ifdef PSEUDO_DMA
+	unsigned spin_max_r;
+	unsigned spin_max_w;
+#endif
 };
 
 #ifdef __KERNEL__

commit 8c32513bd395dc5d382e4883097482567cf8bbc5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:58 2014 +1100

    ncr5380: Cleanup host info() methods
    
    If the host->info() method is not set, then host->name is used by default.
    For atari_scsi, that is exactly the same text. So remove the redundant
    info() method. Keep sun3_scsi.c in line with atari_scsi.
    
    Some NCR5380 drivers return an empty string from the info() method
    (arm/cumana_1.c arm/oak.c mac_scsi.c) while other drivers use the default
    (dmx3191d dtc.c g_NCR5380.c pas16.c t128.c).
    
    Implement a common info() method to replace a lot of duplicated code which
    the various drivers use to announce the same information.
    
    This replaces most of the (deprecated) show_info() output and all of the
    NCR5380_print_info() output. This also eliminates a bunch of code in
    g_NCR5380 which just duplicates functionality in the core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index d811775ffd9d..dc37da49656b 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -273,6 +273,7 @@ struct NCR5380_hostdata {
 	volatile Scsi_Cmnd *selecting;
 	struct delayed_work coroutine;		/* our co-routine */
 	struct scsi_eh_save ses;
+	char info[256];
 };
 
 #ifdef __KERNEL__
@@ -307,7 +308,7 @@ static void NCR5380_information_transfer(struct Scsi_Host *instance);
 static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 #endif
 static void NCR5380_main(struct work_struct *work);
-static void __maybe_unused NCR5380_print_options(struct Scsi_Host *instance);
+static const char *NCR5380_info(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);
 static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd *cmd);
 #if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)

commit 270ac2c290ad8b83c92ceeed07aaf49ec5807851
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:57 2014 +1100

    ncr5380: Remove NCR5380_STATS
    
    The NCR5380_STATS option is only enabled by g_NCR5380 yet it adds
    clutter to all three core drivers. The atari_NCR5380.c and sun3_NCR5380.c
    core drivers have a slightly different implementation of the
    NCR5380_STATS option.
    
    Out of all ten NCR5380 drivers, only one of them (g_NCR5380) actually
    has the code to report on the collected stats. Aside from being unreadable,
    that code seems to be broken because there's no initialization of timebase.
    sun3_NCR5380.c and atari_NCR5380.c have the timebase initialization but
    lack the code to report the stats.
    
    Remove all of this code to improve readability and reduce divergence
    between the three core drivers.
    
    This patch and the next one completely eliminate the PRINTP and ANDP
    pre-processor abuse.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 4b0c628952ee..d811775ffd9d 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -272,15 +272,6 @@ struct NCR5380_hostdata {
 	int select_time;			/* timer in select for target response */
 	volatile Scsi_Cmnd *selecting;
 	struct delayed_work coroutine;		/* our co-routine */
-#ifdef NCR5380_STATS
-	unsigned timebase;			/* Base for time calcs */
-	long time_read[8];			/* time to do reads */
-	long time_write[8];			/* time to do writes */
-	unsigned long bytes_read[8];		/* bytes read */
-	unsigned long bytes_write[8];		/* bytes written */
-	unsigned pendingr;
-	unsigned pendingw;
-#endif
 	struct scsi_eh_save ses;
 };
 

commit 22f5f10d2dadc50bf26a482b782a5e04f6e9b362
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:56 2014 +1100

    ncr5380: Fix SCSI_IRQ_NONE bugs
    
    Oak scsi doesn't use any IRQ, but it sets irq = IRQ_NONE rather than
    SCSI_IRQ_NONE. Problem is, the core NCR5380 driver expects SCSI_IRQ_NONE
    if it is to issue IDENTIFY commands that prevent target disconnection.
    And, as Geert points out, IRQ_NONE is part of enum irqreturn.
    
    Other drivers, when they can't get an IRQ or can't use one, will set
    host->irq = SCSI_IRQ_NONE (that is, 255). But when they exit they will
    attempt to free IRQ 255 which was never requested.
    
    Fix these bugs by using NO_IRQ in place of SCSI_IRQ_NONE and IRQ_NONE.
    That means IRQ 0 is no longer probed by ISA drivers but I don't think
    this matters.
    
    Setting IRQ = 255 for these ISA drivers is understood to mean no IRQ.
    This remains supported so as to avoid breaking existing ISA setups (which
    can be difficult to get working) and because existing documentation
    (SANE, TLDP etc) describes this usage for the ISA NCR5380 driver options.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index f09d560fb6b2..4b0c628952ee 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -232,12 +232,15 @@
  * Scsi_Host structure
  */
 
-#define SCSI_IRQ_NONE	255
 #define DMA_NONE	255
 #define IRQ_AUTO	254
 #define DMA_AUTO	254
 #define PORT_AUTO	0xffff	/* autoprobe io port for 53c400a */
 
+#ifndef NO_IRQ
+#define NO_IRQ		0
+#endif
+
 #define FLAG_HAS_LAST_BYTE_SENT		1	/* NCR53c81 or better */
 #define FLAG_CHECK_LAST_BYTE_SENT	2	/* Only test once */
 #define FLAG_NCR53C400			4	/* NCR53c400 */

commit 997acab7d593913eaa0606ff257079efcfcb146d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:54 2014 +1100

    ncr5380: Remove redundant AUTOSENSE macro
    
    Every NCR5380 driver sets AUTOSENSE so it need not be optional (and the
    mid-layer expects it). Remove this redundant macro to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index b36e3b4a9d43..f09d560fb6b2 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -25,10 +25,7 @@
 #define NCR5380_H
 
 #include <linux/interrupt.h>
-
-#ifdef AUTOSENSE
 #include <scsi/scsi_eh.h>
-#endif
 
 #define NCR5380_PUBLIC_RELEASE 7
 #define NCR53C400_PUBLIC_RELEASE 2
@@ -281,9 +278,7 @@ struct NCR5380_hostdata {
 	unsigned pendingr;
 	unsigned pendingw;
 #endif
-#ifdef AUTOSENSE
 	struct scsi_eh_save ses;
-#endif
 };
 
 #ifdef __KERNEL__

commit 76f13b9321ec8f9550cd1557ed28ac6ae91e612c
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:53 2014 +1100

    ncr5380: Cleanup TAG_NEXT and TAG_NONE macros
    
    Both atari_NCR5380.c and sun3_NCR5380.c core drivers #undef TAG_NONE and
    then redefine it. But the original definition is unused because NCR5380.c
    lacks support for tagged queueing. So just define it once.
    
    The TAG_NEXT macro only appears in the arguments to NCR5380_select() calls.
    But that routine doesn't use its tag argument as the tag was already
    assigned in NCR5380_main(). So remove the unused argument and the macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index b1ed20aaf10e..b36e3b4a9d43 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -224,14 +224,11 @@
 #define DISCONNECT_LONG		2
 
 /* 
- * These are "special" values for the tag parameter passed to NCR5380_select.
+ * "Special" value for the (unsigned char) command tag, to indicate
+ * I_T_L nexus instead of I_T_L_Q.
  */
 
-#define TAG_NEXT	-1	/* Use next free tag */
-#define TAG_NONE	-2	/* 
-				 * Establish I_T_L nexus instead of I_T_L_Q
-				 * even on SCSI-II devices.
-				 */
+#define TAG_NONE	0xff
 
 /*
  * These are "special" values for the irq and dma_channel fields of the 
@@ -323,7 +320,7 @@ static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 static void NCR5380_main(struct work_struct *work);
 static void __maybe_unused NCR5380_print_options(struct Scsi_Host *instance);
 static void NCR5380_reselect(struct Scsi_Host *instance);
-static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd * cmd, int tag);
+static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd *cmd);
 #if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)
 static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
 #endif

commit 4d3d2a54f731aa25f66adcf934ba9a55ca8204d4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:52 2014 +1100

    ncr5380: Remove more useless prototypes
    
    Make use of the host template static initializer instead of assigning
    handlers at run-time. Move __maybe_unused qualifiers from declarations
    to definitions. Move the atari_scsi_bus_reset() wrapper after the
    definition of NCR5380_bus_reset(). All of the host template handler
    prototypes are now redundant so remove them.
    
    The write_info() handler is only relevant to drivers using PSEUDO_DMA so
    this patch fixes the compiler warning in atari_NCR5380.c and sun3_NCR5380.c:
    
      CC      drivers/scsi/atari_scsi.o
      drivers/scsi/NCR5380.h:329: warning: 'NCR5380_write_info' declared 'static' but never defined
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 8b96b687885b..b1ed20aaf10e 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -322,14 +322,6 @@ static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 #endif
 static void NCR5380_main(struct work_struct *work);
 static void __maybe_unused NCR5380_print_options(struct Scsi_Host *instance);
-static int NCR5380_abort(Scsi_Cmnd * cmd);
-static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
-static int NCR5380_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
-static int __maybe_unused NCR5380_show_info(struct seq_file *,
-	struct Scsi_Host *);
-static int __maybe_unused NCR5380_write_info(struct Scsi_Host *instance,
-	char *buffer, int length);
-
 static void NCR5380_reselect(struct Scsi_Host *instance);
 static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd * cmd, int tag);
 #if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)

commit d61c5427f652dd89128f1d2b077aebece3c1a884
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:47 2014 +1100

    ncr5380: Use printk() not pr_debug()
    
    Having defined NDEBUG, and having set the console log level, I'd like to see
    some output. Don't use pr_debug(), it's annoying to have to define DEBUG as
    well.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index c79ddfa6f53c..8b96b687885b 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -296,7 +296,8 @@ struct NCR5380_hostdata {
 #endif
 
 #define dprintk(flg, fmt, ...) \
-	do { if ((NDEBUG) & (flg)) pr_debug(fmt, ## __VA_ARGS__); } while (0)
+	do { if ((NDEBUG) & (flg)) \
+		printk(KERN_DEBUG fmt, ## __VA_ARGS__); } while (0)
 
 #if NDEBUG
 #define NCR5380_dprint(flg, arg) \

commit 16b9d870a0f19f6c1061927a623d9c51c09f2bed
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu May 29 00:43:43 2014 +1000

    scsi/NCR5380: dprintk macro
    
    This is the delta between the two submissions:
    [PATCH 00/12] scsi/NCR5380: fix debugging macros and #include structure
    and
    [PATCH v2 00/12] scsi/NCR5380: fix debugging macros and #include structure
    
    The macro definition changes were discussed on the mailing list during
    review. The idea is to get the compiler to check the parameters of
    disabled printk() calls so that the debugging code doesn't rot again.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 1541c62ddf5f..c79ddfa6f53c 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -295,9 +295,10 @@ struct NCR5380_hostdata {
 #define NDEBUG (0)
 #endif
 
+#define dprintk(flg, fmt, ...) \
+	do { if ((NDEBUG) & (flg)) pr_debug(fmt, ## __VA_ARGS__); } while (0)
+
 #if NDEBUG
-#define dprintk(flg, fmt, args...) \
-	do { if ((NDEBUG) & (flg)) pr_debug(fmt, ## args); } while (0)
 #define NCR5380_dprint(flg, arg) \
 	do { if ((NDEBUG) & (flg)) NCR5380_print(arg); } while (0)
 #define NCR5380_dprint_phase(flg, arg) \
@@ -305,7 +306,6 @@ struct NCR5380_hostdata {
 static void NCR5380_print_phase(struct Scsi_Host *instance);
 static void NCR5380_print(struct Scsi_Host *instance);
 #else
-#define dprintk(flg, fmt, args...)     do {} while (0)
 #define NCR5380_dprint(flg, arg)       do {} while (0)
 #define NCR5380_dprint_phase(flg, arg) do {} while (0)
 #endif

commit 9829e52897359a17169410960e2a9dfcababb83b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:21 2014 +1100

    scsi/NCR5380: fix and standardize NDEBUG macros
    
    All three NCR5380 core driver implementations share the same NCR5380.h
    header file so they need to agree on certain macro definitions.
    
    The flag bit used by the NDEBUG_MERGING macro in atari_NCR5380 and
    sun3_NCR5380 collides with the bit used by NDEBUG_LISTS.
    
    Moreover, NDEBUG_ABORT appears in NCR5380.c so it should be defined in
    NCR5380.h rather than in each of the many drivers using that core.
    
    An undefined NDEBUG_ABORT macro caused compiler errors and led to dodgy
    workarounds in the core driver that can now be removed.
    (See commits f566a576bca09de85bf477fc0ab2c8c96405b77b and
    185a7a1cd79b9891e3c17abdb103ba1c98d6ca7a.)
    
    Move all of the NDEBUG_ABORT, NDEBUG_TAGS and NDEBUG_MERGING macro
    definitions into NCR5380.h where all the other NDEBUG macros live.
    
    Also, incorrect "#ifdef NDEBUG" becomes "#if NDEBUG" to fix the warning:
    drivers/scsi/mac_scsi.c: At top level:
    drivers/scsi/NCR5380.c:418: warning: 'NCR5380_print' defined but not used
    drivers/scsi/NCR5380.c:459: warning: 'NCR5380_print_phase' defined but not used
    
    The debugging code is now enabled when NDEBUG != 0.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 9cb3d316bbce..1541c62ddf5f 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -56,6 +56,9 @@
 #define NDEBUG_C400_PREAD	0x100000
 #define NDEBUG_C400_PWRITE	0x200000
 #define NDEBUG_LISTS		0x400000
+#define NDEBUG_ABORT		0x800000
+#define NDEBUG_TAGS		0x1000000
+#define NDEBUG_MERGING		0x2000000
 
 #define NDEBUG_ANY		0xFFFFFFFFUL
 
@@ -288,9 +291,24 @@ struct NCR5380_hostdata {
 
 #ifdef __KERNEL__
 
+#ifndef NDEBUG
+#define NDEBUG (0)
+#endif
+
+#if NDEBUG
+#define dprintk(flg, fmt, args...) \
+	do { if ((NDEBUG) & (flg)) pr_debug(fmt, ## args); } while (0)
+#define NCR5380_dprint(flg, arg) \
+	do { if ((NDEBUG) & (flg)) NCR5380_print(arg); } while (0)
+#define NCR5380_dprint_phase(flg, arg) \
+	do { if ((NDEBUG) & (flg)) NCR5380_print_phase(arg); } while (0)
+static void NCR5380_print_phase(struct Scsi_Host *instance);
+static void NCR5380_print(struct Scsi_Host *instance);
+#else
 #define dprintk(flg, fmt, args...)     do {} while (0)
 #define NCR5380_dprint(flg, arg)       do {} while (0)
 #define NCR5380_dprint_phase(flg, arg) do {} while (0)
+#endif
 
 #if defined(AUTOPROBE_IRQ)
 static int NCR5380_probe_irq(struct Scsi_Host *instance, int possible);
@@ -303,10 +321,6 @@ static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 #endif
 static void NCR5380_main(struct work_struct *work);
 static void __maybe_unused NCR5380_print_options(struct Scsi_Host *instance);
-#ifdef NDEBUG
-static void NCR5380_print_phase(struct Scsi_Host *instance);
-static void NCR5380_print(struct Scsi_Host *instance);
-#endif
 static int NCR5380_abort(Scsi_Cmnd * cmd);
 static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
 static int NCR5380_queue_command(struct Scsi_Host *, struct scsi_cmnd *);

commit 52a6a1cbd9615d2df59bdf8e77da90371e6a9a84
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:18 2014 +1100

    scsi/NCR5380: fix dprintk macro usage and definition
    
    There are three implementations of the core NCR5380 driver and three sets
    of debugging macro definitions. And all three implementations use the
    NCR5380.h header as well.
    
    Two of the definitions of the dprintk macro accept a variable argument list
    whereas the third does not. Standardize on the variable argument list.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 74994c001ff8..9cb3d316bbce 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -288,9 +288,9 @@ struct NCR5380_hostdata {
 
 #ifdef __KERNEL__
 
-#define dprintk(a,b)			do {} while(0)
-#define NCR5380_dprint(a,b)		do {} while(0)
-#define NCR5380_dprint_phase(a,b)	do {} while(0)
+#define dprintk(flg, fmt, args...)     do {} while (0)
+#define NCR5380_dprint(flg, arg)       do {} while (0)
+#define NCR5380_dprint_phase(flg, arg) do {} while (0)
 
 #if defined(AUTOPROBE_IRQ)
 static int NCR5380_probe_irq(struct Scsi_Host *instance, int possible);

commit 7ac44e061b2eb7871f55f64fe794d221394d126f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:15 2014 +1100

    scsi/NCR5380: remove old CVS keywords
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 14964d0a0e9d..74994c001ff8 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -21,10 +21,6 @@
  * 1+ (800) 334-5454
  */
 
-/*
- * $Log: NCR5380.h,v $
- */
-
 #ifndef NCR5380_H
 #define NCR5380_H
 

commit dd7ab71bb3b4dad7fa1c4fd89706d6870991cfe6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 01:15:54 2013 -0400

    NCR5830: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index fd40a32b1f6f..14964d0a0e9d 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -314,8 +314,10 @@ static void NCR5380_print(struct Scsi_Host *instance);
 static int NCR5380_abort(Scsi_Cmnd * cmd);
 static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
 static int NCR5380_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
-static int __maybe_unused NCR5380_proc_info(struct Scsi_Host *instance,
-	char *buffer, char **start, off_t offset, int length, int inout);
+static int __maybe_unused NCR5380_show_info(struct seq_file *,
+	struct Scsi_Host *);
+static int __maybe_unused NCR5380_write_info(struct Scsi_Host *instance,
+	char *buffer, int length);
 
 static void NCR5380_reselect(struct Scsi_Host *instance);
 static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd * cmd, int tag);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index bdc468c9e1d9..fd40a32b1f6f 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -313,7 +313,7 @@ static void NCR5380_print(struct Scsi_Host *instance);
 #endif
 static int NCR5380_abort(Scsi_Cmnd * cmd);
 static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
-static int NCR5380_queue_command(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *));
+static int NCR5380_queue_command(struct Scsi_Host *, struct scsi_cmnd *);
 static int __maybe_unused NCR5380_proc_info(struct Scsi_Host *instance,
 	char *buffer, char **start, off_t offset, int length, int inout);
 

commit 28424d3a503d43482a5537e556f7b7652d8e56d8
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Mon Sep 10 22:37:45 2007 +0300

    [SCSI] NCR5380: Use scsi_eh API for REQUEST_SENSE invocation
    
      - Use new scsi_eh_prep/restor_cmnd() for synchronous
        REQUEST_SENSE invocation.
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index bccf13f71532..bdc468c9e1d9 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -30,6 +30,10 @@
 
 #include <linux/interrupt.h>
 
+#ifdef AUTOSENSE
+#include <scsi/scsi_eh.h>
+#endif
+
 #define NCR5380_PUBLIC_RELEASE 7
 #define NCR53C400_PUBLIC_RELEASE 2
 
@@ -281,6 +285,9 @@ struct NCR5380_hostdata {
 	unsigned pendingr;
 	unsigned pendingw;
 #endif
+#ifdef AUTOSENSE
+	struct scsi_eh_save ses;
+#endif
 };
 
 #ifdef __KERNEL__

commit 702809ce9b1e91400826ec2ff203c06fdad36034
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed May 23 14:41:56 2007 -0700

    [SCSI] ncr5380 warning fixes
    
    squish these:
    
    drivers/scsi/NCR5380.c:360: warning: 'phases' defined but not used
    drivers/scsi/NCR5380.c:360: warning: 'phases' defined but not used
    drivers/scsi/NCR5380.c:633: warning: 'NCR5380_print_options' defined but not used
    drivers/scsi/NCR5380.c:708: warning: 'NCR5380_proc_info' defined but not used
    drivers/scsi/NCR5380.c:360: warning: 'phases' defined but not used
    drivers/scsi/NCR5380.c:579: warning: 'NCR5380_probe_irq' defined but not used
    drivers/scsi/NCR5380.c:360: warning: 'phases' defined but not used
    drivers/scsi/NCR5380.c:708: warning: 'notyet_generic_proc_info' defined but not used
    drivers/scsi/NCR5380.c:708: warning: 'notyet_generic_proc_info' defined but not used
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 713a108c02ef..bccf13f71532 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -299,7 +299,7 @@ static void NCR5380_information_transfer(struct Scsi_Host *instance);
 static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 #endif
 static void NCR5380_main(struct work_struct *work);
-static void NCR5380_print_options(struct Scsi_Host *instance);
+static void __maybe_unused NCR5380_print_options(struct Scsi_Host *instance);
 #ifdef NDEBUG
 static void NCR5380_print_phase(struct Scsi_Host *instance);
 static void NCR5380_print(struct Scsi_Host *instance);
@@ -307,8 +307,8 @@ static void NCR5380_print(struct Scsi_Host *instance);
 static int NCR5380_abort(Scsi_Cmnd * cmd);
 static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
 static int NCR5380_queue_command(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *));
-static int NCR5380_proc_info(struct Scsi_Host *instance, char *buffer, char **start,
-off_t offset, int length, int inout);
+static int __maybe_unused NCR5380_proc_info(struct Scsi_Host *instance,
+	char *buffer, char **start, off_t offset, int length, int inout);
 
 static void NCR5380_reselect(struct Scsi_Host *instance);
 static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd * cmd, int tag);

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index 1bc73de496b0..713a108c02ef 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -271,7 +271,7 @@ struct NCR5380_hostdata {
 	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
 	int select_time;			/* timer in select for target response */
 	volatile Scsi_Cmnd *selecting;
-	struct work_struct coroutine;		/* our co-routine */
+	struct delayed_work coroutine;		/* our co-routine */
 #ifdef NCR5380_STATS
 	unsigned timebase;			/* Base for time calcs */
 	long time_read[8];			/* time to do reads */
@@ -298,7 +298,7 @@ static void NCR5380_information_transfer(struct Scsi_Host *instance);
 #ifndef DONT_USE_INTR
 static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 #endif
-static void NCR5380_main(void *ptr);
+static void NCR5380_main(struct work_struct *work);
 static void NCR5380_print_options(struct Scsi_Host *instance);
 #ifdef NDEBUG
 static void NCR5380_print_phase(struct Scsi_Host *instance);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index c3462e358d1c..1bc73de496b0 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -296,7 +296,7 @@ static int NCR5380_init(struct Scsi_Host *instance, int flags);
 static void NCR5380_exit(struct Scsi_Host *instance);
 static void NCR5380_information_transfer(struct Scsi_Host *instance);
 #ifndef DONT_USE_INTR
-static irqreturn_t NCR5380_intr(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t NCR5380_intr(int irq, void *dev_id);
 #endif
 static void NCR5380_main(void *ptr);
 static void NCR5380_print_options(struct Scsi_Host *instance);

commit 3471c288036bf0835a82d0b1bbce2002f6e68390
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:52:51 2005 -0400

    [SCSI] Remove no-op implementations of SCSI EH hooks
    
    Drivers need not implement a hook that returns FAILED, and does nothing
    else, since the SCSI midlayer code will do that for us.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
index b5103f94d627..c3462e358d1c 100644
--- a/drivers/scsi/NCR5380.h
+++ b/drivers/scsi/NCR5380.h
@@ -306,8 +306,6 @@ static void NCR5380_print(struct Scsi_Host *instance);
 #endif
 static int NCR5380_abort(Scsi_Cmnd * cmd);
 static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
-static int NCR5380_host_reset(Scsi_Cmnd * cmd);
-static int NCR5380_device_reset(Scsi_Cmnd * cmd);
 static int NCR5380_queue_command(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *));
 static int NCR5380_proc_info(struct Scsi_Host *instance, char *buffer, char **start,
 off_t offset, int length, int inout);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/NCR5380.h b/drivers/scsi/NCR5380.h
new file mode 100644
index 000000000000..b5103f94d627
--- /dev/null
+++ b/drivers/scsi/NCR5380.h
@@ -0,0 +1,432 @@
+/* 
+ * NCR 5380 defines
+ *
+ * Copyright 1993, Drew Eckhardt
+ *	Visionary Computing
+ *	(Unix consulting and custom programming)
+ * 	drew@colorado.edu
+ *      +1 (303) 666-5836
+ *
+ * DISTRIBUTION RELEASE 7
+ *
+ * For more information, please consult 
+ *
+ * NCR 5380 Family
+ * SCSI Protocol Controller
+ * Databook
+ * NCR Microelectronics
+ * 1635 Aeroplaza Drive
+ * Colorado Springs, CO 80916
+ * 1+ (719) 578-3400
+ * 1+ (800) 334-5454
+ */
+
+/*
+ * $Log: NCR5380.h,v $
+ */
+
+#ifndef NCR5380_H
+#define NCR5380_H
+
+#include <linux/interrupt.h>
+
+#define NCR5380_PUBLIC_RELEASE 7
+#define NCR53C400_PUBLIC_RELEASE 2
+
+#define NDEBUG_ARBITRATION	0x1
+#define NDEBUG_AUTOSENSE	0x2
+#define NDEBUG_DMA		0x4
+#define NDEBUG_HANDSHAKE	0x8
+#define NDEBUG_INFORMATION	0x10
+#define NDEBUG_INIT		0x20
+#define NDEBUG_INTR		0x40
+#define NDEBUG_LINKED		0x80
+#define NDEBUG_MAIN		0x100
+#define NDEBUG_NO_DATAOUT	0x200
+#define NDEBUG_NO_WRITE		0x400
+#define NDEBUG_PIO		0x800
+#define NDEBUG_PSEUDO_DMA	0x1000
+#define NDEBUG_QUEUES		0x2000
+#define NDEBUG_RESELECTION	0x4000
+#define NDEBUG_SELECTION	0x8000
+#define NDEBUG_USLEEP		0x10000
+#define NDEBUG_LAST_BYTE_SENT	0x20000
+#define NDEBUG_RESTART_SELECT	0x40000
+#define NDEBUG_EXTENDED		0x80000
+#define NDEBUG_C400_PREAD	0x100000
+#define NDEBUG_C400_PWRITE	0x200000
+#define NDEBUG_LISTS		0x400000
+
+#define NDEBUG_ANY		0xFFFFFFFFUL
+
+/* 
+ * The contents of the OUTPUT DATA register are asserted on the bus when
+ * either arbitration is occurring or the phase-indicating signals (
+ * IO, CD, MSG) in the TARGET COMMAND register and the ASSERT DATA
+ * bit in the INITIATOR COMMAND register is set.
+ */
+
+#define OUTPUT_DATA_REG         0	/* wo DATA lines on SCSI bus */
+#define CURRENT_SCSI_DATA_REG   0	/* ro same */
+
+#define INITIATOR_COMMAND_REG	1	/* rw */
+#define ICR_ASSERT_RST		0x80	/* rw Set to assert RST  */
+#define ICR_ARBITRATION_PROGRESS 0x40	/* ro Indicates arbitration complete */
+#define ICR_TRI_STATE		0x40	/* wo Set to tri-state drivers */
+#define ICR_ARBITRATION_LOST	0x20	/* ro Indicates arbitration lost */
+#define ICR_DIFF_ENABLE		0x20	/* wo Set to enable diff. drivers */
+#define ICR_ASSERT_ACK		0x10	/* rw ini Set to assert ACK */
+#define ICR_ASSERT_BSY		0x08	/* rw Set to assert BSY */
+#define ICR_ASSERT_SEL 		0x04	/* rw Set to assert SEL */
+#define ICR_ASSERT_ATN		0x02	/* rw Set to assert ATN */
+#define ICR_ASSERT_DATA		0x01	/* rw SCSI_DATA_REG is asserted */
+
+#ifdef DIFFERENTIAL
+#define ICR_BASE		ICR_DIFF_ENABLE
+#else
+#define ICR_BASE		0
+#endif
+
+#define MODE_REG		2
+/*
+ * Note : BLOCK_DMA code will keep DRQ asserted for the duration of the 
+ * transfer, causing the chip to hog the bus.  You probably don't want 
+ * this.
+ */
+#define MR_BLOCK_DMA_MODE	0x80	/* rw block mode DMA */
+#define MR_TARGET		0x40	/* rw target mode */
+#define MR_ENABLE_PAR_CHECK	0x20	/* rw enable parity checking */
+#define MR_ENABLE_PAR_INTR	0x10	/* rw enable bad parity interrupt */
+#define MR_ENABLE_EOP_INTR	0x08	/* rw enable eop interrupt */
+#define MR_MONITOR_BSY		0x04	/* rw enable int on unexpected bsy fail */
+#define MR_DMA_MODE		0x02	/* rw DMA / pseudo DMA mode */
+#define MR_ARBITRATE		0x01	/* rw start arbitration */
+
+#ifdef PARITY
+#define MR_BASE			MR_ENABLE_PAR_CHECK
+#else
+#define MR_BASE			0
+#endif
+
+#define TARGET_COMMAND_REG	3
+#define TCR_LAST_BYTE_SENT	0x80	/* ro DMA done */
+#define TCR_ASSERT_REQ		0x08	/* tgt rw assert REQ */
+#define TCR_ASSERT_MSG		0x04	/* tgt rw assert MSG */
+#define TCR_ASSERT_CD		0x02	/* tgt rw assert CD */
+#define TCR_ASSERT_IO		0x01	/* tgt rw assert IO */
+
+#define STATUS_REG		4	/* ro */
+/*
+ * Note : a set bit indicates an active signal, driven by us or another 
+ * device.
+ */
+#define SR_RST			0x80
+#define SR_BSY			0x40
+#define SR_REQ			0x20
+#define SR_MSG			0x10
+#define SR_CD			0x08
+#define SR_IO			0x04
+#define SR_SEL			0x02
+#define SR_DBP			0x01
+
+/*
+ * Setting a bit in this register will cause an interrupt to be generated when 
+ * BSY is false and SEL true and this bit is asserted  on the bus.
+ */
+#define SELECT_ENABLE_REG	4	/* wo */
+
+#define BUS_AND_STATUS_REG	5	/* ro */
+#define BASR_END_DMA_TRANSFER	0x80	/* ro set on end of transfer */
+#define BASR_DRQ		0x40	/* ro mirror of DRQ pin */
+#define BASR_PARITY_ERROR	0x20	/* ro parity error detected */
+#define BASR_IRQ		0x10	/* ro mirror of IRQ pin */
+#define BASR_PHASE_MATCH	0x08	/* ro Set when MSG CD IO match TCR */
+#define BASR_BUSY_ERROR		0x04	/* ro Unexpected change to inactive state */
+#define BASR_ATN 		0x02	/* ro BUS status */
+#define BASR_ACK		0x01	/* ro BUS status */
+
+/* Write any value to this register to start a DMA send */
+#define START_DMA_SEND_REG	5	/* wo */
+
+/* 
+ * Used in DMA transfer mode, data is latched from the SCSI bus on
+ * the falling edge of REQ (ini) or ACK (tgt)
+ */
+#define INPUT_DATA_REG			6	/* ro */
+
+/* Write any value to this register to start a DMA receive */
+#define START_DMA_TARGET_RECEIVE_REG	6	/* wo */
+
+/* Read this register to clear interrupt conditions */
+#define RESET_PARITY_INTERRUPT_REG	7	/* ro */
+
+/* Write any value to this register to start an ini mode DMA receive */
+#define START_DMA_INITIATOR_RECEIVE_REG 7	/* wo */
+
+#define C400_CONTROL_STATUS_REG NCR53C400_register_offset-8	/* rw */
+
+#define CSR_RESET              0x80	/* wo  Resets 53c400 */
+#define CSR_53C80_REG          0x80	/* ro  5380 registers busy */
+#define CSR_TRANS_DIR          0x40	/* rw  Data transfer direction */
+#define CSR_SCSI_BUFF_INTR     0x20	/* rw  Enable int on transfer ready */
+#define CSR_53C80_INTR         0x10	/* rw  Enable 53c80 interrupts */
+#define CSR_SHARED_INTR        0x08	/* rw  Interrupt sharing */
+#define CSR_HOST_BUF_NOT_RDY   0x04	/* ro  Is Host buffer ready */
+#define CSR_SCSI_BUF_RDY       0x02	/* ro  SCSI buffer read */
+#define CSR_GATED_53C80_IRQ    0x01	/* ro  Last block xferred */
+
+#if 0
+#define CSR_BASE CSR_SCSI_BUFF_INTR | CSR_53C80_INTR
+#else
+#define CSR_BASE CSR_53C80_INTR
+#endif
+
+/* Number of 128-byte blocks to be transferred */
+#define C400_BLOCK_COUNTER_REG   NCR53C400_register_offset-7	/* rw */
+
+/* Resume transfer after disconnect */
+#define C400_RESUME_TRANSFER_REG NCR53C400_register_offset-6	/* wo */
+
+/* Access to host buffer stack */
+#define C400_HOST_BUFFER         NCR53C400_register_offset-4	/* rw */
+
+
+/* Note : PHASE_* macros are based on the values of the STATUS register */
+#define PHASE_MASK 	(SR_MSG | SR_CD | SR_IO)
+
+#define PHASE_DATAOUT		0
+#define PHASE_DATAIN		SR_IO
+#define PHASE_CMDOUT		SR_CD
+#define PHASE_STATIN		(SR_CD | SR_IO)
+#define PHASE_MSGOUT		(SR_MSG | SR_CD)
+#define PHASE_MSGIN		(SR_MSG | SR_CD | SR_IO)
+#define PHASE_UNKNOWN		0xff
+
+/* 
+ * Convert status register phase to something we can use to set phase in 
+ * the target register so we can get phase mismatch interrupts on DMA 
+ * transfers.
+ */
+
+#define PHASE_SR_TO_TCR(phase) ((phase) >> 2)
+
+/*
+ * The internal should_disconnect() function returns these based on the 
+ * expected length of a disconnect if a device supports disconnect/
+ * reconnect.
+ */
+
+#define DISCONNECT_NONE		0
+#define DISCONNECT_TIME_TO_DATA	1
+#define DISCONNECT_LONG		2
+
+/* 
+ * These are "special" values for the tag parameter passed to NCR5380_select.
+ */
+
+#define TAG_NEXT	-1	/* Use next free tag */
+#define TAG_NONE	-2	/* 
+				 * Establish I_T_L nexus instead of I_T_L_Q
+				 * even on SCSI-II devices.
+				 */
+
+/*
+ * These are "special" values for the irq and dma_channel fields of the 
+ * Scsi_Host structure
+ */
+
+#define SCSI_IRQ_NONE	255
+#define DMA_NONE	255
+#define IRQ_AUTO	254
+#define DMA_AUTO	254
+#define PORT_AUTO	0xffff	/* autoprobe io port for 53c400a */
+
+#define FLAG_HAS_LAST_BYTE_SENT		1	/* NCR53c81 or better */
+#define FLAG_CHECK_LAST_BYTE_SENT	2	/* Only test once */
+#define FLAG_NCR53C400			4	/* NCR53c400 */
+#define FLAG_NO_PSEUDO_DMA		8	/* Inhibit DMA */
+#define FLAG_DTC3181E			16	/* DTC3181E */
+
+#ifndef ASM
+struct NCR5380_hostdata {
+	NCR5380_implementation_fields;		/* implementation specific */
+	struct Scsi_Host *host;			/* Host backpointer */
+	unsigned char id_mask, id_higher_mask;	/* 1 << id, all bits greater */
+	unsigned char targets_present;		/* targets we have connected
+						   to, so we can call a select
+						   failure a retryable condition */
+	volatile unsigned char busy[8];		/* index = target, bit = lun */
+#if defined(REAL_DMA) || defined(REAL_DMA_POLL)
+	volatile int dma_len;			/* requested length of DMA */
+#endif
+	volatile unsigned char last_message;	/* last message OUT */
+	volatile Scsi_Cmnd *connected;		/* currently connected command */
+	volatile Scsi_Cmnd *issue_queue;	/* waiting to be issued */
+	volatile Scsi_Cmnd *disconnected_queue;	/* waiting for reconnect */
+	volatile int restart_select;		/* we have disconnected,
+						   used to restart 
+						   NCR5380_select() */
+	volatile unsigned aborted:1;		/* flag, says aborted */
+	int flags;
+	unsigned long time_expires;		/* in jiffies, set prior to sleeping */
+	int select_time;			/* timer in select for target response */
+	volatile Scsi_Cmnd *selecting;
+	struct work_struct coroutine;		/* our co-routine */
+#ifdef NCR5380_STATS
+	unsigned timebase;			/* Base for time calcs */
+	long time_read[8];			/* time to do reads */
+	long time_write[8];			/* time to do writes */
+	unsigned long bytes_read[8];		/* bytes read */
+	unsigned long bytes_write[8];		/* bytes written */
+	unsigned pendingr;
+	unsigned pendingw;
+#endif
+};
+
+#ifdef __KERNEL__
+
+#define dprintk(a,b)			do {} while(0)
+#define NCR5380_dprint(a,b)		do {} while(0)
+#define NCR5380_dprint_phase(a,b)	do {} while(0)
+
+#if defined(AUTOPROBE_IRQ)
+static int NCR5380_probe_irq(struct Scsi_Host *instance, int possible);
+#endif
+static int NCR5380_init(struct Scsi_Host *instance, int flags);
+static void NCR5380_exit(struct Scsi_Host *instance);
+static void NCR5380_information_transfer(struct Scsi_Host *instance);
+#ifndef DONT_USE_INTR
+static irqreturn_t NCR5380_intr(int irq, void *dev_id, struct pt_regs *regs);
+#endif
+static void NCR5380_main(void *ptr);
+static void NCR5380_print_options(struct Scsi_Host *instance);
+#ifdef NDEBUG
+static void NCR5380_print_phase(struct Scsi_Host *instance);
+static void NCR5380_print(struct Scsi_Host *instance);
+#endif
+static int NCR5380_abort(Scsi_Cmnd * cmd);
+static int NCR5380_bus_reset(Scsi_Cmnd * cmd);
+static int NCR5380_host_reset(Scsi_Cmnd * cmd);
+static int NCR5380_device_reset(Scsi_Cmnd * cmd);
+static int NCR5380_queue_command(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *));
+static int NCR5380_proc_info(struct Scsi_Host *instance, char *buffer, char **start,
+off_t offset, int length, int inout);
+
+static void NCR5380_reselect(struct Scsi_Host *instance);
+static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd * cmd, int tag);
+#if defined(PSEUDO_DMA) || defined(REAL_DMA) || defined(REAL_DMA_POLL)
+static int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
+#endif
+static int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data);
+
+#if (defined(REAL_DMA) || defined(REAL_DMA_POLL))
+
+#if defined(i386) || defined(__alpha__)
+
+/**
+ *	NCR5380_pc_dma_setup		-	setup ISA DMA
+ *	@instance: adapter to set up
+ *	@ptr: block to transfer (virtual address)
+ *	@count: number of bytes to transfer
+ *	@mode: DMA controller mode to use
+ *
+ *	Program the DMA controller ready to perform an ISA DMA transfer
+ *	on this chip.
+ *
+ *	Locks: takes and releases the ISA DMA lock.
+ */
+ 
+static __inline__ int NCR5380_pc_dma_setup(struct Scsi_Host *instance, unsigned char *ptr, unsigned int count, unsigned char mode)
+{
+	unsigned limit;
+	unsigned long bus_addr = virt_to_bus(ptr);
+	unsigned long flags;
+
+	if (instance->dma_channel <= 3) {
+		if (count > 65536)
+			count = 65536;
+		limit = 65536 - (bus_addr & 0xFFFF);
+	} else {
+		if (count > 65536 * 2)
+			count = 65536 * 2;
+		limit = 65536 * 2 - (bus_addr & 0x1FFFF);
+	}
+
+	if (count > limit)
+		count = limit;
+
+	if ((count & 1) || (bus_addr & 1))
+		panic("scsi%d : attempted unaligned DMA transfer\n", instance->host_no);
+	
+	flags=claim_dma_lock();
+	disable_dma(instance->dma_channel);
+	clear_dma_ff(instance->dma_channel);
+	set_dma_addr(instance->dma_channel, bus_addr);
+	set_dma_count(instance->dma_channel, count);
+	set_dma_mode(instance->dma_channel, mode);
+	enable_dma(instance->dma_channel);
+	release_dma_lock(flags);
+	
+	return count;
+}
+
+/**
+ *	NCR5380_pc_dma_write_setup		-	setup ISA DMA write
+ *	@instance: adapter to set up
+ *	@ptr: block to transfer (virtual address)
+ *	@count: number of bytes to transfer
+ *
+ *	Program the DMA controller ready to perform an ISA DMA write to the
+ *	SCSI controller.
+ *
+ *	Locks: called routines take and release the ISA DMA lock.
+ */
+
+static __inline__ int NCR5380_pc_dma_write_setup(struct Scsi_Host *instance, unsigned char *src, unsigned int count)
+{
+	return NCR5380_pc_dma_setup(instance, src, count, DMA_MODE_WRITE);
+}
+
+/**
+ *	NCR5380_pc_dma_read_setup		-	setup ISA DMA read
+ *	@instance: adapter to set up
+ *	@ptr: block to transfer (virtual address)
+ *	@count: number of bytes to transfer
+ *
+ *	Program the DMA controller ready to perform an ISA DMA read from the
+ *	SCSI controller.
+ *
+ *	Locks: called routines take and release the ISA DMA lock.
+ */
+
+static __inline__ int NCR5380_pc_dma_read_setup(struct Scsi_Host *instance, unsigned char *src, unsigned int count)
+{
+	return NCR5380_pc_dma_setup(instance, src, count, DMA_MODE_READ);
+}
+
+/**
+ *	NCR5380_pc_dma_residual		-	return bytes left 
+ *	@instance: adapter
+ *
+ *	Reports the number of bytes left over after the DMA was terminated.
+ *
+ *	Locks: takes and releases the ISA DMA lock.
+ */
+
+static __inline__ int NCR5380_pc_dma_residual(struct Scsi_Host *instance)
+{
+	unsigned long flags;
+	int tmp;
+
+	flags = claim_dma_lock();
+	clear_dma_ff(instance->dma_channel);
+	tmp = get_dma_residue(instance->dma_channel);
+	release_dma_lock(flags);
+	
+	return tmp;
+}
+#endif				/* defined(i386) || defined(__alpha__) */
+#endif				/* defined(REAL_DMA)  */
+#endif				/* __KERNEL__ */
+#endif				/* ndef ASM */
+#endif				/* NCR5380_H */
