commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 173351a8554b..828d53faf09a 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -72,7 +72,7 @@ static struct scsi_host_template qlogicfas_driver_template = {
 	.can_queue		= 1,
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
-	.use_clustering		= DISABLE_CLUSTERING,
+	.dma_boundary		= PAGE_SIZE - 1,
 };
 
 /*====================================================================*/

commit 5f17af054d6a782e7b582d300274d3143fddba5e
Author: Zhouyang Jia <jiazhouyang09@gmail.com>
Date:   Fri Jun 15 07:41:38 2018 +0800

    pcmcia: add error handling for pcmcia_enable_device in qlogic_stub
    
    When pcmcia_enable_device fails, the lack of error-handling code may
    cause unexpected results.
    
    This patch adds error-handling code after calling pcmcia_enable_device
    in the qlogic_stub scsi driver.
    
    Signed-off-by: Zhouyang Jia <jiazhouyang09@gmail.com>
    Cc: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    [linux@dominikbrodowski.net: update commit message]
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index d4e7e36254b0..173351a8554b 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -254,8 +254,12 @@ static void qlogic_release(struct pcmcia_device *link)
 static int qlogic_resume(struct pcmcia_device *link)
 {
 	scsi_info_t *info = link->priv;
+	int ret;
+
+	ret = pcmcia_enable_device(link);
+	if (ret)
+		return ret;
 
-	pcmcia_enable_device(link);
 	if ((info->manf_id == MANFID_MACNICA) ||
 	    (info->manf_id == MANFID_PIONEER) ||
 	    (info->manf_id == 0x0098)) {

commit dc245cfa82f4dc1e9adf6b9190a9d7dfb1554ecf
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Sat Jul 4 09:19:09 2015 +0530

    pcmcia: Use module_pcmcia_driver for scsi drivers
    
    Use module_pcmcia_driver for drivers whose init and exit functions
    only register and unregister, respectively.
    
    A simplified version of the Coccinelle semantic patch that performs
    this transformation is as follows:
    
    @a@
    identifier f, x;
    @@
    -static f(...) { return pcmcia_register_driver(&x); }
    
    @b depends on a@
    identifier e, a.x;
    @@
    -static e(...) { pcmcia_unregister_driver(&x); }
    
    @c depends on a && b@
    identifier a.f;
    declarer name module_init;
    @@
    -module_init(f);
    
    @d depends on a && b && c@
    identifier b.e, a.x;
    declarer name module_exit;
    declarer name module_pcmcia_driver;
    @@
    -module_exit(e);
    +module_pcmcia_driver(x);
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Cc: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    [linux@dominikbrodowski.net:
     - updated commit message
     - drop change to fdomain which got removed in the meantime]
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 0556054764dc..d4e7e36254b0 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -300,18 +300,7 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	.resume		= qlogic_resume,
 };
 
-static int __init init_qlogic_cs(void)
-{
-	return pcmcia_register_driver(&qlogic_cs_driver);
-}
-
-static void __exit exit_qlogic_cs(void)
-{
-	pcmcia_unregister_driver(&qlogic_cs_driver);
-}
-
 MODULE_AUTHOR("Tom Zerucha, Michael Griffith");
 MODULE_DESCRIPTION("Driver for the PCMCIA Qlogic FAS SCSI controllers");
 MODULE_LICENSE("GPL");
-module_init(init_qlogic_cs);
-module_exit(exit_qlogic_cs);
+module_pcmcia_driver(qlogic_cs_driver);

commit 4a56c1c166b6764f4fb389fbaca6acc75ea215d7
Author: Hannes Reinecke <hare@suse.com>
Date:   Fri Aug 25 13:57:11 2017 +0200

    scsi: qlogicfas: move bus_reset to host_reset
    
    The bus reset handler is really a host reset.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index c670dc704c74..0556054764dc 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -67,7 +67,7 @@ static struct scsi_host_template qlogicfas_driver_template = {
 	.info			= qlogicfas408_info,
 	.queuecommand		= qlogicfas408_queuecommand,
 	.eh_abort_handler	= qlogicfas408_abort,
-	.eh_bus_reset_handler	= qlogicfas408_bus_reset,
+	.eh_host_reset_handler	= qlogicfas408_host_reset,
 	.bios_param		= qlogicfas408_biosparam,
 	.can_queue		= 1,
 	.this_id		= -1,
@@ -264,7 +264,7 @@ static int qlogic_resume(struct pcmcia_device *link)
 		outb(0x04, link->resource[0]->start + 0xd);
 	}
 	/* Ugggglllyyyy!!! */
-	qlogicfas408_bus_reset(NULL);
+	qlogicfas408_host_reset(NULL);
 
 	return 0;
 }

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index bcaf89fe0c9e..c670dc704c74 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -72,7 +72,6 @@ static struct scsi_host_template qlogicfas_driver_template = {
 	.can_queue		= 1,
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
 	.use_clustering		= DISABLE_CLUSTERING,
 };
 

commit 25f8f54f6e178acfd503a95441b0ea05c525f751
Author: Joe Perches <joe@perches.com>
Date:   Tue May 3 19:29:01 2011 -0700

    pcmcia: Convert pcmcia_device_id declarations to const
    
    Saves about 50KB of data.
    
    Old/new size of all objects:
       text    data     bss     dec     hex filename
     563015   80096  130684  773795   bcea3 (TOTALS)
     610916   32256  130632  773804   bceac (TOTALS)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Kurt Van Dijck <kurt.van.dijck@eia.be> (for drivers/net/can/softing/softing_cs.c)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 9c96ca889ec9..bcaf89fe0c9e 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -270,7 +270,7 @@ static int qlogic_resume(struct pcmcia_device *link)
 	return 0;
 }
 
-static struct pcmcia_device_id qlogic_ids[] = {
+static const struct pcmcia_device_id qlogic_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("EIger Labs", "PCMCIA-to-SCSI Adapter", 0x88395fa7, 0x33b7a5e6),
 	PCMCIA_DEVICE_PROD_ID12("EPSON", "SCSI-2 PC Card SC200", 0xd361772f, 0x299d1751),
 	PCMCIA_DEVICE_PROD_ID12("MACNICA", "MIRACLE SCSI-II mPS110", 0x20841b68, 0xab3c3b6d),

commit 2e9b981a7c63ee8278df6823f8389d69dad1a499
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 8 11:36:26 2010 +0200

    pcmcia: move driver name to struct pcmcia_driver
    
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index e8a06e3a384c..9c96ca889ec9 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -294,9 +294,7 @@ MODULE_DEVICE_TABLE(pcmcia, qlogic_ids);
 
 static struct pcmcia_driver qlogic_cs_driver = {
 	.owner		= THIS_MODULE,
-	.drv		= {
 	.name		= "qlogic_cs",
-	},
 	.probe		= qlogic_probe,
 	.remove		= qlogic_detach,
 	.id_table       = qlogic_ids,

commit 00990e7ce0b0e596fe41d9c64d6933ea70084003
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jul 30 13:13:46 2010 +0200

    pcmcia: use autoconfiguration feature for ioports and iomem
    
    When CONF_AUTO_SET_IO or CONF_AUTO_SET_IOMEM are set, the corresponding
    fields in struct pcmcia_device *p_dev->resource[0,1,2] are set
    accordinly. Drivers wishing to override certain settings may do so in
    the callback function, but they no longer need to parse the CIS entries
    stored in cistpl_cftable_entry_t themselves.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: linux-bluetooth@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 468fd12fe98d..e8a06e3a384c 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -155,9 +155,7 @@ static int qlogic_probe(struct pcmcia_device *link)
 		return -ENOMEM;
 	info->p_dev = link;
 	link->priv = info;
-	link->resource[0]->end = 16;
-	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
-	link->config_flags |= CONF_ENABLE_IRQ;
+	link->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;
 	link->config_regs = PRESENT_OPTION;
 
 	return qlogic_config(link);
@@ -176,14 +174,11 @@ static void qlogic_detach(struct pcmcia_device *link)
 
 /*====================================================================*/
 
-static int qlogic_config_check(struct pcmcia_device *p_dev,
-			       cistpl_cftable_entry_t *cfg,
-			       cistpl_cftable_entry_t *dflt,
-			       void *priv_data)
+static int qlogic_config_check(struct pcmcia_device *p_dev, void *priv_data)
 {
 	p_dev->io_lines = 10;
-	p_dev->resource[0]->start = cfg->io.win[0].base;
-	p_dev->resource[0]->end = cfg->io.win[0].len;
+	p_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;
+	p_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
 
 	if (p_dev->resource[0]->start == 0)
 		return -ENODEV;

commit 440eed43e2a95bb842488755683716814da10f2b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jul 30 09:51:52 2010 +0200

    pcmcia: introduce autoconfiguration feature
    
    Introduce an autoconfiguration feature to set certain values in
    pcmcia_loop_config(), instead of copying the same code over and over
    in each PCMCIA driver. At first, introduce the following options:
    
    CONF_AUTO_CHECK_VCC     check or matching Vcc entry
    CONF_AUTO_SET_VPP       set Vpp
    CONF_AUTO_AUDIO         enable the speaker line
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 7d3f49c431fd..468fd12fe98d 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -179,7 +179,6 @@ static void qlogic_detach(struct pcmcia_device *link)
 static int qlogic_config_check(struct pcmcia_device *p_dev,
 			       cistpl_cftable_entry_t *cfg,
 			       cistpl_cftable_entry_t *dflt,
-			       unsigned int vcc,
 			       void *priv_data)
 {
 	p_dev->io_lines = 10;

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 5e2cbe091408..7d3f49c431fd 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -48,7 +48,6 @@
 #include <scsi/scsi_host.h>
 #include "../qlogicfas408.h"
 
-#include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/ds.h>
 #include <pcmcia/ciscode.h>
@@ -158,7 +157,7 @@ static int qlogic_probe(struct pcmcia_device *link)
 	link->priv = info;
 	link->resource[0]->end = 16;
 	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
-	link->conf.Attributes = CONF_ENABLE_IRQ;
+	link->config_flags |= CONF_ENABLE_IRQ;
 	link->config_regs = PRESENT_OPTION;
 
 	return qlogic_config(link);
@@ -208,7 +207,7 @@ static int qlogic_config(struct pcmcia_device * link)
 	if (!link->irq)
 		goto failed;
 
-	ret = pcmcia_request_configuration(link, &link->conf);
+	ret = pcmcia_enable_device(link);
 	if (ret)
 		goto failed;
 
@@ -263,7 +262,7 @@ static int qlogic_resume(struct pcmcia_device *link)
 {
 	scsi_info_t *info = link->priv;
 
-	pcmcia_request_configuration(link, &link->conf);
+	pcmcia_enable_device(link);
 	if ((info->manf_id == MANFID_MACNICA) ||
 	    (info->manf_id == MANFID_PIONEER) ||
 	    (info->manf_id == 0x0098)) {

commit 7feabb6412ea23edd298c0fa90e5aa6733eb4a42
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 18:35:47 2010 +0200

    pcmcia: move config_{base,index,regs} to struct pcmcia_device
    
    Several drivers prefer to explicitly set config_{base,index,regs},
    formerly known as ConfigBase, ConfigIndex and Present. Instead of
    passing these values inside config_req_t, store it in struct
    pcmcia_device.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 77f46a279d6b..5e2cbe091408 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -159,7 +159,7 @@ static int qlogic_probe(struct pcmcia_device *link)
 	link->resource[0]->end = 16;
 	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
 	link->conf.Attributes = CONF_ENABLE_IRQ;
-	link->conf.Present = PRESENT_OPTION;
+	link->config_regs = PRESENT_OPTION;
 
 	return qlogic_config(link);
 }				/* qlogic_attach */

commit 37979e1546a790c44adbc7f27a85569944480ebc
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 16:33:23 2010 +0200

    pcmcia: simplify IntType
    
    IntType was only set to INT_MEMORY (driver pcmciamtd) or INT_MEMORY_AND_IO
    (all other drivers). As this flags seems to relate to ioport access, make
    it conditional to the driver having requested IO port access. There are two
    drivers which do not request IO ports, but did set INT_MEMORY_AND_IO:
    ray_cs and b43. For those, we consistently only set INT_MEMORY in future.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index eb775f1a523c..77f46a279d6b 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -159,7 +159,6 @@ static int qlogic_probe(struct pcmcia_device *link)
 	link->resource[0]->end = 16;
 	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
 	link->conf.Attributes = CONF_ENABLE_IRQ;
-	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
 
 	return qlogic_config(link);

commit 90abdc3b973229bae98dd96649d9f7106cc177a4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 17:23:51 2010 +0200

    pcmcia: do not use io_req_t when calling pcmcia_request_io()
    
    Instead of io_req_t, drivers are now requested to fill out
    struct pcmcia_device *p_dev->resource[0,1] for up to two ioport
    ranges. After a call to pcmcia_request_io(), the ports found there
    are reserved, after calling pcmcia_request_configuration(), they may
    be used.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Michael Buesch <mb@bu3sch.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 4e2b83f26232..eb775f1a523c 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -156,9 +156,8 @@ static int qlogic_probe(struct pcmcia_device *link)
 		return -ENOMEM;
 	info->p_dev = link;
 	link->priv = info;
-	link->io.NumPorts1 = 16;
-	link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
-	link->io.IOAddrLines = 10;
+	link->resource[0]->end = 16;
+	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
@@ -185,13 +184,14 @@ static int qlogic_config_check(struct pcmcia_device *p_dev,
 			       unsigned int vcc,
 			       void *priv_data)
 {
-	p_dev->io.BasePort1 = cfg->io.win[0].base;
-	p_dev->io.NumPorts1 = cfg->io.win[0].len;
+	p_dev->io_lines = 10;
+	p_dev->resource[0]->start = cfg->io.win[0].base;
+	p_dev->resource[0]->end = cfg->io.win[0].len;
 
-	if (p_dev->io.BasePort1 == 0)
+	if (p_dev->resource[0]->start == 0)
 		return -ENODEV;
 
-	return pcmcia_request_io(p_dev, &p_dev->io);
+	return pcmcia_request_io(p_dev);
 }
 
 static int qlogic_config(struct pcmcia_device * link)

commit 9a017a910346afd88ec2e065989903bf211a7d37
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 15:58:54 2010 +0200

    pcmcia: do not use io_req_t after call to pcmcia_request_io()
    
    After pcmcia_request_io(), do not make use of the values stored in
    io_req_t, but instead use those found in struct pcmcia_device->resource[].
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index c1cf7f43313b..4e2b83f26232 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -215,18 +215,18 @@ static int qlogic_config(struct pcmcia_device * link)
 
 	if ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {
 		/* set ATAcmd */
-		outb(0xb4, link->io.BasePort1 + 0xd);
-		outb(0x24, link->io.BasePort1 + 0x9);
-		outb(0x04, link->io.BasePort1 + 0xd);
+		outb(0xb4, link->resource[0]->start + 0xd);
+		outb(0x24, link->resource[0]->start + 0x9);
+		outb(0x04, link->resource[0]->start + 0xd);
 	}
 
 	/* The KXL-810AN has a bigger IO port window */
-	if (link->io.NumPorts1 == 32)
+	if (resource_size(link->resource[0]) == 32)
 		host = qlogic_detect(&qlogicfas_driver_template, link,
-			link->io.BasePort1 + 16, link->irq);
+			link->resource[0]->start + 16, link->irq);
 	else
 		host = qlogic_detect(&qlogicfas_driver_template, link,
-			link->io.BasePort1, link->irq);
+			link->resource[0]->start, link->irq);
 	
 	if (!host) {
 		printk(KERN_INFO "%s: no SCSI devices found\n", qlogic_name);
@@ -268,9 +268,9 @@ static int qlogic_resume(struct pcmcia_device *link)
 	if ((info->manf_id == MANFID_MACNICA) ||
 	    (info->manf_id == MANFID_PIONEER) ||
 	    (info->manf_id == 0x0098)) {
-		outb(0x80, link->io.BasePort1 + 0xd);
-		outb(0x24, link->io.BasePort1 + 0x9);
-		outb(0x04, link->io.BasePort1 + 0xd);
+		outb(0x80, link->resource[0]->start + 0xd);
+		outb(0x24, link->resource[0]->start + 0x9);
+		outb(0x04, link->resource[0]->start + 0xd);
 	}
 	/* Ugggglllyyyy!!! */
 	qlogicfas408_bus_reset(NULL);

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index f0fc6baed9fc..c1cf7f43313b 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -48,7 +48,6 @@
 #include <scsi/scsi_host.h>
 #include "../qlogicfas408.h"
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/ds.h>

commit 317b6d63000b3cc48c43d582d76063500e531a6c
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Mar 20 19:26:51 2010 +0100

    pcmcia: dev_node removal (write-only drivers)
    
    dev_node_t was only used to transport some minor/major numbers
    from the PCMCIA device drivers to deprecated userspace helpers.
    However, only a few drivers made use of it, and the userspace
    helpers are deprecated anyways. Therefore, get rid of dev_node_t .
    
    As a first step, remove any usage of dev_node_t from drivers which
    only wrote to this typedef/struct, but did not make use of it.
    
    CC: linux-bluetooth@vger.kernel.org
    CC: Harald Welte <laforge@gnumonks.org>
    CC: linux-mtd@lists.infradead.org
    CC: linux-wireless@vger.kernel.org
    CC: netdev@vger.kernel.org
    CC: linux-serial@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index c3a4428dbcff..f0fc6baed9fc 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -82,7 +82,6 @@ static struct scsi_host_template qlogicfas_driver_template = {
 
 typedef struct scsi_info_t {
 	struct pcmcia_device	*p_dev;
-	dev_node_t node;
 	struct Scsi_Host *host;
 	unsigned short manf_id;
 } scsi_info_t;
@@ -235,8 +234,6 @@ static int qlogic_config(struct pcmcia_device * link)
 		goto failed;
 	}
 
-	sprintf(info->node.dev_name, "scsi%d", host->host_no);
-	link->dev_node = &info->node;
 	info->host = host;
 
 	return 0;

commit eb14120f743d29744d9475bffec56ff4ad43a749
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 7 12:21:16 2010 +0100

    pcmcia: re-work pcmcia_request_irq()
    
    Instead of the old pcmcia_request_irq() interface, drivers may now
    choose between:
    
    - calling request_irq/free_irq directly. Use the IRQ from *p_dev->irq.
    
    - use pcmcia_request_irq(p_dev, handler_t); the PCMCIA core will
      clean up automatically on calls to pcmcia_disable_device() or
      device ejection.
    
    - drivers still not capable of IRQF_SHARED (or not telling us so) may
      use the deprecated pcmcia_request_exclusive_irq() for the time
      being; they might receive a shared IRQ nonetheless.
    
    CC: linux-bluetooth@vger.kernel.org
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-serial@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: linux-usb@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index f85f094870b4..c3a4428dbcff 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -161,7 +161,6 @@ static int qlogic_probe(struct pcmcia_device *link)
 	link->io.NumPorts1 = 16;
 	link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
 	link->io.IOAddrLines = 10;
-	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
@@ -209,8 +208,7 @@ static int qlogic_config(struct pcmcia_device * link)
 	if (ret)
 		goto failed;
 
-	ret = pcmcia_request_irq(link, &link->irq);
-	if (ret)
+	if (!link->irq)
 		goto failed;
 
 	ret = pcmcia_request_configuration(link, &link->conf);
@@ -227,10 +225,10 @@ static int qlogic_config(struct pcmcia_device * link)
 	/* The KXL-810AN has a bigger IO port window */
 	if (link->io.NumPorts1 == 32)
 		host = qlogic_detect(&qlogicfas_driver_template, link,
-			link->io.BasePort1 + 16, link->irq.AssignedIRQ);
+			link->io.BasePort1 + 16, link->irq);
 	else
 		host = qlogic_detect(&qlogicfas_driver_template, link,
-			link->io.BasePort1, link->irq.AssignedIRQ);
+			link->io.BasePort1, link->irq);
 	
 	if (!host) {
 		printk(KERN_INFO "%s: no SCSI devices found\n", qlogic_name);
@@ -258,7 +256,7 @@ static void qlogic_release(struct pcmcia_device *link)
 
 	scsi_remove_host(info->host);
 
-	free_irq(link->irq.AssignedIRQ, info->host);
+	free_irq(link->irq, info->host);
 	pcmcia_disable_device(link);
 
 	scsi_host_put(info->host);

commit 5fa9167a1bf5f5a4b7282f5e7ac56a4a5a1fa044
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Nov 8 17:24:46 2009 +0100

    pcmcia: rework the irq_req_t typedef
    
    Most of the irq_req_t typedef'd struct can be re-worked quite
    easily:
    
    (1) IRQInfo2 was unused in any case, so drop it.
    
    (2) IRQInfo1 was used write-only, so drop it.
    
    (3) Instance (private data to be passed to the IRQ handler):
            Most PCMCIA drivers using pcmcia_request_irq() to actually
            register an IRQ handler set the "dev_id" to the same pointer
            as the "priv" pointer in struct pcmcia_device. Modify the two
            exceptions (ipwireless, ibmtr_cs) to also work this waym and
            set the IRQ handler's "dev_id" to p_dev->priv unconditionally.
    
    (4) Handler is to be of type irq_handler_t.
    
    (5) Handler != NULL already tells whether an IRQ handler is present.
            Therefore, we do not need the IRQ_HANDLER_PRESENT flag in
            irq_req_t.Attributes.
    
    CC: netdev@vger.kernel.org
    CC: linux-bluetooth@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-scsi@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: Jaroslav Kysela <perex@perex.cz>
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: Karsten Keil <isdn@linux-pingi.de>
    for the Bluetooth parts: Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 65d7ad58433f..f85f094870b4 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -162,7 +162,6 @@ static int qlogic_probe(struct pcmcia_device *link)
 	link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
 	link->io.IOAddrLines = 10;
 	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
-	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
 	link->conf.Attributes = CONF_ENABLE_IRQ;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;

commit 3e7166178a83fef690dcbfcdaeda192f7282a9a4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Oct 24 15:54:14 2009 +0200

    pcmcia: use dynamic debug infrastructure, deprecate CS_CHECK (scsi)
    
    Convert PCMCIA drivers to use the dynamic debug infrastructure, instead of
    requiring manual settings of PCMCIA_DEBUG.
    
    Also, remove all usages of the CS_CHECK macro and replace them with proper
    Linux style calling and return value checking. The extra error reporting may
    be dropped, as the PCMCIA core already complains about any (non-driver-author)
    errors.
    
    CC: linux-scsi@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 20c3e5e6d88a..65d7ad58433f 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -62,15 +62,6 @@
 
 static char qlogic_name[] = "qlogic_cs";
 
-#ifdef PCMCIA_DEBUG
-static int pc_debug = PCMCIA_DEBUG;
-module_param(pc_debug, int, 0644);
-#define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
-static char *version = "qlogic_cs.c 1.79-ac 2002/10/26 (David Hinds)";
-#else
-#define DEBUG(n, args...)
-#endif
-
 static struct scsi_host_template qlogicfas_driver_template = {
 	.module			= THIS_MODULE,
 	.name			= qlogic_name,
@@ -159,7 +150,7 @@ static int qlogic_probe(struct pcmcia_device *link)
 {
 	scsi_info_t *info;
 
-	DEBUG(0, "qlogic_attach()\n");
+	dev_dbg(&link->dev, "qlogic_attach()\n");
 
 	/* Create new SCSI device */
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
@@ -183,7 +174,7 @@ static int qlogic_probe(struct pcmcia_device *link)
 
 static void qlogic_detach(struct pcmcia_device *link)
 {
-	DEBUG(0, "qlogic_detach(0x%p)\n", link);
+	dev_dbg(&link->dev, "qlogic_detach\n");
 
 	qlogic_release(link);
 	kfree(link->priv);
@@ -192,9 +183,6 @@ static void qlogic_detach(struct pcmcia_device *link)
 
 /*====================================================================*/
 
-#define CS_CHECK(fn, ret) \
-do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
-
 static int qlogic_config_check(struct pcmcia_device *p_dev,
 			       cistpl_cftable_entry_t *cfg,
 			       cistpl_cftable_entry_t *dflt,
@@ -213,19 +201,22 @@ static int qlogic_config_check(struct pcmcia_device *p_dev,
 static int qlogic_config(struct pcmcia_device * link)
 {
 	scsi_info_t *info = link->priv;
-	int last_ret, last_fn;
+	int ret;
 	struct Scsi_Host *host;
 
-	DEBUG(0, "qlogic_config(0x%p)\n", link);
+	dev_dbg(&link->dev, "qlogic_config\n");
 
-	last_ret = pcmcia_loop_config(link, qlogic_config_check, NULL);
-	if (last_ret) {
-		cs_error(link, RequestIO, last_ret);
+	ret = pcmcia_loop_config(link, qlogic_config_check, NULL);
+	if (ret)
+		goto failed;
+
+	ret = pcmcia_request_irq(link, &link->irq);
+	if (ret)
 		goto failed;
-	}
 
-	CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
-	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
+	ret = pcmcia_request_configuration(link, &link->conf);
+	if (ret)
+		goto failed;
 
 	if ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {
 		/* set ATAcmd */
@@ -244,7 +235,7 @@ static int qlogic_config(struct pcmcia_device * link)
 	
 	if (!host) {
 		printk(KERN_INFO "%s: no SCSI devices found\n", qlogic_name);
-		goto cs_failed;
+		goto failed;
 	}
 
 	sprintf(info->node.dev_name, "scsi%d", host->host_no);
@@ -253,12 +244,9 @@ static int qlogic_config(struct pcmcia_device * link)
 
 	return 0;
 
-cs_failed:
-	cs_error(link, last_fn, last_ret);
-	pcmcia_disable_device(link);
 failed:
+	pcmcia_disable_device(link);
 	return -ENODEV;
-
 }				/* qlogic_config */
 
 /*====================================================================*/
@@ -267,7 +255,7 @@ static void qlogic_release(struct pcmcia_device *link)
 {
 	scsi_info_t *info = link->priv;
 
-	DEBUG(0, "qlogic_release(0x%p)\n", link);
+	dev_dbg(&link->dev, "qlogic_release\n");
 
 	scsi_remove_host(info->host);
 

commit ad913c11928f51abb6174f165db8d8d205b22e21
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 2 16:12:00 2008 +0200

    pcmcia: pcmcia_config_loop() improvement by passing vcc
    
    By passing the current Vcc setting to the pcmcia_config_loop callback
    function, we can remove pcmcia_get_configuration_info() calls from many
    drivers.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index da6b3603198b..20c3e5e6d88a 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -198,6 +198,7 @@ do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 static int qlogic_config_check(struct pcmcia_device *p_dev,
 			       cistpl_cftable_entry_t *cfg,
 			       cistpl_cftable_entry_t *dflt,
+			       unsigned int vcc,
 			       void *priv_data)
 {
 	p_dev->io.BasePort1 = cfg->io.win[0].base;

commit 8e2fc39ddea7fe8c6798837da282db88a09af793
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 2 15:30:31 2008 +0200

    pcmcia: pcmcia_config_loop() default CIS entry handling
    
    Many drivers use the default CIS entry within their pcmcia_config_loop()
    callback function. Therefore, factor the default CIS entry handling out.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index a361275b20a3..da6b3603198b 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -196,8 +196,9 @@ static void qlogic_detach(struct pcmcia_device *link)
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 
 static int qlogic_config_check(struct pcmcia_device *p_dev,
-				  cistpl_cftable_entry_t *cfg,
-				  void *priv_data)
+			       cistpl_cftable_entry_t *cfg,
+			       cistpl_cftable_entry_t *dflt,
+			       void *priv_data)
 {
 	p_dev->io.BasePort1 = cfg->io.win[0].base;
 	p_dev->io.NumPorts1 = cfg->io.win[0].len;

commit 498ac1899b62626bf6879a251d75c22ec564c559
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 2 14:59:13 2008 +0200

    pcmcia: pcmcia_config_loop() ConfigIndex unification
    
    Almost all drivers set p_dev->conf.ConfigIndex to cfg->index in
    the pcmcia_config_loop() callback function. Therefore, factor it out.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index aa9b9e0968b6..a361275b20a3 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -199,7 +199,6 @@ static int qlogic_config_check(struct pcmcia_device *p_dev,
 				  cistpl_cftable_entry_t *cfg,
 				  void *priv_data)
 {
-	p_dev->conf.ConfigIndex = cfg->index;
 	p_dev->io.BasePort1 = cfg->io.win[0].base;
 	p_dev->io.NumPorts1 = cfg->io.win[0].len;
 

commit 0e6f9d2708409cd8e864cdb94edbe599872a19d1
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Jul 29 08:38:55 2008 +0200

    pcmcia: use pcmcia_loop_config in scsi pcmcia drivers
    
    Use the config loop helper in scsi pcmcia drivers.
    
    CC: James E.J. Bottomley <James.Bottomley@HansenPartnership.com>
    CC: linux-scsi@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 67c5a58d17df..aa9b9e0968b6 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -195,39 +195,32 @@ static void qlogic_detach(struct pcmcia_device *link)
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 
+static int qlogic_config_check(struct pcmcia_device *p_dev,
+				  cistpl_cftable_entry_t *cfg,
+				  void *priv_data)
+{
+	p_dev->conf.ConfigIndex = cfg->index;
+	p_dev->io.BasePort1 = cfg->io.win[0].base;
+	p_dev->io.NumPorts1 = cfg->io.win[0].len;
+
+	if (p_dev->io.BasePort1 == 0)
+		return -ENODEV;
+
+	return pcmcia_request_io(p_dev, &p_dev->io);
+}
+
 static int qlogic_config(struct pcmcia_device * link)
 {
 	scsi_info_t *info = link->priv;
-	tuple_t tuple;
-	cisparse_t parse;
-	int i, last_ret, last_fn;
-	unsigned short tuple_data[32];
+	int last_ret, last_fn;
 	struct Scsi_Host *host;
 
 	DEBUG(0, "qlogic_config(0x%p)\n", link);
 
-	info->manf_id = link->manf_id;
-
-	tuple.TupleData = (cisdata_t *) tuple_data;
-	tuple.TupleDataMax = 64;
-	tuple.TupleOffset = 0;
-
-	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	while (1) {
-		if (pcmcia_get_tuple_data(link, &tuple) != 0 ||
-				pcmcia_parse_tuple(link, &tuple, &parse) != 0)
-			goto next_entry;
-		link->conf.ConfigIndex = parse.cftable_entry.index;
-		link->io.BasePort1 = parse.cftable_entry.io.win[0].base;
-		link->io.NumPorts1 = parse.cftable_entry.io.win[0].len;
-		if (link->io.BasePort1 != 0) {
-			i = pcmcia_request_io(link, &link->io);
-			if (i == CS_SUCCESS)
-				break;
-		}
-	      next_entry:
-		CS_CHECK(GetNextTuple, pcmcia_get_next_tuple(link, &tuple));
+	last_ret = pcmcia_loop_config(link, qlogic_config_check, NULL);
+	if (last_ret) {
+		cs_error(link, RequestIO, last_ret);
+		goto failed;
 	}
 
 	CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
@@ -262,6 +255,7 @@ static int qlogic_config(struct pcmcia_device * link)
 cs_failed:
 	cs_error(link, last_fn, last_ret);
 	pcmcia_disable_device(link);
+failed:
 	return -ENODEV;
 
 }				/* qlogic_config */

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 697cfb76c3a4..67c5a58d17df 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -162,10 +162,9 @@ static int qlogic_probe(struct pcmcia_device *link)
 	DEBUG(0, "qlogic_attach()\n");
 
 	/* Create new SCSI device */
-	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
-	memset(info, 0, sizeof(*info));
 	info->p_dev = link;
 	link->priv = info;
 	link->io.NumPorts1 = 16;

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 9d431fe7f47f..697cfb76c3a4 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -34,7 +34,6 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/ioport.h>

commit af2b3b503ad1b071b66e1531caae252b4b95c847
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Oct 25 21:49:27 2006 -0400

    [PATCH] pcmcia: conf.ConfigBase and conf.Present consolidation
    
    struct pcmcia_device *p_dev->conf.ConfigBase and .Present are set in almost
    all PCMICA driver right at the beginning, using the same calls but slightly
    different implementations. Unfiy this in the PCMCIA core.
    
    Includes a small bugfix ("drivers/net/pcmcia/xirc2ps_cs.c: remove unused
    label") from and Signed-off-by Adrian Bunk <bunk@stusta.de>
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 336e370f7f65..9d431fe7f47f 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -208,16 +208,11 @@ static int qlogic_config(struct pcmcia_device * link)
 
 	DEBUG(0, "qlogic_config(0x%p)\n", link);
 
+	info->manf_id = link->manf_id;
+
 	tuple.TupleData = (cisdata_t *) tuple_data;
 	tuple.TupleDataMax = 64;
 	tuple.TupleOffset = 0;
-	tuple.DesiredTuple = CISTPL_CONFIG;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-	CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
-	link->conf.ConfigBase = parse.config.base;
-
-	info->manf_id = link->manf_id;
 
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));

commit efd50585e2ff9bd60e044fda7764d323010a7fe4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Oct 25 21:28:53 2006 -0400

    [PATCH] pcmcia: remove manf_id and card_id indirection
    
    As we read out the manufactor and card_id from the PCMCIA device in the
    PCMCIA core, and device drivers can access those reliably in struct
    pcmcia_device's fields manf_id and card_id, remove additional (and partly
    broken) manf_id and card_id detection logic from PCMCIA device drivers.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 86c2ac6ae623..336e370f7f65 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -217,9 +217,7 @@ static int qlogic_config(struct pcmcia_device * link)
 	CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
 	link->conf.ConfigBase = parse.config.base;
 
-	tuple.DesiredTuple = CISTPL_MANFID;
-	if ((pcmcia_get_first_tuple(link, &tuple) == CS_SUCCESS) && (pcmcia_get_tuple_data(link, &tuple) == CS_SUCCESS))
-		info->manf_id = le16_to_cpu(tuple.TupleData[0]);
+	info->manf_id = link->manf_id;
 
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));

commit e2d4096365e06b9a3799afbadc28b4519c0b3526
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Mar 2 00:09:29 2006 +0100

    [PATCH] pcmcia: use bitfield instead of p_state and state
    
    Instead of the two status values struct pcmcia_device->p_state and state,
    use descriptive bitfields. Most value-checking in drivers was invalid, as
    the core now only calls the ->remove() (a.k.a. detach) function in case the
    attachement _and_ configuration was successful.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 61c2eb03a9b5..86c2ac6ae623 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -178,7 +178,6 @@ static int qlogic_probe(struct pcmcia_device *link)
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
 
-	link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
 	return qlogic_config(link);
 }				/* qlogic_attach */
 
@@ -188,9 +187,7 @@ static void qlogic_detach(struct pcmcia_device *link)
 {
 	DEBUG(0, "qlogic_detach(0x%p)\n", link);
 
-	if (link->state & DEV_CONFIG)
-		qlogic_release(link);
-
+	qlogic_release(link);
 	kfree(link->priv);
 
 }				/* qlogic_detach */
@@ -224,9 +221,6 @@ static int qlogic_config(struct pcmcia_device * link)
 	if ((pcmcia_get_first_tuple(link, &tuple) == CS_SUCCESS) && (pcmcia_get_tuple_data(link, &tuple) == CS_SUCCESS))
 		info->manf_id = le16_to_cpu(tuple.TupleData[0]);
 
-	/* Configure card */
-	link->state |= DEV_CONFIG;
-
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
 	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
 	while (1) {
@@ -272,7 +266,6 @@ static int qlogic_config(struct pcmcia_device * link)
 	link->dev_node = &info->node;
 	info->host = host;
 
-	link->state &= ~DEV_CONFIG_PENDING;
 	return 0;
 
 cs_failed:
@@ -302,20 +295,18 @@ static void qlogic_release(struct pcmcia_device *link)
 
 static int qlogic_resume(struct pcmcia_device *link)
 {
-	if (link->state & DEV_CONFIG) {
-		scsi_info_t *info = link->priv;
-
-		pcmcia_request_configuration(link, &link->conf);
-		if ((info->manf_id == MANFID_MACNICA) ||
-		    (info->manf_id == MANFID_PIONEER) ||
-		    (info->manf_id == 0x0098)) {
-			outb(0x80, link->io.BasePort1 + 0xd);
-			outb(0x24, link->io.BasePort1 + 0x9);
-			outb(0x04, link->io.BasePort1 + 0xd);
-		}
-		/* Ugggglllyyyy!!! */
-		qlogicfas408_bus_reset(NULL);
+	scsi_info_t *info = link->priv;
+
+	pcmcia_request_configuration(link, &link->conf);
+	if ((info->manf_id == MANFID_MACNICA) ||
+	    (info->manf_id == MANFID_PIONEER) ||
+	    (info->manf_id == 0x0098)) {
+		outb(0x80, link->io.BasePort1 + 0xd);
+		outb(0x24, link->io.BasePort1 + 0x9);
+		outb(0x04, link->io.BasePort1 + 0xd);
 	}
+	/* Ugggglllyyyy!!! */
+	qlogicfas408_bus_reset(NULL);
 
 	return 0;
 }

commit 15b99ac1729503db9e6dc642a50b9b6cb3bf51f9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Mar 31 17:26:06 2006 +0200

    [PATCH] pcmcia: add return value to _config() functions
    
    Most of the driver initialization isn't done in the .probe function, but in
    the internal _config() functions. Make them return a value, so that .probe
    can properly report whether the probing of the device succeeded or not.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index a2a1c4b318e6..61c2eb03a9b5 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -99,7 +99,7 @@ typedef struct scsi_info_t {
 
 static void qlogic_release(struct pcmcia_device *link);
 static void qlogic_detach(struct pcmcia_device *p_dev);
-static void qlogic_config(struct pcmcia_device * link);
+static int qlogic_config(struct pcmcia_device * link);
 
 static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 				struct pcmcia_device *link, int qbase, int qlirq)
@@ -156,7 +156,7 @@ static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 err:
 	return NULL;
 }
-static int qlogic_attach(struct pcmcia_device *link)
+static int qlogic_probe(struct pcmcia_device *link)
 {
 	scsi_info_t *info;
 
@@ -179,9 +179,7 @@ static int qlogic_attach(struct pcmcia_device *link)
 	link->conf.Present = PRESENT_OPTION;
 
 	link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
-	qlogic_config(link);
-
-	return 0;
+	return qlogic_config(link);
 }				/* qlogic_attach */
 
 /*====================================================================*/
@@ -202,7 +200,7 @@ static void qlogic_detach(struct pcmcia_device *link)
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 
-static void qlogic_config(struct pcmcia_device * link)
+static int qlogic_config(struct pcmcia_device * link)
 {
 	scsi_info_t *info = link->priv;
 	tuple_t tuple;
@@ -267,21 +265,20 @@ static void qlogic_config(struct pcmcia_device * link)
 	
 	if (!host) {
 		printk(KERN_INFO "%s: no SCSI devices found\n", qlogic_name);
-		goto out;
+		goto cs_failed;
 	}
 
 	sprintf(info->node.dev_name, "scsi%d", host->host_no);
 	link->dev_node = &info->node;
 	info->host = host;
 
-out:
 	link->state &= ~DEV_CONFIG_PENDING;
-	return;
+	return 0;
 
 cs_failed:
 	cs_error(link, last_fn, last_ret);
 	pcmcia_disable_device(link);
-	return;
+	return -ENODEV;
 
 }				/* qlogic_config */
 
@@ -350,7 +347,7 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	.drv		= {
 	.name		= "qlogic_cs",
 	},
-	.probe		= qlogic_attach,
+	.probe		= qlogic_probe,
 	.remove		= qlogic_detach,
 	.id_table       = qlogic_ids,
 	.resume		= qlogic_resume,

commit fba395eee7d3f342ca739c20f5b3ee635d0420a0
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Mar 31 17:21:06 2006 +0200

    [PATCH] pcmcia: remove dev_link_t and client_handle_t indirection
    
    dev_link_t * and client_handle_t both mean struct pcmcai_device * by now.
    Therefore, remove all such indirections.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index c6b3e9587ff3..a2a1c4b318e6 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -97,12 +97,12 @@ typedef struct scsi_info_t {
 	unsigned short manf_id;
 } scsi_info_t;
 
-static void qlogic_release(dev_link_t *link);
+static void qlogic_release(struct pcmcia_device *link);
 static void qlogic_detach(struct pcmcia_device *p_dev);
-static void qlogic_config(dev_link_t * link);
+static void qlogic_config(struct pcmcia_device * link);
 
 static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
-				dev_link_t *link, int qbase, int qlirq)
+				struct pcmcia_device *link, int qbase, int qlirq)
 {
 	int qltyp;		/* type of chip */
 	int qinitid;
@@ -156,10 +156,9 @@ static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 err:
 	return NULL;
 }
-static int qlogic_attach(struct pcmcia_device *p_dev)
+static int qlogic_attach(struct pcmcia_device *link)
 {
 	scsi_info_t *info;
-	dev_link_t *link = dev_to_instance(p_dev);
 
 	DEBUG(0, "qlogic_attach()\n");
 
@@ -168,7 +167,7 @@ static int qlogic_attach(struct pcmcia_device *p_dev)
 	if (!info)
 		return -ENOMEM;
 	memset(info, 0, sizeof(*info));
-	info->p_dev = p_dev;
+	info->p_dev = link;
 	link->priv = info;
 	link->io.NumPorts1 = 16;
 	link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
@@ -187,10 +186,8 @@ static int qlogic_attach(struct pcmcia_device *p_dev)
 
 /*====================================================================*/
 
-static void qlogic_detach(struct pcmcia_device *p_dev)
+static void qlogic_detach(struct pcmcia_device *link)
 {
-	dev_link_t *link = dev_to_instance(p_dev);
-
 	DEBUG(0, "qlogic_detach(0x%p)\n", link);
 
 	if (link->state & DEV_CONFIG)
@@ -205,9 +202,8 @@ static void qlogic_detach(struct pcmcia_device *p_dev)
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 
-static void qlogic_config(dev_link_t * link)
+static void qlogic_config(struct pcmcia_device * link)
 {
-	client_handle_t handle = link->handle;
 	scsi_info_t *info = link->priv;
 	tuple_t tuple;
 	cisparse_t parse;
@@ -221,38 +217,38 @@ static void qlogic_config(dev_link_t * link)
 	tuple.TupleDataMax = 64;
 	tuple.TupleOffset = 0;
 	tuple.DesiredTuple = CISTPL_CONFIG;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
-	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
-	CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
+	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
+	CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
 	link->conf.ConfigBase = parse.config.base;
 
 	tuple.DesiredTuple = CISTPL_MANFID;
-	if ((pcmcia_get_first_tuple(handle, &tuple) == CS_SUCCESS) && (pcmcia_get_tuple_data(handle, &tuple) == CS_SUCCESS))
+	if ((pcmcia_get_first_tuple(link, &tuple) == CS_SUCCESS) && (pcmcia_get_tuple_data(link, &tuple) == CS_SUCCESS))
 		info->manf_id = le16_to_cpu(tuple.TupleData[0]);
 
 	/* Configure card */
 	link->state |= DEV_CONFIG;
 
 	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
-	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
 	while (1) {
-		if (pcmcia_get_tuple_data(handle, &tuple) != 0 ||
-				pcmcia_parse_tuple(handle, &tuple, &parse) != 0)
+		if (pcmcia_get_tuple_data(link, &tuple) != 0 ||
+				pcmcia_parse_tuple(link, &tuple, &parse) != 0)
 			goto next_entry;
 		link->conf.ConfigIndex = parse.cftable_entry.index;
 		link->io.BasePort1 = parse.cftable_entry.io.win[0].base;
 		link->io.NumPorts1 = parse.cftable_entry.io.win[0].len;
 		if (link->io.BasePort1 != 0) {
-			i = pcmcia_request_io(handle, &link->io);
+			i = pcmcia_request_io(link, &link->io);
 			if (i == CS_SUCCESS)
 				break;
 		}
 	      next_entry:
-		CS_CHECK(GetNextTuple, pcmcia_get_next_tuple(handle, &tuple));
+		CS_CHECK(GetNextTuple, pcmcia_get_next_tuple(link, &tuple));
 	}
 
-	CS_CHECK(RequestIRQ, pcmcia_request_irq(handle, &link->irq));
-	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(handle, &link->conf));
+	CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
+	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
 
 	if ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {
 		/* set ATAcmd */
@@ -283,15 +279,15 @@ static void qlogic_config(dev_link_t * link)
 	return;
 
 cs_failed:
-	cs_error(link->handle, last_fn, last_ret);
-	pcmcia_disable_device(link->handle);
+	cs_error(link, last_fn, last_ret);
+	pcmcia_disable_device(link);
 	return;
 
 }				/* qlogic_config */
 
 /*====================================================================*/
 
-static void qlogic_release(dev_link_t *link)
+static void qlogic_release(struct pcmcia_device *link)
 {
 	scsi_info_t *info = link->priv;
 
@@ -300,21 +296,19 @@ static void qlogic_release(dev_link_t *link)
 	scsi_remove_host(info->host);
 
 	free_irq(link->irq.AssignedIRQ, info->host);
-	pcmcia_disable_device(link->handle);
+	pcmcia_disable_device(link);
 
 	scsi_host_put(info->host);
 }
 
 /*====================================================================*/
 
-static int qlogic_resume(struct pcmcia_device *dev)
+static int qlogic_resume(struct pcmcia_device *link)
 {
-	dev_link_t *link = dev_to_instance(dev);
-
 	if (link->state & DEV_CONFIG) {
 		scsi_info_t *info = link->priv;
 
-		pcmcia_request_configuration(link->handle, &link->conf);
+		pcmcia_request_configuration(link, &link->conf);
 		if ((info->manf_id == MANFID_MACNICA) ||
 		    (info->manf_id == MANFID_PIONEER) ||
 		    (info->manf_id == 0x0098)) {

commit fd238232cd0ff4840ae6946bb338502154096d88
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 5 10:45:09 2006 +0100

    [PATCH] pcmcia: embed dev_link_t into struct pcmcia_device
    
    Embed dev_link_t into struct pcmcia_device(), as they basically address the
    same entity. The actual contents of dev_link_t will be cleaned up step by step.
    This patch includes a bugfix from and signed-off-by Andrew Morton.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 4f28589bbf34..c6b3e9587ff3 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -91,7 +91,7 @@ static struct scsi_host_template qlogicfas_driver_template = {
 /*====================================================================*/
 
 typedef struct scsi_info_t {
-	dev_link_t link;
+	struct pcmcia_device	*p_dev;
 	dev_node_t node;
 	struct Scsi_Host *host;
 	unsigned short manf_id;
@@ -159,7 +159,7 @@ static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 static int qlogic_attach(struct pcmcia_device *p_dev)
 {
 	scsi_info_t *info;
-	dev_link_t *link;
+	dev_link_t *link = dev_to_instance(p_dev);
 
 	DEBUG(0, "qlogic_attach()\n");
 
@@ -168,7 +168,7 @@ static int qlogic_attach(struct pcmcia_device *p_dev)
 	if (!info)
 		return -ENOMEM;
 	memset(info, 0, sizeof(*info));
-	link = &info->link;
+	info->p_dev = p_dev;
 	link->priv = info;
 	link->io.NumPorts1 = 16;
 	link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
@@ -179,9 +179,6 @@ static int qlogic_attach(struct pcmcia_device *p_dev)
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
 
-	link->handle = p_dev;
-	p_dev->instance = link;
-
 	link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
 	qlogic_config(link);
 
@@ -278,7 +275,7 @@ static void qlogic_config(dev_link_t * link)
 	}
 
 	sprintf(info->node.dev_name, "scsi%d", host->host_no);
-	link->dev = &info->node;
+	link->dev_node = &info->node;
 	info->host = host;
 
 out:

commit 70294b468302fd7a0a99dad935c7ba5322989345
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Jan 15 12:43:16 2006 +0100

    [PATCH] pcmcia: remove unneeded Vcc pseudo setting
    
    As we do not allow setting Vcc in the pcmcia core, and Vpp1 and
    Vpp2 can only be set to the same value, a lot of code can be
    streamlined.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 5a8da5143bd1..4f28589bbf34 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -176,7 +176,6 @@ static int qlogic_attach(struct pcmcia_device *p_dev)
 	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
 	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
 	link->conf.Attributes = CONF_ENABLE_IRQ;
-	link->conf.Vcc = 50;
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
 

commit 8661bb5b4af1849c1f5a4e80c4e275fd13c155d6
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Mar 2 00:02:33 2006 +0100

    [PATCH] pcmcia: default suspend and resume handling
    
    In all but one case, the suspend and resume functions of PCMCIA drivers
    contain mostly of calls to pcmcia_release_configuration() and
    pcmcia_request_configuration(). Therefore, move this code out of the
    drivers and into the core.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 1e27059cd462..5a8da5143bd1 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -311,22 +311,10 @@ static void qlogic_release(dev_link_t *link)
 
 /*====================================================================*/
 
-static int qlogic_suspend(struct pcmcia_device *dev)
-{
-	dev_link_t *link = dev_to_instance(dev);
-
-	link->state |= DEV_SUSPEND;
-	if (link->state & DEV_CONFIG)
-		pcmcia_release_configuration(link->handle);
-
-	return 0;
-}
-
 static int qlogic_resume(struct pcmcia_device *dev)
 {
 	dev_link_t *link = dev_to_instance(dev);
 
-	link->state &= ~DEV_SUSPEND;
 	if (link->state & DEV_CONFIG) {
 		scsi_info_t *info = link->priv;
 
@@ -375,7 +363,6 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	.probe		= qlogic_attach,
 	.remove		= qlogic_detach,
 	.id_table       = qlogic_ids,
-	.suspend	= qlogic_suspend,
 	.resume		= qlogic_resume,
 };
 

commit 50db3fdbbc98260fb538c1cc3f8cc597ba7bffe7
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Jan 15 10:05:19 2006 +0100

    [PATCH] pcmcia: convert remaining users of pcmcia_release_io and _irq
    
    Convert the remaining drivers which use pcmcia_release_io or
    pcmcia_release_irq, and remove the EXPORT of these symbols.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 70269fc10f30..1e27059cd462 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -288,12 +288,7 @@ static void qlogic_config(dev_link_t * link)
 
 cs_failed:
 	cs_error(link->handle, last_fn, last_ret);
-	link->dev = NULL;
-
-	pcmcia_release_configuration(link->handle);
-	pcmcia_release_io(link->handle, &link->io);
-	pcmcia_release_irq(link->handle, &link->irq);
-	link->state &= ~DEV_CONFIG;
+	pcmcia_disable_device(link->handle);
 	return;
 
 }				/* qlogic_config */

commit 5f2a71fcb7995633b335a1e380ac63a968e61320
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Jan 15 09:32:39 2006 +0100

    [PATCH] pcmcia: add pcmcia_disable_device
    
    pcmcia_disable_device(struct pcmcia_device *p_dev) performs the necessary
    cleanups upon device or driver removal: it calls the appropriate
    pcmcia_release_* functions, and can replace (most) of the current drivers'
    _release() functions.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index dce7e687fd4a..70269fc10f30 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -289,6 +289,7 @@ static void qlogic_config(dev_link_t * link)
 cs_failed:
 	cs_error(link->handle, last_fn, last_ret);
 	link->dev = NULL;
+
 	pcmcia_release_configuration(link->handle);
 	pcmcia_release_io(link->handle, &link->io);
 	pcmcia_release_irq(link->handle, &link->irq);
@@ -306,17 +307,11 @@ static void qlogic_release(dev_link_t *link)
 	DEBUG(0, "qlogic_release(0x%p)\n", link);
 
 	scsi_remove_host(info->host);
-	link->dev = NULL;
 
 	free_irq(link->irq.AssignedIRQ, info->host);
-
-	pcmcia_release_configuration(link->handle);
-	pcmcia_release_io(link->handle, &link->io);
-	pcmcia_release_irq(link->handle, &link->irq);
+	pcmcia_disable_device(link->handle);
 
 	scsi_host_put(info->host);
-
-	link->state &= ~DEV_CONFIG;
 }
 
 /*====================================================================*/

commit f8cfa618dccbdc6dab5297f75779566a388a98fd
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:25:51 2005 +0100

    [PATCH] pcmcia: unify attach, EVENT_CARD_INSERTION handlers into one probe callback
    
    Unify the EVENT_CARD_INSERTION and "attach" callbacks to one unified
    probe() callback. As all in-kernel drivers are changed to this new
    callback, there will be no temporary backwards-compatibility. Inside a
    probe() function, each driver _must_ set struct pcmcia_device
    *p_dev->instance and instance->handle correctly.
    
    With these patches, the basic driver interface for 16-bit PCMCIA drivers
    now has the classic four callbacks known also from other buses:
    
            int (*probe)            (struct pcmcia_device *dev);
            void (*remove)          (struct pcmcia_device *dev);
    
            int (*suspend)          (struct pcmcia_device *dev);
            int (*resume)           (struct pcmcia_device *dev);
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index e10281a6e5f9..dce7e687fd4a 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -98,13 +98,8 @@ typedef struct scsi_info_t {
 } scsi_info_t;
 
 static void qlogic_release(dev_link_t *link);
-static int qlogic_event(event_t event, int priority, event_callback_args_t * args);
-
-static dev_link_t *qlogic_attach(void);
 static void qlogic_detach(struct pcmcia_device *p_dev);
-
-
-static dev_info_t dev_info = "qlogic_cs";
+static void qlogic_config(dev_link_t * link);
 
 static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 				dev_link_t *link, int qbase, int qlirq)
@@ -161,19 +156,17 @@ static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 err:
 	return NULL;
 }
-static dev_link_t *qlogic_attach(void)
+static int qlogic_attach(struct pcmcia_device *p_dev)
 {
 	scsi_info_t *info;
-	client_reg_t client_reg;
 	dev_link_t *link;
-	int ret;
 
 	DEBUG(0, "qlogic_attach()\n");
 
 	/* Create new SCSI device */
 	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
-		return NULL;
+		return -ENOMEM;
 	memset(info, 0, sizeof(*info));
 	link = &info->link;
 	link->priv = info;
@@ -187,19 +180,13 @@ static dev_link_t *qlogic_attach(void)
 	link->conf.IntType = INT_MEMORY_AND_IO;
 	link->conf.Present = PRESENT_OPTION;
 
-	/* Register with Card Services */
-	link->next = NULL;
-	client_reg.dev_info = &dev_info;
-	client_reg.Version = 0x0210;
-	client_reg.event_callback_args.client_data = link;
-	ret = pcmcia_register_client(&link->handle, &client_reg);
-	if (ret != 0) {
-		cs_error(link->handle, RegisterClient, ret);
-		qlogic_detach(link->handle);
-		return NULL;
-	}
+	link->handle = p_dev;
+	p_dev->instance = link;
+
+	link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+	qlogic_config(link);
 
-	return link;
+	return 0;
 }				/* qlogic_attach */
 
 /*====================================================================*/
@@ -368,21 +355,6 @@ static int qlogic_resume(struct pcmcia_device *dev)
 	return 0;
 }
 
-static int qlogic_event(event_t event, int priority, event_callback_args_t * args)
-{
-	dev_link_t *link = args->client_data;
-
-	DEBUG(1, "qlogic_event(0x%06x)\n", event);
-
-	switch (event) {
-	case CS_EVENT_CARD_INSERTION:
-		link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
-		qlogic_config(link);
-		break;
-	}
-	return 0;
-}				/* qlogic_event */
-
 static struct pcmcia_device_id qlogic_ids[] = {
 	PCMCIA_DEVICE_PROD_ID12("EIger Labs", "PCMCIA-to-SCSI Adapter", 0x88395fa7, 0x33b7a5e6),
 	PCMCIA_DEVICE_PROD_ID12("EPSON", "SCSI-2 PC Card SC200", 0xd361772f, 0x299d1751),
@@ -410,8 +382,7 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	.drv		= {
 	.name		= "qlogic_cs",
 	},
-	.attach		= qlogic_attach,
-	.event		= qlogic_event,
+	.probe		= qlogic_attach,
 	.remove		= qlogic_detach,
 	.id_table       = qlogic_ids,
 	.suspend	= qlogic_suspend,

commit b463581154f3f3eecda27cae60df813fefcd84d3
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:25:35 2005 +0100

    [PATCH] pcmcia: remove dev_list from drivers
    
    The linked list of devices managed by each PCMCIA driver is, in very most
    cases, unused. Therefore, remove it from many drivers.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 8351dc234ffb..e10281a6e5f9 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -104,8 +104,6 @@ static dev_link_t *qlogic_attach(void);
 static void qlogic_detach(struct pcmcia_device *p_dev);
 
 
-static dev_link_t *dev_list = NULL;
-
 static dev_info_t dev_info = "qlogic_cs";
 
 static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
@@ -190,8 +188,7 @@ static dev_link_t *qlogic_attach(void)
 	link->conf.Present = PRESENT_OPTION;
 
 	/* Register with Card Services */
-	link->next = dev_list;
-	dev_list = link;
+	link->next = NULL;
 	client_reg.dev_info = &dev_info;
 	client_reg.Version = 0x0210;
 	client_reg.event_callback_args.client_data = link;
@@ -210,22 +207,12 @@ static dev_link_t *qlogic_attach(void)
 static void qlogic_detach(struct pcmcia_device *p_dev)
 {
 	dev_link_t *link = dev_to_instance(p_dev);
-	dev_link_t **linkp;
 
 	DEBUG(0, "qlogic_detach(0x%p)\n", link);
 
-	/* Locate device structure */
-	for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)
-		if (*linkp == link)
-			break;
-	if (*linkp == NULL)
-		return;
-
 	if (link->state & DEV_CONFIG)
 		qlogic_release(link);
 
-	/* Unlink device structure, free bits */
-	*linkp = link->next;
 	kfree(link->priv);
 
 }				/* qlogic_detach */
@@ -439,7 +426,6 @@ static int __init init_qlogic_cs(void)
 static void __exit exit_qlogic_cs(void)
 {
 	pcmcia_unregister_driver(&qlogic_cs_driver);
-	BUG_ON(dev_list != NULL);
 }
 
 MODULE_AUTHOR("Tom Zerucha, Michael Griffith");

commit cc3b4866bee996c922e875b8c8efe9f0d8803aae
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:23:14 2005 +0100

    [PATCH] pcmcia: unify detach, REMOVAL_EVENT handlers into one remove callback
    
    Unify the "detach" and REMOVAL_EVENT handlers to one "remove" function.
    Old functionality is preserved, for the moment.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 2541a999a0e5..8351dc234ffb 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -101,7 +101,7 @@ static void qlogic_release(dev_link_t *link);
 static int qlogic_event(event_t event, int priority, event_callback_args_t * args);
 
 static dev_link_t *qlogic_attach(void);
-static void qlogic_detach(dev_link_t *);
+static void qlogic_detach(struct pcmcia_device *p_dev);
 
 
 static dev_link_t *dev_list = NULL;
@@ -198,7 +198,7 @@ static dev_link_t *qlogic_attach(void)
 	ret = pcmcia_register_client(&link->handle, &client_reg);
 	if (ret != 0) {
 		cs_error(link->handle, RegisterClient, ret);
-		qlogic_detach(link);
+		qlogic_detach(link->handle);
 		return NULL;
 	}
 
@@ -207,8 +207,9 @@ static dev_link_t *qlogic_attach(void)
 
 /*====================================================================*/
 
-static void qlogic_detach(dev_link_t * link)
+static void qlogic_detach(struct pcmcia_device *p_dev)
 {
+	dev_link_t *link = dev_to_instance(p_dev);
 	dev_link_t **linkp;
 
 	DEBUG(0, "qlogic_detach(0x%p)\n", link);
@@ -223,9 +224,6 @@ static void qlogic_detach(dev_link_t * link)
 	if (link->state & DEV_CONFIG)
 		qlogic_release(link);
 
-	if (link->handle)
-		pcmcia_deregister_client(link->handle);
-
 	/* Unlink device structure, free bits */
 	*linkp = link->next;
 	kfree(link->priv);
@@ -390,11 +388,6 @@ static int qlogic_event(event_t event, int priority, event_callback_args_t * arg
 	DEBUG(1, "qlogic_event(0x%06x)\n", event);
 
 	switch (event) {
-	case CS_EVENT_CARD_REMOVAL:
-		link->state &= ~DEV_PRESENT;
-		if (link->state & DEV_CONFIG)
-			qlogic_release(link);
-		break;
 	case CS_EVENT_CARD_INSERTION:
 		link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
 		qlogic_config(link);
@@ -432,7 +425,7 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	},
 	.attach		= qlogic_attach,
 	.event		= qlogic_event,
-	.detach		= qlogic_detach,
+	.remove		= qlogic_detach,
 	.id_table       = qlogic_ids,
 	.suspend	= qlogic_suspend,
 	.resume		= qlogic_resume,

commit 98e4c28b7ec390c2dad6a4c69d69629c0f7e8b10
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:21:18 2005 +0100

    [PATCH] pcmcia: new suspend core
    
    Move the suspend and resume methods out of the event handler, and into
    special functions. Also use these functions for pre- and post-reset, as
    almost all drivers already do, and the remaining ones can easily be
    converted.
    
    Bugfix to include/pcmcia/ds.c
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index bb091a45a880..2541a999a0e5 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -349,6 +349,40 @@ static void qlogic_release(dev_link_t *link)
 
 /*====================================================================*/
 
+static int qlogic_suspend(struct pcmcia_device *dev)
+{
+	dev_link_t *link = dev_to_instance(dev);
+
+	link->state |= DEV_SUSPEND;
+	if (link->state & DEV_CONFIG)
+		pcmcia_release_configuration(link->handle);
+
+	return 0;
+}
+
+static int qlogic_resume(struct pcmcia_device *dev)
+{
+	dev_link_t *link = dev_to_instance(dev);
+
+	link->state &= ~DEV_SUSPEND;
+	if (link->state & DEV_CONFIG) {
+		scsi_info_t *info = link->priv;
+
+		pcmcia_request_configuration(link->handle, &link->conf);
+		if ((info->manf_id == MANFID_MACNICA) ||
+		    (info->manf_id == MANFID_PIONEER) ||
+		    (info->manf_id == 0x0098)) {
+			outb(0x80, link->io.BasePort1 + 0xd);
+			outb(0x24, link->io.BasePort1 + 0x9);
+			outb(0x04, link->io.BasePort1 + 0xd);
+		}
+		/* Ugggglllyyyy!!! */
+		qlogicfas408_bus_reset(NULL);
+	}
+
+	return 0;
+}
+
 static int qlogic_event(event_t event, int priority, event_callback_args_t * args)
 {
 	dev_link_t *link = args->client_data;
@@ -365,29 +399,6 @@ static int qlogic_event(event_t event, int priority, event_callback_args_t * arg
 		link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
 		qlogic_config(link);
 		break;
-	case CS_EVENT_PM_SUSPEND:
-		link->state |= DEV_SUSPEND;
-		/* Fall through... */
-	case CS_EVENT_RESET_PHYSICAL:
-		if (link->state & DEV_CONFIG)
-			pcmcia_release_configuration(link->handle);
-		break;
-	case CS_EVENT_PM_RESUME:
-		link->state &= ~DEV_SUSPEND;
-		/* Fall through... */
-	case CS_EVENT_CARD_RESET:
-		if (link->state & DEV_CONFIG) {
-			scsi_info_t *info = link->priv;
-			pcmcia_request_configuration(link->handle, &link->conf);
-			if ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {
-				outb(0x80, link->io.BasePort1 + 0xd);
-				outb(0x24, link->io.BasePort1 + 0x9);
-				outb(0x04, link->io.BasePort1 + 0xd);
-			}
-			/* Ugggglllyyyy!!! */
-			qlogicfas408_bus_reset(NULL);
-		}
-		break;
 	}
 	return 0;
 }				/* qlogic_event */
@@ -423,6 +434,8 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	.event		= qlogic_event,
 	.detach		= qlogic_detach,
 	.id_table       = qlogic_ids,
+	.suspend	= qlogic_suspend,
+	.resume		= qlogic_resume,
 };
 
 static int __init init_qlogic_cs(void)

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 7a516f35834e..bb091a45a880 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -72,7 +72,7 @@ static char *version = "qlogic_cs.c 1.79-ac 2002/10/26 (David Hinds)";
 #define DEBUG(n, args...)
 #endif
 
-static Scsi_Host_Template qlogicfas_driver_template = {
+static struct scsi_host_template qlogicfas_driver_template = {
 	.module			= THIS_MODULE,
 	.name			= qlogic_name,
 	.proc_name		= qlogic_name,
@@ -108,7 +108,7 @@ static dev_link_t *dev_list = NULL;
 
 static dev_info_t dev_info = "qlogic_cs";
 
-static struct Scsi_Host *qlogic_detect(Scsi_Host_Template *host,
+static struct Scsi_Host *qlogic_detect(struct scsi_host_template *host,
 				dev_link_t *link, int qbase, int qlirq)
 {
 	int qltyp;		/* type of chip */

commit 44670d2b50efd2443c3810239d6ea3fd02f8ef64
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 7 17:59:05 2005 -0700

    [PATCH] pcmcia: remove references to pcmcia/version.h
    
    As a follow-up, remove the inclusion of pcmcia/version.h in many files.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index e6e496180d11..7a516f35834e 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -49,7 +49,6 @@
 #include <scsi/scsi_host.h>
 #include "../qlogicfas408.h"
 
-#include <pcmcia/version.h>
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>

commit 1e212f3645a6b355de8c43a23376bc0e2ac49a63
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 7 17:59:00 2005 -0700

    [PATCH] pcmcia: move event handler
    
    Move the "event handler" to struct pcmcia_driver -- the unified event handler
    will disappear really soon, but switching it to struct pcmcia_driver in the
    meantime allows for better "step-by-step" patches.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 0dcf41102abf..e6e496180d11 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -194,8 +194,6 @@ static dev_link_t *qlogic_attach(void)
 	link->next = dev_list;
 	dev_list = link;
 	client_reg.dev_info = &dev_info;
-	client_reg.event_handler = &qlogic_event;
-	client_reg.EventMask = CS_EVENT_RESET_REQUEST | CS_EVENT_CARD_RESET | CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL | CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;
 	client_reg.Version = 0x0210;
 	client_reg.event_callback_args.client_data = link;
 	ret = pcmcia_register_client(&link->handle, &client_reg);
@@ -423,6 +421,7 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	.name		= "qlogic_cs",
 	},
 	.attach		= qlogic_attach,
+	.event		= qlogic_event,
 	.detach		= qlogic_detach,
 	.id_table       = qlogic_ids,
 };

commit 7a5a6eeb6de79ab36ef1fceae8cc3c334b43fddc
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Jun 27 16:28:26 2005 -0700

    [PATCH] pcmcia: id_table for qlogic_stub.c
    
    Add pcmcia_device_id table.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index a0175f5d11cd..0dcf41102abf 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -395,6 +395,27 @@ static int qlogic_event(event_t event, int priority, event_callback_args_t * arg
 	return 0;
 }				/* qlogic_event */
 
+static struct pcmcia_device_id qlogic_ids[] = {
+	PCMCIA_DEVICE_PROD_ID12("EIger Labs", "PCMCIA-to-SCSI Adapter", 0x88395fa7, 0x33b7a5e6),
+	PCMCIA_DEVICE_PROD_ID12("EPSON", "SCSI-2 PC Card SC200", 0xd361772f, 0x299d1751),
+	PCMCIA_DEVICE_PROD_ID12("MACNICA", "MIRACLE SCSI-II mPS110", 0x20841b68, 0xab3c3b6d),
+	PCMCIA_DEVICE_PROD_ID12("MIDORI ELECTRONICS ", "CN-SC43", 0x6534382a, 0xd67eee79),
+	PCMCIA_DEVICE_PROD_ID12("NEC", "PC-9801N-J03R", 0x18df0ba0, 0x24662e8a),
+	PCMCIA_DEVICE_PROD_ID12("KME ", "KXLC003", 0x82375a27, 0xf68e5bf7),
+	PCMCIA_DEVICE_PROD_ID12("KME ", "KXLC004", 0x82375a27, 0x68eace54),
+	PCMCIA_DEVICE_PROD_ID12("KME", "KXLC101", 0x3faee676, 0x194250ec),
+	PCMCIA_DEVICE_PROD_ID12("QLOGIC CORPORATION", "pc05", 0xd77b2930, 0xa85b2735),
+	PCMCIA_DEVICE_PROD_ID12("QLOGIC CORPORATION", "pc05 rev 1.10", 0xd77b2930, 0x70f8b5f8),
+	PCMCIA_DEVICE_PROD_ID123("KME", "KXLC002", "00", 0x3faee676, 0x81896b61, 0xf99f065f),
+	PCMCIA_DEVICE_PROD_ID12("RATOC System Inc.", "SCSI2 CARD 37", 0x85c10e17, 0x1a2640c1),
+	PCMCIA_DEVICE_PROD_ID12("TOSHIBA", "SCSC200A PC CARD SCSI", 0xb4585a1a, 0xa6f06ebe),
+	PCMCIA_DEVICE_PROD_ID12("TOSHIBA", "SCSC200B PC CARD SCSI-10", 0xb4585a1a, 0x0a88dea0),
+	/* these conflict with other cards! */
+	/* PCMCIA_DEVICE_PROD_ID123("MACNICA", "MIRACLE SCSI", "mPS100", 0x20841b68, 0xf8dedaeb, 0x89f7fafb), */
+	/* PCMCIA_DEVICE_PROD_ID123("MACNICA", "MIRACLE SCSI", "mPS100", 0x20841b68, 0xf8dedaeb, 0x89f7fafb), */
+	PCMCIA_DEVICE_NULL,
+};
+MODULE_DEVICE_TABLE(pcmcia, qlogic_ids);
 
 static struct pcmcia_driver qlogic_cs_driver = {
 	.owner		= THIS_MODULE,
@@ -403,6 +424,7 @@ static struct pcmcia_driver qlogic_cs_driver = {
 	},
 	.attach		= qlogic_attach,
 	.detach		= qlogic_detach,
+	.id_table       = qlogic_ids,
 };
 
 static int __init init_qlogic_cs(void)

commit 3471c288036bf0835a82d0b1bbce2002f6e68390
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:52:51 2005 -0400

    [SCSI] Remove no-op implementations of SCSI EH hooks
    
    Drivers need not implement a hook that returns FAILED, and does nothing
    else, since the SCSI midlayer code will do that for us.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
index 4766bcd63692..a0175f5d11cd 100644
--- a/drivers/scsi/pcmcia/qlogic_stub.c
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -81,8 +81,6 @@ static Scsi_Host_Template qlogicfas_driver_template = {
 	.queuecommand		= qlogicfas408_queuecommand,
 	.eh_abort_handler	= qlogicfas408_abort,
 	.eh_bus_reset_handler	= qlogicfas408_bus_reset,
-	.eh_device_reset_handler= qlogicfas408_device_reset,
-	.eh_host_reset_handler	= qlogicfas408_host_reset,
 	.bios_param		= qlogicfas408_biosparam,
 	.can_queue		= 1,
 	.this_id		= -1,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/pcmcia/qlogic_stub.c b/drivers/scsi/pcmcia/qlogic_stub.c
new file mode 100644
index 000000000000..4766bcd63692
--- /dev/null
+++ b/drivers/scsi/pcmcia/qlogic_stub.c
@@ -0,0 +1,425 @@
+/*======================================================================
+
+    A driver for the Qlogic SCSI card
+
+    qlogic_cs.c 1.79 2000/06/12 21:27:26
+
+    The contents of this file are subject to the Mozilla Public
+    License Version 1.1 (the "License"); you may not use this file
+    except in compliance with the License. You may obtain a copy of
+    the License at http://www.mozilla.org/MPL/
+
+    Software distributed under the License is distributed on an "AS
+    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+    implied. See the License for the specific language governing
+    rights and limitations under the License.
+
+    The initial developer of the original code is David A. Hinds
+    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
+    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+
+    Alternatively, the contents of this file may be used under the
+    terms of the GNU General Public License version 2 (the "GPL"), in which
+    case the provisions of the GPL are applicable instead of the
+    above.  If you wish to allow the use of your version of this file
+    only under the terms of the GPL and not to allow others to use
+    your version of this file under the MPL, indicate your decision
+    by deleting the provisions above and replace them with the notice
+    and other provisions required by the GPL.  If you do not delete
+    the provisions above, a recipient may use your version of this
+    file under either the MPL or the GPL.
+    
+======================================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <scsi/scsi.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <scsi/scsi_ioctl.h>
+#include <linux/interrupt.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "../qlogicfas408.h"
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/ciscode.h>
+
+/* Set the following to 2 to use normal interrupt (active high/totempole-
+ * tristate), otherwise use 0 (REQUIRED FOR PCMCIA) for active low, open
+ * drain
+ */
+#define INT_TYPE	0
+
+static char qlogic_name[] = "qlogic_cs";
+
+#ifdef PCMCIA_DEBUG
+static int pc_debug = PCMCIA_DEBUG;
+module_param(pc_debug, int, 0644);
+#define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args)
+static char *version = "qlogic_cs.c 1.79-ac 2002/10/26 (David Hinds)";
+#else
+#define DEBUG(n, args...)
+#endif
+
+static Scsi_Host_Template qlogicfas_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= qlogic_name,
+	.proc_name		= qlogic_name,
+	.info			= qlogicfas408_info,
+	.queuecommand		= qlogicfas408_queuecommand,
+	.eh_abort_handler	= qlogicfas408_abort,
+	.eh_bus_reset_handler	= qlogicfas408_bus_reset,
+	.eh_device_reset_handler= qlogicfas408_device_reset,
+	.eh_host_reset_handler	= qlogicfas408_host_reset,
+	.bios_param		= qlogicfas408_biosparam,
+	.can_queue		= 1,
+	.this_id		= -1,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= DISABLE_CLUSTERING,
+};
+
+/*====================================================================*/
+
+typedef struct scsi_info_t {
+	dev_link_t link;
+	dev_node_t node;
+	struct Scsi_Host *host;
+	unsigned short manf_id;
+} scsi_info_t;
+
+static void qlogic_release(dev_link_t *link);
+static int qlogic_event(event_t event, int priority, event_callback_args_t * args);
+
+static dev_link_t *qlogic_attach(void);
+static void qlogic_detach(dev_link_t *);
+
+
+static dev_link_t *dev_list = NULL;
+
+static dev_info_t dev_info = "qlogic_cs";
+
+static struct Scsi_Host *qlogic_detect(Scsi_Host_Template *host,
+				dev_link_t *link, int qbase, int qlirq)
+{
+	int qltyp;		/* type of chip */
+	int qinitid;
+	struct Scsi_Host *shost;	/* registered host structure */
+	struct qlogicfas408_priv *priv;
+
+	qltyp = qlogicfas408_get_chip_type(qbase, INT_TYPE);
+	qinitid = host->this_id;
+	if (qinitid < 0)
+		qinitid = 7;	/* if no ID, use 7 */
+
+	qlogicfas408_setup(qbase, qinitid, INT_TYPE);
+
+	host->name = qlogic_name;
+	shost = scsi_host_alloc(host, sizeof(struct qlogicfas408_priv));
+	if (!shost)
+		goto err;
+	shost->io_port = qbase;
+	shost->n_io_port = 16;
+	shost->dma_channel = -1;
+	if (qlirq != -1)
+		shost->irq = qlirq;
+
+	priv = get_priv_by_host(shost);
+	priv->qlirq = qlirq;
+	priv->qbase = qbase;
+	priv->qinitid = qinitid;
+	priv->shost = shost;
+	priv->int_type = INT_TYPE;					
+
+	if (request_irq(qlirq, qlogicfas408_ihandl, 0, qlogic_name, shost))
+		goto free_scsi_host;
+
+	sprintf(priv->qinfo,
+		"Qlogicfas Driver version 0.46, chip %02X at %03X, IRQ %d, TPdma:%d",
+		qltyp, qbase, qlirq, QL_TURBO_PDMA);
+
+	if (scsi_add_host(shost, NULL))
+		goto free_interrupt;
+
+	scsi_scan_host(shost);
+
+	return shost;
+
+free_interrupt:
+	free_irq(qlirq, shost);
+
+free_scsi_host:
+	scsi_host_put(shost);
+	
+err:
+	return NULL;
+}
+static dev_link_t *qlogic_attach(void)
+{
+	scsi_info_t *info;
+	client_reg_t client_reg;
+	dev_link_t *link;
+	int ret;
+
+	DEBUG(0, "qlogic_attach()\n");
+
+	/* Create new SCSI device */
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return NULL;
+	memset(info, 0, sizeof(*info));
+	link = &info->link;
+	link->priv = info;
+	link->io.NumPorts1 = 16;
+	link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+	link->io.IOAddrLines = 10;
+	link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
+	link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+	link->conf.Attributes = CONF_ENABLE_IRQ;
+	link->conf.Vcc = 50;
+	link->conf.IntType = INT_MEMORY_AND_IO;
+	link->conf.Present = PRESENT_OPTION;
+
+	/* Register with Card Services */
+	link->next = dev_list;
+	dev_list = link;
+	client_reg.dev_info = &dev_info;
+	client_reg.event_handler = &qlogic_event;
+	client_reg.EventMask = CS_EVENT_RESET_REQUEST | CS_EVENT_CARD_RESET | CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL | CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;
+	client_reg.Version = 0x0210;
+	client_reg.event_callback_args.client_data = link;
+	ret = pcmcia_register_client(&link->handle, &client_reg);
+	if (ret != 0) {
+		cs_error(link->handle, RegisterClient, ret);
+		qlogic_detach(link);
+		return NULL;
+	}
+
+	return link;
+}				/* qlogic_attach */
+
+/*====================================================================*/
+
+static void qlogic_detach(dev_link_t * link)
+{
+	dev_link_t **linkp;
+
+	DEBUG(0, "qlogic_detach(0x%p)\n", link);
+
+	/* Locate device structure */
+	for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)
+		if (*linkp == link)
+			break;
+	if (*linkp == NULL)
+		return;
+
+	if (link->state & DEV_CONFIG)
+		qlogic_release(link);
+
+	if (link->handle)
+		pcmcia_deregister_client(link->handle);
+
+	/* Unlink device structure, free bits */
+	*linkp = link->next;
+	kfree(link->priv);
+
+}				/* qlogic_detach */
+
+/*====================================================================*/
+
+#define CS_CHECK(fn, ret) \
+do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
+
+static void qlogic_config(dev_link_t * link)
+{
+	client_handle_t handle = link->handle;
+	scsi_info_t *info = link->priv;
+	tuple_t tuple;
+	cisparse_t parse;
+	int i, last_ret, last_fn;
+	unsigned short tuple_data[32];
+	struct Scsi_Host *host;
+
+	DEBUG(0, "qlogic_config(0x%p)\n", link);
+
+	tuple.TupleData = (cisdata_t *) tuple_data;
+	tuple.TupleDataMax = 64;
+	tuple.TupleOffset = 0;
+	tuple.DesiredTuple = CISTPL_CONFIG;
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
+	CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+	link->conf.ConfigBase = parse.config.base;
+
+	tuple.DesiredTuple = CISTPL_MANFID;
+	if ((pcmcia_get_first_tuple(handle, &tuple) == CS_SUCCESS) && (pcmcia_get_tuple_data(handle, &tuple) == CS_SUCCESS))
+		info->manf_id = le16_to_cpu(tuple.TupleData[0]);
+
+	/* Configure card */
+	link->state |= DEV_CONFIG;
+
+	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+	while (1) {
+		if (pcmcia_get_tuple_data(handle, &tuple) != 0 ||
+				pcmcia_parse_tuple(handle, &tuple, &parse) != 0)
+			goto next_entry;
+		link->conf.ConfigIndex = parse.cftable_entry.index;
+		link->io.BasePort1 = parse.cftable_entry.io.win[0].base;
+		link->io.NumPorts1 = parse.cftable_entry.io.win[0].len;
+		if (link->io.BasePort1 != 0) {
+			i = pcmcia_request_io(handle, &link->io);
+			if (i == CS_SUCCESS)
+				break;
+		}
+	      next_entry:
+		CS_CHECK(GetNextTuple, pcmcia_get_next_tuple(handle, &tuple));
+	}
+
+	CS_CHECK(RequestIRQ, pcmcia_request_irq(handle, &link->irq));
+	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(handle, &link->conf));
+
+	if ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {
+		/* set ATAcmd */
+		outb(0xb4, link->io.BasePort1 + 0xd);
+		outb(0x24, link->io.BasePort1 + 0x9);
+		outb(0x04, link->io.BasePort1 + 0xd);
+	}
+
+	/* The KXL-810AN has a bigger IO port window */
+	if (link->io.NumPorts1 == 32)
+		host = qlogic_detect(&qlogicfas_driver_template, link,
+			link->io.BasePort1 + 16, link->irq.AssignedIRQ);
+	else
+		host = qlogic_detect(&qlogicfas_driver_template, link,
+			link->io.BasePort1, link->irq.AssignedIRQ);
+	
+	if (!host) {
+		printk(KERN_INFO "%s: no SCSI devices found\n", qlogic_name);
+		goto out;
+	}
+
+	sprintf(info->node.dev_name, "scsi%d", host->host_no);
+	link->dev = &info->node;
+	info->host = host;
+
+out:
+	link->state &= ~DEV_CONFIG_PENDING;
+	return;
+
+cs_failed:
+	cs_error(link->handle, last_fn, last_ret);
+	link->dev = NULL;
+	pcmcia_release_configuration(link->handle);
+	pcmcia_release_io(link->handle, &link->io);
+	pcmcia_release_irq(link->handle, &link->irq);
+	link->state &= ~DEV_CONFIG;
+	return;
+
+}				/* qlogic_config */
+
+/*====================================================================*/
+
+static void qlogic_release(dev_link_t *link)
+{
+	scsi_info_t *info = link->priv;
+
+	DEBUG(0, "qlogic_release(0x%p)\n", link);
+
+	scsi_remove_host(info->host);
+	link->dev = NULL;
+
+	free_irq(link->irq.AssignedIRQ, info->host);
+
+	pcmcia_release_configuration(link->handle);
+	pcmcia_release_io(link->handle, &link->io);
+	pcmcia_release_irq(link->handle, &link->irq);
+
+	scsi_host_put(info->host);
+
+	link->state &= ~DEV_CONFIG;
+}
+
+/*====================================================================*/
+
+static int qlogic_event(event_t event, int priority, event_callback_args_t * args)
+{
+	dev_link_t *link = args->client_data;
+
+	DEBUG(1, "qlogic_event(0x%06x)\n", event);
+
+	switch (event) {
+	case CS_EVENT_CARD_REMOVAL:
+		link->state &= ~DEV_PRESENT;
+		if (link->state & DEV_CONFIG)
+			qlogic_release(link);
+		break;
+	case CS_EVENT_CARD_INSERTION:
+		link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+		qlogic_config(link);
+		break;
+	case CS_EVENT_PM_SUSPEND:
+		link->state |= DEV_SUSPEND;
+		/* Fall through... */
+	case CS_EVENT_RESET_PHYSICAL:
+		if (link->state & DEV_CONFIG)
+			pcmcia_release_configuration(link->handle);
+		break;
+	case CS_EVENT_PM_RESUME:
+		link->state &= ~DEV_SUSPEND;
+		/* Fall through... */
+	case CS_EVENT_CARD_RESET:
+		if (link->state & DEV_CONFIG) {
+			scsi_info_t *info = link->priv;
+			pcmcia_request_configuration(link->handle, &link->conf);
+			if ((info->manf_id == MANFID_MACNICA) || (info->manf_id == MANFID_PIONEER) || (info->manf_id == 0x0098)) {
+				outb(0x80, link->io.BasePort1 + 0xd);
+				outb(0x24, link->io.BasePort1 + 0x9);
+				outb(0x04, link->io.BasePort1 + 0xd);
+			}
+			/* Ugggglllyyyy!!! */
+			qlogicfas408_bus_reset(NULL);
+		}
+		break;
+	}
+	return 0;
+}				/* qlogic_event */
+
+
+static struct pcmcia_driver qlogic_cs_driver = {
+	.owner		= THIS_MODULE,
+	.drv		= {
+	.name		= "qlogic_cs",
+	},
+	.attach		= qlogic_attach,
+	.detach		= qlogic_detach,
+};
+
+static int __init init_qlogic_cs(void)
+{
+	return pcmcia_register_driver(&qlogic_cs_driver);
+}
+
+static void __exit exit_qlogic_cs(void)
+{
+	pcmcia_unregister_driver(&qlogic_cs_driver);
+	BUG_ON(dev_list != NULL);
+}
+
+MODULE_AUTHOR("Tom Zerucha, Michael Griffith");
+MODULE_DESCRIPTION("Driver for the PCMCIA Qlogic FAS SCSI controllers");
+MODULE_LICENSE("GPL");
+module_init(init_qlogic_cs);
+module_exit(exit_qlogic_cs);
