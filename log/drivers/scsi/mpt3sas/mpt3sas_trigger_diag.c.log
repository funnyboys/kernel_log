commit 4bc50dc1afb7b77dfc80a1f8f0742b14d6f6e376
Author: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
Date:   Fri Sep 13 09:04:39 2019 -0400

    scsi: mpt3sas: Display message before releasing diag buffer
    
    Display message before releasing the diag buffer so that user knows which
    event caused the release of diag buffer.
    
    Releasing of diag buffer means HBA firmware stops posting the firmware logs
    on the registered diag buffer.
    
    Link: https://lore.kernel.org/r/1568379890-18347-3-git-send-email-sreekanth.reddy@broadcom.com
    Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index 6ac453fd5937..8ec9bab20ec4 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -113,15 +113,21 @@ mpt3sas_process_trigger_data(struct MPT3SAS_ADAPTER *ioc,
 	struct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)
 {
 	u8 issue_reset = 0;
+	u32 *trig_data = (u32 *)&event_data->u.master;
 
 	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: enter\n", __func__));
 
 	/* release the diag buffer trace */
 	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
 	    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {
-		dTriggerDiagPrintk(ioc,
-				   ioc_info(ioc, "%s: release trace diag buffer\n",
-					    __func__));
+		/*
+		 * add a log message so that user knows which event caused
+		 * the release
+		 */
+		ioc_info(ioc,
+		    "%s: Releasing the trace buffer. Trigger_Type 0x%08x, Data[0] 0x%08x, Data[1] 0x%08x\n",
+		    __func__, event_data->trigger_type,
+		    trig_data[0], trig_data[1]);
 		mpt3sas_send_diag_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE,
 		    &issue_reset);
 	}

commit 919d8a3f3fef9910fda7e0549004cbd4243cf744
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 17 08:01:09 2018 -0700

    scsi: mpt3sas: Convert uses of pr_<level> with MPT3SAS_FMT to ioc_<level>
    
    Use a more common logging style.
    
    Done using the perl script below and some typing
    
    $ git grep --name-only -w MPT3SAS_FMT -- "*.c" | \
      xargs perl -i -e 'local $/; while (<>) { s/\bpr_(info|err|notice|warn)\s*\(\s*MPT3SAS_FMT\s*("[^"]+"(?:\s*\\?\s*"[^"]+"\s*){0,5}\s*),\s*ioc->name\s*/ioc_\1(ioc, \2/g; print;}'
    
    Miscellanea for these conversions:
    
    o Coalesce formats
    o Realign arguments
    o Remove unnecessary parentheses
    o Use casts to u64 instead of unsigned long long where appropriate
    o Convert broken pr_info uses to pr_cont
    o Fix broken format string concatenation with line continuations and
      excess whitespace
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Suganath Prabu <suganath-prabu.subramani@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index cae7c1eaef34..6ac453fd5937 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -72,8 +72,7 @@ _mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
 	u16 sz, event_data_sz;
 	unsigned long flags;
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: enter\n",
-	    ioc->name, __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: enter\n", __func__));
 
 	sz = offsetof(Mpi2EventNotificationReply_t, EventData) +
 	    sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T) + 4;
@@ -85,23 +84,23 @@ _mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
 	mpi_reply->EventDataLength = cpu_to_le16(event_data_sz);
 	memcpy(&mpi_reply->EventData, event_data,
 	    sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: add to driver event log\n",
-		ioc->name, __func__));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: add to driver event log\n",
+				    __func__));
 	mpt3sas_ctl_add_to_event_log(ioc, mpi_reply);
 	kfree(mpi_reply);
  out:
 
 	/* clearing the diag_trigger_active flag */
 	spin_lock_irqsave(&ioc->diag_trigger_lock, flags);
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: clearing diag_trigger_active flag\n",
-		ioc->name, __func__));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: clearing diag_trigger_active flag\n",
+				    __func__));
 	ioc->diag_trigger_active = 0;
 	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
-	    __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: exit\n",
+					 __func__));
 }
 
 /**
@@ -115,22 +114,22 @@ mpt3sas_process_trigger_data(struct MPT3SAS_ADAPTER *ioc,
 {
 	u8 issue_reset = 0;
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: enter\n",
-	    ioc->name, __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: enter\n", __func__));
 
 	/* release the diag buffer trace */
 	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
 	    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {
-		dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: release trace diag buffer\n", ioc->name, __func__));
+		dTriggerDiagPrintk(ioc,
+				   ioc_info(ioc, "%s: release trace diag buffer\n",
+					    __func__));
 		mpt3sas_send_diag_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE,
 		    &issue_reset);
 	}
 
 	_mpt3sas_raise_sigio(ioc, event_data);
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
-	    __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: exit\n",
+					 __func__));
 }
 
 /**
@@ -168,9 +167,9 @@ mpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)
 
  by_pass_checks:
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: enter - trigger_bitmask = 0x%08x\n",
-		ioc->name, __func__, trigger_bitmask));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: enter - trigger_bitmask = 0x%08x\n",
+				    __func__, trigger_bitmask));
 
 	/* don't send trigger if an trigger is currently active */
 	if (ioc->diag_trigger_active) {
@@ -182,9 +181,9 @@ mpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)
 	if (ioc->diag_trigger_master.MasterData & trigger_bitmask) {
 		found_match = 1;
 		ioc->diag_trigger_active = 1;
-		dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: setting diag_trigger_active flag\n",
-		ioc->name, __func__));
+		dTriggerDiagPrintk(ioc,
+				   ioc_info(ioc, "%s: setting diag_trigger_active flag\n",
+					    __func__));
 	}
 	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
 
@@ -202,8 +201,8 @@ mpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)
 		mpt3sas_send_trigger_data_event(ioc, &event_data);
 
  out:
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
-	    __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: exit\n",
+					 __func__));
 }
 
 /**
@@ -239,9 +238,9 @@ mpt3sas_trigger_event(struct MPT3SAS_ADAPTER *ioc, u16 event,
 		return;
 	}
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: enter - event = 0x%04x, log_entry_qualifier = 0x%04x\n",
-		ioc->name, __func__, event, log_entry_qualifier));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: enter - event = 0x%04x, log_entry_qualifier = 0x%04x\n",
+				    __func__, event, log_entry_qualifier));
 
 	/* don't send trigger if an trigger is currently active */
 	if (ioc->diag_trigger_active) {
@@ -263,26 +262,26 @@ mpt3sas_trigger_event(struct MPT3SAS_ADAPTER *ioc, u16 event,
 		}
 		found_match = 1;
 		ioc->diag_trigger_active = 1;
-		dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-			"%s: setting diag_trigger_active flag\n",
-			ioc->name, __func__));
+		dTriggerDiagPrintk(ioc,
+				   ioc_info(ioc, "%s: setting diag_trigger_active flag\n",
+					    __func__));
 	}
 	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
 
 	if (!found_match)
 		goto out;
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: setting diag_trigger_active flag\n",
-		ioc->name, __func__));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: setting diag_trigger_active flag\n",
+				    __func__));
 	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
 	event_data.trigger_type = MPT3SAS_TRIGGER_EVENT;
 	event_data.u.event.EventValue = event;
 	event_data.u.event.LogEntryQualifier = log_entry_qualifier;
 	mpt3sas_send_trigger_data_event(ioc, &event_data);
  out:
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
-	    __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: exit\n",
+					 __func__));
 }
 
 /**
@@ -319,9 +318,9 @@ mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,
 		return;
 	}
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: enter - sense_key = 0x%02x, asc = 0x%02x, ascq = 0x%02x\n",
-		ioc->name, __func__, sense_key, asc, ascq));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: enter - sense_key = 0x%02x, asc = 0x%02x, ascq = 0x%02x\n",
+				    __func__, sense_key, asc, ascq));
 
 	/* don't send trigger if an trigger is currently active */
 	if (ioc->diag_trigger_active) {
@@ -347,9 +346,9 @@ mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,
 	if (!found_match)
 		goto out;
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: setting diag_trigger_active flag\n",
-		ioc->name, __func__));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: setting diag_trigger_active flag\n",
+				    __func__));
 	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
 	event_data.trigger_type = MPT3SAS_TRIGGER_SCSI;
 	event_data.u.scsi.SenseKey = sense_key;
@@ -357,8 +356,8 @@ mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,
 	event_data.u.scsi.ASCQ = ascq;
 	mpt3sas_send_trigger_data_event(ioc, &event_data);
  out:
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
-	    __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: exit\n",
+					 __func__));
 }
 
 /**
@@ -393,9 +392,9 @@ mpt3sas_trigger_mpi(struct MPT3SAS_ADAPTER *ioc, u16 ioc_status, u32 loginfo)
 		return;
 	}
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: enter - ioc_status = 0x%04x, loginfo = 0x%08x\n",
-		ioc->name, __func__, ioc_status, loginfo));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: enter - ioc_status = 0x%04x, loginfo = 0x%08x\n",
+				    __func__, ioc_status, loginfo));
 
 	/* don't send trigger if an trigger is currently active */
 	if (ioc->diag_trigger_active) {
@@ -420,15 +419,15 @@ mpt3sas_trigger_mpi(struct MPT3SAS_ADAPTER *ioc, u16 ioc_status, u32 loginfo)
 	if (!found_match)
 		goto out;
 
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: setting diag_trigger_active flag\n",
-		ioc->name, __func__));
+	dTriggerDiagPrintk(ioc,
+			   ioc_info(ioc, "%s: setting diag_trigger_active flag\n",
+				    __func__));
 	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
 	event_data.trigger_type = MPT3SAS_TRIGGER_MPI;
 	event_data.u.mpi.IOCStatus = ioc_status;
 	event_data.u.mpi.IocLogInfo = loginfo;
 	mpt3sas_send_trigger_data_event(ioc, &event_data);
  out:
-	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
-	    __func__));
+	dTriggerDiagPrintk(ioc, ioc_info(ioc, "%s: exit\n",
+					 __func__));
 }

commit 4beb4867f049aea801a93a8fc97801250e32d700
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Fri Jun 15 14:42:01 2018 -0700

    scsi: mpt3sas: Improve kernel-doc headers
    
    Avoids that warnings about the kernel headers appear when building with
    W=1. Remove useless "@Returns - Nothing" clauses. Change "@Return - " into
    "Return: ".
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Cc: Sathya Prakash <sathya.prakash@broadcom.com>
    Cc: Chaitra P B <chaitra.basappa@broadcom.com>
    Cc: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index b60fd7a3b571..cae7c1eaef34 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -62,7 +62,7 @@
 /**
  * _mpt3sas_raise_sigio - notifiy app
  * @ioc: per adapter object
- * @event_data:
+ * @event_data: ?
  */
 static void
 _mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
@@ -107,7 +107,7 @@ _mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
 /**
  * mpt3sas_process_trigger_data - process the event data for the trigger
  * @ioc: per adapter object
- * @event_data:
+ * @event_data: ?
  */
 void
 mpt3sas_process_trigger_data(struct MPT3SAS_ADAPTER *ioc,
@@ -209,8 +209,8 @@ mpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)
 /**
  * mpt3sas_trigger_event - Event trigger handler
  * @ioc: per adapter object
- * @event:
- * @log_entry_qualifier:
+ * @event: ?
+ * @log_entry_qualifier: ?
  *
  */
 void
@@ -288,9 +288,9 @@ mpt3sas_trigger_event(struct MPT3SAS_ADAPTER *ioc, u16 event,
 /**
  * mpt3sas_trigger_scsi - SCSI trigger handler
  * @ioc: per adapter object
- * @sense_key:
- * @asc:
- * @ascq:
+ * @sense_key: ?
+ * @asc: ?
+ * @ascq: ?
  *
  */
 void
@@ -364,8 +364,8 @@ mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,
 /**
  * mpt3sas_trigger_mpi - MPI trigger handler
  * @ioc: per adapter object
- * @ioc_status:
- * @loginfo:
+ * @ioc_status: ?
+ * @loginfo: ?
  *
  */
 void

commit a03bd153b1b31c24b00d516bdbf9370ab8132650
Author: Sreekanth Reddy <sreekanth.reddy@avagotech.com>
Date:   Mon Jan 12 11:39:02 2015 +0530

    mpt2sas, mpt3sas: Update attribution language to Avago
    
    Copyright, Trademark & Confidentiality legal statements throughout the
    source code changed from LSI to Avago.
    
    Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index 8a2dd113f401..b60fd7a3b571 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -4,7 +4,8 @@
  *
  * This code is based on drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
  * Copyright (C) 2012-2014  LSI Corporation
- *  (mailto:DL-MPTFusionLinux@lsi.com)
+ * Copyright (C) 2013-2014 Avago Technologies
+ *  (mailto: MPT-FusionLinux.pdl@avagotech.com)
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License

commit a4ffce0d63e0683060fee6bc269f7b0b12c9700a
Author: Sreekanth Reddy <sreekanth.reddy@avagotech.com>
Date:   Fri Sep 12 15:35:29 2014 +0530

    mpt3sas: Copyright in driver sources is updated for year the 2014.
    
    Copyright in driver sources is updated for year the 2014.
    
    Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@avagotech.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index f6533ab20364..8a2dd113f401 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -3,7 +3,7 @@
  * (Message Passing Technology) based controllers
  *
  * This code is based on drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
- * Copyright (C) 2012-2013  LSI Corporation
+ * Copyright (C) 2012-2014  LSI Corporation
  *  (mailto:DL-MPTFusionLinux@lsi.com)
  *
  * This program is free software; you can redistribute it and/or

commit 48e3b9855d6e1b408ec4a808f243e858a78f4482
Author: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
Date:   Sat Jun 29 03:50:34 2013 +0530

    [SCSI] mpt3sas: 2013 source code copyright
    
    The Copyright String in all mpt3sas files are changed to 2012-2013.
    
    Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index 6f8d6213040b..f6533ab20364 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -3,7 +3,7 @@
  * (Message Passing Technology) based controllers
  *
  * This code is based on drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
- * Copyright (C) 2012  LSI Corporation
+ * Copyright (C) 2012-2013  LSI Corporation
  *  (mailto:DL-MPTFusionLinux@lsi.com)
  *
  * This program is free software; you can redistribute it and/or

commit 3735660d7be66e2e508ff393f69214f2b4113ab2
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Dec 3 15:30:17 2012 +0530

    [SCSI] mpt3sas: Remove unneeded version.h header inclusion
    
    linux/version.h is not necessary as detected by checkversion.pl script.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: "Sreekanth Reddy" <Sreekanth.reddy@lsi.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index da6c5f25749c..6f8d6213040b 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -42,7 +42,6 @@
  * USA.
  */
 
-#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/errno.h>

commit f92363d12359498f9a9960511de1a550f0ec41c2
Author: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
Date:   Fri Nov 30 07:44:21 2012 +0530

    [SCSI] mpt3sas: add new driver supporting 12GB SAS
    
    These driver files are initially, substantially similar to mpt2sas but,
    because mpt2sas is going into maintenance mode and mp3sas will become heavily
    developed, we elected to keep the code bases separate.
    
    Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
    Reviewed-by: Nagalakshmi Nandigama <Nagalakshmi.Nandigama@lsi.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
new file mode 100644
index 000000000000..da6c5f25749c
--- /dev/null
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -0,0 +1,434 @@
+/*
+ * This module provides common API to set Diagnostic trigger for MPT
+ * (Message Passing Technology) based controllers
+ *
+ * This code is based on drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+ * Copyright (C) 2012  LSI Corporation
+ *  (mailto:DL-MPTFusionLinux@lsi.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * NO WARRANTY
+ * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+ * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+ * solely responsible for determining the appropriateness of using and
+ * distributing the Program and assumes all risks associated with its
+ * exercise of rights under this Agreement, including but not limited to
+ * the risks and costs of program errors, damage to or loss of data,
+ * programs or equipment, and unavailability or interruption of operations.
+
+ * DISCLAIMER OF LIABILITY
+ * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+ * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/compat.h>
+#include <linux/poll.h>
+
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include "mpt3sas_base.h"
+
+/**
+ * _mpt3sas_raise_sigio - notifiy app
+ * @ioc: per adapter object
+ * @event_data:
+ */
+static void
+_mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
+	struct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)
+{
+	Mpi2EventNotificationReply_t *mpi_reply;
+	u16 sz, event_data_sz;
+	unsigned long flags;
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: enter\n",
+	    ioc->name, __func__));
+
+	sz = offsetof(Mpi2EventNotificationReply_t, EventData) +
+	    sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T) + 4;
+	mpi_reply = kzalloc(sz, GFP_KERNEL);
+	if (!mpi_reply)
+		goto out;
+	mpi_reply->Event = cpu_to_le16(MPI3_EVENT_DIAGNOSTIC_TRIGGER_FIRED);
+	event_data_sz = (sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T) + 4) / 4;
+	mpi_reply->EventDataLength = cpu_to_le16(event_data_sz);
+	memcpy(&mpi_reply->EventData, event_data,
+	    sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: add to driver event log\n",
+		ioc->name, __func__));
+	mpt3sas_ctl_add_to_event_log(ioc, mpi_reply);
+	kfree(mpi_reply);
+ out:
+
+	/* clearing the diag_trigger_active flag */
+	spin_lock_irqsave(&ioc->diag_trigger_lock, flags);
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: clearing diag_trigger_active flag\n",
+		ioc->name, __func__));
+	ioc->diag_trigger_active = 0;
+	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
+	    __func__));
+}
+
+/**
+ * mpt3sas_process_trigger_data - process the event data for the trigger
+ * @ioc: per adapter object
+ * @event_data:
+ */
+void
+mpt3sas_process_trigger_data(struct MPT3SAS_ADAPTER *ioc,
+	struct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)
+{
+	u8 issue_reset = 0;
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: enter\n",
+	    ioc->name, __func__));
+
+	/* release the diag buffer trace */
+	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_RELEASED) == 0) {
+		dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: release trace diag buffer\n", ioc->name, __func__));
+		mpt3sas_send_diag_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE,
+		    &issue_reset);
+	}
+
+	_mpt3sas_raise_sigio(ioc, event_data);
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
+	    __func__));
+}
+
+/**
+ * mpt3sas_trigger_master - Master trigger handler
+ * @ioc: per adapter object
+ * @trigger_bitmask:
+ *
+ */
+void
+mpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)
+{
+	struct SL_WH_TRIGGERS_EVENT_DATA_T event_data;
+	unsigned long flags;
+	u8 found_match = 0;
+
+	spin_lock_irqsave(&ioc->diag_trigger_lock, flags);
+
+	if (trigger_bitmask & MASTER_TRIGGER_FW_FAULT ||
+	    trigger_bitmask & MASTER_TRIGGER_ADAPTER_RESET)
+		goto by_pass_checks;
+
+	/* check to see if trace buffers are currently registered */
+	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	/* check to see if trace buffers are currently released */
+	if (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_RELEASED) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+ by_pass_checks:
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: enter - trigger_bitmask = 0x%08x\n",
+		ioc->name, __func__, trigger_bitmask));
+
+	/* don't send trigger if an trigger is currently active */
+	if (ioc->diag_trigger_active) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		goto out;
+	}
+
+	/* check for the trigger condition */
+	if (ioc->diag_trigger_master.MasterData & trigger_bitmask) {
+		found_match = 1;
+		ioc->diag_trigger_active = 1;
+		dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: setting diag_trigger_active flag\n",
+		ioc->name, __func__));
+	}
+	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+
+	if (!found_match)
+		goto out;
+
+	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
+	event_data.trigger_type = MPT3SAS_TRIGGER_MASTER;
+	event_data.u.master.MasterData = trigger_bitmask;
+
+	if (trigger_bitmask & MASTER_TRIGGER_FW_FAULT ||
+	    trigger_bitmask & MASTER_TRIGGER_ADAPTER_RESET)
+		_mpt3sas_raise_sigio(ioc, &event_data);
+	else
+		mpt3sas_send_trigger_data_event(ioc, &event_data);
+
+ out:
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
+	    __func__));
+}
+
+/**
+ * mpt3sas_trigger_event - Event trigger handler
+ * @ioc: per adapter object
+ * @event:
+ * @log_entry_qualifier:
+ *
+ */
+void
+mpt3sas_trigger_event(struct MPT3SAS_ADAPTER *ioc, u16 event,
+	u16 log_entry_qualifier)
+{
+	struct SL_WH_TRIGGERS_EVENT_DATA_T event_data;
+	struct SL_WH_EVENT_TRIGGER_T *event_trigger;
+	int i;
+	unsigned long flags;
+	u8 found_match;
+
+	spin_lock_irqsave(&ioc->diag_trigger_lock, flags);
+
+	/* check to see if trace buffers are currently registered */
+	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	/* check to see if trace buffers are currently released */
+	if (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_RELEASED) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: enter - event = 0x%04x, log_entry_qualifier = 0x%04x\n",
+		ioc->name, __func__, event, log_entry_qualifier));
+
+	/* don't send trigger if an trigger is currently active */
+	if (ioc->diag_trigger_active) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		goto out;
+	}
+
+	/* check for the trigger condition */
+	event_trigger = ioc->diag_trigger_event.EventTriggerEntry;
+	for (i = 0 , found_match = 0; i < ioc->diag_trigger_event.ValidEntries
+	    && !found_match; i++, event_trigger++) {
+		if (event_trigger->EventValue != event)
+			continue;
+		if (event == MPI2_EVENT_LOG_ENTRY_ADDED) {
+			if (event_trigger->LogEntryQualifier ==
+			    log_entry_qualifier)
+				found_match = 1;
+			continue;
+		}
+		found_match = 1;
+		ioc->diag_trigger_active = 1;
+		dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+			"%s: setting diag_trigger_active flag\n",
+			ioc->name, __func__));
+	}
+	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+
+	if (!found_match)
+		goto out;
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: setting diag_trigger_active flag\n",
+		ioc->name, __func__));
+	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
+	event_data.trigger_type = MPT3SAS_TRIGGER_EVENT;
+	event_data.u.event.EventValue = event;
+	event_data.u.event.LogEntryQualifier = log_entry_qualifier;
+	mpt3sas_send_trigger_data_event(ioc, &event_data);
+ out:
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
+	    __func__));
+}
+
+/**
+ * mpt3sas_trigger_scsi - SCSI trigger handler
+ * @ioc: per adapter object
+ * @sense_key:
+ * @asc:
+ * @ascq:
+ *
+ */
+void
+mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,
+	u8 ascq)
+{
+	struct SL_WH_TRIGGERS_EVENT_DATA_T event_data;
+	struct SL_WH_SCSI_TRIGGER_T *scsi_trigger;
+	int i;
+	unsigned long flags;
+	u8 found_match;
+
+	spin_lock_irqsave(&ioc->diag_trigger_lock, flags);
+
+	/* check to see if trace buffers are currently registered */
+	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	/* check to see if trace buffers are currently released */
+	if (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_RELEASED) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: enter - sense_key = 0x%02x, asc = 0x%02x, ascq = 0x%02x\n",
+		ioc->name, __func__, sense_key, asc, ascq));
+
+	/* don't send trigger if an trigger is currently active */
+	if (ioc->diag_trigger_active) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		goto out;
+	}
+
+	/* check for the trigger condition */
+	scsi_trigger = ioc->diag_trigger_scsi.SCSITriggerEntry;
+	for (i = 0 , found_match = 0; i < ioc->diag_trigger_scsi.ValidEntries
+	    && !found_match; i++, scsi_trigger++) {
+		if (scsi_trigger->SenseKey != sense_key)
+			continue;
+		if (!(scsi_trigger->ASC == 0xFF || scsi_trigger->ASC == asc))
+			continue;
+		if (!(scsi_trigger->ASCQ == 0xFF || scsi_trigger->ASCQ == ascq))
+			continue;
+		found_match = 1;
+		ioc->diag_trigger_active = 1;
+	}
+	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+
+	if (!found_match)
+		goto out;
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: setting diag_trigger_active flag\n",
+		ioc->name, __func__));
+	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
+	event_data.trigger_type = MPT3SAS_TRIGGER_SCSI;
+	event_data.u.scsi.SenseKey = sense_key;
+	event_data.u.scsi.ASC = asc;
+	event_data.u.scsi.ASCQ = ascq;
+	mpt3sas_send_trigger_data_event(ioc, &event_data);
+ out:
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
+	    __func__));
+}
+
+/**
+ * mpt3sas_trigger_mpi - MPI trigger handler
+ * @ioc: per adapter object
+ * @ioc_status:
+ * @loginfo:
+ *
+ */
+void
+mpt3sas_trigger_mpi(struct MPT3SAS_ADAPTER *ioc, u16 ioc_status, u32 loginfo)
+{
+	struct SL_WH_TRIGGERS_EVENT_DATA_T event_data;
+	struct SL_WH_MPI_TRIGGER_T *mpi_trigger;
+	int i;
+	unsigned long flags;
+	u8 found_match;
+
+	spin_lock_irqsave(&ioc->diag_trigger_lock, flags);
+
+	/* check to see if trace buffers are currently registered */
+	if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_REGISTERED) == 0) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	/* check to see if trace buffers are currently released */
+	if (ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &
+	    MPT3_DIAG_BUFFER_IS_RELEASED) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		return;
+	}
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: enter - ioc_status = 0x%04x, loginfo = 0x%08x\n",
+		ioc->name, __func__, ioc_status, loginfo));
+
+	/* don't send trigger if an trigger is currently active */
+	if (ioc->diag_trigger_active) {
+		spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+		goto out;
+	}
+
+	/* check for the trigger condition */
+	mpi_trigger = ioc->diag_trigger_mpi.MPITriggerEntry;
+	for (i = 0 , found_match = 0; i < ioc->diag_trigger_mpi.ValidEntries
+	    && !found_match; i++, mpi_trigger++) {
+		if (mpi_trigger->IOCStatus != ioc_status)
+			continue;
+		if (!(mpi_trigger->IocLogInfo == 0xFFFFFFFF ||
+		    mpi_trigger->IocLogInfo == loginfo))
+			continue;
+		found_match = 1;
+		ioc->diag_trigger_active = 1;
+	}
+	spin_unlock_irqrestore(&ioc->diag_trigger_lock, flags);
+
+	if (!found_match)
+		goto out;
+
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT
+		"%s: setting diag_trigger_active flag\n",
+		ioc->name, __func__));
+	memset(&event_data, 0, sizeof(struct SL_WH_TRIGGERS_EVENT_DATA_T));
+	event_data.trigger_type = MPT3SAS_TRIGGER_MPI;
+	event_data.u.mpi.IOCStatus = ioc_status;
+	event_data.u.mpi.IocLogInfo = loginfo;
+	mpt3sas_send_trigger_data_event(ioc, &event_data);
+ out:
+	dTriggerDiagPrintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,
+	    __func__));
+}
