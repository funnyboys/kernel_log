commit 74577c3a48a85f235a0506d07f31d91f170d8b19
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Apr 30 14:38:39 2020 +0800

    drm/amd/powerplay: perform PG ungate prior to CG ungate
    
    Since gfxoff should be disabled first before trying to access those
    GC registers.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fc31499c2e5c..7e6dcdf7df73 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -322,12 +322,12 @@ static void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,
 		if (*level & profile_mode_mask) {
 			hwmgr->saved_dpm_level = hwmgr->dpm_level;
 			hwmgr->en_umd_pstate = true;
-			amdgpu_device_ip_set_clockgating_state(hwmgr->adev,
-						AMD_IP_BLOCK_TYPE_GFX,
-						AMD_CG_STATE_UNGATE);
 			amdgpu_device_ip_set_powergating_state(hwmgr->adev,
 					AMD_IP_BLOCK_TYPE_GFX,
 					AMD_PG_STATE_UNGATE);
+			amdgpu_device_ip_set_clockgating_state(hwmgr->adev,
+						AMD_IP_BLOCK_TYPE_GFX,
+						AMD_CG_STATE_UNGATE);
 		}
 	} else {
 		/* exit umd pstate, restore level, enable gfx cg*/

commit c7833d332e05cfa7b190b37dd3094c7257f1ea6d
Author: Tiecheng Zhou <Tiecheng.Zhou@amd.com>
Date:   Sun Apr 26 19:03:17 2020 +0800

    drm/amd/powerplay: avoid using pm_en before it is initialized revised
    
    hwmgr->pm_en is initialized at hwmgr_hw_init.
    
    during amdgpu_device_init, there is amdgpu_asic_reset that calls to
    soc15_asic_reset (for V320 usecase, Vega10 asic), in which:
    1) soc15_asic_reset_method calls to pp_get_asic_baco_capability (pm_en)
    2) soc15_asic_baco_reset calls to pp_set_asic_baco_state (pm_en)
    
    pm_en is used in the above two cases while it has not yet been initialized
    
    So avoid using pm_en in the above two functions for V320 passthrough.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Tiecheng Zhou <Tiecheng.Zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 71b843f542d8..fc31499c2e5c 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1438,7 +1438,8 @@ static int pp_get_asic_baco_capability(void *handle, bool *cap)
 	if (!hwmgr)
 		return -EINVAL;
 
-	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_asic_baco_capability)
+	if (!(hwmgr->not_vf && amdgpu_dpm) ||
+		!hwmgr->hwmgr_func->get_asic_baco_capability)
 		return 0;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1472,7 +1473,8 @@ static int pp_set_asic_baco_state(void *handle, int state)
 	if (!hwmgr)
 		return -EINVAL;
 
-	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->set_asic_baco_state)
+	if (!(hwmgr->not_vf && amdgpu_dpm) ||
+		!hwmgr->hwmgr_func->set_asic_baco_state)
 		return 0;
 
 	mutex_lock(&hwmgr->smu_lock);

commit a1cd1289a68c4f9fb7551edd06c6a6b4661a4cbb
Author: Tiecheng Zhou <Tiecheng.Zhou@amd.com>
Date:   Mon Apr 27 09:44:38 2020 +0800

    Revert "drm/amd/powerplay: avoid using pm_en before it is initialized"
    
    This reverts commit c5207876232649ca5e5ddd6f966d2da75ffded8f.
    
    The commit being reverted changed the wrong place, it should have
    changed in func get_asic_baco_capability.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Tiecheng Zhou <Tiecheng.Zhou@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fdff3e1c5e95..71b843f542d8 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1455,8 +1455,7 @@ static int pp_get_asic_baco_state(void *handle, int *state)
 	if (!hwmgr)
 		return -EINVAL;
 
-	if (!(hwmgr->not_vf && amdgpu_dpm) ||
-		!hwmgr->hwmgr_func->get_asic_baco_state)
+	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_asic_baco_state)
 		return 0;
 
 	mutex_lock(&hwmgr->smu_lock);

commit 764a21cb085b8d7d754b5d74e2ecc6adc064e3e7
Author: Tiecheng Zhou <Tiecheng.Zhou@amd.com>
Date:   Thu Apr 2 16:49:36 2020 +0800

    drm/amd/powerplay: avoid using pm_en before it is initialized
    
    hwmgr->pm_en is initialized at hwmgr_hw_init.
    during amdgpu_device_init, there is amdgpu_asic_reset that calls to
    pp_get_asic_baco_capability, while hwmgr->pm_en has not yet been initialized.
    
    so avoid using pm_en in pp_get_asic_baco_capability.
    
    Reviewed-by: Emily Deng <Emily.Deng@amd.com>
    Signed-off-by: Tiecheng Zhou <Tiecheng.Zhou@amd.com>
    Signed-off-by: Yintian Tao <yttao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 71b843f542d8..fdff3e1c5e95 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1455,7 +1455,8 @@ static int pp_get_asic_baco_state(void *handle, int *state)
 	if (!hwmgr)
 		return -EINVAL;
 
-	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_asic_baco_state)
+	if (!(hwmgr->not_vf && amdgpu_dpm) ||
+		!hwmgr->hwmgr_func->get_asic_baco_state)
 		return 0;
 
 	mutex_lock(&hwmgr->smu_lock);

commit 6b6706cdaca344a9279fe124bf87da040f5711fb
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Mar 27 11:20:29 2020 +0800

    drm/amd/powerplay: added mutex protection on msg issuing
    
    This could avoid the possible race condition.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index c195575366a3..71b843f542d8 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -50,6 +50,7 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 	hwmgr->not_vf = !amdgpu_sriov_vf(adev);
 	hwmgr->device = amdgpu_cgs_create_device(adev);
 	mutex_init(&hwmgr->smu_lock);
+	mutex_init(&hwmgr->msg_lock);
 	hwmgr->chip_family = adev->family;
 	hwmgr->chip_id = adev->asic_type;
 	hwmgr->feature_mask = adev->pm.pp_feature;
@@ -64,6 +65,8 @@ static void amd_powerplay_destroy(struct amdgpu_device *adev)
 {
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
+	mutex_destroy(&hwmgr->msg_lock);
+
 	kfree(hwmgr->hardcode_pp_table);
 	hwmgr->hardcode_pp_table = NULL;
 

commit 29a45960647b243af5f2aa73fd7a822ef3db33eb
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Jan 3 14:18:22 2020 +0800

    drm/amd/powerplay: refine code to support no-dpm case
    
    With "dpm=0", there will be no DPM enabled. The code
    needs to be refined to support this.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7293763d524c..c195575366a3 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -927,9 +927,12 @@ static int pp_dpm_set_mp1_state(void *handle, enum pp_mp1_state mp1_state)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
-	if (!hwmgr || !hwmgr->pm_en)
+	if (!hwmgr)
 		return -EINVAL;
 
+	if (!hwmgr->pm_en)
+		return 0;
+
 	if (hwmgr->hwmgr_func->set_mp1_state)
 		return hwmgr->hwmgr_func->set_mp1_state(hwmgr, mp1_state);
 

commit 8973d9ec8f0e5208909cae81bdeae87ba657359d
Author: Emily Deng <Emily.Deng@amd.com>
Date:   Mon Dec 16 17:19:44 2019 +0800

    drm/amdgpu/sriov: Tonga sriov also need load firmware with smu
    
    Fix Tonga sriov load driver fail issue.
    
    Signed-off-by: Emily Deng <Emily.Deng@amd.com>
    Reviewd-by Yintian Tao <Yintian.tao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 322c2015d3a0..7293763d524c 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -278,9 +278,6 @@ static int pp_dpm_load_fw(void *handle)
 	if (!hwmgr || !hwmgr->smumgr_funcs || !hwmgr->smumgr_funcs->start_smu)
 		return -EINVAL;
 
-	if (!hwmgr->not_vf)
-		return 0;
-
 	if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
 		pr_err("fw load failed\n");
 		return -EINVAL;

commit 63408972e4715ee03e470d9616e2b6aebd6f2595
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Dec 12 18:16:57 2019 +0000

    drm/amd/powerplay: fix various dereferences of a pointer before it is null checked
    
    There are several occurrances of the pointer hwmgr being dereferenced
    before it is null checked.  Fix these by performing the dereference
    of hwmgr after it has been null checked.
    
    Addresses-Coverity: ("Dereference before null check")
    Fixes: c9ffa427db34e6 ("drm/amd/powerplay: enable pp one vf mode for vega10")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 5087d6bdba60..322c2015d3a0 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -275,12 +275,12 @@ static int pp_dpm_load_fw(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
-	if (!hwmgr->not_vf)
-		return 0;
-
 	if (!hwmgr || !hwmgr->smumgr_funcs || !hwmgr->smumgr_funcs->start_smu)
 		return -EINVAL;
 
+	if (!hwmgr->not_vf)
+		return 0;
+
 	if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
 		pr_err("fw load failed\n");
 		return -EINVAL;

commit c9ffa427db34e6896523f0ef0c172a0bbb77c9ad
Author: Yintian Tao <yttao@amd.com>
Date:   Wed Oct 30 17:16:35 2019 +0800

    drm/amd/powerplay: enable pp one vf mode for vega10
    
    Originally, due to the restriction from PSP and SMU, VF has
    to send message to hypervisor driver to handle powerplay
    change which is complicated and redundant. Currently, SMU
    and PSP can support VF to directly handle powerplay
    change by itself. Therefore, the old code about the handshake
    between VF and PF to handle powerplay will be removed and VF
    will use new the registers below to handshake with SMU.
    mmMP1_SMN_C2PMSG_101: register to handle SMU message
    mmMP1_SMN_C2PMSG_102: register to handle SMU parameter
    mmMP1_SMN_C2PMSG_103: register to handle SMU response
    
    v2: remove module parameter pp_one_vf
    v3: fix the parens
    v4: forbid vf to change smu feature
    v5: use hwmon_attributes_visible to skip sepicified hwmon atrribute
    v6: change skip condition at vega10_copy_table_to_smc
    
    Signed-off-by: Yintian Tao <yttao@amd.com>
    Acked-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7932eb163a00..5087d6bdba60 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -48,7 +48,6 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 
 	hwmgr->adev = adev;
 	hwmgr->not_vf = !amdgpu_sriov_vf(adev);
-	hwmgr->pm_en = (amdgpu_dpm && hwmgr->not_vf) ? true : false;
 	hwmgr->device = amdgpu_cgs_create_device(adev);
 	mutex_init(&hwmgr->smu_lock);
 	hwmgr->chip_family = adev->family;
@@ -276,6 +275,9 @@ static int pp_dpm_load_fw(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
+	if (!hwmgr->not_vf)
+		return 0;
+
 	if (!hwmgr || !hwmgr->smumgr_funcs || !hwmgr->smumgr_funcs->start_smu)
 		return -EINVAL;
 

commit 558491dda004b8fc60fef0fcf2329f5bf0e53b08
Author: Kenneth Feng <kenneth.feng@amd.com>
Date:   Fri Nov 8 13:20:30 2019 +0800

    drm/amd/powerplay: dynamically disable ds and ulv for compute
    
    This is to improve the performance in the compute mode
    for vega10. For example, the original performance for a rocm
    bandwidth test: 2G internal GPU copy, is about 99GB/s.
    With the idle power features disabled dynamically, the porformance
    is promoted to about 215GB/s.
    
    Signed-off-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 031447675203..7932eb163a00 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -969,6 +969,14 @@ static int pp_dpm_switch_power_profile(void *handle,
 		workload = hwmgr->workload_setting[index];
 	}
 
+	if (type == PP_SMC_POWER_PROFILE_COMPUTE &&
+		hwmgr->hwmgr_func->disable_power_features_for_compute_performance) {
+			if (hwmgr->hwmgr_func->disable_power_features_for_compute_performance(hwmgr, en)) {
+				mutex_unlock(&hwmgr->smu_lock);
+				return -EINVAL;
+			}
+	}
+
 	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
 		hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, &workload, 0);
 	mutex_unlock(&hwmgr->smu_lock);

commit 3e454860f2a469e82c0f0dd7ff058a70a84a6f8b
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Oct 31 09:41:19 2019 +0800

    drm/amd/powerplay: support xgmi pstate setting on powerplay routine V2
    
    Add xgmi pstate setting on powerplay routine.
    
    V2: split the change of is_support_sw_smu_xgmi into a separate patch
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index f4ff15378e61..031447675203 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1566,6 +1566,23 @@ static int pp_set_df_cstate(void *handle, enum pp_df_cstate state)
 	return 0;
 }
 
+static int pp_set_xgmi_pstate(void *handle, uint32_t pstate)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr)
+		return -EINVAL;
+
+	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->set_xgmi_pstate)
+		return 0;
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->set_xgmi_pstate(hwmgr, pstate);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1625,4 +1642,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.asic_reset_mode_2 = pp_asic_reset_mode_2,
 	.smu_i2c_bus_access = pp_smu_i2c_bus_access,
 	.set_df_cstate = pp_set_df_cstate,
+	.set_xgmi_pstate = pp_set_xgmi_pstate,
 };

commit 4ff17a1df7d550257972a838220a8af4611c8f2c
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Oct 17 12:12:16 2019 +0300

    drm/amdgpu/vi: silence an uninitialized variable warning
    
    Smatch complains that we need to initialized "*cap" otherwise it can
    lead to an uninitialized variable bug in the caller.  This seems like a
    reasonable warning and it doesn't hurt to silence it at least.
    
    drivers/gpu/drm/amd/amdgpu/vi.c:767 vi_asic_reset_method() error: uninitialized symbol 'baco_reset'.
    
    Fixes: 425db2553e43 ("drm/amdgpu: expose BACO interfaces to upper level from PP")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 83196b79edd5..f4ff15378e61 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1421,6 +1421,7 @@ static int pp_get_asic_baco_capability(void *handle, bool *cap)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
+	*cap = false;
 	if (!hwmgr)
 		return -EINVAL;
 

commit 06615f9a0c0d68566fc069729aade64a7dbadd58
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Oct 10 11:34:51 2019 +0800

    drm/amd/powerplay: enable df cstate control on powerplay routine
    
    Currently this is only supported on Vega20 with 40.50 and later
    SMC firmware.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fa8ad7db2b3a..83196b79edd5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1548,6 +1548,23 @@ static int pp_smu_i2c_bus_access(void *handle, bool acquire)
 	return ret;
 }
 
+static int pp_set_df_cstate(void *handle, enum pp_df_cstate state)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr)
+		return -EINVAL;
+
+	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->set_df_cstate)
+		return 0;
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->set_df_cstate(hwmgr, state);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1606,4 +1623,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_ppfeature_status = pp_set_ppfeature_status,
 	.asic_reset_mode_2 = pp_asic_reset_mode_2,
 	.smu_i2c_bus_access = pp_smu_i2c_bus_access,
+	.set_df_cstate = pp_set_df_cstate,
 };

commit e6cbabcd70c7e6fd32766eb82baa50362ca9ae89
Author: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
Date:   Tue Sep 3 16:47:40 2019 -0400

    drm/amdgpu: Add smu lock around in pp_smu_i2c_bus_access
    
    Protect from concurrent SMU accesses.
    
    Signed-off-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Tao Zhou <tao.zhou1@amd.com>
    Reviewed-and-tested-by: Guchun Chen <guchun.chen@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fa636cb462c1..fa8ad7db2b3a 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1531,6 +1531,7 @@ static int pp_asic_reset_mode_2(void *handle)
 static int pp_smu_i2c_bus_access(void *handle, bool acquire)
 {
 	struct pp_hwmgr *hwmgr = handle;
+	int ret = 0;
 
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
@@ -1540,7 +1541,11 @@ static int pp_smu_i2c_bus_access(void *handle, bool acquire)
 		return -EINVAL;
 	}
 
-	return hwmgr->hwmgr_func->smu_i2c_bus_access(hwmgr, acquire);
+	mutex_lock(&hwmgr->smu_lock);
+	ret = hwmgr->hwmgr_func->smu_i2c_bus_access(hwmgr, acquire);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return ret;
 }
 
 static const struct amd_pm_funcs pp_dpm_funcs = {

commit 6acaa6af1501d17d40bb9aa5d76d5bb0b4936ed9
Author: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
Date:   Wed May 1 18:19:48 2019 -0400

    drm/amd/powerplay: Add interface to lock SMU HW I2C.
    
    v2:
    PPSMC_MSG_RequestI2CBus seems not to work and so to avoid conflict
    over I2C bus and engine disable thermal control access to
    force SMU stop using the I2C bus until the issue is reslolved.
    
    Expose and call vega20_is_smc_ram_running to skip locking when SMU
    FW is not yet loaded.
    
    v3:
    Remove the prevoius hack as the SMU found the bug.
    
    v5: Typo fix
    
    Signed-off-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7ef202761998..fa636cb462c1 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1528,6 +1528,21 @@ static int pp_asic_reset_mode_2(void *handle)
 	return ret;
 }
 
+static int pp_smu_i2c_bus_access(void *handle, bool acquire)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->smu_i2c_bus_access == NULL) {
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	return hwmgr->hwmgr_func->smu_i2c_bus_access(hwmgr, acquire);
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1585,4 +1600,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_ppfeature_status = pp_get_ppfeature_status,
 	.set_ppfeature_status = pp_set_ppfeature_status,
 	.asic_reset_mode_2 = pp_asic_reset_mode_2,
+	.smu_i2c_bus_access = pp_smu_i2c_bus_access,
 };

commit e97204ead61c79c292761c5c934a02dfe9967b71
Author: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
Date:   Wed Aug 14 16:26:35 2019 -0400

    drm/amd/poweplay: Add amd_pm_funcs callback for mode 2
    
    Add callback to call the new mode2 reset interface.
    
    Signed-off-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 2e3d9ef625bf..7ef202761998 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1508,6 +1508,26 @@ static int pp_set_ppfeature_status(void *handle, uint64_t ppfeature_masks)
 	return ret;
 }
 
+static int pp_asic_reset_mode_2(void *handle)
+{
+	struct pp_hwmgr *hwmgr = handle;
+		int ret = 0;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->asic_reset == NULL) {
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	ret = hwmgr->hwmgr_func->asic_reset(hwmgr, SMU_ASIC_RESET_MODE_2);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return ret;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1564,4 +1584,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_asic_baco_state = pp_set_asic_baco_state,
 	.get_ppfeature_status = pp_get_ppfeature_status,
 	.set_ppfeature_status = pp_set_ppfeature_status,
+	.asic_reset_mode_2 = pp_asic_reset_mode_2,
 };

commit 479baeacd82841e44cd860d84fa66fe6240f1814
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jul 30 21:27:03 2019 -0500

    drm/amdgpu/powerplay: return success if set_mp1_state is not set
    
    Some asics (APUs) don't have this callback so we want to return
    success.  Avoids spurious error messages on APUs.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 88a2ef75b7e1..2e3d9ef625bf 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -931,12 +931,10 @@ static int pp_dpm_set_mp1_state(void *handle, enum pp_mp1_state mp1_state)
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	if (hwmgr->hwmgr_func->set_mp1_state == NULL) {
-		pr_info_ratelimited("%s was not implemented.\n", __func__);
-		return -EINVAL;
-	}
+	if (hwmgr->hwmgr_func->set_mp1_state)
+		return hwmgr->hwmgr_func->set_mp1_state(hwmgr, mp1_state);
 
-	return hwmgr->hwmgr_func->set_mp1_state(hwmgr, mp1_state);
+	return 0;
 }
 
 static int pp_dpm_switch_power_profile(void *handle,

commit a2c28e34f8c42e35f5f2990d558d367152e63c27
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jul 25 09:41:53 2019 -0500

    drm/amdgpu/powerplay: add a new interface to set the mp1 state
    
    This is required for certain cases such as various GPU resets
    (mode1, mode2), BACO, shutdown, unload, etc. to put the SMU into
    the appropriate state for when the hw is re-initialized.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index bea1587d352d..88a2ef75b7e1 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -924,6 +924,21 @@ static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint3
 	return hwmgr->hwmgr_func->odn_edit_dpm_table(hwmgr, type, input, size);
 }
 
+static int pp_dpm_set_mp1_state(void *handle, enum pp_mp1_state mp1_state)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->set_mp1_state == NULL) {
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	return hwmgr->hwmgr_func->set_mp1_state(hwmgr, mp1_state);
+}
+
 static int pp_dpm_switch_power_profile(void *handle,
 		enum PP_SMC_POWER_PROFILE type, bool en)
 {
@@ -1525,6 +1540,7 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_power_profile_mode = pp_get_power_profile_mode,
 	.set_power_profile_mode = pp_set_power_profile_mode,
 	.odn_edit_dpm_table = pp_odn_edit_dpm_table,
+	.set_mp1_state = pp_dpm_set_mp1_state,
 	.set_power_limit = pp_set_power_limit,
 	.get_power_limit = pp_get_power_limit,
 /* export to DC */

commit 2a7821400f0f3c56fd6667c1a128afb0d70eac81
Author: Yang Wei <yang.wei9@zte.com.cn>
Date:   Thu Feb 28 22:48:04 2019 +0800

    drm/amd/powerplay: fix semicolon code style issue
    
    Delete superfluous semicolons.
    
    Signed-off-by: Yang Wei <yang.wei9@zte.com.cn>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index a66917d971df..bea1587d352d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1304,7 +1304,7 @@ static int pp_notify_smu_enable_pwe(void *handle)
 
 	if (hwmgr->hwmgr_func->smus_notify_pwe == NULL) {
 		pr_info_ratelimited("%s was not implemented.\n", __func__);
-		return -EINVAL;;
+		return -EINVAL;
 	}
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1341,7 +1341,7 @@ static int pp_set_min_deep_sleep_dcefclk(void *handle, uint32_t clock)
 
 	if (hwmgr->hwmgr_func->set_min_deep_sleep_dcefclk == NULL) {
 		pr_debug("%s was not implemented.\n", __func__);
-		return -EINVAL;;
+		return -EINVAL;
 	}
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1360,7 +1360,7 @@ static int pp_set_hard_min_dcefclk_by_freq(void *handle, uint32_t clock)
 
 	if (hwmgr->hwmgr_func->set_hard_min_dcefclk_by_freq == NULL) {
 		pr_debug("%s was not implemented.\n", __func__);
-		return -EINVAL;;
+		return -EINVAL;
 	}
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1379,7 +1379,7 @@ static int pp_set_hard_min_fclk_by_freq(void *handle, uint32_t clock)
 
 	if (hwmgr->hwmgr_func->set_hard_min_fclk_by_freq == NULL) {
 		pr_debug("%s was not implemented.\n", __func__);
-		return -EINVAL;;
+		return -EINVAL;
 	}
 
 	mutex_lock(&hwmgr->smu_lock);

commit 3b94fb101f4071da2b555632d8d68a353a9dde79
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Thu Jan 31 14:11:04 2019 +0800

    drm/amd/powerplay: add limit of pp_feature for smu (v3)
    
    Move pp_feature from the struct of amd_powerplay to amdgpu_device.
    Add pp_feature limit for overdrive interface.
    
    v2: put pp_feature into struct amdgpu_pm.
    v3: merge feature_mask with pp_feature.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Suggested-by: Alex Deucher <alexander.deucher@amd.com>
    Suggested-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 3f73f7cd18b9..a66917d971df 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -53,7 +53,7 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 	mutex_init(&hwmgr->smu_lock);
 	hwmgr->chip_family = adev->family;
 	hwmgr->chip_id = adev->asic_type;
-	hwmgr->feature_mask = adev->powerplay.pp_feature;
+	hwmgr->feature_mask = adev->pm.pp_feature;
 	hwmgr->display_config = &adev->pm.pm_display_cfg;
 	adev->powerplay.pp_handle = hwmgr;
 	adev->powerplay.pp_funcs = &pp_dpm_funcs;

commit 7ca881a8651bdeffd99ba8e0010160f9bf60673e
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Jan 14 14:06:54 2019 +0800

    drm/amd/powerplay: support enabled ppfeatures retrieving and setting V3
    
    User can use "ppfeatures" sysfs interface to retrieve and set enabled
    powerplay features.
    
    V2: expose this feature for Vega10 and later dGPUs
    V3: squash in removal of unused variable (Alex)
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 5d8b5d3c2453..3f73f7cd18b9 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1455,6 +1455,46 @@ static int pp_set_asic_baco_state(void *handle, int state)
 	return 0;
 }
 
+static int pp_get_ppfeature_status(void *handle, char *buf)
+{
+	struct pp_hwmgr *hwmgr = handle;
+	int ret = 0;
+
+	if (!hwmgr || !hwmgr->pm_en || !buf)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->get_ppfeature_status == NULL) {
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	ret = hwmgr->hwmgr_func->get_ppfeature_status(hwmgr, buf);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return ret;
+}
+
+static int pp_set_ppfeature_status(void *handle, uint64_t ppfeature_masks)
+{
+	struct pp_hwmgr *hwmgr = handle;
+	int ret = 0;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->set_ppfeature_status == NULL) {
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	ret = hwmgr->hwmgr_func->set_ppfeature_status(hwmgr, ppfeature_masks);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return ret;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1508,4 +1548,6 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_asic_baco_capability = pp_get_asic_baco_capability,
 	.get_asic_baco_state = pp_get_asic_baco_state,
 	.set_asic_baco_state = pp_set_asic_baco_state,
+	.get_ppfeature_status = pp_get_ppfeature_status,
+	.set_ppfeature_status = pp_set_ppfeature_status,
 };

commit 425db2553e43c7a40f3a9d8c066977493825339c
Author: Jim Qu <Jim.Qu@amd.com>
Date:   Wed Jan 9 16:42:05 2019 +0800

    drm/amdgpu: expose BACO interfaces to upper level from PP
    
    Signed-off-by: Jim Qu <Jim.Qu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9bc27f468d5b..5d8b5d3c2453 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1404,6 +1404,57 @@ static int pp_set_active_display_count(void *handle, uint32_t count)
 	return ret;
 }
 
+static int pp_get_asic_baco_capability(void *handle, bool *cap)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr)
+		return -EINVAL;
+
+	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_asic_baco_capability)
+		return 0;
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->get_asic_baco_capability(hwmgr, cap);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
+static int pp_get_asic_baco_state(void *handle, int *state)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr)
+		return -EINVAL;
+
+	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_asic_baco_state)
+		return 0;
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->get_asic_baco_state(hwmgr, (enum BACO_STATE *)state);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
+static int pp_set_asic_baco_state(void *handle, int state)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr)
+		return -EINVAL;
+
+	if (!hwmgr->pm_en || !hwmgr->hwmgr_func->set_asic_baco_state)
+		return 0;
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->set_asic_baco_state(hwmgr, (enum BACO_STATE)state);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1454,4 +1505,7 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_min_deep_sleep_dcefclk = pp_set_min_deep_sleep_dcefclk,
 	.set_hard_min_dcefclk_by_freq = pp_set_hard_min_dcefclk_by_freq,
 	.set_hard_min_fclk_by_freq = pp_set_hard_min_fclk_by_freq,
+	.get_asic_baco_capability = pp_get_asic_baco_capability,
+	.get_asic_baco_state = pp_get_asic_baco_state,
+	.set_asic_baco_state = pp_set_asic_baco_state,
 };

commit 9ed9203c3ee7acd3f6e2acb3f1f691366847c8b5
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Wed Nov 28 16:55:47 2018 -0500

    drm/amd/powerplay: rv dal-pplib interface refactor powerplay part
    
    [WHY] clarify dal input parameters to pplib interface, remove
    un-used parameters. dal knows exactly which parameters needed
    and their effects at pplib and smu sides.
    
    current dal sequence for dcn1_update_clock to pplib:
    
    1.smu10_display_clock_voltage_request for dcefclk
    2.smu10_display_clock_voltage_request for fclk
    3.phm_store_dal_configuration_data {
      set_min_deep_sleep_dcfclk
      set_active_display_count
      store_cc6_data --- this data never be referenced
    
    new sequence will be:
    
    1. set_display_count  --- need add new pplib interface
    2. set_min_deep_sleep_dcfclk -- new pplib interface
    3. set_hard_min_dcfclk_by_freq
    4. set_hard_min_fclk_by_freq
    
    after this code refactor, smu10_display_clock_voltage_request,
    phm_store_dal_configuration_data will not be needed for rv.
    
    [HOW] step 1: add new functions at pplib interface
          step 2: add new functions at amdgpu dm and dc
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b68c2e0fef01..9bc27f468d5b 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -725,7 +725,7 @@ static int pp_dpm_force_clock_level(void *handle,
 	}
 
 	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
-		pr_info("force clock level is for dpm manual mode only.\n");
+		pr_debug("force clock level is for dpm manual mode only.\n");
 		return -EINVAL;
 	}
 
@@ -899,7 +899,7 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 	}
 
 	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
-		pr_info("power profile setting is for manual dpm mode only.\n");
+		pr_debug("power profile setting is for manual dpm mode only.\n");
 		return ret;
 	}
 
@@ -1072,7 +1072,7 @@ static int pp_get_current_clocks(void *handle,
 					&hw_clocks, PHM_PerformanceLevelDesignation_Activity);
 
 	if (ret) {
-		pr_info("Error in phm_get_clock_info \n");
+		pr_debug("Error in phm_get_clock_info \n");
 		mutex_unlock(&hwmgr->smu_lock);
 		return -EINVAL;
 	}
@@ -1332,6 +1332,78 @@ static int pp_enable_mgpu_fan_boost(void *handle)
 	return 0;
 }
 
+static int pp_set_min_deep_sleep_dcefclk(void *handle, uint32_t clock)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->set_min_deep_sleep_dcefclk == NULL) {
+		pr_debug("%s was not implemented.\n", __func__);
+		return -EINVAL;;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->set_min_deep_sleep_dcefclk(hwmgr, clock);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
+static int pp_set_hard_min_dcefclk_by_freq(void *handle, uint32_t clock)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->set_hard_min_dcefclk_by_freq == NULL) {
+		pr_debug("%s was not implemented.\n", __func__);
+		return -EINVAL;;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->set_hard_min_dcefclk_by_freq(hwmgr, clock);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
+static int pp_set_hard_min_fclk_by_freq(void *handle, uint32_t clock)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->set_hard_min_fclk_by_freq == NULL) {
+		pr_debug("%s was not implemented.\n", __func__);
+		return -EINVAL;;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->set_hard_min_fclk_by_freq(hwmgr, clock);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
+static int pp_set_active_display_count(void *handle, uint32_t count)
+{
+	struct pp_hwmgr *hwmgr = handle;
+	int ret = 0;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	mutex_lock(&hwmgr->smu_lock);
+	ret = phm_set_active_display_count(hwmgr, count);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return ret;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1378,4 +1450,8 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
 	.notify_smu_enable_pwe = pp_notify_smu_enable_pwe,
 	.enable_mgpu_fan_boost = pp_enable_mgpu_fan_boost,
+	.set_active_display_count = pp_set_active_display_count,
+	.set_min_deep_sleep_dcefclk = pp_set_min_deep_sleep_dcefclk,
+	.set_hard_min_dcefclk_by_freq = pp_set_hard_min_dcefclk_by_freq,
+	.set_hard_min_fclk_by_freq = pp_set_hard_min_fclk_by_freq,
 };

commit 527aa2a0ac241d3ecc02c628db50b16d87e646e0
Author: Joerg Roedel <jroedel@suse.de>
Date:   Thu Nov 15 14:40:29 2018 +0100

    drm/amd/powerplay: Ratelimit all "was not implemented" messages
    
    Running kfdtest on an AMD Carizzo flooded the kernel log
    with thousands of these "was not implemented" messages,
    making it impossible to see other messages there.
    
    Ratelimit the messages to prevent user-space from flooding
    the kernel log.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index d6aa1d414320..b68c2e0fef01 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -300,7 +300,7 @@ static int pp_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -387,7 +387,7 @@ static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 		return 0;
 
 	if (hwmgr->hwmgr_func->get_sclk == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -405,7 +405,7 @@ static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 		return 0;
 
 	if (hwmgr->hwmgr_func->get_mclk == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -422,7 +422,7 @@ static void pp_dpm_powergate_vce(void *handle, bool gate)
 		return;
 
 	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -438,7 +438,7 @@ static void pp_dpm_powergate_uvd(void *handle, bool gate)
 		return;
 
 	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -505,7 +505,7 @@ static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 		return;
 
 	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -522,7 +522,7 @@ static uint32_t pp_dpm_get_fan_control_mode(void *handle)
 		return 0;
 
 	if (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -540,7 +540,7 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -558,7 +558,7 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -594,7 +594,7 @@ static int pp_dpm_set_fan_speed_rpm(void *handle, uint32_t rpm)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_fan_speed_rpm == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -720,7 +720,7 @@ static int pp_dpm_force_clock_level(void *handle,
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->force_clock_level == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -745,7 +745,7 @@ static int pp_dpm_print_clock_levels(void *handle,
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->print_clock_levels == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -763,7 +763,7 @@ static int pp_dpm_get_sclk_od(void *handle)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_sclk_od == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -781,7 +781,7 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_sclk_od == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -800,7 +800,7 @@ static int pp_dpm_get_mclk_od(void *handle)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_mclk_od == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -818,7 +818,7 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_mclk_od == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	mutex_lock(&hwmgr->smu_lock);
@@ -878,7 +878,7 @@ static int pp_get_power_profile_mode(void *handle, char *buf)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_power_profile_mode == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return snprintf(buf, PAGE_SIZE, "\n");
 	}
 
@@ -894,7 +894,7 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 		return ret;
 
 	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return ret;
 	}
 
@@ -917,7 +917,7 @@ static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint3
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->odn_edit_dpm_table == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return -EINVAL;
 	}
 
@@ -935,7 +935,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return -EINVAL;
 	}
 
@@ -972,7 +972,7 @@ static int pp_set_power_limit(void *handle, uint32_t limit)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_power_limit == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return -EINVAL;
 	}
 
@@ -1212,7 +1212,7 @@ static int pp_dpm_powergate_mmhub(void *handle)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->powergate_mmhub == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -1227,7 +1227,7 @@ static int pp_dpm_powergate_gfx(void *handle, bool gate)
 		return 0;
 
 	if (hwmgr->hwmgr_func->powergate_gfx == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -1242,7 +1242,7 @@ static void pp_dpm_powergate_acp(void *handle, bool gate)
 		return;
 
 	if (hwmgr->hwmgr_func->powergate_acp == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return;
 	}
 
@@ -1257,7 +1257,7 @@ static void pp_dpm_powergate_sdma(void *handle, bool gate)
 		return;
 
 	if (hwmgr->hwmgr_func->powergate_sdma == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return;
 	}
 
@@ -1303,7 +1303,7 @@ static int pp_notify_smu_enable_pwe(void *handle)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->smus_notify_pwe == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_info_ratelimited("%s was not implemented.\n", __func__);
 		return -EINVAL;;
 	}
 

commit 5be3bb6e92549f246f472d74bfaa54f56acbf998
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Oct 31 14:15:04 2018 +0800

    drm/amd/powerplay: no MGPU fan boost enablement on DPM disabled
    
    As MGPU fan boost feature will be definitely not needed when
    DPM is disabled. So, there is no need to error out.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index bf09735ea3ac..d6aa1d414320 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1318,12 +1318,12 @@ static int pp_enable_mgpu_fan_boost(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
-	if (!hwmgr || !hwmgr->pm_en)
+	if (!hwmgr)
 		return -EINVAL;
 
-	if (hwmgr->hwmgr_func->enable_mgpu_fan_boost == NULL) {
+	if (!hwmgr->pm_en ||
+	     hwmgr->hwmgr_func->enable_mgpu_fan_boost == NULL)
 		return 0;
-	}
 
 	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->enable_mgpu_fan_boost(hwmgr);

commit f7becf9a0803030ae125189823328e2d62b90f7b
Author: Joseph Greathouse <Joseph.Greathouse@amd.com>
Date:   Thu Oct 18 14:57:45 2018 -0500

    drm/amd/pp: enable power limit increase in OD mode
    
    OverDrive mode allows users to increase the maximum SCLK and MCLK
    frequencies beyond the default on the GPU. However, this may not
    results in large performance gains if the GPU then runs into its TDP
    power limit. This patch adds the capability to increase the power
    limit of a GPU above its default maximum.
    
    This is only allowed when overdrive is enabled in the ppfeaturemask,
    since this is an overdrive feature. The TDPODLimit value from the
    VBIOS describes how how much higher the TDP should be allowed to go
    over its default, in percentage.
    
    v2: Moved dereference of hwmgr to after its validity check
    
    Signed-off-by: Joseph Greathouse <Joseph.Greathouse@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index da9ff2cc2777..bf09735ea3ac 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -966,6 +966,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 static int pp_set_power_limit(void *handle, uint32_t limit)
 {
 	struct pp_hwmgr *hwmgr = handle;
+	uint32_t max_power_limit;
 
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
@@ -978,7 +979,13 @@ static int pp_set_power_limit(void *handle, uint32_t limit)
 	if (limit == 0)
 		limit = hwmgr->default_power_limit;
 
-	if (limit > hwmgr->default_power_limit)
+	max_power_limit = hwmgr->default_power_limit;
+	if (hwmgr->od_enabled) {
+		max_power_limit *= (100 + hwmgr->platform_descriptor.TDPODLimit);
+		max_power_limit /= 100;
+	}
+
+	if (limit > max_power_limit)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -997,8 +1004,13 @@ static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 
 	mutex_lock(&hwmgr->smu_lock);
 
-	if (default_limit)
+	if (default_limit) {
 		*limit = hwmgr->default_power_limit;
+		if (hwmgr->od_enabled) {
+			*limit *= (100 + hwmgr->platform_descriptor.TDPODLimit);
+			*limit /= 100;
+		}
+	}
 	else
 		*limit = hwmgr->power_limit;
 

commit 241dbbb1fb21bfff0c46c6873cee5c7923d05378
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Oct 17 16:36:02 2018 +0800

    drm/amd/powerplay: error out when force clock level under auto dpm mode V2
    
    Forcing clock level is supported under manual dpm mode only. Error out
    when trying to set under manual mode. Instead of doing nothing and
    reporting success.
    
    V2: update for mclk/pcie clock level settings also
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index e8964cae6b93..da9ff2cc2777 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -723,11 +723,14 @@ static int pp_dpm_force_clock_level(void *handle,
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
+
+	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
+		pr_info("force clock level is for dpm manual mode only.\n");
+		return -EINVAL;
+	}
+
 	mutex_lock(&hwmgr->smu_lock);
-	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
-		ret = hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
-	else
-		ret = -EINVAL;
+	ret = hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
 	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }

commit 7a862028b95a54adf9b3b88a1415e15478c257be
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Oct 10 15:24:59 2018 +0800

    drm/amd/powerplay: hint when power profile setting is not supported
    
    Give user some hints when the power profile setting is not supported.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 75b56ae032ce..e8964cae6b93 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -894,9 +894,14 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 		pr_info("%s was not implemented.\n", __func__);
 		return ret;
 	}
+
+	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
+		pr_info("power profile setting is for manual dpm mode only.\n");
+		return ret;
+	}
+
 	mutex_lock(&hwmgr->smu_lock);
-	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
-		ret = hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
+	ret = hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
 	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }

commit 735f654e5dd1c55d28aa04d49a9b7fcd3d5cccd0
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Oct 9 14:22:04 2018 +0800

    drm/amdgpu: Remove amdgpu_ucode_fini_bo
    
    The variable clean is unnecessary.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6bc8e9c08b0c..75b56ae032ce 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -109,9 +109,6 @@ static int pp_sw_fini(void *handle)
 
 	hwmgr_sw_fini(hwmgr);
 
-	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
-		amdgpu_ucode_fini_bo(adev);
-
 	release_firmware(adev->pm.fw);
 	adev->pm.fw = NULL;
 

commit 9c8bc8d3394963c9bd4b5bcce03303c56dc3104b
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sat Sep 29 20:28:14 2018 +0800

    drm/amd/pp: Implement load_firmware interface
    
    with this interface, gfx/sdma can be initialized
    before smu.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b2ebcb1457b5..6bc8e9c08b0c 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -270,8 +270,23 @@ const struct amdgpu_ip_block_version pp_smu_ip_block =
 	.funcs = &pp_ip_funcs,
 };
 
+/* This interface only be supported On Vi,
+ * because only smu7/8 can help to load gfx/sdma fw,
+ * smu need to be enabled before load other ip's fw.
+ * so call start smu to load smu7 fw and other ip's fw
+ */
 static int pp_dpm_load_fw(void *handle)
 {
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->smumgr_funcs || !hwmgr->smumgr_funcs->start_smu)
+		return -EINVAL;
+
+	if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
+		pr_err("fw load failed\n");
+		return -EINVAL;
+	}
+
 	return 0;
 }
 

commit 744a522794bdc64391039177153ef973cbff1297
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sat Sep 29 15:42:52 2018 +0800

    drm/amd/pp: Allocate ucode bo in request_smu_load_fw
    
    ucode bo is needed by request_smu_load_fw,
    the request_smu_load_fw maybe called by gfx/sdma
    before smu hw init.
    so move amdgpu_ucode_bo_init to request_smu_lowd_fw
    from smu hw init.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index e51d961a94b2..b2ebcb1457b5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -124,9 +124,6 @@ static int pp_hw_init(void *handle)
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
-	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
-		amdgpu_ucode_init_bo(adev);
-
 	ret = hwmgr_hw_init(hwmgr);
 
 	if (ret)

commit 3023015f791639838ec5d80e5c14851238a1a7d9
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sat Sep 29 14:52:31 2018 +0800

    drm/amd/pp: Fix memory leak on CI/AI
    
    On CI/AI, fw was not loaded by smu, but
    smu's fw still need to be released
    when driver fini.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9d8fa2e39bad..e51d961a94b2 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -109,11 +109,11 @@ static int pp_sw_fini(void *handle)
 
 	hwmgr_sw_fini(hwmgr);
 
-	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU) {
-		release_firmware(adev->pm.fw);
-		adev->pm.fw = NULL;
+	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
 		amdgpu_ucode_fini_bo(adev);
-	}
+
+	release_firmware(adev->pm.fw);
+	adev->pm.fw = NULL;
 
 	return 0;
 }

commit c2870527f700e919fbb543baef36032be5d626e0
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Sep 20 14:30:55 2018 +0800

    drm/amdgpu: Add fan RPM setting via sysfs
    
    Add fan1_target for get/set fan speed in RPM unit
    Add fan1_min/fan1_max for get min, max fan speed in RPM unit
    Add fan1_enable to enable/disable the fan1 sensor
    
    v3: drop the hardcode value of min/max rpm in comments pointed
        out by Alex.
    v2: query the min/max rpm gpu support instand of hardcode value.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 053c485baed0..9d8fa2e39bad 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -576,6 +576,24 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 	return ret;
 }
 
+static int pp_dpm_set_fan_speed_rpm(void *handle, uint32_t rpm)
+{
+	struct pp_hwmgr *hwmgr = handle;
+	int ret = 0;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->set_fan_speed_rpm == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+	mutex_lock(&hwmgr->smu_lock);
+	ret = hwmgr->hwmgr_func->set_fan_speed_rpm(hwmgr, rpm);
+	mutex_unlock(&hwmgr->smu_lock);
+	return ret;
+}
+
 static int pp_dpm_get_pp_num_states(void *handle,
 		struct pp_states_info *data)
 {
@@ -1297,6 +1315,7 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,
 	.get_fan_speed_percent = pp_dpm_get_fan_speed_percent,
 	.get_fan_speed_rpm = pp_dpm_get_fan_speed_rpm,
+	.set_fan_speed_rpm = pp_dpm_set_fan_speed_rpm,
 	.get_pp_num_states = pp_dpm_get_pp_num_states,
 	.get_pp_table = pp_dpm_get_pp_table,
 	.set_pp_table = pp_dpm_set_pp_table,

commit d5f480372ca485806443afca50ef024623f8eb03
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sun Sep 30 13:19:00 2018 +0800

    drm/amd/pp: Implement AMDGPU_PP_SENSOR_MIN/MAX_FAN_RPM
    
    so user can query the RPM range
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 32f475e37051..053c485baed0 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -813,6 +813,12 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 	case AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK:
 		*((uint32_t *)value) = hwmgr->pstate_mclk;
 		return 0;
+	case AMDGPU_PP_SENSOR_MIN_FAN_RPM:
+		*((uint32_t *)value) = hwmgr->thermal_controller.fanInfo.ulMinRPM;
+		return 0;
+	case AMDGPU_PP_SENSOR_MAX_FAN_RPM:
+		*((uint32_t *)value) = hwmgr->thermal_controller.fanInfo.ulMaxRPM;
+		return 0;
 	default:
 		mutex_lock(&hwmgr->smu_lock);
 		ret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);

commit 40bea02f4a1414f0163c5380423f578b3507e69f
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Sep 25 19:45:46 2018 +0800

    drm/amd/pp: Expose the smu support for SDMA PG cntl
    
    SDMA IP can be power up/down via smu message
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index c2e541266273..32f475e37051 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1196,6 +1196,21 @@ static void pp_dpm_powergate_acp(void *handle, bool gate)
 	hwmgr->hwmgr_func->powergate_acp(hwmgr, gate);
 }
 
+static void pp_dpm_powergate_sdma(void *handle, bool gate)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr)
+		return;
+
+	if (hwmgr->hwmgr_func->powergate_sdma == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return;
+	}
+
+	hwmgr->hwmgr_func->powergate_sdma(hwmgr, gate);
+}
+
 static int pp_set_powergating_by_smu(void *handle,
 				uint32_t block_type, bool gate)
 {
@@ -1218,6 +1233,9 @@ static int pp_set_powergating_by_smu(void *handle,
 	case AMD_IP_BLOCK_TYPE_ACP:
 		pp_dpm_powergate_acp(handle, gate);
 		break;
+	case AMD_IP_BLOCK_TYPE_SDMA:
+		pp_dpm_powergate_sdma(handle, gate);
+		break;
 	default:
 		break;
 	}

commit b55c9e7a11f9993328a46b43f3c9e4ca1962c352
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Sep 27 13:43:16 2018 +0800

    drm/amd/powerplay: helper interfaces for MGPU fan boost feature
    
    MGPU fan boost feature is enabled only when two or more dGPUs
    in the system.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index da4ebff5b74d..c2e541266273 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1243,6 +1243,24 @@ static int pp_notify_smu_enable_pwe(void *handle)
 	return 0;
 }
 
+static int pp_enable_mgpu_fan_boost(void *handle)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
+
+	if (hwmgr->hwmgr_func->enable_mgpu_fan_boost == NULL) {
+		return 0;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->enable_mgpu_fan_boost(hwmgr);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1287,4 +1305,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.display_clock_voltage_request = pp_display_clock_voltage_request,
 	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
 	.notify_smu_enable_pwe = pp_notify_smu_enable_pwe,
+	.enable_mgpu_fan_boost = pp_enable_mgpu_fan_boost,
 };

commit 982976d92f17aa8ff5d7a4d09fab4608795d12f3
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Jul 19 13:49:07 2018 +0800

    drm/amd/pp: Add ACP PG support in SMU
    
    when ACP block not enabled, we power off
    acp block to save power.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7a646f94b478..da4ebff5b74d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1181,6 +1181,21 @@ static int pp_dpm_powergate_gfx(void *handle, bool gate)
 	return hwmgr->hwmgr_func->powergate_gfx(hwmgr, gate);
 }
 
+static void pp_dpm_powergate_acp(void *handle, bool gate)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return;
+
+	if (hwmgr->hwmgr_func->powergate_acp == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return;
+	}
+
+	hwmgr->hwmgr_func->powergate_acp(hwmgr, gate);
+}
+
 static int pp_set_powergating_by_smu(void *handle,
 				uint32_t block_type, bool gate)
 {
@@ -1200,6 +1215,9 @@ static int pp_set_powergating_by_smu(void *handle,
 	case AMD_IP_BLOCK_TYPE_GFX:
 		ret = pp_dpm_powergate_gfx(handle, gate);
 		break;
+	case AMD_IP_BLOCK_TYPE_ACP:
+		pp_dpm_powergate_acp(handle, gate);
+		break;
 	default:
 		break;
 	}

commit 97e8f102f5a9123d30258e196c6c1ea29cf52e83
Author: Rex Zhu <rex.zhu@amd.com>
Date:   Tue Jul 17 18:31:50 2018 +0800

    drm/amd/pp: Set Max clock level to display by default
    
    avoid the error in dmesg:
    [drm:dm_pp_get_static_clocks]
    *ERROR* DM_PPLIB: invalid powerlevel state: 0!
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 75c208283e5f..7a646f94b478 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -998,7 +998,7 @@ static int pp_get_display_power_level(void *handle,
 static int pp_get_current_clocks(void *handle,
 		struct amd_pp_clock_info *clocks)
 {
-	struct amd_pp_simple_clock_info simple_clocks;
+	struct amd_pp_simple_clock_info simple_clocks = { 0 };
 	struct pp_clock_info hw_clocks;
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
@@ -1034,7 +1034,10 @@ static int pp_get_current_clocks(void *handle,
 	clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
 	clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
 
-	clocks->max_clocks_state = simple_clocks.level;
+	if (simple_clocks.level == 0)
+		clocks->max_clocks_state = PP_DAL_POWERLEVEL_7;
+	else
+		clocks->max_clocks_state = simple_clocks.level;
 
 	if (0 == phm_get_current_shallow_sleep_clocks(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks)) {
 		clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
@@ -1137,6 +1140,8 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
+	clocks->level = PP_DAL_POWERLEVEL_7;
+
 	mutex_lock(&hwmgr->smu_lock);
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))

commit 0d7f824b3342c774ea18062f5f0f39d542947c34
Author: kbuild test robot <fengguang.wu@intel.com>
Date:   Wed Jul 11 01:11:08 2018 +0800

    drm/amd/pp: fix semicolon.cocci warnings
    
    drivers/gpu/drm/amd/amdgpu/../powerplay/amd_powerplay.c:1209:17-18: Unneeded semicolon
    
     Remove unneeded semicolon.
    
    Generated by: scripts/coccinelle/misc/semicolon.cocci
    
    Fixes: ea870e44415a ("drm/amd/pp: Export notify_smu_enable_pwe to display")
    CC: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 145e5c403bea..75c208283e5f 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1206,7 +1206,7 @@ static int pp_notify_smu_enable_pwe(void *handle)
 	struct pp_hwmgr *hwmgr = handle;
 
 	if (!hwmgr || !hwmgr->pm_en)
-		return -EINVAL;;
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->smus_notify_pwe == NULL) {
 		pr_info("%s was not implemented.\n", __func__);

commit ea870e44415a5f5ed09b6e002e38d3e0de7f390e
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Jun 22 14:12:59 2018 +0800

    drm/amd/pp: Export notify_smu_enable_pwe to display
    
    Display can notify smu to enable pwe after gpu suspend.
    It is used in case when display resumes from S3 and wants to start
    audio driver by enabling pwe
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b72cc644d4e7..145e5c403bea 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1201,6 +1201,25 @@ static int pp_set_powergating_by_smu(void *handle,
 	return ret;
 }
 
+static int pp_notify_smu_enable_pwe(void *handle)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;;
+
+	if (hwmgr->hwmgr_func->smus_notify_pwe == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return -EINVAL;;
+	}
+
+	mutex_lock(&hwmgr->smu_lock);
+	hwmgr->hwmgr_func->smus_notify_pwe(hwmgr);
+	mutex_unlock(&hwmgr->smu_lock);
+
+	return 0;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1244,4 +1263,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_watermarks_for_clocks_ranges = pp_set_watermarks_for_clocks_ranges,
 	.display_clock_voltage_request = pp_display_clock_voltage_request,
 	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
+	.notify_smu_enable_pwe = pp_notify_smu_enable_pwe,
 };

commit 99c5e27d3368eb92476f47530355a6f25bf486e8
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Jun 22 18:26:52 2018 +0800

    drm/amd/pp: Refine the interface exported to display
    
    use void * as function parameter type in order for extension.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 387a1eb6678d..b72cc644d4e7 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1096,17 +1096,17 @@ static int pp_get_clock_by_type_with_voltage(void *handle,
 }
 
 static int pp_set_watermarks_for_clocks_ranges(void *handle,
-		struct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)
+		void *clock_ranges)
 {
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	if (!hwmgr || !hwmgr->pm_en ||!wm_with_clock_ranges)
+	if (!hwmgr || !hwmgr->pm_en || !clock_ranges)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_set_watermarks_for_clocks_ranges(hwmgr,
-			wm_with_clock_ranges);
+			clock_ranges);
 	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;

commit 9134c6d7f288f902d932e7cf57fab2f49e8ad70b
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jun 5 11:46:35 2018 +0800

    drm/amdgpu: Add gfx_off support in smu through pp_set_powergating_by_smu
    
    we can take gfx off feature as gfx power gate. gfx off feature is also
    controled by smu. so add gfx_off support in pp_set_powergating_by_smu.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index ef4884b0ddff..387a1eb6678d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -221,23 +221,7 @@ static int pp_sw_reset(void *handle)
 static int pp_set_powergating_state(void *handle,
 				    enum amd_powergating_state state)
 {
-	struct amdgpu_device *adev = handle;
-	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret;
-
-	if (!hwmgr || !hwmgr->pm_en)
-		return 0;
-
-	if (hwmgr->hwmgr_func->gfx_off_control) {
-		/* Enable/disable GFX off through SMU */
-		ret = hwmgr->hwmgr_func->gfx_off_control(hwmgr,
-							 state == AMD_PG_STATE_GATE);
-		if (ret)
-			pr_err("gfx off control failed!\n");
-	}
-
 	return 0;
-
 }
 
 static int pp_suspend(void *handle)

commit 85f80cb3af10f5daf79eee28300c3bbc55a70666
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Jun 14 13:07:19 2018 +0800

    drm/amd/pp: Add gfx pg support in smu through set_powergating_by_smu
    
    gfx ip block can call set_powergating_by_smu to set gfx pg state if
    necessary.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index f68551ffb1e2..ef4884b0ddff 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -236,14 +236,7 @@ static int pp_set_powergating_state(void *handle,
 			pr_err("gfx off control failed!\n");
 	}
 
-	if (hwmgr->hwmgr_func->powergate_gfx == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return 0;
-	}
-
-	/* Enable/disable GFX per cu powergating through SMU */
-	return hwmgr->hwmgr_func->powergate_gfx(hwmgr,
-			state == AMD_PG_STATE_GATE);
+	return 0;
 
 }
 
@@ -1184,6 +1177,21 @@ static int pp_dpm_powergate_mmhub(void *handle)
 	return hwmgr->hwmgr_func->powergate_mmhub(hwmgr);
 }
 
+static int pp_dpm_powergate_gfx(void *handle, bool gate)
+{
+	struct pp_hwmgr *hwmgr = handle;
+
+	if (!hwmgr || !hwmgr->pm_en)
+		return 0;
+
+	if (hwmgr->hwmgr_func->powergate_gfx == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->powergate_gfx(hwmgr, gate);
+}
+
 static int pp_set_powergating_by_smu(void *handle,
 				uint32_t block_type, bool gate)
 {
@@ -1201,6 +1209,7 @@ static int pp_set_powergating_by_smu(void *handle,
 		pp_dpm_powergate_mmhub(handle);
 		break;
 	case AMD_IP_BLOCK_TYPE_GFX:
+		ret = pp_dpm_powergate_gfx(handle, gate);
 		break;
 	default:
 		break;

commit b92c628712ed3a1cf5d4a144290e8ffc170bf51e
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jun 5 13:06:11 2018 +0800

    drm/amd/pp: Unify powergate_uvd/vce/mmhub to set_powergating_by_smu
    
    Some HW ip blocks need call SMU to enter/leave power gate state.
    So export common set_powergating_by_smu interface.
    
    1. keep consistent with set_clockgating_by_smu
    2. scales easily to powergate other ip(gfx) if necessary
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b69da116b30c..f68551ffb1e2 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -244,6 +244,7 @@ static int pp_set_powergating_state(void *handle,
 	/* Enable/disable GFX per cu powergating through SMU */
 	return hwmgr->hwmgr_func->powergate_gfx(hwmgr,
 			state == AMD_PG_STATE_GATE);
+
 }
 
 static int pp_suspend(void *handle)
@@ -1183,14 +1184,36 @@ static int pp_dpm_powergate_mmhub(void *handle)
 	return hwmgr->hwmgr_func->powergate_mmhub(hwmgr);
 }
 
+static int pp_set_powergating_by_smu(void *handle,
+				uint32_t block_type, bool gate)
+{
+	int ret = 0;
+
+	switch (block_type) {
+	case AMD_IP_BLOCK_TYPE_UVD:
+	case AMD_IP_BLOCK_TYPE_VCN:
+		pp_dpm_powergate_uvd(handle, gate);
+		break;
+	case AMD_IP_BLOCK_TYPE_VCE:
+		pp_dpm_powergate_vce(handle, gate);
+		break;
+	case AMD_IP_BLOCK_TYPE_GMC:
+		pp_dpm_powergate_mmhub(handle);
+		break;
+	case AMD_IP_BLOCK_TYPE_GFX:
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
 static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
 	.force_performance_level = pp_dpm_force_performance_level,
 	.get_performance_level = pp_dpm_get_performance_level,
 	.get_current_power_state = pp_dpm_get_current_power_state,
-	.powergate_vce = pp_dpm_powergate_vce,
-	.powergate_uvd = pp_dpm_powergate_uvd,
 	.dispatch_tasks = pp_dpm_dispatch_tasks,
 	.set_fan_control_mode = pp_dpm_set_fan_control_mode,
 	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
@@ -1210,6 +1233,7 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
 	.switch_power_profile = pp_dpm_switch_power_profile,
 	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
+	.set_powergating_by_smu = pp_set_powergating_by_smu,
 	.get_power_profile_mode = pp_get_power_profile_mode,
 	.set_power_profile_mode = pp_set_power_profile_mode,
 	.odn_edit_dpm_table = pp_odn_edit_dpm_table,
@@ -1227,5 +1251,4 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_watermarks_for_clocks_ranges = pp_set_watermarks_for_clocks_ranges,
 	.display_clock_voltage_request = pp_display_clock_voltage_request,
 	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
-	.powergate_mmhub = pp_dpm_powergate_mmhub,
 };

commit 3eb6e4795de3171d5c59f9368f48bb770087de77
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jun 5 11:28:03 2018 +0800

    drm/amd/pp: Rename enable_per_cu_power_gating to powergate_gfx
    
    keep consistent with powergate_uvd/vce/mmhub
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index da98208cd130..b69da116b30c 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -236,13 +236,13 @@ static int pp_set_powergating_state(void *handle,
 			pr_err("gfx off control failed!\n");
 	}
 
-	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
-		pr_debug("%s was not implemented.\n", __func__);
+	if (hwmgr->hwmgr_func->powergate_gfx == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
 	/* Enable/disable GFX per cu powergating through SMU */
-	return hwmgr->hwmgr_func->enable_per_cu_power_gating(hwmgr,
+	return hwmgr->hwmgr_func->powergate_gfx(hwmgr,
 			state == AMD_PG_STATE_GATE);
 }
 

commit a8da8ff3332b1f92588d22a8a643965409d1892d
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jun 5 10:07:53 2018 +0800

    drm/amdgpu: Rename set_mmhub_powergating_by_smu to powergate_mmhub
    
    In order to keep consistent with powergate_uvd/vce.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index d567be49c31b..da98208cd130 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1168,19 +1168,19 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 	return ret;
 }
 
-static int pp_set_mmhub_powergating_by_smu(void *handle)
+static int pp_dpm_powergate_mmhub(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
-	if (hwmgr->hwmgr_func->set_mmhub_powergating_by_smu == NULL) {
+	if (hwmgr->hwmgr_func->powergate_mmhub == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
-	return hwmgr->hwmgr_func->set_mmhub_powergating_by_smu(hwmgr);
+	return hwmgr->hwmgr_func->powergate_mmhub(hwmgr);
 }
 
 static const struct amd_pm_funcs pp_dpm_funcs = {
@@ -1227,5 +1227,5 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_watermarks_for_clocks_ranges = pp_set_watermarks_for_clocks_ranges,
 	.display_clock_voltage_request = pp_display_clock_voltage_request,
 	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
-	.set_mmhub_powergating_by_smu = pp_set_mmhub_powergating_by_smu,
+	.powergate_mmhub = pp_dpm_powergate_mmhub,
 };

commit 333c8d3ef238f21516659b5221532060bae8a128
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jun 12 17:01:23 2018 +0800

    drm/amd/powerplay: remove uncessary extra gfxoff control call
    
    Gfxoff is already enabled in amdgpu_device_ip_set_powergating_state.
    So, no need to enable it again in pp_late_init.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 0969b65003ed..d567be49c31b 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -180,7 +180,6 @@ static int pp_late_init(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret;
 
 	if (hwmgr && hwmgr->pm_en) {
 		mutex_lock(&hwmgr->smu_lock);
@@ -191,14 +190,6 @@ static int pp_late_init(void *handle)
 	if (adev->pm.smu_prv_buffer_size != 0)
 		pp_reserve_vram_for_smu(adev);
 
-	if (hwmgr && hwmgr->hwmgr_func &&
-	    hwmgr->hwmgr_func->gfx_off_control &&
-	    (hwmgr->feature_mask & PP_GFXOFF_MASK)) {
-		ret = hwmgr->hwmgr_func->gfx_off_control(hwmgr, true);
-		if (ret)
-			pr_err("gfx off enabling failed!\n");
-	}
-
 	return 0;
 }
 

commit 7584498c1c67bba4d1f5a0f7bf48c9a50c3ff5c8
Author: Huang Rui <ray.huang@amd.com>
Date:   Fri May 18 10:39:16 2018 +0800

    drm/amd/powerplay: fix missed hwmgr check warning before call gfx_off_control handler
    
    Patch 9667849bbb8d: "drm/amd/powerplay: add control gfxoff enabling in late
    init" from Mar 13, 2018, leads to the following static checker warning:
    
            drivers/gpu/drm/amd/amdgpu/../powerplay/amd_powerplay.c:194
    pp_late_init()
            error: we previously assumed 'hwmgr' could be null (see line 185)
    
    drivers/gpu/drm/amd/amdgpu/../powerplay/amd_powerplay.c
    
    This patch fixes the warning to add hwmgr checking.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index d0e6e2dd6bc6..0969b65003ed 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -191,7 +191,8 @@ static int pp_late_init(void *handle)
 	if (adev->pm.smu_prv_buffer_size != 0)
 		pp_reserve_vram_for_smu(adev);
 
-	if (hwmgr->hwmgr_func->gfx_off_control &&
+	if (hwmgr && hwmgr->hwmgr_func &&
+	    hwmgr->hwmgr_func->gfx_off_control &&
 	    (hwmgr->feature_mask & PP_GFXOFF_MASK)) {
 		ret = hwmgr->hwmgr_func->gfx_off_control(hwmgr, true);
 		if (ret)

commit 06b18f61ee78f8c69417c3a5e4f21ed678662315
Author: Huang Rui <ray.huang@amd.com>
Date:   Fri Jun 1 14:41:04 2018 +0800

    drm/amdgpu: fix CG enabling hang with gfxoff enabled
    
    After defer the execution of clockgating enabling, at that time, gfx already
    enter into "off" state. Howerver, clockgating enabling will use MMIO to access
    the gfx registers, then get the gfx hung.
    
    So here we should move the gfx powergating and gfxoff enabling behavior at the
    end of initialization behind clockgating.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Cc: Felix Kuehling <Felix.Kuehling@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b493369e6d0f..d0e6e2dd6bc6 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -245,7 +245,7 @@ static int pp_set_powergating_state(void *handle,
 	}
 
 	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+		pr_debug("%s was not implemented.\n", __func__);
 		return 0;
 	}
 

commit 9667849bbb8d8a2b97798ba0972fe25d13ea8acf
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Mar 13 18:32:39 2018 +0800

    drm/amd/powerplay: add control gfxoff enabling in late init
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 246f8e9e9451..b493369e6d0f 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -180,6 +180,7 @@ static int pp_late_init(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
+	int ret;
 
 	if (hwmgr && hwmgr->pm_en) {
 		mutex_lock(&hwmgr->smu_lock);
@@ -189,6 +190,14 @@ static int pp_late_init(void *handle)
 	}
 	if (adev->pm.smu_prv_buffer_size != 0)
 		pp_reserve_vram_for_smu(adev);
+
+	if (hwmgr->hwmgr_func->gfx_off_control &&
+	    (hwmgr->feature_mask & PP_GFXOFF_MASK)) {
+		ret = hwmgr->hwmgr_func->gfx_off_control(hwmgr, true);
+		if (ret)
+			pr_err("gfx off enabling failed!\n");
+	}
+
 	return 0;
 }
 

commit 00f54b97d7de97c41cffaad83d32a9bf03edad89
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Feb 27 21:53:00 2018 +0800

    drm/amdgpu: use pp_feature member to store the mask
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6976596449a8..246f8e9e9451 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -53,7 +53,7 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 	mutex_init(&hwmgr->smu_lock);
 	hwmgr->chip_family = adev->family;
 	hwmgr->chip_id = adev->asic_type;
-	hwmgr->feature_mask = amdgpu_pp_feature_mask;
+	hwmgr->feature_mask = adev->powerplay.pp_feature;
 	hwmgr->display_config = &adev->pm.pm_display_cfg;
 	adev->powerplay.pp_handle = hwmgr;
 	adev->powerplay.pp_funcs = &pp_dpm_funcs;

commit 775b0c11e27fce7d204d2911220fd7eebcc074d0
Author: Huang Rui <ray.huang@amd.com>
Date:   Fri Mar 2 15:18:54 2018 +0800

    drm/amd/powerplay: enable/disable gfxoff through smu
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index bd0d387584ac..6976596449a8 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -222,10 +222,19 @@ static int pp_set_powergating_state(void *handle,
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
+	int ret;
 
 	if (!hwmgr || !hwmgr->pm_en)
 		return 0;
 
+	if (hwmgr->hwmgr_func->gfx_off_control) {
+		/* Enable/disable GFX off through SMU */
+		ret = hwmgr->hwmgr_func->gfx_off_control(hwmgr,
+							 state == AMD_PG_STATE_GATE);
+		if (ret)
+			pr_err("gfx off control failed!\n");
+	}
+
 	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;

commit a0d454a67737162b0e4b1cc91612d7b25d5681b0
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Apr 13 16:16:49 2018 +0800

    drm/amd/pp: Remove dead interface
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6c8191444646..bd0d387584ac 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -934,35 +934,6 @@ static int pp_dpm_switch_power_profile(void *handle,
 	return 0;
 }
 
-static int pp_dpm_notify_smu_memory_info(void *handle,
-					uint32_t virtual_addr_low,
-					uint32_t virtual_addr_hi,
-					uint32_t mc_addr_low,
-					uint32_t mc_addr_hi,
-					uint32_t size)
-{
-	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	if (!hwmgr || !hwmgr->pm_en)
-		return -EINVAL;
-
-	if (hwmgr->hwmgr_func->notify_cac_buffer_info == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return -EINVAL;
-	}
-
-	mutex_lock(&hwmgr->smu_lock);
-
-	ret = hwmgr->hwmgr_func->notify_cac_buffer_info(hwmgr, virtual_addr_low,
-					virtual_addr_hi, mc_addr_low, mc_addr_hi,
-					size);
-
-	mutex_unlock(&hwmgr->smu_lock);
-
-	return ret;
-}
-
 static int pp_set_power_limit(void *handle, uint32_t limit)
 {
 	struct pp_hwmgr *hwmgr = handle;
@@ -1229,7 +1200,6 @@ static const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
 	.switch_power_profile = pp_dpm_switch_power_profile,
 	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
-	.notify_smu_memory_info = pp_dpm_notify_smu_memory_info,
 	.get_power_profile_mode = pp_get_power_profile_mode,
 	.set_power_profile_mode = pp_set_power_profile_mode,
 	.odn_edit_dpm_table = pp_odn_edit_dpm_table,

commit 7951e376704773134cefcf0751e9042368226f15
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Apr 13 16:13:41 2018 +0800

    drm/amdgpu: Reserved vram for smu to save debug info.
    
    v2: check reserved vram size before allocate.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 66c49b89cdb4..6c8191444646 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -145,6 +145,37 @@ static int pp_hw_fini(void *handle)
 	return 0;
 }
 
+static void pp_reserve_vram_for_smu(struct amdgpu_device *adev)
+{
+	int r = -EINVAL;
+	void *cpu_ptr = NULL;
+	uint64_t gpu_addr;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
+
+	if (amdgpu_bo_create_kernel(adev, adev->pm.smu_prv_buffer_size,
+						PAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,
+						&adev->pm.smu_prv_buffer,
+						&gpu_addr,
+						&cpu_ptr)) {
+		DRM_ERROR("amdgpu: failed to create smu prv buffer\n");
+		return;
+	}
+
+	if (hwmgr->hwmgr_func->notify_cac_buffer_info)
+		r = hwmgr->hwmgr_func->notify_cac_buffer_info(hwmgr,
+					lower_32_bits((unsigned long)cpu_ptr),
+					upper_32_bits((unsigned long)cpu_ptr),
+					lower_32_bits(gpu_addr),
+					upper_32_bits(gpu_addr),
+					adev->pm.smu_prv_buffer_size);
+
+	if (r) {
+		amdgpu_bo_free_kernel(&adev->pm.smu_prv_buffer, NULL, NULL);
+		adev->pm.smu_prv_buffer = NULL;
+		DRM_ERROR("amdgpu: failed to notify SMU buffer address\n");
+	}
+}
+
 static int pp_late_init(void *handle)
 {
 	struct amdgpu_device *adev = handle;
@@ -156,6 +187,8 @@ static int pp_late_init(void *handle)
 					AMD_PP_TASK_COMPLETE_INIT, NULL);
 		mutex_unlock(&hwmgr->smu_lock);
 	}
+	if (adev->pm.smu_prv_buffer_size != 0)
+		pp_reserve_vram_for_smu(adev);
 	return 0;
 }
 
@@ -163,6 +196,8 @@ static void pp_late_fini(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 
+	if (adev->pm.smu_prv_buffer)
+		amdgpu_bo_free_kernel(&adev->pm.smu_prv_buffer, NULL, NULL);
 	amd_powerplay_destroy(adev);
 }
 

commit 43fa561fd07fe707815d1b72472f6f5829223a52
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Mar 28 13:42:45 2018 -0500

    drm/amdgpu: remove duplicate cg/pg wrapper functions
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian König<christian.koenig@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 1ca6a13be6a3..66c49b89cdb4 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -288,10 +288,10 @@ static void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,
 		if (*level & profile_mode_mask) {
 			hwmgr->saved_dpm_level = hwmgr->dpm_level;
 			hwmgr->en_umd_pstate = true;
-			cgs_set_clockgating_state(hwmgr->device,
+			amdgpu_device_ip_set_clockgating_state(hwmgr->adev,
 						AMD_IP_BLOCK_TYPE_GFX,
 						AMD_CG_STATE_UNGATE);
-			cgs_set_powergating_state(hwmgr->device,
+			amdgpu_device_ip_set_powergating_state(hwmgr->adev,
 					AMD_IP_BLOCK_TYPE_GFX,
 					AMD_PG_STATE_UNGATE);
 		}
@@ -301,10 +301,10 @@ static void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,
 			if (*level == AMD_DPM_FORCED_LEVEL_PROFILE_EXIT)
 				*level = hwmgr->saved_dpm_level;
 			hwmgr->en_umd_pstate = false;
-			cgs_set_clockgating_state(hwmgr->device,
+			amdgpu_device_ip_set_clockgating_state(hwmgr->adev,
 					AMD_IP_BLOCK_TYPE_GFX,
 					AMD_CG_STATE_GATE);
-			cgs_set_powergating_state(hwmgr->device,
+			amdgpu_device_ip_set_powergating_state(hwmgr->adev,
 					AMD_IP_BLOCK_TYPE_GFX,
 					AMD_PG_STATE_GATE);
 		}

commit 555fd70c59bc7f7acd8bc429d92bd59a66a7b83b
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Mar 27 13:32:02 2018 +0800

    drm/amd/pp: Not call cgs interface to get display info
    
    DC/Non DC all will update display configuration
    when the display state changed
    No need to get display info through cgs interface
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b91ef113a490..1ca6a13be6a3 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -54,6 +54,7 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 	hwmgr->chip_family = adev->family;
 	hwmgr->chip_id = adev->asic_type;
 	hwmgr->feature_mask = amdgpu_pp_feature_mask;
+	hwmgr->display_config = &adev->pm.pm_display_cfg;
 	adev->powerplay.pp_handle = hwmgr;
 	adev->powerplay.pp_funcs = &pp_dpm_funcs;
 	return 0;

commit 64f6db77fcb81493988061587fa478e6612dc45b
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Mar 22 19:32:45 2018 +0800

    drm/amd/pp: Use release_firmware directly in powerplay
    
    Use kernel api directly so we can deprecate the cgs interface.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 337af789d258..b91ef113a490 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -25,6 +25,7 @@
 #include <linux/kernel.h>
 #include <linux/gfp.h>
 #include <linux/slab.h>
+#include <linux/firmware.h>
 #include "amd_shared.h"
 #include "amd_powerplay.h"
 #include "power_state.h"
@@ -107,8 +108,11 @@ static int pp_sw_fini(void *handle)
 
 	hwmgr_sw_fini(hwmgr);
 
-	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
+	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU) {
+		release_firmware(adev->pm.fw);
+		adev->pm.fw = NULL;
 		amdgpu_ucode_fini_bo(adev);
+	}
 
 	return 0;
 }

commit 8bb575a2d83af097980641d864401b303286755c
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Mar 22 15:46:47 2018 +0800

    drm/amd/pp: Save vf state in pp context
    
    Store vf state in pp_context so we can
    deprecate the cgs interface.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9ada102e253c..337af789d258 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -46,7 +46,8 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 		return -ENOMEM;
 
 	hwmgr->adev = adev;
-	hwmgr->pm_en = (amdgpu_dpm != 0 && !amdgpu_sriov_vf(adev)) ? true : false;
+	hwmgr->not_vf = !amdgpu_sriov_vf(adev);
+	hwmgr->pm_en = (amdgpu_dpm && hwmgr->not_vf) ? true : false;
 	hwmgr->device = amdgpu_cgs_create_device(adev);
 	mutex_init(&hwmgr->smu_lock);
 	hwmgr->chip_family = adev->family;

commit b61e54cb1881c7cb74787da6a5d39d8d48dcc075
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Mar 22 15:12:59 2018 +0800

    drm/amd/pp: Lock pm_funcs when set pp table
    
    unlock mutex until set pp table completely to avoid
    conflict if other pp functions were called simultaneously.
    
    use hwmgr_handle_task instand of pp_dpm_dispatch_tasks.
    It is not make sense that call pp_functions in ip_functions.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6503bbfdc76e..9ada102e253c 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -31,8 +31,6 @@
 #include "amdgpu.h"
 #include "hwmgr.h"
 
-static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
-		enum amd_pm_state_type *user_state);
 
 static const struct amd_pm_funcs pp_dpm_funcs;
 
@@ -146,10 +144,12 @@ static int pp_late_init(void *handle)
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
-	if (hwmgr && hwmgr->pm_en)
-		pp_dpm_dispatch_tasks(hwmgr,
+	if (hwmgr && hwmgr->pm_en) {
+		mutex_lock(&hwmgr->smu_lock);
+		hwmgr_handle_task(hwmgr,
 					AMD_PP_TASK_COMPLETE_INIT, NULL);
-
+		mutex_unlock(&hwmgr->smu_lock);
+	}
 	return 0;
 }
 
@@ -620,7 +620,7 @@ static int amd_powerplay_reset(void *handle)
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
+	int ret = -ENOMEM;
 
 	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
@@ -630,28 +630,28 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 		hwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,
 						   hwmgr->soft_pp_table_size,
 						   GFP_KERNEL);
-		if (!hwmgr->hardcode_pp_table) {
-			mutex_unlock(&hwmgr->smu_lock);
-			return -ENOMEM;
-		}
+		if (!hwmgr->hardcode_pp_table)
+			goto err;
 	}
 
 	memcpy(hwmgr->hardcode_pp_table, buf, size);
 
 	hwmgr->soft_pp_table = hwmgr->hardcode_pp_table;
-	mutex_unlock(&hwmgr->smu_lock);
 
 	ret = amd_powerplay_reset(handle);
 	if (ret)
-		return ret;
+		goto err;
 
 	if (hwmgr->hwmgr_func->avfs_control) {
 		ret = hwmgr->hwmgr_func->avfs_control(hwmgr, false);
 		if (ret)
-			return ret;
+			goto err;
 	}
-
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
+err:
+	mutex_unlock(&hwmgr->smu_lock);
+	return ret;
 }
 
 static int pp_dpm_force_clock_level(void *handle,

commit ba8ab90e6ac9322f39ab8368941b38b5bb12477c
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Mar 22 14:52:35 2018 +0800

    drm/amd/pp: Add hwmgr_sw_init/fini functioins
    
    Clean up pp ip functions
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7e8ad30d98e2..6503bbfdc76e 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -31,24 +31,11 @@
 #include "amdgpu.h"
 #include "hwmgr.h"
 
-#define PP_DPM_DISABLED 0xCCCC
-
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 		enum amd_pm_state_type *user_state);
 
 static const struct amd_pm_funcs pp_dpm_funcs;
 
-static inline int pp_check(struct pp_hwmgr *hwmgr)
-{
-	if (hwmgr == NULL || hwmgr->smumgr_funcs == NULL)
-		return -EINVAL;
-
-	if (hwmgr->pm_en == 0 || hwmgr->hwmgr_func == NULL)
-		return PP_DPM_DISABLED;
-
-	return 0;
-}
-
 static int amd_powerplay_create(struct amdgpu_device *adev)
 {
 	struct pp_hwmgr *hwmgr;
@@ -73,7 +60,7 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 }
 
 
-static int amd_powerplay_destroy(struct amdgpu_device *adev)
+static void amd_powerplay_destroy(struct amdgpu_device *adev)
 {
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
@@ -82,8 +69,6 @@ static int amd_powerplay_destroy(struct amdgpu_device *adev)
 
 	kfree(hwmgr);
 	hwmgr = NULL;
-
-	return 0;
 }
 
 static int pp_early_init(void *handle)
@@ -109,18 +94,9 @@ static int pp_sw_init(void *handle)
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret >= 0) {
-		if (hwmgr->smumgr_funcs->smu_init == NULL)
-			return -EINVAL;
+	ret = hwmgr_sw_init(hwmgr);
 
-		ret = hwmgr->smumgr_funcs->smu_init(hwmgr);
-
-		phm_register_irq_handlers(hwmgr);
-
-		pr_debug("amdgpu: powerplay sw initialized\n");
-	}
+	pr_debug("powerplay sw init %s\n", ret ? "failed" : "successfully");
 
 	return ret;
 }
@@ -129,13 +105,8 @@ static int pp_sw_fini(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret >= 0) {
-		if (hwmgr->smumgr_funcs->smu_fini != NULL)
-			hwmgr->smumgr_funcs->smu_fini(hwmgr);
-	}
+	hwmgr_sw_fini(hwmgr);
 
 	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
 		amdgpu_ucode_fini_bo(adev);
@@ -152,40 +123,20 @@ static int pp_hw_init(void *handle)
 	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
 		amdgpu_ucode_init_bo(adev);
 
-	ret = pp_check(hwmgr);
+	ret = hwmgr_hw_init(hwmgr);
 
-	if (ret >= 0) {
-		if (hwmgr->smumgr_funcs->start_smu == NULL)
-			return -EINVAL;
+	if (ret)
+		pr_err("powerplay hw init failed\n");
 
-		if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
-			pr_err("smc start failed\n");
-			hwmgr->smumgr_funcs->smu_fini(hwmgr);
-			return -EINVAL;
-		}
-		if (ret == PP_DPM_DISABLED)
-			goto exit;
-		ret = hwmgr_hw_init(hwmgr);
-		if (ret)
-			goto exit;
-	}
 	return ret;
-exit:
-	hwmgr->pm_en = 0;
-	cgs_notify_dpm_enabled(hwmgr->device, false);
-	return 0;
-
 }
 
 static int pp_hw_fini(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret == 0)
-		hwmgr_hw_fini(hwmgr);
+	hwmgr_hw_fini(hwmgr);
 
 	return 0;
 }
@@ -194,11 +145,8 @@ static int pp_late_init(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret == 0)
+	if (hwmgr && hwmgr->pm_en)
 		pp_dpm_dispatch_tasks(hwmgr,
 					AMD_PP_TASK_COMPLETE_INIT, NULL);
 
@@ -233,12 +181,9 @@ static int pp_set_powergating_state(void *handle,
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return 0;
 
 	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -254,38 +199,16 @@ static int pp_suspend(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret == 0)
-		hwmgr_hw_suspend(hwmgr);
-	return 0;
+	return hwmgr_suspend(hwmgr);
 }
 
 static int pp_resume(void *handle)
 {
 	struct amdgpu_device *adev = handle;
 	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
-	int ret;
-
-	ret = pp_check(hwmgr);
-
-	if (ret < 0)
-		return ret;
-
-	if (hwmgr->smumgr_funcs->start_smu == NULL)
-		return -EINVAL;
-
-	if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
-		pr_err("smc start failed\n");
-		hwmgr->smumgr_funcs->smu_fini(hwmgr);
-		return -EINVAL;
-	}
-
-	if (ret == PP_DPM_DISABLED)
-		return 0;
 
-	return hwmgr_hw_resume(hwmgr);
+	return hwmgr_resume(hwmgr);
 }
 
 static int pp_set_clockgating_state(void *handle,
@@ -334,12 +257,9 @@ static int pp_dpm_fw_loading_complete(void *handle)
 static int pp_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -389,12 +309,9 @@ static int pp_dpm_force_performance_level(void *handle,
 					enum amd_dpm_forced_level level)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (level == hwmgr->dpm_level)
 		return 0;
@@ -412,13 +329,10 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 								void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
 	enum amd_dpm_forced_level level;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
 	level = hwmgr->dpm_level;
@@ -429,13 +343,10 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
 	uint32_t clk = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return 0;
 
 	if (hwmgr->hwmgr_func->get_sclk == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -450,13 +361,10 @@ static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
 	uint32_t clk = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return 0;
 
 	if (hwmgr->hwmgr_func->get_mclk == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -471,11 +379,8 @@ static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 static void pp_dpm_powergate_vce(void *handle, bool gate)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
+	if (!hwmgr || !hwmgr->pm_en)
 		return;
 
 	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
@@ -490,11 +395,8 @@ static void pp_dpm_powergate_vce(void *handle, bool gate)
 static void pp_dpm_powergate_uvd(void *handle, bool gate)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
+	if (!hwmgr || !hwmgr->pm_en)
 		return;
 
 	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
@@ -512,10 +414,8 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 	int ret = 0;
 	struct pp_hwmgr *hwmgr = handle;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr_handle_task(hwmgr, task_id, user_state);
@@ -528,15 +428,9 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
 	struct pp_power_state *state;
-	int ret = 0;
 	enum amd_pm_state_type pm_type;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
-
-	if (hwmgr->current_ps == NULL)
+	if (!hwmgr || !hwmgr->pm_en || !hwmgr->current_ps)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -568,11 +462,8 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
+	if (!hwmgr || !hwmgr->pm_en)
 		return;
 
 	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
@@ -587,13 +478,10 @@ static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 static uint32_t pp_dpm_get_fan_control_mode(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
 	uint32_t mode = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return 0;
 
 	if (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -610,10 +498,8 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -630,10 +516,8 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -651,10 +535,8 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)
 		return -EINVAL;
@@ -670,16 +552,10 @@ static int pp_dpm_get_pp_num_states(void *handle,
 {
 	struct pp_hwmgr *hwmgr = handle;
 	int i;
-	int ret = 0;
 
 	memset(data, 0, sizeof(*data));
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
-
-	if (hwmgr->ps == NULL)
+	if (!hwmgr || !hwmgr->pm_en ||!hwmgr->ps)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -713,15 +589,9 @@ static int pp_dpm_get_pp_num_states(void *handle,
 static int pp_dpm_get_pp_table(void *handle, char **table)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
 	int size = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
-
-	if (!hwmgr->soft_pp_table)
+	if (!hwmgr || !hwmgr->pm_en ||!hwmgr->soft_pp_table)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -736,10 +606,6 @@ static int amd_powerplay_reset(void *handle)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret;
 
-	ret = pp_check(hwmgr);
-	if (ret)
-		return ret;
-
 	ret = hwmgr_hw_fini(hwmgr);
 	if (ret)
 		return ret;
@@ -756,10 +622,8 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
 	if (!hwmgr->hardcode_pp_table) {
@@ -796,10 +660,8 @@ static int pp_dpm_force_clock_level(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->force_clock_level == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -820,10 +682,8 @@ static int pp_dpm_print_clock_levels(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->print_clock_levels == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -840,10 +700,8 @@ static int pp_dpm_get_sclk_od(void *handle)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_sclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -860,10 +718,8 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_sclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -881,10 +737,8 @@ static int pp_dpm_get_mclk_od(void *handle)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_mclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -901,10 +755,8 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_mclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -922,11 +774,7 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret)
-		return ret;
-
-	if (value == NULL)
+	if (!hwmgr || !hwmgr->pm_en || !value)
 		return -EINVAL;
 
 	switch (idx) {
@@ -948,14 +796,11 @@ static struct amd_vce_state*
 pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
+	if (!hwmgr || !hwmgr->pm_en)
 		return NULL;
 
-	if (hwmgr && idx < hwmgr->num_vce_state_tables)
+	if (idx < hwmgr->num_vce_state_tables)
 		return &hwmgr->vce_states[idx];
 	return NULL;
 }
@@ -964,7 +809,7 @@ static int pp_get_power_profile_mode(void *handle, char *buf)
 {
 	struct pp_hwmgr *hwmgr = handle;
 
-	if (!buf || pp_check(hwmgr))
+	if (!hwmgr || !hwmgr->pm_en || !buf)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->get_power_profile_mode == NULL) {
@@ -980,12 +825,12 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = -EINVAL;
 
-	if (pp_check(hwmgr))
-		return -EINVAL;
+	if (!hwmgr || !hwmgr->pm_en)
+		return ret;
 
 	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
-		return -EINVAL;
+		return ret;
 	}
 	mutex_lock(&hwmgr->smu_lock);
 	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
@@ -998,7 +843,7 @@ static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint3
 {
 	struct pp_hwmgr *hwmgr = handle;
 
-	if (pp_check(hwmgr))
+	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->odn_edit_dpm_table == NULL) {
@@ -1016,7 +861,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 	long workload;
 	uint32_t index;
 
-	if (pp_check(hwmgr))
+	if (!hwmgr || !hwmgr->pm_en)
 		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
@@ -1058,10 +903,8 @@ static int pp_dpm_notify_smu_memory_info(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->notify_cac_buffer_info == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -1082,12 +925,9 @@ static int pp_dpm_notify_smu_memory_info(void *handle,
 static int pp_set_power_limit(void *handle, uint32_t limit)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_power_limit == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -1104,20 +944,14 @@ static int pp_set_power_limit(void *handle, uint32_t limit)
 	hwmgr->hwmgr_func->set_power_limit(hwmgr, limit);
 	hwmgr->power_limit = limit;
 	mutex_unlock(&hwmgr->smu_lock);
-	return ret;
+	return 0;
 }
 
 static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
-		return ret;
-
-	if (limit == NULL)
+	if (!hwmgr || !hwmgr->pm_en ||!limit)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1129,19 +963,16 @@ static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 
 	mutex_unlock(&hwmgr->smu_lock);
 
-	return ret;
+	return 0;
 }
 
 static int pp_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
 	phm_store_dal_configuration_data(hwmgr, display_config);
@@ -1155,12 +986,7 @@ static int pp_get_display_power_level(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
-
-	if (output == NULL)
+	if (!hwmgr || !hwmgr->pm_en ||!output)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1177,10 +1003,8 @@ static int pp_get_current_clocks(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
 
@@ -1225,10 +1049,8 @@ static int pp_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struc
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (clocks == NULL)
 		return -EINVAL;
@@ -1246,11 +1068,7 @@ static int pp_get_clock_by_type_with_latency(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret)
-		return ret;
-
-	if (!clocks)
+	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1266,11 +1084,7 @@ static int pp_get_clock_by_type_with_voltage(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret)
-		return ret;
-
-	if (!clocks)
+	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1287,11 +1101,7 @@ static int pp_set_watermarks_for_clocks_ranges(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret)
-		return ret;
-
-	if (!wm_with_clock_ranges)
+	if (!hwmgr || !hwmgr->pm_en ||!wm_with_clock_ranges)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1308,11 +1118,7 @@ static int pp_display_clock_voltage_request(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-	if (ret)
-		return ret;
-
-	if (!clock)
+	if (!hwmgr || !hwmgr->pm_en ||!clock)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1328,12 +1134,7 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(hwmgr);
-
-	if (ret)
-		return ret;
-
-	if (clocks == NULL)
+	if (!hwmgr || !hwmgr->pm_en ||!clocks)
 		return -EINVAL;
 
 	mutex_lock(&hwmgr->smu_lock);
@@ -1348,12 +1149,9 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 static int pp_set_mmhub_powergating_by_smu(void *handle)
 {
 	struct pp_hwmgr *hwmgr = handle;
-	int ret = 0;
-
-	ret = pp_check(hwmgr);
 
-	if (ret)
-		return ret;
+	if (!hwmgr || !hwmgr->pm_en)
+		return -EINVAL;
 
 	if (hwmgr->hwmgr_func->set_mmhub_powergating_by_smu == NULL) {
 		pr_info("%s was not implemented.\n", __func__);

commit 3296c4ae9769cab837799c0f873a1b281f4a156e
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Mar 21 13:10:11 2018 +0800

    drm/amd/pp: Add smu irq handlers in sw_init instand of hw_init
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 038131704d24..7e8ad30d98e2 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -117,6 +117,8 @@ static int pp_sw_init(void *handle)
 
 		ret = hwmgr->smumgr_funcs->smu_init(hwmgr);
 
+		phm_register_irq_handlers(hwmgr);
+
 		pr_debug("amdgpu: powerplay sw initialized\n");
 	}
 

commit 46b27ee9256dc752eb579125b0c79bb9d9574c94
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Mar 21 11:04:21 2018 +0800

    drm/amd/pp: Fix unable to handle kernel paging request
    when set pp table
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index dbb0e691bc89..038131704d24 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -738,7 +738,7 @@ static int amd_powerplay_reset(void *handle)
 	if (ret)
 		return ret;
 
-	ret = pp_hw_fini(hwmgr);
+	ret = hwmgr_hw_fini(hwmgr);
 	if (ret)
 		return ret;
 

commit f004938f789963a0d3023da6e528f53bfb9f4429
Author: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
Date:   Mon Mar 19 16:48:54 2018 -0400

    drm/amd/powerplay: Fix NULL pointer deref on driver unbind.
    
    Signed-off-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 3da3dccd13e2..dbb0e691bc89 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -286,6 +286,12 @@ static int pp_resume(void *handle)
 	return hwmgr_hw_resume(hwmgr);
 }
 
+static int pp_set_clockgating_state(void *handle,
+					  enum amd_clockgating_state state)
+{
+	return 0;
+}
+
 static const struct amd_ip_funcs pp_ip_funcs = {
 	.name = "powerplay",
 	.early_init = pp_early_init,
@@ -300,7 +306,7 @@ static const struct amd_ip_funcs pp_ip_funcs = {
 	.is_idle = pp_is_idle,
 	.wait_for_idle = pp_wait_for_idle,
 	.soft_reset = pp_sw_reset,
-	.set_clockgating_state = NULL,
+	.set_clockgating_state = pp_set_clockgating_state,
 	.set_powergating_state = pp_set_powergating_state,
 };
 

commit 2dac5936e50084e42354c50b3d9723f5f0a2eb63
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Mar 12 19:53:01 2018 +0800

    drm/amdgpu: Call amdgpu_ucode_fini_bo in amd_powerplay.c
    
    make it symmetric with amdgpu_ucode_init_bo in amd_powerplay.c
    
    refine the "commit b22558bb4ff8fc9fe925222f90297d7a03a5fb20"
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index a5bc52cdc40d..3da3dccd13e2 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -134,6 +134,10 @@ static int pp_sw_fini(void *handle)
 		if (hwmgr->smumgr_funcs->smu_fini != NULL)
 			hwmgr->smumgr_funcs->smu_fini(hwmgr);
 	}
+
+	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
+		amdgpu_ucode_fini_bo(adev);
+
 	return 0;
 }
 
@@ -201,7 +205,9 @@ static int pp_late_init(void *handle)
 
 static void pp_late_fini(void *handle)
 {
-	amd_powerplay_destroy(handle);
+	struct amdgpu_device *adev = handle;
+
+	amd_powerplay_destroy(adev);
 }
 
 

commit b905090d2bae2e6189511714a7b88691b439c5a1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Mar 12 19:52:23 2018 +0800

    drm/amdgpu: Remove wrapper layer of smu ip functions
    
    1. delete amdgpu_powerplay.c used for wrapping smu ip functions
    2. delete struct pp_instance,
    3. make struct hwmgr as the smu hw handle.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b989bf3542d6..a5bc52cdc40d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -27,7 +27,6 @@
 #include <linux/slab.h>
 #include "amd_shared.h"
 #include "amd_powerplay.h"
-#include "pp_instance.h"
 #include "power_state.h"
 #include "amdgpu.h"
 #include "hwmgr.h"
@@ -37,18 +36,14 @@
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 		enum amd_pm_state_type *user_state);
 
-static inline int pp_check(struct pp_instance *handle)
-{
-	if (handle == NULL)
-		return -EINVAL;
+static const struct amd_pm_funcs pp_dpm_funcs;
 
-	if (handle->hwmgr == NULL || handle->hwmgr->smumgr_funcs == NULL)
+static inline int pp_check(struct pp_hwmgr *hwmgr)
+{
+	if (hwmgr == NULL || hwmgr->smumgr_funcs == NULL)
 		return -EINVAL;
 
-	if (handle->pm_en == 0)
-		return PP_DPM_DISABLED;
-
-	if (handle->hwmgr->hwmgr_func == NULL)
+	if (hwmgr->pm_en == 0 || hwmgr->hwmgr_func == NULL)
 		return PP_DPM_DISABLED;
 
 	return 0;
@@ -56,54 +51,52 @@ static inline int pp_check(struct pp_instance *handle)
 
 static int amd_powerplay_create(struct amdgpu_device *adev)
 {
-	struct pp_instance *instance;
+	struct pp_hwmgr *hwmgr;
 
 	if (adev == NULL)
 		return -EINVAL;
 
-	instance = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
-	if (instance == NULL)
+	hwmgr = kzalloc(sizeof(struct pp_hwmgr), GFP_KERNEL);
+	if (hwmgr == NULL)
 		return -ENOMEM;
 
-	instance->parent = adev;
-	instance->pm_en = (amdgpu_dpm != 0 && !amdgpu_sriov_vf(adev)) ? true : false;
-	instance->device = adev->powerplay.cgs_device;
-	mutex_init(&instance->pp_lock);
-	adev->powerplay.pp_handle = instance;
-
+	hwmgr->adev = adev;
+	hwmgr->pm_en = (amdgpu_dpm != 0 && !amdgpu_sriov_vf(adev)) ? true : false;
+	hwmgr->device = amdgpu_cgs_create_device(adev);
+	mutex_init(&hwmgr->smu_lock);
+	hwmgr->chip_family = adev->family;
+	hwmgr->chip_id = adev->asic_type;
+	hwmgr->feature_mask = amdgpu_pp_feature_mask;
+	adev->powerplay.pp_handle = hwmgr;
+	adev->powerplay.pp_funcs = &pp_dpm_funcs;
 	return 0;
 }
 
 
-static int amd_powerplay_destroy(void *handle)
+static int amd_powerplay_destroy(struct amdgpu_device *adev)
 {
-	struct pp_instance *instance = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
-	kfree(instance->hwmgr->hardcode_pp_table);
-	instance->hwmgr->hardcode_pp_table = NULL;
+	kfree(hwmgr->hardcode_pp_table);
+	hwmgr->hardcode_pp_table = NULL;
 
-	kfree(instance->hwmgr);
-	instance->hwmgr = NULL;
+	kfree(hwmgr);
+	hwmgr = NULL;
 
-	kfree(instance);
-	instance = NULL;
 	return 0;
 }
 
 static int pp_early_init(void *handle)
 {
 	int ret;
-	struct pp_instance *pp_handle = NULL;
-	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct amdgpu_device *adev = handle;
 
 	ret = amd_powerplay_create(adev);
 
 	if (ret != 0)
 		return ret;
 
-	pp_handle = adev->powerplay.pp_handle;
-
-	ret = hwmgr_early_init(pp_handle);
+	ret = hwmgr_early_init(adev->powerplay.pp_handle);
 	if (ret)
 		return -EINVAL;
 
@@ -112,15 +105,13 @@ static int pp_early_init(void *handle)
 
 static int pp_sw_init(void *handle)
 {
-	struct pp_hwmgr *hwmgr;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret >= 0) {
-		hwmgr = pp_handle->hwmgr;
-
 		if (hwmgr->smumgr_funcs->smu_init == NULL)
 			return -EINVAL;
 
@@ -128,55 +119,53 @@ static int pp_sw_init(void *handle)
 
 		pr_debug("amdgpu: powerplay sw initialized\n");
 	}
+
 	return ret;
 }
 
 static int pp_sw_fini(void *handle)
 {
-	struct pp_hwmgr *hwmgr;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret >= 0) {
-		hwmgr = pp_handle->hwmgr;
-
-		if (hwmgr->smumgr_funcs->smu_fini == NULL)
-			return -EINVAL;
-
-		ret = hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
+		if (hwmgr->smumgr_funcs->smu_fini != NULL)
+			hwmgr->smumgr_funcs->smu_fini(hwmgr);
 	}
-	return ret;
+	return 0;
 }
 
 static int pp_hw_init(void *handle)
 {
 	int ret = 0;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
-	struct pp_hwmgr *hwmgr;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 
-	ret = pp_check(pp_handle);
+	if (adev->firmware.load_type == AMDGPU_FW_LOAD_SMU)
+		amdgpu_ucode_init_bo(adev);
 
-	if (ret >= 0) {
-		hwmgr = pp_handle->hwmgr;
+	ret = pp_check(hwmgr);
 
+	if (ret >= 0) {
 		if (hwmgr->smumgr_funcs->start_smu == NULL)
 			return -EINVAL;
 
-		if(hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
+		if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
 			pr_err("smc start failed\n");
-			hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
+			hwmgr->smumgr_funcs->smu_fini(hwmgr);
 			return -EINVAL;
 		}
 		if (ret == PP_DPM_DISABLED)
 			goto exit;
-		ret = hwmgr_hw_init(pp_handle);
+		ret = hwmgr_hw_init(hwmgr);
 		if (ret)
 			goto exit;
 	}
 	return ret;
 exit:
-	pp_handle->pm_en = 0;
+	hwmgr->pm_en = 0;
 	cgs_notify_dpm_enabled(hwmgr->device, false);
 	return 0;
 
@@ -184,24 +173,27 @@ static int pp_hw_init(void *handle)
 
 static int pp_hw_fini(void *handle)
 {
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret == 0)
-		hwmgr_hw_fini(pp_handle);
+		hwmgr_hw_fini(hwmgr);
 
 	return 0;
 }
 
 static int pp_late_init(void *handle)
 {
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
+
 	if (ret == 0)
-		pp_dpm_dispatch_tasks(pp_handle,
+		pp_dpm_dispatch_tasks(hwmgr,
 					AMD_PP_TASK_COMPLETE_INIT, NULL);
 
 	return 0;
@@ -231,17 +223,15 @@ static int pp_sw_reset(void *handle)
 static int pp_set_powergating_state(void *handle,
 				    enum amd_powergating_state state)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
@@ -254,44 +244,43 @@ static int pp_set_powergating_state(void *handle,
 
 static int pp_suspend(void *handle)
 {
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret == 0)
-		hwmgr_hw_suspend(pp_handle);
+		hwmgr_hw_suspend(hwmgr);
 	return 0;
 }
 
 static int pp_resume(void *handle)
 {
-	struct pp_hwmgr  *hwmgr;
+	struct amdgpu_device *adev = handle;
+	struct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;
 	int ret;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret < 0)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->smumgr_funcs->start_smu == NULL)
 		return -EINVAL;
 
-	if (hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
+	if (hwmgr->smumgr_funcs->start_smu(hwmgr)) {
 		pr_err("smc start failed\n");
-		hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
+		hwmgr->smumgr_funcs->smu_fini(hwmgr);
 		return -EINVAL;
 	}
 
 	if (ret == PP_DPM_DISABLED)
 		return 0;
 
-	return hwmgr_hw_resume(pp_handle);
+	return hwmgr_hw_resume(hwmgr);
 }
 
-const struct amd_ip_funcs pp_ip_funcs = {
+static const struct amd_ip_funcs pp_ip_funcs = {
 	.name = "powerplay",
 	.early_init = pp_early_init,
 	.late_init = pp_late_init,
@@ -309,6 +298,15 @@ const struct amd_ip_funcs pp_ip_funcs = {
 	.set_powergating_state = pp_set_powergating_state,
 };
 
+const struct amdgpu_ip_block_version pp_smu_ip_block =
+{
+	.type = AMD_IP_BLOCK_TYPE_SMC,
+	.major = 1,
+	.minor = 0,
+	.rev = 0,
+	.funcs = &pp_ip_funcs,
+};
+
 static int pp_dpm_load_fw(void *handle)
 {
 	return 0;
@@ -321,17 +319,14 @@ static int pp_dpm_fw_loading_complete(void *handle)
 
 static int pp_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
@@ -379,25 +374,22 @@ static void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,
 static int pp_dpm_force_performance_level(void *handle,
 					enum amd_dpm_forced_level level)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (level == hwmgr->dpm_level)
 		return 0;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	pp_dpm_en_umd_pstate(hwmgr, &level);
 	hwmgr->request_dpm_level = level;
-	hwmgr_handle_task(pp_handle, AMD_PP_TASK_READJUST_POWER_STATE, NULL);
-	mutex_unlock(&pp_handle->pp_lock);
+	hwmgr_handle_task(hwmgr, AMD_PP_TASK_READJUST_POWER_STATE, NULL);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return 0;
 }
@@ -405,152 +397,135 @@ static int pp_dpm_force_performance_level(void *handle,
 static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 								void *handle)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 	enum amd_dpm_forced_level level;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	level = hwmgr->dpm_level;
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return level;
 }
 
 static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 	uint32_t clk = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_sclk == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	clk = hwmgr->hwmgr_func->get_sclk(hwmgr, low);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return clk;
 }
 
 static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 	uint32_t clk = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_mclk == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	clk = hwmgr->hwmgr_func->get_mclk(hwmgr, low);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return clk;
 }
 
 static void pp_dpm_powergate_vce(void *handle, bool gate)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 }
 
 static void pp_dpm_powergate_uvd(void *handle, bool gate)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 }
 
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 		enum amd_pm_state_type *user_state)
 {
 	int ret = 0;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr_handle_task(pp_handle, task_id, user_state);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
+	ret = hwmgr_handle_task(hwmgr, task_id, user_state);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
 
 static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 {
-	struct pp_hwmgr *hwmgr;
+	struct pp_hwmgr *hwmgr = handle;
 	struct pp_power_state *state;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
 	enum amd_pm_state_type pm_type;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->current_ps == NULL)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	state = hwmgr->current_ps;
 
@@ -571,147 +546,129 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 			pm_type = POWER_STATE_TYPE_DEFAULT;
 		break;
 	}
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return pm_type;
 }
 
 static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 }
 
 static uint32_t pp_dpm_get_fan_control_mode(void *handle)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 	uint32_t mode = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	mode = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return mode;
 }
 
 static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_get_pp_num_states(void *handle,
 		struct pp_states_info *data)
 {
-	struct pp_hwmgr *hwmgr;
+	struct pp_hwmgr *hwmgr = handle;
 	int i;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
 
 	memset(data, 0, sizeof(*data));
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->ps == NULL)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	data->nums = hwmgr->num_ps;
 
@@ -735,73 +692,68 @@ static int pp_dpm_get_pp_num_states(void *handle,
 				data->states[i] = POWER_STATE_TYPE_DEFAULT;
 		}
 	}
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
 static int pp_dpm_get_pp_table(void *handle, char **table)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 	int size = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (!hwmgr->soft_pp_table)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	*table = (char *)hwmgr->soft_pp_table;
 	size = hwmgr->soft_pp_table_size;
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return size;
 }
 
 static int amd_powerplay_reset(void *handle)
 {
-	struct pp_instance *instance = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret;
 
-	ret = pp_check(instance);
+	ret = pp_check(hwmgr);
 	if (ret)
 		return ret;
 
-	ret = pp_hw_fini(instance);
+	ret = pp_hw_fini(hwmgr);
 	if (ret)
 		return ret;
 
-	ret = hwmgr_hw_init(instance);
+	ret = hwmgr_hw_init(hwmgr);
 	if (ret)
 		return ret;
 
-	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL);
+	return hwmgr_handle_task(hwmgr, AMD_PP_TASK_COMPLETE_INIT, NULL);
 }
 
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	if (!hwmgr->hardcode_pp_table) {
 		hwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,
 						   hwmgr->soft_pp_table_size,
 						   GFP_KERNEL);
 		if (!hwmgr->hardcode_pp_table) {
-			mutex_unlock(&pp_handle->pp_lock);
+			mutex_unlock(&hwmgr->smu_lock);
 			return -ENOMEM;
 		}
 	}
@@ -809,7 +761,7 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 	memcpy(hwmgr->hardcode_pp_table, buf, size);
 
 	hwmgr->soft_pp_table = hwmgr->hardcode_pp_table;
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	ret = amd_powerplay_reset(handle);
 	if (ret)
@@ -827,163 +779,142 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 static int pp_dpm_force_clock_level(void *handle,
 		enum pp_clock_type type, uint32_t mask)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->force_clock_level == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
 		ret = hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
 	else
 		ret = -EINVAL;
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_print_clock_levels(void *handle,
 		enum pp_clock_type type, char *buf)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->print_clock_levels == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_get_sclk_od(void *handle)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_sclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_sclk_od(hwmgr);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_sclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_get_mclk_od(void *handle)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_mclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->get_mclk_od(hwmgr);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_mclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_dpm_read_sensor(void *handle, int idx,
 			      void *value, int *size)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret)
 		return ret;
 
 	if (value == NULL)
 		return -EINVAL;
 
-	hwmgr = pp_handle->hwmgr;
-
 	switch (idx) {
 	case AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK:
 		*((uint32_t *)value) = hwmgr->pstate_sclk;
@@ -992,9 +923,9 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 		*((uint32_t *)value) = hwmgr->pstate_mclk;
 		return 0;
 	default:
-		mutex_lock(&pp_handle->pp_lock);
+		mutex_lock(&hwmgr->smu_lock);
 		ret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
-		mutex_unlock(&pp_handle->pp_lock);
+		mutex_unlock(&hwmgr->smu_lock);
 		return ret;
 	}
 }
@@ -1002,17 +933,14 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 static struct amd_vce_state*
 pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return NULL;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr && idx < hwmgr->num_vce_state_tables)
 		return &hwmgr->vce_states[idx];
 	return NULL;
@@ -1020,14 +948,11 @@ pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 
 static int pp_get_power_profile_mode(void *handle, char *buf)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 
-	if (!buf || pp_check(pp_handle))
+	if (!buf || pp_check(hwmgr))
 		return -EINVAL;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->get_power_profile_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return snprintf(buf, PAGE_SIZE, "\n");
@@ -1038,36 +963,30 @@ static int pp_get_power_profile_mode(void *handle, char *buf)
 
 static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = -EINVAL;
 
-	if (pp_check(pp_handle))
+	if (pp_check(hwmgr))
 		return -EINVAL;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return -EINVAL;
 	}
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
 		ret = hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint32_t size)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 
-	if (pp_check(pp_handle))
+	if (pp_check(hwmgr))
 		return -EINVAL;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->odn_edit_dpm_table == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return -EINVAL;
@@ -1079,16 +998,13 @@ static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint3
 static int pp_dpm_switch_power_profile(void *handle,
 		enum PP_SMC_POWER_PROFILE type, bool en)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	long workload;
 	uint32_t index;
 
-	if (pp_check(pp_handle))
+	if (pp_check(hwmgr))
 		return -EINVAL;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return -EINVAL;
@@ -1097,7 +1013,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 	if (!(type < PP_SMC_POWER_PROFILE_CUSTOM))
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	if (!en) {
 		hwmgr->workload_mask &= ~(1 << hwmgr->workload_prority[type]);
@@ -1113,7 +1029,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 
 	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
 		hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, &workload, 0);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return 0;
 }
@@ -1125,46 +1041,40 @@ static int pp_dpm_notify_smu_memory_info(void *handle,
 					uint32_t mc_addr_hi,
 					uint32_t size)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->notify_cac_buffer_info == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return -EINVAL;
 	}
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	ret = hwmgr->hwmgr_func->notify_cac_buffer_info(hwmgr, virtual_addr_low,
 					virtual_addr_hi, mc_addr_low, mc_addr_hi,
 					size);
 
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
 
 static int pp_set_power_limit(void *handle, uint32_t limit)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_power_limit == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return -EINVAL;
@@ -1176,20 +1086,19 @@ static int pp_set_power_limit(void *handle, uint32_t limit)
 	if (limit > hwmgr->default_power_limit)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	hwmgr->hwmgr_func->set_power_limit(hwmgr, limit);
 	hwmgr->power_limit = limit;
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
@@ -1197,16 +1106,14 @@ static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 	if (limit == NULL)
 		return -EINVAL;
 
-	hwmgr = pp_handle->hwmgr;
-
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	if (default_limit)
 		*limit = hwmgr->default_power_limit;
 	else
 		*limit = hwmgr->power_limit;
 
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
@@ -1214,42 +1121,37 @@ static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
 static int pp_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	phm_store_dal_configuration_data(hwmgr, display_config);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
 static int pp_get_display_power_level(void *handle,
 		struct amd_pp_simple_clock_info *output)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (output == NULL)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_get_dal_power_level(hwmgr, output);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1258,18 +1160,15 @@ static int pp_get_current_clocks(void *handle,
 {
 	struct amd_pp_simple_clock_info simple_clocks;
 	struct pp_clock_info hw_clocks;
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	phm_get_dal_power_level(hwmgr, &simple_clocks);
 
@@ -1283,7 +1182,7 @@ static int pp_get_current_clocks(void *handle,
 
 	if (ret) {
 		pr_info("Error in phm_get_clock_info \n");
-		mutex_unlock(&pp_handle->pp_lock);
+		mutex_unlock(&hwmgr->smu_lock);
 		return -EINVAL;
 	}
 
@@ -1303,29 +1202,26 @@ static int pp_get_current_clocks(void *handle,
 		clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
 		clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
 	}
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return 0;
 }
 
 static int pp_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (clocks == NULL)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_get_clock_by_type(hwmgr, type, clocks);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1333,21 +1229,19 @@ static int pp_get_clock_by_type_with_latency(void *handle,
 		enum amd_pp_clock_type type,
 		struct pp_clock_levels_with_latency *clocks)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret)
 		return ret;
 
 	if (!clocks)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_get_clock_by_type_with_latency(hwmgr, type, clocks);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
@@ -1355,47 +1249,41 @@ static int pp_get_clock_by_type_with_voltage(void *handle,
 		enum amd_pp_clock_type type,
 		struct pp_clock_levels_with_voltage *clocks)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret)
 		return ret;
 
 	if (!clocks)
 		return -EINVAL;
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
-
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	ret = phm_get_clock_by_type_with_voltage(hwmgr, type, clocks);
 
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_set_watermarks_for_clocks_ranges(void *handle,
 		struct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret)
 		return ret;
 
 	if (!wm_with_clock_ranges)
 		return -EINVAL;
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
-
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_set_watermarks_for_clocks_ranges(hwmgr,
 			wm_with_clock_ranges);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
@@ -1403,22 +1291,19 @@ static int pp_set_watermarks_for_clocks_ranges(void *handle,
 static int pp_display_clock_voltage_request(void *handle,
 		struct pp_display_clock_request *clock)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 	if (ret)
 		return ret;
 
 	if (!clock)
 		return -EINVAL;
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
-
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 	ret = phm_display_clock_voltage_request(hwmgr, clock);
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 
 	return ret;
 }
@@ -1426,42 +1311,36 @@ static int pp_display_clock_voltage_request(void *handle,
 static int pp_get_display_mode_validation_clocks(void *handle,
 		struct amd_pp_simple_clock_info *clocks)
 {
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (clocks == NULL)
 		return -EINVAL;
 
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_lock(&hwmgr->smu_lock);
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))
 		ret = phm_get_max_high_clocks(hwmgr, clocks);
 
-	mutex_unlock(&pp_handle->pp_lock);
+	mutex_unlock(&hwmgr->smu_lock);
 	return ret;
 }
 
 static int pp_set_mmhub_powergating_by_smu(void *handle)
 {
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr = handle;
 	int ret = 0;
 
-	ret = pp_check(pp_handle);
+	ret = pp_check(hwmgr);
 
 	if (ret)
 		return ret;
 
-	hwmgr = pp_handle->hwmgr;
-
 	if (hwmgr->hwmgr_func->set_mmhub_powergating_by_smu == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
@@ -1470,7 +1349,7 @@ static int pp_set_mmhub_powergating_by_smu(void *handle)
 	return hwmgr->hwmgr_func->set_mmhub_powergating_by_smu(hwmgr);
 }
 
-const struct amd_pm_funcs pp_dpm_funcs = {
+static const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
 	.force_performance_level = pp_dpm_force_performance_level,

commit 052fe96d93f2eb93cdb660ad7918aa0534c59c2e
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Mar 2 20:09:11 2018 +0800

    drm/amd/pp: Add auto power profilng switch based on workloads (v2)
    
    Add power profiling mode dynamic switch based on the workloads.
    Currently, support Cumpute, VR, Video, 3D,power saving with Cumpute
    have highest prority, power saving have lowest prority.
    
    in manual dpm mode, driver will stop auto switch, just save the client's
    requests. user can set power profiling mode through sysfs.
    
    when exit manual dpm mode, driver will response the client's requests.
    switch based on the client's prority.
    
    v2: squash in fixes from Rex
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index a8705b5ad264..b989bf3542d6 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1077,22 +1077,44 @@ static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint3
 }
 
 static int pp_dpm_switch_power_profile(void *handle,
-		enum amd_pp_profile_type type)
+		enum PP_SMC_POWER_PROFILE type, bool en)
 {
 	struct pp_hwmgr *hwmgr;
-	struct amd_pp_profile request = {0};
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	long workload;
+	uint32_t index;
 
 	if (pp_check(pp_handle))
 		return -EINVAL;
 
 	hwmgr = pp_handle->hwmgr;
 
-	if (hwmgr->current_power_profile != type) {
-		request.type = type;
-		pp_dpm_set_power_profile_state(handle, &request);
+	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!(type < PP_SMC_POWER_PROFILE_CUSTOM))
+		return -EINVAL;
+
+	mutex_lock(&pp_handle->pp_lock);
+
+	if (!en) {
+		hwmgr->workload_mask &= ~(1 << hwmgr->workload_prority[type]);
+		index = fls(hwmgr->workload_mask);
+		index = index > 0 && index <= Workload_Policy_Max ? index - 1 : 0;
+		workload = hwmgr->workload_setting[index];
+	} else {
+		hwmgr->workload_mask |= (1 << hwmgr->workload_prority[type]);
+		index = fls(hwmgr->workload_mask);
+		index = index <= Workload_Policy_Max ? index - 1 : 0;
+		workload = hwmgr->workload_setting[index];
 	}
 
+	if (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
+		hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, &workload, 0);
+	mutex_unlock(&pp_handle->pp_lock);
+
 	return 0;
 }
 

commit a5278e511dce23349e71d681dfa7e8c600d19603
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sat Feb 24 19:53:41 2018 +0800

    drm/amd/pp: Revert gfx/compute profile switch sysfs
    
    The gfx/compute profiling mode switch is only for internally
    test. Not a complete solution and unexpectly upstream.
    so revert it.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 20ac0fc12483..a8705b5ad264 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1018,58 +1018,6 @@ pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 	return NULL;
 }
 
-static int pp_dpm_reset_power_profile_state(void *handle,
-		struct amd_pp_profile *request)
-{
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
-
-	if (!request || pp_check(pp_handle))
-		return -EINVAL;
-
-	hwmgr = pp_handle->hwmgr;
-
-	if (hwmgr->hwmgr_func->set_power_profile_state == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return 0;
-	}
-
-	if (request->type == AMD_PP_GFX_PROFILE) {
-		hwmgr->gfx_power_profile = hwmgr->default_gfx_power_profile;
-		return hwmgr->hwmgr_func->set_power_profile_state(hwmgr,
-				&hwmgr->gfx_power_profile);
-	} else if (request->type == AMD_PP_COMPUTE_PROFILE) {
-		hwmgr->compute_power_profile =
-				hwmgr->default_compute_power_profile;
-		return hwmgr->hwmgr_func->set_power_profile_state(hwmgr,
-				&hwmgr->compute_power_profile);
-	} else
-		return -EINVAL;
-}
-
-static int pp_dpm_get_power_profile_state(void *handle,
-		struct amd_pp_profile *query)
-{
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
-
-	if (!query || pp_check(pp_handle))
-		return -EINVAL;
-
-	hwmgr = pp_handle->hwmgr;
-
-	if (query->type == AMD_PP_GFX_PROFILE)
-		memcpy(query, &hwmgr->gfx_power_profile,
-				sizeof(struct amd_pp_profile));
-	else if (query->type == AMD_PP_COMPUTE_PROFILE)
-		memcpy(query, &hwmgr->compute_power_profile,
-				sizeof(struct amd_pp_profile));
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
 static int pp_get_power_profile_mode(void *handle, char *buf)
 {
 	struct pp_hwmgr *hwmgr;
@@ -1128,65 +1076,6 @@ static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint3
 	return hwmgr->hwmgr_func->odn_edit_dpm_table(hwmgr, type, input, size);
 }
 
-static int pp_dpm_set_power_profile_state(void *handle,
-		struct amd_pp_profile *request)
-{
-	struct pp_hwmgr *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
-	int ret = -1;
-
-	if (!request || pp_check(pp_handle))
-		return -EINVAL;
-
-	hwmgr = pp_handle->hwmgr;
-
-	if (hwmgr->hwmgr_func->set_power_profile_state == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return 0;
-	}
-
-	if (request->min_sclk ||
-		request->min_mclk ||
-		request->activity_threshold ||
-		request->up_hyst ||
-		request->down_hyst) {
-		if (request->type == AMD_PP_GFX_PROFILE)
-			memcpy(&hwmgr->gfx_power_profile, request,
-					sizeof(struct amd_pp_profile));
-		else if (request->type == AMD_PP_COMPUTE_PROFILE)
-			memcpy(&hwmgr->compute_power_profile, request,
-					sizeof(struct amd_pp_profile));
-		else
-			return -EINVAL;
-
-		if (request->type == hwmgr->current_power_profile)
-			ret = hwmgr->hwmgr_func->set_power_profile_state(
-					hwmgr,
-					request);
-	} else {
-		/* set power profile if it exists */
-		switch (request->type) {
-		case AMD_PP_GFX_PROFILE:
-			ret = hwmgr->hwmgr_func->set_power_profile_state(
-					hwmgr,
-					&hwmgr->gfx_power_profile);
-			break;
-		case AMD_PP_COMPUTE_PROFILE:
-			ret = hwmgr->hwmgr_func->set_power_profile_state(
-					hwmgr,
-					&hwmgr->compute_power_profile);
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	if (!ret)
-		hwmgr->current_power_profile = request->type;
-
-	return 0;
-}
-
 static int pp_dpm_switch_power_profile(void *handle,
 		enum amd_pp_profile_type type)
 {
@@ -1584,9 +1473,6 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_mclk_od = pp_dpm_set_mclk_od,
 	.read_sensor = pp_dpm_read_sensor,
 	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
-	.reset_power_profile_state = pp_dpm_reset_power_profile_state,
-	.get_power_profile_state = pp_dpm_get_power_profile_state,
-	.set_power_profile_state = pp_dpm_set_power_profile_state,
 	.switch_power_profile = pp_dpm_switch_power_profile,
 	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
 	.notify_smu_memory_info = pp_dpm_notify_smu_memory_info,

commit 65ad7cac3866f5fa80dcef3e5048a839046d6a46
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Feb 27 14:09:40 2018 +0800

    drm/amd/pp: Refine powerplay instance
    
    Include adev in powerplay instance.
    so can visit adev directly instand of through cgs interface.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 4e87cfc129b4..20ac0fc12483 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -30,6 +30,7 @@
 #include "pp_instance.h"
 #include "power_state.h"
 #include "amdgpu.h"
+#include "hwmgr.h"
 
 #define PP_DPM_DISABLED 0xCCCC
 
@@ -64,13 +65,10 @@ static int amd_powerplay_create(struct amdgpu_device *adev)
 	if (instance == NULL)
 		return -ENOMEM;
 
-	instance->chip_family = adev->family;
-	instance->chip_id = adev->asic_type;
+	instance->parent = adev;
 	instance->pm_en = (amdgpu_dpm != 0 && !amdgpu_sriov_vf(adev)) ? true : false;
-	instance->feature_mask = amdgpu_pp_feature_mask;
 	instance->device = adev->powerplay.cgs_device;
 	mutex_init(&instance->pp_lock);
-
 	adev->powerplay.pp_handle = instance;
 
 	return 0;

commit a2c120ce6b686c753968b7b1293c7bb878440b7f
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Feb 26 19:58:49 2018 +0800

    drm/amd/pp: Simplify the create of powerplay instance
    
    use adev as input parameter to create powerplay instance
    directly. delete cgs wrap layer for power play create.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 376ed2dd52c7..4e87cfc129b4 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -29,6 +29,7 @@
 #include "amd_powerplay.h"
 #include "pp_instance.h"
 #include "power_state.h"
+#include "amdgpu.h"
 
 #define PP_DPM_DISABLED 0xCCCC
 
@@ -52,28 +53,30 @@ static inline int pp_check(struct pp_instance *handle)
 	return 0;
 }
 
-static int amd_powerplay_create(struct amd_pp_init *pp_init,
-				void **handle)
+static int amd_powerplay_create(struct amdgpu_device *adev)
 {
 	struct pp_instance *instance;
 
-	if (pp_init == NULL || handle == NULL)
+	if (adev == NULL)
 		return -EINVAL;
 
 	instance = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
 	if (instance == NULL)
 		return -ENOMEM;
 
-	instance->chip_family = pp_init->chip_family;
-	instance->chip_id = pp_init->chip_id;
-	instance->pm_en = pp_init->pm_en;
-	instance->feature_mask = pp_init->feature_mask;
-	instance->device = pp_init->device;
+	instance->chip_family = adev->family;
+	instance->chip_id = adev->asic_type;
+	instance->pm_en = (amdgpu_dpm != 0 && !amdgpu_sriov_vf(adev)) ? true : false;
+	instance->feature_mask = amdgpu_pp_feature_mask;
+	instance->device = adev->powerplay.cgs_device;
 	mutex_init(&instance->pp_lock);
-	*handle = instance;
+
+	adev->powerplay.pp_handle = instance;
+
 	return 0;
 }
 
+
 static int amd_powerplay_destroy(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;
@@ -93,11 +96,14 @@ static int pp_early_init(void *handle)
 {
 	int ret;
 	struct pp_instance *pp_handle = NULL;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	pp_handle = cgs_register_pp_handle(handle, amd_powerplay_create);
+	ret = amd_powerplay_create(adev);
 
-	if (!pp_handle)
-		return -EINVAL;
+	if (ret != 0)
+		return ret;
+
+	pp_handle = adev->powerplay.pp_handle;
 
 	ret = hwmgr_early_init(pp_handle);
 	if (ret)

commit 6ab8555e04ecd2278fdca54c33a7ddac7d4ba5d2
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Jan 29 18:04:18 2018 +0800

    drm/amd/pp: Expose set/get_power_limit for DGPU
    
    User can change power limit between
    [0, 1] * max power limit.
    
    Set power limit to 0, restore to max power limit.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7c4b88aa7abb..376ed2dd52c7 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1237,6 +1237,65 @@ static int pp_dpm_notify_smu_memory_info(void *handle,
 	return ret;
 }
 
+static int pp_set_power_limit(void *handle, uint32_t limit)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+
+	if (ret)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->set_power_limit == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	if (limit == 0)
+		limit = hwmgr->default_power_limit;
+
+	if (limit > hwmgr->default_power_limit)
+		return -EINVAL;
+
+	mutex_lock(&pp_handle->pp_lock);
+	hwmgr->hwmgr_func->set_power_limit(hwmgr, limit);
+	hwmgr->power_limit = limit;
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
+}
+
+static int pp_get_power_limit(void *handle, uint32_t *limit, bool default_limit)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+
+	if (ret)
+		return ret;
+
+	if (limit == NULL)
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	mutex_lock(&pp_handle->pp_lock);
+
+	if (default_limit)
+		*limit = hwmgr->default_power_limit;
+	else
+		*limit = hwmgr->power_limit;
+
+	mutex_unlock(&pp_handle->pp_lock);
+
+	return ret;
+}
+
 static int pp_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {
@@ -1530,6 +1589,8 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_power_profile_mode = pp_get_power_profile_mode,
 	.set_power_profile_mode = pp_set_power_profile_mode,
 	.odn_edit_dpm_table = pp_odn_edit_dpm_table,
+	.set_power_limit = pp_set_power_limit,
+	.get_power_limit = pp_get_power_limit,
 /* export to DC */
 	.get_sclk = pp_dpm_get_sclk,
 	.get_mclk = pp_dpm_get_mclk,

commit 72d7619106075232816e87e27791934ae9b7c445
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Tue Feb 6 14:38:38 2018 -0500

    drm/amd/powerplay: add mmhub powergating by smu in powerplay
    
    new generic interface is added in powerplay.
    
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index c571f8eca2fa..7c4b88aa7abb 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1475,6 +1475,27 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 	return ret;
 }
 
+static int pp_set_mmhub_powergating_by_smu(void *handle)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+
+	if (ret)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->set_mmhub_powergating_by_smu == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->set_mmhub_powergating_by_smu(hwmgr);
+}
+
 const struct amd_pm_funcs pp_dpm_funcs = {
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
@@ -1521,4 +1542,5 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_watermarks_for_clocks_ranges = pp_set_watermarks_for_clocks_ranges,
 	.display_clock_voltage_request = pp_display_clock_voltage_request,
 	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
+	.set_mmhub_powergating_by_smu = pp_set_mmhub_powergating_by_smu,
 };

commit 337ecd6a98297493abe826203e553cad6bdfc309
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jan 30 12:55:54 2018 +0800

    drm/amd/pp: Enable pp_set_power_profile_mode under manual mode
    
    Only user enter manual performance mode, driver allow user
    configure the sclk/mclk dpm parameters through sysfs
    pp_power_profile_mode.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 27083bee55e3..c571f8eca2fa 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1088,6 +1088,7 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 {
 	struct pp_hwmgr *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = -EINVAL;
 
 	if (pp_check(pp_handle))
 		return -EINVAL;
@@ -1098,8 +1099,11 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 		pr_info("%s was not implemented.\n", __func__);
 		return -EINVAL;
 	}
-
-	return hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
+	mutex_lock(&pp_handle->pp_lock);
+	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
+		ret = hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint32_t size)

commit 948fd66c94e1206e9b62a5ab00934cb35d00b89a
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jan 30 12:48:12 2018 +0800

    drm/amd/pp: Refine pp_dpm_force_clock_level functions
    
    Only when user set manual performance mode, driver
    enable pp_dpm_force_clock_level.
    so check the mode in pp_dpm_force_clock_level,
    and delete the same logic in callback functions.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 87117b1e51dc..27083bee55e3 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -839,7 +839,10 @@ static int pp_dpm_force_clock_level(void *handle,
 		return 0;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
+	if (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)
+		ret = hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
+	else
+		ret = -EINVAL;
 	mutex_unlock(&pp_handle->pp_lock);
 	return ret;
 }

commit 122fe39da4b43e3891ff3ab82fe70e23e2e29c08
Author: Luis de Bethencourt <luisbg@kernel.org>
Date:   Wed Jan 17 18:50:20 2018 +0000

    drm: amd: Fix trailing semicolons
    
    The trailing semicolon is an empty statement that does no operation.
    Removing the two instances of them since they don't do anything.
    
    Signed-off-by: Luis de Bethencourt <luisbg@kernel.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 173382c98149..87117b1e51dc 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -162,7 +162,7 @@ static int pp_hw_init(void *handle)
 		if(hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
 			pr_err("smc start failed\n");
 			hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
-			return -EINVAL;;
+			return -EINVAL;
 		}
 		if (ret == PP_DPM_DISABLED)
 			goto exit;

commit 21a381f79e807052cbb8cb8f855caa6d13a5737b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jan 24 17:44:48 2018 -0500

    drm/amdgpu/pp: remove the get_temperature API
    
    This is also supported with the read_sensor API and there
    were no more users of the get_temperature API.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 854c43c94714..173382c98149 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -687,29 +687,6 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 	return ret;
 }
 
-static int pp_dpm_get_temperature(void *handle)
-{
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
-	int ret = 0;
-
-	ret = pp_check(pp_handle);
-
-	if (ret)
-		return ret;
-
-	hwmgr = pp_handle->hwmgr;
-
-	if (hwmgr->hwmgr_func->get_temperature == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return 0;
-	}
-	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->get_temperature(hwmgr);
-	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
-}
-
 static int pp_dpm_get_pp_num_states(void *handle,
 		struct pp_states_info *data)
 {
@@ -1492,7 +1469,6 @@ static int pp_get_display_mode_validation_clocks(void *handle,
 }
 
 const struct amd_pm_funcs pp_dpm_funcs = {
-	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
 	.force_performance_level = pp_dpm_force_performance_level,

commit e3933f26b657c341055443103bad331f4537b113
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jan 16 18:35:15 2018 +0800

    drm/amd/pp: Add edit/commit/show OD clock/voltage support in sysfs
    
    when cat pp_od_clk_voltage it show
    OD_SCLK:
    0:        300Mhz        800 mV
    1:        466Mhz        818 mV
    2:        751Mhz        824 mV
    3:       1019Mhz        987 mV
    4:       1074Mhz       1037 mV
    5:       1126Mhz       1087 mV
    6:       1169Mhz       1137 mV
    7:       1206Mhz       1150 mV
    OD_MCLK:
    0:        300Mhz        800 mV
    1:       1650Mhz       1000 mV
    
    echo "s/m level clock voltage" to change
    sclk/mclk's  clock and voltage
    
    echo "r" to restore default value.
    echo "c" to commit the user setting.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index d9cb424ff7e9..854c43c94714 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1122,6 +1122,24 @@ static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
 	return hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
 }
 
+static int pp_odn_edit_dpm_table(void *handle, uint32_t type, long *input, uint32_t size)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	if (pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->odn_edit_dpm_table == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	return hwmgr->hwmgr_func->odn_edit_dpm_table(hwmgr, type, input, size);
+}
+
 static int pp_dpm_set_power_profile_state(void *handle,
 		struct amd_pp_profile *request)
 {
@@ -1507,6 +1525,7 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.notify_smu_memory_info = pp_dpm_notify_smu_memory_info,
 	.get_power_profile_mode = pp_get_power_profile_mode,
 	.set_power_profile_mode = pp_set_power_profile_mode,
+	.odn_edit_dpm_table = pp_odn_edit_dpm_table,
 /* export to DC */
 	.get_sclk = pp_dpm_get_sclk,
 	.get_mclk = pp_dpm_get_mclk,

commit 5ed8d656d60fd19d14bed647793eff0913627fd7
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Jan 8 13:59:05 2018 +0800

    drm/amd/pp: Add stable Pstate clk display support in debugfs
    
    The additional output are: PSTATE_SCLK and PSTATE_MCLK value
    in MHz as:
    
    300 MHz (PSTATE_SCLK)
    300 MHz (PSTATE_MCLK)
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 5e2252127fe5..d9cb424ff7e9 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -992,22 +992,27 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-
 	if (ret)
 		return ret;
 
+	if (value == NULL)
+		return -EINVAL;
+
 	hwmgr = pp_handle->hwmgr;
 
-	if (hwmgr->hwmgr_func->read_sensor == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
+	switch (idx) {
+	case AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK:
+		*((uint32_t *)value) = hwmgr->pstate_sclk;
 		return 0;
+	case AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK:
+		*((uint32_t *)value) = hwmgr->pstate_mclk;
+		return 0;
+	default:
+		mutex_lock(&pp_handle->pp_lock);
+		ret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
+		mutex_unlock(&pp_handle->pp_lock);
+		return ret;
 	}
-
-	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
-	mutex_unlock(&pp_handle->pp_lock);
-
-	return ret;
 }
 
 static struct amd_vce_state*

commit 6390258a2f1390e19dece30bb5231e73ce8a7dd0
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Jan 10 18:48:06 2018 +0800

    drm/amd/pp: Add custom power profile mode support on Vega10
    
    v2: delete uncessary blank line.
        Add static const modifiers to an array
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8859b6754545..5e2252127fe5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1081,6 +1081,42 @@ static int pp_dpm_get_power_profile_state(void *handle,
 	return 0;
 }
 
+static int pp_get_power_profile_mode(void *handle, char *buf)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	if (!buf || pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->get_power_profile_mode == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return snprintf(buf, PAGE_SIZE, "\n");
+	}
+
+	return hwmgr->hwmgr_func->get_power_profile_mode(hwmgr, buf);
+}
+
+static int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	if (pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	return hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);
+}
+
 static int pp_dpm_set_power_profile_state(void *handle,
 		struct amd_pp_profile *request)
 {
@@ -1464,6 +1500,8 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.switch_power_profile = pp_dpm_switch_power_profile,
 	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
 	.notify_smu_memory_info = pp_dpm_notify_smu_memory_info,
+	.get_power_profile_mode = pp_get_power_profile_mode,
+	.set_power_profile_mode = pp_set_power_profile_mode,
 /* export to DC */
 	.get_sclk = pp_dpm_get_sclk,
 	.get_mclk = pp_dpm_get_mclk,

commit 39199b803bfe3376dc343088f25d7c7804f15b71
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Dec 29 14:46:13 2017 +0800

    drm/amd/powerplay: removed hwmgr_handle_task unused parameter and given a better name for
    other parameter
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 4c3223a4d62b..8859b6754545 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -33,7 +33,7 @@
 #define PP_DPM_DISABLED 0xCCCC
 
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
-		void *input, void *output);
+		enum amd_pm_state_type *user_state);
 
 static inline int pp_check(struct pp_instance *handle)
 {
@@ -198,7 +198,7 @@ static int pp_late_init(void *handle)
 	ret = pp_check(pp_handle);
 	if (ret == 0)
 		pp_dpm_dispatch_tasks(pp_handle,
-					AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
+					AMD_PP_TASK_COMPLETE_INIT, NULL);
 
 	return 0;
 }
@@ -392,7 +392,7 @@ static int pp_dpm_force_performance_level(void *handle,
 	mutex_lock(&pp_handle->pp_lock);
 	pp_dpm_en_umd_pstate(hwmgr, &level);
 	hwmgr->request_dpm_level = level;
-	hwmgr_handle_task(pp_handle, AMD_PP_TASK_READJUST_POWER_STATE, NULL, NULL);
+	hwmgr_handle_task(pp_handle, AMD_PP_TASK_READJUST_POWER_STATE, NULL);
 	mutex_unlock(&pp_handle->pp_lock);
 
 	return 0;
@@ -511,7 +511,7 @@ static void pp_dpm_powergate_uvd(void *handle, bool gate)
 }
 
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
-		void *input, void *output)
+		enum amd_pm_state_type *user_state)
 {
 	int ret = 0;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -522,7 +522,7 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 		return ret;
 
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr_handle_task(pp_handle, task_id, input, output);
+	ret = hwmgr_handle_task(pp_handle, task_id, user_state);
 	mutex_unlock(&pp_handle->pp_lock);
 
 	return ret;
@@ -799,7 +799,7 @@ static int amd_powerplay_reset(void *handle)
 	if (ret)
 		return ret;
 
-	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
+	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL);
 }
 
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)

commit 4dbda35ffaa3eb52ecf960b56220644158ddae12
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Dec 28 14:37:58 2017 +0800

    drm/amd/powerplay: set pp_num_states as 0 on error situation
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fa9d1615a2cc..4c3223a4d62b 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -718,6 +718,8 @@ static int pp_dpm_get_pp_num_states(void *handle,
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
 
+	memset(data, 0, sizeof(*data));
+
 	ret = pp_check(pp_handle);
 
 	if (ret)

commit 8621bbbbd3f4bdbdc17122a32becbbfbdf572100
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Dec 18 19:48:00 2017 +0800

    drm/amd/pp: delete repeated call of force_dpm_level
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9d3bdada79d5..fa9d1615a2cc 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -389,20 +389,12 @@ static int pp_dpm_force_performance_level(void *handle,
 	if (level == hwmgr->dpm_level)
 		return 0;
 
-	if (hwmgr->hwmgr_func->force_dpm_level == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return 0;
-	}
-
 	mutex_lock(&pp_handle->pp_lock);
 	pp_dpm_en_umd_pstate(hwmgr, &level);
 	hwmgr->request_dpm_level = level;
 	hwmgr_handle_task(pp_handle, AMD_PP_TASK_READJUST_POWER_STATE, NULL, NULL);
-	ret = hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
-	if (!ret)
-		hwmgr->dpm_level = hwmgr->request_dpm_level;
-
 	mutex_unlock(&pp_handle->pp_lock);
+
 	return 0;
 }
 

commit 95a3ff787a49c57e9ebe2abf7ad8362007b7dff6
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Oct 9 11:30:42 2017 +0800

    drm/amd/pp: delete an outdated comment in amd_powerplay.c
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index a698a278ef8d..9d3bdada79d5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1200,9 +1200,6 @@ static int pp_dpm_notify_smu_memory_info(void *handle,
 	return ret;
 }
 
-
-/* export this function to DAL */
-
 static int pp_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {

commit 4c7c8bbb1fb505fde6a2dfd872aa622a2c8a28dd
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Oct 9 12:22:21 2017 +0800

    drm/amd/pp: implement notify_smu_memory_info on Powerplay
    
    Used to set up smu power logging.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 3d3aa7d17bd9..a698a278ef8d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1166,6 +1166,41 @@ static int pp_dpm_switch_power_profile(void *handle,
 	return 0;
 }
 
+static int pp_dpm_notify_smu_memory_info(void *handle,
+					uint32_t virtual_addr_low,
+					uint32_t virtual_addr_hi,
+					uint32_t mc_addr_low,
+					uint32_t mc_addr_hi,
+					uint32_t size)
+{
+	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+
+	if (ret)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->notify_cac_buffer_info == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&pp_handle->pp_lock);
+
+	ret = hwmgr->hwmgr_func->notify_cac_buffer_info(hwmgr, virtual_addr_low,
+					virtual_addr_hi, mc_addr_low, mc_addr_hi,
+					size);
+
+	mutex_unlock(&pp_handle->pp_lock);
+
+	return ret;
+}
+
+
 /* export this function to DAL */
 
 static int pp_display_configuration_change(void *handle,
@@ -1437,6 +1472,7 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.set_power_profile_state = pp_dpm_set_power_profile_state,
 	.switch_power_profile = pp_dpm_switch_power_profile,
 	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
+	.notify_smu_memory_info = pp_dpm_notify_smu_memory_info,
 /* export to DC */
 	.get_sclk = pp_dpm_get_sclk,
 	.get_mclk = pp_dpm_get_mclk,

commit f685d714321daf660d9a9ecf9d4925c297223260
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Oct 25 23:55:23 2017 -0400

    drm/amd/powerplay: move functions to amd_pm_funcs table
    
    those functions are exported to DC
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 726425809eed..3d3aa7d17bd9 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -788,6 +788,26 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 	return size;
 }
 
+static int amd_powerplay_reset(void *handle)
+{
+	struct pp_instance *instance = (struct pp_instance *)handle;
+	int ret;
+
+	ret = pp_check(instance);
+	if (ret)
+		return ret;
+
+	ret = pp_hw_fini(instance);
+	if (ret)
+		return ret;
+
+	ret = hwmgr_hw_init(instance);
+	if (ret)
+		return ret;
+
+	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
+}
+
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 {
 	struct pp_hwmgr *hwmgr;
@@ -1146,64 +1166,9 @@ static int pp_dpm_switch_power_profile(void *handle,
 	return 0;
 }
 
-const struct amd_pm_funcs pp_dpm_funcs = {
-	.get_temperature = pp_dpm_get_temperature,
-	.load_firmware = pp_dpm_load_fw,
-	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
-	.force_performance_level = pp_dpm_force_performance_level,
-	.get_performance_level = pp_dpm_get_performance_level,
-	.get_current_power_state = pp_dpm_get_current_power_state,
-	.get_sclk = pp_dpm_get_sclk,
-	.get_mclk = pp_dpm_get_mclk,
-	.powergate_vce = pp_dpm_powergate_vce,
-	.powergate_uvd = pp_dpm_powergate_uvd,
-	.dispatch_tasks = pp_dpm_dispatch_tasks,
-	.set_fan_control_mode = pp_dpm_set_fan_control_mode,
-	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
-	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,
-	.get_fan_speed_percent = pp_dpm_get_fan_speed_percent,
-	.get_fan_speed_rpm = pp_dpm_get_fan_speed_rpm,
-	.get_pp_num_states = pp_dpm_get_pp_num_states,
-	.get_pp_table = pp_dpm_get_pp_table,
-	.set_pp_table = pp_dpm_set_pp_table,
-	.force_clock_level = pp_dpm_force_clock_level,
-	.print_clock_levels = pp_dpm_print_clock_levels,
-	.get_sclk_od = pp_dpm_get_sclk_od,
-	.set_sclk_od = pp_dpm_set_sclk_od,
-	.get_mclk_od = pp_dpm_get_mclk_od,
-	.set_mclk_od = pp_dpm_set_mclk_od,
-	.read_sensor = pp_dpm_read_sensor,
-	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
-	.reset_power_profile_state = pp_dpm_reset_power_profile_state,
-	.get_power_profile_state = pp_dpm_get_power_profile_state,
-	.set_power_profile_state = pp_dpm_set_power_profile_state,
-	.switch_power_profile = pp_dpm_switch_power_profile,
-	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
-};
-
-int amd_powerplay_reset(void *handle)
-{
-	struct pp_instance *instance = (struct pp_instance *)handle;
-	int ret;
-
-	ret = pp_check(instance);
-	if (ret)
-		return ret;
-
-	ret = pp_hw_fini(instance);
-	if (ret)
-		return ret;
-
-	ret = hwmgr_hw_init(instance);
-	if (ret)
-		return ret;
-
-	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
-}
-
 /* export this function to DAL */
 
-int amd_powerplay_display_configuration_change(void *handle,
+static int pp_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -1222,7 +1187,7 @@ int amd_powerplay_display_configuration_change(void *handle,
 	return 0;
 }
 
-int amd_powerplay_get_display_power_level(void *handle,
+static int pp_get_display_power_level(void *handle,
 		struct amd_pp_simple_clock_info *output)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -1245,7 +1210,7 @@ int amd_powerplay_get_display_power_level(void *handle,
 	return ret;
 }
 
-int amd_powerplay_get_current_clocks(void *handle,
+static int pp_get_current_clocks(void *handle,
 		struct amd_pp_clock_info *clocks)
 {
 	struct amd_pp_simple_clock_info simple_clocks;
@@ -1299,7 +1264,7 @@ int amd_powerplay_get_current_clocks(void *handle,
 	return 0;
 }
 
-int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
+static int pp_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -1321,7 +1286,7 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 	return ret;
 }
 
-int amd_powerplay_get_clock_by_type_with_latency(void *handle,
+static int pp_get_clock_by_type_with_latency(void *handle,
 		enum amd_pp_clock_type type,
 		struct pp_clock_levels_with_latency *clocks)
 {
@@ -1343,7 +1308,7 @@ int amd_powerplay_get_clock_by_type_with_latency(void *handle,
 	return ret;
 }
 
-int amd_powerplay_get_clock_by_type_with_voltage(void *handle,
+static int pp_get_clock_by_type_with_voltage(void *handle,
 		enum amd_pp_clock_type type,
 		struct pp_clock_levels_with_voltage *clocks)
 {
@@ -1368,7 +1333,7 @@ int amd_powerplay_get_clock_by_type_with_voltage(void *handle,
 	return ret;
 }
 
-int amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,
+static int pp_set_watermarks_for_clocks_ranges(void *handle,
 		struct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)
 {
 	struct pp_hwmgr *hwmgr;
@@ -1392,7 +1357,7 @@ int amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,
 	return ret;
 }
 
-int amd_powerplay_display_clock_voltage_request(void *handle,
+static int pp_display_clock_voltage_request(void *handle,
 		struct pp_display_clock_request *clock)
 {
 	struct pp_hwmgr *hwmgr;
@@ -1415,7 +1380,7 @@ int amd_powerplay_display_clock_voltage_request(void *handle,
 	return ret;
 }
 
-int amd_powerplay_get_display_mode_validation_clocks(void *handle,
+static int pp_get_display_mode_validation_clocks(void *handle,
 		struct amd_pp_simple_clock_info *clocks)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -1441,3 +1406,47 @@ int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 	return ret;
 }
 
+const struct amd_pm_funcs pp_dpm_funcs = {
+	.get_temperature = pp_dpm_get_temperature,
+	.load_firmware = pp_dpm_load_fw,
+	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
+	.force_performance_level = pp_dpm_force_performance_level,
+	.get_performance_level = pp_dpm_get_performance_level,
+	.get_current_power_state = pp_dpm_get_current_power_state,
+	.powergate_vce = pp_dpm_powergate_vce,
+	.powergate_uvd = pp_dpm_powergate_uvd,
+	.dispatch_tasks = pp_dpm_dispatch_tasks,
+	.set_fan_control_mode = pp_dpm_set_fan_control_mode,
+	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
+	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,
+	.get_fan_speed_percent = pp_dpm_get_fan_speed_percent,
+	.get_fan_speed_rpm = pp_dpm_get_fan_speed_rpm,
+	.get_pp_num_states = pp_dpm_get_pp_num_states,
+	.get_pp_table = pp_dpm_get_pp_table,
+	.set_pp_table = pp_dpm_set_pp_table,
+	.force_clock_level = pp_dpm_force_clock_level,
+	.print_clock_levels = pp_dpm_print_clock_levels,
+	.get_sclk_od = pp_dpm_get_sclk_od,
+	.set_sclk_od = pp_dpm_set_sclk_od,
+	.get_mclk_od = pp_dpm_get_mclk_od,
+	.set_mclk_od = pp_dpm_set_mclk_od,
+	.read_sensor = pp_dpm_read_sensor,
+	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
+	.reset_power_profile_state = pp_dpm_reset_power_profile_state,
+	.get_power_profile_state = pp_dpm_get_power_profile_state,
+	.set_power_profile_state = pp_dpm_set_power_profile_state,
+	.switch_power_profile = pp_dpm_switch_power_profile,
+	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
+/* export to DC */
+	.get_sclk = pp_dpm_get_sclk,
+	.get_mclk = pp_dpm_get_mclk,
+	.display_configuration_change = pp_display_configuration_change,
+	.get_display_power_level = pp_get_display_power_level,
+	.get_current_clocks = pp_get_current_clocks,
+	.get_clock_by_type = pp_get_clock_by_type,
+	.get_clock_by_type_with_latency = pp_get_clock_by_type_with_latency,
+	.get_clock_by_type_with_voltage = pp_get_clock_by_type_with_voltage,
+	.set_watermarks_for_clocks_ranges = pp_set_watermarks_for_clocks_ranges,
+	.display_clock_voltage_request = pp_display_clock_voltage_request,
+	.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,
+};

commit 9953b72f9c9cb7733334753788faab33ccc4dc0a
Author: pding <Pixel.Ding@amd.com>
Date:   Thu Oct 26 09:30:38 2017 +0800

    drm/amdgpu: change redundant init logs to debug level
    
    When this VF stays in exclusive mode for long, other VFs will be
    impacted.
    
    The redundant messages causes exclusive mode timeout when they're
    redirected. That is a normal use case for cloud service to redirect
    guest log to virtual serial port.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: pding <Pixel.Ding@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index c7e34128cbde..726425809eed 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -122,7 +122,7 @@ static int pp_sw_init(void *handle)
 
 		ret = hwmgr->smumgr_funcs->smu_init(hwmgr);
 
-		pr_info("amdgpu: powerplay sw initialized\n");
+		pr_debug("amdgpu: powerplay sw initialized\n");
 	}
 	return ret;
 }

commit 7b38a49d75fb5e90512e63038449222c2ef651ef
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Tue Oct 31 17:35:28 2017 -0400

    drm/amd/powerplay: fix memory leak of hardcoded pptable
    
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 0f8b6dc853a5..c7e34128cbde 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -78,6 +78,9 @@ static int amd_powerplay_destroy(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;
 
+	kfree(instance->hwmgr->hardcode_pp_table);
+	instance->hwmgr->hardcode_pp_table = NULL;
+
 	kfree(instance->hwmgr);
 	instance->hwmgr = NULL;
 

commit 7265d50ea20f0dfe7e6d077a2feb50369773c090
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Oct 24 12:44:18 2017 +0300

    drm/amd/powerplay: fix amd_powerplay_reset()
    
    We accidentally inverted an if statement and turned amd_powerplay_reset()
    into a no-op.
    
    Fixes: ae97988fc89e ("drm/amd/powerplay: tidy up ret checks in amd_powerplay.c (v3)")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 3c8ef4bfc205..0f8b6dc853a5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1184,7 +1184,7 @@ int amd_powerplay_reset(void *handle)
 	int ret;
 
 	ret = pp_check(instance);
-	if (!ret)
+	if (ret)
 		return ret;
 
 	ret = pp_hw_fini(instance);

commit e1827a307e96ec51a657a2b7e68a8ffc36ae2a43
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Sep 28 16:12:51 2017 +0800

    drm/amd/powerplay: delete flag PP_VALID
    
    don't need to check pp_valid, all pp
    export functions are moved to ip_funcs
    and pp_funcs. so just need to check the
    function point.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 71bb7d932c86..3c8ef4bfc205 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -37,7 +37,7 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 
 static inline int pp_check(struct pp_instance *handle)
 {
-	if (handle == NULL || handle->pp_valid != PP_VALID)
+	if (handle == NULL)
 		return -EINVAL;
 
 	if (handle->hwmgr == NULL || handle->hwmgr->smumgr_funcs == NULL)
@@ -64,7 +64,6 @@ static int amd_powerplay_create(struct amd_pp_init *pp_init,
 	if (instance == NULL)
 		return -ENOMEM;
 
-	instance->pp_valid = PP_VALID;
 	instance->chip_family = pp_init->chip_family;
 	instance->chip_id = pp_init->chip_id;
 	instance->pm_en = pp_init->pm_en;

commit 3811f8f00c5fef3754091b5c5254355bed1d9022
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Sep 26 13:39:38 2017 +0800

    drm/amd/powerplay: move set_clockgating_by_smu to pp func table
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6e0b35245555..71bb7d932c86 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -222,28 +222,6 @@ static int pp_sw_reset(void *handle)
 	return 0;
 }
 
-
-int amd_set_clockgating_by_smu(void *handle, uint32_t msg_id)
-{
-	struct pp_hwmgr  *hwmgr;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
-	int ret = 0;
-
-	ret = pp_check(pp_handle);
-
-	if (!ret)
-		return ret;
-
-	hwmgr = pp_handle->hwmgr;
-
-	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
-		pr_info("%s was not implemented.\n", __func__);
-		return 0;
-	}
-
-	return hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-}
-
 static int pp_set_powergating_state(void *handle,
 				    enum amd_powergating_state state)
 {
@@ -335,6 +313,27 @@ static int pp_dpm_fw_loading_complete(void *handle)
 	return 0;
 }
 
+static int pp_set_clockgating_by_smu(void *handle, uint32_t msg_id)
+{
+	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+
+	if (ret)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+}
+
 static void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,
 						enum amd_dpm_forced_level *level)
 {
@@ -1177,6 +1176,7 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_power_profile_state = pp_dpm_get_power_profile_state,
 	.set_power_profile_state = pp_dpm_set_power_profile_state,
 	.switch_power_profile = pp_dpm_switch_power_profile,
+	.set_clockgating_by_smu = pp_set_clockgating_by_smu,
 };
 
 int amd_powerplay_reset(void *handle)

commit ae97988fc89e6a26da0b4aaab23027318fe311b1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Sep 29 14:36:15 2017 +0800

    drm/amd/powerplay: tidy up ret checks in amd_powerplay.c (v3)
    
    v2: squash in regression fix (Rex)
    v3: Squash in regression fix (Rex)
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 38ae400c3a35..6e0b35245555 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -231,7 +231,7 @@ int amd_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (!ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -253,7 +253,7 @@ static int pp_set_powergating_state(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -380,7 +380,7 @@ static int pp_dpm_force_performance_level(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -415,7 +415,7 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -434,7 +434,7 @@ static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -458,7 +458,7 @@ static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -481,7 +481,7 @@ static void pp_dpm_powergate_vce(void *handle, bool gate)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return;
 
 	hwmgr = pp_handle->hwmgr;
@@ -503,7 +503,7 @@ static void pp_dpm_powergate_uvd(void *handle, bool gate)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return;
 
 	hwmgr = pp_handle->hwmgr;
@@ -525,7 +525,7 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	mutex_lock(&pp_handle->pp_lock);
@@ -545,7 +545,7 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -587,7 +587,7 @@ static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return;
 
 	hwmgr = pp_handle->hwmgr;
@@ -610,7 +610,7 @@ static uint32_t pp_dpm_get_fan_control_mode(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -633,7 +633,7 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -656,7 +656,7 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -680,7 +680,7 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -702,7 +702,7 @@ static int pp_dpm_get_temperature(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -727,7 +727,7 @@ static int pp_dpm_get_pp_num_states(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -772,7 +772,7 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -795,7 +795,7 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -837,7 +837,7 @@ static int pp_dpm_force_clock_level(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -861,7 +861,7 @@ static int pp_dpm_print_clock_levels(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -884,7 +884,7 @@ static int pp_dpm_get_sclk_od(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -907,7 +907,7 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -931,7 +931,7 @@ static int pp_dpm_get_mclk_od(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -954,7 +954,7 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -978,7 +978,7 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -1004,7 +1004,7 @@ pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return NULL;
 
 	hwmgr = pp_handle->hwmgr;
@@ -1185,7 +1185,7 @@ int amd_powerplay_reset(void *handle)
 	int ret;
 
 	ret = pp_check(instance);
-	if (ret != 0)
+	if (!ret)
 		return ret;
 
 	ret = pp_hw_fini(instance);
@@ -1210,7 +1210,7 @@ int amd_powerplay_display_configuration_change(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -1229,7 +1229,7 @@ int amd_powerplay_get_display_power_level(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -1254,7 +1254,7 @@ int amd_powerplay_get_current_clocks(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -1271,7 +1271,7 @@ int amd_powerplay_get_current_clocks(void *handle,
 		ret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,
 					&hw_clocks, PHM_PerformanceLevelDesignation_Activity);
 
-	if (ret != 0) {
+	if (ret) {
 		pr_info("Error in phm_get_clock_info \n");
 		mutex_unlock(&pp_handle->pp_lock);
 		return -EINVAL;
@@ -1305,7 +1305,7 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
@@ -1328,7 +1328,7 @@ int amd_powerplay_get_clock_by_type_with_latency(void *handle,
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	if (!clocks)
@@ -1350,7 +1350,7 @@ int amd_powerplay_get_clock_by_type_with_voltage(void *handle,
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	if (!clocks)
@@ -1374,7 +1374,7 @@ int amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	if (!wm_with_clock_ranges)
@@ -1398,7 +1398,7 @@ int amd_powerplay_display_clock_voltage_request(void *handle,
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	if (!clock)
@@ -1422,7 +1422,7 @@ int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;

commit e5f23736a88c1d8d727ac655fef5e752507eea8e
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Sep 29 13:57:54 2017 +0800

    drm/amd/powerplay: refine code in amd_powerplay.c (v2)
    
    1. use flag PP_DPM_DISABLED within powerplay
       notify amdgpu dpm state by cgs interface.
    2. delete redundant virtualization check in
       powerplay
    
    v2: squash in fix for hwmgr_init (Rex)
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 488347a11f01..38ae400c3a35 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -30,6 +30,8 @@
 #include "pp_instance.h"
 #include "power_state.h"
 
+#define PP_DPM_DISABLED 0xCCCC
+
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 		void *input, void *output);
 
@@ -99,10 +101,6 @@ static int pp_early_init(void *handle)
 	if (ret)
 		return -EINVAL;
 
-	if ((pp_handle->pm_en == 0)
-		|| cgs_is_virtualization_enabled(pp_handle->device))
-		return PP_DPM_DISABLED;
-
 	return 0;
 }
 
@@ -114,7 +112,7 @@ static int pp_sw_init(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret == 0 || ret == PP_DPM_DISABLED) {
+	if (ret >= 0) {
 		hwmgr = pp_handle->hwmgr;
 
 		if (hwmgr->smumgr_funcs->smu_init == NULL)
@@ -134,7 +132,7 @@ static int pp_sw_fini(void *handle)
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
 	ret = pp_check(pp_handle);
-	if (ret == 0 || ret == PP_DPM_DISABLED) {
+	if (ret >= 0) {
 		hwmgr = pp_handle->hwmgr;
 
 		if (hwmgr->smumgr_funcs->smu_fini == NULL)
@@ -153,7 +151,7 @@ static int pp_hw_init(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret == 0 || ret == PP_DPM_DISABLED) {
+	if (ret >= 0) {
 		hwmgr = pp_handle->hwmgr;
 
 		if (hwmgr->smumgr_funcs->start_smu == NULL)
@@ -165,16 +163,17 @@ static int pp_hw_init(void *handle)
 			return -EINVAL;;
 		}
 		if (ret == PP_DPM_DISABLED)
-			return PP_DPM_DISABLED;
+			goto exit;
+		ret = hwmgr_hw_init(pp_handle);
+		if (ret)
+			goto exit;
 	}
-
-	ret = hwmgr_hw_init(pp_handle);
-	if (ret)
-		goto err;
-	return 0;
-err:
+	return ret;
+exit:
 	pp_handle->pm_en = 0;
-	return PP_DPM_DISABLED;
+	cgs_notify_dpm_enabled(hwmgr->device, false);
+	return 0;
+
 }
 
 static int pp_hw_fini(void *handle)
@@ -275,39 +274,34 @@ static int pp_suspend(void *handle)
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-
-	if (ret == PP_DPM_DISABLED)
-		return 0;
-	else if (ret != 0)
-		return ret;
-
-	return hwmgr_hw_suspend(pp_handle);
+	if (ret == 0)
+		hwmgr_hw_suspend(pp_handle);
+	return 0;
 }
 
 static int pp_resume(void *handle)
 {
 	struct pp_hwmgr  *hwmgr;
-	int ret, ret1;
+	int ret;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	ret1 = pp_check(pp_handle);
+	ret = pp_check(pp_handle);
 
-	if (ret1 != 0 && ret1 != PP_DPM_DISABLED)
-		return ret1;
+	if (ret < 0)
+		return ret;
 
 	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->smumgr_funcs->start_smu == NULL)
 		return -EINVAL;
 
-	ret = hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr);
-	if (ret) {
+	if (hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
 		pr_err("smc start failed\n");
 		hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
-		return ret;
+		return -EINVAL;
 	}
 
-	if (ret1 == PP_DPM_DISABLED)
+	if (ret == PP_DPM_DISABLED)
 		return 0;
 
 	return hwmgr_hw_resume(pp_handle);
@@ -1190,9 +1184,6 @@ int amd_powerplay_reset(void *handle)
 	struct pp_instance *instance = (struct pp_instance *)handle;
 	int ret;
 
-	if (cgs_is_virtualization_enabled(instance->hwmgr->device))
-		return PP_DPM_DISABLED;
-
 	ret = pp_check(instance);
 	if (ret != 0)
 		return ret;
@@ -1203,7 +1194,7 @@ int amd_powerplay_reset(void *handle)
 
 	ret = hwmgr_hw_init(instance);
 	if (ret)
-		return PP_DPM_DISABLED;
+		return ret;
 
 	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
 }

commit 139a285f8124577ed816f63d9e950b01dfaa5401
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Sep 25 20:46:37 2017 +0800

    drm/amdgpu: create powerplay by cgs interface
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 5c7415e8fd0e..488347a11f01 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -50,10 +50,50 @@ static inline int pp_check(struct pp_instance *handle)
 	return 0;
 }
 
+static int amd_powerplay_create(struct amd_pp_init *pp_init,
+				void **handle)
+{
+	struct pp_instance *instance;
+
+	if (pp_init == NULL || handle == NULL)
+		return -EINVAL;
+
+	instance = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
+	if (instance == NULL)
+		return -ENOMEM;
+
+	instance->pp_valid = PP_VALID;
+	instance->chip_family = pp_init->chip_family;
+	instance->chip_id = pp_init->chip_id;
+	instance->pm_en = pp_init->pm_en;
+	instance->feature_mask = pp_init->feature_mask;
+	instance->device = pp_init->device;
+	mutex_init(&instance->pp_lock);
+	*handle = instance;
+	return 0;
+}
+
+static int amd_powerplay_destroy(void *handle)
+{
+	struct pp_instance *instance = (struct pp_instance *)handle;
+
+	kfree(instance->hwmgr);
+	instance->hwmgr = NULL;
+
+	kfree(instance);
+	instance = NULL;
+	return 0;
+}
+
 static int pp_early_init(void *handle)
 {
 	int ret;
-	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_instance *pp_handle = NULL;
+
+	pp_handle = cgs_register_pp_handle(handle, amd_powerplay_create);
+
+	if (!pp_handle)
+		return -EINVAL;
 
 	ret = hwmgr_early_init(pp_handle);
 	if (ret)
@@ -162,6 +202,12 @@ static int pp_late_init(void *handle)
 	return 0;
 }
 
+static void pp_late_fini(void *handle)
+{
+	amd_powerplay_destroy(handle);
+}
+
+
 static bool pp_is_idle(void *handle)
 {
 	return false;
@@ -275,6 +321,7 @@ const struct amd_ip_funcs pp_ip_funcs = {
 	.sw_fini = pp_sw_fini,
 	.hw_init = pp_hw_init,
 	.hw_fini = pp_hw_fini,
+	.late_fini = pp_late_fini,
 	.suspend = pp_suspend,
 	.resume = pp_resume,
 	.is_idle = pp_is_idle,
@@ -1138,41 +1185,6 @@ const struct amd_pm_funcs pp_dpm_funcs = {
 	.switch_power_profile = pp_dpm_switch_power_profile,
 };
 
-int amd_powerplay_create(struct amd_pp_init *pp_init,
-				void **handle)
-{
-	struct pp_instance *instance;
-
-	if (pp_init == NULL || handle == NULL)
-		return -EINVAL;
-
-	instance = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
-	if (instance == NULL)
-		return -ENOMEM;
-
-	instance->pp_valid = PP_VALID;
-	instance->chip_family = pp_init->chip_family;
-	instance->chip_id = pp_init->chip_id;
-	instance->pm_en = pp_init->pm_en;
-	instance->feature_mask = pp_init->feature_mask;
-	instance->device = pp_init->device;
-	mutex_init(&instance->pp_lock);
-	*handle = instance;
-	return 0;
-}
-
-int amd_powerplay_destroy(void *handle)
-{
-	struct pp_instance *instance = (struct pp_instance *)handle;
-
-	kfree(instance->hwmgr);
-	instance->hwmgr = NULL;
-
-	kfree(instance);
-	instance = NULL;
-	return 0;
-}
-
 int amd_powerplay_reset(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;

commit 6d07fe7bcae57ee73d87766b6cd1e026d3fee85d
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Sep 25 18:51:50 2017 +0800

    drm/amdgpu: delete pp_enable in adev
    
    amdgpu not care powerplay or dpm is enabled.
    just check ip functions and pp functions
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9f3f3b8cf64f..5c7415e8fd0e 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -30,6 +30,9 @@
 #include "pp_instance.h"
 #include "power_state.h"
 
+static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
+		void *input, void *output);
+
 static inline int pp_check(struct pp_instance *handle)
 {
 	if (handle == NULL || handle->pp_valid != PP_VALID)
@@ -146,6 +149,19 @@ static int pp_hw_fini(void *handle)
 	return 0;
 }
 
+static int pp_late_init(void *handle)
+{
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+	if (ret == 0)
+		pp_dpm_dispatch_tasks(pp_handle,
+					AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
+
+	return 0;
+}
+
 static bool pp_is_idle(void *handle)
 {
 	return false;
@@ -254,7 +270,7 @@ static int pp_resume(void *handle)
 const struct amd_ip_funcs pp_ip_funcs = {
 	.name = "powerplay",
 	.early_init = pp_early_init,
-	.late_init = NULL,
+	.late_init = pp_late_init,
 	.sw_init = pp_sw_init,
 	.sw_fini = pp_sw_fini,
 	.hw_init = pp_hw_init,

commit b3b030520df05fca7f2dcca455c9628f483a1f95
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Sep 26 13:28:27 2017 -0400

    drm/amd/powerplay: refine powerplay code.
    
    delete struct smumgr, put smu backend function table
    in struct hwmgr
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index c37ea9543ca3..9f3f3b8cf64f 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -35,13 +35,13 @@ static inline int pp_check(struct pp_instance *handle)
 	if (handle == NULL || handle->pp_valid != PP_VALID)
 		return -EINVAL;
 
-	if (handle->smu_mgr == NULL || handle->smu_mgr->smumgr_funcs == NULL)
+	if (handle->hwmgr == NULL || handle->hwmgr->smumgr_funcs == NULL)
 		return -EINVAL;
 
 	if (handle->pm_en == 0)
 		return PP_DPM_DISABLED;
 
-	if (handle->hwmgr == NULL || handle->hwmgr->hwmgr_func == NULL)
+	if (handle->hwmgr->hwmgr_func == NULL)
 		return PP_DPM_DISABLED;
 
 	return 0;
@@ -52,38 +52,32 @@ static int pp_early_init(void *handle)
 	int ret;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	ret = smum_early_init(pp_handle);
+	ret = hwmgr_early_init(pp_handle);
 	if (ret)
-		return ret;
+		return -EINVAL;
 
 	if ((pp_handle->pm_en == 0)
 		|| cgs_is_virtualization_enabled(pp_handle->device))
 		return PP_DPM_DISABLED;
 
-	ret = hwmgr_early_init(pp_handle);
-	if (ret) {
-		pp_handle->pm_en = 0;
-		return PP_DPM_DISABLED;
-	}
-
 	return 0;
 }
 
 static int pp_sw_init(void *handle)
 {
-	struct pp_smumgr *smumgr;
+	struct pp_hwmgr *hwmgr;
 	int ret = 0;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
 	ret = pp_check(pp_handle);
 
 	if (ret == 0 || ret == PP_DPM_DISABLED) {
-		smumgr = pp_handle->smu_mgr;
+		hwmgr = pp_handle->hwmgr;
 
-		if (smumgr->smumgr_funcs->smu_init == NULL)
+		if (hwmgr->smumgr_funcs->smu_init == NULL)
 			return -EINVAL;
 
-		ret = smumgr->smumgr_funcs->smu_init(pp_handle->hwmgr);
+		ret = hwmgr->smumgr_funcs->smu_init(hwmgr);
 
 		pr_info("amdgpu: powerplay sw initialized\n");
 	}
@@ -92,39 +86,39 @@ static int pp_sw_init(void *handle)
 
 static int pp_sw_fini(void *handle)
 {
-	struct pp_smumgr *smumgr;
+	struct pp_hwmgr *hwmgr;
 	int ret = 0;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
 	ret = pp_check(pp_handle);
 	if (ret == 0 || ret == PP_DPM_DISABLED) {
-		smumgr = pp_handle->smu_mgr;
+		hwmgr = pp_handle->hwmgr;
 
-		if (smumgr->smumgr_funcs->smu_fini == NULL)
+		if (hwmgr->smumgr_funcs->smu_fini == NULL)
 			return -EINVAL;
 
-		ret = smumgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
+		ret = hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
 	}
 	return ret;
 }
 
 static int pp_hw_init(void *handle)
 {
-	struct pp_smumgr *smumgr;
 	int ret = 0;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	struct pp_hwmgr *hwmgr;
 
 	ret = pp_check(pp_handle);
 
 	if (ret == 0 || ret == PP_DPM_DISABLED) {
-		smumgr = pp_handle->smu_mgr;
+		hwmgr = pp_handle->hwmgr;
 
-		if (smumgr->smumgr_funcs->start_smu == NULL)
+		if (hwmgr->smumgr_funcs->start_smu == NULL)
 			return -EINVAL;
 
-		if(smumgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
+		if(hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
 			pr_err("smc start failed\n");
-			smumgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
+			hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
 			return -EINVAL;;
 		}
 		if (ret == PP_DPM_DISABLED)
@@ -137,8 +131,6 @@ static int pp_hw_init(void *handle)
 	return 0;
 err:
 	pp_handle->pm_en = 0;
-	kfree(pp_handle->hwmgr);
-	pp_handle->hwmgr = NULL;
 	return PP_DPM_DISABLED;
 }
 
@@ -232,7 +224,7 @@ static int pp_suspend(void *handle)
 
 static int pp_resume(void *handle)
 {
-	struct pp_smumgr *smumgr;
+	struct pp_hwmgr  *hwmgr;
 	int ret, ret1;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
@@ -241,15 +233,15 @@ static int pp_resume(void *handle)
 	if (ret1 != 0 && ret1 != PP_DPM_DISABLED)
 		return ret1;
 
-	smumgr = pp_handle->smu_mgr;
+	hwmgr = pp_handle->hwmgr;
 
-	if (smumgr->smumgr_funcs->start_smu == NULL)
+	if (hwmgr->smumgr_funcs->start_smu == NULL)
 		return -EINVAL;
 
-	ret = smumgr->smumgr_funcs->start_smu(pp_handle->hwmgr);
+	ret = hwmgr->smumgr_funcs->start_smu(pp_handle->hwmgr);
 	if (ret) {
 		pr_err("smc start failed\n");
-		smumgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
+		hwmgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
 		return ret;
 	}
 
@@ -1157,13 +1149,9 @@ int amd_powerplay_destroy(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;
 
-	if (instance->pm_en) {
-		kfree(instance->hwmgr);
-		instance->hwmgr = NULL;
-	}
+	kfree(instance->hwmgr);
+	instance->hwmgr = NULL;
 
-	kfree(instance->smu_mgr);
-	instance->smu_mgr = NULL;
 	kfree(instance);
 	instance = NULL;
 	return 0;
@@ -1174,7 +1162,7 @@ int amd_powerplay_reset(void *handle)
 	struct pp_instance *instance = (struct pp_instance *)handle;
 	int ret;
 
-	if (cgs_is_virtualization_enabled(instance->smu_mgr->device))
+	if (cgs_is_virtualization_enabled(instance->hwmgr->device))
 		return PP_DPM_DISABLED;
 
 	ret = pp_check(instance);

commit d3f8c0abf45866d0e474181e147594d3da15834d
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Sep 20 11:22:56 2017 +0800

    drm/amd/powerplay: refine interface in struct pp_smumgr_func
    
    unify to use struct hwmgr as function parameter in
    smumgr.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 2634d792404a..c37ea9543ca3 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -83,7 +83,7 @@ static int pp_sw_init(void *handle)
 		if (smumgr->smumgr_funcs->smu_init == NULL)
 			return -EINVAL;
 
-		ret = smumgr->smumgr_funcs->smu_init(smumgr);
+		ret = smumgr->smumgr_funcs->smu_init(pp_handle->hwmgr);
 
 		pr_info("amdgpu: powerplay sw initialized\n");
 	}
@@ -103,7 +103,7 @@ static int pp_sw_fini(void *handle)
 		if (smumgr->smumgr_funcs->smu_fini == NULL)
 			return -EINVAL;
 
-		ret = smumgr->smumgr_funcs->smu_fini(smumgr);
+		ret = smumgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
 	}
 	return ret;
 }
@@ -122,9 +122,9 @@ static int pp_hw_init(void *handle)
 		if (smumgr->smumgr_funcs->start_smu == NULL)
 			return -EINVAL;
 
-		if(smumgr->smumgr_funcs->start_smu(smumgr)) {
+		if(smumgr->smumgr_funcs->start_smu(pp_handle->hwmgr)) {
 			pr_err("smc start failed\n");
-			smumgr->smumgr_funcs->smu_fini(smumgr);
+			smumgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
 			return -EINVAL;;
 		}
 		if (ret == PP_DPM_DISABLED)
@@ -246,10 +246,10 @@ static int pp_resume(void *handle)
 	if (smumgr->smumgr_funcs->start_smu == NULL)
 		return -EINVAL;
 
-	ret = smumgr->smumgr_funcs->start_smu(smumgr);
+	ret = smumgr->smumgr_funcs->start_smu(pp_handle->hwmgr);
 	if (ret) {
 		pr_err("smc start failed\n");
-		smumgr->smumgr_funcs->smu_fini(smumgr);
+		smumgr->smumgr_funcs->smu_fini(pp_handle->hwmgr);
 		return ret;
 	}
 

commit f93f0c3a7e8635a507b3f084f5f8b48441c79c9d
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Sep 6 16:08:03 2017 +0800

    drm/amd/powerplay: use struct amd_pm_funcs in powerplay
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 75c810f93e9e..2634d792404a 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -376,11 +376,12 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 	return level;
 }
 
-static int pp_dpm_get_sclk(void *handle, bool low)
+static uint32_t pp_dpm_get_sclk(void *handle, bool low)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
+	uint32_t clk = 0;
 
 	ret = pp_check(pp_handle);
 
@@ -394,16 +395,17 @@ static int pp_dpm_get_sclk(void *handle, bool low)
 		return 0;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->get_sclk(hwmgr, low);
+	clk = hwmgr->hwmgr_func->get_sclk(hwmgr, low);
 	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
+	return clk;
 }
 
-static int pp_dpm_get_mclk(void *handle, bool low)
+static uint32_t pp_dpm_get_mclk(void *handle, bool low)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
+	uint32_t clk = 0;
 
 	ret = pp_check(pp_handle);
 
@@ -417,12 +419,12 @@ static int pp_dpm_get_mclk(void *handle, bool low)
 		return 0;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->get_mclk(hwmgr, low);
+	clk = hwmgr->hwmgr_func->get_mclk(hwmgr, low);
 	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
+	return clk;
 }
 
-static int pp_dpm_powergate_vce(void *handle, bool gate)
+static void pp_dpm_powergate_vce(void *handle, bool gate)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -431,21 +433,20 @@ static int pp_dpm_powergate_vce(void *handle, bool gate)
 	ret = pp_check(pp_handle);
 
 	if (ret != 0)
-		return ret;
+		return;
 
 	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
-		return 0;
+		return;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
+	hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
 	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
 }
 
-static int pp_dpm_powergate_uvd(void *handle, bool gate)
+static void pp_dpm_powergate_uvd(void *handle, bool gate)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -454,18 +455,17 @@ static int pp_dpm_powergate_uvd(void *handle, bool gate)
 	ret = pp_check(pp_handle);
 
 	if (ret != 0)
-		return ret;
+		return;
 
 	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
-		return 0;
+		return;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
+	hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
 	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
 }
 
 static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
@@ -530,7 +530,7 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	return pm_type;
 }
 
-static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
+static void pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -539,25 +539,25 @@ static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 	ret = pp_check(pp_handle);
 
 	if (ret != 0)
-		return ret;
+		return;
 
 	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
-		return 0;
+		return;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
+	hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
 	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
 }
 
-static int pp_dpm_get_fan_control_mode(void *handle)
+static uint32_t pp_dpm_get_fan_control_mode(void *handle)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
+	uint32_t mode = 0;
 
 	ret = pp_check(pp_handle);
 
@@ -571,9 +571,9 @@ static int pp_dpm_get_fan_control_mode(void *handle)
 		return 0;
 	}
 	mutex_lock(&pp_handle->pp_lock);
-	ret = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
+	mode = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
 	mutex_unlock(&pp_handle->pp_lock);
-	return ret;
+	return mode;
 }
 
 static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
@@ -1096,7 +1096,7 @@ static int pp_dpm_switch_power_profile(void *handle,
 	return 0;
 }
 
-const struct amd_powerplay_funcs pp_dpm_funcs = {
+const struct amd_pm_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,

commit 9947f7047f2b57735fa5c76d63728642a1850527
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Aug 29 16:08:56 2017 +0800

    drm/amd/powerplay: add UMD P-state in powerplay.
    
    This feature is for UMD to run benchmark in a
    power state that is as steady as possible. kmd
    need to fix the power state as stable as possible.
    now, kmd support four level:
    profile_standard,peak,min_sclk,min_mclk
    
    move common related code to amd_powerplay.c
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 94bed3c08161..75c810f93e9e 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -30,7 +30,6 @@
 #include "pp_instance.h"
 #include "power_state.h"
 
-
 static inline int pp_check(struct pp_instance *handle)
 {
 	if (handle == NULL || handle->pp_valid != PP_VALID)
@@ -287,6 +286,42 @@ static int pp_dpm_fw_loading_complete(void *handle)
 	return 0;
 }
 
+static void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,
+						enum amd_dpm_forced_level *level)
+{
+	uint32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD |
+					AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK |
+					AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK |
+					AMD_DPM_FORCED_LEVEL_PROFILE_PEAK;
+
+	if (!(hwmgr->dpm_level & profile_mode_mask)) {
+		/* enter umd pstate, save current level, disable gfx cg*/
+		if (*level & profile_mode_mask) {
+			hwmgr->saved_dpm_level = hwmgr->dpm_level;
+			hwmgr->en_umd_pstate = true;
+			cgs_set_clockgating_state(hwmgr->device,
+						AMD_IP_BLOCK_TYPE_GFX,
+						AMD_CG_STATE_UNGATE);
+			cgs_set_powergating_state(hwmgr->device,
+					AMD_IP_BLOCK_TYPE_GFX,
+					AMD_PG_STATE_UNGATE);
+		}
+	} else {
+		/* exit umd pstate, restore level, enable gfx cg*/
+		if (!(*level & profile_mode_mask)) {
+			if (*level == AMD_DPM_FORCED_LEVEL_PROFILE_EXIT)
+				*level = hwmgr->saved_dpm_level;
+			hwmgr->en_umd_pstate = false;
+			cgs_set_clockgating_state(hwmgr->device,
+					AMD_IP_BLOCK_TYPE_GFX,
+					AMD_CG_STATE_GATE);
+			cgs_set_powergating_state(hwmgr->device,
+					AMD_IP_BLOCK_TYPE_GFX,
+					AMD_PG_STATE_GATE);
+		}
+	}
+}
+
 static int pp_dpm_force_performance_level(void *handle,
 					enum amd_dpm_forced_level level)
 {
@@ -301,14 +336,22 @@ static int pp_dpm_force_performance_level(void *handle,
 
 	hwmgr = pp_handle->hwmgr;
 
+	if (level == hwmgr->dpm_level)
+		return 0;
+
 	if (hwmgr->hwmgr_func->force_dpm_level == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
 	mutex_lock(&pp_handle->pp_lock);
+	pp_dpm_en_umd_pstate(hwmgr, &level);
+	hwmgr->request_dpm_level = level;
 	hwmgr_handle_task(pp_handle, AMD_PP_TASK_READJUST_POWER_STATE, NULL, NULL);
-	hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
+	ret = hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
+	if (!ret)
+		hwmgr->dpm_level = hwmgr->request_dpm_level;
+
 	mutex_unlock(&pp_handle->pp_lock);
 	return 0;
 }

commit df1e63942063a0638a5813e5904988d834db2665
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Sep 1 13:46:20 2017 +0800

    drm/amd/powerplay: delete eventmgr layer in poweprlay
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index f73e80c4bf33..94bed3c08161 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -29,7 +29,6 @@
 #include "amd_powerplay.h"
 #include "pp_instance.h"
 #include "power_state.h"
-#include "eventmanager.h"
 
 
 static inline int pp_check(struct pp_instance *handle)
@@ -43,8 +42,7 @@ static inline int pp_check(struct pp_instance *handle)
 	if (handle->pm_en == 0)
 		return PP_DPM_DISABLED;
 
-	if (handle->hwmgr == NULL || handle->hwmgr->hwmgr_func == NULL
-		|| handle->eventmgr == NULL)
+	if (handle->hwmgr == NULL || handle->hwmgr->hwmgr_func == NULL)
 		return PP_DPM_DISABLED;
 
 	return 0;
@@ -69,14 +67,6 @@ static int pp_early_init(void *handle)
 		return PP_DPM_DISABLED;
 	}
 
-	ret = eventmgr_early_init(pp_handle);
-	if (ret) {
-		kfree(pp_handle->hwmgr);
-		pp_handle->hwmgr = NULL;
-		pp_handle->pm_en = 0;
-		return PP_DPM_DISABLED;
-	}
-
 	return 0;
 }
 
@@ -122,7 +112,6 @@ static int pp_sw_fini(void *handle)
 static int pp_hw_init(void *handle)
 {
 	struct pp_smumgr *smumgr;
-	struct pp_eventmgr *eventmgr;
 	int ret = 0;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
@@ -146,38 +135,23 @@ static int pp_hw_init(void *handle)
 	ret = hwmgr_hw_init(pp_handle);
 	if (ret)
 		goto err;
-
-	eventmgr = pp_handle->eventmgr;
-	if (eventmgr->pp_eventmgr_init == NULL ||
-		eventmgr->pp_eventmgr_init(eventmgr))
-		goto err;
-
 	return 0;
 err:
 	pp_handle->pm_en = 0;
-	kfree(pp_handle->eventmgr);
 	kfree(pp_handle->hwmgr);
 	pp_handle->hwmgr = NULL;
-	pp_handle->eventmgr = NULL;
 	return PP_DPM_DISABLED;
 }
 
 static int pp_hw_fini(void *handle)
 {
-	struct pp_eventmgr *eventmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
 
 	ret = pp_check(pp_handle);
-
-	if (ret == 0) {
-		eventmgr = pp_handle->eventmgr;
-
-		if (eventmgr->pp_eventmgr_fini != NULL)
-			eventmgr->pp_eventmgr_fini(eventmgr);
-
+	if (ret == 0)
 		hwmgr_hw_fini(pp_handle);
-	}
+
 	return 0;
 }
 
@@ -244,8 +218,6 @@ static int pp_set_powergating_state(void *handle,
 
 static int pp_suspend(void *handle)
 {
-	struct pp_eventmgr *eventmgr;
-	struct pem_event_data event_data = { {0} };
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
 
@@ -256,16 +228,11 @@ static int pp_suspend(void *handle)
 	else if (ret != 0)
 		return ret;
 
-	eventmgr = pp_handle->eventmgr;
-	pem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);
-
-	return 0;
+	return hwmgr_hw_suspend(pp_handle);
 }
 
 static int pp_resume(void *handle)
 {
-	struct pp_eventmgr *eventmgr;
-	struct pem_event_data event_data = { {0} };
 	struct pp_smumgr *smumgr;
 	int ret, ret1;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -290,11 +257,7 @@ static int pp_resume(void *handle)
 	if (ret1 == PP_DPM_DISABLED)
 		return 0;
 
-	eventmgr = pp_handle->eventmgr;
-
-	pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
-
-	return 0;
+	return hwmgr_hw_resume(pp_handle);
 }
 
 const struct amd_ip_funcs pp_ip_funcs = {
@@ -344,6 +307,7 @@ static int pp_dpm_force_performance_level(void *handle,
 	}
 
 	mutex_lock(&pp_handle->pp_lock);
+	hwmgr_handle_task(pp_handle, AMD_PP_TASK_READJUST_POWER_STATE, NULL, NULL);
 	hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
 	mutex_unlock(&pp_handle->pp_lock);
 	return 0;
@@ -461,60 +425,21 @@ static int pp_dpm_powergate_uvd(void *handle, bool gate)
 	return ret;
 }
 
-static enum PP_StateUILabel power_state_convert(enum amd_pm_state_type  state)
-{
-	switch (state) {
-	case POWER_STATE_TYPE_BATTERY:
-		return PP_StateUILabel_Battery;
-	case POWER_STATE_TYPE_BALANCED:
-		return PP_StateUILabel_Balanced;
-	case POWER_STATE_TYPE_PERFORMANCE:
-		return PP_StateUILabel_Performance;
-	default:
-		return PP_StateUILabel_None;
-	}
-}
-
-static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
+static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,
 		void *input, void *output)
 {
 	int ret = 0;
-	struct pem_event_data data = { {0} };
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
 	ret = pp_check(pp_handle);
 
 	if (ret != 0)
 		return ret;
-	mutex_lock(&pp_handle->pp_lock);
-	switch (event_id) {
-	case AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE:
-		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
-		break;
-	case AMD_PP_EVENT_ENABLE_USER_STATE:
-	{
-		enum amd_pm_state_type  ps;
-
-		if (input == NULL) {
-			ret = -EINVAL;
-			break;
-		}
-		ps = *(unsigned long *)input;
 
-		data.requested_ui_label = power_state_convert(ps);
-		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
-		break;
-	}
-	case AMD_PP_EVENT_COMPLETE_INIT:
-		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
-		break;
-	case AMD_PP_EVENT_READJUST_POWER_STATE:
-		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
-		break;
-	default:
-		break;
-	}
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr_handle_task(pp_handle, task_id, input, output);
 	mutex_unlock(&pp_handle->pp_lock);
+
 	return ret;
 }
 
@@ -1190,10 +1115,8 @@ int amd_powerplay_destroy(void *handle)
 	struct pp_instance *instance = (struct pp_instance *)handle;
 
 	if (instance->pm_en) {
-		kfree(instance->eventmgr);
 		kfree(instance->hwmgr);
 		instance->hwmgr = NULL;
-		instance->eventmgr = NULL;
 	}
 
 	kfree(instance->smu_mgr);
@@ -1206,8 +1129,6 @@ int amd_powerplay_destroy(void *handle)
 int amd_powerplay_reset(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;
-	struct pp_eventmgr *eventmgr;
-	struct pem_event_data event_data = { {0} };
 	int ret;
 
 	if (cgs_is_virtualization_enabled(instance->smu_mgr->device))
@@ -1217,7 +1138,7 @@ int amd_powerplay_reset(void *handle)
 	if (ret != 0)
 		return ret;
 
-	ret = pp_hw_fini(handle);
+	ret = pp_hw_fini(instance);
 	if (ret)
 		return ret;
 
@@ -1225,16 +1146,7 @@ int amd_powerplay_reset(void *handle)
 	if (ret)
 		return PP_DPM_DISABLED;
 
-	eventmgr = instance->eventmgr;
-
-	if (eventmgr->pp_eventmgr_init == NULL)
-		return PP_DPM_DISABLED;
-
-	ret = eventmgr->pp_eventmgr_init(eventmgr);
-	if (ret)
-		return ret;
-
-	return pem_handle_event(eventmgr, AMD_PP_EVENT_COMPLETE_INIT, &event_data);
+	return hwmgr_handle_task(instance, AMD_PP_TASK_COMPLETE_INIT, NULL, NULL);
 }
 
 /* export this function to DAL */

commit 4573f0f21d6c40a9426d0418646d87bbf77d6ab5
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Apr 10 14:40:51 2017 +0800

    drm/amd/powerplay: fix suspend error on DPM disabled
    
    Don't fail if DPM is disabled.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9da5b0bb66d8..f73e80c4bf33 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -251,7 +251,9 @@ static int pp_suspend(void *handle)
 
 	ret = pp_check(pp_handle);
 
-	if (ret != 0)
+	if (ret == PP_DPM_DISABLED)
+		return 0;
+	else if (ret != 0)
 		return ret;
 
 	eventmgr = pp_handle->eventmgr;

commit 99147e64428b9c3bfcd97e545ae478906c79e6a8
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Apr 3 21:42:42 2017 +0300

    drm/amd/powerplay: fix a couple locking issues
    
    We should return unlock on the error path in pp_dpm_dispatch_tasks()
    and there is a double lock bug in pp_dpm_set_sclk_od().
    
    Fixes: 2a5071056e6a ("drm/amd/powerplay: add global PowerPlay mutex.")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 07dbeb225df7..9da5b0bb66d8 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -493,8 +493,10 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
 	{
 		enum amd_pm_state_type  ps;
 
-		if (input == NULL)
-			return -EINVAL;
+		if (input == NULL) {
+			ret = -EINVAL;
+			break;
+		}
 		ps = *(unsigned long *)input;
 
 		data.requested_ui_label = power_state_convert(ps);

commit 0f987cd0d78ead344a07c6fe215234f3be51d051
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Apr 3 21:41:47 2017 +0300

    drm/amd/powerplay: fix pp_dpm_get_current_power_state() (v2)
    
    This switch statement is missing breaks.
    
    v2: agd: break in default case as well
    
    Fixes: 2a5071056e6a ("drm/amd/powerplay: add global PowerPlay mutex.")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6f0ed07bb587..07dbeb225df7 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -539,15 +539,19 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	switch (state->classification.ui_label) {
 	case PP_StateUILabel_Battery:
 		pm_type = POWER_STATE_TYPE_BATTERY;
+		break;
 	case PP_StateUILabel_Balanced:
 		pm_type = POWER_STATE_TYPE_BALANCED;
+		break;
 	case PP_StateUILabel_Performance:
 		pm_type = POWER_STATE_TYPE_PERFORMANCE;
+		break;
 	default:
 		if (state->classification.flags & PP_StateClassificationFlag_Boot)
 			pm_type = POWER_STATE_TYPE_INTERNAL_BOOT;
 		else
 			pm_type = POWER_STATE_TYPE_DEFAULT;
+		break;
 	}
 	mutex_unlock(&pp_handle->pp_lock);
 

commit ad4febd9b7a5b3e86090e5223a6ddf946a63998f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Mar 31 10:51:29 2017 -0400

    drm/amdgpu/powerplay: fix locking typo
    
    Fixes: 2a5071056e6a601e ("drm/amd/powerplay: add global PowerPlay mutex.")
    Reported-by: Julia Lawall <julia.lawall@lip6.fr>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index dfd4fe6f0578..6f0ed07bb587 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -894,7 +894,7 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 
 	mutex_lock(&pp_handle->pp_lock);
 	ret = hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
-	mutex_lock(&pp_handle->pp_lock);
+	mutex_unlock(&pp_handle->pp_lock);
 	return ret;
 }
 

commit d018772748fc474b2265ce333a704620b17df3fd
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Mon Mar 6 13:13:48 2017 -0500

    drm/amd/powerplay: add some display/powerplay interfaces
    
    New interfaces needed to handle the new clock trees and
    bandwidth requirements on vega10.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 6e1e695f97c5..dfd4fe6f0578 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1349,6 +1349,100 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 	return ret;
 }
 
+int amd_powerplay_get_clock_by_type_with_latency(void *handle,
+		enum amd_pp_clock_type type,
+		struct pp_clock_levels_with_latency *clocks)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+	if (ret != 0)
+		return ret;
+
+	if (!clocks)
+		return -EINVAL;
+
+	mutex_lock(&pp_handle->pp_lock);
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	ret = phm_get_clock_by_type_with_latency(hwmgr, type, clocks);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
+}
+
+int amd_powerplay_get_clock_by_type_with_voltage(void *handle,
+		enum amd_pp_clock_type type,
+		struct pp_clock_levels_with_voltage *clocks)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+	if (ret != 0)
+		return ret;
+
+	if (!clocks)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	mutex_lock(&pp_handle->pp_lock);
+
+	ret = phm_get_clock_by_type_with_voltage(hwmgr, type, clocks);
+
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
+}
+
+int amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,
+		struct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+	if (ret != 0)
+		return ret;
+
+	if (!wm_with_clock_ranges)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	mutex_lock(&pp_handle->pp_lock);
+	ret = phm_set_watermarks_for_clocks_ranges(hwmgr,
+			wm_with_clock_ranges);
+	mutex_unlock(&pp_handle->pp_lock);
+
+	return ret;
+}
+
+int amd_powerplay_display_clock_voltage_request(void *handle,
+		struct pp_display_clock_request *clock)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
+
+	ret = pp_check(pp_handle);
+	if (ret != 0)
+		return ret;
+
+	if (!clock)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	mutex_lock(&pp_handle->pp_lock);
+	ret = phm_display_clock_voltage_request(hwmgr, clock);
+	mutex_unlock(&pp_handle->pp_lock);
+
+	return ret;
+}
+
 int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 		struct amd_pp_simple_clock_info *clocks)
 {

commit 2a5071056e6a601efafe628a2f8162e16397ee2d
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Feb 20 17:07:36 2017 +0800

    drm/amd/powerplay: add global PowerPlay mutex.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 79c22f98dc5c..6e1e695f97c5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -341,8 +341,9 @@ static int pp_dpm_force_performance_level(void *handle,
 		return 0;
 	}
 
+	mutex_lock(&pp_handle->pp_lock);
 	hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
-
+	mutex_unlock(&pp_handle->pp_lock);
 	return 0;
 }
 
@@ -352,6 +353,7 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
+	enum amd_dpm_forced_level level;
 
 	ret = pp_check(pp_handle);
 
@@ -359,8 +361,10 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
-
-	return hwmgr->dpm_level;
+	mutex_lock(&pp_handle->pp_lock);
+	level = hwmgr->dpm_level;
+	mutex_unlock(&pp_handle->pp_lock);
+	return level;
 }
 
 static int pp_dpm_get_sclk(void *handle, bool low)
@@ -380,8 +384,10 @@ static int pp_dpm_get_sclk(void *handle, bool low)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->get_sclk(hwmgr, low);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_sclk(hwmgr, low);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_mclk(void *handle, bool low)
@@ -401,8 +407,10 @@ static int pp_dpm_get_mclk(void *handle, bool low)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->get_mclk(hwmgr, low);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_mclk(hwmgr, low);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_powergate_vce(void *handle, bool gate)
@@ -422,8 +430,10 @@ static int pp_dpm_powergate_vce(void *handle, bool gate)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_powergate_uvd(void *handle, bool gate)
@@ -443,8 +453,10 @@ static int pp_dpm_powergate_uvd(void *handle, bool gate)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static enum PP_StateUILabel power_state_convert(enum amd_pm_state_type  state)
@@ -472,7 +484,7 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
 
 	if (ret != 0)
 		return ret;
-
+	mutex_lock(&pp_handle->pp_lock);
 	switch (event_id) {
 	case AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE:
 		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
@@ -498,6 +510,7 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
 	default:
 		break;
 	}
+	mutex_unlock(&pp_handle->pp_lock);
 	return ret;
 }
 
@@ -507,6 +520,7 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	struct pp_power_state *state;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
+	enum amd_pm_state_type pm_type;
 
 	ret = pp_check(pp_handle);
 
@@ -518,21 +532,26 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	if (hwmgr->current_ps == NULL)
 		return -EINVAL;
 
+	mutex_lock(&pp_handle->pp_lock);
+
 	state = hwmgr->current_ps;
 
 	switch (state->classification.ui_label) {
 	case PP_StateUILabel_Battery:
-		return POWER_STATE_TYPE_BATTERY;
+		pm_type = POWER_STATE_TYPE_BATTERY;
 	case PP_StateUILabel_Balanced:
-		return POWER_STATE_TYPE_BALANCED;
+		pm_type = POWER_STATE_TYPE_BALANCED;
 	case PP_StateUILabel_Performance:
-		return POWER_STATE_TYPE_PERFORMANCE;
+		pm_type = POWER_STATE_TYPE_PERFORMANCE;
 	default:
 		if (state->classification.flags & PP_StateClassificationFlag_Boot)
-			return  POWER_STATE_TYPE_INTERNAL_BOOT;
+			pm_type = POWER_STATE_TYPE_INTERNAL_BOOT;
 		else
-			return POWER_STATE_TYPE_DEFAULT;
+			pm_type = POWER_STATE_TYPE_DEFAULT;
 	}
+	mutex_unlock(&pp_handle->pp_lock);
+
+	return pm_type;
 }
 
 static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
@@ -552,8 +571,10 @@ static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_fan_control_mode(void *handle)
@@ -573,8 +594,10 @@ static int pp_dpm_get_fan_control_mode(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
@@ -594,8 +617,10 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
@@ -616,7 +641,10 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 		return 0;
 	}
 
-	return hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
@@ -635,7 +663,10 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 	if (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)
 		return -EINVAL;
 
-	return hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_temperature(void *handle)
@@ -655,8 +686,10 @@ static int pp_dpm_get_temperature(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->get_temperature(hwmgr);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_temperature(hwmgr);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_pp_num_states(void *handle,
@@ -677,6 +710,8 @@ static int pp_dpm_get_pp_num_states(void *handle,
 	if (hwmgr->ps == NULL)
 		return -EINVAL;
 
+	mutex_lock(&pp_handle->pp_lock);
+
 	data->nums = hwmgr->num_ps;
 
 	for (i = 0; i < hwmgr->num_ps; i++) {
@@ -699,7 +734,7 @@ static int pp_dpm_get_pp_num_states(void *handle,
 				data->states[i] = POWER_STATE_TYPE_DEFAULT;
 		}
 	}
-
+	mutex_unlock(&pp_handle->pp_lock);
 	return 0;
 }
 
@@ -708,6 +743,7 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 	struct pp_hwmgr *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
+	int size = 0;
 
 	ret = pp_check(pp_handle);
 
@@ -719,9 +755,11 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 	if (!hwmgr->soft_pp_table)
 		return -EINVAL;
 
+	mutex_lock(&pp_handle->pp_lock);
 	*table = (char *)hwmgr->soft_pp_table;
-
-	return hwmgr->soft_pp_table_size;
+	size = hwmgr->soft_pp_table_size;
+	mutex_unlock(&pp_handle->pp_lock);
+	return size;
 }
 
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
@@ -736,19 +774,21 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
-
+	mutex_lock(&pp_handle->pp_lock);
 	if (!hwmgr->hardcode_pp_table) {
 		hwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,
 						   hwmgr->soft_pp_table_size,
 						   GFP_KERNEL);
-
-		if (!hwmgr->hardcode_pp_table)
+		if (!hwmgr->hardcode_pp_table) {
+			mutex_unlock(&pp_handle->pp_lock);
 			return -ENOMEM;
+		}
 	}
 
 	memcpy(hwmgr->hardcode_pp_table, buf, size);
 
 	hwmgr->soft_pp_table = hwmgr->hardcode_pp_table;
+	mutex_unlock(&pp_handle->pp_lock);
 
 	ret = amd_powerplay_reset(handle);
 	if (ret)
@@ -781,8 +821,10 @@ static int pp_dpm_force_clock_level(void *handle,
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
+	mutex_lock(&pp_handle->pp_lock);
+	hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_print_clock_levels(void *handle,
@@ -803,7 +845,10 @@ static int pp_dpm_print_clock_levels(void *handle,
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-	return hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_sclk_od(void *handle)
@@ -823,8 +868,10 @@ static int pp_dpm_get_sclk_od(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->get_sclk_od(hwmgr);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_sclk_od(hwmgr);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
@@ -845,7 +892,10 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 		return 0;
 	}
 
-	return hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
+	mutex_lock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_get_mclk_od(void *handle)
@@ -865,8 +915,10 @@ static int pp_dpm_get_mclk_od(void *handle)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->get_mclk_od(hwmgr);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->get_mclk_od(hwmgr);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
@@ -886,8 +938,10 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
-
-	return hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 static int pp_dpm_read_sensor(void *handle, int idx,
@@ -909,7 +963,11 @@ static int pp_dpm_read_sensor(void *handle, int idx,
 		return 0;
 	}
 
-	return hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
+	mutex_unlock(&pp_handle->pp_lock);
+
+	return ret;
 }
 
 static struct amd_vce_state*
@@ -1114,8 +1172,8 @@ int amd_powerplay_create(struct amd_pp_init *pp_init,
 	instance->pm_en = pp_init->pm_en;
 	instance->feature_mask = pp_init->feature_mask;
 	instance->device = pp_init->device;
+	mutex_init(&instance->pp_lock);
 	*handle = instance;
-
 	return 0;
 }
 
@@ -1186,9 +1244,9 @@ int amd_powerplay_display_configuration_change(void *handle,
 		return ret;
 
 	hwmgr = pp_handle->hwmgr;
-
+	mutex_lock(&pp_handle->pp_lock);
 	phm_store_dal_configuration_data(hwmgr, display_config);
-
+	mutex_unlock(&pp_handle->pp_lock);
 	return 0;
 }
 
@@ -1209,7 +1267,10 @@ int amd_powerplay_get_display_power_level(void *handle,
 	if (output == NULL)
 		return -EINVAL;
 
-	return phm_get_dal_power_level(hwmgr, output);
+	mutex_lock(&pp_handle->pp_lock);
+	ret = phm_get_dal_power_level(hwmgr, output);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 int amd_powerplay_get_current_clocks(void *handle,
@@ -1228,14 +1289,22 @@ int amd_powerplay_get_current_clocks(void *handle,
 
 	hwmgr = pp_handle->hwmgr;
 
+	mutex_lock(&pp_handle->pp_lock);
+
 	phm_get_dal_power_level(hwmgr, &simple_clocks);
 
-	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_PowerContainment)) {
-		if (0 != phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks, PHM_PerformanceLevelDesignation_PowerContainment))
-			PP_ASSERT_WITH_CODE(0, "Error in PHM_GetPowerContainmentClockInfo", return -1);
-	} else {
-		if (0 != phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks, PHM_PerformanceLevelDesignation_Activity))
-			PP_ASSERT_WITH_CODE(0, "Error in PHM_GetClockInfo", return -1);
+	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,
+					PHM_PlatformCaps_PowerContainment))
+		ret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,
+					&hw_clocks, PHM_PerformanceLevelDesignation_PowerContainment);
+	else
+		ret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,
+					&hw_clocks, PHM_PerformanceLevelDesignation_Activity);
+
+	if (ret != 0) {
+		pr_info("Error in phm_get_clock_info \n");
+		mutex_unlock(&pp_handle->pp_lock);
+		return -EINVAL;
 	}
 
 	clocks->min_engine_clock = hw_clocks.min_eng_clk;
@@ -1254,14 +1323,12 @@ int amd_powerplay_get_current_clocks(void *handle,
 		clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
 		clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
 	}
-
+	mutex_unlock(&pp_handle->pp_lock);
 	return 0;
-
 }
 
 int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
 {
-	int result = -1;
 	struct pp_hwmgr  *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 	int ret = 0;
@@ -1276,9 +1343,10 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 	if (clocks == NULL)
 		return -EINVAL;
 
-	result = phm_get_clock_by_type(hwmgr, type, clocks);
-
-	return result;
+	mutex_lock(&pp_handle->pp_lock);
+	ret = phm_get_clock_by_type(hwmgr, type, clocks);
+	mutex_unlock(&pp_handle->pp_lock);
+	return ret;
 }
 
 int amd_powerplay_get_display_mode_validation_clocks(void *handle,
@@ -1295,13 +1363,15 @@ int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 
 	hwmgr = pp_handle->hwmgr;
 
-
 	if (clocks == NULL)
 		return -EINVAL;
 
+	mutex_lock(&pp_handle->pp_lock);
+
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))
 		ret = phm_get_max_high_clocks(hwmgr, clocks);
 
+	mutex_unlock(&pp_handle->pp_lock);
 	return ret;
 }
 

commit 93a4aec2180f3950e98b2eedfd231f0eea1ece88
Author: Andrew F. Davis <afd@ti.com>
Date:   Wed Mar 15 11:20:24 2017 -0500

    drm/amd/powerplay: remove unneeded conversions to bool
    
    Found with scripts/coccinelle/misc/boolconv.cocci.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8132d464dcb6..79c22f98dc5c 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -239,7 +239,7 @@ static int pp_set_powergating_state(void *handle,
 
 	/* Enable/disable GFX per cu powergating through SMU */
 	return hwmgr->hwmgr_func->enable_per_cu_power_gating(hwmgr,
-			state == AMD_PG_STATE_GATE ? true : false);
+			state == AMD_PG_STATE_GATE);
 }
 
 static int pp_suspend(void *handle)

commit dd4bdf3b35dd8c33dfc41b9917f202f6602dfa48
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Wed Mar 1 15:49:31 2017 -0500

    drm/amd/powerplay: add voltage change support through pp_table
    
    Disable avfs to make voltage change take effect.
    
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fde8fcd46b58..8132d464dcb6 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -750,7 +750,17 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 
 	hwmgr->soft_pp_table = hwmgr->hardcode_pp_table;
 
-	return amd_powerplay_reset(handle);
+	ret = amd_powerplay_reset(handle);
+	if (ret)
+		return ret;
+
+	if (hwmgr->hwmgr_func->avfs_control) {
+		ret = hwmgr->hwmgr_func->avfs_control(hwmgr, false);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
 }
 
 static int pp_dpm_force_clock_level(void *handle,

commit 9f8df7d71e382c9afa808a08c11a990e90ac7df4
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Thu Feb 9 14:29:01 2017 -0500

    drm/amd/amdgpu: Update read_sensor calls to have size parameter (v3)
    
    This update allows sensors to return more than 1 value and
    indicates to the caller how many bytes are written.
    
    The debugfs interface has been updated to handle reading all
    of the values.  Simply seek to the enum value (multiplied
    by 4) and then read as many bytes as the sensor provides.
    
    (v2):  Don't set size to 4 before reading GPU_POWER
    (v3): agd: rebase
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 81e6856ffa11..fde8fcd46b58 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -880,7 +880,8 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 	return hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
 }
 
-static int pp_dpm_read_sensor(void *handle, int idx, void *value)
+static int pp_dpm_read_sensor(void *handle, int idx,
+			      void *value, int *size)
 {
 	struct pp_hwmgr *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;
@@ -898,7 +899,7 @@ static int pp_dpm_read_sensor(void *handle, int idx, void *value)
 		return 0;
 	}
 
-	return hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value);
+	return hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);
 }
 
 static struct amd_vce_state*

commit cd7b0c66ce35e8693a0018b4ce0bc59f46f97bd1
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Tue Feb 7 16:37:48 2017 -0500

    drm/amd/powerplay: change parameter type pointer from int32_t to void in read sensor
    
    As well as fix print format for uint32_t type.
    
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8074386da36f..81e6856ffa11 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -880,7 +880,7 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 	return hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
 }
 
-static int pp_dpm_read_sensor(void *handle, int idx, int32_t *value)
+static int pp_dpm_read_sensor(void *handle, int idx, void *value)
 {
 	struct pp_hwmgr *hwmgr;
 	struct pp_instance *pp_handle = (struct pp_instance *)handle;

commit 34bb2734d1bc3c72e4739234481c0efab0941d14
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Mon Sep 12 16:17:44 2016 -0400

    drm/amd/amdgpu: add power profile sysfs entry
    
    Add the sysfs entries pp_gfx_power_profile and
    pp_compute_power_profile which give user a way to set
    power profile through parameters minimum sclk, minimum mclk,
    activity threshold, up hysteresis and down hysteresis only
    when the entry power_dpm_force_performance_level is in
    default value "auto". It is read and write. Example:
    
    echo 500 800 20 0 5 > /sys/class/drm/card0/device/pp_*_power_profile
    
    cat /sys/class/drm/card0/device/pp_*_power_profile
    500 800 20 0 5
    
    Note: first parameter is sclk in MHz, second is mclk in MHz,
    third is activity threshold in percentage, fourth is up hysteresis
    in ms and fifth is down hysteresis in ms.
    
    echo set > /sys/class/drm/card0/device/pp_*_power_profile
    To set power profile state if it exists.
    
    echo reset > /sys/class/drm/card0/device/pp_*_power_profile
    To restore default state and clear previous setting.
    
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Acked-by: Rex Zhu <Rex.Zhu@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index e9cf207b9dcf..8074386da36f 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -917,10 +917,140 @@ pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 
 	if (hwmgr && idx < hwmgr->num_vce_state_tables)
 		return &hwmgr->vce_states[idx];
-
 	return NULL;
 }
 
+static int pp_dpm_reset_power_profile_state(void *handle,
+		struct amd_pp_profile *request)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	if (!request || pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->set_power_profile_state == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	if (request->type == AMD_PP_GFX_PROFILE) {
+		hwmgr->gfx_power_profile = hwmgr->default_gfx_power_profile;
+		return hwmgr->hwmgr_func->set_power_profile_state(hwmgr,
+				&hwmgr->gfx_power_profile);
+	} else if (request->type == AMD_PP_COMPUTE_PROFILE) {
+		hwmgr->compute_power_profile =
+				hwmgr->default_compute_power_profile;
+		return hwmgr->hwmgr_func->set_power_profile_state(hwmgr,
+				&hwmgr->compute_power_profile);
+	} else
+		return -EINVAL;
+}
+
+static int pp_dpm_get_power_profile_state(void *handle,
+		struct amd_pp_profile *query)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	if (!query || pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (query->type == AMD_PP_GFX_PROFILE)
+		memcpy(query, &hwmgr->gfx_power_profile,
+				sizeof(struct amd_pp_profile));
+	else if (query->type == AMD_PP_COMPUTE_PROFILE)
+		memcpy(query, &hwmgr->compute_power_profile,
+				sizeof(struct amd_pp_profile));
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int pp_dpm_set_power_profile_state(void *handle,
+		struct amd_pp_profile *request)
+{
+	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = -1;
+
+	if (!request || pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->hwmgr_func->set_power_profile_state == NULL) {
+		pr_info("%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	if (request->min_sclk ||
+		request->min_mclk ||
+		request->activity_threshold ||
+		request->up_hyst ||
+		request->down_hyst) {
+		if (request->type == AMD_PP_GFX_PROFILE)
+			memcpy(&hwmgr->gfx_power_profile, request,
+					sizeof(struct amd_pp_profile));
+		else if (request->type == AMD_PP_COMPUTE_PROFILE)
+			memcpy(&hwmgr->compute_power_profile, request,
+					sizeof(struct amd_pp_profile));
+		else
+			return -EINVAL;
+
+		if (request->type == hwmgr->current_power_profile)
+			ret = hwmgr->hwmgr_func->set_power_profile_state(
+					hwmgr,
+					request);
+	} else {
+		/* set power profile if it exists */
+		switch (request->type) {
+		case AMD_PP_GFX_PROFILE:
+			ret = hwmgr->hwmgr_func->set_power_profile_state(
+					hwmgr,
+					&hwmgr->gfx_power_profile);
+			break;
+		case AMD_PP_COMPUTE_PROFILE:
+			ret = hwmgr->hwmgr_func->set_power_profile_state(
+					hwmgr,
+					&hwmgr->compute_power_profile);
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	if (!ret)
+		hwmgr->current_power_profile = request->type;
+
+	return 0;
+}
+
+static int pp_dpm_switch_power_profile(void *handle,
+		enum amd_pp_profile_type type)
+{
+	struct pp_hwmgr *hwmgr;
+	struct amd_pp_profile request = {0};
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	if (pp_check(pp_handle))
+		return -EINVAL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->current_power_profile != type) {
+		request.type = type;
+		pp_dpm_set_power_profile_state(handle, &request);
+	}
+
+	return 0;
+}
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
@@ -949,6 +1079,10 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.set_mclk_od = pp_dpm_set_mclk_od,
 	.read_sensor = pp_dpm_read_sensor,
 	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
+	.reset_power_profile_state = pp_dpm_reset_power_profile_state,
+	.get_power_profile_state = pp_dpm_get_power_profile_state,
+	.set_power_profile_state = pp_dpm_set_power_profile_state,
+	.switch_power_profile = pp_dpm_switch_power_profile,
 };
 
 int amd_powerplay_create(struct amd_pp_init *pp_init,

commit 8fdf26925897974b71283014eb09c57e7e0d2ed8
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Wed Jan 25 15:55:30 2017 +0800

    drm/amdgpu:fix powerplay logic
    
    1,like pp_hw_init, we shouldn't report error if PP disabled
    2,disable pp_en if sriov
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 429f18b99323..e9cf207b9dcf 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -286,7 +286,7 @@ static int pp_resume(void *handle)
 	}
 
 	if (ret1 == PP_DPM_DISABLED)
-		return ret1;
+		return 0;
 
 	eventmgr = pp_handle->eventmgr;
 

commit 1c86380248467b99a0d9a9f7fdd0834fa0c6c5aa
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Dec 28 19:43:23 2016 +0800

    drm/amd/powerplay: refine powerplay interface.
    
    v2: add pp_check function to check pp_instance
       valid.
    
    1. powerplay export two new interface to amdgpu,
       amd_powerplay_create/amd_powerplay_destroy.
    2. create pp_instance/smumgr/hwmgr/eventmgr in
       early init, destroy them when lata_fini.
    3. in sw_init, create and init asic private smumgr
       data, and free them when sw_fini.
    4. in hw_init, create and init asic private hwmgr
       data, and free them when hw_fini.
    5. export powerplay state: PP_DPM_DISABLED.
       when user disabled powerplay or hwmgr/eventmgr
       init failed, powerplay return this state to amdgpu.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fbbac6ba0d17..429f18b99323 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -32,162 +32,152 @@
 #include "eventmanager.h"
 
 
-#define PP_CHECK(handle)						\
-	do {								\
-		if ((handle) == NULL || (handle)->pp_valid != PP_VALID)	\
-			return -EINVAL;					\
-	} while (0)
-
-#define PP_CHECK_HW(hwmgr)						\
-	do {								\
-		if ((hwmgr) == NULL || (hwmgr)->hwmgr_func == NULL)	\
-			return 0;					\
-	} while (0)
-
-static int pp_early_init(void *handle)
+static inline int pp_check(struct pp_instance *handle)
 {
-	return 0;
-}
-
-static int pp_sw_init(void *handle)
-{
-	struct pp_instance *pp_handle;
-	struct pp_hwmgr  *hwmgr;
-	int ret = 0;
+	if (handle == NULL || handle->pp_valid != PP_VALID)
+		return -EINVAL;
 
-	if (handle == NULL)
+	if (handle->smu_mgr == NULL || handle->smu_mgr->smumgr_funcs == NULL)
 		return -EINVAL;
 
-	pp_handle = (struct pp_instance *)handle;
-	hwmgr = pp_handle->hwmgr;
+	if (handle->pm_en == 0)
+		return PP_DPM_DISABLED;
 
-	PP_CHECK_HW(hwmgr);
+	if (handle->hwmgr == NULL || handle->hwmgr->hwmgr_func == NULL
+		|| handle->eventmgr == NULL)
+		return PP_DPM_DISABLED;
 
-	if (hwmgr->pptable_func == NULL ||
-	    hwmgr->pptable_func->pptable_init == NULL ||
-	    hwmgr->hwmgr_func->backend_init == NULL)
-		return -EINVAL;
+	return 0;
+}
 
-	ret = hwmgr->pptable_func->pptable_init(hwmgr);
-	if (ret)
-		goto err;
+static int pp_early_init(void *handle)
+{
+	int ret;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	ret = hwmgr->hwmgr_func->backend_init(hwmgr);
+	ret = smum_early_init(pp_handle);
 	if (ret)
-		goto err1;
+		return ret;
+
+	if ((pp_handle->pm_en == 0)
+		|| cgs_is_virtualization_enabled(pp_handle->device))
+		return PP_DPM_DISABLED;
 
-	if (hwmgr->hwmgr_func->request_firmware) {
-		ret = hwmgr->hwmgr_func->request_firmware(hwmgr);
-		if (ret)
-			goto err2;
+	ret = hwmgr_early_init(pp_handle);
+	if (ret) {
+		pp_handle->pm_en = 0;
+		return PP_DPM_DISABLED;
 	}
 
-	pr_info("initialized.\n");
+	ret = eventmgr_early_init(pp_handle);
+	if (ret) {
+		kfree(pp_handle->hwmgr);
+		pp_handle->hwmgr = NULL;
+		pp_handle->pm_en = 0;
+		return PP_DPM_DISABLED;
+	}
 
 	return 0;
-err2:
-	if (hwmgr->hwmgr_func->backend_fini)
-		hwmgr->hwmgr_func->backend_fini(hwmgr);
-err1:
-	if (hwmgr->pptable_func->pptable_fini)
-		hwmgr->pptable_func->pptable_fini(hwmgr);
-err:
-	pr_err("initialization failed\n");
-	return ret;
 }
 
-static int pp_sw_fini(void *handle)
+static int pp_sw_init(void *handle)
 {
-	struct pp_instance *pp_handle;
-	struct pp_hwmgr  *hwmgr;
+	struct pp_smumgr *smumgr;
 	int ret = 0;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	pp_handle = (struct pp_instance *)handle;
-	hwmgr = pp_handle->hwmgr;
+	if (ret == 0 || ret == PP_DPM_DISABLED) {
+		smumgr = pp_handle->smu_mgr;
 
-	PP_CHECK_HW(hwmgr);
+		if (smumgr->smumgr_funcs->smu_init == NULL)
+			return -EINVAL;
 
-	if (hwmgr->hwmgr_func->release_firmware)
-		 ret = hwmgr->hwmgr_func->release_firmware(hwmgr);
+		ret = smumgr->smumgr_funcs->smu_init(smumgr);
 
-	if (hwmgr->hwmgr_func->backend_fini != NULL)
-		ret = hwmgr->hwmgr_func->backend_fini(hwmgr);
+		pr_info("amdgpu: powerplay sw initialized\n");
+	}
+	return ret;
+}
 
-	if (hwmgr->pptable_func->pptable_fini)
-		hwmgr->pptable_func->pptable_fini(hwmgr);
+static int pp_sw_fini(void *handle)
+{
+	struct pp_smumgr *smumgr;
+	int ret = 0;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+
+	ret = pp_check(pp_handle);
+	if (ret == 0 || ret == PP_DPM_DISABLED) {
+		smumgr = pp_handle->smu_mgr;
 
+		if (smumgr->smumgr_funcs->smu_fini == NULL)
+			return -EINVAL;
+
+		ret = smumgr->smumgr_funcs->smu_fini(smumgr);
+	}
 	return ret;
 }
 
 static int pp_hw_init(void *handle)
 {
-	struct pp_instance *pp_handle;
 	struct pp_smumgr *smumgr;
 	struct pp_eventmgr *eventmgr;
-	struct pp_hwmgr  *hwmgr;
 	int ret = 0;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	pp_handle = (struct pp_instance *)handle;
-	smumgr = pp_handle->smu_mgr;
-	hwmgr = pp_handle->hwmgr;
-
-	if (smumgr == NULL || smumgr->smumgr_funcs == NULL ||
-		smumgr->smumgr_funcs->smu_init == NULL ||
-		smumgr->smumgr_funcs->start_smu == NULL)
-		return -EINVAL;
+	if (ret == 0 || ret == PP_DPM_DISABLED) {
+		smumgr = pp_handle->smu_mgr;
 
-	ret = smumgr->smumgr_funcs->smu_init(smumgr);
-	if (ret) {
-		pr_err("smc initialization failed\n");
-		return ret;
-	}
+		if (smumgr->smumgr_funcs->start_smu == NULL)
+			return -EINVAL;
 
-	ret = smumgr->smumgr_funcs->start_smu(smumgr);
-	if (ret) {
-		pr_err("smc start failed\n");
-		smumgr->smumgr_funcs->smu_fini(smumgr);
-		return ret;
+		if(smumgr->smumgr_funcs->start_smu(smumgr)) {
+			pr_err("smc start failed\n");
+			smumgr->smumgr_funcs->smu_fini(smumgr);
+			return -EINVAL;;
+		}
+		if (ret == PP_DPM_DISABLED)
+			return PP_DPM_DISABLED;
 	}
 
-	PP_CHECK_HW(hwmgr);
-
-	hw_init_power_state_table(hwmgr);
+	ret = hwmgr_hw_init(pp_handle);
+	if (ret)
+		goto err;
 
 	eventmgr = pp_handle->eventmgr;
-	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
-		return -EINVAL;
+	if (eventmgr->pp_eventmgr_init == NULL ||
+		eventmgr->pp_eventmgr_init(eventmgr))
+		goto err;
 
-	ret = eventmgr->pp_eventmgr_init(eventmgr);
 	return 0;
+err:
+	pp_handle->pm_en = 0;
+	kfree(pp_handle->eventmgr);
+	kfree(pp_handle->hwmgr);
+	pp_handle->hwmgr = NULL;
+	pp_handle->eventmgr = NULL;
+	return PP_DPM_DISABLED;
 }
 
 static int pp_hw_fini(void *handle)
 {
-	struct pp_instance *pp_handle;
-	struct pp_smumgr *smumgr;
 	struct pp_eventmgr *eventmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
-
-	pp_handle = (struct pp_instance *)handle;
-	eventmgr = pp_handle->eventmgr;
-
-	if (eventmgr != NULL && eventmgr->pp_eventmgr_fini != NULL)
-		eventmgr->pp_eventmgr_fini(eventmgr);
+	ret = pp_check(pp_handle);
 
-	smumgr = pp_handle->smu_mgr;
+	if (ret == 0) {
+		eventmgr = pp_handle->eventmgr;
 
-	if (smumgr != NULL && smumgr->smumgr_funcs != NULL &&
-		smumgr->smumgr_funcs->smu_fini != NULL)
-		smumgr->smumgr_funcs->smu_fini(smumgr);
+		if (eventmgr->pp_eventmgr_fini != NULL)
+			eventmgr->pp_eventmgr_fini(eventmgr);
 
+		hwmgr_hw_fini(pp_handle);
+	}
 	return 0;
 }
 
@@ -210,13 +200,15 @@ static int pp_sw_reset(void *handle)
 int amd_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -230,13 +222,15 @@ static int pp_set_powergating_state(void *handle,
 				    enum amd_powergating_state state)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -250,37 +244,38 @@ static int pp_set_powergating_state(void *handle,
 
 static int pp_suspend(void *handle)
 {
-	struct pp_instance *pp_handle;
 	struct pp_eventmgr *eventmgr;
 	struct pem_event_data event_data = { {0} };
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
+
+	if (ret != 0)
+		return ret;
 
-	pp_handle = (struct pp_instance *)handle;
 	eventmgr = pp_handle->eventmgr;
+	pem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);
 
-	if (eventmgr != NULL)
-		pem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);
 	return 0;
 }
 
 static int pp_resume(void *handle)
 {
-	struct pp_instance *pp_handle;
 	struct pp_eventmgr *eventmgr;
 	struct pem_event_data event_data = { {0} };
 	struct pp_smumgr *smumgr;
-	int ret;
+	int ret, ret1;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret1 = pp_check(pp_handle);
+
+	if (ret1 != 0 && ret1 != PP_DPM_DISABLED)
+		return ret1;
 
-	pp_handle = (struct pp_instance *)handle;
 	smumgr = pp_handle->smu_mgr;
 
-	if (smumgr == NULL || smumgr->smumgr_funcs == NULL ||
-		smumgr->smumgr_funcs->start_smu == NULL)
+	if (smumgr->smumgr_funcs->start_smu == NULL)
 		return -EINVAL;
 
 	ret = smumgr->smumgr_funcs->start_smu(smumgr);
@@ -290,9 +285,12 @@ static int pp_resume(void *handle)
 		return ret;
 	}
 
+	if (ret1 == PP_DPM_DISABLED)
+		return ret1;
+
 	eventmgr = pp_handle->eventmgr;
-	if (eventmgr != NULL)
-		pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
+
+	pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
 
 	return 0;
 }
@@ -327,18 +325,17 @@ static int pp_dpm_fw_loading_complete(void *handle)
 static int pp_dpm_force_performance_level(void *handle,
 					enum amd_dpm_forced_level level)
 {
-	struct pp_instance *pp_handle;
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	pp_handle = (struct pp_instance *)handle;
+	if (ret != 0)
+		return ret;
 
 	hwmgr = pp_handle->hwmgr;
 
-	PP_CHECK_HW(hwmgr);
-
 	if (hwmgr->hwmgr_func->force_dpm_level == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
 		return 0;
@@ -353,27 +350,31 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 								void *handle)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
-	return (((struct pp_instance *)handle)->hwmgr->dpm_level);
+	return hwmgr->dpm_level;
 }
 
 static int pp_dpm_get_sclk(void *handle, bool low)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_sclk == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -386,13 +387,15 @@ static int pp_dpm_get_sclk(void *handle, bool low)
 static int pp_dpm_get_mclk(void *handle, bool low)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_mclk == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -405,13 +408,15 @@ static int pp_dpm_get_mclk(void *handle, bool low)
 static int pp_dpm_powergate_vce(void *handle, bool gate)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -424,13 +429,15 @@ static int pp_dpm_powergate_vce(void *handle, bool gate)
 static int pp_dpm_powergate_uvd(void *handle, bool gate)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -458,16 +465,13 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
 		void *input, void *output)
 {
 	int ret = 0;
-	struct pp_instance *pp_handle;
 	struct pem_event_data data = { {0} };
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
 
-	pp_handle = (struct pp_instance *)handle;
+	ret = pp_check(pp_handle);
 
-	if (pp_handle == NULL)
-		return -EINVAL;
-
-	if (pp_handle->eventmgr == NULL)
-		return 0;
+	if (ret != 0)
+		return ret;
 
 	switch (event_id) {
 	case AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE:
@@ -501,13 +505,17 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 {
 	struct pp_hwmgr *hwmgr;
 	struct pp_power_state *state;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	if (hwmgr == NULL || hwmgr->current_ps == NULL)
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr->current_ps == NULL)
 		return -EINVAL;
 
 	state = hwmgr->current_ps;
@@ -530,13 +538,15 @@ static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -549,13 +559,15 @@ static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 static int pp_dpm_get_fan_control_mode(void *handle)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -568,13 +580,15 @@ static int pp_dpm_get_fan_control_mode(void *handle)
 static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -587,13 +601,15 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -606,13 +622,15 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)
 		return -EINVAL;
@@ -623,13 +641,15 @@ static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
 static int pp_dpm_get_temperature(void *handle)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_temperature == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -644,13 +664,17 @@ static int pp_dpm_get_pp_num_states(void *handle,
 {
 	struct pp_hwmgr *hwmgr;
 	int i;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->ps == NULL)
+	if (hwmgr->ps == NULL)
 		return -EINVAL;
 
 	data->nums = hwmgr->num_ps;
@@ -682,13 +706,15 @@ static int pp_dpm_get_pp_num_states(void *handle,
 static int pp_dpm_get_pp_table(void *handle, char **table)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (!hwmgr->soft_pp_table)
 		return -EINVAL;
@@ -701,13 +727,15 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (!hwmgr->hardcode_pp_table) {
 		hwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,
@@ -729,13 +757,15 @@ static int pp_dpm_force_clock_level(void *handle,
 		enum pp_clock_type type, uint32_t mask)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->force_clock_level == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -749,13 +779,15 @@ static int pp_dpm_print_clock_levels(void *handle,
 		enum pp_clock_type type, char *buf)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->print_clock_levels == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -767,13 +799,15 @@ static int pp_dpm_print_clock_levels(void *handle,
 static int pp_dpm_get_sclk_od(void *handle)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_sclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -786,13 +820,15 @@ static int pp_dpm_get_sclk_od(void *handle)
 static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->set_sclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -805,13 +841,15 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 static int pp_dpm_get_mclk_od(void *handle)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->get_mclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -824,13 +862,15 @@ static int pp_dpm_get_mclk_od(void *handle)
 static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->set_mclk_od == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -843,13 +883,15 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 static int pp_dpm_read_sensor(void *handle, int idx, int32_t *value)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (!handle)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	if (hwmgr->hwmgr_func->read_sensor == NULL) {
 		pr_info("%s was not implemented.\n", __func__);
@@ -863,13 +905,18 @@ static struct amd_vce_state*
 pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
 {
 	struct pp_hwmgr *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	if (handle) {
-		hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	ret = pp_check(pp_handle);
 
-		if (hwmgr && idx < hwmgr->num_vce_state_tables)
-			return &hwmgr->vce_states[idx];
-	}
+	if (ret != 0)
+		return NULL;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr && idx < hwmgr->num_vce_state_tables)
+		return &hwmgr->vce_states[idx];
 
 	return NULL;
 }
@@ -904,89 +951,44 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
 };
 
-static int amd_pp_instance_init(struct amd_pp_init *pp_init,
-				struct amd_powerplay *amd_pp)
+int amd_powerplay_create(struct amd_pp_init *pp_init,
+				void **handle)
 {
-	int ret;
-	struct pp_instance *handle;
-
-	handle = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
-	if (handle == NULL)
-		return -ENOMEM;
-
-	handle->pp_valid = PP_VALID;
-
-	ret = smum_init(pp_init, handle);
-	if (ret)
-		goto fail_smum;
-
-
-	amd_pp->pp_handle = handle;
+	struct pp_instance *instance;
 
-	if ((amdgpu_dpm == 0)
-		|| cgs_is_virtualization_enabled(pp_init->device))
-		return 0;
+	if (pp_init == NULL || handle == NULL)
+		return -EINVAL;
 
-	ret = hwmgr_init(pp_init, handle);
-	if (ret)
-		goto fail_hwmgr;
+	instance = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
+	if (instance == NULL)
+		return -ENOMEM;
 
-	ret = eventmgr_init(handle);
-	if (ret)
-		goto fail_eventmgr;
+	instance->pp_valid = PP_VALID;
+	instance->chip_family = pp_init->chip_family;
+	instance->chip_id = pp_init->chip_id;
+	instance->pm_en = pp_init->pm_en;
+	instance->feature_mask = pp_init->feature_mask;
+	instance->device = pp_init->device;
+	*handle = instance;
 
 	return 0;
-
-fail_eventmgr:
-	hwmgr_fini(handle->hwmgr);
-fail_hwmgr:
-	smum_fini(handle->smu_mgr);
-fail_smum:
-	kfree(handle);
-	return ret;
 }
 
-static int amd_pp_instance_fini(void *handle)
+int amd_powerplay_destroy(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;
 
-	if (instance == NULL)
-		return -EINVAL;
-
-	if ((amdgpu_dpm != 0)
-		&& !cgs_is_virtualization_enabled(instance->smu_mgr->device)) {
-		eventmgr_fini(instance->eventmgr);
-		hwmgr_fini(instance->hwmgr);
+	if (instance->pm_en) {
+		kfree(instance->eventmgr);
+		kfree(instance->hwmgr);
+		instance->hwmgr = NULL;
+		instance->eventmgr = NULL;
 	}
 
-	smum_fini(instance->smu_mgr);
-	kfree(handle);
-	return 0;
-}
-
-int amd_powerplay_init(struct amd_pp_init *pp_init,
-		       struct amd_powerplay *amd_pp)
-{
-	int ret;
-
-	if (pp_init == NULL || amd_pp == NULL)
-		return -EINVAL;
-
-	ret = amd_pp_instance_init(pp_init, amd_pp);
-
-	if (ret)
-		return ret;
-
-	amd_pp->ip_funcs = &pp_ip_funcs;
-	amd_pp->pp_funcs = &pp_dpm_funcs;
-
-	return 0;
-}
-
-int amd_powerplay_fini(void *handle)
-{
-	amd_pp_instance_fini(handle);
-
+	kfree(instance->smu_mgr);
+	instance->smu_mgr = NULL;
+	kfree(instance);
+	instance = NULL;
 	return 0;
 }
 
@@ -997,33 +999,25 @@ int amd_powerplay_reset(void *handle)
 	struct pem_event_data event_data = { {0} };
 	int ret;
 
-	if (instance == NULL)
-		return -EINVAL;
-
-	eventmgr = instance->eventmgr;
-	if (!eventmgr || !eventmgr->pp_eventmgr_fini)
-		return -EINVAL;
-
-	eventmgr->pp_eventmgr_fini(eventmgr);
+	if (cgs_is_virtualization_enabled(instance->smu_mgr->device))
+		return PP_DPM_DISABLED;
 
-	ret = pp_sw_fini(handle);
-	if (ret)
+	ret = pp_check(instance);
+	if (ret != 0)
 		return ret;
 
-	kfree(instance->hwmgr->ps);
-
-	ret = pp_sw_init(handle);
+	ret = pp_hw_fini(handle);
 	if (ret)
 		return ret;
 
-	if ((amdgpu_dpm == 0)
-		|| cgs_is_virtualization_enabled(instance->smu_mgr->device))
-		return 0;
+	ret = hwmgr_hw_init(instance);
+	if (ret)
+		return PP_DPM_DISABLED;
 
-	hw_init_power_state_table(instance->hwmgr);
+	eventmgr = instance->eventmgr;
 
-	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
-		return -EINVAL;
+	if (eventmgr->pp_eventmgr_init == NULL)
+		return PP_DPM_DISABLED;
 
 	ret = eventmgr->pp_eventmgr_init(eventmgr);
 	if (ret)
@@ -1038,12 +1032,15 @@ int amd_powerplay_display_configuration_change(void *handle,
 	const struct amd_pp_display_configuration *display_config)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	PP_CHECK((struct pp_instance *)handle);
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	phm_store_dal_configuration_data(hwmgr, display_config);
 
@@ -1054,15 +1051,18 @@ int amd_powerplay_get_display_power_level(void *handle,
 		struct amd_pp_simple_clock_info *output)
 {
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	PP_CHECK((struct pp_instance *)handle);
+	ret = pp_check(pp_handle);
 
-	if (output == NULL)
-		return -EINVAL;
+	if (ret != 0)
+		return ret;
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	hwmgr = pp_handle->hwmgr;
 
-	PP_CHECK_HW(hwmgr);
+	if (output == NULL)
+		return -EINVAL;
 
 	return phm_get_dal_power_level(hwmgr, output);
 }
@@ -1070,18 +1070,18 @@ int amd_powerplay_get_display_power_level(void *handle,
 int amd_powerplay_get_current_clocks(void *handle,
 		struct amd_pp_clock_info *clocks)
 {
-	struct pp_hwmgr  *hwmgr;
 	struct amd_pp_simple_clock_info simple_clocks;
 	struct pp_clock_info hw_clocks;
+	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	PP_CHECK((struct pp_instance *)handle);
-
-	if (clocks == NULL)
-		return -EINVAL;
+	ret = pp_check(pp_handle);
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+	if (ret != 0)
+		return ret;
 
-	PP_CHECK_HW(hwmgr);
+	hwmgr = pp_handle->hwmgr;
 
 	phm_get_dal_power_level(hwmgr, &simple_clocks);
 
@@ -1117,18 +1117,20 @@ int amd_powerplay_get_current_clocks(void *handle,
 int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
 {
 	int result = -1;
+	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	struct pp_hwmgr *hwmgr;
+	ret = pp_check(pp_handle);
 
-	PP_CHECK((struct pp_instance *)handle);
+	if (ret != 0)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
 
 	if (clocks == NULL)
 		return -EINVAL;
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
-
-	PP_CHECK_HW(hwmgr);
-
 	result = phm_get_clock_by_type(hwmgr, type, clocks);
 
 	return result;
@@ -1137,21 +1139,24 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 		struct amd_pp_simple_clock_info *clocks)
 {
-	int result = -1;
 	struct pp_hwmgr  *hwmgr;
+	struct pp_instance *pp_handle = (struct pp_instance *)handle;
+	int ret = 0;
 
-	PP_CHECK((struct pp_instance *)handle);
+	ret = pp_check(pp_handle);
 
-	if (clocks == NULL)
-		return -EINVAL;
+	if (ret != 0)
+		return ret;
+
+	hwmgr = pp_handle->hwmgr;
 
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	PP_CHECK_HW(hwmgr);
+	if (clocks == NULL)
+		return -EINVAL;
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))
-		result = phm_get_max_high_clocks(hwmgr, clocks);
+		ret = phm_get_max_high_clocks(hwmgr, clocks);
 
-	return result;
+	return ret;
 }
 

commit 0fb829def63d5217baef112f9d5c0478016467c7
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Dec 26 14:24:05 2016 +0800

    drm/amd/powerplay: refine print message for amd_powerplay
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8b85153d0eed..fbbac6ba0d17 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -82,7 +82,7 @@ static int pp_sw_init(void *handle)
 			goto err2;
 	}
 
-	pr_info("amdgpu: powerplay initialized\n");
+	pr_info("initialized.\n");
 
 	return 0;
 err2:
@@ -92,7 +92,7 @@ static int pp_sw_init(void *handle)
 	if (hwmgr->pptable_func->pptable_fini)
 		hwmgr->pptable_func->pptable_fini(hwmgr);
 err:
-	pr_err("amdgpu: powerplay initialization failed\n");
+	pr_err("initialization failed\n");
 	return ret;
 }
 
@@ -144,13 +144,13 @@ static int pp_hw_init(void *handle)
 
 	ret = smumgr->smumgr_funcs->smu_init(smumgr);
 	if (ret) {
-		printk(KERN_ERR "[ powerplay ] smc initialization failed\n");
+		pr_err("smc initialization failed\n");
 		return ret;
 	}
 
 	ret = smumgr->smumgr_funcs->start_smu(smumgr);
 	if (ret) {
-		printk(KERN_ERR "[ powerplay ] smc start failed\n");
+		pr_err("smc start failed\n");
 		smumgr->smumgr_funcs->smu_fini(smumgr);
 		return ret;
 	}
@@ -219,7 +219,7 @@ int amd_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -239,7 +239,7 @@ static int pp_set_powergating_state(void *handle,
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -285,7 +285,7 @@ static int pp_resume(void *handle)
 
 	ret = smumgr->smumgr_funcs->start_smu(smumgr);
 	if (ret) {
-		printk(KERN_ERR "[ powerplay ] smc start failed\n");
+		pr_err("smc start failed\n");
 		smumgr->smumgr_funcs->smu_fini(smumgr);
 		return ret;
 	}
@@ -340,7 +340,7 @@ static int pp_dpm_force_performance_level(void *handle,
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->force_dpm_level == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -376,7 +376,7 @@ static int pp_dpm_get_sclk(void *handle, bool low)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_sclk == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -395,7 +395,7 @@ static int pp_dpm_get_mclk(void *handle, bool low)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_mclk == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -414,7 +414,7 @@ static int pp_dpm_powergate_vce(void *handle, bool gate)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -433,7 +433,7 @@ static int pp_dpm_powergate_uvd(void *handle, bool gate)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -539,7 +539,7 @@ static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -558,7 +558,7 @@ static int pp_dpm_get_fan_control_mode(void *handle)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -577,7 +577,7 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -596,7 +596,7 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -632,7 +632,7 @@ static int pp_dpm_get_temperature(void *handle)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_temperature == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -738,7 +738,7 @@ static int pp_dpm_force_clock_level(void *handle,
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->force_clock_level == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -758,7 +758,7 @@ static int pp_dpm_print_clock_levels(void *handle,
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->print_clock_levels == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 	return hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
@@ -776,7 +776,7 @@ static int pp_dpm_get_sclk_od(void *handle)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_sclk_od == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -795,7 +795,7 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->set_sclk_od == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -814,7 +814,7 @@ static int pp_dpm_get_mclk_od(void *handle)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->get_mclk_od == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -833,7 +833,7 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->set_mclk_od == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 
@@ -852,7 +852,7 @@ static int pp_dpm_read_sensor(void *handle, int idx, int32_t *value)
 	PP_CHECK_HW(hwmgr);
 
 	if (hwmgr->hwmgr_func->read_sensor == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		pr_info("%s was not implemented.\n", __func__);
 		return 0;
 	}
 

commit 7bd55429fdbd061306a7881b394aec991198ebcf
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Dec 26 14:05:30 2016 +0800

    drm/amd/powerplay: reshuffle headers to make pr_fmt macro before <linux/xxx.h>
    
    This patch reshuffles headers to define pr_fmt before <linux/xxx.h>.
    It can avoid pr_fmt redefine warnning from linux/xxx.h like below:
    
    CC [M]  /home/ray/gpu/BUILD/x86_64/linux/drivers/gpu/drm/amd/amdgpu//../powerplay/amd_powerplay.o
    /home/ray/gpu/BUILD/x86_64/linux/drivers/gpu/drm/amd/amdgpu//../powerplay/amd_powerplay.c:24:0: warning: "pr_fmt" redefined
     #define pr_fmt(fmt) "[powerplay] " fmt
     ^
    In file included from include/linux/kernel.h:13:0,
                     from include/linux/list.h:8,
                     from include/linux/agp_backend.h:33,
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index cc7219084fad..8b85153d0eed 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -20,6 +20,7 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  *
  */
+#include "pp_debug.h"
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/gfp.h>
@@ -29,7 +30,6 @@
 #include "pp_instance.h"
 #include "power_state.h"
 #include "eventmanager.h"
-#include "pp_debug.h"
 
 
 #define PP_CHECK(handle)						\

commit 167112bff8a753f0b1e5f649a3dfb48246bc6afe
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Dec 14 16:26:54 2016 +0800

    drm/amd/powerplay: add callbacks to move smc firmware request into sw_init phase
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index c81cf1412728..cc7219084fad 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -76,9 +76,18 @@ static int pp_sw_init(void *handle)
 	if (ret)
 		goto err1;
 
+	if (hwmgr->hwmgr_func->request_firmware) {
+		ret = hwmgr->hwmgr_func->request_firmware(hwmgr);
+		if (ret)
+			goto err2;
+	}
+
 	pr_info("amdgpu: powerplay initialized\n");
 
 	return 0;
+err2:
+	if (hwmgr->hwmgr_func->backend_fini)
+		hwmgr->hwmgr_func->backend_fini(hwmgr);
 err1:
 	if (hwmgr->pptable_func->pptable_fini)
 		hwmgr->pptable_func->pptable_fini(hwmgr);
@@ -101,6 +110,9 @@ static int pp_sw_fini(void *handle)
 
 	PP_CHECK_HW(hwmgr);
 
+	if (hwmgr->hwmgr_func->release_firmware)
+		 ret = hwmgr->hwmgr_func->release_firmware(hwmgr);
+
 	if (hwmgr->hwmgr_func->backend_fini != NULL)
 		ret = hwmgr->hwmgr_func->backend_fini(hwmgr);
 

commit e9efaaa047b1aebda27b5b65f17c752eb079e51b
Author: Xiangliang Yu <Xiangliang.Yu@amd.com>
Date:   Wed Nov 30 14:07:16 2016 +0800

    drm/amd/powerplay: Fix potential NULL pointer issue
    
    If doesn't enable dpm, the powerplay will not allocate memory for
    hw management. So, hw_init_power_state_table function will reference
    NULL pointer when resetting.
    
    Signed-off-by: Xiangliang Yu <Xiangliang.Yu@amd.com>
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian KÃ¶nig <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 51a36077b993..c81cf1412728 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -1004,12 +1004,12 @@ int amd_powerplay_reset(void *handle)
 	if (ret)
 		return ret;
 
-	hw_init_power_state_table(instance->hwmgr);
-
 	if ((amdgpu_dpm == 0)
 		|| cgs_is_virtualization_enabled(instance->smu_mgr->device))
 		return 0;
 
+	hw_init_power_state_table(instance->hwmgr);
+
 	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
 		return -EINVAL;
 

commit 7b1e8cad1f3612d8059e1dfd870f4928a68691fa
Author: Trigger Huang <trigger.huang@amd.com>
Date:   Wed Nov 16 10:13:45 2016 -0500

    drm/amdgpu: Disable DPM in virtualization
    
    This patch is used for virtualization support. In virtualization,
    only SMU manager is needed, DPM should be disabled. This is a
    use case for commit 2f9346b6f984
    ("drm/amdgpu/powerplay: pp module only enable smu when dpm disabled.")
    
    Signed-off-by: Trigger Huang <trigger.huang@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 4a4f97b37dcb..51a36077b993 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -911,7 +911,8 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 
 	amd_pp->pp_handle = handle;
 
-	if (amdgpu_dpm == 0)
+	if ((amdgpu_dpm == 0)
+		|| cgs_is_virtualization_enabled(pp_init->device))
 		return 0;
 
 	ret = hwmgr_init(pp_init, handle);
@@ -940,7 +941,8 @@ static int amd_pp_instance_fini(void *handle)
 	if (instance == NULL)
 		return -EINVAL;
 
-	if (amdgpu_dpm != 0) {
+	if ((amdgpu_dpm != 0)
+		&& !cgs_is_virtualization_enabled(instance->smu_mgr->device)) {
 		eventmgr_fini(instance->eventmgr);
 		hwmgr_fini(instance->hwmgr);
 	}
@@ -1004,7 +1006,8 @@ int amd_powerplay_reset(void *handle)
 
 	hw_init_power_state_table(instance->hwmgr);
 
-	if (amdgpu_dpm == 0)
+	if ((amdgpu_dpm == 0)
+		|| cgs_is_virtualization_enabled(instance->smu_mgr->device))
 		return 0;
 
 	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)

commit ba5f884cfa3d7fef06b9487679cc8472bf51aa25
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Oct 27 15:29:57 2016 +0800

    drm/amdgpu/powerplay: pp module only enable smu when dpm disabled.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 1f497647a920..4a4f97b37dcb 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -41,7 +41,7 @@
 #define PP_CHECK_HW(hwmgr)						\
 	do {								\
 		if ((hwmgr) == NULL || (hwmgr)->hwmgr_func == NULL)	\
-			return -EINVAL;					\
+			return 0;					\
 	} while (0)
 
 static int pp_early_init(void *handle)
@@ -115,6 +115,7 @@ static int pp_hw_init(void *handle)
 	struct pp_instance *pp_handle;
 	struct pp_smumgr *smumgr;
 	struct pp_eventmgr *eventmgr;
+	struct pp_hwmgr  *hwmgr;
 	int ret = 0;
 
 	if (handle == NULL)
@@ -122,6 +123,7 @@ static int pp_hw_init(void *handle)
 
 	pp_handle = (struct pp_instance *)handle;
 	smumgr = pp_handle->smu_mgr;
+	hwmgr = pp_handle->hwmgr;
 
 	if (smumgr == NULL || smumgr->smumgr_funcs == NULL ||
 		smumgr->smumgr_funcs->smu_init == NULL ||
@@ -141,9 +143,11 @@ static int pp_hw_init(void *handle)
 		return ret;
 	}
 
-	hw_init_power_state_table(pp_handle->hwmgr);
-	eventmgr = pp_handle->eventmgr;
+	PP_CHECK_HW(hwmgr);
 
+	hw_init_power_state_table(hwmgr);
+
+	eventmgr = pp_handle->eventmgr;
 	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
 		return -EINVAL;
 
@@ -243,7 +247,9 @@ static int pp_suspend(void *handle)
 
 	pp_handle = (struct pp_instance *)handle;
 	eventmgr = pp_handle->eventmgr;
-	pem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);
+
+	if (eventmgr != NULL)
+		pem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);
 	return 0;
 }
 
@@ -273,7 +279,8 @@ static int pp_resume(void *handle)
 	}
 
 	eventmgr = pp_handle->eventmgr;
-	pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
+	if (eventmgr != NULL)
+		pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
 
 	return 0;
 }
@@ -340,8 +347,7 @@ static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
 
 	return (((struct pp_instance *)handle)->hwmgr->dpm_level);
 }
@@ -448,6 +454,9 @@ static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
 	if (pp_handle == NULL)
 		return -EINVAL;
 
+	if (pp_handle->eventmgr == NULL)
+		return 0;
+
 	switch (event_id) {
 	case AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE:
 		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
@@ -899,6 +908,12 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 	if (ret)
 		goto fail_smum;
 
+
+	amd_pp->pp_handle = handle;
+
+	if (amdgpu_dpm == 0)
+		return 0;
+
 	ret = hwmgr_init(pp_init, handle);
 	if (ret)
 		goto fail_hwmgr;
@@ -907,7 +922,6 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 	if (ret)
 		goto fail_eventmgr;
 
-	amd_pp->pp_handle = handle;
 	return 0;
 
 fail_eventmgr:
@@ -926,12 +940,12 @@ static int amd_pp_instance_fini(void *handle)
 	if (instance == NULL)
 		return -EINVAL;
 
-	eventmgr_fini(instance->eventmgr);
-
-	hwmgr_fini(instance->hwmgr);
+	if (amdgpu_dpm != 0) {
+		eventmgr_fini(instance->eventmgr);
+		hwmgr_fini(instance->hwmgr);
+	}
 
 	smum_fini(instance->smu_mgr);
-
 	kfree(handle);
 	return 0;
 }
@@ -990,6 +1004,9 @@ int amd_powerplay_reset(void *handle)
 
 	hw_init_power_state_table(instance->hwmgr);
 
+	if (amdgpu_dpm == 0)
+		return 0;
+
 	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
 		return -EINVAL;
 
@@ -1011,6 +1028,8 @@ int amd_powerplay_display_configuration_change(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
+	PP_CHECK_HW(hwmgr);
+
 	phm_store_dal_configuration_data(hwmgr, display_config);
 
 	return 0;
@@ -1028,6 +1047,8 @@ int amd_powerplay_get_display_power_level(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
+	PP_CHECK_HW(hwmgr);
+
 	return phm_get_dal_power_level(hwmgr, output);
 }
 
@@ -1045,6 +1066,8 @@ int amd_powerplay_get_current_clocks(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
+	PP_CHECK_HW(hwmgr);
+
 	phm_get_dal_power_level(hwmgr, &simple_clocks);
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_PowerContainment)) {
@@ -1089,6 +1112,8 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
+	PP_CHECK_HW(hwmgr);
+
 	result = phm_get_clock_by_type(hwmgr, type, clocks);
 
 	return result;
@@ -1107,6 +1132,8 @@ int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
+	PP_CHECK_HW(hwmgr);
+
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))
 		result = phm_get_max_high_clocks(hwmgr, clocks);
 

commit 72a16a9d59ee0de87d9899959978b8e8f6da8438
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Sat Oct 29 23:28:58 2016 +0300

    drm/amd/powerplay: export a function to read fan rpm
    
    Powerplay hwmgr already has an implementation, all we need to do is to call it.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 0b1f2205c2f1..1f497647a920 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -582,6 +582,23 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 	return hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
 }
 
+static int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);
+}
+
 static int pp_dpm_get_temperature(void *handle)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -852,6 +869,7 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
 	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,
 	.get_fan_speed_percent = pp_dpm_get_fan_speed_percent,
+	.get_fan_speed_rpm = pp_dpm_get_fan_speed_rpm,
 	.get_pp_num_states = pp_dpm_get_pp_num_states,
 	.get_pp_table = pp_dpm_get_pp_table,
 	.set_pp_table = pp_dpm_set_pp_table,

commit 597be302f1d30e908115632fd90049242c470e37
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Oct 7 13:52:43 2016 -0400

    drm/amdgpu/powerplay: add an implementation for get_vce_clock_state (v3)
    
    Used by the powerplay dpm code.
    
    v2: update to the new API
    v3: drop old include
    
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index bb8a345c750a..0b1f2205c2f1 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -821,6 +821,21 @@ static int pp_dpm_read_sensor(void *handle, int idx, int32_t *value)
 	return hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value);
 }
 
+static struct amd_vce_state*
+pp_dpm_get_vce_clock_state(void *handle, unsigned idx)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (handle) {
+		hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+		if (hwmgr && idx < hwmgr->num_vce_state_tables)
+			return &hwmgr->vce_states[idx];
+	}
+
+	return NULL;
+}
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
@@ -847,6 +862,7 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_mclk_od = pp_dpm_get_mclk_od,
 	.set_mclk_od = pp_dpm_set_mclk_od,
 	.read_sensor = pp_dpm_read_sensor,
+	.get_vce_clock_state = pp_dpm_get_vce_clock_state,
 };
 
 static int amd_pp_instance_init(struct amd_pp_init *pp_init,

commit f8a4c11b0a33f98212f39a6882d46dfb7b33a006
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Fri Sep 30 17:58:42 2016 +0800

    drm/amd/powerplay: mark symbols static where possible
    
    We get a few warnings when building kernel with W=1:
    drivers/gpu/drm/amd/amdgpu/../powerplay/smumgr/fiji_smumgr.c:162:5: warning: no previous prototype for 'fiji_setup_pwr_virus' [-Wmissing-prototypes]
    drivers/gpu/drm/amd/amdgpu/../powerplay/smumgr/fiji_smc.c:2052:5: warning: no previous prototype for 'fiji_program_mem_timing_parameters' [-Wmissing-prototypes]
    drivers/gpu/drm/amd/amdgpu/../powerplay/smumgr/polaris10_smumgr.c:175:5: warning: no previous prototype for 'polaris10_avfs_event_mgr' [-Wmissing-prototypes]
    drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/cz_hwmgr.c:69:10: warning: no previous prototype for 'cz_get_eclk_level' [-Wmissing-prototypes]
    drivers/gpu/drm/amd/amdgpu/../powerplay/hwmgr/smu7_hwmgr.c:92:26: warning: no previous prototype for 'cast_phw_smu7_power_state' [-Wmissing-prototypes]
    ....
    
    In fact, these functions are only used in the file in which they are
    declared and don't need a declaration, but can be made static.
    So this patch marks these functions with 'static'.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 7174f7a68266..bb8a345c750a 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -436,7 +436,8 @@ static enum PP_StateUILabel power_state_convert(enum amd_pm_state_type  state)
 	}
 }
 
-int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input, void *output)
+static int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,
+		void *input, void *output)
 {
 	int ret = 0;
 	struct pp_instance *pp_handle;
@@ -475,7 +476,7 @@ int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input,
 	return ret;
 }
 
-enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
+static enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 {
 	struct pp_hwmgr *hwmgr;
 	struct pp_power_state *state;

commit 465f96e21365c3df7b992692393834e984db306c
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sun Sep 18 16:52:03 2016 +0800

    drm/amd/powerplay: export function to help to set cg by smu.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 212ec2fd97ed..7174f7a68266 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -191,11 +191,9 @@ static int pp_sw_reset(void *handle)
 }
 
 
-static int pp_set_clockgating_state(void *handle,
-				    enum amd_clockgating_state state)
+int amd_set_clockgating_by_smu(void *handle, uint32_t msg_id)
 {
 	struct pp_hwmgr  *hwmgr;
-	uint32_t msg_id, pp_state;
 
 	if (handle == NULL)
 		return -EINVAL;
@@ -209,76 +207,7 @@ static int pp_set_clockgating_state(void *handle,
 		return 0;
 	}
 
-	if (state == AMD_CG_STATE_UNGATE)
-		pp_state = 0;
-	else
-		pp_state = PP_STATE_CG | PP_STATE_LS;
-
-	/* Enable/disable GFX blocks clock gating through SMU */
-	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
-			PP_BLOCK_GFX_CG,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
-			PP_BLOCK_GFX_3D,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
-			PP_BLOCK_GFX_RLC,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
-			PP_BLOCK_GFX_CP,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
-			PP_BLOCK_GFX_MG,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-
-	/* Enable/disable System blocks clock gating through SMU */
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_BIF,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_BIF,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_MC,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_ROM,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_DRM,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_HDP,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
-			PP_BLOCK_SYS_SDMA,
-			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
-			pp_state);
-	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
-
-	return 0;
+	return hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
 }
 
 static int pp_set_powergating_state(void *handle,
@@ -362,7 +291,7 @@ const struct amd_ip_funcs pp_ip_funcs = {
 	.is_idle = pp_is_idle,
 	.wait_for_idle = pp_wait_for_idle,
 	.soft_reset = pp_sw_reset,
-	.set_clockgating_state = pp_set_clockgating_state,
+	.set_clockgating_state = NULL,
 	.set_powergating_state = pp_set_powergating_state,
 };
 

commit 3de4ec57271a1979b5d960d8610939fff7dc38f9
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Mon Sep 19 12:48:52 2016 -0400

    drm/amd/powerplay:  Replace per-asic print_performance with generic
    
    Replace per-asic print_current_performance() functions with generic
    that calls read_sensor.  Tested on Tonga and Carrizo for aesthetics
    and accuracy.
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index ee0368381e82..212ec2fd97ed 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -576,28 +576,6 @@ enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	}
 }
 
-static void
-pp_debugfs_print_current_performance_level(void *handle,
-					       struct seq_file *m)
-{
-	struct pp_hwmgr  *hwmgr;
-
-	if (handle == NULL)
-		return;
-
-	hwmgr = ((struct pp_instance *)handle)->hwmgr;
-
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL)
-		return;
-
-	if (hwmgr->hwmgr_func->print_current_perforce_level == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
-		return;
-	}
-
-	hwmgr->hwmgr_func->print_current_perforce_level(hwmgr, m);
-}
-
 static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 {
 	struct pp_hwmgr  *hwmgr;
@@ -925,7 +903,6 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.powergate_vce = pp_dpm_powergate_vce,
 	.powergate_uvd = pp_dpm_powergate_uvd,
 	.dispatch_tasks = pp_dpm_dispatch_tasks,
-	.print_current_performance_level = pp_debugfs_print_current_performance_level,
 	.set_fan_control_mode = pp_dpm_set_fan_control_mode,
 	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
 	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,

commit a6e3695221446cf825d12db9c6ad3502c45fb9de
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Thu Sep 15 10:07:34 2016 -0400

    drm/amd/powerplay: Add read_sensor() callback to hwmgr (v3)
    
    Provides standardized interface to read various sensors.
    The API is extensible (by adding to the end of the
    amd_pp_sensors enumeration list.
    
    Support has been added to Carrizo/smu7
    
    (v2) Squashed the two sensor patches into one.
    (v3) Updated to apply to smu7_hwmgr instead
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index b1d19409bf86..ee0368381e82 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -894,6 +894,25 @@ static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
 	return hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
 }
 
+static int pp_dpm_read_sensor(void *handle, int idx, int32_t *value)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->read_sensor == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value);
+}
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
@@ -920,6 +939,7 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.set_sclk_od = pp_dpm_set_sclk_od,
 	.get_mclk_od = pp_dpm_get_mclk_od,
 	.set_mclk_od = pp_dpm_set_mclk_od,
+	.read_sensor = pp_dpm_read_sensor,
 };
 
 static int amd_pp_instance_init(struct amd_pp_init *pp_init,

commit efdf7a93195a712baff7aa077ae5e4542a9af2f9
Author: Edward O'Callaghan <funfunctor@folklore1984.net>
Date:   Sun Sep 4 12:36:19 2016 +1000

    amd/powerplay: use kmemdup instead of kmalloc + memcpy
    
    Save a few clocks by replacing calls to kmalloc followed by memcpy
    with a single call to kmemdup.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 3e7235ffb009..b1d19409bf86 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -764,15 +764,12 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 	PP_CHECK_HW(hwmgr);
 
 	if (!hwmgr->hardcode_pp_table) {
-		hwmgr->hardcode_pp_table =
-				kzalloc(hwmgr->soft_pp_table_size, GFP_KERNEL);
+		hwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,
+						   hwmgr->soft_pp_table_size,
+						   GFP_KERNEL);
 
 		if (!hwmgr->hardcode_pp_table)
 			return -ENOMEM;
-
-		/* to avoid powerplay crash when hardcode pptable is empty */
-		memcpy(hwmgr->hardcode_pp_table, hwmgr->soft_pp_table,
-				hwmgr->soft_pp_table_size);
 	}
 
 	memcpy(hwmgr->hardcode_pp_table, buf, size);

commit 48fad3aff638c7bc16656e31047f689aa44020a1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Sep 1 02:30:42 2016 +0800

    drm/amd/powerplay: original power state table should not be changed.
    
    power state table was set based on vbios and should not be changed.
    when client need to change power state, just make a copy and send to
    smu.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 2de34a5a85c2..3e7235ffb009 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -538,7 +538,6 @@ int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input,
 		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
 		break;
 	case AMD_PP_EVENT_READJUST_POWER_STATE:
-		pp_handle->hwmgr->current_ps = pp_handle->hwmgr->boot_ps;
 		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
 		break;
 	default:

commit d36f3e048e1e81906c776760d70e06bce366ef65
Author: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date:   Sun Aug 21 20:21:27 2016 +0200

    drm/amd/powerplay: avoid NULL pointer dereference
    
    if (a == NULL || a->b == NULL)
    leads to a NULL pointer dereference if a == NULL.
    
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 12d3333b9d12..2de34a5a85c2 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -163,12 +163,12 @@ static int pp_hw_fini(void *handle)
 	pp_handle = (struct pp_instance *)handle;
 	eventmgr = pp_handle->eventmgr;
 
-	if (eventmgr != NULL || eventmgr->pp_eventmgr_fini != NULL)
+	if (eventmgr != NULL && eventmgr->pp_eventmgr_fini != NULL)
 		eventmgr->pp_eventmgr_fini(eventmgr);
 
 	smumgr = pp_handle->smu_mgr;
 
-	if (smumgr != NULL || smumgr->smumgr_funcs != NULL ||
+	if (smumgr != NULL && smumgr->smumgr_funcs != NULL &&
 		smumgr->smumgr_funcs->smu_fini != NULL)
 		smumgr->smumgr_funcs->smu_fini(smumgr);
 

commit af223dfaf0d93e7a0ed75bed4f69e5db198b741e
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Jul 28 16:51:47 2016 +0800

    drm/amdgpu: add module parameters to ctrl powerplay feature
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index abbb658bdc1e..12d3333b9d12 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -31,6 +31,7 @@
 #include "eventmanager.h"
 #include "pp_debug.h"
 
+
 #define PP_CHECK(handle)						\
 	do {								\
 		if ((handle) == NULL || (handle)->pp_valid != PP_VALID)	\

commit ed5121a3d8fdd8992a82a3815642fc46108300fc
Author: Edward O'Callaghan <funfunctor@folklore1984.net>
Date:   Tue Jul 12 10:17:52 2016 +1000

    drivers/amdgpu: Use 'true/false' for bool typed variables
    
    Found-by: Coccinelle
    Signed-off-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Reviewed-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index f9e03ad0baa2..abbb658bdc1e 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -176,7 +176,7 @@ static int pp_hw_fini(void *handle)
 
 static bool pp_is_idle(void *handle)
 {
-	return 0;
+	return false;
 }
 
 static int pp_wait_for_idle(void *handle)

commit 4dcf9e6f2e33fe33ee6da247682b345cf8aa9a84
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Wed Jun 1 17:08:07 2016 -0400

    drm/amd/powerplay: add uploading pptable and resetting powerplay support
    
    Necessary for re-initializing dpm with new pptables at runtime.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index e931e87757de..f9e03ad0baa2 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -744,12 +744,12 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 
 	PP_CHECK_HW(hwmgr);
 
-	if (hwmgr->hwmgr_func->get_pp_table == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
-		return 0;
-	}
+	if (!hwmgr->soft_pp_table)
+		return -EINVAL;
+
+	*table = (char *)hwmgr->soft_pp_table;
 
-	return hwmgr->hwmgr_func->get_pp_table(hwmgr, table);
+	return hwmgr->soft_pp_table_size;
 }
 
 static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
@@ -763,12 +763,23 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 
 	PP_CHECK_HW(hwmgr);
 
-	if (hwmgr->hwmgr_func->set_pp_table == NULL) {
-		printk(KERN_INFO "%s was not implemented.\n", __func__);
-		return 0;
+	if (!hwmgr->hardcode_pp_table) {
+		hwmgr->hardcode_pp_table =
+				kzalloc(hwmgr->soft_pp_table_size, GFP_KERNEL);
+
+		if (!hwmgr->hardcode_pp_table)
+			return -ENOMEM;
+
+		/* to avoid powerplay crash when hardcode pptable is empty */
+		memcpy(hwmgr->hardcode_pp_table, hwmgr->soft_pp_table,
+				hwmgr->soft_pp_table_size);
 	}
 
-	return hwmgr->hwmgr_func->set_pp_table(hwmgr, buf, size);
+	memcpy(hwmgr->hardcode_pp_table, buf, size);
+
+	hwmgr->soft_pp_table = hwmgr->hardcode_pp_table;
+
+	return amd_powerplay_reset(handle);
 }
 
 static int pp_dpm_force_clock_level(void *handle,
@@ -993,6 +1004,44 @@ int amd_powerplay_fini(void *handle)
 	return 0;
 }
 
+int amd_powerplay_reset(void *handle)
+{
+	struct pp_instance *instance = (struct pp_instance *)handle;
+	struct pp_eventmgr *eventmgr;
+	struct pem_event_data event_data = { {0} };
+	int ret;
+
+	if (instance == NULL)
+		return -EINVAL;
+
+	eventmgr = instance->eventmgr;
+	if (!eventmgr || !eventmgr->pp_eventmgr_fini)
+		return -EINVAL;
+
+	eventmgr->pp_eventmgr_fini(eventmgr);
+
+	ret = pp_sw_fini(handle);
+	if (ret)
+		return ret;
+
+	kfree(instance->hwmgr->ps);
+
+	ret = pp_sw_init(handle);
+	if (ret)
+		return ret;
+
+	hw_init_power_state_table(instance->hwmgr);
+
+	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
+		return -EINVAL;
+
+	ret = eventmgr->pp_eventmgr_init(eventmgr);
+	if (ret)
+		return ret;
+
+	return pem_handle_event(eventmgr, AMD_PP_EVENT_COMPLETE_INIT, &event_data);
+}
+
 /* export this function to DAL */
 
 int amd_powerplay_display_configuration_change(void *handle,

commit f2bdc05f773ea68d31e2d50b9e791b7c7dcd1dfa
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Tue May 24 15:11:17 2016 -0400

    drm/amdgpu: add the common code to support mclk OD
    
    This implements mclk OverDrive(OD) through sysfs.
    The new entry pp_mclk_od is read/write. The value of input/output
    is an integer of the overclocking percentage.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8fa6f594d3ad..e931e87757de 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -848,6 +848,44 @@ static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
 	return hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
 }
 
+static int pp_dpm_get_mclk_od(void *handle)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_mclk_od == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->get_mclk_od(hwmgr);
+}
+
+static int pp_dpm_set_mclk_od(void *handle, uint32_t value)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_mclk_od == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);
+}
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
@@ -872,6 +910,8 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.print_clock_levels = pp_dpm_print_clock_levels,
 	.get_sclk_od = pp_dpm_get_sclk_od,
 	.set_sclk_od = pp_dpm_set_sclk_od,
+	.get_mclk_od = pp_dpm_get_mclk_od,
+	.set_mclk_od = pp_dpm_set_mclk_od,
 };
 
 static int amd_pp_instance_init(struct amd_pp_init *pp_init,

commit 428bafa86c99f1888254aec63bbcb1a2001e8770
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Thu May 12 14:51:21 2016 -0400

    drm/amdgpu: add powerplay sclk OD support through sysfs (v2)
    
    Add a new sysfs entry pp_sclk_od to support sclk overdrive(OD) overclocking,
    the entry is read/write, the value of input/output is an integer which is the
    over percentage of the highest sclk.
    
    v2: drop extra semicolon
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index e629f8a9fe93..8fa6f594d3ad 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -536,6 +536,10 @@ int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input,
 	case AMD_PP_EVENT_COMPLETE_INIT:
 		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
 		break;
+	case AMD_PP_EVENT_READJUST_POWER_STATE:
+		pp_handle->hwmgr->current_ps = pp_handle->hwmgr->boot_ps;
+		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
+		break;
 	default:
 		break;
 	}
@@ -806,6 +810,44 @@ static int pp_dpm_print_clock_levels(void *handle,
 	return hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
 }
 
+static int pp_dpm_get_sclk_od(void *handle)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_sclk_od == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->get_sclk_od(hwmgr);
+}
+
+static int pp_dpm_set_sclk_od(void *handle, uint32_t value)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_sclk_od == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
+
+	return hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);
+}
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
@@ -828,6 +870,8 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.set_pp_table = pp_dpm_set_pp_table,
 	.force_clock_level = pp_dpm_force_clock_level,
 	.print_clock_levels = pp_dpm_print_clock_levels,
+	.get_sclk_od = pp_dpm_get_sclk_od,
+	.set_sclk_od = pp_dpm_set_sclk_od,
 };
 
 static int amd_pp_instance_init(struct amd_pp_init *pp_init,

commit 9d8f086cd05954e03f10db1a9a52a240d086dc8c
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Mon May 30 13:43:45 2016 +0800

    drm/amdgpu: fix memleak in pptable_init
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8e345bfddb69..e629f8a9fe93 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -73,11 +73,14 @@ static int pp_sw_init(void *handle)
 
 	ret = hwmgr->hwmgr_func->backend_init(hwmgr);
 	if (ret)
-		goto err;
+		goto err1;
 
 	pr_info("amdgpu: powerplay initialized\n");
 
 	return 0;
+err1:
+	if (hwmgr->pptable_func->pptable_fini)
+		hwmgr->pptable_func->pptable_fini(hwmgr);
 err:
 	pr_err("amdgpu: powerplay initialization failed\n");
 	return ret;
@@ -100,6 +103,9 @@ static int pp_sw_fini(void *handle)
 	if (hwmgr->hwmgr_func->backend_fini != NULL)
 		ret = hwmgr->hwmgr_func->backend_fini(hwmgr);
 
+	if (hwmgr->pptable_func->pptable_fini)
+		hwmgr->pptable_func->pptable_fini(hwmgr);
+
 	return ret;
 }
 

commit b4eeed590deeff13a53db641129f0301d70248f3
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon May 9 17:29:41 2016 +0800

    drm/amd/powerplay: rewrite pp_sw_init to make code readable
    
    Actually, pp_sw_init executes pptable_init and backend_init orderly if
    they are initialized successfully. So rewrite it to make code more
    readable.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9f2d4069a5f3..8e345bfddb69 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -68,15 +68,18 @@ static int pp_sw_init(void *handle)
 		return -EINVAL;
 
 	ret = hwmgr->pptable_func->pptable_init(hwmgr);
+	if (ret)
+		goto err;
 
-	if (ret == 0)
-		ret = hwmgr->hwmgr_func->backend_init(hwmgr);
-
+	ret = hwmgr->hwmgr_func->backend_init(hwmgr);
 	if (ret)
-		printk(KERN_ERR "amdgpu: powerplay initialization failed\n");
-	else
-		printk(KERN_INFO "amdgpu: powerplay initialized\n");
+		goto err;
 
+	pr_info("amdgpu: powerplay initialized\n");
+
+	return 0;
+err:
+	pr_err("amdgpu: powerplay initialization failed\n");
 	return ret;
 }
 

commit 88a907d67c03e80a71c49681bbccf3bfebe74ab4
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Wed May 4 14:28:35 2016 -0400

    drm/amd/amdgpu: Add name field to amd_ip_funcs (v2)
    
    Add name that we can print out in kernel messages
    to aid in debugging.
    
    v2: drop DAL changes for upstream
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index aba587cfce81..9f2d4069a5f3 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -340,6 +340,7 @@ static int pp_resume(void *handle)
 }
 
 const struct amd_ip_funcs pp_ip_funcs = {
+	.name = "powerplay",
 	.early_init = pp_early_init,
 	.late_init = NULL,
 	.sw_init = pp_sw_init,

commit 16a7989ac62a4d491d44a295577a7e75b7e3b0bb
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Mon Mar 28 08:21:52 2016 -0400

    drm/amd/amdgpu: Drop print_status callbacks.
    
    First patch in series to move to user mode
    debug tools we're removing the print_status callbacks.
    
    These functions were unused at the moment anyway.
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 0527ae3d10f9..aba587cfce81 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -180,10 +180,6 @@ static int pp_sw_reset(void *handle)
 	return 0;
 }
 
-static void pp_print_status(void *handle)
-{
-
-}
 
 static int pp_set_clockgating_state(void *handle,
 				    enum amd_clockgating_state state)
@@ -355,7 +351,6 @@ const struct amd_ip_funcs pp_ip_funcs = {
 	.is_idle = pp_is_idle,
 	.wait_for_idle = pp_wait_for_idle,
 	.soft_reset = pp_sw_reset,
-	.print_status = pp_print_status,
 	.set_clockgating_state = pp_set_clockgating_state,
 	.set_powergating_state = pp_set_powergating_state,
 };

commit 5632708f4452eb9afb985b245b98dac9a5feeac2
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Tue Apr 12 14:57:23 2016 -0400

    drm/amd/powerplay: add dpm force multiple levels on cz/tonga/fiji/polaris (v2)
    
    Allows you to force multiple levels rather than just one via the new
    sysfs interrface.
    
    v2: squash in:
    drm/amd/powerplay: ensure clock level set by user is valid.
    From Rex.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index ce8d9bf8d68d..0527ae3d10f9 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -763,7 +763,7 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 }
 
 static int pp_dpm_force_clock_level(void *handle,
-		enum pp_clock_type type, int level)
+		enum pp_clock_type type, uint32_t mask)
 {
 	struct pp_hwmgr *hwmgr;
 
@@ -779,7 +779,7 @@ static int pp_dpm_force_clock_level(void *handle,
 		return 0;
 	}
 
-	return hwmgr->hwmgr_func->force_clock_level(hwmgr, type, level);
+	return hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);
 }
 
 static int pp_dpm_print_clock_levels(void *handle,

commit 7383bcb94a19349263c7b64f4272d0ca9c94e615
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Mar 30 11:35:50 2016 +0800

    drm/amd/powerplay: return 0 when interface not implement on some asic.
    
    Don't fail if certain optional interface callbacks are missing.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 32a6a6f8ffcb..ce8d9bf8d68d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -37,6 +37,12 @@
 			return -EINVAL;					\
 	} while (0)
 
+#define PP_CHECK_HW(hwmgr)						\
+	do {								\
+		if ((hwmgr) == NULL || (hwmgr)->hwmgr_func == NULL)	\
+			return -EINVAL;					\
+	} while (0)
+
 static int pp_early_init(void *handle)
 {
 	return 0;
@@ -54,8 +60,9 @@ static int pp_sw_init(void *handle)
 	pp_handle = (struct pp_instance *)handle;
 	hwmgr = pp_handle->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->pptable_func == NULL ||
-	    hwmgr->hwmgr_func == NULL ||
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->pptable_func == NULL ||
 	    hwmgr->pptable_func->pptable_init == NULL ||
 	    hwmgr->hwmgr_func->backend_init == NULL)
 		return -EINVAL;
@@ -66,9 +73,9 @@ static int pp_sw_init(void *handle)
 		ret = hwmgr->hwmgr_func->backend_init(hwmgr);
 
 	if (ret)
-		printk("amdgpu: powerplay initialization failed\n");
+		printk(KERN_ERR "amdgpu: powerplay initialization failed\n");
 	else
-		printk("amdgpu: powerplay initialized\n");
+		printk(KERN_INFO "amdgpu: powerplay initialized\n");
 
 	return ret;
 }
@@ -85,8 +92,9 @@ static int pp_sw_fini(void *handle)
 	pp_handle = (struct pp_instance *)handle;
 	hwmgr = pp_handle->hwmgr;
 
-	if (hwmgr != NULL || hwmgr->hwmgr_func != NULL ||
-	    hwmgr->hwmgr_func->backend_fini != NULL)
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->backend_fini != NULL)
 		ret = hwmgr->hwmgr_func->backend_fini(hwmgr);
 
 	return ret;
@@ -188,11 +196,12 @@ static int pp_set_clockgating_state(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL)
-			return -EINVAL;
+	PP_CHECK_HW(hwmgr);
 
-	if (hwmgr->hwmgr_func->update_clock_gatings == NULL)
+	if (hwmgr->hwmgr_func->update_clock_gatings == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
 		return 0;
+	}
 
 	if (state == AMD_CG_STATE_UNGATE)
 		pp_state = 0;
@@ -276,9 +285,12 @@ static int pp_set_powergating_state(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-			hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL)
-				return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	/* Enable/disable GFX per cu powergating through SMU */
 	return hwmgr->hwmgr_func->enable_per_cu_power_gating(hwmgr,
@@ -371,9 +383,12 @@ static int pp_dpm_force_performance_level(void *handle,
 
 	hwmgr = pp_handle->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	    hwmgr->hwmgr_func->force_dpm_level == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->force_dpm_level == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
 
@@ -405,9 +420,12 @@ static int pp_dpm_get_sclk(void *handle, bool low)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	    hwmgr->hwmgr_func->get_sclk == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_sclk == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->get_sclk(hwmgr, low);
 }
@@ -421,9 +439,12 @@ static int pp_dpm_get_mclk(void *handle, bool low)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	    hwmgr->hwmgr_func->get_mclk == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_mclk == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->get_mclk(hwmgr, low);
 }
@@ -437,9 +458,12 @@ static int pp_dpm_powergate_vce(void *handle, bool gate)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	    hwmgr->hwmgr_func->powergate_vce == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->powergate_vce == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
 }
@@ -453,9 +477,12 @@ static int pp_dpm_powergate_uvd(void *handle, bool gate)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	    hwmgr->hwmgr_func->powergate_uvd == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->powergate_uvd == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
 }
@@ -551,9 +578,13 @@ pp_debugfs_print_current_performance_level(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	  hwmgr->hwmgr_func->print_current_perforce_level == NULL)
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL)
+		return;
+
+	if (hwmgr->hwmgr_func->print_current_perforce_level == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
 		return;
+	}
 
 	hwmgr->hwmgr_func->print_current_perforce_level(hwmgr, m);
 }
@@ -567,9 +598,12 @@ static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	  hwmgr->hwmgr_func->set_fan_control_mode == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
 }
@@ -583,9 +617,12 @@ static int pp_dpm_get_fan_control_mode(void *handle)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	  hwmgr->hwmgr_func->get_fan_control_mode == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
 }
@@ -599,9 +636,12 @@ static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	  hwmgr->hwmgr_func->set_fan_speed_percent == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);
 }
@@ -615,9 +655,12 @@ static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	  hwmgr->hwmgr_func->get_fan_speed_percent == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
 }
@@ -631,9 +674,12 @@ static int pp_dpm_get_temperature(void *handle)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-	  hwmgr->hwmgr_func->get_temperature == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_temperature == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->get_temperature(hwmgr);
 }
@@ -687,9 +733,12 @@ static int pp_dpm_get_pp_table(void *handle, char **table)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-		hwmgr->hwmgr_func->get_pp_table == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->get_pp_table == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->get_pp_table(hwmgr, table);
 }
@@ -703,9 +752,12 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-		hwmgr->hwmgr_func->set_pp_table == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->set_pp_table == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->set_pp_table(hwmgr, buf, size);
 }
@@ -720,9 +772,12 @@ static int pp_dpm_force_clock_level(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-			hwmgr->hwmgr_func->force_clock_level == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
+
+	if (hwmgr->hwmgr_func->force_clock_level == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 
 	return hwmgr->hwmgr_func->force_clock_level(hwmgr, type, level);
 }
@@ -737,10 +792,12 @@ static int pp_dpm_print_clock_levels(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-			hwmgr->hwmgr_func->print_clock_levels == NULL)
-		return -EINVAL;
+	PP_CHECK_HW(hwmgr);
 
+	if (hwmgr->hwmgr_func->print_clock_levels == NULL) {
+		printk(KERN_INFO "%s was not implemented.\n", __func__);
+		return 0;
+	}
 	return hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
 }
 

commit 538333f0dcc00e24ca4bd63905fa75aa41b4c665
Author: Flora Cui <Flora.Cui@amd.com>
Date:   Mon Feb 15 15:45:59 2016 +0800

    drm/amd/powerplay: add default clockgating handling
    
    This is to workaround regression introduced in
    46c34bcb6a15dd85329a39a5e72c62108626acdc. It should be reverted with a
    final fix.
    
    Signed-off-by: Flora Cui <Flora.Cui@amd.com>
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 94b78095e1ce..32a6a6f8ffcb 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -188,10 +188,12 @@ static int pp_set_clockgating_state(void *handle,
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
-			hwmgr->hwmgr_func->update_clock_gatings == NULL)
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL)
 			return -EINVAL;
 
+	if (hwmgr->hwmgr_func->update_clock_gatings == NULL)
+		return 0;
+
 	if (state == AMD_CG_STATE_UNGATE)
 		pp_state = 0;
 	else

commit 65f85e7d8216afe458e7d798ad12e7a82a55162f
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Thu Feb 11 15:54:45 2016 -0500

    drm/amd/powerplay: add GFX per cu powergating support through SMU/powerplay
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9c742e0a9d35..94b78095e1ce 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -267,7 +267,20 @@ static int pp_set_clockgating_state(void *handle,
 static int pp_set_powergating_state(void *handle,
 				    enum amd_powergating_state state)
 {
-	return 0;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+			hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL)
+				return -EINVAL;
+
+	/* Enable/disable GFX per cu powergating through SMU */
+	return hwmgr->hwmgr_func->enable_per_cu_power_gating(hwmgr,
+			state == AMD_PG_STATE_GATE ? true : false);
 }
 
 static int pp_suspend(void *handle)

commit 03e3905f21c03beea8f68f2c4cf94cf36e53b160
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Tue Feb 9 16:26:00 2016 -0500

    drm/amd/powerplay: add all blocks clockgating support through SMU/powerplay
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9d2290044708..9c742e0a9d35 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -180,6 +180,87 @@ static void pp_print_status(void *handle)
 static int pp_set_clockgating_state(void *handle,
 				    enum amd_clockgating_state state)
 {
+	struct pp_hwmgr  *hwmgr;
+	uint32_t msg_id, pp_state;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+			hwmgr->hwmgr_func->update_clock_gatings == NULL)
+			return -EINVAL;
+
+	if (state == AMD_CG_STATE_UNGATE)
+		pp_state = 0;
+	else
+		pp_state = PP_STATE_CG | PP_STATE_LS;
+
+	/* Enable/disable GFX blocks clock gating through SMU */
+	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
+			PP_BLOCK_GFX_CG,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
+			PP_BLOCK_GFX_3D,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
+			PP_BLOCK_GFX_RLC,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
+			PP_BLOCK_GFX_CP,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_GFX,
+			PP_BLOCK_GFX_MG,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+
+	/* Enable/disable System blocks clock gating through SMU */
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_BIF,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_BIF,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_MC,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_ROM,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_DRM,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_HDP,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+	msg_id = PP_CG_MSG_ID(PP_GROUP_SYS,
+			PP_BLOCK_SYS_SDMA,
+			PP_STATE_SUPPORT_CG | PP_STATE_SUPPORT_LS,
+			pp_state);
+	hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);
+
 	return 0;
 }
 

commit 9b61c0fcdf0cfd20a85d9856d46142e7f297de0a
Merge: 550e3b23a53c 125234dc8b1c
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 14 09:42:34 2016 +1000

    Merge drm-fixes into drm-next.
    
    Nouveau wanted this to avoid some worse conflicts when I merge that.

commit dc26a2a2b3f037c2727f514b64e8a865721ec74b
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Feb 25 17:16:52 2016 +0800

    drm/amd/powerplay: export AMD_PP_EVENT_COMPLETE_INIT task to amdgpu.
    
    This is needed to init the dynamic states without a display.  To be
    used in the next commit.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index aa67244a77ae..589599f66fcc 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -402,8 +402,11 @@ int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input,
 
 		data.requested_ui_label = power_state_convert(ps);
 		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
+		break;
 	}
-	break;
+	case AMD_PP_EVENT_COMPLETE_INIT:
+		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
+		break;
 	default:
 		break;
 	}

commit 0994c09c0412591ccd7303eec263a9dc5119c653
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Feb 25 17:48:24 2016 +0800

    drm/amd/powerplay: fix code style warning.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 2ee4190f8c89..0db64231effe 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -606,7 +606,7 @@ static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
 
 	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
 		hwmgr->hwmgr_func->set_pp_table == NULL)
-			return -EINVAL;
+		return -EINVAL;
 
 	return hwmgr->hwmgr_func->set_pp_table(hwmgr, buf, size);
 }
@@ -623,7 +623,7 @@ static int pp_dpm_force_clock_level(void *handle,
 
 	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
 			hwmgr->hwmgr_func->force_clock_level == NULL)
-				return -EINVAL;
+		return -EINVAL;
 
 	return hwmgr->hwmgr_func->force_clock_level(hwmgr, type, level);
 }

commit fa9e699105ba4c29e34954fab693b1fc19d70084
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Dec 29 13:56:03 2015 +0800

    drm/amd/powerplay: add powerplay valid check to avoid null point.
    
    In case CONFIG_DRM_AMD_POWERPLAY is defined and amdgpu.powerplay=0.
    some functions in powrplay can also be called by DAL. and the input parameter is *adev.
    if just check point not NULL was not enough and will lead to NULL point error.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9b7c2862c16e..2ee4190f8c89 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -786,7 +786,9 @@ int amd_powerplay_get_current_clocks(void *handle,
 	struct amd_pp_simple_clock_info simple_clocks;
 	struct pp_clock_info hw_clocks;
 
-	if (handle == NULL || clocks == NULL)
+	PP_CHECK((struct pp_instance *)handle);
+
+	if (clocks == NULL)
 		return -EINVAL;
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
@@ -828,7 +830,9 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 
 	struct pp_hwmgr *hwmgr;
 
-	if (handle == NULL || clocks == NULL)
+	PP_CHECK((struct pp_instance *)handle);
+
+	if (clocks == NULL)
 		return -EINVAL;
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
@@ -844,7 +848,9 @@ int amd_powerplay_get_display_mode_validation_clocks(void *handle,
 	int result = -1;
 	struct pp_hwmgr  *hwmgr;
 
-	if (handle == NULL || clocks == NULL)
+	PP_CHECK((struct pp_instance *)handle);
+
+	if (clocks == NULL)
 		return -EINVAL;
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;

commit 155f1127ce6f1e2da6ee139b2869242a40b99814
Author: David Rokhvarg <David.Rokhvarg@amd.com>
Date:   Mon Dec 14 10:51:39 2015 -0500

    drm/amd/powerplay: Make declarations of functions exposed to DAL type-safe.
    
    Signed-off-by: David Rokhvarg <David.Rokhvarg@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index fd56af6e92d4..9b7c2862c16e 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -750,10 +750,10 @@ int amd_powerplay_fini(void *handle)
 
 /* export this function to DAL */
 
-int amd_powerplay_display_configuration_change(void *handle, const void *input)
+int amd_powerplay_display_configuration_change(void *handle,
+	const struct amd_pp_display_configuration *display_config)
 {
 	struct pp_hwmgr  *hwmgr;
-	const struct amd_pp_display_configuration *display_config = input;
 
 	PP_CHECK((struct pp_instance *)handle);
 
@@ -780,14 +780,13 @@ int amd_powerplay_get_display_power_level(void *handle,
 }
 
 int amd_powerplay_get_current_clocks(void *handle,
-		void *output)
+		struct amd_pp_clock_info *clocks)
 {
 	struct pp_hwmgr  *hwmgr;
 	struct amd_pp_simple_clock_info simple_clocks;
 	struct pp_clock_info hw_clocks;
-	struct amd_pp_clock_info *clocks = (struct amd_pp_clock_info *)output;
 
-	if (handle == NULL || output == NULL)
+	if (handle == NULL || clocks == NULL)
 		return -EINVAL;
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
@@ -839,12 +838,10 @@ int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, s
 	return result;
 }
 
-int amd_powerplay_get_display_mode_validation_clocks(void *handle, const void *input,
-							void *output)
+int amd_powerplay_get_display_mode_validation_clocks(void *handle,
+		struct amd_pp_simple_clock_info *clocks)
 {
 	int result = -1;
-
-	struct amd_pp_simple_clock_info *clocks = output;
 	struct pp_hwmgr  *hwmgr;
 
 	if (handle == NULL || clocks == NULL)

commit e273b041174c70aa2c7fd4c279596a07c21b8f16
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon Dec 7 18:44:23 2015 +0800

    drm/amd/powerplay: export interface to DAL.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 9a18c5045926..fd56af6e92d4 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -29,6 +29,7 @@
 #include "pp_instance.h"
 #include "power_state.h"
 #include "eventmanager.h"
+#include "pp_debug.h"
 
 #define PP_CHECK(handle)						\
 	do {								\
@@ -777,3 +778,83 @@ int amd_powerplay_get_display_power_level(void *handle,
 
 	return phm_get_dal_power_level(hwmgr, output);
 }
+
+int amd_powerplay_get_current_clocks(void *handle,
+		void *output)
+{
+	struct pp_hwmgr  *hwmgr;
+	struct amd_pp_simple_clock_info simple_clocks;
+	struct pp_clock_info hw_clocks;
+	struct amd_pp_clock_info *clocks = (struct amd_pp_clock_info *)output;
+
+	if (handle == NULL || output == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	phm_get_dal_power_level(hwmgr, &simple_clocks);
+
+	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_PowerContainment)) {
+		if (0 != phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks, PHM_PerformanceLevelDesignation_PowerContainment))
+			PP_ASSERT_WITH_CODE(0, "Error in PHM_GetPowerContainmentClockInfo", return -1);
+	} else {
+		if (0 != phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks, PHM_PerformanceLevelDesignation_Activity))
+			PP_ASSERT_WITH_CODE(0, "Error in PHM_GetClockInfo", return -1);
+	}
+
+	clocks->min_engine_clock = hw_clocks.min_eng_clk;
+	clocks->max_engine_clock = hw_clocks.max_eng_clk;
+	clocks->min_memory_clock = hw_clocks.min_mem_clk;
+	clocks->max_memory_clock = hw_clocks.max_mem_clk;
+	clocks->min_bus_bandwidth = hw_clocks.min_bus_bandwidth;
+	clocks->max_bus_bandwidth = hw_clocks.max_bus_bandwidth;
+
+	clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
+	clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
+
+	clocks->max_clocks_state = simple_clocks.level;
+
+	if (0 == phm_get_current_shallow_sleep_clocks(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks)) {
+		clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
+		clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
+	}
+
+	return 0;
+
+}
+
+int amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)
+{
+	int result = -1;
+
+	struct pp_hwmgr *hwmgr;
+
+	if (handle == NULL || clocks == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	result = phm_get_clock_by_type(hwmgr, type, clocks);
+
+	return result;
+}
+
+int amd_powerplay_get_display_mode_validation_clocks(void *handle, const void *input,
+							void *output)
+{
+	int result = -1;
+
+	struct amd_pp_simple_clock_info *clocks = output;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL || clocks == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))
+		result = phm_get_max_high_clocks(hwmgr, clocks);
+
+	return result;
+}
+

commit 47329134ae7b16cba16a5501fb7685320da08878
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Dec 10 16:49:50 2015 +0800

    drm/amd/powerplay: change struct name.
    
    amd_pp_dal_clock_info to amd_pp_simple_clock_info.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 4719fa7e8cd7..9a18c5045926 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -764,7 +764,7 @@ int amd_powerplay_display_configuration_change(void *handle, const void *input)
 }
 
 int amd_powerplay_get_display_power_level(void *handle,
-		struct amd_pp_dal_clock_info *output)
+		struct amd_pp_simple_clock_info *output)
 {
 	struct pp_hwmgr  *hwmgr;
 

commit f3898ea12fc1f18a4fa9034b169076e8e72d122a
Author: Eric Huang <JinHuiEric.Huang@amd.com>
Date:   Fri Dec 11 16:24:34 2015 -0500

    drm/amd/powerplay: add some sysfs interfaces for powerplay.
    
    The new sysfs interfaces:
    pp_num_states: Read-only, return the number of all pp states, 0 if powerplay is not available.
    pp_cur_state: Read-only, return the index number of current pp state.
    pp_force_state: Read-write, to write a power state index will switch to selected state forcedly and
                    enable forced state mode, disable forced state mode. such as "echo >...".
    pp_table: Read-write, binary output, to be used to read or write the dpm table, the maximum
                    file size is 4KB of page size.
    pp_dpm_sclk: Read-write, reading will return a dpm levels list, to write an index number will force
                    powerplay to set the corresponding dpm level.
    pp_dpm_mclk: same as sclk.
    pp_dpm_pcie: same as sclk.
    
    And add new setting "manual" to the existing interface power_dpm_force_performance_level.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Eric Huang <JinHuiEric.Huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index aa67244a77ae..4719fa7e8cd7 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -433,7 +433,10 @@ enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 	case PP_StateUILabel_Performance:
 		return POWER_STATE_TYPE_PERFORMANCE;
 	default:
-		return POWER_STATE_TYPE_DEFAULT;
+		if (state->classification.flags & PP_StateClassificationFlag_Boot)
+			return  POWER_STATE_TYPE_INTERNAL_BOOT;
+		else
+			return POWER_STATE_TYPE_DEFAULT;
 	}
 }
 
@@ -535,6 +538,112 @@ static int pp_dpm_get_temperature(void *handle)
 	return hwmgr->hwmgr_func->get_temperature(hwmgr);
 }
 
+static int pp_dpm_get_pp_num_states(void *handle,
+		struct pp_states_info *data)
+{
+	struct pp_hwmgr *hwmgr;
+	int i;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->ps == NULL)
+		return -EINVAL;
+
+	data->nums = hwmgr->num_ps;
+
+	for (i = 0; i < hwmgr->num_ps; i++) {
+		struct pp_power_state *state = (struct pp_power_state *)
+				((unsigned long)hwmgr->ps + i * hwmgr->ps_size);
+		switch (state->classification.ui_label) {
+		case PP_StateUILabel_Battery:
+			data->states[i] = POWER_STATE_TYPE_BATTERY;
+			break;
+		case PP_StateUILabel_Balanced:
+			data->states[i] = POWER_STATE_TYPE_BALANCED;
+			break;
+		case PP_StateUILabel_Performance:
+			data->states[i] = POWER_STATE_TYPE_PERFORMANCE;
+			break;
+		default:
+			if (state->classification.flags & PP_StateClassificationFlag_Boot)
+				data->states[i] = POWER_STATE_TYPE_INTERNAL_BOOT;
+			else
+				data->states[i] = POWER_STATE_TYPE_DEFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static int pp_dpm_get_pp_table(void *handle, char **table)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+		hwmgr->hwmgr_func->get_pp_table == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_pp_table(hwmgr, table);
+}
+
+static int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+		hwmgr->hwmgr_func->set_pp_table == NULL)
+			return -EINVAL;
+
+	return hwmgr->hwmgr_func->set_pp_table(hwmgr, buf, size);
+}
+
+static int pp_dpm_force_clock_level(void *handle,
+		enum pp_clock_type type, int level)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+			hwmgr->hwmgr_func->force_clock_level == NULL)
+				return -EINVAL;
+
+	return hwmgr->hwmgr_func->force_clock_level(hwmgr, type, level);
+}
+
+static int pp_dpm_print_clock_levels(void *handle,
+		enum pp_clock_type type, char *buf)
+{
+	struct pp_hwmgr *hwmgr;
+
+	if (!handle)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+			hwmgr->hwmgr_func->print_clock_levels == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);
+}
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
@@ -552,6 +661,11 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
 	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,
 	.get_fan_speed_percent = pp_dpm_get_fan_speed_percent,
+	.get_pp_num_states = pp_dpm_get_pp_num_states,
+	.get_pp_table = pp_dpm_get_pp_table,
+	.set_pp_table = pp_dpm_set_pp_table,
+	.force_clock_level = pp_dpm_force_clock_level,
+	.print_clock_levels = pp_dpm_print_clock_levels,
 };
 
 static int amd_pp_instance_init(struct amd_pp_init *pp_init,

commit 9441f964f8e39374ab175e0a8fe870e1a2f02af1
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Jan 20 12:15:09 2016 -0500

    drm/amdgpu: add a message to indicate when powerplay is enabled (v2)
    
    Makes it clear to the user which power management path is in
    use.
    
    v2: make consistent with dpm
    
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Tom St Denis <tom.stdenis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 8f5d5edcf193..aa67244a77ae 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -64,6 +64,11 @@ static int pp_sw_init(void *handle)
 	if (ret == 0)
 		ret = hwmgr->hwmgr_func->backend_init(hwmgr);
 
+	if (ret)
+		printk("amdgpu: powerplay initialization failed\n");
+	else
+		printk("amdgpu: powerplay initialized\n");
+
 	return ret;
 }
 

commit e0b71a7eff644ca256aee6478bf220ba0a835bed
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Dec 29 10:25:19 2015 +0800

    drm/amd/powerplay: Reload and initialize the smc firmware on powerplay resume.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 2764bd327034..8f5d5edcf193 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -203,13 +203,29 @@ static int pp_resume(void *handle)
 	struct pp_instance *pp_handle;
 	struct pp_eventmgr *eventmgr;
 	struct pem_event_data event_data = { {0} };
+	struct pp_smumgr *smumgr;
+	int ret;
 
 	if (handle == NULL)
 		return -EINVAL;
 
 	pp_handle = (struct pp_instance *)handle;
+	smumgr = pp_handle->smu_mgr;
+
+	if (smumgr == NULL || smumgr->smumgr_funcs == NULL ||
+		smumgr->smumgr_funcs->start_smu == NULL)
+		return -EINVAL;
+
+	ret = smumgr->smumgr_funcs->start_smu(smumgr);
+	if (ret) {
+		printk(KERN_ERR "[ powerplay ] smc start failed\n");
+		smumgr->smumgr_funcs->smu_fini(smumgr);
+		return ret;
+	}
+
 	eventmgr = pp_handle->eventmgr;
 	pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
+
 	return 0;
 }
 
@@ -624,6 +640,7 @@ int amd_powerplay_display_configuration_change(void *handle, const void *input)
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
 	phm_store_dal_configuration_data(hwmgr, display_config);
+
 	return 0;
 }
 

commit a969e163a4ac1b0cfa2dc7ab890aaa9ab092951c
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Dec 29 13:56:03 2015 +0800

    drm/amd/powerplay: add powerplay valid check to avoid null point. (v2)
    
    In case CONFIG_DRM_AMD_POWERPLAY is defined and amdgpu.powerplay=0.
    some functions in powrplay can also be called by DAL. and the input parameter is *adev.
    if just check point not NULL was not enough and will lead to NULL point error.
    
    V2: AGD: rebase on upstream
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index db0370bd60e3..2764bd327034 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -30,6 +30,12 @@
 #include "power_state.h"
 #include "eventmanager.h"
 
+#define PP_CHECK(handle)						\
+	do {								\
+		if ((handle) == NULL || (handle)->pp_valid != PP_VALID)	\
+			return -EINVAL;					\
+	} while (0)
+
 static int pp_early_init(void *handle)
 {
 	return 0;
@@ -537,6 +543,8 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 	if (handle == NULL)
 		return -ENOMEM;
 
+	handle->pp_valid = PP_VALID;
+
 	ret = smum_init(pp_init, handle);
 	if (ret)
 		goto fail_smum;
@@ -611,8 +619,7 @@ int amd_powerplay_display_configuration_change(void *handle, const void *input)
 	struct pp_hwmgr  *hwmgr;
 	const struct amd_pp_display_configuration *display_config = input;
 
-	if (handle == NULL)
-		return -EINVAL;
+	PP_CHECK((struct pp_instance *)handle);
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
@@ -625,7 +632,9 @@ int amd_powerplay_get_display_power_level(void *handle,
 {
 	struct pp_hwmgr  *hwmgr;
 
-	if (handle == NULL || output == NULL)
+	PP_CHECK((struct pp_instance *)handle);
+
+	if (output == NULL)
 		return -EINVAL;
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;

commit 1c9a90820beb63f75ac7dabf75533f425aadc3fa
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Dec 3 10:27:57 2015 -0500

    amd/powerplay: Fix get dal power level
    
    Simplify data struct for get dal power level
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 0b9876daa8dc..db0370bd60e3 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -620,7 +620,8 @@ int amd_powerplay_display_configuration_change(void *handle, const void *input)
 	return 0;
 }
 
-int amd_powerplay_get_display_power_level(void *handle,  void *output)
+int amd_powerplay_get_display_power_level(void *handle,
+		struct amd_pp_dal_clock_info *output)
 {
 	struct pp_hwmgr  *hwmgr;
 
@@ -629,6 +630,5 @@ int amd_powerplay_get_display_power_level(void *handle,  void *output)
 
 	hwmgr = ((struct pp_instance *)handle)->hwmgr;
 
-	return phm_get_dal_power_level(hwmgr,
-			(struct pp_dal_clock_info *)output);
+	return phm_get_dal_power_level(hwmgr, output);
 }

commit c4dd206be1560ebb6eef9cf2200d10a4577cef3f
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Mon Nov 30 16:39:53 2015 -0500

    amd\powerplay Implement get dal power level
    
    Implement get dal power level and simple clock info
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 215757e0ad76..0b9876daa8dc 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -619,3 +619,16 @@ int amd_powerplay_display_configuration_change(void *handle, const void *input)
 	phm_store_dal_configuration_data(hwmgr, display_config);
 	return 0;
 }
+
+int amd_powerplay_get_display_power_level(void *handle,  void *output)
+{
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL || output == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	return phm_get_dal_power_level(hwmgr,
+			(struct pp_dal_clock_info *)output);
+}

commit 7fb72a1fc01cc1a8de533abc80b9eaf0120e8529
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Nov 19 13:35:30 2015 +0800

    drm/amd/powerplay: export interface to DAL to init/change display configuration.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: David Rokhvarg <David.Rokhvarg@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 10385c0fb60d..215757e0ad76 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -603,3 +603,19 @@ int amd_powerplay_fini(void *handle)
 
 	return 0;
 }
+
+/* export this function to DAL */
+
+int amd_powerplay_display_configuration_change(void *handle, const void *input)
+{
+	struct pp_hwmgr  *hwmgr;
+	const struct amd_pp_display_configuration *display_config = input;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	phm_store_dal_configuration_data(hwmgr, display_config);
+	return 0;
+}

commit cac9a1991922c12a9a24ae20d250221742aed692
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Oct 16 11:48:21 2015 +0800

    drm/amdgpu/powerplay: implement fan control interface in amd_powerplay_funcs
    
    This adds the interface needed to expose powerplay fan control to sysfs
    via hwmon.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 66ccfc0fc622..10385c0fb60d 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -428,9 +428,88 @@ pp_debugfs_print_current_performance_level(void *handle,
 	hwmgr->hwmgr_func->print_current_perforce_level(hwmgr, m);
 }
 
+static int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)
+{
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	  hwmgr->hwmgr_func->set_fan_control_mode == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);
+}
+
+static int pp_dpm_get_fan_control_mode(void *handle)
+{
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	  hwmgr->hwmgr_func->get_fan_control_mode == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);
+}
+
+static int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)
+{
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	  hwmgr->hwmgr_func->set_fan_speed_percent == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);
+}
+
+static int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)
+{
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	  hwmgr->hwmgr_func->get_fan_speed_percent == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);
+}
+
+static int pp_dpm_get_temperature(void *handle)
+{
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	  hwmgr->hwmgr_func->get_temperature == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_temperature(hwmgr);
+}
 
 const struct amd_powerplay_funcs pp_dpm_funcs = {
-	.get_temperature = NULL,
+	.get_temperature = pp_dpm_get_temperature,
 	.load_firmware = pp_dpm_load_fw,
 	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
 	.force_performance_level = pp_dpm_force_performance_level,
@@ -442,6 +521,10 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.powergate_uvd = pp_dpm_powergate_uvd,
 	.dispatch_tasks = pp_dpm_dispatch_tasks,
 	.print_current_performance_level = pp_debugfs_print_current_performance_level,
+	.set_fan_control_mode = pp_dpm_set_fan_control_mode,
+	.get_fan_control_mode = pp_dpm_get_fan_control_mode,
+	.set_fan_speed_percent = pp_dpm_set_fan_speed_percent,
+	.get_fan_speed_percent = pp_dpm_get_fan_speed_percent,
 };
 
 static int amd_pp_instance_init(struct amd_pp_init *pp_init,

commit 577bbe01832285f6f5128ae570246e086e37f9d0
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Aug 28 12:56:43 2015 +0800

    drm/amd/powerplay: implement functions of amd_powerplay_func
    
    This is the common interface for interacting with the powerplay
    module.
    
    v2: squash in fixes
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Acked-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 1964a2add63f..66ccfc0fc622 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -27,6 +27,8 @@
 #include "amd_shared.h"
 #include "amd_powerplay.h"
 #include "pp_instance.h"
+#include "power_state.h"
+#include "eventmanager.h"
 
 static int pp_early_init(void *handle)
 {
@@ -177,11 +179,31 @@ static int pp_set_powergating_state(void *handle,
 
 static int pp_suspend(void *handle)
 {
+	struct pp_instance *pp_handle;
+	struct pp_eventmgr *eventmgr;
+	struct pem_event_data event_data = { {0} };
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+	eventmgr = pp_handle->eventmgr;
+	pem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);
 	return 0;
 }
 
 static int pp_resume(void *handle)
 {
+	struct pp_instance *pp_handle;
+	struct pp_eventmgr *eventmgr;
+	struct pem_event_data event_data = { {0} };
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+	eventmgr = pp_handle->eventmgr;
+	pem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);
 	return 0;
 }
 
@@ -215,45 +237,198 @@ static int pp_dpm_fw_loading_complete(void *handle)
 static int pp_dpm_force_performance_level(void *handle,
 					enum amd_dpm_forced_level level)
 {
+	struct pp_instance *pp_handle;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	    hwmgr->hwmgr_func->force_dpm_level == NULL)
+		return -EINVAL;
+
+	hwmgr->hwmgr_func->force_dpm_level(hwmgr, level);
+
 	return 0;
 }
+
 static enum amd_dpm_forced_level pp_dpm_get_performance_level(
 								void *handle)
 {
-	return 0;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL)
+		return -EINVAL;
+
+	return (((struct pp_instance *)handle)->hwmgr->dpm_level);
 }
+
 static int pp_dpm_get_sclk(void *handle, bool low)
 {
-	return 0;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	    hwmgr->hwmgr_func->get_sclk == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_sclk(hwmgr, low);
 }
+
 static int pp_dpm_get_mclk(void *handle, bool low)
 {
-	return 0;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	    hwmgr->hwmgr_func->get_mclk == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->get_mclk(hwmgr, low);
 }
+
 static int pp_dpm_powergate_vce(void *handle, bool gate)
 {
-	return 0;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	    hwmgr->hwmgr_func->powergate_vce == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);
 }
+
 static int pp_dpm_powergate_uvd(void *handle, bool gate)
 {
-	return 0;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	    hwmgr->hwmgr_func->powergate_uvd == NULL)
+		return -EINVAL;
+
+	return hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);
+}
+
+static enum PP_StateUILabel power_state_convert(enum amd_pm_state_type  state)
+{
+	switch (state) {
+	case POWER_STATE_TYPE_BATTERY:
+		return PP_StateUILabel_Battery;
+	case POWER_STATE_TYPE_BALANCED:
+		return PP_StateUILabel_Balanced;
+	case POWER_STATE_TYPE_PERFORMANCE:
+		return PP_StateUILabel_Performance;
+	default:
+		return PP_StateUILabel_None;
+	}
 }
 
 int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input, void *output)
 {
-	return 0;
+	int ret = 0;
+	struct pp_instance *pp_handle;
+	struct pem_event_data data = { {0} };
+
+	pp_handle = (struct pp_instance *)handle;
+
+	if (pp_handle == NULL)
+		return -EINVAL;
+
+	switch (event_id) {
+	case AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE:
+		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
+		break;
+	case AMD_PP_EVENT_ENABLE_USER_STATE:
+	{
+		enum amd_pm_state_type  ps;
+
+		if (input == NULL)
+			return -EINVAL;
+		ps = *(unsigned long *)input;
+
+		data.requested_ui_label = power_state_convert(ps);
+		ret = pem_handle_event(pp_handle->eventmgr, event_id, &data);
+	}
+	break;
+	default:
+		break;
+	}
+	return ret;
 }
+
 enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
 {
-	return 0;
+	struct pp_hwmgr *hwmgr;
+	struct pp_power_state *state;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->current_ps == NULL)
+		return -EINVAL;
+
+	state = hwmgr->current_ps;
+
+	switch (state->classification.ui_label) {
+	case PP_StateUILabel_Battery:
+		return POWER_STATE_TYPE_BATTERY;
+	case PP_StateUILabel_Balanced:
+		return POWER_STATE_TYPE_BALANCED;
+	case PP_StateUILabel_Performance:
+		return POWER_STATE_TYPE_PERFORMANCE;
+	default:
+		return POWER_STATE_TYPE_DEFAULT;
+	}
 }
+
 static void
 pp_debugfs_print_current_performance_level(void *handle,
 					       struct seq_file *m)
 {
-	return;
+	struct pp_hwmgr  *hwmgr;
+
+	if (handle == NULL)
+		return;
+
+	hwmgr = ((struct pp_instance *)handle)->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->hwmgr_func == NULL ||
+	  hwmgr->hwmgr_func->print_current_perforce_level == NULL)
+		return;
+
+	hwmgr->hwmgr_func->print_current_perforce_level(hwmgr, m);
 }
 
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = NULL,
 	.load_firmware = pp_dpm_load_fw,

commit e92a0370575ab985bcdc3ba1520bf946521d62f1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Sep 23 15:14:54 2015 +0800

    drm/amd/powerplay: add event manager sub-component
    
    The event manager handles power related driver events.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Reviewed-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 88fdb04eebb9..1964a2add63f 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -52,6 +52,7 @@ static int pp_sw_init(void *handle)
 		return -EINVAL;
 
 	ret = hwmgr->pptable_func->pptable_init(hwmgr);
+
 	if (ret == 0)
 		ret = hwmgr->hwmgr_func->backend_init(hwmgr);
 
@@ -81,6 +82,7 @@ static int pp_hw_init(void *handle)
 {
 	struct pp_instance *pp_handle;
 	struct pp_smumgr *smumgr;
+	struct pp_eventmgr *eventmgr;
 	int ret = 0;
 
 	if (handle == NULL)
@@ -106,8 +108,14 @@ static int pp_hw_init(void *handle)
 		smumgr->smumgr_funcs->smu_fini(smumgr);
 		return ret;
 	}
+
 	hw_init_power_state_table(pp_handle->hwmgr);
+	eventmgr = pp_handle->eventmgr;
 
+	if (eventmgr == NULL || eventmgr->pp_eventmgr_init == NULL)
+		return -EINVAL;
+
+	ret = eventmgr->pp_eventmgr_init(eventmgr);
 	return 0;
 }
 
@@ -115,11 +123,17 @@ static int pp_hw_fini(void *handle)
 {
 	struct pp_instance *pp_handle;
 	struct pp_smumgr *smumgr;
+	struct pp_eventmgr *eventmgr;
 
 	if (handle == NULL)
 		return -EINVAL;
 
 	pp_handle = (struct pp_instance *)handle;
+	eventmgr = pp_handle->eventmgr;
+
+	if (eventmgr != NULL || eventmgr->pp_eventmgr_fini != NULL)
+		eventmgr->pp_eventmgr_fini(eventmgr);
+
 	smumgr = pp_handle->smu_mgr;
 
 	if (smumgr != NULL || smumgr->smumgr_funcs != NULL ||
@@ -273,9 +287,15 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 	if (ret)
 		goto fail_hwmgr;
 
+	ret = eventmgr_init(handle);
+	if (ret)
+		goto fail_eventmgr;
+
 	amd_pp->pp_handle = handle;
 	return 0;
 
+fail_eventmgr:
+	hwmgr_fini(handle->hwmgr);
 fail_hwmgr:
 	smum_fini(handle->smu_mgr);
 fail_smum:
@@ -286,9 +306,12 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 static int amd_pp_instance_fini(void *handle)
 {
 	struct pp_instance *instance = (struct pp_instance *)handle;
+
 	if (instance == NULL)
 		return -EINVAL;
 
+	eventmgr_fini(instance->eventmgr);
+
 	hwmgr_fini(instance->hwmgr);
 
 	smum_fini(instance->smu_mgr);

commit 3bace359149391c6547cefe3bf729f365bcf3ef6
Author: Jammy Zhou <Jammy.Zhou@amd.com>
Date:   Tue Jul 21 21:18:15 2015 +0800

    drm/amd/powerplay: add hardware manager sub-component
    
    The hwmgr handles all hardware related calls, including clock/power
    gating control, DPM, read and parse PPTable, etc.
    
    v5: squash in fixes
    v4: implement acpi's atcs function use cgs interface
    v3: fix code style error and add big-endian mode support.
    v2: use cgs interface directly in hwmgr sub-module
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index ea78525e26a5..88fdb04eebb9 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -35,12 +35,46 @@ static int pp_early_init(void *handle)
 
 static int pp_sw_init(void *handle)
 {
-	return 0;
+	struct pp_instance *pp_handle;
+	struct pp_hwmgr  *hwmgr;
+	int ret = 0;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr == NULL || hwmgr->pptable_func == NULL ||
+	    hwmgr->hwmgr_func == NULL ||
+	    hwmgr->pptable_func->pptable_init == NULL ||
+	    hwmgr->hwmgr_func->backend_init == NULL)
+		return -EINVAL;
+
+	ret = hwmgr->pptable_func->pptable_init(hwmgr);
+	if (ret == 0)
+		ret = hwmgr->hwmgr_func->backend_init(hwmgr);
+
+	return ret;
 }
 
 static int pp_sw_fini(void *handle)
 {
-	return 0;
+	struct pp_instance *pp_handle;
+	struct pp_hwmgr  *hwmgr;
+	int ret = 0;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+	hwmgr = pp_handle->hwmgr;
+
+	if (hwmgr != NULL || hwmgr->hwmgr_func != NULL ||
+	    hwmgr->hwmgr_func->backend_fini != NULL)
+		ret = hwmgr->hwmgr_func->backend_fini(hwmgr);
+
+	return ret;
 }
 
 static int pp_hw_init(void *handle)
@@ -72,6 +106,8 @@ static int pp_hw_init(void *handle)
 		smumgr->smumgr_funcs->smu_fini(smumgr);
 		return ret;
 	}
+	hw_init_power_state_table(pp_handle->hwmgr);
+
 	return 0;
 }
 
@@ -203,6 +239,7 @@ pp_debugfs_print_current_performance_level(void *handle,
 {
 	return;
 }
+
 const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.get_temperature = NULL,
 	.load_firmware = pp_dpm_load_fw,
@@ -230,10 +267,20 @@ static int amd_pp_instance_init(struct amd_pp_init *pp_init,
 
 	ret = smum_init(pp_init, handle);
 	if (ret)
-		return ret;
+		goto fail_smum;
+
+	ret = hwmgr_init(pp_init, handle);
+	if (ret)
+		goto fail_hwmgr;
 
 	amd_pp->pp_handle = handle;
 	return 0;
+
+fail_hwmgr:
+	smum_fini(handle->smu_mgr);
+fail_smum:
+	kfree(handle);
+	return ret;
 }
 
 static int amd_pp_instance_fini(void *handle)
@@ -242,6 +289,8 @@ static int amd_pp_instance_fini(void *handle)
 	if (instance == NULL)
 		return -EINVAL;
 
+	hwmgr_fini(instance->hwmgr);
+
 	smum_fini(instance->smu_mgr);
 
 	kfree(handle);

commit ac885b3a20e60f568fe856008d038d7bd01394e2
Author: Jammy Zhou <Jammy.Zhou@amd.com>
Date:   Tue Jul 21 17:43:02 2015 +0800

    drm/amd/powerplay: add SMU manager sub-component
    
    The SMUMGR is one sub-component of powerplay for SMU firmware support.
    The SMU handles firmware loading for other IP blocks (GFX, SDMA, etc.)
    on VI parts.  The adds the core powerplay infrastructure to handle that.
    
    v3: direct use printk in powerplay module.
    v2: direct use cgs_read/write_register functions in smu-modules
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
index 39ffc5d4e49f..ea78525e26a5 100644
--- a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -23,8 +23,10 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/gfp.h>
+#include <linux/slab.h>
 #include "amd_shared.h"
 #include "amd_powerplay.h"
+#include "pp_instance.h"
 
 static int pp_early_init(void *handle)
 {
@@ -43,11 +45,51 @@ static int pp_sw_fini(void *handle)
 
 static int pp_hw_init(void *handle)
 {
+	struct pp_instance *pp_handle;
+	struct pp_smumgr *smumgr;
+	int ret = 0;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+	smumgr = pp_handle->smu_mgr;
+
+	if (smumgr == NULL || smumgr->smumgr_funcs == NULL ||
+		smumgr->smumgr_funcs->smu_init == NULL ||
+		smumgr->smumgr_funcs->start_smu == NULL)
+		return -EINVAL;
+
+	ret = smumgr->smumgr_funcs->smu_init(smumgr);
+	if (ret) {
+		printk(KERN_ERR "[ powerplay ] smc initialization failed\n");
+		return ret;
+	}
+
+	ret = smumgr->smumgr_funcs->start_smu(smumgr);
+	if (ret) {
+		printk(KERN_ERR "[ powerplay ] smc start failed\n");
+		smumgr->smumgr_funcs->smu_fini(smumgr);
+		return ret;
+	}
 	return 0;
 }
 
 static int pp_hw_fini(void *handle)
 {
+	struct pp_instance *pp_handle;
+	struct pp_smumgr *smumgr;
+
+	if (handle == NULL)
+		return -EINVAL;
+
+	pp_handle = (struct pp_instance *)handle;
+	smumgr = pp_handle->smu_mgr;
+
+	if (smumgr != NULL || smumgr->smumgr_funcs != NULL ||
+		smumgr->smumgr_funcs->smu_fini != NULL)
+		smumgr->smumgr_funcs->smu_fini(smumgr);
+
 	return 0;
 }
 
@@ -176,12 +218,49 @@ const struct amd_powerplay_funcs pp_dpm_funcs = {
 	.print_current_performance_level = pp_debugfs_print_current_performance_level,
 };
 
+static int amd_pp_instance_init(struct amd_pp_init *pp_init,
+				struct amd_powerplay *amd_pp)
+{
+	int ret;
+	struct pp_instance *handle;
+
+	handle = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);
+	if (handle == NULL)
+		return -ENOMEM;
+
+	ret = smum_init(pp_init, handle);
+	if (ret)
+		return ret;
+
+	amd_pp->pp_handle = handle;
+	return 0;
+}
+
+static int amd_pp_instance_fini(void *handle)
+{
+	struct pp_instance *instance = (struct pp_instance *)handle;
+	if (instance == NULL)
+		return -EINVAL;
+
+	smum_fini(instance->smu_mgr);
+
+	kfree(handle);
+	return 0;
+}
+
 int amd_powerplay_init(struct amd_pp_init *pp_init,
 		       struct amd_powerplay *amd_pp)
 {
+	int ret;
+
 	if (pp_init == NULL || amd_pp == NULL)
 		return -EINVAL;
 
+	ret = amd_pp_instance_init(pp_init, amd_pp);
+
+	if (ret)
+		return ret;
+
 	amd_pp->ip_funcs = &pp_ip_funcs;
 	amd_pp->pp_funcs = &pp_dpm_funcs;
 
@@ -190,5 +269,7 @@ int amd_powerplay_init(struct amd_pp_init *pp_init,
 
 int amd_powerplay_fini(void *handle)
 {
+	amd_pp_instance_fini(handle);
+
 	return 0;
 }

commit 1f7371b2a5faf139465f0af386cccbb54b832534
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Dec 2 17:46:21 2015 -0500

    drm/amd/powerplay: add basic powerplay framework
    
    amdgpu_pp_ip_funcs is introduced to handle the two code paths,
    the legacy one and the new powerplay implementation.
    
    CONFIG_DRM_AMD_POWERPLAY kernel configuration option is
    introduced for the powerplay component.
    
    v4: squash in fixes
    v3: register debugfs file when powerplay module enable
    v2: add amdgpu_ucode_init_bo in hw init when amdgpu_powerplay enable.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Jammy Zhou <Jammy.Zhou@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amd_powerplay.c b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
new file mode 100644
index 000000000000..39ffc5d4e49f
--- /dev/null
+++ b/drivers/gpu/drm/amd/powerplay/amd_powerplay.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/gfp.h>
+#include "amd_shared.h"
+#include "amd_powerplay.h"
+
+static int pp_early_init(void *handle)
+{
+	return 0;
+}
+
+static int pp_sw_init(void *handle)
+{
+	return 0;
+}
+
+static int pp_sw_fini(void *handle)
+{
+	return 0;
+}
+
+static int pp_hw_init(void *handle)
+{
+	return 0;
+}
+
+static int pp_hw_fini(void *handle)
+{
+	return 0;
+}
+
+static bool pp_is_idle(void *handle)
+{
+	return 0;
+}
+
+static int pp_wait_for_idle(void *handle)
+{
+	return 0;
+}
+
+static int pp_sw_reset(void *handle)
+{
+	return 0;
+}
+
+static void pp_print_status(void *handle)
+{
+
+}
+
+static int pp_set_clockgating_state(void *handle,
+				    enum amd_clockgating_state state)
+{
+	return 0;
+}
+
+static int pp_set_powergating_state(void *handle,
+				    enum amd_powergating_state state)
+{
+	return 0;
+}
+
+static int pp_suspend(void *handle)
+{
+	return 0;
+}
+
+static int pp_resume(void *handle)
+{
+	return 0;
+}
+
+const struct amd_ip_funcs pp_ip_funcs = {
+	.early_init = pp_early_init,
+	.late_init = NULL,
+	.sw_init = pp_sw_init,
+	.sw_fini = pp_sw_fini,
+	.hw_init = pp_hw_init,
+	.hw_fini = pp_hw_fini,
+	.suspend = pp_suspend,
+	.resume = pp_resume,
+	.is_idle = pp_is_idle,
+	.wait_for_idle = pp_wait_for_idle,
+	.soft_reset = pp_sw_reset,
+	.print_status = pp_print_status,
+	.set_clockgating_state = pp_set_clockgating_state,
+	.set_powergating_state = pp_set_powergating_state,
+};
+
+static int pp_dpm_load_fw(void *handle)
+{
+	return 0;
+}
+
+static int pp_dpm_fw_loading_complete(void *handle)
+{
+	return 0;
+}
+
+static int pp_dpm_force_performance_level(void *handle,
+					enum amd_dpm_forced_level level)
+{
+	return 0;
+}
+static enum amd_dpm_forced_level pp_dpm_get_performance_level(
+								void *handle)
+{
+	return 0;
+}
+static int pp_dpm_get_sclk(void *handle, bool low)
+{
+	return 0;
+}
+static int pp_dpm_get_mclk(void *handle, bool low)
+{
+	return 0;
+}
+static int pp_dpm_powergate_vce(void *handle, bool gate)
+{
+	return 0;
+}
+static int pp_dpm_powergate_uvd(void *handle, bool gate)
+{
+	return 0;
+}
+
+int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id, void *input, void *output)
+{
+	return 0;
+}
+enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)
+{
+	return 0;
+}
+static void
+pp_debugfs_print_current_performance_level(void *handle,
+					       struct seq_file *m)
+{
+	return;
+}
+const struct amd_powerplay_funcs pp_dpm_funcs = {
+	.get_temperature = NULL,
+	.load_firmware = pp_dpm_load_fw,
+	.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,
+	.force_performance_level = pp_dpm_force_performance_level,
+	.get_performance_level = pp_dpm_get_performance_level,
+	.get_current_power_state = pp_dpm_get_current_power_state,
+	.get_sclk = pp_dpm_get_sclk,
+	.get_mclk = pp_dpm_get_mclk,
+	.powergate_vce = pp_dpm_powergate_vce,
+	.powergate_uvd = pp_dpm_powergate_uvd,
+	.dispatch_tasks = pp_dpm_dispatch_tasks,
+	.print_current_performance_level = pp_debugfs_print_current_performance_level,
+};
+
+int amd_powerplay_init(struct amd_pp_init *pp_init,
+		       struct amd_powerplay *amd_pp)
+{
+	if (pp_init == NULL || amd_pp == NULL)
+		return -EINVAL;
+
+	amd_pp->ip_funcs = &pp_ip_funcs;
+	amd_pp->pp_funcs = &pp_dpm_funcs;
+
+	return 0;
+}
+
+int amd_powerplay_fini(void *handle)
+{
+	return 0;
+}
