commit a0ec225633d9f681e393a1827f29f02c837deb84
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Mar 27 10:48:20 2020 +0800

    drm/amd/powerplay: unified interfaces for message issuing and response checking
    
    This can avoid potential race condition between them.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 294e48e900dc..76d4f12ceedf 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -612,16 +612,19 @@ static int smu8_download_pptable_settings(struct pp_hwmgr *hwmgr, void **table)
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrHi,
-				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr),
+				NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrLo,
-				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr),
+				NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
-				smu8_smu->toc_entry_clock_table);
+				smu8_smu->toc_entry_clock_table,
+				NULL);
 
-	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToDram);
+	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToDram, NULL);
 
 	return 0;
 }
@@ -639,16 +642,19 @@ static int smu8_upload_pptable_settings(struct pp_hwmgr *hwmgr)
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrHi,
-				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr),
+				NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrLo,
-				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr),
+				NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
-				smu8_smu->toc_entry_clock_table);
+				smu8_smu->toc_entry_clock_table,
+				NULL);
 
-	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToSmu);
+	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToSmu, NULL);
 
 	return 0;
 }
@@ -673,23 +679,28 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_DriverDramAddrHi,
-					upper_32_bits(smu8_smu->toc_buffer.mc_addr));
+					upper_32_bits(smu8_smu->toc_buffer.mc_addr),
+					NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_DriverDramAddrLo,
-					lower_32_bits(smu8_smu->toc_buffer.mc_addr));
+					lower_32_bits(smu8_smu->toc_buffer.mc_addr),
+					NULL);
 
-	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_InitJobs);
+	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_InitJobs, NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_ExecuteJob,
-					smu8_smu->toc_entry_aram);
+					smu8_smu->toc_entry_aram,
+					NULL);
 	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
-				smu8_smu->toc_entry_power_profiling_index);
+				smu8_smu->toc_entry_power_profiling_index,
+				NULL);
 
 	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_ExecuteJob,
-					smu8_smu->toc_entry_initialize_index);
+					smu8_smu->toc_entry_initialize_index,
+					NULL);
 
 	fw_to_check = UCODE_ID_RLC_G_MASK |
 			UCODE_ID_SDMA0_MASK |
@@ -860,11 +871,13 @@ static bool smu8_dpm_check_smu_features(struct pp_hwmgr *hwmgr,
 				unsigned long check_feature)
 {
 	int result;
-	unsigned long features;
+	uint32_t features;
 
-	result = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetFeatureStatus, 0);
+	result = smum_send_msg_to_smc_with_parameter(hwmgr,
+				PPSMC_MSG_GetFeatureStatus,
+				0,
+				&features);
 	if (result == 0) {
-		features = smum_get_argument(hwmgr);
 		if (features & check_feature)
 			return true;
 	}

commit 92e0070e02e885ddc4f590dbc8c7d1ff3cc5fb87
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Mar 26 16:47:45 2020 +0800

    drm/amd/powerplay: avoid calling SMU8 specific SMU message implemention
    
    Prepare for coming lock protection for SMU message issuing.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 7dca04a89217..294e48e900dc 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -610,18 +610,18 @@ static int smu8_download_pptable_settings(struct pp_hwmgr *hwmgr, void **table)
 
 	*table = (struct SMU8_Fusion_ClkTable *)smu8_smu->scratch_buffer[i].kaddr;
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrHi,
 				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrLo,
 				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
+	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
 				smu8_smu->toc_entry_clock_table);
 
-	smu8_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToDram);
+	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToDram);
 
 	return 0;
 }
@@ -637,18 +637,18 @@ static int smu8_upload_pptable_settings(struct pp_hwmgr *hwmgr)
 			break;
 	}
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrHi,
 				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 				PPSMC_MSG_SetClkTableAddrLo,
 				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
+	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
 				smu8_smu->toc_entry_clock_table);
 
-	smu8_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToSmu);
+	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToSmu);
 
 	return 0;
 }
@@ -671,23 +671,23 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 
 	smu8_write_smc_sram_dword(hwmgr, smc_address, 0, smc_address+4);
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_DriverDramAddrHi,
 					upper_32_bits(smu8_smu->toc_buffer.mc_addr));
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_DriverDramAddrLo,
 					lower_32_bits(smu8_smu->toc_buffer.mc_addr));
 
-	smu8_send_msg_to_smc(hwmgr, PPSMC_MSG_InitJobs);
+	smum_send_msg_to_smc(hwmgr, PPSMC_MSG_InitJobs);
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_ExecuteJob,
 					smu8_smu->toc_entry_aram);
-	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
+	smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
 				smu8_smu->toc_entry_power_profiling_index);
 
-	smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smum_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_ExecuteJob,
 					smu8_smu->toc_entry_initialize_index);
 
@@ -862,7 +862,7 @@ static bool smu8_dpm_check_smu_features(struct pp_hwmgr *hwmgr,
 	int result;
 	unsigned long features;
 
-	result = smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetFeatureStatus, 0);
+	result = smum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetFeatureStatus, 0);
 	if (result == 0) {
 		features = smum_get_argument(hwmgr);
 		if (features & check_feature)

commit 36e255dd8ffd0aa1a73874740180870519aef37c
Author: Austin Kim <austindh.kim@gmail.com>
Date:   Wed Oct 2 14:17:59 2019 +0900

    drm/amdgpu: Drop unused variable and statement
    
    Even though 'smu8_smu' is declared, it is not used after below statement.
    
       smu8_smu = hwmgr->smu_backend;
    
    So 'unused variable' could be safely removed
    to stop warning message as below:
    
       drivers/gpu/drm/amd/amdgpu/../powerplay/smumgr/smu8_smumgr.c:180:22:
       warning: variable ‘smu8_smu’ set but not used
       [-Wunused-but-set-variable]
    
       struct smu8_smumgr *smu8_smu;
                 ^
    Signed-off-by: Austin Kim <austindh.kim@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 4728aa23a818..7dca04a89217 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -177,12 +177,10 @@ static int smu8_load_mec_firmware(struct pp_hwmgr *hwmgr)
 	uint32_t tmp;
 	int ret = 0;
 	struct cgs_firmware_info info = {0};
-	struct smu8_smumgr *smu8_smu;
 
 	if (hwmgr == NULL || hwmgr->device == NULL)
 		return -EINVAL;
 
-	smu8_smu = hwmgr->smu_backend;
 	ret = cgs_get_firmware_info(hwmgr->device,
 						CGS_UCODE_ID_CP_MEC, &info);
 

commit 9c9284f9cee9052da4cad575da8dc5f2bbb31065
Author: Austin Kim <austindh.kim@gmail.com>
Date:   Fri Aug 30 17:07:04 2019 +0900

    drm/amdgpu: Move null pointer dereference check
    
    Null pointer dereference check should have been checked,
    ahead of below routine.
            struct amdgpu_device *adev = hwmgr->adev;
    
    With this commit, it could avoid potential NULL dereference.
    
    Signed-off-by: Austin Kim <austindh.kim@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 8189fe402c6d..4728aa23a818 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -722,16 +722,17 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 
 static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 {
-	struct amdgpu_device *adev = hwmgr->adev;
+	struct amdgpu_device *adev;
 
 	uint32_t index = SMN_MP1_SRAM_START_ADDR +
 			 SMU8_FIRMWARE_HEADER_LOCATION +
 			 offsetof(struct SMU8_Firmware_Header, Version);
 
-
 	if (hwmgr == NULL || hwmgr->device == NULL)
 		return -EINVAL;
 
+	adev = hwmgr->adev;
+
 	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
 	hwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);
 	pr_info("smu version %02d.%02d.%02d\n",

commit 82973e078b9dcb07a1379f4e75a4f65d2c793d49
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Fri Jun 14 12:06:35 2019 +0800

    drm/amd/powerplay: detect version of smu backend (v2)
    
    Print the backend type.
    
    v2: whitespace fixes (Alex)
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index e2787e14a500..8189fe402c6d 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -881,6 +881,7 @@ static bool smu8_is_dpm_running(struct pp_hwmgr *hwmgr)
 }
 
 const struct pp_smumgr_func smu8_smu_funcs = {
+	.name = "smu8_smu",
 	.smu_init = smu8_smu_init,
 	.smu_fini = smu8_smu_fini,
 	.start_smu = smu8_start_smu,

commit 36b486bc682114a2f1001cbf1a87f21ae381bfc1
Author: Shirish S <shirish.s@amd.com>
Date:   Mon Nov 12 12:13:24 2018 +0530

    drm/amdgpu: log smu version
    
    This patch prints the version of SMU firmware.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by:  Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index b6e8c89ca03a..e2787e14a500 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -734,6 +734,10 @@ static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 
 	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
 	hwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);
+	pr_info("smu version %02d.%02d.%02d\n",
+		((hwmgr->smu_version >> 16) & 0xFF),
+		((hwmgr->smu_version >> 8) & 0xFF),
+		(hwmgr->smu_version & 0xFF));
 	adev->pm.fw_version = hwmgr->smu_version >> 8;
 
 	return smu8_request_smu_load_fw(hwmgr);

commit 2bf011c861b75026d948b199659087ac9bdff026
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Mon Nov 12 14:48:12 2018 +0530

    drm/amdgpu: refactor smu8_send_msg_to_smc and WARN_ON time out
    
    This patch refactors smu8_send_msg_to_smc_with_parameter() to include
    smu8_send_msg_to_smc_async() so that all the messages sent to SMU can be
    profiled and appropriately reported if they fail.
    
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by:  Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 09b844ec3eab..b6e8c89ca03a 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -24,6 +24,7 @@
 #include <linux/delay.h>
 #include <linux/gfp.h>
 #include <linux/kernel.h>
+#include <linux/ktime.h>
 #include <linux/slab.h>
 #include <linux/types.h>
 
@@ -61,9 +62,13 @@ static uint32_t smu8_get_argument(struct pp_hwmgr *hwmgr)
 					mmSMU_MP1_SRBM2P_ARG_0);
 }
 
-static int smu8_send_msg_to_smc_async(struct pp_hwmgr *hwmgr, uint16_t msg)
+/* Send a message to the SMC, and wait for its response.*/
+static int smu8_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,
+					    uint16_t msg, uint32_t parameter)
 {
 	int result = 0;
+	ktime_t t_start;
+	s64 elapsed_us;
 
 	if (hwmgr == NULL || hwmgr->device == NULL)
 		return -EINVAL;
@@ -74,28 +79,31 @@ static int smu8_send_msg_to_smc_async(struct pp_hwmgr *hwmgr, uint16_t msg)
 		/* Read the last message to SMU, to report actual cause */
 		uint32_t val = cgs_read_register(hwmgr->device,
 						 mmSMU_MP1_SRBM2P_MSG_0);
-		pr_err("smu8_send_msg_to_smc_async (0x%04x) failed\n", msg);
-		pr_err("SMU still servicing msg (0x%04x)\n", val);
+		pr_err("%s(0x%04x) aborted; SMU still servicing msg (0x%04x)\n",
+			__func__, msg, val);
 		return result;
 	}
+	t_start = ktime_get();
+
+	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_ARG_0, parameter);
 
 	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_RESP_0, 0);
 	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_MSG_0, msg);
 
-	return 0;
+	result = PHM_WAIT_FIELD_UNEQUAL(hwmgr,
+					SMU_MP1_SRBM2P_RESP_0, CONTENT, 0);
+
+	elapsed_us = ktime_us_delta(ktime_get(), t_start);
+
+	WARN(result, "%s(0x%04x, %#x) timed out after %lld us\n",
+			__func__, msg, parameter, elapsed_us);
+
+	return result;
 }
 
-/* Send a message to the SMC, and wait for its response.*/
 static int smu8_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)
 {
-	int result = 0;
-
-	result = smu8_send_msg_to_smc_async(hwmgr, msg);
-	if (result != 0)
-		return result;
-
-	return PHM_WAIT_FIELD_UNEQUAL(hwmgr,
-					SMU_MP1_SRBM2P_RESP_0, CONTENT, 0);
+	return smu8_send_msg_to_smc_with_parameter(hwmgr, msg, 0);
 }
 
 static int smu8_set_smc_sram_address(struct pp_hwmgr *hwmgr,
@@ -135,17 +143,6 @@ static int smu8_write_smc_sram_dword(struct pp_hwmgr *hwmgr,
 	return result;
 }
 
-static int smu8_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,
-					  uint16_t msg, uint32_t parameter)
-{
-	if (hwmgr == NULL || hwmgr->device == NULL)
-		return -EINVAL;
-
-	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_ARG_0, parameter);
-
-	return smu8_send_msg_to_smc(hwmgr, msg);
-}
-
 static int smu8_check_fw_load_finish(struct pp_hwmgr *hwmgr,
 				   uint32_t firmware)
 {

commit cb899a615be6c42e186e0e71862ebbd5a5c15533
Author: Shirish S <shirish.s@amd.com>
Date:   Fri Oct 26 02:38:58 2018 +0530

    drm/amdgpu: fix reporting of failed msg sent to SMU (v2)
    
    Currently send_msg_to_smc_async() only report which message
    failed, but the actual failing message is the previous one,
    which SMU is unable to service.
    
    This patch reads the contents of register where the SMU is stuck
    and report appropriately.
    
    v2: fix the build (Alex)
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index f836d30fdd44..09b844ec3eab 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -71,7 +71,11 @@ static int smu8_send_msg_to_smc_async(struct pp_hwmgr *hwmgr, uint16_t msg)
 	result = PHM_WAIT_FIELD_UNEQUAL(hwmgr,
 					SMU_MP1_SRBM2P_RESP_0, CONTENT, 0);
 	if (result != 0) {
+		/* Read the last message to SMU, to report actual cause */
+		uint32_t val = cgs_read_register(hwmgr->device,
+						 mmSMU_MP1_SRBM2P_MSG_0);
 		pr_err("smu8_send_msg_to_smc_async (0x%04x) failed\n", msg);
+		pr_err("SMU still servicing msg (0x%04x)\n", val);
 		return result;
 	}
 

commit 7a3e0bb2a57428456948614d8fe94930832903b6
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Oct 10 20:41:32 2018 +0800

    drm/amdgpu: Load fw between hw_init/resume_phase1 and phase2
    
    Extract the function of fw loading out of powerplay.
    Do fw loading between hw_init/resuem_phase1 and phase2
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index abbf2f285aab..f836d30fdd44 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -661,9 +661,6 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 	uint32_t fw_to_check = 0;
 	int ret;
 
-	if (!hwmgr->reload_fw)
-		return 0;
-
 	amdgpu_ucode_init_bo(hwmgr->adev);
 
 	smu8_smu_populate_firmware_entries(hwmgr);
@@ -719,8 +716,6 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 		return ret;
 	}
 
-	hwmgr->reload_fw = 0;
-
 	return 0;
 }
 

commit 744a522794bdc64391039177153ef973cbff1297
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sat Sep 29 15:42:52 2018 +0800

    drm/amd/pp: Allocate ucode bo in request_smu_load_fw
    
    ucode bo is needed by request_smu_load_fw,
    the request_smu_load_fw maybe called by gfx/sdma
    before smu hw init.
    so move amdgpu_ucode_bo_init to request_smu_lowd_fw
    from smu hw init.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 7b3b66d2f047..abbf2f285aab 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -664,6 +664,8 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 	if (!hwmgr->reload_fw)
 		return 0;
 
+	amdgpu_ucode_init_bo(hwmgr->adev);
+
 	smu8_smu_populate_firmware_entries(hwmgr);
 
 	smu8_smu_construct_toc(hwmgr);

commit 5e161e5442a8a209404542c91eb889487b1239f4
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Sat Sep 29 13:54:33 2018 +0800

    drm/amd/pp: Refine smu7/8 request_smu_load_fw callback function
    
    The request_smu_load_fw of VI is used to load gfx/sdma
    ip's firmware.
    
    Check whether the gfx/sdma firmware have been loaded successfully
    in this callback function.
    if failed, driver can exit to avoid gpu hard hung.
    if successful, clean the flag reload_fw to avoid duplicated fw load.
    when suspend/resume, driver need to reload fw.
    so in suspend, reset the reload_fw flag to true to enable load fw when
    resume.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index a74c5be1ec18..7b3b66d2f047 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -658,11 +658,11 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 {
 	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
 	uint32_t smc_address;
+	uint32_t fw_to_check = 0;
+	int ret;
 
-	if (!hwmgr->reload_fw) {
-		pr_info("skip reloading...\n");
+	if (!hwmgr->reload_fw)
 		return 0;
-	}
 
 	smu8_smu_populate_firmware_entries(hwmgr);
 
@@ -689,28 +689,9 @@ static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
 	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
 				smu8_smu->toc_entry_power_profiling_index);
 
-	return smu8_send_msg_to_smc_with_parameter(hwmgr,
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
 					PPSMC_MSG_ExecuteJob,
 					smu8_smu->toc_entry_initialize_index);
-}
-
-static int smu8_start_smu(struct pp_hwmgr *hwmgr)
-{
-	int ret = 0;
-	uint32_t fw_to_check = 0;
-	struct amdgpu_device *adev = hwmgr->adev;
-
-	uint32_t index = SMN_MP1_SRAM_START_ADDR +
-			 SMU8_FIRMWARE_HEADER_LOCATION +
-			 offsetof(struct SMU8_Firmware_Header, Version);
-
-
-	if (hwmgr == NULL || hwmgr->device == NULL)
-		return -EINVAL;
-
-	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
-	hwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);
-	adev->pm.fw_version = hwmgr->smu_version >> 8;
 
 	fw_to_check = UCODE_ID_RLC_G_MASK |
 			UCODE_ID_SDMA0_MASK |
@@ -724,8 +705,6 @@ static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 	if (hwmgr->chip_id == CHIP_STONEY)
 		fw_to_check &= ~(UCODE_ID_SDMA1_MASK | UCODE_ID_CP_MEC_JT2_MASK);
 
-	smu8_request_smu_load_fw(hwmgr);
-
 	ret = smu8_check_fw_load_finish(hwmgr, fw_to_check);
 	if (ret) {
 		pr_err("SMU firmware load failed\n");
@@ -733,10 +712,33 @@ static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 	}
 
 	ret = smu8_load_mec_firmware(hwmgr);
-	if (ret)
+	if (ret) {
 		pr_err("Mec Firmware load failed\n");
+		return ret;
+	}
 
-	return ret;
+	hwmgr->reload_fw = 0;
+
+	return 0;
+}
+
+static int smu8_start_smu(struct pp_hwmgr *hwmgr)
+{
+	struct amdgpu_device *adev = hwmgr->adev;
+
+	uint32_t index = SMN_MP1_SRAM_START_ADDR +
+			 SMU8_FIRMWARE_HEADER_LOCATION +
+			 offsetof(struct SMU8_Firmware_Header, Version);
+
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
+	hwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);
+	adev->pm.fw_version = hwmgr->smu_version >> 8;
+
+	return smu8_request_smu_load_fw(hwmgr);
 }
 
 static int smu8_smu_init(struct pp_hwmgr *hwmgr)

commit 19a86c08510f5edf64745e4c090e89ea105a14cf
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Sep 18 20:30:36 2018 +0800

    drm/amd/pp: Return error immediately if load firmware failed
    
    this can avoid hard hang and be useful for debug.
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index f7e3bc22bb93..a74c5be1ec18 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -724,11 +724,13 @@ static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 	if (hwmgr->chip_id == CHIP_STONEY)
 		fw_to_check &= ~(UCODE_ID_SDMA1_MASK | UCODE_ID_CP_MEC_JT2_MASK);
 
-	ret = smu8_request_smu_load_fw(hwmgr);
-	if (ret)
-		pr_err("SMU firmware load failed\n");
+	smu8_request_smu_load_fw(hwmgr);
 
-	smu8_check_fw_load_finish(hwmgr, fw_to_check);
+	ret = smu8_check_fw_load_finish(hwmgr, fw_to_check);
+	if (ret) {
+		pr_err("SMU firmware load failed\n");
+		return ret;
+	}
 
 	ret = smu8_load_mec_firmware(hwmgr);
 	if (ret)

commit 59f20f5a0c9767a8b66688b84e72a345b4dc1bc1
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jul 12 14:59:22 2018 -0500

    drm/amdgpu/pp: switch smu callback type for get_argument()
    
    return a uint32_t rather than an int to properly reflect
    what the function does.
    
    Reviewed-by: Rex Zhu <rezhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index c861d3023474..f7e3bc22bb93 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -52,10 +52,10 @@ static const enum smu8_scratch_entry firmware_list[] = {
 	SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G,
 };
 
-static int smu8_get_argument(struct pp_hwmgr *hwmgr)
+static uint32_t smu8_get_argument(struct pp_hwmgr *hwmgr)
 {
 	if (hwmgr == NULL || hwmgr->device == NULL)
-		return -EINVAL;
+		return 0;
 
 	return cgs_read_register(hwmgr->device,
 					mmSMU_MP1_SRBM2P_ARG_0);

commit 3f9ca14a1d5d566ecc23718c1782cd9fa3713fc1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Fri Mar 16 15:16:10 2018 +0800

    drm/amd/pp: Move functions to smu backend table for vega10
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 8c49704b81af..c861d3023474 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -52,7 +52,7 @@ static const enum smu8_scratch_entry firmware_list[] = {
 	SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G,
 };
 
-static int smu8_smum_get_argument(struct pp_hwmgr *hwmgr)
+static int smu8_get_argument(struct pp_hwmgr *hwmgr)
 {
 	if (hwmgr == NULL || hwmgr->device == NULL)
 		return -EINVAL;
@@ -881,7 +881,7 @@ const struct pp_smumgr_func smu8_smu_funcs = {
 	.check_fw_load_finish = smu8_check_fw_load_finish,
 	.request_smu_load_fw = NULL,
 	.request_smu_load_specific_fw = NULL,
-	.get_argument = smu8_smum_get_argument,
+	.get_argument = smu8_get_argument,
 	.send_msg_to_smc = smu8_send_msg_to_smc,
 	.send_msg_to_smc_with_parameter = smu8_send_msg_to_smc_with_parameter,
 	.download_pptable_settings = smu8_download_pptable_settings,

commit 59156faf810e05f5c5241f9a90e6d715d1185cd1
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Thu Mar 15 14:45:04 2018 +0800

    drm/amd/pp: Remove the cgs wrapper for notify smu version on APU
    
    Refine commit f49e9bac191b ("drm/amd/pp: Get and save Rv smu version")
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
index 480deb2ce448..8c49704b81af 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -698,7 +698,8 @@ static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 {
 	int ret = 0;
 	uint32_t fw_to_check = 0;
-	struct cgs_firmware_info info = {0};
+	struct amdgpu_device *adev = hwmgr->adev;
+
 	uint32_t index = SMN_MP1_SRAM_START_ADDR +
 			 SMU8_FIRMWARE_HEADER_LOCATION +
 			 offsetof(struct SMU8_Firmware_Header, Version);
@@ -709,8 +710,7 @@ static int smu8_start_smu(struct pp_hwmgr *hwmgr)
 
 	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
 	hwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);
-	info.version = hwmgr->smu_version >> 8;
-	cgs_get_firmware_info(hwmgr->device, CGS_UCODE_ID_SMU, &info);
+	adev->pm.fw_version = hwmgr->smu_version >> 8;
 
 	fw_to_check = UCODE_ID_RLC_G_MASK |
 			UCODE_ID_SDMA0_MASK |

commit 34e40f6338c730572874bc3d6fe330c7f2b63013
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Wed Mar 14 20:05:12 2018 +0800

    drm/amd/pp: Rename file name cz_* to smu8_*
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
new file mode 100644
index 000000000000..480deb2ce448
--- /dev/null
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/smu8_smumgr.c
@@ -0,0 +1,891 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/gfp.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "cgs_common.h"
+#include "smu/smu_8_0_d.h"
+#include "smu/smu_8_0_sh_mask.h"
+#include "smu8.h"
+#include "smu8_fusion.h"
+#include "smu8_smumgr.h"
+#include "cz_ppsmc.h"
+#include "smu_ucode_xfer_cz.h"
+#include "gca/gfx_8_0_d.h"
+#include "gca/gfx_8_0_sh_mask.h"
+#include "smumgr.h"
+
+#define SIZE_ALIGN_32(x)    (((x) + 31) / 32 * 32)
+
+static const enum smu8_scratch_entry firmware_list[] = {
+	SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA0,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA1,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2,
+	SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G,
+};
+
+static int smu8_smum_get_argument(struct pp_hwmgr *hwmgr)
+{
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	return cgs_read_register(hwmgr->device,
+					mmSMU_MP1_SRBM2P_ARG_0);
+}
+
+static int smu8_send_msg_to_smc_async(struct pp_hwmgr *hwmgr, uint16_t msg)
+{
+	int result = 0;
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	result = PHM_WAIT_FIELD_UNEQUAL(hwmgr,
+					SMU_MP1_SRBM2P_RESP_0, CONTENT, 0);
+	if (result != 0) {
+		pr_err("smu8_send_msg_to_smc_async (0x%04x) failed\n", msg);
+		return result;
+	}
+
+	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_RESP_0, 0);
+	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_MSG_0, msg);
+
+	return 0;
+}
+
+/* Send a message to the SMC, and wait for its response.*/
+static int smu8_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)
+{
+	int result = 0;
+
+	result = smu8_send_msg_to_smc_async(hwmgr, msg);
+	if (result != 0)
+		return result;
+
+	return PHM_WAIT_FIELD_UNEQUAL(hwmgr,
+					SMU_MP1_SRBM2P_RESP_0, CONTENT, 0);
+}
+
+static int smu8_set_smc_sram_address(struct pp_hwmgr *hwmgr,
+				     uint32_t smc_address, uint32_t limit)
+{
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	if (0 != (3 & smc_address)) {
+		pr_err("SMC address must be 4 byte aligned\n");
+		return -EINVAL;
+	}
+
+	if (limit <= (smc_address + 3)) {
+		pr_err("SMC address beyond the SMC RAM area\n");
+		return -EINVAL;
+	}
+
+	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX_0,
+				SMN_MP1_SRAM_START_ADDR + smc_address);
+
+	return 0;
+}
+
+static int smu8_write_smc_sram_dword(struct pp_hwmgr *hwmgr,
+		uint32_t smc_address, uint32_t value, uint32_t limit)
+{
+	int result;
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	result = smu8_set_smc_sram_address(hwmgr, smc_address, limit);
+	if (!result)
+		cgs_write_register(hwmgr->device, mmMP0PUB_IND_DATA_0, value);
+
+	return result;
+}
+
+static int smu8_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,
+					  uint16_t msg, uint32_t parameter)
+{
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	cgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_ARG_0, parameter);
+
+	return smu8_send_msg_to_smc(hwmgr, msg);
+}
+
+static int smu8_check_fw_load_finish(struct pp_hwmgr *hwmgr,
+				   uint32_t firmware)
+{
+	int i;
+	uint32_t index = SMN_MP1_SRAM_START_ADDR +
+			 SMU8_FIRMWARE_HEADER_LOCATION +
+			 offsetof(struct SMU8_Firmware_Header, UcodeLoadStatus);
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
+
+	for (i = 0; i < hwmgr->usec_timeout; i++) {
+		if (firmware ==
+			(cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA) & firmware))
+			break;
+		udelay(1);
+	}
+
+	if (i >= hwmgr->usec_timeout) {
+		pr_err("SMU check loaded firmware failed.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int smu8_load_mec_firmware(struct pp_hwmgr *hwmgr)
+{
+	uint32_t reg_data;
+	uint32_t tmp;
+	int ret = 0;
+	struct cgs_firmware_info info = {0};
+	struct smu8_smumgr *smu8_smu;
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	smu8_smu = hwmgr->smu_backend;
+	ret = cgs_get_firmware_info(hwmgr->device,
+						CGS_UCODE_ID_CP_MEC, &info);
+
+	if (ret)
+		return -EINVAL;
+
+	/* Disable MEC parsing/prefetching */
+	tmp = cgs_read_register(hwmgr->device,
+					mmCP_MEC_CNTL);
+	tmp = PHM_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME1_HALT, 1);
+	tmp = PHM_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME2_HALT, 1);
+	cgs_write_register(hwmgr->device, mmCP_MEC_CNTL, tmp);
+
+	tmp = cgs_read_register(hwmgr->device,
+					mmCP_CPC_IC_BASE_CNTL);
+
+	tmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, VMID, 0);
+	tmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, ATC, 0);
+	tmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);
+	tmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, MTYPE, 1);
+	cgs_write_register(hwmgr->device, mmCP_CPC_IC_BASE_CNTL, tmp);
+
+	reg_data = lower_32_bits(info.mc_addr) &
+			PHM_FIELD_MASK(CP_CPC_IC_BASE_LO, IC_BASE_LO);
+	cgs_write_register(hwmgr->device, mmCP_CPC_IC_BASE_LO, reg_data);
+
+	reg_data = upper_32_bits(info.mc_addr) &
+			PHM_FIELD_MASK(CP_CPC_IC_BASE_HI, IC_BASE_HI);
+	cgs_write_register(hwmgr->device, mmCP_CPC_IC_BASE_HI, reg_data);
+
+	return 0;
+}
+
+static uint8_t smu8_translate_firmware_enum_to_arg(struct pp_hwmgr *hwmgr,
+			enum smu8_scratch_entry firmware_enum)
+{
+	uint8_t ret = 0;
+
+	switch (firmware_enum) {
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA0:
+		ret = UCODE_ID_SDMA0;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA1:
+		if (hwmgr->chip_id == CHIP_STONEY)
+			ret = UCODE_ID_SDMA0;
+		else
+			ret = UCODE_ID_SDMA1;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE:
+		ret = UCODE_ID_CP_CE;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP:
+		ret = UCODE_ID_CP_PFP;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME:
+		ret = UCODE_ID_CP_ME;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1:
+		ret = UCODE_ID_CP_MEC_JT1;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2:
+		if (hwmgr->chip_id == CHIP_STONEY)
+			ret = UCODE_ID_CP_MEC_JT1;
+		else
+			ret = UCODE_ID_CP_MEC_JT2;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_GMCON_RENG:
+		ret = UCODE_ID_GMCON_RENG;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G:
+		ret = UCODE_ID_RLC_G;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH:
+		ret = UCODE_ID_RLC_SCRATCH;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM:
+		ret = UCODE_ID_RLC_SRM_ARAM;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM:
+		ret = UCODE_ID_RLC_SRM_DRAM;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_DMCU_ERAM:
+		ret = UCODE_ID_DMCU_ERAM;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_DMCU_IRAM:
+		ret = UCODE_ID_DMCU_IRAM;
+		break;
+	case SMU8_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING:
+		ret = TASK_ARG_INIT_MM_PWR_LOG;
+		break;
+	case SMU8_SCRATCH_ENTRY_DATA_ID_SDMA_HALT:
+	case SMU8_SCRATCH_ENTRY_DATA_ID_SYS_CLOCKGATING:
+	case SMU8_SCRATCH_ENTRY_DATA_ID_SDMA_RING_REGS:
+	case SMU8_SCRATCH_ENTRY_DATA_ID_NONGFX_REINIT:
+	case SMU8_SCRATCH_ENTRY_DATA_ID_SDMA_START:
+	case SMU8_SCRATCH_ENTRY_DATA_ID_IH_REGISTERS:
+		ret = TASK_ARG_REG_MMIO;
+		break;
+	case SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE:
+		ret = TASK_ARG_INIT_CLK_TABLE;
+		break;
+	}
+
+	return ret;
+}
+
+static enum cgs_ucode_id smu8_convert_fw_type_to_cgs(uint32_t fw_type)
+{
+	enum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;
+
+	switch (fw_type) {
+	case UCODE_ID_SDMA0:
+		result = CGS_UCODE_ID_SDMA0;
+		break;
+	case UCODE_ID_SDMA1:
+		result = CGS_UCODE_ID_SDMA1;
+		break;
+	case UCODE_ID_CP_CE:
+		result = CGS_UCODE_ID_CP_CE;
+		break;
+	case UCODE_ID_CP_PFP:
+		result = CGS_UCODE_ID_CP_PFP;
+		break;
+	case UCODE_ID_CP_ME:
+		result = CGS_UCODE_ID_CP_ME;
+		break;
+	case UCODE_ID_CP_MEC_JT1:
+		result = CGS_UCODE_ID_CP_MEC_JT1;
+		break;
+	case UCODE_ID_CP_MEC_JT2:
+		result = CGS_UCODE_ID_CP_MEC_JT2;
+		break;
+	case UCODE_ID_RLC_G:
+		result = CGS_UCODE_ID_RLC_G;
+		break;
+	default:
+		break;
+	}
+
+	return result;
+}
+
+static int smu8_smu_populate_single_scratch_task(
+			struct pp_hwmgr *hwmgr,
+			enum smu8_scratch_entry fw_enum,
+			uint8_t type, bool is_last)
+{
+	uint8_t i;
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	struct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;
+	struct SMU_Task *task = &toc->tasks[smu8_smu->toc_entry_used_count++];
+
+	task->type = type;
+	task->arg = smu8_translate_firmware_enum_to_arg(hwmgr, fw_enum);
+	task->next = is_last ? END_OF_TASK_LIST : smu8_smu->toc_entry_used_count;
+
+	for (i = 0; i < smu8_smu->scratch_buffer_length; i++)
+		if (smu8_smu->scratch_buffer[i].firmware_ID == fw_enum)
+			break;
+
+	if (i >= smu8_smu->scratch_buffer_length) {
+		pr_err("Invalid Firmware Type\n");
+		return -EINVAL;
+	}
+
+	task->addr.low = lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr);
+	task->addr.high = upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr);
+	task->size_bytes = smu8_smu->scratch_buffer[i].data_size;
+
+	if (SMU8_SCRATCH_ENTRY_DATA_ID_IH_REGISTERS == fw_enum) {
+		struct smu8_ih_meta_data *pIHReg_restore =
+		     (struct smu8_ih_meta_data *)smu8_smu->scratch_buffer[i].kaddr;
+		pIHReg_restore->command =
+			METADATA_CMD_MODE0 | METADATA_PERFORM_ON_LOAD;
+	}
+
+	return 0;
+}
+
+static int smu8_smu_populate_single_ucode_load_task(
+					struct pp_hwmgr *hwmgr,
+					enum smu8_scratch_entry fw_enum,
+					bool is_last)
+{
+	uint8_t i;
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	struct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;
+	struct SMU_Task *task = &toc->tasks[smu8_smu->toc_entry_used_count++];
+
+	task->type = TASK_TYPE_UCODE_LOAD;
+	task->arg = smu8_translate_firmware_enum_to_arg(hwmgr, fw_enum);
+	task->next = is_last ? END_OF_TASK_LIST : smu8_smu->toc_entry_used_count;
+
+	for (i = 0; i < smu8_smu->driver_buffer_length; i++)
+		if (smu8_smu->driver_buffer[i].firmware_ID == fw_enum)
+			break;
+
+	if (i >= smu8_smu->driver_buffer_length) {
+		pr_err("Invalid Firmware Type\n");
+		return -EINVAL;
+	}
+
+	task->addr.low = lower_32_bits(smu8_smu->driver_buffer[i].mc_addr);
+	task->addr.high = upper_32_bits(smu8_smu->driver_buffer[i].mc_addr);
+	task->size_bytes = smu8_smu->driver_buffer[i].data_size;
+
+	return 0;
+}
+
+static int smu8_smu_construct_toc_for_rlc_aram_save(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+
+	smu8_smu->toc_entry_aram = smu8_smu->toc_entry_used_count;
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,
+				TASK_TYPE_UCODE_SAVE, true);
+
+	return 0;
+}
+
+static int smu8_smu_initialize_toc_empty_job_list(struct pp_hwmgr *hwmgr)
+{
+	int i;
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	struct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;
+
+	for (i = 0; i < NUM_JOBLIST_ENTRIES; i++)
+		toc->JobList[i] = (uint8_t)IGNORE_JOB;
+
+	return 0;
+}
+
+static int smu8_smu_construct_toc_for_vddgfx_enter(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	struct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;
+
+	toc->JobList[JOB_GFX_SAVE] = (uint8_t)smu8_smu->toc_entry_used_count;
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				    SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,
+				    TASK_TYPE_UCODE_SAVE, false);
+
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				    SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,
+				    TASK_TYPE_UCODE_SAVE, true);
+
+	return 0;
+}
+
+
+static int smu8_smu_construct_toc_for_vddgfx_exit(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	struct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;
+
+	toc->JobList[JOB_GFX_RESTORE] = (uint8_t)smu8_smu->toc_entry_used_count;
+
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);
+
+	if (hwmgr->chip_id == CHIP_STONEY)
+		smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);
+	else
+		smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2, false);
+
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G, false);
+
+	/* populate scratch */
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,
+				TASK_TYPE_UCODE_LOAD, false);
+
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,
+				TASK_TYPE_UCODE_LOAD, false);
+
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,
+				TASK_TYPE_UCODE_LOAD, true);
+
+	return 0;
+}
+
+static int smu8_smu_construct_toc_for_power_profiling(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+
+	smu8_smu->toc_entry_power_profiling_index = smu8_smu->toc_entry_used_count;
+
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING,
+				TASK_TYPE_INITIALIZE, true);
+	return 0;
+}
+
+static int smu8_smu_construct_toc_for_bootup(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+
+	smu8_smu->toc_entry_initialize_index = smu8_smu->toc_entry_used_count;
+
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA0, false);
+	if (hwmgr->chip_id != CHIP_STONEY)
+		smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA1, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);
+	if (hwmgr->chip_id != CHIP_STONEY)
+		smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2, false);
+	smu8_smu_populate_single_ucode_load_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G, true);
+
+	return 0;
+}
+
+static int smu8_smu_construct_toc_for_clock_table(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+
+	smu8_smu->toc_entry_clock_table = smu8_smu->toc_entry_used_count;
+
+	smu8_smu_populate_single_scratch_task(hwmgr,
+				SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE,
+				TASK_TYPE_INITIALIZE, true);
+
+	return 0;
+}
+
+static int smu8_smu_construct_toc(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+
+	smu8_smu->toc_entry_used_count = 0;
+	smu8_smu_initialize_toc_empty_job_list(hwmgr);
+	smu8_smu_construct_toc_for_rlc_aram_save(hwmgr);
+	smu8_smu_construct_toc_for_vddgfx_enter(hwmgr);
+	smu8_smu_construct_toc_for_vddgfx_exit(hwmgr);
+	smu8_smu_construct_toc_for_power_profiling(hwmgr);
+	smu8_smu_construct_toc_for_bootup(hwmgr);
+	smu8_smu_construct_toc_for_clock_table(hwmgr);
+
+	return 0;
+}
+
+static int smu8_smu_populate_firmware_entries(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	uint32_t firmware_type;
+	uint32_t i;
+	int ret;
+	enum cgs_ucode_id ucode_id;
+	struct cgs_firmware_info info = {0};
+
+	smu8_smu->driver_buffer_length = 0;
+
+	for (i = 0; i < ARRAY_SIZE(firmware_list); i++) {
+
+		firmware_type = smu8_translate_firmware_enum_to_arg(hwmgr,
+					firmware_list[i]);
+
+		ucode_id = smu8_convert_fw_type_to_cgs(firmware_type);
+
+		ret = cgs_get_firmware_info(hwmgr->device,
+							ucode_id, &info);
+
+		if (ret == 0) {
+			smu8_smu->driver_buffer[i].mc_addr = info.mc_addr;
+
+			smu8_smu->driver_buffer[i].data_size = info.image_size;
+
+			smu8_smu->driver_buffer[i].firmware_ID = firmware_list[i];
+			smu8_smu->driver_buffer_length++;
+		}
+	}
+
+	return 0;
+}
+
+static int smu8_smu_populate_single_scratch_entry(
+				struct pp_hwmgr *hwmgr,
+				enum smu8_scratch_entry scratch_type,
+				uint32_t ulsize_byte,
+				struct smu8_buffer_entry *entry)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	uint32_t ulsize_aligned = SIZE_ALIGN_32(ulsize_byte);
+
+	entry->data_size = ulsize_byte;
+	entry->kaddr = (char *) smu8_smu->smu_buffer.kaddr +
+				smu8_smu->smu_buffer_used_bytes;
+	entry->mc_addr = smu8_smu->smu_buffer.mc_addr + smu8_smu->smu_buffer_used_bytes;
+	entry->firmware_ID = scratch_type;
+
+	smu8_smu->smu_buffer_used_bytes += ulsize_aligned;
+
+	return 0;
+}
+
+static int smu8_download_pptable_settings(struct pp_hwmgr *hwmgr, void **table)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	unsigned long i;
+
+	for (i = 0; i < smu8_smu->scratch_buffer_length; i++) {
+		if (smu8_smu->scratch_buffer[i].firmware_ID
+			== SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE)
+			break;
+	}
+
+	*table = (struct SMU8_Fusion_ClkTable *)smu8_smu->scratch_buffer[i].kaddr;
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+				PPSMC_MSG_SetClkTableAddrHi,
+				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+				PPSMC_MSG_SetClkTableAddrLo,
+				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
+				smu8_smu->toc_entry_clock_table);
+
+	smu8_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToDram);
+
+	return 0;
+}
+
+static int smu8_upload_pptable_settings(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	unsigned long i;
+
+	for (i = 0; i < smu8_smu->scratch_buffer_length; i++) {
+		if (smu8_smu->scratch_buffer[i].firmware_ID
+				== SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE)
+			break;
+	}
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+				PPSMC_MSG_SetClkTableAddrHi,
+				upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+				PPSMC_MSG_SetClkTableAddrLo,
+				lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr));
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
+				smu8_smu->toc_entry_clock_table);
+
+	smu8_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToSmu);
+
+	return 0;
+}
+
+static int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu = hwmgr->smu_backend;
+	uint32_t smc_address;
+
+	if (!hwmgr->reload_fw) {
+		pr_info("skip reloading...\n");
+		return 0;
+	}
+
+	smu8_smu_populate_firmware_entries(hwmgr);
+
+	smu8_smu_construct_toc(hwmgr);
+
+	smc_address = SMU8_FIRMWARE_HEADER_LOCATION +
+		offsetof(struct SMU8_Firmware_Header, UcodeLoadStatus);
+
+	smu8_write_smc_sram_dword(hwmgr, smc_address, 0, smc_address+4);
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+					PPSMC_MSG_DriverDramAddrHi,
+					upper_32_bits(smu8_smu->toc_buffer.mc_addr));
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+					PPSMC_MSG_DriverDramAddrLo,
+					lower_32_bits(smu8_smu->toc_buffer.mc_addr));
+
+	smu8_send_msg_to_smc(hwmgr, PPSMC_MSG_InitJobs);
+
+	smu8_send_msg_to_smc_with_parameter(hwmgr,
+					PPSMC_MSG_ExecuteJob,
+					smu8_smu->toc_entry_aram);
+	smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,
+				smu8_smu->toc_entry_power_profiling_index);
+
+	return smu8_send_msg_to_smc_with_parameter(hwmgr,
+					PPSMC_MSG_ExecuteJob,
+					smu8_smu->toc_entry_initialize_index);
+}
+
+static int smu8_start_smu(struct pp_hwmgr *hwmgr)
+{
+	int ret = 0;
+	uint32_t fw_to_check = 0;
+	struct cgs_firmware_info info = {0};
+	uint32_t index = SMN_MP1_SRAM_START_ADDR +
+			 SMU8_FIRMWARE_HEADER_LOCATION +
+			 offsetof(struct SMU8_Firmware_Header, Version);
+
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	cgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);
+	hwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);
+	info.version = hwmgr->smu_version >> 8;
+	cgs_get_firmware_info(hwmgr->device, CGS_UCODE_ID_SMU, &info);
+
+	fw_to_check = UCODE_ID_RLC_G_MASK |
+			UCODE_ID_SDMA0_MASK |
+			UCODE_ID_SDMA1_MASK |
+			UCODE_ID_CP_CE_MASK |
+			UCODE_ID_CP_ME_MASK |
+			UCODE_ID_CP_PFP_MASK |
+			UCODE_ID_CP_MEC_JT1_MASK |
+			UCODE_ID_CP_MEC_JT2_MASK;
+
+	if (hwmgr->chip_id == CHIP_STONEY)
+		fw_to_check &= ~(UCODE_ID_SDMA1_MASK | UCODE_ID_CP_MEC_JT2_MASK);
+
+	ret = smu8_request_smu_load_fw(hwmgr);
+	if (ret)
+		pr_err("SMU firmware load failed\n");
+
+	smu8_check_fw_load_finish(hwmgr, fw_to_check);
+
+	ret = smu8_load_mec_firmware(hwmgr);
+	if (ret)
+		pr_err("Mec Firmware load failed\n");
+
+	return ret;
+}
+
+static int smu8_smu_init(struct pp_hwmgr *hwmgr)
+{
+	int ret = 0;
+	struct smu8_smumgr *smu8_smu;
+
+	smu8_smu = kzalloc(sizeof(struct smu8_smumgr), GFP_KERNEL);
+	if (smu8_smu == NULL)
+		return -ENOMEM;
+
+	hwmgr->smu_backend = smu8_smu;
+
+	smu8_smu->toc_buffer.data_size = 4096;
+	smu8_smu->smu_buffer.data_size =
+		ALIGN(UCODE_ID_RLC_SCRATCH_SIZE_BYTE, 32) +
+		ALIGN(UCODE_ID_RLC_SRM_ARAM_SIZE_BYTE, 32) +
+		ALIGN(UCODE_ID_RLC_SRM_DRAM_SIZE_BYTE, 32) +
+		ALIGN(sizeof(struct SMU8_MultimediaPowerLogData), 32) +
+		ALIGN(sizeof(struct SMU8_Fusion_ClkTable), 32);
+
+	ret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,
+				smu8_smu->toc_buffer.data_size,
+				PAGE_SIZE,
+				AMDGPU_GEM_DOMAIN_VRAM,
+				&smu8_smu->toc_buffer.handle,
+				&smu8_smu->toc_buffer.mc_addr,
+				&smu8_smu->toc_buffer.kaddr);
+	if (ret)
+		goto err2;
+
+	ret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,
+				smu8_smu->smu_buffer.data_size,
+				PAGE_SIZE,
+				AMDGPU_GEM_DOMAIN_VRAM,
+				&smu8_smu->smu_buffer.handle,
+				&smu8_smu->smu_buffer.mc_addr,
+				&smu8_smu->smu_buffer.kaddr);
+	if (ret)
+		goto err1;
+
+	if (0 != smu8_smu_populate_single_scratch_entry(hwmgr,
+		SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,
+		UCODE_ID_RLC_SCRATCH_SIZE_BYTE,
+		&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {
+		pr_err("Error when Populate Firmware Entry.\n");
+		goto err0;
+	}
+
+	if (0 != smu8_smu_populate_single_scratch_entry(hwmgr,
+		SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,
+		UCODE_ID_RLC_SRM_ARAM_SIZE_BYTE,
+		&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {
+		pr_err("Error when Populate Firmware Entry.\n");
+		goto err0;
+	}
+	if (0 != smu8_smu_populate_single_scratch_entry(hwmgr,
+		SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,
+		UCODE_ID_RLC_SRM_DRAM_SIZE_BYTE,
+		&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {
+		pr_err("Error when Populate Firmware Entry.\n");
+		goto err0;
+	}
+
+	if (0 != smu8_smu_populate_single_scratch_entry(hwmgr,
+		SMU8_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING,
+		sizeof(struct SMU8_MultimediaPowerLogData),
+		&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {
+		pr_err("Error when Populate Firmware Entry.\n");
+		goto err0;
+	}
+
+	if (0 != smu8_smu_populate_single_scratch_entry(hwmgr,
+		SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE,
+		sizeof(struct SMU8_Fusion_ClkTable),
+		&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {
+		pr_err("Error when Populate Firmware Entry.\n");
+		goto err0;
+	}
+
+	return 0;
+
+err0:
+	amdgpu_bo_free_kernel(&smu8_smu->smu_buffer.handle,
+				&smu8_smu->smu_buffer.mc_addr,
+				&smu8_smu->smu_buffer.kaddr);
+err1:
+	amdgpu_bo_free_kernel(&smu8_smu->toc_buffer.handle,
+				&smu8_smu->toc_buffer.mc_addr,
+				&smu8_smu->toc_buffer.kaddr);
+err2:
+	kfree(smu8_smu);
+	return -EINVAL;
+}
+
+static int smu8_smu_fini(struct pp_hwmgr *hwmgr)
+{
+	struct smu8_smumgr *smu8_smu;
+
+	if (hwmgr == NULL || hwmgr->device == NULL)
+		return -EINVAL;
+
+	smu8_smu = hwmgr->smu_backend;
+	if (smu8_smu) {
+		amdgpu_bo_free_kernel(&smu8_smu->toc_buffer.handle,
+					&smu8_smu->toc_buffer.mc_addr,
+					&smu8_smu->toc_buffer.kaddr);
+		amdgpu_bo_free_kernel(&smu8_smu->smu_buffer.handle,
+					&smu8_smu->smu_buffer.mc_addr,
+					&smu8_smu->smu_buffer.kaddr);
+		kfree(smu8_smu);
+	}
+
+	return 0;
+}
+
+static bool smu8_dpm_check_smu_features(struct pp_hwmgr *hwmgr,
+				unsigned long check_feature)
+{
+	int result;
+	unsigned long features;
+
+	result = smu8_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetFeatureStatus, 0);
+	if (result == 0) {
+		features = smum_get_argument(hwmgr);
+		if (features & check_feature)
+			return true;
+	}
+
+	return false;
+}
+
+static bool smu8_is_dpm_running(struct pp_hwmgr *hwmgr)
+{
+	if (smu8_dpm_check_smu_features(hwmgr, SMU_EnabledFeatureScoreboard_SclkDpmOn))
+		return true;
+	return false;
+}
+
+const struct pp_smumgr_func smu8_smu_funcs = {
+	.smu_init = smu8_smu_init,
+	.smu_fini = smu8_smu_fini,
+	.start_smu = smu8_start_smu,
+	.check_fw_load_finish = smu8_check_fw_load_finish,
+	.request_smu_load_fw = NULL,
+	.request_smu_load_specific_fw = NULL,
+	.get_argument = smu8_smum_get_argument,
+	.send_msg_to_smc = smu8_send_msg_to_smc,
+	.send_msg_to_smc_with_parameter = smu8_send_msg_to_smc_with_parameter,
+	.download_pptable_settings = smu8_download_pptable_settings,
+	.upload_pptable_settings = smu8_upload_pptable_settings,
+	.is_dpm_running = smu8_is_dpm_running,
+};
+
