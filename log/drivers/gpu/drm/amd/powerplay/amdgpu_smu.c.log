commit ab9c21124d6e03460c9c59006a61cc076fefa82e
Author: John Clements <john.clements@amd.com>
Date:   Wed May 13 17:45:06 2020 +0800

    drm/amdgpu: Add cmd to control XGMI link sleep
    
    Added host to SMU FW cmd to enable/disable XGMI link power down
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: John Clements <john.clements@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index de14542de775..8c684a6e0156 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -2100,6 +2100,28 @@ int smu_set_df_cstate(struct smu_context *smu,
 	return ret;
 }
 
+int smu_allow_xgmi_power_down(struct smu_context *smu, bool en)
+{
+	struct amdgpu_device *adev = smu->adev;
+	int ret = 0;
+
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
+	if (!smu->ppt_funcs || !smu->ppt_funcs->allow_xgmi_power_down)
+		return 0;
+
+	mutex_lock(&smu->mutex);
+
+	ret = smu->ppt_funcs->allow_xgmi_power_down(smu, en);
+	if (ret)
+		pr_err("[AllowXgmiPowerDown] failed!\n");
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
 int smu_write_watermarks_table(struct smu_context *smu)
 {
 	void *watermarks_table = smu->smu_table.watermarks_table;

commit 85625e64295079525e5f841b576f9ab71d2c6237
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu May 7 18:17:55 2020 +0800

    drm/amdgpu: enable hibernate support on Navi1X
    
    BACO is needed to support hibernate on Navi1X.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 607ff0270aee..de14542de775 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1498,7 +1498,7 @@ static int smu_disable_dpm(struct smu_context *smu)
 	bool use_baco = !smu->is_apu &&
 		((adev->in_gpu_reset &&
 		  (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO)) ||
-		 (adev->in_runpm && amdgpu_asic_supports_baco(adev)));
+		 ((adev->in_runpm || adev->in_hibernate) && amdgpu_asic_supports_baco(adev)));
 
 	ret = smu_get_smc_version(smu, NULL, &smu_version);
 	if (ret) {

commit 74577c3a48a85f235a0506d07f31d91f170d8b19
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Apr 30 14:38:39 2020 +0800

    drm/amd/powerplay: perform PG ungate prior to CG ungate
    
    Since gfxoff should be disabled first before trying to access those
    GC registers.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 5964d6323a13..607ff0270aee 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1784,12 +1784,12 @@ static int smu_enable_umd_pstate(void *handle,
 		if (*level & profile_mode_mask) {
 			smu_dpm_ctx->saved_dpm_level = smu_dpm_ctx->dpm_level;
 			smu_dpm_ctx->enable_umd_pstate = true;
-			amdgpu_device_ip_set_clockgating_state(smu->adev,
-							       AMD_IP_BLOCK_TYPE_GFX,
-							       AMD_CG_STATE_UNGATE);
 			amdgpu_device_ip_set_powergating_state(smu->adev,
 							       AMD_IP_BLOCK_TYPE_GFX,
 							       AMD_PG_STATE_UNGATE);
+			amdgpu_device_ip_set_clockgating_state(smu->adev,
+							       AMD_IP_BLOCK_TYPE_GFX,
+							       AMD_CG_STATE_UNGATE);
 		}
 	} else {
 		/* exit umd pstate, restore level, enable gfx cg*/

commit 38748ad88a2f9673bb63dda607204bb3a9bc21a0
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Wed Apr 22 19:28:48 2020 +0800

    drm/amdgpu: enable one vf mode for nv12
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 361a5b6cbe3b..5964d6323a13 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -347,13 +347,13 @@ int smu_get_dpm_freq_by_index(struct smu_context *smu, enum smu_clk_type clk_typ
 	param = (uint32_t)(((clk_id & 0xffff) << 16) | (level & 0xffff));
 
 	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetDpmFreqByIndex,
-					  param, &param);
+					  param, value);
 	if (ret)
 		return ret;
 
 	/* BIT31:  0 - Fine grained DPM, 1 - Dicrete DPM
 	 * now, we un-support it */
-	*value = param & 0x7fffffff;
+	*value = *value & 0x7fffffff;
 
 	return ret;
 }
@@ -535,7 +535,6 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	int table_id = smu_table_get_index(smu, table_index);
 	uint32_t table_size;
 	int ret = 0;
-
 	if (!table_data || table_id >= SMU_TABLE_COUNT || table_id < 0)
 		return -EINVAL;
 
@@ -691,7 +690,6 @@ int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 
 	if (smu->is_apu)
 		return 1;
-
 	feature_id = smu_feature_get_index(smu, mask);
 	if (feature_id < 0)
 		return 0;
@@ -1339,6 +1337,9 @@ static int smu_hw_init(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
+	if (amdgpu_sriov_vf(adev) && !amdgpu_sriov_is_pp_one_vf(adev))
+		return 0;
+
 	ret = smu_start_smc_engine(smu);
 	if (ret) {
 		pr_err("SMU is not ready yet!\n");
@@ -1352,9 +1353,6 @@ static int smu_hw_init(void *handle)
 		smu_set_gfx_cgpg(&adev->smu, true);
 	}
 
-	if (amdgpu_sriov_vf(adev) && !amdgpu_sriov_is_pp_one_vf(adev))
-		return 0;
-
 	if (!smu->pm_enabled)
 		return 0;
 

commit b217e6f579d675f90361f1bbafba769601f0bc61
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Thu Apr 23 14:57:40 2020 +0800

    drm/amdgpu: clear the messed up checking logic
    
    for ARCTURUS+ ASICS, we always support SW_SMU for bare-metal
    and for SRIOV one_vf_mode
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Acked-by: Yintian Tao <yttao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2bb1e0c6f344..361a5b6cbe3b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -571,15 +571,10 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 	if (adev->asic_type == CHIP_VEGA20)
 		return (amdgpu_dpm == 2) ? true : false;
 	else if (adev->asic_type >= CHIP_ARCTURUS) {
-		if (amdgpu_sriov_vf(adev) &&
-		    !(adev->asic_type == CHIP_ARCTURUS &&
-		      amdgpu_sriov_is_pp_one_vf(adev)))
-
-			return false;
-		else
+	      if (amdgpu_sriov_is_pp_one_vf(adev) || !amdgpu_sriov_vf(adev))
 			return true;
-	} else
-		return false;
+	}
+	return false;
 }
 
 bool is_support_sw_smu_xgmi(struct amdgpu_device *adev)

commit c983361a724999fcf6a209b485188a9ee93a5e38
Author: Monk Liu <Monk.Liu@amd.com>
Date:   Wed Apr 22 12:15:23 2020 +0800

    drm/amdgpu: sriov is forbidden to call disable DPM
    
    Signed-off-by: Monk Liu <Monk.Liu@amd.com>
    Acked-by: Yintian Tao <yttao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 88b4e5642302..2bb1e0c6f344 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1403,6 +1403,9 @@ static int smu_hw_init(void *handle)
 
 static int smu_stop_dpms(struct smu_context *smu)
 {
+	if (amdgpu_sriov_vf(smu->adev))
+		return 0;
+
 	return smu_system_features_control(smu, false);
 }
 

commit f9b93c9ba605d8b0cf05e72102c3cf4a85aa6191
Author: Jiansong Chen <Jiansong.Chen@amd.com>
Date:   Mon Apr 20 15:36:53 2020 +0800

    drm/amd/powerplay: limit smu support to Arcturus for onevf
    
    Under onevf mode the smu support to other chips is not well
    verified yet.
    
    Signed-off-by: Jiansong Chen <Jiansong.Chen@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d4599fa6dc0b..88b4e5642302 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -571,7 +571,10 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 	if (adev->asic_type == CHIP_VEGA20)
 		return (amdgpu_dpm == 2) ? true : false;
 	else if (adev->asic_type >= CHIP_ARCTURUS) {
-		if (amdgpu_sriov_vf(adev)&& !amdgpu_sriov_is_pp_one_vf(adev))
+		if (amdgpu_sriov_vf(adev) &&
+		    !(adev->asic_type == CHIP_ARCTURUS &&
+		      amdgpu_sriov_is_pp_one_vf(adev)))
+
 			return false;
 		else
 			return true;

commit e57761c68bb431885ff22ecc14b1db31cd09965b
Author: John Clements <john.clements@amd.com>
Date:   Wed Apr 15 10:57:33 2020 +0800

    drm/amdgpu: cache smu fw version info
    
    reduce cmd submission to smu by caching version info
    
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: John Clements <john.clements@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index acbbc50482c4..d4599fa6dc0b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -196,16 +196,31 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 	if (!if_version && !smu_version)
 		return -EINVAL;
 
+	if (smu->smc_fw_if_version && smu->smc_fw_version)
+	{
+		if (if_version)
+			*if_version = smu->smc_fw_if_version;
+
+		if (smu_version)
+			*smu_version = smu->smc_fw_version;
+
+		return 0;
+	}
+
 	if (if_version) {
 		ret = smu_send_smc_msg(smu, SMU_MSG_GetDriverIfVersion, if_version);
 		if (ret)
 			return ret;
+
+		smu->smc_fw_if_version = *if_version;
 	}
 
 	if (smu_version) {
 		ret = smu_send_smc_msg(smu, SMU_MSG_GetSmuVersion, smu_version);
 		if (ret)
 			return ret;
+
+		smu->smc_fw_version = *smu_version;
 	}
 
 	return ret;

commit 774e335b878c1edf5e8e5d0138adaf86a892f025
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Apr 7 14:37:42 2020 +0800

    drm/amd/powerplay: properly set the dpm_enabled state
    
    On the ASIC powered down(in baco or system suspend),
    the dpm_enabled will be set as false. Then all access
    (e.g. df state setting issued on RAS error event) to
    SMU will be blocked.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b69e8d6c0a96..acbbc50482c4 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -62,6 +62,7 @@ const char *smu_get_feature_name(struct smu_context *smu, enum smu_feature_mask
 
 size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 {
+	struct amdgpu_device *adev = smu->adev;
 	size_t size = 0;
 	int ret = 0, i = 0;
 	uint32_t feature_mask[2] = { 0 };
@@ -70,6 +71,9 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 	uint32_t sort_feature[SMU_FEATURE_COUNT];
 	uint64_t hw_feature_count = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	ret = smu_feature_get_enabled_mask(smu, feature_mask, 2);
@@ -110,9 +114,6 @@ static int smu_feature_update_enable_state(struct smu_context *smu,
 	uint32_t feature_low = 0, feature_high = 0;
 	int ret = 0;
 
-	if (!smu->pm_enabled)
-		return ret;
-
 	feature_low = (feature_mask >> 0 ) & 0xffffffff;
 	feature_high = (feature_mask >> 32) & 0xffffffff;
 
@@ -155,6 +156,10 @@ int smu_sys_set_pp_feature_mask(struct smu_context *smu, uint64_t new_mask)
 	uint64_t feature_2_enabled = 0;
 	uint64_t feature_2_disabled = 0;
 	uint64_t feature_enables = 0;
+	struct amdgpu_device *adev = smu->adev;
+
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
 
 	mutex_lock(&smu->mutex);
 
@@ -417,8 +422,12 @@ bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type)
 int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 			   bool gate)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	switch (block_type) {
 	case AMD_IP_BLOCK_TYPE_UVD:
 		ret = smu_dpm_set_uvd_enable(smu, !gate);
@@ -569,8 +578,12 @@ bool is_support_sw_smu_xgmi(struct amdgpu_device *adev)
 int smu_sys_get_pp_table(struct smu_context *smu, void **table)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
+	struct amdgpu_device *adev = smu->adev;
 	uint32_t powerplay_table_size;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (!smu_table->power_play_table && !smu_table->hardcode_pptable)
 		return -EINVAL;
 
@@ -591,11 +604,13 @@ int smu_sys_get_pp_table(struct smu_context *smu, void **table)
 int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
+	struct amdgpu_device *adev = smu->adev;
 	ATOM_COMMON_TABLE_HEADER *header = (ATOM_COMMON_TABLE_HEADER *)buf;
 	int ret = 0;
 
-	if (!smu->pm_enabled)
+	if (!adev->pm.dpm_enabled)
 		return -EINVAL;
+
 	if (header->usStructureSize != size) {
 		pr_err("pp table size not matched !\n");
 		return -EIO;
@@ -636,8 +651,6 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	int ret = 0;
 	uint32_t allowed_feature_mask[SMU_FEATURE_MAX/32];
 
-	if (!smu->pm_enabled)
-		return ret;
 	mutex_lock(&feature->mutex);
 	bitmap_zero(feature->allowed, SMU_FEATURE_MAX);
 	mutex_unlock(&feature->mutex);
@@ -1360,10 +1373,7 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
-	if (!smu->pm_enabled)
-		adev->pm.dpm_enabled = false;
-	else
-		adev->pm.dpm_enabled = true;	/* TODO: will set dpm_enabled flag while VCN and DAL DPM is workable */
+	adev->pm.dpm_enabled = true;
 
 	pr_info("SMU is initialized successfully!\n");
 
@@ -1397,6 +1407,8 @@ static int smu_hw_fini(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
+	adev->pm.dpm_enabled = false;
+
 	smu_i2c_eeprom_fini(smu, &adev->pm.smu_i2c);
 
 	if (!amdgpu_sriov_vf(adev)){
@@ -1538,6 +1550,8 @@ static int smu_suspend(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
+	adev->pm.dpm_enabled = false;
+
 	smu_i2c_eeprom_fini(smu, &adev->pm.smu_i2c);
 
 	if(!amdgpu_sriov_vf(adev)) {
@@ -1594,6 +1608,8 @@ static int smu_resume(void *handle)
 
 	smu->disable_uclk_switch = 0;
 
+	adev->pm.dpm_enabled = true;
+
 	pr_info("SMU is resumed successfully!\n");
 
 	return 0;
@@ -1605,10 +1621,14 @@ static int smu_resume(void *handle)
 int smu_display_configuration_change(struct smu_context *smu,
 				     const struct amd_pp_display_configuration *display_config)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int index = 0;
 	int num_of_active_display = 0;
 
-	if (!smu->pm_enabled || !is_support_sw_smu(smu->adev))
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
+	if (!is_support_sw_smu(smu->adev))
 		return -EINVAL;
 
 	if (!display_config)
@@ -1670,12 +1690,16 @@ int smu_get_current_clocks(struct smu_context *smu,
 			   struct amd_pp_clock_info *clocks)
 {
 	struct amd_pp_simple_clock_info simple_clocks = {0};
+	struct amdgpu_device *adev = smu->adev;
 	struct smu_clock_info hw_clocks;
 	int ret = 0;
 
 	if (!is_support_sw_smu(smu->adev))
 		return -EINVAL;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	smu_get_dal_power_level(smu, &simple_clocks);
@@ -1738,7 +1762,7 @@ static int smu_enable_umd_pstate(void *handle,
 	struct smu_context *smu = (struct smu_context*)(handle);
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 
-	if (!smu->is_apu && (!smu->pm_enabled || !smu_dpm_ctx->dpm_context))
+	if (!smu->is_apu && !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
 	if (!(smu_dpm_ctx->dpm_level & profile_mode_mask)) {
@@ -1780,9 +1804,6 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 	long workload;
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 
-	if (!smu->pm_enabled)
-		return -EINVAL;
-
 	if (!skip_display_settings) {
 		ret = smu_display_config_changed(smu);
 		if (ret) {
@@ -1833,8 +1854,12 @@ int smu_handle_task(struct smu_context *smu,
 		    enum amd_pp_task task_id,
 		    bool lock_needed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (lock_needed)
 		mutex_lock(&smu->mutex);
 
@@ -1868,10 +1893,11 @@ int smu_switch_power_profile(struct smu_context *smu,
 			     bool en)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	struct amdgpu_device *adev = smu->adev;
 	long workload;
 	uint32_t index;
 
-	if (!smu->pm_enabled)
+	if (!adev->pm.dpm_enabled)
 		return -EINVAL;
 
 	if (!(type < PP_SMC_POWER_PROFILE_CUSTOM))
@@ -1902,8 +1928,12 @@ int smu_switch_power_profile(struct smu_context *smu,
 enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	struct amdgpu_device *adev = smu->adev;
 	enum amd_dpm_forced_level level;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (!smu->is_apu && !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
@@ -1917,8 +1947,12 @@ enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
 int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (!smu->is_apu && !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
@@ -1941,8 +1975,12 @@ int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_lev
 
 int smu_set_display_count(struct smu_context *smu, uint32_t count)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 	ret = smu_init_display_count(smu, count);
 	mutex_unlock(&smu->mutex);
@@ -1956,8 +1994,12 @@ int smu_force_clk_levels(struct smu_context *smu,
 			 bool lock_needed)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
 		pr_debug("force clock level is for dpm manual mode only.\n");
 		return -EINVAL;
@@ -1975,20 +2017,19 @@ int smu_force_clk_levels(struct smu_context *smu,
 	return ret;
 }
 
+/*
+ * On system suspending or resetting, the dpm_enabled
+ * flag will be cleared. So that those SMU services which
+ * are not supported will be gated.
+ * However, the mp1 state setting should still be granted
+ * even if the dpm_enabled cleared.
+ */
 int smu_set_mp1_state(struct smu_context *smu,
 		      enum pp_mp1_state mp1_state)
 {
 	uint16_t msg;
 	int ret;
 
-	/*
-	 * The SMC is not fully ready. That may be
-	 * expected as the IP may be masked.
-	 * So, just return without error.
-	 */
-	if (!smu->pm_enabled)
-		return 0;
-
 	mutex_lock(&smu->mutex);
 
 	switch (mp1_state) {
@@ -2025,15 +2066,11 @@ int smu_set_mp1_state(struct smu_context *smu,
 int smu_set_df_cstate(struct smu_context *smu,
 		      enum pp_df_cstate state)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
-	/*
-	 * The SMC is not fully ready. That may be
-	 * expected as the IP may be masked.
-	 * So, just return without error.
-	 */
-	if (!smu->pm_enabled)
-		return 0;
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
 
 	if (!smu->ppt_funcs || !smu->ppt_funcs->set_df_cstate)
 		return 0;
@@ -2067,6 +2104,10 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 		struct dm_pp_wm_sets_with_clock_ranges_soc15 *clock_ranges)
 {
 	void *table = smu->smu_table.watermarks_table;
+	struct amdgpu_device *adev = smu->adev;
+
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
 
 	if (!table)
 		return -EINVAL;
@@ -2091,8 +2132,12 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 
 int smu_set_ac_dc(struct smu_context *smu)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	/* controlled by firmware */
 	if (smu->dc_controlled_by_gpio)
 		return 0;
@@ -2151,8 +2196,12 @@ const struct amdgpu_ip_block_version smu_v12_0_ip_block =
 
 int smu_load_microcode(struct smu_context *smu)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->load_microcode)
@@ -2165,8 +2214,12 @@ int smu_load_microcode(struct smu_context *smu)
 
 int smu_check_fw_status(struct smu_context *smu)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->check_fw_status)
@@ -2193,8 +2246,12 @@ int smu_set_gfx_cgpg(struct smu_context *smu, bool enabled)
 
 int smu_set_fan_speed_rpm(struct smu_context *smu, uint32_t speed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_fan_speed_rpm)
@@ -2210,10 +2267,15 @@ int smu_get_power_limit(struct smu_context *smu,
 			bool def,
 			bool lock_needed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
-	if (lock_needed)
+	if (lock_needed) {
+		if (!adev->pm.dpm_enabled)
+			return -EINVAL;
+
 		mutex_lock(&smu->mutex);
+	}
 
 	if (smu->ppt_funcs->get_power_limit)
 		ret = smu->ppt_funcs->get_power_limit(smu, limit, def);
@@ -2226,8 +2288,12 @@ int smu_get_power_limit(struct smu_context *smu,
 
 int smu_set_power_limit(struct smu_context *smu, uint32_t limit)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_power_limit)
@@ -2240,8 +2306,12 @@ int smu_set_power_limit(struct smu_context *smu, uint32_t limit)
 
 int smu_print_clk_levels(struct smu_context *smu, enum smu_clk_type clk_type, char *buf)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->print_clk_levels)
@@ -2254,8 +2324,12 @@ int smu_print_clk_levels(struct smu_context *smu, enum smu_clk_type clk_type, ch
 
 int smu_get_od_percentage(struct smu_context *smu, enum smu_clk_type type)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_od_percentage)
@@ -2268,8 +2342,12 @@ int smu_get_od_percentage(struct smu_context *smu, enum smu_clk_type type)
 
 int smu_set_od_percentage(struct smu_context *smu, enum smu_clk_type type, uint32_t value)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_od_percentage)
@@ -2284,8 +2362,12 @@ int smu_od_edit_dpm_table(struct smu_context *smu,
 			  enum PP_OD_DPM_TABLE_COMMAND type,
 			  long *input, uint32_t size)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->od_edit_dpm_table)
@@ -2300,8 +2382,12 @@ int smu_read_sensor(struct smu_context *smu,
 		    enum amd_pp_sensors sensor,
 		    void *data, uint32_t *size)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->read_sensor)
@@ -2314,8 +2400,12 @@ int smu_read_sensor(struct smu_context *smu,
 
 int smu_get_power_profile_mode(struct smu_context *smu, char *buf)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_power_profile_mode)
@@ -2331,8 +2421,12 @@ int smu_set_power_profile_mode(struct smu_context *smu,
 			       uint32_t param_size,
 			       bool lock_needed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (lock_needed)
 		mutex_lock(&smu->mutex);
 
@@ -2348,8 +2442,12 @@ int smu_set_power_profile_mode(struct smu_context *smu,
 
 int smu_get_fan_control_mode(struct smu_context *smu)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_fan_control_mode)
@@ -2362,8 +2460,12 @@ int smu_get_fan_control_mode(struct smu_context *smu)
 
 int smu_set_fan_control_mode(struct smu_context *smu, int value)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_fan_control_mode)
@@ -2376,8 +2478,12 @@ int smu_set_fan_control_mode(struct smu_context *smu, int value)
 
 int smu_get_fan_speed_percent(struct smu_context *smu, uint32_t *speed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_fan_speed_percent)
@@ -2390,8 +2496,12 @@ int smu_get_fan_speed_percent(struct smu_context *smu, uint32_t *speed)
 
 int smu_set_fan_speed_percent(struct smu_context *smu, uint32_t speed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_fan_speed_percent)
@@ -2404,8 +2514,12 @@ int smu_set_fan_speed_percent(struct smu_context *smu, uint32_t speed)
 
 int smu_get_fan_speed_rpm(struct smu_context *smu, uint32_t *speed)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_fan_speed_rpm)
@@ -2418,8 +2532,12 @@ int smu_get_fan_speed_rpm(struct smu_context *smu, uint32_t *speed)
 
 int smu_set_deep_sleep_dcefclk(struct smu_context *smu, int clk)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_deep_sleep_dcefclk)
@@ -2432,8 +2550,12 @@ int smu_set_deep_sleep_dcefclk(struct smu_context *smu, int clk)
 
 int smu_set_active_display_count(struct smu_context *smu, uint32_t count)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	if (smu->ppt_funcs->set_active_display_count)
 		ret = smu->ppt_funcs->set_active_display_count(smu, count);
 
@@ -2444,8 +2566,12 @@ int smu_get_clock_by_type(struct smu_context *smu,
 			  enum amd_pp_clock_type type,
 			  struct amd_pp_clocks *clocks)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_clock_by_type)
@@ -2459,8 +2585,12 @@ int smu_get_clock_by_type(struct smu_context *smu,
 int smu_get_max_high_clocks(struct smu_context *smu,
 			    struct amd_pp_simple_clock_info *clocks)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_max_high_clocks)
@@ -2475,8 +2605,12 @@ int smu_get_clock_by_type_with_latency(struct smu_context *smu,
 				       enum smu_clk_type clk_type,
 				       struct pp_clock_levels_with_latency *clocks)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_clock_by_type_with_latency)
@@ -2491,8 +2625,12 @@ int smu_get_clock_by_type_with_voltage(struct smu_context *smu,
 				       enum amd_pp_clock_type type,
 				       struct pp_clock_levels_with_voltage *clocks)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_clock_by_type_with_voltage)
@@ -2507,8 +2645,12 @@ int smu_get_clock_by_type_with_voltage(struct smu_context *smu,
 int smu_display_clock_voltage_request(struct smu_context *smu,
 				      struct pp_display_clock_request *clock_req)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->display_clock_voltage_request)
@@ -2522,8 +2664,12 @@ int smu_display_clock_voltage_request(struct smu_context *smu,
 
 int smu_display_disable_memory_clock_switch(struct smu_context *smu, bool disable_memory_clock_switch)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = -EINVAL;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->display_disable_memory_clock_switch)
@@ -2536,8 +2682,12 @@ int smu_display_disable_memory_clock_switch(struct smu_context *smu, bool disabl
 
 int smu_notify_smu_enable_pwe(struct smu_context *smu)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->notify_smu_enable_pwe)
@@ -2551,8 +2701,12 @@ int smu_notify_smu_enable_pwe(struct smu_context *smu)
 int smu_set_xgmi_pstate(struct smu_context *smu,
 			uint32_t pstate)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_xgmi_pstate)
@@ -2565,8 +2719,12 @@ int smu_set_xgmi_pstate(struct smu_context *smu,
 
 int smu_set_azalia_d3_pme(struct smu_context *smu)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->set_azalia_d3_pme)
@@ -2577,6 +2735,14 @@ int smu_set_azalia_d3_pme(struct smu_context *smu)
 	return ret;
 }
 
+/*
+ * On system suspending or resetting, the dpm_enabled
+ * flag will be cleared. So that those SMU services which
+ * are not supported will be gated.
+ *
+ * However, the baco/mode1 reset should still be granted
+ * as they are still supported and necessary.
+ */
 bool smu_baco_is_support(struct smu_context *smu)
 {
 	bool ret = false;
@@ -2648,8 +2814,12 @@ int smu_mode2_reset(struct smu_context *smu)
 int smu_get_max_sustainable_clocks_by_dc(struct smu_context *smu,
 					 struct pp_smu_nv_clock_table *max_clocks)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_max_sustainable_clocks_by_dc)
@@ -2664,8 +2834,12 @@ int smu_get_uclk_dpm_states(struct smu_context *smu,
 			    unsigned int *clock_values_in_khz,
 			    unsigned int *num_states)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_uclk_dpm_states)
@@ -2679,6 +2853,10 @@ int smu_get_uclk_dpm_states(struct smu_context *smu,
 enum amd_pm_state_type smu_get_current_power_state(struct smu_context *smu)
 {
 	enum amd_pm_state_type pm_state = POWER_STATE_TYPE_DEFAULT;
+	struct amdgpu_device *adev = smu->adev;
+
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
 
 	mutex_lock(&smu->mutex);
 
@@ -2693,8 +2871,12 @@ enum amd_pm_state_type smu_get_current_power_state(struct smu_context *smu)
 int smu_get_dpm_clock_table(struct smu_context *smu,
 			    struct dpm_clocks *clock_table)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret = 0;
 
+	if (!adev->pm.dpm_enabled)
+		return -EINVAL;
+
 	mutex_lock(&smu->mutex);
 
 	if (smu->ppt_funcs->get_dpm_clock_table)

commit 94e0805ba929d7907c63fde8ef676feca62412e3
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Apr 13 13:26:22 2020 +0800

    drm/amd/powerplay: correct i2c eeprom init/fini sequence
    
    As data transfer may starts immediately after i2c eeprom init
    completed. Thus i2c eeprom should be initialized after SMU
    ready. And i2c data transfer should be prohibited when SMU
    down. That is the i2c eeprom fini sequence needs to be
    updated also.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e8b27fab6aa1..b69e8d6c0a96 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -932,13 +932,6 @@ static int smu_sw_init(void *handle)
 		return ret;
 	}
 
-	if (adev->smu.ppt_funcs->i2c_eeprom_init) {
-		ret = smu_i2c_eeprom_init(smu, &adev->pm.smu_i2c);
-
-		if (ret)
-			return ret;
-	}
-
 	return 0;
 }
 
@@ -948,9 +941,6 @@ static int smu_sw_fini(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
-	if (adev->smu.ppt_funcs->i2c_eeprom_fini)
-		smu_i2c_eeprom_fini(smu, &adev->pm.smu_i2c);
-
 	kfree(smu->irq_source);
 	smu->irq_source = NULL;
 
@@ -1366,6 +1356,10 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
+	ret = smu_i2c_eeprom_init(smu, &adev->pm.smu_i2c);
+	if (ret)
+		goto failed;
+
 	if (!smu->pm_enabled)
 		adev->pm.dpm_enabled = false;
 	else
@@ -1403,6 +1397,8 @@ static int smu_hw_fini(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
+	smu_i2c_eeprom_fini(smu, &adev->pm.smu_i2c);
+
 	if (!amdgpu_sriov_vf(adev)){
 		ret = smu_stop_thermal_control(smu);
 		if (ret) {
@@ -1542,6 +1538,8 @@ static int smu_suspend(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
+	smu_i2c_eeprom_fini(smu, &adev->pm.smu_i2c);
+
 	if(!amdgpu_sriov_vf(adev)) {
 		ret = smu_disable_dpm(smu);
 		if (ret)
@@ -1587,6 +1585,10 @@ static int smu_resume(void *handle)
 	if (ret)
 		goto failed;
 
+	ret = smu_i2c_eeprom_init(smu, &adev->pm.smu_i2c);
+	if (ret)
+		goto failed;
+
 	if (smu->is_apu)
 		smu_set_gfx_cgpg(&adev->smu, true);
 

commit 9644bf5f4ab8d691c46e53f67b825c90d97e7219
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Mar 20 13:03:12 2020 -0400

    drm/amdgpu/swSMU: handle manual AC/DC notifications
    
    For boards that do not support automatic AC/DC transitions
    in firmware, manually tell the firmware when the status
    changes.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/issues/1043
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9a9eb23d8540..e8b27fab6aa1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -2087,6 +2087,29 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 	return 0;
 }
 
+int smu_set_ac_dc(struct smu_context *smu)
+{
+	int ret = 0;
+
+	/* controlled by firmware */
+	if (smu->dc_controlled_by_gpio)
+		return 0;
+
+	mutex_lock(&smu->mutex);
+	if (smu->ppt_funcs->set_power_source) {
+		if (smu->adev->pm.ac_power)
+			ret = smu_set_power_source(smu, SMU_POWER_SOURCE_AC);
+		else
+			ret = smu_set_power_source(smu, SMU_POWER_SOURCE_DC);
+		if (ret)
+			pr_err("Failed to switch to %s mode!\n",
+			       smu->adev->pm.ac_power ? "AC" : "DC");
+	}
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit 75610fdd38d9d158385049c9f80547a2253c65ea
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Mar 20 12:45:09 2020 -0400

    drm/amdgpu/swSMU: set AC/DC mode based on the current system state (v2)
    
    Check of the pointer exists and we are actually on AC power.
    
    v2: fix error message to reflect AC/DC mode.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/issues/1043
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2cfb911ab370..9a9eb23d8540 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1155,17 +1155,17 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 			}
 		}
 
-		if (adev->asic_type >= CHIP_NAVI10 &&
-		    adev->asic_type <= CHIP_NAVI12) {
+		if (smu->ppt_funcs->set_power_source) {
 			/*
 			 * For Navi1X, manually switch it to AC mode as PMFW
 			 * may boot it with DC mode.
-			 * TODO: should check whether we are indeed under AC
-			 * mode before doing this.
 			 */
-			ret = smu_set_power_source(smu, SMU_POWER_SOURCE_AC);
+			if (adev->pm.ac_power)
+				ret = smu_set_power_source(smu, SMU_POWER_SOURCE_AC);
+			else
+				ret = smu_set_power_source(smu, SMU_POWER_SOURCE_DC);
 			if (ret) {
-				pr_err("Failed to switch to AC mode!\n");
+				pr_err("Failed to switch to %s mode!\n", adev->pm.ac_power ? "AC" : "DC");
 				return ret;
 			}
 		}

commit 66c2f5db1fbdc987d23149082720bcbe46f41aa2
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Mar 20 14:09:21 2020 -0400

    drm/amdgpu/swSMU: correct the bootup power source for Navi1X (v2)
    
    PMFW may boots those ASICs with DC mode. Need to set it back
    to AC mode.
    
    v2: split from Evan's original patch (Alex)
    
    Bug: https://gitlab.freedesktop.org/drm/amd/issues/1043
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f6d4b0ef46ad..2cfb911ab370 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1154,6 +1154,21 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 				}
 			}
 		}
+
+		if (adev->asic_type >= CHIP_NAVI10 &&
+		    adev->asic_type <= CHIP_NAVI12) {
+			/*
+			 * For Navi1X, manually switch it to AC mode as PMFW
+			 * may boot it with DC mode.
+			 * TODO: should check whether we are indeed under AC
+			 * mode before doing this.
+			 */
+			ret = smu_set_power_source(smu, SMU_POWER_SOURCE_AC);
+			if (ret) {
+				pr_err("Failed to switch to AC mode!\n");
+				return ret;
+			}
+		}
 	}
 	if (adev->asic_type != CHIP_ARCTURUS) {
 		ret = smu_notify_display_change(smu);

commit 8e025615cf9f3465a690b46ae8586db7ccd436c6
Author: John Clements <john.clements@amd.com>
Date:   Thu Mar 19 00:22:32 2020 +0800

    amd/powerplay: arcturus baco reset disable all features
    
    issue smu cmd to disable all features upon baco entry for arcturus
    
    to mitigate potential dirty I2C controller on boot
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: John Clements <john.clements@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0273c63baf8e..f6d4b0ef46ad 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1470,21 +1470,26 @@ static int smu_disable_dpm(struct smu_context *smu)
 	}
 
 	/*
-	 * For baco on Arcturus, this operation
-	 * (disable all smu feature) will be handled by SMU FW.
+	 * Disable all enabled SMU features.
+	 * This should be handled in SMU FW, as a backup
+	 * driver can issue call to SMU FW until sequence
+	 * in SMU FW is operational.
 	 */
-	if (adev->asic_type == CHIP_ARCTURUS) {
-		if (use_baco && (smu_version > 0x360e00))
-			return 0;
-	}
-
-	/* Disable all enabled SMU features */
 	ret = smu_system_features_control(smu, false);
 	if (ret) {
 		pr_err("Failed to disable smu features.\n");
 		return ret;
 	}
 
+	/*
+	 * Arcturus does not have BACO bit in disable feature mask.
+	 * Enablement of BACO bit on Arcturus should be skipped.
+	 */
+	if (adev->asic_type == CHIP_ARCTURUS) {
+		if (use_baco && (smu_version > 0x360e00))
+			return 0;
+	}
+
 	/* For baco, need to leave BACO feature enabled */
 	if (use_baco) {
 		/*

commit 9015d60c9ee106cef0c8b969f998ca157f401605
Author: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
Date:   Thu Mar 12 17:11:32 2020 -0400

    drm/amdgpu: Move EEPROM I2C adapter to amdgpu_device
    
    Puts the i2c adapter in common place for sharing by RAS
    and upcoming data read from FRU EEPROM feature.
    
    v2:
    Move i2c adapter to amdgpu_pm and rename it.
    
    v3: Move i2c adapter init to ASIC specific code and get rid
    of the switch case in amdgpu_device
    
    Signed-off-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 8de8436f0839..0273c63baf8e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -932,6 +932,13 @@ static int smu_sw_init(void *handle)
 		return ret;
 	}
 
+	if (adev->smu.ppt_funcs->i2c_eeprom_init) {
+		ret = smu_i2c_eeprom_init(smu, &adev->pm.smu_i2c);
+
+		if (ret)
+			return ret;
+	}
+
 	return 0;
 }
 
@@ -941,6 +948,9 @@ static int smu_sw_fini(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
+	if (adev->smu.ppt_funcs->i2c_eeprom_fini)
+		smu_i2c_eeprom_fini(smu, &adev->pm.smu_i2c);
+
 	kfree(smu->irq_source);
 	smu->irq_source = NULL;
 

commit f88ef3ca869d04e4d66468a478b6b817772ce243
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Mar 10 18:03:05 2020 +0800

    drm/amdgpu/swsmu: clean up unused header in swsmu
    
    clean up unused header in swsmu driver stack:
    1. pp_debug.h
    2. amd_pcie.h
    3. soc15_common.h
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f18e3fadbc26..8de8436f0839 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -23,15 +23,12 @@
 #include <linux/firmware.h>
 #include <linux/pci.h>
 
-#include "pp_debug.h"
 #include "amdgpu.h"
 #include "amdgpu_smu.h"
 #include "smu_internal.h"
-#include "soc15_common.h"
 #include "smu_v11_0.h"
 #include "smu_v12_0.h"
 #include "atom.h"
-#include "amd_pcie.h"
 #include "vega20_ppt.h"
 #include "arcturus_ppt.h"
 #include "navi10_ppt.h"

commit 7bef6ea9721bb72bfe00810b9d928062a95e8549
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Tue Mar 10 08:20:01 2020 +0800

    drm/amd/powerplay: fix the coverity warning about negative check for an unsigned value
    
    There will be a coverity warning because min and max are both unsigned.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d454493bef14..f18e3fadbc26 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -214,9 +214,6 @@ int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 {
 	int ret = 0;
 
-	if (min < 0 && max < 0)
-		return -EINVAL;
-
 	if (!smu_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 

commit ffbed184d209bb44504fd2cd460db70176765818
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Mon Mar 2 09:36:15 2020 +0800

    drm/amd/powerplay: fix pre-check condition for setting clock range
    
    This fix will handle some MP1 FW issue like as mclk dpm table in renoir has a reverse
    dpm clock layout and a zero frequency dpm level as following case.
    
    cat pp_dpm_mclk
    0: 1200Mhz
    1: 1200Mhz
    2: 800Mhz
    3: 0Mhz
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e3398f9c4284..d454493bef14 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -214,7 +214,7 @@ int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 {
 	int ret = 0;
 
-	if (min <= 0 && max <= 0)
+	if (min < 0 && max < 0)
 		return -EINVAL;
 
 	if (!smu_clk_dpm_is_enabled(smu, clk_type))

commit 31faff1a1c2df06be0d7dfb083051675addcbff9
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Fri Feb 28 14:54:50 2020 +0800

    drm/amdgpu: add lock option for smu_set_soft_freq_range()
    
    Add lock_needed param for smu_set_soft_freq_range()
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9f6da26be90b..e3398f9c4284 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -210,7 +210,7 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 }
 
 int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
-			    uint32_t min, uint32_t max)
+			    uint32_t min, uint32_t max, bool lock_needed)
 {
 	int ret = 0;
 
@@ -220,7 +220,12 @@ int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (!smu_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 
+	if (lock_needed)
+		mutex_lock(&smu->mutex);
 	ret = smu_set_soft_freq_limited_range(smu, clk_type, min, max);
+	if (lock_needed)
+		mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 

commit eb696d041fa5e1bc3be90881e1432a9bb169b771
Author: Matt Coffin <mcoffin13@gmail.com>
Date:   Wed Feb 26 16:16:14 2020 -0700

    drm/amdgpu/smu: Add message sending lock
    
    This adds a message lock to the smu_send_smc_msg* implementations to
    protect against concurrent access to the mmu registers used to
    communicate with the SMU
    
    v2: Implement for smu_v12_0 as well
    
    v3: Add mutex_init for message_lock
    
    Signed-off-by: Matt Coffin <mcoffin13@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f3505bb632ef..9f6da26be90b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -889,6 +889,7 @@ static int smu_sw_init(void *handle)
 
 	mutex_init(&smu->sensor_lock);
 	mutex_init(&smu->metrics_lock);
+	mutex_init(&smu->message_lock);
 
 	smu->watermarks_bitmap = 0;
 	smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;

commit 1c58267cbe46f0b5741628a72d10b5464712a012
Author: Matt Coffin <mcoffin13@gmail.com>
Date:   Wed Feb 26 16:16:12 2020 -0700

    drm/amdgpu/powerplay: Refactor SMU message handling for safety
    
    Move the responsibility for reading argument registers into the
    smu_send_smc_msg* implementations, so that adding a message-sending lock
    to protect the SMU registers will result in the lock still being held
    when the argument is read.
    
    v2: transition smu_v12_0, it's asics, and vega20
    
    Signed-off-by: Matt Coffin <mcoffin13@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 882d5db427db..f3505bb632ef 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -121,20 +121,20 @@ static int smu_feature_update_enable_state(struct smu_context *smu,
 
 	if (enabled) {
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesLow,
-						  feature_low);
+						  feature_low, NULL);
 		if (ret)
 			return ret;
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesHigh,
-						  feature_high);
+						  feature_high, NULL);
 		if (ret)
 			return ret;
 	} else {
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesLow,
-						  feature_low);
+						  feature_low, NULL);
 		if (ret)
 			return ret;
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesHigh,
-						  feature_high);
+						  feature_high, NULL);
 		if (ret)
 			return ret;
 	}
@@ -195,21 +195,13 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 		return -EINVAL;
 
 	if (if_version) {
-		ret = smu_send_smc_msg(smu, SMU_MSG_GetDriverIfVersion);
-		if (ret)
-			return ret;
-
-		ret = smu_read_smc_arg(smu, if_version);
+		ret = smu_send_smc_msg(smu, SMU_MSG_GetDriverIfVersion, if_version);
 		if (ret)
 			return ret;
 	}
 
 	if (smu_version) {
-		ret = smu_send_smc_msg(smu, SMU_MSG_GetSmuVersion);
-		if (ret)
-			return ret;
-
-		ret = smu_read_smc_arg(smu, smu_version);
+		ret = smu_send_smc_msg(smu, SMU_MSG_GetSmuVersion, smu_version);
 		if (ret)
 			return ret;
 	}
@@ -251,7 +243,7 @@ int smu_set_hard_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (max > 0) {
 		param = (uint32_t)((clk_id << 16) | (max & 0xffff));
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetHardMaxByFreq,
-						  param);
+						  param, NULL);
 		if (ret)
 			return ret;
 	}
@@ -259,7 +251,7 @@ int smu_set_hard_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (min > 0) {
 		param = (uint32_t)((clk_id << 16) | (min & 0xffff));
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinByFreq,
-						  param);
+						  param, NULL);
 		if (ret)
 			return ret;
 	}
@@ -335,12 +327,8 @@ int smu_get_dpm_freq_by_index(struct smu_context *smu, enum smu_clk_type clk_typ
 
 	param = (uint32_t)(((clk_id & 0xffff) << 16) | (level & 0xffff));
 
-	ret = smu_send_smc_msg_with_param(smu,SMU_MSG_GetDpmFreqByIndex,
-					  param);
-	if (ret)
-		return ret;
-
-	ret = smu_read_smc_arg(smu, &param);
+	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetDpmFreqByIndex,
+					  param, &param);
 	if (ret)
 		return ret;
 
@@ -542,7 +530,8 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
 					  SMU_MSG_TransferTableDram2Smu :
 					  SMU_MSG_TransferTableSmu2Dram,
-					  table_id | ((argument & 0xFFFF) << 16));
+					  table_id | ((argument & 0xFFFF) << 16),
+					  NULL);
 	if (ret)
 		return ret;
 
@@ -1992,7 +1981,7 @@ int smu_set_mp1_state(struct smu_context *smu,
 		return 0;
 	}
 
-	ret = smu_send_smc_msg(smu, msg);
+	ret = smu_send_smc_msg(smu, msg, NULL);
 	if (ret)
 		pr_err("[PrepareMp1] Failed!\n");
 
@@ -2670,12 +2659,3 @@ uint32_t smu_get_pptable_power_limit(struct smu_context *smu)
 
 	return ret;
 }
-
-int smu_send_smc_msg(struct smu_context *smu,
-		     enum smu_message_type msg)
-{
-	int ret;
-
-	ret = smu_send_smc_msg_with_param(smu, msg, 0);
-	return ret;
-}

commit 2622e2ae27b5bcc31090cd904d54d29111cc7113
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Feb 13 10:42:25 2020 -0500

    drm/amdgpu/powerplay: nv1x, renior copy dcn clock settings of watermark to smu during boot up
    
    dc to pplib interface is changed for navi1x, renoir.
    display_config_changed is not called by dc anymore.
    smu_write_watermarks_table is not executed for navi1x, renoir
    during boot up.
    
    solution: call smu_write_watermarks_table just after dc pass
    watermark clock settings to pplib
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9f2428fd98f6..882d5db427db 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -2056,8 +2056,11 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 			smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&
 			smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
 		smu_set_watermarks_table(smu, table, clock_ranges);
-		smu->watermarks_bitmap |= WATERMARKS_EXIST;
-		smu->watermarks_bitmap &= ~WATERMARKS_LOADED;
+
+		if (!(smu->watermarks_bitmap & WATERMARKS_EXIST)) {
+			smu->watermarks_bitmap |= WATERMARKS_EXIST;
+			smu->watermarks_bitmap &= ~WATERMARKS_LOADED;
+		}
 	}
 
 	mutex_unlock(&smu->mutex);

commit c16904b0f305c5f6bc31de118d4b1e60a5da5408
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Feb 12 11:52:20 2020 +0800

    drm/amd/powerplay: correct the way for checking SMU_FEATURE_BACO_BIT support
    
    Since 'smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT)' will always return
    false considering the 'smu_system_features_control(smu, false)' disabled
    all SMU features.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4720aa58a150..9f2428fd98f6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1488,7 +1488,18 @@ static int smu_disable_dpm(struct smu_context *smu)
 
 	/* For baco, need to leave BACO feature enabled */
 	if (use_baco) {
-		if (smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT)) {
+		/*
+		 * Correct the way for checking whether SMU_FEATURE_BACO_BIT
+		 * is supported.
+		 *
+		 * Since 'smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT)' will
+		 * always return false as the 'smu_system_features_control(smu, false)'
+		 * was just issued above which disabled all SMU features.
+		 *
+		 * Thus 'smu_feature_get_index(smu, SMU_FEATURE_BACO_BIT)' is used
+		 * now for the checking.
+		 */
+		if (smu_feature_get_index(smu, SMU_FEATURE_BACO_BIT) >= 0) {
 			ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
 			if (ret) {
 				pr_warn("set BACO feature enabled failed, return %d\n", ret);

commit 5d8b936df28482739517d62941c907ac460e7430
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Feb 7 10:04:37 2020 -0500

    drm/amdgpu/smu: properly handle runpm/suspend/reset
    
    We need some special handling when using baco vs. other
    things.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 7b1ae2ec78e1..4720aa58a150 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1454,11 +1454,15 @@ int smu_reset(struct smu_context *smu)
 	return ret;
 }
 
-static int smu_disabled_dpms(struct smu_context *smu)
+static int smu_disable_dpm(struct smu_context *smu)
 {
 	struct amdgpu_device *adev = smu->adev;
 	uint32_t smu_version;
 	int ret = 0;
+	bool use_baco = !smu->is_apu &&
+		((adev->in_gpu_reset &&
+		  (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO)) ||
+		 (adev->in_runpm && amdgpu_asic_supports_baco(adev)));
 
 	ret = smu_get_smc_version(smu, NULL, &smu_version);
 	if (ret) {
@@ -1467,13 +1471,13 @@ static int smu_disabled_dpms(struct smu_context *smu)
 	}
 
 	/*
-	 * For baco reset on Arcturus, this operation
+	 * For baco on Arcturus, this operation
 	 * (disable all smu feature) will be handled by SMU FW.
 	 */
-	if (adev->in_gpu_reset &&
-	    (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) &&
-	    (adev->asic_type == CHIP_ARCTURUS && smu_version > 0x360e00))
-		return 0;
+	if (adev->asic_type == CHIP_ARCTURUS) {
+		if (use_baco && (smu_version > 0x360e00))
+			return 0;
+	}
 
 	/* Disable all enabled SMU features */
 	ret = smu_system_features_control(smu, false);
@@ -1482,15 +1486,14 @@ static int smu_disabled_dpms(struct smu_context *smu)
 		return ret;
 	}
 
-	/* For baco reset, need to leave BACO feature enabled */
-	if (adev->in_gpu_reset &&
-	    (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) &&
-	    !smu->is_apu &&
-	    smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT)) {
-		ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
-		if (ret) {
-			pr_warn("set BACO feature enabled failed, return %d\n", ret);
-			return ret;
+	/* For baco, need to leave BACO feature enabled */
+	if (use_baco) {
+		if (smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT)) {
+			ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
+			if (ret) {
+				pr_warn("set BACO feature enabled failed, return %d\n", ret);
+				return ret;
+			}
 		}
 	}
 
@@ -1510,7 +1513,7 @@ static int smu_suspend(void *handle)
 		return 0;
 
 	if(!amdgpu_sriov_vf(adev)) {
-		ret = smu_disabled_dpms(smu);
+		ret = smu_disable_dpm(smu);
 		if (ret)
 			return ret;
 	}

commit 4bcbc25ce7fbc45daf2d0a4b42097d61370c210d
Author: Jack Zhang <Jack.Zhang1@amd.com>
Date:   Fri Feb 7 13:49:02 2020 +0800

    drm/amdgpu/sriov set driver_table address in VF
    
    With the recent patch to unify VRAM address for driver
    table(a83f82e). VF cannot dump table info any more because
    SMU_MSG_SetDriverDramAddrHigh/Low were deleted in the
    function of smu_update_table.
    
    Therefore, VF also needs to set driver_table address
    in smu_hw_init to fix this regression issue.
    
    Signed-off-by: Jack Zhang <Jack.Zhang1@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0e9d33ee08ab..7b1ae2ec78e1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1113,12 +1113,12 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 			return ret;
 	}
 
+	ret = smu_set_driver_table_location(smu);
+	if (ret)
+		return ret;
+
 	/* smu_dump_pptable(smu); */
 	if (!amdgpu_sriov_vf(adev)) {
-		ret = smu_set_driver_table_location(smu);
-		if (ret)
-			return ret;
-
 		/*
 		 * Copy pptable bo in the vram to smc with SMU MSGs such as
 		 * SetDriverDramAddr and TransferTableDram2Smu.

commit 4a6f8f01efef194da1993b0231b0569b29f7555c
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Feb 6 11:09:25 2020 +0800

    drm/amd/powerplay: handle features disablement for baco reset in SMU FW
    
    SMU FW will handle the features disablement for baco reset
    on Arcturus.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index a6d7b5f3aa82..0e9d33ee08ab 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1454,12 +1454,54 @@ int smu_reset(struct smu_context *smu)
 	return ret;
 }
 
+static int smu_disabled_dpms(struct smu_context *smu)
+{
+	struct amdgpu_device *adev = smu->adev;
+	uint32_t smu_version;
+	int ret = 0;
+
+	ret = smu_get_smc_version(smu, NULL, &smu_version);
+	if (ret) {
+		pr_err("Failed to get smu version.\n");
+		return ret;
+	}
+
+	/*
+	 * For baco reset on Arcturus, this operation
+	 * (disable all smu feature) will be handled by SMU FW.
+	 */
+	if (adev->in_gpu_reset &&
+	    (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) &&
+	    (adev->asic_type == CHIP_ARCTURUS && smu_version > 0x360e00))
+		return 0;
+
+	/* Disable all enabled SMU features */
+	ret = smu_system_features_control(smu, false);
+	if (ret) {
+		pr_err("Failed to disable smu features.\n");
+		return ret;
+	}
+
+	/* For baco reset, need to leave BACO feature enabled */
+	if (adev->in_gpu_reset &&
+	    (amdgpu_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) &&
+	    !smu->is_apu &&
+	    smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT)) {
+		ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
+		if (ret) {
+			pr_warn("set BACO feature enabled failed, return %d\n", ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
 static int smu_suspend(void *handle)
 {
-	int ret;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
-	bool baco_feature_is_enabled = false;
+	int ret;
 
 	if (amdgpu_sriov_vf(adev)&& !amdgpu_sriov_is_pp_one_vf(adev))
 		return 0;
@@ -1467,21 +1509,10 @@ static int smu_suspend(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
-	if(!smu->is_apu)
-		baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
-
 	if(!amdgpu_sriov_vf(adev)) {
-		ret = smu_system_features_control(smu, false);
+		ret = smu_disabled_dpms(smu);
 		if (ret)
 			return ret;
-
-		if (baco_feature_is_enabled) {
-			ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
-			if (ret) {
-				pr_warn("set BACO feature enabled failed, return %d\n", ret);
-				return ret;
-			}
-		}
 	}
 
 	smu->watermarks_bitmap &= ~(WATERMARKS_LOADED);

commit 86b93fd62d7ca86291759db1eee38cb1c3b2bf6b
Author: Jack Zhang <Jack.Zhang1@amd.com>
Date:   Wed Feb 5 16:34:27 2020 +0800

    drm/amdgpu/sriov Don't send msg when smu suspend
    
    For sriov and pp_onevf_mode, do not send message to set smu
    status, because smu doesn't support these messages under VF.
    
    Besides, it should skip smu_suspend when pp_onevf_mode is disabled.
    
    Signed-off-by: Jack Zhang <Jack.Zhang1@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 99ad4ddbe12f..a6d7b5f3aa82 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1461,21 +1461,26 @@ static int smu_suspend(void *handle)
 	struct smu_context *smu = &adev->smu;
 	bool baco_feature_is_enabled = false;
 
+	if (amdgpu_sriov_vf(adev)&& !amdgpu_sriov_is_pp_one_vf(adev))
+		return 0;
+
 	if (!smu->pm_enabled)
 		return 0;
 
 	if(!smu->is_apu)
 		baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
 
-	ret = smu_system_features_control(smu, false);
-	if (ret)
-		return ret;
-
-	if (baco_feature_is_enabled) {
-		ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
-		if (ret) {
-			pr_warn("set BACO feature enabled failed, return %d\n", ret);
+	if(!amdgpu_sriov_vf(adev)) {
+		ret = smu_system_features_control(smu, false);
+		if (ret)
 			return ret;
+
+		if (baco_feature_is_enabled) {
+			ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
+			if (ret) {
+				pr_warn("set BACO feature enabled failed, return %d\n", ret);
+				return ret;
+			}
 		}
 	}
 

commit 1cf8c930b378016846c88ef0f1444248033326ec
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Jan 30 16:46:38 2020 +0800

    drm/amd/powerplay: fix navi10 system intermittent reboot issue V2
    
    This workaround is needed only for Navi10 12 Gbps SKUs.
    
    V2: added SMU firmware version guard
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 99469479e277..99ad4ddbe12f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -21,6 +21,7 @@
  */
 
 #include <linux/firmware.h>
+#include <linux/pci.h>
 
 #include "pp_debug.h"
 #include "amdgpu.h"
@@ -1137,6 +1138,23 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		ret = smu_system_features_control(smu, true);
 		if (ret)
 			return ret;
+
+		if (adev->asic_type == CHIP_NAVI10) {
+			if ((adev->pdev->device == 0x731f && (adev->pdev->revision == 0xc2 ||
+							      adev->pdev->revision == 0xc3 ||
+							      adev->pdev->revision == 0xca ||
+							      adev->pdev->revision == 0xcb)) ||
+			    (adev->pdev->device == 0x66af && (adev->pdev->revision == 0xf3 ||
+							      adev->pdev->revision == 0xf4 ||
+							      adev->pdev->revision == 0xf5 ||
+							      adev->pdev->revision == 0xf6))) {
+				ret = smu_disable_umc_cdr_12gbps_workaround(smu);
+				if (ret) {
+					pr_err("Workaround failed to disable UMC CDR feature on 12Gbps SKU!\n");
+					return ret;
+				}
+			}
+		}
 	}
 	if (adev->asic_type != CHIP_ARCTURUS) {
 		ret = smu_notify_display_change(smu);

commit a64c9e15e6247e89ad16021b8d5d6d53c34d7ee7
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Jan 3 17:03:21 2020 +0800

    drm/amd/powerplay: cleanup the interfaces for powergate setting through SMU
    
    Provided an unified entry point. And fixed the confusing that the API
    usage is conflict with what the naming implies.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b4cc0dc00189..99469479e277 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -433,10 +433,10 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 
 	switch (block_type) {
 	case AMD_IP_BLOCK_TYPE_UVD:
-		ret = smu_dpm_set_uvd_enable(smu, gate);
+		ret = smu_dpm_set_uvd_enable(smu, !gate);
 		break;
 	case AMD_IP_BLOCK_TYPE_VCE:
-		ret = smu_dpm_set_vce_enable(smu, gate);
+		ret = smu_dpm_set_vce_enable(smu, !gate);
 		break;
 	case AMD_IP_BLOCK_TYPE_GFX:
 		ret = smu_gfx_off_control(smu, gate);
@@ -445,7 +445,7 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 		ret = smu_powergate_sdma(smu, gate);
 		break;
 	case AMD_IP_BLOCK_TYPE_JPEG:
-		ret = smu_dpm_set_jpeg_enable(smu, gate);
+		ret = smu_dpm_set_jpeg_enable(smu, !gate);
 		break;
 	default:
 		break;

commit e0aa4a92f76b8b1a361f6ae6b0a51854e3113416
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Jan 3 14:24:56 2020 +0800

    drm/amd/powerplay: issue proper hdp flush for table transferring
    
    Guard the content consistence between the view of GPU and CPU
    during the table transferring.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9320cf3ef036..b4cc0dc00189 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -529,8 +529,14 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 
 	table_size = smu_table->tables[table_index].size;
 
-	if (drv2smu)
+	if (drv2smu) {
 		memcpy(table->cpu_addr, table_data, table_size);
+		/*
+		 * Flush hdp cache: to guard the content seen by
+		 * GPU is consitent with CPU.
+		 */
+		amdgpu_asic_flush_hdp(adev, NULL);
+	}
 
 	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
 					  SMU_MSG_TransferTableDram2Smu :
@@ -539,11 +545,10 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	if (ret)
 		return ret;
 
-	/* flush hdp cache */
-	adev->nbio.funcs->hdp_flush(adev, NULL);
-
-	if (!drv2smu)
+	if (!drv2smu) {
+		amdgpu_asic_flush_hdp(adev, NULL);
 		memcpy(table_data, table->cpu_addr, table_size);
+	}
 
 	return ret;
 }

commit 29a45960647b243af5f2aa73fd7a822ef3db33eb
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Jan 3 14:18:22 2020 +0800

    drm/amd/powerplay: refine code to support no-dpm case
    
    With "dpm=0", there will be no DPM enabled. The code
    needs to be refined to support this.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b13e3af79587..9320cf3ef036 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1363,6 +1363,9 @@ static int smu_hw_fini(void *handle)
 		smu_powergate_jpeg(&adev->smu, true);
 	}
 
+	if (!smu->pm_enabled)
+		return 0;
+
 	if (!amdgpu_sriov_vf(adev)){
 		ret = smu_stop_thermal_control(smu);
 		if (ret) {
@@ -1435,6 +1438,9 @@ static int smu_suspend(void *handle)
 	struct smu_context *smu = &adev->smu;
 	bool baco_feature_is_enabled = false;
 
+	if (!smu->pm_enabled)
+		return 0;
+
 	if(!smu->is_apu)
 		baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
 

commit ce0d0ec3390c5cf997e4ca43bd2047fa41e77bf1
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Dec 31 10:39:34 2019 +0800

    drm/amd/powerplay: unified VRAM address for driver table interaction with SMU V2
    
    By this, we can avoid to pass in the VRAM address on every table
    transferring. That puts extra unnecessary traffics on SMU on
    some cases(e.g. polling the amdgpu_pm_info sysfs interface).
    
    V2: document what the driver table is for and how it works
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3b6275831004..b13e3af79587 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -519,26 +519,19 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct amdgpu_device *adev = smu->adev;
-	struct smu_table *table = NULL;
-	int ret = 0;
+	struct smu_table *table = &smu_table->driver_table;
 	int table_id = smu_table_get_index(smu, table_index);
+	uint32_t table_size;
+	int ret = 0;
 
 	if (!table_data || table_id >= SMU_TABLE_COUNT || table_id < 0)
 		return -EINVAL;
 
-	table = &smu_table->tables[table_index];
+	table_size = smu_table->tables[table_index].size;
 
 	if (drv2smu)
-		memcpy(table->cpu_addr, table_data, table->size);
+		memcpy(table->cpu_addr, table_data, table_size);
 
-	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetDriverDramAddrHigh,
-					  upper_32_bits(table->mc_address));
-	if (ret)
-		return ret;
-	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetDriverDramAddrLow,
-					  lower_32_bits(table->mc_address));
-	if (ret)
-		return ret;
 	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
 					  SMU_MSG_TransferTableDram2Smu :
 					  SMU_MSG_TransferTableSmu2Dram,
@@ -550,7 +543,7 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	adev->nbio.funcs->hdp_flush(adev, NULL);
 
 	if (!drv2smu)
-		memcpy(table_data, table->cpu_addr, table->size);
+		memcpy(table_data, table->cpu_addr, table_size);
 
 	return ret;
 }
@@ -976,32 +969,56 @@ static int smu_init_fb_allocations(struct smu_context *smu)
 	struct amdgpu_device *adev = smu->adev;
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *tables = smu_table->tables;
+	struct smu_table *driver_table = &(smu_table->driver_table);
+	uint32_t max_table_size = 0;
 	int ret, i;
 
-	for (i = 0; i < SMU_TABLE_COUNT; i++) {
-		if (tables[i].size == 0)
-			continue;
+	/* VRAM allocation for tool table */
+	if (tables[SMU_TABLE_PMSTATUSLOG].size) {
 		ret = amdgpu_bo_create_kernel(adev,
-					      tables[i].size,
-					      tables[i].align,
-					      tables[i].domain,
-					      &tables[i].bo,
-					      &tables[i].mc_address,
-					      &tables[i].cpu_addr);
-		if (ret)
-			goto failed;
+					      tables[SMU_TABLE_PMSTATUSLOG].size,
+					      tables[SMU_TABLE_PMSTATUSLOG].align,
+					      tables[SMU_TABLE_PMSTATUSLOG].domain,
+					      &tables[SMU_TABLE_PMSTATUSLOG].bo,
+					      &tables[SMU_TABLE_PMSTATUSLOG].mc_address,
+					      &tables[SMU_TABLE_PMSTATUSLOG].cpu_addr);
+		if (ret) {
+			pr_err("VRAM allocation for tool table failed!\n");
+			return ret;
+		}
 	}
 
-	return 0;
-failed:
-	while (--i >= 0) {
+	/* VRAM allocation for driver table */
+	for (i = 0; i < SMU_TABLE_COUNT; i++) {
 		if (tables[i].size == 0)
 			continue;
-		amdgpu_bo_free_kernel(&tables[i].bo,
-				      &tables[i].mc_address,
-				      &tables[i].cpu_addr);
 
+		if (i == SMU_TABLE_PMSTATUSLOG)
+			continue;
+
+		if (max_table_size < tables[i].size)
+			max_table_size = tables[i].size;
+	}
+
+	driver_table->size = max_table_size;
+	driver_table->align = PAGE_SIZE;
+	driver_table->domain = AMDGPU_GEM_DOMAIN_VRAM;
+
+	ret = amdgpu_bo_create_kernel(adev,
+				      driver_table->size,
+				      driver_table->align,
+				      driver_table->domain,
+				      &driver_table->bo,
+				      &driver_table->mc_address,
+				      &driver_table->cpu_addr);
+	if (ret) {
+		pr_err("VRAM allocation for driver table failed!\n");
+		if (tables[SMU_TABLE_PMSTATUSLOG].mc_address)
+			amdgpu_bo_free_kernel(&tables[SMU_TABLE_PMSTATUSLOG].bo,
+					      &tables[SMU_TABLE_PMSTATUSLOG].mc_address,
+					      &tables[SMU_TABLE_PMSTATUSLOG].cpu_addr);
 	}
+
 	return ret;
 }
 
@@ -1009,18 +1026,19 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *tables = smu_table->tables;
-	uint32_t i = 0;
+	struct smu_table *driver_table = &(smu_table->driver_table);
 
 	if (!tables)
 		return 0;
 
-	for (i = 0; i < SMU_TABLE_COUNT; i++) {
-		if (tables[i].size == 0)
-			continue;
-		amdgpu_bo_free_kernel(&tables[i].bo,
-				      &tables[i].mc_address,
-				      &tables[i].cpu_addr);
-	}
+	if (tables[SMU_TABLE_PMSTATUSLOG].mc_address)
+		amdgpu_bo_free_kernel(&tables[SMU_TABLE_PMSTATUSLOG].bo,
+				      &tables[SMU_TABLE_PMSTATUSLOG].mc_address,
+				      &tables[SMU_TABLE_PMSTATUSLOG].cpu_addr);
+
+	amdgpu_bo_free_kernel(&driver_table->bo,
+			      &driver_table->mc_address,
+			      &driver_table->cpu_addr);
 
 	return 0;
 }
@@ -1091,6 +1109,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 
 	/* smu_dump_pptable(smu); */
 	if (!amdgpu_sriov_vf(adev)) {
+		ret = smu_set_driver_table_location(smu);
+		if (ret)
+			return ret;
+
 		/*
 		 * Copy pptable bo in the vram to smc with SMU MSGs such as
 		 * SetDriverDramAddr and TransferTableDram2Smu.

commit 9fa1ed5bf628a871be52bb2d84ade8b108db8902
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Dec 31 10:33:19 2019 +0800

    drm/amd/powerplay: cache the watermark settings on system memory
    
    So that we do not need to allocate a piece of VRAM for it. This
    is a preparation for coming change which unifies the VRAM address
    for all driver tables interaction with SMU.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d432ba08968a..3b6275831004 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1929,32 +1929,25 @@ int smu_set_df_cstate(struct smu_context *smu,
 
 int smu_write_watermarks_table(struct smu_context *smu)
 {
-	int ret = 0;
-	struct smu_table_context *smu_table = &smu->smu_table;
-	struct smu_table *table = NULL;
+	void *watermarks_table = smu->smu_table.watermarks_table;
 
-	table = &smu_table->tables[SMU_TABLE_WATERMARKS];
-
-	if (!table->cpu_addr)
+	if (!watermarks_table)
 		return -EINVAL;
 
-	ret = smu_update_table(smu, SMU_TABLE_WATERMARKS, 0, table->cpu_addr,
+	return smu_update_table(smu,
+				SMU_TABLE_WATERMARKS,
+				0,
+				watermarks_table,
 				true);
-
-	return ret;
 }
 
 int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 		struct dm_pp_wm_sets_with_clock_ranges_soc15 *clock_ranges)
 {
-	struct smu_table *watermarks;
-	void *table;
-
-	if (!smu->smu_table.tables)
-		return 0;
+	void *table = smu->smu_table.watermarks_table;
 
-	watermarks = &smu->smu_table.tables[SMU_TABLE_WATERMARKS];
-	table = watermarks->cpu_addr;
+	if (!table)
+		return -EINVAL;
 
 	mutex_lock(&smu->mutex);
 

commit 895bd048fb0846c912cb896ff58f4341537d0ff1
Author: Jack Zhang <Jack.Zhang1@amd.com>
Date:   Fri Dec 27 14:44:03 2019 +0800

    amd/amdgpu/sriov tdr enablement with pp_onevf_mode
    
    Under sriov and pp_onevf mode,
    1.take resume instead of hw_init for smc recover to avoid
    potential memory leak.
    
    2.add return condition inside smc resume function for
    sriov_pp_onevf_mode and pm_enabled param.
    
    Signed-off-by: Jack Zhang <Jack.Zhang1@amd.com>
    Acked-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ec3dbbeb8f76..d432ba08968a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1445,6 +1445,12 @@ static int smu_resume(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
+	if (amdgpu_sriov_vf(adev)&& !amdgpu_sriov_is_pp_one_vf(adev))
+		return 0;
+
+	if (!smu->pm_enabled)
+		return 0;
+
 	pr_info("SMU is resuming...\n");
 
 	ret = smu_start_smc_engine(smu);

commit c2a801af318397bc5195a20c556a648b2476863d
Author: Jack Zhang <Jack.Zhang1@amd.com>
Date:   Tue Dec 10 10:51:01 2019 +0800

    amd/amdgpu/sriov enable onevf mode for ARCTURUS VF
    
    Before, initialization of smu ip block would be skipped
    for sriov ASICs. But if there's only one VF being used,
    guest driver should be able to dump some HW info such as
    clks, temperature,etc.
    
    To solve this, now after onevf mode is enabled, host
    driver will notify guest. If it's onevf mode, guest will
    do smu hw_init and skip some steps in normal smu hw_init
    flow because host driver has already done it for smu.
    
    With this fix, guest app can talk with smu and dump hw
    information from smu.
    
    v2: refine the logic for pm_enabled.Skip hw_init by not
    changing pm_enabled.
    v3: refine is_support_sw_smu and fix some indentation
    issue.
    
    Signed-off-by: Jack Zhang <Jack.Zhang1@amd.com>
    Acked-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 8cfe5f09308f..ec3dbbeb8f76 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -560,7 +560,7 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 	if (adev->asic_type == CHIP_VEGA20)
 		return (amdgpu_dpm == 2) ? true : false;
 	else if (adev->asic_type >= CHIP_ARCTURUS) {
-		if (amdgpu_sriov_vf(adev))
+		if (amdgpu_sriov_vf(adev)&& !amdgpu_sriov_is_pp_one_vf(adev))
 			return false;
 		else
 			return true;
@@ -1090,28 +1090,27 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	}
 
 	/* smu_dump_pptable(smu); */
+	if (!amdgpu_sriov_vf(adev)) {
+		/*
+		 * Copy pptable bo in the vram to smc with SMU MSGs such as
+		 * SetDriverDramAddr and TransferTableDram2Smu.
+		 */
+		ret = smu_write_pptable(smu);
+		if (ret)
+			return ret;
 
-	/*
-	 * Copy pptable bo in the vram to smc with SMU MSGs such as
-	 * SetDriverDramAddr and TransferTableDram2Smu.
-	 */
-	ret = smu_write_pptable(smu);
-	if (ret)
-		return ret;
-
-	/* issue Run*Btc msg */
-	ret = smu_run_btc(smu);
-	if (ret)
-		return ret;
-
-	ret = smu_feature_set_allowed_mask(smu);
-	if (ret)
-		return ret;
-
-	ret = smu_system_features_control(smu, true);
-	if (ret)
-		return ret;
+		/* issue Run*Btc msg */
+		ret = smu_run_btc(smu);
+		if (ret)
+			return ret;
+		ret = smu_feature_set_allowed_mask(smu);
+		if (ret)
+			return ret;
 
+		ret = smu_system_features_control(smu, true);
+		if (ret)
+			return ret;
+	}
 	if (adev->asic_type != CHIP_ARCTURUS) {
 		ret = smu_notify_display_change(smu);
 		if (ret)
@@ -1164,8 +1163,9 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	/*
 	 * Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
 	 */
-	ret = smu_set_tool_table_location(smu);
-
+	if (!amdgpu_sriov_vf(adev)) {
+		ret = smu_set_tool_table_location(smu);
+	}
 	if (!smu_is_dpm_running(smu))
 		pr_info("dpm has been disabled\n");
 
@@ -1277,6 +1277,9 @@ static int smu_hw_init(void *handle)
 		smu_set_gfx_cgpg(&adev->smu, true);
 	}
 
+	if (amdgpu_sriov_vf(adev) && !amdgpu_sriov_is_pp_one_vf(adev))
+		return 0;
+
 	if (!smu->pm_enabled)
 		return 0;
 
@@ -1329,37 +1332,42 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
+	if (amdgpu_sriov_vf(adev)&& !amdgpu_sriov_is_pp_one_vf(adev))
+		return 0;
+
 	if (smu->is_apu) {
 		smu_powergate_sdma(&adev->smu, true);
 		smu_powergate_vcn(&adev->smu, true);
 		smu_powergate_jpeg(&adev->smu, true);
 	}
 
-	ret = smu_stop_thermal_control(smu);
-	if (ret) {
-		pr_warn("Fail to stop thermal control!\n");
-		return ret;
-	}
-
-	/*
-	 * For custom pptable uploading, skip the DPM features
-	 * disable process on Navi1x ASICs.
-	 *   - As the gfx related features are under control of
-	 *     RLC on those ASICs. RLC reinitialization will be
-	 *     needed to reenable them. That will cost much more
-	 *     efforts.
-	 *
-	 *   - SMU firmware can handle the DPM reenablement
-	 *     properly.
-	 */
-	if (!smu->uploading_custom_pp_table ||
-	    !((adev->asic_type >= CHIP_NAVI10) &&
-	      (adev->asic_type <= CHIP_NAVI12))) {
-		ret = smu_stop_dpms(smu);
+	if (!amdgpu_sriov_vf(adev)){
+		ret = smu_stop_thermal_control(smu);
 		if (ret) {
-			pr_warn("Fail to stop Dpms!\n");
+			pr_warn("Fail to stop thermal control!\n");
 			return ret;
 		}
+
+		/*
+		 * For custom pptable uploading, skip the DPM features
+		 * disable process on Navi1x ASICs.
+		 *   - As the gfx related features are under control of
+		 *     RLC on those ASICs. RLC reinitialization will be
+		 *     needed to reenable them. That will cost much more
+		 *     efforts.
+		 *
+		 *   - SMU firmware can handle the DPM reenablement
+		 *     properly.
+		 */
+		if (!smu->uploading_custom_pp_table ||
+				!((adev->asic_type >= CHIP_NAVI10) &&
+					(adev->asic_type <= CHIP_NAVI12))) {
+			ret = smu_stop_dpms(smu);
+			if (ret) {
+				pr_warn("Fail to stop Dpms!\n");
+				return ret;
+			}
+		}
 	}
 
 	kfree(table_context->driver_pptable);

commit 6a876844e489febae38b7a67e92a29ddc2eb0e6b
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Dec 30 17:08:29 2019 +0800

    drm/amd/powerplay: retrieve the enabled feature mask from cache
    
    This is why those feature mask members designed for. And this
    can reduce the SMU workload.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 826944196911..8cfe5f09308f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1319,7 +1319,7 @@ static int smu_hw_init(void *handle)
 
 static int smu_stop_dpms(struct smu_context *smu)
 {
-	return smu_send_smc_msg(smu, SMU_MSG_DisableAllSmuFeatures);
+	return smu_system_features_control(smu, false);
 }
 
 static int smu_hw_fini(void *handle)

commit e42877b8ba876cf43a0f1261963d66ef11e3b779
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Dec 30 11:27:32 2019 +0800

    drm/amd/powerplay: avoid deadlock on Vega20 swSMU routine
    
    The lock required was already hold by its parent API.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index dcc4ccd5c44e..826944196911 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -2279,13 +2279,9 @@ int smu_set_active_display_count(struct smu_context *smu, uint32_t count)
 {
 	int ret = 0;
 
-	mutex_lock(&smu->mutex);
-
 	if (smu->ppt_funcs->set_active_display_count)
 		ret = smu->ppt_funcs->set_active_display_count(smu, count);
 
-	mutex_unlock(&smu->mutex);
-
 	return ret;
 }
 

commit e4b613e0b27232cf6d31c385493159cabbc78884
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Dec 26 14:41:22 2019 +0800

    drm/amdgpu/smu: add helper function smu_get_dpm_level_range() for smu driver
    
    this function can help smu driver to query dpm level clock range from
    smu firmware.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e51cf5a151e8..dcc4ccd5c44e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -356,6 +356,35 @@ int smu_get_dpm_level_count(struct smu_context *smu, enum smu_clk_type clk_type,
 	return smu_get_dpm_freq_by_index(smu, clk_type, 0xff, value);
 }
 
+int smu_get_dpm_level_range(struct smu_context *smu, enum smu_clk_type clk_type,
+			    uint32_t *min_value, uint32_t *max_value)
+{
+	int ret = 0;
+	uint32_t level_count = 0;
+
+	if (!min_value && !max_value)
+		return -EINVAL;
+
+	if (min_value) {
+		/* by default, level 0 clock value as min value */
+		ret = smu_get_dpm_freq_by_index(smu, clk_type, 0, min_value);
+		if (ret)
+			return ret;
+	}
+
+	if (max_value) {
+		ret = smu_get_dpm_level_count(smu, clk_type, &level_count);
+		if (ret)
+			return ret;
+
+		ret = smu_get_dpm_freq_by_index(smu, clk_type, level_count - 1, max_value);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
 bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type)
 {
 	enum smu_feature_mask feature_id = 0;

commit e78adc5a1d34eda80f157e9af477284989a62bdb
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Wed Dec 25 17:42:35 2019 +0800

    drm/amdgpu/powerplay: fix NULL pointer issue when SMU disabled
    
    Fix smu related NULL pointer issue which occurs when SMU is disabled.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d04c0ae3cfaa..e51cf5a151e8 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1904,8 +1904,14 @@ int smu_write_watermarks_table(struct smu_context *smu)
 int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 		struct dm_pp_wm_sets_with_clock_ranges_soc15 *clock_ranges)
 {
-	struct smu_table *watermarks = &smu->smu_table.tables[SMU_TABLE_WATERMARKS];
-	void *table = watermarks->cpu_addr;
+	struct smu_table *watermarks;
+	void *table;
+
+	if (!smu->smu_table.tables)
+		return 0;
+
+	watermarks = &smu->smu_table.tables[SMU_TABLE_WATERMARKS];
+	table = watermarks->cpu_addr;
 
 	mutex_lock(&smu->mutex);
 
@@ -2397,7 +2403,7 @@ bool smu_baco_is_support(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->ppt_funcs->baco_is_support)
+	if (smu->ppt_funcs && smu->ppt_funcs->baco_is_support)
 		ret = smu->ppt_funcs->baco_is_support(smu);
 
 	mutex_unlock(&smu->mutex);

commit d2f925ff9a239a49339d785f721c8cd89b743539
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Mon Dec 23 18:17:36 2019 +0800

    drm/amdgpu/smu: use unified variable smu->is_apu to check apu asic platform
    
    use unified variable smu->is_apu to check apu asic in smu driver.
    
    related patch:
    drm/amd/powerplay: bypass dpm_context null pointer check guard for some
    smu series
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d07c4f2ccee7..d04c0ae3cfaa 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -643,12 +643,11 @@ int smu_feature_init_dpm(struct smu_context *smu)
 
 int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
-	struct amdgpu_device *adev = smu->adev;
 	struct smu_feature *feature = &smu->smu_feature;
 	int feature_id;
 	int ret = 0;
 
-	if (adev->flags & AMD_IS_APU)
+	if (smu->is_apu)
 		return 1;
 
 	feature_id = smu_feature_get_index(smu, mask);
@@ -1242,7 +1241,7 @@ static int smu_hw_init(void *handle)
 		return ret;
 	}
 
-	if (adev->flags & AMD_IS_APU) {
+	if (smu->is_apu) {
 		smu_powergate_sdma(&adev->smu, false);
 		smu_powergate_vcn(&adev->smu, false);
 		smu_powergate_jpeg(&adev->smu, false);
@@ -1301,7 +1300,7 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
-	if (adev->flags & AMD_IS_APU) {
+	if (smu->is_apu) {
 		smu_powergate_sdma(&adev->smu, true);
 		smu_powergate_vcn(&adev->smu, true);
 		smu_powergate_jpeg(&adev->smu, true);
@@ -1377,7 +1376,7 @@ static int smu_suspend(void *handle)
 	struct smu_context *smu = &adev->smu;
 	bool baco_feature_is_enabled = false;
 
-	if(!(adev->flags & AMD_IS_APU))
+	if(!smu->is_apu)
 		baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
 
 	ret = smu_system_features_control(smu, false);

commit 337443d0e29054c95879a6a3149b29cc8fbd04df
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Fri Dec 20 16:34:42 2019 -0500

    drm/amdgpu/smu: make the set_performance_level logic easier to follow
    
    Have every asic provide a callback for this rather than a mix
    of generic and asic specific code.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 936c68298786..d07c4f2ccee7 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1607,43 +1607,6 @@ static int smu_enable_umd_pstate(void *handle,
 	return 0;
 }
 
-static int smu_default_set_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)
-{
-	int ret = 0;
-	uint32_t sclk_mask, mclk_mask, soc_mask;
-
-	switch (level) {
-	case AMD_DPM_FORCED_LEVEL_HIGH:
-		ret = smu_force_dpm_limit_value(smu, true);
-		break;
-	case AMD_DPM_FORCED_LEVEL_LOW:
-		ret = smu_force_dpm_limit_value(smu, false);
-		break;
-	case AMD_DPM_FORCED_LEVEL_AUTO:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
-		ret = smu_unforce_dpm_levels(smu);
-		break;
-	case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:
-		ret = smu_get_profiling_clk_mask(smu, level,
-						 &sclk_mask,
-						 &mclk_mask,
-						 &soc_mask);
-		if (ret)
-			return ret;
-		smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask, false);
-		smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask, false);
-		smu_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask, false);
-		break;
-	case AMD_DPM_FORCED_LEVEL_MANUAL:
-	case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
-	default:
-		break;
-	}
-	return ret;
-}
-
 int smu_adjust_power_state_dynamic(struct smu_context *smu,
 				   enum amd_dpm_forced_level level,
 				   bool skip_display_settings)
@@ -1681,11 +1644,8 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 	if (smu_dpm_ctx->dpm_level != level) {
 		ret = smu_asic_set_performance_level(smu, level);
 		if (ret) {
-			ret = smu_default_set_performance_level(smu, level);
-			if (ret) {
-				pr_err("Failed to set performance level!");
-				return ret;
-			}
+			pr_err("Failed to set performance level!");
+			return ret;
 		}
 
 		/* update the saved copy */

commit fa7df7516e32807cfc5360f41de8c2cc34e00046
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Dec 17 09:35:01 2019 -0500

    drm/amdgpu/smu: add metrics table lock
    
    This table is used for lots of things, add it's own lock.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/issues/900
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f76a1717ffbd..936c68298786 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -872,6 +872,7 @@ static int smu_sw_init(void *handle)
 	smu->smu_baco.platform_support = false;
 
 	mutex_init(&smu->sensor_lock);
+	mutex_init(&smu->metrics_lock);
 
 	smu->watermarks_bitmap = 0;
 	smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;

commit 19796597d10405210e3364d145ff460390bf0930
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Dec 16 15:05:22 2019 -0500

    drm/amdgpu/smu: fix spelling
    
    s/dispaly/display/g
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 6dddd7818558..f76a1717ffbd 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1670,7 +1670,7 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 	}
 
 	if (!skip_display_settings) {
-		ret = smu_notify_smc_dispaly_config(smu);
+		ret = smu_notify_smc_display_config(smu);
 		if (ret) {
 			pr_err("Failed to notify smc display config!");
 			return ret;

commit 4b4c5638c08d6be3fc4380bda23aa46bbd158073
Author: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
Date:   Thu Dec 5 14:21:31 2019 -0500

    drm/amdgpu: Fix BACO entry failure in NAVI10.
    
    BACO feature must be kept enabled to allow entry into
    BACO state in SMU during runtime suspend.
    
    Signed-off-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Tested-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c30f9a281e4c..6dddd7818558 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1383,7 +1383,7 @@ static int smu_suspend(void *handle)
 	if (ret)
 		return ret;
 
-	if (adev->in_gpu_reset && baco_feature_is_enabled) {
+	if (baco_feature_is_enabled) {
 		ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
 		if (ret) {
 			pr_warn("set BACO feature enabled failed, return %d\n", ret);

commit f275cde7066a27ab7afa0a1d95390dbf237726a2
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Mon Dec 2 15:04:35 2019 +0800

    drm/amdgpu/powerplay: unify smu send message function
    
    Drop smu_send_smc_msg function from ASIC specify structure.
    Reuse smu_send_smc_msg_with_param function for smu_send_smc_msg.
    Set paramer to 0 for smu_send_msg function, otherwise it will send
    with previous paramer value (Not a certain value).
    Materialize msg type for smu send message function definition.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0cc37cfe6eb0..c30f9a281e4c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -2568,3 +2568,12 @@ uint32_t smu_get_pptable_power_limit(struct smu_context *smu)
 
 	return ret;
 }
+
+int smu_send_smc_msg(struct smu_context *smu,
+		     enum smu_message_type msg)
+{
+	int ret;
+
+	ret = smu_send_smc_msg_with_param(smu, msg, 0);
+	return ret;
+}

commit 96358810c66a35b15303c4c2dd0ee48f223c221e
Author: Jack Zhang <Jack.Zhang1@amd.com>
Date:   Mon Dec 2 18:41:36 2019 +0800

    amd/amdgpu/sriov swSMU disable for sriov
    
    For boards greater than ARCTURUS, and under sriov platform,
    swSMU is not supported because smu ip block is commented at
    guest driver.
    
    Generally for sriov, initialization of smu is moved to host driver.
    Thus, smu sw_init and hw_init will not be executed at guest driver.
    
    Without sw structure being initialized in guest driver, swSMU cannot
    declare to be supported.
    
    Signed-off-by: Jack Zhang <Jack.Zhang1@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 98691d41a4e7..0cc37cfe6eb0 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -530,9 +530,12 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 {
 	if (adev->asic_type == CHIP_VEGA20)
 		return (amdgpu_dpm == 2) ? true : false;
-	else if (adev->asic_type >= CHIP_ARCTURUS)
-		return true;
-	else
+	else if (adev->asic_type >= CHIP_ARCTURUS) {
+		if (amdgpu_sriov_vf(adev))
+			return false;
+		else
+			return true;
+	} else
 		return false;
 }
 

commit c7d5dfa88bc4e5a05d664eff04f6981f9fdf872d
Author: zhengbin <zhengbin13@huawei.com>
Date:   Wed Nov 27 17:33:42 2019 +0800

    drm/amd/powerplay: Remove unneeded variable 'ret' in amdgpu_smu.c
    
    Fixes coccicheck warning:
    
    drivers/gpu/drm/amd/powerplay/amdgpu_smu.c:1192:5-8: Unneeded variable: "ret". Return "0" on line 1195
    drivers/gpu/drm/amd/powerplay/amdgpu_smu.c:1945:5-8: Unneeded variable: "ret". Return "0" on line 1961
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 36001a4f65d7..98691d41a4e7 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1189,10 +1189,9 @@ static int smu_free_memory_pool(struct smu_context *smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *memory_pool = &smu_table->memory_pool;
-	int ret = 0;
 
 	if (memory_pool->size == SMU_MEMORY_POOL_SIZE_ZERO)
-		return ret;
+		return 0;
 
 	amdgpu_bo_free_kernel(&memory_pool->bo,
 			      &memory_pool->mc_address,
@@ -1200,7 +1199,7 @@ static int smu_free_memory_pool(struct smu_context *smu)
 
 	memset(memory_pool, 0, sizeof(struct smu_table));
 
-	return ret;
+	return 0;
 }
 
 static int smu_start_smc_engine(struct smu_context *smu)
@@ -1942,7 +1941,6 @@ int smu_write_watermarks_table(struct smu_context *smu)
 int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 		struct dm_pp_wm_sets_with_clock_ranges_soc15 *clock_ranges)
 {
-	int ret = 0;
 	struct smu_table *watermarks = &smu->smu_table.tables[SMU_TABLE_WATERMARKS];
 	void *table = watermarks->cpu_addr;
 
@@ -1958,7 +1956,7 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 
 	mutex_unlock(&smu->mutex);
 
-	return ret;
+	return 0;
 }
 
 const struct amd_ip_funcs smu_ip_funcs = {

commit 11520f27085bbab7dcb2b5998dec7e7abe3a5bd1
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Oct 28 15:20:03 2019 -0400

    drm/amdgpu: split swSMU baco_reset into enter and exit
    
    BACO - Bus Active, Chip Off
    
    So we can use it for power savings rather than just reset.
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b73561957d24..36001a4f65d7 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -2456,14 +2456,28 @@ int smu_baco_get_state(struct smu_context *smu, enum smu_baco_state *state)
 	return 0;
 }
 
-int smu_baco_reset(struct smu_context *smu)
+int smu_baco_enter(struct smu_context *smu)
 {
 	int ret = 0;
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->ppt_funcs->baco_reset)
-		ret = smu->ppt_funcs->baco_reset(smu);
+	if (smu->ppt_funcs->baco_enter)
+		ret = smu->ppt_funcs->baco_enter(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_baco_exit(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->baco_exit)
+		ret = smu->ppt_funcs->baco_exit(smu);
 
 	mutex_unlock(&smu->mutex);
 

commit 85f8433f9bd72ea4e10523058f1cdcda59c4629c
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Nov 13 11:08:35 2019 -0500

    drm/amdgpu/powerplay: properly set PP_GFXOFF_MASK (v2)
    
    So that the setting reflects what the hw supports. This will
    be used in a subsequent patch so needs to be correct.
    
    v2: squash in fix from Colin Ian King
    
    Bug: https://bugzilla.kernel.org/show_bug.cgi?id=205497
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 223c5a794561..b73561957d24 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -730,6 +730,7 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
+		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 		vega20_set_ppt_funcs(smu);
 		break;
 	case CHIP_NAVI10:
@@ -738,6 +739,7 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 		navi10_set_ppt_funcs(smu);
 		break;
 	case CHIP_ARCTURUS:
+		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 		arcturus_set_ppt_funcs(smu);
 		/* OD is not supported on Arcturus */
 		smu->od_enabled =false;

commit c39f062e881dcc6ab4c1c1c5835dc774be1bcfd6
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Nov 11 17:15:02 2019 +0800

    drm/amd/powerplay: avoid DPM reenable process on Navi1x ASICs V2
    
    Otherwise, without RLC reinitialization, the DPM reenablement
    will fail. That affects the custom pptable uploading.
    
    V2: setting/clearing uploading_custom_pp_table in
        smu_sys_set_pp_table()
    
    Reported-by: Matt Coffin <mcoffin13@gmail.com>
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Tested-by: Matt Coffin <mcoffin13@gmail.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index a1453157eefe..223c5a794561 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -594,10 +594,18 @@ int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
 	smu_table->power_play_table = smu_table->hardcode_pptable;
 	smu_table->power_play_table_size = size;
 
+	/*
+	 * Special hw_fini action(for Navi1x, the DPMs disablement will be
+	 * skipped) may be needed for custom pptable uploading.
+	 */
+	smu->uploading_custom_pp_table = true;
+
 	ret = smu_reset(smu);
 	if (ret)
 		pr_info("smu reset failed, ret = %d\n", ret);
 
+	smu->uploading_custom_pp_table = false;
+
 failed:
 	mutex_unlock(&smu->mutex);
 	return ret;
@@ -1300,10 +1308,25 @@ static int smu_hw_fini(void *handle)
 		return ret;
 	}
 
-	ret = smu_stop_dpms(smu);
-	if (ret) {
-		pr_warn("Fail to stop Dpms!\n");
-		return ret;
+	/*
+	 * For custom pptable uploading, skip the DPM features
+	 * disable process on Navi1x ASICs.
+	 *   - As the gfx related features are under control of
+	 *     RLC on those ASICs. RLC reinitialization will be
+	 *     needed to reenable them. That will cost much more
+	 *     efforts.
+	 *
+	 *   - SMU firmware can handle the DPM reenablement
+	 *     properly.
+	 */
+	if (!smu->uploading_custom_pp_table ||
+	    !((adev->asic_type >= CHIP_NAVI10) &&
+	      (adev->asic_type <= CHIP_NAVI12))) {
+		ret = smu_stop_dpms(smu);
+		if (ret) {
+			pr_warn("Fail to stop Dpms!\n");
+			return ret;
+		}
 	}
 
 	kfree(table_context->driver_pptable);

commit 0db2ab99c9fbbd29ea54505027ce16a91da9efff
Author: Leo Liu <leo.liu@amd.com>
Date:   Fri Nov 8 14:38:08 2019 -0500

    drm/amd/powerplay: set JPEG to SMU dpm
    
    By using its own IP block type.
    
    Signed-off-by: Leo Liu <leo.liu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 211934521d37..a1453157eefe 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -415,6 +415,9 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 	case AMD_IP_BLOCK_TYPE_SDMA:
 		ret = smu_powergate_sdma(smu, gate);
 		break;
+	case AMD_IP_BLOCK_TYPE_JPEG:
+		ret = smu_dpm_set_jpeg_enable(smu, gate);
+		break;
 	default:
 		break;
 	}

commit 27f7ff327dbf230098bb05dda9217cc3e5bef6a7
Author: Leo Liu <leo.liu@amd.com>
Date:   Fri Nov 8 14:22:06 2019 -0500

    drm/amd/powerplay: add Powergate JPEG for Renoir
    
    Similar to SDMA, VCN etc.
    
    v2: add argument to both PowerUpJpeg and PowerDownJpeg messages
    
    Signed-off-by: Leo Liu <leo.liu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 69243a858dd5..211934521d37 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1229,6 +1229,7 @@ static int smu_hw_init(void *handle)
 	if (adev->flags & AMD_IS_APU) {
 		smu_powergate_sdma(&adev->smu, false);
 		smu_powergate_vcn(&adev->smu, false);
+		smu_powergate_jpeg(&adev->smu, false);
 		smu_set_gfx_cgpg(&adev->smu, true);
 	}
 
@@ -1287,6 +1288,7 @@ static int smu_hw_fini(void *handle)
 	if (adev->flags & AMD_IS_APU) {
 		smu_powergate_sdma(&adev->smu, true);
 		smu_powergate_vcn(&adev->smu, true);
+		smu_powergate_jpeg(&adev->smu, true);
 	}
 
 	ret = smu_stop_thermal_control(smu);

commit fddbfb1c6503b5218cec4b2bfa71ebd8177d97ba
Author: Kenneth Feng <kenneth.feng@amd.com>
Date:   Tue Nov 12 16:27:11 2019 +0800

    drm/amd/powerplay: read pcie speed/width info (v2)
    
    sysfs interface to read pcie speed&width info on navi1x.
    
    v2: fix warning (trivial)
    
    Signed-off-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 57459a65eb44..69243a858dd5 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1068,10 +1068,6 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		return ret;
 
 	if (adev->asic_type != CHIP_ARCTURUS) {
-		ret = smu_override_pcie_parameters(smu);
-		if (ret)
-			return ret;
-
 		ret = smu_notify_display_change(smu);
 		if (ret)
 			return ret;
@@ -1100,6 +1096,12 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 			return ret;
 	}
 
+	if (adev->asic_type != CHIP_ARCTURUS) {
+		ret = smu_override_pcie_parameters(smu);
+		if (ret)
+			return ret;
+	}
+
 	ret = smu_set_default_od_settings(smu, initialize);
 	if (ret)
 		return ret;

commit 73abde4d864b381be8b36d460d127fd479a560d3
Author: Matt Coffin <mcoffin13@gmail.com>
Date:   Mon Nov 11 11:36:31 2019 -0700

    drm/amdgpu/smu_v11: Unify and fix power limits
    
    [Why]
    On Navi10, and presumably arcterus, updating pp_table via sysfs would
    not re-scale the maximum possible power limit one can set. On navi10,
    the SMU code ignored the power percentage overdrive setting entirely,
    and would not allow you to exceed the default power limit at all.
    
    [How]
    Adding a function to the SMU interface to get the pptable version of the
    default power limit allows ASIC-specific code to provide the correct
    maximum-settable power limit for the current pptable.
    
    v3: fix spelling (Alex)
    
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Matt Coffin <mcoffin13@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 1e2da4d37567..57459a65eb44 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1109,7 +1109,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		if (ret)
 			return ret;
 
-		ret = smu_get_power_limit(smu, &smu->default_power_limit, true, false);
+		ret = smu_get_power_limit(smu, &smu->default_power_limit, false, false);
 		if (ret)
 			return ret;
 	}
@@ -2511,3 +2511,13 @@ int smu_get_dpm_clock_table(struct smu_context *smu,
 
 	return ret;
 }
+
+uint32_t smu_get_pptable_power_limit(struct smu_context *smu)
+{
+	uint32_t ret = 0;
+
+	if (smu->ppt_funcs->get_pptable_power_limit)
+		ret = smu->ppt_funcs->get_pptable_power_limit(smu);
+
+	return ret;
+}

commit 875dc7c4ff224afd4e3c61a7b4e06d4600dd8c0a
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Nov 7 15:33:50 2019 +0800

    drm/amd/powerplay: correct Arcturus OD support
    
    OD is not supported on Arcturus. Thus the
    pp_od_clk_voltage sysfs interface is also not supported.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 66faea66a8e9..1e2da4d37567 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -714,6 +714,9 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 {
 	struct smu_context *smu = &adev->smu;
 
+	if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
+		smu->od_enabled = true;
+
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
 		vega20_set_ppt_funcs(smu);
@@ -725,6 +728,8 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 		break;
 	case CHIP_ARCTURUS:
 		arcturus_set_ppt_funcs(smu);
+		/* OD is not supported on Arcturus */
+		smu->od_enabled =false;
 		break;
 	case CHIP_RENOIR:
 		renoir_set_ppt_funcs(smu);
@@ -733,9 +738,6 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 		return -EINVAL;
 	}
 
-	if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
-		smu->od_enabled = true;
-
 	return 0;
 }
 

commit cf3fde893d3a86fe5275061fbf80d67271d2d0cf
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Nov 6 12:40:12 2019 +0800

    drm/amd/powerplay: fix deadlock on setting power_dpm_force_performance_level
    
    smu_enable_umd_pstate() will try to get the smu->mutex which was already
    hold by its parent API smu_force_performance_level() on the call path.
    Thus deadlock happens.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 85ba341e5d19..66faea66a8e9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -383,14 +383,25 @@ bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type)
 	return true;
 }
 
-
+/**
+ * smu_dpm_set_power_gate - power gate/ungate the specific IP block
+ *
+ * @smu:        smu_context pointer
+ * @block_type: the IP block to power gate/ungate
+ * @gate:       to power gate if true, ungate otherwise
+ *
+ * This API uses no smu->mutex lock protection due to:
+ * 1. It is either called by other IP block(gfx/sdma/vcn/uvd/vce).
+ *    This is guarded to be race condition free by the caller.
+ * 2. Or get called on user setting request of power_dpm_force_performance_level.
+ *    Under this case, the smu->mutex lock protection is already enforced on
+ *    the parent API smu_force_performance_level of the call path.
+ */
 int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 			   bool gate)
 {
 	int ret = 0;
 
-	mutex_lock(&smu->mutex);
-
 	switch (block_type) {
 	case AMD_IP_BLOCK_TYPE_UVD:
 		ret = smu_dpm_set_uvd_enable(smu, gate);
@@ -408,8 +419,6 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 		break;
 	}
 
-	mutex_unlock(&smu->mutex);
-
 	return ret;
 }
 

commit 086e1c56162611aba933d61d6037bd471ee48f48
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Oct 31 14:29:48 2019 +0800

    drm/amd/powerplay: update is_sw_smu_xgmi check
    
    Add check for is_sw_smu routine and drop check
    for amdgpu_dpm which seems non-sense.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4e468b0272c3..85ba341e5d19 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -526,7 +526,7 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 
 bool is_support_sw_smu_xgmi(struct amdgpu_device *adev)
 {
-	if (amdgpu_dpm != 1)
+	if (!is_support_sw_smu(adev))
 		return false;
 
 	if (adev->asic_type == CHIP_VEGA20)

commit f509be184052e9279940dbcd02b0f8ac15b426ca
Author: chen gong <curry.gong@amd.com>
Date:   Fri Oct 25 18:51:23 2019 +0800

    drm/amd/powerplay: Disable gfx CGPG when suspend smu
    
    if no disable gfx CGPG when suspend smu, enabling gfx CGPG will fail when resume smu.
    
    Platform: Renoir
    dmesg log information:
    
    [  151.844110 ] amdgpu: [powerplay] SMU is resuming...
    [  151.844116 ] amdgpu: [powerplay] dpm has been disabled
    [  151.844604 ] amdgpu: [powerplay] Failed to send message 0x2f,response 0xfffffffb param 0x1
    [  151.844605 ] amdgpu: [powerplay] SMU is resumed successfully!
    
    Signed-off-by: chen gong <curry.gong@amd.com>
    Acked-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 26923aa5aea1..4e468b0272c3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1351,6 +1351,8 @@ static int smu_suspend(void *handle)
 	if (adev->asic_type >= CHIP_NAVI10 &&
 	    adev->gfx.rlc.funcs->stop)
 		adev->gfx.rlc.funcs->stop(adev);
+	if (smu->is_apu)
+		smu_set_gfx_cgpg(&adev->smu, false);
 
 	return 0;
 }

commit 6c45e480fe23d779df5cb95ce55cf9d4f4fb51cb
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Oct 17 19:59:29 2019 +0800

    drm/amd/powerplay: clear the swSMU code layer
    
    With this cleanup, the APIs from amdgpu_smu.c will map to
    ASIC specific ones directly. Those can be shared around
    all SMU V11/V12 ASICs will be put in smu_v11_0.c and
    smu_v12_0.c respectively.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 62ef8c43e14e..26923aa5aea1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -31,6 +31,10 @@
 #include "smu_v12_0.h"
 #include "atom.h"
 #include "amd_pcie.h"
+#include "vega20_ppt.h"
+#include "arcturus_ppt.h"
+#include "navi10_ppt.h"
+#include "renoir_ppt.h"
 
 #undef __SMU_DUMMY_MAP
 #define __SMU_DUMMY_MAP(type)	#type
@@ -703,23 +707,26 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
+		vega20_set_ppt_funcs(smu);
+		break;
 	case CHIP_NAVI10:
 	case CHIP_NAVI14:
 	case CHIP_NAVI12:
+		navi10_set_ppt_funcs(smu);
+		break;
 	case CHIP_ARCTURUS:
-		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
-			smu->od_enabled = true;
-		smu_v11_0_set_smu_funcs(smu);
+		arcturus_set_ppt_funcs(smu);
 		break;
 	case CHIP_RENOIR:
-		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
-			smu->od_enabled = true;
-		smu_v12_0_set_smu_funcs(smu);
+		renoir_set_ppt_funcs(smu);
 		break;
 	default:
 		return -EINVAL;
 	}
 
+	if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
+		smu->od_enabled = true;
+
 	return 0;
 }
 
@@ -1177,16 +1184,16 @@ static int smu_start_smc_engine(struct smu_context *smu)
 
 	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
 		if (adev->asic_type < CHIP_NAVI10) {
-			if (smu->funcs->load_microcode) {
-				ret = smu->funcs->load_microcode(smu);
+			if (smu->ppt_funcs->load_microcode) {
+				ret = smu->ppt_funcs->load_microcode(smu);
 				if (ret)
 					return ret;
 			}
 		}
 	}
 
-	if (smu->funcs->check_fw_status) {
-		ret = smu->funcs->check_fw_status(smu);
+	if (smu->ppt_funcs->check_fw_status) {
+		ret = smu->ppt_funcs->check_fw_status(smu);
 		if (ret)
 			pr_err("SMC is not ready\n");
 	}
@@ -1397,8 +1404,8 @@ int smu_display_configuration_change(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_deep_sleep_dcefclk)
-		smu->funcs->set_deep_sleep_dcefclk(smu,
+	if (smu->ppt_funcs->set_deep_sleep_dcefclk)
+		smu->ppt_funcs->set_deep_sleep_dcefclk(smu,
 				display_config->min_dcef_deep_sleep_set_clk / 100);
 
 	for (index = 0; index < display_config->num_path_including_non_display; index++) {
@@ -1952,8 +1959,8 @@ int smu_load_microcode(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->load_microcode)
-		ret = smu->funcs->load_microcode(smu);
+	if (smu->ppt_funcs->load_microcode)
+		ret = smu->ppt_funcs->load_microcode(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -1966,8 +1973,8 @@ int smu_check_fw_status(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->check_fw_status)
-		ret = smu->funcs->check_fw_status(smu);
+	if (smu->ppt_funcs->check_fw_status)
+		ret = smu->ppt_funcs->check_fw_status(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -1980,8 +1987,8 @@ int smu_set_gfx_cgpg(struct smu_context *smu, bool enabled)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_gfx_cgpg)
-		ret = smu->funcs->set_gfx_cgpg(smu, enabled);
+	if (smu->ppt_funcs->set_gfx_cgpg)
+		ret = smu->ppt_funcs->set_gfx_cgpg(smu, enabled);
 
 	mutex_unlock(&smu->mutex);
 
@@ -1994,8 +2001,8 @@ int smu_set_fan_speed_rpm(struct smu_context *smu, uint32_t speed)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_fan_speed_rpm)
-		ret = smu->funcs->set_fan_speed_rpm(smu, speed);
+	if (smu->ppt_funcs->set_fan_speed_rpm)
+		ret = smu->ppt_funcs->set_fan_speed_rpm(smu, speed);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2027,8 +2034,8 @@ int smu_set_power_limit(struct smu_context *smu, uint32_t limit)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_power_limit)
-		ret = smu->funcs->set_power_limit(smu, limit);
+	if (smu->ppt_funcs->set_power_limit)
+		ret = smu->ppt_funcs->set_power_limit(smu, limit);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2149,8 +2156,8 @@ int smu_get_fan_control_mode(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->get_fan_control_mode)
-		ret = smu->funcs->get_fan_control_mode(smu);
+	if (smu->ppt_funcs->get_fan_control_mode)
+		ret = smu->ppt_funcs->get_fan_control_mode(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2163,8 +2170,8 @@ int smu_set_fan_control_mode(struct smu_context *smu, int value)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_fan_control_mode)
-		ret = smu->funcs->set_fan_control_mode(smu, value);
+	if (smu->ppt_funcs->set_fan_control_mode)
+		ret = smu->ppt_funcs->set_fan_control_mode(smu, value);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2191,8 +2198,8 @@ int smu_set_fan_speed_percent(struct smu_context *smu, uint32_t speed)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_fan_speed_percent)
-		ret = smu->funcs->set_fan_speed_percent(smu, speed);
+	if (smu->ppt_funcs->set_fan_speed_percent)
+		ret = smu->ppt_funcs->set_fan_speed_percent(smu, speed);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2219,8 +2226,8 @@ int smu_set_deep_sleep_dcefclk(struct smu_context *smu, int clk)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_deep_sleep_dcefclk)
-		ret = smu->funcs->set_deep_sleep_dcefclk(smu, clk);
+	if (smu->ppt_funcs->set_deep_sleep_dcefclk)
+		ret = smu->ppt_funcs->set_deep_sleep_dcefclk(smu, clk);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2233,8 +2240,8 @@ int smu_set_active_display_count(struct smu_context *smu, uint32_t count)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_active_display_count)
-		ret = smu->funcs->set_active_display_count(smu, count);
+	if (smu->ppt_funcs->set_active_display_count)
+		ret = smu->ppt_funcs->set_active_display_count(smu, count);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2249,8 +2256,8 @@ int smu_get_clock_by_type(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->get_clock_by_type)
-		ret = smu->funcs->get_clock_by_type(smu, type, clocks);
+	if (smu->ppt_funcs->get_clock_by_type)
+		ret = smu->ppt_funcs->get_clock_by_type(smu, type, clocks);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2264,8 +2271,8 @@ int smu_get_max_high_clocks(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->get_max_high_clocks)
-		ret = smu->funcs->get_max_high_clocks(smu, clocks);
+	if (smu->ppt_funcs->get_max_high_clocks)
+		ret = smu->ppt_funcs->get_max_high_clocks(smu, clocks);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2312,8 +2319,8 @@ int smu_display_clock_voltage_request(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->display_clock_voltage_request)
-		ret = smu->funcs->display_clock_voltage_request(smu, clock_req);
+	if (smu->ppt_funcs->display_clock_voltage_request)
+		ret = smu->ppt_funcs->display_clock_voltage_request(smu, clock_req);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2341,8 +2348,8 @@ int smu_notify_smu_enable_pwe(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->notify_smu_enable_pwe)
-		ret = smu->funcs->notify_smu_enable_pwe(smu);
+	if (smu->ppt_funcs->notify_smu_enable_pwe)
+		ret = smu->ppt_funcs->notify_smu_enable_pwe(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2356,8 +2363,8 @@ int smu_set_xgmi_pstate(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_xgmi_pstate)
-		ret = smu->funcs->set_xgmi_pstate(smu, pstate);
+	if (smu->ppt_funcs->set_xgmi_pstate)
+		ret = smu->ppt_funcs->set_xgmi_pstate(smu, pstate);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2370,8 +2377,8 @@ int smu_set_azalia_d3_pme(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->set_azalia_d3_pme)
-		ret = smu->funcs->set_azalia_d3_pme(smu);
+	if (smu->ppt_funcs->set_azalia_d3_pme)
+		ret = smu->ppt_funcs->set_azalia_d3_pme(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2384,8 +2391,8 @@ bool smu_baco_is_support(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->baco_is_support)
-		ret = smu->funcs->baco_is_support(smu);
+	if (smu->ppt_funcs->baco_is_support)
+		ret = smu->ppt_funcs->baco_is_support(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2394,11 +2401,11 @@ bool smu_baco_is_support(struct smu_context *smu)
 
 int smu_baco_get_state(struct smu_context *smu, enum smu_baco_state *state)
 {
-	if (smu->funcs->baco_get_state)
+	if (smu->ppt_funcs->baco_get_state)
 		return -EINVAL;
 
 	mutex_lock(&smu->mutex);
-	*state = smu->funcs->baco_get_state(smu);
+	*state = smu->ppt_funcs->baco_get_state(smu);
 	mutex_unlock(&smu->mutex);
 
 	return 0;
@@ -2410,8 +2417,8 @@ int smu_baco_reset(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->baco_reset)
-		ret = smu->funcs->baco_reset(smu);
+	if (smu->ppt_funcs->baco_reset)
+		ret = smu->ppt_funcs->baco_reset(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2424,8 +2431,8 @@ int smu_mode2_reset(struct smu_context *smu)
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->mode2_reset)
-		ret = smu->funcs->mode2_reset(smu);
+	if (smu->ppt_funcs->mode2_reset)
+		ret = smu->ppt_funcs->mode2_reset(smu);
 
 	mutex_unlock(&smu->mutex);
 
@@ -2439,8 +2446,8 @@ int smu_get_max_sustainable_clocks_by_dc(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	if (smu->funcs->get_max_sustainable_clocks_by_dc)
-		ret = smu->funcs->get_max_sustainable_clocks_by_dc(smu, max_clocks);
+	if (smu->ppt_funcs->get_max_sustainable_clocks_by_dc)
+		ret = smu->ppt_funcs->get_max_sustainable_clocks_by_dc(smu, max_clocks);
 
 	mutex_unlock(&smu->mutex);
 

commit 18c1d3cee4c5935ebcfa0b434e4a8ef6d78496ad
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Oct 17 14:15:41 2019 +0800

    drm/amd/powerplay: split out those internal used swSMU APIs V2
    
    Those swSMU APIs used internally are moved to smu_internal.h while
    others are kept in amdgpu_smu.h.
    
    V2: give a better name smu_internal.h for the place to hold
        those internal APIs
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 007f497fed11..62ef8c43e14e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -25,6 +25,7 @@
 #include "pp_debug.h"
 #include "amdgpu.h"
 #include "amdgpu_smu.h"
+#include "smu_internal.h"
 #include "soc15_common.h"
 #include "smu_v11_0.h"
 #include "smu_v12_0.h"

commit 3697b339c64f82af195fd3cc6492ef26b6dfcd47
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Oct 16 14:43:07 2019 +0800

    drm/amd/powerplay: add lock protection for swSMU APIs V2
    
    This is a quick and low risk fix. Those APIs which
    are exposed to other IPs or to support sysfs/hwmon
    interfaces or DAL will have lock protection. Meanwhile
    no lock protection is enforced for swSMU internal used
    APIs. Future optimization is needed.
    
    V2: strip the lock protection for all swSMU internal APIs
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Acked-by: Feifei Xu <Feifei.Xu@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ee374df32b19..007f497fed11 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -67,6 +67,8 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 	uint32_t sort_feature[SMU_FEATURE_COUNT];
 	uint64_t hw_feature_count = 0;
 
+	mutex_lock(&smu->mutex);
+
 	ret = smu_feature_get_enabled_mask(smu, feature_mask, 2);
 	if (ret)
 		goto failed;
@@ -92,6 +94,8 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 	}
 
 failed:
+	mutex_unlock(&smu->mutex);
+
 	return size;
 }
 
@@ -149,9 +153,11 @@ int smu_sys_set_pp_feature_mask(struct smu_context *smu, uint64_t new_mask)
 	uint64_t feature_2_disabled = 0;
 	uint64_t feature_enables = 0;
 
+	mutex_lock(&smu->mutex);
+
 	ret = smu_feature_get_enabled_mask(smu, feature_mask, 2);
 	if (ret)
-		return ret;
+		goto out;
 
 	feature_enables = ((uint64_t)feature_mask[1] << 32 | (uint64_t)feature_mask[0]);
 
@@ -161,14 +167,17 @@ int smu_sys_set_pp_feature_mask(struct smu_context *smu, uint64_t new_mask)
 	if (feature_2_enabled) {
 		ret = smu_feature_update_enable_state(smu, feature_2_enabled, true);
 		if (ret)
-			return ret;
+			goto out;
 	}
 	if (feature_2_disabled) {
 		ret = smu_feature_update_enable_state(smu, feature_2_disabled, false);
 		if (ret)
-			return ret;
+			goto out;
 	}
 
+out:
+	mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -254,7 +263,7 @@ int smu_set_hard_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 }
 
 int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
-			   uint32_t *min, uint32_t *max)
+			   uint32_t *min, uint32_t *max, bool lock_needed)
 {
 	uint32_t clock_limit;
 	int ret = 0;
@@ -262,6 +271,9 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (!min && !max)
 		return -EINVAL;
 
+	if (lock_needed)
+		mutex_lock(&smu->mutex);
+
 	if (!smu_clk_dpm_is_enabled(smu, clk_type)) {
 		switch (clk_type) {
 		case SMU_MCLK:
@@ -285,14 +297,17 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			*min = clock_limit / 100;
 		if (max)
 			*max = clock_limit / 100;
-
-		return 0;
+	} else {
+		/*
+		 * Todo: Use each asic(ASIC_ppt funcs) control the callbacks exposed to the
+		 * core driver and then have helpers for stuff that is common(SMU_v11_x | SMU_v12_x funcs).
+		 */
+		ret = smu_get_dpm_ultimate_freq(smu, clk_type, min, max);
 	}
-	/*
-	 * Todo: Use each asic(ASIC_ppt funcs) control the callbacks exposed to the
-	 * core driver and then have helpers for stuff that is common(SMU_v11_x | SMU_v12_x funcs).
-	 */
-	ret = smu_get_dpm_ultimate_freq(smu, clk_type, min, max);
+
+	if (lock_needed)
+		mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -369,6 +384,8 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 {
 	int ret = 0;
 
+	mutex_lock(&smu->mutex);
+
 	switch (block_type) {
 	case AMD_IP_BLOCK_TYPE_UVD:
 		ret = smu_dpm_set_uvd_enable(smu, gate);
@@ -386,13 +403,9 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 		break;
 	}
 
-	return ret;
-}
+	mutex_unlock(&smu->mutex);
 
-enum amd_pm_state_type smu_get_current_power_state(struct smu_context *smu)
-{
-	/* not support power state */
-	return POWER_STATE_TYPE_DEFAULT;
+	return ret;
 }
 
 int smu_get_power_num_states(struct smu_context *smu,
@@ -520,16 +533,23 @@ bool is_support_sw_smu_xgmi(struct amdgpu_device *adev)
 int smu_sys_get_pp_table(struct smu_context *smu, void **table)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
+	uint32_t powerplay_table_size;
 
 	if (!smu_table->power_play_table && !smu_table->hardcode_pptable)
 		return -EINVAL;
 
+	mutex_lock(&smu->mutex);
+
 	if (smu_table->hardcode_pptable)
 		*table = smu_table->hardcode_pptable;
 	else
 		*table = smu_table->power_play_table;
 
-	return smu_table->power_play_table_size;
+	powerplay_table_size = smu_table->power_play_table_size;
+
+	mutex_unlock(&smu->mutex);
+
+	return powerplay_table_size;
 }
 
 int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
@@ -556,14 +576,11 @@ int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
 	memcpy(smu_table->hardcode_pptable, buf, size);
 	smu_table->power_play_table = smu_table->hardcode_pptable;
 	smu_table->power_play_table_size = size;
-	mutex_unlock(&smu->mutex);
 
 	ret = smu_reset(smu);
 	if (ret)
 		pr_info("smu reset failed, ret = %d\n", ret);
 
-	return ret;
-
 failed:
 	mutex_unlock(&smu->mutex);
 	return ret;
@@ -726,11 +743,10 @@ static int smu_late_init(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
-	mutex_lock(&smu->mutex);
 	smu_handle_task(&adev->smu,
 			smu->smu_dpm.dpm_level,
-			AMD_PP_TASK_COMPLETE_INIT);
-	mutex_unlock(&smu->mutex);
+			AMD_PP_TASK_COMPLETE_INIT,
+			false);
 
 	return 0;
 }
@@ -1074,7 +1090,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		if (ret)
 			return ret;
 
-		ret = smu_get_power_limit(smu, &smu->default_power_limit, true);
+		ret = smu_get_power_limit(smu, &smu->default_power_limit, true, false);
 		if (ret)
 			return ret;
 	}
@@ -1160,15 +1176,19 @@ static int smu_start_smc_engine(struct smu_context *smu)
 
 	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
 		if (adev->asic_type < CHIP_NAVI10) {
-			ret = smu_load_microcode(smu);
-			if (ret)
-				return ret;
+			if (smu->funcs->load_microcode) {
+				ret = smu->funcs->load_microcode(smu);
+				if (ret)
+					return ret;
+			}
 		}
 	}
 
-	ret = smu_check_fw_status(smu);
-	if (ret)
-		pr_err("SMC is not ready\n");
+	if (smu->funcs->check_fw_status) {
+		ret = smu->funcs->check_fw_status(smu);
+		if (ret)
+			pr_err("SMC is not ready\n");
+	}
 
 	return ret;
 }
@@ -1335,8 +1355,6 @@ static int smu_resume(void *handle)
 
 	pr_info("SMU is resuming...\n");
 
-	mutex_lock(&smu->mutex);
-
 	ret = smu_start_smc_engine(smu);
 	if (ret) {
 		pr_err("SMU is not ready yet!\n");
@@ -1356,13 +1374,11 @@ static int smu_resume(void *handle)
 
 	smu->disable_uclk_switch = 0;
 
-	mutex_unlock(&smu->mutex);
-
 	pr_info("SMU is resumed successfully!\n");
 
 	return 0;
+
 failed:
-	mutex_unlock(&smu->mutex);
 	return ret;
 }
 
@@ -1380,8 +1396,9 @@ int smu_display_configuration_change(struct smu_context *smu,
 
 	mutex_lock(&smu->mutex);
 
-	smu_set_deep_sleep_dcefclk(smu,
-				   display_config->min_dcef_deep_sleep_set_clk / 100);
+	if (smu->funcs->set_deep_sleep_dcefclk)
+		smu->funcs->set_deep_sleep_dcefclk(smu,
+				display_config->min_dcef_deep_sleep_set_clk / 100);
 
 	for (index = 0; index < display_config->num_path_including_non_display; index++) {
 		if (display_config->displays[index].controller_id != 0)
@@ -1559,9 +1576,9 @@ static int smu_default_set_performance_level(struct smu_context *smu, enum amd_d
 						 &soc_mask);
 		if (ret)
 			return ret;
-		smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask);
-		smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask);
-		smu_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask);
+		smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask, false);
+		smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask, false);
+		smu_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask, false);
 		break;
 	case AMD_DPM_FORCED_LEVEL_MANUAL:
 	case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
@@ -1625,7 +1642,7 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 		workload = smu->workload_setting[index];
 
 		if (smu->power_profile_mode != workload)
-			smu_set_power_profile_mode(smu, &workload, 0);
+			smu_set_power_profile_mode(smu, &workload, 0, false);
 	}
 
 	return ret;
@@ -1633,18 +1650,22 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 
 int smu_handle_task(struct smu_context *smu,
 		    enum amd_dpm_forced_level level,
-		    enum amd_pp_task task_id)
+		    enum amd_pp_task task_id,
+		    bool lock_needed)
 {
 	int ret = 0;
 
+	if (lock_needed)
+		mutex_lock(&smu->mutex);
+
 	switch (task_id) {
 	case AMD_PP_TASK_DISPLAY_CONFIG_CHANGE:
 		ret = smu_pre_display_config_changed(smu);
 		if (ret)
-			return ret;
+			goto out;
 		ret = smu_set_cpu_power_state(smu);
 		if (ret)
-			return ret;
+			goto out;
 		ret = smu_adjust_power_state_dynamic(smu, level, false);
 		break;
 	case AMD_PP_TASK_COMPLETE_INIT:
@@ -1655,6 +1676,10 @@ int smu_handle_task(struct smu_context *smu,
 		break;
 	}
 
+out:
+	if (lock_needed)
+		mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -1687,7 +1712,7 @@ int smu_switch_power_profile(struct smu_context *smu,
 	}
 
 	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
-		smu_set_power_profile_mode(smu, &workload, 0);
+		smu_set_power_profile_mode(smu, &workload, 0, false);
 
 	mutex_unlock(&smu->mutex);
 
@@ -1717,12 +1742,19 @@ int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_lev
 	if (!smu->is_apu && !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
+	mutex_lock(&smu->mutex);
+
 	ret = smu_enable_umd_pstate(smu, &level);
-	if (ret)
+	if (ret) {
+		mutex_unlock(&smu->mutex);
 		return ret;
+	}
 
 	ret = smu_handle_task(smu, level,
-			      AMD_PP_TASK_READJUST_POWER_STATE);
+			      AMD_PP_TASK_READJUST_POWER_STATE,
+			      false);
+
+	mutex_unlock(&smu->mutex);
 
 	return ret;
 }
@@ -1740,7 +1772,8 @@ int smu_set_display_count(struct smu_context *smu, uint32_t count)
 
 int smu_force_clk_levels(struct smu_context *smu,
 			 enum smu_clk_type clk_type,
-			 uint32_t mask)
+			 uint32_t mask,
+			 bool lock_needed)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 	int ret = 0;
@@ -1750,9 +1783,15 @@ int smu_force_clk_levels(struct smu_context *smu,
 		return -EINVAL;
 	}
 
+	if (lock_needed)
+		mutex_lock(&smu->mutex);
+
 	if (smu->ppt_funcs && smu->ppt_funcs->force_clk_levels)
 		ret = smu->ppt_funcs->force_clk_levels(smu, clk_type, mask);
 
+	if (lock_needed)
+		mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -1770,6 +1809,8 @@ int smu_set_mp1_state(struct smu_context *smu,
 	if (!smu->pm_enabled)
 		return 0;
 
+	mutex_lock(&smu->mutex);
+
 	switch (mp1_state) {
 	case PP_MP1_STATE_SHUTDOWN:
 		msg = SMU_MSG_PrepareMp1ForShutdown;
@@ -1782,17 +1823,22 @@ int smu_set_mp1_state(struct smu_context *smu,
 		break;
 	case PP_MP1_STATE_NONE:
 	default:
+		mutex_unlock(&smu->mutex);
 		return 0;
 	}
 
 	/* some asics may not support those messages */
-	if (smu_msg_get_index(smu, msg) < 0)
+	if (smu_msg_get_index(smu, msg) < 0) {
+		mutex_unlock(&smu->mutex);
 		return 0;
+	}
 
 	ret = smu_send_smc_msg(smu, msg);
 	if (ret)
 		pr_err("[PrepareMp1] Failed!\n");
 
+	mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -1812,10 +1858,14 @@ int smu_set_df_cstate(struct smu_context *smu,
 	if (!smu->ppt_funcs || !smu->ppt_funcs->set_df_cstate)
 		return 0;
 
+	mutex_lock(&smu->mutex);
+
 	ret = smu->ppt_funcs->set_df_cstate(smu, state);
 	if (ret)
 		pr_err("[SetDfCstate] failed!\n");
 
+	mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -1843,6 +1893,8 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 	struct smu_table *watermarks = &smu->smu_table.tables[SMU_TABLE_WATERMARKS];
 	void *table = watermarks->cpu_addr;
 
+	mutex_lock(&smu->mutex);
+
 	if (!smu->disable_watermark &&
 			smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&
 			smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
@@ -1851,6 +1903,8 @@ int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
 		smu->watermarks_bitmap &= ~WATERMARKS_LOADED;
 	}
 
+	mutex_unlock(&smu->mutex);
+
 	return ret;
 }
 
@@ -1890,3 +1944,549 @@ const struct amdgpu_ip_block_version smu_v12_0_ip_block =
 	.rev = 0,
 	.funcs = &smu_ip_funcs,
 };
+
+int smu_load_microcode(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->load_microcode)
+		ret = smu->funcs->load_microcode(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_check_fw_status(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->check_fw_status)
+		ret = smu->funcs->check_fw_status(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_gfx_cgpg(struct smu_context *smu, bool enabled)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_gfx_cgpg)
+		ret = smu->funcs->set_gfx_cgpg(smu, enabled);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_fan_speed_rpm(struct smu_context *smu, uint32_t speed)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_fan_speed_rpm)
+		ret = smu->funcs->set_fan_speed_rpm(smu, speed);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_power_limit(struct smu_context *smu,
+			uint32_t *limit,
+			bool def,
+			bool lock_needed)
+{
+	int ret = 0;
+
+	if (lock_needed)
+		mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_power_limit)
+		ret = smu->ppt_funcs->get_power_limit(smu, limit, def);
+
+	if (lock_needed)
+		mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_power_limit(struct smu_context *smu, uint32_t limit)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_power_limit)
+		ret = smu->funcs->set_power_limit(smu, limit);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_print_clk_levels(struct smu_context *smu, enum smu_clk_type clk_type, char *buf)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->print_clk_levels)
+		ret = smu->ppt_funcs->print_clk_levels(smu, clk_type, buf);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_od_percentage(struct smu_context *smu, enum smu_clk_type type)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_od_percentage)
+		ret = smu->ppt_funcs->get_od_percentage(smu, type);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_od_percentage(struct smu_context *smu, enum smu_clk_type type, uint32_t value)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->set_od_percentage)
+		ret = smu->ppt_funcs->set_od_percentage(smu, type, value);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_od_edit_dpm_table(struct smu_context *smu,
+			  enum PP_OD_DPM_TABLE_COMMAND type,
+			  long *input, uint32_t size)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->od_edit_dpm_table)
+		ret = smu->ppt_funcs->od_edit_dpm_table(smu, type, input, size);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_read_sensor(struct smu_context *smu,
+		    enum amd_pp_sensors sensor,
+		    void *data, uint32_t *size)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->read_sensor)
+		ret = smu->ppt_funcs->read_sensor(smu, sensor, data, size);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_power_profile_mode(struct smu_context *smu, char *buf)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_power_profile_mode)
+		ret = smu->ppt_funcs->get_power_profile_mode(smu, buf);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_power_profile_mode(struct smu_context *smu,
+			       long *param,
+			       uint32_t param_size,
+			       bool lock_needed)
+{
+	int ret = 0;
+
+	if (lock_needed)
+		mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->set_power_profile_mode)
+		ret = smu->ppt_funcs->set_power_profile_mode(smu, param, param_size);
+
+	if (lock_needed)
+		mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+
+int smu_get_fan_control_mode(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->get_fan_control_mode)
+		ret = smu->funcs->get_fan_control_mode(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_fan_control_mode(struct smu_context *smu, int value)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_fan_control_mode)
+		ret = smu->funcs->set_fan_control_mode(smu, value);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_fan_speed_percent(struct smu_context *smu, uint32_t *speed)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_fan_speed_percent)
+		ret = smu->ppt_funcs->get_fan_speed_percent(smu, speed);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_fan_speed_percent(struct smu_context *smu, uint32_t speed)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_fan_speed_percent)
+		ret = smu->funcs->set_fan_speed_percent(smu, speed);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_fan_speed_rpm(struct smu_context *smu, uint32_t *speed)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_fan_speed_rpm)
+		ret = smu->ppt_funcs->get_fan_speed_rpm(smu, speed);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_deep_sleep_dcefclk(struct smu_context *smu, int clk)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_deep_sleep_dcefclk)
+		ret = smu->funcs->set_deep_sleep_dcefclk(smu, clk);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_active_display_count(struct smu_context *smu, uint32_t count)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_active_display_count)
+		ret = smu->funcs->set_active_display_count(smu, count);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_clock_by_type(struct smu_context *smu,
+			  enum amd_pp_clock_type type,
+			  struct amd_pp_clocks *clocks)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->get_clock_by_type)
+		ret = smu->funcs->get_clock_by_type(smu, type, clocks);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_max_high_clocks(struct smu_context *smu,
+			    struct amd_pp_simple_clock_info *clocks)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->get_max_high_clocks)
+		ret = smu->funcs->get_max_high_clocks(smu, clocks);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_clock_by_type_with_latency(struct smu_context *smu,
+				       enum smu_clk_type clk_type,
+				       struct pp_clock_levels_with_latency *clocks)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_clock_by_type_with_latency)
+		ret = smu->ppt_funcs->get_clock_by_type_with_latency(smu, clk_type, clocks);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_clock_by_type_with_voltage(struct smu_context *smu,
+				       enum amd_pp_clock_type type,
+				       struct pp_clock_levels_with_voltage *clocks)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_clock_by_type_with_voltage)
+		ret = smu->ppt_funcs->get_clock_by_type_with_voltage(smu, type, clocks);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+
+int smu_display_clock_voltage_request(struct smu_context *smu,
+				      struct pp_display_clock_request *clock_req)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->display_clock_voltage_request)
+		ret = smu->funcs->display_clock_voltage_request(smu, clock_req);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+
+int smu_display_disable_memory_clock_switch(struct smu_context *smu, bool disable_memory_clock_switch)
+{
+	int ret = -EINVAL;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->display_disable_memory_clock_switch)
+		ret = smu->ppt_funcs->display_disable_memory_clock_switch(smu, disable_memory_clock_switch);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_notify_smu_enable_pwe(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->notify_smu_enable_pwe)
+		ret = smu->funcs->notify_smu_enable_pwe(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_xgmi_pstate(struct smu_context *smu,
+			uint32_t pstate)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_xgmi_pstate)
+		ret = smu->funcs->set_xgmi_pstate(smu, pstate);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_set_azalia_d3_pme(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->set_azalia_d3_pme)
+		ret = smu->funcs->set_azalia_d3_pme(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+bool smu_baco_is_support(struct smu_context *smu)
+{
+	bool ret = false;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->baco_is_support)
+		ret = smu->funcs->baco_is_support(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_baco_get_state(struct smu_context *smu, enum smu_baco_state *state)
+{
+	if (smu->funcs->baco_get_state)
+		return -EINVAL;
+
+	mutex_lock(&smu->mutex);
+	*state = smu->funcs->baco_get_state(smu);
+	mutex_unlock(&smu->mutex);
+
+	return 0;
+}
+
+int smu_baco_reset(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->baco_reset)
+		ret = smu->funcs->baco_reset(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_mode2_reset(struct smu_context *smu)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->mode2_reset)
+		ret = smu->funcs->mode2_reset(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_max_sustainable_clocks_by_dc(struct smu_context *smu,
+					 struct pp_smu_nv_clock_table *max_clocks)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->funcs->get_max_sustainable_clocks_by_dc)
+		ret = smu->funcs->get_max_sustainable_clocks_by_dc(smu, max_clocks);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+int smu_get_uclk_dpm_states(struct smu_context *smu,
+			    unsigned int *clock_values_in_khz,
+			    unsigned int *num_states)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_uclk_dpm_states)
+		ret = smu->ppt_funcs->get_uclk_dpm_states(smu, clock_values_in_khz, num_states);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
+enum amd_pm_state_type smu_get_current_power_state(struct smu_context *smu)
+{
+	enum amd_pm_state_type pm_state = POWER_STATE_TYPE_DEFAULT;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_current_power_state)
+		pm_state = smu->ppt_funcs->get_current_power_state(smu);
+
+	mutex_unlock(&smu->mutex);
+
+	return pm_state;
+}
+
+int smu_get_dpm_clock_table(struct smu_context *smu,
+			    struct dpm_clocks *clock_table)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+
+	if (smu->ppt_funcs->get_dpm_clock_table)
+		ret = smu->ppt_funcs->get_dpm_clock_table(smu, clock_table);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}

commit 5441dd0e2caadc6038a8c1ccd16cf3c9cdb62db1
Author: Kenneth Feng <kenneth.feng@amd.com>
Date:   Wed Oct 16 16:20:38 2019 +0800

    drm/amd/powerplay: bug fix for memory clock request from display
    
    In some cases, display fixes memory clock frequency to a high value
    rather than the natural memory clock switching.
    When we comes back from s3 resume, the request from display is not reset,
    this causes the bug which makes the memory clock goes into a low value.
    Then due to the insuffcient memory clock, the screen flicks.
    
    Signed-off-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Jack Xiao <Jack.Xiao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e2a03f411d6b..ee374df32b19 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1354,6 +1354,8 @@ static int smu_resume(void *handle)
 	if (smu->is_apu)
 		smu_set_gfx_cgpg(&adev->smu, true);
 
+	smu->disable_uclk_switch = 0;
+
 	mutex_unlock(&smu->mutex);
 
 	pr_info("SMU is resumed successfully!\n");

commit f839110157aed1396506dfab715f523344ab9724
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Tue Oct 15 17:11:49 2019 +0800

    drm/amdgpu: fix S3 failed as RLC safe mode entry stucked in polloing gfx acq
    
    Fix gfx cgpg setting sequence for RLC deadlock at safe mode entry in polling gfx response.
    The patch can fix VCN IB test failed and DAL get dispaly count failed issue.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index acec69b74734..e2a03f411d6b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1188,6 +1188,7 @@ static int smu_hw_init(void *handle)
 	if (adev->flags & AMD_IS_APU) {
 		smu_powergate_sdma(&adev->smu, false);
 		smu_powergate_vcn(&adev->smu, false);
+		smu_set_gfx_cgpg(&adev->smu, true);
 	}
 
 	if (!smu->pm_enabled)
@@ -1350,6 +1351,9 @@ static int smu_resume(void *handle)
 	if (ret)
 		goto failed;
 
+	if (smu->is_apu)
+		smu_set_gfx_cgpg(&adev->smu, true);
+
 	mutex_unlock(&smu->mutex);
 
 	pr_info("SMU is resumed successfully!\n");

commit 7bbdbe405965dc4998996bdea571a5b9a1dd3d16
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Wed Sep 18 09:53:30 2019 -0400

    drm/amdgpu/powerplay: add renoir funcs to support dc
    
    there are two paths for renoir dc access smu.
    one dc access smu directly using bios smc
    interface: set disply, dprefclk, etc.
    another goes through pplib for get dpm clock
    table and set watermmark.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 6cb52881e955..acec69b74734 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1813,6 +1813,41 @@ int smu_set_df_cstate(struct smu_context *smu,
 	return ret;
 }
 
+int smu_write_watermarks_table(struct smu_context *smu)
+{
+	int ret = 0;
+	struct smu_table_context *smu_table = &smu->smu_table;
+	struct smu_table *table = NULL;
+
+	table = &smu_table->tables[SMU_TABLE_WATERMARKS];
+
+	if (!table->cpu_addr)
+		return -EINVAL;
+
+	ret = smu_update_table(smu, SMU_TABLE_WATERMARKS, 0, table->cpu_addr,
+				true);
+
+	return ret;
+}
+
+int smu_set_watermarks_for_clock_ranges(struct smu_context *smu,
+		struct dm_pp_wm_sets_with_clock_ranges_soc15 *clock_ranges)
+{
+	int ret = 0;
+	struct smu_table *watermarks = &smu->smu_table.tables[SMU_TABLE_WATERMARKS];
+	void *table = watermarks->cpu_addr;
+
+	if (!smu->disable_watermark &&
+			smu_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&
+			smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
+		smu_set_watermarks_table(smu, table, clock_ranges);
+		smu->watermarks_bitmap |= WATERMARKS_EXIST;
+		smu->watermarks_bitmap &= ~WATERMARKS_LOADED;
+	}
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit 372120f0a5922655eb2579a50d6aafad474fd14c
Author: Kenneth Feng <kenneth.feng@amd.com>
Date:   Fri Oct 11 17:51:34 2019 +0800

    drm/amd/powerplay: bug fix for pcie parameters override
    
    Bug fix for pcie paramerers override on swsmu.
    Below is a scenario to have this problem.
    pptable definition on pcie dpm:
    0 -> pcie gen speed:1, pcie lanes: *16
    1 -> pcie gen speed:4, pcie lanes: *16
    Then if we have a system only have the capbility:
    pcie gen speed: 3, pcie lanes: *8,
    we will override dpm 1 to pcie gen speed 3, pcie lanes *8.
    But the code skips the dpm 0 configuration.
    So the real pcie dpm parameters are:
    0 -> pcie gen speed:1, pcie lanes: *16
    1 -> pcie gen speed:3, pcie lanes: *8
    Then the wrong pcie lanes will be toggled.
    
    Signed-off-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 8bb5287fe711..6cb52881e955 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -945,50 +945,6 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 	return 0;
 }
 
-static int smu_override_pcie_parameters(struct smu_context *smu)
-{
-	struct amdgpu_device *adev = smu->adev;
-	uint32_t pcie_gen = 0, pcie_width = 0, smu_pcie_arg;
-	int ret;
-
-	if (adev->flags & AMD_IS_APU)
-		return 0;
-
-	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN4)
-		pcie_gen = 3;
-	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)
-		pcie_gen = 2;
-	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)
-		pcie_gen = 1;
-	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN1)
-		pcie_gen = 0;
-
-	/* Bit 31:16: LCLK DPM level. 0 is DPM0, and 1 is DPM1
-	 * Bit 15:8:  PCIE GEN, 0 to 3 corresponds to GEN1 to GEN4
-	 * Bit 7:0:   PCIE lane width, 1 to 7 corresponds is x1 to x32
-	 */
-	if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X16)
-		pcie_width = 6;
-	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X12)
-		pcie_width = 5;
-	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X8)
-		pcie_width = 4;
-	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X4)
-		pcie_width = 3;
-	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X2)
-		pcie_width = 2;
-	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X1)
-		pcie_width = 1;
-
-	smu_pcie_arg = (1 << 16) | (pcie_gen << 8) | pcie_width;
-	ret = smu_send_smc_msg_with_param(smu,
-					  SMU_MSG_OverridePcieParameters,
-					  smu_pcie_arg);
-	if (ret)
-		pr_err("[%s] Attempt to override pcie params failed!\n", __func__);
-	return ret;
-}
-
 static int smu_smc_table_hw_init(struct smu_context *smu,
 				 bool initialize)
 {

commit 7e899409fd5e9abccee8435d9401b8ca12cebcae
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Oct 10 11:40:37 2019 +0800

    drm/amd/powerplay: enable df cstate control on swSMU routine
    
    Currently this is only supported on Vega20 with 40.50 and later
    SMC firmware.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c9266ea70331..8bb5287fe711 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1834,6 +1834,29 @@ int smu_set_mp1_state(struct smu_context *smu,
 	return ret;
 }
 
+int smu_set_df_cstate(struct smu_context *smu,
+		      enum pp_df_cstate state)
+{
+	int ret = 0;
+
+	/*
+	 * The SMC is not fully ready. That may be
+	 * expected as the IP may be masked.
+	 * So, just return without error.
+	 */
+	if (!smu->pm_enabled)
+		return 0;
+
+	if (!smu->ppt_funcs || !smu->ppt_funcs->set_df_cstate)
+		return 0;
+
+	ret = smu->ppt_funcs->set_df_cstate(smu, state);
+	if (ret)
+		pr_err("[SetDfCstate] failed!\n");
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit ea6d8811f18521a2188d1959f5fa2447e6bf5349
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Oct 7 12:02:06 2019 +0300

    drm/amd/powerplay: Fix error handling in smu_init_fb_allocations()
    
    The error handling is off by one.  We should not free the first
    "tables[i].bo" without decrementing "i" because that might result in a
    double free.  The second problem is that when an error occurs, then the
    zeroth element "tables[0].bo" isn't freed.
    
    I had make "i" signed int for the error handling to work, so I just
    updated "ret" as well as a clean up.
    
    Fixes: f96357a991b9 ("drm/amd/powerplay: implement smu_init(fini)_fb_allocations function")
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f1fbbc8b77ee..c9266ea70331 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -896,8 +896,7 @@ static int smu_init_fb_allocations(struct smu_context *smu)
 	struct amdgpu_device *adev = smu->adev;
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *tables = smu_table->tables;
-	uint32_t i = 0;
-	int32_t ret = 0;
+	int ret, i;
 
 	for (i = 0; i < SMU_TABLE_COUNT; i++) {
 		if (tables[i].size == 0)
@@ -915,7 +914,7 @@ static int smu_init_fb_allocations(struct smu_context *smu)
 
 	return 0;
 failed:
-	for (; i > 0; i--) {
+	while (--i >= 0) {
 		if (tables[i].size == 0)
 			continue;
 		amdgpu_bo_free_kernel(&tables[i].bo,

commit fa073f13a218627f1cfd5bca223d5938ee6cd985
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Oct 7 12:04:54 2019 +0300

    drm/amd/powerplay: unlock on error in smu_resume()
    
    This function needs to drop the mutex before returning.
    
    Fixes: f7e3a5776fa6 ("drm/amd/powerplay: check SMU engine readiness before proceeding on S3 resume")
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 6a64f765fcd4..f1fbbc8b77ee 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1384,7 +1384,7 @@ static int smu_resume(void *handle)
 	ret = smu_start_smc_engine(smu);
 	if (ret) {
 		pr_err("SMU is not ready yet!\n");
-		return ret;
+		goto failed;
 	}
 
 	ret = smu_smc_table_hw_init(smu, false);

commit fe9c32a63c0d3ba48f9aaccbcbb6c7f3fac60141
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Sep 27 14:52:10 2019 +0800

    drm/amd/powerplay: initlialize smu->is_apu is false by default
    
    the member of is_apu in smu_context need to initlialize by default.
    
    set default value is false (dGPU)
    
    for patch:
            drm/amd/powerplay: bypass dpm_context null pointer check guard
            for some smu series
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Prike Liang <Prike.Liang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 7b995b0834eb..6a64f765fcd4 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -712,6 +712,7 @@ static int smu_early_init(void *handle)
 
 	smu->adev = adev;
 	smu->pm_enabled = !!amdgpu_dpm;
+	smu->is_apu = false;
 	mutex_init(&smu->mutex);
 
 	return smu_set_funcs(adev);

commit 4045f36fce82ba7023bb7849190e04df8595e2f0
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Tue Sep 24 14:40:09 2019 +0800

    drm/amd/powerplay: implement the interface for setting soft freq range
    
    The APU soft freq range set by different way from DGPU, thus need implement
    the function respectively base on each common SMU part.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d9ef4ae4b8f6..7b995b0834eb 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -205,8 +205,7 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			    uint32_t min, uint32_t max)
 {
-	int ret = 0, clk_id = 0;
-	uint32_t param;
+	int ret = 0;
 
 	if (min <= 0 && max <= 0)
 		return -EINVAL;
@@ -214,27 +213,7 @@ int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (!smu_clk_dpm_is_enabled(smu, clk_type))
 		return 0;
 
-	clk_id = smu_clk_get_index(smu, clk_type);
-	if (clk_id < 0)
-		return clk_id;
-
-	if (max > 0) {
-		param = (uint32_t)((clk_id << 16) | (max & 0xffff));
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxByFreq,
-						  param);
-		if (ret)
-			return ret;
-	}
-
-	if (min > 0) {
-		param = (uint32_t)((clk_id << 16) | (min & 0xffff));
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinByFreq,
-						  param);
-		if (ret)
-			return ret;
-	}
-
-
+	ret = smu_set_soft_freq_limited_range(smu, clk_type, min, max);
 	return ret;
 }
 

commit af1ec44f9a56354bac98d000cbac2c8fed1f2e87
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Wed Sep 18 15:11:34 2019 +0800

    drm/amd/powerplay: bypass dpm_context null pointer check guard for some smu series
    
    For now APU has no smu_dpm_context structure for containing default/current related dpm tables,
    thus will needn't initialize smu_dpm_context to aviod APU null pointer issue.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index df510cb86da5..d9ef4ae4b8f6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1559,7 +1559,8 @@ static int smu_enable_umd_pstate(void *handle,
 
 	struct smu_context *smu = (struct smu_context*)(handle);
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
-	if (!smu->pm_enabled || !smu_dpm_ctx->dpm_context)
+
+	if (!smu->is_apu && (!smu->pm_enabled || !smu_dpm_ctx->dpm_context))
 		return -EINVAL;
 
 	if (!(smu_dpm_ctx->dpm_level & profile_mode_mask)) {
@@ -1757,7 +1758,7 @@ enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 	enum amd_dpm_forced_level level;
 
-	if (!smu_dpm_ctx->dpm_context)
+	if (!smu->is_apu && !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
 	mutex_lock(&(smu->mutex));
@@ -1772,7 +1773,7 @@ int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_lev
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 	int ret = 0;
 
-	if (!smu_dpm_ctx->dpm_context)
+	if (!smu->is_apu && !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
 	ret = smu_enable_umd_pstate(smu, &level);

commit 95f71bfad2c8015e46bce2c23b6f532afc6ab820
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Sep 26 16:22:13 2019 +0800

    drm/amd/powerplay: add sensor lock support for smu
    
    when multithreading access sysfs of amdgpu_pm_info at the sametime.
    the swsmu driver cause smu firmware hang.
    
    eg:
    single thread access:
    Message A + Param A ==> right
    Message B + Param B ==> right
    Message C + Param C ==> right
    multithreading access:
    Message A + Param B ==> error
    Message B + Param A ==> error
    Message C + Param C ==> right
    
    the patch will add sensor lock(mutex) to avoid this error.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 23293e15636b..df510cb86da5 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -840,6 +840,8 @@ static int smu_sw_init(void *handle)
 	smu->smu_baco.state = SMU_BACO_STATE_EXIT;
 	smu->smu_baco.platform_support = false;
 
+	mutex_init(&smu->sensor_lock);
+
 	smu->watermarks_bitmap = 0;
 	smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
 	smu->default_power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;

commit 068ad870bbd8f4f2c5b2fd4977a4f3330c9988f4
Author: chen gong <curry.gong@amd.com>
Date:   Mon Sep 23 15:02:56 2019 +0800

    drm/amd/powerplay: A workaround to GPU RESET on APU
    
    Changes to function "smu_suspend" in amdgpu_smu.c is a workaround.
    
    We should get real information about if baco is enabled or not, while we
    always consider APU SMU feature as enabled in current code.
    
    I know APU do not support baco mode for GPU reset, so I use
    "adev->flags" to skip function "smu_feature_is_enabled".
    
    Signed-off-by: chen gong <curry.gong@amd.com>
    Reviewed-by: Aaron Liu <aaron.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 90fa4448eddb..23293e15636b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1363,7 +1363,10 @@ static int smu_suspend(void *handle)
 	int ret;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
-	bool baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
+	bool baco_feature_is_enabled = false;
+
+	if(!(adev->flags & AMD_IS_APU))
+		baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
 
 	ret = smu_system_features_control(smu, false);
 	if (ret)

commit a90a24d581a919834b75758982ef3117020c0969
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Wed Sep 11 13:15:17 2019 +0800

    drm/amd/amdgpu: power up sdma engine when S3 resume back
    
    The sdma_v4 should be ungated when the IP resume back,
    otherwise it will hang up and resume time out error.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index dd97809c36af..90fa4448eddb 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -400,6 +400,9 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 	case AMD_IP_BLOCK_TYPE_GFX:
 		ret = smu_gfx_off_control(smu, gate);
 		break;
+	case AMD_IP_BLOCK_TYPE_SDMA:
+		ret = smu_powergate_sdma(smu, gate);
+		break;
 	default:
 		break;
 	}

commit f7e3a5776fa6d2d4376c59c7e1d5b3454745c865
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Sep 11 19:39:34 2019 +0800

    drm/amd/powerplay: check SMU engine readiness before proceeding on S3 resume
    
    This is especially needed for non-psp loading way.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index be01b88db3ec..dd97809c36af 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1213,11 +1213,10 @@ static int smu_free_memory_pool(struct smu_context *smu)
 	return ret;
 }
 
-static int smu_hw_init(void *handle)
+static int smu_start_smc_engine(struct smu_context *smu)
 {
-	int ret;
-	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
-	struct smu_context *smu = &adev->smu;
+	struct amdgpu_device *adev = smu->adev;
+	int ret = 0;
 
 	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
 		if (adev->asic_type < CHIP_NAVI10) {
@@ -1228,8 +1227,21 @@ static int smu_hw_init(void *handle)
 	}
 
 	ret = smu_check_fw_status(smu);
+	if (ret)
+		pr_err("SMC is not ready\n");
+
+	return ret;
+}
+
+static int smu_hw_init(void *handle)
+{
+	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+
+	ret = smu_start_smc_engine(smu);
 	if (ret) {
-		pr_err("SMC firmware status is not correct\n");
+		pr_err("SMU is not ready yet!\n");
 		return ret;
 	}
 
@@ -1381,6 +1393,12 @@ static int smu_resume(void *handle)
 
 	mutex_lock(&smu->mutex);
 
+	ret = smu_start_smc_engine(smu);
+	if (ret) {
+		pr_err("SMU is not ready yet!\n");
+		return ret;
+	}
+
 	ret = smu_smc_table_hw_init(smu, false);
 	if (ret)
 		goto failed;

commit 0e0b89c0d7cd1d7a53d0e7538a9d07c5692cf04d
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Sep 11 19:35:45 2019 +0800

    drm/amd/powerplay: properly set mp1 state for SW SMU suspend/reset routine
    
    Set mp1 state properly for SW SMU suspend/reset routine.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 03896e667c14..be01b88db3ec 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1788,6 +1788,46 @@ int smu_force_clk_levels(struct smu_context *smu,
 	return ret;
 }
 
+int smu_set_mp1_state(struct smu_context *smu,
+		      enum pp_mp1_state mp1_state)
+{
+	uint16_t msg;
+	int ret;
+
+	/*
+	 * The SMC is not fully ready. That may be
+	 * expected as the IP may be masked.
+	 * So, just return without error.
+	 */
+	if (!smu->pm_enabled)
+		return 0;
+
+	switch (mp1_state) {
+	case PP_MP1_STATE_SHUTDOWN:
+		msg = SMU_MSG_PrepareMp1ForShutdown;
+		break;
+	case PP_MP1_STATE_UNLOAD:
+		msg = SMU_MSG_PrepareMp1ForUnload;
+		break;
+	case PP_MP1_STATE_RESET:
+		msg = SMU_MSG_PrepareMp1ForReset;
+		break;
+	case PP_MP1_STATE_NONE:
+	default:
+		return 0;
+	}
+
+	/* some asics may not support those messages */
+	if (smu_msg_get_index(smu, msg) < 0)
+		return 0;
+
+	ret = smu_send_smc_msg(smu, msg);
+	if (ret)
+		pr_err("[PrepareMp1] Failed!\n");
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit 04c572a0df02892f29625a1d4e2bc1e65b741cf2
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Sep 5 12:22:42 2019 +0800

    drm/amd/powerplay: issue DC-BTC for arcturus on SMU init
    
    Need to perform DC-BTC for arcturus on bootup.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4681ebefc9c3..03896e667c14 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1079,8 +1079,8 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
-	/* issue RunAfllBtc msg */
-	ret = smu_run_afll_btc(smu);
+	/* issue Run*Btc msg */
+	ret = smu_run_btc(smu);
 	if (ret)
 		return ret;
 

commit 871e5e7219e720e7993c12e47197709d92cbf244
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Sep 3 16:02:33 2019 +0800

    drm/amd/powerplay: replace smu->table_count with SMU_TABLE_COUNT in smu (v2)
    
    fix bellow patch issue:
    drm/amd/powerplay: introduce smu table id type to handle the smu table
    for each asic
    ----
    "This patch introduces new smu table type, it's to handle the
     different smu table
     defines for each asic with the same smu ip."
    
    before:
    use smu->table_count to represent the actual table count in smc firmware
    use actual table count to check smu function parameter about smu table
    after:
    use logic table count "SMU_TABLE_COUNT" to check function parameter
    because table id already mapped in smu driver,
    and smu function will use logic table id not actual table id to check func parameter.
    
    v2: squash in warning fix
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 82a8298b7040..4681ebefc9c3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -482,7 +482,7 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	int ret = 0;
 	int table_id = smu_table_get_index(smu, table_index);
 
-	if (!table_data || table_id >= smu_table->table_count || table_id < 0)
+	if (!table_data || table_id >= SMU_TABLE_COUNT || table_id < 0)
 		return -EINVAL;
 
 	table = &smu_table->tables[table_index];
@@ -911,14 +911,10 @@ static int smu_init_fb_allocations(struct smu_context *smu)
 	struct amdgpu_device *adev = smu->adev;
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *tables = smu_table->tables;
-	uint32_t table_count = smu_table->table_count;
 	uint32_t i = 0;
 	int32_t ret = 0;
 
-	if (table_count <= 0)
-		return -EINVAL;
-
-	for (i = 0 ; i < table_count; i++) {
+	for (i = 0; i < SMU_TABLE_COUNT; i++) {
 		if (tables[i].size == 0)
 			continue;
 		ret = amdgpu_bo_create_kernel(adev,
@@ -949,13 +945,12 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *tables = smu_table->tables;
-	uint32_t table_count = smu_table->table_count;
 	uint32_t i = 0;
 
-	if (table_count == 0 || tables == NULL)
+	if (!tables)
 		return 0;
 
-	for (i = 0 ; i < table_count; i++) {
+	for (i = 0; i < SMU_TABLE_COUNT; i++) {
 		if (tables[i].size == 0)
 			continue;
 		amdgpu_bo_free_kernel(&tables[i].bo,

commit faa695c715e5c9203af824315127037499b33921
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Sep 2 12:37:23 2019 +0800

    drm/amd/powerplay: do proper cleanups on hw_fini
    
    These are needed for smu_reset support.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Jack Gui <Jack.Gui@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ceaf54d70103..82a8298b7040 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1283,6 +1283,11 @@ static int smu_hw_init(void *handle)
 	return ret;
 }
 
+static int smu_stop_dpms(struct smu_context *smu)
+{
+	return smu_send_smc_msg(smu, SMU_MSG_DisableAllSmuFeatures);
+}
+
 static int smu_hw_fini(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
@@ -1295,6 +1300,18 @@ static int smu_hw_fini(void *handle)
 		smu_powergate_vcn(&adev->smu, true);
 	}
 
+	ret = smu_stop_thermal_control(smu);
+	if (ret) {
+		pr_warn("Fail to stop thermal control!\n");
+		return ret;
+	}
+
+	ret = smu_stop_dpms(smu);
+	if (ret) {
+		pr_warn("Fail to stop Dpms!\n");
+		return ret;
+	}
+
 	kfree(table_context->driver_pptable);
 	table_context->driver_pptable = NULL;
 

commit c66846e069dec317b45a0a4b112d4cd7d885509e
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Aug 21 17:19:52 2019 +0800

    drm/amd/powerplay: update cached feature enablement status V3
    
    Need to update in cache feature enablement status after pp_feature
    settings. Another fix for the commit below:
    drm/amd/powerplay: implment sysfs feature status function in smu
    
    V2: update smu_feature_update_enable_state() and relates
    V3: use bitmap_or and bitmap_andnot
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Jack Gui <Jack.Gui@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0b0ae4714123..ceaf54d70103 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -95,6 +95,52 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 	return size;
 }
 
+static int smu_feature_update_enable_state(struct smu_context *smu,
+					   uint64_t feature_mask,
+					   bool enabled)
+{
+	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_low = 0, feature_high = 0;
+	int ret = 0;
+
+	if (!smu->pm_enabled)
+		return ret;
+
+	feature_low = (feature_mask >> 0 ) & 0xffffffff;
+	feature_high = (feature_mask >> 32) & 0xffffffff;
+
+	if (enabled) {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesLow,
+						  feature_low);
+		if (ret)
+			return ret;
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesHigh,
+						  feature_high);
+		if (ret)
+			return ret;
+	} else {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesLow,
+						  feature_low);
+		if (ret)
+			return ret;
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesHigh,
+						  feature_high);
+		if (ret)
+			return ret;
+	}
+
+	mutex_lock(&feature->mutex);
+	if (enabled)
+		bitmap_or(feature->enabled, feature->enabled,
+				(unsigned long *)(&feature_mask), SMU_FEATURE_MAX);
+	else
+		bitmap_andnot(feature->enabled, feature->enabled,
+				(unsigned long *)(&feature_mask), SMU_FEATURE_MAX);
+	mutex_unlock(&feature->mutex);
+
+	return ret;
+}
+
 int smu_sys_set_pp_feature_mask(struct smu_context *smu, uint64_t new_mask)
 {
 	int ret = 0;
@@ -566,41 +612,7 @@ int smu_feature_init_dpm(struct smu_context *smu)
 
 	return ret;
 }
-int smu_feature_update_enable_state(struct smu_context *smu, uint64_t feature_mask, bool enabled)
-{
-	uint32_t feature_low = 0, feature_high = 0;
-	int ret = 0;
-
-	if (!smu->pm_enabled)
-		return ret;
-
-	feature_low = (feature_mask >> 0 ) & 0xffffffff;
-	feature_high = (feature_mask >> 32) & 0xffffffff;
-
-	if (enabled) {
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesLow,
-						  feature_low);
-		if (ret)
-			return ret;
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesHigh,
-						  feature_high);
-		if (ret)
-			return ret;
-
-	} else {
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesLow,
-						  feature_low);
-		if (ret)
-			return ret;
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesHigh,
-						  feature_high);
-		if (ret)
-			return ret;
 
-	}
-
-	return ret;
-}
 
 int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
@@ -630,8 +642,6 @@ int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
 {
 	struct smu_feature *feature = &smu->smu_feature;
 	int feature_id;
-	uint64_t feature_mask = 0;
-	int ret = 0;
 
 	feature_id = smu_feature_get_index(smu, mask);
 	if (feature_id < 0)
@@ -639,22 +649,9 @@ int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
 
 	WARN_ON(feature_id > feature->feature_num);
 
-	feature_mask = 1ULL << feature_id;
-
-	mutex_lock(&feature->mutex);
-	ret = smu_feature_update_enable_state(smu, feature_mask, enable);
-	if (ret)
-		goto failed;
-
-	if (enable)
-		test_and_set_bit(feature_id, feature->enabled);
-	else
-		test_and_clear_bit(feature_id, feature->enabled);
-
-failed:
-	mutex_unlock(&feature->mutex);
-
-	return ret;
+	return smu_feature_update_enable_state(smu,
+					       1ULL << feature_id,
+					       enable);
 }
 
 int smu_feature_is_supported(struct smu_context *smu, enum smu_feature_mask mask)

commit f78c47f669086503844ea0d78b64a18c0e6f3e77
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Aug 30 17:30:46 2019 +0800

    drm/amd/powerplay: guard manual mode prerequisite for clock level force
    
    Force clock level is for dpm manual mode only.
    
    Reported-by: Candice Li <candice.li@amd.com>
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Jack Gui <Jack.Gui@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2a6091562135..0b0ae4714123 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1761,6 +1761,24 @@ int smu_set_display_count(struct smu_context *smu, uint32_t count)
 	return ret;
 }
 
+int smu_force_clk_levels(struct smu_context *smu,
+			 enum smu_clk_type clk_type,
+			 uint32_t mask)
+{
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	int ret = 0;
+
+	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
+		pr_debug("force clock level is for dpm manual mode only.\n");
+		return -EINVAL;
+	}
+
+	if (smu->ppt_funcs && smu->ppt_funcs->force_clk_levels)
+		ret = smu->ppt_funcs->force_clk_levels(smu, clk_type, mask);
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit bebc076285458ca6caa3246aa9c13ac062e14835
Author: Hawking Zhang <Hawking.Zhang@amd.com>
Date:   Fri Aug 23 19:39:18 2019 +0800

    drm/amdgpu: switch to new amdgpu_nbio structure
    
    no functional change, just switch to new structures
    
    Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 22f3c60d380f..2a6091562135 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -460,7 +460,7 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 		return ret;
 
 	/* flush hdp cache */
-	adev->nbio_funcs->hdp_flush(adev, NULL);
+	adev->nbio.funcs->hdp_flush(adev, NULL);
 
 	if (!drv2smu)
 		memcpy(table_data, table->cpu_addr, table->size);

commit ea1fc5e1ff7106f39d63e4a944990674b27af40d
Author: Aaron Liu <aaron.liu@amd.com>
Date:   Fri Aug 30 09:53:27 2019 +0800

    drm/amd/powerplay: SMU_MSG_OverridePcieParameters is unsupport for APU
    
    For apu, SMU_MSG_OverridePcieParameters is unsupport.
    So return directly in smu_override_pcie_parameters function.
    
    Signed-off-by: Aaron Liu <aaron.liu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 29ffb25b9e5e..22f3c60d380f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -975,6 +975,9 @@ static int smu_override_pcie_parameters(struct smu_context *smu)
 	uint32_t pcie_gen = 0, pcie_width = 0, smu_pcie_arg;
 	int ret;
 
+	if (adev->flags & AMD_IS_APU)
+		return 0;
+
 	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN4)
 		pcie_gen = 3;
 	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)

commit eee3258e8f8be822a6d7c15faa3f4a9e3081381e
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Thu Aug 15 16:53:08 2019 +0800

    drm/amd/powerplay: add the interface for getting ultimate frequency v3
    
    add the get_dpm_ultimate_freq for supporting different swSMU.
    -v2:
            Handle the unsupported clock type and read smc message failed case and return error code.
            Move the smu12 uclk frequency retrieved logic to renoir ppt.
    -v3:
            Use goto clause to handle invalidate clk index.
            Add the limited tag for smu_get_dpm_uclk to avoid other likewise interface introduced.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 5340556a34c5..29ffb25b9e5e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -231,9 +231,8 @@ int smu_set_hard_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			   uint32_t *min, uint32_t *max)
 {
-	int ret = 0, clk_id = 0;
-	uint32_t param = 0;
 	uint32_t clock_limit;
+	int ret = 0;
 
 	if (!min && !max)
 		return -EINVAL;
@@ -264,36 +263,11 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 
 		return 0;
 	}
-
-	mutex_lock(&smu->mutex);
-	clk_id = smu_clk_get_index(smu, clk_type);
-	if (clk_id < 0) {
-		ret = -EINVAL;
-		goto failed;
-	}
-
-	param = (clk_id & 0xffff) << 16;
-
-	if (max) {
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetMaxDpmFreq, param);
-		if (ret)
-			goto failed;
-		ret = smu_read_smc_arg(smu, max);
-		if (ret)
-			goto failed;
-	}
-
-	if (min) {
-		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetMinDpmFreq, param);
-		if (ret)
-			goto failed;
-		ret = smu_read_smc_arg(smu, min);
-		if (ret)
-			goto failed;
-	}
-
-failed:
-	mutex_unlock(&smu->mutex);
+	/*
+	 * Todo: Use each asic(ASIC_ppt funcs) control the callbacks exposed to the
+	 * core driver and then have helpers for stuff that is common(SMU_v11_x | SMU_v12_x funcs).
+	 */
+	ret = smu_get_dpm_ultimate_freq(smu, clk_type, min, max);
 	return ret;
 }
 

commit 296ae1038d43c54e0b0e7e4f398c867ba4beaaac
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Fri Aug 16 11:22:13 2019 +0800

    drm/amd/powerplay: enable populate DPM clocks table for swSMU APU
    
    Should populate DPM clocks tables during hw init,otherwise will
    suffer from invalidate table.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Aaron Liu <aaron.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ffbe4d881e48..5340556a34c5 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1042,9 +1042,6 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	struct amdgpu_device *adev = smu->adev;
 	int ret;
 
-	if (adev->flags & AMD_IS_APU)
-		return 0;
-
 	if (smu_is_dpm_running(smu) && adev->in_suspend) {
 		pr_info("dpm has been enabled\n");
 		return 0;

commit ffe61cd6423c9e5db973eb9d9f35accaeec0d9d8
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Thu Aug 15 09:39:06 2019 +0800

    drm/amd/powerplay: regards the APU always enable the dpm feature mask
    
    There is no driver message to enable/disable feature mask for APU.
    For the sake of APU reusing swSMU interface and assume APU supports all
    the feature.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Aaron Liu <aaron.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 99924d3538c2..ffbe4d881e48 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -636,7 +636,7 @@ int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 	int ret = 0;
 
 	if (adev->flags & AMD_IS_APU)
-		return 0;
+		return 1;
 
 	feature_id = smu_feature_get_index(smu, mask);
 	if (feature_id < 0)

commit 51b9121af0946afa4ef9fc164f4b0c1686af7225
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Fri Aug 9 14:17:40 2019 +0800

    drm/amd/powerplay: Disable renoir smu feature retrieve for the moment
    
    To avoid the dpm frequence range get failed when DPM enabled and it
    will be enabled later once handle well the feature bit map struct.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9e774f557771..99924d3538c2 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -630,10 +630,14 @@ int smu_feature_update_enable_state(struct smu_context *smu, uint64_t feature_ma
 
 int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
+	struct amdgpu_device *adev = smu->adev;
 	struct smu_feature *feature = &smu->smu_feature;
 	int feature_id;
 	int ret = 0;
 
+	if (adev->flags & AMD_IS_APU)
+		return 0;
+
 	feature_id = smu_feature_get_index(smu, mask);
 	if (feature_id < 0)
 		return 0;

commit d237e0974b21bebcc15ad1f8e23f51538230dcf5
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Thu Jul 25 13:56:51 2019 +0800

    drm/amd/powerplay: enable renoir dpm feature
    
    enable the dpm feature for the renoir.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Aaron Liu <aaron.liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 935f277e2438..9e774f557771 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -768,10 +768,6 @@ static int smu_late_init(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
-	/* To be removed after dpm is enabled */
-	if (adev->asic_type == CHIP_RENOIR)
-		return 0;
-
 	mutex_lock(&smu->mutex);
 	smu_handle_task(&adev->smu,
 			smu->smu_dpm.dpm_level,
@@ -1275,10 +1271,6 @@ static int smu_hw_init(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
-	/* To be removed after dpm is enabled */
-	if (adev->asic_type == CHIP_RENOIR)
-		return 0;
-
 	ret = smu_feature_init_dpm(smu);
 	if (ret)
 		goto failed;

commit 723d473537778f3f1bd9a91eb286aa5c349c8f0e
Author: Aaron Liu <aaron.liu@amd.com>
Date:   Tue Jul 30 11:28:27 2019 +0800

    drm/amd/powerplay: add DPMCLOCKS table implementation
    
    This patch adds add DPMCLOCKS table implementation
    Rename smu_populate_smc_pptable to smu_populate_smc_tables
    
    Signed-off-by: Aaron Liu <aaron.liu@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 95972901db14..935f277e2438 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1150,7 +1150,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	 * type of clks.
 	 */
 	if (initialize) {
-		ret = smu_populate_smc_pptable(smu);
+		ret = smu_populate_smc_tables(smu);
 		if (ret)
 			return ret;
 

commit 9f21e9ee7f2ffc64a2f0f1f821fb22ded9d18761
Author: Aaron Liu <aaron.liu@amd.com>
Date:   Tue Jul 16 17:33:47 2019 +0800

    drm/amdgpu: add and enable gfxoff feature
    
    This patch updates gfxoff feature.
    
    Signed-off-by: Aaron Liu <aaron.liu@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c8687107d9c9..95972901db14 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -737,7 +737,6 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 		smu_v11_0_set_smu_funcs(smu);
 		break;
 	case CHIP_RENOIR:
-		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
 			smu->od_enabled = true;
 		smu_v12_0_set_smu_funcs(smu);

commit 47903831ada9d6549a5ad2db66d74166cbc211fa
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Aug 8 15:23:17 2019 -0500

    drm/amd/powerplay: powerup sdma/vcn for all apu series
    
    All apu series need powerup sdma and vcn via smu messages.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index cce08c2a43f6..c8687107d9c9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1268,7 +1268,7 @@ static int smu_hw_init(void *handle)
 		return ret;
 	}
 
-	if (adev->asic_type == CHIP_RENOIR) {
+	if (adev->flags & AMD_IS_APU) {
 		smu_powergate_sdma(&adev->smu, false);
 		smu_powergate_vcn(&adev->smu, false);
 	}
@@ -1324,7 +1324,7 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
-	if (adev->asic_type == CHIP_RENOIR) {
+	if (adev->flags & AMD_IS_APU) {
 		smu_powergate_sdma(&adev->smu, true);
 		smu_powergate_vcn(&adev->smu, true);
 	}

commit 4a6296680baea5aa118a7617ef0b23606e3d6b5c
Author: Leo Liu <leo.liu@amd.com>
Date:   Thu Aug 8 15:21:44 2019 -0500

    drm/amdgpu/powerplay: add Renoir VCN power management
    
    Thus VCN can be powered up for normal operations
    
    Signed-off-by: Leo Liu <leo.liu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Aaron Liu <aaron.liu@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d63beff7620e..cce08c2a43f6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1268,8 +1268,10 @@ static int smu_hw_init(void *handle)
 		return ret;
 	}
 
-	if (adev->asic_type == CHIP_RENOIR)
+	if (adev->asic_type == CHIP_RENOIR) {
 		smu_powergate_sdma(&adev->smu, false);
+		smu_powergate_vcn(&adev->smu, false);
+	}
 
 	if (!smu->pm_enabled)
 		return 0;
@@ -1322,8 +1324,10 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
-	if (adev->asic_type == CHIP_RENOIR)
+	if (adev->asic_type == CHIP_RENOIR) {
 		smu_powergate_sdma(&adev->smu, true);
+		smu_powergate_vcn(&adev->smu, true);
+	}
 
 	kfree(table_context->driver_pptable);
 	table_context->driver_pptable = NULL;

commit 51548c0fe3d3487c277608bb6436882d0f052fae
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Jul 24 14:05:11 2019 -0500

    drm/amdgpu: skip dpm init for renoir
    
    Renoir DPM is not functional so far, we skip it for the comment.
    Will revert this patch once SMU 12 is functional.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b9dee9934f0a..d63beff7620e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -768,6 +768,11 @@ static int smu_late_init(void *handle)
 
 	if (!smu->pm_enabled)
 		return 0;
+
+	/* To be removed after dpm is enabled */
+	if (adev->asic_type == CHIP_RENOIR)
+		return 0;
+
 	mutex_lock(&smu->mutex);
 	smu_handle_task(&adev->smu,
 			smu->smu_dpm.dpm_level,
@@ -1269,6 +1274,10 @@ static int smu_hw_init(void *handle)
 	if (!smu->pm_enabled)
 		return 0;
 
+	/* To be removed after dpm is enabled */
+	if (adev->asic_type == CHIP_RENOIR)
+		return 0;
+
 	ret = smu_feature_init_dpm(smu);
 	if (ret)
 		goto failed;

commit 97222cfac7740ba93c2c17f15db5d7184c6ab836
Author: Aaron Liu <aaron.liu@amd.com>
Date:   Fri Aug 9 10:34:40 2019 -0500

    drm/amdgpu/powerplay: add power up/down SDMA interfaces for renoir
    
    1.Implement PowerUpSDMA/PowerDownSDMA interfaces in the swSMU for renoir
    2.adjust smu ip block ahead of gfx&sdma ip block
    
    Signed-off-by: Aaron Liu <aaron.liu@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c35c8a273051..b9dee9934f0a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1263,6 +1263,9 @@ static int smu_hw_init(void *handle)
 		return ret;
 	}
 
+	if (adev->asic_type == CHIP_RENOIR)
+		smu_powergate_sdma(&adev->smu, false);
+
 	if (!smu->pm_enabled)
 		return 0;
 
@@ -1310,6 +1313,9 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
+	if (adev->asic_type == CHIP_RENOIR)
+		smu_powergate_sdma(&adev->smu, true);
+
 	kfree(table_context->driver_pptable);
 	table_context->driver_pptable = NULL;
 

commit 5dbbe6a77d189954287b524988b994bfda75efd6
Author: Aaron Liu <aaron.liu@amd.com>
Date:   Wed Jul 24 14:00:01 2019 -0500

    drm/amdgpu/powerplay: add smu ip block for renoir (v2)
    
    add swSMU [smu_v12_0] for renoir
    
    v2: whitespace fixes (Alex)
    
    Signed-off-by: Aaron Liu <aaron.liu@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2d7db2e68140..c35c8a273051 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -27,6 +27,7 @@
 #include "amdgpu_smu.h"
 #include "soc15_common.h"
 #include "smu_v11_0.h"
+#include "smu_v12_0.h"
 #include "atom.h"
 #include "amd_pcie.h"
 
@@ -735,6 +736,12 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 			smu->od_enabled = true;
 		smu_v11_0_set_smu_funcs(smu);
 		break;
+	case CHIP_RENOIR:
+		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
+		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
+			smu->od_enabled = true;
+		smu_v12_0_set_smu_funcs(smu);
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1031,6 +1038,9 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	struct amdgpu_device *adev = smu->adev;
 	int ret;
 
+	if (adev->flags & AMD_IS_APU)
+		return 0;
+
 	if (smu_is_dpm_running(smu) && adev->in_suspend) {
 		pr_info("dpm has been enabled\n");
 		return 0;
@@ -1790,3 +1800,12 @@ const struct amdgpu_ip_block_version smu_v11_0_ip_block =
 	.rev = 0,
 	.funcs = &smu_ip_funcs,
 };
+
+const struct amdgpu_ip_block_version smu_v12_0_ip_block =
+{
+	.type = AMD_IP_BLOCK_TYPE_SMC,
+	.major = 12,
+	.minor = 0,
+	.rev = 0,
+	.funcs = &smu_ip_funcs,
+};

commit 9b4e63f4513bbd626b2490ce81435a38d7bc3902
Author: Kenneth Feng <kenneth.feng@amd.com>
Date:   Tue Jul 23 12:16:25 2019 +0800

    drm/amd/powerplay: change smu_read_sensor sequence in smu
    
    change the smu_read_sensor sequence to:
    
    asic specific sensor read -> smu v11 specific sensor read -> smu v11 common sensor read
    
    Signed-off-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index dd274922ed8a..2d7db2e68140 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -413,6 +413,9 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 	struct smu_power_gate *power_gate = &smu_power->power_gate;
 	int ret = 0;
 
+	if(!data || !size)
+		return -EINVAL;
+
 	switch (sensor) {
 	case AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK:
 		*((uint32_t *)data) = smu->pstate_sclk;

commit 9234c587a81f360b80aeb7bed643d1405627d6c9
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Aug 5 14:53:12 2019 +0800

    drm/amd/powerplay: skip pcie params override on Arcturus V2
    
    This is not supported on Arcturus.
    
    Affected ASIC: Arcturus
    
    V2: minor cosmetic fix
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Le Ma <Le.Ma@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3b44bbc6f1e7..dd274922ed8a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1109,11 +1109,11 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
-	ret = smu_override_pcie_parameters(smu);
-	if (ret)
-		return ret;
-
 	if (adev->asic_type != CHIP_ARCTURUS) {
+		ret = smu_override_pcie_parameters(smu);
+		if (ret)
+			return ret;
+
 		ret = smu_notify_display_change(smu);
 		if (ret)
 			return ret;

commit 9ea8da75ba43a344a06b7c811a61277e9075a96b
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Thu Aug 1 14:54:59 2019 -0500

    drm/amdgpu/smu11: add smu support for navi12
    
    Same as other Navi asics.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 00651118102c..3b44bbc6f1e7 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -726,6 +726,7 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 	case CHIP_VEGA20:
 	case CHIP_NAVI10:
 	case CHIP_NAVI14:
+	case CHIP_NAVI12:
 	case CHIP_ARCTURUS:
 		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
 			smu->od_enabled = true;

commit 706e50829eb7f667f259c83629bdf9e6c992772b
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Aug 2 16:38:32 2019 +0800

    drm/amd/powerplay: correct navi10 vcn powergate
    
    vcn dpm on is a prerequisite for vcn power gate control.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 07d0f0c5d2c1..00651118102c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -409,6 +409,8 @@ int smu_get_power_num_states(struct smu_context *smu,
 int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 			   void *data, uint32_t *size)
 {
+	struct smu_power_context *smu_power = &smu->smu_power;
+	struct smu_power_gate *power_gate = &smu_power->power_gate;
 	int ret = 0;
 
 	switch (sensor) {
@@ -433,7 +435,7 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 		*size = 4;
 		break;
 	case AMDGPU_PP_SENSOR_VCN_POWER_STATE:
-		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT) ? 1 : 0;
+		*(uint32_t *)data = power_gate->vcn_gated ? 0 : 1;
 		*size = 4;
 		break;
 	default:

commit 4abc1765d2f74f706fdae067f3aec5c0778154d6
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Jul 31 10:34:36 2019 +0800

    drm/amd/powerplay: enable SW SMU power profile switch support in KFD
    
    Hook up the SW SMU power profile switch in KFD routine.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0a20279a5ff8..07d0f0c5d2c1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1677,6 +1677,42 @@ int smu_handle_task(struct smu_context *smu,
 	return ret;
 }
 
+int smu_switch_power_profile(struct smu_context *smu,
+			     enum PP_SMC_POWER_PROFILE type,
+			     bool en)
+{
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	long workload;
+	uint32_t index;
+
+	if (!smu->pm_enabled)
+		return -EINVAL;
+
+	if (!(type < PP_SMC_POWER_PROFILE_CUSTOM))
+		return -EINVAL;
+
+	mutex_lock(&smu->mutex);
+
+	if (!en) {
+		smu->workload_mask &= ~(1 << smu->workload_prority[type]);
+		index = fls(smu->workload_mask);
+		index = index > 0 && index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload = smu->workload_setting[index];
+	} else {
+		smu->workload_mask |= (1 << smu->workload_prority[type]);
+		index = fls(smu->workload_mask);
+		index = index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload = smu->workload_setting[index];
+	}
+
+	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)
+		smu_set_power_profile_mode(smu, &workload, 0);
+
+	mutex_unlock(&smu->mutex);
+
+	return 0;
+}
+
 enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);

commit 839f9117e1c27593245fb2af952a81d11a13b7c9
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jul 30 16:39:45 2019 +0800

    drm/amd/powerplay: guard consistency between CPU copy and local VRAM
    
    This can prevent CPU to use the out-dated copy.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4b9d51231a46..0a20279a5ff8 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -451,6 +451,7 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 		     void *table_data, bool drv2smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
+	struct amdgpu_device *adev = smu->adev;
 	struct smu_table *table = NULL;
 	int ret = 0;
 	int table_id = smu_table_get_index(smu, table_index);
@@ -478,6 +479,9 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	if (ret)
 		return ret;
 
+	/* flush hdp cache */
+	adev->nbio_funcs->hdp_flush(adev, NULL);
+
 	if (!drv2smu)
 		memcpy(table_data, table->cpu_addr, table->size);
 

commit ab63131155b0d86156b892a5d380dc337271aed9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Aug 1 09:39:41 2019 +0100

    drm/amd/powerplay: fix a few spelling mistakes
    
    There are a few spelling mistakes "unknow" -> "unknown" and
    "enabeld" -> "enabled". Fix these.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fb9d6c1b3f33..4b9d51231a46 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -39,7 +39,7 @@ static const char* __smu_message_names[] = {
 const char *smu_get_message_name(struct smu_context *smu, enum smu_message_type type)
 {
 	if (type < 0 || type >= SMU_MSG_MAX_COUNT)
-		return "unknow smu message";
+		return "unknown smu message";
 	return __smu_message_names[type];
 }
 
@@ -52,7 +52,7 @@ static const char* __smu_feature_names[] = {
 const char *smu_get_feature_name(struct smu_context *smu, enum smu_feature_mask feature)
 {
 	if (feature < 0 || feature >= SMU_FEATURE_COUNT)
-		return "unknow smu feature";
+		return "unknown smu feature";
 	return __smu_feature_names[feature];
 }
 
@@ -87,7 +87,7 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 			       smu_get_feature_name(smu, sort_feature[i]),
 			       i,
 			       !!smu_feature_is_enabled(smu, sort_feature[i]) ?
-			       "enabeld" : "disabled");
+			       "enabled" : "disabled");
 	}
 
 failed:

commit e3bf125bdbb6efed2d650effbc3c13320602d64a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Aug 1 12:15:41 2019 +0100

    drm/amd/powerplay: fix off-by-one upper bounds limit checks
    
    There are two occurrances of off-by-one upper bound checking of indexes
    causing potential out-of-bounds array reads. Fix these.
    
    Addresses-Coverity: ("Out-of-bounds read")
    Fixes: cb33363d0e85 ("drm/amd/powerplay: add smu feature name support")
    Fixes: 6b294793e384 ("drm/amd/powerplay: add smu message name support")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 7414ed9a5013..fb9d6c1b3f33 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -38,7 +38,7 @@ static const char* __smu_message_names[] = {
 
 const char *smu_get_message_name(struct smu_context *smu, enum smu_message_type type)
 {
-	if (type < 0 || type > SMU_MSG_MAX_COUNT)
+	if (type < 0 || type >= SMU_MSG_MAX_COUNT)
 		return "unknow smu message";
 	return __smu_message_names[type];
 }
@@ -51,7 +51,7 @@ static const char* __smu_feature_names[] = {
 
 const char *smu_get_feature_name(struct smu_context *smu, enum smu_feature_mask feature)
 {
-	if (feature < 0 || feature > SMU_FEATURE_COUNT)
+	if (feature < 0 || feature >= SMU_FEATURE_COUNT)
 		return "unknow smu feature";
 	return __smu_feature_names[feature];
 }

commit 67194518cb1979d775e10089d00c015d6737c194
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Wed Jul 31 15:37:07 2019 +0800

    drm/amd/powerplay: sort feature status index by asic feature id for smu
    
    before this change, the pp_feature sysfs show feature enable state by
    logic feature id, it is not easy to read.
    this change will sort pp_features show index by asic feature id.
    
    before:
    features high: 0x00000623 low: 0xb3cdaffb
    00. DPM_PREFETCHER       ( 0) : enabeld
    01. DPM_GFXCLK           ( 1) : enabeld
    02. DPM_UCLK             ( 3) : enabeld
    03. DPM_SOCCLK           ( 4) : enabeld
    04. DPM_MP0CLK           ( 5) : enabeld
    05. DPM_LINK             ( 6) : enabeld
    06. DPM_DCEFCLK          ( 7) : enabeld
    07. DS_GFXCLK            (10) : enabeld
    08. DS_SOCCLK            (11) : enabeld
    09. DS_LCLK              (12) : disabled
    10. PPT                  (23) : enabeld
    11. TDC                  (24) : enabeld
    12. THERMAL              (33) : enabeld
    13. RM                   (35) : disabled
    ......
    
    after:
    features high: 0x00000623 low: 0xb3cdaffb
    00. DPM_PREFETCHER       ( 0) : enabeld
    01. DPM_GFXCLK           ( 1) : enabeld
    02. DPM_GFX_PACE         ( 2) : disabled
    03. DPM_UCLK             ( 3) : enabeld
    04. DPM_SOCCLK           ( 4) : enabeld
    05. DPM_MP0CLK           ( 5) : enabeld
    06. DPM_LINK             ( 6) : enabeld
    07. DPM_DCEFCLK          ( 7) : enabeld
    08. MEM_VDDCI_SCALING    ( 8) : enabeld
    09. MEM_MVDD_SCALING     ( 9) : enabeld
    10. DS_GFXCLK            (10) : enabeld
    11. DS_SOCCLK            (11) : enabeld
    12. DS_LCLK              (12) : disabled
    13. DS_DCEFCLK           (13) : enabeld
    ......
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 13b2c8a60232..7414ed9a5013 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -63,6 +63,8 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 	uint32_t feature_mask[2] = { 0 };
 	int32_t feature_index = 0;
 	uint32_t count = 0;
+	uint32_t sort_feature[SMU_FEATURE_COUNT];
+	uint64_t hw_feature_count = 0;
 
 	ret = smu_feature_get_enabled_mask(smu, feature_mask, 2);
 	if (ret)
@@ -75,11 +77,17 @@ size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
 		feature_index = smu_feature_get_index(smu, i);
 		if (feature_index < 0)
 			continue;
+		sort_feature[feature_index] = i;
+		hw_feature_count++;
+	}
+
+	for (i = 0; i < hw_feature_count; i++) {
 		size += sprintf(buf + size, "%02d. %-20s (%2d) : %s\n",
 			       count++,
-			       smu_get_feature_name(smu, i),
-			       feature_index,
-			       !!smu_feature_is_enabled(smu, i) ? "enabeld" : "disabled");
+			       smu_get_feature_name(smu, sort_feature[i]),
+			       i,
+			       !!smu_feature_is_enabled(smu, sort_feature[i]) ?
+			       "enabeld" : "disabled");
 	}
 
 failed:

commit b4af964e75c4163fe3baf98193495f7921a4b3b7
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jul 30 22:52:37 2019 -0500

    drm/amd/powerplay: make power limit retrieval as asic specific
    
    The power limit retrieval should be done per asic. Since we may
    need to lookup in the pptable and that's really asic specific.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b1e0e2a4aca1..13b2c8a60232 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1136,7 +1136,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		if (ret)
 			return ret;
 
-		ret = smu_get_power_limit(smu, &smu->default_power_limit, false);
+		ret = smu_get_power_limit(smu, &smu->default_power_limit, true);
 		if (ret)
 			return ret;
 	}

commit bf2bf52383a09256e11278e7bcb67dcd912078c7
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon Jul 22 09:57:27 2019 +0800

    drm/amd/powerplay: support VCN powergate status retrieval for SW SMU
    
    Commonly used for VCN powergate status retrieval for SW SMU.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9de7b369901e..b1e0e2a4aca1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -424,6 +424,10 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_VCE_BIT) ? 1 : 0;
 		*size = 4;
 		break;
+	case AMDGPU_PP_SENSOR_VCN_POWER_STATE:
+		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT) ? 1 : 0;
+		*size = 4;
+		break;
 	default:
 		ret = -EINVAL;
 		break;

commit 22e1831734716f9e3e4fb1f88060f0efaa59fc6f
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jul 30 23:30:07 2019 -0500

    drm/amd/powerplay: enable SW SMU routine support for arcturus
    
    Enable arcturus SW SMU routines.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fd0485b29429..9de7b369901e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -476,7 +476,7 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 {
 	if (adev->asic_type == CHIP_VEGA20)
 		return (amdgpu_dpm == 2) ? true : false;
-	else if (adev->asic_type >= CHIP_NAVI10)
+	else if (adev->asic_type >= CHIP_ARCTURUS)
 		return true;
 	else
 		return false;
@@ -708,6 +708,7 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 	case CHIP_VEGA20:
 	case CHIP_NAVI10:
 	case CHIP_NAVI14:
+	case CHIP_ARCTURUS:
 		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
 			smu->od_enabled = true;
 		smu_v11_0_set_smu_funcs(smu);
@@ -1013,9 +1014,11 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		return 0;
 	}
 
-	ret = smu_init_display_count(smu, 0);
-	if (ret)
-		return ret;
+	if (adev->asic_type != CHIP_ARCTURUS) {
+		ret = smu_init_display_count(smu, 0);
+		if (ret)
+			return ret;
+	}
 
 	if (initialize) {
 		/* get boot_values from vbios to set revision, gfxclk, and etc. */
@@ -1091,17 +1094,19 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
-	ret = smu_notify_display_change(smu);
-	if (ret)
-		return ret;
+	if (adev->asic_type != CHIP_ARCTURUS) {
+		ret = smu_notify_display_change(smu);
+		if (ret)
+			return ret;
 
-	/*
-	 * Set min deep sleep dce fclk with bootup value from vbios via
-	 * SetMinDeepSleepDcefclk MSG.
-	 */
-	ret = smu_set_min_dcef_deep_sleep(smu);
-	if (ret)
-		return ret;
+		/*
+		 * Set min deep sleep dce fclk with bootup value from vbios via
+		 * SetMinDeepSleepDcefclk MSG.
+		 */
+		ret = smu_set_min_dcef_deep_sleep(smu);
+		if (ret)
+			return ret;
+	}
 
 	/*
 	 * Set initialized values (get from vbios) to dpm tables context such as
@@ -1212,14 +1217,20 @@ static int smu_hw_init(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {
-		ret = smu_check_fw_status(smu);
-		if (ret) {
-			pr_err("SMC firmware status is not correct\n");
-			return ret;
+	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
+		if (adev->asic_type < CHIP_NAVI10) {
+			ret = smu_load_microcode(smu);
+			if (ret)
+				return ret;
 		}
 	}
 
+	ret = smu_check_fw_status(smu);
+	if (ret) {
+		pr_err("SMC firmware status is not correct\n");
+		return ret;
+	}
+
 	if (!smu->pm_enabled)
 		return 0;
 

commit 7c8bcaf4085af03365e86f11dba6a8363ef87c07
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jul 30 22:50:14 2019 -0500

    drm/amd/powerplay: add SW SMU interface for dumping pptable out (v2)
    
    This is especially useful in early bring up phase.
    
    v2: disabled by default (Alex)
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Le Ma <Le.Ma@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4a2ccc5fae73..fd0485b29429 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1064,6 +1064,8 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 			return ret;
 	}
 
+	/* smu_dump_pptable(smu); */
+
 	/*
 	 * Copy pptable bo in the vram to smc with SMU MSGs such as
 	 * SetDriverDramAddr and TransferTableDram2Smu.

commit 98eb03bbf0175f009a74c80ac12b91a9680292f4
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Jul 25 11:47:44 2019 +0800

    drm/amd/powerplay: implment sysfs feature status function in smu
    
    1. Unified feature enable status format in sysfs
    2. Rename ppfeature to pp_features to adapt other pp sysfs node name
    3. this function support all asic, not asic related function.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Acked-by: Rui Huang <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f19e5957bd13..4a2ccc5fae73 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -56,6 +56,67 @@ const char *smu_get_feature_name(struct smu_context *smu, enum smu_feature_mask
 	return __smu_feature_names[feature];
 }
 
+size_t smu_sys_get_pp_feature_mask(struct smu_context *smu, char *buf)
+{
+	size_t size = 0;
+	int ret = 0, i = 0;
+	uint32_t feature_mask[2] = { 0 };
+	int32_t feature_index = 0;
+	uint32_t count = 0;
+
+	ret = smu_feature_get_enabled_mask(smu, feature_mask, 2);
+	if (ret)
+		goto failed;
+
+	size =  sprintf(buf + size, "features high: 0x%08x low: 0x%08x\n",
+			feature_mask[1], feature_mask[0]);
+
+	for (i = 0; i < SMU_FEATURE_COUNT; i++) {
+		feature_index = smu_feature_get_index(smu, i);
+		if (feature_index < 0)
+			continue;
+		size += sprintf(buf + size, "%02d. %-20s (%2d) : %s\n",
+			       count++,
+			       smu_get_feature_name(smu, i),
+			       feature_index,
+			       !!smu_feature_is_enabled(smu, i) ? "enabeld" : "disabled");
+	}
+
+failed:
+	return size;
+}
+
+int smu_sys_set_pp_feature_mask(struct smu_context *smu, uint64_t new_mask)
+{
+	int ret = 0;
+	uint32_t feature_mask[2] = { 0 };
+	uint64_t feature_2_enabled = 0;
+	uint64_t feature_2_disabled = 0;
+	uint64_t feature_enables = 0;
+
+	ret = smu_feature_get_enabled_mask(smu, feature_mask, 2);
+	if (ret)
+		return ret;
+
+	feature_enables = ((uint64_t)feature_mask[1] << 32 | (uint64_t)feature_mask[0]);
+
+	feature_2_enabled  = ~feature_enables & new_mask;
+	feature_2_disabled = feature_enables & ~new_mask;
+
+	if (feature_2_enabled) {
+		ret = smu_feature_update_enable_state(smu, feature_2_enabled, true);
+		if (ret)
+			return ret;
+	}
+	if (feature_2_disabled) {
+		ret = smu_feature_update_enable_state(smu, feature_2_disabled, false);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
 int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t *smu_version)
 {
 	int ret = 0;

commit 26dd668155b24eb24401aed9d73e2f9c7b694ea6
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Jul 25 11:57:25 2019 +0800

    drm/amd/powerplay: move smu_feature_update_enable_state to up level
    
    this function is not ip or asic related function,
    so move it to top level as public api in smu.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 22b581ab8549..f19e5957bd13 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -509,6 +509,41 @@ int smu_feature_init_dpm(struct smu_context *smu)
 
 	return ret;
 }
+int smu_feature_update_enable_state(struct smu_context *smu, uint64_t feature_mask, bool enabled)
+{
+	uint32_t feature_low = 0, feature_high = 0;
+	int ret = 0;
+
+	if (!smu->pm_enabled)
+		return ret;
+
+	feature_low = (feature_mask >> 0 ) & 0xffffffff;
+	feature_high = (feature_mask >> 32) & 0xffffffff;
+
+	if (enabled) {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesLow,
+						  feature_low);
+		if (ret)
+			return ret;
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_EnableSmuFeaturesHigh,
+						  feature_high);
+		if (ret)
+			return ret;
+
+	} else {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesLow,
+						  feature_low);
+		if (ret)
+			return ret;
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_DisableSmuFeaturesHigh,
+						  feature_high);
+		if (ret)
+			return ret;
+
+	}
+
+	return ret;
+}
 
 int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
@@ -534,6 +569,7 @@ int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
 {
 	struct smu_feature *feature = &smu->smu_feature;
 	int feature_id;
+	uint64_t feature_mask = 0;
 	int ret = 0;
 
 	feature_id = smu_feature_get_index(smu, mask);
@@ -542,8 +578,10 @@ int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
 
 	WARN_ON(feature_id > feature->feature_num);
 
+	feature_mask = 1ULL << feature_id;
+
 	mutex_lock(&feature->mutex);
-	ret = smu_feature_update_enable_state(smu, feature_id, enable);
+	ret = smu_feature_update_enable_state(smu, feature_mask, enable);
 	if (ret)
 		goto failed;
 

commit cb33363d0e85341c8781d9095341a981ab410a80
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Jul 25 11:08:42 2019 +0800

    drm/amd/powerplay: add smu feature name support
    
    add smu_get_feature_name support in smu.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fb967c6d5046..22b581ab8549 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -43,6 +43,19 @@ const char *smu_get_message_name(struct smu_context *smu, enum smu_message_type
 	return __smu_message_names[type];
 }
 
+#undef __SMU_DUMMY_MAP
+#define __SMU_DUMMY_MAP(fea)	#fea
+static const char* __smu_feature_names[] = {
+	SMU_FEATURE_MASKS
+};
+
+const char *smu_get_feature_name(struct smu_context *smu, enum smu_feature_mask feature)
+{
+	if (feature < 0 || feature > SMU_FEATURE_COUNT)
+		return "unknow smu feature";
+	return __smu_feature_names[feature];
+}
+
 int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t *smu_version)
 {
 	int ret = 0;

commit 6b294793e3846988ca1234c324ae256b25cee9cf
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Jul 25 10:32:48 2019 +0800

    drm/amd/powerplay: add smu message name support
    
    add smu_get_message_name support in smu.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e8dba0256457..fb967c6d5046 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -30,6 +30,19 @@
 #include "atom.h"
 #include "amd_pcie.h"
 
+#undef __SMU_DUMMY_MAP
+#define __SMU_DUMMY_MAP(type)	#type
+static const char* __smu_message_names[] = {
+	SMU_MESSAGE_TYPES
+};
+
+const char *smu_get_message_name(struct smu_context *smu, enum smu_message_type type)
+{
+	if (type < 0 || type > SMU_MSG_MAX_COUNT)
+		return "unknow smu message";
+	return __smu_message_names[type];
+}
+
 int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t *smu_version)
 {
 	int ret = 0;

commit 4d7fd9e20b0784b07777728316da5bcc13f9f2ab
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Jul 25 10:12:42 2019 +0800

    drm/amd/powerplay: enable SW SMU reset functionality
    
    Move SMU irq handler register to sw_init as that's totally
    software related. Otherwise, it will prevent SMU reset working.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 24644f320073..e8dba0256457 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -743,6 +743,12 @@ static int smu_sw_init(void *handle)
 		return ret;
 	}
 
+	ret = smu_register_irq_handler(smu);
+	if (ret) {
+		pr_err("Failed to register smc irq handler!\n");
+		return ret;
+	}
+
 	return 0;
 }
 
@@ -752,6 +758,9 @@ static int smu_sw_fini(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
+	kfree(smu->irq_source);
+	smu->irq_source = NULL;
+
 	ret = smu_smc_table_sw_fini(smu);
 	if (ret) {
 		pr_err("Failed to sw fini smc table!\n");
@@ -1111,10 +1120,6 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
-	ret = smu_register_irq_handler(smu);
-	if (ret)
-		goto failed;
-
 	if (!smu->pm_enabled)
 		adev->pm.dpm_enabled = false;
 	else
@@ -1144,9 +1149,6 @@ static int smu_hw_fini(void *handle)
 	kfree(table_context->overdrive_table);
 	table_context->overdrive_table = NULL;
 
-	kfree(smu->irq_source);
-	smu->irq_source = NULL;
-
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)
 		return ret;

commit f0d2a7dc1154ed680a8422916ab6a38860800de4
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Jul 25 12:10:34 2019 +0800

    drm/amd/powerplay: fix null pointer dereference around dpm state relates
    
    DPM state relates are not supported on the new SW SMU ASICs. But still
    it's not OK to trigger null pointer dereference on accessing them.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d8bb18445086..24644f320073 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -305,7 +305,8 @@ int smu_get_power_num_states(struct smu_context *smu,
 
 	/* not support power state */
 	memset(state_info, 0, sizeof(struct pp_states_info));
-	state_info->nums = 0;
+	state_info->nums = 1;
+	state_info->states[0] = POWER_STATE_TYPE_DEFAULT;
 
 	return 0;
 }

commit 780f3a9c5b9f739d77cc15fac58a97c3ec6cad99
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jul 23 16:23:28 2019 +0800

    drm/amd/powerplay: some cosmetic fixes
    
    Drop redundant check, duplicate check, duplicate setting
    and fix the return value.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 37eb334de6bd..d8bb18445086 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1444,6 +1444,7 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 
 	if (!smu->pm_enabled)
 		return -EINVAL;
+
 	if (!skip_display_settings) {
 		ret = smu_display_config_changed(smu);
 		if (ret) {
@@ -1452,8 +1453,6 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 		}
 	}
 
-	if (!smu->pm_enabled)
-		return -EINVAL;
 	ret = smu_apply_clocks_adjust_rules(smu);
 	if (ret) {
 		pr_err("Failed to apply clocks adjust rules!");
@@ -1472,9 +1471,14 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 		ret = smu_asic_set_performance_level(smu, level);
 		if (ret) {
 			ret = smu_default_set_performance_level(smu, level);
+			if (ret) {
+				pr_err("Failed to set performance level!");
+				return ret;
+			}
 		}
-		if (!ret)
-			smu_dpm_ctx->dpm_level = level;
+
+		/* update the saved copy */
+		smu_dpm_ctx->dpm_level = level;
 	}
 
 	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
@@ -1533,28 +1537,18 @@ enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
 
 int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)
 {
-	int ret = 0;
-	int i;
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	int ret = 0;
 
 	if (!smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
-	for (i = 0; i < smu->adev->num_ip_blocks; i++) {
-		if (smu->adev->ip_blocks[i].version->type == AMD_IP_BLOCK_TYPE_SMC)
-			break;
-	}
-
-
-	smu->adev->ip_blocks[i].version->funcs->enable_umd_pstate(smu, &level);
-	ret = smu_handle_task(smu, level,
-			      AMD_PP_TASK_READJUST_POWER_STATE);
+	ret = smu_enable_umd_pstate(smu, &level);
 	if (ret)
 		return ret;
 
-	mutex_lock(&smu->mutex);
-	smu_dpm_ctx->dpm_level = level;
-	mutex_unlock(&smu->mutex);
+	ret = smu_handle_task(smu, level,
+			      AMD_PP_TASK_READJUST_POWER_STATE);
 
 	return ret;
 }

commit d3a593e97ecdff6bbebfd8b83079ffc5a332dccf
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jul 23 14:27:20 2019 +0800

    drm/amd/powerplay: no pptable transfer and dpms enabled with "dpm=0"
    
    Honor the 'dpm' module parameter setting on SW SMU routine as what
    we did on previous ASICs. SMU FW loading is still proceeded even
    with "dpm=0".
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0b1285ddc954..37eb334de6bd 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1083,6 +1083,9 @@ static int smu_hw_init(void *handle)
 		}
 	}
 
+	if (!smu->pm_enabled)
+		return 0;
+
 	ret = smu_feature_init_dpm(smu);
 	if (ret)
 		goto failed;

commit b629167d686787507f35a8bfb46b8b12f4f26eb7
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 19 16:06:29 2019 +0800

    drm/amd/powerplay: remove redundancy debug log in smu
    
    remove redundacy debug log in smu.
    eg:
    [ 6897.969447] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6897.969448] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6897.969448] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6899.024114] amdgpu: [powerplay] Unsupported SMU message: 38
    [ 6899.024151] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6899.024151] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6899.024152] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6900.078296] amdgpu: [powerplay] Unsupported SMU message: 38
    [ 6900.078332] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6900.078332] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6900.078333] amdgpu: [powerplay] smu 11 clk dpm feature 1 is not enabled
    [ 6901.133230] amdgpu: [powerplay] Unsupported SMU message: 38
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d3cc90eb160c..0b1285ddc954 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -262,7 +262,6 @@ bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type)
 	}
 
 	if(!smu_feature_is_enabled(smu, feature_id)) {
-		pr_warn("smu %d clk dpm feature %d is not enabled\n", clk_type, feature_id);
 		return false;
 	}
 

commit ebf8fc31cbcedc9d6a81642082661c82eae284fb
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 19 11:39:21 2019 +0800

    drm/amd/powerplay: custom peak clock freq for navi10
    
    v2:
    add function smu_default_set_performance_level as default dpm level handler.
    change function name smu_set_performance_level to smu_asic_set_performance_level
    
    v1:
    1.NAVI10_PEAK_SCLK_XTX    1830 Mhz
    2.NAVI10_PEAK_SCLK_XT     1755 Mhz
    3.NAVI10_PEAK_SCLK_XL     1625 Mhz
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Jack Gui <Jack.Gui@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b6b6c10eeb6e..d3cc90eb160c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1394,13 +1394,49 @@ static int smu_enable_umd_pstate(void *handle,
 	return 0;
 }
 
+static int smu_default_set_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)
+{
+	int ret = 0;
+	uint32_t sclk_mask, mclk_mask, soc_mask;
+
+	switch (level) {
+	case AMD_DPM_FORCED_LEVEL_HIGH:
+		ret = smu_force_dpm_limit_value(smu, true);
+		break;
+	case AMD_DPM_FORCED_LEVEL_LOW:
+		ret = smu_force_dpm_limit_value(smu, false);
+		break;
+	case AMD_DPM_FORCED_LEVEL_AUTO:
+	case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
+		ret = smu_unforce_dpm_levels(smu);
+		break;
+	case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
+	case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
+	case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:
+		ret = smu_get_profiling_clk_mask(smu, level,
+						 &sclk_mask,
+						 &mclk_mask,
+						 &soc_mask);
+		if (ret)
+			return ret;
+		smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask);
+		smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask);
+		smu_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask);
+		break;
+	case AMD_DPM_FORCED_LEVEL_MANUAL:
+	case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
+	default:
+		break;
+	}
+	return ret;
+}
+
 int smu_adjust_power_state_dynamic(struct smu_context *smu,
 				   enum amd_dpm_forced_level level,
 				   bool skip_display_settings)
 {
 	int ret = 0;
 	int index = 0;
-	uint32_t sclk_mask, mclk_mask, soc_mask;
 	long workload;
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 
@@ -1431,39 +1467,10 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 	}
 
 	if (smu_dpm_ctx->dpm_level != level) {
-		switch (level) {
-		case AMD_DPM_FORCED_LEVEL_HIGH:
-			ret = smu_force_dpm_limit_value(smu, true);
-			break;
-		case AMD_DPM_FORCED_LEVEL_LOW:
-			ret = smu_force_dpm_limit_value(smu, false);
-			break;
-
-		case AMD_DPM_FORCED_LEVEL_AUTO:
-		case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
-			ret = smu_unforce_dpm_levels(smu);
-			break;
-
-		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
-		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
-		case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:
-			ret = smu_get_profiling_clk_mask(smu, level,
-							 &sclk_mask,
-							 &mclk_mask,
-							 &soc_mask);
-			if (ret)
-				return ret;
-			smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask);
-			smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask);
-			smu_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask);
-			break;
-
-		case AMD_DPM_FORCED_LEVEL_MANUAL:
-		case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
-		default:
-			break;
+		ret = smu_asic_set_performance_level(smu, level);
+		if (ret) {
+			ret = smu_default_set_performance_level(smu, level);
 		}
-
 		if (!ret)
 			smu_dpm_ctx->dpm_level = level;
 	}

commit 3a48c10d7fb055ff655096eb50e96f36b22b8021
Author: Evan Quan <evan.quan@amd.com>
Date:   Wed Jul 17 16:32:27 2019 +0800

    drm/amd/powerplay: report bootup clock as max supported on dpm disabled
    
    With gfxclk or uclk dpm disabled, it's reasonable to report bootup clock
    as the max supported.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ec1904e47927..b6b6c10eeb6e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -137,12 +137,37 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 {
 	int ret = 0, clk_id = 0;
 	uint32_t param = 0;
+	uint32_t clock_limit;
 
 	if (!min && !max)
 		return -EINVAL;
 
-	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+	if (!smu_clk_dpm_is_enabled(smu, clk_type)) {
+		switch (clk_type) {
+		case SMU_MCLK:
+		case SMU_UCLK:
+			clock_limit = smu->smu_table.boot_values.uclk;
+			break;
+		case SMU_GFXCLK:
+		case SMU_SCLK:
+			clock_limit = smu->smu_table.boot_values.gfxclk;
+			break;
+		case SMU_SOCCLK:
+			clock_limit = smu->smu_table.boot_values.socclk;
+			break;
+		default:
+			clock_limit = 0;
+			break;
+		}
+
+		/* clock in Mhz unit */
+		if (min)
+			*min = clock_limit / 100;
+		if (max)
+			*max = clock_limit / 100;
+
 		return 0;
+	}
 
 	mutex_lock(&smu->mutex);
 	clk_id = smu_clk_get_index(smu, clk_type);

commit c06403045aad6ae2edd935f6309e0c72e118c6de
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Jul 11 14:36:44 2019 +0800

    drm/amd/powerplay: input check for unsupported message/clock index
    
    This can avoid them to be handled in a wrong way without notice.
    Since not all SMU messages/clocks are supported on every SMU11 ASIC.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c8048b865161..ec1904e47927 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -331,7 +331,7 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int
 	int ret = 0;
 	int table_id = smu_table_get_index(smu, table_index);
 
-	if (!table_data || table_id >= smu_table->table_count)
+	if (!table_data || table_id >= smu_table->table_count || table_id < 0)
 		return -EINVAL;
 
 	table = &smu_table->tables[table_index];
@@ -462,10 +462,12 @@ int smu_feature_init_dpm(struct smu_context *smu)
 int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
 	struct smu_feature *feature = &smu->smu_feature;
-	uint32_t feature_id;
+	int feature_id;
 	int ret = 0;
 
 	feature_id = smu_feature_get_index(smu, mask);
+	if (feature_id < 0)
+		return 0;
 
 	WARN_ON(feature_id > feature->feature_num);
 
@@ -480,10 +482,12 @@ int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
 			    bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
-	uint32_t feature_id;
+	int feature_id;
 	int ret = 0;
 
 	feature_id = smu_feature_get_index(smu, mask);
+	if (feature_id < 0)
+		return -EINVAL;
 
 	WARN_ON(feature_id > feature->feature_num);
 
@@ -506,10 +510,12 @@ int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
 int smu_feature_is_supported(struct smu_context *smu, enum smu_feature_mask mask)
 {
 	struct smu_feature *feature = &smu->smu_feature;
-	uint32_t feature_id;
+	int feature_id;
 	int ret = 0;
 
 	feature_id = smu_feature_get_index(smu, mask);
+	if (feature_id < 0)
+		return 0;
 
 	WARN_ON(feature_id > feature->feature_num);
 
@@ -525,10 +531,12 @@ int smu_feature_set_supported(struct smu_context *smu,
 			      bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
-	uint32_t feature_id;
+	int feature_id;
 	int ret = 0;
 
 	feature_id = smu_feature_get_index(smu, mask);
+	if (feature_id < 0)
+		return -EINVAL;
 
 	WARN_ON(feature_id > feature->feature_num);
 

commit 54bd77f3d08d4d044b13041286817d9205ecf688
Author: Yong Zhao <Yong.Zhao@amd.com>
Date:   Fri Jun 28 05:45:39 2019 -0400

    amd/powerplay: No SW XGMI dpm for Arcturus rev 2
    
    xgmi dpm is handled by the SMU.
    
    Signed-off-by: Yong Zhao <Yong.Zhao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d977d68320c9..c8048b865161 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -370,6 +370,17 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 		return false;
 }
 
+bool is_support_sw_smu_xgmi(struct amdgpu_device *adev)
+{
+	if (amdgpu_dpm != 1)
+		return false;
+
+	if (adev->asic_type == CHIP_VEGA20)
+		return true;
+
+	return false;
+}
+
 int smu_sys_get_pp_table(struct smu_context *smu, void **table)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;

commit ba02636de54e7c2f8d549401ce9c9f508a05ef7a
Author: Jack Xiao <Jack.Xiao@amd.com>
Date:   Fri Jul 5 16:00:08 2019 -0500

    drm/amdgpu: enable gfxoff code path for navi14
    
    Based on navi10 gfxoff logic, enable the related code
    path for navi14.
    
    Signed-off-by: Jack Xiao <Jack.Xiao@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 1ac9db3aa5bc..d977d68320c9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -559,9 +559,6 @@ static int smu_early_init(void *handle)
 	smu->pm_enabled = !!amdgpu_dpm;
 	mutex_init(&smu->mutex);
 
-	if (adev->asic_type == CHIP_NAVI14)
-		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
-
 	return smu_set_funcs(adev);
 }
 

commit e017bb8035ce890ff5a4cded2e8b91b814fb7b21
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Mon May 13 17:02:12 2019 +0800

    drm/amd/powerplay: disable gfxoff for navi14
    
    gfxoff doesn't work on navi14 yet, so disable it for now
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Jack Xiao <Jack.Xiao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d977d68320c9..1ac9db3aa5bc 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -559,6 +559,9 @@ static int smu_early_init(void *handle)
 	smu->pm_enabled = !!amdgpu_dpm;
 	mutex_init(&smu->mutex);
 
+	if (adev->asic_type == CHIP_NAVI14)
+		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
+
 	return smu_set_funcs(adev);
 }
 

commit b02ff126898939a685c9a066b5d80dde3ff1c66f
Author: Xiaojie Yuan <xiaojie.yuan@amd.com>
Date:   Wed Feb 13 03:44:10 2019 +0800

    drm/amdgpu/smu11: add support for navi14
    
    Same as navi10.
    
    Signed-off-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f1565c448de5..d977d68320c9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -538,6 +538,7 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
 	case CHIP_NAVI10:
+	case CHIP_NAVI14:
 		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
 			smu->od_enabled = true;
 		smu_v11_0_set_smu_funcs(smu);

commit 0d9d78b57bf32fdc4baf6eb8853e65059dcd5e06
Author: Evan Quan <evan.quan@amd.com>
Date:   Thu Jul 11 15:13:17 2019 +0800

    drm/amd/powerplay: correct smu_update_table usage
    
    The interface was used in a confusing way. In profile mode scenario,
    the 2nd parameter of the interface was used in a different way from
    other scenarios.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 20257c036a65..f1565c448de5 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -323,7 +323,7 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 	return ret;
 }
 
-int smu_update_table(struct smu_context *smu, enum smu_table_id table_index,
+int smu_update_table(struct smu_context *smu, enum smu_table_id table_index, int argument,
 		     void *table_data, bool drv2smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
@@ -350,7 +350,7 @@ int smu_update_table(struct smu_context *smu, enum smu_table_id table_index,
 	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
 					  SMU_MSG_TransferTableDram2Smu :
 					  SMU_MSG_TransferTableSmu2Dram,
-					  table_id);
+					  table_id | ((argument & 0xFFFF) << 16));
 	if (ret)
 		return ret;
 

commit 54728170e00cecfac0394c6ee7ea4043778a512b
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 12 15:22:40 2019 +0800

    drm/amd/powerplay: add helper of smu_clk_dpm_is_enabled for smu
    
    v2: change function name to smu_clk_dpm_is_enabled.
    add this helper function to check dpm clk feature is enabled.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 8150cb81009f..20257c036a65 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -69,6 +69,9 @@ int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (min <= 0 && max <= 0)
 		return -EINVAL;
 
+	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+		return 0;
+
 	clk_id = smu_clk_get_index(smu, clk_type);
 	if (clk_id < 0)
 		return clk_id;
@@ -102,6 +105,9 @@ int smu_set_hard_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (min <= 0 && max <= 0)
 		return -EINVAL;
 
+	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+		return 0;
+
 	clk_id = smu_clk_get_index(smu, clk_type);
 	if (clk_id < 0)
 		return clk_id;
@@ -135,29 +141,8 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (!min && !max)
 		return -EINVAL;
 
-	switch (clk_type) {
-	case SMU_MCLK:
-	case SMU_UCLK:
-		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
-			pr_warn("uclk dpm is not enabled\n");
-			return 0;
-		}
-		break;
-	case SMU_GFXCLK:
-	case SMU_SCLK:
-		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {
-			pr_warn("gfxclk dpm is not enabled\n");
-			return 0;
-		}
-	case SMU_SOCCLK:
-		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
-			pr_warn("sockclk dpm is not enabled\n");
-			return 0;
-		}
-		break;
-	default:
-		break;
-	}
+	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+		return 0;
 
 	mutex_lock(&smu->mutex);
 	clk_id = smu_clk_get_index(smu, clk_type);
@@ -200,6 +185,9 @@ int smu_get_dpm_freq_by_index(struct smu_context *smu, enum smu_clk_type clk_typ
 	if (!value)
 		return -EINVAL;
 
+	if (!smu_clk_dpm_is_enabled(smu, clk_type))
+		return 0;
+
 	clk_id = smu_clk_get_index(smu, clk_type);
 	if (clk_id < 0)
 		return clk_id;
@@ -228,6 +216,35 @@ int smu_get_dpm_level_count(struct smu_context *smu, enum smu_clk_type clk_type,
 	return smu_get_dpm_freq_by_index(smu, clk_type, 0xff, value);
 }
 
+bool smu_clk_dpm_is_enabled(struct smu_context *smu, enum smu_clk_type clk_type)
+{
+	enum smu_feature_mask feature_id = 0;
+
+	switch (clk_type) {
+	case SMU_MCLK:
+	case SMU_UCLK:
+		feature_id = SMU_FEATURE_DPM_UCLK_BIT;
+		break;
+	case SMU_GFXCLK:
+	case SMU_SCLK:
+		feature_id = SMU_FEATURE_DPM_GFXCLK_BIT;
+		break;
+	case SMU_SOCCLK:
+		feature_id = SMU_FEATURE_DPM_SOCCLK_BIT;
+		break;
+	default:
+		return true;
+	}
+
+	if(!smu_feature_is_enabled(smu, feature_id)) {
+		pr_warn("smu %d clk dpm feature %d is not enabled\n", clk_type, feature_id);
+		return false;
+	}
+
+	return true;
+}
+
+
 int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 			   bool gate)
 {

commit 8e33376b7649b353ffd55f2b40fe129ead3880f7
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 12 17:05:52 2019 +0800

    drm/amd/powerplay: fix save dpm level error for smu
    
    the save dpm level should be save previous dpm profile level,
    should not modified by get dpm level function.
    eg: default auto
    1. auto -> standard ==> dpm_level = standard, save_dpm = auto.
    2. standard -> auto ==> dpm_level = auto, save_dpm = standard.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e6f103988c6a..8150cb81009f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1448,17 +1448,16 @@ int smu_handle_task(struct smu_context *smu,
 enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
 {
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	enum amd_dpm_forced_level level;
 
 	if (!smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
 	mutex_lock(&(smu->mutex));
-	if (smu_dpm_ctx->dpm_level != smu_dpm_ctx->saved_dpm_level) {
-		smu_dpm_ctx->saved_dpm_level = smu_dpm_ctx->dpm_level;
-	}
+	level = smu_dpm_ctx->dpm_level;
 	mutex_unlock(&(smu->mutex));
 
-	return smu_dpm_ctx->dpm_level;
+	return level;
 }
 
 int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)

commit 75728f512e1f6cc37da9c173b7a7690b10b1c3f5
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 12 14:42:12 2019 +0800

    drm/amd/powerplay: add standard profile dpm support for smu
    
    1. the standard dpm is not support before.
    2. use auto profile to adapt standard profile.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 5f844357e6ac..e6f103988c6a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1378,10 +1378,10 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 			break;
 
 		case AMD_DPM_FORCED_LEVEL_AUTO:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
 			ret = smu_unforce_dpm_levels(smu);
 			break;
 
-		case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
 		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
 		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
 		case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:

commit eaf963b5c17e611ca35850f65db7ebe929bef774
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 12 14:40:12 2019 +0800

    drm/amd/powerplay: add socclk profile dpm support.
    
    1.miss socclk profile support when bringup.
    2.add feature check for socclk.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 04132653e289..5f844357e6ac 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -149,6 +149,11 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			pr_warn("gfxclk dpm is not enabled\n");
 			return 0;
 		}
+	case SMU_SOCCLK:
+		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {
+			pr_warn("sockclk dpm is not enabled\n");
+			return 0;
+		}
 		break;
 	default:
 		break;
@@ -1388,6 +1393,7 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 				return ret;
 			smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask);
 			smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask);
+			smu_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask);
 			break;
 
 		case AMD_DPM_FORCED_LEVEL_MANUAL:

commit 64974ab24908a92b5dfe52e1ace3d67c47d657cb
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 12 11:27:50 2019 +0800

    drm/amd/powerplay: add pstate mclk(uclk) support for navi10
    
    add pstate mclk(uclk) support.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c382eb901178..04132653e289 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -136,6 +136,7 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 		return -EINVAL;
 
 	switch (clk_type) {
+	case SMU_MCLK:
 	case SMU_UCLK:
 		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
 			pr_warn("uclk dpm is not enabled\n");

commit d36893362d22ff46fdb105ebab12df00bbf23397
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Jul 11 21:33:17 2019 +0800

    drm/amd/powerplay: fix smu clock type change miss error
    
    in the smu module, use the smu_xxxclk type to identify the CLK type
    use SMU_SCLK, SMU_MCLK to replace PP_SCLK, PP_MCLK.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3093917adc2d..c382eb901178 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1385,8 +1385,8 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 							 &soc_mask);
 			if (ret)
 				return ret;
-			smu_force_clk_levels(smu, PP_SCLK, 1 << sclk_mask);
-			smu_force_clk_levels(smu, PP_MCLK, 1 << mclk_mask);
+			smu_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask);
+			smu_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask);
 			break;
 
 		case AMD_DPM_FORCED_LEVEL_MANUAL:

commit 767acabdac81ded97e8f6930bc2dabff8db1638c
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jul 5 15:58:46 2019 -0500

    drm/amd/powerplay: add baco smu reset function for smu11
    
    add baco reset support for smu11.
    it can help gpu do asic reset when gpu recovery.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 31152d495f69..3093917adc2d 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -634,6 +634,11 @@ static int smu_sw_init(void *handle)
 	bitmap_zero(smu->smu_feature.supported, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.enabled, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.allowed, SMU_FEATURE_MAX);
+
+	mutex_init(&smu->smu_baco.mutex);
+	smu->smu_baco.state = SMU_BACO_STATE_EXIT;
+	smu->smu_baco.platform_support = false;
+
 	smu->watermarks_bitmap = 0;
 	smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
 	smu->default_power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
@@ -1103,11 +1108,20 @@ static int smu_suspend(void *handle)
 	int ret;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
+	bool baco_feature_is_enabled = smu_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT);
 
 	ret = smu_system_features_control(smu, false);
 	if (ret)
 		return ret;
 
+	if (adev->in_gpu_reset && baco_feature_is_enabled) {
+		ret = smu_feature_set_enabled(smu, SMU_FEATURE_BACO_BIT, true);
+		if (ret) {
+			pr_warn("set BACO feature enabled failed, return %d\n", ret);
+			return ret;
+		}
+	}
+
 	smu->watermarks_bitmap &= ~(WATERMARKS_LOADED);
 
 	if (adev->asic_type >= CHIP_NAVI10 &&

commit 309bce0ca8bd5804db27bc2d56fb1e272c1a5359
Author: Evan Quan <evan.quan@amd.com>
Date:   Tue Jun 25 23:03:00 2019 +0800

    drm/amd/powerplay: add missing smu_get_clk_info_from_vbios() call
    
    This seems a merge error.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index a0fb36360bea..31152d495f69 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -820,6 +820,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		if (ret)
 			return ret;
 
+		ret = smu_get_clk_info_from_vbios(smu);
+		if (ret)
+			return ret;
+
 		/*
 		 * check if the format_revision in vbios is up to pptable header
 		 * version, and the structure size is not 0.

commit ac1092b341148c6fce8d0fe2ce8fa6764027bd02
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri Jun 14 17:04:36 2019 +0800

    drm/amd/powerplay: check gfxclk dpm enablement before proceeding
    
    Support gfxclk dpm disablement.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Feifei Xu <Feifei.Xu@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9559127dd0ec..a0fb36360bea 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -143,6 +143,7 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 		}
 		break;
 	case SMU_GFXCLK:
+	case SMU_SCLK:
 		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {
 			pr_warn("gfxclk dpm is not enabled\n");
 			return 0;

commit 1189413f9cd45e42dc8ce3dc4eacd6ae27269ef9
Author: Prike Liang <Prike.Liang@amd.com>
Date:   Mon Jun 24 17:25:26 2019 +0800

    drm/amd/powerplay:clean up the residual mutex for smu_hw_init
    
    The mutex for procting SMU during hw_init was removed as system
    will be deadlock when smu_populate_umd_state_clk try get SMU mutex.
    Therefore need remove the residual mutex from failed path.
    
    Signed-off-by: Prike Liang <Prike.Liang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 29fb1965686a..9559127dd0ec 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1044,7 +1044,6 @@ static int smu_hw_init(void *handle)
 	return 0;
 
 failed:
-	mutex_unlock(&smu->mutex);
 	return ret;
 }
 

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 73c86d628d6aa3d7162094ef1f0503bda17b506e
Author: Hawking Zhang <Hawking.Zhang@amd.com>
Date:   Mon Jun 24 19:26:00 2019 +0800

    drm/amdgpu: fix modprobe failure for uvd_4/5/6
    
    For uvd_4/5/6, amdgpu driver will only power on them when
    there are jobs assigned to decode/enc rings.uvd_4/5/6 dpm was broken
    since amdgpu_dpm_set_powergating_by_smu only covers gfx block.
    
    The change would add more IP block support in amdgpu_dpm_set_powergating_by_smu
    For GFX/UVD/VCN/VCE, if the new SMU driver is supported, invoke new
    power gate helper function smu_dpm_set_power_gate, otherwise, fallback to
    legacy powerplay helper function pp_set_powergating_by_smu. For other IP blocks
    always invoke legacy powerplay helper function.
    
    Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Tianci Yin <tianci.yin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 8bf42f80f253..5aa0594fb53f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -233,6 +233,9 @@ int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 	case AMD_IP_BLOCK_TYPE_VCE:
 		ret = smu_dpm_set_vce_enable(smu, gate);
 		break;
+	case AMD_IP_BLOCK_TYPE_GFX:
+		ret = smu_gfx_off_control(smu, gate);
+		break;
 	default:
 		break;
 	}

commit 0c83d32c565c9f40cb686df5ad65ade8ec85a876
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Mon Jun 17 13:17:27 2019 -0500

    drm/amd/powerplay: simplified od_settings for each asic
    
    the od_settings is asic related data, so move it to asic file.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 1947abaad036..8bf42f80f253 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1058,21 +1058,9 @@ static int smu_hw_fini(void *handle)
 	kfree(table_context->max_sustainable_clocks);
 	table_context->max_sustainable_clocks = NULL;
 
-	kfree(table_context->od_feature_capabilities);
-	table_context->od_feature_capabilities = NULL;
-
-	kfree(table_context->od_settings_max);
-	table_context->od_settings_max = NULL;
-
-	kfree(table_context->od_settings_min);
-	table_context->od_settings_min = NULL;
-
 	kfree(table_context->overdrive_table);
 	table_context->overdrive_table = NULL;
 
-	kfree(table_context->od8_settings);
-	table_context->od8_settings = NULL;
-
 	kfree(smu->irq_source);
 	smu->irq_source = NULL;
 

commit 8f30a16d3ac15f61aa7a02b77191aafe44912654
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue May 21 15:37:24 2019 +0800

    drm/amd/powerplay: move od_default_setting callback to asic file
    
    the set default od_setting is asic related function,
    so move thic code to vega20_ppt file.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 8a554dc3243c..1947abaad036 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -901,7 +901,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 			return ret;
 	}
 
-	ret = smu_set_od8_default_settings(smu, initialize);
+	ret = smu_set_default_od_settings(smu, initialize);
 	if (ret)
 		return ret;
 

commit 6f6a7bba696118ea440116f7c09dc93e18d8e78b
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Wed May 15 15:59:38 2019 +0800

    drm/amd/powerplay: fix deadlock issue for smu_force_performance_level
    
    the smu->mutex is internal lock resource in sw-smu, some functions will use
    it at the same time, so it maybe will cause deadlock issue.
    this patch fix this issue in smu_force_performance_level function.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 41e9a7ed8680..8a554dc3243c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1459,12 +1459,15 @@ int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_lev
 			break;
 	}
 
-	mutex_lock(&smu->mutex);
 
 	smu->adev->ip_blocks[i].version->funcs->enable_umd_pstate(smu, &level);
 	ret = smu_handle_task(smu, level,
 			      AMD_PP_TASK_READJUST_POWER_STATE);
+	if (ret)
+		return ret;
 
+	mutex_lock(&smu->mutex);
+	smu_dpm_ctx->dpm_level = level;
 	mutex_unlock(&smu->mutex);
 
 	return ret;

commit 2e13c7551ca03dac449c0d55a08a0459d876ea11
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Wed May 29 23:30:32 2019 -0500

    drm/amd/powerplay: notify smu with active display count
    
    when dc update clocks via smu, smu needs to know how many
    displays active. this interface is for dc notify number
    of active displays to smu.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4d7aeee91bc8..41e9a7ed8680 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -802,7 +802,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		return 0;
 	}
 
-	ret = smu_init_display(smu);
+	ret = smu_init_display_count(smu, 0);
 	if (ret)
 		return ret;
 
@@ -1470,6 +1470,17 @@ int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_lev
 	return ret;
 }
 
+int smu_set_display_count(struct smu_context *smu, uint32_t count)
+{
+	int ret = 0;
+
+	mutex_lock(&smu->mutex);
+	ret = smu_init_display_count(smu, count);
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit 576851345b677b28617217f5d97920f62eab471e
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Jun 4 17:38:42 2019 +0800

    drm/amd/powerplay: remove smu callback funciton get_mclk(get_sclk)
    
    remove smu callback: get_mclk, get_sclk.
    because the function smu_get_dpm_freq_range has the same function.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3cb71668e523..4d7aeee91bc8 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -135,30 +135,52 @@ int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	if (!min && !max)
 		return -EINVAL;
 
+	switch (clk_type) {
+	case SMU_UCLK:
+		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {
+			pr_warn("uclk dpm is not enabled\n");
+			return 0;
+		}
+		break;
+	case SMU_GFXCLK:
+		if (!smu_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {
+			pr_warn("gfxclk dpm is not enabled\n");
+			return 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	mutex_lock(&smu->mutex);
 	clk_id = smu_clk_get_index(smu, clk_type);
-	if (clk_id < 0)
-		return clk_id;
+	if (clk_id < 0) {
+		ret = -EINVAL;
+		goto failed;
+	}
 
 	param = (clk_id & 0xffff) << 16;
 
 	if (max) {
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetMaxDpmFreq, param);
 		if (ret)
-			return ret;
+			goto failed;
 		ret = smu_read_smc_arg(smu, max);
 		if (ret)
-			return ret;
+			goto failed;
 	}
 
 	if (min) {
 		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetMinDpmFreq, param);
 		if (ret)
-			return ret;
+			goto failed;
 		ret = smu_read_smc_arg(smu, min);
 		if (ret)
-			return ret;
+			goto failed;
 	}
 
+failed:
+	mutex_unlock(&smu->mutex);
 	return ret;
 }
 

commit e9c12a8e27aa211b057e5cb442ce96c02d9fde78
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Jun 4 17:41:48 2019 +0800

    drm/amd/powerplay: remove smu mutex lock in smu_hw_init
    
    the smu mutex lock is unnecessary in smu hw init.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 1d0523831a15..3cb71668e523 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -981,8 +981,6 @@ static int smu_hw_init(void *handle)
 		}
 	}
 
-	mutex_lock(&smu->mutex);
-
 	ret = smu_feature_init_dpm(smu);
 	if (ret)
 		goto failed;
@@ -1011,8 +1009,6 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
-	mutex_unlock(&smu->mutex);
-
 	if (!smu->pm_enabled)
 		adev->pm.dpm_enabled = false;
 	else

commit 5e6d266573db27f97de56f457138730a6ac48413
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu May 30 18:00:22 2019 +0800

    drm/amd/powerplay: add thermal ctf support for navi10
    
    add sw-CTF support for navi10
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 7d1d91975705..1d0523831a15 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1007,6 +1007,10 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
+	ret = smu_register_irq_handler(smu);
+	if (ret)
+		goto failed;
+
 	mutex_unlock(&smu->mutex);
 
 	if (!smu->pm_enabled)
@@ -1051,6 +1055,9 @@ static int smu_hw_fini(void *handle)
 	kfree(table_context->od8_settings);
 	table_context->od8_settings = NULL;
 
+	kfree(smu->irq_source);
+	smu->irq_source = NULL;
+
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)
 		return ret;

commit a38470f0f8dcd639262d7e2eeaa26b8e0947d811
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Wed May 15 12:59:58 2019 +0800

    drm/amd/powerplay: move power_dpm_force_performance_level to amdgpu_smu file
    
    because this callback is not asic related function, so move it to top
    code level to support more asic (eg: navi10)
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 6a6f36006f80..7d1d91975705 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1404,6 +1404,47 @@ int smu_handle_task(struct smu_context *smu,
 	return ret;
 }
 
+enum amd_dpm_forced_level smu_get_performance_level(struct smu_context *smu)
+{
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+
+	if (!smu_dpm_ctx->dpm_context)
+		return -EINVAL;
+
+	mutex_lock(&(smu->mutex));
+	if (smu_dpm_ctx->dpm_level != smu_dpm_ctx->saved_dpm_level) {
+		smu_dpm_ctx->saved_dpm_level = smu_dpm_ctx->dpm_level;
+	}
+	mutex_unlock(&(smu->mutex));
+
+	return smu_dpm_ctx->dpm_level;
+}
+
+int smu_force_performance_level(struct smu_context *smu, enum amd_dpm_forced_level level)
+{
+	int ret = 0;
+	int i;
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+
+	if (!smu_dpm_ctx->dpm_context)
+		return -EINVAL;
+
+	for (i = 0; i < smu->adev->num_ip_blocks; i++) {
+		if (smu->adev->ip_blocks[i].version->type == AMD_IP_BLOCK_TYPE_SMC)
+			break;
+	}
+
+	mutex_lock(&smu->mutex);
+
+	smu->adev->ip_blocks[i].version->funcs->enable_umd_pstate(smu, &level);
+	ret = smu_handle_task(smu, level,
+			      AMD_PP_TASK_READJUST_POWER_STATE);
+
+	mutex_unlock(&smu->mutex);
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit 6b1b7b5bf03db9fb2cac485eee5289edf2bc5b61
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Apr 23 11:20:46 2019 +0800

    drm/amd/powerplay: move read sensor of UVD[VCE]_POWER to amdgpu_smu file
    
    This part of code is asic unrelated and moves to top code level.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 6183b8f6d6c1..6a6f36006f80 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -255,6 +255,14 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 		ret = smu_feature_get_enabled_mask(smu, (uint32_t *)data, 2);
 		*size = 8;
 		break;
+	case AMDGPU_PP_SENSOR_UVD_POWER:
+		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_UVD_BIT) ? 1 : 0;
+		*size = 4;
+		break;
+	case AMDGPU_PP_SENSOR_VCE_POWER:
+		*(uint32_t *)data = smu_feature_is_enabled(smu, SMU_FEATURE_DPM_VCE_BIT) ? 1 : 0;
+		*size = 4;
+		break;
 	default:
 		ret = -EINVAL;
 		break;

commit 3366561767209326d3a6d4d2c727788beca7fcea
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Mon Apr 22 14:40:30 2019 +0800

    drm/amd/powerplay: add helper function of smu_set_hard_freq_range
    
    add this function to get dpm clock information.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index dd06d23bb188..6183b8f6d6c1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -93,6 +93,39 @@ int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 	return ret;
 }
 
+int smu_set_hard_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
+			    uint32_t min, uint32_t max)
+{
+	int ret = 0, clk_id = 0;
+	uint32_t param;
+
+	if (min <= 0 && max <= 0)
+		return -EINVAL;
+
+	clk_id = smu_clk_get_index(smu, clk_type);
+	if (clk_id < 0)
+		return clk_id;
+
+	if (max > 0) {
+		param = (uint32_t)((clk_id << 16) | (max & 0xffff));
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetHardMaxByFreq,
+						  param);
+		if (ret)
+			return ret;
+	}
+
+	if (min > 0) {
+		param = (uint32_t)((clk_id << 16) | (min & 0xffff));
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinByFreq,
+						  param);
+		if (ret)
+			return ret;
+	}
+
+
+	return ret;
+}
+
 int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			   uint32_t *min, uint32_t *max)
 {

commit 0d7cbd280796f709b134d763295c2d4276392594
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Apr 19 10:19:28 2019 +0800

    drm/amd/powerplay: add helper function of smu_set_soft_freq_range
    
    add this helper function to get dpm clk information.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ec84921332ac..dd06d23bb188 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -60,6 +60,39 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 	return ret;
 }
 
+int smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
+			    uint32_t min, uint32_t max)
+{
+	int ret = 0, clk_id = 0;
+	uint32_t param;
+
+	if (min <= 0 && max <= 0)
+		return -EINVAL;
+
+	clk_id = smu_clk_get_index(smu, clk_type);
+	if (clk_id < 0)
+		return clk_id;
+
+	if (max > 0) {
+		param = (uint32_t)((clk_id << 16) | (max & 0xffff));
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxByFreq,
+						  param);
+		if (ret)
+			return ret;
+	}
+
+	if (min > 0) {
+		param = (uint32_t)((clk_id << 16) | (min & 0xffff));
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinByFreq,
+						  param);
+		if (ret)
+			return ret;
+	}
+
+
+	return ret;
+}
+
 int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
 			   uint32_t *min, uint32_t *max)
 {

commit 8b3d243e47ddd4a570150651e028ecd1c30287bc
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Apr 18 18:46:04 2019 +0800

    drm/amd/powerplay: add helper function of smu_get_dpm_freq_range
    
    add this helper function to get dpm clk information (min, max);
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b2731a631c2b..ec84921332ac 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -60,6 +60,42 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 	return ret;
 }
 
+int smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,
+			   uint32_t *min, uint32_t *max)
+{
+	int ret = 0, clk_id = 0;
+	uint32_t param = 0;
+
+	if (!min && !max)
+		return -EINVAL;
+
+	clk_id = smu_clk_get_index(smu, clk_type);
+	if (clk_id < 0)
+		return clk_id;
+
+	param = (clk_id & 0xffff) << 16;
+
+	if (max) {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetMaxDpmFreq, param);
+		if (ret)
+			return ret;
+		ret = smu_read_smc_arg(smu, max);
+		if (ret)
+			return ret;
+	}
+
+	if (min) {
+		ret = smu_send_smc_msg_with_param(smu, SMU_MSG_GetMinDpmFreq, param);
+		if (ret)
+			return ret;
+		ret = smu_read_smc_arg(smu, min);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
 int smu_get_dpm_freq_by_index(struct smu_context *smu, enum smu_clk_type clk_type,
 			      uint16_t level, uint32_t *value)
 {

commit 3ac54a50438053b1f4d3480c608eda50ae25775c
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Wed Mar 27 14:46:20 2019 +0800

    drm/amd/powerplay: add helper function to get dpm freq informations
    
    this function can help driver to get ppclk informations
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 30dae7ca19c4..b2731a631c2b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -60,6 +60,43 @@ int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t
 	return ret;
 }
 
+int smu_get_dpm_freq_by_index(struct smu_context *smu, enum smu_clk_type clk_type,
+			      uint16_t level, uint32_t *value)
+{
+	int ret = 0, clk_id = 0;
+	uint32_t param;
+
+	if (!value)
+		return -EINVAL;
+
+	clk_id = smu_clk_get_index(smu, clk_type);
+	if (clk_id < 0)
+		return clk_id;
+
+	param = (uint32_t)(((clk_id & 0xffff) << 16) | (level & 0xffff));
+
+	ret = smu_send_smc_msg_with_param(smu,SMU_MSG_GetDpmFreqByIndex,
+					  param);
+	if (ret)
+		return ret;
+
+	ret = smu_read_smc_arg(smu, &param);
+	if (ret)
+		return ret;
+
+	/* BIT31:  0 - Fine grained DPM, 1 - Dicrete DPM
+	 * now, we un-support it */
+	*value = param & 0x7fffffff;
+
+	return ret;
+}
+
+int smu_get_dpm_level_count(struct smu_context *smu, enum smu_clk_type clk_type,
+			    uint32_t *value)
+{
+	return smu_get_dpm_freq_by_index(smu, clk_type, 0xff, value);
+}
+
 int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 			   bool gate)
 {

commit e17a512a18c1f1dece8c3d4f9685c581052d3191
Author: Jack Xiao <Jack.Xiao@amd.com>
Date:   Mon May 6 16:35:41 2019 +0800

    drm/amdgpu: RLC must be disabled after SMU when S3 on navi
    
    SMU requires to interact with RLC when disable all features,
    so RLC shouldn't be disabled ahead of SMU.
    
    Signed-off-by: Jack Xiao <Jack.Xiao@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9e0b439b41ca..30dae7ca19c4 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -943,6 +943,10 @@ static int smu_suspend(void *handle)
 
 	smu->watermarks_bitmap &= ~(WATERMARKS_LOADED);
 
+	if (adev->asic_type >= CHIP_NAVI10 &&
+	    adev->gfx.rlc.funcs->stop)
+		adev->gfx.rlc.funcs->stop(adev);
+
 	return 0;
 }
 

commit 948f540cd0120ef9d622af42c1b95f28cf992da0
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed May 29 23:18:01 2019 -0500

    drm/amd/powerplay: set dpm_enabled flag but don't enable vcn dpm
    
    This patch sets dpm_enabled flag but don't enable vcn dpm, because vcn dpm
    doesn't work so far and we needs to enable the sysfs interfaces.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 71f93f9a1368..9e0b439b41ca 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -865,10 +865,7 @@ static int smu_hw_init(void *handle)
 	if (!smu->pm_enabled)
 		adev->pm.dpm_enabled = false;
 	else
-		adev->pm.dpm_enabled = true;
-	/* TODO: will set dpm_enabled flag while VCN and DAL DPM is workable */
-	if (adev->asic_type != CHIP_NAVI10)
-		adev->pm.dpm_enabled = true;
+		adev->pm.dpm_enabled = true;	/* TODO: will set dpm_enabled flag while VCN and DAL DPM is workable */
 
 	pr_info("SMU is initialized successfully!\n");
 

commit 8d7315cef98bfd1f53b69aafde83bc9834b11904
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed May 29 23:15:54 2019 -0500

    drm/amd/powerplay: do not set dpm_enabled flag before VCN/DCN DPM is workable
    
    This dpm_enabled flag will be recognized as the VCN DPM enabled as well. In fact
    VCN/DCN DPM on Navi10 is not good so far, so we cannot enable it for now.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fd628fc3c255..71f93f9a1368 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -866,6 +866,9 @@ static int smu_hw_init(void *handle)
 		adev->pm.dpm_enabled = false;
 	else
 		adev->pm.dpm_enabled = true;
+	/* TODO: will set dpm_enabled flag while VCN and DAL DPM is workable */
+	if (adev->asic_type != CHIP_NAVI10)
+		adev->pm.dpm_enabled = true;
 
 	pr_info("SMU is initialized successfully!\n");
 

commit 33bd73ae6c615754cffb94336abbbd8bb841eb34
Author: Huang Rui <ray.huang@amd.com>
Date:   Sun Mar 31 12:02:00 2019 +0800

    drm/amd/powerplay: modify smu_update_table to use SMU_TABLE_xxx as the input
    
    Table id may be different for each asic, so it's good to use this as the input
    for common interface.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fedd5ff694f2..fd628fc3c255 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -127,18 +127,18 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 	return ret;
 }
 
-int smu_update_table(struct smu_context *smu, uint32_t table_index,
+int smu_update_table(struct smu_context *smu, enum smu_table_id table_index,
 		     void *table_data, bool drv2smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *table = NULL;
 	int ret = 0;
-	int table_id = table_index & 0xffff;
+	int table_id = smu_table_get_index(smu, table_index);
 
 	if (!table_data || table_id >= smu_table->table_count)
 		return -EINVAL;
 
-	table = &smu_table->tables[table_id];
+	table = &smu_table->tables[table_index];
 
 	if (drv2smu)
 		memcpy(table->cpu_addr, table_data, table->size);
@@ -154,7 +154,7 @@ int smu_update_table(struct smu_context *smu, uint32_t table_index,
 	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
 					  SMU_MSG_TransferTableDram2Smu :
 					  SMU_MSG_TransferTableSmu2Dram,
-					  table_index);
+					  table_id);
 	if (ret)
 		return ret;
 

commit 8b2ae145de4cd263b96c67d5ba936cd0c896b0c2
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Apr 22 14:06:42 2019 -0500

    drm/amd/powerplay/smu11: remove smu_update_table_with_arg
    
    Nothing was using it.  Just replace with smu_update_table
    which is what everything was using via a wrapper anyway.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e6eec55be487..fedd5ff694f2 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -127,19 +127,17 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 	return ret;
 }
 
-int smu_update_table_with_arg(struct smu_context *smu, uint16_t table_id, uint16_t exarg,
+int smu_update_table(struct smu_context *smu, uint32_t table_index,
 		     void *table_data, bool drv2smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *table = NULL;
 	int ret = 0;
-	uint32_t table_index;
+	int table_id = table_index & 0xffff;
 
 	if (!table_data || table_id >= smu_table->table_count)
 		return -EINVAL;
 
-	table_index = (exarg << 16) | table_id;
-
 	table = &smu_table->tables[table_id];
 
 	if (drv2smu)

commit ffcb08dfaa3ae80292f89ee36b4604d3751ea4da
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed May 29 23:14:33 2019 -0500

    drm/amd/powerplay: introduce smu feature type to handle feature mask for each asic
    
    This patch introduces new smu feature type, it's to handle the different feature
    mask defines for each asic with the same smu ip.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 785321da1141..e6eec55be487 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -254,11 +254,14 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	return ret;
 }
 
-int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
+int smu_feature_is_enabled(struct smu_context *smu, enum smu_feature_mask mask)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
@@ -268,11 +271,15 @@ int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
 	return ret;
 }
 
-int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable)
+int smu_feature_set_enabled(struct smu_context *smu, enum smu_feature_mask mask,
+			    bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
@@ -291,11 +298,14 @@ int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable
 	return ret;
 }
 
-int smu_feature_is_supported(struct smu_context *smu, int feature_id)
+int smu_feature_is_supported(struct smu_context *smu, enum smu_feature_mask mask)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);
@@ -305,12 +315,16 @@ int smu_feature_is_supported(struct smu_context *smu, int feature_id)
 	return ret;
 }
 
-int smu_feature_set_supported(struct smu_context *smu, int feature_id,
+int smu_feature_set_supported(struct smu_context *smu,
+			      enum smu_feature_mask mask,
 			      bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	uint32_t feature_id;
 	int ret = 0;
 
+	feature_id = smu_feature_get_index(smu, mask);
+
 	WARN_ON(feature_id > feature->feature_num);
 
 	mutex_lock(&feature->mutex);

commit 54b998ca8d1ccbf626b398ff6ad0d1dfa771e197
Author: Hawking Zhang <Hawking.Zhang@amd.com>
Date:   Mon Apr 1 15:32:48 2019 +0800

    drm/amdgpu: enable sw smu driver for navi10 by default
    
    Navi10 will use sw smu driver for dynamic power managment,
    while vega20 could also use sw smu driver when amdgpu_dpm is
    set to 2
    
    Signed-off-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 63df59e7335d..785321da1141 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -168,13 +168,12 @@ int smu_update_table_with_arg(struct smu_context *smu, uint16_t table_id, uint16
 
 bool is_support_sw_smu(struct amdgpu_device *adev)
 {
-	if (amdgpu_dpm != 1)
-		return false;
-
-	if (adev->asic_type >= CHIP_VEGA20 && adev->asic_type != CHIP_RAVEN)
+	if (adev->asic_type == CHIP_VEGA20)
+		return (amdgpu_dpm == 2) ? true : false;
+	else if (adev->asic_type >= CHIP_NAVI10)
 		return true;
-
-	return false;
+	else
+		return false;
 }
 
 int smu_sys_get_pp_table(struct smu_context *smu, void **table)

commit 9e04021602e758bc42e15c9f8c87b196ecf9c6ef
Author: Kenneth Feng <kenneth.feng@amd.com>
Date:   Wed Mar 27 17:10:09 2019 +0800

    drm/amd/amdgpu: fw version check with gfxoff
    
    1. check the firmware version when enabling gfxoff
    2. overwrite the pptable to make sure gfxoff is really
    enabled on navi10
    
    Signed-off-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index cc245f4c61ab..63df59e7335d 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -331,7 +331,6 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
 	case CHIP_NAVI10:
-		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
 			smu->od_enabled = true;
 		smu_v11_0_set_smu_funcs(smu);

commit 74c958a3766cd1948978a60cc995c17145a5eed8
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Mar 19 17:20:09 2019 +0800

    drm/amd/powerplay: optimization feature mask function for asic
    
    1.change function return value type: from "unallowed" to "allowed"
    2.replace feature mask number with feature macro, the code will clear.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index a48ca6a4353c..cc245f4c61ab 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -233,22 +233,22 @@ int smu_feature_init_dpm(struct smu_context *smu)
 {
 	struct smu_feature *feature = &smu->smu_feature;
 	int ret = 0;
-	uint32_t unallowed_feature_mask[SMU_FEATURE_MAX/32];
+	uint32_t allowed_feature_mask[SMU_FEATURE_MAX/32];
 
 	if (!smu->pm_enabled)
 		return ret;
 	mutex_lock(&feature->mutex);
-	bitmap_fill(feature->allowed, SMU_FEATURE_MAX);
+	bitmap_zero(feature->allowed, SMU_FEATURE_MAX);
 	mutex_unlock(&feature->mutex);
 
-	ret = smu_get_unallowed_feature_mask(smu, unallowed_feature_mask,
+	ret = smu_get_allowed_feature_mask(smu, allowed_feature_mask,
 					     SMU_FEATURE_MAX/32);
 	if (ret)
 		return ret;
 
 	mutex_lock(&feature->mutex);
-	bitmap_andnot(feature->allowed, feature->allowed,
-		      (unsigned long *)unallowed_feature_mask,
+	bitmap_or(feature->allowed, feature->allowed,
+		      (unsigned long *)allowed_feature_mask,
 		      feature->feature_num);
 	mutex_unlock(&feature->mutex);
 

commit 5586348236f81de739f8d818a305d7034651bb00
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Tue Mar 19 11:00:41 2019 +0800

    drm/amd/powerplay: remove duplicate code from smu hw init
    
    remove duplicate code (un-used) in smu
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Xiaojie Yuan <xiaojie.yuan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2de67e16e5e3..a48ca6a4353c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -637,10 +637,6 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		if (ret)
 			return ret;
 
-		ret = smu_get_clk_info_from_vbios(smu);
-		if (ret)
-			return ret;
-
 		/*
 		 * check if the format_revision in vbios is up to pptable header
 		 * version, and the structure size is not 0.

commit b55c83a7438da50126e6a2c98dcf4476ce2fd0fd
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jun 21 10:49:22 2019 -0500

    drm/amd/powerplay: implement smc firmware v2.1 for smu11
    
    1.add smc_firmware_header_v2_1 hfirmware support, support more pptable in smc firmware.
    2.optimization current pptable load framework.
    3.rename read_pptable_from_vbios with setup_pptable.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b9b56ec1aacf..2de67e16e5e3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -633,7 +633,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		if (ret)
 			return ret;
 
-		ret = smu_read_pptable_from_vbios(smu);
+		ret = smu_setup_pptable(smu);
 		if (ret)
 			return ret;
 

commit 0186eb96300d26bbb82050f2acc462a396d55e6b
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Feb 20 20:05:11 2019 +0800

    drm/amd/powerplay: smu needs to be initialized after rlc in direct mode
    
    For gfx 10, rlc firmware loading relies on smu firmware is loaded firstly, so in
    direct type, it has to load smc ucode here before rlc. And meanwhile, the smu
    initialization has to move after rlc, otherwise, smu message will get failure
    during the handshake with rlc and smu.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 88fd79d5aca6..b9b56ec1aacf 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -820,16 +820,12 @@ static int smu_hw_init(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
-		ret = smu_load_microcode(smu);
-		if (ret)
+	if (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {
+		ret = smu_check_fw_status(smu);
+		if (ret) {
+			pr_err("SMC firmware status is not correct\n");
 			return ret;
-	}
-
-	ret = smu_check_fw_status(smu);
-	if (ret) {
-		pr_err("SMC firmware status is not correct\n");
-		return ret;
+		}
 	}
 
 	mutex_lock(&smu->mutex);

commit 4009b9b589aa11d812d40b92b1f825e45efb853f
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Jan 31 21:11:11 2019 +0800

    drm/amd/powerplay: move bootup value before read pptable from vbios
    
    In navi10, we need read the pp_table_id from bootup value, then decide whether
    use load the soft pptable.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index a3a6099ab8cd..88fd79d5aca6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -628,12 +628,12 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		return ret;
 
 	if (initialize) {
-		ret = smu_read_pptable_from_vbios(smu);
+		/* get boot_values from vbios to set revision, gfxclk, and etc. */
+		ret = smu_get_vbios_bootup_values(smu);
 		if (ret)
 			return ret;
 
-		/* get boot_values from vbios to set revision, gfxclk, and etc. */
-		ret = smu_get_vbios_bootup_values(smu);
+		ret = smu_read_pptable_from_vbios(smu);
 		if (ret)
 			return ret;
 

commit 2573e87074f02ad74c88f952487b01f867a1c5f9
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Jan 31 20:32:54 2019 +0800

    drm/amd/powerplay: set smu v11 funcs for navi10
    
    Naiv10 also uses smu v11 functions.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3026c7e2d3ea..a3a6099ab8cd 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -330,6 +330,7 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
+	case CHIP_NAVI10:
 		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
 			smu->od_enabled = true;

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit 9fdd91aa8cf43043690a41589e75359b4d837b92
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:54 2019 +0200

    drm/amd: drop use of drmP.h in powerplay/
    
    Delete the only include of drmP.h in powerplay/.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian Knig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-8-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index eec329ab6037..a4c9d9267f8e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -20,9 +20,9 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
-#include "pp_debug.h"
 #include <linux/firmware.h>
-#include <drm/drmP.h>
+
+#include "pp_debug.h"
 #include "amdgpu.h"
 #include "amdgpu_smu.h"
 #include "soc15_common.h"

commit 91c1ead6aee22d4595f50ba66070b94a4a8f84a9
Merge: 14ee642c2ab0 cf401e2856b2
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri May 31 09:33:29 2019 +1000

    Merge branch 'drm-next-5.3' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    New stuff for 5.3:
    - Add new thermal sensors for vega asics
    - Various RAS fixes
    - Add sysfs interface for memory interface utilization
    - Use HMM rather than mmu notifier for user pages
    - Expose xgmi topology via kfd
    - SR-IOV fixes
    - Fixes for manual driver reload
    - Add unique identifier for vega asics
    - Clean up user fence handling with UVD/VCE/VCN blocks
    - Convert DC to use core bpc attribute rather than a custom one
    - Add GWS support for KFD
    - Vega powerplay improvements
    - Add CRC support for DCE 12
    - SR-IOV support for new security policy
    - Various cleanups
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190529220944.14464-1-alexander.deucher@amd.com

commit a7517677085413ff69d0c9038b0aadc2e7954143
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Tue May 21 15:57:21 2019 +0800

    drm/amd/powerplay: Fix code error for translating int type to bool type correctly
    
    Fix code error to support value < 0 or > 1.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Hawking Zhang <hawking.zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3a47130f8150..d5f03b962539 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -348,7 +348,7 @@ static int smu_early_init(void *handle)
 	struct smu_context *smu = &adev->smu;
 
 	smu->adev = adev;
-	smu->pm_enabled = amdgpu_dpm;
+	smu->pm_enabled = !!amdgpu_dpm;
 	mutex_init(&smu->mutex);
 
 	return smu_set_funcs(adev);

commit a254bfa2c5fbd46165010cd6c29a4ad7638b8772
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Wed May 8 14:38:55 2019 +0800

    drm/amd/powerplay: Enable "disable dpm" feature to support swSMU debug (v2)
    
    add pm_enabled to control the dpm off/on.
    v2: Directly return 0 to replace return ret and merge some check code.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Hawking Zhang <hawking.zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b119a276a977..3a47130f8150 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -198,6 +198,8 @@ int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
 	ATOM_COMMON_TABLE_HEADER *header = (ATOM_COMMON_TABLE_HEADER *)buf;
 	int ret = 0;
 
+	if (!smu->pm_enabled)
+		return -EINVAL;
 	if (header->usStructureSize != size) {
 		pr_err("pp table size not matched !\n");
 		return -EIO;
@@ -233,6 +235,8 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	int ret = 0;
 	uint32_t unallowed_feature_mask[SMU_FEATURE_MAX/32];
 
+	if (!smu->pm_enabled)
+		return ret;
 	mutex_lock(&feature->mutex);
 	bitmap_fill(feature->allowed, SMU_FEATURE_MAX);
 	mutex_unlock(&feature->mutex);
@@ -344,6 +348,7 @@ static int smu_early_init(void *handle)
 	struct smu_context *smu = &adev->smu;
 
 	smu->adev = adev;
+	smu->pm_enabled = amdgpu_dpm;
 	mutex_init(&smu->mutex);
 
 	return smu_set_funcs(adev);
@@ -353,6 +358,9 @@ static int smu_late_init(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
+
+	if (!smu->pm_enabled)
+		return 0;
 	mutex_lock(&smu->mutex);
 	smu_handle_task(&adev->smu,
 			smu->smu_dpm.dpm_level,
@@ -736,6 +744,9 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	 */
 	ret = smu_set_tool_table_location(smu);
 
+	if (!smu_is_dpm_running(smu))
+		pr_info("dpm has been disabled\n");
+
 	return ret;
 }
 
@@ -848,7 +859,10 @@ static int smu_hw_init(void *handle)
 
 	mutex_unlock(&smu->mutex);
 
-	adev->pm.dpm_enabled = true;
+	if (!smu->pm_enabled)
+		adev->pm.dpm_enabled = false;
+	else
+		adev->pm.dpm_enabled = true;
 
 	pr_info("SMU is initialized successfully!\n");
 
@@ -963,7 +977,7 @@ int smu_display_configuration_change(struct smu_context *smu,
 	int index = 0;
 	int num_of_active_display = 0;
 
-	if (!is_support_sw_smu(smu->adev))
+	if (!smu->pm_enabled || !is_support_sw_smu(smu->adev))
 		return -EINVAL;
 
 	if (!display_config)
@@ -1091,7 +1105,7 @@ static int smu_enable_umd_pstate(void *handle,
 
 	struct smu_context *smu = (struct smu_context*)(handle);
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
-	if (!smu_dpm_ctx->dpm_context)
+	if (!smu->pm_enabled || !smu_dpm_ctx->dpm_context)
 		return -EINVAL;
 
 	if (!(smu_dpm_ctx->dpm_level & profile_mode_mask)) {
@@ -1134,6 +1148,8 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 	long workload;
 	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
 
+	if (!smu->pm_enabled)
+		return -EINVAL;
 	if (!skip_display_settings) {
 		ret = smu_display_config_changed(smu);
 		if (ret) {
@@ -1142,6 +1158,8 @@ int smu_adjust_power_state_dynamic(struct smu_context *smu,
 		}
 	}
 
+	if (!smu->pm_enabled)
+		return -EINVAL;
 	ret = smu_apply_clocks_adjust_rules(smu);
 	if (ret) {
 		pr_err("Failed to apply clocks adjust rules!");

commit e969f29148baee095a6ca5f81e840890578abeac
Author: Evan Quan <evan.quan@amd.com>
Date:   Mon May 13 11:16:27 2019 +0800

    drm/amd/powerplay: drop redundant smu call
    
    smu_get_clk_info_from_vbios() was called repeatedly. It
    seems a merge error.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ed8840026e59..b119a276a977 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -636,10 +636,6 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 		 * check if the format_revision in vbios is up to pptable header
 		 * version, and the structure size is not 0.
 		 */
-		ret = smu_get_clk_info_from_vbios(smu);
-		if (ret)
-			return ret;
-
 		ret = smu_check_pptable(smu);
 		if (ret)
 			return ret;

commit 8667eb64a6b2bad2111361839e91209bd16fe92f
Author: Evan Quan <evan.quan@amd.com>
Date:   Fri May 10 16:56:27 2019 +0800

    drm/amd/powerplay: drop unnecessary sw smu check
    
    There is already sw smu check on IP block adding.
    
    Signed-off-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 52d919a8b70a..ed8840026e59 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -436,9 +436,6 @@ static int smu_sw_init(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
-	if (!is_support_sw_smu(adev))
-		return -EINVAL;
-
 	smu->pool_size = adev->pm.smu_prv_buffer_size;
 	smu->smu_feature.feature_num = SMU_FEATURE_MAX;
 	mutex_init(&smu->smu_feature.mutex);
@@ -490,9 +487,6 @@ static int smu_sw_fini(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
-	if (!is_support_sw_smu(adev))
-		return -EINVAL;
-
 	ret = smu_smc_table_sw_fini(smu);
 	if (ret) {
 		pr_err("Failed to sw fini smc table!\n");
@@ -818,9 +812,6 @@ static int smu_hw_init(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (!is_support_sw_smu(adev))
-		return -EINVAL;
-
 	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
 		ret = smu_load_microcode(smu);
 		if (ret)
@@ -879,9 +870,6 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
-	if (!is_support_sw_smu(adev))
-		return -EINVAL;
-
 	kfree(table_context->driver_pptable);
 	table_context->driver_pptable = NULL;
 
@@ -936,9 +924,6 @@ static int smu_suspend(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (!is_support_sw_smu(adev))
-		return -EINVAL;
-
 	ret = smu_system_features_control(smu, false);
 	if (ret)
 		return ret;
@@ -954,9 +939,6 @@ static int smu_resume(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (!is_support_sw_smu(adev))
-		return -EINVAL;
-
 	pr_info("SMU is resuming...\n");
 
 	mutex_lock(&smu->mutex);

commit 4fde03a7efe42f1b3de3b483f98dc4551dd62ac4
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Mon Apr 29 14:47:41 2019 +0800

    drm/amd/powerplay: add helper function to get smu firmware & if version
    
    add this helper function to get smc version.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c058c784180e..52d919a8b70a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -30,6 +30,36 @@
 #include "atom.h"
 #include "amd_pcie.h"
 
+int smu_get_smc_version(struct smu_context *smu, uint32_t *if_version, uint32_t *smu_version)
+{
+	int ret = 0;
+
+	if (!if_version && !smu_version)
+		return -EINVAL;
+
+	if (if_version) {
+		ret = smu_send_smc_msg(smu, SMU_MSG_GetDriverIfVersion);
+		if (ret)
+			return ret;
+
+		ret = smu_read_smc_arg(smu, if_version);
+		if (ret)
+			return ret;
+	}
+
+	if (smu_version) {
+		ret = smu_send_smc_msg(smu, SMU_MSG_GetSmuVersion);
+		if (ret)
+			return ret;
+
+		ret = smu_read_smc_arg(smu, smu_version);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
 int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 			   bool gate)
 {

commit 029f41535ac5e07e1fa17ca963a9f9fd05fb665f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 15 12:51:30 2019 +0300

    drm/amd/powerplay: fix locking in smu_feature_set_supported()
    
    There is a typo so the code unlocks twice instead of taking the lock and
    then releasing it.
    
    Fixes: f14a323db5b0 ("drm/amd/powerplay: implement update enabled feature state to smc for smu11")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c058c784180e..eec329ab6037 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -280,7 +280,7 @@ int smu_feature_set_supported(struct smu_context *smu, int feature_id,
 
 	WARN_ON(feature_id > feature->feature_num);
 
-	mutex_unlock(&feature->mutex);
+	mutex_lock(&feature->mutex);
 	if (enable)
 		test_and_set_bit(feature_id, feature->supported);
 	else

commit 4825d8d6a0fe689bde668140600663f2c246e88f
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Mon Apr 8 16:15:36 2019 +0800

    drm/amd/powerplay: optimization function of smu_update_table
    
    in fact, the firmware need 2 parameter: 1.table_id, 2.XferArg
    so change the function interface to match the firmware code
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 7e8c74da6a74..c058c784180e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -97,16 +97,19 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 	return ret;
 }
 
-int smu_update_table(struct smu_context *smu, uint32_t table_id,
+int smu_update_table_with_arg(struct smu_context *smu, uint16_t table_id, uint16_t exarg,
 		     void *table_data, bool drv2smu)
 {
 	struct smu_table_context *smu_table = &smu->smu_table;
 	struct smu_table *table = NULL;
 	int ret = 0;
+	uint32_t table_index;
 
 	if (!table_data || table_id >= smu_table->table_count)
 		return -EINVAL;
 
+	table_index = (exarg << 16) | table_id;
+
 	table = &smu_table->tables[table_id];
 
 	if (drv2smu)
@@ -123,7 +126,7 @@ int smu_update_table(struct smu_context *smu, uint32_t table_id,
 	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
 					  SMU_MSG_TransferTableDram2Smu :
 					  SMU_MSG_TransferTableSmu2Dram,
-					  table_id);
+					  table_index);
 	if (ret)
 		return ret;
 

commit 6c851417336af718587a83b27fbe83480c31fc2f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Mar 21 09:28:22 2019 +0300

    drm/amd/powerplay: Fix double unlock bug in smu_sys_set_pp_table()
    
    We already unlocked a few lines earlier so this code unlocks twice on
    the success path.
    
    Fixes: 289921b03fe5e ("drm/amd/powerplay: implement sysfs of pp_table for smu11 (v2)")
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 00b7c885772b..7e8c74da6a74 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -187,6 +187,8 @@ int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
 	if (ret)
 		pr_info("smu reset failed, ret = %d\n", ret);
 
+	return ret;
+
 failed:
 	mutex_unlock(&smu->mutex);
 	return ret;

commit dff234d275be271d3dadfcd2e8b2d37c26e24fd0
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Feb 27 18:51:01 2019 +0800

    drm/amd/powerplay: fix raven issue for sw smu
    
    Raven series doesn't support sw smu so far, so we have to add checking to
    confirm it return false while the asic is raven.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Likun Gao <Likun.Gao@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fe2f7e2abe35..00b7c885772b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -138,7 +138,7 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 	if (amdgpu_dpm != 1)
 		return false;
 
-	if (adev->asic_type >= CHIP_VEGA20)
+	if (adev->asic_type >= CHIP_VEGA20 && adev->asic_type != CHIP_RAVEN)
 		return true;
 
 	return false;

commit 3b94fb101f4071da2b555632d8d68a353a9dde79
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Thu Jan 31 14:11:04 2019 +0800

    drm/amd/powerplay: add limit of pp_feature for smu (v3)
    
    Move pp_feature from the struct of amd_powerplay to amdgpu_device.
    Add pp_feature limit for overdrive interface.
    
    v2: put pp_feature into struct amdgpu_pm.
    v3: merge feature_mask with pp_feature.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Suggested-by: Alex Deucher <alexander.deucher@amd.com>
    Suggested-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index fa6248d8adf9..fe2f7e2abe35 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -291,6 +291,9 @@ static int smu_set_funcs(struct amdgpu_device *adev)
 
 	switch (adev->asic_type) {
 	case CHIP_VEGA20:
+		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
+		if (adev->pm.pp_feature & PP_OVERDRIVE_MASK)
+			smu->od_enabled = true;
 		smu_v11_0_set_smu_funcs(smu);
 		break;
 	default:

commit d4631cba9ebe6743df123e7c99372dfb2f840d1f
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Feb 20 19:58:11 2019 +0800

    drm/amd/powerplay: move setting allowed mask and feature enabling together
    
    This patch moves setting allowed mask and feature enabling together to refine
    the programming sequence.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 7857ceb7403f..fa6248d8adf9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -586,10 +586,6 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
-	ret = smu_feature_set_allowed_mask(smu);
-	if (ret)
-		return ret;
-
 	if (initialize) {
 		ret = smu_read_pptable_from_vbios(smu);
 		if (ret)
@@ -654,6 +650,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
+	ret = smu_feature_set_allowed_mask(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_system_features_control(smu, true);
 	if (ret)
 		return ret;

commit 24e141e1a6f27925a9439169ff0b83bbc2329d63
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Thu Feb 21 16:50:23 2019 +0800

    drm/amd/powerplay: add override pcie parameters
    
    PCIE parameters should be override to fix the conflict between the ASIC
    capabilities and the system capabilities.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Gui Chengming <Jack.Gui@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f5d6caf11ca3..7857ceb7403f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -28,6 +28,7 @@
 #include "soc15_common.h"
 #include "smu_v11_0.h"
 #include "atom.h"
+#include "amd_pcie.h"
 
 int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
 			   bool gate)
@@ -529,6 +530,47 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 	return 0;
 }
 
+static int smu_override_pcie_parameters(struct smu_context *smu)
+{
+	struct amdgpu_device *adev = smu->adev;
+	uint32_t pcie_gen = 0, pcie_width = 0, smu_pcie_arg;
+	int ret;
+
+	if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN4)
+		pcie_gen = 3;
+	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)
+		pcie_gen = 2;
+	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)
+		pcie_gen = 1;
+	else if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN1)
+		pcie_gen = 0;
+
+	/* Bit 31:16: LCLK DPM level. 0 is DPM0, and 1 is DPM1
+	 * Bit 15:8:  PCIE GEN, 0 to 3 corresponds to GEN1 to GEN4
+	 * Bit 7:0:   PCIE lane width, 1 to 7 corresponds is x1 to x32
+	 */
+	if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X16)
+		pcie_width = 6;
+	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X12)
+		pcie_width = 5;
+	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X8)
+		pcie_width = 4;
+	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X4)
+		pcie_width = 3;
+	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X2)
+		pcie_width = 2;
+	else if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X1)
+		pcie_width = 1;
+
+	smu_pcie_arg = (1 << 16) | (pcie_gen << 8) | pcie_width;
+	ret = smu_send_smc_msg_with_param(smu,
+					  SMU_MSG_OverridePcieParameters,
+					  smu_pcie_arg);
+	if (ret)
+		pr_err("[%s] Attempt to override pcie params failed!\n", __func__);
+	return ret;
+}
+
 static int smu_smc_table_hw_init(struct smu_context *smu,
 				 bool initialize)
 {
@@ -616,6 +658,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
+	ret = smu_override_pcie_parameters(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_notify_display_change(smu);
 	if (ret)
 		return ret;

commit 4b77faaf8c3be77a3f435333d62905989f0a3a40
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Wed Feb 20 13:42:55 2019 +0800

    drm/amd/powerplay: support sysfs to set socclk, fclk, dcefclk
    
    Add sys interface to set socclk, fclk and dcefclk for smu.
    Add feature_mask parameter for smu_upload_dpm_level as socclk, fclk and
    dcefclk have dependency, without feature_mask to point out specific clk
    will make it fail to set some clk.
    Fix the function of smu_unforce_dpm_levels.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Gui Chengming <Jack.Gui@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 231cce90763d..f5d6caf11ca3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1062,25 +1062,6 @@ static int smu_enable_umd_pstate(void *handle,
 	return 0;
 }
 
-int smu_unforce_dpm_levels(struct smu_context *smu)
-{
-	int ret = 0;
-
-	ret = smu_upload_dpm_level(smu, false);
-	if (ret) {
-		pr_err("Failed to upload DPM Bootup Levels!");
-		return ret;
-	}
-
-	ret = smu_upload_dpm_level(smu, true);
-	if (ret) {
-		pr_err("Failed to upload DPM Max Levels!");
-		return ret;
-	}
-
-	return ret;
-}
-
 int smu_adjust_power_state_dynamic(struct smu_context *smu,
 				   enum amd_dpm_forced_level level,
 				   bool skip_display_settings)

commit f067499b4862c053a8971461d0d937e173690ddf
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Fri Feb 15 15:47:26 2019 +0800

    drm/amd/powerplay: add condition for smc table hw init
    
    Smc table hw init should be skipped for suspend/resume when dpm running.
    Unified feature enable and disable function into smu_system_features_control.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 0a9b87369f5c..231cce90763d 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -532,8 +532,14 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 static int smu_smc_table_hw_init(struct smu_context *smu,
 				 bool initialize)
 {
+	struct amdgpu_device *adev = smu->adev;
 	int ret;
 
+	if (smu_is_dpm_running(smu) && adev->in_suspend) {
+		pr_info("dpm has been enabled\n");
+		return 0;
+	}
+
 	ret = smu_init_display(smu);
 	if (ret)
 		return ret;
@@ -606,7 +612,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu,
 	if (ret)
 		return ret;
 
-	ret = smu_feature_enable_all(smu);
+	ret = smu_system_features_control(smu, true);
 	if (ret)
 		return ret;
 
@@ -849,7 +855,7 @@ static int smu_suspend(void *handle)
 	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
-	ret = smu_feature_disable_all(smu);
+	ret = smu_system_features_control(smu, false);
 	if (ret)
 		return ret;
 

commit 4733cc7244c2f18292dbb78ba88dfee35b73ff67
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Thu Feb 14 18:35:14 2019 +0800

    drm/amd/powerplay: add suspend and resume function for smu
    
    Functional the function of smu suspend and resume.
    Modified the function of smu_smc_table_hw_init to make it useful for smu
    resume.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kenneth Feng <kenneth.feng@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9cb45fe0459b..0a9b87369f5c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -529,7 +529,8 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 	return 0;
 }
 
-static int smu_smc_table_hw_init(struct smu_context *smu)
+static int smu_smc_table_hw_init(struct smu_context *smu,
+				 bool initialize)
 {
 	int ret;
 
@@ -541,54 +542,56 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
-	ret = smu_read_pptable_from_vbios(smu);
-	if (ret)
-		return ret;
+	if (initialize) {
+		ret = smu_read_pptable_from_vbios(smu);
+		if (ret)
+			return ret;
 
-	/* get boot_values from vbios to set revision, gfxclk, and etc. */
-	ret = smu_get_vbios_bootup_values(smu);
-	if (ret)
-		return ret;
+		/* get boot_values from vbios to set revision, gfxclk, and etc. */
+		ret = smu_get_vbios_bootup_values(smu);
+		if (ret)
+			return ret;
 
-	ret = smu_get_clk_info_from_vbios(smu);
-	if (ret)
-		return ret;
+		ret = smu_get_clk_info_from_vbios(smu);
+		if (ret)
+			return ret;
 
-	/*
-	 * check if the format_revision in vbios is up to pptable header
-	 * version, and the structure size is not 0.
-	 */
-	ret = smu_get_clk_info_from_vbios(smu);
-	if (ret)
-		return ret;
+		/*
+		 * check if the format_revision in vbios is up to pptable header
+		 * version, and the structure size is not 0.
+		 */
+		ret = smu_get_clk_info_from_vbios(smu);
+		if (ret)
+			return ret;
 
-	ret = smu_check_pptable(smu);
-	if (ret)
-		return ret;
+		ret = smu_check_pptable(smu);
+		if (ret)
+			return ret;
 
-	/*
-	 * allocate vram bos to store smc table contents.
-	 */
-	ret = smu_init_fb_allocations(smu);
-	if (ret)
-		return ret;
+		/*
+		 * allocate vram bos to store smc table contents.
+		 */
+		ret = smu_init_fb_allocations(smu);
+		if (ret)
+			return ret;
 
-	/*
-	 * Parse pptable format and fill PPTable_t smc_pptable to
-	 * smu_table_context structure. And read the smc_dpm_table from vbios,
-	 * then fill it into smc_pptable.
-	 */
-	ret = smu_parse_pptable(smu);
-	if (ret)
-		return ret;
+		/*
+		 * Parse pptable format and fill PPTable_t smc_pptable to
+		 * smu_table_context structure. And read the smc_dpm_table from vbios,
+		 * then fill it into smc_pptable.
+		 */
+		ret = smu_parse_pptable(smu);
+		if (ret)
+			return ret;
 
-	/*
-	 * Send msg GetDriverIfVersion to check if the return value is equal
-	 * with DRIVER_IF_VERSION of smc header.
-	 */
-	ret = smu_check_fw_version(smu);
-	if (ret)
-		return ret;
+		/*
+		 * Send msg GetDriverIfVersion to check if the return value is equal
+		 * with DRIVER_IF_VERSION of smc header.
+		 */
+		ret = smu_check_fw_version(smu);
+		if (ret)
+			return ret;
+	}
 
 	/*
 	 * Copy pptable bo in the vram to smc with SMU MSGs such as
@@ -624,25 +627,29 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	 * gfxclk, memclk, dcefclk, and etc. And enable the DPM feature for each
 	 * type of clks.
 	 */
-	ret = smu_populate_smc_pptable(smu);
-	if (ret)
-		return ret;
+	if (initialize) {
+		ret = smu_populate_smc_pptable(smu);
+		if (ret)
+			return ret;
 
-	ret = smu_init_max_sustainable_clocks(smu);
-	if (ret)
-		return ret;
+		ret = smu_init_max_sustainable_clocks(smu);
+		if (ret)
+			return ret;
+	}
 
-	ret = smu_set_od8_default_settings(smu);
+	ret = smu_set_od8_default_settings(smu, initialize);
 	if (ret)
 		return ret;
 
-	ret = smu_populate_umd_state_clk(smu);
-	if (ret)
-		return ret;
+	if (initialize) {
+		ret = smu_populate_umd_state_clk(smu);
+		if (ret)
+			return ret;
 
-	ret = smu_get_power_limit(smu, &smu->default_power_limit, false);
-	if (ret)
-		return ret;
+		ret = smu_get_power_limit(smu, &smu->default_power_limit, false);
+		if (ret)
+			return ret;
+	}
 
 	/*
 	 * Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
@@ -714,6 +721,7 @@ static int smu_free_memory_pool(struct smu_context *smu)
 
 	return ret;
 }
+
 static int smu_hw_init(void *handle)
 {
 	int ret;
@@ -741,7 +749,7 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
-	ret = smu_smc_table_hw_init(smu);
+	ret = smu_smc_table_hw_init(smu, true);
 	if (ret)
 		goto failed;
 
@@ -834,11 +842,19 @@ int smu_reset(struct smu_context *smu)
 
 static int smu_suspend(void *handle)
 {
+	int ret;
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
 
 	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
+	ret = smu_feature_disable_all(smu);
+	if (ret)
+		return ret;
+
+	smu->watermarks_bitmap &= ~(WATERMARKS_LOADED);
+
 	return 0;
 }
 
@@ -853,37 +869,13 @@ static int smu_resume(void *handle)
 
 	pr_info("SMU is resuming...\n");
 
-	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
-		ret = smu_load_microcode(smu);
-		if (ret)
-			return ret;
-	}
-
-	ret = smu_check_fw_status(smu);
-	if (ret) {
-		pr_err("SMC firmware status is not correct\n");
-		return ret;
-	}
-
 	mutex_lock(&smu->mutex);
 
-	ret = smu_set_tool_table_location(smu);
-	if (ret)
-		goto failed;
-
-	ret = smu_write_pptable(smu);
+	ret = smu_smc_table_hw_init(smu, false);
 	if (ret)
 		goto failed;
 
-	ret = smu_write_watermarks_table(smu);
-	if (ret)
-		goto failed;
-
-	ret = smu_set_last_dcef_min_deep_sleep_clk(smu);
-	if (ret)
-		goto failed;
-
-	ret = smu_system_features_control(smu, true);
+	ret = smu_start_thermal_control(smu);
 	if (ret)
 		goto failed;
 

commit bee71d26d2233961dc6c8d18fce0ecf38905cd45
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Wed Jan 30 11:38:55 2019 +0800

    drm/amd/powerplay: add smu_late_init for SMU11.
    
    add smu_late_init to complete smu init sequence for SMU11.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 60491d1f674a..9cb45fe0459b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -310,6 +310,19 @@ static int smu_early_init(void *handle)
 	return smu_set_funcs(adev);
 }
 
+static int smu_late_init(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+	mutex_lock(&smu->mutex);
+	smu_handle_task(&adev->smu,
+			smu->smu_dpm.dpm_level,
+			AMD_PP_TASK_COMPLETE_INIT);
+	mutex_unlock(&smu->mutex);
+
+	return 0;
+}
+
 int smu_get_atom_data_table(struct smu_context *smu, uint32_t table,
 			    uint16_t *size, uint8_t *frev, uint8_t *crev,
 			    uint8_t **addr)
@@ -1181,7 +1194,7 @@ int smu_handle_task(struct smu_context *smu,
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,
-	.late_init = NULL,
+	.late_init = smu_late_init,
 	.sw_init = smu_sw_init,
 	.sw_fini = smu_sw_fini,
 	.hw_init = smu_hw_init,

commit 46814f51527b7bb0aae2d8582ac7a9da2941f1d2
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Thu Jan 24 17:50:57 2019 +0800

    drm/amd/powerplay: add STABLE_PSTATE_SCLK and STABLE_PSTATE_MCLK when read sensor for SMU11
    
    add AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK and
    AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK to support
    read sensor for SMU11.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Kevin Wang <kevink1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ed2d1996455e..60491d1f674a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -73,6 +73,14 @@ int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 	int ret = 0;
 
 	switch (sensor) {
+	case AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK:
+		*((uint32_t *)data) = smu->pstate_sclk;
+		*size = 4;
+		break;
+	case AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK:
+		*((uint32_t *)data) = smu->pstate_mclk;
+		*size = 4;
+		break;
 	case AMDGPU_PP_SENSOR_ENABLED_SMC_FEATURES_MASK:
 		ret = smu_feature_get_enabled_mask(smu, (uint32_t *)data, 2);
 		*size = 8;

commit 014c4440161b96ad237b1795f9dfdff24c419342
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Tue Jan 22 17:56:16 2019 +0800

    drm/amd/powerplay: implement power1_cap and power1_cap_max interface for SMU11 (v2)
    
    add get_power_limit and set_power_limit functions
    to support hwmon for SMU11.
    
    v2: fix the code style issue.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ed2f7ccd2fb5..ed2d1996455e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -619,7 +619,7 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
-	ret = smu_get_power_limit(smu);
+	ret = smu_get_power_limit(smu, &smu->default_power_limit, false);
 	if (ret)
 		return ret;
 

commit a317cf0362729df2776419536eea73fd55f62e03
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jan 25 17:33:40 2019 +0800

    drm/amd/powerplay: enable amdgpu dpm for smu
    
    enable amdgpu dpm global flag
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 48b346f95cd6..ed2f7ccd2fb5 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -742,6 +742,8 @@ static int smu_hw_init(void *handle)
 
 	mutex_unlock(&smu->mutex);
 
+	adev->pm.dpm_enabled = true;
+
 	pr_info("SMU is initialized successfully!\n");
 
 	return 0;

commit bc0fcffd36baa1cbbf2a6e951e4f1acad3aa8c90
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Thu Jan 24 19:53:40 2019 +0800

    drm/amd/powerplay: Unify smu handle task function (v2)
    
    Unify power stade adjust function into smu_handle_task by the judgment
    of task_id.
    Move functions which have no relationship with smu version into the file
    of amdgpu_smu.
    Modified the function of smu_display_config_changed into two part.
    Unify some similiar function.
    
    v2: Correct the operation of upload dpm level when force dpm limit value.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d6578be92196..48b346f95cd6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -1041,6 +1041,133 @@ static int smu_enable_umd_pstate(void *handle,
 	return 0;
 }
 
+int smu_unforce_dpm_levels(struct smu_context *smu)
+{
+	int ret = 0;
+
+	ret = smu_upload_dpm_level(smu, false);
+	if (ret) {
+		pr_err("Failed to upload DPM Bootup Levels!");
+		return ret;
+	}
+
+	ret = smu_upload_dpm_level(smu, true);
+	if (ret) {
+		pr_err("Failed to upload DPM Max Levels!");
+		return ret;
+	}
+
+	return ret;
+}
+
+int smu_adjust_power_state_dynamic(struct smu_context *smu,
+				   enum amd_dpm_forced_level level,
+				   bool skip_display_settings)
+{
+	int ret = 0;
+	int index = 0;
+	uint32_t sclk_mask, mclk_mask, soc_mask;
+	long workload;
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+
+	if (!skip_display_settings) {
+		ret = smu_display_config_changed(smu);
+		if (ret) {
+			pr_err("Failed to change display config!");
+			return ret;
+		}
+	}
+
+	ret = smu_apply_clocks_adjust_rules(smu);
+	if (ret) {
+		pr_err("Failed to apply clocks adjust rules!");
+		return ret;
+	}
+
+	if (!skip_display_settings) {
+		ret = smu_notify_smc_dispaly_config(smu);
+		if (ret) {
+			pr_err("Failed to notify smc display config!");
+			return ret;
+		}
+	}
+
+	if (smu_dpm_ctx->dpm_level != level) {
+		switch (level) {
+		case AMD_DPM_FORCED_LEVEL_HIGH:
+			ret = smu_force_dpm_limit_value(smu, true);
+			break;
+		case AMD_DPM_FORCED_LEVEL_LOW:
+			ret = smu_force_dpm_limit_value(smu, false);
+			break;
+
+		case AMD_DPM_FORCED_LEVEL_AUTO:
+			ret = smu_unforce_dpm_levels(smu);
+			break;
+
+		case AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:
+			ret = smu_get_profiling_clk_mask(smu, level,
+							 &sclk_mask,
+							 &mclk_mask,
+							 &soc_mask);
+			if (ret)
+				return ret;
+			smu_force_clk_levels(smu, PP_SCLK, 1 << sclk_mask);
+			smu_force_clk_levels(smu, PP_MCLK, 1 << mclk_mask);
+			break;
+
+		case AMD_DPM_FORCED_LEVEL_MANUAL:
+		case AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:
+		default:
+			break;
+		}
+
+		if (!ret)
+			smu_dpm_ctx->dpm_level = level;
+	}
+
+	if (smu_dpm_ctx->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {
+		index = fls(smu->workload_mask);
+		index = index > 0 && index <= WORKLOAD_POLICY_MAX ? index - 1 : 0;
+		workload = smu->workload_setting[index];
+
+		if (smu->power_profile_mode != workload)
+			smu_set_power_profile_mode(smu, &workload, 0);
+	}
+
+	return ret;
+}
+
+int smu_handle_task(struct smu_context *smu,
+		    enum amd_dpm_forced_level level,
+		    enum amd_pp_task task_id)
+{
+	int ret = 0;
+
+	switch (task_id) {
+	case AMD_PP_TASK_DISPLAY_CONFIG_CHANGE:
+		ret = smu_pre_display_config_changed(smu);
+		if (ret)
+			return ret;
+		ret = smu_set_cpu_power_state(smu);
+		if (ret)
+			return ret;
+		ret = smu_adjust_power_state_dynamic(smu, level, false);
+		break;
+	case AMD_PP_TASK_COMPLETE_INIT:
+	case AMD_PP_TASK_READJUST_POWER_STATE:
+		ret = smu_adjust_power_state_dynamic(smu, level, true);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,

commit 72e91f37a81768c81aa7ac78169f5a3259c621ac
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Fri Jan 25 15:10:13 2019 +0800

    drm/amd/powerplay: implement dpm enable functions of uvd & vce for smu
    
    add function of dpm enable uvd & vce for extern module use.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f4328cf78d22..d6578be92196 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -29,6 +29,25 @@
 #include "smu_v11_0.h"
 #include "atom.h"
 
+int smu_dpm_set_power_gate(struct smu_context *smu, uint32_t block_type,
+			   bool gate)
+{
+	int ret = 0;
+
+	switch (block_type) {
+	case AMD_IP_BLOCK_TYPE_UVD:
+		ret = smu_dpm_set_uvd_enable(smu, gate);
+		break;
+	case AMD_IP_BLOCK_TYPE_VCE:
+		ret = smu_dpm_set_vce_enable(smu, gate);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
 enum amd_pm_state_type smu_get_current_power_state(struct smu_context *smu)
 {
 	/* not support power state */

commit f14a323db5b0f6cca18b7908337c84b16b2f4e92
Author: Kevin Wang <kevin1.wang@amd.com>
Date:   Thu Jan 24 15:27:02 2019 +0800

    drm/amd/powerplay: implement update enabled feature state to smc for smu11
    
    change:
    1.when enable smu feature, the feature id will store sw-bitmap and smu
    controller.
    2.add feature mutex lock to protect feature bitmap changed when update
    feature enabled state.
    
    Signed-off-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2917411a10eb..f4328cf78d22 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -170,16 +170,20 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	int ret = 0;
 	uint32_t unallowed_feature_mask[SMU_FEATURE_MAX/32];
 
+	mutex_lock(&feature->mutex);
 	bitmap_fill(feature->allowed, SMU_FEATURE_MAX);
+	mutex_unlock(&feature->mutex);
 
 	ret = smu_get_unallowed_feature_mask(smu, unallowed_feature_mask,
 					     SMU_FEATURE_MAX/32);
 	if (ret)
 		return ret;
 
+	mutex_lock(&feature->mutex);
 	bitmap_andnot(feature->allowed, feature->allowed,
 		      (unsigned long *)unallowed_feature_mask,
 		      feature->feature_num);
+	mutex_unlock(&feature->mutex);
 
 	return ret;
 }
@@ -187,38 +191,70 @@ int smu_feature_init_dpm(struct smu_context *smu)
 int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
-	return test_bit(feature_id, feature->enabled);
+
+	mutex_lock(&feature->mutex);
+	ret = test_bit(feature_id, feature->enabled);
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
+
+	mutex_lock(&feature->mutex);
+	ret = smu_feature_update_enable_state(smu, feature_id, enable);
+	if (ret)
+		goto failed;
+
 	if (enable)
 		test_and_set_bit(feature_id, feature->enabled);
 	else
 		test_and_clear_bit(feature_id, feature->enabled);
-	return 0;
+
+failed:
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 int smu_feature_is_supported(struct smu_context *smu, int feature_id)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
-	return test_bit(feature_id, feature->supported);
+
+	mutex_lock(&feature->mutex);
+	ret = test_bit(feature_id, feature->supported);
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 int smu_feature_set_supported(struct smu_context *smu, int feature_id,
 			      bool enable)
 {
 	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+
 	WARN_ON(feature_id > feature->feature_num);
+
+	mutex_unlock(&feature->mutex);
 	if (enable)
 		test_and_set_bit(feature_id, feature->supported);
 	else
 		test_and_clear_bit(feature_id, feature->supported);
-	return 0;
+	mutex_unlock(&feature->mutex);
+
+	return ret;
 }
 
 static int smu_set_funcs(struct amdgpu_device *adev)
@@ -326,6 +362,7 @@ static int smu_sw_init(void *handle)
 
 	smu->pool_size = adev->pm.smu_prv_buffer_size;
 	smu->smu_feature.feature_num = SMU_FEATURE_MAX;
+	mutex_init(&smu->smu_feature.mutex);
 	bitmap_zero(smu->smu_feature.supported, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.enabled, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.allowed, SMU_FEATURE_MAX);

commit 9a431038e30a45c470c5f949824a76538809662d
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Fri Jan 18 11:27:25 2019 +0800

    drm/amd/powerplay: implement power_dpm_force_performance_level for SMU11
    
    add get_performance_level and force_performance_level
    to implement the sys interface for SMU11.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 83fadcac18e6..2917411a10eb 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -351,6 +351,8 @@ static int smu_sw_init(void *handle)
 	smu->workload_setting[6] = PP_SMC_POWER_PROFILE_CUSTOM;
 	smu->display_config = &adev->pm.pm_display_cfg;
 
+	smu->smu_dpm.dpm_level = AMD_DPM_FORCED_LEVEL_AUTO;
+	smu->smu_dpm.requested_dpm_level = AMD_DPM_FORCED_LEVEL_AUTO;
 	ret = smu_init_microcode(smu);
 	if (ret) {
 		pr_err("Failed to load smu firmware!\n");

commit 49d27e91cf4fd817d8e554c20a496721719519d2
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Thu Jan 17 17:57:18 2019 +0800

    drm/amd/powerplay: add enable_umd_pstate functions for SMU11
    
    add enable_umd_pstate to support sys interface for SMU11.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 2a8669c89539..83fadcac18e6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -940,6 +940,49 @@ static int smu_set_powergating_state(void *handle,
 	return 0;
 }
 
+static int smu_enable_umd_pstate(void *handle,
+		      enum amd_dpm_forced_level *level)
+{
+	uint32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD |
+					AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK |
+					AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK |
+					AMD_DPM_FORCED_LEVEL_PROFILE_PEAK;
+
+	struct smu_context *smu = (struct smu_context*)(handle);
+	struct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);
+	if (!smu_dpm_ctx->dpm_context)
+		return -EINVAL;
+
+	if (!(smu_dpm_ctx->dpm_level & profile_mode_mask)) {
+		/* enter umd pstate, save current level, disable gfx cg*/
+		if (*level & profile_mode_mask) {
+			smu_dpm_ctx->saved_dpm_level = smu_dpm_ctx->dpm_level;
+			smu_dpm_ctx->enable_umd_pstate = true;
+			amdgpu_device_ip_set_clockgating_state(smu->adev,
+							       AMD_IP_BLOCK_TYPE_GFX,
+							       AMD_CG_STATE_UNGATE);
+			amdgpu_device_ip_set_powergating_state(smu->adev,
+							       AMD_IP_BLOCK_TYPE_GFX,
+							       AMD_PG_STATE_UNGATE);
+		}
+	} else {
+		/* exit umd pstate, restore level, enable gfx cg*/
+		if (!(*level & profile_mode_mask)) {
+			if (*level == AMD_DPM_FORCED_LEVEL_PROFILE_EXIT)
+				*level = smu_dpm_ctx->saved_dpm_level;
+			smu_dpm_ctx->enable_umd_pstate = false;
+			amdgpu_device_ip_set_clockgating_state(smu->adev,
+							       AMD_IP_BLOCK_TYPE_GFX,
+							       AMD_CG_STATE_GATE);
+			amdgpu_device_ip_set_powergating_state(smu->adev,
+							       AMD_IP_BLOCK_TYPE_GFX,
+							       AMD_PG_STATE_GATE);
+		}
+	}
+
+	return 0;
+}
+
 const struct amd_ip_funcs smu_ip_funcs = {
 	.name = "smu",
 	.early_init = smu_early_init,
@@ -956,6 +999,7 @@ const struct amd_ip_funcs smu_ip_funcs = {
 	.soft_reset = NULL,
 	.set_clockgating_state = smu_set_clockgating_state,
 	.set_powergating_state = smu_set_powergating_state,
+	.enable_umd_pstate = smu_enable_umd_pstate,
 };
 
 const struct amdgpu_ip_block_version smu_v11_0_ip_block =

commit 379a445480f65d6fe91abb14041526ae3e4ba5fa
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Thu Jan 17 16:58:57 2019 +0800

    drm/amd/powerplay: add display_config to handle display config for SMU11.
    
    add display_config to support sys interface for SMU11.
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f0e5bfc0deeb..2a8669c89539 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -349,6 +349,7 @@ static int smu_sw_init(void *handle)
 	smu->workload_setting[4] = PP_SMC_POWER_PROFILE_VR;
 	smu->workload_setting[5] = PP_SMC_POWER_PROFILE_COMPUTE;
 	smu->workload_setting[6] = PP_SMC_POWER_PROFILE_CUSTOM;
+	smu->display_config = &adev->pm.pm_display_cfg;
 
 	ret = smu_init_microcode(smu);
 	if (ret) {

commit 16177fd053841dbfa8bfc3b698dcee7a0abe20cb
Author: Chengming Gui <Jack.Gui@amd.com>
Date:   Mon Jan 14 14:37:31 2019 +0800

    drm/amd/powerplay: implement pp_power_profile_mode sys inerface for SMU11
    
    Add set/get power profile mode functions.
            Added dependency interfaces:
                    1) vega20_set_activity_monitor_coeff
                    2) vega20_get_activity_monitor_coeff
                    3) conv_power_profile_to_pplib_workload
    
    Signed-off-by: Chengming Gui <Jack.Gui@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 81939c40b9bc..f0e5bfc0deeb 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -330,6 +330,25 @@ static int smu_sw_init(void *handle)
 	bitmap_zero(smu->smu_feature.enabled, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.allowed, SMU_FEATURE_MAX);
 	smu->watermarks_bitmap = 0;
+	smu->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
+	smu->default_power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
+
+	smu->workload_mask = 1 << smu->workload_prority[PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT];
+	smu->workload_prority[PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT] = 0;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_FULLSCREEN3D] = 1;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_POWERSAVING] = 2;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_VIDEO] = 3;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_VR] = 4;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_COMPUTE] = 5;
+	smu->workload_prority[PP_SMC_POWER_PROFILE_CUSTOM] = 6;
+
+	smu->workload_setting[0] = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;
+	smu->workload_setting[1] = PP_SMC_POWER_PROFILE_FULLSCREEN3D;
+	smu->workload_setting[2] = PP_SMC_POWER_PROFILE_POWERSAVING;
+	smu->workload_setting[3] = PP_SMC_POWER_PROFILE_VIDEO;
+	smu->workload_setting[4] = PP_SMC_POWER_PROFILE_VR;
+	smu->workload_setting[5] = PP_SMC_POWER_PROFILE_COMPUTE;
+	smu->workload_setting[6] = PP_SMC_POWER_PROFILE_CUSTOM;
 
 	ret = smu_init_microcode(smu);
 	if (ret) {

commit 6316f51c4758a421f7e1fcaa8e3717ea1901d550
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Jan 22 16:26:39 2019 +0800

    drm/amd/powerplay: remove unnecessary checking in smu_hw_fini
    
    This patch removes unnecessary NULL pointer checking in smu_hw_fini, because
    kfree is able to handle NULL pointer case.
    
    Suggested-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 04ee523b2bf9..81939c40b9bc 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -683,40 +683,26 @@ static int smu_hw_fini(void *handle)
 	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
-	if (table_context->driver_pptable) {
-		kfree(table_context->driver_pptable);
-		table_context->driver_pptable = NULL;
-	}
+	kfree(table_context->driver_pptable);
+	table_context->driver_pptable = NULL;
 
-	if (table_context->max_sustainable_clocks) {
-		kfree(table_context->max_sustainable_clocks);
-		table_context->max_sustainable_clocks = NULL;
-	}
+	kfree(table_context->max_sustainable_clocks);
+	table_context->max_sustainable_clocks = NULL;
 
-	if (table_context->od_feature_capabilities) {
-		kfree(table_context->od_feature_capabilities);
-		table_context->od_feature_capabilities = NULL;
-	}
+	kfree(table_context->od_feature_capabilities);
+	table_context->od_feature_capabilities = NULL;
 
-	if (table_context->od_settings_max) {
-		kfree(table_context->od_settings_max);
-		table_context->od_settings_max = NULL;
-	}
+	kfree(table_context->od_settings_max);
+	table_context->od_settings_max = NULL;
 
-	if (table_context->od_settings_min) {
-		kfree(table_context->od_settings_min);
-		table_context->od_settings_min = NULL;
-	}
+	kfree(table_context->od_settings_min);
+	table_context->od_settings_min = NULL;
 
-	if (table_context->overdrive_table) {
-		kfree(table_context->overdrive_table);
-		table_context->overdrive_table = NULL;
-	}
+	kfree(table_context->overdrive_table);
+	table_context->overdrive_table = NULL;
 
-	if (table_context->od8_settings) {
-		kfree(table_context->od8_settings);
-		table_context->od8_settings = NULL;
-	}
+	kfree(table_context->od8_settings);
+	table_context->od8_settings = NULL;
 
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)

commit 2c80abe3816bf573858261c84bcc12c06ac93a5e
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Wed Jan 9 19:11:58 2019 +0800

    drm/amd/powerplay: add function to set default overdrive settings
    
    Add function of vega20_set_default_od8_setttings for vega20 with smu11
    arch to setup default overdrive value.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index dded495374c9..04ee523b2bf9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -533,6 +533,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_set_od8_default_settings(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_populate_umd_state_clk(smu);
 	if (ret)
 		return ret;
@@ -704,6 +708,16 @@ static int smu_hw_fini(void *handle)
 		table_context->od_settings_min = NULL;
 	}
 
+	if (table_context->overdrive_table) {
+		kfree(table_context->overdrive_table);
+		table_context->overdrive_table = NULL;
+	}
+
+	if (table_context->od8_settings) {
+		kfree(table_context->od8_settings);
+		table_context->od8_settings = NULL;
+	}
+
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)
 		return ret;

commit b55ca3bdaf0bbfd14ad6619a991fbd324ae1ad4b
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Tue Jan 8 14:18:02 2019 +0800

    drm/amd/powerplay: add function to store overdrive information for smu11
    
    Add vega20_setup_od8_information function to store overdrive information
    from powerplay_table to smu_table which will used when setting od8.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Kevin Wang <kevin1.wang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e6915ef55b6a..dded495374c9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -689,6 +689,21 @@ static int smu_hw_fini(void *handle)
 		table_context->max_sustainable_clocks = NULL;
 	}
 
+	if (table_context->od_feature_capabilities) {
+		kfree(table_context->od_feature_capabilities);
+		table_context->od_feature_capabilities = NULL;
+	}
+
+	if (table_context->od_settings_max) {
+		kfree(table_context->od_settings_max);
+		table_context->od_settings_max = NULL;
+	}
+
+	if (table_context->od_settings_min) {
+		kfree(table_context->od_settings_min);
+		table_context->od_settings_min = NULL;
+	}
+
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)
 		return ret;

commit 2e069391188c1883c30f3a9441ba1b279da68c94
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Jan 17 15:25:37 2019 +0800

    drm/amd/powerplay: implement interface to set watermarks for clock ranges
    
    This patch implements inteferface to set watermarks table for clock ranges on
    smu 11. It fills watermark table before it is written to SMC.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 9e60f56853b2..e6915ef55b6a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -329,6 +329,7 @@ static int smu_sw_init(void *handle)
 	bitmap_zero(smu->smu_feature.supported, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.enabled, SMU_FEATURE_MAX);
 	bitmap_zero(smu->smu_feature.allowed, SMU_FEATURE_MAX);
+	smu->watermarks_bitmap = 0;
 
 	ret = smu_init_microcode(smu);
 	if (ret) {

commit 5e2d38814e9fb39c529030523fe9c6b175c0c19f
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Jan 16 14:43:29 2019 +0800

    drm/amd/powerplay: add interface to get current clocks for display
    
    This patch fills the amd_pp_clock_info data for display, it will get the current
    info in that structure.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index cf8739f262c8..9e60f56853b2 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -814,6 +814,84 @@ int smu_display_configuration_change(struct smu_context *smu,
 	return 0;
 }
 
+static int smu_get_clock_info(struct smu_context *smu,
+			      struct smu_clock_info *clk_info,
+			      enum smu_perf_level_designation designation)
+{
+	int ret;
+	struct smu_performance_level level = {0};
+
+	if (!clk_info)
+		return -EINVAL;
+
+	ret = smu_get_perf_level(smu, PERF_LEVEL_ACTIVITY, &level);
+	if (ret)
+		return -EINVAL;
+
+	clk_info->min_mem_clk = level.memory_clock;
+	clk_info->min_eng_clk = level.core_clock;
+	clk_info->min_bus_bandwidth = level.non_local_mem_freq * level.non_local_mem_width;
+
+	ret = smu_get_perf_level(smu, designation, &level);
+	if (ret)
+		return -EINVAL;
+
+	clk_info->min_mem_clk = level.memory_clock;
+	clk_info->min_eng_clk = level.core_clock;
+	clk_info->min_bus_bandwidth = level.non_local_mem_freq * level.non_local_mem_width;
+
+	return 0;
+}
+
+int smu_get_current_clocks(struct smu_context *smu,
+			   struct amd_pp_clock_info *clocks)
+{
+	struct amd_pp_simple_clock_info simple_clocks = {0};
+	struct smu_clock_info hw_clocks;
+	int ret = 0;
+
+	if (!is_support_sw_smu(smu->adev))
+		return -EINVAL;
+
+	mutex_lock(&smu->mutex);
+
+	smu_get_dal_power_level(smu, &simple_clocks);
+
+	if (smu->support_power_containment)
+		ret = smu_get_clock_info(smu, &hw_clocks,
+					 PERF_LEVEL_POWER_CONTAINMENT);
+	else
+		ret = smu_get_clock_info(smu, &hw_clocks, PERF_LEVEL_ACTIVITY);
+
+	if (ret) {
+		pr_err("Error in smu_get_clock_info\n");
+		goto failed;
+	}
+
+	clocks->min_engine_clock = hw_clocks.min_eng_clk;
+	clocks->max_engine_clock = hw_clocks.max_eng_clk;
+	clocks->min_memory_clock = hw_clocks.min_mem_clk;
+	clocks->max_memory_clock = hw_clocks.max_mem_clk;
+	clocks->min_bus_bandwidth = hw_clocks.min_bus_bandwidth;
+	clocks->max_bus_bandwidth = hw_clocks.max_bus_bandwidth;
+	clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
+	clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
+
+        if (simple_clocks.level == 0)
+                clocks->max_clocks_state = PP_DAL_POWERLEVEL_7;
+        else
+                clocks->max_clocks_state = simple_clocks.level;
+
+        if (!smu_get_current_shallow_sleep_clocks(smu, &hw_clocks)) {
+                clocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;
+                clocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;
+        }
+
+failed:
+	mutex_unlock(&smu->mutex);
+	return ret;
+}
+
 static int smu_set_clockgating_state(void *handle,
 				     enum amd_clockgating_state state)
 {

commit 94ed6d0cfdb867be9bf05f03d682980bce5d0036
Author: Huang Rui <ray.huang@amd.com>
Date:   Fri Jan 11 16:23:36 2019 +0800

    drm/amd/powerplay: add smu display configuration change function
    
    This patch adds display configuration change function that creates the new path
    with sw smu driver instead of powerplay.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index dc431f2eebe1..cf8739f262c8 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -780,6 +780,40 @@ static int smu_resume(void *handle)
 	return ret;
 }
 
+int smu_display_configuration_change(struct smu_context *smu,
+				     const struct amd_pp_display_configuration *display_config)
+{
+	int index = 0;
+	int num_of_active_display = 0;
+
+	if (!is_support_sw_smu(smu->adev))
+		return -EINVAL;
+
+	if (!display_config)
+		return -EINVAL;
+
+	mutex_lock(&smu->mutex);
+
+	smu_set_deep_sleep_dcefclk(smu,
+				   display_config->min_dcef_deep_sleep_set_clk / 100);
+
+	for (index = 0; index < display_config->num_path_including_non_display; index++) {
+		if (display_config->displays[index].controller_id != 0)
+			num_of_active_display++;
+	}
+
+	smu_set_active_display_count(smu, num_of_active_display);
+
+	smu_store_cc6_data(smu, display_config->cpu_pstate_separation_time,
+			   display_config->cpu_cc6_disable,
+			   display_config->cpu_pstate_disable,
+			   display_config->nb_pstate_switch_disable);
+
+	mutex_unlock(&smu->mutex);
+
+	return 0;
+}
+
 static int smu_set_clockgating_state(void *handle,
 				     enum amd_clockgating_state state)
 {

commit ea2d0bf8c7f07ca6d0de11628a5d3af6c247e51c
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Thu Jan 17 13:29:06 2019 +0800

    drm/amd/powerplay: implement sysfs of pp_cur_state function
    
    add function of smu_get_currente_state for sw-smu.
    
    v2: fix code typo error if (ret);
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b4d6046d5f23..dc431f2eebe1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -29,6 +29,12 @@
 #include "smu_v11_0.h"
 #include "atom.h"
 
+enum amd_pm_state_type smu_get_current_power_state(struct smu_context *smu)
+{
+	/* not support power state */
+	return POWER_STATE_TYPE_DEFAULT;
+}
+
 int smu_get_power_num_states(struct smu_context *smu,
 			     struct pp_states_info *state_info)
 {

commit 0989532330e1e7d25693c14b3d57288aa4915f81
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Thu Jan 17 13:15:48 2019 +0800

    drm/amd/powerplay: implement sysfs of get num states function
    
    add function smu_get_power_num_state function for sw-smu.
    it's only for sysfs interface, the power state feature is not ready for sw-smu.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 012d2790da8a..b4d6046d5f23 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -29,6 +29,19 @@
 #include "smu_v11_0.h"
 #include "atom.h"
 
+int smu_get_power_num_states(struct smu_context *smu,
+			     struct pp_states_info *state_info)
+{
+	if (!state_info)
+		return -EINVAL;
+
+	/* not support power state */
+	memset(state_info, 0, sizeof(struct pp_states_info));
+	state_info->nums = 0;
+
+	return 0;
+}
+
 int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
 			   void *data, uint32_t *size)
 {

commit 143c75d6514dd65ba49d3846a5a02c45a4b7f15b
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Wed Jan 16 09:55:03 2019 +0800

    drm/amd/powerplay: implement sensor of get feature mask
    
    add sensor interface of feature mask for debugfs.
    this interface is not ip related function, so need move high level
    file to implement (amdgpu_smu)
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Evan Quan <evan.quan@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f17c85fc61e9..012d2790da8a 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -29,6 +29,27 @@
 #include "smu_v11_0.h"
 #include "atom.h"
 
+int smu_common_read_sensor(struct smu_context *smu, enum amd_pp_sensors sensor,
+			   void *data, uint32_t *size)
+{
+	int ret = 0;
+
+	switch (sensor) {
+	case AMDGPU_PP_SENSOR_ENABLED_SMC_FEATURES_MASK:
+		ret = smu_feature_get_enabled_mask(smu, (uint32_t *)data, 2);
+		*size = 8;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	if (ret)
+		*size = 0;
+
+	return ret;
+}
+
 int smu_update_table(struct smu_context *smu, uint32_t table_id,
 		     void *table_data, bool drv2smu)
 {

commit 289921b03fe5e288cf924a52018f075e1b94f446
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Fri Jan 11 15:07:52 2019 +0800

    drm/amd/powerplay: implement sysfs of pp_table for smu11 (v2)
    
    add pp_table sysfs interface for new sw-smu.
    get: return pptable raw data
    set: write pptable raw data to pptable, then reset smu (hw_fini -> hw_init)
    
    v2: fix mutex lock issue
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f35c2177d13d..f17c85fc61e9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -76,6 +76,54 @@ bool is_support_sw_smu(struct amdgpu_device *adev)
 	return false;
 }
 
+int smu_sys_get_pp_table(struct smu_context *smu, void **table)
+{
+	struct smu_table_context *smu_table = &smu->smu_table;
+
+	if (!smu_table->power_play_table && !smu_table->hardcode_pptable)
+		return -EINVAL;
+
+	if (smu_table->hardcode_pptable)
+		*table = smu_table->hardcode_pptable;
+	else
+		*table = smu_table->power_play_table;
+
+	return smu_table->power_play_table_size;
+}
+
+int smu_sys_set_pp_table(struct smu_context *smu,  void *buf, size_t size)
+{
+	struct smu_table_context *smu_table = &smu->smu_table;
+	ATOM_COMMON_TABLE_HEADER *header = (ATOM_COMMON_TABLE_HEADER *)buf;
+	int ret = 0;
+
+	if (header->usStructureSize != size) {
+		pr_err("pp table size not matched !\n");
+		return -EIO;
+	}
+
+	mutex_lock(&smu->mutex);
+	if (!smu_table->hardcode_pptable)
+		smu_table->hardcode_pptable = kzalloc(size, GFP_KERNEL);
+	if (!smu_table->hardcode_pptable) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	memcpy(smu_table->hardcode_pptable, buf, size);
+	smu_table->power_play_table = smu_table->hardcode_pptable;
+	smu_table->power_play_table_size = size;
+	mutex_unlock(&smu->mutex);
+
+	ret = smu_reset(smu);
+	if (ret)
+		pr_info("smu reset failed, ret = %d\n", ret);
+
+failed:
+	mutex_unlock(&smu->mutex);
+	return ret;
+}
+
 int smu_feature_init_dpm(struct smu_context *smu)
 {
 	struct smu_feature *feature = &smu->smu_feature;
@@ -328,7 +376,7 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 	uint32_t i = 0;
 
 	if (table_count == 0 || tables == NULL)
-		return -EINVAL;
+		return 0;
 
 	for (i = 0 ; i < table_count; i++) {
 		if (tables[i].size == 0)
@@ -590,9 +638,10 @@ static int smu_hw_fini(void *handle)
 	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
-	if (!table_context->driver_pptable)
-		return -EINVAL;
-	kfree(table_context->driver_pptable);
+	if (table_context->driver_pptable) {
+		kfree(table_context->driver_pptable);
+		table_context->driver_pptable = NULL;
+	}
 
 	if (table_context->max_sustainable_clocks) {
 		kfree(table_context->max_sustainable_clocks);
@@ -610,6 +659,22 @@ static int smu_hw_fini(void *handle)
 	return 0;
 }
 
+int smu_reset(struct smu_context *smu)
+{
+	struct amdgpu_device *adev = smu->adev;
+	int ret = 0;
+
+	ret = smu_hw_fini(adev);
+	if (ret)
+		return ret;
+
+	ret = smu_hw_init(adev);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
 static int smu_suspend(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;

commit dc8e3a0c8efbaab9b4bc7b924463a56ea33d818c
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Thu Jan 10 12:33:23 2019 +0800

    drm/amd/powerplay: implement is_support_sw_smu function for new smu
    
    add this helper to check new sw-smu support.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 56095a400731..f35c2177d13d 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -65,6 +65,17 @@ int smu_update_table(struct smu_context *smu, uint32_t table_id,
 	return ret;
 }
 
+bool is_support_sw_smu(struct amdgpu_device *adev)
+{
+	if (amdgpu_dpm != 1)
+		return false;
+
+	if (adev->asic_type >= CHIP_VEGA20)
+		return true;
+
+	return false;
+}
+
 int smu_feature_init_dpm(struct smu_context *smu)
 {
 	struct smu_feature *feature = &smu->smu_feature;
@@ -222,7 +233,7 @@ static int smu_sw_init(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
-	if (adev->asic_type < CHIP_VEGA20)
+	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
 	smu->pool_size = adev->pm.smu_prv_buffer_size;
@@ -252,7 +263,7 @@ static int smu_sw_fini(void *handle)
 	struct smu_context *smu = &adev->smu;
 	int ret;
 
-	if (adev->asic_type < CHIP_VEGA20)
+	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
 	ret = smu_smc_table_sw_fini(smu);
@@ -517,7 +528,7 @@ static int smu_hw_init(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (adev->asic_type < CHIP_VEGA20)
+	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
 	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
@@ -576,7 +587,7 @@ static int smu_hw_fini(void *handle)
 	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
-	if (adev->asic_type < CHIP_VEGA20)
+	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
 	if (!table_context->driver_pptable)
@@ -603,7 +614,7 @@ static int smu_suspend(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
-	if (adev->asic_type < CHIP_VEGA20)
+	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
 	return 0;
@@ -615,7 +626,7 @@ static int smu_resume(void *handle)
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
 
-	if (adev->asic_type < CHIP_VEGA20)
+	if (!is_support_sw_smu(adev))
 		return -EINVAL;
 
 	pr_info("SMU is resuming...\n");

commit dbe6a97024a6eeadf7912383e05118ff98883d2d
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Mon Jan 7 15:34:09 2019 +0800

    drm/amd/powerplay: implement smu update table function
    
    sometime, the driver need changed table data between driver and smu.
    this function can help update table data
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 172b84480d6c..56095a400731 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -29,6 +29,42 @@
 #include "smu_v11_0.h"
 #include "atom.h"
 
+int smu_update_table(struct smu_context *smu, uint32_t table_id,
+		     void *table_data, bool drv2smu)
+{
+	struct smu_table_context *smu_table = &smu->smu_table;
+	struct smu_table *table = NULL;
+	int ret = 0;
+
+	if (!table_data || table_id >= smu_table->table_count)
+		return -EINVAL;
+
+	table = &smu_table->tables[table_id];
+
+	if (drv2smu)
+		memcpy(table->cpu_addr, table_data, table->size);
+
+	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetDriverDramAddrHigh,
+					  upper_32_bits(table->mc_address));
+	if (ret)
+		return ret;
+	ret = smu_send_smc_msg_with_param(smu, SMU_MSG_SetDriverDramAddrLow,
+					  lower_32_bits(table->mc_address));
+	if (ret)
+		return ret;
+	ret = smu_send_smc_msg_with_param(smu, drv2smu ?
+					  SMU_MSG_TransferTableDram2Smu :
+					  SMU_MSG_TransferTableSmu2Dram,
+					  table_id);
+	if (ret)
+		return ret;
+
+	if (!drv2smu)
+		memcpy(table_data, table->cpu_addr, table->size);
+
+	return ret;
+}
+
 int smu_feature_init_dpm(struct smu_context *smu)
 {
 	struct smu_feature *feature = &smu->smu_feature;

commit 74ba3553b2bb26adb36dd7d0b13b85bca64f3ef2
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Fri Jan 4 16:00:48 2019 +0800

    drm/amd/powerplay: add function to start thermal control
    
    Add function to start thermal control for smu11 when smu hw_init.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index cd04369c652b..172b84480d6c 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -518,6 +518,10 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
+	ret = smu_start_thermal_control(smu);
+	if (ret)
+		goto failed;
+
 	mutex_unlock(&smu->mutex);
 
 	pr_info("SMU is initialized successfully!\n");

commit 7457cf02540571e17ce464e5cb1865cfb020de31
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 25 16:34:39 2018 +0800

    drm/amd/powerplay: add get_max_sustainable_clock function
    
    This patch adds get_max_sustainable_clock function for smu11.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b225cf876a91..cd04369c652b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -393,6 +393,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_init_max_sustainable_clocks(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_populate_umd_state_clk(smu);
 	if (ret)
 		return ret;
@@ -539,6 +543,11 @@ static int smu_hw_fini(void *handle)
 		return -EINVAL;
 	kfree(table_context->driver_pptable);
 
+	if (table_context->max_sustainable_clocks) {
+		kfree(table_context->max_sustainable_clocks);
+		table_context->max_sustainable_clocks = NULL;
+	}
+
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)
 		return ret;

commit e66adb1eea90703f4e1d8ea509f7ec3fe0b4be6d
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Tue Dec 25 14:44:25 2018 +0800

    drm/amd/powerplay: add function to get power limit for smu11 (v2)
    
    Add smu_v11_0_get_power_limit function to get power limit vaule.
    
    v2: update "set" to "get", it only implements "get" behavior. (Alex)
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f5ffc9bd31a6..b225cf876a91 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -397,6 +397,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_get_power_limit(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
 	 */

commit 133438fa4e60d017b2c45b9fca64bcc4fc64007f
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Mon Dec 24 19:49:38 2018 +0800

    drm/amd/powerplay: add function to populate umd state clk.
    
    Add vega20_populate_umd_state_clk function to set pstate_sclk and pstate_mclk.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e03132c17f4e..f5ffc9bd31a6 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -393,6 +393,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_populate_umd_state_clk(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
 	 */

commit d6a4aa825a65ee7ec0293666fd1572e4621ad13d
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Thu Dec 20 20:31:55 2018 +0800

    drm/amd/powerplay: set defalut dpm table for smu
    
    Add smu_set_default_dpm_table function to set dpm table for smu11.
    Modified the sequence to populate smc pptable, as it should be done after
    related dpm feature is enabled.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 47b46115a4f3..e03132c17f4e 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -347,15 +347,6 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
-	/*
-	 * Set initialized values (get from vbios) to dpm tables context such as
-	 * gfxclk, memclk, dcefclk, and etc. And enable the DPM feature for each
-	 * type of clks.
-	 */
-	ret = smu_populate_smc_pptable(smu);
-	if (ret)
-		return ret;
-
 	/*
 	 * Send msg GetDriverIfVersion to check if the return value is equal
 	 * with DRIVER_IF_VERSION of smc header.
@@ -393,6 +384,15 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * Set initialized values (get from vbios) to dpm tables context such as
+	 * gfxclk, memclk, dcefclk, and etc. And enable the DPM feature for each
+	 * type of clks.
+	 */
+	ret = smu_populate_smc_pptable(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
 	 */

commit e1c6f86a915f7c3f6bba7a72713f9e61221dafe4
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Wed Dec 26 16:14:55 2018 +0800

    drm/amd/powerplay: implement smu_notify_display_change function for smu11
    
    add smu_notify_display_change function to send msg to smc to notify
    display is changed.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index aba3fb1a6bdb..47b46115a4f3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -381,6 +381,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_notify_display_change(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * Set min deep sleep dce fclk with bootup value from vbios via
 	 * SetMinDeepSleepDcefclk MSG.

commit 2f25158d7db8a435a65f22ca194fc461cb26db82
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Wed Dec 26 16:13:09 2018 +0800

    drm/amd/powerplay: implement feature get&set functions
    
    add smu feature operation function helper to deal with smu feature
    bitmap.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f9b254c8dad9..aba3fb1a6bdb 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -49,6 +49,43 @@ int smu_feature_init_dpm(struct smu_context *smu)
 	return ret;
 }
 
+int smu_feature_is_enabled(struct smu_context *smu, int feature_id)
+{
+	struct smu_feature *feature = &smu->smu_feature;
+	WARN_ON(feature_id > feature->feature_num);
+	return test_bit(feature_id, feature->enabled);
+}
+
+int smu_feature_set_enabled(struct smu_context *smu, int feature_id, bool enable)
+{
+	struct smu_feature *feature = &smu->smu_feature;
+	WARN_ON(feature_id > feature->feature_num);
+	if (enable)
+		test_and_set_bit(feature_id, feature->enabled);
+	else
+		test_and_clear_bit(feature_id, feature->enabled);
+	return 0;
+}
+
+int smu_feature_is_supported(struct smu_context *smu, int feature_id)
+{
+	struct smu_feature *feature = &smu->smu_feature;
+	WARN_ON(feature_id > feature->feature_num);
+	return test_bit(feature_id, feature->supported);
+}
+
+int smu_feature_set_supported(struct smu_context *smu, int feature_id,
+			      bool enable)
+{
+	struct smu_feature *feature = &smu->smu_feature;
+	WARN_ON(feature_id > feature->feature_num);
+	if (enable)
+		test_and_set_bit(feature_id, feature->supported);
+	else
+		test_and_clear_bit(feature_id, feature->supported);
+	return 0;
+}
+
 static int smu_set_funcs(struct amdgpu_device *adev)
 {
 	struct smu_context *smu = &adev->smu;

commit 6b816d7316397b5898609e8da31c33790ef34ea0
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Wed Dec 26 17:36:25 2018 +0800

    drm/amd/powerplay: implement smu feature functions
    
    each ip will support different smu feature,
    the driver use bitmap to management this feature.
    
    bitmap:
    -allowed: sw driver to enable & disable some feature when driver init.
    -suppored: the feature is supproed.
    -enabled: the feature is enabled.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <Ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 3ca3d1cd43d2..f9b254c8dad9 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -29,6 +29,26 @@
 #include "smu_v11_0.h"
 #include "atom.h"
 
+int smu_feature_init_dpm(struct smu_context *smu)
+{
+	struct smu_feature *feature = &smu->smu_feature;
+	int ret = 0;
+	uint32_t unallowed_feature_mask[SMU_FEATURE_MAX/32];
+
+	bitmap_fill(feature->allowed, SMU_FEATURE_MAX);
+
+	ret = smu_get_unallowed_feature_mask(smu, unallowed_feature_mask,
+					     SMU_FEATURE_MAX/32);
+	if (ret)
+		return ret;
+
+	bitmap_andnot(feature->allowed, feature->allowed,
+		      (unsigned long *)unallowed_feature_mask,
+		      feature->feature_num);
+
+	return ret;
+}
+
 static int smu_set_funcs(struct amdgpu_device *adev)
 {
 	struct smu_context *smu = &adev->smu;
@@ -133,6 +153,10 @@ static int smu_sw_init(void *handle)
 		return -EINVAL;
 
 	smu->pool_size = adev->pm.smu_prv_buffer_size;
+	smu->smu_feature.feature_num = SMU_FEATURE_MAX;
+	bitmap_zero(smu->smu_feature.supported, SMU_FEATURE_MAX);
+	bitmap_zero(smu->smu_feature.enabled, SMU_FEATURE_MAX);
+	bitmap_zero(smu->smu_feature.allowed, SMU_FEATURE_MAX);
 
 	ret = smu_init_microcode(smu);
 	if (ret) {
@@ -241,6 +265,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_feature_set_allowed_mask(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_read_pptable_from_vbios(smu);
 	if (ret)
 		return ret;
@@ -312,6 +340,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_feature_enable_all(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * Set min deep sleep dce fclk with bootup value from vbios via
 	 * SetMinDeepSleepDcefclk MSG.
@@ -413,6 +445,10 @@ static int smu_hw_init(void *handle)
 
 	mutex_lock(&smu->mutex);
 
+	ret = smu_feature_init_dpm(smu);
+	if (ret)
+		goto failed;
+
 	ret = smu_smc_table_hw_init(smu);
 	if (ret)
 		goto failed;

commit f6a6b9526cf0f4247ecc10d8634db8325640fa6e
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Mon Dec 24 18:17:15 2018 +0800

    drm/amd/powerplay: implement smu_run_afll_btc function
    
    Add smu_run_afll_btc function to send msg to smc to start run afll btc.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 773a388cc8fe..3ca3d1cd43d2 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -232,6 +232,7 @@ static int smu_fini_fb_allocations(struct smu_context *smu)
 
 	return 0;
 }
+
 static int smu_smc_table_hw_init(struct smu_context *smu)
 {
 	int ret;
@@ -306,6 +307,11 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/* issue RunAfllBtc msg */
+	ret = smu_run_afll_btc(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * Set min deep sleep dce fclk with bootup value from vbios via
 	 * SetMinDeepSleepDcefclk MSG.

commit 56c53ad6fe6c59469eda11caedc408b6e827864a
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Mon Dec 24 15:02:50 2018 +0800

    drm/amd/powerplay: implement smu_init_display for smu11
    
    Add smu_init_display function to send msg to smc to init display.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e4da464655f8..773a388cc8fe 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -236,6 +236,10 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 {
 	int ret;
 
+	ret = smu_init_display(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_read_pptable_from_vbios(smu);
 	if (ret)
 		return ret;

commit afba8282292940378632c61e1686f230fa5be655
Author: Likun Gao <Likun.Gao@amd.com>
Date:   Mon Dec 17 20:59:42 2018 +0800

    drm/amd/powerplay: update hw fini function to relase some memory
    
    Release memory of table_context->driver_pptable and
    table_context->ppt_information when smu hw fini.
    
    Signed-off-by: Likun Gao <Likun.Gao@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index c85316617951..e4da464655f8 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -434,11 +434,16 @@ static int smu_hw_fini(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
+	struct smu_table_context *table_context = &smu->smu_table;
 	int ret = 0;
 
 	if (adev->asic_type < CHIP_VEGA20)
 		return -EINVAL;
 
+	if (!table_context->driver_pptable)
+		return -EINVAL;
+	kfree(table_context->driver_pptable);
+
 	ret = smu_fini_fb_allocations(smu);
 	if (ret)
 		return ret;

commit 74e07f9d3b77034cd1546617afce1d014a68d1ca
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 18 20:23:17 2018 +0800

    drm/amd/powerplay: add vega20 pptable function file
    
    This patch adds the vega20_ppt.c to support ATOM_Vega20_POWERPLAYTABLE format
    for vega20 on smu11. It will be used to implement to asic specific pptable
    helpers.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Likun Gao <Likun.Gao@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 926d0f87a955..c85316617951 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -48,16 +48,11 @@ static int smu_early_init(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
-	int ret;
-
-	ret = smu_set_funcs(adev);
-	if (ret)
-		return ret;
 
 	smu->adev = adev;
 	mutex_init(&smu->mutex);
 
-	return 0;
+	return smu_set_funcs(adev);
 }
 
 int smu_get_atom_data_table(struct smu_context *smu, uint32_t table,

commit 0b51d9937845fb6e0639be2cbd31557c4a36e073
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Mon Dec 17 16:47:49 2018 +0800

    drm/amd/powerplay: implement smu_alloc[free]_memory pool function
    
    This patch implements smu_alloc[free]_memory pool function to reserve the memory
    pool bo.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f31b62813256..926d0f87a955 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -137,6 +137,8 @@ static int smu_sw_init(void *handle)
 	if (adev->asic_type < CHIP_VEGA20)
 		return -EINVAL;
 
+	smu->pool_size = adev->pm.smu_prv_buffer_size;
+
 	ret = smu_init_microcode(smu);
 	if (ret) {
 		pr_err("Failed to load smu firmware!\n");
@@ -333,9 +335,56 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
  */
 static int smu_alloc_memory_pool(struct smu_context *smu)
 {
-	return 0;
+	struct amdgpu_device *adev = smu->adev;
+	struct smu_table_context *smu_table = &smu->smu_table;
+	struct smu_table *memory_pool = &smu_table->memory_pool;
+	uint64_t pool_size = smu->pool_size;
+	int ret = 0;
+
+	if (pool_size == SMU_MEMORY_POOL_SIZE_ZERO)
+		return ret;
+
+	memory_pool->size = pool_size;
+	memory_pool->align = PAGE_SIZE;
+	memory_pool->domain = AMDGPU_GEM_DOMAIN_GTT;
+
+	switch (pool_size) {
+	case SMU_MEMORY_POOL_SIZE_256_MB:
+	case SMU_MEMORY_POOL_SIZE_512_MB:
+	case SMU_MEMORY_POOL_SIZE_1_GB:
+	case SMU_MEMORY_POOL_SIZE_2_GB:
+		ret = amdgpu_bo_create_kernel(adev,
+					      memory_pool->size,
+					      memory_pool->align,
+					      memory_pool->domain,
+					      &memory_pool->bo,
+					      &memory_pool->mc_address,
+					      &memory_pool->cpu_addr);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
 }
 
+static int smu_free_memory_pool(struct smu_context *smu)
+{
+	struct smu_table_context *smu_table = &smu->smu_table;
+	struct smu_table *memory_pool = &smu_table->memory_pool;
+	int ret = 0;
+
+	if (memory_pool->size == SMU_MEMORY_POOL_SIZE_ZERO)
+		return ret;
+
+	amdgpu_bo_free_kernel(&memory_pool->bo,
+			      &memory_pool->mc_address,
+			      &memory_pool->cpu_addr);
+
+	memset(memory_pool, 0, sizeof(struct smu_table));
+
+	return ret;
+}
 static int smu_hw_init(void *handle)
 {
 	int ret;
@@ -399,6 +448,10 @@ static int smu_hw_fini(void *handle)
 	if (ret)
 		return ret;
 
+	ret = smu_free_memory_pool(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 08115f87c38de82f82991a990e36806fa6f3057d
Author: Huang Rui <ray.huang@amd.com>
Date:   Mon Dec 17 14:56:40 2018 +0800

    drm/amd/powerplay: implement get_clk_info_from_vbios function for smu11 (v2)
    
    This patch implements the get_clk_info_from_vbios function for smu11.
    We can do execute_vbios_cmd_table to fetch the clk value from vbios.
    
    v2: use the proper cpu_to_le[32|16]() and le[32|16]_to_cpu() macros to handle
    endianness. (Alex)
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index ef377ef0e389..f31b62813256 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -248,10 +248,18 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	ret = smu_get_clk_info_from_vbios(smu);
+	if (ret)
+		return ret;
+
 	/*
 	 * check if the format_revision in vbios is up to pptable header
 	 * version, and the structure size is not 0.
 	 */
+	ret = smu_get_clk_info_from_vbios(smu);
+	if (ret)
+		return ret;
+
 	ret = smu_check_pptable(smu);
 	if (ret)
 		return ret;

commit f96357a991b965e9dc6882718c670c49945a89a8
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Fri Dec 14 18:34:20 2018 +0800

    drm/amd/powerplay: implement smu_init(fini)_fb_allocations function
    
    This patch implements smu_init_fb_allocations/smu_fini_fb_allocations function
    for smu to reserve the BOs for smc tables.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b275139ae96b..ef377ef0e389 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -178,10 +178,63 @@ static int smu_sw_fini(void *handle)
 
 static int smu_init_fb_allocations(struct smu_context *smu)
 {
-	/* TODO */
+	struct amdgpu_device *adev = smu->adev;
+	struct smu_table_context *smu_table = &smu->smu_table;
+	struct smu_table *tables = smu_table->tables;
+	uint32_t table_count = smu_table->table_count;
+	uint32_t i = 0;
+	int32_t ret = 0;
+
+	if (table_count <= 0)
+		return -EINVAL;
+
+	for (i = 0 ; i < table_count; i++) {
+		if (tables[i].size == 0)
+			continue;
+		ret = amdgpu_bo_create_kernel(adev,
+					      tables[i].size,
+					      tables[i].align,
+					      tables[i].domain,
+					      &tables[i].bo,
+					      &tables[i].mc_address,
+					      &tables[i].cpu_addr);
+		if (ret)
+			goto failed;
+	}
+
 	return 0;
+failed:
+	for (; i > 0; i--) {
+		if (tables[i].size == 0)
+			continue;
+		amdgpu_bo_free_kernel(&tables[i].bo,
+				      &tables[i].mc_address,
+				      &tables[i].cpu_addr);
+
+	}
+	return ret;
 }
 
+static int smu_fini_fb_allocations(struct smu_context *smu)
+{
+	struct smu_table_context *smu_table = &smu->smu_table;
+	struct smu_table *tables = smu_table->tables;
+	uint32_t table_count = smu_table->table_count;
+	uint32_t i = 0;
+
+	if (table_count == 0 || tables == NULL)
+		return -EINVAL;
+
+	for (i = 0 ; i < table_count; i++) {
+		if (tables[i].size == 0)
+			continue;
+		amdgpu_bo_free_kernel(&tables[i].bo,
+				      &tables[i].mc_address,
+				      &tables[i].cpu_addr);
+	}
+
+	return 0;
+}
 static int smu_smc_table_hw_init(struct smu_context *smu)
 {
 	int ret;
@@ -329,10 +382,15 @@ static int smu_hw_fini(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	struct smu_context *smu = &adev->smu;
+	int ret = 0;
 
 	if (adev->asic_type < CHIP_VEGA20)
 		return -EINVAL;
 
+	ret = smu_fini_fb_allocations(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 8bf16963df8c27787f12d7df88d4c88fe6d9aff1
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Sat Dec 15 10:50:03 2018 +0800

    drm/amd/powerplay: implement smu_init[fini]_power function for smu11
    
    This patch implements smu_init[fini]_power function for smu v11.
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index f79a125a91bc..b275139ae96b 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -167,6 +167,12 @@ static int smu_sw_fini(void *handle)
 		return ret;
 	}
 
+	ret = smu_fini_power(smu);
+	if (ret) {
+		pr_err("Failed to init smu_fini_power!\n");
+		return ret;
+	}
+
 	return 0;
 }
 

commit 813ce279448e7d5af183571b99d8ca7f605188b8
Author: Kevin Wang <Kevin1.Wang@amd.com>
Date:   Fri Dec 14 17:43:57 2018 +0800

    drm/amd/powerplay: implement smu_init[fini]_smc_tables for smu11
    
    Each SMU IP may have a different number of SMU tables, so these tables
    are allocated using dynamic memory
    
    Signed-off-by: Kevin Wang <Kevin1.Wang@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 901c99fea26f..f79a125a91bc 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -115,6 +115,19 @@ static int smu_smc_table_sw_init(struct smu_context *smu)
 	return 0;
 }
 
+static int smu_smc_table_sw_fini(struct smu_context *smu)
+{
+	int ret;
+
+	ret = smu_fini_smc_tables(smu);
+	if (ret) {
+		pr_err("Failed to smu_fini_smc_tables!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 static int smu_sw_init(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
@@ -142,10 +155,18 @@ static int smu_sw_init(void *handle)
 static int smu_sw_fini(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+	int ret;
 
 	if (adev->asic_type < CHIP_VEGA20)
 		return -EINVAL;
 
+	ret = smu_smc_table_sw_fini(smu);
+	if (ret) {
+		pr_err("Failed to sw fini smc table!\n");
+		return ret;
+	}
+
 	return 0;
 }
 

commit e15da5a4b08a94ef63630c85197dabd1c8a88b36
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Dec 12 21:06:59 2018 +0800

    drm/amd/powerplay: add get atom data table helper
    
    This patch adds get atom data table helper for smu future use.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Reviewed-by: Kevin Wang <Kevin1.Wang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index a6f19b525420..901c99fea26f 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -27,6 +27,7 @@
 #include "amdgpu_smu.h"
 #include "soc15_common.h"
 #include "smu_v11_0.h"
+#include "atom.h"
 
 static int smu_set_funcs(struct amdgpu_device *adev)
 {
@@ -59,6 +60,22 @@ static int smu_early_init(void *handle)
 	return 0;
 }
 
+int smu_get_atom_data_table(struct smu_context *smu, uint32_t table,
+			    uint16_t *size, uint8_t *frev, uint8_t *crev,
+			    uint8_t **addr)
+{
+	struct amdgpu_device *adev = smu->adev;
+	uint16_t data_start;
+
+	if (!amdgpu_atom_parse_data_header(adev->mode_info.atom_context, table,
+					   size, frev, crev, &data_start))
+		return -EINVAL;
+
+	*addr = (uint8_t *)adev->mode_info.atom_context->bios + data_start;
+
+	return 0;
+}
+
 static int smu_initialize_pptable(struct smu_context *smu)
 {
 	/* TODO */

commit fad3ecf2359b564fa6e3ef7e87f44dd17947ab82
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Dec 5 12:01:09 2018 +0800

    drm/amd/powerplay: add resume sequence placeholder for smu ip block
    
    This patch adds resume sequence placeholder for smu ip block.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index e0a5597cf6c4..a6f19b525420 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -311,13 +311,50 @@ static int smu_resume(void *handle)
 	if (adev->asic_type < CHIP_VEGA20)
 		return -EINVAL;
 
+	pr_info("SMU is resuming...\n");
+
+	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
+		ret = smu_load_microcode(smu);
+		if (ret)
+			return ret;
+	}
+
+	ret = smu_check_fw_status(smu);
+	if (ret) {
+		pr_err("SMC firmware status is not correct\n");
+		return ret;
+	}
+
 	mutex_lock(&smu->mutex);
 
-	/* TODO */
+	ret = smu_set_tool_table_location(smu);
+	if (ret)
+		goto failed;
+
+	ret = smu_write_pptable(smu);
+	if (ret)
+		goto failed;
+
+	ret = smu_write_watermarks_table(smu);
+	if (ret)
+		goto failed;
+
+	ret = smu_set_last_dcef_min_deep_sleep_clk(smu);
+	if (ret)
+		goto failed;
+
+	ret = smu_system_features_control(smu, true);
+	if (ret)
+		goto failed;
 
 	mutex_unlock(&smu->mutex);
 
+	pr_info("SMU is resumed successfully!\n");
+
 	return 0;
+failed:
+	mutex_unlock(&smu->mutex);
+	return ret;
 }
 
 static int smu_set_clockgating_state(void *handle,

commit c56de9e8287dab5c3e393fa30597c20cbf43533a
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Dec 5 11:45:34 2018 +0800

    drm/amd/powerplay: add interface to notify memory pool location (v2)
    
    This patch adds interface to notify memory pool location for smu.
    It's to use msg SetSystemVirtualDramAddr and DramLogSetDramAddr can notify pool
    location.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 4f61ee954ea7..e0a5597cf6c4 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -262,6 +262,14 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
+	/*
+	 * Use msg SetSystemVirtualDramAddr and DramLogSetDramAddr can notify
+	 * pool location.
+	 */
+	ret = smu_notify_memory_pool_location(smu);
+	if (ret)
+		goto failed;
+
 	mutex_unlock(&smu->mutex);
 
 	pr_info("SMU is initialized successfully!\n");

commit e65d45f2c73df8b7596d67c09bc3528a8968a99d
Author: Huang Rui <ray.huang@amd.com>
Date:   Wed Dec 5 11:41:33 2018 +0800

    drm/amd/powerplay: add interface to allocate memory pool (v2)
    
    This patch adds interface to allocate memory pool for smu.
    This memory pool will be used for SMC use and msg SetSystemVirtualDramAddr and
    DramLogSetDramAddr can notify it changed.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 87c46cf32293..4f61ee954ea7 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -216,6 +216,21 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	return ret;
 }
 
+/**
+ * smu_alloc_memory_pool - allocate memory pool in the system memory
+ *
+ * @smu: amdgpu_device pointer
+ *
+ * This memory pool will be used for SMC use and msg SetSystemVirtualDramAddr
+ * and DramLogSetDramAddr can notify it changed.
+ *
+ * Returns 0 on success, error on failure.
+ */
+static int smu_alloc_memory_pool(struct smu_context *smu)
+{
+	return 0;
+}
+
 static int smu_hw_init(void *handle)
 {
 	int ret;
@@ -243,6 +258,10 @@ static int smu_hw_init(void *handle)
 	if (ret)
 		goto failed;
 
+	ret = smu_alloc_memory_pool(smu);
+	if (ret)
+		goto failed;
+
 	mutex_unlock(&smu->mutex);
 
 	pr_info("SMU is initialized successfully!\n");

commit 206bc589ed497497d87699b406e195b7c7b51900
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 22:04:24 2018 +0800

    drm/amd/powerplay: add interface to set tool table location (v2)
    
    This patch adds interface to set tool table location for smu.
    Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 5e22b154fff1..87c46cf32293 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -208,7 +208,12 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
-	return 0;
+	/*
+	 * Set PMSTATUSLOG table bo address with SetToolsDramAddr MSG for tools.
+	 */
+	ret = smu_set_tool_table_location(smu);
+
+	return ret;
 }
 
 static int smu_hw_init(void *handle)

commit a7ebb6d2fde4d478f48036aaa92859eff36271ea
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 22:00:22 2018 +0800

    drm/amd/powerplay: add interface to set min dcef deep sleep (v2)
    
    This patch adds interface to set min dcef deep sleep for smu.
    It's to set min deep sleep dce fclk with bootup value from vbios via
    SetMinDeepSleepDcefclk MSG.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 747b6b7a7675..5e22b154fff1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -200,6 +200,14 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * Set min deep sleep dce fclk with bootup value from vbios via
+	 * SetMinDeepSleepDcefclk MSG.
+	 */
+	ret = smu_set_min_dcef_deep_sleep(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 31b5ae495d68fba85bf64fae6f173372d56131da
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 21:57:05 2018 +0800

    drm/amd/powerplay: add interface to write pptable (v2)
    
    This patch adds interface to write pptable for smu.
    It's to copy pptable bo in the vram to smc with SMU MSGs such as
    SetDriverDramAddr and TransferTableDram2Smu.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 519682541cae..747b6b7a7675 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -192,6 +192,14 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * Copy pptable bo in the vram to smc with SMU MSGs such as
+	 * SetDriverDramAddr and TransferTableDram2Smu.
+	 */
+	ret = smu_write_pptable(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit a751b095898294764a364e436d9ddb14ad727482
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 21:51:23 2018 +0800

    drm/amd/powerplay: add interface to check fw version (v2)
    
    This patch adds interface to check fw version for smu.
    It's to send msg GetDriverIfVersion to check if the return value is equal with
    DRIVER_IF_VERSION of smc header.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b40a3c15a1b3..519682541cae 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -184,6 +184,14 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * Send msg GetDriverIfVersion to check if the return value is equal
+	 * with DRIVER_IF_VERSION of smc header.
+	 */
+	ret = smu_check_fw_version(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 86187fec9151881dd2b8ef116d32acfa771dc1c1
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 21:42:41 2018 +0800

    drm/amd/powerplay: add interface to populate smc pptable (v2)
    
    This patch adds interface to populate smc pptable for smu.
    It's to set initialized values (get from vbios) to dpm tables context such as
    gfxclk, memclk, dcefclk, and etc. And enable the DPM feature for each type of
    clks.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 323db7dc47b1..b40a3c15a1b3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -175,6 +175,15 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * Set initialized values (get from vbios) to dpm tables context such as
+	 * gfxclk, memclk, dcefclk, and etc. And enable the DPM feature for each
+	 * type of clks.
+	 */
+	ret = smu_populate_smc_pptable(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 9e4848a4edd60d1f9f3bb556d6575d642690c79d
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 21:34:43 2018 +0800

    drm/amd/powerplay: add interface to parse pptable (v2)
    
    This patch adds interface to parse pptable for smu.
    It's to parse pptable format and fill PPTable_t smc_pptable to smu_table_context
    structure. And read the smc_dpm_table from vbios, then fill it into smc_pptable.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 931343c80978..323db7dc47b1 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -166,6 +166,15 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * Parse pptable format and fill PPTable_t smc_pptable to
+	 * smu_table_context structure. And read the smc_dpm_table from vbios,
+	 * then fill it into smc_pptable.
+	 */
+	ret = smu_parse_pptable(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 9c9a1747c2921015dd62d680c153af2c24a547b0
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 18:54:50 2018 +0800

    drm/amd/powerplay: add interface to init fb allocations (v2)
    
    This patch adds interface to init fb allocations for smu.
    It's to allocate vram bos to store smc table contents.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d7d40bfba7b0..931343c80978 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -132,6 +132,12 @@ static int smu_sw_fini(void *handle)
 	return 0;
 }
 
+static int smu_init_fb_allocations(struct smu_context *smu)
+{
+	/* TODO */
+	return 0;
+}
+
 static int smu_smc_table_hw_init(struct smu_context *smu)
 {
 	int ret;
@@ -153,6 +159,13 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * allocate vram bos to store smc table contents.
+	 */
+	ret = smu_init_fb_allocations(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 46126e6dad1cf3292bbae29c5fe321ca96d110fc
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 18:41:58 2018 +0800

    drm/amd/powerplay: add interface to check pptable (v2)
    
    This patch adds interface to check pptable function for smu.
    It's to check if the format_revision in vbios is up to pptable header version,
    and the structure size is not 0.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d022388f3993..d7d40bfba7b0 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -145,6 +145,14 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/*
+	 * check if the format_revision in vbios is up to pptable header
+	 * version, and the structure size is not 0.
+	 */
+	ret = smu_check_pptable(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit a6b35900dca9607cdd687a9886d3a4e6af0e4420
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 18:24:58 2018 +0800

    drm/amd/powerplay: add interface to get vbios bootup values (v2)
    
    This patch adds interface to get vbios bootup values for smu.
    It's to get boot_values from vbios to set revision, gfxclk, and etc.
    
    v2: add detailed info to describe this function.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 10316a2397da..d022388f3993 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -140,6 +140,11 @@ static int smu_smc_table_hw_init(struct smu_context *smu)
 	if (ret)
 		return ret;
 
+	/* get boot_values from vbios to set revision, gfxclk, and etc. */
+	ret = smu_get_vbios_bootup_values(smu);
+	if (ret)
+		return ret;
+
 	return 0;
 }
 

commit 17e6081bc19275f62b259f72457822310a1734c4
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 18:13:19 2018 +0800

    drm/amd/powerplay: add interface to init power (v2)
    
    This patch adds interface to init power function for smu.
    It's to create smu_power_context structure, and allocate smu_dpm_context and
    context size to fill the smu_power_context data.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 71da3dcd3db3..10316a2397da 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -85,6 +85,16 @@ static int smu_smc_table_sw_init(struct smu_context *smu)
 		return ret;
 	}
 
+	/**
+	 * Create smu_power_context structure, and allocate smu_dpm_context and
+	 * context size to fill the smu_power_context data.
+	 */
+	ret = smu_init_power(smu);
+	if (ret) {
+		pr_err("Failed to init smu_init_power!\n");
+		return ret;
+	}
+
 	return 0;
 }
 

commit cabd44c064c84064292508a58c97f4e9ad9a6409
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 17:42:08 2018 +0800

    drm/amd/powerplay: add interface to init smc tables (v2)
    
    This patch adds interface to init smc tables for smu. It is to create smu_table
    structure, and init smc tables such as TABLE_PPTABLE, TABLE_WATERMARKS,
    TABLE_SMU_METRICS, and etc.
    
    v2: add detailed info to describe this function
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index d6ecd6337ba4..71da3dcd3db3 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -75,6 +75,16 @@ static int smu_smc_table_sw_init(struct smu_context *smu)
 		return ret;
 	}
 
+	/**
+	 * Create smu_table structure, and init smc tables such as
+	 * TABLE_PPTABLE, TABLE_WATERMARKS, TABLE_SMU_METRICS, and etc.
+	 */
+	ret = smu_init_smc_tables(smu);
+	if (ret) {
+		pr_err("Failed to init smc tables!\n");
+		return ret;
+	}
+
 	return 0;
 }
 

commit b56240005f0cc1663ec290819497f85bd4367c62
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 17:27:10 2018 +0800

    drm/amd/powerplay: add placeholder of smu_initialize_pptable
    
    This patch adds placeholder of smu_initialize_pptable for smu.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 145435f05bc2..d6ecd6337ba4 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -59,6 +59,25 @@ static int smu_early_init(void *handle)
 	return 0;
 }
 
+static int smu_initialize_pptable(struct smu_context *smu)
+{
+	/* TODO */
+	return 0;
+}
+
+static int smu_smc_table_sw_init(struct smu_context *smu)
+{
+	int ret;
+
+	ret = smu_initialize_pptable(smu);
+	if (ret) {
+		pr_err("Failed to init smu_initialize_pptable!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
 static int smu_sw_init(void *handle)
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
@@ -74,6 +93,12 @@ static int smu_sw_init(void *handle)
 		return ret;
 	}
 
+	ret = smu_smc_table_sw_init(smu);
+	if (ret) {
+		pr_err("Failed to sw init smc table!\n");
+		return ret;
+	}
+
 	return 0;
 }
 

commit 05cadcd339dd06809684235daad5676a3687d108
Author: Huang Rui <ray.huang@amd.com>
Date:   Tue Dec 4 17:14:41 2018 +0800

    drm/amd/powerplay: add interface to read pptable from vbios
    
    This patch adds interface to read pptable from vbios for smu.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index b78125207b67..145435f05bc2 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -87,6 +87,17 @@ static int smu_sw_fini(void *handle)
 	return 0;
 }
 
+static int smu_smc_table_hw_init(struct smu_context *smu)
+{
+	int ret;
+
+	ret = smu_read_pptable_from_vbios(smu);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static int smu_hw_init(void *handle)
 {
 	int ret;
@@ -110,13 +121,19 @@ static int smu_hw_init(void *handle)
 
 	mutex_lock(&smu->mutex);
 
-	/* TODO */
+	ret = smu_smc_table_hw_init(smu);
+	if (ret)
+		goto failed;
 
 	mutex_unlock(&smu->mutex);
 
 	pr_info("SMU is initialized successfully!\n");
 
 	return 0;
+
+failed:
+	mutex_unlock(&smu->mutex);
+	return ret;
 }
 
 static int smu_hw_fini(void *handle)

commit e11c4fd578716882768e3008b1fd0a4ac6827a07
Author: Huang Rui <ray.huang@amd.com>
Date:   Sun Dec 2 18:25:00 2018 +0800

    drm/amd/powerplay: add fw load checking interface
    
    This patch adds fw load checking interface for smu.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index afdef545fbed..b78125207b67 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -102,6 +102,12 @@ static int smu_hw_init(void *handle)
 			return ret;
 	}
 
+	ret = smu_check_fw_status(smu);
+	if (ret) {
+		pr_err("SMC firmware status is not correct\n");
+		return ret;
+	}
+
 	mutex_lock(&smu->mutex);
 
 	/* TODO */

commit 3d2f5200a70282b8db5164ca1fe2028a0285e816
Author: Huang Rui <ray.huang@amd.com>
Date:   Sun Dec 2 18:12:10 2018 +0800

    drm/amd/powerplay: add firmware loading interface
    
    This patch adds firmware loading interface for smu.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 247cd63c4435..afdef545fbed 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -96,6 +96,12 @@ static int smu_hw_init(void *handle)
 	if (adev->asic_type < CHIP_VEGA20)
 		return -EINVAL;
 
+	if (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {
+		ret = smu_load_microcode(smu);
+		if (ret)
+			return ret;
+	}
+
 	mutex_lock(&smu->mutex);
 
 	/* TODO */

commit 0784552664ce1b2590796ba9187efce98edf4ca6
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Nov 29 14:01:47 2018 +0800

    drm/amd/powerplay: add smu11 sub block for SMU IP
    
    This patch add smu11 sub ip block skeleton as placeholder
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
index 291cc31a8496..247cd63c4435 100644
--- a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -26,9 +26,20 @@
 #include "amdgpu.h"
 #include "amdgpu_smu.h"
 #include "soc15_common.h"
+#include "smu_v11_0.h"
 
 static int smu_set_funcs(struct amdgpu_device *adev)
 {
+	struct smu_context *smu = &adev->smu;
+
+	switch (adev->asic_type) {
+	case CHIP_VEGA20:
+		smu_v11_0_set_smu_funcs(smu);
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -164,3 +175,12 @@ const struct amd_ip_funcs smu_ip_funcs = {
 	.set_clockgating_state = smu_set_clockgating_state,
 	.set_powergating_state = smu_set_powergating_state,
 };
+
+const struct amdgpu_ip_block_version smu_v11_0_ip_block =
+{
+	.type = AMD_IP_BLOCK_TYPE_SMC,
+	.major = 11,
+	.minor = 0,
+	.rev = 0,
+	.funcs = &smu_ip_funcs,
+};

commit 137d63abbf6a0859e79b662e81d21170ecb75e59
Author: Huang Rui <ray.huang@amd.com>
Date:   Thu Nov 29 13:56:06 2018 +0800

    drm/amd/powerplay: add new smu ip block
    
    This patch add amdgpu_smu ip block skeleton as placeholder.
    We plan use new smu ip block from Vega20.
    
    Signed-off-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
new file mode 100644
index 000000000000..291cc31a8496
--- /dev/null
+++ b/drivers/gpu/drm/amd/powerplay/amdgpu_smu.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2019 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "pp_debug.h"
+#include <linux/firmware.h>
+#include <drm/drmP.h>
+#include "amdgpu.h"
+#include "amdgpu_smu.h"
+#include "soc15_common.h"
+
+static int smu_set_funcs(struct amdgpu_device *adev)
+{
+	return 0;
+}
+
+static int smu_early_init(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+	int ret;
+
+	ret = smu_set_funcs(adev);
+	if (ret)
+		return ret;
+
+	smu->adev = adev;
+	mutex_init(&smu->mutex);
+
+	return 0;
+}
+
+static int smu_sw_init(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+	int ret;
+
+	if (adev->asic_type < CHIP_VEGA20)
+		return -EINVAL;
+
+	ret = smu_init_microcode(smu);
+	if (ret) {
+		pr_err("Failed to load smu firmware!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int smu_sw_fini(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->asic_type < CHIP_VEGA20)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int smu_hw_init(void *handle)
+{
+	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+
+	if (adev->asic_type < CHIP_VEGA20)
+		return -EINVAL;
+
+	mutex_lock(&smu->mutex);
+
+	/* TODO */
+
+	mutex_unlock(&smu->mutex);
+
+	pr_info("SMU is initialized successfully!\n");
+
+	return 0;
+}
+
+static int smu_hw_fini(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+
+	if (adev->asic_type < CHIP_VEGA20)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int smu_suspend(void *handle)
+{
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+
+	if (adev->asic_type < CHIP_VEGA20)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int smu_resume(void *handle)
+{
+	int ret;
+	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
+	struct smu_context *smu = &adev->smu;
+
+	if (adev->asic_type < CHIP_VEGA20)
+		return -EINVAL;
+
+	mutex_lock(&smu->mutex);
+
+	/* TODO */
+
+	mutex_unlock(&smu->mutex);
+
+	return 0;
+}
+
+static int smu_set_clockgating_state(void *handle,
+				     enum amd_clockgating_state state)
+{
+	return 0;
+}
+
+static int smu_set_powergating_state(void *handle,
+				     enum amd_powergating_state state)
+{
+	return 0;
+}
+
+const struct amd_ip_funcs smu_ip_funcs = {
+	.name = "smu",
+	.early_init = smu_early_init,
+	.late_init = NULL,
+	.sw_init = smu_sw_init,
+	.sw_fini = smu_sw_fini,
+	.hw_init = smu_hw_init,
+	.hw_fini = smu_hw_fini,
+	.suspend = smu_suspend,
+	.resume = smu_resume,
+	.is_idle = NULL,
+	.check_soft_reset = NULL,
+	.wait_for_idle = NULL,
+	.soft_reset = NULL,
+	.set_clockgating_state = smu_set_clockgating_state,
+	.set_powergating_state = smu_set_powergating_state,
+};
