commit 6eb3cf2e06d22b2b08e6b0ab48cb9c05a8e1a107
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Jun 29 13:03:52 2020 -0400

    drm/amd/display: Only revalidate bandwidth on medium and fast updates
    
    [Why]
    Changes that are fast don't require updating DLG parameters making
    this call unnecessary. Considering this is an expensive call it should
    not be done on every flip.
    
    DML touches clocks, p-state support, DLG params and a few other DC
    internal flags and these aren't expected during fast. A hang has been
    reported with this change when called on every flip which suggests that
    modifying these fields is not recommended behavior on fast updates.
    
    [How]
    Guard the validation to only happen if update type isn't FAST.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1191
    Fixes: a24eaa5c51255b ("drm/amd/display: Revalidate bandwidth before commiting DC updates")
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6f93a6ca4cf0..d016f50e187c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2538,10 +2538,12 @@ void dc_commit_updates_for_stream(struct dc *dc,
 
 	copy_stream_update_to_stream(dc, context, stream, stream_update);
 
-	if (!dc->res_pool->funcs->validate_bandwidth(dc, context, false)) {
-		DC_ERROR("Mode validation failed for stream update!\n");
-		dc_release_state(context);
-		return;
+	if (update_type > UPDATE_TYPE_FAST) {
+		if (!dc->res_pool->funcs->validate_bandwidth(dc, context, false)) {
+			DC_ERROR("Mode validation failed for stream update!\n");
+			dc_release_state(context);
+			return;
+		}
 	}
 
 	commit_planes_for_stream(

commit a24eaa5c51255b344d5a321f1eeb3205f2775498
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Jun 2 20:42:33 2020 -0400

    drm/amd/display: Revalidate bandwidth before commiting DC updates
    
    [Why]
    Whenever we switch between tiled formats without also switching pixel
    formats or doing anything else that recreates the DC plane state we
    can run into underflow or hangs since we're not updating the
    DML parameters before committing to the hardware.
    
    [How]
    If the update type is FULL then call validate_bandwidth again to update
    the DML parmeters before committing the state.
    
    This is basically just a workaround and protective measure against
    update types being added DC where we could run into this issue in
    the future.
    
    We can only fully validate the state in advance before applying it to
    the hardware if we recreate all the plane and stream states since
    we can't modify what's currently in use.
    
    The next step is to update DM to ensure that we're creating the plane
    and stream states for whatever could potentially be a full update in
    DC to pre-emptively recreate the state for DC global validation.
    
    The workaround can stay until this has been fixed in DM.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b4e2053bca9f..6f93a6ca4cf0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2538,6 +2538,12 @@ void dc_commit_updates_for_stream(struct dc *dc,
 
 	copy_stream_update_to_stream(dc, context, stream, stream_update);
 
+	if (!dc->res_pool->funcs->validate_bandwidth(dc, context, false)) {
+		DC_ERROR("Mode validation failed for stream update!\n");
+		dc_release_state(context);
+		return;
+	}
+
 	commit_planes_for_stream(
 				dc,
 				srf_updates,

commit b7f839d292948142eaab77cedd031aad0bfec872
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 2 17:22:48 2020 -0400

    drm/amdgpu/display: use blanked rather than plane state for sync groups
    
    We may end up with no planes set yet, depending on the ordering, but we
    should have the proper blanking state which is either handled by either
    DPG or TG depending on the hardware generation.  Check both to determine
    the proper blanked state.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/issues/781
    Fixes: 5fc0cbfad45648 ("drm/amd/display: determine if a pipe is synced by plane state")
    Cc: nicholas.kazlauskas@amd.com
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 45cfb7c45566..b4e2053bca9f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1016,9 +1016,17 @@ static void program_timing_sync(
 			}
 		}
 
-		/* set first pipe with plane as master */
+		/* set first unblanked pipe as master */
 		for (j = 0; j < group_size; j++) {
-			if (pipe_set[j]->plane_state) {
+			bool is_blanked;
+
+			if (pipe_set[j]->stream_res.opp->funcs->dpg_is_blanked)
+				is_blanked =
+					pipe_set[j]->stream_res.opp->funcs->dpg_is_blanked(pipe_set[j]->stream_res.opp);
+			else
+				is_blanked =
+					pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg);
+			if (!is_blanked) {
 				if (j == 0)
 					break;
 
@@ -1039,9 +1047,17 @@ static void program_timing_sync(
 				status->timing_sync_info.master = false;
 
 		}
-		/* remove any other pipes with plane as they have already been synced */
+		/* remove any other unblanked pipes as they have already been synced */
 		for (j = j + 1; j < group_size; j++) {
-			if (pipe_set[j]->plane_state) {
+			bool is_blanked;
+
+			if (pipe_set[j]->stream_res.opp->funcs->dpg_is_blanked)
+				is_blanked =
+					pipe_set[j]->stream_res.opp->funcs->dpg_is_blanked(pipe_set[j]->stream_res.opp);
+			else
+				is_blanked =
+					pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg);
+			if (!is_blanked) {
 				group_size--;
 				pipe_set[j] = pipe_set[group_size];
 				j--;

commit cdca3f218d9bbe086b0df9bc95b4f0c0d1011415
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Apr 21 22:01:58 2020 -0400

    drm/amd/display: move location of dmub_srv.h file
    
    [Why]
    Make a separation of what belongs in the differen dmub
    headers
    
    dmub_srv.h is for exposing dmub srv interface to rest of
    driver.
    
    other headers inside dmub/inc exposes cmds and definitions
    that are owned by the firmware
    
    [How]
    keep firmware owned definitions in dmub/inc
    
    move stuff that is purely driver interface headers to dmub/
    since those are interface calls that are defined for rest of
    driver to use
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0a12d13349c1..45cfb7c45566 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -66,7 +66,7 @@
 
 #include "dce/dce_i2c.h"
 
-#include "dmub/inc/dmub_cmd_dal.h"
+#include "dmub/dmub_srv.h"
 
 #define CTX \
 	dc->ctx

commit 5f6dbd54c05f38d30da9c1d310219808a69afd35
Author: Roman Li <roman.li@amd.com>
Date:   Wed Feb 26 17:30:29 2020 -0500

    drm/amd/display: fix counter in wait_for_no_pipes_pending
    
    [Why]
    Wait counter is not being reset for each pipe.
    
    [How]
    Move counter reset into pipe loop scope.
    
    Signed-off-by: Roman Li <roman.li@amd.com>
    Reviewed-by: Zhan Liu <Zhan.Liu@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f47acf30acd2..0a12d13349c1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -839,11 +839,10 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 static void wait_for_no_pipes_pending(struct dc *dc, struct dc_state *context)
 {
 	int i;
-	int count = 0;
-	struct pipe_ctx *pipe;
 	PERF_TRACE();
 	for (i = 0; i < MAX_PIPES; i++) {
-		pipe = &context->res_ctx.pipe_ctx[i];
+		int count = 0;
+		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 
 		if (!pipe->plane_state)
 			continue;

commit 3ba01817365c5a2c07a8be09117f3e22e16f5c80
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Sat Apr 18 19:22:55 2020 -0400

    drm/amd/display: Move panel_cntl specific register from abm to panel_cntl.
    
    [Why]
    panel_cntl specific register should be access in panel_cntl object.
    
    [How]
    Move these register access from abm to panel_cntl.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ad817bd74586..f47acf30acd2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2210,9 +2210,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 				if (should_program_abm) {
 					if (*stream_update->abm_level == ABM_LEVEL_IMMEDIATE_DISABLE) {
-						pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(
-								pipe_ctx->stream_res.abm,
-								pipe_ctx->stream->link->panel_cntl->inst);
+						dc->hwss.set_abm_immediate_disable(pipe_ctx);
 					} else {
 						pipe_ctx->stream_res.abm->funcs->set_abm_level(
 							pipe_ctx->stream_res.abm, stream->abm_level);

commit 18400f91c1c17777d98013ea15d620e7b4ac1cf4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Apr 22 18:07:59 2020 -0400

    drm/amd/display: Add panel cntl id for set backlight level.
    
    [Why & How]
    Add panel cntl instance when calling set backlight.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0f7810571be3..ad817bd74586 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2210,7 +2210,9 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 				if (should_program_abm) {
 					if (*stream_update->abm_level == ABM_LEVEL_IMMEDIATE_DISABLE) {
-						pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(pipe_ctx->stream_res.abm);
+						pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(
+								pipe_ctx->stream_res.abm,
+								pipe_ctx->stream->link->panel_cntl->inst);
 					} else {
 						pipe_ctx->stream_res.abm->funcs->set_abm_level(
 							pipe_ctx->stream_res.abm, stream->abm_level);

commit fefe92fe747ca74c6f127833188d4ff02d6f4e11
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Mar 27 18:23:16 2020 -0400

    drm/amd/display: make all backlight calls link based
    
    [Why]
    Backlight adjustment is tied to a specific display.  So make the calls
    target a link rather than making it a global state.
    
    [How]
    make all backlight calls link based
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d5ecf2031255..0f7810571be3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2646,33 +2646,12 @@ void dc_set_power_state(
 
 void dc_resume(struct dc *dc)
 {
-
 	uint32_t i;
 
 	for (i = 0; i < dc->link_count; i++)
 		core_link_resume(dc->links[i]);
 }
 
-unsigned int dc_get_current_backlight_pwm(struct dc *dc)
-{
-	struct abm *abm = dc->res_pool->abm;
-
-	if (abm)
-		return abm->funcs->get_current_backlight(abm);
-
-	return 0;
-}
-
-unsigned int dc_get_target_backlight_pwm(struct dc *dc)
-{
-	struct abm *abm = dc->res_pool->abm;
-
-	if (abm)
-		return abm->funcs->get_target_backlight(abm);
-
-	return 0;
-}
-
 bool dc_is_dmcu_initialized(struct dc *dc)
 {
 	struct dmcu *dmcu = dc->res_pool->dmcu;

commit a8665946f39aff519f363ebd7c1013c673cb31a1
Author: Wenjing Liu <wenjing.liu@amd.com>
Date:   Tue Mar 31 12:32:53 2020 -0400

    drm/amd/display: add optc get crc support for timings with ODM/DSC
    
    [why]
    Optc needs to know if timing is enabled with ODM or DSC before computing
    crc.  Otherwise value computed will be inaccurate. Before this change,
    the CRC computed without ODM is not equal to the CRC computed with ODM
    for the same timing. This is unexpected as we are driving the same
    timing despite of the underlaying hardware setup to achieve it. This is
    caused by missing hardware programming sequence to support it.
    
    [how]
    Add the new programming sequence based on hardware guide.
    
    Signed-off-by: Wenjing Liu <wenjing.liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9bde05547b30..d5ecf2031255 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -350,7 +350,7 @@ bool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
-		if (pipe->stream == stream)
+		if (pipe->stream == stream && !pipe->top_pipe && !pipe->prev_odm_pipe)
 			break;
 	}
 	/* Stream not found */
@@ -367,6 +367,9 @@ bool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,
 	param.windowb_x_end = pipe->stream->timing.h_addressable;
 	param.windowb_y_end = pipe->stream->timing.v_addressable;
 
+	param.dsc_mode = pipe->stream->timing.flags.DSC ? 1:0;
+	param.odm_mode = pipe->next_odm_pipe ? 1:0;
+
 	/* Default to the union of both windows */
 	param.selection = UNION_WINDOW_A_B;
 	param.continuous_mode = continuous;

commit d1ebfdd8d0fc30ff65b85a4bf3fa9e5e35006466
Author: Wyatt Wood <wyatt.wood@amd.com>
Date:   Tue Mar 31 09:31:16 2020 -0400

    drm/amd/display: Unify psr feature flags
    
    [Why]
    As it stands, psr has feature flags in dm, stream, and link. Most are
    not defined well enough, and different dm layers have different uses for
    these same flags.
    
    [How]
    We define a new structure called psr_settings in dc_link that will hold
    the following psr feature flags:
    
    psr_feature_enable - psr is supported
    psr_allow_active - psr is currently active
    psr_version - internal psr version supported
    psr_frame_capture_indication_req
    psr_sdp_transmit_line_num_deadline
    The last two flags were moved out of the power module
    for the purposes of consolidating psr flags.
    Their use is already well-defined.
    
    Psr caps reported by sink will also be stored in dc_link,
    in dpcd_caps.psr_caps.
    
    Signed-off-by: Wyatt Wood <wyatt.wood@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8489f1e56892..9bde05547b30 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -66,6 +66,8 @@
 
 #include "dce/dce_i2c.h"
 
+#include "dmub/inc/dmub_cmd_dal.h"
+
 #define CTX \
 	dc->ctx
 

commit 6fb4280ecbff9dd8a8db57bc9bfeef95c2b3a53f
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Sun Apr 5 16:41:11 2020 -0400

    drm/amd/display: Acknowledge wm_optimized_required
    
    [Why]
    If dc->clk_mgr->funcs->are_clock_states_equal is set, then
    wm_optimized_required is never checked. In that case, when going from a
    higher mode to a lower mode, wm_optimized_required remains true until
    the next mode change.
    
    [How]
     - move from else-if to unconditional or
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 512703eeaf82..8489f1e56892 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1861,8 +1861,9 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		// Else we fallback to mem compare.
 		} else if (memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0) {
 			dc->optimized_required = true;
-		} else if (dc->wm_optimized_required)
-			dc->optimized_required = true;
+		}
+
+		dc->optimized_required |= dc->wm_optimized_required;
 	}
 
 	return type;

commit bdfbff5ef46b99322476fefe7dfe51ac8fdb6173
Author: Isabel Zhang <isabel.zhang@amd.com>
Date:   Sun Apr 5 16:41:01 2020 -0400

    drm/amd/display: Update stream adjust in dc_stream_adjust_vmin_vmax
    
    [Why]
    After v_total_min and max are updated in vrr structure, the changes are
    not reflected in stream adjust. When these values are read from stream
    adjust it does not reflect the actual state of the system.
    
    [How]
    Set stream adjust values equal to vrr adjust values after vrr adjust
    values are updated.
    
    Signed-off-by: Isabel Zhang <isabel.zhang@amd.com>
    Reviewed-by: Alvin Lee <Alvin.Lee2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6379cf71d9d5..512703eeaf82 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -283,6 +283,8 @@ bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 	int i = 0;
 	bool ret = false;
 
+	stream->adjust = *adjust;
+
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 

commit 875390a86321c20f43ba5a3c8fec33a1b12322e4
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Sun Apr 5 16:40:57 2020 -0400

    drm/amd/display: Calculate scaling ratios on every medium/full update
    
    [Why]
    If a plane isn't being actively enabled or disabled then DC won't
    always recalculate scaling rects and ratios for the primary plane.
    
    This results in only a partial or corrupted rect being displayed on
    the screen instead of scaling to fit the screen.
    
    [How]
    Add back the logic to recalculate the scaling rects into
    dc_commit_updates_for_stream since this is the expected place to
    do it in DC.
    
    This was previously removed a few years ago to fix an underscan issue
    but underscan is still functional now with this change - and it should
    be, since this is only updating to the latest plane state getting passed
    in.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f21bbb295ad3..6379cf71d9d5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2462,7 +2462,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 	enum surface_update_type update_type;
 	struct dc_state *context;
 	struct dc_context *dc_ctx = dc->ctx;
-	int i;
+	int i, j;
 
 	stream_status = dc_stream_get_status(stream);
 	context = dc->current_state;
@@ -2500,6 +2500,17 @@ void dc_commit_updates_for_stream(struct dc *dc,
 
 		copy_surface_update_to_plane(surface, &srf_updates[i]);
 
+		if (update_type >= UPDATE_TYPE_MED) {
+			for (j = 0; j < dc->res_pool->pipe_count; j++) {
+				struct pipe_ctx *pipe_ctx =
+					&context->res_ctx.pipe_ctx[j];
+
+				if (pipe_ctx->plane_state != surface)
+					continue;
+
+				resource_build_scaling_params(pipe_ctx);
+			}
+		}
 	}
 
 	copy_stream_update_to_stream(dc, context, stream, stream_update);

commit 5c41c023f8b213d425af973a4dd83f5b9bc0bfb2
Author: Stylon Wang <stylon.wang@amd.com>
Date:   Tue Mar 10 15:09:29 2020 -0400

    drm/amd/display: Support plane level CTM
    
    [Why]
    CTM was only supported at CRTC level and we need color space conversion
    in linear space at plane level.
    
    [How]
    - Add plane-level CTM to dc interface
    - Program plane-level CTM in DCN
    
    Signed-off-by: Stylon Wang <stylon.wang@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1a2c2e3dd6d2..f21bbb295ad3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1726,6 +1726,9 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	if (u->coeff_reduction_factor)
 		update_flags->bits.coeff_reduction_change = 1;
 
+	if (u->gamut_remap_matrix)
+		update_flags->bits.gamut_remap_change = 1;
+
 	if (u->gamma) {
 		enum surface_pixel_format format = SURFACE_PIXEL_FORMAT_GRPH_BEGIN;
 
@@ -1751,7 +1754,8 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 
 	if (update_flags->bits.input_csc_change
 			|| update_flags->bits.coeff_reduction_change
-			|| update_flags->bits.gamma_change) {
+			|| update_flags->bits.gamma_change
+			|| update_flags->bits.gamut_remap_change) {
 		type = UPDATE_TYPE_FULL;
 		elevate_update_type(&overall_type, type);
 	}
@@ -1996,6 +2000,10 @@ static void copy_surface_update_to_plane(
 	if (srf_update->coeff_reduction_factor)
 		surface->coeff_reduction_factor =
 			*srf_update->coeff_reduction_factor;
+
+	if (srf_update->gamut_remap_matrix)
+		surface->gamut_remap_matrix =
+			*srf_update->gamut_remap_matrix;
 }
 
 static void copy_stream_update_to_stream(struct dc *dc,

commit 9941b8129030c9202aaf39114477a0e58c0d6ffc
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Mar 9 17:13:02 2020 -0400

    drm/amd/display: Not doing optimize bandwidth if flip pending.
    
    [Why]
    In some scenario like 1366x768 VSR enabled connected with a 4K monitor
    and playing 4K video in clone mode, underflow will be observed due to
    decrease dppclk when previouse surface scan isn't finished
    
    [How]
    In this use case, surface flip is switching between 4K and 1366x768,
    1366x768 needs smaller dppclk, and when decrease the clk and previous
    surface scan is for 4K and scan isn't done, underflow will happen.  Not
    doing optimize bandwidth in case of flip pending.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2ffb22177df9..1a2c2e3dd6d2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1360,6 +1360,26 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	return (result == DC_OK);
 }
 
+static bool is_flip_pending_in_pipes(struct dc *dc, struct dc_state *context)
+{
+	int i;
+	struct pipe_ctx *pipe;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe->plane_state)
+			continue;
+
+		/* Must set to false to start with, due to OR in update function */
+		pipe->plane_state->status.is_flip_pending = false;
+		dc->hwss.update_pending_status(pipe);
+		if (pipe->plane_state->status.is_flip_pending)
+			return true;
+	}
+	return false;
+}
+
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
@@ -1370,6 +1390,9 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	post_surface_trace(dc);
 
+	if (is_flip_pending_in_pipes(dc, context))
+		return true;
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL ||
 		    context->res_ctx.pipe_ctx[i].plane_state == NULL) {

commit 0aa63a333ddf39b180c789c995de5319122116a0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Mar 5 13:41:43 2020 -0500

    drm/amd/display: combine watermark change and clock change for update clocks.
    
    [Why]
    underflow happened when playing video on 1366x768 + 4K clone mode due to
    incorrect handle watermark change flag and lower down clocks to early.
    
    [How]
    Check watermark change flag when decide doing optimized, and check
    optimized required flag to do clock update.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 137180ad6a25..2ffb22177df9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1365,7 +1365,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct dc_state *context = dc->current_state;
 
-	if ((!dc->clk_optimized_required && !dc->wm_optimized_required) || dc->optimize_seamless_boot_streams > 0)
+	if ((!dc->optimized_required) || dc->optimize_seamless_boot_streams > 0)
 		return true;
 
 	post_surface_trace(dc);
@@ -1379,7 +1379,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	dc->hwss.optimize_bandwidth(dc, context);
 
-	dc->clk_optimized_required = false;
+	dc->optimized_required = false;
 	dc->wm_optimized_required = false;
 
 	return true;
@@ -1828,11 +1828,12 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		// If there's an available clock comparator, we use that.
 		if (dc->clk_mgr->funcs->are_clock_states_equal) {
 			if (!dc->clk_mgr->funcs->are_clock_states_equal(&dc->clk_mgr->clks, &dc->current_state->bw_ctx.bw.dcn.clk))
-				dc->clk_optimized_required = true;
+				dc->optimized_required = true;
 		// Else we fallback to mem compare.
 		} else if (memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0) {
-			dc->clk_optimized_required = true;
-		}
+			dc->optimized_required = true;
+		} else if (dc->wm_optimized_required)
+			dc->optimized_required = true;
 	}
 
 	return type;
@@ -2204,7 +2205,7 @@ static void commit_planes_for_stream(struct dc *dc,
 			dc->optimize_seamless_boot_streams--;
 
 			if (dc->optimize_seamless_boot_streams == 0)
-				dc->clk_optimized_required = true;
+				dc->optimized_required = true;
 		}
 	}
 

commit c803bb4eb90adb138bdc455bed337cbfe7343aea
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Mar 2 10:29:26 2020 -0500

    drm/amd/display: Pass triplebuffer surface flip flags down to plane state
    
    [Why]
    A "dcn20_program_front_end_for_ctx" warning is observed on Renoir.
    
    Since the resource definition doesn't explicitly disable triplebuffer
    flips like Navi10 DC actually attempts to go and setup triplebuffering
    even when we pass in false to the plane state.
    
    If we hit a full update after triplebuffering has been setup we see the
    assertion since we don't expect full updates while performing
    triplebuffer flips.
    
    Normally this would get reset back to false whne we pass in the new
    plane state, but since we never actually copy the flag when doing
    surface updates this doesn't happen.
    
    [How]
    Copy the flag onto the plane update based on the requested surface
    update state.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index df285f57fe92..137180ad6a25 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1871,6 +1871,8 @@ static void copy_surface_update_to_plane(
 		surface->time.index++;
 		if (surface->time.index >= DC_PLANE_UPDATE_TIMES_MAX)
 			surface->time.index = 0;
+
+		surface->triplebuffer_flips = srf_update->flip_addr->triplebuffer_flips;
 	}
 
 	if (srf_update->scaling_info) {

commit 4c631826e0bcfaefe580faeb4ef6651e5ebe57c1
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Feb 26 14:25:29 2020 -0500

    drm/amd/display: Not check wm and clk change flag in optimized bandwidth.
    
    [Why]
    System isn't able to enter S0i3 due to not send display count 0 to smu.
    When dpms off, clk changed flag is cleared alreay, and it is checked
    when doing optimized bandwidth, and update clocks is bypassed due to the
    flag is unset.
    
    [How]
    Remove check flag incide the function since watermark values and clocks
    values are checked during update to determine whether to perform it, no
    need to check it again outside the function.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6dece1ee30bf..df285f57fe92 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1378,6 +1378,10 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 		}
 
 	dc->hwss.optimize_bandwidth(dc, context);
+
+	dc->clk_optimized_required = false;
+	dc->wm_optimized_required = false;
+
 	return true;
 }
 

commit 89e94bc57429305e089f149a6e7083e5f36f39c4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Feb 14 12:55:55 2020 -0500

    drm/amd/display: optimize prgoram wm and clks
    
    [Why]
    In some display configuration like 1080P monitor playing a 1080P video,
    if user use ALT+F4 to exit Movie and TV, there is a chance clocks are
    same only water mark changed. Current clock optimization machanism will
    result in water mark keeps high after exit Movie and TV app.
    
    [How]
    Return if watermark need to be optimized when doing program watermark,
    perform the optimization after.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7513aa71da38..6dece1ee30bf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1365,7 +1365,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct dc_state *context = dc->current_state;
 
-	if (!dc->optimized_required || dc->optimize_seamless_boot_streams > 0)
+	if ((!dc->clk_optimized_required && !dc->wm_optimized_required) || dc->optimize_seamless_boot_streams > 0)
 		return true;
 
 	post_surface_trace(dc);
@@ -1377,8 +1377,6 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 			dc->hwss.disable_plane(dc, &context->res_ctx.pipe_ctx[i]);
 		}
 
-	dc->optimized_required = false;
-
 	dc->hwss.optimize_bandwidth(dc, context);
 	return true;
 }
@@ -1826,10 +1824,10 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		// If there's an available clock comparator, we use that.
 		if (dc->clk_mgr->funcs->are_clock_states_equal) {
 			if (!dc->clk_mgr->funcs->are_clock_states_equal(&dc->clk_mgr->clks, &dc->current_state->bw_ctx.bw.dcn.clk))
-				dc->optimized_required = true;
+				dc->clk_optimized_required = true;
 		// Else we fallback to mem compare.
 		} else if (memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0) {
-			dc->optimized_required = true;
+			dc->clk_optimized_required = true;
 		}
 	}
 
@@ -2200,7 +2198,7 @@ static void commit_planes_for_stream(struct dc *dc,
 			dc->optimize_seamless_boot_streams--;
 
 			if (dc->optimize_seamless_boot_streams == 0)
-				dc->optimized_required = true;
+				dc->clk_optimized_required = true;
 		}
 	}
 

commit 0136684f9b58b78fb2b8671e8eaa7bfc41330e0f
Author: Calvin Hou <Calvin.Hou@amd.com>
Date:   Mon Jan 27 14:40:41 2020 -0500

    drm/amd/display: Pass override OUI in to dc_init_data
    
    [WHY]
    Vendor dongle requires propietary OUI and handshake sequence.
    
    [HOW]
    Add a new structure to dc_init_data, to allow creator to pass
    an override vendor_oui. This value will be written to DP_SOURCE_OUI
    instead of AMD signature, when dpcd_set_source_specific_data is
    called.
    
    Signed-off-by: Calvin Hou <Calvin.Hou@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 40878b86a05d..7513aa71da38 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -701,7 +701,7 @@ static bool dc_construct(struct dc *dc,
 		dc_ctx->created_bios = true;
 	}
 
-
+	dc->vendor_signature = init_params->vendor_signature;
 
 	/* Create GPIO service */
 	dc_ctx->gpio_service = dal_gpio_service_create(

commit 71b81f1275e0b5713fae86004be72719a2fa73b7
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed Jan 22 11:54:54 2020 -0500

    drm/amd/display: decouple global lock out of pipe control lock
    
    [why]
    hwss should not guess what type of pipe lock is needed.
    The caller of the lock function should know
    the right type of pipe lock.
    Decouple the setup of global lock outside of pipe control lock
    logic.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7fdd82b7708a..40878b86a05d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2220,6 +2220,11 @@ static void commit_planes_for_stream(struct dc *dc,
 		}
 	}
 
+	if ((update_type != UPDATE_TYPE_FAST) && stream->update_flags.bits.dsc_changed)
+		if (top_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_enable)
+			top_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_enable(
+					top_pipe_to_program->stream_res.tg);
+
 	if ((update_type != UPDATE_TYPE_FAST) && dc->hwss.interdependent_update_lock)
 		dc->hwss.interdependent_update_lock(dc, context, true);
 	else
@@ -2377,6 +2382,21 @@ static void commit_planes_for_stream(struct dc *dc,
 	else
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 
+	if ((update_type != UPDATE_TYPE_FAST) && stream->update_flags.bits.dsc_changed)
+		if (top_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_enable) {
+			top_pipe_to_program->stream_res.tg->funcs->wait_for_state(
+					top_pipe_to_program->stream_res.tg,
+					CRTC_STATE_VACTIVE);
+			top_pipe_to_program->stream_res.tg->funcs->wait_for_state(
+					top_pipe_to_program->stream_res.tg,
+					CRTC_STATE_VBLANK);
+			top_pipe_to_program->stream_res.tg->funcs->wait_for_state(
+					top_pipe_to_program->stream_res.tg,
+					CRTC_STATE_VACTIVE);
+			top_pipe_to_program->stream_res.tg->funcs->lock_doublebuffer_disable(
+					top_pipe_to_program->stream_res.tg);
+		}
+
 	if (update_type != UPDATE_TYPE_FAST)
 		dc->hwss.post_unlock_program_front_end(dc, context);
 

commit 6409e2552ffc8784581820dd72730a64dda66743
Author: Roman Li <roman.li@amd.com>
Date:   Thu Jan 30 15:43:07 2020 -0500

    drm/amd/display: remove early break in interdependent_lock
    
    [Why]
    The break in apply_ctx_interdependent_lock() may potentially
    lead to early break from the loop leaving update plane unlocked
    
    [How]
    Remove break
    
    Signed-off-by: Roman Li <roman.li@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2208282ea6cb..7fdd82b7708a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -778,7 +778,6 @@ void apply_ctx_interdependent_lock(struct dc *dc, struct dc_state *context, stru
 				if (!pipe_ctx->top_pipe &&
 					(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
 					dc->hwss.pipe_control_lock(dc, pipe_ctx, lock);
-				break;
 			}
 		}
 	}

commit 009114f6df84150a567b05537aa29b9d660e419b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 17:04:24 2020 -0500

    drm/amd/display: Added locking for atomic update stream and update planes
    
    [Why]
    Screen flickering when HDR switches between FP16 and ARGB2101010
    
    [How]
    Moved pipe_control_lock so stream update and plane update occur atomically
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Lucy Li <lucy.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c9c7cf00976f..2208282ea6cb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -761,6 +761,29 @@ static bool disable_all_writeback_pipes_for_stream(
 	return true;
 }
 
+void apply_ctx_interdependent_lock(struct dc *dc, struct dc_state *context, struct dc_stream_state *stream, bool lock)
+{
+	int i = 0;
+
+	/* Checks if interdependent update function pointer is NULL or not, takes care of DCE110 case */
+	if (dc->hwss.interdependent_update_lock)
+		dc->hwss.interdependent_update_lock(dc, context, lock);
+	else {
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+			struct pipe_ctx *old_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+
+			// Copied conditions that were previously in dce110_apply_ctx_for_surface
+			if (stream == pipe_ctx->stream) {
+				if (!pipe_ctx->top_pipe &&
+					(pipe_ctx->plane_state || old_pipe_ctx->plane_state))
+					dc->hwss.pipe_control_lock(dc, pipe_ctx, lock);
+				break;
+			}
+		}
+	}
+}
+
 static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 {
 	int i, j;
@@ -786,12 +809,17 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 		if (should_disable && old_stream) {
 			dc_rem_all_planes_for_stream(dc, old_stream, dangling_context);
 			disable_all_writeback_pipes_for_stream(dc, old_stream, dangling_context);
+
 			if (dc->hwss.apply_ctx_for_surface) {
+				apply_ctx_interdependent_lock(dc, dc->current_state, old_stream, true);
 				dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
+				apply_ctx_interdependent_lock(dc, dc->current_state, old_stream, false);
 				dc->hwss.post_unlock_program_front_end(dc, dangling_context);
 			}
 			if (dc->hwss.program_front_end_for_ctx) {
+				dc->hwss.interdependent_update_lock(dc, dc->current_state, true);
 				dc->hwss.program_front_end_for_ctx(dc, dangling_context);
+				dc->hwss.interdependent_update_lock(dc, dc->current_state, false);
 				dc->hwss.post_unlock_program_front_end(dc, dangling_context);
 			}
 		}
@@ -1214,17 +1242,19 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use
 	 */
-	if (dc->hwss.apply_ctx_for_surface)
+	if (dc->hwss.apply_ctx_for_surface) {
 		for (i = 0; i < context->stream_count; i++) {
 			if (context->streams[i]->mode_changed)
 				continue;
-
+			apply_ctx_interdependent_lock(dc, context, context->streams[i], true);
 			dc->hwss.apply_ctx_for_surface(
 				dc, context->streams[i],
 				context->stream_status[i].plane_count,
 				context); /* use new pipe config in new context */
+			apply_ctx_interdependent_lock(dc, context, context->streams[i], false);
 			dc->hwss.post_unlock_program_front_end(dc, context);
 		}
+	}
 
 	/* Program hardware */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -1244,10 +1274,11 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	/* Program all planes within new context*/
 	if (dc->hwss.program_front_end_for_ctx) {
+		dc->hwss.interdependent_update_lock(dc, context, true);
 		dc->hwss.program_front_end_for_ctx(dc, context);
+		dc->hwss.interdependent_update_lock(dc, context, false);
 		dc->hwss.post_unlock_program_front_end(dc, context);
 	}
-
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_link *link = context->streams[i]->link;
 
@@ -1255,10 +1286,12 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 			continue;
 
 		if (dc->hwss.apply_ctx_for_surface) {
+			apply_ctx_interdependent_lock(dc, context, context->streams[i], true);
 			dc->hwss.apply_ctx_for_surface(
 					dc, context->streams[i],
 					context->stream_status[i].plane_count,
 					context);
+			apply_ctx_interdependent_lock(dc, context, context->streams[i], false);
 			dc->hwss.post_unlock_program_front_end(dc, context);
 		}
 
@@ -2105,15 +2138,10 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-			if (stream_update->dsc_config && dc->hwss.pipe_control_lock_global) {
-				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
+			if (stream_update->dsc_config)
 				dp_update_dsc_config(pipe_ctx);
-				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
-			}
 
 			if (stream_update->dpms_off) {
-				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
-
 				if (*stream_update->dpms_off) {
 					core_link_disable_stream(pipe_ctx);
 					/* for dpms, keep acquired resources*/
@@ -2127,8 +2155,6 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 					core_link_enable_stream(dc->current_state, pipe_ctx);
 				}
-
-				dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
 			}
 
 			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
@@ -2184,6 +2210,27 @@ static void commit_planes_for_stream(struct dc *dc,
 		context_clock_trace(dc, context);
 	}
 
+	for (j = 0; j < dc->res_pool->pipe_count; j++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+		if (!pipe_ctx->top_pipe &&
+			!pipe_ctx->prev_odm_pipe &&
+			pipe_ctx->stream &&
+			pipe_ctx->stream == stream) {
+			top_pipe_to_program = pipe_ctx;
+		}
+	}
+
+	if ((update_type != UPDATE_TYPE_FAST) && dc->hwss.interdependent_update_lock)
+		dc->hwss.interdependent_update_lock(dc, context, true);
+	else
+		/* Lock the top pipe while updating plane addrs, since freesync requires
+		 *  plane addr update event triggers to be synchronized.
+		 *  top_pipe_to_program is expected to never be NULL
+		 */
+		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);
+
+
 	// Stream updates
 	if (stream_update)
 		commit_planes_do_stream_update(dc, stream, stream_update, update_type, context);
@@ -2198,6 +2245,11 @@ static void commit_planes_for_stream(struct dc *dc,
 		if (dc->hwss.program_front_end_for_ctx)
 			dc->hwss.program_front_end_for_ctx(dc, context);
 
+		if ((update_type != UPDATE_TYPE_FAST) && dc->hwss.interdependent_update_lock)
+			dc->hwss.interdependent_update_lock(dc, context, false);
+		else
+			dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
+
 		dc->hwss.post_unlock_program_front_end(dc, context);
 		return;
 	}
@@ -2234,8 +2286,6 @@ static void commit_planes_for_stream(struct dc *dc,
 			pipe_ctx->stream == stream) {
 			struct dc_stream_status *stream_status = NULL;
 
-			top_pipe_to_program = pipe_ctx;
-
 			if (!pipe_ctx->plane_state)
 				continue;
 
@@ -2280,12 +2330,6 @@ static void commit_planes_for_stream(struct dc *dc,
 
 	// Update Type FAST, Surface updates
 	if (update_type == UPDATE_TYPE_FAST) {
-		/* Lock the top pipe while updating plane addrs, since freesync requires
-		 *  plane addr update event triggers to be synchronized.
-		 *  top_pipe_to_program is expected to never be NULL
-		 */
-		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);
-
 		if (dc->hwss.set_flip_control_gsl)
 			for (i = 0; i < surface_count; i++) {
 				struct dc_plane_state *plane_state = srf_updates[i].surface;
@@ -2327,9 +2371,12 @@ static void commit_planes_for_stream(struct dc *dc,
 					dc->hwss.update_plane_addr(dc, pipe_ctx);
 			}
 		}
+	}
 
+	if ((update_type != UPDATE_TYPE_FAST) && dc->hwss.interdependent_update_lock)
+		dc->hwss.interdependent_update_lock(dc, context, false);
+	else
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
-	}
 
 	if (update_type != UPDATE_TYPE_FAST)
 		dc->hwss.post_unlock_program_front_end(dc, context);

commit acdac228c4d1b9ff8ac778835719d3381c198aad
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 17:02:09 2020 -0500

    drm/amd/display: Indicate dsc updates explicitly
    
    [Why]
    DSC updates only set type to FULL UPDATE, but doesn't
    flag the change
    
    [How]
    Add DSC flag update flag
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 738ba91220df..c9c7cf00976f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1738,14 +1738,15 @@ static enum surface_update_type check_update_surfaces_for_stream(
 
 		if (stream_update->wb_update)
 			su_flags->bits.wb_update = 1;
+
+		if (stream_update->dsc_config)
+			su_flags->bits.dsc_changed = 1;
+
 		if (su_flags->raw != 0)
 			overall_type = UPDATE_TYPE_FULL;
 
 		if (stream_update->output_csc_transform || stream_update->output_color_space)
 			su_flags->bits.out_csc = 1;
-
-		if (stream_update->dsc_config)
-			overall_type = UPDATE_TYPE_FULL;
 	}
 
 	for (i = 0 ; i < surface_count; i++) {
@@ -1780,8 +1781,11 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 	type = check_update_surfaces_for_stream(dc, updates, surface_count, stream_update, stream_status);
 	if (type == UPDATE_TYPE_FULL) {
-		if (stream_update)
+		if (stream_update) {
+			uint32_t dsc_changed = stream_update->stream->update_flags.bits.dsc_changed;
 			stream_update->stream->update_flags.raw = 0xFFFFFFFF;
+			stream_update->stream->update_flags.bits.dsc_changed = dsc_changed;
+		}
 		for (i = 0; i < surface_count; i++)
 			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
 	}
@@ -2097,14 +2101,15 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				}
 			}
 
+			/* Full fe update*/
+			if (update_type == UPDATE_TYPE_FAST)
+				continue;
+
 			if (stream_update->dsc_config && dc->hwss.pipe_control_lock_global) {
 				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
 				dp_update_dsc_config(pipe_ctx);
 				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
 			}
-			/* Full fe update*/
-			if (update_type == UPDATE_TYPE_FAST)
-				continue;
 
 			if (stream_update->dpms_off) {
 				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);

commit bbf5f6c3f83bedd71006473849138a446ad4d9a3
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 14 16:23:31 2020 -0500

    drm/amd/display: Split program front end part that occur outside lock
    
    [Why]
    Eventually want to lock at a higher level in stack.
    To do this, we need to be able to isolate the parts that need to be done
    after pipe unlock.
    
    [How]
    Split out programming that is done post unlock.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 073172e53b5b..738ba91220df 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -786,11 +786,15 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 		if (should_disable && old_stream) {
 			dc_rem_all_planes_for_stream(dc, old_stream, dangling_context);
 			disable_all_writeback_pipes_for_stream(dc, old_stream, dangling_context);
-			if (dc->hwss.apply_ctx_for_surface)
+			if (dc->hwss.apply_ctx_for_surface) {
 				dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
+				dc->hwss.post_unlock_program_front_end(dc, dangling_context);
+			}
+			if (dc->hwss.program_front_end_for_ctx) {
+				dc->hwss.program_front_end_for_ctx(dc, dangling_context);
+				dc->hwss.post_unlock_program_front_end(dc, dangling_context);
+			}
 		}
-		if (dc->hwss.program_front_end_for_ctx)
-			dc->hwss.program_front_end_for_ctx(dc, dangling_context);
 	}
 
 	current_ctx = dc->current_state;
@@ -1219,6 +1223,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				dc, context->streams[i],
 				context->stream_status[i].plane_count,
 				context); /* use new pipe config in new context */
+			dc->hwss.post_unlock_program_front_end(dc, context);
 		}
 
 	/* Program hardware */
@@ -1238,19 +1243,24 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	}
 
 	/* Program all planes within new context*/
-	if (dc->hwss.program_front_end_for_ctx)
+	if (dc->hwss.program_front_end_for_ctx) {
 		dc->hwss.program_front_end_for_ctx(dc, context);
+		dc->hwss.post_unlock_program_front_end(dc, context);
+	}
+
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_link *link = context->streams[i]->link;
 
 		if (!context->streams[i]->mode_changed)
 			continue;
 
-		if (dc->hwss.apply_ctx_for_surface)
+		if (dc->hwss.apply_ctx_for_surface) {
 			dc->hwss.apply_ctx_for_surface(
 					dc, context->streams[i],
 					context->stream_status[i].plane_count,
 					context);
+			dc->hwss.post_unlock_program_front_end(dc, context);
+		}
 
 		/*
 		 * enable stereo
@@ -2183,6 +2193,7 @@ static void commit_planes_for_stream(struct dc *dc,
 		if (dc->hwss.program_front_end_for_ctx)
 			dc->hwss.program_front_end_for_ctx(dc, context);
 
+		dc->hwss.post_unlock_program_front_end(dc, context);
 		return;
 	}
 
@@ -2315,6 +2326,9 @@ static void commit_planes_for_stream(struct dc *dc,
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 	}
 
+	if (update_type != UPDATE_TYPE_FAST)
+		dc->hwss.post_unlock_program_front_end(dc, context);
+
 	// Fire manual trigger only when bottom plane is flipped
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];

commit e2d533eceb1feb0b8b965c3ff11184921532a28e
Author: Joseph Gravenor <joseph.gravenor@amd.com>
Date:   Wed Jan 15 13:27:06 2020 -0500

    drm/amd/display: remove invalid dc_is_hw_initialized function
    
    [why/how]
    We found out that the register we read actually gets reset by SMU
    after we loose power, meaning this always returns true
    
    Signed-off-by: Joseph Gravenor <joseph.gravenor@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 04441dbcba76..073172e53b5b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1318,12 +1318,6 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	return (result == DC_OK);
 }
 
-bool dc_is_hw_initialized(struct dc *dc)
-{
-	struct dc_bios *dcb = dc->ctx->dc_bios;
-	return dcb->funcs->is_accelerated_mode(dcb);
-}
-
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;

commit bb67bfd2e7101bf2ac5327b0b7a847cd9fb9723f
Author: Dor Askayo <dor.askayo@gmail.com>
Date:   Sat Jan 4 14:22:15 2020 +0200

    drm/amd/display: do not allocate display_mode_lib unnecessarily
    
    This allocation isn't required and can fail when resuming from suspend.
    
    Bug: https://gitlab.freedesktop.org/drm/amd/issues/1009
    Signed-off-by: Dor Askayo <dor.askayo@gmail.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6c797fac189d..04441dbcba76 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2462,12 +2462,7 @@ void dc_set_power_state(
 	enum dc_acpi_cm_power_state power_state)
 {
 	struct kref refcount;
-	struct display_mode_lib *dml = kzalloc(sizeof(struct display_mode_lib),
-						GFP_KERNEL);
-
-	ASSERT(dml);
-	if (!dml)
-		return;
+	struct display_mode_lib *dml;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
@@ -2490,6 +2485,12 @@ void dc_set_power_state(
 		 * clean state, and dc hw programming optimizations will not
 		 * cause any trouble.
 		 */
+		dml = kzalloc(sizeof(struct display_mode_lib),
+				GFP_KERNEL);
+
+		ASSERT(dml);
+		if (!dml)
+			return;
 
 		/* Preserve refcount */
 		refcount = dc->current_state->refcount;
@@ -2503,10 +2504,10 @@ void dc_set_power_state(
 		dc->current_state->refcount = refcount;
 		dc->current_state->bw_ctx.dml = *dml;
 
+		kfree(dml);
+
 		break;
 	}
-
-	kfree(dml);
 }
 
 void dc_resume(struct dc *dc)

commit 5b5abe9526073ccbf3032d27b5864520829cdd9c
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Dec 9 17:26:34 2019 -0500

    drm/amd/display: make PSR static screen entry within 30 ms
    
    [Why]
    With different refresh rate panels, the PSR entry/exit time is
    different since it is dependent on 2 frame entry time today
    
    [How]
    Make static screen num frame entry time to be calculated
    such that entry time is within 30 ms instead of fixed num
    frames.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c918a0cd8c60..6c797fac189d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -510,10 +510,10 @@ bool dc_stream_program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 	return ret;
 }
 
-void dc_stream_set_static_screen_events(struct dc *dc,
+void dc_stream_set_static_screen_params(struct dc *dc,
 		struct dc_stream_state **streams,
 		int num_streams,
-		const struct dc_static_screen_events *events)
+		const struct dc_static_screen_params *params)
 {
 	int i = 0;
 	int j = 0;
@@ -532,7 +532,7 @@ void dc_stream_set_static_screen_events(struct dc *dc,
 		}
 	}
 
-	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
+	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, params);
 }
 
 static void dc_destruct(struct dc *dc)

commit 09178aaa2311cbef76c72dad4a0da165945fe75e
Author: Joseph Gravenor <joseph.gravenor@amd.com>
Date:   Thu Dec 12 15:40:50 2019 -0500

    drm/amd/display: stop doing unnecessary detection when going to D3
    
    [Why]
    Don't want to start HW discovery unless we have lost power,
    as doing rediscovery otherwise is both unnecessary and time consuming.
    Before this change it takes 40 seconds to go in to suspend, after it
    takes 27 seconds
    
    [How]
    Accelerated mode gets cleared if we lose power. Only do detection if
    this register is cleared
    
    Signed-off-by: Joseph Gravenor <joseph.gravenor@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 46f2b54c3526..c918a0cd8c60 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1318,6 +1318,12 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	return (result == DC_OK);
 }
 
+bool dc_is_hw_initialized(struct dc *dc)
+{
+	struct dc_bios *dcb = dc->ctx->dc_bios;
+	return dcb->funcs->is_accelerated_mode(dcb);
+}
+
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;

commit 1075735ecce96b34ba9aee529dd2253da6d21ceb
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Thu Dec 5 17:12:17 2019 -0500

    drm/amd/display: Fix 300Hz Freesync bug
    
    Needed to reprogram vblank_start in dml properly in order to get the
    correct dlg params to program VTG.
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Martin Leung <Martin.Leung@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3d89904003f0..46f2b54c3526 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -287,7 +287,6 @@ bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 		struct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.tg) {
-			pipe->stream->adjust = *adjust;
 			dc->hwss.set_drr(&pipe,
 					1,
 					adjust->v_total_min,

commit 68c0fca5e45a1fd1262e70d89857e2ede1995f6b
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Nov 25 10:58:44 2019 -0500

    drm/amd/display: support virtual DCN
    
    [why]
    DAL3 should support SRIOV
    
    [how]
    Add support for the virtual dal flag.  This flag should skip
    most/all of DC construction since the HW isn't accessible, but
    still construct WindowsDM (almost) normally but with only SW display
    targets
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c13480685853..3d89904003f0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -582,6 +582,40 @@ static void dc_destruct(struct dc *dc)
 
 }
 
+static bool dc_construct_ctx(struct dc *dc,
+		const struct dc_init_data *init_params)
+{
+	struct dc_context *dc_ctx;
+	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
+
+	dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
+	if (!dc_ctx)
+		return false;
+
+	dc_ctx->cgs_device = init_params->cgs_device;
+	dc_ctx->driver_context = init_params->driver;
+	dc_ctx->dc = dc;
+	dc_ctx->asic_id = init_params->asic_id;
+	dc_ctx->dc_sink_id_count = 0;
+	dc_ctx->dc_stream_id_count = 0;
+	dc_ctx->dce_environment = init_params->dce_environment;
+
+	/* Create logger */
+
+	dc_version = resource_parse_asic_id(init_params->asic_id);
+	dc_ctx->dce_version = dc_version;
+
+	dc_ctx->perf_trace = dc_perf_trace_create();
+	if (!dc_ctx->perf_trace) {
+		ASSERT_CRITICAL(false);
+		return false;
+	}
+
+	dc->ctx = dc_ctx;
+
+	return true;
+}
+
 static bool dc_construct(struct dc *dc,
 		const struct dc_init_data *init_params)
 {
@@ -593,7 +627,6 @@ static bool dc_construct(struct dc *dc,
 	struct dcn_ip_params *dcn_ip;
 #endif
 
-	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 	dc->config = init_params->flags;
 
 	// Allocate memory for the vm_helper
@@ -639,26 +672,12 @@ static bool dc_construct(struct dc *dc,
 	dc->soc_bounding_box = init_params->soc_bounding_box;
 #endif
 
-	dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
-	if (!dc_ctx) {
+	if (!dc_construct_ctx(dc, init_params)) {
 		dm_error("%s: failed to create ctx\n", __func__);
 		goto fail;
 	}
 
-	dc_ctx->cgs_device = init_params->cgs_device;
-	dc_ctx->driver_context = init_params->driver;
-	dc_ctx->dc = dc;
-	dc_ctx->asic_id = init_params->asic_id;
-	dc_ctx->dc_sink_id_count = 0;
-	dc_ctx->dc_stream_id_count = 0;
-	dc->ctx = dc_ctx;
-
-	/* Create logger */
-
-	dc_ctx->dce_environment = init_params->dce_environment;
-
-	dc_version = resource_parse_asic_id(init_params->asic_id);
-	dc_ctx->dce_version = dc_version;
+        dc_ctx = dc->ctx;
 
 	/* Resource should construct all asic specific resources.
 	 * This should be the only place where we need to parse the asic id
@@ -673,7 +692,7 @@ static bool dc_construct(struct dc *dc,
 		bp_init_data.bios = init_params->asic_id.atombios_base_address;
 
 		dc_ctx->dc_bios = dal_bios_parser_create(
-				&bp_init_data, dc_version);
+				&bp_init_data, dc_ctx->dce_version);
 
 		if (!dc_ctx->dc_bios) {
 			ASSERT_CRITICAL(false);
@@ -681,17 +700,13 @@ static bool dc_construct(struct dc *dc,
 		}
 
 		dc_ctx->created_bios = true;
-		}
-
-	dc_ctx->perf_trace = dc_perf_trace_create();
-	if (!dc_ctx->perf_trace) {
-		ASSERT_CRITICAL(false);
-		goto fail;
 	}
 
+
+
 	/* Create GPIO service */
 	dc_ctx->gpio_service = dal_gpio_service_create(
-			dc_version,
+			dc_ctx->dce_version,
 			dc_ctx->dce_environment,
 			dc_ctx);
 
@@ -700,7 +715,7 @@ static bool dc_construct(struct dc *dc,
 		goto fail;
 	}
 
-	dc->res_pool = dc_create_resource_pool(dc, init_params, dc_version);
+	dc->res_pool = dc_create_resource_pool(dc, init_params, dc_ctx->dce_version);
 	if (!dc->res_pool)
 		goto fail;
 
@@ -731,8 +746,6 @@ static bool dc_construct(struct dc *dc,
 	return true;
 
 fail:
-
-	dc_destruct(dc);
 	return false;
 }
 
@@ -825,29 +838,38 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	if (NULL == dc)
 		goto alloc_fail;
 
-	if (false == dc_construct(dc, init_params))
-		goto construct_fail;
+	if (init_params->dce_environment == DCE_ENV_VIRTUAL_HW) {
+		if (false == dc_construct_ctx(dc, init_params)) {
+			dc_destruct(dc);
+			goto construct_fail;
+		}
+	} else {
+		if (false == dc_construct(dc, init_params)) {
+			dc_destruct(dc);
+			goto construct_fail;
+		}
+
+		full_pipe_count = dc->res_pool->pipe_count;
+		if (dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
+			full_pipe_count--;
+		dc->caps.max_streams = min(
+				full_pipe_count,
+				dc->res_pool->stream_enc_count);
 
-	full_pipe_count = dc->res_pool->pipe_count;
-	if (dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
-		full_pipe_count--;
-	dc->caps.max_streams = min(
-			full_pipe_count,
-			dc->res_pool->stream_enc_count);
+		dc->optimize_seamless_boot_streams = 0;
+		dc->caps.max_links = dc->link_count;
+		dc->caps.max_audios = dc->res_pool->audio_count;
+		dc->caps.linear_pitch_alignment = 64;
 
-	dc->optimize_seamless_boot_streams = 0;
-	dc->caps.max_links = dc->link_count;
-	dc->caps.max_audios = dc->res_pool->audio_count;
-	dc->caps.linear_pitch_alignment = 64;
+		dc->caps.max_dp_protocol_version = DP_VERSION_1_4;
 
-	dc->caps.max_dp_protocol_version = DP_VERSION_1_4;
+		if (dc->res_pool->dmcu != NULL)
+			dc->versions.dmcu_version = dc->res_pool->dmcu->dmcu_version;
+	}
 
 	/* Populate versioning information */
 	dc->versions.dc_ver = DC_VER;
 
-	if (dc->res_pool->dmcu != NULL)
-		dc->versions.dmcu_version = dc->res_pool->dmcu->dmcu_version;
-
 	dc->build_id = DC_BUILD_ID;
 
 	DC_LOG_DC("Display Core initialized\n");
@@ -865,7 +887,8 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 void dc_hardware_init(struct dc *dc)
 {
-	dc->hwss.init_hw(dc);
+	if (dc->ctx->dce_environment != DCE_ENV_VIRTUAL_HW)
+		dc->hwss.init_hw(dc);
 }
 
 void dc_init_callbacks(struct dc *dc,

commit 8d5bc3a5b8fec50ff175cf59a411723ae98b8317
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Sun Nov 24 19:11:15 2019 -0500

    drm/amd/display: scaling changes should also be a full update
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2cb31f403b74..c13480685853 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1577,7 +1577,7 @@ static enum surface_update_type get_scaling_info_update_type(
 
 		update_flags->bits.scaling_change = 1;
 		if (u->scaling_info->src_rect.width > u->surface->src_rect.width
-				&& u->scaling_info->src_rect.height > u->surface->src_rect.height)
+				|| u->scaling_info->src_rect.height > u->surface->src_rect.height)
 			/* Making src rect bigger requires a bandwidth change */
 			update_flags->bits.clock_change = 1;
 	}
@@ -1591,11 +1591,11 @@ static enum surface_update_type get_scaling_info_update_type(
 		update_flags->bits.position_change = 1;
 
 	if (update_flags->bits.clock_change
-			|| update_flags->bits.bandwidth_change)
+			|| update_flags->bits.bandwidth_change
+			|| update_flags->bits.scaling_change)
 		return UPDATE_TYPE_FULL;
 
-	if (update_flags->bits.scaling_change
-			|| update_flags->bits.position_change)
+	if (update_flags->bits.position_change)
 		return UPDATE_TYPE_MED;
 
 	return UPDATE_TYPE_FAST;

commit ccce745c28d6cc7b42a50933fe4b751da0257598
Author: Martin Leung <martin.leung@amd.com>
Date:   Thu Nov 21 19:13:54 2019 -0500

    drm/amd/display: Enable Seamless Boot Transition for Multiple Streams
    
    [why]
    dc previously had bugs that interfered with the ability to inherit a
    timing from a device with multiple streams (without flash/blanking).
    After this fix there is still a dependency on UEFI support.
    
    [how]
    fixed 3 bugs: loaded MPC state, changed bw_optimize flag to a counter
    instead of a boolean, and reading dpp/disp clk from HW to ensure we
    don't raise the clock's when we're not supposed to.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 879cedd79d9e..2cb31f403b74 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -835,6 +835,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 			full_pipe_count,
 			dc->res_pool->stream_enc_count);
 
+	dc->optimize_seamless_boot_streams = 0;
 	dc->caps.max_links = dc->link_count;
 	dc->caps.max_audios = dc->res_pool->audio_count;
 	dc->caps.linear_pitch_alignment = 64;
@@ -1178,10 +1179,10 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	for (i = 0; i < context->stream_count; i++) {
 		if (context->streams[i]->apply_seamless_boot_optimization)
-			dc->optimize_seamless_boot = true;
+			dc->optimize_seamless_boot_streams++;
 	}
 
-	if (!dc->optimize_seamless_boot)
+	if (dc->optimize_seamless_boot_streams == 0)
 		dc->hwss.prepare_bandwidth(dc, context);
 
 	/* re-program planes for existing stream, in case we need to
@@ -1254,7 +1255,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	if (!dc->optimize_seamless_boot) {
+	if (dc->optimize_seamless_boot_streams == 0) {
 		/* Must wait for no flips to be pending before doing optimize bw */
 		wait_for_no_pipes_pending(dc, context);
 		/* pplib is notified if disp_num changed */
@@ -1300,7 +1301,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct dc_state *context = dc->current_state;
 
-	if (!dc->optimized_required || dc->optimize_seamless_boot)
+	if (!dc->optimized_required || dc->optimize_seamless_boot_streams > 0)
 		return true;
 
 	post_surface_trace(dc);
@@ -2084,7 +2085,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 					dc->hwss.optimize_bandwidth(dc, dc->current_state);
 				} else {
-					if (!dc->optimize_seamless_boot)
+					if (dc->optimize_seamless_boot_streams == 0)
 						dc->hwss.prepare_bandwidth(dc, dc->current_state);
 
 					core_link_enable_stream(dc->current_state, pipe_ctx);
@@ -2125,7 +2126,7 @@ static void commit_planes_for_stream(struct dc *dc,
 	int i, j;
 	struct pipe_ctx *top_pipe_to_program = NULL;
 
-	if (dc->optimize_seamless_boot && surface_count > 0) {
+	if (dc->optimize_seamless_boot_streams > 0 && surface_count > 0) {
 		/* Optimize seamless boot flag keeps clocks and watermarks high until
 		 * first flip. After first flip, optimization is required to lower
 		 * bandwidth. Important to note that it is expected UEFI will
@@ -2134,12 +2135,14 @@ static void commit_planes_for_stream(struct dc *dc,
 		 */
 		if (stream->apply_seamless_boot_optimization) {
 			stream->apply_seamless_boot_optimization = false;
-			dc->optimize_seamless_boot = false;
-			dc->optimized_required = true;
+			dc->optimize_seamless_boot_streams--;
+
+			if (dc->optimize_seamless_boot_streams == 0)
+				dc->optimized_required = true;
 		}
 	}
 
-	if (update_type == UPDATE_TYPE_FULL && !dc->optimize_seamless_boot) {
+	if (update_type == UPDATE_TYPE_FULL && dc->optimize_seamless_boot_streams == 0) {
 		dc->hwss.prepare_bandwidth(dc, context);
 		context_clock_trace(dc, context);
 	}

commit 6b5d7730d226bed8e87085d870e76fb9018ff0b1
Author: Noah Abradjian <noah.abradjian@amd.com>
Date:   Mon Nov 18 13:59:57 2019 -0500

    drm/amd/display: Add wait for flip not pending on pipe unlock
    
    [Why]
    Lack of proper timing caused intermittent underflow on unplug external DP.
    A previous fix was invalid and caused S0i3 regression, so had to be reverted.
    
    [How]
    When unlocking pipe, wait for no pipes to have flip pending before unlocking.
    
    Signed-off-by: Noah Abradjian <noah.abradjian@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 39fe38cb39b6..879cedd79d9e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -66,6 +66,9 @@
 
 #include "dce/dce_i2c.h"
 
+#define CTX \
+	dc->ctx
+
 #define DC_LOGGER \
 	dc->ctx->logger
 
@@ -783,6 +786,33 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 	dc_release_state(current_ctx);
 }
 
+static void wait_for_no_pipes_pending(struct dc *dc, struct dc_state *context)
+{
+	int i;
+	int count = 0;
+	struct pipe_ctx *pipe;
+	PERF_TRACE();
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe = &context->res_ctx.pipe_ctx[i];
+
+		if (!pipe->plane_state)
+			continue;
+
+		/* Timeout 100 ms */
+		while (count < 100000) {
+			/* Must set to false to start with, due to OR in update function */
+			pipe->plane_state->status.is_flip_pending = false;
+			dc->hwss.update_pending_status(pipe);
+			if (!pipe->plane_state->status.is_flip_pending)
+				break;
+			udelay(1);
+			count++;
+		}
+		ASSERT(!pipe->plane_state->status.is_flip_pending);
+	}
+	PERF_TRACE();
+}
+
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
@@ -1224,9 +1254,12 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	if (!dc->optimize_seamless_boot)
-			/* pplib is notified if disp_num changed */
-			dc->hwss.optimize_bandwidth(dc, context);
+	if (!dc->optimize_seamless_boot) {
+		/* Must wait for no flips to be pending before doing optimize bw */
+		wait_for_no_pipes_pending(dc, context);
+		/* pplib is notified if disp_num changed */
+		dc->hwss.optimize_bandwidth(dc, context);
+	}
 
 	for (i = 0; i < context->stream_count; i++)
 		context->streams[i]->mode_changed = false;

commit 5c7b0f38522e702ce0143a9ef62908eb953808ac
Author: Noah Abradjian <noah.abradjian@amd.com>
Date:   Wed Nov 13 17:06:40 2019 -0500

    drm/amd/display: Remove redundant call
    
    [Why]
    I was advised that we don't need this call of program_front_end, as
    earlier and later calls in the same sequence are sufficient.
    
    [How]
    Remove first call of program_front_end in dc_commit_state_no_check.
    
    Signed-off-by: Noah Abradjian <noah.abradjian@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 55f22a1c0aa5..39fe38cb39b6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1167,8 +1167,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->stream_status[i].plane_count,
 				context); /* use new pipe config in new context */
 		}
-	if (dc->hwss.program_front_end_for_ctx)
-		dc->hwss.program_front_end_for_ctx(dc, context);
 
 	/* Program hardware */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {

commit 8d623f86c07fce9b01e42b503df82bbabfb1621d
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Nov 13 14:04:56 2019 -0500

    drm/amd/display: add DP protocol version
    
    [Why]
    We want to know DP protocol version
    
    [How]
    In DC create we initialize a cap to indicate the max
    DP protocol version supported
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 061e8adf7476..55f22a1c0aa5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -809,6 +809,8 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	dc->caps.max_audios = dc->res_pool->audio_count;
 	dc->caps.linear_pitch_alignment = 64;
 
+	dc->caps.max_dp_protocol_version = DP_VERSION_1_4;
+
 	/* Populate versioning information */
 	dc->versions.dc_ver = DC_VER;
 

commit a4cea11655fbc5246fb5a066588e1589e9cfefa5
Author: Jaehyun Chung <jaehyun.chung@amd.com>
Date:   Thu Nov 7 11:16:49 2019 -0500

    drm/amd/display: Wrong ifdef guards were used around DML validation
    
    [Why]
    Wrong guards were causing the debug option not to run.
    
    [How]
    Changed the guard to the correct one, matching the rq, ttu, dlg regs struct
    members that need to be guarded. Also log a message when validation starts.
    
    Signed-off-by: Jaehyun Chung <jaehyun.chung@amd.com>
    Reviewed-by: Alvin Lee <Alvin.Lee2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e384c143bb58..061e8adf7476 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2187,7 +2187,7 @@ static void commit_planes_for_stream(struct dc *dc,
 	}
 	if (dc->hwss.program_front_end_for_ctx && update_type != UPDATE_TYPE_FAST) {
 		dc->hwss.program_front_end_for_ctx(dc, context);
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_DRM_AMD_DC_DCN
 		if (dc->debug.validate_dml_output) {
 			for (i = 0; i < dc->res_pool->pipe_count; i++) {
 				struct pipe_ctx cur_pipe = context->res_ctx.pipe_ctx[i];

commit f42ea55be1114768e36c4e8dff4400ca811309cf
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:17:30 2019 -0500

    drm/amd/display: add separate of private hwss functions
    
    [Why]
    Some function pointers in the hwss function pointer table are
    meant to be hw sequencer entry points to be called from dc.
    
    However some of those function pointers are not meant to
    be entry points, but instead used as a code reuse/inheritance
    tool called directly by other hwss functions, not by dc.
    
    Therefore, we want a more clear separation of which functions
    we determine to be interface functions vs the functions we
    use within hwss.
    
    [How]
    DC interface functions will be stored in:
        struct hw_sequencer_funcs
    Functions used within HWSS will be stored in:
        struct hwseq_private_funcs
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2645d20e8c4c..e384c143bb58 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2004,6 +2004,12 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				dc->hwss.update_info_frame(pipe_ctx);
 			}
 
+			if (stream_update->hdr_static_metadata &&
+					stream->use_dynamic_meta &&
+					dc->hwss.set_dmdata_attributes &&
+					pipe_ctx->stream->dmdata_address.quad_part != 0)
+				dc->hwss.set_dmdata_attributes(pipe_ctx);
+
 			if (stream_update->gamut_remap)
 				dc_stream_set_gamut_remap(dc, stream);
 

commit 07863a6cc2936f8cc4b5bfb506dec48531cc4948
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Sat Nov 23 12:36:39 2019 -0700

    drm/amd/display: Use NULL for pointer assignment in copy_stream_update_to_stream
    
    Clang warns:
    
    ../drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:1965:26: warning:
    expression which evaluates to zero treated as a null pointer constant of
    type 'struct dc_dsc_config *' [-Wnon-literal-null-conversion]
                                    update->dsc_config = false;
                                                         ^~~~~
    ../drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:1971:25: warning:
    expression which evaluates to zero treated as a null pointer constant of
    type 'struct dc_dsc_config *' [-Wnon-literal-null-conversion]
                            update->dsc_config = false;
                                                 ^~~~~
    2 warnings generated.
    
    Fixes: f6fe4053b91f ("drm/amd/display: Use a temporary copy of the current state when updating DSC config")
    Link: https://github.com/ClangBuiltLinux/linux/issues/777
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c7db4f4810c6..2645d20e8c4c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1962,13 +1962,13 @@ static void copy_stream_update_to_stream(struct dc *dc,
 			if (!dc->res_pool->funcs->validate_bandwidth(dc, dsc_validate_context, true)) {
 				stream->timing.dsc_cfg = old_dsc_cfg;
 				stream->timing.flags.DSC = old_dsc_enabled;
-				update->dsc_config = false;
+				update->dsc_config = NULL;
 			}
 
 			dc_release_state(dsc_validate_context);
 		} else {
 			DC_ERROR("Failed to allocate new validate context for DSC change\n");
-			update->dsc_config = false;
+			update->dsc_config = NULL;
 		}
 	}
 }

commit f6fe4053b91fab916eaf69de48a35f6acc598140
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Mon Nov 4 17:44:23 2019 -0500

    drm/amd/display: Use a temporary copy of the current state when updating DSC config
    
    [why]
    When updating DSC config, a new config has to be validated before proceeding
    with applying the update. Validation, however, modifies the current state.
    This means DSC config validation would affect pipe re-assignment, causing
    intermittent screen corruption issues when ODM is required for DSC.
    
    [how]
    - Use a copy of the current state for modified DSC config validation
    - Set the update type to FULL_UPDATE to correctly validate and set the
      actual state used for committing the streams
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 61dd373b4715..c7db4f4810c6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1677,6 +1677,9 @@ static enum surface_update_type check_update_surfaces_for_stream(
 
 		if (stream_update->output_csc_transform || stream_update->output_color_space)
 			su_flags->bits.out_csc = 1;
+
+		if (stream_update->dsc_config)
+			overall_type = UPDATE_TYPE_FULL;
 	}
 
 	for (i = 0 ; i < surface_count; i++) {
@@ -1868,8 +1871,10 @@ static void copy_surface_update_to_plane(
 static void copy_stream_update_to_stream(struct dc *dc,
 					 struct dc_state *context,
 					 struct dc_stream_state *stream,
-					 const struct dc_stream_update *update)
+					 struct dc_stream_update *update)
 {
+	struct dc_context *dc_ctx = dc->ctx;
+
 	if (update == NULL || stream == NULL)
 		return;
 
@@ -1946,12 +1951,24 @@ static void copy_stream_update_to_stream(struct dc *dc,
 		uint32_t enable_dsc = (update->dsc_config->num_slices_h != 0 &&
 				       update->dsc_config->num_slices_v != 0);
 
-		stream->timing.dsc_cfg = *update->dsc_config;
-		stream->timing.flags.DSC = enable_dsc;
-		if (!dc->res_pool->funcs->validate_bandwidth(dc, context,
-							     true)) {
-			stream->timing.dsc_cfg = old_dsc_cfg;
-			stream->timing.flags.DSC = old_dsc_enabled;
+		/* Use temporarry context for validating new DSC config */
+		struct dc_state *dsc_validate_context = dc_create_state(dc);
+
+		if (dsc_validate_context) {
+			dc_resource_state_copy_construct(dc->current_state, dsc_validate_context);
+
+			stream->timing.dsc_cfg = *update->dsc_config;
+			stream->timing.flags.DSC = enable_dsc;
+			if (!dc->res_pool->funcs->validate_bandwidth(dc, dsc_validate_context, true)) {
+				stream->timing.dsc_cfg = old_dsc_cfg;
+				stream->timing.flags.DSC = old_dsc_enabled;
+				update->dsc_config = false;
+			}
+
+			dc_release_state(dsc_validate_context);
+		} else {
+			DC_ERROR("Failed to allocate new validate context for DSC change\n");
+			update->dsc_config = false;
 		}
 	}
 }

commit b9fe5151052f9d1123027e2de1e6372d884887de
Author: Jaehyun Chung <jaehyun.chung@amd.com>
Date:   Thu Oct 31 15:53:24 2019 -0400

    drm/amd/display: DML Validation Dump/Check with Logging
    
    [Why]
    Need validation that we are programming the expected values (rq, ttu, dlg)
    from DML. This debug feature will output logs if we are programming
    incorrect values and may help differentiate DAL issues from HW issues.
    
    [How]
    Dump relevant registers for each pipe with active stream. Compare current
    reg values with the converted DML output. Log mismatches when found.
    
    Signed-off-by: Jaehyun Chung <jaehyun.chung@amd.com>
    Reviewed-by: Alvin Lee <Alvin.Lee2@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1395aff39980..61dd373b4715 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2162,8 +2162,24 @@ static void commit_planes_for_stream(struct dc *dc,
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
 		}
 	}
-	if (dc->hwss.program_front_end_for_ctx && update_type != UPDATE_TYPE_FAST)
+	if (dc->hwss.program_front_end_for_ctx && update_type != UPDATE_TYPE_FAST) {
 		dc->hwss.program_front_end_for_ctx(dc, context);
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+		if (dc->debug.validate_dml_output) {
+			for (i = 0; i < dc->res_pool->pipe_count; i++) {
+				struct pipe_ctx cur_pipe = context->res_ctx.pipe_ctx[i];
+				if (cur_pipe.stream == NULL)
+					continue;
+
+				cur_pipe.plane_res.hubp->funcs->validate_dml_output(
+						cur_pipe.plane_res.hubp, dc->ctx,
+						&context->res_ctx.pipe_ctx[i].rq_regs,
+						&context->res_ctx.pipe_ctx[i].dlg_regs,
+						&context->res_ctx.pipe_ctx[i].ttu_regs);
+			}
+		}
+#endif
+	}
 
 	// Update Type FAST, Surface updates
 	if (update_type == UPDATE_TYPE_FAST) {

commit 78c7738211e027f122ada3f59c2c5e8a83ee3c59
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Oct 29 15:05:56 2019 -0400

    drm/amd/display: cleanup of function pointer tables
    
    [Why]
    It is becoming increasingly hard to figure out which
    function is called on the different DCN versions
    
    [How]
    1. Make function pointer table init in its own init.c file
    2. Remove other scenarios in hwseq.c file that need to
    include headers of other DCN versions. (If needed,
    it should have been done via the function pointers)
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a25172ba0782..1395aff39980 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1973,11 +1973,11 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 			if (stream_update->periodic_interrupt0 &&
 					dc->hwss.setup_periodic_interrupt)
-				dc->hwss.setup_periodic_interrupt(pipe_ctx, VLINE0);
+				dc->hwss.setup_periodic_interrupt(dc, pipe_ctx, VLINE0);
 
 			if (stream_update->periodic_interrupt1 &&
 					dc->hwss.setup_periodic_interrupt)
-				dc->hwss.setup_periodic_interrupt(pipe_ctx, VLINE1);
+				dc->hwss.setup_periodic_interrupt(dc, pipe_ctx, VLINE1);
 
 			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||

commit 46250a0cba4ce9c9754b922ef89a2aa484209164
Author: Michael Strauss <michael.strauss@amd.com>
Date:   Sun Nov 3 09:35:03 2019 -0500

    drm/amd/display: Avoid conflict between HDR multiplier and 3dlut
    
    [WHY]
    There can be a conflict between OS HDR multiplier and 3dlut HDR
    multiplier, which are both sent to DC.
    
    [HOW]
    Instead of having dc determine which HDR multiplier to use, make the
    decision in dm and send only the intended value in a surface update.
    Store the current OS HDR multiplier and determine whether to use it or
    the 3dlut's multiplier before sending the surface update to dc. Send
    multiplier to dc in fixed31_32 format, dc then converts it to hw format.
    
    Signed-off-by: Michael Strauss <michael.strauss@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6089c90ad6cd..a25172ba0782 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1469,11 +1469,6 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 		elevate_update_type(&update_type, UPDATE_TYPE_MED);
 	}
 
-	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level) {
-		update_flags->bits.sdr_white_level = 1;
-		elevate_update_type(&update_type, UPDATE_TYPE_MED);
-	}
-
 	if (u->plane_info->dcc.enable != u->surface->dcc.enable
 			|| u->plane_info->dcc.independent_64b_blks != u->surface->dcc.independent_64b_blks
 			|| u->plane_info->dcc.meta_pitch != u->surface->dcc.meta_pitch) {
@@ -1620,6 +1615,12 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 			update_flags->bits.gamma_change = 1;
 	}
 
+	if (u->hdr_mult.value)
+		if (u->hdr_mult.value != u->surface->hdr_mult.value) {
+			update_flags->bits.hdr_mult = 1;
+			elevate_update_type(&overall_type, UPDATE_TYPE_MED);
+		}
+
 	if (update_flags->bits.in_transfer_func_change) {
 		type = UPDATE_TYPE_MED;
 		elevate_update_type(&overall_type, type);
@@ -1801,8 +1802,6 @@ static void copy_surface_update_to_plane(
 				srf_update->plane_info->global_alpha_value;
 		surface->dcc =
 				srf_update->plane_info->dcc;
-		surface->sdr_white_level =
-				srf_update->plane_info->sdr_white_level;
 		surface->layer_index =
 				srf_update->plane_info->layer_index;
 	}
@@ -1847,6 +1846,10 @@ static void copy_surface_update_to_plane(
 		memcpy(surface->lut3d_func, srf_update->lut3d_func,
 		sizeof(*surface->lut3d_func));
 
+	if (srf_update->hdr_mult.value)
+		surface->hdr_mult =
+				srf_update->hdr_mult;
+
 	if (srf_update->blend_tf &&
 			(surface->blend_tf !=
 			srf_update->blend_tf))

commit d9e32672a1285d6c5e06bedaabb465441c172aa8
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Oct 31 21:39:39 2019 -0400

    drm/amd/display: cleanup of construct and destruct funcs
    
    [Why]
    Too many construct functions which makes searching
    difficult, especially on some debuggers.
    
    [How]
    Append all construct and destruct functions with dcn
    number and object type to make each construct function
    name unique
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7f796a4c73d4..6089c90ad6cd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -533,7 +533,7 @@ void dc_stream_set_static_screen_events(struct dc *dc,
 	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
-static void destruct(struct dc *dc)
+static void dc_destruct(struct dc *dc)
 {
 	if (dc->current_state) {
 		dc_release_state(dc->current_state);
@@ -579,7 +579,7 @@ static void destruct(struct dc *dc)
 
 }
 
-static bool construct(struct dc *dc,
+static bool dc_construct(struct dc *dc,
 		const struct dc_init_data *init_params)
 {
 	struct dc_context *dc_ctx;
@@ -729,7 +729,7 @@ static bool construct(struct dc *dc,
 
 fail:
 
-	destruct(dc);
+	dc_destruct(dc);
 	return false;
 }
 
@@ -795,7 +795,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	if (NULL == dc)
 		goto alloc_fail;
 
-	if (false == construct(dc, init_params))
+	if (false == dc_construct(dc, init_params))
 		goto construct_fail;
 
 	full_pipe_count = dc->res_pool->pipe_count;
@@ -852,7 +852,7 @@ void dc_deinit_callbacks(struct dc *dc)
 
 void dc_destroy(struct dc **dc)
 {
-	destruct(*dc);
+	dc_destruct(*dc);
 	kfree(*dc);
 	*dc = NULL;
 }

commit be32c9891c13fe26e9f7fb4020b2adc40ca2dec3
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Thu Oct 31 15:27:28 2019 -0400

    drm/amd/display: revert change causing DTN hang for RV
    
    [Why]
    Hanging on RV for DTN driver verifier
    
    [How]
    Roll back change and investigate further
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c3a315f1d5f8..7f796a4c73d4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1747,37 +1747,12 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-static void validate_dcc_with_meta_address(
-	struct dc_plane_dcc_param *dcc,
-	struct dc_plane_address *address)
-{
-	if ((address->grph.meta_addr.quad_part == 0) &&
-		dcc->enable) {
-		ASSERT(!dcc->enable);
-		dcc->enable = false;
-	} else if ((address->grph.meta_addr.quad_part != 0) &&
-		!dcc->enable)
-		dcc->enable = true;
-
-	if (address->type != PLN_ADDR_TYPE_GRAPHICS) {
-		if ((address->grph_stereo.right_meta_addr.quad_part == 0) &&
-			dcc->enable) {
-			ASSERT(!dcc->enable);
-			dcc->enable = false;
-		} else if ((address->grph_stereo.right_meta_addr.quad_part != 0) &&
-			!dcc->enable)
-			dcc->enable = true;
-	}
-}
-
 static void copy_surface_update_to_plane(
 		struct dc_plane_state *surface,
 		struct dc_surface_update *srf_update)
 {
 	if (srf_update->flip_addr) {
 		surface->address = srf_update->flip_addr->address;
-		validate_dcc_with_meta_address(&surface->dcc, &surface->address);
-
 		surface->flip_immediate =
 			srf_update->flip_addr->flip_immediate;
 		surface->time.time_elapsed_in_us[surface->time.index] =
@@ -1826,8 +1801,6 @@ static void copy_surface_update_to_plane(
 				srf_update->plane_info->global_alpha_value;
 		surface->dcc =
 				srf_update->plane_info->dcc;
-		validate_dcc_with_meta_address(&surface->dcc, &surface->address);
-
 		surface->sdr_white_level =
 				srf_update->plane_info->sdr_white_level;
 		surface->layer_index =

commit 8d8a6af71a75e09ce5796b4ae780818865832c50
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Wed Oct 23 21:36:29 2019 -0400

    drm/amd/display: Fix stereo with DCC enabled
    
    [Why]
    When sending DCC with Stereo, DCC gets enabled but the meta addresses
    are 0. This happens momentarily before the meta addresses are populated
    with a valid address.
    
    [How]
    Add call validate_dcc_with_meta_address() in
    copy_surface_update_to_plane() to check for surface address and DCC
    change.
    When DCC has changed, check if DCC enable is true but meta address is 0.
    If so, we turn DCC enable to false. When surface address has changed, we
    check if DCC enable is false but meta address is not 0. If so, we turn
    DCC enable back to true.  This will restore DCC enable to the proper
    setting once the meta address is valid.
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7f796a4c73d4..c3a315f1d5f8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1747,12 +1747,37 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
+static void validate_dcc_with_meta_address(
+	struct dc_plane_dcc_param *dcc,
+	struct dc_plane_address *address)
+{
+	if ((address->grph.meta_addr.quad_part == 0) &&
+		dcc->enable) {
+		ASSERT(!dcc->enable);
+		dcc->enable = false;
+	} else if ((address->grph.meta_addr.quad_part != 0) &&
+		!dcc->enable)
+		dcc->enable = true;
+
+	if (address->type != PLN_ADDR_TYPE_GRAPHICS) {
+		if ((address->grph_stereo.right_meta_addr.quad_part == 0) &&
+			dcc->enable) {
+			ASSERT(!dcc->enable);
+			dcc->enable = false;
+		} else if ((address->grph_stereo.right_meta_addr.quad_part != 0) &&
+			!dcc->enable)
+			dcc->enable = true;
+	}
+}
+
 static void copy_surface_update_to_plane(
 		struct dc_plane_state *surface,
 		struct dc_surface_update *srf_update)
 {
 	if (srf_update->flip_addr) {
 		surface->address = srf_update->flip_addr->address;
+		validate_dcc_with_meta_address(&surface->dcc, &surface->address);
+
 		surface->flip_immediate =
 			srf_update->flip_addr->flip_immediate;
 		surface->time.time_elapsed_in_us[surface->time.index] =
@@ -1801,6 +1826,8 @@ static void copy_surface_update_to_plane(
 				srf_update->plane_info->global_alpha_value;
 		surface->dcc =
 				srf_update->plane_info->dcc;
+		validate_dcc_with_meta_address(&surface->dcc, &surface->address);
+
 		surface->sdr_white_level =
 				srf_update->plane_info->sdr_white_level;
 		surface->layer_index =

commit 39a502c882e5a571041bb2e2b5b2c7f883c6505d
Author: zhengbin <zhengbin13@huawei.com>
Date:   Mon Nov 11 17:33:13 2019 +0800

    drm/amd/display: Use static const, not const static
    
    Move the static keyword to the front of declarations.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1fa255e077d0..7f796a4c73d4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -69,7 +69,7 @@
 #define DC_LOGGER \
 	dc->ctx->logger
 
-const static char DC_BUILD_ID[] = "production-build";
+static const char DC_BUILD_ID[] = "production-build";
 
 /**
  * DOC: Overview

commit 4b31b1720704bf058b2f3df1d354ac23a669c6f5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Nov 9 15:49:21 2019 +0000

    drm/amd/display: remove duplicated comparison expression
    
    There is comparison expression that is duplicated and hence one
    of the expressions can be removed.  Remove it.
    
    Addresses-Coverity: ("Same on both sides")
    Fixes: 12e2b2d4c65f ("drm/amd/display: add dcc programming for dual plane")
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1fdba13b3d0f..1fa255e077d0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1491,7 +1491,6 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	}
 
 	if (u->plane_info->plane_size.surface_pitch != u->surface->plane_size.surface_pitch
-			|| u->plane_info->plane_size.surface_pitch != u->surface->plane_size.surface_pitch
 			|| u->plane_info->plane_size.chroma_pitch != u->surface->plane_size.chroma_pitch) {
 		update_flags->bits.plane_size_change = 1;
 		elevate_update_type(&update_type, UPDATE_TYPE_MED);

commit b86a1aa36a92bcfbc062c5e99c1d084f27f25bab
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:48:35 2019 -0500

    drm/amd/display: rename DCN1_0 kconfig to DCN
    
    Since dcn20 and dcn21 are under dcn1 it doesnt make sense to
    have it named dcn1.
    
    Change it to "dcn" to make it generic
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 30e42cbc17d1..1fdba13b3d0f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -566,7 +566,7 @@ static void destruct(struct dc *dc)
 	kfree(dc->bw_dceip);
 	dc->bw_dceip = NULL;
 
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_DRM_AMD_DC_DCN
 	kfree(dc->dcn_soc);
 	dc->dcn_soc = NULL;
 
@@ -585,7 +585,7 @@ static bool construct(struct dc *dc,
 	struct dc_context *dc_ctx;
 	struct bw_calcs_dceip *dc_dceip;
 	struct bw_calcs_vbios *dc_vbios;
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_DRM_AMD_DC_DCN
 	struct dcn_soc_bounding_box *dcn_soc;
 	struct dcn_ip_params *dcn_ip;
 #endif
@@ -617,7 +617,7 @@ static bool construct(struct dc *dc,
 	}
 
 	dc->bw_vbios = dc_vbios;
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_DRM_AMD_DC_DCN
 	dcn_soc = kzalloc(sizeof(*dcn_soc), GFP_KERNEL);
 	if (!dcn_soc) {
 		dm_error("%s: failed to create dcn_soc\n", __func__);
@@ -1296,7 +1296,7 @@ struct dc_state *dc_create_state(struct dc *dc)
 	 * initialize and obtain IP and SOC the base DML instance from DC is
 	 * initially copied into every context
 	 */
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_DRM_AMD_DC_DCN
 	memcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));
 #endif
 

commit aca935c7cc866a935a61769c9e9782dd834a8502
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:44:19 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_1 flag
    
    [Why]
    
    DCN21 is stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DCN2_1 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_1 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DCN2_1 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_1 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup Renoir definitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN21 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e7e552f02b51..30e42cbc17d1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -705,10 +705,8 @@ static bool construct(struct dc *dc,
 	if (!dc->clk_mgr)
 		goto fail;
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_1
 	if (dc->res_pool->funcs->update_bw_bounding_box)
 		dc->res_pool->funcs->update_bw_bounding_box(dc, dc->clk_mgr->bw_params);
-#endif
 
 	/* Creation of current_state must occur after dc->dml
 	 * is initialized in dc_create_resource_pool because

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0cef26941b0d..e7e552f02b51 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -60,13 +60,9 @@
 #include "dc_link_dp.h"
 #include "dc_dmub_srv.h"
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #include "dsc.h"
-#endif
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 #include "vm_helper.h"
-#endif
 
 #include "dce/dce_i2c.h"
 
@@ -578,11 +574,9 @@ static void destruct(struct dc *dc)
 	dc->dcn_ip = NULL;
 
 #endif
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 	kfree(dc->vm_helper);
 	dc->vm_helper = NULL;
 
-#endif
 }
 
 static bool construct(struct dc *dc,
@@ -599,7 +593,6 @@ static bool construct(struct dc *dc,
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 	dc->config = init_params->flags;
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 	// Allocate memory for the vm_helper
 	dc->vm_helper = kzalloc(sizeof(struct vm_helper), GFP_KERNEL);
 	if (!dc->vm_helper) {
@@ -607,7 +600,6 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 
-#endif
 	memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));
 
 	dc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);
@@ -641,9 +633,7 @@ static bool construct(struct dc *dc,
 	}
 
 	dc->dcn_ip = dcn_ip;
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 	dc->soc_bounding_box = init_params->soc_bounding_box;
-#endif
 #endif
 
 	dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
@@ -745,7 +735,6 @@ static bool construct(struct dc *dc,
 	return false;
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 static bool disable_all_writeback_pipes_for_stream(
 		const struct dc *dc,
 		struct dc_stream_state *stream,
@@ -758,7 +747,6 @@ static bool disable_all_writeback_pipes_for_stream(
 
 	return true;
 }
-#endif
 
 static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 {
@@ -784,16 +772,12 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 		}
 		if (should_disable && old_stream) {
 			dc_rem_all_planes_for_stream(dc, old_stream, dangling_context);
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 			disable_all_writeback_pipes_for_stream(dc, old_stream, dangling_context);
-#endif
 			if (dc->hwss.apply_ctx_for_surface)
 				dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
 		}
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		if (dc->hwss.program_front_end_for_ctx)
 			dc->hwss.program_front_end_for_ctx(dc, dangling_context);
-#endif
 	}
 
 	current_ctx = dc->current_state;
@@ -1183,10 +1167,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->stream_status[i].plane_count,
 				context); /* use new pipe config in new context */
 		}
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	if (dc->hwss.program_front_end_for_ctx)
 		dc->hwss.program_front_end_for_ctx(dc, context);
-#endif
 
 	/* Program hardware */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -1205,10 +1187,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	}
 
 	/* Program all planes within new context*/
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	if (dc->hwss.program_front_end_for_ctx)
 		dc->hwss.program_front_end_for_ctx(dc, context);
-#endif
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_link *link = context->streams[i]->link;
 
@@ -1692,10 +1672,8 @@ static enum surface_update_type check_update_surfaces_for_stream(
 		if (stream_update->gamut_remap)
 			su_flags->bits.gamut_remap = 1;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		if (stream_update->wb_update)
 			su_flags->bits.wb_update = 1;
-#endif
 		if (su_flags->raw != 0)
 			overall_type = UPDATE_TYPE_FULL;
 
@@ -1860,7 +1838,6 @@ static void copy_surface_update_to_plane(
 			sizeof(struct dc_transfer_func_distributed_points));
 	}
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	if (srf_update->func_shaper &&
 			(surface->in_shaper_func !=
 			srf_update->func_shaper))
@@ -1879,7 +1856,6 @@ static void copy_surface_update_to_plane(
 		memcpy(surface->blend_tf, srf_update->blend_tf,
 		sizeof(*surface->blend_tf));
 
-#endif
 	if (srf_update->input_csc_color_matrix)
 		surface->input_csc_color_matrix =
 			*srf_update->input_csc_color_matrix;
@@ -1954,7 +1930,6 @@ static void copy_stream_update_to_stream(struct dc *dc,
 
 	if (update->dither_option)
 		stream->dither_option = *update->dither_option;
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	/* update current stream with writeback info */
 	if (update->wb_update) {
 		int i;
@@ -1965,8 +1940,6 @@ static void copy_stream_update_to_stream(struct dc *dc,
 			stream->writeback_info[i] =
 				update->wb_update->writeback_info[i];
 	}
-#endif
-#if defined(CONFIG_DRM_AMD_DC_DSC_SUPPORT)
 	if (update->dsc_config) {
 		struct dc_dsc_config old_dsc_cfg = stream->timing.dsc_cfg;
 		uint32_t old_dsc_enabled = stream->timing.flags.DSC;
@@ -1981,7 +1954,6 @@ static void copy_stream_update_to_stream(struct dc *dc,
 			stream->timing.flags.DSC = old_dsc_enabled;
 		}
 	}
-#endif
 }
 
 static void commit_planes_do_stream_update(struct dc *dc,
@@ -2022,31 +1994,25 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				dc_stream_program_csc_matrix(dc, stream);
 
 			if (stream_update->dither_option) {
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 				struct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;
-#endif
 				resource_build_bit_depth_reduction_params(pipe_ctx->stream,
 									&pipe_ctx->stream->bit_depth_params);
 				pipe_ctx->stream_res.opp->funcs->opp_program_fmt(pipe_ctx->stream_res.opp,
 						&stream->bit_depth_params,
 						&stream->clamping);
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 				while (odm_pipe) {
 					odm_pipe->stream_res.opp->funcs->opp_program_fmt(odm_pipe->stream_res.opp,
 							&stream->bit_depth_params,
 							&stream->clamping);
 					odm_pipe = odm_pipe->next_odm_pipe;
 				}
-#endif
 			}
 
-#if defined(CONFIG_DRM_AMD_DC_DSC_SUPPORT)
 			if (stream_update->dsc_config && dc->hwss.pipe_control_lock_global) {
 				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
 				dp_update_dsc_config(pipe_ctx);
 				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
 			}
-#endif
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
@@ -2133,15 +2099,12 @@ static void commit_planes_for_stream(struct dc *dc,
 		 */
 		if (dc->hwss.apply_ctx_for_surface)
 			dc->hwss.apply_ctx_for_surface(dc, stream, 0, context);
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		if (dc->hwss.program_front_end_for_ctx)
 			dc->hwss.program_front_end_for_ctx(dc, context);
-#endif
 
 		return;
 	}
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	if (!IS_DIAG_DC(dc->ctx->dce_environment)) {
 		for (i = 0; i < surface_count; i++) {
 			struct dc_plane_state *plane_state = srf_updates[i].surface;
@@ -2163,7 +2126,6 @@ static void commit_planes_for_stream(struct dc *dc,
 			}
 		}
 	}
-#endif
 
 	// Update Type FULL, Surface updates
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
@@ -2184,7 +2146,6 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 			ASSERT(!pipe_ctx->plane_state->triplebuffer_flips);
 
 			if (dc->hwss.program_triplebuffer != NULL &&
@@ -2193,7 +2154,6 @@ static void commit_planes_for_stream(struct dc *dc,
 				dc->hwss.program_triplebuffer(
 					dc, pipe_ctx, pipe_ctx->plane_state->triplebuffer_flips);
 			}
-#endif
 			stream_status =
 				stream_get_status(context, pipe_ctx->stream);
 
@@ -2202,10 +2162,8 @@ static void commit_planes_for_stream(struct dc *dc,
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
 		}
 	}
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	if (dc->hwss.program_front_end_for_ctx && update_type != UPDATE_TYPE_FAST)
 		dc->hwss.program_front_end_for_ctx(dc, context);
-#endif
 
 	// Update Type FAST, Surface updates
 	if (update_type == UPDATE_TYPE_FAST) {
@@ -2215,7 +2173,6 @@ static void commit_planes_for_stream(struct dc *dc,
 		 */
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		if (dc->hwss.set_flip_control_gsl)
 			for (i = 0; i < surface_count; i++) {
 				struct dc_plane_state *plane_state = srf_updates[i].surface;
@@ -2234,7 +2191,6 @@ static void commit_planes_for_stream(struct dc *dc,
 							plane_state->flip_immediate);
 				}
 			}
-#endif
 		/* Perform requested Updates */
 		for (i = 0; i < surface_count; i++) {
 			struct dc_plane_state *plane_state = srf_updates[i].surface;
@@ -2247,7 +2203,6 @@ static void commit_planes_for_stream(struct dc *dc,
 
 				if (pipe_ctx->plane_state != plane_state)
 					continue;
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 				/*program triple buffer after lock based on flip type*/
 				if (dc->hwss.program_triplebuffer != NULL &&
 					!dc->debug.disable_tri_buf) {
@@ -2255,7 +2210,6 @@ static void commit_planes_for_stream(struct dc *dc,
 					dc->hwss.program_triplebuffer(
 						dc, pipe_ctx, plane_state->triplebuffer_flips);
 				}
-#endif
 				if (srf_updates[i].flip_addr)
 					dc->hwss.update_plane_addr(dc, pipe_ctx);
 			}
@@ -2421,12 +2375,10 @@ void dc_set_power_state(
 
 		dc->hwss.init_hw(dc);
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 		if (dc->hwss.init_sys_ctx != NULL &&
 			dc->vm_pa_config.valid) {
 			dc->hwss.init_sys_ctx(dc->hwseq, dc, &dc->vm_pa_config);
 		}
-#endif
 
 		break;
 	default:

commit 00ada9d14f386305abfad73665d235882768c78f
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Thu Oct 17 16:40:02 2019 -0400

    drm/amd/display: Unify all scaling when Integer Scaling enabled
    
    [why]
    We want to guarantee integer ratio scaling for all scaling modes.
    
    [how]
    Treat centered, fullscreen, preserve aspect ratio the same: scale
    the view as many times as possible, and fill in the rest with a black
    border.
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index aadd2a20fc65..0cef26941b0d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1552,7 +1552,10 @@ static enum surface_update_type get_scaling_info_update_type(
 	if (u->scaling_info->clip_rect.width != u->surface->clip_rect.width
 			|| u->scaling_info->clip_rect.height != u->surface->clip_rect.height
 			|| u->scaling_info->dst_rect.width != u->surface->dst_rect.width
-			|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height) {
+			|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height
+			|| u->scaling_info->scaling_quality.integer_scaling !=
+				u->surface->scaling_quality.integer_scaling
+			) {
 		update_flags->bits.scaling_change = 1;
 
 		if ((u->scaling_info->dst_rect.width < u->surface->dst_rect.width
@@ -1673,7 +1676,8 @@ static enum surface_update_type check_update_surfaces_for_stream(
 		union stream_update_flags *su_flags = &stream_update->stream->update_flags;
 
 		if ((stream_update->src.height != 0 && stream_update->src.width != 0) ||
-				(stream_update->dst.height != 0 && stream_update->dst.width != 0))
+			(stream_update->dst.height != 0 && stream_update->dst.width != 0) ||
+			stream_update->integer_scaling_update)
 			su_flags->bits.scaling = 1;
 
 		if (stream_update->out_transfer_func)

commit d9a07577b8a3131c90c187fb2b89662bee535cfd
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Aug 2 17:22:57 2019 -0400

    drm/amd/display: add oem i2c implemenation in dc
    
    [why]
    Need it for some OEM I2C devices in Nv10
    
    [how]
    Link up code to parse OEM table and expose DC interface
    to access the pins
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index cbdd049ca76b..aadd2a20fc65 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2502,6 +2502,17 @@ bool dc_submit_i2c(
 		cmd);
 }
 
+bool dc_submit_i2c_oem(
+		struct dc *dc,
+		struct i2c_command *cmd)
+{
+	struct ddc_service *ddc = dc->res_pool->oem_device;
+	return dce_i2c_submit_command(
+		dc->res_pool,
+		ddc->ddc_pin,
+		cmd);
+}
+
 static bool link_add_remote_sink_helper(struct dc_link *dc_link, struct dc_sink *sink)
 {
 	if (dc_link->sink_count >= MAX_SINKS_PER_LINK) {

commit f2988e67144a263e33aa3b916457bf3095288c94
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Oct 18 18:24:59 2019 -0400

    drm/amd/display: optimize bandwidth after commit streams.
    
    [Why]
    System is unable to enter S0i3 due to DISPLAY_OFF_MASK not asserted
    in SMU.
    
    [How]
    Optimized bandwidth should be called paired and to resolve unplug
    display underflow issue, optimize bandwidth after commit streams is
    moved to next page flip, in case of S0i3, there is a change for no
    flip coming causing display count is 1 in SMU side.
    Add optimize bandwidth after commit stream.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0a5f91ab4652..cbdd049ca76b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1246,6 +1246,10 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
+	if (!dc->optimize_seamless_boot)
+			/* pplib is notified if disp_num changed */
+			dc->hwss.optimize_bandwidth(dc, context);
+
 	for (i = 0; i < context->stream_count; i++)
 		context->streams[i]->mode_changed = false;
 

commit 2200eb9e1819aabb9a1c24d5f6b132f389a2e8a9
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Mon Oct 28 09:22:34 2019 -0400

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DMUB guards
    
    [Why]
    Support for DMUB only depends on support for DC. It doesn't use floating
    point so we don't need to guard it by any specific DCN revision.
    
    [How]
    Drop the guards and cleanup the newlines around each one.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2bf4da41577a..0a5f91ab4652 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -58,10 +58,7 @@
 #include "hubp.h"
 
 #include "dc_link_dp.h"
-
-#ifdef CONFIG_DRM_AMD_DC_DMUB
 #include "dc_dmub_srv.h"
-#endif
 
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #include "dsc.h"
@@ -2410,10 +2407,9 @@ void dc_set_power_state(
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
 		dc_resource_state_construct(dc, dc->current_state);
-#ifdef CONFIG_DRM_AMD_DC_DMUB
+
 		if (dc->ctx->dmub_srv)
 			dc_dmub_srv_wait_phy_init(dc->ctx->dmub_srv);
-#endif
 
 		dc->hwss.init_hw(dc);
 

commit 3a1627b07385a6bb497f7ca4e2ffe1e1dbc70b68
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Oct 25 15:03:58 2019 -0400

    drm/amd/display: Add DMUB support to DC
    
    DC will use DMUB for command submission and flow control during
    initialization.
    
    Register offloading as well as submitting some BIOS commands are part
    of the DC internal interface but are guarded behind debug options.
    
    It won't be functional in amdgpu_dm yet since we don't pass the
    DMUB service to DC for use.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 32f31bf91915..2bf4da41577a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -59,6 +59,10 @@
 
 #include "dc_link_dp.h"
 
+#ifdef CONFIG_DRM_AMD_DC_DMUB
+#include "dc_dmub_srv.h"
+#endif
+
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #include "dsc.h"
 #endif
@@ -2406,6 +2410,10 @@ void dc_set_power_state(
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
 		dc_resource_state_construct(dc, dc->current_state);
+#ifdef CONFIG_DRM_AMD_DC_DMUB
+		if (dc->ctx->dmub_srv)
+			dc_dmub_srv_wait_phy_init(dc->ctx->dmub_srv);
+#endif
 
 		dc->hwss.init_hw(dc);
 

commit 039ffeaae307d61318742e0b2f79742e08ea6b8b
Author: zhongshiqi <zhong.shiqi@zte.com.cn>
Date:   Wed Oct 23 16:32:23 2019 +0800

    dc.c:use kzalloc without test
    
    dc.c:583:null check is needed after using kzalloc function
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: zhongshiqi <zhong.shiqi@zte.com.cn>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0a443348df10..32f31bf91915 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -601,6 +601,10 @@ static bool construct(struct dc *dc,
 #ifdef CONFIG_DRM_AMD_DC_DCN2_0
 	// Allocate memory for the vm_helper
 	dc->vm_helper = kzalloc(sizeof(struct vm_helper), GFP_KERNEL);
+	if (!dc->vm_helper) {
+		dm_error("%s: failed to create dc->vm_helper\n", __func__);
+		goto fail;
+	}
 
 #endif
 	memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));

commit 1ea8751bd28d1ec2b36a56ec6bc1ac28903d09b4
Author: Noah Abradjian <noah.abradjian@amd.com>
Date:   Fri Sep 27 16:30:57 2019 -0400

    drm/amd/display: Make clk mgr the only dto update point
    
    [Why]
    
    * Clk Mgr DTO update point did not cover all needed updates, as it included a
      check for plane_state which does not exist yet when the updater is called on
      driver startup
    * This resulted in another update path in the pipe programming sequence, based
      on a dppclk update flag
    * However, this alternate path allowed for stray DTO updates, some of which would
      occur in the wrong order during dppclk lowering and cause underflow
    
    [How]
    
    * Remove plane_state check and use of plane_res.dpp->inst, getting rid
      of sequence dependencies (this results in extra dto programming for unused
      pipes but that doesn't cause issues and is a small cost)
    * Allow DTOs to be updated even if global clock is equal, to account for
      edge case exposed by diags tests
    * Remove update_dpp_dto call in pipe programming sequence (leave update to
      dppclk_control there, as that update is necessary and shouldn't occur in clk
      mgr)
    * Remove call to optimize_bandwidth when committing state, as it is not needed
      and resulted in sporadic underflows even with other fixes in place
    
    Signed-off-by: Noah Abradjian <noah.abradjian@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5e487bb82861..0a443348df10 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1241,10 +1241,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	if (!dc->optimize_seamless_boot)
-		/* pplib is notified if disp_num changed */
-		dc->hwss.optimize_bandwidth(dc, context);
-
 	for (i = 0; i < context->stream_count; i++)
 		context->streams[i]->mode_changed = false;
 

commit 22631bb8ca58b14bd5cbd583479e7cdda763cd1d
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Oct 1 11:31:37 2019 -0400

    drm/amd/display: add flag to allow diag to force enumerate edp
    
    [why]
    SLT tests require that diag can drive eDP even if nothing is connected, this is not
    typical production use case, so we need to add flag
    
    [how]
    add flag, and this flag supercedes "should destroy" logic
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 55b82ca44c3b..5e487bb82861 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -194,7 +194,7 @@ static bool create_links(
 				}
 			}
 
-			if (!should_destory_link) {
+			if (dc->config.force_enum_edp || !should_destory_link) {
 				dc->links[dc->link_count] = link;
 				link->dc = dc;
 				++dc->link_count;

commit 69fea579c215679212e9a15a79465687e6add3ae
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Aug 30 16:58:29 2019 -0400

    drm/amd/display: remove unused code
    
    Commit hints are unnecessary after front end programming redesign.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 41b51f43a64b..55b82ca44c3b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1248,8 +1248,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	for (i = 0; i < context->stream_count; i++)
 		context->streams[i]->mode_changed = false;
 
-	memset(&context->commit_hints, 0, sizeof(context->commit_hints));
-
 	dc_release_state(dc->current_state);
 
 	dc->current_state = context;

commit 34b86b75dfc90ab3d996c224314ce51772a3b351
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Thu Oct 10 16:11:57 2019 +0300

    drm/amd/display: Use swap() where appropriate
    
    Mostly a cocci-job, but it flat out refused to remove the
    declaration in drivers/gpu/drm/amd/display/dc/core/dc.c so
    had to do that part manually.
    
    @swap@
    identifier TEMP;
    expression A,B;
    @@
    - TEMP = A;
    - A = B;
    - B = TEMP;
    + swap(A, B);
    
    @@
    type T;
    identifier swap.TEMP;
    @@
    (
    - T TEMP;
    |
    - T TEMP = {...};
    )
    ... when != TEMP
    
    Cc: Harry Wentland <harry.wentland@amd.com>
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: amd-gfx@lists.freedesktop.org
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 824c0d3b2100..41b51f43a64b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -939,15 +939,11 @@ static void program_timing_sync(
 
 		/* set first pipe with plane as master */
 		for (j = 0; j < group_size; j++) {
-			struct pipe_ctx *temp;
-
 			if (pipe_set[j]->plane_state) {
 				if (j == 0)
 					break;
 
-				temp = pipe_set[0];
-				pipe_set[0] = pipe_set[j];
-				pipe_set[j] = temp;
+				swap(pipe_set[0], pipe_set[j]);
 				break;
 			}
 		}

commit 52883b36f70ad39e58c57e7ddacad251ad02ee7f
Author: Leo Li <sunpeng.li@amd.com>
Date:   Fri Sep 20 09:43:36 2019 -0400

    drm/amd/display: Fix maybe-uninitialized warning
    
    [Why]
    
    Compiling with GCC 9.1.0 gives the following warning (I have
    warnings-as-errors enabled):
    
    drivers/gpu/drm/amd/amdgpu/../dal-dev/dc/core/dc.c: In function 'dc_validate_seamless_boot_timing':
    drivers/gpu/drm/amd/amdgpu/../dal-dev/dc/core/dc.c:1180:8: error: 'se' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     1180 |   if (!se->funcs->dp_get_pixel_format(
          |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     1181 |    se,
          |    ~~~
     1182 |    &hw_crtc_timing.pixel_encoding,
          |    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     1183 |    &hw_crtc_timing.display_color_depth))
    
    [How]
    
    Initialize se to NULL.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3416c8bd09ae..824c0d3b2100 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1004,7 +1004,7 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 				struct dc_crtc_timing *crtc_timing)
 {
 	struct timing_generator *tg;
-	struct stream_encoder *se;
+	struct stream_encoder *se = NULL;
 
 	struct dc_crtc_timing hw_crtc_timing = {0};
 

commit 93c2340bdc24b6067a7621e71d4aacac1f85b5f2
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Sep 17 14:50:22 2019 -0400

    drm/amd/display: add more checks to validate seamless boot timing
    
    [why]
    we found using an active DP to HDMI panel that we weren't validating
    dp_pixel_format and hardware timing v_front_porch, causing screen to
    blank and/or corrupt while attempting a seamless boot.
    
    [how]
    added checks during dc_validate_seamless_boot_timing for these values
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7ac68e77b32b..3416c8bd09ae 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1004,6 +1004,10 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 				struct dc_crtc_timing *crtc_timing)
 {
 	struct timing_generator *tg;
+	struct stream_encoder *se;
+
+	struct dc_crtc_timing hw_crtc_timing = {0};
+
 	struct dc_link *link = sink->link;
 	unsigned int i, enc_inst, tg_inst = 0;
 
@@ -1023,6 +1027,9 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 
 	for (i = 0; i < dc->res_pool->stream_enc_count; i++) {
 		if (dc->res_pool->stream_enc[i]->id == enc_inst) {
+
+			se = dc->res_pool->stream_enc[i];
+
 			tg_inst = dc->res_pool->stream_enc[i]->funcs->dig_source_otg(
 				dc->res_pool->stream_enc[i]);
 			break;
@@ -1038,10 +1045,46 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 
 	tg = dc->res_pool->timing_generators[tg_inst];
 
-	if (!tg->funcs->is_matching_timing)
+	if (!tg->funcs->get_hw_timing)
+		return false;
+
+	if (!tg->funcs->get_hw_timing(tg, &hw_crtc_timing))
+		return false;
+
+	if (crtc_timing->h_total != hw_crtc_timing.h_total)
+		return false;
+
+	if (crtc_timing->h_border_left != hw_crtc_timing.h_border_left)
+		return false;
+
+	if (crtc_timing->h_addressable != hw_crtc_timing.h_addressable)
+		return false;
+
+	if (crtc_timing->h_border_right != hw_crtc_timing.h_border_right)
+		return false;
+
+	if (crtc_timing->h_front_porch != hw_crtc_timing.h_front_porch)
+		return false;
+
+	if (crtc_timing->h_sync_width != hw_crtc_timing.h_sync_width)
 		return false;
 
-	if (!tg->funcs->is_matching_timing(tg, crtc_timing))
+	if (crtc_timing->v_total != hw_crtc_timing.v_total)
+		return false;
+
+	if (crtc_timing->v_border_top != hw_crtc_timing.v_border_top)
+		return false;
+
+	if (crtc_timing->v_addressable != hw_crtc_timing.v_addressable)
+		return false;
+
+	if (crtc_timing->v_border_bottom != hw_crtc_timing.v_border_bottom)
+		return false;
+
+	if (crtc_timing->v_front_porch != hw_crtc_timing.v_front_porch)
+		return false;
+
+	if (crtc_timing->v_sync_width != hw_crtc_timing.v_sync_width)
 		return false;
 
 	if (dc_is_dp_signal(link->connector_signal)) {
@@ -1054,6 +1097,20 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 		if (crtc_timing->pix_clk_100hz != pix_clk_100hz)
 			return false;
 
+		if (!se->funcs->dp_get_pixel_format)
+			return false;
+
+		if (!se->funcs->dp_get_pixel_format(
+			se,
+			&hw_crtc_timing.pixel_encoding,
+			&hw_crtc_timing.display_color_depth))
+			return false;
+
+		if (hw_crtc_timing.display_color_depth != crtc_timing->display_color_depth)
+			return false;
+
+		if (hw_crtc_timing.pixel_encoding != crtc_timing->pixel_encoding)
+			return false;
 	}
 
 	return true;

commit deb79818e1b420ee593443230eafb932094f0674
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Sep 9 11:05:33 2019 -0400

    drm/amd/display: add explicit comparator as default optimization check
    
    [why]
    memcmp is vulnerable to regression due to dc_clocks structures not being
    organized properly (not "current" clock related structures being at the beginning
    of the structure) and causes unnecessary setting of the optimize bit
    
    [how]
    add a dcn sepcific comparator, implement for dcn2
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a56a989ee607..7ac68e77b32b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1681,8 +1681,16 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
 	}
 
-	if (type == UPDATE_TYPE_FAST && memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0)
-		dc->optimized_required = true;
+	if (type == UPDATE_TYPE_FAST) {
+		// If there's an available clock comparator, we use that.
+		if (dc->clk_mgr->funcs->are_clock_states_equal) {
+			if (!dc->clk_mgr->funcs->are_clock_states_equal(&dc->clk_mgr->clks, &dc->current_state->bw_ctx.bw.dcn.clk))
+				dc->optimized_required = true;
+		// Else we fallback to mem compare.
+		} else if (memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0) {
+			dc->optimized_required = true;
+		}
+	}
 
 	return type;
 }

commit 90d268741f74f7852ebc295c96212c6e992b2078
Author: Robin Singh <robin.singh@amd.com>
Date:   Thu Aug 22 14:42:49 2019 -0400

    drm/amd/display: Added pixel dynamic expansion control.
    
    [Why]
    To compare the crc of the framebuffer data at input of
    display pipeline with the crc of the otg, we need to
    disable pixel formatter's dynamic expansion feature during
    crc capture and keep it enable in the normal operation.
    
    [HOW]
    Expose a new interface in DM and dc for pixel formatter
    (fmt dynamic bitdepth expansion control). Interface control
    the FMT_DYNAMIC_EXP_EN  bit, during crc capture keep
    it disabled.
    
    Signed-off-by: Robin Singh <robin.singh@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f24f82b68694..a56a989ee607 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -411,6 +411,27 @@ bool dc_stream_get_crc(struct dc *dc, struct dc_stream_state *stream,
 	return false;
 }
 
+void dc_stream_set_dyn_expansion(struct dc *dc, struct dc_stream_state *stream,
+		enum dc_dynamic_expansion option)
+{
+	/* OPP FMT dyn expansion updates*/
+	int i = 0;
+	struct pipe_ctx *pipe_ctx;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (dc->current_state->res_ctx.pipe_ctx[i].stream
+				== stream) {
+			pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+			pipe_ctx->stream_res.opp->dyn_expansion = option;
+			pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
+					pipe_ctx->stream_res.opp,
+					COLOR_SPACE_YCBCR601,
+					stream->timing.display_color_depth,
+					stream->signal);
+		}
+	}
+}
+
 void dc_stream_set_dither_option(struct dc_stream_state *stream,
 		enum dc_dither_option option)
 {

commit d462fcf5012bdffb8f182eae01f73439bf4176f9
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 6 17:43:53 2019 -0400

    drm/amd/display: Update hdcp display config
    
    [Why]
    We need to update the hdcp display parameter whenever the link is
    updated, so the next time there is an update to hdcp we have the
    latest display info
    
    [How]
    Create a callback, and use this anytime there is a change in the link. This will
    be used later by the dm.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 098752059064..f24f82b68694 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -830,6 +830,16 @@ void dc_hardware_init(struct dc *dc)
 void dc_init_callbacks(struct dc *dc,
 		const struct dc_callback_init *init_params)
 {
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+	dc->ctx->cp_psp = init_params->cp_psp;
+#endif
+}
+
+void dc_deinit_callbacks(struct dc *dc)
+{
+#ifdef CONFIG_DRM_AMD_DC_HDCP
+	memset(&dc->ctx->cp_psp, 0, sizeof(dc->ctx->cp_psp));
+#endif
 }
 
 void dc_destroy(struct dc **dc)

commit 08b662793b90fc3a7e1d84d0fe0a5c04112731fd
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Sep 3 15:22:30 2019 -0400

    drm/amd/display: fix use of uninitialized variable
    
    tg_inst may be used uninitialized, so initialize it to 0.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jaehyun Chung <Jaehyun.Chung@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d5249814bea2..098752059064 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -974,7 +974,7 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 {
 	struct timing_generator *tg;
 	struct dc_link *link = sink->link;
-	unsigned int enc_inst, tg_inst, i;
+	unsigned int i, enc_inst, tg_inst = 0;
 
 	// Seamless port only support single DP and EDP so far
 	if (sink->sink_signal != SIGNAL_TYPE_DISPLAY_PORT &&

commit 7f7652ee8c8c1c21a1493171bb9996759edb8d46
Author: Martin Leung <martin.leung@amd.com>
Date:   Fri Aug 16 17:26:23 2019 -0400

    drm/amd/display: enable single dp seamless boot
    
    [why]
    seamless boot didn't work for non edp's before
    
    [how]
    removed edp-specific code, made dp read uefi-set link settings. Also fixed
    a hubbub code line to be consistent with usage of function.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a31c51423529..d5249814bea2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -974,29 +974,33 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 {
 	struct timing_generator *tg;
 	struct dc_link *link = sink->link;
-	unsigned int enc_inst, tg_inst;
+	unsigned int enc_inst, tg_inst, i;
+
+	// Seamless port only support single DP and EDP so far
+	if (sink->sink_signal != SIGNAL_TYPE_DISPLAY_PORT &&
+		sink->sink_signal != SIGNAL_TYPE_EDP)
+		return false;
 
 	/* Check for enabled DIG to identify enabled display */
 	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))
 		return false;
 
-	/* Check for which front end is used by this encoder.
-	 * Note the inst is 1 indexed, where 0 is undefined.
-	 * Note that DIG_FE can source from different OTG but our
-	 * current implementation always map 1-to-1, so this code makes
-	 * the same assumption and doesn't check OTG source.
-	 */
 	enc_inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);
 
-	/* Instance should be within the range of the pool */
-	if (enc_inst >= dc->res_pool->pipe_count)
+	if (enc_inst == ENGINE_ID_UNKNOWN)
 		return false;
 
-	if (enc_inst >= dc->res_pool->stream_enc_count)
-		return false;
+	for (i = 0; i < dc->res_pool->stream_enc_count; i++) {
+		if (dc->res_pool->stream_enc[i]->id == enc_inst) {
+			tg_inst = dc->res_pool->stream_enc[i]->funcs->dig_source_otg(
+				dc->res_pool->stream_enc[i]);
+			break;
+		}
+	}
 
-	tg_inst = dc->res_pool->stream_enc[enc_inst]->funcs->dig_source_otg(
-		dc->res_pool->stream_enc[enc_inst]);
+	// tg_inst not found
+	if (i == dc->res_pool->stream_enc_count)
+		return false;
 
 	if (tg_inst >= dc->res_pool->timing_generator_count)
 		return false;

commit 3a4d180d4a9df63144c6c069860b2be312c3256a
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Fri Aug 30 14:59:00 2019 -0400

    drm/amd/display: Optimize clocks on clock change
    
    [WHY]
    Presently, there is no way for clocks to be lowered, only raised.
    
    [HOW]
    Compare clock status against previous known clock status, and optimize
    if different.
    This requires re-ordering the layout of the dc_clocks structure, as the
    current ordering allows identical clock states to appear different.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index cbc4501d1c4a..a31c51423529 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1646,6 +1646,9 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
 	}
 
+	if (type == UPDATE_TYPE_FAST && memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0)
+		dc->optimized_required = true;
+
 	return type;
 }
 

commit 799c5b9cb91ca759df65707d2820b5fe1ee5383c
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Mon Aug 26 15:02:47 2019 -0400

    drm/amd/display: Revert fixup DPP programming sequence
    
    [WHY]
    This change was made because DTO programming was double-buffered, which
    is itself an issue. After deactivating the DTO double buffer, this
    change becomes unnecessary.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a31c51423529..cbc4501d1c4a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1646,9 +1646,6 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
 	}
 
-	if (type == UPDATE_TYPE_FAST && memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0)
-		dc->optimized_required = true;
-
 	return type;
 }
 

commit 98bf2f5262f15e16c09ac47bbf305577283242fb
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Mon Aug 12 18:47:50 2019 -0400

    drm/amd/display: Separate hardware initialization from creation
    
    [Why]
    Separating the hardware initialization from the creation of the
    dc structures gives greater flexibility to the dm to override
    options for debugging.
    
    [How]
    Move the hardware initialization call to a new function,
    dc_hardware_init. No functional change is intended.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d54f5b956809..a31c51423529 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -790,9 +790,6 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	if (false == construct(dc, init_params))
 		goto construct_fail;
 
-	/*TODO: separate HW and SW initialization*/
-	dc->hwss.init_hw(dc);
-
 	full_pipe_count = dc->res_pool->pipe_count;
 	if (dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
 		full_pipe_count--;
@@ -825,6 +822,11 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	return NULL;
 }
 
+void dc_hardware_init(struct dc *dc)
+{
+	dc->hwss.init_hw(dc);
+}
+
 void dc_init_callbacks(struct dc *dc,
 		const struct dc_callback_init *init_params)
 {

commit 119630061e72e6512ee8911b473cfacb6b211c53
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Thu Aug 15 15:22:34 2019 -0400

    drm/amd/display: remove hw access from dc_destroy
    
    [why]
    dc_destroy should only clean up SW, this is because GPUs may be
    removed before driver unload, leading to HW to be unavailable.
    
    [how]
    remove GPIO close as part of GPIO destroy, this is unnecessary because
    GPIO is not shared, and GPIOs are generally closed after being opened
    
    Add tracking to HW access during destructor to make future issues
    easier to pinpoint, and block access to prevent hangs.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index bd39f100a8a7..d54f5b956809 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1886,6 +1886,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_state *context)
 {
 	int j;
+	bool should_program_abm;
 
 	// Stream updates
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
@@ -1966,14 +1967,21 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			}
 
 			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
-				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
-					// if otg funcs defined check if blanked before programming
-					if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))
+				should_program_abm = true;
+
+				// if otg funcs defined check if blanked before programming
+				if (pipe_ctx->stream_res.tg->funcs->is_blanked)
+					if (pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))
+						should_program_abm = false;
+
+				if (should_program_abm) {
+					if (*stream_update->abm_level == ABM_LEVEL_IMMEDIATE_DISABLE) {
+						pipe_ctx->stream_res.abm->funcs->set_abm_immediate_disable(pipe_ctx->stream_res.abm);
+					} else {
 						pipe_ctx->stream_res.abm->funcs->set_abm_level(
 							pipe_ctx->stream_res.abm, stream->abm_level);
-				} else
-					pipe_ctx->stream_res.abm->funcs->set_abm_level(
-						pipe_ctx->stream_res.abm, stream->abm_level);
+					}
+				}
 			}
 		}
 	}

commit b6e881c947417e75272d3568cedf31f5ef016dcb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 13 18:00:28 2019 -0500

    drm/amd/display: update navi to use new surface programming behaviour
    
    New behaviour will track global updates and update any hw that isn't
    related to current stream being updated.
    
    This should fix any issues caused by pipe split pipes being taken
    by other streams.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5d1adeda4d90..bd39f100a8a7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -761,8 +761,13 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 			disable_all_writeback_pipes_for_stream(dc, old_stream, dangling_context);
 #endif
-			dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
+			if (dc->hwss.apply_ctx_for_surface)
+				dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
 		}
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		if (dc->hwss.program_front_end_for_ctx)
+			dc->hwss.program_front_end_for_ctx(dc, dangling_context);
+#endif
 	}
 
 	current_ctx = dc->current_state;
@@ -1073,15 +1078,20 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use
 	 */
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->streams[i]->mode_changed)
-			continue;
+	if (dc->hwss.apply_ctx_for_surface)
+		for (i = 0; i < context->stream_count; i++) {
+			if (context->streams[i]->mode_changed)
+				continue;
 
-		dc->hwss.apply_ctx_for_surface(
-			dc, context->streams[i],
-			context->stream_status[i].plane_count,
-			context); /* use new pipe config in new context */
-	}
+			dc->hwss.apply_ctx_for_surface(
+				dc, context->streams[i],
+				context->stream_status[i].plane_count,
+				context); /* use new pipe config in new context */
+		}
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (dc->hwss.program_front_end_for_ctx)
+		dc->hwss.program_front_end_for_ctx(dc, context);
+#endif
 
 	/* Program hardware */
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
@@ -1100,16 +1110,21 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	}
 
 	/* Program all planes within new context*/
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (dc->hwss.program_front_end_for_ctx)
+		dc->hwss.program_front_end_for_ctx(dc, context);
+#endif
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_link *link = context->streams[i]->link;
 
 		if (!context->streams[i]->mode_changed)
 			continue;
 
-		dc->hwss.apply_ctx_for_surface(
-				dc, context->streams[i],
-				context->stream_status[i].plane_count,
-				context);
+		if (dc->hwss.apply_ctx_for_surface)
+			dc->hwss.apply_ctx_for_surface(
+					dc, context->streams[i],
+					context->stream_status[i].plane_count,
+					context);
 
 		/*
 		 * enable stereo
@@ -1492,20 +1507,15 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 	union surface_update_flags *update_flags = &u->surface->update_flags;
 
-	update_flags->raw = 0; // Reset all flags
-
 	if (u->flip_addr)
 		update_flags->bits.addr_update = 1;
 
-	if (!is_surface_in_context(context, u->surface)) {
-		update_flags->bits.new_plane = 1;
+	if (!is_surface_in_context(context, u->surface) || u->surface->force_full_update) {
+		update_flags->raw = 0xFFFFFFFF;
 		return UPDATE_TYPE_FULL;
 	}
 
-	if (u->surface->force_full_update) {
-		update_flags->bits.full_update = 1;
-		return UPDATE_TYPE_FULL;
-	}
+	update_flags->raw = 0; // Reset all flags
 
 	type = get_plane_info_update_type(u);
 	elevate_update_type(&overall_type, type);
@@ -1563,40 +1573,43 @@ static enum surface_update_type check_update_surfaces_for_stream(
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
 	if (stream_status == NULL || stream_status->plane_count != surface_count)
-		return UPDATE_TYPE_FULL;
+		overall_type = UPDATE_TYPE_FULL;
 
 	/* some stream updates require passive update */
 	if (stream_update) {
-		if ((stream_update->src.height != 0) &&
-				(stream_update->src.width != 0))
-			return UPDATE_TYPE_FULL;
+		union stream_update_flags *su_flags = &stream_update->stream->update_flags;
 
-		if ((stream_update->dst.height != 0) &&
-				(stream_update->dst.width != 0))
-			return UPDATE_TYPE_FULL;
+		if ((stream_update->src.height != 0 && stream_update->src.width != 0) ||
+				(stream_update->dst.height != 0 && stream_update->dst.width != 0))
+			su_flags->bits.scaling = 1;
 
 		if (stream_update->out_transfer_func)
-			return UPDATE_TYPE_FULL;
+			su_flags->bits.out_tf = 1;
 
 		if (stream_update->abm_level)
-			return UPDATE_TYPE_FULL;
+			su_flags->bits.abm_level = 1;
 
 		if (stream_update->dpms_off)
-			return UPDATE_TYPE_FULL;
+			su_flags->bits.dpms_off = 1;
+
+		if (stream_update->gamut_remap)
+			su_flags->bits.gamut_remap = 1;
 
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 		if (stream_update->wb_update)
-			return UPDATE_TYPE_FULL;
+			su_flags->bits.wb_update = 1;
 #endif
+		if (su_flags->raw != 0)
+			overall_type = UPDATE_TYPE_FULL;
+
+		if (stream_update->output_csc_transform || stream_update->output_color_space)
+			su_flags->bits.out_csc = 1;
 	}
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
 				det_surface_update(dc, &updates[i]);
 
-		if (type == UPDATE_TYPE_FULL)
-			return type;
-
 		elevate_update_type(&overall_type, type);
 	}
 
@@ -1618,13 +1631,18 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	int i;
 	enum surface_update_type type;
 
+	if (stream_update)
+		stream_update->stream->update_flags.raw = 0;
 	for (i = 0; i < surface_count; i++)
 		updates[i].surface->update_flags.raw = 0;
 
 	type = check_update_surfaces_for_stream(dc, updates, surface_count, stream_update, stream_status);
-	if (type == UPDATE_TYPE_FULL)
+	if (type == UPDATE_TYPE_FULL) {
+		if (stream_update)
+			stream_update->stream->update_flags.raw = 0xFFFFFFFF;
 		for (i = 0; i < surface_count; i++)
 			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
+	}
 
 	if (type == UPDATE_TYPE_FAST && memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0)
 		dc->optimized_required = true;
@@ -2000,7 +2018,13 @@ static void commit_planes_for_stream(struct dc *dc,
 		 * In case of turning off screen, no need to program front end a second time.
 		 * just return after program blank.
 		 */
-		dc->hwss.apply_ctx_for_surface(dc, stream, 0, context);
+		if (dc->hwss.apply_ctx_for_surface)
+			dc->hwss.apply_ctx_for_surface(dc, stream, 0, context);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		if (dc->hwss.program_front_end_for_ctx)
+			dc->hwss.program_front_end_for_ctx(dc, context);
+#endif
+
 		return;
 	}
 
@@ -2060,10 +2084,15 @@ static void commit_planes_for_stream(struct dc *dc,
 			stream_status =
 				stream_get_status(context, pipe_ctx->stream);
 
-			dc->hwss.apply_ctx_for_surface(
+			if (dc->hwss.apply_ctx_for_surface)
+				dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
 		}
 	}
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (dc->hwss.program_front_end_for_ctx && update_type != UPDATE_TYPE_FAST)
+		dc->hwss.program_front_end_for_ctx(dc, context);
+#endif
 
 	// Update Type FAST, Surface updates
 	if (update_type == UPDATE_TYPE_FAST) {

commit 1b2c7b2c6d615791a38be33d9e2d32a2736e70cb
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Jul 26 17:09:35 2019 -0400

    drm/amd/display: call update_bw_bounding_box
    
    call update_bw_bounding_box in DC construct
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 87ca5a290d12..5d1adeda4d90 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -689,6 +689,11 @@ static bool construct(struct dc *dc,
 	if (!dc->clk_mgr)
 		goto fail;
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_1
+	if (dc->res_pool->funcs->update_bw_bounding_box)
+		dc->res_pool->funcs->update_bw_bounding_box(dc, dc->clk_mgr->bw_params);
+#endif
+
 	/* Creation of current_state must occur after dc->dml
 	 * is initialized in dc_create_resource_pool because
 	 * on creation it copies the contents of dc->dml

commit 470e2ca569bf780f832e3020ceb5afdef16a9084
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Thu Aug 8 11:08:52 2019 -0400

    drm/amd/display: Expose OTG_V_TOTAL_MID for HW Diags
    
    [Why]
    Existing HW Features, HW Diags test requested that the
    registers be exposed.
    
    [How]
    Add V_TOTAL_MID to existing DC structures.
    Make sure values are passed down throughout DC
    Add Register definition.
    Program the additional registers
    Add additional Logic for V_TOTAL_CONTROL.
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 82c07d82e937..87ca5a290d12 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -291,7 +291,9 @@ bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 			dc->hwss.set_drr(&pipe,
 					1,
 					adjust->v_total_min,
-					adjust->v_total_max);
+					adjust->v_total_max,
+					adjust->v_total_mid,
+					adjust->v_total_mid_frame_num);
 
 			ret = true;
 		}

commit 285e30049708c40a8b0221438d0300cb19a68eff
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 15:10:33 2019 -0400

    drm/amd/display: fix dcn20 odm dpp programming
    
    dcn20 requires special casing for odm.
    This change treats odm as alternative to mpc tree on dcn20.
    
    This is planned to be fixed in a future refactor
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b0ae9d2aad0e..82c07d82e937 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2026,6 +2026,7 @@ static void commit_planes_for_stream(struct dc *dc,
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 		if (!pipe_ctx->top_pipe &&
+			!pipe_ctx->prev_odm_pipe &&
 			pipe_ctx->stream &&
 			pipe_ctx->stream == stream) {
 			struct dc_stream_status *stream_status = NULL;

commit 24d01c9b32547acf7261585aefb5c953930ed0fd
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Aug 2 16:32:13 2019 -0400

    drm/amd/display: fix odm pipe copy
    
    ODM next and prev pipe were missing from dc_copy_state
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 84f12e13c900..b0ae9d2aad0e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1230,6 +1230,12 @@ struct dc_state *dc_copy_state(struct dc_state *src_ctx)
 			if (cur_pipe->bottom_pipe)
 				cur_pipe->bottom_pipe = &new_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
 
+			if (cur_pipe->prev_odm_pipe)
+				cur_pipe->prev_odm_pipe =  &new_ctx->res_ctx.pipe_ctx[cur_pipe->prev_odm_pipe->pipe_idx];
+
+			if (cur_pipe->next_odm_pipe)
+				cur_pipe->next_odm_pipe = &new_ctx->res_ctx.pipe_ctx[cur_pipe->next_odm_pipe->pipe_idx];
+
 	}
 
 	for (i = 0; i < new_ctx->stream_count; i++) {

commit 574304041bb9508a4e73533e8d1702b0e713d321
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu Jul 25 14:43:55 2019 -0400

    drm/amd/display: fix audio endpoint not getting disabled issue
    
    [Why]
    Disable_audio_stream gets enum option as a paramenter which will decide
    if we free acquired resources or not. However checks for the option is
    guarded by the other condition which check if audio stream is getting
    diabled more than once. With both conditions combined, if we attempt to
    disable audio stream twice in a row, first with keep and second with
    free as an option, we will never free any resources, which will make
    system think there is audio endpoint connected even after we plug out
    the device
    
    [How]
    Get rid of option as parameter to disable_audio_stream and move the part
    of the code that free acquired resources to outside where to keep or to
    free resources is actually determined
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f09811c0bf02..84f12e13c900 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1918,7 +1918,11 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
 
 				if (*stream_update->dpms_off) {
-					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
+					core_link_disable_stream(pipe_ctx);
+					/* for dpms, keep acquired resources*/
+					if (pipe_ctx->stream_res.audio && !dc->debug.az_endpoint_mute_only)
+						pipe_ctx->stream_res.audio->funcs->az_disable(pipe_ctx->stream_res.audio);
+
 					dc->hwss.optimize_bandwidth(dc, dc->current_state);
 				} else {
 					if (!dc->optimize_seamless_boot)

commit b1f6d01c4a3b7eeb2eb035e79d425cd6a696fa45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 17:17:28 2019 -0400

    drm/amd/display: re structure odm to allow 4 to 1 support
    
    Currently odm is handled using top_bottom pipe by special casing
    the differing opps to differentiate from mpc combine.
    
    Since top/bottom pipe list was made to track mpc muxing this creates
    difficulties in adding a 4 pipe odm case support.
    
    Rather than continue using mpc combine list, this change reworks odm
    to use it's own linked list to keep track of odm combine pipes. This
    also opens up options for using mpo with odm, if a practical use case
    is ever found.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 55505b9f8ab4..f09811c0bf02 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1860,9 +1860,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (!pipe_ctx->top_pipe &&
-			pipe_ctx->stream &&
-			pipe_ctx->stream == stream) {
+		if (!pipe_ctx->top_pipe &&  !pipe_ctx->prev_odm_pipe && pipe_ctx->stream == stream) {
 
 			if (stream_update->periodic_interrupt0 &&
 					dc->hwss.setup_periodic_interrupt)
@@ -1888,7 +1886,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 			if (stream_update->dither_option) {
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
-				struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
+				struct pipe_ctx *odm_pipe = pipe_ctx->next_odm_pipe;
 #endif
 				resource_build_bit_depth_reduction_params(pipe_ctx->stream,
 									&pipe_ctx->stream->bit_depth_params);
@@ -1896,10 +1894,12 @@ static void commit_planes_do_stream_update(struct dc *dc,
 						&stream->bit_depth_params,
 						&stream->clamping);
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
-				if (odm_pipe)
+				while (odm_pipe) {
 					odm_pipe->stream_res.opp->funcs->opp_program_fmt(odm_pipe->stream_res.opp,
 							&stream->bit_depth_params,
 							&stream->clamping);
+					odm_pipe = odm_pipe->next_odm_pipe;
+				}
 #endif
 			}
 

commit 5cb99d46f7bdf02cacf08ea9d4301aff0cd311a6
Author: David Francis <David.Francis@amd.com>
Date:   Thu May 23 14:25:35 2019 -0400

    Revert "drm/amd/display: Fix underscan not using proper scaling"
    
    This reverts commit 80e80ec817f161560b4159608fb41bd289abede3.
    
    This commit fixed an issue with underscan commits not updating all
    needed timing values, but through various refactors it is no longer
    necessary. It causes corruption on odm combine by
    overwriting the halved h_active in the stream timing
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4a2c7e9c56c0..55505b9f8ab4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2130,7 +2130,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 	enum surface_update_type update_type;
 	struct dc_state *context;
 	struct dc_context *dc_ctx = dc->ctx;
-	int i, j;
+	int i;
 
 	stream_status = dc_stream_get_status(stream);
 	context = dc->current_state;
@@ -2168,16 +2168,6 @@ void dc_commit_updates_for_stream(struct dc *dc,
 
 		copy_surface_update_to_plane(surface, &srf_updates[i]);
 
-		if (update_type >= UPDATE_TYPE_MED) {
-			for (j = 0; j < dc->res_pool->pipe_count; j++) {
-				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-
-				if (pipe_ctx->plane_state != surface)
-					continue;
-
-				resource_build_scaling_params(pipe_ctx);
-			}
-		}
 	}
 
 	copy_stream_update_to_stream(dc, context, stream, stream_update);

commit 6d83a32d0bdd39cdcc0d70d7b719cd2ffb419268
Author: Michael Strauss <michael.strauss@amd.com>
Date:   Fri Jul 26 12:04:12 2019 -0400

    drm/amd/display: Enable MPO with pre-blend color processing (RGB)
    
    [Why]
    DCN10 performs color processing before MPC combination, causes color
    shift in RGB colorspaces when positive brightness offset is applied
    However, YCbCr is still unfixed and remains disabled
    
    [How]
    Add layerIndex to dc_plane_state and dc_plane_info structs
    Re-enable MPO when brightness is adjusted and colorspace is not YCbCr
    Set rear plane's brightness offset to 0 when front plane visible
    
    Signed-off-by: Michael Strauss <michael.strauss@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e79ee114ab57..4a2c7e9c56c0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1692,6 +1692,8 @@ static void copy_surface_update_to_plane(
 				srf_update->plane_info->dcc;
 		surface->sdr_white_level =
 				srf_update->plane_info->sdr_white_level;
+		surface->layer_index =
+				srf_update->plane_info->layer_index;
 	}
 
 	if (srf_update->gamma &&

commit e5382701c3520b3ed66169a6e4aa6ce5df8c56e0
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Mon Jul 22 15:23:32 2019 -0400

    drm/amd/display: reprogram VM config when system resume
    
    [Why]
    The vm config will be clear to 0 when system enter S4. It will
    cause hubbub didn't know how to fetch data when system resume.
    The flip always pending because earliest_inuse_address and
    request_address are different.
    
    [How]
    Reprogram VM config when system resume
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 760384561180..e79ee114ab57 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2265,6 +2265,14 @@ void dc_set_power_state(
 		dc_resource_state_construct(dc, dc->current_state);
 
 		dc->hwss.init_hw(dc);
+
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+		if (dc->hwss.init_sys_ctx != NULL &&
+			dc->vm_pa_config.valid) {
+			dc->hwss.init_sys_ctx(dc->hwseq, dc, &dc->vm_pa_config);
+		}
+#endif
+
 		break;
 	default:
 		ASSERT(dc->current_state->stream_count == 0);

commit 5ec43eda85506ddc2f91c3a4e28b38da3f14cf1e
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Jul 17 16:08:19 2019 -0400

    drm/amd/display: enabling seamless boot sequence for dcn2
    
    [Why]
    Seamless boot (building SW state inheriting BIOS-initialized timing) was
    enabled on DCN2, including fixes
    
    [How]
    Includes fixes for MPC, DPPCLK, and DIG FE mapping/OTG source select/
    Pixel clock.
    
    This is part 2 of 2 for seamless boot NV10
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f61eb296542a..760384561180 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -960,7 +960,7 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 {
 	struct timing_generator *tg;
 	struct dc_link *link = sink->link;
-	unsigned int inst;
+	unsigned int enc_inst, tg_inst;
 
 	/* Check for enabled DIG to identify enabled display */
 	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))
@@ -972,13 +972,22 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 	 * current implementation always map 1-to-1, so this code makes
 	 * the same assumption and doesn't check OTG source.
 	 */
-	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc) - 1;
+	enc_inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);
 
 	/* Instance should be within the range of the pool */
-	if (inst >= dc->res_pool->pipe_count)
+	if (enc_inst >= dc->res_pool->pipe_count)
 		return false;
 
-	tg = dc->res_pool->timing_generators[inst];
+	if (enc_inst >= dc->res_pool->stream_enc_count)
+		return false;
+
+	tg_inst = dc->res_pool->stream_enc[enc_inst]->funcs->dig_source_otg(
+		dc->res_pool->stream_enc[enc_inst]);
+
+	if (tg_inst >= dc->res_pool->timing_generator_count)
+		return false;
+
+	tg = dc->res_pool->timing_generators[tg_inst];
 
 	if (!tg->funcs->is_matching_timing)
 		return false;
@@ -991,10 +1000,11 @@ bool dc_validate_seamless_boot_timing(const struct dc *dc,
 
 		dc->res_pool->dp_clock_source->funcs->get_pixel_clk_frequency_100hz(
 			dc->res_pool->dp_clock_source,
-			inst, &pix_clk_100hz);
+			tg_inst, &pix_clk_100hz);
 
 		if (crtc_timing->pix_clk_100hz != pix_clk_100hz)
 			return false;
+
 	}
 
 	return true;
@@ -1904,13 +1914,17 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 			if (stream_update->dpms_off) {
 				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
+
 				if (*stream_update->dpms_off) {
 					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
 					dc->hwss.optimize_bandwidth(dc, dc->current_state);
 				} else {
-					dc->hwss.prepare_bandwidth(dc, dc->current_state);
+					if (!dc->optimize_seamless_boot)
+						dc->hwss.prepare_bandwidth(dc, dc->current_state);
+
 					core_link_enable_stream(dc->current_state, pipe_ctx);
 				}
+
 				dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
 			}
 

commit f7f38ffef56b0138f902efd261a6d90680fec2d3
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Jul 15 10:41:47 2019 -0400

    drm/amd/display: fixup DPP programming sequence
    
    [why]
    DC does not correct account for the fact that DPP DTO is double buffered while DPP ref is not.
    This means that when DPP ref clock is lowered when it's "safe to lower", the DPP blocks that need
    an increased divider will temporarily have actual DPP clock drop below minimum while DTO
    double buffering takes effect.  This results in temporary underflow.
    
    [how]
    To fix this, DPP clock cannot be programmed atomically, but rather be broken up into the DTO and the
    ref.  Each has a separate "safe to lower" logic.  When doing "prepare" the ref and dividers may only increase.
    When doing "optimize", both may decrease.  It is guaranteed that we won't exceed max DPP clock because
    we do not use dividers larger than 1.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 21fb7ee17c9c..f61eb296542a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1603,6 +1603,9 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		for (i = 0; i < surface_count; i++)
 			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
 
+	if (type == UPDATE_TYPE_FAST && memcmp(&dc->current_state->bw_ctx.bw.dcn.clk, &dc->clk_mgr->clks, offsetof(struct dc_clocks, prev_p_state_change_support)) != 0)
+		dc->optimized_required = true;
+
 	return type;
 }
 

commit 44f3dd09a8a103018df199345c669978a90c10c1
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Aug 8 00:29:23 2019 -0500

    drm/amd/display: use kvmalloc for dc_state (v2)
    
    It's large and doesn't need contiguous memory.  Fixes
    allocation failures in some cases.
    
    v2: kvfree the memory.
    
    Reviewed-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 252b621d93a9..21fb7ee17c9c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -23,6 +23,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/mm.h>
 
 #include "dm_services.h"
 
@@ -1183,8 +1184,8 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 struct dc_state *dc_create_state(struct dc *dc)
 {
-	struct dc_state *context = kzalloc(sizeof(struct dc_state),
-					   GFP_KERNEL);
+	struct dc_state *context = kvzalloc(sizeof(struct dc_state),
+					    GFP_KERNEL);
 
 	if (!context)
 		return NULL;
@@ -1204,11 +1205,11 @@ struct dc_state *dc_create_state(struct dc *dc)
 struct dc_state *dc_copy_state(struct dc_state *src_ctx)
 {
 	int i, j;
-	struct dc_state *new_ctx = kmemdup(src_ctx,
-			sizeof(struct dc_state), GFP_KERNEL);
+	struct dc_state *new_ctx = kvmalloc(sizeof(struct dc_state), GFP_KERNEL);
 
 	if (!new_ctx)
 		return NULL;
+	memcpy(new_ctx, src_ctx, sizeof(struct dc_state));
 
 	for (i = 0; i < MAX_PIPES; i++) {
 			struct pipe_ctx *cur_pipe = &new_ctx->res_ctx.pipe_ctx[i];
@@ -1242,7 +1243,7 @@ static void dc_state_free(struct kref *kref)
 {
 	struct dc_state *context = container_of(kref, struct dc_state, refcount);
 	dc_resource_state_destruct(context);
-	kfree(context);
+	kvfree(context);
 }
 
 void dc_release_state(struct dc_state *context)

commit 87abff77880da827b8c9acb37e241999183b406f
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jul 23 15:23:12 2019 +0100

    drm/amd/display: fix a missing null check on a failed kzalloc
    
    Currently the allocation of config may fail and a null pointer
    dereference on config can occur.  Fix this by added a null
    check on a failed allocation of config.
    
    Addresses-Coverity: ("Dereference null return")
    Fixes: c2cd9d04ecf0 ("drm/amd/display: Hook up calls to do stereo mux and dig programming to stereo control interface")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 94f126d2331c..252b621d93a9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1259,6 +1259,8 @@ bool dc_set_generic_gpio_for_stereo(bool enable,
 	struct gpio_generic_mux_config *config = kzalloc(sizeof(struct gpio_generic_mux_config),
 			   GFP_KERNEL);
 
+	if (!config)
+		return false;
 	pin_info = dal_gpio_get_generic_pin_info(gpio_service, GPIO_ID_GENERIC, 0);
 
 	if (pin_info.mask == 0xFFFFFFFF || pin_info.offset == 0xFFFFFFFF) {

commit 291ac8fb0cd934104b1d154220695ec049592a25
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Tue Jul 2 22:33:34 2019 -0500

    drm/amd/display: Add debug entry to destroy disconnected edp link
    
    Add a flag to dc_debug_options to determine if a disconnected edp link
    should be destroyed.
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d6a0a08f5cda..94f126d2331c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -180,13 +180,25 @@ static bool create_links(
 		link = link_create(&link_init_params);
 
 		if (link) {
-			if (dc->config.edp_not_connected &&
-					link->connector_signal == SIGNAL_TYPE_EDP) {
-				link_destroy(&link);
-			} else {
+			bool should_destory_link = false;
+
+			if (link->connector_signal == SIGNAL_TYPE_EDP) {
+				if (dc->config.edp_not_connected)
+					should_destory_link = true;
+				else if (dc->debug.remove_disconnect_edp) {
+					enum dc_connection_type type;
+					dc_link_detect_sink(link, &type);
+					if (type == dc_connection_none)
+						should_destory_link = true;
+				}
+			}
+
+			if (!should_destory_link) {
 				dc->links[dc->link_count] = link;
 				link->dc = dc;
 				++dc->link_count;
+			} else {
+				link_destroy(&link);
 			}
 		}
 	}

commit 8897810adfa768b0c127c1e204bedc4449e3f945
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Tue Jun 25 14:55:53 2019 -0400

    drm/amd/display: Fix dc_create failure handling and 666 color depths
    
    [Why]
    It is possible (but very unlikely) that constructing dc fails
    before current_state is created.
    
    We support 666 color depth in some scenarios, but this
    isn't handled in get_norm_pix_clk. It uses exactly the
    same pixel clock as the 888 case.
    
    [How]
    Check for non null current_state before destructing.
    
    Add case for 666 color depth to get_norm_pix_clk to
    avoid assertion.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4b1d314f2939..d6a0a08f5cda 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -502,8 +502,10 @@ void dc_stream_set_static_screen_events(struct dc *dc,
 
 static void destruct(struct dc *dc)
 {
-	dc_release_state(dc->current_state);
-	dc->current_state = NULL;
+	if (dc->current_state) {
+		dc_release_state(dc->current_state);
+		dc->current_state = NULL;
+	}
 
 	destroy_links(dc);
 

commit 12e2b2d4c65f6164830e25fcd9624519a424b182
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 3 16:20:42 2019 -0400

    drm/amd/display: add dcc programming for dual plane
    
    Add dual plane dcc programming support for
    surfaces.
    
    Removes unions from plane size and dcc params as they
    serve no practical purpose only making our code
    more convoluted. This results in easy dual plane
    dcc and surface size programming.
    
    Temporary diags_dm code is used to handle the interface
    change without breaking functionality as a diags change
    needs to be applied after this one.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c86c86c07fd9..4b1d314f2939 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1349,8 +1349,8 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	}
 
 	if (u->plane_info->dcc.enable != u->surface->dcc.enable
-			|| u->plane_info->dcc.grph.independent_64b_blks != u->surface->dcc.grph.independent_64b_blks
-			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch) {
+			|| u->plane_info->dcc.independent_64b_blks != u->surface->dcc.independent_64b_blks
+			|| u->plane_info->dcc.meta_pitch != u->surface->dcc.meta_pitch) {
 		update_flags->bits.dcc_change = 1;
 		elevate_update_type(&update_type, UPDATE_TYPE_MED);
 	}
@@ -1364,9 +1364,9 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
 	}
 
-	if (u->plane_info->plane_size.grph.surface_pitch != u->surface->plane_size.grph.surface_pitch
-			|| u->plane_info->plane_size.video.luma_pitch != u->surface->plane_size.video.luma_pitch
-			|| u->plane_info->plane_size.video.chroma_pitch != u->surface->plane_size.video.chroma_pitch) {
+	if (u->plane_info->plane_size.surface_pitch != u->surface->plane_size.surface_pitch
+			|| u->plane_info->plane_size.surface_pitch != u->surface->plane_size.surface_pitch
+			|| u->plane_info->plane_size.chroma_pitch != u->surface->plane_size.chroma_pitch) {
 		update_flags->bits.plane_size_change = 1;
 		elevate_update_type(&update_type, UPDATE_TYPE_MED);
 	}

commit 925f566cb7aedbcf26005035cf894ec824e8ca2f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jun 27 18:16:21 2019 -0400

    drm/amd/display: add set and get clock for testing purposes
    
    add dc_set_clock
    add dc_get_clock
    
    this is for testing and diagnostics to get/set DPPCLK and DISPCLK.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a8516deb5ac3..c86c86c07fd9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2431,3 +2431,14 @@ void get_clock_requirements_for_state(struct dc_state *state, struct AsicStateEx
 	info->fClock					= (unsigned int)state->bw_ctx.bw.dcn.clk.fclk_khz;
 	info->phyClock					= (unsigned int)state->bw_ctx.bw.dcn.clk.phyclk_khz;
 }
+enum dc_status dc_set_clock(struct dc *dc, enum dc_clock_type clock_type, uint32_t clk_khz, uint32_t stepping)
+{
+	if (dc->hwss.set_clock)
+		return dc->hwss.set_clock(dc, clock_type, clk_khz, stepping);
+	return DC_ERROR_UNEXPECTED;
+}
+void dc_get_clock(struct dc *dc, enum dc_clock_type clock_type, struct dc_clock_config *clock_cfg)
+{
+	if (dc->hwss.get_clock)
+		dc->hwss.get_clock(dc, clock_type, clock_cfg);
+}

commit c2cd9d04ecf0f26fb472ffbd8274a55c05df0ffb
Author: Murton Liu <murton.liu@amd.com>
Date:   Tue Jun 25 11:15:09 2019 -0400

    drm/amd/display: Hook up calls to do stereo mux and dig programming to stereo control interface
    
    [Why]
    Implementation of stereo mux register is complete, but unused. Need to
    call functions to write relevant configs.
    
    [How]
    Add function to write stereo config for enable/disable case and call in
    stereo control interface.
    
    Signed-off-by: Murton Liu <murton.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 32fd9184ef22..a8516deb5ac3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1236,6 +1236,53 @@ void dc_release_state(struct dc_state *context)
 	kref_put(&context->refcount, dc_state_free);
 }
 
+bool dc_set_generic_gpio_for_stereo(bool enable,
+		struct gpio_service *gpio_service)
+{
+	enum gpio_result gpio_result = GPIO_RESULT_NON_SPECIFIC_ERROR;
+	struct gpio_pin_info pin_info;
+	struct gpio *generic;
+	struct gpio_generic_mux_config *config = kzalloc(sizeof(struct gpio_generic_mux_config),
+			   GFP_KERNEL);
+
+	pin_info = dal_gpio_get_generic_pin_info(gpio_service, GPIO_ID_GENERIC, 0);
+
+	if (pin_info.mask == 0xFFFFFFFF || pin_info.offset == 0xFFFFFFFF) {
+		kfree(config);
+		return false;
+	} else {
+		generic = dal_gpio_service_create_generic_mux(
+			gpio_service,
+			pin_info.offset,
+			pin_info.mask);
+	}
+
+	if (!generic) {
+		kfree(config);
+		return false;
+	}
+
+	gpio_result = dal_gpio_open(generic, GPIO_MODE_OUTPUT);
+
+	config->enable_output_from_mux = enable;
+	config->mux_select = GPIO_SIGNAL_SOURCE_PASS_THROUGH_STEREO_SYNC;
+
+	if (gpio_result == GPIO_RESULT_OK)
+		gpio_result = dal_mux_setup_config(generic, config);
+
+	if (gpio_result == GPIO_RESULT_OK) {
+		dal_gpio_close(generic);
+		dal_gpio_destroy_generic_mux(&generic);
+		kfree(config);
+		return true;
+	} else {
+		dal_gpio_close(generic);
+		dal_gpio_destroy_generic_mux(&generic);
+		kfree(config);
+		return false;
+	}
+}
+
 static bool is_surface_in_context(
 		const struct dc_state *context,
 		const struct dc_plane_state *plane_state)

commit 70f1476a7eedf85078f5b5a3b2647591f6df4d17
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Fri May 17 14:43:10 2019 -0400

    drm/amd/display: Add debug option to disable timing sync
    
    [Why]
    We want a debug option to disable timing sync for testing.
    
    [How]
    New dc debug option that must be false to call program_timing_sync
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4ef4dc63e221..32fd9184ef22 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1062,7 +1062,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (result != DC_OK)
 		return result;
 
-	if (context->stream_count > 1) {
+	if (context->stream_count > 1 && !dc->debug.disable_timing_sync) {
 		enable_timing_multisync(dc, context);
 		program_timing_sync(dc, context);
 	}

commit d12c202289b07037da285299b4122fa2072eca96
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Thu Jul 4 00:27:18 2019 +0800

    drm/amdgpu: Use kmemdup rather than duplicating its implementation
    
    kmemdup is introduced to duplicate a region of memory in a neat way.
    Rather than kmalloc/kzalloc + memcpy, which the programmer needs to
    write the size twice (sometimes lead to mistakes), kmemdup improves
    readability, leads to smaller code and also reduce the chances of mistakes.
    Suggestion to use kmemdup rather than using kmalloc/kzalloc + memcpy.
    
    Reviewed-by: Christian König <Christian.Koenig@amd.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 14c4c60c59db..4ef4dc63e221 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1190,14 +1190,12 @@ struct dc_state *dc_create_state(struct dc *dc)
 struct dc_state *dc_copy_state(struct dc_state *src_ctx)
 {
 	int i, j;
-	struct dc_state *new_ctx = kzalloc(sizeof(struct dc_state),
-					   GFP_KERNEL);
+	struct dc_state *new_ctx = kmemdup(src_ctx,
+			sizeof(struct dc_state), GFP_KERNEL);
 
 	if (!new_ctx)
 		return NULL;
 
-	memcpy(new_ctx, src_ctx, sizeof(struct dc_state));
-
 	for (i = 0; i < MAX_PIPES; i++) {
 			struct pipe_ctx *cur_pipe = &new_ctx->res_ctx.pipe_ctx[i];
 

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit bda9afdacf8942c313a47cc95582737345a91c5e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 22 18:05:41 2019 -0400

    drm/amd/display: move vmid determination logic to a module
    
    Currently vmid is decided internally inside dc. With the introduction
    of new asics we are required to coordinate vmid use with external
    components.
    
    This change converts vmid logic to a DAL module allowing vmid to be
    passed in as a parameter to DC.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8bc8ac3a7718..a29bb9bf3f9c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -808,26 +808,6 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
-#ifdef CONFIG_DRM_AMD_DC_DCN2_0
-bool dc_init_memory_hub(struct dc *dc, struct dc_addr_space_config *config)
-{
-	// Memory hub init isn't done as part of dc_create because in windows, dal/dc is
-	// constructed before the vm config is setup in kmd so there's no way
-	// they can give it to us at boot/dc_create
-	bool vmSupported;
-
-	// Call HWSS to setup HUBBUB for address config
-	dc->hwss.init_dchub(dc->hwseq, dc, config);
-
-	// Pre-init system aperture start/end for all HUBP instances (if not gating?)
-	// or cache system aperture if using power gating
-	memcpy(&dc->vm_config, config, sizeof(struct dc_addr_space_config));
-
-	vmSupported = (dc->ctx->asic_id.chip_family == FAMILY_NV) ? true : false;
-	return vmSupported;
-}
-
-#endif
 static void enable_timing_multisync(
 		struct dc *dc,
 		struct dc_state *ctx)

commit 6f4992b0e2db5f8a182bfb75e710ce47555b10ff
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue May 14 09:19:01 2019 -0400

    drm/amd/display: Copy stream updates onto streams
    
    [Why]
    Almost every function in DC that works with stream state expects that
    the current state on the stream is the one that it should be writing
    out. These functions are typically triggered by specifying a particular
    stream update - but the actual contents of the stream update itself
    are ignored, leaving it to the DM to actually update the stream state
    itself.
    
    The problem with doing this in DM is a matter of timing. On Linux
    most of this is incorrectly done in atomic check, when we actually want
    it to be done during atomic commit tail while access to DC is locked.
    
    To give an example, a commit requesting to modify color management
    state for DM could come in, be rejected, but still have modified
    the actual system state for the stream since it's shared memory. The
    next time color management gets programmed it'll use the rejected
    color management info - which might not even still be around if it's
    a custom transfer function.
    
    So a reasonable place to perform this is within DC itself and this is
    the model that's currently in use for surface updates. DC can even
    compare the current system state to the incoming surface update to
    determine update level, something that can't currnetly be done with the
    framework for stream updates.
    
    [How]
    Duplicate the framework used for surface updates for stream updates
    as well. Copy all the updates after checking the update type.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8cecd58653cf..8bc8ac3a7718 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1694,6 +1694,101 @@ static void copy_surface_update_to_plane(
 			*srf_update->coeff_reduction_factor;
 }
 
+static void copy_stream_update_to_stream(struct dc *dc,
+					 struct dc_state *context,
+					 struct dc_stream_state *stream,
+					 const struct dc_stream_update *update)
+{
+	if (update == NULL || stream == NULL)
+		return;
+
+	if (update->src.height && update->src.width)
+		stream->src = update->src;
+
+	if (update->dst.height && update->dst.width)
+		stream->dst = update->dst;
+
+	if (update->out_transfer_func &&
+	    stream->out_transfer_func != update->out_transfer_func) {
+		stream->out_transfer_func->sdr_ref_white_level =
+			update->out_transfer_func->sdr_ref_white_level;
+		stream->out_transfer_func->tf = update->out_transfer_func->tf;
+		stream->out_transfer_func->type =
+			update->out_transfer_func->type;
+		memcpy(&stream->out_transfer_func->tf_pts,
+		       &update->out_transfer_func->tf_pts,
+		       sizeof(struct dc_transfer_func_distributed_points));
+	}
+
+	if (update->hdr_static_metadata)
+		stream->hdr_static_metadata = *update->hdr_static_metadata;
+
+	if (update->abm_level)
+		stream->abm_level = *update->abm_level;
+
+	if (update->periodic_interrupt0)
+		stream->periodic_interrupt0 = *update->periodic_interrupt0;
+
+	if (update->periodic_interrupt1)
+		stream->periodic_interrupt1 = *update->periodic_interrupt1;
+
+	if (update->gamut_remap)
+		stream->gamut_remap_matrix = *update->gamut_remap;
+
+	/* Note: this being updated after mode set is currently not a use case
+	 * however if it arises OCSC would need to be reprogrammed at the
+	 * minimum
+	 */
+	if (update->output_color_space)
+		stream->output_color_space = *update->output_color_space;
+
+	if (update->output_csc_transform)
+		stream->csc_color_matrix = *update->output_csc_transform;
+
+	if (update->vrr_infopacket)
+		stream->vrr_infopacket = *update->vrr_infopacket;
+
+	if (update->dpms_off)
+		stream->dpms_off = *update->dpms_off;
+
+	if (update->vsc_infopacket)
+		stream->vsc_infopacket = *update->vsc_infopacket;
+
+	if (update->vsp_infopacket)
+		stream->vsp_infopacket = *update->vsp_infopacket;
+
+	if (update->dither_option)
+		stream->dither_option = *update->dither_option;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	/* update current stream with writeback info */
+	if (update->wb_update) {
+		int i;
+
+		stream->num_wb_info = update->wb_update->num_wb_info;
+		ASSERT(stream->num_wb_info <= MAX_DWB_PIPES);
+		for (i = 0; i < stream->num_wb_info; i++)
+			stream->writeback_info[i] =
+				update->wb_update->writeback_info[i];
+	}
+#endif
+#if defined(CONFIG_DRM_AMD_DC_DSC_SUPPORT)
+	if (update->dsc_config) {
+		struct dc_dsc_config old_dsc_cfg = stream->timing.dsc_cfg;
+		uint32_t old_dsc_enabled = stream->timing.flags.DSC;
+		uint32_t enable_dsc = (update->dsc_config->num_slices_h != 0 &&
+				       update->dsc_config->num_slices_v != 0);
+
+		stream->timing.dsc_cfg = *update->dsc_config;
+		stream->timing.flags.DSC = enable_dsc;
+		if (!dc->res_pool->funcs->validate_bandwidth(dc, context,
+							     true)) {
+			stream->timing.dsc_cfg = old_dsc_cfg;
+			stream->timing.flags.DSC = old_dsc_enabled;
+		}
+	}
+#endif
+}
+
 static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update,
@@ -2022,6 +2117,8 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		}
 	}
 
+	copy_stream_update_to_stream(dc, context, stream, stream_update);
+
 	commit_planes_for_stream(
 				dc,
 				srf_updates,

commit c3ec8ba5377994251e83893aa8820f771ff4aabf
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed May 8 13:29:09 2019 -0400

    drm/amd/display: Return UPDATE_TYPE_FULL on writeback update
    
    Should do full update when display writeback is updated.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Duke Du <Duke.Du@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index fd955151132f..8cecd58653cf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1516,6 +1516,11 @@ static enum surface_update_type check_update_surfaces_for_stream(
 
 		if (stream_update->dpms_off)
 			return UPDATE_TYPE_FULL;
+
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		if (stream_update->wb_update)
+			return UPDATE_TYPE_FULL;
+#endif
 	}
 
 	for (i = 0 ; i < surface_count; i++) {

commit ba32c50f04466463258546a8e75ff8ddd6776bd5
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Mon May 6 14:22:39 2019 -0400

    drm/amd/display: decouple dsc adjustment out of enablement
    
    [why]
    dsc adjustment is allowed via stream update sequence.
    dsc enablement is only allowed via commit stream sequence.
    with the current unified dsc set function, it is hard
    to determine which sequence it is called by.
    The solution is to decouple dsc adjustment out of enablement
    sequence so we can handle them separately.
    
    [how]
    decouple dsc adjustment out of enablement.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8bf3433af3f8..fd955151132f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1746,14 +1746,9 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 #if defined(CONFIG_DRM_AMD_DC_DSC_SUPPORT)
 			if (stream_update->dsc_config && dc->hwss.pipe_control_lock_global) {
-				bool enable_dsc = (stream_update->dsc_config->num_slices_h && stream_update->dsc_config->num_slices_v);
-
 				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
-				dp_set_dsc_enable(pipe_ctx, enable_dsc);
+				dp_update_dsc_config(pipe_ctx);
 				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
-
-				if (!stream->is_dsc_enabled)
-					dc->res_pool->funcs->remove_dsc_from_stream_resource(dc, context, stream);
 			}
 #endif
 			/* Full fe update*/

commit ad141db915a8b402fd29e553d4f0b9e870141ca6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 14:56:29 2019 -0400

    drm/amd/display: add null checks and set update flags for DCN2
    
    * add plane state null checks
    * add and set update surface flags
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 867a84c2bfbf..8bf3433af3f8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1427,6 +1427,9 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 
 	update_flags->raw = 0; // Reset all flags
 
+	if (u->flip_addr)
+		update_flags->bits.addr_update = 1;
+
 	if (!is_surface_in_context(context, u->surface)) {
 		update_flags->bits.new_plane = 1;
 		return UPDATE_TYPE_FULL;

commit f99b6f4f216ac0ff7f477dd36c88e7b229292dec
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Apr 18 09:51:12 2019 -0500

    drm/amd/display: Integrate color transform3x4 with 3dlut tm
    
    [Why & How]
    Reuse existent code path (dcn1+) and in order to do that apply de gamma
    in 1D blender LUT and re use MPC OGAM.
    Follow up is required.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Vitaly Prosyak <Vitaly.Prosyak@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6abf22aaf571..867a84c2bfbf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1669,6 +1669,13 @@ static void copy_surface_update_to_plane(
 			srf_update->lut3d_func))
 		memcpy(surface->lut3d_func, srf_update->lut3d_func,
 		sizeof(*surface->lut3d_func));
+
+	if (srf_update->blend_tf &&
+			(surface->blend_tf !=
+			srf_update->blend_tf))
+		memcpy(surface->blend_tf, srf_update->blend_tf,
+		sizeof(*surface->blend_tf));
+
 #endif
 	if (srf_update->input_csc_color_matrix)
 		surface->input_csc_color_matrix =

commit c9ae6e1691cd1dcd5f7f76050b5eca16bc82445e
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Tue Apr 2 12:40:22 2019 -0400

    drm/amd/display: Acquire DSC HW resource only if required by stream
    
    [why]
    There are ASICs that have fewer DSC engines than pipes, which makes
    DSC a resource that should be used only if required.
    
    [how]
    Acquire DSC HW resource if required by stream and release when not
    required anymore.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 68eddcc0fbcc..6abf22aaf571 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1736,19 +1736,14 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 #if defined(CONFIG_DRM_AMD_DC_DSC_SUPPORT)
 			if (stream_update->dsc_config && dc->hwss.pipe_control_lock_global) {
-				if (stream_update->dsc_config->num_slices_h &&
-						stream_update->dsc_config->num_slices_v) {
-					/* dsc enable */
-					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
-					dp_set_dsc_enable(pipe_ctx, true);
-					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
-				} else {
-					/* dsc disable */
-					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
-					dp_set_dsc_enable(pipe_ctx, false);
-					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
-				}
+				bool enable_dsc = (stream_update->dsc_config->num_slices_h && stream_update->dsc_config->num_slices_v);
+
+				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
+				dp_set_dsc_enable(pipe_ctx, enable_dsc);
+				dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
 
+				if (!stream->is_dsc_enabled)
+					dc->res_pool->funcs->remove_dsc_from_stream_resource(dc, context, stream);
 			}
 #endif
 			/* Full fe update*/

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 052d3c8c6b73..68eddcc0fbcc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -56,6 +56,10 @@
 
 #include "dc_link_dp.h"
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+#include "dsc.h"
+#endif
+
 #ifdef CONFIG_DRM_AMD_DC_DCN2_0
 #include "vm_helper.h"
 #endif
@@ -1730,6 +1734,23 @@ static void commit_planes_do_stream_update(struct dc *dc,
 #endif
 			}
 
+#if defined(CONFIG_DRM_AMD_DC_DSC_SUPPORT)
+			if (stream_update->dsc_config && dc->hwss.pipe_control_lock_global) {
+				if (stream_update->dsc_config->num_slices_h &&
+						stream_update->dsc_config->num_slices_v) {
+					/* dsc enable */
+					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
+					dp_set_dsc_enable(pipe_ctx, true);
+					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
+				} else {
+					/* dsc disable */
+					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, true);
+					dp_set_dsc_enable(pipe_ctx, false);
+					dc->hwss.pipe_control_lock_global(dc, pipe_ctx, false);
+				}
+
+			}
+#endif
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;

commit 6fbefb84a98ecc43cb4035c44fe417e6751ddd83
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:34 2019 -0500

    drm/amd/display: Add DC core changes for DCN2
    
    Core DC changes for DCN2.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 08092ae57bc8..052d3c8c6b73 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -56,6 +56,10 @@
 
 #include "dc_link_dp.h"
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+#include "vm_helper.h"
+#endif
+
 #include "dce/dce_i2c.h"
 
 #define DC_LOGGER \
@@ -528,6 +532,11 @@ static void destruct(struct dc *dc)
 	kfree(dc->dcn_ip);
 	dc->dcn_ip = NULL;
 
+#endif
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+	kfree(dc->vm_helper);
+	dc->vm_helper = NULL;
+
 #endif
 }
 
@@ -545,6 +554,11 @@ static bool construct(struct dc *dc,
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 	dc->config = init_params->flags;
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+	// Allocate memory for the vm_helper
+	dc->vm_helper = kzalloc(sizeof(struct vm_helper), GFP_KERNEL);
+
+#endif
 	memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));
 
 	dc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);
@@ -578,6 +592,9 @@ static bool construct(struct dc *dc,
 	}
 
 	dc->dcn_ip = dcn_ip;
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+	dc->soc_bounding_box = init_params->soc_bounding_box;
+#endif
 #endif
 
 	dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
@@ -674,6 +691,21 @@ static bool construct(struct dc *dc,
 	return false;
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+static bool disable_all_writeback_pipes_for_stream(
+		const struct dc *dc,
+		struct dc_stream_state *stream,
+		struct dc_state *context)
+{
+	int i;
+
+	for (i = 0; i < stream->num_wb_info; i++)
+		stream->writeback_info[i].wb_enabled = false;
+
+	return true;
+}
+#endif
+
 static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 {
 	int i, j;
@@ -698,6 +730,9 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 		}
 		if (should_disable && old_stream) {
 			dc_rem_all_planes_for_stream(dc, old_stream, dangling_context);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+			disable_all_writeback_pipes_for_stream(dc, old_stream, dangling_context);
+#endif
 			dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
 		}
 	}
@@ -769,6 +804,26 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
+#ifdef CONFIG_DRM_AMD_DC_DCN2_0
+bool dc_init_memory_hub(struct dc *dc, struct dc_addr_space_config *config)
+{
+	// Memory hub init isn't done as part of dc_create because in windows, dal/dc is
+	// constructed before the vm config is setup in kmd so there's no way
+	// they can give it to us at boot/dc_create
+	bool vmSupported;
+
+	// Call HWSS to setup HUBBUB for address config
+	dc->hwss.init_dchub(dc->hwseq, dc, config);
+
+	// Pre-init system aperture start/end for all HUBP instances (if not gating?)
+	// or cache system aperture if using power gating
+	memcpy(&dc->vm_config, config, sizeof(struct dc_addr_space_config));
+
+	vmSupported = (dc->ctx->asic_id.chip_family == FAMILY_NV) ? true : false;
+	return vmSupported;
+}
+
+#endif
 static void enable_timing_multisync(
 		struct dc *dc,
 		struct dc_state *ctx)
@@ -1598,6 +1653,19 @@ static void copy_surface_update_to_plane(
 			sizeof(struct dc_transfer_func_distributed_points));
 	}
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (srf_update->func_shaper &&
+			(surface->in_shaper_func !=
+			srf_update->func_shaper))
+		memcpy(surface->in_shaper_func, srf_update->func_shaper,
+		sizeof(*surface->in_shaper_func));
+
+	if (srf_update->lut3d_func &&
+			(surface->lut3d_func !=
+			srf_update->lut3d_func))
+		memcpy(surface->lut3d_func, srf_update->lut3d_func,
+		sizeof(*surface->lut3d_func));
+#endif
 	if (srf_update->input_csc_color_matrix)
 		surface->input_csc_color_matrix =
 			*srf_update->input_csc_color_matrix;
@@ -1646,11 +1714,20 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				dc_stream_program_csc_matrix(dc, stream);
 
 			if (stream_update->dither_option) {
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+				struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
+#endif
 				resource_build_bit_depth_reduction_params(pipe_ctx->stream,
 									&pipe_ctx->stream->bit_depth_params);
 				pipe_ctx->stream_res.opp->funcs->opp_program_fmt(pipe_ctx->stream_res.opp,
 						&stream->bit_depth_params,
 						&stream->clamping);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+				if (odm_pipe)
+					odm_pipe->stream_res.opp->funcs->opp_program_fmt(odm_pipe->stream_res.opp,
+							&stream->bit_depth_params,
+							&stream->clamping);
+#endif
 			}
 
 			/* Full fe update*/
@@ -1726,6 +1803,30 @@ static void commit_planes_for_stream(struct dc *dc,
 		return;
 	}
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (!IS_DIAG_DC(dc->ctx->dce_environment)) {
+		for (i = 0; i < surface_count; i++) {
+			struct dc_plane_state *plane_state = srf_updates[i].surface;
+			/*set logical flag for lock/unlock use*/
+			for (j = 0; j < dc->res_pool->pipe_count; j++) {
+				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+				if (!pipe_ctx->plane_state)
+					continue;
+				if (pipe_ctx->plane_state != plane_state)
+					continue;
+				plane_state->triplebuffer_flips = false;
+				if (update_type == UPDATE_TYPE_FAST &&
+					dc->hwss.program_triplebuffer != NULL &&
+					!plane_state->flip_immediate &&
+					!dc->debug.disable_tri_buf) {
+						/*triple buffer for VUpdate  only*/
+						plane_state->triplebuffer_flips = true;
+				}
+			}
+		}
+	}
+#endif
+
 	// Update Type FULL, Surface updates
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1744,6 +1845,16 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+			ASSERT(!pipe_ctx->plane_state->triplebuffer_flips);
+
+			if (dc->hwss.program_triplebuffer != NULL &&
+				!dc->debug.disable_tri_buf) {
+				/*turn off triple buffer for full update*/
+				dc->hwss.program_triplebuffer(
+					dc, pipe_ctx, pipe_ctx->plane_state->triplebuffer_flips);
+			}
+#endif
 			stream_status =
 				stream_get_status(context, pipe_ctx->stream);
 
@@ -1760,6 +1871,26 @@ static void commit_planes_for_stream(struct dc *dc,
 		 */
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+		if (dc->hwss.set_flip_control_gsl)
+			for (i = 0; i < surface_count; i++) {
+				struct dc_plane_state *plane_state = srf_updates[i].surface;
+
+				for (j = 0; j < dc->res_pool->pipe_count; j++) {
+					struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+					if (pipe_ctx->stream != stream)
+						continue;
+
+					if (pipe_ctx->plane_state != plane_state)
+						continue;
+
+					// GSL has to be used for flip immediate
+					dc->hwss.set_flip_control_gsl(pipe_ctx,
+							plane_state->flip_immediate);
+				}
+			}
+#endif
 		/* Perform requested Updates */
 		for (i = 0; i < surface_count; i++) {
 			struct dc_plane_state *plane_state = srf_updates[i].surface;
@@ -1772,7 +1903,15 @@ static void commit_planes_for_stream(struct dc *dc,
 
 				if (pipe_ctx->plane_state != plane_state)
 					continue;
-
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+				/*program triple buffer after lock based on flip type*/
+				if (dc->hwss.program_triplebuffer != NULL &&
+					!dc->debug.disable_tri_buf) {
+					/*only enable triplebuffer for  fast_update*/
+					dc->hwss.program_triplebuffer(
+						dc, pipe_ctx, plane_state->triplebuffer_flips);
+				}
+#endif
 				if (srf_updates[i].flip_addr)
 					dc->hwss.update_plane_addr(dc, pipe_ctx);
 			}

commit 4f0793989f2f65eccffc7d326856f18788534c61
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 17 13:10:48 2019 -0500

    Revert "drm/amd/display: Copy stream updates onto streams"
    
    This reverts commit 6e5155ae6b66054db35d8f3c64f9863b9d0466c1.
    
    Revert this to apply the version that includes DCN2 support.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index bf64a73f1482..08092ae57bc8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1607,73 +1607,6 @@ static void copy_surface_update_to_plane(
 			*srf_update->coeff_reduction_factor;
 }
 
-static void copy_stream_update_to_stream(struct dc *dc,
-					 struct dc_state *context,
-					 struct dc_stream_state *stream,
-					 const struct dc_stream_update *update)
-{
-	if (update == NULL || stream == NULL)
-		return;
-
-	if (update->src.height && update->src.width)
-		stream->src = update->src;
-
-	if (update->dst.height && update->dst.width)
-		stream->dst = update->dst;
-
-	if (update->out_transfer_func &&
-	    stream->out_transfer_func != update->out_transfer_func) {
-		stream->out_transfer_func->sdr_ref_white_level =
-			update->out_transfer_func->sdr_ref_white_level;
-		stream->out_transfer_func->tf = update->out_transfer_func->tf;
-		stream->out_transfer_func->type =
-			update->out_transfer_func->type;
-		memcpy(&stream->out_transfer_func->tf_pts,
-		       &update->out_transfer_func->tf_pts,
-		       sizeof(struct dc_transfer_func_distributed_points));
-	}
-
-	if (update->hdr_static_metadata)
-		stream->hdr_static_metadata = *update->hdr_static_metadata;
-
-	if (update->abm_level)
-		stream->abm_level = *update->abm_level;
-
-	if (update->periodic_interrupt0)
-		stream->periodic_interrupt0 = *update->periodic_interrupt0;
-
-	if (update->periodic_interrupt1)
-		stream->periodic_interrupt1 = *update->periodic_interrupt1;
-
-	if (update->gamut_remap)
-		stream->gamut_remap_matrix = *update->gamut_remap;
-
-	/* Note: this being updated after mode set is currently not a use case
-	 * however if it arises OCSC would need to be reprogrammed at the
-	 * minimum
-	 */
-	if (update->output_color_space)
-		stream->output_color_space = *update->output_color_space;
-
-	if (update->output_csc_transform)
-		stream->csc_color_matrix = *update->output_csc_transform;
-
-	if (update->vrr_infopacket)
-		stream->vrr_infopacket = *update->vrr_infopacket;
-
-	if (update->dpms_off)
-		stream->dpms_off = *update->dpms_off;
-
-	if (update->vsc_infopacket)
-		stream->vsc_infopacket = *update->vsc_infopacket;
-
-	if (update->vsp_infopacket)
-		stream->vsp_infopacket = *update->vsp_infopacket;
-
-	if (update->dither_option)
-		stream->dither_option = *update->dither_option;
-}
-
 static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update,
@@ -1924,8 +1857,6 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		}
 	}
 
-	copy_stream_update_to_stream(dc, context, stream, stream_update);
-
 	commit_planes_for_stream(
 				dc,
 				srf_updates,

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit c08264876f4da8b0ee16ab1a070cb405186ef28a
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Wed May 29 14:38:53 2019 -0400

    drm/amd/display: Use stream opp_id instead of hubp
    
    [WHY]
    By the time output csc matrix is being programmed, stream connection to
    OPP has been established, but this information has not been relayed back
    to HUBP.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 45b542b5d920..bf64a73f1482 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -457,7 +457,7 @@ bool dc_stream_program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 					pipes,
 					stream->output_color_space,
 					stream->csc_color_matrix.matrix,
-					pipes->plane_res.hubp ? pipes->plane_res.hubp->opp_id : 0);
+					pipes->stream_res.opp->inst);
 			ret = true;
 		}
 	}

commit 6e5155ae6b66054db35d8f3c64f9863b9d0466c1
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue May 14 09:19:01 2019 -0400

    drm/amd/display: Copy stream updates onto streams
    
    [Why]
    Almost every function in DC that works with stream state expects that
    the current state on the stream is the one that it should be writing
    out. These functions are typically triggered by specifying a particular
    stream update - but the actual contents of the stream update itself
    are ignored, leaving it to the DM to actually update the stream state
    itself.
    
    The problem with doing this in DM is a matter of timing. On Linux
    most of this is incorrectly done in atomic check, when we actually want
    it to be done during atomic commit tail while access to DC is locked.
    
    To give an example, a commit requesting to modify color management
    state for DM could come in, be rejected, but still have modified
    the actual system state for the stream since it's shared memory. The
    next time color management gets programmed it'll use the rejected
    color management info - which might not even still be around if it's
    a custom transfer function.
    
    So a reasonable place to perform this is within DC itself and this is
    the model that's currently in use for surface updates. DC can even
    compare the current system state to the incoming surface update to
    determine update level, something that can't currnetly be done with the
    framework for stream updates.
    
    [How]
    Duplicate the framework used for surface updates for stream updates
    as well. Copy all the updates after checking the update type.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0bff546d3727..45b542b5d920 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1607,6 +1607,73 @@ static void copy_surface_update_to_plane(
 			*srf_update->coeff_reduction_factor;
 }
 
+static void copy_stream_update_to_stream(struct dc *dc,
+					 struct dc_state *context,
+					 struct dc_stream_state *stream,
+					 const struct dc_stream_update *update)
+{
+	if (update == NULL || stream == NULL)
+		return;
+
+	if (update->src.height && update->src.width)
+		stream->src = update->src;
+
+	if (update->dst.height && update->dst.width)
+		stream->dst = update->dst;
+
+	if (update->out_transfer_func &&
+	    stream->out_transfer_func != update->out_transfer_func) {
+		stream->out_transfer_func->sdr_ref_white_level =
+			update->out_transfer_func->sdr_ref_white_level;
+		stream->out_transfer_func->tf = update->out_transfer_func->tf;
+		stream->out_transfer_func->type =
+			update->out_transfer_func->type;
+		memcpy(&stream->out_transfer_func->tf_pts,
+		       &update->out_transfer_func->tf_pts,
+		       sizeof(struct dc_transfer_func_distributed_points));
+	}
+
+	if (update->hdr_static_metadata)
+		stream->hdr_static_metadata = *update->hdr_static_metadata;
+
+	if (update->abm_level)
+		stream->abm_level = *update->abm_level;
+
+	if (update->periodic_interrupt0)
+		stream->periodic_interrupt0 = *update->periodic_interrupt0;
+
+	if (update->periodic_interrupt1)
+		stream->periodic_interrupt1 = *update->periodic_interrupt1;
+
+	if (update->gamut_remap)
+		stream->gamut_remap_matrix = *update->gamut_remap;
+
+	/* Note: this being updated after mode set is currently not a use case
+	 * however if it arises OCSC would need to be reprogrammed at the
+	 * minimum
+	 */
+	if (update->output_color_space)
+		stream->output_color_space = *update->output_color_space;
+
+	if (update->output_csc_transform)
+		stream->csc_color_matrix = *update->output_csc_transform;
+
+	if (update->vrr_infopacket)
+		stream->vrr_infopacket = *update->vrr_infopacket;
+
+	if (update->dpms_off)
+		stream->dpms_off = *update->dpms_off;
+
+	if (update->vsc_infopacket)
+		stream->vsc_infopacket = *update->vsc_infopacket;
+
+	if (update->vsp_infopacket)
+		stream->vsp_infopacket = *update->vsp_infopacket;
+
+	if (update->dither_option)
+		stream->dither_option = *update->dither_option;
+}
+
 static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update,
@@ -1857,6 +1924,8 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		}
 	}
 
+	copy_stream_update_to_stream(dc, context, stream, stream_update);
+
 	commit_planes_for_stream(
 				dc,
 				srf_updates,

commit 540c122924bd260c5124534d16bd75c0b62f5856
Author: Tao.Huang <Tao.Huang@amd.com>
Date:   Mon May 6 16:26:54 2019 +0800

    drm/amd/display: fix resource saving missing when power state switch
    
    Signed-off-by: Tao.Huang <Tao.Huang@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d89a29bd8785..0bff546d3727 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1930,6 +1930,12 @@ void dc_set_power_state(
 	enum dc_acpi_cm_power_state power_state)
 {
 	struct kref refcount;
+	struct display_mode_lib *dml = kzalloc(sizeof(struct display_mode_lib),
+						GFP_KERNEL);
+
+	ASSERT(dml);
+	if (!dml)
+		return;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
@@ -1946,15 +1952,20 @@ void dc_set_power_state(
 
 		/* Preserve refcount */
 		refcount = dc->current_state->refcount;
+		/* Preserve display mode lib */
+		memcpy(dml, &dc->current_state->bw_ctx.dml, sizeof(struct display_mode_lib));
+
 		dc_resource_state_destruct(dc->current_state);
 		memset(dc->current_state, 0,
 				sizeof(*dc->current_state));
 
 		dc->current_state->refcount = refcount;
+		dc->current_state->bw_ctx.dml = *dml;
 
 		break;
 	}
 
+	kfree(dml);
 }
 
 void dc_resume(struct dc *dc)

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 18c775a950cc..03dec40de361 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -22,6 +22,8 @@
  * Authors: AMD
  */
 
+#include <linux/slab.h>
+
 #include "dm_services.h"
 
 #include "dc.h"

commit 4fd334122399a133ddaee8ef865eb10a1cf8000f
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Thu May 16 18:43:54 2019 -0400

    drm/amd/display: program manual trigger only for bottom most pipe
    
    [Why]
    We only want to manual trigger end-of-frame when the bottom-most
    pipe is flipped to prevent overlays from ending the frame too early.
    
    [How]
    Check that the manual trigger is only firing on bottom plane.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 49be32863044..d89a29bd8785 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1781,14 +1781,14 @@ static void commit_planes_for_stream(struct dc *dc,
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 	}
 
-	// Fire manual trigger
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+	// Fire manual trigger only when bottom plane is flipped
+	for (j = 0; j < dc->res_pool->pipe_count; j++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (pipe_ctx->top_pipe ||
-			!pipe_ctx->stream ||
-			pipe_ctx->stream != stream ||
-			!srf_updates[i].flip_addr)
+		if (pipe_ctx->bottom_pipe ||
+				!pipe_ctx->stream ||
+				pipe_ctx->stream != stream ||
+				!pipe_ctx->plane_state->update_flags.bits.addr_update)
 			continue;
 
 		if (pipe_ctx->stream_res.tg->funcs->program_manual_trigger)

commit fe798de53a7a5e2ef9cf7bf5b075f32903d4eec1
Author: Chris Park <Chris.Park@amd.com>
Date:   Fri May 10 13:34:30 2019 -0400

    drm/amd/display: Move link functions from dc to dc_link
    
    [Why]
    link-specific functions should reside in dc_link.c
    
    [How]
    Move them there.
    
    Signed-off-by: Chris Park <Chris.Park@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5012b6755dc8..49be32863044 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -490,128 +490,6 @@ void dc_stream_set_static_screen_events(struct dc *dc,
 	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
-void dc_link_set_drive_settings(struct dc *dc,
-				struct link_training_settings *lt_settings,
-				const struct dc_link *link)
-{
-
-	int i;
-
-	for (i = 0; i < dc->link_count; i++) {
-		if (dc->links[i] == link)
-			break;
-	}
-
-	if (i >= dc->link_count)
-		ASSERT_CRITICAL(false);
-
-	dc_link_dp_set_drive_settings(dc->links[i], lt_settings);
-}
-
-void dc_link_perform_link_training(struct dc *dc,
-				   struct dc_link_settings *link_setting,
-				   bool skip_video_pattern)
-{
-	int i;
-
-	for (i = 0; i < dc->link_count; i++)
-		dc_link_dp_perform_link_training(
-			dc->links[i],
-			link_setting,
-			skip_video_pattern);
-}
-
-void dc_link_set_preferred_link_settings(struct dc *dc,
-					 struct dc_link_settings *link_setting,
-					 struct dc_link *link)
-{
-	int i;
-	struct pipe_ctx *pipe;
-	struct dc_stream_state *link_stream;
-	struct dc_link_settings store_settings = *link_setting;
-
-	link->preferred_link_setting = store_settings;
-
-	/* Retrain with preferred link settings only relevant for
-	 * DP signal type
-	 */
-	if (!dc_is_dp_signal(link->connector_signal))
-		return;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
-		if (pipe->stream && pipe->stream->link) {
-			if (pipe->stream->link == link)
-				break;
-		}
-	}
-
-	/* Stream not found */
-	if (i == MAX_PIPES)
-		return;
-
-	link_stream = link->dc->current_state->res_ctx.pipe_ctx[i].stream;
-
-	/* Cannot retrain link if backend is off */
-	if (link_stream->dpms_off)
-		return;
-
-	if (link_stream)
-		decide_link_settings(link_stream, &store_settings);
-
-	if ((store_settings.lane_count != LANE_COUNT_UNKNOWN) &&
-		(store_settings.link_rate != LINK_RATE_UNKNOWN))
-		dp_retrain_link_dp_test(link, &store_settings, false);
-}
-
-void dc_link_enable_hpd(const struct dc_link *link)
-{
-	dc_link_dp_enable_hpd(link);
-}
-
-void dc_link_disable_hpd(const struct dc_link *link)
-{
-	dc_link_dp_disable_hpd(link);
-}
-
-
-void dc_link_set_test_pattern(struct dc_link *link,
-			      enum dp_test_pattern test_pattern,
-			      const struct link_training_settings *p_link_settings,
-			      const unsigned char *p_custom_pattern,
-			      unsigned int cust_pattern_size)
-{
-	if (link != NULL)
-		dc_link_dp_set_test_pattern(
-			link,
-			test_pattern,
-			p_link_settings,
-			p_custom_pattern,
-			cust_pattern_size);
-}
-
-uint32_t dc_link_bandwidth_kbps(
-	const struct dc_link *link,
-	const struct dc_link_settings *link_setting)
-{
-	uint32_t link_bw_kbps = link_setting->link_rate * LINK_RATE_REF_FREQ_IN_KHZ; /* bytes per sec */
-
-	link_bw_kbps *= 8;   /* 8 bits per byte*/
-	link_bw_kbps *= link_setting->lane_count;
-
-	return link_bw_kbps;
-
-}
-
-const struct dc_link_settings *dc_link_get_link_cap(
-		const struct dc_link *link)
-{
-	if (link->preferred_link_setting.lane_count != LANE_COUNT_UNKNOWN &&
-			link->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN)
-		return &link->preferred_link_setting;
-	return &link->verified_link_cap;
-}
-
 static void destruct(struct dc *dc)
 {
 	dc_release_state(dc->current_state);

commit e63e2491ad92036e844230b6373ae07923552f6c
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Tue Apr 23 11:53:52 2019 -0400

    drm/amd/display: Ensure DRR triggers in BP
    
    [Why]
    In the previous implementation DRR event sometimes came
    in during FP2 region which is a keep-out zone. This
    would cause the frame not to latch until the next frame
    which resulted in heavy flicker. To fix this we need
    to make sure that it triggers in the BP.
    
    [How]
    1. Remove DRR programming during flip
    2. Setup manual trigger for DRR event and trigger it
    after surface programming is complete
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 79c3a372584f..5012b6755dc8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -263,7 +263,7 @@ bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
+		if (pipe->stream == stream && pipe->stream_res.tg) {
 			pipe->stream->adjust = *adjust;
 			dc->hwss.set_drr(&pipe,
 					1,
@@ -1745,13 +1745,6 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			pipe_ctx->stream &&
 			pipe_ctx->stream == stream) {
 
-			/* Fast update*/
-			// VRR program can be done as part of FAST UPDATE
-			if (stream_update->adjust)
-				dc->hwss.set_drr(&pipe_ctx, 1,
-					stream_update->adjust->v_total_min,
-					stream_update->adjust->v_total_max);
-
 			if (stream_update->periodic_interrupt0 &&
 					dc->hwss.setup_periodic_interrupt)
 				dc->hwss.setup_periodic_interrupt(pipe_ctx, VLINE0);
@@ -1909,6 +1902,20 @@ static void commit_planes_for_stream(struct dc *dc,
 
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 	}
+
+	// Fire manual trigger
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->top_pipe ||
+			!pipe_ctx->stream ||
+			pipe_ctx->stream != stream ||
+			!srf_updates[i].flip_addr)
+			continue;
+
+		if (pipe_ctx->stream_res.tg->funcs->program_manual_trigger)
+			pipe_ctx->stream_res.tg->funcs->program_manual_trigger(pipe_ctx->stream_res.tg);
+	}
 }
 
 void dc_commit_updates_for_stream(struct dc *dc,

commit dc88b4a684d284a200c0ecfd8d87179d6f6c89a3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Apr 22 19:39:35 2019 -0400

    drm/amd/display: make clk mgr soc specific
    
    [Why]
    First step of refactoring clk mgr to better handle different
    ways of handling clock operations. Clock operation policies are
    soc specific and not just DCN vesion specific. It is not a hw resource,
    should not be in the resource pool.
    
    [How]
    Change clock manager creation to be based on HW internal ID, rename
    clock manager members to be more clear. Move clock manager out of
    resource.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4e17af2b63dc..79c3a372584f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -33,6 +33,7 @@
 
 #include "resource.h"
 
+#include "clk_mgr.h"
 #include "clock_source.h"
 #include "dc_bios_types.h"
 
@@ -618,6 +619,11 @@ static void destruct(struct dc *dc)
 
 	destroy_links(dc);
 
+	if (dc->clk_mgr) {
+		dc_destroy_clk_mgr(dc->clk_mgr);
+		dc->clk_mgr = NULL;
+	}
+
 	dc_destroy_resource_pool(dc);
 
 	if (dc->ctx->gpio_service)
@@ -761,6 +767,10 @@ static bool construct(struct dc *dc,
 	if (!dc->res_pool)
 		goto fail;
 
+	dc->clk_mgr = dc_clk_mgr_create(dc->ctx, dc->res_pool->pp_smu, dc->res_pool->dccg);
+	if (!dc->clk_mgr)
+		goto fail;
+
 	/* Creation of current_state must occur after dc->dml
 	 * is initialized in dc_create_resource_pool because
 	 * on creation it copies the contents of dc->dml

commit ccd76ebce4e8e1e19df19bc7024355a1f82a9363
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Apr 30 16:22:38 2019 -0400

    drm/amd/display: dont set  otg offset
    
    move the update of otg instance outside of hw programming logic,
    since this is sw state, it should always be updated and should
    never be optimized away.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 257e632a3a1a..4e17af2b63dc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1141,7 +1141,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	/* Program all planes within new context*/
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_link *link = context->streams[i]->link;
-		struct dc_stream_status *status;
 
 		if (!context->streams[i]->mode_changed)
 			continue;
@@ -1166,9 +1165,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 			}
 		}
 
-		status = dc_stream_get_status_from_state(context, context->streams[i]);
-		context->streams[i]->out.otg_offset = status->primary_otg_inst;
-
 		CONN_MSG_MODE(link, "{%dx%d, %dx%d@%dKhz}",
 				context->streams[i]->timing.h_addressable,
 				context->streams[i]->timing.v_addressable,

commit aa5fdb1ab5b6559ce6ebe11dd78177c8487f02e0
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Thu May 2 13:21:48 2019 -0400

    drm/amd/display: Explicitly specify update type per plane info change
    
    [Why]
    The bit for flip addr is being set causing the determination for
    FAST vs MEDIUM to always return MEDIUM when plane info is provided
    as a surface update. This causes extreme stuttering for the typical
    atomic update path on Linux.
    
    [How]
    Don't use update_flags->raw for determining FAST vs MEDIUM. It's too
    fragile to changes like this.
    
    Explicitly specify the update type per update flag instead. It's not
    as clever as checking the bits itself but at least it's correct.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Eryk Brol <Eryk.Brol@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f469394751c1..257e632a3a1a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1333,74 +1333,94 @@ static bool is_surface_in_context(
 static enum surface_update_type get_plane_info_update_type(const struct dc_surface_update *u)
 {
 	union surface_update_flags *update_flags = &u->surface->update_flags;
+	enum surface_update_type update_type = UPDATE_TYPE_FAST;
 
 	if (!u->plane_info)
 		return UPDATE_TYPE_FAST;
 
-	if (u->plane_info->color_space != u->surface->color_space)
+	if (u->plane_info->color_space != u->surface->color_space) {
 		update_flags->bits.color_space_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
-	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror)
+	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror) {
 		update_flags->bits.horizontal_mirror_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
-	if (u->plane_info->rotation != u->surface->rotation)
+	if (u->plane_info->rotation != u->surface->rotation) {
 		update_flags->bits.rotation_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
+	}
 
-	if (u->plane_info->format != u->surface->format)
+	if (u->plane_info->format != u->surface->format) {
 		update_flags->bits.pixel_format_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
+	}
 
-	if (u->plane_info->stereo_format != u->surface->stereo_format)
+	if (u->plane_info->stereo_format != u->surface->stereo_format) {
 		update_flags->bits.stereo_format_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
+	}
 
-	if (u->plane_info->per_pixel_alpha != u->surface->per_pixel_alpha)
+	if (u->plane_info->per_pixel_alpha != u->surface->per_pixel_alpha) {
 		update_flags->bits.per_pixel_alpha_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
-	if (u->plane_info->global_alpha_value != u->surface->global_alpha_value)
+	if (u->plane_info->global_alpha_value != u->surface->global_alpha_value) {
 		update_flags->bits.global_alpha_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
-	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level)
+	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level) {
 		update_flags->bits.sdr_white_level = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
 	if (u->plane_info->dcc.enable != u->surface->dcc.enable
 			|| u->plane_info->dcc.grph.independent_64b_blks != u->surface->dcc.grph.independent_64b_blks
-			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch)
+			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch) {
 		update_flags->bits.dcc_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
 	if (resource_pixel_format_to_bpp(u->plane_info->format) !=
-			resource_pixel_format_to_bpp(u->surface->format))
+			resource_pixel_format_to_bpp(u->surface->format)) {
 		/* different bytes per element will require full bandwidth
 		 * and DML calculation
 		 */
 		update_flags->bits.bpp_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_FULL);
+	}
 
 	if (u->plane_info->plane_size.grph.surface_pitch != u->surface->plane_size.grph.surface_pitch
 			|| u->plane_info->plane_size.video.luma_pitch != u->surface->plane_size.video.luma_pitch
-			|| u->plane_info->plane_size.video.chroma_pitch != u->surface->plane_size.video.chroma_pitch)
+			|| u->plane_info->plane_size.video.chroma_pitch != u->surface->plane_size.video.chroma_pitch) {
 		update_flags->bits.plane_size_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+	}
 
 
 	if (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,
 			sizeof(union dc_tiling_info)) != 0) {
 		update_flags->bits.swizzle_change = 1;
+		elevate_update_type(&update_type, UPDATE_TYPE_MED);
+
 		/* todo: below are HW dependent, we should add a hook to
 		 * DCE/N resource and validated there.
 		 */
-		if (u->plane_info->tiling_info.gfx9.swizzle != DC_SW_LINEAR)
+		if (u->plane_info->tiling_info.gfx9.swizzle != DC_SW_LINEAR) {
 			/* swizzled mode requires RQ to be setup properly,
 			 * thus need to run DML to calculate RQ settings
 			 */
 			update_flags->bits.bandwidth_change = 1;
+			elevate_update_type(&update_type, UPDATE_TYPE_FULL);
+		}
 	}
 
-	if (update_flags->bits.rotation_change
-			|| update_flags->bits.stereo_format_change
-			|| update_flags->bits.pixel_format_change
-			|| update_flags->bits.bpp_change
-			|| update_flags->bits.bandwidth_change
-			|| update_flags->bits.output_tf_change)
-		return UPDATE_TYPE_FULL;
-
-	return update_flags->raw ? UPDATE_TYPE_MED : UPDATE_TYPE_FAST;
+	/* This should be UPDATE_TYPE_FAST if nothing has changed. */
+	return update_type;
 }
 
 static enum surface_update_type get_scaling_info_update_type(
@@ -1464,9 +1484,6 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 
 	update_flags->raw = 0; // Reset all flags
 
-	if (u->flip_addr)
-		update_flags->bits.addr_update = 1;
-
 	if (!is_surface_in_context(context, u->surface)) {
 		update_flags->bits.new_plane = 1;
 		return UPDATE_TYPE_FULL;
@@ -1483,6 +1500,9 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	type = get_scaling_info_update_type(u);
 	elevate_update_type(&overall_type, type);
 
+	if (u->flip_addr)
+		update_flags->bits.addr_update = 1;
+
 	if (u->in_transfer_func)
 		update_flags->bits.in_transfer_func_change = 1;
 

commit 24c18794946ad127334138669b2aa204b2e60763
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 14:56:29 2019 -0400

    drm/amd/display: add null checks and set update flags
    
    * add plane state null checks
    * add and set update surface flags
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 700278216424..f469394751c1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1358,6 +1358,9 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->global_alpha_value != u->surface->global_alpha_value)
 		update_flags->bits.global_alpha_change = 1;
 
+	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level)
+		update_flags->bits.sdr_white_level = 1;
+
 	if (u->plane_info->dcc.enable != u->surface->dcc.enable
 			|| u->plane_info->dcc.grph.independent_64b_blks != u->surface->dcc.grph.independent_64b_blks
 			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch)
@@ -1461,6 +1464,9 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 
 	update_flags->raw = 0; // Reset all flags
 
+	if (u->flip_addr)
+		update_flags->bits.addr_update = 1;
+
 	if (!is_surface_in_context(context, u->surface)) {
 		update_flags->bits.new_plane = 1;
 		return UPDATE_TYPE_FULL;

commit 8dea49605f6e21b5b380b0cae7f1f1160675e3ee
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Apr 15 14:52:25 2019 -0400

    drm/amd/display: add support for disconnected eDP panels
    
    [why]
    On some configurations, eDP from GPU is muxed with another GPU.  DC does
    not know state of mux, but DM has this knowledge.  This flag allows DC to ignore
    creating EDP link when DM informs DC that EDP mux is not connected.
    
    [how]
    Add flag to dc, populate flag in DM
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ee6b646180b6..700278216424 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -169,9 +169,14 @@ static bool create_links(
 		link = link_create(&link_init_params);
 
 		if (link) {
-			dc->links[dc->link_count] = link;
-			link->dc = dc;
-			++dc->link_count;
+			if (dc->config.edp_not_connected &&
+					link->connector_signal == SIGNAL_TYPE_EDP) {
+				link_destroy(&link);
+			} else {
+				dc->links[dc->link_count] = link;
+				link->dc = dc;
+				++dc->link_count;
+			}
 		}
 	}
 

commit 4cd75ff096f4ef49c343093b52a952f27aba7796
Author: Anthony Koo <anthony.koo@amd.com>
Date:   Fri Apr 12 21:23:45 2019 -0400

    drm/amd/display: fix multi display seamless boot case
    
    [Why]
    There is a scenario that causes eDP to become blank if
    there are multiple displays connected, and the external
    display is set as the primary display such that the first
    flip comes to the external display.
    
    In this scenario, we call our optimize function before
    the eDP even has a chance to flip.
    
    [How]
    There is a check that prevents bandwidth optimize from
    occurring before first flip is complete on the seamless boot
    display.
    But actually it assumed the seamless boot display is the
    first one to flip. But in this scenario it is not.
    Modify the check to ensure the steam with the seamless
    boot flag set is the one that has completed the first flip.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 18c775a950cc..ee6b646180b6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1138,9 +1138,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 		const struct dc_link *link = context->streams[i]->link;
 		struct dc_stream_status *status;
 
-		if (context->streams[i]->apply_seamless_boot_optimization)
-			context->streams[i]->apply_seamless_boot_optimization = false;
-
 		if (!context->streams[i]->mode_changed)
 			continue;
 
@@ -1792,10 +1789,15 @@ static void commit_planes_for_stream(struct dc *dc,
 	if (dc->optimize_seamless_boot && surface_count > 0) {
 		/* Optimize seamless boot flag keeps clocks and watermarks high until
 		 * first flip. After first flip, optimization is required to lower
-		 * bandwidth.
+		 * bandwidth. Important to note that it is expected UEFI will
+		 * only light up a single display on POST, therefore we only expect
+		 * one stream with seamless boot flag set.
 		 */
-		dc->optimize_seamless_boot = false;
-		dc->optimized_required = true;
+		if (stream->apply_seamless_boot_optimization) {
+			stream->apply_seamless_boot_optimization = false;
+			dc->optimize_seamless_boot = false;
+			dc->optimized_required = true;
+		}
 	}
 
 	if (update_type == UPDATE_TYPE_FULL && !dc->optimize_seamless_boot) {

commit a2d635decbfa9c1e4ae15cb05b68b2559f7f827c
Merge: 89c3b37af87e eb85d03e01c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 8 21:35:19 2019 -0700

    Merge tag 'drm-next-2019-05-09' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "This has two exciting community drivers for ARM Mali accelerators.
      Since ARM has never been open source friendly on the GPU side of the
      house, the community has had to create open source drivers for the
      Mali GPUs. Lima covers the older t4xx and panfrost the newer 6xx/7xx
      series. Well done to all involved and hopefully this will help ARM
      head in the right direction.
    
      There is also now the ability if you don't have any of the legacy
      drivers enabled (pre-KMS) to remove all the pre-KMS support code from
      the core drm, this saves 10% or so in codesize on my machine.
    
      i915 also enable Icelake/Elkhart Lake Gen11 GPUs by default, vboxvideo
      moves out of staging.
    
      There are also some rcar-du patches which crossover with media tree
      but all should be acked by Mauro.
    
      Summary:
    
      uapi changes:
       - Colorspace connector property
       - fourcc - new YUV formts
       - timeline sync objects initially merged
       - expose FB_DAMAGE_CLIPS to atomic userspace
    
      new drivers:
       - vboxvideo: moved out of staging
       - aspeed: ASPEED SoC BMC chip display support
       - lima: ARM Mali4xx GPU acceleration driver support
       - panfrost: ARM Mali6xx/7xx Midgard/Bitfrost acceleration driver support
    
      core:
       - component helper docs
       - unplugging fixes
       - devm device init
       - MIPI/DSI rate control
       - shmem backed gem objects
       - connector, display_info, edid_quirks cleanups
       - dma_buf fence chain support
       - 64-bit dma-fence seqno comparison fixes
       - move initial fb config code to core
       - gem fence array helpers for Lima
       - ability to remove legacy support code if no drivers requires it (removes 10% of drm.ko size)
       - lease fixes
    
      ttm:
       - unified DRM_FILE_PAGE_OFFSET handling
       - Account for kernel allocations in kernel zone only
    
      panel:
       - OSD070T1718-19TS panel support
       - panel-tpo-td028ttec1 backlight support
       - Ronbo RB070D30 MIPI/DSI
       - Feiyang FY07024DI26A30-D MIPI-DSI panel
       - Rocktech jh057n00900 MIPI-DSI panel
    
      i915:
       - Comet Lake (Gen9) PCI IDs
       - Updated Icelake PCI IDs
       - Elkhartlake (Gen11) support
       - DP MST property addtions
       - plane and watermark fixes
       - Icelake port sync and VEBOX disable fixes
       - struct_mutex usage reduction
       - Icelake gamma fix
       - GuC reset fixes
       - make mmap more asynchronous
       - sound display power well race fixes
       - DDI/MIPI-DSI clocks for Icelake
       - Icelake RPS frequency changing support
       - Icelake workarounds
    
      amdgpu:
       - Use HMM for userptr
       - vega20 experimental smu11 support
       - RAS support for vega20
       - BACO support for vega12 + fixes for vega20
       - reworked IH interrupt handling
       - amdkfd RAS support
       - Freesync improvements
       - initial timeline sync object support
       - DC Z ordering fixes
       - NV12 planes support
       - colorspace properties for planes=
       - eDP opts if eDP already initialized
    
      nouveau:
       - misc fixes
    
      etnaviv:
       - misc fixes
    
      msm:
       - GPU zap shader support expansion
       - robustness ABI addition
    
      exynos:
       - Logging cleanups
    
      tegra:
       - Shared reset fix
       - CPU cache maintenance fix
    
      cirrus:
       - driver rewritten using simple helpers
    
      meson:
       - G12A support
    
      vmwgfx:
       - Resource dirtying management improvements
       - Userspace logging improvements
    
      virtio:
       - PRIME fixes
    
      rockchip:
       - rk3066 hdmi support
    
      sun4i:
       - DSI burst mode support
    
      vc4:
       - load tracker to detect underflow
    
      v3d:
       - v3d v4.2 support
    
      malidp:
       - initial Mali D71 support in komeda driver
    
      tfp410:
       - omap related improvement
    
      omapdrm:
       - drm bridge/panel support
       - drop some omap specific panels
    
      rcar-du:
       - Display writeback support"
    
    * tag 'drm-next-2019-05-09' of git://anongit.freedesktop.org/drm/drm: (1507 commits)
      drm/msm/a6xx: No zap shader is not an error
      drm/cma-helper: Fix drm_gem_cma_free_object()
      drm: Fix timestamp docs for variable refresh properties.
      drm/komeda: Mark the local functions as static
      drm/komeda: Fixed warning: Function parameter or member not described
      drm/komeda: Expose bus_width to Komeda-CORE
      drm/komeda: Add sysfs attribute: core_id and config_id
      drm: add non-desktop quirk for Valve HMDs
      drm/panfrost: Show stored feature registers
      drm/panfrost: Don't scream about deferred probe
      drm/panfrost: Disable PM on probe failure
      drm/panfrost: Set DMA masks earlier
      drm/panfrost: Add sanity checks to submit IOCTL
      drm/etnaviv: initialize idle mask before querying the HW db
      drm: introduce a capability flag for syncobj timeline support
      drm: report consistent errors when checking syncobj capibility
      drm/nouveau/nouveau: forward error generated while resuming objects tree
      drm/nouveau/fb/ramgk104: fix spelling mistake "sucessfully" -> "successfully"
      drm/nouveau/i2c: Disable i2c bus access after ->fini()
      drm/nouveau: Remove duplicate ACPI_VIDEO_NOTIFY_PROBE definition
      ...

commit 5ac4619b9d2fdbb54ef4b247db774637e347d46e
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Mon Apr 1 17:07:21 2019 -0400

    drm/amd/display: change name from dc_link_get_verified_link_cap to dc_link_get_link_cap
    
    [Why]
    DM doesn't need to know which link cap is being retrieved ( verified
     or preferred ).  Let DC figure it out.
    
    [How]
    Change name.
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4887d0611001..dda10b1f8574 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -597,7 +597,7 @@ uint32_t dc_link_bandwidth_kbps(
 
 }
 
-const struct dc_link_settings *dc_link_get_verified_link_cap(
+const struct dc_link_settings *dc_link_get_link_cap(
 		const struct dc_link *link)
 {
 	if (link->preferred_link_setting.lane_count != LANE_COUNT_UNKNOWN &&

commit c238bfe0be9ef7420f7669a69e27c8c8f4d8a568
Author: David Francis <David.Francis@amd.com>
Date:   Fri Mar 29 13:23:15 2019 -0400

    drm/amd/display: If one stream full updates, full update all planes
    
    [Why]
    On some compositors, with two monitors attached, VT terminal
    switch can cause a graphical issue by the following means:
    
    There are two streams, one for each monitor. Each stream has one
    plane
    
    current state:
            M1:S1->P1
            M2:S2->P2
    
    The user calls for a terminal switch and a commit is made to
    change both planes to linear swizzle mode. In atomic check,
    a new dc_state is constructed with new planes on each stream
    
    new state:
            M1:S1->P3
            M2:S2->P4
    
    In commit tail, each stream is committed, one at a time. The first
    stream (S1) updates properly, triggerring a full update and replacing
    the state
    
    current state:
            M1:S1->P3
            M2:S2->P4
    
    The update for S2 comes in, but dc detects that there is no difference
    between the stream and plane in the new and current states, and so
    triggers a fast update. The fast update does not program swizzle,
    so the second monitor is corrupted
    
    [How]
    Add a flag to dc_plane_state that forces full updates
    
    When a stream undergoes a full update, set this flag on all changed
    planes, then clear it on the current stream
    
    Subsequent streams will get full updates as a result
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet Lakha@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c68fbd55db3c..a6cda201c964 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1377,6 +1377,11 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 		return UPDATE_TYPE_FULL;
 	}
 
+	if (u->surface->force_full_update) {
+		update_flags->bits.full_update = 1;
+		return UPDATE_TYPE_FULL;
+	}
+
 	type = get_plane_info_update_type(u);
 	elevate_update_type(&overall_type, type);
 
@@ -1802,6 +1807,14 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		}
 
 		dc_resource_state_copy_construct(state, context);
+
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct pipe_ctx *new_pipe = &context->res_ctx.pipe_ctx[i];
+			struct pipe_ctx *old_pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+
+			if (new_pipe->plane_state && new_pipe->plane_state != old_pipe->plane_state)
+				new_pipe->plane_state->force_full_update = true;
+		}
 	}
 
 
@@ -1838,6 +1851,12 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		dc->current_state = context;
 		dc_release_state(old);
 
+		for (i = 0; i < dc->res_pool->pipe_count; i++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+			if (pipe_ctx->plane_state && pipe_ctx->stream == stream)
+				pipe_ctx->plane_state->force_full_update = false;
+		}
 	}
 	/*let's use current_state to update watermark etc*/
 	if (update_type >= UPDATE_TYPE_FULL)

commit c85fc65e2241bacbce35e3beb28ac4994e1e033a
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sat Mar 23 13:46:40 2019 -0400

    drm/amd/display: init dc_config before rest of DC init
    
    [Why]
    In some cases we want DC init to take in some config options
    
    [How]
    Init dc_config before rest of DC init
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2b1cd8bd5e03..4887d0611001 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -654,6 +654,8 @@ static bool construct(struct dc *dc,
 #endif
 
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
+	dc->config = init_params->flags;
+
 	memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));
 
 	dc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);
@@ -847,8 +849,6 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	if (dc->res_pool->dmcu != NULL)
 		dc->versions.dmcu_version = dc->res_pool->dmcu->dmcu_version;
 
-	dc->config = init_params->flags;
-
 	dc->build_id = DC_BUILD_ID;
 
 	DC_LOG_DC("Display Core initialized\n");

commit 7ee3769a37d3f9d7352bb0182b0bf3a2beabe523
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Fri Mar 22 19:33:46 2019 -0400

    drm/amd/display: prefer preferred link cap over verified link settings
    
    [why]
    when preferred link cap is set, we should always use
    preferred in all validation.
    we should not use preferred for some validation but use
    verified for others.
    
    [how]
    create getter function that gets verified link cap.
    if preferred is set, return preferred link settings instead.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 51b85a8ef9f2..2b1cd8bd5e03 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -597,6 +597,15 @@ uint32_t dc_link_bandwidth_kbps(
 
 }
 
+const struct dc_link_settings *dc_link_get_verified_link_cap(
+		const struct dc_link *link)
+{
+	if (link->preferred_link_setting.lane_count != LANE_COUNT_UNKNOWN &&
+			link->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN)
+		return &link->preferred_link_setting;
+	return &link->verified_link_cap;
+}
+
 static void destruct(struct dc *dc)
 {
 	dc_release_state(dc->current_state);

commit 332c11914a76200dfbafc6b46ae5e728216aac00
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Tue Mar 19 19:47:32 2019 -0400

    drm/amd/display: Calculate link bandwidth in a common function
    
    [why]
    Currently link bandwidth is calculated in two places, using the same
    formula. They should be unified into calling one function.
    
    [how]
    Replace all implementations of link bandwidth calculation with a call
    to a function.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5f05e191f0ff..51b85a8ef9f2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -584,6 +584,19 @@ void dc_link_set_test_pattern(struct dc_link *link,
 			cust_pattern_size);
 }
 
+uint32_t dc_link_bandwidth_kbps(
+	const struct dc_link *link,
+	const struct dc_link_settings *link_setting)
+{
+	uint32_t link_bw_kbps = link_setting->link_rate * LINK_RATE_REF_FREQ_IN_KHZ; /* bytes per sec */
+
+	link_bw_kbps *= 8;   /* 8 bits per byte*/
+	link_bw_kbps *= link_setting->lane_count;
+
+	return link_bw_kbps;
+
+}
+
 static void destruct(struct dc *dc)
 {
 	dc_release_state(dc->current_state);

commit 805ab8f7da89c7f2a2ad39b149ac82beb62ba513
Author: Leo Li <sunpeng.li@amd.com>
Date:   Thu Mar 21 10:36:07 2019 -0400

    drm/amd/display: Fix "dc has no member named dml" compile error
    
    For DCN disabled builds, dc->dml is stripped out. Therefore, guard usage
    in dc_create_state() with CONFIG_DRM_AMD_DC_DCN1_0.
    
    It fixes the following error:
    
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c: In function 'dc_create_state':
    >> drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:1237:34: error: 'struct dc' has no member named 'dml'
         memcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));
                                         ^~
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1c1cfb513620..5f05e191f0ff 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1229,7 +1229,9 @@ struct dc_state *dc_create_state(struct dc *dc)
 	 * initialize and obtain IP and SOC the base DML instance from DC is
 	 * initially copied into every context
 	 */
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	memcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));
+#endif
 
 	kref_init(&context->refcount);
 

commit 813d20dccf93f84f4c16236f7c037dc34db48f10
Author: Aidan Wood <Aidan.Wood@amd.com>
Date:   Fri Feb 22 13:37:03 2019 -0500

    drm/amd/display: Fix multi-thread writing to 1 state
    
    [Why]
    Multiple threads were writing back to one global VBA in DC resulting
    in multiple threads overwriting eachother's data
    
    [How]
    Add an instance of DML (which contains VBA) to each context and
    change all calls that used dc->dml to use context->dml. Created a
    seperate copy constructor for linux in a case where there is no
    access to DC.
    
    Signed-off-by: Aidan Wood <Aidan.Wood@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c7415772e280..1c1cfb513620 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -681,13 +681,6 @@ static bool construct(struct dc *dc,
 	dc_ctx->dc_stream_id_count = 0;
 	dc->ctx = dc_ctx;
 
-	dc->current_state = dc_create_state();
-
-	if (!dc->current_state) {
-		dm_error("%s: failed to create validate ctx\n", __func__);
-		goto fail;
-	}
-
 	/* Create logger */
 
 	dc_ctx->dce_environment = init_params->dce_environment;
@@ -739,6 +732,18 @@ static bool construct(struct dc *dc,
 	if (!dc->res_pool)
 		goto fail;
 
+	/* Creation of current_state must occur after dc->dml
+	 * is initialized in dc_create_resource_pool because
+	 * on creation it copies the contents of dc->dml
+	 */
+
+	dc->current_state = dc_create_state(dc);
+
+	if (!dc->current_state) {
+		dm_error("%s: failed to create validate ctx\n", __func__);
+		goto fail;
+	}
+
 	dc_resource_state_construct(dc, dc->current_state);
 
 	if (!create_links(dc, init_params->num_virtual_links))
@@ -755,7 +760,7 @@ static bool construct(struct dc *dc,
 static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
 {
 	int i, j;
-	struct dc_state *dangling_context = dc_create_state();
+	struct dc_state *dangling_context = dc_create_state(dc);
 	struct dc_state *current_ctx;
 
 	if (dangling_context == NULL)
@@ -1213,18 +1218,58 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	return true;
 }
 
-struct dc_state *dc_create_state(void)
+struct dc_state *dc_create_state(struct dc *dc)
 {
 	struct dc_state *context = kzalloc(sizeof(struct dc_state),
 					   GFP_KERNEL);
 
 	if (!context)
 		return NULL;
+	/* Each context must have their own instance of VBA and in order to
+	 * initialize and obtain IP and SOC the base DML instance from DC is
+	 * initially copied into every context
+	 */
+	memcpy(&context->bw_ctx.dml, &dc->dml, sizeof(struct display_mode_lib));
 
 	kref_init(&context->refcount);
+
 	return context;
 }
 
+struct dc_state *dc_copy_state(struct dc_state *src_ctx)
+{
+	int i, j;
+	struct dc_state *new_ctx = kzalloc(sizeof(struct dc_state),
+					   GFP_KERNEL);
+
+	if (!new_ctx)
+		return NULL;
+
+	memcpy(new_ctx, src_ctx, sizeof(struct dc_state));
+
+	for (i = 0; i < MAX_PIPES; i++) {
+			struct pipe_ctx *cur_pipe = &new_ctx->res_ctx.pipe_ctx[i];
+
+			if (cur_pipe->top_pipe)
+				cur_pipe->top_pipe =  &new_ctx->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+
+			if (cur_pipe->bottom_pipe)
+				cur_pipe->bottom_pipe = &new_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+
+	}
+
+	for (i = 0; i < new_ctx->stream_count; i++) {
+			dc_stream_retain(new_ctx->streams[i]);
+			for (j = 0; j < new_ctx->stream_status[i].plane_count; j++)
+				dc_plane_state_retain(
+					new_ctx->stream_status[i].plane_states[j]);
+	}
+
+	kref_init(&new_ctx->refcount);
+
+	return new_ctx;
+}
+
 void dc_retain_state(struct dc_state *context)
 {
 	kref_get(&context->refcount);
@@ -1824,7 +1869,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 	if (update_type >= UPDATE_TYPE_FULL) {
 
 		/* initialize scratch memory for building context */
-		context = dc_create_state();
+		context = dc_create_state(dc);
 		if (context == NULL) {
 			DC_ERROR("Failed to allocate new validate context!\n");
 			return;
@@ -2109,13 +2154,13 @@ void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 
 void get_clock_requirements_for_state(struct dc_state *state, struct AsicStateEx *info)
 {
-	info->displayClock				= (unsigned int)state->bw.dcn.clk.dispclk_khz;
-	info->engineClock				= (unsigned int)state->bw.dcn.clk.dcfclk_khz;
-	info->memoryClock				= (unsigned int)state->bw.dcn.clk.dramclk_khz;
-	info->maxSupportedDppClock		= (unsigned int)state->bw.dcn.clk.max_supported_dppclk_khz;
-	info->dppClock					= (unsigned int)state->bw.dcn.clk.dppclk_khz;
-	info->socClock					= (unsigned int)state->bw.dcn.clk.socclk_khz;
-	info->dcfClockDeepSleep			= (unsigned int)state->bw.dcn.clk.dcfclk_deep_sleep_khz;
-	info->fClock					= (unsigned int)state->bw.dcn.clk.fclk_khz;
-	info->phyClock					= (unsigned int)state->bw.dcn.clk.phyclk_khz;
+	info->displayClock				= (unsigned int)state->bw_ctx.bw.dcn.clk.dispclk_khz;
+	info->engineClock				= (unsigned int)state->bw_ctx.bw.dcn.clk.dcfclk_khz;
+	info->memoryClock				= (unsigned int)state->bw_ctx.bw.dcn.clk.dramclk_khz;
+	info->maxSupportedDppClock		= (unsigned int)state->bw_ctx.bw.dcn.clk.max_supported_dppclk_khz;
+	info->dppClock					= (unsigned int)state->bw_ctx.bw.dcn.clk.dppclk_khz;
+	info->socClock					= (unsigned int)state->bw_ctx.bw.dcn.clk.socclk_khz;
+	info->dcfClockDeepSleep			= (unsigned int)state->bw_ctx.bw.dcn.clk.dcfclk_deep_sleep_khz;
+	info->fClock					= (unsigned int)state->bw_ctx.bw.dcn.clk.fclk_khz;
+	info->phyClock					= (unsigned int)state->bw_ctx.bw.dcn.clk.phyclk_khz;
 }

commit d9673c920c035df8f17445d5c81142dbe4bf51a0
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Feb 13 16:20:27 2019 -0500

    drm/amd/display: Pass init_data into DCN resource creation
    
    [WHY]
    The resource constructor currently needs num_virtual_links from
    init_data but will need access to other items provided by DM.
    
    [HOW]
    Pass init_data into DCN create_resource_pool functions.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Hersen Wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 699e1ee75035..c7415772e280 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -735,11 +735,7 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 
-	dc->res_pool = dc_create_resource_pool(
-			dc,
-			init_params->num_virtual_links,
-			dc_version,
-			init_params->asic_id);
+	dc->res_pool = dc_create_resource_pool(dc, init_params, dc_version);
 	if (!dc->res_pool)
 		goto fail;
 

commit 66acd4418d7de131ef3831e52a8af3d2480e5b15
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Mon Mar 4 16:21:06 2019 -0500

    drm/amd/display: Link train only when link is DP and backend is enabled
    
    [Why]
    In certain cases we do link training when we don't have a backend.
    
    [How]
    In dc_link_set_preferred_link_settings(), store preferred link settings
    first and then verify that the link is DP and the link stream's backend is
    enabled.  If either is false, then we will not do any link retraining.
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 260a01ebd888..699e1ee75035 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -524,6 +524,14 @@ void dc_link_set_preferred_link_settings(struct dc *dc,
 	struct dc_stream_state *link_stream;
 	struct dc_link_settings store_settings = *link_setting;
 
+	link->preferred_link_setting = store_settings;
+
+	/* Retrain with preferred link settings only relevant for
+	 * DP signal type
+	 */
+	if (!dc_is_dp_signal(link->connector_signal))
+		return;
+
 	for (i = 0; i < MAX_PIPES; i++) {
 		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 		if (pipe->stream && pipe->stream->link) {
@@ -538,7 +546,10 @@ void dc_link_set_preferred_link_settings(struct dc *dc,
 
 	link_stream = link->dc->current_state->res_ctx.pipe_ctx[i].stream;
 
-	link->preferred_link_setting = store_settings;
+	/* Cannot retrain link if backend is off */
+	if (link_stream->dpms_off)
+		return;
+
 	if (link_stream)
 		decide_link_settings(link_stream, &store_settings);
 

commit e6bddf6c67f9a3abf6f1ef75e52bc1cd228dfe4d
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed Feb 20 14:00:55 2019 -0500

    drm/amd/display: add pipe lock during stream update
    
    [why]
    Stream update will adjust both info packets and stream params,
    need to make sure all things are applied togather.
    
    [how]
    add pipe lock during stream update
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b65551d07e4f..260a01ebd888 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1672,6 +1672,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				continue;
 
 			if (stream_update->dpms_off) {
+				dc->hwss.pipe_control_lock(dc, pipe_ctx, true);
 				if (*stream_update->dpms_off) {
 					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
 					dc->hwss.optimize_bandwidth(dc, dc->current_state);
@@ -1679,6 +1680,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					dc->hwss.prepare_bandwidth(dc, dc->current_state);
 					core_link_enable_stream(dc->current_state, pipe_ctx);
 				}
+				dc->hwss.pipe_control_lock(dc, pipe_ctx, false);
 			}
 
 			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {

commit 87d44f62d51fddce9dd7c0a7badc3e6723b30e9d
Author: Charlene Liu <Charlene.Liu@amd.com>
Date:   Wed Feb 13 19:48:31 2019 -0500

    Revert "drm/amd/display: dcn add check surface in_use"
    
    This reverts commit 6bff1cc7780cca2fd2a775aa7b18b789e2a1b608.
    
    [Description]
    Revert since this will be checked at CP side.
    
    Signed-off-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 96090d6ce7a9..b65551d07e4f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1746,9 +1746,6 @@ static void commit_planes_for_stream(struct dc *dc,
 
 			if (!pipe_ctx->plane_state)
 				continue;
-			/*make sure hw finished surface update*/
-			if (dc->hwss.wait_surface_safe_to_update)
-				dc->hwss.wait_surface_safe_to_update(dc, pipe_ctx);
 
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)

commit 46570f090469c8c453622523ae5ccede256148f5
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Feb 8 20:50:51 2019 -0500

    drm/amd/display: Keep clocks high before seamless boot done
    
    [Why]
    UEFI boot usually uses a boot profile that uses higher clocks
    and watermark settings.
    UEFI boot surface is less optimal, for example it uses linear surface
    
    [How]
    Before we finish our seamless boot sequence, keep the clock and
    watermark settings from boot.
    Update to optimal settings only after first flip away from UEFI
    frame buffer.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 679f1441f3b7..96090d6ce7a9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -971,7 +971,7 @@ static bool context_changed(
 	return false;
 }
 
-bool dc_validate_seamless_boot_timing(struct dc *dc,
+bool dc_validate_seamless_boot_timing(const struct dc *dc,
 				const struct dc_sink *sink,
 				struct dc_crtc_timing *crtc_timing)
 {
@@ -1062,7 +1062,13 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc, context);
 
-	dc->hwss.prepare_bandwidth(dc, context);
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->apply_seamless_boot_optimization)
+			dc->optimize_seamless_boot = true;
+	}
+
+	if (!dc->optimize_seamless_boot)
+		dc->hwss.prepare_bandwidth(dc, context);
 
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use
@@ -1137,8 +1143,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	/* pplib is notified if disp_num changed */
-	dc->hwss.optimize_bandwidth(dc, context);
+	if (!dc->optimize_seamless_boot)
+		/* pplib is notified if disp_num changed */
+		dc->hwss.optimize_bandwidth(dc, context);
 
 	for (i = 0; i < context->stream_count; i++)
 		context->streams[i]->mode_changed = false;
@@ -1181,7 +1188,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct dc_state *context = dc->current_state;
 
-	if (dc->optimized_required == false)
+	if (!dc->optimized_required || dc->optimize_seamless_boot)
 		return true;
 
 	post_surface_trace(dc);
@@ -1699,7 +1706,16 @@ static void commit_planes_for_stream(struct dc *dc,
 	int i, j;
 	struct pipe_ctx *top_pipe_to_program = NULL;
 
-	if (update_type == UPDATE_TYPE_FULL) {
+	if (dc->optimize_seamless_boot && surface_count > 0) {
+		/* Optimize seamless boot flag keeps clocks and watermarks high until
+		 * first flip. After first flip, optimization is required to lower
+		 * bandwidth.
+		 */
+		dc->optimize_seamless_boot = false;
+		dc->optimized_required = true;
+	}
+
+	if (update_type == UPDATE_TYPE_FULL && !dc->optimize_seamless_boot) {
 		dc->hwss.prepare_bandwidth(dc, context);
 		context_clock_trace(dc, context);
 	}

commit e85c2d63a1c480c3e961a301c8c7691dc0bb841b
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Feb 12 12:09:24 2019 -0500

    drm/amd/display: add full update commit hint struct
    
    In some cases we might need to do a full update. Add a commit_hints
    struct for future use
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5dfc2e3ede6d..679f1441f3b7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1143,6 +1143,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	for (i = 0; i < context->stream_count; i++)
 		context->streams[i]->mode_changed = false;
 
+	memset(&context->commit_hints, 0, sizeof(context->commit_hints));
+
 	dc_release_state(dc->current_state);
 
 	dc->current_state = context;

commit 6649f19a364606b6475b61338422eed9845a0d61
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Thu Feb 7 18:54:35 2019 -0500

    drm/amd/display: Add ability to override bounding box in DC construct
    
    Add a dc_bounding_box_overrides struct to define bb overrides. It is
    loaded in during DC init.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1bfd9ba18b6d..5dfc2e3ede6d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -621,6 +621,8 @@ static bool construct(struct dc *dc,
 #endif
 
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
+	memcpy(&dc->bb_overrides, &init_params->bb_overrides, sizeof(dc->bb_overrides));
+
 	dc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);
 	if (!dc_dceip) {
 		dm_error("%s: failed to create dceip\n", __func__);

commit 2750160bccab4d7a4017197a3f0d75ee8cc4c6af
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Feb 4 14:36:13 2019 -0500

    drm/amd/display: dcn add check surface in_use
    
    Driver need to  poll the SURFACE_INUSE register to determine when to
    start the new task and write data to the checked surface.
    
    Implement the wait functions, and add the necessary hubbub registers.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c68fbd55db3c..1bfd9ba18b6d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1726,6 +1726,9 @@ static void commit_planes_for_stream(struct dc *dc,
 
 			if (!pipe_ctx->plane_state)
 				continue;
+			/*make sure hw finished surface update*/
+			if (dc->hwss.wait_surface_safe_to_update)
+				dc->hwss.wait_surface_safe_to_update(dc, pipe_ctx);
 
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)

commit d6001aed266391e05517ff03078c144d4b279d5d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 25 14:40:14 2019 -0500

    drm/amd/display: Refactor for setup periodic interrupt.
    
    [Why]
    Current periodic interrupt start point calc in optc
    is not clear.
    
    [How]
    1. DM convert delta time to lines number and dc will calculate the
       start position as per lines number and interrupt type.
    2. hwss calculates the start point as per line offset.
    3. optc programs vertical interrupts register as per start point
       and interrupt source.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8879cd4bb70c..c68fbd55db3c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1626,13 +1626,13 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					stream_update->adjust->v_total_min,
 					stream_update->adjust->v_total_max);
 
-			if (stream_update->periodic_vsync_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
-				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, VLINE0, &stream->periodic_vsync_config);
+			if (stream_update->periodic_interrupt0 &&
+					dc->hwss.setup_periodic_interrupt)
+				dc->hwss.setup_periodic_interrupt(pipe_ctx, VLINE0);
 
-			if (stream_update->enhanced_sync_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
-				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, VLINE1, &stream->enhanced_sync_config);
+			if (stream_update->periodic_interrupt1 &&
+					dc->hwss.setup_periodic_interrupt)
+				dc->hwss.setup_periodic_interrupt(pipe_ctx, VLINE1);
 
 			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||

commit d8d2f174bcc2c26c3485c70e0c6fe22b27bce739
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Jan 25 15:23:09 2019 -0500

    drm/amd/display: Clear stream->mode_changed after commit
    
    [Why]
    The stream->mode_changed flag can persist in the following sequence
    of atomic commits:
    
    Commit 1:
    Enable CRTC0 (mode_changed = true), Enable CRTC1 (mode_changed = true)
    
    Commit 2:
    Disable CRTC1 (mode_changed = false)
    
    In this sequence we want to keep the exiting CRTC0 but it's not in the
    atomic state for the commit since it hasn't been modified. In this case
    the stream->mode_changed flag persists as true and we don't re-program
    the planes for the existing stream.
    
    [How]
    The flag needs to be cleared and it makes the most sense to do it within
    DC after the state has been committed. Nothing following dc_commit_state
    should think that the stream's mode has changed.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 52f838442e21..8879cd4bb70c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1138,6 +1138,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	/* pplib is notified if disp_num changed */
 	dc->hwss.optimize_bandwidth(dc, context);
 
+	for (i = 0; i < context->stream_count; i++)
+		context->streams[i]->mode_changed = false;
+
 	dc_release_state(dc->current_state);
 
 	dc->current_state = context;

commit d2d7885f75b614a982a73383956570d95d79c23e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:41:44 2019 -0500

    drm/amd/display: add seamless boot flag to stream
    
    [Why]
    If we determine the stream we are trying to commit
    matches HW, we want to try to optimize.
    
    [How]
    Try to acquire the HW resources that are already enabled
    and optimize.
    Also skip backend reprogramming
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b620520771a7..52f838442e21 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1096,6 +1096,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 		const struct dc_link *link = context->streams[i]->link;
 		struct dc_stream_status *status;
 
+		if (context->streams[i]->apply_seamless_boot_optimization)
+			context->streams[i]->apply_seamless_boot_optimization = false;
+
 		if (!context->streams[i]->mode_changed)
 			continue;
 

commit 68f1a00c23d443c9d940fbd512a195e9e6c08b11
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:08:02 2019 -0500

    drm/amd/display: interface to check if timing can be seamless
    
    [Why]
    Need to figure out whether a timing we want to commit matches
    something that GOP already programmed, in which case
    we can decide to some optimizations
    
    [How]
    1. Add way to check for DIG FE
    2. Add way to check for matching OTG timing
    3. Add way to check for matching pixel clock (if possible)
        - Currently only support DP for pixel clock, since it is easy to calc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 77e1bd18b1dd..b620520771a7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -969,6 +969,52 @@ static bool context_changed(
 	return false;
 }
 
+bool dc_validate_seamless_boot_timing(struct dc *dc,
+				const struct dc_sink *sink,
+				struct dc_crtc_timing *crtc_timing)
+{
+	struct timing_generator *tg;
+	struct dc_link *link = sink->link;
+	unsigned int inst;
+
+	/* Check for enabled DIG to identify enabled display */
+	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))
+		return false;
+
+	/* Check for which front end is used by this encoder.
+	 * Note the inst is 1 indexed, where 0 is undefined.
+	 * Note that DIG_FE can source from different OTG but our
+	 * current implementation always map 1-to-1, so this code makes
+	 * the same assumption and doesn't check OTG source.
+	 */
+	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc) - 1;
+
+	/* Instance should be within the range of the pool */
+	if (inst >= dc->res_pool->pipe_count)
+		return false;
+
+	tg = dc->res_pool->timing_generators[inst];
+
+	if (!tg->funcs->is_matching_timing)
+		return false;
+
+	if (!tg->funcs->is_matching_timing(tg, crtc_timing))
+		return false;
+
+	if (dc_is_dp_signal(link->connector_signal)) {
+		unsigned int pix_clk_100hz;
+
+		dc->res_pool->dp_clock_source->funcs->get_pixel_clk_frequency_100hz(
+			dc->res_pool->dp_clock_source,
+			inst, &pix_clk_100hz);
+
+		if (crtc_timing->pix_clk_100hz != pix_clk_100hz)
+			return false;
+	}
+
+	return true;
+}
+
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct dc_state *context,

commit e6d2421343a78a3ef83d7839a8704dd2eb3c9a69
Author: Murton Liu <murton.liu@amd.com>
Date:   Wed Jan 23 17:37:57 2019 -0500

    drm/amd/display: PIP overlay corruption
    
    [Why]
    When moving mouse onto or off of pip plane,
    screen would flash briefly due to garbage negative
    pos values being programmed for cursor.
    Also, text flashes due to PIP flips taking too long.
    
    [How]
    When negative pos value seen, default to 0 and adjust by modifying cursor hotspot.
    For flip issue, only do post update when optimize required vs all the time.
    
    Signed-off-by: Murton Liu <murton.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Sivapiriyan Kumarasamy <Sivapiriyan.Kumarasamy@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index af5f486d24e0..77e1bd18b1dd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1125,6 +1125,9 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct dc_state *context = dc->current_state;
 
+	if (dc->optimized_required == false)
+		return true;
+
 	post_surface_trace(dc);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)

commit 00fbeb4e2f9eda0ebd57eefdcf25e41958f98fa5
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Mon Jan 21 14:40:16 2019 -0500

    drm/amd/display: DC VM Fixes
    
    [Why]
    VM_helper needs to be intialized with the dc struct in order to fix
    an unallocated memory issue. System aperture settings should be
    initialized to 0 and guarded with a check to make sure vm_config
    is valid.
    
    [How]
    Allocate and free memory for vm_helper with other dc members.
    Check whether the vm_config valid bit is set before initializing
    aperture settings.
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 409097cf58ed..af5f486d24e0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -621,7 +621,6 @@ static bool construct(struct dc *dc,
 #endif
 
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
-
 	dc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);
 	if (!dc_dceip) {
 		dm_error("%s: failed to create dceip\n", __func__);

commit 810ece19ee74c5705190ef18ccb292e7930a2377
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Jan 24 15:59:22 2019 -0500

    drm/amd/display: Calc vline position in dc.
    
    We need to calcualte vline position in DC for DCN.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d9f62befd86a..409097cf58ed 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1572,13 +1572,13 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					stream_update->adjust->v_total_min,
 					stream_update->adjust->v_total_max);
 
-			if (stream_update->vline0_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+			if (stream_update->periodic_vsync_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
 				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, VLINE0, &stream->vline0_config);
+					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, VLINE0, &stream->periodic_vsync_config);
 
-			if (stream_update->vline1_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+			if (stream_update->enhanced_sync_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
 				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, VLINE1, &stream->vline1_config);
+					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing, VLINE1, &stream->enhanced_sync_config);
 
 			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||

commit 8dac4e7d89ea3b09695c0948d375a62df9443ca0
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Mon Jan 21 12:01:53 2019 -0500

    drm/amd/display: store timing sync info in dc_stream_status
    
    in program_timing_sync, after all the pipes are
    grouped, store timing sync info in dc_stream_status
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d8579b207300..d9f62befd86a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -869,8 +869,9 @@ static void program_timing_sync(
 		struct dc *dc,
 		struct dc_state *ctx)
 {
-	int i, j;
+	int i, j, k;
 	int group_index = 0;
+	int num_group = 0;
 	int pipe_count = dc->res_pool->pipe_count;
 	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
 
@@ -922,6 +923,18 @@ static void program_timing_sync(
 			}
 		}
 
+
+		for (k = 0; k < group_size; k++) {
+			struct dc_stream_status *status = dc_stream_get_status_from_state(ctx, pipe_set[k]->stream);
+
+			status->timing_sync_info.group_id = num_group;
+			status->timing_sync_info.group_size = group_size;
+			if (k == 0)
+				status->timing_sync_info.master = true;
+			else
+				status->timing_sync_info.master = false;
+
+		}
 		/* remove any other pipes with plane as they have already been synced */
 		for (j = j + 1; j < group_size; j++) {
 			if (pipe_set[j]->plane_state) {
@@ -936,6 +949,7 @@ static void program_timing_sync(
 				dc, group_index, group_size, pipe_set);
 			group_index++;
 		}
+		num_group++;
 	}
 }
 

commit 056f05f65bf42cb69c48bf1bb6e085c7a405a565
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 18 19:44:33 2019 -0500

    drm/amd/display: pass vline_config parameter by reference.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e0ac009f00ab..d8579b207300 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1560,11 +1560,11 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 			if (stream_update->vline0_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
 				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, VLINE0, stream->vline0_config);
+					pipe_ctx->stream_res.tg, VLINE0, &stream->vline0_config);
 
 			if (stream_update->vline1_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
 				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, VLINE1, stream->vline1_config);
+					pipe_ctx->stream_res.tg, VLINE1, &stream->vline1_config);
 
 			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||

commit 5fc0cbfad4564856ee0f323d3f88a7cff19cc3f1
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Fri Jan 18 18:19:51 2019 -0500

    drm/amd/display: determine if a pipe is synced by plane state
    
    [why]
    is_blanked is not a general indicator of if a pipe is synced
    for all asics.
    plane state is more accurate and applicable for all asics.
    
    [how]
    Remove is_blanked call and
    add checking plane_state against NULL instead.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index db8252ec3671..e0ac009f00ab 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -907,11 +907,11 @@ static void program_timing_sync(
 			}
 		}
 
-		/* set first unblanked pipe as master */
+		/* set first pipe with plane as master */
 		for (j = 0; j < group_size; j++) {
 			struct pipe_ctx *temp;
 
-			if (pipe_set[j]->stream_res.tg->funcs->is_blanked && !pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
+			if (pipe_set[j]->plane_state) {
 				if (j == 0)
 					break;
 
@@ -922,9 +922,9 @@ static void program_timing_sync(
 			}
 		}
 
-		/* remove any other unblanked pipes as they have already been synced */
+		/* remove any other pipes with plane as they have already been synced */
 		for (j = j + 1; j < group_size; j++) {
-			if (pipe_set[j]->stream_res.tg->funcs->is_blanked && !pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
+			if (pipe_set[j]->plane_state) {
 				group_size--;
 				pipe_set[j] = pipe_set[group_size];
 				j--;

commit f3e3698d05454f2aeb9ef9969fc58a68090441ad
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Jan 9 09:14:54 2019 -0500

    drm/amd/display: Apply all surface updates onto surfaces
    
    [Why]
    Most surface updates weren't propagated onto the surface during
    dc_commit_updates_for_stream. This makes it more difficult for DC to
    determine the actual surface update type required.
    
    [How]
    Use copy_surface_update_to_plane to propagate the changes. The FreeSync
    surface timing information update for BTR has been moved out of
    amdgpu_dm.c into this function as well.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e22be0aefd1b..db8252ec3671 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1440,6 +1440,101 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
+static void copy_surface_update_to_plane(
+		struct dc_plane_state *surface,
+		struct dc_surface_update *srf_update)
+{
+	if (srf_update->flip_addr) {
+		surface->address = srf_update->flip_addr->address;
+		surface->flip_immediate =
+			srf_update->flip_addr->flip_immediate;
+		surface->time.time_elapsed_in_us[surface->time.index] =
+			srf_update->flip_addr->flip_timestamp_in_us -
+				surface->time.prev_update_time_in_us;
+		surface->time.prev_update_time_in_us =
+			srf_update->flip_addr->flip_timestamp_in_us;
+		surface->time.index++;
+		if (surface->time.index >= DC_PLANE_UPDATE_TIMES_MAX)
+			surface->time.index = 0;
+	}
+
+	if (srf_update->scaling_info) {
+		surface->scaling_quality =
+				srf_update->scaling_info->scaling_quality;
+		surface->dst_rect =
+				srf_update->scaling_info->dst_rect;
+		surface->src_rect =
+				srf_update->scaling_info->src_rect;
+		surface->clip_rect =
+				srf_update->scaling_info->clip_rect;
+	}
+
+	if (srf_update->plane_info) {
+		surface->color_space =
+				srf_update->plane_info->color_space;
+		surface->format =
+				srf_update->plane_info->format;
+		surface->plane_size =
+				srf_update->plane_info->plane_size;
+		surface->rotation =
+				srf_update->plane_info->rotation;
+		surface->horizontal_mirror =
+				srf_update->plane_info->horizontal_mirror;
+		surface->stereo_format =
+				srf_update->plane_info->stereo_format;
+		surface->tiling_info =
+				srf_update->plane_info->tiling_info;
+		surface->visible =
+				srf_update->plane_info->visible;
+		surface->per_pixel_alpha =
+				srf_update->plane_info->per_pixel_alpha;
+		surface->global_alpha =
+				srf_update->plane_info->global_alpha;
+		surface->global_alpha_value =
+				srf_update->plane_info->global_alpha_value;
+		surface->dcc =
+				srf_update->plane_info->dcc;
+		surface->sdr_white_level =
+				srf_update->plane_info->sdr_white_level;
+	}
+
+	if (srf_update->gamma &&
+			(surface->gamma_correction !=
+					srf_update->gamma)) {
+		memcpy(&surface->gamma_correction->entries,
+			&srf_update->gamma->entries,
+			sizeof(struct dc_gamma_entries));
+		surface->gamma_correction->is_identity =
+			srf_update->gamma->is_identity;
+		surface->gamma_correction->num_entries =
+			srf_update->gamma->num_entries;
+		surface->gamma_correction->type =
+			srf_update->gamma->type;
+	}
+
+	if (srf_update->in_transfer_func &&
+			(surface->in_transfer_func !=
+				srf_update->in_transfer_func)) {
+		surface->in_transfer_func->sdr_ref_white_level =
+			srf_update->in_transfer_func->sdr_ref_white_level;
+		surface->in_transfer_func->tf =
+			srf_update->in_transfer_func->tf;
+		surface->in_transfer_func->type =
+			srf_update->in_transfer_func->type;
+		memcpy(&surface->in_transfer_func->tf_pts,
+			&srf_update->in_transfer_func->tf_pts,
+			sizeof(struct dc_transfer_func_distributed_points));
+	}
+
+	if (srf_update->input_csc_color_matrix)
+		surface->input_csc_color_matrix =
+			*srf_update->input_csc_color_matrix;
+
+	if (srf_update->coeff_reduction_factor)
+		surface->coeff_reduction_factor =
+			*srf_update->coeff_reduction_factor;
+}
+
 static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update,
@@ -1645,14 +1740,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 	for (i = 0; i < surface_count; i++) {
 		struct dc_plane_state *surface = srf_updates[i].surface;
 
-		/* TODO: On flip we don't build the state, so it still has the
-		 * old address. Which is why we are updating the address here
-		 */
-		if (srf_updates[i].flip_addr) {
-			surface->address = srf_updates[i].flip_addr->address;
-			surface->flip_immediate = srf_updates[i].flip_addr->flip_immediate;
-
-		}
+		copy_surface_update_to_plane(surface, &srf_updates[i]);
 
 		if (update_type >= UPDATE_TYPE_MED) {
 			for (j = 0; j < dc->res_pool->pipe_count; j++) {

commit 8fde60b7f350045614aecbc433eda830b5413b6d
Author: Fatemeh Darbehani <fatemeh.darbehani@amd.com>
Date:   Fri Jan 11 11:00:26 2019 -0500

    drm/amd/display: Add Vline1 interrupt source to InterruptManager
    
    [Why]
    Enhanced sync need to use vertical_interrupt1.
    
    [How]
    Add vertical_interrupt1 source to irq manger,
    Implment setup vline interrupt interface.
    
    Signed-off-by: Fatemeh Darbehani <fatemeh.darbehani@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1dabafc12cfe..e22be0aefd1b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1463,11 +1463,13 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					stream_update->adjust->v_total_min,
 					stream_update->adjust->v_total_max);
 
-			if (stream_update->periodic_fn_vsync_delta &&
-					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+			if (stream_update->vline0_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
 				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
-					pipe_ctx->stream->periodic_fn_vsync_delta);
+					pipe_ctx->stream_res.tg, VLINE0, stream->vline0_config);
+
+			if (stream_update->vline1_config && pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
+					pipe_ctx->stream_res.tg, VLINE1, stream->vline1_config);
 
 			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||

commit 4ef9f1ec837be562b42a1c0f196c4ef371b2ed84
Author: David Francis <David.Francis@amd.com>
Date:   Thu Jan 3 14:38:06 2019 -0500

    drm/amd/display: Let updates with no scaling changes be fast
    
    [Why]
    DC was assuming that any surface_update->scaling_info
    meant the update was at least medium.  However, if nothing
    has changed there is no scaling to program, so there is
    no problem with the update being fast
    
    [How]
    If every update flag is not set, the update is fast
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 56702840710b..1dabafc12cfe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1240,7 +1240,7 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 			|| update_flags->bits.output_tf_change)
 		return UPDATE_TYPE_FULL;
 
-	return UPDATE_TYPE_MED;
+	return update_flags->raw ? UPDATE_TYPE_MED : UPDATE_TYPE_FAST;
 }
 
 static enum surface_update_type get_scaling_info_update_type(

commit 077d0b6ba2114b86d353fce4eaca6cfb2e344eb6
Author: David Francis <David.Francis@amd.com>
Date:   Fri Nov 30 11:02:59 2018 -0500

    drm/amd/display: Remove i2caux folder
    
    [Why]
    It is huge, unmaintainable, needlessly layered, and obsolete
    
    [How]
    Remove it.  All of it.  Also remove the i2caux struct in
    dc_context and the code that created and destructed it
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c94bc405d135..56702840710b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -585,9 +585,6 @@ static void destruct(struct dc *dc)
 	if (dc->ctx->gpio_service)
 		dal_gpio_service_destroy(&dc->ctx->gpio_service);
 
-	if (dc->ctx->i2caux)
-		dal_i2caux_destroy(&dc->ctx->i2caux);
-
 	if (dc->ctx->created_bios)
 		dal_bios_parser_destroy(&dc->ctx->dc_bios);
 
@@ -709,14 +706,6 @@ static bool construct(struct dc *dc,
 		dc_ctx->created_bios = true;
 		}
 
-	/* Create I2C AUX */
-	dc_ctx->i2caux = dal_i2caux_create(dc_ctx);
-
-	if (!dc_ctx->i2caux) {
-		ASSERT_CRITICAL(false);
-		goto fail;
-	}
-
 	dc_ctx->perf_trace = dc_perf_trace_create();
 	if (!dc_ctx->perf_trace) {
 		ASSERT_CRITICAL(false);

commit 4bd0dc68fd00f41ed64fbcfe7b7afe93763b04ad
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Mon Dec 10 13:46:34 2018 -0500

    drm/amd/display: Fix missing hwss function for dce
    
    [Why]
    The driver will crash on dce hardware due to a null function pointer.
    
    [How]
    - bring back "program_csc_matrix" functionality as "program_output_csc" for
    dce110
    - dce110 doesn't use the "opp_id" parameter, so use 0 when there's no hubp
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index af907d541318..c94bc405d135 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -451,7 +451,7 @@ bool dc_stream_program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 					pipes,
 					stream->output_color_space,
 					stream->csc_color_matrix.matrix,
-					pipes->plane_res.hubp->opp_id);
+					pipes->plane_res.hubp ? pipes->plane_res.hubp->opp_id : 0);
 			ret = true;
 		}
 	}

commit cfdb60f7673907c718a2c434f7ee6ecfe14d85b7
Author: David Francis <David.Francis@amd.com>
Date:   Mon Dec 10 10:18:21 2018 -0500

    drm/amd/display: Remove unused parameter plane_states
    
    [Why]
    The function dc_commit_updates_for_stream had a parameter called
    plane_states.  It was never used.  It was getting in the way
    of some cleanup work
    
    [How]
    Remove it
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 024f7ea6ba92..af907d541318 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1620,7 +1620,6 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		int surface_count,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update,
-		struct dc_plane_state **plane_states,
 		struct dc_state *state)
 {
 	const struct dc_stream_status *stream_status;

commit 09f609c34fc8b9cb560947ab11609259f5d42889
Author: Leo Li <sunpeng.li@amd.com>
Date:   Tue Nov 27 15:05:12 2018 -0500

    drm/amd/display: Fix driver load crash in amdgpu_dm
    
    [Why]
    This fixes an regression introduced by:
        drm/amd/display: add stream ID and otg instance in dc_stream_state
    
    During driver initialization, a null pointer deref is raised. This is
    caused by searching for a stream status in the dc->current_state before
    the dc_state swap happens at the end of dc_commit_state_no_check().
    Since the swap has not happened, the dc_state to be swapped in should
    be searched, and not dc->current_state.
    
    [How]
    Add a function that searches for the stream status within the given
    dc_state, instead of dc->current_state. Use that before the state swap
    happens in dc_commit_state_no_check().
    
    Also remove duplicate occurrences of this function in amdgpu_dm.c.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3872c82843a8..024f7ea6ba92 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1071,7 +1071,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 			}
 		}
 
-		status = dc_stream_get_status(context->streams[i]);
+		status = dc_stream_get_status_from_state(context, context->streams[i]);
 		context->streams[i]->out.otg_offset = status->primary_otg_inst;
 
 		CONN_MSG_MODE(link, "{%dx%d, %dx%d@%dKhz}",

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 66067a46eb6f..3872c82843a8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1079,7 +1079,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->streams[i]->timing.v_addressable,
 				context->streams[i]->timing.h_total,
 				context->streams[i]->timing.v_total,
-				context->streams[i]->timing.pix_clk_khz);
+				context->streams[i]->timing.pix_clk_100hz / 10);
 	}
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);

commit f284975ef2bcec6eb5ab51f61ea67f460ca49a03
Author: David Francis <David.Francis@amd.com>
Date:   Tue Nov 13 10:37:16 2018 -0500

    drm/amd/display: Add backlight pwm debugfs
    
    [Why]
    ABM enablement testing can be automated if a way of reading
    target and current hardware backlight is available
    
    [How]
    Expand debugfs interface with two new entries.
    Hook directly into dc interface.  Units are as
    a fraction of 0x1000 = 100%
    
    Use the built-in amdgpu function for creating
    read-only debugfs files
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7b9174b1432f..66067a46eb6f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1779,6 +1779,26 @@ void dc_resume(struct dc *dc)
 		core_link_resume(dc->links[i]);
 }
 
+unsigned int dc_get_current_backlight_pwm(struct dc *dc)
+{
+	struct abm *abm = dc->res_pool->abm;
+
+	if (abm)
+		return abm->funcs->get_current_backlight(abm);
+
+	return 0;
+}
+
+unsigned int dc_get_target_backlight_pwm(struct dc *dc)
+{
+	struct abm *abm = dc->res_pool->abm;
+
+	if (abm)
+		return abm->funcs->get_target_backlight(abm);
+
+	return 0;
+}
+
 bool dc_is_dmcu_initialized(struct dc *dc)
 {
 	struct dmcu *dmcu = dc->res_pool->dmcu;

commit 04a789bef315a3ed64f296fab21be3933405ea43
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 23 15:21:02 2018 -0500

    drm/amd/display: add stream ID and otg instance in dc_stream_state
    
    [why]
    stream ID allows DMs to avoid memory address comparisons to compare
    stream equality.
    otg_instance allows DC to more rigorously define when otg_instance
    can change.  specifically, it is now defined to be only mutable when dc_stream_state
    changes.  This is better than a "get status" function which prevents efficient
    caching of otherwise very stable information.
    
    [how]
    stream ID follows similar pattern to sink ID, which is already implemented
    
    otg_instance is an output which occurs on all dc_stream modification functions
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a3cd93825dcf..7b9174b1432f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -669,6 +669,7 @@ static bool construct(struct dc *dc,
 	dc_ctx->dc = dc;
 	dc_ctx->asic_id = init_params->asic_id;
 	dc_ctx->dc_sink_id_count = 0;
+	dc_ctx->dc_stream_id_count = 0;
 	dc->ctx = dc_ctx;
 
 	dc->current_state = dc_create_state();
@@ -1045,6 +1046,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	/* Program all planes within new context*/
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_link *link = context->streams[i]->link;
+		struct dc_stream_status *status;
 
 		if (!context->streams[i]->mode_changed)
 			continue;
@@ -1069,6 +1071,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 			}
 		}
 
+		status = dc_stream_get_status(context->streams[i]);
+		context->streams[i]->out.otg_offset = status->primary_otg_inst;
+
 		CONN_MSG_MODE(link, "{%dx%d, %dx%d@%dKhz}",
 				context->streams[i]->timing.h_addressable,
 				context->streams[i]->timing.v_addressable,

commit ceb3dbb4690db8377ad127a5666cd4775d9f70f4
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 9 09:21:21 2018 -0500

    drm/amd/display: remove sink reference in dc_stream_state
    
    [why]
    dc_stream_state containing a pointer to sink is poor design.
    Sink describes the display, and the specifications or capabilities
    it has.  That information is irrelevant for dc_stream_state, which describes
    hardware state, and is generally used for hardware programming.  It
    could further be argued that dc_sink itself is just a convenience dc
    provides, and DC should be perfectly capable of programming hardware
    without any dc_sinks (for example, emulated sinks).
    
    [how]
    Phase 1:
    Deprecate use of dc_sink pointer in dc_stream.  Most references are trivial
    to remove, but some call sites are risky (such as is_timing_changed) with
    no obvious logical replacement.  These will be removed in follow up change.
    
    Add dc_link pointer to dc_stream.  This is the typical reason DC really needed
    sink pointer, and most call sites are replaced with this.
    
    DMs also need minor updates, as all 3 DMs leverage stream->sink for
    some functionality.  this is replaced instead by a pointer to private data
    inside dc_stream_state, which is used by DMs as a quality of life improvment
    for some key functionality.  it allows DMs to set pointers have to their own objects
    which associate OS objects to dc_stream_states (such as DisplayTarget
    and amdgpu_dm_connector).  Without the private pointer, DMs would be
    forced to perform a lookup for callbacks.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ce34e3e0c31f..a3cd93825dcf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -384,7 +384,7 @@ void dc_stream_set_dither_option(struct dc_stream_state *stream,
 		enum dc_dither_option option)
 {
 	struct bit_depth_reduction_params params;
-	struct dc_link *link = stream->sink->link;
+	struct dc_link *link = stream->link;
 	struct pipe_ctx *pipes = NULL;
 	int i;
 
@@ -526,9 +526,8 @@ void dc_link_set_preferred_link_settings(struct dc *dc,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
-		if (pipe->stream && pipe->stream->sink
-			&& pipe->stream->sink->link) {
-			if (pipe->stream->sink->link == link)
+		if (pipe->stream && pipe->stream->link) {
+			if (pipe->stream->link == link)
 				break;
 		}
 	}
@@ -1045,7 +1044,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	/* Program all planes within new context*/
 	for (i = 0; i < context->stream_count; i++) {
-		const struct dc_sink *sink = context->streams[i]->sink;
+		const struct dc_link *link = context->streams[i]->link;
 
 		if (!context->streams[i]->mode_changed)
 			continue;
@@ -1070,7 +1069,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 			}
 		}
 
-		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
+		CONN_MSG_MODE(link, "{%dx%d, %dx%d@%dKhz}",
 				context->streams[i]->timing.h_addressable,
 				context->streams[i]->timing.v_addressable,
 				context->streams[i]->timing.h_total,

commit ebd084cd6509313307bc3b8fd9695f65aee8ff96
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Fri Nov 16 19:12:46 2018 +0800

    drm/amd/display: add plane size change check condition
    
    [Why]
    Driver didn't check plane size and surface size is mismatch.
    It will cause pitch data incorrect.
    
    [How]
    Add condition to check is plane change and update surface
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e12612be118d..ce34e3e0c31f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1220,6 +1220,12 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 		 */
 		update_flags->bits.bpp_change = 1;
 
+	if (u->plane_info->plane_size.grph.surface_pitch != u->surface->plane_size.grph.surface_pitch
+			|| u->plane_info->plane_size.video.luma_pitch != u->surface->plane_size.video.luma_pitch
+			|| u->plane_info->plane_size.video.chroma_pitch != u->surface->plane_size.video.chroma_pitch)
+		update_flags->bits.plane_size_change = 1;
+
+
 	if (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,
 			sizeof(union dc_tiling_info)) != 0) {
 		update_flags->bits.swizzle_change = 1;

commit d5cf79eeda52045bc685939b86975944312f688f
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Nov 13 18:21:53 2018 -0500

    drm/amd/display: implement dc_init_callbacks to assign callback pointers after dc_create
    
    [why]
    Some components depend on dc to constuct
    but need to assign callback functions to dc.
    
    [how]
    Instead of assigning dc callback functions in dc_create,
    decouple the callback init to a standlone function after dc_create. This
    is currently a no-op.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5fd52094d459..e12612be118d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -840,6 +840,11 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	return NULL;
 }
 
+void dc_init_callbacks(struct dc *dc,
+		const struct dc_callback_init *init_params)
+{
+}
+
 void dc_destroy(struct dc **dc)
 {
 	destruct(*dc);

commit c2c2ce1e9623fdce429c7df84ee8564074d84846
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 7 10:38:05 2018 -0500

    drm/amd/display: Optimize passive update planes.
    
    [Why]
    passive update planes still spends a litte more
    time on some cases.
    
    [How]
    Remove unnecessary trace which involving in some register read.
    Disable debug output for release build.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3a71049b61cb..5fd52094d459 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1570,9 +1570,6 @@ static void commit_planes_for_stream(struct dc *dc,
 		}
 	}
 
-	if (update_type == UPDATE_TYPE_FULL)
-		context_timing_trace(dc, &context->res_ctx);
-
 	// Update Type FAST, Surface updates
 	if (update_type == UPDATE_TYPE_FAST) {
 		/* Lock the top pipe while updating plane addrs, since freesync requires

commit fd0853567cdf2eeddf22ba9021deedf6b1f90f7a
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Nov 29 07:18:29 2018 -0500

    drm/amd/display: Fix bug with not updating VSP infoframe
    
    [WHY]
    Currently, when the VSP infopacket is rebuilt in DM, it is not updated
    when being programmed in encoder.
    
    [HOW]
    Add new VSP case for update_info_frame
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index aa11a176d673..3a71049b61cb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1467,7 +1467,8 @@ static void commit_planes_do_stream_update(struct dc *dc,
 
 			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||
-					stream_update->vsc_infopacket) {
+					stream_update->vsc_infopacket ||
+					stream_update->vsp_infopacket) {
 				resource_build_info_frame(pipe_ctx);
 				dc->hwss.update_info_frame(pipe_ctx);
 			}

commit d3302424e04d0c5ed478d80c0ff53783091f31f4
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Dec 4 14:10:58 2018 -0500

    drm/amd/display: Don't log error if we have no connectors
    
    [Why]
    In certain configurations, such as PX configs or some Vega20 parts
    DC gets created without connectors.
    
    [How]
    Drop the dm_error print when no connectors.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d9c57984394b..aa11a176d673 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -151,10 +151,6 @@ static bool create_links(
 		return false;
 	}
 
-	if (connectors_num == 0 && num_virtual_links == 0) {
-		dm_error("DC: Number of connectors is zero!\n");
-	}
-
 	dm_output_to_console(
 		"DC: %s: connectors_num: physical:%d, virtual:%d\n",
 		__func__,

commit 0cf5eb76e2b453b3d159082eb4707c03a1686cf7
Author: David Francis <David.Francis@amd.com>
Date:   Fri Nov 30 09:57:06 2018 -0500

    drm/amd/display: Add tracing to dc
    
    [Why]
    Tracing is a useful and cheap debug functionality
    
    [How]
    This creates a new trace system amdgpu_dm, currently with
    three trace events
    
    amdgpu_dc_rreg and amdgpu_dc_wreg report the address and value
    of any dc register reads and writes
    
    amdgpu_dc_performance requires at least one of those two to be
    enabled.  It counts the register reads and writes since the
    last entry
    
    v2: Don't check for NULL before kfree
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8a182cb35c8f..d9c57984394b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -224,6 +224,17 @@ static bool create_links(
 	return false;
 }
 
+static struct dc_perf_trace *dc_perf_trace_create(void)
+{
+	return kzalloc(sizeof(struct dc_perf_trace), GFP_KERNEL);
+}
+
+static void dc_perf_trace_destroy(struct dc_perf_trace **perf_trace)
+{
+	kfree(*perf_trace);
+	*perf_trace = NULL;
+}
+
 /**
  *****************************************************************************
  *  Function: dc_stream_adjust_vmin_vmax
@@ -585,6 +596,8 @@ static void destruct(struct dc *dc)
 	if (dc->ctx->created_bios)
 		dal_bios_parser_destroy(&dc->ctx->dc_bios);
 
+	dc_perf_trace_destroy(&dc->ctx->perf_trace);
+
 	kfree(dc->ctx);
 	dc->ctx = NULL;
 
@@ -708,6 +721,12 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 
+	dc_ctx->perf_trace = dc_perf_trace_create();
+	if (!dc_ctx->perf_trace) {
+		ASSERT_CRITICAL(false);
+		goto fail;
+	}
+
 	/* Create GPIO service */
 	dc_ctx->gpio_service = dal_gpio_service_create(
 			dc_version,

commit 8ccb596fc574bae614aea9a532d8993e0f400f7e
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Wed Nov 7 14:59:41 2018 -0500

    drm/amd/display: Program dithering if requested
    
    Dithering needs to be enabled or disabled as requested. If
    dc_stream_update->dither_option is non-null, program the FMT blocks.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8edd0309255b..8a182cb35c8f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1463,6 +1463,14 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			if (stream_update->output_csc_transform)
 				dc_stream_program_csc_matrix(dc, stream);
 
+			if (stream_update->dither_option) {
+				resource_build_bit_depth_reduction_params(pipe_ctx->stream,
+									&pipe_ctx->stream->bit_depth_params);
+				pipe_ctx->stream_res.opp->funcs->opp_program_fmt(pipe_ctx->stream_res.opp,
+						&stream->bit_depth_params,
+						&stream->clamping);
+			}
+
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;

commit 2119aa17c963e59710617c70bb7b59e89c5ff447
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 9 09:45:28 2018 -0400

    drm/amd/display: Start documentation of DC
    
    [Why]
    There are a lot of unintuitive parts of the dm-dc interface.
    It would help us if these were documented to provide
    a common understanding of what they are supposed to do
    
    [How]
    Most of this documentation is stubs, to be filled out more
    thoroughly by the experts
    
    Not every dm-accessible function and struct is mentioned.
    Simple functions like getters, setters, retain, release,
    create, destroy can be left unadorned.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index dba6b57830c7..8edd0309255b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -62,6 +62,55 @@
 
 const static char DC_BUILD_ID[] = "production-build";
 
+/**
+ * DOC: Overview
+ *
+ * DC is the OS-agnostic component of the amdgpu DC driver.
+ *
+ * DC maintains and validates a set of structs representing the state of the
+ * driver and writes that state to AMD hardware
+ *
+ * Main DC HW structs:
+ *
+ * struct dc - The central struct.  One per driver.  Created on driver load,
+ * destroyed on driver unload.
+ *
+ * struct dc_context - One per driver.
+ * Used as a backpointer by most other structs in dc.
+ *
+ * struct dc_link - One per connector (the physical DP, HDMI, miniDP, or eDP
+ * plugpoints).  Created on driver load, destroyed on driver unload.
+ *
+ * struct dc_sink - One per display.  Created on boot or hotplug.
+ * Destroyed on shutdown or hotunplug.  A dc_link can have a local sink
+ * (the display directly attached).  It may also have one or more remote
+ * sinks (in the Multi-Stream Transport case)
+ *
+ * struct resource_pool - One per driver.  Represents the hw blocks not in the
+ * main pipeline.  Not directly accessible by dm.
+ *
+ * Main dc state structs:
+ *
+ * These structs can be created and destroyed as needed.  There is a full set of
+ * these structs in dc->current_state representing the currently programmed state.
+ *
+ * struct dc_state - The global DC state to track global state information,
+ * such as bandwidth values.
+ *
+ * struct dc_stream_state - Represents the hw configuration for the pipeline from
+ * a framebuffer to a display.  Maps one-to-one with dc_sink.
+ *
+ * struct dc_plane_state - Represents a framebuffer.  Each stream has at least one,
+ * and may have more in the Multi-Plane Overlay case.
+ *
+ * struct resource_context - Represents the programmable state of everything in
+ * the resource_pool.  Not directly accessible by dm.
+ *
+ * struct pipe_ctx - A member of struct resource_context.  Represents the
+ * internal hardware pipeline components.  Each dc_plane_state has either
+ * one or two (in the pipe-split case).
+ */
+
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
@@ -240,7 +289,7 @@ bool dc_stream_get_crtc_position(struct dc *dc,
 }
 
 /**
- * dc_stream_configure_crc: Configure CRC capture for the given stream.
+ * dc_stream_configure_crc() - Configure CRC capture for the given stream.
  * @dc: DC Object
  * @stream: The stream to configure CRC on.
  * @enable: Enable CRC if true, disable otherwise.
@@ -292,7 +341,7 @@ bool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,
 }
 
 /**
- * dc_stream_get_crc: Get CRC values for the given stream.
+ * dc_stream_get_crc() - Get CRC values for the given stream.
  * @dc: DC object
  * @stream: The DC stream state of the stream to get CRCs from.
  * @r_cr, g_y, b_cb: CRC values for the three channels are stored here.
@@ -1329,6 +1378,11 @@ static enum surface_update_type check_update_surfaces_for_stream(
 	return overall_type;
 }
 
+/**
+ * dc_check_update_surfaces_for_stream() - Determine update type (fast, med, or full)
+ *
+ * See :c:type:`enum surface_update_type <surface_update_type>` for explanation of update types
+ */
 enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc *dc,
 		struct dc_surface_update *updates,
@@ -1631,6 +1685,9 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 	return dal_irq_service_to_irq_source(dc->res_pool->irqs, src_id, ext_id);
 }
 
+/**
+ * dc_interrupt_set() - Enable/disable an AMD hw interrupt source
+ */
 bool dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
 {
 
@@ -1724,6 +1781,11 @@ static bool link_add_remote_sink_helper(struct dc_link *dc_link, struct dc_sink
 	return true;
 }
 
+/**
+ * dc_link_add_remote_sink() - Create a sink and attach it to an existing link
+ *
+ * EDID length is in bytes
+ */
 struct dc_sink *dc_link_add_remote_sink(
 		struct dc_link *link,
 		const uint8_t *edid,
@@ -1782,6 +1844,12 @@ struct dc_sink *dc_link_add_remote_sink(
 	return NULL;
 }
 
+/**
+ * dc_link_remove_remote_sink() - Remove a remote sink from a dc_link
+ *
+ * Note that this just removes the struct dc_sink - it doesn't
+ * program hardware or alter other members of dc_link
+ */
 void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 {
 	int i;

commit c1ee92f94ce3b9aa72524f861dea67882d02ad34
Author: David Francis <David.Francis@amd.com>
Date:   Mon Nov 26 15:51:09 2018 -0500

    drm/amd: Add abm level drm property
    
    Adaptive Backlight Management (ABM) is a feature
    that reduces backlight level to save power, while
    increasing pixel contrast and pixel luminance
    to maintain readability and image quality.
    
    ABM will adjust in response to the
    pixel luminance of the displayed content.
    
    ABM is made available as a drm property on eDP
    monitors called "abm level", which ranges from 0 to 4.
    When this property is set to 0, ABM is off.  Levels 1
    to 4 represent different ranges of backlight reduction.
    At higher levels both the backlight reduction and pixel
    adjustment will be greater.
    
    ABM requires DMCU firmware, which is currently available for
    Raven ASICs only.  If the feature does not work, please
    ensure your firmware is up to date.
    
    v2:
    Fix commit message, only attach property if DMCU loaded
    v3:
    Store ABM level in crtc state to accommodate dc
    v4:
    Fix ABM saving on dpms cycle
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1d8bd554869b..dba6b57830c7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1686,6 +1686,15 @@ void dc_resume(struct dc *dc)
 		core_link_resume(dc->links[i]);
 }
 
+bool dc_is_dmcu_initialized(struct dc *dc)
+{
+	struct dmcu *dmcu = dc->res_pool->dmcu;
+
+	if (dmcu)
+		return dmcu->funcs->is_dmcu_initialized(dmcu);
+	return false;
+}
+
 bool dc_submit_i2c(
 		struct dc *dc,
 		uint32_t link_index,
@@ -1810,4 +1819,4 @@ void get_clock_requirements_for_state(struct dc_state *state, struct AsicStateEx
 	info->dcfClockDeepSleep			= (unsigned int)state->bw.dcn.clk.dcfclk_deep_sleep_khz;
 	info->fClock					= (unsigned int)state->bw.dcn.clk.fclk_khz;
 	info->phyClock					= (unsigned int)state->bw.dcn.clk.phyclk_khz;
-}
\ No newline at end of file
+}

commit 37cd85ce3322706d9d357ffbe54481fa884af9e5
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 16 14:21:32 2018 -0400

    drm/amd/display: Remove dc_stream_state->status
    
    [Why]
    dc_state has an array of dc_stream_status that contain
    pointers to the dc_plane_state and other useful information
    
    Confusingly, dc_stream_state also contains a dc_stream_status
    called status.  This struct was partially initialized and
    used in a few places
    
    [How]
    stream->status.link has been replaced with stream->sink->link.
    If a stream does not have a sink, or a sink does not have a link,
    something has gone seriously wrong
    
    All other properties of stream->status were zeroed by kzalloc
    and never initialized, so they have been replaced by the number 0
    
    This is a refactor: no functional change is intended
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3279e26c3440..1d8bd554869b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -328,7 +328,7 @@ void dc_stream_set_dither_option(struct dc_stream_state *stream,
 		enum dc_dither_option option)
 {
 	struct bit_depth_reduction_params params;
-	struct dc_link *link = stream->status.link;
+	struct dc_link *link = stream->sink->link;
 	struct pipe_ctx *pipes = NULL;
 	int i;
 

commit 3917a470757cf55155663240481b1dda0206717b
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Oct 12 17:31:58 2018 -0400

    drm/amd/display: Remove program_csc_matrix
    
    [Why] On DCN1/DCE, There are two functions programming OCSC:
    program_csc_matrix and program_output_csc. They do the same thing.
    
    [How] Consolidate to use only program_output_csc.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 503bb166a81c..3279e26c3440 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -391,9 +391,11 @@ bool dc_stream_program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 				== stream) {
 
 			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
-			dc->hwss.program_csc_matrix(pipes,
-			stream->output_color_space,
-			stream->csc_color_matrix.matrix);
+			dc->hwss.program_output_csc(dc,
+					pipes,
+					stream->output_color_space,
+					stream->csc_color_matrix.matrix,
+					pipes->plane_res.hubp->opp_id);
 			ret = true;
 		}
 	}

commit 06308d024ad56e36f86aeccb271c7591cc098f7f
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Tue Oct 2 11:50:49 2018 -0400

    drm/amd/display: Remove stream_res tg null check in commit planes
    
    [Why]
    TG in pipe_ctx stream resource is not null where used in
    commit_planes_do_stream_update since it is assigned the
    same time the stream is set in pipe_ctx - when the pipe is
    acquired. This null check produced a static code analysis
    warning and should be removed to avoid similar unnecessary
    checks in the future.
    
    [How]
    Remove the null check.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a8d8358058ff..503bb166a81c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1389,7 +1389,6 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					stream_update->adjust->v_total_max);
 
 			if (stream_update->periodic_fn_vsync_delta &&
-					pipe_ctx->stream_res.tg &&
 					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
 				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
 					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,

commit e2bf20073e4d32c78d4007b8aecb4a61b8418797
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Sep 26 15:52:19 2018 -0400

    drm/amd/display: fix report display count logic
    
    [Why]
    Previous logic to update display count in commit_planes_do_stream_update
    doesn't cover all cases.
    
    [How]
    Update display count as part of clock updates. Count virtual stream
    as active to work around headless situation.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 20dd062d7a33..a8d8358058ff 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1365,35 +1365,6 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-static void notify_display_count_to_smu(
-		struct dc *dc,
-		struct dc_state *context)
-{
-	int i, display_count;
-	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
-
-	/*
-	 * if function pointer not set up, this message is
-	 * sent as part of pplib_apply_display_requirements.
-	 * So just return.
-	 */
-	if (!pp_smu || !pp_smu->set_display_count)
-		return;
-
-	display_count = 0;
-	for (i = 0; i < context->stream_count; i++) {
-		const struct dc_stream_state *stream = context->streams[i];
-
-		/* only notify active stream */
-		if (stream->dpms_off)
-			continue;
-
-		display_count++;
-	}
-
-	pp_smu->set_display_count(&pp_smu->pp_smu, display_count);
-}
-
 static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update,
@@ -1444,15 +1415,13 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			if (stream_update->dpms_off) {
 				if (*stream_update->dpms_off) {
 					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
-					notify_display_count_to_smu(dc, dc->current_state);
+					dc->hwss.optimize_bandwidth(dc, dc->current_state);
 				} else {
-					notify_display_count_to_smu(dc, dc->current_state);
+					dc->hwss.prepare_bandwidth(dc, dc->current_state);
 					core_link_enable_stream(dc->current_state, pipe_ctx);
 				}
 			}
 
-
-
 			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
 				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
 					// if otg funcs defined check if blanked before programming

commit 9566b67586fb1d96c36207fd975087d68296755c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Sep 18 15:00:49 2018 -0400

    drm/amd/display: remove safe_to_lower flag from dc, use 2 functions instead
    
    This is done to keep things more readable, avoids a true/false flag
    in dc interface layer.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2bbc39de10cc..20dd062d7a33 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -941,7 +941,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc, context);
 
-	dc->hwss.set_bandwidth(dc, context, false);
+	dc->hwss.prepare_bandwidth(dc, context);
 
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use
@@ -1010,7 +1010,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
 	/* pplib is notified if disp_num changed */
-	dc->hwss.set_bandwidth(dc, context, true);
+	dc->hwss.optimize_bandwidth(dc, context);
 
 	dc_release_state(dc->current_state);
 
@@ -1059,7 +1059,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	dc->optimized_required = false;
 
-	dc->hwss.set_bandwidth(dc, context, true);
+	dc->hwss.optimize_bandwidth(dc, context);
 	return true;
 }
 
@@ -1479,7 +1479,7 @@ static void commit_planes_for_stream(struct dc *dc,
 	struct pipe_ctx *top_pipe_to_program = NULL;
 
 	if (update_type == UPDATE_TYPE_FULL) {
-		dc->hwss.set_bandwidth(dc, context, false);
+		dc->hwss.prepare_bandwidth(dc, context);
 		context_clock_trace(dc, context);
 	}
 

commit 24f7dd7ea98dc54fa45a0dd10c7a472e00ca01d4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Sep 13 17:42:14 2018 -0400

    drm/amd/display: move pplib/smu notification to dccg block
    
    This is done to clear up the clock programming sequence
    since the only time we need to notify pplib is after
    clock update.
    
    This also renames the clk block to dccg, at the moment
    this block contains both clock management and dccg
    functionality.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7c491c91465f..2bbc39de10cc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -957,8 +957,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	}
 
 	/* Program hardware */
-	dc->hwss.ready_shared_resources(dc, context);
-
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		pipe = &context->res_ctx.pipe_ctx[i];
 		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
@@ -1020,8 +1018,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_retain_state(dc->current_state);
 
-	dc->hwss.optimize_shared_resources(dc);
-
 	return result;
 }
 
@@ -1448,12 +1444,8 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			if (stream_update->dpms_off) {
 				if (*stream_update->dpms_off) {
 					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
-					dc->hwss.pplib_apply_display_requirements(
-						dc, dc->current_state);
 					notify_display_count_to_smu(dc, dc->current_state);
 				} else {
-					dc->hwss.pplib_apply_display_requirements(
-						dc, dc->current_state);
 					notify_display_count_to_smu(dc, dc->current_state);
 					core_link_enable_stream(dc->current_state, pipe_ctx);
 				}

commit 8ab2180f96f5334974a84f54e794b3bc5912f4d1
Author: Eryk Brol <eryk.brol@amd.com>
Date:   Fri Sep 7 13:24:28 2018 -0400

    drm/amd/display: Add function to fetch clock requirements
    
    Also add dram clock to clocks struct, for systems that uses them.
    
    Signed-off-by: Eryk Brol <eryk.brol@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a0e933f2a06c..7c491c91465f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1836,3 +1836,16 @@ void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 		}
 	}
 }
+
+void get_clock_requirements_for_state(struct dc_state *state, struct AsicStateEx *info)
+{
+	info->displayClock				= (unsigned int)state->bw.dcn.clk.dispclk_khz;
+	info->engineClock				= (unsigned int)state->bw.dcn.clk.dcfclk_khz;
+	info->memoryClock				= (unsigned int)state->bw.dcn.clk.dramclk_khz;
+	info->maxSupportedDppClock		= (unsigned int)state->bw.dcn.clk.max_supported_dppclk_khz;
+	info->dppClock					= (unsigned int)state->bw.dcn.clk.dppclk_khz;
+	info->socClock					= (unsigned int)state->bw.dcn.clk.socclk_khz;
+	info->dcfClockDeepSleep			= (unsigned int)state->bw.dcn.clk.dcfclk_deep_sleep_khz;
+	info->fClock					= (unsigned int)state->bw.dcn.clk.fclk_khz;
+	info->phyClock					= (unsigned int)state->bw.dcn.clk.phyclk_khz;
+}
\ No newline at end of file

commit 74eac5f3b43eda8b518662b011d1f18d5560e144
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu Sep 13 15:26:08 2018 -0400

    drm/amd/display: Calculate swizzle mode using bpp during validation
    
    [Why]
    Previously bandwidth validation was failing because swizzle mode was not
    initialized during plane_state allocation. The swizzle mode was
    calculated using pixed format which is how swizzle mode is initially
    calculated in addrlib.
    
    [How]
    * Set default swizzle mode for validation to DC_SW_UNKNOWN
    * Created new function in dcn10_assign_swizzle_mode which sets the
      plane swizzle mode based on selected pixed format
    * Added the call of assign_swizzle_mode into dc_validate_global_state
    * Set failsafe swizzle mode back to DC_SW_LINEAR
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 99ecaeb4bdd8..a0e933f2a06c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1113,32 +1113,6 @@ static bool is_surface_in_context(
 	return false;
 }
 
-static unsigned int pixel_format_to_bpp(enum surface_pixel_format format)
-{
-	switch (format) {
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
-		return 12;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
-	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
-	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
-		return 16;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
-		return 32;
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
-	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
-	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
-		return 64;
-	default:
-		ASSERT_CRITICAL(false);
-		return -1;
-	}
-}
-
 static enum surface_update_type get_plane_info_update_type(const struct dc_surface_update *u)
 {
 	union surface_update_flags *update_flags = &u->surface->update_flags;
@@ -1172,8 +1146,8 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch)
 		update_flags->bits.dcc_change = 1;
 
-	if (pixel_format_to_bpp(u->plane_info->format) !=
-			pixel_format_to_bpp(u->surface->format))
+	if (resource_pixel_format_to_bpp(u->plane_info->format) !=
+			resource_pixel_format_to_bpp(u->surface->format))
 		/* different bytes per element will require full bandwidth
 		 * and DML calculation
 		 */

commit be61df574256ae8c0dbd45ac148ca7260a0483c0
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Thu Sep 13 09:32:26 2018 -0400

    drm/amd/display: Add DC build_id to determine build type
    
    [why]
    Sometimes there are indications that the incorrect driver is being
    loaded in automated tests. This change adds the ability for builds to
    be tagged with a string, and picked up by the test infrastructure.
    
    [how]
    dc.c will allocate const for build id, which is init-ed with default
    value, indicating production build. For test builds, build server will
    find/replace this value. The test machine will then verify this value.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 76fe5a9af3bf..99ecaeb4bdd8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -60,6 +60,7 @@
 #define DC_LOGGER \
 	dc->ctx->logger
 
+const static char DC_BUILD_ID[] = "production-build";
 
 /*******************************************************************************
  * Private functions
@@ -758,6 +759,8 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 	dc->config = init_params->flags;
 
+	dc->build_id = DC_BUILD_ID;
+
 	DC_LOG_DC("Display Core initialized\n");
 
 

commit 30049754ab7c4b6148dd3cd64af7d54850604582
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Wed Sep 12 14:15:42 2018 -0400

    drm/amd/display: fix gamma not being applied
    
    [WHY]
    Previously night light forced a full update by
    applying a  transfer function update regardless of if it was changed.
    This logic was removed,
    
    Now gamma surface updates are only applied when there is also a plane
    info update, this does not work in cases such as using the night light
    slider.
    
    [HOW]
    When moving the night light slider we will perform a full update if
    the gamma has changed and there is a surface, even when the surface
    has not changed. Also get stream updates in setgamma prior to
    update planes and stream.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 61bb3d52641c..76fe5a9af3bf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1176,9 +1176,6 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 		 */
 		update_flags->bits.bpp_change = 1;
 
-	if (u->gamma && dce_use_lut(u->plane_info->format))
-		update_flags->bits.gamma_change = 1;
-
 	if (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,
 			sizeof(union dc_tiling_info)) != 0) {
 		update_flags->bits.swizzle_change = 1;
@@ -1195,7 +1192,6 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (update_flags->bits.rotation_change
 			|| update_flags->bits.stereo_format_change
 			|| update_flags->bits.pixel_format_change
-			|| update_flags->bits.gamma_change
 			|| update_flags->bits.bpp_change
 			|| update_flags->bits.bandwidth_change
 			|| update_flags->bits.output_tf_change)
@@ -1285,13 +1281,26 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	if (u->coeff_reduction_factor)
 		update_flags->bits.coeff_reduction_change = 1;
 
+	if (u->gamma) {
+		enum surface_pixel_format format = SURFACE_PIXEL_FORMAT_GRPH_BEGIN;
+
+		if (u->plane_info)
+			format = u->plane_info->format;
+		else if (u->surface)
+			format = u->surface->format;
+
+		if (dce_use_lut(format))
+			update_flags->bits.gamma_change = 1;
+	}
+
 	if (update_flags->bits.in_transfer_func_change) {
 		type = UPDATE_TYPE_MED;
 		elevate_update_type(&overall_type, type);
 	}
 
 	if (update_flags->bits.input_csc_change
-			|| update_flags->bits.coeff_reduction_change) {
+			|| update_flags->bits.coeff_reduction_change
+			|| update_flags->bits.gamma_change) {
 		type = UPDATE_TYPE_FULL;
 		elevate_update_type(&overall_type, type);
 	}

commit 5aa9935b6531dfe6ebdc1cacbc8d8a736620345f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Sep 7 13:31:34 2018 -0400

    drm/amd/display: add pp_smu NULL pointer check
    
    add pp_smu NULL ptr check
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7d9be87140cc..61bb3d52641c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1395,7 +1395,7 @@ static void notify_display_count_to_smu(
 	 * sent as part of pplib_apply_display_requirements.
 	 * So just return.
 	 */
-	if (!pp_smu->set_display_count)
+	if (!pp_smu || !pp_smu->set_display_count)
 		return;
 
 	display_count = 0;

commit a978f65765e2ccefb22eb77940685ae60c05ff6c
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Fri Sep 7 10:13:55 2018 -0400

    drm/amd/display: use proper pipe_ctx index
    
    Use link->link_index as index to pipe_ctx[] to get proper link
    information instead of using index 0 to avoid potential miss matches.
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1c438eedf77a..7d9be87140cc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -460,9 +460,25 @@ void dc_link_set_preferred_link_settings(struct dc *dc,
 					 struct dc_link_settings *link_setting,
 					 struct dc_link *link)
 {
+	int i;
+	struct pipe_ctx *pipe;
+	struct dc_stream_state *link_stream;
 	struct dc_link_settings store_settings = *link_setting;
-	struct dc_stream_state *link_stream =
-		link->dc->current_state->res_ctx.pipe_ctx[0].stream;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe->stream && pipe->stream->sink
+			&& pipe->stream->sink->link) {
+			if (pipe->stream->sink->link == link)
+				break;
+		}
+	}
+
+	/* Stream not found */
+	if (i == MAX_PIPES)
+		return;
+
+	link_stream = link->dc->current_state->res_ctx.pipe_ctx[i].stream;
 
 	link->preferred_link_setting = store_settings;
 	if (link_stream)

commit ad908423ef86f1787b635a8830d49f50ff862295
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Aug 15 17:35:50 2018 -0400

    drm/amd/display: support 48 MHZ refclk off
    
    [Why]
    On PCO and up, whenever SMU receive message to indicate active
    display count = 0. SMU will turn off 48MHZ TMDP reference clock
    by writing to 1 TMDP_48M_Refclk_Driver_PWDN. Once this clock is
    off, no PHY register will respond to register access. This means
    our current sequence of notifying display count along with requesting
    clock will cause driver to hang when accessing PHY registers after
    displays count goes to 0.
    
    [How]
    Separate the PPSMC_MSG_SetDisplayCount message from the SMU messages
    that request clocks, have display own sequencing of this message so
    that we can send it at the appropriate time.
    Do not redundantly power off HW when entering S3, S4, since display
    should already be called to disable all streams. And ASIC soon be
    powered down.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 32318b4e0d1e..1c438eedf77a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1367,6 +1367,34 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
+static void notify_display_count_to_smu(
+		struct dc *dc,
+		struct dc_state *context)
+{
+	int i, display_count;
+	struct pp_smu_funcs_rv *pp_smu = dc->res_pool->pp_smu;
+
+	/*
+	 * if function pointer not set up, this message is
+	 * sent as part of pplib_apply_display_requirements.
+	 * So just return.
+	 */
+	if (!pp_smu->set_display_count)
+		return;
+
+	display_count = 0;
+	for (i = 0; i < context->stream_count; i++) {
+		const struct dc_stream_state *stream = context->streams[i];
+
+		/* only notify active stream */
+		if (stream->dpms_off)
+			continue;
+
+		display_count++;
+	}
+
+	pp_smu->set_display_count(&pp_smu->pp_smu, display_count);
+}
 
 static void commit_planes_do_stream_update(struct dc *dc,
 		struct dc_stream_state *stream,
@@ -1420,13 +1448,17 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
 					dc->hwss.pplib_apply_display_requirements(
 						dc, dc->current_state);
+					notify_display_count_to_smu(dc, dc->current_state);
 				} else {
 					dc->hwss.pplib_apply_display_requirements(
 						dc, dc->current_state);
+					notify_display_count_to_smu(dc, dc->current_state);
 					core_link_enable_stream(dc->current_state, pipe_ctx);
 				}
 			}
 
+
+
 			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
 				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
 					// if otg funcs defined check if blanked before programming
@@ -1662,9 +1694,7 @@ void dc_set_power_state(
 		dc->hwss.init_hw(dc);
 		break;
 	default:
-
-		dc->hwss.power_down(dc);
-
+		ASSERT(dc->current_state->stream_count == 0);
 		/* Zero out the current context so that on resume we start with
 		 * clean state, and dc hw programming optimizations will not
 		 * cause any trouble.

commit eb385204b2416f88aea6e1d1cfbbf5b8dbddcaa5
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Jul 26 14:58:35 2018 -0400

    drm/amd/display: Program csc matrix as part of stream update
    
    Add csc_transform struct to dc_stream_update, and program if set when
    updating streams
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 99450293a1c5..32318b4e0d1e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -379,6 +379,27 @@ bool dc_stream_set_gamut_remap(struct dc *dc, const struct dc_stream_state *stre
 	return ret;
 }
 
+bool dc_stream_program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
+{
+	int i = 0;
+	bool ret = false;
+	struct pipe_ctx *pipes;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (dc->current_state->res_ctx.pipe_ctx[i].stream
+				== stream) {
+
+			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
+			dc->hwss.program_csc_matrix(pipes,
+			stream->output_color_space,
+			stream->csc_color_matrix.matrix);
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
 void dc_stream_set_static_screen_events(struct dc *dc,
 		struct dc_stream_state **streams,
 		int num_streams,
@@ -1387,6 +1408,9 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			if (stream_update->gamut_remap)
 				dc_stream_set_gamut_remap(dc, stream);
 
+			if (stream_update->output_csc_transform)
+				dc_stream_program_csc_matrix(dc, stream);
+
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;

commit c85e6e546edd7e362693218a33a6f63217802fd3
Author: David Francis <David.Francis@amd.com>
Date:   Mon Jul 23 14:12:10 2018 -0400

    drm/amd/display: Create new i2c resource
    
    [Why]
    I2C code did not match dc resource model and was generally
    unpleasant
    
    [How]
    Move code into new svelte dce_i2c files, replacing various i2c
    objects with two structs: dce_i2c_sw and dce_i2c_hw.  Fully split
    sw and hw code paths.  Remove all redundant declarations.  Use
    address lists to distinguish between versions.  Change dce80 code
    to newer register access macros.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b906b6adc5a8..99450293a1c5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -54,6 +54,9 @@
 #include "hubp.h"
 
 #include "dc_link_dp.h"
+
+#include "dce/dce_i2c.h"
+
 #define DC_LOGGER \
 	dc->ctx->logger
 
@@ -1673,9 +1676,8 @@ bool dc_submit_i2c(
 
 	struct dc_link *link = dc->links[link_index];
 	struct ddc_service *ddc = link->ddc;
-
-	return dal_i2caux_submit_i2c_command(
-		ddc->ctx->i2caux,
+	return dce_i2c_submit_command(
+		dc->res_pool,
 		ddc->ddc_pin,
 		cmd);
 }

commit 8ab5617279507044682248f47c3afa9f753d8fe3
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Jul 26 14:58:35 2018 -0400

    drm/amd/display: Program gamut remap as part of stream update
    
    Add gamut remap to dc_stream_update struct, and program if set when updating
    streams.
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b5c7be1cdd81..b906b6adc5a8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -359,6 +359,23 @@ void dc_stream_set_dither_option(struct dc_stream_state *stream,
 		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }
 
+bool dc_stream_set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
+{
+	int i = 0;
+	bool ret = false;
+	struct pipe_ctx *pipes;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {
+			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
+			dc->hwss.program_gamut_remap(pipes);
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
 void dc_stream_set_static_screen_events(struct dc *dc,
 		struct dc_stream_state **streams,
 		int num_streams,
@@ -1364,6 +1381,9 @@ static void commit_planes_do_stream_update(struct dc *dc,
 				dc->hwss.update_info_frame(pipe_ctx);
 			}
 
+			if (stream_update->gamut_remap)
+				dc_stream_set_gamut_remap(dc, stream);
+
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;

commit 72ac71a7e65260cc9a5f5e7dde5d14892d867c98
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Jul 20 15:44:08 2018 -0400

    drm/amd/display: HDR dynamic meta should be treated as stream update
    
    [Why]
    Recently we fixed HDR static meta using AFMT registers to be treated as
    fast stream update.
    Dynamic meta is still being treated as (full) surface update because it
    touches HUBP and it travels with pipe data.
    Here we change it to be (fast) stream update.
    Note, originally we also wanted to redesign here a bit, but without OS
    level support for true dynamic meta, it's left the same. We are simply
    using HW that can do dynamic meta to send HDR static meta, I still prefer
    keeping it in one static meta type then defining dynamic meta types to
    hold the same info. Once we know how OS interfaces look like, we can
    do proper design.
    
    [How]
    Move dyn meta update from update_hubp_dpp to commit_planes_do_stream_update
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9a947f8341bf..b5c7be1cdd81 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1357,7 +1357,7 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
 					pipe_ctx->stream->periodic_fn_vsync_delta);
 
-			if (stream_update->hdr_static_metadata ||
+			if ((stream_update->hdr_static_metadata && !stream->use_dynamic_meta) ||
 					stream_update->vrr_infopacket ||
 					stream_update->vsc_infopacket) {
 				resource_build_info_frame(pipe_ctx);

commit e71f8ca1a7db244642f9f882f1df003fa567ad43
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Thu Jul 5 19:23:17 2018 -0400

    drm/amd/display: Handle HDR meta update as fast update
    
    [Why]
    Vesa DPMS tool sends different HDR meta in OS flips without changing output
    parameters. We don't properly update HDR info frame:
    - we label HDR meta update as fast update
    - when updating HW info frame, we only do it if full update
    
    [How]
    It should still be fast update, so when doing HW infoframe update,
    do it always no matter the update type.
    Also, don't request passive flip for HDR meta update only without output
    transfer function or color space changed.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index eda21868c892..9a947f8341bf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1357,6 +1357,13 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
 					pipe_ctx->stream->periodic_fn_vsync_delta);
 
+			if (stream_update->hdr_static_metadata ||
+					stream_update->vrr_infopacket ||
+					stream_update->vsc_infopacket) {
+				resource_build_info_frame(pipe_ctx);
+				dc->hwss.update_info_frame(pipe_ctx);
+			}
+
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
@@ -1383,13 +1390,6 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					pipe_ctx->stream_res.abm->funcs->set_abm_level(
 						pipe_ctx->stream_res.abm, stream->abm_level);
 			}
-
-			if (stream_update->hdr_static_metadata ||
-				stream_update->vrr_infopacket ||
-				stream_update->vsc_infopacket) {
-				resource_build_info_frame(pipe_ctx);
-				dc->hwss.update_info_frame(pipe_ctx);
-			}
 		}
 	}
 }

commit 0e4af5f3675bd766dbf11e5f17428ea69b630035
Author: Alvin lee <alvin.lee3@amd.com>
Date:   Fri Jun 8 13:58:36 2018 -0400

    drm/amd/display: Program vsc_infopacket in commit_planes_for_stream
    
    Signed-off-by: Alvin lee <alvin.lee3@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 699cb6f51121..eda21868c892 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1385,7 +1385,8 @@ static void commit_planes_do_stream_update(struct dc *dc,
 			}
 
 			if (stream_update->hdr_static_metadata ||
-				stream_update->vrr_infopacket) {
+				stream_update->vrr_infopacket ||
+				stream_update->vsc_infopacket) {
 				resource_build_info_frame(pipe_ctx);
 				dc->hwss.update_info_frame(pipe_ctx);
 			}

commit 27e2e207747981ca3161dec16cea304f8e46cd65
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Fri May 18 17:05:52 2018 -0400

    drm/amd/display: Program vline interrupt on FAST update
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2d4a5a85f799..699cb6f51121 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1350,6 +1350,13 @@ static void commit_planes_do_stream_update(struct dc *dc,
 					stream_update->adjust->v_total_min,
 					stream_update->adjust->v_total_max);
 
+			if (stream_update->periodic_fn_vsync_delta &&
+					pipe_ctx->stream_res.tg &&
+					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
+					pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
+					pipe_ctx->stream->periodic_fn_vsync_delta);
+
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
@@ -1377,12 +1384,6 @@ static void commit_planes_do_stream_update(struct dc *dc,
 						pipe_ctx->stream_res.abm, stream->abm_level);
 			}
 
-			if (stream_update->periodic_fn_vsync_delta &&
-				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
-					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-						pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
-						pipe_ctx->stream->periodic_fn_vsync_delta);
-
 			if (stream_update->hdr_static_metadata ||
 				stream_update->vrr_infopacket) {
 				resource_build_info_frame(pipe_ctx);

commit 1e7e86c43f38d2cc0183ae2a440c70f3c6163883
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Tue May 1 10:39:26 2018 -0400

    drm/amd/display: decouple front and backend pgm using dpms_off as backend enable flag
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0179d2be9866..2d4a5a85f799 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1270,6 +1270,9 @@ static enum surface_update_type check_update_surfaces_for_stream(
 
 		if (stream_update->abm_level)
 			return UPDATE_TYPE_FULL;
+
+		if (stream_update->dpms_off)
+			return UPDATE_TYPE_FULL;
 	}
 
 	for (i = 0 ; i < surface_count; i++) {
@@ -1324,6 +1327,71 @@ static struct dc_stream_status *stream_get_status(
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 
+static void commit_planes_do_stream_update(struct dc *dc,
+		struct dc_stream_state *stream,
+		struct dc_stream_update *stream_update,
+		enum surface_update_type update_type,
+		struct dc_state *context)
+{
+	int j;
+
+	// Stream updates
+	for (j = 0; j < dc->res_pool->pipe_count; j++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+		if (!pipe_ctx->top_pipe &&
+			pipe_ctx->stream &&
+			pipe_ctx->stream == stream) {
+
+			/* Fast update*/
+			// VRR program can be done as part of FAST UPDATE
+			if (stream_update->adjust)
+				dc->hwss.set_drr(&pipe_ctx, 1,
+					stream_update->adjust->v_total_min,
+					stream_update->adjust->v_total_max);
+
+			/* Full fe update*/
+			if (update_type == UPDATE_TYPE_FAST)
+				continue;
+
+			if (stream_update->dpms_off) {
+				if (*stream_update->dpms_off) {
+					core_link_disable_stream(pipe_ctx, KEEP_ACQUIRED_RESOURCE);
+					dc->hwss.pplib_apply_display_requirements(
+						dc, dc->current_state);
+				} else {
+					dc->hwss.pplib_apply_display_requirements(
+						dc, dc->current_state);
+					core_link_enable_stream(dc->current_state, pipe_ctx);
+				}
+			}
+
+			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
+				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
+					// if otg funcs defined check if blanked before programming
+					if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))
+						pipe_ctx->stream_res.abm->funcs->set_abm_level(
+							pipe_ctx->stream_res.abm, stream->abm_level);
+				} else
+					pipe_ctx->stream_res.abm->funcs->set_abm_level(
+						pipe_ctx->stream_res.abm, stream->abm_level);
+			}
+
+			if (stream_update->periodic_fn_vsync_delta &&
+				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
+						pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
+						pipe_ctx->stream->periodic_fn_vsync_delta);
+
+			if (stream_update->hdr_static_metadata ||
+				stream_update->vrr_infopacket) {
+				resource_build_info_frame(pipe_ctx);
+				dc->hwss.update_info_frame(pipe_ctx);
+			}
+		}
+	}
+}
+
 static void commit_planes_for_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates,
 		int surface_count,
@@ -1340,15 +1408,20 @@ static void commit_planes_for_stream(struct dc *dc,
 		context_clock_trace(dc, context);
 	}
 
+	// Stream updates
+	if (stream_update)
+		commit_planes_do_stream_update(dc, stream, stream_update, update_type, context);
+
 	if (surface_count == 0) {
 		/*
 		 * In case of turning off screen, no need to program front end a second time.
-		 * just return after program front end.
+		 * just return after program blank.
 		 */
-		dc->hwss.apply_ctx_for_surface(dc, stream, surface_count, context);
+		dc->hwss.apply_ctx_for_surface(dc, stream, 0, context);
 		return;
 	}
 
+	// Update Type FULL, Surface updates
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
@@ -1362,13 +1435,6 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (!pipe_ctx->plane_state)
 				continue;
 
-			/* Fast update*/
-			// VRR program can be done as part of FAST UPDATE
-			if (stream_update && stream_update->adjust)
-				dc->hwss.set_drr(&pipe_ctx, 1,
-					stream_update->adjust->v_total_min,
-					stream_update->adjust->v_total_max);
-
 			/* Full fe update*/
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
@@ -1378,34 +1444,18 @@ static void commit_planes_for_stream(struct dc *dc,
 
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
-
-			if (stream_update && stream_update->abm_level && pipe_ctx->stream_res.abm) {
-				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
-					// if otg funcs defined check if blanked before programming
-					if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))
-						pipe_ctx->stream_res.abm->funcs->set_abm_level(
-								pipe_ctx->stream_res.abm, stream->abm_level);
-				} else
-					pipe_ctx->stream_res.abm->funcs->set_abm_level(
-							pipe_ctx->stream_res.abm, stream->abm_level);
-			}
-
-			if (stream_update && stream_update->periodic_fn_vsync_delta &&
-					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
-				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
-						pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
-						pipe_ctx->stream->periodic_fn_vsync_delta);
 		}
 	}
 
 	if (update_type == UPDATE_TYPE_FULL)
 		context_timing_trace(dc, &context->res_ctx);
 
-	/* Lock the top pipe while updating plane addrs, since freesync requires
-	 *  plane addr update event triggers to be synchronized.
-	 *  top_pipe_to_program is expected to never be NULL
-	 */
+	// Update Type FAST, Surface updates
 	if (update_type == UPDATE_TYPE_FAST) {
+		/* Lock the top pipe while updating plane addrs, since freesync requires
+		 *  plane addr update event triggers to be synchronized.
+		 *  top_pipe_to_program is expected to never be NULL
+		 */
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);
 
 		/* Perform requested Updates */
@@ -1428,21 +1478,6 @@ static void commit_planes_for_stream(struct dc *dc,
 
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 	}
-
-	if (stream && stream_update)
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx =
-					&context->res_ctx.pipe_ctx[j];
-
-			if (pipe_ctx->stream != stream)
-				continue;
-
-			if (stream_update->hdr_static_metadata ||
-				(stream_update->vrr_infopacket)) {
-				resource_build_info_frame(pipe_ctx);
-				dc->hwss.update_info_frame(pipe_ctx);
-			}
-		}
 }
 
 void dc_commit_updates_for_stream(struct dc *dc,

commit 4c1fa3630b44f03d5539a778ddcea319e9c8223a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Mar 25 16:28:33 2018 -0400

    drm/amd/display: Don't force UPDATE_TYPE_FULL if stream_update has hdr_static_metadata
    
    This was missed when pushing public patch for 3e3a40b03847 (drm/amd/display:
    Updated HDR Static Metadata to directly take info packet raw)
    
    This is currently no problem yet since we're not doing HDR on Linux yet.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a4df627d6936..0179d2be9866 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1268,9 +1268,6 @@ static enum surface_update_type check_update_surfaces_for_stream(
 		if (stream_update->out_transfer_func)
 			return UPDATE_TYPE_FULL;
 
-		if (stream_update->hdr_static_metadata)
-			return UPDATE_TYPE_FULL;
-
 		if (stream_update->abm_level)
 			return UPDATE_TYPE_FULL;
 	}

commit 98e6436d3af5fef7ca9b59d865dd5807ede36fb9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:40:28 2018 -0500

    drm/amd/display: Refactor FreeSync module
    
    Remove dependency on internal sink map and instead
    use existing stream and plane state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 71742635e797..a4df627d6936 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -188,11 +188,9 @@ static bool create_links(
  *****************************************************************************
  */
 bool dc_stream_adjust_vmin_vmax(struct dc *dc,
-		struct dc_stream_state **streams, int num_streams,
-		int vmin, int vmax)
+		struct dc_stream_state *stream,
+		struct dc_crtc_timing_adjust *adjust)
 {
-	/* TODO: Support multiple streams */
-	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
@@ -200,11 +198,11 @@ bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 		struct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
-			dc->hwss.set_drr(&pipe, 1, vmin, vmax);
-
-			/* build and update the info frame */
-			resource_build_info_frame(pipe);
-			dc->hwss.update_info_frame(pipe);
+			pipe->stream->adjust = *adjust;
+			dc->hwss.set_drr(&pipe,
+					1,
+					adjust->v_total_min,
+					adjust->v_total_max);
 
 			ret = true;
 		}
@@ -217,7 +215,7 @@ bool dc_stream_get_crtc_position(struct dc *dc,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
-	struct dc_stream_state *stream = streams[0];
+	const struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 	struct crtc_position position;
@@ -1257,8 +1255,25 @@ static enum surface_update_type check_update_surfaces_for_stream(
 	if (stream_status == NULL || stream_status->plane_count != surface_count)
 		return UPDATE_TYPE_FULL;
 
-	if (stream_update)
-		return UPDATE_TYPE_FULL;
+	/* some stream updates require passive update */
+	if (stream_update) {
+		if ((stream_update->src.height != 0) &&
+				(stream_update->src.width != 0))
+			return UPDATE_TYPE_FULL;
+
+		if ((stream_update->dst.height != 0) &&
+				(stream_update->dst.width != 0))
+			return UPDATE_TYPE_FULL;
+
+		if (stream_update->out_transfer_func)
+			return UPDATE_TYPE_FULL;
+
+		if (stream_update->hdr_static_metadata)
+			return UPDATE_TYPE_FULL;
+
+		if (stream_update->abm_level)
+			return UPDATE_TYPE_FULL;
+	}
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
@@ -1337,7 +1352,6 @@ static void commit_planes_for_stream(struct dc *dc,
 		return;
 	}
 
-	/* Full fe update*/
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
@@ -1348,11 +1362,22 @@ static void commit_planes_for_stream(struct dc *dc,
 
 			top_pipe_to_program = pipe_ctx;
 
-			if (update_type == UPDATE_TYPE_FAST || !pipe_ctx->plane_state)
+			if (!pipe_ctx->plane_state)
+				continue;
+
+			/* Fast update*/
+			// VRR program can be done as part of FAST UPDATE
+			if (stream_update && stream_update->adjust)
+				dc->hwss.set_drr(&pipe_ctx, 1,
+					stream_update->adjust->v_total_min,
+					stream_update->adjust->v_total_max);
+
+			/* Full fe update*/
+			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
 			stream_status =
-					stream_get_status(context, pipe_ctx->stream);
+				stream_get_status(context, pipe_ctx->stream);
 
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
@@ -1407,7 +1432,7 @@ static void commit_planes_for_stream(struct dc *dc,
 		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 	}
 
-	if (stream && stream_update && update_type > UPDATE_TYPE_FAST)
+	if (stream && stream_update)
 		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[j];
@@ -1415,7 +1440,8 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (pipe_ctx->stream != stream)
 				continue;
 
-			if (stream_update->hdr_static_metadata) {
+			if (stream_update->hdr_static_metadata ||
+				(stream_update->vrr_infopacket)) {
 				resource_build_info_frame(pipe_ctx);
 				dc->hwss.update_info_frame(pipe_ctx);
 			}

commit 94a4ffd1d40b845dd19f9fdbb2cb6bf32de0946b
Author: Gloria Li <geling.li@amd.com>
Date:   Thu Jul 26 11:32:14 2018 -0400

    drm/amd/display: fix PIP bugs on Dal3
    
    [Why]
    There are outstanding bugs for PIP in Dal3:
    -Crash when toggling PIP visibility
    -Global Alpha is not working, Adjusting global alpha
     doesn’t have an effect
    -Cursor is not working with pip plane and pipe splits
    -One flash occurs when cursor enters PIP plane from
     top/bottom
    -Crash when moving PIP plane off the screen
    
    [How]
    Resolve divide by 0 error
    Implement global alpha
    Program cursor on all pipes
    Add dst rects' x and y offests into cursor position
    Disable cursor when it is beyond bottom/top edge
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ebdf82044f73..71742635e797 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1106,6 +1106,9 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->per_pixel_alpha != u->surface->per_pixel_alpha)
 		update_flags->bits.per_pixel_alpha_change = 1;
 
+	if (u->plane_info->global_alpha_value != u->surface->global_alpha_value)
+		update_flags->bits.global_alpha_change = 1;
+
 	if (u->plane_info->dcc.enable != u->surface->dcc.enable
 			|| u->plane_info->dcc.grph.independent_64b_blks != u->surface->dcc.grph.independent_64b_blks
 			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch)

commit 1c8faa9aa0cc1ccf02bed608d23966b7347d71a6
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Jul 24 09:42:23 2018 -0400

    drm/amd/display: Enable DFS bypass support in DC config
    
    [Why]
    
    We explicitly disable DFS bypass support when creating DC. Support
    for this feature should now be in place so it can be left implicitly
    enabled.
    
    [How]
    
    Remove the line that disables DFS bypass support.
    
    Note: This option was actually reset to false anyway for most of
    the hardware I've tested on making this particular line misleading
    in the first place. This patch also fixes this issue.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6ae050dc3220..ebdf82044f73 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -706,8 +706,6 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	DC_LOG_DC("Display Core initialized\n");
 
 
-	/* TODO: missing feature to be enabled */
-	dc->debug.disable_dfs_bypass = true;
 
 	return dc;
 

commit dc37a9a08d5760e405ffdd94ec6bbb6efededba6
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Thu Aug 16 15:44:38 2018 -0400

    Revert "drm/amdgpu/display: Replace CONFIG_DRM_AMD_DC_DCN1_0 with CONFIG_X86"
    
    This reverts commit 8624c3c4dbfe24fc6740687236a2e196f5f4bfb0.
    
    We need CONFIG_DRM_AMD_DC_DCN1_0 to guard code that is using fp math.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d7076807b637..6ae050dc3220 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -487,7 +487,7 @@ static void destruct(struct dc *dc)
 	kfree(dc->bw_dceip);
 	dc->bw_dceip = NULL;
 
-#ifdef CONFIG_X86
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	kfree(dc->dcn_soc);
 	dc->dcn_soc = NULL;
 
@@ -503,7 +503,7 @@ static bool construct(struct dc *dc,
 	struct dc_context *dc_ctx;
 	struct bw_calcs_dceip *dc_dceip;
 	struct bw_calcs_vbios *dc_vbios;
-#ifdef CONFIG_X86
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	struct dcn_soc_bounding_box *dcn_soc;
 	struct dcn_ip_params *dcn_ip;
 #endif
@@ -525,7 +525,7 @@ static bool construct(struct dc *dc,
 	}
 
 	dc->bw_vbios = dc_vbios;
-#ifdef CONFIG_X86
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	dcn_soc = kzalloc(sizeof(*dcn_soc), GFP_KERNEL);
 	if (!dcn_soc) {
 		dm_error("%s: failed to create dcn_soc\n", __func__);

commit 8f7040b8f252fae4ca5d2453e9f50b78cf6b834f
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Mon Jul 30 12:22:35 2018 -0400

    drm/amd/display: Do not retain link settings
    
    Do not retrain link settings if lane count and link rate are both
    unknown.  Causes driver to be stuck reading VBIOS register after
    removing emulated connection.
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 733ac224e7fd..d7076807b637 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -52,6 +52,8 @@
 #include "dm_helpers.h"
 #include "mem_input.h"
 #include "hubp.h"
+
+#include "dc_link_dp.h"
 #define DC_LOGGER \
 	dc->ctx->logger
 
@@ -419,8 +421,17 @@ void dc_link_set_preferred_link_settings(struct dc *dc,
 					 struct dc_link_settings *link_setting,
 					 struct dc_link *link)
 {
-	link->preferred_link_setting = *link_setting;
-	dp_retrain_link_dp_test(link, link_setting, false);
+	struct dc_link_settings store_settings = *link_setting;
+	struct dc_stream_state *link_stream =
+		link->dc->current_state->res_ctx.pipe_ctx[0].stream;
+
+	link->preferred_link_setting = store_settings;
+	if (link_stream)
+		decide_link_settings(link_stream, &store_settings);
+
+	if ((store_settings.lane_count != LANE_COUNT_UNKNOWN) &&
+		(store_settings.link_rate != LINK_RATE_UNKNOWN))
+		dp_retrain_link_dp_test(link, &store_settings, false);
 }
 
 void dc_link_enable_hpd(const struct dc_link *link)

commit 4841203102a337b4b627e6dd3a1dc8c88aec982b
Author: Michel Dänzer <michel.daenzer@amd.com>
Date:   Tue Jul 17 12:37:45 2018 +0200

    drm/amdgpu/display: Replace CONFIG_DRM_AMD_DC_DCN1_0 with CONFIG_X86
    
    Allowing CONFIG_DRM_AMD_DC_DCN1_0 to be disabled on X86 was an
    opportunity for display with Raven Ridge accidentally not working.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index cb0be7f6994c..733ac224e7fd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -476,7 +476,7 @@ static void destruct(struct dc *dc)
 	kfree(dc->bw_dceip);
 	dc->bw_dceip = NULL;
 
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_X86
 	kfree(dc->dcn_soc);
 	dc->dcn_soc = NULL;
 
@@ -492,7 +492,7 @@ static bool construct(struct dc *dc,
 	struct dc_context *dc_ctx;
 	struct bw_calcs_dceip *dc_dceip;
 	struct bw_calcs_vbios *dc_vbios;
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_X86
 	struct dcn_soc_bounding_box *dcn_soc;
 	struct dcn_ip_params *dcn_ip;
 #endif
@@ -514,7 +514,7 @@ static bool construct(struct dc *dc,
 	}
 
 	dc->bw_vbios = dc_vbios;
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_X86
 	dcn_soc = kzalloc(sizeof(*dcn_soc), GFP_KERNEL);
 	if (!dcn_soc) {
 		dm_error("%s: failed to create dcn_soc\n", __func__);

commit e1cb3e4801e6896ba93d63222b1052199d2a8c9b
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Jun 19 09:58:24 2018 -0400

    drm/amd/display: Convert remaining loggers off dc_logger
    
    - Removed dal/dm/dc loggers from linux, switched to kernel prints
    - Modified functions that used these directly to use macros
    - dc_logger support is completely dropped from Linux
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 815656a5b6bd..cb0be7f6994c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -467,9 +467,6 @@ static void destruct(struct dc *dc)
 	if (dc->ctx->created_bios)
 		dal_bios_parser_destroy(&dc->ctx->dc_bios);
 
-	if (dc->ctx->logger)
-		dal_logger_destroy(&dc->ctx->logger);
-
 	kfree(dc->ctx);
 	dc->ctx = NULL;
 
@@ -492,7 +489,6 @@ static void destruct(struct dc *dc)
 static bool construct(struct dc *dc,
 		const struct dc_init_data *init_params)
 {
-	struct dal_logger *logger;
 	struct dc_context *dc_ctx;
 	struct bw_calcs_dceip *dc_dceip;
 	struct bw_calcs_vbios *dc_vbios;
@@ -557,14 +553,7 @@ static bool construct(struct dc *dc,
 	}
 
 	/* Create logger */
-	logger = dal_logger_create(dc_ctx, init_params->log_mask);
 
-	if (!logger) {
-		/* can *not* call logger. call base driver 'print error' */
-		dm_error("%s: failed to create Logger!\n", __func__);
-		goto fail;
-	}
-	dc_ctx->logger = logger;
 	dc_ctx->dce_environment = init_params->dce_environment;
 
 	dc_version = resource_parse_asic_id(init_params->asic_id);
@@ -983,9 +972,7 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	for (i = 0; i < context->stream_count; i++) {
 		struct dc_stream_state *stream = context->streams[i];
 
-		dc_stream_log(stream,
-				dc->ctx->logger,
-				LOG_DC);
+		dc_stream_log(dc, stream);
 	}
 
 	result = dc_commit_state_no_check(dc, context);

commit 40dd6bd376a4b8617d7cfb1402bafd84bbd79bbd
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Jun 15 09:28:34 2018 -0400

    drm/amd/display: Linux Set/Read link rate and lane count through debugfs
    
    expose dc function to be called by linux dm
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2a785bbf2b8f..815656a5b6bd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -384,6 +384,71 @@ void dc_stream_set_static_screen_events(struct dc *dc,
 	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
+void dc_link_set_drive_settings(struct dc *dc,
+				struct link_training_settings *lt_settings,
+				const struct dc_link *link)
+{
+
+	int i;
+
+	for (i = 0; i < dc->link_count; i++) {
+		if (dc->links[i] == link)
+			break;
+	}
+
+	if (i >= dc->link_count)
+		ASSERT_CRITICAL(false);
+
+	dc_link_dp_set_drive_settings(dc->links[i], lt_settings);
+}
+
+void dc_link_perform_link_training(struct dc *dc,
+				   struct dc_link_settings *link_setting,
+				   bool skip_video_pattern)
+{
+	int i;
+
+	for (i = 0; i < dc->link_count; i++)
+		dc_link_dp_perform_link_training(
+			dc->links[i],
+			link_setting,
+			skip_video_pattern);
+}
+
+void dc_link_set_preferred_link_settings(struct dc *dc,
+					 struct dc_link_settings *link_setting,
+					 struct dc_link *link)
+{
+	link->preferred_link_setting = *link_setting;
+	dp_retrain_link_dp_test(link, link_setting, false);
+}
+
+void dc_link_enable_hpd(const struct dc_link *link)
+{
+	dc_link_dp_enable_hpd(link);
+}
+
+void dc_link_disable_hpd(const struct dc_link *link)
+{
+	dc_link_dp_disable_hpd(link);
+}
+
+
+void dc_link_set_test_pattern(struct dc_link *link,
+			      enum dp_test_pattern test_pattern,
+			      const struct link_training_settings *p_link_settings,
+			      const unsigned char *p_custom_pattern,
+			      unsigned int cust_pattern_size)
+{
+	if (link != NULL)
+		dc_link_dp_set_test_pattern(
+			link,
+			test_pattern,
+			p_link_settings,
+			p_custom_pattern,
+			cust_pattern_size);
+}
+
 static void destruct(struct dc *dc)
 {
 	dc_release_state(dc->current_state);

commit c910a717dac6540a636a57c1a34261c6d84fc0eb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 18:39:21 2018 -0400

    drm/amd/display: clean up set_bandwidth usage
    
    This removes redundant set_bandwidth calls as well
    as fixes a bug in post_set_address_update where dcn1
    would never get to lower clocks.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 53ce7fa864b4..2a785bbf2b8f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -944,12 +944,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	dc->optimized_required = false;
 
-	/* 3rd param should be true, temp w/a for RV*/
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	dc->hwss.set_bandwidth(dc, context, dc->ctx->dce_version < DCN_VERSION_1_0);
-#else
 	dc->hwss.set_bandwidth(dc, context, true);
-#endif
 	return true;
 }
 

commit ce3f6e82249cccbbfd919ad30d256ec62d06b4af
Author: Alvin lee <alvin.lee3@amd.com>
Date:   Fri May 18 14:14:38 2018 -0400

    drm/amd/display: create sink_id in dc_sink structure to idenitify all sinks
    
    Signed-off-by: Alvin lee <alvin.lee3@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2c05630e78fb..53ce7fa864b4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -481,6 +481,7 @@ static bool construct(struct dc *dc,
 	dc_ctx->driver_context = init_params->driver;
 	dc_ctx->dc = dc;
 	dc_ctx->asic_id = init_params->asic_id;
+	dc_ctx->dc_sink_id_count = 0;
 	dc->ctx = dc_ctx;
 
 	dc->current_state = dc_create_state();

commit 8de94233f4cdcd5b3065fa9b9af3edc10874a120
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Wed May 9 15:41:47 2018 -0400

    drm/amd/display: Prefix TIMING_STANDARD entries with DC_
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2b1a92844c38..2c05630e78fb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1564,7 +1564,7 @@ struct dc_sink *dc_link_add_remote_sink(
 	struct dc_sink *dc_sink;
 	enum dc_edid_status edid_status;
 
-	if (len > MAX_EDID_BUFFER_SIZE) {
+	if (len > DC_MAX_EDID_BUFFER_SIZE) {
 		dm_error("Max EDID buffer size breached!\n");
 		return NULL;
 	}

commit a27f1996778363adc5ca3a31f6306edd8fa54350
Author: Yasir Al Shekerchi <YasirAl.Shekerchi@amd.com>
Date:   Fri May 4 16:53:03 2018 -0400

    drm/amd/display: Added documentation for some DC interface functions
    
    Signed-off-by: Yasir Al Shekerchi <YasirAl.Shekerchi@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 644b2187507b..2b1a92844c38 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -169,6 +169,22 @@ static bool create_links(
 	return false;
 }
 
+/**
+ *****************************************************************************
+ *  Function: dc_stream_adjust_vmin_vmax
+ *
+ *  @brief
+ *     Looks up the pipe context of dc_stream_state and updates the
+ *     vertical_total_min and vertical_total_max of the DRR, Dynamic Refresh
+ *     Rate, which is a power-saving feature that targets reducing panel
+ *     refresh rate while the screen is static
+ *
+ *  @param [in] dc: dc reference
+ *  @param [in] stream: Initial dc stream state
+ *  @param [in] adjust: Updated parameters for vertical_total_min and
+ *  vertical_total_max
+ *****************************************************************************
+ */
 bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 		struct dc_stream_state **streams, int num_streams,
 		int vmin, int vmax)

commit 95d2c3e15da613afd53b4b8f2cdb352dc7d12221
Merge: b8a71080ad28 8344c53f5705
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 16 08:21:51 2018 +1000

    Merge branch 'drm-next-4.18' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    Main changes for 4.18.  I'd like to do a separate pull for vega20 later
    this week or next.  Highlights:
    - Reserve pre-OS scanout buffer during init for seemless transition from
      console to driver
    - VEGAM support
    - Improved GPU scheduler documentation
    - Initial gfxoff support for raven
    - SR-IOV fixes
    - Default to non-AGP on PowerPC for radeon
    - Fine grained clock voltage control for vega10
    - Power profiles for vega10
    - Further clean up of powerplay/driver interface
    - Underlay fixes
    - Display link bw updates
    - Gamma fixes
    - Scatter/Gather display support on CZ/ST
    - Misc bug fixes and clean ups
    
    [airlied: fixup v3d vs scheduler API change]
    
    Link: https://patchwork.freedesktop.org/patch/msgid/20180515185450.1113-1-alexander.deucher@amd.com
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 85b25034608e861ce60b771b988967ea039a06c6
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Mar 25 16:41:06 2018 -0400

    drm/amd/display: Get rid of unused input_tf
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8f09f3ab0c29..e59357724eac 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1018,9 +1018,6 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->color_space != u->surface->color_space)
 		update_flags->bits.color_space_change = 1;
 
-	if (u->plane_info->input_tf != u->surface->input_tf)
-		update_flags->bits.input_tf_change = 1;
-
 	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror)
 		update_flags->bits.horizontal_mirror_change = 1;
 

commit 35ad2254cb7d0a46f135eb57990ca6618f79510b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Mar 29 11:23:37 2018 -0400

    drm/amd/display: csc updates require FULL update
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b331d9e78cdb..8f09f3ab0c29 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1154,12 +1154,20 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	if (u->input_csc_color_matrix)
 		update_flags->bits.input_csc_change = 1;
 
-	if (update_flags->bits.in_transfer_func_change
-			|| update_flags->bits.input_csc_change) {
+	if (u->coeff_reduction_factor)
+		update_flags->bits.coeff_reduction_change = 1;
+
+	if (update_flags->bits.in_transfer_func_change) {
 		type = UPDATE_TYPE_MED;
 		elevate_update_type(&overall_type, type);
 	}
 
+	if (update_flags->bits.input_csc_change
+			|| update_flags->bits.coeff_reduction_change) {
+		type = UPDATE_TYPE_FULL;
+		elevate_update_type(&overall_type, type);
+	}
+
 	return overall_type;
 }
 

commit 1402c605173bbbb1c2f7e615a1708a6ee61c69c3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Mar 14 17:56:58 2018 -0400

    drm/amd/display: Set all update flags when we have full update
    
    To prevent future optimization related bugs, just set all update
    flags when we have a full update, since we know we want to reprogram
    everything in that case.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6f4ad67ffca6..b331d9e78cdb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1208,7 +1208,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	type = check_update_surfaces_for_stream(dc, updates, surface_count, stream_update, stream_status);
 	if (type == UPDATE_TYPE_FULL)
 		for (i = 0; i < surface_count; i++)
-			updates[i].surface->update_flags.bits.full_update = 1;
+			updates[i].surface->update_flags.raw = 0xFFFFFFFF;
 
 	return type;
 }

commit 44d09c6a577c8ed4e0ef50257487c071ae5e0fa2
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Mar 15 14:29:24 2018 -0400

    drm/amd/display: Move commit_planes_to_stream to amdgpu_dm
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 554cf975be05..6f4ad67ffca6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -936,95 +936,6 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	return true;
 }
 
-/*
- * TODO this whole function needs to go
- *
- * dc_surface_update is needlessly complex. See if we can just replace this
- * with a dc_plane_state and follow the atomic model a bit more closely here.
- */
-bool dc_commit_planes_to_stream(
-		struct dc *dc,
-		struct dc_plane_state **plane_states,
-		uint8_t new_plane_count,
-		struct dc_stream_state *dc_stream,
-		struct dc_state *state)
-{
-	/* no need to dynamically allocate this. it's pretty small */
-	struct dc_surface_update updates[MAX_SURFACES];
-	struct dc_flip_addrs *flip_addr;
-	struct dc_plane_info *plane_info;
-	struct dc_scaling_info *scaling_info;
-	int i;
-	struct dc_stream_update *stream_update =
-			kzalloc(sizeof(struct dc_stream_update), GFP_KERNEL);
-
-	if (!stream_update) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
-
-	flip_addr = kcalloc(MAX_SURFACES, sizeof(struct dc_flip_addrs),
-			    GFP_KERNEL);
-	plane_info = kcalloc(MAX_SURFACES, sizeof(struct dc_plane_info),
-			     GFP_KERNEL);
-	scaling_info = kcalloc(MAX_SURFACES, sizeof(struct dc_scaling_info),
-			       GFP_KERNEL);
-
-	if (!flip_addr || !plane_info || !scaling_info) {
-		kfree(flip_addr);
-		kfree(plane_info);
-		kfree(scaling_info);
-		kfree(stream_update);
-		return false;
-	}
-
-	memset(updates, 0, sizeof(updates));
-
-	stream_update->src = dc_stream->src;
-	stream_update->dst = dc_stream->dst;
-	stream_update->out_transfer_func = dc_stream->out_transfer_func;
-
-	for (i = 0; i < new_plane_count; i++) {
-		updates[i].surface = plane_states[i];
-		updates[i].gamma =
-			(struct dc_gamma *)plane_states[i]->gamma_correction;
-		updates[i].in_transfer_func = plane_states[i]->in_transfer_func;
-		flip_addr[i].address = plane_states[i]->address;
-		flip_addr[i].flip_immediate = plane_states[i]->flip_immediate;
-		plane_info[i].color_space = plane_states[i]->color_space;
-		plane_info[i].input_tf = plane_states[i]->input_tf;
-		plane_info[i].format = plane_states[i]->format;
-		plane_info[i].plane_size = plane_states[i]->plane_size;
-		plane_info[i].rotation = plane_states[i]->rotation;
-		plane_info[i].horizontal_mirror = plane_states[i]->horizontal_mirror;
-		plane_info[i].stereo_format = plane_states[i]->stereo_format;
-		plane_info[i].tiling_info = plane_states[i]->tiling_info;
-		plane_info[i].visible = plane_states[i]->visible;
-		plane_info[i].per_pixel_alpha = plane_states[i]->per_pixel_alpha;
-		plane_info[i].dcc = plane_states[i]->dcc;
-		scaling_info[i].scaling_quality = plane_states[i]->scaling_quality;
-		scaling_info[i].src_rect = plane_states[i]->src_rect;
-		scaling_info[i].dst_rect = plane_states[i]->dst_rect;
-		scaling_info[i].clip_rect = plane_states[i]->clip_rect;
-
-		updates[i].flip_addr = &flip_addr[i];
-		updates[i].plane_info = &plane_info[i];
-		updates[i].scaling_info = &scaling_info[i];
-	}
-
-	dc_commit_updates_for_stream(
-			dc,
-			updates,
-			new_plane_count,
-			dc_stream, stream_update, plane_states, state);
-
-	kfree(flip_addr);
-	kfree(plane_info);
-	kfree(scaling_info);
-	kfree(stream_update);
-	return true;
-}
-
 struct dc_state *dc_create_state(void)
 {
 	struct dc_state *context = kzalloc(sizeof(struct dc_state),

commit 6e5b3587dbf6aaf7f9eef4956a3fce12bf7e9ffa
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Wed Mar 14 09:15:24 2018 -0400

    drm/amd/display: Add vline IRQ programming for DCN
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 63a3d468939a..554cf975be05 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1375,6 +1375,12 @@ static void commit_planes_for_stream(struct dc *dc,
 					pipe_ctx->stream_res.abm->funcs->set_abm_level(
 							pipe_ctx->stream_res.abm, stream->abm_level);
 			}
+
+			if (stream_update && stream_update->periodic_fn_vsync_delta &&
+					pipe_ctx->stream_res.tg->funcs->program_vline_interrupt)
+				pipe_ctx->stream_res.tg->funcs->program_vline_interrupt(
+						pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing,
+						pipe_ctx->stream->periodic_fn_vsync_delta);
 		}
 	}
 

commit 672a9c106966f8d418478830975288b8096bb058
Merge: e8403b493fd5 75a24b822d38
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 5 11:56:35 2018 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      kfifo: fix inaccurate comment
      tools/thermal: tmon: fix for segfault
      net: Spelling s/stucture/structure/
      edd: don't spam log if no EDD information is present
      Documentation: Fix early-microcode.txt references after file rename
      tracing: Block comments should align the * on each line
      treewide: Fix typos in printk
      GenWQE: Fix a typo in two comments
      treewide: Align function definition open/close braces

commit 447a5647c9e7ab97780541f546a90e2620caa487
Author: Joe Perches <joe@perches.com>
Date:   Wed Mar 21 15:09:32 2018 -0700

    treewide: Align function definition open/close braces
    
    Some functions definitions have either the initial open brace and/or
    the closing brace outside of column 1.
    
    Move those braces to column 1.
    
    This allows various function analyzers like gnu complexity to work
    properly for these modified functions.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Nicolin Chen <nicoleotsuka@gmail.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 12868c769606..5b15c04ce751 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -463,7 +463,7 @@ static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
  ******************************************************************************/
 
 struct dc *dc_create(const struct dc_init_data *init_params)
- {
+{
 	struct dc *dc = kzalloc(sizeof(*dc), GFP_KERNEL);
 	unsigned int full_pipe_count;
 

commit a4056c2a6344c64bd62234458a314e6aecce226f
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Feb 23 17:51:33 2018 -0500

    drm/amd/display: use HW hdr mult for brightness boost
    
    In MPO scenario when playing SDR clip in HDR desktop mode, Win is
    boosting desktop and requests driver to boost MPO. But driver boosting
    is currently done in regamma which is stream property and thus shared
    between grph and video.
    
    Redesigning the boosting in RV: use CM_HDR_MULT register which was added
    for this scenario. It also has the benefit that it can be done in HIRQL.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 16a1931bc4cd..63a3d468939a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1110,9 +1110,6 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->input_tf != u->surface->input_tf)
 		update_flags->bits.input_tf_change = 1;
 
-	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level)
-		update_flags->bits.output_tf_change = 1;
-
 	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror)
 		update_flags->bits.horizontal_mirror_change = 1;
 

commit 8e437c799158be80aa1ae27f362e30081e2a1e9f
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Feb 27 15:06:31 2018 -0500

    drm/amd/display: Modified set bandwidth sequence.
    
    This change make sure bandwidth is set properly.
    For increase bandwidth, set bandwidth before backend
    and front end programming.
    For decrease bandwidth, set bandwidth after.
    To avoid smu hang when reboot and dpms due to 0 disp clk,
    keep min disp clock as 100Mhz.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index fa402291a921..16a1931bc4cd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -871,11 +871,11 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->streams[i]->timing.pix_clk_khz);
 	}
 
+	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
+
 	/* pplib is notified if disp_num changed */
 	dc->hwss.set_bandwidth(dc, context, true);
 
-	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
-
 	dc_release_state(dc->current_state);
 
 	dc->current_state = context;

commit 623a7e96cd73a46d15f64b1c5e1f4ea3548271f2
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Feb 22 16:50:39 2018 -0500

    drm/amd/display: Remove 300Mhz minimum disp clk limit.
    
    300Mhz disp clk limit was a workaround that was fixed in SMU and is no
    longer needed.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e72fdb5697fc..fa402291a921 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -803,6 +803,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc, context);
 
+	dc->hwss.set_bandwidth(dc, context, false);
+
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use
 	 */
@@ -869,6 +871,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->streams[i]->timing.pix_clk_khz);
 	}
 
+	/* pplib is notified if disp_num changed */
+	dc->hwss.set_bandwidth(dc, context, true);
+
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
 	dc_release_state(dc->current_state);

commit a7596f25db13b1f5a2f8a068d8e9a60a23e34451
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Fri Feb 23 19:01:07 2018 -0500

    drm/amd/display: Varibright add null check
    
    Add null check for stream update
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 40a65cb9ee23..e72fdb5697fc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1363,7 +1363,7 @@ static void commit_planes_for_stream(struct dc *dc,
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
 
-			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
+			if (stream_update && stream_update->abm_level && pipe_ctx->stream_res.abm) {
 				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
 					// if otg funcs defined check if blanked before programming
 					if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))

commit 9aef1a31709076660f7d5f638ab5ecadea4ca856
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Fri Feb 23 13:04:13 2018 -0500

    drm/amd/display: Varibright fix bug and review comments
    
    Fix bug and make changes from review 132656
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a0b91eeb1939..40a65cb9ee23 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1363,11 +1363,15 @@ static void commit_planes_for_stream(struct dc *dc,
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
 
-			if (stream_update->abm_setting.stream_update) {
-				if (dc->res_pool->abm)
-					dc->res_pool->abm->funcs->set_abm_level(
-							dc->res_pool->abm, stream->abm_settings.abm_level);
-				stream->abm_settings.stream_update = 0;
+			if (stream_update->abm_level && pipe_ctx->stream_res.abm) {
+				if (pipe_ctx->stream_res.tg->funcs->is_blanked) {
+					// if otg funcs defined check if blanked before programming
+					if (!pipe_ctx->stream_res.tg->funcs->is_blanked(pipe_ctx->stream_res.tg))
+						pipe_ctx->stream_res.abm->funcs->set_abm_level(
+								pipe_ctx->stream_res.abm, stream->abm_level);
+				} else
+					pipe_ctx->stream_res.abm->funcs->set_abm_level(
+							pipe_ctx->stream_res.abm, stream->abm_level);
 			}
 		}
 	}

commit aa5a5777304228819a52562d346bc3eb1b4873fa
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Tue Feb 13 17:37:23 2018 -0500

    drm/amd/display: Vari-bright looks disabled near end of MM14
    
    Avoid hanging DMCU by setting abm level only when OTG unblanked
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8394d69b963f..a0b91eeb1939 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -42,6 +42,7 @@
 #include "dmcu.h"
 #include "dpp.h"
 #include "timing_generator.h"
+#include "abm.h"
 #include "virtual/virtual_link_encoder.h"
 
 #include "link_hwss.h"
@@ -1361,6 +1362,13 @@ static void commit_planes_for_stream(struct dc *dc,
 
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
+
+			if (stream_update->abm_setting.stream_update) {
+				if (dc->res_pool->abm)
+					dc->res_pool->abm->funcs->set_abm_level(
+							dc->res_pool->abm, stream->abm_settings.abm_level);
+				stream->abm_settings.stream_update = 0;
+			}
 		}
 	}
 

commit c0e463d3a02a54bdb272f9e52c5942348234c40e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Feb 13 11:03:01 2018 -0500

    drm/amd/display: Return success when enabling interrupt
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 35e84ed031de..12868c769606 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1358,13 +1358,13 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 	return dal_irq_service_to_irq_source(dc->res_pool->irqs, src_id, ext_id);
 }
 
-void dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
+bool dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
 {
 
 	if (dc == NULL)
-		return;
+		return false;
 
-	dal_irq_service_set(dc->res_pool->irqs, src, enable);
+	return dal_irq_service_set(dc->res_pool->irqs, src, enable);
 }
 
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)

commit a0e30392dd03727c069d1cf93ee6582473dd3dd6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Feb 13 11:03:01 2018 -0500

    drm/amd/display: Return success when enabling interrupt
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2bc15a46882a..8394d69b963f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1516,13 +1516,13 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 	return dal_irq_service_to_irq_source(dc->res_pool->irqs, src_id, ext_id);
 }
 
-void dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
+bool dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
 {
 
 	if (dc == NULL)
-		return;
+		return false;
 
-	dal_irq_service_set(dc->res_pool->irqs, src, enable);
+	return dal_irq_service_set(dc->res_pool->irqs, src, enable);
 }
 
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)

commit 1296423bf23c7a58133970e223b1f47ec6570308
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 20 17:42:50 2018 -0500

    drm/amd/display: define DC_LOGGER for logger
    
    Created a DC_LOGGER define. This is used to
    pass the logger into the macros.
    
    Anywhere we need to use the logger we need to define
    DC_LOGGER
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 73bb416cb7dc..2bc15a46882a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -51,6 +51,8 @@
 #include "dm_helpers.h"
 #include "mem_input.h"
 #include "hubp.h"
+#define DC_LOGGER \
+	dc->ctx->logger
 
 
 /*******************************************************************************
@@ -264,7 +266,7 @@ bool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,
 	/* Only call if supported */
 	if (tg->funcs->configure_crc)
 		return tg->funcs->configure_crc(tg, &param);
-	DC_LOG_WARNING(dc->ctx->logger,  "CRC capture not supported.");
+	DC_LOG_WARNING("CRC capture not supported.");
 	return false;
 }
 
@@ -297,7 +299,7 @@ bool dc_stream_get_crc(struct dc *dc, struct dc_stream_state *stream,
 
 	if (tg->funcs->get_crc)
 		return tg->funcs->get_crc(tg, r_cr, g_y, b_cb);
-	DC_LOG_WARNING(dc->ctx->logger,  "CRC capture not supported.");
+	DC_LOG_WARNING("CRC capture not supported.");
 	return false;
 }
 
@@ -618,8 +620,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 	dc->config = init_params->flags;
 
-	DC_LOG_DC(dc->ctx->logger,
-			"Display Core initialized\n");
+	DC_LOG_DC("Display Core initialized\n");
 
 
 	/* TODO: missing feature to be enabled */
@@ -888,7 +889,7 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	if (false == context_changed(dc, context))
 		return DC_OK;
 
-	DC_LOG_DC(dc->ctx->logger,  "%s: %d streams\n",
+	DC_LOG_DC("%s: %d streams\n",
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {

commit 2f3fd67a8af25f5b4d549c3e9cc515dbf1839ffc
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Feb 16 13:57:42 2018 -0500

    drm/amd/display: Use MACROS instead of dm_logger
    
    Created MACROS for all log levels. Also Replaced
    usage of dm_logger_write to the defined MACROS
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 77a1bf233c3c..73bb416cb7dc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -264,7 +264,7 @@ bool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,
 	/* Only call if supported */
 	if (tg->funcs->configure_crc)
 		return tg->funcs->configure_crc(tg, &param);
-	dm_logger_write(dc->ctx->logger, LOG_WARNING, "CRC capture not supported.");
+	DC_LOG_WARNING(dc->ctx->logger,  "CRC capture not supported.");
 	return false;
 }
 
@@ -297,7 +297,7 @@ bool dc_stream_get_crc(struct dc *dc, struct dc_stream_state *stream,
 
 	if (tg->funcs->get_crc)
 		return tg->funcs->get_crc(tg, r_cr, g_y, b_cb);
-	dm_logger_write(dc->ctx->logger, LOG_WARNING, "CRC capture not supported.");
+	DC_LOG_WARNING(dc->ctx->logger,  "CRC capture not supported.");
 	return false;
 }
 
@@ -618,7 +618,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 	dc->config = init_params->flags;
 
-	dm_logger_write(dc->ctx->logger, LOG_DC,
+	DC_LOG_DC(dc->ctx->logger,
 			"Display Core initialized\n");
 
 
@@ -888,7 +888,7 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	if (false == context_changed(dc, context))
 		return DC_OK;
 
-	dm_logger_write(dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+	DC_LOG_DC(dc->ctx->logger,  "%s: %d streams\n",
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {

commit e923a355aa5dc861d4a50c29a292242bd90140c8
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Feb 7 23:25:43 2018 -0500

    drm/amd/display: provide an interface to query firmware version
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8583d9e05721..77a1bf233c3c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -39,6 +39,7 @@
 #include "bios_parser_interface.h"
 #include "include/irq_service_interface.h"
 #include "transform.h"
+#include "dmcu.h"
 #include "dpp.h"
 #include "timing_generator.h"
 #include "virtual/virtual_link_encoder.h"
@@ -609,6 +610,12 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	dc->caps.max_audios = dc->res_pool->audio_count;
 	dc->caps.linear_pitch_alignment = 64;
 
+	/* Populate versioning information */
+	dc->versions.dc_ver = DC_VER;
+
+	if (dc->res_pool->dmcu != NULL)
+		dc->versions.dmcu_version = dc->res_pool->dmcu->dmcu_version;
+
 	dc->config = init_params->flags;
 
 	dm_logger_write(dc->ctx->logger, LOG_DC,

commit 6531738842dbc84ced7514b8934d7d43fae74680
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Feb 8 14:05:14 2018 -0500

    drm/amd/display: Treat bad EDID as no EDID
    
    We have an mst dock firmware that will emulate an EDID with bad
    checksum.
    
    v2: Tread -> Treat
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f4ffbf2e2caf..8583d9e05721 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1637,12 +1637,17 @@ struct dc_sink *dc_link_add_remote_sink(
 			&dc_sink->dc_edid,
 			&dc_sink->edid_caps);
 
-	if (edid_status != EDID_OK)
-		goto fail;
+	/*
+	 * Treat device as no EDID device if EDID
+	 * parsing fails
+	 */
+	if (edid_status != EDID_OK) {
+		dc_sink->dc_edid.length = 0;
+		dm_error("Bad EDID, status%d!\n", edid_status);
+	}
 
 	return dc_sink;
-fail:
-	dc_link_remove_remote_sink(link, dc_sink);
+
 fail_add_sink:
 	dc_sink_release(dc_sink);
 	return NULL;

commit aed7b06e49d2a4ceec6e71a33a2365576fc9c4da
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jan 23 17:43:37 2018 -0500

    drm/amd/display: When enabling CRC, disable dither & enable truncation
    
    When user-mode is using 8bpc, the hardware represents it internally
    using a higher bit depth. This causes problems when comparing CRCs for
    color managment tests.
    
    We need to disable dithering as well, since it makes CRC values
    non-deterministic.
    
    It's easy to see why dithering needs to be disabled, The reason why
    truncation also needs to be enabled is better described with an example.
    Consider the folowing which tests the color transform matrix (CTM):
    
    Expected CRC = FB_A -> Degamma (Bypassed) -> CTM (Bypassed)
                                                      |
                                                      v
                                Obtain CRC  <- Regamma(Bypassed)
    
    Actual CRC = FB_B -> Degamma (Bypassed) -> CTM (0.5*Identity)
                                                      |
                                                      v
                                Obtain CRC  <- Regamma(Bypassed)
    
    FB_A contains a solid red color at half intensity (127 @ 8bpc)
    FB_B contains a solid red color at full intensity (255 @ 8bpc)
    
    We expect that Expected CRC = Actual CRC, but that's not the case. When
    the CTM is applied, the output is at half intensity, but also at a
    higher bit depth within hardware. i.e. 255/2 = 127.5: not representable
    in 8bpc, but can be at 10bpc. This causes the two CRC's to be different.
    
    The solution is to truncate the output bit depth to the same as input
    when enabling CRC capture. Since Linux only supports 8bpc, hard code
    that for now.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ea5c35166ffa..f4ffbf2e2caf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -316,7 +316,6 @@ void dc_stream_set_dither_option(struct dc_stream_state *stream,
 		}
 	}
 
-	memset(&params, 0, sizeof(params));
 	if (!pipes)
 		return;
 	if (option > DITHER_OPTION_MAX)
@@ -324,9 +323,18 @@ void dc_stream_set_dither_option(struct dc_stream_state *stream,
 
 	stream->dither_option = option;
 
-	resource_build_bit_depth_reduction_params(stream,
-				&params);
+	memset(&params, 0, sizeof(params));
+	resource_build_bit_depth_reduction_params(stream, &params);
 	stream->bit_depth_params = params;
+
+	if (pipes->plane_res.xfm &&
+	    pipes->plane_res.xfm->funcs->transform_set_pixel_storage_depth) {
+		pipes->plane_res.xfm->funcs->transform_set_pixel_storage_depth(
+			pipes->plane_res.xfm,
+			pipes->plane_res.scl_data.lb_params.depth,
+			&stream->bit_depth_params);
+	}
+
 	pipes->stream_res.opp->funcs->
 		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }

commit 44af70a7428404f8c00b77988888c8b495b78766
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Feb 6 09:50:49 2018 -0500

    drm/amd/display: Expose dither setting functionality to Linux
    
    We will need this to disable dither for CRC capture.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a78e0364b1b2..ea5c35166ffa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -300,6 +300,37 @@ bool dc_stream_get_crc(struct dc *dc, struct dc_stream_state *stream,
 	return false;
 }
 
+void dc_stream_set_dither_option(struct dc_stream_state *stream,
+		enum dc_dither_option option)
+{
+	struct bit_depth_reduction_params params;
+	struct dc_link *link = stream->status.link;
+	struct pipe_ctx *pipes = NULL;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (link->dc->current_state->res_ctx.pipe_ctx[i].stream ==
+				stream) {
+			pipes = &link->dc->current_state->res_ctx.pipe_ctx[i];
+			break;
+		}
+	}
+
+	memset(&params, 0, sizeof(params));
+	if (!pipes)
+		return;
+	if (option > DITHER_OPTION_MAX)
+		return;
+
+	stream->dither_option = option;
+
+	resource_build_bit_depth_reduction_params(stream,
+				&params);
+	stream->bit_depth_params = params;
+	pipes->stream_res.opp->funcs->
+		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
+}
+
 void dc_stream_set_static_screen_events(struct dc *dc,
 		struct dc_stream_state **streams,
 		int num_streams,

commit a771c1f2892139e39416ed1fd272f8834f3ec658
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed Jan 10 17:40:32 2018 -0500

    drm/amd/display: Force full update on pixel_format_change
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 67e3d00eecd2..a78e0364b1b2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1105,6 +1105,7 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 
 	if (update_flags->bits.rotation_change
 			|| update_flags->bits.stereo_format_change
+			|| update_flags->bits.pixel_format_change
 			|| update_flags->bits.gamma_change
 			|| update_flags->bits.bpp_change
 			|| update_flags->bits.bandwidth_change

commit 05133ac856d0788a6d12f40b3f2e0af0d8a05147
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Jan 4 14:29:58 2018 -0500

    drm/amd/display: Synchronize update plane addr for freesync
    
    Lock top_pipe when doing update plane addr for split pipe freesync case
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index eddfc4396367..67e3d00eecd2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1278,6 +1278,7 @@ static void commit_planes_for_stream(struct dc *dc,
 		struct dc_state *context)
 {
 	int i, j;
+	struct pipe_ctx *top_pipe_to_program = NULL;
 
 	if (update_type == UPDATE_TYPE_FULL) {
 		dc->hwss.set_bandwidth(dc, context, false);
@@ -1297,13 +1298,17 @@ static void commit_planes_for_stream(struct dc *dc,
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (update_type == UPDATE_TYPE_FAST || !pipe_ctx->plane_state)
-			continue;
-
 		if (!pipe_ctx->top_pipe &&
-		    pipe_ctx->stream &&
-		    pipe_ctx->stream == stream) {
-			struct dc_stream_status *stream_status =
+			pipe_ctx->stream &&
+			pipe_ctx->stream == stream) {
+			struct dc_stream_status *stream_status = NULL;
+
+			top_pipe_to_program = pipe_ctx;
+
+			if (update_type == UPDATE_TYPE_FAST || !pipe_ctx->plane_state)
+				continue;
+
+			stream_status =
 					stream_get_status(context, pipe_ctx->stream);
 
 			dc->hwss.apply_ctx_for_surface(
@@ -1314,22 +1319,32 @@ static void commit_planes_for_stream(struct dc *dc,
 	if (update_type == UPDATE_TYPE_FULL)
 		context_timing_trace(dc, &context->res_ctx);
 
-	/* Perform requested Updates */
-	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *plane_state = srf_updates[i].surface;
+	/* Lock the top pipe while updating plane addrs, since freesync requires
+	 *  plane addr update event triggers to be synchronized.
+	 *  top_pipe_to_program is expected to never be NULL
+	 */
+	if (update_type == UPDATE_TYPE_FAST) {
+		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, true);
 
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+		/* Perform requested Updates */
+		for (i = 0; i < surface_count; i++) {
+			struct dc_plane_state *plane_state = srf_updates[i].surface;
 
-			if (pipe_ctx->stream != stream)
-				continue;
+			for (j = 0; j < dc->res_pool->pipe_count; j++) {
+				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (pipe_ctx->plane_state != plane_state)
-				continue;
+				if (pipe_ctx->stream != stream)
+					continue;
 
-			if (update_type == UPDATE_TYPE_FAST && srf_updates[i].flip_addr)
+				if (pipe_ctx->plane_state != plane_state)
+					continue;
+
+				if (srf_updates[i].flip_addr)
 					dc->hwss.update_plane_addr(dc, pipe_ctx);
+			}
 		}
+
+		dc->hwss.pipe_control_lock(dc, top_pipe_to_program, false);
 	}
 
 	if (stream && stream_update && update_type > UPDATE_TYPE_FAST)

commit 3aa0caddf6997a62e08e19bbaf6f5d61067c1196
Author: Duke Du <Duke.Du@amd.com>
Date:   Thu Jan 4 09:32:06 2018 +0800

    drm/amd/display: Update the register GRPH_SWAP_CNTL if surface pixel format changed.
    
    Signed-off-by: Duke Du <Duke.Du@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 990f891a46f6..eddfc4396367 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1066,6 +1066,9 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->rotation != u->surface->rotation)
 		update_flags->bits.rotation_change = 1;
 
+	if (u->plane_info->format != u->surface->format)
+		update_flags->bits.pixel_format_change = 1;
+
 	if (u->plane_info->stereo_format != u->surface->stereo_format)
 		update_flags->bits.stereo_format_change = 1;
 

commit 6d9ac917e6269c3446e19cb6adecd51aefa5fedf
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Fri Dec 22 11:22:39 2017 -0500

    drm/amd/display: [RS4][RV] SDR Brightness Boost
    
    We assume FP16 1.0 frame buffer value maps to 80 nits.
    DC changes are to make this configurable.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 350458d3730c..990f891a46f6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1057,6 +1057,9 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->input_tf != u->surface->input_tf)
 		update_flags->bits.input_tf_change = 1;
 
+	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level)
+		update_flags->bits.output_tf_change = 1;
+
 	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror)
 		update_flags->bits.horizontal_mirror_change = 1;
 
@@ -1101,7 +1104,8 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 			|| update_flags->bits.stereo_format_change
 			|| update_flags->bits.gamma_change
 			|| update_flags->bits.bpp_change
-			|| update_flags->bits.bandwidth_change)
+			|| update_flags->bits.bandwidth_change
+			|| update_flags->bits.output_tf_change)
 		return UPDATE_TYPE_FULL;
 
 	return UPDATE_TYPE_MED;

commit 31aec354f92ca811df79439233130dbd232162a9
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Mon Dec 18 14:20:39 2017 -0500

    drm/amd/display: Implement interface for CRC on CRTC
    
    Add interfaces in DC for per CRTC CRC configuration and fetching.
    Also implement amdgpu_dm functions to hook onto DRM.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ad44fb0215b4..350458d3730c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -215,6 +215,91 @@ bool dc_stream_get_crtc_position(struct dc *dc,
 	return ret;
 }
 
+/**
+ * dc_stream_configure_crc: Configure CRC capture for the given stream.
+ * @dc: DC Object
+ * @stream: The stream to configure CRC on.
+ * @enable: Enable CRC if true, disable otherwise.
+ * @continuous: Capture CRC on every frame if true. Otherwise, only capture
+ *              once.
+ *
+ * By default, only CRC0 is configured, and the entire frame is used to
+ * calculate the crc.
+ */
+bool dc_stream_configure_crc(struct dc *dc, struct dc_stream_state *stream,
+			     bool enable, bool continuous)
+{
+	int i;
+	struct pipe_ctx *pipe;
+	struct crc_params param;
+	struct timing_generator *tg;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe->stream == stream)
+			break;
+	}
+	/* Stream not found */
+	if (i == MAX_PIPES)
+		return false;
+
+	/* Always capture the full frame */
+	param.windowa_x_start = 0;
+	param.windowa_y_start = 0;
+	param.windowa_x_end = pipe->stream->timing.h_addressable;
+	param.windowa_y_end = pipe->stream->timing.v_addressable;
+	param.windowb_x_start = 0;
+	param.windowb_y_start = 0;
+	param.windowb_x_end = pipe->stream->timing.h_addressable;
+	param.windowb_y_end = pipe->stream->timing.v_addressable;
+
+	/* Default to the union of both windows */
+	param.selection = UNION_WINDOW_A_B;
+	param.continuous_mode = continuous;
+	param.enable = enable;
+
+	tg = pipe->stream_res.tg;
+
+	/* Only call if supported */
+	if (tg->funcs->configure_crc)
+		return tg->funcs->configure_crc(tg, &param);
+	dm_logger_write(dc->ctx->logger, LOG_WARNING, "CRC capture not supported.");
+	return false;
+}
+
+/**
+ * dc_stream_get_crc: Get CRC values for the given stream.
+ * @dc: DC object
+ * @stream: The DC stream state of the stream to get CRCs from.
+ * @r_cr, g_y, b_cb: CRC values for the three channels are stored here.
+ *
+ * dc_stream_configure_crc needs to be called beforehand to enable CRCs.
+ * Return false if stream is not found, or if CRCs are not enabled.
+ */
+bool dc_stream_get_crc(struct dc *dc, struct dc_stream_state *stream,
+		       uint32_t *r_cr, uint32_t *g_y, uint32_t *b_cb)
+{
+	int i;
+	struct pipe_ctx *pipe;
+	struct timing_generator *tg;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe->stream == stream)
+			break;
+	}
+	/* Stream not found */
+	if (i == MAX_PIPES)
+		return false;
+
+	tg = pipe->stream_res.tg;
+
+	if (tg->funcs->get_crc)
+		return tg->funcs->get_crc(tg, r_cr, g_y, b_cb);
+	dm_logger_write(dc->ctx->logger, LOG_WARNING, "CRC capture not supported.");
+	return false;
+}
+
 void dc_stream_set_static_screen_events(struct dc *dc,
 		struct dc_stream_state **streams,
 		int num_streams,

commit 405c50a07d3f67971d3e01cec83dbdcd5bdd529e
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Dec 20 10:07:42 2017 -0500

    drm/amd/display: Fix check for setting input TF
    
    We no longer change the plane state pointer for full updates, and as
    such, we weren't setting the input transfer function and programming the
    degamma registers when we are supposed to. Check for a full update, an
    input TF change, or a gamma change in the update flags instead to correct
    this.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d8a2079b360f..ad44fb0215b4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -29,6 +29,7 @@
 #include "core_status.h"
 #include "core_types.h"
 #include "hw_sequencer.h"
+#include "dce/dce_hwseq.h"
 
 #include "resource.h"
 
@@ -995,6 +996,9 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 		 */
 		update_flags->bits.bpp_change = 1;
 
+	if (u->gamma && dce_use_lut(u->plane_info->format))
+		update_flags->bits.gamma_change = 1;
+
 	if (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,
 			sizeof(union dc_tiling_info)) != 0) {
 		update_flags->bits.swizzle_change = 1;
@@ -1010,6 +1014,7 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 
 	if (update_flags->bits.rotation_change
 			|| update_flags->bits.stereo_format_change
+			|| update_flags->bits.gamma_change
 			|| update_flags->bits.bpp_change
 			|| update_flags->bits.bandwidth_change)
 		return UPDATE_TYPE_FULL;
@@ -1090,12 +1095,12 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	elevate_update_type(&overall_type, type);
 
 	if (u->in_transfer_func)
-		update_flags->bits.in_transfer_func = 1;
+		update_flags->bits.in_transfer_func_change = 1;
 
 	if (u->input_csc_color_matrix)
 		update_flags->bits.input_csc_change = 1;
 
-	if (update_flags->bits.in_transfer_func
+	if (update_flags->bits.in_transfer_func_change
 			|| update_flags->bits.input_csc_change) {
 		type = UPDATE_TYPE_MED;
 		elevate_update_type(&overall_type, type);

commit 25292028d74b4b13ab512bcac60a5e02e2a48b90
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Dec 19 11:51:40 2017 -0500

    drm/amd/display: Disable eDP with a proper sequence.
    
    Proper sequence should be:
    disable backlight
    dp blank
    disable output
    edp power off
    
    In enable accelatate mode, all the encoder and controller
    are disabled, so move disable eDP to the function is the
    easiest way to implement.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 36b761a3bfc6..d8a2079b360f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -649,31 +649,6 @@ bool dc_enable_stereo(
 	return ret;
 }
 
-static void disable_eDP_not_in_use(struct dc *dc, struct dc_state *context)
-{
-	int i;
-	struct dc_link *link = NULL;
-
-	/* check if eDP panel is suppose to be set mode, if yes, no need to disable */
-	for (i = 0; i < context->stream_count; i++) {
-		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
-			return;
-	}
-
-	/* check if there is an eDP panel not in use */
-	for (i = 0; i < dc->link_count; i++) {
-		if (dc->links[i]->local_sink &&
-			dc->links[i]->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
-			link = dc->links[i];
-			break;
-		}
-	}
-
-	if (link) {
-		dc->hwss.edp_backlight_control(link, false);
-		dc->hwss.edp_power_control(link, false);
-	}
-}
 /*
  * Applies given context to HW and copy it into current context.
  * It's up to the user to release the src context afterwards.
@@ -691,10 +666,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	for (i = 0; i < context->stream_count; i++)
 		dc_streams[i] =  context->streams[i];
 
-	if (!dcb->funcs->is_accelerated_mode(dcb)) {
-		dc->hwss.enable_accelerated_mode(dc);
-		disable_eDP_not_in_use(dc, context);
-	}
+	if (!dcb->funcs->is_accelerated_mode(dcb))
+		dc->hwss.enable_accelerated_mode(dc, context);
 
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use

commit 91178796ba171ebcc77bc384ff0a9afbeaf6b4d0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Dec 18 16:59:44 2017 -0500

    drm/amd/display: disable eDP backlight for extend monitor only reboot use case.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7938c1746841..36b761a3bfc6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -649,7 +649,31 @@ bool dc_enable_stereo(
 	return ret;
 }
 
+static void disable_eDP_not_in_use(struct dc *dc, struct dc_state *context)
+{
+	int i;
+	struct dc_link *link = NULL;
 
+	/* check if eDP panel is suppose to be set mode, if yes, no need to disable */
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->signal == SIGNAL_TYPE_EDP)
+			return;
+	}
+
+	/* check if there is an eDP panel not in use */
+	for (i = 0; i < dc->link_count; i++) {
+		if (dc->links[i]->local_sink &&
+			dc->links[i]->local_sink->sink_signal == SIGNAL_TYPE_EDP) {
+			link = dc->links[i];
+			break;
+		}
+	}
+
+	if (link) {
+		dc->hwss.edp_backlight_control(link, false);
+		dc->hwss.edp_power_control(link, false);
+	}
+}
 /*
  * Applies given context to HW and copy it into current context.
  * It's up to the user to release the src context afterwards.
@@ -667,8 +691,10 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	for (i = 0; i < context->stream_count; i++)
 		dc_streams[i] =  context->streams[i];
 
-	if (!dcb->funcs->is_accelerated_mode(dcb))
+	if (!dcb->funcs->is_accelerated_mode(dcb)) {
 		dc->hwss.enable_accelerated_mode(dc);
+		disable_eDP_not_in_use(dc, context);
+	}
 
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use

commit 03736f4cf83cb03aa6bdbc768941a4148d9b929c
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Mon Dec 18 10:34:56 2017 -0500

    drm/amd/display: Prevent master programming in multisync
    
    Verify that the stream is master - and program only the slave displays
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 59ad71a8ced0..7938c1746841 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -521,11 +521,13 @@ static void enable_timing_multisync(
 		if (!ctx->res_ctx.pipe_ctx[i].stream ||
 				!ctx->res_ctx.pipe_ctx[i].stream->triggered_crtc_reset.enabled)
 			continue;
+		if (ctx->res_ctx.pipe_ctx[i].stream == ctx->res_ctx.pipe_ctx[i].stream->triggered_crtc_reset.event_source)
+			continue;
 		multisync_pipes[multisync_count] = &ctx->res_ctx.pipe_ctx[i];
 		multisync_count++;
 	}
 
-	if (multisync_count > 1) {
+	if (multisync_count > 0) {
 		dc->hwss.enable_per_frame_crtc_position_reset(
 			dc, multisync_count, multisync_pipes);
 	}

commit 63b024c86974f7cc03fc9b8d780408218c347f8b
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Dec 13 17:29:01 2017 -0500

    drm/amd/display: cleanup after FBC init rework
    
    After reworking FBC init for dynamic mem alloc
    old FBC init code in DC became redundant.
    Removing it.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 35e84ed031de..59ad71a8ced0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -359,9 +359,6 @@ static bool construct(struct dc *dc,
 	dc_version = resource_parse_asic_id(init_params->asic_id);
 	dc_ctx->dce_version = dc_version;
 
-#if defined(CONFIG_DRM_AMD_DC_FBC)
-	dc->ctx->fbc_gpu_addr = init_params->fbc_gpu_addr;
-#endif
 	/* Resource should construct all asic specific resources.
 	 * This should be the only place where we need to parse the asic id
 	 */

commit 4ebf8483112e3f33f7a96b5aa8779d25ad5f71b7
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Dec 12 14:34:30 2017 -0500

    drm/amd/display: check for null before calling is_blanked
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ab875ea8aba4..35e84ed031de 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -580,7 +580,7 @@ static void program_timing_sync(
 		for (j = 0; j < group_size; j++) {
 			struct pipe_ctx *temp;
 
-			if (!pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
+			if (pipe_set[j]->stream_res.tg->funcs->is_blanked && !pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
 				if (j == 0)
 					break;
 
@@ -593,7 +593,7 @@ static void program_timing_sync(
 
 		/* remove any other unblanked pipes as they have already been synced */
 		for (j = j + 1; j < group_size; j++) {
-			if (!pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
+			if (pipe_set[j]->stream_res.tg->funcs->is_blanked && !pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
 				group_size--;
 				pipe_set[j] = pipe_set[group_size];
 				j--;

commit e9dd9223c6d633a33fd2125ed1b1ec9d5bcbb5a7
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Thu Nov 16 17:08:44 2017 -0500

    drm/amd/display: Add dcc_change surface update flag
    
    Program the DCC registers when dcc_change is true.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 19d96aeaa113..ab875ea8aba4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -985,6 +985,11 @@ static enum surface_update_type get_plane_info_update_type(const struct dc_surfa
 	if (u->plane_info->per_pixel_alpha != u->surface->per_pixel_alpha)
 		update_flags->bits.per_pixel_alpha_change = 1;
 
+	if (u->plane_info->dcc.enable != u->surface->dcc.enable
+			|| u->plane_info->dcc.grph.independent_64b_blks != u->surface->dcc.grph.independent_64b_blks
+			|| u->plane_info->dcc.grph.meta_pitch != u->surface->dcc.grph.meta_pitch)
+		update_flags->bits.dcc_change = 1;
+
 	if (pixel_format_to_bpp(u->plane_info->format) !=
 			pixel_format_to_bpp(u->surface->format))
 		/* different bytes per element will require full bandwidth

commit 4010472575f48787085aa66279275255e7919078
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 22 15:59:39 2017 -0500

    drm/amd/display: Add optimized_required flag
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 98eff80acffa..19d96aeaa113 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -788,6 +788,8 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 			dc->hwss.disable_plane(dc, &context->res_ctx.pipe_ctx[i]);
 		}
 
+	dc->optimized_required = false;
+
 	/* 3rd param should be true, temp w/a for RV*/
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	dc->hwss.set_bandwidth(dc, context, dc->ctx->dce_version < DCN_VERSION_1_0);

commit 52924dc3d0daf725a63f5c749cb263aad06f928a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 20:17:03 2017 -0500

    drm/amd/display: Fix potential mem leak in DC construct
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:506 construct() warn:
    possible memory leak of 'dc_ctx'
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:506 construct() warn:
    possible memory leak of 'dc_vbios'
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:506 construct() warn:
    possible memory leak of 'dcn_ip'
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:506 construct() warn:
    possible memory leak of 'dcn_soc'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 18fc5e792d5c..98eff80acffa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -283,19 +283,17 @@ static bool construct(struct dc *dc,
 		const struct dc_init_data *init_params)
 {
 	struct dal_logger *logger;
-	struct dc_context *dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
-	struct bw_calcs_dceip *dc_dceip = kzalloc(sizeof(*dc_dceip),
-						  GFP_KERNEL);
-	struct bw_calcs_vbios *dc_vbios = kzalloc(sizeof(*dc_vbios),
-						  GFP_KERNEL);
+	struct dc_context *dc_ctx;
+	struct bw_calcs_dceip *dc_dceip;
+	struct bw_calcs_vbios *dc_vbios;
 #ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	struct dcn_soc_bounding_box *dcn_soc = kzalloc(sizeof(*dcn_soc),
-						       GFP_KERNEL);
-	struct dcn_ip_params *dcn_ip = kzalloc(sizeof(*dcn_ip), GFP_KERNEL);
+	struct dcn_soc_bounding_box *dcn_soc;
+	struct dcn_ip_params *dcn_ip;
 #endif
 
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 
+	dc_dceip = kzalloc(sizeof(*dc_dceip), GFP_KERNEL);
 	if (!dc_dceip) {
 		dm_error("%s: failed to create dceip\n", __func__);
 		goto fail;
@@ -303,6 +301,7 @@ static bool construct(struct dc *dc,
 
 	dc->bw_dceip = dc_dceip;
 
+	dc_vbios = kzalloc(sizeof(*dc_vbios), GFP_KERNEL);
 	if (!dc_vbios) {
 		dm_error("%s: failed to create vbios\n", __func__);
 		goto fail;
@@ -310,6 +309,7 @@ static bool construct(struct dc *dc,
 
 	dc->bw_vbios = dc_vbios;
 #ifdef CONFIG_DRM_AMD_DC_DCN1_0
+	dcn_soc = kzalloc(sizeof(*dcn_soc), GFP_KERNEL);
 	if (!dcn_soc) {
 		dm_error("%s: failed to create dcn_soc\n", __func__);
 		goto fail;
@@ -317,6 +317,7 @@ static bool construct(struct dc *dc,
 
 	dc->dcn_soc = dcn_soc;
 
+	dcn_ip = kzalloc(sizeof(*dcn_ip), GFP_KERNEL);
 	if (!dcn_ip) {
 		dm_error("%s: failed to create dcn_ip\n", __func__);
 		goto fail;
@@ -325,11 +326,18 @@ static bool construct(struct dc *dc,
 	dc->dcn_ip = dcn_ip;
 #endif
 
+	dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
 	if (!dc_ctx) {
 		dm_error("%s: failed to create ctx\n", __func__);
 		goto fail;
 	}
 
+	dc_ctx->cgs_device = init_params->cgs_device;
+	dc_ctx->driver_context = init_params->driver;
+	dc_ctx->dc = dc;
+	dc_ctx->asic_id = init_params->asic_id;
+	dc->ctx = dc_ctx;
+
 	dc->current_state = dc_create_state();
 
 	if (!dc->current_state) {
@@ -337,11 +345,6 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 
-	dc_ctx->cgs_device = init_params->cgs_device;
-	dc_ctx->driver_context = init_params->driver;
-	dc_ctx->dc = dc;
-	dc_ctx->asic_id = init_params->asic_id;
-
 	/* Create logger */
 	logger = dal_logger_create(dc_ctx, init_params->log_mask);
 
@@ -351,11 +354,10 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 	dc_ctx->logger = logger;
-	dc->ctx = dc_ctx;
-	dc->ctx->dce_environment = init_params->dce_environment;
+	dc_ctx->dce_environment = init_params->dce_environment;
 
 	dc_version = resource_parse_asic_id(init_params->asic_id);
-	dc->ctx->dce_version = dc_version;
+	dc_ctx->dce_version = dc_version;
 
 #if defined(CONFIG_DRM_AMD_DC_FBC)
 	dc->ctx->fbc_gpu_addr = init_params->fbc_gpu_addr;

commit 096480eac61ca8aa1834ba7ceda165d397e29ca0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Nov 15 16:06:15 2017 -0500

    drm/amd/display: Remove unnecessary wait mpcc idle.
    
    Before power gate plane, mpcc idle wait is processed,
    no need to wait another time.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d1488d5ee028..18fc5e792d5c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1178,12 +1178,6 @@ static void commit_planes_for_stream(struct dc *dc,
 	if (update_type == UPDATE_TYPE_FULL) {
 		dc->hwss.set_bandwidth(dc, context, false);
 		context_clock_trace(dc, context);
-
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-
-			dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
-		}
 	}
 
 	if (surface_count == 0) {

commit 8980aa3c9ed63f703fd5e0bff6a53b6ba1356ae1
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Nov 13 17:22:17 2017 -0500

    drm/amd/display: Only program watermark for full update.
    
    For scaling and position change, it isn't necessary to program
    watermark and check P-State as well.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 727f68b39fce..d1488d5ee028 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1178,9 +1178,7 @@ static void commit_planes_for_stream(struct dc *dc,
 	if (update_type == UPDATE_TYPE_FULL) {
 		dc->hwss.set_bandwidth(dc, context, false);
 		context_clock_trace(dc, context);
-	}
 
-	if (update_type > UPDATE_TYPE_FAST) {
 		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
@@ -1215,7 +1213,7 @@ static void commit_planes_for_stream(struct dc *dc,
 		}
 	}
 
-	if (update_type > UPDATE_TYPE_FAST)
+	if (update_type == UPDATE_TYPE_FULL)
 		context_timing_trace(dc, &context->res_ctx);
 
 	/* Perform requested Updates */

commit 27b3f4fc91e1df74aa15f669c9b032d73dee2ef8
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Nov 10 16:12:08 2017 -0500

    drm/amd/display: Do not program front-end twice
    
    The sequence of front-end > back-end > front-end programming will
    program the front-end more than once. Add a mode_changed flag, and use
    it to determine whether the front-end should be programmed before, or
    after back-end.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4b683a9636f3..727f68b39fce 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -672,10 +672,13 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	/* re-program planes for existing stream, in case we need to
 	 * free up plane resource for later use
 	 */
-	for (i = 0; i < dc->current_state->stream_count; i++) {
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->streams[i]->mode_changed)
+			continue;
+
 		dc->hwss.apply_ctx_for_surface(
-			dc, dc->current_state->streams[i],
-			dc->current_state->stream_status[i].plane_count,
+			dc, context->streams[i],
+			context->stream_status[i].plane_count,
 			context); /* use new pipe config in new context */
 	}
 
@@ -701,6 +704,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
+		if (!context->streams[i]->mode_changed)
+			continue;
+
 		dc->hwss.apply_ctx_for_surface(
 				dc, context->streams[i],
 				context->stream_status[i].plane_count,

commit a9beb6c741fb8716a19821b7662b81dfd23751d7
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 12:05:35 2017 -0400

    drm/amd/display: Remove unnecessary dc_link vtable
    
    None of this needs to be a function table or dynamic in any way.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index fb33556eeac6..4b683a9636f3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -239,93 +239,6 @@ void dc_stream_set_static_screen_events(struct dc *dc,
 	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
-static void set_drive_settings(struct dc *dc,
-		struct link_training_settings *lt_settings,
-		const struct dc_link *link)
-{
-
-	int i;
-
-	for (i = 0; i < dc->link_count; i++) {
-		if (dc->links[i] == link)
-			break;
-	}
-
-	if (i >= dc->link_count)
-		ASSERT_CRITICAL(false);
-
-	dc_link_dp_set_drive_settings(dc->links[i], lt_settings);
-}
-
-static void perform_link_training(struct dc *dc,
-		struct dc_link_settings *link_setting,
-		bool skip_video_pattern)
-{
-	int i;
-
-	for (i = 0; i < dc->link_count; i++)
-		dc_link_dp_perform_link_training(
-			dc->links[i],
-			link_setting,
-			skip_video_pattern);
-}
-
-static void set_preferred_link_settings(struct dc *dc,
-		struct dc_link_settings *link_setting,
-		struct dc_link *link)
-{
-	link->preferred_link_setting = *link_setting;
-	dp_retrain_link_dp_test(link, link_setting, false);
-}
-
-static void enable_hpd(const struct dc_link *link)
-{
-	dc_link_dp_enable_hpd(link);
-}
-
-static void disable_hpd(const struct dc_link *link)
-{
-	dc_link_dp_disable_hpd(link);
-}
-
-
-static void set_test_pattern(
-		struct dc_link *link,
-		enum dp_test_pattern test_pattern,
-		const struct link_training_settings *p_link_settings,
-		const unsigned char *p_custom_pattern,
-		unsigned int cust_pattern_size)
-{
-	if (link != NULL)
-		dc_link_dp_set_test_pattern(
-			link,
-			test_pattern,
-			p_link_settings,
-			p_custom_pattern,
-			cust_pattern_size);
-}
-
-static void allocate_dc_stream_funcs(struct dc  *dc)
-{
-	dc->link_funcs.set_drive_settings =
-			set_drive_settings;
-
-	dc->link_funcs.perform_link_training =
-			perform_link_training;
-
-	dc->link_funcs.set_preferred_link_settings =
-			set_preferred_link_settings;
-
-	dc->link_funcs.enable_hpd =
-			enable_hpd;
-
-	dc->link_funcs.disable_hpd =
-			disable_hpd;
-
-	dc->link_funcs.set_test_pattern =
-			set_test_pattern;
-}
-
 static void destruct(struct dc *dc)
 {
 	dc_release_state(dc->current_state);
@@ -502,8 +415,6 @@ static bool construct(struct dc *dc,
 	if (!create_links(dc, init_params->num_virtual_links))
 		goto fail;
 
-	allocate_dc_stream_funcs(dc);
-
 	return true;
 
 fail:

commit 4f804817d5cfb4bd1abf59a29721446af4b4cfd4
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Nov 9 13:55:46 2017 -0500

    drm/amd/display: Move update_plane_addr to apply_ctx_for_surface for dce.
    
    Move update_plane_addr to apply_ctx_for_surface, address update will
    just be called once, not twice for updat type is full and medium.
    This will reduce some reg access and duration time.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f8cbc4f0b1a3..fb33556eeac6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1314,8 +1314,8 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
-			if (srf_updates[i].flip_addr)
-				dc->hwss.update_plane_addr(dc, pipe_ctx);
+			if (update_type == UPDATE_TYPE_FAST && srf_updates[i].flip_addr)
+					dc->hwss.update_plane_addr(dc, pipe_ctx);
 		}
 	}
 

commit db65d4ad91e7dc5b9109b115af70cf294e7686c4
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 8 16:51:03 2017 -0500

    drm/amd/display: Fix Linux after optimize frontend programming
    
    We still require the update_plane_addr call in commit_planes_for_stream.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f9c5ed6310b6..f8cbc4f0b1a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1314,11 +1314,8 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
-			if (update_type == UPDATE_TYPE_FAST) {
-				if (srf_updates[i].flip_addr)
-					dc->hwss.update_plane_addr(dc, pipe_ctx);
-				continue;
-			}
+			if (srf_updates[i].flip_addr)
+				dc->hwss.update_plane_addr(dc, pipe_ctx);
 		}
 	}
 

commit 2a06e0a5a491f306e22eb5a5239a6bd8ce0f1ac6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Nov 1 11:43:36 2017 -0400

    drm/amd/display: Remove unnecessary dc_stream vtable
    
    There's no need to have this as a vtable. The vtable was initially
    used for stream_adjust_vmin_vmax but the condition checked here
    (set_drr) is always true, hence we don't need to assign this
    dynamically anymore.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 63872ce500b8..f9c5ed6310b6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -164,7 +164,7 @@ static bool create_links(
 	return false;
 }
 
-static bool stream_adjust_vmin_vmax(struct dc *dc,
+bool dc_stream_adjust_vmin_vmax(struct dc *dc,
 		struct dc_stream_state **streams, int num_streams,
 		int vmin, int vmax)
 {
@@ -189,7 +189,7 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 	return ret;
 }
 
-static bool stream_get_crtc_position(struct dc *dc,
+bool dc_stream_get_crtc_position(struct dc *dc,
 		struct dc_stream_state **streams, int num_streams,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
@@ -214,45 +214,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 	return ret;
 }
 
-static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
-{
-	int i = 0;
-	bool ret = false;
-	struct pipe_ctx *pipes;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {
-			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
-			dc->hwss.program_gamut_remap(pipes);
-			ret = true;
-		}
-	}
-
-	return ret;
-}
-
-static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
-{
-	int i = 0;
-	bool ret = false;
-	struct pipe_ctx *pipes;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_state->res_ctx.pipe_ctx[i].stream
-				== stream) {
-
-			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
-			dc->hwss.program_csc_matrix(pipes,
-			stream->output_color_space,
-			stream->csc_color_matrix.matrix);
-			ret = true;
-		}
-	}
-
-	return ret;
-}
-
-static void set_static_screen_events(struct dc *dc,
+void dc_stream_set_static_screen_events(struct dc *dc,
 		struct dc_stream_state **streams,
 		int num_streams,
 		const struct dc_static_screen_events *events)
@@ -343,100 +305,8 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
-static void set_dither_option(struct dc_stream_state *stream,
-		enum dc_dither_option option)
-{
-	struct bit_depth_reduction_params params;
-	struct dc_link *link = stream->status.link;
-	struct pipe_ctx *pipes = NULL;
-	int i;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (link->dc->current_state->res_ctx.pipe_ctx[i].stream ==
-				stream) {
-			pipes = &link->dc->current_state->res_ctx.pipe_ctx[i];
-			break;
-		}
-	}
-
-	memset(&params, 0, sizeof(params));
-	if (!pipes)
-		return;
-	if (option > DITHER_OPTION_MAX)
-		return;
-
-	stream->dither_option = option;
-
-	resource_build_bit_depth_reduction_params(stream,
-				&params);
-	stream->bit_depth_params = params;
-	pipes->stream_res.opp->funcs->
-		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
-}
-
-void set_dpms(
-	struct dc *dc,
-	struct dc_stream_state *stream,
-	bool dpms_off)
-{
-	struct pipe_ctx *pipe_ctx = NULL;
-	int i;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {
-			pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
-			break;
-		}
-	}
-
-	if (!pipe_ctx) {
-		ASSERT(0);
-		return;
-	}
-
-	if (stream->dpms_off != dpms_off) {
-		stream->dpms_off = dpms_off;
-
-		if (dpms_off) {
-			core_link_disable_stream(pipe_ctx,
-					KEEP_ACQUIRED_RESOURCE);
-
-			dc->hwss.pplib_apply_display_requirements(
-					dc, dc->current_state);
-		} else {
-			dc->hwss.pplib_apply_display_requirements(
-					dc, dc->current_state);
-
-			core_link_enable_stream(dc->current_state, pipe_ctx);
-		}
-	}
-}
-
 static void allocate_dc_stream_funcs(struct dc  *dc)
 {
-	if (dc->hwss.set_drr != NULL) {
-		dc->stream_funcs.adjust_vmin_vmax =
-				stream_adjust_vmin_vmax;
-	}
-
-	dc->stream_funcs.set_static_screen_events =
-			set_static_screen_events;
-
-	dc->stream_funcs.get_crtc_position =
-			stream_get_crtc_position;
-
-	dc->stream_funcs.set_gamut_remap =
-			set_gamut_remap;
-
-	dc->stream_funcs.program_csc_matrix =
-			program_csc_matrix;
-
-	dc->stream_funcs.set_dither_option =
-			set_dither_option;
-
-	dc->stream_funcs.set_dpms =
-			set_dpms;
-
 	dc->link_funcs.set_drive_settings =
 			set_drive_settings;
 

commit 27b8931327aa5d0c2cedef16b0d32ac7b25a3cf5
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Nov 8 12:15:17 2017 -0500

    drm/amd/display: Add check update surfaces for stream wrapper
    
    This allows us to properly clear and set the update flags for all cases.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 369a5e7af47e..63872ce500b8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1310,7 +1310,7 @@ static enum surface_update_type det_surface_update(const struct dc *dc,
 	return overall_type;
 }
 
-enum surface_update_type dc_check_update_surfaces_for_stream(
+static enum surface_update_type check_update_surfaces_for_stream(
 		struct dc *dc,
 		struct dc_surface_update *updates,
 		int surface_count,
@@ -1330,7 +1330,6 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		enum surface_update_type type =
 				det_surface_update(dc, &updates[i]);
 
-		updates[i].surface->update_type = type;
 		if (type == UPDATE_TYPE_FULL)
 			return type;
 
@@ -1340,6 +1339,27 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	return overall_type;
 }
 
+enum surface_update_type dc_check_update_surfaces_for_stream(
+		struct dc *dc,
+		struct dc_surface_update *updates,
+		int surface_count,
+		struct dc_stream_update *stream_update,
+		const struct dc_stream_status *stream_status)
+{
+	int i;
+	enum surface_update_type type;
+
+	for (i = 0; i < surface_count; i++)
+		updates[i].surface->update_flags.raw = 0;
+
+	type = check_update_surfaces_for_stream(dc, updates, surface_count, stream_update, stream_status);
+	if (type == UPDATE_TYPE_FULL)
+		for (i = 0; i < surface_count; i++)
+			updates[i].surface->update_flags.bits.full_update = 1;
+
+	return type;
+}
+
 static struct dc_stream_status *stream_get_status(
 	struct dc_state *ctx,
 	struct dc_stream_state *stream)

commit 746673c79dca3dc4c9720e49cd57b467da7a5ac8
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Nov 8 09:21:28 2017 -0500

    drm/amd/display: Rename pitch_alignment to linear_pitch_alignment
    
    Also initialize this to 64 for all ASICs.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 03d8cea7400a..369a5e7af47e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -702,6 +702,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 	dc->caps.max_links = dc->link_count;
 	dc->caps.max_audios = dc->res_pool->audio_count;
+	dc->caps.linear_pitch_alignment = 64;
 
 	dc->config = init_params->flags;
 

commit 949785b5d113af61d40999b2841d1a99de6f9075
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Nov 7 23:37:49 2017 -0500

    drm/amd/display: fix plane update prior to stream enablement
    
    plane update prior to stream enablement is there to recombine pipe
    in case we need free pipe for new display.  need to pass in new state
    or we will just re-applyingwhat we already have
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 34e678f30328..03d8cea7400a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -887,12 +887,14 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
-	/* Combine planes if required, in case of pipe split disable */
+	/* re-program planes for existing stream, in case we need to
+	 * free up plane resource for later use
+	 */
 	for (i = 0; i < dc->current_state->stream_count; i++) {
 		dc->hwss.apply_ctx_for_surface(
 			dc, dc->current_state->streams[i],
 			dc->current_state->stream_status[i].plane_count,
-			dc->current_state);
+			context); /* use new pipe config in new context */
 	}
 
 	/* Program hardware */

commit 19ec320e82c63a44d8d61752e139351be18928ba
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Mon Nov 6 17:00:07 2017 -0500

    drm/amd/display: Add update flags in to determine surface update type
    
    This way, we can know exactly what triggered the update type we're
    looking at, and we can simplify the logic for determining what exactly
    needs to be updated in the future.
    
    Also allow a dst rect size increase to go through a medium update,
    since that does not require us to increase clock or bandwidth.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3497d827b877..34e678f30328 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -54,6 +54,13 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
+
+static inline void elevate_update_type(enum surface_update_type *original, enum surface_update_type new)
+{
+	if (new > *original)
+		*original = new;
+}
+
 static void destroy_links(struct dc *dc)
 {
 	uint32_t i;
@@ -1161,77 +1168,88 @@ static unsigned int pixel_format_to_bpp(enum surface_pixel_format format)
 
 static enum surface_update_type get_plane_info_update_type(const struct dc_surface_update *u)
 {
-	struct dc_plane_info temp_plane_info;
-	memset(&temp_plane_info, 0, sizeof(temp_plane_info));
+	union surface_update_flags *update_flags = &u->surface->update_flags;
 
 	if (!u->plane_info)
 		return UPDATE_TYPE_FAST;
 
-	temp_plane_info = *u->plane_info;
+	if (u->plane_info->color_space != u->surface->color_space)
+		update_flags->bits.color_space_change = 1;
 
-	/* Copy all parameters that will cause a full update
-	 * from current surface, the rest of the parameters
-	 * from provided plane configuration.
-	 * Perform memory compare and special validation
-	 * for those that can cause fast/medium updates
-	 */
+	if (u->plane_info->input_tf != u->surface->input_tf)
+		update_flags->bits.input_tf_change = 1;
 
-	/* Full update parameters */
-	temp_plane_info.color_space = u->surface->color_space;
-	temp_plane_info.input_tf = u->surface->input_tf;
-	temp_plane_info.horizontal_mirror = u->surface->horizontal_mirror;
-	temp_plane_info.rotation = u->surface->rotation;
-	temp_plane_info.stereo_format = u->surface->stereo_format;
+	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror)
+		update_flags->bits.horizontal_mirror_change = 1;
 
-	if (memcmp(u->plane_info, &temp_plane_info,
-			sizeof(struct dc_plane_info)) != 0)
-		return UPDATE_TYPE_FULL;
+	if (u->plane_info->rotation != u->surface->rotation)
+		update_flags->bits.rotation_change = 1;
+
+	if (u->plane_info->stereo_format != u->surface->stereo_format)
+		update_flags->bits.stereo_format_change = 1;
+
+	if (u->plane_info->per_pixel_alpha != u->surface->per_pixel_alpha)
+		update_flags->bits.per_pixel_alpha_change = 1;
 
 	if (pixel_format_to_bpp(u->plane_info->format) !=
-			pixel_format_to_bpp(u->surface->format)) {
+			pixel_format_to_bpp(u->surface->format))
 		/* different bytes per element will require full bandwidth
 		 * and DML calculation
 		 */
-		return UPDATE_TYPE_FULL;
-	}
+		update_flags->bits.bpp_change = 1;
 
 	if (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,
 			sizeof(union dc_tiling_info)) != 0) {
+		update_flags->bits.swizzle_change = 1;
 		/* todo: below are HW dependent, we should add a hook to
 		 * DCE/N resource and validated there.
 		 */
-		if (u->plane_info->tiling_info.gfx9.swizzle != DC_SW_LINEAR) {
+		if (u->plane_info->tiling_info.gfx9.swizzle != DC_SW_LINEAR)
 			/* swizzled mode requires RQ to be setup properly,
 			 * thus need to run DML to calculate RQ settings
 			 */
-			return UPDATE_TYPE_FULL;
-		}
+			update_flags->bits.bandwidth_change = 1;
 	}
 
+	if (update_flags->bits.rotation_change
+			|| update_flags->bits.stereo_format_change
+			|| update_flags->bits.bpp_change
+			|| update_flags->bits.bandwidth_change)
+		return UPDATE_TYPE_FULL;
+
 	return UPDATE_TYPE_MED;
 }
 
-static enum surface_update_type  get_scaling_info_update_type(
+static enum surface_update_type get_scaling_info_update_type(
 		const struct dc_surface_update *u)
 {
+	union surface_update_flags *update_flags = &u->surface->update_flags;
+
 	if (!u->scaling_info)
 		return UPDATE_TYPE_FAST;
 
 	if (u->scaling_info->clip_rect.width != u->surface->clip_rect.width
 			|| u->scaling_info->clip_rect.height != u->surface->clip_rect.height
 			|| u->scaling_info->dst_rect.width != u->surface->dst_rect.width
-			|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height)
-		return UPDATE_TYPE_FULL;
+			|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height) {
+		update_flags->bits.scaling_change = 1;
+
+		if ((u->scaling_info->dst_rect.width < u->surface->dst_rect.width
+			|| u->scaling_info->dst_rect.height < u->surface->dst_rect.height)
+				&& (u->scaling_info->dst_rect.width < u->surface->src_rect.width
+					|| u->scaling_info->dst_rect.height < u->surface->src_rect.height))
+			/* Making dst rect smaller requires a bandwidth change */
+			update_flags->bits.bandwidth_change = 1;
+	}
 
 	if (u->scaling_info->src_rect.width != u->surface->src_rect.width
 		|| u->scaling_info->src_rect.height != u->surface->src_rect.height) {
 
+		update_flags->bits.scaling_change = 1;
 		if (u->scaling_info->src_rect.width > u->surface->src_rect.width
 				&& u->scaling_info->src_rect.height > u->surface->src_rect.height)
-			return UPDATE_TYPE_FULL;
-
-		/* Upscaling does not require a full update */
-		return UPDATE_TYPE_MED;
+			/* Making src rect bigger requires a bandwidth change */
+			update_flags->bits.clock_change = 1;
 	}
 
 	if (u->scaling_info->src_rect.x != u->surface->src_rect.x
@@ -1240,33 +1258,50 @@ static enum surface_update_type  get_scaling_info_update_type(
 			|| u->scaling_info->clip_rect.y != u->surface->clip_rect.y
 			|| u->scaling_info->dst_rect.x != u->surface->dst_rect.x
 			|| u->scaling_info->dst_rect.y != u->surface->dst_rect.y)
+		update_flags->bits.position_change = 1;
+
+	if (update_flags->bits.clock_change
+			|| update_flags->bits.bandwidth_change)
+		return UPDATE_TYPE_FULL;
+
+	if (update_flags->bits.scaling_change
+			|| update_flags->bits.position_change)
 		return UPDATE_TYPE_MED;
 
 	return UPDATE_TYPE_FAST;
 }
 
 static enum surface_update_type det_surface_update(const struct dc *dc,
-												   const struct dc_surface_update *u)
+		const struct dc_surface_update *u)
 {
 	const struct dc_state *context = dc->current_state;
-	enum surface_update_type type = UPDATE_TYPE_FAST;
+	enum surface_update_type type;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
+	union surface_update_flags *update_flags = &u->surface->update_flags;
+
+	update_flags->raw = 0; // Reset all flags
 
-	if (!is_surface_in_context(context, u->surface))
+	if (!is_surface_in_context(context, u->surface)) {
+		update_flags->bits.new_plane = 1;
 		return UPDATE_TYPE_FULL;
+	}
 
 	type = get_plane_info_update_type(u);
-	if (overall_type < type)
-		overall_type = type;
+	elevate_update_type(&overall_type, type);
 
 	type = get_scaling_info_update_type(u);
-	if (overall_type < type)
-		overall_type = type;
+	elevate_update_type(&overall_type, type);
+
+	if (u->in_transfer_func)
+		update_flags->bits.in_transfer_func = 1;
+
+	if (u->input_csc_color_matrix)
+		update_flags->bits.input_csc_change = 1;
 
-	if (u->in_transfer_func ||
-		u->input_csc_color_matrix) {
-		if (overall_type < UPDATE_TYPE_MED)
-			overall_type = UPDATE_TYPE_MED;
+	if (update_flags->bits.in_transfer_func
+			|| update_flags->bits.input_csc_change) {
+		type = UPDATE_TYPE_MED;
+		elevate_update_type(&overall_type, type);
 	}
 
 	return overall_type;
@@ -1292,11 +1327,11 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		enum surface_update_type type =
 				det_surface_update(dc, &updates[i]);
 
+		updates[i].surface->update_type = type;
 		if (type == UPDATE_TYPE_FULL)
 			return type;
 
-		if (overall_type < type)
-			overall_type = type;
+		elevate_update_type(&overall_type, type);
 	}
 
 	return overall_type;

commit 9f89df7d9bdff3b12ba50183420e1177b259f0e6
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Nov 7 14:54:56 2017 -0500

    drm/amd/display: Remove legacy unused workaround
    
    We shouldn't be able to get a non-visible plane into DC anymore.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3808b562a59f..3497d827b877 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1159,9 +1159,7 @@ static unsigned int pixel_format_to_bpp(enum surface_pixel_format format)
 	}
 }
 
-static enum surface_update_type get_plane_info_update_type(
-		const struct dc_surface_update *u,
-		int surface_index)
+static enum surface_update_type get_plane_info_update_type(const struct dc_surface_update *u)
 {
 	struct dc_plane_info temp_plane_info;
 	memset(&temp_plane_info, 0, sizeof(temp_plane_info));
@@ -1185,11 +1183,6 @@ static enum surface_update_type get_plane_info_update_type(
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
 
-	if (surface_index == 0)
-		temp_plane_info.visible = u->plane_info->visible;
-	else
-		temp_plane_info.visible = u->surface->visible;
-
 	if (memcmp(u->plane_info, &temp_plane_info,
 			sizeof(struct dc_plane_info)) != 0)
 		return UPDATE_TYPE_FULL;
@@ -1252,10 +1245,8 @@ static enum surface_update_type  get_scaling_info_update_type(
 	return UPDATE_TYPE_FAST;
 }
 
-static enum surface_update_type det_surface_update(
-		const struct dc *dc,
-		const struct dc_surface_update *u,
-		int surface_index)
+static enum surface_update_type det_surface_update(const struct dc *dc,
+												   const struct dc_surface_update *u)
 {
 	const struct dc_state *context = dc->current_state;
 	enum surface_update_type type = UPDATE_TYPE_FAST;
@@ -1264,7 +1255,7 @@ static enum surface_update_type det_surface_update(
 	if (!is_surface_in_context(context, u->surface))
 		return UPDATE_TYPE_FULL;
 
-	type = get_plane_info_update_type(u, surface_index);
+	type = get_plane_info_update_type(u);
 	if (overall_type < type)
 		overall_type = type;
 
@@ -1299,7 +1290,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
-				det_surface_update(dc, &updates[i], i);
+				det_surface_update(dc, &updates[i]);
 
 		if (type == UPDATE_TYPE_FULL)
 			return type;

commit e7f93e906748499951a76e9035ac8f6e85c0a110
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Nov 7 15:54:58 2017 -0500

    drm/amd/display: Early return on stream programming failure
    
    The fail goto is incorrect. It will incorrectly release the dc_states on
    stream programming failure.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e8ec2b0bd90b..3808b562a59f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -899,7 +899,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	result = dc->hwss.apply_ctx_to_hw(dc, context);
 
 	if (result != DC_OK)
-		goto fail;
+		return result;
 
 	if (context->stream_count > 1) {
 		enable_timing_multisync(dc, context);
@@ -938,7 +938,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->streams[i]->timing.pix_clk_khz);
 	}
 
-fail:
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
 	dc_release_state(dc->current_state);

commit b674f1edc9a033f4d3ea61e5f4996186e27bdcb5
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Nov 7 13:51:02 2017 -0500

    drm/amd/display: Change frontend/backend programming sequence
    
    This is a follow-up to the following change:
    
    Yongqiang Sun: Program front end first when set mode.
    
    Due to pipe-splitting features, how we handle stream enabling and
    disabling needs to change.
    
    In the case of pipe split disable, two planes need to be combined back
    into the same stream. This needs to be done before any stream
    programming happens.
    
    The previous patch addresses this, but breaks cross-platform
    compatibility. It's not guaranteed that a dc commit will be called
    separately to program planes and streams.
    
    Therefore, we handle the combined commit case by doing plane programming
    both before and after stream programming, to handle pipe split disable
    and plane enable respectively.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 96267b9b99d5..e8ec2b0bd90b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -880,6 +880,33 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
+	/* Combine planes if required, in case of pipe split disable */
+	for (i = 0; i < dc->current_state->stream_count; i++) {
+		dc->hwss.apply_ctx_for_surface(
+			dc, dc->current_state->streams[i],
+			dc->current_state->stream_status[i].plane_count,
+			dc->current_state);
+	}
+
+	/* Program hardware */
+	dc->hwss.ready_shared_resources(dc, context);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		pipe = &context->res_ctx.pipe_ctx[i];
+		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
+	}
+
+	result = dc->hwss.apply_ctx_to_hw(dc, context);
+
+	if (result != DC_OK)
+		goto fail;
+
+	if (context->stream_count > 1) {
+		enable_timing_multisync(dc, context);
+		program_timing_sync(dc, context);
+	}
+
+	/* Program all planes within new context*/
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
@@ -911,19 +938,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 				context->streams[i]->timing.pix_clk_khz);
 	}
 
-	dc->hwss.ready_shared_resources(dc, context);
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		pipe = &context->res_ctx.pipe_ctx[i];
-		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
-	}
-	result = dc->hwss.apply_ctx_to_hw(dc, context);
-
-	if (context->stream_count > 1) {
-		enable_timing_multisync(dc, context);
-		program_timing_sync(dc, context);
-	}
-
+fail:
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
 	dc_release_state(dc->current_state);

commit 4faf6eddfbebba1cdc4653484b7a8c8f28bd3bff
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Nov 7 13:21:02 2017 -0500

    drm/amd/display: Remove dangling planes on dc commit state
    
    When disabling pipe splitting, we need to make sure we disable both
    planes used.
    
    This should be done for Linux as well.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e0f13d79911d..96267b9b99d5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -880,8 +880,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
-
-
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 

commit b8fce2c9d773e178380cfeb659ebe453a8216f4b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Nov 7 11:01:34 2017 -0500

    drm/amd/display: Optimize programming front end
    
    In case of update type is medium, optimize squence,
    reduce programing time.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7578b4a9ee5b..e0f13d79911d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1353,7 +1353,7 @@ static void commit_planes_for_stream(struct dc *dc,
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
+		if (update_type == UPDATE_TYPE_FAST || !pipe_ctx->plane_state)
 			continue;
 
 		if (!pipe_ctx->top_pipe &&
@@ -1374,26 +1374,20 @@ static void commit_planes_for_stream(struct dc *dc,
 	for (i = 0; i < surface_count; i++) {
 		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
-		if (update_type == UPDATE_TYPE_MED)
-			dc->hwss.apply_ctx_for_surface(
-					dc, stream, surface_count, context);
-
 		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (pipe_ctx->plane_state != plane_state)
+			if (pipe_ctx->stream != stream)
 				continue;
 
-			if (srf_updates[i].flip_addr)
-				dc->hwss.update_plane_addr(dc, pipe_ctx);
-
-			if (update_type == UPDATE_TYPE_FAST)
+			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
-			/* work around to program degamma regs for split pipe after set mode. */
-			if (srf_updates[i].in_transfer_func ||
-			    (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state))
-				dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
+			if (update_type == UPDATE_TYPE_FAST) {
+				if (srf_updates[i].flip_addr)
+					dc->hwss.update_plane_addr(dc, pipe_ctx);
+				continue;
+			}
 		}
 	}
 

commit 7f914a62c94fb29b96a88d72c9a2688db95275cf
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Nov 6 14:40:31 2017 -0500

    drm/amd/display: Apply work around for stutter.
    
    Power on one plane after disable all the planes, for
    a hw bug work around to resolve stutter efficiency issue.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4c078c284f90..7578b4a9ee5b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -974,7 +974,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL ||
 		    context->res_ctx.pipe_ctx[i].plane_state == NULL) {
 			context->res_ctx.pipe_ctx[i].pipe_idx = i;
-			dc->hwss.power_down_front_end(dc, &context->res_ctx.pipe_ctx[i]);
+			dc->hwss.disable_plane(dc, &context->res_ctx.pipe_ctx[i]);
 		}
 
 	/* 3rd param should be true, temp w/a for RV*/

commit 5fd9f8a10f7cfcb584cdb993610491baa4fc4611
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Mon Nov 6 15:53:36 2017 -0500

    drm/amd/display: Loosen plane_info and scaling_info checks
    
    Make it so that differing dcc and plane size fields don't necessarily
    result in a full update, along with upscaling modes. This allows us to
    save some unnecessary full updates.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5745304b5af5..4c078c284f90 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1169,9 +1169,7 @@ static enum surface_update_type get_plane_info_update_type(
 	/* Full update parameters */
 	temp_plane_info.color_space = u->surface->color_space;
 	temp_plane_info.input_tf = u->surface->input_tf;
-	temp_plane_info.dcc = u->surface->dcc;
 	temp_plane_info.horizontal_mirror = u->surface->horizontal_mirror;
-	temp_plane_info.plane_size = u->surface->plane_size;
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
 
@@ -1214,14 +1212,23 @@ static enum surface_update_type  get_scaling_info_update_type(
 	if (!u->scaling_info)
 		return UPDATE_TYPE_FAST;
 
-	if (u->scaling_info->src_rect.width != u->surface->src_rect.width
-			|| u->scaling_info->src_rect.height != u->surface->src_rect.height
-			|| u->scaling_info->clip_rect.width != u->surface->clip_rect.width
+	if (u->scaling_info->clip_rect.width != u->surface->clip_rect.width
 			|| u->scaling_info->clip_rect.height != u->surface->clip_rect.height
 			|| u->scaling_info->dst_rect.width != u->surface->dst_rect.width
 			|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height)
 		return UPDATE_TYPE_FULL;
 
+	if (u->scaling_info->src_rect.width != u->surface->src_rect.width
+		|| u->scaling_info->src_rect.height != u->surface->src_rect.height) {
+
+		if (u->scaling_info->src_rect.width > u->surface->src_rect.width
+				&& u->scaling_info->src_rect.height > u->surface->src_rect.height)
+			return UPDATE_TYPE_FULL;
+
+		/* Upscaling does not require a full update */
+		return UPDATE_TYPE_MED;
+	}
+
 	if (u->scaling_info->src_rect.x != u->surface->src_rect.x
 			|| u->scaling_info->src_rect.y != u->surface->src_rect.y
 			|| u->scaling_info->clip_rect.x != u->surface->clip_rect.x

commit 631aaa0af4be3de8f0184095075650afaa023334
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Oct 31 15:55:15 2017 -0400

    drm/amd/display: send display_count msg so SMU can enter S0i2
    
    SMU can future lower voltages in long idle case when all display is off.
    
    If all display output is turned off via DPMS, send display_count = 0
    after all output are turned off.
    
    otherwise send display_count msg before turning on display to make sure
    SMU exit S0i2 state.  before is not neccessary as we are out of S0i2
    when driver execute code, but send message before anyways for correctness.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e59e7028ad57..5745304b5af5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -389,11 +389,19 @@ void set_dpms(
 
 	if (stream->dpms_off != dpms_off) {
 		stream->dpms_off = dpms_off;
-		if (dpms_off)
+
+		if (dpms_off) {
 			core_link_disable_stream(pipe_ctx,
 					KEEP_ACQUIRED_RESOURCE);
-		else
+
+			dc->hwss.pplib_apply_display_requirements(
+					dc, dc->current_state);
+		} else {
+			dc->hwss.pplib_apply_display_requirements(
+					dc, dc->current_state);
+
 			core_link_enable_stream(dc->current_state, pipe_ctx);
+		}
 	}
 }
 

commit 3e64668d7926854b084f89831ecbe4ae75600db6
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Nov 2 10:52:09 2017 -0400

    drm/amd/display: fix regamma programming
    
    When new coefficients match cached we would skip setting regamma mode
    Also, when doing a stream update we would program regamma for all pipes,
    even thos that are not yet powered on. This resulted in never setting
    regamma since we would cache before the pipe is powered.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f3397ff17345..e59e7028ad57 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1382,27 +1382,19 @@ static void commit_planes_for_stream(struct dc *dc,
 		}
 	}
 
-	if (update_type > UPDATE_TYPE_FAST) {
+	if (stream && stream_update && update_type > UPDATE_TYPE_FAST)
 		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx =
 					&context->res_ctx.pipe_ctx[j];
 
-			if (!pipe_ctx->stream)
+			if (pipe_ctx->stream != stream)
 				continue;
 
-			if (stream_update != NULL &&
-				stream_update->out_transfer_func != NULL) {
-				dc->hwss.set_output_transfer_func(
-						pipe_ctx, pipe_ctx->stream);
-			}
-
-			if (stream_update != NULL &&
-				stream_update->hdr_static_metadata) {
+			if (stream_update->hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);
 				dc->hwss.update_info_frame(pipe_ctx);
 			}
 		}
-	}
 }
 
 void dc_commit_updates_for_stream(struct dc *dc,

commit a6114e854c55c928b9b8bcf7014eb205bd112c68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Oct 31 16:27:59 2017 -0400

    drm/amd/display: Fix some more color indentations
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 39431bd8d77e..f3397ff17345 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1376,10 +1376,9 @@ static void commit_planes_for_stream(struct dc *dc,
 				continue;
 
 			/* work around to program degamma regs for split pipe after set mode. */
-			if (srf_updates[i].in_transfer_func || (pipe_ctx->top_pipe &&
-					pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state))
-				dc->hwss.set_input_transfer_func(
-						pipe_ctx, pipe_ctx->plane_state);
+			if (srf_updates[i].in_transfer_func ||
+			    (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state))
+				dc->hwss.set_input_transfer_func(pipe_ctx, pipe_ctx->plane_state);
 		}
 	}
 

commit e6c258cb4e6fbc7500c493df22f52e1046c575b0
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Oct 30 17:32:14 2017 -0400

    drm/amd/display: Refactor disable front end pipes.
    
    There are different code to disable front end, it is
    difficult to debug and adding new process.
    This refactor makes all disable front end call the same
    functions.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f3496881caf4..39431bd8d77e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -963,9 +963,11 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	post_surface_trace(dc);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++)
-		if (context->res_ctx.pipe_ctx[i].stream == NULL
-				|| context->res_ctx.pipe_ctx[i].plane_state == NULL)
-			dc->hwss.power_down_front_end(dc, i);
+		if (context->res_ctx.pipe_ctx[i].stream == NULL ||
+		    context->res_ctx.pipe_ctx[i].plane_state == NULL) {
+			context->res_ctx.pipe_ctx[i].pipe_idx = i;
+			dc->hwss.power_down_front_end(dc, &context->res_ctx.pipe_ctx[i]);
+		}
 
 	/* 3rd param should be true, temp w/a for RV*/
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -1339,8 +1341,11 @@ static void commit_planes_for_stream(struct dc *dc,
 		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
 			continue;
 
-		if (!pipe_ctx->top_pipe && pipe_ctx->stream) {
-			struct dc_stream_status *stream_status = stream_get_status(context, pipe_ctx->stream);
+		if (!pipe_ctx->top_pipe &&
+		    pipe_ctx->stream &&
+		    pipe_ctx->stream == stream) {
+			struct dc_stream_status *stream_status =
+					stream_get_status(context, pipe_ctx->stream);
 
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);

commit 83c3e57bc4703c5955da9942d7e57bc26465c770
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Oct 30 15:53:40 2017 -0400

    drm/amd/display: Both timing_sync and multisync need stream_count > 1
    
    Previous code threw a warning about misleading indentation
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 01ec1edd1c69..f3496881caf4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -913,9 +913,10 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	}
 	result = dc->hwss.apply_ctx_to_hw(dc, context);
 
-	if (context->stream_count > 1)
+	if (context->stream_count > 1) {
 		enable_timing_multisync(dc, context);
 		program_timing_sync(dc, context);
+	}
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 

commit c2a5b5008a92efdf816cf3c3b9f37aa8d6f8b54e
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Oct 25 20:30:46 2017 -0400

    drm/amd/display: Do post_update_surfaces on new state
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 507b1171d65f..01ec1edd1c69 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1469,10 +1469,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 				stream_update,
 				update_type,
 				context);
-
-	if (update_type >= UPDATE_TYPE_FULL)
-		dc_post_update_surfaces_to_stream(dc);
-
+	/*update current_State*/
 	if (dc->current_state != context) {
 
 		struct dc_state *old = dc->current_state;
@@ -1481,6 +1478,9 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		dc_release_state(old);
 
 	}
+	/*let's use current_state to update watermark etc*/
+	if (update_type >= UPDATE_TYPE_FULL)
+		dc_post_update_surfaces_to_stream(dc);
 
 	return;
 

commit fa2123dbccdc881fae02aaf8b05758db53d62955
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Oct 17 15:29:22 2017 -0400

    drm/amd/display: Multi display synchronization logic
    
    This feature synchronizes multiple displays with various timings
    to a display with the highest refresh rate
    it is enabled if edid caps flag multi_display_sync is set to one
    
    There are limitations on refresh rates allowed
    that can be synchronized. That would
    prevent from underflow and other potential
    corruptions.
    
    Multi display synchronization is using the
    same functions as timing_sync in order to minimize
    redunduncy and decision to disable synchronization is
    based on trigger parametre set in DM
    
    Feature is developed for DCN1 and DCE11
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 55317c029d44..507b1171d65f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -713,6 +713,28 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
+static void enable_timing_multisync(
+		struct dc *dc,
+		struct dc_state *ctx)
+{
+	int i = 0, multisync_count = 0;
+	int pipe_count = dc->res_pool->pipe_count;
+	struct pipe_ctx *multisync_pipes[MAX_PIPES] = { NULL };
+
+	for (i = 0; i < pipe_count; i++) {
+		if (!ctx->res_ctx.pipe_ctx[i].stream ||
+				!ctx->res_ctx.pipe_ctx[i].stream->triggered_crtc_reset.enabled)
+			continue;
+		multisync_pipes[multisync_count] = &ctx->res_ctx.pipe_ctx[i];
+		multisync_count++;
+	}
+
+	if (multisync_count > 1) {
+		dc->hwss.enable_per_frame_crtc_position_reset(
+			dc, multisync_count, multisync_pipes);
+	}
+}
+
 static void program_timing_sync(
 		struct dc *dc,
 		struct dc_state *ctx)
@@ -891,7 +913,9 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	}
 	result = dc->hwss.apply_ctx_to_hw(dc, context);
 
-	program_timing_sync(dc, context);
+	if (context->stream_count > 1)
+		enable_timing_multisync(dc, context);
+		program_timing_sync(dc, context);
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 

commit 56ef6ed9faf35b9057630dd12aeca134f98214ec
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Oct 23 17:02:02 2017 -0400

    drm/amd/display: Move hdr_metadata from plane to stream
    
    Need to move HDR Metadata from Surface to Stream since there is only one
    infoframe possible per stream.
    
    Also cleaning up some duplicate definitions.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index bc596df85ca9..55317c029d44 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1007,6 +1007,7 @@ bool dc_commit_planes_to_stream(
 		flip_addr[i].address = plane_states[i]->address;
 		flip_addr[i].flip_immediate = plane_states[i]->flip_immediate;
 		plane_info[i].color_space = plane_states[i]->color_space;
+		plane_info[i].input_tf = plane_states[i]->input_tf;
 		plane_info[i].format = plane_states[i]->format;
 		plane_info[i].plane_size = plane_states[i]->plane_size;
 		plane_info[i].rotation = plane_states[i]->rotation;
@@ -1132,12 +1133,12 @@ static enum surface_update_type get_plane_info_update_type(
 
 	/* Full update parameters */
 	temp_plane_info.color_space = u->surface->color_space;
+	temp_plane_info.input_tf = u->surface->input_tf;
 	temp_plane_info.dcc = u->surface->dcc;
 	temp_plane_info.horizontal_mirror = u->surface->horizontal_mirror;
 	temp_plane_info.plane_size = u->surface->plane_size;
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
-	temp_plane_info.input_csc_enabled = u->surface->input_csc_color_matrix.enable_adjustment;
 
 	if (surface_index == 0)
 		temp_plane_info.visible = u->plane_info->visible;
@@ -1218,7 +1219,6 @@ static enum surface_update_type det_surface_update(
 		overall_type = type;
 
 	if (u->in_transfer_func ||
-		u->hdr_static_metadata ||
 		u->input_csc_color_matrix) {
 		if (overall_type < UPDATE_TYPE_MED)
 			overall_type = UPDATE_TYPE_MED;
@@ -1350,14 +1350,25 @@ static void commit_planes_for_stream(struct dc *dc,
 					pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state))
 				dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->plane_state);
+		}
+	}
+
+	if (update_type > UPDATE_TYPE_FAST) {
+		for (j = 0; j < dc->res_pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx =
+					&context->res_ctx.pipe_ctx[j];
+
+			if (!pipe_ctx->stream)
+				continue;
 
 			if (stream_update != NULL &&
-					stream_update->out_transfer_func != NULL) {
+				stream_update->out_transfer_func != NULL) {
 				dc->hwss.set_output_transfer_func(
 						pipe_ctx, pipe_ctx->stream);
 			}
 
-			if (srf_updates[i].hdr_static_metadata) {
+			if (stream_update != NULL &&
+				stream_update->hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);
 				dc->hwss.update_info_frame(pipe_ctx);
 			}

commit de4a2967737114d426411a79781d9d81d0ff38d2
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Thu Oct 19 13:41:30 2017 -0400

    drm/amd/display: Apply VQ adjustments in MPO case
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c874dfd099d3..bc596df85ca9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1137,6 +1137,7 @@ static enum surface_update_type get_plane_info_update_type(
 	temp_plane_info.plane_size = u->surface->plane_size;
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
+	temp_plane_info.input_csc_enabled = u->surface->input_csc_color_matrix.enable_adjustment;
 
 	if (surface_index == 0)
 		temp_plane_info.visible = u->plane_info->visible;
@@ -1217,7 +1218,8 @@ static enum surface_update_type det_surface_update(
 		overall_type = type;
 
 	if (u->in_transfer_func ||
-		u->hdr_static_metadata) {
+		u->hdr_static_metadata ||
+		u->input_csc_color_matrix) {
 		if (overall_type < UPDATE_TYPE_MED)
 			overall_type = UPDATE_TYPE_MED;
 	}

commit 74707de3365a0ab1244e0253842e5b10d32c4a01
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 17 14:24:28 2017 -0400

    drm/amd/display: Not reset front end when program back end.
    
    Since front end is programmed before back end programming,
    no need to reset front end in back end programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9925d0e01c04..c874dfd099d3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -850,6 +850,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
+
+
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
@@ -928,7 +930,6 @@ bool dc_commit_state(struct dc *dc, struct dc_state *context)
 	return (result == DC_OK);
 }
 
-
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;

commit 3dc780ec3473200ef870eae9b19169445d76be4c
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 17 14:48:11 2017 -0400

    drm/amd/display: Move lock to front end program.
    
    Moved lock and unlock to apply_ctx_to_surface, since all
    the front end programming is within apply_ctx_to_surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e8894ad3adf4..9925d0e01c04 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -839,7 +839,7 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
-	int i, j, k, l;
+	int i, k, l;
 	struct dc_stream_state *dc_streams[MAX_STREAMS] = {0};
 
 	disable_dangling_plane(dc, context);
@@ -893,15 +893,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	for (i = 0; i < context->stream_count; i++) {
-		for (j = 0; j < MAX_PIPES; j++) {
-			pipe = &context->res_ctx.pipe_ctx[j];
-
-			if (!pipe->top_pipe && pipe->stream == context->streams[i])
-				dc->hwss.pipe_control_lock(dc, pipe, false);
-		}
-	}
-
 	dc_release_state(dc->current_state);
 
 	dc->current_state = context;
@@ -1313,27 +1304,6 @@ static void commit_planes_for_stream(struct dc *dc,
 		return;
 	}
 
-	/* Lock pipes for provided surfaces, or all active if full update*/
-	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *plane_state = srf_updates[i].surface;
-
-		for (j = 0; j < dc->res_pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-
-			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->plane_state != plane_state)
-				continue;
-			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
-				continue;
-
-			dc->hwss.pipe_control_lock(
-					dc,
-					pipe_ctx,
-					true);
-		}
-		if (update_type == UPDATE_TYPE_FULL)
-			break;
-	}
-
 	/* Full fe update*/
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1390,26 +1360,6 @@ static void commit_planes_for_stream(struct dc *dc,
 			}
 		}
 	}
-
-	/* Unlock pipes */
-	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
-		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
-
-		for (j = 0; j < surface_count; j++) {
-			if (update_type != UPDATE_TYPE_FULL &&
-			    srf_updates[j].surface != pipe_ctx->plane_state)
-				continue;
-			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
-				continue;
-
-			dc->hwss.pipe_control_lock(
-					dc,
-					pipe_ctx,
-					false);
-
-			break;
-		}
-	}
 }
 
 void dc_commit_updates_for_stream(struct dc *dc,

commit 553aae12e3ad4d4d9cb9accb129a8c818bce506b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Oct 16 10:43:59 2017 -0400

    drm/amd/display: Add APU cap in dc_caps
    
    Some features should only be enabled on APUs or should not
    be enabled on APUs.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7240db2e6f09..e8894ad3adf4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -558,6 +558,7 @@ static bool construct(struct dc *dc,
 
 	dc_version = resource_parse_asic_id(init_params->asic_id);
 	dc->ctx->dce_version = dc_version;
+
 #if defined(CONFIG_DRM_AMD_DC_FBC)
 	dc->ctx->fbc_gpu_addr = init_params->fbc_gpu_addr;
 #endif

commit edf38b58ecd847df75723fb90d4a1c3669b1e670
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 20:11:37 2017 -0500

    drm/amd/display: Fix potential NULL and mem leak in create_links
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:148 create_links()
    error: potential null dereference 'link->link_enc'.  (kzalloc returns
    null)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 15625fd94455..7240db2e6f09 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -121,6 +121,10 @@ static bool create_links(
 			goto failed_alloc;
 		}
 
+		link->link_index = dc->link_count;
+		dc->links[dc->link_count] = link;
+		dc->link_count++;
+
 		link->ctx = dc->ctx;
 		link->dc = dc;
 		link->connector_signal = SIGNAL_TYPE_VIRTUAL;
@@ -128,6 +132,12 @@ static bool create_links(
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
 		link->link_enc = kzalloc(sizeof(*link->link_enc), GFP_KERNEL);
+
+		if (!link->link_enc) {
+			BREAK_TO_DEBUGGER();
+			goto failed_alloc;
+		}
+
 		link->link_status.dpcd_caps = &link->dpcd_caps;
 
 		enc_init.ctx = dc->ctx;
@@ -139,10 +149,6 @@ static bool create_links(
 		enc_init.encoder.id = ENCODER_ID_INTERNAL_VIRTUAL;
 		enc_init.encoder.enum_id = ENUM_ID_1;
 		virtual_link_encoder_construct(link->link_enc, &enc_init);
-
-		link->link_index = dc->link_count;
-		dc->links[dc->link_count] = link;
-		dc->link_count++;
 	}
 
 	return true;

commit 6bffebc90c23e2341a1f8371e7b496ec94136e47
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Wed Oct 18 20:22:40 2017 -0400

    drm/amd/display: Add timing validation against dongle cap
    
    For DP active dongles, the dpcd dongle caps are read but not
    used to validate mode timing. This addresses this.
    
    In particular, this change fixes light up on the HDMI 4k TV
    connected through DP active dongle. Since the 4k TV defaults
    to YCbCr420, which the dongle don't support.
    
    This change does not address MST cases, a more generalized
    approach must be taken for that.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index fe63f5894d43..15625fd94455 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -128,6 +128,7 @@ static bool create_links(
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
 		link->link_enc = kzalloc(sizeof(*link->link_enc), GFP_KERNEL);
+		link->link_status.dpcd_caps = &link->dpcd_caps;
 
 		enc_init.ctx = dc->ctx;
 		enc_init.channel = CHANNEL_ID_UNKNOWN;

commit 524bed9a2b9f7d7f9aa5f62547b1faec2f9bab35
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Nov 7 13:21:02 2017 -0500

    drm/amd/display: Remove dangling planes on dc commit state
    
    When disabling pipe splitting, we need to make sure we disable both
    planes used.
    
    This should be done for Linux as well.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 566ca82b5241..fe63f5894d43 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -619,6 +619,39 @@ static bool construct(struct dc *dc,
 	return false;
 }
 
+static void disable_dangling_plane(struct dc *dc, struct dc_state *context)
+{
+	int i, j;
+	struct dc_state *dangling_context = dc_create_state();
+	struct dc_state *current_ctx;
+
+	if (dangling_context == NULL)
+		return;
+
+	dc_resource_state_copy_construct(dc->current_state, dangling_context);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct dc_stream_state *old_stream =
+				dc->current_state->res_ctx.pipe_ctx[i].stream;
+		bool should_disable = true;
+
+		for (j = 0; j < context->stream_count; j++) {
+			if (old_stream == context->streams[j]) {
+				should_disable = false;
+				break;
+			}
+		}
+		if (should_disable && old_stream) {
+			dc_rem_all_planes_for_stream(dc, old_stream, dangling_context);
+			dc->hwss.apply_ctx_for_surface(dc, old_stream, 0, dangling_context);
+		}
+	}
+
+	current_ctx = dc->current_state;
+	dc->current_state = dangling_context;
+	dc_release_state(current_ctx);
+}
+
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
@@ -801,6 +834,8 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 	int i, j, k, l;
 	struct dc_stream_state *dc_streams[MAX_STREAMS] = {0};
 
+	disable_dangling_plane(dc, context);
+
 	for (i = 0; i < context->stream_count; i++)
 		dc_streams[i] =  context->streams[i];
 
@@ -830,8 +865,6 @@ static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *c
 			}
 		}
 
-
-
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
 				context->streams[i]->timing.h_addressable,
 				context->streams[i]->timing.v_addressable,

commit 3f0260f6fb86cdb35bf8e6974d50453e7b7f8e40
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Oct 31 14:39:36 2017 -0400

    drm/amd/display: add flip_immediate to commit update for stream
    
    This struct is not updated on page flip and causes vblank_mode
    to not work as expected
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Tested-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ce3c57b38bc0..566ca82b5241 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1414,8 +1414,11 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		/* TODO: On flip we don't build the state, so it still has the
 		 * old address. Which is why we are updating the address here
 		 */
-		if (srf_updates[i].flip_addr)
+		if (srf_updates[i].flip_addr) {
 			surface->address = srf_updates[i].flip_addr->address;
+			surface->flip_immediate = srf_updates[i].flip_addr->flip_immediate;
+
+		}
 
 		if (update_type >= UPDATE_TYPE_MED) {
 			for (j = 0; j < dc->res_pool->pipe_count; j++) {

commit f7dbc385c15084d6e11192e8a5dd901eb96dbec2
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 7 05:21:18 2017 +1000

    amdgpu/dc: handle allocation failures in dc_commit_planes_to_stream.
    
    Reported-by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:966 dc_commit_planes_to_stream() error: potential null dereference 'flip_addr'.  (kcalloc returns null)
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:968 dc_commit_planes_to_stream() error: potential null dereference 'plane_info'.  (kcalloc returns null)
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:978 dc_commit_planes_to_stream() error: potential null dereference 'scaling_info'.  (kcalloc returns null)
    
    Reviewed-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a71392ffc46d..ce3c57b38bc0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -952,6 +952,14 @@ bool dc_commit_planes_to_stream(
 	scaling_info = kcalloc(MAX_SURFACES, sizeof(struct dc_scaling_info),
 			       GFP_KERNEL);
 
+	if (!flip_addr || !plane_info || !scaling_info) {
+		kfree(flip_addr);
+		kfree(plane_info);
+		kfree(scaling_info);
+		kfree(stream_update);
+		return false;
+	}
+
 	memset(updates, 0, sizeof(updates));
 
 	stream_update->src = dc_stream->src;

commit 565f26a39d8e49745fda00d2303138aea831fd29
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Oct 16 20:10:00 2017 -0400

    drm/amd/display: Small comment on dc_commit_planes_to_stream
    
    Having one struct on the stack was somewhat confusing. Also mention
    that the whole function should eventually go.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7a0593d4ca62..a71392ffc46d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -918,6 +918,12 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	return true;
 }
 
+/*
+ * TODO this whole function needs to go
+ *
+ * dc_surface_update is needlessly complex. See if we can just replace this
+ * with a dc_plane_state and follow the atomic model a bit more closely here.
+ */
 bool dc_commit_planes_to_stream(
 		struct dc *dc,
 		struct dc_plane_state **plane_states,
@@ -925,6 +931,7 @@ bool dc_commit_planes_to_stream(
 		struct dc_stream_state *dc_stream,
 		struct dc_state *state)
 {
+	/* no need to dynamically allocate this. it's pretty small */
 	struct dc_surface_update updates[MAX_SURFACES];
 	struct dc_flip_addrs *flip_addr;
 	struct dc_plane_info *plane_info;

commit bb16bee4b394bafd6168c7719b7b07e19d1f0ce1
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Oct 12 14:15:26 2017 -0400

    drm/amd/display: Reduce stack size of commit_planes_to_stream
    
    This function likes to blow 1024 stack size when something is
    added to the addr struct. For now just dynamically allocate.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ff6bd384aece..7a0593d4ca62 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -926,9 +926,9 @@ bool dc_commit_planes_to_stream(
 		struct dc_state *state)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
-	struct dc_flip_addrs flip_addr[MAX_SURFACES];
-	struct dc_plane_info plane_info[MAX_SURFACES];
-	struct dc_scaling_info scaling_info[MAX_SURFACES];
+	struct dc_flip_addrs *flip_addr;
+	struct dc_plane_info *plane_info;
+	struct dc_scaling_info *scaling_info;
 	int i;
 	struct dc_stream_update *stream_update =
 			kzalloc(sizeof(struct dc_stream_update), GFP_KERNEL);
@@ -938,10 +938,14 @@ bool dc_commit_planes_to_stream(
 		return false;
 	}
 
+	flip_addr = kcalloc(MAX_SURFACES, sizeof(struct dc_flip_addrs),
+			    GFP_KERNEL);
+	plane_info = kcalloc(MAX_SURFACES, sizeof(struct dc_plane_info),
+			     GFP_KERNEL);
+	scaling_info = kcalloc(MAX_SURFACES, sizeof(struct dc_scaling_info),
+			       GFP_KERNEL);
+
 	memset(updates, 0, sizeof(updates));
-	memset(flip_addr, 0, sizeof(flip_addr));
-	memset(plane_info, 0, sizeof(plane_info));
-	memset(scaling_info, 0, sizeof(scaling_info));
 
 	stream_update->src = dc_stream->src;
 	stream_update->dst = dc_stream->dst;
@@ -980,6 +984,9 @@ bool dc_commit_planes_to_stream(
 			new_plane_count,
 			dc_stream, stream_update, plane_states, state);
 
+	kfree(flip_addr);
+	kfree(plane_info);
+	kfree(scaling_info);
 	kfree(stream_update);
 	return true;
 }

commit 62c933f9c6bf287b5b911a1eb838bc942eaa7202
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 10 14:01:33 2017 -0400

    drm/amd/display: WA for 3 display play video hot plug.
    
            Three monitor connected and playing a video will
            occupy all 4 pipes, if hot plug forth display,
            commit streams will be failed due to no free pipe
            can be found.
            Work around:
            When forth monitor connected, mark video plane as
            a fake plane, remove it in dc, keep it in dm and
            report address to OS, until OS turn off MPO.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9d750fa29a87..ff6bd384aece 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -793,7 +793,7 @@ bool dc_enable_stereo(
  * Applies given context to HW and copy it into current context.
  * It's up to the user to release the src context afterwards.
  */
-static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
+static enum dc_status dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 {
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -869,7 +869,7 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 
 	dc->hwss.optimize_shared_resources(dc);
 
-	return (result == DC_OK);
+	return result;
 }
 
 bool dc_commit_state(struct dc *dc, struct dc_state *context)

commit 3df8fcafb7edab79d76c4c76c93446b91eb4916f
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Wed Oct 4 12:47:13 2017 -0400

    drm/amd/display: Do not set bandwidth on page flips.
    
    Which removes a lockdep warning for a possible deadlock situation:
    
    While holding the drm event mutex (hard irq safe),
    dc_post_update_surfaces_to_stream eventually acquires the atom context
    lock, which is hard irq unsafe. We should only be calling it on full
    updates anyways.
    
    Also remove a redundant call to dc_post_update_surfaces_to_stream,
    dc_commit_updates_for_stream already calls it.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 80ddccc2570a..9d750fa29a87 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -980,8 +980,6 @@ bool dc_commit_planes_to_stream(
 			new_plane_count,
 			dc_stream, stream_update, plane_states, state);
 
-	dc_post_update_surfaces_to_stream(dc);
-
 	kfree(stream_update);
 	return true;
 }
@@ -1418,7 +1416,8 @@ void dc_commit_updates_for_stream(struct dc *dc,
 				update_type,
 				context);
 
-	dc_post_update_surfaces_to_stream(dc);
+	if (update_type >= UPDATE_TYPE_FULL)
+		dc_post_update_surfaces_to_stream(dc);
 
 	if (dc->current_state != context) {
 

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 12aeb6d83f42..80ddccc2570a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -38,6 +38,7 @@
 #include "bios_parser_interface.h"
 #include "include/irq_service_interface.h"
 #include "transform.h"
+#include "dpp.h"
 #include "timing_generator.h"
 #include "virtual/virtual_link_encoder.h"
 

commit 80e80ec817f161560b4159608fb41bd289abede3
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Oct 3 13:53:51 2017 -0400

    drm/amd/display: Fix underscan not using proper scaling
    
    fix underscan not being set correctly
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4df5bf750257..12aeb6d83f42 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1362,7 +1362,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 	enum surface_update_type update_type;
 	struct dc_state *context;
 	struct dc_context *dc_ctx = dc->ctx;
-	int i;
+	int i, j;
 
 	stream_status = dc_stream_get_status(stream);
 	context = dc->current_state;
@@ -1396,8 +1396,17 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		if (srf_updates[i].flip_addr)
 			surface->address = srf_updates[i].flip_addr->address;
 
-	}
+		if (update_type >= UPDATE_TYPE_MED) {
+			for (j = 0; j < dc->res_pool->pipe_count; j++) {
+				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+				if (pipe_ctx->plane_state != surface)
+					continue;
 
+				resource_build_scaling_params(pipe_ctx);
+			}
+		}
+	}
 
 	commit_planes_for_stream(
 				dc,

commit 8feabd03d34e4555c119e69269dae28f52e0d86c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 2 14:39:42 2017 -0400

    drm/amd/display: rename struct mem_input to hubp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index fe66c6a21bc3..4df5bf750257 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -47,6 +47,7 @@
 #include "dc_link_ddc.h"
 #include "dm_helpers.h"
 #include "mem_input.h"
+#include "hubp.h"
 
 
 /*******************************************************************************

commit 8459f633b65a81979b9b233ed0a91a9fdc98b7bd
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Tue Oct 3 18:15:51 2017 -0400

    drm/amd/display: Handle case when stream not found in set_dpms
    
    When validate with context fail to add stream to the context, we have
    a case where set_dpms won't be able to find the stream that need to
    be disabled.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4cdb855ef855..fe66c6a21bc3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -363,7 +363,7 @@ void set_dpms(
 	struct dc_stream_state *stream,
 	bool dpms_off)
 {
-	struct pipe_ctx *pipe_ctx;
+	struct pipe_ctx *pipe_ctx = NULL;
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -373,6 +373,11 @@ void set_dpms(
 		}
 	}
 
+	if (!pipe_ctx) {
+		ASSERT(0);
+		return;
+	}
+
 	if (stream->dpms_off != dpms_off) {
 		stream->dpms_off = dpms_off;
 		if (dpms_off)

commit c196cbe065da1c9b5f7683af9cdd0889760151c1
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Oct 3 16:47:02 2017 -0400

    drm/amd/display: add dpms state to DC follow up
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 92fab09843e4..4cdb855ef855 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -332,7 +332,7 @@ static void set_dither_option(struct dc_stream_state *stream,
 {
 	struct bit_depth_reduction_params params;
 	struct dc_link *link = stream->status.link;
-	struct pipe_ctx *pipes;
+	struct pipe_ctx *pipes = NULL;
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -344,7 +344,7 @@ static void set_dither_option(struct dc_stream_state *stream,
 	}
 
 	memset(&params, 0, sizeof(params));
-	if (!stream)
+	if (!pipes)
 		return;
 	if (option > DITHER_OPTION_MAX)
 		return;

commit 067c878a220cbe6198b3cfdc7f372adab4762ad8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 3 15:03:49 2017 -0400

    drm/amd/display: Fixed switching mode half screen gamma incorrect.
    
            Half screen gamma setting and cursor are incorrect
            when switching mode through win+p due to wrong programming
            gamma sequence (In case of bottom pipe, gamma and cursor are
            programmed before front end programmed, pipe is power gated).
    
            change:
            1. Cache curor attributes to stream
            2. Move set gamma and cursor inside front end
               programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d963de753e63..92fab09843e4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1269,10 +1269,6 @@ static void commit_planes_for_stream(struct dc *dc,
 	/* Full fe update*/
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[j];
-		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
-		struct dc_cursor_position position = { 0 };
-
 
 		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
 			continue;
@@ -1283,17 +1279,6 @@ static void commit_planes_for_stream(struct dc *dc,
 			dc->hwss.apply_ctx_for_surface(
 					dc, pipe_ctx->stream, stream_status->plane_count, context);
 		}
-
-		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
-
-		if (is_new_pipe_surface) {
-			dc->hwss.update_plane_addr(dc, pipe_ctx);
-			dc->hwss.set_input_transfer_func(
-					pipe_ctx, pipe_ctx->plane_state);
-			dc->hwss.set_output_transfer_func(
-					pipe_ctx, pipe_ctx->stream);
-		}
 	}
 
 	if (update_type > UPDATE_TYPE_FAST)

commit d050f8ed14494ea23c6e10b5893010946ef0f78b
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Fri Sep 29 16:36:34 2017 -0400

    drm/amd/display: add dpms state to DC
    
    - avoid eDP screen flash 4 times when resume from s3
    - improve s3 and boot time
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 09bab93815a3..d963de753e63 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -332,7 +332,16 @@ static void set_dither_option(struct dc_stream_state *stream,
 {
 	struct bit_depth_reduction_params params;
 	struct dc_link *link = stream->status.link;
-	struct pipe_ctx *pipes = link->dc->current_state->res_ctx.pipe_ctx;
+	struct pipe_ctx *pipes;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (link->dc->current_state->res_ctx.pipe_ctx[i].stream ==
+				stream) {
+			pipes = &link->dc->current_state->res_ctx.pipe_ctx[i];
+			break;
+		}
+	}
 
 	memset(&params, 0, sizeof(params));
 	if (!stream)
@@ -349,6 +358,31 @@ static void set_dither_option(struct dc_stream_state *stream,
 		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }
 
+void set_dpms(
+	struct dc *dc,
+	struct dc_stream_state *stream,
+	bool dpms_off)
+{
+	struct pipe_ctx *pipe_ctx;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {
+			pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+			break;
+		}
+	}
+
+	if (stream->dpms_off != dpms_off) {
+		stream->dpms_off = dpms_off;
+		if (dpms_off)
+			core_link_disable_stream(pipe_ctx,
+					KEEP_ACQUIRED_RESOURCE);
+		else
+			core_link_enable_stream(dc->current_state, pipe_ctx);
+	}
+}
+
 static void allocate_dc_stream_funcs(struct dc  *dc)
 {
 	if (dc->hwss.set_drr != NULL) {
@@ -371,6 +405,9 @@ static void allocate_dc_stream_funcs(struct dc  *dc)
 	dc->stream_funcs.set_dither_option =
 			set_dither_option;
 
+	dc->stream_funcs.set_dpms =
+			set_dpms;
+
 	dc->link_funcs.set_drive_settings =
 			set_drive_settings;
 

commit 309c42efdab945071c693a51334fbaeb0a700b0d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Oct 2 17:08:24 2017 -0400

    drm/amd/display: wa to program split pipedegamma regs after mode set.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 33a63c7d7a8e..09bab93815a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1282,7 +1282,9 @@ static void commit_planes_for_stream(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-			if (srf_updates[i].in_transfer_func)
+			/* work around to program degamma regs for split pipe after set mode. */
+			if (srf_updates[i].in_transfer_func || (pipe_ctx->top_pipe &&
+					pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state))
 				dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->plane_state);
 

commit 13ab1b44151195823fa0e2ceace1cf4687266dba
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Sep 28 17:18:27 2017 -0400

    drm/amd/display: Fixed extend to second screen mode hang
    
            1. Fixed acquire free split pipe bug.
            2. Change return value for dc_add_stream_to_ctx
               from bool to enum.
            4. Remove redundant apply_ctx_for_surface calling
            5. Unlock pipe after back end programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f9bac11d3950..33a63c7d7a8e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -766,34 +766,27 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
-		for (j = 0; j < context->stream_status[i].plane_count; j++) {
-			dc->hwss.apply_ctx_for_surface(
-					dc, context->streams[i],
-					context->stream_status[i].plane_count,
-					context);
+		dc->hwss.apply_ctx_for_surface(
+				dc, context->streams[i],
+				context->stream_status[i].plane_count,
+				context);
 
-			/*
-			 * enable stereo
-			 * TODO rework dc_enable_stereo call to work with validation sets?
-			 */
-			for (k = 0; k < MAX_PIPES; k++) {
-				pipe = &context->res_ctx.pipe_ctx[k];
-
-				for (l = 0 ; pipe && l < context->stream_count; l++)  {
-					if (context->streams[l] &&
-					    context->streams[l] == pipe->stream &&
-					    dc->hwss.setup_stereo)
-						dc->hwss.setup_stereo(pipe, dc);
-				}
+		/*
+		 * enable stereo
+		 * TODO rework dc_enable_stereo call to work with validation sets?
+		 */
+		for (k = 0; k < MAX_PIPES; k++) {
+			pipe = &context->res_ctx.pipe_ctx[k];
+
+			for (l = 0 ; pipe && l < context->stream_count; l++)  {
+				if (context->streams[l] &&
+					context->streams[l] == pipe->stream &&
+					dc->hwss.setup_stereo)
+					dc->hwss.setup_stereo(pipe, dc);
 			}
 		}
 
-		for (j = 0; j < MAX_PIPES; j++) {
-			pipe = &context->res_ctx.pipe_ctx[j];
 
-			if (!pipe->top_pipe && pipe->stream == context->streams[i])
-				dc->hwss.pipe_control_lock(dc, pipe, false);
-		}
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
 				context->streams[i]->timing.h_addressable,
@@ -815,6 +808,15 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
+	for (i = 0; i < context->stream_count; i++) {
+		for (j = 0; j < MAX_PIPES; j++) {
+			pipe = &context->res_ctx.pipe_ctx[j];
+
+			if (!pipe->top_pipe && pipe->stream == context->streams[i])
+				dc->hwss.pipe_control_lock(dc, pipe, false);
+		}
+	}
+
 	dc_release_state(dc->current_state);
 
 	dc->current_state = context;

commit 50d4cfdc118122f58ffdb09607a57c621e24d777
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Sep 28 10:40:10 2017 -0400

    drm/amd/display: Program front end first when set mode.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a5c72dbc2dcc..f9bac11d3950 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -763,16 +763,6 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
-	dc->hwss.ready_shared_resources(dc, context);
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		pipe = &context->res_ctx.pipe_ctx[i];
-		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
-	}
-	result = dc->hwss.apply_ctx_to_hw(dc, context);
-
-	program_timing_sync(dc, context);
-
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
@@ -798,6 +788,13 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 			}
 		}
 
+		for (j = 0; j < MAX_PIPES; j++) {
+			pipe = &context->res_ctx.pipe_ctx[j];
+
+			if (!pipe->top_pipe && pipe->stream == context->streams[i])
+				dc->hwss.pipe_control_lock(dc, pipe, false);
+		}
+
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
 				context->streams[i]->timing.h_addressable,
 				context->streams[i]->timing.v_addressable,
@@ -806,6 +803,16 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 				context->streams[i]->timing.pix_clk_khz);
 	}
 
+	dc->hwss.ready_shared_resources(dc, context);
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		pipe = &context->res_ctx.pipe_ctx[i];
+		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
+	}
+	result = dc->hwss.apply_ctx_to_hw(dc, context);
+
+	program_timing_sync(dc, context);
+
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
 	dc_release_state(dc->current_state);

commit 3eab79163fcb0f7777440dfe360d2eedbbcc47b9
Author: Shirish S <shirish.s@amd.com>
Date:   Tue Sep 26 15:35:42 2017 +0530

    drm/amd/display: make FBC configurable option
    
    Currently FBC is guarded with ENABLE_FBC macro,
    which needs to be manually enabled in Makefile.
    
    This patch moves it to Kconfig so that there
    wont be any need to additional patch to be carried
    for enabling or disabling on every SoC.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3439bc46a4a2..a5c72dbc2dcc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -507,7 +507,7 @@ static bool construct(struct dc *dc,
 
 	dc_version = resource_parse_asic_id(init_params->asic_id);
 	dc->ctx->dce_version = dc_version;
-#ifdef ENABLE_FBC
+#if defined(CONFIG_DRM_AMD_DC_FBC)
 	dc->ctx->fbc_gpu_addr = init_params->fbc_gpu_addr;
 #endif
 	/* Resource should construct all asic specific resources.

commit 60d671db1c0c02f31bcff3ea5dee244d26b8ed77
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Mon Sep 25 16:39:45 2017 -0400

    drm/amd/display: Fix ref_count messed up issue
    
    In the full update type, need to add ref_count to the newly
    created dc_state->stream. It made mistake to add ref_count to
    dc->current_state->stream which keeps adding up without release.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ffc36f5ac50c..3439bc46a4a2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1322,6 +1322,7 @@ void dc_commit_updates_for_stream(struct dc *dc,
 	const struct dc_stream_status *stream_status;
 	enum surface_update_type update_type;
 	struct dc_state *context;
+	struct dc_context *dc_ctx = dc->ctx;
 	int i;
 
 	stream_status = dc_stream_get_status(stream);
@@ -1334,8 +1335,17 @@ void dc_commit_updates_for_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 
-	if (update_type >= UPDATE_TYPE_FULL)
+	if (update_type >= UPDATE_TYPE_FULL) {
+
+		/* initialize scratch memory for building context */
+		context = dc_create_state();
+		if (context == NULL) {
+			DC_ERROR("Failed to allocate new validate context!\n");
+			return;
+		}
+
 		dc_resource_state_copy_construct(state, context);
+	}
 
 
 	for (i = 0; i < surface_count; i++) {
@@ -1361,6 +1371,15 @@ void dc_commit_updates_for_stream(struct dc *dc,
 
 	dc_post_update_surfaces_to_stream(dc);
 
+	if (dc->current_state != context) {
+
+		struct dc_state *old = dc->current_state;
+
+		dc->current_state = context;
+		dc_release_state(old);
+
+	}
+
 	return;
 
 }

commit 671a6246e0d3652c024f99d5641c7cf427b0b5a5
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Sep 22 13:41:13 2017 -0400

    drm/amd/display: Early return when turn off a plane.
    
    In case of two monitor connected and turn off one of the monitors,
    OTG0 is locked after graphic plane off due to redundant programming
    front end regs.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2cea8de9c9be..ffc36f5ac50c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1190,8 +1190,14 @@ static void commit_planes_for_stream(struct dc *dc,
 		}
 	}
 
-	if (surface_count == 0)
+	if (surface_count == 0) {
+		/*
+		 * In case of turning off screen, no need to program front end a second time.
+		 * just return after program front end.
+		 */
 		dc->hwss.apply_ctx_for_surface(dc, stream, surface_count, context);
+		return;
+	}
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {

commit 4b7e7e2b1bb2c7308ee3ccbef3f67cb9ce52e954
Author: ShihChen Chen <ShihChen.Chen@amd.com>
Date:   Tue Sep 12 11:10:12 2017 +0800

    drm/amd/display: make tile changing run at ISR
    
    Signed-off-by: ShihChen Chen <ShihChen.Chen@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1ec6df9870da..2cea8de9c9be 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1031,7 +1031,6 @@ static enum surface_update_type get_plane_info_update_type(
 	temp_plane_info.plane_size = u->surface->plane_size;
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
-	temp_plane_info.tiling_info = u->surface->tiling_info;
 
 	if (surface_index == 0)
 		temp_plane_info.visible = u->plane_info->visible;
@@ -1044,10 +1043,26 @@ static enum surface_update_type get_plane_info_update_type(
 
 	if (pixel_format_to_bpp(u->plane_info->format) !=
 			pixel_format_to_bpp(u->surface->format)) {
+		/* different bytes per element will require full bandwidth
+		 * and DML calculation
+		 */
 		return UPDATE_TYPE_FULL;
-	} else {
-		return UPDATE_TYPE_MED;
 	}
+
+	if (memcmp(&u->plane_info->tiling_info, &u->surface->tiling_info,
+			sizeof(union dc_tiling_info)) != 0) {
+		/* todo: below are HW dependent, we should add a hook to
+		 * DCE/N resource and validated there.
+		 */
+		if (u->plane_info->tiling_info.gfx9.swizzle != DC_SW_LINEAR) {
+			/* swizzled mode requires RQ to be setup properly,
+			 * thus need to run DML to calculate RQ settings
+			 */
+			return UPDATE_TYPE_FULL;
+		}
+	}
+
+	return UPDATE_TYPE_MED;
 }
 
 static enum surface_update_type  get_scaling_info_update_type(

commit bc6828e0e6b6c5bcafbb093f9fe475f63dbe47e5
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Sep 12 13:56:57 2017 -0400

    drm/amd/display: Refactor dc_update_planes_and_stream.
    
    Split update_planes_and_stream_state (split Software and Hardware
    programming) as the state is already build, so we only need to
    program the hardware
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 47f16a4b9f27..1ec6df9870da 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -869,7 +869,8 @@ bool dc_commit_planes_to_stream(
 		struct dc *dc,
 		struct dc_plane_state **plane_states,
 		uint8_t new_plane_count,
-		struct dc_stream_state *dc_stream)
+		struct dc_stream_state *dc_stream,
+		struct dc_state *state)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
 	struct dc_flip_addrs flip_addr[MAX_SURFACES];
@@ -920,11 +921,11 @@ bool dc_commit_planes_to_stream(
 		updates[i].scaling_info = &scaling_info[i];
 	}
 
-	dc_update_planes_and_stream(
+	dc_commit_updates_for_stream(
 			dc,
 			updates,
 			new_plane_count,
-			dc_stream, stream_update);
+			dc_stream, stream_update, plane_states, state);
 
 	dc_post_update_surfaces_to_stream(dc);
 
@@ -1150,192 +1151,20 @@ static struct dc_stream_status *stream_get_status(
 
 static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-void dc_update_planes_and_stream(struct dc *dc,
-		struct dc_surface_update *srf_updates, int surface_count,
+
+static void commit_planes_for_stream(struct dc *dc,
+		struct dc_surface_update *srf_updates,
+		int surface_count,
 		struct dc_stream_state *stream,
-		struct dc_stream_update *stream_update)
+		struct dc_stream_update *stream_update,
+		enum surface_update_type update_type,
+		struct dc_state *context)
 {
-	struct dc_state *context;
 	int i, j;
-	enum surface_update_type update_type;
-	const struct dc_stream_status *stream_status;
-	struct dc_context *dc_ctx = dc->ctx;
-
-	stream_status = dc_stream_get_status(stream);
-
-	ASSERT(stream_status);
-	if (!stream_status)
-		return; /* Cannot commit surface to stream that is not committed */
-
-#ifdef ENABLE_FBC
-	if (srf_updates->flip_addr) {
-		if (srf_updates->flip_addr->address.grph.addr.low_part == 0)
-			ASSERT(0);
-	}
-#endif
-	context = dc->current_state;
-
-	/* update current stream with the new updates */
-	if (stream_update) {
-		if ((stream_update->src.height != 0) &&
-				(stream_update->src.width != 0))
-			stream->src = stream_update->src;
-
-		if ((stream_update->dst.height != 0) &&
-				(stream_update->dst.width != 0))
-			stream->dst = stream_update->dst;
-
-		if (stream_update->out_transfer_func &&
-				stream_update->out_transfer_func !=
-						stream->out_transfer_func) {
-			if (stream->out_transfer_func != NULL)
-				dc_transfer_func_release(stream->out_transfer_func);
-			dc_transfer_func_retain(stream_update->out_transfer_func);
-			stream->out_transfer_func =
-				stream_update->out_transfer_func;
-		}
-	}
-
-	/* do not perform surface update if surface has invalid dimensions
-	 * (all zero) and no scaling_info is provided
-	 */
-	if (surface_count > 0 &&
-			srf_updates->surface->src_rect.width == 0 &&
-			srf_updates->surface->src_rect.height == 0 &&
-			srf_updates->surface->dst_rect.width == 0 &&
-			srf_updates->surface->dst_rect.height == 0 &&
-			!srf_updates->scaling_info) {
-		ASSERT(false);
-		return;
-	}
-
-	update_type = dc_check_update_surfaces_for_stream(
-			dc, srf_updates, surface_count, stream_update, stream_status);
-
-	if (update_type >= update_surface_trace_level)
-		update_surface_trace(dc, srf_updates, surface_count);
-
-	if (update_type >= UPDATE_TYPE_FULL) {
-		struct dc_plane_state *new_planes[MAX_SURFACES] = {0};
-
-		for (i = 0; i < surface_count; i++)
-			new_planes[i] = srf_updates[i].surface;
-
-		/* initialize scratch memory for building context */
-		context = dc_create_state();
-		if (context == NULL) {
-			DC_ERROR("Failed to allocate new validate context!\n");
-			return;
-		}
-
-		dc_resource_state_copy_construct(
-				dc->current_state, context);
-
-		/*remove old surfaces from context */
-		if (!dc_rem_all_planes_for_stream(dc, stream, context)) {
-
-			BREAK_TO_DEBUGGER();
-			goto fail;
-		}
-
-		/* add surface to context */
-		if (!dc_add_all_planes_for_stream(dc, stream, new_planes, surface_count, context)) {
-
-			BREAK_TO_DEBUGGER();
-			goto fail;
-		}
-	}
-
-	/* save update parameters into surface */
-	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
-
-		if (srf_updates[i].flip_addr) {
-			surface->address = srf_updates[i].flip_addr->address;
-			surface->flip_immediate =
-					srf_updates[i].flip_addr->flip_immediate;
-		}
-
-		if (srf_updates[i].scaling_info) {
-			surface->scaling_quality =
-					srf_updates[i].scaling_info->scaling_quality;
-			surface->dst_rect =
-					srf_updates[i].scaling_info->dst_rect;
-			surface->src_rect =
-					srf_updates[i].scaling_info->src_rect;
-			surface->clip_rect =
-					srf_updates[i].scaling_info->clip_rect;
-		}
-
-		if (srf_updates[i].plane_info) {
-			surface->color_space =
-					srf_updates[i].plane_info->color_space;
-			surface->format =
-					srf_updates[i].plane_info->format;
-			surface->plane_size =
-					srf_updates[i].plane_info->plane_size;
-			surface->rotation =
-					srf_updates[i].plane_info->rotation;
-			surface->horizontal_mirror =
-					srf_updates[i].plane_info->horizontal_mirror;
-			surface->stereo_format =
-					srf_updates[i].plane_info->stereo_format;
-			surface->tiling_info =
-					srf_updates[i].plane_info->tiling_info;
-			surface->visible =
-					srf_updates[i].plane_info->visible;
-			surface->per_pixel_alpha =
-					srf_updates[i].plane_info->per_pixel_alpha;
-			surface->dcc =
-					srf_updates[i].plane_info->dcc;
-		}
-
-		if (update_type >= UPDATE_TYPE_MED) {
-			for (j = 0; j < dc->res_pool->pipe_count; j++) {
-				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-
-				if (pipe_ctx->plane_state != surface)
-					continue;
-
-				resource_build_scaling_params(pipe_ctx);
-			}
-		}
-
-		if (srf_updates[i].gamma &&
-			srf_updates[i].gamma != surface->gamma_correction) {
-			if (surface->gamma_correction != NULL)
-				dc_gamma_release(&surface->gamma_correction);
-
-			dc_gamma_retain(srf_updates[i].gamma);
-			surface->gamma_correction = srf_updates[i].gamma;
-		}
-
-		if (srf_updates[i].in_transfer_func &&
-			srf_updates[i].in_transfer_func != surface->in_transfer_func) {
-			if (surface->in_transfer_func != NULL)
-				dc_transfer_func_release(
-						surface->
-						in_transfer_func);
-
-			dc_transfer_func_retain(
-					srf_updates[i].in_transfer_func);
-			surface->in_transfer_func =
-					srf_updates[i].in_transfer_func;
-		}
-
-		if (srf_updates[i].hdr_static_metadata)
-			surface->hdr_static_ctx =
-				*(srf_updates[i].hdr_static_metadata);
-	}
 
 	if (update_type == UPDATE_TYPE_FULL) {
-		if (!dc->res_pool->funcs->validate_bandwidth(dc, context)) {
-			BREAK_TO_DEBUGGER();
-			goto fail;
-		} else {
-			dc->hwss.set_bandwidth(dc, context, false);
-			context_clock_trace(dc, context);
-		}
+		dc->hwss.set_bandwidth(dc, context, false);
+		context_clock_trace(dc, context);
 	}
 
 	if (update_type > UPDATE_TYPE_FAST) {
@@ -1459,27 +1288,60 @@ void dc_update_planes_and_stream(struct dc *dc,
 			break;
 		}
 	}
+}
+
+void dc_commit_updates_for_stream(struct dc *dc,
+		struct dc_surface_update *srf_updates,
+		int surface_count,
+		struct dc_stream_state *stream,
+		struct dc_stream_update *stream_update,
+		struct dc_plane_state **plane_states,
+		struct dc_state *state)
+{
+	const struct dc_stream_status *stream_status;
+	enum surface_update_type update_type;
+	struct dc_state *context;
+	int i;
 
-	if (dc->current_state != context) {
+	stream_status = dc_stream_get_status(stream);
+	context = dc->current_state;
+
+	update_type = dc_check_update_surfaces_for_stream(
+				dc, srf_updates, surface_count, stream_update, stream_status);
+
+	if (update_type >= update_surface_trace_level)
+		update_surface_trace(dc, srf_updates, surface_count);
 
-		/* Since memory free requires elevated IRQL, an interrupt
-		 * request is generated by mem free. If this happens
-		 * between freeing and reassigning the context, our vsync
-		 * interrupt will call into dc and cause a memory
-		 * corruption BSOD. Hence, we first reassign the context,
-		 * then free the old context.
-		 */
 
-		struct dc_state *old = dc->current_state;
+	if (update_type >= UPDATE_TYPE_FULL)
+		dc_resource_state_copy_construct(state, context);
 
-		dc->current_state = context;
-		dc_release_state(old);
+
+	for (i = 0; i < surface_count; i++) {
+		struct dc_plane_state *surface = srf_updates[i].surface;
+
+		/* TODO: On flip we don't build the state, so it still has the
+		 * old address. Which is why we are updating the address here
+		 */
+		if (srf_updates[i].flip_addr)
+			surface->address = srf_updates[i].flip_addr->address;
 
 	}
+
+
+	commit_planes_for_stream(
+				dc,
+				srf_updates,
+				surface_count,
+				stream,
+				stream_update,
+				update_type,
+				context);
+
+	dc_post_update_surfaces_to_stream(dc);
+
 	return;
 
-fail:
-	dc_release_state(context);
 }
 
 uint8_t dc_get_current_stream_count(struct dc *dc)

commit 6bf520280f3621d458e2ef3bd3c48acb89a39af7
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Sep 5 12:20:39 2017 -0400

    drm/amd/display: Driver message to SMU to indicate display off
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f41f15faf019..47f16a4b9f27 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -763,7 +763,7 @@ static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
-	dc->hwss.ready_shared_resources(dc);
+	dc->hwss.ready_shared_resources(dc, context);
 
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		pipe = &context->res_ctx.pipe_ctx[i];

commit 8ee5702afdd48b5864c46418ad310d6a23c8e9ab
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:39:02 2017 +1000

    amdgpu/dc: use kref for dc_state.
    
    I'm not a huge fan of those copying around refcounts bits, might
    want to consider alternates, but this should work for now.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d8820d6f79c6..f41f15faf019 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -940,25 +940,25 @@ struct dc_state *dc_create_state(void)
 	if (!context)
 		return NULL;
 
-	atomic_inc(&context->ref_count);
+	kref_init(&context->refcount);
 	return context;
 }
 
 void dc_retain_state(struct dc_state *context)
 {
-	ASSERT(atomic_read(&context->ref_count) > 0);
-	atomic_inc(&context->ref_count);
+	kref_get(&context->refcount);
 }
 
-void dc_release_state(struct dc_state *context)
+static void dc_state_free(struct kref *kref)
 {
-	ASSERT(atomic_read(&context->ref_count) > 0);
-	atomic_dec(&context->ref_count);
+	struct dc_state *context = container_of(kref, struct dc_state, refcount);
+	dc_resource_state_destruct(context);
+	kfree(context);
+}
 
-	if (atomic_read(&context->ref_count) == 0) {
-		dc_resource_state_destruct(context);
-		kfree(context);
-	}
+void dc_release_state(struct dc_state *context)
+{
+	kref_put(&context->refcount, dc_state_free);
 }
 
 static bool is_surface_in_context(
@@ -1520,7 +1520,7 @@ void dc_set_power_state(
 	struct dc *dc,
 	enum dc_acpi_cm_power_state power_state)
 {
-	atomic_t ref_count;
+	struct kref refcount;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
@@ -1538,12 +1538,12 @@ void dc_set_power_state(
 		 */
 
 		/* Preserve refcount */
-		ref_count = dc->current_state->ref_count;
+		refcount = dc->current_state->refcount;
 		dc_resource_state_destruct(dc->current_state);
 		memset(dc->current_state, 0,
 				sizeof(*dc->current_state));
 
-		dc->current_state->ref_count = ref_count;
+		dc->current_state->refcount = refcount;
 
 		break;
 	}

commit 5d15ae23f8a42ce6728294808b6bd96c6b251a5f
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 15:11:02 2017 +1000

    amdgpu/dc: kill a bunch of dead code.
    
    None of this code is used currently.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2dcff41c9b38..d8820d6f79c6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1559,107 +1559,6 @@ void dc_resume(struct dc *dc)
 		core_link_resume(dc->links[i]);
 }
 
-bool dc_read_aux_dpcd(
-		struct dc *dc,
-		uint32_t link_index,
-		uint32_t address,
-		uint8_t *data,
-		uint32_t size)
-{
-
-	struct dc_link *link = dc->links[link_index];
-	enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->ddc,
-			false,
-			I2C_MOT_UNDEF,
-			address,
-			data,
-			size);
-	return r == DDC_RESULT_SUCESSFULL;
-}
-
-bool dc_write_aux_dpcd(
-		struct dc *dc,
-		uint32_t link_index,
-		uint32_t address,
-		const uint8_t *data,
-		uint32_t size)
-{
-	struct dc_link *link = dc->links[link_index];
-
-	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->ddc,
-			false,
-			I2C_MOT_UNDEF,
-			address,
-			data,
-			size);
-	return r == DDC_RESULT_SUCESSFULL;
-}
-
-bool dc_read_aux_i2c(
-		struct dc *dc,
-		uint32_t link_index,
-		enum i2c_mot_mode mot,
-		uint32_t address,
-		uint8_t *data,
-		uint32_t size)
-{
-
-		struct dc_link *link = dc->links[link_index];
-		enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->ddc,
-			true,
-			mot,
-			address,
-			data,
-			size);
-		return r == DDC_RESULT_SUCESSFULL;
-}
-
-bool dc_write_aux_i2c(
-		struct dc *dc,
-		uint32_t link_index,
-		enum i2c_mot_mode mot,
-		uint32_t address,
-		const uint8_t *data,
-		uint32_t size)
-{
-	struct dc_link *link = dc->links[link_index];
-
-	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->ddc,
-			true,
-			mot,
-			address,
-			data,
-			size);
-	return r == DDC_RESULT_SUCESSFULL;
-}
-
-bool dc_query_ddc_data(
-		struct dc *dc,
-		uint32_t link_index,
-		uint32_t address,
-		uint8_t *write_buf,
-		uint32_t write_size,
-		uint8_t *read_buf,
-		uint32_t read_size) {
-
-
-	struct dc_link *link = dc->links[link_index];
-
-	bool result = dal_ddc_service_query_ddc_data(
-			link->ddc,
-			address,
-			write_buf,
-			write_size,
-			read_buf,
-			read_size);
-
-	return result;
-}
-
 bool dc_submit_i2c(
 		struct dc *dc,
 		uint32_t link_index,

commit 44858055bb28b1ba45dc05acecf9087bc4786701
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 15:11:01 2017 +1000

    amdgpu/dc: set a bunch of functions to static.
    
    All of these are unused outside the file they are in.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1ec8248546c5..2dcff41c9b38 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -327,7 +327,7 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
-void set_dither_option(struct dc_stream_state *stream,
+static void set_dither_option(struct dc_stream_state *stream,
 		enum dc_dither_option option)
 {
 	struct bit_depth_reduction_params params;

commit c6fa531809f08af52406347e5351920cc2d55e42
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 15:11:00 2017 +1000

    amdgpu/dc: kill some deadcode in dc core.
    
    Moves one function to an inline, but kills a bunch of deadcode.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c8235b041b5b..1ec8248546c5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -575,30 +575,6 @@ static bool construct(struct dc *dc,
 	return false;
 }
 
-/*
-void ProgramPixelDurationV(unsigned int pixelClockInKHz )
-{
-	fixed31_32 pixel_duration = Fixed31_32(100000000, pixelClockInKHz) * 10;
-	unsigned int pixDurationInPico = round(pixel_duration);
-
-	DPG_PIPE_ARBITRATION_CONTROL1 arb_control;
-
-	arb_control.u32All = ReadReg (mmDPGV0_PIPE_ARBITRATION_CONTROL1);
-	arb_control.bits.PIXEL_DURATION = pixDurationInPico;
-	WriteReg (mmDPGV0_PIPE_ARBITRATION_CONTROL1, arb_control.u32All);
-
-	arb_control.u32All = ReadReg (mmDPGV1_PIPE_ARBITRATION_CONTROL1);
-	arb_control.bits.PIXEL_DURATION = pixDurationInPico;
-	WriteReg (mmDPGV1_PIPE_ARBITRATION_CONTROL1, arb_control.u32All);
-
-	WriteReg (mmDPGV0_PIPE_ARBITRATION_CONTROL2, 0x4000800);
-	WriteReg (mmDPGV0_REPEATER_PROGRAM, 0x11);
-
-	WriteReg (mmDPGV1_PIPE_ARBITRATION_CONTROL2, 0x4000800);
-	WriteReg (mmDPGV1_REPEATER_PROGRAM, 0x11);
-}
-*/
-
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
@@ -1518,28 +1494,6 @@ struct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i)
 	return NULL;
 }
 
-struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)
-{
-	return dc->links[link_index];
-}
-
-const struct graphics_object_id dc_get_link_id_at_index(
-	struct dc *dc, uint32_t link_index)
-{
-	return dc->links[link_index]->link_id;
-}
-
-enum dc_irq_source dc_get_hpd_irq_source_at_index(
-	struct dc *dc, uint32_t link_index)
-{
-	return dc->links[link_index]->irq_source_hpd;
-}
-
-const struct audio **dc_get_audios(struct dc *dc)
-{
-	return (const struct audio **)dc->res_pool->audios;
-}
-
 enum dc_irq_source dc_interrupt_to_irq_source(
 		struct dc *dc,
 		uint32_t src_id,
@@ -1789,17 +1743,6 @@ struct dc_sink *dc_link_add_remote_sink(
 	return NULL;
 }
 
-void dc_link_set_sink(struct dc_link *link, struct dc_sink *sink)
-{
-	link->local_sink = sink;
-
-	if (sink == NULL) {
-		link->type = dc_connection_none;
-	} else {
-		link->type = dc_connection_single;
-	}
-}
-
 void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 {
 	int i;
@@ -1825,37 +1768,3 @@ void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 		}
 	}
 }
-
-bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
-{
-	int i;
-	struct mem_input *mi = NULL;
-
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		if (dc->res_pool->mis[i] != NULL) {
-			mi = dc->res_pool->mis[i];
-			break;
-		}
-	}
-	if (mi == NULL) {
-		dm_error("no mem_input!\n");
-		return false;
-	}
-
-	if (dc->hwss.update_dchub)
-		dc->hwss.update_dchub(dc->hwseq, dh_data);
-	else
-		ASSERT(dc->hwss.update_dchub);
-
-
-	return true;
-
-}
-
-void dc_log_hw_state(struct dc *dc)
-{
-
-	if (dc->hwss.log_hw_state)
-		dc->hwss.log_hw_state(dc);
-}
-

commit b8a1d69ccb5e0ffc2771b3a7a6ec9d948d10ee9d
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 10:23:15 2017 +1000

    amdgpu/dc: static constify update_surface_trace_level
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 008f137dff80..c8235b041b5b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1172,7 +1172,7 @@ static struct dc_stream_status *stream_get_status(
 	return NULL;
 }
 
-enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
+static const enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,

commit 2dc3e4a86c8cce49bc73f41d8e0134557c506488
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 10:20:39 2017 +1000

    amdgpu/dc: drop dc_ver char
    
    This isn't referenced anywhere, and if it was it should be const.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7fd42fc8bdfa..008f137dff80 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -49,8 +49,6 @@
 #include "mem_input.h"
 
 
-char dc_ver[] = DC_VER;
-
 /*******************************************************************************
  * Private functions
  ******************************************************************************/

commit a2e74cb626d2e1587a5ec35c3ccfc26104bdfa30
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Sep 28 15:39:41 2017 -0400

    drm/amd/display: Remove DWB
    
    It's not in a good shape and currently completely unused.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d86d9796e4cc..7fd42fc8bdfa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1525,15 +1525,6 @@ struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)
 	return dc->links[link_index];
 }
 
-struct dwbc *dc_get_dwb_at_pipe(struct dc *dc, uint32_t pipe)
-{
-	if ((pipe >= dwb_pipe0) && (pipe < dwb_pipe_max_num)) {
-		return dc->res_pool->dwbc[(int)pipe];
-	} else {
-		return NULL;
-	}
-}
-
 const struct graphics_object_id dc_get_link_id_at_index(
 	struct dc *dc, uint32_t link_index)
 {

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 58c5083bef2a..d86d9796e4cc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -113,7 +113,7 @@ static bool create_links(
 	}
 
 	for (i = 0; i < num_virtual_links; i++) {
-		struct dc_link *link = dm_alloc(sizeof(*link));
+		struct dc_link *link = kzalloc(sizeof(*link), GFP_KERNEL);
 		struct encoder_init_data enc_init = {0};
 
 		if (link == NULL) {
@@ -127,7 +127,7 @@ static bool create_links(
 		link->link_id.type = OBJECT_TYPE_CONNECTOR;
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
-		link->link_enc = dm_alloc(sizeof(*link->link_enc));
+		link->link_enc = kzalloc(sizeof(*link->link_enc), GFP_KERNEL);
 
 		enc_init.ctx = dc->ctx;
 		enc_init.channel = CHANNEL_ID_UNKNOWN;
@@ -413,20 +413,20 @@ static void destruct(struct dc *dc)
 	if (dc->ctx->logger)
 		dal_logger_destroy(&dc->ctx->logger);
 
-	dm_free(dc->ctx);
+	kfree(dc->ctx);
 	dc->ctx = NULL;
 
-	dm_free(dc->bw_vbios);
+	kfree(dc->bw_vbios);
 	dc->bw_vbios = NULL;
 
-	dm_free(dc->bw_dceip);
+	kfree(dc->bw_dceip);
 	dc->bw_dceip = NULL;
 
 #ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	dm_free(dc->dcn_soc);
+	kfree(dc->dcn_soc);
 	dc->dcn_soc = NULL;
 
-	dm_free(dc->dcn_ip);
+	kfree(dc->dcn_ip);
 	dc->dcn_ip = NULL;
 
 #endif
@@ -436,12 +436,15 @@ static bool construct(struct dc *dc,
 		const struct dc_init_data *init_params)
 {
 	struct dal_logger *logger;
-	struct dc_context *dc_ctx = dm_alloc(sizeof(*dc_ctx));
-	struct bw_calcs_dceip *dc_dceip = dm_alloc(sizeof(*dc_dceip));
-	struct bw_calcs_vbios *dc_vbios = dm_alloc(sizeof(*dc_vbios));
+	struct dc_context *dc_ctx = kzalloc(sizeof(*dc_ctx), GFP_KERNEL);
+	struct bw_calcs_dceip *dc_dceip = kzalloc(sizeof(*dc_dceip),
+						  GFP_KERNEL);
+	struct bw_calcs_vbios *dc_vbios = kzalloc(sizeof(*dc_vbios),
+						  GFP_KERNEL);
 #ifdef CONFIG_DRM_AMD_DC_DCN1_0
-	struct dcn_soc_bounding_box *dcn_soc = dm_alloc(sizeof(*dcn_soc));
-	struct dcn_ip_params *dcn_ip = dm_alloc(sizeof(*dcn_ip));
+	struct dcn_soc_bounding_box *dcn_soc = kzalloc(sizeof(*dcn_soc),
+						       GFP_KERNEL);
+	struct dcn_ip_params *dcn_ip = kzalloc(sizeof(*dcn_ip), GFP_KERNEL);
 #endif
 
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
@@ -604,7 +607,7 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
 
 struct dc *dc_create(const struct dc_init_data *init_params)
  {
-	struct dc *dc = dm_alloc(sizeof(*dc));
+	struct dc *dc = kzalloc(sizeof(*dc), GFP_KERNEL);
 	unsigned int full_pipe_count;
 
 	if (NULL == dc)
@@ -638,7 +641,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	return dc;
 
 construct_fail:
-	dm_free(dc);
+	kfree(dc);
 
 alloc_fail:
 	return NULL;
@@ -647,7 +650,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 void dc_destroy(struct dc **dc)
 {
 	destruct(*dc);
-	dm_free(*dc);
+	kfree(*dc);
 	*dc = NULL;
 }
 
@@ -900,7 +903,7 @@ bool dc_commit_planes_to_stream(
 	struct dc_scaling_info scaling_info[MAX_SURFACES];
 	int i;
 	struct dc_stream_update *stream_update =
-			dm_alloc(sizeof(struct dc_stream_update));
+			kzalloc(sizeof(struct dc_stream_update), GFP_KERNEL);
 
 	if (!stream_update) {
 		BREAK_TO_DEBUGGER();
@@ -951,13 +954,14 @@ bool dc_commit_planes_to_stream(
 
 	dc_post_update_surfaces_to_stream(dc);
 
-	dm_free(stream_update);
+	kfree(stream_update);
 	return true;
 }
 
 struct dc_state *dc_create_state(void)
 {
-	struct dc_state *context = dm_alloc(sizeof(struct dc_state));
+	struct dc_state *context = kzalloc(sizeof(struct dc_state),
+					   GFP_KERNEL);
 
 	if (!context)
 		return NULL;
@@ -979,7 +983,7 @@ void dc_release_state(struct dc_state *context)
 
 	if (atomic_read(&context->ref_count) == 0) {
 		dc_resource_state_destruct(context);
-		dm_free(context);
+		kfree(context);
 	}
 }
 

commit 4a6cee2ca142615970fa3334191e992e7fb51159
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Sep 24 14:31:51 2017 -0400

    drm/amd/display: Remove unused dc_validate_guaranteed function
    
    It got refactored away and was never cleaned.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 75a5fa2296d7..58c5083bef2a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -651,40 +651,6 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
-bool dc_validate_guaranteed(
-		struct dc *dc,
-		struct dc_stream_state *stream)
-{
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct dc_state *context;
-
-	if (!dc_validate_stream(dc, stream))
-		return false;
-
-	context = dm_alloc(sizeof(struct dc_state));
-	if (context == NULL)
-		goto context_alloc_fail;
-
-	dc_resource_state_construct(dc, dc->current_state);
-
-	atomic_inc(&context->ref_count);
-
-	result = dc->res_pool->funcs->validate_guaranteed(
-					dc, stream, context);
-
-	dc_release_state(context);
-
-context_alloc_fail:
-	if (result != DC_OK) {
-		dm_logger_write(dc->ctx->logger, LOG_WARNING,
-			"%s:guaranteed validation failed, dc_status:%d\n",
-			__func__,
-			result);
-		}
-
-	return (result == DC_OK);
-}
-
 static void program_timing_sync(
 		struct dc *dc,
 		struct dc_state *ctx)

commit 01a526f3dee9abe1e2db9e37e4ceb4149f8ae77b
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 19:33:40 2017 -0400

    drm/amd/display: Pass log_mask from DM
    
    Linux and Windows often desire different log levels.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5579d2167a9a..75a5fa2296d7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -493,7 +493,7 @@ static bool construct(struct dc *dc,
 	dc_ctx->asic_id = init_params->asic_id;
 
 	/* Create logger */
-	logger = dal_logger_create(dc_ctx);
+	logger = dal_logger_create(dc_ctx, init_params->log_mask);
 
 	if (!logger) {
 		/* can *not* call logger. call base driver 'print error' */

commit aeff7ab11e2516bfa41c77b9ea57bc2c07bb3b62
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Fri Sep 1 16:03:16 2017 -0400

    drm/amd/display: Fix context alloc failed logging
    
    Since there was no return statement in the fail block immediately
    preceding the context_alloc_fail block, any failure within the
    function caused a context alloc failed error message to be printed.
    Since the context_alloc_fail block is only used once, move it to
    where the goto is directly and accompany it with a return statement.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d5320f7162b4..5579d2167a9a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1279,8 +1279,10 @@ void dc_update_planes_and_stream(struct dc *dc,
 
 		/* initialize scratch memory for building context */
 		context = dc_create_state();
-		if (context == NULL)
-				goto context_alloc_fail;
+		if (context == NULL) {
+			DC_ERROR("Failed to allocate new validate context!\n");
+			return;
+		}
 
 		dc_resource_state_copy_construct(
 				dc->current_state, context);
@@ -1534,9 +1536,6 @@ void dc_update_planes_and_stream(struct dc *dc,
 
 fail:
 	dc_release_state(context);
-
-context_alloc_fail:
-	DC_ERROR("Failed to allocate new validate context!\n");
 }
 
 uint8_t dc_get_current_stream_count(struct dc *dc)

commit 603767f903bf5bf301728b197dcde63cf880fe2e
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Sep 1 16:14:01 2017 -0400

    drm/amd/display: fix default dithering
    
    bug: default is mapped to no dithering.
    
    default to spatial dithering based on color depth
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ab6ad946231e..d5320f7162b4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -341,23 +341,9 @@ void set_dither_option(struct dc_stream_state *stream,
 		return;
 	if (option > DITHER_OPTION_MAX)
 		return;
-	if (option == DITHER_OPTION_DEFAULT) {
-		switch (stream->timing.display_color_depth) {
-		case COLOR_DEPTH_666:
-			stream->dither_option = DITHER_OPTION_SPATIAL6;
-			break;
-		case COLOR_DEPTH_888:
-			stream->dither_option = DITHER_OPTION_SPATIAL8;
-			break;
-		case COLOR_DEPTH_101010:
-			stream->dither_option = DITHER_OPTION_SPATIAL10;
-			break;
-		default:
-			option = DITHER_OPTION_DISABLE;
-		}
-	} else {
-		stream->dither_option = option;
-	}
+
+	stream->dither_option = option;
+
 	resource_build_bit_depth_reduction_params(stream,
 				&params);
 	stream->bit_depth_params = params;

commit ab8db3e1653c50ae19d1c31d82f94beb5115aeef
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Aug 28 14:25:01 2017 -0400

    drm/amd/display: Move dis_clk into dc_state.
    
    dis_clk is single instance across pipes.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6bf8af7a592d..ab6ad946231e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -573,6 +573,8 @@ static bool construct(struct dc *dc,
 	if (!dc->res_pool)
 		goto fail;
 
+	dc_resource_state_construct(dc, dc->current_state);
+
 	if (!create_links(dc, init_params->num_virtual_links))
 		goto fail;
 
@@ -677,6 +679,8 @@ bool dc_validate_guaranteed(
 	if (context == NULL)
 		goto context_alloc_fail;
 
+	dc_resource_state_construct(dc, dc->current_state);
+
 	atomic_inc(&context->ref_count);
 
 	result = dc->res_pool->funcs->validate_guaranteed(
@@ -1622,6 +1626,8 @@ void dc_set_power_state(
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
+		dc_resource_state_construct(dc, dc->current_state);
+
 		dc->hwss.init_hw(dc);
 		break;
 	default:
@@ -1638,6 +1644,7 @@ void dc_set_power_state(
 		dc_resource_state_destruct(dc->current_state);
 		memset(dc->current_state, 0,
 				sizeof(*dc->current_state));
+
 		dc->current_state->ref_count = ref_count;
 
 		break;

commit f36cc577c3254738e370b553f9f8cedf2df84070
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Aug 28 12:04:23 2017 -0400

    drm/amd/display: Rename dc resource_validate_ctx methods
    
    Rename dc_resource methods from validate_ctx to state
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 53f814dcc24d..6bf8af7a592d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1022,7 +1022,7 @@ void dc_release_state(struct dc_state *context)
 	atomic_dec(&context->ref_count);
 
 	if (atomic_read(&context->ref_count) == 0) {
-		dc_resource_validate_ctx_destruct(context);
+		dc_resource_state_destruct(context);
 		dm_free(context);
 	}
 }
@@ -1292,7 +1292,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		if (context == NULL)
 				goto context_alloc_fail;
 
-		dc_resource_validate_ctx_copy_construct(
+		dc_resource_state_copy_construct(
 				dc->current_state, context);
 
 		/*remove old surfaces from context */
@@ -1635,7 +1635,7 @@ void dc_set_power_state(
 
 		/* Preserve refcount */
 		ref_count = dc->current_state->ref_count;
-		dc_resource_validate_ctx_destruct(dc->current_state);
+		dc_resource_state_destruct(dc->current_state);
 		memset(dc->current_state, 0,
 				sizeof(*dc->current_state));
 		dc->current_state->ref_count = ref_count;

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_state and
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a20dc24db0d5..53f814dcc24d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -160,7 +160,7 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 	bool ret = false;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		struct pipe_ctx *pipe = &dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
 			dc->hwss.set_drr(&pipe, 1, vmin, vmax);
@@ -187,7 +187,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe =
-				&dc->current_context->res_ctx.pipe_ctx[i];
+				&dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
 			dc->hwss.get_position(&pipe, 1, &position);
@@ -207,8 +207,8 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_context->res_ctx.pipe_ctx[i].stream == stream) {
-			pipes = &dc->current_context->res_ctx.pipe_ctx[i];
+		if (dc->current_state->res_ctx.pipe_ctx[i].stream == stream) {
+			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
 			dc->hwss.program_gamut_remap(pipes);
 			ret = true;
 		}
@@ -224,10 +224,10 @@ static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (dc->current_context->res_ctx.pipe_ctx[i].stream
+		if (dc->current_state->res_ctx.pipe_ctx[i].stream
 				== stream) {
 
-			pipes = &dc->current_context->res_ctx.pipe_ctx[i];
+			pipes = &dc->current_state->res_ctx.pipe_ctx[i];
 			dc->hwss.program_csc_matrix(pipes,
 			stream->output_color_space,
 			stream->csc_color_matrix.matrix);
@@ -252,10 +252,10 @@ static void set_static_screen_events(struct dc *dc,
 		struct dc_stream_state *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
-			if (dc->current_context->res_ctx.pipe_ctx[j].stream
+			if (dc->current_state->res_ctx.pipe_ctx[j].stream
 					== stream) {
 				pipes_affected[num_pipes_affected++] =
-						&dc->current_context->res_ctx.pipe_ctx[j];
+						&dc->current_state->res_ctx.pipe_ctx[j];
 			}
 		}
 	}
@@ -334,7 +334,7 @@ void set_dither_option(struct dc_stream_state *stream,
 {
 	struct bit_depth_reduction_params params;
 	struct dc_link *link = stream->status.link;
-	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
+	struct pipe_ctx *pipes = link->dc->current_state->res_ctx.pipe_ctx;
 
 	memset(&params, 0, sizeof(params));
 	if (!stream)
@@ -408,8 +408,8 @@ static void allocate_dc_stream_funcs(struct dc  *dc)
 
 static void destruct(struct dc *dc)
 {
-	dc_release_validate_context(dc->current_context);
-	dc->current_context = NULL;
+	dc_release_state(dc->current_state);
+	dc->current_state = NULL;
 
 	destroy_links(dc);
 
@@ -494,9 +494,9 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 
-	dc->current_context = dc_create_state();
+	dc->current_state = dc_create_state();
 
-	if (!dc->current_context) {
+	if (!dc->current_state) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
 		goto fail;
 	}
@@ -668,12 +668,12 @@ bool dc_validate_guaranteed(
 		struct dc_stream_state *stream)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct validate_context *context;
+	struct dc_state *context;
 
 	if (!dc_validate_stream(dc, stream))
 		return false;
 
-	context = dm_alloc(sizeof(struct validate_context));
+	context = dm_alloc(sizeof(struct dc_state));
 	if (context == NULL)
 		goto context_alloc_fail;
 
@@ -682,7 +682,7 @@ bool dc_validate_guaranteed(
 	result = dc->res_pool->funcs->validate_guaranteed(
 					dc, stream, context);
 
-	dc_release_validate_context(context);
+	dc_release_state(context);
 
 context_alloc_fail:
 	if (result != DC_OK) {
@@ -697,7 +697,7 @@ bool dc_validate_guaranteed(
 
 static void program_timing_sync(
 		struct dc *dc,
-		struct validate_context *ctx)
+		struct dc_state *ctx)
 {
 	int i, j;
 	int group_index = 0;
@@ -771,15 +771,15 @@ static void program_timing_sync(
 
 static bool context_changed(
 		struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	uint8_t i;
 
-	if (context->stream_count != dc->current_context->stream_count)
+	if (context->stream_count != dc->current_state->stream_count)
 		return true;
 
-	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (dc->current_context->streams[i] != context->streams[i])
+	for (i = 0; i < dc->current_state->stream_count; i++) {
+		if (dc->current_state->streams[i] != context->streams[i])
 			return true;
 	}
 
@@ -788,7 +788,7 @@ static bool context_changed(
 
 bool dc_enable_stereo(
 	struct dc *dc,
-	struct validate_context *context,
+	struct dc_state *context,
 	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
@@ -800,7 +800,7 @@ bool dc_enable_stereo(
 		if (context != NULL)
 			pipe = &context->res_ctx.pipe_ctx[i];
 		else
-			pipe = &dc->current_context->res_ctx.pipe_ctx[i];
+			pipe = &dc->current_state->res_ctx.pipe_ctx[i];
 		for (j = 0 ; pipe && j < stream_count; j++)  {
 			if (streams[j] && streams[j] == pipe->stream &&
 				dc->hwss.setup_stereo)
@@ -816,7 +816,7 @@ bool dc_enable_stereo(
  * Applies given context to HW and copy it into current context.
  * It's up to the user to release the src context afterwards.
  */
-static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *context)
+static bool dc_commit_state_no_check(struct dc *dc, struct dc_state *context)
 {
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -875,18 +875,18 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	dc_release_validate_context(dc->current_context);
+	dc_release_state(dc->current_state);
 
-	dc->current_context = context;
+	dc->current_state = context;
 
-	dc_retain_validate_context(dc->current_context);
+	dc_retain_state(dc->current_state);
 
 	dc->hwss.optimize_shared_resources(dc);
 
 	return (result == DC_OK);
 }
 
-bool dc_commit_context(struct dc *dc, struct validate_context *context)
+bool dc_commit_state(struct dc *dc, struct dc_state *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	int i;
@@ -905,7 +905,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 				LOG_DC);
 	}
 
-	result = dc_commit_context_no_check(dc, context);
+	result = dc_commit_state_no_check(dc, context);
 
 	return (result == DC_OK);
 }
@@ -914,7 +914,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
-	struct validate_context *context = dc->current_context;
+	struct dc_state *context = dc->current_state;
 
 	post_surface_trace(dc);
 
@@ -999,9 +999,9 @@ bool dc_commit_planes_to_stream(
 	return true;
 }
 
-struct validate_context *dc_create_state(void)
+struct dc_state *dc_create_state(void)
 {
-	struct validate_context *context = dm_alloc(sizeof(struct validate_context));
+	struct dc_state *context = dm_alloc(sizeof(struct dc_state));
 
 	if (!context)
 		return NULL;
@@ -1010,13 +1010,13 @@ struct validate_context *dc_create_state(void)
 	return context;
 }
 
-void dc_retain_validate_context(struct validate_context *context)
+void dc_retain_state(struct dc_state *context)
 {
 	ASSERT(atomic_read(&context->ref_count) > 0);
 	atomic_inc(&context->ref_count);
 }
 
-void dc_release_validate_context(struct validate_context *context)
+void dc_release_state(struct dc_state *context)
 {
 	ASSERT(atomic_read(&context->ref_count) > 0);
 	atomic_dec(&context->ref_count);
@@ -1028,7 +1028,7 @@ void dc_release_validate_context(struct validate_context *context)
 }
 
 static bool is_surface_in_context(
-		const struct validate_context *context,
+		const struct dc_state *context,
 		const struct dc_plane_state *plane_state)
 {
 	int j;
@@ -1145,7 +1145,7 @@ static enum surface_update_type det_surface_update(
 		const struct dc_surface_update *u,
 		int surface_index)
 {
-	const struct validate_context *context = dc->current_context;
+	const struct dc_state *context = dc->current_state;
 	enum surface_update_type type = UPDATE_TYPE_FAST;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
@@ -1200,7 +1200,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 }
 
 static struct dc_stream_status *stream_get_status(
-	struct validate_context *ctx,
+	struct dc_state *ctx,
 	struct dc_stream_state *stream)
 {
 	uint8_t i;
@@ -1221,7 +1221,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
 {
-	struct validate_context *context;
+	struct dc_state *context;
 	int i, j;
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
@@ -1239,7 +1239,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 			ASSERT(0);
 	}
 #endif
-	context = dc->current_context;
+	context = dc->current_state;
 
 	/* update current stream with the new updates */
 	if (stream_update) {
@@ -1293,7 +1293,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 				goto context_alloc_fail;
 
 		dc_resource_validate_ctx_copy_construct(
-				dc->current_context, context);
+				dc->current_state, context);
 
 		/*remove old surfaces from context */
 		if (!dc_rem_all_planes_for_stream(dc, stream, context)) {
@@ -1437,7 +1437,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 	/* Full fe update*/
 	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[j];
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[j];
 		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
@@ -1524,7 +1524,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		}
 	}
 
-	if (dc->current_context != context) {
+	if (dc->current_state != context) {
 
 		/* Since memory free requires elevated IRQL, an interrupt
 		 * request is generated by mem free. If this happens
@@ -1534,16 +1534,16 @@ void dc_update_planes_and_stream(struct dc *dc,
 		 * then free the old context.
 		 */
 
-		struct validate_context *old = dc->current_context;
+		struct dc_state *old = dc->current_state;
 
-		dc->current_context = context;
-		dc_release_validate_context(old);
+		dc->current_state = context;
+		dc_release_state(old);
 
 	}
 	return;
 
 fail:
-	dc_release_validate_context(context);
+	dc_release_state(context);
 
 context_alloc_fail:
 	DC_ERROR("Failed to allocate new validate context!\n");
@@ -1551,13 +1551,13 @@ void dc_update_planes_and_stream(struct dc *dc,
 
 uint8_t dc_get_current_stream_count(struct dc *dc)
 {
-	return dc->current_context->stream_count;
+	return dc->current_state->stream_count;
 }
 
 struct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i)
 {
-	if (i < dc->current_context->stream_count)
-		return dc->current_context->streams[i];
+	if (i < dc->current_state->stream_count)
+		return dc->current_state->streams[i];
 	return NULL;
 }
 
@@ -1634,11 +1634,11 @@ void dc_set_power_state(
 		 */
 
 		/* Preserve refcount */
-		ref_count = dc->current_context->ref_count;
-		dc_resource_validate_ctx_destruct(dc->current_context);
-		memset(dc->current_context, 0,
-				sizeof(*dc->current_context));
-		dc->current_context->ref_count = ref_count;
+		ref_count = dc->current_state->ref_count;
+		dc_resource_validate_ctx_destruct(dc->current_state);
+		memset(dc->current_state, 0,
+				sizeof(*dc->current_state));
+		dc->current_state->ref_count = ref_count;
 
 		break;
 	}

commit 41f97c0773aed681ad65fa27ee88b503fbdcd298
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Aug 24 17:40:00 2017 -0400

    drm/amd/display: DF C-state entry blocked when DPMS
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index dc1b7d061be2..a20dc24db0d5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -830,6 +830,8 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		dc->hwss.enable_accelerated_mode(dc);
 
+	dc->hwss.ready_shared_resources(dc);
+
 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		pipe = &context->res_ctx.pipe_ctx[i];
 		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
@@ -879,6 +881,8 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	dc_retain_validate_context(dc->current_context);
 
+	dc->hwss.optimize_shared_resources(dc);
+
 	return (result == DC_OK);
 }
 

commit 156590454259a19d1709fab2ff7d59870574e822
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Aug 23 15:44:42 2017 -0400

    drm/amd/display: Clean up flattening core_dc to dc
    
    Clean up some code related to flattening core_dc commit
    (Remove redundent dc = dc, which was the result of removing
    DC_TO_CORE() macro)
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 79980cb0900c..dc1b7d061be2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -155,20 +155,19 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
-	struct dc  *core_dc = dc;
 	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		struct pipe_ctx *pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
+		struct pipe_ctx *pipe = &dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
-			core_dc->hwss.set_drr(&pipe, 1, vmin, vmax);
+			dc->hwss.set_drr(&pipe, 1, vmin, vmax);
 
 			/* build and update the info frame */
 			resource_build_info_frame(pipe);
-			core_dc->hwss.update_info_frame(pipe);
+			dc->hwss.update_info_frame(pipe);
 
 			ret = true;
 		}
@@ -181,7 +180,6 @@ static bool stream_get_crtc_position(struct dc *dc,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
-	struct dc *core_dc = dc;
 	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
@@ -189,10 +187,10 @@ static bool stream_get_crtc_position(struct dc *dc,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe =
-				&core_dc->current_context->res_ctx.pipe_ctx[i];
+				&dc->current_context->res_ctx.pipe_ctx[i];
 
 		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
-			core_dc->hwss.get_position(&pipe, 1, &position);
+			dc->hwss.get_position(&pipe, 1, &position);
 
 			*v_pos = position.vertical_count;
 			*nom_v_pos = position.nominal_vcount;
@@ -204,15 +202,14 @@ static bool stream_get_crtc_position(struct dc *dc,
 
 static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 {
-	struct dc  *core_dc = dc;
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == stream) {
-			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
-			core_dc->hwss.program_gamut_remap(pipes);
+		if (dc->current_context->res_ctx.pipe_ctx[i].stream == stream) {
+			pipes = &dc->current_context->res_ctx.pipe_ctx[i];
+			dc->hwss.program_gamut_remap(pipes);
 			ret = true;
 		}
 	}
@@ -222,17 +219,16 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 
 static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 {
-	struct dc  *core_dc = dc;
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
+		if (dc->current_context->res_ctx.pipe_ctx[i].stream
 				== stream) {
 
-			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
-			core_dc->hwss.program_csc_matrix(pipes,
+			pipes = &dc->current_context->res_ctx.pipe_ctx[i];
+			dc->hwss.program_csc_matrix(pipes,
 			stream->output_color_space,
 			stream->csc_color_matrix.matrix);
 			ret = true;
@@ -247,7 +243,6 @@ static void set_static_screen_events(struct dc *dc,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
-	struct dc  *core_dc = dc;
 	int i = 0;
 	int j = 0;
 	struct pipe_ctx *pipes_affected[MAX_PIPES];
@@ -257,45 +252,44 @@ static void set_static_screen_events(struct dc *dc,
 		struct dc_stream_state *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
-			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
+			if (dc->current_context->res_ctx.pipe_ctx[j].stream
 					== stream) {
 				pipes_affected[num_pipes_affected++] =
-						&core_dc->current_context->res_ctx.pipe_ctx[j];
+						&dc->current_context->res_ctx.pipe_ctx[j];
 			}
 		}
 	}
 
-	core_dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
+	dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
 static void set_drive_settings(struct dc *dc,
 		struct link_training_settings *lt_settings,
 		const struct dc_link *link)
 {
-	struct dc  *core_dc = dc;
+
 	int i;
 
-	for (i = 0; i < core_dc->link_count; i++) {
-		if (core_dc->links[i] == link)
+	for (i = 0; i < dc->link_count; i++) {
+		if (dc->links[i] == link)
 			break;
 	}
 
-	if (i >= core_dc->link_count)
+	if (i >= dc->link_count)
 		ASSERT_CRITICAL(false);
 
-	dc_link_dp_set_drive_settings(core_dc->links[i], lt_settings);
+	dc_link_dp_set_drive_settings(dc->links[i], lt_settings);
 }
 
 static void perform_link_training(struct dc *dc,
 		struct dc_link_settings *link_setting,
 		bool skip_video_pattern)
 {
-	struct dc  *core_dc = dc;
 	int i;
 
-	for (i = 0; i < core_dc->link_count; i++)
+	for (i = 0; i < dc->link_count; i++)
 		dc_link_dp_perform_link_training(
-			core_dc->links[i],
+			dc->links[i],
 			link_setting,
 			skip_video_pattern);
 }
@@ -371,44 +365,44 @@ void set_dither_option(struct dc_stream_state *stream,
 		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }
 
-static void allocate_dc_stream_funcs(struct dc  *core_dc)
+static void allocate_dc_stream_funcs(struct dc  *dc)
 {
-	if (core_dc->hwss.set_drr != NULL) {
-		core_dc->stream_funcs.adjust_vmin_vmax =
+	if (dc->hwss.set_drr != NULL) {
+		dc->stream_funcs.adjust_vmin_vmax =
 				stream_adjust_vmin_vmax;
 	}
 
-	core_dc->stream_funcs.set_static_screen_events =
+	dc->stream_funcs.set_static_screen_events =
 			set_static_screen_events;
 
-	core_dc->stream_funcs.get_crtc_position =
+	dc->stream_funcs.get_crtc_position =
 			stream_get_crtc_position;
 
-	core_dc->stream_funcs.set_gamut_remap =
+	dc->stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
-	core_dc->stream_funcs.program_csc_matrix =
+	dc->stream_funcs.program_csc_matrix =
 			program_csc_matrix;
 
-	core_dc->stream_funcs.set_dither_option =
+	dc->stream_funcs.set_dither_option =
 			set_dither_option;
 
-	core_dc->link_funcs.set_drive_settings =
+	dc->link_funcs.set_drive_settings =
 			set_drive_settings;
 
-	core_dc->link_funcs.perform_link_training =
+	dc->link_funcs.perform_link_training =
 			perform_link_training;
 
-	core_dc->link_funcs.set_preferred_link_settings =
+	dc->link_funcs.set_preferred_link_settings =
 			set_preferred_link_settings;
 
-	core_dc->link_funcs.enable_hpd =
+	dc->link_funcs.enable_hpd =
 			enable_hpd;
 
-	core_dc->link_funcs.disable_hpd =
+	dc->link_funcs.disable_hpd =
 			disable_hpd;
 
-	core_dc->link_funcs.set_test_pattern =
+	dc->link_funcs.set_test_pattern =
 			set_test_pattern;
 }
 
@@ -622,41 +616,41 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
 
 struct dc *dc_create(const struct dc_init_data *init_params)
  {
-	struct dc *core_dc = dm_alloc(sizeof(*core_dc));
+	struct dc *dc = dm_alloc(sizeof(*dc));
 	unsigned int full_pipe_count;
 
-	if (NULL == core_dc)
+	if (NULL == dc)
 		goto alloc_fail;
 
-	if (false == construct(core_dc, init_params))
+	if (false == construct(dc, init_params))
 		goto construct_fail;
 
 	/*TODO: separate HW and SW initialization*/
-	core_dc->hwss.init_hw(core_dc);
+	dc->hwss.init_hw(dc);
 
-	full_pipe_count = core_dc->res_pool->pipe_count;
-	if (core_dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
+	full_pipe_count = dc->res_pool->pipe_count;
+	if (dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
 		full_pipe_count--;
-	core_dc->caps.max_streams = min(
+	dc->caps.max_streams = min(
 			full_pipe_count,
-			core_dc->res_pool->stream_enc_count);
+			dc->res_pool->stream_enc_count);
 
-	core_dc->caps.max_links = core_dc->link_count;
-	core_dc->caps.max_audios = core_dc->res_pool->audio_count;
+	dc->caps.max_links = dc->link_count;
+	dc->caps.max_audios = dc->res_pool->audio_count;
 
-	core_dc->config = init_params->flags;
+	dc->config = init_params->flags;
 
-	dm_logger_write(core_dc->ctx->logger, LOG_DC,
+	dm_logger_write(dc->ctx->logger, LOG_DC,
 			"Display Core initialized\n");
 
 
 	/* TODO: missing feature to be enabled */
-	core_dc->debug.disable_dfs_bypass = true;
+	dc->debug.disable_dfs_bypass = true;
 
-	return core_dc;
+	return dc;
 
 construct_fail:
-	dm_free(core_dc);
+	dm_free(dc);
 
 alloc_fail:
 	return NULL;
@@ -664,9 +658,8 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 void dc_destroy(struct dc **dc)
 {
-	struct dc  *core_dc = *dc;
-	destruct(core_dc);
-	dm_free(core_dc);
+	destruct(*dc);
+	dm_free(*dc);
 	*dc = NULL;
 }
 
@@ -674,7 +667,6 @@ bool dc_validate_guaranteed(
 		struct dc *dc,
 		struct dc_stream_state *stream)
 {
-	struct dc  *core_dc = dc;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
@@ -687,14 +679,14 @@ bool dc_validate_guaranteed(
 
 	atomic_inc(&context->ref_count);
 
-	result = core_dc->res_pool->funcs->validate_guaranteed(
-					core_dc, stream, context);
+	result = dc->res_pool->funcs->validate_guaranteed(
+					dc, stream, context);
 
 	dc_release_validate_context(context);
 
 context_alloc_fail:
 	if (result != DC_OK) {
-		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
+		dm_logger_write(dc->ctx->logger, LOG_WARNING,
 			"%s:guaranteed validation failed, dc_status:%d\n",
 			__func__,
 			result);
@@ -704,12 +696,12 @@ bool dc_validate_guaranteed(
 }
 
 static void program_timing_sync(
-		struct dc *core_dc,
+		struct dc *dc,
 		struct validate_context *ctx)
 {
 	int i, j;
 	int group_index = 0;
-	int pipe_count = core_dc->res_pool->pipe_count;
+	int pipe_count = dc->res_pool->pipe_count;
 	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
 
 	for (i = 0; i < pipe_count; i++) {
@@ -770,8 +762,8 @@ static void program_timing_sync(
 		}
 
 		if (group_size > 1) {
-			core_dc->hwss.enable_timing_synchronization(
-				core_dc, group_index, group_size, pipe_set);
+			dc->hwss.enable_timing_synchronization(
+				dc, group_index, group_size, pipe_set);
 			group_index++;
 		}
 	}
@@ -803,17 +795,16 @@ bool dc_enable_stereo(
 	bool ret = true;
 	int i, j;
 	struct pipe_ctx *pipe;
-	struct dc  *core_dc = dc;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context != NULL)
 			pipe = &context->res_ctx.pipe_ctx[i];
 		else
-			pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			pipe = &dc->current_context->res_ctx.pipe_ctx[i];
 		for (j = 0 ; pipe && j < stream_count; j++)  {
 			if (streams[j] && streams[j] == pipe->stream &&
-				core_dc->hwss.setup_stereo)
-				core_dc->hwss.setup_stereo(pipe, core_dc);
+				dc->hwss.setup_stereo)
+				dc->hwss.setup_stereo(pipe, dc);
 		}
 	}
 
@@ -827,8 +818,7 @@ bool dc_enable_stereo(
  */
 static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *context)
 {
-	struct dc *core_dc = dc;
-	struct dc_bios *dcb = core_dc->ctx->dc_bios;
+	struct dc_bios *dcb = dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
@@ -838,22 +828,22 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		dc_streams[i] =  context->streams[i];
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
-		core_dc->hwss.enable_accelerated_mode(core_dc);
+		dc->hwss.enable_accelerated_mode(dc);
 
-	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		pipe = &context->res_ctx.pipe_ctx[i];
-		core_dc->hwss.wait_for_mpcc_disconnect(core_dc, core_dc->res_pool, pipe);
+		dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe);
 	}
-	result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
+	result = dc->hwss.apply_ctx_to_hw(dc, context);
 
-	program_timing_sync(core_dc, context);
+	program_timing_sync(dc, context);
 
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].plane_count; j++) {
-			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, context->streams[i],
+			dc->hwss.apply_ctx_for_surface(
+					dc, context->streams[i],
 					context->stream_status[i].plane_count,
 					context);
 
@@ -867,8 +857,8 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 				for (l = 0 ; pipe && l < context->stream_count; l++)  {
 					if (context->streams[l] &&
 					    context->streams[l] == pipe->stream &&
-					    core_dc->hwss.setup_stereo)
-						core_dc->hwss.setup_stereo(pipe, core_dc);
+					    dc->hwss.setup_stereo)
+						dc->hwss.setup_stereo(pipe, dc);
 				}
 			}
 		}
@@ -883,11 +873,11 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	dc_release_validate_context(core_dc->current_context);
+	dc_release_validate_context(dc->current_context);
 
-	core_dc->current_context = context;
+	dc->current_context = context;
 
-	dc_retain_validate_context(core_dc->current_context);
+	dc_retain_validate_context(dc->current_context);
 
 	return (result == DC_OK);
 }
@@ -895,20 +885,19 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 bool dc_commit_context(struct dc *dc, struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct dc  *core_dc = dc;
 	int i;
 
-	if (false == context_changed(core_dc, context))
+	if (false == context_changed(dc, context))
 		return DC_OK;
 
-	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+	dm_logger_write(dc->ctx->logger, LOG_DC, "%s: %d streams\n",
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct dc_stream_state *stream = context->streams[i];
 
 		dc_stream_log(stream,
-				core_dc->ctx->logger,
+				dc->ctx->logger,
 				LOG_DC);
 	}
 
@@ -921,21 +910,20 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
-	struct dc  *core_dc = dc;
-	struct validate_context *context = core_dc->current_context;
+	struct validate_context *context = dc->current_context;
 
 	post_surface_trace(dc);
 
-	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
+	for (i = 0; i < dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL
 				|| context->res_ctx.pipe_ctx[i].plane_state == NULL)
-			core_dc->hwss.power_down_front_end(core_dc, i);
+			dc->hwss.power_down_front_end(dc, i);
 
 	/* 3rd param should be true, temp w/a for RV*/
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	core_dc->hwss.set_bandwidth(core_dc, context, core_dc->ctx->dce_version < DCN_VERSION_1_0);
+	dc->hwss.set_bandwidth(dc, context, dc->ctx->dce_version < DCN_VERSION_1_0);
 #else
-	core_dc->hwss.set_bandwidth(core_dc, context, true);
+	dc->hwss.set_bandwidth(dc, context, true);
 #endif
 	return true;
 }
@@ -1184,7 +1172,6 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc_stream_update *stream_update,
 		const struct dc_stream_status *stream_status)
 {
-	struct dc  *core_dc = dc;
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
@@ -1196,7 +1183,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
-				det_surface_update(core_dc, &updates[i], i);
+				det_surface_update(dc, &updates[i], i);
 
 		if (type == UPDATE_TYPE_FULL)
 			return type;
@@ -1230,12 +1217,11 @@ void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
 {
-	struct dc  *core_dc = dc;
 	struct validate_context *context;
 	int i, j;
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
-	struct dc_context *dc_ctx = core_dc->ctx;
+	struct dc_context *dc_ctx = dc->ctx;
 
 	stream_status = dc_stream_get_status(stream);
 
@@ -1249,7 +1235,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 			ASSERT(0);
 	}
 #endif
-	context = core_dc->current_context;
+	context = dc->current_context;
 
 	/* update current stream with the new updates */
 	if (stream_update) {
@@ -1303,7 +1289,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 				goto context_alloc_fail;
 
 		dc_resource_validate_ctx_copy_construct(
-				core_dc->current_context, context);
+				dc->current_context, context);
 
 		/*remove old surfaces from context */
 		if (!dc_rem_all_planes_for_stream(dc, stream, context)) {
@@ -1365,7 +1351,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		}
 
 		if (update_type >= UPDATE_TYPE_MED) {
-			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+			for (j = 0; j < dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 				if (pipe_ctx->plane_state != surface)
@@ -1403,31 +1389,31 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	if (update_type == UPDATE_TYPE_FULL) {
-		if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
+		if (!dc->res_pool->funcs->validate_bandwidth(dc, context)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
 		} else {
-			core_dc->hwss.set_bandwidth(core_dc, context, false);
+			dc->hwss.set_bandwidth(dc, context, false);
 			context_clock_trace(dc, context);
 		}
 	}
 
 	if (update_type > UPDATE_TYPE_FAST) {
-		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			core_dc->hwss.wait_for_mpcc_disconnect(core_dc, core_dc->res_pool, pipe_ctx);
+			dc->hwss.wait_for_mpcc_disconnect(dc, dc->res_pool, pipe_ctx);
 		}
 	}
 
 	if (surface_count == 0)
-		core_dc->hwss.apply_ctx_for_surface(core_dc, stream, surface_count, context);
+		dc->hwss.apply_ctx_for_surface(dc, stream, surface_count, context);
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
 		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
-		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->plane_state != plane_state)
@@ -1435,8 +1421,8 @@ void dc_update_planes_and_stream(struct dc *dc,
 			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
-			core_dc->hwss.pipe_control_lock(
-					core_dc,
+			dc->hwss.pipe_control_lock(
+					dc,
 					pipe_ctx,
 					true);
 		}
@@ -1445,9 +1431,9 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	/* Full fe update*/
-	for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+	for (j = 0; j < dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-		struct pipe_ctx *cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
+		struct pipe_ctx *cur_pipe_ctx = &dc->current_context->res_ctx.pipe_ctx[j];
 		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
@@ -1458,18 +1444,18 @@ void dc_update_planes_and_stream(struct dc *dc,
 		if (!pipe_ctx->top_pipe && pipe_ctx->stream) {
 			struct dc_stream_status *stream_status = stream_get_status(context, pipe_ctx->stream);
 
-			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, pipe_ctx->stream, stream_status->plane_count, context);
+			dc->hwss.apply_ctx_for_surface(
+					dc, pipe_ctx->stream, stream_status->plane_count, context);
 		}
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
 
 		if (is_new_pipe_surface) {
-			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-			core_dc->hwss.set_input_transfer_func(
+			dc->hwss.update_plane_addr(dc, pipe_ctx);
+			dc->hwss.set_input_transfer_func(
 					pipe_ctx, pipe_ctx->plane_state);
-			core_dc->hwss.set_output_transfer_func(
+			dc->hwss.set_output_transfer_func(
 					pipe_ctx, pipe_ctx->stream);
 		}
 	}
@@ -1482,40 +1468,40 @@ void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
-			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, stream, surface_count, context);
+			dc->hwss.apply_ctx_for_surface(
+					dc, stream, surface_count, context);
 
-		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+		for (j = 0; j < dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
 			if (srf_updates[i].flip_addr)
-				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+				dc->hwss.update_plane_addr(dc, pipe_ctx);
 
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
 			if (srf_updates[i].in_transfer_func)
-				core_dc->hwss.set_input_transfer_func(
+				dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->plane_state);
 
 			if (stream_update != NULL &&
 					stream_update->out_transfer_func != NULL) {
-				core_dc->hwss.set_output_transfer_func(
+				dc->hwss.set_output_transfer_func(
 						pipe_ctx, pipe_ctx->stream);
 			}
 
 			if (srf_updates[i].hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);
-				core_dc->hwss.update_info_frame(pipe_ctx);
+				dc->hwss.update_info_frame(pipe_ctx);
 			}
 		}
 	}
 
 	/* Unlock pipes */
-	for (i = core_dc->res_pool->pipe_count - 1; i >= 0; i--) {
+	for (i = dc->res_pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		for (j = 0; j < surface_count; j++) {
@@ -1525,8 +1511,8 @@ void dc_update_planes_and_stream(struct dc *dc,
 			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
-			core_dc->hwss.pipe_control_lock(
-					core_dc,
+			dc->hwss.pipe_control_lock(
+					dc,
 					pipe_ctx,
 					false);
 
@@ -1534,7 +1520,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		}
 	}
 
-	if (core_dc->current_context != context) {
+	if (dc->current_context != context) {
 
 		/* Since memory free requires elevated IRQL, an interrupt
 		 * request is generated by mem free. If this happens
@@ -1544,9 +1530,9 @@ void dc_update_planes_and_stream(struct dc *dc,
 		 * then free the old context.
 		 */
 
-		struct validate_context *old = core_dc->current_context;
+		struct validate_context *old = dc->current_context;
 
-		core_dc->current_context = context;
+		dc->current_context = context;
 		dc_release_validate_context(old);
 
 	}
@@ -1561,29 +1547,25 @@ void dc_update_planes_and_stream(struct dc *dc,
 
 uint8_t dc_get_current_stream_count(struct dc *dc)
 {
-	struct dc *core_dc = dc;
-	return core_dc->current_context->stream_count;
+	return dc->current_context->stream_count;
 }
 
 struct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i)
 {
-	struct dc *core_dc = dc;
-	if (i < core_dc->current_context->stream_count)
-		return core_dc->current_context->streams[i];
+	if (i < dc->current_context->stream_count)
+		return dc->current_context->streams[i];
 	return NULL;
 }
 
 struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)
 {
-	struct dc  *core_dc = dc;
-	return core_dc->links[link_index];
+	return dc->links[link_index];
 }
 
 struct dwbc *dc_get_dwb_at_pipe(struct dc *dc, uint32_t pipe)
 {
-	struct dc *core_dc = dc;
 	if ((pipe >= dwb_pipe0) && (pipe < dwb_pipe_max_num)) {
-		return core_dc->res_pool->dwbc[(int)pipe];
+		return dc->res_pool->dwbc[(int)pipe];
 	} else {
 		return NULL;
 	}
@@ -1592,21 +1574,18 @@ struct dwbc *dc_get_dwb_at_pipe(struct dc *dc, uint32_t pipe)
 const struct graphics_object_id dc_get_link_id_at_index(
 	struct dc *dc, uint32_t link_index)
 {
-	struct dc *core_dc = dc;
-	return core_dc->links[link_index]->link_id;
+	return dc->links[link_index]->link_id;
 }
 
 enum dc_irq_source dc_get_hpd_irq_source_at_index(
 	struct dc *dc, uint32_t link_index)
 {
-	struct dc *core_dc = dc;
-	return core_dc->links[link_index]->irq_source_hpd;
+	return dc->links[link_index]->irq_source_hpd;
 }
 
 const struct audio **dc_get_audios(struct dc *dc)
 {
-	struct dc *core_dc = dc;
-	return (const struct audio **)core_dc->res_pool->audios;
+	return (const struct audio **)dc->res_pool->audios;
 }
 
 enum dc_irq_source dc_interrupt_to_irq_source(
@@ -1614,41 +1593,36 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 		uint32_t src_id,
 		uint32_t ext_id)
 {
-	struct dc *core_dc = dc;
-	return dal_irq_service_to_irq_source(core_dc->res_pool->irqs, src_id, ext_id);
+	return dal_irq_service_to_irq_source(dc->res_pool->irqs, src_id, ext_id);
 }
 
 void dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
 {
-	struct dc *core_dc;
 
 	if (dc == NULL)
 		return;
-	core_dc = dc;
 
-	dal_irq_service_set(core_dc->res_pool->irqs, src, enable);
+	dal_irq_service_set(dc->res_pool->irqs, src, enable);
 }
 
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 {
-	struct dc  *core_dc = dc;
-	dal_irq_service_ack(core_dc->res_pool->irqs, src);
+	dal_irq_service_ack(dc->res_pool->irqs, src);
 }
 
 void dc_set_power_state(
 	struct dc *dc,
 	enum dc_acpi_cm_power_state power_state)
 {
-	struct dc  *core_dc = dc;
 	atomic_t ref_count;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
-		core_dc->hwss.init_hw(core_dc);
+		dc->hwss.init_hw(dc);
 		break;
 	default:
 
-		core_dc->hwss.power_down(core_dc);
+		dc->hwss.power_down(dc);
 
 		/* Zero out the current context so that on resume we start with
 		 * clean state, and dc hw programming optimizations will not
@@ -1656,11 +1630,11 @@ void dc_set_power_state(
 		 */
 
 		/* Preserve refcount */
-		ref_count = core_dc->current_context->ref_count;
-		dc_resource_validate_ctx_destruct(core_dc->current_context);
-		memset(core_dc->current_context, 0,
-				sizeof(*core_dc->current_context));
-		core_dc->current_context->ref_count = ref_count;
+		ref_count = dc->current_context->ref_count;
+		dc_resource_validate_ctx_destruct(dc->current_context);
+		memset(dc->current_context, 0,
+				sizeof(*dc->current_context));
+		dc->current_context->ref_count = ref_count;
 
 		break;
 	}
@@ -1669,12 +1643,11 @@ void dc_set_power_state(
 
 void dc_resume(struct dc *dc)
 {
-	struct dc  *core_dc = dc;
 
 	uint32_t i;
 
-	for (i = 0; i < core_dc->link_count; i++)
-		core_link_resume(core_dc->links[i]);
+	for (i = 0; i < dc->link_count; i++)
+		core_link_resume(dc->links[i]);
 }
 
 bool dc_read_aux_dpcd(
@@ -1684,9 +1657,8 @@ bool dc_read_aux_dpcd(
 		uint8_t *data,
 		uint32_t size)
 {
-	struct dc  *core_dc = dc;
 
-	struct dc_link *link = core_dc->links[link_index];
+	struct dc_link *link = dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
 			link->ddc,
 			false,
@@ -1704,8 +1676,7 @@ bool dc_write_aux_dpcd(
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct dc  *core_dc = dc;
-	struct dc_link *link = core_dc->links[link_index];
+	struct dc_link *link = dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
@@ -1725,9 +1696,8 @@ bool dc_read_aux_i2c(
 		uint8_t *data,
 		uint32_t size)
 {
-	struct dc  *core_dc = dc;
 
-		struct dc_link *link = core_dc->links[link_index];
+		struct dc_link *link = dc->links[link_index];
 		enum ddc_result r = dal_ddc_service_read_dpcd_data(
 			link->ddc,
 			true,
@@ -1746,8 +1716,7 @@ bool dc_write_aux_i2c(
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct dc  *core_dc = dc;
-	struct dc_link *link = core_dc->links[link_index];
+	struct dc_link *link = dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
@@ -1768,9 +1737,8 @@ bool dc_query_ddc_data(
 		uint8_t *read_buf,
 		uint32_t read_size) {
 
-	struct dc  *core_dc = dc;
 
-	struct dc_link *link = core_dc->links[link_index];
+	struct dc_link *link = dc->links[link_index];
 
 	bool result = dal_ddc_service_query_ddc_data(
 			link->ddc,
@@ -1788,9 +1756,8 @@ bool dc_submit_i2c(
 		uint32_t link_index,
 		struct i2c_command *cmd)
 {
-	struct dc  *core_dc = dc;
 
-	struct dc_link *link = core_dc->links[link_index];
+	struct dc_link *link = dc->links[link_index];
 	struct ddc_service *ddc = link->ddc;
 
 	return dal_i2caux_submit_i2c_command(
@@ -1907,12 +1874,11 @@ void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 {
 	int i;
-	struct dc  *core_dc = dc;
 	struct mem_input *mi = NULL;
 
-	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
-		if (core_dc->res_pool->mis[i] != NULL) {
-			mi = core_dc->res_pool->mis[i];
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		if (dc->res_pool->mis[i] != NULL) {
+			mi = dc->res_pool->mis[i];
 			break;
 		}
 	}
@@ -1921,10 +1887,10 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 		return false;
 	}
 
-	if (core_dc->hwss.update_dchub)
-		core_dc->hwss.update_dchub(core_dc->hwseq, dh_data);
+	if (dc->hwss.update_dchub)
+		dc->hwss.update_dchub(dc->hwseq, dh_data);
 	else
-		ASSERT(core_dc->hwss.update_dchub);
+		ASSERT(dc->hwss.update_dchub);
 
 
 	return true;
@@ -1933,9 +1899,8 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 
 void dc_log_hw_state(struct dc *dc)
 {
-	struct dc *core_dc = dc;
 
-	if (core_dc->hwss.log_hw_state)
-		core_dc->hwss.log_hw_state(core_dc);
+	if (dc->hwss.log_hw_state)
+		dc->hwss.log_hw_state(dc);
 }
 

commit 19f89e2392e692208a0a00465d30b2b2bf43e9a9
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Aug 11 10:43:45 2017 -0400

    drm/amd/display: Per plane validation context build.
    
    Introduce add/remove plane to/from context.
    Make DC wrapper to use them in WIndows/Diags.
    Use them in dc_update_surface_to_stream.
    Call add/remove plane from Linux DM.
    
    Remove dc_validation_set from dc_validate_global_state interface
    and by this remove clean Linux DM from using it.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ab2b8f23b20a..79980cb0900c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1305,10 +1305,16 @@ void dc_update_planes_and_stream(struct dc *dc,
 		dc_resource_validate_ctx_copy_construct(
 				core_dc->current_context, context);
 
+		/*remove old surfaces from context */
+		if (!dc_rem_all_planes_for_stream(dc, stream, context)) {
+
+			BREAK_TO_DEBUGGER();
+			goto fail;
+		}
+
 		/* add surface to context */
-		if (!resource_attach_surfaces_to_context(
-				new_planes, surface_count, stream,
-				context, core_dc->res_pool)) {
+		if (!dc_add_all_planes_for_stream(dc, stream, new_planes, surface_count, context)) {
+
 			BREAK_TO_DEBUGGER();
 			goto fail;
 		}

commit 83a3d42d121301d26601ef7599052e1d78fde9fb
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Aug 21 16:28:39 2017 -0400

    drm/amd/display: Remove unneeded code
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e6cea839d283..ab2b8f23b20a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -670,67 +670,6 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
-static bool validate_streams (
-		struct dc *dc,
-		const struct dc_validation_set set[],
-		int set_count)
-{
-	int i;
-
-	for (i = 0; i < set_count; i++)
-		if (!dc_validate_stream(dc, set[i].stream))
-			return false;
-
-	return true;
-}
-
-static bool validate_surfaces(
-		struct dc *dc,
-		const struct dc_validation_set set[],
-		int set_count)
-{
-	int i, j;
-
-	for (i = 0; i < set_count; i++)
-		for (j = 0; j < set[i].plane_count; j++)
-			if (!dc_validate_plane(dc, set[i].plane_states[j]))
-				return false;
-
-	return true;
-}
-
-bool dc_validate_resources(
-		struct dc *dc,
-		const struct dc_validation_set set[],
-		uint8_t set_count)
-{
-	bool result = false;
-	struct validate_context *context;
-
-	if (!validate_streams(dc, set, set_count))
-		return false;
-
-	if (!validate_surfaces(dc, set, set_count))
-		return false;
-
-	context = dm_alloc(sizeof(struct validate_context));
-	if (context == NULL)
-		goto context_alloc_fail;
-
-	atomic_inc(&context->ref_count);
-
-	dc_resource_validate_ctx_copy_construct_current(dc, context);
-
-	result = dc_validate_with_context(
-				dc, set, set_count, context);
-
-context_alloc_fail:
-	dc_release_validate_context(context);
-	context = NULL;
-
-	return result;
-}
-
 bool dc_validate_guaranteed(
 		struct dc *dc,
 		struct dc_stream_state *stream)
@@ -855,24 +794,6 @@ static bool context_changed(
 	return false;
 }
 
-static bool streams_changed(
-		struct dc *dc,
-		struct dc_stream_state *streams[],
-		uint8_t stream_count)
-{
-	uint8_t i;
-
-	if (stream_count != dc->current_context->stream_count)
-		return true;
-
-	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (dc->current_context->streams[i] != streams[i])
-			return true;
-	}
-
-	return false;
-}
-
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
@@ -997,72 +918,6 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 }
 
 
-bool dc_commit_streams(
-	struct dc *dc,
-	struct dc_stream_state *streams[],
-	uint8_t stream_count)
-{
-	struct dc  *core_dc = dc;
-	bool result = false;
-	struct validate_context *context;
-	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
-	int i;
-
-	if (false == streams_changed(core_dc, streams, stream_count))
-		return DC_OK;
-
-	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
-				__func__, stream_count);
-
-	for (i = 0; i < stream_count; i++) {
-		struct dc_stream_state *stream = streams[i];
-		struct dc_stream_status *status = dc_stream_get_status(stream);
-		int j;
-
-		dc_stream_log(stream,
-				core_dc->ctx->logger,
-				LOG_DC);
-
-		set[i].stream = stream;
-
-		if (status) {
-			set[i].plane_count = status->plane_count;
-			for (j = 0; j < status->plane_count; j++)
-				set[i].plane_states[j] = status->plane_states[j];
-		}
-
-	}
-
-	if (!validate_streams(dc, set, stream_count))
-		return false;
-
-	if (!validate_surfaces(dc, set, stream_count))
-		return false;
-
-	context = dm_alloc(sizeof(struct validate_context));
-	if (context == NULL)
-		goto context_alloc_fail;
-
-	atomic_inc(&context->ref_count);
-
-	dc_resource_validate_ctx_copy_construct_current(dc, context);
-
-	result = dc_validate_with_context(
-			dc, set, stream_count, context);
-	if (!result) {
-		BREAK_TO_DEBUGGER();
-		goto fail;
-	}
-
-	result = dc_commit_context_no_check(dc, context);
-
-fail:
-	dc_release_validate_context(context);
-
-context_alloc_fail:
-	return result;
-}
-
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;

commit 7fb77c51f3b8e91499b6fd1973804c9230d2d8d3
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Aug 19 08:55:58 2017 -0400

    drm/amd/display: version 3.1.01
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 035c44e0e7d2..e6cea839d283 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -48,6 +48,9 @@
 #include "dm_helpers.h"
 #include "mem_input.h"
 
+
+char dc_ver[] = DC_VER;
+
 /*******************************************************************************
  * Private functions
  ******************************************************************************/

commit 57d972d4927581d027007c92b57b843c186128d4
Author: Roman Li <Roman.Li@amd.com>
Date:   Thu Aug 17 16:14:45 2017 -0400

    drm/amd/display: Fix FBC disable for stereo
    
    Removed FBC disable from dc_enable_stereo().
    It should be implemented in stereo_setup callback, which is not
    implemented yet. Otherwise it always disable FBC regardless
    if stereo supported or not.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8a6bd2917799..035c44e0e7d2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -881,10 +881,6 @@ bool dc_enable_stereo(
 	struct pipe_ctx *pipe;
 	struct dc  *core_dc = dc;
 
-#ifdef ENABLE_FBC
-	struct compressor *fbc_compressor = core_dc->fbc_compressor;
-#endif
-
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context != NULL)
 			pipe = &context->res_ctx.pipe_ctx[i];
@@ -897,13 +893,6 @@ bool dc_enable_stereo(
 		}
 	}
 
-#ifdef ENABLE_FBC
-	if (fbc_compressor != NULL &&
-	    fbc_compressor->funcs->is_fbc_enabled_in_hw(core_dc->fbc_compressor,
-							NULL))
-		fbc_compressor->funcs->disable_fbc(fbc_compressor);
-
-#endif
 	return ret;
 }
 

commit 81c90ec0348002b6f6b0c108e3e60e666cb4b673
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Thu Sep 7 16:46:34 2017 -0400

    drm/amd/display: Refactor dc_state creation into a function.
    
    For less repetition and easy debugging.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 10126d9a7233..8a6bd2917799 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -497,15 +497,13 @@ static bool construct(struct dc *dc,
 		goto fail;
 	}
 
-	dc->current_context = dm_alloc(sizeof(*dc->current_context));
+	dc->current_context = dc_create_state();
 
 	if (!dc->current_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
 		goto fail;
 	}
 
-	atomic_inc(&dc->current_context->ref_count);
-
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
 	dc_ctx->dc = dc;
@@ -1162,6 +1160,17 @@ bool dc_commit_planes_to_stream(
 	return true;
 }
 
+struct validate_context *dc_create_state(void)
+{
+	struct validate_context *context = dm_alloc(sizeof(struct validate_context));
+
+	if (!context)
+		return NULL;
+
+	atomic_inc(&context->ref_count);
+	return context;
+}
+
 void dc_retain_validate_context(struct validate_context *context)
 {
 	ASSERT(atomic_read(&context->ref_count) > 0);
@@ -1442,12 +1451,10 @@ void dc_update_planes_and_stream(struct dc *dc,
 			new_planes[i] = srf_updates[i].surface;
 
 		/* initialize scratch memory for building context */
-		context = dm_alloc(sizeof(*context));
+		context = dc_create_state();
 		if (context == NULL)
 				goto context_alloc_fail;
 
-		atomic_inc(&context->ref_count);
-
 		dc_resource_validate_ctx_copy_construct(
 				core_dc->current_context, context);
 

commit 1dc904974eb7deef924650adc5af542878ce2040
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Jul 31 11:29:25 2017 -0400

    drm/amd/display: Per stream validate_context build v2.
    
    Until now new context would start as empty, then populated
    with exsisting pipes + new. Now we start with duplication
    of existing context and then add/delete from the context
    pipes as needed.
    
    This allows to do a per stream resource
    population, start discarding dc_validation_set
    and by this brings DC closer to to DRM.
    
    v2: Add some fixes and rebase.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 44c7b52e4a00..10126d9a7233 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -669,41 +669,6 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
-static bool is_validation_required(
-		const struct dc *dc,
-		const struct dc_validation_set set[],
-		int set_count)
-{
-	const struct validate_context *context = dc->current_context;
-	int i, j;
-
-	if (context->stream_count != set_count)
-		return true;
-
-	for (i = 0; i < set_count; i++) {
-
-		if (set[i].plane_count != context->stream_status[i].plane_count)
-			return true;
-		if (!dc_is_stream_unchanged(set[i].stream, context->streams[i]))
-			return true;
-
-		for (j = 0; j < set[i].plane_count; j++) {
-			struct dc_plane_state temp_plane;
-			memset(&temp_plane, 0, sizeof(temp_plane));
-
-			temp_plane = *context->stream_status[i].plane_states[j];
-			temp_plane.clip_rect = set[i].plane_states[j]->clip_rect;
-			temp_plane.dst_rect.x = set[i].plane_states[j]->dst_rect.x;
-			temp_plane.dst_rect.y = set[i].plane_states[j]->dst_rect.y;
-
-			if (memcmp(&temp_plane, set[i].plane_states[j], sizeof(temp_plane)) != 0)
-				return true;
-		}
-	}
-
-	return false;
-}
-
 static bool validate_streams (
 		struct dc *dc,
 		const struct dc_validation_set set[],
@@ -733,52 +698,12 @@ static bool validate_surfaces(
 	return true;
 }
 
-struct validate_context *dc_get_validate_context(
-		struct dc *dc,
-		const struct dc_validation_set set[],
-		uint8_t set_count)
-{
-	struct dc *core_dc = dc;
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct validate_context *context;
-
-
-	context = dm_alloc(sizeof(struct validate_context));
-	if (context == NULL)
-		goto context_alloc_fail;
-
-	atomic_inc(&context->ref_count);
-
-	if (!is_validation_required(core_dc, set, set_count)) {
-		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
-		return context;
-	}
-
-	result = core_dc->res_pool->funcs->validate_with_context(
-			core_dc, set, set_count, context, core_dc->current_context);
-
-context_alloc_fail:
-	if (result != DC_OK) {
-		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
-				"%s:resource validation failed, dc_status:%d\n",
-				__func__,
-				result);
-
-		dc_release_validate_context(context);
-		context = NULL;
-	}
-
-	return context;
-
-}
-
 bool dc_validate_resources(
 		struct dc *dc,
 		const struct dc_validation_set set[],
 		uint8_t set_count)
 {
-	struct dc  *core_dc = dc;
-	enum dc_status result = DC_ERROR_UNEXPECTED;
+	bool result = false;
 	struct validate_context *context;
 
 	if (!validate_streams(dc, set, set_count))
@@ -793,21 +718,16 @@ bool dc_validate_resources(
 
 	atomic_inc(&context->ref_count);
 
-	result = core_dc->res_pool->funcs->validate_with_context(
-				core_dc, set, set_count, context, NULL);
+	dc_resource_validate_ctx_copy_construct_current(dc, context);
 
-context_alloc_fail:
-	if (result != DC_OK) {
-		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
-				"%s:resource validation failed, dc_status:%d\n",
-				__func__,
-				result);
-	}
+	result = dc_validate_with_context(
+				dc, set, set_count, context);
 
+context_alloc_fail:
 	dc_release_validate_context(context);
 	context = NULL;
 
-	return result == DC_OK;
+	return result;
 }
 
 bool dc_validate_guaranteed(
@@ -1093,7 +1013,7 @@ bool dc_commit_streams(
 	uint8_t stream_count)
 {
 	struct dc  *core_dc = dc;
-	enum dc_status result = DC_ERROR_UNEXPECTED;
+	bool result = false;
 	struct validate_context *context;
 	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
 	int i;
@@ -1135,13 +1055,11 @@ bool dc_commit_streams(
 
 	atomic_inc(&context->ref_count);
 
-	result = core_dc->res_pool->funcs->validate_with_context(
-			core_dc, set, stream_count, context, core_dc->current_context);
-	if (result != DC_OK){
-		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
-					"%s: Context validation failed! dc_status:%d\n",
-					__func__,
-					result);
+	dc_resource_validate_ctx_copy_construct_current(dc, context);
+
+	result = dc_validate_with_context(
+			dc, set, stream_count, context);
+	if (!result) {
 		BREAK_TO_DEBUGGER();
 		goto fail;
 	}
@@ -1152,7 +1070,7 @@ bool dc_commit_streams(
 	dc_release_validate_context(context);
 
 context_alloc_fail:
-	return (result == DC_OK);
+	return result;
 }
 
 bool dc_post_update_surfaces_to_stream(struct dc *dc)

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 40d65b758994..44c7b52e4a00 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -35,7 +35,6 @@
 #include "clock_source.h"
 #include "dc_bios_types.h"
 
-#include "dce_calcs.h"
 #include "bios_parser_interface.h"
 #include "include/irq_service_interface.h"
 #include "transform.h"
@@ -52,7 +51,7 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static void destroy_links(struct core_dc *dc)
+static void destroy_links(struct dc *dc)
 {
 	uint32_t i;
 
@@ -63,7 +62,7 @@ static void destroy_links(struct core_dc *dc)
 }
 
 static bool create_links(
-		struct core_dc *dc,
+		struct dc *dc,
 		uint32_t num_virtual_links)
 {
 	int i;
@@ -153,7 +152,7 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
@@ -179,7 +178,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
@@ -202,7 +201,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 
 static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
@@ -220,7 +219,7 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 
 static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
@@ -245,7 +244,7 @@ static void set_static_screen_events(struct dc *dc,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i = 0;
 	int j = 0;
 	struct pipe_ctx *pipes_affected[MAX_PIPES];
@@ -270,7 +269,7 @@ static void set_drive_settings(struct dc *dc,
 		struct link_training_settings *lt_settings,
 		const struct dc_link *link)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i;
 
 	for (i = 0; i < core_dc->link_count; i++) {
@@ -288,7 +287,7 @@ static void perform_link_training(struct dc *dc,
 		struct dc_link_settings *link_setting,
 		bool skip_video_pattern)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i;
 
 	for (i = 0; i < core_dc->link_count; i++)
@@ -369,48 +368,48 @@ void set_dither_option(struct dc_stream_state *stream,
 		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }
 
-static void allocate_dc_stream_funcs(struct core_dc *core_dc)
+static void allocate_dc_stream_funcs(struct dc  *core_dc)
 {
 	if (core_dc->hwss.set_drr != NULL) {
-		core_dc->public.stream_funcs.adjust_vmin_vmax =
+		core_dc->stream_funcs.adjust_vmin_vmax =
 				stream_adjust_vmin_vmax;
 	}
 
-	core_dc->public.stream_funcs.set_static_screen_events =
+	core_dc->stream_funcs.set_static_screen_events =
 			set_static_screen_events;
 
-	core_dc->public.stream_funcs.get_crtc_position =
+	core_dc->stream_funcs.get_crtc_position =
 			stream_get_crtc_position;
 
-	core_dc->public.stream_funcs.set_gamut_remap =
+	core_dc->stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
-	core_dc->public.stream_funcs.program_csc_matrix =
+	core_dc->stream_funcs.program_csc_matrix =
 			program_csc_matrix;
 
-	core_dc->public.stream_funcs.set_dither_option =
+	core_dc->stream_funcs.set_dither_option =
 			set_dither_option;
 
-	core_dc->public.link_funcs.set_drive_settings =
+	core_dc->link_funcs.set_drive_settings =
 			set_drive_settings;
 
-	core_dc->public.link_funcs.perform_link_training =
+	core_dc->link_funcs.perform_link_training =
 			perform_link_training;
 
-	core_dc->public.link_funcs.set_preferred_link_settings =
+	core_dc->link_funcs.set_preferred_link_settings =
 			set_preferred_link_settings;
 
-	core_dc->public.link_funcs.enable_hpd =
+	core_dc->link_funcs.enable_hpd =
 			enable_hpd;
 
-	core_dc->public.link_funcs.disable_hpd =
+	core_dc->link_funcs.disable_hpd =
 			disable_hpd;
 
-	core_dc->public.link_funcs.set_test_pattern =
+	core_dc->link_funcs.set_test_pattern =
 			set_test_pattern;
 }
 
-static void destruct(struct core_dc *dc)
+static void destruct(struct dc *dc)
 {
 	dc_release_validate_context(dc->current_context);
 	dc->current_context = NULL;
@@ -446,10 +445,11 @@ static void destruct(struct core_dc *dc)
 
 	dm_free(dc->dcn_ip);
 	dc->dcn_ip = NULL;
+
 #endif
 }
 
-static bool construct(struct core_dc *dc,
+static bool construct(struct dc *dc,
 		const struct dc_init_data *init_params)
 {
 	struct dal_logger *logger;
@@ -508,7 +508,7 @@ static bool construct(struct core_dc *dc,
 
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
-	dc_ctx->dc = &dc->public;
+	dc_ctx->dc = dc;
 	dc_ctx->asic_id = init_params->asic_id;
 
 	/* Create logger */
@@ -621,7 +621,7 @@ void ProgramPixelDurationV(unsigned int pixelClockInKHz )
 
 struct dc *dc_create(const struct dc_init_data *init_params)
  {
-	struct core_dc *core_dc = dm_alloc(sizeof(*core_dc));
+	struct dc *core_dc = dm_alloc(sizeof(*core_dc));
 	unsigned int full_pipe_count;
 
 	if (NULL == core_dc)
@@ -636,23 +636,23 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	full_pipe_count = core_dc->res_pool->pipe_count;
 	if (core_dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
 		full_pipe_count--;
-	core_dc->public.caps.max_streams = min(
+	core_dc->caps.max_streams = min(
 			full_pipe_count,
 			core_dc->res_pool->stream_enc_count);
 
-	core_dc->public.caps.max_links = core_dc->link_count;
-	core_dc->public.caps.max_audios = core_dc->res_pool->audio_count;
+	core_dc->caps.max_links = core_dc->link_count;
+	core_dc->caps.max_audios = core_dc->res_pool->audio_count;
 
-	core_dc->public.config = init_params->flags;
+	core_dc->config = init_params->flags;
 
 	dm_logger_write(core_dc->ctx->logger, LOG_DC,
 			"Display Core initialized\n");
 
 
 	/* TODO: missing feature to be enabled */
-	core_dc->public.debug.disable_dfs_bypass = true;
+	core_dc->debug.disable_dfs_bypass = true;
 
-	return &core_dc->public;
+	return core_dc;
 
 construct_fail:
 	dm_free(core_dc);
@@ -663,14 +663,14 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 
 void dc_destroy(struct dc **dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(*dc);
+	struct dc  *core_dc = *dc;
 	destruct(core_dc);
 	dm_free(core_dc);
 	*dc = NULL;
 }
 
 static bool is_validation_required(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		const struct dc_validation_set set[],
 		int set_count)
 {
@@ -705,7 +705,7 @@ static bool is_validation_required(
 }
 
 static bool validate_streams (
-		const struct dc *dc,
+		struct dc *dc,
 		const struct dc_validation_set set[],
 		int set_count)
 {
@@ -719,7 +719,7 @@ static bool validate_streams (
 }
 
 static bool validate_surfaces(
-		const struct dc *dc,
+		struct dc *dc,
 		const struct dc_validation_set set[],
 		int set_count)
 {
@@ -734,11 +734,11 @@ static bool validate_surfaces(
 }
 
 struct validate_context *dc_get_validate_context(
-		const struct dc *dc,
+		struct dc *dc,
 		const struct dc_validation_set set[],
 		uint8_t set_count)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
@@ -773,11 +773,11 @@ struct validate_context *dc_get_validate_context(
 }
 
 bool dc_validate_resources(
-		const struct dc *dc,
+		struct dc *dc,
 		const struct dc_validation_set set[],
 		uint8_t set_count)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
@@ -811,10 +811,10 @@ bool dc_validate_resources(
 }
 
 bool dc_validate_guaranteed(
-		const struct dc *dc,
+		struct dc *dc,
 		struct dc_stream_state *stream)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
@@ -844,7 +844,7 @@ bool dc_validate_guaranteed(
 }
 
 static void program_timing_sync(
-		struct core_dc *core_dc,
+		struct dc *core_dc,
 		struct validate_context *ctx)
 {
 	int i, j;
@@ -918,7 +918,7 @@ static void program_timing_sync(
 }
 
 static bool context_changed(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct validate_context *context)
 {
 	uint8_t i;
@@ -935,7 +935,7 @@ static bool context_changed(
 }
 
 static bool streams_changed(
-		struct core_dc *dc,
+		struct dc *dc,
 		struct dc_stream_state *streams[],
 		uint8_t stream_count)
 {
@@ -961,7 +961,7 @@ bool dc_enable_stereo(
 	bool ret = true;
 	int i, j;
 	struct pipe_ctx *pipe;
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 #ifdef ENABLE_FBC
 	struct compressor *fbc_compressor = core_dc->fbc_compressor;
@@ -996,7 +996,7 @@ bool dc_enable_stereo(
  */
 static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *context)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
@@ -1064,7 +1064,7 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 bool dc_commit_context(struct dc *dc, struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i;
 
 	if (false == context_changed(core_dc, context))
@@ -1092,7 +1092,7 @@ bool dc_commit_streams(
 	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
@@ -1158,7 +1158,7 @@ bool dc_commit_streams(
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct validate_context *context = core_dc->current_context;
 
 	post_surface_trace(dc);
@@ -1375,7 +1375,7 @@ static enum surface_update_type  get_scaling_info_update_type(
 }
 
 static enum surface_update_type det_surface_update(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		const struct dc_surface_update *u,
 		int surface_index)
 {
@@ -1410,7 +1410,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc_stream_update *stream_update,
 		const struct dc_stream_status *stream_status)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
@@ -1456,7 +1456,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct validate_context *context;
 	int i, j;
 	enum surface_update_type update_type;
@@ -1781,29 +1781,29 @@ void dc_update_planes_and_stream(struct dc *dc,
 	DC_ERROR("Failed to allocate new validate context!\n");
 }
 
-uint8_t dc_get_current_stream_count(const struct dc *dc)
+uint8_t dc_get_current_stream_count(struct dc *dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	return core_dc->current_context->stream_count;
 }
 
-struct dc_stream_state *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
+struct dc_stream_state *dc_get_stream_at_index(struct dc *dc, uint8_t i)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	if (i < core_dc->current_context->stream_count)
 		return core_dc->current_context->streams[i];
 	return NULL;
 }
 
-struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
+struct dc_link *dc_get_link_at_index(struct dc *dc, uint32_t link_index)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	return core_dc->links[link_index];
 }
 
-struct dwbc *dc_get_dwb_at_pipe(const struct dc *dc, uint32_t pipe)
+struct dwbc *dc_get_dwb_at_pipe(struct dc *dc, uint32_t pipe)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	if ((pipe >= dwb_pipe0) && (pipe < dwb_pipe_max_num)) {
 		return core_dc->res_pool->dwbc[(int)pipe];
 	} else {
@@ -1814,20 +1814,20 @@ struct dwbc *dc_get_dwb_at_pipe(const struct dc *dc, uint32_t pipe)
 const struct graphics_object_id dc_get_link_id_at_index(
 	struct dc *dc, uint32_t link_index)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	return core_dc->links[link_index]->link_id;
 }
 
 enum dc_irq_source dc_get_hpd_irq_source_at_index(
 	struct dc *dc, uint32_t link_index)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	return core_dc->links[link_index]->irq_source_hpd;
 }
 
 const struct audio **dc_get_audios(struct dc *dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	return (const struct audio **)core_dc->res_pool->audios;
 }
 
@@ -1836,24 +1836,24 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 		uint32_t src_id,
 		uint32_t ext_id)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 	return dal_irq_service_to_irq_source(core_dc->res_pool->irqs, src_id, ext_id);
 }
 
-void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable)
+void dc_interrupt_set(struct dc *dc, enum dc_irq_source src, bool enable)
 {
-	struct core_dc *core_dc;
+	struct dc *core_dc;
 
 	if (dc == NULL)
 		return;
-	core_dc = DC_TO_CORE(dc);
+	core_dc = dc;
 
 	dal_irq_service_set(core_dc->res_pool->irqs, src, enable);
 }
 
 void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	dal_irq_service_ack(core_dc->res_pool->irqs, src);
 }
 
@@ -1861,7 +1861,7 @@ void dc_set_power_state(
 	struct dc *dc,
 	enum dc_acpi_cm_power_state power_state)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	atomic_t ref_count;
 
 	switch (power_state) {
@@ -1889,9 +1889,9 @@ void dc_set_power_state(
 
 }
 
-void dc_resume(const struct dc *dc)
+void dc_resume(struct dc *dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 	uint32_t i;
 
@@ -1906,7 +1906,7 @@ bool dc_read_aux_dpcd(
 		uint8_t *data,
 		uint32_t size)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 	struct dc_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
@@ -1926,7 +1926,7 @@ bool dc_write_aux_dpcd(
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
@@ -1947,7 +1947,7 @@ bool dc_read_aux_i2c(
 		uint8_t *data,
 		uint32_t size)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 		struct dc_link *link = core_dc->links[link_index];
 		enum ddc_result r = dal_ddc_service_read_dpcd_data(
@@ -1968,7 +1968,7 @@ bool dc_write_aux_i2c(
 		const uint8_t *data,
 		uint32_t size)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
@@ -1990,7 +1990,7 @@ bool dc_query_ddc_data(
 		uint8_t *read_buf,
 		uint32_t read_size) {
 
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 	struct dc_link *link = core_dc->links[link_index];
 
@@ -2010,7 +2010,7 @@ bool dc_submit_i2c(
 		uint32_t link_index,
 		struct i2c_command *cmd)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 
 	struct dc_link *link = core_dc->links[link_index];
 	struct ddc_service *ddc = link->ddc;
@@ -2129,7 +2129,7 @@ void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 {
 	int i;
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct mem_input *mi = NULL;
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
@@ -2155,7 +2155,7 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 
 void dc_log_hw_state(struct dc *dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 
 	if (core_dc->hwss.log_hw_state)
 		core_dc->hwss.log_hw_state(core_dc);

commit 65111f25f1fea751f3b4321a59c993c2898b7dbf
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Aug 3 13:02:29 2017 -0400

    drm/amd/display: change dcn_ip and dcn_soc into pointers
    
    -Change dcn_ip into pointer
    -Change dcn_soc into pointer
    
    This is needed for flattening of core_dc into dc, as without
    this the diags build fails
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 33c3d88b1c86..40d65b758994 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -440,6 +440,13 @@ static void destruct(struct core_dc *dc)
 	dm_free(dc->bw_dceip);
 	dc->bw_dceip = NULL;
 
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+	dm_free(dc->dcn_soc);
+	dc->dcn_soc = NULL;
+
+	dm_free(dc->dcn_ip);
+	dc->dcn_ip = NULL;
+#endif
 }
 
 static bool construct(struct core_dc *dc,
@@ -449,33 +456,52 @@ static bool construct(struct core_dc *dc,
 	struct dc_context *dc_ctx = dm_alloc(sizeof(*dc_ctx));
 	struct bw_calcs_dceip *dc_dceip = dm_alloc(sizeof(*dc_dceip));
 	struct bw_calcs_vbios *dc_vbios = dm_alloc(sizeof(*dc_vbios));
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+	struct dcn_soc_bounding_box *dcn_soc = dm_alloc(sizeof(*dcn_soc));
+	struct dcn_ip_params *dcn_ip = dm_alloc(sizeof(*dcn_ip));
+#endif
 
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 
 	if (!dc_dceip) {
 		dm_error("%s: failed to create dceip\n", __func__);
-		goto dceip_fail;
+		goto fail;
 	}
 
 	dc->bw_dceip = dc_dceip;
 
 	if (!dc_vbios) {
 		dm_error("%s: failed to create vbios\n", __func__);
-		goto vbios_fail;
+		goto fail;
 	}
 
 	dc->bw_vbios = dc_vbios;
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+	if (!dcn_soc) {
+		dm_error("%s: failed to create dcn_soc\n", __func__);
+		goto fail;
+	}
+
+	dc->dcn_soc = dcn_soc;
+
+	if (!dcn_ip) {
+		dm_error("%s: failed to create dcn_ip\n", __func__);
+		goto fail;
+	}
+
+	dc->dcn_ip = dcn_ip;
+#endif
 
 	if (!dc_ctx) {
 		dm_error("%s: failed to create ctx\n", __func__);
-		goto ctx_fail;
+		goto fail;
 	}
 
 	dc->current_context = dm_alloc(sizeof(*dc->current_context));
 
 	if (!dc->current_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
-		goto val_ctx_fail;
+		goto fail;
 	}
 
 	atomic_inc(&dc->current_context->ref_count);
@@ -491,7 +517,7 @@ static bool construct(struct core_dc *dc,
 	if (!logger) {
 		/* can *not* call logger. call base driver 'print error' */
 		dm_error("%s: failed to create Logger!\n", __func__);
-		goto logger_fail;
+		goto fail;
 	}
 	dc_ctx->logger = logger;
 	dc->ctx = dc_ctx;
@@ -519,7 +545,7 @@ static bool construct(struct core_dc *dc,
 
 		if (!dc_ctx->dc_bios) {
 			ASSERT_CRITICAL(false);
-			goto bios_fail;
+			goto fail;
 		}
 
 		dc_ctx->created_bios = true;
@@ -530,7 +556,7 @@ static bool construct(struct core_dc *dc,
 
 	if (!dc_ctx->i2caux) {
 		ASSERT_CRITICAL(false);
-		goto failed_to_create_i2caux;
+		goto fail;
 	}
 
 	/* Create GPIO service */
@@ -541,7 +567,7 @@ static bool construct(struct core_dc *dc,
 
 	if (!dc_ctx->gpio_service) {
 		ASSERT_CRITICAL(false);
-		goto gpio_fail;
+		goto fail;
 	}
 
 	dc->res_pool = dc_create_resource_pool(
@@ -550,26 +576,17 @@ static bool construct(struct core_dc *dc,
 			dc_version,
 			init_params->asic_id);
 	if (!dc->res_pool)
-		goto create_resource_fail;
+		goto fail;
 
 	if (!create_links(dc, init_params->num_virtual_links))
-		goto create_links_fail;
+		goto fail;
 
 	allocate_dc_stream_funcs(dc);
 
 	return true;
 
-	/**** error handling here ****/
-create_links_fail:
-create_resource_fail:
-gpio_fail:
-failed_to_create_i2caux:
-bios_fail:
-logger_fail:
-val_ctx_fail:
-ctx_fail:
-dceip_fail:
-vbios_fail:
+fail:
+
 	destruct(dc);
 	return false;
 }

commit e771aae02baa59386972faec491cd221c169ed53
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Wed Aug 9 10:30:28 2017 -0400

    drm/amd/display: Add comment explaining context free
    
    This comment explains a previous change that adds some complexity
    to the context free in dc:
    
    commit 9ad58779a895 ("drm/amd/display: Fix accessing freed memory")
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 477024c467e6..33c3d88b1c86 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1740,6 +1740,15 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	if (core_dc->current_context != context) {
+
+		/* Since memory free requires elevated IRQL, an interrupt
+		 * request is generated by mem free. If this happens
+		 * between freeing and reassigning the context, our vsync
+		 * interrupt will call into dc and cause a memory
+		 * corruption BSOD. Hence, we first reassign the context,
+		 * then free the old context.
+		 */
+
 		struct validate_context *old = core_dc->current_context;
 
 		core_dc->current_context = context;

commit 77a4ea53fd89ccf823e77cc31cea808a3589f732
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Aug 2 16:56:03 2017 -0400

    drm/amd/display: change bw_dceip and bw_vbios into pointers
    
    -Change bw_calcs_dceip into pointer
    -Change bw_calcs_vbios into pointer
    
    This is needed for flattening of core_dc into dc, as without this the
    diags build fails
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index aeed95a5d097..477024c467e6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -433,6 +433,13 @@ static void destruct(struct core_dc *dc)
 
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
+
+	dm_free(dc->bw_vbios);
+	dc->bw_vbios = NULL;
+
+	dm_free(dc->bw_dceip);
+	dc->bw_dceip = NULL;
+
 }
 
 static bool construct(struct core_dc *dc,
@@ -440,8 +447,25 @@ static bool construct(struct core_dc *dc,
 {
 	struct dal_logger *logger;
 	struct dc_context *dc_ctx = dm_alloc(sizeof(*dc_ctx));
+	struct bw_calcs_dceip *dc_dceip = dm_alloc(sizeof(*dc_dceip));
+	struct bw_calcs_vbios *dc_vbios = dm_alloc(sizeof(*dc_vbios));
+
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
 
+	if (!dc_dceip) {
+		dm_error("%s: failed to create dceip\n", __func__);
+		goto dceip_fail;
+	}
+
+	dc->bw_dceip = dc_dceip;
+
+	if (!dc_vbios) {
+		dm_error("%s: failed to create vbios\n", __func__);
+		goto vbios_fail;
+	}
+
+	dc->bw_vbios = dc_vbios;
+
 	if (!dc_ctx) {
 		dm_error("%s: failed to create ctx\n", __func__);
 		goto ctx_fail;
@@ -544,6 +568,8 @@ static bool construct(struct core_dc *dc,
 logger_fail:
 val_ctx_fail:
 ctx_fail:
+dceip_fail:
+vbios_fail:
 	destruct(dc);
 	return false;
 }

commit 391e20d84104a6b7b9d4a66fec6a7eb0a93f6ef4
Author: Duke Du <Duke.Du@amd.com>
Date:   Thu Aug 3 10:20:52 2017 -0400

    drm/amd/display: add display write back(DWB)
    
    Signed-off-by: Duke Du <Duke.Du@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8efdd05841e1..aeed95a5d097 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1749,6 +1749,16 @@ struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
 	return core_dc->links[link_index];
 }
 
+struct dwbc *dc_get_dwb_at_pipe(const struct dc *dc, uint32_t pipe)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	if ((pipe >= dwb_pipe0) && (pipe < dwb_pipe_max_num)) {
+		return core_dc->res_pool->dwbc[(int)pipe];
+	} else {
+		return NULL;
+	}
+}
+
 const struct graphics_object_id dc_get_link_id_at_index(
 	struct dc *dc, uint32_t link_index)
 {

commit e8cd26434df0cd8d97f31aeb4399afcdc37fcfda
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Mon Jul 31 17:10:44 2017 -0400

    drm/amd/display: Use atomic types for ref_count
    
    Current ref_count inc/dec is not guarded by locks which leads to
    a raced condition where two threads try to access the variable
    at the same time. In this case, both might act on the same cached
    value and inc/dec from the same value, rather than inc/dec by 2.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b69a726717d9..8efdd05841e1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -454,7 +454,7 @@ static bool construct(struct core_dc *dc,
 		goto val_ctx_fail;
 	}
 
-	dc->current_context->ref_count++;
+	atomic_inc(&dc->current_context->ref_count);
 
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
@@ -704,7 +704,7 @@ struct validate_context *dc_get_validate_context(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	++context->ref_count;
+	atomic_inc(&context->ref_count);
 
 	if (!is_validation_required(core_dc, set, set_count)) {
 		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
@@ -748,7 +748,7 @@ bool dc_validate_resources(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	++context->ref_count;
+	atomic_inc(&context->ref_count);
 
 	result = core_dc->res_pool->funcs->validate_with_context(
 				core_dc, set, set_count, context, NULL);
@@ -782,7 +782,7 @@ bool dc_validate_guaranteed(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	++context->ref_count;
+	atomic_inc(&context->ref_count);
 
 	result = core_dc->res_pool->funcs->validate_guaranteed(
 					core_dc, stream, context);
@@ -1090,7 +1090,7 @@ bool dc_commit_streams(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	++context->ref_count;
+	atomic_inc(&context->ref_count);
 
 	result = core_dc->res_pool->funcs->validate_with_context(
 			core_dc, set, stream_count, context, core_dc->current_context);
@@ -1203,16 +1203,16 @@ bool dc_commit_planes_to_stream(
 
 void dc_retain_validate_context(struct validate_context *context)
 {
-	ASSERT(context->ref_count > 0);
-	++context->ref_count;
+	ASSERT(atomic_read(&context->ref_count) > 0);
+	atomic_inc(&context->ref_count);
 }
 
 void dc_release_validate_context(struct validate_context *context)
 {
-	ASSERT(context->ref_count > 0);
-	--context->ref_count;
+	ASSERT(atomic_read(&context->ref_count) > 0);
+	atomic_dec(&context->ref_count);
 
-	if (context->ref_count == 0) {
+	if (atomic_read(&context->ref_count) == 0) {
 		dc_resource_validate_ctx_destruct(context);
 		dm_free(context);
 	}
@@ -1485,7 +1485,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 		if (context == NULL)
 				goto context_alloc_fail;
 
-		++context->ref_count;
+		atomic_inc(&context->ref_count);
 
 		dc_resource_validate_ctx_copy_construct(
 				core_dc->current_context, context);
@@ -1800,7 +1800,7 @@ void dc_set_power_state(
 	enum dc_acpi_cm_power_state power_state)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int ref_count;
+	atomic_t ref_count;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:

commit 5aa72db72ccc08c2d3d3e4b0a285bab932db5132
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Thu Aug 3 18:29:42 2017 -0400

    drm/amd/display: Fix accessing freed memory
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f305780c36ce..b69a726717d9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1714,8 +1714,11 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	if (core_dc->current_context != context) {
-		dc_release_validate_context(core_dc->current_context);
+		struct validate_context *old = core_dc->current_context;
+
 		core_dc->current_context = context;
+		dc_release_validate_context(old);
+
 	}
 	return;
 

commit 3e9ad6164b98f82ff4b191980c502f09fee4deef
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Aug 3 00:22:25 2017 -0400

    drm/amd/display: add programming for 0 plane case
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 748e709c611f..f305780c36ce 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -978,10 +978,10 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		const struct dc_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].plane_count; j++) {
-			const struct dc_plane_state *plane_state =
-					context->stream_status[i].plane_states[j];
-
-			core_dc->hwss.apply_ctx_for_surface(core_dc, plane_state, context);
+			core_dc->hwss.apply_ctx_for_surface(
+					core_dc, context->streams[i],
+					context->stream_status[i].plane_count,
+					context);
 
 			/*
 			 * enable stereo
@@ -1391,6 +1391,21 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	return overall_type;
 }
 
+static struct dc_stream_status *stream_get_status(
+	struct validate_context *ctx,
+	struct dc_stream_state *stream)
+{
+	uint8_t i;
+
+	for (i = 0; i < ctx->stream_count; i++) {
+		if (stream == ctx->streams[i]) {
+			return &ctx->stream_status[i];
+		}
+	}
+
+	return NULL;
+}
+
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_planes_and_stream(struct dc *dc,
@@ -1405,16 +1420,6 @@ void dc_update_planes_and_stream(struct dc *dc,
 	const struct dc_stream_status *stream_status;
 	struct dc_context *dc_ctx = core_dc->ctx;
 
-	/* Currently this function do not result in any HW programming
-	 * when called with 0 surface. But proceeding will cause
-	 * SW state to be updated in validate_context. So we might as
-	 * well make it not do anything at all until the hw programming
-	 * is implemented properly to handle 0 surface case.
-	 * TODO: fix hw programming then remove this early return
-	 */
-	if (surface_count == 0)
-		return;
-
 	stream_status = dc_stream_get_status(stream);
 
 	ASSERT(stream_status);
@@ -1595,7 +1600,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 	}
 
 	if (surface_count == 0)
-		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
+		core_dc->hwss.apply_ctx_for_surface(core_dc, stream, surface_count, context);
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
@@ -1625,12 +1630,16 @@ void dc_update_planes_and_stream(struct dc *dc,
 		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
+
 		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
 			continue;
 
-		if (!pipe_ctx->top_pipe)
+		if (!pipe_ctx->top_pipe && pipe_ctx->stream) {
+			struct dc_stream_status *stream_status = stream_get_status(context, pipe_ctx->stream);
+
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, pipe_ctx->plane_state, context);
+					core_dc, pipe_ctx->stream, stream_status->plane_count, context);
+		}
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
@@ -1653,7 +1662,7 @@ void dc_update_planes_and_stream(struct dc *dc,
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, plane_state, context);
+					core_dc, stream, surface_count, context);
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];

commit 8e9c4c8cf35ff23aafc69f9ef4c9cc471dac4094
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:36:12 2017 -0400

    drm/amd/display: Move stream_enc to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->stream_enc/pipes->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->stream_enc->/ctx->stream_res\.stream_enc->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->stream_enc/pipe->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->stream_enc/pipe_ctx->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.stream_enc/pipe_ctx\[pipe_offset\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->stream_enc/grouped_pipes\[i\]->stream_^Cs\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->stream_enc/grouped_pipes\[0\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->stream_enc/grouped_pipes\[1\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->stream_enc/pipe_ctx\[i\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->stream_enc/pipe_ctx_old->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->stream_enc/pipe_set\[j\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.stream_enc/pipe_ctx\[i\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.stream_enc/pipes\[i\]\.stream_res\.stream_enc/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 61c2a210c123..748e709c611f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -161,7 +161,7 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == stream && pipe->stream_enc) {
+		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
 			core_dc->hwss.set_drr(&pipe, 1, vmin, vmax);
 
 			/* build and update the info frame */
@@ -189,7 +189,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 		struct pipe_ctx *pipe =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == stream && pipe->stream_enc) {
+		if (pipe->stream == stream && pipe->stream_res.stream_enc) {
 			core_dc->hwss.get_position(&pipe, 1, &position);
 
 			*v_pos = position.vertical_count;

commit 6b670fa965b620bf0131a0a339a388a0581bc466
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:59:26 2017 -0400

    drm/amd/display: Move TG to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->tg/pipes->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->tg->/ctx->stream_res\.tg->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->tg/pipe->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->tg/pipe_ctx->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.tg/pipe_ctx\[pipe_offset\]\.stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[i\]->tg/grouped_pipes\[i\]->stream_^Cs\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[0\]->tg/grouped_pipes\[0\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[1\]->tg/grouped_pipes\[1\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]->tg/pipe_ctx\[i\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx_old->tg/pipe_ctx_old->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_set\[j\]->tg/pipe_set\[j\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]\.tg/pipe_ctx\[i\]\.stream_res\.tg/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 507732e4b67b..61c2a210c123 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -846,7 +846,7 @@ static void program_timing_sync(
 		for (j = 0; j < group_size; j++) {
 			struct pipe_ctx *temp;
 
-			if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
+			if (!pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
 				if (j == 0)
 					break;
 
@@ -859,7 +859,7 @@ static void program_timing_sync(
 
 		/* remove any other unblanked pipes as they have already been synced */
 		for (j = j + 1; j < group_size; j++) {
-			if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
+			if (!pipe_set[j]->stream_res.tg->funcs->is_blanked(pipe_set[j]->stream_res.tg)) {
 				group_size--;
 				pipe_set[j] = pipe_set[group_size];
 				j--;

commit a6a6cb349e39ef23a341a17752eebf69a5c0d7ff
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:55:28 2017 -0400

    drm/amd/display: Move OPP to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->opp/pipes->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->opp->/ctx->stream_res\.opp->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->opp/pipe->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->opp/pipe_ctx->stream_res\.opp/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ffc9c05e2fb5..507732e4b67b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -365,8 +365,8 @@ void set_dither_option(struct dc_stream_state *stream,
 	resource_build_bit_depth_reduction_params(stream,
 				&params);
 	stream->bit_depth_params = params;
-	pipes->opp->funcs->
-		opp_program_bit_depth_reduction(pipes->opp, &params);
+	pipes->stream_res.opp->funcs->
+		opp_program_bit_depth_reduction(pipes->stream_res.opp, &params);
 }
 
 static void allocate_dc_stream_funcs(struct core_dc *core_dc)

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8b6b7631d776..ffc9c05e2fb5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -639,21 +639,21 @@ static bool is_validation_required(
 
 	for (i = 0; i < set_count; i++) {
 
-		if (set[i].surface_count != context->stream_status[i].surface_count)
+		if (set[i].plane_count != context->stream_status[i].plane_count)
 			return true;
 		if (!dc_is_stream_unchanged(set[i].stream, context->streams[i]))
 			return true;
 
-		for (j = 0; j < set[i].surface_count; j++) {
-			struct dc_plane_state temp_surf;
-			memset(&temp_surf, 0, sizeof(temp_surf));
+		for (j = 0; j < set[i].plane_count; j++) {
+			struct dc_plane_state temp_plane;
+			memset(&temp_plane, 0, sizeof(temp_plane));
 
-			temp_surf = *context->stream_status[i].surfaces[j];
-			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
-			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
-			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
+			temp_plane = *context->stream_status[i].plane_states[j];
+			temp_plane.clip_rect = set[i].plane_states[j]->clip_rect;
+			temp_plane.dst_rect.x = set[i].plane_states[j]->dst_rect.x;
+			temp_plane.dst_rect.y = set[i].plane_states[j]->dst_rect.y;
 
-			if (memcmp(&temp_surf, set[i].surfaces[j], sizeof(temp_surf)) != 0)
+			if (memcmp(&temp_plane, set[i].plane_states[j], sizeof(temp_plane)) != 0)
 				return true;
 		}
 	}
@@ -683,8 +683,8 @@ static bool validate_surfaces(
 	int i, j;
 
 	for (i = 0; i < set_count; i++)
-		for (j = 0; j < set[i].surface_count; j++)
-			if (!dc_validate_plane(dc, set[i].surfaces[j]))
+		for (j = 0; j < set[i].plane_count; j++)
+			if (!dc_validate_plane(dc, set[i].plane_states[j]))
 				return false;
 
 	return true;
@@ -977,11 +977,11 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	for (i = 0; i < context->stream_count; i++) {
 		const struct dc_sink *sink = context->streams[i]->sink;
 
-		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			const struct dc_plane_state *surface =
-					context->stream_status[i].surfaces[j];
+		for (j = 0; j < context->stream_status[i].plane_count; j++) {
+			const struct dc_plane_state *plane_state =
+					context->stream_status[i].plane_states[j];
 
-			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+			core_dc->hwss.apply_ctx_for_surface(core_dc, plane_state, context);
 
 			/*
 			 * enable stereo
@@ -1073,9 +1073,9 @@ bool dc_commit_streams(
 		set[i].stream = stream;
 
 		if (status) {
-			set[i].surface_count = status->surface_count;
-			for (j = 0; j < status->surface_count; j++)
-				set[i].surfaces[j] = status->surfaces[j];
+			set[i].plane_count = status->plane_count;
+			for (j = 0; j < status->plane_count; j++)
+				set[i].plane_states[j] = status->plane_states[j];
 		}
 
 	}
@@ -1122,7 +1122,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL
-				|| context->res_ctx.pipe_ctx[i].surface == NULL)
+				|| context->res_ctx.pipe_ctx[i].plane_state == NULL)
 			core_dc->hwss.power_down_front_end(core_dc, i);
 
 	/* 3rd param should be true, temp w/a for RV*/
@@ -1134,10 +1134,10 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	return true;
 }
 
-bool dc_commit_surfaces_to_stream(
+bool dc_commit_planes_to_stream(
 		struct dc *dc,
-		struct dc_plane_state **new_surfaces,
-		uint8_t new_surface_count,
+		struct dc_plane_state **plane_states,
+		uint8_t new_plane_count,
 		struct dc_stream_state *dc_stream)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
@@ -1162,37 +1162,37 @@ bool dc_commit_surfaces_to_stream(
 	stream_update->dst = dc_stream->dst;
 	stream_update->out_transfer_func = dc_stream->out_transfer_func;
 
-	for (i = 0; i < new_surface_count; i++) {
-		updates[i].surface = new_surfaces[i];
+	for (i = 0; i < new_plane_count; i++) {
+		updates[i].surface = plane_states[i];
 		updates[i].gamma =
-			(struct dc_gamma *)new_surfaces[i]->gamma_correction;
-		updates[i].in_transfer_func = new_surfaces[i]->in_transfer_func;
-		flip_addr[i].address = new_surfaces[i]->address;
-		flip_addr[i].flip_immediate = new_surfaces[i]->flip_immediate;
-		plane_info[i].color_space = new_surfaces[i]->color_space;
-		plane_info[i].format = new_surfaces[i]->format;
-		plane_info[i].plane_size = new_surfaces[i]->plane_size;
-		plane_info[i].rotation = new_surfaces[i]->rotation;
-		plane_info[i].horizontal_mirror = new_surfaces[i]->horizontal_mirror;
-		plane_info[i].stereo_format = new_surfaces[i]->stereo_format;
-		plane_info[i].tiling_info = new_surfaces[i]->tiling_info;
-		plane_info[i].visible = new_surfaces[i]->visible;
-		plane_info[i].per_pixel_alpha = new_surfaces[i]->per_pixel_alpha;
-		plane_info[i].dcc = new_surfaces[i]->dcc;
-		scaling_info[i].scaling_quality = new_surfaces[i]->scaling_quality;
-		scaling_info[i].src_rect = new_surfaces[i]->src_rect;
-		scaling_info[i].dst_rect = new_surfaces[i]->dst_rect;
-		scaling_info[i].clip_rect = new_surfaces[i]->clip_rect;
+			(struct dc_gamma *)plane_states[i]->gamma_correction;
+		updates[i].in_transfer_func = plane_states[i]->in_transfer_func;
+		flip_addr[i].address = plane_states[i]->address;
+		flip_addr[i].flip_immediate = plane_states[i]->flip_immediate;
+		plane_info[i].color_space = plane_states[i]->color_space;
+		plane_info[i].format = plane_states[i]->format;
+		plane_info[i].plane_size = plane_states[i]->plane_size;
+		plane_info[i].rotation = plane_states[i]->rotation;
+		plane_info[i].horizontal_mirror = plane_states[i]->horizontal_mirror;
+		plane_info[i].stereo_format = plane_states[i]->stereo_format;
+		plane_info[i].tiling_info = plane_states[i]->tiling_info;
+		plane_info[i].visible = plane_states[i]->visible;
+		plane_info[i].per_pixel_alpha = plane_states[i]->per_pixel_alpha;
+		plane_info[i].dcc = plane_states[i]->dcc;
+		scaling_info[i].scaling_quality = plane_states[i]->scaling_quality;
+		scaling_info[i].src_rect = plane_states[i]->src_rect;
+		scaling_info[i].dst_rect = plane_states[i]->dst_rect;
+		scaling_info[i].clip_rect = plane_states[i]->clip_rect;
 
 		updates[i].flip_addr = &flip_addr[i];
 		updates[i].plane_info = &plane_info[i];
 		updates[i].scaling_info = &scaling_info[i];
 	}
 
-	dc_update_surfaces_and_stream(
+	dc_update_planes_and_stream(
 			dc,
 			updates,
-			new_surface_count,
+			new_plane_count,
 			dc_stream, stream_update);
 
 	dc_post_update_surfaces_to_stream(dc);
@@ -1220,14 +1220,14 @@ void dc_release_validate_context(struct validate_context *context)
 
 static bool is_surface_in_context(
 		const struct validate_context *context,
-		const struct dc_plane_state *surface)
+		const struct dc_plane_state *plane_state)
 {
 	int j;
 
 	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (surface == pipe_ctx->surface) {
+		if (plane_state == pipe_ctx->plane_state) {
 			return true;
 		}
 	}
@@ -1371,7 +1371,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
-	if (stream_status == NULL || stream_status->surface_count != surface_count)
+	if (stream_status == NULL || stream_status->plane_count != surface_count)
 		return UPDATE_TYPE_FULL;
 
 	if (stream_update)
@@ -1393,7 +1393,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-void dc_update_surfaces_and_stream(struct dc *dc,
+void dc_update_planes_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,
 		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
@@ -1470,10 +1470,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		struct dc_plane_state *new_surfaces[MAX_SURFACES] = {0};
+		struct dc_plane_state *new_planes[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
-			new_surfaces[i] = srf_updates[i].surface;
+			new_planes[i] = srf_updates[i].surface;
 
 		/* initialize scratch memory for building context */
 		context = dm_alloc(sizeof(*context));
@@ -1487,7 +1487,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, stream,
+				new_planes, surface_count, stream,
 				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
@@ -1542,7 +1542,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-				if (pipe_ctx->surface != surface)
+				if (pipe_ctx->plane_state != surface)
 					continue;
 
 				resource_build_scaling_params(pipe_ctx);
@@ -1599,14 +1599,14 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
+		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->surface != surface)
+			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->plane_state != plane_state)
 				continue;
-			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
 			core_dc->hwss.pipe_control_lock(
@@ -1622,15 +1622,15 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 		struct pipe_ctx *cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
-		bool is_new_pipe_surface = cur_pipe_ctx->surface != pipe_ctx->surface;
+		bool is_new_pipe_surface = cur_pipe_ctx->plane_state != pipe_ctx->plane_state;
 		struct dc_cursor_position position = { 0 };
 
-		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->surface)
+		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->plane_state)
 			continue;
 
 		if (!pipe_ctx->top_pipe)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, pipe_ctx->surface, context);
+					core_dc, pipe_ctx->plane_state, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
 		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
@@ -1638,7 +1638,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		if (is_new_pipe_surface) {
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 			core_dc->hwss.set_input_transfer_func(
-					pipe_ctx, pipe_ctx->surface);
+					pipe_ctx, pipe_ctx->plane_state);
 			core_dc->hwss.set_output_transfer_func(
 					pipe_ctx, pipe_ctx->stream);
 		}
@@ -1649,16 +1649,16 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = srf_updates[i].surface;
+		struct dc_plane_state *plane_state = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(
-					core_dc, surface, context);
+					core_dc, plane_state, context);
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (pipe_ctx->surface != surface)
+			if (pipe_ctx->plane_state != plane_state)
 				continue;
 
 			if (srf_updates[i].flip_addr)
@@ -1669,7 +1669,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 			if (srf_updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
-						pipe_ctx, pipe_ctx->surface);
+						pipe_ctx, pipe_ctx->plane_state);
 
 			if (stream_update != NULL &&
 					stream_update->out_transfer_func != NULL) {
@@ -1690,9 +1690,9 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		for (j = 0; j < surface_count; j++) {
 			if (update_type != UPDATE_TYPE_FULL &&
-			    srf_updates[j].surface != pipe_ctx->surface)
+			    srf_updates[j].surface != pipe_ctx->plane_state)
 				continue;
-			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+			if (!pipe_ctx->plane_state || pipe_ctx->top_pipe)
 				continue;
 
 			core_dc->hwss.pipe_control_lock(

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 500788c35d70..8b6b7631d776 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -149,12 +149,12 @@ static bool create_links(
 }
 
 static bool stream_adjust_vmin_vmax(struct dc *dc,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_stream *stream = streams[0];
+	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
@@ -175,12 +175,12 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 }
 
 static bool stream_get_crtc_position(struct dc *dc,
-		struct dc_stream **streams, int num_streams,
+		struct dc_stream_state **streams, int num_streams,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_stream *stream = streams[0];
+	struct dc_stream_state *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 	struct crtc_position position;
@@ -200,7 +200,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 	return ret;
 }
 
-static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
+static bool set_gamut_remap(struct dc *dc, const struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
@@ -218,7 +218,7 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 	return ret;
 }
 
-static bool program_csc_matrix(struct dc *dc, struct dc_stream *stream)
+static bool program_csc_matrix(struct dc *dc, struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i = 0;
@@ -241,7 +241,7 @@ static bool program_csc_matrix(struct dc *dc, struct dc_stream *stream)
 }
 
 static void set_static_screen_events(struct dc *dc,
-		struct dc_stream **streams,
+		struct dc_stream_state **streams,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
@@ -252,7 +252,7 @@ static void set_static_screen_events(struct dc *dc,
 	int num_pipes_affected = 0;
 
 	for (i = 0; i < num_streams; i++) {
-		struct dc_stream *stream = streams[i];
+		struct dc_stream_state *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
 			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
@@ -333,7 +333,7 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
-void set_dither_option(struct dc_stream *stream,
+void set_dither_option(struct dc_stream_state *stream,
 		enum dc_dither_option option)
 {
 	struct bit_depth_reduction_params params;
@@ -769,7 +769,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -893,7 +893,7 @@ static bool context_changed(
 
 static bool streams_changed(
 		struct core_dc *dc,
-		struct dc_stream *streams[],
+		struct dc_stream_state *streams[],
 		uint8_t stream_count)
 {
 	uint8_t i;
@@ -912,7 +912,7 @@ static bool streams_changed(
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
-	struct dc_stream *streams[],
+	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
 	bool ret = true;
@@ -958,7 +958,7 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
-	struct dc_stream *dc_streams[MAX_STREAMS] = {0};
+	struct dc_stream_state *dc_streams[MAX_STREAMS] = {0};
 
 	for (i = 0; i < context->stream_count; i++)
 		dc_streams[i] =  context->streams[i];
@@ -1031,7 +1031,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		dc_stream_log(stream,
 				core_dc->ctx->logger,
@@ -1046,7 +1046,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 
 bool dc_commit_streams(
 	struct dc *dc,
-	struct dc_stream *streams[],
+	struct dc_stream_state *streams[],
 	uint8_t stream_count)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1062,7 +1062,7 @@ bool dc_commit_streams(
 				__func__, stream_count);
 
 	for (i = 0; i < stream_count; i++) {
-		struct dc_stream *stream = streams[i];
+		struct dc_stream_state *stream = streams[i];
 		struct dc_stream_status *status = dc_stream_get_status(stream);
 		int j;
 
@@ -1138,7 +1138,7 @@ bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
 		struct dc_plane_state **new_surfaces,
 		uint8_t new_surface_count,
-		struct dc_stream *dc_stream)
+		struct dc_stream_state *dc_stream)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
 	struct dc_flip_addrs flip_addr[MAX_SURFACES];
@@ -1395,7 +1395,7 @@ enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_surfaces_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct dc_stream_update *stream_update)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1723,7 +1723,7 @@ uint8_t dc_get_current_stream_count(const struct dc *dc)
 	return core_dc->current_context->stream_count;
 }
 
-struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
+struct dc_stream_state *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	if (i < core_dc->current_context->stream_count)

commit c9614aeb12f80fa7a787e608d75b707175997edd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:24:04 2017 -0400

    drm/amd/display: Rename dc_surface to dc_plane_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_surface/struct dc_plane_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_update/struct dc_surface_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_status/struct dc_surface_status/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_dcc_cap/struct dc_surface_dcc_cap/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5acf4c697ae8..500788c35d70 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -645,7 +645,7 @@ static bool is_validation_required(
 			return true;
 
 		for (j = 0; j < set[i].surface_count; j++) {
-			struct dc_surface temp_surf;
+			struct dc_plane_state temp_surf;
 			memset(&temp_surf, 0, sizeof(temp_surf));
 
 			temp_surf = *context->stream_status[i].surfaces[j];
@@ -684,7 +684,7 @@ static bool validate_surfaces(
 
 	for (i = 0; i < set_count; i++)
 		for (j = 0; j < set[i].surface_count; j++)
-			if (!dc_validate_surface(dc, set[i].surfaces[j]))
+			if (!dc_validate_plane(dc, set[i].surfaces[j]))
 				return false;
 
 	return true;
@@ -978,7 +978,7 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		const struct dc_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			const struct dc_surface *surface =
+			const struct dc_plane_state *surface =
 					context->stream_status[i].surfaces[j];
 
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
@@ -1136,7 +1136,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
-		struct dc_surface **new_surfaces,
+		struct dc_plane_state **new_surfaces,
 		uint8_t new_surface_count,
 		struct dc_stream *dc_stream)
 {
@@ -1220,7 +1220,7 @@ void dc_release_validate_context(struct validate_context *context)
 
 static bool is_surface_in_context(
 		const struct validate_context *context,
-		const struct dc_surface *surface)
+		const struct dc_plane_state *surface)
 {
 	int j;
 
@@ -1470,7 +1470,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		struct dc_surface *new_surfaces[MAX_SURFACES] = {0};
+		struct dc_plane_state *new_surfaces[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
 			new_surfaces[i] = srf_updates[i].surface;
@@ -1496,7 +1496,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* save update parameters into surface */
 	for (i = 0; i < surface_count; i++) {
-		struct dc_surface *surface = srf_updates[i].surface;
+		struct dc_plane_state *surface = srf_updates[i].surface;
 
 		if (srf_updates[i].flip_addr) {
 			surface->address = srf_updates[i].flip_addr->address;
@@ -1599,7 +1599,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
-		struct dc_surface *surface = srf_updates[i].surface;
+		struct dc_plane_state *surface = srf_updates[i].surface;
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1649,7 +1649,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
-		struct dc_surface *surface = srf_updates[i].surface;
+		struct dc_plane_state *surface = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(

commit d54d29db47cdbe1f26776f2d03320ca56c5271fa
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Jul 28 12:07:38 2017 -0400

    drm/amd/display: Move and Rename "is_stream_changed()"
    
     -Move "is_stream_changed()" to DC interface
     -Rename "is_stream_changed()" to "dc_is_stream_changed()"
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ba8093317aa9..5acf4c697ae8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -641,7 +641,7 @@ static bool is_validation_required(
 
 		if (set[i].surface_count != context->stream_status[i].surface_count)
 			return true;
-		if (!is_stream_unchanged(set[i].stream, context->streams[i]))
+		if (!dc_is_stream_unchanged(set[i].stream, context->streams[i]))
 			return true;
 
 		for (j = 0; j < set[i].surface_count; j++) {

commit d70ccd4a65373599fe9aa999dff07c05ea2893e6
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jul 28 15:33:38 2017 -0400

    drm/amd/display: Keep blank until set visibility to true after mode switch
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 83b8b196cc1e..ba8093317aa9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1609,12 +1609,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
 				continue;
 
-			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-				core_dc->hwss.pipe_control_lock(
-						core_dc,
-						pipe_ctx,
-						true);
-			}
+			core_dc->hwss.pipe_control_lock(
+					core_dc,
+					pipe_ctx,
+					true);
 		}
 		if (update_type == UPDATE_TYPE_FULL)
 			break;
@@ -1697,12 +1695,11 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
 				continue;
 
-			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-				core_dc->hwss.pipe_control_lock(
-						core_dc,
-						pipe_ctx,
-						false);
-			}
+			core_dc->hwss.pipe_control_lock(
+					core_dc,
+					pipe_ctx,
+					false);
+
 			break;
 		}
 	}

commit f669089aa12ab9b509ed8ff3755e73794b7941ea
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Thu Jul 27 16:47:14 2017 -0400

    drm/amd/display: Add stateless surface validation to validate_resources
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1c0d21840cba..83b8b196cc1e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -675,6 +675,21 @@ static bool validate_streams (
 	return true;
 }
 
+static bool validate_surfaces(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	int i, j;
+
+	for (i = 0; i < set_count; i++)
+		for (j = 0; j < set[i].surface_count; j++)
+			if (!dc_validate_surface(dc, set[i].surfaces[j]))
+				return false;
+
+	return true;
+}
+
 struct validate_context *dc_get_validate_context(
 		const struct dc *dc,
 		const struct dc_validation_set set[],
@@ -726,6 +741,9 @@ bool dc_validate_resources(
 	if (!validate_streams(dc, set, set_count))
 		return false;
 
+	if (!validate_surfaces(dc, set, set_count))
+		return false;
+
 	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
@@ -1065,6 +1083,9 @@ bool dc_commit_streams(
 	if (!validate_streams(dc, set, stream_count))
 		return false;
 
+	if (!validate_surfaces(dc, set, stream_count))
+		return false;
+
 	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;

commit 690b5e3960810c733f812f8849c3a05415c2f53d
Author: Roman Li <Roman.Li@amd.com>
Date:   Thu Jul 27 20:00:06 2017 -0400

    drm/amd/display: Initial prototype of FBC implementation
    
    - Protected by ENABLE_FBC compile flag
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index df8c5ca6b22a..1c0d21840cba 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -475,7 +475,9 @@ static bool construct(struct core_dc *dc,
 
 	dc_version = resource_parse_asic_id(init_params->asic_id);
 	dc->ctx->dce_version = dc_version;
-
+#ifdef ENABLE_FBC
+	dc->ctx->fbc_gpu_addr = init_params->fbc_gpu_addr;
+#endif
 	/* Resource should construct all asic specific resources.
 	 * This should be the only place where we need to parse the asic id
 	 */
@@ -919,7 +921,7 @@ bool dc_enable_stereo(
 #ifdef ENABLE_FBC
 	if (fbc_compressor != NULL &&
 	    fbc_compressor->funcs->is_fbc_enabled_in_hw(core_dc->fbc_compressor,
-							&pipe->tg->inst))
+							NULL))
 		fbc_compressor->funcs->disable_fbc(fbc_compressor);
 
 #endif
@@ -2066,3 +2068,4 @@ void dc_log_hw_state(struct dc *dc)
 	if (core_dc->hwss.log_hw_state)
 		core_dc->hwss.log_hw_state(core_dc);
 }
+

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index bab07f8d4880..df8c5ca6b22a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -149,19 +149,19 @@ static bool create_links(
 }
 
 static bool stream_adjust_vmin_vmax(struct dc *dc,
-		const struct dc_stream **stream, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		int vmin, int vmax)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	struct dc_stream *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == core_stream && pipe->stream_enc) {
+		if (pipe->stream == stream && pipe->stream_enc) {
 			core_dc->hwss.set_drr(&pipe, 1, vmin, vmax);
 
 			/* build and update the info frame */
@@ -175,12 +175,12 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 }
 
 static bool stream_get_crtc_position(struct dc *dc,
-		const struct dc_stream **stream, int num_streams,
+		struct dc_stream **streams, int num_streams,
 		unsigned int *v_pos, unsigned int *nom_v_pos)
 {
 	/* TODO: Support multiple streams */
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	struct dc_stream *stream = streams[0];
 	int i = 0;
 	bool ret = false;
 	struct crtc_position position;
@@ -189,7 +189,7 @@ static bool stream_get_crtc_position(struct dc *dc,
 		struct pipe_ctx *pipe =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe->stream == core_stream && pipe->stream_enc) {
+		if (pipe->stream == stream && pipe->stream_enc) {
 			core_dc->hwss.get_position(&pipe, 1, &position);
 
 			*v_pos = position.vertical_count;
@@ -203,15 +203,12 @@ static bool stream_get_crtc_position(struct dc *dc,
 static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
-				== core_stream) {
-
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == stream) {
 			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
 			core_dc->hwss.program_gamut_remap(pipes);
 			ret = true;
@@ -221,22 +218,21 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 	return ret;
 }
 
-static bool program_csc_matrix(struct dc *dc, const struct dc_stream *stream)
+static bool program_csc_matrix(struct dc *dc, struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
-				== core_stream) {
+				== stream) {
 
 			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
 			core_dc->hwss.program_csc_matrix(pipes,
-			core_stream->public.output_color_space,
-			core_stream->public.csc_color_matrix.matrix);
+			stream->output_color_space,
+			stream->csc_color_matrix.matrix);
 			ret = true;
 		}
 	}
@@ -245,7 +241,7 @@ static bool program_csc_matrix(struct dc *dc, const struct dc_stream *stream)
 }
 
 static void set_static_screen_events(struct dc *dc,
-		const struct dc_stream **stream,
+		struct dc_stream **streams,
 		int num_streams,
 		const struct dc_static_screen_events *events)
 {
@@ -256,11 +252,11 @@ static void set_static_screen_events(struct dc *dc,
 	int num_pipes_affected = 0;
 
 	for (i = 0; i < num_streams; i++) {
-		struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[i]);
+		struct dc_stream *stream = streams[i];
 
 		for (j = 0; j < MAX_PIPES; j++) {
 			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
-					== core_stream) {
+					== stream) {
 				pipes_affected[num_pipes_affected++] =
 						&core_dc->current_context->res_ctx.pipe_ctx[j];
 			}
@@ -337,10 +333,9 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
-void set_dither_option(const struct dc_stream *dc_stream,
+void set_dither_option(struct dc_stream *stream,
 		enum dc_dither_option option)
 {
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct bit_depth_reduction_params params;
 	struct dc_link *link = stream->status.link;
 	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
@@ -351,21 +346,21 @@ void set_dither_option(const struct dc_stream *dc_stream,
 	if (option > DITHER_OPTION_MAX)
 		return;
 	if (option == DITHER_OPTION_DEFAULT) {
-		switch (stream->public.timing.display_color_depth) {
+		switch (stream->timing.display_color_depth) {
 		case COLOR_DEPTH_666:
-			stream->public.dither_option = DITHER_OPTION_SPATIAL6;
+			stream->dither_option = DITHER_OPTION_SPATIAL6;
 			break;
 		case COLOR_DEPTH_888:
-			stream->public.dither_option = DITHER_OPTION_SPATIAL8;
+			stream->dither_option = DITHER_OPTION_SPATIAL8;
 			break;
 		case COLOR_DEPTH_101010:
-			stream->public.dither_option = DITHER_OPTION_SPATIAL10;
+			stream->dither_option = DITHER_OPTION_SPATIAL10;
 			break;
 		default:
 			option = DITHER_OPTION_DISABLE;
 		}
 	} else {
-		stream->public.dither_option = option;
+		stream->dither_option = option;
 	}
 	resource_build_bit_depth_reduction_params(stream,
 				&params);
@@ -644,7 +639,7 @@ static bool is_validation_required(
 
 		if (set[i].surface_count != context->stream_status[i].surface_count)
 			return true;
-		if (!is_stream_unchanged(DC_STREAM_TO_CORE(set[i].stream), context->streams[i]))
+		if (!is_stream_unchanged(set[i].stream, context->streams[i]))
 			return true;
 
 		for (j = 0; j < set[i].surface_count; j++) {
@@ -754,7 +749,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		const struct dc_stream *stream)
+		struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -869,7 +864,7 @@ static bool context_changed(
 		return true;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (&dc->current_context->streams[i]->public != &context->streams[i]->public)
+		if (dc->current_context->streams[i] != context->streams[i])
 			return true;
 	}
 
@@ -878,7 +873,7 @@ static bool context_changed(
 
 static bool streams_changed(
 		struct core_dc *dc,
-		const struct dc_stream *streams[],
+		struct dc_stream *streams[],
 		uint8_t stream_count)
 {
 	uint8_t i;
@@ -887,7 +882,7 @@ static bool streams_changed(
 		return true;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (&dc->current_context->streams[i]->public != streams[i])
+		if (dc->current_context->streams[i] != streams[i])
 			return true;
 	}
 
@@ -897,7 +892,7 @@ static bool streams_changed(
 bool dc_enable_stereo(
 	struct dc *dc,
 	struct validate_context *context,
-	const struct dc_stream *streams[],
+	struct dc_stream *streams[],
 	uint8_t stream_count)
 {
 	bool ret = true;
@@ -915,7 +910,7 @@ bool dc_enable_stereo(
 		else
 			pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 		for (j = 0 ; pipe && j < stream_count; j++)  {
-			if (streams[j] && streams[j] == &pipe->stream->public &&
+			if (streams[j] && streams[j] == pipe->stream &&
 				core_dc->hwss.setup_stereo)
 				core_dc->hwss.setup_stereo(pipe, core_dc);
 		}
@@ -943,10 +938,10 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
-	const struct dc_stream *dc_streams[MAX_STREAMS] = {0};
+	struct dc_stream *dc_streams[MAX_STREAMS] = {0};
 
 	for (i = 0; i < context->stream_count; i++)
-		dc_streams[i] =  &context->streams[i]->public;
+		dc_streams[i] =  context->streams[i];
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		core_dc->hwss.enable_accelerated_mode(core_dc);
@@ -985,11 +980,11 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		}
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
-				context->streams[i]->public.timing.h_addressable,
-				context->streams[i]->public.timing.v_addressable,
-				context->streams[i]->public.timing.h_total,
-				context->streams[i]->public.timing.v_total,
-				context->streams[i]->public.timing.pix_clk_khz);
+				context->streams[i]->timing.h_addressable,
+				context->streams[i]->timing.v_addressable,
+				context->streams[i]->timing.h_total,
+				context->streams[i]->timing.v_total,
+				context->streams[i]->timing.pix_clk_khz);
 	}
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
@@ -1016,7 +1011,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
-		const struct dc_stream *stream = &context->streams[i]->public;
+		struct dc_stream *stream = context->streams[i];
 
 		dc_stream_log(stream,
 				core_dc->ctx->logger,
@@ -1031,7 +1026,7 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 
 bool dc_commit_streams(
 	struct dc *dc,
-	const struct dc_stream *streams[],
+	struct dc_stream *streams[],
 	uint8_t stream_count)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1047,8 +1042,8 @@ bool dc_commit_streams(
 				__func__, stream_count);
 
 	for (i = 0; i < stream_count; i++) {
-		const struct dc_stream *stream = streams[i];
-		const struct dc_stream_status *status = dc_stream_get_status(stream);
+		struct dc_stream *stream = streams[i];
+		struct dc_stream_status *status = dc_stream_get_status(stream);
 		int j;
 
 		dc_stream_log(stream,
@@ -1120,7 +1115,7 @@ bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
 		struct dc_surface **new_surfaces,
 		uint8_t new_surface_count,
-		const struct dc_stream *dc_stream)
+		struct dc_stream *dc_stream)
 {
 	struct dc_surface_update updates[MAX_SURFACES];
 	struct dc_flip_addrs flip_addr[MAX_SURFACES];
@@ -1377,7 +1372,7 @@ enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_surfaces_and_stream(struct dc *dc,
 		struct dc_surface_update *srf_updates, int surface_count,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *stream,
 		struct dc_stream_update *stream_update)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1385,7 +1380,6 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	int i, j;
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct dc_context *dc_ctx = core_dc->ctx;
 
 	/* Currently this function do not result in any HW programming
@@ -1398,7 +1392,8 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (surface_count == 0)
 		return;
 
-	stream_status = dc_stream_get_status(dc_stream);
+	stream_status = dc_stream_get_status(stream);
+
 	ASSERT(stream_status);
 	if (!stream_status)
 		return; /* Cannot commit surface to stream that is not committed */
@@ -1415,19 +1410,19 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (stream_update) {
 		if ((stream_update->src.height != 0) &&
 				(stream_update->src.width != 0))
-			stream->public.src = stream_update->src;
+			stream->src = stream_update->src;
 
 		if ((stream_update->dst.height != 0) &&
 				(stream_update->dst.width != 0))
-			stream->public.dst = stream_update->dst;
+			stream->dst = stream_update->dst;
 
 		if (stream_update->out_transfer_func &&
 				stream_update->out_transfer_func !=
-						dc_stream->out_transfer_func) {
-			if (dc_stream->out_transfer_func != NULL)
-				dc_transfer_func_release(dc_stream->out_transfer_func);
+						stream->out_transfer_func) {
+			if (stream->out_transfer_func != NULL)
+				dc_transfer_func_release(stream->out_transfer_func);
 			dc_transfer_func_retain(stream_update->out_transfer_func);
-			stream->public.out_transfer_func =
+			stream->out_transfer_func =
 				stream_update->out_transfer_func;
 		}
 	}
@@ -1469,7 +1464,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, dc_stream,
+				new_surfaces, surface_count, stream,
 				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
@@ -1617,7 +1612,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 					core_dc, pipe_ctx->surface, context);
 
 		/* TODO: this is a hack w/a for switching from mpo to pipe split */
-		dc_stream_set_cursor_position(&pipe_ctx->stream->public, &position);
+		dc_stream_set_cursor_position(pipe_ctx->stream, &position);
 
 		if (is_new_pipe_surface) {
 			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
@@ -1712,7 +1707,7 @@ struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	if (i < core_dc->current_context->stream_count)
-		return &(core_dc->current_context->streams[i]->public);
+		return core_dc->current_context->streams[i];
 	return NULL;
 }
 

commit 3639fa68122154b453eeaac840daadf3c7c56db4
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Tue Jul 25 15:14:24 2017 -0400

    drm/amd/display: Clean up some DCN1 guards
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9c2faf8e4b14..bab07f8d4880 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1109,7 +1109,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	/* 3rd param should be true, temp w/a for RV*/
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	core_dc->hwss.set_bandwidth(core_dc, context, core_dc->ctx->dce_version != DCN_VERSION_1_0);
+	core_dc->hwss.set_bandwidth(core_dc, context, core_dc->ctx->dce_version < DCN_VERSION_1_0);
 #else
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 #endif

commit 9345d9874c324b2f8cce79d4de11f27ae1ef80e9
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Jul 21 16:34:36 2017 -0400

    drm/amd/display: Move stream validations into seperate function.
    
    Stateless streams validations (not require resource population)
    moved into hook to be called directly from DM.
    
    Call dc_validate_stream be before validate_with_context for
    non Linux APIs
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 79218805754e..9c2faf8e4b14 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -664,6 +664,20 @@ static bool is_validation_required(
 	return false;
 }
 
+static bool validate_streams (
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	int i;
+
+	for (i = 0; i < set_count; i++)
+		if (!dc_validate_stream(dc, set[i].stream))
+			return false;
+
+	return true;
+}
+
 struct validate_context *dc_get_validate_context(
 		const struct dc *dc,
 		const struct dc_validation_set set[],
@@ -673,6 +687,7 @@ struct validate_context *dc_get_validate_context(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
+
 	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
@@ -711,6 +726,9 @@ bool dc_validate_resources(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
+	if (!validate_streams(dc, set, set_count))
+		return false;
+
 	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
@@ -742,6 +760,9 @@ bool dc_validate_guaranteed(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
+	if (!dc_validate_stream(dc, stream))
+		return false;
+
 	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;
@@ -1044,6 +1065,9 @@ bool dc_commit_streams(
 
 	}
 
+	if (!validate_streams(dc, set, stream_count))
+		return false;
+
 	context = dm_alloc(sizeof(struct validate_context));
 	if (context == NULL)
 		goto context_alloc_fail;

commit 6be425f3dc16bac797f300136b976bce46229784
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Jul 24 10:47:02 2017 -0400

    drm/amd/display: break up plane disable and disconnect in set mode
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d3873ac45cf3..79218805754e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -932,7 +932,7 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		pipe = &context->res_ctx.pipe_ctx[i];
-		core_dc->hwss.wait_for_mpcc_disconnect(core_dc->res_pool, pipe);
+		core_dc->hwss.wait_for_mpcc_disconnect(core_dc, core_dc->res_pool, pipe);
 	}
 	result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
 
@@ -1364,6 +1364,16 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct dc_context *dc_ctx = core_dc->ctx;
 
+	/* Currently this function do not result in any HW programming
+	 * when called with 0 surface. But proceeding will cause
+	 * SW state to be updated in validate_context. So we might as
+	 * well make it not do anything at all until the hw programming
+	 * is implemented properly to handle 0 surface case.
+	 * TODO: fix hw programming then remove this early return
+	 */
+	if (surface_count == 0)
+		return;
+
 	stream_status = dc_stream_get_status(dc_stream);
 	ASSERT(stream_status);
 	if (!stream_status)
@@ -1535,15 +1545,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	}
 
 	if (update_type > UPDATE_TYPE_FAST) {
-		for (i = 0; i < surface_count; i++) {
-			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
-				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-
-				if (pipe_ctx->surface != srf_updates[i].surface)
-					continue;
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-				core_dc->hwss.wait_for_mpcc_disconnect(core_dc->res_pool, pipe_ctx);
-			}
+			core_dc->hwss.wait_for_mpcc_disconnect(core_dc, core_dc->res_pool, pipe_ctx);
 		}
 	}
 

commit 7a6c4af6bf41516cc9e12d83cc8fcebfdd8be01c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 15:30:17 2017 -0400

    drm/amd/display: Roll core_gamma into dc_gamma
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 30374ffaae0b..d3873ac45cf3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1500,12 +1500,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		if (srf_updates[i].gamma &&
 			srf_updates[i].gamma != surface->gamma_correction) {
 			if (surface->gamma_correction != NULL)
-				dc_gamma_release(&surface->
-						gamma_correction);
+				dc_gamma_release(&surface->gamma_correction);
 
 			dc_gamma_retain(srf_updates[i].gamma);
-			surface->gamma_correction =
-						srf_updates[i].gamma;
+			surface->gamma_correction = srf_updates[i].gamma;
 		}
 
 		if (srf_updates[i].in_transfer_func &&

commit b73a22d3257f9ec237c46be12d74b58d5a925d8c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 14:04:27 2017 -0400

    drm/amd/display: Roll core_sink into dc_sink
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 73740e2a5819..30374ffaae0b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -939,7 +939,7 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	program_timing_sync(core_dc, context);
 
 	for (i = 0; i < context->stream_count; i++) {
-		const struct core_sink *sink = context->streams[i]->sink;
+		const struct dc_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].surface_count; j++) {
 			const struct dc_surface *surface =
@@ -1984,7 +1984,7 @@ void dc_link_set_sink(struct dc_link *link, struct dc_sink *sink)
 	}
 }
 
-void dc_link_remove_remote_sink(struct dc_link *link, const struct dc_sink *sink)
+void dc_link_remove_remote_sink(struct dc_link *link, struct dc_sink *sink)
 {
 	int i;
 

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 569310ab116d..73740e2a5819 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -94,7 +94,7 @@ static bool create_links(
 
 	for (i = 0; i < connectors_num; i++) {
 		struct link_init_data link_init_params = {0};
-		struct core_link *link;
+		struct dc_link *link;
 
 		link_init_params.ctx = dc->ctx;
 		/* next BIOS object table connector */
@@ -111,7 +111,7 @@ static bool create_links(
 	}
 
 	for (i = 0; i < num_virtual_links; i++) {
-		struct core_link *link = dm_alloc(sizeof(*link));
+		struct dc_link *link = dm_alloc(sizeof(*link));
 		struct encoder_init_data enc_init = {0};
 
 		if (link == NULL) {
@@ -121,7 +121,7 @@ static bool create_links(
 
 		link->ctx = dc->ctx;
 		link->dc = dc;
-		link->public.connector_signal = SIGNAL_TYPE_VIRTUAL;
+		link->connector_signal = SIGNAL_TYPE_VIRTUAL;
 		link->link_id.type = OBJECT_TYPE_CONNECTOR;
 		link->link_id.id = CONNECTOR_ID_VIRTUAL;
 		link->link_id.enum_id = ENUM_ID_1;
@@ -137,7 +137,7 @@ static bool create_links(
 		enc_init.encoder.enum_id = ENUM_ID_1;
 		virtual_link_encoder_construct(link->link_enc, &enc_init);
 
-		link->public.link_index = dc->link_count;
+		link->link_index = dc->link_count;
 		dc->links[dc->link_count] = link;
 		dc->link_count++;
 	}
@@ -278,14 +278,14 @@ static void set_drive_settings(struct dc *dc,
 	int i;
 
 	for (i = 0; i < core_dc->link_count; i++) {
-		if (&core_dc->links[i]->public == link)
+		if (core_dc->links[i] == link)
 			break;
 	}
 
 	if (i >= core_dc->link_count)
 		ASSERT_CRITICAL(false);
 
-	dc_link_dp_set_drive_settings(&core_dc->links[i]->public, lt_settings);
+	dc_link_dp_set_drive_settings(core_dc->links[i], lt_settings);
 }
 
 static void perform_link_training(struct dc *dc,
@@ -297,20 +297,17 @@ static void perform_link_training(struct dc *dc,
 
 	for (i = 0; i < core_dc->link_count; i++)
 		dc_link_dp_perform_link_training(
-			&core_dc->links[i]->public,
+			core_dc->links[i],
 			link_setting,
 			skip_video_pattern);
 }
 
 static void set_preferred_link_settings(struct dc *dc,
 		struct dc_link_settings *link_setting,
-		const struct dc_link *link)
+		struct dc_link *link)
 {
-	struct core_link *core_link = DC_LINK_TO_CORE(link);
-
-	core_link->public.preferred_link_setting =
-				*link_setting;
-	dp_retrain_link_dp_test(core_link, link_setting, false);
+	link->preferred_link_setting = *link_setting;
+	dp_retrain_link_dp_test(link, link_setting, false);
 }
 
 static void enable_hpd(const struct dc_link *link)
@@ -325,7 +322,7 @@ static void disable_hpd(const struct dc_link *link)
 
 
 static void set_test_pattern(
-		const struct dc_link *link,
+		struct dc_link *link,
 		enum dp_test_pattern test_pattern,
 		const struct link_training_settings *p_link_settings,
 		const unsigned char *p_custom_pattern,
@@ -345,9 +342,8 @@ void set_dither_option(const struct dc_stream *dc_stream,
 {
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct bit_depth_reduction_params params;
-	struct core_link *core_link = DC_LINK_TO_CORE(stream->status.link);
-	struct pipe_ctx *pipes =
-			core_link->dc->current_context->res_ctx.pipe_ctx;
+	struct dc_link *link = stream->status.link;
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
 
 	memset(&params, 0, sizeof(params));
 	if (!stream)
@@ -1693,10 +1689,10 @@ struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 	return NULL;
 }
 
-const struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
+struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return &core_dc->links[link_index]->public;
+	return core_dc->links[link_index];
 }
 
 const struct graphics_object_id dc_get_link_id_at_index(
@@ -1710,7 +1706,7 @@ enum dc_irq_source dc_get_hpd_irq_source_at_index(
 	struct dc *dc, uint32_t link_index)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return core_dc->links[link_index]->public.irq_source_hpd;
+	return core_dc->links[link_index]->irq_source_hpd;
 }
 
 const struct audio **dc_get_audios(struct dc *dc)
@@ -1796,9 +1792,9 @@ bool dc_read_aux_dpcd(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			false,
 			I2C_MOT_UNDEF,
 			address,
@@ -1815,10 +1811,10 @@ bool dc_write_aux_dpcd(
 		uint32_t size)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			false,
 			I2C_MOT_UNDEF,
 			address,
@@ -1837,9 +1833,9 @@ bool dc_read_aux_i2c(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-		struct core_link *link = core_dc->links[link_index];
+		struct dc_link *link = core_dc->links[link_index];
 		enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			true,
 			mot,
 			address,
@@ -1857,10 +1853,10 @@ bool dc_write_aux_i2c(
 		uint32_t size)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->public.ddc,
+			link->ddc,
 			true,
 			mot,
 			address,
@@ -1880,10 +1876,10 @@ bool dc_query_ddc_data(
 
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_link *link = core_dc->links[link_index];
+	struct dc_link *link = core_dc->links[link_index];
 
 	bool result = dal_ddc_service_query_ddc_data(
-			link->public.ddc,
+			link->ddc,
 			address,
 			write_buf,
 			write_size,
@@ -1900,8 +1896,8 @@ bool dc_submit_i2c(
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_link *link = core_dc->links[link_index];
-	struct ddc_service *ddc = link->public.ddc;
+	struct dc_link *link = core_dc->links[link_index];
+	struct ddc_service *ddc = link->ddc;
 
 	return dal_i2caux_submit_i2c_command(
 		ddc->ctx->i2caux,
@@ -1909,10 +1905,8 @@ bool dc_submit_i2c(
 		cmd);
 }
 
-static bool link_add_remote_sink_helper(struct core_link *core_link, struct dc_sink *sink)
+static bool link_add_remote_sink_helper(struct dc_link *dc_link, struct dc_sink *sink)
 {
-	struct dc_link *dc_link = &core_link->public;
-
 	if (dc_link->sink_count >= MAX_SINKS_PER_LINK) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -1927,14 +1921,13 @@ static bool link_add_remote_sink_helper(struct core_link *core_link, struct dc_s
 }
 
 struct dc_sink *dc_link_add_remote_sink(
-		const struct dc_link *link,
+		struct dc_link *link,
 		const uint8_t *edid,
 		int len,
 		struct dc_sink_init_data *init_data)
 {
 	struct dc_sink *dc_sink;
 	enum dc_edid_status edid_status;
-	struct core_link *core_link = DC_LINK_TO_LINK(link);
 
 	if (len > MAX_EDID_BUFFER_SIZE) {
 		dm_error("Max EDID buffer size breached!\n");
@@ -1960,12 +1953,12 @@ struct dc_sink *dc_link_add_remote_sink(
 	dc_sink->dc_edid.length = len;
 
 	if (!link_add_remote_sink_helper(
-			core_link,
+			link,
 			dc_sink))
 		goto fail_add_sink;
 
 	edid_status = dm_helpers_parse_edid_caps(
-			core_link->ctx,
+			link->ctx,
 			&dc_sink->dc_edid,
 			&dc_sink->edid_caps);
 
@@ -1980,43 +1973,38 @@ struct dc_sink *dc_link_add_remote_sink(
 	return NULL;
 }
 
-void dc_link_set_sink(const struct dc_link *link, struct dc_sink *sink)
+void dc_link_set_sink(struct dc_link *link, struct dc_sink *sink)
 {
-	struct core_link *core_link = DC_LINK_TO_LINK(link);
-	struct dc_link *dc_link = &core_link->public;
-
-	dc_link->local_sink = sink;
+	link->local_sink = sink;
 
 	if (sink == NULL) {
-		dc_link->type = dc_connection_none;
+		link->type = dc_connection_none;
 	} else {
-		dc_link->type = dc_connection_single;
+		link->type = dc_connection_single;
 	}
 }
 
-void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink *sink)
+void dc_link_remove_remote_sink(struct dc_link *link, const struct dc_sink *sink)
 {
 	int i;
-	struct core_link *core_link = DC_LINK_TO_LINK(link);
-	struct dc_link *dc_link = &core_link->public;
 
 	if (!link->sink_count) {
 		BREAK_TO_DEBUGGER();
 		return;
 	}
 
-	for (i = 0; i < dc_link->sink_count; i++) {
-		if (dc_link->remote_sinks[i] == sink) {
+	for (i = 0; i < link->sink_count; i++) {
+		if (link->remote_sinks[i] == sink) {
 			dc_sink_release(sink);
-			dc_link->remote_sinks[i] = NULL;
+			link->remote_sinks[i] = NULL;
 
 			/* shrink array to remove empty place */
-			while (i < dc_link->sink_count - 1) {
-				dc_link->remote_sinks[i] = dc_link->remote_sinks[i+1];
+			while (i < link->sink_count - 1) {
+				link->remote_sinks[i] = link->remote_sinks[i+1];
 				i++;
 			}
-			dc_link->remote_sinks[i] = NULL;
-			dc_link->sink_count--;
+			link->remote_sinks[i] = NULL;
+			link->sink_count--;
 			return;
 		}
 	}

commit e12cfcb1d447cc937d1abc6f4aab8bbe5f88542e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 11:43:32 2017 -0400

    drm/amd/display: Roll core_surface into dc_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e89a2e5c8902..569310ab116d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -946,8 +946,8 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 		const struct core_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			struct core_surface *surface =
-					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
+			const struct dc_surface *surface =
+					context->stream_status[i].surfaces[j];
 
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
 
@@ -1098,7 +1098,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
-		const struct dc_surface **new_surfaces,
+		struct dc_surface **new_surfaces,
 		uint8_t new_surface_count,
 		const struct dc_stream *dc_stream)
 {
@@ -1189,7 +1189,7 @@ static bool is_surface_in_context(
 	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-		if (surface == &pipe_ctx->surface->public) {
+		if (surface == pipe_ctx->surface) {
 			return true;
 		}
 	}
@@ -1422,7 +1422,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		const struct dc_surface *new_surfaces[MAX_SURFACES] = {0};
+		struct dc_surface *new_surfaces[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
 			new_surfaces[i] = srf_updates[i].surface;
@@ -1448,46 +1448,45 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* save update parameters into surface */
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface =
-				DC_SURFACE_TO_CORE(srf_updates[i].surface);
+		struct dc_surface *surface = srf_updates[i].surface;
 
 		if (srf_updates[i].flip_addr) {
-			surface->public.address = srf_updates[i].flip_addr->address;
-			surface->public.flip_immediate =
+			surface->address = srf_updates[i].flip_addr->address;
+			surface->flip_immediate =
 					srf_updates[i].flip_addr->flip_immediate;
 		}
 
 		if (srf_updates[i].scaling_info) {
-			surface->public.scaling_quality =
+			surface->scaling_quality =
 					srf_updates[i].scaling_info->scaling_quality;
-			surface->public.dst_rect =
+			surface->dst_rect =
 					srf_updates[i].scaling_info->dst_rect;
-			surface->public.src_rect =
+			surface->src_rect =
 					srf_updates[i].scaling_info->src_rect;
-			surface->public.clip_rect =
+			surface->clip_rect =
 					srf_updates[i].scaling_info->clip_rect;
 		}
 
 		if (srf_updates[i].plane_info) {
-			surface->public.color_space =
+			surface->color_space =
 					srf_updates[i].plane_info->color_space;
-			surface->public.format =
+			surface->format =
 					srf_updates[i].plane_info->format;
-			surface->public.plane_size =
+			surface->plane_size =
 					srf_updates[i].plane_info->plane_size;
-			surface->public.rotation =
+			surface->rotation =
 					srf_updates[i].plane_info->rotation;
-			surface->public.horizontal_mirror =
+			surface->horizontal_mirror =
 					srf_updates[i].plane_info->horizontal_mirror;
-			surface->public.stereo_format =
+			surface->stereo_format =
 					srf_updates[i].plane_info->stereo_format;
-			surface->public.tiling_info =
+			surface->tiling_info =
 					srf_updates[i].plane_info->tiling_info;
-			surface->public.visible =
+			surface->visible =
 					srf_updates[i].plane_info->visible;
-			surface->public.per_pixel_alpha =
+			surface->per_pixel_alpha =
 					srf_updates[i].plane_info->per_pixel_alpha;
-			surface->public.dcc =
+			surface->dcc =
 					srf_updates[i].plane_info->dcc;
 		}
 
@@ -1503,31 +1502,31 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 
 		if (srf_updates[i].gamma &&
-			srf_updates[i].gamma != surface->public.gamma_correction) {
-			if (surface->public.gamma_correction != NULL)
-				dc_gamma_release(&surface->public.
+			srf_updates[i].gamma != surface->gamma_correction) {
+			if (surface->gamma_correction != NULL)
+				dc_gamma_release(&surface->
 						gamma_correction);
 
 			dc_gamma_retain(srf_updates[i].gamma);
-			surface->public.gamma_correction =
+			surface->gamma_correction =
 						srf_updates[i].gamma;
 		}
 
 		if (srf_updates[i].in_transfer_func &&
-			srf_updates[i].in_transfer_func != surface->public.in_transfer_func) {
-			if (surface->public.in_transfer_func != NULL)
+			srf_updates[i].in_transfer_func != surface->in_transfer_func) {
+			if (surface->in_transfer_func != NULL)
 				dc_transfer_func_release(
-						surface->public.
+						surface->
 						in_transfer_func);
 
 			dc_transfer_func_retain(
 					srf_updates[i].in_transfer_func);
-			surface->public.in_transfer_func =
+			surface->in_transfer_func =
 					srf_updates[i].in_transfer_func;
 		}
 
 		if (srf_updates[i].hdr_static_metadata)
-			surface->public.hdr_static_ctx =
+			surface->hdr_static_ctx =
 				*(srf_updates[i].hdr_static_metadata);
 	}
 
@@ -1543,12 +1542,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	if (update_type > UPDATE_TYPE_FAST) {
 		for (i = 0; i < surface_count; i++) {
-			struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
-
 			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-				if (pipe_ctx->surface != surface)
+				if (pipe_ctx->surface != srf_updates[i].surface)
 					continue;
 
 				core_dc->hwss.wait_for_mpcc_disconnect(core_dc->res_pool, pipe_ctx);
@@ -1561,7 +1558,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
+		struct dc_surface *surface = srf_updates[i].surface;
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1613,7 +1610,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
+		struct dc_surface *surface = srf_updates[i].surface;
 
 		if (update_type == UPDATE_TYPE_MED)
 			core_dc->hwss.apply_ctx_for_surface(
@@ -1654,7 +1651,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		for (j = 0; j < surface_count; j++) {
 			if (update_type != UPDATE_TYPE_FULL &&
-					srf_updates[j].surface != &pipe_ctx->surface->public)
+			    srf_updates[j].surface != pipe_ctx->surface)
 				continue;
 			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
 				continue;

commit 08b1688620426ad3e09fc7a98aabc28dda30cde6
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Sun Jul 23 18:30:15 2017 -0400

    drm/amd/display: Move DCHUBBUB block from MemInput to HW sequencer.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9ef671735125..e89a2e5c8902 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2042,10 +2042,10 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 		return false;
 	}
 
-	if (mi->funcs->mem_input_update_dchub)
-		mi->funcs->mem_input_update_dchub(mi, dh_data);
+	if (core_dc->hwss.update_dchub)
+		core_dc->hwss.update_dchub(core_dc->hwseq, dh_data);
 	else
-		ASSERT(mi->funcs->mem_input_update_dchub);
+		ASSERT(core_dc->hwss.update_dchub);
 
 
 	return true;

commit 8748068764e7a50ac787c1c17f402f3fbbe97ccc
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Sun Jul 23 15:18:57 2017 -0400

    drm/amd/display: add idle wait for passive surface update and modeset
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index de05ad09599f..9ef671735125 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -934,6 +934,10 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		core_dc->hwss.enable_accelerated_mode(core_dc);
 
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+		pipe = &context->res_ctx.pipe_ctx[i];
+		core_dc->hwss.wait_for_mpcc_disconnect(core_dc->res_pool, pipe);
+	}
 	result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
 
 	program_timing_sync(core_dc, context);
@@ -1537,6 +1541,21 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 	}
 
+	if (update_type > UPDATE_TYPE_FAST) {
+		for (i = 0; i < surface_count; i++) {
+			struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
+
+			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+				if (pipe_ctx->surface != surface)
+					continue;
+
+				core_dc->hwss.wait_for_mpcc_disconnect(core_dc->res_pool, pipe_ctx);
+			}
+		}
+	}
+
 	if (surface_count == 0)
 		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
 

commit 8c4abe0b07a12c402f009abed8217e6c2e33a300
Author: Ding Wang <Ding.Wang@amd.com>
Date:   Tue Jul 18 17:18:11 2017 -0400

    drm/amd/display: fix decide_link_settings
    
    Signed-off-by: Ding Wang <Ding.Wang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ad1b90563eb6..de05ad09599f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -308,10 +308,8 @@ static void set_preferred_link_settings(struct dc *dc,
 {
 	struct core_link *core_link = DC_LINK_TO_CORE(link);
 
-	core_link->public.verified_link_cap.lane_count =
-				link_setting->lane_count;
-	core_link->public.verified_link_cap.link_rate =
-				link_setting->link_rate;
+	core_link->public.preferred_link_setting =
+				*link_setting;
 	dp_retrain_link_dp_test(core_link, link_setting, false);
 }
 

commit 6d244be884d20b1e9c912291a242dccedd6d9040
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Jul 20 00:12:20 2017 -0400

    drm/amd/display: plumbing to allow easy print of HW state for DTN
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index eda36c7a5c57..ad1b90563eb6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -2035,3 +2035,10 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 
 }
 
+void dc_log_hw_state(struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	if (core_dc->hwss.log_hw_state)
+		core_dc->hwss.log_hw_state(core_dc);
+}

commit 90114434772321881c8d11133b634e710e4e1f06
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Thu Jul 13 16:27:08 2017 -0400

    drm/amd/display: Fix S3 gamma corruption.
    
    On S3 resume gamma is corrupted since no gamma programming
    took place.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 20f41991f94d..eda36c7a5c57 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1120,11 +1120,13 @@ bool dc_commit_surfaces_to_stream(
 
 	stream_update->src = dc_stream->src;
 	stream_update->dst = dc_stream->dst;
+	stream_update->out_transfer_func = dc_stream->out_transfer_func;
 
 	for (i = 0; i < new_surface_count; i++) {
 		updates[i].surface = new_surfaces[i];
 		updates[i].gamma =
 			(struct dc_gamma *)new_surfaces[i]->gamma_correction;
+		updates[i].in_transfer_func = new_surfaces[i]->in_transfer_func;
 		flip_addr[i].address = new_surfaces[i]->address;
 		flip_addr[i].flip_immediate = new_surfaces[i]->flip_immediate;
 		plane_info[i].color_space = new_surfaces[i]->color_space;

commit 60bf1860d29f4f459e8b195dc73fcb2d980500d0
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Thu Jul 13 10:52:47 2017 -0400

    drm/amd/display: Preserve refcount for S3 case.
    
    Curent_context is zerroed out for suspend, keep the refcount.
    Minor code move in dc_commit_context_no_check
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8e580ac91b2a..20f41991f94d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -977,10 +977,10 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	dc_release_validate_context(core_dc->current_context);
 
-	dc_retain_validate_context(context);
-
 	core_dc->current_context = context;
 
+	dc_retain_validate_context(core_dc->current_context);
+
 	return (result == DC_OK);
 }
 
@@ -1065,8 +1065,6 @@ bool dc_commit_streams(
 
 	result = dc_commit_context_no_check(dc, context);
 
-	return (result == DC_OK);
-
 fail:
 	dc_release_validate_context(context);
 
@@ -1736,6 +1734,7 @@ void dc_set_power_state(
 	enum dc_acpi_cm_power_state power_state)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int ref_count;
 
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
@@ -1749,8 +1748,13 @@ void dc_set_power_state(
 		 * clean state, and dc hw programming optimizations will not
 		 * cause any trouble.
 		 */
+
+		/* Preserve refcount */
+		ref_count = core_dc->current_context->ref_count;
+		dc_resource_validate_ctx_destruct(core_dc->current_context);
 		memset(core_dc->current_context, 0,
 				sizeof(*core_dc->current_context));
+		core_dc->current_context->ref_count = ref_count;
 
 		break;
 	}

commit 9a3afbb3ea37b9a6bc16b9d6e4a51b183724158d
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Jul 11 18:36:42 2017 -0400

    drm/amd/display: dc_validate_ctx refocunt fixes.
    
    In dc_resource_validate_ctx_copy_construct don't override dst
    context refcount.
    
    Remove extra retain to new ctx in dc_update_surfaces_and_stream
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e81c9d57b3d1..8e580ac91b2a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -424,6 +424,7 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 static void destruct(struct core_dc *dc)
 {
 	dc_release_validate_context(dc->current_context);
+	dc->current_context = NULL;
 
 	destroy_links(dc);
 
@@ -441,9 +442,6 @@ static void destruct(struct core_dc *dc)
 	if (dc->ctx->logger)
 		dal_logger_destroy(&dc->ctx->logger);
 
-	dm_free(dc->current_context);
-	dc->current_context = NULL;
-
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
 }
@@ -1656,7 +1654,6 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	if (core_dc->current_context != context) {
 		dc_release_validate_context(core_dc->current_context);
-		dc_retain_validate_context(context);
 		core_dc->current_context = context;
 	}
 	return;

commit 8a76708ec4be2e9d63131e3769f17a04d8a82c87
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Jul 11 14:41:51 2017 -0400

    drm/amd/display: Introduce refcount for dc_validate_context
    
    Linux requires to be able to release allocated context
    in case it was never commited.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4f9302901a62..e81c9d57b3d1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -423,7 +423,7 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 
 static void destruct(struct core_dc *dc)
 {
-	dc_resource_validate_ctx_destruct(dc->current_context);
+	dc_release_validate_context(dc->current_context);
 
 	destroy_links(dc);
 
@@ -467,6 +467,8 @@ static bool construct(struct core_dc *dc,
 		goto val_ctx_fail;
 	}
 
+	dc->current_context->ref_count++;
+
 	dc_ctx->cgs_device = init_params->cgs_device;
 	dc_ctx->driver_context = init_params->driver;
 	dc_ctx->dc = &dc->public;
@@ -683,6 +685,8 @@ struct validate_context *dc_get_validate_context(
 	if (context == NULL)
 		goto context_alloc_fail;
 
+	++context->ref_count;
+
 	if (!is_validation_required(core_dc, set, set_count)) {
 		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
 		return context;
@@ -698,8 +702,7 @@ struct validate_context *dc_get_validate_context(
 				__func__,
 				result);
 
-		dc_resource_validate_ctx_destruct(context);
-		dm_free(context);
+		dc_release_validate_context(context);
 		context = NULL;
 	}
 
@@ -720,6 +723,8 @@ bool dc_validate_resources(
 	if (context == NULL)
 		goto context_alloc_fail;
 
+	++context->ref_count;
+
 	result = core_dc->res_pool->funcs->validate_with_context(
 				core_dc, set, set_count, context, NULL);
 
@@ -731,8 +736,7 @@ bool dc_validate_resources(
 				result);
 	}
 
-	dc_resource_validate_ctx_destruct(context);
-	dm_free(context);
+	dc_release_validate_context(context);
 	context = NULL;
 
 	return result == DC_OK;
@@ -750,11 +754,12 @@ bool dc_validate_guaranteed(
 	if (context == NULL)
 		goto context_alloc_fail;
 
+	++context->ref_count;
+
 	result = core_dc->res_pool->funcs->validate_guaranteed(
 					core_dc, stream, context);
 
-	dc_resource_validate_ctx_destruct(context);
-	dm_free(context);
+	dc_release_validate_context(context);
 
 context_alloc_fail:
 	if (result != DC_OK) {
@@ -972,8 +977,10 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	dc_resource_validate_ctx_destruct(core_dc->current_context);
-	dm_free(core_dc->current_context);
+	dc_release_validate_context(core_dc->current_context);
+
+	dc_retain_validate_context(context);
+
 	core_dc->current_context = context;
 
 	return (result == DC_OK);
@@ -1045,6 +1052,8 @@ bool dc_commit_streams(
 	if (context == NULL)
 		goto context_alloc_fail;
 
+	++context->ref_count;
+
 	result = core_dc->res_pool->funcs->validate_with_context(
 			core_dc, set, stream_count, context, core_dc->current_context);
 	if (result != DC_OK){
@@ -1053,7 +1062,6 @@ bool dc_commit_streams(
 					__func__,
 					result);
 		BREAK_TO_DEBUGGER();
-		dc_resource_validate_ctx_destruct(context);
 		goto fail;
 	}
 
@@ -1062,7 +1070,7 @@ bool dc_commit_streams(
 	return (result == DC_OK);
 
 fail:
-	dm_free(context);
+	dc_release_validate_context(context);
 
 context_alloc_fail:
 	return (result == DC_OK);
@@ -1155,6 +1163,23 @@ bool dc_commit_surfaces_to_stream(
 	return true;
 }
 
+void dc_retain_validate_context(struct validate_context *context)
+{
+	ASSERT(context->ref_count > 0);
+	++context->ref_count;
+}
+
+void dc_release_validate_context(struct validate_context *context)
+{
+	ASSERT(context->ref_count > 0);
+	--context->ref_count;
+
+	if (context->ref_count == 0) {
+		dc_resource_validate_ctx_destruct(context);
+		dm_free(context);
+	}
+}
+
 static bool is_surface_in_context(
 		const struct validate_context *context,
 		const struct dc_surface *surface)
@@ -1341,6 +1366,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	struct dc_context *dc_ctx = core_dc->ctx;
 
 	stream_status = dc_stream_get_status(dc_stream);
 	ASSERT(stream_status);
@@ -1403,6 +1429,11 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* initialize scratch memory for building context */
 		context = dm_alloc(sizeof(*context));
+		if (context == NULL)
+				goto context_alloc_fail;
+
+		++context->ref_count;
+
 		dc_resource_validate_ctx_copy_construct(
 				core_dc->current_context, context);
 
@@ -1624,16 +1655,17 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	}
 
 	if (core_dc->current_context != context) {
-		dc_resource_validate_ctx_destruct(core_dc->current_context);
-		dm_free(core_dc->current_context);
-
+		dc_release_validate_context(core_dc->current_context);
+		dc_retain_validate_context(context);
 		core_dc->current_context = context;
 	}
 	return;
 
 fail:
-	dc_resource_validate_ctx_destruct(context);
-	dm_free(context);
+	dc_release_validate_context(context);
+
+context_alloc_fail:
+	DC_ERROR("Failed to allocate new validate context!\n");
 }
 
 uint8_t dc_get_current_stream_count(const struct dc *dc)

commit a85c205ae3d183c196d0af7df336b1315e95faf7
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Mon Jul 10 15:52:10 2017 -0400

    drm/amd/display: Fix context copy memory leak
    
    This change corrects an error introduced in 355f123f. Instead of
    using the copy constructor to assign the new context, we swap the
    pointer.
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 52077d39b30a..4f9302901a62 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -972,7 +972,9 @@ static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *c
 
 	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
 
-	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
+	dc_resource_validate_ctx_destruct(core_dc->current_context);
+	dm_free(core_dc->current_context);
+	core_dc->current_context = context;
 
 	return (result == DC_OK);
 }
@@ -1057,9 +1059,6 @@ bool dc_commit_streams(
 
 	result = dc_commit_context_no_check(dc, context);
 
-	dc_resource_validate_ctx_destruct(context);
-	dm_free(context);
-
 	return (result == DC_OK);
 
 fail:

commit fa6ecfc67a4a0f96b5e4b6d5437602f2d5b191ac
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Thu Jul 6 13:53:15 2017 -0400

    drm/amd/display: Refactor dc_commit_streams
    
    Change it to sue dc_commit_context. dc_commit_context
    is used directly from Linux DM.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2f93f0e9ba84..52077d39b30a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -913,33 +913,22 @@ bool dc_enable_stereo(
 	return ret;
 }
 
-/* TODO operate on validation set (or something like it) */
-bool dc_commit_context(struct dc *dc, struct validate_context *context)
+
+/*
+ * Applies given context to HW and copy it into current context.
+ * It's up to the user to release the src context afterwards.
+ */
+static bool dc_commit_context_no_check(struct dc *dc, struct validate_context *context)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
+	const struct dc_stream *dc_streams[MAX_STREAMS] = {0};
 
-	if (!context)
-		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
-				"%s: dc_commit_context with no context!\n",
-				__func__);
-
-	if (false == context_changed(core_dc, context))
-		return DC_OK;
-
-	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
-				__func__, context->stream_count);
-
-	for (i = 0; i < context->stream_count; i++) {
-		const struct dc_stream *stream = &context->streams[i]->public;
-
-		dc_stream_log(stream,
-				core_dc->ctx->logger,
-				LOG_DC);
-	}
+	for (i = 0; i < context->stream_count; i++)
+		dc_streams[i] =  &context->streams[i]->public;
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		core_dc->hwss.enable_accelerated_mode(core_dc);
@@ -981,22 +970,49 @@ bool dc_commit_context(struct dc *dc, struct validate_context *context)
 				context->streams[i]->public.timing.pix_clk_khz);
 	}
 
+	dc_enable_stereo(dc, context, dc_streams, context->stream_count);
+
 	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
 
 	return (result == DC_OK);
 }
 
+bool dc_commit_context(struct dc *dc, struct validate_context *context)
+{
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	if (false == context_changed(core_dc, context))
+		return DC_OK;
+
+	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+				__func__, context->stream_count);
+
+	for (i = 0; i < context->stream_count; i++) {
+		const struct dc_stream *stream = &context->streams[i]->public;
+
+		dc_stream_log(stream,
+				core_dc->ctx->logger,
+				LOG_DC);
+	}
+
+	result = dc_commit_context_no_check(dc, context);
+
+	return (result == DC_OK);
+}
+
+
 bool dc_commit_streams(
 	struct dc *dc,
 	const struct dc_stream *streams[],
 	uint8_t stream_count)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
-	int i, j;
+	int i;
 
 	if (false == streams_changed(core_dc, streams, stream_count))
 		return DC_OK;
@@ -1039,43 +1055,10 @@ bool dc_commit_streams(
 		goto fail;
 	}
 
-	if (!dcb->funcs->is_accelerated_mode(dcb)) {
-		core_dc->hwss.enable_accelerated_mode(core_dc);
-	}
-
-	if (result == DC_OK) {
-		result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
-	}
-
-	program_timing_sync(core_dc, context);
-
-	for (i = 0; i < context->stream_count; i++) {
-		const struct core_sink *sink = context->streams[i]->sink;
-
-		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			struct core_surface *surface =
-					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
-
-			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
-		}
+	result = dc_commit_context_no_check(dc, context);
 
-		CONN_MSG_MODE(sink->link, "{%ux%u, %ux%u@%u, %ux%u@%uKhz}",
-				context->streams[i]->public.src.width,
-				context->streams[i]->public.src.height,
-				context->streams[i]->public.timing.h_addressable,
-				context->streams[i]->public.timing.v_addressable,
-				context->streams[i]->public.timing.pix_clk_khz * 1000 /
-					context->streams[i]->public.timing.h_total /
-					context->streams[i]->public.timing.v_total, // Refresh rate
-				context->streams[i]->public.timing.h_total,
-				context->streams[i]->public.timing.v_total,
-				context->streams[i]->public.timing.pix_clk_khz);
-	}
-	dc_enable_stereo(dc, context, streams, stream_count);
-	dc_resource_validate_ctx_destruct(core_dc->current_context);
-	dm_free(core_dc->current_context);
-
-	core_dc->current_context = context;
+	dc_resource_validate_ctx_destruct(context);
+	dm_free(context);
 
 	return (result == DC_OK);
 

commit f9ea47cec22ff332c2206249a18851c7eb68d832
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Wed Jul 5 13:28:24 2017 -0400

    drm/amd/display: Undo dc_update_surfaces_and_stream change.
    
    Restoring conditional call to in_transfer_func since no reason
    to call it unconditionally.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 90a31509edd6..2f93f0e9ba84 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1603,10 +1603,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-			/* TODO find out why check is false */
-			/* TODO with this still not programming some color stuff... panel is dark-ish */
-			/*if (is_new_pipe_surface ||
-					srf_updates[i].in_transfer_func)*/
+			if (srf_updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 

commit e2c7bb1228bec5b1224b235e90ffa1def8e3900e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jun 28 13:23:04 2017 -0400

    drm/amd/display: Use validate_context from atomic_check in commit
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b50fc0dae28c..90a31509edd6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -841,18 +841,17 @@ static void program_timing_sync(
 	}
 }
 
-static bool set_changed(
+static bool context_changed(
 		struct core_dc *dc,
-		const struct dc_validation_set set[],
-		uint8_t set_count)
+		struct validate_context *context)
 {
 	uint8_t i;
 
-	if (set_count != dc->current_context->stream_count)
+	if (context->stream_count != dc->current_context->stream_count)
 		return true;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (&dc->current_context->streams[i]->public != set[i].stream)
+		if (&dc->current_context->streams[i]->public != &context->streams[i]->public)
 			return true;
 	}
 
@@ -915,55 +914,37 @@ bool dc_enable_stereo(
 }
 
 /* TODO operate on validation set (or something like it) */
-bool dc_commit_validation_set(
-	const struct dc *dc,
-	const struct dc_validation_set set[],
-	uint8_t set_count)
+bool dc_commit_context(struct dc *dc, struct validate_context *context)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct validate_context *context;
 	struct pipe_ctx *pipe;
 	int i, j, k, l;
 
-	/* TODO check validation set changed */
-	if (false == set_changed(core_dc, set, set_count))
+	if (!context)
+		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
+				"%s: dc_commit_context with no context!\n",
+				__func__);
+
+	if (false == context_changed(core_dc, context))
 		return DC_OK;
 
 	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
-				__func__, set_count);
-
-	for (i = 0; i < set_count; i++)
-		dc_stream_log(set[i].stream,
-			      core_dc->ctx->logger,
-			      LOG_DC);
+				__func__, context->stream_count);
 
-	context = dm_alloc(sizeof(struct validate_context));
-	if (context == NULL)
-		goto context_alloc_fail;
+	for (i = 0; i < context->stream_count; i++) {
+		const struct dc_stream *stream = &context->streams[i]->public;
 
-	/* TODO no need for validation. just rebuild context */
-	/* TODO check context is created deterministically */
-	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set,
-								 set_count,
-								 context,
-								 core_dc->current_context);
-	if (result != DC_OK) {
-		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
-					"%s: Context validation failed! dc_status:%d\n",
-					__func__,
-					result);
-		BREAK_TO_DEBUGGER();
-		dc_resource_validate_ctx_destruct(context);
-		goto fail;
+		dc_stream_log(stream,
+				core_dc->ctx->logger,
+				LOG_DC);
 	}
 
 	if (!dcb->funcs->is_accelerated_mode(dcb))
 		core_dc->hwss.enable_accelerated_mode(core_dc);
 
-	if (result == DC_OK)
-		result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
+	result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
 
 	program_timing_sync(core_dc, context);
 
@@ -1000,17 +981,8 @@ bool dc_commit_validation_set(
 				context->streams[i]->public.timing.pix_clk_khz);
 	}
 
-	dc_resource_validate_ctx_destruct(core_dc->current_context);
-	dm_free(core_dc->current_context);
-
-	core_dc->current_context = context;
-
-	return (result == DC_OK);
-
-fail:
-	dm_free(context);
+	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
 
-context_alloc_fail:
 	return (result == DC_OK);
 }
 
@@ -1631,7 +1603,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-			if (srf_updates[i].in_transfer_func)
+			/* TODO find out why check is false */
+			/* TODO with this still not programming some color stuff... panel is dark-ish */
+			/*if (is_new_pipe_surface ||
+					srf_updates[i].in_transfer_func)*/
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 

commit 7cf2c840c6b5ee98195d249e3748bb90c9bcb831
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Mar 6 09:43:30 2017 -0500

    drm/amd/display: Commit validation set from state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1d2e421e8d0a..b50fc0dae28c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -841,6 +841,24 @@ static void program_timing_sync(
 	}
 }
 
+static bool set_changed(
+		struct core_dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count)
+{
+	uint8_t i;
+
+	if (set_count != dc->current_context->stream_count)
+		return true;
+
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (&dc->current_context->streams[i]->public != set[i].stream)
+			return true;
+	}
+
+	return false;
+}
+
 static bool streams_changed(
 		struct core_dc *dc,
 		const struct dc_stream *streams[],
@@ -896,6 +914,106 @@ bool dc_enable_stereo(
 	return ret;
 }
 
+/* TODO operate on validation set (or something like it) */
+bool dc_commit_validation_set(
+	const struct dc *dc,
+	const struct dc_validation_set set[],
+	uint8_t set_count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_bios *dcb = core_dc->ctx->dc_bios;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+	struct pipe_ctx *pipe;
+	int i, j, k, l;
+
+	/* TODO check validation set changed */
+	if (false == set_changed(core_dc, set, set_count))
+		return DC_OK;
+
+	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+				__func__, set_count);
+
+	for (i = 0; i < set_count; i++)
+		dc_stream_log(set[i].stream,
+			      core_dc->ctx->logger,
+			      LOG_DC);
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	/* TODO no need for validation. just rebuild context */
+	/* TODO check context is created deterministically */
+	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set,
+								 set_count,
+								 context,
+								 core_dc->current_context);
+	if (result != DC_OK) {
+		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
+					"%s: Context validation failed! dc_status:%d\n",
+					__func__,
+					result);
+		BREAK_TO_DEBUGGER();
+		dc_resource_validate_ctx_destruct(context);
+		goto fail;
+	}
+
+	if (!dcb->funcs->is_accelerated_mode(dcb))
+		core_dc->hwss.enable_accelerated_mode(core_dc);
+
+	if (result == DC_OK)
+		result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
+
+	program_timing_sync(core_dc, context);
+
+	for (i = 0; i < context->stream_count; i++) {
+		const struct core_sink *sink = context->streams[i]->sink;
+
+		for (j = 0; j < context->stream_status[i].surface_count; j++) {
+			struct core_surface *surface =
+					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
+
+			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+
+			/*
+			 * enable stereo
+			 * TODO rework dc_enable_stereo call to work with validation sets?
+			 */
+			for (k = 0; k < MAX_PIPES; k++) {
+				pipe = &context->res_ctx.pipe_ctx[k];
+
+				for (l = 0 ; pipe && l < context->stream_count; l++)  {
+					if (context->streams[l] &&
+					    context->streams[l] == pipe->stream &&
+					    core_dc->hwss.setup_stereo)
+						core_dc->hwss.setup_stereo(pipe, core_dc);
+				}
+			}
+		}
+
+		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
+				context->streams[i]->public.timing.h_addressable,
+				context->streams[i]->public.timing.v_addressable,
+				context->streams[i]->public.timing.h_total,
+				context->streams[i]->public.timing.v_total,
+				context->streams[i]->public.timing.pix_clk_khz);
+	}
+
+	dc_resource_validate_ctx_destruct(core_dc->current_context);
+	dm_free(core_dc->current_context);
+
+	core_dc->current_context = context;
+
+	return (result == DC_OK);
+
+fail:
+	dm_free(context);
+
+context_alloc_fail:
+	return (result == DC_OK);
+}
+
 bool dc_commit_streams(
 	struct dc *dc,
 	const struct dc_stream *streams[],

commit cdc5e04888cec337e44049f9b51d8894364ad52a
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Jun 28 13:36:25 2017 -0500

    drm/amd/display: Fix for hdmi frame pack stereo
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a9ddd0756b3b..1d2e421e8d0a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -967,7 +967,6 @@ bool dc_commit_streams(
 					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
 
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
-			dc_enable_stereo(dc, context, streams, stream_count);
 		}
 
 		CONN_MSG_MODE(sink->link, "{%ux%u, %ux%u@%u, %ux%u@%uKhz}",
@@ -982,7 +981,7 @@ bool dc_commit_streams(
 				context->streams[i]->public.timing.v_total,
 				context->streams[i]->public.timing.pix_clk_khz);
 	}
-
+	dc_enable_stereo(dc, context, streams, stream_count);
 	dc_resource_validate_ctx_destruct(core_dc->current_context);
 	dm_free(core_dc->current_context);
 

commit abe07e80836fb25a5bcfda573413a68be82439c6
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Wed Jun 28 17:21:42 2017 -0400

    drm/amd/display: Add DC interface for custom CSC matrix
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Vitaly Prosyak <Vitaly.Prosyak@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c113c1a259d4..a9ddd0756b3b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -221,6 +221,29 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 	return ret;
 }
 
+static bool program_csc_matrix(struct dc *dc, const struct dc_stream *stream)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
+	int i = 0;
+	bool ret = false;
+	struct pipe_ctx *pipes;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
+				== core_stream) {
+
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.program_csc_matrix(pipes,
+			core_stream->public.output_color_space,
+			core_stream->public.csc_color_matrix.matrix);
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
 static void set_static_screen_events(struct dc *dc,
 		const struct dc_stream **stream,
 		int num_streams,
@@ -373,6 +396,9 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
+	core_dc->public.stream_funcs.program_csc_matrix =
+			program_csc_matrix;
+
 	core_dc->public.stream_funcs.set_dither_option =
 			set_dither_option;
 

commit 9ff1bb090b40949cddfbb904e613395ad2633fc7
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Fri Jun 23 17:45:50 2017 -0400

    drm/amd/display: Add extra mode and clock info to DTN logs
    
    Adds some additional information to logs in dc_commit_streams to
    better match Dal2.
    
    Also adds a new function, dc_raw_log, that has the same
    functionality as dc_conn_log, but does not attach display specific
    prefixes to the log output.
    
    Finally, adds a new DC log type, LOG_DTN, that logs to
    LogMinor_DispConnect_dtn in DM. This new log type and dc_raw_log
    are used to generate clock info in the logs to match Dal2.
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 51e4cb30f858..c113c1a259d4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -944,9 +944,14 @@ bool dc_commit_streams(
 			dc_enable_stereo(dc, context, streams, stream_count);
 		}
 
-		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
+		CONN_MSG_MODE(sink->link, "{%ux%u, %ux%u@%u, %ux%u@%uKhz}",
+				context->streams[i]->public.src.width,
+				context->streams[i]->public.src.height,
 				context->streams[i]->public.timing.h_addressable,
 				context->streams[i]->public.timing.v_addressable,
+				context->streams[i]->public.timing.pix_clk_khz * 1000 /
+					context->streams[i]->public.timing.h_total /
+					context->streams[i]->public.timing.v_total, // Refresh rate
 				context->streams[i]->public.timing.h_total,
 				context->streams[i]->public.timing.v_total,
 				context->streams[i]->public.timing.pix_clk_khz);

commit 1663ae1c4288da81b9f1668d204aa8ed55ebf849
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Jun 27 16:34:27 2017 -0400

    drm/amd/display: Connect DC resource to FBC compressor
    
    - Connected DC resource to FBC compressor,
    - Initial Implementation of FBC for Stoney/Carrizo
    - Code is currently guarded with "ENABLE_FBC" compile time flag
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2f481ef55490..51e4cb30f858 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -843,6 +843,11 @@ bool dc_enable_stereo(
 	int i, j;
 	struct pipe_ctx *pipe;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+#ifdef ENABLE_FBC
+	struct compressor *fbc_compressor = core_dc->fbc_compressor;
+#endif
+
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context != NULL)
 			pipe = &context->res_ctx.pipe_ctx[i];
@@ -854,6 +859,14 @@ bool dc_enable_stereo(
 				core_dc->hwss.setup_stereo(pipe, core_dc);
 		}
 	}
+
+#ifdef ENABLE_FBC
+	if (fbc_compressor != NULL &&
+	    fbc_compressor->funcs->is_fbc_enabled_in_hw(core_dc->fbc_compressor,
+							&pipe->tg->inst))
+		fbc_compressor->funcs->disable_fbc(fbc_compressor);
+
+#endif
 	return ret;
 }
 
@@ -1232,6 +1245,12 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (!stream_status)
 		return; /* Cannot commit surface to stream that is not committed */
 
+#ifdef ENABLE_FBC
+	if (srf_updates->flip_addr) {
+		if (srf_updates->flip_addr->address.grph.addr.low_part == 0)
+			ASSERT(0);
+	}
+#endif
 	context = core_dc->current_context;
 
 	/* update current stream with the new updates */

commit cfe4645e17f8dbe680c35c439d000313f2648482
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 14 18:58:04 2017 -0400

    drm/amd/display: fix dcn pipe reset sequence
    
    This change fixes dcn10 front end reset sequence. Previously we
    would reset front end during flip which led to issues
    in certain MPO and 4k/5k scenarios. We would also never properly
    power gate our front end.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 18fde5081742..2f481ef55490 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -963,11 +963,8 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL
-				|| context->res_ctx.pipe_ctx[i].surface == NULL) {
-			context->res_ctx.pipe_ctx[i].pipe_idx = i;
-			core_dc->hwss.power_down_front_end(
-					core_dc, &context->res_ctx.pipe_ctx[i]);
-		}
+				|| context->res_ctx.pipe_ctx[i].surface == NULL)
+			core_dc->hwss.power_down_front_end(core_dc, i);
 
 	/* 3rd param should be true, temp w/a for RV*/
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -989,7 +986,6 @@ bool dc_commit_surfaces_to_stream(
 	struct dc_plane_info plane_info[MAX_SURFACES];
 	struct dc_scaling_info scaling_info[MAX_SURFACES];
 	int i;
-	bool ret;
 	struct dc_stream_update *stream_update =
 			dm_alloc(sizeof(struct dc_stream_update));
 
@@ -1038,10 +1034,10 @@ bool dc_commit_surfaces_to_stream(
 			new_surface_count,
 			dc_stream, stream_update);
 
-	ret = dc_post_update_surfaces_to_stream(dc);
+	dc_post_update_surfaces_to_stream(dc);
 
 	dm_free(stream_update);
-	return ret;
+	return true;
 }
 
 static bool is_surface_in_context(
@@ -1217,14 +1213,6 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	return overall_type;
 }
 
-void dc_update_surfaces_for_stream(struct dc *dc,
-		struct dc_surface_update *surface_updates, int surface_count,
-		const struct dc_stream *dc_stream)
-{
-	dc_update_surfaces_and_stream(dc, surface_updates, surface_count,
-			dc_stream, NULL);
-}
-
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_surfaces_and_stream(struct dc *dc,
@@ -1401,7 +1389,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 	}
 
-	if (!surface_count)  /* reset */
+	if (surface_count == 0)
 		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
 
 	/* Lock pipes for provided surfaces, or all active if full update*/

commit f19d5f3520d67cee4a98721032c1b7aee7942f20
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 13 17:14:51 2017 -0400

    drm/amd/display: do full fe reprogram on full update
    
    Fixes MPO entry in 2x4k scenario on raven
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 909d38522361..18fde5081742 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1404,15 +1404,18 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (!surface_count)  /* reset */
 		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
 
-	/* Lock pipes for provided surfaces */
+	/* Lock pipes for provided surfaces, or all active if full update*/
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (pipe_ctx->surface != surface)
+			if (update_type != UPDATE_TYPE_FULL && pipe_ctx->surface != surface)
+				continue;
+			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
 				continue;
+
 			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 				core_dc->hwss.pipe_control_lock(
 						core_dc,
@@ -1420,22 +1423,49 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 						true);
 			}
 		}
+		if (update_type == UPDATE_TYPE_FULL)
+			break;
 	}
 
+	/* Full fe update*/
+	for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+		struct pipe_ctx *cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
+		bool is_new_pipe_surface = cur_pipe_ctx->surface != pipe_ctx->surface;
+		struct dc_cursor_position position = { 0 };
+
+		if (update_type != UPDATE_TYPE_FULL || !pipe_ctx->surface)
+			continue;
+
+		if (!pipe_ctx->top_pipe)
+			core_dc->hwss.apply_ctx_for_surface(
+					core_dc, pipe_ctx->surface, context);
+
+		/* TODO: this is a hack w/a for switching from mpo to pipe split */
+		dc_stream_set_cursor_position(&pipe_ctx->stream->public, &position);
+
+		if (is_new_pipe_surface) {
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+			core_dc->hwss.set_input_transfer_func(
+					pipe_ctx, pipe_ctx->surface);
+			core_dc->hwss.set_output_transfer_func(
+					pipe_ctx, pipe_ctx->stream);
+		}
+	}
+
+	if (update_type > UPDATE_TYPE_FAST)
+		context_timing_trace(dc, &context->res_ctx);
+
 	/* Perform requested Updates */
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
-		if (update_type >= UPDATE_TYPE_MED) {
-				core_dc->hwss.apply_ctx_for_surface(
-						core_dc, surface, context);
-				context_timing_trace(dc, &context->res_ctx);
-		}
+		if (update_type == UPDATE_TYPE_MED)
+			core_dc->hwss.apply_ctx_for_surface(
+					core_dc, surface, context);
 
 		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-			struct pipe_ctx *cur_pipe_ctx;
-			bool is_new_pipe_surface = true;
 
 			if (pipe_ctx->surface != surface)
 				continue;
@@ -1446,19 +1476,12 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;
 
-			cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
-			if (cur_pipe_ctx->surface == pipe_ctx->surface)
-				is_new_pipe_surface = false;
-
-			if (is_new_pipe_surface ||
-					srf_updates[i].in_transfer_func)
+			if (srf_updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 
-			if (is_new_pipe_surface ||
-				(stream_update != NULL &&
-					stream_update->out_transfer_func !=
-							NULL)) {
+			if (stream_update != NULL &&
+					stream_update->out_transfer_func != NULL) {
 				core_dc->hwss.set_output_transfer_func(
 						pipe_ctx, pipe_ctx->stream);
 			}
@@ -1475,15 +1498,19 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		for (j = 0; j < surface_count; j++) {
-			if (srf_updates[j].surface == &pipe_ctx->surface->public) {
-				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-					core_dc->hwss.pipe_control_lock(
-							core_dc,
-							pipe_ctx,
-							false);
-				}
-				break;
+			if (update_type != UPDATE_TYPE_FULL &&
+					srf_updates[j].surface != &pipe_ctx->surface->public)
+				continue;
+			if (!pipe_ctx->surface || pipe_ctx->top_pipe)
+				continue;
+
+			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
+				core_dc->hwss.pipe_control_lock(
+						core_dc,
+						pipe_ctx,
+						false);
 			}
+			break;
 		}
 	}
 

commit 7950f0f9815a2dc2e3e1cc2d341d486ac2ae8bae
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 13 17:08:22 2017 -0400

    drm/amd/display: fix dc_post_update_surfaces_to_stream
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a8f34a92cee2..909d38522361 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -953,15 +953,6 @@ bool dc_commit_streams(
 	return (result == DC_OK);
 }
 
-bool dc_pre_update_surfaces_to_stream(
-		struct dc *dc,
-		const struct dc_surface *const *new_surfaces,
-		uint8_t new_surface_count,
-		const struct dc_stream *dc_stream)
-{
-	return true;
-}
-
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
@@ -971,14 +962,19 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	post_surface_trace(dc);
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
-		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
+		if (context->res_ctx.pipe_ctx[i].stream == NULL
+				|| context->res_ctx.pipe_ctx[i].surface == NULL) {
 			context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
 					core_dc, &context->res_ctx.pipe_ctx[i]);
 		}
 
+	/* 3rd param should be true, temp w/a for RV*/
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	core_dc->hwss.set_bandwidth(core_dc, context, core_dc->ctx->dce_version != DCN_VERSION_1_0);
+#else
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
-
+#endif
 	return true;
 }
 
@@ -1262,17 +1258,12 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		if (stream_update->out_transfer_func &&
 				stream_update->out_transfer_func !=
-				dc_stream->out_transfer_func) {
-			if (stream_update->out_transfer_func->type !=
-					TF_TYPE_UNKNOWN) {
-				if (dc_stream->out_transfer_func != NULL)
-					dc_transfer_func_release
-					(dc_stream->out_transfer_func);
-				dc_transfer_func_retain(stream_update->
-					out_transfer_func);
-				stream->public.out_transfer_func =
-					stream_update->out_transfer_func;
-			}
+						dc_stream->out_transfer_func) {
+			if (dc_stream->out_transfer_func != NULL)
+				dc_transfer_func_release(dc_stream->out_transfer_func);
+			dc_transfer_func_retain(stream_update->out_transfer_func);
+			stream->public.out_transfer_func =
+				stream_update->out_transfer_func;
 		}
 	}
 

commit ebf055f95b4782e681c0040461a33c0210e65a5d
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Jun 14 10:19:57 2017 -0400

    drm/amd/display: fix issues with incorrectly detecting UPDATE_TYPE_FULL
    
    This is due to how structures are being packed with padding added.
    Structure field initialization doesn't clear the padding bytes, which cause
    our memcmp to give incorrect result.
    
    Move smaller structure parameters to end of structure.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f5f365b418c2..a8f34a92cee2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -628,7 +628,8 @@ static bool is_validation_required(
 			return true;
 
 		for (j = 0; j < set[i].surface_count; j++) {
-			struct dc_surface temp_surf = { 0 };
+			struct dc_surface temp_surf;
+			memset(&temp_surf, 0, sizeof(temp_surf));
 
 			temp_surf = *context->stream_status[i].surfaces[j];
 			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
@@ -1095,6 +1096,7 @@ static enum surface_update_type get_plane_info_update_type(
 		int surface_index)
 {
 	struct dc_plane_info temp_plane_info;
+	memset(&temp_plane_info, 0, sizeof(temp_plane_info));
 
 	if (!u->plane_info)
 		return UPDATE_TYPE_FAST;
@@ -1294,7 +1296,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
-		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
+		const struct dc_surface *new_surfaces[MAX_SURFACES] = {0};
 
 		for (i = 0; i < surface_count; i++)
 			new_surfaces[i] = srf_updates[i].surface;

commit 80b4c5a8c1e1856848a440a63accbe029ea3b51b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jun 13 16:31:49 2017 -0400

    drm/amd/display: fix dc_check_update_surfaces_for_stream memcmp sequence
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e518aeddfa58..f5f365b418c2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1094,11 +1094,13 @@ static enum surface_update_type get_plane_info_update_type(
 		const struct dc_surface_update *u,
 		int surface_index)
 {
-	struct dc_plane_info temp_plane_info = { 0 };
+	struct dc_plane_info temp_plane_info;
 
 	if (!u->plane_info)
 		return UPDATE_TYPE_FAST;
 
+	temp_plane_info = *u->plane_info;
+
 	/* Copy all parameters that will cause a full update
 	 * from current surface, the rest of the parameters
 	 * from provided plane configuration.
@@ -1115,10 +1117,6 @@ static enum surface_update_type get_plane_info_update_type(
 	temp_plane_info.stereo_format = u->surface->stereo_format;
 	temp_plane_info.tiling_info = u->surface->tiling_info;
 
-	/* Special Validation parameters */
-	temp_plane_info.format = u->plane_info->format;
-	temp_plane_info.per_pixel_alpha = u->plane_info->per_pixel_alpha;
-
 	if (surface_index == 0)
 		temp_plane_info.visible = u->plane_info->visible;
 	else

commit 7f5c22d1652327b64375e88b184b0df502c7bdc7
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Jun 8 15:55:02 2017 -0500

    drm/amd/display: RV stereo support
    
    HDMI frame pack and DP frame alternate in band
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 47870a640f37..e518aeddfa58 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -832,6 +832,30 @@ static bool streams_changed(
 	return false;
 }
 
+bool dc_enable_stereo(
+	struct dc *dc,
+	struct validate_context *context,
+	const struct dc_stream *streams[],
+	uint8_t stream_count)
+{
+	bool ret = true;
+	int i, j;
+	struct pipe_ctx *pipe;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (context != NULL)
+			pipe = &context->res_ctx.pipe_ctx[i];
+		else
+			pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
+		for (j = 0 ; pipe && j < stream_count; j++)  {
+			if (streams[j] && streams[j] == &pipe->stream->public &&
+				core_dc->hwss.setup_stereo)
+				core_dc->hwss.setup_stereo(pipe, core_dc);
+		}
+	}
+	return ret;
+}
+
 bool dc_commit_streams(
 	struct dc *dc,
 	const struct dc_stream *streams[],
@@ -903,6 +927,7 @@ bool dc_commit_streams(
 					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
 
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+			dc_enable_stereo(dc, context, streams, stream_count);
 		}
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",

commit c9742685c24acd6d71cdda3067bfc2f512fe2b7c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 7 13:53:30 2017 -0400

    drm/amd/display: add bw logging for dcn
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index fb5bacb50ebc..47870a640f37 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1379,8 +1379,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
-		} else
+		} else {
 			core_dc->hwss.set_bandwidth(core_dc, context, false);
+			context_clock_trace(dc, context);
+		}
 	}
 
 	if (!surface_count)  /* reset */

commit ba326a9185f1c56d86e51dd89589e4eff42f02eb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jun 2 19:01:37 2017 -0400

    drm/amd/display: propagate surface alpha setting from OS to DC
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 657e10bae93f..fb5bacb50ebc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -998,6 +998,7 @@ bool dc_commit_surfaces_to_stream(
 		plane_info[i].stereo_format = new_surfaces[i]->stereo_format;
 		plane_info[i].tiling_info = new_surfaces[i]->tiling_info;
 		plane_info[i].visible = new_surfaces[i]->visible;
+		plane_info[i].per_pixel_alpha = new_surfaces[i]->per_pixel_alpha;
 		plane_info[i].dcc = new_surfaces[i]->dcc;
 		scaling_info[i].scaling_quality = new_surfaces[i]->scaling_quality;
 		scaling_info[i].src_rect = new_surfaces[i]->src_rect;
@@ -1068,7 +1069,7 @@ static enum surface_update_type get_plane_info_update_type(
 		const struct dc_surface_update *u,
 		int surface_index)
 {
-	struct dc_plane_info temp_plane_info = { { { { 0 } } } };
+	struct dc_plane_info temp_plane_info = { 0 };
 
 	if (!u->plane_info)
 		return UPDATE_TYPE_FAST;
@@ -1091,6 +1092,7 @@ static enum surface_update_type get_plane_info_update_type(
 
 	/* Special Validation parameters */
 	temp_plane_info.format = u->plane_info->format;
+	temp_plane_info.per_pixel_alpha = u->plane_info->per_pixel_alpha;
 
 	if (surface_index == 0)
 		temp_plane_info.visible = u->plane_info->visible;
@@ -1327,6 +1329,8 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 					srf_updates[i].plane_info->tiling_info;
 			surface->public.visible =
 					srf_updates[i].plane_info->visible;
+			surface->public.per_pixel_alpha =
+					srf_updates[i].plane_info->per_pixel_alpha;
 			surface->public.dcc =
 					srf_updates[i].plane_info->dcc;
 		}

commit 1bf56e62cc4fbff6d701b798da05a91f78aa12e9
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Fri Jun 2 17:25:49 2017 -0400

    drm/amd/display: Call program_gamut explicitly instead of entire set_plane
    
    This fixes on boot crush on Vega, Polaris with Dal3.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f5102b644942..657e10bae93f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -213,8 +213,7 @@ static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 				== core_stream) {
 
 			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
-			core_dc->hwss.set_plane_config(core_dc, pipes,
-					&core_dc->current_context->res_ctx);
+			core_dc->hwss.program_gamut_remap(pipes);
 			ret = true;
 		}
 	}

commit 556ee1b75c94cd88710e2fa8c83e2dc22717fc4f
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Thu Jun 1 16:54:53 2017 -0400

    drm/amd/display: Add assertion for invalid surface dimensions
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 976229eb2492..f5102b644942 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1258,8 +1258,10 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			srf_updates->surface->src_rect.height == 0 &&
 			srf_updates->surface->dst_rect.width == 0 &&
 			srf_updates->surface->dst_rect.height == 0 &&
-			!srf_updates->scaling_info)
+			!srf_updates->scaling_info) {
+		ASSERT(false);
 		return;
+	}
 
 	update_type = dc_check_update_surfaces_for_stream(
 			dc, srf_updates, surface_count, stream_update, stream_status);

commit e7b1322e15ea66c135ff98c1eb15fc542ef79c89
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Thu Jun 1 15:40:04 2017 -0400

    drm/amd/display: Don't update surface if dimensions are 0
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 323a5e706908..976229eb2492 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1250,8 +1250,15 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 	}
 
-	/* only proceed if we need to make a surface update */
-	if (!srf_updates)
+	/* do not perform surface update if surface has invalid dimensions
+	 * (all zero) and no scaling_info is provided
+	 */
+	if (surface_count > 0 &&
+			srf_updates->surface->src_rect.width == 0 &&
+			srf_updates->surface->src_rect.height == 0 &&
+			srf_updates->surface->dst_rect.width == 0 &&
+			srf_updates->surface->dst_rect.height == 0 &&
+			!srf_updates->scaling_info)
 		return;
 
 	update_type = dc_check_update_surfaces_for_stream(

commit e4bf0a0eed7e0e3bb7f0be2788cf0a5ecc16b068
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu May 25 10:55:54 2017 -0400

    drm/amd/display: create_links bug with empty DDI slot
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c33e31c9e3e1..323a5e706908 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -97,6 +97,7 @@ static bool create_links(
 		struct core_link *link;
 
 		link_init_params.ctx = dc->ctx;
+		/* next BIOS object table connector */
 		link_init_params.connector_index = i;
 		link_init_params.link_index = dc->link_count;
 		link_init_params.dc = dc;
@@ -106,8 +107,6 @@ static bool create_links(
 			dc->links[dc->link_count] = link;
 			link->dc = dc;
 			++dc->link_count;
-		} else {
-			dm_error("DC: failed to create link!\n");
 		}
 	}
 

commit c7dbdf1535a34741a8805d04a9ae75a887d8b581
Author: Corbin McElhanney <corbin.mcelhanney@amd.com>
Date:   Tue May 23 15:26:57 2017 -0400

    drm/amd/display: Allow update stream without surface
    
    Passing NULL as surfaceUpdates to dc_update_surfaces_and_stream now
    updates just the stream. Code that is dependent on srf_updates was moved
    below the NULL check.
    
    Signed-off-by: Corbin McElhanney <corbin.mcelhanney@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f5349970b594..c33e31c9e3e1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1223,33 +1223,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (!stream_status)
 		return; /* Cannot commit surface to stream that is not committed */
 
-	update_type = dc_check_update_surfaces_for_stream(
-			dc, srf_updates, surface_count, stream_update, stream_status);
-
-	if (update_type >= update_surface_trace_level)
-		update_surface_trace(dc, srf_updates, surface_count);
-
-	if (update_type >= UPDATE_TYPE_FULL) {
-		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
-
-		for (i = 0; i < surface_count; i++)
-			new_surfaces[i] = srf_updates[i].surface;
-
-		/* initialize scratch memory for building context */
-		context = dm_alloc(sizeof(*context));
-		dc_resource_validate_ctx_copy_construct(
-				core_dc->current_context, context);
-
-		/* add surface to context */
-		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, dc_stream,
-				context, core_dc->res_pool)) {
-			BREAK_TO_DEBUGGER();
-			goto fail;
-		}
-	} else {
-		context = core_dc->current_context;
-	}
+	context = core_dc->current_context;
 
 	/* update current stream with the new updates */
 	if (stream_update) {
@@ -1277,6 +1251,36 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 	}
 
+	/* only proceed if we need to make a surface update */
+	if (!srf_updates)
+		return;
+
+	update_type = dc_check_update_surfaces_for_stream(
+			dc, srf_updates, surface_count, stream_update, stream_status);
+
+	if (update_type >= update_surface_trace_level)
+		update_surface_trace(dc, srf_updates, surface_count);
+
+	if (update_type >= UPDATE_TYPE_FULL) {
+		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
+
+		for (i = 0; i < surface_count; i++)
+			new_surfaces[i] = srf_updates[i].surface;
+
+		/* initialize scratch memory for building context */
+		context = dm_alloc(sizeof(*context));
+		dc_resource_validate_ctx_copy_construct(
+				core_dc->current_context, context);
+
+		/* add surface to context */
+		if (!resource_attach_surfaces_to_context(
+				new_surfaces, surface_count, dc_stream,
+				context, core_dc->res_pool)) {
+			BREAK_TO_DEBUGGER();
+			goto fail;
+		}
+	}
+
 	/* save update parameters into surface */
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface =

commit 893a2dd4a3ffceb3b3fa88353d8270de06195b10
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon May 22 20:25:48 2017 -0400

    drm/amd/display: Clean unused interface.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4900e8073c69..f5349970b594 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -249,47 +249,6 @@ static void set_static_screen_events(struct dc *dc,
 	core_dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
 }
 
-/* This function is not expected to fail, proper implementation of
- * validation will prevent this from ever being called for unsupported
- * configurations.
- */
-static void stream_update_scaling(
-		const struct dc *dc,
-		const struct dc_stream *dc_stream,
-		const struct rect *src,
-		const struct rect *dst)
-{
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct validate_context *cur_ctx = core_dc->current_context;
-	int i;
-
-	if (src)
-		stream->public.src = *src;
-
-	if (dst)
-		stream->public.dst = *dst;
-
-	for (i = 0; i < cur_ctx->stream_count; i++) {
-		struct core_stream *cur_stream = cur_ctx->streams[i];
-
-		if (stream == cur_stream) {
-			struct dc_stream_status *status = &cur_ctx->stream_status[i];
-
-			if (status->surface_count)
-				if (!dc_commit_surfaces_to_stream(
-						&core_dc->public,
-						status->surfaces,
-						status->surface_count,
-						&cur_stream->public))
-					/* Need to debug validation */
-					BREAK_TO_DEBUGGER();
-
-			return;
-		}
-	}
-}
-
 static void set_drive_settings(struct dc *dc,
 		struct link_training_settings *lt_settings,
 		const struct dc_link *link)
@@ -402,7 +361,6 @@ void set_dither_option(const struct dc_stream *dc_stream,
 
 static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 {
-	core_dc->public.stream_funcs.stream_update_scaling = stream_update_scaling;
 	if (core_dc->hwss.set_drr != NULL) {
 		core_dc->public.stream_funcs.adjust_vmin_vmax =
 				stream_adjust_vmin_vmax;

commit c1473558e617d886276e4a8b3c139b681d90d67c
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri May 19 17:40:50 2017 -0400

    drm/amd/display: program scaler not called.
    
    Scaler code in case of UPDATE_TYPE_MED was not called
    since new pipe context and current context are the same.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b428c7c6559b..4900e8073c69 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1011,12 +1011,23 @@ bool dc_commit_surfaces_to_stream(
 	struct dc_plane_info plane_info[MAX_SURFACES];
 	struct dc_scaling_info scaling_info[MAX_SURFACES];
 	int i;
+	bool ret;
+	struct dc_stream_update *stream_update =
+			dm_alloc(sizeof(struct dc_stream_update));
+
+	if (!stream_update) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
 
 	memset(updates, 0, sizeof(updates));
 	memset(flip_addr, 0, sizeof(flip_addr));
 	memset(plane_info, 0, sizeof(plane_info));
 	memset(scaling_info, 0, sizeof(scaling_info));
 
+	stream_update->src = dc_stream->src;
+	stream_update->dst = dc_stream->dst;
+
 	for (i = 0; i < new_surface_count; i++) {
 		updates[i].surface = new_surfaces[i];
 		updates[i].gamma =
@@ -1041,9 +1052,17 @@ bool dc_commit_surfaces_to_stream(
 		updates[i].plane_info = &plane_info[i];
 		updates[i].scaling_info = &scaling_info[i];
 	}
-	dc_update_surfaces_for_stream(dc, updates, new_surface_count, dc_stream);
 
-	return dc_post_update_surfaces_to_stream(dc);
+	dc_update_surfaces_and_stream(
+			dc,
+			updates,
+			new_surface_count,
+			dc_stream, stream_update);
+
+	ret = dc_post_update_surfaces_to_stream(dc);
+
+	dm_free(stream_update);
+	return ret;
 }
 
 static bool is_surface_in_context(

commit 21de3396b44a67429c6b6a3f2d697fb261c76054
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Mon May 22 13:11:15 2017 +0800

    drm/amd/display: call amdgpu_dm_fini when hw_fini.
    
    to free up drm mode_config info.
    
    fix issue: unload amdgpu, can't load amdgpu again.
    [drm:drm_debugfs_init [drm]] *ERROR* Cannot create /sys/kernel/debug/dri/0
    [drm:drm_minor_register [drm]] *ERROR* DRM: Failed to initialize /sys/kernel/debug/dri.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Andrey Grodzovsky<andrey.grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 773f0efc449b..b428c7c6559b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1541,7 +1541,12 @@ enum dc_irq_source dc_interrupt_to_irq_source(
 
 void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_dc *core_dc;
+
+	if (dc == NULL)
+		return;
+	core_dc = DC_TO_CORE(dc);
+
 	dal_irq_service_set(core_dc->res_pool->irqs, src, enable);
 }
 

commit afc8935ef0fc04c87cd7e7749ff28c32be4f712a
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 17 16:56:56 2017 -0400

    drm/amd/display: revert dc_get_validate_context re-entrancy fix
    
    Apply dc_get_validate_context re-entrancy fix to dc_validate_resources instead
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0aafcc088284..773f0efc449b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -653,6 +653,40 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
+static bool is_validation_required(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	const struct validate_context *context = dc->current_context;
+	int i, j;
+
+	if (context->stream_count != set_count)
+		return true;
+
+	for (i = 0; i < set_count; i++) {
+
+		if (set[i].surface_count != context->stream_status[i].surface_count)
+			return true;
+		if (!is_stream_unchanged(DC_STREAM_TO_CORE(set[i].stream), context->streams[i]))
+			return true;
+
+		for (j = 0; j < set[i].surface_count; j++) {
+			struct dc_surface temp_surf = { 0 };
+
+			temp_surf = *context->stream_status[i].surfaces[j];
+			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
+			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
+			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
+
+			if (memcmp(&temp_surf, set[i].surfaces[j], sizeof(temp_surf)) != 0)
+				return true;
+		}
+	}
+
+	return false;
+}
+
 struct validate_context *dc_get_validate_context(
 		const struct dc *dc,
 		const struct dc_validation_set set[],
@@ -663,11 +697,16 @@ struct validate_context *dc_get_validate_context(
 	struct validate_context *context;
 
 	context = dm_alloc(sizeof(struct validate_context));
-	if(context == NULL)
+	if (context == NULL)
 		goto context_alloc_fail;
 
+	if (!is_validation_required(core_dc, set, set_count)) {
+		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
+		return context;
+	}
+
 	result = core_dc->res_pool->funcs->validate_with_context(
-				core_dc, set, set_count, context, NULL);
+			core_dc, set, set_count, context, core_dc->current_context);
 
 context_alloc_fail:
 	if (result != DC_OK) {
@@ -690,16 +729,30 @@ bool dc_validate_resources(
 		const struct dc_validation_set set[],
 		uint8_t set_count)
 {
-	struct validate_context *ctx;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
 
-	ctx = dc_get_validate_context(dc, set, set_count);
-	if (ctx) {
-		dc_resource_validate_ctx_destruct(ctx);
-		dm_free(ctx);
-		return true;
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	result = core_dc->res_pool->funcs->validate_with_context(
+				core_dc, set, set_count, context, NULL);
+
+context_alloc_fail:
+	if (result != DC_OK) {
+		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
+				"%s:resource validation failed, dc_status:%d\n",
+				__func__,
+				result);
 	}
 
-	return false;
+	dc_resource_validate_ctx_destruct(context);
+	dm_free(context);
+	context = NULL;
+
+	return result == DC_OK;
 }
 
 bool dc_validate_guaranteed(

commit 430ef426bc43b59a7444c08d664e24a7cf89710e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 17 16:05:40 2017 -0400

    drm/amd/display: make dc_get_validate_context re-entrant
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b5ba822df55e..0aafcc088284 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -653,40 +653,6 @@ void dc_destroy(struct dc **dc)
 	*dc = NULL;
 }
 
-static bool is_validation_required(
-		const struct core_dc *dc,
-		const struct dc_validation_set set[],
-		int set_count)
-{
-	const struct validate_context *context = dc->current_context;
-	int i, j;
-
-	if (context->stream_count != set_count)
-		return true;
-
-	for (i = 0; i < set_count; i++) {
-
-		if (set[i].surface_count != context->stream_status[i].surface_count)
-			return true;
-		if (!is_stream_unchanged(DC_STREAM_TO_CORE(set[i].stream), context->streams[i]))
-			return true;
-
-		for (j = 0; j < set[i].surface_count; j++) {
-			struct dc_surface temp_surf = { 0 };
-
-			temp_surf = *context->stream_status[i].surfaces[j];
-			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
-			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
-			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
-
-			if (memcmp(&temp_surf, set[i].surfaces[j], sizeof(temp_surf)) != 0)
-				return true;
-		}
-	}
-
-	return false;
-}
-
 struct validate_context *dc_get_validate_context(
 		const struct dc *dc,
 		const struct dc_validation_set set[],
@@ -700,13 +666,8 @@ struct validate_context *dc_get_validate_context(
 	if(context == NULL)
 		goto context_alloc_fail;
 
-	if (!is_validation_required(core_dc, set, set_count)) {
-		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
-		return context;
-	}
-
 	result = core_dc->res_pool->funcs->validate_with_context(
-						core_dc, set, set_count, context);
+				core_dc, set, set_count, context, NULL);
 
 context_alloc_fail:
 	if (result != DC_OK) {
@@ -903,7 +864,8 @@ bool dc_commit_streams(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set, stream_count, context);
+	result = core_dc->res_pool->funcs->validate_with_context(
+			core_dc, set, stream_count, context, core_dc->current_context);
 	if (result != DC_OK){
 		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
 					"%s: Context validation failed! dc_status:%d\n",

commit b802acc7f3266e43905dfeee865bf1acc4e00bce
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon May 15 14:47:02 2017 -0400

    drm/amd/display: Clean unused interface.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6d56cb0c29cc..b5ba822df55e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1515,32 +1515,6 @@ const struct audio **dc_get_audios(struct dc *dc)
 	return (const struct audio **)core_dc->res_pool->audios;
 }
 
-void dc_flip_surface_addrs(
-		struct dc *dc,
-		const struct dc_surface *const surfaces[],
-		struct dc_flip_addrs flip_addrs[],
-		uint32_t count)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int i, j;
-
-	for (i = 0; i < count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
-
-		surface->public.address = flip_addrs[i].address;
-		surface->public.flip_immediate = flip_addrs[i].flip_immediate;
-
-		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
-
-			if (pipe_ctx->surface != surface)
-				continue;
-
-			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-		}
-	}
-}
-
 enum dc_irq_source dc_interrupt_to_irq_source(
 		struct dc *dc,
 		uint32_t src_id,

commit b71a061801cb431d23854e0b6a6b7c04fa1f4c83
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 10 18:05:02 2017 -0400

    drm/amd/display: fix scaling info based surface update type check
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index bc9808180346..6d56cb0c29cc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1122,45 +1122,24 @@ static enum surface_update_type get_plane_info_update_type(
 static enum surface_update_type  get_scaling_info_update_type(
 		const struct dc_surface_update *u)
 {
-	struct dc_scaling_info temp_scaling_info = { { 0 } };
-
 	if (!u->scaling_info)
 		return UPDATE_TYPE_FAST;
 
-	/* Copy all parameters that will cause a full update
-	 * from current surface, the rest of the parameters
-	 * from provided plane configuration.
-	 * Perform memory compare and special validation
-	 * for those that can cause fast/medium updates
-	 */
-
-	/* Full Update Parameters */
-	temp_scaling_info.dst_rect = u->surface->dst_rect;
-	temp_scaling_info.src_rect = u->surface->src_rect;
-	temp_scaling_info.scaling_quality = u->surface->scaling_quality;
-
-	/* Special validation required */
-	temp_scaling_info.clip_rect = u->scaling_info->clip_rect;
-
-	if (memcmp(u->scaling_info, &temp_scaling_info,
-			sizeof(struct dc_scaling_info)) != 0)
+	if (u->scaling_info->src_rect.width != u->surface->src_rect.width
+			|| u->scaling_info->src_rect.height != u->surface->src_rect.height
+			|| u->scaling_info->clip_rect.width != u->surface->clip_rect.width
+			|| u->scaling_info->clip_rect.height != u->surface->clip_rect.height
+			|| u->scaling_info->dst_rect.width != u->surface->dst_rect.width
+			|| u->scaling_info->dst_rect.height != u->surface->dst_rect.height)
 		return UPDATE_TYPE_FULL;
 
-	/* Check Clip rectangles if not equal
-	 * difference is in offsets == > UPDATE_TYPE_MED
-	 * difference is in dimensions == > UPDATE_TYPE_FULL
-	 */
-	if (memcmp(&u->scaling_info->clip_rect,
-			&u->surface->clip_rect, sizeof(struct rect)) != 0) {
-		if ((u->scaling_info->clip_rect.height ==
-			u->surface->clip_rect.height) &&
-			(u->scaling_info->clip_rect.width ==
-			u->surface->clip_rect.width)) {
-			return UPDATE_TYPE_MED;
-		} else {
-			return UPDATE_TYPE_FULL;
-		}
-	}
+	if (u->scaling_info->src_rect.x != u->surface->src_rect.x
+			|| u->scaling_info->src_rect.y != u->surface->src_rect.y
+			|| u->scaling_info->clip_rect.x != u->surface->clip_rect.x
+			|| u->scaling_info->clip_rect.y != u->surface->clip_rect.y
+			|| u->scaling_info->dst_rect.x != u->surface->dst_rect.x
+			|| u->scaling_info->dst_rect.y != u->surface->dst_rect.y)
+		return UPDATE_TYPE_MED;
 
 	return UPDATE_TYPE_FAST;
 }

commit 0e12c3f6a0a4e73c6b6d11b7aebf20b7026ef18f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 10 11:35:07 2017 -0400

    drm/amd/display: add yuv pixel formats to pixel_format_to_bpp()
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1e6952bde25b..bc9808180346 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1051,8 +1051,13 @@ static bool is_surface_in_context(
 static unsigned int pixel_format_to_bpp(enum surface_pixel_format format)
 {
 	switch (format) {
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		return 12;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
 	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
 		return 16;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:

commit f46661dd42f3648b92eca73ba2c48f5d9a418b1b
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Tue May 9 14:45:54 2017 -0400

    drm/amd/display: Move output transfer function to stream updates
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 3c2554381a25..1e6952bde25b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -201,11 +201,10 @@ static bool stream_get_crtc_position(struct dc *dc,
 	return ret;
 }
 
-static bool set_gamut_remap(struct dc *dc,
-			const struct dc_stream **stream, int num_streams)
+static bool set_gamut_remap(struct dc *dc, const struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
 	int i = 0;
 	bool ret = false;
 	struct pipe_ctx *pipes;
@@ -1182,7 +1181,6 @@ static enum surface_update_type det_surface_update(
 		overall_type = type;
 
 	if (u->in_transfer_func ||
-		u->out_transfer_func ||
 		u->hdr_static_metadata) {
 		if (overall_type < UPDATE_TYPE_MED)
 			overall_type = UPDATE_TYPE_MED;
@@ -1279,8 +1277,28 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	/* update current stream with the new updates */
 	if (stream_update) {
-		stream->public.src = stream_update->src;
-		stream->public.dst = stream_update->dst;
+		if ((stream_update->src.height != 0) &&
+				(stream_update->src.width != 0))
+			stream->public.src = stream_update->src;
+
+		if ((stream_update->dst.height != 0) &&
+				(stream_update->dst.width != 0))
+			stream->public.dst = stream_update->dst;
+
+		if (stream_update->out_transfer_func &&
+				stream_update->out_transfer_func !=
+				dc_stream->out_transfer_func) {
+			if (stream_update->out_transfer_func->type !=
+					TF_TYPE_UNKNOWN) {
+				if (dc_stream->out_transfer_func != NULL)
+					dc_transfer_func_release
+					(dc_stream->out_transfer_func);
+				dc_transfer_func_retain(stream_update->
+					out_transfer_func);
+				stream->public.out_transfer_func =
+					stream_update->out_transfer_func;
+			}
+		}
 	}
 
 	/* save update parameters into surface */
@@ -1361,13 +1379,6 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 					srf_updates[i].in_transfer_func;
 		}
 
-		if (srf_updates[i].out_transfer_func &&
-			srf_updates[i].out_transfer_func != dc_stream->out_transfer_func) {
-			if (dc_stream->out_transfer_func != NULL)
-				dc_transfer_func_release(dc_stream->out_transfer_func);
-			dc_transfer_func_retain(srf_updates[i].out_transfer_func);
-			stream->public.out_transfer_func = srf_updates[i].out_transfer_func;
-		}
 		if (srf_updates[i].hdr_static_metadata)
 			surface->public.hdr_static_ctx =
 				*(srf_updates[i].hdr_static_metadata);
@@ -1436,11 +1447,12 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 						pipe_ctx, pipe_ctx->surface);
 
 			if (is_new_pipe_surface ||
-					srf_updates[i].out_transfer_func)
+				(stream_update != NULL &&
+					stream_update->out_transfer_func !=
+							NULL)) {
 				core_dc->hwss.set_output_transfer_func(
-						pipe_ctx,
-						pipe_ctx->surface,
-						pipe_ctx->stream);
+						pipe_ctx, pipe_ctx->stream);
+			}
 
 			if (srf_updates[i].hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);

commit e61a04f1af6187caebcad69ff72b571179b3dde9
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Apr 27 17:13:34 2017 -0400

    drm/amd/display: Use MED update type if clip position changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b30d4bc7b040..3c2554381a25 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1143,7 +1143,7 @@ static enum surface_update_type  get_scaling_info_update_type(
 		return UPDATE_TYPE_FULL;
 
 	/* Check Clip rectangles if not equal
-	 * difference is in offsets == > UPDATE_TYPE_FAST
+	 * difference is in offsets == > UPDATE_TYPE_MED
 	 * difference is in dimensions == > UPDATE_TYPE_FULL
 	 */
 	if (memcmp(&u->scaling_info->clip_rect,
@@ -1152,7 +1152,7 @@ static enum surface_update_type  get_scaling_info_update_type(
 			u->surface->clip_rect.height) &&
 			(u->scaling_info->clip_rect.width ==
 			u->surface->clip_rect.width)) {
-			return UPDATE_TYPE_FAST;
+			return UPDATE_TYPE_MED;
 		} else {
 			return UPDATE_TYPE_FULL;
 		}
@@ -1326,8 +1326,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 					srf_updates[i].plane_info->dcc;
 		}
 
-		/* not sure if we still need this */
-		if (update_type == UPDATE_TYPE_FULL) {
+		if (update_type >= UPDATE_TYPE_MED) {
 			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 

commit 9037d802a97812cb8d614b48f817a5532cf1558c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 2 17:29:48 2017 -0400

    drm/amd/display: refactor bw related variable structure in val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d063a252ccd9..b30d4bc7b040 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -970,13 +970,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	int i;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct validate_context *context = dm_alloc(sizeof(struct validate_context));
-
-	if (!context) {
-		dm_error("%s: failed to create validate ctx\n", __func__);
-		return false;
-	}
-	dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
+	struct validate_context *context = core_dc->current_context;
 
 	post_surface_trace(dc);
 
@@ -986,21 +980,9 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 			core_dc->hwss.power_down_front_end(
 					core_dc, &context->res_ctx.pipe_ctx[i]);
 		}
-	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
-		BREAK_TO_DEBUGGER();
-		dc_resource_validate_ctx_destruct(context);
-		dm_free(context);
-		return false;
-	}
 
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
-	if (core_dc->current_context) {
-		dc_resource_validate_ctx_destruct(core_dc->current_context);
-		dm_free(core_dc->current_context);
-	}
-	core_dc->current_context = context;
-
 	return true;
 }
 

commit 46df790c6b569faffb4cc93889745a7827283749
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Sun Apr 30 09:20:55 2017 -0400

    drm/amd/display: i2c/aux Remove link index.
    
    Link index is an unnecessery level of inderection when
    calling from kernel i2c/aux transfer into DAL.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 738acf0cc7db..d063a252ccd9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1525,13 +1525,6 @@ const struct graphics_object_id dc_get_link_id_at_index(
 	return core_dc->links[link_index]->link_id;
 }
 
-const struct ddc_service *dc_get_ddc_at_index(
-	struct dc *dc, uint32_t link_index)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return core_dc->links[link_index]->ddc;
-}
-
 enum dc_irq_source dc_get_hpd_irq_source_at_index(
 	struct dc *dc, uint32_t link_index)
 {
@@ -1639,7 +1632,7 @@ bool dc_read_aux_dpcd(
 
 	struct core_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->ddc,
+			link->public.ddc,
 			false,
 			I2C_MOT_UNDEF,
 			address,
@@ -1659,7 +1652,7 @@ bool dc_write_aux_dpcd(
 	struct core_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->ddc,
+			link->public.ddc,
 			false,
 			I2C_MOT_UNDEF,
 			address,
@@ -1680,7 +1673,7 @@ bool dc_read_aux_i2c(
 
 		struct core_link *link = core_dc->links[link_index];
 		enum ddc_result r = dal_ddc_service_read_dpcd_data(
-			link->ddc,
+			link->public.ddc,
 			true,
 			mot,
 			address,
@@ -1701,7 +1694,7 @@ bool dc_write_aux_i2c(
 	struct core_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
-			link->ddc,
+			link->public.ddc,
 			true,
 			mot,
 			address,
@@ -1724,7 +1717,7 @@ bool dc_query_ddc_data(
 	struct core_link *link = core_dc->links[link_index];
 
 	bool result = dal_ddc_service_query_ddc_data(
-			link->ddc,
+			link->public.ddc,
 			address,
 			write_buf,
 			write_size,
@@ -1742,7 +1735,7 @@ bool dc_submit_i2c(
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
 	struct core_link *link = core_dc->links[link_index];
-	struct ddc_service *ddc = link->ddc;
+	struct ddc_service *ddc = link->public.ddc;
 
 	return dal_i2caux_submit_i2c_command(
 		ddc->ctx->i2caux,

commit 529cad0f945c9e60569e902062d2f2741e4fd71a
Author: Ding Wang <Ding.Wang@amd.com>
Date:   Tue Apr 25 10:03:27 2017 -0400

    drm/amd/display: Add function to set dither option
    
    Signed-off-by: Ding Wang <Ding.Wang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 37986632f025..738acf0cc7db 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -363,6 +363,44 @@ static void set_test_pattern(
 			cust_pattern_size);
 }
 
+void set_dither_option(const struct dc_stream *dc_stream,
+		enum dc_dither_option option)
+{
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	struct bit_depth_reduction_params params;
+	struct core_link *core_link = DC_LINK_TO_CORE(stream->status.link);
+	struct pipe_ctx *pipes =
+			core_link->dc->current_context->res_ctx.pipe_ctx;
+
+	memset(&params, 0, sizeof(params));
+	if (!stream)
+		return;
+	if (option > DITHER_OPTION_MAX)
+		return;
+	if (option == DITHER_OPTION_DEFAULT) {
+		switch (stream->public.timing.display_color_depth) {
+		case COLOR_DEPTH_666:
+			stream->public.dither_option = DITHER_OPTION_SPATIAL6;
+			break;
+		case COLOR_DEPTH_888:
+			stream->public.dither_option = DITHER_OPTION_SPATIAL8;
+			break;
+		case COLOR_DEPTH_101010:
+			stream->public.dither_option = DITHER_OPTION_SPATIAL10;
+			break;
+		default:
+			option = DITHER_OPTION_DISABLE;
+		}
+	} else {
+		stream->public.dither_option = option;
+	}
+	resource_build_bit_depth_reduction_params(stream,
+				&params);
+	stream->bit_depth_params = params;
+	pipes->opp->funcs->
+		opp_program_bit_depth_reduction(pipes->opp, &params);
+}
+
 static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 {
 	core_dc->public.stream_funcs.stream_update_scaling = stream_update_scaling;
@@ -380,6 +418,9 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
+	core_dc->public.stream_funcs.set_dither_option =
+			set_dither_option;
+
 	core_dc->public.link_funcs.set_drive_settings =
 			set_drive_settings;
 

commit a2b8659db9b435853cb0dc78d225a492e7ee69d0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Apr 22 14:17:51 2017 -0400

    drm/amd/display: decouple resource_pool from resource_context
    
    to avoid null access in case res_ctx is used to access res_pool before it's fully constructed
    
    also make it clear which function has dependency on resource_pool
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2e74faef68e7..37986632f025 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -736,7 +736,7 @@ static void program_timing_sync(
 {
 	int i, j;
 	int group_index = 0;
-	int pipe_count = ctx->res_ctx.pool->pipe_count;
+	int pipe_count = core_dc->res_pool->pipe_count;
 	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
 
 	for (i = 0; i < pipe_count; i++) {
@@ -939,7 +939,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	post_surface_trace(dc);
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
 			context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
@@ -1015,7 +1015,7 @@ static bool is_surface_in_context(
 {
 	int j;
 
-	for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+	for (j = 0; j < MAX_PIPES; j++) {
 		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 		if (surface == &pipe_ctx->surface->public) {
@@ -1245,7 +1245,8 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, dc_stream, context)) {
+				new_surfaces, surface_count, dc_stream,
+				context, core_dc->res_pool)) {
 			BREAK_TO_DEBUGGER();
 			goto fail;
 		}
@@ -1304,7 +1305,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* not sure if we still need this */
 		if (update_type == UPDATE_TYPE_FULL) {
-			for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 				if (pipe_ctx->surface != surface)
@@ -1365,7 +1366,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (pipe_ctx->surface != surface)
@@ -1389,7 +1390,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 				context_timing_trace(dc, &context->res_ctx);
 		}
 
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 			struct pipe_ctx *cur_pipe_ctx;
 			bool is_new_pipe_surface = true;
@@ -1427,7 +1428,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	}
 
 	/* Unlock pipes */
-	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
+	for (i = core_dc->res_pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		for (j = 0; j < surface_count; j++) {
@@ -1571,8 +1572,6 @@ void dc_set_power_state(
 		memset(core_dc->current_context, 0,
 				sizeof(*core_dc->current_context));
 
-		core_dc->current_context->res_ctx.pool = core_dc->res_pool;
-
 		break;
 	}
 

commit 72ada5f76939ed00c07c584be7691a29d3c2c3da
Author: Eric Cook <Eric.Cook@amd.com>
Date:   Tue Apr 18 15:24:50 2017 -0400

    drm/amd/display: FreeSync Auto Sweep Support
    
    Implement core support to allow for FreeSync Auto Sweep to work
    
    Signed-off-by: Eric Cook <Eric.Cook@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 93c936d92f5a..2e74faef68e7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -175,6 +175,31 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 	return ret;
 }
 
+static bool stream_get_crtc_position(struct dc *dc,
+		const struct dc_stream **stream, int num_streams,
+		unsigned int *v_pos, unsigned int *nom_v_pos)
+{
+	/* TODO: Support multiple streams */
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	int i = 0;
+	bool ret = false;
+	struct crtc_position position;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe =
+				&core_dc->current_context->res_ctx.pipe_ctx[i];
+
+		if (pipe->stream == core_stream && pipe->stream_enc) {
+			core_dc->hwss.get_position(&pipe, 1, &position);
+
+			*v_pos = position.vertical_count;
+			*nom_v_pos = position.nominal_vcount;
+			ret = true;
+		}
+	}
+	return ret;
+}
 
 static bool set_gamut_remap(struct dc *dc,
 			const struct dc_stream **stream, int num_streams)
@@ -349,6 +374,9 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 	core_dc->public.stream_funcs.set_static_screen_events =
 			set_static_screen_events;
 
+	core_dc->public.stream_funcs.get_crtc_position =
+			stream_get_crtc_position;
+
 	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 

commit 94267b3df7ee00f21fa0ff7d618ca7e0574db5ed
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Fri Apr 21 15:29:55 2017 -0400

    drm/amd/display: PSR Refactor
    
    - Refacotr PSR to follow correct module pattern
    - fix eDP only working on sink index 0.
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 1dd9c736aedc..93c936d92f5a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -199,6 +199,32 @@ static bool set_gamut_remap(struct dc *dc,
 	return ret;
 }
 
+static void set_static_screen_events(struct dc *dc,
+		const struct dc_stream **stream,
+		int num_streams,
+		const struct dc_static_screen_events *events)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i = 0;
+	int j = 0;
+	struct pipe_ctx *pipes_affected[MAX_PIPES];
+	int num_pipes_affected = 0;
+
+	for (i = 0; i < num_streams; i++) {
+		struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[i]);
+
+		for (j = 0; j < MAX_PIPES; j++) {
+			if (core_dc->current_context->res_ctx.pipe_ctx[j].stream
+					== core_stream) {
+				pipes_affected[num_pipes_affected++] =
+						&core_dc->current_context->res_ctx.pipe_ctx[j];
+			}
+		}
+	}
+
+	core_dc->hwss.set_static_screen_control(pipes_affected, num_pipes_affected, events);
+}
+
 /* This function is not expected to fail, proper implementation of
  * validation will prevent this from ever being called for unsupported
  * configurations.
@@ -240,45 +266,6 @@ static void stream_update_scaling(
 	}
 }
 
-static bool set_psr_enable(struct dc *dc, bool enable)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int i;
-
-	for (i = 0; i < core_dc->link_count; i++)
-		dc_link_set_psr_enable(&core_dc->links[i]->public,
-				enable);
-
-	return true;
-}
-
-
-static bool setup_psr(struct dc *dc, const struct dc_stream *stream)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
-	struct pipe_ctx *pipes;
-	int i;
-	unsigned int underlay_idx = core_dc->res_pool->underlay_pipe_index;
-
-	for (i = 0; i < core_dc->link_count; i++) {
-		if (core_stream->sink->link == core_dc->links[i])
-			dc_link_setup_psr(&core_dc->links[i]->public,
-					stream);
-	}
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
-				== core_stream && i != underlay_idx) {
-			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
-			core_dc->hwss.set_static_screen_control(&pipes, 1,
-					0x182);
-		}
-	}
-
-	return true;
-}
-
 static void set_drive_settings(struct dc *dc,
 		struct link_training_settings *lt_settings,
 		const struct dc_link *link)
@@ -359,15 +346,12 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 				stream_adjust_vmin_vmax;
 	}
 
+	core_dc->public.stream_funcs.set_static_screen_events =
+			set_static_screen_events;
+
 	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
-	core_dc->public.stream_funcs.set_psr_enable =
-			set_psr_enable;
-
-	core_dc->public.stream_funcs.setup_psr =
-			setup_psr;
-
 	core_dc->public.link_funcs.set_drive_settings =
 			set_drive_settings;
 

commit de37e273df49dd015f6c308668f223327f6cf8fc
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Apr 18 17:31:46 2017 -0400

    drm/amd/display: fix memory leak
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b1f0a50171af..1dd9c736aedc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -918,7 +918,6 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *context = dm_alloc(sizeof(struct validate_context));
-	bool result = true;
 
 	if (!context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
@@ -927,28 +926,29 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
 
 	post_surface_trace(dc);
+
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
 			context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
 					core_dc, &context->res_ctx.pipe_ctx[i]);
 		}
-
 	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
 		BREAK_TO_DEBUGGER();
-		result = false;
-		goto cleanup;
+		dc_resource_validate_ctx_destruct(context);
+		dm_free(context);
+		return false;
 	}
 
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
-	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
-
-cleanup:
-	dc_resource_validate_ctx_destruct(context);
-	dm_free(context);
+	if (core_dc->current_context) {
+		dc_resource_validate_ctx_destruct(core_dc->current_context);
+		dm_free(core_dc->current_context);
+	}
+	core_dc->current_context = context;
 
-	return result;
+	return true;
 }
 
 bool dc_commit_surfaces_to_stream(
@@ -1440,10 +1440,8 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	return;
 
 fail:
-	if (core_dc->current_context != context) {
-		dc_resource_validate_ctx_destruct(context);
-		dm_free(context);
-	}
+	dc_resource_validate_ctx_destruct(context);
+	dm_free(context);
 }
 
 uint8_t dc_get_current_stream_count(const struct dc *dc)

commit 50f27269b8dd81d73c787dd18ba19a08bec128d3
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Apr 18 15:43:22 2017 -0400

    drm/amd/display: Fix memory leak in post_update_surfaces
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 64b5216fb920..b1f0a50171af 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -918,6 +918,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	int i;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *context = dm_alloc(sizeof(struct validate_context));
+	bool result = true;
 
 	if (!context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
@@ -935,17 +936,19 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
 		BREAK_TO_DEBUGGER();
-		return false;
+		result = false;
+		goto cleanup;
 	}
 
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
 	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
 
+cleanup:
 	dc_resource_validate_ctx_destruct(context);
 	dm_free(context);
 
-	return true;
+	return result;
 }
 
 bool dc_commit_surfaces_to_stream(

commit 07d72b39bc861b644ea8f6037e0c6a9836050306
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Mar 29 11:22:05 2017 -0400

    drm/amd/display: Return context from validate_context
    
    This will allow us to carry it from check to commit
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5620fe361173..64b5216fb920 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -635,7 +635,7 @@ static bool is_validation_required(
 	return false;
 }
 
-bool dc_validate_resources(
+struct validate_context *dc_get_validate_context(
 		const struct dc *dc,
 		const struct dc_validation_set set[],
 		uint8_t set_count)
@@ -644,31 +644,51 @@ bool dc_validate_resources(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 
-	if (!is_validation_required(core_dc, set, set_count))
-		return true;
-
 	context = dm_alloc(sizeof(struct validate_context));
 	if(context == NULL)
 		goto context_alloc_fail;
 
+	if (!is_validation_required(core_dc, set, set_count)) {
+		dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
+		return context;
+	}
+
 	result = core_dc->res_pool->funcs->validate_with_context(
 						core_dc, set, set_count, context);
 
-	dc_resource_validate_ctx_destruct(context);
-	dm_free(context);
-
 context_alloc_fail:
 	if (result != DC_OK) {
 		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
 				"%s:resource validation failed, dc_status:%d\n",
 				__func__,
 				result);
+
+		dc_resource_validate_ctx_destruct(context);
+		dm_free(context);
+		context = NULL;
 	}
 
-	return (result == DC_OK);
+	return context;
 
 }
 
+bool dc_validate_resources(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count)
+{
+	struct validate_context *ctx;
+
+	ctx = dc_get_validate_context(dc, set, set_count);
+	if (ctx) {
+		dc_resource_validate_ctx_destruct(ctx);
+		dm_free(ctx);
+		return true;
+	}
+
+	return false;
+}
+
 bool dc_validate_guaranteed(
 		const struct dc *dc,
 		const struct dc_stream *stream)

commit 8122a253b34aec75a1fdc3fe61c97b9026a0bff6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Mar 29 11:15:14 2017 -0400

    drm/amd/display: Move resource_validate_ctx_destruct to dc.h
    
    This will be needed to clean up context once we add it to private
    atomic state.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0d870e9c7c99..5620fe361173 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -389,7 +389,7 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 
 static void destruct(struct core_dc *dc)
 {
-	resource_validate_ctx_destruct(dc->current_context);
+	dc_resource_validate_ctx_destruct(dc->current_context);
 
 	destroy_links(dc);
 
@@ -654,7 +654,7 @@ bool dc_validate_resources(
 	result = core_dc->res_pool->funcs->validate_with_context(
 						core_dc, set, set_count, context);
 
-	resource_validate_ctx_destruct(context);
+	dc_resource_validate_ctx_destruct(context);
 	dm_free(context);
 
 context_alloc_fail:
@@ -684,7 +684,7 @@ bool dc_validate_guaranteed(
 	result = core_dc->res_pool->funcs->validate_guaranteed(
 					core_dc, stream, context);
 
-	resource_validate_ctx_destruct(context);
+	dc_resource_validate_ctx_destruct(context);
 	dm_free(context);
 
 context_alloc_fail:
@@ -838,7 +838,7 @@ bool dc_commit_streams(
 					__func__,
 					result);
 		BREAK_TO_DEBUGGER();
-		resource_validate_ctx_destruct(context);
+		dc_resource_validate_ctx_destruct(context);
 		goto fail;
 	}
 
@@ -870,7 +870,7 @@ bool dc_commit_streams(
 				context->streams[i]->public.timing.pix_clk_khz);
 	}
 
-	resource_validate_ctx_destruct(core_dc->current_context);
+	dc_resource_validate_ctx_destruct(core_dc->current_context);
 	dm_free(core_dc->current_context);
 
 	core_dc->current_context = context;
@@ -903,7 +903,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 		dm_error("%s: failed to create validate ctx\n", __func__);
 		return false;
 	}
-	resource_validate_ctx_copy_construct(core_dc->current_context, context);
+	dc_resource_validate_ctx_copy_construct(core_dc->current_context, context);
 
 	post_surface_trace(dc);
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
@@ -920,9 +920,9 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
-	resource_validate_ctx_copy_construct(context, core_dc->current_context);
+	dc_resource_validate_ctx_copy_construct(context, core_dc->current_context);
 
-	resource_validate_ctx_destruct(context);
+	dc_resource_validate_ctx_destruct(context);
 	dm_free(context);
 
 	return true;
@@ -1205,7 +1205,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 		/* initialize scratch memory for building context */
 		context = dm_alloc(sizeof(*context));
-		resource_validate_ctx_copy_construct(
+		dc_resource_validate_ctx_copy_construct(
 				core_dc->current_context, context);
 
 		/* add surface to context */
@@ -1409,7 +1409,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	}
 
 	if (core_dc->current_context != context) {
-		resource_validate_ctx_destruct(core_dc->current_context);
+		dc_resource_validate_ctx_destruct(core_dc->current_context);
 		dm_free(core_dc->current_context);
 
 		core_dc->current_context = context;
@@ -1418,7 +1418,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 fail:
 	if (core_dc->current_context != context) {
-		resource_validate_ctx_destruct(context);
+		dc_resource_validate_ctx_destruct(context);
 		dm_free(context);
 	}
 }

commit 927f6eff2aa40e73528619818374c271ddfadd3d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Apr 6 18:57:05 2017 -0400

    drm/amd/display: Copy ctx to current_context instead of assign
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e8499e744595..0d870e9c7c99 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -906,13 +906,13 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	resource_validate_ctx_copy_construct(core_dc->current_context, context);
 
 	post_surface_trace(dc);
-
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
 			context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
 					core_dc, &context->res_ctx.pipe_ctx[i]);
 		}
+
 	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
 		BREAK_TO_DEBUGGER();
 		return false;
@@ -920,11 +920,10 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
-	resource_validate_ctx_destruct(core_dc->current_context);
-	if (core_dc->current_context)
-		dm_free(core_dc->current_context);
+	resource_validate_ctx_copy_construct(context, core_dc->current_context);
 
-	core_dc->current_context = context;
+	resource_validate_ctx_destruct(context);
+	dm_free(context);
 
 	return true;
 }

commit 6d9501e4ad2df6fc631e99d3cfd2afa09542393a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Apr 6 17:05:53 2017 -0400

    drm/amd/display: Get rid of temp_flip_context
    
    If we need to update our context we can allocate memory.
    No need to keep temporary memory for this.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7b0b7356ae89..e8499e744595 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -409,8 +409,6 @@ static void destruct(struct core_dc *dc)
 
 	dm_free(dc->current_context);
 	dc->current_context = NULL;
-	dm_free(dc->temp_flip_context);
-	dc->temp_flip_context = NULL;
 
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
@@ -429,9 +427,8 @@ static bool construct(struct core_dc *dc,
 	}
 
 	dc->current_context = dm_alloc(sizeof(*dc->current_context));
-	dc->temp_flip_context = dm_alloc(sizeof(*dc->temp_flip_context));
 
-	if (!dc->current_context || !dc->temp_flip_context) {
+	if (!dc->current_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
 		goto val_ctx_fail;
 	}
@@ -874,13 +871,9 @@ bool dc_commit_streams(
 	}
 
 	resource_validate_ctx_destruct(core_dc->current_context);
+	dm_free(core_dc->current_context);
 
-	if (core_dc->temp_flip_context != core_dc->current_context) {
-		dm_free(core_dc->temp_flip_context);
-		core_dc->temp_flip_context = core_dc->current_context;
-	}
 	core_dc->current_context = context;
-	memset(core_dc->temp_flip_context, 0, sizeof(*core_dc->temp_flip_context));
 
 	return (result == DC_OK);
 
@@ -1212,7 +1205,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 			new_surfaces[i] = srf_updates[i].surface;
 
 		/* initialize scratch memory for building context */
-		context = core_dc->temp_flip_context;
+		context = dm_alloc(sizeof(*context));
 		resource_validate_ctx_copy_construct(
 				core_dc->current_context, context);
 
@@ -1220,7 +1213,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		if (!resource_attach_surfaces_to_context(
 				new_surfaces, surface_count, dc_stream, context)) {
 			BREAK_TO_DEBUGGER();
-			return;
+			goto fail;
 		}
 	} else {
 		context = core_dc->current_context;
@@ -1326,7 +1319,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (update_type == UPDATE_TYPE_FULL) {
 		if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
 			BREAK_TO_DEBUGGER();
-			return;
+			goto fail;
 		} else
 			core_dc->hwss.set_bandwidth(core_dc, context, false);
 	}
@@ -1418,10 +1411,17 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 
 	if (core_dc->current_context != context) {
 		resource_validate_ctx_destruct(core_dc->current_context);
-		core_dc->temp_flip_context = core_dc->current_context;
+		dm_free(core_dc->current_context);
 
 		core_dc->current_context = context;
 	}
+	return;
+
+fail:
+	if (core_dc->current_context != context) {
+		resource_validate_ctx_destruct(context);
+		dm_free(context);
+	}
 }
 
 uint8_t dc_get_current_stream_count(const struct dc *dc)

commit 03e4173b44d514818c98555bc709a931ff9300ce
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Apr 6 16:48:48 2017 -0400

    drm/amd/display: Remove unused scratch_val_ctx
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6576137ee189..7b0b7356ae89 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -411,8 +411,6 @@ static void destruct(struct core_dc *dc)
 	dc->current_context = NULL;
 	dm_free(dc->temp_flip_context);
 	dc->temp_flip_context = NULL;
-	dm_free(dc->scratch_val_ctx);
-	dc->scratch_val_ctx = NULL;
 
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
@@ -432,7 +430,6 @@ static bool construct(struct core_dc *dc,
 
 	dc->current_context = dm_alloc(sizeof(*dc->current_context));
 	dc->temp_flip_context = dm_alloc(sizeof(*dc->temp_flip_context));
-	dc->scratch_val_ctx = dm_alloc(sizeof(*dc->scratch_val_ctx));
 
 	if (!dc->current_context || !dc->temp_flip_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);

commit 1ce71fcd5dddf4a3198a96e422122edc210847e9
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Apr 11 22:24:44 2017 -0400

    drm/amd/display: use full surface update when stream is NULL
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 70dc02cf4dbb..6576137ee189 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1155,7 +1155,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
-	if (stream_status->surface_count != surface_count)
+	if (stream_status == NULL || stream_status->surface_count != surface_count)
 		return UPDATE_TYPE_FULL;
 
 	if (stream_update)

commit b64875feb18a734739929e2af8a625b186bb6ec0
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Mon Apr 10 09:37:11 2017 -0400

    drm/amd/display: set NULL value during removal for remoteSink
    
    In MST case during removal of remote sink its descriptor pointer wasn't freed corectly.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 203cb9d0c89d..70dc02cf4dbb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1787,7 +1787,7 @@ void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink
 				dc_link->remote_sinks[i] = dc_link->remote_sinks[i+1];
 				i++;
 			}
-
+			dc_link->remote_sinks[i] = NULL;
 			dc_link->sink_count--;
 			return;
 		}

commit fb9611d2167d73b7a7af66edb30893d22de9382d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Apr 6 16:23:14 2017 -0400

    drm/amd/display: change mpo surface update check condition.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9a3507e743cf..203cb9d0c89d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1024,7 +1024,8 @@ static unsigned int pixel_format_to_bpp(enum surface_pixel_format format)
 }
 
 static enum surface_update_type get_plane_info_update_type(
-		const struct dc_surface_update *u)
+		const struct dc_surface_update *u,
+		int surface_index)
 {
 	struct dc_plane_info temp_plane_info = { { { { 0 } } } };
 
@@ -1049,7 +1050,11 @@ static enum surface_update_type get_plane_info_update_type(
 
 	/* Special Validation parameters */
 	temp_plane_info.format = u->plane_info->format;
-	temp_plane_info.visible = u->plane_info->visible;
+
+	if (surface_index == 0)
+		temp_plane_info.visible = u->plane_info->visible;
+	else
+		temp_plane_info.visible = u->surface->visible;
 
 	if (memcmp(u->plane_info, &temp_plane_info,
 			sizeof(struct dc_plane_info)) != 0)
@@ -1111,7 +1116,8 @@ static enum surface_update_type  get_scaling_info_update_type(
 
 static enum surface_update_type det_surface_update(
 		const struct core_dc *dc,
-		const struct dc_surface_update *u)
+		const struct dc_surface_update *u,
+		int surface_index)
 {
 	const struct validate_context *context = dc->current_context;
 	enum surface_update_type type = UPDATE_TYPE_FAST;
@@ -1120,7 +1126,7 @@ static enum surface_update_type det_surface_update(
 	if (!is_surface_in_context(context, u->surface))
 		return UPDATE_TYPE_FULL;
 
-	type = get_plane_info_update_type(u);
+	type = get_plane_info_update_type(u, surface_index);
 	if (overall_type < type)
 		overall_type = type;
 
@@ -1157,7 +1163,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
-				det_surface_update(core_dc, &updates[i]);
+				det_surface_update(core_dc, &updates[i], i);
 
 		if (type == UPDATE_TYPE_FULL)
 			return type;

commit dd3f348f0013f2cb2508f72adb35285a34b2baf7
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Mar 31 13:53:42 2017 -0400

    drm/amd/display: Ignore visible flag when check surface update type.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 40a800155fe6..9a3507e743cf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1046,10 +1046,10 @@ static enum surface_update_type get_plane_info_update_type(
 	temp_plane_info.rotation = u->surface->rotation;
 	temp_plane_info.stereo_format = u->surface->stereo_format;
 	temp_plane_info.tiling_info = u->surface->tiling_info;
-	temp_plane_info.visible = u->surface->visible;
 
 	/* Special Validation parameters */
 	temp_plane_info.format = u->plane_info->format;
+	temp_plane_info.visible = u->plane_info->visible;
 
 	if (memcmp(u->plane_info, &temp_plane_info,
 			sizeof(struct dc_plane_info)) != 0)

commit 7c7f5b15be6528b33d825ead6acb739d7d061a2e
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Mar 28 16:57:52 2017 -0400

    drm/amd/display: Refactor edid read.
    
    Allow Linux to use DRM provided EDID read functioality
    by moving  DAL edid implementation to module hence
    removing this code from DC by this cleaning up DC
    code for upstream.
    
    v2: Removing ddc_service. No more need for it.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b3891228b499..40a800155fe6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1553,7 +1553,7 @@ void dc_resume(const struct dc *dc)
 		core_link_resume(core_dc->links[i]);
 }
 
-bool dc_read_dpcd(
+bool dc_read_aux_dpcd(
 		struct dc *dc,
 		uint32_t link_index,
 		uint32_t address,
@@ -1565,56 +1565,100 @@ bool dc_read_dpcd(
 	struct core_link *link = core_dc->links[link_index];
 	enum ddc_result r = dal_ddc_service_read_dpcd_data(
 			link->ddc,
+			false,
+			I2C_MOT_UNDEF,
 			address,
 			data,
 			size);
 	return r == DDC_RESULT_SUCESSFULL;
 }
 
-bool dc_query_ddc_data(
+bool dc_write_aux_dpcd(
 		struct dc *dc,
 		uint32_t link_index,
 		uint32_t address,
-		uint8_t *write_buf,
-		uint32_t write_size,
-		uint8_t *read_buf,
-		uint32_t read_size) {
-
+		const uint8_t *data,
+		uint32_t size)
+{
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-
 	struct core_link *link = core_dc->links[link_index];
 
-	bool result = dal_ddc_service_query_ddc_data(
+	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
+			false,
+			I2C_MOT_UNDEF,
 			address,
-			write_buf,
-			write_size,
-			read_buf,
-			read_size);
-
-	return result;
+			data,
+			size);
+	return r == DDC_RESULT_SUCESSFULL;
 }
 
+bool dc_read_aux_i2c(
+		struct dc *dc,
+		uint32_t link_index,
+		enum i2c_mot_mode mot,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-bool dc_write_dpcd(
+		struct core_link *link = core_dc->links[link_index];
+		enum ddc_result r = dal_ddc_service_read_dpcd_data(
+			link->ddc,
+			true,
+			mot,
+			address,
+			data,
+			size);
+		return r == DDC_RESULT_SUCESSFULL;
+}
+
+bool dc_write_aux_i2c(
 		struct dc *dc,
 		uint32_t link_index,
+		enum i2c_mot_mode mot,
 		uint32_t address,
 		const uint8_t *data,
 		uint32_t size)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-
 	struct core_link *link = core_dc->links[link_index];
 
 	enum ddc_result r = dal_ddc_service_write_dpcd_data(
 			link->ddc,
+			true,
+			mot,
 			address,
 			data,
 			size);
 	return r == DDC_RESULT_SUCESSFULL;
 }
 
+bool dc_query_ddc_data(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		uint8_t *write_buf,
+		uint32_t write_size,
+		uint8_t *read_buf,
+		uint32_t read_size) {
+
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
+
+	bool result = dal_ddc_service_query_ddc_data(
+			link->ddc,
+			address,
+			write_buf,
+			write_size,
+			read_buf,
+			read_size);
+
+	return result;
+}
+
 bool dc_submit_i2c(
 		struct dc *dc,
 		uint32_t link_index,

commit 5e141de45218d36a6b98c783834684fd0d617f7a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Mar 21 18:17:12 2017 -0400

    drm/amd/display: Rename bandwidth_calcs.h to dce_calcs.h
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c0889ad8357e..b3891228b499 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -35,7 +35,7 @@
 #include "clock_source.h"
 #include "dc_bios_types.h"
 
-#include "bandwidth_calcs.h"
+#include "dce_calcs.h"
 #include "bios_parser_interface.h"
 #include "include/irq_service_interface.h"
 #include "transform.h"

commit 00f02019990d9020321c446a04044b6ca05d20f8
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Fri Mar 17 12:02:58 2017 -0400

    drm/amd/display: Fix applying surface to underlay pipe
    
    1. Locking all pipes before doing any changes
    2. Applying surface for both top and bottom pipes
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6409d4d1d7f8..c0889ad8357e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1331,32 +1331,41 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 	if (!surface_count)  /* reset */
 		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
 
+	/* Lock pipes for provided surfaces */
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-			struct pipe_ctx *cur_pipe_ctx;
-			bool is_new_pipe_surface = true;
 
 			if (pipe_ctx->surface != surface)
 				continue;
-
-			if (update_type >= UPDATE_TYPE_MED) {
-				/* only apply for top pipe */
-				if (!pipe_ctx->top_pipe) {
-					core_dc->hwss.apply_ctx_for_surface(core_dc,
-							 surface, context);
-					context_timing_trace(dc, &context->res_ctx);
-				}
-			}
-
 			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 				core_dc->hwss.pipe_control_lock(
 						core_dc,
 						pipe_ctx,
 						true);
 			}
+		}
+	}
+
+	/* Perform requested Updates */
+	for (i = 0; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
+
+		if (update_type >= UPDATE_TYPE_MED) {
+				core_dc->hwss.apply_ctx_for_surface(
+						core_dc, surface, context);
+				context_timing_trace(dc, &context->res_ctx);
+		}
+
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+			struct pipe_ctx *cur_pipe_ctx;
+			bool is_new_pipe_surface = true;
+
+			if (pipe_ctx->surface != surface)
+				continue;
 
 			if (srf_updates[i].flip_addr)
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
@@ -1387,6 +1396,7 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 		}
 	}
 
+	/* Unlock pipes */
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 

commit 745cc746da42a3a8a48fb7a6b8c4ee2c3f2cdf8b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Mar 14 12:30:29 2017 -0400

    drm/amd/display: remove dc_pre_update_surfaces_to_stream from dc use
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 26f227ddd025..6409d4d1d7f8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -900,106 +900,7 @@ bool dc_pre_update_surfaces_to_stream(
 		uint8_t new_surface_count,
 		const struct dc_stream *dc_stream)
 {
-	int i, j;
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct dc_stream_status *stream_status = NULL;
-	struct validate_context *context;
-	bool ret = true;
-
-	pre_surface_trace(dc, new_surfaces, new_surface_count);
-
-	if (core_dc->current_context->stream_count == 0)
-		return false;
-
-	/* Cannot commit surface to a stream that is not commited */
-	for (i = 0; i < core_dc->current_context->stream_count; i++)
-		if (dc_stream == &core_dc->current_context->streams[i]->public)
-			break;
-
-	if (i == core_dc->current_context->stream_count)
-		return false;
-
-	stream_status = &core_dc->current_context->stream_status[i];
-
-	if (new_surface_count == stream_status->surface_count) {
-		bool skip_pre = true;
-
-		for (i = 0; i < stream_status->surface_count; i++) {
-			struct dc_surface temp_surf = { 0 };
-
-			temp_surf = *stream_status->surfaces[i];
-			temp_surf.clip_rect = new_surfaces[i]->clip_rect;
-			temp_surf.dst_rect.x = new_surfaces[i]->dst_rect.x;
-			temp_surf.dst_rect.y = new_surfaces[i]->dst_rect.y;
-
-			if (memcmp(&temp_surf, new_surfaces[i], sizeof(temp_surf)) != 0) {
-				skip_pre = false;
-				break;
-			}
-		}
-
-		if (skip_pre)
-			return true;
-	}
-
-	context = dm_alloc(sizeof(struct validate_context));
-
-	if (!context) {
-		dm_error("%s: failed to create validate ctx\n", __func__);
-		ret = false;
-		goto val_ctx_fail;
-	}
-
-	resource_validate_ctx_copy_construct(core_dc->current_context, context);
-
-	dm_logger_write(core_dc->ctx->logger, LOG_DC,
-				"%s: commit %d surfaces to stream 0x%x\n",
-				__func__,
-				new_surface_count,
-				dc_stream);
-
-	if (!resource_attach_surfaces_to_context(
-			new_surfaces, new_surface_count, dc_stream, context)) {
-		BREAK_TO_DEBUGGER();
-		ret = false;
-		goto unexpected_fail;
-	}
-
-	for (i = 0; i < new_surface_count; i++)
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-			if (context->res_ctx.pipe_ctx[j].surface !=
-					DC_SURFACE_TO_CORE(new_surfaces[i]))
-				continue;
-
-			resource_build_scaling_params(&context->res_ctx.pipe_ctx[j]);
-		}
-
-	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
-		BREAK_TO_DEBUGGER();
-		ret = false;
-		goto unexpected_fail;
-	}
-
-	core_dc->hwss.set_bandwidth(core_dc, context, false);
-
-	for (i = 0; i < new_surface_count; i++)
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-			if (context->res_ctx.pipe_ctx[j].surface !=
-					DC_SURFACE_TO_CORE(new_surfaces[i]))
-				continue;
-
-			core_dc->hwss.prepare_pipe_for_context(
-					core_dc,
-					&context->res_ctx.pipe_ctx[j],
-					context);
-		}
-
-unexpected_fail:
-	resource_validate_ctx_destruct(context);
-	dm_free(context);
-val_ctx_fail:
-
-	return ret;
+	return true;
 }
 
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
@@ -1050,10 +951,6 @@ bool dc_commit_surfaces_to_stream(
 	struct dc_scaling_info scaling_info[MAX_SURFACES];
 	int i;
 
-	if (!dc_pre_update_surfaces_to_stream(
-			dc, new_surfaces, new_surface_count, dc_stream))
-		return false;
-
 	memset(updates, 0, sizeof(updates));
 	memset(flip_addr, 0, sizeof(flip_addr));
 	memset(plane_info, 0, sizeof(plane_info));
@@ -1423,10 +1320,12 @@ void dc_update_surfaces_and_stream(struct dc *dc,
 				*(srf_updates[i].hdr_static_metadata);
 	}
 
-	if (update_type == UPDATE_TYPE_FULL &&
-			!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
-		BREAK_TO_DEBUGGER();
-		return;
+	if (update_type == UPDATE_TYPE_FULL) {
+		if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
+			BREAK_TO_DEBUGGER();
+			return;
+		} else
+			core_dc->hwss.set_bandwidth(core_dc, context, false);
 	}
 
 	if (!surface_count)  /* reset */

commit ee8f63e1781eb3e4acdcff5324ca29b723aded45
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Tue Mar 14 11:54:31 2017 -0400

    drm/amd/display: changing the dc_update_surfaces_and_stream
    
    1. Adding the ability to update the stream parameters during FULL_UPDATE type
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 228ef6b310e0..26f227ddd025 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1245,6 +1245,7 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 		struct dc *dc,
 		struct dc_surface_update *updates,
 		int surface_count,
+		struct dc_stream_update *stream_update,
 		const struct dc_stream_status *stream_status)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -1254,6 +1255,9 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	if (stream_status->surface_count != surface_count)
 		return UPDATE_TYPE_FULL;
 
+	if (stream_update)
+		return UPDATE_TYPE_FULL;
+
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
 				det_surface_update(core_dc, &updates[i]);
@@ -1268,39 +1272,27 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	return overall_type;
 }
 
-void dc_update_surfaces_and_stream(struct dc *dc,
+void dc_update_surfaces_for_stream(struct dc *dc,
 		struct dc_surface_update *surface_updates, int surface_count,
-		const struct dc_stream *dc_stream,
-		struct dc_stream_update *stream_update)
+		const struct dc_stream *dc_stream)
 {
-	const struct dc_stream_status *stream_status;
-
-	stream_status = dc_stream_get_status(dc_stream);
-	ASSERT(stream_status);
-	if (!stream_status)
-		return; /* Cannot update stream that is not committed */
-
-	if (stream_update) {
-		dc->stream_funcs.stream_update_scaling(dc, dc_stream,
-				&stream_update->src, &stream_update->dst);
-	}
-
-	dc_update_surfaces_for_stream(dc, surface_updates,
-			surface_count, dc_stream);
+	dc_update_surfaces_and_stream(dc, surface_updates, surface_count,
+			dc_stream, NULL);
 }
 
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-void dc_update_surfaces_for_stream(struct dc *dc,
-		struct dc_surface_update *updates, int surface_count,
-		const struct dc_stream *dc_stream)
+void dc_update_surfaces_and_stream(struct dc *dc,
+		struct dc_surface_update *srf_updates, int surface_count,
+		const struct dc_stream *dc_stream,
+		struct dc_stream_update *stream_update)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *context;
 	int i, j;
-
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	stream_status = dc_stream_get_status(dc_stream);
 	ASSERT(stream_status);
@@ -1308,16 +1300,16 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		return; /* Cannot commit surface to stream that is not committed */
 
 	update_type = dc_check_update_surfaces_for_stream(
-			dc, updates, surface_count, stream_status);
+			dc, srf_updates, surface_count, stream_update, stream_status);
 
 	if (update_type >= update_surface_trace_level)
-		update_surface_trace(dc, updates, surface_count);
+		update_surface_trace(dc, srf_updates, surface_count);
 
 	if (update_type >= UPDATE_TYPE_FULL) {
 		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
 
 		for (i = 0; i < surface_count; i++)
-			new_surfaces[i] = updates[i].surface;
+			new_surfaces[i] = srf_updates[i].surface;
 
 		/* initialize scratch memory for building context */
 		context = core_dc->temp_flip_context;
@@ -1333,47 +1325,54 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 	} else {
 		context = core_dc->current_context;
 	}
+
+	/* update current stream with the new updates */
+	if (stream_update) {
+		stream->public.src = stream_update->src;
+		stream->public.dst = stream_update->dst;
+	}
+
+	/* save update parameters into surface */
 	for (i = 0; i < surface_count; i++) {
-		/* save update param into surface */
-		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
-		struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+		struct core_surface *surface =
+				DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
-		if (updates[i].flip_addr) {
-			surface->public.address = updates[i].flip_addr->address;
+		if (srf_updates[i].flip_addr) {
+			surface->public.address = srf_updates[i].flip_addr->address;
 			surface->public.flip_immediate =
-					updates[i].flip_addr->flip_immediate;
+					srf_updates[i].flip_addr->flip_immediate;
 		}
 
-		if (updates[i].scaling_info) {
+		if (srf_updates[i].scaling_info) {
 			surface->public.scaling_quality =
-					updates[i].scaling_info->scaling_quality;
+					srf_updates[i].scaling_info->scaling_quality;
 			surface->public.dst_rect =
-					updates[i].scaling_info->dst_rect;
+					srf_updates[i].scaling_info->dst_rect;
 			surface->public.src_rect =
-					updates[i].scaling_info->src_rect;
+					srf_updates[i].scaling_info->src_rect;
 			surface->public.clip_rect =
-					updates[i].scaling_info->clip_rect;
+					srf_updates[i].scaling_info->clip_rect;
 		}
 
-		if (updates[i].plane_info) {
+		if (srf_updates[i].plane_info) {
 			surface->public.color_space =
-					updates[i].plane_info->color_space;
+					srf_updates[i].plane_info->color_space;
 			surface->public.format =
-					updates[i].plane_info->format;
+					srf_updates[i].plane_info->format;
 			surface->public.plane_size =
-					updates[i].plane_info->plane_size;
+					srf_updates[i].plane_info->plane_size;
 			surface->public.rotation =
-					updates[i].plane_info->rotation;
+					srf_updates[i].plane_info->rotation;
 			surface->public.horizontal_mirror =
-					updates[i].plane_info->horizontal_mirror;
+					srf_updates[i].plane_info->horizontal_mirror;
 			surface->public.stereo_format =
-					updates[i].plane_info->stereo_format;
+					srf_updates[i].plane_info->stereo_format;
 			surface->public.tiling_info =
-					updates[i].plane_info->tiling_info;
+					srf_updates[i].plane_info->tiling_info;
 			surface->public.visible =
-					updates[i].plane_info->visible;
+					srf_updates[i].plane_info->visible;
 			surface->public.dcc =
-					updates[i].plane_info->dcc;
+					srf_updates[i].plane_info->dcc;
 		}
 
 		/* not sure if we still need this */
@@ -1388,40 +1387,40 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			}
 		}
 
-		if (updates[i].gamma &&
-			updates[i].gamma != surface->public.gamma_correction) {
+		if (srf_updates[i].gamma &&
+			srf_updates[i].gamma != surface->public.gamma_correction) {
 			if (surface->public.gamma_correction != NULL)
 				dc_gamma_release(&surface->public.
 						gamma_correction);
 
-			dc_gamma_retain(updates[i].gamma);
+			dc_gamma_retain(srf_updates[i].gamma);
 			surface->public.gamma_correction =
-						updates[i].gamma;
+						srf_updates[i].gamma;
 		}
 
-		if (updates[i].in_transfer_func &&
-			updates[i].in_transfer_func != surface->public.in_transfer_func) {
+		if (srf_updates[i].in_transfer_func &&
+			srf_updates[i].in_transfer_func != surface->public.in_transfer_func) {
 			if (surface->public.in_transfer_func != NULL)
 				dc_transfer_func_release(
 						surface->public.
 						in_transfer_func);
 
 			dc_transfer_func_retain(
-					updates[i].in_transfer_func);
+					srf_updates[i].in_transfer_func);
 			surface->public.in_transfer_func =
-					updates[i].in_transfer_func;
+					srf_updates[i].in_transfer_func;
 		}
 
-		if (updates[i].out_transfer_func &&
-			updates[i].out_transfer_func != dc_stream->out_transfer_func) {
+		if (srf_updates[i].out_transfer_func &&
+			srf_updates[i].out_transfer_func != dc_stream->out_transfer_func) {
 			if (dc_stream->out_transfer_func != NULL)
 				dc_transfer_func_release(dc_stream->out_transfer_func);
-			dc_transfer_func_retain(updates[i].out_transfer_func);
-			stream->public.out_transfer_func = updates[i].out_transfer_func;
+			dc_transfer_func_retain(srf_updates[i].out_transfer_func);
+			stream->public.out_transfer_func = srf_updates[i].out_transfer_func;
 		}
-		if (updates[i].hdr_static_metadata)
+		if (srf_updates[i].hdr_static_metadata)
 			surface->public.hdr_static_ctx =
-				*(updates[i].hdr_static_metadata);
+				*(srf_updates[i].hdr_static_metadata);
 	}
 
 	if (update_type == UPDATE_TYPE_FULL &&
@@ -1434,7 +1433,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
 
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+		struct core_surface *surface = DC_SURFACE_TO_CORE(srf_updates[i].surface);
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1460,7 +1459,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 						true);
 			}
 
-			if (updates[i].flip_addr)
+			if (srf_updates[i].flip_addr)
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 
 			if (update_type == UPDATE_TYPE_FAST)
@@ -1471,18 +1470,18 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 				is_new_pipe_surface = false;
 
 			if (is_new_pipe_surface ||
-					updates[i].in_transfer_func)
+					srf_updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 
 			if (is_new_pipe_surface ||
-					updates[i].out_transfer_func)
+					srf_updates[i].out_transfer_func)
 				core_dc->hwss.set_output_transfer_func(
 						pipe_ctx,
 						pipe_ctx->surface,
 						pipe_ctx->stream);
 
-			if (updates[i].hdr_static_metadata) {
+			if (srf_updates[i].hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);
 				core_dc->hwss.update_info_frame(pipe_ctx);
 			}
@@ -1493,7 +1492,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		for (j = 0; j < surface_count; j++) {
-			if (updates[j].surface == &pipe_ctx->surface->public) {
+			if (srf_updates[j].surface == &pipe_ctx->surface->public) {
 				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 					core_dc->hwss.pipe_control_lock(
 							core_dc,

commit a783e7b5182ba5df2916c7abda60b8e781bdb3aa
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Thu Mar 9 14:38:15 2017 -0500

    drm/amd/display: adding new dc_update_surfaces_and_stream
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index d6041e842347..228ef6b310e0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1268,6 +1268,27 @@ enum surface_update_type dc_check_update_surfaces_for_stream(
 	return overall_type;
 }
 
+void dc_update_surfaces_and_stream(struct dc *dc,
+		struct dc_surface_update *surface_updates, int surface_count,
+		const struct dc_stream *dc_stream,
+		struct dc_stream_update *stream_update)
+{
+	const struct dc_stream_status *stream_status;
+
+	stream_status = dc_stream_get_status(dc_stream);
+	ASSERT(stream_status);
+	if (!stream_status)
+		return; /* Cannot update stream that is not committed */
+
+	if (stream_update) {
+		dc->stream_funcs.stream_update_scaling(dc, dc_stream,
+				&stream_update->src, &stream_update->dst);
+	}
+
+	dc_update_surfaces_for_stream(dc, surface_updates,
+			surface_count, dc_stream);
+}
+
 enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
 void dc_update_surfaces_for_stream(struct dc *dc,

commit 8fa9ca2ec6919656db87391a1633692ee8d57c22
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:21:43 2017 -0400

    drm/amd/display: Remove DCE12 guards
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 28ed8eaee1ff..d6041e842347 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1815,7 +1815,6 @@ void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink
 	}
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 {
 	int i;
@@ -1842,5 +1841,4 @@ bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
 	return true;
 
 }
-#endif
 

commit 2c8ad2d5a20c8b7425b547dd4a969ffecad29b39
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:20:24 2017 -0400

    drm/amd/display: Enable DCE12 support
    
    This wires DCE12 support into DC and enables it.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index b9ca9688f8a3..28ed8eaee1ff 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1815,3 +1815,32 @@ void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink
 	}
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
+{
+	int i;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct mem_input *mi = NULL;
+
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+		if (core_dc->res_pool->mis[i] != NULL) {
+			mi = core_dc->res_pool->mis[i];
+			break;
+		}
+	}
+	if (mi == NULL) {
+		dm_error("no mem_input!\n");
+		return false;
+	}
+
+	if (mi->funcs->mem_input_update_dchub)
+		mi->funcs->mem_input_update_dchub(mi, dh_data);
+	else
+		ASSERT(mi->funcs->mem_input_update_dchub);
+
+
+	return true;
+
+}
+#endif
+

commit b2d0a103e6a0a823b46dd2d7f8c2de82c419e286
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Mar 1 18:27:17 2017 -0500

    drm/amd/display: add init calculation to scaler params
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index edcb731a3aea..b9ca9688f8a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -971,8 +971,7 @@ bool dc_pre_update_surfaces_to_stream(
 					DC_SURFACE_TO_CORE(new_surfaces[i]))
 				continue;
 
-			resource_build_scaling_params(
-				new_surfaces[i], &context->res_ctx.pipe_ctx[j]);
+			resource_build_scaling_params(&context->res_ctx.pipe_ctx[j]);
 		}
 
 	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
@@ -1364,7 +1363,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 				if (pipe_ctx->surface != surface)
 					continue;
 
-				resource_build_scaling_params(updates[i].surface, pipe_ctx);
+				resource_build_scaling_params(pipe_ctx);
 			}
 		}
 

commit a36214858c9093086c1bf1415af6b67c220d711f
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Thu Apr 20 15:59:25 2017 -0400

    drm/amd/display: Switch to DRM helpers in s3.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a39b9987b9d6..edcb731a3aea 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1589,21 +1589,15 @@ void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
 
 void dc_set_power_state(
 	struct dc *dc,
-	enum dc_acpi_cm_power_state power_state,
-	enum dc_video_power_state video_power_state)
+	enum dc_acpi_cm_power_state power_state)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	core_dc->previous_power_state = core_dc->current_power_state;
-	core_dc->current_power_state = video_power_state;
-
 	switch (power_state) {
 	case DC_ACPI_CM_POWER_STATE_D0:
 		core_dc->hwss.init_hw(core_dc);
 		break;
 	default:
-		/* NULL means "reset/release all DC streams" */
-		dc_commit_streams(dc, NULL, 0);
 
 		core_dc->hwss.power_down(core_dc);
 

commit f196f0805b5b75f024481ab4dc65f60d86fe6441
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Mar 3 09:37:11 2017 -0500

    drm/amd/display: After program backend, also program front end regs.
    
    Issue:
    In case of two 4K@60 + one non-4k monitor, when unplug non-4k monitor,
    the remain two 4k monitor don't work properly.
    Reason:
    In that case, two 4k use two pipes and no split, when unplug happens,
    those two monitor will use 4 pipes and split, but on that time, frontend
    is not programed properly.
    Solution:
    After programed backend, front end should be programmed as per new pipe
    setting.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f1ec27365f56..a39b9987b9d6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -806,7 +806,7 @@ bool dc_commit_streams(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
 	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
-	int i, j, k;
+	int i, j;
 
 	if (false == streams_changed(core_dc, streams, stream_count))
 		return DC_OK;
@@ -862,18 +862,10 @@ bool dc_commit_streams(
 		const struct core_sink *sink = context->streams[i]->sink;
 
 		for (j = 0; j < context->stream_status[i].surface_count; j++) {
-			const struct dc_surface *dc_surface =
-					context->stream_status[i].surfaces[j];
-
-			for (k = 0; k < context->res_ctx.pool->pipe_count; k++) {
-				struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[k];
+			struct core_surface *surface =
+					DC_SURFACE_TO_CORE(context->stream_status[i].surfaces[j]);
 
-				if (dc_surface != &pipe->surface->public
-						|| !dc_surface->visible)
-					continue;
-
-				pipe->tg->funcs->set_blank(pipe->tg, false);
-			}
+			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
 		}
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",

commit 5ac3d3c9b79fb607fc25268c8dbd220ac14f5ac6
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Mar 3 13:44:35 2017 -0500

    drm/amd/display: move refclk from dc to resource_pool
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4fed2f25cd96..f1ec27365f56 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -467,7 +467,6 @@ static bool construct(struct core_dc *dc,
 	else {
 		/* Create BIOS parser */
 		struct bp_init_data bp_init_data;
-		struct firmware_info fw_info = { { 0 } };
 
 		bp_init_data.ctx = dc_ctx;
 		bp_init_data.bios = init_params->asic_id.atombios_base_address;
@@ -481,12 +480,6 @@ static bool construct(struct core_dc *dc,
 		}
 
 		dc_ctx->created_bios = true;
-
-		if (dc_ctx->dc_bios->funcs->get_firmware_info(
-				dc_ctx->dc_bios, &fw_info) == BP_RESULT_OK) {
-				dc->ctx->ref_clock_inKhz = fw_info.pll_info.crystal_frequency;
-		} else
-			ASSERT_CRITICAL(false);
 		}
 
 	/* Create I2C AUX */

commit 68339af3cb7fa32634170fe5cf5cba1335bb8cc9
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Fri Mar 3 14:37:08 2017 -0500

    drm/amd/display: Memory leak fix during disable
    
    1.current_context memory wasn't released at
    dc_post_update_surfaces_to_stream during context swap.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 302a10c86afb..4fed2f25cd96 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1046,6 +1046,9 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
 	resource_validate_ctx_destruct(core_dc->current_context);
+	if (core_dc->current_context)
+		dm_free(core_dc->current_context);
+
 	core_dc->current_context = context;
 
 	return true;

commit e8c963d6d970220ab33f4197ab4dea18c1615e52
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Mar 2 21:18:03 2017 -0500

    drm/amd/display: refclock from bios firmwareInfoTable
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 27e31bd665ce..302a10c86afb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -467,6 +467,8 @@ static bool construct(struct core_dc *dc,
 	else {
 		/* Create BIOS parser */
 		struct bp_init_data bp_init_data;
+		struct firmware_info fw_info = { { 0 } };
+
 		bp_init_data.ctx = dc_ctx;
 		bp_init_data.bios = init_params->asic_id.atombios_base_address;
 
@@ -479,7 +481,13 @@ static bool construct(struct core_dc *dc,
 		}
 
 		dc_ctx->created_bios = true;
-	}
+
+		if (dc_ctx->dc_bios->funcs->get_firmware_info(
+				dc_ctx->dc_bios, &fw_info) == BP_RESULT_OK) {
+				dc->ctx->ref_clock_inKhz = fw_info.pll_info.crystal_frequency;
+		} else
+			ASSERT_CRITICAL(false);
+		}
 
 	/* Create I2C AUX */
 	dc_ctx->i2caux = dal_i2caux_create(dc_ctx);

commit 5869b0f6bc631d8c697018e7f1d873419da1dba2
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Wed Mar 1 12:30:11 2017 -0500

    drm/amd/display: Adding FastUpdate functionality
    
    Exposing DC Api dc_check_update_surfaces_for_stream
    validation will return the answer which type of update is required,
    so upper layers can is it safe to call the update API fro high IRQ yes/no.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c34232c8c322..27e31bd665ce 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1110,42 +1110,149 @@ static bool is_surface_in_context(
 	return false;
 }
 
-enum surface_update_type {
-	UPDATE_TYPE_FAST, /* super fast, safe to execute in isr */
-	UPDATE_TYPE_MED,  /* a lot of programming needed.  may need to alloc */
-	UPDATE_TYPE_FULL, /* may need to shuffle resources */
-};
+static unsigned int pixel_format_to_bpp(enum surface_pixel_format format)
+{
+	switch (format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		return 16;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		return 32;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		return 64;
+	default:
+		ASSERT_CRITICAL(false);
+		return -1;
+	}
+}
+
+static enum surface_update_type get_plane_info_update_type(
+		const struct dc_surface_update *u)
+{
+	struct dc_plane_info temp_plane_info = { { { { 0 } } } };
+
+	if (!u->plane_info)
+		return UPDATE_TYPE_FAST;
+
+	/* Copy all parameters that will cause a full update
+	 * from current surface, the rest of the parameters
+	 * from provided plane configuration.
+	 * Perform memory compare and special validation
+	 * for those that can cause fast/medium updates
+	 */
+
+	/* Full update parameters */
+	temp_plane_info.color_space = u->surface->color_space;
+	temp_plane_info.dcc = u->surface->dcc;
+	temp_plane_info.horizontal_mirror = u->surface->horizontal_mirror;
+	temp_plane_info.plane_size = u->surface->plane_size;
+	temp_plane_info.rotation = u->surface->rotation;
+	temp_plane_info.stereo_format = u->surface->stereo_format;
+	temp_plane_info.tiling_info = u->surface->tiling_info;
+	temp_plane_info.visible = u->surface->visible;
+
+	/* Special Validation parameters */
+	temp_plane_info.format = u->plane_info->format;
+
+	if (memcmp(u->plane_info, &temp_plane_info,
+			sizeof(struct dc_plane_info)) != 0)
+		return UPDATE_TYPE_FULL;
+
+	if (pixel_format_to_bpp(u->plane_info->format) !=
+			pixel_format_to_bpp(u->surface->format)) {
+		return UPDATE_TYPE_FULL;
+	} else {
+		return UPDATE_TYPE_MED;
+	}
+}
+
+static enum surface_update_type  get_scaling_info_update_type(
+		const struct dc_surface_update *u)
+{
+	struct dc_scaling_info temp_scaling_info = { { 0 } };
+
+	if (!u->scaling_info)
+		return UPDATE_TYPE_FAST;
+
+	/* Copy all parameters that will cause a full update
+	 * from current surface, the rest of the parameters
+	 * from provided plane configuration.
+	 * Perform memory compare and special validation
+	 * for those that can cause fast/medium updates
+	 */
+
+	/* Full Update Parameters */
+	temp_scaling_info.dst_rect = u->surface->dst_rect;
+	temp_scaling_info.src_rect = u->surface->src_rect;
+	temp_scaling_info.scaling_quality = u->surface->scaling_quality;
+
+	/* Special validation required */
+	temp_scaling_info.clip_rect = u->scaling_info->clip_rect;
+
+	if (memcmp(u->scaling_info, &temp_scaling_info,
+			sizeof(struct dc_scaling_info)) != 0)
+		return UPDATE_TYPE_FULL;
+
+	/* Check Clip rectangles if not equal
+	 * difference is in offsets == > UPDATE_TYPE_FAST
+	 * difference is in dimensions == > UPDATE_TYPE_FULL
+	 */
+	if (memcmp(&u->scaling_info->clip_rect,
+			&u->surface->clip_rect, sizeof(struct rect)) != 0) {
+		if ((u->scaling_info->clip_rect.height ==
+			u->surface->clip_rect.height) &&
+			(u->scaling_info->clip_rect.width ==
+			u->surface->clip_rect.width)) {
+			return UPDATE_TYPE_FAST;
+		} else {
+			return UPDATE_TYPE_FULL;
+		}
+	}
+
+	return UPDATE_TYPE_FAST;
+}
 
 static enum surface_update_type det_surface_update(
 		const struct core_dc *dc,
 		const struct dc_surface_update *u)
 {
 	const struct validate_context *context = dc->current_context;
-
-	if (u->scaling_info || u->plane_info)
-		/* todo: not all scale and plane_info update need full update
-		 * ie. check if following is the same
-		 * scale ratio, view port, surface bpp etc
-		 */
-		return UPDATE_TYPE_FULL; /* may need bandwidth update */
+	enum surface_update_type type = UPDATE_TYPE_FAST;
+	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
 	if (!is_surface_in_context(context, u->surface))
 		return UPDATE_TYPE_FULL;
 
+	type = get_plane_info_update_type(u);
+	if (overall_type < type)
+		overall_type = type;
+
+	type = get_scaling_info_update_type(u);
+	if (overall_type < type)
+		overall_type = type;
+
 	if (u->in_transfer_func ||
 		u->out_transfer_func ||
-		u->hdr_static_metadata)
-		return UPDATE_TYPE_MED;
+		u->hdr_static_metadata) {
+		if (overall_type < UPDATE_TYPE_MED)
+			overall_type = UPDATE_TYPE_MED;
+	}
 
-	return UPDATE_TYPE_FAST;
+	return overall_type;
 }
 
-static enum surface_update_type check_update_surfaces_for_stream(
-		struct core_dc *dc,
+enum surface_update_type dc_check_update_surfaces_for_stream(
+		struct dc *dc,
 		struct dc_surface_update *updates,
 		int surface_count,
 		const struct dc_stream_status *stream_status)
 {
+	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
 	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
@@ -1154,7 +1261,7 @@ static enum surface_update_type check_update_surfaces_for_stream(
 
 	for (i = 0 ; i < surface_count; i++) {
 		enum surface_update_type type =
-				det_surface_update(dc, &updates[i]);
+				det_surface_update(core_dc, &updates[i]);
 
 		if (type == UPDATE_TYPE_FULL)
 			return type;
@@ -1184,8 +1291,8 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 	if (!stream_status)
 		return; /* Cannot commit surface to stream that is not committed */
 
-	update_type = check_update_surfaces_for_stream(
-			core_dc, updates, surface_count, stream_status);
+	update_type = dc_check_update_surfaces_for_stream(
+			dc, updates, surface_count, stream_status);
 
 	if (update_type >= update_surface_trace_level)
 		update_surface_trace(dc, updates, surface_count);
@@ -1321,7 +1428,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			if (pipe_ctx->surface != surface)
 				continue;
 
-			if (update_type == UPDATE_TYPE_FULL) {
+			if (update_type >= UPDATE_TYPE_MED) {
 				/* only apply for top pipe */
 				if (!pipe_ctx->top_pipe) {
 					core_dc->hwss.apply_ctx_for_surface(core_dc,

commit 773d1bcae744379a03f525bfc9249d8abf0550a8
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Feb 28 22:52:29 2017 -0500

    drm/amd/display: remove independent lock as we have no use case today
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8f871924beb9..c34232c8c322 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1178,7 +1178,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
-	unsigned int lock_mask = 0;
 
 	stream_status = dc_stream_get_status(dc_stream);
 	ASSERT(stream_status);
@@ -1332,15 +1331,9 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			}
 
 			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-				lock_mask = PIPE_LOCK_CONTROL_GRAPHICS |
-						PIPE_LOCK_CONTROL_SCL |
-						PIPE_LOCK_CONTROL_BLENDER |
-						PIPE_LOCK_CONTROL_MODE;
-
 				core_dc->hwss.pipe_control_lock(
 						core_dc,
 						pipe_ctx,
-						lock_mask,
 						true);
 			}
 
@@ -1382,7 +1375,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 					core_dc->hwss.pipe_control_lock(
 							core_dc,
 							pipe_ctx,
-							lock_mask,
 							false);
 				}
 				break;

commit d98e5cc2ddacb34e9cdf1c06dce2758198af0120
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Feb 28 21:30:32 2017 -0500

    drm/amd/display: clean up and simply locking logic
    
    always take update lock instead of using HW built in update
    lock trigger with write to primary_addr_lo.
    
    we will be a little more inefficient with the extra registers
    write to lock, but this simplify code and make it always correct.
    
    Will revisit locking optimization once update sequence mature
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index efe50fd2be78..8f871924beb9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1321,22 +1321,22 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 
 			if (pipe_ctx->surface != surface)
 				continue;
-			/*lock all the MCPP if blnd is enable for DRR*/
-			if ((update_type == UPDATE_TYPE_FAST &&
-					(dc_stream->freesync_ctx.enabled == true &&
-							surface_count != context->res_ctx.pool->pipe_count)) &&
-					!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-				lock_mask = PIPE_LOCK_CONTROL_MPCC_ADDR;
+
+			if (update_type == UPDATE_TYPE_FULL) {
+				/* only apply for top pipe */
+				if (!pipe_ctx->top_pipe) {
+					core_dc->hwss.apply_ctx_for_surface(core_dc,
+							 surface, context);
+					context_timing_trace(dc, &context->res_ctx);
+				}
 			}
 
-			if (update_type != UPDATE_TYPE_FAST &&
-				!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
+			if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 				lock_mask = PIPE_LOCK_CONTROL_GRAPHICS |
 						PIPE_LOCK_CONTROL_SCL |
 						PIPE_LOCK_CONTROL_BLENDER |
 						PIPE_LOCK_CONTROL_MODE;
-			}
-			if (lock_mask != 0) {
+
 				core_dc->hwss.pipe_control_lock(
 						core_dc,
 						pipe_ctx,
@@ -1344,15 +1344,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 						true);
 			}
 
-			if (update_type == UPDATE_TYPE_FULL) {
-				/* only apply for top pipe */
-				if (!pipe_ctx->top_pipe) {
-					core_dc->hwss.apply_ctx_for_surface(core_dc,
-							 surface, context);
-					context_timing_trace(dc, &context->res_ctx);
-				}
-			}
-
 			if (updates[i].flip_addr)
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 
@@ -1382,9 +1373,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		}
 	}
 
-	if ((update_type == UPDATE_TYPE_FAST) && lock_mask == 0)
-		return;
-
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 

commit 92a65e32ade943135a6e48ec756661c0896392d0
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Feb 28 19:49:15 2017 -0500

    drm/amd/display: extended the programming sequence to VFlip as well
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 66a5b2745501..efe50fd2be78 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1316,6 +1316,9 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+			struct pipe_ctx *cur_pipe_ctx;
+			bool is_new_pipe_surface = true;
+
 			if (pipe_ctx->surface != surface)
 				continue;
 			/*lock all the MCPP if blnd is enable for DRR*/
@@ -1324,26 +1327,16 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 							surface_count != context->res_ctx.pool->pipe_count)) &&
 					!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 				lock_mask = PIPE_LOCK_CONTROL_MPCC_ADDR;
-				core_dc->hwss.pipe_control_lock(
-						core_dc,
-						pipe_ctx,
-						lock_mask,
-						true);
-				}
 			}
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-			struct pipe_ctx *cur_pipe_ctx;
-			bool is_new_pipe_surface = true;
 
-			if (pipe_ctx->surface != surface)
-				continue;
 			if (update_type != UPDATE_TYPE_FAST &&
 				!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 				lock_mask = PIPE_LOCK_CONTROL_GRAPHICS |
 						PIPE_LOCK_CONTROL_SCL |
 						PIPE_LOCK_CONTROL_BLENDER |
 						PIPE_LOCK_CONTROL_MODE;
+			}
+			if (lock_mask != 0) {
 				core_dc->hwss.pipe_control_lock(
 						core_dc,
 						pipe_ctx,
@@ -1389,7 +1382,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		}
 	}
 
-	if (update_type == UPDATE_TYPE_FAST && (lock_mask == 0))
+	if ((update_type == UPDATE_TYPE_FAST) && lock_mask == 0)
 		return;
 
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {

commit f0828115efa0406fbe0010b1d8c9c965fc718733
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Feb 28 15:23:38 2017 -0500

    drm/amd/display: freesync pipe split :VTotal_Min_Mask for Hflip/lock.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 852932aec436..66a5b2745501 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1178,6 +1178,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 
 	enum surface_update_type update_type;
 	const struct dc_stream_status *stream_status;
+	unsigned int lock_mask = 0;
 
 	stream_status = dc_stream_get_status(dc_stream);
 	ASSERT(stream_status);
@@ -1313,6 +1314,23 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
 
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+			if (pipe_ctx->surface != surface)
+				continue;
+			/*lock all the MCPP if blnd is enable for DRR*/
+			if ((update_type == UPDATE_TYPE_FAST &&
+					(dc_stream->freesync_ctx.enabled == true &&
+							surface_count != context->res_ctx.pool->pipe_count)) &&
+					!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
+				lock_mask = PIPE_LOCK_CONTROL_MPCC_ADDR;
+				core_dc->hwss.pipe_control_lock(
+						core_dc,
+						pipe_ctx,
+						lock_mask,
+						true);
+				}
+			}
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 			struct pipe_ctx *cur_pipe_ctx;
@@ -1320,16 +1338,16 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 
 			if (pipe_ctx->surface != surface)
 				continue;
-
 			if (update_type != UPDATE_TYPE_FAST &&
 				!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-				core_dc->hwss.pipe_control_lock(
-						core_dc->hwseq,
-						pipe_ctx->pipe_idx,
-						PIPE_LOCK_CONTROL_GRAPHICS |
+				lock_mask = PIPE_LOCK_CONTROL_GRAPHICS |
 						PIPE_LOCK_CONTROL_SCL |
 						PIPE_LOCK_CONTROL_BLENDER |
-						PIPE_LOCK_CONTROL_MODE,
+						PIPE_LOCK_CONTROL_MODE;
+				core_dc->hwss.pipe_control_lock(
+						core_dc,
+						pipe_ctx,
+						lock_mask,
 						true);
 			}
 
@@ -1371,7 +1389,7 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		}
 	}
 
-	if (update_type == UPDATE_TYPE_FAST)
+	if (update_type == UPDATE_TYPE_FAST && (lock_mask == 0))
 		return;
 
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
@@ -1381,11 +1399,9 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			if (updates[j].surface == &pipe_ctx->surface->public) {
 				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 					core_dc->hwss.pipe_control_lock(
-							core_dc->hwseq,
-							pipe_ctx->pipe_idx,
-							PIPE_LOCK_CONTROL_GRAPHICS |
-							PIPE_LOCK_CONTROL_SCL |
-							PIPE_LOCK_CONTROL_BLENDER,
+							core_dc,
+							pipe_ctx,
+							lock_mask,
 							false);
 				}
 				break;

commit ce9c088051e198b19eb533b24c605b7cedbe5b9c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Feb 22 18:14:52 2017 -0500

    drm/amd/display: move visual confirm recout adjustment to scaler
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 0ec2c4f39735..852932aec436 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -980,11 +980,6 @@ bool dc_pre_update_surfaces_to_stream(
 
 			resource_build_scaling_params(
 				new_surfaces[i], &context->res_ctx.pipe_ctx[j]);
-
-			if (dc->debug.surface_visual_confirm) {
-				context->res_ctx.pipe_ctx[j].scl_data.recout.height -= 2;
-				context->res_ctx.pipe_ctx[j].scl_data.recout.width -= 2;
-			}
 		}
 
 	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
@@ -1267,10 +1262,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 					continue;
 
 				resource_build_scaling_params(updates[i].surface, pipe_ctx);
-				if (dc->debug.surface_visual_confirm) {
-					pipe_ctx->scl_data.recout.height -= 2;
-					pipe_ctx->scl_data.recout.width -= 2;
-				}
 			}
 		}
 

commit cf43759306002e29f025344504dc680a9a0b3ac8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Feb 22 17:52:22 2017 -0500

    drm/amd/display: bandwidth update fix
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index da0f72071ef5..0ec2c4f39735 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -795,159 +795,6 @@ static bool streams_changed(
 	return false;
 }
 
-static void fill_display_configs(
-	const struct validate_context *context,
-	struct dm_pp_display_configuration *pp_display_cfg)
-{
-	int j;
-	int num_cfgs = 0;
-
-	for (j = 0; j < context->stream_count; j++) {
-		int k;
-
-		const struct core_stream *stream = context->streams[j];
-		struct dm_pp_single_disp_config *cfg =
-			&pp_display_cfg->disp_configs[num_cfgs];
-		const struct pipe_ctx *pipe_ctx = NULL;
-
-		for (k = 0; k < MAX_PIPES; k++)
-			if (stream == context->res_ctx.pipe_ctx[k].stream) {
-				pipe_ctx = &context->res_ctx.pipe_ctx[k];
-				break;
-			}
-
-		ASSERT(pipe_ctx != NULL);
-
-		num_cfgs++;
-		cfg->signal = pipe_ctx->stream->signal;
-		cfg->pipe_idx = pipe_ctx->pipe_idx;
-		cfg->src_height = stream->public.src.height;
-		cfg->src_width = stream->public.src.width;
-		cfg->ddi_channel_mapping =
-			stream->sink->link->ddi_channel_mapping.raw;
-		cfg->transmitter =
-			stream->sink->link->link_enc->transmitter;
-		cfg->link_settings.lane_count =
-			stream->sink->link->public.cur_link_settings.lane_count;
-		cfg->link_settings.link_rate =
-			stream->sink->link->public.cur_link_settings.link_rate;
-		cfg->link_settings.link_spread =
-			stream->sink->link->public.cur_link_settings.link_spread;
-		cfg->sym_clock = stream->phy_pix_clk;
-		/* Round v_refresh*/
-		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
-		cfg->v_refresh /= stream->public.timing.h_total;
-		cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
-							/ stream->public.timing.v_total;
-	}
-
-	pp_display_cfg->display_count = num_cfgs;
-}
-
-static uint32_t get_min_vblank_time_us(const struct validate_context *context)
-{
-	uint8_t j;
-	uint32_t min_vertical_blank_time = -1;
-
-		for (j = 0; j < context->stream_count; j++) {
-			const struct dc_stream *stream = &context->streams[j]->public;
-			uint32_t vertical_blank_in_pixels = 0;
-			uint32_t vertical_blank_time = 0;
-
-			vertical_blank_in_pixels = stream->timing.h_total *
-				(stream->timing.v_total
-					- stream->timing.v_addressable);
-
-			vertical_blank_time = vertical_blank_in_pixels
-				* 1000 / stream->timing.pix_clk_khz;
-
-			if (min_vertical_blank_time > vertical_blank_time)
-				min_vertical_blank_time = vertical_blank_time;
-		}
-
-	return min_vertical_blank_time;
-}
-
-static int determine_sclk_from_bounding_box(
-		const struct core_dc *dc,
-		int required_sclk)
-{
-	int i;
-
-	/*
-	 * Some asics do not give us sclk levels, so we just report the actual
-	 * required sclk
-	 */
-	if (dc->sclk_lvls.num_levels == 0)
-		return required_sclk;
-
-	for (i = 0; i < dc->sclk_lvls.num_levels; i++) {
-		if (dc->sclk_lvls.clocks_in_khz[i] >= required_sclk)
-			return dc->sclk_lvls.clocks_in_khz[i];
-	}
-	/*
-	 * even maximum level could not satisfy requirement, this
-	 * is unexpected at this stage, should have been caught at
-	 * validation time
-	 */
-	ASSERT(0);
-	return dc->sclk_lvls.clocks_in_khz[dc->sclk_lvls.num_levels - 1];
-}
-
-void pplib_apply_display_requirements(
-	struct core_dc *dc,
-	const struct validate_context *context,
-	struct dm_pp_display_configuration *pp_display_cfg)
-{
-	pp_display_cfg->all_displays_in_sync =
-		context->bw_results.all_displays_in_sync;
-	pp_display_cfg->nb_pstate_switch_disable =
-			context->bw_results.nbp_state_change_enable == false;
-	pp_display_cfg->cpu_cc6_disable =
-			context->bw_results.cpuc_state_change_enable == false;
-	pp_display_cfg->cpu_pstate_disable =
-			context->bw_results.cpup_state_change_enable == false;
-	pp_display_cfg->cpu_pstate_separation_time =
-			context->bw_results.blackout_recovery_time_us;
-
-	pp_display_cfg->min_memory_clock_khz = context->bw_results.required_yclk
-		/ MEMORY_TYPE_MULTIPLIER;
-
-	pp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(
-			dc,
-			context->bw_results.required_sclk);
-
-	pp_display_cfg->min_engine_clock_deep_sleep_khz
-			= context->bw_results.required_sclk_deep_sleep;
-
-	pp_display_cfg->avail_mclk_switch_time_us =
-						get_min_vblank_time_us(context);
-	/* TODO: dce11.2*/
-	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
-
-	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
-
-	fill_display_configs(context, pp_display_cfg);
-
-	/* TODO: is this still applicable?*/
-	if (pp_display_cfg->display_count == 1) {
-		const struct dc_crtc_timing *timing =
-			&context->streams[0]->public.timing;
-
-		pp_display_cfg->crtc_index =
-			pp_display_cfg->disp_configs[0].pipe_idx;
-		pp_display_cfg->line_time_in_us = timing->h_total * 1000
-							/ timing->pix_clk_khz;
-	}
-
-	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
-			struct dm_pp_display_configuration)) !=  0)
-		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
-
-	dc->prev_display_config = *pp_display_cfg;
-
-}
-
 bool dc_commit_streams(
 	struct dc *dc,
 	const struct dc_stream *streams[],
@@ -1036,9 +883,6 @@ bool dc_commit_streams(
 				context->streams[i]->public.timing.pix_clk_khz);
 	}
 
-	pplib_apply_display_requirements(core_dc,
-			context, &context->pp_display_cfg);
-
 	resource_validate_ctx_destruct(core_dc->current_context);
 
 	if (core_dc->temp_flip_context != core_dc->current_context) {
@@ -1065,7 +909,6 @@ bool dc_pre_update_surfaces_to_stream(
 {
 	int i, j;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int prev_disp_clk = core_dc->current_context->dispclk_khz;
 	struct dc_stream_status *stream_status = NULL;
 	struct validate_context *context;
 	bool ret = true;
@@ -1150,16 +993,7 @@ bool dc_pre_update_surfaces_to_stream(
 		goto unexpected_fail;
 	}
 
-	if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)
-			&& prev_disp_clk < context->dispclk_khz) {
-		pplib_apply_display_requirements(core_dc, context,
-						&context->pp_display_cfg);
-		context->res_ctx.pool->display_clock->funcs->set_clock(
-				context->res_ctx.pool->display_clock,
-				context->dispclk_khz * 115 / 100);
-		core_dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
-		core_dc->current_context->dispclk_khz = context->dispclk_khz;
-	}
+	core_dc->hwss.set_bandwidth(core_dc, context, false);
 
 	for (i = 0; i < new_surface_count; i++)
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
@@ -1206,10 +1040,7 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 		return false;
 	}
 
-	core_dc->hwss.set_bandwidth(core_dc);
-
-	/*TODO: dce specific*/
-	pplib_apply_display_requirements(core_dc, context, &context->pp_display_cfg);
+	core_dc->hwss.set_bandwidth(core_dc, context, true);
 
 	resource_validate_ctx_destruct(core_dc->current_context);
 	core_dc->current_context = context;

commit 45209ef7197bd4b5e7e224ff46fa9a3eca25c3bd
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Feb 24 14:19:40 2017 -0500

    drm/amd/display: remove apply_clk_constraints, used validate_bandwidth universally
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e0d9572768cb..da0f72071ef5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1144,12 +1144,11 @@ bool dc_pre_update_surfaces_to_stream(
 			}
 		}
 
-	if (core_dc->res_pool->funcs->validate_bandwidth)
-		if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, context) != DC_OK) {
-			BREAK_TO_DEBUGGER();
-			ret = false;
-			goto unexpected_fail;
-		}
+	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
+		BREAK_TO_DEBUGGER();
+		ret = false;
+		goto unexpected_fail;
+	}
 
 	if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)
 			&& prev_disp_clk < context->dispclk_khz) {
@@ -1184,28 +1183,36 @@ bool dc_pre_update_surfaces_to_stream(
 
 bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *context = dm_alloc(sizeof(struct validate_context));
+
+	if (!context) {
+		dm_error("%s: failed to create validate ctx\n", __func__);
+		return false;
+	}
+	resource_validate_ctx_copy_construct(core_dc->current_context, context);
 
 	post_surface_trace(dc);
 
-	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count; i++)
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL) {
-			core_dc->current_context->res_ctx.pipe_ctx[i].pipe_idx = i;
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++)
+		if (context->res_ctx.pipe_ctx[i].stream == NULL) {
+			context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
-					core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
-		}
-	if (core_dc->res_pool->funcs->validate_bandwidth)
-		if (core_dc->res_pool->funcs->validate_bandwidth(
-				core_dc, core_dc->current_context) != DC_OK) {
-			BREAK_TO_DEBUGGER();
-			return false;
+					core_dc, &context->res_ctx.pipe_ctx[i]);
 		}
+	if (!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
 
 	core_dc->hwss.set_bandwidth(core_dc);
 
-	pplib_apply_display_requirements(
-			core_dc, core_dc->current_context, &core_dc->current_context->pp_display_cfg);
+	/*TODO: dce specific*/
+	pplib_apply_display_requirements(core_dc, context, &context->pp_display_cfg);
+
+	resource_validate_ctx_destruct(core_dc->current_context);
+	core_dc->current_context = context;
 
 	return true;
 }
@@ -1472,6 +1479,11 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 				*(updates[i].hdr_static_metadata);
 	}
 
+	if (update_type == UPDATE_TYPE_FULL &&
+			!core_dc->res_pool->funcs->validate_bandwidth(core_dc, context)) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
 
 	if (!surface_count)  /* reset */
 		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);

commit 648013696767f0266aa7bd44407786a99f7a7910
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 24 11:31:23 2017 -0500

    drm/amd/display: Fix warnings in DC
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 6516c275e0c7..e0d9572768cb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1068,7 +1068,6 @@ bool dc_pre_update_surfaces_to_stream(
 	int prev_disp_clk = core_dc->current_context->dispclk_khz;
 	struct dc_stream_status *stream_status = NULL;
 	struct validate_context *context;
-	struct validate_context *temp_context;
 	bool ret = true;
 
 	pre_surface_trace(dc, new_surfaces, new_surface_count);
@@ -1425,7 +1424,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		if (update_type == UPDATE_TYPE_FULL) {
 			for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-				struct core_stream *stream = pipe_ctx->stream;
 
 				if (pipe_ctx->surface != surface)
 					continue;

commit 2b230ea3e76f6238b31fd270cab76d55394f3293
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Thu Feb 16 16:15:30 2017 -0500

    drm/amd/display: Add query_ddc_data function
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 84412e752017..6516c275e0c7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1725,6 +1725,31 @@ bool dc_read_dpcd(
 	return r == DDC_RESULT_SUCESSFULL;
 }
 
+bool dc_query_ddc_data(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		uint8_t *write_buf,
+		uint32_t write_size,
+		uint8_t *read_buf,
+		uint32_t read_size) {
+
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
+
+	bool result = dal_ddc_service_query_ddc_data(
+			link->ddc,
+			address,
+			write_buf,
+			write_size,
+			read_buf,
+			read_size);
+
+	return result;
+}
+
+
 bool dc_write_dpcd(
 		struct dc *dc,
 		uint32_t link_index,

commit 5c1879b6b93898d65e05dfb47f947fa4f5a904a4
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Mon Feb 13 11:07:33 2017 -0500

    drm/amd/display: fix dc_commit_surfaces_to_stream for dcc
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 4c405f4b880e..84412e752017 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1246,6 +1246,7 @@ bool dc_commit_surfaces_to_stream(
 		plane_info[i].stereo_format = new_surfaces[i]->stereo_format;
 		plane_info[i].tiling_info = new_surfaces[i]->tiling_info;
 		plane_info[i].visible = new_surfaces[i]->visible;
+		plane_info[i].dcc = new_surfaces[i]->dcc;
 		scaling_info[i].scaling_quality = new_surfaces[i]->scaling_quality;
 		scaling_info[i].src_rect = new_surfaces[i]->src_rect;
 		scaling_info[i].dst_rect = new_surfaces[i]->dst_rect;

commit a99240d5f8e14fc081e2cccad6ac46b48cea7def
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Feb 2 17:08:19 2017 -0500

    drm/amd/display: use disp clock value in context rather than bw_results
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9d2f78f21748..4c405f4b880e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -925,7 +925,7 @@ void pplib_apply_display_requirements(
 	/* TODO: dce11.2*/
 	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
 
-	pp_display_cfg->disp_clk_khz = context->bw_results.dispclk_khz;
+	pp_display_cfg->disp_clk_khz = context->dispclk_khz;
 
 	fill_display_configs(context, pp_display_cfg);
 
@@ -1065,8 +1065,7 @@ bool dc_pre_update_surfaces_to_stream(
 {
 	int i, j;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
-	int new_disp_clk;
+	int prev_disp_clk = core_dc->current_context->dispclk_khz;
 	struct dc_stream_status *stream_status = NULL;
 	struct validate_context *context;
 	struct validate_context *temp_context;
@@ -1152,17 +1151,16 @@ bool dc_pre_update_surfaces_to_stream(
 			ret = false;
 			goto unexpected_fail;
 		}
-	new_disp_clk = context->bw_results.dispclk_khz;
 
 	if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)
-			&& prev_disp_clk < new_disp_clk) {
+			&& prev_disp_clk < context->dispclk_khz) {
 		pplib_apply_display_requirements(core_dc, context,
 						&context->pp_display_cfg);
 		context->res_ctx.pool->display_clock->funcs->set_clock(
 				context->res_ctx.pool->display_clock,
-				new_disp_clk * 115 / 100);
-		core_dc->current_context->bw_results.dispclk_khz = new_disp_clk;
-		core_dc->current_context->dispclk_khz = new_disp_clk;
+				context->dispclk_khz * 115 / 100);
+		core_dc->current_context->bw_results.dispclk_khz = context->dispclk_khz;
+		core_dc->current_context->dispclk_khz = context->dispclk_khz;
 	}
 
 	for (i = 0; i < new_surface_count; i++)

commit 0f56b418ef497032a71358fb8c76d10f24fd5d58
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jan 25 13:58:46 2017 -0500

    drm/amd/display: add dcfclk reporting to pplib
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e05e4199e38a..9d2f78f21748 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1065,7 +1065,7 @@ bool dc_pre_update_surfaces_to_stream(
 {
 	int i, j;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
+	int prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
 	int new_disp_clk;
 	struct dc_stream_status *stream_status = NULL;
 	struct validate_context *context;
@@ -1146,36 +1146,23 @@ bool dc_pre_update_surfaces_to_stream(
 			}
 		}
 
-	if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, context) != DC_OK) {
-		BREAK_TO_DEBUGGER();
-		ret = false;
-		goto unexpected_fail;
-	}
-	new_disp_clk = context->bw_results.dispclk_khz;
-
-	if (core_dc->res_pool->funcs->apply_clk_constraints) {
-		temp_context = core_dc->res_pool->funcs->apply_clk_constraints(
-				core_dc,
-				context);
-		if (!temp_context) {
-			dm_error("%s:failed apply clk constraints\n", __func__);
+	if (core_dc->res_pool->funcs->validate_bandwidth)
+		if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, context) != DC_OK) {
+			BREAK_TO_DEBUGGER();
 			ret = false;
 			goto unexpected_fail;
 		}
-		resource_validate_ctx_destruct(context);
-		ASSERT(core_dc->scratch_val_ctx == temp_context);
-		core_dc->scratch_val_ctx = context;
-		context = temp_context;
-	}
+	new_disp_clk = context->bw_results.dispclk_khz;
 
-	if (prev_disp_clk < new_disp_clk) {
+	if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)
+			&& prev_disp_clk < new_disp_clk) {
 		pplib_apply_display_requirements(core_dc, context,
 						&context->pp_display_cfg);
 		context->res_ctx.pool->display_clock->funcs->set_clock(
 				context->res_ctx.pool->display_clock,
-				context->bw_results.dispclk_khz * 115 / 100);
-		core_dc->current_context->bw_results.dispclk_khz =
-				context->bw_results.dispclk_khz;
+				new_disp_clk * 115 / 100);
+		core_dc->current_context->bw_results.dispclk_khz = new_disp_clk;
+		core_dc->current_context->dispclk_khz = new_disp_clk;
 	}
 
 	for (i = 0; i < new_surface_count; i++)
@@ -1209,15 +1196,14 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL) {
 			core_dc->current_context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
-							core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
+					core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
+		}
+	if (core_dc->res_pool->funcs->validate_bandwidth)
+		if (core_dc->res_pool->funcs->validate_bandwidth(
+				core_dc, core_dc->current_context) != DC_OK) {
+			BREAK_TO_DEBUGGER();
+			return false;
 		}
-
-
-	if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, core_dc->current_context)
-			!= DC_OK) {
-		BREAK_TO_DEBUGGER();
-		return false;
-	}
 
 	core_dc->hwss.set_bandwidth(core_dc);
 

commit 998166a6116bea93f6e1672177581b689b008bf7
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jan 24 15:45:33 2017 -0500

    drm/amd/display: Make new pixel clock more obvious
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 499ef561bbfc..e05e4199e38a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1066,6 +1066,7 @@ bool dc_pre_update_surfaces_to_stream(
 	int i, j;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
+	int new_disp_clk;
 	struct dc_stream_status *stream_status = NULL;
 	struct validate_context *context;
 	struct validate_context *temp_context;
@@ -1150,6 +1151,7 @@ bool dc_pre_update_surfaces_to_stream(
 		ret = false;
 		goto unexpected_fail;
 	}
+	new_disp_clk = context->bw_results.dispclk_khz;
 
 	if (core_dc->res_pool->funcs->apply_clk_constraints) {
 		temp_context = core_dc->res_pool->funcs->apply_clk_constraints(
@@ -1166,7 +1168,7 @@ bool dc_pre_update_surfaces_to_stream(
 		context = temp_context;
 	}
 
-	if (prev_disp_clk < context->bw_results.dispclk_khz) {
+	if (prev_disp_clk < new_disp_clk) {
 		pplib_apply_display_requirements(core_dc, context,
 						&context->pp_display_cfg);
 		context->res_ctx.pool->display_clock->funcs->set_clock(

commit 6728b30c974e38711f70dc38edf68503bf71c4a9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Jan 24 15:19:42 2017 -0500

    drm/amd/display: Move backlight from encoder to ABM
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 152c694cc044..499ef561bbfc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -240,34 +240,6 @@ static void stream_update_scaling(
 	}
 }
 
-static bool set_backlight(struct dc *dc, unsigned int backlight_level,
-			unsigned int frame_ramp, const struct dc_stream *stream)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int i;
-
-	if (stream->sink->sink_signal == SIGNAL_TYPE_EDP) {
-		for (i = 0; i < core_dc->link_count; i++)
-			dc_link_set_backlight_level(&core_dc->links[i]->public,
-					backlight_level, frame_ramp, stream);
-	}
-
-	return true;
-
-}
-
-static bool init_dmcu_backlight_settings(struct dc *dc)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int i;
-
-	for (i = 0; i < core_dc->link_count; i++)
-		dc_link_init_dmcu_backlight_settings
-			(&core_dc->links[i]->public);
-
-	return true;
-}
-
 static bool set_psr_enable(struct dc *dc, bool enable)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -390,12 +362,6 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 	core_dc->public.stream_funcs.set_gamut_remap =
 			set_gamut_remap;
 
-	core_dc->public.stream_funcs.set_backlight =
-			set_backlight;
-
-	core_dc->public.stream_funcs.init_dmcu_backlight_settings =
-			init_dmcu_backlight_settings;
-
 	core_dc->public.stream_funcs.set_psr_enable =
 			set_psr_enable;
 

commit 5e7773a219f7821163ad2b17be0d02f8be8ce0c6
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Jan 23 16:55:20 2017 -0500

    drm/amd/display: DMCU Compile and Load
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 474c2d42525d..152c694cc044 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -268,19 +268,6 @@ static bool init_dmcu_backlight_settings(struct dc *dc)
 	return true;
 }
 
-
-static bool set_abm_level(struct dc *dc, unsigned int abm_level)
-{
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int i;
-
-	for (i = 0; i < core_dc->link_count; i++)
-		dc_link_set_abm_level(&core_dc->links[i]->public,
-				abm_level);
-
-	return true;
-}
-
 static bool set_psr_enable(struct dc *dc, bool enable)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
@@ -409,9 +396,6 @@ static void allocate_dc_stream_funcs(struct core_dc *core_dc)
 	core_dc->public.stream_funcs.init_dmcu_backlight_settings =
 			init_dmcu_backlight_settings;
 
-	core_dc->public.stream_funcs.set_abm_level =
-			set_abm_level;
-
 	core_dc->public.stream_funcs.set_psr_enable =
 			set_psr_enable;
 

commit bb9042da8e8ada796cfae7e432a54e872c5b1784
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 27 10:29:01 2017 -0500

    drm/amd/display: Change power gating off sequence to fix hang
    
    Power off plane clear all the reg values includes cursor.
    When OS call set cursor position, cursor address reg is cleared,
    results in system hard hang.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 75718151356d..474c2d42525d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1254,9 +1254,12 @@ bool dc_post_update_surfaces_to_stream(struct dc *dc)
 	post_surface_trace(dc);
 
 	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count; i++)
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL)
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL) {
+			core_dc->current_context->res_ctx.pipe_ctx[i].pipe_idx = i;
 			core_dc->hwss.power_down_front_end(
-				core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
+							core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
+		}
+
 
 	if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, core_dc->current_context)
 			!= DC_OK) {

commit 17c06cab918e23b15dcf1618d9735a46fd1529f8
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Jan 24 16:06:32 2017 -0500

    drm/amd/display: Make sure to update address without flip
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c863bffab989..75718151356d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1568,7 +1568,9 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 							 surface, context);
 					context_timing_trace(dc, &context->res_ctx);
 				}
-			} else if (updates[i].flip_addr)
+			}
+
+			if (updates[i].flip_addr)
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 
 			if (update_type == UPDATE_TYPE_FAST)

commit 37d66a339b6f29251ebe0da78816d6d07554c617
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jan 20 17:14:23 2017 -0500

    drm/amd/display: fix timing trace debug print
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index c627b907528c..c863bffab989 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1563,9 +1563,11 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 
 			if (update_type == UPDATE_TYPE_FULL) {
 				/* only apply for top pipe */
-				if (!pipe_ctx->top_pipe)
+				if (!pipe_ctx->top_pipe) {
 					core_dc->hwss.apply_ctx_for_surface(core_dc,
 							 surface, context);
+					context_timing_trace(dc, &context->res_ctx);
+				}
 			} else if (updates[i].flip_addr)
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 

commit 954815153b4b1213237d389be15d5448f67154ff
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Mon Jan 23 17:51:17 2017 -0500

    drm/amd/display: enable color gamma programming
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 01d614781def..c627b907528c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1498,9 +1498,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			}
 		}
 
-		if (dc->debug.disable_color_module)
-			continue;  /* skip below color updates */
-
 		if (updates[i].gamma &&
 			updates[i].gamma != surface->public.gamma_correction) {
 			if (surface->public.gamma_correction != NULL)
@@ -1579,9 +1576,6 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			if (cur_pipe_ctx->surface == pipe_ctx->surface)
 				is_new_pipe_surface = false;
 
-			if (dc->debug.disable_color_module)
-				continue;  /* skip below color updates */
-
 			if (is_new_pipe_surface ||
 					updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(

commit ed1519403227490d517c2d59755d68d3c31afa12
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Jan 23 17:10:04 2017 -0500

    drm/amd/display: Fixed 4K black issue by refactor update surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 170936bb378a..01d614781def 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1482,17 +1482,19 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 		}
 
 		/* not sure if we still need this */
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
-			struct core_stream *stream = pipe_ctx->stream;
+		if (update_type == UPDATE_TYPE_FULL) {
+			for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+				struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+				struct core_stream *stream = pipe_ctx->stream;
 
-			if (pipe_ctx->surface != surface)
-				continue;
+				if (pipe_ctx->surface != surface)
+					continue;
 
-			resource_build_scaling_params(updates[i].surface, pipe_ctx);
-			if (dc->debug.surface_visual_confirm) {
-				pipe_ctx->scl_data.recout.height -= 2;
-				pipe_ctx->scl_data.recout.width -= 2;
+				resource_build_scaling_params(updates[i].surface, pipe_ctx);
+				if (dc->debug.surface_visual_confirm) {
+					pipe_ctx->scl_data.recout.height -= 2;
+					pipe_ctx->scl_data.recout.width -= 2;
+				}
 			}
 		}
 
@@ -1563,10 +1565,12 @@ void dc_update_surfaces_for_stream(struct dc *dc,
 			}
 
 			if (update_type == UPDATE_TYPE_FULL) {
-				core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
-			} else if (updates[i].flip_addr) {
+				/* only apply for top pipe */
+				if (!pipe_ctx->top_pipe)
+					core_dc->hwss.apply_ctx_for_surface(core_dc,
+							 surface, context);
+			} else if (updates[i].flip_addr)
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-			}
 
 			if (update_type == UPDATE_TYPE_FAST)
 				continue;

commit e72f0acd369d3ddfa6e924279d4010bcdb3de31b
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Jan 19 23:57:09 2017 -0500

    drm/amd/display: refactor dc_update_surfaces_for_stream
    
    - reuse existing helper functions
    - helper function to make it more obvious which cases we can do optimize programming
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index de6ef8713ea8..170936bb378a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1007,7 +1007,7 @@ bool dc_commit_streams(
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
-	struct dc_validation_set set[MAX_STREAMS] = { 0 };
+	struct dc_validation_set set[MAX_STREAMS] = { {0, {0} } };
 	int i, j, k;
 
 	if (false == streams_changed(core_dc, streams, stream_count))
@@ -1321,80 +1321,167 @@ bool dc_commit_surfaces_to_stream(
 	return dc_post_update_surfaces_to_stream(dc);
 }
 
-void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *updates,
-		int surface_count, const struct dc_stream *dc_stream)
+static bool is_surface_in_context(
+		const struct validate_context *context,
+		const struct dc_surface *surface)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct validate_context *context = core_dc->temp_flip_context;
-	int i, j;
-	bool is_new_pipe_surface[MAX_PIPES];
-	const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
-	bool need_apply_clk_constraints = false;
-	bool can_skip_context_building = true;
+	int j;
 
-	update_surface_trace(dc, updates, surface_count);
+	for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+		const struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-	*context = *core_dc->current_context;
+		if (surface == &pipe_ctx->surface->public) {
+			return true;
+		}
+	}
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
-		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+	return false;
+}
 
-		if (cur_pipe->top_pipe)
-			cur_pipe->top_pipe =
-				&context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+enum surface_update_type {
+	UPDATE_TYPE_FAST, /* super fast, safe to execute in isr */
+	UPDATE_TYPE_MED,  /* a lot of programming needed.  may need to alloc */
+	UPDATE_TYPE_FULL, /* may need to shuffle resources */
+};
 
-		if (cur_pipe->bottom_pipe)
-			cur_pipe->bottom_pipe =
-				&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
-	}
+static enum surface_update_type det_surface_update(
+		const struct core_dc *dc,
+		const struct dc_surface_update *u)
+{
+	const struct validate_context *context = dc->current_context;
 
-	for (j = 0; j < MAX_PIPES; j++)
-		is_new_pipe_surface[j] = true;
+	if (u->scaling_info || u->plane_info)
+		/* todo: not all scale and plane_info update need full update
+		 * ie. check if following is the same
+		 * scale ratio, view port, surface bpp etc
+		 */
+		return UPDATE_TYPE_FULL; /* may need bandwidth update */
 
-	for (i = 0 ; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
-		bool existing_surface = false;
+	if (!is_surface_in_context(context, u->surface))
+		return UPDATE_TYPE_FULL;
 
-		new_surfaces[i] = updates[i].surface;
+	if (u->in_transfer_func ||
+		u->out_transfer_func ||
+		u->hdr_static_metadata)
+		return UPDATE_TYPE_MED;
 
-		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+	return UPDATE_TYPE_FAST;
+}
 
-			if (surface == pipe_ctx->surface) {
-				existing_surface = true;
-				is_new_pipe_surface[j] = false;
-			}
-		}
+static enum surface_update_type check_update_surfaces_for_stream(
+		struct core_dc *dc,
+		struct dc_surface_update *updates,
+		int surface_count,
+		const struct dc_stream_status *stream_status)
+{
+	int i;
+	enum surface_update_type overall_type = UPDATE_TYPE_FAST;
 
-		if (updates[i].plane_info ||
-			updates[i].scaling_info ||
-			!existing_surface)
-			can_skip_context_building = false;
+	if (stream_status->surface_count != surface_count)
+		return UPDATE_TYPE_FULL;
+
+	for (i = 0 ; i < surface_count; i++) {
+		enum surface_update_type type =
+				det_surface_update(dc, &updates[i]);
+
+		if (type == UPDATE_TYPE_FULL)
+			return type;
+
+		if (overall_type < type)
+			overall_type = type;
 	}
 
-	if (!can_skip_context_building && dc_stream) {
-		const struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	return overall_type;
+}
 
-		if (core_dc->current_context->stream_count == 0)
-			return;
+enum surface_update_type update_surface_trace_level = UPDATE_TYPE_FULL;
 
-		/* Cannot commit surface to a stream that is not commited */
-		for (i = 0; i < core_dc->current_context->stream_count; i++)
-			if (stream == core_dc->current_context->streams[i])
-				break;
-		if (i == core_dc->current_context->stream_count)
-			return;
+void dc_update_surfaces_for_stream(struct dc *dc,
+		struct dc_surface_update *updates, int surface_count,
+		const struct dc_stream *dc_stream)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *context;
+	int i, j;
+
+	enum surface_update_type update_type;
+	const struct dc_stream_status *stream_status;
+
+	stream_status = dc_stream_get_status(dc_stream);
+	ASSERT(stream_status);
+	if (!stream_status)
+		return; /* Cannot commit surface to stream that is not committed */
+
+	update_type = check_update_surfaces_for_stream(
+			core_dc, updates, surface_count, stream_status);
+
+	if (update_type >= update_surface_trace_level)
+		update_surface_trace(dc, updates, surface_count);
 
+	if (update_type >= UPDATE_TYPE_FULL) {
+		const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
+
+		for (i = 0; i < surface_count; i++)
+			new_surfaces[i] = updates[i].surface;
+
+		/* initialize scratch memory for building context */
+		context = core_dc->temp_flip_context;
+		resource_validate_ctx_copy_construct(
+				core_dc->current_context, context);
+
+		/* add surface to context */
 		if (!resource_attach_surfaces_to_context(
 				new_surfaces, surface_count, dc_stream, context)) {
 			BREAK_TO_DEBUGGER();
 			return;
 		}
+	} else {
+		context = core_dc->current_context;
 	}
-
 	for (i = 0; i < surface_count; i++) {
+		/* save update param into surface */
 		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+		struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
+		if (updates[i].flip_addr) {
+			surface->public.address = updates[i].flip_addr->address;
+			surface->public.flip_immediate =
+					updates[i].flip_addr->flip_immediate;
+		}
+
+		if (updates[i].scaling_info) {
+			surface->public.scaling_quality =
+					updates[i].scaling_info->scaling_quality;
+			surface->public.dst_rect =
+					updates[i].scaling_info->dst_rect;
+			surface->public.src_rect =
+					updates[i].scaling_info->src_rect;
+			surface->public.clip_rect =
+					updates[i].scaling_info->clip_rect;
+		}
+
+		if (updates[i].plane_info) {
+			surface->public.color_space =
+					updates[i].plane_info->color_space;
+			surface->public.format =
+					updates[i].plane_info->format;
+			surface->public.plane_size =
+					updates[i].plane_info->plane_size;
+			surface->public.rotation =
+					updates[i].plane_info->rotation;
+			surface->public.horizontal_mirror =
+					updates[i].plane_info->horizontal_mirror;
+			surface->public.stereo_format =
+					updates[i].plane_info->stereo_format;
+			surface->public.tiling_info =
+					updates[i].plane_info->tiling_info;
+			surface->public.visible =
+					updates[i].plane_info->visible;
+			surface->public.dcc =
+					updates[i].plane_info->dcc;
+		}
+
+		/* not sure if we still need this */
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 			struct core_stream *stream = pipe_ctx->stream;
@@ -1402,133 +1489,101 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 			if (pipe_ctx->surface != surface)
 				continue;
 
-			if (updates[i].flip_addr) {
-				surface->public.address = updates[i].flip_addr->address;
-				surface->public.flip_immediate =
-						updates[i].flip_addr->flip_immediate;
-			}
-
-			if (updates[i].plane_info || updates[i].scaling_info
-					|| is_new_pipe_surface[j]) {
-				need_apply_clk_constraints = true;
-
-				if (updates[i].plane_info) {
-					surface->public.color_space =
-						updates[i].plane_info->color_space;
-					surface->public.format =
-						updates[i].plane_info->format;
-					surface->public.plane_size =
-						updates[i].plane_info->plane_size;
-					surface->public.rotation =
-						updates[i].plane_info->rotation;
-					surface->public.horizontal_mirror =
-						updates[i].plane_info->horizontal_mirror;
-					surface->public.stereo_format =
-						updates[i].plane_info->stereo_format;
-					surface->public.tiling_info =
-						updates[i].plane_info->tiling_info;
-					surface->public.visible =
-						updates[i].plane_info->visible;
-					surface->public.dcc =
-						updates[i].plane_info->dcc;
-				}
-
-				if (updates[i].scaling_info) {
-					surface->public.scaling_quality =
-						updates[i].scaling_info->scaling_quality;
-					surface->public.dst_rect =
-						updates[i].scaling_info->dst_rect;
-					surface->public.src_rect =
-						updates[i].scaling_info->src_rect;
-					surface->public.clip_rect =
-						updates[i].scaling_info->clip_rect;
-				}
-
-				resource_build_scaling_params(updates[i].surface, pipe_ctx);
-				if (dc->debug.surface_visual_confirm) {
-					pipe_ctx->scl_data.recout.height -= 2;
-					pipe_ctx->scl_data.recout.width -= 2;
-				}
+			resource_build_scaling_params(updates[i].surface, pipe_ctx);
+			if (dc->debug.surface_visual_confirm) {
+				pipe_ctx->scl_data.recout.height -= 2;
+				pipe_ctx->scl_data.recout.width -= 2;
 			}
+		}
 
-			if (dc->debug.disable_color_module)
-				continue;  /* skip below color updates */
+		if (dc->debug.disable_color_module)
+			continue;  /* skip below color updates */
 
-			if (updates[i].gamma &&
-				updates[i].gamma != surface->public.gamma_correction) {
-				if (surface->public.gamma_correction != NULL)
-					dc_gamma_release(&surface->public.
-							gamma_correction);
+		if (updates[i].gamma &&
+			updates[i].gamma != surface->public.gamma_correction) {
+			if (surface->public.gamma_correction != NULL)
+				dc_gamma_release(&surface->public.
+						gamma_correction);
 
-				dc_gamma_retain(updates[i].gamma);
-				surface->public.gamma_correction =
-							updates[i].gamma;
-			}
+			dc_gamma_retain(updates[i].gamma);
+			surface->public.gamma_correction =
+						updates[i].gamma;
+		}
 
-			if (updates[i].in_transfer_func &&
-				updates[i].in_transfer_func != surface->public.in_transfer_func) {
-				if (surface->public.in_transfer_func != NULL)
-					dc_transfer_func_release(
-							surface->public.
-							in_transfer_func);
-
-				dc_transfer_func_retain(
-						updates[i].in_transfer_func);
-				surface->public.in_transfer_func =
-						updates[i].in_transfer_func;
-			}
+		if (updates[i].in_transfer_func &&
+			updates[i].in_transfer_func != surface->public.in_transfer_func) {
+			if (surface->public.in_transfer_func != NULL)
+				dc_transfer_func_release(
+						surface->public.
+						in_transfer_func);
+
+			dc_transfer_func_retain(
+					updates[i].in_transfer_func);
+			surface->public.in_transfer_func =
+					updates[i].in_transfer_func;
+		}
 
-			if (updates[i].out_transfer_func &&
-				updates[i].out_transfer_func != stream->public.out_transfer_func) {
-				if (stream->public.out_transfer_func != NULL)
-					dc_transfer_func_release(
-							stream->public.
-							out_transfer_func);
-				dc_transfer_func_retain(
-						updates[i].out_transfer_func);
-				stream->public.out_transfer_func =
-						updates[i].out_transfer_func;
-			}
-			if (updates[i].hdr_static_metadata)
-				surface->public.hdr_static_ctx =
-					*(updates[i].hdr_static_metadata);
+		if (updates[i].out_transfer_func &&
+			updates[i].out_transfer_func != dc_stream->out_transfer_func) {
+			if (dc_stream->out_transfer_func != NULL)
+				dc_transfer_func_release(dc_stream->out_transfer_func);
+			dc_transfer_func_retain(updates[i].out_transfer_func);
+			stream->public.out_transfer_func = updates[i].out_transfer_func;
 		}
+		if (updates[i].hdr_static_metadata)
+			surface->public.hdr_static_ctx =
+				*(updates[i].hdr_static_metadata);
 	}
 
+
+	if (!surface_count)  /* reset */
+		core_dc->hwss.apply_ctx_for_surface(core_dc, NULL, context);
+
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+			struct pipe_ctx *cur_pipe_ctx;
+			bool is_new_pipe_surface = true;
 
 			if (pipe_ctx->surface != surface)
 				continue;
 
-			if (updates[i].flip_addr && can_skip_context_building) {
-				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-			} else {
+			if (update_type != UPDATE_TYPE_FAST &&
+				!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
+				core_dc->hwss.pipe_control_lock(
+						core_dc->hwseq,
+						pipe_ctx->pipe_idx,
+						PIPE_LOCK_CONTROL_GRAPHICS |
+						PIPE_LOCK_CONTROL_SCL |
+						PIPE_LOCK_CONTROL_BLENDER |
+						PIPE_LOCK_CONTROL_MODE,
+						true);
+			}
 
-				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
-					core_dc->hwss.pipe_control_lock(
-							core_dc->hwseq,
-							pipe_ctx->pipe_idx,
-							PIPE_LOCK_CONTROL_GRAPHICS |
-							PIPE_LOCK_CONTROL_SCL |
-							PIPE_LOCK_CONTROL_BLENDER |
-							PIPE_LOCK_CONTROL_MODE,
-							true);
-				}
+			if (update_type == UPDATE_TYPE_FULL) {
+				core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+			} else if (updates[i].flip_addr) {
+				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 			}
 
+			if (update_type == UPDATE_TYPE_FAST)
+				continue;
+
+			cur_pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
+			if (cur_pipe_ctx->surface == pipe_ctx->surface)
+				is_new_pipe_surface = false;
+
 			if (dc->debug.disable_color_module)
 				continue;  /* skip below color updates */
 
-			if (is_new_pipe_surface[j] ||
+			if (is_new_pipe_surface ||
 					updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 
-			if (is_new_pipe_surface[j] ||
+			if (is_new_pipe_surface ||
 					updates[i].out_transfer_func)
 				core_dc->hwss.set_output_transfer_func(
 						pipe_ctx,
@@ -1539,14 +1594,12 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 				resource_build_info_frame(pipe_ctx);
 				core_dc->hwss.update_info_frame(pipe_ctx);
 			}
-
-		}
-		if (!can_skip_context_building) {
-			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
-			context_timing_trace(dc, &context->res_ctx);
 		}
 	}
 
+	if (update_type == UPDATE_TYPE_FAST)
+		return;
+
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
@@ -1566,8 +1619,12 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 		}
 	}
 
-	core_dc->temp_flip_context = core_dc->current_context;
-	core_dc->current_context = context;
+	if (core_dc->current_context != context) {
+		resource_validate_ctx_destruct(core_dc->current_context);
+		core_dc->temp_flip_context = core_dc->current_context;
+
+		core_dc->current_context = context;
+	}
 }
 
 uint8_t dc_get_current_stream_count(const struct dc *dc)

commit dcbd4ee0fabcc1f6a40d67e8a8621e9ac5a382ac
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Jan 19 10:53:58 2017 -0500

    drm/amd/display: Change update surface condition, fix surface transition corruption.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 270f8c5cfeda..de6ef8713ea8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1497,7 +1497,6 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
-		bool apply_ctx = false;
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
@@ -1505,13 +1504,9 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 			if (pipe_ctx->surface != surface)
 				continue;
 
-			if (updates[i].flip_addr) {
+			if (updates[i].flip_addr && can_skip_context_building) {
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
-			}
-
-			if (updates[i].plane_info || updates[i].scaling_info
-					|| is_new_pipe_surface[j]) {
-				apply_ctx = true;
+			} else {
 
 				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
 					core_dc->hwss.pipe_control_lock(
@@ -1546,7 +1541,7 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 			}
 
 		}
-		if (apply_ctx) {
+		if (!can_skip_context_building) {
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
 			context_timing_trace(dc, &context->res_ctx);
 		}

commit f0e3db90a6fbee4acc921a4912a3e3460efb5cc0
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jan 23 11:49:24 2017 -0500

    drm/amd/display: Don't reserve pipe for underlay on ASIC without underlay
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f9b7fc85d71a..270f8c5cfeda 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -621,7 +621,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	core_dc->hwss.init_hw(core_dc);
 
 	full_pipe_count = core_dc->res_pool->pipe_count;
-	if (core_dc->res_pool->underlay_pipe_index >= 0)
+	if (core_dc->res_pool->underlay_pipe_index != NO_UNDERLAY_PIPE)
 		full_pipe_count--;
 	core_dc->public.caps.max_streams = min(
 			full_pipe_count,

commit adc9b14139de00b9fe016acc901a5fcf50145008
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Jan 17 17:40:13 2017 -0500

    drm/amd/display: add missing dcc update on flip call
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9deddc8ee2d1..f9b7fc85d71a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1429,6 +1429,8 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 						updates[i].plane_info->tiling_info;
 					surface->public.visible =
 						updates[i].plane_info->visible;
+					surface->public.dcc =
+						updates[i].plane_info->dcc;
 				}
 
 				if (updates[i].scaling_info) {

commit f84a8161cb1652281746d113667427dbbf8bd5db
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Jan 12 23:18:33 2017 -0500

    drm/amd/display: mode change without breaking unaffected streams
    
    - include clock constraint logic in validate
    - in dc_commit_streams, include surfaces of unaffected streams
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 948f82a56472..9deddc8ee2d1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1007,7 +1007,7 @@ bool dc_commit_streams(
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
-	struct dc_validation_set set[MAX_STREAMS];
+	struct dc_validation_set set[MAX_STREAMS] = { 0 };
 	int i, j, k;
 
 	if (false == streams_changed(core_dc, streams, stream_count))
@@ -1018,13 +1018,20 @@ bool dc_commit_streams(
 
 	for (i = 0; i < stream_count; i++) {
 		const struct dc_stream *stream = streams[i];
+		const struct dc_stream_status *status = dc_stream_get_status(stream);
+		int j;
 
 		dc_stream_log(stream,
 				core_dc->ctx->logger,
 				LOG_DC);
 
 		set[i].stream = stream;
-		set[i].surface_count = 0;
+
+		if (status) {
+			set[i].surface_count = status->surface_count;
+			for (j = 0; j < status->surface_count; j++)
+				set[i].surfaces[j] = status->surfaces[j];
+		}
 
 	}
 

commit fcd2f4bf8bbe73ac860d1be275a22a54a8d8d385
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Thu Jan 5 17:12:20 2017 -0500

    drm/amd/display: Output Transfer Function Regamma Refactor
    
    - Create translation function to translate logical format to hw format
    - Refactor to use transfer function in dc instead of input gamma
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 7d4299b9ee1f..948f82a56472 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1519,23 +1519,23 @@ void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *upda
 			if (dc->debug.disable_color_module)
 				continue;  /* skip below color updates */
 
-			if (updates[i].hdr_static_metadata) {
-				resource_build_info_frame(pipe_ctx);
-				core_dc->hwss.update_info_frame(pipe_ctx);
-			}
 			if (is_new_pipe_surface[j] ||
 					updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(
 						pipe_ctx, pipe_ctx->surface);
 
 			if (is_new_pipe_surface[j] ||
-					updates[i].gamma ||
 					updates[i].out_transfer_func)
 				core_dc->hwss.set_output_transfer_func(
 						pipe_ctx,
 						pipe_ctx->surface,
 						pipe_ctx->stream);
 
+			if (updates[i].hdr_static_metadata) {
+				resource_build_info_frame(pipe_ctx);
+				core_dc->hwss.update_info_frame(pipe_ctx);
+			}
+
 		}
 		if (apply_ctx) {
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);

commit ab2541b67395088b9de8ebf3943ef9ef86bccc41
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Thu Dec 29 15:27:12 2016 -0500

    drm/amd/display: Remove dc_target object
    
    dc_target does not fit well into DRM framework so removed it.
    This will prevent the driver from leveraging the pipe-split
    code for tiled displays, so will have to be handled at a higher
    level.  Most places that used dc_target now directly use dc_stream
    instead.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a7348573ebca..7d4299b9ee1f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -49,15 +49,6 @@
 #include "dm_helpers.h"
 #include "mem_input.h"
 
-/*******************************************************************************
- * Private structures
- ******************************************************************************/
-
-struct dc_target_sync_report {
-	uint32_t h_count;
-	uint32_t v_count;
-};
-
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
@@ -221,7 +212,7 @@ static void stream_update_scaling(
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *cur_ctx = core_dc->current_context;
-	int i, j;
+	int i;
 
 	if (src)
 		stream->public.src = *src;
@@ -229,20 +220,18 @@ static void stream_update_scaling(
 	if (dst)
 		stream->public.dst = *dst;
 
-	for (i = 0; i < cur_ctx->target_count; i++) {
-		struct core_target *target = cur_ctx->targets[i];
-		struct dc_target_status *status = &cur_ctx->target_status[i];
+	for (i = 0; i < cur_ctx->stream_count; i++) {
+		struct core_stream *cur_stream = cur_ctx->streams[i];
 
-		for (j = 0; j < target->public.stream_count; j++) {
-			if (target->public.streams[j] != dc_stream)
-				continue;
+		if (stream == cur_stream) {
+			struct dc_stream_status *status = &cur_ctx->stream_status[i];
 
 			if (status->surface_count)
-				if (!dc_commit_surfaces_to_target(
+				if (!dc_commit_surfaces_to_stream(
 						&core_dc->public,
 						status->surfaces,
 						status->surface_count,
-						&target->public))
+						&cur_stream->public))
 					/* Need to debug validation */
 					BREAK_TO_DEBUGGER();
 
@@ -634,7 +623,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	full_pipe_count = core_dc->res_pool->pipe_count;
 	if (core_dc->res_pool->underlay_pipe_index >= 0)
 		full_pipe_count--;
-	core_dc->public.caps.max_targets = min(
+	core_dc->public.caps.max_streams = min(
 			full_pipe_count,
 			core_dc->res_pool->stream_enc_count);
 
@@ -675,20 +664,20 @@ static bool is_validation_required(
 	const struct validate_context *context = dc->current_context;
 	int i, j;
 
-	if (context->target_count != set_count)
+	if (context->stream_count != set_count)
 		return true;
 
 	for (i = 0; i < set_count; i++) {
 
-		if (set[i].surface_count != context->target_status[i].surface_count)
+		if (set[i].surface_count != context->stream_status[i].surface_count)
 			return true;
-		if (!is_target_unchanged(DC_TARGET_TO_CORE(set[i].target), context->targets[i]))
+		if (!is_stream_unchanged(DC_STREAM_TO_CORE(set[i].stream), context->streams[i]))
 			return true;
 
 		for (j = 0; j < set[i].surface_count; j++) {
 			struct dc_surface temp_surf = { 0 };
 
-			temp_surf = *context->target_status[i].surfaces[j];
+			temp_surf = *context->stream_status[i].surfaces[j];
 			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
 			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
 			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
@@ -737,7 +726,7 @@ bool dc_validate_resources(
 
 bool dc_validate_guaranteed(
 		const struct dc *dc,
-		const struct dc_target *dc_target)
+		const struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -748,7 +737,7 @@ bool dc_validate_guaranteed(
 		goto context_alloc_fail;
 
 	result = core_dc->res_pool->funcs->validate_guaranteed(
-					core_dc, dc_target, context);
+					core_dc, stream, context);
 
 	resource_validate_ctx_destruct(context);
 	dm_free(context);
@@ -838,18 +827,18 @@ static void program_timing_sync(
 	}
 }
 
-static bool targets_changed(
+static bool streams_changed(
 		struct core_dc *dc,
-		struct dc_target *targets[],
-		uint8_t target_count)
+		const struct dc_stream *streams[],
+		uint8_t stream_count)
 {
 	uint8_t i;
 
-	if (target_count != dc->current_context->target_count)
+	if (stream_count != dc->current_context->stream_count)
 		return true;
 
-	for (i = 0; i < dc->current_context->target_count; i++) {
-		if (&dc->current_context->targets[i]->public != targets[i])
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (&dc->current_context->streams[i]->public != streams[i])
 			return true;
 	}
 
@@ -860,74 +849,72 @@ static void fill_display_configs(
 	const struct validate_context *context,
 	struct dm_pp_display_configuration *pp_display_cfg)
 {
-	uint8_t i, j, k;
-	uint8_t num_cfgs = 0;
-
-	for (i = 0; i < context->target_count; i++) {
-		const struct core_target *target = context->targets[i];
-
-		for (j = 0; j < target->public.stream_count; j++) {
-			const struct core_stream *stream =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
-			struct dm_pp_single_disp_config *cfg =
-					&pp_display_cfg->disp_configs[num_cfgs];
-			const struct pipe_ctx *pipe_ctx = NULL;
-
-			for (k = 0; k < MAX_PIPES; k++)
-				if (stream ==
-					context->res_ctx.pipe_ctx[k].stream) {
-					pipe_ctx = &context->res_ctx.pipe_ctx[k];
-					break;
-				}
+	int j;
+	int num_cfgs = 0;
 
-			ASSERT(pipe_ctx != NULL);
-
-			num_cfgs++;
-			cfg->signal = pipe_ctx->stream->signal;
-			cfg->pipe_idx = pipe_ctx->pipe_idx;
-			cfg->src_height = stream->public.src.height;
-			cfg->src_width = stream->public.src.width;
-			cfg->ddi_channel_mapping =
-				stream->sink->link->ddi_channel_mapping.raw;
-			cfg->transmitter =
-				stream->sink->link->link_enc->transmitter;
-			cfg->link_settings.lane_count = stream->sink->link->public.cur_link_settings.lane_count;
-			cfg->link_settings.link_rate = stream->sink->link->public.cur_link_settings.link_rate;
-			cfg->link_settings.link_spread = stream->sink->link->public.cur_link_settings.link_spread;
-			cfg->sym_clock = stream->phy_pix_clk;
-			/* Round v_refresh*/
-			cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
-			cfg->v_refresh /= stream->public.timing.h_total;
-			cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
-						/ stream->public.timing.v_total;
-		}
+	for (j = 0; j < context->stream_count; j++) {
+		int k;
+
+		const struct core_stream *stream = context->streams[j];
+		struct dm_pp_single_disp_config *cfg =
+			&pp_display_cfg->disp_configs[num_cfgs];
+		const struct pipe_ctx *pipe_ctx = NULL;
+
+		for (k = 0; k < MAX_PIPES; k++)
+			if (stream == context->res_ctx.pipe_ctx[k].stream) {
+				pipe_ctx = &context->res_ctx.pipe_ctx[k];
+				break;
+			}
+
+		ASSERT(pipe_ctx != NULL);
+
+		num_cfgs++;
+		cfg->signal = pipe_ctx->stream->signal;
+		cfg->pipe_idx = pipe_ctx->pipe_idx;
+		cfg->src_height = stream->public.src.height;
+		cfg->src_width = stream->public.src.width;
+		cfg->ddi_channel_mapping =
+			stream->sink->link->ddi_channel_mapping.raw;
+		cfg->transmitter =
+			stream->sink->link->link_enc->transmitter;
+		cfg->link_settings.lane_count =
+			stream->sink->link->public.cur_link_settings.lane_count;
+		cfg->link_settings.link_rate =
+			stream->sink->link->public.cur_link_settings.link_rate;
+		cfg->link_settings.link_spread =
+			stream->sink->link->public.cur_link_settings.link_spread;
+		cfg->sym_clock = stream->phy_pix_clk;
+		/* Round v_refresh*/
+		cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
+		cfg->v_refresh /= stream->public.timing.h_total;
+		cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
+							/ stream->public.timing.v_total;
 	}
+
 	pp_display_cfg->display_count = num_cfgs;
 }
 
 static uint32_t get_min_vblank_time_us(const struct validate_context *context)
 {
-	uint8_t i, j;
+	uint8_t j;
 	uint32_t min_vertical_blank_time = -1;
 
-	for (i = 0; i < context->target_count; i++) {
-		const struct core_target *target = context->targets[i];
-
-		for (j = 0; j < target->public.stream_count; j++) {
-			const struct dc_stream *stream =
-						target->public.streams[j];
+		for (j = 0; j < context->stream_count; j++) {
+			const struct dc_stream *stream = &context->streams[j]->public;
 			uint32_t vertical_blank_in_pixels = 0;
 			uint32_t vertical_blank_time = 0;
 
 			vertical_blank_in_pixels = stream->timing.h_total *
 				(stream->timing.v_total
 					- stream->timing.v_addressable);
+
 			vertical_blank_time = vertical_blank_in_pixels
 				* 1000 / stream->timing.pix_clk_khz;
+
 			if (min_vertical_blank_time > vertical_blank_time)
 				min_vertical_blank_time = vertical_blank_time;
 		}
-	}
+
 	return min_vertical_blank_time;
 }
 
@@ -995,7 +982,7 @@ void pplib_apply_display_requirements(
 	/* TODO: is this still applicable?*/
 	if (pp_display_cfg->display_count == 1) {
 		const struct dc_crtc_timing *timing =
-			&context->targets[0]->public.streams[0]->timing;
+			&context->streams[0]->public.timing;
 
 		pp_display_cfg->crtc_index =
 			pp_display_cfg->disp_configs[0].pipe_idx;
@@ -1011,34 +998,32 @@ void pplib_apply_display_requirements(
 
 }
 
-bool dc_commit_targets(
+bool dc_commit_streams(
 	struct dc *dc,
-	struct dc_target *targets[],
-	uint8_t target_count)
+	const struct dc_stream *streams[],
+	uint8_t stream_count)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_bios *dcb = core_dc->ctx->dc_bios;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	struct validate_context *context;
-	struct dc_validation_set set[MAX_TARGETS];
+	struct dc_validation_set set[MAX_STREAMS];
 	int i, j, k;
 
-	if (false == targets_changed(core_dc, targets, target_count))
+	if (false == streams_changed(core_dc, streams, stream_count))
 		return DC_OK;
 
-	dm_logger_write(core_dc->ctx->logger, LOG_DC,
-				"%s: %d targets\n",
-				__func__,
-				target_count);
+	dm_logger_write(core_dc->ctx->logger, LOG_DC, "%s: %d streams\n",
+				__func__, stream_count);
 
-	for (i = 0; i < target_count; i++) {
-		struct dc_target *target = targets[i];
+	for (i = 0; i < stream_count; i++) {
+		const struct dc_stream *stream = streams[i];
 
-		dc_target_log(target,
+		dc_stream_log(stream,
 				core_dc->ctx->logger,
 				LOG_DC);
 
-		set[i].target = targets[i];
+		set[i].stream = stream;
 		set[i].surface_count = 0;
 
 	}
@@ -1047,7 +1032,7 @@ bool dc_commit_targets(
 	if (context == NULL)
 		goto context_alloc_fail;
 
-	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set, target_count, context);
+	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set, stream_count, context);
 	if (result != DC_OK){
 		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
 					"%s: Context validation failed! dc_status:%d\n",
@@ -1068,13 +1053,12 @@ bool dc_commit_targets(
 
 	program_timing_sync(core_dc, context);
 
-	for (i = 0; i < context->target_count; i++) {
-		struct dc_target *dc_target = &context->targets[i]->public;
-		struct core_sink *sink = DC_SINK_TO_CORE(dc_target->streams[0]->sink);
+	for (i = 0; i < context->stream_count; i++) {
+		const struct core_sink *sink = context->streams[i]->sink;
 
-		for (j = 0; j < context->target_status[i].surface_count; j++) {
+		for (j = 0; j < context->stream_status[i].surface_count; j++) {
 			const struct dc_surface *dc_surface =
-					context->target_status[i].surfaces[j];
+					context->stream_status[i].surfaces[j];
 
 			for (k = 0; k < context->res_ctx.pool->pipe_count; k++) {
 				struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[k];
@@ -1088,11 +1072,11 @@ bool dc_commit_targets(
 		}
 
 		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
-				dc_target->streams[0]->timing.h_addressable,
-				dc_target->streams[0]->timing.v_addressable,
-				dc_target->streams[0]->timing.h_total,
-				dc_target->streams[0]->timing.v_total,
-				dc_target->streams[0]->timing.pix_clk_khz);
+				context->streams[i]->public.timing.h_addressable,
+				context->streams[i]->public.timing.v_addressable,
+				context->streams[i]->public.timing.h_total,
+				context->streams[i]->public.timing.v_total,
+				context->streams[i]->public.timing.pix_clk_khz);
 	}
 
 	pplib_apply_display_requirements(core_dc,
@@ -1116,43 +1100,42 @@ bool dc_commit_targets(
 	return (result == DC_OK);
 }
 
-bool dc_pre_update_surfaces_to_target(
+bool dc_pre_update_surfaces_to_stream(
 		struct dc *dc,
 		const struct dc_surface *const *new_surfaces,
 		uint8_t new_surface_count,
-		struct dc_target *dc_target)
+		const struct dc_stream *dc_stream)
 {
 	int i, j;
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
-	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
-	struct dc_target_status *target_status = NULL;
+	struct dc_stream_status *stream_status = NULL;
 	struct validate_context *context;
 	struct validate_context *temp_context;
 	bool ret = true;
 
 	pre_surface_trace(dc, new_surfaces, new_surface_count);
 
-	if (core_dc->current_context->target_count == 0)
+	if (core_dc->current_context->stream_count == 0)
 		return false;
 
-	/* Cannot commit surface to a target that is not commited */
-	for (i = 0; i < core_dc->current_context->target_count; i++)
-		if (target == core_dc->current_context->targets[i])
+	/* Cannot commit surface to a stream that is not commited */
+	for (i = 0; i < core_dc->current_context->stream_count; i++)
+		if (dc_stream == &core_dc->current_context->streams[i]->public)
 			break;
 
-	if (i == core_dc->current_context->target_count)
+	if (i == core_dc->current_context->stream_count)
 		return false;
 
-	target_status = &core_dc->current_context->target_status[i];
+	stream_status = &core_dc->current_context->stream_status[i];
 
-	if (new_surface_count == target_status->surface_count) {
+	if (new_surface_count == stream_status->surface_count) {
 		bool skip_pre = true;
 
-		for (i = 0; i < target_status->surface_count; i++) {
+		for (i = 0; i < stream_status->surface_count; i++) {
 			struct dc_surface temp_surf = { 0 };
 
-			temp_surf = *target_status->surfaces[i];
+			temp_surf = *stream_status->surfaces[i];
 			temp_surf.clip_rect = new_surfaces[i]->clip_rect;
 			temp_surf.dst_rect.x = new_surfaces[i]->dst_rect.x;
 			temp_surf.dst_rect.y = new_surfaces[i]->dst_rect.y;
@@ -1178,13 +1161,13 @@ bool dc_pre_update_surfaces_to_target(
 	resource_validate_ctx_copy_construct(core_dc->current_context, context);
 
 	dm_logger_write(core_dc->ctx->logger, LOG_DC,
-				"%s: commit %d surfaces to target 0x%x\n",
+				"%s: commit %d surfaces to stream 0x%x\n",
 				__func__,
 				new_surface_count,
-				dc_target);
+				dc_stream);
 
 	if (!resource_attach_surfaces_to_context(
-			new_surfaces, new_surface_count, dc_target, context)) {
+			new_surfaces, new_surface_count, dc_stream, context)) {
 		BREAK_TO_DEBUGGER();
 		ret = false;
 		goto unexpected_fail;
@@ -1256,7 +1239,7 @@ bool dc_pre_update_surfaces_to_target(
 	return ret;
 }
 
-bool dc_post_update_surfaces_to_target(struct dc *dc)
+bool dc_post_update_surfaces_to_stream(struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
@@ -1282,22 +1265,27 @@ bool dc_post_update_surfaces_to_target(struct dc *dc)
 	return true;
 }
 
-bool dc_commit_surfaces_to_target(
+bool dc_commit_surfaces_to_stream(
 		struct dc *dc,
 		const struct dc_surface **new_surfaces,
 		uint8_t new_surface_count,
-		struct dc_target *dc_target)
+		const struct dc_stream *dc_stream)
 {
-	struct dc_surface_update updates[MAX_SURFACES] = { 0 };
-	struct dc_flip_addrs flip_addr[MAX_SURFACES] = { 0 };
-	struct dc_plane_info plane_info[MAX_SURFACES] = { 0 };
-	struct dc_scaling_info scaling_info[MAX_SURFACES] = { 0 };
+	struct dc_surface_update updates[MAX_SURFACES];
+	struct dc_flip_addrs flip_addr[MAX_SURFACES];
+	struct dc_plane_info plane_info[MAX_SURFACES];
+	struct dc_scaling_info scaling_info[MAX_SURFACES];
 	int i;
 
-	if (!dc_pre_update_surfaces_to_target(
-			dc, new_surfaces, new_surface_count, dc_target))
+	if (!dc_pre_update_surfaces_to_stream(
+			dc, new_surfaces, new_surface_count, dc_stream))
 		return false;
 
+	memset(updates, 0, sizeof(updates));
+	memset(flip_addr, 0, sizeof(flip_addr));
+	memset(plane_info, 0, sizeof(plane_info));
+	memset(scaling_info, 0, sizeof(scaling_info));
+
 	for (i = 0; i < new_surface_count; i++) {
 		updates[i].surface = new_surfaces[i];
 		updates[i].gamma =
@@ -1321,13 +1309,13 @@ bool dc_commit_surfaces_to_target(
 		updates[i].plane_info = &plane_info[i];
 		updates[i].scaling_info = &scaling_info[i];
 	}
-	dc_update_surfaces_for_target(dc, updates, new_surface_count, dc_target);
+	dc_update_surfaces_for_stream(dc, updates, new_surface_count, dc_stream);
 
-	return dc_post_update_surfaces_to_target(dc);
+	return dc_post_update_surfaces_to_stream(dc);
 }
 
-void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *updates,
-		int surface_count, struct dc_target *dc_target)
+void dc_update_surfaces_for_stream(struct dc *dc, struct dc_surface_update *updates,
+		int surface_count, const struct dc_stream *dc_stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *context = core_dc->temp_flip_context;
@@ -1377,21 +1365,21 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			can_skip_context_building = false;
 	}
 
-	if (!can_skip_context_building && dc_target) {
-		struct core_target *target = DC_TARGET_TO_CORE(dc_target);
+	if (!can_skip_context_building && dc_stream) {
+		const struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
-		if (core_dc->current_context->target_count == 0)
+		if (core_dc->current_context->stream_count == 0)
 			return;
 
-		/* Cannot commit surface to a target that is not commited */
-		for (i = 0; i < core_dc->current_context->target_count; i++)
-			if (target == core_dc->current_context->targets[i])
+		/* Cannot commit surface to a stream that is not commited */
+		for (i = 0; i < core_dc->current_context->stream_count; i++)
+			if (stream == core_dc->current_context->streams[i])
 				break;
-		if (i == core_dc->current_context->target_count)
+		if (i == core_dc->current_context->stream_count)
 			return;
 
 		if (!resource_attach_surfaces_to_context(
-				new_surfaces, surface_count, dc_target, context)) {
+				new_surfaces, surface_count, dc_stream, context)) {
 			BREAK_TO_DEBUGGER();
 			return;
 		}
@@ -1578,17 +1566,17 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 	core_dc->current_context = context;
 }
 
-uint8_t dc_get_current_target_count(const struct dc *dc)
+uint8_t dc_get_current_stream_count(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	return core_dc->current_context->target_count;
+	return core_dc->current_context->stream_count;
 }
 
-struct dc_target *dc_get_target_at_index(const struct dc *dc, uint8_t i)
+struct dc_stream *dc_get_stream_at_index(const struct dc *dc, uint8_t i)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
-	if (i < core_dc->current_context->target_count)
-		return &(core_dc->current_context->targets[i]->public);
+	if (i < core_dc->current_context->stream_count)
+		return &(core_dc->current_context->streams[i]->public);
 	return NULL;
 }
 
@@ -1687,8 +1675,8 @@ void dc_set_power_state(
 		core_dc->hwss.init_hw(core_dc);
 		break;
 	default:
-		/* NULL means "reset/release all DC targets" */
-		dc_commit_targets(dc, NULL, 0);
+		/* NULL means "reset/release all DC streams" */
+		dc_commit_streams(dc, NULL, 0);
 
 		core_dc->hwss.power_down(core_dc);
 
@@ -1882,11 +1870,3 @@ void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink
 	}
 }
 
-const struct dc_stream_status *dc_stream_get_status(
-	const struct dc_stream *dc_stream)
-{
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
-
-	return &stream->status;
-}
-

commit 7d7024ca202c502324dce683f2061b35d113a6aa
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jan 10 08:35:47 2017 +1000

    drm/amd/display: drop min/max wrappers
    
    These aren't needed, and aren't really used in too many places.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 2277f9bf4bb1..a7348573ebca 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -634,7 +634,7 @@ struct dc *dc_create(const struct dc_init_data *init_params)
 	full_pipe_count = core_dc->res_pool->pipe_count;
 	if (core_dc->res_pool->underlay_pipe_index >= 0)
 		full_pipe_count--;
-	core_dc->public.caps.max_targets = dm_min(
+	core_dc->public.caps.max_targets = min(
 			full_pipe_count,
 			core_dc->res_pool->stream_enc_count);
 

commit b06b7680e341151c8c60b07ddc6f5e63e7392c17
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Thu Jan 5 17:47:43 2017 -0500

    drm/amd/display: blank mechanism for supporting MPO
    
    blank/unblanck functionality apply_ctx_for_surface will update planes visibility
    by manipulating Blender and CRTC HW modules.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 25e7d7bc282b..2277f9bf4bb1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1246,10 +1246,6 @@ bool dc_pre_update_surfaces_to_target(
 					core_dc,
 					&context->res_ctx.pipe_ctx[j],
 					context);
-
-			if (!new_surfaces[i]->visible)
-				context->res_ctx.pipe_ctx[j].tg->funcs->set_blank(
-						context->res_ctx.pipe_ctx[j].tg, true);
 		}
 
 unexpected_fail:

commit bf5cda339d3609408624afcb6f533f4eabc7d142
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Wed Jan 4 10:22:35 2017 -0500

    drm/amd/display: Fix DP PHY test pre-emphasis not set properly
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a7c6c980927e..25e7d7bc282b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -332,14 +332,21 @@ static bool setup_psr(struct dc *dc, const struct dc_stream *stream)
 }
 
 static void set_drive_settings(struct dc *dc,
-		struct link_training_settings *lt_settings)
+		struct link_training_settings *lt_settings,
+		const struct dc_link *link)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	int i;
 
-	for (i = 0; i < core_dc->link_count; i++)
-		dc_link_dp_set_drive_settings(&core_dc->links[i]->public,
-				lt_settings);
+	for (i = 0; i < core_dc->link_count; i++) {
+		if (&core_dc->links[i]->public == link)
+			break;
+	}
+
+	if (i >= core_dc->link_count)
+		ASSERT_CRITICAL(false);
+
+	dc_link_dp_set_drive_settings(&core_dc->links[i]->public, lt_settings);
 }
 
 static void perform_link_training(struct dc *dc,

commit 73c7260292db3f506b2562cbb25c06adfe90ca99
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Dec 29 14:58:54 2016 -0500

    drm/amd/display: Fix link retraining hw sequence for auto test
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index ad1ce600a165..a7c6c980927e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -366,9 +366,7 @@ static void set_preferred_link_settings(struct dc *dc,
 				link_setting->lane_count;
 	core_link->public.verified_link_cap.link_rate =
 				link_setting->link_rate;
-	dp_retrain_link_physi(core_link,
-			link_setting,
-			false);
+	dp_retrain_link_dp_test(core_link, link_setting, false);
 }
 
 static void enable_hpd(const struct dc_link *link)

commit 886391680cce3b7c4543b88bbd4eb49c80c26532
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Fri Dec 23 16:53:12 2016 -0500

    drm/amd/display: Fix link retraining hw sequence
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 69819d834543..ad1ce600a165 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -357,17 +357,18 @@ static void perform_link_training(struct dc *dc,
 }
 
 static void set_preferred_link_settings(struct dc *dc,
-		struct dc_link_settings *link_setting)
+		struct dc_link_settings *link_setting,
+		const struct dc_link *link)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	int i;
+	struct core_link *core_link = DC_LINK_TO_CORE(link);
 
-	for (i = 0; i < core_dc->link_count; i++) {
-		core_dc->links[i]->public.verified_link_cap.lane_count =
+	core_link->public.verified_link_cap.lane_count =
 				link_setting->lane_count;
-		core_dc->links[i]->public.verified_link_cap.link_rate =
+	core_link->public.verified_link_cap.link_rate =
 				link_setting->link_rate;
-	}
+	dp_retrain_link_physi(core_link,
+			link_setting,
+			false);
 }
 
 static void enable_hpd(const struct dc_link *link)

commit 649aa6f4fc40395153834ea78531e0cffd5ee49d
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Dec 23 11:08:43 2016 -0500

    drm/amd/display: enable option to disable HDR related updates.
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 12620df7056d..69819d834543 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1526,6 +1526,9 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				}
 			}
 
+			if (dc->debug.disable_color_module)
+				continue;  /* skip below color updates */
+
 			if (updates[i].hdr_static_metadata) {
 				resource_build_info_frame(pipe_ctx);
 				core_dc->hwss.update_info_frame(pipe_ctx);

commit aff20230b439921d6660eb2ef6d9f6c273d9b240
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 23 10:18:08 2016 -0500

    drm/amd/display: Set gamma to NULL at release
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index aca13d1cd4bb..12620df7056d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1458,7 +1458,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			if (updates[i].gamma &&
 				updates[i].gamma != surface->public.gamma_correction) {
 				if (surface->public.gamma_correction != NULL)
-					dc_gamma_release(surface->public.
+					dc_gamma_release(&surface->public.
 							gamma_correction);
 
 				dc_gamma_retain(updates[i].gamma);

commit e12078c56c24894b07cd3aae43788b90d6ea390e
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Dec 23 07:20:53 2016 -0500

    drm/amd/display: debug option to disable color module fucntionality
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e368d660362f..aca13d1cd4bb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1452,8 +1452,11 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				}
 			}
 
-			if (updates[i].gamma && updates[i].gamma !=
-				surface->public.gamma_correction) {
+			if (dc->debug.disable_color_module)
+				continue;  /* skip below color updates */
+
+			if (updates[i].gamma &&
+				updates[i].gamma != surface->public.gamma_correction) {
 				if (surface->public.gamma_correction != NULL)
 					dc_gamma_release(surface->public.
 							gamma_correction);
@@ -1464,8 +1467,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			}
 
 			if (updates[i].in_transfer_func &&
-					updates[i].in_transfer_func !=
-					surface->public.in_transfer_func) {
+				updates[i].in_transfer_func != surface->public.in_transfer_func) {
 				if (surface->public.in_transfer_func != NULL)
 					dc_transfer_func_release(
 							surface->public.
@@ -1478,8 +1480,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			}
 
 			if (updates[i].out_transfer_func &&
-					updates[i].out_transfer_func !=
-					stream->public.out_transfer_func) {
+				updates[i].out_transfer_func != stream->public.out_transfer_func) {
 				if (stream->public.out_transfer_func != NULL)
 					dc_transfer_func_release(
 							stream->public.

commit 1646a6fe746d7e923774994d2020e1707dcda884
Author: Andrew Wong <andrew.wong1@amd.com>
Date:   Thu Dec 22 15:41:30 2016 -0500

    drm/amd/display: DAL3: HDR10 Infoframe encoding
    
    - Add HDR metadata struct
    - Add register programming calculations
    - Added HDR metadata to surface and update_surface
    - Add HDR info packet programming for DP port
    
    Signed-off-by: Andrew Wong <andrew.wong1@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 5e60640df61b..e368d660362f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1489,6 +1489,9 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				stream->public.out_transfer_func =
 						updates[i].out_transfer_func;
 			}
+			if (updates[i].hdr_static_metadata)
+				surface->public.hdr_static_ctx =
+					*(updates[i].hdr_static_metadata);
 		}
 	}
 
@@ -1522,6 +1525,10 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				}
 			}
 
+			if (updates[i].hdr_static_metadata) {
+				resource_build_info_frame(pipe_ctx);
+				core_dc->hwss.update_info_frame(pipe_ctx);
+			}
 			if (is_new_pipe_surface[j] ||
 					updates[i].in_transfer_func)
 				core_dc->hwss.set_input_transfer_func(

commit 1c4e6bcefd0e70eae4f1145e334955b4b21ebb42
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Dec 22 10:48:19 2016 -0500

    drm/amd/display: Fixed split update bug.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index e6010abc9e0d..5e60640df61b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1333,6 +1333,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 	bool is_new_pipe_surface[MAX_PIPES];
 	const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
 	bool need_apply_clk_constraints = false;
+	bool can_skip_context_building = true;
 
 	update_surface_trace(dc, updates, surface_count);
 
@@ -1355,17 +1356,26 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 
 	for (i = 0 ; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+		bool existing_surface = false;
 
 		new_surfaces[i] = updates[i].surface;
+
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
-			if (surface == pipe_ctx->surface)
+			if (surface == pipe_ctx->surface) {
+				existing_surface = true;
 				is_new_pipe_surface[j] = false;
+			}
 		}
+
+		if (updates[i].plane_info ||
+			updates[i].scaling_info ||
+			!existing_surface)
+			can_skip_context_building = false;
 	}
 
-	if (dc_target) {
+	if (!can_skip_context_building && dc_target) {
 		struct core_target *target = DC_TARGET_TO_CORE(dc_target);
 
 		if (core_dc->current_context->target_count == 0)

commit 6680b6a1377f944e5369f456fe1b9d193dd4624b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Dec 21 16:48:51 2016 -0500

    drm/amd/display: Fixed crash
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 891075e39ecf..e6010abc9e0d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -167,24 +167,20 @@ static bool stream_adjust_vmin_vmax(struct dc *dc,
 	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
 	int i = 0;
 	bool ret = false;
-	struct pipe_ctx *pipes;
-	unsigned int underlay_idx = core_dc->res_pool->underlay_pipe_index;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == core_stream
-				&& i != underlay_idx) {
+		struct pipe_ctx *pipe = &core_dc->current_context->res_ctx.pipe_ctx[i];
 
-			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
-			core_dc->hwss.set_drr(&pipes, 1, vmin, vmax);
+		if (pipe->stream == core_stream && pipe->stream_enc) {
+			core_dc->hwss.set_drr(&pipe, 1, vmin, vmax);
 
 			/* build and update the info frame */
-			resource_build_info_frame(pipes);
-			core_dc->hwss.update_info_frame(pipes);
+			resource_build_info_frame(pipe);
+			core_dc->hwss.update_info_frame(pipe);
 
 			ret = true;
 		}
 	}
-
 	return ret;
 }
 

commit 1964cb736aaa094379d47aa1dc056a5531cecbd6
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 13 16:41:05 2016 +1000

    drm/amd/display: remove dc hub - this seems unused.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index df1bae8ea92b..891075e39ecf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1871,30 +1871,3 @@ const struct dc_stream_status *dc_stream_get_status(
 	return &stream->status;
 }
 
-bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
-{
-	int i;
-	struct core_dc *core_dc = DC_TO_CORE(dc);
-	struct mem_input *mi = NULL;
-
-	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
-		if (core_dc->res_pool->mis[i] != NULL) {
-			mi = core_dc->res_pool->mis[i];
-			break;
-		}
-	}
-	if (mi == NULL) {
-		dm_error("no mem_input!\n");
-		return false;
-	}
-
-	if (mi->funcs->mem_input_update_dchub)
-		mi->funcs->mem_input_update_dchub(mi, dh_data);
-	else
-		ASSERT(mi->funcs->mem_input_update_dchub);
-
-
-	return true;
-
-}
-

commit 90e508ba253c9e43711a7bf16230cdb13d0b1440
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Dec 15 12:09:46 2016 -0500

    drm/amd/display: Refactor output transfer function to stream
    
    Refactor part 3 - Moving output transfer function from surface to stream
    
    Split HWSS to program degamma and regamma separately.
    Degamma should be dependent on input transfer function.
    And Regamma should depend on the desired output transfer function.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f20701a507da..df1bae8ea92b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1394,6 +1394,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 
 		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+			struct core_stream *stream = pipe_ctx->stream;
 
 			if (pipe_ctx->surface != surface)
 				continue;
@@ -1472,15 +1473,14 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 
 			if (updates[i].out_transfer_func &&
 					updates[i].out_transfer_func !=
-					surface->public.out_transfer_func) {
-				if (surface->public.out_transfer_func != NULL)
+					stream->public.out_transfer_func) {
+				if (stream->public.out_transfer_func != NULL)
 					dc_transfer_func_release(
-							surface->public.
+							stream->public.
 							out_transfer_func);
-
 				dc_transfer_func_retain(
 						updates[i].out_transfer_func);
-				surface->public.out_transfer_func =
+				stream->public.out_transfer_func =
 						updates[i].out_transfer_func;
 			}
 		}
@@ -1516,12 +1516,19 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				}
 			}
 
+			if (is_new_pipe_surface[j] ||
+					updates[i].in_transfer_func)
+				core_dc->hwss.set_input_transfer_func(
+						pipe_ctx, pipe_ctx->surface);
+
 			if (is_new_pipe_surface[j] ||
 					updates[i].gamma ||
-					updates[i].in_transfer_func ||
 					updates[i].out_transfer_func)
-				core_dc->hwss.set_gamma_correction(
-						pipe_ctx, pipe_ctx->surface);
+				core_dc->hwss.set_output_transfer_func(
+						pipe_ctx,
+						pipe_ctx->surface,
+						pipe_ctx->stream);
+
 		}
 		if (apply_ctx) {
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);

commit fb735a9f29f94fcb29fee224b8da704a510a5a3a
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Dec 13 13:59:41 2016 -0500

    drm/amd/display: Add in/out transfer functions to DC
    
    Refactor part 1 of degamma/regamma programming.
    
    End goal is to have source and output transfer function in
    which dc can use to decide how to program the degamma
    and regamma HW.
    
    Gamma will be explicitly applied through
    dc_update_surfaces_for_target.
    
    Color module should build the logical curve with all
    adjustments applied and pass enough information
    for dc to program HW PWL.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 9a35e3bb8283..f20701a507da 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1455,6 +1455,34 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				surface->public.gamma_correction =
 							updates[i].gamma;
 			}
+
+			if (updates[i].in_transfer_func &&
+					updates[i].in_transfer_func !=
+					surface->public.in_transfer_func) {
+				if (surface->public.in_transfer_func != NULL)
+					dc_transfer_func_release(
+							surface->public.
+							in_transfer_func);
+
+				dc_transfer_func_retain(
+						updates[i].in_transfer_func);
+				surface->public.in_transfer_func =
+						updates[i].in_transfer_func;
+			}
+
+			if (updates[i].out_transfer_func &&
+					updates[i].out_transfer_func !=
+					surface->public.out_transfer_func) {
+				if (surface->public.out_transfer_func != NULL)
+					dc_transfer_func_release(
+							surface->public.
+							out_transfer_func);
+
+				dc_transfer_func_retain(
+						updates[i].out_transfer_func);
+				surface->public.out_transfer_func =
+						updates[i].out_transfer_func;
+			}
 		}
 	}
 
@@ -1474,7 +1502,6 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 
 			if (updates[i].plane_info || updates[i].scaling_info
 					|| is_new_pipe_surface[j]) {
-
 				apply_ctx = true;
 
 				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
@@ -1489,9 +1516,12 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				}
 			}
 
-			if (updates[i].gamma)
-				core_dc->hwss.prepare_pipe_for_context(
-						core_dc, pipe_ctx, context);
+			if (is_new_pipe_surface[j] ||
+					updates[i].gamma ||
+					updates[i].in_transfer_func ||
+					updates[i].out_transfer_func)
+				core_dc->hwss.set_gamma_correction(
+						pipe_ctx, pipe_ctx->surface);
 		}
 		if (apply_ctx) {
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);

commit 1e3d346f4fbb48f0a89134f4b834d3be2df3cc25
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Tue Dec 13 14:23:16 2016 -0600

    drm/amd/display: re gamma programming
    
    Fix gamma update logic to avoid crash
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 75b6e404d016..9a35e3bb8283 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1445,7 +1445,8 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				}
 			}
 
-			if (updates[i].gamma) {
+			if (updates[i].gamma && updates[i].gamma !=
+				surface->public.gamma_correction) {
 				if (surface->public.gamma_correction != NULL)
 					dc_gamma_release(surface->public.
 							gamma_correction);

commit 98d2cc2b03d937af36ce5ef227ae57232bbe8471
Author: Andrew Wong <andrew.wong1@amd.com>
Date:   Mon Dec 12 11:17:06 2016 -0500

    drm/amd/display: Change locking of registers when flipping frames.
    
    - Introduce GRPH_UPDATE_LOCK around programming surface flip.
    - Remove the now unused graphic surface lock.
    - Add macros to get and set four registers
    - both immediate and H Retrace should not be enabled at the same time
    
    Signed-off-by: Andrew Wong <andrew.wong1@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 41df500817ad..75b6e404d016 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1468,11 +1468,6 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				continue;
 
 			if (updates[i].flip_addr) {
-				core_dc->hwss.pipe_control_lock(
-							core_dc->hwseq,
-							pipe_ctx->pipe_idx,
-							PIPE_LOCK_CONTROL_SURFACE,
-							true);
 				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
 			}
 
@@ -1485,7 +1480,6 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 					core_dc->hwss.pipe_control_lock(
 							core_dc->hwseq,
 							pipe_ctx->pipe_idx,
-							PIPE_LOCK_CONTROL_SURFACE |
 							PIPE_LOCK_CONTROL_GRAPHICS |
 							PIPE_LOCK_CONTROL_SCL |
 							PIPE_LOCK_CONTROL_BLENDER |
@@ -1515,8 +1509,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 							pipe_ctx->pipe_idx,
 							PIPE_LOCK_CONTROL_GRAPHICS |
 							PIPE_LOCK_CONTROL_SCL |
-							PIPE_LOCK_CONTROL_BLENDER |
-							PIPE_LOCK_CONTROL_SURFACE,
+							PIPE_LOCK_CONTROL_BLENDER,
 							false);
 				}
 				break;

commit 89e8963036085e4e0e9a993d2e1bdbb931d53794
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Mon Dec 12 10:32:24 2016 -0500

    drm/amd/display: Fix Gamma Adjustment
    
    - Gamma correction is not properly copied to the surface after refactor
    - Make sure gamma correction is copied with correct retain
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index de99d71f9042..41df500817ad 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1302,8 +1302,8 @@ bool dc_commit_surfaces_to_target(
 
 	for (i = 0; i < new_surface_count; i++) {
 		updates[i].surface = new_surfaces[i];
-		updates[i].gamma = (struct dc_gamma *)new_surfaces[i]->gamma_correction;
-
+		updates[i].gamma =
+			(struct dc_gamma *)new_surfaces[i]->gamma_correction;
 		flip_addr[i].address = new_surfaces[i]->address;
 		flip_addr[i].flip_immediate = new_surfaces[i]->flip_immediate;
 		plane_info[i].color_space = new_surfaces[i]->color_space;
@@ -1444,6 +1444,16 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 					pipe_ctx->scl_data.recout.width -= 2;
 				}
 			}
+
+			if (updates[i].gamma) {
+				if (surface->public.gamma_correction != NULL)
+					dc_gamma_release(surface->public.
+							gamma_correction);
+
+				dc_gamma_retain(updates[i].gamma);
+				surface->public.gamma_correction =
+							updates[i].gamma;
+			}
 		}
 	}
 

commit 9474980ac470a20d244318db9a7c12be01437805
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Dec 8 09:47:11 2016 -0500

    drm/amd/display: Added timing sync trace.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 8e1d695fcb77..de99d71f9042 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1488,8 +1488,10 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				core_dc->hwss.prepare_pipe_for_context(
 						core_dc, pipe_ctx, context);
 		}
-		if (apply_ctx)
+		if (apply_ctx) {
 			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+			context_timing_trace(dc, &context->res_ctx);
+		}
 	}
 
 	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {

commit 5ea81b91857882bb5bfa883fb27671133957a96c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Dec 5 18:03:04 2016 -0500

    drm/amd/display: fix up construction of scratch_val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 522ef7047564..8e1d695fcb77 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -450,11 +450,6 @@ static void destruct(struct core_dc *dc)
 {
 	resource_validate_ctx_destruct(dc->current_context);
 
-	dm_free(dc->temp_flip_context);
-	dc->temp_flip_context = NULL;
-	dm_free(dc->scratch_val_ctx);
-	dc->scratch_val_ctx = NULL;
-
 	destroy_links(dc);
 
 	dc_destroy_resource_pool(dc);
@@ -473,6 +468,10 @@ static void destruct(struct core_dc *dc)
 
 	dm_free(dc->current_context);
 	dc->current_context = NULL;
+	dm_free(dc->temp_flip_context);
+	dc->temp_flip_context = NULL;
+	dm_free(dc->scratch_val_ctx);
+	dc->scratch_val_ctx = NULL;
 
 	dm_free(dc->ctx);
 	dc->ctx = NULL;
@@ -492,7 +491,7 @@ static bool construct(struct core_dc *dc,
 
 	dc->current_context = dm_alloc(sizeof(*dc->current_context));
 	dc->temp_flip_context = dm_alloc(sizeof(*dc->temp_flip_context));
-	dc->scratch_val_ctx = dm_alloc(sizeof(*dc->temp_flip_context));
+	dc->scratch_val_ctx = dm_alloc(sizeof(*dc->scratch_val_ctx));
 
 	if (!dc->current_context || !dc->temp_flip_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
@@ -1220,6 +1219,7 @@ bool dc_pre_update_surfaces_to_target(
 			goto unexpected_fail;
 		}
 		resource_validate_ctx_destruct(context);
+		ASSERT(core_dc->scratch_val_ctx == temp_context);
 		core_dc->scratch_val_ctx = context;
 		context = temp_context;
 	}

commit f4c07f88cc30e77d2431b5bcf95a05e0ee6f3482
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Dec 6 21:22:17 2016 -0500

    drm/amd/display: avoid apply_clk_constraints for address update
    
    - dc_update_surfaces_for_target get called in ISR but apply_clk_constraints allocates memory
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 70b7673993b2..522ef7047564 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1336,6 +1336,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 	int i, j;
 	bool is_new_pipe_surface[MAX_PIPES];
 	const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
+	bool need_apply_clk_constraints = false;
 
 	update_surface_trace(dc, updates, surface_count);
 
@@ -1405,6 +1406,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 
 			if (updates[i].plane_info || updates[i].scaling_info
 					|| is_new_pipe_surface[j]) {
+				need_apply_clk_constraints = true;
 
 				if (updates[i].plane_info) {
 					surface->public.color_space =

commit edbd58af6998217c5c1ab91cb6ca239c607cc9e0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Dec 6 22:12:09 2016 -0500

    drm/amd/display: fix indexing bug
    
    - is_new_pipe_surface should be addressed with pipe idx, not surface idx
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index a3c5def507a9..70b7673993b2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1334,7 +1334,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct validate_context *context = core_dc->temp_flip_context;
 	int i, j;
-	bool is_new_pipe_surface[MAX_SURFACES];
+	bool is_new_pipe_surface[MAX_PIPES];
 	const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
 
 	update_surface_trace(dc, updates, surface_count);
@@ -1353,7 +1353,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 				&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
 	}
 
-	for (j = 0; j < MAX_SURFACES; j++)
+	for (j = 0; j < MAX_PIPES; j++)
 		is_new_pipe_surface[j] = true;
 
 	for (i = 0 ; i < surface_count; i++) {
@@ -1364,7 +1364,7 @@ void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *upda
 			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
 
 			if (surface == pipe_ctx->surface)
-				is_new_pipe_surface[i] = false;
+				is_new_pipe_surface[j] = false;
 		}
 	}
 

commit 13625c7bf328c9e201363eba3c3e5a15560c4ae9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Nov 29 13:11:08 2016 -0500

    drm/amd/display: create scratch_val_ctx as temp w/a
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 70dc70685471..a3c5def507a9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -452,6 +452,8 @@ static void destruct(struct core_dc *dc)
 
 	dm_free(dc->temp_flip_context);
 	dc->temp_flip_context = NULL;
+	dm_free(dc->scratch_val_ctx);
+	dc->scratch_val_ctx = NULL;
 
 	destroy_links(dc);
 
@@ -490,6 +492,7 @@ static bool construct(struct core_dc *dc,
 
 	dc->current_context = dm_alloc(sizeof(*dc->current_context));
 	dc->temp_flip_context = dm_alloc(sizeof(*dc->temp_flip_context));
+	dc->scratch_val_ctx = dm_alloc(sizeof(*dc->temp_flip_context));
 
 	if (!dc->current_context || !dc->temp_flip_context) {
 		dm_error("%s: failed to create validate ctx\n", __func__);
@@ -1217,7 +1220,7 @@ bool dc_pre_update_surfaces_to_target(
 			goto unexpected_fail;
 		}
 		resource_validate_ctx_destruct(context);
-		dm_free(context);
+		core_dc->scratch_val_ctx = context;
 		context = temp_context;
 	}
 

commit 1a687574a71f187dedcab3ac6012b0889c5a4e99
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 10:49:51 2016 -0500

    drm/amd/display: restyle display clock calls part 1
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index 424a7d4b8731..70dc70685471 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1224,7 +1224,9 @@ bool dc_pre_update_surfaces_to_target(
 	if (prev_disp_clk < context->bw_results.dispclk_khz) {
 		pplib_apply_display_requirements(core_dc, context,
 						&context->pp_display_cfg);
-		core_dc->hwss.set_display_clock(context);
+		context->res_ctx.pool->display_clock->funcs->set_clock(
+				context->res_ctx.pool->display_clock,
+				context->bw_results.dispclk_khz * 115 / 100);
 		core_dc->current_context->bw_results.dispclk_khz =
 				context->bw_results.dispclk_khz;
 	}

commit ead964f24e111aa5ba6ec4c2ee15ae20f11a121a
Author: jimqu <Jim.Qu@amd.com>
Date:   Mon Nov 28 08:05:46 2016 +0800

    drm/amd/display: Fix memory corruption issue.
    
    temp_flip_context is always same as current_context,
    and the current_context will be freed in
    dc_commit_targets(), but  temp_flip_context will be used in
    dc_update_surfaces_for_target().
    
    Signed-off-by: JimQu <Jim.Qu@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
index f7638f84421b..424a7d4b8731 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1096,8 +1096,12 @@ bool dc_commit_targets(
 
 	resource_validate_ctx_destruct(core_dc->current_context);
 
-	dm_free(core_dc->current_context);
+	if (core_dc->temp_flip_context != core_dc->current_context) {
+		dm_free(core_dc->temp_flip_context);
+		core_dc->temp_flip_context = core_dc->current_context;
+	}
 	core_dc->current_context = context;
+	memset(core_dc->temp_flip_context, 0, sizeof(*core_dc->temp_flip_context));
 
 	return (result == DC_OK);
 

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc.c b/drivers/gpu/drm/amd/display/dc/core/dc.c
new file mode 100644
index 000000000000..f7638f84421b
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -0,0 +1,1846 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ */
+
+#include "dm_services.h"
+
+#include "dc.h"
+
+#include "core_status.h"
+#include "core_types.h"
+#include "hw_sequencer.h"
+
+#include "resource.h"
+
+#include "clock_source.h"
+#include "dc_bios_types.h"
+
+#include "bandwidth_calcs.h"
+#include "bios_parser_interface.h"
+#include "include/irq_service_interface.h"
+#include "transform.h"
+#include "timing_generator.h"
+#include "virtual/virtual_link_encoder.h"
+
+#include "link_hwss.h"
+#include "link_encoder.h"
+
+#include "dc_link_ddc.h"
+#include "dm_helpers.h"
+#include "mem_input.h"
+
+/*******************************************************************************
+ * Private structures
+ ******************************************************************************/
+
+struct dc_target_sync_report {
+	uint32_t h_count;
+	uint32_t v_count;
+};
+
+/*******************************************************************************
+ * Private functions
+ ******************************************************************************/
+static void destroy_links(struct core_dc *dc)
+{
+	uint32_t i;
+
+	for (i = 0; i < dc->link_count; i++) {
+		if (NULL != dc->links[i])
+			link_destroy(&dc->links[i]);
+	}
+}
+
+static bool create_links(
+		struct core_dc *dc,
+		uint32_t num_virtual_links)
+{
+	int i;
+	int connectors_num;
+	struct dc_bios *bios = dc->ctx->dc_bios;
+
+	dc->link_count = 0;
+
+	connectors_num = bios->funcs->get_connectors_number(bios);
+
+	if (connectors_num > ENUM_ID_COUNT) {
+		dm_error(
+			"DC: Number of connectors %d exceeds maximum of %d!\n",
+			connectors_num,
+			ENUM_ID_COUNT);
+		return false;
+	}
+
+	if (connectors_num == 0 && num_virtual_links == 0) {
+		dm_error("DC: Number of connectors is zero!\n");
+	}
+
+	dm_output_to_console(
+		"DC: %s: connectors_num: physical:%d, virtual:%d\n",
+		__func__,
+		connectors_num,
+		num_virtual_links);
+
+	for (i = 0; i < connectors_num; i++) {
+		struct link_init_data link_init_params = {0};
+		struct core_link *link;
+
+		link_init_params.ctx = dc->ctx;
+		link_init_params.connector_index = i;
+		link_init_params.link_index = dc->link_count;
+		link_init_params.dc = dc;
+		link = link_create(&link_init_params);
+
+		if (link) {
+			dc->links[dc->link_count] = link;
+			link->dc = dc;
+			++dc->link_count;
+		} else {
+			dm_error("DC: failed to create link!\n");
+		}
+	}
+
+	for (i = 0; i < num_virtual_links; i++) {
+		struct core_link *link = dm_alloc(sizeof(*link));
+		struct encoder_init_data enc_init = {0};
+
+		if (link == NULL) {
+			BREAK_TO_DEBUGGER();
+			goto failed_alloc;
+		}
+
+		link->ctx = dc->ctx;
+		link->dc = dc;
+		link->public.connector_signal = SIGNAL_TYPE_VIRTUAL;
+		link->link_id.type = OBJECT_TYPE_CONNECTOR;
+		link->link_id.id = CONNECTOR_ID_VIRTUAL;
+		link->link_id.enum_id = ENUM_ID_1;
+		link->link_enc = dm_alloc(sizeof(*link->link_enc));
+
+		enc_init.ctx = dc->ctx;
+		enc_init.channel = CHANNEL_ID_UNKNOWN;
+		enc_init.hpd_source = HPD_SOURCEID_UNKNOWN;
+		enc_init.transmitter = TRANSMITTER_UNKNOWN;
+		enc_init.connector = link->link_id;
+		enc_init.encoder.type = OBJECT_TYPE_ENCODER;
+		enc_init.encoder.id = ENCODER_ID_INTERNAL_VIRTUAL;
+		enc_init.encoder.enum_id = ENUM_ID_1;
+		virtual_link_encoder_construct(link->link_enc, &enc_init);
+
+		link->public.link_index = dc->link_count;
+		dc->links[dc->link_count] = link;
+		dc->link_count++;
+	}
+
+	return true;
+
+failed_alloc:
+	return false;
+}
+
+static bool stream_adjust_vmin_vmax(struct dc *dc,
+		const struct dc_stream **stream, int num_streams,
+		int vmin, int vmax)
+{
+	/* TODO: Support multiple streams */
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	int i = 0;
+	bool ret = false;
+	struct pipe_ctx *pipes;
+	unsigned int underlay_idx = core_dc->res_pool->underlay_pipe_index;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == core_stream
+				&& i != underlay_idx) {
+
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.set_drr(&pipes, 1, vmin, vmax);
+
+			/* build and update the info frame */
+			resource_build_info_frame(pipes);
+			core_dc->hwss.update_info_frame(pipes);
+
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
+
+static bool set_gamut_remap(struct dc *dc,
+			const struct dc_stream **stream, int num_streams)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream[0]);
+	int i = 0;
+	bool ret = false;
+	struct pipe_ctx *pipes;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
+				== core_stream) {
+
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.set_plane_config(core_dc, pipes,
+					&core_dc->current_context->res_ctx);
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
+/* This function is not expected to fail, proper implementation of
+ * validation will prevent this from ever being called for unsupported
+ * configurations.
+ */
+static void stream_update_scaling(
+		const struct dc *dc,
+		const struct dc_stream *dc_stream,
+		const struct rect *src,
+		const struct rect *dst)
+{
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *cur_ctx = core_dc->current_context;
+	int i, j;
+
+	if (src)
+		stream->public.src = *src;
+
+	if (dst)
+		stream->public.dst = *dst;
+
+	for (i = 0; i < cur_ctx->target_count; i++) {
+		struct core_target *target = cur_ctx->targets[i];
+		struct dc_target_status *status = &cur_ctx->target_status[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			if (target->public.streams[j] != dc_stream)
+				continue;
+
+			if (status->surface_count)
+				if (!dc_commit_surfaces_to_target(
+						&core_dc->public,
+						status->surfaces,
+						status->surface_count,
+						&target->public))
+					/* Need to debug validation */
+					BREAK_TO_DEBUGGER();
+
+			return;
+		}
+	}
+}
+
+static bool set_backlight(struct dc *dc, unsigned int backlight_level,
+			unsigned int frame_ramp, const struct dc_stream *stream)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	if (stream->sink->sink_signal == SIGNAL_TYPE_EDP) {
+		for (i = 0; i < core_dc->link_count; i++)
+			dc_link_set_backlight_level(&core_dc->links[i]->public,
+					backlight_level, frame_ramp, stream);
+	}
+
+	return true;
+
+}
+
+static bool init_dmcu_backlight_settings(struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_init_dmcu_backlight_settings
+			(&core_dc->links[i]->public);
+
+	return true;
+}
+
+
+static bool set_abm_level(struct dc *dc, unsigned int abm_level)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_set_abm_level(&core_dc->links[i]->public,
+				abm_level);
+
+	return true;
+}
+
+static bool set_psr_enable(struct dc *dc, bool enable)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_set_psr_enable(&core_dc->links[i]->public,
+				enable);
+
+	return true;
+}
+
+
+static bool setup_psr(struct dc *dc, const struct dc_stream *stream)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
+	struct pipe_ctx *pipes;
+	int i;
+	unsigned int underlay_idx = core_dc->res_pool->underlay_pipe_index;
+
+	for (i = 0; i < core_dc->link_count; i++) {
+		if (core_stream->sink->link == core_dc->links[i])
+			dc_link_setup_psr(&core_dc->links[i]->public,
+					stream);
+	}
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream
+				== core_stream && i != underlay_idx) {
+			pipes = &core_dc->current_context->res_ctx.pipe_ctx[i];
+			core_dc->hwss.set_static_screen_control(&pipes, 1,
+					0x182);
+		}
+	}
+
+	return true;
+}
+
+static void set_drive_settings(struct dc *dc,
+		struct link_training_settings *lt_settings)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_dp_set_drive_settings(&core_dc->links[i]->public,
+				lt_settings);
+}
+
+static void perform_link_training(struct dc *dc,
+		struct dc_link_settings *link_setting,
+		bool skip_video_pattern)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		dc_link_dp_perform_link_training(
+			&core_dc->links[i]->public,
+			link_setting,
+			skip_video_pattern);
+}
+
+static void set_preferred_link_settings(struct dc *dc,
+		struct dc_link_settings *link_setting)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	for (i = 0; i < core_dc->link_count; i++) {
+		core_dc->links[i]->public.verified_link_cap.lane_count =
+				link_setting->lane_count;
+		core_dc->links[i]->public.verified_link_cap.link_rate =
+				link_setting->link_rate;
+	}
+}
+
+static void enable_hpd(const struct dc_link *link)
+{
+	dc_link_dp_enable_hpd(link);
+}
+
+static void disable_hpd(const struct dc_link *link)
+{
+	dc_link_dp_disable_hpd(link);
+}
+
+
+static void set_test_pattern(
+		const struct dc_link *link,
+		enum dp_test_pattern test_pattern,
+		const struct link_training_settings *p_link_settings,
+		const unsigned char *p_custom_pattern,
+		unsigned int cust_pattern_size)
+{
+	if (link != NULL)
+		dc_link_dp_set_test_pattern(
+			link,
+			test_pattern,
+			p_link_settings,
+			p_custom_pattern,
+			cust_pattern_size);
+}
+
+static void allocate_dc_stream_funcs(struct core_dc *core_dc)
+{
+	core_dc->public.stream_funcs.stream_update_scaling = stream_update_scaling;
+	if (core_dc->hwss.set_drr != NULL) {
+		core_dc->public.stream_funcs.adjust_vmin_vmax =
+				stream_adjust_vmin_vmax;
+	}
+
+	core_dc->public.stream_funcs.set_gamut_remap =
+			set_gamut_remap;
+
+	core_dc->public.stream_funcs.set_backlight =
+			set_backlight;
+
+	core_dc->public.stream_funcs.init_dmcu_backlight_settings =
+			init_dmcu_backlight_settings;
+
+	core_dc->public.stream_funcs.set_abm_level =
+			set_abm_level;
+
+	core_dc->public.stream_funcs.set_psr_enable =
+			set_psr_enable;
+
+	core_dc->public.stream_funcs.setup_psr =
+			setup_psr;
+
+	core_dc->public.link_funcs.set_drive_settings =
+			set_drive_settings;
+
+	core_dc->public.link_funcs.perform_link_training =
+			perform_link_training;
+
+	core_dc->public.link_funcs.set_preferred_link_settings =
+			set_preferred_link_settings;
+
+	core_dc->public.link_funcs.enable_hpd =
+			enable_hpd;
+
+	core_dc->public.link_funcs.disable_hpd =
+			disable_hpd;
+
+	core_dc->public.link_funcs.set_test_pattern =
+			set_test_pattern;
+}
+
+static void destruct(struct core_dc *dc)
+{
+	resource_validate_ctx_destruct(dc->current_context);
+
+	dm_free(dc->temp_flip_context);
+	dc->temp_flip_context = NULL;
+
+	destroy_links(dc);
+
+	dc_destroy_resource_pool(dc);
+
+	if (dc->ctx->gpio_service)
+		dal_gpio_service_destroy(&dc->ctx->gpio_service);
+
+	if (dc->ctx->i2caux)
+		dal_i2caux_destroy(&dc->ctx->i2caux);
+
+	if (dc->ctx->created_bios)
+		dal_bios_parser_destroy(&dc->ctx->dc_bios);
+
+	if (dc->ctx->logger)
+		dal_logger_destroy(&dc->ctx->logger);
+
+	dm_free(dc->current_context);
+	dc->current_context = NULL;
+
+	dm_free(dc->ctx);
+	dc->ctx = NULL;
+}
+
+static bool construct(struct core_dc *dc,
+		const struct dc_init_data *init_params)
+{
+	struct dal_logger *logger;
+	struct dc_context *dc_ctx = dm_alloc(sizeof(*dc_ctx));
+	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
+
+	if (!dc_ctx) {
+		dm_error("%s: failed to create ctx\n", __func__);
+		goto ctx_fail;
+	}
+
+	dc->current_context = dm_alloc(sizeof(*dc->current_context));
+	dc->temp_flip_context = dm_alloc(sizeof(*dc->temp_flip_context));
+
+	if (!dc->current_context || !dc->temp_flip_context) {
+		dm_error("%s: failed to create validate ctx\n", __func__);
+		goto val_ctx_fail;
+	}
+
+	dc_ctx->cgs_device = init_params->cgs_device;
+	dc_ctx->driver_context = init_params->driver;
+	dc_ctx->dc = &dc->public;
+	dc_ctx->asic_id = init_params->asic_id;
+
+	/* Create logger */
+	logger = dal_logger_create(dc_ctx);
+
+	if (!logger) {
+		/* can *not* call logger. call base driver 'print error' */
+		dm_error("%s: failed to create Logger!\n", __func__);
+		goto logger_fail;
+	}
+	dc_ctx->logger = logger;
+	dc->ctx = dc_ctx;
+	dc->ctx->dce_environment = init_params->dce_environment;
+
+	dc_version = resource_parse_asic_id(init_params->asic_id);
+	dc->ctx->dce_version = dc_version;
+
+	/* Resource should construct all asic specific resources.
+	 * This should be the only place where we need to parse the asic id
+	 */
+	if (init_params->vbios_override)
+		dc_ctx->dc_bios = init_params->vbios_override;
+	else {
+		/* Create BIOS parser */
+		struct bp_init_data bp_init_data;
+		bp_init_data.ctx = dc_ctx;
+		bp_init_data.bios = init_params->asic_id.atombios_base_address;
+
+		dc_ctx->dc_bios = dal_bios_parser_create(
+				&bp_init_data, dc_version);
+
+		if (!dc_ctx->dc_bios) {
+			ASSERT_CRITICAL(false);
+			goto bios_fail;
+		}
+
+		dc_ctx->created_bios = true;
+	}
+
+	/* Create I2C AUX */
+	dc_ctx->i2caux = dal_i2caux_create(dc_ctx);
+
+	if (!dc_ctx->i2caux) {
+		ASSERT_CRITICAL(false);
+		goto failed_to_create_i2caux;
+	}
+
+	/* Create GPIO service */
+	dc_ctx->gpio_service = dal_gpio_service_create(
+			dc_version,
+			dc_ctx->dce_environment,
+			dc_ctx);
+
+	if (!dc_ctx->gpio_service) {
+		ASSERT_CRITICAL(false);
+		goto gpio_fail;
+	}
+
+	dc->res_pool = dc_create_resource_pool(
+			dc,
+			init_params->num_virtual_links,
+			dc_version,
+			init_params->asic_id);
+	if (!dc->res_pool)
+		goto create_resource_fail;
+
+	if (!create_links(dc, init_params->num_virtual_links))
+		goto create_links_fail;
+
+	allocate_dc_stream_funcs(dc);
+
+	return true;
+
+	/**** error handling here ****/
+create_links_fail:
+create_resource_fail:
+gpio_fail:
+failed_to_create_i2caux:
+bios_fail:
+logger_fail:
+val_ctx_fail:
+ctx_fail:
+	destruct(dc);
+	return false;
+}
+
+/*
+void ProgramPixelDurationV(unsigned int pixelClockInKHz )
+{
+	fixed31_32 pixel_duration = Fixed31_32(100000000, pixelClockInKHz) * 10;
+	unsigned int pixDurationInPico = round(pixel_duration);
+
+	DPG_PIPE_ARBITRATION_CONTROL1 arb_control;
+
+	arb_control.u32All = ReadReg (mmDPGV0_PIPE_ARBITRATION_CONTROL1);
+	arb_control.bits.PIXEL_DURATION = pixDurationInPico;
+	WriteReg (mmDPGV0_PIPE_ARBITRATION_CONTROL1, arb_control.u32All);
+
+	arb_control.u32All = ReadReg (mmDPGV1_PIPE_ARBITRATION_CONTROL1);
+	arb_control.bits.PIXEL_DURATION = pixDurationInPico;
+	WriteReg (mmDPGV1_PIPE_ARBITRATION_CONTROL1, arb_control.u32All);
+
+	WriteReg (mmDPGV0_PIPE_ARBITRATION_CONTROL2, 0x4000800);
+	WriteReg (mmDPGV0_REPEATER_PROGRAM, 0x11);
+
+	WriteReg (mmDPGV1_PIPE_ARBITRATION_CONTROL2, 0x4000800);
+	WriteReg (mmDPGV1_REPEATER_PROGRAM, 0x11);
+}
+*/
+
+/*******************************************************************************
+ * Public functions
+ ******************************************************************************/
+
+struct dc *dc_create(const struct dc_init_data *init_params)
+ {
+	struct core_dc *core_dc = dm_alloc(sizeof(*core_dc));
+	unsigned int full_pipe_count;
+
+	if (NULL == core_dc)
+		goto alloc_fail;
+
+	if (false == construct(core_dc, init_params))
+		goto construct_fail;
+
+	/*TODO: separate HW and SW initialization*/
+	core_dc->hwss.init_hw(core_dc);
+
+	full_pipe_count = core_dc->res_pool->pipe_count;
+	if (core_dc->res_pool->underlay_pipe_index >= 0)
+		full_pipe_count--;
+	core_dc->public.caps.max_targets = dm_min(
+			full_pipe_count,
+			core_dc->res_pool->stream_enc_count);
+
+	core_dc->public.caps.max_links = core_dc->link_count;
+	core_dc->public.caps.max_audios = core_dc->res_pool->audio_count;
+
+	core_dc->public.config = init_params->flags;
+
+	dm_logger_write(core_dc->ctx->logger, LOG_DC,
+			"Display Core initialized\n");
+
+
+	/* TODO: missing feature to be enabled */
+	core_dc->public.debug.disable_dfs_bypass = true;
+
+	return &core_dc->public;
+
+construct_fail:
+	dm_free(core_dc);
+
+alloc_fail:
+	return NULL;
+}
+
+void dc_destroy(struct dc **dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(*dc);
+	destruct(core_dc);
+	dm_free(core_dc);
+	*dc = NULL;
+}
+
+static bool is_validation_required(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	const struct validate_context *context = dc->current_context;
+	int i, j;
+
+	if (context->target_count != set_count)
+		return true;
+
+	for (i = 0; i < set_count; i++) {
+
+		if (set[i].surface_count != context->target_status[i].surface_count)
+			return true;
+		if (!is_target_unchanged(DC_TARGET_TO_CORE(set[i].target), context->targets[i]))
+			return true;
+
+		for (j = 0; j < set[i].surface_count; j++) {
+			struct dc_surface temp_surf = { 0 };
+
+			temp_surf = *context->target_status[i].surfaces[j];
+			temp_surf.clip_rect = set[i].surfaces[j]->clip_rect;
+			temp_surf.dst_rect.x = set[i].surfaces[j]->dst_rect.x;
+			temp_surf.dst_rect.y = set[i].surfaces[j]->dst_rect.y;
+
+			if (memcmp(&temp_surf, set[i].surfaces[j], sizeof(temp_surf)) != 0)
+				return true;
+		}
+	}
+
+	return false;
+}
+
+bool dc_validate_resources(
+		const struct dc *dc,
+		const struct dc_validation_set set[],
+		uint8_t set_count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+
+	if (!is_validation_required(core_dc, set, set_count))
+		return true;
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if(context == NULL)
+		goto context_alloc_fail;
+
+	result = core_dc->res_pool->funcs->validate_with_context(
+						core_dc, set, set_count, context);
+
+	resource_validate_ctx_destruct(context);
+	dm_free(context);
+
+context_alloc_fail:
+	if (result != DC_OK) {
+		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
+				"%s:resource validation failed, dc_status:%d\n",
+				__func__,
+				result);
+	}
+
+	return (result == DC_OK);
+
+}
+
+bool dc_validate_guaranteed(
+		const struct dc *dc,
+		const struct dc_target *dc_target)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	result = core_dc->res_pool->funcs->validate_guaranteed(
+					core_dc, dc_target, context);
+
+	resource_validate_ctx_destruct(context);
+	dm_free(context);
+
+context_alloc_fail:
+	if (result != DC_OK) {
+		dm_logger_write(core_dc->ctx->logger, LOG_WARNING,
+			"%s:guaranteed validation failed, dc_status:%d\n",
+			__func__,
+			result);
+		}
+
+	return (result == DC_OK);
+}
+
+static void program_timing_sync(
+		struct core_dc *core_dc,
+		struct validate_context *ctx)
+{
+	int i, j;
+	int group_index = 0;
+	int pipe_count = ctx->res_ctx.pool->pipe_count;
+	struct pipe_ctx *unsynced_pipes[MAX_PIPES] = { NULL };
+
+	for (i = 0; i < pipe_count; i++) {
+		if (!ctx->res_ctx.pipe_ctx[i].stream || ctx->res_ctx.pipe_ctx[i].top_pipe)
+			continue;
+
+		unsynced_pipes[i] = &ctx->res_ctx.pipe_ctx[i];
+	}
+
+	for (i = 0; i < pipe_count; i++) {
+		int group_size = 1;
+		struct pipe_ctx *pipe_set[MAX_PIPES];
+
+		if (!unsynced_pipes[i])
+			continue;
+
+		pipe_set[0] = unsynced_pipes[i];
+		unsynced_pipes[i] = NULL;
+
+		/* Add tg to the set, search rest of the tg's for ones with
+		 * same timing, add all tgs with same timing to the group
+		 */
+		for (j = i + 1; j < pipe_count; j++) {
+			if (!unsynced_pipes[j])
+				continue;
+
+			if (resource_are_streams_timing_synchronizable(
+					unsynced_pipes[j]->stream,
+					pipe_set[0]->stream)) {
+				pipe_set[group_size] = unsynced_pipes[j];
+				unsynced_pipes[j] = NULL;
+				group_size++;
+			}
+		}
+
+		/* set first unblanked pipe as master */
+		for (j = 0; j < group_size; j++) {
+			struct pipe_ctx *temp;
+
+			if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
+				if (j == 0)
+					break;
+
+				temp = pipe_set[0];
+				pipe_set[0] = pipe_set[j];
+				pipe_set[j] = temp;
+				break;
+			}
+		}
+
+		/* remove any other unblanked pipes as they have already been synced */
+		for (j = j + 1; j < group_size; j++) {
+			if (!pipe_set[j]->tg->funcs->is_blanked(pipe_set[j]->tg)) {
+				group_size--;
+				pipe_set[j] = pipe_set[group_size];
+				j--;
+			}
+		}
+
+		if (group_size > 1) {
+			core_dc->hwss.enable_timing_synchronization(
+				core_dc, group_index, group_size, pipe_set);
+			group_index++;
+		}
+	}
+}
+
+static bool targets_changed(
+		struct core_dc *dc,
+		struct dc_target *targets[],
+		uint8_t target_count)
+{
+	uint8_t i;
+
+	if (target_count != dc->current_context->target_count)
+		return true;
+
+	for (i = 0; i < dc->current_context->target_count; i++) {
+		if (&dc->current_context->targets[i]->public != targets[i])
+			return true;
+	}
+
+	return false;
+}
+
+static void fill_display_configs(
+	const struct validate_context *context,
+	struct dm_pp_display_configuration *pp_display_cfg)
+{
+	uint8_t i, j, k;
+	uint8_t num_cfgs = 0;
+
+	for (i = 0; i < context->target_count; i++) {
+		const struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			const struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+			struct dm_pp_single_disp_config *cfg =
+					&pp_display_cfg->disp_configs[num_cfgs];
+			const struct pipe_ctx *pipe_ctx = NULL;
+
+			for (k = 0; k < MAX_PIPES; k++)
+				if (stream ==
+					context->res_ctx.pipe_ctx[k].stream) {
+					pipe_ctx = &context->res_ctx.pipe_ctx[k];
+					break;
+				}
+
+			ASSERT(pipe_ctx != NULL);
+
+			num_cfgs++;
+			cfg->signal = pipe_ctx->stream->signal;
+			cfg->pipe_idx = pipe_ctx->pipe_idx;
+			cfg->src_height = stream->public.src.height;
+			cfg->src_width = stream->public.src.width;
+			cfg->ddi_channel_mapping =
+				stream->sink->link->ddi_channel_mapping.raw;
+			cfg->transmitter =
+				stream->sink->link->link_enc->transmitter;
+			cfg->link_settings.lane_count = stream->sink->link->public.cur_link_settings.lane_count;
+			cfg->link_settings.link_rate = stream->sink->link->public.cur_link_settings.link_rate;
+			cfg->link_settings.link_spread = stream->sink->link->public.cur_link_settings.link_spread;
+			cfg->sym_clock = stream->phy_pix_clk;
+			/* Round v_refresh*/
+			cfg->v_refresh = stream->public.timing.pix_clk_khz * 1000;
+			cfg->v_refresh /= stream->public.timing.h_total;
+			cfg->v_refresh = (cfg->v_refresh + stream->public.timing.v_total / 2)
+						/ stream->public.timing.v_total;
+		}
+	}
+	pp_display_cfg->display_count = num_cfgs;
+}
+
+static uint32_t get_min_vblank_time_us(const struct validate_context *context)
+{
+	uint8_t i, j;
+	uint32_t min_vertical_blank_time = -1;
+
+	for (i = 0; i < context->target_count; i++) {
+		const struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			const struct dc_stream *stream =
+						target->public.streams[j];
+			uint32_t vertical_blank_in_pixels = 0;
+			uint32_t vertical_blank_time = 0;
+
+			vertical_blank_in_pixels = stream->timing.h_total *
+				(stream->timing.v_total
+					- stream->timing.v_addressable);
+			vertical_blank_time = vertical_blank_in_pixels
+				* 1000 / stream->timing.pix_clk_khz;
+			if (min_vertical_blank_time > vertical_blank_time)
+				min_vertical_blank_time = vertical_blank_time;
+		}
+	}
+	return min_vertical_blank_time;
+}
+
+static int determine_sclk_from_bounding_box(
+		const struct core_dc *dc,
+		int required_sclk)
+{
+	int i;
+
+	/*
+	 * Some asics do not give us sclk levels, so we just report the actual
+	 * required sclk
+	 */
+	if (dc->sclk_lvls.num_levels == 0)
+		return required_sclk;
+
+	for (i = 0; i < dc->sclk_lvls.num_levels; i++) {
+		if (dc->sclk_lvls.clocks_in_khz[i] >= required_sclk)
+			return dc->sclk_lvls.clocks_in_khz[i];
+	}
+	/*
+	 * even maximum level could not satisfy requirement, this
+	 * is unexpected at this stage, should have been caught at
+	 * validation time
+	 */
+	ASSERT(0);
+	return dc->sclk_lvls.clocks_in_khz[dc->sclk_lvls.num_levels - 1];
+}
+
+void pplib_apply_display_requirements(
+	struct core_dc *dc,
+	const struct validate_context *context,
+	struct dm_pp_display_configuration *pp_display_cfg)
+{
+	pp_display_cfg->all_displays_in_sync =
+		context->bw_results.all_displays_in_sync;
+	pp_display_cfg->nb_pstate_switch_disable =
+			context->bw_results.nbp_state_change_enable == false;
+	pp_display_cfg->cpu_cc6_disable =
+			context->bw_results.cpuc_state_change_enable == false;
+	pp_display_cfg->cpu_pstate_disable =
+			context->bw_results.cpup_state_change_enable == false;
+	pp_display_cfg->cpu_pstate_separation_time =
+			context->bw_results.blackout_recovery_time_us;
+
+	pp_display_cfg->min_memory_clock_khz = context->bw_results.required_yclk
+		/ MEMORY_TYPE_MULTIPLIER;
+
+	pp_display_cfg->min_engine_clock_khz = determine_sclk_from_bounding_box(
+			dc,
+			context->bw_results.required_sclk);
+
+	pp_display_cfg->min_engine_clock_deep_sleep_khz
+			= context->bw_results.required_sclk_deep_sleep;
+
+	pp_display_cfg->avail_mclk_switch_time_us =
+						get_min_vblank_time_us(context);
+	/* TODO: dce11.2*/
+	pp_display_cfg->avail_mclk_switch_time_in_disp_active_us = 0;
+
+	pp_display_cfg->disp_clk_khz = context->bw_results.dispclk_khz;
+
+	fill_display_configs(context, pp_display_cfg);
+
+	/* TODO: is this still applicable?*/
+	if (pp_display_cfg->display_count == 1) {
+		const struct dc_crtc_timing *timing =
+			&context->targets[0]->public.streams[0]->timing;
+
+		pp_display_cfg->crtc_index =
+			pp_display_cfg->disp_configs[0].pipe_idx;
+		pp_display_cfg->line_time_in_us = timing->h_total * 1000
+							/ timing->pix_clk_khz;
+	}
+
+	if (memcmp(&dc->prev_display_config, pp_display_cfg, sizeof(
+			struct dm_pp_display_configuration)) !=  0)
+		dm_pp_apply_display_requirements(dc->ctx, pp_display_cfg);
+
+	dc->prev_display_config = *pp_display_cfg;
+
+}
+
+bool dc_commit_targets(
+	struct dc *dc,
+	struct dc_target *targets[],
+	uint8_t target_count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_bios *dcb = core_dc->ctx->dc_bios;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct validate_context *context;
+	struct dc_validation_set set[MAX_TARGETS];
+	int i, j, k;
+
+	if (false == targets_changed(core_dc, targets, target_count))
+		return DC_OK;
+
+	dm_logger_write(core_dc->ctx->logger, LOG_DC,
+				"%s: %d targets\n",
+				__func__,
+				target_count);
+
+	for (i = 0; i < target_count; i++) {
+		struct dc_target *target = targets[i];
+
+		dc_target_log(target,
+				core_dc->ctx->logger,
+				LOG_DC);
+
+		set[i].target = targets[i];
+		set[i].surface_count = 0;
+
+	}
+
+	context = dm_alloc(sizeof(struct validate_context));
+	if (context == NULL)
+		goto context_alloc_fail;
+
+	result = core_dc->res_pool->funcs->validate_with_context(core_dc, set, target_count, context);
+	if (result != DC_OK){
+		dm_logger_write(core_dc->ctx->logger, LOG_ERROR,
+					"%s: Context validation failed! dc_status:%d\n",
+					__func__,
+					result);
+		BREAK_TO_DEBUGGER();
+		resource_validate_ctx_destruct(context);
+		goto fail;
+	}
+
+	if (!dcb->funcs->is_accelerated_mode(dcb)) {
+		core_dc->hwss.enable_accelerated_mode(core_dc);
+	}
+
+	if (result == DC_OK) {
+		result = core_dc->hwss.apply_ctx_to_hw(core_dc, context);
+	}
+
+	program_timing_sync(core_dc, context);
+
+	for (i = 0; i < context->target_count; i++) {
+		struct dc_target *dc_target = &context->targets[i]->public;
+		struct core_sink *sink = DC_SINK_TO_CORE(dc_target->streams[0]->sink);
+
+		for (j = 0; j < context->target_status[i].surface_count; j++) {
+			const struct dc_surface *dc_surface =
+					context->target_status[i].surfaces[j];
+
+			for (k = 0; k < context->res_ctx.pool->pipe_count; k++) {
+				struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[k];
+
+				if (dc_surface != &pipe->surface->public
+						|| !dc_surface->visible)
+					continue;
+
+				pipe->tg->funcs->set_blank(pipe->tg, false);
+			}
+		}
+
+		CONN_MSG_MODE(sink->link, "{%dx%d, %dx%d@%dKhz}",
+				dc_target->streams[0]->timing.h_addressable,
+				dc_target->streams[0]->timing.v_addressable,
+				dc_target->streams[0]->timing.h_total,
+				dc_target->streams[0]->timing.v_total,
+				dc_target->streams[0]->timing.pix_clk_khz);
+	}
+
+	pplib_apply_display_requirements(core_dc,
+			context, &context->pp_display_cfg);
+
+	resource_validate_ctx_destruct(core_dc->current_context);
+
+	dm_free(core_dc->current_context);
+	core_dc->current_context = context;
+
+	return (result == DC_OK);
+
+fail:
+	dm_free(context);
+
+context_alloc_fail:
+	return (result == DC_OK);
+}
+
+bool dc_pre_update_surfaces_to_target(
+		struct dc *dc,
+		const struct dc_surface *const *new_surfaces,
+		uint8_t new_surface_count,
+		struct dc_target *dc_target)
+{
+	int i, j;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	uint32_t prev_disp_clk = core_dc->current_context->bw_results.dispclk_khz;
+	struct core_target *target = DC_TARGET_TO_CORE(dc_target);
+	struct dc_target_status *target_status = NULL;
+	struct validate_context *context;
+	struct validate_context *temp_context;
+	bool ret = true;
+
+	pre_surface_trace(dc, new_surfaces, new_surface_count);
+
+	if (core_dc->current_context->target_count == 0)
+		return false;
+
+	/* Cannot commit surface to a target that is not commited */
+	for (i = 0; i < core_dc->current_context->target_count; i++)
+		if (target == core_dc->current_context->targets[i])
+			break;
+
+	if (i == core_dc->current_context->target_count)
+		return false;
+
+	target_status = &core_dc->current_context->target_status[i];
+
+	if (new_surface_count == target_status->surface_count) {
+		bool skip_pre = true;
+
+		for (i = 0; i < target_status->surface_count; i++) {
+			struct dc_surface temp_surf = { 0 };
+
+			temp_surf = *target_status->surfaces[i];
+			temp_surf.clip_rect = new_surfaces[i]->clip_rect;
+			temp_surf.dst_rect.x = new_surfaces[i]->dst_rect.x;
+			temp_surf.dst_rect.y = new_surfaces[i]->dst_rect.y;
+
+			if (memcmp(&temp_surf, new_surfaces[i], sizeof(temp_surf)) != 0) {
+				skip_pre = false;
+				break;
+			}
+		}
+
+		if (skip_pre)
+			return true;
+	}
+
+	context = dm_alloc(sizeof(struct validate_context));
+
+	if (!context) {
+		dm_error("%s: failed to create validate ctx\n", __func__);
+		ret = false;
+		goto val_ctx_fail;
+	}
+
+	resource_validate_ctx_copy_construct(core_dc->current_context, context);
+
+	dm_logger_write(core_dc->ctx->logger, LOG_DC,
+				"%s: commit %d surfaces to target 0x%x\n",
+				__func__,
+				new_surface_count,
+				dc_target);
+
+	if (!resource_attach_surfaces_to_context(
+			new_surfaces, new_surface_count, dc_target, context)) {
+		BREAK_TO_DEBUGGER();
+		ret = false;
+		goto unexpected_fail;
+	}
+
+	for (i = 0; i < new_surface_count; i++)
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			if (context->res_ctx.pipe_ctx[j].surface !=
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+			resource_build_scaling_params(
+				new_surfaces[i], &context->res_ctx.pipe_ctx[j]);
+
+			if (dc->debug.surface_visual_confirm) {
+				context->res_ctx.pipe_ctx[j].scl_data.recout.height -= 2;
+				context->res_ctx.pipe_ctx[j].scl_data.recout.width -= 2;
+			}
+		}
+
+	if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, context) != DC_OK) {
+		BREAK_TO_DEBUGGER();
+		ret = false;
+		goto unexpected_fail;
+	}
+
+	if (core_dc->res_pool->funcs->apply_clk_constraints) {
+		temp_context = core_dc->res_pool->funcs->apply_clk_constraints(
+				core_dc,
+				context);
+		if (!temp_context) {
+			dm_error("%s:failed apply clk constraints\n", __func__);
+			ret = false;
+			goto unexpected_fail;
+		}
+		resource_validate_ctx_destruct(context);
+		dm_free(context);
+		context = temp_context;
+	}
+
+	if (prev_disp_clk < context->bw_results.dispclk_khz) {
+		pplib_apply_display_requirements(core_dc, context,
+						&context->pp_display_cfg);
+		core_dc->hwss.set_display_clock(context);
+		core_dc->current_context->bw_results.dispclk_khz =
+				context->bw_results.dispclk_khz;
+	}
+
+	for (i = 0; i < new_surface_count; i++)
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			if (context->res_ctx.pipe_ctx[j].surface !=
+					DC_SURFACE_TO_CORE(new_surfaces[i]))
+				continue;
+
+			core_dc->hwss.prepare_pipe_for_context(
+					core_dc,
+					&context->res_ctx.pipe_ctx[j],
+					context);
+
+			if (!new_surfaces[i]->visible)
+				context->res_ctx.pipe_ctx[j].tg->funcs->set_blank(
+						context->res_ctx.pipe_ctx[j].tg, true);
+		}
+
+unexpected_fail:
+	resource_validate_ctx_destruct(context);
+	dm_free(context);
+val_ctx_fail:
+
+	return ret;
+}
+
+bool dc_post_update_surfaces_to_target(struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i;
+
+	post_surface_trace(dc);
+
+	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count; i++)
+		if (core_dc->current_context->res_ctx.pipe_ctx[i].stream == NULL)
+			core_dc->hwss.power_down_front_end(
+				core_dc, &core_dc->current_context->res_ctx.pipe_ctx[i]);
+
+	if (core_dc->res_pool->funcs->validate_bandwidth(core_dc, core_dc->current_context)
+			!= DC_OK) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	core_dc->hwss.set_bandwidth(core_dc);
+
+	pplib_apply_display_requirements(
+			core_dc, core_dc->current_context, &core_dc->current_context->pp_display_cfg);
+
+	return true;
+}
+
+bool dc_commit_surfaces_to_target(
+		struct dc *dc,
+		const struct dc_surface **new_surfaces,
+		uint8_t new_surface_count,
+		struct dc_target *dc_target)
+{
+	struct dc_surface_update updates[MAX_SURFACES] = { 0 };
+	struct dc_flip_addrs flip_addr[MAX_SURFACES] = { 0 };
+	struct dc_plane_info plane_info[MAX_SURFACES] = { 0 };
+	struct dc_scaling_info scaling_info[MAX_SURFACES] = { 0 };
+	int i;
+
+	if (!dc_pre_update_surfaces_to_target(
+			dc, new_surfaces, new_surface_count, dc_target))
+		return false;
+
+	for (i = 0; i < new_surface_count; i++) {
+		updates[i].surface = new_surfaces[i];
+		updates[i].gamma = (struct dc_gamma *)new_surfaces[i]->gamma_correction;
+
+		flip_addr[i].address = new_surfaces[i]->address;
+		flip_addr[i].flip_immediate = new_surfaces[i]->flip_immediate;
+		plane_info[i].color_space = new_surfaces[i]->color_space;
+		plane_info[i].format = new_surfaces[i]->format;
+		plane_info[i].plane_size = new_surfaces[i]->plane_size;
+		plane_info[i].rotation = new_surfaces[i]->rotation;
+		plane_info[i].horizontal_mirror = new_surfaces[i]->horizontal_mirror;
+		plane_info[i].stereo_format = new_surfaces[i]->stereo_format;
+		plane_info[i].tiling_info = new_surfaces[i]->tiling_info;
+		plane_info[i].visible = new_surfaces[i]->visible;
+		scaling_info[i].scaling_quality = new_surfaces[i]->scaling_quality;
+		scaling_info[i].src_rect = new_surfaces[i]->src_rect;
+		scaling_info[i].dst_rect = new_surfaces[i]->dst_rect;
+		scaling_info[i].clip_rect = new_surfaces[i]->clip_rect;
+
+		updates[i].flip_addr = &flip_addr[i];
+		updates[i].plane_info = &plane_info[i];
+		updates[i].scaling_info = &scaling_info[i];
+	}
+	dc_update_surfaces_for_target(dc, updates, new_surface_count, dc_target);
+
+	return dc_post_update_surfaces_to_target(dc);
+}
+
+void dc_update_surfaces_for_target(struct dc *dc, struct dc_surface_update *updates,
+		int surface_count, struct dc_target *dc_target)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct validate_context *context = core_dc->temp_flip_context;
+	int i, j;
+	bool is_new_pipe_surface[MAX_SURFACES];
+	const struct dc_surface *new_surfaces[MAX_SURFACES] = { 0 };
+
+	update_surface_trace(dc, updates, surface_count);
+
+	*context = *core_dc->current_context;
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+
+		if (cur_pipe->top_pipe)
+			cur_pipe->top_pipe =
+				&context->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+
+		if (cur_pipe->bottom_pipe)
+			cur_pipe->bottom_pipe =
+				&context->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+	}
+
+	for (j = 0; j < MAX_SURFACES; j++)
+		is_new_pipe_surface[j] = true;
+
+	for (i = 0 ; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+
+		new_surfaces[i] = updates[i].surface;
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+			if (surface == pipe_ctx->surface)
+				is_new_pipe_surface[i] = false;
+		}
+	}
+
+	if (dc_target) {
+		struct core_target *target = DC_TARGET_TO_CORE(dc_target);
+
+		if (core_dc->current_context->target_count == 0)
+			return;
+
+		/* Cannot commit surface to a target that is not commited */
+		for (i = 0; i < core_dc->current_context->target_count; i++)
+			if (target == core_dc->current_context->targets[i])
+				break;
+		if (i == core_dc->current_context->target_count)
+			return;
+
+		if (!resource_attach_surfaces_to_context(
+				new_surfaces, surface_count, dc_target, context)) {
+			BREAK_TO_DEBUGGER();
+			return;
+		}
+	}
+
+	for (i = 0; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+			if (pipe_ctx->surface != surface)
+				continue;
+
+			if (updates[i].flip_addr) {
+				surface->public.address = updates[i].flip_addr->address;
+				surface->public.flip_immediate =
+						updates[i].flip_addr->flip_immediate;
+			}
+
+			if (updates[i].plane_info || updates[i].scaling_info
+					|| is_new_pipe_surface[j]) {
+
+				if (updates[i].plane_info) {
+					surface->public.color_space =
+						updates[i].plane_info->color_space;
+					surface->public.format =
+						updates[i].plane_info->format;
+					surface->public.plane_size =
+						updates[i].plane_info->plane_size;
+					surface->public.rotation =
+						updates[i].plane_info->rotation;
+					surface->public.horizontal_mirror =
+						updates[i].plane_info->horizontal_mirror;
+					surface->public.stereo_format =
+						updates[i].plane_info->stereo_format;
+					surface->public.tiling_info =
+						updates[i].plane_info->tiling_info;
+					surface->public.visible =
+						updates[i].plane_info->visible;
+				}
+
+				if (updates[i].scaling_info) {
+					surface->public.scaling_quality =
+						updates[i].scaling_info->scaling_quality;
+					surface->public.dst_rect =
+						updates[i].scaling_info->dst_rect;
+					surface->public.src_rect =
+						updates[i].scaling_info->src_rect;
+					surface->public.clip_rect =
+						updates[i].scaling_info->clip_rect;
+				}
+
+				resource_build_scaling_params(updates[i].surface, pipe_ctx);
+				if (dc->debug.surface_visual_confirm) {
+					pipe_ctx->scl_data.recout.height -= 2;
+					pipe_ctx->scl_data.recout.width -= 2;
+				}
+			}
+		}
+	}
+
+	for (i = 0; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(updates[i].surface);
+		bool apply_ctx = false;
+
+		for (j = 0; j < context->res_ctx.pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[j];
+
+			if (pipe_ctx->surface != surface)
+				continue;
+
+			if (updates[i].flip_addr) {
+				core_dc->hwss.pipe_control_lock(
+							core_dc->hwseq,
+							pipe_ctx->pipe_idx,
+							PIPE_LOCK_CONTROL_SURFACE,
+							true);
+				core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+			}
+
+			if (updates[i].plane_info || updates[i].scaling_info
+					|| is_new_pipe_surface[j]) {
+
+				apply_ctx = true;
+
+				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
+					core_dc->hwss.pipe_control_lock(
+							core_dc->hwseq,
+							pipe_ctx->pipe_idx,
+							PIPE_LOCK_CONTROL_SURFACE |
+							PIPE_LOCK_CONTROL_GRAPHICS |
+							PIPE_LOCK_CONTROL_SCL |
+							PIPE_LOCK_CONTROL_BLENDER |
+							PIPE_LOCK_CONTROL_MODE,
+							true);
+				}
+			}
+
+			if (updates[i].gamma)
+				core_dc->hwss.prepare_pipe_for_context(
+						core_dc, pipe_ctx, context);
+		}
+		if (apply_ctx)
+			core_dc->hwss.apply_ctx_for_surface(core_dc, surface, context);
+	}
+
+	for (i = context->res_ctx.pool->pipe_count - 1; i >= 0; i--) {
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
+
+		for (j = 0; j < surface_count; j++) {
+			if (updates[j].surface == &pipe_ctx->surface->public) {
+				if (!pipe_ctx->tg->funcs->is_blanked(pipe_ctx->tg)) {
+					core_dc->hwss.pipe_control_lock(
+							core_dc->hwseq,
+							pipe_ctx->pipe_idx,
+							PIPE_LOCK_CONTROL_GRAPHICS |
+							PIPE_LOCK_CONTROL_SCL |
+							PIPE_LOCK_CONTROL_BLENDER |
+							PIPE_LOCK_CONTROL_SURFACE,
+							false);
+				}
+				break;
+			}
+		}
+	}
+
+	core_dc->temp_flip_context = core_dc->current_context;
+	core_dc->current_context = context;
+}
+
+uint8_t dc_get_current_target_count(const struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->current_context->target_count;
+}
+
+struct dc_target *dc_get_target_at_index(const struct dc *dc, uint8_t i)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	if (i < core_dc->current_context->target_count)
+		return &(core_dc->current_context->targets[i]->public);
+	return NULL;
+}
+
+const struct dc_link *dc_get_link_at_index(const struct dc *dc, uint32_t link_index)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return &core_dc->links[link_index]->public;
+}
+
+const struct graphics_object_id dc_get_link_id_at_index(
+	struct dc *dc, uint32_t link_index)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->link_id;
+}
+
+const struct ddc_service *dc_get_ddc_at_index(
+	struct dc *dc, uint32_t link_index)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->ddc;
+}
+
+enum dc_irq_source dc_get_hpd_irq_source_at_index(
+	struct dc *dc, uint32_t link_index)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return core_dc->links[link_index]->public.irq_source_hpd;
+}
+
+const struct audio **dc_get_audios(struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return (const struct audio **)core_dc->res_pool->audios;
+}
+
+void dc_flip_surface_addrs(
+		struct dc *dc,
+		const struct dc_surface *const surfaces[],
+		struct dc_flip_addrs flip_addrs[],
+		uint32_t count)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	int i, j;
+
+	for (i = 0; i < count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
+
+		surface->public.address = flip_addrs[i].address;
+		surface->public.flip_immediate = flip_addrs[i].flip_immediate;
+
+		for (j = 0; j < core_dc->res_pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &core_dc->current_context->res_ctx.pipe_ctx[j];
+
+			if (pipe_ctx->surface != surface)
+				continue;
+
+			core_dc->hwss.update_plane_addr(core_dc, pipe_ctx);
+		}
+	}
+}
+
+enum dc_irq_source dc_interrupt_to_irq_source(
+		struct dc *dc,
+		uint32_t src_id,
+		uint32_t ext_id)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	return dal_irq_service_to_irq_source(core_dc->res_pool->irqs, src_id, ext_id);
+}
+
+void dc_interrupt_set(const struct dc *dc, enum dc_irq_source src, bool enable)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	dal_irq_service_set(core_dc->res_pool->irqs, src, enable);
+}
+
+void dc_interrupt_ack(struct dc *dc, enum dc_irq_source src)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	dal_irq_service_ack(core_dc->res_pool->irqs, src);
+}
+
+void dc_set_power_state(
+	struct dc *dc,
+	enum dc_acpi_cm_power_state power_state,
+	enum dc_video_power_state video_power_state)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	core_dc->previous_power_state = core_dc->current_power_state;
+	core_dc->current_power_state = video_power_state;
+
+	switch (power_state) {
+	case DC_ACPI_CM_POWER_STATE_D0:
+		core_dc->hwss.init_hw(core_dc);
+		break;
+	default:
+		/* NULL means "reset/release all DC targets" */
+		dc_commit_targets(dc, NULL, 0);
+
+		core_dc->hwss.power_down(core_dc);
+
+		/* Zero out the current context so that on resume we start with
+		 * clean state, and dc hw programming optimizations will not
+		 * cause any trouble.
+		 */
+		memset(core_dc->current_context, 0,
+				sizeof(*core_dc->current_context));
+
+		core_dc->current_context->res_ctx.pool = core_dc->res_pool;
+
+		break;
+	}
+
+}
+
+void dc_resume(const struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	uint32_t i;
+
+	for (i = 0; i < core_dc->link_count; i++)
+		core_link_resume(core_dc->links[i]);
+}
+
+bool dc_read_dpcd(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		uint8_t *data,
+		uint32_t size)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
+	enum ddc_result r = dal_ddc_service_read_dpcd_data(
+			link->ddc,
+			address,
+			data,
+			size);
+	return r == DDC_RESULT_SUCESSFULL;
+}
+
+bool dc_write_dpcd(
+		struct dc *dc,
+		uint32_t link_index,
+		uint32_t address,
+		const uint8_t *data,
+		uint32_t size)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
+
+	enum ddc_result r = dal_ddc_service_write_dpcd_data(
+			link->ddc,
+			address,
+			data,
+			size);
+	return r == DDC_RESULT_SUCESSFULL;
+}
+
+bool dc_submit_i2c(
+		struct dc *dc,
+		uint32_t link_index,
+		struct i2c_command *cmd)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct core_link *link = core_dc->links[link_index];
+	struct ddc_service *ddc = link->ddc;
+
+	return dal_i2caux_submit_i2c_command(
+		ddc->ctx->i2caux,
+		ddc->ddc_pin,
+		cmd);
+}
+
+static bool link_add_remote_sink_helper(struct core_link *core_link, struct dc_sink *sink)
+{
+	struct dc_link *dc_link = &core_link->public;
+
+	if (dc_link->sink_count >= MAX_SINKS_PER_LINK) {
+		BREAK_TO_DEBUGGER();
+		return false;
+	}
+
+	dc_sink_retain(sink);
+
+	dc_link->remote_sinks[dc_link->sink_count] = sink;
+	dc_link->sink_count++;
+
+	return true;
+}
+
+struct dc_sink *dc_link_add_remote_sink(
+		const struct dc_link *link,
+		const uint8_t *edid,
+		int len,
+		struct dc_sink_init_data *init_data)
+{
+	struct dc_sink *dc_sink;
+	enum dc_edid_status edid_status;
+	struct core_link *core_link = DC_LINK_TO_LINK(link);
+
+	if (len > MAX_EDID_BUFFER_SIZE) {
+		dm_error("Max EDID buffer size breached!\n");
+		return NULL;
+	}
+
+	if (!init_data) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	if (!init_data->link) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	dc_sink = dc_sink_create(init_data);
+
+	if (!dc_sink)
+		return NULL;
+
+	memmove(dc_sink->dc_edid.raw_edid, edid, len);
+	dc_sink->dc_edid.length = len;
+
+	if (!link_add_remote_sink_helper(
+			core_link,
+			dc_sink))
+		goto fail_add_sink;
+
+	edid_status = dm_helpers_parse_edid_caps(
+			core_link->ctx,
+			&dc_sink->dc_edid,
+			&dc_sink->edid_caps);
+
+	if (edid_status != EDID_OK)
+		goto fail;
+
+	return dc_sink;
+fail:
+	dc_link_remove_remote_sink(link, dc_sink);
+fail_add_sink:
+	dc_sink_release(dc_sink);
+	return NULL;
+}
+
+void dc_link_set_sink(const struct dc_link *link, struct dc_sink *sink)
+{
+	struct core_link *core_link = DC_LINK_TO_LINK(link);
+	struct dc_link *dc_link = &core_link->public;
+
+	dc_link->local_sink = sink;
+
+	if (sink == NULL) {
+		dc_link->type = dc_connection_none;
+	} else {
+		dc_link->type = dc_connection_single;
+	}
+}
+
+void dc_link_remove_remote_sink(const struct dc_link *link, const struct dc_sink *sink)
+{
+	int i;
+	struct core_link *core_link = DC_LINK_TO_LINK(link);
+	struct dc_link *dc_link = &core_link->public;
+
+	if (!link->sink_count) {
+		BREAK_TO_DEBUGGER();
+		return;
+	}
+
+	for (i = 0; i < dc_link->sink_count; i++) {
+		if (dc_link->remote_sinks[i] == sink) {
+			dc_sink_release(sink);
+			dc_link->remote_sinks[i] = NULL;
+
+			/* shrink array to remove empty place */
+			while (i < dc_link->sink_count - 1) {
+				dc_link->remote_sinks[i] = dc_link->remote_sinks[i+1];
+				i++;
+			}
+
+			dc_link->sink_count--;
+			return;
+		}
+	}
+}
+
+const struct dc_stream_status *dc_stream_get_status(
+	const struct dc_stream *dc_stream)
+{
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+
+	return &stream->status;
+}
+
+bool dc_init_dchub(struct dc *dc, struct dchub_init_data *dh_data)
+{
+	int i;
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct mem_input *mi = NULL;
+
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+		if (core_dc->res_pool->mis[i] != NULL) {
+			mi = core_dc->res_pool->mis[i];
+			break;
+		}
+	}
+	if (mi == NULL) {
+		dm_error("no mem_input!\n");
+		return false;
+	}
+
+	if (mi->funcs->mem_input_update_dchub)
+		mi->funcs->mem_input_update_dchub(mi, dh_data);
+	else
+		ASSERT(mi->funcs->mem_input_update_dchub);
+
+
+	return true;
+
+}
+
