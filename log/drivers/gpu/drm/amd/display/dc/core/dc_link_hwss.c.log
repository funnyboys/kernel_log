commit d5bef51f084fccafa984b114ff74a01a64a0e2e3
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Apr 7 12:01:07 2020 -0400

    drm/amd/display: fix virtual signal dsc setup
    
    This prevents dpcd access on virtual links.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 51e0ee6e7695..6590f51caefa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -400,7 +400,7 @@ static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	bool result = false;
 
-	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
+	if (dc_is_virtual_signal(stream->signal) || IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		result = true;
 	else
 		result = dm_helpers_dp_write_dsc_enable(dc->ctx, stream, enable);

commit 2f752e914d943c199f3255b4aba3358fd78cc8c9
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Mar 5 16:32:35 2020 -0500

    drm/amd/display: Remove connect DIG FE to its BE during timing programming
    
    [why]
    Causes regression with MST DSC displays not lighting up after DPMS
    
    [how]
    Revert commit 8cc426d79be1c3 ("drm/amd/display: Program DSC during timing programming")
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index ac2103dec9e7..51e0ee6e7695 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -394,7 +394,7 @@ static void dsc_optc_config_log(struct display_stream_compressor *dsc,
 	DC_LOG_DSC("\tslice_width %d", config->slice_width);
 }
 
-bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
+static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 {
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct dc_stream_state *stream = pipe_ctx->stream;

commit 8cc426d79be1c360f2cc53a469a9eb7c737ccad9
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Wed Feb 26 14:53:54 2020 -0500

    drm/amd/display: Program DSC during timing programming
    
    [why]
    Link or DIG BE can't be exposed to a higher stream bandwidth than they
    can handle. When DSC is required to fit the stream into the link
    bandwidth, DSC has to be programmed during timing programming to ensure
    this. Without it, intermittent issues such as black screen after S3 or a
    hot-plug can be seen.
    
    [how]
    Move DSC programming from enabling stream on link to timing setup.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 51e0ee6e7695..ac2103dec9e7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -394,7 +394,7 @@ static void dsc_optc_config_log(struct display_stream_compressor *dsc,
 	DC_LOG_DSC("\tslice_width %d", config->slice_width);
 }
 
-static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
+bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 {
 	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct dc_stream_state *stream = pipe_ctx->stream;

commit df8e34ac27e8a0d8dce364628226c5619693c3fd
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Feb 18 17:11:50 2020 -0500

    drm/amd/display: fix image corruption with ODM 2:1 DSC 2 slice
    
    [why]
    When combining two or more pipes in DSC mode, there will always be more
    than 1 slice per line.  In this case, as per DSC rules, the sink device
    is expecting that the ICH is reset at the end of each slice line (i.e.
    ICH_RESET_AT_END_OF_LINE must be configured based on the number of
    slices at the output of ODM).  It is recommended that software set
    ICH_RESET_AT_END_OF_LINE = 0xF for each DSC in the ODM combine.  However
    the current code only set ICH_RESET_AT_END_OF_LINE = 0xF when number of
    slice per DSC engine is greater than 1 instead of number of slice per
    output after ODM combine.
    
    [how]
    Add is_odm in dsc config. Set ICH_RESET_AT_END_OF_LINE = 0xF if either
    is_odm or number of slice per DSC engine is greater than 1.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 58634f191a55..51e0ee6e7695 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -431,6 +431,7 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 		dsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;
 		dsc_cfg.pixel_encoding = stream->timing.pixel_encoding;
 		dsc_cfg.color_depth = stream->timing.display_color_depth;
+		dsc_cfg.is_odm = pipe_ctx->next_odm_pipe ? true : false;
 		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
 		ASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % opp_cnt == 0);
 		dsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;
@@ -535,6 +536,7 @@ bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
 		dsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;
 		dsc_cfg.pixel_encoding = stream->timing.pixel_encoding;
 		dsc_cfg.color_depth = stream->timing.display_color_depth;
+		dsc_cfg.is_odm = pipe_ctx->next_odm_pipe ? true : false;
 		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
 
 		DC_LOG_DSC(" ");

commit cb8348fec250e517b5facb4cab3125ddc597f9aa
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Jan 28 11:58:44 2020 -0500

    drm/amd/display: always apply T7/T9 delay logic
    
    [why]
    before we exit early in edp_reciever_ready if we detect that panel
    is not edp or below rev 1.2. This will skip the backlight/t7 delay panel
    patch.
    
    [how]
    edit logic to ensure panel patch is applied regardless of edp rev.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index ddb855045767..58634f191a55 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -153,18 +153,19 @@ bool edp_receiver_ready_T9(struct dc_link *link)
 	unsigned char edpRev = 0;
 	enum dc_status result = DC_OK;
 	result = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));
-	if (edpRev < DP_EDP_12)
-		return true;
-	/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
-	do {
-		sinkstatus = 1;
-		result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
-		if (sinkstatus == 0)
-			break;
-		if (result != DC_OK)
-			break;
-		udelay(100); //MAx T9
-	} while (++tries < 50);
+
+     /* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
+	if (result == DC_OK && edpRev >= DP_EDP_12) {
+		do {
+			sinkstatus = 1;
+			result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
+			if (sinkstatus == 0)
+				break;
+			if (result != DC_OK)
+				break;
+			udelay(100); //MAx T9
+		} while (++tries < 50);
+	}
 
 	if (link->local_sink->edid_caps.panel_patch.extra_delay_backlight_off > 0)
 		udelay(link->local_sink->edid_caps.panel_patch.extra_delay_backlight_off * 1000);
@@ -183,21 +184,22 @@ bool edp_receiver_ready_T7(struct dc_link *link)
 	unsigned long long time_taken_in_ns = 0;
 
 	result = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));
-	if (result == DC_OK && edpRev < DP_EDP_12)
-		return true;
-	/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
-	enter_timestamp = dm_get_timestamp(link->ctx);
-	do {
-		sinkstatus = 0;
-		result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
-		if (sinkstatus == 1)
-			break;
-		if (result != DC_OK)
-			break;
-		udelay(25);
-		finish_timestamp = dm_get_timestamp(link->ctx);
-		time_taken_in_ns = dm_get_elapse_time_in_ns(link->ctx, finish_timestamp, enter_timestamp);
-	} while (time_taken_in_ns < 50 * 1000000); //MAx T7 is 50ms
+
+	if (result == DC_OK && edpRev >= DP_EDP_12) {
+		/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
+		enter_timestamp = dm_get_timestamp(link->ctx);
+		do {
+			sinkstatus = 0;
+			result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
+			if (sinkstatus == 1)
+				break;
+			if (result != DC_OK)
+				break;
+			udelay(25);
+			finish_timestamp = dm_get_timestamp(link->ctx);
+			time_taken_in_ns = dm_get_elapse_time_in_ns(link->ctx, finish_timestamp, enter_timestamp);
+		} while (time_taken_in_ns < 50 * 1000000); //MAx T7 is 50ms
+	}
 
 	if (link->local_sink->edid_caps.panel_patch.extra_t7_ms > 0)
 		udelay(link->local_sink->edid_caps.panel_patch.extra_t7_ms * 1000);

commit b6adc57cff616da18ff8cff028d2ddf585c97334
Author: David Francis <David.Francis@amd.com>
Date:   Fri Aug 16 13:43:46 2019 -0400

    drm/amd/display: Initialize DSC PPS variables to 0
    
    For DSC MST, sometimes monitors would break out
    in full-screen static. The issue traced back to the
    PPS generation code, where these variables were being used
    uninitialized and were picking up garbage.
    
    memset to 0 to avoid this
    
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index d1df0541e10a..ddb855045767 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -525,6 +525,9 @@ bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
 		struct dsc_config dsc_cfg;
 		uint8_t dsc_packed_pps[128];
 
+		memset(&dsc_cfg, 0, sizeof(dsc_cfg));
+		memset(dsc_packed_pps, 0, 128);
+
 		/* Enable DSC hw block */
 		dsc_cfg.pic_width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
 		dsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;

commit 302f598804dc768cd2aa7ed7d6b7bfd326131819
Author: Dale Zhao <dale.zhao@amd.com>
Date:   Mon Dec 2 10:31:55 2019 +0800

    drm/amd/display: Use absolute time stamp to follow the eDP T7 spec requirement
    
    [Why]:
    According to eDP spec, max T7 delay should be 50 ms. Current code uses 300
    retry counters may not be accurate enough for different panels.
    
    [How]:
    Use absolute time stamp to achive accurate delay.
    
    Signed-off-by: Dale Zhao <dale.zhao@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 548aac02ca11..d1df0541e10a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -173,15 +173,20 @@ bool edp_receiver_ready_T9(struct dc_link *link)
 }
 bool edp_receiver_ready_T7(struct dc_link *link)
 {
-	unsigned int tries = 0;
 	unsigned char sinkstatus = 0;
 	unsigned char edpRev = 0;
 	enum dc_status result = DC_OK;
 
+	/* use absolute time stamp to constrain max T7*/
+	unsigned long long enter_timestamp = 0;
+	unsigned long long finish_timestamp = 0;
+	unsigned long long time_taken_in_ns = 0;
+
 	result = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));
 	if (result == DC_OK && edpRev < DP_EDP_12)
 		return true;
 	/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
+	enter_timestamp = dm_get_timestamp(link->ctx);
 	do {
 		sinkstatus = 0;
 		result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
@@ -189,8 +194,10 @@ bool edp_receiver_ready_T7(struct dc_link *link)
 			break;
 		if (result != DC_OK)
 			break;
-		udelay(25); //MAx T7 is 50ms
-	} while (++tries < 300);
+		udelay(25);
+		finish_timestamp = dm_get_timestamp(link->ctx);
+		time_taken_in_ns = dm_get_elapse_time_in_ns(link->ctx, finish_timestamp, enter_timestamp);
+	} while (time_taken_in_ns < 50 * 1000000); //MAx T7 is 50ms
 
 	if (link->local_sink->edid_caps.panel_patch.extra_t7_ms > 0)
 		udelay(link->local_sink->edid_caps.panel_patch.extra_t7_ms * 1000);

commit 832aa63bef346fc6a58bf46412036d368142fddf
Author: Paul Hsieh <paul.hsieh@amd.com>
Date:   Fri Nov 1 14:41:37 2019 +0800

    drm/amd/display: Reset PHY in link re-training
    
    [Why]
    Link training failed randomly when plugging USB-C display in/out.
    
    [How]
    If link training failed, reset PHY in link re-training.
    
    Signed-off-by: Paul Hsieh <paul.hsieh@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 67ce12df23f1..548aac02ca11 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -333,20 +333,12 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 			memset(&link->cur_link_settings, 0,
 				sizeof(link->cur_link_settings));
 
-			link->link_enc->funcs->enable_dp_output(
-						link->link_enc,
-						link_setting,
-						pipes[i].clock_source->id);
-			link->cur_link_settings = *link_setting;
-
-			dp_receiver_power_ctrl(link, true);
-
 			perform_link_training_with_retries(
-					link,
 					link_setting,
 					skip_video_pattern,
-					LINK_TRAINING_ATTEMPTS);
-
+					LINK_TRAINING_ATTEMPTS,
+					&pipes[i],
+					SIGNAL_TYPE_DISPLAY_PORT);
 
 			link->dc->hwss.enable_stream(&pipes[i]);
 

commit 2b77dcc5e5aa382832af93a581de8293db72d888
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:04:34 2019 -0500

    drm/amd/display: rename core_dc to dc
    
    [Why]
    First, to make code more consistent
    Second, to get rid of those scenario where we create a second
    local pointer to dc when it's already passed in.
    
    [How]
    Rename core_dc to dc
    Remove duplicate local pointers to dc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index bb1e8e5b5252..67ce12df23f1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -95,8 +95,8 @@ void dp_enable_link_phy(
 	const struct dc_link_settings *link_settings)
 {
 	struct link_encoder *link_enc = link->link_enc;
-	struct dc  *core_dc = link->ctx->dc;
-	struct dmcu *dmcu = core_dc->res_pool->dmcu;
+	struct dc  *dc = link->ctx->dc;
+	struct dmcu *dmcu = dc->res_pool->dmcu;
 
 	struct pipe_ctx *pipes =
 			link->dc->current_state->res_ctx.pipe_ctx;
@@ -200,8 +200,8 @@ bool edp_receiver_ready_T7(struct dc_link *link)
 
 void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {
-	struct dc  *core_dc = link->ctx->dc;
-	struct dmcu *dmcu = core_dc->res_pool->dmcu;
+	struct dc  *dc = link->ctx->dc;
+	struct dmcu *dmcu = dc->res_pool->dmcu;
 
 	if (!link->wa_flags.dp_keep_receiver_powered)
 		dp_receiver_power_ctrl(link, false);
@@ -395,14 +395,14 @@ static void dsc_optc_config_log(struct display_stream_compressor *dsc,
 
 static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 {
-	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	bool result = false;
 
-	if (IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
+	if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment))
 		result = true;
 	else
-		result = dm_helpers_dp_write_dsc_enable(core_dc->ctx, stream, enable);
+		result = dm_helpers_dp_write_dsc_enable(dc->ctx, stream, enable);
 	return result;
 }
 
@@ -412,7 +412,7 @@ static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 {
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
-	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct pipe_ctx *odm_pipe;
 	int opp_cnt = 1;
@@ -448,7 +448,7 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 		optc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;
 
 		/* Enable DSC in encoder */
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 			DC_LOG_DSC("Setting stream encoder DSC config for engine %d:", (int)pipe_ctx->stream_res.stream_enc->id);
 			dsc_optc_config_log(dsc, &dsc_optc_cfg);
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(pipe_ctx->stream_res.stream_enc,
@@ -473,7 +473,7 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 				OPTC_DSC_DISABLED, 0, 0);
 
 		/* disable DSC in stream encoder */
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(
 					pipe_ctx->stream_res.stream_enc,
 					OPTC_DSC_DISABLED, 0, 0);
@@ -516,7 +516,7 @@ bool dp_set_dsc_enable(struct pipe_ctx *pipe_ctx, bool enable)
 bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
 {
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
-	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc *dc = pipe_ctx->stream->ctx->dc;
 	struct dc_stream_state *stream = pipe_ctx->stream;
 
 	if (!pipe_ctx->stream->timing.flags.DSC || !dsc)
@@ -535,7 +535,7 @@ bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
 
 		DC_LOG_DSC(" ");
 		dsc->funcs->dsc_get_packed_pps(dsc, &dsc_cfg, &dsc_packed_pps[0]);
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 			DC_LOG_DSC("Setting stream encoder DSC PPS SDP for engine %d\n", (int)pipe_ctx->stream_res.stream_enc->id);
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(
 									pipe_ctx->stream_res.stream_enc,
@@ -544,7 +544,7 @@ bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
 		}
 	} else {
 		/* disable DSC PPS in stream encoder */
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(
 						pipe_ctx->stream_res.stream_enc, false, NULL);
 		}

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 5efbdc1eb173..bb1e8e5b5252 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -12,12 +12,8 @@
 #include "dc_link_ddc.h"
 #include "dm_helpers.h"
 #include "dpcd_defs.h"
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #include "dsc.h"
-#endif
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 #include "resource.h"
-#endif
 
 static uint8_t convert_to_count(uint8_t lttpr_repeater_count)
 {
@@ -374,7 +370,6 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 	}
 }
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #define DC_LOGGER \
 	dsc->ctx->logger
 static void dsc_optc_config_log(struct display_stream_compressor *dsc,
@@ -572,5 +567,4 @@ bool dp_update_dsc_config(struct pipe_ctx *pipe_ctx)
 	dp_set_dsc_pps_sdp(pipe_ctx, true);
 	return true;
 }
-#endif
 

commit 64c12b733fe7eaffa9207e6f30b313595c6e6597
Author: abdoulaye berthe <abdoulaye.berthe@amd.com>
Date:   Wed Jul 24 11:01:44 2019 -0400

    drm/amd/display: implement lttpr logic
    
    1-If at least one repeater is present in the link and we are in non
    transparent mode, perform clock recovery then channel equalization
    with all repeaters one by one before training DPRX.
    
    2-Mark the end of LT with a repeater by setting training pattern 0
    at the end of channel equalization with each repeater.
    
    Signed-off-by: abdoulaye berthe <abdoulaye.berthe@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index a519dbc5ecb6..5efbdc1eb173 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -19,6 +19,36 @@
 #include "resource.h"
 #endif
 
+static uint8_t convert_to_count(uint8_t lttpr_repeater_count)
+{
+	switch (lttpr_repeater_count) {
+	case 0x80: // 1 lttpr repeater
+		return 1;
+	case 0x40: // 2 lttpr repeaters
+		return 2;
+	case 0x20: // 3 lttpr repeaters
+		return 3;
+	case 0x10: // 4 lttpr repeaters
+		return 4;
+	case 0x08: // 5 lttpr repeaters
+		return 5;
+	case 0x04: // 6 lttpr repeaters
+		return 6;
+	case 0x02: // 7 lttpr repeaters
+		return 7;
+	case 0x01: // 8 lttpr repeaters
+		return 8;
+	default:
+		break;
+	}
+	return 0; // invalid value
+}
+
+static inline bool is_immediate_downstream(struct dc_link *link, uint32_t offset)
+{
+	return (convert_to_count(link->dpcd_caps.lttpr_caps.phy_repeater_cnt) == offset);
+}
+
 enum dc_status core_link_read_dpcd(
 	struct dc_link *link,
 	uint32_t address,
@@ -212,7 +242,8 @@ void dp_disable_link_phy_mst(struct dc_link *link, enum signal_type signal)
 
 bool dp_set_hw_training_pattern(
 	struct dc_link *link,
-	enum dc_dp_training_pattern pattern)
+	enum dc_dp_training_pattern pattern,
+	uint32_t offset)
 {
 	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
 
@@ -240,10 +271,14 @@ bool dp_set_hw_training_pattern(
 
 void dp_set_hw_lane_settings(
 	struct dc_link *link,
-	const struct link_training_settings *link_settings)
+	const struct link_training_settings *link_settings,
+	uint32_t offset)
 {
 	struct link_encoder *encoder = link->link_enc;
 
+	if (!link->is_lttpr_mode_transparent && !is_immediate_downstream(link, offset))
+		return;
+
 	/* call Encoder to set lane settings */
 	encoder->funcs->dp_set_lane_settings(encoder, link_settings);
 }

commit b131932215c993ea5adf8192d1de2e8d6b23048d
Author: Jing Zhou <Jing.Zhou@amd.com>
Date:   Thu Aug 22 14:26:33 2019 +0800

    drm/amd/display: verify stream link before link test
    
    [Why]
    DP1.2 LL CTS test failure.
    
    [How]
    The failure is caused by not verify stream link is equal
    to link, only check stream and link is not null.
    
    Signed-off-by: Jing Zhou <Jing.Zhou@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 79438c4f1e20..a519dbc5ecb6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -277,7 +277,8 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 		if (pipes[i].stream != NULL &&
 			!pipes[i].top_pipe && !pipes[i].prev_odm_pipe &&
 			pipes[i].stream->link != NULL &&
-			pipes[i].stream_res.stream_enc != NULL) {
+			pipes[i].stream_res.stream_enc != NULL &&
+			pipes[i].stream->link == link) {
 			udelay(100);
 
 			pipes[i].stream_res.stream_enc->funcs->dp_blank(

commit 574304041bb9508a4e73533e8d1702b0e713d321
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu Jul 25 14:43:55 2019 -0400

    drm/amd/display: fix audio endpoint not getting disabled issue
    
    [Why]
    Disable_audio_stream gets enum option as a paramenter which will decide
    if we free acquired resources or not. However checks for the option is
    guarded by the other condition which check if audio stream is getting
    diabled more than once. With both conditions combined, if we attempt to
    disable audio stream twice in a row, first with keep and second with
    free as an option, we will never free any resources, which will make
    system think there is audio endpoint connected even after we plug out
    the device
    
    [How]
    Get rid of option as parameter to disable_audio_stream and move the part
    of the code that free acquired resources to outside where to keep or to
    free resources is actually determined
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index fe9a4e4b9d1f..79438c4f1e20 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -289,7 +289,9 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			dp_receiver_power_ctrl(link, false);
 
-			link->dc->hwss.disable_stream(&pipes[i], KEEP_ACQUIRED_RESOURCE);
+			link->dc->hwss.disable_stream(&pipes[i]);
+			if ((&pipes[i])->stream_res.audio && !link->dc->debug.az_endpoint_mute_only)
+				(&pipes[i])->stream_res.audio->funcs->az_disable((&pipes[i])->stream_res.audio);
 
 			link->link_enc->funcs->disable_output(
 					link->link_enc,

commit b1f6d01c4a3b7eeb2eb035e79d425cd6a696fa45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 17:17:28 2019 -0400

    drm/amd/display: re structure odm to allow 4 to 1 support
    
    Currently odm is handled using top_bottom pipe by special casing
    the differing opps to differentiate from mpc combine.
    
    Since top/bottom pipe list was made to track mpc muxing this creates
    difficulties in adding a 4 pipe odm case support.
    
    Rather than continue using mpc combine list, this change reworks odm
    to use it's own linked list to keep track of odm combine pipes. This
    also opens up options for using mpo with odm, if a practical use case
    is ever found.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 35c5467e60e8..fe9a4e4b9d1f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -275,7 +275,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (pipes[i].stream != NULL &&
-			!pipes[i].top_pipe &&
+			!pipes[i].top_pipe && !pipes[i].prev_odm_pipe &&
 			pipes[i].stream->link != NULL &&
 			pipes[i].stream_res.stream_enc != NULL) {
 			udelay(100);
@@ -381,7 +381,11 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
 	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
 	struct dc_stream_state *stream = pipe_ctx->stream;
-	struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
+	struct pipe_ctx *odm_pipe;
+	int opp_cnt = 1;
+
+	for (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)
+		opp_cnt++;
 
 	if (enable) {
 		struct dsc_config dsc_cfg;
@@ -389,26 +393,24 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 		enum optc_dsc_mode optc_dsc_mode;
 
 		/* Enable DSC hw block */
-		dsc_cfg.pic_width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
+		dsc_cfg.pic_width = (stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right) / opp_cnt;
 		dsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;
 		dsc_cfg.pixel_encoding = stream->timing.pixel_encoding;
 		dsc_cfg.color_depth = stream->timing.display_color_depth;
 		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
+		ASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % opp_cnt == 0);
+		dsc_cfg.dc_dsc_cfg.num_slices_h /= opp_cnt;
+
+		dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);
+		dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
+		for (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe) {
+			struct display_stream_compressor *odm_dsc = odm_pipe->stream_res.dsc;
 
-		if (odm_pipe) {
-			struct display_stream_compressor *bot_dsc = odm_pipe->stream_res.dsc;
-
-			dsc_cfg.pic_width /= 2;
-			ASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % 2 == 0);
-			dsc_cfg.dc_dsc_cfg.num_slices_h /= 2;
-			dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);
-			bot_dsc->funcs->dsc_set_config(bot_dsc, &dsc_cfg, &dsc_optc_cfg);
-			dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
-			bot_dsc->funcs->dsc_enable(bot_dsc, odm_pipe->stream_res.opp->inst);
-		} else {
-			dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);
-			dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
+			odm_dsc->funcs->dsc_set_config(odm_dsc, &dsc_cfg, &dsc_optc_cfg);
+			odm_dsc->funcs->dsc_enable(odm_dsc, odm_pipe->stream_res.opp->inst);
 		}
+		dsc_cfg.dc_dsc_cfg.num_slices_h *= opp_cnt;
+		dsc_cfg.pic_width *= opp_cnt;
 
 		optc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;
 
@@ -449,7 +451,7 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 
 		/* disable DSC block */
 		pipe_ctx->stream_res.dsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);
-		if (odm_pipe)
+		for (odm_pipe = pipe_ctx->next_odm_pipe; odm_pipe; odm_pipe = odm_pipe->next_odm_pipe)
 			odm_pipe->stream_res.dsc->funcs->dsc_disable(odm_pipe->stream_res.dsc);
 	}
 }

commit 9b420a19bd077f81caadcb34738d7298550a7ed7
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Jul 25 18:46:54 2019 -0400

    drm/amd/display: Add and refine DSC logs in enable sequence
    
    [why]
    Some logs messages were not precise and some new log messages
    were needed after "get packed PPS" function was introduced
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index af65071b6cf5..35c5467e60e8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -342,10 +342,22 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 static void dsc_optc_config_log(struct display_stream_compressor *dsc,
 		struct dsc_optc_config *config)
 {
-	DC_LOG_DSC("Setting optc DSC config at DSC inst %d", dsc->inst);
-	DC_LOG_DSC("\n\tbytes_per_pixel %d\n\tis_pixel_format_444 %d\n\tslice_width %d",
-			config->bytes_per_pixel,
-			config->is_pixel_format_444, config->slice_width);
+	uint32_t precision = 1 << 28;
+	uint32_t bytes_per_pixel_int = config->bytes_per_pixel / precision;
+	uint32_t bytes_per_pixel_mod = config->bytes_per_pixel % precision;
+	uint64_t ll_bytes_per_pix_fraq = bytes_per_pixel_mod;
+
+	/* 7 fractional digits decimal precision for bytes per pixel is enough because DSC
+	 * bits per pixel precision is 1/16th of a pixel, which means bytes per pixel precision is
+	 * 1/16/8 = 1/128 of a byte, or 0.0078125 decimal
+	 */
+	ll_bytes_per_pix_fraq *= 10000000;
+	ll_bytes_per_pix_fraq /= precision;
+
+	DC_LOG_DSC("\tbytes_per_pixel 0x%08x (%d.%07d)",
+			config->bytes_per_pixel, bytes_per_pixel_int, (uint32_t)ll_bytes_per_pix_fraq);
+	DC_LOG_DSC("\tis_pixel_format_444 %d", config->is_pixel_format_444);
+	DC_LOG_DSC("\tslice_width %d", config->slice_width);
 }
 
 static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
@@ -400,17 +412,21 @@ void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 
 		optc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;
 
-		dsc_optc_config_log(dsc, &dsc_optc_cfg);
 		/* Enable DSC in encoder */
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+			DC_LOG_DSC("Setting stream encoder DSC config for engine %d:", (int)pipe_ctx->stream_res.stream_enc->id);
+			dsc_optc_config_log(dsc, &dsc_optc_cfg);
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(pipe_ctx->stream_res.stream_enc,
 									optc_dsc_mode,
 									dsc_optc_cfg.bytes_per_pixel,
 									dsc_optc_cfg.slice_width);
 
 			/* PPS SDP is set elsewhere because it has to be done after DIG FE is connected to DIG BE */
+		}
 
 		/* Enable DSC in OPTC */
+		DC_LOG_DSC("Setting optc DSC config for tg instance %d:", pipe_ctx->stream_res.tg->inst);
+		dsc_optc_config_log(dsc, &dsc_optc_cfg);
 		pipe_ctx->stream_res.tg->funcs->set_dsc_config(pipe_ctx->stream_res.tg,
 							optc_dsc_mode,
 							dsc_optc_cfg.bytes_per_pixel,
@@ -482,13 +498,15 @@ bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
 		dsc_cfg.color_depth = stream->timing.display_color_depth;
 		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
 
+		DC_LOG_DSC(" ");
 		dsc->funcs->dsc_get_packed_pps(dsc, &dsc_cfg, &dsc_packed_pps[0]);
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+			DC_LOG_DSC("Setting stream encoder DSC PPS SDP for engine %d\n", (int)pipe_ctx->stream_res.stream_enc->id);
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(
 									pipe_ctx->stream_res.stream_enc,
 									true,
 									&dsc_packed_pps[0]);
-
+		}
 	} else {
 		/* disable DSC PPS in stream encoder */
 		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {

commit 1a9e3d4569fc9a9a1cbfb14cacf3268114646ab6
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Wed Jul 17 19:02:14 2019 -0400

    drm/amd/display: Set DSC before DIG front-end is connected to its back-end
    
    [why]
    At the time DIG FE is connected to its BE, the clocks in OTG are enabled and
    PHY will also be set up. When DSC has to be used to fit the stream into the
    available bandwidth, without DSC being set DIG could get exposed to the
    higer bandwidth it (or link) could handle. This causes the HW to "reject"
    video enable setup (the register shows that video enable was attempted, but
    the status bit shows it as disabled).
    
    [how]
    - Separate DSC setup into DSC register config and DSC PPS SDP setup
    
    - Move most of the DSC setup (register config) to before
      dcn10_link_encoder_connect_dig_be_to_fe() is  called
    
    - Set up DSC PPS SDP after DIG FE is connected to its BE. This is because
      setting DSC PPS SDP before that has no effect.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index daaff7319413..af65071b6cf5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -361,9 +361,10 @@ static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 	return result;
 }
 
-/* This has to be done after DSC was enabled on RX first, i.e. after dp_enable_dsc_on_rx() had been called
+/* The stream with these settings can be sent (unblanked) only after DSC was enabled on RX first,
+ * i.e. after dp_enable_dsc_on_rx() had been called
  */
-void set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
+void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 {
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
 	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
@@ -371,11 +372,9 @@ void set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 	struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
 
 	if (enable) {
-		/* TODO proper function */
 		struct dsc_config dsc_cfg;
 		struct dsc_optc_config dsc_optc_cfg;
 		enum optc_dsc_mode optc_dsc_mode;
-		uint8_t dsc_packed_pps[128];
 
 		/* Enable DSC hw block */
 		dsc_cfg.pic_width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
@@ -384,19 +383,20 @@ void set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 		dsc_cfg.color_depth = stream->timing.display_color_depth;
 		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
 
-		dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg, &dsc_packed_pps[0]);
 		if (odm_pipe) {
 			struct display_stream_compressor *bot_dsc = odm_pipe->stream_res.dsc;
-			uint8_t dsc_packed_pps_odm[128];
 
 			dsc_cfg.pic_width /= 2;
 			ASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % 2 == 0);
 			dsc_cfg.dc_dsc_cfg.num_slices_h /= 2;
-			dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg, &dsc_packed_pps_odm[0]);
-			bot_dsc->funcs->dsc_set_config(bot_dsc, &dsc_cfg, &dsc_optc_cfg, &dsc_packed_pps_odm[0]);
+			dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);
+			bot_dsc->funcs->dsc_set_config(bot_dsc, &dsc_cfg, &dsc_optc_cfg);
+			dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
 			bot_dsc->funcs->dsc_enable(bot_dsc, odm_pipe->stream_res.opp->inst);
+		} else {
+			dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg);
+			dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
 		}
-		dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
 
 		optc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;
 
@@ -406,8 +406,9 @@ void set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(pipe_ctx->stream_res.stream_enc,
 									optc_dsc_mode,
 									dsc_optc_cfg.bytes_per_pixel,
-									dsc_optc_cfg.slice_width,
-									&dsc_packed_pps[0]);
+									dsc_optc_cfg.slice_width);
+
+			/* PPS SDP is set elsewhere because it has to be done after DIG FE is connected to DIG BE */
 
 		/* Enable DSC in OPTC */
 		pipe_ctx->stream_res.tg->funcs->set_dsc_config(pipe_ctx->stream_res.tg,
@@ -421,10 +422,14 @@ void set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 				OPTC_DSC_DISABLED, 0, 0);
 
 		/* disable DSC in stream encoder */
-		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(
 					pipe_ctx->stream_res.stream_enc,
-					OPTC_DSC_DISABLED, 0, 0, NULL);
+					OPTC_DSC_DISABLED, 0, 0);
+
+			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(
+					pipe_ctx->stream_res.stream_enc, false, NULL);
+		}
 
 		/* disable DSC block */
 		pipe_ctx->stream_res.dsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);
@@ -445,18 +450,57 @@ bool dp_set_dsc_enable(struct pipe_ctx *pipe_ctx, bool enable)
 
 	if (enable) {
 		if (dp_set_dsc_on_rx(pipe_ctx, true)) {
-			set_dsc_on_stream(pipe_ctx, true);
+			dp_set_dsc_on_stream(pipe_ctx, true);
 			result = true;
 		}
 	} else {
 		dp_set_dsc_on_rx(pipe_ctx, false);
-		set_dsc_on_stream(pipe_ctx, false);
+		dp_set_dsc_on_stream(pipe_ctx, false);
 		result = true;
 	}
 out:
 	return result;
 }
 
+bool dp_set_dsc_pps_sdp(struct pipe_ctx *pipe_ctx, bool enable)
+{
+	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
+	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc_stream_state *stream = pipe_ctx->stream;
+
+	if (!pipe_ctx->stream->timing.flags.DSC || !dsc)
+		return false;
+
+	if (enable) {
+		struct dsc_config dsc_cfg;
+		uint8_t dsc_packed_pps[128];
+
+		/* Enable DSC hw block */
+		dsc_cfg.pic_width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
+		dsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;
+		dsc_cfg.pixel_encoding = stream->timing.pixel_encoding;
+		dsc_cfg.color_depth = stream->timing.display_color_depth;
+		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
+
+		dsc->funcs->dsc_get_packed_pps(dsc, &dsc_cfg, &dsc_packed_pps[0]);
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
+			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(
+									pipe_ctx->stream_res.stream_enc,
+									true,
+									&dsc_packed_pps[0]);
+
+	} else {
+		/* disable DSC PPS in stream encoder */
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_pps_info_packet(
+						pipe_ctx->stream_res.stream_enc, false, NULL);
+		}
+	}
+
+	return true;
+}
+
+
 bool dp_update_dsc_config(struct pipe_ctx *pipe_ctx)
 {
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
@@ -466,9 +510,9 @@ bool dp_update_dsc_config(struct pipe_ctx *pipe_ctx)
 	if (!dsc)
 		return false;
 
-	set_dsc_on_stream(pipe_ctx, true);
+	dp_set_dsc_on_stream(pipe_ctx, true);
+	dp_set_dsc_pps_sdp(pipe_ctx, true);
 	return true;
 }
-
 #endif
 

commit 0b226322434c7786381d7a594efca9cc46f85211
Author: David Galiffi <david.galiffi@amd.com>
Date:   Mon Jun 24 10:34:13 2019 -0400

    drm/amd/display: Synchronous DisplayPort Link Training
    
    [WHY]
    We require a method to perform synchronous link training.
    
    [HOW]
    Sync LT is broken into 3 basic steps.
    "Begin" starts the state machine, and resets "preferred" link settings.
    "Attempt" will attempt to train the link with a given set of training
    parameters.
    "End" stops the state machine, and will optionally disable the link phy.
    Between "Begin" and "End" DPCD:600h must not be set to "2"
    (D3:Powered Down).
    Between "Begin" and "End", there may be multiple "Attempts" with different
    training parameters.
    
    Signed-off-by: David Galiffi <david.galiffi@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 878f47b59d5a..daaff7319413 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -55,6 +55,9 @@ void dp_receiver_power_ctrl(struct dc_link *link, bool on)
 
 	state = on ? DP_POWER_STATE_D0 : DP_POWER_STATE_D3;
 
+	if (link->sync_lt_in_progress)
+		return;
+
 	core_link_write_dpcd(link, DP_SET_POWER, &state,
 			sizeof(state));
 }
@@ -245,46 +248,6 @@ void dp_set_hw_lane_settings(
 	encoder->funcs->dp_set_lane_settings(encoder, link_settings);
 }
 
-enum dp_panel_mode dp_get_panel_mode(struct dc_link *link)
-{
-	/* We need to explicitly check that connector
-	 * is not DP. Some Travis_VGA get reported
-	 * by video bios as DP.
-	 */
-	if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
-
-		switch (link->dpcd_caps.branch_dev_id) {
-		case DP_BRANCH_DEVICE_ID_2:
-			if (strncmp(
-				link->dpcd_caps.branch_dev_name,
-				DP_VGA_LVDS_CONVERTER_ID_2,
-				sizeof(
-				link->dpcd_caps.
-				branch_dev_name)) == 0) {
-				return DP_PANEL_MODE_SPECIAL;
-			}
-			break;
-		case DP_BRANCH_DEVICE_ID_3:
-			if (strncmp(link->dpcd_caps.branch_dev_name,
-				DP_VGA_LVDS_CONVERTER_ID_3,
-				sizeof(
-				link->dpcd_caps.
-				branch_dev_name)) == 0) {
-				return DP_PANEL_MODE_SPECIAL;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (link->dpcd_caps.panel_mode_edp) {
-		return DP_PANEL_MODE_EDP;
-	}
-
-	return DP_PANEL_MODE_DEFAULT;
-}
-
 void dp_set_hw_test_pattern(
 	struct dc_link *link,
 	enum dp_test_pattern test_pattern,

commit 88eac241a1fc500ce5274a09ddc4bd5fc2b5adb6
Author: Anthony Koo <anthony.koo@amd.com>
Date:   Wed Jun 12 16:30:15 2019 -0400

    drm/amd/display: add monitor patch to add T7 delay
    
    [Why]
    Specifically to one panel,
    TCON is able to accept active video signal quickly, but
    the Source Driver requires 2-3 frames of extra time.
    
    It is a Panel issue since TCON needs to take care of
    all Sink requirements including Source Driver. But in
    this case it does not.
    
    Customer is asking to add fixed T7 delay as panel
    workaround.
    
    [How]
    Add monitor specific patch to add T7 delay
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 46257f0fcbe7..878f47b59d5a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -162,6 +162,10 @@ bool edp_receiver_ready_T7(struct dc_link *link)
 			break;
 		udelay(25); //MAx T7 is 50ms
 	} while (++tries < 300);
+
+	if (link->local_sink->edid_caps.panel_patch.extra_t7_ms > 0)
+		udelay(link->local_sink->edid_caps.panel_patch.extra_t7_ms * 1000);
+
 	return result;
 }
 

commit 606b355170b56549890e8202a2b62f97d28b395e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 5 16:35:08 2019 -0400

    drm/amd/display: add hdmi2.1 dsc pps packet programming
    
    This change adds EMP packet programming for enabling dsc with
    hdmi. The packets are structured according to VESA HDMI 2.1x
    r2 spec, section 10.10.2.2.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 211fadefe2f5..46257f0fcbe7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -396,7 +396,7 @@ static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
 
 /* This has to be done after DSC was enabled on RX first, i.e. after dp_enable_dsc_on_rx() had been called
  */
-static void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
+void set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 {
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
 	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
@@ -435,7 +435,7 @@ static void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 
 		dsc_optc_config_log(dsc, &dsc_optc_cfg);
 		/* Enable DSC in encoder */
-		if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment) && pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config)
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(pipe_ctx->stream_res.stream_enc,
 									optc_dsc_mode,
 									dsc_optc_cfg.bytes_per_pixel,
@@ -454,11 +454,10 @@ static void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 				OPTC_DSC_DISABLED, 0, 0);
 
 		/* disable DSC in stream encoder */
-		if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+		if (dc_is_dp_signal(stream->signal) && !IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
 			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(
 					pipe_ctx->stream_res.stream_enc,
 					OPTC_DSC_DISABLED, 0, 0, NULL);
-		}
 
 		/* disable DSC block */
 		pipe_ctx->stream_res.dsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);
@@ -479,12 +478,12 @@ bool dp_set_dsc_enable(struct pipe_ctx *pipe_ctx, bool enable)
 
 	if (enable) {
 		if (dp_set_dsc_on_rx(pipe_ctx, true)) {
-			dp_set_dsc_on_stream(pipe_ctx, true);
+			set_dsc_on_stream(pipe_ctx, true);
 			result = true;
 		}
 	} else {
 		dp_set_dsc_on_rx(pipe_ctx, false);
-		dp_set_dsc_on_stream(pipe_ctx, false);
+		set_dsc_on_stream(pipe_ctx, false);
 		result = true;
 	}
 out:
@@ -500,7 +499,7 @@ bool dp_update_dsc_config(struct pipe_ctx *pipe_ctx)
 	if (!dsc)
 		return false;
 
-	dp_set_dsc_on_stream(pipe_ctx, true);
+	set_dsc_on_stream(pipe_ctx, true);
 	return true;
 }
 

commit e0a6440a2961b1da3ea895b0bef082fc1a78e190
Author: David Galiffi <David.Galiffi@amd.com>
Date:   Thu May 30 11:56:39 2019 -0400

    drm/amd/display: Add ability to set preferred link training parameters.
    
    [WHY]
    To add support for OS requirement to set preferred link training
    parameters.
    
    [HOW]
    Create new structure of dp link training overrides. During link training
    processes, these values should be used instead of the default training
    parameters.
    
    Signed-off-by: David Galiffi <David.Galiffi@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 2d019e1f6135..211fadefe2f5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -25,10 +25,11 @@ enum dc_status core_link_read_dpcd(
 	uint8_t *data,
 	uint32_t size)
 {
-	if (!dm_helpers_dp_read_dpcd(link->ctx,
-			link,
-			address, data, size))
-			return DC_ERROR_UNEXPECTED;
+	if (!link->aux_access_disabled &&
+			!dm_helpers_dp_read_dpcd(link->ctx,
+			link, address, data, size)) {
+		return DC_ERROR_UNEXPECTED;
+	}
 
 	return DC_OK;
 }
@@ -39,10 +40,11 @@ enum dc_status core_link_write_dpcd(
 	const uint8_t *data,
 	uint32_t size)
 {
-	if (!dm_helpers_dp_write_dpcd(link->ctx,
-			link,
-			address, data, size))
-				return DC_ERROR_UNEXPECTED;
+	if (!link->aux_access_disabled &&
+			!dm_helpers_dp_write_dpcd(link->ctx,
+			link, address, data, size)) {
+		return DC_ERROR_UNEXPECTED;
+	}
 
 	return DC_OK;
 }
@@ -203,21 +205,21 @@ void dp_disable_link_phy_mst(struct dc_link *link, enum signal_type signal)
 
 bool dp_set_hw_training_pattern(
 	struct dc_link *link,
-	enum hw_dp_training_pattern pattern)
+	enum dc_dp_training_pattern pattern)
 {
 	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
 
 	switch (pattern) {
-	case HW_DP_TRAINING_PATTERN_1:
+	case DP_TRAINING_PATTERN_SEQUENCE_1:
 		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN1;
 		break;
-	case HW_DP_TRAINING_PATTERN_2:
+	case DP_TRAINING_PATTERN_SEQUENCE_2:
 		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN2;
 		break;
-	case HW_DP_TRAINING_PATTERN_3:
+	case DP_TRAINING_PATTERN_SEQUENCE_3:
 		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN3;
 		break;
-	case HW_DP_TRAINING_PATTERN_4:
+	case DP_TRAINING_PATTERN_SEQUENCE_4:
 		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN4;
 		break;
 	default:

commit ba32c50f04466463258546a8e75ff8ddd6776bd5
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Mon May 6 14:22:39 2019 -0400

    drm/amd/display: decouple dsc adjustment out of enablement
    
    [why]
    dsc adjustment is allowed via stream update sequence.
    dsc enablement is only allowed via commit stream sequence.
    with the current unified dsc set function, it is hard
    to determine which sequence it is called by.
    The solution is to decouple dsc adjustment out of enablement
    sequence so we can handle them separately.
    
    [how]
    decouple dsc adjustment out of enablement.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 8b22af9085e4..2d019e1f6135 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -467,41 +467,40 @@ static void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
 
 bool dp_set_dsc_enable(struct pipe_ctx *pipe_ctx, bool enable)
 {
-	struct dc_stream_state *stream = pipe_ctx->stream;
 	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
 	bool result = false;
 
+	if (!pipe_ctx->stream->timing.flags.DSC)
+		goto out;
 	if (!dsc)
 		goto out;
 
-	if (enable && stream->is_dsc_enabled) {
-		/* update dsc stream */
-		dp_set_dsc_on_stream(pipe_ctx, true);
-		stream->is_dsc_enabled = true;
-		result = true;
-	} else if (enable && !stream->is_dsc_enabled) {
-		/* enable dsc on non dsc stream */
+	if (enable) {
 		if (dp_set_dsc_on_rx(pipe_ctx, true)) {
 			dp_set_dsc_on_stream(pipe_ctx, true);
-			stream->is_dsc_enabled = true;
 			result = true;
-		} else {
-			stream->is_dsc_enabled = false;
-			result = false;
 		}
-	} else if (!enable && stream->is_dsc_enabled) {
-		/* disable dsc on dsc stream */
+	} else {
 		dp_set_dsc_on_rx(pipe_ctx, false);
 		dp_set_dsc_on_stream(pipe_ctx, false);
-		stream->is_dsc_enabled = false;
-		result = true;
-	} else {
-		/* disable dsc on non dsc stream */
 		result = true;
 	}
 out:
 	return result;
 }
 
+bool dp_update_dsc_config(struct pipe_ctx *pipe_ctx)
+{
+	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
+
+	if (!pipe_ctx->stream->timing.flags.DSC)
+		return false;
+	if (!dsc)
+		return false;
+
+	dp_set_dsc_on_stream(pipe_ctx, true);
+	return true;
+}
+
 #endif
 

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index b0dea759cd86..8b22af9085e4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -12,6 +12,12 @@
 #include "dc_link_ddc.h"
 #include "dm_helpers.h"
 #include "dpcd_defs.h"
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+#include "dsc.h"
+#endif
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+#include "resource.h"
+#endif
 
 enum dc_status core_link_read_dpcd(
 	struct dc_link *link,
@@ -360,3 +366,142 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 		}
 	}
 }
+
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+#define DC_LOGGER \
+	dsc->ctx->logger
+static void dsc_optc_config_log(struct display_stream_compressor *dsc,
+		struct dsc_optc_config *config)
+{
+	DC_LOG_DSC("Setting optc DSC config at DSC inst %d", dsc->inst);
+	DC_LOG_DSC("\n\tbytes_per_pixel %d\n\tis_pixel_format_444 %d\n\tslice_width %d",
+			config->bytes_per_pixel,
+			config->is_pixel_format_444, config->slice_width);
+}
+
+static bool dp_set_dsc_on_rx(struct pipe_ctx *pipe_ctx, bool enable)
+{
+	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	bool result = false;
+
+	if (IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment))
+		result = true;
+	else
+		result = dm_helpers_dp_write_dsc_enable(core_dc->ctx, stream, enable);
+	return result;
+}
+
+/* This has to be done after DSC was enabled on RX first, i.e. after dp_enable_dsc_on_rx() had been called
+ */
+static void dp_set_dsc_on_stream(struct pipe_ctx *pipe_ctx, bool enable)
+{
+	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
+	struct dc *core_dc = pipe_ctx->stream->ctx->dc;
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct pipe_ctx *odm_pipe = dc_res_get_odm_bottom_pipe(pipe_ctx);
+
+	if (enable) {
+		/* TODO proper function */
+		struct dsc_config dsc_cfg;
+		struct dsc_optc_config dsc_optc_cfg;
+		enum optc_dsc_mode optc_dsc_mode;
+		uint8_t dsc_packed_pps[128];
+
+		/* Enable DSC hw block */
+		dsc_cfg.pic_width = stream->timing.h_addressable + stream->timing.h_border_left + stream->timing.h_border_right;
+		dsc_cfg.pic_height = stream->timing.v_addressable + stream->timing.v_border_top + stream->timing.v_border_bottom;
+		dsc_cfg.pixel_encoding = stream->timing.pixel_encoding;
+		dsc_cfg.color_depth = stream->timing.display_color_depth;
+		dsc_cfg.dc_dsc_cfg = stream->timing.dsc_cfg;
+
+		dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg, &dsc_packed_pps[0]);
+		if (odm_pipe) {
+			struct display_stream_compressor *bot_dsc = odm_pipe->stream_res.dsc;
+			uint8_t dsc_packed_pps_odm[128];
+
+			dsc_cfg.pic_width /= 2;
+			ASSERT(dsc_cfg.dc_dsc_cfg.num_slices_h % 2 == 0);
+			dsc_cfg.dc_dsc_cfg.num_slices_h /= 2;
+			dsc->funcs->dsc_set_config(dsc, &dsc_cfg, &dsc_optc_cfg, &dsc_packed_pps_odm[0]);
+			bot_dsc->funcs->dsc_set_config(bot_dsc, &dsc_cfg, &dsc_optc_cfg, &dsc_packed_pps_odm[0]);
+			bot_dsc->funcs->dsc_enable(bot_dsc, odm_pipe->stream_res.opp->inst);
+		}
+		dsc->funcs->dsc_enable(dsc, pipe_ctx->stream_res.opp->inst);
+
+		optc_dsc_mode = dsc_optc_cfg.is_pixel_format_444 ? OPTC_DSC_ENABLED_444 : OPTC_DSC_ENABLED_NATIVE_SUBSAMPLED;
+
+		dsc_optc_config_log(dsc, &dsc_optc_cfg);
+		/* Enable DSC in encoder */
+		if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment) && pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config)
+			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(pipe_ctx->stream_res.stream_enc,
+									optc_dsc_mode,
+									dsc_optc_cfg.bytes_per_pixel,
+									dsc_optc_cfg.slice_width,
+									&dsc_packed_pps[0]);
+
+		/* Enable DSC in OPTC */
+		pipe_ctx->stream_res.tg->funcs->set_dsc_config(pipe_ctx->stream_res.tg,
+							optc_dsc_mode,
+							dsc_optc_cfg.bytes_per_pixel,
+							dsc_optc_cfg.slice_width);
+	} else {
+		/* disable DSC in OPTC */
+		pipe_ctx->stream_res.tg->funcs->set_dsc_config(
+				pipe_ctx->stream_res.tg,
+				OPTC_DSC_DISABLED, 0, 0);
+
+		/* disable DSC in stream encoder */
+		if (!IS_FPGA_MAXIMUS_DC(core_dc->ctx->dce_environment)) {
+			pipe_ctx->stream_res.stream_enc->funcs->dp_set_dsc_config(
+					pipe_ctx->stream_res.stream_enc,
+					OPTC_DSC_DISABLED, 0, 0, NULL);
+		}
+
+		/* disable DSC block */
+		pipe_ctx->stream_res.dsc->funcs->dsc_disable(pipe_ctx->stream_res.dsc);
+		if (odm_pipe)
+			odm_pipe->stream_res.dsc->funcs->dsc_disable(odm_pipe->stream_res.dsc);
+	}
+}
+
+bool dp_set_dsc_enable(struct pipe_ctx *pipe_ctx, bool enable)
+{
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	struct display_stream_compressor *dsc = pipe_ctx->stream_res.dsc;
+	bool result = false;
+
+	if (!dsc)
+		goto out;
+
+	if (enable && stream->is_dsc_enabled) {
+		/* update dsc stream */
+		dp_set_dsc_on_stream(pipe_ctx, true);
+		stream->is_dsc_enabled = true;
+		result = true;
+	} else if (enable && !stream->is_dsc_enabled) {
+		/* enable dsc on non dsc stream */
+		if (dp_set_dsc_on_rx(pipe_ctx, true)) {
+			dp_set_dsc_on_stream(pipe_ctx, true);
+			stream->is_dsc_enabled = true;
+			result = true;
+		} else {
+			stream->is_dsc_enabled = false;
+			result = false;
+		}
+	} else if (!enable && stream->is_dsc_enabled) {
+		/* disable dsc on dsc stream */
+		dp_set_dsc_on_rx(pipe_ctx, false);
+		dp_set_dsc_on_stream(pipe_ctx, false);
+		stream->is_dsc_enabled = false;
+		result = true;
+	} else {
+		/* disable dsc on non dsc stream */
+		result = true;
+	}
+out:
+	return result;
+}
+
+#endif
+

commit a9a3c0da1427153e74a4ad97b1a897384a6b0404
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Mon Apr 8 15:27:53 2019 -0400

    drm/amd/display: add explicit handshake between x86 and DMCU
    
    [why]
    When DMCU interrupts x86, it leads to undefined phy programming
    
    [how]
    expand dmcu interface to support new PHY lock and unlock commands
    if DMCU FW doesn't support these commands, they fail silently so its okay
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index f7f7515f65f4..b0dea759cd86 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -58,6 +58,8 @@ void dp_enable_link_phy(
 	const struct dc_link_settings *link_settings)
 {
 	struct link_encoder *link_enc = link->link_enc;
+	struct dc  *core_dc = link->ctx->dc;
+	struct dmcu *dmcu = core_dc->res_pool->dmcu;
 
 	struct pipe_ctx *pipes =
 			link->dc->current_state->res_ctx.pipe_ctx;
@@ -84,6 +86,9 @@ void dp_enable_link_phy(
 		}
 	}
 
+	if (dmcu != NULL && dmcu->funcs->lock_phy)
+		dmcu->funcs->lock_phy(dmcu);
+
 	if (dc_is_dp_sst_signal(signal)) {
 		link_enc->funcs->enable_dp_output(
 						link_enc,
@@ -95,6 +100,10 @@ void dp_enable_link_phy(
 						link_settings,
 						clock_source);
 	}
+
+	if (dmcu != NULL && dmcu->funcs->unlock_phy)
+		dmcu->funcs->unlock_phy(dmcu);
+
 	link->cur_link_settings = *link_settings;
 
 	dp_receiver_power_ctrl(link, true);
@@ -150,15 +159,25 @@ bool edp_receiver_ready_T7(struct dc_link *link)
 
 void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {
+	struct dc  *core_dc = link->ctx->dc;
+	struct dmcu *dmcu = core_dc->res_pool->dmcu;
+
 	if (!link->wa_flags.dp_keep_receiver_powered)
 		dp_receiver_power_ctrl(link, false);
 
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->disable_output(link->link_enc, signal);
 		link->dc->hwss.edp_power_control(link, false);
-	} else
+	} else {
+		if (dmcu != NULL && dmcu->funcs->lock_phy)
+			dmcu->funcs->lock_phy(dmcu);
+
 		link->link_enc->funcs->disable_output(link->link_enc, signal);
 
+		if (dmcu != NULL && dmcu->funcs->unlock_phy)
+			dmcu->funcs->unlock_phy(dmcu);
+	}
+
 	/* Clear current link setting.*/
 	memset(&link->cur_link_settings, 0,
 			sizeof(link->cur_link_settings));

commit a4f1d2b8a543e136a0c945ca85d5d64ab471ac2a
Author: Xiaodong Yan <Xiaodong.Yan@amd.com>
Date:   Thu Jan 17 00:18:01 2019 +0800

    drm/amd/display: Add monitor patch for backlight off
    
    [Why]
    Different panel need different time from backlight disable to end of valid video data,
    if the time is too short, panel will flash when dpms off
    
    [How]
    Add monitor patch to control the time from backlight disable to end of valid video data,
    
    Signed-off-by: Xiaodong Yan <Xiaodong.Yan@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 16d441d3af8a..f7f7515f65f4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -119,6 +119,10 @@ bool edp_receiver_ready_T9(struct dc_link *link)
 			break;
 		udelay(100); //MAx T9
 	} while (++tries < 50);
+
+	if (link->local_sink->edid_caps.panel_patch.extra_delay_backlight_off > 0)
+		udelay(link->local_sink->edid_caps.panel_patch.extra_delay_backlight_off * 1000);
+
 	return result;
 }
 bool edp_receiver_ready_T7(struct dc_link *link)

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index a179c09580c3..16d441d3af8a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -74,8 +74,8 @@ void dp_enable_link_phy(
 			if (pipes[i].clock_source != NULL &&
 					pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
 				pipes[i].clock_source = dp_cs;
-				pipes[i].stream_res.pix_clk_params.requested_pix_clk =
-						pipes[i].stream->timing.pix_clk_khz;
+				pipes[i].stream_res.pix_clk_params.requested_pix_clk_100hz =
+						pipes[i].stream->timing.pix_clk_100hz;
 				pipes[i].clock_source->funcs->program_pix_clk(
 							pipes[i].clock_source,
 							&pipes[i].stream_res.pix_clk_params,

commit ceb3dbb4690db8377ad127a5666cd4775d9f70f4
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 9 09:21:21 2018 -0500

    drm/amd/display: remove sink reference in dc_stream_state
    
    [why]
    dc_stream_state containing a pointer to sink is poor design.
    Sink describes the display, and the specifications or capabilities
    it has.  That information is irrelevant for dc_stream_state, which describes
    hardware state, and is generally used for hardware programming.  It
    could further be argued that dc_sink itself is just a convenience dc
    provides, and DC should be perfectly capable of programming hardware
    without any dc_sinks (for example, emulated sinks).
    
    [how]
    Phase 1:
    Deprecate use of dc_sink pointer in dc_stream.  Most references are trivial
    to remove, but some call sites are risky (such as is_timing_changed) with
    no obvious logical replacement.  These will be removed in follow up change.
    
    Add dc_link pointer to dc_stream.  This is the typical reason DC really needed
    sink pointer, and most call sites are replaced with this.
    
    DMs also need minor updates, as all 3 DMs leverage stream->sink for
    some functionality.  this is replaced instead by a pointer to private data
    inside dc_stream_state, which is used by DMs as a quality of life improvment
    for some key functionality.  it allows DMs to set pointers have to their own objects
    which associate OS objects to dc_stream_states (such as DisplayTarget
    and amdgpu_dm_connector).  Without the private pointer, DMs would be
    forced to perform a lookup for callbacks.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 0065ec7d5330..a179c09580c3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -70,8 +70,7 @@ void dp_enable_link_phy(
 	 */
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (pipes[i].stream != NULL &&
-			pipes[i].stream->sink != NULL &&
-			pipes[i].stream->sink->link == link) {
+			pipes[i].stream->link == link) {
 			if (pipes[i].clock_source != NULL &&
 					pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
 				pipes[i].clock_source = dp_cs;
@@ -279,10 +278,8 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (pipes[i].stream != NULL &&
 			!pipes[i].top_pipe &&
-			pipes[i].stream->sink != NULL &&
-			pipes[i].stream->sink->link != NULL &&
-			pipes[i].stream_res.stream_enc != NULL &&
-			pipes[i].stream->sink->link == link) {
+			pipes[i].stream->link != NULL &&
+			pipes[i].stream_res.stream_enc != NULL) {
 			udelay(100);
 
 			pipes[i].stream_res.stream_enc->funcs->dp_blank(

commit 1ae62f3114a95982f2f4cbe5c7bd14b81233597a
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Mon Dec 3 17:26:15 2018 -0500

    drm/amd/display: verify lane status before exiting verify link cap
    
    [why]
    DP LL CTS1.4 4.3.2.1 test failure.
    
    [how]
    The failure is caused by not handling DP link loss
    hpd short pusle during set mode. The change is to read link status
    before set mode link training. If link is lost, re-verify link caps.
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 82cd1d6e6e59..0065ec7d5330 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -96,6 +96,7 @@ void dp_enable_link_phy(
 						link_settings,
 						clock_source);
 	}
+	link->cur_link_settings = *link_settings;
 
 	dp_receiver_power_ctrl(link, true);
 }
@@ -307,6 +308,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 						link->link_enc,
 						link_setting,
 						pipes[i].clock_source->id);
+			link->cur_link_settings = *link_setting;
 
 			dp_receiver_power_ctrl(link, true);
 
@@ -316,7 +318,6 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 					skip_video_pattern,
 					LINK_TRAINING_ATTEMPTS);
 
-			link->cur_link_settings = *link_setting;
 
 			link->dc->hwss.enable_stream(&pipes[i]);
 

commit f0cd0a346dfd1df4b691fe38dafb51911392fbce
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Apr 26 14:06:00 2018 -0400

    drm/amd/display: DCN1 link encoder
    
    Create DCN1 link encoder files and update AUX and HPD register access.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 7c866a7d5e77..82cd1d6e6e59 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -11,8 +11,6 @@
 #include "dc_link_dp.h"
 #include "dc_link_ddc.h"
 #include "dm_helpers.h"
-#include "dce/dce_link_encoder.h"
-#include "dce/dce_stream_encoder.h"
 #include "dpcd_defs.h"
 
 enum dc_status core_link_read_dpcd(

commit 94405cf63884e364ec560d99af47084cb1b47b5f
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Fri Feb 16 14:04:16 2018 -0500

    drm/amd/display: Update Link Training Fallback logic
    
    [Description]
    When CR fails to minimum link rate,
    we should reduce lane count to the number lowest cr_done lanes.
    
    [Code Review]
    Jun Lei
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index bae9b0587e12..7c866a7d5e77 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -279,6 +279,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (pipes[i].stream != NULL &&
+			!pipes[i].top_pipe &&
 			pipes[i].stream->sink != NULL &&
 			pipes[i].stream->sink->link != NULL &&
 			pipes[i].stream_res.stream_enc != NULL &&

commit 5180d4a4766d7df4b3ffae919f867ce9598d8942
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jan 18 19:09:06 2018 -0500

    drm/amd/display: add eDP 1.2+ polling for T7
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 524f4aafa543..bae9b0587e12 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -123,6 +123,28 @@ bool edp_receiver_ready_T9(struct dc_link *link)
 	} while (++tries < 50);
 	return result;
 }
+bool edp_receiver_ready_T7(struct dc_link *link)
+{
+	unsigned int tries = 0;
+	unsigned char sinkstatus = 0;
+	unsigned char edpRev = 0;
+	enum dc_status result = DC_OK;
+
+	result = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));
+	if (result == DC_OK && edpRev < DP_EDP_12)
+		return true;
+	/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
+	do {
+		sinkstatus = 0;
+		result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
+		if (sinkstatus == 1)
+			break;
+		if (result != DC_OK)
+			break;
+		udelay(25); //MAx T7 is 50ms
+	} while (++tries < 300);
+	return result;
+}
 
 void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {

commit 69b9723a81e74e517048e1523a24d76fe8e2aef2
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Jan 18 12:53:04 2018 -0500

    drm/amd/display: wait for T9 after backlight off mainlink blank.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 2096f2a179f2..524f4aafa543 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -102,7 +102,7 @@ void dp_enable_link_phy(
 	dp_receiver_power_ctrl(link, true);
 }
 
-static bool edp_receiver_ready_T9(struct dc_link *link)
+bool edp_receiver_ready_T9(struct dc_link *link)
 {
 	unsigned int tries = 0;
 	unsigned char sinkstatus = 0;
@@ -130,7 +130,6 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 		dp_receiver_power_ctrl(link, false);
 
 	if (signal == SIGNAL_TYPE_EDP) {
-		edp_receiver_ready_T9(link);
 		link->link_enc->funcs->disable_output(link->link_enc, signal);
 		link->dc->hwss.edp_power_control(link, false);
 	} else

commit 904623ee5936e2226009b2f238f28781aecd2565
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Nov 24 16:31:03 2017 -0500

    drm/amd/display: Move wait for hpd ready out from edp power control.
    
    It may take over 200ms for wait hpd ready. To optimize the resume time,
    we can power on eDP in init_hw, wait for hpd ready when doing link
    training.
    
    also create separate eDP enable function to make sure eDP is powered up
    before doing and DPCD access, as HPD low will result in DPDC transaction
    failure.
    
    After optimization,
    setpowerstate 145ms -> 9.8ms,
    DPMS 387ms -> 18.9ms
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index f2902569be2e..2096f2a179f2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -88,15 +88,7 @@ void dp_enable_link_phy(
 	}
 
 	if (dc_is_dp_sst_signal(signal)) {
-		if (signal == SIGNAL_TYPE_EDP) {
-			link->dc->hwss.edp_power_control(link, true);
-			link_enc->funcs->enable_dp_output(
-						link_enc,
-						link_settings,
-						clock_source);
-			link->dc->hwss.edp_backlight_control(link, true);
-		} else
-			link_enc->funcs->enable_dp_output(
+		link_enc->funcs->enable_dp_output(
 						link_enc,
 						link_settings,
 						clock_source);
@@ -138,7 +130,6 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 		dp_receiver_power_ctrl(link, false);
 
 	if (signal == SIGNAL_TYPE_EDP) {
-		link->dc->hwss.edp_backlight_control(link, false);
 		edp_receiver_ready_T9(link);
 		link->link_enc->funcs->disable_output(link->link_enc, signal);
 		link->dc->hwss.edp_power_control(link, false);

commit 069d418f412ec4b33056dc7d84b63c80c2e50abf
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Sep 26 19:45:43 2017 -0400

    drm/amd/display: Don't use dc_link in link_encoder
    
    dc_link is at a higher level than link_encoder, and we only want
    higher-level components to be able to access lower-level ones,
    not the other way around.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 9a33b471270a..f2902569be2e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -89,7 +89,7 @@ void dp_enable_link_phy(
 
 	if (dc_is_dp_sst_signal(signal)) {
 		if (signal == SIGNAL_TYPE_EDP) {
-			link->dc->hwss.edp_power_control(link->link_enc, true);
+			link->dc->hwss.edp_power_control(link, true);
 			link_enc->funcs->enable_dp_output(
 						link_enc,
 						link_settings,
@@ -140,10 +140,10 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->dc->hwss.edp_backlight_control(link, false);
 		edp_receiver_ready_T9(link);
-		link->link_enc->funcs->disable_output(link->link_enc, signal, link);
-		link->dc->hwss.edp_power_control(link->link_enc, false);
+		link->link_enc->funcs->disable_output(link->link_enc, signal);
+		link->dc->hwss.edp_power_control(link, false);
 	} else
-		link->link_enc->funcs->disable_output(link->link_enc, signal, link);
+		link->link_enc->funcs->disable_output(link->link_enc, signal);
 
 	/* Clear current link setting.*/
 	memset(&link->cur_link_settings, 0,
@@ -286,8 +286,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			link->link_enc->funcs->disable_output(
 					link->link_enc,
-					SIGNAL_TYPE_DISPLAY_PORT,
-					link);
+					SIGNAL_TYPE_DISPLAY_PORT);
 
 			/* Clear current link setting. */
 			memset(&link->cur_link_settings, 0,

commit 4176664b1fc8aa052f886037590cac4fb0dd8afb
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Sep 27 23:23:16 2017 -0400

    drm/amd/display: audio dynamic resource acquired related
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 34b6d1cb151e..9a33b471270a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -282,7 +282,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			dp_receiver_power_ctrl(link, false);
 
-			link->dc->hwss.disable_stream(&pipes[i]);
+			link->dc->hwss.disable_stream(&pipes[i], KEEP_ACQUIRED_RESOURCE);
 
 			link->link_enc->funcs->disable_output(
 					link->link_enc,

commit 8740196935625dfb171ab115120315060e4a8a41
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Mon Sep 25 18:03:14 2017 -0400

    drm/amd/display: Move power control from link encoder to hwsequencer
    
    A recent commit moved the backlight control code along with the register
    defines, but did not move the power control code. This along with
    remnant fields in the dce110_link_enc_registers struct made it so that
    the code still compiled, but any attempts to access the
    LVTMA_PWRSEQ_STATE register led to reading from an address of 0. This
    patch corrects that.
    
    Also, rename blacklight_control to edp_backlight_control (Typo fix).
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index fa2250554be5..34b6d1cb151e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -89,12 +89,12 @@ void dp_enable_link_phy(
 
 	if (dc_is_dp_sst_signal(signal)) {
 		if (signal == SIGNAL_TYPE_EDP) {
-			link_enc->funcs->power_control(link_enc, true);
+			link->dc->hwss.edp_power_control(link->link_enc, true);
 			link_enc->funcs->enable_dp_output(
 						link_enc,
 						link_settings,
 						clock_source);
-			link->dc->hwss.backlight_control(link, true);
+			link->dc->hwss.edp_backlight_control(link, true);
 		} else
 			link_enc->funcs->enable_dp_output(
 						link_enc,
@@ -138,10 +138,10 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 		dp_receiver_power_ctrl(link, false);
 
 	if (signal == SIGNAL_TYPE_EDP) {
-		link->dc->hwss.backlight_control(link, false);
+		link->dc->hwss.edp_backlight_control(link, false);
 		edp_receiver_ready_T9(link);
 		link->link_enc->funcs->disable_output(link->link_enc, signal, link);
-		link->link_enc->funcs->power_control(link->link_enc, false);
+		link->dc->hwss.edp_power_control(link->link_enc, false);
 	} else
 		link->link_enc->funcs->disable_output(link->link_enc, signal, link);
 

commit 5eefbc40173644b5f74d7e074ba6cd8de5563e05
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Fri Sep 15 17:42:20 2017 -0400

    drm/amd/display: moving backlight registers to hwsequencer
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 5f815cab94b5..fa2250554be5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -94,7 +94,7 @@ void dp_enable_link_phy(
 						link_enc,
 						link_settings,
 						clock_source);
-			link_enc->funcs->backlight_control(link_enc, true);
+			link->dc->hwss.backlight_control(link, true);
 		} else
 			link_enc->funcs->enable_dp_output(
 						link_enc,
@@ -138,12 +138,12 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 		dp_receiver_power_ctrl(link, false);
 
 	if (signal == SIGNAL_TYPE_EDP) {
-		link->link_enc->funcs->backlight_control(link->link_enc, false);
+		link->dc->hwss.backlight_control(link, false);
 		edp_receiver_ready_T9(link);
-		link->link_enc->funcs->disable_output(link->link_enc, signal);
+		link->link_enc->funcs->disable_output(link->link_enc, signal, link);
 		link->link_enc->funcs->power_control(link->link_enc, false);
 	} else
-		link->link_enc->funcs->disable_output(link->link_enc, signal);
+		link->link_enc->funcs->disable_output(link->link_enc, signal, link);
 
 	/* Clear current link setting.*/
 	memset(&link->cur_link_settings, 0,
@@ -286,7 +286,8 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			link->link_enc->funcs->disable_output(
 					link->link_enc,
-					SIGNAL_TYPE_DISPLAY_PORT);
+					SIGNAL_TYPE_DISPLAY_PORT,
+					link);
 
 			/* Clear current link setting. */
 			memset(&link->cur_link_settings, 0,

commit 4770b18493b3d9fe1f8913e69ec5134b103d5788
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Oct 11 12:42:30 2017 -0400

    drm/amd/display/dc: drop dm_delay_in_microseconds
    
    Use udelay directly.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 616431e25b79..5f815cab94b5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -127,7 +127,7 @@ static bool edp_receiver_ready_T9(struct dc_link *link)
 			break;
 		if (result != DC_OK)
 			break;
-		dm_delay_in_microseconds(link->ctx, 100); //MAx T9
+		udelay(100); //MAx T9
 	} while (++tries < 50);
 	return result;
 }
@@ -271,7 +271,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 			pipes[i].stream->sink->link != NULL &&
 			pipes[i].stream_res.stream_enc != NULL &&
 			pipes[i].stream->sink->link == link) {
-			dm_delay_in_microseconds(link->ctx, 100);
+			udelay(100);
 
 			pipes[i].stream_res.stream_enc->funcs->dp_blank(
 					pipes[i].stream_res.stream_enc);

commit 44858055bb28b1ba45dc05acecf9087bc4786701
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 15:11:01 2017 +1000

    amdgpu/dc: set a bunch of functions to static.
    
    All of these are unused outside the file they are in.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 3427fb5b7e30..616431e25b79 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -110,7 +110,7 @@ void dp_enable_link_phy(
 	dp_receiver_power_ctrl(link, true);
 }
 
-bool edp_receiver_ready_T9(struct dc_link *link)
+static bool edp_receiver_ready_T9(struct dc_link *link)
 {
 	unsigned int tries = 0;
 	unsigned char sinkstatus = 0;

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_stateand
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 23d8b614e0fd..3427fb5b7e30 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -62,7 +62,7 @@ void dp_enable_link_phy(
 	struct link_encoder *link_enc = link->link_enc;
 
 	struct pipe_ctx *pipes =
-			link->dc->current_context->res_ctx.pipe_ctx;
+			link->dc->current_state->res_ctx.pipe_ctx;
 	struct clock_source *dp_cs =
 			link->dc->res_pool->dp_clock_source;
 	unsigned int i;
@@ -262,7 +262,7 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 			bool skip_video_pattern)
 {
 	struct pipe_ctx *pipes =
-			&link->dc->current_context->res_ctx.pipe_ctx[0];
+			&link->dc->current_state->res_ctx.pipe_ctx[0];
 	unsigned int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {

commit c25e2d1f8ff403fdb7a82a025ae492d167bbdb99
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Mon Aug 21 16:43:08 2017 -0400

    drm/amd/display: retry LT on failing LT in automated request
    
    [Description]
    Link training is not retried in automated link training request.
    In case link training is occasionally failing, there is not way to retry
    so the requested lane settings will not set.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 3a5abd92036a..23d8b614e0fd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -299,10 +299,11 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			dp_receiver_power_ctrl(link, true);
 
-			dc_link_dp_perform_link_training(
+			perform_link_training_with_retries(
 					link,
 					link_setting,
-					skip_video_pattern);
+					skip_video_pattern,
+					LINK_TRAINING_ATTEMPTS);
 
 			link->cur_link_settings = *link_setting;
 

commit 3005e437e70fd4d1da64d91b4ef027f62d3b9a41
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Thu Aug 17 16:24:11 2017 -0400

    drm/amd/display: re-enable audio after LT test
    
    [Description]
    Audio should be attached to the same pipe once it is attached.
    We will not remove audio endpoint in disable stream.
    We will reeanble the audio after automated link training test
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index e12f1f9fb590..3a5abd92036a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -310,6 +310,20 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 
 			link->dc->hwss.unblank_stream(&pipes[i],
 					link_setting);
+
+			if (pipes[i].stream_res.audio) {
+				/* notify audio driver for
+				 * audio modes of monitor */
+				pipes[i].stream_res.audio->funcs->az_enable(
+						pipes[i].stream_res.audio);
+
+				/* un-mute audio */
+				/* TODO: audio should be per stream rather than
+				 * per link */
+				pipes[i].stream_res.stream_enc->funcs->
+				audio_mute_control(
+					pipes[i].stream_res.stream_enc, false);
+			}
 		}
 	}
 }

commit 71afd9d14f49a0a16050ada488ac1be182f5602f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Aug 11 13:22:02 2017 -0400

    drm/amd/display: eDP power sequence T9 fail
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index da880bd02ad7..e12f1f9fb590 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -110,6 +110,28 @@ void dp_enable_link_phy(
 	dp_receiver_power_ctrl(link, true);
 }
 
+bool edp_receiver_ready_T9(struct dc_link *link)
+{
+	unsigned int tries = 0;
+	unsigned char sinkstatus = 0;
+	unsigned char edpRev = 0;
+	enum dc_status result = DC_OK;
+	result = core_link_read_dpcd(link, DP_EDP_DPCD_REV, &edpRev, sizeof(edpRev));
+	if (edpRev < DP_EDP_12)
+		return true;
+	/* start from eDP version 1.2, SINK_STAUS indicate the sink is ready.*/
+	do {
+		sinkstatus = 1;
+		result = core_link_read_dpcd(link, DP_SINK_STATUS, &sinkstatus, sizeof(sinkstatus));
+		if (sinkstatus == 0)
+			break;
+		if (result != DC_OK)
+			break;
+		dm_delay_in_microseconds(link->ctx, 100); //MAx T9
+	} while (++tries < 50);
+	return result;
+}
+
 void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {
 	if (!link->wa_flags.dp_keep_receiver_powered)
@@ -117,6 +139,7 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->backlight_control(link->link_enc, false);
+		edp_receiver_ready_T9(link);
 		link->link_enc->funcs->disable_output(link->link_enc, signal);
 		link->link_enc->funcs->power_control(link->link_enc, false);
 	} else

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index d19c663c257f..da880bd02ad7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -3,7 +3,7 @@
 
 #include "dm_services.h"
 #include "dc.h"
-#include "inc/core_dc.h"
+#include "inc/core_types.h"
 #include "include/ddc_service_types.h"
 #include "include/i2caux_interface.h"
 #include "link_hwss.h"

commit c10efbd3714bfb6fff8c3b8e2d817028bc25355b
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Aug 3 13:04:44 2017 -0400

    drm/amd/display: fix eDP power down sequence
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 822568767f2d..d19c663c257f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -90,10 +90,13 @@ void dp_enable_link_phy(
 	if (dc_is_dp_sst_signal(signal)) {
 		if (signal == SIGNAL_TYPE_EDP) {
 			link_enc->funcs->power_control(link_enc, true);
+			link_enc->funcs->enable_dp_output(
+						link_enc,
+						link_settings,
+						clock_source);
 			link_enc->funcs->backlight_control(link_enc, true);
-		}
-
-		link_enc->funcs->enable_dp_output(
+		} else
+			link_enc->funcs->enable_dp_output(
 						link_enc,
 						link_settings,
 						clock_source);
@@ -114,10 +117,10 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->backlight_control(link->link_enc, false);
+		link->link_enc->funcs->disable_output(link->link_enc, signal);
 		link->link_enc->funcs->power_control(link->link_enc, false);
-	}
-
-	link->link_enc->funcs->disable_output(link->link_enc, signal);
+	} else
+		link->link_enc->funcs->disable_output(link->link_enc, signal);
 
 	/* Clear current link setting.*/
 	memset(&link->cur_link_settings, 0,

commit 10688217e3af3ec73892139bed3d23a6e1170a14
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 15:17:43 2017 -0400

    drm/amd/display: Move pix_clk_params into stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipes->pix_clk_params/pipes->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->pix_clk_params/pipe_with_clk_src->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/ctx->pix_clk_params->/ctx->stream_res\.pix_clk_params->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->pix_clk_params/pipe->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_ctx->pix_clk_params/pipe_ctx->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.pix_clk_params/pipe_ctx\[pipe_offset\]\.stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->pix_clk_params/grouped_pipes\[i\]->stream_^Cs\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->pix_clk_params/grouped_pipes\[0\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->pix_clk_params/grouped_pipes\[1\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->pix_clk_params/pipe_ctx\[i\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->pix_clk_params/pipe_ctx_old->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->pix_clk_params/pipe_set\[j\]->stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.pix_clk_params/pipe_ctx\[i\]\.stream_res\.pix_clk_params/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.pix_clk_params/pipes\[i\]\.stream_res\.pix_clk_params/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 7d52c6c7cf89..822568767f2d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -77,11 +77,11 @@ void dp_enable_link_phy(
 			if (pipes[i].clock_source != NULL &&
 					pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
 				pipes[i].clock_source = dp_cs;
-				pipes[i].pix_clk_params.requested_pix_clk =
+				pipes[i].stream_res.pix_clk_params.requested_pix_clk =
 						pipes[i].stream->timing.pix_clk_khz;
 				pipes[i].clock_source->funcs->program_pix_clk(
 							pipes[i].clock_source,
-							&pipes[i].pix_clk_params,
+							&pipes[i].stream_res.pix_clk_params,
 							&pipes[i].pll_settings);
 			}
 		}

commit 8e9c4c8cf35ff23aafc69f9ef4c9cc471dac4094
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:36:12 2017 -0400

    drm/amd/display: Move stream_enc to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->stream_enc/pipes->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->stream_enc->/ctx->stream_res\.stream_enc->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->stream_enc/pipe->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->stream_enc/pipe_ctx->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.stream_enc/pipe_ctx\[pipe_offset\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->stream_enc/grouped_pipes\[i\]->stream_^Cs\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->stream_enc/grouped_pipes\[0\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->stream_enc/grouped_pipes\[1\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->stream_enc/pipe_ctx\[i\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->stream_enc/pipe_ctx_old->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->stream_enc/pipe_set\[j\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.stream_enc/pipe_ctx\[i\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.stream_enc/pipes\[i\]\.stream_res\.stream_enc/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index f2f57a75f864..7d52c6c7cf89 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -243,12 +243,12 @@ void dp_retrain_link_dp_test(struct dc_link *link,
 		if (pipes[i].stream != NULL &&
 			pipes[i].stream->sink != NULL &&
 			pipes[i].stream->sink->link != NULL &&
-			pipes[i].stream_enc != NULL &&
+			pipes[i].stream_res.stream_enc != NULL &&
 			pipes[i].stream->sink->link == link) {
 			dm_delay_in_microseconds(link->ctx, 100);
 
-			pipes[i].stream_enc->funcs->dp_blank(
-					pipes[i].stream_enc);
+			pipes[i].stream_res.stream_enc->funcs->dp_blank(
+					pipes[i].stream_res.stream_enc);
 
 			/* disable any test pattern that might be active */
 			dp_set_hw_test_pattern(link,

commit 4654a2f7fce0c2fd3dafe2c366ddf8e9e080fa44
Author: Roman Li <Roman.Li@amd.com>
Date:   Wed Jul 26 16:27:37 2017 -0400

    drm/amd/display: add detect caps for edp
    
    1. The caps detect sequence for edp is different from dp.
       Added separate function for edp.
    2. Removed max_link_setting and replaced it with verified
       to avoid confusion.
    3. Reverted sink count guard for edp powerdown as unnecessary
       with the changes above.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 76dc16916821..f2f57a75f864 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -114,9 +114,7 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->backlight_control(link->link_enc, false);
-		if (link->dpcd_sink_count)
-			link->link_enc->funcs->power_control(link->link_enc,
-									false);
+		link->link_enc->funcs->power_control(link->link_enc, false);
 	}
 
 	link->link_enc->funcs->disable_output(link->link_enc, signal);

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 5bdcd5067116..76dc16916821 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -78,7 +78,7 @@ void dp_enable_link_phy(
 					pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
 				pipes[i].clock_source = dp_cs;
 				pipes[i].pix_clk_params.requested_pix_clk =
-						pipes[i].stream->public.timing.pix_clk_khz;
+						pipes[i].stream->timing.pix_clk_khz;
 				pipes[i].clock_source->funcs->program_pix_clk(
 							pipes[i].clock_source,
 							&pipes[i].pix_clk_params,

commit 48841a20fc794cee0dcbcabee64e068bd6db2df7
Author: Roman Li <Roman.Li@amd.com>
Date:   Tue Jul 25 14:50:44 2017 -0400

    drm/amd/display: Fix eDP panel light-up
    
     Power-down panel on disale only if sink exists
     otherwise it fails edid read during init sequence
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index aac2420caefa..5bdcd5067116 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -114,7 +114,9 @@ void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 
 	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->backlight_control(link->link_enc, false);
-		link->link_enc->funcs->power_control(link->link_enc, false);
+		if (link->dpcd_sink_count)
+			link->link_enc->funcs->power_control(link->link_enc,
+									false);
 	}
 
 	link->link_enc->funcs->disable_output(link->link_enc, signal);

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 0092e70b9efd..aac2420caefa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -16,13 +16,13 @@
 #include "dpcd_defs.h"
 
 enum dc_status core_link_read_dpcd(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t address,
 	uint8_t *data,
 	uint32_t size)
 {
 	if (!dm_helpers_dp_read_dpcd(link->ctx,
-			&link->public,
+			link,
 			address, data, size))
 			return DC_ERROR_UNEXPECTED;
 
@@ -30,20 +30,20 @@ enum dc_status core_link_read_dpcd(
 }
 
 enum dc_status core_link_write_dpcd(
-	struct core_link* link,
+	struct dc_link *link,
 	uint32_t address,
 	const uint8_t *data,
 	uint32_t size)
 {
 	if (!dm_helpers_dp_write_dpcd(link->ctx,
-			&link->public,
+			link,
 			address, data, size))
 				return DC_ERROR_UNEXPECTED;
 
 	return DC_OK;
 }
 
-void dp_receiver_power_ctrl(struct core_link *link, bool on)
+void dp_receiver_power_ctrl(struct dc_link *link, bool on)
 {
 	uint8_t state;
 
@@ -54,7 +54,7 @@ void dp_receiver_power_ctrl(struct core_link *link, bool on)
 }
 
 void dp_enable_link_phy(
-	struct core_link *link,
+	struct dc_link *link,
 	enum signal_type signal,
 	enum clock_source_id clock_source,
 	const struct dc_link_settings *link_settings)
@@ -107,7 +107,7 @@ void dp_enable_link_phy(
 	dp_receiver_power_ctrl(link, true);
 }
 
-void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
+void dp_disable_link_phy(struct dc_link *link, enum signal_type signal)
 {
 	if (!link->wa_flags.dp_keep_receiver_powered)
 		dp_receiver_power_ctrl(link, false);
@@ -120,11 +120,11 @@ void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
 	link->link_enc->funcs->disable_output(link->link_enc, signal);
 
 	/* Clear current link setting.*/
-	memset(&link->public.cur_link_settings, 0,
-			sizeof(link->public.cur_link_settings));
+	memset(&link->cur_link_settings, 0,
+			sizeof(link->cur_link_settings));
 }
 
-void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal)
+void dp_disable_link_phy_mst(struct dc_link *link, enum signal_type signal)
 {
 	/* MST disable link only when no stream use the link */
 	if (link->mst_stream_alloc_table.stream_count > 0)
@@ -137,7 +137,7 @@ void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal)
 }
 
 bool dp_set_hw_training_pattern(
-	struct core_link *link,
+	struct dc_link *link,
 	enum hw_dp_training_pattern pattern)
 {
 	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
@@ -165,7 +165,7 @@ bool dp_set_hw_training_pattern(
 }
 
 void dp_set_hw_lane_settings(
-	struct core_link *link,
+	struct dc_link *link,
 	const struct link_training_settings *link_settings)
 {
 	struct link_encoder *encoder = link->link_enc;
@@ -174,13 +174,13 @@ void dp_set_hw_lane_settings(
 	encoder->funcs->dp_set_lane_settings(encoder, link_settings);
 }
 
-enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
+enum dp_panel_mode dp_get_panel_mode(struct dc_link *link)
 {
 	/* We need to explicitly check that connector
 	 * is not DP. Some Travis_VGA get reported
 	 * by video bios as DP.
 	 */
-	if (link->public.connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+	if (link->connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
 
 		switch (link->dpcd_caps.branch_dev_id) {
 		case DP_BRANCH_DEVICE_ID_2:
@@ -215,7 +215,7 @@ enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
 }
 
 void dp_set_hw_test_pattern(
-	struct core_link *link,
+	struct dc_link *link,
 	enum dp_test_pattern test_pattern,
 	uint8_t *custom_pattern,
 	uint32_t custom_pattern_size)
@@ -231,7 +231,7 @@ void dp_set_hw_test_pattern(
 	encoder->funcs->dp_set_phy_pattern(encoder, &pattern_param);
 }
 
-void dp_retrain_link_dp_test(struct core_link *link,
+void dp_retrain_link_dp_test(struct dc_link *link,
 			struct dc_link_settings *link_setting,
 			bool skip_video_pattern)
 {
@@ -263,8 +263,8 @@ void dp_retrain_link_dp_test(struct core_link *link,
 					SIGNAL_TYPE_DISPLAY_PORT);
 
 			/* Clear current link setting. */
-			memset(&link->public.cur_link_settings, 0,
-				sizeof(link->public.cur_link_settings));
+			memset(&link->cur_link_settings, 0,
+				sizeof(link->cur_link_settings));
 
 			link->link_enc->funcs->enable_dp_output(
 						link->link_enc,
@@ -274,11 +274,11 @@ void dp_retrain_link_dp_test(struct core_link *link,
 			dp_receiver_power_ctrl(link, true);
 
 			dc_link_dp_perform_link_training(
-					&link->public,
+					link,
 					link_setting,
 					skip_video_pattern);
 
-			link->public.cur_link_settings = *link_setting;
+			link->cur_link_settings = *link_setting;
 
 			link->dc->hwss.enable_stream(&pipes[i]);
 

commit ef347b3b80c2f973140553db41224f886ef3b9da
Author: John Wu <john.wu@amd.com>
Date:   Wed Jul 12 14:25:52 2017 +0800

    drm/amd/display: Fix eDP power isn't off when lid close
    
    Signed-off-by: John Wu <john.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 4f46ff14fb69..0092e70b9efd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -112,8 +112,10 @@ void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
 	if (!link->wa_flags.dp_keep_receiver_powered)
 		dp_receiver_power_ctrl(link, false);
 
-	if (signal == SIGNAL_TYPE_EDP)
+	if (signal == SIGNAL_TYPE_EDP) {
 		link->link_enc->funcs->backlight_control(link->link_enc, false);
+		link->link_enc->funcs->power_control(link->link_enc, false);
+	}
 
 	link->link_enc->funcs->disable_output(link->link_enc, signal);
 

commit 0a5c357a85e99eae6b1914272bc2cf8f49cf511b
Author: Ayyappa Chandolu <Ayyappa.Chandolu@amd.com>
Date:   Fri May 12 17:05:55 2017 +0530

    drm/amd/display: Fix ASSR enablement on DP to EDP converter
    
    ASSR mode is not enable when we connect eDP panel via DP to eDP converter.
    connector_signal is coming as SIGNAL_TYPE_DISPLAY_PORT. Present code
    ignoring panel_mode_edp for SIGNAL_TYPE_DISPLAY_PORT. Added checking
    panel_mode_edp for all signals.
    
    Signed-off-by: Ayyappa Chandolu <Ayyappa.Chandolu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 316df150c1d9..4f46ff14fb69 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -203,10 +203,10 @@ enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
 		default:
 			break;
 		}
+	}
 
-		if (link->dpcd_caps.panel_mode_edp) {
-			return DP_PANEL_MODE_EDP;
-		}
+	if (link->dpcd_caps.panel_mode_edp) {
+		return DP_PANEL_MODE_EDP;
 	}
 
 	return DP_PANEL_MODE_DEFAULT;

commit 07c84c7ad388c28ce69303182e06644ef30d3ac3
Author: Ding Wang <Ding.Wang@amd.com>
Date:   Mon Apr 10 14:02:23 2017 -0400

    drm/amd/display: Fix for tile MST
    
    - Set stream signal type to be SST when setting non-tile timing on MST
      tiled display.
      - Disable MST on sink after disabling MST link.
      - Enable MST on sink before enabling MST link.
    
    Signed-off-by: Ding Wang <Ding.Wang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 3b814592fd70..316df150c1d9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -129,6 +129,9 @@ void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal)
 		return;
 
 	dp_disable_link_phy(link, signal);
+
+	/* set the sink to SST mode after disabling the link */
+	dp_enable_mst_on_sink(link, false);
 }
 
 bool dp_set_hw_training_pattern(

commit 75a74755763062b5dd722a19b3fe7a60813ee369
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Thu Jan 26 18:03:16 2017 -0500

    drm/amd/display: DP compliance automation test fixes
    
    Fixes:
    1. Removing pending flag since we are executing teh entire flow without context switches
    2. Adding stream enablment - connection between DIG BE to DIG FE during test link training
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index b0ac94d673c4..3b814592fd70 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -251,6 +251,8 @@ void dp_retrain_link_dp_test(struct core_link *link,
 
 			dp_receiver_power_ctrl(link, false);
 
+			link->dc->hwss.disable_stream(&pipes[i]);
+
 			link->link_enc->funcs->disable_output(
 					link->link_enc,
 					SIGNAL_TYPE_DISPLAY_PORT);
@@ -273,6 +275,8 @@ void dp_retrain_link_dp_test(struct core_link *link,
 
 			link->public.cur_link_settings = *link_setting;
 
+			link->dc->hwss.enable_stream(&pipes[i]);
+
 			link->dc->hwss.unblank_stream(&pipes[i],
 					link_setting);
 		}

commit 457b74cb3773a1950e49c2d4826d1b295c59bdf1
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Jan 11 15:52:06 2017 -0500

    drm/amd/display: Null check clock source.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 55d96656e54b..b0ac94d673c4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -74,7 +74,8 @@ void dp_enable_link_phy(
 		if (pipes[i].stream != NULL &&
 			pipes[i].stream->sink != NULL &&
 			pipes[i].stream->sink->link == link) {
-			if (pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
+			if (pipes[i].clock_source != NULL &&
+					pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
 				pipes[i].clock_source = dp_cs;
 				pipes[i].pix_clk_params.requested_pix_clk =
 						pipes[i].stream->public.timing.pix_clk_khz;

commit 0ea9e02af5572323f79b493ec8d6bfa55effb2f7
Author: Ding Wang <Ding.Wang@amd.com>
Date:   Tue Jan 10 12:47:37 2017 -0500

    drm/amd/display: Use DTO as clock on DP if not
    
    Use DVO as pixel clock for DP before enabling link
    PHY. Otherwise, when switching from HDMI passive dongle
    to DP on the same connector, the PHY PLL is used as
    pixel clock, and CRTC would stop working.
    
    Signed-off-by: Ding Wang <Ding.Wang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index da49be0672d7..55d96656e54b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -61,6 +61,31 @@ void dp_enable_link_phy(
 {
 	struct link_encoder *link_enc = link->link_enc;
 
+	struct pipe_ctx *pipes =
+			link->dc->current_context->res_ctx.pipe_ctx;
+	struct clock_source *dp_cs =
+			link->dc->res_pool->dp_clock_source;
+	unsigned int i;
+	/* If the current pixel clock source is not DTO(happens after
+	 * switching from HDMI passive dongle to DP on the same connector),
+	 * switch the pixel clock source to DTO.
+	 */
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (pipes[i].stream != NULL &&
+			pipes[i].stream->sink != NULL &&
+			pipes[i].stream->sink->link == link) {
+			if (pipes[i].clock_source->id != CLOCK_SOURCE_ID_DP_DTO) {
+				pipes[i].clock_source = dp_cs;
+				pipes[i].pix_clk_params.requested_pix_clk =
+						pipes[i].stream->public.timing.pix_clk_khz;
+				pipes[i].clock_source->funcs->program_pix_clk(
+							pipes[i].clock_source,
+							&pipes[i].pix_clk_params,
+							&pipes[i].pll_settings);
+			}
+		}
+	}
+
 	if (dc_is_dp_sst_signal(signal)) {
 		if (signal == SIGNAL_TYPE_EDP) {
 			link_enc->funcs->power_control(link_enc, true);

commit bf5cda339d3609408624afcb6f533f4eabc7d142
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Wed Jan 4 10:22:35 2017 -0500

    drm/amd/display: Fix DP PHY test pre-emphasis not set properly
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index e287584ade29..da49be0672d7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -229,10 +229,9 @@ void dp_retrain_link_dp_test(struct core_link *link,
 					link->link_enc,
 					SIGNAL_TYPE_DISPLAY_PORT);
 
-			/* Clear current link setting.
-			 * memset(&link->public.cur_link_settings, 0,
-			 * 	sizeof(link->public.cur_link_settings));
-			 */
+			/* Clear current link setting. */
+			memset(&link->public.cur_link_settings, 0,
+				sizeof(link->public.cur_link_settings));
 
 			link->link_enc->funcs->enable_dp_output(
 						link->link_enc,
@@ -246,6 +245,8 @@ void dp_retrain_link_dp_test(struct core_link *link,
 					link_setting,
 					skip_video_pattern);
 
+			link->public.cur_link_settings = *link_setting;
+
 			link->dc->hwss.unblank_stream(&pipes[i],
 					link_setting);
 		}

commit 73c7260292db3f506b2562cbb25c06adfe90ca99
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Thu Dec 29 14:58:54 2016 -0500

    drm/amd/display: Fix link retraining hw sequence for auto test
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index f870a0e72074..e287584ade29 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -200,28 +200,7 @@ void dp_set_hw_test_pattern(
 	encoder->funcs->dp_set_phy_pattern(encoder, &pattern_param);
 }
 
-void dp_retrain_link(struct core_link *link)
-{
-	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
-	unsigned int i;
-
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (pipes[i].stream_enc != NULL) {
-			dm_delay_in_microseconds(link->ctx, 100);
-			pipes->stream_enc->funcs->dp_blank(pipes[i].stream_enc);
-			link->dc->hwss.disable_stream(&pipes[i]);
-			dc_link_dp_perform_link_training(
-					&link->public,
-					&link->public.verified_link_cap,
-					true);
-			link->dc->hwss.enable_stream(&pipes[i]);
-			link->dc->hwss.unblank_stream(&pipes[i],
-					&link->public.verified_link_cap);
-		}
-	}
-}
-
-void dp_retrain_link_physi(struct core_link *link,
+void dp_retrain_link_dp_test(struct core_link *link,
 			struct dc_link_settings *link_setting,
 			bool skip_video_pattern)
 {
@@ -240,6 +219,10 @@ void dp_retrain_link_physi(struct core_link *link,
 			pipes[i].stream_enc->funcs->dp_blank(
 					pipes[i].stream_enc);
 
+			/* disable any test pattern that might be active */
+			dp_set_hw_test_pattern(link,
+					DP_TEST_PATTERN_VIDEO_MODE, NULL, 0);
+
 			dp_receiver_power_ctrl(link, false);
 
 			link->link_enc->funcs->disable_output(

commit 886391680cce3b7c4543b88bbd4eb49c80c26532
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Fri Dec 23 16:53:12 2016 -0500

    drm/amd/display: Fix link retraining hw sequence
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 4febc8d2a96d..f870a0e72074 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -200,7 +200,6 @@ void dp_set_hw_test_pattern(
 	encoder->funcs->dp_set_phy_pattern(encoder, &pattern_param);
 }
 
-
 void dp_retrain_link(struct core_link *link)
 {
 	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
@@ -221,3 +220,51 @@ void dp_retrain_link(struct core_link *link)
 		}
 	}
 }
+
+void dp_retrain_link_physi(struct core_link *link,
+			struct dc_link_settings *link_setting,
+			bool skip_video_pattern)
+{
+	struct pipe_ctx *pipes =
+			&link->dc->current_context->res_ctx.pipe_ctx[0];
+	unsigned int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (pipes[i].stream != NULL &&
+			pipes[i].stream->sink != NULL &&
+			pipes[i].stream->sink->link != NULL &&
+			pipes[i].stream_enc != NULL &&
+			pipes[i].stream->sink->link == link) {
+			dm_delay_in_microseconds(link->ctx, 100);
+
+			pipes[i].stream_enc->funcs->dp_blank(
+					pipes[i].stream_enc);
+
+			dp_receiver_power_ctrl(link, false);
+
+			link->link_enc->funcs->disable_output(
+					link->link_enc,
+					SIGNAL_TYPE_DISPLAY_PORT);
+
+			/* Clear current link setting.
+			 * memset(&link->public.cur_link_settings, 0,
+			 * 	sizeof(link->public.cur_link_settings));
+			 */
+
+			link->link_enc->funcs->enable_dp_output(
+						link->link_enc,
+						link_setting,
+						pipes[i].clock_source->id);
+
+			dp_receiver_power_ctrl(link, true);
+
+			dc_link_dp_perform_link_training(
+					&link->public,
+					link_setting,
+					skip_video_pattern);
+
+			link->dc->hwss.unblank_stream(&pipes[i],
+					link_setting);
+		}
+	}
+}

commit 3a340294f7e7a784c83f9cd72f49987cc7daaced
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Dec 13 16:41:11 2016 +1000

    drm/amd/display: port to using drm dpcd defines
    
    We only keep one list of these defines in the kernel, so we should use it.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index 0c5f16cb1d54..4febc8d2a96d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -49,7 +49,7 @@ void dp_receiver_power_ctrl(struct core_link *link, bool on)
 
 	state = on ? DP_POWER_STATE_D0 : DP_POWER_STATE_D3;
 
-	core_link_write_dpcd(link, DPCD_ADDRESS_POWER_STATE, &state,
+	core_link_write_dpcd(link, DP_SET_POWER, &state,
 			sizeof(state));
 }
 

commit eaca91eea60e5b0732b7e9ab213359d75f36901f
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Dec 19 14:10:53 2016 -0500

    drm/amd/display: Move dpcd structs into dp_types header
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
index e89f5f176ec3..0c5f16cb1d54 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -13,6 +13,7 @@
 #include "dm_helpers.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
+#include "dpcd_defs.h"
 
 enum dc_status core_link_read_dpcd(
 	struct core_link* link,

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
new file mode 100644
index 000000000000..e89f5f176ec3
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_hwss.c
@@ -0,0 +1,222 @@
+/* Copyright 2015 Advanced Micro Devices, Inc. */
+
+
+#include "dm_services.h"
+#include "dc.h"
+#include "inc/core_dc.h"
+#include "include/ddc_service_types.h"
+#include "include/i2caux_interface.h"
+#include "link_hwss.h"
+#include "hw_sequencer.h"
+#include "dc_link_dp.h"
+#include "dc_link_ddc.h"
+#include "dm_helpers.h"
+#include "dce/dce_link_encoder.h"
+#include "dce/dce_stream_encoder.h"
+
+enum dc_status core_link_read_dpcd(
+	struct core_link* link,
+	uint32_t address,
+	uint8_t *data,
+	uint32_t size)
+{
+	if (!dm_helpers_dp_read_dpcd(link->ctx,
+			&link->public,
+			address, data, size))
+			return DC_ERROR_UNEXPECTED;
+
+	return DC_OK;
+}
+
+enum dc_status core_link_write_dpcd(
+	struct core_link* link,
+	uint32_t address,
+	const uint8_t *data,
+	uint32_t size)
+{
+	if (!dm_helpers_dp_write_dpcd(link->ctx,
+			&link->public,
+			address, data, size))
+				return DC_ERROR_UNEXPECTED;
+
+	return DC_OK;
+}
+
+void dp_receiver_power_ctrl(struct core_link *link, bool on)
+{
+	uint8_t state;
+
+	state = on ? DP_POWER_STATE_D0 : DP_POWER_STATE_D3;
+
+	core_link_write_dpcd(link, DPCD_ADDRESS_POWER_STATE, &state,
+			sizeof(state));
+}
+
+void dp_enable_link_phy(
+	struct core_link *link,
+	enum signal_type signal,
+	enum clock_source_id clock_source,
+	const struct dc_link_settings *link_settings)
+{
+	struct link_encoder *link_enc = link->link_enc;
+
+	if (dc_is_dp_sst_signal(signal)) {
+		if (signal == SIGNAL_TYPE_EDP) {
+			link_enc->funcs->power_control(link_enc, true);
+			link_enc->funcs->backlight_control(link_enc, true);
+		}
+
+		link_enc->funcs->enable_dp_output(
+						link_enc,
+						link_settings,
+						clock_source);
+	} else {
+		link_enc->funcs->enable_dp_mst_output(
+						link_enc,
+						link_settings,
+						clock_source);
+	}
+
+	dp_receiver_power_ctrl(link, true);
+}
+
+void dp_disable_link_phy(struct core_link *link, enum signal_type signal)
+{
+	if (!link->wa_flags.dp_keep_receiver_powered)
+		dp_receiver_power_ctrl(link, false);
+
+	if (signal == SIGNAL_TYPE_EDP)
+		link->link_enc->funcs->backlight_control(link->link_enc, false);
+
+	link->link_enc->funcs->disable_output(link->link_enc, signal);
+
+	/* Clear current link setting.*/
+	memset(&link->public.cur_link_settings, 0,
+			sizeof(link->public.cur_link_settings));
+}
+
+void dp_disable_link_phy_mst(struct core_link *link, enum signal_type signal)
+{
+	/* MST disable link only when no stream use the link */
+	if (link->mst_stream_alloc_table.stream_count > 0)
+		return;
+
+	dp_disable_link_phy(link, signal);
+}
+
+bool dp_set_hw_training_pattern(
+	struct core_link *link,
+	enum hw_dp_training_pattern pattern)
+{
+	enum dp_test_pattern test_pattern = DP_TEST_PATTERN_UNSUPPORTED;
+
+	switch (pattern) {
+	case HW_DP_TRAINING_PATTERN_1:
+		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN1;
+		break;
+	case HW_DP_TRAINING_PATTERN_2:
+		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN2;
+		break;
+	case HW_DP_TRAINING_PATTERN_3:
+		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN3;
+		break;
+	case HW_DP_TRAINING_PATTERN_4:
+		test_pattern = DP_TEST_PATTERN_TRAINING_PATTERN4;
+		break;
+	default:
+		break;
+	}
+
+	dp_set_hw_test_pattern(link, test_pattern, NULL, 0);
+
+	return true;
+}
+
+void dp_set_hw_lane_settings(
+	struct core_link *link,
+	const struct link_training_settings *link_settings)
+{
+	struct link_encoder *encoder = link->link_enc;
+
+	/* call Encoder to set lane settings */
+	encoder->funcs->dp_set_lane_settings(encoder, link_settings);
+}
+
+enum dp_panel_mode dp_get_panel_mode(struct core_link *link)
+{
+	/* We need to explicitly check that connector
+	 * is not DP. Some Travis_VGA get reported
+	 * by video bios as DP.
+	 */
+	if (link->public.connector_signal != SIGNAL_TYPE_DISPLAY_PORT) {
+
+		switch (link->dpcd_caps.branch_dev_id) {
+		case DP_BRANCH_DEVICE_ID_2:
+			if (strncmp(
+				link->dpcd_caps.branch_dev_name,
+				DP_VGA_LVDS_CONVERTER_ID_2,
+				sizeof(
+				link->dpcd_caps.
+				branch_dev_name)) == 0) {
+				return DP_PANEL_MODE_SPECIAL;
+			}
+			break;
+		case DP_BRANCH_DEVICE_ID_3:
+			if (strncmp(link->dpcd_caps.branch_dev_name,
+				DP_VGA_LVDS_CONVERTER_ID_3,
+				sizeof(
+				link->dpcd_caps.
+				branch_dev_name)) == 0) {
+				return DP_PANEL_MODE_SPECIAL;
+			}
+			break;
+		default:
+			break;
+		}
+
+		if (link->dpcd_caps.panel_mode_edp) {
+			return DP_PANEL_MODE_EDP;
+		}
+	}
+
+	return DP_PANEL_MODE_DEFAULT;
+}
+
+void dp_set_hw_test_pattern(
+	struct core_link *link,
+	enum dp_test_pattern test_pattern,
+	uint8_t *custom_pattern,
+	uint32_t custom_pattern_size)
+{
+	struct encoder_set_dp_phy_pattern_param pattern_param = {0};
+	struct link_encoder *encoder = link->link_enc;
+
+	pattern_param.dp_phy_pattern = test_pattern;
+	pattern_param.custom_pattern = custom_pattern;
+	pattern_param.custom_pattern_size = custom_pattern_size;
+	pattern_param.dp_panel_mode = dp_get_panel_mode(link);
+
+	encoder->funcs->dp_set_phy_pattern(encoder, &pattern_param);
+}
+
+
+void dp_retrain_link(struct core_link *link)
+{
+	struct pipe_ctx *pipes = link->dc->current_context->res_ctx.pipe_ctx;
+	unsigned int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (pipes[i].stream_enc != NULL) {
+			dm_delay_in_microseconds(link->ctx, 100);
+			pipes->stream_enc->funcs->dp_blank(pipes[i].stream_enc);
+			link->dc->hwss.disable_stream(&pipes[i]);
+			dc_link_dp_perform_link_training(
+					&link->public,
+					&link->public.verified_link_cap,
+					true);
+			link->dc->hwss.enable_stream(&pipes[i]);
+			link->dc->hwss.unblank_stream(&pipes[i],
+					&link->public.verified_link_cap);
+		}
+	}
+}
