commit 2b77dcc5e5aa382832af93a581de8293db72d888
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:04:34 2019 -0500

    drm/amd/display: rename core_dc to dc
    
    [Why]
    First, to make code more consistent
    Second, to get rid of those scenario where we create a second
    local pointer to dc when it's already passed in.
    
    [How]
    Rename core_dc to dc
    Remove duplicate local pointers to dc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index e60aff46d510..ea1229a3e2b2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -108,16 +108,14 @@ void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 
 struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 {
-	struct dc *core_dc = dc;
-
 	struct dc_plane_state *plane_state = kvzalloc(sizeof(*plane_state),
-						      GFP_KERNEL);
+							GFP_KERNEL);
 
 	if (NULL == plane_state)
 		return NULL;
 
 	kref_init(&plane_state->refcount);
-	dc_plane_construct(core_dc->ctx, plane_state);
+	dc_plane_construct(dc->ctx, plane_state);
 
 	return plane_state;
 }
@@ -137,7 +135,7 @@ const struct dc_plane_status *dc_plane_get_status(
 		const struct dc_plane_state *plane_state)
 {
 	const struct dc_plane_status *plane_status;
-	struct dc  *core_dc;
+	struct dc  *dc;
 	int i;
 
 	if (!plane_state ||
@@ -148,15 +146,15 @@ const struct dc_plane_status *dc_plane_get_status(
 	}
 
 	plane_status = &plane_state->status;
-	core_dc = plane_state->ctx->dc;
+	dc = plane_state->ctx->dc;
 
-	if (core_dc->current_state == NULL)
+	if (dc->current_state == NULL)
 		return NULL;
 
 	/* Find the current plane state and set its pending bit to false */
-	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
-				&core_dc->current_state->res_ctx.pipe_ctx[i];
+				&dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->plane_state != plane_state)
 			continue;
@@ -166,14 +164,14 @@ const struct dc_plane_status *dc_plane_get_status(
 		break;
 	}
 
-	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
-				&core_dc->current_state->res_ctx.pipe_ctx[i];
+				&dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
-		core_dc->hwss.update_pending_status(pipe_ctx);
+		dc->hwss.update_pending_status(pipe_ctx);
 	}
 
 	return plane_status;

commit d9e32672a1285d6c5e06bedaabb465441c172aa8
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Oct 31 21:39:39 2019 -0400

    drm/amd/display: cleanup of construct and destruct funcs
    
    [Why]
    Too many construct functions which makes searching
    difficult, especially on some debuggers.
    
    [How]
    Append all construct and destruct functions with dcn
    number and object type to make each construct function
    name unique
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index aaecdee2b8b4..e60aff46d510 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -37,7 +37,7 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
+static void dc_plane_construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
 	plane_state->ctx = ctx;
 
@@ -68,7 +68,7 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 
 }
 
-static void destruct(struct dc_plane_state *plane_state)
+static void dc_plane_destruct(struct dc_plane_state *plane_state)
 {
 	if (plane_state->gamma_correction != NULL) {
 		dc_gamma_release(&plane_state->gamma_correction);
@@ -117,7 +117,7 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 		return NULL;
 
 	kref_init(&plane_state->refcount);
-	construct(core_dc->ctx, plane_state);
+	dc_plane_construct(core_dc->ctx, plane_state);
 
 	return plane_state;
 }
@@ -187,7 +187,7 @@ void dc_plane_state_retain(struct dc_plane_state *plane_state)
 static void dc_plane_state_free(struct kref *kref)
 {
 	struct dc_plane_state *plane_state = container_of(kref, struct dc_plane_state, refcount);
-	destruct(plane_state);
+	dc_plane_destruct(plane_state);
 	kvfree(plane_state);
 }
 

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index b9d6a5bd8522..aaecdee2b8b4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -50,7 +50,6 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 		plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
 		plane_state->in_transfer_func->ctx = ctx;
 	}
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	plane_state->in_shaper_func = dc_create_transfer_func();
 	if (plane_state->in_shaper_func != NULL) {
 		plane_state->in_shaper_func->type = TF_TYPE_BYPASS;
@@ -67,7 +66,6 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 		plane_state->blend_tf->ctx = ctx;
 	}
 
-#endif
 }
 
 static void destruct(struct dc_plane_state *plane_state)
@@ -80,7 +78,6 @@ static void destruct(struct dc_plane_state *plane_state)
 				plane_state->in_transfer_func);
 		plane_state->in_transfer_func = NULL;
 	}
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	if (plane_state->in_shaper_func != NULL) {
 		dc_transfer_func_release(
 				plane_state->in_shaper_func);
@@ -97,7 +94,6 @@ static void destruct(struct dc_plane_state *plane_state)
 		plane_state->blend_tf = NULL;
 	}
 
-#endif
 }
 
 /*******************************************************************************
@@ -262,7 +258,6 @@ struct dc_transfer_func *dc_create_transfer_func(void)
 	return NULL;
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 static void dc_3dlut_func_free(struct kref *kref)
 {
 	struct dc_3dlut *lut = container_of(kref, struct dc_3dlut, refcount);
@@ -296,6 +291,5 @@ void dc_3dlut_func_retain(struct dc_3dlut *lut)
 {
 	kref_get(&lut->refcount);
 }
-#endif
 
 

commit a2080098692173cf27282f686e341b184f9d68e3
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Fri Jun 21 10:13:16 2019 -0500

    drm/amd/display: Add MPC 3DLUT resource management
    
    [Why & How]
    Number of 3DLUT's in MPC are not equal to number of pipes.
    Resource management is required.
    Activate on FPGA entire tm solution  which includes
    the following :hdr multiplier, shaper, 3dlut.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Gary Kattan <Gary.Kattan@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index f40e4fd52fa2..b9d6a5bd8522 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -60,7 +60,6 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 	plane_state->lut3d_func = dc_create_3dlut_func();
 	if (plane_state->lut3d_func != NULL) {
 		plane_state->lut3d_func->ctx = ctx;
-		plane_state->lut3d_func->initialized = false;
 	}
 	plane_state->blend_tf = dc_create_transfer_func();
 	if (plane_state->blend_tf != NULL) {
@@ -279,7 +278,7 @@ struct dc_3dlut *dc_create_3dlut_func(void)
 		goto alloc_fail;
 
 	kref_init(&lut->refcount);
-	lut->initialized = false;
+	lut->state.raw = 0;
 
 	return lut;
 

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit f99b6f4f216ac0ff7f477dd36c88e7b229292dec
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Apr 18 09:51:12 2019 -0500

    drm/amd/display: Integrate color transform3x4 with 3dlut tm
    
    [Why & How]
    Reuse existent code path (dcn1+) and in order to do that apply de gamma
    in 1D blender LUT and re use MPC OGAM.
    Follow up is required.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Vitaly Prosyak <Vitaly.Prosyak@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 60f20d96f9e0..394a87981614 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -60,6 +60,11 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 		plane_state->lut3d_func->ctx = ctx;
 		plane_state->lut3d_func->initialized = false;
 	}
+	plane_state->blend_tf = dc_create_transfer_func();
+	if (plane_state->blend_tf != NULL) {
+		plane_state->blend_tf->type = TF_TYPE_BYPASS;
+		plane_state->blend_tf->ctx = ctx;
+	}
 
 #endif
 }
@@ -85,6 +90,11 @@ static void destruct(struct dc_plane_state *plane_state)
 				plane_state->lut3d_func);
 		plane_state->lut3d_func = NULL;
 	}
+	if (plane_state->blend_tf != NULL) {
+		dc_transfer_func_release(
+				plane_state->blend_tf);
+		plane_state->blend_tf = NULL;
+	}
 
 #endif
 }

commit 6fbefb84a98ecc43cb4035c44fe417e6751ddd83
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:34 2019 -0500

    drm/amd/display: Add DC core changes for DCN2
    
    Core DC changes for DCN2.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index a5e86f9b148f..60f20d96f9e0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -48,6 +48,20 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 		plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
 		plane_state->in_transfer_func->ctx = ctx;
 	}
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	plane_state->in_shaper_func = dc_create_transfer_func();
+	if (plane_state->in_shaper_func != NULL) {
+		plane_state->in_shaper_func->type = TF_TYPE_BYPASS;
+		plane_state->in_shaper_func->ctx = ctx;
+	}
+
+	plane_state->lut3d_func = dc_create_3dlut_func();
+	if (plane_state->lut3d_func != NULL) {
+		plane_state->lut3d_func->ctx = ctx;
+		plane_state->lut3d_func->initialized = false;
+	}
+
+#endif
 }
 
 static void destruct(struct dc_plane_state *plane_state)
@@ -60,6 +74,19 @@ static void destruct(struct dc_plane_state *plane_state)
 				plane_state->in_transfer_func);
 		plane_state->in_transfer_func = NULL;
 	}
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	if (plane_state->in_shaper_func != NULL) {
+		dc_transfer_func_release(
+				plane_state->in_shaper_func);
+		plane_state->in_shaper_func = NULL;
+	}
+	if (plane_state->lut3d_func != NULL) {
+		dc_3dlut_func_release(
+				plane_state->lut3d_func);
+		plane_state->lut3d_func = NULL;
+	}
+
+#endif
 }
 
 /*******************************************************************************
@@ -224,4 +251,40 @@ struct dc_transfer_func *dc_create_transfer_func(void)
 	return NULL;
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+static void dc_3dlut_func_free(struct kref *kref)
+{
+	struct dc_3dlut *lut = container_of(kref, struct dc_3dlut, refcount);
+
+	kvfree(lut);
+}
+
+struct dc_3dlut *dc_create_3dlut_func(void)
+{
+	struct dc_3dlut *lut = kvzalloc(sizeof(*lut), GFP_KERNEL);
+
+	if (lut == NULL)
+		goto alloc_fail;
+
+	kref_init(&lut->refcount);
+	lut->initialized = false;
+
+	return lut;
+
+alloc_fail:
+	return NULL;
+
+}
+
+void dc_3dlut_func_release(struct dc_3dlut *lut)
+{
+	kref_put(&lut->refcount, dc_3dlut_func_free);
+}
+
+void dc_3dlut_func_retain(struct dc_3dlut *lut)
+{
+	kref_get(&lut->refcount);
+}
+#endif
+
 

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index a5e86f9b148f..87b3b03c3556 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/mm.h>
+
 /* DC interface (public) */
 #include "dm_services.h"
 #include "dc.h"

commit 128c075ad4fc4139f47bcd38a5115573394a0e34
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Wed Feb 6 13:19:08 2019 -0500

    drm/amd/display: Set flip pending for pipe split
    
    [WHY]
    When doing split pipe, if one pipe is pending on flip, the entire
    plane's status should be flip pending, otherwise corruption can occur
    when OS writes to a surface prematurely.
    
    [HOW]
    Clear the flip pending bit before checking pipes, then OR the flip
    pending bits from all pipes together to create the flip pending status
    of the entire plane.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Eryk Brol <Eryk.Brol@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index ee6bd50f60b8..a5e86f9b148f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -119,6 +119,19 @@ const struct dc_plane_status *dc_plane_get_status(
 	if (core_dc->current_state == NULL)
 		return NULL;
 
+	/* Find the current plane state and set its pending bit to false */
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx =
+				&core_dc->current_state->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->plane_state != plane_state)
+			continue;
+
+		pipe_ctx->plane_state->status.is_flip_pending = false;
+
+		break;
+	}
+
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_state->res_ctx.pipe_ctx[i];

commit ccab1217230246dccc3110990b028f195ad2d609
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed Jan 2 14:12:53 2019 -0500

    drm/amd/display: Check for NULL when creating gamma struct
    
    [Wjy&How] Some stress test is causing unexpected memory allocation
    failure. This prevents null dereference but there will likely be problems
    later, hard to gracefully handle memalloc fail for critical objects.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Reza Amini <Reza.Amini@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index c60c9b4c3075..ee6bd50f60b8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -40,11 +40,14 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 	plane_state->ctx = ctx;
 
 	plane_state->gamma_correction = dc_create_gamma();
-	plane_state->gamma_correction->is_identity = true;
+	if (plane_state->gamma_correction != NULL)
+		plane_state->gamma_correction->is_identity = true;
 
 	plane_state->in_transfer_func = dc_create_transfer_func();
-	plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
-	plane_state->in_transfer_func->ctx = ctx;
+	if (plane_state->in_transfer_func != NULL) {
+		plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+		plane_state->in_transfer_func->ctx = ctx;
+	}
 }
 
 static void destruct(struct dc_plane_state *plane_state)

commit ce8a805ae1768be16c62a541ce1b2d23e7b99124
Author: David Francis <David.Francis@amd.com>
Date:   Fri Sep 21 14:36:17 2018 -0400

    drm/amd/display: initialize dc_transfer_func->ctx
    
    [Why]
    dc_transfer_func structs were being passed around with a null
    pointer, waiting for unsuspecting programmers to dereference it.
    
    [How]
    Initialize it
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 8fb3aefd195c..c60c9b4c3075 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -44,6 +44,7 @@ static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state
 
 	plane_state->in_transfer_func = dc_create_transfer_func();
 	plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
+	plane_state->in_transfer_func->ctx = ctx;
 }
 
 static void destruct(struct dc_plane_state *plane_state)

commit 7ac7aebe85d3b3b57a58efefcdde2bd5d398550d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jul 31 11:42:54 2018 +0100

    drm/amd/display: add missing void parameter to dc_create_transfer_func
    
    Add a missing void parameter to function dc_create_transfer_func, fixes
    sparse warning:
    
    warning: non-ANSI function declaration of function 'dc_create_transfer_func'
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 815dfb50089b..8fb3aefd195c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -192,7 +192,7 @@ void dc_transfer_func_release(struct dc_transfer_func *tf)
 	kref_put(&tf->refcount, dc_transfer_func_free);
 }
 
-struct dc_transfer_func *dc_create_transfer_func()
+struct dc_transfer_func *dc_create_transfer_func(void)
 {
 	struct dc_transfer_func *tf = kvzalloc(sizeof(*tf), GFP_KERNEL);
 

commit a27f1996778363adc5ca3a31f6306edd8fa54350
Author: Yasir Al Shekerchi <YasirAl.Shekerchi@amd.com>
Date:   Fri May 4 16:53:03 2018 -0400

    drm/amd/display: Added documentation for some DC interface functions
    
    Signed-off-by: Yasir Al Shekerchi <YasirAl.Shekerchi@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 68a71adeb12e..815dfb50089b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -84,6 +84,17 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 	return plane_state;
 }
 
+/**
+ *****************************************************************************
+ *  Function: dc_plane_get_status
+ *
+ *  @brief
+ *     Looks up the pipe context of plane_state and updates the pending status
+ *     of the pipe context. Then returns plane_state->status
+ *
+ *  @param [in] plane_state: pointer to the plane_state to get the status of
+ *****************************************************************************
+ */
 const struct dc_plane_status *dc_plane_get_status(
 		const struct dc_plane_state *plane_state)
 {

commit f7dbe9186d85dd63df7868d408fea6859281c446
Author: Michel Dänzer <michel.daenzer@amd.com>
Date:   Tue Apr 17 12:25:22 2018 +0200

    drm/amd/display: Use kvzalloc for potentially large allocations
    
    Allocating up to 32 physically contiguous pages can easily fail (and has
    failed for me), and isn't necessary anyway.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 959387705965..68a71adeb12e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -72,8 +72,8 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 {
 	struct dc *core_dc = dc;
 
-	struct dc_plane_state *plane_state = kzalloc(sizeof(*plane_state),
-						     GFP_KERNEL);
+	struct dc_plane_state *plane_state = kvzalloc(sizeof(*plane_state),
+						      GFP_KERNEL);
 
 	if (NULL == plane_state)
 		return NULL;
@@ -126,7 +126,7 @@ static void dc_plane_state_free(struct kref *kref)
 {
 	struct dc_plane_state *plane_state = container_of(kref, struct dc_plane_state, refcount);
 	destruct(plane_state);
-	kfree(plane_state);
+	kvfree(plane_state);
 }
 
 void dc_plane_state_release(struct dc_plane_state *plane_state)
@@ -142,7 +142,7 @@ void dc_gamma_retain(struct dc_gamma *gamma)
 static void dc_gamma_free(struct kref *kref)
 {
 	struct dc_gamma *gamma = container_of(kref, struct dc_gamma, refcount);
-	kfree(gamma);
+	kvfree(gamma);
 }
 
 void dc_gamma_release(struct dc_gamma **gamma)
@@ -153,7 +153,7 @@ void dc_gamma_release(struct dc_gamma **gamma)
 
 struct dc_gamma *dc_create_gamma(void)
 {
-	struct dc_gamma *gamma = kzalloc(sizeof(*gamma), GFP_KERNEL);
+	struct dc_gamma *gamma = kvzalloc(sizeof(*gamma), GFP_KERNEL);
 
 	if (gamma == NULL)
 		goto alloc_fail;
@@ -173,7 +173,7 @@ void dc_transfer_func_retain(struct dc_transfer_func *tf)
 static void dc_transfer_func_free(struct kref *kref)
 {
 	struct dc_transfer_func *tf = container_of(kref, struct dc_transfer_func, refcount);
-	kfree(tf);
+	kvfree(tf);
 }
 
 void dc_transfer_func_release(struct dc_transfer_func *tf)
@@ -183,7 +183,7 @@ void dc_transfer_func_release(struct dc_transfer_func *tf)
 
 struct dc_transfer_func *dc_create_transfer_func()
 {
-	struct dc_transfer_func *tf = kzalloc(sizeof(*tf), GFP_KERNEL);
+	struct dc_transfer_func *tf = kvzalloc(sizeof(*tf), GFP_KERNEL);
 
 	if (tf == NULL)
 		goto alloc_fail;

commit e43a432c018a9a2c2641e1f8c08a836cc83982cd
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Mar 27 16:43:56 2018 -0400

    drm/amd/display: Have DC manage its own allocation of gamma
    
    Creating plane will also allocate gamma and input TF
    Creating stream will also allocate outputTF
    
    Fix issue with gamma not applied
    OS may call SetGamma before surface committed, so need to store
    in target and apply later.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index ade5b8ee9c3c..959387705965 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -38,6 +38,12 @@
 static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
 	plane_state->ctx = ctx;
+
+	plane_state->gamma_correction = dc_create_gamma();
+	plane_state->gamma_correction->is_identity = true;
+
+	plane_state->in_transfer_func = dc_create_transfer_func();
+	plane_state->in_transfer_func->type = TF_TYPE_BYPASS;
 }
 
 static void destruct(struct dc_plane_state *plane_state)
@@ -175,7 +181,7 @@ void dc_transfer_func_release(struct dc_transfer_func *tf)
 	kref_put(&tf->refcount, dc_transfer_func_free);
 }
 
-struct dc_transfer_func *dc_create_transfer_func(void)
+struct dc_transfer_func *dc_create_transfer_func()
 {
 	struct dc_transfer_func *tf = kzalloc(sizeof(*tf), GFP_KERNEL);
 

commit a4718a5bca77954ffaa5f828158c45aae40a7ec8
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 7 05:17:12 2017 +1000

    amdgpu/dc: fix non-ansi function decls.
    
    smatch reported:
    drivers/gpu/drm/amd/amdgpu/../display/dc/bios/dce80/command_table_helper_dce80.c:351:71: warning: non-ANSI function declaration of function 'dal_cmd_tbl_helper_dce80_get_table'
    drivers/gpu/drm/amd/amdgpu/../display/dc/bios/dce110/command_table_helper_dce110.c:361:72: warning: non-ANSI function declaration of function 'dal_cmd_tbl_helper_dce110_get_table'
    drivers/gpu/drm/amd/amdgpu/../display/dc/bios/dce112/command_table_helper_dce112.c:415:72: warning: non-ANSI function declaration of function 'dal_cmd_tbl_helper_dce112_get_table'
    drivers/gpu/drm/amd/amdgpu/../display/dc/bios/dce112/command_table_helper2_dce112.c:415:73: warning: non-ANSI function declaration of function 'dal_cmd_tbl_helper_dce112_get_table2'
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_surface.c:148:34: warning: non-ANSI function declaration of function 'dc_create_gamma'
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_surface.c:178:50: warning: non-ANSI function declaration of function 'dc_create_transfer_func'
    
    This fixes them.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 5aa2270f36fd..ade5b8ee9c3c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -145,7 +145,7 @@ void dc_gamma_release(struct dc_gamma **gamma)
 	*gamma = NULL;
 }
 
-struct dc_gamma *dc_create_gamma()
+struct dc_gamma *dc_create_gamma(void)
 {
 	struct dc_gamma *gamma = kzalloc(sizeof(*gamma), GFP_KERNEL);
 
@@ -175,7 +175,7 @@ void dc_transfer_func_release(struct dc_transfer_func *tf)
 	kref_put(&tf->refcount, dc_transfer_func_free);
 }
 
-struct dc_transfer_func *dc_create_transfer_func()
+struct dc_transfer_func *dc_create_transfer_func(void)
 {
 	struct dc_transfer_func *tf = kzalloc(sizeof(*tf), GFP_KERNEL);
 

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index d43783a45ab6..5aa2270f36fd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -30,6 +30,7 @@
 /* DC core (private) */
 #include "core_types.h"
 #include "transform.h"
+#include "dpp.h"
 
 /*******************************************************************************
  * Private functions

commit 4d090f0fae08ddaccf8caaf707f386d52b7f7a08
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:38:59 2017 +1000

    amdgpu/dc: use kref for dc_plane_state.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 0950075b6c54..d43783a45ab6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -71,8 +71,8 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 	if (NULL == plane_state)
 		return NULL;
 
+	kref_init(&plane_state->refcount);
 	construct(core_dc->ctx, plane_state);
-	atomic_inc(&plane_state->ref_count);
 
 	return plane_state;
 }
@@ -112,19 +112,19 @@ const struct dc_plane_status *dc_plane_get_status(
 
 void dc_plane_state_retain(struct dc_plane_state *plane_state)
 {
-	ASSERT(atomic_read(&plane_state->ref_count) > 0);
-	atomic_inc(&plane_state->ref_count);
+	kref_get(&plane_state->refcount);
 }
 
-void dc_plane_state_release(struct dc_plane_state *plane_state)
+static void dc_plane_state_free(struct kref *kref)
 {
-	ASSERT(atomic_read(&plane_state->ref_count) > 0);
-	atomic_dec(&plane_state->ref_count);
+	struct dc_plane_state *plane_state = container_of(kref, struct dc_plane_state, refcount);
+	destruct(plane_state);
+	kfree(plane_state);
+}
 
-	if (atomic_read(&plane_state->ref_count) == 0) {
-		destruct(plane_state);
-		kfree(plane_state);
-	}
+void dc_plane_state_release(struct dc_plane_state *plane_state)
+{
+	kref_put(&plane_state->refcount, dc_plane_state_free);
 }
 
 void dc_gamma_retain(struct dc_gamma *gamma)

commit 5c58ab0bd61b5c8538721f4200475c0af0e33efe
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:38:58 2017 +1000

    amdgpu/dc: convert dc_gamma to kref reference counting.
    
    Rolling your own reference counting is frowned upon.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index c2168dfacc8d..0950075b6c54 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -129,18 +129,18 @@ void dc_plane_state_release(struct dc_plane_state *plane_state)
 
 void dc_gamma_retain(struct dc_gamma *gamma)
 {
-	ASSERT(atomic_read(&gamma->ref_count) > 0);
-	atomic_inc(&gamma->ref_count);
+	kref_get(&gamma->refcount);
 }
 
-void dc_gamma_release(struct dc_gamma **gamma)
+static void dc_gamma_free(struct kref *kref)
 {
-	ASSERT(atomic_read(&(*gamma)->ref_count) > 0);
-	atomic_dec(&(*gamma)->ref_count);
-
-	if (atomic_read(&(*gamma)->ref_count) == 0)
-		kfree((*gamma));
+	struct dc_gamma *gamma = container_of(kref, struct dc_gamma, refcount);
+	kfree(gamma);
+}
 
+void dc_gamma_release(struct dc_gamma **gamma)
+{
+	kref_put(&(*gamma)->refcount, dc_gamma_free);
 	*gamma = NULL;
 }
 
@@ -151,8 +151,7 @@ struct dc_gamma *dc_create_gamma()
 	if (gamma == NULL)
 		goto alloc_fail;
 
-	atomic_inc(&gamma->ref_count);
-
+	kref_init(&gamma->refcount);
 	return gamma;
 
 alloc_fail:

commit 93052132568aedb5eda04deae51d6034738a4800
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:38:57 2017 +1000

    amdgpu/dc: convert dc_transfer to use a kref.
    
    Rolling your own atomic ref counts is frowned upon.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index ff07105bfd99..c2168dfacc8d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -161,17 +161,18 @@ struct dc_gamma *dc_create_gamma()
 
 void dc_transfer_func_retain(struct dc_transfer_func *tf)
 {
-	ASSERT(atomic_read(&tf->ref_count) > 0);
-	atomic_inc(&tf->ref_count);
+	kref_get(&tf->refcount);
 }
 
-void dc_transfer_func_release(struct dc_transfer_func *tf)
+static void dc_transfer_func_free(struct kref *kref)
 {
-	ASSERT(atomic_read(&tf->ref_count) > 0);
-	atomic_dec(&tf->ref_count);
+	struct dc_transfer_func *tf = container_of(kref, struct dc_transfer_func, refcount);
+	kfree(tf);
+}
 
-	if (atomic_read(&tf->ref_count) == 0)
-		kfree(tf);
+void dc_transfer_func_release(struct dc_transfer_func *tf)
+{
+	kref_put(&tf->refcount, dc_transfer_func_free);
 }
 
 struct dc_transfer_func *dc_create_transfer_func()
@@ -181,7 +182,7 @@ struct dc_transfer_func *dc_create_transfer_func()
 	if (tf == NULL)
 		goto alloc_fail;
 
-	atomic_inc(&tf->ref_count);
+	kref_init(&tf->refcount);
 
 	return tf;
 

commit 4ee67c71b89948289eb5c55f1a19281be61178e5
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:37:33 2017 +1000

    amdgpu/dc: don't memset after kzalloc.
    
    We allocate this struct zeroed, so don't need to memset in the
    constructor.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index f170ae95529c..ff07105bfd99 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -37,8 +37,6 @@
 static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
 	plane_state->ctx = ctx;
-	memset(&plane_state->hdr_static_ctx,
-			0, sizeof(struct dc_hdr_static_metadata));
 }
 
 static void destruct(struct dc_plane_state *plane_state)

commit db6c3bdcfe2d810338f90a13d415d43dd98d342b
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:41 2017 +1000

    amdgpu: fixup construct to void paths on some more dc objects.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 511ada94530e..f170ae95529c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -34,12 +34,11 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
+static void construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
 	plane_state->ctx = ctx;
 	memset(&plane_state->hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
-	return true;
 }
 
 static void destruct(struct dc_plane_state *plane_state)
@@ -72,20 +71,12 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 						     GFP_KERNEL);
 
 	if (NULL == plane_state)
-		goto alloc_fail;
-
-	if (false == construct(core_dc->ctx, plane_state))
-		goto construct_fail;
+		return NULL;
 
+	construct(core_dc->ctx, plane_state);
 	atomic_inc(&plane_state->ref_count);
 
 	return plane_state;
-
-construct_fail:
-	kfree(plane_state);
-
-alloc_fail:
-	return NULL;
 }
 
 const struct dc_plane_status *dc_plane_get_status(

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index e96f63eed070..511ada94530e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -68,7 +68,8 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 {
 	struct dc *core_dc = dc;
 
-	struct dc_plane_state *plane_state = dm_alloc(sizeof(*plane_state));
+	struct dc_plane_state *plane_state = kzalloc(sizeof(*plane_state),
+						     GFP_KERNEL);
 
 	if (NULL == plane_state)
 		goto alloc_fail;
@@ -81,7 +82,7 @@ struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 	return plane_state;
 
 construct_fail:
-	dm_free(plane_state);
+	kfree(plane_state);
 
 alloc_fail:
 	return NULL;
@@ -133,7 +134,7 @@ void dc_plane_state_release(struct dc_plane_state *plane_state)
 
 	if (atomic_read(&plane_state->ref_count) == 0) {
 		destruct(plane_state);
-		dm_free(plane_state);
+		kfree(plane_state);
 	}
 }
 
@@ -149,14 +150,14 @@ void dc_gamma_release(struct dc_gamma **gamma)
 	atomic_dec(&(*gamma)->ref_count);
 
 	if (atomic_read(&(*gamma)->ref_count) == 0)
-		dm_free((*gamma));
+		kfree((*gamma));
 
 	*gamma = NULL;
 }
 
 struct dc_gamma *dc_create_gamma()
 {
-	struct dc_gamma *gamma = dm_alloc(sizeof(*gamma));
+	struct dc_gamma *gamma = kzalloc(sizeof(*gamma), GFP_KERNEL);
 
 	if (gamma == NULL)
 		goto alloc_fail;
@@ -181,12 +182,12 @@ void dc_transfer_func_release(struct dc_transfer_func *tf)
 	atomic_dec(&tf->ref_count);
 
 	if (atomic_read(&tf->ref_count) == 0)
-		dm_free(tf);
+		kfree(tf);
 }
 
 struct dc_transfer_func *dc_create_transfer_func()
 {
-	struct dc_transfer_func *tf = dm_alloc(sizeof(*tf));
+	struct dc_transfer_func *tf = kzalloc(sizeof(*tf), GFP_KERNEL);
 
 	if (tf == NULL)
 		goto alloc_fail;

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_state and
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 0b6410fb2f3e..e96f63eed070 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -104,12 +104,12 @@ const struct dc_plane_status *dc_plane_get_status(
 	plane_status = &plane_state->status;
 	core_dc = plane_state->ctx->dc;
 
-	if (core_dc->current_context == NULL)
+	if (core_dc->current_state == NULL)
 		return NULL;
 
 	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
-				&core_dc->current_context->res_ctx.pipe_ctx[i];
+				&core_dc->current_state->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->plane_state != plane_state)
 			continue;

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index da19c7fa5151..0b6410fb2f3e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -28,7 +28,7 @@
 #include "dc.h"
 
 /* DC core (private) */
-#include "core_dc.h"
+#include "core_types.h"
 #include "transform.h"
 
 /*******************************************************************************
@@ -64,9 +64,9 @@ void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_plane_state *dc_create_plane_state(const struct dc *dc)
+struct dc_plane_state *dc_create_plane_state(struct dc *dc)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 
 	struct dc_plane_state *plane_state = dm_alloc(sizeof(*plane_state));
 
@@ -91,7 +91,7 @@ const struct dc_plane_status *dc_plane_get_status(
 		const struct dc_plane_state *plane_state)
 {
 	const struct dc_plane_status *plane_status;
-	struct core_dc *core_dc;
+	struct dc  *core_dc;
 	int i;
 
 	if (!plane_state ||
@@ -102,7 +102,7 @@ const struct dc_plane_status *dc_plane_get_status(
 	}
 
 	plane_status = &plane_state->status;
-	core_dc = DC_TO_CORE(plane_state->ctx->dc);
+	core_dc = plane_state->ctx->dc;
 
 	if (core_dc->current_context == NULL)
 		return NULL;

commit e8cd26434df0cd8d97f31aeb4399afcdc37fcfda
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Mon Jul 31 17:10:44 2017 -0400

    drm/amd/display: Use atomic types for ref_count
    
    Current ref_count inc/dec is not guarded by locks which leads to
    a raced condition where two threads try to access the variable
    at the same time. In this case, both might act on the same cached
    value and inc/dec from the same value, rather than inc/dec by 2.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 3bcca2d1872b..da19c7fa5151 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -76,7 +76,7 @@ struct dc_plane_state *dc_create_plane_state(const struct dc *dc)
 	if (false == construct(core_dc->ctx, plane_state))
 		goto construct_fail;
 
-	++plane_state->ref_count;
+	atomic_inc(&plane_state->ref_count);
 
 	return plane_state;
 
@@ -122,16 +122,16 @@ const struct dc_plane_status *dc_plane_get_status(
 
 void dc_plane_state_retain(struct dc_plane_state *plane_state)
 {
-	ASSERT(plane_state->ref_count > 0);
-	++plane_state->ref_count;
+	ASSERT(atomic_read(&plane_state->ref_count) > 0);
+	atomic_inc(&plane_state->ref_count);
 }
 
 void dc_plane_state_release(struct dc_plane_state *plane_state)
 {
-	ASSERT(plane_state->ref_count > 0);
-	--plane_state->ref_count;
+	ASSERT(atomic_read(&plane_state->ref_count) > 0);
+	atomic_dec(&plane_state->ref_count);
 
-	if (plane_state->ref_count == 0) {
+	if (atomic_read(&plane_state->ref_count) == 0) {
 		destruct(plane_state);
 		dm_free(plane_state);
 	}
@@ -139,16 +139,16 @@ void dc_plane_state_release(struct dc_plane_state *plane_state)
 
 void dc_gamma_retain(struct dc_gamma *gamma)
 {
-	ASSERT(gamma->ref_count > 0);
-	++gamma->ref_count;
+	ASSERT(atomic_read(&gamma->ref_count) > 0);
+	atomic_inc(&gamma->ref_count);
 }
 
 void dc_gamma_release(struct dc_gamma **gamma)
 {
-	ASSERT((*gamma)->ref_count > 0);
-	--(*gamma)->ref_count;
+	ASSERT(atomic_read(&(*gamma)->ref_count) > 0);
+	atomic_dec(&(*gamma)->ref_count);
 
-	if ((*gamma)->ref_count == 0)
+	if (atomic_read(&(*gamma)->ref_count) == 0)
 		dm_free((*gamma));
 
 	*gamma = NULL;
@@ -161,7 +161,7 @@ struct dc_gamma *dc_create_gamma()
 	if (gamma == NULL)
 		goto alloc_fail;
 
-	++gamma->ref_count;
+	atomic_inc(&gamma->ref_count);
 
 	return gamma;
 
@@ -171,16 +171,16 @@ struct dc_gamma *dc_create_gamma()
 
 void dc_transfer_func_retain(struct dc_transfer_func *tf)
 {
-	ASSERT(tf->ref_count > 0);
-	++tf->ref_count;
+	ASSERT(atomic_read(&tf->ref_count) > 0);
+	atomic_inc(&tf->ref_count);
 }
 
 void dc_transfer_func_release(struct dc_transfer_func *tf)
 {
-	ASSERT(tf->ref_count > 0);
-	--tf->ref_count;
+	ASSERT(atomic_read(&tf->ref_count) > 0);
+	atomic_dec(&tf->ref_count);
 
-	if (tf->ref_count == 0)
+	if (atomic_read(&tf->ref_count) == 0)
 		dm_free(tf);
 }
 
@@ -191,7 +191,7 @@ struct dc_transfer_func *dc_create_transfer_func()
 	if (tf == NULL)
 		goto alloc_fail;
 
-	++tf->ref_count;
+	atomic_inc(&tf->ref_count);
 
 	return tf;
 

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 941b3671375d..3bcca2d1872b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -34,75 +34,75 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct dc_plane_state *surface)
+static bool construct(struct dc_context *ctx, struct dc_plane_state *plane_state)
 {
-	surface->ctx = ctx;
-	memset(&surface->hdr_static_ctx,
+	plane_state->ctx = ctx;
+	memset(&plane_state->hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 
-static void destruct(struct dc_plane_state *surface)
+static void destruct(struct dc_plane_state *plane_state)
 {
-	if (surface->gamma_correction != NULL) {
-		dc_gamma_release(&surface->gamma_correction);
+	if (plane_state->gamma_correction != NULL) {
+		dc_gamma_release(&plane_state->gamma_correction);
 	}
-	if (surface->in_transfer_func != NULL) {
+	if (plane_state->in_transfer_func != NULL) {
 		dc_transfer_func_release(
-				surface->in_transfer_func);
-		surface->in_transfer_func = NULL;
+				plane_state->in_transfer_func);
+		plane_state->in_transfer_func = NULL;
 	}
 }
 
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-void enable_surface_flip_reporting(struct dc_plane_state *surface,
+void enable_surface_flip_reporting(struct dc_plane_state *plane_state,
 		uint32_t controller_id)
 {
-	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
+	plane_state->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_plane_state *dc_create_surface(const struct dc *dc)
+struct dc_plane_state *dc_create_plane_state(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_plane_state *surface = dm_alloc(sizeof(*surface));
+	struct dc_plane_state *plane_state = dm_alloc(sizeof(*plane_state));
 
-	if (NULL == surface)
+	if (NULL == plane_state)
 		goto alloc_fail;
 
-	if (false == construct(core_dc->ctx, surface))
+	if (false == construct(core_dc->ctx, plane_state))
 		goto construct_fail;
 
-	++surface->ref_count;
+	++plane_state->ref_count;
 
-	return surface;
+	return plane_state;
 
 construct_fail:
-	dm_free(surface);
+	dm_free(plane_state);
 
 alloc_fail:
 	return NULL;
 }
 
-const struct dc_surface_status *dc_surface_get_status(
-		const struct dc_plane_state *dc_surface)
+const struct dc_plane_status *dc_plane_get_status(
+		const struct dc_plane_state *plane_state)
 {
-	const struct dc_surface_status *surface_status;
+	const struct dc_plane_status *plane_status;
 	struct core_dc *core_dc;
 	int i;
 
-	if (!dc_surface ||
-		!dc_surface->ctx ||
-		!dc_surface->ctx->dc) {
+	if (!plane_state ||
+		!plane_state->ctx ||
+		!plane_state->ctx->dc) {
 		ASSERT(0);
 		return NULL; /* remove this if above assert never hit */
 	}
 
-	surface_status = &dc_surface->status;
-	core_dc = DC_TO_CORE(dc_surface->ctx->dc);
+	plane_status = &plane_state->status;
+	core_dc = DC_TO_CORE(plane_state->ctx->dc);
 
 	if (core_dc->current_context == NULL)
 		return NULL;
@@ -111,29 +111,29 @@ const struct dc_surface_status *dc_surface_get_status(
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != dc_surface)
+		if (pipe_ctx->plane_state != plane_state)
 			continue;
 
 		core_dc->hwss.update_pending_status(pipe_ctx);
 	}
 
-	return surface_status;
+	return plane_status;
 }
 
-void dc_surface_retain(struct dc_plane_state *surface)
+void dc_plane_state_retain(struct dc_plane_state *plane_state)
 {
-	ASSERT(surface->ref_count > 0);
-	++surface->ref_count;
+	ASSERT(plane_state->ref_count > 0);
+	++plane_state->ref_count;
 }
 
-void dc_surface_release(struct dc_plane_state *surface)
+void dc_plane_state_release(struct dc_plane_state *plane_state)
 {
-	ASSERT(surface->ref_count > 0);
-	--surface->ref_count;
+	ASSERT(plane_state->ref_count > 0);
+	--plane_state->ref_count;
 
-	if (surface->ref_count == 0) {
-		destruct(surface);
-		dm_free(surface);
+	if (plane_state->ref_count == 0) {
+		destruct(plane_state);
+		dm_free(plane_state);
 	}
 }
 

commit c9614aeb12f80fa7a787e608d75b707175997edd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:24:04 2017 -0400

    drm/amd/display: Rename dc_surface to dc_plane_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_surface/struct dc_plane_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_update/struct dc_surface_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_status/struct dc_surface_status/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_dcc_cap/struct dc_surface_dcc_cap/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index eded6b7da97d..941b3671375d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -34,7 +34,7 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct dc_surface *surface)
+static bool construct(struct dc_context *ctx, struct dc_plane_state *surface)
 {
 	surface->ctx = ctx;
 	memset(&surface->hdr_static_ctx,
@@ -42,7 +42,7 @@ static bool construct(struct dc_context *ctx, struct dc_surface *surface)
 	return true;
 }
 
-static void destruct(struct dc_surface *surface)
+static void destruct(struct dc_plane_state *surface)
 {
 	if (surface->gamma_correction != NULL) {
 		dc_gamma_release(&surface->gamma_correction);
@@ -57,18 +57,18 @@ static void destruct(struct dc_surface *surface)
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-void enable_surface_flip_reporting(struct dc_surface *surface,
+void enable_surface_flip_reporting(struct dc_plane_state *surface,
 		uint32_t controller_id)
 {
 	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
 
-struct dc_surface *dc_create_surface(const struct dc *dc)
+struct dc_plane_state *dc_create_surface(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct dc_surface *surface = dm_alloc(sizeof(*surface));
+	struct dc_plane_state *surface = dm_alloc(sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
@@ -88,7 +88,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 }
 
 const struct dc_surface_status *dc_surface_get_status(
-		const struct dc_surface *dc_surface)
+		const struct dc_plane_state *dc_surface)
 {
 	const struct dc_surface_status *surface_status;
 	struct core_dc *core_dc;
@@ -120,13 +120,13 @@ const struct dc_surface_status *dc_surface_get_status(
 	return surface_status;
 }
 
-void dc_surface_retain(struct dc_surface *surface)
+void dc_surface_retain(struct dc_plane_state *surface)
 {
 	ASSERT(surface->ref_count > 0);
 	++surface->ref_count;
 }
 
-void dc_surface_release(struct dc_surface *surface)
+void dc_surface_release(struct dc_plane_state *surface)
 {
 	ASSERT(surface->ref_count > 0);
 	--surface->ref_count;

commit 7a6c4af6bf41516cc9e12d83cc8fcebfdd8be01c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 15:30:17 2017 -0400

    drm/amd/display: Roll core_gamma into dc_gamma
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index a8b9515fd367..eded6b7da97d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -137,37 +137,33 @@ void dc_surface_release(struct dc_surface *surface)
 	}
 }
 
-void dc_gamma_retain(const struct dc_gamma *dc_gamma)
+void dc_gamma_retain(struct dc_gamma *gamma)
 {
-	struct core_gamma *gamma = DC_GAMMA_TO_CORE(dc_gamma);
-
 	ASSERT(gamma->ref_count > 0);
 	++gamma->ref_count;
 }
 
-void dc_gamma_release(const struct dc_gamma **dc_gamma)
+void dc_gamma_release(struct dc_gamma **gamma)
 {
-	struct core_gamma *gamma = DC_GAMMA_TO_CORE(*dc_gamma);
-
-	ASSERT(gamma->ref_count > 0);
-	--gamma->ref_count;
+	ASSERT((*gamma)->ref_count > 0);
+	--(*gamma)->ref_count;
 
-	if (gamma->ref_count == 0)
-		dm_free(gamma);
+	if ((*gamma)->ref_count == 0)
+		dm_free((*gamma));
 
-	*dc_gamma = NULL;
+	*gamma = NULL;
 }
 
 struct dc_gamma *dc_create_gamma()
 {
-	struct core_gamma *gamma = dm_alloc(sizeof(*gamma));
+	struct dc_gamma *gamma = dm_alloc(sizeof(*gamma));
 
 	if (gamma == NULL)
 		goto alloc_fail;
 
 	++gamma->ref_count;
 
-	return &gamma->public;
+	return gamma;
 
 alloc_fail:
 	return NULL;

commit 0b0aab86d51ee63d521f0d96ff4dfe1d6252f9b2
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 15:20:50 2017 -0400

    drm/amd/display: Roll gamma struct into core_gamma
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 9a21ea71f4b3..a8b9515fd367 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -31,19 +31,6 @@
 #include "core_dc.h"
 #include "transform.h"
 
-/*******************************************************************************
- * Private structures
- ******************************************************************************/
-struct gamma {
-	struct core_gamma protected;
-	int ref_count;
-};
-
-#define DC_GAMMA_TO_GAMMA(dc_gamma) \
-	container_of(dc_gamma, struct gamma, protected.public)
-#define CORE_GAMMA_TO_GAMMA(core_gamma) \
-	container_of(core_gamma, struct gamma, protected)
-
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
@@ -152,7 +139,7 @@ void dc_surface_release(struct dc_surface *surface)
 
 void dc_gamma_retain(const struct dc_gamma *dc_gamma)
 {
-	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
+	struct core_gamma *gamma = DC_GAMMA_TO_CORE(dc_gamma);
 
 	ASSERT(gamma->ref_count > 0);
 	++gamma->ref_count;
@@ -160,7 +147,7 @@ void dc_gamma_retain(const struct dc_gamma *dc_gamma)
 
 void dc_gamma_release(const struct dc_gamma **dc_gamma)
 {
-	struct gamma *gamma = DC_GAMMA_TO_GAMMA(*dc_gamma);
+	struct core_gamma *gamma = DC_GAMMA_TO_CORE(*dc_gamma);
 
 	ASSERT(gamma->ref_count > 0);
 	--gamma->ref_count;
@@ -173,14 +160,14 @@ void dc_gamma_release(const struct dc_gamma **dc_gamma)
 
 struct dc_gamma *dc_create_gamma()
 {
-	struct gamma *gamma = dm_alloc(sizeof(*gamma));
+	struct core_gamma *gamma = dm_alloc(sizeof(*gamma));
 
 	if (gamma == NULL)
 		goto alloc_fail;
 
 	++gamma->ref_count;
 
-	return &gamma->protected.public;
+	return &gamma->public;
 
 alloc_fail:
 	return NULL;

commit e12cfcb1d447cc937d1abc6f4aab8bbe5f88542e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 11:43:32 2017 -0400

    drm/amd/display: Roll core_surface into dc_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 3784358d35ef..9a21ea71f4b3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -47,33 +47,32 @@ struct gamma {
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct core_surface *surface)
+static bool construct(struct dc_context *ctx, struct dc_surface *surface)
 {
 	surface->ctx = ctx;
-	memset(&surface->public.hdr_static_ctx,
+	memset(&surface->hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 
-static void destruct(struct core_surface *surface)
+static void destruct(struct dc_surface *surface)
 {
-	if (surface->public.gamma_correction != NULL) {
-		dc_gamma_release(&surface->public.gamma_correction);
+	if (surface->gamma_correction != NULL) {
+		dc_gamma_release(&surface->gamma_correction);
 	}
-	if (surface->public.in_transfer_func != NULL) {
+	if (surface->in_transfer_func != NULL) {
 		dc_transfer_func_release(
-				surface->public.in_transfer_func);
-		surface->public.in_transfer_func = NULL;
+				surface->in_transfer_func);
+		surface->in_transfer_func = NULL;
 	}
 }
 
 /*******************************************************************************
  * Public functions
  ******************************************************************************/
-void enable_surface_flip_reporting(struct dc_surface *dc_surface,
+void enable_surface_flip_reporting(struct dc_surface *surface,
 		uint32_t controller_id)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
 	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
@@ -82,7 +81,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct core_surface *surface = dm_alloc(sizeof(*surface));
+	struct dc_surface *surface = dm_alloc(sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
@@ -92,7 +91,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 
 	++surface->ref_count;
 
-	return &surface->public;
+	return surface;
 
 construct_fail:
 	dm_free(surface);
@@ -104,20 +103,19 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 const struct dc_surface_status *dc_surface_get_status(
 		const struct dc_surface *dc_surface)
 {
-	struct dc_surface_status *surface_status;
-	struct core_surface *core_surface = DC_SURFACE_TO_CORE(dc_surface);
+	const struct dc_surface_status *surface_status;
 	struct core_dc *core_dc;
 	int i;
 
 	if (!dc_surface ||
-		!core_surface->ctx ||
-		!core_surface->ctx->dc) {
+		!dc_surface->ctx ||
+		!dc_surface->ctx->dc) {
 		ASSERT(0);
 		return NULL; /* remove this if above assert never hit */
 	}
 
-	surface_status = &core_surface->status;
-	core_dc = DC_TO_CORE(core_surface->ctx->dc);
+	surface_status = &dc_surface->status;
+	core_dc = DC_TO_CORE(dc_surface->ctx->dc);
 
 	if (core_dc->current_context == NULL)
 		return NULL;
@@ -126,7 +124,7 @@ const struct dc_surface_status *dc_surface_get_status(
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface != core_surface)
+		if (pipe_ctx->surface != dc_surface)
 			continue;
 
 		core_dc->hwss.update_pending_status(pipe_ctx);
@@ -135,18 +133,14 @@ const struct dc_surface_status *dc_surface_get_status(
 	return surface_status;
 }
 
-void dc_surface_retain(const struct dc_surface *dc_surface)
+void dc_surface_retain(struct dc_surface *surface)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
-
 	ASSERT(surface->ref_count > 0);
 	++surface->ref_count;
 }
 
-void dc_surface_release(const struct dc_surface *dc_surface)
+void dc_surface_release(struct dc_surface *surface)
 {
-	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
-
 	ASSERT(surface->ref_count > 0);
 	--surface->ref_count;
 

commit 03618e910797c9bb7ec8eb1e45df64ad8080a37a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 10:26:23 2017 -0400

    drm/amd/display: Roll surface struct into core_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index d44ddfb85748..3784358d35ef 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -34,20 +34,11 @@
 /*******************************************************************************
  * Private structures
  ******************************************************************************/
-struct surface {
-	struct core_surface protected;
-	enum dc_irq_source irq_source;
-	int ref_count;
-};
-
 struct gamma {
 	struct core_gamma protected;
 	int ref_count;
 };
 
-#define DC_SURFACE_TO_SURFACE(dc_surface) container_of(dc_surface, struct surface, protected.public)
-#define CORE_SURFACE_TO_SURFACE(core_surface) container_of(core_surface, struct surface, protected)
-
 #define DC_GAMMA_TO_GAMMA(dc_gamma) \
 	container_of(dc_gamma, struct gamma, protected.public)
 #define CORE_GAMMA_TO_GAMMA(core_gamma) \
@@ -56,23 +47,23 @@ struct gamma {
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static bool construct(struct dc_context *ctx, struct surface *surface)
+static bool construct(struct dc_context *ctx, struct core_surface *surface)
 {
-	surface->protected.ctx = ctx;
-	memset(&surface->protected.public.hdr_static_ctx,
+	surface->ctx = ctx;
+	memset(&surface->public.hdr_static_ctx,
 			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 
-static void destruct(struct surface *surface)
+static void destruct(struct core_surface *surface)
 {
-	if (surface->protected.public.gamma_correction != NULL) {
-		dc_gamma_release(&surface->protected.public.gamma_correction);
+	if (surface->public.gamma_correction != NULL) {
+		dc_gamma_release(&surface->public.gamma_correction);
 	}
-	if (surface->protected.public.in_transfer_func != NULL) {
+	if (surface->public.in_transfer_func != NULL) {
 		dc_transfer_func_release(
-				surface->protected.public.in_transfer_func);
-		surface->protected.public.in_transfer_func = NULL;
+				surface->public.in_transfer_func);
+		surface->public.in_transfer_func = NULL;
 	}
 }
 
@@ -82,7 +73,7 @@ static void destruct(struct surface *surface)
 void enable_surface_flip_reporting(struct dc_surface *dc_surface,
 		uint32_t controller_id)
 {
-	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
+	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
 	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
 	/*register_flip_interrupt(surface);*/
 }
@@ -91,7 +82,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
-	struct surface *surface = dm_alloc(sizeof(*surface));
+	struct core_surface *surface = dm_alloc(sizeof(*surface));
 
 	if (NULL == surface)
 		goto alloc_fail;
@@ -101,7 +92,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 
 	++surface->ref_count;
 
-	return &surface->protected.public;
+	return &surface->public;
 
 construct_fail:
 	dm_free(surface);
@@ -146,7 +137,7 @@ const struct dc_surface_status *dc_surface_get_status(
 
 void dc_surface_retain(const struct dc_surface *dc_surface)
 {
-	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
+	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
 
 	ASSERT(surface->ref_count > 0);
 	++surface->ref_count;
@@ -154,7 +145,7 @@ void dc_surface_retain(const struct dc_surface *dc_surface)
 
 void dc_surface_release(const struct dc_surface *dc_surface)
 {
-	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
+	struct core_surface *surface = DC_SURFACE_TO_CORE(dc_surface);
 
 	ASSERT(surface->ref_count > 0);
 	--surface->ref_count;

commit 7b0c470fcb44b7dbe63db5b5fb52b6123ebe335f
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Mon Jul 10 14:04:21 2017 -0400

    drm/amd/display: Flattening to dc_transfer_func
    
    Flattening dc transfer functions in the following manner:
    transfer_func > core_transfer_func > dc_transfer_func
    
    References to deleted structs are updated as needed.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index aa6ac9596235..d44ddfb85748 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -45,18 +45,11 @@ struct gamma {
 	int ref_count;
 };
 
-struct transfer_func {
-	struct core_transfer_func protected;
-	int ref_count;
-};
-
 #define DC_SURFACE_TO_SURFACE(dc_surface) container_of(dc_surface, struct surface, protected.public)
 #define CORE_SURFACE_TO_SURFACE(core_surface) container_of(core_surface, struct surface, protected)
 
 #define DC_GAMMA_TO_GAMMA(dc_gamma) \
 	container_of(dc_gamma, struct gamma, protected.public)
-#define DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf) \
-	container_of(dc_tf, struct transfer_func, protected.public)
 #define CORE_GAMMA_TO_GAMMA(core_gamma) \
 	container_of(core_gamma, struct gamma, protected)
 
@@ -208,18 +201,14 @@ struct dc_gamma *dc_create_gamma()
 	return NULL;
 }
 
-void dc_transfer_func_retain(const struct dc_transfer_func *dc_tf)
+void dc_transfer_func_retain(struct dc_transfer_func *tf)
 {
-	struct transfer_func *tf = DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf);
-
 	ASSERT(tf->ref_count > 0);
 	++tf->ref_count;
 }
 
-void dc_transfer_func_release(const struct dc_transfer_func *dc_tf)
+void dc_transfer_func_release(struct dc_transfer_func *tf)
 {
-	struct transfer_func *tf = DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf);
-
 	ASSERT(tf->ref_count > 0);
 	--tf->ref_count;
 
@@ -229,14 +218,14 @@ void dc_transfer_func_release(const struct dc_transfer_func *dc_tf)
 
 struct dc_transfer_func *dc_create_transfer_func()
 {
-	struct transfer_func *tf = dm_alloc(sizeof(*tf));
+	struct dc_transfer_func *tf = dm_alloc(sizeof(*tf));
 
 	if (tf == NULL)
 		goto alloc_fail;
 
 	++tf->ref_count;
 
-	return &tf->protected.public;
+	return tf;
 
 alloc_fail:
 	return NULL;

commit a2b8659db9b435853cb0dc78d225a492e7ee69d0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Apr 22 14:17:51 2017 -0400

    drm/amd/display: decouple resource_pool from resource_context
    
    to avoid null access in case res_ctx is used to access res_pool before it's fully constructed
    
    also make it clear which function has dependency on resource_pool
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 943895faee49..aa6ac9596235 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -138,8 +138,7 @@ const struct dc_surface_status *dc_surface_get_status(
 	if (core_dc->current_context == NULL)
 		return NULL;
 
-	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count;
-			i++) {
+	for (i = 0; i < core_dc->res_pool->pipe_count; i++) {
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 

commit 648013696767f0266aa7bd44407786a99f7a7910
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 24 11:31:23 2017 -0500

    drm/amd/display: Fix warnings in DC
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 21fedd447bd1..943895faee49 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -121,7 +121,7 @@ const struct dc_surface_status *dc_surface_get_status(
 		const struct dc_surface *dc_surface)
 {
 	struct dc_surface_status *surface_status;
-	struct core_surface *core_surface = DC_SURFACE_TO_CORE(dc_surface);;
+	struct core_surface *core_surface = DC_SURFACE_TO_CORE(dc_surface);
 	struct core_dc *core_dc;
 	int i;
 

commit e4e354b02fa8b6d53ec65bd5dbd27d014e4e752f
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Jan 19 14:46:26 2017 -0500

    drm/amd/display: clean up redundant logic
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index d607972b830b..21fedd447bd1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -121,26 +121,20 @@ const struct dc_surface_status *dc_surface_get_status(
 		const struct dc_surface *dc_surface)
 {
 	struct dc_surface_status *surface_status;
-	struct core_surface *core_surface;
+	struct core_surface *core_surface = DC_SURFACE_TO_CORE(dc_surface);;
 	struct core_dc *core_dc;
 	int i;
 
-	if (dc_surface == NULL)
-		return NULL;
-
-	core_surface = DC_SURFACE_TO_CORE(dc_surface);
-
-	if (core_surface == NULL || core_surface->ctx == NULL)
-		return NULL;
+	if (!dc_surface ||
+		!core_surface->ctx ||
+		!core_surface->ctx->dc) {
+		ASSERT(0);
+		return NULL; /* remove this if above assert never hit */
+	}
 
 	surface_status = &core_surface->status;
-
-	if (core_surface->ctx == NULL || core_surface->ctx->dc == NULL)
-		return NULL;
-
 	core_dc = DC_TO_CORE(core_surface->ctx->dc);
 
-
 	if (core_dc->current_context == NULL)
 		return NULL;
 
@@ -149,8 +143,7 @@ const struct dc_surface_status *dc_surface_get_status(
 		struct pipe_ctx *pipe_ctx =
 				&core_dc->current_context->res_ctx.pipe_ctx[i];
 
-		if (pipe_ctx->surface !=
-				DC_SURFACE_TO_CORE(dc_surface))
+		if (pipe_ctx->surface != core_surface)
 			continue;
 
 		core_dc->hwss.update_pending_status(pipe_ctx);

commit aff20230b439921d6660eb2ef6d9f6c273d9b240
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Dec 23 10:18:08 2016 -0500

    drm/amd/display: Set gamma to NULL at release
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index d962baa477f5..d607972b830b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -74,8 +74,7 @@ static bool construct(struct dc_context *ctx, struct surface *surface)
 static void destruct(struct surface *surface)
 {
 	if (surface->protected.public.gamma_correction != NULL) {
-		dc_gamma_release(surface->protected.public.gamma_correction);
-		surface->protected.public.gamma_correction = NULL;
+		dc_gamma_release(&surface->protected.public.gamma_correction);
 	}
 	if (surface->protected.public.in_transfer_func != NULL) {
 		dc_transfer_func_release(
@@ -189,15 +188,17 @@ void dc_gamma_retain(const struct dc_gamma *dc_gamma)
 	++gamma->ref_count;
 }
 
-void dc_gamma_release(const struct dc_gamma *dc_gamma)
+void dc_gamma_release(const struct dc_gamma **dc_gamma)
 {
-	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
+	struct gamma *gamma = DC_GAMMA_TO_GAMMA(*dc_gamma);
 
 	ASSERT(gamma->ref_count > 0);
 	--gamma->ref_count;
 
 	if (gamma->ref_count == 0)
 		dm_free(gamma);
+
+	*dc_gamma = NULL;
 }
 
 struct dc_gamma *dc_create_gamma()

commit 1646a6fe746d7e923774994d2020e1707dcda884
Author: Andrew Wong <andrew.wong1@amd.com>
Date:   Thu Dec 22 15:41:30 2016 -0500

    drm/amd/display: DAL3: HDR10 Infoframe encoding
    
    - Add HDR metadata struct
    - Add register programming calculations
    - Added HDR metadata to surface and update_surface
    - Add HDR info packet programming for DP port
    
    Signed-off-by: Andrew Wong <andrew.wong1@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 6b4c75a78fe8..d962baa477f5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -66,6 +66,8 @@ struct transfer_func {
 static bool construct(struct dc_context *ctx, struct surface *surface)
 {
 	surface->protected.ctx = ctx;
+	memset(&surface->protected.public.hdr_static_ctx,
+			0, sizeof(struct dc_hdr_static_metadata));
 	return true;
 }
 

commit db96c69ee78845c4f4cadea9fd282fb265253874
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Dec 20 18:01:30 2016 -0500

    drm/amd/display: Add refcount debug assert
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index cf8fb9a8ce8e..6b4c75a78fe8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -105,7 +105,7 @@ struct dc_surface *dc_create_surface(const struct dc *dc)
 	if (false == construct(core_dc->ctx, surface))
 		goto construct_fail;
 
-	dc_surface_retain(&surface->protected.public);
+	++surface->ref_count;
 
 	return &surface->protected.public;
 
@@ -162,6 +162,7 @@ void dc_surface_retain(const struct dc_surface *dc_surface)
 {
 	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
 
+	ASSERT(surface->ref_count > 0);
 	++surface->ref_count;
 }
 
@@ -169,6 +170,7 @@ void dc_surface_release(const struct dc_surface *dc_surface)
 {
 	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
 
+	ASSERT(surface->ref_count > 0);
 	--surface->ref_count;
 
 	if (surface->ref_count == 0) {
@@ -181,12 +183,15 @@ void dc_gamma_retain(const struct dc_gamma *dc_gamma)
 {
 	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
 
+	ASSERT(gamma->ref_count > 0);
 	++gamma->ref_count;
 }
 
 void dc_gamma_release(const struct dc_gamma *dc_gamma)
 {
 	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
+
+	ASSERT(gamma->ref_count > 0);
 	--gamma->ref_count;
 
 	if (gamma->ref_count == 0)
@@ -200,7 +205,7 @@ struct dc_gamma *dc_create_gamma()
 	if (gamma == NULL)
 		goto alloc_fail;
 
-	dc_gamma_retain(&gamma->protected.public);
+	++gamma->ref_count;
 
 	return &gamma->protected.public;
 
@@ -212,12 +217,15 @@ void dc_transfer_func_retain(const struct dc_transfer_func *dc_tf)
 {
 	struct transfer_func *tf = DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf);
 
+	ASSERT(tf->ref_count > 0);
 	++tf->ref_count;
 }
 
 void dc_transfer_func_release(const struct dc_transfer_func *dc_tf)
 {
 	struct transfer_func *tf = DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf);
+
+	ASSERT(tf->ref_count > 0);
 	--tf->ref_count;
 
 	if (tf->ref_count == 0)
@@ -231,7 +239,7 @@ struct dc_transfer_func *dc_create_transfer_func()
 	if (tf == NULL)
 		goto alloc_fail;
 
-	dc_transfer_func_retain(&tf->protected.public);
+	++tf->ref_count;
 
 	return &tf->protected.public;
 

commit 80bd20967261d9438dc814f3e6e904aea053163b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Dec 21 11:13:48 2016 -0500

    drm/amd/display: reset transfer_func to NULL on release
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 3ec1f363e43e..cf8fb9a8ce8e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -71,11 +71,15 @@ static bool construct(struct dc_context *ctx, struct surface *surface)
 
 static void destruct(struct surface *surface)
 {
-	if (surface->protected.public.gamma_correction != NULL)
+	if (surface->protected.public.gamma_correction != NULL) {
 		dc_gamma_release(surface->protected.public.gamma_correction);
-	if (surface->protected.public.in_transfer_func != NULL)
+		surface->protected.public.gamma_correction = NULL;
+	}
+	if (surface->protected.public.in_transfer_func != NULL) {
 		dc_transfer_func_release(
 				surface->protected.public.in_transfer_func);
+		surface->protected.public.in_transfer_func = NULL;
+	}
 }
 
 /*******************************************************************************

commit 90e508ba253c9e43711a7bf16230cdb13d0b1440
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Dec 15 12:09:46 2016 -0500

    drm/amd/display: Refactor output transfer function to stream
    
    Refactor part 3 - Moving output transfer function from surface to stream
    
    Split HWSS to program degamma and regamma separately.
    Degamma should be dependent on input transfer function.
    And Regamma should depend on the desired output transfer function.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 8d2668406f3a..3ec1f363e43e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -76,9 +76,6 @@ static void destruct(struct surface *surface)
 	if (surface->protected.public.in_transfer_func != NULL)
 		dc_transfer_func_release(
 				surface->protected.public.in_transfer_func);
-	if (surface->protected.public.out_transfer_func != NULL)
-		dc_transfer_func_release(
-				surface->protected.public.out_transfer_func);
 }
 
 /*******************************************************************************
@@ -223,9 +220,8 @@ void dc_transfer_func_release(const struct dc_transfer_func *dc_tf)
 		dm_free(tf);
 }
 
-struct dc_transfer_func *dc_create_transfer_func(const struct dc *dc)
+struct dc_transfer_func *dc_create_transfer_func()
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct transfer_func *tf = dm_alloc(sizeof(*tf));
 
 	if (tf == NULL)

commit fb735a9f29f94fcb29fee224b8da704a510a5a3a
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Dec 13 13:59:41 2016 -0500

    drm/amd/display: Add in/out transfer functions to DC
    
    Refactor part 1 of degamma/regamma programming.
    
    End goal is to have source and output transfer function in
    which dc can use to decide how to program the degamma
    and regamma HW.
    
    Gamma will be explicitly applied through
    dc_update_surfaces_for_target.
    
    Color module should build the logical curve with all
    adjustments applied and pass enough information
    for dc to program HW PWL.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index 06d8b326714a..8d2668406f3a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -45,11 +45,18 @@ struct gamma {
 	int ref_count;
 };
 
+struct transfer_func {
+	struct core_transfer_func protected;
+	int ref_count;
+};
+
 #define DC_SURFACE_TO_SURFACE(dc_surface) container_of(dc_surface, struct surface, protected.public)
 #define CORE_SURFACE_TO_SURFACE(core_surface) container_of(core_surface, struct surface, protected)
 
 #define DC_GAMMA_TO_GAMMA(dc_gamma) \
 	container_of(dc_gamma, struct gamma, protected.public)
+#define DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf) \
+	container_of(dc_tf, struct transfer_func, protected.public)
 #define CORE_GAMMA_TO_GAMMA(core_gamma) \
 	container_of(core_gamma, struct gamma, protected)
 
@@ -66,6 +73,12 @@ static void destruct(struct surface *surface)
 {
 	if (surface->protected.public.gamma_correction != NULL)
 		dc_gamma_release(surface->protected.public.gamma_correction);
+	if (surface->protected.public.in_transfer_func != NULL)
+		dc_transfer_func_release(
+				surface->protected.public.in_transfer_func);
+	if (surface->protected.public.out_transfer_func != NULL)
+		dc_transfer_func_release(
+				surface->protected.public.out_transfer_func);
 }
 
 /*******************************************************************************
@@ -163,16 +176,6 @@ void dc_surface_release(const struct dc_surface *dc_surface)
 	}
 }
 
-static bool construct_gamma(struct gamma *gamma)
-{
-	return true;
-}
-
-static void destruct_gamma(struct gamma *gamma)
-{
-
-}
-
 void dc_gamma_retain(const struct dc_gamma *dc_gamma)
 {
 	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
@@ -185,10 +188,8 @@ void dc_gamma_release(const struct dc_gamma *dc_gamma)
 	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
 	--gamma->ref_count;
 
-	if (gamma->ref_count == 0) {
-		destruct_gamma(gamma);
+	if (gamma->ref_count == 0)
 		dm_free(gamma);
-	}
 }
 
 struct dc_gamma *dc_create_gamma()
@@ -198,17 +199,44 @@ struct dc_gamma *dc_create_gamma()
 	if (gamma == NULL)
 		goto alloc_fail;
 
-	if (false == construct_gamma(gamma))
-		goto construct_fail;
-
 	dc_gamma_retain(&gamma->protected.public);
 
 	return &gamma->protected.public;
 
-construct_fail:
-	dm_free(gamma);
+alloc_fail:
+	return NULL;
+}
+
+void dc_transfer_func_retain(const struct dc_transfer_func *dc_tf)
+{
+	struct transfer_func *tf = DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf);
+
+	++tf->ref_count;
+}
+
+void dc_transfer_func_release(const struct dc_transfer_func *dc_tf)
+{
+	struct transfer_func *tf = DC_TRANSFER_FUNC_TO_TRANSFER_FUNC(dc_tf);
+	--tf->ref_count;
+
+	if (tf->ref_count == 0)
+		dm_free(tf);
+}
+
+struct dc_transfer_func *dc_create_transfer_func(const struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct transfer_func *tf = dm_alloc(sizeof(*tf));
+
+	if (tf == NULL)
+		goto alloc_fail;
+
+	dc_transfer_func_retain(&tf->protected.public);
+
+	return &tf->protected.public;
 
 alloc_fail:
 	return NULL;
 }
 
+

commit 89e8963036085e4e0e9a993d2e1bdbb931d53794
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Mon Dec 12 10:32:24 2016 -0500

    drm/amd/display: Fix Gamma Adjustment
    
    - Gamma correction is not properly copied to the surface after refactor
    - Make sure gamma correction is copied with correct retain
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
index b89d3b5d0ba0..06d8b326714a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -64,7 +64,8 @@ static bool construct(struct dc_context *ctx, struct surface *surface)
 
 static void destruct(struct surface *surface)
 {
-
+	if (surface->protected.public.gamma_correction != NULL)
+		dc_gamma_release(surface->protected.public.gamma_correction);
 }
 
 /*******************************************************************************

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_surface.c b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
new file mode 100644
index 000000000000..b89d3b5d0ba0
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_surface.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2015 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+/* DC interface (public) */
+#include "dm_services.h"
+#include "dc.h"
+
+/* DC core (private) */
+#include "core_dc.h"
+#include "transform.h"
+
+/*******************************************************************************
+ * Private structures
+ ******************************************************************************/
+struct surface {
+	struct core_surface protected;
+	enum dc_irq_source irq_source;
+	int ref_count;
+};
+
+struct gamma {
+	struct core_gamma protected;
+	int ref_count;
+};
+
+#define DC_SURFACE_TO_SURFACE(dc_surface) container_of(dc_surface, struct surface, protected.public)
+#define CORE_SURFACE_TO_SURFACE(core_surface) container_of(core_surface, struct surface, protected)
+
+#define DC_GAMMA_TO_GAMMA(dc_gamma) \
+	container_of(dc_gamma, struct gamma, protected.public)
+#define CORE_GAMMA_TO_GAMMA(core_gamma) \
+	container_of(core_gamma, struct gamma, protected)
+
+/*******************************************************************************
+ * Private functions
+ ******************************************************************************/
+static bool construct(struct dc_context *ctx, struct surface *surface)
+{
+	surface->protected.ctx = ctx;
+	return true;
+}
+
+static void destruct(struct surface *surface)
+{
+
+}
+
+/*******************************************************************************
+ * Public functions
+ ******************************************************************************/
+void enable_surface_flip_reporting(struct dc_surface *dc_surface,
+		uint32_t controller_id)
+{
+	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
+	surface->irq_source = controller_id + DC_IRQ_SOURCE_PFLIP1 - 1;
+	/*register_flip_interrupt(surface);*/
+}
+
+struct dc_surface *dc_create_surface(const struct dc *dc)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	struct surface *surface = dm_alloc(sizeof(*surface));
+
+	if (NULL == surface)
+		goto alloc_fail;
+
+	if (false == construct(core_dc->ctx, surface))
+		goto construct_fail;
+
+	dc_surface_retain(&surface->protected.public);
+
+	return &surface->protected.public;
+
+construct_fail:
+	dm_free(surface);
+
+alloc_fail:
+	return NULL;
+}
+
+const struct dc_surface_status *dc_surface_get_status(
+		const struct dc_surface *dc_surface)
+{
+	struct dc_surface_status *surface_status;
+	struct core_surface *core_surface;
+	struct core_dc *core_dc;
+	int i;
+
+	if (dc_surface == NULL)
+		return NULL;
+
+	core_surface = DC_SURFACE_TO_CORE(dc_surface);
+
+	if (core_surface == NULL || core_surface->ctx == NULL)
+		return NULL;
+
+	surface_status = &core_surface->status;
+
+	if (core_surface->ctx == NULL || core_surface->ctx->dc == NULL)
+		return NULL;
+
+	core_dc = DC_TO_CORE(core_surface->ctx->dc);
+
+
+	if (core_dc->current_context == NULL)
+		return NULL;
+
+	for (i = 0; i < core_dc->current_context->res_ctx.pool->pipe_count;
+			i++) {
+		struct pipe_ctx *pipe_ctx =
+				&core_dc->current_context->res_ctx.pipe_ctx[i];
+
+		if (pipe_ctx->surface !=
+				DC_SURFACE_TO_CORE(dc_surface))
+			continue;
+
+		core_dc->hwss.update_pending_status(pipe_ctx);
+	}
+
+	return surface_status;
+}
+
+void dc_surface_retain(const struct dc_surface *dc_surface)
+{
+	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
+
+	++surface->ref_count;
+}
+
+void dc_surface_release(const struct dc_surface *dc_surface)
+{
+	struct surface *surface = DC_SURFACE_TO_SURFACE(dc_surface);
+
+	--surface->ref_count;
+
+	if (surface->ref_count == 0) {
+		destruct(surface);
+		dm_free(surface);
+	}
+}
+
+static bool construct_gamma(struct gamma *gamma)
+{
+	return true;
+}
+
+static void destruct_gamma(struct gamma *gamma)
+{
+
+}
+
+void dc_gamma_retain(const struct dc_gamma *dc_gamma)
+{
+	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
+
+	++gamma->ref_count;
+}
+
+void dc_gamma_release(const struct dc_gamma *dc_gamma)
+{
+	struct gamma *gamma = DC_GAMMA_TO_GAMMA(dc_gamma);
+	--gamma->ref_count;
+
+	if (gamma->ref_count == 0) {
+		destruct_gamma(gamma);
+		dm_free(gamma);
+	}
+}
+
+struct dc_gamma *dc_create_gamma()
+{
+	struct gamma *gamma = dm_alloc(sizeof(*gamma));
+
+	if (gamma == NULL)
+		goto alloc_fail;
+
+	if (false == construct_gamma(gamma))
+		goto construct_fail;
+
+	dc_gamma_retain(&gamma->protected.public);
+
+	return &gamma->protected.public;
+
+construct_fail:
+	dm_free(gamma);
+
+alloc_fail:
+	return NULL;
+}
+
