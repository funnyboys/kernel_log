commit be73e608ae2711dc8a1ab8b9549d9e348061b2ee
Author: Josip Pavic <Josip.Pavic@amd.com>
Date:   Mon Jul 6 15:43:39 2020 -0400

    drm/amd/display: handle failed allocation during stream construction
    
    [Why]
    Failing to allocate a transfer function during stream construction leads
    to a null pointer dereference
    
    [How]
    Handle the failed allocation by failing the stream construction
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Josip Pavic <Josip.Pavic@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 4f0e7203dba4..470c82794f6f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -56,7 +56,7 @@ void update_stream_signal(struct dc_stream_state *stream, struct dc_sink *sink)
 	}
 }
 
-static void dc_stream_construct(struct dc_stream_state *stream,
+static bool dc_stream_construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
@@ -118,11 +118,17 @@ static void dc_stream_construct(struct dc_stream_state *stream,
 	update_stream_signal(stream, dc_sink_data);
 
 	stream->out_transfer_func = dc_create_transfer_func();
+	if (stream->out_transfer_func == NULL) {
+		dc_sink_release(dc_sink_data);
+		return false;
+	}
 	stream->out_transfer_func->type = TF_TYPE_BYPASS;
 	stream->out_transfer_func->ctx = stream->ctx;
 
 	stream->stream_id = stream->ctx->dc_stream_id_count;
 	stream->ctx->dc_stream_id_count++;
+
+	return true;
 }
 
 static void dc_stream_destruct(struct dc_stream_state *stream)
@@ -164,13 +170,20 @@ struct dc_stream_state *dc_create_stream_for_sink(
 
 	stream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);
 	if (stream == NULL)
-		return NULL;
+		goto alloc_fail;
 
-	dc_stream_construct(stream, sink);
+	if (dc_stream_construct(stream, sink) == false)
+		goto construct_fail;
 
 	kref_init(&stream->refcount);
 
 	return stream;
+
+construct_fail:
+	kfree(stream);
+
+alloc_fail:
+	return NULL;
 }
 
 struct dc_stream_state *dc_copy_stream(const struct dc_stream_state *stream)

commit b2a7b0ce0773bfa4406bc0a78e41979532a1edd7
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Wed Apr 22 18:08:03 2020 -0400

    drm/amd/display: Use cursor locking to prevent flip delays
    
    [Why]
    Current locking scheme for cursor can result in a flip missing
    its vsync, deferring it for one or more vsyncs.  Result is a
    potential for stuttering when cursor is moved.
    
    [How]
    Use cursor update lock so that flips are not blocked while cursor
    is being programmed.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 8c20e9e907b2..4f0e7203dba4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -231,34 +231,6 @@ struct dc_stream_status *dc_stream_get_status(
 	return dc_stream_get_status_from_state(dc->current_state, stream);
 }
 
-static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
-{
-#if defined(CONFIG_DRM_AMD_DC_DCN)
-	unsigned int vupdate_line;
-	unsigned int lines_to_vupdate, us_to_vupdate, vpos, nvpos;
-	struct dc_stream_state *stream = pipe_ctx->stream;
-	unsigned int us_per_line;
-
-	if (!dc->hwss.get_vupdate_offset_from_vsync)
-		return;
-
-	vupdate_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);
-	if (!dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos))
-		return;
-
-	if (vpos >= vupdate_line)
-		return;
-
-	us_per_line =
-		stream->timing.h_total * 10000 / stream->timing.pix_clk_100hz;
-	lines_to_vupdate = vupdate_line - vpos;
-	us_to_vupdate = lines_to_vupdate * us_per_line;
-
-	/* 70 us is a conservative estimate of cursor update time*/
-	if (us_to_vupdate < 70)
-		udelay(us_to_vupdate);
-#endif
-}
 
 /**
  * dc_stream_set_cursor_attributes() - Update cursor attributes and set cursor surface address
@@ -298,9 +270,7 @@ bool dc_stream_set_cursor_attributes(
 
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;
-
-			delay_cursor_until_vupdate(pipe_ctx, dc);
-			dc->hwss.pipe_control_lock(dc, pipe_to_program, true);
+			dc->hwss.cursor_lock(dc, pipe_to_program, true);
 		}
 
 		dc->hwss.set_cursor_attribute(pipe_ctx);
@@ -309,7 +279,7 @@ bool dc_stream_set_cursor_attributes(
 	}
 
 	if (pipe_to_program)
-		dc->hwss.pipe_control_lock(dc, pipe_to_program, false);
+		dc->hwss.cursor_lock(dc, pipe_to_program, false);
 
 	return true;
 }
@@ -349,16 +319,14 @@ bool dc_stream_set_cursor_position(
 
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;
-
-			delay_cursor_until_vupdate(pipe_ctx, dc);
-			dc->hwss.pipe_control_lock(dc, pipe_to_program, true);
+			dc->hwss.cursor_lock(dc, pipe_to_program, true);
 		}
 
 		dc->hwss.set_cursor_position(pipe_ctx);
 	}
 
 	if (pipe_to_program)
-		dc->hwss.pipe_control_lock(dc, pipe_to_program, false);
+		dc->hwss.cursor_lock(dc, pipe_to_program, false);
 
 	return true;
 }

commit fdfd2a858590d318cfee483bd1c73e00f77533af
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Wed Apr 22 18:07:56 2020 -0400

    drm/amd/display: Defer cursor update around VUPDATE for all ASIC
    
    [Why]
    Fixes the following scenario:
    
    - Flip has been prepared sometime during the frame, update pending
    - Cursor update happens right when VUPDATE would happen
    - OPTC lock acquired, VUPDATE is blocked until next frame
    - Flip is delayed potentially infinitely
    
    With the igt@kms_cursor_legacy cursor-vs-flip-legacy test we can
    observe nearly *13* frames of delay for some flips on Navi.
    
    [How]
    Apply the Raven workaround generically. When close enough to VUPDATE
    block cursor updates from occurring from the dc_stream_set_cursor_*
    helpers.
    
    This could perhaps be a little smarter by checking if there were
    pending updates or flips earlier in the frame on the HUBP side before
    applying the delay, but this should be fine for now.
    
    This fixes the kms_cursor_legacy test.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 6ddbb00ed37a..8c20e9e907b2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -239,24 +239,24 @@ static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	unsigned int us_per_line;
 
-	if (stream->ctx->asic_id.chip_family == FAMILY_RV &&
-			ASICREV_IS_RAVEN(stream->ctx->asic_id.hw_internal_rev)) {
+	if (!dc->hwss.get_vupdate_offset_from_vsync)
+		return;
 
-		vupdate_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);
-		if (!dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos))
-			return;
+	vupdate_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);
+	if (!dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos))
+		return;
 
-		if (vpos >= vupdate_line)
-			return;
+	if (vpos >= vupdate_line)
+		return;
 
-		us_per_line = stream->timing.h_total * 10000 / stream->timing.pix_clk_100hz;
-		lines_to_vupdate = vupdate_line - vpos;
-		us_to_vupdate = lines_to_vupdate * us_per_line;
+	us_per_line =
+		stream->timing.h_total * 10000 / stream->timing.pix_clk_100hz;
+	lines_to_vupdate = vupdate_line - vpos;
+	us_to_vupdate = lines_to_vupdate * us_per_line;
 
-		/* 70 us is a conservative estimate of cursor update time*/
-		if (us_to_vupdate < 70)
-			udelay(us_to_vupdate);
-	}
+	/* 70 us is a conservative estimate of cursor update time*/
+	if (us_to_vupdate < 70)
+		udelay(us_to_vupdate);
 #endif
 }
 

commit 6a652f6d127dac1c67c413c3309258c874535dd1
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Nov 20 21:23:47 2019 -0500

    drm/amd/display: Add warmup escape call support
    
    Add warmup escape support, for diags, in a way that is possible to
    choose a new or an existing sequence. For achieving this goal, this
    commit adds separated MCIF buffer as VCN request.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index b43a4b115fd8..6ddbb00ed37a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -406,25 +406,30 @@ bool dc_stream_add_writeback(struct dc *dc,
 		stream->writeback_info[stream->num_wb_info++] = *wb_info;
 	}
 
-	if (!dc->hwss.update_bandwidth(dc, dc->current_state)) {
-		dm_error("DC: update_bandwidth failed!\n");
-		return false;
-	}
-
-	/* enable writeback */
 	if (dc->hwss.enable_writeback) {
 		struct dc_stream_status *stream_status = dc_stream_get_status(stream);
 		struct dwbc *dwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];
+		dwb->otg_inst = stream_status->primary_otg_inst;
+	}
+	if (IS_DIAG_DC(dc->ctx->dce_environment)) {
+		if (!dc->hwss.update_bandwidth(dc, dc->current_state)) {
+			dm_error("DC: update_bandwidth failed!\n");
+			return false;
+		}
 
-		if (dwb->funcs->is_enabled(dwb)) {
-			/* writeback pipe already enabled, only need to update */
-			dc->hwss.update_writeback(dc, stream_status, wb_info, dc->current_state);
-		} else {
-			/* Enable writeback pipe from scratch*/
-			dc->hwss.enable_writeback(dc, stream_status, wb_info, dc->current_state);
+		/* enable writeback */
+		if (dc->hwss.enable_writeback) {
+			struct dwbc *dwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];
+
+			if (dwb->funcs->is_enabled(dwb)) {
+				/* writeback pipe already enabled, only need to update */
+				dc->hwss.update_writeback(dc, wb_info, dc->current_state);
+			} else {
+				/* Enable writeback pipe from scratch*/
+				dc->hwss.enable_writeback(dc, wb_info, dc->current_state);
+			}
 		}
 	}
-
 	return true;
 }
 
@@ -463,19 +468,29 @@ bool dc_stream_remove_writeback(struct dc *dc,
 	}
 	stream->num_wb_info = j;
 
-	/* recalculate and apply DML parameters */
-	if (!dc->hwss.update_bandwidth(dc, dc->current_state)) {
-		dm_error("DC: update_bandwidth failed!\n");
-		return false;
-	}
-
-	/* disable writeback */
-	if (dc->hwss.disable_writeback)
-		dc->hwss.disable_writeback(dc, dwb_pipe_inst);
+	if (IS_DIAG_DC(dc->ctx->dce_environment)) {
+		/* recalculate and apply DML parameters */
+		if (!dc->hwss.update_bandwidth(dc, dc->current_state)) {
+			dm_error("DC: update_bandwidth failed!\n");
+			return false;
+		}
 
+		/* disable writeback */
+		if (dc->hwss.disable_writeback)
+			dc->hwss.disable_writeback(dc, dwb_pipe_inst);
+	}
 	return true;
 }
 
+bool dc_stream_warmup_writeback(struct dc *dc,
+		int num_dwb,
+		struct dc_writeback_info *wb_info)
+{
+	if (dc->hwss.mmhubbub_warmup)
+		return dc->hwss.mmhubbub_warmup(dc, num_dwb, wb_info);
+	else
+		return false;
+}
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;

commit f42ea55be1114768e36c4e8dff4400ca811309cf
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:17:30 2019 -0500

    drm/amd/display: add separate of private hwss functions
    
    [Why]
    Some function pointers in the hwss function pointer table are
    meant to be hw sequencer entry points to be called from dc.
    
    However some of those function pointers are not meant to
    be entry points, but instead used as a code reuse/inheritance
    tool called directly by other hwss functions, not by dc.
    
    Therefore, we want a more clear separation of which functions
    we determine to be interface functions vs the functions we
    use within hwss.
    
    [How]
    DC interface functions will be stored in:
        struct hw_sequencer_funcs
    Functions used within HWSS will be stored in:
        struct hwseq_private_funcs
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 70b7c1eb8a8f..b43a4b115fd8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -33,9 +33,6 @@
 #include "resource.h"
 #include "ipp.h"
 #include "timing_generator.h"
-#if defined(CONFIG_DRM_AMD_DC_DCN)
-#include "dcn10/dcn10_hw_sequencer.h"
-#endif
 
 #define DC_LOGGER dc->ctx->logger
 

commit 2b77dcc5e5aa382832af93a581de8293db72d888
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:04:34 2019 -0500

    drm/amd/display: rename core_dc to dc
    
    [Why]
    First, to make code more consistent
    Second, to get rid of those scenario where we create a second
    local pointer to dc when it's already passed in.
    
    [How]
    Rename core_dc to dc
    Remove duplicate local pointers to dc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index d9afd834c146..70b7c1eb8a8f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -271,7 +271,7 @@ bool dc_stream_set_cursor_attributes(
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
-	struct dc  *core_dc;
+	struct dc  *dc;
 	struct resource_context *res_ctx;
 	struct pipe_ctx *pipe_to_program = NULL;
 
@@ -289,8 +289,8 @@ bool dc_stream_set_cursor_attributes(
 		return false;
 	}
 
-	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_state->res_ctx;
+	dc = stream->ctx->dc;
+	res_ctx = &dc->current_state->res_ctx;
 	stream->cursor_attributes = *attributes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -302,17 +302,17 @@ bool dc_stream_set_cursor_attributes(
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;
 
-			delay_cursor_until_vupdate(pipe_ctx, core_dc);
-			core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, true);
+			delay_cursor_until_vupdate(pipe_ctx, dc);
+			dc->hwss.pipe_control_lock(dc, pipe_to_program, true);
 		}
 
-		core_dc->hwss.set_cursor_attribute(pipe_ctx);
-		if (core_dc->hwss.set_cursor_sdr_white_level)
-			core_dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
+		dc->hwss.set_cursor_attribute(pipe_ctx);
+		if (dc->hwss.set_cursor_sdr_white_level)
+			dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
 	}
 
 	if (pipe_to_program)
-		core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, false);
+		dc->hwss.pipe_control_lock(dc, pipe_to_program, false);
 
 	return true;
 }
@@ -322,7 +322,7 @@ bool dc_stream_set_cursor_position(
 	const struct dc_cursor_position *position)
 {
 	int i;
-	struct dc  *core_dc;
+	struct dc  *dc;
 	struct resource_context *res_ctx;
 	struct pipe_ctx *pipe_to_program = NULL;
 
@@ -336,8 +336,8 @@ bool dc_stream_set_cursor_position(
 		return false;
 	}
 
-	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_state->res_ctx;
+	dc = stream->ctx->dc;
+	res_ctx = &dc->current_state->res_ctx;
 	stream->cursor_position = *position;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -353,15 +353,15 @@ bool dc_stream_set_cursor_position(
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;
 
-			delay_cursor_until_vupdate(pipe_ctx, core_dc);
-			core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, true);
+			delay_cursor_until_vupdate(pipe_ctx, dc);
+			dc->hwss.pipe_control_lock(dc, pipe_to_program, true);
 		}
 
-		core_dc->hwss.set_cursor_position(pipe_ctx);
+		dc->hwss.set_cursor_position(pipe_ctx);
 	}
 
 	if (pipe_to_program)
-		core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, false);
+		dc->hwss.pipe_control_lock(dc, pipe_to_program, false);
 
 	return true;
 }
@@ -482,9 +482,9 @@ bool dc_stream_remove_writeback(struct dc *dc,
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;
-	struct dc  *core_dc = stream->ctx->dc;
+	struct dc  *dc = stream->ctx->dc;
 	struct resource_context *res_ctx =
-		&core_dc->current_state->res_ctx;
+		&dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;
@@ -541,9 +541,9 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 {
 	uint8_t i;
 	bool ret = false;
-	struct dc  *core_dc = stream->ctx->dc;
+	struct dc  *dc = stream->ctx->dc;
 	struct resource_context *res_ctx =
-		&core_dc->current_state->res_ctx;
+		&dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;

commit 78c7738211e027f122ada3f59c2c5e8a83ee3c59
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Oct 29 15:05:56 2019 -0400

    drm/amd/display: cleanup of function pointer tables
    
    [Why]
    It is becoming increasingly hard to figure out which
    function is called on the different DCN versions
    
    [How]
    1. Make function pointer table init in its own init.c file
    2. Remove other scenarios in hwseq.c file that need to
    include headers of other DCN versions. (If needed,
    it should have been done via the function pointers)
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 8d4ffc683204..d9afd834c146 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -27,6 +27,7 @@
 #include <linux/slab.h>
 
 #include "dm_services.h"
+#include "basics/dc_common.h"
 #include "dc.h"
 #include "core_types.h"
 #include "resource.h"
@@ -244,7 +245,7 @@ static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 	if (stream->ctx->asic_id.chip_family == FAMILY_RV &&
 			ASICREV_IS_RAVEN(stream->ctx->asic_id.hw_internal_rev)) {
 
-		vupdate_line = get_vupdate_offset_from_vsync(pipe_ctx);
+		vupdate_line = dc->hwss.get_vupdate_offset_from_vsync(pipe_ctx);
 		if (!dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos))
 			return;
 

commit d9e32672a1285d6c5e06bedaabb465441c172aa8
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Oct 31 21:39:39 2019 -0400

    drm/amd/display: cleanup of construct and destruct funcs
    
    [Why]
    Too many construct functions which makes searching
    difficult, especially on some debuggers.
    
    [How]
    Append all construct and destruct functions with dcn
    number and object type to make each construct function
    name unique
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 88a84bfaea6f..8d4ffc683204 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -58,7 +58,7 @@ void update_stream_signal(struct dc_stream_state *stream, struct dc_sink *sink)
 	}
 }
 
-static void construct(struct dc_stream_state *stream,
+static void dc_stream_construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
@@ -127,7 +127,7 @@ static void construct(struct dc_stream_state *stream,
 	stream->ctx->dc_stream_id_count++;
 }
 
-static void destruct(struct dc_stream_state *stream)
+static void dc_stream_destruct(struct dc_stream_state *stream)
 {
 	dc_sink_release(stream->sink);
 	if (stream->out_transfer_func != NULL) {
@@ -145,7 +145,7 @@ static void dc_stream_free(struct kref *kref)
 {
 	struct dc_stream_state *stream = container_of(kref, struct dc_stream_state, refcount);
 
-	destruct(stream);
+	dc_stream_destruct(stream);
 	kfree(stream);
 }
 
@@ -168,7 +168,7 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	if (stream == NULL)
 		return NULL;
 
-	construct(stream, sink);
+	dc_stream_construct(stream, sink);
 
 	kref_init(&stream->refcount);
 

commit b74361974bfa242b5010ec6b83c7e275c190a247
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Nov 8 16:29:45 2019 +0000

    drm/amd/display: remove redundant variable status
    
    Variable status is redundant, it is being initialized with a value
    that is over-written later and this is being returned immediately
    after the assignment.  Clean up the code by removing status and
    just returning the value returned from the call to function
    dc->hwss.dmdata_status_done.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 371d49e9b745..88a84bfaea6f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -565,7 +565,6 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 
 bool dc_stream_dmdata_status_done(struct dc *dc, struct dc_stream_state *stream)
 {
-	bool status = true;
 	struct pipe_ctx *pipe = NULL;
 	int i;
 
@@ -581,8 +580,7 @@ bool dc_stream_dmdata_status_done(struct dc *dc, struct dc_stream_state *stream)
 	if (i == MAX_PIPES)
 		return true;
 
-	status = dc->hwss.dmdata_status_done(pipe);
-	return status;
+	return dc->hwss.dmdata_status_done(pipe);
 }
 
 bool dc_stream_set_dynamic_metadata(struct dc *dc,

commit b86a1aa36a92bcfbc062c5e99c1d084f27f25bab
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:48:35 2019 -0500

    drm/amd/display: rename DCN1_0 kconfig to DCN
    
    Since dcn20 and dcn21 are under dcn1 it doesnt make sense to
    have it named dcn1.
    
    Change it to "dcn" to make it generic
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index dc05c14530b0..371d49e9b745 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -32,7 +32,7 @@
 #include "resource.h"
 #include "ipp.h"
 #include "timing_generator.h"
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 #include "dcn10/dcn10_hw_sequencer.h"
 #endif
 
@@ -235,7 +235,7 @@ struct dc_stream_status *dc_stream_get_status(
 
 static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 {
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 	unsigned int vupdate_line;
 	unsigned int lines_to_vupdate, us_to_vupdate, vpos, nvpos;
 	struct dc_stream_state *stream = pipe_ctx->stream;

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index bb09243758fe..dc05c14530b0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -108,7 +108,6 @@ static void construct(struct dc_stream_state *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 	memset(&stream->timing.dsc_cfg, 0, sizeof(stream->timing.dsc_cfg));
 	stream->timing.dsc_cfg.num_slices_h = 0;
 	stream->timing.dsc_cfg.num_slices_v = 0;
@@ -117,7 +116,6 @@ static void construct(struct dc_stream_state *stream,
 	stream->timing.dsc_cfg.linebuf_depth = 9;
 	stream->timing.dsc_cfg.version_minor = 2;
 	stream->timing.dsc_cfg.ycbcr422_simple = 0;
-#endif
 
 	update_stream_signal(stream, dc_sink_data);
 
@@ -367,7 +365,6 @@ bool dc_stream_set_cursor_position(
 	return true;
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 bool dc_stream_add_writeback(struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_writeback_info *wb_info)
@@ -480,7 +477,6 @@ bool dc_stream_remove_writeback(struct dc *dc,
 
 	return true;
 }
-#endif
 
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
@@ -567,7 +563,6 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 	return ret;
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 bool dc_stream_dmdata_status_done(struct dc *dc, struct dc_stream_state *stream)
 {
 	bool status = true;
@@ -630,7 +625,6 @@ bool dc_stream_set_dynamic_metadata(struct dc *dc,
 
 	return true;
 }
-#endif
 
 void dc_stream_log(const struct dc *dc, const struct dc_stream_state *stream)
 {

commit edb922b022c0c94805c4ffad202b3edff83d76f0
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Thu Aug 29 17:06:05 2019 -0400

    drm/amd/display: Program DWB watermarks from correct state
    
    [Why]
    When diags adds a DWB via a stream update, we calculate MMHUBBUB
    paramaters, but dc->current_state has not yet been updated
    when the DWB programming happens. This leads to overflow on
    high bandwidth tests since the incorrect MMHUBBUB arbitration
    parameters are programmed.
    
    [How]
    Pass the updated context down to the (enable|update)_writeback functions
    so that they can use the correct watermarks when programming MMHUBBUB.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index bf1d7bb90e0f..bb09243758fe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -423,10 +423,10 @@ bool dc_stream_add_writeback(struct dc *dc,
 
 		if (dwb->funcs->is_enabled(dwb)) {
 			/* writeback pipe already enabled, only need to update */
-			dc->hwss.update_writeback(dc, stream_status, wb_info);
+			dc->hwss.update_writeback(dc, stream_status, wb_info, dc->current_state);
 		} else {
 			/* Enable writeback pipe from scratch*/
-			dc->hwss.enable_writeback(dc, stream_status, wb_info);
+			dc->hwss.enable_writeback(dc, stream_status, wb_info, dc->current_state);
 		}
 	}
 

commit f591344e89dca887afeb5bbe21fa199687fd4a5f
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Wed Jul 3 13:59:26 2019 -0400

    drm/amd/display: Clean up dynamic metadata logic
    
     [Why]
    Code to enable DCN20 dynamic metadata feature is duplicated in two places
    and was added to DCE110 enable stream.
    
    [How]
    Create DCN20 specific enable stream function for clarity, and add a hardware
    sequencer function to program dynamic metadata to avoid the duplicate
    code.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 352862370390..bf1d7bb90e0f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -566,6 +566,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 
 	return ret;
 }
+
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 bool dc_stream_dmdata_status_done(struct dc *dc, struct dc_stream_state *stream)
 {
@@ -597,6 +598,14 @@ bool dc_stream_set_dynamic_metadata(struct dc *dc,
 	struct hubp *hubp;
 	int i;
 
+	/* Dynamic metadata is only supported on HDMI or DP */
+	if (!dc_is_hdmi_signal(stream->signal) && !dc_is_dp_signal(stream->signal))
+		return false;
+
+	/* Check hardware support */
+	if (!dc->hwss.program_dmdata_engine)
+		return false;
+
 	for (i = 0; i < MAX_PIPES; i++) {
 		pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
 		if (pipe_ctx->stream == stream)
@@ -612,23 +621,7 @@ bool dc_stream_set_dynamic_metadata(struct dc *dc,
 
 	pipe_ctx->stream->dmdata_address = attr->address;
 
-	if (pipe_ctx->stream_res.stream_enc &&
-			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata != NULL) {
-		if (pipe_ctx->stream->dmdata_address.quad_part != 0) {
-			/* if using dynamic meta, don't set up generic infopackets */
-			pipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;
-			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
-					pipe_ctx->stream_res.stream_enc,
-					true, pipe_ctx->plane_res.hubp->inst,
-					dc_is_dp_signal(pipe_ctx->stream->signal) ?
-							dmdata_dp : dmdata_hdmi);
-		} else
-			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
-					pipe_ctx->stream_res.stream_enc,
-					false, pipe_ctx->plane_res.hubp->inst,
-					dc_is_dp_signal(pipe_ctx->stream->signal) ?
-							dmdata_dp : dmdata_hdmi);
-	}
+	dc->hwss.program_dmdata_engine(pipe_ctx);
 
 	if (hubp->funcs->dmdata_set_attributes != NULL &&
 			pipe_ctx->stream->dmdata_address.quad_part != 0) {

commit 24f1d1cee2bc9cb591145e21823d7865208a7991
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Wed May 29 18:52:17 2019 -0400

    drm/amd/display: Check for valid stream_encode
    
    Before accessing it's vtable, check that stream_encoder is non-null.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index af7f8be230f7..352862370390 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -612,7 +612,8 @@ bool dc_stream_set_dynamic_metadata(struct dc *dc,
 
 	pipe_ctx->stream->dmdata_address = attr->address;
 
-	if (pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata != NULL) {
+	if (pipe_ctx->stream_res.stream_enc &&
+			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata != NULL) {
 		if (pipe_ctx->stream->dmdata_address.quad_part != 0) {
 			/* if using dynamic meta, don't set up generic infopackets */
 			pipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;

commit d12c202289b07037da285299b4122fa2072eca96
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Thu Jul 4 00:27:18 2019 +0800

    drm/amdgpu: Use kmemdup rather than duplicating its implementation
    
    kmemdup is introduced to duplicate a region of memory in a neat way.
    Rather than kmalloc/kzalloc + memcpy, which the programmer needs to
    write the size twice (sometimes lead to mistakes), kmemdup improves
    readability, leads to smaller code and also reduce the chances of mistakes.
    Suggestion to use kmemdup rather than using kmalloc/kzalloc + memcpy.
    
    Reviewed-by: Christian König <Christian.Koenig@amd.com>
    Reviewed-by: Emil Velikov <emil.velikov@collabora.com>
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a7c769a1b40b..af7f8be230f7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -181,12 +181,10 @@ struct dc_stream_state *dc_copy_stream(const struct dc_stream_state *stream)
 {
 	struct dc_stream_state *new_stream;
 
-	new_stream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);
+	new_stream = kmemdup(stream, sizeof(struct dc_stream_state), GFP_KERNEL);
 	if (!new_stream)
 		return NULL;
 
-	memcpy(new_stream, stream, sizeof(struct dc_stream_state));
-
 	if (new_stream->sink)
 		dc_sink_retain(new_stream->sink);
 

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit c3ec8ba5377994251e83893aa8820f771ff4aabf
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed May 8 13:29:09 2019 -0400

    drm/amd/display: Return UPDATE_TYPE_FULL on writeback update
    
    Should do full update when display writeback is updated.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Duke Du <Duke.Du@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3787398f6d80..30a25e694da0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -373,6 +373,7 @@ bool dc_stream_add_writeback(struct dc *dc,
 {
 	bool isDrc = false;
 	int i = 0;
+	struct dwbc *dwb;
 
 	if (stream == NULL) {
 		dm_error("DC: dc_stream is NULL!\n");
@@ -391,7 +392,8 @@ bool dc_stream_add_writeback(struct dc *dc,
 
 	wb_info->dwb_params.out_transfer_func = stream->out_transfer_func;
 
-
+	dwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];
+	dwb->dwb_is_drc = false;
 
 	/* recalculate and apply DML parameters */
 

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index de50d778e4b0..3787398f6d80 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -105,6 +105,16 @@ static void construct(struct dc_stream_state *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+	memset(&stream->timing.dsc_cfg, 0, sizeof(stream->timing.dsc_cfg));
+	stream->timing.dsc_cfg.num_slices_h = 0;
+	stream->timing.dsc_cfg.num_slices_v = 0;
+	stream->timing.dsc_cfg.bits_per_pixel = 128;
+	stream->timing.dsc_cfg.block_pred_enable = 1;
+	stream->timing.dsc_cfg.linebuf_depth = 9;
+	stream->timing.dsc_cfg.version_minor = 2;
+	stream->timing.dsc_cfg.ycbcr422_simple = 0;
+#endif
 
 	update_stream_signal(stream, dc_sink_data);
 

commit 6fbefb84a98ecc43cb4035c44fe417e6751ddd83
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:34 2019 -0500

    drm/amd/display: Add DC core changes for DCN2
    
    Core DC changes for DCN2.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a002e690814f..de50d778e4b0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -105,6 +105,7 @@ static void construct(struct dc_stream_state *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
+
 	update_stream_signal(stream, dc_sink_data);
 
 	stream->out_transfer_func = dc_create_transfer_func();
@@ -355,6 +356,119 @@ bool dc_stream_set_cursor_position(
 	return true;
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+bool dc_stream_add_writeback(struct dc *dc,
+		struct dc_stream_state *stream,
+		struct dc_writeback_info *wb_info)
+{
+	bool isDrc = false;
+	int i = 0;
+
+	if (stream == NULL) {
+		dm_error("DC: dc_stream is NULL!\n");
+		return false;
+	}
+
+	if (wb_info == NULL) {
+		dm_error("DC: dc_writeback_info is NULL!\n");
+		return false;
+	}
+
+	if (wb_info->dwb_pipe_inst >= MAX_DWB_PIPES) {
+		dm_error("DC: writeback pipe is invalid!\n");
+		return false;
+	}
+
+	wb_info->dwb_params.out_transfer_func = stream->out_transfer_func;
+
+
+
+	/* recalculate and apply DML parameters */
+
+	for (i = 0; i < stream->num_wb_info; i++) {
+		/*dynamic update*/
+		if (stream->writeback_info[i].wb_enabled &&
+			stream->writeback_info[i].dwb_pipe_inst == wb_info->dwb_pipe_inst) {
+			stream->writeback_info[i] = *wb_info;
+			isDrc = true;
+		}
+	}
+
+	if (!isDrc) {
+		stream->writeback_info[stream->num_wb_info++] = *wb_info;
+	}
+
+	if (!dc->hwss.update_bandwidth(dc, dc->current_state)) {
+		dm_error("DC: update_bandwidth failed!\n");
+		return false;
+	}
+
+	/* enable writeback */
+	if (dc->hwss.enable_writeback) {
+		struct dc_stream_status *stream_status = dc_stream_get_status(stream);
+		struct dwbc *dwb = dc->res_pool->dwbc[wb_info->dwb_pipe_inst];
+
+		if (dwb->funcs->is_enabled(dwb)) {
+			/* writeback pipe already enabled, only need to update */
+			dc->hwss.update_writeback(dc, stream_status, wb_info);
+		} else {
+			/* Enable writeback pipe from scratch*/
+			dc->hwss.enable_writeback(dc, stream_status, wb_info);
+		}
+	}
+
+	return true;
+}
+
+bool dc_stream_remove_writeback(struct dc *dc,
+		struct dc_stream_state *stream,
+		uint32_t dwb_pipe_inst)
+{
+	int i = 0, j = 0;
+	if (stream == NULL) {
+		dm_error("DC: dc_stream is NULL!\n");
+		return false;
+	}
+
+	if (dwb_pipe_inst >= MAX_DWB_PIPES) {
+		dm_error("DC: writeback pipe is invalid!\n");
+		return false;
+	}
+
+//	stream->writeback_info[dwb_pipe_inst].wb_enabled = false;
+	for (i = 0; i < stream->num_wb_info; i++) {
+		/*dynamic update*/
+		if (stream->writeback_info[i].wb_enabled &&
+			stream->writeback_info[i].dwb_pipe_inst == dwb_pipe_inst) {
+			stream->writeback_info[i].wb_enabled = false;
+		}
+	}
+
+	/* remove writeback info for disabled writeback pipes from stream */
+	for (i = 0, j = 0; i < stream->num_wb_info; i++) {
+		if (stream->writeback_info[i].wb_enabled) {
+			if (i != j)
+				/* trim the array */
+				stream->writeback_info[j] = stream->writeback_info[i];
+			j++;
+		}
+	}
+	stream->num_wb_info = j;
+
+	/* recalculate and apply DML parameters */
+	if (!dc->hwss.update_bandwidth(dc, dc->current_state)) {
+		dm_error("DC: update_bandwidth failed!\n");
+		return false;
+	}
+
+	/* disable writeback */
+	if (dc->hwss.disable_writeback)
+		dc->hwss.disable_writeback(dc, dwb_pipe_inst);
+
+	return true;
+}
+#endif
+
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;
@@ -439,6 +553,77 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 
 	return ret;
 }
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+bool dc_stream_dmdata_status_done(struct dc *dc, struct dc_stream_state *stream)
+{
+	bool status = true;
+	struct pipe_ctx *pipe = NULL;
+	int i;
+
+	if (!dc->hwss.dmdata_status_done)
+		return false;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe = &dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe->stream == stream)
+			break;
+	}
+	/* Stream not found, by default we'll assume HUBP fetched dm data */
+	if (i == MAX_PIPES)
+		return true;
+
+	status = dc->hwss.dmdata_status_done(pipe);
+	return status;
+}
+
+bool dc_stream_set_dynamic_metadata(struct dc *dc,
+		struct dc_stream_state *stream,
+		struct dc_dmdata_attributes *attr)
+{
+	struct pipe_ctx *pipe_ctx = NULL;
+	struct hubp *hubp;
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		pipe_ctx = &dc->current_state->res_ctx.pipe_ctx[i];
+		if (pipe_ctx->stream == stream)
+			break;
+	}
+
+	if (i == MAX_PIPES)
+		return false;
+
+	hubp = pipe_ctx->plane_res.hubp;
+	if (hubp == NULL)
+		return false;
+
+	pipe_ctx->stream->dmdata_address = attr->address;
+
+	if (pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata != NULL) {
+		if (pipe_ctx->stream->dmdata_address.quad_part != 0) {
+			/* if using dynamic meta, don't set up generic infopackets */
+			pipe_ctx->stream_res.encoder_info_frame.hdrsmd.valid = false;
+			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
+					pipe_ctx->stream_res.stream_enc,
+					true, pipe_ctx->plane_res.hubp->inst,
+					dc_is_dp_signal(pipe_ctx->stream->signal) ?
+							dmdata_dp : dmdata_hdmi);
+		} else
+			pipe_ctx->stream_res.stream_enc->funcs->set_dynamic_metadata(
+					pipe_ctx->stream_res.stream_enc,
+					false, pipe_ctx->plane_res.hubp->inst,
+					dc_is_dp_signal(pipe_ctx->stream->signal) ?
+							dmdata_dp : dmdata_hdmi);
+	}
+
+	if (hubp->funcs->dmdata_set_attributes != NULL &&
+			pipe_ctx->stream->dmdata_address.quad_part != 0) {
+		hubp->funcs->dmdata_set_attributes(hubp, attr);
+	}
+
+	return true;
+}
+#endif
 
 void dc_stream_log(const struct dc *dc, const struct dc_stream_state *stream)
 {

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 1dc3492f02a1..7a46cc4414d2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -24,6 +24,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/slab.h>
 
 #include "dm_services.h"
 #include "dc.h"

commit c366be543c5ea35f4d4103f5ee69f052ce2bffe1
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:49 2019 +0200

    drm/amd: drop dependencies on drm_os_linux.h
    
    Fix so no files in drm/amd/ depends on the
    deprecated drm_os_linux.h header file.
    
    It was done manually:
    - remove drm_os_linux.h from drmP.h
    - fix all build errros
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-3-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 96e97d25d639..1dc3492f02a1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/delay.h>
+
 #include "dm_services.h"
 #include "dc.h"
 #include "core_types.h"

commit b1432fcbdbea5de6e4ec2e1b2fa2b3c13ade4785
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue May 7 15:18:44 2019 -0400

    drm/amd/display: assign new stream id in dc_copy_stream
    
    [why]
    stream id should uniquely identify an instance of stream.
    the copy constructor should be treated as a new
    stream instance.
    
    [how]
    assign a new stream id in this copy constructor.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 59b247af5b81..a002e690814f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -179,6 +179,9 @@ struct dc_stream_state *dc_copy_stream(const struct dc_stream_state *stream)
 	if (new_stream->out_transfer_func)
 		dc_transfer_func_retain(new_stream->out_transfer_func);
 
+	new_stream->stream_id = new_stream->ctx->dc_stream_id_count;
+	new_stream->ctx->dc_stream_id_count++;
+
 	kref_init(&new_stream->refcount);
 
 	return new_stream;

commit dc88b4a684d284a200c0ecfd8d87179d6f6c89a3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Apr 22 19:39:35 2019 -0400

    drm/amd/display: make clk mgr soc specific
    
    [Why]
    First step of refactoring clk mgr to better handle different
    ways of handling clock operations. Clock operation policies are
    soc specific and not just DCN vesion specific. It is not a hw resource,
    should not be in the resource pool.
    
    [How]
    Change clock manager creation to be based on HW internal ID, rename
    clock manager members to be more clear. Move clock manager out of
    resource.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index b723ffc8ea25..59b247af5b81 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -229,7 +229,7 @@ static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 	unsigned int us_per_line;
 
 	if (stream->ctx->asic_id.chip_family == FAMILY_RV &&
-			ASIC_REV_IS_RAVEN(stream->ctx->asic_id.hw_internal_rev)) {
+			ASICREV_IS_RAVEN(stream->ctx->asic_id.hw_internal_rev)) {
 
 		vupdate_line = get_vupdate_offset_from_vsync(pipe_ctx);
 		if (!dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos))

commit 88ccdf1d59df4d93b0591c8879316de40ef88f93
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Tue Apr 16 11:07:22 2019 -0400

    drm/amd/display: Expose send immediate sdp message interface
    
    [Why]
    To send sdp message immediately from a single slot.
    
    [How]
    Modify the generic SDP message interface, and use GSP4 to send immediate
    sdp message.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a79f608b2f79..b723ffc8ea25 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -371,42 +371,12 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 	return 0;
 }
 
-static void build_dp_sdp_info_frame(struct pipe_ctx *pipe_ctx,
-		const uint8_t  *custom_sdp_message,
-		unsigned int sdp_message_size)
-{
-	uint8_t i;
-	struct encoder_info_frame *info = &pipe_ctx->stream_res.encoder_info_frame;
-
-	/* set valid info */
-	info->dpsdp.valid = true;
-
-	/* set sdp message header */
-	info->dpsdp.hb0 = custom_sdp_message[0]; /* package id */
-	info->dpsdp.hb1 = custom_sdp_message[1]; /* package type */
-	info->dpsdp.hb2 = custom_sdp_message[2]; /* package specific byte 0 any data */
-	info->dpsdp.hb3 = custom_sdp_message[3]; /* package specific byte 0 any data */
-
-	/* set sdp message data */
-	for (i = 0; i < 32; i++)
-		info->dpsdp.sb[i] = (custom_sdp_message[i+4]);
-
-}
-
-static void invalid_dp_sdp_info_frame(struct pipe_ctx *pipe_ctx)
-{
-	struct encoder_info_frame *info = &pipe_ctx->stream_res.encoder_info_frame;
-
-	/* in-valid info */
-	info->dpsdp.valid = false;
-}
-
 bool dc_stream_send_dp_sdp(const struct dc_stream_state *stream,
 		const uint8_t *custom_sdp_message,
 		unsigned int sdp_message_size)
 {
 	int i;
-	struct dc  *core_dc;
+	struct dc  *dc;
 	struct resource_context *res_ctx;
 
 	if (stream == NULL) {
@@ -414,8 +384,8 @@ bool dc_stream_send_dp_sdp(const struct dc_stream_state *stream,
 		return false;
 	}
 
-	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_state->res_ctx;
+	dc = stream->ctx->dc;
+	res_ctx = &dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -423,11 +393,14 @@ bool dc_stream_send_dp_sdp(const struct dc_stream_state *stream,
 		if (pipe_ctx->stream != stream)
 			continue;
 
-		build_dp_sdp_info_frame(pipe_ctx, custom_sdp_message, sdp_message_size);
-
-		core_dc->hwss.update_info_frame(pipe_ctx);
+		if (dc->hwss.send_immediate_sdp_message != NULL)
+			dc->hwss.send_immediate_sdp_message(pipe_ctx,
+								custom_sdp_message,
+								sdp_message_size);
+		else
+			DC_LOG_WARNING("%s:send_immediate_sdp_message not implemented on this ASIC\n",
+			__func__);
 
-		invalid_dp_sdp_info_frame(pipe_ctx);
 	}
 
 	return true;

commit 40df2f809e8fe4d9e4f9b7b177f95e76e1f36442
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Apr 17 19:15:15 2019 -0400

    drm/amd/display: color space ycbcr709 support
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Duke Du <Duke.Du@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 96e97d25d639..a79f608b2f79 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -47,8 +47,8 @@ void update_stream_signal(struct dc_stream_state *stream, struct dc_sink *sink)
 
 	if (dc_is_dvi_signal(stream->signal)) {
 		if (stream->ctx->dc->caps.dual_link_dvi &&
-		    (stream->timing.pix_clk_100hz / 10) > TMDS_MAX_PIXEL_CLOCK &&
-		    sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+			(stream->timing.pix_clk_100hz / 10) > TMDS_MAX_PIXEL_CLOCK &&
+			sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;

commit 11f874c041f0476ec9fc44387478d3bbb3c74b73
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Apr 26 22:48:11 2019 +0100

    drm/amd/display: fix incorrect null check on pointer
    
    Currently an allocation is being made but the allocation failure
    check is being performed on another pointer. Fix this by checking
    the correct pointer. Also use the normal kernel idiom for null
    pointer checks.
    
    Addresses-Coverity: ("Resource leak")
    Fixes: 43e3ac8389ef ("drm/amd/display: Add function to copy DC streams")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 6200df3edcd0..96e97d25d639 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -168,7 +168,7 @@ struct dc_stream_state *dc_copy_stream(const struct dc_stream_state *stream)
 	struct dc_stream_state *new_stream;
 
 	new_stream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);
-	if (stream == NULL)
+	if (!new_stream)
 		return NULL;
 
 	memcpy(new_stream, stream, sizeof(struct dc_stream_state));

commit cc602e2b0d78254e41bb81f32e2825f00c7cc69c
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Apr 8 13:47:10 2019 -0400

    drm/amd/display: Allow cursor position when plane_res.ipp is NULL
    
    [Why]
    Starting with DCN1, the input_pixel_processor (ipp) struct has been
    replaced by dpp struct (part of DAL3.1 SW architecture change).
    Need to update logic to handle cases where ipp is never allocated.
    
    [How]
    Only skip cursor position programming if both ipp and dpp resources
    are NULL.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 09d765f359b0..6200df3edcd0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -333,7 +333,7 @@ bool dc_stream_set_cursor_position(
 				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
 				!pipe_ctx->plane_state ||
 				(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp) ||
-				!pipe_ctx->plane_res.ipp)
+				(!pipe_ctx->plane_res.ipp && !pipe_ctx->plane_res.dpp))
 			continue;
 
 		if (!pipe_to_program) {

commit 43e3ac8389ef68ab2347eb1ae4a6e5b49793614e
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Fri Mar 29 18:22:16 2019 -0400

    drm/amd/display: Add function to copy DC streams
    
    We'll need the ability to copy a dc_stream_state for some features.
    Implement it here.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index e10479d58c11..09d765f359b0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -163,6 +163,27 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	return stream;
 }
 
+struct dc_stream_state *dc_copy_stream(const struct dc_stream_state *stream)
+{
+	struct dc_stream_state *new_stream;
+
+	new_stream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);
+	if (stream == NULL)
+		return NULL;
+
+	memcpy(new_stream, stream, sizeof(struct dc_stream_state));
+
+	if (new_stream->sink)
+		dc_sink_retain(new_stream->sink);
+
+	if (new_stream->out_transfer_func)
+		dc_transfer_func_retain(new_stream->out_transfer_func);
+
+	kref_init(&new_stream->refcount);
+
+	return new_stream;
+}
+
 /**
  * dc_stream_get_status_from_state - Get stream status from given dc state
  * @state: DC state to find the stream status in

commit 623588b8ee601c4e15e717ea5cbea838cd9723ac
Author: David Francis <David.Francis@amd.com>
Date:   Mon Mar 25 09:44:04 2019 -0400

    drm/amd/display: Handle get crtc position error
    
    [Why]
    dc_stream_get_crtc_position can return false.
    This was unhandled in delay_cursor_until_vupdate
    
    [How]
    If dc_stream_get_crtc_position returns false, something
    is weird.  Don't delay.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index f7a293902234..e10479d58c11 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -211,7 +211,8 @@ static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 			ASIC_REV_IS_RAVEN(stream->ctx->asic_id.hw_internal_rev)) {
 
 		vupdate_line = get_vupdate_offset_from_vsync(pipe_ctx);
-		dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos);
+		if (!dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos))
+			return;
 
 		if (vpos >= vupdate_line)
 			return;

commit 4e8738a206d28d681c1c5195e4d085d5ffcb00fc
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Mar 20 16:15:22 2019 -0500

    drm/amdgpu/display: fix build when DCN KCONFIG is not set
    
    Leads to an undefined symbol otherwise.
    
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 4af3545fc414..f7a293902234 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -29,7 +29,9 @@
 #include "resource.h"
 #include "ipp.h"
 #include "timing_generator.h"
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "dcn10/dcn10_hw_sequencer.h"
+#endif
 
 #define DC_LOGGER dc->ctx->logger
 
@@ -199,6 +201,7 @@ struct dc_stream_status *dc_stream_get_status(
 
 static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 {
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	unsigned int vupdate_line;
 	unsigned int lines_to_vupdate, us_to_vupdate, vpos, nvpos;
 	struct dc_stream_state *stream = pipe_ctx->stream;
@@ -221,6 +224,7 @@ static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
 		if (us_to_vupdate < 70)
 			udelay(us_to_vupdate);
 	}
+#endif
 }
 
 /**

commit d5f90f3a0ab3d8a458c3152e6b56a5845d3f7b3f
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Thu Mar 7 15:31:11 2019 -0500

    drm/amd/display: Expose generic SDP message access interface
    
    [Why]
    We need to add DP SDP message test debugfs to make sdp message test
    more convenient and efficient.
    
    [How]
    Add a DM accessible SDP interface for custom data.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 59ccab36dab8..4af3545fc414 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -345,6 +345,68 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 	return 0;
 }
 
+static void build_dp_sdp_info_frame(struct pipe_ctx *pipe_ctx,
+		const uint8_t  *custom_sdp_message,
+		unsigned int sdp_message_size)
+{
+	uint8_t i;
+	struct encoder_info_frame *info = &pipe_ctx->stream_res.encoder_info_frame;
+
+	/* set valid info */
+	info->dpsdp.valid = true;
+
+	/* set sdp message header */
+	info->dpsdp.hb0 = custom_sdp_message[0]; /* package id */
+	info->dpsdp.hb1 = custom_sdp_message[1]; /* package type */
+	info->dpsdp.hb2 = custom_sdp_message[2]; /* package specific byte 0 any data */
+	info->dpsdp.hb3 = custom_sdp_message[3]; /* package specific byte 0 any data */
+
+	/* set sdp message data */
+	for (i = 0; i < 32; i++)
+		info->dpsdp.sb[i] = (custom_sdp_message[i+4]);
+
+}
+
+static void invalid_dp_sdp_info_frame(struct pipe_ctx *pipe_ctx)
+{
+	struct encoder_info_frame *info = &pipe_ctx->stream_res.encoder_info_frame;
+
+	/* in-valid info */
+	info->dpsdp.valid = false;
+}
+
+bool dc_stream_send_dp_sdp(const struct dc_stream_state *stream,
+		const uint8_t *custom_sdp_message,
+		unsigned int sdp_message_size)
+{
+	int i;
+	struct dc  *core_dc;
+	struct resource_context *res_ctx;
+
+	if (stream == NULL) {
+		dm_error("DC: dc_stream is NULL!\n");
+		return false;
+	}
+
+	core_dc = stream->ctx->dc;
+	res_ctx = &core_dc->current_state->res_ctx;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->stream != stream)
+			continue;
+
+		build_dp_sdp_info_frame(pipe_ctx, custom_sdp_message, sdp_message_size);
+
+		core_dc->hwss.update_info_frame(pipe_ctx);
+
+		invalid_dp_sdp_info_frame(pipe_ctx);
+	}
+
+	return true;
+}
+
 bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 				  uint32_t *v_blank_start,
 				  uint32_t *v_blank_end,

commit c6ade4ee7375c0bb47ba25be53918eaa842ae263
Author: David Francis <David.Francis@amd.com>
Date:   Thu Feb 21 15:04:05 2019 -0500

    drm/amd/display: On DCN1, Wait for vupdate on cursor updates
    
    [Why]
    Cursor updates must acquire the pipe control lock to
    prevent vupdate from triggering in the middle of cursor
    programming. On DCN1 the pipe control lock prevents
    pageflips from occurring. This means that a cursor update
    right before vupdate can delay a pending pageflip
    
    [How]
    If the time until the next vupdate is less than a
    conservative estimate of the cursor programming time,
    wait until the vupdate has passed before locking.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 996298c35f42..59ccab36dab8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -29,6 +29,7 @@
 #include "resource.h"
 #include "ipp.h"
 #include "timing_generator.h"
+#include "dcn10/dcn10_hw_sequencer.h"
 
 #define DC_LOGGER dc->ctx->logger
 
@@ -196,6 +197,32 @@ struct dc_stream_status *dc_stream_get_status(
 	return dc_stream_get_status_from_state(dc->current_state, stream);
 }
 
+static void delay_cursor_until_vupdate(struct pipe_ctx *pipe_ctx, struct dc *dc)
+{
+	unsigned int vupdate_line;
+	unsigned int lines_to_vupdate, us_to_vupdate, vpos, nvpos;
+	struct dc_stream_state *stream = pipe_ctx->stream;
+	unsigned int us_per_line;
+
+	if (stream->ctx->asic_id.chip_family == FAMILY_RV &&
+			ASIC_REV_IS_RAVEN(stream->ctx->asic_id.hw_internal_rev)) {
+
+		vupdate_line = get_vupdate_offset_from_vsync(pipe_ctx);
+		dc_stream_get_crtc_position(dc, &stream, 1, &vpos, &nvpos);
+
+		if (vpos >= vupdate_line)
+			return;
+
+		us_per_line = stream->timing.h_total * 10000 / stream->timing.pix_clk_100hz;
+		lines_to_vupdate = vupdate_line - vpos;
+		us_to_vupdate = lines_to_vupdate * us_per_line;
+
+		/* 70 us is a conservative estimate of cursor update time*/
+		if (us_to_vupdate < 70)
+			udelay(us_to_vupdate);
+	}
+}
+
 /**
  * dc_stream_set_cursor_attributes() - Update cursor attributes and set cursor surface address
  */
@@ -234,6 +261,8 @@ bool dc_stream_set_cursor_attributes(
 
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;
+
+			delay_cursor_until_vupdate(pipe_ctx, core_dc);
 			core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, true);
 		}
 
@@ -283,6 +312,8 @@ bool dc_stream_set_cursor_position(
 
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;
+
+			delay_cursor_until_vupdate(pipe_ctx, core_dc);
 			core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, true);
 		}
 

commit 09f609c34fc8b9cb560947ab11609259f5d42889
Author: Leo Li <sunpeng.li@amd.com>
Date:   Tue Nov 27 15:05:12 2018 -0500

    drm/amd/display: Fix driver load crash in amdgpu_dm
    
    [Why]
    This fixes an regression introduced by:
        drm/amd/display: add stream ID and otg instance in dc_stream_state
    
    During driver initialization, a null pointer deref is raised. This is
    caused by searching for a stream status in the dc->current_state before
    the dc_state swap happens at the end of dc_commit_state_no_check().
    Since the swap has not happened, the dc_state to be swapped in should
    be searched, and not dc->current_state.
    
    [How]
    Add a function that searches for the stream status within the given
    dc_state, instead of dc->current_state. Use that before the state swap
    happens in dc_commit_state_no_check().
    
    Also remove duplicate occurrences of this function in amdgpu_dm.c.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index e498a9aa8035..996298c35f42 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -160,20 +160,42 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	return stream;
 }
 
-struct dc_stream_status *dc_stream_get_status(
+/**
+ * dc_stream_get_status_from_state - Get stream status from given dc state
+ * @state: DC state to find the stream status in
+ * @stream: The stream to get the stream status for
+ *
+ * The given stream is expected to exist in the given dc state. Otherwise, NULL
+ * will be returned.
+ */
+struct dc_stream_status *dc_stream_get_status_from_state(
+	struct dc_state *state,
 	struct dc_stream_state *stream)
 {
 	uint8_t i;
-	struct dc  *dc = stream->ctx->dc;
 
-	for (i = 0; i < dc->current_state->stream_count; i++) {
-		if (stream == dc->current_state->streams[i])
-			return &dc->current_state->stream_status[i];
+	for (i = 0; i < state->stream_count; i++) {
+		if (stream == state->streams[i])
+			return &state->stream_status[i];
 	}
 
 	return NULL;
 }
 
+/**
+ * dc_stream_get_status() - Get current stream status of the given stream state
+ * @stream: The stream to get the stream status for.
+ *
+ * The given stream is expected to exist in dc->current_state. Otherwise, NULL
+ * will be returned.
+ */
+struct dc_stream_status *dc_stream_get_status(
+	struct dc_stream_state *stream)
+{
+	struct dc *dc = stream->ctx->dc;
+	return dc_stream_get_status_from_state(dc->current_state, stream);
+}
+
 /**
  * dc_stream_set_cursor_attributes() - Update cursor attributes and set cursor surface address
  */

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 336586ba4639..e498a9aa8035 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -44,7 +44,7 @@ void update_stream_signal(struct dc_stream_state *stream, struct dc_sink *sink)
 
 	if (dc_is_dvi_signal(stream->signal)) {
 		if (stream->ctx->dc->caps.dual_link_dvi &&
-		    stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK &&
+		    (stream->timing.pix_clk_100hz / 10) > TMDS_MAX_PIXEL_CLOCK &&
 		    sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
@@ -339,7 +339,7 @@ void dc_stream_log(const struct dc *dc, const struct dc_stream_state *stream)
 			stream->output_color_space);
 	DC_LOG_DC(
 			"\tpix_clk_khz: %d, h_total: %d, v_total: %d, pixelencoder:%d, displaycolorDepth:%d\n",
-			stream->timing.pix_clk_khz,
+			stream->timing.pix_clk_100hz / 10,
 			stream->timing.h_total,
 			stream->timing.v_total,
 			stream->timing.pixel_encoding,

commit 04a789bef315a3ed64f296fab21be3933405ea43
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 23 15:21:02 2018 -0500

    drm/amd/display: add stream ID and otg instance in dc_stream_state
    
    [why]
    stream ID allows DMs to avoid memory address comparisons to compare
    stream equality.
    otg_instance allows DC to more rigorously define when otg_instance
    can change.  specifically, it is now defined to be only mutable when dc_stream_state
    changes.  This is better than a "get status" function which prevents efficient
    caching of otherwise very stable information.
    
    [how]
    stream ID follows similar pattern to sink ID, which is already implemented
    
    otg_instance is an output which occurs on all dc_stream modification functions
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 8f9dc6f54bf1..336586ba4639 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -107,6 +107,9 @@ static void construct(struct dc_stream_state *stream,
 	stream->out_transfer_func = dc_create_transfer_func();
 	stream->out_transfer_func->type = TF_TYPE_BYPASS;
 	stream->out_transfer_func->ctx = stream->ctx;
+
+	stream->stream_id = stream->ctx->dc_stream_id_count;
+	stream->ctx->dc_stream_id_count++;
 }
 
 static void destruct(struct dc_stream_state *stream)

commit ceb3dbb4690db8377ad127a5666cd4775d9f70f4
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 9 09:21:21 2018 -0500

    drm/amd/display: remove sink reference in dc_stream_state
    
    [why]
    dc_stream_state containing a pointer to sink is poor design.
    Sink describes the display, and the specifications or capabilities
    it has.  That information is irrelevant for dc_stream_state, which describes
    hardware state, and is generally used for hardware programming.  It
    could further be argued that dc_sink itself is just a convenience dc
    provides, and DC should be perfectly capable of programming hardware
    without any dc_sinks (for example, emulated sinks).
    
    [how]
    Phase 1:
    Deprecate use of dc_sink pointer in dc_stream.  Most references are trivial
    to remove, but some call sites are risky (such as is_timing_changed) with
    no obvious logical replacement.  These will be removed in follow up change.
    
    Add dc_link pointer to dc_stream.  This is the typical reason DC really needed
    sink pointer, and most call sites are replaced with this.
    
    DMs also need minor updates, as all 3 DMs leverage stream->sink for
    some functionality.  this is replaced instead by a pointer to private data
    inside dc_stream_state, which is used by DMs as a quality of life improvment
    for some key functionality.  it allows DMs to set pointers have to their own objects
    which associate OS objects to dc_stream_states (such as DisplayTarget
    and amdgpu_dm_connector).  Without the private pointer, DMs would be
    forced to perform a lookup for callbacks.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 66e5c4623a49..8f9dc6f54bf1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -35,20 +35,17 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-void update_stream_signal(struct dc_stream_state *stream)
+void update_stream_signal(struct dc_stream_state *stream, struct dc_sink *sink)
 {
-
-	struct dc_sink *dc_sink = stream->sink;
-
-	if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-		stream->signal = stream->sink->link->connector_signal;
+	if (sink->sink_signal == SIGNAL_TYPE_NONE)
+		stream->signal = stream->link->connector_signal;
 	else
-		stream->signal = dc_sink->sink_signal;
+		stream->signal = sink->sink_signal;
 
 	if (dc_is_dvi_signal(stream->signal)) {
 		if (stream->ctx->dc->caps.dual_link_dvi &&
 		    stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK &&
-		    stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+		    sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
@@ -61,10 +58,15 @@ static void construct(struct dc_stream_state *stream,
 	uint32_t i = 0;
 
 	stream->sink = dc_sink_data;
-	stream->ctx = stream->sink->ctx;
-
 	dc_sink_retain(dc_sink_data);
 
+	stream->ctx = dc_sink_data->ctx;
+	stream->link = dc_sink_data->link;
+	stream->sink_patches = dc_sink_data->edid_caps.panel_patch;
+	stream->converter_disable_audio = dc_sink_data->converter_disable_audio;
+	stream->qs_bit = dc_sink_data->edid_caps.qs_bit;
+	stream->qy_bit = dc_sink_data->edid_caps.qy_bit;
+
 	/* Copy audio modes */
 	/* TODO - Remove this translation */
 	for (i = 0; i < (dc_sink_data->edid_caps.audio_mode_count); i++)
@@ -100,7 +102,7 @@ static void construct(struct dc_stream_state *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
-	update_stream_signal(stream);
+	update_stream_signal(stream, dc_sink_data);
 
 	stream->out_transfer_func = dc_create_transfer_func();
 	stream->out_transfer_func->type = TF_TYPE_BYPASS;
@@ -339,11 +341,7 @@ void dc_stream_log(const struct dc *dc, const struct dc_stream_state *stream)
 			stream->timing.v_total,
 			stream->timing.pixel_encoding,
 			stream->timing.display_color_depth);
-	DC_LOG_DC(
-			"\tsink name: %s, serial: %d\n",
-			stream->sink->edid_caps.display_name,
-			stream->sink->edid_caps.serial_number);
 	DC_LOG_DC(
 			"\tlink: %d\n",
-			stream->sink->link->link_index);
+			stream->link->link_index);
 }

commit 2119aa17c963e59710617c70bb7b59e89c5ff447
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 9 09:45:28 2018 -0400

    drm/amd/display: Start documentation of DC
    
    [Why]
    There are a lot of unintuitive parts of the dm-dc interface.
    It would help us if these were documented to provide
    a common understanding of what they are supposed to do
    
    [How]
    Most of this documentation is stubs, to be filled out more
    thoroughly by the experts
    
    Not every dm-accessible function and struct is mentioned.
    Simple functions like getters, setters, retain, release,
    create, destroy can be left unadorned.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 780838a05f44..66e5c4623a49 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -170,7 +170,7 @@ struct dc_stream_status *dc_stream_get_status(
 }
 
 /**
- * Update the cursor attributes and set cursor surface address
+ * dc_stream_set_cursor_attributes() - Update cursor attributes and set cursor surface address
  */
 bool dc_stream_set_cursor_attributes(
 	struct dc_stream_state *stream,

commit 37cd85ce3322706d9d357ffbe54481fa884af9e5
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 16 14:21:32 2018 -0400

    drm/amd/display: Remove dc_stream_state->status
    
    [Why]
    dc_state has an array of dc_stream_status that contain
    pointers to the dc_plane_state and other useful information
    
    Confusingly, dc_stream_state also contains a dc_stream_status
    called status.  This struct was partially initialized and
    used in a few places
    
    [How]
    stream->status.link has been replaced with stream->sink->link.
    If a stream does not have a sink, or a sink does not have a link,
    something has gone seriously wrong
    
    All other properties of stream->status were zeroed by kzalloc
    and never initialized, so they have been replaced by the number 0
    
    This is a refactor: no functional change is intended
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index e113439aaa86..780838a05f44 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -100,8 +100,6 @@ static void construct(struct dc_stream_state *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
-	stream->status.link = stream->sink->link;
-
 	update_stream_signal(stream);
 
 	stream->out_transfer_func = dc_create_transfer_func();

commit ce8a805ae1768be16c62a541ce1b2d23e7b99124
Author: David Francis <David.Francis@amd.com>
Date:   Fri Sep 21 14:36:17 2018 -0400

    drm/amd/display: initialize dc_transfer_func->ctx
    
    [Why]
    dc_transfer_func structs were being passed around with a null
    pointer, waiting for unsuspecting programmers to dereference it.
    
    [How]
    Initialize it
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 2ac848a106ba..e113439aaa86 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -106,6 +106,7 @@ static void construct(struct dc_stream_state *stream,
 
 	stream->out_transfer_func = dc_create_transfer_func();
 	stream->out_transfer_func->type = TF_TYPE_BYPASS;
+	stream->out_transfer_func->ctx = stream->ctx;
 }
 
 static void destruct(struct dc_stream_state *stream)

commit 94a4ffd1d40b845dd19f9fdbb2cb6bf32de0946b
Author: Gloria Li <geling.li@amd.com>
Date:   Thu Jul 26 11:32:14 2018 -0400

    drm/amd/display: fix PIP bugs on Dal3
    
    [Why]
    There are outstanding bugs for PIP in Dal3:
    -Crash when toggling PIP visibility
    -Global Alpha is not working, Adjusting global alpha
     doesn’t have an effect
    -Cursor is not working with pip plane and pipe splits
    -One flash occurs when cursor enters PIP plane from
     top/bottom
    -Crash when moving PIP plane off the screen
    
    [How]
    Resolve divide by 0 error
    Implement global alpha
    Program cursor on all pipes
    Add dst rects' x and y offests into cursor position
    Disable cursor when it is beyond bottom/top edge
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index fdcc8ab19bf3..2ac848a106ba 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -205,8 +205,6 @@ bool dc_stream_set_cursor_attributes(
 
 		if (pipe_ctx->stream != stream)
 			continue;
-		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
-			continue;
 
 		if (!pipe_to_program) {
 			pipe_to_program = pipe_ctx;

commit ddb85fcd839cab0ac46a44d47c4f345dad4c2cb1
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Tue Jul 10 16:04:05 2018 -0400

    drm/amd/display: Null ptr check for set_sdr_white_level
    
    [Why&How]
    Cursor boosting can only be done on DCN+
    Check for nullptr since DCE doesn't implement it.
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Sivapiriyan Kumarasamy <Sivapiriyan.Kumarasamy@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 4717330a42f4..fdcc8ab19bf3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -214,7 +214,8 @@ bool dc_stream_set_cursor_attributes(
 		}
 
 		core_dc->hwss.set_cursor_attribute(pipe_ctx);
-		core_dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
+		if (core_dc->hwss.set_cursor_sdr_white_level)
+			core_dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
 	}
 
 	if (pipe_to_program)

commit 6d92b5c2d5bea1b1d0859bd8f3080344e5e3960e
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Wed Jun 27 18:23:37 2018 -0400

    drm/amd/display: Refactor SDR cursor boosting in HDR mode
    
    [Why]
    Cursor boosting is done via CNVC_CUR register which is DPP, not HUBP
    Previous commit was implementing it in HUBP functions,
    and also breaking diags tests.
    
    [How]
    1. Undo original commit as well as Eric's diags test fix, almost completely
    2. Move programming to DPP and call via new dc_stream function
    3. Also removing cur_rom_en from dpp_cursor_attributes and programming
    as part of normal cursor attributes as it depends on cursor color format
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 0223f4867e8d..4717330a42f4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -214,6 +214,7 @@ bool dc_stream_set_cursor_attributes(
 		}
 
 		core_dc->hwss.set_cursor_attribute(pipe_ctx);
+		core_dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
 	}
 
 	if (pipe_to_program)

commit e1cb3e4801e6896ba93d63222b1052199d2a8c9b
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Jun 19 09:58:24 2018 -0400

    drm/amd/display: Convert remaining loggers off dc_logger
    
    - Removed dal/dm/dc loggers from linux, switched to kernel prints
    - Modified functions that used these directly to use macros
    - dc_logger support is completely dropped from Linux
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3732a1de9d6c..0223f4867e8d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -30,6 +30,8 @@
 #include "ipp.h"
 #include "timing_generator.h"
 
+#define DC_LOGGER dc->ctx->logger
+
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
@@ -317,16 +319,10 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 	return ret;
 }
 
-
-void dc_stream_log(
-	const struct dc_stream_state *stream,
-	struct dal_logger *dm_logger,
-	enum dc_log_type log_type)
+void dc_stream_log(const struct dc *dc, const struct dc_stream_state *stream)
 {
-
-	dm_logger_write(dm_logger,
-			log_type,
-			"core_stream 0x%x: src: %d, %d, %d, %d; dst: %d, %d, %d, %d, colorSpace:%d\n",
+	DC_LOG_DC(
+			"core_stream 0x%p: src: %d, %d, %d, %d; dst: %d, %d, %d, %d, colorSpace:%d\n",
 			stream,
 			stream->src.x,
 			stream->src.y,
@@ -337,21 +333,18 @@ void dc_stream_log(
 			stream->dst.width,
 			stream->dst.height,
 			stream->output_color_space);
-	dm_logger_write(dm_logger,
-			log_type,
+	DC_LOG_DC(
 			"\tpix_clk_khz: %d, h_total: %d, v_total: %d, pixelencoder:%d, displaycolorDepth:%d\n",
 			stream->timing.pix_clk_khz,
 			stream->timing.h_total,
 			stream->timing.v_total,
 			stream->timing.pixel_encoding,
 			stream->timing.display_color_depth);
-	dm_logger_write(dm_logger,
-			log_type,
+	DC_LOG_DC(
 			"\tsink name: %s, serial: %d\n",
 			stream->sink->edid_caps.display_name,
 			stream->sink->edid_caps.serial_number);
-	dm_logger_write(dm_logger,
-			log_type,
+	DC_LOG_DC(
 			"\tlink: %d\n",
 			stream->sink->link->link_index);
 }

commit 3bff0796e90960b0abfea21c7f2b50d2d6a19bd9
Author: Martin Tsai <Martin.Tsai@amd.com>
Date:   Tue Apr 17 17:20:06 2018 -0400

    drm/amd/display: to synchronize the hubp and dpp programming in cursor control
    
    Signed-off-by: Martin Tsai <Martin.Tsai@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3b2ddbd8c054..3732a1de9d6c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -178,6 +178,7 @@ bool dc_stream_set_cursor_attributes(
 	int i;
 	struct dc  *core_dc;
 	struct resource_context *res_ctx;
+	struct pipe_ctx *pipe_to_program = NULL;
 
 	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
@@ -205,9 +206,17 @@ bool dc_stream_set_cursor_attributes(
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
 
+		if (!pipe_to_program) {
+			pipe_to_program = pipe_ctx;
+			core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, true);
+		}
 
 		core_dc->hwss.set_cursor_attribute(pipe_ctx);
 	}
+
+	if (pipe_to_program)
+		core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, false);
+
 	return true;
 }
 
@@ -218,6 +227,7 @@ bool dc_stream_set_cursor_position(
 	int i;
 	struct dc  *core_dc;
 	struct resource_context *res_ctx;
+	struct pipe_ctx *pipe_to_program = NULL;
 
 	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
@@ -243,9 +253,17 @@ bool dc_stream_set_cursor_position(
 				!pipe_ctx->plane_res.ipp)
 			continue;
 
+		if (!pipe_to_program) {
+			pipe_to_program = pipe_ctx;
+			core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, true);
+		}
+
 		core_dc->hwss.set_cursor_position(pipe_ctx);
 	}
 
+	if (pipe_to_program)
+		core_dc->hwss.pipe_control_lock(core_dc, pipe_to_program, false);
+
 	return true;
 }
 

commit e43a432c018a9a2c2641e1f8c08a836cc83982cd
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Mar 27 16:43:56 2018 -0400

    drm/amd/display: Have DC manage its own allocation of gamma
    
    Creating plane will also allocate gamma and input TF
    Creating stream will also allocate outputTF
    
    Fix issue with gamma not applied
    OS may call SetGamma before surface committed, so need to store
    in target and apply later.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index ce0747ed0f00..3b2ddbd8c054 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -101,14 +101,16 @@ static void construct(struct dc_stream_state *stream,
 	stream->status.link = stream->sink->link;
 
 	update_stream_signal(stream);
+
+	stream->out_transfer_func = dc_create_transfer_func();
+	stream->out_transfer_func->type = TF_TYPE_BYPASS;
 }
 
 static void destruct(struct dc_stream_state *stream)
 {
 	dc_sink_release(stream->sink);
 	if (stream->out_transfer_func != NULL) {
-		dc_transfer_func_release(
-				stream->out_transfer_func);
+		dc_transfer_func_release(stream->out_transfer_func);
 		stream->out_transfer_func = NULL;
 	}
 }

commit d1aaad05d0c39c8bf796e556ebbcc4ed6f4d799a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Mar 2 17:19:27 2018 -0500

    drm/amd/display: Check for HW blocks in HWSS, rather than DC core for cursor
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index cd5819789d76..ce0747ed0f00 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -198,8 +198,7 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || (!pipe_ctx->plane_res.xfm &&
-		    !pipe_ctx->plane_res.dpp) || !pipe_ctx->plane_res.ipp)
+		if (pipe_ctx->stream != stream)
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;

commit 5d447f09b8d8346c64f4c952a67c61f7ce88d3c1
Author: Shirish S <shirish.s@amd.com>
Date:   Wed Feb 21 16:10:33 2018 +0530

    drm/amd/display: check for ipp before calling cursor operations
    
    Currently all cursor related functions are made to all
    pipes that are attached to a particular stream.
    This is not applicable to pipes that do not have cursor plane
    initialised like underlay.
    Hence this patch allows cursor related operations on a pipe
    only if ipp in available on that particular pipe.
    
    The check is added to set_cursor_position & set_cursor_attribute.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 87a193ac2883..cd5819789d76 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -198,7 +198,8 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || (!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
+		if (pipe_ctx->stream != stream || (!pipe_ctx->plane_res.xfm &&
+		    !pipe_ctx->plane_res.dpp) || !pipe_ctx->plane_res.ipp)
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
@@ -237,7 +238,8 @@ bool dc_stream_set_cursor_position(
 		if (pipe_ctx->stream != stream ||
 				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
 				!pipe_ctx->plane_state ||
-				(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
+				(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp) ||
+				!pipe_ctx->plane_res.ipp)
 			continue;
 
 		core_dc->hwss.set_cursor_position(pipe_ctx);

commit 33fd17d9125c008143c3df166e01f2e9f89f48ce
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Thu Jan 18 19:07:54 2018 -0500

    drm/amd/display: fix cursor related Pstate hang
    
    Move cursor programming to inside the OTG_MASTER_UPDATE_LOCK
    
    If graphics plane go from 1 pipe to hsplit, the cursor updates
    after mpc programming and unlock. Which means there is a window
    of time where cursor is enabled on the wrong pipe if it's on
    the right side of the screen (i.e. case where cursor need to
    move from pipe 0 to pipe 3 post split). This will cause pstate hang.
    
    Solution is to program the cursor while still locked.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index c3b198836d1d..87a193ac2883 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -193,6 +193,7 @@ bool dc_stream_set_cursor_attributes(
 
 	core_dc = stream->ctx->dc;
 	res_ctx = &core_dc->current_state->res_ctx;
+	stream->cursor_attributes = *attributes;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -203,34 +204,8 @@ bool dc_stream_set_cursor_attributes(
 			continue;
 
 
-		if (pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes != NULL)
-			pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
-						pipe_ctx->plane_res.ipp, attributes);
-
-		if (pipe_ctx->plane_res.hubp != NULL &&
-				pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes != NULL)
-			pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(
-					pipe_ctx->plane_res.hubp, attributes);
-
-		if (pipe_ctx->plane_res.mi != NULL &&
-				pipe_ctx->plane_res.mi->funcs->set_cursor_attributes != NULL)
-			pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
-					pipe_ctx->plane_res.mi, attributes);
-
-
-		if (pipe_ctx->plane_res.xfm != NULL &&
-				pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
-			pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
-				pipe_ctx->plane_res.xfm, attributes);
-
-		if (pipe_ctx->plane_res.dpp != NULL &&
-				pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes != NULL)
-			pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(
-				pipe_ctx->plane_res.dpp, attributes->color_format);
+		core_dc->hwss.set_cursor_attribute(pipe_ctx);
 	}
-
-	stream->cursor_attributes = *attributes;
-
 	return true;
 }
 
@@ -254,21 +229,10 @@ bool dc_stream_set_cursor_position(
 
 	core_dc = stream->ctx->dc;
 	res_ctx = &core_dc->current_state->res_ctx;
+	stream->cursor_position = *position;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
-		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
-		struct mem_input *mi = pipe_ctx->plane_res.mi;
-		struct hubp *hubp = pipe_ctx->plane_res.hubp;
-		struct dpp *dpp = pipe_ctx->plane_res.dpp;
-		struct dc_cursor_position pos_cpy = *position;
-		struct dc_cursor_mi_param param = {
-			.pixel_clk_khz = stream->timing.pix_clk_khz,
-			.ref_clk_khz = core_dc->res_pool->ref_clock_inKhz,
-			.viewport_x_start = pipe_ctx->plane_res.scl_data.viewport.x,
-			.viewport_width = pipe_ctx->plane_res.scl_data.viewport.width,
-			.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz
-		};
 
 		if (pipe_ctx->stream != stream ||
 				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
@@ -276,33 +240,9 @@ bool dc_stream_set_cursor_position(
 				(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
 			continue;
 
-		if (pipe_ctx->plane_state->address.type
-				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
-			pos_cpy.enable = false;
-
-		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
-			pos_cpy.enable = false;
-
-
-		if (ipp != NULL && ipp->funcs->ipp_cursor_set_position != NULL)
-			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
-
-		if (mi != NULL && mi->funcs->set_cursor_position != NULL)
-			mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
-
-		if (!hubp)
-			continue;
-
-		if (hubp->funcs->set_cursor_position != NULL)
-			hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
-
-		if (dpp != NULL && dpp->funcs->set_cursor_position != NULL)
-			dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width);
-
+		core_dc->hwss.set_cursor_position(pipe_ctx);
 	}
 
-	stream->cursor_position = *position;
-
 	return true;
 }
 

commit 9182b4cb445dc31bd46d2cc1e9e7e38771fdbae4
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Dec 18 12:01:30 2017 -0500

    drm/amd/display: Call update_stream_signal directly from amdgpu_dm
    
    There's no good place in DC to cover all place where stream signal should
    be updated. update_stream_signal depends on timing which comes from DM.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3cbdd8cacd37..c3b198836d1d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -33,7 +33,7 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-static void update_stream_signal(struct dc_stream_state *stream)
+void update_stream_signal(struct dc_stream_state *stream)
 {
 
 	struct dc_sink *dc_sink = stream->sink;

commit f2c7c55b0e00817fa28b800834fe2b2bc22946b6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Dec 18 14:36:01 2017 -0500

    drm/amd/display: Don't block dual-link DVI modes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 37dd109f4c53..3cbdd8cacd37 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -33,7 +33,6 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
-#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
 static void update_stream_signal(struct dc_stream_state *stream)
 {
 
@@ -46,7 +45,7 @@ static void update_stream_signal(struct dc_stream_state *stream)
 
 	if (dc_is_dvi_signal(stream->signal)) {
 		if (stream->ctx->dc->caps.dual_link_dvi &&
-		    stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+		    stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK &&
 		    stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else

commit 7e98ab103521f82957f3c2d82d555a6803360440
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Dec 19 16:17:22 2017 -0500

    drm/amd/display: Don't allow dual-link DVI on all ASICs.
    
    Our APUs (Carrizo, Stoney, Raven) don't support it.
    
    v2: Don't use is_apu as other ASICs might also not support it
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 261811e0c094..37dd109f4c53 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -45,8 +45,9 @@ static void update_stream_signal(struct dc_stream_state *stream)
 		stream->signal = dc_sink->sink_signal;
 
 	if (dc_is_dvi_signal(stream->signal)) {
-		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
-			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+		if (stream->ctx->dc->caps.dual_link_dvi &&
+		    stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+		    stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;

commit ea783c31e270dbdd82d5b9d40de4e6336e92e5b2
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Nov 21 16:12:23 2017 -0500

    drm/amd/display: Cache cursor position.
    
    When programming cursor position after front end programmed,
    if position is already set previously, it doesn't make sense
    to program position with all 0.
    Cache position and use the parameter after front end programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index e39568b4460c..261811e0c094 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -301,6 +301,8 @@ bool dc_stream_set_cursor_position(
 
 	}
 
+	stream->cursor_position = *position;
+
 	return true;
 }
 

commit 9a0beb3944f28d9d3d1864ca2145a940bc829295
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Nov 14 12:13:27 2017 -0500

    drm/amd/display: CNVC pseudocode review follow up
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 375fb457e223..e39568b4460c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -226,7 +226,7 @@ bool dc_stream_set_cursor_attributes(
 		if (pipe_ctx->plane_res.dpp != NULL &&
 				pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(
-				pipe_ctx->plane_res.dpp, attributes);
+				pipe_ctx->plane_res.dpp, attributes->color_format);
 	}
 
 	stream->cursor_attributes = *attributes;

commit e14ca957797470978cf2a8b18c1a136b6cb7dc8f
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Nov 3 17:58:42 2017 -0400

    drm/amd/display: combine output signal and signal
    
    output signal used to be a public member to be used by DM to override
    the stream signal. Now since there is no longer separation between
    public and private part of stream, they are combined. The overriding
    was not working properly as well, which is addressed by this change
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index e230cc44a0a7..375fb457e223 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -36,16 +36,13 @@
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
 static void update_stream_signal(struct dc_stream_state *stream)
 {
-	if (stream->output_signal == SIGNAL_TYPE_NONE) {
-		struct dc_sink *dc_sink = stream->sink;
 
-		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-			stream->signal = stream->sink->link->connector_signal;
-		else
-			stream->signal = dc_sink->sink_signal;
-	} else {
-		stream->signal = stream->output_signal;
-	}
+	struct dc_sink *dc_sink = stream->sink;
+
+	if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
+		stream->signal = stream->sink->link->connector_signal;
+	else
+		stream->signal = dc_sink->sink_signal;
 
 	if (dc_is_dvi_signal(stream->signal)) {
 		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&

commit b3fb2b4e21a995c4fa511627088bd55b88f6be11
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 19:49:44 2017 -0500

    drm/amd/display: Fix hubp check in set_cursor_position
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_stream.c:298
    dc_stream_set_cursor_position() error: we previously assumed 'hubp'
    could be null (see line 294)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index b00a6040a697..e230cc44a0a7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -263,7 +263,6 @@ bool dc_stream_set_cursor_position(
 		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 		struct mem_input *mi = pipe_ctx->plane_res.mi;
 		struct hubp *hubp = pipe_ctx->plane_res.hubp;
-		struct transform *xfm = pipe_ctx->plane_res.xfm;
 		struct dpp *dpp = pipe_ctx->plane_res.dpp;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
@@ -294,11 +293,11 @@ bool dc_stream_set_cursor_position(
 		if (mi != NULL && mi->funcs->set_cursor_position != NULL)
 			mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
 
-		if (hubp != NULL && hubp->funcs->set_cursor_position != NULL)
-			hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
+		if (!hubp)
+			continue;
 
-		if (xfm != NULL && xfm->funcs->set_cursor_position != NULL)
-			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, hubp->curs_attr.width);
+		if (hubp->funcs->set_cursor_position != NULL)
+			hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
 
 		if (dpp != NULL && dpp->funcs->set_cursor_position != NULL)
 			dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width);

commit 82e9781053c8a6aa3515aea3ade76546afb4c082
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Oct 26 11:47:42 2017 +0530

    drm/amd/display: Fix formatting for null pointer dereference fix
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index de04b95e103a..b00a6040a697 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -288,7 +288,7 @@ bool dc_stream_set_cursor_position(
 			pos_cpy.enable = false;
 
 
-		if (ipp !=NULL && ipp->funcs->ipp_cursor_set_position != NULL)
+		if (ipp != NULL && ipp->funcs->ipp_cursor_set_position != NULL)
 			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
 
 		if (mi != NULL && mi->funcs->set_cursor_position != NULL)

commit bf5563ede9f254fba083c6b56e4ca8b836babb1d
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Nov 7 05:30:47 2017 +1000

    amdgpu/dc: fix indentation warning from smatch.
    
    This fixes all the current smatch:
    warn: inconsistent indenting
    
    Reviewed-by: Andrey Grodzovsky <andrey.grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 572b885195c7..de04b95e103a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -182,11 +182,11 @@ bool dc_stream_set_cursor_attributes(
 
 	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
-			return false;
+		return false;
 	}
 	if (NULL == attributes) {
 		dm_error("DC: attributes is NULL!\n");
-			return false;
+		return false;
 	}
 
 	if (attributes->address.quad_part == 0) {

commit 55d9038b0c680ec90e3a7d2440e717ac6a2a8064
Author: Shirish S <shirish.s@amd.com>
Date:   Thu Oct 26 11:47:42 2017 +0530

    drm/amd/display: fix null pointer dereference
    
    While setting cursor position in case of mpo,
    input_pixel_processor is not available for underlay,
    hence add check of the same to avoid null pointer
    access issue.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 5cf69af9693d..572b885195c7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -288,7 +288,7 @@ bool dc_stream_set_cursor_position(
 			pos_cpy.enable = false;
 
 
-		if (ipp->funcs->ipp_cursor_set_position != NULL)
+		if (ipp !=NULL && ipp->funcs->ipp_cursor_set_position != NULL)
 			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
 
 		if (mi != NULL && mi->funcs->set_cursor_position != NULL)

commit b0f8d4e963de8cd77c237a8ea37799f6f5ce995a
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Fri Oct 6 18:02:23 2017 -0400

    drm/amd/display: Don't set cursor address is 0 logging as errors
    
    This actually happens quite a bit, and having it as an error causes
    false positive messages when running tests.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 97f040a25820..5cf69af9693d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -190,7 +190,7 @@ bool dc_stream_set_cursor_attributes(
 	}
 
 	if (attributes->address.quad_part == 0) {
-		dm_error("DC: Cursor address is 0!\n");
+		dm_output_to_console("DC: Cursor address is 0!\n");
 		return false;
 	}
 

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 10421ea31373..97f040a25820 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -200,7 +200,7 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.xfm)
+		if (pipe_ctx->stream != stream || (!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
@@ -221,9 +221,15 @@ bool dc_stream_set_cursor_attributes(
 					pipe_ctx->plane_res.mi, attributes);
 
 
-		if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
+		if (pipe_ctx->plane_res.xfm != NULL &&
+				pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
 				pipe_ctx->plane_res.xfm, attributes);
+
+		if (pipe_ctx->plane_res.dpp != NULL &&
+				pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes != NULL)
+			pipe_ctx->plane_res.dpp->funcs->set_cursor_attributes(
+				pipe_ctx->plane_res.dpp, attributes);
 	}
 
 	stream->cursor_attributes = *attributes;
@@ -258,6 +264,7 @@ bool dc_stream_set_cursor_position(
 		struct mem_input *mi = pipe_ctx->plane_res.mi;
 		struct hubp *hubp = pipe_ctx->plane_res.hubp;
 		struct transform *xfm = pipe_ctx->plane_res.xfm;
+		struct dpp *dpp = pipe_ctx->plane_res.dpp;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = stream->timing.pix_clk_khz,
@@ -270,7 +277,7 @@ bool dc_stream_set_cursor_position(
 		if (pipe_ctx->stream != stream ||
 				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
 				!pipe_ctx->plane_state ||
-				!pipe_ctx->plane_res.xfm)
+				(!pipe_ctx->plane_res.xfm && !pipe_ctx->plane_res.dpp))
 			continue;
 
 		if (pipe_ctx->plane_state->address.type
@@ -293,6 +300,9 @@ bool dc_stream_set_cursor_position(
 		if (xfm != NULL && xfm->funcs->set_cursor_position != NULL)
 			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, hubp->curs_attr.width);
 
+		if (dpp != NULL && dpp->funcs->set_cursor_position != NULL)
+			dpp->funcs->set_cursor_position(dpp, &pos_cpy, &param, hubp->curs_attr.width);
+
 	}
 
 	return true;

commit 39a4e6608f28586dee77daf8dc3af53e7829d2a8
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 17:57:35 2017 -0400

    drm/amd/display: add null check for cursor functions
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 411678736ed4..10421ea31373 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -210,11 +210,13 @@ bool dc_stream_set_cursor_attributes(
 			pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
 						pipe_ctx->plane_res.ipp, attributes);
 
-		if (pipe_ctx->plane_res.hubp != NULL)
+		if (pipe_ctx->plane_res.hubp != NULL &&
+				pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(
 					pipe_ctx->plane_res.hubp, attributes);
 
-		if (pipe_ctx->plane_res.mi != NULL)
+		if (pipe_ctx->plane_res.mi != NULL &&
+				pipe_ctx->plane_res.mi->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
 					pipe_ctx->plane_res.mi, attributes);
 
@@ -253,6 +255,7 @@ bool dc_stream_set_cursor_position(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
+		struct mem_input *mi = pipe_ctx->plane_res.mi;
 		struct hubp *hubp = pipe_ctx->plane_res.hubp;
 		struct transform *xfm = pipe_ctx->plane_res.xfm;
 		struct dc_cursor_position pos_cpy = *position;
@@ -281,10 +284,13 @@ bool dc_stream_set_cursor_position(
 		if (ipp->funcs->ipp_cursor_set_position != NULL)
 			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
 
-		if (hubp != NULL)
+		if (mi != NULL && mi->funcs->set_cursor_position != NULL)
+			mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
+
+		if (hubp != NULL && hubp->funcs->set_cursor_position != NULL)
 			hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
 
-		if (xfm != NULL)
+		if (xfm != NULL && xfm->funcs->set_cursor_position != NULL)
 			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, hubp->curs_attr.width);
 
 	}

commit 8feabd03d34e4555c119e69269dae28f52e0d86c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 2 14:39:42 2017 -0400

    drm/amd/display: rename struct mem_input to hubp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3dd44bef56eb..411678736ed4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -200,7 +200,7 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.mi || !pipe_ctx->plane_res.xfm)
+		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.xfm)
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
@@ -210,10 +210,15 @@ bool dc_stream_set_cursor_attributes(
 			pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
 						pipe_ctx->plane_res.ipp, attributes);
 
-		if (pipe_ctx->plane_res.mi->funcs->set_cursor_attributes != NULL)
+		if (pipe_ctx->plane_res.hubp != NULL)
+			pipe_ctx->plane_res.hubp->funcs->set_cursor_attributes(
+					pipe_ctx->plane_res.hubp, attributes);
+
+		if (pipe_ctx->plane_res.mi != NULL)
 			pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
 					pipe_ctx->plane_res.mi, attributes);
 
+
 		if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
 			pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
 				pipe_ctx->plane_res.xfm, attributes);
@@ -248,7 +253,7 @@ bool dc_stream_set_cursor_position(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
-		struct mem_input *mi = pipe_ctx->plane_res.mi;
+		struct hubp *hubp = pipe_ctx->plane_res.hubp;
 		struct transform *xfm = pipe_ctx->plane_res.xfm;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
@@ -260,7 +265,7 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->plane_res.mi ||
+				(!pipe_ctx->plane_res.mi  && !pipe_ctx->plane_res.hubp) ||
 				!pipe_ctx->plane_state ||
 				!pipe_ctx->plane_res.xfm)
 			continue;
@@ -276,11 +281,12 @@ bool dc_stream_set_cursor_position(
 		if (ipp->funcs->ipp_cursor_set_position != NULL)
 			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
 
-		if (mi->funcs->set_cursor_attributes != NULL)
-			mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
+		if (hubp != NULL)
+			hubp->funcs->set_cursor_position(hubp, &pos_cpy, &param);
+
+		if (xfm != NULL)
+			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, hubp->curs_attr.width);
 
-		if (xfm->funcs->set_cursor_attributes != NULL)
-			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, mi->curs_attr.width);
 	}
 
 	return true;

commit 067c878a220cbe6198b3cfdc7f372adab4762ad8
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 3 15:03:49 2017 -0400

    drm/amd/display: Fixed switching mode half screen gamma incorrect.
    
            Half screen gamma setting and cursor are incorrect
            when switching mode through win+p due to wrong programming
            gamma sequence (In case of bottom pipe, gamma and cursor are
            programmed before front end programmed, pipe is power gated).
    
            change:
            1. Cache curor attributes to stream
            2. Move set gamma and cursor inside front end
               programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index c19b478bcdc7..3dd44bef56eb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -173,7 +173,7 @@ struct dc_stream_status *dc_stream_get_status(
  * Update the cursor attributes and set cursor surface address
  */
 bool dc_stream_set_cursor_attributes(
-	const struct dc_stream_state *stream,
+	struct dc_stream_state *stream,
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
@@ -189,6 +189,11 @@ bool dc_stream_set_cursor_attributes(
 			return false;
 	}
 
+	if (attributes->address.quad_part == 0) {
+		dm_error("DC: Cursor address is 0!\n");
+		return false;
+	}
+
 	core_dc = stream->ctx->dc;
 	res_ctx = &core_dc->current_state->res_ctx;
 
@@ -214,6 +219,8 @@ bool dc_stream_set_cursor_attributes(
 				pipe_ctx->plane_res.xfm, attributes);
 	}
 
+	stream->cursor_attributes = *attributes;
+
 	return true;
 }
 

commit b87d78d6aa104b207ff588d2cfd13633c2385994
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Tue Sep 19 17:29:28 2017 -0400

    drm/amd/display: moving cursor functions from ipp to mem_input
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 23df7bc020d2..c19b478bcdc7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -195,13 +195,23 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.ipp)
+		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.mi || !pipe_ctx->plane_res.xfm)
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
 
-		pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
-				pipe_ctx->plane_res.ipp, attributes);
+
+		if (pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes != NULL)
+			pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
+						pipe_ctx->plane_res.ipp, attributes);
+
+		if (pipe_ctx->plane_res.mi->funcs->set_cursor_attributes != NULL)
+			pipe_ctx->plane_res.mi->funcs->set_cursor_attributes(
+					pipe_ctx->plane_res.mi, attributes);
+
+		if (pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes != NULL)
+			pipe_ctx->plane_res.xfm->funcs->set_cursor_attributes(
+				pipe_ctx->plane_res.xfm, attributes);
 	}
 
 	return true;
@@ -231,6 +241,8 @@ bool dc_stream_set_cursor_position(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
+		struct mem_input *mi = pipe_ctx->plane_res.mi;
+		struct transform *xfm = pipe_ctx->plane_res.xfm;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = stream->timing.pix_clk_khz,
@@ -241,7 +253,9 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->plane_res.ipp || !pipe_ctx->plane_state)
+				!pipe_ctx->plane_res.mi ||
+				!pipe_ctx->plane_state ||
+				!pipe_ctx->plane_res.xfm)
 			continue;
 
 		if (pipe_ctx->plane_state->address.type
@@ -251,7 +265,15 @@ bool dc_stream_set_cursor_position(
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			pos_cpy.enable = false;
 
-		ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
+
+		if (ipp->funcs->ipp_cursor_set_position != NULL)
+			ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
+
+		if (mi->funcs->set_cursor_attributes != NULL)
+			mi->funcs->set_cursor_position(mi, &pos_cpy, &param);
+
+		if (xfm->funcs->set_cursor_attributes != NULL)
+			xfm->funcs->set_cursor_position(xfm, &pos_cpy, &param, mi->curs_attr.width);
 	}
 
 	return true;

commit bfe0feb143151cce76411bb211c3eec0f6cff7ba
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:39:00 2017 +1000

    amdgpu/dc: convert dc_stream_state to kref.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a99196414255..23df7bc020d2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -118,20 +118,21 @@ static void destruct(struct dc_stream_state *stream)
 
 void dc_stream_retain(struct dc_stream_state *stream)
 {
-	ASSERT(atomic_read(&stream->ref_count) > 0);
-	atomic_inc(&stream->ref_count);
+	kref_get(&stream->refcount);
+}
+
+static void dc_stream_free(struct kref *kref)
+{
+	struct dc_stream_state *stream = container_of(kref, struct dc_stream_state, refcount);
+
+	destruct(stream);
+	kfree(stream);
 }
 
 void dc_stream_release(struct dc_stream_state *stream)
 {
 	if (stream != NULL) {
-		ASSERT(atomic_read(&stream->ref_count) > 0);
-		atomic_dec(&stream->ref_count);
-
-		if (atomic_read(&stream->ref_count) == 0) {
-			destruct(stream);
-			kfree(stream);
-		}
+		kref_put(&stream->refcount, dc_stream_free);
 	}
 }
 
@@ -149,10 +150,9 @@ struct dc_stream_state *dc_create_stream_for_sink(
 
 	construct(stream, sink);
 
-	atomic_inc(&stream->ref_count);
+	kref_init(&stream->refcount);
 
 	return stream;
-
 }
 
 struct dc_stream_status *dc_stream_get_status(

commit db6c3bdcfe2d810338f90a13d415d43dd98d342b
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:41 2017 +1000

    amdgpu: fixup construct to void paths on some more dc objects.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index d5da847ffad6..a99196414255 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -56,7 +56,7 @@ static void update_stream_signal(struct dc_stream_state *stream)
 	}
 }
 
-static bool construct(struct dc_stream_state *stream,
+static void construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
@@ -104,7 +104,6 @@ static bool construct(struct dc_stream_state *stream,
 	stream->status.link = stream->sink->link;
 
 	update_stream_signal(stream);
-	return true;
 }
 
 static void destruct(struct dc_stream_state *stream)
@@ -142,25 +141,18 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	struct dc_stream_state *stream;
 
 	if (sink == NULL)
-		goto alloc_fail;
+		return NULL;
 
 	stream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);
+	if (stream == NULL)
+		return NULL;
 
-	if (NULL == stream)
-		goto alloc_fail;
-
-	if (false == construct(stream, sink))
-			goto construct_fail;
+	construct(stream, sink);
 
 	atomic_inc(&stream->ref_count);
 
 	return stream;
 
-construct_fail:
-	kfree(stream);
-
-alloc_fail:
-	return NULL;
 }
 
 struct dc_stream_status *dc_stream_get_status(

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a421779093d9..d5da847ffad6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -131,7 +131,7 @@ void dc_stream_release(struct dc_stream_state *stream)
 
 		if (atomic_read(&stream->ref_count) == 0) {
 			destruct(stream);
-			dm_free(stream);
+			kfree(stream);
 		}
 	}
 }
@@ -144,7 +144,7 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	if (sink == NULL)
 		goto alloc_fail;
 
-	stream = dm_alloc(sizeof(struct dc_stream_state));
+	stream = kzalloc(sizeof(struct dc_stream_state), GFP_KERNEL);
 
 	if (NULL == stream)
 		goto alloc_fail;
@@ -157,7 +157,7 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	return stream;
 
 construct_fail:
-	dm_free(stream);
+	kfree(stream);
 
 alloc_fail:
 	return NULL;

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_state and
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 0e7cc293184e..a421779093d9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -169,10 +169,9 @@ struct dc_stream_status *dc_stream_get_status(
 	uint8_t i;
 	struct dc  *dc = stream->ctx->dc;
 
-	for (i = 0; i < dc->current_context->stream_count; i++) {
-		if (stream == dc->current_context->streams[i]) {
-			return &dc->current_context->stream_status[i];
-		}
+	for (i = 0; i < dc->current_state->stream_count; i++) {
+		if (stream == dc->current_state->streams[i])
+			return &dc->current_state->stream_status[i];
 	}
 
 	return NULL;
@@ -199,7 +198,7 @@ bool dc_stream_set_cursor_attributes(
 	}
 
 	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_context->res_ctx;
+	res_ctx = &core_dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -235,7 +234,7 @@ bool dc_stream_set_cursor_position(
 	}
 
 	core_dc = stream->ctx->dc;
-	res_ctx = &core_dc->current_context->res_ctx;
+	res_ctx = &core_dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
@@ -271,7 +270,7 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 	uint8_t i;
 	struct dc  *core_dc = stream->ctx->dc;
 	struct resource_context *res_ctx =
-		&core_dc->current_context->res_ctx;
+		&core_dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;
@@ -295,7 +294,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 	bool ret = false;
 	struct dc  *core_dc = stream->ctx->dc;
 	struct resource_context *res_ctx =
-		&core_dc->current_context->res_ctx;
+		&core_dc->current_state->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;

commit 96313f1b7a4b14c8e120564698aa3be709445324
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Thu Aug 24 16:03:02 2017 -0400

    drm/amd/display: Fix MST downstream display not light up regression
    
    The fix is for the scenario: MST+SST chain together, and hook up
    to the card.
    
    Regression: Per stream validate_context build v2
    Before dc_add_stream_to_ctx(), need to update/reset
    stream signal type to SIGNAL_TYPE_DISPLAY_PORT_MST. Otherwise,
    downstream device cannot be added to ctx due to the lack of signal
    type info (SIGNAL_TYPE_NONE).
    update_stream_signal() needs to be done after stream is created.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index aaa6d2326190..0e7cc293184e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -33,6 +33,28 @@
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
+#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
+static void update_stream_signal(struct dc_stream_state *stream)
+{
+	if (stream->output_signal == SIGNAL_TYPE_NONE) {
+		struct dc_sink *dc_sink = stream->sink;
+
+		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
+			stream->signal = stream->sink->link->connector_signal;
+		else
+			stream->signal = dc_sink->sink_signal;
+	} else {
+		stream->signal = stream->output_signal;
+	}
+
+	if (dc_is_dvi_signal(stream->signal)) {
+		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+		else
+			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
+	}
+}
 
 static bool construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
@@ -80,6 +102,8 @@ static bool construct(struct dc_stream_state *stream,
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
 	stream->status.link = stream->sink->link;
+
+	update_stream_signal(stream);
 	return true;
 }
 

commit f670af8a954ae09b1f4949421e5d300be66d1156
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Aug 17 14:57:27 2017 -0400

    drm/amd/display: Remove unnecessary assignemnt
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 5e4f7f08e3db..aaa6d2326190 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -41,7 +41,6 @@ static bool construct(struct dc_stream_state *stream,
 
 	stream->sink = dc_sink_data;
 	stream->ctx = stream->sink->ctx;
-	stream->sink = dc_sink_data;
 
 	dc_sink_retain(dc_sink_data);
 

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 47e407dab4a3..5e4f7f08e3db 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -144,7 +144,7 @@ struct dc_stream_status *dc_stream_get_status(
 	struct dc_stream_state *stream)
 {
 	uint8_t i;
-	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
+	struct dc  *dc = stream->ctx->dc;
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
 		if (stream == dc->current_context->streams[i]) {
@@ -163,7 +163,7 @@ bool dc_stream_set_cursor_attributes(
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
-	struct core_dc *core_dc;
+	struct dc  *core_dc;
 	struct resource_context *res_ctx;
 
 	if (NULL == stream) {
@@ -175,7 +175,7 @@ bool dc_stream_set_cursor_attributes(
 			return false;
 	}
 
-	core_dc = DC_TO_CORE(stream->ctx->dc);
+	core_dc = stream->ctx->dc;
 	res_ctx = &core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -198,7 +198,7 @@ bool dc_stream_set_cursor_position(
 	const struct dc_cursor_position *position)
 {
 	int i;
-	struct core_dc *core_dc;
+	struct dc  *core_dc;
 	struct resource_context *res_ctx;
 
 	if (NULL == stream) {
@@ -211,7 +211,7 @@ bool dc_stream_set_cursor_position(
 		return false;
 	}
 
-	core_dc = DC_TO_CORE(stream->ctx->dc);
+	core_dc = stream->ctx->dc;
 	res_ctx = &core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -246,7 +246,7 @@ bool dc_stream_set_cursor_position(
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;
-	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
+	struct dc  *core_dc = stream->ctx->dc;
 	struct resource_context *res_ctx =
 		&core_dc->current_context->res_ctx;
 
@@ -270,7 +270,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 {
 	uint8_t i;
 	bool ret = false;
-	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
+	struct dc  *core_dc = stream->ctx->dc;
 	struct resource_context *res_ctx =
 		&core_dc->current_context->res_ctx;
 

commit e8cd26434df0cd8d97f31aeb4399afcdc37fcfda
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Mon Jul 31 17:10:44 2017 -0400

    drm/amd/display: Use atomic types for ref_count
    
    Current ref_count inc/dec is not guarded by locks which leads to
    a raced condition where two threads try to access the variable
    at the same time. In this case, both might act on the same cached
    value and inc/dec from the same value, rather than inc/dec by 2.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 2de37fed12a5..47e407dab4a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -96,19 +96,17 @@ static void destruct(struct dc_stream_state *stream)
 
 void dc_stream_retain(struct dc_stream_state *stream)
 {
-
-	ASSERT(stream->ref_count > 0);
-	stream->ref_count++;
+	ASSERT(atomic_read(&stream->ref_count) > 0);
+	atomic_inc(&stream->ref_count);
 }
 
 void dc_stream_release(struct dc_stream_state *stream)
 {
-
 	if (stream != NULL) {
-		ASSERT(stream->ref_count > 0);
-		stream->ref_count--;
+		ASSERT(atomic_read(&stream->ref_count) > 0);
+		atomic_dec(&stream->ref_count);
 
-		if (stream->ref_count == 0) {
+		if (atomic_read(&stream->ref_count) == 0) {
 			destruct(stream);
 			dm_free(stream);
 		}
@@ -131,7 +129,7 @@ struct dc_stream_state *dc_create_stream_for_sink(
 	if (false == construct(stream, sink))
 			goto construct_fail;
 
-	stream->ref_count++;
+	atomic_inc(&stream->ref_count);
 
 	return stream;
 

commit 6b670fa965b620bf0131a0a339a388a0581bc466
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:59:26 2017 -0400

    drm/amd/display: Move TG to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->tg/pipes->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->tg->/ctx->stream_res\.tg->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->tg/pipe->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->tg/pipe_ctx->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.tg/pipe_ctx\[pipe_offset\]\.stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[i\]->tg/grouped_pipes\[i\]->stream_^Cs\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[0\]->tg/grouped_pipes\[0\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[1\]->tg/grouped_pipes\[1\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]->tg/pipe_ctx\[i\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx_old->tg/pipe_ctx_old->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_set\[j\]->tg/pipe_set\[j\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]\.tg/pipe_ctx\[i\]\.stream_res\.tg/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 10587896cc86..2de37fed12a5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -253,7 +253,7 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 		&core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		struct timing_generator *tg = res_ctx->pipe_ctx[i].tg;
+		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;
 
 		if (res_ctx->pipe_ctx[i].stream != stream)
 			continue;
@@ -277,7 +277,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 		&core_dc->current_context->res_ctx;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		struct timing_generator *tg = res_ctx->pipe_ctx[i].tg;
+		struct timing_generator *tg = res_ctx->pipe_ctx[i].stream_res.tg;
 
 		if (res_ctx->pipe_ctx[i].stream != stream)
 			continue;

commit 86a66c4eb7365c96230bca218634439f7b057306
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:55:55 2017 -0400

    drm/amd/display: Move mi, ipp, xfm to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.mi/\.plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->mi/->plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.ipp/\.plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->ipp/->plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.xfm/\.plane_res.xfm/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->xfm/->plane_res.xfm/g'
    
    To clean up bad renames:
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.ipps/\.ipps/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mpcc_cfg\.plane_res\.mi/mpcc_cfg\.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mi->plane_res\./mi->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/cfg->plane_res\./cfg->/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index ef3a7b83cebe..10587896cc86 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -183,13 +183,13 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream != stream || !pipe_ctx->ipp)
+		if (pipe_ctx->stream != stream || !pipe_ctx->plane_res.ipp)
 			continue;
 		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
 
-		pipe_ctx->ipp->funcs->ipp_cursor_set_attributes(
-				pipe_ctx->ipp, attributes);
+		pipe_ctx->plane_res.ipp->funcs->ipp_cursor_set_attributes(
+				pipe_ctx->plane_res.ipp, attributes);
 	}
 
 	return true;
@@ -218,7 +218,7 @@ bool dc_stream_set_cursor_position(
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
-		struct input_pixel_processor *ipp = pipe_ctx->ipp;
+		struct input_pixel_processor *ipp = pipe_ctx->plane_res.ipp;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = stream->timing.pix_clk_khz,
@@ -229,7 +229,7 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->ipp || !pipe_ctx->plane_state)
+				!pipe_ctx->plane_res.ipp || !pipe_ctx->plane_state)
 			continue;
 
 		if (pipe_ctx->plane_state->address.type

commit 6702a9ac53f88a373a9969b4dee292f4c5f023f5
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:51:21 2017 -0400

    drm/amd/display: Move scl_data to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.scl_data/\.plane_res.scl_data/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->scl_data/->plane_res.scl_data/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 2b6506822cca..ef3a7b83cebe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -223,9 +223,9 @@ bool dc_stream_set_cursor_position(
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = stream->timing.pix_clk_khz,
 			.ref_clk_khz = core_dc->res_pool->ref_clock_inKhz,
-			.viewport_x_start = pipe_ctx->scl_data.viewport.x,
-			.viewport_width = pipe_ctx->scl_data.viewport.width,
-			.h_scale_ratio = pipe_ctx->scl_data.ratios.horz
+			.viewport_x_start = pipe_ctx->plane_res.scl_data.viewport.x,
+			.viewport_width = pipe_ctx->plane_res.scl_data.viewport.width,
+			.h_scale_ratio = pipe_ctx->plane_res.scl_data.ratios.horz
 		};
 
 		if (pipe_ctx->stream != stream ||

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 7a87f38f2324..2b6506822cca 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -185,7 +185,7 @@ bool dc_stream_set_cursor_attributes(
 
 		if (pipe_ctx->stream != stream || !pipe_ctx->ipp)
 			continue;
-		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			continue;
 
 		pipe_ctx->ipp->funcs->ipp_cursor_set_attributes(
@@ -229,14 +229,14 @@ bool dc_stream_set_cursor_position(
 		};
 
 		if (pipe_ctx->stream != stream ||
-				!pipe_ctx->ipp || !pipe_ctx->surface)
+				!pipe_ctx->ipp || !pipe_ctx->plane_state)
 			continue;
 
-		if (pipe_ctx->surface->address.type
+		if (pipe_ctx->plane_state->address.type
 				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 			pos_cpy.enable = false;
 
-		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+		if (pipe_ctx->top_pipe && pipe_ctx->plane_state != pipe_ctx->top_pipe->plane_state)
 			pos_cpy.enable = false;
 
 		ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a77e1e80d7c2..7a87f38f2324 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -34,7 +34,7 @@
  * Private functions
  ******************************************************************************/
 
-static bool construct(struct dc_stream *stream,
+static bool construct(struct dc_stream_state *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
@@ -84,7 +84,7 @@ static bool construct(struct dc_stream *stream,
 	return true;
 }
 
-static void destruct(struct dc_stream *stream)
+static void destruct(struct dc_stream_state *stream)
 {
 	dc_sink_release(stream->sink);
 	if (stream->out_transfer_func != NULL) {
@@ -94,14 +94,14 @@ static void destruct(struct dc_stream *stream)
 	}
 }
 
-void dc_stream_retain(struct dc_stream *stream)
+void dc_stream_retain(struct dc_stream_state *stream)
 {
 
 	ASSERT(stream->ref_count > 0);
 	stream->ref_count++;
 }
 
-void dc_stream_release(struct dc_stream *stream)
+void dc_stream_release(struct dc_stream_state *stream)
 {
 
 	if (stream != NULL) {
@@ -115,15 +115,15 @@ void dc_stream_release(struct dc_stream *stream)
 	}
 }
 
-struct dc_stream *dc_create_stream_for_sink(
+struct dc_stream_state *dc_create_stream_for_sink(
 		struct dc_sink *sink)
 {
-	struct dc_stream *stream;
+	struct dc_stream_state *stream;
 
 	if (sink == NULL)
 		goto alloc_fail;
 
-	stream = dm_alloc(sizeof(struct dc_stream));
+	stream = dm_alloc(sizeof(struct dc_stream_state));
 
 	if (NULL == stream)
 		goto alloc_fail;
@@ -143,7 +143,7 @@ struct dc_stream *dc_create_stream_for_sink(
 }
 
 struct dc_stream_status *dc_stream_get_status(
-	struct dc_stream *stream)
+	struct dc_stream_state *stream)
 {
 	uint8_t i;
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
@@ -161,7 +161,7 @@ struct dc_stream_status *dc_stream_get_status(
  * Update the cursor attributes and set cursor surface address
  */
 bool dc_stream_set_cursor_attributes(
-	const struct dc_stream *stream,
+	const struct dc_stream_state *stream,
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
@@ -196,7 +196,7 @@ bool dc_stream_set_cursor_attributes(
 }
 
 bool dc_stream_set_cursor_position(
-	struct dc_stream *stream,
+	struct dc_stream_state *stream,
 	const struct dc_cursor_position *position)
 {
 	int i;
@@ -245,7 +245,7 @@ bool dc_stream_set_cursor_position(
 	return true;
 }
 
-uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream)
+uint32_t dc_stream_get_vblank_counter(const struct dc_stream_state *stream)
 {
 	uint8_t i;
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
@@ -264,7 +264,7 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream)
 	return 0;
 }
 
-bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
+bool dc_stream_get_scanoutpos(const struct dc_stream_state *stream,
 				  uint32_t *v_blank_start,
 				  uint32_t *v_blank_end,
 				  uint32_t *h_position,
@@ -297,7 +297,7 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
 
 
 void dc_stream_log(
-	const struct dc_stream *stream,
+	const struct dc_stream_state *stream,
 	struct dal_logger *dm_logger,
 	enum dc_log_type log_type)
 {

commit a989ab08a7e3ee4675ea56b5dcfd0f2966aa91db
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Wed Jul 26 16:13:48 2017 -0400

    drm/amd/display: Roll stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 46ad1bc12f63..a77e1e80d7c2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -30,17 +30,6 @@
 #include "ipp.h"
 #include "timing_generator.h"
 
-/*******************************************************************************
- * Private definitions
- ******************************************************************************/
-
-struct stream {
-	struct dc_stream protected;
-	int ref_count;
-};
-
-#define DC_STREAM_TO_STREAM(dc_stream) container_of(dc_stream, struct stream, protected)
-
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
@@ -105,24 +94,22 @@ static void destruct(struct dc_stream *stream)
 	}
 }
 
-void dc_stream_retain(struct dc_stream *dc_stream)
+void dc_stream_retain(struct dc_stream *stream)
 {
-	struct stream *stream = DC_STREAM_TO_STREAM(dc_stream);
 
 	ASSERT(stream->ref_count > 0);
 	stream->ref_count++;
 }
 
-void dc_stream_release(struct dc_stream *public)
+void dc_stream_release(struct dc_stream *stream)
 {
-	struct stream *stream = DC_STREAM_TO_STREAM(public);
 
-	if (public != NULL) {
+	if (stream != NULL) {
 		ASSERT(stream->ref_count > 0);
 		stream->ref_count--;
 
 		if (stream->ref_count == 0) {
-			destruct(public);
+			destruct(stream);
 			dm_free(stream);
 		}
 	}
@@ -131,22 +118,22 @@ void dc_stream_release(struct dc_stream *public)
 struct dc_stream *dc_create_stream_for_sink(
 		struct dc_sink *sink)
 {
-	struct stream *stream;
+	struct dc_stream *stream;
 
 	if (sink == NULL)
 		goto alloc_fail;
 
-	stream = dm_alloc(sizeof(struct stream));
+	stream = dm_alloc(sizeof(struct dc_stream));
 
 	if (NULL == stream)
 		goto alloc_fail;
 
-	if (false == construct(&stream->protected, sink))
+	if (false == construct(stream, sink))
 			goto construct_fail;
 
 	stream->ref_count++;
 
-	return &stream->protected;
+	return stream;
 
 construct_fail:
 	dm_free(stream);

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 5b356ddf5614..46ad1bc12f63 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -35,24 +35,24 @@
  ******************************************************************************/
 
 struct stream {
-	struct core_stream protected;
+	struct dc_stream protected;
 	int ref_count;
 };
 
-#define DC_STREAM_TO_STREAM(dc_stream) container_of(dc_stream, struct stream, protected.public)
+#define DC_STREAM_TO_STREAM(dc_stream) container_of(dc_stream, struct stream, protected)
 
 /*******************************************************************************
  * Private functions
  ******************************************************************************/
 
-static bool construct(struct core_stream *stream,
+static bool construct(struct dc_stream *stream,
 	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
 
 	stream->sink = dc_sink_data;
 	stream->ctx = stream->sink->ctx;
-	stream->public.sink = dc_sink_data;
+	stream->sink = dc_sink_data;
 
 	dc_sink_retain(dc_sink_data);
 
@@ -60,52 +60,52 @@ static bool construct(struct core_stream *stream,
 	/* TODO - Remove this translation */
 	for (i = 0; i < (dc_sink_data->edid_caps.audio_mode_count); i++)
 	{
-		stream->public.audio_info.modes[i].channel_count = dc_sink_data->edid_caps.audio_modes[i].channel_count;
-		stream->public.audio_info.modes[i].format_code = dc_sink_data->edid_caps.audio_modes[i].format_code;
-		stream->public.audio_info.modes[i].sample_rates.all = dc_sink_data->edid_caps.audio_modes[i].sample_rate;
-		stream->public.audio_info.modes[i].sample_size = dc_sink_data->edid_caps.audio_modes[i].sample_size;
+		stream->audio_info.modes[i].channel_count = dc_sink_data->edid_caps.audio_modes[i].channel_count;
+		stream->audio_info.modes[i].format_code = dc_sink_data->edid_caps.audio_modes[i].format_code;
+		stream->audio_info.modes[i].sample_rates.all = dc_sink_data->edid_caps.audio_modes[i].sample_rate;
+		stream->audio_info.modes[i].sample_size = dc_sink_data->edid_caps.audio_modes[i].sample_size;
 	}
-	stream->public.audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;
-	stream->public.audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;
-	stream->public.audio_info.video_latency = dc_sink_data->edid_caps.video_latency;
+	stream->audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;
+	stream->audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;
+	stream->audio_info.video_latency = dc_sink_data->edid_caps.video_latency;
 	memmove(
-		stream->public.audio_info.display_name,
+		stream->audio_info.display_name,
 		dc_sink_data->edid_caps.display_name,
 		AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);
-	stream->public.audio_info.manufacture_id = dc_sink_data->edid_caps.manufacturer_id;
-	stream->public.audio_info.product_id = dc_sink_data->edid_caps.product_id;
-	stream->public.audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;
+	stream->audio_info.manufacture_id = dc_sink_data->edid_caps.manufacturer_id;
+	stream->audio_info.product_id = dc_sink_data->edid_caps.product_id;
+	stream->audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;
 
 	if (dc_sink_data->dc_container_id != NULL) {
 		struct dc_container_id *dc_container_id = dc_sink_data->dc_container_id;
 
-		stream->public.audio_info.port_id[0] = dc_container_id->portId[0];
-		stream->public.audio_info.port_id[1] = dc_container_id->portId[1];
+		stream->audio_info.port_id[0] = dc_container_id->portId[0];
+		stream->audio_info.port_id[1] = dc_container_id->portId[1];
 	} else {
 		/* TODO - WindowDM has implemented,
 		other DMs need Unhardcode port_id */
-		stream->public.audio_info.port_id[0] = 0x5558859e;
-		stream->public.audio_info.port_id[1] = 0xd989449;
+		stream->audio_info.port_id[0] = 0x5558859e;
+		stream->audio_info.port_id[1] = 0xd989449;
 	}
 
 	/* EDID CAP translation for HDMI 2.0 */
-	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
+	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
 	stream->status.link = stream->sink->link;
 	return true;
 }
 
-static void destruct(struct core_stream *stream)
+static void destruct(struct dc_stream *stream)
 {
 	dc_sink_release(stream->sink);
-	if (stream->public.out_transfer_func != NULL) {
+	if (stream->out_transfer_func != NULL) {
 		dc_transfer_func_release(
-				stream->public.out_transfer_func);
-		stream->public.out_transfer_func = NULL;
+				stream->out_transfer_func);
+		stream->out_transfer_func = NULL;
 	}
 }
 
-void dc_stream_retain(const struct dc_stream *dc_stream)
+void dc_stream_retain(struct dc_stream *dc_stream)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(dc_stream);
 
@@ -113,17 +113,16 @@ void dc_stream_retain(const struct dc_stream *dc_stream)
 	stream->ref_count++;
 }
 
-void dc_stream_release(const struct dc_stream *public)
+void dc_stream_release(struct dc_stream *public)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(public);
-	struct core_stream *protected = DC_STREAM_TO_CORE(public);
 
 	if (public != NULL) {
 		ASSERT(stream->ref_count > 0);
 		stream->ref_count--;
 
 		if (stream->ref_count == 0) {
-			destruct(protected);
+			destruct(public);
 			dm_free(stream);
 		}
 	}
@@ -147,7 +146,7 @@ struct dc_stream *dc_create_stream_for_sink(
 
 	stream->ref_count++;
 
-	return &stream->protected.public;
+	return &stream->protected;
 
 construct_fail:
 	dm_free(stream);
@@ -157,10 +156,9 @@ struct dc_stream *dc_create_stream_for_sink(
 }
 
 struct dc_stream_status *dc_stream_get_status(
-	const struct dc_stream *dc_stream)
+	struct dc_stream *stream)
 {
 	uint8_t i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 
 	for (i = 0; i < dc->current_context->stream_count; i++) {
@@ -176,15 +174,14 @@ struct dc_stream_status *dc_stream_get_status(
  * Update the cursor attributes and set cursor surface address
  */
 bool dc_stream_set_cursor_attributes(
-	const struct dc_stream *dc_stream,
+	const struct dc_stream *stream,
 	const struct dc_cursor_attributes *attributes)
 {
 	int i;
-	struct core_stream *stream;
 	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
-	if (NULL == dc_stream) {
+	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
 			return false;
 	}
@@ -193,7 +190,6 @@ bool dc_stream_set_cursor_attributes(
 			return false;
 	}
 
-	stream = DC_STREAM_TO_CORE(dc_stream);
 	core_dc = DC_TO_CORE(stream->ctx->dc);
 	res_ctx = &core_dc->current_context->res_ctx;
 
@@ -213,15 +209,14 @@ bool dc_stream_set_cursor_attributes(
 }
 
 bool dc_stream_set_cursor_position(
-	const struct dc_stream *dc_stream,
+	struct dc_stream *stream,
 	const struct dc_cursor_position *position)
 {
 	int i;
-	struct core_stream *stream;
 	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
 
-	if (NULL == dc_stream) {
+	if (NULL == stream) {
 		dm_error("DC: dc_stream is NULL!\n");
 		return false;
 	}
@@ -231,7 +226,6 @@ bool dc_stream_set_cursor_position(
 		return false;
 	}
 
-	stream = DC_STREAM_TO_CORE(dc_stream);
 	core_dc = DC_TO_CORE(stream->ctx->dc);
 	res_ctx = &core_dc->current_context->res_ctx;
 
@@ -240,7 +234,7 @@ bool dc_stream_set_cursor_position(
 		struct input_pixel_processor *ipp = pipe_ctx->ipp;
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
-			.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
+			.pixel_clk_khz = stream->timing.pix_clk_khz,
 			.ref_clk_khz = core_dc->res_pool->ref_clock_inKhz,
 			.viewport_x_start = pipe_ctx->scl_data.viewport.x,
 			.viewport_width = pipe_ctx->scl_data.viewport.width,
@@ -264,10 +258,9 @@ bool dc_stream_set_cursor_position(
 	return true;
 }
 
-uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)
+uint32_t dc_stream_get_vblank_counter(const struct dc_stream *stream)
 {
 	uint8_t i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
 		&core_dc->current_context->res_ctx;
@@ -284,7 +277,7 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)
 	return 0;
 }
 
-bool dc_stream_get_scanoutpos(const struct dc_stream *dc_stream,
+bool dc_stream_get_scanoutpos(const struct dc_stream *stream,
 				  uint32_t *v_blank_start,
 				  uint32_t *v_blank_end,
 				  uint32_t *h_position,
@@ -292,7 +285,6 @@ bool dc_stream_get_scanoutpos(const struct dc_stream *dc_stream,
 {
 	uint8_t i;
 	bool ret = false;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
 		&core_dc->current_context->res_ctx;
@@ -322,37 +314,35 @@ void dc_stream_log(
 	struct dal_logger *dm_logger,
 	enum dc_log_type log_type)
 {
-	const struct core_stream *core_stream =
-		DC_STREAM_TO_CORE(stream);
 
 	dm_logger_write(dm_logger,
 			log_type,
 			"core_stream 0x%x: src: %d, %d, %d, %d; dst: %d, %d, %d, %d, colorSpace:%d\n",
-			core_stream,
-			core_stream->public.src.x,
-			core_stream->public.src.y,
-			core_stream->public.src.width,
-			core_stream->public.src.height,
-			core_stream->public.dst.x,
-			core_stream->public.dst.y,
-			core_stream->public.dst.width,
-			core_stream->public.dst.height,
-			core_stream->public.output_color_space);
+			stream,
+			stream->src.x,
+			stream->src.y,
+			stream->src.width,
+			stream->src.height,
+			stream->dst.x,
+			stream->dst.y,
+			stream->dst.width,
+			stream->dst.height,
+			stream->output_color_space);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tpix_clk_khz: %d, h_total: %d, v_total: %d, pixelencoder:%d, displaycolorDepth:%d\n",
-			core_stream->public.timing.pix_clk_khz,
-			core_stream->public.timing.h_total,
-			core_stream->public.timing.v_total,
-			core_stream->public.timing.pixel_encoding,
-			core_stream->public.timing.display_color_depth);
+			stream->timing.pix_clk_khz,
+			stream->timing.h_total,
+			stream->timing.v_total,
+			stream->timing.pixel_encoding,
+			stream->timing.display_color_depth);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tsink name: %s, serial: %d\n",
-			core_stream->sink->edid_caps.display_name,
-			core_stream->sink->edid_caps.serial_number);
+			stream->sink->edid_caps.display_name,
+			stream->sink->edid_caps.serial_number);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tlink: %d\n",
-			core_stream->sink->link->link_index);
+			stream->sink->link->link_index);
 }

commit b73a22d3257f9ec237c46be12d74b58d5a925d8c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 14:04:27 2017 -0400

    drm/amd/display: Roll core_sink into dc_sink
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index a329709de360..5b356ddf5614 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -46,11 +46,11 @@ struct stream {
  ******************************************************************************/
 
 static bool construct(struct core_stream *stream,
-	const struct dc_sink *dc_sink_data)
+	struct dc_sink *dc_sink_data)
 {
 	uint32_t i = 0;
 
-	stream->sink = DC_SINK_TO_CORE(dc_sink_data);
+	stream->sink = dc_sink_data;
 	stream->ctx = stream->sink->ctx;
 	stream->public.sink = dc_sink_data;
 
@@ -97,7 +97,7 @@ static bool construct(struct core_stream *stream,
 
 static void destruct(struct core_stream *stream)
 {
-	dc_sink_release(&stream->sink->public);
+	dc_sink_release(stream->sink);
 	if (stream->public.out_transfer_func != NULL) {
 		dc_transfer_func_release(
 				stream->public.out_transfer_func);
@@ -130,9 +130,8 @@ void dc_stream_release(const struct dc_stream *public)
 }
 
 struct dc_stream *dc_create_stream_for_sink(
-		const struct dc_sink *dc_sink)
+		struct dc_sink *sink)
 {
-	struct core_sink *sink = DC_SINK_TO_CORE(dc_sink);
 	struct stream *stream;
 
 	if (sink == NULL)
@@ -143,7 +142,7 @@ struct dc_stream *dc_create_stream_for_sink(
 	if (NULL == stream)
 		goto alloc_fail;
 
-	if (false == construct(&stream->protected, dc_sink))
+	if (false == construct(&stream->protected, sink))
 			goto construct_fail;
 
 	stream->ref_count++;
@@ -350,8 +349,8 @@ void dc_stream_log(
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tsink name: %s, serial: %d\n",
-			core_stream->sink->public.edid_caps.display_name,
-			core_stream->sink->public.edid_caps.serial_number);
+			core_stream->sink->edid_caps.display_name,
+			core_stream->sink->edid_caps.serial_number);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tlink: %d\n",

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 73712fd6f64a..a329709de360 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -91,7 +91,7 @@ static bool construct(struct core_stream *stream,
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
-	stream->status.link = &stream->sink->link->public;
+	stream->status.link = stream->sink->link;
 	return true;
 }
 
@@ -355,5 +355,5 @@ void dc_stream_log(
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tlink: %d\n",
-			core_stream->sink->link->public.link_index);
+			core_stream->sink->link->link_index);
 }

commit e12cfcb1d447cc937d1abc6f4aab8bbe5f88542e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 11:43:32 2017 -0400

    drm/amd/display: Roll core_surface into dc_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index ead7b63caab7..73712fd6f64a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -157,7 +157,7 @@ struct dc_stream *dc_create_stream_for_sink(
 	return NULL;
 }
 
-const struct dc_stream_status *dc_stream_get_status(
+struct dc_stream_status *dc_stream_get_status(
 	const struct dc_stream *dc_stream)
 {
 	uint8_t i;
@@ -252,7 +252,7 @@ bool dc_stream_set_cursor_position(
 				!pipe_ctx->ipp || !pipe_ctx->surface)
 			continue;
 
-		if (pipe_ctx->surface->public.address.type
+		if (pipe_ctx->surface->address.type
 				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
 			pos_cpy.enable = false;
 

commit e2c7bb1228bec5b1224b235e90ffa1def8e3900e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jun 28 13:23:04 2017 -0400

    drm/amd/display: Use validate_context from atomic_check in commit
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 4ba446de4d00..ead7b63caab7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -164,9 +164,11 @@ const struct dc_stream_status *dc_stream_get_status(
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
 
-	for (i = 0; i < dc->current_context->stream_count; i++)
-		if (stream == dc->current_context->streams[i])
+	for (i = 0; i < dc->current_context->stream_count; i++) {
+		if (stream == dc->current_context->streams[i]) {
 			return &dc->current_context->stream_status[i];
+		}
+	}
 
 	return NULL;
 }

commit cf4cde2b0b678ca1cf56d7b397c78b1bc3d3155b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Apr 28 09:56:08 2017 -0400

    drm/amd/display: Disable cursor on video surface.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 99b6a1695f26..4ba446de4d00 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -250,6 +250,10 @@ bool dc_stream_set_cursor_position(
 				!pipe_ctx->ipp || !pipe_ctx->surface)
 			continue;
 
+		if (pipe_ctx->surface->public.address.type
+				== PLN_ADDR_TYPE_VIDEO_PROGRESSIVE)
+			pos_cpy.enable = false;
+
 		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
 			pos_cpy.enable = false;
 

commit a2b8659db9b435853cb0dc78d225a492e7ee69d0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Apr 22 14:17:51 2017 -0400

    drm/amd/display: decouple resource_pool from resource_context
    
    to avoid null access in case res_ctx is used to access res_pool before it's fully constructed
    
    also make it clear which function has dependency on resource_pool
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 23627b14c16c..99b6a1695f26 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -240,7 +240,7 @@ bool dc_stream_set_cursor_position(
 		struct dc_cursor_position pos_cpy = *position;
 		struct dc_cursor_mi_param param = {
 			.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
-			.ref_clk_khz = res_ctx->pool->ref_clock_inKhz,
+			.ref_clk_khz = core_dc->res_pool->ref_clock_inKhz,
 			.viewport_x_start = pipe_ctx->scl_data.viewport.x,
 			.viewport_width = pipe_ctx->scl_data.viewport.width,
 			.h_scale_ratio = pipe_ctx->scl_data.ratios.horz

commit beb16b6a0f921f66472e4946a4955f07942fa9d8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Apr 21 09:34:09 2017 -0400

    drm/amd/display: improve cursor programming reliability
    
    This change will cache cursor attributes and reprogram them
    when enabling cursor after power gating if the attributes were not
    yet reprogrammed
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 3dbd6c0885d8..23627b14c16c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -182,7 +182,6 @@ bool dc_stream_set_cursor_attributes(
 	struct core_stream *stream;
 	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
-	bool ret = false;
 
 	if (NULL == dc_stream) {
 		dm_error("DC: dc_stream is NULL!\n");
@@ -200,28 +199,26 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if ((pipe_ctx->stream == stream) &&
-			(pipe_ctx->ipp != NULL)) {
-			struct input_pixel_processor *ipp = pipe_ctx->ipp;
+		if (pipe_ctx->stream != stream || !pipe_ctx->ipp)
+			continue;
+		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+			continue;
 
-			if (ipp->funcs->ipp_cursor_set_attributes(
-				ipp, attributes))
-				ret = true;
-		}
+		pipe_ctx->ipp->funcs->ipp_cursor_set_attributes(
+				pipe_ctx->ipp, attributes);
 	}
 
-	return ret;
+	return true;
 }
 
 bool dc_stream_set_cursor_position(
 	const struct dc_stream *dc_stream,
-	struct dc_cursor_position *position)
+	const struct dc_cursor_position *position)
 {
 	int i;
 	struct core_stream *stream;
 	struct core_dc *core_dc;
 	struct resource_context *res_ctx;
-	bool ret = false;
 
 	if (NULL == dc_stream) {
 		dm_error("DC: dc_stream is NULL!\n");
@@ -239,27 +236,27 @@ bool dc_stream_set_cursor_position(
 
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+		struct input_pixel_processor *ipp = pipe_ctx->ipp;
+		struct dc_cursor_position pos_cpy = *position;
+		struct dc_cursor_mi_param param = {
+			.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
+			.ref_clk_khz = res_ctx->pool->ref_clock_inKhz,
+			.viewport_x_start = pipe_ctx->scl_data.viewport.x,
+			.viewport_width = pipe_ctx->scl_data.viewport.width,
+			.h_scale_ratio = pipe_ctx->scl_data.ratios.horz
+		};
+
+		if (pipe_ctx->stream != stream ||
+				!pipe_ctx->ipp || !pipe_ctx->surface)
+			continue;
 
-		if (pipe_ctx->stream == stream &&
-				pipe_ctx->ipp && pipe_ctx->surface) {
-			struct input_pixel_processor *ipp = pipe_ctx->ipp;
-			struct dc_cursor_mi_param param = {
-				.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
-				.ref_clk_khz = res_ctx->pool->ref_clock_inKhz,
-				.viewport_x_start = pipe_ctx->scl_data.viewport.x,
-				.viewport_width = pipe_ctx->scl_data.viewport.width,
-				.h_scale_ratio = pipe_ctx->scl_data.ratios.horz,
-			};
-
-			if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
-				position->enable = false;
-
-			ipp->funcs->ipp_cursor_set_position(ipp, position, &param);
-			ret = true;
-		}
+		if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+			pos_cpy.enable = false;
+
+		ipp->funcs->ipp_cursor_set_position(ipp, &pos_cpy, &param);
 	}
 
-	return ret;
+	return true;
 }
 
 uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)

commit 81c509633aa93442d58b895f773892b3e8d936cf
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Tue Apr 11 15:15:28 2017 -0400

    drm/amd/display: Parse scanline registers
    
    They could differ between ASIC generations
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index bf209f7bbf98..3dbd6c0885d8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -282,12 +282,14 @@ uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)
 	return 0;
 }
 
-uint32_t dc_stream_get_scanoutpos(
-		const struct dc_stream *dc_stream,
-		uint32_t *vbl,
-		uint32_t *position)
+bool dc_stream_get_scanoutpos(const struct dc_stream *dc_stream,
+				  uint32_t *v_blank_start,
+				  uint32_t *v_blank_end,
+				  uint32_t *h_position,
+				  uint32_t *v_position)
 {
 	uint8_t i;
+	bool ret = false;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
 	struct resource_context *res_ctx =
@@ -299,10 +301,17 @@ uint32_t dc_stream_get_scanoutpos(
 		if (res_ctx->pipe_ctx[i].stream != stream)
 			continue;
 
-		return tg->funcs->get_scanoutpos(tg, vbl, position);
+		tg->funcs->get_scanoutpos(tg,
+					  v_blank_start,
+					  v_blank_end,
+					  h_position,
+					  v_position);
+
+		ret = true;
+		break;
 	}
 
-	return 0;
+	return ret;
 }
 
 

commit dabb3979e1cdfddbc9121116cfcf69f01991e51d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Mar 27 09:59:38 2017 -0400

    drm/amd/display: Fix MPO exit and cursor issue.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 512a53bdc32f..bf209f7bbf98 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -215,7 +215,7 @@ bool dc_stream_set_cursor_attributes(
 
 bool dc_stream_set_cursor_position(
 	const struct dc_stream *dc_stream,
-	const struct dc_cursor_position *position)
+	struct dc_cursor_position *position)
 {
 	int i;
 	struct core_stream *stream;
@@ -251,6 +251,9 @@ bool dc_stream_set_cursor_position(
 				.h_scale_ratio = pipe_ctx->scl_data.ratios.horz,
 			};
 
+			if (pipe_ctx->top_pipe && pipe_ctx->surface != pipe_ctx->top_pipe->surface)
+				position->enable = false;
+
 			ipp->funcs->ipp_cursor_set_position(ipp, position, &param);
 			ret = true;
 		}

commit 8c8953139c4b8e1be14d0b1a53dc1fd607727b59
Author: xhdu <Duke.Du@amd.com>
Date:   Tue Mar 21 11:05:32 2017 -0400

    drm/amd/display: Add audio/video ContainerId implementation
    
    Leave hardcoded if no ContainerId provided by DM.
    
    Signed-off-by: Duke Du <Duke.Du@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index bafba1f13a1a..512a53bdc32f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -76,9 +76,17 @@ static bool construct(struct core_stream *stream,
 	stream->public.audio_info.product_id = dc_sink_data->edid_caps.product_id;
 	stream->public.audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;
 
-	/* TODO - Unhardcode port_id */
-	stream->public.audio_info.port_id[0] = 0x5558859e;
-	stream->public.audio_info.port_id[1] = 0xd989449;
+	if (dc_sink_data->dc_container_id != NULL) {
+		struct dc_container_id *dc_container_id = dc_sink_data->dc_container_id;
+
+		stream->public.audio_info.port_id[0] = dc_container_id->portId[0];
+		stream->public.audio_info.port_id[1] = dc_container_id->portId[1];
+	} else {
+		/* TODO - WindowDM has implemented,
+		other DMs need Unhardcode port_id */
+		stream->public.audio_info.port_id[0] = 0x5558859e;
+		stream->public.audio_info.port_id[1] = 0xd989449;
+	}
 
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;

commit 5ac3d3c9b79fb607fc25268c8dbd220ac14f5ac6
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Mar 3 13:44:35 2017 -0500

    drm/amd/display: move refclk from dc to resource_pool
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 365a19e5d11c..bafba1f13a1a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -237,7 +237,7 @@ bool dc_stream_set_cursor_position(
 			struct input_pixel_processor *ipp = pipe_ctx->ipp;
 			struct dc_cursor_mi_param param = {
 				.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
-				.ref_clk_khz = core_dc->ctx->ref_clock_inKhz,
+				.ref_clk_khz = res_ctx->pool->ref_clock_inKhz,
 				.viewport_x_start = pipe_ctx->scl_data.viewport.x,
 				.viewport_width = pipe_ctx->scl_data.viewport.width,
 				.h_scale_ratio = pipe_ctx->scl_data.ratios.horz,

commit e8c963d6d970220ab33f4197ab4dea18c1615e52
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Mar 2 21:18:03 2017 -0500

    drm/amd/display: refclock from bios firmwareInfoTable
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 4e1a933be021..365a19e5d11c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -237,7 +237,7 @@ bool dc_stream_set_cursor_position(
 			struct input_pixel_processor *ipp = pipe_ctx->ipp;
 			struct dc_cursor_mi_param param = {
 				.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
-				.ref_clk_khz = 48000,/*todo refclk*/
+				.ref_clk_khz = core_dc->ctx->ref_clock_inKhz,
 				.viewport_x_start = pipe_ctx->scl_data.viewport.x,
 				.viewport_width = pipe_ctx->scl_data.viewport.width,
 				.h_scale_ratio = pipe_ctx->scl_data.ratios.horz,

commit 4b679bc3cab09f2af44bd34dfc197939a4602aa8
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Feb 22 13:46:29 2017 -0500

    drm/amd/display: HDMI deep color mode audio issue
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index e1f579bcd789..4e1a933be021 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -305,7 +305,7 @@ void dc_stream_log(
 
 	dm_logger_write(dm_logger,
 			log_type,
-			"core_stream 0x%x: src: %d, %d, %d, %d; dst: %d, %d, %d, %d;\n",
+			"core_stream 0x%x: src: %d, %d, %d, %d; dst: %d, %d, %d, %d, colorSpace:%d\n",
 			core_stream,
 			core_stream->public.src.x,
 			core_stream->public.src.y,
@@ -314,13 +314,16 @@ void dc_stream_log(
 			core_stream->public.dst.x,
 			core_stream->public.dst.y,
 			core_stream->public.dst.width,
-			core_stream->public.dst.height);
+			core_stream->public.dst.height,
+			core_stream->public.output_color_space);
 	dm_logger_write(dm_logger,
 			log_type,
-			"\tpix_clk_khz: %d, h_total: %d, v_total: %d\n",
+			"\tpix_clk_khz: %d, h_total: %d, v_total: %d, pixelencoder:%d, displaycolorDepth:%d\n",
 			core_stream->public.timing.pix_clk_khz,
 			core_stream->public.timing.h_total,
-			core_stream->public.timing.v_total);
+			core_stream->public.timing.v_total,
+			core_stream->public.timing.pixel_encoding,
+			core_stream->public.timing.display_color_depth);
 	dm_logger_write(dm_logger,
 			log_type,
 			"\tsink name: %s, serial: %d\n",

commit 0be06fc29b31d92a22180deaf866ad5f97133a9e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jan 19 17:54:39 2017 -0500

    drm/amd/display: prevent setting cursor position with no surface
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 47816c5ee0e0..e1f579bcd789 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -232,8 +232,8 @@ bool dc_stream_set_cursor_position(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if ((pipe_ctx->stream == stream) &&
-				(pipe_ctx->ipp != NULL)) {
+		if (pipe_ctx->stream == stream &&
+				pipe_ctx->ipp && pipe_ctx->surface) {
 			struct input_pixel_processor *ipp = pipe_ctx->ipp;
 			struct dc_cursor_mi_param param = {
 				.pixel_clk_khz = dc_stream->timing.pix_clk_khz,

commit cc0cb445ae56890a322abe2cc8df63b1ccab74fb
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Wed Jan 11 14:33:36 2017 -0500

    drm/amd/display: Fixing some fallout from dc_target removal
    
    Also avoid allocating memory dce110_set_output_transfer_func
    if not needed
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index bc1f387d1992..47816c5ee0e0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -192,7 +192,8 @@ bool dc_stream_set_cursor_attributes(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream == stream) {
+		if ((pipe_ctx->stream == stream) &&
+			(pipe_ctx->ipp != NULL)) {
 			struct input_pixel_processor *ipp = pipe_ctx->ipp;
 
 			if (ipp->funcs->ipp_cursor_set_attributes(
@@ -231,7 +232,8 @@ bool dc_stream_set_cursor_position(
 	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-		if (pipe_ctx->stream == stream) {
+		if ((pipe_ctx->stream == stream) &&
+				(pipe_ctx->ipp != NULL)) {
 			struct input_pixel_processor *ipp = pipe_ctx->ipp;
 			struct dc_cursor_mi_param param = {
 				.pixel_clk_khz = dc_stream->timing.pix_clk_khz,

commit ab2541b67395088b9de8ebf3943ef9ef86bccc41
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Thu Dec 29 15:27:12 2016 -0500

    drm/amd/display: Remove dc_target object
    
    dc_target does not fit well into DRM framework so removed it.
    This will prevent the driver from leveraging the pipe-split
    code for tiled displays, so will have to be handled at a higher
    level.  Most places that used dc_target now directly use dc_stream
    instead.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index cda67a78dbfd..bc1f387d1992 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -27,6 +27,8 @@
 #include "dc.h"
 #include "core_types.h"
 #include "resource.h"
+#include "ipp.h"
+#include "timing_generator.h"
 
 /*******************************************************************************
  * Private definitions
@@ -146,3 +148,184 @@ struct dc_stream *dc_create_stream_for_sink(
 alloc_fail:
 	return NULL;
 }
+
+const struct dc_stream_status *dc_stream_get_status(
+	const struct dc_stream *dc_stream)
+{
+	uint8_t i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	struct core_dc *dc = DC_TO_CORE(stream->ctx->dc);
+
+	for (i = 0; i < dc->current_context->stream_count; i++)
+		if (stream == dc->current_context->streams[i])
+			return &dc->current_context->stream_status[i];
+
+	return NULL;
+}
+
+/**
+ * Update the cursor attributes and set cursor surface address
+ */
+bool dc_stream_set_cursor_attributes(
+	const struct dc_stream *dc_stream,
+	const struct dc_cursor_attributes *attributes)
+{
+	int i;
+	struct core_stream *stream;
+	struct core_dc *core_dc;
+	struct resource_context *res_ctx;
+	bool ret = false;
+
+	if (NULL == dc_stream) {
+		dm_error("DC: dc_stream is NULL!\n");
+			return false;
+	}
+	if (NULL == attributes) {
+		dm_error("DC: attributes is NULL!\n");
+			return false;
+	}
+
+	stream = DC_STREAM_TO_CORE(dc_stream);
+	core_dc = DC_TO_CORE(stream->ctx->dc);
+	res_ctx = &core_dc->current_context->res_ctx;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->stream == stream) {
+			struct input_pixel_processor *ipp = pipe_ctx->ipp;
+
+			if (ipp->funcs->ipp_cursor_set_attributes(
+				ipp, attributes))
+				ret = true;
+		}
+	}
+
+	return ret;
+}
+
+bool dc_stream_set_cursor_position(
+	const struct dc_stream *dc_stream,
+	const struct dc_cursor_position *position)
+{
+	int i;
+	struct core_stream *stream;
+	struct core_dc *core_dc;
+	struct resource_context *res_ctx;
+	bool ret = false;
+
+	if (NULL == dc_stream) {
+		dm_error("DC: dc_stream is NULL!\n");
+		return false;
+	}
+
+	if (NULL == position) {
+		dm_error("DC: cursor position is NULL!\n");
+		return false;
+	}
+
+	stream = DC_STREAM_TO_CORE(dc_stream);
+	core_dc = DC_TO_CORE(stream->ctx->dc);
+	res_ctx = &core_dc->current_context->res_ctx;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->stream == stream) {
+			struct input_pixel_processor *ipp = pipe_ctx->ipp;
+			struct dc_cursor_mi_param param = {
+				.pixel_clk_khz = dc_stream->timing.pix_clk_khz,
+				.ref_clk_khz = 48000,/*todo refclk*/
+				.viewport_x_start = pipe_ctx->scl_data.viewport.x,
+				.viewport_width = pipe_ctx->scl_data.viewport.width,
+				.h_scale_ratio = pipe_ctx->scl_data.ratios.horz,
+			};
+
+			ipp->funcs->ipp_cursor_set_position(ipp, position, &param);
+			ret = true;
+		}
+	}
+
+	return ret;
+}
+
+uint32_t dc_stream_get_vblank_counter(const struct dc_stream *dc_stream)
+{
+	uint8_t i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
+	struct resource_context *res_ctx =
+		&core_dc->current_context->res_ctx;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct timing_generator *tg = res_ctx->pipe_ctx[i].tg;
+
+		if (res_ctx->pipe_ctx[i].stream != stream)
+			continue;
+
+		return tg->funcs->get_frame_count(tg);
+	}
+
+	return 0;
+}
+
+uint32_t dc_stream_get_scanoutpos(
+		const struct dc_stream *dc_stream,
+		uint32_t *vbl,
+		uint32_t *position)
+{
+	uint8_t i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
+	struct core_dc *core_dc = DC_TO_CORE(stream->ctx->dc);
+	struct resource_context *res_ctx =
+		&core_dc->current_context->res_ctx;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		struct timing_generator *tg = res_ctx->pipe_ctx[i].tg;
+
+		if (res_ctx->pipe_ctx[i].stream != stream)
+			continue;
+
+		return tg->funcs->get_scanoutpos(tg, vbl, position);
+	}
+
+	return 0;
+}
+
+
+void dc_stream_log(
+	const struct dc_stream *stream,
+	struct dal_logger *dm_logger,
+	enum dc_log_type log_type)
+{
+	const struct core_stream *core_stream =
+		DC_STREAM_TO_CORE(stream);
+
+	dm_logger_write(dm_logger,
+			log_type,
+			"core_stream 0x%x: src: %d, %d, %d, %d; dst: %d, %d, %d, %d;\n",
+			core_stream,
+			core_stream->public.src.x,
+			core_stream->public.src.y,
+			core_stream->public.src.width,
+			core_stream->public.src.height,
+			core_stream->public.dst.x,
+			core_stream->public.dst.y,
+			core_stream->public.dst.width,
+			core_stream->public.dst.height);
+	dm_logger_write(dm_logger,
+			log_type,
+			"\tpix_clk_khz: %d, h_total: %d, v_total: %d\n",
+			core_stream->public.timing.pix_clk_khz,
+			core_stream->public.timing.h_total,
+			core_stream->public.timing.v_total);
+	dm_logger_write(dm_logger,
+			log_type,
+			"\tsink name: %s, serial: %d\n",
+			core_stream->sink->public.edid_caps.display_name,
+			core_stream->sink->public.edid_caps.serial_number);
+	dm_logger_write(dm_logger,
+			log_type,
+			"\tlink: %d\n",
+			core_stream->sink->link->public.link_index);
+}

commit 1646a6fe746d7e923774994d2020e1707dcda884
Author: Andrew Wong <andrew.wong1@amd.com>
Date:   Thu Dec 22 15:41:30 2016 -0500

    drm/amd/display: DAL3: HDR10 Infoframe encoding
    
    - Add HDR metadata struct
    - Add register programming calculations
    - Added HDR metadata to surface and update_surface
    - Add HDR info packet programming for DP port
    
    Signed-off-by: Andrew Wong <andrew.wong1@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 39a6124aa85f..cda67a78dbfd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -82,7 +82,6 @@ static bool construct(struct core_stream *stream,
 	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
 
 	stream->status.link = &stream->sink->link->public;
-
 	return true;
 }
 

commit db96c69ee78845c4f4cadea9fd282fb265253874
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Dec 20 18:01:30 2016 -0500

    drm/amd/display: Add refcount debug assert
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 84e3fbbe23ac..39a6124aa85f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -99,6 +99,8 @@ static void destruct(struct core_stream *stream)
 void dc_stream_retain(const struct dc_stream *dc_stream)
 {
 	struct stream *stream = DC_STREAM_TO_STREAM(dc_stream);
+
+	ASSERT(stream->ref_count > 0);
 	stream->ref_count++;
 }
 
@@ -108,6 +110,7 @@ void dc_stream_release(const struct dc_stream *public)
 	struct core_stream *protected = DC_STREAM_TO_CORE(public);
 
 	if (public != NULL) {
+		ASSERT(stream->ref_count > 0);
 		stream->ref_count--;
 
 		if (stream->ref_count == 0) {
@@ -134,7 +137,7 @@ struct dc_stream *dc_create_stream_for_sink(
 	if (false == construct(&stream->protected, dc_sink))
 			goto construct_fail;
 
-	dc_stream_retain(&stream->protected.public);
+	stream->ref_count++;
 
 	return &stream->protected.public;
 

commit 80bd20967261d9438dc814f3e6e904aea053163b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Dec 21 11:13:48 2016 -0500

    drm/amd/display: reset transfer_func to NULL on release
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 237436e22720..84e3fbbe23ac 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -89,9 +89,11 @@ static bool construct(struct core_stream *stream,
 static void destruct(struct core_stream *stream)
 {
 	dc_sink_release(&stream->sink->public);
-	if (stream->public.out_transfer_func != NULL)
+	if (stream->public.out_transfer_func != NULL) {
 		dc_transfer_func_release(
 				stream->public.out_transfer_func);
+		stream->public.out_transfer_func = NULL;
+	}
 }
 
 void dc_stream_retain(const struct dc_stream *dc_stream)

commit 90e508ba253c9e43711a7bf16230cdb13d0b1440
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Dec 15 12:09:46 2016 -0500

    drm/amd/display: Refactor output transfer function to stream
    
    Refactor part 3 - Moving output transfer function from surface to stream
    
    Split HWSS to program degamma and regamma separately.
    Degamma should be dependent on input transfer function.
    And Regamma should depend on the desired output transfer function.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 8d6aa607e1f5..237436e22720 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -89,6 +89,9 @@ static bool construct(struct core_stream *stream,
 static void destruct(struct core_stream *stream)
 {
 	dc_sink_release(&stream->sink->public);
+	if (stream->public.out_transfer_func != NULL)
+		dc_transfer_func_release(
+				stream->public.out_transfer_func);
 }
 
 void dc_stream_retain(const struct dc_stream *dc_stream)

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
new file mode 100644
index 000000000000..8d6aa607e1f5
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dm_services.h"
+#include "dc.h"
+#include "core_types.h"
+#include "resource.h"
+
+/*******************************************************************************
+ * Private definitions
+ ******************************************************************************/
+
+struct stream {
+	struct core_stream protected;
+	int ref_count;
+};
+
+#define DC_STREAM_TO_STREAM(dc_stream) container_of(dc_stream, struct stream, protected.public)
+
+/*******************************************************************************
+ * Private functions
+ ******************************************************************************/
+
+static bool construct(struct core_stream *stream,
+	const struct dc_sink *dc_sink_data)
+{
+	uint32_t i = 0;
+
+	stream->sink = DC_SINK_TO_CORE(dc_sink_data);
+	stream->ctx = stream->sink->ctx;
+	stream->public.sink = dc_sink_data;
+
+	dc_sink_retain(dc_sink_data);
+
+	/* Copy audio modes */
+	/* TODO - Remove this translation */
+	for (i = 0; i < (dc_sink_data->edid_caps.audio_mode_count); i++)
+	{
+		stream->public.audio_info.modes[i].channel_count = dc_sink_data->edid_caps.audio_modes[i].channel_count;
+		stream->public.audio_info.modes[i].format_code = dc_sink_data->edid_caps.audio_modes[i].format_code;
+		stream->public.audio_info.modes[i].sample_rates.all = dc_sink_data->edid_caps.audio_modes[i].sample_rate;
+		stream->public.audio_info.modes[i].sample_size = dc_sink_data->edid_caps.audio_modes[i].sample_size;
+	}
+	stream->public.audio_info.mode_count = dc_sink_data->edid_caps.audio_mode_count;
+	stream->public.audio_info.audio_latency = dc_sink_data->edid_caps.audio_latency;
+	stream->public.audio_info.video_latency = dc_sink_data->edid_caps.video_latency;
+	memmove(
+		stream->public.audio_info.display_name,
+		dc_sink_data->edid_caps.display_name,
+		AUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);
+	stream->public.audio_info.manufacture_id = dc_sink_data->edid_caps.manufacturer_id;
+	stream->public.audio_info.product_id = dc_sink_data->edid_caps.product_id;
+	stream->public.audio_info.flags.all = dc_sink_data->edid_caps.speaker_flags;
+
+	/* TODO - Unhardcode port_id */
+	stream->public.audio_info.port_id[0] = 0x5558859e;
+	stream->public.audio_info.port_id[1] = 0xd989449;
+
+	/* EDID CAP translation for HDMI 2.0 */
+	stream->public.timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
+
+	stream->status.link = &stream->sink->link->public;
+
+	return true;
+}
+
+static void destruct(struct core_stream *stream)
+{
+	dc_sink_release(&stream->sink->public);
+}
+
+void dc_stream_retain(const struct dc_stream *dc_stream)
+{
+	struct stream *stream = DC_STREAM_TO_STREAM(dc_stream);
+	stream->ref_count++;
+}
+
+void dc_stream_release(const struct dc_stream *public)
+{
+	struct stream *stream = DC_STREAM_TO_STREAM(public);
+	struct core_stream *protected = DC_STREAM_TO_CORE(public);
+
+	if (public != NULL) {
+		stream->ref_count--;
+
+		if (stream->ref_count == 0) {
+			destruct(protected);
+			dm_free(stream);
+		}
+	}
+}
+
+struct dc_stream *dc_create_stream_for_sink(
+		const struct dc_sink *dc_sink)
+{
+	struct core_sink *sink = DC_SINK_TO_CORE(dc_sink);
+	struct stream *stream;
+
+	if (sink == NULL)
+		goto alloc_fail;
+
+	stream = dm_alloc(sizeof(struct stream));
+
+	if (NULL == stream)
+		goto alloc_fail;
+
+	if (false == construct(&stream->protected, dc_sink))
+			goto construct_fail;
+
+	dc_stream_retain(&stream->protected.public);
+
+	return &stream->protected.public;
+
+construct_fail:
+	dm_free(stream);
+
+alloc_fail:
+	return NULL;
+}
