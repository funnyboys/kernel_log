commit 570bc18c2966b05f556bedca24245a497db5ed13
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 27 14:55:08 2020 -0400

    drm/amd/display: fix and simplify pipe split logic
    
    Current odm/mpc combine logic to detect which pipes need to split
    logically is flawed leading to incorrect pipe merge/split operations
    being taken.
    
    This change cleans up the logic and fixes the logical errors.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index bbef8c67d1db..0c5619364e7d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -532,6 +532,24 @@ static inline void get_vp_scan_direction(
 		*flip_horz_scan_dir = !*flip_horz_scan_dir;
 }
 
+int get_num_mpc_splits(struct pipe_ctx *pipe)
+{
+	int mpc_split_count = 0;
+	struct pipe_ctx *other_pipe = pipe->bottom_pipe;
+
+	while (other_pipe && other_pipe->plane_state == pipe->plane_state) {
+		mpc_split_count++;
+		other_pipe = other_pipe->bottom_pipe;
+	}
+	other_pipe = pipe->top_pipe;
+	while (other_pipe && other_pipe->plane_state == pipe->plane_state) {
+		mpc_split_count++;
+		other_pipe = other_pipe->top_pipe;
+	}
+
+	return mpc_split_count;
+}
+
 int get_num_odm_splits(struct pipe_ctx *pipe)
 {
 	int odm_split_count = 0;
@@ -556,16 +574,11 @@ static void calculate_split_count_and_index(struct pipe_ctx *pipe_ctx, int *spli
 		/*Check for mpc split*/
 		struct pipe_ctx *split_pipe = pipe_ctx->top_pipe;
 
+		*split_count = get_num_mpc_splits(pipe_ctx);
 		while (split_pipe && split_pipe->plane_state == pipe_ctx->plane_state) {
 			(*split_idx)++;
-			(*split_count)++;
 			split_pipe = split_pipe->top_pipe;
 		}
-		split_pipe = pipe_ctx->bottom_pipe;
-		while (split_pipe && split_pipe->plane_state == pipe_ctx->plane_state) {
-			(*split_count)++;
-			split_pipe = split_pipe->bottom_pipe;
-		}
 	} else {
 		/*Get odm split index*/
 		struct pipe_ctx *split_pipe = pipe_ctx->prev_odm_pipe;

commit 14e49bb316789ceea35940b834c89ab54ec7b064
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Nov 28 14:14:56 2019 -0500

    drm/amd/display: Minimize DSC resource re-assignment
    
    [why]
    Assigning a different DSC resource than the one previosly used is
    currently not handled. This causes black screen on mode change when more
    than one monitor is connected on some ASICs.
    
    [how]
    - Acquire the previously used DSC if available
    - Make sure re-program is triggered if new DSC is used
    
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index cb5d11f11cad..bbef8c67d1db 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2666,6 +2666,9 @@ bool pipe_need_reprogram(
 		false == pipe_ctx_old->stream->dpms_off)
 		return true;
 
+	if (pipe_ctx_old->stream_res.dsc != pipe_ctx->stream_res.dsc)
+		return true;
+
 	return false;
 }
 

commit 8c076bc8d731ece31c7c932730c5581af50f47da
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Tue Apr 21 21:41:25 2020 -0400

    drm/amd/display: Mode change with same timing causing long display blank
    
    [Why]
    What a mode change is requested for the same timing a full stream reset
    can occur in some cases which causes monitor to blank for a few seconds.
    
    [How]
    Do not consider infoframe updates as needing a full stream reset as they
    will be handled on the first flip after a modeset when surface
    information is available.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1a01c038632b..cb5d11f11cad 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1547,35 +1547,6 @@ bool dc_add_all_planes_for_stream(
 	return add_all_planes_for_stream(dc, stream, &set, 1, context);
 }
 
-
-static bool is_hdr_static_meta_changed(struct dc_stream_state *cur_stream,
-	struct dc_stream_state *new_stream)
-{
-	if (cur_stream == NULL)
-		return true;
-
-	if (memcmp(&cur_stream->hdr_static_metadata,
-			&new_stream->hdr_static_metadata,
-			sizeof(struct dc_info_packet)) != 0)
-		return true;
-
-	return false;
-}
-
-static bool is_vsc_info_packet_changed(struct dc_stream_state *cur_stream,
-		struct dc_stream_state *new_stream)
-{
-	if (cur_stream == NULL)
-		return true;
-
-	if (memcmp(&cur_stream->vsc_infopacket,
-			&new_stream->vsc_infopacket,
-			sizeof(struct dc_info_packet)) != 0)
-		return true;
-
-	return false;
-}
-
 static bool is_timing_changed(struct dc_stream_state *cur_stream,
 		struct dc_stream_state *new_stream)
 {
@@ -1610,15 +1581,9 @@ static bool are_stream_backends_same(
 	if (is_timing_changed(stream_a, stream_b))
 		return false;
 
-	if (is_hdr_static_meta_changed(stream_a, stream_b))
-		return false;
-
 	if (stream_a->dpms_off != stream_b->dpms_off)
 		return false;
 
-	if (is_vsc_info_packet_changed(stream_a, stream_b))
-		return false;
-
 	return true;
 }
 
@@ -1758,21 +1723,6 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-bool resource_is_stream_unchanged(
-	struct dc_state *old_context, struct dc_stream_state *stream)
-{
-	int i;
-
-	for (i = 0; i < old_context->stream_count; i++) {
-		struct dc_stream_state *old_stream = old_context->streams[i];
-
-		if (are_stream_backends_same(old_stream, stream))
-				return true;
-	}
-
-	return false;
-}
-
 /**
  * dc_add_stream_to_ctx() - Add a new dc_stream_state to a dc_state.
  */
@@ -2027,17 +1977,6 @@ enum dc_status resource_map_pool_resources(
 	int pipe_idx = -1;
 	struct dc_bios *dcb = dc->ctx->dc_bios;
 
-	/* TODO Check if this is needed */
-	/*if (!resource_is_stream_unchanged(old_context, stream)) {
-			if (stream != NULL && old_context->streams[i] != NULL) {
-				stream->bit_depth_params =
-						old_context->streams[i]->bit_depth_params;
-				stream->clamping = old_context->streams[i]->clamping;
-				continue;
-			}
-		}
-	*/
-
 	calculate_phy_pix_clks(stream);
 
 	/* TODO: Check Linux */
@@ -2720,15 +2659,9 @@ bool pipe_need_reprogram(
 	if (is_timing_changed(pipe_ctx_old->stream, pipe_ctx->stream))
 		return true;
 
-	if (is_hdr_static_meta_changed(pipe_ctx_old->stream, pipe_ctx->stream))
-		return true;
-
 	if (pipe_ctx_old->stream->dpms_off != pipe_ctx->stream->dpms_off)
 		return true;
 
-	if (is_vsc_info_packet_changed(pipe_ctx_old->stream, pipe_ctx->stream))
-		return true;
-
 	if (false == pipe_ctx_old->stream->link->link_state_valid &&
 		false == pipe_ctx_old->stream->dpms_off)
 		return true;

commit 3a4837fb3c96aa6a0f017781a062687be4d6250b
Author: Sung Lee <sung.lee@amd.com>
Date:   Wed Apr 22 18:07:55 2020 -0400

    drm/amd/display: Change viewport limit to 12 for DCN2
    
    [WHY & HOW]
    Viewport limit was set to 16 pixels due to an issue with MPO
    on small viewports. This restriction does not apply and the
    viewport limit can now be lowered.
    
    Signed-off-by: Sung Lee <sung.lee@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 12f5c6881cd0..1a01c038632b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1064,8 +1064,8 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	calculate_viewport(pipe_ctx);
 
-	if (pipe_ctx->plane_res.scl_data.viewport.height < 16 ||
-		pipe_ctx->plane_res.scl_data.viewport.width < 16) {
+	if (pipe_ctx->plane_res.scl_data.viewport.height < 12 ||
+		pipe_ctx->plane_res.scl_data.viewport.width < 12) {
 		if (store_h_border_left) {
 			restore_border_left_from_dst(pipe_ctx,
 				store_h_border_left);

commit fa90219a129fd87bc2186caca79d2626fc1986a9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Sun Apr 5 16:41:02 2020 -0400

    drm/amd/display: fix dml pipe merge logic
    
    Dml merges mpc/odm combine pipes to do calculations. This merge is
    imperfect if there is a viewport overlap. This change saves pre overlap
    viewport for dml use.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7b32a34908c8..12f5c6881cd0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -692,6 +692,9 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	/* Round up, assume original video size always even dimensions */
 	data->viewport_c.width = (data->viewport.width + vpc_div - 1) / vpc_div;
 	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
+
+	data->viewport_unadjusted = data->viewport;
+	data->viewport_c_unadjusted = data->viewport_c;
 }
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx)

commit 5b5c1777bd3ce3ae3a448c8c8df3c724d1bfa9fe
Author: Josip Pavic <Josip.Pavic@amd.com>
Date:   Sun Apr 5 16:40:41 2020 -0400

    drm/amd/display: prevent loop from occuring in pipe list
    
    [Why]
    If no free pipes are available, acquire_first_split_pipe is called to
    get a pipe to use. This call may alter the ordering of the pipes in the
    list so that, for example, the tail pipe changes.
    
    If acquire_first_split_pipe returns the tail pipe, we'll have free_pipe
    == tail_pipe. What tail_pipe refers to is not the current tail_pipe, but
    what was previously the tail pipe - i.e. prior to the call to
    acquire_first_split_pipe
    
    The logic that follows will link free_pipe to the tail pipe, referring to
    the current tail pipe. However, since tail_pipe is cached from before the
    call to acquire_first_split_pipe, the wrong tail pipe will be used, and
    it will end up being linked to itself, creating a loop that, if traversed,
    will result in a soft hang.
    
    [How]
    Do not cache the tail pipe. Instead, check the tail pipe after the call to
    acquire_first_split_pipe is made.
    
    Signed-off-by: Josip Pavic <Josip.Pavic@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f4bcc71b2920..7b32a34908c8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1358,9 +1358,6 @@ bool dc_add_plane_to_context(
 	dc_plane_state_retain(plane_state);
 
 	while (head_pipe) {
-		tail_pipe = resource_get_tail_pipe(&context->res_ctx, head_pipe);
-		ASSERT(tail_pipe);
-
 		free_pipe = acquire_free_pipe_for_head(context, pool, head_pipe);
 
 	#if defined(CONFIG_DRM_AMD_DC_DCN)
@@ -1378,6 +1375,8 @@ bool dc_add_plane_to_context(
 		free_pipe->plane_state = plane_state;
 
 		if (head_pipe != free_pipe) {
+			tail_pipe = resource_get_tail_pipe(&context->res_ctx, head_pipe);
+			ASSERT(tail_pipe);
 			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
 			free_pipe->stream_res.abm = tail_pipe->stream_res.abm;
 			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;

commit 33eef72f8a781b227ba413c453c51e7703a1c481
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Fri Mar 6 17:07:12 2020 -0500

    drm/amd/display: Update function to get optimal number of taps
    
    [Why]
    Diagnostics scaling test failing to set required number of vertical taps
    in 4:2:0 surface case
    
    [How]
    In dpp3_get_optimal_number_of_taps() need to use LB_MEMORY_CONFIG_3 for
    4:2:0 surface case. In resource_build_scaling_params() make sure to also
    set plane res alpha enable based on updated surface state
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 75c7ce4c7581..f4bcc71b2920 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1077,6 +1077,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * on certain displays, such as the Sharp 4k
 	 */
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
+	pipe_ctx->plane_res.scl_data.lb_params.alpha_en = plane_state->per_pixel_alpha;
 
 	pipe_ctx->plane_res.scl_data.recout.x += timing->h_border_left;
 	pipe_ctx->plane_res.scl_data.recout.y += timing->v_border_top;

commit 7287a6757825de78799731480ecccbc7c85cf45b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jan 29 12:16:57 2020 -0500

    drm/amd/display: add on demand pipe merge logic for dcn2+
    
    Adds logic that will determine if pipes need merging during validation.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 3a1a5aef524d..75c7ce4c7581 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -893,6 +893,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 	bool orthogonal_rotation, flip_vert_scan_dir, flip_horz_scan_dir;
+	int odm_idx = 0;
 
 	/*
 	 * Need to calculate the scan direction for viewport to make adjustments
@@ -924,11 +925,13 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 					* stream->dst.width / stream->src.width -
 					src.x * plane_state->dst_rect.width / src.width
 					* stream->dst.width / stream->src.width);
-	/*modified recout_skip_h calculation due to odm having no recout offset caused by split*/
+	/*modified recout_skip_h calculation due to odm having no recout offset*/
 	while (odm_pipe) {
-		recout_skip_h += odm_pipe->plane_res.scl_data.recout.width + odm_pipe->plane_res.scl_data.recout.x;
+		odm_idx++;
 		odm_pipe = odm_pipe->prev_odm_pipe;
 	}
+	if (odm_idx)
+		recout_skip_h += odm_idx * data->recout.width;
 
 	recout_skip_v = data->recout.y - (stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
 					* stream->dst.height / stream->src.height -

commit 8d8c82b6998767e7d049820f5c03db1b2defe3af
Author: Joseph Gravenor <joseph.gravenor@amd.com>
Date:   Fri Feb 14 17:53:47 2020 -0500

    drm/amd/display: add worst case dcc meta pitch to fake plane
    
    [why]
    When we have single channel memory, we can not light up 2 4k displays
    with a 1080p edp, because we don't have enough bw by a small margin.
    this small margin comes from dcc meta being too large. We however don't
    have this dcc meta when we create fake planes so, before the flip we
    will not filter out the mode for 2 4k displays with a 1080p edp
    
    [how]
    Change get_default_swizzle_mode to something more general so we don't
    end up with a separate function for every missing field in the fake
    plane. Add a reasonable dcc meta to the fake plane when it is filled in,
    so we filter out modes that don't have enough bandwidth. To do this, we
    take the screen width and align it to 1024(8k 60)
    
    Signed-off-by: Joseph Gravenor <joseph.gravenor@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 572ce3842535..3a1a5aef524d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2171,10 +2171,10 @@ enum dc_status dc_validate_global_state(
 			if (pipe_ctx->stream != stream)
 				continue;
 
-			if (dc->res_pool->funcs->get_default_swizzle_mode &&
+			if (dc->res_pool->funcs->patch_unknown_plane_state &&
 					pipe_ctx->plane_state &&
 					pipe_ctx->plane_state->tiling_info.gfx9.swizzle == DC_SW_UNKNOWN) {
-				result = dc->res_pool->funcs->get_default_swizzle_mode(pipe_ctx->plane_state);
+				result = dc->res_pool->funcs->patch_unknown_plane_state(pipe_ctx->plane_state);
 				if (result != DC_OK)
 					return result;
 			}

commit 228a10d4e1b018ca777281de22276f291bd25a2f
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Feb 11 23:29:04 2020 -0500

    drm/amdgpu/display move get_num_odm_splits() into dc_resource.c
    
    It's used by more than just DCN2.0.  Fixes missing symbol when
    amdgpu is built without DCN support.
    
    Reviewed-by: Zhan Liu <zhan.liu@amd.com>
    Tested-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c02e5994d32b..572ce3842535 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -532,6 +532,22 @@ static inline void get_vp_scan_direction(
 		*flip_horz_scan_dir = !*flip_horz_scan_dir;
 }
 
+int get_num_odm_splits(struct pipe_ctx *pipe)
+{
+	int odm_split_count = 0;
+	struct pipe_ctx *next_pipe = pipe->next_odm_pipe;
+	while (next_pipe) {
+		odm_split_count++;
+		next_pipe = next_pipe->next_odm_pipe;
+	}
+	pipe = pipe->prev_odm_pipe;
+	while (pipe) {
+		odm_split_count++;
+		pipe = pipe->prev_odm_pipe;
+	}
+	return odm_split_count;
+}
+
 static void calculate_split_count_and_index(struct pipe_ctx *pipe_ctx, int *split_count, int *split_idx)
 {
 	*split_count = get_num_odm_splits(pipe_ctx);

commit cf2156e240bcb732536d9de60a9f30b9d92cf965
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Feb 11 23:22:04 2020 -0500

    drm/amdgpu/display: extend DCN guards
    
    to cover dcn2.x related headers.
    
    Reviewed-by: Zhan Liu <zhan.liu@amd.com>
    Tested-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a65a1e7820d6..c02e5994d32b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -46,12 +46,12 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
+#include "dce120/dce120_resource.h"
 #if defined(CONFIG_DRM_AMD_DC_DCN)
 #include "dcn10/dcn10_resource.h"
-#endif
 #include "dcn20/dcn20_resource.h"
 #include "dcn21/dcn21_resource.h"
-#include "dce120/dce120_resource.h"
+#endif
 
 #define DC_LOGGER_INIT(logger)
 

commit 5bf24270d1ccd94f0b6efcd7c96b98bf1faea893
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Dec 13 18:22:40 2019 -0500

    drm/amd/display: add odm split logic to scaling calculations
    
    Currently odm scaling calculations are only done when adding initial
    odm pipe. Any scaling re-calculations will mess up odm because of this.
    
    This change resolves the problem by updating scaling split logic to
    handle odm.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Michael Strauss <Michael.Strauss@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index cd80d8249d14..a65a1e7820d6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -532,6 +532,35 @@ static inline void get_vp_scan_direction(
 		*flip_horz_scan_dir = !*flip_horz_scan_dir;
 }
 
+static void calculate_split_count_and_index(struct pipe_ctx *pipe_ctx, int *split_count, int *split_idx)
+{
+	*split_count = get_num_odm_splits(pipe_ctx);
+	*split_idx = 0;
+	if (*split_count == 0) {
+		/*Check for mpc split*/
+		struct pipe_ctx *split_pipe = pipe_ctx->top_pipe;
+
+		while (split_pipe && split_pipe->plane_state == pipe_ctx->plane_state) {
+			(*split_idx)++;
+			(*split_count)++;
+			split_pipe = split_pipe->top_pipe;
+		}
+		split_pipe = pipe_ctx->bottom_pipe;
+		while (split_pipe && split_pipe->plane_state == pipe_ctx->plane_state) {
+			(*split_count)++;
+			split_pipe = split_pipe->bottom_pipe;
+		}
+	} else {
+		/*Get odm split index*/
+		struct pipe_ctx *split_pipe = pipe_ctx->prev_odm_pipe;
+
+		while (split_pipe) {
+			(*split_idx)++;
+			split_pipe = split_pipe->prev_odm_pipe;
+		}
+	}
+}
+
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -541,16 +570,16 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	struct rect clip, dest;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
-	bool pri_split = pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
-	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
+	int split_count = 0;
+	int split_idx = 0;
 	bool orthogonal_rotation, flip_y_start, flip_x_start;
 
+	calculate_split_count_and_index(pipe_ctx, &split_count, &split_idx);
+
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
-		pri_split = false;
-		sec_split = false;
+		split_count = 0;
+		split_idx = 0;
 	}
 
 	/* The actual clip is an intersection between stream
@@ -609,23 +638,32 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	data->viewport.height = clip.height * surf_src.height / dest.height;
 
 	/* Handle split */
-	if (pri_split || sec_split) {
+	if (split_count) {
+		/* extra pixels in the division remainder need to go to pipes after
+		 * the extra pixel index minus one(epimo) defined here as:
+		 */
+		int epimo = 0;
+
 		if (orthogonal_rotation) {
-			if (flip_y_start != pri_split)
-				data->viewport.height /= 2;
-			else {
-				data->viewport.y +=  data->viewport.height / 2;
-				/* Ceil offset pipe */
-				data->viewport.height = (data->viewport.height + 1) / 2;
-			}
+			if (flip_y_start)
+				split_idx = split_count - split_idx;
+
+			epimo = split_count - data->viewport.height % (split_count + 1);
+
+			data->viewport.y += (data->viewport.height / (split_count + 1)) * split_idx;
+			if (split_idx > epimo)
+				data->viewport.y += split_idx - epimo - 1;
+			data->viewport.height = data->viewport.height / (split_count + 1) + (split_idx > epimo ? 1 : 0);
 		} else {
-			if (flip_x_start != pri_split)
-				data->viewport.width /= 2;
-			else {
-				data->viewport.x +=  data->viewport.width / 2;
-				/* Ceil offset pipe */
-				data->viewport.width = (data->viewport.width + 1) / 2;
-			}
+			if (flip_x_start)
+				split_idx = split_count - split_idx;
+
+			epimo = split_count - data->viewport.width % (split_count + 1);
+
+			data->viewport.x += (data->viewport.width / (split_count + 1)) * split_idx;
+			if (split_idx > epimo)
+				data->viewport.x += split_idx - epimo - 1;
+			data->viewport.width = data->viewport.width / (split_count + 1) + (split_idx > epimo ? 1 : 0);
 		}
 	}
 
@@ -644,58 +682,58 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
+	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
 	struct rect surf_clip = plane_state->clip_rect;
-	bool pri_split = pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
-	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
-	bool top_bottom_split = stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM;
-
-	pipe_ctx->plane_res.scl_data.recout.x = stream->dst.x;
+	bool pri_split_tb = pipe_ctx->bottom_pipe &&
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state &&
+			stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM;
+	bool sec_split_tb = pipe_ctx->top_pipe &&
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state &&
+			stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM;
+	int split_count = 0;
+	int split_idx = 0;
+
+	calculate_split_count_and_index(pipe_ctx, &split_count, &split_idx);
+
+	data->recout.x = stream->dst.x;
 	if (stream->src.x < surf_clip.x)
-		pipe_ctx->plane_res.scl_data.recout.x += (surf_clip.x
-			- stream->src.x) * stream->dst.width
+		data->recout.x += (surf_clip.x - stream->src.x) * stream->dst.width
 						/ stream->src.width;
 
-	pipe_ctx->plane_res.scl_data.recout.width = surf_clip.width *
-			stream->dst.width / stream->src.width;
-	if (pipe_ctx->plane_res.scl_data.recout.width + pipe_ctx->plane_res.scl_data.recout.x >
-			stream->dst.x + stream->dst.width)
-		pipe_ctx->plane_res.scl_data.recout.width =
-			stream->dst.x + stream->dst.width
-						- pipe_ctx->plane_res.scl_data.recout.x;
+	data->recout.width = surf_clip.width * stream->dst.width / stream->src.width;
+	if (data->recout.width + data->recout.x > stream->dst.x + stream->dst.width)
+		data->recout.width = stream->dst.x + stream->dst.width - data->recout.x;
 
-	pipe_ctx->plane_res.scl_data.recout.y = stream->dst.y;
+	data->recout.y = stream->dst.y;
 	if (stream->src.y < surf_clip.y)
-		pipe_ctx->plane_res.scl_data.recout.y += (surf_clip.y
-			- stream->src.y) * stream->dst.height
+		data->recout.y += (surf_clip.y - stream->src.y) * stream->dst.height
 						/ stream->src.height;
 
-	pipe_ctx->plane_res.scl_data.recout.height = surf_clip.height *
-			stream->dst.height / stream->src.height;
-	if (pipe_ctx->plane_res.scl_data.recout.height + pipe_ctx->plane_res.scl_data.recout.y >
-			stream->dst.y + stream->dst.height)
-		pipe_ctx->plane_res.scl_data.recout.height =
-			stream->dst.y + stream->dst.height
-						- pipe_ctx->plane_res.scl_data.recout.y;
+	data->recout.height = surf_clip.height * stream->dst.height / stream->src.height;
+	if (data->recout.height + data->recout.y > stream->dst.y + stream->dst.height)
+		data->recout.height = stream->dst.y + stream->dst.height - data->recout.y;
 
 	/* Handle h & v split, handle rotation using viewport */
-	if (sec_split && top_bottom_split) {
-		pipe_ctx->plane_res.scl_data.recout.y +=
-				pipe_ctx->plane_res.scl_data.recout.height / 2;
+	if (sec_split_tb) {
+		data->recout.y += data->recout.height / 2;
 		/* Floor primary pipe, ceil 2ndary pipe */
-		pipe_ctx->plane_res.scl_data.recout.height =
-				(pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
-	} else if (pri_split && top_bottom_split)
-		pipe_ctx->plane_res.scl_data.recout.height /= 2;
-	else if (sec_split) {
-		pipe_ctx->plane_res.scl_data.recout.x +=
-				pipe_ctx->plane_res.scl_data.recout.width / 2;
-		/* Ceil offset pipe */
-		pipe_ctx->plane_res.scl_data.recout.width =
-				(pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
-	} else if (pri_split)
-		pipe_ctx->plane_res.scl_data.recout.width /= 2;
+		data->recout.height = (data->recout.height + 1) / 2;
+	} else if (pri_split_tb)
+		data->recout.height /= 2;
+	else if (split_count) {
+		/* extra pixels in the division remainder need to go to pipes after
+		 * the extra pixel index minus one(epimo) defined here as:
+		 */
+		int epimo = split_count - data->recout.width % (split_count + 1);
+
+		/*no recout offset due to odm */
+		if (!pipe_ctx->next_odm_pipe && !pipe_ctx->prev_odm_pipe) {
+			data->recout.x += (data->recout.width / (split_count + 1)) * split_idx;
+			if (split_idx > epimo)
+				data->recout.x += split_idx - epimo - 1;
+		}
+		data->recout.width = data->recout.width / (split_count + 1) + (split_idx > epimo ? 1 : 0);
+	}
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
@@ -832,6 +870,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
+	struct pipe_ctx *odm_pipe = pipe_ctx->prev_odm_pipe;
 	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
 	struct rect src = pipe_ctx->plane_state->src_rect;
 	int recout_skip_h, recout_skip_v, surf_size_h, surf_size_v;
@@ -869,6 +908,12 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 					* stream->dst.width / stream->src.width -
 					src.x * plane_state->dst_rect.width / src.width
 					* stream->dst.width / stream->src.width);
+	/*modified recout_skip_h calculation due to odm having no recout offset caused by split*/
+	while (odm_pipe) {
+		recout_skip_h += odm_pipe->plane_res.scl_data.recout.width + odm_pipe->plane_res.scl_data.recout.x;
+		odm_pipe = odm_pipe->prev_odm_pipe;
+	}
+
 	recout_skip_v = data->recout.y - (stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
 					* stream->dst.height / stream->src.height -
 					src.y * plane_state->dst_rect.height / src.height
@@ -1021,6 +1066,8 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 		store_h_border_left + timing->h_border_right;
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable +
 		timing->v_border_top + timing->v_border_bottom;
+	if (pipe_ctx->next_odm_pipe || pipe_ctx->prev_odm_pipe)
+		pipe_ctx->plane_res.scl_data.h_active /= get_num_odm_splits(pipe_ctx) + 1;
 
 	/* Taps calculations */
 	if (pipe_ctx->plane_res.xfm != NULL)

commit 3f0940f8691a295234ed25b94cafe0467af8a50b
Author: Charlene Liu <Charlene.Liu@amd.com>
Date:   Fri Jan 10 14:52:49 2020 -0500

    drm/amd/display: add stream_enc_inst for PSP HDCP inst use
    
    [why]
    new HW engine mapping requirment use in PSP
    [how]
    report stream_enc_inst
    
    Signed-off-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a0eb9e533a61..cd80d8249d14 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2034,7 +2034,7 @@ enum dc_status resource_map_pool_resources(
 	for (i = 0; i < context->stream_count; i++)
 		if (context->streams[i] == stream) {
 			context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
-			context->stream_status[i].stream_enc_inst = pipe_ctx->stream_res.stream_enc->id;
+			context->stream_status[i].stream_enc_inst = pipe_ctx->stream_res.stream_enc->stream_enc_inst;
 			context->stream_status[i].audio_inst =
 				pipe_ctx->stream_res.audio ? pipe_ctx->stream_res.audio->inst : -1;
 

commit 6d822156d0b6f529aa95d55286742c908f5b4e35
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Mon Dec 9 18:54:26 2019 -0500

    drm/amd/display: Disable secondary link for certain monitors
    
    [why]
    If the specific monitor supports DSC, the secondary link should be
    disabled, and the other way around, too: if either that monitor or
    our ASIC doesn't support DSC, the secodary link should be enabled.
    
    [how]
    Add a monitor patch and disable secondary link if that monitor
    is detected and if ASIC supports DSC, or otherwise enable secondary
    link.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Joshua Aberback <Joshua.Aberback@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 64a0e08fd019..a0eb9e533a61 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2066,6 +2066,13 @@ void dc_resource_state_construct(
 	dst_ctx->clk_mgr = dc->clk_mgr;
 }
 
+
+bool dc_resource_is_dsc_encoding_supported(const struct dc *dc)
+{
+	return dc->res_pool->res_cap->num_dsc > 0;
+}
+
+
 /**
  * dc_validate_global_state() - Determine if HW can support a given state
  * Checks HW resource availability and bandwidth requirement.
@@ -2897,6 +2904,3 @@ void get_audio_check(struct audio_info *aud_modes,
 	}
 }
 
-
-
-

commit 89d07b662f5e2d74c439f9a7cbefa41b3e76d745
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Thu Nov 28 15:55:01 2019 -0500

    drm/amd/display: fix 270 degree rotation for mixed-SLS mode
    
    [Why]
    When we rotate 270 in mixed SLS mode, the recouts occupy the
    right side of the display.  So all the recout_skip_v values
    are relative to the left side of the display.  This causes
    adjust_vp_and_init_for_seamless_clip() to incorrectly increase
    the data->viewport.height for that recout.  The rotation looks
    like the bottom half is duplicated twice.
    
    [How]
    recout.x values are being adjusted based on
    stream->timing.h_border_left.  Instead of using h_border_left,
    use dst.x to represent the border.  Shift dst.x by the amount of
    stream->timing.h_border_left and set
    stream->timing.h_border_left to 0.  Do all the calculations
    and then revert stream->timing.h_border_left and
    stream->dst.x back to their original values.
    When calculating pipe_ctx->plane_res.scl_data.h_active,
    make sure to use the original stream->timing.h_border_left
    value.
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 51e0f4472dbd..64a0e08fd019 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -940,11 +940,51 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 
 }
 
+/*
+ * When handling 270 rotation in mixed SLS mode, we have
+ * stream->timing.h_border_left that is non zero.  If we are doing
+ * pipe-splitting, this h_border_left value gets added to recout.x and when it
+ * calls calculate_inits_and_adj_vp() and
+ * adjust_vp_and_init_for_seamless_clip(), it can cause viewport.height for a
+ * pipe to be incorrect.
+ *
+ * To fix this, instead of using stream->timing.h_border_left, we can use
+ * stream->dst.x to represent the border instead.  So we will set h_border_left
+ * to 0 and shift the appropriate amount in stream->dst.x.  We will then
+ * perform all calculations in resource_build_scaling_params() based on this
+ * and then restore the h_border_left and stream->dst.x to their original
+ * values.
+ *
+ * shift_border_left_to_dst() will shift the amount of h_border_left to
+ * stream->dst.x and set h_border_left to 0.  restore_border_left_from_dst()
+ * will restore h_border_left and stream->dst.x back to their original values
+ * We also need to make sure pipe_ctx->plane_res.scl_data.h_active uses the
+ * original h_border_left value in its calculation.
+ */
+int shift_border_left_to_dst(struct pipe_ctx *pipe_ctx)
+{
+	int store_h_border_left = pipe_ctx->stream->timing.h_border_left;
+
+	if (store_h_border_left) {
+		pipe_ctx->stream->timing.h_border_left = 0;
+		pipe_ctx->stream->dst.x += store_h_border_left;
+	}
+	return store_h_border_left;
+}
+
+void restore_border_left_from_dst(struct pipe_ctx *pipe_ctx,
+                                  int store_h_border_left)
+{
+	pipe_ctx->stream->dst.x -= store_h_border_left;
+	pipe_ctx->stream->timing.h_border_left = store_h_border_left;
+}
+
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	bool res = false;
+	int store_h_border_left = shift_border_left_to_dst(pipe_ctx);
 	DC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
@@ -957,8 +997,14 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	calculate_viewport(pipe_ctx);
 
-	if (pipe_ctx->plane_res.scl_data.viewport.height < 16 || pipe_ctx->plane_res.scl_data.viewport.width < 16)
+	if (pipe_ctx->plane_res.scl_data.viewport.height < 16 ||
+		pipe_ctx->plane_res.scl_data.viewport.width < 16) {
+		if (store_h_border_left) {
+			restore_border_left_from_dst(pipe_ctx,
+				store_h_border_left);
+		}
 		return false;
+	}
 
 	calculate_recout(pipe_ctx);
 
@@ -971,8 +1017,10 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.recout.x += timing->h_border_left;
 	pipe_ctx->plane_res.scl_data.recout.y += timing->v_border_top;
 
-	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable + timing->h_border_left + timing->h_border_right;
-	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
+	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable +
+		store_h_border_left + timing->h_border_right;
+	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable +
+		timing->v_border_top + timing->v_border_bottom;
 
 	/* Taps calculations */
 	if (pipe_ctx->plane_res.xfm != NULL)
@@ -1019,6 +1067,9 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				plane_state->dst_rect.x,
 				plane_state->dst_rect.y);
 
+	if (store_h_border_left)
+		restore_border_left_from_dst(pipe_ctx, store_h_border_left);
+
 	return res;
 }
 

commit 74cc5f02eb67c1a725f6a11407990836f6f5ddd2
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Sat Nov 23 17:15:51 2019 -0500

    drm/amd/display: Remove integer scaling code from DC and fix cursor
    
    [Why]
    Scaling better handled by upper layers before pipe splitting.
    
    [How]
    Remove DC code for integer scaling and force cursor update if
    viewport or scaling changes occur to prevent underflow from
    invalid cursor position.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 594731182641..51e0f4472dbd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -940,48 +940,6 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 
 }
 
-static bool is_downscaled(const struct rect *src_rect, const struct rect *dst_rect)
-{
-        if (src_rect->width > dst_rect->width || src_rect->height > dst_rect->height)
-		return true;
-	return false;
-}
-
-static bool is_mpo(int layer_index)
-{
-	if (layer_index > 0)
-		return true;
-	return false;
-}
-
-static void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
-{
-	unsigned int integer_multiple = 1;
-
-	if (pipe_ctx->plane_state->scaling_quality.integer_scaling &&
-	    !is_downscaled(&pipe_ctx->plane_state->src_rect, &pipe_ctx->plane_state->dst_rect) &&
-	    !is_mpo(pipe_ctx->plane_state->layer_index)) {
-		// calculate maximum # of replication of src onto addressable
-		integer_multiple = min(
-				pipe_ctx->stream->timing.h_addressable / pipe_ctx->stream->src.width,
-				pipe_ctx->stream->timing.v_addressable  / pipe_ctx->stream->src.height);
-
-		//scale dst
-		pipe_ctx->stream->dst.width  = integer_multiple * pipe_ctx->stream->src.width;
-		pipe_ctx->stream->dst.height = integer_multiple * pipe_ctx->stream->src.height;
-
-		//center dst onto addressable
-		pipe_ctx->stream->dst.x = (pipe_ctx->stream->timing.h_addressable - pipe_ctx->stream->dst.width)/2;
-		pipe_ctx->stream->dst.y = (pipe_ctx->stream->timing.v_addressable - pipe_ctx->stream->dst.height)/2;
-
-		//We are guaranteed that we are scaling in integer ratio
-		pipe_ctx->plane_state->scaling_quality.v_taps = 1;
-		pipe_ctx->plane_state->scaling_quality.h_taps = 1;
-		pipe_ctx->plane_state->scaling_quality.v_taps_c = 1;
-		pipe_ctx->plane_state->scaling_quality.h_taps_c = 1;
-	}
-}
-
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -995,8 +953,6 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.format = convert_pixel_format_to_dalsurface(
 			pipe_ctx->plane_state->format);
 
-	calculate_integer_scaling(pipe_ctx);
-
 	calculate_scaling_ratios(pipe_ctx);
 
 	calculate_viewport(pipe_ctx);

commit ccce745c28d6cc7b42a50933fe4b751da0257598
Author: Martin Leung <martin.leung@amd.com>
Date:   Thu Nov 21 19:13:54 2019 -0500

    drm/amd/display: Enable Seamless Boot Transition for Multiple Streams
    
    [why]
    dc previously had bugs that interfered with the ability to inherit a
    timing from a device with multiple streams (without flash/blanking).
    After this fix there is still a dependency on UEFI support.
    
    [how]
    fixed 3 bugs: loaded MPC state, changed bw_optimize flag to a counter
    instead of a boolean, and reading dpp/disp clk from HW to ensure we
    don't raise the clock's when we're not supposed to.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4700c785566b..594731182641 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1910,8 +1910,26 @@ static int acquire_resource_from_hw_enabled_state(
 		pipe_ctx->plane_res.dpp = pool->dpps[tg_inst];
 		pipe_ctx->stream_res.opp = pool->opps[tg_inst];
 
-		if (pool->dpps[tg_inst])
+		if (pool->dpps[tg_inst]) {
 			pipe_ctx->plane_res.mpcc_inst = pool->dpps[tg_inst]->inst;
+
+			// Read DPP->MPCC->OPP Pipe from HW State
+			if (pool->mpc->funcs->read_mpcc_state) {
+				struct mpcc_state s = {0};
+
+				pool->mpc->funcs->read_mpcc_state(pool->mpc, pipe_ctx->plane_res.mpcc_inst, &s);
+
+				if (s.dpp_id < MAX_MPCC)
+					pool->mpc->mpcc_array[pipe_ctx->plane_res.mpcc_inst].dpp_id = s.dpp_id;
+
+				if (s.bot_mpcc_id < MAX_MPCC)
+					pool->mpc->mpcc_array[pipe_ctx->plane_res.mpcc_inst].mpcc_bot =
+							&pool->mpc->mpcc_array[s.bot_mpcc_id];
+
+				if (s.opp_id < MAX_OPP)
+					pipe_ctx->stream_res.opp->mpc_tree_params.opp_id = s.opp_id;
+			}
+		}
 		pipe_ctx->pipe_idx = tg_inst;
 
 		pipe_ctx->stream = stream;

commit 993dca3e53c30ed1c1c4b2c135904d1402fe034f
Author: Qingqing Zhuo <qingqing.zhuo@amd.com>
Date:   Thu Nov 21 14:06:32 2019 -0500

    drm/amd/display: AVI info package change due to spec update
    
    YQ should be limited range for all cases.
    
    Signed-off-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 39cc71bedf69..4700c785566b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2297,7 +2297,7 @@ static void set_avi_info_frame(
 		if (color_space == COLOR_SPACE_SRGB ||
 			color_space == COLOR_SPACE_2020_RGB_FULLRANGE) {
 			hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
-			hdmi_info.bits.YQ0_YQ1 = YYC_QUANTIZATION_FULL_RANGE;
+			hdmi_info.bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
 		} else if (color_space == COLOR_SPACE_SRGB_LIMITED ||
 					color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE) {
 			hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;

commit 663bfef0da610da5920df3b030d2aae8e4513baa
Author: Aidan Yang <Aidan.Yang@amd.com>
Date:   Wed Nov 20 11:05:36 2019 -0500

    drm/amd/display: Disable integerscaling for downscale and MPO
    
    [Why]
    Integer scaling is applied to MPO planes when downscaling,
    MPO planes use variable taps and integer scaling sets taps=1
    
    [How]
    Disable integer scaling on MPO planes,
    Disable integer scaling for downscaling planes
    
    Signed-off-by: Aidan Yang <Aidan.Yang@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6c6f5640234c..39cc71bedf69 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -940,11 +940,27 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 
 }
 
+static bool is_downscaled(const struct rect *src_rect, const struct rect *dst_rect)
+{
+        if (src_rect->width > dst_rect->width || src_rect->height > dst_rect->height)
+		return true;
+	return false;
+}
+
+static bool is_mpo(int layer_index)
+{
+	if (layer_index > 0)
+		return true;
+	return false;
+}
+
 static void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
 {
 	unsigned int integer_multiple = 1;
 
-	if (pipe_ctx->plane_state->scaling_quality.integer_scaling) {
+	if (pipe_ctx->plane_state->scaling_quality.integer_scaling &&
+	    !is_downscaled(&pipe_ctx->plane_state->src_rect, &pipe_ctx->plane_state->dst_rect) &&
+	    !is_mpo(pipe_ctx->plane_state->layer_index)) {
 		// calculate maximum # of replication of src onto addressable
 		integer_multiple = min(
 				pipe_ctx->stream->timing.h_addressable / pipe_ctx->stream->src.width,

commit 3ab4cc65b3e626c41edcbecce94d66f619cc200f
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Nov 8 21:52:27 2019 -0500

    drm/amd/display: HDMI 2.x audio bandwidth check
    
    Add HDMI 2.x audio bandwidth check
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0c19de678339..6c6f5640234c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2811,3 +2811,51 @@ unsigned int resource_pixel_format_to_bpp(enum surface_pixel_format format)
 		return -1;
 	}
 }
+static unsigned int get_max_audio_sample_rate(struct audio_mode *modes)
+{
+	if (modes) {
+		if (modes->sample_rates.rate.RATE_192)
+			return 192000;
+		if (modes->sample_rates.rate.RATE_176_4)
+			return 176400;
+		if (modes->sample_rates.rate.RATE_96)
+			return 96000;
+		if (modes->sample_rates.rate.RATE_88_2)
+			return 88200;
+		if (modes->sample_rates.rate.RATE_48)
+			return 48000;
+		if (modes->sample_rates.rate.RATE_44_1)
+			return 44100;
+		if (modes->sample_rates.rate.RATE_32)
+			return 32000;
+	}
+	/*original logic when no audio info*/
+	return 441000;
+}
+
+void get_audio_check(struct audio_info *aud_modes,
+	struct audio_check *audio_chk)
+{
+	unsigned int i;
+	unsigned int max_sample_rate = 0;
+
+	if (aud_modes) {
+		audio_chk->audio_packet_type = 0x2;/*audio sample packet AP = .25 for layout0, 1 for layout1*/
+
+		audio_chk->max_audiosample_rate = 0;
+		for (i = 0; i < aud_modes->mode_count; i++) {
+			max_sample_rate = get_max_audio_sample_rate(&aud_modes->modes[i]);
+			if (audio_chk->max_audiosample_rate < max_sample_rate)
+				audio_chk->max_audiosample_rate = max_sample_rate;
+			/*dts takes the same as type 2: AP = 0.25*/
+		}
+		/*check which one take more bandwidth*/
+		if (audio_chk->max_audiosample_rate > 192000)
+			audio_chk->audio_packet_type = 0x9;/*AP =1*/
+		audio_chk->acat = 0;/*not support*/
+	}
+}
+
+
+
+

commit 75441d9d35f71123933eafa4dd55459403582add
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Nov 12 13:58:32 2019 -0500

    drm/amd/display: Return a correct error value
    
    [why]
    The function is expected to return instance of the timing generator
    therefore we shouldn't be returning boolean in integer function,
    and we shouldn't be returning zero so changing it to -1.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Martin Leung <Martin.Leung@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a9412720c860..0c19de678339 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1866,7 +1866,7 @@ static int acquire_resource_from_hw_enabled_state(
 	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);
 
 	if (inst == ENGINE_ID_UNKNOWN)
-		return false;
+		return -1;
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i]->id == inst) {
@@ -1878,10 +1878,10 @@ static int acquire_resource_from_hw_enabled_state(
 
 	// tg_inst not found
 	if (i == pool->stream_enc_count)
-		return false;
+		return -1;
 
 	if (tg_inst >= pool->timing_generator_count)
-		return false;
+		return -1;
 
 	if (!res_ctx->pipe_ctx[tg_inst].stream) {
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[tg_inst];

commit 2b77dcc5e5aa382832af93a581de8293db72d888
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Nov 5 13:04:34 2019 -0500

    drm/amd/display: rename core_dc to dc
    
    [Why]
    First, to make code more consistent
    Second, to get rid of those scenario where we create a second
    local pointer to dc when it's already passed in.
    
    [How]
    Rename core_dc to dc
    Remove duplicate local pointers to dc
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 89b5f86cd40b..a9412720c860 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2747,9 +2747,8 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 
 enum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 {
-	struct dc  *core_dc = dc;
 	struct dc_link *link = stream->link;
-	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
+	struct timing_generator *tg = dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
 
 	calculate_phy_pix_clks(stream);

commit b86a1aa36a92bcfbc062c5e99c1d084f27f25bab
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:48:35 2019 -0500

    drm/amd/display: rename DCN1_0 kconfig to DCN
    
    Since dcn20 and dcn21 are under dcn1 it doesnt make sense to
    have it named dcn1.
    
    Change it to "dcn" to make it generic
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 162e512831b7..89b5f86cd40b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -46,7 +46,7 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dcn20/dcn20_resource.h"
@@ -95,7 +95,7 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 		else
 			dc_version = DCE_VERSION_12_0;
 		break;
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 	case FAMILY_RV:
 		dc_version = DCN_VERSION_1_0;
 		if (ASICREV_IS_RAVEN2(asic_id.hw_internal_rev))
@@ -154,7 +154,7 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 				init_data->num_virtual_links, dc);
 		break;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 	case DCN_VERSION_1_0:
 	case DCN_VERSION_1_01:
 		res_pool = dcn10_create_resource_pool(init_data, dc);
@@ -1192,7 +1192,7 @@ static struct pipe_ctx *acquire_free_pipe_for_head(
 	return pool->funcs->acquire_idle_pipe_for_layer(context, pool, head_pipe->stream);
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#if defined(CONFIG_DRM_AMD_DC_DCN)
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
@@ -1273,7 +1273,7 @@ bool dc_add_plane_to_context(
 
 		free_pipe = acquire_free_pipe_for_head(context, pool, head_pipe);
 
-	#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	#if defined(CONFIG_DRM_AMD_DC_DCN)
 		if (!free_pipe) {
 			int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 			if (pipe_idx >= 0)
@@ -1947,7 +1947,7 @@ enum dc_status resource_map_pool_resources(
 		/* acquire new resources */
 		pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_DRM_AMD_DC_DCN
 	if (pipe_idx < 0)
 		pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 #endif

commit aca935c7cc866a935a61769c9e9782dd834a8502
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:44:19 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_1 flag
    
    [Why]
    
    DCN21 is stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DCN2_1 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_1 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DCN2_1 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_1 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup Renoir definitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN21 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6e20c76b9933..162e512831b7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -50,9 +50,7 @@
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dcn20/dcn20_resource.h"
-#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
 #include "dcn21/dcn21_resource.h"
-#endif
 #include "dce120/dce120_resource.h"
 
 #define DC_LOGGER_INIT(logger)
@@ -102,10 +100,8 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 		dc_version = DCN_VERSION_1_0;
 		if (ASICREV_IS_RAVEN2(asic_id.hw_internal_rev))
 			dc_version = DCN_VERSION_1_01;
-#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
 		if (ASICREV_IS_RENOIR(asic_id.hw_internal_rev))
 			dc_version = DCN_VERSION_2_1;
-#endif
 		break;
 #endif
 
@@ -168,11 +164,9 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 	case DCN_VERSION_2_0:
 		res_pool = dcn20_create_resource_pool(init_data, dc);
 		break;
-#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
 	case DCN_VERSION_2_1:
 		res_pool = dcn21_create_resource_pool(init_data, dc);
 		break;
-#endif
 #endif
 
 	default:

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 30f5434fa8e9..6e20c76b9933 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -49,9 +49,7 @@
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "dcn10/dcn10_resource.h"
 #endif
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 #include "dcn20/dcn20_resource.h"
-#endif
 #if defined(CONFIG_DRM_AMD_DC_DCN2_1)
 #include "dcn21/dcn21_resource.h"
 #endif
@@ -111,11 +109,9 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 		break;
 #endif
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	case FAMILY_NV:
 		dc_version = DCN_VERSION_2_0;
 		break;
-#endif
 	default:
 		dc_version = DCE_VERSION_UNKNOWN;
 		break;
@@ -167,18 +163,16 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 	case DCN_VERSION_1_01:
 		res_pool = dcn10_create_resource_pool(init_data, dc);
 		break;
-#endif
 
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	case DCN_VERSION_2_0:
 		res_pool = dcn20_create_resource_pool(init_data, dc);
 		break;
-#endif
 #if defined(CONFIG_DRM_AMD_DC_DCN2_1)
 	case DCN_VERSION_2_1:
 		res_pool = dcn21_create_resource_pool(init_data, dc);
 		break;
+#endif
 #endif
 
 	default:

commit 00ada9d14f386305abfad73665d235882768c78f
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Thu Oct 17 16:40:02 2019 -0400

    drm/amd/display: Unify all scaling when Integer Scaling enabled
    
    [why]
    We want to guarantee integer ratio scaling for all scaling modes.
    
    [how]
    Treat centered, fullscreen, preserve aspect ratio the same: scale
    the view as many times as possible, and fill in the rest with a black
    border.
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 37698305a2dc..30f5434fa8e9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -951,25 +951,14 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 	data->inits.v_c_bot = dc_fixpt_add(data->inits.v_c, data->ratios.vert_c);
 
 }
-static bool are_rects_integer_multiples(struct rect src, struct rect dest)
-{
-	if (dest.width  >= src.width  && dest.width  % src.width  == 0 &&
-		dest.height >= src.height && dest.height % src.height == 0)
-		return true;
-
-	return false;
-}
 
 static void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
 {
-	if (!pipe_ctx->plane_state->scaling_quality.integer_scaling)
-		return;
+	unsigned int integer_multiple = 1;
 
-	//for Centered Mode
-	if (pipe_ctx->stream->dst.width  == pipe_ctx->stream->src.width &&
-		pipe_ctx->stream->dst.height == pipe_ctx->stream->src.height) {
+	if (pipe_ctx->plane_state->scaling_quality.integer_scaling) {
 		// calculate maximum # of replication of src onto addressable
-		unsigned int integer_multiple = min(
+		integer_multiple = min(
 				pipe_ctx->stream->timing.h_addressable / pipe_ctx->stream->src.width,
 				pipe_ctx->stream->timing.v_addressable  / pipe_ctx->stream->src.height);
 
@@ -980,10 +969,8 @@ static void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
 		//center dst onto addressable
 		pipe_ctx->stream->dst.x = (pipe_ctx->stream->timing.h_addressable - pipe_ctx->stream->dst.width)/2;
 		pipe_ctx->stream->dst.y = (pipe_ctx->stream->timing.v_addressable - pipe_ctx->stream->dst.height)/2;
-	}
 
-	//disable taps if src & dst are integer ratio
-	if (are_rects_integer_multiples(pipe_ctx->stream->src, pipe_ctx->stream->dst)) {
+		//We are guaranteed that we are scaling in integer ratio
 		pipe_ctx->plane_state->scaling_quality.v_taps = 1;
 		pipe_ctx->plane_state->scaling_quality.h_taps = 1;
 		pipe_ctx->plane_state->scaling_quality.v_taps_c = 1;

commit 4ef0b9d0a10eab55d36dc2f3ea316163c4addf8c
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon Oct 28 21:34:36 2019 +0800

    drm/amd/display: Make calculate_integer_scaling static
    
    Fix sparse warning:
    
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:963:6:
     warning: symbol 'calculate_integer_scaling' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 70e601a975df..37698305a2dc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -960,7 +960,7 @@ static bool are_rects_integer_multiples(struct rect src, struct rect dest)
 	return false;
 }
 
-void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
+static void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
 {
 	if (!pipe_ctx->plane_state->scaling_quality.integer_scaling)
 		return;

commit 3b733278ca6b51e3271eeb9fb8f46f32e374ab6a
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Mon Sep 30 10:11:24 2019 -0400

    drm/amd/display: Add center mode for integer scaling in DC
    
    [why]
    We want to use maximum space on display to show source
    
    [how]
    For Centered Mode: Replicate source as many times as possible to use
    maximum of display active space add borders.
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 8fe39fdefc27..70e601a975df 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -951,7 +951,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 	data->inits.v_c_bot = dc_fixpt_add(data->inits.v_c, data->ratios.vert_c);
 
 }
-static bool are_rect_integer_multiples(struct rect src, struct rect dest)
+static bool are_rects_integer_multiples(struct rect src, struct rect dest)
 {
 	if (dest.width  >= src.width  && dest.width  % src.width  == 0 &&
 		dest.height >= src.height && dest.height % src.height == 0)
@@ -959,6 +959,38 @@ static bool are_rect_integer_multiples(struct rect src, struct rect dest)
 
 	return false;
 }
+
+void calculate_integer_scaling(struct pipe_ctx *pipe_ctx)
+{
+	if (!pipe_ctx->plane_state->scaling_quality.integer_scaling)
+		return;
+
+	//for Centered Mode
+	if (pipe_ctx->stream->dst.width  == pipe_ctx->stream->src.width &&
+		pipe_ctx->stream->dst.height == pipe_ctx->stream->src.height) {
+		// calculate maximum # of replication of src onto addressable
+		unsigned int integer_multiple = min(
+				pipe_ctx->stream->timing.h_addressable / pipe_ctx->stream->src.width,
+				pipe_ctx->stream->timing.v_addressable  / pipe_ctx->stream->src.height);
+
+		//scale dst
+		pipe_ctx->stream->dst.width  = integer_multiple * pipe_ctx->stream->src.width;
+		pipe_ctx->stream->dst.height = integer_multiple * pipe_ctx->stream->src.height;
+
+		//center dst onto addressable
+		pipe_ctx->stream->dst.x = (pipe_ctx->stream->timing.h_addressable - pipe_ctx->stream->dst.width)/2;
+		pipe_ctx->stream->dst.y = (pipe_ctx->stream->timing.v_addressable - pipe_ctx->stream->dst.height)/2;
+	}
+
+	//disable taps if src & dst are integer ratio
+	if (are_rects_integer_multiples(pipe_ctx->stream->src, pipe_ctx->stream->dst)) {
+		pipe_ctx->plane_state->scaling_quality.v_taps = 1;
+		pipe_ctx->plane_state->scaling_quality.h_taps = 1;
+		pipe_ctx->plane_state->scaling_quality.v_taps_c = 1;
+		pipe_ctx->plane_state->scaling_quality.h_taps_c = 1;
+	}
+}
+
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -972,6 +1004,8 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.format = convert_pixel_format_to_dalsurface(
 			pipe_ctx->plane_state->format);
 
+	calculate_integer_scaling(pipe_ctx);
+
 	calculate_scaling_ratios(pipe_ctx);
 
 	calculate_viewport(pipe_ctx);
@@ -1002,13 +1036,6 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
 				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 
-	if (res &&
-	    plane_state->scaling_quality.integer_scaling &&
-	    are_rect_integer_multiples(pipe_ctx->plane_res.scl_data.viewport,
-				       pipe_ctx->plane_res.scl_data.recout)) {
-		pipe_ctx->plane_res.scl_data.taps.v_taps = 1;
-		pipe_ctx->plane_res.scl_data.taps.h_taps = 1;
-	}
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */

commit 0460f9abf275ef3cdab4c531bfa06e2552f5e1c3
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Thu Oct 3 15:09:53 2019 -0400

    drm/amd/display: do not synchronize "drr" displays
    
    [why]
    A display that supports DRR can never really be considered
    "synchronized" with any other display because we can dynamically
    enable DRR (i.e. without modeset).  this will cause their
    relative CRTC positions to drift and lose sync.  this will disrupt
    features such as MCLK switching that assume and depend on
    their permanent alignment (that can only change with modeset)
    
    [how]
    check for ignore_msa in stream when considered synchronizability
    this ignore_msa is basically actually implemented as "supports drr"
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index da9e2e5f5c0d..8fe39fdefc27 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -404,6 +404,9 @@ bool resource_are_streams_timing_synchronizable(
 	if (stream1->view_format != stream2->view_format)
 		return false;
 
+	if (stream1->ignore_msa_timing_param || stream2->ignore_msa_timing_param)
+		return false;
+
 	return true;
 }
 static bool is_dp_and_hdmi_sharable(
@@ -1540,6 +1543,9 @@ bool dc_is_stream_unchanged(
 	if (!are_stream_backends_same(old_stream, stream))
 		return false;
 
+	if (old_stream->ignore_msa_timing_param != stream->ignore_msa_timing_param)
+		return false;
+
 	return true;
 }
 

commit f24b0522da181a00003ef138766a366973bf664d
Author: Paul Hsieh <paul.hsieh@amd.com>
Date:   Tue Oct 1 17:06:04 2019 +0800

    drm/amd/display: audio endpoint cannot switch
    
    [Why]
    On some systems, we need to check the dcn version in runtime
    system, not in compile time.
    
    [How]
    Stub in dcn version parameter to find_first_free_audio
    
    Signed-off-by: Paul Hsieh <paul.hsieh@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 25da0c45d828..da9e2e5f5c0d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1629,7 +1629,8 @@ static int acquire_first_free_pipe(
 static struct audio *find_first_free_audio(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		enum engine_id id)
+		enum engine_id id,
+		enum dce_version dc_version)
 {
 	int i, available_audio_count;
 
@@ -1965,7 +1966,7 @@ enum dc_status resource_map_pool_resources(
 	    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 	    stream->audio_info.mode_count && stream->audio_info.flags.all) {
 		pipe_ctx->stream_res.audio = find_first_free_audio(
-		&context->res_ctx, pool, pipe_ctx->stream_res.stream_enc->id);
+		&context->res_ctx, pool, pipe_ctx->stream_res.stream_enc->id, dc_ctx->dce_version);
 
 		/*
 		 * Audio assigned in order first come first get.

commit 08b662793b90fc3a7e1d84d0fe0a5c04112731fd
Author: Martin Leung <martin.leung@amd.com>
Date:   Tue Sep 3 15:22:30 2019 -0400

    drm/amd/display: fix use of uninitialized variable
    
    tg_inst may be used uninitialized, so initialize it to 0.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jaehyun Chung <Jaehyun.Chung@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 215e93aa63a7..25da0c45d828 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1848,7 +1848,7 @@ static int acquire_resource_from_hw_enabled_state(
 		struct dc_stream_state *stream)
 {
 	struct dc_link *link = stream->link;
-	unsigned int inst, tg_inst, i;
+	unsigned int i, inst, tg_inst = 0;
 
 	/* Check for enabled DIG to identify enabled display */
 	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))

commit 7f7652ee8c8c1c21a1493171bb9996759edb8d46
Author: Martin Leung <martin.leung@amd.com>
Date:   Fri Aug 16 17:26:23 2019 -0400

    drm/amd/display: enable single dp seamless boot
    
    [why]
    seamless boot didn't work for non edp's before
    
    [how]
    removed edp-specific code, made dp read uefi-set link settings. Also fixed
    a hubbub code line to be consistent with usage of function.
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 8f70295179ff..215e93aa63a7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1848,28 +1848,28 @@ static int acquire_resource_from_hw_enabled_state(
 		struct dc_stream_state *stream)
 {
 	struct dc_link *link = stream->link;
-	unsigned int inst, tg_inst;
+	unsigned int inst, tg_inst, i;
 
 	/* Check for enabled DIG to identify enabled display */
 	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))
 		return -1;
 
-	/* Check for which front end is used by this encoder.
-	 * Note the inst is 1 indexed, where 0 is undefined.
-	 * Note that DIG_FE can source from different OTG but our
-	 * current implementation always map 1-to-1, so this code makes
-	 * the same assumption and doesn't check OTG source.
-	 */
 	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);
 
-	/* Instance should be within the range of the pool */
-	if (inst >= pool->pipe_count)
-		return -1;
+	if (inst == ENGINE_ID_UNKNOWN)
+		return false;
 
-	if (inst >= pool->stream_enc_count)
-		return -1;
+	for (i = 0; i < pool->stream_enc_count; i++) {
+		if (pool->stream_enc[i]->id == inst) {
+			tg_inst = pool->stream_enc[i]->funcs->dig_source_otg(
+				pool->stream_enc[i]);
+			break;
+		}
+	}
 
-	tg_inst = pool->stream_enc[inst]->funcs->dig_source_otg(pool->stream_enc[inst]);
+	// tg_inst not found
+	if (i == pool->stream_enc_count)
+		return false;
 
 	if (tg_inst >= pool->timing_generator_count)
 		return false;

commit e22ece54ee782ac81838fb6a4b1a45c82e33461c
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Jul 26 17:06:02 2019 -0400

    drm/amd/display: Handle Renoir in DC
    
    add Renoir DCN version in DC and handle it
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 5fb0c3d672e4..8f70295179ff 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -52,6 +52,9 @@
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 #include "dcn20/dcn20_resource.h"
 #endif
+#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
+#include "dcn21/dcn21_resource.h"
+#endif
 #include "dce120/dce120_resource.h"
 
 #define DC_LOGGER_INIT(logger)
@@ -101,6 +104,10 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 		dc_version = DCN_VERSION_1_0;
 		if (ASICREV_IS_RAVEN2(asic_id.hw_internal_rev))
 			dc_version = DCN_VERSION_1_01;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
+		if (ASICREV_IS_RENOIR(asic_id.hw_internal_rev))
+			dc_version = DCN_VERSION_2_1;
+#endif
 		break;
 #endif
 
@@ -168,6 +175,11 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 		res_pool = dcn20_create_resource_pool(init_data, dc);
 		break;
 #endif
+#if defined(CONFIG_DRM_AMD_DC_DCN2_1)
+	case DCN_VERSION_2_1:
+		res_pool = dcn21_create_resource_pool(init_data, dc);
+		break;
+#endif
 
 	default:
 		break;

commit f49cfa279b9a2214172d13e87fe6a11bd3941f67
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Fri Aug 2 16:01:37 2019 -0400

    drm/amd/display: flicking observed while installing driver on Navi10 CF
    
    [WHY] value of dchub_ref_clock is decided by dchubbub global timer
    settings which is programmed by vbios command table disp_init.
    for multi-GPU case, vbios is posted only for primary GPU. without
    vbios posted for the secondary GPU, value of dchub_ref_clock is not
    set properly. this value will affect dcn bandwidth calcuation and
    cause underflow. user will see screen flicking during driver
    installation for dual GPU case.
    
    [HOW] dc init_hw always call vbios command table disp_init to
    make sure dchubbub global timer is configured and enable.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f7d8edc9cd02..5fb0c3d672e4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -172,6 +172,7 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 	default:
 		break;
 	}
+
 	if (res_pool != NULL) {
 		if (dc->ctx->dc_bios->fw_info_valid) {
 			res_pool->ref_clocks.xtalin_clock_inKhz =

commit 224980366d9d9c10797943cc16631c82a50855f8
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 16:09:07 2019 -0400

    drm/amd/display: fix odm stream release
    
    Need to memset all odm pipes when calling dc_remove_stream_from_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ac908141b395..f7d8edc9cd02 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1114,13 +1114,12 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct dc_stream_state *stream)
 {
 	int i;
+
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream
 				&& !res_ctx->pipe_ctx[i].top_pipe
-				&& !res_ctx->pipe_ctx[i].prev_odm_pipe) {
+				&& !res_ctx->pipe_ctx[i].prev_odm_pipe)
 			return &res_ctx->pipe_ctx[i];
-			break;
-		}
 	}
 	return NULL;
 }
@@ -1697,45 +1696,45 @@ enum dc_status dc_remove_stream_from_ctx(
 {
 	int i;
 	struct dc_context *dc_ctx = dc->ctx;
-	struct pipe_ctx *del_pipe = NULL;
+	struct pipe_ctx *del_pipe = resource_get_head_pipe_for_stream(&new_ctx->res_ctx, stream);
+	struct pipe_ctx *odm_pipe;
 
-	/* Release primary pipe */
-	for (i = 0; i < MAX_PIPES; i++) {
-		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream &&
-				!new_ctx->res_ctx.pipe_ctx[i].top_pipe) {
-			del_pipe = &new_ctx->res_ctx.pipe_ctx[i];
+	if (!del_pipe) {
+		DC_ERROR("Pipe not found for stream %p !\n", stream);
+		return DC_ERROR_UNEXPECTED;
+	}
 
-			ASSERT(del_pipe->stream_res.stream_enc);
-			update_stream_engine_usage(
-					&new_ctx->res_ctx,
-						dc->res_pool,
-					del_pipe->stream_res.stream_enc,
-					false);
+	odm_pipe = del_pipe->next_odm_pipe;
 
-			if (del_pipe->stream_res.audio)
-				update_audio_usage(
-					&new_ctx->res_ctx,
-					dc->res_pool,
-					del_pipe->stream_res.audio,
-					false);
+	/* Release primary pipe */
+	ASSERT(del_pipe->stream_res.stream_enc);
+	update_stream_engine_usage(
+			&new_ctx->res_ctx,
+				dc->res_pool,
+			del_pipe->stream_res.stream_enc,
+			false);
 
-			resource_unreference_clock_source(&new_ctx->res_ctx,
-							  dc->res_pool,
-							  del_pipe->clock_source);
+	if (del_pipe->stream_res.audio)
+		update_audio_usage(
+			&new_ctx->res_ctx,
+			dc->res_pool,
+			del_pipe->stream_res.audio,
+			false);
 
-			if (dc->res_pool->funcs->remove_stream_from_ctx)
-				dc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);
+	resource_unreference_clock_source(&new_ctx->res_ctx,
+					  dc->res_pool,
+					  del_pipe->clock_source);
 
-			memset(del_pipe, 0, sizeof(*del_pipe));
+	if (dc->res_pool->funcs->remove_stream_from_ctx)
+		dc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);
 
-			break;
-		}
-	}
+	while (odm_pipe) {
+		struct pipe_ctx *next_odm_pipe = odm_pipe->next_odm_pipe;
 
-	if (!del_pipe) {
-		DC_ERROR("Pipe not found for stream %p !\n", stream);
-		return DC_ERROR_UNEXPECTED;
+		memset(odm_pipe, 0, sizeof(*odm_pipe));
+		odm_pipe = next_odm_pipe;
 	}
+	memset(del_pipe, 0, sizeof(*del_pipe));
 
 	for (i = 0; i < new_ctx->stream_count; i++)
 		if (new_ctx->streams[i] == stream)

commit b5a41620bb88efb9fb31a4fa5e652e3d5bead7d4
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Aug 2 14:49:58 2019 -0400

    drm/amd/display: support spdif
    
    [Description]
    port spdif fix to staging:
     spdif hardwired to afmt inst 1.
     spdif func pointer
     spdif resource allocation (reserve last audio endpoint for spdif only)
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 30bae60918ea..ac908141b395 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -262,12 +262,10 @@ bool resource_construct(
 				DC_ERR("DC: failed to create audio!\n");
 				return false;
 			}
-
 			if (!aud->funcs->endpoint_valid(aud)) {
 				aud->funcs->destroy(&aud);
 				break;
 			}
-
 			pool->audios[i] = aud;
 			pool->audio_count++;
 		}
@@ -1621,24 +1619,25 @@ static struct audio *find_first_free_audio(
 		const struct resource_pool *pool,
 		enum engine_id id)
 {
-	int i;
-	for (i = 0; i < pool->audio_count; i++) {
+	int i, available_audio_count;
+
+	available_audio_count = pool->audio_count;
+
+	for (i = 0; i < available_audio_count; i++) {
 		if ((res_ctx->is_audio_acquired[i] == false) && (res_ctx->is_stream_enc_acquired[i] == true)) {
 			/*we have enough audio endpoint, find the matching inst*/
 			if (id != i)
 				continue;
-
 			return pool->audios[i];
 		}
 	}
 
-    /* use engine id to find free audio */
-	if ((id < pool->audio_count) && (res_ctx->is_audio_acquired[id] == false)) {
+	/* use engine id to find free audio */
+	if ((id < available_audio_count) && (res_ctx->is_audio_acquired[id] == false)) {
 		return pool->audios[id];
 	}
-
 	/*not found the matching one, first come first serve*/
-	for (i = 0; i < pool->audio_count; i++) {
+	for (i = 0; i < available_audio_count; i++) {
 		if (res_ctx->is_audio_acquired[i] == false) {
 			return pool->audios[i];
 		}

commit b1f6d01c4a3b7eeb2eb035e79d425cd6a696fa45
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Aug 6 17:17:28 2019 -0400

    drm/amd/display: re structure odm to allow 4 to 1 support
    
    Currently odm is handled using top_bottom pipe by special casing
    the differing opps to differentiate from mpc combine.
    
    Since top/bottom pipe list was made to track mpc muxing this creates
    difficulties in adding a 4 pipe odm case support.
    
    Rather than continue using mpc combine list, this change reworks odm
    to use it's own linked list to keep track of odm combine pipes. This
    also opens up options for using mpo with odm, if a practical use case
    is ever found.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 97e992e30d1a..30bae60918ea 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1117,8 +1117,9 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 {
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (res_ctx->pipe_ctx[i].stream == stream &&
-				!res_ctx->pipe_ctx[i].top_pipe) {
+		if (res_ctx->pipe_ctx[i].stream == stream
+				&& !res_ctx->pipe_ctx[i].top_pipe
+				&& !res_ctx->pipe_ctx[i].prev_odm_pipe) {
 			return &res_ctx->pipe_ctx[i];
 			break;
 		}
@@ -1126,15 +1127,11 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	return NULL;
 }
 
-static struct pipe_ctx *resource_get_tail_pipe_for_stream(
+static struct pipe_ctx *resource_get_tail_pipe(
 		struct resource_context *res_ctx,
-		struct dc_stream_state *stream)
+		struct pipe_ctx *head_pipe)
 {
-	struct pipe_ctx *head_pipe, *tail_pipe;
-	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
-
-	if (!head_pipe)
-		return NULL;
+	struct pipe_ctx *tail_pipe;
 
 	tail_pipe = head_pipe->bottom_pipe;
 
@@ -1150,31 +1147,20 @@ static struct pipe_ctx *resource_get_tail_pipe_for_stream(
  * A free_pipe for a stream is defined here as a pipe
  * that has no surface attached yet
  */
-static struct pipe_ctx *acquire_free_pipe_for_stream(
+static struct pipe_ctx *acquire_free_pipe_for_head(
 		struct dc_state *context,
 		const struct resource_pool *pool,
-		struct dc_stream_state *stream)
+		struct pipe_ctx *head_pipe)
 {
 	int i;
 	struct resource_context *res_ctx = &context->res_ctx;
 
-	struct pipe_ctx *head_pipe = NULL;
-
-	/* Find head pipe, which has the back end set up*/
-
-	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
-
-	if (!head_pipe) {
-		ASSERT(0);
-		return NULL;
-	}
-
 	if (!head_pipe->plane_state)
 		return head_pipe;
 
 	/* Re-use pipe already acquired for this stream if available*/
 	for (i = pool->pipe_count - 1; i >= 0; i--) {
-		if (res_ctx->pipe_ctx[i].stream == stream &&
+		if (res_ctx->pipe_ctx[i].stream == head_pipe->stream &&
 				!res_ctx->pipe_ctx[i].plane_state) {
 			return &res_ctx->pipe_ctx[i];
 		}
@@ -1188,8 +1174,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	if (!pool->funcs->acquire_idle_pipe_for_layer)
 		return NULL;
 
-	return pool->funcs->acquire_idle_pipe_for_layer(context, pool, stream);
-
+	return pool->funcs->acquire_idle_pipe_for_layer(context, pool, head_pipe->stream);
 }
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -1203,7 +1188,7 @@ static int acquire_first_split_pipe(
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *split_pipe = &res_ctx->pipe_ctx[i];
 
-		if (split_pipe->top_pipe && !dc_res_is_odm_head_pipe(split_pipe) &&
+		if (split_pipe->top_pipe &&
 				split_pipe->top_pipe->plane_state == split_pipe->plane_state) {
 			split_pipe->top_pipe->bottom_pipe = split_pipe->bottom_pipe;
 			if (split_pipe->bottom_pipe)
@@ -1264,39 +1249,41 @@ bool dc_add_plane_to_context(
 		return false;
 	}
 
-	tail_pipe = resource_get_tail_pipe_for_stream(&context->res_ctx, stream);
-	ASSERT(tail_pipe);
+	/* retain new surface, but only once per stream */
+	dc_plane_state_retain(plane_state);
 
-	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
+	while (head_pipe) {
+		tail_pipe = resource_get_tail_pipe(&context->res_ctx, head_pipe);
+		ASSERT(tail_pipe);
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-	if (!free_pipe) {
-		int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
-		if (pipe_idx >= 0)
-			free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
-	}
-#endif
-	if (!free_pipe)
-		return false;
+		free_pipe = acquire_free_pipe_for_head(context, pool, head_pipe);
 
-	/* retain new surfaces */
-	dc_plane_state_retain(plane_state);
-	free_pipe->plane_state = plane_state;
-
-	if (head_pipe != free_pipe) {
-		free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
-		free_pipe->stream_res.abm = tail_pipe->stream_res.abm;
-		free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
-		free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
-		free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
-		free_pipe->clock_source = tail_pipe->clock_source;
-		free_pipe->top_pipe = tail_pipe;
-		tail_pipe->bottom_pipe = free_pipe;
-	} else if (free_pipe->bottom_pipe && free_pipe->bottom_pipe->plane_state == NULL) {
-		ASSERT(free_pipe->bottom_pipe->stream_res.opp != free_pipe->stream_res.opp);
-		free_pipe->bottom_pipe->plane_state = plane_state;
-	}
+	#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		if (!free_pipe) {
+			int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+			if (pipe_idx >= 0)
+				free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
+		}
+	#endif
+		if (!free_pipe) {
+			dc_plane_state_release(plane_state);
+			return false;
+		}
 
+		free_pipe->plane_state = plane_state;
+
+		if (head_pipe != free_pipe) {
+			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
+			free_pipe->stream_res.abm = tail_pipe->stream_res.abm;
+			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
+			free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
+			free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
+			free_pipe->clock_source = tail_pipe->clock_source;
+			free_pipe->top_pipe = tail_pipe;
+			tail_pipe->bottom_pipe = free_pipe;
+		}
+		head_pipe = head_pipe->next_odm_pipe;
+	}
 	/* assign new surfaces*/
 	stream_status->plane_states[stream_status->plane_count] = plane_state;
 
@@ -1305,35 +1292,6 @@ bool dc_add_plane_to_context(
 	return true;
 }
 
-struct pipe_ctx *dc_res_get_odm_bottom_pipe(struct pipe_ctx *pipe_ctx)
-{
-	struct pipe_ctx *bottom_pipe = pipe_ctx->bottom_pipe;
-
-	/* ODM should only be updated once per otg */
-	if (pipe_ctx->top_pipe)
-		return NULL;
-
-	while (bottom_pipe) {
-		if (bottom_pipe->stream_res.opp != pipe_ctx->stream_res.opp)
-			break;
-		bottom_pipe = bottom_pipe->bottom_pipe;
-	}
-
-	return bottom_pipe;
-}
-
-bool dc_res_is_odm_head_pipe(struct pipe_ctx *pipe_ctx)
-{
-	struct pipe_ctx *top_pipe = pipe_ctx->top_pipe;
-
-	if (!top_pipe)
-		return false;
-	if (top_pipe && top_pipe->stream_res.opp == pipe_ctx->stream_res.opp)
-		return false;
-
-	return true;
-}
-
 bool dc_remove_plane_from_context(
 		const struct dc *dc,
 		struct dc_stream_state *stream,
@@ -1360,12 +1318,6 @@ bool dc_remove_plane_from_context(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->plane_state == plane_state) {
-			if (dc_res_is_odm_head_pipe(pipe_ctx)) {
-				pipe_ctx->plane_state = NULL;
-				pipe_ctx->bottom_pipe = NULL;
-				continue;
-			}
-
 			if (pipe_ctx->top_pipe)
 				pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
 
@@ -1380,13 +1332,10 @@ bool dc_remove_plane_from_context(
 			 * For head pipe detach surfaces from pipe for tail
 			 * pipe just zero it out
 			 */
-			if (!pipe_ctx->top_pipe) {
+			if (!pipe_ctx->top_pipe)
 				pipe_ctx->plane_state = NULL;
-				if (!dc_res_get_odm_bottom_pipe(pipe_ctx))
-					pipe_ctx->bottom_pipe = NULL;
-			} else {
+			else
 				memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-			}
 		}
 	}
 
@@ -1755,9 +1704,6 @@ enum dc_status dc_remove_stream_from_ctx(
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream &&
 				!new_ctx->res_ctx.pipe_ctx[i].top_pipe) {
-			struct pipe_ctx *odm_pipe =
-					dc_res_get_odm_bottom_pipe(&new_ctx->res_ctx.pipe_ctx[i]);
-
 			del_pipe = &new_ctx->res_ctx.pipe_ctx[i];
 
 			ASSERT(del_pipe->stream_res.stream_enc);
@@ -1782,8 +1728,6 @@ enum dc_status dc_remove_stream_from_ctx(
 				dc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);
 
 			memset(del_pipe, 0, sizeof(*del_pipe));
-			if (odm_pipe)
-				memset(odm_pipe, 0, sizeof(*odm_pipe));
 
 			break;
 		}
@@ -2497,6 +2441,12 @@ void dc_resource_state_copy_construct(
 
 		if (cur_pipe->bottom_pipe)
 			cur_pipe->bottom_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+
+		if (cur_pipe->next_odm_pipe)
+			cur_pipe->next_odm_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->next_odm_pipe->pipe_idx];
+
+		if (cur_pipe->prev_odm_pipe)
+			cur_pipe->prev_odm_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->prev_odm_pipe->pipe_idx];
 	}
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {

commit 5ec43eda85506ddc2f91c3a4e28b38da3f14cf1e
Author: Martin Leung <martin.leung@amd.com>
Date:   Wed Jul 17 16:08:19 2019 -0400

    drm/amd/display: enabling seamless boot sequence for dcn2
    
    [Why]
    Seamless boot (building SW state inheriting BIOS-initialized timing) was
    enabled on DCN2, including fixes
    
    [How]
    Includes fixes for MPC, DPPCLK, and DIG FE mapping/OTG source select/
    Pixel clock.
    
    This is part 2 of 2 for seamless boot NV10
    
    Signed-off-by: Martin Leung <martin.leung@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 5956e70f573f..97e992e30d1a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1893,7 +1893,7 @@ static int acquire_resource_from_hw_enabled_state(
 		struct dc_stream_state *stream)
 {
 	struct dc_link *link = stream->link;
-	unsigned int inst;
+	unsigned int inst, tg_inst;
 
 	/* Check for enabled DIG to identify enabled display */
 	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))
@@ -1905,28 +1905,37 @@ static int acquire_resource_from_hw_enabled_state(
 	 * current implementation always map 1-to-1, so this code makes
 	 * the same assumption and doesn't check OTG source.
 	 */
-	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc) - 1;
+	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc);
 
 	/* Instance should be within the range of the pool */
 	if (inst >= pool->pipe_count)
 		return -1;
 
-	if (!res_ctx->pipe_ctx[inst].stream) {
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[inst];
+	if (inst >= pool->stream_enc_count)
+		return -1;
+
+	tg_inst = pool->stream_enc[inst]->funcs->dig_source_otg(pool->stream_enc[inst]);
+
+	if (tg_inst >= pool->timing_generator_count)
+		return false;
+
+	if (!res_ctx->pipe_ctx[tg_inst].stream) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[tg_inst];
+
+		pipe_ctx->stream_res.tg = pool->timing_generators[tg_inst];
+		pipe_ctx->plane_res.mi = pool->mis[tg_inst];
+		pipe_ctx->plane_res.hubp = pool->hubps[tg_inst];
+		pipe_ctx->plane_res.ipp = pool->ipps[tg_inst];
+		pipe_ctx->plane_res.xfm = pool->transforms[tg_inst];
+		pipe_ctx->plane_res.dpp = pool->dpps[tg_inst];
+		pipe_ctx->stream_res.opp = pool->opps[tg_inst];
 
-		pipe_ctx->stream_res.tg = pool->timing_generators[inst];
-		pipe_ctx->plane_res.mi = pool->mis[inst];
-		pipe_ctx->plane_res.hubp = pool->hubps[inst];
-		pipe_ctx->plane_res.ipp = pool->ipps[inst];
-		pipe_ctx->plane_res.xfm = pool->transforms[inst];
-		pipe_ctx->plane_res.dpp = pool->dpps[inst];
-		pipe_ctx->stream_res.opp = pool->opps[inst];
-		if (pool->dpps[inst])
-			pipe_ctx->plane_res.mpcc_inst = pool->dpps[inst]->inst;
-		pipe_ctx->pipe_idx = inst;
+		if (pool->dpps[tg_inst])
+			pipe_ctx->plane_res.mpcc_inst = pool->dpps[tg_inst]->inst;
+		pipe_ctx->pipe_idx = tg_inst;
 
 		pipe_ctx->stream = stream;
-		return inst;
+		return tg_inst;
 	}
 
 	return -1;

commit 9adc8050bf3ca3e49c65e13259a4c310640542f1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 12 15:06:06 2019 -0400

    drm/amd/display: make firmware info only load once during dc_bios create
    
    Currently every time DC wants to access firmware info we make a call
    into VBIOS. This makes no sense as there is nothing that can change
    runtime inside fw info and can cause issues when calling unstable
    bios during bringup.
    
    This change eliminate this behavior by only calling bios once for fw
    info and keeping it stored as part of dc_bios.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c227b86420a0..5956e70f573f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -173,12 +173,9 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 		break;
 	}
 	if (res_pool != NULL) {
-		struct dc_firmware_info fw_info = { { 0 } };
-
-		if (dc->ctx->dc_bios->funcs->get_firmware_info(dc->ctx->dc_bios,
-				&fw_info) == BP_RESULT_OK) {
+		if (dc->ctx->dc_bios->fw_info_valid) {
 			res_pool->ref_clocks.xtalin_clock_inKhz =
-				fw_info.pll_info.crystal_frequency;
+				dc->ctx->dc_bios->fw_info.pll_info.crystal_frequency;
 			/* initialize with firmware data first, no all
 			 * ASIC have DCCG SW component. FPGA or
 			 * simulation need initialization of

commit ce08aad3896f342d6c99e8e2dc1f71a0926efafc
Author: Alvin Lee <alvin.lee2@amd.com>
Date:   Thu Jul 4 15:17:42 2019 -0400

    drm/amd/display: Only enable audio if speaker allocation exists
    
    [Why]
    
    In dm_helpers_parse_edid_caps, there is a corner case where no speakers
    can be allocated even though the audio mode count is greater than 0.
    Enabling audio when no speaker allocations exists can cause issues in
    the video stream.
    
    [How]
    
    Add a check to not enable audio unless one or more speaker allocations
    exist (since doing this can cause issues in the video stream).
    
    Signed-off-by: Alvin Lee <alvin.lee2@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6f9d310de542..c227b86420a0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2002,7 +2002,7 @@ enum dc_status resource_map_pool_resources(
 	/* TODO: Add check if ASIC support and EDID audio */
 	if (!stream->converter_disable_audio &&
 	    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
-	    stream->audio_info.mode_count) {
+	    stream->audio_info.mode_count && stream->audio_info.flags.all) {
 		pipe_ctx->stream_res.audio = find_first_free_audio(
 		&context->res_ctx, pool, pipe_ctx->stream_res.stream_enc->id);
 

commit 8897810adfa768b0c127c1e204bedc4449e3f945
Author: Julian Parkin <julian.parkin@amd.com>
Date:   Tue Jun 25 14:55:53 2019 -0400

    drm/amd/display: Fix dc_create failure handling and 666 color depths
    
    [Why]
    It is possible (but very unlikely) that constructing dc fails
    before current_state is created.
    
    We support 666 color depth in some scenarios, but this
    isn't handled in get_norm_pix_clk. It uses exactly the
    same pixel clock as the 888 case.
    
    [How]
    Check for non null current_state before destructing.
    
    Add case for 666 color depth to get_norm_pix_clk to
    avoid assertion.
    
    Signed-off-by: Julian Parkin <julian.parkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index e4d0035b4ed4..6f9d310de542 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1855,6 +1855,7 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 		pix_clk /= 2;
 	if (timing->pixel_encoding != PIXEL_ENCODING_YCBCR422) {
 		switch (timing->display_color_depth) {
+		case COLOR_DEPTH_666:
 		case COLOR_DEPTH_888:
 			normalized_pix_clk = pix_clk;
 			break;

commit f7938bc0f08b3d748d20dc2c88914f03331dce94
Author: Reza Amini <Reza.Amini@amd.com>
Date:   Mon Jun 10 16:45:50 2019 -0400

    drm/amd/display: Implement DAL3 GPU Integer Scaling
    
    [WHY]
    Users want to not have filtering when scaling by integer
    multiples to native timing.
    
    [HOW]
    If timing is a multiple integer of view, we set number of taps
    to 1 (effectivly closest neighbour).
    
    Signed-off-by: Reza Amini <Reza.Amini@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a0e29c37ab69..e4d0035b4ed4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -940,7 +940,14 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
 	data->inits.v_c_bot = dc_fixpt_add(data->inits.v_c, data->ratios.vert_c);
 
 }
+static bool are_rect_integer_multiples(struct rect src, struct rect dest)
+{
+	if (dest.width  >= src.width  && dest.width  % src.width  == 0 &&
+		dest.height >= src.height && dest.height % src.height == 0)
+		return true;
 
+	return false;
+}
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
@@ -983,6 +990,15 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->plane_res.dpp != NULL)
 		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
 				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+
+	if (res &&
+	    plane_state->scaling_quality.integer_scaling &&
+	    are_rect_integer_multiples(pipe_ctx->plane_res.scl_data.viewport,
+				       pipe_ctx->plane_res.scl_data.recout)) {
+		pipe_ctx->plane_res.scl_data.taps.v_taps = 1;
+		pipe_ctx->plane_res.scl_data.taps.h_taps = 1;
+	}
+
 	if (!res) {
 		/* Try 24 bpp linebuffer */
 		pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;

commit 5feb9f07a2035394ed808e266d294a9df3a8d544
Author: Tai Man <taiman.wong@amd.com>
Date:   Fri Jun 7 17:32:27 2019 -0400

    drm/amd/display: use encoder's engine id to find matched free audio device
    
    [Why]
    On some platforms, the encoder id 3 is not populated. So the encoders
    are not stored in right order as index (id: 0, 1, 2, 4, 5) at pool. This
    would cause encoders id 4 & id 5 to fail when finding corresponding
    audio device, defaulting to the first available audio device. As result,
    we cannot stream audio into two DP ports with encoders id 4 & id 5.
    
    [How]
    It need to create enough audio device objects (0 - 5) to perform matching.
    Then use encoder engine id to find matched audio device.
    
    Signed-off-by: Tai Man <taiman.wong@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 51a78283a86d..a0e29c37ab69 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -258,7 +258,7 @@ bool resource_construct(
 		 * PORT_CONNECTIVITY == 1 (as instructed by HW team).
 		 */
 		update_num_audio(&straps, &num_audio, &pool->audio_support);
-		for (i = 0; i < pool->pipe_count && i < num_audio; i++) {
+		for (i = 0; i < caps->num_audio; i++) {
 			struct audio *aud = create_funcs->create_audio(ctx, i);
 
 			if (aud == NULL) {
@@ -1669,6 +1669,12 @@ static struct audio *find_first_free_audio(
 			return pool->audios[i];
 		}
 	}
+
+    /* use engine id to find free audio */
+	if ((id < pool->audio_count) && (res_ctx->is_audio_acquired[id] == false)) {
+		return pool->audios[id];
+	}
+
 	/*not found the matching one, first come first serve*/
 	for (i = 0; i < pool->audio_count; i++) {
 		if (res_ctx->is_audio_acquired[i] == false) {

commit 41a5a2a8531f95d18bb4efddea581ccb469e8ee5
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Wed Jun 26 13:06:07 2019 -0400

    drm/amd/display: init res_pool dccg_ref, dchub_ref with xtalin_freq
    
    [WHY] dc sw clock implementation of navi10 and raven are not exact the
    same. dcccg, dchub reference clock initialization is done after dc calls
    vbios dispcontroller_init table. for raven family, before
    dispcontroller_init is called by dc, the ref clk values are referred
    by sw clock implementation and program asic register using wrong
    values. this causes dchub pstate error. This need provide valid ref
    clk values. for navi10, since dispcontroller_init is not called,
    dchubbub_global_timer_enable = 0, hubbub2_get_dchub_ref_freq will
    hit aeert. this need remove hubbub2_get_dchub_ref_freq from this
    location and move to dcn20_init_hw.
    
    [HOW] for all asic, initialize dccg, dchub ref clk with data from
    vbios firmware table by default. for raven asic family, use these data
    from vbios, for asic which support sw dccg component, like navi10,
    read ref clk by sw dccg functions and update the ref clk.
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 48dfb305a0b0..51a78283a86d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -175,32 +175,22 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 	if (res_pool != NULL) {
 		struct dc_firmware_info fw_info = { { 0 } };
 
-		if (dc->ctx->dc_bios->funcs->get_firmware_info(
-				dc->ctx->dc_bios, &fw_info) == BP_RESULT_OK) {
-				res_pool->ref_clocks.xtalin_clock_inKhz = fw_info.pll_info.crystal_frequency;
-
-				if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
-					// On FPGA these dividers are currently not configured by GDB
-					res_pool->ref_clocks.dccg_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
-					res_pool->ref_clocks.dchub_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
-				} else if (res_pool->dccg && res_pool->hubbub) {
-					// If DCCG reference frequency cannot be determined (usually means not set to xtalin) then this is a critical error
-					// as this value must be known for DCHUB programming
-					(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,
-							fw_info.pll_info.crystal_frequency,
-							&res_pool->ref_clocks.dccg_ref_clock_inKhz);
-
-					// Similarly, if DCHUB reference frequency cannot be determined, then it is also a critical error
-					(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,
-							res_pool->ref_clocks.dccg_ref_clock_inKhz,
-							&res_pool->ref_clocks.dchub_ref_clock_inKhz);
-				} else {
-					// Not all ASICs have DCCG sw component
-					res_pool->ref_clocks.dccg_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
-					res_pool->ref_clocks.dchub_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
-				}
-			} else
-				ASSERT_CRITICAL(false);
+		if (dc->ctx->dc_bios->funcs->get_firmware_info(dc->ctx->dc_bios,
+				&fw_info) == BP_RESULT_OK) {
+			res_pool->ref_clocks.xtalin_clock_inKhz =
+				fw_info.pll_info.crystal_frequency;
+			/* initialize with firmware data first, no all
+			 * ASIC have DCCG SW component. FPGA or
+			 * simulation need initialization of
+			 * dccg_ref_clock_inKhz, dchub_ref_clock_inKhz
+			 * with xtalin_clock_inKhz
+			 */
+			res_pool->ref_clocks.dccg_ref_clock_inKhz =
+				res_pool->ref_clocks.xtalin_clock_inKhz;
+			res_pool->ref_clocks.dchub_ref_clock_inKhz =
+				res_pool->ref_clocks.xtalin_clock_inKhz;
+		} else
+			ASSERT_CRITICAL(false);
 	}
 
 	return res_pool;

commit 5fdb7c4c7f2691efd760b0b0dc00da4a3699f1a6
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Fri Jun 28 13:39:41 2019 -0400

    drm/amd/display: Expose audio inst from DC to DM
    
    [Why]
    In order to give pin notifications to the sound driver from DM we need
    to know whether audio is enabled on a stream and what pin it's using
    from DC.
    
    [How]
    Expose the instance via stream status if it's a mapped resource for
    the stream. It will be -1 if there's no audio mapped.
    
    Cc: Leo Li <sunpeng.li@amd.com>
    Cc: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 173fcfb5abe6..48dfb305a0b0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2011,6 +2011,9 @@ enum dc_status resource_map_pool_resources(
 		if (context->streams[i] == stream) {
 			context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
 			context->stream_status[i].stream_enc_inst = pipe_ctx->stream_res.stream_enc->id;
+			context->stream_status[i].audio_inst =
+				pipe_ctx->stream_res.audio ? pipe_ctx->stream_res.audio->inst : -1;
+
 			return DC_OK;
 		}
 

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit 7ed4e6352c16fe018864bc4e626c48e27a0cefee
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Feb 22 16:52:08 2019 -0500

    drm/amd/display: Add DCN2 HW Sequencer and Resource
    
    Add DCN2 resource definition and HW Sequencer changes.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0a2e0fe75405..d10ebfd33a60 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -46,6 +46,9 @@
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "dcn10/dcn10_resource.h"
 #endif
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+#include "dcn20/dcn20_resource.h"
+#endif
 #include "dce120/dce120_resource.h"
 
 #define DC_LOGGER_INIT(logger)
@@ -97,6 +100,12 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 			dc_version = DCN_VERSION_1_01;
 		break;
 #endif
+
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	case FAMILY_NV:
+		dc_version = DCN_VERSION_2_0;
+		break;
+#endif
 	default:
 		dc_version = DCE_VERSION_UNKNOWN;
 		break;
@@ -151,6 +160,12 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 #endif
 
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	case DCN_VERSION_2_0:
+		res_pool = dcn20_create_resource_pool(init_data, dc);
+		break;
+#endif
+
 	default:
 		break;
 	}

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian König" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index eac7186e4f08..5ad1c62e9e4d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -22,6 +22,9 @@
  * Authors: AMD
  *
  */
+
+#include <linux/slab.h>
+
 #include "dm_services.h"
 
 #include "resource.h"

commit dc88b4a684d284a200c0ecfd8d87179d6f6c89a3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Apr 22 19:39:35 2019 -0400

    drm/amd/display: make clk mgr soc specific
    
    [Why]
    First step of refactoring clk mgr to better handle different
    ways of handling clock operations. Clock operation policies are
    soc specific and not just DCN vesion specific. It is not a hw resource,
    should not be in the resource pool.
    
    [How]
    Change clock manager creation to be based on HW internal ID, rename
    clock manager members to be more clear. Move clock manager out of
    resource.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index b7952f39f3fc..0a2e0fe75405 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2018,7 +2018,7 @@ void dc_resource_state_construct(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dst_ctx->clk_mgr = dc->res_pool->clk_mgr;
+	dst_ctx->clk_mgr = dc->clk_mgr;
 }
 
 /**

commit 78cc70b1e47d660207dabf75ca2751fc1e4edf84
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Wed Apr 24 15:25:41 2019 -0400

    drm/amd/display: Engine-specific encoder allocation
    
    [WHY]
    From DCE110 onward, we have the ability to assign DIG BE and FE
    separately for any display connector type; before, we could only do this
    for DP.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 578503ba0d9f..b7952f39f3fc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1646,46 +1646,6 @@ static int acquire_first_free_pipe(
 	return -1;
 }
 
-static struct stream_encoder *find_first_free_match_stream_enc_for_link(
-		struct resource_context *res_ctx,
-		const struct resource_pool *pool,
-		struct dc_stream_state *stream)
-{
-	int i;
-	int j = -1;
-	struct dc_link *link = stream->link;
-
-	for (i = 0; i < pool->stream_enc_count; i++) {
-		if (!res_ctx->is_stream_enc_acquired[i] &&
-				pool->stream_enc[i]) {
-			/* Store first available for MST second display
-			 * in daisy chain use case */
-			j = i;
-			if (pool->stream_enc[i]->id ==
-					link->link_enc->preferred_engine)
-				return pool->stream_enc[i];
-		}
-	}
-
-	/*
-	 * below can happen in cases when stream encoder is acquired:
-	 * 1) for second MST display in chain, so preferred engine already
-	 * acquired;
-	 * 2) for another link, which preferred engine already acquired by any
-	 * MST configuration.
-	 *
-	 * If signal is of DP type and preferred engine not found, return last available
-	 *
-	 * TODO - This is just a patch up and a generic solution is
-	 * required for non DP connectors.
-	 */
-
-	if (j >= 0 && link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT)
-		return pool->stream_enc[j];
-
-	return NULL;
-}
-
 static struct audio *find_first_free_audio(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
@@ -1997,7 +1957,7 @@ enum dc_status resource_map_pool_resources(
 	pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
 
 	pipe_ctx->stream_res.stream_enc =
-		find_first_free_match_stream_enc_for_link(
+		dc->res_pool->funcs->find_first_free_match_stream_enc_for_link(
 			&context->res_ctx, pool, stream);
 
 	if (!pipe_ctx->stream_res.stream_enc)

commit eed928dcd83ee8c80fa05013bbc019bc9e9e2a0e
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Apr 29 14:35:01 2019 -0400

    drm/amd/display: enabling stream after HPD low to high happened
    
    [Why]
    1. No real HPD plug in/out but HPD happens,
     the driver notifies OS connection changed.
    2. No display in target.
    
    When HPD goes low to high,
    the driver should regard as HPD and enter setmode flow.
    
    [How]
    In this case, even stream didn't change but still retrain.
    
    Signed-off-by: Chiawen Huang <chiawen.huang@amd.com>
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 262d07a8cb75..578503ba0d9f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2642,6 +2642,10 @@ bool pipe_need_reprogram(
 	if (is_vsc_info_packet_changed(pipe_ctx_old->stream, pipe_ctx->stream))
 		return true;
 
+	if (false == pipe_ctx_old->stream->link->link_state_valid &&
+		false == pipe_ctx_old->stream->dpms_off)
+		return true;
+
 	return false;
 }
 

commit 24c18794946ad127334138669b2aa204b2e60763
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 8 14:56:29 2019 -0400

    drm/amd/display: add null checks and set update flags
    
    * add plane state null checks
    * add and set update surface flags
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d9bfffb2c48d..262d07a8cb75 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2497,7 +2497,6 @@ void dc_resource_state_copy_construct(
 
 		if (cur_pipe->bottom_pipe)
 			cur_pipe->bottom_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
-
 	}
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {

commit 97df424fe7a7497a129f057527f646c91b881fbf
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue May 14 09:12:45 2019 -0400

    drm/amd/display: Drop DCN1_01 guards
    
    [WHY]
    These were only needed for bringup. They're not needed anymore.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 58ce7a6b914c..d9bfffb2c48d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -93,10 +93,8 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case FAMILY_RV:
 		dc_version = DCN_VERSION_1_0;
-#if defined(CONFIG_DRM_AMD_DC_DCN1_01)
 		if (ASICREV_IS_RAVEN2(asic_id.hw_internal_rev))
 			dc_version = DCN_VERSION_1_01;
-#endif
 		break;
 #endif
 	default:
@@ -147,9 +145,7 @@ struct resource_pool *dc_create_resource_pool(struct dc  *dc,
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case DCN_VERSION_1_0:
-#if defined(CONFIG_DRM_AMD_DC_DCN1_01)
 	case DCN_VERSION_1_01:
-#endif
 		res_pool = dcn10_create_resource_pool(init_data, dc);
 		break;
 #endif

commit 88ccdf1d59df4d93b0591c8879316de40ef88f93
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Tue Apr 16 11:07:22 2019 -0400

    drm/amd/display: Expose send immediate sdp message interface
    
    [Why]
    To send sdp message immediately from a single slot.
    
    [How]
    Modify the generic SDP message interface, and use GSP4 to send immediate
    sdp message.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 47b99458d319..58ce7a6b914c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2446,21 +2446,6 @@ static void set_spd_info_packet(
 	*info_packet = stream->vrr_infopacket;
 }
 
-static void set_dp_sdp_info_packet(
-		struct dc_info_packet *info_packet,
-		struct dc_stream_state *stream)
-{
-	/* SPD info packet for custom sdp message */
-
-	/* Return if false. If true,
-	 * set the corresponding bit in the info packet
-	 */
-	if (!stream->dpsdp_infopacket.valid)
-		return;
-
-	*info_packet = stream->dpsdp_infopacket;
-}
-
 static void set_hdr_static_info_packet(
 		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
@@ -2557,7 +2542,6 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 	info->spd.valid = false;
 	info->hdrsmd.valid = false;
 	info->vsc.valid = false;
-	info->dpsdp.valid = false;
 
 	signal = pipe_ctx->stream->signal;
 
@@ -2577,8 +2561,6 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd, pipe_ctx->stream);
-
-		set_dp_sdp_info_packet(&info->dpsdp, pipe_ctx->stream);
 	}
 
 	patch_gamut_packet_checksum(&info->gamut);

commit 79592db31297d2fbf1c24b7775199e2bda283079
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Apr 16 13:31:22 2019 -0400

    drm/amd/display: fix acquire_first_split_pipe function
    
    This function needs to re-calculate the scaling on the pipe
    that loses it's half.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 20966325852f..47b99458d319 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1184,24 +1184,27 @@ static int acquire_first_split_pipe(
 	int i;
 
 	for (i = 0; i < pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
-
-		if (pipe_ctx->top_pipe &&
-				pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state) {
-			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
-			if (pipe_ctx->bottom_pipe)
-				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
-
-			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-			pipe_ctx->stream_res.tg = pool->timing_generators[i];
-			pipe_ctx->plane_res.hubp = pool->hubps[i];
-			pipe_ctx->plane_res.ipp = pool->ipps[i];
-			pipe_ctx->plane_res.dpp = pool->dpps[i];
-			pipe_ctx->stream_res.opp = pool->opps[i];
-			pipe_ctx->plane_res.mpcc_inst = pool->dpps[i]->inst;
-			pipe_ctx->pipe_idx = i;
-
-			pipe_ctx->stream = stream;
+		struct pipe_ctx *split_pipe = &res_ctx->pipe_ctx[i];
+
+		if (split_pipe->top_pipe && !dc_res_is_odm_head_pipe(split_pipe) &&
+				split_pipe->top_pipe->plane_state == split_pipe->plane_state) {
+			split_pipe->top_pipe->bottom_pipe = split_pipe->bottom_pipe;
+			if (split_pipe->bottom_pipe)
+				split_pipe->bottom_pipe->top_pipe = split_pipe->top_pipe;
+
+			if (split_pipe->top_pipe->plane_state)
+				resource_build_scaling_params(split_pipe->top_pipe);
+
+			memset(split_pipe, 0, sizeof(*split_pipe));
+			split_pipe->stream_res.tg = pool->timing_generators[i];
+			split_pipe->plane_res.hubp = pool->hubps[i];
+			split_pipe->plane_res.ipp = pool->ipps[i];
+			split_pipe->plane_res.dpp = pool->dpps[i];
+			split_pipe->stream_res.opp = pool->opps[i];
+			split_pipe->plane_res.mpcc_inst = pool->dpps[i]->inst;
+			split_pipe->pipe_idx = i;
+
+			split_pipe->stream = stream;
 			return i;
 		}
 	}

commit 2f482c4f90983810cb8a29fd0db43a7a6a9d6cb3
Author: Chris Park <Chris.Park@amd.com>
Date:   Wed Apr 17 18:11:57 2019 -0400

    drm/amd/display: Define Byte 14 on AVI InfoFrame
    
    [Why]
    Part of HDMI 2.1 requires AVI InfoFrame version update
    from current V2 to V4 for new colorimetry.
    
    [How]
    Define V4 AVI InfoFrame ACE0-ACE3 bit.
    
    Signed-off-by: Chris Park <Chris.Park@amd.com>
    Reviewed-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9ef417eb697d..20966325852f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2384,6 +2384,13 @@ static void set_avi_info_frame(
 	hdmi_info.bits.bar_right = (stream->timing.h_total
 			- stream->timing.h_border_right + 1);
 
+    /* Additional Colorimetry Extension
+     * Used in conduction with C0-C1 and EC0-EC2
+     * 0 = DCI-P3 RGB (D65)
+     * 1 = DCI-P3 RGB (theater)
+     */
+	hdmi_info.bits.ACE0_ACE3 = 0;
+
 	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
 	check_sum = &hdmi_info.packet_raw_data.sb[0];
 

commit efa023363cdffafa839e5cc7e6fc9f38631e998d
Author: Chris Park <Chris.Park@amd.com>
Date:   Wed Apr 17 16:32:25 2019 -0400

    drm/amd/display: Support AVI InfoFrame V3 and V4
    
    [Why]
    Part of HDMI 2.1 requires AVI InfoFrame version update
    from current V2 to V3 for new VICs, and V4 for
    new colorimetry.
    
    [How]
    Implement V3 and V4 AVI InfoFrame.
    If (C1, C0)=(1, 1) and (EC2, EC1, EC0)=(1, 1, 1),
    the Source shall use 20 AVI InfoFrame Version 4.
    If VIC >= 128, the Source shall use AVI InfoFrame Version 3
    
    Signed-off-by: Chris Park <Chris.Park@amd.com>
    Reviewed-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index eac7186e4f08..9ef417eb697d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2354,7 +2354,18 @@ static void set_avi_info_frame(
 			break;
 		}
 	}
+	/* If VIC >= 128, the Source shall use AVI InfoFrame Version 3*/
 	hdmi_info.bits.VIC0_VIC7 = vic;
+	if (vic >= 128)
+		hdmi_info.bits.header.version = 3;
+	/* If (C1, C0)=(1, 1) and (EC2, EC1, EC0)=(1, 1, 1),
+	 * the Source shall use 20 AVI InfoFrame Version 4
+	 */
+	if (hdmi_info.bits.C0_C1 == COLORIMETRY_EXTENDED &&
+			hdmi_info.bits.EC0_EC2 == COLORIMETRYEX_RESERVED) {
+		hdmi_info.bits.header.version = 4;
+		hdmi_info.bits.header.length = 14;
+	}
 
 	/* pixel repetition
 	 * PR0 - PR3 start from 0 whereas pHwPathMode->mode.timing.flags.pixel
@@ -2376,9 +2387,9 @@ static void set_avi_info_frame(
 	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
 	check_sum = &hdmi_info.packet_raw_data.sb[0];
 
-	*check_sum = HDMI_INFOFRAME_TYPE_AVI + HDMI_AVI_INFOFRAME_SIZE + 2;
+	*check_sum = HDMI_INFOFRAME_TYPE_AVI + hdmi_info.bits.header.length + hdmi_info.bits.header.version;
 
-	for (byte_index = 1; byte_index <= HDMI_AVI_INFOFRAME_SIZE; byte_index++)
+	for (byte_index = 1; byte_index <= hdmi_info.bits.header.length; byte_index++)
 		*check_sum += hdmi_info.packet_raw_data.sb[byte_index];
 
 	/* one byte complement */

commit afcd526b1ba9dbc5707f9bd8d2d032ae62e337dc
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Mon Apr 1 15:18:29 2019 -0400

    drm/amd/display: Add fast_validate parameter
    
    Add a fast_validate parameter in dc_validate_global_state for future use
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 3830e6ce1355..eac7186e4f08 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2067,12 +2067,14 @@ void dc_resource_state_construct(
  * Checks HW resource availability and bandwidth requirement.
  * @dc: dc struct for this driver
  * @new_ctx: state to be validated
+ * @fast_validate: set to true if only yes/no to support matters
  *
  * Return: DC_OK if the result can be programmed.  Otherwise, an error code.
  */
 enum dc_status dc_validate_global_state(
 		struct dc *dc,
-		struct dc_state *new_ctx)
+		struct dc_state *new_ctx,
+		bool fast_validate)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	int i, j;
@@ -2127,7 +2129,7 @@ enum dc_status dc_validate_global_state(
 	result = resource_build_scaling_params_for_context(dc, new_ctx);
 
 	if (result == DC_OK)
-		if (!dc->res_pool->funcs->validate_bandwidth(dc, new_ctx))
+		if (!dc->res_pool->funcs->validate_bandwidth(dc, new_ctx, fast_validate))
 			result = DC_FAIL_BANDWIDTH_VALIDATE;
 
 	return result;

commit fe6382cd69de98802455e77040c6e00d9e12cc47
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Mar 26 13:26:37 2019 -0400

    drm/amd/display: fix is odm head pipe logic
    
    Simply return true/false, don't iterate up the tree.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f798fc28fb2a..3830e6ce1355 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1305,18 +1305,13 @@ struct pipe_ctx *dc_res_get_odm_bottom_pipe(struct pipe_ctx *pipe_ctx)
 bool dc_res_is_odm_head_pipe(struct pipe_ctx *pipe_ctx)
 {
 	struct pipe_ctx *top_pipe = pipe_ctx->top_pipe;
-	bool result = false;
 
+	if (!top_pipe)
+		return false;
 	if (top_pipe && top_pipe->stream_res.opp == pipe_ctx->stream_res.opp)
 		return false;
 
-	while (top_pipe) {
-		if (!top_pipe->top_pipe && top_pipe->stream_res.opp != pipe_ctx->stream_res.opp)
-			result = true;
-		top_pipe = top_pipe->top_pipe;
-	}
-
-	return result;
+	return true;
 }
 
 bool dc_remove_plane_from_context(

commit 0de34efc7b5f1f34676dcdd7ed8bb8a20038724d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Mar 20 17:10:41 2019 -0400

    drm/amd/display: fix clk_mgr naming
    
    clk_mgr is called dccg in dc_state, this change fixes that
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d0ed95eda508..f798fc28fb2a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2064,7 +2064,7 @@ void dc_resource_state_construct(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dst_ctx->dccg = dc->res_pool->clk_mgr;
+	dst_ctx->clk_mgr = dc->res_pool->clk_mgr;
 }
 
 /**

commit c0415c8722a43aa3f97f24ab54334107c34f9290
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Mar 15 13:59:25 2019 -0400

    drm/amd/display: fix odm output gamma programming
    
    Currently only top pipe gets output tf programmed. This change
    makes all odm head pipes get output tf programmed.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index caf9d894f95f..d0ed95eda508 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1302,7 +1302,7 @@ struct pipe_ctx *dc_res_get_odm_bottom_pipe(struct pipe_ctx *pipe_ctx)
 	return bottom_pipe;
 }
 
-static bool dc_res_is_odm_bottom_pipe(struct pipe_ctx *pipe_ctx)
+bool dc_res_is_odm_head_pipe(struct pipe_ctx *pipe_ctx)
 {
 	struct pipe_ctx *top_pipe = pipe_ctx->top_pipe;
 	bool result = false;
@@ -1345,7 +1345,7 @@ bool dc_remove_plane_from_context(
 		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
 		if (pipe_ctx->plane_state == plane_state) {
-			if (dc_res_is_odm_bottom_pipe(pipe_ctx)) {
+			if (dc_res_is_odm_head_pipe(pipe_ctx)) {
 				pipe_ctx->plane_state = NULL;
 				pipe_ctx->bottom_pipe = NULL;
 				continue;

commit 248cbed60db05f39913707c1ad74999730487fd6
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Feb 28 14:45:13 2019 -0500

    drm/amd/display: use dc_is_virtual instead of ENUM
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nevenko Stupar <Nevenko.Stupar@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 42ef04230ea2..caf9d894f95f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2788,10 +2788,11 @@ enum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 	if (!tg->funcs->validate_timing(tg, &stream->timing))
 		res = DC_FAIL_CONTROLLER_VALIDATE;
 
-	if (res == DC_OK)
+	if (res == DC_OK) {
 		if (!link->link_enc->funcs->validate_output_with_stream(
 						link->link_enc, stream))
 			res = DC_FAIL_ENC_VALIDATE;
+	}
 
 	/* TODO: validate audio ASIC caps, encoder */
 

commit d9673c920c035df8f17445d5c81142dbe4bf51a0
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Feb 13 16:20:27 2019 -0500

    drm/amd/display: Pass init_data into DCN resource creation
    
    [WHY]
    The resource constructor currently needs num_virtual_links from
    init_data but will need access to other items provided by DM.
    
    [HOW]
    Pass init_data into DCN create_resource_pool functions.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Hersen Wu <hersenxs.wu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4a651d7dd052..42ef04230ea2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -106,44 +106,43 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 	return dc_version;
 }
 
-struct resource_pool *dc_create_resource_pool(
-				struct dc  *dc,
-				int num_virtual_links,
-				enum dce_version dc_version,
-				struct hw_asic_id asic_id)
+struct resource_pool *dc_create_resource_pool(struct dc  *dc,
+					      const struct dc_init_data *init_data,
+					      enum dce_version dc_version)
 {
 	struct resource_pool *res_pool = NULL;
 
 	switch (dc_version) {
 	case DCE_VERSION_8_0:
 		res_pool = dce80_create_resource_pool(
-			num_virtual_links, dc);
+				init_data->num_virtual_links, dc);
 		break;
 	case DCE_VERSION_8_1:
 		res_pool = dce81_create_resource_pool(
-			num_virtual_links, dc);
+				init_data->num_virtual_links, dc);
 		break;
 	case DCE_VERSION_8_3:
 		res_pool = dce83_create_resource_pool(
-			num_virtual_links, dc);
+				init_data->num_virtual_links, dc);
 		break;
 	case DCE_VERSION_10_0:
 		res_pool = dce100_create_resource_pool(
-				num_virtual_links, dc);
+				init_data->num_virtual_links, dc);
 		break;
 	case DCE_VERSION_11_0:
 		res_pool = dce110_create_resource_pool(
-			num_virtual_links, dc, asic_id);
+				init_data->num_virtual_links, dc,
+				init_data->asic_id);
 		break;
 	case DCE_VERSION_11_2:
 	case DCE_VERSION_11_22:
 		res_pool = dce112_create_resource_pool(
-			num_virtual_links, dc);
+				init_data->num_virtual_links, dc);
 		break;
 	case DCE_VERSION_12_0:
 	case DCE_VERSION_12_1:
 		res_pool = dce120_create_resource_pool(
-			num_virtual_links, dc);
+				init_data->num_virtual_links, dc);
 		break;
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -151,8 +150,7 @@ struct resource_pool *dc_create_resource_pool(
 #if defined(CONFIG_DRM_AMD_DC_DCN1_01)
 	case DCN_VERSION_1_01:
 #endif
-		res_pool = dcn10_create_resource_pool(
-				num_virtual_links, dc);
+		res_pool = dcn10_create_resource_pool(init_data, dc);
 		break;
 #endif
 

commit 5581192d72337146ae8ca3128359ecd0bad0f8c7
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Mar 12 15:12:41 2019 -0400

    drm/amd/display: add preferred pipe split logic
    
    [why]
    existing logic finds "first free pipe from 5 -> 0" to split
    this will cause certain sequences to require DC to move
    an MPCC from one tree to another, which is unsupported
    this leads to blackscreen
    
    to mitigate this problem, we will always try to acquire the
    "preferred" pipe, and each pipe has a unique preferred pipe
    this means we avoid most of the scenarios where
    pipe splitting leads to moving MPCC from one tree
    to another
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 374ce43096ac..4a651d7dd052 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1038,24 +1038,60 @@ enum dc_status resource_build_scaling_params_for_context(
 
 struct pipe_ctx *find_idle_secondary_pipe(
 		struct resource_context *res_ctx,
-		const struct resource_pool *pool)
+		const struct resource_pool *pool,
+		const struct pipe_ctx *primary_pipe)
 {
 	int i;
 	struct pipe_ctx *secondary_pipe = NULL;
 
 	/*
-	 * search backwards for the second pipe to keep pipe
-	 * assignment more consistent
+	 * We add a preferred pipe mapping to avoid the chance that
+	 * MPCCs already in use will need to be reassigned to other trees.
+	 * For example, if we went with the strict, assign backwards logic:
+	 *
+	 * (State 1)
+	 * Display A on, no surface, top pipe = 0
+	 * Display B on, no surface, top pipe = 1
+	 *
+	 * (State 2)
+	 * Display A on, no surface, top pipe = 0
+	 * Display B on, surface enable, top pipe = 1, bottom pipe = 5
+	 *
+	 * (State 3)
+	 * Display A on, surface enable, top pipe = 0, bottom pipe = 5
+	 * Display B on, surface enable, top pipe = 1, bottom pipe = 4
+	 *
+	 * The state 2->3 transition requires remapping MPCC 5 from display B
+	 * to display A.
+	 *
+	 * However, with the preferred pipe logic, state 2 would look like:
+	 *
+	 * (State 2)
+	 * Display A on, no surface, top pipe = 0
+	 * Display B on, surface enable, top pipe = 1, bottom pipe = 4
+	 *
+	 * This would then cause 2->3 to not require remapping any MPCCs.
 	 */
-
-	for (i = pool->pipe_count - 1; i >= 0; i--) {
-		if (res_ctx->pipe_ctx[i].stream == NULL) {
-			secondary_pipe = &res_ctx->pipe_ctx[i];
-			secondary_pipe->pipe_idx = i;
-			break;
+	if (primary_pipe) {
+		int preferred_pipe_idx = (pool->pipe_count - 1) - primary_pipe->pipe_idx;
+		if (res_ctx->pipe_ctx[preferred_pipe_idx].stream == NULL) {
+			secondary_pipe = &res_ctx->pipe_ctx[preferred_pipe_idx];
+			secondary_pipe->pipe_idx = preferred_pipe_idx;
 		}
 	}
 
+	/*
+	 * search backwards for the second pipe to keep pipe
+	 * assignment more consistent
+	 */
+	if (!secondary_pipe)
+		for (i = pool->pipe_count - 1; i >= 0; i--) {
+			if (res_ctx->pipe_ctx[i].stream == NULL) {
+				secondary_pipe = &res_ctx->pipe_ctx[i];
+				secondary_pipe->pipe_idx = i;
+				break;
+			}
+		}
 
 	return secondary_pipe;
 }

commit d5f90f3a0ab3d8a458c3152e6b56a5845d3f7b3f
Author: Leo (Hanghong) Ma <hanghong.ma@amd.com>
Date:   Thu Mar 7 15:31:11 2019 -0500

    drm/amd/display: Expose generic SDP message access interface
    
    [Why]
    We need to add DP SDP message test debugfs to make sdp message test
    more convenient and efficient.
    
    [How]
    Add a DM accessible SDP interface for custom data.
    
    Signed-off-by: Leo (Hanghong) Ma <hanghong.ma@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 3c9df3703e46..374ce43096ac 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2394,6 +2394,21 @@ static void set_spd_info_packet(
 	*info_packet = stream->vrr_infopacket;
 }
 
+static void set_dp_sdp_info_packet(
+		struct dc_info_packet *info_packet,
+		struct dc_stream_state *stream)
+{
+	/* SPD info packet for custom sdp message */
+
+	/* Return if false. If true,
+	 * set the corresponding bit in the info packet
+	 */
+	if (!stream->dpsdp_infopacket.valid)
+		return;
+
+	*info_packet = stream->dpsdp_infopacket;
+}
+
 static void set_hdr_static_info_packet(
 		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
@@ -2490,6 +2505,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 	info->spd.valid = false;
 	info->hdrsmd.valid = false;
 	info->vsc.valid = false;
+	info->dpsdp.valid = false;
 
 	signal = pipe_ctx->stream->signal;
 
@@ -2509,6 +2525,8 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd, pipe_ctx->stream);
+
+		set_dp_sdp_info_packet(&info->dpsdp, pipe_ctx->stream);
 	}
 
 	patch_gamut_packet_checksum(&info->gamut);

commit 6ffaa6fcd06add240abe681f9b6da7fef742b85d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Mar 8 20:16:45 2019 -0500

    drm/amd/display: fix odm pipe management
    
    There are issues removing surfaces/streams when odm is active.
    This is a step to fix that
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 13f99b11aaa6..3c9df3703e46 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1251,6 +1251,40 @@ bool dc_add_plane_to_context(
 	return true;
 }
 
+struct pipe_ctx *dc_res_get_odm_bottom_pipe(struct pipe_ctx *pipe_ctx)
+{
+	struct pipe_ctx *bottom_pipe = pipe_ctx->bottom_pipe;
+
+	/* ODM should only be updated once per otg */
+	if (pipe_ctx->top_pipe)
+		return NULL;
+
+	while (bottom_pipe) {
+		if (bottom_pipe->stream_res.opp != pipe_ctx->stream_res.opp)
+			break;
+		bottom_pipe = bottom_pipe->bottom_pipe;
+	}
+
+	return bottom_pipe;
+}
+
+static bool dc_res_is_odm_bottom_pipe(struct pipe_ctx *pipe_ctx)
+{
+	struct pipe_ctx *top_pipe = pipe_ctx->top_pipe;
+	bool result = false;
+
+	if (top_pipe && top_pipe->stream_res.opp == pipe_ctx->stream_res.opp)
+		return false;
+
+	while (top_pipe) {
+		if (!top_pipe->top_pipe && top_pipe->stream_res.opp != pipe_ctx->stream_res.opp)
+			result = true;
+		top_pipe = top_pipe->top_pipe;
+	}
+
+	return result;
+}
+
 bool dc_remove_plane_from_context(
 		const struct dc *dc,
 		struct dc_stream_state *stream,
@@ -1274,10 +1308,14 @@ bool dc_remove_plane_from_context(
 
 	/* release pipe for plane*/
 	for (i = pool->pipe_count - 1; i >= 0; i--) {
-		struct pipe_ctx *pipe_ctx;
+		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-		if (context->res_ctx.pipe_ctx[i].plane_state == plane_state) {
-			pipe_ctx = &context->res_ctx.pipe_ctx[i];
+		if (pipe_ctx->plane_state == plane_state) {
+			if (dc_res_is_odm_bottom_pipe(pipe_ctx)) {
+				pipe_ctx->plane_state = NULL;
+				pipe_ctx->bottom_pipe = NULL;
+				continue;
+			}
 
 			if (pipe_ctx->top_pipe)
 				pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
@@ -1293,11 +1331,10 @@ bool dc_remove_plane_from_context(
 			 * For head pipe detach surfaces from pipe for tail
 			 * pipe just zero it out
 			 */
-			if (!pipe_ctx->top_pipe || (!pipe_ctx->top_pipe->top_pipe &&
-					pipe_ctx->top_pipe->stream_res.opp != pipe_ctx->stream_res.opp)) {
-				pipe_ctx->top_pipe = NULL;
+			if (!pipe_ctx->top_pipe) {
 				pipe_ctx->plane_state = NULL;
-				pipe_ctx->bottom_pipe = NULL;
+				if (!dc_res_get_odm_bottom_pipe(pipe_ctx))
+					pipe_ctx->bottom_pipe = NULL;
 			} else {
 				memset(pipe_ctx, 0, sizeof(*pipe_ctx));
 			}
@@ -1703,6 +1740,9 @@ enum dc_status dc_remove_stream_from_ctx(
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream &&
 				!new_ctx->res_ctx.pipe_ctx[i].top_pipe) {
+			struct pipe_ctx *odm_pipe =
+					dc_res_get_odm_bottom_pipe(&new_ctx->res_ctx.pipe_ctx[i]);
+
 			del_pipe = &new_ctx->res_ctx.pipe_ctx[i];
 
 			ASSERT(del_pipe->stream_res.stream_enc);
@@ -1727,6 +1767,10 @@ enum dc_status dc_remove_stream_from_ctx(
 				dc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);
 
 			memset(del_pipe, 0, sizeof(*del_pipe));
+			if (odm_pipe)
+				memset(odm_pipe, 0, sizeof(*odm_pipe));
+
+			break;
 		}
 	}
 

commit f25f06b67ba237b76092a6fc522b1a94e84bfa85
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Mar 8 16:44:53 2019 -0500

    drm/amd/display: fix odm combine pipe reset
    
    We fail to reset the second odm combine pipe. This change fixes
    odm pointer management.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ec0e2ad5f1c3..13f99b11aaa6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1293,9 +1293,9 @@ bool dc_remove_plane_from_context(
 			 * For head pipe detach surfaces from pipe for tail
 			 * pipe just zero it out
 			 */
-			if (!pipe_ctx->top_pipe ||
-				(!pipe_ctx->top_pipe->top_pipe &&
+			if (!pipe_ctx->top_pipe || (!pipe_ctx->top_pipe->top_pipe &&
 					pipe_ctx->top_pipe->stream_res.opp != pipe_ctx->stream_res.opp)) {
+				pipe_ctx->top_pipe = NULL;
 				pipe_ctx->plane_state = NULL;
 				pipe_ctx->bottom_pipe = NULL;
 			} else {
@@ -1727,8 +1727,6 @@ enum dc_status dc_remove_stream_from_ctx(
 				dc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);
 
 			memset(del_pipe, 0, sizeof(*del_pipe));
-
-			break;
 		}
 	}
 

commit bc2193992b00488f5734613ac95b78ef2d2803ab
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Mar 7 13:26:13 2019 -0500

    drm/amd/display: fix releasing planes when exiting odm
    
    Releasing planes should not release the 2nd odm pipe right away,
    this change leaves us with 2 pipes with null planes and same stream
    when planes are released during odm.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 79e760ac3600..ec0e2ad5f1c3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1293,10 +1293,12 @@ bool dc_remove_plane_from_context(
 			 * For head pipe detach surfaces from pipe for tail
 			 * pipe just zero it out
 			 */
-			if (!pipe_ctx->top_pipe) {
+			if (!pipe_ctx->top_pipe ||
+				(!pipe_ctx->top_pipe->top_pipe &&
+					pipe_ctx->top_pipe->stream_res.opp != pipe_ctx->stream_res.opp)) {
 				pipe_ctx->plane_state = NULL;
 				pipe_ctx->bottom_pipe = NULL;
-			} else  {
+			} else {
 				memset(pipe_ctx, 0, sizeof(*pipe_ctx));
 			}
 		}

commit 33d7598d7022eac064b48e42dd4ae3e1dc9b52cd
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Feb 22 16:50:00 2019 -0500

    drm/amd/display: fix up reference clock abstractions
    
    [why]
    "reference clock" is a very overloaded variable in DC and causes confusion
    as there are multiple sources of reference clock, which may be different values
    incorrect input values to DML will cause DCHUB to be programmed improperly
    and lead to hard to debug underflow issues
    
    [how]
    instead of using ref clock everywhere, specify WHICH ref clock:
    - xtalin
    - dccg refclk
    - dchub refclk
    
    these are all distinct values which may not be equal
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 144440203316..79e760ac3600 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -31,6 +31,8 @@
 #include "opp.h"
 #include "timing_generator.h"
 #include "transform.h"
+#include "dccg.h"
+#include "dchubbub.h"
 #include "dpp.h"
 #include "core_types.h"
 #include "set_mode_types.h"
@@ -163,7 +165,28 @@ struct resource_pool *dc_create_resource_pool(
 
 		if (dc->ctx->dc_bios->funcs->get_firmware_info(
 				dc->ctx->dc_bios, &fw_info) == BP_RESULT_OK) {
-				res_pool->ref_clock_inKhz = fw_info.pll_info.crystal_frequency;
+				res_pool->ref_clocks.xtalin_clock_inKhz = fw_info.pll_info.crystal_frequency;
+
+				if (IS_FPGA_MAXIMUS_DC(dc->ctx->dce_environment)) {
+					// On FPGA these dividers are currently not configured by GDB
+					res_pool->ref_clocks.dccg_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
+					res_pool->ref_clocks.dchub_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
+				} else if (res_pool->dccg && res_pool->hubbub) {
+					// If DCCG reference frequency cannot be determined (usually means not set to xtalin) then this is a critical error
+					// as this value must be known for DCHUB programming
+					(res_pool->dccg->funcs->get_dccg_ref_freq)(res_pool->dccg,
+							fw_info.pll_info.crystal_frequency,
+							&res_pool->ref_clocks.dccg_ref_clock_inKhz);
+
+					// Similarly, if DCHUB reference frequency cannot be determined, then it is also a critical error
+					(res_pool->hubbub->funcs->get_dchub_ref_freq)(res_pool->hubbub,
+							res_pool->ref_clocks.dccg_ref_clock_inKhz,
+							&res_pool->ref_clocks.dchub_ref_clock_inKhz);
+				} else {
+					// Not all ASICs have DCCG sw component
+					res_pool->ref_clocks.dccg_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
+					res_pool->ref_clocks.dchub_ref_clock_inKhz = res_pool->ref_clocks.xtalin_clock_inKhz;
+				}
 			} else
 				ASSERT_CRITICAL(false);
 	}

commit 929c3aaa26ef69abdb5e5ec7af5eacd6f6687836
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Wed Feb 13 17:56:38 2019 -0500

    drm/amd/display: Free DCN version of stream encoder
    
    Cross a TODO item off the list. Cleanup SIGNAL_TYPE_HDMI_FRL, it's
    not currently supported.
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7f3c7defb540..144440203316 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -260,6 +260,7 @@ bool resource_construct(
 			pool->stream_enc_count++;
 		}
 	}
+
 	dc->caps.dynamic_audio = false;
 	if (pool->audio_count < pool->stream_enc_count) {
 		dc->caps.dynamic_audio = true;

commit 46570f090469c8c453622523ae5ccede256148f5
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Fri Feb 8 20:50:51 2019 -0500

    drm/amd/display: Keep clocks high before seamless boot done
    
    [Why]
    UEFI boot usually uses a boot profile that uses higher clocks
    and watermark settings.
    UEFI boot surface is less optimal, for example it uses linear surface
    
    [How]
    Before we finish our seamless boot sequence, keep the clock and
    watermark settings from boot.
    Update to optimal settings only after first flip away from UEFI
    frame buffer.
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0c3e8663d7b4..7f3c7defb540 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1858,6 +1858,7 @@ enum dc_status resource_map_pool_resources(
 	struct dc_context *dc_ctx = dc->ctx;
 	struct pipe_ctx *pipe_ctx = NULL;
 	int pipe_idx = -1;
+	struct dc_bios *dcb = dc->ctx->dc_bios;
 
 	/* TODO Check if this is needed */
 	/*if (!resource_is_stream_unchanged(old_context, stream)) {
@@ -1872,6 +1873,13 @@ enum dc_status resource_map_pool_resources(
 
 	calculate_phy_pix_clks(stream);
 
+	/* TODO: Check Linux */
+	if (dc->config.allow_seamless_boot_optimization &&
+			!dcb->funcs->is_accelerated_mode(dcb)) {
+		if (dc_validate_seamless_boot_timing(dc, stream->sink, &stream->timing))
+			stream->apply_seamless_boot_optimization = true;
+	}
+
 	if (stream->apply_seamless_boot_optimization)
 		pipe_idx = acquire_resource_from_hw_enabled_state(
 				&context->res_ctx,

commit 4a797d24fe0dc75063e8cfc312d20abff8a0ea99
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Feb 1 07:31:47 2019 -0500

    drm/amd/display: Allow for plane-less resource reservation
    
    This change changes dc add plane logic to allow plane-less resource
    reservation (pipe split).
    
    If a free pipe_ctx (no plane_state attached) is the head pipe, and is
    found with a bottom pipe attached, assign the plane to add on the bottom
    pipe.
    
    In addition, prepend dcn10 to dcn10-specific reset_back_end_for_pipe
    and reset_hw_ctx_wrap
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 349ab8017776..0c3e8663d7b4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1214,6 +1214,9 @@ bool dc_add_plane_to_context(
 		free_pipe->clock_source = tail_pipe->clock_source;
 		free_pipe->top_pipe = tail_pipe;
 		tail_pipe->bottom_pipe = free_pipe;
+	} else if (free_pipe->bottom_pipe && free_pipe->bottom_pipe->plane_state == NULL) {
+		ASSERT(free_pipe->bottom_pipe->stream_res.opp != free_pipe->stream_res.opp);
+		free_pipe->bottom_pipe->plane_state = plane_state;
 	}
 
 	/* assign new surfaces*/

commit d2d7885f75b614a982a73383956570d95d79c23e
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sun Jan 20 01:41:44 2019 -0500

    drm/amd/display: add seamless boot flag to stream
    
    [Why]
    If we determine the stream we are trying to commit
    matches HW, we want to try to optimize.
    
    [How]
    Try to acquire the HW resources that are already enabled
    and optimize.
    Also skip backend reprogramming
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9888bc7659f3..349ab8017776 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1800,6 +1800,51 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 		stream->phy_pix_clk *= 2;
 }
 
+static int acquire_resource_from_hw_enabled_state(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
+		struct dc_stream_state *stream)
+{
+	struct dc_link *link = stream->link;
+	unsigned int inst;
+
+	/* Check for enabled DIG to identify enabled display */
+	if (!link->link_enc->funcs->is_dig_enabled(link->link_enc))
+		return -1;
+
+	/* Check for which front end is used by this encoder.
+	 * Note the inst is 1 indexed, where 0 is undefined.
+	 * Note that DIG_FE can source from different OTG but our
+	 * current implementation always map 1-to-1, so this code makes
+	 * the same assumption and doesn't check OTG source.
+	 */
+	inst = link->link_enc->funcs->get_dig_frontend(link->link_enc) - 1;
+
+	/* Instance should be within the range of the pool */
+	if (inst >= pool->pipe_count)
+		return -1;
+
+	if (!res_ctx->pipe_ctx[inst].stream) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[inst];
+
+		pipe_ctx->stream_res.tg = pool->timing_generators[inst];
+		pipe_ctx->plane_res.mi = pool->mis[inst];
+		pipe_ctx->plane_res.hubp = pool->hubps[inst];
+		pipe_ctx->plane_res.ipp = pool->ipps[inst];
+		pipe_ctx->plane_res.xfm = pool->transforms[inst];
+		pipe_ctx->plane_res.dpp = pool->dpps[inst];
+		pipe_ctx->stream_res.opp = pool->opps[inst];
+		if (pool->dpps[inst])
+			pipe_ctx->plane_res.mpcc_inst = pool->dpps[inst]->inst;
+		pipe_ctx->pipe_idx = inst;
+
+		pipe_ctx->stream = stream;
+		return inst;
+	}
+
+	return -1;
+}
+
 enum dc_status resource_map_pool_resources(
 		const struct dc  *dc,
 		struct dc_state *context,
@@ -1824,8 +1869,15 @@ enum dc_status resource_map_pool_resources(
 
 	calculate_phy_pix_clks(stream);
 
-	/* acquire new resources */
-	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
+	if (stream->apply_seamless_boot_optimization)
+		pipe_idx = acquire_resource_from_hw_enabled_state(
+				&context->res_ctx,
+				pool,
+				stream);
+
+	if (pipe_idx < 0)
+		/* acquire new resources */
+		pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
 #ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	if (pipe_idx < 0)

commit 38684e46ef6622f25f141727fd9a9733b43eaf55
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Thu Nov 22 17:04:14 2018 -0500

    drm/amd/display: Improve logging of validation failures during atomic_check
    
    [Why]
    There are different reasons for Validation failure error during
    atomic_check
    
    [How]
    Add better logging of the reason for validation failure
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 98f0fca0b08d..9888bc7659f3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1842,7 +1842,7 @@ enum dc_status resource_map_pool_resources(
 			&context->res_ctx, pool, stream);
 
 	if (!pipe_ctx->stream_res.stream_enc)
-		return DC_NO_STREAM_ENG_RESOURCE;
+		return DC_NO_STREAM_ENC_RESOURCE;
 
 	update_stream_engine_usage(
 		&context->res_ctx, pool,

commit 380604e27bc9c26ce64a83044aa1ea76ffd28caf
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Tue Nov 6 14:24:12 2018 -0500

    drm/amd/display: Use 100 Hz precision for pipe pixel clocks
    
    [Why]
    Users would like more accurate pixel clocks, especially for fractional
    "TV" frame rates like 59.94 Hz.
    
    [How]
    Store and communicate pixel clocks with 100 Hz accuracy from
    dc_crtc_timing through to BIOS command table setpixelclock call.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 188cf4fa5cf0..98f0fca0b08d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -355,8 +355,8 @@ bool resource_are_streams_timing_synchronizable(
 				!= stream2->timing.v_addressable)
 		return false;
 
-	if (stream1->timing.pix_clk_khz
-				!= stream2->timing.pix_clk_khz)
+	if (stream1->timing.pix_clk_100hz
+				!= stream2->timing.pix_clk_100hz)
 		return false;
 
 	if (stream1->clamping.c_depth != stream2->clamping.c_depth)
@@ -1759,7 +1759,7 @@ static struct dc_stream_state *find_pll_sharable_stream(
 
 static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 {
-	uint32_t pix_clk = timing->pix_clk_khz;
+	uint32_t pix_clk = timing->pix_clk_100hz;
 	uint32_t normalized_pix_clk = pix_clk;
 
 	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
@@ -1791,10 +1791,10 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 	/* update actual pixel clock on all streams */
 	if (dc_is_hdmi_signal(stream->signal))
 		stream->phy_pix_clk = get_norm_pix_clk(
-			&stream->timing);
+			&stream->timing) / 10;
 	else
 		stream->phy_pix_clk =
-			stream->timing.pix_clk_khz;
+			stream->timing.pix_clk_100hz / 10;
 
 	if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)
 		stream->phy_pix_clk *= 2;

commit ceb3dbb4690db8377ad127a5666cd4775d9f70f4
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Fri Nov 9 09:21:21 2018 -0500

    drm/amd/display: remove sink reference in dc_stream_state
    
    [why]
    dc_stream_state containing a pointer to sink is poor design.
    Sink describes the display, and the specifications or capabilities
    it has.  That information is irrelevant for dc_stream_state, which describes
    hardware state, and is generally used for hardware programming.  It
    could further be argued that dc_sink itself is just a convenience dc
    provides, and DC should be perfectly capable of programming hardware
    without any dc_sinks (for example, emulated sinks).
    
    [how]
    Phase 1:
    Deprecate use of dc_sink pointer in dc_stream.  Most references are trivial
    to remove, but some call sites are risky (such as is_timing_changed) with
    no obvious logical replacement.  These will be removed in follow up change.
    
    Add dc_link pointer to dc_stream.  This is the typical reason DC really needed
    sink pointer, and most call sites are replaced with this.
    
    DMs also need minor updates, as all 3 DMs leverage stream->sink for
    some functionality.  this is replaced instead by a pointer to private data
    inside dc_stream_state, which is used by DMs as a quality of life improvment
    for some key functionality.  it allows DMs to set pointers have to their own objects
    which associate OS objects to dc_stream_states (such as DisplayTarget
    and amdgpu_dm_connector).  Without the private pointer, DMs would be
    forced to perform a lookup for callbacks.
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 76137df74a53..188cf4fa5cf0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1559,7 +1559,7 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 {
 	int i;
 	int j = -1;
-	struct dc_link *link = stream->sink->link;
+	struct dc_link *link = stream->link;
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (!res_ctx->is_stream_enc_acquired[i] &&
@@ -1748,7 +1748,7 @@ static struct dc_stream_state *find_pll_sharable_stream(
 		if (resource_are_streams_timing_synchronizable(
 			stream_needs_pll, stream_has_pll)
 			&& !dc_is_dp_signal(stream_has_pll->signal)
-			&& stream_has_pll->sink->link->connector_signal
+			&& stream_has_pll->link->connector_signal
 			!= SIGNAL_TYPE_VIRTUAL)
 			return stream_has_pll;
 
@@ -1850,7 +1850,7 @@ enum dc_status resource_map_pool_resources(
 		true);
 
 	/* TODO: Add check if ASIC support and EDID audio */
-	if (!stream->sink->converter_disable_audio &&
+	if (!stream->converter_disable_audio &&
 	    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 	    stream->audio_info.mode_count) {
 		pipe_ctx->stream_res.audio = find_first_free_audio(
@@ -2112,7 +2112,7 @@ static void set_avi_info_frame(
 	itc = true;
 	itc_value = 1;
 
-	support = stream->sink->edid_caps.content_support;
+	support = stream->content_support;
 
 	if (itc) {
 		if (!support.bits.valid_content_type) {
@@ -2151,8 +2151,8 @@ static void set_avi_info_frame(
 
 	/* TODO : We should handle YCC quantization */
 	/* but we do not have matrix calculation */
-	if (stream->sink->edid_caps.qs_bit == 1 &&
-			stream->sink->edid_caps.qy_bit == 1) {
+	if (stream->qs_bit == 1 &&
+			stream->qy_bit == 1) {
 		if (color_space == COLOR_SPACE_SRGB ||
 			color_space == COLOR_SPACE_2020_RGB_FULLRANGE) {
 			hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
@@ -2596,7 +2596,7 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 enum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 {
 	struct dc  *core_dc = dc;
-	struct dc_link *link = stream->sink->link;
+	struct dc_link *link = stream->link;
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
 

commit b8b6ce89016485cb92fdf2f527b40249aefbc470
Author: Leo Li <sunpeng.li@amd.com>
Date:   Wed Oct 31 16:56:54 2018 -0400

    drm/amd/display: Add DCE_VERSION_12_1 enum for Vega 20
    
    [Why]
    We'll need a way to differentiate Vega 20 in DC
    
    [How]
    Add a DCE_VERSION_12_1 enum, which will be returned as the DC version if
    the ASIC used is a Vega 20.
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Reviewed-by: David Francis <David.Francis@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c347afd1030f..76137df74a53 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -83,7 +83,10 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 			dc_version = DCE_VERSION_11_22;
 		break;
 	case FAMILY_AI:
-		dc_version = DCE_VERSION_12_0;
+		if (ASICREV_IS_VEGA20_P(asic_id.hw_internal_rev))
+			dc_version = DCE_VERSION_12_1;
+		else
+			dc_version = DCE_VERSION_12_0;
 		break;
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case FAMILY_RV:
@@ -136,6 +139,7 @@ struct resource_pool *dc_create_resource_pool(
 			num_virtual_links, dc);
 		break;
 	case DCE_VERSION_12_0:
+	case DCE_VERSION_12_1:
 		res_pool = dce120_create_resource_pool(
 			num_virtual_links, dc);
 		break;

commit ecd0136bfdb5a28b8a869c305823df9d663e85ee
Author: Harmanprit Tatla <Harmanprit.Tatla@amd.com>
Date:   Mon Nov 5 17:55:53 2018 -0500

    drm/amd/display: Info frame cleanup
    
    * Use provided infopacket in stream (if valid) instead of reconstructing
      in set_vendor_info_packet()
    * Use proper format for enums
    * Use dc info packet struct instead
    
    Signed-off-by: Harmanprit Tatla <Harmanprit.Tatla@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d4fd1d1357fe..c347afd1030f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2233,113 +2233,15 @@ static void set_vendor_info_packet(
 		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
-	uint32_t length = 0;
-	bool hdmi_vic_mode = false;
-	uint8_t checksum = 0;
-	uint32_t i = 0;
-	enum dc_timing_3d_format format;
-	// Can be different depending on packet content /*todo*/
-	// unsigned int length = pPathMode->dolbyVision ? 24 : 5;
-
-	info_packet->valid = false;
-
-	format = stream->timing.timing_3d_format;
-	if (stream->view_format == VIEW_3D_FORMAT_NONE)
-		format = TIMING_3D_FORMAT_NONE;
-
-	/* Can be different depending on packet content */
-	length = 5;
-
-	if (stream->timing.hdmi_vic != 0
-			&& stream->timing.h_total >= 3840
-			&& stream->timing.v_total >= 2160)
-		hdmi_vic_mode = true;
-
-	/* According to HDMI 1.4a CTS, VSIF should be sent
-	 * for both 3D stereo and HDMI VIC modes.
-	 * For all other modes, there is no VSIF sent.  */
+	/* SPD info packet for FreeSync */
 
-	if (format == TIMING_3D_FORMAT_NONE && !hdmi_vic_mode)
+	/* Check if Freesync is supported. Return if false. If true,
+	 * set the corresponding bit in the info packet
+	 */
+	if (!stream->vsp_infopacket.valid)
 		return;
 
-	/* 24bit IEEE Registration identifier (0x000c03). LSB first. */
-	info_packet->sb[1] = 0x03;
-	info_packet->sb[2] = 0x0C;
-	info_packet->sb[3] = 0x00;
-
-	/*PB4: 5 lower bytes = 0 (reserved). 3 higher bits = HDMI_Video_Format.
-	 * The value for HDMI_Video_Format are:
-	 * 0x0 (0b000) - No additional HDMI video format is presented in this
-	 * packet
-	 * 0x1 (0b001) - Extended resolution format present. 1 byte of HDMI_VIC
-	 * parameter follows
-	 * 0x2 (0b010) - 3D format indication present. 3D_Structure and
-	 * potentially 3D_Ext_Data follows
-	 * 0x3..0x7 (0b011..0b111) - reserved for future use */
-	if (format != TIMING_3D_FORMAT_NONE)
-		info_packet->sb[4] = (2 << 5);
-	else if (hdmi_vic_mode)
-		info_packet->sb[4] = (1 << 5);
-
-	/* PB5: If PB4 claims 3D timing (HDMI_Video_Format = 0x2):
-	 * 4 lower bites = 0 (reserved). 4 higher bits = 3D_Structure.
-	 * The value for 3D_Structure are:
-	 * 0x0 - Frame Packing
-	 * 0x1 - Field Alternative
-	 * 0x2 - Line Alternative
-	 * 0x3 - Side-by-Side (full)
-	 * 0x4 - L + depth
-	 * 0x5 - L + depth + graphics + graphics-depth
-	 * 0x6 - Top-and-Bottom
-	 * 0x7 - Reserved for future use
-	 * 0x8 - Side-by-Side (Half)
-	 * 0x9..0xE - Reserved for future use
-	 * 0xF - Not used */
-	switch (format) {
-	case TIMING_3D_FORMAT_HW_FRAME_PACKING:
-	case TIMING_3D_FORMAT_SW_FRAME_PACKING:
-		info_packet->sb[5] = (0x0 << 4);
-		break;
-
-	case TIMING_3D_FORMAT_SIDE_BY_SIDE:
-	case TIMING_3D_FORMAT_SBS_SW_PACKED:
-		info_packet->sb[5] = (0x8 << 4);
-		length = 6;
-		break;
-
-	case TIMING_3D_FORMAT_TOP_AND_BOTTOM:
-	case TIMING_3D_FORMAT_TB_SW_PACKED:
-		info_packet->sb[5] = (0x6 << 4);
-		break;
-
-	default:
-		break;
-	}
-
-	/*PB5: If PB4 is set to 0x1 (extended resolution format)
-	 * fill PB5 with the correct HDMI VIC code */
-	if (hdmi_vic_mode)
-		info_packet->sb[5] = stream->timing.hdmi_vic;
-
-	/* Header */
-	info_packet->hb0 = HDMI_INFOFRAME_TYPE_VENDOR; /* VSIF packet type. */
-	info_packet->hb1 = 0x01; /* Version */
-
-	/* 4 lower bits = Length, 4 higher bits = 0 (reserved) */
-	info_packet->hb2 = (uint8_t) (length);
-
-	/* Calculate checksum */
-	checksum = 0;
-	checksum += info_packet->hb0;
-	checksum += info_packet->hb1;
-	checksum += info_packet->hb2;
-
-	for (i = 1; i <= length; i++)
-		checksum += info_packet->sb[i];
-
-	info_packet->sb[0] = (uint8_t) (0x100 - checksum);
-
-	info_packet->valid = true;
+	*info_packet = stream->vsp_infopacket;
 }
 
 static void set_spd_info_packet(

commit 2119aa17c963e59710617c70bb7b59e89c5ff447
Author: David Francis <David.Francis@amd.com>
Date:   Tue Oct 9 09:45:28 2018 -0400

    drm/amd/display: Start documentation of DC
    
    [Why]
    There are a lot of unintuitive parts of the dm-dc interface.
    It would help us if these were documented to provide
    a common understanding of what they are supposed to do
    
    [How]
    Most of this documentation is stubs, to be filled out more
    thoroughly by the experts
    
    Not every dm-accessible function and struct is mentioned.
    Simple functions like getters, setters, retain, release,
    create, destroy can be left unadorned.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0bb844a7b990..d4fd1d1357fe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1447,6 +1447,14 @@ static bool are_stream_backends_same(
 	return true;
 }
 
+/**
+ * dc_is_stream_unchanged() - Compare two stream states for equivalence.
+ *
+ * Checks if there a difference between the two states
+ * that would require a mode change.
+ *
+ * Does not compare cursor position or attributes.
+ */
 bool dc_is_stream_unchanged(
 	struct dc_stream_state *old_stream, struct dc_stream_state *stream)
 {
@@ -1457,6 +1465,9 @@ bool dc_is_stream_unchanged(
 	return true;
 }
 
+/**
+ * dc_is_stream_scaling_unchanged() - Compare scaling rectangles of two streams.
+ */
 bool dc_is_stream_scaling_unchanged(
 	struct dc_stream_state *old_stream, struct dc_stream_state *stream)
 {
@@ -1616,6 +1627,9 @@ bool resource_is_stream_unchanged(
 	return false;
 }
 
+/**
+ * dc_add_stream_to_ctx() - Add a new dc_stream_state to a dc_state.
+ */
 enum dc_status dc_add_stream_to_ctx(
 		struct dc *dc,
 		struct dc_state *new_ctx,
@@ -1640,6 +1654,9 @@ enum dc_status dc_add_stream_to_ctx(
 	return res;
 }
 
+/**
+ * dc_remove_stream_from_ctx() - Remove a stream from a dc_state.
+ */
 enum dc_status dc_remove_stream_from_ctx(
 			struct dc *dc,
 			struct dc_state *new_ctx,
@@ -1860,6 +1877,12 @@ enum dc_status resource_map_pool_resources(
 	return DC_ERROR_UNEXPECTED;
 }
 
+/**
+ * dc_resource_state_copy_construct_current() - Creates a new dc_state from existing state
+ * Is a shallow copy.  Increments refcounts on existing streams and planes.
+ * @dc: copy out of dc->current_state
+ * @dst_ctx: copy into this
+ */
 void dc_resource_state_copy_construct_current(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
@@ -1875,6 +1898,14 @@ void dc_resource_state_construct(
 	dst_ctx->dccg = dc->res_pool->clk_mgr;
 }
 
+/**
+ * dc_validate_global_state() - Determine if HW can support a given state
+ * Checks HW resource availability and bandwidth requirement.
+ * @dc: dc struct for this driver
+ * @new_ctx: state to be validated
+ *
+ * Return: DC_OK if the result can be programmed.  Otherwise, an error code.
+ */
 enum dc_status dc_validate_global_state(
 		struct dc *dc,
 		struct dc_state *new_ctx)
@@ -2364,10 +2395,6 @@ void dc_resource_state_destruct(struct dc_state *context)
 	}
 }
 
-/*
- * Copy src_ctx into dst_ctx and retain all surfaces and streams referenced
- * by the src_ctx
- */
 void dc_resource_state_copy_construct(
 		const struct dc_state *src_ctx,
 		struct dc_state *dst_ctx)

commit 00737c59a231a4eab955f6cd53c88e7c6449abd0
Author: Eric Bernstein <eric.bernstein@amd.com>
Date:   Mon Oct 29 16:05:47 2018 -0400

    drm/amd/display: get tail pipe before aquire free pipe
    
    [Why]
    For some complicated blending transition cases, the head
    pipe of the second stream may end up being a higher pipe
    index than the free pipe.  In those cases dc_add_plane_to_context
    will incorrectly set the tail_pipe to the free pipe, which
    will cause the top_pipe and bottom_pipe to be the same
    
    [How]
    Move the call to resource_get_tail_pipe_for_stream() to be
    before call to acquire_free_pipe_for_stream().
    
    Signed-off-by: Eric Bernstein <eric.bernstein@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0a1985ca9882..0bb844a7b990 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1182,6 +1182,9 @@ bool dc_add_plane_to_context(
 		return false;
 	}
 
+	tail_pipe = resource_get_tail_pipe_for_stream(&context->res_ctx, stream);
+	ASSERT(tail_pipe);
+
 	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -1199,10 +1202,6 @@ bool dc_add_plane_to_context(
 	free_pipe->plane_state = plane_state;
 
 	if (head_pipe != free_pipe) {
-
-		tail_pipe = resource_get_tail_pipe_for_stream(&context->res_ctx, stream);
-		ASSERT(tail_pipe);
-
 		free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
 		free_pipe->stream_res.abm = tail_pipe->stream_res.abm;
 		free_pipe->stream_res.opp = tail_pipe->stream_res.opp;

commit 9b6067c08de84215d4c66a74150e9ac3e9f0ef72
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Oct 19 16:17:29 2018 -0400

    drm/amd/display: redesign scaling rotation math
    
    Change the math to work in viewport rotation when calculating
    viewport and viewport adjustment. This simplifies the math
    for viewport calculation and makes viewport adjustment easier to
    understand.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 98bc298ec948..0a1985ca9882 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -478,10 +478,29 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 	return dal_pixel_format;
 }
 
-static void rect_swap_helper(struct rect *rect)
-{
-	swap(rect->height, rect->width);
-	swap(rect->x, rect->y);
+static inline void get_vp_scan_direction(
+	enum dc_rotation_angle rotation,
+	bool horizontal_mirror,
+	bool *orthogonal_rotation,
+	bool *flip_vert_scan_dir,
+	bool *flip_horz_scan_dir)
+{
+	*orthogonal_rotation = false;
+	*flip_vert_scan_dir = false;
+	*flip_horz_scan_dir = false;
+	if (rotation == ROTATION_ANGLE_180) {
+		*flip_vert_scan_dir = true;
+		*flip_horz_scan_dir = true;
+	} else if (rotation == ROTATION_ANGLE_90) {
+		*orthogonal_rotation = true;
+		*flip_horz_scan_dir = true;
+	} else if (rotation == ROTATION_ANGLE_270) {
+		*orthogonal_rotation = true;
+		*flip_vert_scan_dir = true;
+	}
+
+	if (horizontal_mirror)
+		*flip_horz_scan_dir = !*flip_horz_scan_dir;
 }
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
@@ -490,33 +509,14 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
 	struct rect surf_src = plane_state->src_rect;
-	struct rect clip = { 0 };
+	struct rect clip, dest;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 	bool pri_split = pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
-	bool flip_vert_scan_dir = false, flip_horz_scan_dir = false;
-
-
-	/*
-	 * We need take horizontal mirror into account. On an unrotated surface this means
-	 * that the viewport offset is actually the offset from the other side of source
-	 * image so we have to subtract the right edge of the viewport from the right edge of
-	 * the source window. Similar to mirror we need to take into account how offset is
-	 * affected for 270/180 rotations
-	 */
-	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_180) {
-		flip_vert_scan_dir = true;
-		flip_horz_scan_dir = true;
-	} else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90)
-		flip_vert_scan_dir = true;
-	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
-		flip_horz_scan_dir = true;
-
-	if (pipe_ctx->plane_state->horizontal_mirror)
-		flip_horz_scan_dir = !flip_horz_scan_dir;
+	bool orthogonal_rotation, flip_y_start, flip_x_start;
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
@@ -524,13 +524,10 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		sec_split = false;
 	}
 
-	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
-		rect_swap_helper(&surf_src);
-
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
+	dest = plane_state->dst_rect;
 	clip.x = stream->src.x > plane_state->clip_rect.x ?
 			stream->src.x : plane_state->clip_rect.x;
 
@@ -547,66 +544,77 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			stream->src.y + stream->src.height - clip.y :
 			plane_state->clip_rect.y + plane_state->clip_rect.height - clip.y ;
 
-	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
-	 * note: surf_src.ofs should be added after rotation/mirror offset direction
-	 *       adjustment since it is already in viewport space
-	 * num_pixels = clip.num_pix * scl_ratio
+	/*
+	 * Need to calculate how scan origin is shifted in vp space
+	 * to correctly rotate clip and dst
 	 */
-	data->viewport.x = (clip.x - plane_state->dst_rect.x) *
-			surf_src.width / plane_state->dst_rect.width;
-	data->viewport.width = clip.width *
-			surf_src.width / plane_state->dst_rect.width;
+	get_vp_scan_direction(
+			plane_state->rotation,
+			plane_state->horizontal_mirror,
+			&orthogonal_rotation,
+			&flip_y_start,
+			&flip_x_start);
 
-	data->viewport.y = (clip.y - plane_state->dst_rect.y) *
-			surf_src.height / plane_state->dst_rect.height;
-	data->viewport.height = clip.height *
-			surf_src.height / plane_state->dst_rect.height;
-
-	if (flip_vert_scan_dir)
-		data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
-	if (flip_horz_scan_dir)
-		data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
+	if (orthogonal_rotation) {
+		swap(clip.x, clip.y);
+		swap(clip.width, clip.height);
+		swap(dest.x, dest.y);
+		swap(dest.width, dest.height);
+	}
+	if (flip_x_start) {
+		clip.x = dest.x + dest.width - clip.x - clip.width;
+		dest.x = 0;
+	}
+	if (flip_y_start) {
+		clip.y = dest.y + dest.height - clip.y - clip.height;
+		dest.y = 0;
+	}
 
-	data->viewport.x += surf_src.x;
-	data->viewport.y += surf_src.y;
+	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
+	 * num_pixels = clip.num_pix * scl_ratio
+	 */
+	data->viewport.x = surf_src.x + (clip.x - dest.x) * surf_src.width / dest.width;
+	data->viewport.width = clip.width * surf_src.width / dest.width;
+
+	data->viewport.y = surf_src.y + (clip.y - dest.y) * surf_src.height / dest.height;
+	data->viewport.height = clip.height * surf_src.height / dest.height;
+
+	/* Handle split */
+	if (pri_split || sec_split) {
+		if (orthogonal_rotation) {
+			if (flip_y_start != pri_split)
+				data->viewport.height /= 2;
+			else {
+				data->viewport.y +=  data->viewport.height / 2;
+				/* Ceil offset pipe */
+				data->viewport.height = (data->viewport.height + 1) / 2;
+			}
+		} else {
+			if (flip_x_start != pri_split)
+				data->viewport.width /= 2;
+			else {
+				data->viewport.x +=  data->viewport.width / 2;
+				/* Ceil offset pipe */
+				data->viewport.width = (data->viewport.width + 1) / 2;
+			}
+		}
+	}
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
 	data->viewport_c.y = data->viewport.y / vpc_div;
-	data->inits.h_c = (data->viewport.x % vpc_div) != 0 ?
-			dc_fixpt_half : dc_fixpt_zero;
-	data->inits.v_c = (data->viewport.y % vpc_div) != 0 ?
-			dc_fixpt_half : dc_fixpt_zero;
+	data->inits.h_c = (data->viewport.x % vpc_div) != 0 ? dc_fixpt_half : dc_fixpt_zero;
+	data->inits.v_c = (data->viewport.y % vpc_div) != 0 ? dc_fixpt_half : dc_fixpt_zero;
+
 	/* Round up, assume original video size always even dimensions */
 	data->viewport_c.width = (data->viewport.width + vpc_div - 1) / vpc_div;
 	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
-
-	/* Handle hsplit */
-	if (sec_split) {
-		data->viewport.x +=  data->viewport.width / 2;
-		data->viewport_c.x +=  data->viewport_c.width / 2;
-		/* Ceil offset pipe */
-		data->viewport.width = (data->viewport.width + 1) / 2;
-		data->viewport_c.width = (data->viewport_c.width + 1) / 2;
-	} else if (pri_split) {
-		if (data->viewport.width > 1)
-			data->viewport.width /= 2;
-		if (data->viewport_c.width > 1)
-			data->viewport_c.width /= 2;
-	}
-
-	if (plane_state->rotation == ROTATION_ANGLE_90 ||
-			plane_state->rotation == ROTATION_ANGLE_270) {
-		rect_swap_helper(&data->viewport_c);
-		rect_swap_helper(&data->viewport);
-	}
 }
 
-static void calculate_recout(struct pipe_ctx *pipe_ctx, struct rect *recout_full)
+static void calculate_recout(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	struct rect surf_src = plane_state->src_rect;
 	struct rect surf_clip = plane_state->clip_rect;
 	bool pri_split = pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
@@ -614,10 +622,6 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct rect *recout_full
 			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
 	bool top_bottom_split = stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM;
 
-	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
-		rect_swap_helper(&surf_src);
-
 	pipe_ctx->plane_res.scl_data.recout.x = stream->dst.x;
 	if (stream->src.x < surf_clip.x)
 		pipe_ctx->plane_res.scl_data.recout.x += (surf_clip.x
@@ -646,7 +650,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct rect *recout_full
 			stream->dst.y + stream->dst.height
 						- pipe_ctx->plane_res.scl_data.recout.y;
 
-	/* Handle h & vsplit */
+	/* Handle h & v split, handle rotation using viewport */
 	if (sec_split && top_bottom_split) {
 		pipe_ctx->plane_res.scl_data.recout.y +=
 				pipe_ctx->plane_res.scl_data.recout.height / 2;
@@ -655,44 +659,14 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct rect *recout_full
 				(pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
 	} else if (pri_split && top_bottom_split)
 		pipe_ctx->plane_res.scl_data.recout.height /= 2;
-	else if (pri_split || sec_split) {
-		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
-		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
-					(plane_state->rotation == ROTATION_ANGLE_180);
-
-		if (plane_state->rotation == ROTATION_ANGLE_90
-				|| plane_state->rotation == ROTATION_ANGLE_270)
-			/* Secondary_pipe XOR Rotation_270 */
-			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
-
-		if (right_view) {
-			pipe_ctx->plane_res.scl_data.recout.x +=
-					pipe_ctx->plane_res.scl_data.recout.width / 2;
-			/* Ceil offset pipe */
-			pipe_ctx->plane_res.scl_data.recout.width =
-					(pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
-		} else {
-			if (pipe_ctx->plane_res.scl_data.recout.width > 1)
-				pipe_ctx->plane_res.scl_data.recout.width /= 2;
-		}
-	}
-	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream surf_src offset)
-	 *			* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
-	 *			ratio)
-	 */
-	recout_full->x = stream->dst.x + (plane_state->dst_rect.x - stream->src.x)
-					* stream->dst.width / stream->src.width -
-			surf_src.x * plane_state->dst_rect.width / surf_src.width
-					* stream->dst.width / stream->src.width;
-	recout_full->y = stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
-					* stream->dst.height / stream->src.height -
-			surf_src.y * plane_state->dst_rect.height / surf_src.height
-					* stream->dst.height / stream->src.height;
-
-	recout_full->width = plane_state->dst_rect.width
-					* stream->dst.width / stream->src.width;
-	recout_full->height = plane_state->dst_rect.height
-					* stream->dst.height / stream->src.height;
+	else if (sec_split) {
+		pipe_ctx->plane_res.scl_data.recout.x +=
+				pipe_ctx->plane_res.scl_data.recout.width / 2;
+		/* Ceil offset pipe */
+		pipe_ctx->plane_res.scl_data.recout.width =
+				(pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
+	} else if (pri_split)
+		pipe_ctx->plane_res.scl_data.recout.width /= 2;
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
@@ -705,9 +679,10 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 	const int out_w = stream->dst.width;
 	const int out_h = stream->dst.height;
 
+	/*Swap surf_src height and width since scaling ratios are in recout rotation*/
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
-		rect_swap_helper(&surf_src);
+		swap(surf_src.height, surf_src.width);
 
 	pipe_ctx->plane_res.scl_data.ratios.horz = dc_fixpt_from_fraction(
 					surf_src.width,
@@ -744,351 +719,202 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.scl_data.ratios.vert_c, 19);
 }
 
-static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct rect *recout_full)
+static inline void adjust_vp_and_init_for_seamless_clip(
+		bool flip_scan_dir,
+		int recout_skip,
+		int src_size,
+		int taps,
+		struct fixed31_32 ratio,
+		struct fixed31_32 *init,
+		int *vp_offset,
+		int *vp_size)
 {
-	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
-	struct rect src = pipe_ctx->plane_state->src_rect;
-	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
-			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
-	bool flip_vert_scan_dir = false, flip_horz_scan_dir = false;
-
-	/*
-	 * Need to calculate the scan direction for viewport to make adjustments
-	 */
-	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_180) {
-		flip_vert_scan_dir = true;
-		flip_horz_scan_dir = true;
-	} else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90)
-		flip_vert_scan_dir = true;
-	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
-		flip_horz_scan_dir = true;
-
-	if (pipe_ctx->plane_state->horizontal_mirror)
-			flip_horz_scan_dir = !flip_horz_scan_dir;
-
-	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
-		rect_swap_helper(&src);
-		rect_swap_helper(&data->viewport_c);
-		rect_swap_helper(&data->viewport);
-	}
-
-	/*
-	 * Init calculated according to formula:
-	 * 	init = (scaling_ratio + number_of_taps + 1) / 2
-	 * 	init_bot = init + scaling_ratio
-	 * 	init_c = init + truncated_vp_c_offset(from calculate viewport)
-	 */
-	data->inits.h = dc_fixpt_truncate(dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.horz, data->taps.h_taps + 1), 2), 19);
-
-	data->inits.h_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.h_c, dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2)), 19);
-
-	data->inits.v = dc_fixpt_truncate(dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.vert, data->taps.v_taps + 1), 2), 19);
-
-	data->inits.v_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.v_c, dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2)), 19);
-
-	if (!flip_horz_scan_dir) {
+	if (!flip_scan_dir) {
 		/* Adjust for viewport end clip-off */
-		if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
-			int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.h, data->ratios.horz));
-
-			int_part = int_part > 0 ? int_part : 0;
-			data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
-		}
-		if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
-			int vp_clip = (src.x + src.width) / vpc_div -
-					data->viewport_c.width - data->viewport_c.x;
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.h_c, data->ratios.horz_c));
+		if ((*vp_offset + *vp_size) < src_size) {
+			int vp_clip = src_size - *vp_size - *vp_offset;
+			int int_part = dc_fixpt_floor(dc_fixpt_sub(*init, ratio));
 
 			int_part = int_part > 0 ? int_part : 0;
-			data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
+			*vp_size += int_part < vp_clip ? int_part : vp_clip;
 		}
 
 		/* Adjust for non-0 viewport offset */
-		if (data->viewport.x) {
+		if (*vp_offset) {
 			int int_part;
 
-			data->inits.h = dc_fixpt_add(data->inits.h, dc_fixpt_mul_int(
-					data->ratios.horz, data->recout.x - recout_full->x));
-			int_part = dc_fixpt_floor(data->inits.h) - data->viewport.x;
-			if (int_part < data->taps.h_taps) {
-				int int_adj = data->viewport.x >= (data->taps.h_taps - int_part) ?
-							(data->taps.h_taps - int_part) : data->viewport.x;
-				data->viewport.x -= int_adj;
-				data->viewport.width += int_adj;
+			*init = dc_fixpt_add(*init, dc_fixpt_mul_int(ratio, recout_skip));
+			int_part = dc_fixpt_floor(*init) - *vp_offset;
+			if (int_part < taps) {
+				int int_adj = *vp_offset >= (taps - int_part) ?
+							(taps - int_part) : *vp_offset;
+				*vp_offset -= int_adj;
+				*vp_size += int_adj;
 				int_part += int_adj;
-			} else if (int_part > data->taps.h_taps) {
-				data->viewport.x += int_part - data->taps.h_taps;
-				data->viewport.width -= int_part - data->taps.h_taps;
-				int_part = data->taps.h_taps;
+			} else if (int_part > taps) {
+				*vp_offset += int_part - taps;
+				*vp_size -= int_part - taps;
+				int_part = taps;
 			}
-			data->inits.h.value &= 0xffffffff;
-			data->inits.h = dc_fixpt_add_int(data->inits.h, int_part);
-		}
-
-		if (data->viewport_c.x) {
-			int int_part;
-
-			data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_mul_int(
-					data->ratios.horz_c, data->recout.x - recout_full->x));
-			int_part = dc_fixpt_floor(data->inits.h_c) - data->viewport_c.x;
-			if (int_part < data->taps.h_taps_c) {
-				int int_adj = data->viewport_c.x >= (data->taps.h_taps_c - int_part) ?
-						(data->taps.h_taps_c - int_part) : data->viewport_c.x;
-				data->viewport_c.x -= int_adj;
-				data->viewport_c.width += int_adj;
-				int_part += int_adj;
-			} else if (int_part > data->taps.h_taps_c) {
-				data->viewport_c.x += int_part - data->taps.h_taps_c;
-				data->viewport_c.width -= int_part - data->taps.h_taps_c;
-				int_part = data->taps.h_taps_c;
-			}
-			data->inits.h_c.value &= 0xffffffff;
-			data->inits.h_c = dc_fixpt_add_int(data->inits.h_c, int_part);
+			init->value &= 0xffffffff;
+			*init = dc_fixpt_add_int(*init, int_part);
 		}
 	} else {
 		/* Adjust for non-0 viewport offset */
-		if (data->viewport.x) {
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.h, data->ratios.horz));
-
-			int_part = int_part > 0 ? int_part : 0;
-			data->viewport.width += int_part < data->viewport.x ? int_part : data->viewport.x;
-			data->viewport.x -= int_part < data->viewport.x ? int_part : data->viewport.x;
-		}
-		if (data->viewport_c.x) {
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.h_c, data->ratios.horz_c));
+		if (*vp_offset) {
+			int int_part = dc_fixpt_floor(dc_fixpt_sub(*init, ratio));
 
 			int_part = int_part > 0 ? int_part : 0;
-			data->viewport_c.width += int_part < data->viewport_c.x ? int_part : data->viewport_c.x;
-			data->viewport_c.x -= int_part < data->viewport_c.x ? int_part : data->viewport_c.x;
+			*vp_size += int_part < *vp_offset ? int_part : *vp_offset;
+			*vp_offset -= int_part < *vp_offset ? int_part : *vp_offset;
 		}
 
 		/* Adjust for viewport end clip-off */
-		if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
+		if ((*vp_offset + *vp_size) < src_size) {
 			int int_part;
-			int end_offset = src.x + src.width
-					- data->viewport.x - data->viewport.width;
+			int end_offset = src_size - *vp_offset - *vp_size;
 
 			/*
 			 * this is init if vp had no offset, keep in mind this is from the
 			 * right side of vp due to scan direction
 			 */
-			data->inits.h = dc_fixpt_add(data->inits.h, dc_fixpt_mul_int(
-					data->ratios.horz, data->recout.x - recout_full->x));
+			*init = dc_fixpt_add(*init, dc_fixpt_mul_int(ratio, recout_skip));
 			/*
 			 * this is the difference between first pixel of viewport available to read
 			 * and init position, takning into account scan direction
 			 */
-			int_part = dc_fixpt_floor(data->inits.h) - end_offset;
-			if (int_part < data->taps.h_taps) {
-				int int_adj = end_offset >= (data->taps.h_taps - int_part) ?
-							(data->taps.h_taps - int_part) : end_offset;
-				data->viewport.width += int_adj;
+			int_part = dc_fixpt_floor(*init) - end_offset;
+			if (int_part < taps) {
+				int int_adj = end_offset >= (taps - int_part) ?
+							(taps - int_part) : end_offset;
+				*vp_size += int_adj;
 				int_part += int_adj;
-			} else if (int_part > data->taps.h_taps) {
-				data->viewport.width += int_part - data->taps.h_taps;
-				int_part = data->taps.h_taps;
+			} else if (int_part > taps) {
+				*vp_size += int_part - taps;
+				int_part = taps;
 			}
-			data->inits.h.value &= 0xffffffff;
-			data->inits.h = dc_fixpt_add_int(data->inits.h, int_part);
+			init->value &= 0xffffffff;
+			*init = dc_fixpt_add_int(*init, int_part);
 		}
-
-		if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
-			int int_part;
-			int end_offset = (src.x + src.width) / vpc_div
-					- data->viewport_c.x - data->viewport_c.width;
-
-			/*
-			 * this is init if vp had no offset, keep in mind this is from the
-			 * right side of vp due to scan direction
-			 */
-			data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_mul_int(
-					data->ratios.horz_c, data->recout.x - recout_full->x));
-			/*
-			 * this is the difference between first pixel of viewport available to read
-			 * and init position, takning into account scan direction
-			 */
-			int_part = dc_fixpt_floor(data->inits.h_c) - end_offset;
-			if (int_part < data->taps.h_taps_c) {
-				int int_adj = end_offset >= (data->taps.h_taps_c - int_part) ?
-							(data->taps.h_taps_c - int_part) : end_offset;
-				data->viewport_c.width += int_adj;
-				int_part += int_adj;
-			} else if (int_part > data->taps.h_taps_c) {
-				data->viewport_c.width += int_part - data->taps.h_taps_c;
-				int_part = data->taps.h_taps_c;
-			}
-			data->inits.h_c.value &= 0xffffffff;
-			data->inits.h_c = dc_fixpt_add_int(data->inits.h_c, int_part);
-		}
-
 	}
-	if (!flip_vert_scan_dir) {
-		/* Adjust for viewport end clip-off */
-		if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
-			int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.v, data->ratios.vert));
-
-			int_part = int_part > 0 ? int_part : 0;
-			data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
-		}
-		if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
-			int vp_clip = (src.y + src.height) / vpc_div -
-					data->viewport_c.height - data->viewport_c.y;
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.v_c, data->ratios.vert_c));
-
-			int_part = int_part > 0 ? int_part : 0;
-			data->viewport_c.height += int_part < vp_clip ? int_part : vp_clip;
-		}
-
-		/* Adjust for non-0 viewport offset */
-		if (data->viewport.y) {
-			int int_part;
-
-			data->inits.v = dc_fixpt_add(data->inits.v, dc_fixpt_mul_int(
-					data->ratios.vert, data->recout.y - recout_full->y));
-			int_part = dc_fixpt_floor(data->inits.v) - data->viewport.y;
-			if (int_part < data->taps.v_taps) {
-				int int_adj = data->viewport.y >= (data->taps.v_taps - int_part) ?
-							(data->taps.v_taps - int_part) : data->viewport.y;
-				data->viewport.y -= int_adj;
-				data->viewport.height += int_adj;
-				int_part += int_adj;
-			} else if (int_part > data->taps.v_taps) {
-				data->viewport.y += int_part - data->taps.v_taps;
-				data->viewport.height -= int_part - data->taps.v_taps;
-				int_part = data->taps.v_taps;
-			}
-			data->inits.v.value &= 0xffffffff;
-			data->inits.v = dc_fixpt_add_int(data->inits.v, int_part);
-		}
-
-		if (data->viewport_c.y) {
-			int int_part;
+}
 
-			data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_mul_int(
-					data->ratios.vert_c, data->recout.y - recout_full->y));
-			int_part = dc_fixpt_floor(data->inits.v_c) - data->viewport_c.y;
-			if (int_part < data->taps.v_taps_c) {
-				int int_adj = data->viewport_c.y >= (data->taps.v_taps_c - int_part) ?
-						(data->taps.v_taps_c - int_part) : data->viewport_c.y;
-				data->viewport_c.y -= int_adj;
-				data->viewport_c.height += int_adj;
-				int_part += int_adj;
-			} else if (int_part > data->taps.v_taps_c) {
-				data->viewport_c.y += int_part - data->taps.v_taps_c;
-				data->viewport_c.height -= int_part - data->taps.v_taps_c;
-				int_part = data->taps.v_taps_c;
-			}
-			data->inits.v_c.value &= 0xffffffff;
-			data->inits.v_c = dc_fixpt_add_int(data->inits.v_c, int_part);
-		}
-	} else {
-		/* Adjust for non-0 viewport offset */
-		if (data->viewport.y) {
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.v, data->ratios.vert));
+static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx)
+{
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
+	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
+	struct rect src = pipe_ctx->plane_state->src_rect;
+	int recout_skip_h, recout_skip_v, surf_size_h, surf_size_v;
+	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
+			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
+	bool orthogonal_rotation, flip_vert_scan_dir, flip_horz_scan_dir;
 
-			int_part = int_part > 0 ? int_part : 0;
-			data->viewport.height += int_part < data->viewport.y ? int_part : data->viewport.y;
-			data->viewport.y -= int_part < data->viewport.y ? int_part : data->viewport.y;
-		}
-		if (data->viewport_c.y) {
-			int int_part = dc_fixpt_floor(
-					dc_fixpt_sub(data->inits.v_c, data->ratios.vert_c));
+	/*
+	 * Need to calculate the scan direction for viewport to make adjustments
+	 */
+	get_vp_scan_direction(
+			plane_state->rotation,
+			plane_state->horizontal_mirror,
+			&orthogonal_rotation,
+			&flip_vert_scan_dir,
+			&flip_horz_scan_dir);
+
+	/* Calculate src rect rotation adjusted to recout space */
+	surf_size_h = src.x + src.width;
+	surf_size_v = src.y + src.height;
+	if (flip_horz_scan_dir)
+		src.x = 0;
+	if (flip_vert_scan_dir)
+		src.y = 0;
+	if (orthogonal_rotation) {
+		swap(src.x, src.y);
+		swap(src.width, src.height);
+	}
 
-			int_part = int_part > 0 ? int_part : 0;
-			data->viewport_c.height += int_part < data->viewport_c.y ? int_part : data->viewport_c.y;
-			data->viewport_c.y -= int_part < data->viewport_c.y ? int_part : data->viewport_c.y;
-		}
+	/* Recout matching initial vp offset = recout_offset - (stream dst offset +
+	 *			((surf dst offset - stream src offset) * 1/ stream scaling ratio)
+	 *			- (surf surf_src offset * 1/ full scl ratio))
+	 */
+	recout_skip_h = data->recout.x - (stream->dst.x + (plane_state->dst_rect.x - stream->src.x)
+					* stream->dst.width / stream->src.width -
+					src.x * plane_state->dst_rect.width / src.width
+					* stream->dst.width / stream->src.width);
+	recout_skip_v = data->recout.y - (stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
+					* stream->dst.height / stream->src.height -
+					src.y * plane_state->dst_rect.height / src.height
+					* stream->dst.height / stream->src.height);
+	if (orthogonal_rotation)
+		swap(recout_skip_h, recout_skip_v);
+	/*
+	 * Init calculated according to formula:
+	 * 	init = (scaling_ratio + number_of_taps + 1) / 2
+	 * 	init_bot = init + scaling_ratio
+	 * 	init_c = init + truncated_vp_c_offset(from calculate viewport)
+	 */
+	data->inits.h = dc_fixpt_truncate(dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.horz, data->taps.h_taps + 1), 2), 19);
 
-		/* Adjust for viewport end clip-off */
-		if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
-			int int_part;
-			int end_offset = src.y + src.height
-					- data->viewport.y - data->viewport.height;
+	data->inits.h_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.h_c, dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2)), 19);
 
-			/*
-			 * this is init if vp had no offset, keep in mind this is from the
-			 * right side of vp due to scan direction
-			 */
-			data->inits.v = dc_fixpt_add(data->inits.v, dc_fixpt_mul_int(
-					data->ratios.vert, data->recout.y - recout_full->y));
-			/*
-			 * this is the difference between first pixel of viewport available to read
-			 * and init position, taking into account scan direction
-			 */
-			int_part = dc_fixpt_floor(data->inits.v) - end_offset;
-			if (int_part < data->taps.v_taps) {
-				int int_adj = end_offset >= (data->taps.v_taps - int_part) ?
-							(data->taps.v_taps - int_part) : end_offset;
-				data->viewport.height += int_adj;
-				int_part += int_adj;
-			} else if (int_part > data->taps.v_taps) {
-				data->viewport.height += int_part - data->taps.v_taps;
-				int_part = data->taps.v_taps;
-			}
-			data->inits.v.value &= 0xffffffff;
-			data->inits.v = dc_fixpt_add_int(data->inits.v, int_part);
-		}
+	data->inits.v = dc_fixpt_truncate(dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.vert, data->taps.v_taps + 1), 2), 19);
 
-		if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
-			int int_part;
-			int end_offset = (src.y + src.height) / vpc_div
-					- data->viewport_c.y - data->viewport_c.height;
+	data->inits.v_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.v_c, dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2)), 19);
 
-			/*
-			 * this is init if vp had no offset, keep in mind this is from the
-			 * right side of vp due to scan direction
-			 */
-			data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_mul_int(
-					data->ratios.vert_c, data->recout.y - recout_full->y));
-			/*
-			 * this is the difference between first pixel of viewport available to read
-			 * and init position, taking into account scan direction
-			 */
-			int_part = dc_fixpt_floor(data->inits.v_c) - end_offset;
-			if (int_part < data->taps.v_taps_c) {
-				int int_adj = end_offset >= (data->taps.v_taps_c - int_part) ?
-							(data->taps.v_taps_c - int_part) : end_offset;
-				data->viewport_c.height += int_adj;
-				int_part += int_adj;
-			} else if (int_part > data->taps.v_taps_c) {
-				data->viewport_c.height += int_part - data->taps.v_taps_c;
-				int_part = data->taps.v_taps_c;
-			}
-			data->inits.v_c.value &= 0xffffffff;
-			data->inits.v_c = dc_fixpt_add_int(data->inits.v_c, int_part);
-		}
-	}
+	/*
+	 * Taps, inits and scaling ratios are in recout space need to rotate
+	 * to viewport rotation before adjustment
+	 */
+	adjust_vp_and_init_for_seamless_clip(
+			flip_horz_scan_dir,
+			recout_skip_h,
+			surf_size_h,
+			orthogonal_rotation ? data->taps.v_taps : data->taps.h_taps,
+			orthogonal_rotation ? data->ratios.vert : data->ratios.horz,
+			orthogonal_rotation ? &data->inits.v : &data->inits.h,
+			&data->viewport.x,
+			&data->viewport.width);
+	adjust_vp_and_init_for_seamless_clip(
+			flip_horz_scan_dir,
+			recout_skip_h,
+			surf_size_h / vpc_div,
+			orthogonal_rotation ? data->taps.v_taps_c : data->taps.h_taps_c,
+			orthogonal_rotation ? data->ratios.vert_c : data->ratios.horz_c,
+			orthogonal_rotation ? &data->inits.v_c : &data->inits.h_c,
+			&data->viewport_c.x,
+			&data->viewport_c.width);
+	adjust_vp_and_init_for_seamless_clip(
+			flip_vert_scan_dir,
+			recout_skip_v,
+			surf_size_v,
+			orthogonal_rotation ? data->taps.h_taps : data->taps.v_taps,
+			orthogonal_rotation ? data->ratios.horz : data->ratios.vert,
+			orthogonal_rotation ? &data->inits.h : &data->inits.v,
+			&data->viewport.y,
+			&data->viewport.height);
+	adjust_vp_and_init_for_seamless_clip(
+			flip_vert_scan_dir,
+			recout_skip_v,
+			surf_size_v / vpc_div,
+			orthogonal_rotation ? data->taps.h_taps_c : data->taps.v_taps_c,
+			orthogonal_rotation ? data->ratios.horz_c : data->ratios.vert_c,
+			orthogonal_rotation ? &data->inits.h_c : &data->inits.v_c,
+			&data->viewport_c.y,
+			&data->viewport_c.height);
 
 	/* Interlaced inits based on final vert inits */
 	data->inits.v_bot = dc_fixpt_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dc_fixpt_add(data->inits.v_c, data->ratios.vert_c);
 
-	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
-		rect_swap_helper(&data->viewport_c);
-		rect_swap_helper(&data->viewport);
-	}
 }
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
-	struct rect recout_full = { 0 };
 	bool res = false;
 	DC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);
 	/* Important: scaling ratio calculation requires pixel format,
@@ -1105,7 +931,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->plane_res.scl_data.viewport.height < 16 || pipe_ctx->plane_res.scl_data.viewport.width < 16)
 		return false;
 
-	calculate_recout(pipe_ctx, &recout_full);
+	calculate_recout(pipe_ctx);
 
 	/**
 	 * Setting line buffer pixel depth to 24bpp yields banding
@@ -1146,7 +972,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	if (res)
 		/* May need to re-check lb size after this in some obscure scenario */
-		calculate_inits_and_adj_vp(pipe_ctx, &recout_full);
+		calculate_inits_and_adj_vp(pipe_ctx);
 
 	DC_LOG_SCALER(
 				"%s: Viewport:\nheight:%d width:%d x:%d "

commit 08e1c28dd521c7b08d1b0af0bae9fb22ccc012a4
Author: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date:   Sat Oct 20 01:21:40 2018 +0530

    drm/amd/display: calculate stream->phy_pix_clk before clock mapping
    
    [why]
    phy_pix_clk is one of the variable used to check if one PLL can be shared
    with displays having common mode set configuration. As of now
    phy_pix_clock varialbe is calculated in function dc_validate_stream().
    dc_validate_stream() function is called after clocks are assigned for the
    new display. Due to this during hotplug, when PLL sharing conditions are
    checked for new display phy_pix_clk variable will be 0 and for displays
    that are already enabled phy_pix_clk will have some value. Hence PLL will
    not be shared and if the display hardware doesn't have any more PLL to
    assign, mode set will fail due to resource unavailability.
    
    [how]
    Instead of only calculating the phy_pix_clk variable after the PLL is
    assigned for new display, this patch calculates phy_pix_clk also during
    the before assigning the PLL for new display.
    
    Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d09aa35f4181..98bc298ec948 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1976,6 +1976,8 @@ enum dc_status resource_map_pool_resources(
 		}
 	*/
 
+	calculate_phy_pix_clks(stream);
+
 	/* acquire new resources */
 	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 

commit eb9714a201f46ac46c1314849242d9eba56752e4
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Mon Oct 22 16:34:32 2018 -0400

    drm/amd/display: resolve minor log problems
    
    [Why]
    dc_add_stream_to_context is used to check bw requirement.
    It is not an error if it fails.
    
    [How]
    Replace DC_ERROR with DC_LOG_WARNING.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fc65b0055167..d09aa35f4181 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1796,11 +1796,11 @@ enum dc_status dc_add_stream_to_ctx(
 		struct dc_state *new_ctx,
 		struct dc_stream_state *stream)
 {
-	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status res;
+	DC_LOGGER_INIT(dc->ctx->logger);
 
 	if (new_ctx->stream_count >= dc->res_pool->timing_generator_count) {
-		DC_ERROR("Max streams reached, can't add stream %p !\n", stream);
+		DC_LOG_WARNING("Max streams reached, can't add stream %p !\n", stream);
 		return DC_ERROR_UNEXPECTED;
 	}
 
@@ -1810,7 +1810,7 @@ enum dc_status dc_add_stream_to_ctx(
 
 	res = dc->res_pool->funcs->add_stream_to_ctx(dc, new_ctx, stream);
 	if (res != DC_OK)
-		DC_ERROR("Adding stream %p to context failed with err %d!\n", stream, res);
+		DC_LOG_WARNING("Adding stream %p to context failed with err %d!\n", stream, res);
 
 	return res;
 }

commit 83d4065991f044def34607b654096fd5712f059f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Oct 16 18:00:29 2018 -0400

    drm/amd/display: fix mirror rotation scaling math
    
    Curretly dc will incorrectly calculate viewport when there is
    rotation or mirror being applied
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Su Chung <Su.Chung@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d68906b90399..fc65b0055167 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -499,8 +499,13 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
 	bool flip_vert_scan_dir = false, flip_horz_scan_dir = false;
 
+
 	/*
-	 * Need to calculate the scan direction for viewport to properly determine offset
+	 * We need take horizontal mirror into account. On an unrotated surface this means
+	 * that the viewport offset is actually the offset from the other side of source
+	 * image so we have to subtract the right edge of the viewport from the right edge of
+	 * the source window. Similar to mirror we need to take into account how offset is
+	 * affected for 270/180 rotations
 	 */
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_180) {
 		flip_vert_scan_dir = true;
@@ -510,6 +515,9 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		flip_horz_scan_dir = true;
 
+	if (pipe_ctx->plane_state->horizontal_mirror)
+		flip_horz_scan_dir = !flip_horz_scan_dir;
+
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 		pri_split = false;
@@ -540,45 +548,27 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			plane_state->clip_rect.y + plane_state->clip_rect.height - clip.y ;
 
 	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
+	 * note: surf_src.ofs should be added after rotation/mirror offset direction
+	 *       adjustment since it is already in viewport space
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	data->viewport.x = surf_src.x + (clip.x - plane_state->dst_rect.x) *
+	data->viewport.x = (clip.x - plane_state->dst_rect.x) *
 			surf_src.width / plane_state->dst_rect.width;
 	data->viewport.width = clip.width *
 			surf_src.width / plane_state->dst_rect.width;
 
-	data->viewport.y = surf_src.y + (clip.y - plane_state->dst_rect.y) *
+	data->viewport.y = (clip.y - plane_state->dst_rect.y) *
 			surf_src.height / plane_state->dst_rect.height;
 	data->viewport.height = clip.height *
 			surf_src.height / plane_state->dst_rect.height;
 
-	/* To transfer the x, y to correct coordinate on mirror image (camera).
-	 * deg  0 : transfer x,
-	 * deg 90 : don't need to transfer,
-	 * deg180 : transfer y,
-	 * deg270 : transfer x and y.
-	 * To transfer the x, y to correct coordinate on non-mirror image (video).
-	 * deg  0 : don't need to transfer,
-	 * deg 90 : transfer y,
-	 * deg180 : transfer x and y,
-	 * deg270 : transfer x.
-	 */
-	if (pipe_ctx->plane_state->horizontal_mirror) {
-		if (flip_horz_scan_dir && !flip_vert_scan_dir) {
-			data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
-			data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
-		} else if (flip_horz_scan_dir && flip_vert_scan_dir)
-			data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
-		else {
-			if (!flip_horz_scan_dir && !flip_vert_scan_dir)
-				data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
-		}
-	} else {
-		if (flip_horz_scan_dir)
-			data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
-		if (flip_vert_scan_dir)
-			data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
-	}
+	if (flip_vert_scan_dir)
+		data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
+	if (flip_horz_scan_dir)
+		data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
+
+	data->viewport.x += surf_src.x;
+	data->viewport.y += surf_src.y;
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
@@ -773,22 +763,15 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct rect *r
 	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		flip_horz_scan_dir = true;
 
+	if (pipe_ctx->plane_state->horizontal_mirror)
+			flip_horz_scan_dir = !flip_horz_scan_dir;
+
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
-
-		if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270 &&
-			pipe_ctx->plane_state->horizontal_mirror) {
-			flip_vert_scan_dir = true;
-		}
-		if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 &&
-			pipe_ctx->plane_state->horizontal_mirror) {
-			flip_vert_scan_dir = false;
-		}
-	} else if (pipe_ctx->plane_state->horizontal_mirror)
-			flip_horz_scan_dir = !flip_horz_scan_dir;
+	}
 
 	/*
 	 * Init calculated according to formula:

commit ddc07a3803a71413f73d40f17cedf5ebd28ef3bc
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Oct 12 09:40:06 2018 -0400

    drm/amd/display: remove interlace scaling adjustment
    
    We do not need to adjust surface scaling when p2i is enabled
    and we do not support interlaced timing otherwise
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a5eb80aa3dd9..d68906b90399 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1115,9 +1115,6 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.format = convert_pixel_format_to_dalsurface(
 			pipe_ctx->plane_state->format);
 
-	if (pipe_ctx->stream->timing.flags.INTERLACE)
-		pipe_ctx->stream->dst.height *= 2;
-
 	calculate_scaling_ratios(pipe_ctx);
 
 	calculate_viewport(pipe_ctx);
@@ -1138,9 +1135,6 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable + timing->h_border_left + timing->h_border_right;
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
-	if (pipe_ctx->stream->timing.flags.INTERLACE)
-		pipe_ctx->plane_res.scl_data.v_active *= 2;
-
 
 	/* Taps calculations */
 	if (pipe_ctx->plane_res.xfm != NULL)
@@ -1185,9 +1179,6 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				plane_state->dst_rect.x,
 				plane_state->dst_rect.y);
 
-	if (pipe_ctx->stream->timing.flags.INTERLACE)
-		pipe_ctx->stream->dst.height /= 2;
-
 	return res;
 }
 

commit 84e7fc05a92700297f1de945251fa3b14349532c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 28 07:46:42 2018 -0400

    drm/amd/display: rename dccg to clk_mgr
    
    In preparation for adding the actual dccg block since the
    current implementation of dccg is mor eof a clock manager
    than a hw block
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index b16650c6f477..a5eb80aa3dd9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2071,7 +2071,7 @@ void dc_resource_state_construct(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dst_ctx->dccg = dc->res_pool->dccg;
+	dst_ctx->dccg = dc->res_pool->clk_mgr;
 }
 
 enum dc_status dc_validate_global_state(

commit 24f7dd7ea98dc54fa45a0dd10c7a472e00ca01d4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Sep 13 17:42:14 2018 -0400

    drm/amd/display: move pplib/smu notification to dccg block
    
    This is done to clear up the clock programming sequence
    since the only time we need to notify pplib is after
    clock update.
    
    This also renames the clk block to dccg, at the moment
    this block contains both clock management and dccg
    functionality.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index b6fe29b9fb65..b16650c6f477 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2071,7 +2071,7 @@ void dc_resource_state_construct(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dst_ctx->dis_clk = dc->res_pool->dccg;
+	dst_ctx->dccg = dc->res_pool->dccg;
 }
 
 enum dc_status dc_validate_global_state(

commit 74eac5f3b43eda8b518662b011d1f18d5560e144
Author: Su Sung Chung <Su.Chung@amd.com>
Date:   Thu Sep 13 15:26:08 2018 -0400

    drm/amd/display: Calculate swizzle mode using bpp during validation
    
    [Why]
    Previously bandwidth validation was failing because swizzle mode was not
    initialized during plane_state allocation. The swizzle mode was
    calculated using pixed format which is how swizzle mode is initially
    calculated in addrlib.
    
    [How]
    * Set default swizzle mode for validation to DC_SW_UNKNOWN
    * Created new function in dcn10_assign_swizzle_mode which sets the
      plane swizzle mode based on selected pixed format
    * Added the call of assign_swizzle_mode into dc_validate_global_state
    * Set failsafe swizzle mode back to DC_SW_LINEAR
    
    Signed-off-by: Su Sung Chung <Su.Chung@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a3fee3769f4d..b6fe29b9fb65 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2099,6 +2099,14 @@ enum dc_status dc_validate_global_state(
 			if (pipe_ctx->stream != stream)
 				continue;
 
+			if (dc->res_pool->funcs->get_default_swizzle_mode &&
+					pipe_ctx->plane_state &&
+					pipe_ctx->plane_state->tiling_info.gfx9.swizzle == DC_SW_UNKNOWN) {
+				result = dc->res_pool->funcs->get_default_swizzle_mode(pipe_ctx->plane_state);
+				if (result != DC_OK)
+					return result;
+			}
+
 			/* Switch to dp clock source only if there is
 			 * no non dp stream that shares the same timing
 			 * with the dp stream.
@@ -2888,3 +2896,32 @@ enum dc_status dc_validate_plane(struct dc *dc, const struct dc_plane_state *pla
 
 	return res;
 }
+
+unsigned int resource_pixel_format_to_bpp(enum surface_pixel_format format)
+{
+	switch (format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:
+		return 8;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		return 12;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		return 16;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:
+		return 32;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		return 64;
+	default:
+		ASSERT_CRITICAL(false);
+		return -1;
+	}
+}

commit 39c03e0032ff839e62aae7d85a541451444a3198
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Sep 12 18:22:16 2018 -0400

    drm/amd/display: fix 4K stereo screen flash issue
    
    [Why]
    HDMI_scramber is not enabled for pixel rate >340Mhz.
    [How]
    Calculate the phy clock to include the Hw frame packing factor.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2d6a4300bfa4..a3fee3769f4d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1975,6 +1975,9 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 	else
 		stream->phy_pix_clk =
 			stream->timing.pix_clk_khz;
+
+	if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_HW_FRAME_PACKING)
+		stream->phy_pix_clk *= 2;
 }
 
 enum dc_status resource_map_pool_resources(

commit d77f778e59ca858e1fb1e9d4946080d689c04711
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Aug 27 11:31:08 2018 -0400

    drm/amd/display: Fix 3D stereo issues.
    
    We were not providing the correct pixel clocks to DML for marks
    calculation.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 721dd13d2ed2..2d6a4300bfa4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -363,6 +363,9 @@ bool resource_are_streams_timing_synchronizable(
 			|| !dc_is_dp_signal(stream2->signal)))
 		return false;
 
+	if (stream1->view_format != stream2->view_format)
+		return false;
+
 	return true;
 }
 static bool is_dp_and_hdmi_sharable(
@@ -373,7 +376,7 @@ static bool is_dp_and_hdmi_sharable(
 		return false;
 
 	if (stream1->clamping.c_depth != COLOR_DEPTH_888 ||
-	    stream2->clamping.c_depth != COLOR_DEPTH_888)
+		stream2->clamping.c_depth != COLOR_DEPTH_888)
 		return false;
 
 	return true;

commit 0e3d73f1a440eaca270a028bff51649ae99df113
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Jan 22 16:12:27 2018 -0500

    drm/amd/display: Add Raven2 definitions in dc
    
    Add Raven2 definitions in the dc code
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Huang Rui <ray.huang@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d981755d1e4d..721dd13d2ed2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -88,6 +88,10 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case FAMILY_RV:
 		dc_version = DCN_VERSION_1_0;
+#if defined(CONFIG_DRM_AMD_DC_DCN1_01)
+		if (ASICREV_IS_RAVEN2(asic_id.hw_internal_rev))
+			dc_version = DCN_VERSION_1_01;
+#endif
 		break;
 #endif
 	default:
@@ -138,6 +142,9 @@ struct resource_pool *dc_create_resource_pool(
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case DCN_VERSION_1_0:
+#if defined(CONFIG_DRM_AMD_DC_DCN1_01)
+	case DCN_VERSION_1_01:
+#endif
 		res_pool = dcn10_create_resource_pool(
 				num_virtual_links, dc);
 		break;

commit cae50a43b931c6d70c7e16e1128af10398d8635a
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Aug 24 16:54:14 2018 -0400

    drm/amd/display: use link type to decide stream enc acquisition
    
    [Why]
    Virtual sink is used when set mode happens on a disconnected display
    to allow the mode set to proceed. This did not work with MST because
    the logic for acquiring stream encoder uses stream signal to determine
    the special handling is required, and stream signal is virtual instead
    of DP in this case.
    
    [How]
    Use link type to decide instead.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f85fa7b55efb..d981755d1e4d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1762,7 +1762,7 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 	 * required for non DP connectors.
 	 */
 
-	if (j >= 0 && dc_is_dp_signal(stream->signal))
+	if (j >= 0 && link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT)
 		return pool->stream_enc[j];
 
 	return NULL;

commit 43fbbe89f15b297e269388dee63901715e55d712
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Aug 14 12:09:45 2018 +0300

    drm/amd/display: indent an if statement
    
    The if statement isn't indented and it makes static checkers complain.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 07a1dd41666d..f85fa7b55efb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -367,7 +367,7 @@ static bool is_dp_and_hdmi_sharable(
 
 	if (stream1->clamping.c_depth != COLOR_DEPTH_888 ||
 	    stream2->clamping.c_depth != COLOR_DEPTH_888)
-	return false;
+		return false;
 
 	return true;
 

commit 1336926f43ccadf2a152ea89a27de725c4d17f62
Author: Alvin lee <alvin.lee3@amd.com>
Date:   Mon Jun 4 17:31:25 2018 -0400

    drm/amd/display: Enable Stereo in Dal3
    
    - program infoframe for Stereo
    - program stereo flip control registers properly
    
    v2: Add missing license headers
    
    Signed-off-by: Alvin lee <alvin.lee3@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9157f5d83b0d..07a1dd41666d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1578,6 +1578,20 @@ static bool is_hdr_static_meta_changed(struct dc_stream_state *cur_stream,
 	return false;
 }
 
+static bool is_vsc_info_packet_changed(struct dc_stream_state *cur_stream,
+		struct dc_stream_state *new_stream)
+{
+	if (cur_stream == NULL)
+		return true;
+
+	if (memcmp(&cur_stream->vsc_infopacket,
+			&new_stream->vsc_infopacket,
+			sizeof(struct dc_info_packet)) != 0)
+		return true;
+
+	return false;
+}
+
 static bool is_timing_changed(struct dc_stream_state *cur_stream,
 		struct dc_stream_state *new_stream)
 {
@@ -1618,6 +1632,9 @@ static bool are_stream_backends_same(
 	if (stream_a->dpms_off != stream_b->dpms_off)
 		return false;
 
+	if (is_vsc_info_packet_changed(stream_a, stream_b))
+		return false;
+
 	return true;
 }
 
@@ -2504,43 +2521,10 @@ static void set_vsc_info_packet(
 		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
-	unsigned int vscPacketRevision = 0;
-	unsigned int i;
-
-	/*VSC packet set to 2 when DP revision >= 1.2*/
-	if (stream->psr_version != 0) {
-		vscPacketRevision = 2;
-	}
-
-	/* VSC packet not needed based on the features
-	 * supported by this DP display
-	 */
-	if (vscPacketRevision == 0)
+	if (!stream->vsc_infopacket.valid)
 		return;
 
-	if (vscPacketRevision == 0x2) {
-		/* Secondary-data Packet ID = 0*/
-		info_packet->hb0 = 0x00;
-		/* 07h - Packet Type Value indicating Video
-		 * Stream Configuration packet
-		 */
-		info_packet->hb1 = 0x07;
-		/* 02h = VSC SDP supporting 3D stereo and PSR
-		 * (applies to eDP v1.3 or higher).
-		 */
-		info_packet->hb2 = 0x02;
-		/* 08h = VSC packet supporting 3D stereo + PSR
-		 * (HB2 = 02h).
-		 */
-		info_packet->hb3 = 0x08;
-
-		for (i = 0; i < 28; i++)
-			info_packet->sb[i] = 0;
-
-		info_packet->valid = true;
-	}
-
-	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
+	*info_packet = stream->vsc_infopacket;
 }
 
 void dc_resource_state_destruct(struct dc_state *context)
@@ -2722,6 +2706,9 @@ bool pipe_need_reprogram(
 	if (pipe_ctx_old->stream->dpms_off != pipe_ctx->stream->dpms_off)
 		return true;
 
+	if (is_vsc_info_packet_changed(pipe_ctx_old->stream, pipe_ctx->stream))
+		return true;
+
 	return false;
 }
 

commit 1e7e86c43f38d2cc0183ae2a440c70f3c6163883
Author: Samson Tam <Samson.Tam@amd.com>
Date:   Tue May 1 10:39:26 2018 -0400

    drm/amd/display: decouple front and backend pgm using dpms_off as backend enable flag
    
    Signed-off-by: Samson Tam <Samson.Tam@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4468b240929a..9157f5d83b0d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1615,6 +1615,9 @@ static bool are_stream_backends_same(
 	if (is_hdr_static_meta_changed(stream_a, stream_b))
 		return false;
 
+	if (stream_a->dpms_off != stream_b->dpms_off)
+		return false;
+
 	return true;
 }
 
@@ -2716,6 +2719,9 @@ bool pipe_need_reprogram(
 	if (is_hdr_static_meta_changed(pipe_ctx_old->stream, pipe_ctx->stream))
 		return true;
 
+	if (pipe_ctx_old->stream->dpms_off != pipe_ctx->stream->dpms_off)
+		return true;
+
 	return false;
 }
 

commit 98e6436d3af5fef7ca9b59d865dd5807ede36fb9
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Aug 21 14:40:28 2018 -0500

    drm/amd/display: Refactor FreeSync module
    
    Remove dependency on internal sink map and instead
    use existing stream and plane state
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2c348b11b9a5..4468b240929a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2475,119 +2475,13 @@ static void set_spd_info_packet(
 {
 	/* SPD info packet for FreeSync */
 
-	unsigned char checksum = 0;
-	unsigned int idx, payload_size = 0;
-
 	/* Check if Freesync is supported. Return if false. If true,
 	 * set the corresponding bit in the info packet
 	 */
-	if (stream->freesync_ctx.supported == false)
+	if (!stream->vrr_infopacket.valid)
 		return;
 
-	if (dc_is_hdmi_signal(stream->signal)) {
-
-		/* HEADER */
-
-		/* HB0  = Packet Type = 0x83 (Source Product
-		 *	  Descriptor InfoFrame)
-		 */
-		info_packet->hb0 = HDMI_INFOFRAME_TYPE_SPD;
-
-		/* HB1  = Version = 0x01 */
-		info_packet->hb1 = 0x01;
-
-		/* HB2  = [Bits 7:5 = 0] [Bits 4:0 = Length = 0x08] */
-		info_packet->hb2 = 0x08;
-
-		payload_size = 0x08;
-
-	} else if (dc_is_dp_signal(stream->signal)) {
-
-		/* HEADER */
-
-		/* HB0  = Secondary-data Packet ID = 0 - Only non-zero
-		 *	  when used to associate audio related info packets
-		 */
-		info_packet->hb0 = 0x00;
-
-		/* HB1  = Packet Type = 0x83 (Source Product
-		 *	  Descriptor InfoFrame)
-		 */
-		info_packet->hb1 = HDMI_INFOFRAME_TYPE_SPD;
-
-		/* HB2  = [Bits 7:0 = Least significant eight bits -
-		 *	  For INFOFRAME, the value must be 1Bh]
-		 */
-		info_packet->hb2 = 0x1B;
-
-		/* HB3  = [Bits 7:2 = INFOFRAME SDP Version Number = 0x1]
-		 *	  [Bits 1:0 = Most significant two bits = 0x00]
-		 */
-		info_packet->hb3 = 0x04;
-
-		payload_size = 0x1B;
-	}
-
-	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
-	info_packet->sb[1] = 0x1A;
-
-	/* PB2 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 1) */
-	info_packet->sb[2] = 0x00;
-
-	/* PB3 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 2) */
-	info_packet->sb[3] = 0x00;
-
-	/* PB4 = Reserved */
-	info_packet->sb[4] = 0x00;
-
-	/* PB5 = Reserved */
-	info_packet->sb[5] = 0x00;
-
-	/* PB6 = [Bits 7:3 = Reserved] */
-	info_packet->sb[6] = 0x00;
-
-	if (stream->freesync_ctx.supported == true)
-		/* PB6 = [Bit 0 = FreeSync Supported] */
-		info_packet->sb[6] |= 0x01;
-
-	if (stream->freesync_ctx.enabled == true)
-		/* PB6 = [Bit 1 = FreeSync Enabled] */
-		info_packet->sb[6] |= 0x02;
-
-	if (stream->freesync_ctx.active == true)
-		/* PB6 = [Bit 2 = FreeSync Active] */
-		info_packet->sb[6] |= 0x04;
-
-	/* PB7 = FreeSync Minimum refresh rate (Hz) */
-	info_packet->sb[7] = (unsigned char) (stream->freesync_ctx.
-			min_refresh_in_micro_hz / 1000000);
-
-	/* PB8 = FreeSync Maximum refresh rate (Hz)
-	 *
-	 * Note: We do not use the maximum capable refresh rate
-	 * of the panel, because we should never go above the field
-	 * rate of the mode timing set.
-	 */
-	info_packet->sb[8] = (unsigned char) (stream->freesync_ctx.
-			nominal_refresh_in_micro_hz / 1000000);
-
-	/* PB9 - PB27  = Reserved */
-	for (idx = 9; idx <= 27; idx++)
-		info_packet->sb[idx] = 0x00;
-
-	/* Calculate checksum */
-	checksum += info_packet->hb0;
-	checksum += info_packet->hb1;
-	checksum += info_packet->hb2;
-	checksum += info_packet->hb3;
-
-	for (idx = 1; idx <= payload_size; idx++)
-		checksum += info_packet->sb[idx];
-
-	/* PB0 = Checksum (one byte complement) */
-	info_packet->sb[0] = (unsigned char) (0x100 - checksum);
-
-	info_packet->valid = true;
+	*info_packet = stream->vrr_infopacket;
 }
 
 static void set_hdr_static_info_packet(

commit 94a4ffd1d40b845dd19f9fdbb2cb6bf32de0946b
Author: Gloria Li <geling.li@amd.com>
Date:   Thu Jul 26 11:32:14 2018 -0400

    drm/amd/display: fix PIP bugs on Dal3
    
    [Why]
    There are outstanding bugs for PIP in Dal3:
    -Crash when toggling PIP visibility
    -Global Alpha is not working, Adjusting global alpha
     doesn’t have an effect
    -Cursor is not working with pip plane and pipe splits
    -One flash occurs when cursor enters PIP plane from
     top/bottom
    -Crash when moving PIP plane off the screen
    
    [How]
    Resolve divide by 0 error
    Implement global alpha
    Program cursor on all pipes
    Add dst rects' x and y offests into cursor position
    Disable cursor when it is beyond bottom/top edge
    
    Signed-off-by: Gloria Li <geling.li@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d10314016edb..2c348b11b9a5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -589,8 +589,10 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		data->viewport.width = (data->viewport.width + 1) / 2;
 		data->viewport_c.width = (data->viewport_c.width + 1) / 2;
 	} else if (pri_split) {
-		data->viewport.width /= 2;
-		data->viewport_c.width /= 2;
+		if (data->viewport.width > 1)
+			data->viewport.width /= 2;
+		if (data->viewport_c.width > 1)
+			data->viewport_c.width /= 2;
 	}
 
 	if (plane_state->rotation == ROTATION_ANGLE_90 ||
@@ -670,7 +672,8 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct rect *recout_full
 			pipe_ctx->plane_res.scl_data.recout.width =
 					(pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
 		} else {
-			pipe_ctx->plane_res.scl_data.recout.width /= 2;
+			if (pipe_ctx->plane_res.scl_data.recout.width > 1)
+				pipe_ctx->plane_res.scl_data.recout.width /= 2;
 		}
 	}
 	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream surf_src offset)

commit 9b5349f74a85a6aa05c06d30f10b3a83d6ec00b1
Author: Martin Tsai <Martin.Tsai@amd.com>
Date:   Fri Jul 27 15:39:47 2018 +0800

    drm/amd/display: correct image viewport calculation
    
    [why]
    We didn't transfer the camera/video viewport coordinate
    when doing rotation and mirror.
    
    [how]
    To correct the viewport coordinate in calculate_viewport().
    
    Signed-off-by: Martin Tsai <Martin.Tsai@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ea6beccfd89d..d10314016edb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -487,6 +487,18 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
+	bool flip_vert_scan_dir = false, flip_horz_scan_dir = false;
+
+	/*
+	 * Need to calculate the scan direction for viewport to properly determine offset
+	 */
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_180) {
+		flip_vert_scan_dir = true;
+		flip_horz_scan_dir = true;
+	} else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90)
+		flip_vert_scan_dir = true;
+	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
+		flip_horz_scan_dir = true;
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
@@ -530,6 +542,34 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	data->viewport.height = clip.height *
 			surf_src.height / plane_state->dst_rect.height;
 
+	/* To transfer the x, y to correct coordinate on mirror image (camera).
+	 * deg  0 : transfer x,
+	 * deg 90 : don't need to transfer,
+	 * deg180 : transfer y,
+	 * deg270 : transfer x and y.
+	 * To transfer the x, y to correct coordinate on non-mirror image (video).
+	 * deg  0 : don't need to transfer,
+	 * deg 90 : transfer y,
+	 * deg180 : transfer x and y,
+	 * deg270 : transfer x.
+	 */
+	if (pipe_ctx->plane_state->horizontal_mirror) {
+		if (flip_horz_scan_dir && !flip_vert_scan_dir) {
+			data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
+			data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
+		} else if (flip_horz_scan_dir && flip_vert_scan_dir)
+			data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
+		else {
+			if (!flip_horz_scan_dir && !flip_vert_scan_dir)
+				data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
+		}
+	} else {
+		if (flip_horz_scan_dir)
+			data->viewport.x = surf_src.width - data->viewport.x - data->viewport.width;
+		if (flip_vert_scan_dir)
+			data->viewport.y = surf_src.height - data->viewport.y - data->viewport.height;
+	}
+
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
 	data->viewport_c.y = data->viewport.y / vpc_div;
@@ -725,6 +765,15 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct rect *r
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
+
+		if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270 &&
+			pipe_ctx->plane_state->horizontal_mirror) {
+			flip_vert_scan_dir = true;
+		}
+		if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 &&
+			pipe_ctx->plane_state->horizontal_mirror) {
+			flip_vert_scan_dir = false;
+		}
 	} else if (pipe_ctx->plane_state->horizontal_mirror)
 			flip_horz_scan_dir = !flip_horz_scan_dir;
 

commit dc37a9a08d5760e405ffdd94ec6bbb6efededba6
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Thu Aug 16 15:44:38 2018 -0400

    Revert "drm/amdgpu/display: Replace CONFIG_DRM_AMD_DC_DCN1_0 with CONFIG_X86"
    
    This reverts commit 8624c3c4dbfe24fc6740687236a2e196f5f4bfb0.
    
    We need CONFIG_DRM_AMD_DC_DCN1_0 to guard code that is using fp math.
    
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1644f2a946b0..ea6beccfd89d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -41,7 +41,7 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
-#ifdef CONFIG_X86
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dce120/dce120_resource.h"
@@ -85,7 +85,7 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 	case FAMILY_AI:
 		dc_version = DCE_VERSION_12_0;
 		break;
-#ifdef CONFIG_X86
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case FAMILY_RV:
 		dc_version = DCN_VERSION_1_0;
 		break;
@@ -136,7 +136,7 @@ struct resource_pool *dc_create_resource_pool(
 			num_virtual_links, dc);
 		break;
 
-#ifdef CONFIG_X86
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case DCN_VERSION_1_0:
 		res_pool = dcn10_create_resource_pool(
 				num_virtual_links, dc);
@@ -1251,7 +1251,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 }
 
-#ifdef CONFIG_X86
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
@@ -1322,7 +1322,7 @@ bool dc_add_plane_to_context(
 
 	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
 
-#ifdef CONFIG_X86
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	if (!free_pipe) {
 		int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 		if (pipe_idx >= 0)
@@ -1920,7 +1920,7 @@ enum dc_status resource_map_pool_resources(
 	/* acquire new resources */
 	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
-#ifdef CONFIG_X86
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	if (pipe_idx < 0)
 		pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 #endif

commit ad8960a6cb06c446d0a391ce095f6f28edf36aff
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Thu Aug 2 09:45:09 2018 -0400

    drm/amd/display: Check if clock source in use before disabling
    
    [why]
    We are disabling clock source while other pipes are still using
    it, because we don't verify the number of pipes that share it.
    
    [how]
    - Adding a function in resources to return the number of pipes
    sharing the clock source.
    - Checking that no one is sharing the clock source before disabling
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 964ba1af7b07..1644f2a946b0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -268,24 +268,30 @@ bool resource_construct(
 
 	return true;
 }
+static int find_matching_clock_source(
+		const struct resource_pool *pool,
+		struct clock_source *clock_source)
+{
+
+	int i;
 
+	for (i = 0; i < pool->clk_src_count; i++) {
+		if (pool->clock_sources[i] == clock_source)
+			return i;
+	}
+	return -1;
+}
 
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
 		struct clock_source *clock_source)
 {
-	int i;
-
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != clock_source)
-			continue;
+	int i = find_matching_clock_source(pool, clock_source);
 
+	if (i > -1)
 		res_ctx->clock_source_ref_count[i]--;
 
-		break;
-	}
-
 	if (pool->dp_clock_source == clock_source)
 		res_ctx->dp_clock_source_ref_count--;
 }
@@ -295,19 +301,31 @@ void resource_reference_clock_source(
 		const struct resource_pool *pool,
 		struct clock_source *clock_source)
 {
-	int i;
-	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != clock_source)
-			continue;
+	int i = find_matching_clock_source(pool, clock_source);
 
+	if (i > -1)
 		res_ctx->clock_source_ref_count[i]++;
-		break;
-	}
 
 	if (pool->dp_clock_source == clock_source)
 		res_ctx->dp_clock_source_ref_count++;
 }
 
+int resource_get_clock_source_reference(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
+		struct clock_source *clock_source)
+{
+	int i = find_matching_clock_source(pool, clock_source);
+
+	if (i > -1)
+		return res_ctx->clock_source_ref_count[i];
+
+	if (pool->dp_clock_source == clock_source)
+		return res_ctx->dp_clock_source_ref_count;
+
+	return -1;
+}
+
 bool resource_are_streams_timing_synchronizable(
 	struct dc_stream_state *stream1,
 	struct dc_stream_state *stream2)

commit fc69009e35b74e45ad71140e94355e999b8d24af
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Mon Jul 16 09:17:55 2018 -0400

    drm/amd/display: Allow clock sharing b/w HDMI and DVI
    
    [why]
    HDMI and DVI share the same PHY clock and single link
    DVI and HDMI both use 4 lanes, so they should be allowed
    to be sharing the same clock source if all other parameters
    are satisfied.
    
    [how]
    Change a check for general DVI to Dual DVI.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4ca41d6e3bcf..964ba1af7b07 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -372,11 +372,11 @@ static bool is_sharable_clk_src(
 		return false;
 
 	if (dc_is_hdmi_signal(pipe_with_clk_src->stream->signal)
-			&& dc_is_dvi_signal(pipe->stream->signal))
+			&& dc_is_dual_link_signal(pipe->stream->signal))
 		return false;
 
 	if (dc_is_hdmi_signal(pipe->stream->signal)
-			&& dc_is_dvi_signal(pipe_with_clk_src->stream->signal))
+			&& dc_is_dual_link_signal(pipe_with_clk_src->stream->signal))
 		return false;
 
 	if (!resource_are_streams_timing_synchronizable(

commit 3e27e10e2ecee0d3a0083f8ae76354ac9c6ad15c
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Thu Jul 12 16:44:05 2018 -0400

    drm/amd/display: Don't share clk source between DP and HDMI
    
    [why]
    Prevent clock source sharing between HDMI and DP connectors.
    DP shouldn't be sharing its ref clock with phy clock,
    which caused an issue of older ASICS booting up with multiple
    diplays plugged in.
    
    [how]
    Add an extra check that would prevent HDMI and DP sharing clk.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2e65715f76a1..4ca41d6e3bcf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -330,6 +330,9 @@ bool resource_are_streams_timing_synchronizable(
 				!= stream2->timing.pix_clk_khz)
 		return false;
 
+	if (stream1->clamping.c_depth != stream2->clamping.c_depth)
+		return false;
+
 	if (stream1->phy_pix_clk != stream2->phy_pix_clk
 			&& (!dc_is_dp_signal(stream1->signal)
 			|| !dc_is_dp_signal(stream2->signal)))
@@ -337,6 +340,20 @@ bool resource_are_streams_timing_synchronizable(
 
 	return true;
 }
+static bool is_dp_and_hdmi_sharable(
+		struct dc_stream_state *stream1,
+		struct dc_stream_state *stream2)
+{
+	if (stream1->ctx->dc->caps.disable_dp_clk_share)
+		return false;
+
+	if (stream1->clamping.c_depth != COLOR_DEPTH_888 ||
+	    stream2->clamping.c_depth != COLOR_DEPTH_888)
+	return false;
+
+	return true;
+
+}
 
 static bool is_sharable_clk_src(
 	const struct pipe_ctx *pipe_with_clk_src,
@@ -348,7 +365,10 @@ static bool is_sharable_clk_src(
 	if (pipe_with_clk_src->stream->signal == SIGNAL_TYPE_VIRTUAL)
 		return false;
 
-	if (dc_is_dp_signal(pipe_with_clk_src->stream->signal))
+	if (dc_is_dp_signal(pipe_with_clk_src->stream->signal) ||
+		(dc_is_dp_signal(pipe->stream->signal) &&
+		!is_dp_and_hdmi_sharable(pipe_with_clk_src->stream,
+				     pipe->stream)))
 		return false;
 
 	if (dc_is_hdmi_signal(pipe_with_clk_src->stream->signal)

commit 4841203102a337b4b627e6dd3a1dc8c88aec982b
Author: Michel Dänzer <michel.daenzer@amd.com>
Date:   Tue Jul 17 12:37:45 2018 +0200

    drm/amdgpu/display: Replace CONFIG_DRM_AMD_DC_DCN1_0 with CONFIG_X86
    
    Allowing CONFIG_DRM_AMD_DC_DCN1_0 to be disabled on X86 was an
    opportunity for display with Raven Ridge accidentally not working.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9abe5481e40c..2e65715f76a1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -41,7 +41,7 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#ifdef CONFIG_X86
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dce120/dce120_resource.h"
@@ -85,7 +85,7 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 	case FAMILY_AI:
 		dc_version = DCE_VERSION_12_0;
 		break;
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#ifdef CONFIG_X86
 	case FAMILY_RV:
 		dc_version = DCN_VERSION_1_0;
 		break;
@@ -136,7 +136,7 @@ struct resource_pool *dc_create_resource_pool(
 			num_virtual_links, dc);
 		break;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#ifdef CONFIG_X86
 	case DCN_VERSION_1_0:
 		res_pool = dcn10_create_resource_pool(
 				num_virtual_links, dc);
@@ -1213,7 +1213,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#ifdef CONFIG_X86
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
@@ -1284,7 +1284,7 @@ bool dc_add_plane_to_context(
 
 	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#ifdef CONFIG_X86
 	if (!free_pipe) {
 		int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 		if (pipe_idx >= 0)
@@ -1882,7 +1882,7 @@ enum dc_status resource_map_pool_resources(
 	/* acquire new resources */
 	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
-#ifdef CONFIG_DRM_AMD_DC_DCN1_0
+#ifdef CONFIG_X86
 	if (pipe_idx < 0)
 		pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 #endif

commit ece4147fea152fe0761d67b825fb4b4b9f94349b
Author: Ken Chalmers <ken.chalmers@amd.com>
Date:   Wed Jun 27 12:48:21 2018 -0400

    drm/amd/display: Fix new stream count check in dc_add_stream_to_ctx
    
    [Why]
    The previous code could allow through attempts to enable more streams
    than there are timing generators, in designs where the number of pipes
    is greater than the number of timing generators.
    
    [How]
    Compare the new stream count to the resource pool's timing generator
    count, instead of its pipe count.  Also correct a typo in the error
    message.
    
    Signed-off-by: Ken Chalmers <ken.chalmers@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c5fc5250e2bf..9abe5481e40c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1705,8 +1705,8 @@ enum dc_status dc_add_stream_to_ctx(
 	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status res;
 
-	if (new_ctx->stream_count >= dc->res_pool->pipe_count) {
-		DC_ERROR("Max streams reached, can add stream %p !\n", stream);
+	if (new_ctx->stream_count >= dc->res_pool->timing_generator_count) {
+		DC_ERROR("Max streams reached, can't add stream %p !\n", stream);
 		return DC_ERROR_UNEXPECTED;
 	}
 

commit 6ca11246180a6e5e6b5b668545c2575b304c9f7f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 16:44:26 2018 -0400

    drm/amd/display: rename display clock block to dccg
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fca22550417a..c5fc5250e2bf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1948,7 +1948,7 @@ void dc_resource_state_construct(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dst_ctx->dis_clk = dc->res_pool->display_clock;
+	dst_ctx->dis_clk = dc->res_pool->dccg;
 }
 
 enum dc_status dc_validate_global_state(

commit a10dc97ab8e9b5560fc47d57d2048c7455774472
Author: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date:   Thu May 17 14:50:12 2018 -0400

    drm/amd/display: Add use_dynamic_meta flag to stream_state
    
    Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1d716171e581..fca22550417a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2506,7 +2506,8 @@ static void set_hdr_static_info_packet(
 {
 	/* HDR Static Metadata info packet for HDR10 */
 
-	if (!stream->hdr_static_metadata.valid)
+	if (!stream->hdr_static_metadata.valid ||
+			stream->use_dynamic_meta)
 		return;
 
 	*info_packet = stream->hdr_static_metadata;

commit 9a08f51fa737d6cc167beb98bc21db8821b2dff2
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 3 13:42:43 2018 -0400

    drm/amd/display: upgrade scaler math
    
    This change will allow the viewport overlap to apply to rotated/
    mirrored surfaces. Viewport overlap results in extra pixels being
    added to viewport allowing the first few pixels to be scaled as
    if there is no cut-off(mpo or pipe split) and allows us to get matching
    crc's between scaled split and unsplit outputs of the same thing.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 751f3ac9d921..1d716171e581 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -522,13 +522,12 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	}
 }
 
-static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
+static void calculate_recout(struct pipe_ctx *pipe_ctx, struct rect *recout_full)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct rect surf_src = plane_state->src_rect;
 	struct rect surf_clip = plane_state->clip_rect;
-	int recout_full_x, recout_full_y;
 	bool pri_split = pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
@@ -597,20 +596,22 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 		}
 	}
 	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream surf_src offset)
-	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
-	 * 				ratio)
+	 *			* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
+	 *			ratio)
 	 */
-	recout_full_x = stream->dst.x + (plane_state->dst_rect.x - stream->src.x)
+	recout_full->x = stream->dst.x + (plane_state->dst_rect.x - stream->src.x)
 					* stream->dst.width / stream->src.width -
 			surf_src.x * plane_state->dst_rect.width / surf_src.width
 					* stream->dst.width / stream->src.width;
-	recout_full_y = stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
+	recout_full->y = stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
 					* stream->dst.height / stream->src.height -
 			surf_src.y * plane_state->dst_rect.height / surf_src.height
 					* stream->dst.height / stream->src.height;
 
-	recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x - recout_full_x;
-	recout_skip->height = pipe_ctx->plane_res.scl_data.recout.y - recout_full_y;
+	recout_full->width = plane_state->dst_rect.width
+					* stream->dst.width / stream->src.width;
+	recout_full->height = plane_state->dst_rect.height
+					* stream->dst.height / stream->src.height;
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
@@ -662,7 +663,7 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_res.scl_data.ratios.vert_c, 19);
 }
 
-static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
+static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct rect *recout_full)
 {
 	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
 	struct rect src = pipe_ctx->plane_state->src_rect;
@@ -680,15 +681,14 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		flip_vert_scan_dir = true;
 	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		flip_horz_scan_dir = true;
-	if (pipe_ctx->plane_state->horizontal_mirror)
-		flip_horz_scan_dir = !flip_horz_scan_dir;
 
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
-	}
+	} else if (pipe_ctx->plane_state->horizontal_mirror)
+			flip_horz_scan_dir = !flip_horz_scan_dir;
 
 	/*
 	 * Init calculated according to formula:
@@ -708,127 +708,286 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	data->inits.v_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.v_c, dc_fixpt_div_int(
 			dc_fixpt_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2)), 19);
 
+	if (!flip_horz_scan_dir) {
+		/* Adjust for viewport end clip-off */
+		if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
+			int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.h, data->ratios.horz));
 
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
+		}
+		if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
+			int vp_clip = (src.x + src.width) / vpc_div -
+					data->viewport_c.width - data->viewport_c.x;
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.h_c, data->ratios.horz_c));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
+		}
 
-	/* Adjust for viewport end clip-off */
-	if ((data->viewport.x + data->viewport.width) < (src.x + src.width) && !flip_horz_scan_dir) {
-		int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
-		int int_part = dc_fixpt_floor(
-				dc_fixpt_sub(data->inits.h, data->ratios.horz));
-
-		int_part = int_part > 0 ? int_part : 0;
-		data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
-	}
-	if ((data->viewport.y + data->viewport.height) < (src.y + src.height) && !flip_vert_scan_dir) {
-		int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
-		int int_part = dc_fixpt_floor(
-				dc_fixpt_sub(data->inits.v, data->ratios.vert));
-
-		int_part = int_part > 0 ? int_part : 0;
-		data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
-	}
-	if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div && !flip_horz_scan_dir) {
-		int vp_clip = (src.x + src.width) / vpc_div -
-				data->viewport_c.width - data->viewport_c.x;
-		int int_part = dc_fixpt_floor(
-				dc_fixpt_sub(data->inits.h_c, data->ratios.horz_c));
-
-		int_part = int_part > 0 ? int_part : 0;
-		data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
-	}
-	if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div && !flip_vert_scan_dir) {
-		int vp_clip = (src.y + src.height) / vpc_div -
-				data->viewport_c.height - data->viewport_c.y;
-		int int_part = dc_fixpt_floor(
-				dc_fixpt_sub(data->inits.v_c, data->ratios.vert_c));
-
-		int_part = int_part > 0 ? int_part : 0;
-		data->viewport_c.height += int_part < vp_clip ? int_part : vp_clip;
-	}
-
-	/* Adjust for non-0 viewport offset */
-	if (data->viewport.x && !flip_horz_scan_dir) {
-		int int_part;
-
-		data->inits.h = dc_fixpt_add(data->inits.h, dc_fixpt_mul_int(
-				data->ratios.horz, recout_skip->width));
-		int_part = dc_fixpt_floor(data->inits.h) - data->viewport.x;
-		if (int_part < data->taps.h_taps) {
-			int int_adj = data->viewport.x >= (data->taps.h_taps - int_part) ?
-						(data->taps.h_taps - int_part) : data->viewport.x;
-			data->viewport.x -= int_adj;
-			data->viewport.width += int_adj;
-			int_part += int_adj;
-		} else if (int_part > data->taps.h_taps) {
-			data->viewport.x += int_part - data->taps.h_taps;
-			data->viewport.width -= int_part - data->taps.h_taps;
-			int_part = data->taps.h_taps;
+		/* Adjust for non-0 viewport offset */
+		if (data->viewport.x) {
+			int int_part;
+
+			data->inits.h = dc_fixpt_add(data->inits.h, dc_fixpt_mul_int(
+					data->ratios.horz, data->recout.x - recout_full->x));
+			int_part = dc_fixpt_floor(data->inits.h) - data->viewport.x;
+			if (int_part < data->taps.h_taps) {
+				int int_adj = data->viewport.x >= (data->taps.h_taps - int_part) ?
+							(data->taps.h_taps - int_part) : data->viewport.x;
+				data->viewport.x -= int_adj;
+				data->viewport.width += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.h_taps) {
+				data->viewport.x += int_part - data->taps.h_taps;
+				data->viewport.width -= int_part - data->taps.h_taps;
+				int_part = data->taps.h_taps;
+			}
+			data->inits.h.value &= 0xffffffff;
+			data->inits.h = dc_fixpt_add_int(data->inits.h, int_part);
 		}
-		data->inits.h.value &= 0xffffffff;
-		data->inits.h = dc_fixpt_add_int(data->inits.h, int_part);
-	}
-
-	if (data->viewport_c.x && !flip_horz_scan_dir) {
-		int int_part;
-
-		data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_mul_int(
-				data->ratios.horz_c, recout_skip->width));
-		int_part = dc_fixpt_floor(data->inits.h_c) - data->viewport_c.x;
-		if (int_part < data->taps.h_taps_c) {
-			int int_adj = data->viewport_c.x >= (data->taps.h_taps_c - int_part) ?
-					(data->taps.h_taps_c - int_part) : data->viewport_c.x;
-			data->viewport_c.x -= int_adj;
-			data->viewport_c.width += int_adj;
-			int_part += int_adj;
-		} else if (int_part > data->taps.h_taps_c) {
-			data->viewport_c.x += int_part - data->taps.h_taps_c;
-			data->viewport_c.width -= int_part - data->taps.h_taps_c;
-			int_part = data->taps.h_taps_c;
+
+		if (data->viewport_c.x) {
+			int int_part;
+
+			data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_mul_int(
+					data->ratios.horz_c, data->recout.x - recout_full->x));
+			int_part = dc_fixpt_floor(data->inits.h_c) - data->viewport_c.x;
+			if (int_part < data->taps.h_taps_c) {
+				int int_adj = data->viewport_c.x >= (data->taps.h_taps_c - int_part) ?
+						(data->taps.h_taps_c - int_part) : data->viewport_c.x;
+				data->viewport_c.x -= int_adj;
+				data->viewport_c.width += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.h_taps_c) {
+				data->viewport_c.x += int_part - data->taps.h_taps_c;
+				data->viewport_c.width -= int_part - data->taps.h_taps_c;
+				int_part = data->taps.h_taps_c;
+			}
+			data->inits.h_c.value &= 0xffffffff;
+			data->inits.h_c = dc_fixpt_add_int(data->inits.h_c, int_part);
 		}
-		data->inits.h_c.value &= 0xffffffff;
-		data->inits.h_c = dc_fixpt_add_int(data->inits.h_c, int_part);
-	}
-
-	if (data->viewport.y && !flip_vert_scan_dir) {
-		int int_part;
-
-		data->inits.v = dc_fixpt_add(data->inits.v, dc_fixpt_mul_int(
-				data->ratios.vert, recout_skip->height));
-		int_part = dc_fixpt_floor(data->inits.v) - data->viewport.y;
-		if (int_part < data->taps.v_taps) {
-			int int_adj = data->viewport.y >= (data->taps.v_taps - int_part) ?
-						(data->taps.v_taps - int_part) : data->viewport.y;
-			data->viewport.y -= int_adj;
-			data->viewport.height += int_adj;
-			int_part += int_adj;
-		} else if (int_part > data->taps.v_taps) {
-			data->viewport.y += int_part - data->taps.v_taps;
-			data->viewport.height -= int_part - data->taps.v_taps;
-			int_part = data->taps.v_taps;
+	} else {
+		/* Adjust for non-0 viewport offset */
+		if (data->viewport.x) {
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.h, data->ratios.horz));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport.width += int_part < data->viewport.x ? int_part : data->viewport.x;
+			data->viewport.x -= int_part < data->viewport.x ? int_part : data->viewport.x;
+		}
+		if (data->viewport_c.x) {
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.h_c, data->ratios.horz_c));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport_c.width += int_part < data->viewport_c.x ? int_part : data->viewport_c.x;
+			data->viewport_c.x -= int_part < data->viewport_c.x ? int_part : data->viewport_c.x;
 		}
-		data->inits.v.value &= 0xffffffff;
-		data->inits.v = dc_fixpt_add_int(data->inits.v, int_part);
-	}
-
-	if (data->viewport_c.y && !flip_vert_scan_dir) {
-		int int_part;
-
-		data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_mul_int(
-				data->ratios.vert_c, recout_skip->height));
-		int_part = dc_fixpt_floor(data->inits.v_c) - data->viewport_c.y;
-		if (int_part < data->taps.v_taps_c) {
-			int int_adj = data->viewport_c.y >= (data->taps.v_taps_c - int_part) ?
-					(data->taps.v_taps_c - int_part) : data->viewport_c.y;
-			data->viewport_c.y -= int_adj;
-			data->viewport_c.height += int_adj;
-			int_part += int_adj;
-		} else if (int_part > data->taps.v_taps_c) {
-			data->viewport_c.y += int_part - data->taps.v_taps_c;
-			data->viewport_c.height -= int_part - data->taps.v_taps_c;
-			int_part = data->taps.v_taps_c;
+
+		/* Adjust for viewport end clip-off */
+		if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
+			int int_part;
+			int end_offset = src.x + src.width
+					- data->viewport.x - data->viewport.width;
+
+			/*
+			 * this is init if vp had no offset, keep in mind this is from the
+			 * right side of vp due to scan direction
+			 */
+			data->inits.h = dc_fixpt_add(data->inits.h, dc_fixpt_mul_int(
+					data->ratios.horz, data->recout.x - recout_full->x));
+			/*
+			 * this is the difference between first pixel of viewport available to read
+			 * and init position, takning into account scan direction
+			 */
+			int_part = dc_fixpt_floor(data->inits.h) - end_offset;
+			if (int_part < data->taps.h_taps) {
+				int int_adj = end_offset >= (data->taps.h_taps - int_part) ?
+							(data->taps.h_taps - int_part) : end_offset;
+				data->viewport.width += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.h_taps) {
+				data->viewport.width += int_part - data->taps.h_taps;
+				int_part = data->taps.h_taps;
+			}
+			data->inits.h.value &= 0xffffffff;
+			data->inits.h = dc_fixpt_add_int(data->inits.h, int_part);
+		}
+
+		if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
+			int int_part;
+			int end_offset = (src.x + src.width) / vpc_div
+					- data->viewport_c.x - data->viewport_c.width;
+
+			/*
+			 * this is init if vp had no offset, keep in mind this is from the
+			 * right side of vp due to scan direction
+			 */
+			data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_mul_int(
+					data->ratios.horz_c, data->recout.x - recout_full->x));
+			/*
+			 * this is the difference between first pixel of viewport available to read
+			 * and init position, takning into account scan direction
+			 */
+			int_part = dc_fixpt_floor(data->inits.h_c) - end_offset;
+			if (int_part < data->taps.h_taps_c) {
+				int int_adj = end_offset >= (data->taps.h_taps_c - int_part) ?
+							(data->taps.h_taps_c - int_part) : end_offset;
+				data->viewport_c.width += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.h_taps_c) {
+				data->viewport_c.width += int_part - data->taps.h_taps_c;
+				int_part = data->taps.h_taps_c;
+			}
+			data->inits.h_c.value &= 0xffffffff;
+			data->inits.h_c = dc_fixpt_add_int(data->inits.h_c, int_part);
+		}
+
+	}
+	if (!flip_vert_scan_dir) {
+		/* Adjust for viewport end clip-off */
+		if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
+			int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.v, data->ratios.vert));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
+		}
+		if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
+			int vp_clip = (src.y + src.height) / vpc_div -
+					data->viewport_c.height - data->viewport_c.y;
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.v_c, data->ratios.vert_c));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport_c.height += int_part < vp_clip ? int_part : vp_clip;
+		}
+
+		/* Adjust for non-0 viewport offset */
+		if (data->viewport.y) {
+			int int_part;
+
+			data->inits.v = dc_fixpt_add(data->inits.v, dc_fixpt_mul_int(
+					data->ratios.vert, data->recout.y - recout_full->y));
+			int_part = dc_fixpt_floor(data->inits.v) - data->viewport.y;
+			if (int_part < data->taps.v_taps) {
+				int int_adj = data->viewport.y >= (data->taps.v_taps - int_part) ?
+							(data->taps.v_taps - int_part) : data->viewport.y;
+				data->viewport.y -= int_adj;
+				data->viewport.height += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.v_taps) {
+				data->viewport.y += int_part - data->taps.v_taps;
+				data->viewport.height -= int_part - data->taps.v_taps;
+				int_part = data->taps.v_taps;
+			}
+			data->inits.v.value &= 0xffffffff;
+			data->inits.v = dc_fixpt_add_int(data->inits.v, int_part);
+		}
+
+		if (data->viewport_c.y) {
+			int int_part;
+
+			data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_mul_int(
+					data->ratios.vert_c, data->recout.y - recout_full->y));
+			int_part = dc_fixpt_floor(data->inits.v_c) - data->viewport_c.y;
+			if (int_part < data->taps.v_taps_c) {
+				int int_adj = data->viewport_c.y >= (data->taps.v_taps_c - int_part) ?
+						(data->taps.v_taps_c - int_part) : data->viewport_c.y;
+				data->viewport_c.y -= int_adj;
+				data->viewport_c.height += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.v_taps_c) {
+				data->viewport_c.y += int_part - data->taps.v_taps_c;
+				data->viewport_c.height -= int_part - data->taps.v_taps_c;
+				int_part = data->taps.v_taps_c;
+			}
+			data->inits.v_c.value &= 0xffffffff;
+			data->inits.v_c = dc_fixpt_add_int(data->inits.v_c, int_part);
+		}
+	} else {
+		/* Adjust for non-0 viewport offset */
+		if (data->viewport.y) {
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.v, data->ratios.vert));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport.height += int_part < data->viewport.y ? int_part : data->viewport.y;
+			data->viewport.y -= int_part < data->viewport.y ? int_part : data->viewport.y;
+		}
+		if (data->viewport_c.y) {
+			int int_part = dc_fixpt_floor(
+					dc_fixpt_sub(data->inits.v_c, data->ratios.vert_c));
+
+			int_part = int_part > 0 ? int_part : 0;
+			data->viewport_c.height += int_part < data->viewport_c.y ? int_part : data->viewport_c.y;
+			data->viewport_c.y -= int_part < data->viewport_c.y ? int_part : data->viewport_c.y;
+		}
+
+		/* Adjust for viewport end clip-off */
+		if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
+			int int_part;
+			int end_offset = src.y + src.height
+					- data->viewport.y - data->viewport.height;
+
+			/*
+			 * this is init if vp had no offset, keep in mind this is from the
+			 * right side of vp due to scan direction
+			 */
+			data->inits.v = dc_fixpt_add(data->inits.v, dc_fixpt_mul_int(
+					data->ratios.vert, data->recout.y - recout_full->y));
+			/*
+			 * this is the difference between first pixel of viewport available to read
+			 * and init position, taking into account scan direction
+			 */
+			int_part = dc_fixpt_floor(data->inits.v) - end_offset;
+			if (int_part < data->taps.v_taps) {
+				int int_adj = end_offset >= (data->taps.v_taps - int_part) ?
+							(data->taps.v_taps - int_part) : end_offset;
+				data->viewport.height += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.v_taps) {
+				data->viewport.height += int_part - data->taps.v_taps;
+				int_part = data->taps.v_taps;
+			}
+			data->inits.v.value &= 0xffffffff;
+			data->inits.v = dc_fixpt_add_int(data->inits.v, int_part);
+		}
+
+		if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
+			int int_part;
+			int end_offset = (src.y + src.height) / vpc_div
+					- data->viewport_c.y - data->viewport_c.height;
+
+			/*
+			 * this is init if vp had no offset, keep in mind this is from the
+			 * right side of vp due to scan direction
+			 */
+			data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_mul_int(
+					data->ratios.vert_c, data->recout.y - recout_full->y));
+			/*
+			 * this is the difference between first pixel of viewport available to read
+			 * and init position, taking into account scan direction
+			 */
+			int_part = dc_fixpt_floor(data->inits.v_c) - end_offset;
+			if (int_part < data->taps.v_taps_c) {
+				int int_adj = end_offset >= (data->taps.v_taps_c - int_part) ?
+							(data->taps.v_taps_c - int_part) : end_offset;
+				data->viewport_c.height += int_adj;
+				int_part += int_adj;
+			} else if (int_part > data->taps.v_taps_c) {
+				data->viewport_c.height += int_part - data->taps.v_taps_c;
+				int_part = data->taps.v_taps_c;
+			}
+			data->inits.v_c.value &= 0xffffffff;
+			data->inits.v_c = dc_fixpt_add_int(data->inits.v_c, int_part);
 		}
-		data->inits.v_c.value &= 0xffffffff;
-		data->inits.v_c = dc_fixpt_add_int(data->inits.v_c, int_part);
 	}
 
 	/* Interlaced inits based on final vert inits */
@@ -846,7 +1005,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
-	struct view recout_skip = { 0 };
+	struct rect recout_full = { 0 };
 	bool res = false;
 	DC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);
 	/* Important: scaling ratio calculation requires pixel format,
@@ -866,7 +1025,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->plane_res.scl_data.viewport.height < 16 || pipe_ctx->plane_res.scl_data.viewport.width < 16)
 		return false;
 
-	calculate_recout(pipe_ctx, &recout_skip);
+	calculate_recout(pipe_ctx, &recout_full);
 
 	/**
 	 * Setting line buffer pixel depth to 24bpp yields banding
@@ -910,7 +1069,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	if (res)
 		/* May need to re-check lb size after this in some obscure scenario */
-		calculate_inits_and_adj_vp(pipe_ctx, &recout_skip);
+		calculate_inits_and_adj_vp(pipe_ctx, &recout_full);
 
 	DC_LOG_SCALER(
 				"%s: Viewport:\nheight:%d width:%d x:%d "

commit 0002d3ac8aadcb2850475557de32234b447ba502
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 14:19:23 2018 -0400

    drm/amd/display: truncate scaling ratios and inits to 19 bit precision
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 082458f2097c..751f3ac9d921 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -652,6 +652,14 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 		pipe_ctx->plane_res.scl_data.ratios.horz_c.value /= 2;
 		pipe_ctx->plane_res.scl_data.ratios.vert_c.value /= 2;
 	}
+	pipe_ctx->plane_res.scl_data.ratios.horz = dc_fixpt_truncate(
+			pipe_ctx->plane_res.scl_data.ratios.horz, 19);
+	pipe_ctx->plane_res.scl_data.ratios.vert = dc_fixpt_truncate(
+			pipe_ctx->plane_res.scl_data.ratios.vert, 19);
+	pipe_ctx->plane_res.scl_data.ratios.horz_c = dc_fixpt_truncate(
+			pipe_ctx->plane_res.scl_data.ratios.horz_c, 19);
+	pipe_ctx->plane_res.scl_data.ratios.vert_c = dc_fixpt_truncate(
+			pipe_ctx->plane_res.scl_data.ratios.vert_c, 19);
 }
 
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
@@ -688,17 +696,18 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	 * 	init_bot = init + scaling_ratio
 	 * 	init_c = init + truncated_vp_c_offset(from calculate viewport)
 	 */
-	data->inits.h = dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.horz, data->taps.h_taps + 1), 2);
+	data->inits.h = dc_fixpt_truncate(dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.horz, data->taps.h_taps + 1), 2), 19);
 
-	data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2));
+	data->inits.h_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.h_c, dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2)), 19);
 
-	data->inits.v = dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.vert, data->taps.v_taps + 1), 2);
+	data->inits.v = dc_fixpt_truncate(dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.vert, data->taps.v_taps + 1), 2), 19);
+
+	data->inits.v_c = dc_fixpt_truncate(dc_fixpt_add(data->inits.v_c, dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2)), 19);
 
-	data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_div_int(
-			dc_fixpt_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2));
 
 
 	/* Adjust for viewport end clip-off */

commit eb0e515464e4a1be730c7ac7a01c3ba04c98ea97
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Apr 18 11:37:53 2018 -0400

    drm/amd/display: get rid of 32.32 unsigned fixed point
    
    32.32 is redundant, 31.32 does everything we use 32.32 for
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 345835ff58d1..082458f2097c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -496,9 +496,9 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	data->viewport_c.x = data->viewport.x / vpc_div;
 	data->viewport_c.y = data->viewport.y / vpc_div;
 	data->inits.h_c = (data->viewport.x % vpc_div) != 0 ?
-			dal_fixed31_32_half : dal_fixed31_32_zero;
+			dc_fixpt_half : dc_fixpt_zero;
 	data->inits.v_c = (data->viewport.y % vpc_div) != 0 ?
-			dal_fixed31_32_half : dal_fixed31_32_zero;
+			dc_fixpt_half : dc_fixpt_zero;
 	/* Round up, assume original video size always even dimensions */
 	data->viewport_c.width = (data->viewport.width + vpc_div - 1) / vpc_div;
 	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
@@ -627,10 +627,10 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
-	pipe_ctx->plane_res.scl_data.ratios.horz = dal_fixed31_32_from_fraction(
+	pipe_ctx->plane_res.scl_data.ratios.horz = dc_fixpt_from_fraction(
 					surf_src.width,
 					plane_state->dst_rect.width);
-	pipe_ctx->plane_res.scl_data.ratios.vert = dal_fixed31_32_from_fraction(
+	pipe_ctx->plane_res.scl_data.ratios.vert = dc_fixpt_from_fraction(
 					surf_src.height,
 					plane_state->dst_rect.height);
 
@@ -688,32 +688,32 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	 * 	init_bot = init + scaling_ratio
 	 * 	init_c = init + truncated_vp_c_offset(from calculate viewport)
 	 */
-	data->inits.h = dal_fixed31_32_div_int(
-			dal_fixed31_32_add_int(data->ratios.horz, data->taps.h_taps + 1), 2);
+	data->inits.h = dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.horz, data->taps.h_taps + 1), 2);
 
-	data->inits.h_c = dal_fixed31_32_add(data->inits.h_c, dal_fixed31_32_div_int(
-			dal_fixed31_32_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2));
+	data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2));
 
-	data->inits.v = dal_fixed31_32_div_int(
-			dal_fixed31_32_add_int(data->ratios.vert, data->taps.v_taps + 1), 2);
+	data->inits.v = dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.vert, data->taps.v_taps + 1), 2);
 
-	data->inits.v_c = dal_fixed31_32_add(data->inits.v_c, dal_fixed31_32_div_int(
-			dal_fixed31_32_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2));
+	data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_div_int(
+			dc_fixpt_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2));
 
 
 	/* Adjust for viewport end clip-off */
 	if ((data->viewport.x + data->viewport.width) < (src.x + src.width) && !flip_horz_scan_dir) {
 		int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
-		int int_part = dal_fixed31_32_floor(
-				dal_fixed31_32_sub(data->inits.h, data->ratios.horz));
+		int int_part = dc_fixpt_floor(
+				dc_fixpt_sub(data->inits.h, data->ratios.horz));
 
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
 	}
 	if ((data->viewport.y + data->viewport.height) < (src.y + src.height) && !flip_vert_scan_dir) {
 		int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
-		int int_part = dal_fixed31_32_floor(
-				dal_fixed31_32_sub(data->inits.v, data->ratios.vert));
+		int int_part = dc_fixpt_floor(
+				dc_fixpt_sub(data->inits.v, data->ratios.vert));
 
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
@@ -721,8 +721,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div && !flip_horz_scan_dir) {
 		int vp_clip = (src.x + src.width) / vpc_div -
 				data->viewport_c.width - data->viewport_c.x;
-		int int_part = dal_fixed31_32_floor(
-				dal_fixed31_32_sub(data->inits.h_c, data->ratios.horz_c));
+		int int_part = dc_fixpt_floor(
+				dc_fixpt_sub(data->inits.h_c, data->ratios.horz_c));
 
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
@@ -730,8 +730,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div && !flip_vert_scan_dir) {
 		int vp_clip = (src.y + src.height) / vpc_div -
 				data->viewport_c.height - data->viewport_c.y;
-		int int_part = dal_fixed31_32_floor(
-				dal_fixed31_32_sub(data->inits.v_c, data->ratios.vert_c));
+		int int_part = dc_fixpt_floor(
+				dc_fixpt_sub(data->inits.v_c, data->ratios.vert_c));
 
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport_c.height += int_part < vp_clip ? int_part : vp_clip;
@@ -741,9 +741,9 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	if (data->viewport.x && !flip_horz_scan_dir) {
 		int int_part;
 
-		data->inits.h = dal_fixed31_32_add(data->inits.h, dal_fixed31_32_mul_int(
+		data->inits.h = dc_fixpt_add(data->inits.h, dc_fixpt_mul_int(
 				data->ratios.horz, recout_skip->width));
-		int_part = dal_fixed31_32_floor(data->inits.h) - data->viewport.x;
+		int_part = dc_fixpt_floor(data->inits.h) - data->viewport.x;
 		if (int_part < data->taps.h_taps) {
 			int int_adj = data->viewport.x >= (data->taps.h_taps - int_part) ?
 						(data->taps.h_taps - int_part) : data->viewport.x;
@@ -756,15 +756,15 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 			int_part = data->taps.h_taps;
 		}
 		data->inits.h.value &= 0xffffffff;
-		data->inits.h = dal_fixed31_32_add_int(data->inits.h, int_part);
+		data->inits.h = dc_fixpt_add_int(data->inits.h, int_part);
 	}
 
 	if (data->viewport_c.x && !flip_horz_scan_dir) {
 		int int_part;
 
-		data->inits.h_c = dal_fixed31_32_add(data->inits.h_c, dal_fixed31_32_mul_int(
+		data->inits.h_c = dc_fixpt_add(data->inits.h_c, dc_fixpt_mul_int(
 				data->ratios.horz_c, recout_skip->width));
-		int_part = dal_fixed31_32_floor(data->inits.h_c) - data->viewport_c.x;
+		int_part = dc_fixpt_floor(data->inits.h_c) - data->viewport_c.x;
 		if (int_part < data->taps.h_taps_c) {
 			int int_adj = data->viewport_c.x >= (data->taps.h_taps_c - int_part) ?
 					(data->taps.h_taps_c - int_part) : data->viewport_c.x;
@@ -777,15 +777,15 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 			int_part = data->taps.h_taps_c;
 		}
 		data->inits.h_c.value &= 0xffffffff;
-		data->inits.h_c = dal_fixed31_32_add_int(data->inits.h_c, int_part);
+		data->inits.h_c = dc_fixpt_add_int(data->inits.h_c, int_part);
 	}
 
 	if (data->viewport.y && !flip_vert_scan_dir) {
 		int int_part;
 
-		data->inits.v = dal_fixed31_32_add(data->inits.v, dal_fixed31_32_mul_int(
+		data->inits.v = dc_fixpt_add(data->inits.v, dc_fixpt_mul_int(
 				data->ratios.vert, recout_skip->height));
-		int_part = dal_fixed31_32_floor(data->inits.v) - data->viewport.y;
+		int_part = dc_fixpt_floor(data->inits.v) - data->viewport.y;
 		if (int_part < data->taps.v_taps) {
 			int int_adj = data->viewport.y >= (data->taps.v_taps - int_part) ?
 						(data->taps.v_taps - int_part) : data->viewport.y;
@@ -798,15 +798,15 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 			int_part = data->taps.v_taps;
 		}
 		data->inits.v.value &= 0xffffffff;
-		data->inits.v = dal_fixed31_32_add_int(data->inits.v, int_part);
+		data->inits.v = dc_fixpt_add_int(data->inits.v, int_part);
 	}
 
 	if (data->viewport_c.y && !flip_vert_scan_dir) {
 		int int_part;
 
-		data->inits.v_c = dal_fixed31_32_add(data->inits.v_c, dal_fixed31_32_mul_int(
+		data->inits.v_c = dc_fixpt_add(data->inits.v_c, dc_fixpt_mul_int(
 				data->ratios.vert_c, recout_skip->height));
-		int_part = dal_fixed31_32_floor(data->inits.v_c) - data->viewport_c.y;
+		int_part = dc_fixpt_floor(data->inits.v_c) - data->viewport_c.y;
 		if (int_part < data->taps.v_taps_c) {
 			int int_adj = data->viewport_c.y >= (data->taps.v_taps_c - int_part) ?
 					(data->taps.v_taps_c - int_part) : data->viewport_c.y;
@@ -819,12 +819,12 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 			int_part = data->taps.v_taps_c;
 		}
 		data->inits.v_c.value &= 0xffffffff;
-		data->inits.v_c = dal_fixed31_32_add_int(data->inits.v_c, int_part);
+		data->inits.v_c = dc_fixpt_add_int(data->inits.v_c, int_part);
 	}
 
 	/* Interlaced inits based on final vert inits */
-	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
-	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
+	data->inits.v_bot = dc_fixpt_add(data->inits.v, data->ratios.vert);
+	data->inits.v_c_bot = dc_fixpt_add(data->inits.v_c, data->ratios.vert_c);
 
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {

commit 2b6dc93a3d439136c3fe11291a506e581b84a327
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed May 16 08:39:58 2018 -0500

    drm/amdgpu/display: remove VEGAM config option
    
    Leftover from bringup.  No need to keep it around for
    upstream.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9eb731fb5251..345835ff58d1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -79,10 +79,8 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 				ASIC_REV_IS_POLARIS12_V(asic_id.hw_internal_rev)) {
 			dc_version = DCE_VERSION_11_2;
 		}
-#if defined(CONFIG_DRM_AMD_DC_VEGAM)
 		if (ASIC_REV_IS_VEGAM(asic_id.hw_internal_rev))
 			dc_version = DCE_VERSION_11_22;
-#endif
 		break;
 	case FAMILY_AI:
 		dc_version = DCE_VERSION_12_0;
@@ -129,9 +127,7 @@ struct resource_pool *dc_create_resource_pool(
 			num_virtual_links, dc, asic_id);
 		break;
 	case DCE_VERSION_11_2:
-#if defined(CONFIG_DRM_AMD_DC_VEGAM)
 	case DCE_VERSION_11_22:
-#endif
 		res_pool = dce112_create_resource_pool(
 			num_virtual_links, dc);
 		break;

commit ada8ce1530a7d1bf2e37560afa57bad911d36e81
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Apr 20 10:53:50 2018 -0400

    drm/amd/display: Couple formatting fixes
    
    Things such as mis-indent, and space at beginning of line.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4de1b443e438..9eb731fb5251 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1798,9 +1798,9 @@ enum dc_status dc_validate_global_state(
 		return DC_ERROR_UNEXPECTED;
 
 	if (dc->res_pool->funcs->validate_global) {
-			result = dc->res_pool->funcs->validate_global(dc, new_ctx);
-			if (result != DC_OK)
-				return result;
+		result = dc->res_pool->funcs->validate_global(dc, new_ctx);
+		if (result != DC_OK)
+			return result;
 	}
 
 	for (i = 0; i < new_ctx->stream_count; i++) {

commit 6b622181230e7c9286f594e4e51266b6f019b031
Author: Julian Parkin <jparkin@amd.com>
Date:   Tue Apr 17 11:49:06 2018 -0400

    drm/amd/display: reprogram infoframe during apply_ctx_to_hw
    
    To ensure the infoframe gets updated during an SDR/HDR switch
    this change adds a new function to to check if the HDR static
    metadata has changed and adds it to is_timing_changed and
    pipe_need_reprogram checks
    
    Signed-off-by: Julian Parkin <jparkin@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 447729cd29f0..4de1b443e438 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1310,6 +1310,19 @@ bool dc_add_all_planes_for_stream(
 }
 
 
+static bool is_hdr_static_meta_changed(struct dc_stream_state *cur_stream,
+	struct dc_stream_state *new_stream)
+{
+	if (cur_stream == NULL)
+		return true;
+
+	if (memcmp(&cur_stream->hdr_static_metadata,
+			&new_stream->hdr_static_metadata,
+			sizeof(struct dc_info_packet)) != 0)
+		return true;
+
+	return false;
+}
 
 static bool is_timing_changed(struct dc_stream_state *cur_stream,
 		struct dc_stream_state *new_stream)
@@ -1345,6 +1358,9 @@ static bool are_stream_backends_same(
 	if (is_timing_changed(stream_a, stream_b))
 		return false;
 
+	if (is_hdr_static_meta_changed(stream_a, stream_b))
+		return false;
+
 	return true;
 }
 
@@ -2548,6 +2564,8 @@ bool pipe_need_reprogram(
 	if (is_timing_changed(pipe_ctx_old->stream, pipe_ctx->stream))
 		return true;
 
+	if (is_hdr_static_meta_changed(pipe_ctx_old->stream, pipe_ctx->stream))
+		return true;
 
 	return false;
 }

commit 0c75d5acc80dc5247962370c9f555922197b1ec3
Author: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
Date:   Wed Apr 11 15:39:35 2018 -0500

    drm/amd/display: Implement VEGAM device IDs in DC
    
    Implement device IDs for VEGAM
    
    Signed-off-by: Jerry (Fangzhi) Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d7a92eca8a27..447729cd29f0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -79,6 +79,10 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 				ASIC_REV_IS_POLARIS12_V(asic_id.hw_internal_rev)) {
 			dc_version = DCE_VERSION_11_2;
 		}
+#if defined(CONFIG_DRM_AMD_DC_VEGAM)
+		if (ASIC_REV_IS_VEGAM(asic_id.hw_internal_rev))
+			dc_version = DCE_VERSION_11_22;
+#endif
 		break;
 	case FAMILY_AI:
 		dc_version = DCE_VERSION_12_0;
@@ -125,6 +129,9 @@ struct resource_pool *dc_create_resource_pool(
 			num_virtual_links, dc, asic_id);
 		break;
 	case DCE_VERSION_11_2:
+#if defined(CONFIG_DRM_AMD_DC_VEGAM)
+	case DCE_VERSION_11_22:
+#endif
 		res_pool = dce112_create_resource_pool(
 			num_virtual_links, dc);
 		break;

commit c5b38aec266deade4067ddc606634ace68d2da8c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Mar 29 16:39:10 2018 -0400

    drm/amd/display: fix segfault on insufficient TG during validation
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 8d7bc1fa9ffe..d7a92eca8a27 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1700,7 +1700,7 @@ enum dc_status resource_map_pool_resources(
 		pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
 #endif
 
-	if (pipe_idx < 0)
+	if (pipe_idx < 0 || context->res_ctx.pipe_ctx[pipe_idx].stream_res.tg == NULL)
 		return DC_NO_CONTROLLER_RESOURCE;
 
 	pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];

commit 754e3673201eb192be68b8a07f2e448d75f69dfe
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Tue Mar 27 23:12:21 2018 -0400

    drm/amd/display: Fix structure initialization of hdmi_info_packet
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index e1036e409877..8d7bc1fa9ffe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1853,11 +1853,13 @@ static void set_avi_info_frame(
 	unsigned int cn0_cn1_value = 0;
 	uint8_t *check_sum = NULL;
 	uint8_t byte_index = 0;
-	union hdmi_info_packet hdmi_info = {0};
+	union hdmi_info_packet hdmi_info;
 	union display_content_support support = {0};
 	unsigned int vic = pipe_ctx->stream->timing.vic;
 	enum dc_timing_3d_format format;
 
+	memset(&hdmi_info, 0, sizeof(union hdmi_info_packet));
+
 	color_space = pipe_ctx->stream->output_color_space;
 	if (color_space == COLOR_SPACE_UNKNOWN)
 		color_space = (stream->timing.pixel_encoding == PIXEL_ENCODING_RGB) ?

commit 0eeef69022b4ea503106f5f695fd5d8ae2c72706
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Apr 9 14:55:17 2018 -0500

    drm/amd/display: Updated HDR Static Metadata to directly take info packet raw
    
    Updated HDR Static Metadata to directly take info packet raw
    
    Updating Infopacket does not require Passive
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index eb8f4792198c..e1036e409877 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2315,97 +2315,12 @@ static void set_hdr_static_info_packet(
 		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
-	uint16_t i = 0;
-	enum signal_type signal = stream->signal;
-	uint32_t data;
+	/* HDR Static Metadata info packet for HDR10 */
 
-	if (!stream->hdr_static_metadata.hdr_supported)
+	if (!stream->hdr_static_metadata.valid)
 		return;
 
-	if (dc_is_hdmi_signal(signal)) {
-		info_packet->valid = true;
-
-		info_packet->hb0 = 0x87;
-		info_packet->hb1 = 0x01;
-		info_packet->hb2 = 0x1A;
-		i = 1;
-	} else if (dc_is_dp_signal(signal)) {
-		info_packet->valid = true;
-
-		info_packet->hb0 = 0x00;
-		info_packet->hb1 = 0x87;
-		info_packet->hb2 = 0x1D;
-		info_packet->hb3 = (0x13 << 2);
-		i = 2;
-	}
-
-	data = stream->hdr_static_metadata.is_hdr;
-	info_packet->sb[i++] = data ? 0x02 : 0x00;
-	info_packet->sb[i++] = 0x00;
-
-	data = stream->hdr_static_metadata.chromaticity_green_x / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_green_y / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_blue_x / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_blue_y / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_red_x / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_red_y / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_white_point_x / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.chromaticity_white_point_y / 2;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.max_luminance;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.min_luminance;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.maximum_content_light_level;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	data = stream->hdr_static_metadata.maximum_frame_average_light_level;
-	info_packet->sb[i++] = data & 0xFF;
-	info_packet->sb[i++] = (data & 0xFF00) >> 8;
-
-	if (dc_is_hdmi_signal(signal)) {
-		uint32_t checksum = 0;
-
-		checksum += info_packet->hb0;
-		checksum += info_packet->hb1;
-		checksum += info_packet->hb2;
-
-		for (i = 1; i <= info_packet->hb2; i++)
-			checksum += info_packet->sb[i];
-
-		info_packet->sb[0] = 0x100 - checksum;
-	} else if (dc_is_dp_signal(signal)) {
-		info_packet->sb[0] = 0x01;
-		info_packet->sb[1] = 0x1A;
-	}
+	*info_packet = stream->hdr_static_metadata;
 }
 
 static void set_vsc_info_packet(

commit dc002a2e4f6e164fd9e5c1353df795dc65784887
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Mar 26 12:33:22 2018 -0400

    drm/amd/display: Update scaler v_active data if interlaced
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Reviewed-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 50b84f69bd25..eb8f4792198c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -844,6 +844,9 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.format = convert_pixel_format_to_dalsurface(
 			pipe_ctx->plane_state->format);
 
+	if (pipe_ctx->stream->timing.flags.INTERLACE)
+		pipe_ctx->stream->dst.height *= 2;
+
 	calculate_scaling_ratios(pipe_ctx);
 
 	calculate_viewport(pipe_ctx);
@@ -864,6 +867,8 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable + timing->h_border_left + timing->h_border_right;
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
+	if (pipe_ctx->stream->timing.flags.INTERLACE)
+		pipe_ctx->plane_res.scl_data.v_active *= 2;
 
 
 	/* Taps calculations */
@@ -909,6 +914,9 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				plane_state->dst_rect.x,
 				plane_state->dst_rect.y);
 
+	if (pipe_ctx->stream->timing.flags.INTERLACE)
+		pipe_ctx->stream->dst.height /= 2;
+
 	return res;
 }
 

commit 5d4b05ddd826d877327ecabf987b7c61ec3cb0c5
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Mar 15 13:01:46 2018 -0400

    drm/amd/display: Add Dynamic debug prints
    
    Created Macros for DC_LOG_XXX to pr_debug() & DRM_DEBUG_KMS.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 379b05536321..50b84f69bd25 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -45,8 +45,9 @@
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dce120/dce120_resource.h"
-#define DC_LOGGER \
-	ctx->logger
+
+#define DC_LOGGER_INIT(logger)
+
 enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 {
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
@@ -835,7 +836,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
-	struct dc_context *ctx = pipe_ctx->stream->ctx;
+	DC_LOGGER_INIT(pipe_ctx->stream->ctx->logger);
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
 	 * Inits require viewport, taps, ratios and recout of split pipe

commit e09b6473c605119a5f7c451a93a9e812e216a824
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Mar 15 14:18:18 2018 -0400

    drm/amd/display: Rename encoder_info_packet to dc_info_packet
    
    Move this out of the HW includes to dc_types.h
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index cae78ee9a6fc..379b05536321 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1811,7 +1811,7 @@ enum dc_status dc_validate_global_state(
 }
 
 static void patch_gamut_packet_checksum(
-		struct encoder_info_packet *gamut_packet)
+		struct dc_info_packet *gamut_packet)
 {
 	/* For gamut we recalc checksum */
 	if (gamut_packet->valid) {
@@ -1830,12 +1830,11 @@ static void patch_gamut_packet_checksum(
 }
 
 static void set_avi_info_frame(
-		struct encoder_info_packet *info_packet,
+		struct dc_info_packet *info_packet,
 		struct pipe_ctx *pipe_ctx)
 {
 	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
-	struct info_frame info_frame = { {0} };
 	uint32_t pixel_encoding = 0;
 	enum scanning_type scan_type = SCANNING_TYPE_NODATA;
 	enum dc_aspect_ratio aspect = ASPECT_RATIO_NO_DATA;
@@ -1845,7 +1844,7 @@ static void set_avi_info_frame(
 	unsigned int cn0_cn1_value = 0;
 	uint8_t *check_sum = NULL;
 	uint8_t byte_index = 0;
-	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
+	union hdmi_info_packet hdmi_info = {0};
 	union display_content_support support = {0};
 	unsigned int vic = pipe_ctx->stream->timing.vic;
 	enum dc_timing_3d_format format;
@@ -1856,11 +1855,11 @@ static void set_avi_info_frame(
 			COLOR_SPACE_SRGB:COLOR_SPACE_YCBCR709;
 
 	/* Initialize header */
-	hdmi_info->bits.header.info_frame_type = HDMI_INFOFRAME_TYPE_AVI;
+	hdmi_info.bits.header.info_frame_type = HDMI_INFOFRAME_TYPE_AVI;
 	/* InfoFrameVersion_3 is defined by CEA861F (Section 6.4), but shall
 	* not be used in HDMI 2.0 (Section 10.1) */
-	hdmi_info->bits.header.version = 2;
-	hdmi_info->bits.header.length = HDMI_AVI_INFOFRAME_SIZE;
+	hdmi_info.bits.header.version = 2;
+	hdmi_info.bits.header.length = HDMI_AVI_INFOFRAME_SIZE;
 
 	/*
 	 * IDO-defined (Y2,Y1,Y0 = 1,1,1) shall not be used by devices built
@@ -1886,39 +1885,39 @@ static void set_avi_info_frame(
 
 	/* Y0_Y1_Y2 : The pixel encoding */
 	/* H14b AVI InfoFrame has extension on Y-field from 2 bits to 3 bits */
-	hdmi_info->bits.Y0_Y1_Y2 = pixel_encoding;
+	hdmi_info.bits.Y0_Y1_Y2 = pixel_encoding;
 
 	/* A0 = 1 Active Format Information valid */
-	hdmi_info->bits.A0 = ACTIVE_FORMAT_VALID;
+	hdmi_info.bits.A0 = ACTIVE_FORMAT_VALID;
 
 	/* B0, B1 = 3; Bar info data is valid */
-	hdmi_info->bits.B0_B1 = BAR_INFO_BOTH_VALID;
+	hdmi_info.bits.B0_B1 = BAR_INFO_BOTH_VALID;
 
-	hdmi_info->bits.SC0_SC1 = PICTURE_SCALING_UNIFORM;
+	hdmi_info.bits.SC0_SC1 = PICTURE_SCALING_UNIFORM;
 
 	/* S0, S1 : Underscan / Overscan */
 	/* TODO: un-hardcode scan type */
 	scan_type = SCANNING_TYPE_UNDERSCAN;
-	hdmi_info->bits.S0_S1 = scan_type;
+	hdmi_info.bits.S0_S1 = scan_type;
 
 	/* C0, C1 : Colorimetry */
 	if (color_space == COLOR_SPACE_YCBCR709 ||
 			color_space == COLOR_SPACE_YCBCR709_LIMITED)
-		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU709;
+		hdmi_info.bits.C0_C1 = COLORIMETRY_ITU709;
 	else if (color_space == COLOR_SPACE_YCBCR601 ||
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)
-		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU601;
+		hdmi_info.bits.C0_C1 = COLORIMETRY_ITU601;
 	else {
-		hdmi_info->bits.C0_C1 = COLORIMETRY_NO_DATA;
+		hdmi_info.bits.C0_C1 = COLORIMETRY_NO_DATA;
 	}
 	if (color_space == COLOR_SPACE_2020_RGB_FULLRANGE ||
 			color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE ||
 			color_space == COLOR_SPACE_2020_YCBCR) {
-		hdmi_info->bits.EC0_EC2 = COLORIMETRYEX_BT2020RGBYCBCR;
-		hdmi_info->bits.C0_C1   = COLORIMETRY_EXTENDED;
+		hdmi_info.bits.EC0_EC2 = COLORIMETRYEX_BT2020RGBYCBCR;
+		hdmi_info.bits.C0_C1   = COLORIMETRY_EXTENDED;
 	} else if (color_space == COLOR_SPACE_ADOBERGB) {
-		hdmi_info->bits.EC0_EC2 = COLORIMETRYEX_ADOBERGB;
-		hdmi_info->bits.C0_C1   = COLORIMETRY_EXTENDED;
+		hdmi_info.bits.EC0_EC2 = COLORIMETRYEX_ADOBERGB;
+		hdmi_info.bits.C0_C1   = COLORIMETRY_EXTENDED;
 	}
 
 	/* TODO: un-hardcode aspect ratio */
@@ -1927,18 +1926,18 @@ static void set_avi_info_frame(
 	switch (aspect) {
 	case ASPECT_RATIO_4_3:
 	case ASPECT_RATIO_16_9:
-		hdmi_info->bits.M0_M1 = aspect;
+		hdmi_info.bits.M0_M1 = aspect;
 		break;
 
 	case ASPECT_RATIO_NO_DATA:
 	case ASPECT_RATIO_64_27:
 	case ASPECT_RATIO_256_135:
 	default:
-		hdmi_info->bits.M0_M1 = 0;
+		hdmi_info.bits.M0_M1 = 0;
 	}
 
 	/* Active Format Aspect ratio - same as Picture Aspect Ratio. */
-	hdmi_info->bits.R0_R3 = ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;
+	hdmi_info.bits.R0_R3 = ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;
 
 	/* TODO: un-hardcode cn0_cn1 and itc */
 
@@ -1981,8 +1980,8 @@ static void set_avi_info_frame(
 				}
 			}
 		}
-		hdmi_info->bits.CN0_CN1 = cn0_cn1_value;
-		hdmi_info->bits.ITC = itc_value;
+		hdmi_info.bits.CN0_CN1 = cn0_cn1_value;
+		hdmi_info.bits.ITC = itc_value;
 	}
 
 	/* TODO : We should handle YCC quantization */
@@ -1991,19 +1990,19 @@ static void set_avi_info_frame(
 			stream->sink->edid_caps.qy_bit == 1) {
 		if (color_space == COLOR_SPACE_SRGB ||
 			color_space == COLOR_SPACE_2020_RGB_FULLRANGE) {
-			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
-			hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_FULL_RANGE;
+			hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
+			hdmi_info.bits.YQ0_YQ1 = YYC_QUANTIZATION_FULL_RANGE;
 		} else if (color_space == COLOR_SPACE_SRGB_LIMITED ||
 					color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE) {
-			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;
-			hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
+			hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;
+			hdmi_info.bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
 		} else {
-			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
-			hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
+			hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
+			hdmi_info.bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
 		}
 	} else {
-		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
-		hdmi_info->bits.YQ0_YQ1   = YYC_QUANTIZATION_LIMITED_RANGE;
+		hdmi_info.bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
+		hdmi_info.bits.YQ0_YQ1   = YYC_QUANTIZATION_LIMITED_RANGE;
 	}
 
 	///VIC
@@ -2028,51 +2027,49 @@ static void set_avi_info_frame(
 			break;
 		}
 	}
-	hdmi_info->bits.VIC0_VIC7 = vic;
+	hdmi_info.bits.VIC0_VIC7 = vic;
 
 	/* pixel repetition
 	 * PR0 - PR3 start from 0 whereas pHwPathMode->mode.timing.flags.pixel
 	 * repetition start from 1 */
-	hdmi_info->bits.PR0_PR3 = 0;
+	hdmi_info.bits.PR0_PR3 = 0;
 
 	/* Bar Info
 	 * barTop:    Line Number of End of Top Bar.
 	 * barBottom: Line Number of Start of Bottom Bar.
 	 * barLeft:   Pixel Number of End of Left Bar.
 	 * barRight:  Pixel Number of Start of Right Bar. */
-	hdmi_info->bits.bar_top = stream->timing.v_border_top;
-	hdmi_info->bits.bar_bottom = (stream->timing.v_total
+	hdmi_info.bits.bar_top = stream->timing.v_border_top;
+	hdmi_info.bits.bar_bottom = (stream->timing.v_total
 			- stream->timing.v_border_bottom + 1);
-	hdmi_info->bits.bar_left  = stream->timing.h_border_left;
-	hdmi_info->bits.bar_right = (stream->timing.h_total
+	hdmi_info.bits.bar_left  = stream->timing.h_border_left;
+	hdmi_info.bits.bar_right = (stream->timing.h_total
 			- stream->timing.h_border_right + 1);
 
 	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
-	check_sum = &info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
+	check_sum = &hdmi_info.packet_raw_data.sb[0];
 
 	*check_sum = HDMI_INFOFRAME_TYPE_AVI + HDMI_AVI_INFOFRAME_SIZE + 2;
 
 	for (byte_index = 1; byte_index <= HDMI_AVI_INFOFRAME_SIZE; byte_index++)
-		*check_sum += hdmi_info->packet_raw_data.sb[byte_index];
+		*check_sum += hdmi_info.packet_raw_data.sb[byte_index];
 
 	/* one byte complement */
 	*check_sum = (uint8_t) (0x100 - *check_sum);
 
 	/* Store in hw_path_mode */
-	info_packet->hb0 = hdmi_info->packet_raw_data.hb0;
-	info_packet->hb1 = hdmi_info->packet_raw_data.hb1;
-	info_packet->hb2 = hdmi_info->packet_raw_data.hb2;
+	info_packet->hb0 = hdmi_info.packet_raw_data.hb0;
+	info_packet->hb1 = hdmi_info.packet_raw_data.hb1;
+	info_packet->hb2 = hdmi_info.packet_raw_data.hb2;
 
-	for (byte_index = 0; byte_index < sizeof(info_frame.avi_info_packet.
-				info_packet_hdmi.packet_raw_data.sb); byte_index++)
-		info_packet->sb[byte_index] = info_frame.avi_info_packet.
-				info_packet_hdmi.packet_raw_data.sb[byte_index];
+	for (byte_index = 0; byte_index < sizeof(hdmi_info.packet_raw_data.sb); byte_index++)
+		info_packet->sb[byte_index] = hdmi_info.packet_raw_data.sb[byte_index];
 
 	info_packet->valid = true;
 }
 
 static void set_vendor_info_packet(
-		struct encoder_info_packet *info_packet,
+		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
 	uint32_t length = 0;
@@ -2185,7 +2182,7 @@ static void set_vendor_info_packet(
 }
 
 static void set_spd_info_packet(
-		struct encoder_info_packet *info_packet,
+		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
 	/* SPD info packet for FreeSync */
@@ -2306,7 +2303,7 @@ static void set_spd_info_packet(
 }
 
 static void set_hdr_static_info_packet(
-		struct encoder_info_packet *info_packet,
+		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
 	uint16_t i = 0;
@@ -2403,7 +2400,7 @@ static void set_hdr_static_info_packet(
 }
 
 static void set_vsc_info_packet(
-		struct encoder_info_packet *info_packet,
+		struct dc_info_packet *info_packet,
 		struct dc_stream_state *stream)
 {
 	unsigned int vscPacketRevision = 0;

commit 6133470c8e2ffdc6a5d67a1d79a9a0c1c0a94a10
Author: Julian Parkin <jparkin@amd.com>
Date:   Tue Mar 13 15:53:13 2018 -0400

    drm/amd/display: drop dc_validate_guaranteed
    
    Block FP16 scaling in validate_resources codepath.
    
    Signed-off-by: Julian Parkin <jparkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ba3487e97361..cae78ee9a6fc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1599,18 +1599,6 @@ enum dc_status dc_remove_stream_from_ctx(
 	return DC_OK;
 }
 
-static void copy_pipe_ctx(
-	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
-{
-	struct dc_plane_state *plane_state = to_pipe_ctx->plane_state;
-	struct dc_stream_state *stream = to_pipe_ctx->stream;
-
-	*to_pipe_ctx = *from_pipe_ctx;
-	to_pipe_ctx->stream = stream;
-	if (plane_state != NULL)
-		to_pipe_ctx->plane_state = plane_state;
-}
-
 static struct dc_stream_state *find_pll_sharable_stream(
 		struct dc_stream_state *stream_needs_pll,
 		struct dc_state *context)
@@ -1752,26 +1740,6 @@ enum dc_status resource_map_pool_resources(
 	return DC_ERROR_UNEXPECTED;
 }
 
-/* first stream in the context is used to populate the rest */
-void validate_guaranteed_copy_streams(
-		struct dc_state *context,
-		int max_streams)
-{
-	int i;
-
-	for (i = 1; i < max_streams; i++) {
-		context->streams[i] = context->streams[0];
-
-		copy_pipe_ctx(&context->res_ctx.pipe_ctx[0],
-			      &context->res_ctx.pipe_ctx[i]);
-		context->res_ctx.pipe_ctx[i].stream =
-				context->res_ctx.pipe_ctx[0].stream;
-
-		dc_stream_retain(context->streams[i]);
-		context->stream_count++;
-	}
-}
-
 void dc_resource_state_copy_construct_current(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)

commit 9aef1a31709076660f7d5f638ab5ecadea4ca856
Author: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
Date:   Fri Feb 23 13:04:13 2018 -0500

    drm/amd/display: Varibright fix bug and review comments
    
    Fix bug and make changes from review 132656
    
    Signed-off-by: SivapiriyanKumarasamy <sivapiriyan.kumarasamy@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index b9fc6d842931..ba3487e97361 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1124,6 +1124,7 @@ bool dc_add_plane_to_context(
 		ASSERT(tail_pipe);
 
 		free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
+		free_pipe->stream_res.abm = tail_pipe->stream_res.abm;
 		free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
 		free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
 		free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
@@ -1736,6 +1737,10 @@ enum dc_status resource_map_pool_resources(
 					   pipe_ctx->stream_res.audio, true);
 	}
 
+	/* Add ABM to the resource if on EDP */
+	if (pipe_ctx->stream && dc_is_embedded_signal(pipe_ctx->stream->signal))
+		pipe_ctx->stream_res.abm = pool->abm;
+
 	for (i = 0; i < context->stream_count; i++)
 		if (context->streams[i] == stream) {
 			context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;

commit 1296423bf23c7a58133970e223b1f47ec6570308
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 20 17:42:50 2018 -0500

    drm/amd/display: define DC_LOGGER for logger
    
    Created a DC_LOGGER define. This is used to
    pass the logger into the macros.
    
    Anywhere we need to use the logger we need to define
    DC_LOGGER
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 52b0a4ae2f9a..b9fc6d842931 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -45,7 +45,8 @@
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dce120/dce120_resource.h"
-
+#define DC_LOGGER \
+	ctx->logger
 enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 {
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
@@ -834,7 +835,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
-
+	struct dc_context *ctx = pipe_ctx->stream->ctx;
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
 	 * Inits require viewport, taps, ratios and recout of split pipe
@@ -893,7 +894,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 		/* May need to re-check lb size after this in some obscure scenario */
 		calculate_inits_and_adj_vp(pipe_ctx, &recout_skip);
 
-	DC_LOG_SCALER(pipe_ctx->stream->ctx->logger,
+	DC_LOG_SCALER(
 				"%s: Viewport:\nheight:%d width:%d x:%d "
 				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
 				"y:%d\n",

commit 2f3fd67a8af25f5b4d549c3e9cc515dbf1839ffc
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Feb 16 13:57:42 2018 -0500

    drm/amd/display: Use MACROS instead of dm_logger
    
    Created MACROS for all log levels. Also Replaced
    usage of dm_logger_write to the defined MACROS
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 48709d4b5627..52b0a4ae2f9a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -893,7 +893,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 		/* May need to re-check lb size after this in some obscure scenario */
 		calculate_inits_and_adj_vp(pipe_ctx, &recout_skip);
 
-	dm_logger_write(pipe_ctx->stream->ctx->logger, LOG_SCALER,
+	DC_LOG_SCALER(pipe_ctx->stream->ctx->logger,
 				"%s: Viewport:\nheight:%d width:%d x:%d "
 				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
 				"y:%d\n",

commit 85075fa04287dce81397dab75af0992274727b82
Author: Xingyue Tao <xingyue.tao@amd.com>
Date:   Fri Feb 16 16:29:13 2018 -0500

    drm/amd/display: add psr_version to stream
    
    Brightness could not be changed for some panels whose DPCD_version is below 1.2
    Now psr_version is added into stream, and it copies from the displayTarget's psr_version.
    It checks if the stream's psr_versio is non-zero and sets the vsc info packet revision now.
    
    Signed-off-by: Xingyue Tao <xingyue.tao@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ce0e9e76eb35..48709d4b5627 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2436,7 +2436,7 @@ static void set_vsc_info_packet(
 	unsigned int i;
 
 	/*VSC packet set to 2 when DP revision >= 1.2*/
-	if (stream->sink->link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {
+	if (stream->psr_version != 0) {
 		vscPacketRevision = 2;
 	}
 

commit 3b94a4007dcfd4ac5780cd3d8a2d99979c966073
Author: Tao <xtao@amd.com>
Date:   Thu Feb 8 16:04:25 2018 -0500

    drm/amd/display: Set vsc pack revision when DPCD revision is >= 1.2
    
    Brightness couldn't change when booting up in DC mode.
    It was because "psr_enabled" flag was not set to true before
    setting vsc packet revision, causing packet rev setup was skipped.
    Now instead of checking the psr flag, it checks if the DPCD_REV >= 1.2
    and set the vsc packet revision.
    
    Signed-off-by: Tao <xtao@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a6f8c1f93693..ce0e9e76eb35 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -35,6 +35,7 @@
 #include "core_types.h"
 #include "set_mode_types.h"
 #include "virtual/virtual_stream_encoder.h"
+#include "dpcd_defs.h"
 
 #include "dce80/dce80_resource.h"
 #include "dce100/dce100_resource.h"
@@ -2434,7 +2435,8 @@ static void set_vsc_info_packet(
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
 
-	if (stream->sink->link->psr_enabled) {
+	/*VSC packet set to 2 when DP revision >= 1.2*/
+	if (stream->sink->link->dpcd_caps.dpcd_rev.raw >= DPCD_REV_12) {
 		vscPacketRevision = 2;
 	}
 

commit 4ee778dcc16b0ebbd4370a6de79c10bd88c89328
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Jan 29 16:34:16 2018 -0500

    drm/amd/display: disable seamless vp adjustment for mirrored surface
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a215c5b74cbd..a6f8c1f93693 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -696,7 +696,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 
 	/* Adjust for viewport end clip-off */
-	if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
+	if ((data->viewport.x + data->viewport.width) < (src.x + src.width) && !flip_horz_scan_dir) {
 		int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
 		int int_part = dal_fixed31_32_floor(
 				dal_fixed31_32_sub(data->inits.h, data->ratios.horz));
@@ -704,7 +704,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
 	}
-	if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
+	if ((data->viewport.y + data->viewport.height) < (src.y + src.height) && !flip_vert_scan_dir) {
 		int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
 		int int_part = dal_fixed31_32_floor(
 				dal_fixed31_32_sub(data->inits.v, data->ratios.vert));
@@ -712,7 +712,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
 	}
-	if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
+	if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div && !flip_horz_scan_dir) {
 		int vp_clip = (src.x + src.width) / vpc_div -
 				data->viewport_c.width - data->viewport_c.x;
 		int int_part = dal_fixed31_32_floor(
@@ -721,7 +721,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		int_part = int_part > 0 ? int_part : 0;
 		data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
 	}
-	if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
+	if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div && !flip_vert_scan_dir) {
 		int vp_clip = (src.y + src.height) / vpc_div -
 				data->viewport_c.height - data->viewport_c.y;
 		int int_part = dal_fixed31_32_floor(

commit bc373a890f14958c98e476e38b0a71adab3fc733
Author: Roman Li <Roman.Li@amd.com>
Date:   Fri Dec 29 17:45:03 2017 -0500

    drm/amd/display: Fix null-derefs on non-dcn builds
    
    Fixing regression introduced by
    'Use real BE and FE index to program regs.'
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ba88284d305a..a215c5b74cbd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1407,7 +1407,8 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
-			pipe_ctx->plane_res.mpcc_inst = pool->dpps[i]->inst;
+			if (pool->dpps[i])
+				pipe_ctx->plane_res.mpcc_inst = pool->dpps[i]->inst;
 			pipe_ctx->pipe_idx = i;
 
 

commit e56ae556e16265de6cc237d14a9a1518dbbcb807
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Dec 14 17:57:56 2017 -0500

    drm/amd/display: Define remove_stream_from_ctx resource func
    
    This will allow us to clean up resources on a stream as needed.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 36d54ef5cae2..ba88284d305a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1554,6 +1554,9 @@ enum dc_status dc_remove_stream_from_ctx(
 							  dc->res_pool,
 							  del_pipe->clock_source);
 
+			if (dc->res_pool->funcs->remove_stream_from_ctx)
+				dc->res_pool->funcs->remove_stream_from_ctx(dc, new_ctx, stream);
+
 			memset(del_pipe, 0, sizeof(*del_pipe));
 
 			break;

commit e07f541f50a31541f761300aa8bf6e3008ac448b
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Dec 19 16:47:02 2017 -0500

    drm/amd/display: Use real BE and FE index to program regs.
    
    In case of some pipes are fused, pipe_idx should not
    be used to program pipe regs. Instead of that, BE and FE
    inst number should be used for reg index.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4d07ffebfd31..36d54ef5cae2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1054,6 +1054,7 @@ static int acquire_first_split_pipe(
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
+			pipe_ctx->plane_res.mpcc_inst = pool->dpps[i]->inst;
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -1406,6 +1407,7 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
+			pipe_ctx->plane_res.mpcc_inst = pool->dpps[i]->inst;
 			pipe_ctx->pipe_idx = i;
 
 

commit eb6c24a3e6c677cb5c2cde8340a910a39d765a8d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Dec 4 20:58:16 2017 -0500

    drm/amd/display: Move MAX_TMDS_CLOCK define to header
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 95b8dd0e53c6..4d07ffebfd31 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1360,9 +1360,6 @@ bool dc_is_stream_scaling_unchanged(
 	return true;
 }
 
-/* Maximum TMDS single link pixel clock 165MHz */
-#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
-
 static void update_stream_engine_usage(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,

commit 737ae4ea82180158571bd2d171fe5007dd7b74ee
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Dec 7 15:48:15 2017 -0500

    drm/amd/display: fix 180 full screen pipe split
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index bc1b5f42a0a4..95b8dd0e53c6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -669,12 +669,6 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	if (pipe_ctx->plane_state->horizontal_mirror)
 		flip_horz_scan_dir = !flip_horz_scan_dir;
 
-	/* Temp W/A for rotated displays, ignore recout_skip */
-	if (flip_vert_scan_dir)
-		recout_skip->height = 0;
-	if (flip_horz_scan_dir)
-		recout_skip->width = 0;
-
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
@@ -738,7 +732,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	}
 
 	/* Adjust for non-0 viewport offset */
-	if (data->viewport.x) {
+	if (data->viewport.x && !flip_horz_scan_dir) {
 		int int_part;
 
 		data->inits.h = dal_fixed31_32_add(data->inits.h, dal_fixed31_32_mul_int(
@@ -759,7 +753,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		data->inits.h = dal_fixed31_32_add_int(data->inits.h, int_part);
 	}
 
-	if (data->viewport_c.x) {
+	if (data->viewport_c.x && !flip_horz_scan_dir) {
 		int int_part;
 
 		data->inits.h_c = dal_fixed31_32_add(data->inits.h_c, dal_fixed31_32_mul_int(
@@ -780,7 +774,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		data->inits.h_c = dal_fixed31_32_add_int(data->inits.h_c, int_part);
 	}
 
-	if (data->viewport.y) {
+	if (data->viewport.y && !flip_vert_scan_dir) {
 		int int_part;
 
 		data->inits.v = dal_fixed31_32_add(data->inits.v, dal_fixed31_32_mul_int(
@@ -801,7 +795,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 		data->inits.v = dal_fixed31_32_add_int(data->inits.v, int_part);
 	}
 
-	if (data->viewport_c.y) {
+	if (data->viewport_c.y && !flip_vert_scan_dir) {
 		int int_part;
 
 		data->inits.v_c = dal_fixed31_32_add(data->inits.v_c, dal_fixed31_32_mul_int(

commit b01313918202ebb1385d06d2bd27136a7a561e94
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 29 17:42:08 2017 -0500

    drm/amd/display: fix rotated surface scaling
    
    This is a resubmit with the errors fixed
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ae9312df0a1c..bc1b5f42a0a4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -527,12 +527,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
-
-	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
-		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
-		pri_split = false;
-		sec_split = false;
-	}
+	bool top_bottom_split = stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM;
 
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
@@ -567,17 +562,15 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 						- pipe_ctx->plane_res.scl_data.recout.y;
 
 	/* Handle h & vsplit */
-	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
-			pipe_ctx->plane_state && stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
-		pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height / 2;
+	if (sec_split && top_bottom_split) {
+		pipe_ctx->plane_res.scl_data.recout.y +=
+				pipe_ctx->plane_res.scl_data.recout.height / 2;
 		/* Floor primary pipe, ceil 2ndary pipe */
-		pipe_ctx->plane_res.scl_data.recout.height = (pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
-	} else if (pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state
-			&& stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
+		pipe_ctx->plane_res.scl_data.recout.height =
+				(pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
+	} else if (pri_split && top_bottom_split)
 		pipe_ctx->plane_res.scl_data.recout.height /= 2;
-
-	if (pri_split || sec_split) {
+	else if (pri_split || sec_split) {
 		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
 		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
 					(plane_state->rotation == ROTATION_ANGLE_180);
@@ -601,32 +594,17 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
-	recout_full_x = stream->dst.x + (plane_state->dst_rect.x -  stream->src.x)
+	recout_full_x = stream->dst.x + (plane_state->dst_rect.x - stream->src.x)
 					* stream->dst.width / stream->src.width -
 			surf_src.x * plane_state->dst_rect.width / surf_src.width
 					* stream->dst.width / stream->src.width;
-	recout_full_y = stream->dst.y + (plane_state->dst_rect.y -  stream->src.y)
+	recout_full_y = stream->dst.y + (plane_state->dst_rect.y - stream->src.y)
 					* stream->dst.height / stream->src.height -
 			surf_src.y * plane_state->dst_rect.height / surf_src.height
 					* stream->dst.height / stream->src.height;
 
 	recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x - recout_full_x;
 	recout_skip->height = pipe_ctx->plane_res.scl_data.recout.y - recout_full_y;
-
-	/*Adjust recout_skip for rotation */
-	if ((pri_split || sec_split) && (plane_state->rotation == ROTATION_ANGLE_270 || plane_state->rotation == ROTATION_ANGLE_180)) {
-		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
-					(plane_state->rotation == ROTATION_ANGLE_180);
-
-		if (plane_state->rotation == ROTATION_ANGLE_90
-				|| plane_state->rotation == ROTATION_ANGLE_270)
-			/* Secondary_pipe XOR Rotation_270 */
-			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
-		if (!right_view)
-			recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x + pipe_ctx->plane_res.scl_data.recout.width / 2 - recout_full_x;
-		else
-			recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x - pipe_ctx->plane_res.scl_data.recout.width / 2 - recout_full_x;
-	}
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
@@ -676,7 +654,26 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	struct rect src = pipe_ctx->plane_state->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
+	bool flip_vert_scan_dir = false, flip_horz_scan_dir = false;
 
+	/*
+	 * Need to calculate the scan direction for viewport to make adjustments
+	 */
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_180) {
+		flip_vert_scan_dir = true;
+		flip_horz_scan_dir = true;
+	} else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90)
+		flip_vert_scan_dir = true;
+	else if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
+		flip_horz_scan_dir = true;
+	if (pipe_ctx->plane_state->horizontal_mirror)
+		flip_horz_scan_dir = !flip_horz_scan_dir;
+
+	/* Temp W/A for rotated displays, ignore recout_skip */
+	if (flip_vert_scan_dir)
+		recout_skip->height = 0;
+	if (flip_horz_scan_dir)
+		recout_skip->width = 0;
 
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {

commit 0c31a8218b80da4220757a0eff2d4f7c1229842d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Nov 21 13:45:51 2017 -0500

    drm/amd/display: fix recout_skip calculation when rotating 180 or 270
    
    Fixed fliped landscape and fliped portrait hard hang.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ad28eba017f2..ae9312df0a1c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -498,26 +498,15 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
 
 	/* Handle hsplit */
-	if (pri_split || sec_split) {
-		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
-		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
-					(plane_state->rotation == ROTATION_ANGLE_180);
-
-		if (plane_state->rotation == ROTATION_ANGLE_90
-				|| plane_state->rotation == ROTATION_ANGLE_270)
-			/* Secondary_pipe XOR Rotation_270 */
-			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
-
-		if (right_view) {
-			data->viewport.x +=  data->viewport.width / 2;
-			data->viewport_c.x +=  data->viewport_c.width / 2;
-			/* Ceil offset pipe */
-			data->viewport.width = (data->viewport.width + 1) / 2;
-			data->viewport_c.width = (data->viewport_c.width + 1) / 2;
-		} else {
-			data->viewport.width /= 2;
-			data->viewport_c.width /= 2;
-		}
+	if (sec_split) {
+		data->viewport.x +=  data->viewport.width / 2;
+		data->viewport_c.x +=  data->viewport_c.width / 2;
+		/* Ceil offset pipe */
+		data->viewport.width = (data->viewport.width + 1) / 2;
+		data->viewport_c.width = (data->viewport_c.width + 1) / 2;
+	} else if (pri_split) {
+		data->viewport.width /= 2;
+		data->viewport_c.width /= 2;
 	}
 
 	if (plane_state->rotation == ROTATION_ANGLE_90 ||
@@ -534,6 +523,16 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	struct rect surf_src = plane_state->src_rect;
 	struct rect surf_clip = plane_state->clip_rect;
 	int recout_full_x, recout_full_y;
+	bool pri_split = pipe_ctx->bottom_pipe &&
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
+	bool sec_split = pipe_ctx->top_pipe &&
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
+
+	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
+		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
+		pri_split = false;
+		sec_split = false;
+	}
 
 	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
@@ -569,23 +568,35 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 	/* Handle h & vsplit */
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
-		pipe_ctx->plane_state) {
-		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
-			pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height / 2;
-			/* Floor primary pipe, ceil 2ndary pipe */
-			pipe_ctx->plane_res.scl_data.recout.height = (pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
-		} else {
-			pipe_ctx->plane_res.scl_data.recout.x += pipe_ctx->plane_res.scl_data.recout.width / 2;
-			pipe_ctx->plane_res.scl_data.recout.width = (pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
-		}
+			pipe_ctx->plane_state && stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
+		pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height / 2;
+		/* Floor primary pipe, ceil 2ndary pipe */
+		pipe_ctx->plane_res.scl_data.recout.height = (pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
 	} else if (pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {
-		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
-			pipe_ctx->plane_res.scl_data.recout.height /= 2;
-		else
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state
+			&& stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
+		pipe_ctx->plane_res.scl_data.recout.height /= 2;
+
+	if (pri_split || sec_split) {
+		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
+		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
+					(plane_state->rotation == ROTATION_ANGLE_180);
+
+		if (plane_state->rotation == ROTATION_ANGLE_90
+				|| plane_state->rotation == ROTATION_ANGLE_270)
+			/* Secondary_pipe XOR Rotation_270 */
+			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
+
+		if (right_view) {
+			pipe_ctx->plane_res.scl_data.recout.x +=
+					pipe_ctx->plane_res.scl_data.recout.width / 2;
+			/* Ceil offset pipe */
+			pipe_ctx->plane_res.scl_data.recout.width =
+					(pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
+		} else {
 			pipe_ctx->plane_res.scl_data.recout.width /= 2;
+		}
 	}
-
 	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream surf_src offset)
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
@@ -601,6 +612,21 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 	recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x - recout_full_x;
 	recout_skip->height = pipe_ctx->plane_res.scl_data.recout.y - recout_full_y;
+
+	/*Adjust recout_skip for rotation */
+	if ((pri_split || sec_split) && (plane_state->rotation == ROTATION_ANGLE_270 || plane_state->rotation == ROTATION_ANGLE_180)) {
+		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
+					(plane_state->rotation == ROTATION_ANGLE_180);
+
+		if (plane_state->rotation == ROTATION_ANGLE_90
+				|| plane_state->rotation == ROTATION_ANGLE_270)
+			/* Secondary_pipe XOR Rotation_270 */
+			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
+		if (!right_view)
+			recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x + pipe_ctx->plane_res.scl_data.recout.width / 2 - recout_full_x;
+		else
+			recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x - pipe_ctx->plane_res.scl_data.recout.width / 2 - recout_full_x;
+	}
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)

commit 9ce6aae12c66adf87b5861f8fa5705ea11d0b6ee
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Nov 30 21:29:47 2017 -0500

    drm/amdgpu: add license to files where it was missing
    
    These files were missing it before.
    
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9c5e879f18b3..ad28eba017f2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1,5 +1,5 @@
 /*
-* Copyright 2012-15 Advanced Micro Devices, Inc.
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),

commit 99676f20dc913672166ab3b22fe29c20a2c27a82
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Fri Nov 10 16:38:13 2017 -0600

    drm/amd/display/dc/core/dc_resource: use swap macro in rect_swap_helper
    
    Make use of the swap macro instead of _manually_ swapping values
    and remove unnecessary variable temp.
    
    This makes the code easier to read and maintain.
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 15e518aba916..9c5e879f18b3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -426,15 +426,8 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 
 static void rect_swap_helper(struct rect *rect)
 {
-	uint32_t temp = 0;
-
-	temp = rect->height;
-	rect->height = rect->width;
-	rect->width = temp;
-
-	temp = rect->x;
-	rect->x = rect->y;
-	rect->y = temp;
+	swap(rect->height, rect->width);
+	swap(rect->x, rect->y);
 }
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)

commit 56ef6ed9faf35b9057630dd12aeca134f98214ec
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Oct 23 17:02:02 2017 -0400

    drm/amd/display: Move hdr_metadata from plane to stream
    
    Need to move HDR Metadata from Surface to Stream since there is only one
    infoframe possible per stream.
    
    Also cleaning up some duplicate definitions.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index b7422d3b71ef..15e518aba916 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2319,20 +2319,13 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_plane_state *plane_state,
 		struct dc_stream_state *stream)
 {
 	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
-	struct dc_hdr_static_metadata hdr_metadata;
 	uint32_t data;
 
-	if (!plane_state)
-		return;
-
-	hdr_metadata = plane_state->hdr_static_ctx;
-
-	if (!hdr_metadata.hdr_supported)
+	if (!stream->hdr_static_metadata.hdr_supported)
 		return;
 
 	if (dc_is_hdmi_signal(signal)) {
@@ -2352,55 +2345,55 @@ static void set_hdr_static_info_packet(
 		i = 2;
 	}
 
-	data = hdr_metadata.is_hdr;
+	data = stream->hdr_static_metadata.is_hdr;
 	info_packet->sb[i++] = data ? 0x02 : 0x00;
 	info_packet->sb[i++] = 0x00;
 
-	data = hdr_metadata.chromaticity_green_x / 2;
+	data = stream->hdr_static_metadata.chromaticity_green_x / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_green_y / 2;
+	data = stream->hdr_static_metadata.chromaticity_green_y / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_blue_x / 2;
+	data = stream->hdr_static_metadata.chromaticity_blue_x / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_blue_y / 2;
+	data = stream->hdr_static_metadata.chromaticity_blue_y / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_red_x / 2;
+	data = stream->hdr_static_metadata.chromaticity_red_x / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_red_y / 2;
+	data = stream->hdr_static_metadata.chromaticity_red_y / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_white_point_x / 2;
+	data = stream->hdr_static_metadata.chromaticity_white_point_x / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.chromaticity_white_point_y / 2;
+	data = stream->hdr_static_metadata.chromaticity_white_point_y / 2;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.max_luminance;
+	data = stream->hdr_static_metadata.max_luminance;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.min_luminance;
+	data = stream->hdr_static_metadata.min_luminance;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.maximum_content_light_level;
+	data = stream->hdr_static_metadata.maximum_content_light_level;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
-	data = hdr_metadata.maximum_frame_average_light_level;
+	data = stream->hdr_static_metadata.maximum_frame_average_light_level;
 	info_packet->sb[i++] = data & 0xFF;
 	info_packet->sb[i++] = (data & 0xFF00) >> 8;
 
@@ -2551,16 +2544,14 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
-		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->plane_state, pipe_ctx->stream);
+		set_hdr_static_info_packet(&info->hdrsmd, pipe_ctx->stream);
 
 	} else if (dc_is_dp_signal(signal)) {
 		set_vsc_info_packet(&info->vsc, pipe_ctx->stream);
 
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
-		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->plane_state, pipe_ctx->stream);
+		set_hdr_static_info_packet(&info->hdrsmd, pipe_ctx->stream);
 	}
 
 	patch_gamut_packet_checksum(&info->gamut);

commit e41ab0309a1b75d31c360d1d2b0de58e8d7958ad
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Nov 10 20:35:27 2017 -0500

    drm/amd/display: Fix couple more inconsistent NULL checks in dc_resource
    
    Found by smatch:
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:1001
    acquire_free_pipe_for_stream() error: we previously assumed 'head_pipe'
    could be null (see line 998)
    drivers/gpu/drm/amd/amdgpu/../display/dc/core/dc_resource.c:1808
    dc_validate_global_state() error: we previously assumed 'new_ctx' could
    be null (see line 1778)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 546fe99d34f2..b7422d3b71ef 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -993,8 +993,10 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
 
-	if (!head_pipe)
+	if (!head_pipe) {
 		ASSERT(0);
+		return NULL;
+	}
 
 	if (!head_pipe->plane_state)
 		return head_pipe;
@@ -1772,13 +1774,16 @@ enum dc_status dc_validate_global_state(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	int i, j;
 
+	if (!new_ctx)
+		return DC_ERROR_UNEXPECTED;
+
 	if (dc->res_pool->funcs->validate_global) {
 			result = dc->res_pool->funcs->validate_global(dc, new_ctx);
 			if (result != DC_OK)
 				return result;
 	}
 
-	for (i = 0; new_ctx && i < new_ctx->stream_count; i++) {
+	for (i = 0; i < new_ctx->stream_count; i++) {
 		struct dc_stream_state *stream = new_ctx->streams[i];
 
 		for (j = 0; j < dc->res_pool->pipe_count; j++) {

commit cfb071f7a9673109415d097125b3c12c16836acc
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Nov 15 18:55:57 2017 -0500

    drm/amd/display: try to find matching audio inst for enc inst first
    
    [Description]
    in eDP+ HDMI/DP clone or extended configuration, audio inst changed from inst 1 to inst0.
    No failure related this though, just playback device endpoint inst changed.
    Also  remove one addition register read.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 655e08df48a0..546fe99d34f2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1449,11 +1449,16 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 
 static struct audio *find_first_free_audio(
 		struct resource_context *res_ctx,
-		const struct resource_pool *pool)
+		const struct resource_pool *pool,
+		enum engine_id id)
 {
 	int i;
 	for (i = 0; i < pool->audio_count; i++) {
 		if ((res_ctx->is_audio_acquired[i] == false) && (res_ctx->is_stream_enc_acquired[i] == true)) {
+			/*we have enough audio endpoint, find the matching inst*/
+			if (id != i)
+				continue;
+
 			return pool->audios[i];
 		}
 	}
@@ -1702,7 +1707,7 @@ enum dc_status resource_map_pool_resources(
 	    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 	    stream->audio_info.mode_count) {
 		pipe_ctx->stream_res.audio = find_first_free_audio(
-		&context->res_ctx, pool);
+		&context->res_ctx, pool, pipe_ctx->stream_res.stream_enc->id);
 
 		/*
 		 * Audio assigned in order first come first get.

commit 16fb754a294d25f4077e1f475d930c22698f442a
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Nov 10 13:53:53 2017 -0500

    drm/amd/display: fix split viewport rounding error
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1cd15d1cc3f4..655e08df48a0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -516,13 +516,11 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
 
 		if (right_view) {
-			data->viewport.width /= 2;
-			data->viewport_c.width /= 2;
-			data->viewport.x +=  data->viewport.width;
-			data->viewport_c.x +=  data->viewport_c.width;
+			data->viewport.x +=  data->viewport.width / 2;
+			data->viewport_c.x +=  data->viewport_c.width / 2;
 			/* Ceil offset pipe */
-			data->viewport.width += data->viewport.width % 2;
-			data->viewport_c.width += data->viewport_c.width % 2;
+			data->viewport.width = (data->viewport.width + 1) / 2;
+			data->viewport_c.width = (data->viewport_c.width + 1) / 2;
 		} else {
 			data->viewport.width /= 2;
 			data->viewport_c.width /= 2;

commit 116b2632ab033b2a755c1c7b703fede6860b3140
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Oct 24 17:57:38 2017 -0400

    drm/amd/display: fix split recout offset
    
    Previous recout calculation fix changed recout size rounding
    and affected the offset when it should not have
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ced339a145c6..1cd15d1cc3f4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -580,12 +580,12 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
 		pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
+			pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height / 2;
 			/* Floor primary pipe, ceil 2ndary pipe */
 			pipe_ctx->plane_res.scl_data.recout.height = (pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
-			pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height;
 		} else {
+			pipe_ctx->plane_res.scl_data.recout.x += pipe_ctx->plane_res.scl_data.recout.width / 2;
 			pipe_ctx->plane_res.scl_data.recout.width = (pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
-			pipe_ctx->plane_res.scl_data.recout.x += pipe_ctx->plane_res.scl_data.recout.width;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {

commit 4ddd76d1ce00bb0d78e73e29fd9062ecd6bad611
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Oct 23 15:37:37 2017 -0400

    drm/amd/display: fix split recout calculation
    
    Recout split rounding code was wrong
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a2f9be3716cf..ced339a145c6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -580,14 +580,12 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
 		pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
-			pipe_ctx->plane_res.scl_data.recout.height /= 2;
-			pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height;
 			/* Floor primary pipe, ceil 2ndary pipe */
-			pipe_ctx->plane_res.scl_data.recout.height += pipe_ctx->plane_res.scl_data.recout.height % 2;
+			pipe_ctx->plane_res.scl_data.recout.height = (pipe_ctx->plane_res.scl_data.recout.height + 1) / 2;
+			pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height;
 		} else {
-			pipe_ctx->plane_res.scl_data.recout.width /= 2;
+			pipe_ctx->plane_res.scl_data.recout.width = (pipe_ctx->plane_res.scl_data.recout.width + 1) / 2;
 			pipe_ctx->plane_res.scl_data.recout.x += pipe_ctx->plane_res.scl_data.recout.width;
-			pipe_ctx->plane_res.scl_data.recout.width += pipe_ctx->plane_res.scl_data.recout.width % 2;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {

commit 1b6c80674192bd6b235de7bc58f0bd03eb7f89df
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Oct 13 12:13:02 2017 -0400

    drm/amd/display: Add null check for 24BPP (xfm and dpp)
    
    Fixes Nullptr error when trying 24BPP
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d1cdf9f8853d..a2f9be3716cf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -856,6 +856,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable + timing->h_border_left + timing->h_border_right;
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
 
+
 	/* Taps calculations */
 	if (pipe_ctx->plane_res.xfm != NULL)
 		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
@@ -864,16 +865,21 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	if (pipe_ctx->plane_res.dpp != NULL)
 		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
 				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
-
 	if (!res) {
 		/* Try 24 bpp linebuffer */
 		pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
 
-		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
-			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
-
-		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
-			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+		if (pipe_ctx->plane_res.xfm != NULL)
+			res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
+					pipe_ctx->plane_res.xfm,
+					&pipe_ctx->plane_res.scl_data,
+					&plane_state->scaling_quality);
+
+		if (pipe_ctx->plane_res.dpp != NULL)
+			res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
+					pipe_ctx->plane_res.dpp,
+					&pipe_ctx->plane_res.scl_data,
+					&plane_state->scaling_quality);
 	}
 
 	if (res)

commit 62c933f9c6bf287b5b911a1eb838bc942eaa7202
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Oct 10 14:01:33 2017 -0400

    drm/amd/display: WA for 3 display play video hot plug.
    
            Three monitor connected and playing a video will
            occupy all 4 pipes, if hot plug forth display,
            commit streams will be failed due to no free pipe
            can be found.
            Work around:
            When forth monitor connected, mark video plane as
            a fake plane, remove it in dc, keep it in dm and
            report address to OS, until OS turn off MPO.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0aca7a3d3dd6..d1cdf9f8853d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1503,7 +1503,7 @@ enum dc_status dc_add_stream_to_ctx(
 	return res;
 }
 
-bool dc_remove_stream_from_ctx(
+enum dc_status dc_remove_stream_from_ctx(
 			struct dc *dc,
 			struct dc_state *new_ctx,
 			struct dc_stream_state *stream)
@@ -2756,7 +2756,7 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
+enum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 {
 	struct dc  *core_dc = dc;
 	struct dc_link *link = stream->sink->link;
@@ -2780,14 +2780,16 @@ bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 		      link,
 		      &stream->timing);
 
-	return res == DC_OK;
+	return res;
 }
 
-bool dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state)
+enum dc_status dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state)
 {
+	enum dc_status res = DC_OK;
+
 	/* TODO For now validates pixel format only */
 	if (dc->res_pool->funcs->validate_plane)
-		return dc->res_pool->funcs->validate_plane(plane_state, &dc->caps) == DC_OK;
+		return dc->res_pool->funcs->validate_plane(plane_state, &dc->caps);
 
-	return true;
+	return res;
 }

commit 58bb0e63dd99c4bdb84e79a95311bb6899789681
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Tue Oct 10 14:36:39 2017 -0400

    drm/amd/display: Correct timings in build scaling params
    
    A previous patch set the addressable timing as active + border,
    when in fact, the VESA standard specifies active as equal to
    addressable + border.
    
    This patch makes the fix more correct and in line with the standard.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 55feb16b1fd7..0aca7a3d3dd6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -850,22 +850,11 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 */
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 
-	/**
-	 * KMD sends us h and v_addressable without the borders, which causes us sometimes to draw
-	 * the blank region on-screen. Correct for this by adding the borders back to their
-	 * respective addressable values, and by shifting recout.
-	 */
-	timing->h_addressable += timing->h_border_left + timing->h_border_right;
-	timing->v_addressable += timing->v_border_top + timing->v_border_bottom;
-	pipe_ctx->plane_res.scl_data.recout.y += timing->v_border_top;
 	pipe_ctx->plane_res.scl_data.recout.x += timing->h_border_left;
-	timing->v_border_top = 0;
-	timing->v_border_bottom = 0;
-	timing->h_border_left = 0;
-	timing->h_border_right = 0;
+	pipe_ctx->plane_res.scl_data.recout.y += timing->v_border_top;
 
-	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable;
-	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable;
+	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable + timing->h_border_left + timing->h_border_right;
+	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
 
 	/* Taps calculations */
 	if (pipe_ctx->plane_res.xfm != NULL)

commit 94c6d735e9ca13018da40f633fd602af6e272cc6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Oct 13 12:42:01 2017 -0400

    drm/amd/display: Fix non-DCN build
    
    Acquire_first_split_pipe only makes sense for DCN.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2a5c91772473..55feb16b1fd7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1684,8 +1684,10 @@ enum dc_status resource_map_pool_resources(
 	/* acquire new resources */
 	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
+#ifdef CONFIG_DRM_AMD_DC_DCN1_0
 	if (pipe_idx < 0)
 		pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+#endif
 
 	if (pipe_idx < 0)
 		return DC_NO_CONTROLLER_RESOURCE;

commit 9a5d9c48d883db4f7f3e5409062bef7d25165a95
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Fri Oct 6 11:57:40 2017 -0400

    drm/amd/display: Report stream as different on scaling change
    
    When scaling is enabled, our preference is to scale up to the prefered
    (native) mode. This means that hardware timings will be the same across
    a modeset.
    
    Therefore, also report mode as changed if source or destination
    rectangle is different.
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 454a521a268d..2a5c91772473 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1335,6 +1335,28 @@ bool dc_is_stream_unchanged(
 	return true;
 }
 
+bool dc_is_stream_scaling_unchanged(
+	struct dc_stream_state *old_stream, struct dc_stream_state *stream)
+{
+	if (old_stream == stream)
+		return true;
+
+	if (old_stream == NULL || stream == NULL)
+		return false;
+
+	if (memcmp(&old_stream->src,
+			&stream->src,
+			sizeof(struct rect)) != 0)
+		return false;
+
+	if (memcmp(&old_stream->dst,
+			&stream->dst,
+			sizeof(struct rect)) != 0)
+		return false;
+
+	return true;
+}
+
 /* Maximum TMDS single link pixel clock 165MHz */
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
 

commit 199e458aafc241a2792b3f8a99d5a11aa7726a7d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Oct 5 19:15:25 2017 -0400

    drm/amd/display: Set addressable region as active + border
    
    This ensures that we do not draw the blank region onscreen, and that we
    do underscan instead.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 303d7ec684d9..454a521a268d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -850,6 +850,20 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 */
 	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 
+	/**
+	 * KMD sends us h and v_addressable without the borders, which causes us sometimes to draw
+	 * the blank region on-screen. Correct for this by adding the borders back to their
+	 * respective addressable values, and by shifting recout.
+	 */
+	timing->h_addressable += timing->h_border_left + timing->h_border_right;
+	timing->v_addressable += timing->v_border_top + timing->v_border_bottom;
+	pipe_ctx->plane_res.scl_data.recout.y += timing->v_border_top;
+	pipe_ctx->plane_res.scl_data.recout.x += timing->h_border_left;
+	timing->v_border_top = 0;
+	timing->v_border_bottom = 0;
+	timing->h_border_left = 0;
+	timing->h_border_right = 0;
+
 	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable;
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable;
 

commit d94585a06b8197a723787c6c5502872abcff0e8e
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Thu Oct 5 16:47:49 2017 -0400

    drm/amd/display: rename transform to dpp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Eric Bernstein <Eric.Bernstein@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c80bde94472f..303d7ec684d9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -31,6 +31,7 @@
 #include "opp.h"
 #include "timing_generator.h"
 #include "transform.h"
+#include "dpp.h"
 #include "core_types.h"
 #include "set_mode_types.h"
 #include "virtual/virtual_stream_encoder.h"
@@ -853,8 +854,13 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable;
 
 	/* Taps calculations */
-	res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+	if (pipe_ctx->plane_res.xfm != NULL)
+		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
+				pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+
+	if (pipe_ctx->plane_res.dpp != NULL)
+		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
+				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
@@ -862,6 +868,9 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
 			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+
+		res = pipe_ctx->plane_res.dpp->funcs->dpp_get_optimal_number_of_taps(
+			pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -1026,7 +1035,7 @@ static int acquire_first_split_pipe(
 			pipe_ctx->stream_res.tg = pool->timing_generators[i];
 			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
-			pipe_ctx->plane_res.xfm = pool->transforms[i];
+			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
 			pipe_ctx->pipe_idx = i;
 
@@ -1359,6 +1368,7 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
+			pipe_ctx->plane_res.dpp = pool->dpps[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
 			pipe_ctx->pipe_idx = i;
 

commit abb4986eea1670922a0b89ef62688b4b649bd3c6
Author: Andrew Jiang <Andrew.Jiang@amd.com>
Date:   Wed Oct 4 15:55:45 2017 -0400

    drm/amd/display: Fix up plane_states add/remove logic
    
    Our plane_states array trimming logic was faulty, we should be starting
    to shuffle from the plane that was just released, not from the very
    beginning of the array.
    
    Also get rid of a leftover line that was setting the plane state at the
    stream index to null, leading to issues. Also move the
    dc_plane_state_retain call to where we reference plane_state, in case we
    do hit the error case where we can't get a free pipe.
    
    Signed-off-by: Andrew Jiang <Andrew.Jiang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4fb4f0068f1b..c80bde94472f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1073,9 +1073,6 @@ bool dc_add_plane_to_context(
 		return false;
 	}
 
-	/* retain new surfaces */
-	dc_plane_state_retain(plane_state);
-
 	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
@@ -1085,11 +1082,11 @@ bool dc_add_plane_to_context(
 			free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
 	}
 #endif
-	if (!free_pipe) {
-		stream_status->plane_states[i] = NULL;
+	if (!free_pipe)
 		return false;
-	}
 
+	/* retain new surfaces */
+	dc_plane_state_retain(plane_state);
 	free_pipe->plane_state = plane_state;
 
 	if (head_pipe != free_pipe) {
@@ -1181,8 +1178,8 @@ bool dc_remove_plane_from_context(
 
 	stream_status->plane_count--;
 
-	/* Trim back arrays */
-	for (i = 0; i < stream_status->plane_count; i++)
+	/* Start at the plane we've just released, and move all the planes one index forward to "trim" the array */
+	for (; i < stream_status->plane_count; i++)
 		stream_status->plane_states[i] = stream_status->plane_states[i + 1];
 
 	stream_status->plane_states[stream_status->plane_count] = NULL;

commit 8feabd03d34e4555c119e69269dae28f52e0d86c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 2 14:39:42 2017 -0400

    drm/amd/display: rename struct mem_input to hubp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7d750369b78b..4fb4f0068f1b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1024,7 +1024,7 @@ static int acquire_first_split_pipe(
 
 			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
 			pipe_ctx->stream_res.tg = pool->timing_generators[i];
-			pipe_ctx->plane_res.mi = pool->mis[i];
+			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
@@ -1359,6 +1359,7 @@ static int acquire_first_free_pipe(
 
 			pipe_ctx->stream_res.tg = pool->timing_generators[i];
 			pipe_ctx->plane_res.mi = pool->mis[i];
+			pipe_ctx->plane_res.hubp = pool->hubps[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];

commit 8e7095b909dd5451c92dc04420891a578e2f3152
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Oct 3 12:54:18 2017 -0400

    drm/amd/display: add max_video_width cap to dc
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c60f53069708..7d750369b78b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2750,11 +2750,9 @@ bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 
 bool dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state)
 {
-	struct dc *core_dc = dc;
-
 	/* TODO For now validates pixel format only */
-	if (core_dc->res_pool->funcs->validate_plane)
-		return core_dc->res_pool->funcs->validate_plane(plane_state) == DC_OK;
+	if (dc->res_pool->funcs->validate_plane)
+		return dc->res_pool->funcs->validate_plane(plane_state, &dc->caps) == DC_OK;
 
 	return true;
 }

commit 13ab1b44151195823fa0e2ceace1cf4687266dba
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Sep 28 17:18:27 2017 -0400

    drm/amd/display: Fixed extend to second screen mode hang
    
            1. Fixed acquire free split pipe bug.
            2. Change return value for dc_add_stream_to_ctx
               from bool to enum.
            4. Remove redundant apply_ctx_for_surface calling
            5. Unlock pipe after back end programming.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c31dccdc3d2e..c60f53069708 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1446,7 +1446,7 @@ bool resource_is_stream_unchanged(
 	return false;
 }
 
-bool dc_add_stream_to_ctx(
+enum dc_status dc_add_stream_to_ctx(
 		struct dc *dc,
 		struct dc_state *new_ctx,
 		struct dc_stream_state *stream)
@@ -1467,7 +1467,7 @@ bool dc_add_stream_to_ctx(
 	if (res != DC_OK)
 		DC_ERROR("Adding stream %p to context failed with err %d!\n", stream, res);
 
-	return res == DC_OK;
+	return res;
 }
 
 bool dc_remove_stream_from_ctx(
@@ -1640,10 +1640,9 @@ enum dc_status resource_map_pool_resources(
 	/* acquire new resources */
 	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	if (pipe_idx < 0)
-		acquire_first_split_pipe(&context->res_ctx, pool, stream);
-#endif
+		pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+
 	if (pipe_idx < 0)
 		return DC_NO_CONTROLLER_RESOURCE;
 

commit 66bfd4fd17737d0a644fa74e0cb309c0daf8fb22
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Thu Sep 28 15:38:01 2017 -0400

    drm/amd/display: arbitration find the matching dig-az first.
    
    [Description]
    this change is in branch already.
    without this change, after resume, az_inst might swapped.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 68c613229a10..c31dccdc3d2e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1417,19 +1417,15 @@ static struct audio *find_first_free_audio(
 		const struct resource_pool *pool)
 {
 	int i;
-	if (pool->audio_count >=  pool->stream_enc_count) {
-		for (i = 0; i < pool->audio_count; i++) {
-			if ((res_ctx->is_audio_acquired[i] == false) && (res_ctx->is_stream_enc_acquired[i] == true)) {
-				/*we have enough audio endpoint, no need to do dynamic distribution*/
-				return pool->audios[i];
-			}
+	for (i = 0; i < pool->audio_count; i++) {
+		if ((res_ctx->is_audio_acquired[i] == false) && (res_ctx->is_stream_enc_acquired[i] == true)) {
+			return pool->audios[i];
 		}
-	} else { /*first come first serve*/
-		for (i = 0; i < pool->audio_count; i++) {
-			if (res_ctx->is_audio_acquired[i] == false) {
-
-				return pool->audios[i];
-			}
+	}
+	/*not found the matching one, first come first serve*/
+	for (i = 0; i < pool->audio_count; i++) {
+		if (res_ctx->is_audio_acquired[i] == false) {
+			return pool->audios[i];
 		}
 	}
 	return 0;

commit 4176664b1fc8aa052f886037590cac4fb0dd8afb
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Sep 27 23:23:16 2017 -0400

    drm/amd/display: audio dynamic resource acquired related
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index bbfec7cb2ad1..68c613229a10 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -242,7 +242,10 @@ bool resource_construct(
 			pool->stream_enc_count++;
 		}
 	}
-
+	dc->caps.dynamic_audio = false;
+	if (pool->audio_count < pool->stream_enc_count) {
+		dc->caps.dynamic_audio = true;
+	}
 	for (i = 0; i < num_virtual_links; i++) {
 		pool->stream_enc[pool->stream_enc_count] =
 			virtual_stream_encoder_create(
@@ -1330,7 +1333,7 @@ static void update_stream_engine_usage(
 }
 
 /* TODO: release audio object */
-static void update_audio_usage(
+void update_audio_usage(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
 		struct audio *audio,
@@ -1414,12 +1417,21 @@ static struct audio *find_first_free_audio(
 		const struct resource_pool *pool)
 {
 	int i;
-	for (i = 0; i < pool->audio_count; i++) {
-		if (res_ctx->is_audio_acquired[i] == false) {
-			return pool->audios[i];
+	if (pool->audio_count >=  pool->stream_enc_count) {
+		for (i = 0; i < pool->audio_count; i++) {
+			if ((res_ctx->is_audio_acquired[i] == false) && (res_ctx->is_stream_enc_acquired[i] == true)) {
+				/*we have enough audio endpoint, no need to do dynamic distribution*/
+				return pool->audios[i];
+			}
 		}
-	}
+	} else { /*first come first serve*/
+		for (i = 0; i < pool->audio_count; i++) {
+			if (res_ctx->is_audio_acquired[i] == false) {
 
+				return pool->audios[i];
+			}
+		}
+	}
 	return 0;
 }
 

commit d596e5d08da0a25be789432ed821e63db9ef72ac
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Sep 21 10:46:33 2017 -0400

    drm/amd/display: Fixed incorrect return value for validaton
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d9a2d09a1f4f..bbfec7cb2ad1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1723,10 +1723,11 @@ enum dc_status dc_validate_global_state(
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	int i, j;
 
-	if (dc->res_pool->funcs->validate_global &&
-			dc->res_pool->funcs->validate_global(
-			dc, new_ctx) != DC_OK)
-		return false;
+	if (dc->res_pool->funcs->validate_global) {
+			result = dc->res_pool->funcs->validate_global(dc, new_ctx);
+			if (result != DC_OK)
+				return result;
+	}
 
 	for (i = 0; new_ctx && i < new_ctx->stream_count; i++) {
 		struct dc_stream_state *stream = new_ctx->streams[i];

commit e750d56d2c62875c81f52344afab44220300388d
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Sep 20 17:06:18 2017 -0400

    drm/amd/display: Fixed validation return wrong result.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 77b3474a7c9e..d9a2d09a1f4f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1716,7 +1716,7 @@ void dc_resource_state_construct(
 	dst_ctx->dis_clk = dc->res_pool->display_clock;
 }
 
-bool dc_validate_global_state(
+enum dc_status dc_validate_global_state(
 		struct dc *dc,
 		struct dc_state *new_ctx)
 {

commit 8ee5702afdd48b5864c46418ad310d6a23c8e9ab
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 12:39:02 2017 +1000

    amdgpu/dc: use kref for dc_state.
    
    I'm not a huge fan of those copying around refcounts bits, might
    want to consider alternates, but this should work for now.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 99a4d19f582d..77b3474a7c9e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2432,7 +2432,7 @@ void dc_resource_state_copy_construct(
 		struct dc_state *dst_ctx)
 {
 	int i, j;
-	atomic_t ref_count = dst_ctx->ref_count;
+	struct kref refcount = dst_ctx->refcount;
 
 	*dst_ctx = *src_ctx;
 
@@ -2455,7 +2455,7 @@ void dc_resource_state_copy_construct(
 	}
 
 	/* context refcount should not be overridden */
-	dst_ctx->ref_count = ref_count;
+	dst_ctx->refcount = refcount;
 
 }
 

commit d029810caafa4e6b146274560154e3f0f0381fb5
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Oct 3 14:27:14 2017 +1000

    amdgpu/dc: kfree already checks for NULL.
    
    Don't bother checking for it.
    
    Found with the cocci ifnullfree.cocci script.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1832f252edab..99a4d19f582d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -159,8 +159,7 @@ void dc_destroy_resource_pool(struct dc  *dc)
 		if (dc->res_pool)
 			dc->res_pool->funcs->destroy(&dc->res_pool);
 
-		if (dc->hwseq)
-			kfree(dc->hwseq);
+		kfree(dc->hwseq);
 	}
 }
 

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index dcfdfebd5c62..1832f252edab 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -160,7 +160,7 @@ void dc_destroy_resource_pool(struct dc  *dc)
 			dc->res_pool->funcs->destroy(&dc->res_pool);
 
 		if (dc->hwseq)
-			dm_free(dc->hwseq);
+			kfree(dc->hwseq);
 	}
 }
 

commit 2c8f195adf21430e4e8bbd13942826ccf8fa225c
Author: Shirish S <shirish.s@amd.com>
Date:   Tue Sep 26 12:26:41 2017 +0530

    drm/amd/display: don't clean-up bottom pipe plane_state
    
    In the scenario of setting underlay, dc_validate_global_state()
    is called after constructing the context with all
    relevant bottom_pipe related configurations in dm_update_planes_state().
    
    Currently, in dc_validate_global_state(), without checking for bottom_pipe's
    existence, the pipe_ctx structure is initialised to 0, hence
    nullyfying the plane_state of bottom_pipe which shall be accessed
    in populate_initial_data() called from bw_calcs().
    
    Due to this null pointer access kernel panics and leads to reboot
    when underlay is tried to set.
    
    This patch fixes the issue by no longer clearing the top_pipe. This
    workaround is no longer required.
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 15b627548cd2..dcfdfebd5c62 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1729,14 +1729,6 @@ bool dc_validate_global_state(
 			dc, new_ctx) != DC_OK)
 		return false;
 
-	/* TODO without this SWDEV-114774 brakes */
-	for (i = 0; i < dc->res_pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];
-
-		if (pipe_ctx->top_pipe)
-			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-	}
-
 	for (i = 0; new_ctx && i < new_ctx->stream_count; i++) {
 		struct dc_stream_state *stream = new_ctx->streams[i];
 

commit 21e67d4d52ca8688feb8c4f6e6d29b2d16d578ad
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 5 15:50:48 2017 -0400

    drm/amd/display: No need to keep track of unreffed clk sources
    
    This simplifies clock source reprogramming a bit.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9aa0da743174..15b627548cd2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -261,13 +261,12 @@ bool resource_construct(
 }
 
 
-bool resource_unreference_clock_source(
+void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
 		struct clock_source *clock_source)
 {
 	int i;
-	bool need_reset = false;
 
 	for (i = 0; i < pool->clk_src_count; i++) {
 		if (pool->clock_sources[i] != clock_source)
@@ -275,24 +274,11 @@ bool resource_unreference_clock_source(
 
 		res_ctx->clock_source_ref_count[i]--;
 
-		if (res_ctx->clock_source_ref_count[i] == 0) {
-			res_ctx->clock_source_changed[i] = true;
-			need_reset = true;
-		}
-
 		break;
 	}
 
-	if (pool->dp_clock_source == clock_source) {
+	if (pool->dp_clock_source == clock_source)
 		res_ctx->dp_clock_source_ref_count--;
-
-		if (res_ctx->dp_clock_source_ref_count == 0) {
-			res_ctx->dp_clock_source_changed = true;
-			need_reset = true;
-		}
-	}
-
-	return need_reset;
 }
 
 void resource_reference_clock_source(

commit 9d0dcecd93e4997c65b18404f1ab2fce2ab79010
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 19:05:17 2017 -0400

    drm/amd/display: Power down clock source at commit
    
    Still one more in dc_validate_global
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 57c3dcd3fadd..9aa0da743174 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -275,8 +275,10 @@ bool resource_unreference_clock_source(
 
 		res_ctx->clock_source_ref_count[i]--;
 
-		if (res_ctx->clock_source_ref_count[i] == 0)
+		if (res_ctx->clock_source_ref_count[i] == 0) {
+			res_ctx->clock_source_changed[i] = true;
 			need_reset = true;
+		}
 
 		break;
 	}
@@ -284,8 +286,10 @@ bool resource_unreference_clock_source(
 	if (pool->dp_clock_source == clock_source) {
 		res_ctx->dp_clock_source_ref_count--;
 
-		if (res_ctx->dp_clock_source_ref_count == 0)
+		if (res_ctx->dp_clock_source_ref_count == 0) {
+			res_ctx->dp_clock_source_changed = true;
 			need_reset = true;
+		}
 	}
 
 	return need_reset;
@@ -1502,6 +1506,10 @@ bool dc_remove_stream_from_ctx(
 					del_pipe->stream_res.audio,
 					false);
 
+			resource_unreference_clock_source(&new_ctx->res_ctx,
+							  dc->res_pool,
+							  del_pipe->clock_source);
+
 			memset(del_pipe, 0, sizeof(*del_pipe));
 
 			break;
@@ -1759,13 +1767,10 @@ bool dc_validate_global_state(
 			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
 				!find_pll_sharable_stream(stream, new_ctx)) {
 
-				if (resource_unreference_clock_source(
+				resource_unreference_clock_source(
 						&new_ctx->res_ctx,
 						dc->res_pool,
-						pipe_ctx->clock_source)) {
-					pipe_ctx->clock_source->funcs->cs_power_down(pipe_ctx->clock_source);
-					pipe_ctx->clock_source = NULL;
-				}
+						pipe_ctx->clock_source);
 
 				pipe_ctx->clock_source = dc->res_pool->dp_clock_source;
 				resource_reference_clock_source(

commit 4a6295361c737a80e9f079952ac863a3b0c26acf
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 18:43:45 2017 -0400

    drm/amd/display: Don't reset clock source at unref
    
    Powering down the clock source during unref is unsafe as we might want
    to unref during atomic_check
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ce721b77c1bc..57c3dcd3fadd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -261,31 +261,34 @@ bool resource_construct(
 }
 
 
-void resource_unreference_clock_source(
+bool resource_unreference_clock_source(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct clock_source **clock_source)
+		struct clock_source *clock_source)
 {
 	int i;
+	bool need_reset = false;
+
 	for (i = 0; i < pool->clk_src_count; i++) {
-		if (pool->clock_sources[i] != *clock_source)
+		if (pool->clock_sources[i] != clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]--;
 
 		if (res_ctx->clock_source_ref_count[i] == 0)
-			(*clock_source)->funcs->cs_power_down(*clock_source);
+			need_reset = true;
 
 		break;
 	}
 
-	if (pool->dp_clock_source == *clock_source) {
+	if (pool->dp_clock_source == clock_source) {
 		res_ctx->dp_clock_source_ref_count--;
 
 		if (res_ctx->dp_clock_source_ref_count == 0)
-			(*clock_source)->funcs->cs_power_down(*clock_source);
+			need_reset = true;
 	}
-	*clock_source = NULL;
+
+	return need_reset;
 }
 
 void resource_reference_clock_source(
@@ -1756,10 +1759,14 @@ bool dc_validate_global_state(
 			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
 				!find_pll_sharable_stream(stream, new_ctx)) {
 
-				resource_unreference_clock_source(
+				if (resource_unreference_clock_source(
 						&new_ctx->res_ctx,
 						dc->res_pool,
-						&pipe_ctx->clock_source);
+						pipe_ctx->clock_source)) {
+					pipe_ctx->clock_source->funcs->cs_power_down(pipe_ctx->clock_source);
+					pipe_ctx->clock_source = NULL;
+				}
+
 				pipe_ctx->clock_source = dc->res_pool->dp_clock_source;
 				resource_reference_clock_source(
 						&new_ctx->res_ctx,

commit 603767f903bf5bf301728b197dcde63cf880fe2e
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Fri Sep 1 16:14:01 2017 -0400

    drm/amd/display: fix default dithering
    
    bug: default is mapped to no dithering.
    
    default to spatial dithering based on color depth
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fbf7747424a9..ce721b77c1bc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2607,6 +2607,22 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 
 	memset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));
 
+	if (option == DITHER_OPTION_DEFAULT) {
+		switch (stream->timing.display_color_depth) {
+		case COLOR_DEPTH_666:
+			option = DITHER_OPTION_SPATIAL6;
+			break;
+		case COLOR_DEPTH_888:
+			option = DITHER_OPTION_SPATIAL8;
+			break;
+		case COLOR_DEPTH_101010:
+			option = DITHER_OPTION_SPATIAL10;
+			break;
+		default:
+			option = DITHER_OPTION_DISABLE;
+		}
+	}
+
 	if (option == DITHER_OPTION_DISABLE)
 		return;
 

commit 7c228a1a910784801360db5aedd153db9f465b56
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Aug 28 10:59:39 2017 -0400

    drm/amd/display: Don't spam log with failed validation
    
    In a lot of case we fail validation of timings for legitimate
    reasons. No need to print an error.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c7bb966e8b29..fbf7747424a9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2711,7 +2711,6 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 {
 	struct dc  *core_dc = dc;
-	struct dc_context *dc_ctx = core_dc->ctx;
 	struct dc_link *link = stream->sink->link;
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
@@ -2733,10 +2732,6 @@ bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 		      link,
 		      &stream->timing);
 
-	if (res != DC_OK)
-		DC_ERROR("Failed validation for stream %p, err:%d, !\n",
-				stream, res);
-
 	return res == DC_OK;
 }
 

commit ab8db3e1653c50ae19d1c31d82f94beb5115aeef
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Aug 28 14:25:01 2017 -0400

    drm/amd/display: Move dis_clk into dc_state.
    
    dis_clk is single instance across pipes.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a4e92219a594..c7bb966e8b29 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1033,7 +1033,6 @@ static int acquire_first_split_pipe(
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
-			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -1368,7 +1367,6 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->stream_res.opp = pool->opps[i];
-			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 
@@ -1714,6 +1712,14 @@ void dc_resource_state_copy_construct_current(
 	dc_resource_state_copy_construct(dc->current_state, dst_ctx);
 }
 
+
+void dc_resource_state_construct(
+		const struct dc *dc,
+		struct dc_state *dst_ctx)
+{
+	dst_ctx->dis_clk = dc->res_pool->display_clock;
+}
+
 bool dc_validate_global_state(
 		struct dc *dc,
 		struct dc_state *new_ctx)

commit 4ed4e51b19496c4d160f3ca368d9ff5dd3e4a5b9
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Wed Aug 23 15:29:18 2017 -0400

    drm/amd/display: Add a clock source to a sharing pipe
    
    Fix to allow DVI displays to share the same clock source
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d284d9d40e2b..a4e92219a594 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2536,7 +2536,7 @@ enum dc_status resource_map_clock_resources(
 		pipe_ctx->clock_source = NULL;
 
 		if (!dc->config.disable_disp_pll_sharing)
-			resource_find_used_clk_src_for_sharing(
+			pipe_ctx->clock_source = resource_find_used_clk_src_for_sharing(
 				&context->res_ctx,
 				pipe_ctx);
 

commit f36cc577c3254738e370b553f9f8cedf2df84070
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Aug 28 12:04:23 2017 -0400

    drm/amd/display: Rename dc resource_validate_ctx methods
    
    Rename dc_resource methods from validate_ctx to state
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 727afeaa3830..d284d9d40e2b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1707,11 +1707,11 @@ void validate_guaranteed_copy_streams(
 	}
 }
 
-void dc_resource_validate_ctx_copy_construct_current(
+void dc_resource_state_copy_construct_current(
 		const struct dc *dc,
 		struct dc_state *dst_ctx)
 {
-	dc_resource_validate_ctx_copy_construct(dc->current_state, dst_ctx);
+	dc_resource_state_copy_construct(dc->current_state, dst_ctx);
 }
 
 bool dc_validate_global_state(
@@ -2413,7 +2413,7 @@ static void set_vsc_info_packet(
 	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
 }
 
-void dc_resource_validate_ctx_destruct(struct dc_state *context)
+void dc_resource_state_destruct(struct dc_state *context)
 {
 	int i, j;
 
@@ -2432,7 +2432,7 @@ void dc_resource_validate_ctx_destruct(struct dc_state *context)
  * Copy src_ctx into dst_ctx and retain all surfaces and streams referenced
  * by the src_ctx
  */
-void dc_resource_validate_ctx_copy_construct(
+void dc_resource_state_copy_construct(
 		const struct dc_state *src_ctx,
 		struct dc_state *dst_ctx)
 {

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_state and
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9eb8d48bc889..727afeaa3830 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -893,7 +893,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 enum dc_status resource_build_scaling_params_for_context(
 	const struct dc  *dc,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	int i;
 
@@ -971,7 +971,7 @@ static struct pipe_ctx *resource_get_tail_pipe_for_stream(
  * that has no surface attached yet
  */
 static struct pipe_ctx *acquire_free_pipe_for_stream(
-		struct validate_context *context,
+		struct dc_state *context,
 		const struct resource_pool *pool,
 		struct dc_stream_state *stream)
 {
@@ -1048,7 +1048,7 @@ bool dc_add_plane_to_context(
 		const struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_plane_state *plane_state,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 	struct resource_pool *pool = dc->res_pool;
@@ -1124,7 +1124,7 @@ bool dc_remove_plane_from_context(
 		const struct dc *dc,
 		struct dc_stream_state *stream,
 		struct dc_plane_state *plane_state,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 	struct dc_stream_status *stream_status = NULL;
@@ -1199,7 +1199,7 @@ bool dc_remove_plane_from_context(
 bool dc_rem_all_planes_for_stream(
 		const struct dc *dc,
 		struct dc_stream_state *stream,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i, old_plane_count;
 	struct dc_stream_status *stream_status = NULL;
@@ -1233,7 +1233,7 @@ static bool add_all_planes_for_stream(
 		struct dc_stream_state *stream,
 		const struct dc_validation_set set[],
 		int set_count,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i, j;
 
@@ -1258,7 +1258,7 @@ bool dc_add_all_planes_for_stream(
 		struct dc_stream_state *stream,
 		struct dc_plane_state * const *plane_states,
 		int plane_count,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	struct dc_validation_set set;
 	int i;
@@ -1434,7 +1434,7 @@ static struct audio *find_first_free_audio(
 }
 
 bool resource_is_stream_unchanged(
-	struct validate_context *old_context, struct dc_stream_state *stream)
+	struct dc_state *old_context, struct dc_stream_state *stream)
 {
 	int i;
 
@@ -1450,7 +1450,7 @@ bool resource_is_stream_unchanged(
 
 bool dc_add_stream_to_ctx(
 		struct dc *dc,
-		struct validate_context *new_ctx,
+		struct dc_state *new_ctx,
 		struct dc_stream_state *stream)
 {
 	struct dc_context *dc_ctx = dc->ctx;
@@ -1474,7 +1474,7 @@ bool dc_add_stream_to_ctx(
 
 bool dc_remove_stream_from_ctx(
 			struct dc *dc,
-			struct validate_context *new_ctx,
+			struct dc_state *new_ctx,
 			struct dc_stream_state *stream)
 {
 	int i;
@@ -1553,7 +1553,7 @@ static void copy_pipe_ctx(
 
 static struct dc_stream_state *find_pll_sharable_stream(
 		struct dc_stream_state *stream_needs_pll,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 
@@ -1615,7 +1615,7 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 
 enum dc_status resource_map_pool_resources(
 		const struct dc  *dc,
-		struct validate_context *context,
+		struct dc_state *context,
 		struct dc_stream_state *stream)
 {
 	const struct resource_pool *pool = dc->res_pool;
@@ -1689,7 +1689,7 @@ enum dc_status resource_map_pool_resources(
 
 /* first stream in the context is used to populate the rest */
 void validate_guaranteed_copy_streams(
-		struct validate_context *context,
+		struct dc_state *context,
 		int max_streams)
 {
 	int i;
@@ -1709,14 +1709,14 @@ void validate_guaranteed_copy_streams(
 
 void dc_resource_validate_ctx_copy_construct_current(
 		const struct dc *dc,
-		struct validate_context *dst_ctx)
+		struct dc_state *dst_ctx)
 {
-	dc_resource_validate_ctx_copy_construct(dc->current_context, dst_ctx);
+	dc_resource_validate_ctx_copy_construct(dc->current_state, dst_ctx);
 }
 
 bool dc_validate_global_state(
 		struct dc *dc,
-		struct validate_context *new_ctx)
+		struct dc_state *new_ctx)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 	int i, j;
@@ -2413,7 +2413,7 @@ static void set_vsc_info_packet(
 	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
 }
 
-void dc_resource_validate_ctx_destruct(struct validate_context *context)
+void dc_resource_validate_ctx_destruct(struct dc_state *context)
 {
 	int i, j;
 
@@ -2433,8 +2433,8 @@ void dc_resource_validate_ctx_destruct(struct validate_context *context)
  * by the src_ctx
  */
 void dc_resource_validate_ctx_copy_construct(
-		const struct validate_context *src_ctx,
-		struct validate_context *dst_ctx)
+		const struct dc_state *src_ctx,
+		struct dc_state *dst_ctx)
 {
 	int i, j;
 	atomic_t ref_count = dst_ctx->ref_count;
@@ -2518,7 +2518,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 
 enum dc_status resource_map_clock_resources(
 		const struct dc  *dc,
-		struct validate_context *context,
+		struct dc_state *context,
 		struct dc_stream_state *stream)
 {
 	/* acquire new resources */

commit 96313f1b7a4b14c8e120564698aa3be709445324
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Thu Aug 24 16:03:02 2017 -0400

    drm/amd/display: Fix MST downstream display not light up regression
    
    The fix is for the scenario: MST+SST chain together, and hook up
    to the card.
    
    Regression: Per stream validate_context build v2
    Before dc_add_stream_to_ctx(), need to update/reset
    stream signal type to SIGNAL_TYPE_DISPLAY_PORT_MST. Otherwise,
    downstream device cannot be added to ctx due to the lack of signal
    type info (SIGNAL_TYPE_NONE).
    update_stream_signal() needs to be done after stream is created.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6eee1b1a563e..9eb8d48bc889 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1323,7 +1323,6 @@ bool dc_is_stream_unchanged(
 
 /* Maximum TMDS single link pixel clock 165MHz */
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
-#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
 
 static void update_stream_engine_usage(
 		struct resource_context *res_ctx,
@@ -1434,28 +1433,6 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-static void update_stream_signal(struct dc_stream_state *stream)
-{
-	if (stream->output_signal == SIGNAL_TYPE_NONE) {
-		struct dc_sink *dc_sink = stream->sink;
-
-		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-			stream->signal = stream->sink->link->connector_signal;
-		else
-			stream->signal = dc_sink->sink_signal;
-	} else {
-		stream->signal = stream->output_signal;
-	}
-
-	if (dc_is_dvi_signal(stream->signal)) {
-		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
-			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
-			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
-		else
-			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
-	}
-}
-
 bool resource_is_stream_unchanged(
 	struct validate_context *old_context, struct dc_stream_state *stream)
 {
@@ -1627,8 +1604,6 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 
 static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 {
-	update_stream_signal(stream);
-
 	/* update actual pixel clock on all streams */
 	if (dc_is_hdmi_signal(stream->signal))
 		stream->phy_pix_clk = get_norm_pix_clk(

commit 19f89e2392e692208a0a00465d30b2b2bf43e9a9
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Aug 11 10:43:45 2017 -0400

    drm/amd/display: Per plane validation context build.
    
    Introduce add/remove plane to/from context.
    Make DC wrapper to use them in WIndows/Diags.
    Use them in dc_update_surface_to_stream.
    Call add/remove plane from Linux DM.
    
    Remove dc_validation_set from dc_validate_global_state interface
    and by this remove clean Linux DM from using it.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fbfe15f783c0..6eee1b1a563e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -946,6 +946,26 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	return NULL;
 }
 
+static struct pipe_ctx *resource_get_tail_pipe_for_stream(
+		struct resource_context *res_ctx,
+		struct dc_stream_state *stream)
+{
+	struct pipe_ctx *head_pipe, *tail_pipe;
+	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
+
+	if (!head_pipe)
+		return NULL;
+
+	tail_pipe = head_pipe->bottom_pipe;
+
+	while (tail_pipe) {
+		head_pipe = tail_pipe;
+		tail_pipe = tail_pipe->bottom_pipe;
+	}
+
+	return head_pipe;
+}
+
 /*
  * A free_pipe for a stream is defined here as a pipe
  * that has no surface attached yet
@@ -990,22 +1010,6 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 }
 
-static void release_free_pipes_for_stream(
-		struct resource_context *res_ctx,
-		struct dc_stream_state *stream)
-{
-	int i;
-
-	for (i = MAX_PIPES - 1; i >= 0; i--) {
-		/* never release the topmost pipe*/
-		if (res_ctx->pipe_ctx[i].stream == stream &&
-				res_ctx->pipe_ctx[i].top_pipe &&
-				!res_ctx->pipe_ctx[i].plane_state) {
-			memset(&res_ctx->pipe_ctx[i], 0, sizeof(struct pipe_ctx));
-		}
-	}
-}
-
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
@@ -1040,96 +1044,235 @@ static int acquire_first_split_pipe(
 }
 #endif
 
-bool resource_attach_surfaces_to_context(
-		struct dc_plane_state * const *plane_states,
-		int surface_count,
+bool dc_add_plane_to_context(
+		const struct dc *dc,
 		struct dc_stream_state *stream,
-		struct validate_context *context,
-		const struct resource_pool *pool)
+		struct dc_plane_state *plane_state,
+		struct validate_context *context)
 {
 	int i;
-	struct pipe_ctx *tail_pipe;
+	struct resource_pool *pool = dc->res_pool;
+	struct pipe_ctx *head_pipe, *tail_pipe, *free_pipe;
 	struct dc_stream_status *stream_status = NULL;
 
+	for (i = 0; i < context->stream_count; i++)
+		if (context->streams[i] == stream) {
+			stream_status = &context->stream_status[i];
+			break;
+		}
+	if (stream_status == NULL) {
+		dm_error("Existing stream not found; failed to attach surface!\n");
+		return false;
+	}
+
+
+	if (stream_status->plane_count == MAX_SURFACE_NUM) {
+		dm_error("Surface: can not attach plane_state %p! Maximum is: %d\n",
+				plane_state, MAX_SURFACE_NUM);
+		return false;
+	}
+
+	head_pipe = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
+
+	if (!head_pipe) {
+		dm_error("Head pipe not found for stream_state %p !\n", stream);
+		return false;
+	}
+
+	/* retain new surfaces */
+	dc_plane_state_retain(plane_state);
+
+	free_pipe = acquire_free_pipe_for_stream(context, pool, stream);
 
-	if (surface_count > MAX_SURFACE_NUM) {
-		dm_error("Surface: can not attach %d surfaces! Maximum is: %d\n",
-			surface_count, MAX_SURFACE_NUM);
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	if (!free_pipe) {
+		int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+		if (pipe_idx >= 0)
+			free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
+	}
+#endif
+	if (!free_pipe) {
+		stream_status->plane_states[i] = NULL;
 		return false;
 	}
 
+	free_pipe->plane_state = plane_state;
+
+	if (head_pipe != free_pipe) {
+
+		tail_pipe = resource_get_tail_pipe_for_stream(&context->res_ctx, stream);
+		ASSERT(tail_pipe);
+
+		free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
+		free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
+		free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
+		free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
+		free_pipe->clock_source = tail_pipe->clock_source;
+		free_pipe->top_pipe = tail_pipe;
+		tail_pipe->bottom_pipe = free_pipe;
+	}
+
+	/* assign new surfaces*/
+	stream_status->plane_states[stream_status->plane_count] = plane_state;
+
+	stream_status->plane_count++;
+
+	return true;
+}
+
+bool dc_remove_plane_from_context(
+		const struct dc *dc,
+		struct dc_stream_state *stream,
+		struct dc_plane_state *plane_state,
+		struct validate_context *context)
+{
+	int i;
+	struct dc_stream_status *stream_status = NULL;
+	struct resource_pool *pool = dc->res_pool;
+
 	for (i = 0; i < context->stream_count; i++)
 		if (context->streams[i] == stream) {
 			stream_status = &context->stream_status[i];
 			break;
 		}
+
 	if (stream_status == NULL) {
-		dm_error("Existing stream not found; failed to attach surfaces\n");
+		dm_error("Existing stream not found; failed to remove plane.\n");
 		return false;
 	}
 
-	/* retain new surfaces */
-	for (i = 0; i < surface_count; i++)
-		dc_plane_state_retain(plane_states[i]);
-
-	/* detach surfaces from pipes */
-	for (i = 0; i < pool->pipe_count; i++)
-		if (context->res_ctx.pipe_ctx[i].stream == stream) {
-			context->res_ctx.pipe_ctx[i].plane_state = NULL;
-			context->res_ctx.pipe_ctx[i].bottom_pipe = NULL;
-		}
+	/* release pipe for plane*/
+	for (i = pool->pipe_count - 1; i >= 0; i--) {
+		struct pipe_ctx *pipe_ctx;
 
-	/* release existing surfaces*/
-	for (i = 0; i < stream_status->plane_count; i++)
-		dc_plane_state_release(stream_status->plane_states[i]);
+		if (context->res_ctx.pipe_ctx[i].plane_state == plane_state) {
+			pipe_ctx = &context->res_ctx.pipe_ctx[i];
 
-	for (i = surface_count; i < stream_status->plane_count; i++)
-		stream_status->plane_states[i] = NULL;
+			if (pipe_ctx->top_pipe)
+				pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
 
-	tail_pipe = NULL;
-	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *plane_state = plane_states[i];
-		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
-				context, pool, stream);
+			/* Second condition is to avoid setting NULL to top pipe
+			 * of tail pipe making it look like head pipe in subsequent
+			 * deletes
+			 */
+			if (pipe_ctx->bottom_pipe && pipe_ctx->top_pipe)
+				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-		if (!free_pipe) {
-			int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
-			if (pipe_idx >= 0)
-				free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
-		}
-#endif
-		if (!free_pipe) {
-			stream_status->plane_states[i] = NULL;
-			return false;
+			/*
+			 * For head pipe detach surfaces from pipe for tail
+			 * pipe just zero it out
+			 */
+			if (!pipe_ctx->top_pipe) {
+				pipe_ctx->plane_state = NULL;
+				pipe_ctx->bottom_pipe = NULL;
+			} else  {
+				memset(pipe_ctx, 0, sizeof(*pipe_ctx));
+			}
 		}
+	}
+
 
-		free_pipe->plane_state = plane_state;
+	for (i = 0; i < stream_status->plane_count; i++) {
+		if (stream_status->plane_states[i] == plane_state) {
 
-		if (tail_pipe) {
-			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
-			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
-			free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
-			free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
-			free_pipe->clock_source = tail_pipe->clock_source;
-			free_pipe->top_pipe = tail_pipe;
-			tail_pipe->bottom_pipe = free_pipe;
+			dc_plane_state_release(stream_status->plane_states[i]);
+			break;
 		}
+	}
 
-		tail_pipe = free_pipe;
+	if (i == stream_status->plane_count) {
+		dm_error("Existing plane_state not found; failed to detach it!\n");
+		return false;
 	}
 
-	release_free_pipes_for_stream(&context->res_ctx, stream);
+	stream_status->plane_count--;
 
-	/* assign new surfaces*/
-	for (i = 0; i < surface_count; i++)
-		stream_status->plane_states[i] = plane_states[i];
+	/* Trim back arrays */
+	for (i = 0; i < stream_status->plane_count; i++)
+		stream_status->plane_states[i] = stream_status->plane_states[i + 1];
+
+	stream_status->plane_states[stream_status->plane_count] = NULL;
+
+	return true;
+}
+
+bool dc_rem_all_planes_for_stream(
+		const struct dc *dc,
+		struct dc_stream_state *stream,
+		struct validate_context *context)
+{
+	int i, old_plane_count;
+	struct dc_stream_status *stream_status = NULL;
+	struct dc_plane_state *del_planes[MAX_SURFACE_NUM] = { 0 };
+
+	for (i = 0; i < context->stream_count; i++)
+			if (context->streams[i] == stream) {
+				stream_status = &context->stream_status[i];
+				break;
+			}
+
+	if (stream_status == NULL) {
+		dm_error("Existing stream %p not found!\n", stream);
+		return false;
+	}
+
+	old_plane_count = stream_status->plane_count;
 
-	stream_status->plane_count = surface_count;
+	for (i = 0; i < old_plane_count; i++)
+		del_planes[i] = stream_status->plane_states[i];
+
+	for (i = 0; i < old_plane_count; i++)
+		if (!dc_remove_plane_from_context(dc, stream, del_planes[i], context))
+			return false;
 
 	return true;
 }
 
+static bool add_all_planes_for_stream(
+		const struct dc *dc,
+		struct dc_stream_state *stream,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context)
+{
+	int i, j;
+
+	for (i = 0; i < set_count; i++)
+		if (set[i].stream == stream)
+			break;
+
+	if (i == set_count) {
+		dm_error("Stream %p not found in set!\n", stream);
+		return false;
+	}
+
+	for (j = 0; j < set[i].plane_count; j++)
+		if (!dc_add_plane_to_context(dc, stream, set[i].plane_states[j], context))
+			return false;
+
+	return true;
+}
+
+bool dc_add_all_planes_for_stream(
+		const struct dc *dc,
+		struct dc_stream_state *stream,
+		struct dc_plane_state * const *plane_states,
+		int plane_count,
+		struct validate_context *context)
+{
+	struct dc_validation_set set;
+	int i;
+
+	set.stream = stream;
+	set.plane_count = plane_count;
+
+	for (i = 0; i < plane_count; i++)
+		set.plane_states[i] = plane_states[i];
+
+	return add_all_planes_for_stream(dc, stream, &set, 1, context);
+}
+
+
 
 static bool is_timing_changed(struct dc_stream_state *cur_stream,
 		struct dc_stream_state *new_stream)
@@ -1178,41 +1321,6 @@ bool dc_is_stream_unchanged(
 	return true;
 }
 
-bool resource_validate_attach_surfaces(
-		const struct dc_validation_set set[],
-		int set_count,
-		const struct validate_context *old_context,
-		struct validate_context *context,
-		const struct resource_pool *pool)
-{
-	int i, j;
-
-	for (i = 0; i < set_count; i++) {
-		for (j = 0; old_context && j < old_context->stream_count; j++)
-			if (dc_is_stream_unchanged(
-					old_context->streams[j],
-					context->streams[i])) {
-				if (!resource_attach_surfaces_to_context(
-						old_context->stream_status[j].plane_states,
-						old_context->stream_status[j].plane_count,
-						context->streams[i],
-						context, pool))
-					return false;
-				context->stream_status[i] = old_context->stream_status[j];
-			}
-		if (set[i].plane_count != 0)
-			if (!resource_attach_surfaces_to_context(
-					set[i].plane_states,
-					set[i].plane_count,
-					context->streams[i],
-					context, pool))
-				return false;
-
-	}
-
-	return true;
-}
-
 /* Maximum TMDS single link pixel clock 165MHz */
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
@@ -1392,23 +1500,22 @@ bool dc_remove_stream_from_ctx(
 			struct validate_context *new_ctx,
 			struct dc_stream_state *stream)
 {
-	int i, j;
+	int i;
 	struct dc_context *dc_ctx = dc->ctx;
 	struct pipe_ctx *del_pipe = NULL;
 
-	/*TODO MPO to remove extra pipe or in surface remove ?*/
-
-	/* Release primary and secondary pipe (if exsist) */
+	/* Release primary pipe */
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream) {
+		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream &&
+				!new_ctx->res_ctx.pipe_ctx[i].top_pipe) {
 			del_pipe = &new_ctx->res_ctx.pipe_ctx[i];
 
-			if (del_pipe->stream_res.stream_enc)
-				update_stream_engine_usage(
-						&new_ctx->res_ctx,
+			ASSERT(del_pipe->stream_res.stream_enc);
+			update_stream_engine_usage(
+					&new_ctx->res_ctx,
 						dc->res_pool,
-						del_pipe->stream_res.stream_enc,
-						false);
+					del_pipe->stream_res.stream_enc,
+					false);
 
 			if (del_pipe->stream_res.audio)
 				update_audio_usage(
@@ -1418,6 +1525,8 @@ bool dc_remove_stream_from_ctx(
 					false);
 
 			memset(del_pipe, 0, sizeof(*del_pipe));
+
+			break;
 		}
 	}
 
@@ -1438,10 +1547,6 @@ bool dc_remove_stream_from_ctx(
 	dc_stream_release(new_ctx->streams[i]);
 	new_ctx->stream_count--;
 
-	/*TODO move into dc_remove_surface_from_ctx	?*/
-	for (j = 0; j < new_ctx->stream_status[i].plane_count; j++)
-		dc_plane_state_release(new_ctx->stream_status[i].plane_states[j]);
-
 	/* Trim back arrays */
 	for (; i < new_ctx->stream_count; i++) {
 		new_ctx->streams[i] = new_ctx->streams[i + 1];
@@ -1636,18 +1741,14 @@ void dc_resource_validate_ctx_copy_construct_current(
 
 bool dc_validate_global_state(
 		struct dc *dc,
-		const struct dc_validation_set set[],
-		int set_count,
 		struct validate_context *new_ctx)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
-	struct dc_context *dc_ctx = dc->ctx;
-	struct validate_context *old_context = dc->current_context;
 	int i, j;
 
 	if (dc->res_pool->funcs->validate_global &&
-	    dc->res_pool->funcs->validate_global(dc, set, set_count,
-						 old_context, new_ctx) != DC_OK)
+			dc->res_pool->funcs->validate_global(
+			dc, new_ctx) != DC_OK)
 		return false;
 
 	/* TODO without this SWDEV-114774 brakes */
@@ -1687,15 +1788,6 @@ bool dc_validate_global_state(
 		}
 	}
 
-	/*TODO This should be ok */
-	/* Split pipe resource, do not acquire back end */
-
-	if (!resource_validate_attach_surfaces(
-			set, set_count, old_context, new_ctx, dc->res_pool)) {
-		DC_ERROR("Failed to attach surface to stream!\n");
-		return DC_FAIL_ATTACH_SURFACES;
-	}
-
 	result = resource_build_scaling_params_for_context(dc, new_ctx);
 
 	if (result == DC_OK)

commit 0f0bdca5cae04ec2f842955bcef16a3daed6149f
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Aug 22 18:42:51 2017 -0400

    drm/amd/display: Safe stream encoder id in stream_status
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 428863bccab6..fbfe15f783c0 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1599,6 +1599,7 @@ enum dc_status resource_map_pool_resources(
 	for (i = 0; i < context->stream_count; i++)
 		if (context->streams[i] == stream) {
 			context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
+			context->stream_status[i].stream_enc_inst = pipe_ctx->stream_res.stream_enc->id;
 			return DC_OK;
 		}
 

commit 83a3d42d121301d26601ef7599052e1d78fde9fb
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Mon Aug 21 16:28:39 2017 -0400

    drm/amd/display: Remove unneeded code
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f640986c6fd2..428863bccab6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1633,79 +1633,6 @@ void dc_resource_validate_ctx_copy_construct_current(
 	dc_resource_validate_ctx_copy_construct(dc->current_context, dst_ctx);
 }
 
-bool dc_validate_with_context(
-		struct dc *dc,
-		const struct dc_validation_set set[],
-		int set_count,
-		struct validate_context *context)
-{
-	int i, j;
-	enum dc_status res = DC_ERROR_UNEXPECTED;
-	bool found = false;
-	int old_stream_count = context->stream_count;
-	struct dc_stream_state *del_streams[MAX_PIPES] = { 0 };
-	struct dc_stream_state *add_streams[MAX_PIPES] = { 0 };
-	int del_streams_count = 0;
-	int add_streams_count = 0;
-
-
-	/* First remove from context all deleted streams */
-	for (i = 0; i < old_stream_count; i++) {
-		struct dc_stream_state *stream = context->streams[i];
-
-		for (j = 0; j < set_count; j++) {
-			if (stream == set[j].stream) {
-				found = true;
-				break;
-			}
-		}
-
-		if (!found)
-			del_streams[del_streams_count++] = stream;
-
-		found = false;
-	}
-
-	/* Now add new ones */
-	for (i = 0; i < set_count; i++) {
-		struct dc_stream_state *stream = set[i].stream;
-
-		for (j = 0; j < old_stream_count; j++) {
-			if (stream == context->streams[j]) {
-				found = true;
-				break;
-			}
-		}
-
-		if (!found)
-			add_streams[add_streams_count++] = stream;
-
-		found = false;
-	}
-
-	for (i = 0; i < del_streams_count; i++)
-		if (!dc_remove_stream_from_ctx(dc, context, del_streams[i]))
-			goto fail;
-
-	for (i = 0; i < add_streams_count; i++)
-		if (!dc_add_stream_to_ctx(dc, context, add_streams[i]))
-			goto fail;
-
-	if (!dc_validate_global_state(dc, set, set_count, context))
-		goto fail;
-
-	res = DC_OK;
-
-fail:
-	if (res != DC_OK) {
-		dm_logger_write(dc->ctx->logger, LOG_WARNING,
-				"%s:resource validation failed, dc_status:%d\n",
-				__func__,
-				res);
-}
-	return res == DC_OK;
-}
-
 bool dc_validate_global_state(
 		struct dc *dc,
 		const struct dc_validation_set set[],

commit 1dc904974eb7deef924650adc5af542878ce2040
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Jul 31 11:29:25 2017 -0400

    drm/amd/display: Per stream validate_context build v2.
    
    Until now new context would start as empty, then populated
    with exsisting pipes + new. Now we start with duplication
    of existing context and then add/delete from the context
    pipes as needed.
    
    This allows to do a per stream resource
    population, start discarding dc_validation_set
    and by this brings DC closer to to DRM.
    
    v2: Add some fixes and rebase.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2b357318f945..f640986c6fd2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -938,7 +938,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				res_ctx->pipe_ctx[i].stream_res.stream_enc) {
+				!res_ctx->pipe_ctx[i].top_pipe) {
 			return &res_ctx->pipe_ctx[i];
 			break;
 		}
@@ -1217,29 +1217,31 @@ bool resource_validate_attach_surfaces(
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
 
-static void set_stream_engine_in_use(
+static void update_stream_engine_usage(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct stream_encoder *stream_enc)
+		struct stream_encoder *stream_enc,
+		bool acquired)
 {
 	int i;
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (pool->stream_enc[i] == stream_enc)
-			res_ctx->is_stream_enc_acquired[i] = true;
+			res_ctx->is_stream_enc_acquired[i] = acquired;
 	}
 }
 
 /* TODO: release audio object */
-static void set_audio_in_use(
+static void update_audio_usage(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct audio *audio)
+		struct audio *audio,
+		bool acquired)
 {
 	int i;
 	for (i = 0; i < pool->audio_count; i++) {
 		if (pool->audios[i] == audio)
-			res_ctx->is_audio_acquired[i] = true;
+			res_ctx->is_audio_acquired[i] = acquired;
 	}
 }
 
@@ -1361,6 +1363,100 @@ bool resource_is_stream_unchanged(
 	return false;
 }
 
+bool dc_add_stream_to_ctx(
+		struct dc *dc,
+		struct validate_context *new_ctx,
+		struct dc_stream_state *stream)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	enum dc_status res;
+
+	if (new_ctx->stream_count >= dc->res_pool->pipe_count) {
+		DC_ERROR("Max streams reached, can add stream %p !\n", stream);
+		return DC_ERROR_UNEXPECTED;
+	}
+
+	new_ctx->streams[new_ctx->stream_count] = stream;
+	dc_stream_retain(stream);
+	new_ctx->stream_count++;
+
+	res = dc->res_pool->funcs->add_stream_to_ctx(dc, new_ctx, stream);
+	if (res != DC_OK)
+		DC_ERROR("Adding stream %p to context failed with err %d!\n", stream, res);
+
+	return res == DC_OK;
+}
+
+bool dc_remove_stream_from_ctx(
+			struct dc *dc,
+			struct validate_context *new_ctx,
+			struct dc_stream_state *stream)
+{
+	int i, j;
+	struct dc_context *dc_ctx = dc->ctx;
+	struct pipe_ctx *del_pipe = NULL;
+
+	/*TODO MPO to remove extra pipe or in surface remove ?*/
+
+	/* Release primary and secondary pipe (if exsist) */
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (new_ctx->res_ctx.pipe_ctx[i].stream == stream) {
+			del_pipe = &new_ctx->res_ctx.pipe_ctx[i];
+
+			if (del_pipe->stream_res.stream_enc)
+				update_stream_engine_usage(
+						&new_ctx->res_ctx,
+						dc->res_pool,
+						del_pipe->stream_res.stream_enc,
+						false);
+
+			if (del_pipe->stream_res.audio)
+				update_audio_usage(
+					&new_ctx->res_ctx,
+					dc->res_pool,
+					del_pipe->stream_res.audio,
+					false);
+
+			memset(del_pipe, 0, sizeof(*del_pipe));
+		}
+	}
+
+	if (!del_pipe) {
+		DC_ERROR("Pipe not found for stream %p !\n", stream);
+		return DC_ERROR_UNEXPECTED;
+	}
+
+	for (i = 0; i < new_ctx->stream_count; i++)
+		if (new_ctx->streams[i] == stream)
+			break;
+
+	if (new_ctx->streams[i] != stream) {
+		DC_ERROR("Context doesn't have stream %p !\n", stream);
+		return DC_ERROR_UNEXPECTED;
+	}
+
+	dc_stream_release(new_ctx->streams[i]);
+	new_ctx->stream_count--;
+
+	/*TODO move into dc_remove_surface_from_ctx	?*/
+	for (j = 0; j < new_ctx->stream_status[i].plane_count; j++)
+		dc_plane_state_release(new_ctx->stream_status[i].plane_states[j]);
+
+	/* Trim back arrays */
+	for (; i < new_ctx->stream_count; i++) {
+		new_ctx->streams[i] = new_ctx->streams[i + 1];
+		new_ctx->stream_status[i] = new_ctx->stream_status[i + 1];
+	}
+
+	new_ctx->streams[new_ctx->stream_count] = NULL;
+	memset(
+			&new_ctx->stream_status[new_ctx->stream_count],
+			0,
+			sizeof(new_ctx->stream_status[0]));
+
+	return DC_OK;
+}
+
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
@@ -1440,15 +1536,16 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 enum dc_status resource_map_pool_resources(
 		const struct dc  *dc,
 		struct validate_context *context,
-		struct validate_context *old_context)
+		struct dc_stream_state *stream)
 {
 	const struct resource_pool *pool = dc->res_pool;
-	int i, j;
-
-	for (i = 0; old_context && i < context->stream_count; i++) {
-		struct dc_stream_state *stream = context->streams[i];
+	int i;
+	struct dc_context *dc_ctx = dc->ctx;
+	struct pipe_ctx *pipe_ctx = NULL;
+	int pipe_idx = -1;
 
-		if (!resource_is_stream_unchanged(old_context, stream)) {
+	/* TODO Check if this is needed */
+	/*if (!resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
 				stream->bit_depth_params =
 						old_context->streams[i]->bit_depth_params;
@@ -1456,119 +1553,228 @@ enum dc_status resource_map_pool_resources(
 				continue;
 			}
 		}
+	*/
 
-		/* mark resources used for stream that is already active */
-		for (j = 0; j < pool->pipe_count; j++) {
-			struct pipe_ctx *pipe_ctx =
-				&context->res_ctx.pipe_ctx[j];
-			const struct pipe_ctx *old_pipe_ctx =
-					&old_context->res_ctx.pipe_ctx[j];
-
-			if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
-				continue;
+	/* acquire new resources */
+	pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
 
-			if (old_pipe_ctx->top_pipe)
-				continue;
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	if (pipe_idx < 0)
+		acquire_first_split_pipe(&context->res_ctx, pool, stream);
+#endif
+	if (pipe_idx < 0)
+		return DC_NO_CONTROLLER_RESOURCE;
+
+	pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
+
+	pipe_ctx->stream_res.stream_enc =
+		find_first_free_match_stream_enc_for_link(
+			&context->res_ctx, pool, stream);
+
+	if (!pipe_ctx->stream_res.stream_enc)
+		return DC_NO_STREAM_ENG_RESOURCE;
+
+	update_stream_engine_usage(
+		&context->res_ctx, pool,
+		pipe_ctx->stream_res.stream_enc,
+		true);
+
+	/* TODO: Add check if ASIC support and EDID audio */
+	if (!stream->sink->converter_disable_audio &&
+	    dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
+	    stream->audio_info.mode_count) {
+		pipe_ctx->stream_res.audio = find_first_free_audio(
+		&context->res_ctx, pool);
+
+		/*
+		 * Audio assigned in order first come first get.
+		 * There are asics which has number of audio
+		 * resources less then number of pipes
+		 */
+		if (pipe_ctx->stream_res.audio)
+			update_audio_usage(&context->res_ctx, pool,
+					   pipe_ctx->stream_res.audio, true);
+	}
 
-			pipe_ctx->stream = stream;
-			copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
+	for (i = 0; i < context->stream_count; i++)
+		if (context->streams[i] == stream) {
+			context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
+			return DC_OK;
+		}
 
-			/* Split pipe resource, do not acquire back end */
-			if (!pipe_ctx->stream_res.stream_enc)
-				continue;
+	DC_ERROR("Stream %p not found in new ctx!\n", stream);
+	return DC_ERROR_UNEXPECTED;
+}
 
-			set_stream_engine_in_use(
-				&context->res_ctx, pool,
-				pipe_ctx->stream_res.stream_enc);
+/* first stream in the context is used to populate the rest */
+void validate_guaranteed_copy_streams(
+		struct validate_context *context,
+		int max_streams)
+{
+	int i;
 
-			/* Switch to dp clock source only if there is
-			 * no non dp stream that shares the same timing
-			 * with the dp stream.
-			 */
-			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
-				!find_pll_sharable_stream(stream, context))
-				pipe_ctx->clock_source = pool->dp_clock_source;
+	for (i = 1; i < max_streams; i++) {
+		context->streams[i] = context->streams[0];
 
-			resource_reference_clock_source(
-				&context->res_ctx, pool,
-				pipe_ctx->clock_source);
+		copy_pipe_ctx(&context->res_ctx.pipe_ctx[0],
+			      &context->res_ctx.pipe_ctx[i]);
+		context->res_ctx.pipe_ctx[i].stream =
+				context->res_ctx.pipe_ctx[0].stream;
 
-			set_audio_in_use(&context->res_ctx, pool,
-					pipe_ctx->stream_res.audio);
-		}
+		dc_stream_retain(context->streams[i]);
+		context->stream_count++;
 	}
+}
 
-	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream_state *stream = context->streams[i];
-		struct pipe_ctx *pipe_ctx = NULL;
-		int pipe_idx = -1;
+void dc_resource_validate_ctx_copy_construct_current(
+		const struct dc *dc,
+		struct validate_context *dst_ctx)
+{
+	dc_resource_validate_ctx_copy_construct(dc->current_context, dst_ctx);
+}
 
-		if (old_context && resource_is_stream_unchanged(old_context, stream))
-			continue;
-		/* acquire new resources */
-		pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-		if (pipe_idx < 0)
-			acquire_first_split_pipe(&context->res_ctx, pool, stream);
-#endif
-		if (pipe_idx < 0)
-			return DC_NO_CONTROLLER_RESOURCE;
+bool dc_validate_with_context(
+		struct dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context)
+{
+	int i, j;
+	enum dc_status res = DC_ERROR_UNEXPECTED;
+	bool found = false;
+	int old_stream_count = context->stream_count;
+	struct dc_stream_state *del_streams[MAX_PIPES] = { 0 };
+	struct dc_stream_state *add_streams[MAX_PIPES] = { 0 };
+	int del_streams_count = 0;
+	int add_streams_count = 0;
 
-		pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
 
-		pipe_ctx->stream_res.stream_enc =
-			find_first_free_match_stream_enc_for_link(
-				&context->res_ctx, pool, stream);
+	/* First remove from context all deleted streams */
+	for (i = 0; i < old_stream_count; i++) {
+		struct dc_stream_state *stream = context->streams[i];
+
+		for (j = 0; j < set_count; j++) {
+			if (stream == set[j].stream) {
+				found = true;
+				break;
+			}
+		}
 
-		if (!pipe_ctx->stream_res.stream_enc)
-			return DC_NO_STREAM_ENG_RESOURCE;
+		if (!found)
+			del_streams[del_streams_count++] = stream;
 
-		set_stream_engine_in_use(
-			&context->res_ctx, pool,
-			pipe_ctx->stream_res.stream_enc);
+		found = false;
+	}
 
-		/* TODO: Add check if ASIC support and EDID audio */
-		if (!stream->sink->converter_disable_audio &&
-			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
-			stream->audio_info.mode_count) {
-			pipe_ctx->stream_res.audio = find_first_free_audio(
-				&context->res_ctx, pool);
+	/* Now add new ones */
+	for (i = 0; i < set_count; i++) {
+		struct dc_stream_state *stream = set[i].stream;
 
-			/*
-			 * Audio assigned in order first come first get.
-			 * There are asics which has number of audio
-			 * resources less then number of pipes
-			 */
-			if (pipe_ctx->stream_res.audio)
-				set_audio_in_use(
-					&context->res_ctx, pool,
-					pipe_ctx->stream_res.audio);
+		for (j = 0; j < old_stream_count; j++) {
+			if (stream == context->streams[j]) {
+				found = true;
+				break;
+			}
 		}
 
-		context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
+		if (!found)
+			add_streams[add_streams_count++] = stream;
+
+		found = false;
 	}
 
-	return DC_OK;
+	for (i = 0; i < del_streams_count; i++)
+		if (!dc_remove_stream_from_ctx(dc, context, del_streams[i]))
+			goto fail;
+
+	for (i = 0; i < add_streams_count; i++)
+		if (!dc_add_stream_to_ctx(dc, context, add_streams[i]))
+			goto fail;
+
+	if (!dc_validate_global_state(dc, set, set_count, context))
+		goto fail;
+
+	res = DC_OK;
+
+fail:
+	if (res != DC_OK) {
+		dm_logger_write(dc->ctx->logger, LOG_WARNING,
+				"%s:resource validation failed, dc_status:%d\n",
+				__func__,
+				res);
+}
+	return res == DC_OK;
 }
 
-/* first stream in the context is used to populate the rest */
-void validate_guaranteed_copy_streams(
-		struct validate_context *context,
-		int max_streams)
+bool dc_validate_global_state(
+		struct dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *new_ctx)
 {
-	int i;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	struct dc_context *dc_ctx = dc->ctx;
+	struct validate_context *old_context = dc->current_context;
+	int i, j;
 
-	for (i = 1; i < max_streams; i++) {
-		context->streams[i] = context->streams[0];
+	if (dc->res_pool->funcs->validate_global &&
+	    dc->res_pool->funcs->validate_global(dc, set, set_count,
+						 old_context, new_ctx) != DC_OK)
+		return false;
 
-		copy_pipe_ctx(&context->res_ctx.pipe_ctx[0],
-			      &context->res_ctx.pipe_ctx[i]);
-		context->res_ctx.pipe_ctx[i].stream =
-				context->res_ctx.pipe_ctx[0].stream;
+	/* TODO without this SWDEV-114774 brakes */
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[i];
 
-		dc_stream_retain(context->streams[i]);
-		context->stream_count++;
+		if (pipe_ctx->top_pipe)
+			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
+	}
+
+	for (i = 0; new_ctx && i < new_ctx->stream_count; i++) {
+		struct dc_stream_state *stream = new_ctx->streams[i];
+
+		for (j = 0; j < dc->res_pool->pipe_count; j++) {
+			struct pipe_ctx *pipe_ctx = &new_ctx->res_ctx.pipe_ctx[j];
+
+			if (pipe_ctx->stream != stream)
+				continue;
+
+			/* Switch to dp clock source only if there is
+			 * no non dp stream that shares the same timing
+			 * with the dp stream.
+			 */
+			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
+				!find_pll_sharable_stream(stream, new_ctx)) {
+
+				resource_unreference_clock_source(
+						&new_ctx->res_ctx,
+						dc->res_pool,
+						&pipe_ctx->clock_source);
+				pipe_ctx->clock_source = dc->res_pool->dp_clock_source;
+				resource_reference_clock_source(
+						&new_ctx->res_ctx,
+						dc->res_pool,
+						 pipe_ctx->clock_source);
+			}
+		}
+	}
+
+	/*TODO This should be ok */
+	/* Split pipe resource, do not acquire back end */
+
+	if (!resource_validate_attach_surfaces(
+			set, set_count, old_context, new_ctx, dc->res_pool)) {
+		DC_ERROR("Failed to attach surface to stream!\n");
+		return DC_FAIL_ATTACH_SURFACES;
 	}
+
+	result = resource_build_scaling_params_for_context(dc, new_ctx);
+
+	if (result == DC_OK)
+		if (!dc->res_pool->funcs->validate_bandwidth(dc, new_ctx))
+			result = DC_FAIL_BANDWIDTH_VALIDATE;
+
+	return result;
 }
 
 static void patch_gamut_packet_checksum(
@@ -2318,54 +2524,40 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 enum dc_status resource_map_clock_resources(
 		const struct dc  *dc,
 		struct validate_context *context,
-		struct validate_context *old_context)
+		struct dc_stream_state *stream)
 {
-	int i, j;
-	const struct resource_pool *pool = dc->res_pool;
-
 	/* acquire new resources */
-	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream_state *stream = context->streams[i];
-
-		if (old_context && resource_is_stream_unchanged(old_context, stream))
-			continue;
+	const struct resource_pool *pool = dc->res_pool;
+	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(
+				&context->res_ctx, stream);
 
-		for (j = 0; j < MAX_PIPES; j++) {
-			struct pipe_ctx *pipe_ctx =
-				&context->res_ctx.pipe_ctx[j];
+	if (!pipe_ctx)
+		return DC_ERROR_UNEXPECTED;
 
-			if (context->res_ctx.pipe_ctx[j].stream != stream)
-				continue;
+	if (dc_is_dp_signal(pipe_ctx->stream->signal)
+		|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
+		pipe_ctx->clock_source = pool->dp_clock_source;
+	else {
+		pipe_ctx->clock_source = NULL;
 
-			if (dc_is_dp_signal(pipe_ctx->stream->signal)
-				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
-				pipe_ctx->clock_source = pool->dp_clock_source;
-			else {
-				pipe_ctx->clock_source = NULL;
-
-				if (!dc->config.disable_disp_pll_sharing)
-					resource_find_used_clk_src_for_sharing(
-						&context->res_ctx,
-						pipe_ctx);
-
-				if (pipe_ctx->clock_source == NULL)
-					pipe_ctx->clock_source =
-						dc_resource_find_first_free_pll(
-							&context->res_ctx,
-							pool);
-			}
+		if (!dc->config.disable_disp_pll_sharing)
+			resource_find_used_clk_src_for_sharing(
+				&context->res_ctx,
+				pipe_ctx);
 
-			if (pipe_ctx->clock_source == NULL)
-				return DC_NO_CLOCK_SOURCE_RESOURCE;
+		if (pipe_ctx->clock_source == NULL)
+			pipe_ctx->clock_source =
+				dc_resource_find_first_free_pll(
+					&context->res_ctx,
+					pool);
+	}
 
-			resource_reference_clock_source(
-				&context->res_ctx, pool,
-				pipe_ctx->clock_source);
+	if (pipe_ctx->clock_source == NULL)
+		return DC_NO_CLOCK_SOURCE_RESOURCE;
 
-			/* only one cs per stream regardless of mpo */
-			break;
-		}
-	}
+	resource_reference_clock_source(
+		&context->res_ctx, pool,
+		pipe_ctx->clock_source);
 
 	return DC_OK;
 }

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d2b8f27416d6..2b357318f945 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -92,7 +92,7 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 }
 
 struct resource_pool *dc_create_resource_pool(
-				struct core_dc *dc,
+				struct dc  *dc,
 				int num_virtual_links,
 				enum dce_version dc_version,
 				struct hw_asic_id asic_id)
@@ -153,7 +153,7 @@ struct resource_pool *dc_create_resource_pool(
 	return res_pool;
 }
 
-void dc_destroy_resource_pool(struct core_dc *dc)
+void dc_destroy_resource_pool(struct dc  *dc)
 {
 	if (dc) {
 		if (dc->res_pool)
@@ -193,7 +193,7 @@ static void update_num_audio(
 
 bool resource_construct(
 	unsigned int num_virtual_links,
-	struct core_dc *dc,
+	struct dc  *dc,
 	struct resource_pool *pool,
 	const struct resource_create_funcs *create_funcs)
 {
@@ -892,7 +892,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 
 enum dc_status resource_build_scaling_params_for_context(
-	const struct core_dc *dc,
+	const struct dc  *dc,
 	struct validate_context *context)
 {
 	int i;
@@ -1438,7 +1438,7 @@ static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 }
 
 enum dc_status resource_map_pool_resources(
-		const struct core_dc *dc,
+		const struct dc  *dc,
 		struct validate_context *context,
 		struct validate_context *old_context)
 {
@@ -2316,7 +2316,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 }
 
 enum dc_status resource_map_clock_resources(
-		const struct core_dc *dc,
+		const struct dc  *dc,
 		struct validate_context *context,
 		struct validate_context *old_context)
 {
@@ -2343,7 +2343,7 @@ enum dc_status resource_map_clock_resources(
 			else {
 				pipe_ctx->clock_source = NULL;
 
-				if (!dc->public.config.disable_disp_pll_sharing)
+				if (!dc->config.disable_disp_pll_sharing)
 					resource_find_used_clk_src_for_sharing(
 						&context->res_ctx,
 						pipe_ctx);
@@ -2515,9 +2515,9 @@ void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream)
+bool dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc  *core_dc = dc;
 	struct dc_context *dc_ctx = core_dc->ctx;
 	struct dc_link *link = stream->sink->link;
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
@@ -2547,9 +2547,9 @@ bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream)
 	return res == DC_OK;
 }
 
-bool dc_validate_plane(const struct dc *dc, const struct dc_plane_state *plane_state)
+bool dc_validate_plane(struct dc *dc, const struct dc_plane_state *plane_state)
 {
-	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc *core_dc = dc;
 
 	/* TODO For now validates pixel format only */
 	if (core_dc->res_pool->funcs->validate_plane)

commit 503a7c6f2518be909fa61276ee002846524b588b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Aug 3 10:19:58 2017 -0400

    drm/amd/display: Use function pointer for update_plane_addr
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 0d33e179d9f7..d2b8f27416d6 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -132,7 +132,7 @@ struct resource_pool *dc_create_resource_pool(
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 	case DCN_VERSION_1_0:
 		res_pool = dcn10_create_resource_pool(
-			num_virtual_links, dc);
+				num_virtual_links, dc);
 		break;
 #endif
 

commit b8e9eb7259f744fdc2e34f008e4af211ce0df19a
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Aug 9 14:03:34 2017 -0400

    drm/amd/display: fix eDP bootup/S4 backlight on
    
    also pass-in correct dispclk tor DMCU
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1d69bd25e07b..0d33e179d9f7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -169,16 +169,14 @@ static void update_num_audio(
 	unsigned int *num_audio,
 	struct audio_support *aud_support)
 {
+	aud_support->dp_audio = true;
+	aud_support->hdmi_audio_native = false;
+	aud_support->hdmi_audio_on_dongle = false;
+
 	if (straps->hdmi_disable == 0) {
-		aud_support->hdmi_audio_native = true;
-		aud_support->hdmi_audio_on_dongle = true;
-		aud_support->dp_audio = true;
-	} else {
 		if (straps->dc_pinstraps_audio & 0x2) {
 			aud_support->hdmi_audio_on_dongle = true;
-			aud_support->dp_audio = true;
-		} else {
-			aud_support->dp_audio = true;
+			aud_support->hdmi_audio_native = true;
 		}
 	}
 

commit e8cd26434df0cd8d97f31aeb4399afcdc37fcfda
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Mon Jul 31 17:10:44 2017 -0400

    drm/amd/display: Use atomic types for ref_count
    
    Current ref_count inc/dec is not guarded by locks which leads to
    a raced condition where two threads try to access the variable
    at the same time. In this case, both might act on the same cached
    value and inc/dec from the same value, rather than inc/dec by 2.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 56a85c80131d..1d69bd25e07b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2238,7 +2238,7 @@ void dc_resource_validate_ctx_copy_construct(
 		struct validate_context *dst_ctx)
 {
 	int i, j;
-	int ref_count = dst_ctx->ref_count;
+	atomic_t ref_count = dst_ctx->ref_count;
 
 	*dst_ctx = *src_ctx;
 

commit 7992a6290a79afc1568c873d434f39234f7d3e26
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Thu Aug 10 14:39:51 2017 -0400

    drm/amd/disply/dc: add resource support for DCE8 APUs (v2)
    
    Add the appropriate resources for APUs:
    KV:    4 pipes, 7 dig, 3 PPLLs
    KB/ML: 2 pipes, 6 dig, 2 PPLLs
    
    v2: rebase changes
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ee7a393b2b00..56a85c80131d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -101,9 +101,15 @@ struct resource_pool *dc_create_resource_pool(
 
 	switch (dc_version) {
 	case DCE_VERSION_8_0:
+		res_pool = dce80_create_resource_pool(
+			num_virtual_links, dc);
+		break;
 	case DCE_VERSION_8_1:
+		res_pool = dce81_create_resource_pool(
+			num_virtual_links, dc);
+		break;
 	case DCE_VERSION_8_3:
-		res_pool = dce80_create_resource_pool(
+		res_pool = dce83_create_resource_pool(
 			num_virtual_links, dc);
 		break;
 	case DCE_VERSION_10_0:

commit ebfdf0d0770bd20e9baff3750b5103d6b7fa21c3
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Thu Aug 10 14:39:50 2017 -0400

    drm/amd/display/dc: add DCE_VERSION for DCE8 APUs
    
    DCE 8.1 = Kaveri
    DCE 8.3 = Kabini/Mullins
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 30237f049c99..ee7a393b2b00 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -50,9 +50,16 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 	switch (asic_id.chip_family) {
 
 	case FAMILY_CI:
-	case FAMILY_KV:
 		dc_version = DCE_VERSION_8_0;
 		break;
+	case FAMILY_KV:
+		if (ASIC_REV_IS_KALINDI(asic_id.hw_internal_rev) ||
+		    ASIC_REV_IS_BHAVANI(asic_id.hw_internal_rev) ||
+		    ASIC_REV_IS_GODAVARI(asic_id.hw_internal_rev))
+			dc_version = DCE_VERSION_8_3;
+		else
+			dc_version = DCE_VERSION_8_1;
+		break;
 	case FAMILY_CZ:
 		dc_version = DCE_VERSION_11_0;
 		break;
@@ -94,6 +101,8 @@ struct resource_pool *dc_create_resource_pool(
 
 	switch (dc_version) {
 	case DCE_VERSION_8_0:
+	case DCE_VERSION_8_1:
+	case DCE_VERSION_8_3:
 		res_pool = dce80_create_resource_pool(
 			num_virtual_links, dc);
 		break;

commit 96c50c0d0cead772001fd4ab1861594c059e7e0f
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 15:58:26 2017 -0400

    drm/amd/display: Move encoder_info_frame to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipes->encoder_info_frame/pipes->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->encoder_info_frame/pipe_with_clk_src->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/ctx->encoder_info_frame->/ctx->stream_res\.encoder_info_frame->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe->encoder_info_frame/pipe->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_ctx->encoder_info_frame/pipe_ctx->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.encoder_info_frame/pipe_ctx\[pipe_offset\]\.stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->encoder_info_frame/grouped_pipes\[i\]->stream_^Cs\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->encoder_info_frame/grouped_pipes\[0\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->encoder_info_frame/grouped_pipes\[1\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->encoder_info_frame/pipe_ctx\[i\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->encoder_info_frame/pipe_ctx_old->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->encoder_info_frame/pipe_set\[j\]->stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.encoder_info_frame/pipe_ctx\[i\]\.stream_res\.encoder_info_frame/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.encoder_info_frame/pipes\[i\]\.stream_res\.encoder_info_frame/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 5c1d3c568090..30237f049c99 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2267,7 +2267,7 @@ struct clock_source *dc_resource_find_first_free_pll(
 void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 {
 	enum signal_type signal = SIGNAL_TYPE_NONE;
-	struct encoder_info_frame *info = &pipe_ctx->encoder_info_frame;
+	struct encoder_info_frame *info = &pipe_ctx->stream_res.encoder_info_frame;
 
 	/* default all packets to invalid */
 	info->avi.valid = false;

commit afaacef482759215681ad0a8c6a8b60cc7d29592
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:59:17 2017 -0400

    drm/amd/display: Move audio to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->audio/pipes->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/pipe_with_clk_src->audio/pipe_with_clk_src->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->audio->/ctx->stream_res\.audio->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->audio/pipe->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->audio/pipe_ctx->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.audio/pipe_ctx\[pipe_offset\]\.stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->audio/grouped_pipes\[i\]->stream_^Cs\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->audio/grouped_pipes\[0\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->audio/grouped_pipes\[1\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->audio/pipe_ctx\[i\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->audio/pipe_ctx_old->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->audio/pipe_set\[j\]->stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.audio/pipe_ctx\[i\]\.stream_res\.audio/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.audio/pipes\[i\]\.stream_res\.audio/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 13feff1003d8..5c1d3c568090 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1097,7 +1097,7 @@ bool resource_attach_surfaces_to_context(
 			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
 			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
 			free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
-			free_pipe->audio = tail_pipe->audio;
+			free_pipe->stream_res.audio = tail_pipe->stream_res.audio;
 			free_pipe->clock_source = tail_pipe->clock_source;
 			free_pipe->top_pipe = tail_pipe;
 			tail_pipe->bottom_pipe = free_pipe;
@@ -1481,7 +1481,7 @@ enum dc_status resource_map_pool_resources(
 				pipe_ctx->clock_source);
 
 			set_audio_in_use(&context->res_ctx, pool,
-					pipe_ctx->audio);
+					pipe_ctx->stream_res.audio);
 		}
 	}
 
@@ -1518,7 +1518,7 @@ enum dc_status resource_map_pool_resources(
 		if (!stream->sink->converter_disable_audio &&
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 			stream->audio_info.mode_count) {
-			pipe_ctx->audio = find_first_free_audio(
+			pipe_ctx->stream_res.audio = find_first_free_audio(
 				&context->res_ctx, pool);
 
 			/*
@@ -1526,10 +1526,10 @@ enum dc_status resource_map_pool_resources(
 			 * There are asics which has number of audio
 			 * resources less then number of pipes
 			 */
-			if (pipe_ctx->audio)
+			if (pipe_ctx->stream_res.audio)
 				set_audio_in_use(
 					&context->res_ctx, pool,
-					pipe_ctx->audio);
+					pipe_ctx->stream_res.audio);
 		}
 
 		context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
@@ -2375,7 +2375,7 @@ bool pipe_need_reprogram(
 	if (pipe_ctx_old->stream->signal != pipe_ctx->stream->signal)
 		return true;
 
-	if (pipe_ctx_old->audio != pipe_ctx->audio)
+	if (pipe_ctx_old->stream_res.audio != pipe_ctx->stream_res.audio)
 		return true;
 
 	if (pipe_ctx_old->clock_source != pipe_ctx->clock_source

commit 8e9c4c8cf35ff23aafc69f9ef4c9cc471dac4094
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 14:36:12 2017 -0400

    drm/amd/display: Move stream_enc to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->stream_enc/pipes->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->stream_enc->/ctx->stream_res\.stream_enc->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->stream_enc/pipe->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->stream_enc/pipe_ctx->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.stream_enc/pipe_ctx\[pipe_offset\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[i\]->stream_enc/grouped_pipes\[i\]->stream_^Cs\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[0\]->stream_enc/grouped_pipes\[0\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/grouped_pipes\[1\]->stream_enc/grouped_pipes\[1\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]->stream_enc/pipe_ctx\[i\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx_old->stream_enc/pipe_ctx_old->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_set\[j\]->stream_enc/pipe_set\[j\]->stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[i\]\.stream_enc/pipe_ctx\[i\]\.stream_res\.stream_enc/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipes\[i\]\.stream_enc/pipes\[i\]\.stream_res\.stream_enc/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 5326713bf3fb..13feff1003d8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -925,7 +925,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				res_ctx->pipe_ctx[i].stream_enc) {
+				res_ctx->pipe_ctx[i].stream_res.stream_enc) {
 			return &res_ctx->pipe_ctx[i];
 			break;
 		}
@@ -1096,7 +1096,7 @@ bool resource_attach_surfaces_to_context(
 		if (tail_pipe) {
 			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
 			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
-			free_pipe->stream_enc = tail_pipe->stream_enc;
+			free_pipe->stream_res.stream_enc = tail_pipe->stream_res.stream_enc;
 			free_pipe->audio = tail_pipe->audio;
 			free_pipe->clock_source = tail_pipe->clock_source;
 			free_pipe->top_pipe = tail_pipe;
@@ -1461,12 +1461,12 @@ enum dc_status resource_map_pool_resources(
 			copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
 
 			/* Split pipe resource, do not acquire back end */
-			if (!pipe_ctx->stream_enc)
+			if (!pipe_ctx->stream_res.stream_enc)
 				continue;
 
 			set_stream_engine_in_use(
 				&context->res_ctx, pool,
-				pipe_ctx->stream_enc);
+				pipe_ctx->stream_res.stream_enc);
 
 			/* Switch to dp clock source only if there is
 			 * no non dp stream that shares the same timing
@@ -1503,16 +1503,16 @@ enum dc_status resource_map_pool_resources(
 
 		pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
 
-		pipe_ctx->stream_enc =
+		pipe_ctx->stream_res.stream_enc =
 			find_first_free_match_stream_enc_for_link(
 				&context->res_ctx, pool, stream);
 
-		if (!pipe_ctx->stream_enc)
+		if (!pipe_ctx->stream_res.stream_enc)
 			return DC_NO_STREAM_ENG_RESOURCE;
 
 		set_stream_engine_in_use(
 			&context->res_ctx, pool,
-			pipe_ctx->stream_enc);
+			pipe_ctx->stream_res.stream_enc);
 
 		/* TODO: Add check if ASIC support and EDID audio */
 		if (!stream->sink->converter_disable_audio &&
@@ -2382,7 +2382,7 @@ bool pipe_need_reprogram(
 			&& pipe_ctx_old->stream != pipe_ctx->stream)
 		return true;
 
-	if (pipe_ctx_old->stream_enc != pipe_ctx->stream_enc)
+	if (pipe_ctx_old->stream_res.stream_enc != pipe_ctx->stream_res.stream_enc)
 		return true;
 
 	if (is_timing_changed(pipe_ctx_old->stream, pipe_ctx->stream))

commit 6b670fa965b620bf0131a0a339a388a0581bc466
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:59:26 2017 -0400

    drm/amd/display: Move TG to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->tg/pipes->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->tg->/ctx->stream_res\.tg->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->tg/pipe->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->tg/pipe_ctx->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i \
    's/pipe_ctx\[pipe_offset\]\.tg/pipe_ctx\[pipe_offset\]\.stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[i\]->tg/grouped_pipes\[i\]->stream_^Cs\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[0\]->tg/grouped_pipes\[0\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i
    's/grouped_pipes\[1\]->tg/grouped_pipes\[1\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]->tg/pipe_ctx\[i\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx_old->tg/pipe_ctx_old->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_set\[j\]->tg/pipe_set\[j\]->stream_res\.tg/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx\[i\]\.tg/pipe_ctx\[i\]\.stream_res\.tg/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ba529f8b24e8..5326713bf3fb 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1011,7 +1011,7 @@ static int acquire_first_split_pipe(
 				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
 
 			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->stream_res.tg = pool->timing_generators[i];
 			pipe_ctx->plane_res.mi = pool->mis[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
@@ -1094,7 +1094,7 @@ bool resource_attach_surfaces_to_context(
 		free_pipe->plane_state = plane_state;
 
 		if (tail_pipe) {
-			free_pipe->tg = tail_pipe->tg;
+			free_pipe->stream_res.tg = tail_pipe->stream_res.tg;
 			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
 			free_pipe->stream_enc = tail_pipe->stream_enc;
 			free_pipe->audio = tail_pipe->audio;
@@ -1241,7 +1241,7 @@ static int acquire_first_free_pipe(
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->stream_res.tg = pool->timing_generators[i];
 			pipe_ctx->plane_res.mi = pool->mis[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
@@ -1532,7 +1532,7 @@ enum dc_status resource_map_pool_resources(
 					pipe_ctx->audio);
 		}
 
-		context->stream_status[i].primary_otg_inst = pipe_ctx->tg->inst;
+		context->stream_status[i].primary_otg_inst = pipe_ctx->stream_res.tg->inst;
 	}
 
 	return DC_OK;

commit a6a6cb349e39ef23a341a17752eebf69a5c0d7ff
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 13:55:28 2017 -0400

    drm/amd/display: Move OPP to stream_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipes->opp/pipes->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/ctx->opp->/ctx->stream_res\.opp->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe->opp/pipe->stream_res\.opp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/pipe_ctx->opp/pipe_ctx->stream_res\.opp/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7270f0de9598..ba529f8b24e8 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1015,7 +1015,7 @@ static int acquire_first_split_pipe(
 			pipe_ctx->plane_res.mi = pool->mis[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
-			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->stream_res.opp = pool->opps[i];
 			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
@@ -1095,7 +1095,7 @@ bool resource_attach_surfaces_to_context(
 
 		if (tail_pipe) {
 			free_pipe->tg = tail_pipe->tg;
-			free_pipe->opp = tail_pipe->opp;
+			free_pipe->stream_res.opp = tail_pipe->stream_res.opp;
 			free_pipe->stream_enc = tail_pipe->stream_enc;
 			free_pipe->audio = tail_pipe->audio;
 			free_pipe->clock_source = tail_pipe->clock_source;
@@ -1245,7 +1245,7 @@ static int acquire_first_free_pipe(
 			pipe_ctx->plane_res.mi = pool->mis[i];
 			pipe_ctx->plane_res.ipp = pool->ipps[i];
 			pipe_ctx->plane_res.xfm = pool->transforms[i];
-			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->stream_res.opp = pool->opps[i];
 			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 

commit 86a66c4eb7365c96230bca218634439f7b057306
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:55:55 2017 -0400

    drm/amd/display: Move mi, ipp, xfm to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.mi/\.plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->mi/->plane_res.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.ipp/\.plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->ipp/->plane_res.ipp/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.xfm/\.plane_res.xfm/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->xfm/->plane_res.xfm/g'
    
    To clean up bad renames:
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.min/\.min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.min/->min/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mic/->mic/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mis/\.mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mid/->mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.mid/\.mid/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->plane_res\.mis/->mis/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.plane_res\.ipps/\.ipps/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mpcc_cfg\.plane_res\.mi/mpcc_cfg\.mi/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/mi->plane_res\./mi->/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/cfg->plane_res\./cfg->/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 84a15a999117..7270f0de9598 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -845,15 +845,15 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable;
 
 	/* Taps calculations */
-	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+	res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
+		pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
 		pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
 
-		res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-			pipe_ctx->xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
+		res = pipe_ctx->plane_res.xfm->funcs->transform_get_optimal_number_of_taps(
+			pipe_ctx->plane_res.xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -1012,9 +1012,9 @@ static int acquire_first_split_pipe(
 
 			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
 			pipe_ctx->tg = pool->timing_generators[i];
-			pipe_ctx->mi = pool->mis[i];
-			pipe_ctx->ipp = pool->ipps[i];
-			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->plane_res.mi = pool->mis[i];
+			pipe_ctx->plane_res.ipp = pool->ipps[i];
+			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->opp = pool->opps[i];
 			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
@@ -1242,9 +1242,9 @@ static int acquire_first_free_pipe(
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
 			pipe_ctx->tg = pool->timing_generators[i];
-			pipe_ctx->mi = pool->mis[i];
-			pipe_ctx->ipp = pool->ipps[i];
-			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->plane_res.mi = pool->mis[i];
+			pipe_ctx->plane_res.ipp = pool->ipps[i];
+			pipe_ctx->plane_res.xfm = pool->transforms[i];
 			pipe_ctx->opp = pool->opps[i];
 			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;

commit 6702a9ac53f88a373a9969b4dee292f4c5f023f5
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sun Jul 30 11:51:21 2017 -0400

    drm/amd/display: Move scl_data to plane_res
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/\.scl_data/\.plane_res.scl_data/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/->scl_data/->plane_res.scl_data/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4eef400cb551..84a15a999117 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -432,7 +432,7 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	struct scaler_data *data = &pipe_ctx->scl_data;
+	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
 	struct rect surf_src = plane_state->src_rect;
 	struct rect clip = { 0 };
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
@@ -539,53 +539,53 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
-	pipe_ctx->scl_data.recout.x = stream->dst.x;
+	pipe_ctx->plane_res.scl_data.recout.x = stream->dst.x;
 	if (stream->src.x < surf_clip.x)
-		pipe_ctx->scl_data.recout.x += (surf_clip.x
+		pipe_ctx->plane_res.scl_data.recout.x += (surf_clip.x
 			- stream->src.x) * stream->dst.width
 						/ stream->src.width;
 
-	pipe_ctx->scl_data.recout.width = surf_clip.width *
+	pipe_ctx->plane_res.scl_data.recout.width = surf_clip.width *
 			stream->dst.width / stream->src.width;
-	if (pipe_ctx->scl_data.recout.width + pipe_ctx->scl_data.recout.x >
+	if (pipe_ctx->plane_res.scl_data.recout.width + pipe_ctx->plane_res.scl_data.recout.x >
 			stream->dst.x + stream->dst.width)
-		pipe_ctx->scl_data.recout.width =
+		pipe_ctx->plane_res.scl_data.recout.width =
 			stream->dst.x + stream->dst.width
-						- pipe_ctx->scl_data.recout.x;
+						- pipe_ctx->plane_res.scl_data.recout.x;
 
-	pipe_ctx->scl_data.recout.y = stream->dst.y;
+	pipe_ctx->plane_res.scl_data.recout.y = stream->dst.y;
 	if (stream->src.y < surf_clip.y)
-		pipe_ctx->scl_data.recout.y += (surf_clip.y
+		pipe_ctx->plane_res.scl_data.recout.y += (surf_clip.y
 			- stream->src.y) * stream->dst.height
 						/ stream->src.height;
 
-	pipe_ctx->scl_data.recout.height = surf_clip.height *
+	pipe_ctx->plane_res.scl_data.recout.height = surf_clip.height *
 			stream->dst.height / stream->src.height;
-	if (pipe_ctx->scl_data.recout.height + pipe_ctx->scl_data.recout.y >
+	if (pipe_ctx->plane_res.scl_data.recout.height + pipe_ctx->plane_res.scl_data.recout.y >
 			stream->dst.y + stream->dst.height)
-		pipe_ctx->scl_data.recout.height =
+		pipe_ctx->plane_res.scl_data.recout.height =
 			stream->dst.y + stream->dst.height
-						- pipe_ctx->scl_data.recout.y;
+						- pipe_ctx->plane_res.scl_data.recout.y;
 
 	/* Handle h & vsplit */
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
 		pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
-			pipe_ctx->scl_data.recout.height /= 2;
-			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
+			pipe_ctx->plane_res.scl_data.recout.height /= 2;
+			pipe_ctx->plane_res.scl_data.recout.y += pipe_ctx->plane_res.scl_data.recout.height;
 			/* Floor primary pipe, ceil 2ndary pipe */
-			pipe_ctx->scl_data.recout.height += pipe_ctx->scl_data.recout.height % 2;
+			pipe_ctx->plane_res.scl_data.recout.height += pipe_ctx->plane_res.scl_data.recout.height % 2;
 		} else {
-			pipe_ctx->scl_data.recout.width /= 2;
-			pipe_ctx->scl_data.recout.x += pipe_ctx->scl_data.recout.width;
-			pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
+			pipe_ctx->plane_res.scl_data.recout.width /= 2;
+			pipe_ctx->plane_res.scl_data.recout.x += pipe_ctx->plane_res.scl_data.recout.width;
+			pipe_ctx->plane_res.scl_data.recout.width += pipe_ctx->plane_res.scl_data.recout.width % 2;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
-			pipe_ctx->scl_data.recout.height /= 2;
+			pipe_ctx->plane_res.scl_data.recout.height /= 2;
 		else
-			pipe_ctx->scl_data.recout.width /= 2;
+			pipe_ctx->plane_res.scl_data.recout.width /= 2;
 	}
 
 	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream surf_src offset)
@@ -601,8 +601,8 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			surf_src.y * plane_state->dst_rect.height / surf_src.height
 					* stream->dst.height / stream->src.height;
 
-	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
-	recout_skip->height = pipe_ctx->scl_data.recout.y - recout_full_y;
+	recout_skip->width = pipe_ctx->plane_res.scl_data.recout.x - recout_full_x;
+	recout_skip->height = pipe_ctx->plane_res.scl_data.recout.y - recout_full_y;
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
@@ -619,36 +619,36 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
-	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
+	pipe_ctx->plane_res.scl_data.ratios.horz = dal_fixed31_32_from_fraction(
 					surf_src.width,
 					plane_state->dst_rect.width);
-	pipe_ctx->scl_data.ratios.vert = dal_fixed31_32_from_fraction(
+	pipe_ctx->plane_res.scl_data.ratios.vert = dal_fixed31_32_from_fraction(
 					surf_src.height,
 					plane_state->dst_rect.height);
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
-		pipe_ctx->scl_data.ratios.horz.value *= 2;
+		pipe_ctx->plane_res.scl_data.ratios.horz.value *= 2;
 	else if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
-		pipe_ctx->scl_data.ratios.vert.value *= 2;
+		pipe_ctx->plane_res.scl_data.ratios.vert.value *= 2;
 
-	pipe_ctx->scl_data.ratios.vert.value = div64_s64(
-		pipe_ctx->scl_data.ratios.vert.value * in_h, out_h);
-	pipe_ctx->scl_data.ratios.horz.value = div64_s64(
-		pipe_ctx->scl_data.ratios.horz.value * in_w, out_w);
+	pipe_ctx->plane_res.scl_data.ratios.vert.value = div64_s64(
+		pipe_ctx->plane_res.scl_data.ratios.vert.value * in_h, out_h);
+	pipe_ctx->plane_res.scl_data.ratios.horz.value = div64_s64(
+		pipe_ctx->plane_res.scl_data.ratios.horz.value * in_w, out_w);
 
-	pipe_ctx->scl_data.ratios.horz_c = pipe_ctx->scl_data.ratios.horz;
-	pipe_ctx->scl_data.ratios.vert_c = pipe_ctx->scl_data.ratios.vert;
+	pipe_ctx->plane_res.scl_data.ratios.horz_c = pipe_ctx->plane_res.scl_data.ratios.horz;
+	pipe_ctx->plane_res.scl_data.ratios.vert_c = pipe_ctx->plane_res.scl_data.ratios.vert;
 
-	if (pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP8
-			|| pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP10) {
-		pipe_ctx->scl_data.ratios.horz_c.value /= 2;
-		pipe_ctx->scl_data.ratios.vert_c.value /= 2;
+	if (pipe_ctx->plane_res.scl_data.format == PIXEL_FORMAT_420BPP8
+			|| pipe_ctx->plane_res.scl_data.format == PIXEL_FORMAT_420BPP10) {
+		pipe_ctx->plane_res.scl_data.ratios.horz_c.value /= 2;
+		pipe_ctx->plane_res.scl_data.ratios.vert_c.value /= 2;
 	}
 }
 
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	struct scaler_data *data = &pipe_ctx->scl_data;
+	struct scaler_data *data = &pipe_ctx->plane_res.scl_data;
 	struct rect src = pipe_ctx->plane_state->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
@@ -823,14 +823,14 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * lb depth calculation requires recout and taps require scaling ratios.
 	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
-	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
+	pipe_ctx->plane_res.scl_data.format = convert_pixel_format_to_dalsurface(
 			pipe_ctx->plane_state->format);
 
 	calculate_scaling_ratios(pipe_ctx);
 
 	calculate_viewport(pipe_ctx);
 
-	if (pipe_ctx->scl_data.viewport.height < 16 || pipe_ctx->scl_data.viewport.width < 16)
+	if (pipe_ctx->plane_res.scl_data.viewport.height < 16 || pipe_ctx->plane_res.scl_data.viewport.width < 16)
 		return false;
 
 	calculate_recout(pipe_ctx, &recout_skip);
@@ -839,21 +839,21 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * Setting line buffer pixel depth to 24bpp yields banding
 	 * on certain displays, such as the Sharp 4k
 	 */
-	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
+	pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
 
-	pipe_ctx->scl_data.h_active = timing->h_addressable;
-	pipe_ctx->scl_data.v_active = timing->v_addressable;
+	pipe_ctx->plane_res.scl_data.h_active = timing->h_addressable;
+	pipe_ctx->plane_res.scl_data.v_active = timing->v_addressable;
 
 	/* Taps calculations */
 	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
+		pipe_ctx->xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
-		pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
+		pipe_ctx->plane_res.scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
 
 		res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-			pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
+			pipe_ctx->xfm, &pipe_ctx->plane_res.scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -865,10 +865,10 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
 				"y:%d\n",
 				__func__,
-				pipe_ctx->scl_data.viewport.height,
-				pipe_ctx->scl_data.viewport.width,
-				pipe_ctx->scl_data.viewport.x,
-				pipe_ctx->scl_data.viewport.y,
+				pipe_ctx->plane_res.scl_data.viewport.height,
+				pipe_ctx->plane_res.scl_data.viewport.width,
+				pipe_ctx->plane_res.scl_data.viewport.x,
+				pipe_ctx->plane_res.scl_data.viewport.y,
 				plane_state->dst_rect.height,
 				plane_state->dst_rect.width,
 				plane_state->dst_rect.x,

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ce0415f26600..4eef400cb551 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -430,17 +430,17 @@ static void rect_swap_helper(struct rect *rect)
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect surf_src = surface->src_rect;
+	struct rect surf_src = plane_state->src_rect;
 	struct rect clip = { 0 };
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 	bool pri_split = pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface;
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state;
 	bool sec_split = pipe_ctx->top_pipe &&
-			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
+			pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state;
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
 		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
@@ -448,41 +448,41 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		sec_split = false;
 	}
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
-	clip.x = stream->src.x > surface->clip_rect.x ?
-			stream->src.x : surface->clip_rect.x;
+	clip.x = stream->src.x > plane_state->clip_rect.x ?
+			stream->src.x : plane_state->clip_rect.x;
 
 	clip.width = stream->src.x + stream->src.width <
-			surface->clip_rect.x + surface->clip_rect.width ?
+			plane_state->clip_rect.x + plane_state->clip_rect.width ?
 			stream->src.x + stream->src.width - clip.x :
-			surface->clip_rect.x + surface->clip_rect.width - clip.x ;
+			plane_state->clip_rect.x + plane_state->clip_rect.width - clip.x ;
 
-	clip.y = stream->src.y > surface->clip_rect.y ?
-			stream->src.y : surface->clip_rect.y;
+	clip.y = stream->src.y > plane_state->clip_rect.y ?
+			stream->src.y : plane_state->clip_rect.y;
 
 	clip.height = stream->src.y + stream->src.height <
-			surface->clip_rect.y + surface->clip_rect.height ?
+			plane_state->clip_rect.y + plane_state->clip_rect.height ?
 			stream->src.y + stream->src.height - clip.y :
-			surface->clip_rect.y + surface->clip_rect.height - clip.y ;
+			plane_state->clip_rect.y + plane_state->clip_rect.height - clip.y ;
 
 	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	data->viewport.x = surf_src.x + (clip.x - surface->dst_rect.x) *
-			surf_src.width / surface->dst_rect.width;
+	data->viewport.x = surf_src.x + (clip.x - plane_state->dst_rect.x) *
+			surf_src.width / plane_state->dst_rect.width;
 	data->viewport.width = clip.width *
-			surf_src.width / surface->dst_rect.width;
+			surf_src.width / plane_state->dst_rect.width;
 
-	data->viewport.y = surf_src.y + (clip.y - surface->dst_rect.y) *
-			surf_src.height / surface->dst_rect.height;
+	data->viewport.y = surf_src.y + (clip.y - plane_state->dst_rect.y) *
+			surf_src.height / plane_state->dst_rect.height;
 	data->viewport.height = clip.height *
-			surf_src.height / surface->dst_rect.height;
+			surf_src.height / plane_state->dst_rect.height;
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
@@ -498,13 +498,13 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	/* Handle hsplit */
 	if (pri_split || sec_split) {
 		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
-		bool right_view = (sec_split != surface->horizontal_mirror) !=
-					(surface->rotation == ROTATION_ANGLE_180);
+		bool right_view = (sec_split != plane_state->horizontal_mirror) !=
+					(plane_state->rotation == ROTATION_ANGLE_180);
 
-		if (surface->rotation == ROTATION_ANGLE_90
-				|| surface->rotation == ROTATION_ANGLE_270)
+		if (plane_state->rotation == ROTATION_ANGLE_90
+				|| plane_state->rotation == ROTATION_ANGLE_270)
 			/* Secondary_pipe XOR Rotation_270 */
-			right_view = (surface->rotation == ROTATION_ANGLE_270) != sec_split;
+			right_view = (plane_state->rotation == ROTATION_ANGLE_270) != sec_split;
 
 		if (right_view) {
 			data->viewport.width /= 2;
@@ -520,8 +520,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		}
 	}
 
-	if (surface->rotation == ROTATION_ANGLE_90 ||
-			surface->rotation == ROTATION_ANGLE_270) {
+	if (plane_state->rotation == ROTATION_ANGLE_90 ||
+			plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -529,14 +529,14 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	struct rect surf_src = surface->src_rect;
-	struct rect surf_clip = surface->clip_rect;
+	struct rect surf_src = plane_state->src_rect;
+	struct rect surf_clip = plane_state->clip_rect;
 	int recout_full_x, recout_full_y;
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.recout.x = stream->dst.x;
@@ -568,8 +568,8 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 						- pipe_ctx->scl_data.recout.y;
 
 	/* Handle h & vsplit */
-	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
-		pipe_ctx->surface) {
+	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->plane_state ==
+		pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 			pipe_ctx->scl_data.recout.height /= 2;
 			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
@@ -581,7 +581,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
-			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+			pipe_ctx->bottom_pipe->plane_state == pipe_ctx->plane_state) {
 		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
 		else
@@ -592,13 +592,13 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
-	recout_full_x = stream->dst.x + (surface->dst_rect.x -  stream->src.x)
+	recout_full_x = stream->dst.x + (plane_state->dst_rect.x -  stream->src.x)
 					* stream->dst.width / stream->src.width -
-			surf_src.x * surface->dst_rect.width / surf_src.width
+			surf_src.x * plane_state->dst_rect.width / surf_src.width
 					* stream->dst.width / stream->src.width;
-	recout_full_y = stream->dst.y + (surface->dst_rect.y -  stream->src.y)
+	recout_full_y = stream->dst.y + (plane_state->dst_rect.y -  stream->src.y)
 					* stream->dst.height / stream->src.height -
-			surf_src.y * surface->dst_rect.height / surf_src.height
+			surf_src.y * plane_state->dst_rect.height / surf_src.height
 					* stream->dst.height / stream->src.height;
 
 	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
@@ -607,24 +607,24 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	const struct dc_stream_state *stream = pipe_ctx->stream;
-	struct rect surf_src = surface->src_rect;
+	struct rect surf_src = plane_state->src_rect;
 	const int in_w = stream->src.width;
 	const int in_h = stream->src.height;
 	const int out_w = stream->dst.width;
 	const int out_h = stream->dst.height;
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
 					surf_src.width,
-					surface->dst_rect.width);
+					plane_state->dst_rect.width);
 	pipe_ctx->scl_data.ratios.vert = dal_fixed31_32_from_fraction(
 					surf_src.height,
-					surface->dst_rect.height);
+					plane_state->dst_rect.height);
 
 	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
@@ -649,13 +649,13 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect src = pipe_ctx->surface->src_rect;
+	struct rect src = pipe_ctx->plane_state->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
@@ -805,8 +805,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
 
-	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->plane_state->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->plane_state->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -814,7 +814,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_plane_state *surface = pipe_ctx->surface;
+	const struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
@@ -824,7 +824,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
 	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
-			pipe_ctx->surface->format);
+			pipe_ctx->plane_state->format);
 
 	calculate_scaling_ratios(pipe_ctx);
 
@@ -846,14 +846,14 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 
 	/* Taps calculations */
 	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-		pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+		pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
 
 	if (!res) {
 		/* Try 24 bpp linebuffer */
 		pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
 
 		res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
-			pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+			pipe_ctx->xfm, &pipe_ctx->scl_data, &plane_state->scaling_quality);
 	}
 
 	if (res)
@@ -869,10 +869,10 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 				pipe_ctx->scl_data.viewport.width,
 				pipe_ctx->scl_data.viewport.x,
 				pipe_ctx->scl_data.viewport.y,
-				surface->dst_rect.height,
-				surface->dst_rect.width,
-				surface->dst_rect.x,
-				surface->dst_rect.y);
+				plane_state->dst_rect.height,
+				plane_state->dst_rect.width,
+				plane_state->dst_rect.x,
+				plane_state->dst_rect.y);
 
 	return res;
 }
@@ -885,7 +885,7 @@ enum dc_status resource_build_scaling_params_for_context(
 	int i;
 
 	for (i = 0; i < MAX_PIPES; i++) {
-		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
+		if (context->res_ctx.pipe_ctx[i].plane_state != NULL &&
 				context->res_ctx.pipe_ctx[i].stream != NULL)
 			if (!resource_build_scaling_params(&context->res_ctx.pipe_ctx[i]))
 				return DC_FAIL_SCALING;
@@ -954,13 +954,13 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	if (!head_pipe)
 		ASSERT(0);
 
-	if (!head_pipe->surface)
+	if (!head_pipe->plane_state)
 		return head_pipe;
 
 	/* Re-use pipe already acquired for this stream if available*/
 	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				!res_ctx->pipe_ctx[i].surface) {
+				!res_ctx->pipe_ctx[i].plane_state) {
 			return &res_ctx->pipe_ctx[i];
 		}
 	}
@@ -987,7 +987,7 @@ static void release_free_pipes_for_stream(
 		/* never release the topmost pipe*/
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				res_ctx->pipe_ctx[i].top_pipe &&
-				!res_ctx->pipe_ctx[i].surface) {
+				!res_ctx->pipe_ctx[i].plane_state) {
 			memset(&res_ctx->pipe_ctx[i], 0, sizeof(struct pipe_ctx));
 		}
 	}
@@ -1005,7 +1005,7 @@ static int acquire_first_split_pipe(
 		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
 		if (pipe_ctx->top_pipe &&
-				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+				pipe_ctx->top_pipe->plane_state == pipe_ctx->plane_state) {
 			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
 			if (pipe_ctx->bottom_pipe)
 				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
@@ -1028,7 +1028,7 @@ static int acquire_first_split_pipe(
 #endif
 
 bool resource_attach_surfaces_to_context(
-		struct dc_plane_state * const *surfaces,
+		struct dc_plane_state * const *plane_states,
 		int surface_count,
 		struct dc_stream_state *stream,
 		struct validate_context *context,
@@ -1057,25 +1057,25 @@ bool resource_attach_surfaces_to_context(
 
 	/* retain new surfaces */
 	for (i = 0; i < surface_count; i++)
-		dc_surface_retain(surfaces[i]);
+		dc_plane_state_retain(plane_states[i]);
 
 	/* detach surfaces from pipes */
 	for (i = 0; i < pool->pipe_count; i++)
 		if (context->res_ctx.pipe_ctx[i].stream == stream) {
-			context->res_ctx.pipe_ctx[i].surface = NULL;
+			context->res_ctx.pipe_ctx[i].plane_state = NULL;
 			context->res_ctx.pipe_ctx[i].bottom_pipe = NULL;
 		}
 
 	/* release existing surfaces*/
-	for (i = 0; i < stream_status->surface_count; i++)
-		dc_surface_release(stream_status->surfaces[i]);
+	for (i = 0; i < stream_status->plane_count; i++)
+		dc_plane_state_release(stream_status->plane_states[i]);
 
-	for (i = surface_count; i < stream_status->surface_count; i++)
-		stream_status->surfaces[i] = NULL;
+	for (i = surface_count; i < stream_status->plane_count; i++)
+		stream_status->plane_states[i] = NULL;
 
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
-		struct dc_plane_state *surface = surfaces[i];
+		struct dc_plane_state *plane_state = plane_states[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, stream);
 
@@ -1087,11 +1087,11 @@ bool resource_attach_surfaces_to_context(
 		}
 #endif
 		if (!free_pipe) {
-			stream_status->surfaces[i] = NULL;
+			stream_status->plane_states[i] = NULL;
 			return false;
 		}
 
-		free_pipe->surface = surface;
+		free_pipe->plane_state = plane_state;
 
 		if (tail_pipe) {
 			free_pipe->tg = tail_pipe->tg;
@@ -1110,9 +1110,9 @@ bool resource_attach_surfaces_to_context(
 
 	/* assign new surfaces*/
 	for (i = 0; i < surface_count; i++)
-		stream_status->surfaces[i] = surfaces[i];
+		stream_status->plane_states[i] = plane_states[i];
 
-	stream_status->surface_count = surface_count;
+	stream_status->plane_count = surface_count;
 
 	return true;
 }
@@ -1180,17 +1180,17 @@ bool resource_validate_attach_surfaces(
 					old_context->streams[j],
 					context->streams[i])) {
 				if (!resource_attach_surfaces_to_context(
-						old_context->stream_status[j].surfaces,
-						old_context->stream_status[j].surface_count,
+						old_context->stream_status[j].plane_states,
+						old_context->stream_status[j].plane_count,
 						context->streams[i],
 						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
 			}
-		if (set[i].surface_count != 0)
+		if (set[i].plane_count != 0)
 			if (!resource_attach_surfaces_to_context(
-					set[i].surfaces,
-					set[i].surface_count,
+					set[i].plane_states,
+					set[i].plane_count,
 					context->streams[i],
 					context, pool))
 				return false;
@@ -1351,13 +1351,13 @@ bool resource_is_stream_unchanged(
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
-	struct dc_plane_state *surface = to_pipe_ctx->surface;
+	struct dc_plane_state *plane_state = to_pipe_ctx->plane_state;
 	struct dc_stream_state *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
 	to_pipe_ctx->stream = stream;
-	if (surface != NULL)
-		to_pipe_ctx->surface = surface;
+	if (plane_state != NULL)
+		to_pipe_ctx->plane_state = plane_state;
 }
 
 static struct dc_stream_state *find_pll_sharable_stream(
@@ -2055,7 +2055,7 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_plane_state *surface,
+		struct dc_plane_state *plane_state,
 		struct dc_stream_state *stream)
 {
 	uint16_t i = 0;
@@ -2063,10 +2063,10 @@ static void set_hdr_static_info_packet(
 	struct dc_hdr_static_metadata hdr_metadata;
 	uint32_t data;
 
-	if (!surface)
+	if (!plane_state)
 		return;
 
-	hdr_metadata = surface->hdr_static_ctx;
+	hdr_metadata = plane_state->hdr_static_ctx;
 
 	if (!hdr_metadata.hdr_supported)
 		return;
@@ -2204,11 +2204,11 @@ void dc_resource_validate_ctx_destruct(struct validate_context *context)
 	int i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		for (j = 0; j < context->stream_status[i].surface_count; j++)
-			dc_surface_release(
-				context->stream_status[i].surfaces[j]);
+		for (j = 0; j < context->stream_status[i].plane_count; j++)
+			dc_plane_state_release(
+				context->stream_status[i].plane_states[j]);
 
-		context->stream_status[i].surface_count = 0;
+		context->stream_status[i].plane_count = 0;
 		dc_stream_release(context->streams[i]);
 		context->streams[i] = NULL;
 	}
@@ -2240,9 +2240,9 @@ void dc_resource_validate_ctx_copy_construct(
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {
 		dc_stream_retain(dst_ctx->streams[i]);
-		for (j = 0; j < dst_ctx->stream_status[i].surface_count; j++)
-			dc_surface_retain(
-				dst_ctx->stream_status[i].surfaces[j]);
+		for (j = 0; j < dst_ctx->stream_status[i].plane_count; j++)
+			dc_plane_state_retain(
+				dst_ctx->stream_status[i].plane_states[j]);
 	}
 
 	/* context refcount should not be overridden */
@@ -2288,7 +2288,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->surface, pipe_ctx->stream);
+				pipe_ctx->plane_state, pipe_ctx->stream);
 
 	} else if (dc_is_dp_signal(signal)) {
 		set_vsc_info_packet(&info->vsc, pipe_ctx->stream);
@@ -2296,7 +2296,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_spd_info_packet(&info->spd, pipe_ctx->stream);
 
 		set_hdr_static_info_packet(&info->hdrsmd,
-				pipe_ctx->surface, pipe_ctx->stream);
+				pipe_ctx->plane_state, pipe_ctx->stream);
 	}
 
 	patch_gamut_packet_checksum(&info->gamut);

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fd1d6be79fee..ce0415f26600 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -294,8 +294,8 @@ void resource_reference_clock_source(
 }
 
 bool resource_are_streams_timing_synchronizable(
-	struct dc_stream *stream1,
-	struct dc_stream *stream2)
+	struct dc_stream_state *stream1,
+	struct dc_stream_state *stream2)
 {
 	if (stream1->timing.h_total != stream2->timing.h_total)
 		return false;
@@ -431,7 +431,7 @@ static void rect_swap_helper(struct rect *rect)
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
 	struct rect clip = { 0 };
@@ -530,7 +530,7 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	const struct dc_plane_state *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	struct rect surf_clip = surface->clip_rect;
 	int recout_full_x, recout_full_y;
@@ -608,7 +608,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_plane_state *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = pipe_ctx->stream;
+	const struct dc_stream_state *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	const int in_w = stream->src.width;
 	const int in_h = stream->src.height;
@@ -920,7 +920,7 @@ struct pipe_ctx *find_idle_secondary_pipe(
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -940,7 +940,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 	struct resource_context *res_ctx = &context->res_ctx;
@@ -979,7 +979,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 static void release_free_pipes_for_stream(
 		struct resource_context *res_ctx,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 
@@ -997,7 +997,7 @@ static void release_free_pipes_for_stream(
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 
@@ -1030,7 +1030,7 @@ static int acquire_first_split_pipe(
 bool resource_attach_surfaces_to_context(
 		struct dc_plane_state * const *surfaces,
 		int surface_count,
-		struct dc_stream *stream,
+		struct dc_stream_state *stream,
 		struct validate_context *context,
 		const struct resource_pool *pool)
 {
@@ -1118,8 +1118,8 @@ bool resource_attach_surfaces_to_context(
 }
 
 
-static bool is_timing_changed(struct dc_stream *cur_stream,
-		struct dc_stream *new_stream)
+static bool is_timing_changed(struct dc_stream_state *cur_stream,
+		struct dc_stream_state *new_stream)
 {
 	if (cur_stream == NULL)
 		return true;
@@ -1141,7 +1141,7 @@ static bool is_timing_changed(struct dc_stream *cur_stream,
 }
 
 static bool are_stream_backends_same(
-	struct dc_stream *stream_a, struct dc_stream *stream_b)
+	struct dc_stream_state *stream_a, struct dc_stream_state *stream_b)
 {
 	if (stream_a == stream_b)
 		return true;
@@ -1156,7 +1156,7 @@ static bool are_stream_backends_same(
 }
 
 bool dc_is_stream_unchanged(
-	struct dc_stream *old_stream, struct dc_stream *stream)
+	struct dc_stream_state *old_stream, struct dc_stream_state *stream)
 {
 
 	if (!are_stream_backends_same(old_stream, stream))
@@ -1233,7 +1233,7 @@ static void set_audio_in_use(
 static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 
@@ -1260,7 +1260,7 @@ static int acquire_first_free_pipe(
 static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	int i;
 	int j = -1;
@@ -1311,7 +1311,7 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-static void update_stream_signal(struct dc_stream *stream)
+static void update_stream_signal(struct dc_stream_state *stream)
 {
 	if (stream->output_signal == SIGNAL_TYPE_NONE) {
 		struct dc_sink *dc_sink = stream->sink;
@@ -1334,12 +1334,12 @@ static void update_stream_signal(struct dc_stream *stream)
 }
 
 bool resource_is_stream_unchanged(
-	struct validate_context *old_context, struct dc_stream *stream)
+	struct validate_context *old_context, struct dc_stream_state *stream)
 {
 	int i;
 
 	for (i = 0; i < old_context->stream_count; i++) {
-		struct dc_stream *old_stream = old_context->streams[i];
+		struct dc_stream_state *old_stream = old_context->streams[i];
 
 		if (are_stream_backends_same(old_stream, stream))
 				return true;
@@ -1352,7 +1352,7 @@ static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
 	struct dc_plane_state *surface = to_pipe_ctx->surface;
-	struct dc_stream *stream = to_pipe_ctx->stream;
+	struct dc_stream_state *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
 	to_pipe_ctx->stream = stream;
@@ -1360,14 +1360,14 @@ static void copy_pipe_ctx(
 		to_pipe_ctx->surface = surface;
 }
 
-static struct dc_stream *find_pll_sharable_stream(
-		struct dc_stream *stream_needs_pll,
+static struct dc_stream_state *find_pll_sharable_stream(
+		struct dc_stream_state *stream_needs_pll,
 		struct validate_context *context)
 {
 	int i;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream_has_pll = context->streams[i];
+		struct dc_stream_state *stream_has_pll = context->streams[i];
 
 		/* We are looking for non dp, non virtual stream */
 		if (resource_are_streams_timing_synchronizable(
@@ -1411,7 +1411,7 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-static void calculate_phy_pix_clks(struct dc_stream *stream)
+static void calculate_phy_pix_clks(struct dc_stream_state *stream)
 {
 	update_stream_signal(stream);
 
@@ -1433,7 +1433,7 @@ enum dc_status resource_map_pool_resources(
 	int i, j;
 
 	for (i = 0; old_context && i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (!resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
@@ -1486,7 +1486,7 @@ enum dc_status resource_map_pool_resources(
 	}
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 		struct pipe_ctx *pipe_ctx = NULL;
 		int pipe_idx = -1;
 
@@ -1581,7 +1581,7 @@ static void set_avi_info_frame(
 		struct encoder_info_packet *info_packet,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct dc_stream *stream = pipe_ctx->stream;
+	struct dc_stream_state *stream = pipe_ctx->stream;
 	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
 	struct info_frame info_frame = { {0} };
 	uint32_t pixel_encoding = 0;
@@ -1821,7 +1821,7 @@ static void set_avi_info_frame(
 
 static void set_vendor_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	uint32_t length = 0;
 	bool hdmi_vic_mode = false;
@@ -1934,7 +1934,7 @@ static void set_vendor_info_packet(
 
 static void set_spd_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	/* SPD info packet for FreeSync */
 
@@ -2056,7 +2056,7 @@ static void set_spd_info_packet(
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
 		struct dc_plane_state *surface,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
@@ -2159,7 +2159,7 @@ static void set_hdr_static_info_packet(
 
 static void set_vsc_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_stream *stream)
+		struct dc_stream_state *stream)
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
@@ -2312,7 +2312,7 @@ enum dc_status resource_map_clock_resources(
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -2392,7 +2392,7 @@ bool pipe_need_reprogram(
 	return false;
 }
 
-void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
+void resource_build_bit_depth_reduction_params(struct dc_stream_state *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth)
 {
 	enum dc_dither_option option = stream->dither_option;
@@ -2502,7 +2502,7 @@ void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream)
+bool dc_validate_stream(const struct dc *dc, struct dc_stream_state *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_context *dc_ctx = core_dc->ctx;

commit c9614aeb12f80fa7a787e608d75b707175997edd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:24:04 2017 -0400

    drm/amd/display: Rename dc_surface to dc_plane_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_surface/struct dc_plane_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_update/struct dc_surface_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_status/struct dc_surface_status/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_dcc_cap/struct dc_surface_dcc_cap/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 005eac5fae80..fd1d6be79fee 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -430,7 +430,7 @@ static void rect_swap_helper(struct rect *rect)
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = pipe_ctx->surface;
+	const struct dc_plane_state *surface = pipe_ctx->surface;
 	const struct dc_stream *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
@@ -529,7 +529,7 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	const struct dc_surface *surface = pipe_ctx->surface;
+	const struct dc_plane_state *surface = pipe_ctx->surface;
 	const struct dc_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	struct rect surf_clip = surface->clip_rect;
@@ -607,7 +607,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = pipe_ctx->surface;
+	const struct dc_plane_state *surface = pipe_ctx->surface;
 	const struct dc_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	const int in_w = stream->src.width;
@@ -814,7 +814,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = pipe_ctx->surface;
+	const struct dc_plane_state *surface = pipe_ctx->surface;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
@@ -1028,7 +1028,7 @@ static int acquire_first_split_pipe(
 #endif
 
 bool resource_attach_surfaces_to_context(
-		struct dc_surface * const *surfaces,
+		struct dc_plane_state * const *surfaces,
 		int surface_count,
 		struct dc_stream *stream,
 		struct validate_context *context,
@@ -1075,7 +1075,7 @@ bool resource_attach_surfaces_to_context(
 
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
-		struct dc_surface *surface = surfaces[i];
+		struct dc_plane_state *surface = surfaces[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, stream);
 
@@ -1351,7 +1351,7 @@ bool resource_is_stream_unchanged(
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
-	struct dc_surface *surface = to_pipe_ctx->surface;
+	struct dc_plane_state *surface = to_pipe_ctx->surface;
 	struct dc_stream *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
@@ -2055,7 +2055,7 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct dc_surface *surface,
+		struct dc_plane_state *surface,
 		struct dc_stream *stream)
 {
 	uint16_t i = 0;
@@ -2534,13 +2534,13 @@ bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream)
 	return res == DC_OK;
 }
 
-bool dc_validate_surface(const struct dc *dc, const struct dc_surface *surface)
+bool dc_validate_plane(const struct dc *dc, const struct dc_plane_state *plane_state)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 
 	/* TODO For now validates pixel format only */
-	if (core_dc->res_pool->funcs->validate_surface)
-		return core_dc->res_pool->funcs->validate_surface(surface) == DC_OK;
+	if (core_dc->res_pool->funcs->validate_plane)
+		return core_dc->res_pool->funcs->validate_plane(plane_state) == DC_OK;
 
 	return true;
 }

commit d54d29db47cdbe1f26776f2d03320ca56c5271fa
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Fri Jul 28 12:07:38 2017 -0400

    drm/amd/display: Move and Rename "is_stream_changed()"
    
     -Move "is_stream_changed()" to DC interface
     -Rename "is_stream_changed()" to "dc_is_stream_changed()"
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 566a1bed9828..005eac5fae80 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1155,7 +1155,7 @@ static bool are_stream_backends_same(
 	return true;
 }
 
-bool is_stream_unchanged(
+bool dc_is_stream_unchanged(
 	struct dc_stream *old_stream, struct dc_stream *stream)
 {
 
@@ -1176,7 +1176,7 @@ bool resource_validate_attach_surfaces(
 
 	for (i = 0; i < set_count; i++) {
 		for (j = 0; old_context && j < old_context->stream_count; j++)
-			if (is_stream_unchanged(
+			if (dc_is_stream_unchanged(
 					old_context->streams[j],
 					context->streams[i])) {
 				if (!resource_attach_surfaces_to_context(

commit b701542d29d61c3514f51496168831c8476a8e2a
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Jul 28 18:21:22 2017 -0400

    drm/amd/display: fix >340 Mhz with deep color pipe split no display
    
     the input to HW formula needs to take care the deep color.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1f4237fc3e53..566a1bed9828 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1657,8 +1657,6 @@ static void set_avi_info_frame(
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)
 		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU601;
 	else {
-		if (stream->timing.pixel_encoding != PIXEL_ENCODING_RGB)
-			BREAK_TO_DEBUGGER();
 		hdmi_info->bits.C0_C1 = COLORIMETRY_NO_DATA;
 	}
 	if (color_space == COLOR_SPACE_2020_RGB_FULLRANGE ||

commit 792671d7e1e28995c6a63104fac1208e19a0ab08
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Wed Jul 26 15:51:31 2017 -0400

    drm/amd/display: Add per surface validation hook.
    
    For now just validate pixel format in the hook.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d381e380e974..1f4237fc3e53 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2535,3 +2535,14 @@ bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream)
 
 	return res == DC_OK;
 }
+
+bool dc_validate_surface(const struct dc *dc, const struct dc_surface *surface)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+
+	/* TODO For now validates pixel format only */
+	if (core_dc->res_pool->funcs->validate_surface)
+		return core_dc->res_pool->funcs->validate_surface(surface) == DC_OK;
+
+	return true;
+}

commit 1515a47b44c8667987d070fdc494691f91b44b46
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jul 26 19:31:53 2017 -0400

    drm/amd/display: Rename firmware_info to dc_firmware_info
    
    This is to avoid conflicts with amdgpu's firmware_info once we
    merge amdgpu_dm_types with amdgpu_dm.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4068d53137f5..d381e380e974 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -126,7 +126,7 @@ struct resource_pool *dc_create_resource_pool(
 		break;
 	}
 	if (res_pool != NULL) {
-		struct firmware_info fw_info = { { 0 } };
+		struct dc_firmware_info fw_info = { { 0 } };
 
 		if (dc->ctx->dc_bios->funcs->get_firmware_info(
 				dc->ctx->dc_bios, &fw_info) == BP_RESULT_OK) {

commit cc408d726c20f32e4fdd688f870dd2b17960d4a2
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 21 17:46:50 2017 -0400

    drm/amd/display: mpc block redesign
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ddbd3de63a8d..4068d53137f5 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1017,7 +1017,6 @@ static int acquire_first_split_pipe(
 			pipe_ctx->xfm = pool->transforms[i];
 			pipe_ctx->opp = pool->opps[i];
 			pipe_ctx->dis_clk = pool->display_clock;
-			pipe_ctx->mpcc = pool->mpcc[i];
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -1096,6 +1095,7 @@ bool resource_attach_surfaces_to_context(
 
 		if (tail_pipe) {
 			free_pipe->tg = tail_pipe->tg;
+			free_pipe->opp = tail_pipe->opp;
 			free_pipe->stream_enc = tail_pipe->stream_enc;
 			free_pipe->audio = tail_pipe->audio;
 			free_pipe->clock_source = tail_pipe->clock_source;
@@ -1241,9 +1241,6 @@ static int acquire_first_free_pipe(
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-			pipe_ctx->mpcc = pool->mpcc[i];
-#endif
 			pipe_ctx->tg = pool->timing_generators[i];
 			pipe_ctx->mi = pool->mis[i];
 			pipe_ctx->ipp = pool->ipps[i];

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index eeefc9c33633..ddbd3de63a8d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -294,25 +294,25 @@ void resource_reference_clock_source(
 }
 
 bool resource_are_streams_timing_synchronizable(
-	const struct core_stream *stream1,
-	const struct core_stream *stream2)
+	struct dc_stream *stream1,
+	struct dc_stream *stream2)
 {
-	if (stream1->public.timing.h_total != stream2->public.timing.h_total)
+	if (stream1->timing.h_total != stream2->timing.h_total)
 		return false;
 
-	if (stream1->public.timing.v_total != stream2->public.timing.v_total)
+	if (stream1->timing.v_total != stream2->timing.v_total)
 		return false;
 
-	if (stream1->public.timing.h_addressable
-				!= stream2->public.timing.h_addressable)
+	if (stream1->timing.h_addressable
+				!= stream2->timing.h_addressable)
 		return false;
 
-	if (stream1->public.timing.v_addressable
-				!= stream2->public.timing.v_addressable)
+	if (stream1->timing.v_addressable
+				!= stream2->timing.v_addressable)
 		return false;
 
-	if (stream1->public.timing.pix_clk_khz
-				!= stream2->public.timing.pix_clk_khz)
+	if (stream1->timing.pix_clk_khz
+				!= stream2->timing.pix_clk_khz)
 		return false;
 
 	if (stream1->phy_pix_clk != stream2->phy_pix_clk
@@ -431,7 +431,7 @@ static void rect_swap_helper(struct rect *rect)
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	const struct dc_stream *stream = &pipe_ctx->stream->public;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
 	struct rect clip = { 0 };
@@ -530,7 +530,7 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	struct rect surf_clip = surface->clip_rect;
 	int recout_full_x, recout_full_y;
@@ -539,38 +539,38 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
-	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
-	if (stream->public.src.x < surf_clip.x)
+	pipe_ctx->scl_data.recout.x = stream->dst.x;
+	if (stream->src.x < surf_clip.x)
 		pipe_ctx->scl_data.recout.x += (surf_clip.x
-			- stream->public.src.x) * stream->public.dst.width
-						/ stream->public.src.width;
+			- stream->src.x) * stream->dst.width
+						/ stream->src.width;
 
 	pipe_ctx->scl_data.recout.width = surf_clip.width *
-			stream->public.dst.width / stream->public.src.width;
+			stream->dst.width / stream->src.width;
 	if (pipe_ctx->scl_data.recout.width + pipe_ctx->scl_data.recout.x >
-			stream->public.dst.x + stream->public.dst.width)
+			stream->dst.x + stream->dst.width)
 		pipe_ctx->scl_data.recout.width =
-			stream->public.dst.x + stream->public.dst.width
+			stream->dst.x + stream->dst.width
 						- pipe_ctx->scl_data.recout.x;
 
-	pipe_ctx->scl_data.recout.y = stream->public.dst.y;
-	if (stream->public.src.y < surf_clip.y)
+	pipe_ctx->scl_data.recout.y = stream->dst.y;
+	if (stream->src.y < surf_clip.y)
 		pipe_ctx->scl_data.recout.y += (surf_clip.y
-			- stream->public.src.y) * stream->public.dst.height
-						/ stream->public.src.height;
+			- stream->src.y) * stream->dst.height
+						/ stream->src.height;
 
 	pipe_ctx->scl_data.recout.height = surf_clip.height *
-			stream->public.dst.height / stream->public.src.height;
+			stream->dst.height / stream->src.height;
 	if (pipe_ctx->scl_data.recout.height + pipe_ctx->scl_data.recout.y >
-			stream->public.dst.y + stream->public.dst.height)
+			stream->dst.y + stream->dst.height)
 		pipe_ctx->scl_data.recout.height =
-			stream->public.dst.y + stream->public.dst.height
+			stream->dst.y + stream->dst.height
 						- pipe_ctx->scl_data.recout.y;
 
 	/* Handle h & vsplit */
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
 		pipe_ctx->surface) {
-		if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
+		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 			pipe_ctx->scl_data.recout.height /= 2;
 			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
 			/* Floor primary pipe, ceil 2ndary pipe */
@@ -582,7 +582,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 		}
 	} else if (pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
-		if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
+		if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
 		else
 			pipe_ctx->scl_data.recout.width /= 2;
@@ -592,14 +592,14 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
-	recout_full_x = stream->public.dst.x + (surface->dst_rect.x -  stream->public.src.x)
-					* stream->public.dst.width / stream->public.src.width -
+	recout_full_x = stream->dst.x + (surface->dst_rect.x -  stream->src.x)
+					* stream->dst.width / stream->src.width -
 			surf_src.x * surface->dst_rect.width / surf_src.width
-					* stream->public.dst.width / stream->public.src.width;
-	recout_full_y = stream->public.dst.y + (surface->dst_rect.y -  stream->public.src.y)
-					* stream->public.dst.height / stream->public.src.height -
+					* stream->dst.width / stream->src.width;
+	recout_full_y = stream->dst.y + (surface->dst_rect.y -  stream->src.y)
+					* stream->dst.height / stream->src.height -
 			surf_src.y * surface->dst_rect.height / surf_src.height
-					* stream->public.dst.height / stream->public.src.height;
+					* stream->dst.height / stream->src.height;
 
 	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
 	recout_skip->height = pipe_ctx->scl_data.recout.y - recout_full_y;
@@ -608,12 +608,12 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	struct core_stream *stream = pipe_ctx->stream;
+	const struct dc_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
-	const int in_w = stream->public.src.width;
-	const int in_h = stream->public.src.height;
-	const int out_w = stream->public.dst.width;
-	const int out_h = stream->public.dst.height;
+	const int in_w = stream->src.width;
+	const int in_h = stream->src.height;
+	const int out_w = stream->dst.width;
+	const int out_h = stream->dst.height;
 
 	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
@@ -626,9 +626,9 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 					surf_src.height,
 					surface->dst_rect.height);
 
-	if (stream->public.view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
+	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
-	else if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
+	else if (stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 		pipe_ctx->scl_data.ratios.vert.value *= 2;
 
 	pipe_ctx->scl_data.ratios.vert.value = div64_s64(
@@ -815,7 +815,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = pipe_ctx->surface;
-	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
 
@@ -920,7 +920,7 @@ struct pipe_ctx *find_idle_secondary_pipe(
 
 struct pipe_ctx *resource_get_head_pipe_for_stream(
 		struct resource_context *res_ctx,
-		const struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 	for (i = 0; i < MAX_PIPES; i++) {
@@ -940,11 +940,10 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct validate_context *context,
 		const struct resource_pool *pool,
-		const struct dc_stream *dc_stream)
+		struct dc_stream *stream)
 {
 	int i;
 	struct resource_context *res_ctx = &context->res_ctx;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	struct pipe_ctx *head_pipe = NULL;
 
@@ -980,10 +979,9 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 
 static void release_free_pipes_for_stream(
 		struct resource_context *res_ctx,
-		const struct dc_stream *dc_stream)
+		struct dc_stream *stream)
 {
 	int i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	for (i = MAX_PIPES - 1; i >= 0; i--) {
 		/* never release the topmost pipe*/
@@ -999,7 +997,7 @@ static void release_free_pipes_for_stream(
 static int acquire_first_split_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 
@@ -1033,14 +1031,13 @@ static int acquire_first_split_pipe(
 bool resource_attach_surfaces_to_context(
 		struct dc_surface * const *surfaces,
 		int surface_count,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *stream,
 		struct validate_context *context,
 		const struct resource_pool *pool)
 {
 	int i;
 	struct pipe_ctx *tail_pipe;
 	struct dc_stream_status *stream_status = NULL;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 
 	if (surface_count > MAX_SURFACE_NUM) {
@@ -1050,7 +1047,7 @@ bool resource_attach_surfaces_to_context(
 	}
 
 	for (i = 0; i < context->stream_count; i++)
-		if (&context->streams[i]->public == dc_stream) {
+		if (context->streams[i] == stream) {
 			stream_status = &context->stream_status[i];
 			break;
 		}
@@ -1081,7 +1078,7 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++) {
 		struct dc_surface *surface = surfaces[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
-				context, pool, dc_stream);
+				context, pool, stream);
 
 #if defined(CONFIG_DRM_AMD_DC_DCN1_0)
 		if (!free_pipe) {
@@ -1109,7 +1106,7 @@ bool resource_attach_surfaces_to_context(
 		tail_pipe = free_pipe;
 	}
 
-	release_free_pipes_for_stream(&context->res_ctx, dc_stream);
+	release_free_pipes_for_stream(&context->res_ctx, stream);
 
 	/* assign new surfaces*/
 	for (i = 0; i < surface_count; i++)
@@ -1121,8 +1118,8 @@ bool resource_attach_surfaces_to_context(
 }
 
 
-static bool is_timing_changed(const struct core_stream *cur_stream,
-		const struct core_stream *new_stream)
+static bool is_timing_changed(struct dc_stream *cur_stream,
+		struct dc_stream *new_stream)
 {
 	if (cur_stream == NULL)
 		return true;
@@ -1134,18 +1131,17 @@ static bool is_timing_changed(const struct core_stream *cur_stream,
 		return true;
 
 	/* If output color space is changed, need to reprogram info frames */
-	if (cur_stream->public.output_color_space !=
-			new_stream->public.output_color_space)
+	if (cur_stream->output_color_space != new_stream->output_color_space)
 		return true;
 
 	return memcmp(
-		&cur_stream->public.timing,
-		&new_stream->public.timing,
+		&cur_stream->timing,
+		&new_stream->timing,
 		sizeof(struct dc_crtc_timing)) != 0;
 }
 
 static bool are_stream_backends_same(
-	const struct core_stream *stream_a, const struct core_stream *stream_b)
+	struct dc_stream *stream_a, struct dc_stream *stream_b)
 {
 	if (stream_a == stream_b)
 		return true;
@@ -1160,7 +1156,7 @@ static bool are_stream_backends_same(
 }
 
 bool is_stream_unchanged(
-	const struct core_stream *old_stream, const struct core_stream *stream)
+	struct dc_stream *old_stream, struct dc_stream *stream)
 {
 
 	if (!are_stream_backends_same(old_stream, stream))
@@ -1186,7 +1182,7 @@ bool resource_validate_attach_surfaces(
 				if (!resource_attach_surfaces_to_context(
 						old_context->stream_status[j].surfaces,
 						old_context->stream_status[j].surface_count,
-						&context->streams[i]->public,
+						context->streams[i],
 						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
@@ -1195,7 +1191,7 @@ bool resource_validate_attach_surfaces(
 			if (!resource_attach_surfaces_to_context(
 					set[i].surfaces,
 					set[i].surface_count,
-					&context->streams[i]->public,
+					context->streams[i],
 					context, pool))
 				return false;
 
@@ -1237,7 +1233,7 @@ static void set_audio_in_use(
 static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 
@@ -1267,7 +1263,7 @@ static int acquire_first_free_pipe(
 static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	int i;
 	int j = -1;
@@ -1318,22 +1314,22 @@ static struct audio *find_first_free_audio(
 	return 0;
 }
 
-static void update_stream_signal(struct core_stream *stream)
+static void update_stream_signal(struct dc_stream *stream)
 {
-	if (stream->public.output_signal == SIGNAL_TYPE_NONE) {
-		struct dc_sink *dc_sink = stream->public.sink;
+	if (stream->output_signal == SIGNAL_TYPE_NONE) {
+		struct dc_sink *dc_sink = stream->sink;
 
 		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
 			stream->signal = stream->sink->link->connector_signal;
 		else
 			stream->signal = dc_sink->sink_signal;
 	} else {
-		stream->signal = stream->public.output_signal;
+		stream->signal = stream->output_signal;
 	}
 
 	if (dc_is_dvi_signal(stream->signal)) {
-		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
-			stream->public.sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
+		if (stream->timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+			stream->sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
@@ -1341,12 +1337,12 @@ static void update_stream_signal(struct core_stream *stream)
 }
 
 bool resource_is_stream_unchanged(
-	const struct validate_context *old_context, const struct core_stream *stream)
+	struct validate_context *old_context, struct dc_stream *stream)
 {
 	int i;
 
 	for (i = 0; i < old_context->stream_count; i++) {
-		const struct core_stream *old_stream = old_context->streams[i];
+		struct dc_stream *old_stream = old_context->streams[i];
 
 		if (are_stream_backends_same(old_stream, stream))
 				return true;
@@ -1359,7 +1355,7 @@ static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
 	struct dc_surface *surface = to_pipe_ctx->surface;
-	struct core_stream *stream = to_pipe_ctx->stream;
+	struct dc_stream *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
 	to_pipe_ctx->stream = stream;
@@ -1367,14 +1363,14 @@ static void copy_pipe_ctx(
 		to_pipe_ctx->surface = surface;
 }
 
-static struct core_stream *find_pll_sharable_stream(
-		const struct core_stream *stream_needs_pll,
+static struct dc_stream *find_pll_sharable_stream(
+		struct dc_stream *stream_needs_pll,
 		struct validate_context *context)
 {
 	int i;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream_has_pll = context->streams[i];
+		struct dc_stream *stream_has_pll = context->streams[i];
 
 		/* We are looking for non dp, non virtual stream */
 		if (resource_are_streams_timing_synchronizable(
@@ -1418,17 +1414,17 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-static void calculate_phy_pix_clks(struct core_stream *stream)
+static void calculate_phy_pix_clks(struct dc_stream *stream)
 {
 	update_stream_signal(stream);
 
 	/* update actual pixel clock on all streams */
 	if (dc_is_hdmi_signal(stream->signal))
 		stream->phy_pix_clk = get_norm_pix_clk(
-			&stream->public.timing);
+			&stream->timing);
 	else
 		stream->phy_pix_clk =
-			stream->public.timing.pix_clk_khz;
+			stream->timing.pix_clk_khz;
 }
 
 enum dc_status resource_map_pool_resources(
@@ -1440,7 +1436,7 @@ enum dc_status resource_map_pool_resources(
 	int i, j;
 
 	for (i = 0; old_context && i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (!resource_is_stream_unchanged(old_context, stream)) {
 			if (stream != NULL && old_context->streams[i] != NULL) {
@@ -1493,7 +1489,7 @@ enum dc_status resource_map_pool_resources(
 	}
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 		struct pipe_ctx *pipe_ctx = NULL;
 		int pipe_idx = -1;
 
@@ -1524,7 +1520,7 @@ enum dc_status resource_map_pool_resources(
 		/* TODO: Add check if ASIC support and EDID audio */
 		if (!stream->sink->converter_disable_audio &&
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
-			stream->public.audio_info.mode_count) {
+			stream->audio_info.mode_count) {
 			pipe_ctx->audio = find_first_free_audio(
 				&context->res_ctx, pool);
 
@@ -1560,7 +1556,7 @@ void validate_guaranteed_copy_streams(
 		context->res_ctx.pipe_ctx[i].stream =
 				context->res_ctx.pipe_ctx[0].stream;
 
-		dc_stream_retain(&context->streams[i]->public);
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 }
@@ -1588,7 +1584,7 @@ static void set_avi_info_frame(
 		struct encoder_info_packet *info_packet,
 		struct pipe_ctx *pipe_ctx)
 {
-	struct core_stream *stream = pipe_ctx->stream;
+	struct dc_stream *stream = pipe_ctx->stream;
 	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
 	struct info_frame info_frame = { {0} };
 	uint32_t pixel_encoding = 0;
@@ -1602,12 +1598,12 @@ static void set_avi_info_frame(
 	uint8_t byte_index = 0;
 	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
 	union display_content_support support = {0};
-	unsigned int vic = pipe_ctx->stream->public.timing.vic;
+	unsigned int vic = pipe_ctx->stream->timing.vic;
 	enum dc_timing_3d_format format;
 
-	color_space = pipe_ctx->stream->public.output_color_space;
+	color_space = pipe_ctx->stream->output_color_space;
 	if (color_space == COLOR_SPACE_UNKNOWN)
-		color_space = (stream->public.timing.pixel_encoding == PIXEL_ENCODING_RGB)?
+		color_space = (stream->timing.pixel_encoding == PIXEL_ENCODING_RGB) ?
 			COLOR_SPACE_SRGB:COLOR_SPACE_YCBCR709;
 
 	/* Initialize header */
@@ -1622,7 +1618,7 @@ static void set_avi_info_frame(
 	 * according to HDMI 2.0 spec (Section 10.1)
 	 */
 
-	switch (stream->public.timing.pixel_encoding) {
+	switch (stream->timing.pixel_encoding) {
 	case PIXEL_ENCODING_YCBCR422:
 		pixel_encoding = 1;
 		break;
@@ -1664,7 +1660,7 @@ static void set_avi_info_frame(
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)
 		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU601;
 	else {
-		if (stream->public.timing.pixel_encoding != PIXEL_ENCODING_RGB)
+		if (stream->timing.pixel_encoding != PIXEL_ENCODING_RGB)
 			BREAK_TO_DEBUGGER();
 		hdmi_info->bits.C0_C1 = COLORIMETRY_NO_DATA;
 	}
@@ -1679,7 +1675,7 @@ static void set_avi_info_frame(
 	}
 
 	/* TODO: un-hardcode aspect ratio */
-	aspect = stream->public.timing.aspect_ratio;
+	aspect = stream->timing.aspect_ratio;
 
 	switch (aspect) {
 	case ASPECT_RATIO_4_3:
@@ -1705,7 +1701,7 @@ static void set_avi_info_frame(
 	itc = true;
 	itc_value = 1;
 
-	support = stream->public.sink->edid_caps.content_support;
+	support = stream->sink->edid_caps.content_support;
 
 	if (itc) {
 		if (!support.bits.valid_content_type) {
@@ -1744,8 +1740,8 @@ static void set_avi_info_frame(
 
 	/* TODO : We should handle YCC quantization */
 	/* but we do not have matrix calculation */
-	if (stream->public.sink->edid_caps.qs_bit == 1 &&
-			stream->public.sink->edid_caps.qy_bit == 1) {
+	if (stream->sink->edid_caps.qs_bit == 1 &&
+			stream->sink->edid_caps.qy_bit == 1) {
 		if (color_space == COLOR_SPACE_SRGB ||
 			color_space == COLOR_SPACE_2020_RGB_FULLRANGE) {
 			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
@@ -1764,11 +1760,11 @@ static void set_avi_info_frame(
 	}
 
 	///VIC
-	format = stream->public.timing.timing_3d_format;
+	format = stream->timing.timing_3d_format;
 	/*todo, add 3DStereo support*/
 	if (format != TIMING_3D_FORMAT_NONE) {
 		// Based on HDMI specs hdmi vic needs to be converted to cea vic when 3D is enabled
-		switch (pipe_ctx->stream->public.timing.hdmi_vic) {
+		switch (pipe_ctx->stream->timing.hdmi_vic) {
 		case 1:
 			vic = 95;
 			break;
@@ -1797,12 +1793,12 @@ static void set_avi_info_frame(
 	 * barBottom: Line Number of Start of Bottom Bar.
 	 * barLeft:   Pixel Number of End of Left Bar.
 	 * barRight:  Pixel Number of Start of Right Bar. */
-	hdmi_info->bits.bar_top = stream->public.timing.v_border_top;
-	hdmi_info->bits.bar_bottom = (stream->public.timing.v_total
-			- stream->public.timing.v_border_bottom + 1);
-	hdmi_info->bits.bar_left  = stream->public.timing.h_border_left;
-	hdmi_info->bits.bar_right = (stream->public.timing.h_total
-			- stream->public.timing.h_border_right + 1);
+	hdmi_info->bits.bar_top = stream->timing.v_border_top;
+	hdmi_info->bits.bar_bottom = (stream->timing.v_total
+			- stream->timing.v_border_bottom + 1);
+	hdmi_info->bits.bar_left  = stream->timing.h_border_left;
+	hdmi_info->bits.bar_right = (stream->timing.h_total
+			- stream->timing.h_border_right + 1);
 
 	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
 	check_sum = &info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
@@ -1830,7 +1826,7 @@ static void set_avi_info_frame(
 
 static void set_vendor_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	uint32_t length = 0;
 	bool hdmi_vic_mode = false;
@@ -1842,16 +1838,16 @@ static void set_vendor_info_packet(
 
 	info_packet->valid = false;
 
-	format = stream->public.timing.timing_3d_format;
-	if (stream->public.view_format == VIEW_3D_FORMAT_NONE)
+	format = stream->timing.timing_3d_format;
+	if (stream->view_format == VIEW_3D_FORMAT_NONE)
 		format = TIMING_3D_FORMAT_NONE;
 
 	/* Can be different depending on packet content */
 	length = 5;
 
-	if (stream->public.timing.hdmi_vic != 0
-			&& stream->public.timing.h_total >= 3840
-			&& stream->public.timing.v_total >= 2160)
+	if (stream->timing.hdmi_vic != 0
+			&& stream->timing.h_total >= 3840
+			&& stream->timing.v_total >= 2160)
 		hdmi_vic_mode = true;
 
 	/* According to HDMI 1.4a CTS, VSIF should be sent
@@ -1918,7 +1914,7 @@ static void set_vendor_info_packet(
 	/*PB5: If PB4 is set to 0x1 (extended resolution format)
 	 * fill PB5 with the correct HDMI VIC code */
 	if (hdmi_vic_mode)
-		info_packet->sb[5] = stream->public.timing.hdmi_vic;
+		info_packet->sb[5] = stream->timing.hdmi_vic;
 
 	/* Header */
 	info_packet->hb0 = HDMI_INFOFRAME_TYPE_VENDOR; /* VSIF packet type. */
@@ -1943,7 +1939,7 @@ static void set_vendor_info_packet(
 
 static void set_spd_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	/* SPD info packet for FreeSync */
 
@@ -1953,7 +1949,7 @@ static void set_spd_info_packet(
 	/* Check if Freesync is supported. Return if false. If true,
 	 * set the corresponding bit in the info packet
 	 */
-	if (stream->public.freesync_ctx.supported == false)
+	if (stream->freesync_ctx.supported == false)
 		return;
 
 	if (dc_is_hdmi_signal(stream->signal)) {
@@ -2018,20 +2014,20 @@ static void set_spd_info_packet(
 	/* PB6 = [Bits 7:3 = Reserved] */
 	info_packet->sb[6] = 0x00;
 
-	if (stream->public.freesync_ctx.supported == true)
+	if (stream->freesync_ctx.supported == true)
 		/* PB6 = [Bit 0 = FreeSync Supported] */
 		info_packet->sb[6] |= 0x01;
 
-	if (stream->public.freesync_ctx.enabled == true)
+	if (stream->freesync_ctx.enabled == true)
 		/* PB6 = [Bit 1 = FreeSync Enabled] */
 		info_packet->sb[6] |= 0x02;
 
-	if (stream->public.freesync_ctx.active == true)
+	if (stream->freesync_ctx.active == true)
 		/* PB6 = [Bit 2 = FreeSync Active] */
 		info_packet->sb[6] |= 0x04;
 
 	/* PB7 = FreeSync Minimum refresh rate (Hz) */
-	info_packet->sb[7] = (unsigned char) (stream->public.freesync_ctx.
+	info_packet->sb[7] = (unsigned char) (stream->freesync_ctx.
 			min_refresh_in_micro_hz / 1000000);
 
 	/* PB8 = FreeSync Maximum refresh rate (Hz)
@@ -2040,7 +2036,7 @@ static void set_spd_info_packet(
 	 * of the panel, because we should never go above the field
 	 * rate of the mode timing set.
 	 */
-	info_packet->sb[8] = (unsigned char) (stream->public.freesync_ctx.
+	info_packet->sb[8] = (unsigned char) (stream->freesync_ctx.
 			nominal_refresh_in_micro_hz / 1000000);
 
 	/* PB9 - PB27  = Reserved */
@@ -2065,7 +2061,7 @@ static void set_spd_info_packet(
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
 		struct dc_surface *surface,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
@@ -2168,7 +2164,7 @@ static void set_hdr_static_info_packet(
 
 static void set_vsc_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_stream *stream)
+		struct dc_stream *stream)
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
@@ -2218,7 +2214,7 @@ void dc_resource_validate_ctx_destruct(struct validate_context *context)
 				context->stream_status[i].surfaces[j]);
 
 		context->stream_status[i].surface_count = 0;
-		dc_stream_release(&context->streams[i]->public);
+		dc_stream_release(context->streams[i]);
 		context->streams[i] = NULL;
 	}
 }
@@ -2248,7 +2244,7 @@ void dc_resource_validate_ctx_copy_construct(
 	}
 
 	for (i = 0; i < dst_ctx->stream_count; i++) {
-		dc_stream_retain(&dst_ctx->streams[i]->public);
+		dc_stream_retain(dst_ctx->streams[i]);
 		for (j = 0; j < dst_ctx->stream_status[i].surface_count; j++)
 			dc_surface_retain(
 				dst_ctx->stream_status[i].surfaces[j]);
@@ -2321,7 +2317,7 @@ enum dc_status resource_map_clock_resources(
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
-		const struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -2401,12 +2397,12 @@ bool pipe_need_reprogram(
 	return false;
 }
 
-void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
+void resource_build_bit_depth_reduction_params(struct dc_stream *stream,
 		struct bit_depth_reduction_params *fmt_bit_depth)
 {
-	enum dc_dither_option option = stream->public.dither_option;
+	enum dc_dither_option option = stream->dither_option;
 	enum dc_pixel_encoding pixel_encoding =
-			stream->public.timing.pixel_encoding;
+			stream->timing.pixel_encoding;
 
 	memset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));
 
@@ -2511,31 +2507,30 @@ void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
 
-bool dc_validate_stream(const struct dc *dc, const struct dc_stream *stream)
+bool dc_validate_stream(const struct dc *dc, struct dc_stream *stream)
 {
 	struct core_dc *core_dc = DC_TO_CORE(dc);
 	struct dc_context *dc_ctx = core_dc->ctx;
-	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
-	struct dc_link *link = core_stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
 	enum dc_status res = DC_OK;
 
-	calculate_phy_pix_clks(core_stream);
+	calculate_phy_pix_clks(stream);
 
-	if (!tg->funcs->validate_timing(tg, &core_stream->public.timing))
+	if (!tg->funcs->validate_timing(tg, &stream->timing))
 		res = DC_FAIL_CONTROLLER_VALIDATE;
 
 	if (res == DC_OK)
 		if (!link->link_enc->funcs->validate_output_with_stream(
-						link->link_enc, core_stream))
+						link->link_enc, stream))
 			res = DC_FAIL_ENC_VALIDATE;
 
 	/* TODO: validate audio ASIC caps, encoder */
 
 	if (res == DC_OK)
-		res = dc_link_validate_mode_timing(core_stream,
+		res = dc_link_validate_mode_timing(stream,
 		      link,
-		      &core_stream->public.timing);
+		      &stream->timing);
 
 	if (res != DC_OK)
 		DC_ERROR("Failed validation for stream %p, err:%d, !\n",

commit b3d6c3f0f676a06820aa23c9f8590e080d6f6765
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 14:04:27 2017 -0400

    drm/amd/display: Minor fix for dc_sink refactor
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index dea2943392e4..eeefc9c33633 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1321,7 +1321,7 @@ static struct audio *find_first_free_audio(
 static void update_stream_signal(struct core_stream *stream)
 {
 	if (stream->public.output_signal == SIGNAL_TYPE_NONE) {
-		const struct dc_sink *dc_sink = stream->public.sink;
+		struct dc_sink *dc_sink = stream->public.sink;
 
 		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
 			stream->signal = stream->sink->link->connector_signal;

commit 3639fa68122154b453eeaac840daadf3c7c56db4
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Tue Jul 25 15:14:24 2017 -0400

    drm/amd/display: Clean up some DCN1 guards
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4403d8244407..dea2943392e4 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -120,6 +120,8 @@ struct resource_pool *dc_create_resource_pool(
 			num_virtual_links, dc);
 		break;
 #endif
+
+
 	default:
 		break;
 	}

commit 9345d9874c324b2f8cce79d4de11f27ae1ef80e9
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Jul 21 16:34:36 2017 -0400

    drm/amd/display: Move stream validations into seperate function.
    
    Stateless streams validations (not require resource population)
    moved into hook to be called directly from DM.
    
    Call dc_validate_stream be before validate_with_context for
    non Linux APIs
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7cb572ff3cba..4403d8244407 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1416,23 +1416,17 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-static void calculate_phy_pix_clks(struct validate_context *context)
+static void calculate_phy_pix_clks(struct core_stream *stream)
 {
-	int i;
-
-	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
-
-		update_stream_signal(stream);
-
-		/* update actual pixel clock on all streams */
-		if (dc_is_hdmi_signal(stream->signal))
-			stream->phy_pix_clk = get_norm_pix_clk(
-				&stream->public.timing);
-		else
-			stream->phy_pix_clk =
-				stream->public.timing.pix_clk_khz;
-	}
+	update_stream_signal(stream);
+
+	/* update actual pixel clock on all streams */
+	if (dc_is_hdmi_signal(stream->signal))
+		stream->phy_pix_clk = get_norm_pix_clk(
+			&stream->public.timing);
+	else
+		stream->phy_pix_clk =
+			stream->public.timing.pix_clk_khz;
 }
 
 enum dc_status resource_map_pool_resources(
@@ -1443,8 +1437,6 @@ enum dc_status resource_map_pool_resources(
 	const struct resource_pool *pool = dc->res_pool;
 	int i, j;
 
-	calculate_phy_pix_clks(context);
-
 	for (i = 0; old_context && i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
 
@@ -2516,3 +2508,36 @@ void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
 
 	fmt_bit_depth->pixel_encoding = pixel_encoding;
 }
+
+bool dc_validate_stream(const struct dc *dc, const struct dc_stream *stream)
+{
+	struct core_dc *core_dc = DC_TO_CORE(dc);
+	struct dc_context *dc_ctx = core_dc->ctx;
+	struct core_stream *core_stream = DC_STREAM_TO_CORE(stream);
+	struct dc_link *link = core_stream->sink->link;
+	struct timing_generator *tg = core_dc->res_pool->timing_generators[0];
+	enum dc_status res = DC_OK;
+
+	calculate_phy_pix_clks(core_stream);
+
+	if (!tg->funcs->validate_timing(tg, &core_stream->public.timing))
+		res = DC_FAIL_CONTROLLER_VALIDATE;
+
+	if (res == DC_OK)
+		if (!link->link_enc->funcs->validate_output_with_stream(
+						link->link_enc, core_stream))
+			res = DC_FAIL_ENC_VALIDATE;
+
+	/* TODO: validate audio ASIC caps, encoder */
+
+	if (res == DC_OK)
+		res = dc_link_validate_mode_timing(core_stream,
+		      link,
+		      &core_stream->public.timing);
+
+	if (res != DC_OK)
+		DC_ERROR("Failed validation for stream %p, err:%d, !\n",
+				stream, res);
+
+	return res == DC_OK;
+}

commit b73a22d3257f9ec237c46be12d74b58d5a925d8c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jul 24 14:04:27 2017 -0400

    drm/amd/display: Roll core_sink into dc_sink
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7a3d090f8465..7cb572ff3cba 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1528,7 +1528,7 @@ enum dc_status resource_map_pool_resources(
 			pipe_ctx->stream_enc);
 
 		/* TODO: Add check if ASIC support and EDID audio */
-		if (!stream->sink->public.converter_disable_audio &&
+		if (!stream->sink->converter_disable_audio &&
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 			stream->public.audio_info.mode_count) {
 			pipe_ctx->audio = find_first_free_audio(

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 303c95432d5b..7a3d090f8465 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1269,7 +1269,7 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 {
 	int i;
 	int j = -1;
-	struct core_link *link = stream->sink->link;
+	struct dc_link *link = stream->sink->link;
 
 	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (!res_ctx->is_stream_enc_acquired[i] &&
@@ -1322,9 +1322,7 @@ static void update_stream_signal(struct core_stream *stream)
 		const struct dc_sink *dc_sink = stream->public.sink;
 
 		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-			stream->signal =
-					stream->sink->link->
-					public.connector_signal;
+			stream->signal = stream->sink->link->connector_signal;
 		else
 			stream->signal = dc_sink->sink_signal;
 	} else {
@@ -1380,7 +1378,7 @@ static struct core_stream *find_pll_sharable_stream(
 		if (resource_are_streams_timing_synchronizable(
 			stream_needs_pll, stream_has_pll)
 			&& !dc_is_dp_signal(stream_has_pll->signal)
-			&& stream_has_pll->sink->link->public.connector_signal
+			&& stream_has_pll->sink->link->connector_signal
 			!= SIGNAL_TYPE_VIRTUAL)
 			return stream_has_pll;
 

commit e12cfcb1d447cc937d1abc6f4aab8bbe5f88542e
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 20 11:43:32 2017 -0400

    drm/amd/display: Roll core_surface into dc_surface
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 5acc5cdcda16..303c95432d5b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -428,7 +428,7 @@ static void rect_swap_helper(struct rect *rect)
 
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	const struct dc_stream *stream = &pipe_ctx->stream->public;
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
@@ -446,8 +446,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		sec_split = false;
 	}
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	/* The actual clip is an intersection between stream
@@ -527,14 +527,14 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	struct core_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	struct rect surf_clip = surface->clip_rect;
 	int recout_full_x, recout_full_y;
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
@@ -605,7 +605,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	struct core_stream *stream = pipe_ctx->stream;
 	struct rect surf_src = surface->src_rect;
 	const int in_w = stream->public.src.width;
@@ -613,8 +613,8 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 	const int out_w = stream->public.dst.width;
 	const int out_h = stream->public.dst.height;
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270)
 		rect_swap_helper(&surf_src);
 
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
@@ -647,13 +647,13 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect src = pipe_ctx->surface->public.src_rect;
+	struct rect src = pipe_ctx->surface->src_rect;
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
 			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
@@ -803,8 +803,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
 
-	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
-			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+	if (pipe_ctx->surface->rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->rotation == ROTATION_ANGLE_270) {
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}
@@ -812,7 +812,7 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 {
-	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_surface *surface = pipe_ctx->surface;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
@@ -822,7 +822,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
 	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
-			pipe_ctx->surface->public.format);
+			pipe_ctx->surface->format);
 
 	calculate_scaling_ratios(pipe_ctx);
 
@@ -1029,7 +1029,7 @@ static int acquire_first_split_pipe(
 #endif
 
 bool resource_attach_surfaces_to_context(
-		const struct dc_surface * const *surfaces,
+		struct dc_surface * const *surfaces,
 		int surface_count,
 		const struct dc_stream *dc_stream,
 		struct validate_context *context,
@@ -1077,7 +1077,7 @@ bool resource_attach_surfaces_to_context(
 
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
-		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
+		struct dc_surface *surface = surfaces[i];
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, dc_stream);
 
@@ -1358,7 +1358,7 @@ bool resource_is_stream_unchanged(
 static void copy_pipe_ctx(
 	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
 {
-	struct core_surface *surface = to_pipe_ctx->surface;
+	struct dc_surface *surface = to_pipe_ctx->surface;
 	struct core_stream *stream = to_pipe_ctx->stream;
 
 	*to_pipe_ctx = *from_pipe_ctx;
@@ -2072,7 +2072,7 @@ static void set_spd_info_packet(
 
 static void set_hdr_static_info_packet(
 		struct encoder_info_packet *info_packet,
-		struct core_surface *surface,
+		struct dc_surface *surface,
 		struct core_stream *stream)
 {
 	uint16_t i = 0;
@@ -2083,7 +2083,7 @@ static void set_hdr_static_info_packet(
 	if (!surface)
 		return;
 
-	hdr_metadata = surface->public.hdr_static_ctx;
+	hdr_metadata = surface->hdr_static_ctx;
 
 	if (!hdr_metadata.hdr_supported)
 		return;

commit 50e27654d778114382093eecc1d6e5b7e9343d23
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Thu Jul 20 19:04:56 2017 -0400

    drm/amd/display: Implement logic for hdmi info packet bits.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 63056e8c6d78..5acc5cdcda16 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1603,10 +1603,13 @@ static void set_avi_info_frame(
 	enum scanning_type scan_type = SCANNING_TYPE_NODATA;
 	enum dc_aspect_ratio aspect = ASPECT_RATIO_NO_DATA;
 	bool itc = false;
+	uint8_t itc_value = 0;
 	uint8_t cn0_cn1 = 0;
+	unsigned int cn0_cn1_value = 0;
 	uint8_t *check_sum = NULL;
 	uint8_t byte_index = 0;
 	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
+	union display_content_support support = {0};
 	unsigned int vic = pipe_ctx->stream->public.timing.vic;
 	enum dc_timing_3d_format format;
 
@@ -1703,26 +1706,71 @@ static void set_avi_info_frame(
 	hdmi_info->bits.R0_R3 = ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;
 
 	/* TODO: un-hardcode cn0_cn1 and itc */
+
 	cn0_cn1 = 0;
-	itc = false;
+	cn0_cn1_value = 0;
+
+	itc = true;
+	itc_value = 1;
+
+	support = stream->public.sink->edid_caps.content_support;
 
 	if (itc) {
-		hdmi_info->bits.ITC     = 1;
-		hdmi_info->bits.CN0_CN1 = cn0_cn1;
+		if (!support.bits.valid_content_type) {
+			cn0_cn1_value = 0;
+		} else {
+			if (cn0_cn1 == DISPLAY_CONTENT_TYPE_GRAPHICS) {
+				if (support.bits.graphics_content == 1) {
+					cn0_cn1_value = 0;
+				}
+			} else if (cn0_cn1 == DISPLAY_CONTENT_TYPE_PHOTO) {
+				if (support.bits.photo_content == 1) {
+					cn0_cn1_value = 1;
+				} else {
+					cn0_cn1_value = 0;
+					itc_value = 0;
+				}
+			} else if (cn0_cn1 == DISPLAY_CONTENT_TYPE_CINEMA) {
+				if (support.bits.cinema_content == 1) {
+					cn0_cn1_value = 2;
+				} else {
+					cn0_cn1_value = 0;
+					itc_value = 0;
+				}
+			} else if (cn0_cn1 == DISPLAY_CONTENT_TYPE_GAME) {
+				if (support.bits.game_content == 1) {
+					cn0_cn1_value = 3;
+				} else {
+					cn0_cn1_value = 0;
+					itc_value = 0;
+				}
+			}
+		}
+		hdmi_info->bits.CN0_CN1 = cn0_cn1_value;
+		hdmi_info->bits.ITC = itc_value;
 	}
 
 	/* TODO : We should handle YCC quantization */
 	/* but we do not have matrix calculation */
-	if (color_space == COLOR_SPACE_SRGB) {
-		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
-		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_FULL_RANGE;
-	} else if (color_space == COLOR_SPACE_SRGB_LIMITED) {
-		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;
-		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
+	if (stream->public.sink->edid_caps.qs_bit == 1 &&
+			stream->public.sink->edid_caps.qy_bit == 1) {
+		if (color_space == COLOR_SPACE_SRGB ||
+			color_space == COLOR_SPACE_2020_RGB_FULLRANGE) {
+			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
+			hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_FULL_RANGE;
+		} else if (color_space == COLOR_SPACE_SRGB_LIMITED ||
+					color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE) {
+			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;
+			hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
+		} else {
+			hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
+			hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
+		}
 	} else {
 		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
-		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
+		hdmi_info->bits.YQ0_YQ1   = YYC_QUANTIZATION_LIMITED_RANGE;
 	}
+
 	///VIC
 	format = stream->public.timing.timing_3d_format;
 	/*todo, add 3DStereo support*/

commit 15e173352eeae76286e0d018f9eec6b55726caa4
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jul 17 16:04:02 2017 -0400

    drm/amd/display: fix aviInfoFrame bar Info and add set_avMute
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9d0128e95767..63056e8c6d78 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1607,6 +1607,8 @@ static void set_avi_info_frame(
 	uint8_t *check_sum = NULL;
 	uint8_t byte_index = 0;
 	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
+	unsigned int vic = pipe_ctx->stream->public.timing.vic;
+	enum dc_timing_3d_format format;
 
 	color_space = pipe_ctx->stream->public.output_color_space;
 	if (color_space == COLOR_SPACE_UNKNOWN)
@@ -1661,8 +1663,7 @@ static void set_avi_info_frame(
 
 	/* C0, C1 : Colorimetry */
 	if (color_space == COLOR_SPACE_YCBCR709 ||
-			color_space == COLOR_SPACE_YCBCR709_LIMITED ||
-			color_space == COLOR_SPACE_2020_YCBCR)
+			color_space == COLOR_SPACE_YCBCR709_LIMITED)
 		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU709;
 	else if (color_space == COLOR_SPACE_YCBCR601 ||
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)
@@ -1722,9 +1723,29 @@ static void set_avi_info_frame(
 		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
 		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
 	}
-
-	hdmi_info->bits.VIC0_VIC7 =
-					stream->public.timing.vic;
+	///VIC
+	format = stream->public.timing.timing_3d_format;
+	/*todo, add 3DStereo support*/
+	if (format != TIMING_3D_FORMAT_NONE) {
+		// Based on HDMI specs hdmi vic needs to be converted to cea vic when 3D is enabled
+		switch (pipe_ctx->stream->public.timing.hdmi_vic) {
+		case 1:
+			vic = 95;
+			break;
+		case 2:
+			vic = 94;
+			break;
+		case 3:
+			vic = 93;
+			break;
+		case 4:
+			vic = 98;
+			break;
+		default:
+			break;
+		}
+	}
+	hdmi_info->bits.VIC0_VIC7 = vic;
 
 	/* pixel repetition
 	 * PR0 - PR3 start from 0 whereas pHwPathMode->mode.timing.flags.pixel
@@ -1737,7 +1758,7 @@ static void set_avi_info_frame(
 	 * barLeft:   Pixel Number of End of Left Bar.
 	 * barRight:  Pixel Number of Start of Right Bar. */
 	hdmi_info->bits.bar_top = stream->public.timing.v_border_top;
-	hdmi_info->bits.bar_bottom = (stream->public.timing.v_border_top
+	hdmi_info->bits.bar_bottom = (stream->public.timing.v_total
 			- stream->public.timing.v_border_bottom + 1);
 	hdmi_info->bits.bar_left  = stream->public.timing.h_border_left;
 	hdmi_info->bits.bar_right = (stream->public.timing.h_total
@@ -1776,6 +1797,10 @@ static void set_vendor_info_packet(
 	uint8_t checksum = 0;
 	uint32_t i = 0;
 	enum dc_timing_3d_format format;
+	// Can be different depending on packet content /*todo*/
+	// unsigned int length = pPathMode->dolbyVision ? 24 : 5;
+
+	info_packet->valid = false;
 
 	format = stream->public.timing.timing_3d_format;
 	if (stream->public.view_format == VIEW_3D_FORMAT_NONE)

commit 9294c7763fdc3da62dbf74a279921120c8f76721
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Jul 12 15:49:46 2017 -0400

    drm/amd/display: fix 4k@30 with 10bit deep color and avi for BT2020
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 78ba5c6d9ac2..9d0128e95767 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1661,7 +1661,8 @@ static void set_avi_info_frame(
 
 	/* C0, C1 : Colorimetry */
 	if (color_space == COLOR_SPACE_YCBCR709 ||
-			color_space == COLOR_SPACE_YCBCR709_LIMITED)
+			color_space == COLOR_SPACE_YCBCR709_LIMITED ||
+			color_space == COLOR_SPACE_2020_YCBCR)
 		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU709;
 	else if (color_space == COLOR_SPACE_YCBCR601 ||
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)

commit 9a3afbb3ea37b9a6bc16b9d6e4a51b183724158d
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Tue Jul 11 18:36:42 2017 -0400

    drm/amd/display: dc_validate_ctx refocunt fixes.
    
    In dc_resource_validate_ctx_copy_construct don't override dst
    context refcount.
    
    Remove extra retain to new ctx in dc_update_surfaces_and_stream
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 5a5ed37474bf..78ba5c6d9ac2 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2166,6 +2166,7 @@ void dc_resource_validate_ctx_copy_construct(
 		struct validate_context *dst_ctx)
 {
 	int i, j;
+	int ref_count = dst_ctx->ref_count;
 
 	*dst_ctx = *src_ctx;
 
@@ -2186,6 +2187,10 @@ void dc_resource_validate_ctx_copy_construct(
 			dc_surface_retain(
 				dst_ctx->stream_status[i].surfaces[j]);
 	}
+
+	/* context refcount should not be overridden */
+	dst_ctx->ref_count = ref_count;
+
 }
 
 struct clock_source *dc_resource_find_first_free_pll(

commit 87449a90c2545eaed5757153770346563378463b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Jul 6 14:27:49 2017 -0400

    drm/amd/display: Fix MPO visual confirm
    
    1. Need to blend non-active area to show visual confirm borders
    2. Set number of Visual Confirm lines based on pipe instance
    3. Set Different colors representing surface format of bottom most plan
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ddf032214dc3..5a5ed37474bf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -399,11 +399,11 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 		break;
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
-		dal_pixel_format = PIXEL_FORMAT_420BPP12;
+		dal_pixel_format = PIXEL_FORMAT_420BPP8;
 		break;
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
-		dal_pixel_format = PIXEL_FORMAT_420BPP15;
+		dal_pixel_format = PIXEL_FORMAT_420BPP10;
 		break;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
 	default:
@@ -433,8 +433,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect surf_src = surface->src_rect;
 	struct rect clip = { 0 };
-	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
-			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
+	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
+			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 	bool pri_split = pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface;
 	bool sec_split = pipe_ctx->top_pipe &&
@@ -637,8 +637,8 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 	pipe_ctx->scl_data.ratios.horz_c = pipe_ctx->scl_data.ratios.horz;
 	pipe_ctx->scl_data.ratios.vert_c = pipe_ctx->scl_data.ratios.vert;
 
-	if (pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP12
-			|| pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP15) {
+	if (pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP8
+			|| pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP10) {
 		pipe_ctx->scl_data.ratios.horz_c.value /= 2;
 		pipe_ctx->scl_data.ratios.vert_c.value /= 2;
 	}
@@ -648,8 +648,8 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 {
 	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect src = pipe_ctx->surface->public.src_rect;
-	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
-			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
+	int vpc_div = (data->format == PIXEL_FORMAT_420BPP8
+			|| data->format == PIXEL_FORMAT_420BPP10) ? 2 : 1;
 
 
 	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||

commit cdc5e04888cec337e44049f9b51d8894364ad52a
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Jun 28 13:36:25 2017 -0500

    drm/amd/display: Fix for hdmi frame pack stereo
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fb033b69e2bf..ddf032214dc3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -626,7 +626,7 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 
 	if (stream->public.view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
-	else if (surface->stereo_format == PLANE_STEREO_FORMAT_TOP_AND_BOTTOM)
+	else if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 		pipe_ctx->scl_data.ratios.vert.value *= 2;
 
 	pipe_ctx->scl_data.ratios.vert.value = div64_s64(

commit cfe4645e17f8dbe680c35c439d000313f2648482
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jun 14 18:58:04 2017 -0400

    drm/amd/display: fix dcn pipe reset sequence
    
    This change fixes dcn10 front end reset sequence. Previously we
    would reset front end during flip which led to issues
    in certain MPO and 4k/5k scenarios. We would also never properly
    power gate our front end.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f0183d5f0d0d..fb033b69e2bf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1096,6 +1096,10 @@ bool resource_attach_surfaces_to_context(
 		free_pipe->surface = surface;
 
 		if (tail_pipe) {
+			free_pipe->tg = tail_pipe->tg;
+			free_pipe->stream_enc = tail_pipe->stream_enc;
+			free_pipe->audio = tail_pipe->audio;
+			free_pipe->clock_source = tail_pipe->clock_source;
 			free_pipe->top_pipe = tail_pipe;
 			tail_pipe->bottom_pipe = free_pipe;
 		}
@@ -2300,6 +2304,9 @@ bool pipe_need_reprogram(
 		struct pipe_ctx *pipe_ctx_old,
 		struct pipe_ctx *pipe_ctx)
 {
+	if (!pipe_ctx_old->stream)
+		return false;
+
 	if (pipe_ctx_old->stream->sink != pipe_ctx->stream->sink)
 		return true;
 

commit e5f2038ef12cf5606ec3d7c79e2539cafcb409dd
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Sat Jun 24 16:01:37 2017 -0400

    drm/amd/display: w/a no color space info for HDMI when build AVI
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 90eb839f5414..f0183d5f0d0d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1605,6 +1605,9 @@ static void set_avi_info_frame(
 	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
 
 	color_space = pipe_ctx->stream->public.output_color_space;
+	if (color_space == COLOR_SPACE_UNKNOWN)
+		color_space = (stream->public.timing.pixel_encoding == PIXEL_ENCODING_RGB)?
+			COLOR_SPACE_SRGB:COLOR_SPACE_YCBCR709;
 
 	/* Initialize header */
 	hdmi_info->bits.header.info_frame_type = HDMI_INFOFRAME_TYPE_AVI;

commit 7f5c22d1652327b64375e88b184b0df502c7bdc7
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Thu Jun 8 15:55:02 2017 -0500

    drm/amd/display: RV stereo support
    
    HDMI frame pack and DP frame alternate in band
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c51ec617eff7..90eb839f5414 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -440,8 +440,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
 
-	if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_SIDE_BY_SIDE ||
-		stream->timing.timing_3d_format == TIMING_3D_FORMAT_TOP_AND_BOTTOM) {
+	if (stream->view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE ||
+		stream->view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 		pri_split = false;
 		sec_split = false;
 	}
@@ -568,8 +568,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	/* Handle h & vsplit */
 	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
 		pipe_ctx->surface) {
-		if (stream->public.timing.timing_3d_format ==
-			TIMING_3D_FORMAT_TOP_AND_BOTTOM) {
+		if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM) {
 			pipe_ctx->scl_data.recout.height /= 2;
 			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
 			/* Floor primary pipe, ceil 2ndary pipe */
@@ -581,8 +580,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 		}
 	} else if (pipe_ctx->bottom_pipe &&
 			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
-		if (stream->public.timing.timing_3d_format ==
-			TIMING_3D_FORMAT_TOP_AND_BOTTOM)
+		if (stream->public.view_format == VIEW_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
 		else
 			pipe_ctx->scl_data.recout.width /= 2;
@@ -626,7 +624,7 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 					surf_src.height,
 					surface->dst_rect.height);
 
-	if (surface->stereo_format == PLANE_STEREO_FORMAT_SIDE_BY_SIDE)
+	if (stream->public.view_format == VIEW_3D_FORMAT_SIDE_BY_SIDE)
 		pipe_ctx->scl_data.ratios.horz.value *= 2;
 	else if (surface->stereo_format == PLANE_STEREO_FORMAT_TOP_AND_BOTTOM)
 		pipe_ctx->scl_data.ratios.vert.value *= 2;
@@ -1772,6 +1770,8 @@ static void set_vendor_info_packet(
 	enum dc_timing_3d_format format;
 
 	format = stream->public.timing.timing_3d_format;
+	if (stream->public.view_format == VIEW_3D_FORMAT_NONE)
+		format = TIMING_3D_FORMAT_NONE;
 
 	/* Can be different depending on packet content */
 	length = 5;

commit f0558542a72e72919dae2ac2187847ec312c2bcb
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Jun 1 18:35:54 2017 -0400

    drm/amd/display: redesign mpc
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index b7f31b985b4f..c51ec617eff7 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1008,8 +1008,6 @@ static int acquire_first_split_pipe(
 
 		if (pipe_ctx->top_pipe &&
 				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
-			int mpc_idx = pipe_ctx->mpc_idx;
-
 			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
 			if (pipe_ctx->bottom_pipe)
 				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
@@ -1021,8 +1019,8 @@ static int acquire_first_split_pipe(
 			pipe_ctx->xfm = pool->transforms[i];
 			pipe_ctx->opp = pool->opps[i];
 			pipe_ctx->dis_clk = pool->display_clock;
+			pipe_ctx->mpcc = pool->mpcc[i];
 			pipe_ctx->pipe_idx = i;
-			pipe_ctx->mpc_idx = mpc_idx;
 
 			pipe_ctx->stream = stream;
 			return i;
@@ -1243,6 +1241,9 @@ static int acquire_first_free_pipe(
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+			pipe_ctx->mpcc = pool->mpcc[i];
+#endif
 			pipe_ctx->tg = pool->timing_generators[i];
 			pipe_ctx->mi = pool->mis[i];
 			pipe_ctx->ipp = pool->ipps[i];
@@ -1251,9 +1252,6 @@ static int acquire_first_free_pipe(
 			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-			pipe_ctx->mpc_idx = -1;
-#endif
 
 			pipe_ctx->stream = stream;
 			return i;

commit 909e8c9e417945f313b68ed6c5a559fe5266be8b
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Jun 5 16:54:33 2017 -0400

    drm/amd/display: fix single link black screen
    
    Don't fall back to dual link DVI mode if the connector
    is single Link only.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index e4a6636fd829..b7f31b985b4f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1204,6 +1204,7 @@ bool resource_validate_attach_surfaces(
 
 /* Maximum TMDS single link pixel clock 165MHz */
 #define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
+#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST 297000
 
 static void set_stream_engine_in_use(
 		struct resource_context *res_ctx,
@@ -1331,7 +1332,8 @@ static void update_stream_signal(struct core_stream *stream)
 	}
 
 	if (dc_is_dvi_signal(stream->signal)) {
-		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
+		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ_UPMOST &&
+			stream->public.sink->sink_signal != SIGNAL_TYPE_DVI_SINGLE_LINK)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;

commit 0f9a536fe036eed82b563b0da5b2c57a9455b679
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 30 13:38:10 2017 -0400

    drm/amd/display: fix mpo + split pipe aquisition failure
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index e6e3b181a3dc..e4a6636fd829 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -995,6 +995,43 @@ static void release_free_pipes_for_stream(
 	}
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+static int acquire_first_split_pipe(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
+		struct core_stream *stream)
+{
+	int i;
+
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->top_pipe &&
+				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+			int mpc_idx = pipe_ctx->mpc_idx;
+
+			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
+			if (pipe_ctx->bottom_pipe)
+				pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
+
+			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
+			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->mi = pool->mis[i];
+			pipe_ctx->ipp = pool->ipps[i];
+			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
+			pipe_ctx->pipe_idx = i;
+			pipe_ctx->mpc_idx = mpc_idx;
+
+			pipe_ctx->stream = stream;
+			return i;
+		}
+	}
+	return -1;
+}
+#endif
+
 bool resource_attach_surfaces_to_context(
 		const struct dc_surface * const *surfaces,
 		int surface_count,
@@ -1048,6 +1085,13 @@ bool resource_attach_surfaces_to_context(
 		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
 				context, pool, dc_stream);
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		if (!free_pipe) {
+			int pipe_idx = acquire_first_split_pipe(&context->res_ctx, pool, stream);
+			if (pipe_idx >= 0)
+				free_pipe = &context->res_ctx.pipe_ctx[pipe_idx];
+		}
+#endif
 		if (!free_pipe) {
 			stream_status->surfaces[i] = NULL;
 			return false;
@@ -1391,42 +1435,6 @@ static void calculate_phy_pix_clks(struct validate_context *context)
 	}
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
-static int acquire_first_split_pipe(
-		struct resource_context *res_ctx,
-		const struct resource_pool *pool,
-		struct core_stream *stream)
-{
-	int i;
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
-
-		if (pipe_ctx->top_pipe &&
-				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
-			int mpc_idx = pipe_ctx->mpc_idx;
-
-			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
-			pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
-
-			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
-			pipe_ctx->tg = pool->timing_generators[i];
-			pipe_ctx->mi = pool->mis[i];
-			pipe_ctx->ipp = pool->ipps[i];
-			pipe_ctx->xfm = pool->transforms[i];
-			pipe_ctx->opp = pool->opps[i];
-			pipe_ctx->dis_clk = pool->display_clock;
-			pipe_ctx->pipe_idx = i;
-			pipe_ctx->mpc_idx = mpc_idx;
-
-			pipe_ctx->stream = stream;
-			return i;
-		}
-	}
-	return -1;
-}
-#endif
-
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context,

commit 05a19c39cb0adcb0f73b7418b9afead49d2406d4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon May 29 18:26:28 2017 -0400

    drm/amd/display: fix surface attachment handling of pipe split
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 124fcac63eba..e6e3b181a3dc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -894,24 +894,6 @@ enum dc_status resource_build_scaling_params_for_context(
 	return DC_OK;
 }
 
-static void detach_surfaces_for_stream(
-		struct validate_context *context,
-		const struct resource_pool *pool,
-		const struct dc_stream *dc_stream)
-{
-	int i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
-
-	for (i = 0; i < pool->pipe_count; i++) {
-		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
-		if (cur_pipe->stream == stream) {
-			cur_pipe->surface = NULL;
-			cur_pipe->top_pipe = NULL;
-			cur_pipe->bottom_pipe = NULL;
-		}
-	}
-}
-
 struct pipe_ctx *find_idle_secondary_pipe(
 		struct resource_context *res_ctx,
 		const struct resource_pool *pool)
@@ -1004,9 +986,11 @@ static void release_free_pipes_for_stream(
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	for (i = MAX_PIPES - 1; i >= 0; i--) {
+		/* never release the topmost pipe*/
 		if (res_ctx->pipe_ctx[i].stream == stream &&
+				res_ctx->pipe_ctx[i].top_pipe &&
 				!res_ctx->pipe_ctx[i].surface) {
-			res_ctx->pipe_ctx[i].stream = NULL;
+			memset(&res_ctx->pipe_ctx[i], 0, sizeof(struct pipe_ctx));
 		}
 	}
 }
@@ -1021,6 +1005,7 @@ bool resource_attach_surfaces_to_context(
 	int i;
 	struct pipe_ctx *tail_pipe;
 	struct dc_stream_status *stream_status = NULL;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 
 	if (surface_count > MAX_SURFACE_NUM) {
@@ -1043,7 +1028,12 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++)
 		dc_surface_retain(surfaces[i]);
 
-	detach_surfaces_for_stream(context, pool, dc_stream);
+	/* detach surfaces from pipes */
+	for (i = 0; i < pool->pipe_count; i++)
+		if (context->res_ctx.pipe_ctx[i].stream == stream) {
+			context->res_ctx.pipe_ctx[i].surface = NULL;
+			context->res_ctx.pipe_ctx[i].bottom_pipe = NULL;
+		}
 
 	/* release existing surfaces*/
 	for (i = 0; i < stream_status->surface_count; i++)
@@ -1052,11 +1042,6 @@ bool resource_attach_surfaces_to_context(
 	for (i = surface_count; i < stream_status->surface_count; i++)
 		stream_status->surfaces[i] = NULL;
 
-	stream_status->surface_count = 0;
-
-	if (surface_count == 0)
-		return true;
-
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);

commit 5d11e9fca5b45191b531d8fa3b9dd6de1156fc2b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon May 29 18:29:33 2017 -0400

    drm/amd/display: allow taking split pipes during resource mapping
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6202b4b3e597..124fcac63eba 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1406,6 +1406,42 @@ static void calculate_phy_pix_clks(struct validate_context *context)
 	}
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+static int acquire_first_split_pipe(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
+		struct core_stream *stream)
+{
+	int i;
+
+	for (i = 0; i < pool->pipe_count; i++) {
+		struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+		if (pipe_ctx->top_pipe &&
+				pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+			int mpc_idx = pipe_ctx->mpc_idx;
+
+			pipe_ctx->top_pipe->bottom_pipe = pipe_ctx->bottom_pipe;
+			pipe_ctx->bottom_pipe->top_pipe = pipe_ctx->top_pipe;
+
+			memset(pipe_ctx, 0, sizeof(*pipe_ctx));
+			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->mi = pool->mis[i];
+			pipe_ctx->ipp = pool->ipps[i];
+			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
+			pipe_ctx->pipe_idx = i;
+			pipe_ctx->mpc_idx = mpc_idx;
+
+			pipe_ctx->stream = stream;
+			return i;
+		}
+	}
+	return -1;
+}
+#endif
+
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context,
@@ -1477,8 +1513,11 @@ enum dc_status resource_map_pool_resources(
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
 		/* acquire new resources */
-		pipe_idx = acquire_first_free_pipe(
-				&context->res_ctx, pool, stream);
+		pipe_idx = acquire_first_free_pipe(&context->res_ctx, pool, stream);
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+		if (pipe_idx < 0)
+			acquire_first_split_pipe(&context->res_ctx, pool, stream);
+#endif
 		if (pipe_idx < 0)
 			return DC_NO_CONTROLLER_RESOURCE;
 

commit 630e3573853ff8644daf1ae32a503984110afe28
Author: Jeff Smith <whydoubt@gmail.com>
Date:   Fri May 19 08:32:23 2017 -0500

    drm/amd/display: default spd packet to invalid
    
    Signed-off-by: Jeff Smith <whydoubt@gmail.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ec5045734378..6202b4b3e597 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2172,6 +2172,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 	info->avi.valid = false;
 	info->gamut.valid = false;
 	info->vendor.valid = false;
+	info->spd.valid = false;
 	info->hdrsmd.valid = false;
 	info->vsc.valid = false;
 

commit 430ef426bc43b59a7444c08d664e24a7cf89710e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 17 16:05:40 2017 -0400

    drm/amd/display: make dc_get_validate_context re-entrant
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 7ca03d1ad163..ec5045734378 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1148,7 +1148,7 @@ bool resource_validate_attach_surfaces(
 	int i, j;
 
 	for (i = 0; i < set_count; i++) {
-		for (j = 0; j < old_context->stream_count; j++)
+		for (j = 0; old_context && j < old_context->stream_count; j++)
 			if (is_stream_unchanged(
 					old_context->streams[j],
 					context->streams[i])) {
@@ -1387,9 +1387,7 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 	return normalized_pix_clk;
 }
 
-static void calculate_phy_pix_clks(
-		const struct core_dc *dc,
-		struct validate_context *context)
+static void calculate_phy_pix_clks(struct validate_context *context)
 {
 	int i;
 
@@ -1410,21 +1408,22 @@ static void calculate_phy_pix_clks(
 
 enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
-		struct validate_context *context)
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	const struct resource_pool *pool = dc->res_pool;
 	int i, j;
 
-	calculate_phy_pix_clks(dc, context);
+	calculate_phy_pix_clks(context);
 
-	for (i = 0; i < context->stream_count; i++) {
+	for (i = 0; old_context && i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
 
-		if (!resource_is_stream_unchanged(dc->current_context, stream)) {
-			if (stream != NULL && dc->current_context->streams[i] != NULL) {
+		if (!resource_is_stream_unchanged(old_context, stream)) {
+			if (stream != NULL && old_context->streams[i] != NULL) {
 				stream->bit_depth_params =
-						dc->current_context->streams[i]->bit_depth_params;
-				stream->clamping = dc->current_context->streams[i]->clamping;
+						old_context->streams[i]->bit_depth_params;
+				stream->clamping = old_context->streams[i]->clamping;
 				continue;
 			}
 		}
@@ -1434,7 +1433,7 @@ enum dc_status resource_map_pool_resources(
 			struct pipe_ctx *pipe_ctx =
 				&context->res_ctx.pipe_ctx[j];
 			const struct pipe_ctx *old_pipe_ctx =
-				&dc->current_context->res_ctx.pipe_ctx[j];
+					&old_context->res_ctx.pipe_ctx[j];
 
 			if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
 				continue;
@@ -1475,7 +1474,7 @@ enum dc_status resource_map_pool_resources(
 		struct pipe_ctx *pipe_ctx = NULL;
 		int pipe_idx = -1;
 
-		if (resource_is_stream_unchanged(dc->current_context, stream))
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
 		/* acquire new resources */
 		pipe_idx = acquire_first_free_pipe(
@@ -2203,7 +2202,8 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 
 enum dc_status resource_map_clock_resources(
 		const struct core_dc *dc,
-		struct validate_context *context)
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	int i, j;
 	const struct resource_pool *pool = dc->res_pool;
@@ -2212,7 +2212,7 @@ enum dc_status resource_map_clock_resources(
 	for (i = 0; i < context->stream_count; i++) {
 		const struct core_stream *stream = context->streams[i];
 
-		if (resource_is_stream_unchanged(dc->current_context, stream))
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
 
 		for (j = 0; j < MAX_PIPES; j++) {

commit 86006a7f54c7fb59ccb3061d7a3dcd3c0443b4fe
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 9 16:39:26 2017 -0400

    drm/amd/display: fix scaling calculation for proper surface input format
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9588217e0220..7ca03d1ad163 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -431,6 +431,7 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	const struct dc_stream *stream = &pipe_ctx->stream->public;
 	struct scaler_data *data = &pipe_ctx->scl_data;
+	struct rect surf_src = surface->src_rect;
 	struct rect clip = { 0 };
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
 			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
@@ -444,6 +445,11 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 		pri_split = false;
 		sec_split = false;
 	}
+
+	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+		rect_swap_helper(&surf_src);
+
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
@@ -463,18 +469,18 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			stream->src.y + stream->src.height - clip.y :
 			surface->clip_rect.y + surface->clip_rect.height - clip.y ;
 
-	/* offset = src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
+	/* offset = surf_src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	data->viewport.x = surface->src_rect.x + (clip.x - surface->dst_rect.x) *
-			surface->src_rect.width / surface->dst_rect.width;
+	data->viewport.x = surf_src.x + (clip.x - surface->dst_rect.x) *
+			surf_src.width / surface->dst_rect.width;
 	data->viewport.width = clip.width *
-			surface->src_rect.width / surface->dst_rect.width;
+			surf_src.width / surface->dst_rect.width;
 
-	data->viewport.y = surface->src_rect.y + (clip.y - surface->dst_rect.y) *
-			surface->src_rect.height / surface->dst_rect.height;
+	data->viewport.y = surf_src.y + (clip.y - surface->dst_rect.y) *
+			surf_src.height / surface->dst_rect.height;
 	data->viewport.height = clip.height *
-			surface->src_rect.height / surface->dst_rect.height;
+			surf_src.height / surface->dst_rect.height;
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
@@ -523,16 +529,21 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 {
 	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct core_stream *stream = pipe_ctx->stream;
-	struct rect clip = surface->clip_rect;
+	struct rect surf_src = surface->src_rect;
+	struct rect surf_clip = surface->clip_rect;
 	int recout_full_x, recout_full_y;
 
+	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+		rect_swap_helper(&surf_src);
+
 	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
-	if (stream->public.src.x < clip.x)
-		pipe_ctx->scl_data.recout.x += (clip.x
+	if (stream->public.src.x < surf_clip.x)
+		pipe_ctx->scl_data.recout.x += (surf_clip.x
 			- stream->public.src.x) * stream->public.dst.width
 						/ stream->public.src.width;
 
-	pipe_ctx->scl_data.recout.width = clip.width *
+	pipe_ctx->scl_data.recout.width = surf_clip.width *
 			stream->public.dst.width / stream->public.src.width;
 	if (pipe_ctx->scl_data.recout.width + pipe_ctx->scl_data.recout.x >
 			stream->public.dst.x + stream->public.dst.width)
@@ -541,12 +552,12 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 						- pipe_ctx->scl_data.recout.x;
 
 	pipe_ctx->scl_data.recout.y = stream->public.dst.y;
-	if (stream->public.src.y < clip.y)
-		pipe_ctx->scl_data.recout.y += (clip.y
+	if (stream->public.src.y < surf_clip.y)
+		pipe_ctx->scl_data.recout.y += (surf_clip.y
 			- stream->public.src.y) * stream->public.dst.height
 						/ stream->public.src.height;
 
-	pipe_ctx->scl_data.recout.height = clip.height *
+	pipe_ctx->scl_data.recout.height = surf_clip.height *
 			stream->public.dst.height / stream->public.src.height;
 	if (pipe_ctx->scl_data.recout.height + pipe_ctx->scl_data.recout.y >
 			stream->public.dst.y + stream->public.dst.height)
@@ -569,7 +580,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
 		}
 	} else if (pipe_ctx->bottom_pipe &&
-			   pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
 		if (stream->public.timing.timing_3d_format ==
 			TIMING_3D_FORMAT_TOP_AND_BOTTOM)
 			pipe_ctx->scl_data.recout.height /= 2;
@@ -577,17 +588,17 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			pipe_ctx->scl_data.recout.width /= 2;
 	}
 
-	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream src offset)
-	 * 				* 1/ stream scaling ratio) - (surf src offset * 1/ full scl
+	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream surf_src offset)
+	 * 				* 1/ stream scaling ratio) - (surf surf_src offset * 1/ full scl
 	 * 				ratio)
 	 */
 	recout_full_x = stream->public.dst.x + (surface->dst_rect.x -  stream->public.src.x)
 					* stream->public.dst.width / stream->public.src.width -
-			surface->src_rect.x * surface->dst_rect.width / surface->src_rect.width
+			surf_src.x * surface->dst_rect.width / surf_src.width
 					* stream->public.dst.width / stream->public.src.width;
 	recout_full_y = stream->public.dst.y + (surface->dst_rect.y -  stream->public.src.y)
 					* stream->public.dst.height / stream->public.src.height -
-			surface->src_rect.y * surface->dst_rect.height / surface->src_rect.height
+			surf_src.y * surface->dst_rect.height / surf_src.height
 					* stream->public.dst.height / stream->public.src.height;
 
 	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
@@ -598,16 +609,21 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct core_stream *stream = pipe_ctx->stream;
+	struct rect surf_src = surface->src_rect;
 	const int in_w = stream->public.src.width;
 	const int in_h = stream->public.src.height;
 	const int out_w = stream->public.dst.width;
 	const int out_h = stream->public.dst.height;
 
+	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270)
+		rect_swap_helper(&surf_src);
+
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
-					surface->src_rect.width,
+					surf_src.width,
 					surface->dst_rect.width);
 	pipe_ctx->scl_data.ratios.vert = dal_fixed31_32_from_fraction(
-					surface->src_rect.height,
+					surf_src.height,
 					surface->dst_rect.height);
 
 	if (surface->stereo_format == PLANE_STEREO_FORMAT_SIDE_BY_SIDE)
@@ -637,8 +653,10 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
 			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
 
+
 	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
 			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+		rect_swap_helper(&src);
 		rect_swap_helper(&data->viewport_c);
 		rect_swap_helper(&data->viewport);
 	}

commit 56dcade33fd3c1681a43ebc250523249be3adbb0
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue May 9 10:41:42 2017 -0400

    drm/amd/display: Keep DVI_SINGLE_LINK signal if low clk
    
    If user is using DVI->HDMI dongle dual link signal might pose a
    problem. Keep single link signal type if clk is lower than
    max tmds clk.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ae8b221c85aa..9588217e0220 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1283,9 +1283,12 @@ static void update_stream_signal(struct core_stream *stream)
 		stream->signal = stream->public.output_signal;
 	}
 
-	if (stream->signal == SIGNAL_TYPE_DVI_SINGLE_LINK &&
-		stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
-		stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+	if (dc_is_dvi_signal(stream->signal)) {
+		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
+			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+		else
+			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
+	}
 }
 
 bool resource_is_stream_unchanged(

commit ff5ef99248662ef98a64c11c5370ecd9fbbf57a6
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:27:42 2017 -0400

    drm/amdgpu/display: Enable DCN in DC
    
    Enable DCN in DC.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2de86f8364a3..ae8b221c85aa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -39,6 +39,9 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+#include "dcn10/dcn10_resource.h"
+#endif
 #include "dce120/dce120_resource.h"
 
 enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
@@ -69,6 +72,11 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 	case FAMILY_AI:
 		dc_version = DCE_VERSION_12_0;
 		break;
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	case FAMILY_RV:
+		dc_version = DCN_VERSION_1_0;
+		break;
+#endif
 	default:
 		dc_version = DCE_VERSION_UNKNOWN;
 		break;
@@ -105,6 +113,13 @@ struct resource_pool *dc_create_resource_pool(
 		res_pool = dce120_create_resource_pool(
 			num_virtual_links, dc);
 		break;
+
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+	case DCN_VERSION_1_0:
+		res_pool = dcn10_create_resource_pool(
+			num_virtual_links, dc);
+		break;
+#endif
 	default:
 		break;
 	}
@@ -1188,6 +1203,10 @@ static int acquire_first_free_pipe(
 			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
+#if defined(CONFIG_DRM_AMD_DC_DCN1_0)
+			pipe_ctx->mpc_idx = -1;
+#endif
+
 			pipe_ctx->stream = stream;
 			return i;
 		}

commit 529cad0f945c9e60569e902062d2f2741e4fd71a
Author: Ding Wang <Ding.Wang@amd.com>
Date:   Tue Apr 25 10:03:27 2017 -0400

    drm/amd/display: Add function to set dither option
    
    Signed-off-by: Ding Wang <Ding.Wang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 43e5758719ca..2de86f8364a3 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2246,3 +2246,113 @@ bool pipe_need_reprogram(
 
 	return false;
 }
+
+void resource_build_bit_depth_reduction_params(const struct core_stream *stream,
+		struct bit_depth_reduction_params *fmt_bit_depth)
+{
+	enum dc_dither_option option = stream->public.dither_option;
+	enum dc_pixel_encoding pixel_encoding =
+			stream->public.timing.pixel_encoding;
+
+	memset(fmt_bit_depth, 0, sizeof(*fmt_bit_depth));
+
+	if (option == DITHER_OPTION_DISABLE)
+		return;
+
+	if (option == DITHER_OPTION_TRUN6) {
+		fmt_bit_depth->flags.TRUNCATE_ENABLED = 1;
+		fmt_bit_depth->flags.TRUNCATE_DEPTH = 0;
+	} else if (option == DITHER_OPTION_TRUN8 ||
+			option == DITHER_OPTION_TRUN8_SPATIAL6 ||
+			option == DITHER_OPTION_TRUN8_FM6) {
+		fmt_bit_depth->flags.TRUNCATE_ENABLED = 1;
+		fmt_bit_depth->flags.TRUNCATE_DEPTH = 1;
+	} else if (option == DITHER_OPTION_TRUN10        ||
+			option == DITHER_OPTION_TRUN10_SPATIAL6   ||
+			option == DITHER_OPTION_TRUN10_SPATIAL8   ||
+			option == DITHER_OPTION_TRUN10_FM8     ||
+			option == DITHER_OPTION_TRUN10_FM6     ||
+			option == DITHER_OPTION_TRUN10_SPATIAL8_FM6) {
+		fmt_bit_depth->flags.TRUNCATE_ENABLED = 1;
+		fmt_bit_depth->flags.TRUNCATE_DEPTH = 2;
+	}
+
+	/* special case - Formatter can only reduce by 4 bits at most.
+	 * When reducing from 12 to 6 bits,
+	 * HW recommends we use trunc with round mode
+	 * (if we did nothing, trunc to 10 bits would be used)
+	 * note that any 12->10 bit reduction is ignored prior to DCE8,
+	 * as the input was 10 bits.
+	 */
+	if (option == DITHER_OPTION_SPATIAL6_FRAME_RANDOM ||
+			option == DITHER_OPTION_SPATIAL6 ||
+			option == DITHER_OPTION_FM6) {
+		fmt_bit_depth->flags.TRUNCATE_ENABLED = 1;
+		fmt_bit_depth->flags.TRUNCATE_DEPTH = 2;
+		fmt_bit_depth->flags.TRUNCATE_MODE = 1;
+	}
+
+	/* spatial dither
+	 * note that spatial modes 1-3 are never used
+	 */
+	if (option == DITHER_OPTION_SPATIAL6_FRAME_RANDOM            ||
+			option == DITHER_OPTION_SPATIAL6 ||
+			option == DITHER_OPTION_TRUN10_SPATIAL6      ||
+			option == DITHER_OPTION_TRUN8_SPATIAL6) {
+		fmt_bit_depth->flags.SPATIAL_DITHER_ENABLED = 1;
+		fmt_bit_depth->flags.SPATIAL_DITHER_DEPTH = 0;
+		fmt_bit_depth->flags.HIGHPASS_RANDOM = 1;
+		fmt_bit_depth->flags.RGB_RANDOM =
+				(pixel_encoding == PIXEL_ENCODING_RGB) ? 1 : 0;
+	} else if (option == DITHER_OPTION_SPATIAL8_FRAME_RANDOM            ||
+			option == DITHER_OPTION_SPATIAL8 ||
+			option == DITHER_OPTION_SPATIAL8_FM6        ||
+			option == DITHER_OPTION_TRUN10_SPATIAL8      ||
+			option == DITHER_OPTION_TRUN10_SPATIAL8_FM6) {
+		fmt_bit_depth->flags.SPATIAL_DITHER_ENABLED = 1;
+		fmt_bit_depth->flags.SPATIAL_DITHER_DEPTH = 1;
+		fmt_bit_depth->flags.HIGHPASS_RANDOM = 1;
+		fmt_bit_depth->flags.RGB_RANDOM =
+				(pixel_encoding == PIXEL_ENCODING_RGB) ? 1 : 0;
+	} else if (option == DITHER_OPTION_SPATIAL10_FRAME_RANDOM ||
+			option == DITHER_OPTION_SPATIAL10 ||
+			option == DITHER_OPTION_SPATIAL10_FM8 ||
+			option == DITHER_OPTION_SPATIAL10_FM6) {
+		fmt_bit_depth->flags.SPATIAL_DITHER_ENABLED = 1;
+		fmt_bit_depth->flags.SPATIAL_DITHER_DEPTH = 2;
+		fmt_bit_depth->flags.HIGHPASS_RANDOM = 1;
+		fmt_bit_depth->flags.RGB_RANDOM =
+				(pixel_encoding == PIXEL_ENCODING_RGB) ? 1 : 0;
+	}
+
+	if (option == DITHER_OPTION_SPATIAL6 ||
+			option == DITHER_OPTION_SPATIAL8 ||
+			option == DITHER_OPTION_SPATIAL10) {
+		fmt_bit_depth->flags.FRAME_RANDOM = 0;
+	} else {
+		fmt_bit_depth->flags.FRAME_RANDOM = 1;
+	}
+
+	//////////////////////
+	//// temporal dither
+	//////////////////////
+	if (option == DITHER_OPTION_FM6           ||
+			option == DITHER_OPTION_SPATIAL8_FM6     ||
+			option == DITHER_OPTION_SPATIAL10_FM6     ||
+			option == DITHER_OPTION_TRUN10_FM6     ||
+			option == DITHER_OPTION_TRUN8_FM6      ||
+			option == DITHER_OPTION_TRUN10_SPATIAL8_FM6) {
+		fmt_bit_depth->flags.FRAME_MODULATION_ENABLED = 1;
+		fmt_bit_depth->flags.FRAME_MODULATION_DEPTH = 0;
+	} else if (option == DITHER_OPTION_FM8        ||
+			option == DITHER_OPTION_SPATIAL10_FM8  ||
+			option == DITHER_OPTION_TRUN10_FM8) {
+		fmt_bit_depth->flags.FRAME_MODULATION_ENABLED = 1;
+		fmt_bit_depth->flags.FRAME_MODULATION_DEPTH = 1;
+	} else if (option == DITHER_OPTION_FM10) {
+		fmt_bit_depth->flags.FRAME_MODULATION_ENABLED = 1;
+		fmt_bit_depth->flags.FRAME_MODULATION_DEPTH = 2;
+	}
+
+	fmt_bit_depth->pixel_encoding = pixel_encoding;
+}

commit a2b8659db9b435853cb0dc78d225a492e7ee69d0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Apr 22 14:17:51 2017 -0400

    drm/amd/display: decouple resource_pool from resource_context
    
    to avoid null access in case res_ctx is used to access res_pool before it's fully constructed
    
    also make it clear which function has dependency on resource_pool
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index cdb98d5f7caa..43e5758719ca 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -233,11 +233,12 @@ bool resource_construct(
 
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct clock_source **clock_source)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
-		if (res_ctx->pool->clock_sources[i] != *clock_source)
+	for (i = 0; i < pool->clk_src_count; i++) {
+		if (pool->clock_sources[i] != *clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]--;
@@ -248,7 +249,7 @@ void resource_unreference_clock_source(
 		break;
 	}
 
-	if (res_ctx->pool->dp_clock_source == *clock_source) {
+	if (pool->dp_clock_source == *clock_source) {
 		res_ctx->dp_clock_source_ref_count--;
 
 		if (res_ctx->dp_clock_source_ref_count == 0)
@@ -259,18 +260,19 @@ void resource_unreference_clock_source(
 
 void resource_reference_clock_source(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct clock_source *clock_source)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
-		if (res_ctx->pool->clock_sources[i] != clock_source)
+	for (i = 0; i < pool->clk_src_count; i++) {
+		if (pool->clock_sources[i] != clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]++;
 		break;
 	}
 
-	if (res_ctx->pool->dp_clock_source == clock_source)
+	if (pool->dp_clock_source == clock_source)
 		res_ctx->dp_clock_source_ref_count++;
 }
 
@@ -861,12 +863,13 @@ enum dc_status resource_build_scaling_params_for_context(
 
 static void detach_surfaces_for_stream(
 		struct validate_context *context,
+		const struct resource_pool *pool,
 		const struct dc_stream *dc_stream)
 {
 	int i;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
-	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < pool->pipe_count; i++) {
 		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
 		if (cur_pipe->stream == stream) {
 			cur_pipe->surface = NULL;
@@ -876,7 +879,9 @@ static void detach_surfaces_for_stream(
 	}
 }
 
-struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx)
+struct pipe_ctx *find_idle_secondary_pipe(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
 	struct pipe_ctx *secondary_pipe = NULL;
@@ -886,7 +891,7 @@ struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx)
 	 * assignment more consistent
 	 */
 
-	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == NULL) {
 			secondary_pipe = &res_ctx->pipe_ctx[i];
 			secondary_pipe->pipe_idx = i;
@@ -903,7 +908,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 		const struct core_stream *stream)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				res_ctx->pipe_ctx[i].stream_enc) {
 			return &res_ctx->pipe_ctx[i];
@@ -919,6 +924,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
  */
 static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct validate_context *context,
+		const struct resource_pool *pool,
 		const struct dc_stream *dc_stream)
 {
 	int i;
@@ -938,7 +944,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 		return head_pipe;
 
 	/* Re-use pipe already acquired for this stream if available*/
-	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+	for (i = pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				!res_ctx->pipe_ctx[i].surface) {
 			return &res_ctx->pipe_ctx[i];
@@ -950,10 +956,10 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	 * to acquire an idle one to satisfy the request
 	 */
 
-	if(!res_ctx->pool->funcs->acquire_idle_pipe_for_layer)
+	if (!pool->funcs->acquire_idle_pipe_for_layer)
 		return NULL;
 
-	return res_ctx->pool->funcs->acquire_idle_pipe_for_layer(context, stream);
+	return pool->funcs->acquire_idle_pipe_for_layer(context, pool, stream);
 
 }
 
@@ -964,7 +970,7 @@ static void release_free_pipes_for_stream(
 	int i;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
-	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+	for (i = MAX_PIPES - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
 				!res_ctx->pipe_ctx[i].surface) {
 			res_ctx->pipe_ctx[i].stream = NULL;
@@ -976,7 +982,8 @@ bool resource_attach_surfaces_to_context(
 		const struct dc_surface * const *surfaces,
 		int surface_count,
 		const struct dc_stream *dc_stream,
-		struct validate_context *context)
+		struct validate_context *context,
+		const struct resource_pool *pool)
 {
 	int i;
 	struct pipe_ctx *tail_pipe;
@@ -1003,7 +1010,7 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++)
 		dc_surface_retain(surfaces[i]);
 
-	detach_surfaces_for_stream(context, dc_stream);
+	detach_surfaces_for_stream(context, pool, dc_stream);
 
 	/* release existing surfaces*/
 	for (i = 0; i < stream_status->surface_count; i++)
@@ -1020,7 +1027,8 @@ bool resource_attach_surfaces_to_context(
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
-		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(context, dc_stream);
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
+				context, pool, dc_stream);
 
 		if (!free_pipe) {
 			stream_status->surfaces[i] = NULL;
@@ -1101,7 +1109,8 @@ bool resource_validate_attach_surfaces(
 		const struct dc_validation_set set[],
 		int set_count,
 		const struct validate_context *old_context,
-		struct validate_context *context)
+		struct validate_context *context,
+		const struct resource_pool *pool)
 {
 	int i, j;
 
@@ -1114,7 +1123,7 @@ bool resource_validate_attach_surfaces(
 						old_context->stream_status[j].surfaces,
 						old_context->stream_status[j].surface_count,
 						&context->streams[i]->public,
-						context))
+						context, pool))
 					return false;
 				context->stream_status[i] = old_context->stream_status[j];
 			}
@@ -1123,7 +1132,7 @@ bool resource_validate_attach_surfaces(
 					set[i].surfaces,
 					set[i].surface_count,
 					&context->streams[i]->public,
-					context))
+					context, pool))
 				return false;
 
 	}
@@ -1136,12 +1145,13 @@ bool resource_validate_attach_surfaces(
 
 static void set_stream_engine_in_use(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct stream_encoder *stream_enc)
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
-		if (res_ctx->pool->stream_enc[i] == stream_enc)
+	for (i = 0; i < pool->stream_enc_count; i++) {
+		if (pool->stream_enc[i] == stream_enc)
 			res_ctx->is_stream_enc_acquired[i] = true;
 	}
 }
@@ -1149,32 +1159,33 @@ static void set_stream_engine_in_use(
 /* TODO: release audio object */
 static void set_audio_in_use(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct audio *audio)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->audio_count; i++) {
-		if (res_ctx->pool->audios[i] == audio) {
+	for (i = 0; i < pool->audio_count; i++) {
+		if (pool->audios[i] == audio)
 			res_ctx->is_audio_acquired[i] = true;
-		}
 	}
 }
 
 static int acquire_first_free_pipe(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct core_stream *stream)
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+	for (i = 0; i < pool->pipe_count; i++) {
 		if (!res_ctx->pipe_ctx[i].stream) {
 			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
 
-			pipe_ctx->tg = res_ctx->pool->timing_generators[i];
-			pipe_ctx->mi = res_ctx->pool->mis[i];
-			pipe_ctx->ipp = res_ctx->pool->ipps[i];
-			pipe_ctx->xfm = res_ctx->pool->transforms[i];
-			pipe_ctx->opp = res_ctx->pool->opps[i];
-			pipe_ctx->dis_clk = res_ctx->pool->display_clock;
+			pipe_ctx->tg = pool->timing_generators[i];
+			pipe_ctx->mi = pool->mis[i];
+			pipe_ctx->ipp = pool->ipps[i];
+			pipe_ctx->xfm = pool->transforms[i];
+			pipe_ctx->opp = pool->opps[i];
+			pipe_ctx->dis_clk = pool->display_clock;
 			pipe_ctx->pipe_idx = i;
 
 			pipe_ctx->stream = stream;
@@ -1186,21 +1197,22 @@ static int acquire_first_free_pipe(
 
 static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 		struct resource_context *res_ctx,
+		const struct resource_pool *pool,
 		struct core_stream *stream)
 {
 	int i;
 	int j = -1;
 	struct core_link *link = stream->sink->link;
 
-	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
+	for (i = 0; i < pool->stream_enc_count; i++) {
 		if (!res_ctx->is_stream_enc_acquired[i] &&
-					res_ctx->pool->stream_enc[i]) {
+				pool->stream_enc[i]) {
 			/* Store first available for MST second display
 			 * in daisy chain use case */
 			j = i;
-			if (res_ctx->pool->stream_enc[i]->id ==
+			if (pool->stream_enc[i]->id ==
 					link->link_enc->preferred_engine)
-				return res_ctx->pool->stream_enc[i];
+				return pool->stream_enc[i];
 		}
 	}
 
@@ -1218,17 +1230,19 @@ static struct stream_encoder *find_first_free_match_stream_enc_for_link(
 	 */
 
 	if (j >= 0 && dc_is_dp_signal(stream->signal))
-		return res_ctx->pool->stream_enc[j];
+		return pool->stream_enc[j];
 
 	return NULL;
 }
 
-static struct audio *find_first_free_audio(struct resource_context *res_ctx)
+static struct audio *find_first_free_audio(
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
-	for (i = 0; i < res_ctx->pool->audio_count; i++) {
+	for (i = 0; i < pool->audio_count; i++) {
 		if (res_ctx->is_audio_acquired[i] == false) {
-			return res_ctx->pool->audios[i];
+			return pool->audios[i];
 		}
 	}
 
@@ -1358,6 +1372,7 @@ enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
+	const struct resource_pool *pool = dc->res_pool;
 	int i, j;
 
 	calculate_phy_pix_clks(dc, context);
@@ -1370,12 +1385,12 @@ enum dc_status resource_map_pool_resources(
 				stream->bit_depth_params =
 						dc->current_context->streams[i]->bit_depth_params;
 				stream->clamping = dc->current_context->streams[i]->clamping;
-			continue;
+				continue;
+			}
 		}
-	}
 
 		/* mark resources used for stream that is already active */
-		for (j = 0; j < MAX_PIPES; j++) {
+		for (j = 0; j < pool->pipe_count; j++) {
 			struct pipe_ctx *pipe_ctx =
 				&context->res_ctx.pipe_ctx[j];
 			const struct pipe_ctx *old_pipe_ctx =
@@ -1395,7 +1410,7 @@ enum dc_status resource_map_pool_resources(
 				continue;
 
 			set_stream_engine_in_use(
-				&context->res_ctx,
+				&context->res_ctx, pool,
 				pipe_ctx->stream_enc);
 
 			/* Switch to dp clock source only if there is
@@ -1404,15 +1419,14 @@ enum dc_status resource_map_pool_resources(
 			 */
 			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
 				!find_pll_sharable_stream(stream, context))
-				pipe_ctx->clock_source =
-					context->res_ctx.pool->dp_clock_source;
+				pipe_ctx->clock_source = pool->dp_clock_source;
 
 			resource_reference_clock_source(
-				&context->res_ctx,
+				&context->res_ctx, pool,
 				pipe_ctx->clock_source);
 
-			set_audio_in_use(&context->res_ctx,
-					 pipe_ctx->audio);
+			set_audio_in_use(&context->res_ctx, pool,
+					pipe_ctx->audio);
 		}
 	}
 
@@ -1424,22 +1438,22 @@ enum dc_status resource_map_pool_resources(
 		if (resource_is_stream_unchanged(dc->current_context, stream))
 			continue;
 		/* acquire new resources */
-		pipe_idx = acquire_first_free_pipe(&context->res_ctx, stream);
+		pipe_idx = acquire_first_free_pipe(
+				&context->res_ctx, pool, stream);
 		if (pipe_idx < 0)
 			return DC_NO_CONTROLLER_RESOURCE;
 
-
 		pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
 
 		pipe_ctx->stream_enc =
 			find_first_free_match_stream_enc_for_link(
-				&context->res_ctx, stream);
+				&context->res_ctx, pool, stream);
 
 		if (!pipe_ctx->stream_enc)
 			return DC_NO_STREAM_ENG_RESOURCE;
 
 		set_stream_engine_in_use(
-			&context->res_ctx,
+			&context->res_ctx, pool,
 			pipe_ctx->stream_enc);
 
 		/* TODO: Add check if ASIC support and EDID audio */
@@ -1447,7 +1461,7 @@ enum dc_status resource_map_pool_resources(
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 			stream->public.audio_info.mode_count) {
 			pipe_ctx->audio = find_first_free_audio(
-				&context->res_ctx);
+				&context->res_ctx, pool);
 
 			/*
 			 * Audio assigned in order first come first get.
@@ -1456,7 +1470,7 @@ enum dc_status resource_map_pool_resources(
 			 */
 			if (pipe_ctx->audio)
 				set_audio_in_use(
-					&context->res_ctx,
+					&context->res_ctx, pool,
 					pipe_ctx->audio);
 		}
 
@@ -2077,7 +2091,7 @@ void dc_resource_validate_ctx_copy_construct(
 
 	*dst_ctx = *src_ctx;
 
-	for (i = 0; i < dst_ctx->res_ctx.pool->pipe_count; i++) {
+	for (i = 0; i < MAX_PIPES; i++) {
 		struct pipe_ctx *cur_pipe = &dst_ctx->res_ctx.pipe_ctx[i];
 
 		if (cur_pipe->top_pipe)
@@ -2097,13 +2111,14 @@ void dc_resource_validate_ctx_copy_construct(
 }
 
 struct clock_source *dc_resource_find_first_free_pll(
-		struct resource_context *res_ctx)
+		struct resource_context *res_ctx,
+		const struct resource_pool *pool)
 {
 	int i;
 
-	for (i = 0; i < res_ctx->pool->clk_src_count; ++i) {
+	for (i = 0; i < pool->clk_src_count; ++i) {
 		if (res_ctx->clock_source_ref_count[i] == 0)
-			return res_ctx->pool->clock_sources[i];
+			return pool->clock_sources[i];
 	}
 
 	return NULL;
@@ -2151,6 +2166,7 @@ enum dc_status resource_map_clock_resources(
 		struct validate_context *context)
 {
 	int i, j;
+	const struct resource_pool *pool = dc->res_pool;
 
 	/* acquire new resources */
 	for (i = 0; i < context->stream_count; i++) {
@@ -2168,8 +2184,7 @@ enum dc_status resource_map_clock_resources(
 
 			if (dc_is_dp_signal(pipe_ctx->stream->signal)
 				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
-				pipe_ctx->clock_source =
-					context->res_ctx.pool->dp_clock_source;
+				pipe_ctx->clock_source = pool->dp_clock_source;
 			else {
 				pipe_ctx->clock_source = NULL;
 
@@ -2180,14 +2195,16 @@ enum dc_status resource_map_clock_resources(
 
 				if (pipe_ctx->clock_source == NULL)
 					pipe_ctx->clock_source =
-						dc_resource_find_first_free_pll(&context->res_ctx);
+						dc_resource_find_first_free_pll(
+							&context->res_ctx,
+							pool);
 			}
 
 			if (pipe_ctx->clock_source == NULL)
 				return DC_NO_CLOCK_SOURCE_RESOURCE;
 
 			resource_reference_clock_source(
-				&context->res_ctx,
+				&context->res_ctx, pool,
 				pipe_ctx->clock_source);
 
 			/* only one cs per stream regardless of mpo */

commit 94267b3df7ee00f21fa0ff7d618ca7e0574db5ed
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Fri Apr 21 15:29:55 2017 -0400

    drm/amd/display: PSR Refactor
    
    - Refacotr PSR to follow correct module pattern
    - fix eDP only working on sink index 0.
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2e12a0ba5ddf..cdb98d5f7caa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2015,7 +2015,7 @@ static void set_vsc_info_packet(
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
 
-	if (stream->sink->link->public.psr_caps.psr_version != 0) {
+	if (stream->sink->link->psr_enabled) {
 		vscPacketRevision = 2;
 	}
 

commit 8122a253b34aec75a1fdc3fe61c97b9026a0bff6
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Mar 29 11:15:14 2017 -0400

    drm/amd/display: Move resource_validate_ctx_destruct to dc.h
    
    This will be needed to clean up context once we add it to private
    atomic state.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2d40864b7b48..2e12a0ba5ddf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -2050,7 +2050,7 @@ static void set_vsc_info_packet(
 	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
 }
 
-void resource_validate_ctx_destruct(struct validate_context *context)
+void dc_resource_validate_ctx_destruct(struct validate_context *context)
 {
 	int i, j;
 
@@ -2069,7 +2069,7 @@ void resource_validate_ctx_destruct(struct validate_context *context)
  * Copy src_ctx into dst_ctx and retain all surfaces and streams referenced
  * by the src_ctx
  */
-void resource_validate_ctx_copy_construct(
+void dc_resource_validate_ctx_copy_construct(
 		const struct validate_context *src_ctx,
 		struct validate_context *dst_ctx)
 {

commit 8b32076c27227cf5bed0c925c7a1a9680748424a
Author: Sylvia Tsai <sylvia.tsai@amd.com>
Date:   Tue Apr 4 17:28:17 2017 -0400

    drm/amd/display: Adding dm controlled signal type in dc_stream
    
    - Adding dm controlled signal type in dc_stream
    - Adding fallback to dvi signal when output signal is hdmi and the connector
      type is not
    
    Signed-off-by: Sylvia Tsai <sylvia.tsai@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Sylvia Tsai <Sylvia.Tsai@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 069f588a9e02..2d40864b7b48 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1237,22 +1237,22 @@ static struct audio *find_first_free_audio(struct resource_context *res_ctx)
 
 static void update_stream_signal(struct core_stream *stream)
 {
-	const struct dc_sink *dc_sink = stream->public.sink;
-
-	if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
-		stream->signal = stream->sink->link->public.connector_signal;
-	else if (dc_sink->sink_signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||
-			dc_sink->sink_signal == SIGNAL_TYPE_DVI_DUAL_LINK)
-		/* For asic supports dual link DVI, we should adjust signal type
-		 * based on timing pixel clock. If pixel clock more than 165Mhz,
-		 * signal is dual link, otherwise, single link.
-		 */
-		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
-			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+	if (stream->public.output_signal == SIGNAL_TYPE_NONE) {
+		const struct dc_sink *dc_sink = stream->public.sink;
+
+		if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
+			stream->signal =
+					stream->sink->link->
+					public.connector_signal;
 		else
-			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
-	else
-		stream->signal = dc_sink->sink_signal;
+			stream->signal = dc_sink->sink_signal;
+	} else {
+		stream->signal = stream->public.output_signal;
+	}
+
+	if (stream->signal == SIGNAL_TYPE_DVI_SINGLE_LINK &&
+		stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
+		stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 }
 
 bool resource_is_stream_unchanged(

commit e8d726b71c55fb5c20fcf76bdea93c148a4b11e5
Author: Reza Amini <reza.amini@amd.com>
Date:   Wed Mar 29 12:05:15 2017 -0400

    drm/amd/display: refactor member referencing to improve readability
    
    Signed-off-by: Reza Amini <reza.amini@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 8f53d7a9f4dd..069f588a9e02 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1519,17 +1519,16 @@ static void set_avi_info_frame(
 	uint8_t cn0_cn1 = 0;
 	uint8_t *check_sum = NULL;
 	uint8_t byte_index = 0;
+	union hdmi_info_packet *hdmi_info = &info_frame.avi_info_packet.info_packet_hdmi;
 
 	color_space = pipe_ctx->stream->public.output_color_space;
 
 	/* Initialize header */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.header.
-			info_frame_type = HDMI_INFOFRAME_TYPE_AVI;
+	hdmi_info->bits.header.info_frame_type = HDMI_INFOFRAME_TYPE_AVI;
 	/* InfoFrameVersion_3 is defined by CEA861F (Section 6.4), but shall
 	* not be used in HDMI 2.0 (Section 10.1) */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.header.version = 2;
-	info_frame.avi_info_packet.info_packet_hdmi.bits.header.length =
-			HDMI_AVI_INFOFRAME_SIZE;
+	hdmi_info->bits.header.version = 2;
+	hdmi_info->bits.header.length = HDMI_AVI_INFOFRAME_SIZE;
 
 	/*
 	 * IDO-defined (Y2,Y1,Y0 = 1,1,1) shall not be used by devices built
@@ -1555,52 +1554,41 @@ static void set_avi_info_frame(
 
 	/* Y0_Y1_Y2 : The pixel encoding */
 	/* H14b AVI InfoFrame has extension on Y-field from 2 bits to 3 bits */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.Y0_Y1_Y2 =
-		pixel_encoding;
+	hdmi_info->bits.Y0_Y1_Y2 = pixel_encoding;
 
 	/* A0 = 1 Active Format Information valid */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.A0 =
-		ACTIVE_FORMAT_VALID;
+	hdmi_info->bits.A0 = ACTIVE_FORMAT_VALID;
 
 	/* B0, B1 = 3; Bar info data is valid */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.B0_B1 =
-		BAR_INFO_BOTH_VALID;
+	hdmi_info->bits.B0_B1 = BAR_INFO_BOTH_VALID;
 
-	info_frame.avi_info_packet.info_packet_hdmi.bits.SC0_SC1 =
-			PICTURE_SCALING_UNIFORM;
+	hdmi_info->bits.SC0_SC1 = PICTURE_SCALING_UNIFORM;
 
 	/* S0, S1 : Underscan / Overscan */
 	/* TODO: un-hardcode scan type */
 	scan_type = SCANNING_TYPE_UNDERSCAN;
-	info_frame.avi_info_packet.info_packet_hdmi.bits.S0_S1 = scan_type;
+	hdmi_info->bits.S0_S1 = scan_type;
 
 	/* C0, C1 : Colorimetry */
 	if (color_space == COLOR_SPACE_YCBCR709 ||
 			color_space == COLOR_SPACE_YCBCR709_LIMITED)
-		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
-				COLORIMETRY_ITU709;
+		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU709;
 	else if (color_space == COLOR_SPACE_YCBCR601 ||
 			color_space == COLOR_SPACE_YCBCR601_LIMITED)
-		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
-				COLORIMETRY_ITU601;
+		hdmi_info->bits.C0_C1 = COLORIMETRY_ITU601;
 	else {
 		if (stream->public.timing.pixel_encoding != PIXEL_ENCODING_RGB)
 			BREAK_TO_DEBUGGER();
-		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
-				COLORIMETRY_NO_DATA;
+		hdmi_info->bits.C0_C1 = COLORIMETRY_NO_DATA;
 	}
 	if (color_space == COLOR_SPACE_2020_RGB_FULLRANGE ||
 			color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE ||
 			color_space == COLOR_SPACE_2020_YCBCR) {
-		info_frame.avi_info_packet.info_packet_hdmi.bits.EC0_EC2 =
-				COLORIMETRYEX_BT2020RGBYCBCR;
-		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
-				COLORIMETRY_EXTENDED;
+		hdmi_info->bits.EC0_EC2 = COLORIMETRYEX_BT2020RGBYCBCR;
+		hdmi_info->bits.C0_C1   = COLORIMETRY_EXTENDED;
 	} else if (color_space == COLOR_SPACE_ADOBERGB) {
-		info_frame.avi_info_packet.info_packet_hdmi.bits.EC0_EC2 =
-				COLORIMETRYEX_ADOBERGB;
-		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
-				COLORIMETRY_EXTENDED;
+		hdmi_info->bits.EC0_EC2 = COLORIMETRYEX_ADOBERGB;
+		hdmi_info->bits.C0_C1   = COLORIMETRY_EXTENDED;
 	}
 
 	/* TODO: un-hardcode aspect ratio */
@@ -1609,93 +1597,76 @@ static void set_avi_info_frame(
 	switch (aspect) {
 	case ASPECT_RATIO_4_3:
 	case ASPECT_RATIO_16_9:
-		info_frame.avi_info_packet.info_packet_hdmi.bits.M0_M1 = aspect;
+		hdmi_info->bits.M0_M1 = aspect;
 		break;
 
 	case ASPECT_RATIO_NO_DATA:
 	case ASPECT_RATIO_64_27:
 	case ASPECT_RATIO_256_135:
 	default:
-		info_frame.avi_info_packet.info_packet_hdmi.bits.M0_M1 = 0;
+		hdmi_info->bits.M0_M1 = 0;
 	}
 
 	/* Active Format Aspect ratio - same as Picture Aspect Ratio. */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.R0_R3 =
-			ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;
+	hdmi_info->bits.R0_R3 = ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;
 
 	/* TODO: un-hardcode cn0_cn1 and itc */
 	cn0_cn1 = 0;
 	itc = false;
 
 	if (itc) {
-		info_frame.avi_info_packet.info_packet_hdmi.bits.ITC = 1;
-		info_frame.avi_info_packet.info_packet_hdmi.bits.CN0_CN1 =
-			cn0_cn1;
+		hdmi_info->bits.ITC     = 1;
+		hdmi_info->bits.CN0_CN1 = cn0_cn1;
 	}
 
 	/* TODO : We should handle YCC quantization */
 	/* but we do not have matrix calculation */
 	if (color_space == COLOR_SPACE_SRGB) {
-		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
-						RGB_QUANTIZATION_FULL_RANGE;
-		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
-						YYC_QUANTIZATION_FULL_RANGE;
+		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_FULL_RANGE;
+		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_FULL_RANGE;
 	} else if (color_space == COLOR_SPACE_SRGB_LIMITED) {
-		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
-						RGB_QUANTIZATION_LIMITED_RANGE;
-		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
-						YYC_QUANTIZATION_LIMITED_RANGE;
+		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_LIMITED_RANGE;
+		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
 	} else {
-		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
-						RGB_QUANTIZATION_DEFAULT_RANGE;
-		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
-						YYC_QUANTIZATION_LIMITED_RANGE;
+		hdmi_info->bits.Q0_Q1   = RGB_QUANTIZATION_DEFAULT_RANGE;
+		hdmi_info->bits.YQ0_YQ1 = YYC_QUANTIZATION_LIMITED_RANGE;
 	}
 
-	info_frame.avi_info_packet.info_packet_hdmi.bits.VIC0_VIC7 =
+	hdmi_info->bits.VIC0_VIC7 =
 					stream->public.timing.vic;
 
 	/* pixel repetition
 	 * PR0 - PR3 start from 0 whereas pHwPathMode->mode.timing.flags.pixel
 	 * repetition start from 1 */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.PR0_PR3 = 0;
+	hdmi_info->bits.PR0_PR3 = 0;
 
 	/* Bar Info
 	 * barTop:    Line Number of End of Top Bar.
 	 * barBottom: Line Number of Start of Bottom Bar.
 	 * barLeft:   Pixel Number of End of Left Bar.
 	 * barRight:  Pixel Number of Start of Right Bar. */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_top =
-			stream->public.timing.v_border_top;
-	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_bottom =
-		(stream->public.timing.v_border_top
+	hdmi_info->bits.bar_top = stream->public.timing.v_border_top;
+	hdmi_info->bits.bar_bottom = (stream->public.timing.v_border_top
 			- stream->public.timing.v_border_bottom + 1);
-	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_left =
-			stream->public.timing.h_border_left;
-	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_right =
-		(stream->public.timing.h_total
+	hdmi_info->bits.bar_left  = stream->public.timing.h_border_left;
+	hdmi_info->bits.bar_right = (stream->public.timing.h_total
 			- stream->public.timing.h_border_right + 1);
 
 	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
-	check_sum =
-		&info_frame.
-		avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
+	check_sum = &info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
+
 	*check_sum = HDMI_INFOFRAME_TYPE_AVI + HDMI_AVI_INFOFRAME_SIZE + 2;
 
 	for (byte_index = 1; byte_index <= HDMI_AVI_INFOFRAME_SIZE; byte_index++)
-		*check_sum += info_frame.avi_info_packet.info_packet_hdmi.
-				packet_raw_data.sb[byte_index];
+		*check_sum += hdmi_info->packet_raw_data.sb[byte_index];
 
 	/* one byte complement */
 	*check_sum = (uint8_t) (0x100 - *check_sum);
 
 	/* Store in hw_path_mode */
-	info_packet->hb0 =
-		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb0;
-	info_packet->hb1 =
-		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb1;
-	info_packet->hb2 =
-		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb2;
+	info_packet->hb0 = hdmi_info->packet_raw_data.hb0;
+	info_packet->hb1 = hdmi_info->packet_raw_data.hb1;
+	info_packet->hb2 = hdmi_info->packet_raw_data.hb2;
 
 	for (byte_index = 0; byte_index < sizeof(info_frame.avi_info_packet.
 				info_packet_hdmi.packet_raw_data.sb); byte_index++)

commit 7b779c991d9422f677dff70d701eae448c7c696a
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Mon Mar 27 12:48:46 2017 -0500

    drm/amd/display: stereo support
    
    Frame sequential, top-bottom and side-by-side support.
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 61ca1e21ae66..8f53d7a9f4dd 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -422,6 +422,11 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	bool sec_split = pipe_ctx->top_pipe &&
 			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
 
+	if (stream->timing.timing_3d_format == TIMING_3D_FORMAT_SIDE_BY_SIDE ||
+		stream->timing.timing_3d_format == TIMING_3D_FORMAT_TOP_AND_BOTTOM) {
+		pri_split = false;
+		sec_split = false;
+	}
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
@@ -532,14 +537,27 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 			stream->public.dst.y + stream->public.dst.height
 						- pipe_ctx->scl_data.recout.y;
 
-	/* Handle hsplit */
-	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
-		pipe_ctx->scl_data.recout.width /= 2;
-		pipe_ctx->scl_data.recout.x += pipe_ctx->scl_data.recout.width;
-		/* Floor primary pipe, ceil 2ndary pipe */
-		pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
-	} else if (pipe_ctx->bottom_pipe && pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
-		pipe_ctx->scl_data.recout.width /= 2;
+	/* Handle h & vsplit */
+	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface ==
+		pipe_ctx->surface) {
+		if (stream->public.timing.timing_3d_format ==
+			TIMING_3D_FORMAT_TOP_AND_BOTTOM) {
+			pipe_ctx->scl_data.recout.height /= 2;
+			pipe_ctx->scl_data.recout.y += pipe_ctx->scl_data.recout.height;
+			/* Floor primary pipe, ceil 2ndary pipe */
+			pipe_ctx->scl_data.recout.height += pipe_ctx->scl_data.recout.height % 2;
+		} else {
+			pipe_ctx->scl_data.recout.width /= 2;
+			pipe_ctx->scl_data.recout.x += pipe_ctx->scl_data.recout.width;
+			pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
+		}
+	} else if (pipe_ctx->bottom_pipe &&
+			   pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+		if (stream->public.timing.timing_3d_format ==
+			TIMING_3D_FORMAT_TOP_AND_BOTTOM)
+			pipe_ctx->scl_data.recout.height /= 2;
+		else
+			pipe_ctx->scl_data.recout.width /= 2;
 	}
 
 	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream src offset)

commit 2fc67983fbc56b7b6bba64d4410e3bfeee467834
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Mar 20 14:49:53 2017 -0400

    drm/amd/display: remove redundant check
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Reviewed-by: Anthony Koo <Anthony.Koo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 875d1a63fcea..61ca1e21ae66 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1063,8 +1063,6 @@ static bool are_stream_backends_same(
 	if (stream_a == NULL || stream_b == NULL)
 		return false;
 
-	if (stream_a->public.timing.pixel_encoding != stream_b->public.timing.pixel_encoding)
-		return false;
 	if (is_timing_changed(stream_a, stream_b))
 		return false;
 
@@ -1074,8 +1072,6 @@ static bool are_stream_backends_same(
 bool is_stream_unchanged(
 	const struct core_stream *old_stream, const struct core_stream *stream)
 {
-	if (old_stream != stream)
-		return false;
 
 	if (!are_stream_backends_same(old_stream, stream))
 		return false;

commit 7e2fe3190dc2eb62d84069f18cbf3fbabf79ded7
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Mar 17 13:09:09 2017 -0400

    drm/amd/display: DP is hotplugged, HDMI with 4:2:0 corruption
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 9f624e84f59b..875d1a63fcea 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -297,8 +297,8 @@ bool resource_are_streams_timing_synchronizable(
 		return false;
 
 	if (stream1->phy_pix_clk != stream2->phy_pix_clk
-			&& !dc_is_dp_signal(stream1->signal)
-			&& !dc_is_dp_signal(stream2->signal))
+			&& (!dc_is_dp_signal(stream1->signal)
+			|| !dc_is_dp_signal(stream2->signal)))
 		return false;
 
 	return true;
@@ -1063,6 +1063,8 @@ static bool are_stream_backends_same(
 	if (stream_a == NULL || stream_b == NULL)
 		return false;
 
+	if (stream_a->public.timing.pixel_encoding != stream_b->public.timing.pixel_encoding)
+		return false;
 	if (is_timing_changed(stream_a, stream_b))
 		return false;
 
@@ -1072,8 +1074,8 @@ static bool are_stream_backends_same(
 bool is_stream_unchanged(
 	const struct core_stream *old_stream, const struct core_stream *stream)
 {
-	if (old_stream == stream)
-		return true;
+	if (old_stream != stream)
+		return false;
 
 	if (!are_stream_backends_same(old_stream, stream))
 		return false;
@@ -1357,6 +1359,7 @@ enum dc_status resource_map_pool_resources(
 			continue;
 		}
 	}
+
 		/* mark resources used for stream that is already active */
 		for (j = 0; j < MAX_PIPES; j++) {
 			struct pipe_ctx *pipe_ctx =

commit e73c1efca8c5fd4a53f6d725fc6ca18c65570d37
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Tue Mar 14 16:41:50 2017 -0400

    drm/amd/display: Use stream_enc to get head pipe.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6700d6b27a8a..9f624e84f59b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -887,7 +887,7 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 	int i;
 	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
-				!res_ctx->pipe_ctx[i].top_pipe) {
+				res_ctx->pipe_ctx[i].stream_enc) {
 			return &res_ctx->pipe_ctx[i];
 			break;
 		}

commit 745cc746da42a3a8a48fb7a6b8c4ee2c3f2cdf8b
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Mar 14 12:30:29 2017 -0400

    drm/amd/display: remove dc_pre_update_surfaces_to_stream from dc use
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ad37d0efca2e..6700d6b27a8a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -900,10 +900,11 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
  * that has no surface attached yet
  */
 static struct pipe_ctx *acquire_free_pipe_for_stream(
-		struct resource_context *res_ctx,
+		struct validate_context *context,
 		const struct dc_stream *dc_stream)
 {
 	int i;
+	struct resource_context *res_ctx = &context->res_ctx;
 	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	struct pipe_ctx *head_pipe = NULL;
@@ -934,7 +935,7 @@ static struct pipe_ctx *acquire_free_pipe_for_stream(
 	if(!res_ctx->pool->funcs->acquire_idle_pipe_for_layer)
 		return NULL;
 
-	return res_ctx->pool->funcs->acquire_idle_pipe_for_layer(res_ctx, stream);
+	return res_ctx->pool->funcs->acquire_idle_pipe_for_layer(context, stream);
 
 }
 
@@ -1001,8 +1002,7 @@ bool resource_attach_surfaces_to_context(
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
-		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
-				&context->res_ctx, dc_stream);
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(context, dc_stream);
 
 		if (!free_pipe) {
 			stream_status->surfaces[i] = NULL;

commit 8fa9ca2ec6919656db87391a1633692ee8d57c22
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:21:43 2017 -0400

    drm/amd/display: Remove DCE12 guards
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 77ef3304d2bc..ad37d0efca2e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -39,9 +39,7 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 #include "dce120/dce120_resource.h"
-#endif
 
 enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 {
@@ -68,11 +66,9 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 			dc_version = DCE_VERSION_11_2;
 		}
 		break;
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 	case FAMILY_AI:
 		dc_version = DCE_VERSION_12_0;
 		break;
-#endif
 	default:
 		dc_version = DCE_VERSION_UNKNOWN;
 		break;
@@ -105,12 +101,10 @@ struct resource_pool *dc_create_resource_pool(
 		res_pool = dce112_create_resource_pool(
 			num_virtual_links, dc);
 		break;
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 	case DCE_VERSION_12_0:
 		res_pool = dce120_create_resource_pool(
 			num_virtual_links, dc);
 		break;
-#endif
 	default:
 		break;
 	}

commit 2c8ad2d5a20c8b7425b547dd4a969ffecad29b39
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:20:24 2017 -0400

    drm/amd/display: Enable DCE12 support
    
    This wires DCE12 support into DC and enables it.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6119973c7f0a..77ef3304d2bc 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -39,6 +39,9 @@
 #include "dce100/dce100_resource.h"
 #include "dce110/dce110_resource.h"
 #include "dce112/dce112_resource.h"
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+#include "dce120/dce120_resource.h"
+#endif
 
 enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 {
@@ -65,6 +68,11 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 			dc_version = DCE_VERSION_11_2;
 		}
 		break;
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+	case FAMILY_AI:
+		dc_version = DCE_VERSION_12_0;
+		break;
+#endif
 	default:
 		dc_version = DCE_VERSION_UNKNOWN;
 		break;
@@ -97,6 +105,12 @@ struct resource_pool *dc_create_resource_pool(
 		res_pool = dce112_create_resource_pool(
 			num_virtual_links, dc);
 		break;
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+	case DCE_VERSION_12_0:
+		res_pool = dce120_create_resource_pool(
+			num_virtual_links, dc);
+		break;
+#endif
 	default:
 		break;
 	}

commit c802570ed5a679c3c58fdde4b23d494bd884efc9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Mar 8 13:45:33 2017 -0500

    drm/amd/display: fix incorrect vp adjustment
    
    Viewport would be incorrectly adjusted when surface was used
    for multiple displays
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 01f15052bebf..6119973c7f0a 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -494,6 +494,7 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct core_stream *stream = pipe_ctx->stream;
 	struct rect clip = surface->clip_rect;
+	int recout_full_x, recout_full_y;
 
 	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
 	if (stream->public.src.x < clip.x)
@@ -533,10 +534,21 @@ static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip
 		pipe_ctx->scl_data.recout.width /= 2;
 	}
 
-	recout_skip->width = pipe_ctx->scl_data.recout.x - stream->public.dst.x -
-			surface->dst_rect.x * stream->public.dst.width / stream->public.src.width;
-	recout_skip->height = pipe_ctx->scl_data.recout.y - stream->public.dst.y -
-			surface->dst_rect.y * stream->public.dst.height / stream->public.src.height;
+	/* Unclipped recout offset = stream dst offset + ((surf dst offset - stream src offset)
+	 * 				* 1/ stream scaling ratio) - (surf src offset * 1/ full scl
+	 * 				ratio)
+	 */
+	recout_full_x = stream->public.dst.x + (surface->dst_rect.x -  stream->public.src.x)
+					* stream->public.dst.width / stream->public.src.width -
+			surface->src_rect.x * surface->dst_rect.width / surface->src_rect.width
+					* stream->public.dst.width / stream->public.src.width;
+	recout_full_y = stream->public.dst.y + (surface->dst_rect.y -  stream->public.src.y)
+					* stream->public.dst.height / stream->public.src.height -
+			surface->src_rect.y * surface->dst_rect.height / surface->src_rect.height
+					* stream->public.dst.height / stream->public.src.height;
+
+	recout_skip->width = pipe_ctx->scl_data.recout.x - recout_full_x;
+	recout_skip->height = pipe_ctx->scl_data.recout.y - recout_full_y;
 }
 
 static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)

commit 1fbd2cfc15988f90ce5bebbbeaf759f4d1c615e1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Mar 6 18:02:30 2017 -0500

    drm/amd/display: fix viewport adjustment on rotated surface
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index e34b52e28e52..01f15052bebf 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -404,57 +404,47 @@ static void rect_swap_helper(struct rect *rect)
 static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	const struct dc_stream *stream = &pipe_ctx->stream->public;
 	struct scaler_data *data = &pipe_ctx->scl_data;
-	struct rect stream_src = pipe_ctx->stream->public.src;
-	struct rect src = surface->src_rect;
-	struct rect dst = surface->dst_rect;
-	struct rect surface_clip = surface->clip_rect;
-	struct rect clip = {0};
+	struct rect clip = { 0 };
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
 			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
-	bool need_split = (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface)
-		|| (pipe_ctx->bottom_pipe && pipe_ctx->bottom_pipe->surface == pipe_ctx->surface);
-
-
-	if (surface->rotation == ROTATION_ANGLE_90 ||
-	    surface->rotation == ROTATION_ANGLE_270) {
-		rect_swap_helper(&src);
-		rect_swap_helper(&dst);
-		rect_swap_helper(&surface_clip);
-		rect_swap_helper(&stream_src);
-	}
+	bool pri_split = pipe_ctx->bottom_pipe &&
+			pipe_ctx->bottom_pipe->surface == pipe_ctx->surface;
+	bool sec_split = pipe_ctx->top_pipe &&
+			pipe_ctx->top_pipe->surface == pipe_ctx->surface;
 
 	/* The actual clip is an intersection between stream
 	 * source and surface clip
 	 */
-	clip.x = stream_src.x > surface_clip.x ?
-			stream_src.x : surface_clip.x;
+	clip.x = stream->src.x > surface->clip_rect.x ?
+			stream->src.x : surface->clip_rect.x;
 
-	clip.width = stream_src.x + stream_src.width <
-			surface_clip.x + surface_clip.width ?
-			stream_src.x + stream_src.width - clip.x :
-			surface_clip.x + surface_clip.width - clip.x ;
+	clip.width = stream->src.x + stream->src.width <
+			surface->clip_rect.x + surface->clip_rect.width ?
+			stream->src.x + stream->src.width - clip.x :
+			surface->clip_rect.x + surface->clip_rect.width - clip.x ;
 
-	clip.y = stream_src.y > surface_clip.y ?
-			stream_src.y : surface_clip.y;
+	clip.y = stream->src.y > surface->clip_rect.y ?
+			stream->src.y : surface->clip_rect.y;
 
-	clip.height = stream_src.y + stream_src.height <
-			surface_clip.y + surface_clip.height ?
-			stream_src.y + stream_src.height - clip.y :
-			surface_clip.y + surface_clip.height - clip.y ;
+	clip.height = stream->src.y + stream->src.height <
+			surface->clip_rect.y + surface->clip_rect.height ?
+			stream->src.y + stream->src.height - clip.y :
+			surface->clip_rect.y + surface->clip_rect.height - clip.y ;
 
-	/* offset = src.ofs + (clip.ofs - dst.ofs) * scl_ratio
+	/* offset = src.ofs + (clip.ofs - surface->dst_rect.ofs) * scl_ratio
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	data->viewport.x = src.x + (clip.x - dst.x) *
-			src.width / dst.width;
+	data->viewport.x = surface->src_rect.x + (clip.x - surface->dst_rect.x) *
+			surface->src_rect.width / surface->dst_rect.width;
 	data->viewport.width = clip.width *
-			src.width / dst.width;
+			surface->src_rect.width / surface->dst_rect.width;
 
-	data->viewport.y = src.y + (clip.y - dst.y) *
-			src.height / dst.height;
+	data->viewport.y = surface->src_rect.y + (clip.y - surface->dst_rect.y) *
+			surface->src_rect.height / surface->dst_rect.height;
 	data->viewport.height = clip.height *
-			src.height / dst.height;
+			surface->src_rect.height / surface->dst_rect.height;
 
 	/* Round down, compensate in init */
 	data->viewport_c.x = data->viewport.x / vpc_div;
@@ -468,27 +458,15 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
 
 	/* Handle hsplit */
-	if (need_split && (surface->rotation == ROTATION_ANGLE_90 ||
-				surface->rotation == ROTATION_ANGLE_270)) {
-		bool lower_view = (surface->rotation == ROTATION_ANGLE_270) ^
-			(pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface);
-
-		if (lower_view) {
-			data->viewport.height /= 2;
-			data->viewport_c.height /= 2;
-			data->viewport.y +=  data->viewport.height;
-			data->viewport_c.y +=  data->viewport_c.height;
-			/* Ceil offset pipe */
-			data->viewport.height += data->viewport.height % 2;
-			data->viewport_c.height += data->viewport_c.height % 2;
-		} else {
-			data->viewport.height /= 2;
-			data->viewport_c.height /= 2;
-		}
-	} else if (need_split) {
-		bool right_view = (surface->rotation == ROTATION_ANGLE_180) ^
-			(pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface) ^
-			surface->horizontal_mirror;
+	if (pri_split || sec_split) {
+		/* HMirror XOR Secondary_pipe XOR Rotation_180 */
+		bool right_view = (sec_split != surface->horizontal_mirror) !=
+					(surface->rotation == ROTATION_ANGLE_180);
+
+		if (surface->rotation == ROTATION_ANGLE_90
+				|| surface->rotation == ROTATION_ANGLE_270)
+			/* Secondary_pipe XOR Rotation_270 */
+			right_view = (surface->rotation == ROTATION_ANGLE_270) != sec_split;
 
 		if (right_view) {
 			data->viewport.width /= 2;
@@ -503,6 +481,12 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 			data->viewport_c.width /= 2;
 		}
 	}
+
+	if (surface->rotation == ROTATION_ANGLE_90 ||
+			surface->rotation == ROTATION_ANGLE_270) {
+		rect_swap_helper(&data->viewport_c);
+		rect_swap_helper(&data->viewport);
+	}
 }
 
 static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
@@ -559,10 +543,10 @@ static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
 	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct core_stream *stream = pipe_ctx->stream;
-	const uint32_t in_w = stream->public.src.width;
-	const uint32_t in_h = stream->public.src.height;
-	const uint32_t out_w = stream->public.dst.width;
-	const uint32_t out_h = stream->public.dst.height;
+	const int in_w = stream->public.src.width;
+	const int in_h = stream->public.src.height;
+	const int out_w = stream->public.dst.width;
+	const int out_h = stream->public.dst.height;
 
 	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
 					surface->src_rect.width,
@@ -598,6 +582,12 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
 			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
 
+	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+		rect_swap_helper(&data->viewport_c);
+		rect_swap_helper(&data->viewport);
+	}
+
 	/*
 	 * Init calculated according to formula:
 	 * 	init = (scaling_ratio + number_of_taps + 1) / 2
@@ -620,28 +610,36 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	/* Adjust for viewport end clip-off */
 	if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
 		int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
-		int int_part = dal_fixed31_32_floor(data->inits.h);
+		int int_part = dal_fixed31_32_floor(
+				dal_fixed31_32_sub(data->inits.h, data->ratios.horz));
 
+		int_part = int_part > 0 ? int_part : 0;
 		data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
 	}
 	if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
 		int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
-		int int_part = dal_fixed31_32_floor(data->inits.v);
+		int int_part = dal_fixed31_32_floor(
+				dal_fixed31_32_sub(data->inits.v, data->ratios.vert));
 
+		int_part = int_part > 0 ? int_part : 0;
 		data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
 	}
 	if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
 		int vp_clip = (src.x + src.width) / vpc_div -
 				data->viewport_c.width - data->viewport_c.x;
-		int int_part = dal_fixed31_32_floor(data->inits.h_c);
+		int int_part = dal_fixed31_32_floor(
+				dal_fixed31_32_sub(data->inits.h_c, data->ratios.horz_c));
 
+		int_part = int_part > 0 ? int_part : 0;
 		data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
 	}
 	if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
 		int vp_clip = (src.y + src.height) / vpc_div -
 				data->viewport_c.height - data->viewport_c.y;
-		int int_part = dal_fixed31_32_floor(data->inits.v_c);
+		int int_part = dal_fixed31_32_floor(
+				dal_fixed31_32_sub(data->inits.v_c, data->ratios.vert_c));
 
+		int_part = int_part > 0 ? int_part : 0;
 		data->viewport_c.height += int_part < vp_clip ? int_part : vp_clip;
 	}
 
@@ -733,6 +731,12 @@ static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *r
 	/* Interlaced inits based on final vert inits */
 	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
 	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
+
+	if (pipe_ctx->surface->public.rotation == ROTATION_ANGLE_90 ||
+			pipe_ctx->surface->public.rotation == ROTATION_ANGLE_270) {
+		rect_swap_helper(&data->viewport_c);
+		rect_swap_helper(&data->viewport);
+	}
 }
 
 bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
@@ -780,6 +784,7 @@ bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
 	}
 
 	if (res)
+		/* May need to re-check lb size after this in some obscure scenario */
 		calculate_inits_and_adj_vp(pipe_ctx, &recout_skip);
 
 	dm_logger_write(pipe_ctx->stream->ctx->logger, LOG_SCALER,

commit 9e6c74ceef866edf2cec380c8ce06ef73d56478d
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Mar 6 14:57:28 2017 -0500

    drm/amd/display: fix hsplit viewport calculation for rotated/mirrored usecases
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index d4b338fa4ab9..e34b52e28e52 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -412,6 +412,8 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	struct rect clip = {0};
 	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
 			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
+	bool need_split = (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface)
+		|| (pipe_ctx->bottom_pipe && pipe_ctx->bottom_pipe->surface == pipe_ctx->surface);
 
 
 	if (surface->rotation == ROTATION_ANGLE_90 ||
@@ -466,17 +468,40 @@ static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
 
 	/* Handle hsplit */
-	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
-		data->viewport.width /= 2;
-		data->viewport_c.width /= 2;
-		data->viewport.x +=  data->viewport.width;
-		data->viewport_c.x +=  data->viewport_c.width;
-		/* Floor primary pipe, ceil 2ndary pipe */
-		data->viewport.width += data->viewport.width % 2;
-		data->viewport_c.width += data->viewport_c.width % 2;
-	} else if (pipe_ctx->bottom_pipe && pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
-		data->viewport.width /= 2;
-		data->viewport_c.width /= 2;
+	if (need_split && (surface->rotation == ROTATION_ANGLE_90 ||
+				surface->rotation == ROTATION_ANGLE_270)) {
+		bool lower_view = (surface->rotation == ROTATION_ANGLE_270) ^
+			(pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface);
+
+		if (lower_view) {
+			data->viewport.height /= 2;
+			data->viewport_c.height /= 2;
+			data->viewport.y +=  data->viewport.height;
+			data->viewport_c.y +=  data->viewport_c.height;
+			/* Ceil offset pipe */
+			data->viewport.height += data->viewport.height % 2;
+			data->viewport_c.height += data->viewport_c.height % 2;
+		} else {
+			data->viewport.height /= 2;
+			data->viewport_c.height /= 2;
+		}
+	} else if (need_split) {
+		bool right_view = (surface->rotation == ROTATION_ANGLE_180) ^
+			(pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface) ^
+			surface->horizontal_mirror;
+
+		if (right_view) {
+			data->viewport.width /= 2;
+			data->viewport_c.width /= 2;
+			data->viewport.x +=  data->viewport.width;
+			data->viewport_c.x +=  data->viewport_c.width;
+			/* Ceil offset pipe */
+			data->viewport.width += data->viewport.width % 2;
+			data->viewport_c.width += data->viewport_c.width % 2;
+		} else {
+			data->viewport.width /= 2;
+			data->viewport_c.width /= 2;
+		}
 	}
 }
 

commit b2d0a103e6a0a823b46dd2d7f8c2de82c419e286
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Mar 1 18:27:17 2017 -0500

    drm/amd/display: add init calculation to scaler params
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 326019407cb1..d4b338fa4ab9 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -401,15 +401,17 @@ static void rect_swap_helper(struct rect *rect)
 	rect->y = temp;
 }
 
-static void calculate_viewport(
-		const struct dc_surface *surface,
-		struct pipe_ctx *pipe_ctx)
+static void calculate_viewport(struct pipe_ctx *pipe_ctx)
 {
+	const struct dc_surface *surface = &pipe_ctx->surface->public;
+	struct scaler_data *data = &pipe_ctx->scl_data;
 	struct rect stream_src = pipe_ctx->stream->public.src;
 	struct rect src = surface->src_rect;
 	struct rect dst = surface->dst_rect;
 	struct rect surface_clip = surface->clip_rect;
 	struct rect clip = {0};
+	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
+			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
 
 
 	if (surface->rotation == ROTATION_ANGLE_90 ||
@@ -442,27 +444,45 @@ static void calculate_viewport(
 	/* offset = src.ofs + (clip.ofs - dst.ofs) * scl_ratio
 	 * num_pixels = clip.num_pix * scl_ratio
 	 */
-	pipe_ctx->scl_data.viewport.x = src.x + (clip.x - dst.x) *
+	data->viewport.x = src.x + (clip.x - dst.x) *
 			src.width / dst.width;
-	pipe_ctx->scl_data.viewport.width = clip.width *
+	data->viewport.width = clip.width *
 			src.width / dst.width;
 
-	pipe_ctx->scl_data.viewport.y = src.y + (clip.y - dst.y) *
+	data->viewport.y = src.y + (clip.y - dst.y) *
 			src.height / dst.height;
-	pipe_ctx->scl_data.viewport.height = clip.height *
+	data->viewport.height = clip.height *
 			src.height / dst.height;
 
-	/* Minimum viewport such that 420/422 chroma vp is non 0 */
-	if (pipe_ctx->scl_data.viewport.width < 2)
-		pipe_ctx->scl_data.viewport.width = 2;
-	if (pipe_ctx->scl_data.viewport.height < 2)
-		pipe_ctx->scl_data.viewport.height = 2;
+	/* Round down, compensate in init */
+	data->viewport_c.x = data->viewport.x / vpc_div;
+	data->viewport_c.y = data->viewport.y / vpc_div;
+	data->inits.h_c = (data->viewport.x % vpc_div) != 0 ?
+			dal_fixed31_32_half : dal_fixed31_32_zero;
+	data->inits.v_c = (data->viewport.y % vpc_div) != 0 ?
+			dal_fixed31_32_half : dal_fixed31_32_zero;
+	/* Round up, assume original video size always even dimensions */
+	data->viewport_c.width = (data->viewport.width + vpc_div - 1) / vpc_div;
+	data->viewport_c.height = (data->viewport.height + vpc_div - 1) / vpc_div;
+
+	/* Handle hsplit */
+	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+		data->viewport.width /= 2;
+		data->viewport_c.width /= 2;
+		data->viewport.x +=  data->viewport.width;
+		data->viewport_c.x +=  data->viewport_c.width;
+		/* Floor primary pipe, ceil 2ndary pipe */
+		data->viewport.width += data->viewport.width % 2;
+		data->viewport_c.width += data->viewport_c.width % 2;
+	} else if (pipe_ctx->bottom_pipe && pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+		data->viewport.width /= 2;
+		data->viewport_c.width /= 2;
+	}
 }
 
-static void calculate_recout(
-		const struct dc_surface *surface,
-		struct pipe_ctx *pipe_ctx)
+static void calculate_recout(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
+	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct core_stream *stream = pipe_ctx->stream;
 	struct rect clip = surface->clip_rect;
 
@@ -493,12 +513,26 @@ static void calculate_recout(
 		pipe_ctx->scl_data.recout.height =
 			stream->public.dst.y + stream->public.dst.height
 						- pipe_ctx->scl_data.recout.y;
+
+	/* Handle hsplit */
+	if (pipe_ctx->top_pipe && pipe_ctx->top_pipe->surface == pipe_ctx->surface) {
+		pipe_ctx->scl_data.recout.width /= 2;
+		pipe_ctx->scl_data.recout.x += pipe_ctx->scl_data.recout.width;
+		/* Floor primary pipe, ceil 2ndary pipe */
+		pipe_ctx->scl_data.recout.width += pipe_ctx->scl_data.recout.width % 2;
+	} else if (pipe_ctx->bottom_pipe && pipe_ctx->bottom_pipe->surface == pipe_ctx->surface) {
+		pipe_ctx->scl_data.recout.width /= 2;
+	}
+
+	recout_skip->width = pipe_ctx->scl_data.recout.x - stream->public.dst.x -
+			surface->dst_rect.x * stream->public.dst.width / stream->public.src.width;
+	recout_skip->height = pipe_ctx->scl_data.recout.y - stream->public.dst.y -
+			surface->dst_rect.y * stream->public.dst.height / stream->public.src.height;
 }
 
-static void calculate_scaling_ratios(
-		const struct dc_surface *surface,
-		struct pipe_ctx *pipe_ctx)
+static void calculate_scaling_ratios(struct pipe_ctx *pipe_ctx)
 {
+	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct core_stream *stream = pipe_ctx->stream;
 	const uint32_t in_w = stream->public.src.width;
 	const uint32_t in_h = stream->public.src.height;
@@ -525,31 +559,179 @@ static void calculate_scaling_ratios(
 	pipe_ctx->scl_data.ratios.horz_c = pipe_ctx->scl_data.ratios.horz;
 	pipe_ctx->scl_data.ratios.vert_c = pipe_ctx->scl_data.ratios.vert;
 
-	if (pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP12) {
+	if (pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP12
+			|| pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP15) {
 		pipe_ctx->scl_data.ratios.horz_c.value /= 2;
 		pipe_ctx->scl_data.ratios.vert_c.value /= 2;
 	}
 }
 
-bool resource_build_scaling_params(
-	const struct dc_surface *surface,
-	struct pipe_ctx *pipe_ctx)
+static void calculate_inits_and_adj_vp(struct pipe_ctx *pipe_ctx, struct view *recout_skip)
 {
-	bool res;
+	struct scaler_data *data = &pipe_ctx->scl_data;
+	struct rect src = pipe_ctx->surface->public.src_rect;
+	int vpc_div = (data->format == PIXEL_FORMAT_420BPP12
+			|| data->format == PIXEL_FORMAT_420BPP15) ? 2 : 1;
+
+	/*
+	 * Init calculated according to formula:
+	 * 	init = (scaling_ratio + number_of_taps + 1) / 2
+	 * 	init_bot = init + scaling_ratio
+	 * 	init_c = init + truncated_vp_c_offset(from calculate viewport)
+	 */
+	data->inits.h = dal_fixed31_32_div_int(
+			dal_fixed31_32_add_int(data->ratios.horz, data->taps.h_taps + 1), 2);
+
+	data->inits.h_c = dal_fixed31_32_add(data->inits.h_c, dal_fixed31_32_div_int(
+			dal_fixed31_32_add_int(data->ratios.horz_c, data->taps.h_taps_c + 1), 2));
+
+	data->inits.v = dal_fixed31_32_div_int(
+			dal_fixed31_32_add_int(data->ratios.vert, data->taps.v_taps + 1), 2);
+
+	data->inits.v_c = dal_fixed31_32_add(data->inits.v_c, dal_fixed31_32_div_int(
+			dal_fixed31_32_add_int(data->ratios.vert_c, data->taps.v_taps_c + 1), 2));
+
+
+	/* Adjust for viewport end clip-off */
+	if ((data->viewport.x + data->viewport.width) < (src.x + src.width)) {
+		int vp_clip = src.x + src.width - data->viewport.width - data->viewport.x;
+		int int_part = dal_fixed31_32_floor(data->inits.h);
+
+		data->viewport.width += int_part < vp_clip ? int_part : vp_clip;
+	}
+	if ((data->viewport.y + data->viewport.height) < (src.y + src.height)) {
+		int vp_clip = src.y + src.height - data->viewport.height - data->viewport.y;
+		int int_part = dal_fixed31_32_floor(data->inits.v);
+
+		data->viewport.height += int_part < vp_clip ? int_part : vp_clip;
+	}
+	if ((data->viewport_c.x + data->viewport_c.width) < (src.x + src.width) / vpc_div) {
+		int vp_clip = (src.x + src.width) / vpc_div -
+				data->viewport_c.width - data->viewport_c.x;
+		int int_part = dal_fixed31_32_floor(data->inits.h_c);
+
+		data->viewport_c.width += int_part < vp_clip ? int_part : vp_clip;
+	}
+	if ((data->viewport_c.y + data->viewport_c.height) < (src.y + src.height) / vpc_div) {
+		int vp_clip = (src.y + src.height) / vpc_div -
+				data->viewport_c.height - data->viewport_c.y;
+		int int_part = dal_fixed31_32_floor(data->inits.v_c);
+
+		data->viewport_c.height += int_part < vp_clip ? int_part : vp_clip;
+	}
+
+	/* Adjust for non-0 viewport offset */
+	if (data->viewport.x) {
+		int int_part;
+
+		data->inits.h = dal_fixed31_32_add(data->inits.h, dal_fixed31_32_mul_int(
+				data->ratios.horz, recout_skip->width));
+		int_part = dal_fixed31_32_floor(data->inits.h) - data->viewport.x;
+		if (int_part < data->taps.h_taps) {
+			int int_adj = data->viewport.x >= (data->taps.h_taps - int_part) ?
+						(data->taps.h_taps - int_part) : data->viewport.x;
+			data->viewport.x -= int_adj;
+			data->viewport.width += int_adj;
+			int_part += int_adj;
+		} else if (int_part > data->taps.h_taps) {
+			data->viewport.x += int_part - data->taps.h_taps;
+			data->viewport.width -= int_part - data->taps.h_taps;
+			int_part = data->taps.h_taps;
+		}
+		data->inits.h.value &= 0xffffffff;
+		data->inits.h = dal_fixed31_32_add_int(data->inits.h, int_part);
+	}
+
+	if (data->viewport_c.x) {
+		int int_part;
+
+		data->inits.h_c = dal_fixed31_32_add(data->inits.h_c, dal_fixed31_32_mul_int(
+				data->ratios.horz_c, recout_skip->width));
+		int_part = dal_fixed31_32_floor(data->inits.h_c) - data->viewport_c.x;
+		if (int_part < data->taps.h_taps_c) {
+			int int_adj = data->viewport_c.x >= (data->taps.h_taps_c - int_part) ?
+					(data->taps.h_taps_c - int_part) : data->viewport_c.x;
+			data->viewport_c.x -= int_adj;
+			data->viewport_c.width += int_adj;
+			int_part += int_adj;
+		} else if (int_part > data->taps.h_taps_c) {
+			data->viewport_c.x += int_part - data->taps.h_taps_c;
+			data->viewport_c.width -= int_part - data->taps.h_taps_c;
+			int_part = data->taps.h_taps_c;
+		}
+		data->inits.h_c.value &= 0xffffffff;
+		data->inits.h_c = dal_fixed31_32_add_int(data->inits.h_c, int_part);
+	}
+
+	if (data->viewport.y) {
+		int int_part;
+
+		data->inits.v = dal_fixed31_32_add(data->inits.v, dal_fixed31_32_mul_int(
+				data->ratios.vert, recout_skip->height));
+		int_part = dal_fixed31_32_floor(data->inits.v) - data->viewport.y;
+		if (int_part < data->taps.v_taps) {
+			int int_adj = data->viewport.y >= (data->taps.v_taps - int_part) ?
+						(data->taps.v_taps - int_part) : data->viewport.y;
+			data->viewport.y -= int_adj;
+			data->viewport.height += int_adj;
+			int_part += int_adj;
+		} else if (int_part > data->taps.v_taps) {
+			data->viewport.y += int_part - data->taps.v_taps;
+			data->viewport.height -= int_part - data->taps.v_taps;
+			int_part = data->taps.v_taps;
+		}
+		data->inits.v.value &= 0xffffffff;
+		data->inits.v = dal_fixed31_32_add_int(data->inits.v, int_part);
+	}
+
+	if (data->viewport_c.y) {
+		int int_part;
+
+		data->inits.v_c = dal_fixed31_32_add(data->inits.v_c, dal_fixed31_32_mul_int(
+				data->ratios.vert_c, recout_skip->height));
+		int_part = dal_fixed31_32_floor(data->inits.v_c) - data->viewport_c.y;
+		if (int_part < data->taps.v_taps_c) {
+			int int_adj = data->viewport_c.y >= (data->taps.v_taps_c - int_part) ?
+					(data->taps.v_taps_c - int_part) : data->viewport_c.y;
+			data->viewport_c.y -= int_adj;
+			data->viewport_c.height += int_adj;
+			int_part += int_adj;
+		} else if (int_part > data->taps.v_taps_c) {
+			data->viewport_c.y += int_part - data->taps.v_taps_c;
+			data->viewport_c.height -= int_part - data->taps.v_taps_c;
+			int_part = data->taps.v_taps_c;
+		}
+		data->inits.v_c.value &= 0xffffffff;
+		data->inits.v_c = dal_fixed31_32_add_int(data->inits.v_c, int_part);
+	}
+
+	/* Interlaced inits based on final vert inits */
+	data->inits.v_bot = dal_fixed31_32_add(data->inits.v, data->ratios.vert);
+	data->inits.v_c_bot = dal_fixed31_32_add(data->inits.v_c, data->ratios.vert_c);
+}
+
+bool resource_build_scaling_params(struct pipe_ctx *pipe_ctx)
+{
+	const struct dc_surface *surface = &pipe_ctx->surface->public;
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	struct view recout_skip = { 0 };
+	bool res = false;
+
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
+	 * Inits require viewport, taps, ratios and recout of split pipe
 	 */
-	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(surface->format);
+	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(
+			pipe_ctx->surface->public.format);
+
+	calculate_scaling_ratios(pipe_ctx);
 
-	calculate_viewport(surface, pipe_ctx);
+	calculate_viewport(pipe_ctx);
 
 	if (pipe_ctx->scl_data.viewport.height < 16 || pipe_ctx->scl_data.viewport.width < 16)
 		return false;
 
-	calculate_scaling_ratios(surface, pipe_ctx);
-
-	calculate_recout(surface, pipe_ctx);
+	calculate_recout(pipe_ctx, &recout_skip);
 
 	/**
 	 * Setting line buffer pixel depth to 24bpp yields banding
@@ -572,6 +754,9 @@ bool resource_build_scaling_params(
 			pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
 	}
 
+	if (res)
+		calculate_inits_and_adj_vp(pipe_ctx, &recout_skip);
+
 	dm_logger_write(pipe_ctx->stream->ctx->logger, LOG_SCALER,
 				"%s: Viewport:\nheight:%d width:%d x:%d "
 				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
@@ -599,9 +784,7 @@ enum dc_status resource_build_scaling_params_for_context(
 	for (i = 0; i < MAX_PIPES; i++) {
 		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
 				context->res_ctx.pipe_ctx[i].stream != NULL)
-			if (!resource_build_scaling_params(
-				&context->res_ctx.pipe_ctx[i].surface->public,
-				&context->res_ctx.pipe_ctx[i]))
+			if (!resource_build_scaling_params(&context->res_ctx.pipe_ctx[i]))
 				return DC_FAIL_SCALING;
 	}
 

commit 4a9a5d62ec01755d36aa72782ff023da417b472a
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Tue Mar 7 11:48:50 2017 -0500

    drm/amd/display: Refactor on dc_sink structure.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index c38f71e45381..326019407cb1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1193,7 +1193,7 @@ enum dc_status resource_map_pool_resources(
 			pipe_ctx->stream_enc);
 
 		/* TODO: Add check if ASIC support and EDID audio */
-		if (!stream->sink->converter_disable_audio &&
+		if (!stream->sink->public.converter_disable_audio &&
 			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
 			stream->public.audio_info.mode_count) {
 			pipe_ctx->audio = find_first_free_audio(

commit 268cadbd653d3d9172975a46c79f458475f82cb5
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Mar 6 14:58:59 2017 -0500

    drm/amd/display: Do not copy bottom pipe when map resource.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f1b1dae5399e..c38f71e45381 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1134,6 +1134,9 @@ enum dc_status resource_map_pool_resources(
 			if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
 				continue;
 
+			if (old_pipe_ctx->top_pipe)
+				continue;
+
 			pipe_ctx->stream = stream;
 			copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
 

commit 5ac3d3c9b79fb607fc25268c8dbd220ac14f5ac6
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Mar 3 13:44:35 2017 -0500

    drm/amd/display: move refclk from dc to resource_pool
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 407ce60f253e..f1b1dae5399e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -31,6 +31,7 @@
 #include "opp.h"
 #include "timing_generator.h"
 #include "transform.h"
+#include "core_types.h"
 #include "set_mode_types.h"
 #include "virtual/virtual_stream_encoder.h"
 
@@ -77,25 +78,39 @@ struct resource_pool *dc_create_resource_pool(
 				enum dce_version dc_version,
 				struct hw_asic_id asic_id)
 {
+	struct resource_pool *res_pool = NULL;
 
 	switch (dc_version) {
 	case DCE_VERSION_8_0:
-		return dce80_create_resource_pool(
+		res_pool = dce80_create_resource_pool(
 			num_virtual_links, dc);
+		break;
 	case DCE_VERSION_10_0:
-		return dce100_create_resource_pool(
+		res_pool = dce100_create_resource_pool(
 				num_virtual_links, dc);
+		break;
 	case DCE_VERSION_11_0:
-		return dce110_create_resource_pool(
+		res_pool = dce110_create_resource_pool(
 			num_virtual_links, dc, asic_id);
+		break;
 	case DCE_VERSION_11_2:
-		return dce112_create_resource_pool(
+		res_pool = dce112_create_resource_pool(
 			num_virtual_links, dc);
+		break;
 	default:
 		break;
 	}
+	if (res_pool != NULL) {
+		struct firmware_info fw_info = { { 0 } };
+
+		if (dc->ctx->dc_bios->funcs->get_firmware_info(
+				dc->ctx->dc_bios, &fw_info) == BP_RESULT_OK) {
+				res_pool->ref_clock_inKhz = fw_info.pll_info.crystal_frequency;
+			} else
+				ASSERT_CRITICAL(false);
+	}
 
-	return false;
+	return res_pool;
 }
 
 void dc_destroy_resource_pool(struct core_dc *dc)

commit 4b679bc3cab09f2af44bd34dfc197939a4602aa8
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Feb 22 13:46:29 2017 -0500

    drm/amd/display: HDMI deep color mode audio issue
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4d556b379524..407ce60f253e 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1101,9 +1101,14 @@ enum dc_status resource_map_pool_resources(
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
 
-		if (!resource_is_stream_unchanged(dc->current_context, stream))
+		if (!resource_is_stream_unchanged(dc->current_context, stream)) {
+			if (stream != NULL && dc->current_context->streams[i] != NULL) {
+				stream->bit_depth_params =
+						dc->current_context->streams[i]->bit_depth_params;
+				stream->clamping = dc->current_context->streams[i]->clamping;
 			continue;
-
+		}
+	}
 		/* mark resources used for stream that is already active */
 		for (j = 0; j < MAX_PIPES; j++) {
 			struct pipe_ctx *pipe_ctx =

commit 70063a5957126087f167ff3890784d7b3b36c844
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Thu Feb 16 11:04:48 2017 -0500

    drm/amd/display: Add bypass case for PQ transfer function
    
    - Source and destination color space should be the same for
      app control case
    - Bypass degamma, regamma, and gamut remap
    - Add hdr supported check for info frame
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 991828f503aa..4d556b379524 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1675,7 +1675,7 @@ static void set_hdr_static_info_packet(
 
 	hdr_metadata = surface->public.hdr_static_ctx;
 
-	if (!hdr_metadata.is_hdr)
+	if (!hdr_metadata.hdr_supported)
 		return;
 
 	if (dc_is_hdmi_signal(signal)) {

commit 17a96033dae7e56cd48d1b3c952e0b4ca9384312
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Tue Feb 14 07:14:58 2017 +0100

    drm/amd/dc: fix semicolon.cocci warnings
    
    Remove unneeded semicolon.
    
    Generated by: scripts/coccinelle/misc/semicolon.cocci
    
    Signed-off-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index e4e86110d45d..991828f503aa 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -135,7 +135,7 @@ static void update_num_audio(
 		break;
 	default:
 		DC_ERR("DC: unexpected audio fuse!\n");
-	};
+	}
 }
 
 bool resource_construct(

commit ffbcd19a8856a63f4310c89b2af599409e3f2216
Author: Vitaly Prosyak <vitaly.prosyak@amd.com>
Date:   Wed Feb 1 12:54:15 2017 -0600

    drm/amd/display: Adding 10 bpcc video P010 format
    
    Signed-off-by: Vitaly Prosyak <vitaly.prosyak@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 856a33ad8ec1..e4e86110d45d 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -358,11 +358,13 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 		dal_pixel_format = PIXEL_FORMAT_FP16;
 		break;
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
-		dal_pixel_format = PIXEL_FORMAT_420BPP12;
-		break;
 	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
 		dal_pixel_format = PIXEL_FORMAT_420BPP12;
 		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCbCr:
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb:
+		dal_pixel_format = PIXEL_FORMAT_420BPP15;
+		break;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
 	default:
 		dal_pixel_format = PIXEL_FORMAT_UNKNOWN;

commit cc4d99b8a888e16093b985d6a11fbd37ab92697c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Wed Feb 1 20:35:53 2017 -0500

    drm/amd/display: HDMI YCbCr422 12bpc pixel format issue
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 3d8a85e48b05..856a33ad8ec1 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1045,25 +1045,25 @@ static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
 
 	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
 		pix_clk /= 2;
-
-	switch (timing->display_color_depth) {
-	case COLOR_DEPTH_888:
-		normalized_pix_clk = pix_clk;
-		break;
-	case COLOR_DEPTH_101010:
-		normalized_pix_clk = (pix_clk * 30) / 24;
+	if (timing->pixel_encoding != PIXEL_ENCODING_YCBCR422) {
+		switch (timing->display_color_depth) {
+		case COLOR_DEPTH_888:
+			normalized_pix_clk = pix_clk;
+			break;
+		case COLOR_DEPTH_101010:
+			normalized_pix_clk = (pix_clk * 30) / 24;
+			break;
+		case COLOR_DEPTH_121212:
+			normalized_pix_clk = (pix_clk * 36) / 24;
 		break;
-	case COLOR_DEPTH_121212:
-		normalized_pix_clk = (pix_clk * 36) / 24;
+		case COLOR_DEPTH_161616:
+			normalized_pix_clk = (pix_clk * 48) / 24;
 		break;
-	case COLOR_DEPTH_161616:
-		normalized_pix_clk = (pix_clk * 48) / 24;
-		break;
-	default:
-		ASSERT(0);
+		default:
+			ASSERT(0);
 		break;
+		}
 	}
-
 	return normalized_pix_clk;
 }
 

commit 8fde5884f4a18dec81ab5d498bf7bf3c156f8dfb
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Jan 31 20:18:05 2017 -0500

    drm/amd/display: Fix YCbCr pixel format shows green issue
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index ee1c3b029394..3d8a85e48b05 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1300,19 +1300,23 @@ static void set_avi_info_frame(
 	info_frame.avi_info_packet.info_packet_hdmi.bits.S0_S1 = scan_type;
 
 	/* C0, C1 : Colorimetry */
-	if (color_space == COLOR_SPACE_YCBCR709)
+	if (color_space == COLOR_SPACE_YCBCR709 ||
+			color_space == COLOR_SPACE_YCBCR709_LIMITED)
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_ITU709;
-	else if (color_space == COLOR_SPACE_YCBCR601)
+	else if (color_space == COLOR_SPACE_YCBCR601 ||
+			color_space == COLOR_SPACE_YCBCR601_LIMITED)
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_ITU601;
-	else
+	else {
+		if (stream->public.timing.pixel_encoding != PIXEL_ENCODING_RGB)
+			BREAK_TO_DEBUGGER();
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_NO_DATA;
-
+	}
 	if (color_space == COLOR_SPACE_2020_RGB_FULLRANGE ||
-		color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE ||
-		color_space == COLOR_SPACE_2020_YCBCR) {
+			color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE ||
+			color_space == COLOR_SPACE_2020_YCBCR) {
 		info_frame.avi_info_packet.info_packet_hdmi.bits.EC0_EC2 =
 				COLORIMETRYEX_BT2020RGBYCBCR;
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =

commit 8693049a896c2c3a2bb74f0efde62318636beaef
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Mon Jan 16 20:50:47 2017 -0500

    drm/amd/display: rename BGRA8888 to ABGR8888
    
    DC actually support ABGR8888 instead of BGRA8888 (R/B swap rather than endian swap) ,
    rename to avoid confusion
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 8b41c7708562..ee1c3b029394 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -341,7 +341,7 @@ static enum pixel_format convert_pixel_format_to_dalsurface(
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
 		dal_pixel_format = PIXEL_FORMAT_ARGB8888;
 		break;
-	case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		dal_pixel_format = PIXEL_FORMAT_ARGB8888;
 		break;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:

commit 534db198866070fdb655423637afdce6cf0c05db
Author: Amy Zhang <Amy.Zhang@amd.com>
Date:   Fri Jan 13 16:49:26 2017 -0500

    drm/amd/display: HDR Enablement For Applications
    
    - Made sure dest color space is updated in stream and info frame
    - Optimized segment distribution algorithm for regamma mapping
    
    Signed-off-by: Amy Zhang <Amy.Zhang@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index fe79a2890247..8b41c7708562 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1310,6 +1310,20 @@ static void set_avi_info_frame(
 		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
 				COLORIMETRY_NO_DATA;
 
+	if (color_space == COLOR_SPACE_2020_RGB_FULLRANGE ||
+		color_space == COLOR_SPACE_2020_RGB_LIMITEDRANGE ||
+		color_space == COLOR_SPACE_2020_YCBCR) {
+		info_frame.avi_info_packet.info_packet_hdmi.bits.EC0_EC2 =
+				COLORIMETRYEX_BT2020RGBYCBCR;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
+				COLORIMETRY_EXTENDED;
+	} else if (color_space == COLOR_SPACE_ADOBERGB) {
+		info_frame.avi_info_packet.info_packet_hdmi.bits.EC0_EC2 =
+				COLORIMETRYEX_ADOBERGB;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
+				COLORIMETRY_EXTENDED;
+	}
+
 	/* TODO: un-hardcode aspect ratio */
 	aspect = stream->public.timing.aspect_ratio;
 

commit 6e4d6beec6dae279ec7ac27c9034b2208898f382
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Jan 14 20:36:14 2017 -0500

    drm/amd/display: remove hw_info_frame
    
    - construct using encoder_info_frame directly
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 6037ee25598c..fe79a2890247 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1211,70 +1211,27 @@ void validate_guaranteed_copy_streams(
 	}
 }
 
-static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
-	struct encoder_info_frame *encoder_info_frame)
+static void patch_gamut_packet_checksum(
+		struct encoder_info_packet *gamut_packet)
 {
-	memset(
-		encoder_info_frame, 0, sizeof(struct encoder_info_frame));
-
 	/* For gamut we recalc checksum */
-	if (hw_info_frame->gamut_packet.valid) {
+	if (gamut_packet->valid) {
 		uint8_t chk_sum = 0;
 		uint8_t *ptr;
 		uint8_t i;
 
-		memmove(
-						&encoder_info_frame->gamut,
-						&hw_info_frame->gamut_packet,
-						sizeof(struct hw_info_packet));
-
 		/*start of the Gamut data. */
-		ptr = &encoder_info_frame->gamut.sb[3];
+		ptr = &gamut_packet->sb[3];
 
-		for (i = 0; i <= encoder_info_frame->gamut.sb[1]; i++)
+		for (i = 0; i <= gamut_packet->sb[1]; i++)
 			chk_sum += ptr[i];
 
-		encoder_info_frame->gamut.sb[2] = (uint8_t) (0x100 - chk_sum);
-	}
-
-	if (hw_info_frame->avi_info_packet.valid) {
-		memmove(
-						&encoder_info_frame->avi,
-						&hw_info_frame->avi_info_packet,
-						sizeof(struct hw_info_packet));
-	}
-
-	if (hw_info_frame->vendor_info_packet.valid) {
-		memmove(
-						&encoder_info_frame->vendor,
-						&hw_info_frame->vendor_info_packet,
-						sizeof(struct hw_info_packet));
-	}
-
-	if (hw_info_frame->spd_packet.valid) {
-		memmove(
-						&encoder_info_frame->spd,
-						&hw_info_frame->spd_packet,
-						sizeof(struct hw_info_packet));
-	}
-
-	if (hw_info_frame->vsc_packet.valid) {
-		memmove(
-						&encoder_info_frame->vsc,
-						&hw_info_frame->vsc_packet,
-						sizeof(struct hw_info_packet));
-	}
-
-	if (hw_info_frame->hdrsmd_packet.valid) {
-		memmove(
-						&encoder_info_frame->hdrsmd,
-						&hw_info_frame->hdrsmd_packet,
-						sizeof(struct hw_info_packet));
+		gamut_packet->sb[2] = (uint8_t) (0x100 - chk_sum);
 	}
 }
 
 static void set_avi_info_frame(
-	struct hw_info_packet *info_packet,
+		struct encoder_info_packet *info_packet,
 		struct pipe_ctx *pipe_ctx)
 {
 	struct core_stream *stream = pipe_ctx->stream;
@@ -1288,9 +1245,6 @@ static void set_avi_info_frame(
 	uint8_t *check_sum = NULL;
 	uint8_t byte_index = 0;
 
-	if (info_packet == NULL)
-		return;
-
 	color_space = pipe_ctx->stream->public.output_color_space;
 
 	/* Initialize header */
@@ -1458,8 +1412,9 @@ static void set_avi_info_frame(
 	info_packet->valid = true;
 }
 
-static void set_vendor_info_packet(struct core_stream *stream,
-		struct hw_info_packet *info_packet)
+static void set_vendor_info_packet(
+		struct encoder_info_packet *info_packet,
+		struct core_stream *stream)
 {
 	uint32_t length = 0;
 	bool hdmi_vic_mode = false;
@@ -1467,9 +1422,6 @@ static void set_vendor_info_packet(struct core_stream *stream,
 	uint32_t i = 0;
 	enum dc_timing_3d_format format;
 
-	ASSERT_CRITICAL(stream != NULL);
-	ASSERT_CRITICAL(info_packet != NULL);
-
 	format = stream->public.timing.timing_3d_format;
 
 	/* Can be different depending on packet content */
@@ -1567,8 +1519,9 @@ static void set_vendor_info_packet(struct core_stream *stream,
 	info_packet->valid = true;
 }
 
-static void set_spd_info_packet(struct core_stream *stream,
-		struct hw_info_packet *info_packet)
+static void set_spd_info_packet(
+		struct encoder_info_packet *info_packet,
+		struct core_stream *stream)
 {
 	/* SPD info packet for FreeSync */
 
@@ -1688,9 +1641,9 @@ static void set_spd_info_packet(struct core_stream *stream,
 }
 
 static void set_hdr_static_info_packet(
+		struct encoder_info_packet *info_packet,
 		struct core_surface *surface,
-		struct core_stream *stream,
-		struct hw_info_packet *info_packet)
+		struct core_stream *stream)
 {
 	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
@@ -1791,8 +1744,9 @@ static void set_hdr_static_info_packet(
 	}
 }
 
-static void set_vsc_info_packet(struct core_stream *stream,
-		struct hw_info_packet *info_packet)
+static void set_vsc_info_packet(
+		struct encoder_info_packet *info_packet,
+		struct core_stream *stream)
 {
 	unsigned int vscPacketRevision = 0;
 	unsigned int i;
@@ -1894,36 +1848,38 @@ struct clock_source *dc_resource_find_first_free_pll(
 void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 {
 	enum signal_type signal = SIGNAL_TYPE_NONE;
-	struct hw_info_frame info_frame = { { 0 } };
+	struct encoder_info_frame *info = &pipe_ctx->encoder_info_frame;
 
 	/* default all packets to invalid */
-	info_frame.avi_info_packet.valid = false;
-	info_frame.gamut_packet.valid = false;
-	info_frame.vendor_info_packet.valid = false;
-	info_frame.spd_packet.valid = false;
-	info_frame.vsc_packet.valid = false;
-	info_frame.hdrsmd_packet.valid = false;
+	info->avi.valid = false;
+	info->gamut.valid = false;
+	info->vendor.valid = false;
+	info->hdrsmd.valid = false;
+	info->vsc.valid = false;
 
 	signal = pipe_ctx->stream->signal;
 
 	/* HDMi and DP have different info packets*/
 	if (dc_is_hdmi_signal(signal)) {
-		set_avi_info_frame(
-			&info_frame.avi_info_packet, pipe_ctx);
-		set_vendor_info_packet(
-			pipe_ctx->stream, &info_frame.vendor_info_packet);
-		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
-		set_hdr_static_info_packet(pipe_ctx->surface,
-				pipe_ctx->stream, &info_frame.hdrsmd_packet);
+		set_avi_info_frame(&info->avi, pipe_ctx);
+
+		set_vendor_info_packet(&info->vendor, pipe_ctx->stream);
+
+		set_spd_info_packet(&info->spd, pipe_ctx->stream);
+
+		set_hdr_static_info_packet(&info->hdrsmd,
+				pipe_ctx->surface, pipe_ctx->stream);
+
 	} else if (dc_is_dp_signal(signal)) {
-		set_vsc_info_packet(pipe_ctx->stream, &info_frame.vsc_packet);
-		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
-		set_hdr_static_info_packet(pipe_ctx->surface,
-				pipe_ctx->stream, &info_frame.hdrsmd_packet);
+		set_vsc_info_packet(&info->vsc, pipe_ctx->stream);
+
+		set_spd_info_packet(&info->spd, pipe_ctx->stream);
+
+		set_hdr_static_info_packet(&info->hdrsmd,
+				pipe_ctx->surface, pipe_ctx->stream);
 	}
 
-	translate_info_frame(&info_frame,
-			&pipe_ctx->encoder_info_frame);
+	patch_gamut_packet_checksum(&info->gamut);
 }
 
 enum dc_status resource_map_clock_resources(

commit f84a8161cb1652281746d113667427dbbf8bd5db
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Thu Jan 12 23:18:33 2017 -0500

    drm/amd/display: mode change without breaking unaffected streams
    
    - include clock constraint logic in validate
    - in dc_commit_streams, include surfaces of unaffected streams
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 1f87b948678b..6037ee25598c 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -585,7 +585,7 @@ enum dc_status resource_build_scaling_params_for_context(
 			if (!resource_build_scaling_params(
 				&context->res_ctx.pipe_ctx[i].surface->public,
 				&context->res_ctx.pipe_ctx[i]))
-				return DC_FAIL_BANDWIDTH_VALIDATE;
+				return DC_FAIL_SCALING;
 	}
 
 	return DC_OK;

commit ab2541b67395088b9de8ebf3943ef9ef86bccc41
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Thu Dec 29 15:27:12 2016 -0500

    drm/amd/display: Remove dc_target object
    
    dc_target does not fit well into DRM framework so removed it.
    This will prevent the driver from leveraging the pipe-split
    code for tiled displays, so will have to be handled at a higher
    level.  Most places that used dc_target now directly use dc_stream
    instead.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 4bb6b1d9c970..1f87b948678b 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -591,12 +591,12 @@ enum dc_status resource_build_scaling_params_for_context(
 	return DC_OK;
 }
 
-static void detach_surfaces_for_target(
+static void detach_surfaces_for_stream(
 		struct validate_context *context,
-		const struct dc_target *dc_target)
+		const struct dc_stream *dc_stream)
 {
 	int i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
 		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
@@ -646,15 +646,15 @@ struct pipe_ctx *resource_get_head_pipe_for_stream(
 }
 
 /*
- * A free_pipe for a target is defined here as a pipe with a stream that belongs
- * to the target but has no surface attached yet
+ * A free_pipe for a stream is defined here as a pipe
+ * that has no surface attached yet
  */
-static struct pipe_ctx *acquire_free_pipe_for_target(
+static struct pipe_ctx *acquire_free_pipe_for_stream(
 		struct resource_context *res_ctx,
-		const struct dc_target *dc_target)
+		const struct dc_stream *dc_stream)
 {
 	int i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	struct pipe_ctx *head_pipe = NULL;
 
@@ -688,12 +688,12 @@ static struct pipe_ctx *acquire_free_pipe_for_target(
 
 }
 
-static void release_free_pipes_for_target(
+static void release_free_pipes_for_stream(
 		struct resource_context *res_ctx,
-		const struct dc_target *dc_target)
+		const struct dc_stream *dc_stream)
 {
 	int i;
-	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_stream);
 
 	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
 		if (res_ctx->pipe_ctx[i].stream == stream &&
@@ -706,12 +706,12 @@ static void release_free_pipes_for_target(
 bool resource_attach_surfaces_to_context(
 		const struct dc_surface * const *surfaces,
 		int surface_count,
-		const struct dc_target *dc_target,
+		const struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	int i;
 	struct pipe_ctx *tail_pipe;
-	struct dc_target_status *target_status = NULL;
+	struct dc_stream_status *stream_status = NULL;
 
 
 	if (surface_count > MAX_SURFACE_NUM) {
@@ -720,13 +720,13 @@ bool resource_attach_surfaces_to_context(
 		return false;
 	}
 
-	for (i = 0; i < context->target_count; i++)
-		if (&context->targets[i]->public == dc_target) {
-			target_status = &context->target_status[i];
+	for (i = 0; i < context->stream_count; i++)
+		if (&context->streams[i]->public == dc_stream) {
+			stream_status = &context->stream_status[i];
 			break;
 		}
-	if (target_status == NULL) {
-		dm_error("Existing target not found; failed to attach surfaces\n");
+	if (stream_status == NULL) {
+		dm_error("Existing stream not found; failed to attach surfaces\n");
 		return false;
 	}
 
@@ -734,16 +734,16 @@ bool resource_attach_surfaces_to_context(
 	for (i = 0; i < surface_count; i++)
 		dc_surface_retain(surfaces[i]);
 
-	detach_surfaces_for_target(context, dc_target);
+	detach_surfaces_for_stream(context, dc_stream);
 
 	/* release existing surfaces*/
-	for (i = 0; i < target_status->surface_count; i++)
-		dc_surface_release(target_status->surfaces[i]);
+	for (i = 0; i < stream_status->surface_count; i++)
+		dc_surface_release(stream_status->surfaces[i]);
 
-	for (i = surface_count; i < target_status->surface_count; i++)
-		target_status->surfaces[i] = NULL;
+	for (i = surface_count; i < stream_status->surface_count; i++)
+		stream_status->surfaces[i] = NULL;
 
-	target_status->surface_count = 0;
+	stream_status->surface_count = 0;
 
 	if (surface_count == 0)
 		return true;
@@ -751,11 +751,11 @@ bool resource_attach_surfaces_to_context(
 	tail_pipe = NULL;
 	for (i = 0; i < surface_count; i++) {
 		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
-		struct pipe_ctx *free_pipe = acquire_free_pipe_for_target(
-				&context->res_ctx, dc_target);
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_stream(
+				&context->res_ctx, dc_stream);
 
 		if (!free_pipe) {
-			target_status->surfaces[i] = NULL;
+			stream_status->surfaces[i] = NULL;
 			return false;
 		}
 
@@ -769,13 +769,13 @@ bool resource_attach_surfaces_to_context(
 		tail_pipe = free_pipe;
 	}
 
-	release_free_pipes_for_target(&context->res_ctx, dc_target);
+	release_free_pipes_for_stream(&context->res_ctx, dc_stream);
 
 	/* assign new surfaces*/
 	for (i = 0; i < surface_count; i++)
-		target_status->surfaces[i] = surfaces[i];
+		stream_status->surfaces[i] = surfaces[i];
 
-	target_status->surface_count = surface_count;
+	stream_status->surface_count = surface_count;
 
 	return true;
 }
@@ -819,25 +819,14 @@ static bool are_stream_backends_same(
 	return true;
 }
 
-bool is_target_unchanged(
-	const struct core_target *old_target, const struct core_target *target)
+bool is_stream_unchanged(
+	const struct core_stream *old_stream, const struct core_stream *stream)
 {
-	int i;
-
-	if (old_target == target)
+	if (old_stream == stream)
 		return true;
-	if (old_target->public.stream_count != target->public.stream_count)
-		return false;
-
-	for (i = 0; i < old_target->public.stream_count; i++) {
-		const struct core_stream *old_stream = DC_STREAM_TO_CORE(
-				old_target->public.streams[i]);
-		const struct core_stream *stream = DC_STREAM_TO_CORE(
-				target->public.streams[i]);
 
-		if (!are_stream_backends_same(old_stream, stream))
-			return false;
-	}
+	if (!are_stream_backends_same(old_stream, stream))
+		return false;
 
 	return true;
 }
@@ -851,23 +840,23 @@ bool resource_validate_attach_surfaces(
 	int i, j;
 
 	for (i = 0; i < set_count; i++) {
-		for (j = 0; j < old_context->target_count; j++)
-			if (is_target_unchanged(
-					old_context->targets[j],
-					context->targets[i])) {
+		for (j = 0; j < old_context->stream_count; j++)
+			if (is_stream_unchanged(
+					old_context->streams[j],
+					context->streams[i])) {
 				if (!resource_attach_surfaces_to_context(
-						old_context->target_status[j].surfaces,
-						old_context->target_status[j].surface_count,
-						&context->targets[i]->public,
+						old_context->stream_status[j].surfaces,
+						old_context->stream_status[j].surface_count,
+						&context->streams[i]->public,
 						context))
 					return false;
-				context->target_status[i] = old_context->target_status[j];
+				context->stream_status[i] = old_context->stream_status[j];
 			}
 		if (set[i].surface_count != 0)
 			if (!resource_attach_surfaces_to_context(
 					set[i].surfaces,
 					set[i].surface_count,
-					&context->targets[i]->public,
+					&context->streams[i]->public,
 					context))
 				return false;
 
@@ -1001,20 +990,15 @@ static void update_stream_signal(struct core_stream *stream)
 }
 
 bool resource_is_stream_unchanged(
-	const struct validate_context *old_context, struct core_stream *stream)
+	const struct validate_context *old_context, const struct core_stream *stream)
 {
-	int i, j;
-
-	for (i = 0; i < old_context->target_count; i++) {
-		struct core_target *old_target = old_context->targets[i];
+	int i;
 
-		for (j = 0; j < old_target->public.stream_count; j++) {
-			struct core_stream *old_stream =
-				DC_STREAM_TO_CORE(old_target->public.streams[j]);
+	for (i = 0; i < old_context->stream_count; i++) {
+		const struct core_stream *old_stream = old_context->streams[i];
 
-			if (are_stream_backends_same(old_stream, stream))
+		if (are_stream_backends_same(old_stream, stream))
 				return true;
-		}
 	}
 
 	return false;
@@ -1036,23 +1020,19 @@ static struct core_stream *find_pll_sharable_stream(
 		const struct core_stream *stream_needs_pll,
 		struct validate_context *context)
 {
-	int i, j;
+	int i;
 
-	for (i = 0; i < context->target_count; i++) {
-		struct core_target *target = context->targets[i];
+	for (i = 0; i < context->stream_count; i++) {
+		struct core_stream *stream_has_pll = context->streams[i];
 
-		for (j = 0; j < target->public.stream_count; j++) {
-			struct core_stream *stream_has_pll =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
+		/* We are looking for non dp, non virtual stream */
+		if (resource_are_streams_timing_synchronizable(
+			stream_needs_pll, stream_has_pll)
+			&& !dc_is_dp_signal(stream_has_pll->signal)
+			&& stream_has_pll->sink->link->public.connector_signal
+			!= SIGNAL_TYPE_VIRTUAL)
+			return stream_has_pll;
 
-			/* We are looking for non dp, non virtual stream */
-			if (resource_are_streams_timing_synchronizable(
-						stream_needs_pll, stream_has_pll)
-				&& !dc_is_dp_signal(stream_has_pll->signal)
-				&& stream_has_pll->sink->link->public.connector_signal
-							!= SIGNAL_TYPE_VIRTUAL)
-					return stream_has_pll;
-		}
 	}
 
 	return NULL;
@@ -1091,25 +1071,20 @@ static void calculate_phy_pix_clks(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
-	int i, j;
-
-	for (i = 0; i < context->target_count; i++) {
-		struct core_target *target = context->targets[i];
+	int i;
 
-		for (j = 0; j < target->public.stream_count; j++) {
-			struct core_stream *stream =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
+	for (i = 0; i < context->stream_count; i++) {
+		struct core_stream *stream = context->streams[i];
 
-			update_stream_signal(stream);
+		update_stream_signal(stream);
 
-			/* update actual pixel clock on all streams */
-			if (dc_is_hdmi_signal(stream->signal))
-				stream->phy_pix_clk = get_norm_pix_clk(
-					&stream->public.timing);
-			else
-				stream->phy_pix_clk =
-						stream->public.timing.pix_clk_khz;
-		}
+		/* update actual pixel clock on all streams */
+		if (dc_is_hdmi_signal(stream->signal))
+			stream->phy_pix_clk = get_norm_pix_clk(
+				&stream->public.timing);
+		else
+			stream->phy_pix_clk =
+				stream->public.timing.pix_clk_khz;
 	}
 }
 
@@ -1117,136 +1092,122 @@ enum dc_status resource_map_pool_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
-	int i, j, k;
+	int i, j;
 
 	calculate_phy_pix_clks(dc, context);
 
-	for (i = 0; i < context->target_count; i++) {
-		struct core_target *target = context->targets[i];
-
-		for (j = 0; j < target->public.stream_count; j++) {
-			struct core_stream *stream =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
-
-			if (!resource_is_stream_unchanged(dc->current_context, stream))
-				continue;
-
-			/* mark resources used for stream that is already active */
-			for (k = 0; k < MAX_PIPES; k++) {
-				struct pipe_ctx *pipe_ctx =
-					&context->res_ctx.pipe_ctx[k];
-				const struct pipe_ctx *old_pipe_ctx =
-					&dc->current_context->res_ctx.pipe_ctx[k];
+	for (i = 0; i < context->stream_count; i++) {
+		struct core_stream *stream = context->streams[i];
 
-				if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
-					continue;
+		if (!resource_is_stream_unchanged(dc->current_context, stream))
+			continue;
 
-				pipe_ctx->stream = stream;
-				copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
+		/* mark resources used for stream that is already active */
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
+			const struct pipe_ctx *old_pipe_ctx =
+				&dc->current_context->res_ctx.pipe_ctx[j];
 
-				/* Split pipe resource, do not acquire back end */
-				if (!pipe_ctx->stream_enc)
-					continue;
+			if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
+				continue;
 
-				set_stream_engine_in_use(
-					&context->res_ctx,
-					pipe_ctx->stream_enc);
-
-				/* Switch to dp clock source only if there is
-				 * no non dp stream that shares the same timing
-				 * with the dp stream.
-				 */
-				if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
-					!find_pll_sharable_stream(stream, context))
-					pipe_ctx->clock_source =
-						context->res_ctx.pool->dp_clock_source;
+			pipe_ctx->stream = stream;
+			copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
 
-				resource_reference_clock_source(
-					&context->res_ctx,
-					pipe_ctx->clock_source);
+			/* Split pipe resource, do not acquire back end */
+			if (!pipe_ctx->stream_enc)
+				continue;
 
-				set_audio_in_use(&context->res_ctx,
-					pipe_ctx->audio);
-			}
+			set_stream_engine_in_use(
+				&context->res_ctx,
+				pipe_ctx->stream_enc);
+
+			/* Switch to dp clock source only if there is
+			 * no non dp stream that shares the same timing
+			 * with the dp stream.
+			 */
+			if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
+				!find_pll_sharable_stream(stream, context))
+				pipe_ctx->clock_source =
+					context->res_ctx.pool->dp_clock_source;
+
+			resource_reference_clock_source(
+				&context->res_ctx,
+				pipe_ctx->clock_source);
+
+			set_audio_in_use(&context->res_ctx,
+					 pipe_ctx->audio);
 		}
 	}
 
-	for (i = 0; i < context->target_count; i++) {
-		struct core_target *target = context->targets[i];
-
-		for (j = 0; j < target->public.stream_count; j++) {
-			struct core_stream *stream =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
-			struct pipe_ctx *pipe_ctx = NULL;
-			int pipe_idx = -1;
-
-			if (resource_is_stream_unchanged(dc->current_context, stream))
-				continue;
-			/* acquire new resources */
-			pipe_idx = acquire_first_free_pipe(
-						&context->res_ctx, stream);
-			if (pipe_idx < 0)
-				return DC_NO_CONTROLLER_RESOURCE;
-
-
-			pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
+	for (i = 0; i < context->stream_count; i++) {
+		struct core_stream *stream = context->streams[i];
+		struct pipe_ctx *pipe_ctx = NULL;
+		int pipe_idx = -1;
 
-			pipe_ctx->stream_enc =
-				find_first_free_match_stream_enc_for_link(
-					&context->res_ctx, stream);
-
-			if (!pipe_ctx->stream_enc)
-				return DC_NO_STREAM_ENG_RESOURCE;
-
-			set_stream_engine_in_use(
+		if (resource_is_stream_unchanged(dc->current_context, stream))
+			continue;
+		/* acquire new resources */
+		pipe_idx = acquire_first_free_pipe(&context->res_ctx, stream);
+		if (pipe_idx < 0)
+			return DC_NO_CONTROLLER_RESOURCE;
+
+
+		pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
+
+		pipe_ctx->stream_enc =
+			find_first_free_match_stream_enc_for_link(
+				&context->res_ctx, stream);
+
+		if (!pipe_ctx->stream_enc)
+			return DC_NO_STREAM_ENG_RESOURCE;
+
+		set_stream_engine_in_use(
+			&context->res_ctx,
+			pipe_ctx->stream_enc);
+
+		/* TODO: Add check if ASIC support and EDID audio */
+		if (!stream->sink->converter_disable_audio &&
+			dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
+			stream->public.audio_info.mode_count) {
+			pipe_ctx->audio = find_first_free_audio(
+				&context->res_ctx);
+
+			/*
+			 * Audio assigned in order first come first get.
+			 * There are asics which has number of audio
+			 * resources less then number of pipes
+			 */
+			if (pipe_ctx->audio)
+				set_audio_in_use(
 					&context->res_ctx,
-					pipe_ctx->stream_enc);
-
-			/* TODO: Add check if ASIC support and EDID audio */
-			if (!stream->sink->converter_disable_audio &&
-						dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
-						stream->public.audio_info.mode_count) {
-				pipe_ctx->audio = find_first_free_audio(
-						&context->res_ctx);
-
-				/*
-				 * Audio assigned in order first come first get.
-				 * There are asics which has number of audio
-				 * resources less then number of pipes
-				 */
-				if (pipe_ctx->audio)
-					set_audio_in_use(
-						&context->res_ctx,
-						pipe_ctx->audio);
-			}
-
-			if (j == 0) {
-				context->target_status[i].primary_otg_inst =
-						pipe_ctx->tg->inst;
-			}
+					pipe_ctx->audio);
 		}
+
+		context->stream_status[i].primary_otg_inst = pipe_ctx->tg->inst;
 	}
 
 	return DC_OK;
 }
 
-/* first target in the context is used to populate the rest */
-void validate_guaranteed_copy_target(
+/* first stream in the context is used to populate the rest */
+void validate_guaranteed_copy_streams(
 		struct validate_context *context,
-		int max_targets)
+		int max_streams)
 {
 	int i;
 
-	for (i = 1; i < max_targets; i++) {
-		context->targets[i] = context->targets[0];
+	for (i = 1; i < max_streams; i++) {
+		context->streams[i] = context->streams[0];
 
 		copy_pipe_ctx(&context->res_ctx.pipe_ctx[0],
 			      &context->res_ctx.pipe_ctx[i]);
 		context->res_ctx.pipe_ctx[i].stream =
 				context->res_ctx.pipe_ctx[0].stream;
 
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
+		dc_stream_retain(&context->streams[i]->public);
+		context->stream_count++;
 	}
 }
 
@@ -1875,18 +1836,19 @@ void resource_validate_ctx_destruct(struct validate_context *context)
 {
 	int i, j;
 
-	for (i = 0; i < context->target_count; i++) {
-		for (j = 0; j < context->target_status[i].surface_count; j++)
+	for (i = 0; i < context->stream_count; i++) {
+		for (j = 0; j < context->stream_status[i].surface_count; j++)
 			dc_surface_release(
-				context->target_status[i].surfaces[j]);
+				context->stream_status[i].surfaces[j]);
 
-		context->target_status[i].surface_count = 0;
-		dc_target_release(&context->targets[i]->public);
+		context->stream_status[i].surface_count = 0;
+		dc_stream_release(&context->streams[i]->public);
+		context->streams[i] = NULL;
 	}
 }
 
 /*
- * Copy src_ctx into dst_ctx and retain all surfaces and targets referenced
+ * Copy src_ctx into dst_ctx and retain all surfaces and streams referenced
  * by the src_ctx
  */
 void resource_validate_ctx_copy_construct(
@@ -1908,11 +1870,11 @@ void resource_validate_ctx_copy_construct(
 
 	}
 
-	for (i = 0; i < dst_ctx->target_count; i++) {
-		dc_target_retain(&dst_ctx->targets[i]->public);
-		for (j = 0; j < dst_ctx->target_status[i].surface_count; j++)
+	for (i = 0; i < dst_ctx->stream_count; i++) {
+		dc_stream_retain(&dst_ctx->streams[i]->public);
+		for (j = 0; j < dst_ctx->stream_status[i].surface_count; j++)
 			dc_surface_retain(
-				dst_ctx->target_status[i].surfaces[j]);
+				dst_ctx->stream_status[i].surfaces[j]);
 	}
 }
 
@@ -1968,53 +1930,48 @@ enum dc_status resource_map_clock_resources(
 		const struct core_dc *dc,
 		struct validate_context *context)
 {
-	int i, j, k;
+	int i, j;
 
 	/* acquire new resources */
-	for (i = 0; i < context->target_count; i++) {
-		struct core_target *target = context->targets[i];
+	for (i = 0; i < context->stream_count; i++) {
+		const struct core_stream *stream = context->streams[i];
 
-		for (j = 0; j < target->public.stream_count; j++) {
-			struct core_stream *stream =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
+		if (resource_is_stream_unchanged(dc->current_context, stream))
+			continue;
+
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
 
-			if (resource_is_stream_unchanged(dc->current_context, stream))
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
 				continue;
 
-			for (k = 0; k < MAX_PIPES; k++) {
-				struct pipe_ctx *pipe_ctx =
-					&context->res_ctx.pipe_ctx[k];
+			if (dc_is_dp_signal(pipe_ctx->stream->signal)
+				|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
+				pipe_ctx->clock_source =
+					context->res_ctx.pool->dp_clock_source;
+			else {
+				pipe_ctx->clock_source = NULL;
 
-				if (context->res_ctx.pipe_ctx[k].stream != stream)
-					continue;
+				if (!dc->public.config.disable_disp_pll_sharing)
+					resource_find_used_clk_src_for_sharing(
+						&context->res_ctx,
+						pipe_ctx);
 
-				if (dc_is_dp_signal(pipe_ctx->stream->signal)
-					|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
+				if (pipe_ctx->clock_source == NULL)
 					pipe_ctx->clock_source =
-						context->res_ctx.pool->dp_clock_source;
-				else {
-					pipe_ctx->clock_source = NULL;
-
-					if (!dc->public.config.disable_disp_pll_sharing)
-						resource_find_used_clk_src_for_sharing(
-							&context->res_ctx,
-							pipe_ctx);
-
-					if (pipe_ctx->clock_source == NULL)
-						pipe_ctx->clock_source =
-							dc_resource_find_first_free_pll(&context->res_ctx);
-				}
+						dc_resource_find_first_free_pll(&context->res_ctx);
+			}
 
-				if (pipe_ctx->clock_source == NULL)
-					return DC_NO_CLOCK_SOURCE_RESOURCE;
+			if (pipe_ctx->clock_source == NULL)
+				return DC_NO_CLOCK_SOURCE_RESOURCE;
 
-				resource_reference_clock_source(
-						&context->res_ctx,
-						pipe_ctx->clock_source);
+			resource_reference_clock_source(
+				&context->res_ctx,
+				pipe_ctx->clock_source);
 
-				/* only one cs per stream regardless of mpo */
-				break;
-			}
+			/* only one cs per stream regardless of mpo */
+			break;
 		}
 	}
 

commit 3e183c5f083125986dd0cd0ab609252349983f0e
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jan 10 09:33:32 2017 +1000

    drm/amd/display: start using linux hdmi header
    
    DAL has defines for things, and it doesn't even use them itself.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Edward O'Callaghan <funfunctor@folklore1984.net>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 59770bc9c8fe..4bb6b1d9c970 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1334,13 +1334,12 @@ static void set_avi_info_frame(
 
 	/* Initialize header */
 	info_frame.avi_info_packet.info_packet_hdmi.bits.header.
-			info_frame_type = INFO_FRAME_AVI;
+			info_frame_type = HDMI_INFOFRAME_TYPE_AVI;
 	/* InfoFrameVersion_3 is defined by CEA861F (Section 6.4), but shall
 	* not be used in HDMI 2.0 (Section 10.1) */
-	info_frame.avi_info_packet.info_packet_hdmi.bits.header.version =
-			INFO_FRAME_VERSION_2;
+	info_frame.avi_info_packet.info_packet_hdmi.bits.header.version = 2;
 	info_frame.avi_info_packet.info_packet_hdmi.bits.header.length =
-			INFO_FRAME_SIZE_AVI;
+			HDMI_AVI_INFOFRAME_SIZE;
 
 	/*
 	 * IDO-defined (Y2,Y1,Y0 = 1,1,1) shall not be used by devices built
@@ -1473,10 +1472,9 @@ static void set_avi_info_frame(
 	check_sum =
 		&info_frame.
 		avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
-	*check_sum = INFO_FRAME_AVI + INFO_FRAME_SIZE_AVI
-			+ INFO_FRAME_VERSION_2;
+	*check_sum = HDMI_INFOFRAME_TYPE_AVI + HDMI_AVI_INFOFRAME_SIZE + 2;
 
-	for (byte_index = 1; byte_index <= INFO_FRAME_SIZE_AVI; byte_index++)
+	for (byte_index = 1; byte_index <= HDMI_AVI_INFOFRAME_SIZE; byte_index++)
 		*check_sum += info_frame.avi_info_packet.info_packet_hdmi.
 				packet_raw_data.sb[byte_index];
 
@@ -1588,7 +1586,7 @@ static void set_vendor_info_packet(struct core_stream *stream,
 		info_packet->sb[5] = stream->public.timing.hdmi_vic;
 
 	/* Header */
-	info_packet->hb0 = 0x81; /* VSIF packet type. */
+	info_packet->hb0 = HDMI_INFOFRAME_TYPE_VENDOR; /* VSIF packet type. */
 	info_packet->hb1 = 0x01; /* Version */
 
 	/* 4 lower bits = Length, 4 higher bits = 0 (reserved) */
@@ -1629,7 +1627,7 @@ static void set_spd_info_packet(struct core_stream *stream,
 		/* HB0  = Packet Type = 0x83 (Source Product
 		 *	  Descriptor InfoFrame)
 		 */
-		info_packet->hb0 = 0x83;
+		info_packet->hb0 = HDMI_INFOFRAME_TYPE_SPD;
 
 		/* HB1  = Version = 0x01 */
 		info_packet->hb1 = 0x01;
@@ -1651,7 +1649,7 @@ static void set_spd_info_packet(struct core_stream *stream,
 		/* HB1  = Packet Type = 0x83 (Source Product
 		 *	  Descriptor InfoFrame)
 		 */
-		info_packet->hb1 = 0x83;
+		info_packet->hb1 = HDMI_INFOFRAME_TYPE_SPD;
 
 		/* HB2  = [Bits 7:0 = Least significant eight bits -
 		 *	  For INFOFRAME, the value must be 1Bh]

commit 2796eaee69ce139aa5ae8047bf3071650893ce1d
Author: Joshua Aberback <Joshua.Aberback@amd.com>
Date:   Mon Jan 9 14:43:08 2017 -0500

    drm/amd/display: When signal type of sink is none, use link type for stream
    
    Signed-off-by: Joshua Aberback <Joshua.Aberback@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index a82f2d6ea80f..59770bc9c8fe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -984,19 +984,20 @@ static void update_stream_signal(struct core_stream *stream)
 {
 	const struct dc_sink *dc_sink = stream->public.sink;
 
-	stream->signal = dc_sink->sink_signal;
-	/* For asic supports dual link DVI, we should adjust signal type
-	 * based on timing pixel clock. If pixel clock more than 165Mhz,
-	 * signal is dual link, otherwise, single link.
-	 */
-	if (dc_sink->sink_signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||
-			dc_sink->sink_signal == SIGNAL_TYPE_DVI_DUAL_LINK) {
-		if (stream->public.timing.pix_clk_khz >
-						TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
+	if (dc_sink->sink_signal == SIGNAL_TYPE_NONE)
+		stream->signal = stream->sink->link->public.connector_signal;
+	else if (dc_sink->sink_signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||
+			dc_sink->sink_signal == SIGNAL_TYPE_DVI_DUAL_LINK)
+		/* For asic supports dual link DVI, we should adjust signal type
+		 * based on timing pixel clock. If pixel clock more than 165Mhz,
+		 * signal is dual link, otherwise, single link.
+		 */
+		if (stream->public.timing.pix_clk_khz > TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
 			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
 		else
 			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
-	}
+	else
+		stream->signal = dc_sink->sink_signal;
 }
 
 bool resource_is_stream_unchanged(

commit 10bff005926af12aa7b1d97ea9bc948ccbaed1c9
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Jan 5 11:26:59 2017 -0500

    drm/amd/display: Check hdr support before setting.
    
    In case of programing info frame to
    some monitors don't support HDR, it will
    result in black screen or corruption when
    unplug monitor.
    By checking hdr flag to avoid unnecessary
    setting for monitors don't support HDR.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 80fe6b9f9397..a82f2d6ea80f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1742,6 +1742,9 @@ static void set_hdr_static_info_packet(
 
 	hdr_metadata = surface->public.hdr_static_ctx;
 
+	if (!hdr_metadata.is_hdr)
+		return;
+
 	if (dc_is_hdmi_signal(signal)) {
 		info_packet->valid = true;
 

commit e66e4d64289b647f7787d257dd2be0055ae7df94
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jan 4 18:54:29 2017 -0500

    drm/amd/display: Fix wrong index bug in set_avi_info_frame
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 3e3379529b69..80fe6b9f9397 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1490,9 +1490,10 @@ static void set_avi_info_frame(
 	info_packet->hb2 =
 		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb2;
 
-	for (byte_index = 0; byte_index < sizeof(info_packet->sb); byte_index++)
+	for (byte_index = 0; byte_index < sizeof(info_frame.avi_info_packet.
+				info_packet_hdmi.packet_raw_data.sb); byte_index++)
 		info_packet->sb[byte_index] = info_frame.avi_info_packet.
-		info_packet_hdmi.packet_raw_data.sb[byte_index];
+				info_packet_hdmi.packet_raw_data.sb[byte_index];
 
 	info_packet->valid = true;
 }

commit e5cf325b0c21e626c402b57a055f02c478e3df40
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jan 4 18:48:07 2017 -0500

    drm/amd/display: Fix warnings in DC
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 2b08f5ae5e33..3e3379529b69 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1731,14 +1731,15 @@ static void set_hdr_static_info_packet(
 		struct core_stream *stream,
 		struct hw_info_packet *info_packet)
 {
-	uint16_t i;
+	uint16_t i = 0;
 	enum signal_type signal = stream->signal;
+	struct dc_hdr_static_metadata hdr_metadata;
+	uint32_t data;
 
 	if (!surface)
 		return;
 
-	struct dc_hdr_static_metadata hdr_metadata =
-			surface->public.hdr_static_ctx;
+	hdr_metadata = surface->public.hdr_static_ctx;
 
 	if (dc_is_hdmi_signal(signal)) {
 		info_packet->valid = true;
@@ -1757,8 +1758,6 @@ static void set_hdr_static_info_packet(
 		i = 2;
 	}
 
-	uint32_t data;
-
 	data = hdr_metadata.is_hdr;
 	info_packet->sb[i++] = data ? 0x02 : 0x00;
 	info_packet->sb[i++] = 0x00;

commit 1646a6fe746d7e923774994d2020e1707dcda884
Author: Andrew Wong <andrew.wong1@amd.com>
Date:   Thu Dec 22 15:41:30 2016 -0500

    drm/amd/display: DAL3: HDR10 Infoframe encoding
    
    - Add HDR metadata struct
    - Add register programming calculations
    - Added HDR metadata to surface and update_surface
    - Add HDR info packet programming for DP port
    
    Signed-off-by: Andrew Wong <andrew.wong1@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 386b3cc14fbe..2b08f5ae5e33 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -32,7 +32,6 @@
 #include "timing_generator.h"
 #include "transform.h"
 #include "set_mode_types.h"
-
 #include "virtual/virtual_stream_encoder.h"
 
 #include "dce80/dce80_resource.h"
@@ -1303,6 +1302,13 @@ static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
 						&hw_info_frame->vsc_packet,
 						sizeof(struct hw_info_packet));
 	}
+
+	if (hw_info_frame->hdrsmd_packet.valid) {
+		memmove(
+						&encoder_info_frame->hdrsmd,
+						&hw_info_frame->hdrsmd_packet,
+						sizeof(struct hw_info_packet));
+	}
 }
 
 static void set_avi_info_frame(
@@ -1720,6 +1726,108 @@ static void set_spd_info_packet(struct core_stream *stream,
 	info_packet->valid = true;
 }
 
+static void set_hdr_static_info_packet(
+		struct core_surface *surface,
+		struct core_stream *stream,
+		struct hw_info_packet *info_packet)
+{
+	uint16_t i;
+	enum signal_type signal = stream->signal;
+
+	if (!surface)
+		return;
+
+	struct dc_hdr_static_metadata hdr_metadata =
+			surface->public.hdr_static_ctx;
+
+	if (dc_is_hdmi_signal(signal)) {
+		info_packet->valid = true;
+
+		info_packet->hb0 = 0x87;
+		info_packet->hb1 = 0x01;
+		info_packet->hb2 = 0x1A;
+		i = 1;
+	} else if (dc_is_dp_signal(signal)) {
+		info_packet->valid = true;
+
+		info_packet->hb0 = 0x00;
+		info_packet->hb1 = 0x87;
+		info_packet->hb2 = 0x1D;
+		info_packet->hb3 = (0x13 << 2);
+		i = 2;
+	}
+
+	uint32_t data;
+
+	data = hdr_metadata.is_hdr;
+	info_packet->sb[i++] = data ? 0x02 : 0x00;
+	info_packet->sb[i++] = 0x00;
+
+	data = hdr_metadata.chromaticity_green_x / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_green_y / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_blue_x / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_blue_y / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_red_x / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_red_y / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_white_point_x / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.chromaticity_white_point_y / 2;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.max_luminance;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.min_luminance;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.maximum_content_light_level;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	data = hdr_metadata.maximum_frame_average_light_level;
+	info_packet->sb[i++] = data & 0xFF;
+	info_packet->sb[i++] = (data & 0xFF00) >> 8;
+
+	if (dc_is_hdmi_signal(signal)) {
+		uint32_t checksum = 0;
+
+		checksum += info_packet->hb0;
+		checksum += info_packet->hb1;
+		checksum += info_packet->hb2;
+
+		for (i = 1; i <= info_packet->hb2; i++)
+			checksum += info_packet->sb[i];
+
+		info_packet->sb[0] = 0x100 - checksum;
+	} else if (dc_is_dp_signal(signal)) {
+		info_packet->sb[0] = 0x01;
+		info_packet->sb[1] = 0x1A;
+	}
+}
+
 static void set_vsc_info_packet(struct core_stream *stream,
 		struct hw_info_packet *info_packet)
 {
@@ -1830,6 +1938,7 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 	info_frame.vendor_info_packet.valid = false;
 	info_frame.spd_packet.valid = false;
 	info_frame.vsc_packet.valid = false;
+	info_frame.hdrsmd_packet.valid = false;
 
 	signal = pipe_ctx->stream->signal;
 
@@ -1840,9 +1949,13 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_vendor_info_packet(
 			pipe_ctx->stream, &info_frame.vendor_info_packet);
 		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
+		set_hdr_static_info_packet(pipe_ctx->surface,
+				pipe_ctx->stream, &info_frame.hdrsmd_packet);
 	} else if (dc_is_dp_signal(signal)) {
 		set_vsc_info_packet(pipe_ctx->stream, &info_frame.vsc_packet);
 		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
+		set_hdr_static_info_packet(pipe_ctx->surface,
+				pipe_ctx->stream, &info_frame.hdrsmd_packet);
 	}
 
 	translate_info_frame(&info_frame,

commit 8c737fcc24b01ef36da5f78aace70d444485abf9
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Thu Dec 22 13:07:11 2016 -0500

    drm/amd/display: Fixed crash caused by unnecessary clock source in split pipe.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index eac597d0c790..386b3cc14fbe 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -211,27 +211,28 @@ bool resource_construct(
 
 void resource_unreference_clock_source(
 		struct resource_context *res_ctx,
-		struct clock_source *clock_source)
+		struct clock_source **clock_source)
 {
 	int i;
 	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
-		if (res_ctx->pool->clock_sources[i] != clock_source)
+		if (res_ctx->pool->clock_sources[i] != *clock_source)
 			continue;
 
 		res_ctx->clock_source_ref_count[i]--;
 
 		if (res_ctx->clock_source_ref_count[i] == 0)
-			clock_source->funcs->cs_power_down(clock_source);
+			(*clock_source)->funcs->cs_power_down(*clock_source);
 
 		break;
 	}
 
-	if (res_ctx->pool->dp_clock_source == clock_source) {
+	if (res_ctx->pool->dp_clock_source == *clock_source) {
 		res_ctx->dp_clock_source_ref_count--;
 
 		if (res_ctx->dp_clock_source_ref_count == 0)
-			clock_source->funcs->cs_power_down(clock_source);
+			(*clock_source)->funcs->cs_power_down(*clock_source);
 	}
+	*clock_source = NULL;
 }
 
 void resource_reference_clock_source(
@@ -288,11 +289,6 @@ static bool is_sharable_clk_src(
 	if (pipe_with_clk_src->clock_source == NULL)
 		return false;
 
-	if (pipe_with_clk_src->stream == NULL) {
-		ASSERT(0);
-		return false;
-	}
-
 	if (pipe_with_clk_src->stream->signal == SIGNAL_TYPE_VIRTUAL)
 		return false;
 
@@ -1148,6 +1144,10 @@ enum dc_status resource_map_pool_resources(
 				pipe_ctx->stream = stream;
 				copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
 
+				/* Split pipe resource, do not acquire back end */
+				if (!pipe_ctx->stream_enc)
+					continue;
+
 				set_stream_engine_in_use(
 					&context->res_ctx,
 					pipe_ctx->stream_enc);

commit 0f4e66cd7dac538adca4b1cac8f36b90db1709e6
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Wed Dec 21 11:16:48 2016 -0500

    drm/amd/display: don't crash if stream is NULL when trying to share clocks
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index 343114b2680f..eac597d0c790 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -288,6 +288,11 @@ static bool is_sharable_clk_src(
 	if (pipe_with_clk_src->clock_source == NULL)
 		return false;
 
+	if (pipe_with_clk_src->stream == NULL) {
+		ASSERT(0);
+		return false;
+	}
+
 	if (pipe_with_clk_src->stream->signal == SIGNAL_TYPE_VIRTUAL)
 		return false;
 

commit b264d3455d9c8ce0bea422a04a867f0a724c7770
Author: Jordan Lazare <Jordan.Lazare@amd.com>
Date:   Wed Dec 14 15:35:13 2016 -0500

    drm/amd/dal: Add POLARIS12 support (v2)
    
    v2: agd: squash in dm fix, rebase
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index f552b0468186..343114b2680f 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -60,7 +60,8 @@ enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 			break;
 		}
 		if (ASIC_REV_IS_POLARIS10_P(asic_id.hw_internal_rev) ||
-				ASIC_REV_IS_POLARIS11_M(asic_id.hw_internal_rev)) {
+				ASIC_REV_IS_POLARIS11_M(asic_id.hw_internal_rev) ||
+				ASIC_REV_IS_POLARIS12_V(asic_id.hw_internal_rev)) {
 			dc_version = DCE_VERSION_11_2;
 		}
 		break;

commit a33fa99d8b8ec71a69e089e39ab1498d31169640
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Dec 6 11:26:08 2016 -0500

    drm/amd/display: Fix bunch of warnings in DC
    
    Some of those are potential bugs
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
index bd53d27e5414..f552b0468186 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -1834,11 +1834,10 @@ void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
 		set_vendor_info_packet(
 			pipe_ctx->stream, &info_frame.vendor_info_packet);
 		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
-	}
-
-	else if (dc_is_dp_signal(signal))
+	} else if (dc_is_dp_signal(signal)) {
 		set_vsc_info_packet(pipe_ctx->stream, &info_frame.vsc_packet);
 		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
+	}
 
 	translate_info_frame(&info_frame,
 			&pipe_ctx->encoder_info_frame);

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
new file mode 100644
index 000000000000..bd53d27e5414
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -0,0 +1,1934 @@
+/*
+* Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+#include "dm_services.h"
+
+#include "resource.h"
+#include "include/irq_service_interface.h"
+#include "link_encoder.h"
+#include "stream_encoder.h"
+#include "opp.h"
+#include "timing_generator.h"
+#include "transform.h"
+#include "set_mode_types.h"
+
+#include "virtual/virtual_stream_encoder.h"
+
+#include "dce80/dce80_resource.h"
+#include "dce100/dce100_resource.h"
+#include "dce110/dce110_resource.h"
+#include "dce112/dce112_resource.h"
+
+enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
+{
+	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
+	switch (asic_id.chip_family) {
+
+	case FAMILY_CI:
+	case FAMILY_KV:
+		dc_version = DCE_VERSION_8_0;
+		break;
+	case FAMILY_CZ:
+		dc_version = DCE_VERSION_11_0;
+		break;
+
+	case FAMILY_VI:
+		if (ASIC_REV_IS_TONGA_P(asic_id.hw_internal_rev) ||
+				ASIC_REV_IS_FIJI_P(asic_id.hw_internal_rev)) {
+			dc_version = DCE_VERSION_10_0;
+			break;
+		}
+		if (ASIC_REV_IS_POLARIS10_P(asic_id.hw_internal_rev) ||
+				ASIC_REV_IS_POLARIS11_M(asic_id.hw_internal_rev)) {
+			dc_version = DCE_VERSION_11_2;
+		}
+		break;
+	default:
+		dc_version = DCE_VERSION_UNKNOWN;
+		break;
+	}
+	return dc_version;
+}
+
+struct resource_pool *dc_create_resource_pool(
+				struct core_dc *dc,
+				int num_virtual_links,
+				enum dce_version dc_version,
+				struct hw_asic_id asic_id)
+{
+
+	switch (dc_version) {
+	case DCE_VERSION_8_0:
+		return dce80_create_resource_pool(
+			num_virtual_links, dc);
+	case DCE_VERSION_10_0:
+		return dce100_create_resource_pool(
+				num_virtual_links, dc);
+	case DCE_VERSION_11_0:
+		return dce110_create_resource_pool(
+			num_virtual_links, dc, asic_id);
+	case DCE_VERSION_11_2:
+		return dce112_create_resource_pool(
+			num_virtual_links, dc);
+	default:
+		break;
+	}
+
+	return false;
+}
+
+void dc_destroy_resource_pool(struct core_dc *dc)
+{
+	if (dc) {
+		if (dc->res_pool)
+			dc->res_pool->funcs->destroy(&dc->res_pool);
+
+		if (dc->hwseq)
+			dm_free(dc->hwseq);
+	}
+}
+
+static void update_num_audio(
+	const struct resource_straps *straps,
+	unsigned int *num_audio,
+	struct audio_support *aud_support)
+{
+	if (straps->hdmi_disable == 0) {
+		aud_support->hdmi_audio_native = true;
+		aud_support->hdmi_audio_on_dongle = true;
+		aud_support->dp_audio = true;
+	} else {
+		if (straps->dc_pinstraps_audio & 0x2) {
+			aud_support->hdmi_audio_on_dongle = true;
+			aud_support->dp_audio = true;
+		} else {
+			aud_support->dp_audio = true;
+		}
+	}
+
+	switch (straps->audio_stream_number) {
+	case 0: /* multi streams supported */
+		break;
+	case 1: /* multi streams not supported */
+		*num_audio = 1;
+		break;
+	default:
+		DC_ERR("DC: unexpected audio fuse!\n");
+	};
+}
+
+bool resource_construct(
+	unsigned int num_virtual_links,
+	struct core_dc *dc,
+	struct resource_pool *pool,
+	const struct resource_create_funcs *create_funcs)
+{
+	struct dc_context *ctx = dc->ctx;
+	const struct resource_caps *caps = pool->res_cap;
+	int i;
+	unsigned int num_audio = caps->num_audio;
+	struct resource_straps straps = {0};
+
+	if (create_funcs->read_dce_straps)
+		create_funcs->read_dce_straps(dc->ctx, &straps);
+
+	pool->audio_count = 0;
+	if (create_funcs->create_audio) {
+		/* find the total number of streams available via the
+		 * AZALIA_F0_CODEC_PIN_CONTROL_RESPONSE_CONFIGURATION_DEFAULT
+		 * registers (one for each pin) starting from pin 1
+		 * up to the max number of audio pins.
+		 * We stop on the first pin where
+		 * PORT_CONNECTIVITY == 1 (as instructed by HW team).
+		 */
+		update_num_audio(&straps, &num_audio, &pool->audio_support);
+		for (i = 0; i < pool->pipe_count && i < num_audio; i++) {
+			struct audio *aud = create_funcs->create_audio(ctx, i);
+
+			if (aud == NULL) {
+				DC_ERR("DC: failed to create audio!\n");
+				return false;
+			}
+
+			if (!aud->funcs->endpoint_valid(aud)) {
+				aud->funcs->destroy(&aud);
+				break;
+			}
+
+			pool->audios[i] = aud;
+			pool->audio_count++;
+		}
+	}
+
+	pool->stream_enc_count = 0;
+	if (create_funcs->create_stream_encoder) {
+		for (i = 0; i < caps->num_stream_encoder; i++) {
+			pool->stream_enc[i] = create_funcs->create_stream_encoder(i, ctx);
+			if (pool->stream_enc[i] == NULL)
+				DC_ERR("DC: failed to create stream_encoder!\n");
+			pool->stream_enc_count++;
+		}
+	}
+
+	for (i = 0; i < num_virtual_links; i++) {
+		pool->stream_enc[pool->stream_enc_count] =
+			virtual_stream_encoder_create(
+					ctx, ctx->dc_bios);
+		if (pool->stream_enc[pool->stream_enc_count] == NULL) {
+			DC_ERR("DC: failed to create stream_encoder!\n");
+			return false;
+		}
+		pool->stream_enc_count++;
+	}
+
+	dc->hwseq = create_funcs->create_hwseq(ctx);
+
+	return true;
+}
+
+
+void resource_unreference_clock_source(
+		struct resource_context *res_ctx,
+		struct clock_source *clock_source)
+{
+	int i;
+	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
+		if (res_ctx->pool->clock_sources[i] != clock_source)
+			continue;
+
+		res_ctx->clock_source_ref_count[i]--;
+
+		if (res_ctx->clock_source_ref_count[i] == 0)
+			clock_source->funcs->cs_power_down(clock_source);
+
+		break;
+	}
+
+	if (res_ctx->pool->dp_clock_source == clock_source) {
+		res_ctx->dp_clock_source_ref_count--;
+
+		if (res_ctx->dp_clock_source_ref_count == 0)
+			clock_source->funcs->cs_power_down(clock_source);
+	}
+}
+
+void resource_reference_clock_source(
+		struct resource_context *res_ctx,
+		struct clock_source *clock_source)
+{
+	int i;
+	for (i = 0; i < res_ctx->pool->clk_src_count; i++) {
+		if (res_ctx->pool->clock_sources[i] != clock_source)
+			continue;
+
+		res_ctx->clock_source_ref_count[i]++;
+		break;
+	}
+
+	if (res_ctx->pool->dp_clock_source == clock_source)
+		res_ctx->dp_clock_source_ref_count++;
+}
+
+bool resource_are_streams_timing_synchronizable(
+	const struct core_stream *stream1,
+	const struct core_stream *stream2)
+{
+	if (stream1->public.timing.h_total != stream2->public.timing.h_total)
+		return false;
+
+	if (stream1->public.timing.v_total != stream2->public.timing.v_total)
+		return false;
+
+	if (stream1->public.timing.h_addressable
+				!= stream2->public.timing.h_addressable)
+		return false;
+
+	if (stream1->public.timing.v_addressable
+				!= stream2->public.timing.v_addressable)
+		return false;
+
+	if (stream1->public.timing.pix_clk_khz
+				!= stream2->public.timing.pix_clk_khz)
+		return false;
+
+	if (stream1->phy_pix_clk != stream2->phy_pix_clk
+			&& !dc_is_dp_signal(stream1->signal)
+			&& !dc_is_dp_signal(stream2->signal))
+		return false;
+
+	return true;
+}
+
+static bool is_sharable_clk_src(
+	const struct pipe_ctx *pipe_with_clk_src,
+	const struct pipe_ctx *pipe)
+{
+	if (pipe_with_clk_src->clock_source == NULL)
+		return false;
+
+	if (pipe_with_clk_src->stream->signal == SIGNAL_TYPE_VIRTUAL)
+		return false;
+
+	if (dc_is_dp_signal(pipe_with_clk_src->stream->signal))
+		return false;
+
+	if (dc_is_hdmi_signal(pipe_with_clk_src->stream->signal)
+			&& dc_is_dvi_signal(pipe->stream->signal))
+		return false;
+
+	if (dc_is_hdmi_signal(pipe->stream->signal)
+			&& dc_is_dvi_signal(pipe_with_clk_src->stream->signal))
+		return false;
+
+	if (!resource_are_streams_timing_synchronizable(
+			pipe_with_clk_src->stream, pipe->stream))
+		return false;
+
+	return true;
+}
+
+struct clock_source *resource_find_used_clk_src_for_sharing(
+					struct resource_context *res_ctx,
+					struct pipe_ctx *pipe_ctx)
+{
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (is_sharable_clk_src(&res_ctx->pipe_ctx[i], pipe_ctx))
+			return res_ctx->pipe_ctx[i].clock_source;
+	}
+
+	return NULL;
+}
+
+static enum pixel_format convert_pixel_format_to_dalsurface(
+		enum surface_pixel_format surface_pixel_format)
+{
+	enum pixel_format dal_pixel_format = PIXEL_FORMAT_UNKNOWN;
+
+	switch (surface_pixel_format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:
+		dal_pixel_format = PIXEL_FORMAT_INDEX8;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+		dal_pixel_format = PIXEL_FORMAT_RGB565;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		dal_pixel_format = PIXEL_FORMAT_RGB565;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+		dal_pixel_format = PIXEL_FORMAT_ARGB8888;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+		dal_pixel_format = PIXEL_FORMAT_ARGB8888;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+		dal_pixel_format = PIXEL_FORMAT_ARGB2101010;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+		dal_pixel_format = PIXEL_FORMAT_ARGB2101010;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:
+		dal_pixel_format = PIXEL_FORMAT_ARGB2101010_XRBIAS;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F:
+		dal_pixel_format = PIXEL_FORMAT_FP16;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr:
+		dal_pixel_format = PIXEL_FORMAT_420BPP12;
+		break;
+	case SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb:
+		dal_pixel_format = PIXEL_FORMAT_420BPP12;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+	default:
+		dal_pixel_format = PIXEL_FORMAT_UNKNOWN;
+		break;
+	}
+	return dal_pixel_format;
+}
+
+static void rect_swap_helper(struct rect *rect)
+{
+	uint32_t temp = 0;
+
+	temp = rect->height;
+	rect->height = rect->width;
+	rect->width = temp;
+
+	temp = rect->x;
+	rect->x = rect->y;
+	rect->y = temp;
+}
+
+static void calculate_viewport(
+		const struct dc_surface *surface,
+		struct pipe_ctx *pipe_ctx)
+{
+	struct rect stream_src = pipe_ctx->stream->public.src;
+	struct rect src = surface->src_rect;
+	struct rect dst = surface->dst_rect;
+	struct rect surface_clip = surface->clip_rect;
+	struct rect clip = {0};
+
+
+	if (surface->rotation == ROTATION_ANGLE_90 ||
+	    surface->rotation == ROTATION_ANGLE_270) {
+		rect_swap_helper(&src);
+		rect_swap_helper(&dst);
+		rect_swap_helper(&surface_clip);
+		rect_swap_helper(&stream_src);
+	}
+
+	/* The actual clip is an intersection between stream
+	 * source and surface clip
+	 */
+	clip.x = stream_src.x > surface_clip.x ?
+			stream_src.x : surface_clip.x;
+
+	clip.width = stream_src.x + stream_src.width <
+			surface_clip.x + surface_clip.width ?
+			stream_src.x + stream_src.width - clip.x :
+			surface_clip.x + surface_clip.width - clip.x ;
+
+	clip.y = stream_src.y > surface_clip.y ?
+			stream_src.y : surface_clip.y;
+
+	clip.height = stream_src.y + stream_src.height <
+			surface_clip.y + surface_clip.height ?
+			stream_src.y + stream_src.height - clip.y :
+			surface_clip.y + surface_clip.height - clip.y ;
+
+	/* offset = src.ofs + (clip.ofs - dst.ofs) * scl_ratio
+	 * num_pixels = clip.num_pix * scl_ratio
+	 */
+	pipe_ctx->scl_data.viewport.x = src.x + (clip.x - dst.x) *
+			src.width / dst.width;
+	pipe_ctx->scl_data.viewport.width = clip.width *
+			src.width / dst.width;
+
+	pipe_ctx->scl_data.viewport.y = src.y + (clip.y - dst.y) *
+			src.height / dst.height;
+	pipe_ctx->scl_data.viewport.height = clip.height *
+			src.height / dst.height;
+
+	/* Minimum viewport such that 420/422 chroma vp is non 0 */
+	if (pipe_ctx->scl_data.viewport.width < 2)
+		pipe_ctx->scl_data.viewport.width = 2;
+	if (pipe_ctx->scl_data.viewport.height < 2)
+		pipe_ctx->scl_data.viewport.height = 2;
+}
+
+static void calculate_recout(
+		const struct dc_surface *surface,
+		struct pipe_ctx *pipe_ctx)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	struct rect clip = surface->clip_rect;
+
+	pipe_ctx->scl_data.recout.x = stream->public.dst.x;
+	if (stream->public.src.x < clip.x)
+		pipe_ctx->scl_data.recout.x += (clip.x
+			- stream->public.src.x) * stream->public.dst.width
+						/ stream->public.src.width;
+
+	pipe_ctx->scl_data.recout.width = clip.width *
+			stream->public.dst.width / stream->public.src.width;
+	if (pipe_ctx->scl_data.recout.width + pipe_ctx->scl_data.recout.x >
+			stream->public.dst.x + stream->public.dst.width)
+		pipe_ctx->scl_data.recout.width =
+			stream->public.dst.x + stream->public.dst.width
+						- pipe_ctx->scl_data.recout.x;
+
+	pipe_ctx->scl_data.recout.y = stream->public.dst.y;
+	if (stream->public.src.y < clip.y)
+		pipe_ctx->scl_data.recout.y += (clip.y
+			- stream->public.src.y) * stream->public.dst.height
+						/ stream->public.src.height;
+
+	pipe_ctx->scl_data.recout.height = clip.height *
+			stream->public.dst.height / stream->public.src.height;
+	if (pipe_ctx->scl_data.recout.height + pipe_ctx->scl_data.recout.y >
+			stream->public.dst.y + stream->public.dst.height)
+		pipe_ctx->scl_data.recout.height =
+			stream->public.dst.y + stream->public.dst.height
+						- pipe_ctx->scl_data.recout.y;
+}
+
+static void calculate_scaling_ratios(
+		const struct dc_surface *surface,
+		struct pipe_ctx *pipe_ctx)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	const uint32_t in_w = stream->public.src.width;
+	const uint32_t in_h = stream->public.src.height;
+	const uint32_t out_w = stream->public.dst.width;
+	const uint32_t out_h = stream->public.dst.height;
+
+	pipe_ctx->scl_data.ratios.horz = dal_fixed31_32_from_fraction(
+					surface->src_rect.width,
+					surface->dst_rect.width);
+	pipe_ctx->scl_data.ratios.vert = dal_fixed31_32_from_fraction(
+					surface->src_rect.height,
+					surface->dst_rect.height);
+
+	if (surface->stereo_format == PLANE_STEREO_FORMAT_SIDE_BY_SIDE)
+		pipe_ctx->scl_data.ratios.horz.value *= 2;
+	else if (surface->stereo_format == PLANE_STEREO_FORMAT_TOP_AND_BOTTOM)
+		pipe_ctx->scl_data.ratios.vert.value *= 2;
+
+	pipe_ctx->scl_data.ratios.vert.value = div64_s64(
+		pipe_ctx->scl_data.ratios.vert.value * in_h, out_h);
+	pipe_ctx->scl_data.ratios.horz.value = div64_s64(
+		pipe_ctx->scl_data.ratios.horz.value * in_w, out_w);
+
+	pipe_ctx->scl_data.ratios.horz_c = pipe_ctx->scl_data.ratios.horz;
+	pipe_ctx->scl_data.ratios.vert_c = pipe_ctx->scl_data.ratios.vert;
+
+	if (pipe_ctx->scl_data.format == PIXEL_FORMAT_420BPP12) {
+		pipe_ctx->scl_data.ratios.horz_c.value /= 2;
+		pipe_ctx->scl_data.ratios.vert_c.value /= 2;
+	}
+}
+
+bool resource_build_scaling_params(
+	const struct dc_surface *surface,
+	struct pipe_ctx *pipe_ctx)
+{
+	bool res;
+	struct dc_crtc_timing *timing = &pipe_ctx->stream->public.timing;
+	/* Important: scaling ratio calculation requires pixel format,
+	 * lb depth calculation requires recout and taps require scaling ratios.
+	 */
+	pipe_ctx->scl_data.format = convert_pixel_format_to_dalsurface(surface->format);
+
+	calculate_viewport(surface, pipe_ctx);
+
+	if (pipe_ctx->scl_data.viewport.height < 16 || pipe_ctx->scl_data.viewport.width < 16)
+		return false;
+
+	calculate_scaling_ratios(surface, pipe_ctx);
+
+	calculate_recout(surface, pipe_ctx);
+
+	/**
+	 * Setting line buffer pixel depth to 24bpp yields banding
+	 * on certain displays, such as the Sharp 4k
+	 */
+	pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_30BPP;
+
+	pipe_ctx->scl_data.h_active = timing->h_addressable;
+	pipe_ctx->scl_data.v_active = timing->v_addressable;
+
+	/* Taps calculations */
+	res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
+		pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+
+	if (!res) {
+		/* Try 24 bpp linebuffer */
+		pipe_ctx->scl_data.lb_params.depth = LB_PIXEL_DEPTH_24BPP;
+
+		res = pipe_ctx->xfm->funcs->transform_get_optimal_number_of_taps(
+			pipe_ctx->xfm, &pipe_ctx->scl_data, &surface->scaling_quality);
+	}
+
+	dm_logger_write(pipe_ctx->stream->ctx->logger, LOG_SCALER,
+				"%s: Viewport:\nheight:%d width:%d x:%d "
+				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
+				"y:%d\n",
+				__func__,
+				pipe_ctx->scl_data.viewport.height,
+				pipe_ctx->scl_data.viewport.width,
+				pipe_ctx->scl_data.viewport.x,
+				pipe_ctx->scl_data.viewport.y,
+				surface->dst_rect.height,
+				surface->dst_rect.width,
+				surface->dst_rect.x,
+				surface->dst_rect.y);
+
+	return res;
+}
+
+
+enum dc_status resource_build_scaling_params_for_context(
+	const struct core_dc *dc,
+	struct validate_context *context)
+{
+	int i;
+
+	for (i = 0; i < MAX_PIPES; i++) {
+		if (context->res_ctx.pipe_ctx[i].surface != NULL &&
+				context->res_ctx.pipe_ctx[i].stream != NULL)
+			if (!resource_build_scaling_params(
+				&context->res_ctx.pipe_ctx[i].surface->public,
+				&context->res_ctx.pipe_ctx[i]))
+				return DC_FAIL_BANDWIDTH_VALIDATE;
+	}
+
+	return DC_OK;
+}
+
+static void detach_surfaces_for_target(
+		struct validate_context *context,
+		const struct dc_target *dc_target)
+{
+	int i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+
+	for (i = 0; i < context->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &context->res_ctx.pipe_ctx[i];
+		if (cur_pipe->stream == stream) {
+			cur_pipe->surface = NULL;
+			cur_pipe->top_pipe = NULL;
+			cur_pipe->bottom_pipe = NULL;
+		}
+	}
+}
+
+struct pipe_ctx *find_idle_secondary_pipe(struct resource_context *res_ctx)
+{
+	int i;
+	struct pipe_ctx *secondary_pipe = NULL;
+
+	/*
+	 * search backwards for the second pipe to keep pipe
+	 * assignment more consistent
+	 */
+
+	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+		if (res_ctx->pipe_ctx[i].stream == NULL) {
+			secondary_pipe = &res_ctx->pipe_ctx[i];
+			secondary_pipe->pipe_idx = i;
+			break;
+		}
+	}
+
+
+	return secondary_pipe;
+}
+
+struct pipe_ctx *resource_get_head_pipe_for_stream(
+		struct resource_context *res_ctx,
+		const struct core_stream *stream)
+{
+	int i;
+	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+		if (res_ctx->pipe_ctx[i].stream == stream &&
+				!res_ctx->pipe_ctx[i].top_pipe) {
+			return &res_ctx->pipe_ctx[i];
+			break;
+		}
+	}
+	return NULL;
+}
+
+/*
+ * A free_pipe for a target is defined here as a pipe with a stream that belongs
+ * to the target but has no surface attached yet
+ */
+static struct pipe_ctx *acquire_free_pipe_for_target(
+		struct resource_context *res_ctx,
+		const struct dc_target *dc_target)
+{
+	int i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+
+	struct pipe_ctx *head_pipe = NULL;
+
+	/* Find head pipe, which has the back end set up*/
+
+	head_pipe = resource_get_head_pipe_for_stream(res_ctx, stream);
+
+	if (!head_pipe)
+		ASSERT(0);
+
+	if (!head_pipe->surface)
+		return head_pipe;
+
+	/* Re-use pipe already acquired for this stream if available*/
+	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+		if (res_ctx->pipe_ctx[i].stream == stream &&
+				!res_ctx->pipe_ctx[i].surface) {
+			return &res_ctx->pipe_ctx[i];
+		}
+	}
+
+	/*
+	 * At this point we have no re-useable pipe for this stream and we need
+	 * to acquire an idle one to satisfy the request
+	 */
+
+	if(!res_ctx->pool->funcs->acquire_idle_pipe_for_layer)
+		return NULL;
+
+	return res_ctx->pool->funcs->acquire_idle_pipe_for_layer(res_ctx, stream);
+
+}
+
+static void release_free_pipes_for_target(
+		struct resource_context *res_ctx,
+		const struct dc_target *dc_target)
+{
+	int i;
+	struct core_stream *stream = DC_STREAM_TO_CORE(dc_target->streams[0]);
+
+	for (i = res_ctx->pool->pipe_count - 1; i >= 0; i--) {
+		if (res_ctx->pipe_ctx[i].stream == stream &&
+				!res_ctx->pipe_ctx[i].surface) {
+			res_ctx->pipe_ctx[i].stream = NULL;
+		}
+	}
+}
+
+bool resource_attach_surfaces_to_context(
+		const struct dc_surface * const *surfaces,
+		int surface_count,
+		const struct dc_target *dc_target,
+		struct validate_context *context)
+{
+	int i;
+	struct pipe_ctx *tail_pipe;
+	struct dc_target_status *target_status = NULL;
+
+
+	if (surface_count > MAX_SURFACE_NUM) {
+		dm_error("Surface: can not attach %d surfaces! Maximum is: %d\n",
+			surface_count, MAX_SURFACE_NUM);
+		return false;
+	}
+
+	for (i = 0; i < context->target_count; i++)
+		if (&context->targets[i]->public == dc_target) {
+			target_status = &context->target_status[i];
+			break;
+		}
+	if (target_status == NULL) {
+		dm_error("Existing target not found; failed to attach surfaces\n");
+		return false;
+	}
+
+	/* retain new surfaces */
+	for (i = 0; i < surface_count; i++)
+		dc_surface_retain(surfaces[i]);
+
+	detach_surfaces_for_target(context, dc_target);
+
+	/* release existing surfaces*/
+	for (i = 0; i < target_status->surface_count; i++)
+		dc_surface_release(target_status->surfaces[i]);
+
+	for (i = surface_count; i < target_status->surface_count; i++)
+		target_status->surfaces[i] = NULL;
+
+	target_status->surface_count = 0;
+
+	if (surface_count == 0)
+		return true;
+
+	tail_pipe = NULL;
+	for (i = 0; i < surface_count; i++) {
+		struct core_surface *surface = DC_SURFACE_TO_CORE(surfaces[i]);
+		struct pipe_ctx *free_pipe = acquire_free_pipe_for_target(
+				&context->res_ctx, dc_target);
+
+		if (!free_pipe) {
+			target_status->surfaces[i] = NULL;
+			return false;
+		}
+
+		free_pipe->surface = surface;
+
+		if (tail_pipe) {
+			free_pipe->top_pipe = tail_pipe;
+			tail_pipe->bottom_pipe = free_pipe;
+		}
+
+		tail_pipe = free_pipe;
+	}
+
+	release_free_pipes_for_target(&context->res_ctx, dc_target);
+
+	/* assign new surfaces*/
+	for (i = 0; i < surface_count; i++)
+		target_status->surfaces[i] = surfaces[i];
+
+	target_status->surface_count = surface_count;
+
+	return true;
+}
+
+
+static bool is_timing_changed(const struct core_stream *cur_stream,
+		const struct core_stream *new_stream)
+{
+	if (cur_stream == NULL)
+		return true;
+
+	/* If sink pointer changed, it means this is a hotplug, we should do
+	 * full hw setting.
+	 */
+	if (cur_stream->sink != new_stream->sink)
+		return true;
+
+	/* If output color space is changed, need to reprogram info frames */
+	if (cur_stream->public.output_color_space !=
+			new_stream->public.output_color_space)
+		return true;
+
+	return memcmp(
+		&cur_stream->public.timing,
+		&new_stream->public.timing,
+		sizeof(struct dc_crtc_timing)) != 0;
+}
+
+static bool are_stream_backends_same(
+	const struct core_stream *stream_a, const struct core_stream *stream_b)
+{
+	if (stream_a == stream_b)
+		return true;
+
+	if (stream_a == NULL || stream_b == NULL)
+		return false;
+
+	if (is_timing_changed(stream_a, stream_b))
+		return false;
+
+	return true;
+}
+
+bool is_target_unchanged(
+	const struct core_target *old_target, const struct core_target *target)
+{
+	int i;
+
+	if (old_target == target)
+		return true;
+	if (old_target->public.stream_count != target->public.stream_count)
+		return false;
+
+	for (i = 0; i < old_target->public.stream_count; i++) {
+		const struct core_stream *old_stream = DC_STREAM_TO_CORE(
+				old_target->public.streams[i]);
+		const struct core_stream *stream = DC_STREAM_TO_CORE(
+				target->public.streams[i]);
+
+		if (!are_stream_backends_same(old_stream, stream))
+			return false;
+	}
+
+	return true;
+}
+
+bool resource_validate_attach_surfaces(
+		const struct dc_validation_set set[],
+		int set_count,
+		const struct validate_context *old_context,
+		struct validate_context *context)
+{
+	int i, j;
+
+	for (i = 0; i < set_count; i++) {
+		for (j = 0; j < old_context->target_count; j++)
+			if (is_target_unchanged(
+					old_context->targets[j],
+					context->targets[i])) {
+				if (!resource_attach_surfaces_to_context(
+						old_context->target_status[j].surfaces,
+						old_context->target_status[j].surface_count,
+						&context->targets[i]->public,
+						context))
+					return false;
+				context->target_status[i] = old_context->target_status[j];
+			}
+		if (set[i].surface_count != 0)
+			if (!resource_attach_surfaces_to_context(
+					set[i].surfaces,
+					set[i].surface_count,
+					&context->targets[i]->public,
+					context))
+				return false;
+
+	}
+
+	return true;
+}
+
+/* Maximum TMDS single link pixel clock 165MHz */
+#define TMDS_MAX_PIXEL_CLOCK_IN_KHZ 165000
+
+static void set_stream_engine_in_use(
+		struct resource_context *res_ctx,
+		struct stream_encoder *stream_enc)
+{
+	int i;
+
+	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
+		if (res_ctx->pool->stream_enc[i] == stream_enc)
+			res_ctx->is_stream_enc_acquired[i] = true;
+	}
+}
+
+/* TODO: release audio object */
+static void set_audio_in_use(
+		struct resource_context *res_ctx,
+		struct audio *audio)
+{
+	int i;
+	for (i = 0; i < res_ctx->pool->audio_count; i++) {
+		if (res_ctx->pool->audios[i] == audio) {
+			res_ctx->is_audio_acquired[i] = true;
+		}
+	}
+}
+
+static int acquire_first_free_pipe(
+		struct resource_context *res_ctx,
+		struct core_stream *stream)
+{
+	int i;
+
+	for (i = 0; i < res_ctx->pool->pipe_count; i++) {
+		if (!res_ctx->pipe_ctx[i].stream) {
+			struct pipe_ctx *pipe_ctx = &res_ctx->pipe_ctx[i];
+
+			pipe_ctx->tg = res_ctx->pool->timing_generators[i];
+			pipe_ctx->mi = res_ctx->pool->mis[i];
+			pipe_ctx->ipp = res_ctx->pool->ipps[i];
+			pipe_ctx->xfm = res_ctx->pool->transforms[i];
+			pipe_ctx->opp = res_ctx->pool->opps[i];
+			pipe_ctx->dis_clk = res_ctx->pool->display_clock;
+			pipe_ctx->pipe_idx = i;
+
+			pipe_ctx->stream = stream;
+			return i;
+		}
+	}
+	return -1;
+}
+
+static struct stream_encoder *find_first_free_match_stream_enc_for_link(
+		struct resource_context *res_ctx,
+		struct core_stream *stream)
+{
+	int i;
+	int j = -1;
+	struct core_link *link = stream->sink->link;
+
+	for (i = 0; i < res_ctx->pool->stream_enc_count; i++) {
+		if (!res_ctx->is_stream_enc_acquired[i] &&
+					res_ctx->pool->stream_enc[i]) {
+			/* Store first available for MST second display
+			 * in daisy chain use case */
+			j = i;
+			if (res_ctx->pool->stream_enc[i]->id ==
+					link->link_enc->preferred_engine)
+				return res_ctx->pool->stream_enc[i];
+		}
+	}
+
+	/*
+	 * below can happen in cases when stream encoder is acquired:
+	 * 1) for second MST display in chain, so preferred engine already
+	 * acquired;
+	 * 2) for another link, which preferred engine already acquired by any
+	 * MST configuration.
+	 *
+	 * If signal is of DP type and preferred engine not found, return last available
+	 *
+	 * TODO - This is just a patch up and a generic solution is
+	 * required for non DP connectors.
+	 */
+
+	if (j >= 0 && dc_is_dp_signal(stream->signal))
+		return res_ctx->pool->stream_enc[j];
+
+	return NULL;
+}
+
+static struct audio *find_first_free_audio(struct resource_context *res_ctx)
+{
+	int i;
+	for (i = 0; i < res_ctx->pool->audio_count; i++) {
+		if (res_ctx->is_audio_acquired[i] == false) {
+			return res_ctx->pool->audios[i];
+		}
+	}
+
+	return 0;
+}
+
+static void update_stream_signal(struct core_stream *stream)
+{
+	const struct dc_sink *dc_sink = stream->public.sink;
+
+	stream->signal = dc_sink->sink_signal;
+	/* For asic supports dual link DVI, we should adjust signal type
+	 * based on timing pixel clock. If pixel clock more than 165Mhz,
+	 * signal is dual link, otherwise, single link.
+	 */
+	if (dc_sink->sink_signal == SIGNAL_TYPE_DVI_SINGLE_LINK ||
+			dc_sink->sink_signal == SIGNAL_TYPE_DVI_DUAL_LINK) {
+		if (stream->public.timing.pix_clk_khz >
+						TMDS_MAX_PIXEL_CLOCK_IN_KHZ)
+			stream->signal = SIGNAL_TYPE_DVI_DUAL_LINK;
+		else
+			stream->signal = SIGNAL_TYPE_DVI_SINGLE_LINK;
+	}
+}
+
+bool resource_is_stream_unchanged(
+	const struct validate_context *old_context, struct core_stream *stream)
+{
+	int i, j;
+
+	for (i = 0; i < old_context->target_count; i++) {
+		struct core_target *old_target = old_context->targets[i];
+
+		for (j = 0; j < old_target->public.stream_count; j++) {
+			struct core_stream *old_stream =
+				DC_STREAM_TO_CORE(old_target->public.streams[j]);
+
+			if (are_stream_backends_same(old_stream, stream))
+				return true;
+		}
+	}
+
+	return false;
+}
+
+static void copy_pipe_ctx(
+	const struct pipe_ctx *from_pipe_ctx, struct pipe_ctx *to_pipe_ctx)
+{
+	struct core_surface *surface = to_pipe_ctx->surface;
+	struct core_stream *stream = to_pipe_ctx->stream;
+
+	*to_pipe_ctx = *from_pipe_ctx;
+	to_pipe_ctx->stream = stream;
+	if (surface != NULL)
+		to_pipe_ctx->surface = surface;
+}
+
+static struct core_stream *find_pll_sharable_stream(
+		const struct core_stream *stream_needs_pll,
+		struct validate_context *context)
+{
+	int i, j;
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream_has_pll =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+
+			/* We are looking for non dp, non virtual stream */
+			if (resource_are_streams_timing_synchronizable(
+						stream_needs_pll, stream_has_pll)
+				&& !dc_is_dp_signal(stream_has_pll->signal)
+				&& stream_has_pll->sink->link->public.connector_signal
+							!= SIGNAL_TYPE_VIRTUAL)
+					return stream_has_pll;
+		}
+	}
+
+	return NULL;
+}
+
+static int get_norm_pix_clk(const struct dc_crtc_timing *timing)
+{
+	uint32_t pix_clk = timing->pix_clk_khz;
+	uint32_t normalized_pix_clk = pix_clk;
+
+	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		pix_clk /= 2;
+
+	switch (timing->display_color_depth) {
+	case COLOR_DEPTH_888:
+		normalized_pix_clk = pix_clk;
+		break;
+	case COLOR_DEPTH_101010:
+		normalized_pix_clk = (pix_clk * 30) / 24;
+		break;
+	case COLOR_DEPTH_121212:
+		normalized_pix_clk = (pix_clk * 36) / 24;
+		break;
+	case COLOR_DEPTH_161616:
+		normalized_pix_clk = (pix_clk * 48) / 24;
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+
+	return normalized_pix_clk;
+}
+
+static void calculate_phy_pix_clks(
+		const struct core_dc *dc,
+		struct validate_context *context)
+{
+	int i, j;
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+
+			update_stream_signal(stream);
+
+			/* update actual pixel clock on all streams */
+			if (dc_is_hdmi_signal(stream->signal))
+				stream->phy_pix_clk = get_norm_pix_clk(
+					&stream->public.timing);
+			else
+				stream->phy_pix_clk =
+						stream->public.timing.pix_clk_khz;
+		}
+	}
+}
+
+enum dc_status resource_map_pool_resources(
+		const struct core_dc *dc,
+		struct validate_context *context)
+{
+	int i, j, k;
+
+	calculate_phy_pix_clks(dc, context);
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+
+			if (!resource_is_stream_unchanged(dc->current_context, stream))
+				continue;
+
+			/* mark resources used for stream that is already active */
+			for (k = 0; k < MAX_PIPES; k++) {
+				struct pipe_ctx *pipe_ctx =
+					&context->res_ctx.pipe_ctx[k];
+				const struct pipe_ctx *old_pipe_ctx =
+					&dc->current_context->res_ctx.pipe_ctx[k];
+
+				if (!are_stream_backends_same(old_pipe_ctx->stream, stream))
+					continue;
+
+				pipe_ctx->stream = stream;
+				copy_pipe_ctx(old_pipe_ctx, pipe_ctx);
+
+				set_stream_engine_in_use(
+					&context->res_ctx,
+					pipe_ctx->stream_enc);
+
+				/* Switch to dp clock source only if there is
+				 * no non dp stream that shares the same timing
+				 * with the dp stream.
+				 */
+				if (dc_is_dp_signal(pipe_ctx->stream->signal) &&
+					!find_pll_sharable_stream(stream, context))
+					pipe_ctx->clock_source =
+						context->res_ctx.pool->dp_clock_source;
+
+				resource_reference_clock_source(
+					&context->res_ctx,
+					pipe_ctx->clock_source);
+
+				set_audio_in_use(&context->res_ctx,
+					pipe_ctx->audio);
+			}
+		}
+	}
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+			struct pipe_ctx *pipe_ctx = NULL;
+			int pipe_idx = -1;
+
+			if (resource_is_stream_unchanged(dc->current_context, stream))
+				continue;
+			/* acquire new resources */
+			pipe_idx = acquire_first_free_pipe(
+						&context->res_ctx, stream);
+			if (pipe_idx < 0)
+				return DC_NO_CONTROLLER_RESOURCE;
+
+
+			pipe_ctx = &context->res_ctx.pipe_ctx[pipe_idx];
+
+			pipe_ctx->stream_enc =
+				find_first_free_match_stream_enc_for_link(
+					&context->res_ctx, stream);
+
+			if (!pipe_ctx->stream_enc)
+				return DC_NO_STREAM_ENG_RESOURCE;
+
+			set_stream_engine_in_use(
+					&context->res_ctx,
+					pipe_ctx->stream_enc);
+
+			/* TODO: Add check if ASIC support and EDID audio */
+			if (!stream->sink->converter_disable_audio &&
+						dc_is_audio_capable_signal(pipe_ctx->stream->signal) &&
+						stream->public.audio_info.mode_count) {
+				pipe_ctx->audio = find_first_free_audio(
+						&context->res_ctx);
+
+				/*
+				 * Audio assigned in order first come first get.
+				 * There are asics which has number of audio
+				 * resources less then number of pipes
+				 */
+				if (pipe_ctx->audio)
+					set_audio_in_use(
+						&context->res_ctx,
+						pipe_ctx->audio);
+			}
+
+			if (j == 0) {
+				context->target_status[i].primary_otg_inst =
+						pipe_ctx->tg->inst;
+			}
+		}
+	}
+
+	return DC_OK;
+}
+
+/* first target in the context is used to populate the rest */
+void validate_guaranteed_copy_target(
+		struct validate_context *context,
+		int max_targets)
+{
+	int i;
+
+	for (i = 1; i < max_targets; i++) {
+		context->targets[i] = context->targets[0];
+
+		copy_pipe_ctx(&context->res_ctx.pipe_ctx[0],
+			      &context->res_ctx.pipe_ctx[i]);
+		context->res_ctx.pipe_ctx[i].stream =
+				context->res_ctx.pipe_ctx[0].stream;
+
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
+	}
+}
+
+static void translate_info_frame(const struct hw_info_frame *hw_info_frame,
+	struct encoder_info_frame *encoder_info_frame)
+{
+	memset(
+		encoder_info_frame, 0, sizeof(struct encoder_info_frame));
+
+	/* For gamut we recalc checksum */
+	if (hw_info_frame->gamut_packet.valid) {
+		uint8_t chk_sum = 0;
+		uint8_t *ptr;
+		uint8_t i;
+
+		memmove(
+						&encoder_info_frame->gamut,
+						&hw_info_frame->gamut_packet,
+						sizeof(struct hw_info_packet));
+
+		/*start of the Gamut data. */
+		ptr = &encoder_info_frame->gamut.sb[3];
+
+		for (i = 0; i <= encoder_info_frame->gamut.sb[1]; i++)
+			chk_sum += ptr[i];
+
+		encoder_info_frame->gamut.sb[2] = (uint8_t) (0x100 - chk_sum);
+	}
+
+	if (hw_info_frame->avi_info_packet.valid) {
+		memmove(
+						&encoder_info_frame->avi,
+						&hw_info_frame->avi_info_packet,
+						sizeof(struct hw_info_packet));
+	}
+
+	if (hw_info_frame->vendor_info_packet.valid) {
+		memmove(
+						&encoder_info_frame->vendor,
+						&hw_info_frame->vendor_info_packet,
+						sizeof(struct hw_info_packet));
+	}
+
+	if (hw_info_frame->spd_packet.valid) {
+		memmove(
+						&encoder_info_frame->spd,
+						&hw_info_frame->spd_packet,
+						sizeof(struct hw_info_packet));
+	}
+
+	if (hw_info_frame->vsc_packet.valid) {
+		memmove(
+						&encoder_info_frame->vsc,
+						&hw_info_frame->vsc_packet,
+						sizeof(struct hw_info_packet));
+	}
+}
+
+static void set_avi_info_frame(
+	struct hw_info_packet *info_packet,
+		struct pipe_ctx *pipe_ctx)
+{
+	struct core_stream *stream = pipe_ctx->stream;
+	enum dc_color_space color_space = COLOR_SPACE_UNKNOWN;
+	struct info_frame info_frame = { {0} };
+	uint32_t pixel_encoding = 0;
+	enum scanning_type scan_type = SCANNING_TYPE_NODATA;
+	enum dc_aspect_ratio aspect = ASPECT_RATIO_NO_DATA;
+	bool itc = false;
+	uint8_t cn0_cn1 = 0;
+	uint8_t *check_sum = NULL;
+	uint8_t byte_index = 0;
+
+	if (info_packet == NULL)
+		return;
+
+	color_space = pipe_ctx->stream->public.output_color_space;
+
+	/* Initialize header */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.header.
+			info_frame_type = INFO_FRAME_AVI;
+	/* InfoFrameVersion_3 is defined by CEA861F (Section 6.4), but shall
+	* not be used in HDMI 2.0 (Section 10.1) */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.header.version =
+			INFO_FRAME_VERSION_2;
+	info_frame.avi_info_packet.info_packet_hdmi.bits.header.length =
+			INFO_FRAME_SIZE_AVI;
+
+	/*
+	 * IDO-defined (Y2,Y1,Y0 = 1,1,1) shall not be used by devices built
+	 * according to HDMI 2.0 spec (Section 10.1)
+	 */
+
+	switch (stream->public.timing.pixel_encoding) {
+	case PIXEL_ENCODING_YCBCR422:
+		pixel_encoding = 1;
+		break;
+
+	case PIXEL_ENCODING_YCBCR444:
+		pixel_encoding = 2;
+		break;
+	case PIXEL_ENCODING_YCBCR420:
+		pixel_encoding = 3;
+		break;
+
+	case PIXEL_ENCODING_RGB:
+	default:
+		pixel_encoding = 0;
+	}
+
+	/* Y0_Y1_Y2 : The pixel encoding */
+	/* H14b AVI InfoFrame has extension on Y-field from 2 bits to 3 bits */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.Y0_Y1_Y2 =
+		pixel_encoding;
+
+	/* A0 = 1 Active Format Information valid */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.A0 =
+		ACTIVE_FORMAT_VALID;
+
+	/* B0, B1 = 3; Bar info data is valid */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.B0_B1 =
+		BAR_INFO_BOTH_VALID;
+
+	info_frame.avi_info_packet.info_packet_hdmi.bits.SC0_SC1 =
+			PICTURE_SCALING_UNIFORM;
+
+	/* S0, S1 : Underscan / Overscan */
+	/* TODO: un-hardcode scan type */
+	scan_type = SCANNING_TYPE_UNDERSCAN;
+	info_frame.avi_info_packet.info_packet_hdmi.bits.S0_S1 = scan_type;
+
+	/* C0, C1 : Colorimetry */
+	if (color_space == COLOR_SPACE_YCBCR709)
+		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
+				COLORIMETRY_ITU709;
+	else if (color_space == COLOR_SPACE_YCBCR601)
+		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
+				COLORIMETRY_ITU601;
+	else
+		info_frame.avi_info_packet.info_packet_hdmi.bits.C0_C1 =
+				COLORIMETRY_NO_DATA;
+
+	/* TODO: un-hardcode aspect ratio */
+	aspect = stream->public.timing.aspect_ratio;
+
+	switch (aspect) {
+	case ASPECT_RATIO_4_3:
+	case ASPECT_RATIO_16_9:
+		info_frame.avi_info_packet.info_packet_hdmi.bits.M0_M1 = aspect;
+		break;
+
+	case ASPECT_RATIO_NO_DATA:
+	case ASPECT_RATIO_64_27:
+	case ASPECT_RATIO_256_135:
+	default:
+		info_frame.avi_info_packet.info_packet_hdmi.bits.M0_M1 = 0;
+	}
+
+	/* Active Format Aspect ratio - same as Picture Aspect Ratio. */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.R0_R3 =
+			ACTIVE_FORMAT_ASPECT_RATIO_SAME_AS_PICTURE;
+
+	/* TODO: un-hardcode cn0_cn1 and itc */
+	cn0_cn1 = 0;
+	itc = false;
+
+	if (itc) {
+		info_frame.avi_info_packet.info_packet_hdmi.bits.ITC = 1;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.CN0_CN1 =
+			cn0_cn1;
+	}
+
+	/* TODO : We should handle YCC quantization */
+	/* but we do not have matrix calculation */
+	if (color_space == COLOR_SPACE_SRGB) {
+		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
+						RGB_QUANTIZATION_FULL_RANGE;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
+						YYC_QUANTIZATION_FULL_RANGE;
+	} else if (color_space == COLOR_SPACE_SRGB_LIMITED) {
+		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
+						RGB_QUANTIZATION_LIMITED_RANGE;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
+						YYC_QUANTIZATION_LIMITED_RANGE;
+	} else {
+		info_frame.avi_info_packet.info_packet_hdmi.bits.Q0_Q1 =
+						RGB_QUANTIZATION_DEFAULT_RANGE;
+		info_frame.avi_info_packet.info_packet_hdmi.bits.YQ0_YQ1 =
+						YYC_QUANTIZATION_LIMITED_RANGE;
+	}
+
+	info_frame.avi_info_packet.info_packet_hdmi.bits.VIC0_VIC7 =
+					stream->public.timing.vic;
+
+	/* pixel repetition
+	 * PR0 - PR3 start from 0 whereas pHwPathMode->mode.timing.flags.pixel
+	 * repetition start from 1 */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.PR0_PR3 = 0;
+
+	/* Bar Info
+	 * barTop:    Line Number of End of Top Bar.
+	 * barBottom: Line Number of Start of Bottom Bar.
+	 * barLeft:   Pixel Number of End of Left Bar.
+	 * barRight:  Pixel Number of Start of Right Bar. */
+	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_top =
+			stream->public.timing.v_border_top;
+	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_bottom =
+		(stream->public.timing.v_border_top
+			- stream->public.timing.v_border_bottom + 1);
+	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_left =
+			stream->public.timing.h_border_left;
+	info_frame.avi_info_packet.info_packet_hdmi.bits.bar_right =
+		(stream->public.timing.h_total
+			- stream->public.timing.h_border_right + 1);
+
+	/* check_sum - Calculate AFMT_AVI_INFO0 ~ AFMT_AVI_INFO3 */
+	check_sum =
+		&info_frame.
+		avi_info_packet.info_packet_hdmi.packet_raw_data.sb[0];
+	*check_sum = INFO_FRAME_AVI + INFO_FRAME_SIZE_AVI
+			+ INFO_FRAME_VERSION_2;
+
+	for (byte_index = 1; byte_index <= INFO_FRAME_SIZE_AVI; byte_index++)
+		*check_sum += info_frame.avi_info_packet.info_packet_hdmi.
+				packet_raw_data.sb[byte_index];
+
+	/* one byte complement */
+	*check_sum = (uint8_t) (0x100 - *check_sum);
+
+	/* Store in hw_path_mode */
+	info_packet->hb0 =
+		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb0;
+	info_packet->hb1 =
+		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb1;
+	info_packet->hb2 =
+		info_frame.avi_info_packet.info_packet_hdmi.packet_raw_data.hb2;
+
+	for (byte_index = 0; byte_index < sizeof(info_packet->sb); byte_index++)
+		info_packet->sb[byte_index] = info_frame.avi_info_packet.
+		info_packet_hdmi.packet_raw_data.sb[byte_index];
+
+	info_packet->valid = true;
+}
+
+static void set_vendor_info_packet(struct core_stream *stream,
+		struct hw_info_packet *info_packet)
+{
+	uint32_t length = 0;
+	bool hdmi_vic_mode = false;
+	uint8_t checksum = 0;
+	uint32_t i = 0;
+	enum dc_timing_3d_format format;
+
+	ASSERT_CRITICAL(stream != NULL);
+	ASSERT_CRITICAL(info_packet != NULL);
+
+	format = stream->public.timing.timing_3d_format;
+
+	/* Can be different depending on packet content */
+	length = 5;
+
+	if (stream->public.timing.hdmi_vic != 0
+			&& stream->public.timing.h_total >= 3840
+			&& stream->public.timing.v_total >= 2160)
+		hdmi_vic_mode = true;
+
+	/* According to HDMI 1.4a CTS, VSIF should be sent
+	 * for both 3D stereo and HDMI VIC modes.
+	 * For all other modes, there is no VSIF sent.  */
+
+	if (format == TIMING_3D_FORMAT_NONE && !hdmi_vic_mode)
+		return;
+
+	/* 24bit IEEE Registration identifier (0x000c03). LSB first. */
+	info_packet->sb[1] = 0x03;
+	info_packet->sb[2] = 0x0C;
+	info_packet->sb[3] = 0x00;
+
+	/*PB4: 5 lower bytes = 0 (reserved). 3 higher bits = HDMI_Video_Format.
+	 * The value for HDMI_Video_Format are:
+	 * 0x0 (0b000) - No additional HDMI video format is presented in this
+	 * packet
+	 * 0x1 (0b001) - Extended resolution format present. 1 byte of HDMI_VIC
+	 * parameter follows
+	 * 0x2 (0b010) - 3D format indication present. 3D_Structure and
+	 * potentially 3D_Ext_Data follows
+	 * 0x3..0x7 (0b011..0b111) - reserved for future use */
+	if (format != TIMING_3D_FORMAT_NONE)
+		info_packet->sb[4] = (2 << 5);
+	else if (hdmi_vic_mode)
+		info_packet->sb[4] = (1 << 5);
+
+	/* PB5: If PB4 claims 3D timing (HDMI_Video_Format = 0x2):
+	 * 4 lower bites = 0 (reserved). 4 higher bits = 3D_Structure.
+	 * The value for 3D_Structure are:
+	 * 0x0 - Frame Packing
+	 * 0x1 - Field Alternative
+	 * 0x2 - Line Alternative
+	 * 0x3 - Side-by-Side (full)
+	 * 0x4 - L + depth
+	 * 0x5 - L + depth + graphics + graphics-depth
+	 * 0x6 - Top-and-Bottom
+	 * 0x7 - Reserved for future use
+	 * 0x8 - Side-by-Side (Half)
+	 * 0x9..0xE - Reserved for future use
+	 * 0xF - Not used */
+	switch (format) {
+	case TIMING_3D_FORMAT_HW_FRAME_PACKING:
+	case TIMING_3D_FORMAT_SW_FRAME_PACKING:
+		info_packet->sb[5] = (0x0 << 4);
+		break;
+
+	case TIMING_3D_FORMAT_SIDE_BY_SIDE:
+	case TIMING_3D_FORMAT_SBS_SW_PACKED:
+		info_packet->sb[5] = (0x8 << 4);
+		length = 6;
+		break;
+
+	case TIMING_3D_FORMAT_TOP_AND_BOTTOM:
+	case TIMING_3D_FORMAT_TB_SW_PACKED:
+		info_packet->sb[5] = (0x6 << 4);
+		break;
+
+	default:
+		break;
+	}
+
+	/*PB5: If PB4 is set to 0x1 (extended resolution format)
+	 * fill PB5 with the correct HDMI VIC code */
+	if (hdmi_vic_mode)
+		info_packet->sb[5] = stream->public.timing.hdmi_vic;
+
+	/* Header */
+	info_packet->hb0 = 0x81; /* VSIF packet type. */
+	info_packet->hb1 = 0x01; /* Version */
+
+	/* 4 lower bits = Length, 4 higher bits = 0 (reserved) */
+	info_packet->hb2 = (uint8_t) (length);
+
+	/* Calculate checksum */
+	checksum = 0;
+	checksum += info_packet->hb0;
+	checksum += info_packet->hb1;
+	checksum += info_packet->hb2;
+
+	for (i = 1; i <= length; i++)
+		checksum += info_packet->sb[i];
+
+	info_packet->sb[0] = (uint8_t) (0x100 - checksum);
+
+	info_packet->valid = true;
+}
+
+static void set_spd_info_packet(struct core_stream *stream,
+		struct hw_info_packet *info_packet)
+{
+	/* SPD info packet for FreeSync */
+
+	unsigned char checksum = 0;
+	unsigned int idx, payload_size = 0;
+
+	/* Check if Freesync is supported. Return if false. If true,
+	 * set the corresponding bit in the info packet
+	 */
+	if (stream->public.freesync_ctx.supported == false)
+		return;
+
+	if (dc_is_hdmi_signal(stream->signal)) {
+
+		/* HEADER */
+
+		/* HB0  = Packet Type = 0x83 (Source Product
+		 *	  Descriptor InfoFrame)
+		 */
+		info_packet->hb0 = 0x83;
+
+		/* HB1  = Version = 0x01 */
+		info_packet->hb1 = 0x01;
+
+		/* HB2  = [Bits 7:5 = 0] [Bits 4:0 = Length = 0x08] */
+		info_packet->hb2 = 0x08;
+
+		payload_size = 0x08;
+
+	} else if (dc_is_dp_signal(stream->signal)) {
+
+		/* HEADER */
+
+		/* HB0  = Secondary-data Packet ID = 0 - Only non-zero
+		 *	  when used to associate audio related info packets
+		 */
+		info_packet->hb0 = 0x00;
+
+		/* HB1  = Packet Type = 0x83 (Source Product
+		 *	  Descriptor InfoFrame)
+		 */
+		info_packet->hb1 = 0x83;
+
+		/* HB2  = [Bits 7:0 = Least significant eight bits -
+		 *	  For INFOFRAME, the value must be 1Bh]
+		 */
+		info_packet->hb2 = 0x1B;
+
+		/* HB3  = [Bits 7:2 = INFOFRAME SDP Version Number = 0x1]
+		 *	  [Bits 1:0 = Most significant two bits = 0x00]
+		 */
+		info_packet->hb3 = 0x04;
+
+		payload_size = 0x1B;
+	}
+
+	/* PB1 = 0x1A (24bit AMD IEEE OUI (0x00001A) - Byte 0) */
+	info_packet->sb[1] = 0x1A;
+
+	/* PB2 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 1) */
+	info_packet->sb[2] = 0x00;
+
+	/* PB3 = 0x00 (24bit AMD IEEE OUI (0x00001A) - Byte 2) */
+	info_packet->sb[3] = 0x00;
+
+	/* PB4 = Reserved */
+	info_packet->sb[4] = 0x00;
+
+	/* PB5 = Reserved */
+	info_packet->sb[5] = 0x00;
+
+	/* PB6 = [Bits 7:3 = Reserved] */
+	info_packet->sb[6] = 0x00;
+
+	if (stream->public.freesync_ctx.supported == true)
+		/* PB6 = [Bit 0 = FreeSync Supported] */
+		info_packet->sb[6] |= 0x01;
+
+	if (stream->public.freesync_ctx.enabled == true)
+		/* PB6 = [Bit 1 = FreeSync Enabled] */
+		info_packet->sb[6] |= 0x02;
+
+	if (stream->public.freesync_ctx.active == true)
+		/* PB6 = [Bit 2 = FreeSync Active] */
+		info_packet->sb[6] |= 0x04;
+
+	/* PB7 = FreeSync Minimum refresh rate (Hz) */
+	info_packet->sb[7] = (unsigned char) (stream->public.freesync_ctx.
+			min_refresh_in_micro_hz / 1000000);
+
+	/* PB8 = FreeSync Maximum refresh rate (Hz)
+	 *
+	 * Note: We do not use the maximum capable refresh rate
+	 * of the panel, because we should never go above the field
+	 * rate of the mode timing set.
+	 */
+	info_packet->sb[8] = (unsigned char) (stream->public.freesync_ctx.
+			nominal_refresh_in_micro_hz / 1000000);
+
+	/* PB9 - PB27  = Reserved */
+	for (idx = 9; idx <= 27; idx++)
+		info_packet->sb[idx] = 0x00;
+
+	/* Calculate checksum */
+	checksum += info_packet->hb0;
+	checksum += info_packet->hb1;
+	checksum += info_packet->hb2;
+	checksum += info_packet->hb3;
+
+	for (idx = 1; idx <= payload_size; idx++)
+		checksum += info_packet->sb[idx];
+
+	/* PB0 = Checksum (one byte complement) */
+	info_packet->sb[0] = (unsigned char) (0x100 - checksum);
+
+	info_packet->valid = true;
+}
+
+static void set_vsc_info_packet(struct core_stream *stream,
+		struct hw_info_packet *info_packet)
+{
+	unsigned int vscPacketRevision = 0;
+	unsigned int i;
+
+	if (stream->sink->link->public.psr_caps.psr_version != 0) {
+		vscPacketRevision = 2;
+	}
+
+	/* VSC packet not needed based on the features
+	 * supported by this DP display
+	 */
+	if (vscPacketRevision == 0)
+		return;
+
+	if (vscPacketRevision == 0x2) {
+		/* Secondary-data Packet ID = 0*/
+		info_packet->hb0 = 0x00;
+		/* 07h - Packet Type Value indicating Video
+		 * Stream Configuration packet
+		 */
+		info_packet->hb1 = 0x07;
+		/* 02h = VSC SDP supporting 3D stereo and PSR
+		 * (applies to eDP v1.3 or higher).
+		 */
+		info_packet->hb2 = 0x02;
+		/* 08h = VSC packet supporting 3D stereo + PSR
+		 * (HB2 = 02h).
+		 */
+		info_packet->hb3 = 0x08;
+
+		for (i = 0; i < 28; i++)
+			info_packet->sb[i] = 0;
+
+		info_packet->valid = true;
+	}
+
+	/*TODO: stereo 3D support and extend pixel encoding colorimetry*/
+}
+
+void resource_validate_ctx_destruct(struct validate_context *context)
+{
+	int i, j;
+
+	for (i = 0; i < context->target_count; i++) {
+		for (j = 0; j < context->target_status[i].surface_count; j++)
+			dc_surface_release(
+				context->target_status[i].surfaces[j]);
+
+		context->target_status[i].surface_count = 0;
+		dc_target_release(&context->targets[i]->public);
+	}
+}
+
+/*
+ * Copy src_ctx into dst_ctx and retain all surfaces and targets referenced
+ * by the src_ctx
+ */
+void resource_validate_ctx_copy_construct(
+		const struct validate_context *src_ctx,
+		struct validate_context *dst_ctx)
+{
+	int i, j;
+
+	*dst_ctx = *src_ctx;
+
+	for (i = 0; i < dst_ctx->res_ctx.pool->pipe_count; i++) {
+		struct pipe_ctx *cur_pipe = &dst_ctx->res_ctx.pipe_ctx[i];
+
+		if (cur_pipe->top_pipe)
+			cur_pipe->top_pipe =  &dst_ctx->res_ctx.pipe_ctx[cur_pipe->top_pipe->pipe_idx];
+
+		if (cur_pipe->bottom_pipe)
+			cur_pipe->bottom_pipe = &dst_ctx->res_ctx.pipe_ctx[cur_pipe->bottom_pipe->pipe_idx];
+
+	}
+
+	for (i = 0; i < dst_ctx->target_count; i++) {
+		dc_target_retain(&dst_ctx->targets[i]->public);
+		for (j = 0; j < dst_ctx->target_status[i].surface_count; j++)
+			dc_surface_retain(
+				dst_ctx->target_status[i].surfaces[j]);
+	}
+}
+
+struct clock_source *dc_resource_find_first_free_pll(
+		struct resource_context *res_ctx)
+{
+	int i;
+
+	for (i = 0; i < res_ctx->pool->clk_src_count; ++i) {
+		if (res_ctx->clock_source_ref_count[i] == 0)
+			return res_ctx->pool->clock_sources[i];
+	}
+
+	return NULL;
+}
+
+void resource_build_info_frame(struct pipe_ctx *pipe_ctx)
+{
+	enum signal_type signal = SIGNAL_TYPE_NONE;
+	struct hw_info_frame info_frame = { { 0 } };
+
+	/* default all packets to invalid */
+	info_frame.avi_info_packet.valid = false;
+	info_frame.gamut_packet.valid = false;
+	info_frame.vendor_info_packet.valid = false;
+	info_frame.spd_packet.valid = false;
+	info_frame.vsc_packet.valid = false;
+
+	signal = pipe_ctx->stream->signal;
+
+	/* HDMi and DP have different info packets*/
+	if (dc_is_hdmi_signal(signal)) {
+		set_avi_info_frame(
+			&info_frame.avi_info_packet, pipe_ctx);
+		set_vendor_info_packet(
+			pipe_ctx->stream, &info_frame.vendor_info_packet);
+		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
+	}
+
+	else if (dc_is_dp_signal(signal))
+		set_vsc_info_packet(pipe_ctx->stream, &info_frame.vsc_packet);
+		set_spd_info_packet(pipe_ctx->stream, &info_frame.spd_packet);
+
+	translate_info_frame(&info_frame,
+			&pipe_ctx->encoder_info_frame);
+}
+
+enum dc_status resource_map_clock_resources(
+		const struct core_dc *dc,
+		struct validate_context *context)
+{
+	int i, j, k;
+
+	/* acquire new resources */
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+
+			if (resource_is_stream_unchanged(dc->current_context, stream))
+				continue;
+
+			for (k = 0; k < MAX_PIPES; k++) {
+				struct pipe_ctx *pipe_ctx =
+					&context->res_ctx.pipe_ctx[k];
+
+				if (context->res_ctx.pipe_ctx[k].stream != stream)
+					continue;
+
+				if (dc_is_dp_signal(pipe_ctx->stream->signal)
+					|| pipe_ctx->stream->signal == SIGNAL_TYPE_VIRTUAL)
+					pipe_ctx->clock_source =
+						context->res_ctx.pool->dp_clock_source;
+				else {
+					pipe_ctx->clock_source = NULL;
+
+					if (!dc->public.config.disable_disp_pll_sharing)
+						resource_find_used_clk_src_for_sharing(
+							&context->res_ctx,
+							pipe_ctx);
+
+					if (pipe_ctx->clock_source == NULL)
+						pipe_ctx->clock_source =
+							dc_resource_find_first_free_pll(&context->res_ctx);
+				}
+
+				if (pipe_ctx->clock_source == NULL)
+					return DC_NO_CLOCK_SOURCE_RESOURCE;
+
+				resource_reference_clock_source(
+						&context->res_ctx,
+						pipe_ctx->clock_source);
+
+				/* only one cs per stream regardless of mpo */
+				break;
+			}
+		}
+	}
+
+	return DC_OK;
+}
+
+/*
+ * Note: We need to disable output if clock sources change,
+ * since bios does optimization and doesn't apply if changing
+ * PHY when not already disabled.
+ */
+bool pipe_need_reprogram(
+		struct pipe_ctx *pipe_ctx_old,
+		struct pipe_ctx *pipe_ctx)
+{
+	if (pipe_ctx_old->stream->sink != pipe_ctx->stream->sink)
+		return true;
+
+	if (pipe_ctx_old->stream->signal != pipe_ctx->stream->signal)
+		return true;
+
+	if (pipe_ctx_old->audio != pipe_ctx->audio)
+		return true;
+
+	if (pipe_ctx_old->clock_source != pipe_ctx->clock_source
+			&& pipe_ctx_old->stream != pipe_ctx->stream)
+		return true;
+
+	if (pipe_ctx_old->stream_enc != pipe_ctx->stream_enc)
+		return true;
+
+	if (is_timing_changed(pipe_ctx_old->stream, pipe_ctx->stream))
+		return true;
+
+
+	return false;
+}
