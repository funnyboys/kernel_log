commit 9ec051bf4470ee20505c3c1bca9dc441944de4df
Author: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Date:   Wed Apr 29 10:53:02 2020 -0400

    drm/amd/display: Rework dsc to isolate FPU operations
    
    When we want to use float point operation on Linux
    we need to use within special kernel protection
    (`kernel_fpu_{begin,end}()`.), otherwise the kernel
    can clobber userspace FPU register state. For detecting
    these issues we use a tool named objtool (with -Ffa
    flags) to highlight the FPU problems, all warnings can
    be summed up as follows:
    
    ./tools/objtool/objtool check -Ffa
    drivers/gpu/drm/amd/display/dc/dml/dml_common_defs.o
    
    [..] dc/dsc/rc_calc.o: warning: objtool: get_qp_set()+0x2f8:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/rc_calc.o: warning: objtool: dsc_roundf()+0x5:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/rc_calc.o: warning: objtool: dsc_ceil()+0x5:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/rc_calc.o: warning: objtool: get_ofs_set()+0x3eb:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/rc_calc.o: warning: objtool: calc_rc_params()+0x3c:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/dc_dsc.o: warning: objtool:
    get_dsc_bandwidth_range.isra.0()+0x8d:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/dc_dsc.o: warning: objtool: setup_dsc_config()+0x2ef:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/rc_calc_dpi.o: warning: objtool:copy_pps_fields()+0xbb:
    FPU instruction outside of kernel_fpu_{begin,end}()
    [..] dc/dsc/rc_calc_dpi.o: warning: objtool:
    dscc_compute_dsc_parameters()+0x7b:
    FPU instruction outside of kernel_fpu_{begin,end}()
    
    This commit fixes the above issues by rework DSC as described:
    
    1. Isolate all FPU operations in a single file;
    2. Use FPU flags only in the file that handles FPU operations;
    3. Isolate all functions that require float point operation in static
       functions;
    4. Add a mid-layer function that does not use any float point operation,
       and that could be safely invoked in other parts of the code.
    5. Keep float point operation under DC_FP_{START/END} macro.
    
    CC: Christian KÃ¶nig <christian.koenig@amd.com>
    CC: Alexander Deucher <Alexander.Deucher@amd.com>
    CC: Peter Zijlstra <peterz@infradead.org>
    CC: Tony Cheng <tony.cheng@amd.com>
    CC: Harry Wentland <hwentlan@amd.com>
    Signed-off-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Reviewed-by: Mikita Lipski <Mikita.Lipski@amd.com>
    Acked-by: Qingqing Zhuo <qingqing.zhuo@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 0ea6662a1563..0c7f247bb7de 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -22,10 +22,12 @@
  * Author: AMD
  */
 
+#include <drm/drm_dsc.h>
 #include "dc_hw_types.h"
 #include "dsc.h"
 #include <drm/drm_dp_helper.h>
 #include "dc.h"
+#include "rc_calc.h"
 
 /* This module's internal functions */
 
@@ -304,22 +306,6 @@ static inline uint32_t dsc_div_by_10_round_up(uint32_t value)
 	return (value + 9) / 10;
 }
 
-static inline uint32_t calc_dsc_bpp_x16(uint32_t stream_bandwidth_kbps, uint32_t pix_clk_100hz, uint32_t bpp_increment_div)
-{
-	uint32_t dsc_target_bpp_x16;
-	float f_dsc_target_bpp;
-	float f_stream_bandwidth_100bps = stream_bandwidth_kbps * 10.0f;
-	uint32_t precision = bpp_increment_div; // bpp_increment_div is actually precision
-
-	f_dsc_target_bpp = f_stream_bandwidth_100bps / pix_clk_100hz;
-
-	// Round down to the nearest precision stop to bring it into DSC spec range
-	dsc_target_bpp_x16 = (uint32_t)(f_dsc_target_bpp * precision);
-	dsc_target_bpp_x16 = (dsc_target_bpp_x16 * 16) / precision;
-
-	return dsc_target_bpp_x16;
-}
-
 /* Get DSC bandwidth range based on [min_bpp, max_bpp] target bitrate range, and timing's pixel clock
  * and uncompressed bandwidth.
  */

commit 7837300c250cdda06bf82177fa4f1a512d290ee0
Author: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
Date:   Wed Apr 29 14:41:42 2020 -0400

    drm: Correct DP DSC macro typo
    
    In the file drm_dp_helper.h we have a macro named
    DP_DSC_THROUGHPUT_MODE_{0,1}_UPSUPPORTED, the correct name should be
    DP_DSC_THROUGHPUT_MODE_{0,1}_UNSUPPORTED. This commits adjusts this typo
    in the header file and in other places that attempt to access this
    macro.
    
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200429184142.1867987-1-Rodrigo.Siqueira@amd.com

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 87d682d25278..0ea6662a1563 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -129,7 +129,7 @@ static bool dsc_line_buff_depth_from_dpcd(int dpcd_line_buff_bit_depth, int *lin
 static bool dsc_throughput_from_dpcd(int dpcd_throughput, int *throughput)
 {
 	switch (dpcd_throughput) {
-	case DP_DSC_THROUGHPUT_MODE_0_UPSUPPORTED:
+	case DP_DSC_THROUGHPUT_MODE_0_UNSUPPORTED:
 		*throughput = 0;
 		break;
 	case DP_DSC_THROUGHPUT_MODE_0_170:

commit 07d4f905329438b8e4daf7f58f5afea7d781a9b2
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Jan 7 16:33:32 2020 -0500

    drm/amd/display: Add debug option to disable DSC support
    
    [how]
    Empty dsc enc caps when debug option is set to disable DSC.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 8b78fcbfe746..87d682d25278 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -224,7 +224,8 @@ static void get_dsc_enc_caps(
 
 	memset(dsc_enc_caps, 0, sizeof(struct dsc_enc_caps));
 	if (dsc) {
-		dsc->funcs->dsc_get_enc_caps(dsc_enc_caps, pixel_clock_100Hz);
+		if (!dsc->ctx->dc->debug.disable_dsc)
+			dsc->funcs->dsc_get_enc_caps(dsc_enc_caps, pixel_clock_100Hz);
 		if (dsc->ctx->dc->debug.native422_support)
 			dsc_enc_caps->color_formats.bits.YCBCR_NATIVE_422 = 1;
 	}

commit 2af0f378c4808ee565bd6be10e1e5abf890c1f3a
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Tue Dec 3 17:01:12 2019 -0500

    drm/amd/display: Add debug option to override DSC target bpp increment
    
    [why]
    It's required for debug purposes.
    
    [how]
    Add a dsc_bpp_increment_div debug option that overrides DPCD
    BITS_PER_PIXEL_INCREMENT value. The value dsc_bpp_increment_div should
    be set to is the one after parsing, i.e. it could be 1, 2, 4, 8 or 16
    (meaning 1pix, 1/2pix, ..., 1/16pix).
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 71b048363506..8b78fcbfe746 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -760,7 +760,7 @@ static bool setup_dsc_config(
 	return is_dsc_possible;
 }
 
-bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_basic_data, const uint8_t *dpcd_dsc_ext_data, struct dsc_dec_dpcd_caps *dsc_sink_caps)
+bool dc_dsc_parse_dsc_dpcd(const struct dc *dc, const uint8_t *dpcd_dsc_basic_data, const uint8_t *dpcd_dsc_ext_data, struct dsc_dec_dpcd_caps *dsc_sink_caps)
 {
 	if (!dpcd_dsc_basic_data)
 		return false;
@@ -813,6 +813,23 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_basic_data, const uint8_t *dp
 	if (!dsc_bpp_increment_div_from_dpcd(dpcd_dsc_basic_data[DP_DSC_BITS_PER_PIXEL_INC - DP_DSC_SUPPORT], &dsc_sink_caps->bpp_increment_div))
 		return false;
 
+	if (dc->debug.dsc_bpp_increment_div) {
+		/* dsc_bpp_increment_div should onl be 1, 2, 4, 8 or 16, but rather than rejecting invalid values,
+		 * we'll accept all and get it into range. This also makes the above check against 0 redundant,
+		 * but that one stresses out the override will be only used if it's not 0.
+		 */
+		if (dc->debug.dsc_bpp_increment_div >= 1)
+			dsc_sink_caps->bpp_increment_div = 1;
+		if (dc->debug.dsc_bpp_increment_div >= 2)
+			dsc_sink_caps->bpp_increment_div = 2;
+		if (dc->debug.dsc_bpp_increment_div >= 4)
+			dsc_sink_caps->bpp_increment_div = 4;
+		if (dc->debug.dsc_bpp_increment_div >= 8)
+			dsc_sink_caps->bpp_increment_div = 8;
+		if (dc->debug.dsc_bpp_increment_div >= 16)
+			dsc_sink_caps->bpp_increment_div = 16;
+	}
+
 	/* Extended caps */
 	if (dpcd_dsc_ext_data == NULL) { // Extended DPCD DSC data can be null, e.g. because it doesn't apply to SST
 		dsc_sink_caps->branch_overall_throughput_0_mps = 0;

commit 6026be696193db16006058d8d67fedb7c7e6832d
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Tue Nov 19 18:46:26 2019 -0500

    drm/amd/display: Add interface to adjust DSC max target bpp limit
    
    [Why]
    For some use cases we need to be able to adjust the maximum target bpp
    allowed by DSC policy.
    
    [How]
    New interface dc_dsc_policy_set_max_target_bpp_limit
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index d2423ad1fac2..71b048363506 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -29,6 +29,9 @@
 
 /* This module's internal functions */
 
+/* default DSC policy target bitrate limit is 16bpp */
+static uint32_t dsc_policy_max_target_bpp_limit = 16;
+
 static uint32_t dc_dsc_bandwidth_in_kbps_from_timing(
 	const struct dc_crtc_timing *timing)
 {
@@ -951,7 +954,12 @@ void dc_dsc_get_policy_for_timing(const struct dc_crtc_timing *timing, struct dc
 	default:
 		return;
 	}
-	/* internal upper limit to 16 bpp */
-	if (policy->max_target_bpp > 16)
-		policy->max_target_bpp = 16;
+	/* internal upper limit, default 16 bpp */
+	if (policy->max_target_bpp > dsc_policy_max_target_bpp_limit)
+		policy->max_target_bpp = dsc_policy_max_target_bpp_limit;
+}
+
+void dc_dsc_policy_set_max_target_bpp_limit(uint32_t limit)
+{
+	dsc_policy_max_target_bpp_limit = limit;
 }

commit 799a5f74d11ef7c2e8d86b143d4f1b64793411b6
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Fri Nov 15 11:24:54 2019 -0500

    drm/amd/display: add dsc policy getter
    
    dc needs to expose its internal dsc policy.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index febae6cc7295..d2423ad1fac2 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -27,19 +27,6 @@
 #include <drm/drm_dp_helper.h>
 #include "dc.h"
 
-struct dc_dsc_policy {
-	bool use_min_slices_h;
-	int max_slices_h; // Maximum available if 0
-	int min_sice_height; // Must not be less than 8
-};
-
-const struct dc_dsc_policy dsc_policy = {
-	.use_min_slices_h = true, // DSC Policy: Use minimum number of slices that fits the pixel clock
-	.max_slices_h = 0, // DSC Policy: Use max available slices (in our case 4 for or 8, depending on the mode)
-	.min_sice_height = 108, // DSC Policy: Use slice height recommended by VESA DSC Spreadsheet user guide
-};
-
-
 /* This module's internal functions */
 
 static uint32_t dc_dsc_bandwidth_in_kbps_from_timing(
@@ -370,6 +357,7 @@ static void get_dsc_bandwidth_range(
  *        or if it couldn't be applied based on DSC policy.
  */
 static bool decide_dsc_target_bpp_x16(
+		const struct dc_dsc_policy *policy,
 		const struct dsc_enc_caps *dsc_common_caps,
 		const int target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
@@ -377,13 +365,10 @@ static bool decide_dsc_target_bpp_x16(
 {
 	bool should_use_dsc = false;
 	struct dc_dsc_bw_range range;
-	uint32_t min_target_bpp = 0;
-	uint32_t max_target_bpp = 0;
 
 	memset(&range, 0, sizeof(range));
 
-	dc_dsc_get_bpp_range_for_pixel_encoding(timing->pixel_encoding, &min_target_bpp, &max_target_bpp);
-	get_dsc_bandwidth_range(min_target_bpp, max_target_bpp,
+	get_dsc_bandwidth_range(policy->min_target_bpp, policy->max_target_bpp,
 			dsc_common_caps, timing, &range);
 	if (target_bandwidth_kbps >= range.stream_kbps) {
 		/* enough bandwidth without dsc */
@@ -579,9 +564,11 @@ static bool setup_dsc_config(
 	bool is_dsc_possible = false;
 	int pic_height;
 	int slice_height;
+	struct dc_dsc_policy policy;
 
 	memset(dsc_cfg, 0, sizeof(struct dc_dsc_config));
 
+	dc_dsc_get_policy_for_timing(timing, &policy);
 	pic_width = timing->h_addressable + timing->h_border_left + timing->h_border_right;
 	pic_height = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
 
@@ -597,7 +584,12 @@ static bool setup_dsc_config(
 		goto done;
 
 	if (target_bandwidth_kbps > 0) {
-		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_common_caps, target_bandwidth_kbps, timing, &target_bpp);
+		is_dsc_possible = decide_dsc_target_bpp_x16(
+				&policy,
+				&dsc_common_caps,
+				target_bandwidth_kbps,
+				timing,
+				&target_bpp);
 		dsc_cfg->bits_per_pixel = target_bpp;
 	}
 	if (!is_dsc_possible)
@@ -699,20 +691,20 @@ static bool setup_dsc_config(
 	if (!is_dsc_possible)
 		goto done;
 
-	if (dsc_policy.use_min_slices_h) {
+	if (policy.use_min_slices_h) {
 		if (min_slices_h > 0)
 			num_slices_h = min_slices_h;
 		else if (max_slices_h > 0) { // Fall back to max slices if min slices is not working out
-			if (dsc_policy.max_slices_h)
-				num_slices_h = min(dsc_policy.max_slices_h, max_slices_h);
+			if (policy.max_slices_h)
+				num_slices_h = min(policy.max_slices_h, max_slices_h);
 			else
 				num_slices_h = max_slices_h;
 		} else
 			is_dsc_possible = false;
 	} else {
 		if (max_slices_h > 0) {
-			if (dsc_policy.max_slices_h)
-				num_slices_h = min(dsc_policy.max_slices_h, max_slices_h);
+			if (policy.max_slices_h)
+				num_slices_h = min(policy.max_slices_h, max_slices_h);
 			else
 				num_slices_h = max_slices_h;
 		} else if (min_slices_h > 0) // Fall back to min slices if max slices is not possible
@@ -734,7 +726,7 @@ static bool setup_dsc_config(
 	// Slice height (i.e. number of slices per column): start with policy and pick the first one that height is divisible by.
 	// For 4:2:0 make sure the slice height is divisible by 2 as well.
 	if (min_slice_height_override == 0)
-		slice_height = min(dsc_policy.min_sice_height, pic_height);
+		slice_height = min(policy.min_slice_height, pic_height);
 	else
 		slice_height = min(min_slice_height_override, pic_height);
 
@@ -905,28 +897,61 @@ bool dc_dsc_compute_config(
 	return is_dsc_possible;
 }
 
-bool dc_dsc_get_bpp_range_for_pixel_encoding(enum dc_pixel_encoding pixel_enc,
-		uint32_t *min_bpp,
-		uint32_t *max_bpp)
+void dc_dsc_get_policy_for_timing(const struct dc_crtc_timing *timing, struct dc_dsc_policy *policy)
 {
-	bool result = true;
+	uint32_t bpc = 0;
+
+	policy->min_target_bpp = 0;
+	policy->max_target_bpp = 0;
+
+	/* DSC Policy: Use minimum number of slices that fits the pixel clock */
+	policy->use_min_slices_h = true;
 
-	switch (pixel_enc) {
+	/* DSC Policy: Use max available slices
+	 * (in our case 4 for or 8, depending on the mode)
+	 */
+	policy->max_slices_h = 0;
+
+	/* DSC Policy: Use slice height recommended
+	 * by VESA DSC Spreadsheet user guide
+	 */
+	policy->min_slice_height = 108;
+
+	/* DSC Policy: follow DP specs with an internal upper limit to 16 bpp
+	 * for better interoperability
+	 */
+	switch (timing->display_color_depth) {
+	case COLOR_DEPTH_888:
+		bpc = 8;
+		break;
+	case COLOR_DEPTH_101010:
+		bpc = 10;
+		break;
+	case COLOR_DEPTH_121212:
+		bpc = 12;
+		break;
+	default:
+		return;
+	}
+	switch (timing->pixel_encoding) {
 	case PIXEL_ENCODING_RGB:
 	case PIXEL_ENCODING_YCBCR444:
-	case PIXEL_ENCODING_YCBCR422:
-		*min_bpp = 8;
-		*max_bpp = 16;
+	case PIXEL_ENCODING_YCBCR422: /* assume no YCbCr422 native support */
+		/* DP specs limits to 8 */
+		policy->min_target_bpp = 8;
+		/* DP specs limits to 3 x bpc */
+		policy->max_target_bpp = 3 * bpc;
 		break;
 	case PIXEL_ENCODING_YCBCR420:
-		*min_bpp = 6;
-		*max_bpp = 16;
+		/* DP specs limits to 6 */
+		policy->min_target_bpp = 6;
+		/* DP specs limits to 1.5 x bpc assume bpc is an even number */
+		policy->max_target_bpp = bpc * 3 / 2;
 		break;
 	default:
-		*min_bpp = 0;
-		*max_bpp = 0;
-		result = false;
+		return;
 	}
-
-	return result;
+	/* internal upper limit to 16 bpp */
+	if (policy->max_target_bpp > 16)
+		policy->max_target_bpp = 16;
 }

commit dcd65857a7815ef94735f73d01e0d0d7e1ff2090
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed Nov 13 17:03:37 2019 -0500

    drm/amd/display: add dc dsc functions to return bpp range for pixel encoding
    
    [why]
    Need to support 6 bpp for 420 pixel encoding only.
    
    [how]
    Add a dc function to determine what bpp range can be supported
    for given pixel encoding.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index ec86ba73a039..febae6cc7295 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -31,16 +31,12 @@ struct dc_dsc_policy {
 	bool use_min_slices_h;
 	int max_slices_h; // Maximum available if 0
 	int min_sice_height; // Must not be less than 8
-	int max_target_bpp;
-	int min_target_bpp; // Minimum target bits per pixel
 };
 
 const struct dc_dsc_policy dsc_policy = {
 	.use_min_slices_h = true, // DSC Policy: Use minimum number of slices that fits the pixel clock
 	.max_slices_h = 0, // DSC Policy: Use max available slices (in our case 4 for or 8, depending on the mode)
 	.min_sice_height = 108, // DSC Policy: Use slice height recommended by VESA DSC Spreadsheet user guide
-	.max_target_bpp = 16,
-	.min_target_bpp = 8,
 };
 
 
@@ -374,7 +370,6 @@ static void get_dsc_bandwidth_range(
  *        or if it couldn't be applied based on DSC policy.
  */
 static bool decide_dsc_target_bpp_x16(
-		const struct dc_dsc_policy *policy,
 		const struct dsc_enc_caps *dsc_common_caps,
 		const int target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
@@ -382,10 +377,13 @@ static bool decide_dsc_target_bpp_x16(
 {
 	bool should_use_dsc = false;
 	struct dc_dsc_bw_range range;
+	uint32_t min_target_bpp = 0;
+	uint32_t max_target_bpp = 0;
 
 	memset(&range, 0, sizeof(range));
 
-	get_dsc_bandwidth_range(policy->min_target_bpp, policy->max_target_bpp,
+	dc_dsc_get_bpp_range_for_pixel_encoding(timing->pixel_encoding, &min_target_bpp, &max_target_bpp);
+	get_dsc_bandwidth_range(min_target_bpp, max_target_bpp,
 			dsc_common_caps, timing, &range);
 	if (target_bandwidth_kbps >= range.stream_kbps) {
 		/* enough bandwidth without dsc */
@@ -599,7 +597,7 @@ static bool setup_dsc_config(
 		goto done;
 
 	if (target_bandwidth_kbps > 0) {
-		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_policy, &dsc_common_caps, target_bandwidth_kbps, timing, &target_bpp);
+		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_common_caps, target_bandwidth_kbps, timing, &target_bpp);
 		dsc_cfg->bits_per_pixel = target_bpp;
 	}
 	if (!is_dsc_possible)
@@ -906,3 +904,29 @@ bool dc_dsc_compute_config(
 			timing, dsc_min_slice_height_override, dsc_cfg);
 	return is_dsc_possible;
 }
+
+bool dc_dsc_get_bpp_range_for_pixel_encoding(enum dc_pixel_encoding pixel_enc,
+		uint32_t *min_bpp,
+		uint32_t *max_bpp)
+{
+	bool result = true;
+
+	switch (pixel_enc) {
+	case PIXEL_ENCODING_RGB:
+	case PIXEL_ENCODING_YCBCR444:
+	case PIXEL_ENCODING_YCBCR422:
+		*min_bpp = 8;
+		*max_bpp = 16;
+		break;
+	case PIXEL_ENCODING_YCBCR420:
+		*min_bpp = 6;
+		*max_bpp = 16;
+		break;
+	default:
+		*min_bpp = 0;
+		*max_bpp = 0;
+		result = false;
+	}
+
+	return result;
+}

commit e8cfbdac9a07c4faad60ef9bc82c53079faf4557
Author: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
Date:   Thu Oct 3 17:35:32 2019 -0400

    drm/amd/display: Add DSC 422Native debug option
    
    [Why]
    Need to be able to enable native 422 for debugging purposes.
    
    [How]
    Add new dc_debug_options bool and check it in the get_dsc_enc_caps
    function.
    
    Signed-off-by: Ilya Bakoulin <Ilya.Bakoulin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index dabd3b7a4cdc..ec86ba73a039 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -25,6 +25,7 @@
 #include "dc_hw_types.h"
 #include "dsc.h"
 #include <drm/drm_dp_helper.h>
+#include "dc.h"
 
 struct dc_dsc_policy {
 	bool use_min_slices_h;
@@ -236,8 +237,11 @@ static void get_dsc_enc_caps(
 	// This is a static HW query, so we can use any DSC
 
 	memset(dsc_enc_caps, 0, sizeof(struct dsc_enc_caps));
-	if (dsc)
+	if (dsc) {
 		dsc->funcs->dsc_get_enc_caps(dsc_enc_caps, pixel_clock_100Hz);
+		if (dsc->ctx->dc->debug.native422_support)
+			dsc_enc_caps->color_formats.bits.YCBCR_NATIVE_422 = 1;
+	}
 }
 
 /* Returns 'false' if no intersection was found for at least one capablity.

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index e60f760585e4..dabd3b7a4cdc 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -22,7 +22,6 @@
  * Author: AMD
  */
 
-#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 #include "dc_hw_types.h"
 #include "dsc.h"
 #include <drm/drm_dp_helper.h>
@@ -903,4 +902,3 @@ bool dc_dsc_compute_config(
 			timing, dsc_min_slice_height_override, dsc_cfg);
 	return is_dsc_possible;
 }
-#endif /* CONFIG_DRM_AMD_DC_DSC_SUPPORT */

commit 0417df1699406a8909088152b9bd46e1c2297bbe
Author: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
Date:   Mon Aug 19 15:18:43 2019 -0400

    drm/amd/display: Isolate DSC module from driver dependencies
    
    [Why]
    Edid Utility wishes to include DSC module from driver instead
    of doing it's own logic which will need to be updated every time
    someone modifies the driver logic.
    
    [How]
    Modify some functions such that we dont need to pass the entire
    DC structure as parameter.
    -Remove DC inclusion from module.
    -Filter out problematic types and inclusions
    
    Signed-off-by: Bayan Zabihiyan <bayan.zabihiyan@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 929ebd4cfb8c..e60f760585e4 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -23,8 +23,7 @@
  */
 
 #ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
-#include "dc.h"
-#include "core_types.h"
+#include "dc_hw_types.h"
 #include "dsc.h"
 #include <drm/drm_dp_helper.h>
 
@@ -47,6 +46,59 @@ const struct dc_dsc_policy dsc_policy = {
 
 /* This module's internal functions */
 
+static uint32_t dc_dsc_bandwidth_in_kbps_from_timing(
+	const struct dc_crtc_timing *timing)
+{
+	uint32_t bits_per_channel = 0;
+	uint32_t kbps;
+
+	if (timing->flags.DSC) {
+		kbps = (timing->pix_clk_100hz * timing->dsc_cfg.bits_per_pixel);
+		kbps = kbps / 160 + ((kbps % 160) ? 1 : 0);
+		return kbps;
+	}
+
+	switch (timing->display_color_depth) {
+	case COLOR_DEPTH_666:
+		bits_per_channel = 6;
+		break;
+	case COLOR_DEPTH_888:
+		bits_per_channel = 8;
+		break;
+	case COLOR_DEPTH_101010:
+		bits_per_channel = 10;
+		break;
+	case COLOR_DEPTH_121212:
+		bits_per_channel = 12;
+		break;
+	case COLOR_DEPTH_141414:
+		bits_per_channel = 14;
+		break;
+	case COLOR_DEPTH_161616:
+		bits_per_channel = 16;
+		break;
+	default:
+		break;
+	}
+
+	ASSERT(bits_per_channel != 0);
+
+	kbps = timing->pix_clk_100hz / 10;
+	kbps *= bits_per_channel;
+
+	if (timing->flags.Y_ONLY != 1) {
+		/*Only YOnly make reduce bandwidth by 1/3 compares to RGB*/
+		kbps *= 3;
+		if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
+			kbps /= 2;
+		else if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)
+			kbps = kbps * 2 / 3;
+	}
+
+	return kbps;
+
+}
+
 static bool dsc_buff_block_size_from_dpcd(int dpcd_buff_block_size, int *buff_block_size)
 {
 
@@ -178,12 +230,11 @@ static bool dsc_bpp_increment_div_from_dpcd(int bpp_increment_dpcd, uint32_t *bp
 }
 
 static void get_dsc_enc_caps(
-	const struct dc *dc,
+	const struct display_stream_compressor *dsc,
 	struct dsc_enc_caps *dsc_enc_caps,
 	int pixel_clock_100Hz)
 {
 	// This is a static HW query, so we can use any DSC
-	struct display_stream_compressor *dsc = dc->res_pool->dscs[0];
 
 	memset(dsc_enc_caps, 0, sizeof(struct dsc_enc_caps));
 	if (dsc)
@@ -290,7 +341,7 @@ static void get_dsc_bandwidth_range(
 		struct dc_dsc_bw_range *range)
 {
 	/* native stream bandwidth */
-	range->stream_kbps = dc_bandwidth_in_kbps_from_timing(timing);
+	range->stream_kbps = dc_dsc_bandwidth_in_kbps_from_timing(timing);
 
 	/* max dsc target bpp */
 	range->max_kbps = dsc_div_by_10_round_up(max_bpp * timing->pix_clk_100hz);
@@ -806,7 +857,8 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_basic_data, const uint8_t *dp
  * If DSC is not possible, leave '*range' untouched.
  */
 bool dc_dsc_compute_bandwidth_range(
-		const struct dc *dc,
+		const struct display_stream_compressor *dsc,
+		const uint32_t dsc_min_slice_height_override,
 		const uint32_t min_bpp,
 		const uint32_t max_bpp,
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
@@ -818,14 +870,14 @@ bool dc_dsc_compute_bandwidth_range(
 	struct dsc_enc_caps dsc_common_caps;
 	struct dc_dsc_config config;
 
-	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
+	get_dsc_enc_caps(dsc, &dsc_enc_caps, timing->pix_clk_100hz);
 
 	is_dsc_possible = intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps,
 			timing->pixel_encoding, &dsc_common_caps);
 
 	if (is_dsc_possible)
 		is_dsc_possible = setup_dsc_config(dsc_sink_caps, &dsc_enc_caps, 0, timing,
-					dc->debug.dsc_min_slice_height_override, &config);
+				dsc_min_slice_height_override, &config);
 
 	if (is_dsc_possible)
 		get_dsc_bandwidth_range(min_bpp, max_bpp, &dsc_common_caps, timing, range);
@@ -834,8 +886,9 @@ bool dc_dsc_compute_bandwidth_range(
 }
 
 bool dc_dsc_compute_config(
-		const struct dc *dc,
+		const struct display_stream_compressor *dsc,
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
+		const uint32_t dsc_min_slice_height_override,
 		uint32_t target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_config *dsc_cfg)
@@ -843,11 +896,11 @@ bool dc_dsc_compute_config(
 	bool is_dsc_possible = false;
 	struct dsc_enc_caps dsc_enc_caps;
 
-	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
+	get_dsc_enc_caps(dsc, &dsc_enc_caps, timing->pix_clk_100hz);
 	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
 			&dsc_enc_caps,
 			target_bandwidth_kbps,
-			timing, dc->debug.dsc_min_slice_height_override, dsc_cfg);
+			timing, dsc_min_slice_height_override, dsc_cfg);
 	return is_dsc_possible;
 }
 #endif /* CONFIG_DRM_AMD_DC_DSC_SUPPORT */

commit b5cf0647c2a83711907f0c6cdede72a397252639
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Fri Aug 16 14:26:56 2019 -0400

    drm/amd/display: config to override DSC start slice height
    
    [why]
    It's sometimes useful to have this option when debugging
    
    [how]
    Add a config flag. If the flag is not set, use driver default policy.
    If the flag is set, use the value from the flag as the starting DSC slice
    height.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Martin Leung <Martin.Leung@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 5995bcdfed54..929ebd4cfb8c 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -512,6 +512,7 @@ static bool setup_dsc_config(
 		const struct dsc_enc_caps *dsc_enc_caps,
 		int target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
+		int min_slice_height_override,
 		struct dc_dsc_config *dsc_cfg)
 {
 	struct dsc_enc_caps dsc_common_caps;
@@ -680,7 +681,10 @@ static bool setup_dsc_config(
 
 	// Slice height (i.e. number of slices per column): start with policy and pick the first one that height is divisible by.
 	// For 4:2:0 make sure the slice height is divisible by 2 as well.
-	slice_height = min(dsc_policy.min_sice_height, pic_height);
+	if (min_slice_height_override == 0)
+		slice_height = min(dsc_policy.min_sice_height, pic_height);
+	else
+		slice_height = min(min_slice_height_override, pic_height);
 
 	while (slice_height < pic_height && (pic_height % slice_height != 0 ||
 		(timing->pixel_encoding == PIXEL_ENCODING_YCBCR420 && slice_height % 2 != 0)))
@@ -820,10 +824,8 @@ bool dc_dsc_compute_bandwidth_range(
 			timing->pixel_encoding, &dsc_common_caps);
 
 	if (is_dsc_possible)
-		is_dsc_possible = setup_dsc_config(dsc_sink_caps,
-				&dsc_enc_caps,
-				0,
-				timing, &config);
+		is_dsc_possible = setup_dsc_config(dsc_sink_caps, &dsc_enc_caps, 0, timing,
+					dc->debug.dsc_min_slice_height_override, &config);
 
 	if (is_dsc_possible)
 		get_dsc_bandwidth_range(min_bpp, max_bpp, &dsc_common_caps, timing, range);
@@ -845,7 +847,7 @@ bool dc_dsc_compute_config(
 	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
 			&dsc_enc_caps,
 			target_bandwidth_kbps,
-			timing, dsc_cfg);
+			timing, dc->debug.dsc_min_slice_height_override, dsc_cfg);
 	return is_dsc_possible;
 }
 #endif /* CONFIG_DRM_AMD_DC_DSC_SUPPORT */

commit 7470673340b118b744e629383e8374ced4100b84
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Jul 18 19:13:26 2019 -0400

    drm/amd/display: Change DSC policy from slices per column to minimum slice height
    
    [why] Minimum slice height is recommended by VESA DSC Spreadsheet user guide
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index ef5f84a144c3..5995bcdfed54 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -28,6 +28,23 @@
 #include "dsc.h"
 #include <drm/drm_dp_helper.h>
 
+struct dc_dsc_policy {
+	bool use_min_slices_h;
+	int max_slices_h; // Maximum available if 0
+	int min_sice_height; // Must not be less than 8
+	int max_target_bpp;
+	int min_target_bpp; // Minimum target bits per pixel
+};
+
+const struct dc_dsc_policy dsc_policy = {
+	.use_min_slices_h = true, // DSC Policy: Use minimum number of slices that fits the pixel clock
+	.max_slices_h = 0, // DSC Policy: Use max available slices (in our case 4 for or 8, depending on the mode)
+	.min_sice_height = 108, // DSC Policy: Use slice height recommended by VESA DSC Spreadsheet user guide
+	.max_target_bpp = 16,
+	.min_target_bpp = 8,
+};
+
+
 /* This module's internal functions */
 
 static bool dsc_buff_block_size_from_dpcd(int dpcd_buff_block_size, int *buff_block_size)
@@ -241,14 +258,6 @@ static bool intersect_dsc_caps(
 	return true;
 }
 
-struct dc_dsc_policy {
-	bool use_min_slices_h;
-	int max_slices_h; // Maximum available if 0
-	int num_slices_v;
-	int max_target_bpp;
-	int min_target_bpp; // Minimum target bits per pixel
-};
-
 static inline uint32_t dsc_div_by_10_round_up(uint32_t value)
 {
 	return (value + 9) / 10;
@@ -270,19 +279,6 @@ static inline uint32_t calc_dsc_bpp_x16(uint32_t stream_bandwidth_kbps, uint32_t
 	return dsc_target_bpp_x16;
 }
 
-const struct dc_dsc_policy dsc_policy = {
-	.use_min_slices_h = true, // DSC Policy: Use minimum number of slices that fits the pixel clock
-	.max_slices_h = 0, // DSC Policy: Use max available slices (in our case 4 for or 8, depending on the mode)
-	/* DSC Policy: Number of vertical slices set to 2 for no particular reason.
-	 * Seems small enough to not affect the quality too much, while still providing some error
-	 * propagation control (which may also help debugging).
-	 */
-	.num_slices_v = 16,
-	.max_target_bpp = 16,
-	.min_target_bpp = 8,
-};
-
-
 /* Get DSC bandwidth range based on [min_bpp, max_bpp] target bitrate range, and timing's pixel clock
  * and uncompressed bandwidth.
  */
@@ -528,8 +524,8 @@ static bool setup_dsc_config(
 	int sink_per_slice_throughput_mps;
 	int branch_max_throughput_mps = 0;
 	bool is_dsc_possible = false;
-	int num_slices_v;
 	int pic_height;
+	int slice_height;
 
 	memset(dsc_cfg, 0, sizeof(struct dc_dsc_config));
 
@@ -615,7 +611,7 @@ static bool setup_dsc_config(
 	if (!is_dsc_possible)
 		goto done;
 
-	// DSC slicing
+	// Slice width (i.e. number of slices per line)
 	max_slices_h = get_max_dsc_slices(dsc_common_caps.slice_caps);
 
 	while (max_slices_h > 0) {
@@ -678,29 +674,26 @@ static bool setup_dsc_config(
 	dsc_cfg->num_slices_h = num_slices_h;
 	slice_width = pic_width / num_slices_h;
 
-	// Vertical number of slices: start from policy and pick the first one that height is divisible by.
+	is_dsc_possible = slice_width <= dsc_common_caps.max_slice_width;
+	if (!is_dsc_possible)
+		goto done;
+
+	// Slice height (i.e. number of slices per column): start with policy and pick the first one that height is divisible by.
 	// For 4:2:0 make sure the slice height is divisible by 2 as well.
-	num_slices_v = dsc_policy.num_slices_v;
-	if (num_slices_v < 1)
-		num_slices_v = 1;
-
-	while (num_slices_v >= 1) {
-		if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) {
-			int slice_height = pic_height / num_slices_v;
-			if (pic_height % num_slices_v == 0 && slice_height % 2 == 0)
-				break;
-		} else if (pic_height % num_slices_v == 0)
-			break;
+	slice_height = min(dsc_policy.min_sice_height, pic_height);
 
-		num_slices_v--;
-	}
+	while (slice_height < pic_height && (pic_height % slice_height != 0 ||
+		(timing->pixel_encoding == PIXEL_ENCODING_YCBCR420 && slice_height % 2 != 0)))
+		slice_height++;
 
-	dsc_cfg->num_slices_v = num_slices_v;
+	if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) // For the case when pic_height < dsc_policy.min_sice_height
+		is_dsc_possible = (slice_height % 2 == 0);
 
-	is_dsc_possible = slice_width <= dsc_common_caps.max_slice_width;
 	if (!is_dsc_possible)
 		goto done;
 
+	dsc_cfg->num_slices_v = pic_height/slice_height;
+
 	// Final decission: can we do DSC or not?
 	if (is_dsc_possible) {
 		// Fill out the rest of DSC settings

commit 440e80ce02cde7b810e4eb555768c2d77e7a27c8
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jun 26 14:24:27 2019 +0100

    drm/amd/display: fix a couple of spelling mistakes
    
    There are a couple of spelling mistakes in dm_error messages and
    a comment. Fix these.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 77e7a0f8a527..ef5f84a144c3 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -47,7 +47,7 @@ static bool dsc_buff_block_size_from_dpcd(int dpcd_buff_block_size, int *buff_bl
 		*buff_block_size = 64 * 1024;
 		break;
 	default: {
-			dm_error("%s: DPCD DSC buffer size not recoginzed.\n", __func__);
+			dm_error("%s: DPCD DSC buffer size not recognized.\n", __func__);
 			return false;
 		}
 	}
@@ -63,7 +63,7 @@ static bool dsc_line_buff_depth_from_dpcd(int dpcd_line_buff_bit_depth, int *lin
 	else if (dpcd_line_buff_bit_depth == 8)
 		*line_buff_bit_depth = 8;
 	else {
-		dm_error("%s: DPCD DSC buffer depth not recoginzed.\n", __func__);
+		dm_error("%s: DPCD DSC buffer depth not recognized.\n", __func__);
 		return false;
 	}
 
@@ -123,7 +123,7 @@ static bool dsc_throughput_from_dpcd(int dpcd_throughput, int *throughput)
 		*throughput = 1000;
 		break;
 	default: {
-			dm_error("%s: DPCD DSC througput mode not recoginzed.\n", __func__);
+			dm_error("%s: DPCD DSC throughput mode not recognized.\n", __func__);
 			return false;
 		}
 	}
@@ -152,7 +152,7 @@ static bool dsc_bpp_increment_div_from_dpcd(int bpp_increment_dpcd, uint32_t *bp
 		*bpp_increment_div = 1;
 		break;
 	default: {
-		dm_error("%s: DPCD DSC bits-per-pixel increment not recoginzed.\n", __func__);
+		dm_error("%s: DPCD DSC bits-per-pixel increment not recognized.\n", __func__);
 		return false;
 	}
 	}

commit e710fdb134ad4c08ae2cabc6731fba6fb72fa0b8
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Wed May 22 11:50:20 2019 -0400

    drm/amd/display: update dsc max_target_bpp to 16 bpp
    
    [why]
    According to the latest specs, the max_target bpp sink
    can support is 16 bpp.
    
    [how]
    update dsc max_target_bpp to 16
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 96b18bb3b1cc..77e7a0f8a527 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -242,9 +242,6 @@ static bool intersect_dsc_caps(
 }
 
 struct dc_dsc_policy {
-	float max_compression_ratio_legacy;
-	float sst_compression_legacy; // Maximum quality if 0.0
-	float mst_compression_legacy;
 	bool use_min_slices_h;
 	int max_slices_h; // Maximum available if 0
 	int num_slices_v;
@@ -274,18 +271,14 @@ static inline uint32_t calc_dsc_bpp_x16(uint32_t stream_bandwidth_kbps, uint32_t
 }
 
 const struct dc_dsc_policy dsc_policy = {
-	.max_compression_ratio_legacy = 3.0f, // DSC Policy: Limit compression to 3:1 at most in all cases
-	.sst_compression_legacy = 0.0f, // DSC Policy: SST - Maximum quality (0.0)
-	.mst_compression_legacy = 3.0f, // DSC Policy: MST - always 3:1 compression
 	.use_min_slices_h = true, // DSC Policy: Use minimum number of slices that fits the pixel clock
 	.max_slices_h = 0, // DSC Policy: Use max available slices (in our case 4 for or 8, depending on the mode)
-
 	/* DSC Policy: Number of vertical slices set to 2 for no particular reason.
 	 * Seems small enough to not affect the quality too much, while still providing some error
 	 * propagation control (which may also help debugging).
 	 */
 	.num_slices_v = 16,
-	.max_target_bpp = 24,
+	.max_target_bpp = 16,
 	.min_target_bpp = 8,
 };
 

commit 39a4eb853f9ac85e9b042874ef5fa12c8e20e440
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Thu May 16 13:01:51 2019 -0400

    drm/amd/display: update DSC MST DP virtual DPCD peer device enumeration policy
    
    [why]
    Current policy assumes virtual DPCD peer device as
    an individual MST branch device with 1 input and 1 output.
    However this is only true for virtual DP-to-DP peer device.
    In general there are three types of virtual DP peer devices.
    1. Sink peer device with virtual DPCD.
    2. Virtual DP-to-DP Peer device with virtual DPCD.
    3. Virtual DP-to-HDMI Protocol Converter Peer Device with
    Virtual DPCD.
    So we should break the assumption and handle all three types.
    
    [how]
    DP-to-DP peer device will have virtual DPCD cap upstream.
    Sink peer device will have virtual DPCD on the logical port.
    Dp to HDMI protocol converter peer device will have virtual DPCD
    on its converter port.
    For DSC capable Synaptics non VGA port we workaround by enumerating
    a virutal DPCD peer device on its upstream
    even if it doesn't have one.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 252c3d0a2555..96b18bb3b1cc 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -725,9 +725,12 @@ static bool setup_dsc_config(
 
 bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_basic_data, const uint8_t *dpcd_dsc_ext_data, struct dsc_dec_dpcd_caps *dsc_sink_caps)
 {
+	if (!dpcd_dsc_basic_data)
+		return false;
+
 	dsc_sink_caps->is_dsc_supported = (dpcd_dsc_basic_data[DP_DSC_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_DECOMPRESSION_IS_SUPPORTED) != 0;
 	if (!dsc_sink_caps->is_dsc_supported)
-		return true;
+		return false;
 
 	dsc_sink_caps->dsc_version = dpcd_dsc_basic_data[DP_DSC_REV - DP_DSC_SUPPORT];
 

commit cba4d59c936cd17ac601c188725ccd779467a509
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Thu Apr 25 12:11:50 2019 -0400

    drm/amd/display: fix a potential issue in DSC logic
    
    [why]
    In compute dsc bandwidth range there is an uninitialized variable
    
    [how]
    Initialize the variable to the correct value.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 94a623dc37f4..252c3d0a2555 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -826,10 +826,16 @@ bool dc_dsc_compute_bandwidth_range(
 	struct dc_dsc_config config;
 
 	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
-	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
-			&dsc_enc_caps,
-			0,
-			timing, &config);
+
+	is_dsc_possible = intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps,
+			timing->pixel_encoding, &dsc_common_caps);
+
+	if (is_dsc_possible)
+		is_dsc_possible = setup_dsc_config(dsc_sink_caps,
+				&dsc_enc_caps,
+				0,
+				timing, &config);
+
 	if (is_dsc_possible)
 		get_dsc_bandwidth_range(min_bpp, max_bpp, &dsc_common_caps, timing, range);
 

commit f446489adcbc9c4833ae724a985166731c577bcd
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Wed Apr 17 19:07:08 2019 -0400

    drm/amd/display: Add support for extended DSC DPCD caps
    
    [why]
    A few of the new DSC DPCD caps were introduced by a DP 1.4a SCR in order
    to give DSC branch decoders a chance to expose their maximum throughput
    and maximum line width limitations.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index f09f23707a94..94a623dc37f4 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -252,7 +252,7 @@ struct dc_dsc_policy {
 	int min_target_bpp; // Minimum target bits per pixel
 };
 
-static inline uint32_t dsc_round_up(uint32_t value)
+static inline uint32_t dsc_div_by_10_round_up(uint32_t value)
 {
 	return (value + 9) / 10;
 }
@@ -304,7 +304,7 @@ static void get_dsc_bandwidth_range(
 	range->stream_kbps = dc_bandwidth_in_kbps_from_timing(timing);
 
 	/* max dsc target bpp */
-	range->max_kbps = dsc_round_up(max_bpp * timing->pix_clk_100hz);
+	range->max_kbps = dsc_div_by_10_round_up(max_bpp * timing->pix_clk_100hz);
 	range->max_target_bpp_x16 = max_bpp * 16;
 	if (range->max_kbps > range->stream_kbps) {
 		/* max dsc target bpp is capped to native bandwidth */
@@ -313,7 +313,7 @@ static void get_dsc_bandwidth_range(
 	}
 
 	/* min dsc target bpp */
-	range->min_kbps = dsc_round_up(min_bpp * timing->pix_clk_100hz);
+	range->min_kbps = dsc_div_by_10_round_up(min_bpp * timing->pix_clk_100hz);
 	range->min_target_bpp_x16 = min_bpp * 16;
 	if (range->min_kbps > range->max_kbps) {
 		/* min dsc target bpp is capped to max dsc bandwidth*/
@@ -532,16 +532,23 @@ static bool setup_dsc_config(
 	int pic_width;
 	int slice_width;
 	int target_bpp;
-	int sink_per_slice_throughput;
+	int sink_per_slice_throughput_mps;
+	int branch_max_throughput_mps = 0;
 	bool is_dsc_possible = false;
 	int num_slices_v;
 	int pic_height;
 
 	memset(dsc_cfg, 0, sizeof(struct dc_dsc_config));
 
+	pic_width = timing->h_addressable + timing->h_border_left + timing->h_border_right;
+	pic_height = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
+
 	if (!dsc_sink_caps->is_dsc_supported)
 		goto done;
 
+	if (dsc_sink_caps->branch_max_line_width && dsc_sink_caps->branch_max_line_width < pic_width)
+		goto done;
+
 	// Intersect decoder with encoder DSC caps and validate DSC settings
 	is_dsc_possible = intersect_dsc_caps(dsc_sink_caps, dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
 	if (!is_dsc_possible)
@@ -554,39 +561,46 @@ static bool setup_dsc_config(
 	if (!is_dsc_possible)
 		goto done;
 
-	sink_per_slice_throughput = 0;
+	sink_per_slice_throughput_mps = 0;
 
 	// Validate available DSC settings against the mode timing
 
-	// Color format
+	// Validate color format (and pick up the throughput values)
 	dsc_cfg->ycbcr422_simple = false;
 	switch (timing->pixel_encoding)	{
 	case PIXEL_ENCODING_RGB:
 		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.RGB;
-		sink_per_slice_throughput = dsc_sink_caps->throughput_mode_0_mps;
+		sink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_0_mps;
+		branch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_0_mps;
 		break;
 	case PIXEL_ENCODING_YCBCR444:
 		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_444;
-		sink_per_slice_throughput = dsc_sink_caps->throughput_mode_0_mps;
-		break;
-	case PIXEL_ENCODING_YCBCR422: {
-			is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_422;
-			sink_per_slice_throughput = dsc_sink_caps->throughput_mode_1_mps;
-			if (!is_dsc_possible) {
-				is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_SIMPLE_422;
-				dsc_cfg->ycbcr422_simple = is_dsc_possible;
-				sink_per_slice_throughput = dsc_sink_caps->throughput_mode_0_mps;
-			}
+		sink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_0_mps;
+		branch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_0_mps;
+		break;
+	case PIXEL_ENCODING_YCBCR422:
+		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_422;
+		sink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_1_mps;
+		branch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_1_mps;
+		if (!is_dsc_possible) {
+			is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_SIMPLE_422;
+			dsc_cfg->ycbcr422_simple = is_dsc_possible;
+			sink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_0_mps;
 		}
 		break;
 	case PIXEL_ENCODING_YCBCR420:
 		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_420;
-		sink_per_slice_throughput = dsc_sink_caps->throughput_mode_1_mps;
+		sink_per_slice_throughput_mps = dsc_sink_caps->throughput_mode_1_mps;
+		branch_max_throughput_mps = dsc_sink_caps->branch_overall_throughput_1_mps;
 		break;
 	default:
 		is_dsc_possible = false;
 	}
 
+	// Validate branch's maximum throughput
+	if (branch_max_throughput_mps && dsc_div_by_10_round_up(timing->pix_clk_100hz) > branch_max_throughput_mps * 1000)
+		is_dsc_possible = false;
+
 	if (!is_dsc_possible)
 		goto done;
 
@@ -611,7 +625,6 @@ static bool setup_dsc_config(
 	// DSC slicing
 	max_slices_h = get_max_dsc_slices(dsc_common_caps.slice_caps);
 
-	pic_width = timing->h_addressable + timing->h_border_left + timing->h_border_right;
 	while (max_slices_h > 0) {
 		if (pic_width % max_slices_h == 0)
 			break;
@@ -630,7 +643,8 @@ static bool setup_dsc_config(
 	min_slices_h = fit_num_slices_up(dsc_common_caps.slice_caps, min_slices_h);
 
 	while (min_slices_h <= max_slices_h) {
-		if (dsc_round_up(timing->pix_clk_100hz) / (min_slices_h) <= sink_per_slice_throughput * 1000)
+		int pix_clk_per_slice_khz = dsc_div_by_10_round_up(timing->pix_clk_100hz) / min_slices_h;
+		if (pix_clk_per_slice_khz <= sink_per_slice_throughput_mps * 1000)
 			break;
 
 		min_slices_h = inc_num_slices(dsc_common_caps.slice_caps, min_slices_h);
@@ -673,7 +687,6 @@ static bool setup_dsc_config(
 
 	// Vertical number of slices: start from policy and pick the first one that height is divisible by.
 	// For 4:2:0 make sure the slice height is divisible by 2 as well.
-	pic_height = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
 	num_slices_v = dsc_policy.num_slices_v;
 	if (num_slices_v < 1)
 		num_slices_v = 1;
@@ -710,41 +723,41 @@ static bool setup_dsc_config(
 	return is_dsc_possible;
 }
 
-bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data, struct dsc_dec_dpcd_caps *dsc_sink_caps)
+bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_basic_data, const uint8_t *dpcd_dsc_ext_data, struct dsc_dec_dpcd_caps *dsc_sink_caps)
 {
-	dsc_sink_caps->is_dsc_supported = (dpcd_dsc_data[DP_DSC_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_DECOMPRESSION_IS_SUPPORTED) != 0;
+	dsc_sink_caps->is_dsc_supported = (dpcd_dsc_basic_data[DP_DSC_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_DECOMPRESSION_IS_SUPPORTED) != 0;
 	if (!dsc_sink_caps->is_dsc_supported)
 		return true;
 
-	dsc_sink_caps->dsc_version = dpcd_dsc_data[DP_DSC_REV - DP_DSC_SUPPORT];
+	dsc_sink_caps->dsc_version = dpcd_dsc_basic_data[DP_DSC_REV - DP_DSC_SUPPORT];
 
 	{
 		int buff_block_size;
 		int buff_size;
 
-		if (!dsc_buff_block_size_from_dpcd(dpcd_dsc_data[DP_DSC_RC_BUF_BLK_SIZE - DP_DSC_SUPPORT], &buff_block_size))
+		if (!dsc_buff_block_size_from_dpcd(dpcd_dsc_basic_data[DP_DSC_RC_BUF_BLK_SIZE - DP_DSC_SUPPORT], &buff_block_size))
 			return false;
 
-		buff_size = dpcd_dsc_data[DP_DSC_RC_BUF_SIZE - DP_DSC_SUPPORT] + 1;
+		buff_size = dpcd_dsc_basic_data[DP_DSC_RC_BUF_SIZE - DP_DSC_SUPPORT] + 1;
 		dsc_sink_caps->rc_buffer_size = buff_size * buff_block_size;
 	}
 
-	dsc_sink_caps->slice_caps1.raw = dpcd_dsc_data[DP_DSC_SLICE_CAP_1 - DP_DSC_SUPPORT];
-	if (!dsc_line_buff_depth_from_dpcd(dpcd_dsc_data[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT], &dsc_sink_caps->lb_bit_depth))
+	dsc_sink_caps->slice_caps1.raw = dpcd_dsc_basic_data[DP_DSC_SLICE_CAP_1 - DP_DSC_SUPPORT];
+	if (!dsc_line_buff_depth_from_dpcd(dpcd_dsc_basic_data[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT], &dsc_sink_caps->lb_bit_depth))
 		return false;
 
 	dsc_sink_caps->is_block_pred_supported =
-		(dpcd_dsc_data[DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_BLK_PREDICTION_IS_SUPPORTED) != 0;
+		(dpcd_dsc_basic_data[DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_BLK_PREDICTION_IS_SUPPORTED) != 0;
 
 	dsc_sink_caps->edp_max_bits_per_pixel =
-		dpcd_dsc_data[DP_DSC_MAX_BITS_PER_PIXEL_LOW - DP_DSC_SUPPORT] |
-		dpcd_dsc_data[DP_DSC_MAX_BITS_PER_PIXEL_HI - DP_DSC_SUPPORT] << 8;
+		dpcd_dsc_basic_data[DP_DSC_MAX_BITS_PER_PIXEL_LOW - DP_DSC_SUPPORT] |
+		dpcd_dsc_basic_data[DP_DSC_MAX_BITS_PER_PIXEL_HI - DP_DSC_SUPPORT] << 8;
 
-	dsc_sink_caps->color_formats.raw = dpcd_dsc_data[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT];
-	dsc_sink_caps->color_depth.raw = dpcd_dsc_data[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];
+	dsc_sink_caps->color_formats.raw = dpcd_dsc_basic_data[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT];
+	dsc_sink_caps->color_depth.raw = dpcd_dsc_basic_data[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];
 
 	{
-		int dpcd_throughput = dpcd_dsc_data[DP_DSC_PEAK_THROUGHPUT - DP_DSC_SUPPORT];
+		int dpcd_throughput = dpcd_dsc_basic_data[DP_DSC_PEAK_THROUGHPUT - DP_DSC_SUPPORT];
 
 		if (!dsc_throughput_from_dpcd(dpcd_throughput & DP_DSC_THROUGHPUT_MODE_0_MASK, &dsc_sink_caps->throughput_mode_0_mps))
 			return false;
@@ -754,12 +767,43 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data, struct dsc_dec_dpcd_cap
 			return false;
 	}
 
-	dsc_sink_caps->max_slice_width = dpcd_dsc_data[DP_DSC_MAX_SLICE_WIDTH - DP_DSC_SUPPORT] * 320;
-	dsc_sink_caps->slice_caps2.raw = dpcd_dsc_data[DP_DSC_SLICE_CAP_2 - DP_DSC_SUPPORT];
+	dsc_sink_caps->max_slice_width = dpcd_dsc_basic_data[DP_DSC_MAX_SLICE_WIDTH - DP_DSC_SUPPORT] * 320;
+	dsc_sink_caps->slice_caps2.raw = dpcd_dsc_basic_data[DP_DSC_SLICE_CAP_2 - DP_DSC_SUPPORT];
 
-	if (!dsc_bpp_increment_div_from_dpcd(dpcd_dsc_data[DP_DSC_BITS_PER_PIXEL_INC - DP_DSC_SUPPORT], &dsc_sink_caps->bpp_increment_div))
+	if (!dsc_bpp_increment_div_from_dpcd(dpcd_dsc_basic_data[DP_DSC_BITS_PER_PIXEL_INC - DP_DSC_SUPPORT], &dsc_sink_caps->bpp_increment_div))
 		return false;
 
+	/* Extended caps */
+	if (dpcd_dsc_ext_data == NULL) { // Extended DPCD DSC data can be null, e.g. because it doesn't apply to SST
+		dsc_sink_caps->branch_overall_throughput_0_mps = 0;
+		dsc_sink_caps->branch_overall_throughput_1_mps = 0;
+		dsc_sink_caps->branch_max_line_width = 0;
+		return true;
+	}
+
+	dsc_sink_caps->branch_overall_throughput_0_mps = dpcd_dsc_ext_data[DP_DSC_BRANCH_OVERALL_THROUGHPUT_0 - DP_DSC_BRANCH_OVERALL_THROUGHPUT_0];
+	if (dsc_sink_caps->branch_overall_throughput_0_mps == 0)
+		dsc_sink_caps->branch_overall_throughput_0_mps = 0;
+	else if (dsc_sink_caps->branch_overall_throughput_0_mps == 1)
+		dsc_sink_caps->branch_overall_throughput_0_mps = 680;
+	else {
+		dsc_sink_caps->branch_overall_throughput_0_mps *= 50;
+		dsc_sink_caps->branch_overall_throughput_0_mps += 600;
+	}
+
+	dsc_sink_caps->branch_overall_throughput_1_mps = dpcd_dsc_ext_data[DP_DSC_BRANCH_OVERALL_THROUGHPUT_1 - DP_DSC_BRANCH_OVERALL_THROUGHPUT_0];
+	if (dsc_sink_caps->branch_overall_throughput_1_mps == 0)
+		dsc_sink_caps->branch_overall_throughput_1_mps = 0;
+	else if (dsc_sink_caps->branch_overall_throughput_1_mps == 1)
+		dsc_sink_caps->branch_overall_throughput_1_mps = 680;
+	else {
+		dsc_sink_caps->branch_overall_throughput_1_mps *= 50;
+		dsc_sink_caps->branch_overall_throughput_1_mps += 600;
+	}
+
+	dsc_sink_caps->branch_max_line_width = dpcd_dsc_ext_data[DP_DSC_BRANCH_MAX_LINE_WIDTH - DP_DSC_BRANCH_OVERALL_THROUGHPUT_0] * 320;
+	ASSERT(dsc_sink_caps->branch_max_line_width == 0 || dsc_sink_caps->branch_max_line_width >= 5120);
+
 	return true;
 }
 

commit d7cd0e053b17dfa0dd4669dfb388c100be272823
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Mon Apr 15 17:31:44 2019 -0400

    drm/amd/display: Add 170Mpix/sec DSC throughput support
    
    [why]
    It was missing, although defined in DP spec
    
    [how]
    - Add handling of this value to DSC code
    - Also remove unused file dsc_helpers.c
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Joshua Aberback <Joshua.Aberback@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index d58d718171b5..f09f23707a94 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -74,6 +74,12 @@ static bool dsc_line_buff_depth_from_dpcd(int dpcd_line_buff_bit_depth, int *lin
 static bool dsc_throughput_from_dpcd(int dpcd_throughput, int *throughput)
 {
 	switch (dpcd_throughput) {
+	case DP_DSC_THROUGHPUT_MODE_0_UPSUPPORTED:
+		*throughput = 0;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_170:
+		*throughput = 170;
+		break;
 	case DP_DSC_THROUGHPUT_MODE_0_340:
 		*throughput = 340;
 		break;
@@ -170,7 +176,7 @@ static void get_dsc_enc_caps(
 /* Returns 'false' if no intersection was found for at least one capablity.
  * It also implicitly validates some sink caps against invalid value of zero.
  */
-static bool dc_intersect_dsc_caps(
+static bool intersect_dsc_caps(
 	const struct dsc_dec_dpcd_caps *dsc_sink_caps,
 	const struct dsc_enc_caps *dsc_enc_caps,
 	enum dc_pixel_encoding pixel_encoding,
@@ -537,7 +543,7 @@ static bool setup_dsc_config(
 		goto done;
 
 	// Intersect decoder with encoder DSC caps and validate DSC settings
-	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
+	is_dsc_possible = intersect_dsc_caps(dsc_sink_caps, dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
 	if (!is_dsc_possible)
 		goto done;
 

commit 9c0ab2dd070db6282c27690e7b57976485055ff7
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Fri Apr 5 15:02:18 2019 -0400

    drm/amd/display: Consider DSC target bpp precision when calculating DSC target bpp
    
    [why]
    DSC target bpp precision is a decoder DPCD and an AMD encoder capability.
    It must be taken into account when calculating target bitrate.
    
    [how]
    Add a DC DSC function that does this calculation.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Acked-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index d15da6f906e8..d58d718171b5 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -283,6 +283,10 @@ const struct dc_dsc_policy dsc_policy = {
 	.min_target_bpp = 8,
 };
 
+
+/* Get DSC bandwidth range based on [min_bpp, max_bpp] target bitrate range, and timing's pixel clock
+ * and uncompressed bandwidth.
+ */
 static void get_dsc_bandwidth_range(
 		const uint32_t min_bpp,
 		const uint32_t max_bpp,
@@ -312,6 +316,7 @@ static void get_dsc_bandwidth_range(
 	}
 }
 
+
 /* Decides if DSC should be used and calculates target bpp if it should, applying DSC policy.
  *
  * Returns:
@@ -494,10 +499,10 @@ static int fit_num_slices_up(union dsc_enc_slice_caps slice_caps, int num_slices
  *
  * dsc_enc_caps        - DSC encoder capabilities
  *
- * target_bandwidth    - Target bandwidth to fit the stream into.
- *                       If 0, do not calculate target bpp.
+ * target_bandwidth_kbps  - Target bandwidth to fit the stream into.
+ *                          If 0, do not calculate target bpp.
  *
- * timing              - The stream timing to fit into 'target_bandwidth' or apply
+ * timing              - The stream timing to fit into 'target_bandwidth_kbps' or apply
  *                       maximum compression to, if 'target_badwidth == 0'
  *
  * dsc_cfg             - DSC configuration to use if it was possible to come up with
@@ -510,7 +515,7 @@ static int fit_num_slices_up(union dsc_enc_slice_caps slice_caps, int num_slices
 static bool setup_dsc_config(
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
 		const struct dsc_enc_caps *dsc_enc_caps,
-		int target_bandwidth,
+		int target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_config *dsc_cfg)
 {
@@ -536,8 +541,8 @@ static bool setup_dsc_config(
 	if (!is_dsc_possible)
 		goto done;
 
-	if (target_bandwidth > 0) {
-		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_policy, &dsc_common_caps, target_bandwidth, timing, &target_bpp);
+	if (target_bandwidth_kbps > 0) {
+		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_policy, &dsc_common_caps, target_bandwidth_kbps, timing, &target_bpp);
 		dsc_cfg->bits_per_pixel = target_bpp;
 	}
 	if (!is_dsc_possible)
@@ -753,6 +758,10 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data, struct dsc_dec_dpcd_cap
 }
 
 
+/* If DSC is possbile, get DSC bandwidth range based on [min_bpp, max_bpp] target bitrate range and
+ * timing's pixel clock and uncompressed bandwidth.
+ * If DSC is not possible, leave '*range' untouched.
+ */
 bool dc_dsc_compute_bandwidth_range(
 		const struct dc *dc,
 		const uint32_t min_bpp,
@@ -780,7 +789,7 @@ bool dc_dsc_compute_bandwidth_range(
 bool dc_dsc_compute_config(
 		const struct dc *dc,
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
-		int target_bandwidth,
+		uint32_t target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_config *dsc_cfg)
 {
@@ -790,7 +799,7 @@ bool dc_dsc_compute_config(
 	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
 	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
 			&dsc_enc_caps,
-			target_bandwidth,
+			target_bandwidth_kbps,
 			timing, dsc_cfg);
 	return is_dsc_possible;
 }

commit c2209d15444581e2314e7f66edf24e1d9e6dba4a
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue May 7 15:00:43 2019 -0500

    drm/amd/display: Implement DSC MST fair share algorithm
    
    [why]
    The current policy will always enable DSC to 12 bpp
    regardless of if the current bandwidth is enough for MST displays.
    This logic is not optimal because user will get lower quality output
    if DSC compression is enabled.
    This change to is to implement a DSC MST bandwidth fair share
    algorithm so we will dynamically decide if DSC is needed and what
    quality (target bpp) is needed to fairly destribute the MST bandwidth
    in one MST topology. This will allow user to see the most optimal
    image quality with the given bandwidth.
    
    [how]
    We will start with lowest bandwidth possible and run a
    Max-Min fairness algorithm to fairly distribute the available
    bandwidth. If there is still remaining bandwidth, we will try to fit
    the timing without DSC compression.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Hawking Zhang <Hawking.Zhang@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 6357325d3c90..d15da6f906e8 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -284,7 +284,8 @@ const struct dc_dsc_policy dsc_policy = {
 };
 
 static void get_dsc_bandwidth_range(
-		const struct dc_dsc_policy *policy,
+		const uint32_t min_bpp,
+		const uint32_t max_bpp,
 		const struct dsc_enc_caps *dsc_caps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_bw_range *range)
@@ -293,8 +294,8 @@ static void get_dsc_bandwidth_range(
 	range->stream_kbps = dc_bandwidth_in_kbps_from_timing(timing);
 
 	/* max dsc target bpp */
-	range->max_kbps = dsc_round_up(policy->max_target_bpp * timing->pix_clk_100hz);
-	range->max_target_bpp_x16 = policy->max_target_bpp * 16;
+	range->max_kbps = dsc_round_up(max_bpp * timing->pix_clk_100hz);
+	range->max_target_bpp_x16 = max_bpp * 16;
 	if (range->max_kbps > range->stream_kbps) {
 		/* max dsc target bpp is capped to native bandwidth */
 		range->max_kbps = range->stream_kbps;
@@ -302,8 +303,8 @@ static void get_dsc_bandwidth_range(
 	}
 
 	/* min dsc target bpp */
-	range->min_kbps = dsc_round_up(policy->min_target_bpp * timing->pix_clk_100hz);
-	range->min_target_bpp_x16 = policy->min_target_bpp * 16;
+	range->min_kbps = dsc_round_up(min_bpp * timing->pix_clk_100hz);
+	range->min_target_bpp_x16 = min_bpp * 16;
 	if (range->min_kbps > range->max_kbps) {
 		/* min dsc target bpp is capped to max dsc bandwidth*/
 		range->min_kbps = range->max_kbps;
@@ -330,7 +331,8 @@ static bool decide_dsc_target_bpp_x16(
 
 	memset(&range, 0, sizeof(range));
 
-	get_dsc_bandwidth_range(policy, dsc_common_caps, timing, &range);
+	get_dsc_bandwidth_range(policy->min_target_bpp, policy->max_target_bpp,
+			dsc_common_caps, timing, &range);
 	if (target_bandwidth_kbps >= range.stream_kbps) {
 		/* enough bandwidth without dsc */
 		*target_bpp_x16 = 0;
@@ -753,6 +755,8 @@ bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data, struct dsc_dec_dpcd_cap
 
 bool dc_dsc_compute_bandwidth_range(
 		const struct dc *dc,
+		const uint32_t min_bpp,
+		const uint32_t max_bpp,
 		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
 		const struct dc_crtc_timing *timing,
 		struct dc_dsc_bw_range *range)
@@ -760,10 +764,16 @@ bool dc_dsc_compute_bandwidth_range(
 	bool is_dsc_possible = false;
 	struct dsc_enc_caps dsc_enc_caps;
 	struct dsc_enc_caps dsc_common_caps;
+	struct dc_dsc_config config;
+
 	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
-	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
+	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
+			&dsc_enc_caps,
+			0,
+			timing, &config);
 	if (is_dsc_possible)
-		get_dsc_bandwidth_range(&dsc_policy, &dsc_common_caps, timing, range);
+		get_dsc_bandwidth_range(min_bpp, max_bpp, &dsc_common_caps, timing, range);
+
 	return is_dsc_possible;
 }
 

commit 23882a693fe11228cfd38c74cd8db3e54edaef82
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Mar 28 17:40:18 2019 -0400

    drm/amd/display: Make sure DSC slice height is divisible by 2 for 4:2:0 color format
    
    [why] DSC spec requires this
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index c649f62d183d..6357325d3c90 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -658,14 +658,23 @@ static bool setup_dsc_config(
 	dsc_cfg->num_slices_h = num_slices_h;
 	slice_width = pic_width / num_slices_h;
 
-	// Vertical number of slices: start from policy and pick the first one that height is divisible by
+	// Vertical number of slices: start from policy and pick the first one that height is divisible by.
+	// For 4:2:0 make sure the slice height is divisible by 2 as well.
 	pic_height = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
 	num_slices_v = dsc_policy.num_slices_v;
 	if (num_slices_v < 1)
 		num_slices_v = 1;
 
-	while (num_slices_v >= 1 && (pic_height % num_slices_v != 0))
+	while (num_slices_v >= 1) {
+		if (timing->pixel_encoding == PIXEL_ENCODING_YCBCR420) {
+			int slice_height = pic_height / num_slices_v;
+			if (pic_height % num_slices_v == 0 && slice_height % 2 == 0)
+				break;
+		} else if (pic_height % num_slices_v == 0)
+			break;
+
 		num_slices_v--;
+	}
 
 	dsc_cfg->num_slices_v = num_slices_v;
 

commit d438d113380eff1c27a1d239a9bd624e0fb15b6d
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Thu Mar 28 13:47:25 2019 -0400

    drm/amd/display: Use 1/8th DSC target bitrate precision for N4:2:2 and 4:2:0 formats
    
    [why]
    On at least some of the devices (e.g. Realtek scaler) we get a black screen if 1/16th
    precision is used.
    
    [how]
    Work around it by reducing precision to 1/8th for N4:2:2 and 4:2:0 color formats. This
    is a safe workaround and would have a very mild impact on the quality.
    The issue is still to be root-caused and fixed correctly.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 471eb9873885..c649f62d183d 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -228,6 +228,10 @@ static bool dc_intersect_dsc_caps(
 
 	dsc_common_caps->bpp_increment_div = min(dsc_sink_caps->bpp_increment_div, dsc_enc_caps->bpp_increment_div);
 
+	// TODO DSC: Remove this workaround for N422 and 420 once it's fixed, or move it to get_dsc_encoder_caps()
+	if (pixel_encoding == PIXEL_ENCODING_YCBCR422 || pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		dsc_common_caps->bpp_increment_div = min(dsc_common_caps->bpp_increment_div, (uint32_t)8);
+
 	return true;
 }
 

commit 87029eb4fad8fd6a46e92886f350c2fe91c6a5e8
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Wed Mar 27 18:54:19 2019 -0400

    drm/amd/display: Remove additional FEC link bandwidth reduction
    
    [why]
    This is now done in the original link bandwidth calculation and DSC
    must not do this anymore.
    
    [how]
    Remove the line of code that should have been removed when transition
    to correctly applying FEC overhead was made.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index e71197d35d79..471eb9873885 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -311,19 +311,18 @@ static void get_dsc_bandwidth_range(
  *
  * Returns:
  *     - 'true' if DSC was required by policy and was successfully applied
- *     - 'false' if DSC was not necessary (e.g. if uncompressed stream fits 'target_bandwidth'),
+ *     - 'false' if DSC was not necessary (e.g. if uncompressed stream fits 'target_bandwidth_kbps'),
  *        or if it couldn't be applied based on DSC policy.
  */
 static bool decide_dsc_target_bpp_x16(
 		const struct dc_dsc_policy *policy,
 		const struct dsc_enc_caps *dsc_common_caps,
-		const int target_bandwidth,
+		const int target_bandwidth_kbps,
 		const struct dc_crtc_timing *timing,
 		int *target_bpp_x16)
 {
 	bool should_use_dsc = false;
 	struct dc_dsc_bw_range range;
-	float target_bandwidth_kbps = target_bandwidth * 0.97f; // 3% overhead for FEC
 
 	memset(&range, 0, sizeof(range));
 

commit 96454cfb4fbe84948cfa84a538550f1429ce441f
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Tue Mar 26 14:36:52 2019 -0400

    drm/amd/display: remove target_dpp hack for dsc
    
    Remove dc_dsc hack for MST policy
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index fe63af836f1e..e71197d35d79 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -490,7 +490,7 @@ static int fit_num_slices_up(union dsc_enc_slice_caps slice_caps, int num_slices
  * dsc_enc_caps        - DSC encoder capabilities
  *
  * target_bandwidth    - Target bandwidth to fit the stream into.
- *                       If 0, use maximum compression as per DSC policy.
+ *                       If 0, do not calculate target bpp.
  *
  * timing              - The stream timing to fit into 'target_bandwidth' or apply
  *                       maximum compression to, if 'target_badwidth == 0'
@@ -517,7 +517,6 @@ static bool setup_dsc_config(
 	int slice_width;
 	int target_bpp;
 	int sink_per_slice_throughput;
-	// TODO DSC: See if it makes sense to use 2.4% for SST
 	bool is_dsc_possible = false;
 	int num_slices_v;
 	int pic_height;
@@ -534,20 +533,11 @@ static bool setup_dsc_config(
 
 	if (target_bandwidth > 0) {
 		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_policy, &dsc_common_caps, target_bandwidth, timing, &target_bpp);
-	} else if (timing->pix_clk_100hz * 12 <= dc_bandwidth_in_kbps_from_timing(timing) * 10) {
-		/* use 12 target bpp for MST display
-		 * TODO: implement new MST DSC target bpp policy */
-		target_bpp = 16*12;
-		is_dsc_possible = true;
-	} else {
-		is_dsc_possible = false;
+		dsc_cfg->bits_per_pixel = target_bpp;
 	}
-
 	if (!is_dsc_possible)
 		goto done;
 
-	dsc_cfg->bits_per_pixel = target_bpp;
-
 	sink_per_slice_throughput = 0;
 
 	// Validate available DSC settings against the mode timing
@@ -773,18 +763,13 @@ bool dc_dsc_compute_config(
 		struct dc_dsc_config *dsc_cfg)
 {
 	bool is_dsc_possible = false;
-
 	struct dsc_enc_caps dsc_enc_caps;
-	struct dsc_enc_caps dsc_common_caps;
 
 	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
-	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps,
-			timing->pixel_encoding, &dsc_common_caps);
-	if (is_dsc_possible)
-		is_dsc_possible = setup_dsc_config(dsc_sink_caps,
-				&dsc_enc_caps,
-				target_bandwidth,
-				timing, dsc_cfg);
+	is_dsc_possible = setup_dsc_config(dsc_sink_caps,
+			&dsc_enc_caps,
+			target_bandwidth,
+			timing, dsc_cfg);
 	return is_dsc_possible;
 }
 #endif /* CONFIG_DRM_AMD_DC_DSC_SUPPORT */

commit 390fdfbd2d6578dc54b234a801cfc8da05641eda
Author: Wenjing Liu <Wenjing.Liu@amd.com>
Date:   Sat Mar 23 16:28:31 2019 -0400

    drm/amd/display: remove legacy DSC functions
    
    [why]
    Clean up some dsc legacy functions that are
    no longer needed.
    
    [how]
    remove two dsc functions in dc_dsc, use dc_bandwidth_in_kbps_from_timing
    instead of calc_required_bandwidth_for_timing.
    
    Signed-off-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 9e9c77e472e1..fe63af836f1e 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -231,66 +231,6 @@ static bool dc_intersect_dsc_caps(
 	return true;
 }
 
-// TODO DSC: Can this be moved to a common helper module and replace WindowsDM::calcRequiredBandwidthForTiming()?
-static int bpp_from_dc_color_depth(enum dc_color_depth color_depth)
-{
-	int bits_per_pixel;
-
-	// Get color depth in bits per pixel
-	switch (color_depth) {
-	case COLOR_DEPTH_UNDEFINED:
-		bits_per_pixel = 0;
-		break;
-	case COLOR_DEPTH_666:
-		bits_per_pixel = 6;
-		break;
-	case COLOR_DEPTH_888:
-		bits_per_pixel = 8;
-		break;
-	case COLOR_DEPTH_101010:
-		bits_per_pixel = 10;
-		break;
-	case COLOR_DEPTH_121212:
-		bits_per_pixel = 12;
-		break;
-	case COLOR_DEPTH_141414:
-		bits_per_pixel = 14;
-		break;
-	case COLOR_DEPTH_161616:
-		bits_per_pixel = 16;
-		break;
-	case COLOR_DEPTH_999:
-		bits_per_pixel = 9;
-		break;
-	case COLOR_DEPTH_111111:
-		bits_per_pixel = 11;
-		break;
-	case COLOR_DEPTH_COUNT:
-	default:
-		bits_per_pixel = 0;
-		break;
-	}
-
-	return bits_per_pixel;
-}
-
-// TODO DSC: Can this be moved to a common helper module and replace WindowsDM::calcRequiredBandwidthForTiming()?
-static int calc_required_bandwidth_for_timing(const struct dc_crtc_timing *crtc_timing)
-{
-	int timing_bandwidth_kbps = 0;
-	int bits_per_pixel = bpp_from_dc_color_depth(crtc_timing->display_color_depth);
-
-	if (crtc_timing->pixel_encoding == PIXEL_ENCODING_RGB ||
-		crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR444)
-		timing_bandwidth_kbps = crtc_timing->pix_clk_100hz * bits_per_pixel * 3 / 10;
-	else if (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)
-		timing_bandwidth_kbps = crtc_timing->pix_clk_100hz * 8 * 3 / 10;
-	else if (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
-		timing_bandwidth_kbps = crtc_timing->pix_clk_100hz * bits_per_pixel * 3 / 20;
-
-	return timing_bandwidth_kbps;
-}
-
 struct dc_dsc_policy {
 	float max_compression_ratio_legacy;
 	float sst_compression_legacy; // Maximum quality if 0.0
@@ -346,7 +286,7 @@ static void get_dsc_bandwidth_range(
 		struct dc_dsc_bw_range *range)
 {
 	/* native stream bandwidth */
-	range->stream_kbps = calc_required_bandwidth_for_timing(timing);
+	range->stream_kbps = dc_bandwidth_in_kbps_from_timing(timing);
 
 	/* max dsc target bpp */
 	range->max_kbps = dsc_round_up(policy->max_target_bpp * timing->pix_clk_100hz);
@@ -367,6 +307,13 @@ static void get_dsc_bandwidth_range(
 	}
 }
 
+/* Decides if DSC should be used and calculates target bpp if it should, applying DSC policy.
+ *
+ * Returns:
+ *     - 'true' if DSC was required by policy and was successfully applied
+ *     - 'false' if DSC was not necessary (e.g. if uncompressed stream fits 'target_bandwidth'),
+ *        or if it couldn't be applied based on DSC policy.
+ */
 static bool decide_dsc_target_bpp_x16(
 		const struct dc_dsc_policy *policy,
 		const struct dsc_enc_caps *dsc_common_caps,
@@ -402,7 +349,6 @@ static bool decide_dsc_target_bpp_x16(
 	return should_use_dsc;
 }
 
-
 #define MIN_AVAILABLE_SLICES_SIZE  4
 
 static int get_available_dsc_slices(union dsc_enc_slice_caps slice_caps, int *available_slices)
@@ -588,7 +534,7 @@ static bool setup_dsc_config(
 
 	if (target_bandwidth > 0) {
 		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_policy, &dsc_common_caps, target_bandwidth, timing, &target_bpp);
-	} else if (timing->pix_clk_100hz * 12 <= calc_required_bandwidth_for_timing(timing) * 10) {
+	} else if (timing->pix_clk_100hz * 12 <= dc_bandwidth_in_kbps_from_timing(timing) * 10) {
 		/* use 12 target bpp for MST display
 		 * TODO: implement new MST DSC target bpp policy */
 		target_bpp = 16*12;
@@ -841,55 +787,4 @@ bool dc_dsc_compute_config(
 				timing, dsc_cfg);
 	return is_dsc_possible;
 }
-
-bool dc_check_and_fit_timing_into_bandwidth_with_dsc_legacy(
-		const struct dc *pDC,
-		const struct dc_link *link,
-		struct dc_crtc_timing *timing)
-{
-	int requiredBandwidth_Kbps;
-	bool stream_fits_into_bandwidth = false;
-	int total_link_bandwdith_kbps = dc_link_bandwidth_kbps(link, &link->verified_link_cap);
-
-	if (link->preferred_link_setting.lane_count != LANE_COUNT_UNKNOWN &&
-			link->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN) {
-		total_link_bandwdith_kbps = dc_link_bandwidth_kbps(link, &link->preferred_link_setting);
-	}
-
-	timing->flags.DSC = 0;
-	requiredBandwidth_Kbps = calc_required_bandwidth_for_timing(timing);
-
-	if (total_link_bandwdith_kbps >= requiredBandwidth_Kbps)
-		stream_fits_into_bandwidth = true;
-	else {
-		// There's not enough bandwidth in the link. See if DSC can be used to resolve this.
-		int link_bandwidth_kbps = link->type == dc_connection_mst_branch ? 0 : total_link_bandwdith_kbps;
-
-		stream_fits_into_bandwidth = dc_setup_dsc_in_timing_legacy(pDC, &link->dpcd_caps.dsc_sink_caps, link_bandwidth_kbps, timing);
-	}
-
-	return stream_fits_into_bandwidth;
-}
-
-bool dc_setup_dsc_in_timing_legacy(const struct dc *pDC,
-		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
-		int available_bandwidth_kbps,
-		struct dc_crtc_timing *timing)
-{
-	bool isDscOK = false;
-	struct dsc_enc_caps dsc_enc_caps;
-
-	timing->flags.DSC = 0;
-	get_dsc_enc_caps(pDC, &dsc_enc_caps, timing->pix_clk_100hz);
-	if (dsc_enc_caps.dsc_version) {
-		struct dc_dsc_config dscCfg = {0};
-
-		isDscOK = setup_dsc_config(dsc_sink_caps, &dsc_enc_caps, available_bandwidth_kbps, timing, &dscCfg);
-
-		memcpy(&timing->dsc_cfg, &dscCfg, sizeof(dscCfg));
-		timing->flags.DSC = isDscOK ? 1 : 0;
-	}
-
-	return isDscOK;
-}
 #endif /* CONFIG_DRM_AMD_DC_DSC_SUPPORT */

commit c2bcd914a2a7917442daf20a7b33d690f5903bea
Author: Nikola Cornij <nikola.cornij@amd.com>
Date:   Tue Mar 19 19:47:32 2019 -0400

    drm/amd/display: Calculate link bandwidth in a common function
    
    [why]
    Currently link bandwidth is calculated in various places using the same
    multi-step formula. Doing this in one common place makes sure the same
    formula will indeed be applied to all link bandwidth calculations.
    It also makes it possible to apply link-setting-specific adjustments
    that affect effective link bandwidth.
    
    [how]
    Replace all implementations of link bandwidth calculation with a call
    to a function.
    
    Signed-off-by: Nikola Cornij <nikola.cornij@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
index 4ffcc2844d19..9e9c77e472e1 100644
--- a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -849,15 +849,11 @@ bool dc_check_and_fit_timing_into_bandwidth_with_dsc_legacy(
 {
 	int requiredBandwidth_Kbps;
 	bool stream_fits_into_bandwidth = false;
-	int link_rate_kbytes_per_sec = link->verified_link_cap.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;
-	int total_link_bandwdith_kbps = link->verified_link_cap.lane_count * link_rate_kbytes_per_sec * 8;
-
-	if (link->preferred_link_setting.lane_count !=
-			LANE_COUNT_UNKNOWN &&
-			link->preferred_link_setting.link_rate !=
-					LINK_RATE_UNKNOWN) {
-		link_rate_kbytes_per_sec =  link->preferred_link_setting.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;
-		total_link_bandwdith_kbps =  link->preferred_link_setting.lane_count * link_rate_kbytes_per_sec * 8;
+	int total_link_bandwdith_kbps = dc_link_bandwidth_kbps(link, &link->verified_link_cap);
+
+	if (link->preferred_link_setting.lane_count != LANE_COUNT_UNKNOWN &&
+			link->preferred_link_setting.link_rate != LINK_RATE_UNKNOWN) {
+		total_link_bandwdith_kbps = dc_link_bandwidth_kbps(link, &link->preferred_link_setting);
 	}
 
 	timing->flags.DSC = 0;

commit 97bda0322b8a91aa8d534763e709571b2334e585
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Feb 25 13:26:34 2019 -0500

    drm/amd/display: Add DSC support for Navi (v2)
    
    Add support for DCN2 DSC (Display Stream Compression)
    
    HW Blocks:
    
     +--------++------+       +----------+
     | HUBBUB || HUBP |  <--  | MMHUBBUB |
     +--------++------+       +----------+
            |                     ^
            v                     |
        +--------+            +--------+
        |  DPP   |            |  DWB   |
        +--------+            +--------+
            |
            v                      ^
        +--------+                 |
        |  MPC   |                 |
        +--------+                 |
            |                      |
            v                      |
        +-------+      +-------+   |
        |  OPP  | <--> |  DSC  |   |
        +-------+      +-------+   |
            |                      |
            v                      |
        +--------+                /
        |  OPTC  |  --------------
        +--------+
            |
            v
        +--------+       +--------+
        |  DIO   |       |  DCCG  |
        +--------+       +--------+
    
    v2: rebase (Alex)
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
new file mode 100644
index 000000000000..4ffcc2844d19
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dsc/dc_dsc.c
@@ -0,0 +1,899 @@
+/*
+ * Copyright 2019 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Author: AMD
+ */
+
+#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
+#include "dc.h"
+#include "core_types.h"
+#include "dsc.h"
+#include <drm/drm_dp_helper.h>
+
+/* This module's internal functions */
+
+static bool dsc_buff_block_size_from_dpcd(int dpcd_buff_block_size, int *buff_block_size)
+{
+
+	switch (dpcd_buff_block_size) {
+	case DP_DSC_RC_BUF_BLK_SIZE_1:
+		*buff_block_size = 1024;
+		break;
+	case DP_DSC_RC_BUF_BLK_SIZE_4:
+		*buff_block_size = 4 * 1024;
+		break;
+	case DP_DSC_RC_BUF_BLK_SIZE_16:
+		*buff_block_size = 16 * 1024;
+		break;
+	case DP_DSC_RC_BUF_BLK_SIZE_64:
+		*buff_block_size = 64 * 1024;
+		break;
+	default: {
+			dm_error("%s: DPCD DSC buffer size not recoginzed.\n", __func__);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+
+static bool dsc_line_buff_depth_from_dpcd(int dpcd_line_buff_bit_depth, int *line_buff_bit_depth)
+{
+	if (0 <= dpcd_line_buff_bit_depth && dpcd_line_buff_bit_depth <= 7)
+		*line_buff_bit_depth = dpcd_line_buff_bit_depth + 9;
+	else if (dpcd_line_buff_bit_depth == 8)
+		*line_buff_bit_depth = 8;
+	else {
+		dm_error("%s: DPCD DSC buffer depth not recoginzed.\n", __func__);
+		return false;
+	}
+
+	return true;
+}
+
+
+static bool dsc_throughput_from_dpcd(int dpcd_throughput, int *throughput)
+{
+	switch (dpcd_throughput) {
+	case DP_DSC_THROUGHPUT_MODE_0_340:
+		*throughput = 340;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_400:
+		*throughput = 400;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_450:
+		*throughput = 450;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_500:
+		*throughput = 500;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_550:
+		*throughput = 550;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_600:
+		*throughput = 600;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_650:
+		*throughput = 650;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_700:
+		*throughput = 700;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_750:
+		*throughput = 750;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_800:
+		*throughput = 800;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_850:
+		*throughput = 850;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_900:
+		*throughput = 900;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_950:
+		*throughput = 950;
+		break;
+	case DP_DSC_THROUGHPUT_MODE_0_1000:
+		*throughput = 1000;
+		break;
+	default: {
+			dm_error("%s: DPCD DSC througput mode not recoginzed.\n", __func__);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+
+static bool dsc_bpp_increment_div_from_dpcd(int bpp_increment_dpcd, uint32_t *bpp_increment_div)
+{
+
+	switch (bpp_increment_dpcd) {
+	case 0:
+		*bpp_increment_div = 16;
+		break;
+	case 1:
+		*bpp_increment_div = 8;
+		break;
+	case 2:
+		*bpp_increment_div = 4;
+		break;
+	case 3:
+		*bpp_increment_div = 2;
+		break;
+	case 4:
+		*bpp_increment_div = 1;
+		break;
+	default: {
+		dm_error("%s: DPCD DSC bits-per-pixel increment not recoginzed.\n", __func__);
+		return false;
+	}
+	}
+
+	return true;
+}
+
+static void get_dsc_enc_caps(
+	const struct dc *dc,
+	struct dsc_enc_caps *dsc_enc_caps,
+	int pixel_clock_100Hz)
+{
+	// This is a static HW query, so we can use any DSC
+	struct display_stream_compressor *dsc = dc->res_pool->dscs[0];
+
+	memset(dsc_enc_caps, 0, sizeof(struct dsc_enc_caps));
+	if (dsc)
+		dsc->funcs->dsc_get_enc_caps(dsc_enc_caps, pixel_clock_100Hz);
+}
+
+/* Returns 'false' if no intersection was found for at least one capablity.
+ * It also implicitly validates some sink caps against invalid value of zero.
+ */
+static bool dc_intersect_dsc_caps(
+	const struct dsc_dec_dpcd_caps *dsc_sink_caps,
+	const struct dsc_enc_caps *dsc_enc_caps,
+	enum dc_pixel_encoding pixel_encoding,
+	struct dsc_enc_caps *dsc_common_caps)
+{
+	int32_t max_slices;
+	int32_t total_sink_throughput;
+
+	memset(dsc_common_caps, 0, sizeof(struct dsc_enc_caps));
+
+	dsc_common_caps->dsc_version = min(dsc_sink_caps->dsc_version, dsc_enc_caps->dsc_version);
+	if (!dsc_common_caps->dsc_version)
+		return false;
+
+	dsc_common_caps->slice_caps.bits.NUM_SLICES_1 = dsc_sink_caps->slice_caps1.bits.NUM_SLICES_1 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_1;
+	dsc_common_caps->slice_caps.bits.NUM_SLICES_2 = dsc_sink_caps->slice_caps1.bits.NUM_SLICES_2 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_2;
+	dsc_common_caps->slice_caps.bits.NUM_SLICES_4 = dsc_sink_caps->slice_caps1.bits.NUM_SLICES_4 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_4;
+	dsc_common_caps->slice_caps.bits.NUM_SLICES_8 = dsc_sink_caps->slice_caps1.bits.NUM_SLICES_8 && dsc_enc_caps->slice_caps.bits.NUM_SLICES_8;
+	if (!dsc_common_caps->slice_caps.raw)
+		return false;
+
+	dsc_common_caps->lb_bit_depth = min(dsc_sink_caps->lb_bit_depth, dsc_enc_caps->lb_bit_depth);
+	if (!dsc_common_caps->lb_bit_depth)
+		return false;
+
+	dsc_common_caps->is_block_pred_supported = dsc_sink_caps->is_block_pred_supported && dsc_enc_caps->is_block_pred_supported;
+
+	dsc_common_caps->color_formats.raw = dsc_sink_caps->color_formats.raw & dsc_enc_caps->color_formats.raw;
+	if (!dsc_common_caps->color_formats.raw)
+		return false;
+
+	dsc_common_caps->color_depth.raw = dsc_sink_caps->color_depth.raw & dsc_enc_caps->color_depth.raw;
+	if (!dsc_common_caps->color_depth.raw)
+		return false;
+
+	max_slices = 0;
+	if (dsc_common_caps->slice_caps.bits.NUM_SLICES_1)
+		max_slices = 1;
+
+	if (dsc_common_caps->slice_caps.bits.NUM_SLICES_2)
+		max_slices = 2;
+
+	if (dsc_common_caps->slice_caps.bits.NUM_SLICES_4)
+		max_slices = 4;
+
+	total_sink_throughput = max_slices * dsc_sink_caps->throughput_mode_0_mps;
+	if (pixel_encoding == PIXEL_ENCODING_YCBCR422 || pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		total_sink_throughput = max_slices * dsc_sink_caps->throughput_mode_1_mps;
+
+	dsc_common_caps->max_total_throughput_mps = min(total_sink_throughput, dsc_enc_caps->max_total_throughput_mps);
+
+	dsc_common_caps->max_slice_width = min(dsc_sink_caps->max_slice_width, dsc_enc_caps->max_slice_width);
+	if (!dsc_common_caps->max_slice_width)
+		return false;
+
+	dsc_common_caps->bpp_increment_div = min(dsc_sink_caps->bpp_increment_div, dsc_enc_caps->bpp_increment_div);
+
+	return true;
+}
+
+// TODO DSC: Can this be moved to a common helper module and replace WindowsDM::calcRequiredBandwidthForTiming()?
+static int bpp_from_dc_color_depth(enum dc_color_depth color_depth)
+{
+	int bits_per_pixel;
+
+	// Get color depth in bits per pixel
+	switch (color_depth) {
+	case COLOR_DEPTH_UNDEFINED:
+		bits_per_pixel = 0;
+		break;
+	case COLOR_DEPTH_666:
+		bits_per_pixel = 6;
+		break;
+	case COLOR_DEPTH_888:
+		bits_per_pixel = 8;
+		break;
+	case COLOR_DEPTH_101010:
+		bits_per_pixel = 10;
+		break;
+	case COLOR_DEPTH_121212:
+		bits_per_pixel = 12;
+		break;
+	case COLOR_DEPTH_141414:
+		bits_per_pixel = 14;
+		break;
+	case COLOR_DEPTH_161616:
+		bits_per_pixel = 16;
+		break;
+	case COLOR_DEPTH_999:
+		bits_per_pixel = 9;
+		break;
+	case COLOR_DEPTH_111111:
+		bits_per_pixel = 11;
+		break;
+	case COLOR_DEPTH_COUNT:
+	default:
+		bits_per_pixel = 0;
+		break;
+	}
+
+	return bits_per_pixel;
+}
+
+// TODO DSC: Can this be moved to a common helper module and replace WindowsDM::calcRequiredBandwidthForTiming()?
+static int calc_required_bandwidth_for_timing(const struct dc_crtc_timing *crtc_timing)
+{
+	int timing_bandwidth_kbps = 0;
+	int bits_per_pixel = bpp_from_dc_color_depth(crtc_timing->display_color_depth);
+
+	if (crtc_timing->pixel_encoding == PIXEL_ENCODING_RGB ||
+		crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR444)
+		timing_bandwidth_kbps = crtc_timing->pix_clk_100hz * bits_per_pixel * 3 / 10;
+	else if (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR422)
+		timing_bandwidth_kbps = crtc_timing->pix_clk_100hz * 8 * 3 / 10;
+	else if (crtc_timing->pixel_encoding == PIXEL_ENCODING_YCBCR420)
+		timing_bandwidth_kbps = crtc_timing->pix_clk_100hz * bits_per_pixel * 3 / 20;
+
+	return timing_bandwidth_kbps;
+}
+
+struct dc_dsc_policy {
+	float max_compression_ratio_legacy;
+	float sst_compression_legacy; // Maximum quality if 0.0
+	float mst_compression_legacy;
+	bool use_min_slices_h;
+	int max_slices_h; // Maximum available if 0
+	int num_slices_v;
+	int max_target_bpp;
+	int min_target_bpp; // Minimum target bits per pixel
+};
+
+static inline uint32_t dsc_round_up(uint32_t value)
+{
+	return (value + 9) / 10;
+}
+
+static inline uint32_t calc_dsc_bpp_x16(uint32_t stream_bandwidth_kbps, uint32_t pix_clk_100hz, uint32_t bpp_increment_div)
+{
+	uint32_t dsc_target_bpp_x16;
+	float f_dsc_target_bpp;
+	float f_stream_bandwidth_100bps = stream_bandwidth_kbps * 10.0f;
+	uint32_t precision = bpp_increment_div; // bpp_increment_div is actually precision
+
+	f_dsc_target_bpp = f_stream_bandwidth_100bps / pix_clk_100hz;
+
+	// Round down to the nearest precision stop to bring it into DSC spec range
+	dsc_target_bpp_x16 = (uint32_t)(f_dsc_target_bpp * precision);
+	dsc_target_bpp_x16 = (dsc_target_bpp_x16 * 16) / precision;
+
+	return dsc_target_bpp_x16;
+}
+
+const struct dc_dsc_policy dsc_policy = {
+	.max_compression_ratio_legacy = 3.0f, // DSC Policy: Limit compression to 3:1 at most in all cases
+	.sst_compression_legacy = 0.0f, // DSC Policy: SST - Maximum quality (0.0)
+	.mst_compression_legacy = 3.0f, // DSC Policy: MST - always 3:1 compression
+	.use_min_slices_h = true, // DSC Policy: Use minimum number of slices that fits the pixel clock
+	.max_slices_h = 0, // DSC Policy: Use max available slices (in our case 4 for or 8, depending on the mode)
+
+	/* DSC Policy: Number of vertical slices set to 2 for no particular reason.
+	 * Seems small enough to not affect the quality too much, while still providing some error
+	 * propagation control (which may also help debugging).
+	 */
+	.num_slices_v = 16,
+	.max_target_bpp = 24,
+	.min_target_bpp = 8,
+};
+
+static void get_dsc_bandwidth_range(
+		const struct dc_dsc_policy *policy,
+		const struct dsc_enc_caps *dsc_caps,
+		const struct dc_crtc_timing *timing,
+		struct dc_dsc_bw_range *range)
+{
+	/* native stream bandwidth */
+	range->stream_kbps = calc_required_bandwidth_for_timing(timing);
+
+	/* max dsc target bpp */
+	range->max_kbps = dsc_round_up(policy->max_target_bpp * timing->pix_clk_100hz);
+	range->max_target_bpp_x16 = policy->max_target_bpp * 16;
+	if (range->max_kbps > range->stream_kbps) {
+		/* max dsc target bpp is capped to native bandwidth */
+		range->max_kbps = range->stream_kbps;
+		range->max_target_bpp_x16 = calc_dsc_bpp_x16(range->stream_kbps, timing->pix_clk_100hz, dsc_caps->bpp_increment_div);
+	}
+
+	/* min dsc target bpp */
+	range->min_kbps = dsc_round_up(policy->min_target_bpp * timing->pix_clk_100hz);
+	range->min_target_bpp_x16 = policy->min_target_bpp * 16;
+	if (range->min_kbps > range->max_kbps) {
+		/* min dsc target bpp is capped to max dsc bandwidth*/
+		range->min_kbps = range->max_kbps;
+		range->min_target_bpp_x16 = range->max_target_bpp_x16;
+	}
+}
+
+static bool decide_dsc_target_bpp_x16(
+		const struct dc_dsc_policy *policy,
+		const struct dsc_enc_caps *dsc_common_caps,
+		const int target_bandwidth,
+		const struct dc_crtc_timing *timing,
+		int *target_bpp_x16)
+{
+	bool should_use_dsc = false;
+	struct dc_dsc_bw_range range;
+	float target_bandwidth_kbps = target_bandwidth * 0.97f; // 3% overhead for FEC
+
+	memset(&range, 0, sizeof(range));
+
+	get_dsc_bandwidth_range(policy, dsc_common_caps, timing, &range);
+	if (target_bandwidth_kbps >= range.stream_kbps) {
+		/* enough bandwidth without dsc */
+		*target_bpp_x16 = 0;
+		should_use_dsc = false;
+	} else if (target_bandwidth_kbps >= range.max_kbps) {
+		/* use max target bpp allowed */
+		*target_bpp_x16 = range.max_target_bpp_x16;
+		should_use_dsc = true;
+	} else if (target_bandwidth_kbps >= range.min_kbps) {
+		/* use target bpp that can take entire target bandwidth */
+		*target_bpp_x16 = calc_dsc_bpp_x16(target_bandwidth_kbps, timing->pix_clk_100hz, dsc_common_caps->bpp_increment_div);
+		should_use_dsc = true;
+	} else {
+		/* not enough bandwidth to fulfill minimum requirement */
+		*target_bpp_x16 = 0;
+		should_use_dsc = false;
+	}
+
+	return should_use_dsc;
+}
+
+
+#define MIN_AVAILABLE_SLICES_SIZE  4
+
+static int get_available_dsc_slices(union dsc_enc_slice_caps slice_caps, int *available_slices)
+{
+	int idx = 0;
+
+	memset(available_slices, -1, MIN_AVAILABLE_SLICES_SIZE);
+
+	if (slice_caps.bits.NUM_SLICES_1)
+		available_slices[idx++] = 1;
+
+	if (slice_caps.bits.NUM_SLICES_2)
+		available_slices[idx++] = 2;
+
+	if (slice_caps.bits.NUM_SLICES_4)
+		available_slices[idx++] = 4;
+
+	if (slice_caps.bits.NUM_SLICES_8)
+		available_slices[idx++] = 8;
+
+	return idx;
+}
+
+
+static int get_max_dsc_slices(union dsc_enc_slice_caps slice_caps)
+{
+	int max_slices = 0;
+	int available_slices[MIN_AVAILABLE_SLICES_SIZE];
+	int end_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);
+
+	if (end_idx > 0)
+		max_slices = available_slices[end_idx - 1];
+
+	return max_slices;
+}
+
+
+// Increment sice number in available sice numbers stops if possible, or just increment if not
+static int inc_num_slices(union dsc_enc_slice_caps slice_caps, int num_slices)
+{
+	// Get next bigger num slices available in common caps
+	int available_slices[MIN_AVAILABLE_SLICES_SIZE];
+	int end_idx;
+	int i;
+	int new_num_slices = num_slices;
+
+	end_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);
+	if (end_idx == 0) {
+		// No available slices found
+		new_num_slices++;
+		return new_num_slices;
+	}
+
+	// Numbers of slices found - get the next bigger number
+	for (i = 0; i < end_idx; i++) {
+		if (new_num_slices < available_slices[i]) {
+			new_num_slices = available_slices[i];
+			break;
+		}
+	}
+
+	if (new_num_slices == num_slices) // No biger number of slices found
+		new_num_slices++;
+
+	return new_num_slices;
+}
+
+
+// Decrement sice number in available sice numbers stops if possible, or just decrement if not. Stop at zero.
+static int dec_num_slices(union dsc_enc_slice_caps slice_caps, int num_slices)
+{
+	// Get next bigger num slices available in common caps
+	int available_slices[MIN_AVAILABLE_SLICES_SIZE];
+	int end_idx;
+	int i;
+	int new_num_slices = num_slices;
+
+	end_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);
+	if (end_idx == 0 && new_num_slices > 0) {
+		// No numbers of slices found
+		new_num_slices++;
+		return new_num_slices;
+	}
+
+	// Numbers of slices found - get the next smaller number
+	for (i = end_idx - 1; i >= 0; i--) {
+		if (new_num_slices > available_slices[i]) {
+			new_num_slices = available_slices[i];
+			break;
+		}
+	}
+
+	if (new_num_slices == num_slices) {
+		// No smaller number of slices found
+		new_num_slices--;
+		if (new_num_slices < 0)
+			new_num_slices = 0;
+	}
+
+	return new_num_slices;
+}
+
+
+// Choose next bigger number of slices if the requested number of slices is not available
+static int fit_num_slices_up(union dsc_enc_slice_caps slice_caps, int num_slices)
+{
+	// Get next bigger num slices available in common caps
+	int available_slices[MIN_AVAILABLE_SLICES_SIZE];
+	int end_idx;
+	int i;
+	int new_num_slices = num_slices;
+
+	end_idx = get_available_dsc_slices(slice_caps, &available_slices[0]);
+	if (end_idx == 0) {
+		// No available slices found
+		new_num_slices++;
+		return new_num_slices;
+	}
+
+	// Numbers of slices found - get the equal or next bigger number
+	for (i = 0; i < end_idx; i++) {
+		if (new_num_slices <= available_slices[i]) {
+			new_num_slices = available_slices[i];
+			break;
+		}
+	}
+
+	return new_num_slices;
+}
+
+
+/* Attempts to set DSC configuration for the stream, applying DSC policy.
+ * Returns 'true' if successful or 'false' if not.
+ *
+ * Parameters:
+ *
+ * dsc_sink_caps       - DSC sink decoder capabilities (from DPCD)
+ *
+ * dsc_enc_caps        - DSC encoder capabilities
+ *
+ * target_bandwidth    - Target bandwidth to fit the stream into.
+ *                       If 0, use maximum compression as per DSC policy.
+ *
+ * timing              - The stream timing to fit into 'target_bandwidth' or apply
+ *                       maximum compression to, if 'target_badwidth == 0'
+ *
+ * dsc_cfg             - DSC configuration to use if it was possible to come up with
+ *                       one for the given inputs.
+ *                       The target bitrate after DSC can be calculated by multiplying
+ *                       dsc_cfg.bits_per_pixel (in U6.4 format) by pixel rate, e.g.
+ *
+ *                       dsc_stream_bitrate_kbps = (int)ceil(timing->pix_clk_khz * dsc_cfg.bits_per_pixel / 16.0);
+ */
+static bool setup_dsc_config(
+		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
+		const struct dsc_enc_caps *dsc_enc_caps,
+		int target_bandwidth,
+		const struct dc_crtc_timing *timing,
+		struct dc_dsc_config *dsc_cfg)
+{
+	struct dsc_enc_caps dsc_common_caps;
+	int max_slices_h;
+	int min_slices_h;
+	int num_slices_h;
+	int pic_width;
+	int slice_width;
+	int target_bpp;
+	int sink_per_slice_throughput;
+	// TODO DSC: See if it makes sense to use 2.4% for SST
+	bool is_dsc_possible = false;
+	int num_slices_v;
+	int pic_height;
+
+	memset(dsc_cfg, 0, sizeof(struct dc_dsc_config));
+
+	if (!dsc_sink_caps->is_dsc_supported)
+		goto done;
+
+	// Intersect decoder with encoder DSC caps and validate DSC settings
+	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
+	if (!is_dsc_possible)
+		goto done;
+
+	if (target_bandwidth > 0) {
+		is_dsc_possible = decide_dsc_target_bpp_x16(&dsc_policy, &dsc_common_caps, target_bandwidth, timing, &target_bpp);
+	} else if (timing->pix_clk_100hz * 12 <= calc_required_bandwidth_for_timing(timing) * 10) {
+		/* use 12 target bpp for MST display
+		 * TODO: implement new MST DSC target bpp policy */
+		target_bpp = 16*12;
+		is_dsc_possible = true;
+	} else {
+		is_dsc_possible = false;
+	}
+
+	if (!is_dsc_possible)
+		goto done;
+
+	dsc_cfg->bits_per_pixel = target_bpp;
+
+	sink_per_slice_throughput = 0;
+
+	// Validate available DSC settings against the mode timing
+
+	// Color format
+	dsc_cfg->ycbcr422_simple = false;
+	switch (timing->pixel_encoding)	{
+	case PIXEL_ENCODING_RGB:
+		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.RGB;
+		sink_per_slice_throughput = dsc_sink_caps->throughput_mode_0_mps;
+		break;
+	case PIXEL_ENCODING_YCBCR444:
+		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_444;
+		sink_per_slice_throughput = dsc_sink_caps->throughput_mode_0_mps;
+		break;
+	case PIXEL_ENCODING_YCBCR422: {
+			is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_422;
+			sink_per_slice_throughput = dsc_sink_caps->throughput_mode_1_mps;
+			if (!is_dsc_possible) {
+				is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_SIMPLE_422;
+				dsc_cfg->ycbcr422_simple = is_dsc_possible;
+				sink_per_slice_throughput = dsc_sink_caps->throughput_mode_0_mps;
+			}
+		}
+		break;
+	case PIXEL_ENCODING_YCBCR420:
+		is_dsc_possible = (bool)dsc_common_caps.color_formats.bits.YCBCR_NATIVE_420;
+		sink_per_slice_throughput = dsc_sink_caps->throughput_mode_1_mps;
+		break;
+	default:
+		is_dsc_possible = false;
+	}
+
+	if (!is_dsc_possible)
+		goto done;
+
+	// Color depth
+	switch (timing->display_color_depth) {
+	case COLOR_DEPTH_888:
+		is_dsc_possible = (bool)dsc_common_caps.color_depth.bits.COLOR_DEPTH_8_BPC;
+		break;
+	case COLOR_DEPTH_101010:
+		is_dsc_possible = (bool)dsc_common_caps.color_depth.bits.COLOR_DEPTH_10_BPC;
+		break;
+	case COLOR_DEPTH_121212:
+		is_dsc_possible = (bool)dsc_common_caps.color_depth.bits.COLOR_DEPTH_12_BPC;
+		break;
+	default:
+		is_dsc_possible = false;
+	}
+
+	if (!is_dsc_possible)
+		goto done;
+
+	// DSC slicing
+	max_slices_h = get_max_dsc_slices(dsc_common_caps.slice_caps);
+
+	pic_width = timing->h_addressable + timing->h_border_left + timing->h_border_right;
+	while (max_slices_h > 0) {
+		if (pic_width % max_slices_h == 0)
+			break;
+
+		max_slices_h = dec_num_slices(dsc_common_caps.slice_caps, max_slices_h);
+	}
+
+	is_dsc_possible = (dsc_common_caps.max_slice_width > 0);
+	if (!is_dsc_possible)
+		goto done;
+
+	min_slices_h = pic_width / dsc_common_caps.max_slice_width;
+	if (pic_width % dsc_common_caps.max_slice_width)
+		min_slices_h++;
+
+	min_slices_h = fit_num_slices_up(dsc_common_caps.slice_caps, min_slices_h);
+
+	while (min_slices_h <= max_slices_h) {
+		if (dsc_round_up(timing->pix_clk_100hz) / (min_slices_h) <= sink_per_slice_throughput * 1000)
+			break;
+
+		min_slices_h = inc_num_slices(dsc_common_caps.slice_caps, min_slices_h);
+	}
+
+	if (pic_width % min_slices_h != 0)
+		min_slices_h = 0; // DSC TODO: Maybe try increasing the number of slices first?
+
+	is_dsc_possible = (min_slices_h <= max_slices_h);
+	if (!is_dsc_possible)
+		goto done;
+
+	if (dsc_policy.use_min_slices_h) {
+		if (min_slices_h > 0)
+			num_slices_h = min_slices_h;
+		else if (max_slices_h > 0) { // Fall back to max slices if min slices is not working out
+			if (dsc_policy.max_slices_h)
+				num_slices_h = min(dsc_policy.max_slices_h, max_slices_h);
+			else
+				num_slices_h = max_slices_h;
+		} else
+			is_dsc_possible = false;
+	} else {
+		if (max_slices_h > 0) {
+			if (dsc_policy.max_slices_h)
+				num_slices_h = min(dsc_policy.max_slices_h, max_slices_h);
+			else
+				num_slices_h = max_slices_h;
+		} else if (min_slices_h > 0) // Fall back to min slices if max slices is not possible
+			num_slices_h = min_slices_h;
+		else
+			is_dsc_possible = false;
+	}
+
+	if (!is_dsc_possible)
+		goto done;
+
+	dsc_cfg->num_slices_h = num_slices_h;
+	slice_width = pic_width / num_slices_h;
+
+	// Vertical number of slices: start from policy and pick the first one that height is divisible by
+	pic_height = timing->v_addressable + timing->v_border_top + timing->v_border_bottom;
+	num_slices_v = dsc_policy.num_slices_v;
+	if (num_slices_v < 1)
+		num_slices_v = 1;
+
+	while (num_slices_v >= 1 && (pic_height % num_slices_v != 0))
+		num_slices_v--;
+
+	dsc_cfg->num_slices_v = num_slices_v;
+
+	is_dsc_possible = slice_width <= dsc_common_caps.max_slice_width;
+	if (!is_dsc_possible)
+		goto done;
+
+	// Final decission: can we do DSC or not?
+	if (is_dsc_possible) {
+		// Fill out the rest of DSC settings
+		dsc_cfg->block_pred_enable = dsc_common_caps.is_block_pred_supported;
+		dsc_cfg->linebuf_depth = dsc_common_caps.lb_bit_depth;
+		dsc_cfg->version_minor = (dsc_common_caps.dsc_version & 0xf0) >> 4;
+	}
+
+done:
+	if (!is_dsc_possible)
+		memset(dsc_cfg, 0, sizeof(struct dc_dsc_config));
+
+	return is_dsc_possible;
+}
+
+bool dc_dsc_parse_dsc_dpcd(const uint8_t *dpcd_dsc_data, struct dsc_dec_dpcd_caps *dsc_sink_caps)
+{
+	dsc_sink_caps->is_dsc_supported = (dpcd_dsc_data[DP_DSC_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_DECOMPRESSION_IS_SUPPORTED) != 0;
+	if (!dsc_sink_caps->is_dsc_supported)
+		return true;
+
+	dsc_sink_caps->dsc_version = dpcd_dsc_data[DP_DSC_REV - DP_DSC_SUPPORT];
+
+	{
+		int buff_block_size;
+		int buff_size;
+
+		if (!dsc_buff_block_size_from_dpcd(dpcd_dsc_data[DP_DSC_RC_BUF_BLK_SIZE - DP_DSC_SUPPORT], &buff_block_size))
+			return false;
+
+		buff_size = dpcd_dsc_data[DP_DSC_RC_BUF_SIZE - DP_DSC_SUPPORT] + 1;
+		dsc_sink_caps->rc_buffer_size = buff_size * buff_block_size;
+	}
+
+	dsc_sink_caps->slice_caps1.raw = dpcd_dsc_data[DP_DSC_SLICE_CAP_1 - DP_DSC_SUPPORT];
+	if (!dsc_line_buff_depth_from_dpcd(dpcd_dsc_data[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT], &dsc_sink_caps->lb_bit_depth))
+		return false;
+
+	dsc_sink_caps->is_block_pred_supported =
+		(dpcd_dsc_data[DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT] & DP_DSC_BLK_PREDICTION_IS_SUPPORTED) != 0;
+
+	dsc_sink_caps->edp_max_bits_per_pixel =
+		dpcd_dsc_data[DP_DSC_MAX_BITS_PER_PIXEL_LOW - DP_DSC_SUPPORT] |
+		dpcd_dsc_data[DP_DSC_MAX_BITS_PER_PIXEL_HI - DP_DSC_SUPPORT] << 8;
+
+	dsc_sink_caps->color_formats.raw = dpcd_dsc_data[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT];
+	dsc_sink_caps->color_depth.raw = dpcd_dsc_data[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];
+
+	{
+		int dpcd_throughput = dpcd_dsc_data[DP_DSC_PEAK_THROUGHPUT - DP_DSC_SUPPORT];
+
+		if (!dsc_throughput_from_dpcd(dpcd_throughput & DP_DSC_THROUGHPUT_MODE_0_MASK, &dsc_sink_caps->throughput_mode_0_mps))
+			return false;
+
+		dpcd_throughput = (dpcd_throughput & DP_DSC_THROUGHPUT_MODE_1_MASK) >> DP_DSC_THROUGHPUT_MODE_1_SHIFT;
+		if (!dsc_throughput_from_dpcd(dpcd_throughput, &dsc_sink_caps->throughput_mode_1_mps))
+			return false;
+	}
+
+	dsc_sink_caps->max_slice_width = dpcd_dsc_data[DP_DSC_MAX_SLICE_WIDTH - DP_DSC_SUPPORT] * 320;
+	dsc_sink_caps->slice_caps2.raw = dpcd_dsc_data[DP_DSC_SLICE_CAP_2 - DP_DSC_SUPPORT];
+
+	if (!dsc_bpp_increment_div_from_dpcd(dpcd_dsc_data[DP_DSC_BITS_PER_PIXEL_INC - DP_DSC_SUPPORT], &dsc_sink_caps->bpp_increment_div))
+		return false;
+
+	return true;
+}
+
+
+bool dc_dsc_compute_bandwidth_range(
+		const struct dc *dc,
+		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
+		const struct dc_crtc_timing *timing,
+		struct dc_dsc_bw_range *range)
+{
+	bool is_dsc_possible = false;
+	struct dsc_enc_caps dsc_enc_caps;
+	struct dsc_enc_caps dsc_common_caps;
+	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
+	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps, timing->pixel_encoding, &dsc_common_caps);
+	if (is_dsc_possible)
+		get_dsc_bandwidth_range(&dsc_policy, &dsc_common_caps, timing, range);
+	return is_dsc_possible;
+}
+
+bool dc_dsc_compute_config(
+		const struct dc *dc,
+		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
+		int target_bandwidth,
+		const struct dc_crtc_timing *timing,
+		struct dc_dsc_config *dsc_cfg)
+{
+	bool is_dsc_possible = false;
+
+	struct dsc_enc_caps dsc_enc_caps;
+	struct dsc_enc_caps dsc_common_caps;
+
+	get_dsc_enc_caps(dc, &dsc_enc_caps, timing->pix_clk_100hz);
+	is_dsc_possible = dc_intersect_dsc_caps(dsc_sink_caps, &dsc_enc_caps,
+			timing->pixel_encoding, &dsc_common_caps);
+	if (is_dsc_possible)
+		is_dsc_possible = setup_dsc_config(dsc_sink_caps,
+				&dsc_enc_caps,
+				target_bandwidth,
+				timing, dsc_cfg);
+	return is_dsc_possible;
+}
+
+bool dc_check_and_fit_timing_into_bandwidth_with_dsc_legacy(
+		const struct dc *pDC,
+		const struct dc_link *link,
+		struct dc_crtc_timing *timing)
+{
+	int requiredBandwidth_Kbps;
+	bool stream_fits_into_bandwidth = false;
+	int link_rate_kbytes_per_sec = link->verified_link_cap.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;
+	int total_link_bandwdith_kbps = link->verified_link_cap.lane_count * link_rate_kbytes_per_sec * 8;
+
+	if (link->preferred_link_setting.lane_count !=
+			LANE_COUNT_UNKNOWN &&
+			link->preferred_link_setting.link_rate !=
+					LINK_RATE_UNKNOWN) {
+		link_rate_kbytes_per_sec =  link->preferred_link_setting.link_rate * LINK_RATE_REF_FREQ_IN_KHZ;
+		total_link_bandwdith_kbps =  link->preferred_link_setting.lane_count * link_rate_kbytes_per_sec * 8;
+	}
+
+	timing->flags.DSC = 0;
+	requiredBandwidth_Kbps = calc_required_bandwidth_for_timing(timing);
+
+	if (total_link_bandwdith_kbps >= requiredBandwidth_Kbps)
+		stream_fits_into_bandwidth = true;
+	else {
+		// There's not enough bandwidth in the link. See if DSC can be used to resolve this.
+		int link_bandwidth_kbps = link->type == dc_connection_mst_branch ? 0 : total_link_bandwdith_kbps;
+
+		stream_fits_into_bandwidth = dc_setup_dsc_in_timing_legacy(pDC, &link->dpcd_caps.dsc_sink_caps, link_bandwidth_kbps, timing);
+	}
+
+	return stream_fits_into_bandwidth;
+}
+
+bool dc_setup_dsc_in_timing_legacy(const struct dc *pDC,
+		const struct dsc_dec_dpcd_caps *dsc_sink_caps,
+		int available_bandwidth_kbps,
+		struct dc_crtc_timing *timing)
+{
+	bool isDscOK = false;
+	struct dsc_enc_caps dsc_enc_caps;
+
+	timing->flags.DSC = 0;
+	get_dsc_enc_caps(pDC, &dsc_enc_caps, timing->pix_clk_100hz);
+	if (dsc_enc_caps.dsc_version) {
+		struct dc_dsc_config dscCfg = {0};
+
+		isDscOK = setup_dsc_config(dsc_sink_caps, &dsc_enc_caps, available_bandwidth_kbps, timing, &dscCfg);
+
+		memcpy(&timing->dsc_cfg, &dscCfg, sizeof(dscCfg));
+		timing->flags.DSC = isDscOK ? 1 : 0;
+	}
+
+	return isDscOK;
+}
+#endif /* CONFIG_DRM_AMD_DC_DSC_SUPPORT */
