commit 9543a9c3e2359db4b9576ee2ae3bae5a28e08387
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jan 31 07:57:39 2020 +0300

    drm/amd/display: Possible divide by zero in set_speed()
    
    If "speed" is zero then we use it as a divisor to find "prescale".  It's
    better to move the check for zero to the very start of the function.
    
    Fixes: 9eeec26a1339 ("drm/amd/display: Refine i2c frequency calculating sequence")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 066188ba7949..24adec407972 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -267,6 +267,9 @@ static void set_speed(
 	uint32_t xtal_ref_div = 0;
 	uint32_t prescale = 0;
 
+	if (speed == 0)
+		return;
+
 	REG_GET(MICROSECOND_TIME_BASE_DIV, XTAL_REF_DIV, &xtal_ref_div);
 
 	if (xtal_ref_div == 0)
@@ -274,17 +277,15 @@ static void set_speed(
 
 	prescale = ((dce_i2c_hw->reference_frequency * 2) / xtal_ref_div) / speed;
 
-	if (speed) {
-		if (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)
-			REG_UPDATE_N(SPEED, 3,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);
-		else
-			REG_UPDATE_N(SPEED, 2,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
-	}
+	if (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)
+		REG_UPDATE_N(SPEED, 3,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);
+	else
+		REG_UPDATE_N(SPEED, 2,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
 }
 
 static bool setup_engine(

commit 09f6dd6e6d4305cf199443bb7d099f4f64dc374b
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Tue Jan 14 11:08:34 2020 +0800

    drm/amd/display: init hw i2c speed
    
    [Why]
    Driver didn't init hw i2c speed cause hdcp hw cannot
    send command, because the default value of speed register
    is 0x2.
    
    [How]
    Restore the default speed when release i2c engine
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 49d490214060..066188ba7949 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -339,7 +339,7 @@ static void release_engine(
 	bool safe_to_reset;
 
 	/* Restore original HW engine speed */
-	REG_WRITE(SPEED, dce_i2c_hw->original_speed);
+	set_speed(dce_i2c_hw, dce_i2c_hw->default_speed);
 
 	/* Reset HW engine */
 	{
@@ -371,7 +371,6 @@ struct dce_i2c_hw *acquire_i2c_hw_engine(
 {
 	uint32_t counter = 0;
 	enum gpio_result result;
-	uint32_t current_speed;
 	struct dce_i2c_hw *dce_i2c_hw = NULL;
 
 	if (!ddc)
@@ -409,11 +408,6 @@ struct dce_i2c_hw *acquire_i2c_hw_engine(
 
 	dce_i2c_hw->ddc = ddc;
 
-	current_speed = REG_READ(SPEED);
-
-	if (current_speed)
-		dce_i2c_hw->original_speed = current_speed;
-
 	if (!setup_engine(dce_i2c_hw)) {
 		release_engine(dce_i2c_hw);
 		return NULL;
@@ -613,7 +607,6 @@ void dce_i2c_hw_construct(
 	dce_i2c_hw->buffer_used_bytes = 0;
 	dce_i2c_hw->transaction_count = 0;
 	dce_i2c_hw->engine_keep_power_up_count = 1;
-	dce_i2c_hw->original_speed = DEFAULT_I2C_HW_SPEED;
 	dce_i2c_hw->default_speed = DEFAULT_I2C_HW_SPEED;
 	dce_i2c_hw->send_reset_length = 0;
 	dce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCE;

commit 9eeec26a13392d6efb5215c26b5e9965ef7ac2af
Author: Lewis Huang <Lewis.Huang@amd.com>
Date:   Sat Jan 11 00:51:15 2020 +0800

    drm/amd/display: Refine i2c frequency calculating sequence
    
    [Why]
    In HG mode, vbios didn't call DispController_Init to program NV1x
    XTAL_REF_DIV value when ASIC_INIT, but driver read XTAL_REF_DIV
    to calculate i2c reference frequency. it cause i2c frequency change
    from 100kHz to 200kHz.
    
    [How]
    remove get_speed function and calculate reference frequency at
    set_speed functiton.
    
    Signed-off-by: Lewis Huang <Lewis.Huang@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 1cd4d8fc361f..49d490214060 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -100,20 +100,6 @@ static uint32_t get_hw_buffer_available_size(
 			dce_i2c_hw->buffer_used_bytes;
 }
 
-static uint32_t get_speed(
-	const struct dce_i2c_hw *dce_i2c_hw)
-{
-	uint32_t pre_scale = 0;
-
-	REG_GET(SPEED, DC_I2C_DDC1_PRESCALE, &pre_scale);
-
-	/* [anaumov] it seems following is unnecessary */
-	/*ASSERT(value.bits.DC_I2C_DDC1_PRESCALE);*/
-	return pre_scale ?
-		dce_i2c_hw->reference_frequency / pre_scale :
-		dce_i2c_hw->default_speed;
-}
-
 static void process_channel_reply(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct i2c_payload *reply)
@@ -278,16 +264,25 @@ static void set_speed(
 	struct dce_i2c_hw *dce_i2c_hw,
 	uint32_t speed)
 {
+	uint32_t xtal_ref_div = 0;
+	uint32_t prescale = 0;
+
+	REG_GET(MICROSECOND_TIME_BASE_DIV, XTAL_REF_DIV, &xtal_ref_div);
+
+	if (xtal_ref_div == 0)
+		xtal_ref_div = 2;
+
+	prescale = ((dce_i2c_hw->reference_frequency * 2) / xtal_ref_div) / speed;
 
 	if (speed) {
 		if (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)
 			REG_UPDATE_N(SPEED, 3,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,
 				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,
 				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);
 		else
 			REG_UPDATE_N(SPEED, 2,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), prescale,
 				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
 	}
 }
@@ -344,9 +339,7 @@ static void release_engine(
 	bool safe_to_reset;
 
 	/* Restore original HW engine speed */
-
-	set_speed(dce_i2c_hw, dce_i2c_hw->original_speed);
-
+	REG_WRITE(SPEED, dce_i2c_hw->original_speed);
 
 	/* Reset HW engine */
 	{
@@ -416,7 +409,7 @@ struct dce_i2c_hw *acquire_i2c_hw_engine(
 
 	dce_i2c_hw->ddc = ddc;
 
-	current_speed = get_speed(dce_i2c_hw);
+	current_speed = REG_READ(SPEED);
 
 	if (current_speed)
 		dce_i2c_hw->original_speed = current_speed;
@@ -478,13 +471,9 @@ static void submit_channel_request_hw(
 
 static uint32_t get_transaction_timeout_hw(
 	const struct dce_i2c_hw *dce_i2c_hw,
-	uint32_t length)
+	uint32_t length,
+	uint32_t speed)
 {
-
-	uint32_t speed = get_speed(dce_i2c_hw);
-
-
-
 	uint32_t period_timeout;
 	uint32_t num_of_clock_stretches;
 
@@ -504,7 +493,8 @@ static uint32_t get_transaction_timeout_hw(
 bool dce_i2c_hw_engine_submit_payload(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct i2c_payload *payload,
-	bool middle_of_transaction)
+	bool middle_of_transaction,
+	uint32_t speed)
 {
 
 	struct i2c_request_transaction_data request;
@@ -542,7 +532,7 @@ bool dce_i2c_hw_engine_submit_payload(
 	/* obtain timeout value before submitting request */
 
 	transaction_timeout = get_transaction_timeout_hw(
-		dce_i2c_hw, payload->length + 1);
+		dce_i2c_hw, payload->length + 1, speed);
 
 	submit_channel_request_hw(
 		dce_i2c_hw, &request);
@@ -588,13 +578,11 @@ bool dce_i2c_submit_command_hw(
 		struct i2c_payload *payload = cmd->payloads + index_of_payload;
 
 		if (!dce_i2c_hw_engine_submit_payload(
-				dce_i2c_hw, payload, mot)) {
+				dce_i2c_hw, payload, mot, cmd->speed)) {
 			result = false;
 			break;
 		}
 
-
-
 		++index_of_payload;
 	}
 
@@ -640,9 +628,6 @@ void dce100_i2c_hw_construct(
 	const struct dce_i2c_shift *shifts,
 	const struct dce_i2c_mask *masks)
 {
-
-	uint32_t xtal_ref_div = 0;
-
 	dce_i2c_hw_construct(dce_i2c_hw,
 			ctx,
 			engine_id,
@@ -650,21 +635,6 @@ void dce100_i2c_hw_construct(
 			shifts,
 			masks);
 	dce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE100;
-
-	REG_GET(MICROSECOND_TIME_BASE_DIV, XTAL_REF_DIV, &xtal_ref_div);
-
-	if (xtal_ref_div == 0)
-		xtal_ref_div = 2;
-
-	/*Calculating Reference Clock by divding original frequency by
-	 * XTAL_REF_DIV.
-	 * At upper level, uint32_t reference_frequency =
-	 *  dal_dce_i2c_get_reference_clock(as) >> 1
-	 *  which already divided by 2. So we need x2 to get original
-	 *  reference clock from ppll_info
-	 */
-	dce_i2c_hw->reference_frequency =
-		(dce_i2c_hw->reference_frequency * 2) / xtal_ref_div;
 }
 
 void dce112_i2c_hw_construct(

commit 1da37801a8b0fffb024fea594c7f1d7867ed8aa0
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Wed Nov 6 14:38:55 2019 -0500

    drm/amd/display: Drop CONFIG_DRM_AMD_DC_DCN2_0 and DSC_SUPPORTED
    
    [Why]
    
    DCN2 and DSC are stable enough to be build by default. So drop the flags.
    
    [How]
    
    Remove them using the unifdef tool. The following commands were executed
    in sequence:
    
    $ find -name '*.c' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    $ find -name '*.h' -exec unifdef -m -DCONFIG_DRM_AMD_DC_DSC_SUPPORT -DCONFIG_DRM_AMD_DC_DCN2_0 -UCONFIG_TRIM_DRM_AMD_DC_DCN2_0 '{}' ';'
    
    In addition:
    
    * Remove from kconfig, and replace any dependencies with DCN1_0.
    * Remove from any makefiles.
    * Fix and cleanup NV defninitions in dal_asic_id.h
    * Expand DCN1 ifdef to include DCN2 code in the following files:
        * clk_mgr/clk_mgr.c: dc_clk_mgr_create()
        * core/dc_resources.c: dc_create_resource_pool()
        * dce/dce_dmcu.c: dcn20_*lock_phy()
        * dce/dce_dmcu.c: dcn20_funcs
        * dce/dce_dmcu.c: dcn20_dmcu_create()
        * gpio/hw_factory.c: dal_hw_factory_init()
        * gpio/hw_translate.c: dal_hw_translate_init()
    
    Signed-off-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index aad7b52165be..1cd4d8fc361f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -296,9 +296,7 @@ static bool setup_engine(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
 	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	uint32_t  reset_length = 0;
-#endif
 	/* we have checked I2c not used by DMCU, set SW use I2C REQ to 1 to indicate SW using it*/
 	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);
 
@@ -322,14 +320,12 @@ static bool setup_engine(
 		REG_UPDATE_N(SETUP, 2,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	} else {
 		reset_length = dce_i2c_hw->send_reset_length;
 		REG_UPDATE_N(SETUP, 3,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_SEND_RESET_LENGTH), reset_length,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
-#endif
 	}
 	/* Program HW priority
 	 * set to High - interrupt software I2C at any time
@@ -705,7 +701,6 @@ void dcn1_i2c_hw_construct(
 	dce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCN;
 }
 
-#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 void dcn2_i2c_hw_construct(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct dc_context *ctx,
@@ -724,4 +719,3 @@ void dcn2_i2c_hw_construct(
 	if (ctx->dc->debug.scl_reset_length10)
 		dce_i2c_hw->send_reset_length = I2C_SEND_RESET_LENGTH_10;
 }
-#endif

commit 9a00d0ff92f4c718054b5c068e255ecc61ef48bb
Author: Derek Lai <Derek.Lai@amd.com>
Date:   Fri Aug 23 11:44:53 2019 -0500

    drm/amd/display: Use res_cap to acquire i2c instead of pipe count
    
    [Why]
    We should be using the ddc_num from res_caps. As the
    pipe count != number of i2c resources.
    
    [How]
    Use ddc_num from res_cap instead of pipe count.
    
    Signed-off-by: Derek Lai <Derek.Lai@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 420b18f99ce9..aad7b52165be 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -25,6 +25,7 @@
 
 #include <linux/delay.h>
 
+#include "resource.h"
 #include "dce_i2c.h"
 #include "dce_i2c_hw.h"
 #include "reg_helper.h"
@@ -390,7 +391,7 @@ struct dce_i2c_hw *acquire_i2c_hw_engine(
 	if (ddc->hw_info.hw_supported) {
 		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
 
-		if (line < pool->pipe_count)
+		if (line < pool->res_cap->num_ddc)
 			dce_i2c_hw = pool->hw_i2cs[line];
 	}
 

commit 9adc8050bf3ca3e49c65e13259a4c310640542f1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 12 15:06:06 2019 -0400

    drm/amd/display: make firmware info only load once during dc_bios create
    
    Currently every time DC wants to access firmware info we make a call
    into VBIOS. This makes no sense as there is nothing that can change
    runtime inside fw info and can cause issues when calling unstable
    bios during bringup.
    
    This change eliminate this behavior by only calling bios once for fw
    info and keeping it stored as part of dc_bios.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index a9061aaf1562..420b18f99ce9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -99,17 +99,6 @@ static uint32_t get_hw_buffer_available_size(
 			dce_i2c_hw->buffer_used_bytes;
 }
 
-uint32_t get_reference_clock(
-		struct dc_bios *bios)
-{
-	struct dc_firmware_info info = { { 0 } };
-
-	if (bios->funcs->get_firmware_info(bios, &info) != BP_RESULT_OK)
-		return 0;
-
-	return info.pll_info.crystal_frequency;
-}
-
 static uint32_t get_speed(
 	const struct dce_i2c_hw *dce_i2c_hw)
 {
@@ -632,7 +621,7 @@ void dce_i2c_hw_construct(
 {
 	dce_i2c_hw->ctx = ctx;
 	dce_i2c_hw->engine_id = engine_id;
-	dce_i2c_hw->reference_frequency = get_reference_clock(ctx->dc_bios) >> 1;
+	dce_i2c_hw->reference_frequency = (ctx->dc_bios->fw_info.pll_info.crystal_frequency) >> 1;
 	dce_i2c_hw->regs = regs;
 	dce_i2c_hw->shifts = shifts;
 	dce_i2c_hw->masks = masks;

commit d7929c1e13e3788e7cb741d75b5baec5e53eff21
Merge: 8ac875db0fdc 80d42db02b3a
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Tue Jun 25 08:42:25 2019 -0500

    Merge branch 'drm-next' into drm-next-5.3
    
    Backmerge drm-next and fix up conflicts due to drmP.h removal.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

commit c703e753c8d150295335ff9671d5573310048831
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Apr 15 16:17:59 2019 -0400

    drm/amd/display: add SW_USE_I2C_REG request.
    
    [Description]
    This is for DC_I2c arbitration use between HW use/SW use and DMCU use.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index d658b862430a..b2786a704708 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -306,6 +306,8 @@ static bool setup_engine(
 #if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 	uint32_t  reset_length = 0;
 #endif
+	/* we have checked I2c not used by DMCU, set SW use I2C REQ to 1 to indicate SW using it*/
+	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);
 
 	/* we have checked I2c not used by DMCU, set SW use I2C REQ to 1 to indicate SW using it*/
 	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);

commit 38e7128960a67a172c0fc525ff9bc8b738ebe127
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue May 7 14:47:35 2019 -0500

    drm/amd/display: add AUX and I2C for DCN2
    
    Adding support to program DCN2 AUX and I2C HW.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 7f2460caa2a6..d658b862430a 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -303,6 +303,10 @@ static bool setup_engine(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
 	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	uint32_t  reset_length = 0;
+#endif
+
 	/* we have checked I2c not used by DMCU, set SW use I2C REQ to 1 to indicate SW using it*/
 	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);
 
@@ -323,6 +327,14 @@ static bool setup_engine(
 		REG_UPDATE_N(SETUP, 2,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
 			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+	} else {
+		reset_length = dce_i2c_hw->send_reset_length;
+		REG_UPDATE_N(SETUP, 3,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_SEND_RESET_LENGTH), reset_length,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
+#endif
 	}
 	/* Program HW priority
 	 * set to High - interrupt software I2C at any time
@@ -698,3 +710,23 @@ void dcn1_i2c_hw_construct(
 	dce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCN;
 }
 
+#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
+void dcn2_i2c_hw_construct(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct dc_context *ctx,
+	uint32_t engine_id,
+	const struct dce_i2c_registers *regs,
+	const struct dce_i2c_shift *shifts,
+	const struct dce_i2c_mask *masks)
+{
+	dcn1_i2c_hw_construct(dce_i2c_hw,
+			ctx,
+			engine_id,
+			regs,
+			shifts,
+			masks);
+	dce_i2c_hw->send_reset_length = I2C_SEND_RESET_LENGTH_9;
+	if (ctx->dc->debug.scl_reset_length10)
+		dce_i2c_hw->send_reset_length = I2C_SEND_RESET_LENGTH_10;
+}
+#endif

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit f09220041851d585a26063ff13a0cd1d2afc0629
Author: Derek Lai <Derek.Lai@amd.com>
Date:   Wed May 22 14:49:23 2019 +0800

    drm/amd/display: add i2c_hw_Status check to make sure as HW I2c in use
    
    1. Add i2c_hw_Status check to make sure when HW i2c is in use.
    2. Don't reset HW engine in is_hw_busy() and instead do this in
    process_transaction() because SW i2c does not check if hw i2c is in use
    
    Signed-off-by: Derek Lai <Derek.Lai@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 526aab438374..7f2460caa2a6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -149,6 +149,36 @@ static void process_channel_reply(
 	}
 }
 
+static bool is_engine_available(struct dce_i2c_hw *dce_i2c_hw)
+{
+	unsigned int arbitrate;
+	unsigned int i2c_hw_status;
+
+	REG_GET(HW_STATUS, DC_I2C_DDC1_HW_STATUS, &i2c_hw_status);
+	if (i2c_hw_status == DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_HW)
+		return false;
+
+	REG_GET(DC_I2C_ARBITRATION, DC_I2C_REG_RW_CNTL_STATUS, &arbitrate);
+	if (arbitrate == DC_I2C_REG_RW_CNTL_STATUS_DMCU_ONLY)
+		return false;
+
+	return true;
+}
+
+static bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)
+{
+	uint32_t i2c_sw_status = 0;
+
+	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)
+		return false;
+
+	if (is_engine_available(dce_i2c_hw))
+		return false;
+
+	return true;
+}
+
 static bool process_transaction(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct i2c_request_transaction_data *request)
@@ -159,6 +189,11 @@ static bool process_transaction(
 	bool last_transaction = false;
 	uint32_t value = 0;
 
+	if (is_hw_busy(dce_i2c_hw)) {
+		request->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;
+		return false;
+	}
+
 	last_transaction = ((dce_i2c_hw->transaction_count == 3) ||
 			(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||
 			(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ));
@@ -294,27 +329,12 @@ static bool setup_engine(
 	 * Enable restart of SW I2C that was interrupted by HW
 	 * disable queuing of software while I2C is in use by HW
 	 */
-	REG_UPDATE_2(DC_I2C_ARBITRATION,
-		     DC_I2C_NO_QUEUED_SW_GO, 0,
-		     DC_I2C_SW_PRIORITY, DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL);
+	REG_UPDATE(DC_I2C_ARBITRATION,
+			DC_I2C_NO_QUEUED_SW_GO, 0);
 
 	return true;
 }
 
-static bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)
-{
-	uint32_t i2c_sw_status = 0;
-
-	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
-	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)
-		return false;
-
-	reset_hw_engine(dce_i2c_hw);
-
-	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
-	return i2c_sw_status != DC_I2C_STATUS__DC_I2C_STATUS_IDLE;
-}
-
 static void release_engine(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
@@ -349,16 +369,6 @@ static void release_engine(
 
 }
 
-static bool is_engine_available(struct dce_i2c_hw *dce_i2c_hw)
-{
-	unsigned int arbitrate;
-
-	REG_GET(DC_I2C_ARBITRATION, DC_I2C_REG_RW_CNTL_STATUS, &arbitrate);
-	if (arbitrate == DC_I2C_REG_RW_CNTL_STATUS_DMCU_ONLY)
-		return false;
-	return true;
-}
-
 struct dce_i2c_hw *acquire_i2c_hw_engine(
 	struct resource_pool *pool,
 	struct ddc *ddc)
@@ -456,6 +466,7 @@ static void submit_channel_request_hw(
 		request->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;
 		return;
 	}
+	reset_hw_engine(dce_i2c_hw);
 
 	execute_transaction(dce_i2c_hw);
 

commit c366be543c5ea35f4d4103f5ee69f052ce2bffe1
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:49 2019 +0200

    drm/amd: drop dependencies on drm_os_linux.h
    
    Fix so no files in drm/amd/ depends on the
    deprecated drm_os_linux.h header file.
    
    It was done manually:
    - remove drm_os_linux.h from drmP.h
    - fix all build errros
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-3-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index cd26161bcc4d..8a236d40d8d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -22,6 +22,9 @@
  * Authors: AMD
  *
  */
+
+#include <linux/delay.h>
+
 #include "dce_i2c.h"
 #include "dce_i2c_hw.h"
 #include "reg_helper.h"

commit f5ce9f3cba9f385bb4d0b4f76b6b32cef2b84da0
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Mon Apr 15 16:17:59 2019 -0400

    drm/amd/display: add SW_USE_I2C_REG request.
    
    [Description]
    This is for DC_I2c arbitration use between HW use/SW use and DMCU use.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index cd26161bcc4d..526aab438374 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -268,6 +268,8 @@ static bool setup_engine(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
 	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
+	/* we have checked I2c not used by DMCU, set SW use I2C REQ to 1 to indicate SW using it*/
+	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_USE_I2C_REG_REQ, 1);
 
 	if (dce_i2c_hw->setup_limit != 0)
 		i2c_setup_limit = dce_i2c_hw->setup_limit;
@@ -322,8 +324,6 @@ static void release_engine(
 
 	set_speed(dce_i2c_hw, dce_i2c_hw->original_speed);
 
-	/* Release I2C */
-	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_DONE_USING_I2C_REG, 1);
 
 	/* Reset HW engine */
 	{
@@ -343,6 +343,9 @@ static void release_engine(
 	/* HW I2c engine - clock gating feature */
 	if (!dce_i2c_hw->engine_keep_power_up_count)
 		REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
+	/* Release I2C after reset, so HW or DMCU could use it */
+	REG_UPDATE_2(DC_I2C_ARBITRATION, DC_I2C_SW_DONE_USING_I2C_REG, 1,
+		DC_I2C_SW_USE_I2C_REG_REQ, 0);
 
 }
 

commit 42195a226bebe037f405576188240da9a1a5ff2c
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Fri Feb 22 13:55:46 2019 -0500

    drm/amd/display: add HW i2c arbitration with dmcu
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Wenjing Liu <Wenjing.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 40f2d6e0b122..cd26161bcc4d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -346,6 +346,16 @@ static void release_engine(
 
 }
 
+static bool is_engine_available(struct dce_i2c_hw *dce_i2c_hw)
+{
+	unsigned int arbitrate;
+
+	REG_GET(DC_I2C_ARBITRATION, DC_I2C_REG_RW_CNTL_STATUS, &arbitrate);
+	if (arbitrate == DC_I2C_REG_RW_CNTL_STATUS_DMCU_ONLY)
+		return false;
+	return true;
+}
+
 struct dce_i2c_hw *acquire_i2c_hw_engine(
 	struct resource_pool *pool,
 	struct ddc *ddc)
@@ -368,7 +378,7 @@ struct dce_i2c_hw *acquire_i2c_hw_engine(
 	if (!dce_i2c_hw)
 		return NULL;
 
-	if (pool->i2c_hw_buffer_in_use)
+	if (pool->i2c_hw_buffer_in_use || !is_engine_available(dce_i2c_hw))
 		return NULL;
 
 	do {

commit 9bbf6a5341092e8a9b4e7b02bea6721e29ced9ef
Author: David Francis <David.Francis@amd.com>
Date:   Fri Aug 3 13:24:28 2018 -0400

    drm/amd/display: Flatten unnecessary i2c functions
    
    [Why]
    The dce_i2c_hw code contained four funtcions that were only
    called in one place and did not have a clearly delineated
    purpose.
    
    [How]
    Inline these functions, keeping the same functionality.
    
    This is not a functional change.
    
    The functions disable_i2c_hw_engine and release_engine_dce_hw were
    pulled into their respective callers.
    
    The most interesting part of this change is the acquire functions.
    dce_i2c_hw_engine_acquire_engine was pulled into
    dce_i2c_engine_acquire_hw, and dce_i2c_engine_acquire_hw was pulled
    into acquire_i2c_hw_engine.
    
    Some notes to show that this change is not functional:
    -Failure conditions in any function resulted in a cascade of calls that
    ended in a 'return NULL'.
    Those are replaced with a direct 'return NULL'.
    
    -The variable result is the one from dce_i2c_hw_engine_acquire_engine.
    The boolean result used as part of return logic was removed.
    
    -As the second half of dce_i2c_hw_engine_acquire_engine is only executed
    if that function is returning true and therefore exiting the do-while
    loop in dce_i2c_engine_acquire_hw, those lines were moved outside
    of the loop.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 2800d3fa49da..40f2d6e0b122 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -36,12 +36,6 @@
 #define FN(reg_name, field_name) \
 	dce_i2c_hw->shifts->field_name, dce_i2c_hw->masks->field_name
 
-static void disable_i2c_hw_engine(
-	struct dce_i2c_hw *dce_i2c_hw)
-{
-	REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
-}
-
 static void execute_transaction(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
@@ -348,60 +342,40 @@ static void release_engine(
 		REG_UPDATE(DC_I2C_CONTROL, DC_I2C_SW_STATUS_RESET, 1);
 	/* HW I2c engine - clock gating feature */
 	if (!dce_i2c_hw->engine_keep_power_up_count)
-		disable_i2c_hw_engine(dce_i2c_hw);
+		REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
 
 }
 
-static void release_engine_dce_hw(
+struct dce_i2c_hw *acquire_i2c_hw_engine(
 	struct resource_pool *pool,
-	struct dce_i2c_hw *dce_i2c_hw)
-{
-	pool->i2c_hw_buffer_in_use = false;
-
-	release_engine(dce_i2c_hw);
-	dal_ddc_close(dce_i2c_hw->ddc);
-
-	dce_i2c_hw->ddc = NULL;
-}
-
-bool dce_i2c_hw_engine_acquire_engine(
-	struct dce_i2c_hw *dce_i2c_hw,
 	struct ddc *ddc)
 {
-
+	uint32_t counter = 0;
 	enum gpio_result result;
 	uint32_t current_speed;
+	struct dce_i2c_hw *dce_i2c_hw = NULL;
 
-	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
-		GPIO_DDC_CONFIG_TYPE_MODE_I2C);
-
-	if (result != GPIO_RESULT_OK)
-		return false;
-
-	dce_i2c_hw->ddc = ddc;
-
-
-	current_speed = get_speed(dce_i2c_hw);
+	if (!ddc)
+		return NULL;
 
-	if (current_speed)
-		dce_i2c_hw->original_speed = current_speed;
+	if (ddc->hw_info.hw_supported) {
+		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
 
-	return true;
-}
+		if (line < pool->pipe_count)
+			dce_i2c_hw = pool->hw_i2cs[line];
+	}
 
-bool dce_i2c_engine_acquire_hw(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct ddc *ddc_handle)
-{
+	if (!dce_i2c_hw)
+		return NULL;
 
-	uint32_t counter = 0;
-	bool result;
+	if (pool->i2c_hw_buffer_in_use)
+		return NULL;
 
 	do {
-		result = dce_i2c_hw_engine_acquire_engine(
-				dce_i2c_hw, ddc_handle);
+		result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
+			GPIO_DDC_CONFIG_TYPE_MODE_I2C);
 
-		if (result)
+		if (result == GPIO_RESULT_OK)
 			break;
 
 		/* i2c_engine is busy by VBios, lets wait and retry */
@@ -411,45 +385,23 @@ bool dce_i2c_engine_acquire_hw(
 		++counter;
 	} while (counter < 2);
 
-	if (result) {
-		if (!setup_engine(dce_i2c_hw)) {
-			release_engine(dce_i2c_hw);
-			result = false;
-		}
-	}
-
-	return result;
-}
-
-struct dce_i2c_hw *acquire_i2c_hw_engine(
-	struct resource_pool *pool,
-	struct ddc *ddc)
-{
-
-	struct dce_i2c_hw *engine = NULL;
-
-	if (!ddc)
+	if (result != GPIO_RESULT_OK)
 		return NULL;
 
-	if (ddc->hw_info.hw_supported) {
-		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
-
-		if (line < pool->pipe_count)
-			engine = pool->hw_i2cs[line];
-	}
+	dce_i2c_hw->ddc = ddc;
 
-	if (!engine)
-		return NULL;
+	current_speed = get_speed(dce_i2c_hw);
 
+	if (current_speed)
+		dce_i2c_hw->original_speed = current_speed;
 
-	if (!pool->i2c_hw_buffer_in_use &&
-			dce_i2c_engine_acquire_hw(engine, ddc)) {
-		pool->i2c_hw_buffer_in_use = true;
-		return engine;
+	if (!setup_engine(dce_i2c_hw)) {
+		release_engine(dce_i2c_hw);
+		return NULL;
 	}
 
-
-	return NULL;
+	pool->i2c_hw_buffer_in_use = true;
+	return dce_i2c_hw;
 }
 
 enum i2c_channel_operation_result dce_i2c_hw_engine_wait_on_operation_result(
@@ -619,7 +571,12 @@ bool dce_i2c_submit_command_hw(
 		++index_of_payload;
 	}
 
-	release_engine_dce_hw(pool, dce_i2c_hw);
+	pool->i2c_hw_buffer_in_use = false;
+
+	release_engine(dce_i2c_hw);
+	dal_ddc_close(dce_i2c_hw->ddc);
+
+	dce_i2c_hw->ddc = NULL;
 
 	return result;
 }

commit d377ae4e3754ee3f81f63a0d9e3eadba7830d3e3
Author: David Francis <David.Francis@amd.com>
Date:   Fri Aug 3 14:25:19 2018 -0400

    drm/amd/display: Remove redundant i2c structs
    
    [Why]
    The i2c code contains two structs that contain the same
    information as i2c_payload
    
    [How]
    Replace references to those structs with references to
    i2c_payload
    
    dce_i2c_transaction_request->status was written to but never read,
    so all references to it are removed
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index cd7da59794d0..2800d3fa49da 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -129,7 +129,7 @@ static uint32_t get_speed(
 
 static void process_channel_reply(
 	struct dce_i2c_hw *dce_i2c_hw,
-	struct i2c_reply_transaction_data *reply)
+	struct i2c_payload *reply)
 {
 	uint32_t length = reply->length;
 	uint8_t *buffer = reply->data;
@@ -522,9 +522,9 @@ static uint32_t get_transaction_timeout_hw(
 	return period_timeout * num_of_clock_stretches;
 }
 
-bool dce_i2c_hw_engine_submit_request(
+bool dce_i2c_hw_engine_submit_payload(
 	struct dce_i2c_hw *dce_i2c_hw,
-	struct dce_i2c_transaction_request *dce_i2c_request,
+	struct i2c_payload *payload,
 	bool middle_of_transaction)
 {
 
@@ -541,46 +541,36 @@ bool dce_i2c_hw_engine_submit_request(
 	 * the number of free bytes in HW buffer (minus one for address)
 	 */
 
-	if (dce_i2c_request->payload.length >=
+	if (payload->length >=
 			get_hw_buffer_available_size(dce_i2c_hw)) {
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_BUFFER_OVERFLOW;
 		return false;
 	}
 
-	if (dce_i2c_request->operation == DCE_I2C_TRANSACTION_READ)
+	if (!payload->write)
 		request.action = middle_of_transaction ?
 			DCE_I2C_TRANSACTION_ACTION_I2C_READ_MOT :
 			DCE_I2C_TRANSACTION_ACTION_I2C_READ;
-	else if (dce_i2c_request->operation == DCE_I2C_TRANSACTION_WRITE)
+	else
 		request.action = middle_of_transaction ?
 			DCE_I2C_TRANSACTION_ACTION_I2C_WRITE_MOT :
 			DCE_I2C_TRANSACTION_ACTION_I2C_WRITE;
-	else {
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_INVALID_OPERATION;
-		/* [anaumov] in DAL2, there was no "return false" */
-		return false;
-	}
 
-	request.address = (uint8_t) dce_i2c_request->payload.address;
-	request.length = dce_i2c_request->payload.length;
-	request.data = dce_i2c_request->payload.data;
+
+	request.address = (uint8_t) ((payload->address << 1) | !payload->write);
+	request.length = payload->length;
+	request.data = payload->data;
 
 	/* obtain timeout value before submitting request */
 
 	transaction_timeout = get_transaction_timeout_hw(
-		dce_i2c_hw, dce_i2c_request->payload.length + 1);
+		dce_i2c_hw, payload->length + 1);
 
 	submit_channel_request_hw(
 		dce_i2c_hw, &request);
 
 	if ((request.status == I2C_CHANNEL_OPERATION_FAILED) ||
-		(request.status == I2C_CHANNEL_OPERATION_ENGINE_BUSY)) {
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_CHANNEL_BUSY;
+		(request.status == I2C_CHANNEL_OPERATION_ENGINE_BUSY))
 		return false;
-	}
 
 	/* wait until transaction proceed */
 
@@ -591,37 +581,11 @@ bool dce_i2c_hw_engine_submit_request(
 
 	/* update transaction status */
 
-	switch (operation_result) {
-	case I2C_CHANNEL_OPERATION_SUCCEEDED:
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_SUCCEEDED;
+	if (operation_result == I2C_CHANNEL_OPERATION_SUCCEEDED)
 		result = true;
-	break;
-	case I2C_CHANNEL_OPERATION_NO_RESPONSE:
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_NACK;
-	break;
-	case I2C_CHANNEL_OPERATION_TIMEOUT:
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_TIMEOUT;
-	break;
-	case I2C_CHANNEL_OPERATION_FAILED:
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_INCOMPLETE;
-	break;
-	default:
-		dce_i2c_request->status =
-			DCE_I2C_TRANSACTION_STATUS_FAILED_OPERATION;
-	}
 
-	if (result && (dce_i2c_request->operation == DCE_I2C_TRANSACTION_READ)) {
-		struct i2c_reply_transaction_data reply;
-
-		reply.data = dce_i2c_request->payload.data;
-		reply.length = dce_i2c_request->payload.length;
-
-		process_channel_reply(dce_i2c_hw, &reply);
-	}
+	if (result && (!payload->write))
+		process_channel_reply(dce_i2c_hw, payload);
 
 	return result;
 }
@@ -644,22 +608,8 @@ bool dce_i2c_submit_command_hw(
 
 		struct i2c_payload *payload = cmd->payloads + index_of_payload;
 
-		struct dce_i2c_transaction_request request = { 0 };
-
-		request.operation = payload->write ?
-			DCE_I2C_TRANSACTION_WRITE :
-			DCE_I2C_TRANSACTION_READ;
-
-		request.payload.address_space =
-			DCE_I2C_TRANSACTION_ADDRESS_SPACE_I2C;
-		request.payload.address = (payload->address << 1) |
-			!payload->write;
-		request.payload.length = payload->length;
-		request.payload.data = payload->data;
-
-
-		if (!dce_i2c_hw_engine_submit_request(
-				dce_i2c_hw, &request, mot)) {
+		if (!dce_i2c_hw_engine_submit_payload(
+				dce_i2c_hw, payload, mot)) {
 			result = false;
 			break;
 		}

commit 9bbdb0f345f50e2a9afd7d7c475e3b788eec402b
Author: David Francis <David.Francis@amd.com>
Date:   Thu Aug 9 13:20:04 2018 -0400

    drm/amd/display: Eliminate i2c hw function pointers
    
    [Why]
    The function pointers of the dce_i2c_hw struct were never
    accessed from outside dce_i2c_hw.c and had only one version.
    As function pointers take up space and make debugging difficult,
    and they are not needed in this case, they should be removed.
    
    [How]
    Remove the dce_i2c_hw_funcs struct and make static all
    functions that were previously a part of it.  Reorder
    the functions in dce_i2c_hw.c.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 3a63e3cbb91d..cd7da59794d0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -36,223 +36,41 @@
 #define FN(reg_name, field_name) \
 	dce_i2c_hw->shifts->field_name, dce_i2c_hw->masks->field_name
 
-
-static inline void reset_hw_engine(struct dce_i2c_hw *dce_i2c_hw)
-{
-	REG_UPDATE_2(DC_I2C_CONTROL,
-		     DC_I2C_SW_STATUS_RESET, 1,
-		     DC_I2C_SW_STATUS_RESET, 1);
-}
-
-static bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)
-{
-	uint32_t i2c_sw_status = 0;
-
-	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
-	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)
-		return false;
-
-	reset_hw_engine(dce_i2c_hw);
-
-	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
-	return i2c_sw_status != DC_I2C_STATUS__DC_I2C_STATUS_IDLE;
-}
-
-static void set_speed(
-	struct dce_i2c_hw *dce_i2c_hw,
-	uint32_t speed)
-{
-
-	if (speed) {
-		if (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)
-			REG_UPDATE_N(SPEED, 3,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);
-		else
-			REG_UPDATE_N(SPEED, 2,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
-				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
-	}
-}
-
-bool dce_i2c_hw_engine_acquire_engine(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct ddc *ddc)
-{
-
-	enum gpio_result result;
-	uint32_t current_speed;
-
-	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
-		GPIO_DDC_CONFIG_TYPE_MODE_I2C);
-
-	if (result != GPIO_RESULT_OK)
-		return false;
-
-	dce_i2c_hw->ddc = ddc;
-
-
-	current_speed = dce_i2c_hw->funcs->get_speed(dce_i2c_hw);
-
-	if (current_speed)
-		dce_i2c_hw->original_speed = current_speed;
-
-	return true;
-}
-bool dce_i2c_engine_acquire_hw(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct ddc *ddc_handle)
-{
-
-	uint32_t counter = 0;
-	bool result;
-
-	do {
-		result = dce_i2c_hw_engine_acquire_engine(
-				dce_i2c_hw, ddc_handle);
-
-		if (result)
-			break;
-
-		/* i2c_engine is busy by VBios, lets wait and retry */
-
-		udelay(10);
-
-		++counter;
-	} while (counter < 2);
-
-	if (result) {
-		if (!dce_i2c_hw->funcs->setup_engine(dce_i2c_hw)) {
-			dce_i2c_hw->funcs->release_engine(dce_i2c_hw);
-			result = false;
-		}
-	}
-
-	return result;
-}
-struct dce_i2c_hw *acquire_i2c_hw_engine(
-	struct resource_pool *pool,
-	struct ddc *ddc)
+static void disable_i2c_hw_engine(
+	struct dce_i2c_hw *dce_i2c_hw)
 {
-
-	struct dce_i2c_hw *engine = NULL;
-
-	if (!ddc)
-		return NULL;
-
-	if (ddc->hw_info.hw_supported) {
-		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
-
-		if (line < pool->pipe_count)
-			engine = pool->hw_i2cs[line];
-	}
-
-	if (!engine)
-		return NULL;
-
-
-	if (!pool->i2c_hw_buffer_in_use &&
-			dce_i2c_engine_acquire_hw(engine, ddc)) {
-		pool->i2c_hw_buffer_in_use = true;
-		return engine;
-	}
-
-
-	return NULL;
+	REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
 }
 
-static bool setup_engine(
+static void execute_transaction(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
-	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
+	REG_UPDATE_N(SETUP, 5,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_EN), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_CLK_DRIVE_EN), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_SEL), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_TRANSACTION_DELAY), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_BYTE_DELAY), 0);
 
-	if (dce_i2c_hw->setup_limit != 0)
-		i2c_setup_limit = dce_i2c_hw->setup_limit;
-	/* Program pin select */
-	REG_UPDATE_6(DC_I2C_CONTROL,
-		     DC_I2C_GO, 0,
+
+	REG_UPDATE_5(DC_I2C_CONTROL,
 		     DC_I2C_SOFT_RESET, 0,
+		     DC_I2C_SW_STATUS_RESET, 0,
 		     DC_I2C_SEND_RESET, 0,
-		     DC_I2C_SW_STATUS_RESET, 1,
-		     DC_I2C_TRANSACTION_COUNT, 0,
-		     DC_I2C_DDC_SELECT, dce_i2c_hw->engine_id);
-
-	/* Program time limit */
-	if (dce_i2c_hw->send_reset_length == 0) {
-		/*pre-dcn*/
-		REG_UPDATE_N(SETUP, 2,
-			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
-			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
-	}
-	/* Program HW priority
-	 * set to High - interrupt software I2C at any time
-	 * Enable restart of SW I2C that was interrupted by HW
-	 * disable queuing of software while I2C is in use by HW
-	 */
-	REG_UPDATE_2(DC_I2C_ARBITRATION,
-		     DC_I2C_NO_QUEUED_SW_GO, 0,
-		     DC_I2C_SW_PRIORITY, DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL);
-
-	return true;
-}
-
-
-
-
-static void process_channel_reply(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct i2c_reply_transaction_data *reply)
-{
-	uint32_t length = reply->length;
-	uint8_t *buffer = reply->data;
-
-	REG_SET_3(DC_I2C_DATA, 0,
-		 DC_I2C_INDEX, dce_i2c_hw->buffer_used_write,
-		 DC_I2C_DATA_RW, 1,
-		 DC_I2C_INDEX_WRITE, 1);
-
-	while (length) {
-		/* after reading the status,
-		 * if the I2C operation executed successfully
-		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
-		 * should read data bytes from I2C circular data buffer
-		 */
-
-		uint32_t i2c_data;
+		     DC_I2C_GO, 0,
+		     DC_I2C_TRANSACTION_COUNT, dce_i2c_hw->transaction_count - 1);
 
-		REG_GET(DC_I2C_DATA, DC_I2C_DATA, &i2c_data);
-		*buffer++ = i2c_data;
+	/* start I2C transfer */
+	REG_UPDATE(DC_I2C_CONTROL, DC_I2C_GO, 1);
 
-		--length;
-	}
+	/* all transactions were executed and HW buffer became empty
+	 * (even though it actually happens when status becomes DONE)
+	 */
+	dce_i2c_hw->transaction_count = 0;
+	dce_i2c_hw->buffer_used_bytes = 0;
 }
-enum i2c_channel_operation_result dce_i2c_hw_engine_wait_on_operation_result(
-	struct dce_i2c_hw *dce_i2c_hw,
-	uint32_t timeout,
-	enum i2c_channel_operation_result expected_result)
-{
-	enum i2c_channel_operation_result result;
-	uint32_t i = 0;
-
-	if (!timeout)
-		return I2C_CHANNEL_OPERATION_SUCCEEDED;
-
-	do {
 
-		result = dce_i2c_hw->funcs->get_channel_status(
-				dce_i2c_hw, NULL);
-
-		if (result != expected_result)
-			break;
-
-		udelay(1);
-
-		++i;
-	} while (i < timeout);
-	return result;
-}
-static enum i2c_channel_operation_result get_channel_status_hw(
+static enum i2c_channel_operation_result get_channel_status(
 	struct dce_i2c_hw *dce_i2c_hw,
 	uint8_t *returned_bytes)
 {
@@ -277,24 +95,13 @@ static enum i2c_channel_operation_result get_channel_status_hw(
 	return I2C_CHANNEL_OPERATION_SUCCEEDED;
 }
 
-static void submit_channel_request_hw(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct i2c_request_transaction_data *request)
+static uint32_t get_hw_buffer_available_size(
+	const struct dce_i2c_hw *dce_i2c_hw)
 {
-	request->status = I2C_CHANNEL_OPERATION_SUCCEEDED;
-
-	if (!dce_i2c_hw->funcs->process_transaction(dce_i2c_hw, request))
-		return;
-
-	if (dce_i2c_hw->funcs->is_hw_busy(dce_i2c_hw)) {
-		request->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;
-		return;
-	}
-
-	dce_i2c_hw->funcs->execute_transaction(dce_i2c_hw);
-
-
+	return dce_i2c_hw->buffer_size -
+			dce_i2c_hw->buffer_used_bytes;
 }
+
 uint32_t get_reference_clock(
 		struct dc_bios *bios)
 {
@@ -306,33 +113,48 @@ uint32_t get_reference_clock(
 	return info.pll_info.crystal_frequency;
 }
 
-static void execute_transaction_hw(
-	struct dce_i2c_hw *dce_i2c_hw)
+static uint32_t get_speed(
+	const struct dce_i2c_hw *dce_i2c_hw)
 {
-	REG_UPDATE_N(SETUP, 5,
-		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_EN), 0,
-		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_CLK_DRIVE_EN), 0,
-		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_SEL), 0,
-		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_TRANSACTION_DELAY), 0,
-		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_BYTE_DELAY), 0);
+	uint32_t pre_scale = 0;
 
+	REG_GET(SPEED, DC_I2C_DDC1_PRESCALE, &pre_scale);
 
-	REG_UPDATE_5(DC_I2C_CONTROL,
-		     DC_I2C_SOFT_RESET, 0,
-		     DC_I2C_SW_STATUS_RESET, 0,
-		     DC_I2C_SEND_RESET, 0,
-		     DC_I2C_GO, 0,
-		     DC_I2C_TRANSACTION_COUNT, dce_i2c_hw->transaction_count - 1);
+	/* [anaumov] it seems following is unnecessary */
+	/*ASSERT(value.bits.DC_I2C_DDC1_PRESCALE);*/
+	return pre_scale ?
+		dce_i2c_hw->reference_frequency / pre_scale :
+		dce_i2c_hw->default_speed;
+}
 
-	/* start I2C transfer */
-	REG_UPDATE(DC_I2C_CONTROL, DC_I2C_GO, 1);
+static void process_channel_reply(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_reply_transaction_data *reply)
+{
+	uint32_t length = reply->length;
+	uint8_t *buffer = reply->data;
 
-	/* all transactions were executed and HW buffer became empty
-	 * (even though it actually happens when status becomes DONE)
-	 */
-	dce_i2c_hw->transaction_count = 0;
-	dce_i2c_hw->buffer_used_bytes = 0;
+	REG_SET_3(DC_I2C_DATA, 0,
+		 DC_I2C_INDEX, dce_i2c_hw->buffer_used_write,
+		 DC_I2C_DATA_RW, 1,
+		 DC_I2C_INDEX_WRITE, 1);
+
+	while (length) {
+		/* after reading the status,
+		 * if the I2C operation executed successfully
+		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
+		 * should read data bytes from I2C circular data buffer
+		 */
+
+		uint32_t i2c_data;
+
+		REG_GET(DC_I2C_DATA, DC_I2C_DATA, &i2c_data);
+		*buffer++ = i2c_data;
+
+		--length;
+	}
 }
+
 static bool process_transaction(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct i2c_request_transaction_data *request)
@@ -422,51 +244,89 @@ static bool process_transaction(
 
 	return last_transaction;
 }
-static uint32_t get_transaction_timeout_hw(
-	const struct dce_i2c_hw *dce_i2c_hw,
-	uint32_t length)
-{
-
-	uint32_t speed = dce_i2c_hw->funcs->get_speed(dce_i2c_hw);
 
+static inline void reset_hw_engine(struct dce_i2c_hw *dce_i2c_hw)
+{
+	REG_UPDATE_2(DC_I2C_CONTROL,
+		     DC_I2C_SW_STATUS_RESET, 1,
+		     DC_I2C_SW_STATUS_RESET, 1);
+}
 
+static void set_speed(
+	struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t speed)
+{
 
-	uint32_t period_timeout;
-	uint32_t num_of_clock_stretches;
+	if (speed) {
+		if (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)
+			REG_UPDATE_N(SPEED, 3,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);
+		else
+			REG_UPDATE_N(SPEED, 2,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
+	}
+}
 
-	if (!speed)
-		return 0;
+static bool setup_engine(
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
 
-	period_timeout = (1000 * TRANSACTION_TIMEOUT_IN_I2C_CLOCKS) / speed;
+	if (dce_i2c_hw->setup_limit != 0)
+		i2c_setup_limit = dce_i2c_hw->setup_limit;
+	/* Program pin select */
+	REG_UPDATE_6(DC_I2C_CONTROL,
+		     DC_I2C_GO, 0,
+		     DC_I2C_SOFT_RESET, 0,
+		     DC_I2C_SEND_RESET, 0,
+		     DC_I2C_SW_STATUS_RESET, 1,
+		     DC_I2C_TRANSACTION_COUNT, 0,
+		     DC_I2C_DDC_SELECT, dce_i2c_hw->engine_id);
 
-	num_of_clock_stretches = 1 + (length << 3) + 1;
-	num_of_clock_stretches +=
-		(dce_i2c_hw->buffer_used_bytes << 3) +
-		(dce_i2c_hw->transaction_count << 1);
+	/* Program time limit */
+	if (dce_i2c_hw->send_reset_length == 0) {
+		/*pre-dcn*/
+		REG_UPDATE_N(SETUP, 2,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
+	}
+	/* Program HW priority
+	 * set to High - interrupt software I2C at any time
+	 * Enable restart of SW I2C that was interrupted by HW
+	 * disable queuing of software while I2C is in use by HW
+	 */
+	REG_UPDATE_2(DC_I2C_ARBITRATION,
+		     DC_I2C_NO_QUEUED_SW_GO, 0,
+		     DC_I2C_SW_PRIORITY, DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL);
 
-	return period_timeout * num_of_clock_stretches;
+	return true;
 }
 
-static void release_engine_dce_hw(
-	struct resource_pool *pool,
-	struct dce_i2c_hw *dce_i2c_hw)
+static bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)
 {
-	pool->i2c_hw_buffer_in_use = false;
+	uint32_t i2c_sw_status = 0;
 
-	dce_i2c_hw->funcs->release_engine(dce_i2c_hw);
-	dal_ddc_close(dce_i2c_hw->ddc);
+	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)
+		return false;
 
-	dce_i2c_hw->ddc = NULL;
+	reset_hw_engine(dce_i2c_hw);
+
+	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+	return i2c_sw_status != DC_I2C_STATUS__DC_I2C_STATUS_IDLE;
 }
 
-static void release_engine_hw(
+static void release_engine(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
 	bool safe_to_reset;
 
 	/* Restore original HW engine speed */
 
-	dce_i2c_hw->funcs->set_speed(dce_i2c_hw, dce_i2c_hw->original_speed);
+	set_speed(dce_i2c_hw, dce_i2c_hw->original_speed);
 
 	/* Release I2C */
 	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_DONE_USING_I2C_REG, 1);
@@ -488,35 +348,180 @@ static void release_engine_hw(
 		REG_UPDATE(DC_I2C_CONTROL, DC_I2C_SW_STATUS_RESET, 1);
 	/* HW I2c engine - clock gating feature */
 	if (!dce_i2c_hw->engine_keep_power_up_count)
-		dce_i2c_hw->funcs->disable_i2c_hw_engine(dce_i2c_hw);
+		disable_i2c_hw_engine(dce_i2c_hw);
 
 }
 
-
-static void disable_i2c_hw_engine(
+static void release_engine_dce_hw(
+	struct resource_pool *pool,
 	struct dce_i2c_hw *dce_i2c_hw)
 {
-	REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
+	pool->i2c_hw_buffer_in_use = false;
+
+	release_engine(dce_i2c_hw);
+	dal_ddc_close(dce_i2c_hw->ddc);
+
+	dce_i2c_hw->ddc = NULL;
 }
-static uint32_t get_speed_hw(
-	const struct dce_i2c_hw *dce_i2c_hw)
+
+bool dce_i2c_hw_engine_acquire_engine(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct ddc *ddc)
 {
-	uint32_t pre_scale = 0;
 
-	REG_GET(SPEED, DC_I2C_DDC1_PRESCALE, &pre_scale);
+	enum gpio_result result;
+	uint32_t current_speed;
 
-	/* [anaumov] it seems following is unnecessary */
-	/*ASSERT(value.bits.DC_I2C_DDC1_PRESCALE);*/
-	return pre_scale ?
-		dce_i2c_hw->reference_frequency / pre_scale :
-		dce_i2c_hw->default_speed;
+	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
+		GPIO_DDC_CONFIG_TYPE_MODE_I2C);
+
+	if (result != GPIO_RESULT_OK)
+		return false;
+
+	dce_i2c_hw->ddc = ddc;
+
+
+	current_speed = get_speed(dce_i2c_hw);
+
+	if (current_speed)
+		dce_i2c_hw->original_speed = current_speed;
+
+	return true;
 }
-static uint32_t get_hw_buffer_available_size(
-	const struct dce_i2c_hw *dce_i2c_hw)
+
+bool dce_i2c_engine_acquire_hw(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct ddc *ddc_handle)
 {
-	return dce_i2c_hw->buffer_size -
-			dce_i2c_hw->buffer_used_bytes;
+
+	uint32_t counter = 0;
+	bool result;
+
+	do {
+		result = dce_i2c_hw_engine_acquire_engine(
+				dce_i2c_hw, ddc_handle);
+
+		if (result)
+			break;
+
+		/* i2c_engine is busy by VBios, lets wait and retry */
+
+		udelay(10);
+
+		++counter;
+	} while (counter < 2);
+
+	if (result) {
+		if (!setup_engine(dce_i2c_hw)) {
+			release_engine(dce_i2c_hw);
+			result = false;
+		}
+	}
+
+	return result;
+}
+
+struct dce_i2c_hw *acquire_i2c_hw_engine(
+	struct resource_pool *pool,
+	struct ddc *ddc)
+{
+
+	struct dce_i2c_hw *engine = NULL;
+
+	if (!ddc)
+		return NULL;
+
+	if (ddc->hw_info.hw_supported) {
+		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
+
+		if (line < pool->pipe_count)
+			engine = pool->hw_i2cs[line];
+	}
+
+	if (!engine)
+		return NULL;
+
+
+	if (!pool->i2c_hw_buffer_in_use &&
+			dce_i2c_engine_acquire_hw(engine, ddc)) {
+		pool->i2c_hw_buffer_in_use = true;
+		return engine;
+	}
+
+
+	return NULL;
+}
+
+enum i2c_channel_operation_result dce_i2c_hw_engine_wait_on_operation_result(
+	struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t timeout,
+	enum i2c_channel_operation_result expected_result)
+{
+	enum i2c_channel_operation_result result;
+	uint32_t i = 0;
+
+	if (!timeout)
+		return I2C_CHANNEL_OPERATION_SUCCEEDED;
+
+	do {
+
+		result = get_channel_status(
+				dce_i2c_hw, NULL);
+
+		if (result != expected_result)
+			break;
+
+		udelay(1);
+
+		++i;
+	} while (i < timeout);
+	return result;
+}
+
+static void submit_channel_request_hw(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_request_transaction_data *request)
+{
+	request->status = I2C_CHANNEL_OPERATION_SUCCEEDED;
+
+	if (!process_transaction(dce_i2c_hw, request))
+		return;
+
+	if (is_hw_busy(dce_i2c_hw)) {
+		request->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;
+		return;
+	}
+
+	execute_transaction(dce_i2c_hw);
+
+
+}
+
+static uint32_t get_transaction_timeout_hw(
+	const struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t length)
+{
+
+	uint32_t speed = get_speed(dce_i2c_hw);
+
+
+
+	uint32_t period_timeout;
+	uint32_t num_of_clock_stretches;
+
+	if (!speed)
+		return 0;
+
+	period_timeout = (1000 * TRANSACTION_TIMEOUT_IN_I2C_CLOCKS) / speed;
+
+	num_of_clock_stretches = 1 + (length << 3) + 1;
+	num_of_clock_stretches +=
+		(dce_i2c_hw->buffer_used_bytes << 3) +
+		(dce_i2c_hw->transaction_count << 1);
+
+	return period_timeout * num_of_clock_stretches;
 }
+
 bool dce_i2c_hw_engine_submit_request(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct dce_i2c_transaction_request *dce_i2c_request,
@@ -615,9 +620,7 @@ bool dce_i2c_hw_engine_submit_request(
 		reply.data = dce_i2c_request->payload.data;
 		reply.length = dce_i2c_request->payload.length;
 
-		dce_i2c_hw->funcs->process_channel_reply(dce_i2c_hw, &reply);
-
-
+		process_channel_reply(dce_i2c_hw, &reply);
 	}
 
 	return result;
@@ -632,7 +635,7 @@ bool dce_i2c_submit_command_hw(
 	uint8_t index_of_payload = 0;
 	bool result;
 
-	dce_i2c_hw->funcs->set_speed(dce_i2c_hw, cmd->speed);
+	set_speed(dce_i2c_hw, cmd->speed);
 
 	result = true;
 
@@ -670,32 +673,6 @@ bool dce_i2c_submit_command_hw(
 
 	return result;
 }
-static const struct dce_i2c_hw_funcs dce100_i2c_hw_funcs = {
-		.setup_engine = setup_engine,
-		.set_speed = set_speed,
-		.get_speed = get_speed_hw,
-		.release_engine = release_engine_hw,
-		.process_transaction = process_transaction,
-		.process_channel_reply = process_channel_reply,
-		.is_hw_busy = is_hw_busy,
-		.get_channel_status = get_channel_status_hw,
-		.execute_transaction = execute_transaction_hw,
-		.disable_i2c_hw_engine = disable_i2c_hw_engine
-};
-static const struct dce_i2c_hw_funcs dce80_i2c_hw_funcs = {
-		.setup_engine = setup_engine,
-		.set_speed = set_speed,
-		.get_speed = get_speed_hw,
-		.release_engine = release_engine_hw,
-		.process_transaction = process_transaction,
-		.process_channel_reply = process_channel_reply,
-		.is_hw_busy = is_hw_busy,
-		.get_channel_status = get_channel_status_hw,
-		.execute_transaction = execute_transaction_hw,
-		.disable_i2c_hw_engine = disable_i2c_hw_engine
-};
-
-
 
 void dce_i2c_hw_construct(
 	struct dce_i2c_hw *dce_i2c_hw,
@@ -718,7 +695,6 @@ void dce_i2c_hw_construct(
 	dce_i2c_hw->default_speed = DEFAULT_I2C_HW_SPEED;
 	dce_i2c_hw->send_reset_length = 0;
 	dce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
-	dce_i2c_hw->funcs = &dce80_i2c_hw_funcs;
 	dce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE;
 }
 
@@ -739,7 +715,6 @@ void dce100_i2c_hw_construct(
 			regs,
 			shifts,
 			masks);
-	dce_i2c_hw->funcs = &dce100_i2c_hw_funcs;
 	dce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE100;
 
 	REG_GET(MICROSECOND_TIME_BASE_DIV, XTAL_REF_DIV, &xtal_ref_div);

commit 728098352ea493584feea20be114006c30d76bca
Author: David Francis <David.Francis@amd.com>
Date:   Thu Aug 9 13:15:36 2018 -0400

    drm/amd/display: Combine dce80 and dce100 i2c hw functions
    
    [Why]
    There are two versions of the hw function pointers: one for dce80
    and one for all other versions.  These paired functions are
    nearly identical.  dce80 and dce100 should not require
    different i2c access functions.
    
    [How]
    Combine each pair of functions into a single function.  Mostly
    the new functions are based on the dce100 versions as those
    versions are newer, support more features, and
    were more maintained.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Sun peng Li <Sunpeng.Li@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
index 6a57c4874e6b..3a63e3cbb91d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -58,18 +58,7 @@ static bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)
 	return i2c_sw_status != DC_I2C_STATUS__DC_I2C_STATUS_IDLE;
 }
 
-static void set_speed_hw_dce80(
-	struct dce_i2c_hw *dce_i2c_hw,
-	uint32_t speed)
-{
-
-	if (speed) {
-		REG_UPDATE_N(SPEED, 2,
-			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
-			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
-	}
-}
-static void set_speed_hw_dce100(
+static void set_speed(
 	struct dce_i2c_hw *dce_i2c_hw,
 	uint32_t speed)
 {
@@ -86,6 +75,7 @@ static void set_speed_hw_dce100(
 				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
 	}
 }
+
 bool dce_i2c_hw_engine_acquire_engine(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct ddc *ddc)
@@ -172,7 +162,7 @@ struct dce_i2c_hw *acquire_i2c_hw_engine(
 	return NULL;
 }
 
-static bool setup_engine_hw_dce100(
+static bool setup_engine(
 	struct dce_i2c_hw *dce_i2c_hw)
 {
 	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
@@ -206,72 +196,11 @@ static bool setup_engine_hw_dce100(
 
 	return true;
 }
-static bool setup_engine_hw_dce80(
-	struct dce_i2c_hw *dce_i2c_hw)
-{
-
-	/* Program pin select */
-	{
-		REG_UPDATE_6(DC_I2C_CONTROL,
-			     DC_I2C_GO, 0,
-			     DC_I2C_SOFT_RESET, 0,
-			     DC_I2C_SEND_RESET, 0,
-			     DC_I2C_SW_STATUS_RESET, 1,
-			     DC_I2C_TRANSACTION_COUNT, 0,
-			     DC_I2C_DDC_SELECT, dce_i2c_hw->engine_id);
-	}
-
-	/* Program time limit */
-	{
-		REG_UPDATE_2(SETUP,
-			     DC_I2C_DDC1_TIME_LIMIT, I2C_SETUP_TIME_LIMIT_DCE,
-			     DC_I2C_DDC1_ENABLE, 1);
-	}
-
-	/* Program HW priority
-	 * set to High - interrupt software I2C at any time
-	 * Enable restart of SW I2C that was interrupted by HW
-	 * disable queuing of software while I2C is in use by HW
-	 */
-	{
-		REG_UPDATE_2(DC_I2C_ARBITRATION,
-			     DC_I2C_NO_QUEUED_SW_GO, 0,
-			     DC_I2C_SW_PRIORITY, DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL);
-	}
 
-	return true;
-}
 
 
 
-static void process_channel_reply_hw_dce80(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct i2c_reply_transaction_data *reply)
-{
-	uint32_t length = reply->length;
-	uint8_t *buffer = reply->data;
-
-	REG_SET_3(DC_I2C_DATA, 0,
-		 DC_I2C_INDEX, length - 1,
-		 DC_I2C_DATA_RW, 1,
-		 DC_I2C_INDEX_WRITE, 1);
-
-	while (length) {
-		/* after reading the status,
-		 * if the I2C operation executed successfully
-		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
-		 * should read data bytes from I2C circular data buffer
-		 */
-
-		uint32_t i2c_data;
-
-		REG_GET(DC_I2C_DATA, DC_I2C_DATA, &i2c_data);
-		*buffer++ = i2c_data;
-
-		--length;
-	}
-}
-static void process_channel_reply_hw_dce100(
+static void process_channel_reply(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct i2c_reply_transaction_data *reply)
 {
@@ -404,7 +333,7 @@ static void execute_transaction_hw(
 	dce_i2c_hw->transaction_count = 0;
 	dce_i2c_hw->buffer_used_bytes = 0;
 }
-static bool process_transaction_hw_dce80(
+static bool process_transaction(
 	struct dce_i2c_hw *dce_i2c_hw,
 	struct i2c_request_transaction_data *request)
 {
@@ -414,135 +343,49 @@ static bool process_transaction_hw_dce80(
 	bool last_transaction = false;
 	uint32_t value = 0;
 
-	{
-
-		last_transaction = ((dce_i2c_hw->transaction_count == 3) ||
-				(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||
-				(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ));
+	last_transaction = ((dce_i2c_hw->transaction_count == 3) ||
+			(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||
+			(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ));
 
 
-		switch (dce_i2c_hw->transaction_count) {
-		case 0:
-			REG_UPDATE_5(DC_I2C_TRANSACTION0,
-				     DC_I2C_STOP_ON_NACK0, 1,
-				     DC_I2C_START0, 1,
-				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
-				     DC_I2C_COUNT0, length,
-				     DC_I2C_STOP0, last_transaction ? 1 : 0);
-			break;
-		case 1:
-			REG_UPDATE_5(DC_I2C_TRANSACTION1,
-				     DC_I2C_STOP_ON_NACK0, 1,
-				     DC_I2C_START0, 1,
-				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
-				     DC_I2C_COUNT0, length,
-				     DC_I2C_STOP0, last_transaction ? 1 : 0);
-			break;
-		case 2:
-			REG_UPDATE_5(DC_I2C_TRANSACTION2,
-				     DC_I2C_STOP_ON_NACK0, 1,
-				     DC_I2C_START0, 1,
-				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
-				     DC_I2C_COUNT0, length,
-				     DC_I2C_STOP0, last_transaction ? 1 : 0);
-			break;
-		case 3:
-			REG_UPDATE_5(DC_I2C_TRANSACTION3,
-				     DC_I2C_STOP_ON_NACK0, 1,
-				     DC_I2C_START0, 1,
-				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
-				     DC_I2C_COUNT0, length,
-				     DC_I2C_STOP0, last_transaction ? 1 : 0);
-			break;
-		default:
-			/* TODO Warning ? */
-			break;
-		}
-	}
-
-	/* Write the I2C address and I2C data
-	 * into the hardware circular buffer, one byte per entry.
-	 * As an example, the 7-bit I2C slave address for CRT monitor
-	 * for reading DDC/EDID information is 0b1010001.
-	 * For an I2C send operation, the LSB must be programmed to 0;
-	 * for I2C receive operation, the LSB must be programmed to 1.
-	 */
-
-	{
-		if (dce_i2c_hw->transaction_count == 0) {
-			value = REG_SET_4(DC_I2C_DATA, 0,
-					 DC_I2C_DATA_RW, false,
-					 DC_I2C_DATA, request->address,
-					 DC_I2C_INDEX, 0,
-					 DC_I2C_INDEX_WRITE, 1);
-		} else
-			value = REG_SET_2(DC_I2C_DATA, 0,
-					 DC_I2C_DATA_RW, false,
-					 DC_I2C_DATA, request->address);
-
-		if (!(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ)) {
-
-			while (length) {
-				REG_SET_2(DC_I2C_DATA, value,
-					 DC_I2C_INDEX_WRITE, 0,
-					 DC_I2C_DATA, *buffer++);
-				--length;
-			}
-		}
-	}
-
-	++dce_i2c_hw->transaction_count;
-	dce_i2c_hw->buffer_used_bytes += length + 1;
-
-	return last_transaction;
-}
-
-#define STOP_TRANS_PREDICAT \
-		((dce_i2c_hw->transaction_count == 3) ||	\
-				(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||	\
-				(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ))
-
-#define SET_I2C_TRANSACTION(id)	\
-		do {	\
-			REG_UPDATE_N(DC_I2C_TRANSACTION##id, 5,	\
-				FN(DC_I2C_TRANSACTION0, DC_I2C_STOP_ON_NACK0), 1,	\
-				FN(DC_I2C_TRANSACTION0, DC_I2C_START0), 1,	\
-				FN(DC_I2C_TRANSACTION0, DC_I2C_STOP0), STOP_TRANS_PREDICAT ? 1:0,	\
-				FN(DC_I2C_TRANSACTION0, DC_I2C_RW0), (0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ)),	\
-				FN(DC_I2C_TRANSACTION0, DC_I2C_COUNT0), length);	\
-				if (STOP_TRANS_PREDICAT)	\
-					last_transaction = true;	\
-		} while (false)
-
-static bool process_transaction_hw_dce100(
-	struct dce_i2c_hw *dce_i2c_hw,
-	struct i2c_request_transaction_data *request)
-{
-	uint32_t length = request->length;
-	uint8_t *buffer = request->data;
-	uint32_t value = 0;
-
-	bool last_transaction = false;
-
 	switch (dce_i2c_hw->transaction_count) {
 	case 0:
-		SET_I2C_TRANSACTION(0);
+		REG_UPDATE_5(DC_I2C_TRANSACTION0,
+				 DC_I2C_STOP_ON_NACK0, 1,
+				 DC_I2C_START0, 1,
+				 DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				 DC_I2C_COUNT0, length,
+				 DC_I2C_STOP0, last_transaction ? 1 : 0);
 		break;
 	case 1:
-		SET_I2C_TRANSACTION(1);
+		REG_UPDATE_5(DC_I2C_TRANSACTION1,
+				 DC_I2C_STOP_ON_NACK0, 1,
+				 DC_I2C_START0, 1,
+				 DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				 DC_I2C_COUNT0, length,
+				 DC_I2C_STOP0, last_transaction ? 1 : 0);
 		break;
 	case 2:
-		SET_I2C_TRANSACTION(2);
+		REG_UPDATE_5(DC_I2C_TRANSACTION2,
+				 DC_I2C_STOP_ON_NACK0, 1,
+				 DC_I2C_START0, 1,
+				 DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				 DC_I2C_COUNT0, length,
+				 DC_I2C_STOP0, last_transaction ? 1 : 0);
 		break;
 	case 3:
-		SET_I2C_TRANSACTION(3);
+		REG_UPDATE_5(DC_I2C_TRANSACTION3,
+				 DC_I2C_STOP_ON_NACK0, 1,
+				 DC_I2C_START0, 1,
+				 DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				 DC_I2C_COUNT0, length,
+				 DC_I2C_STOP0, last_transaction ? 1 : 0);
 		break;
 	default:
 		/* TODO Warning ? */
 		break;
 	}
 
-
 	/* Write the I2C address and I2C data
 	 * into the hardware circular buffer, one byte per entry.
 	 * As an example, the 7-bit I2C slave address for CRT monitor
@@ -828,24 +671,24 @@ bool dce_i2c_submit_command_hw(
 	return result;
 }
 static const struct dce_i2c_hw_funcs dce100_i2c_hw_funcs = {
-		.setup_engine = setup_engine_hw_dce100,
-		.set_speed = set_speed_hw_dce100,
+		.setup_engine = setup_engine,
+		.set_speed = set_speed,
 		.get_speed = get_speed_hw,
 		.release_engine = release_engine_hw,
-		.process_transaction = process_transaction_hw_dce100,
-		.process_channel_reply = process_channel_reply_hw_dce100,
+		.process_transaction = process_transaction,
+		.process_channel_reply = process_channel_reply,
 		.is_hw_busy = is_hw_busy,
 		.get_channel_status = get_channel_status_hw,
 		.execute_transaction = execute_transaction_hw,
 		.disable_i2c_hw_engine = disable_i2c_hw_engine
 };
 static const struct dce_i2c_hw_funcs dce80_i2c_hw_funcs = {
-		.setup_engine = setup_engine_hw_dce80,
-		.set_speed = set_speed_hw_dce80,
+		.setup_engine = setup_engine,
+		.set_speed = set_speed,
 		.get_speed = get_speed_hw,
 		.release_engine = release_engine_hw,
-		.process_transaction = process_transaction_hw_dce80,
-		.process_channel_reply = process_channel_reply_hw_dce80,
+		.process_transaction = process_transaction,
+		.process_channel_reply = process_channel_reply,
 		.is_hw_busy = is_hw_busy,
 		.get_channel_status = get_channel_status_hw,
 		.execute_transaction = execute_transaction_hw,

commit c85e6e546edd7e362693218a33a6f63217802fd3
Author: David Francis <David.Francis@amd.com>
Date:   Mon Jul 23 14:12:10 2018 -0400

    drm/amd/display: Create new i2c resource
    
    [Why]
    I2C code did not match dc resource model and was generally
    unpleasant
    
    [How]
    Move code into new svelte dce_i2c files, replacing various i2c
    objects with two structs: dce_i2c_sw and dce_i2c_hw.  Fully split
    sw and hw code paths.  Remove all redundant declarations.  Use
    address lists to distinguish between versions.  Change dce80 code
    to newer register access macros.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
new file mode 100644
index 000000000000..6a57c4874e6b
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_i2c_hw.c
@@ -0,0 +1,951 @@
+/*
+ * Copyright 2018 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+#include "dce_i2c.h"
+#include "dce_i2c_hw.h"
+#include "reg_helper.h"
+#include "include/gpio_service_interface.h"
+
+#define CTX \
+	dce_i2c_hw->ctx
+#define REG(reg)\
+	dce_i2c_hw->regs->reg
+
+#undef FN
+#define FN(reg_name, field_name) \
+	dce_i2c_hw->shifts->field_name, dce_i2c_hw->masks->field_name
+
+
+static inline void reset_hw_engine(struct dce_i2c_hw *dce_i2c_hw)
+{
+	REG_UPDATE_2(DC_I2C_CONTROL,
+		     DC_I2C_SW_STATUS_RESET, 1,
+		     DC_I2C_SW_STATUS_RESET, 1);
+}
+
+static bool is_hw_busy(struct dce_i2c_hw *dce_i2c_hw)
+{
+	uint32_t i2c_sw_status = 0;
+
+	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_IDLE)
+		return false;
+
+	reset_hw_engine(dce_i2c_hw);
+
+	REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+	return i2c_sw_status != DC_I2C_STATUS__DC_I2C_STATUS_IDLE;
+}
+
+static void set_speed_hw_dce80(
+	struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t speed)
+{
+
+	if (speed) {
+		REG_UPDATE_N(SPEED, 2,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+			     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
+	}
+}
+static void set_speed_hw_dce100(
+	struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t speed)
+{
+
+	if (speed) {
+		if (dce_i2c_hw->masks->DC_I2C_DDC1_START_STOP_TIMING_CNTL)
+			REG_UPDATE_N(SPEED, 3,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_START_STOP_TIMING_CNTL), speed > 50 ? 2:1);
+		else
+			REG_UPDATE_N(SPEED, 2,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_PRESCALE), dce_i2c_hw->reference_frequency / speed,
+				     FN(DC_I2C_DDC1_SPEED, DC_I2C_DDC1_THRESHOLD), 2);
+	}
+}
+bool dce_i2c_hw_engine_acquire_engine(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct ddc *ddc)
+{
+
+	enum gpio_result result;
+	uint32_t current_speed;
+
+	result = dal_ddc_open(ddc, GPIO_MODE_HARDWARE,
+		GPIO_DDC_CONFIG_TYPE_MODE_I2C);
+
+	if (result != GPIO_RESULT_OK)
+		return false;
+
+	dce_i2c_hw->ddc = ddc;
+
+
+	current_speed = dce_i2c_hw->funcs->get_speed(dce_i2c_hw);
+
+	if (current_speed)
+		dce_i2c_hw->original_speed = current_speed;
+
+	return true;
+}
+bool dce_i2c_engine_acquire_hw(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct ddc *ddc_handle)
+{
+
+	uint32_t counter = 0;
+	bool result;
+
+	do {
+		result = dce_i2c_hw_engine_acquire_engine(
+				dce_i2c_hw, ddc_handle);
+
+		if (result)
+			break;
+
+		/* i2c_engine is busy by VBios, lets wait and retry */
+
+		udelay(10);
+
+		++counter;
+	} while (counter < 2);
+
+	if (result) {
+		if (!dce_i2c_hw->funcs->setup_engine(dce_i2c_hw)) {
+			dce_i2c_hw->funcs->release_engine(dce_i2c_hw);
+			result = false;
+		}
+	}
+
+	return result;
+}
+struct dce_i2c_hw *acquire_i2c_hw_engine(
+	struct resource_pool *pool,
+	struct ddc *ddc)
+{
+
+	struct dce_i2c_hw *engine = NULL;
+
+	if (!ddc)
+		return NULL;
+
+	if (ddc->hw_info.hw_supported) {
+		enum gpio_ddc_line line = dal_ddc_get_line(ddc);
+
+		if (line < pool->pipe_count)
+			engine = pool->hw_i2cs[line];
+	}
+
+	if (!engine)
+		return NULL;
+
+
+	if (!pool->i2c_hw_buffer_in_use &&
+			dce_i2c_engine_acquire_hw(engine, ddc)) {
+		pool->i2c_hw_buffer_in_use = true;
+		return engine;
+	}
+
+
+	return NULL;
+}
+
+static bool setup_engine_hw_dce100(
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	uint32_t i2c_setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
+
+	if (dce_i2c_hw->setup_limit != 0)
+		i2c_setup_limit = dce_i2c_hw->setup_limit;
+	/* Program pin select */
+	REG_UPDATE_6(DC_I2C_CONTROL,
+		     DC_I2C_GO, 0,
+		     DC_I2C_SOFT_RESET, 0,
+		     DC_I2C_SEND_RESET, 0,
+		     DC_I2C_SW_STATUS_RESET, 1,
+		     DC_I2C_TRANSACTION_COUNT, 0,
+		     DC_I2C_DDC_SELECT, dce_i2c_hw->engine_id);
+
+	/* Program time limit */
+	if (dce_i2c_hw->send_reset_length == 0) {
+		/*pre-dcn*/
+		REG_UPDATE_N(SETUP, 2,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_TIME_LIMIT), i2c_setup_limit,
+			     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_ENABLE), 1);
+	}
+	/* Program HW priority
+	 * set to High - interrupt software I2C at any time
+	 * Enable restart of SW I2C that was interrupted by HW
+	 * disable queuing of software while I2C is in use by HW
+	 */
+	REG_UPDATE_2(DC_I2C_ARBITRATION,
+		     DC_I2C_NO_QUEUED_SW_GO, 0,
+		     DC_I2C_SW_PRIORITY, DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL);
+
+	return true;
+}
+static bool setup_engine_hw_dce80(
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+
+	/* Program pin select */
+	{
+		REG_UPDATE_6(DC_I2C_CONTROL,
+			     DC_I2C_GO, 0,
+			     DC_I2C_SOFT_RESET, 0,
+			     DC_I2C_SEND_RESET, 0,
+			     DC_I2C_SW_STATUS_RESET, 1,
+			     DC_I2C_TRANSACTION_COUNT, 0,
+			     DC_I2C_DDC_SELECT, dce_i2c_hw->engine_id);
+	}
+
+	/* Program time limit */
+	{
+		REG_UPDATE_2(SETUP,
+			     DC_I2C_DDC1_TIME_LIMIT, I2C_SETUP_TIME_LIMIT_DCE,
+			     DC_I2C_DDC1_ENABLE, 1);
+	}
+
+	/* Program HW priority
+	 * set to High - interrupt software I2C at any time
+	 * Enable restart of SW I2C that was interrupted by HW
+	 * disable queuing of software while I2C is in use by HW
+	 */
+	{
+		REG_UPDATE_2(DC_I2C_ARBITRATION,
+			     DC_I2C_NO_QUEUED_SW_GO, 0,
+			     DC_I2C_SW_PRIORITY, DC_I2C_ARBITRATION__DC_I2C_SW_PRIORITY_NORMAL);
+	}
+
+	return true;
+}
+
+
+
+static void process_channel_reply_hw_dce80(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_reply_transaction_data *reply)
+{
+	uint32_t length = reply->length;
+	uint8_t *buffer = reply->data;
+
+	REG_SET_3(DC_I2C_DATA, 0,
+		 DC_I2C_INDEX, length - 1,
+		 DC_I2C_DATA_RW, 1,
+		 DC_I2C_INDEX_WRITE, 1);
+
+	while (length) {
+		/* after reading the status,
+		 * if the I2C operation executed successfully
+		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
+		 * should read data bytes from I2C circular data buffer
+		 */
+
+		uint32_t i2c_data;
+
+		REG_GET(DC_I2C_DATA, DC_I2C_DATA, &i2c_data);
+		*buffer++ = i2c_data;
+
+		--length;
+	}
+}
+static void process_channel_reply_hw_dce100(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_reply_transaction_data *reply)
+{
+	uint32_t length = reply->length;
+	uint8_t *buffer = reply->data;
+
+	REG_SET_3(DC_I2C_DATA, 0,
+		 DC_I2C_INDEX, dce_i2c_hw->buffer_used_write,
+		 DC_I2C_DATA_RW, 1,
+		 DC_I2C_INDEX_WRITE, 1);
+
+	while (length) {
+		/* after reading the status,
+		 * if the I2C operation executed successfully
+		 * (i.e. DC_I2C_STATUS_DONE = 1) then the I2C controller
+		 * should read data bytes from I2C circular data buffer
+		 */
+
+		uint32_t i2c_data;
+
+		REG_GET(DC_I2C_DATA, DC_I2C_DATA, &i2c_data);
+		*buffer++ = i2c_data;
+
+		--length;
+	}
+}
+enum i2c_channel_operation_result dce_i2c_hw_engine_wait_on_operation_result(
+	struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t timeout,
+	enum i2c_channel_operation_result expected_result)
+{
+	enum i2c_channel_operation_result result;
+	uint32_t i = 0;
+
+	if (!timeout)
+		return I2C_CHANNEL_OPERATION_SUCCEEDED;
+
+	do {
+
+		result = dce_i2c_hw->funcs->get_channel_status(
+				dce_i2c_hw, NULL);
+
+		if (result != expected_result)
+			break;
+
+		udelay(1);
+
+		++i;
+	} while (i < timeout);
+	return result;
+}
+static enum i2c_channel_operation_result get_channel_status_hw(
+	struct dce_i2c_hw *dce_i2c_hw,
+	uint8_t *returned_bytes)
+{
+	uint32_t i2c_sw_status = 0;
+	uint32_t value =
+		REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+	if (i2c_sw_status == DC_I2C_STATUS__DC_I2C_STATUS_USED_BY_SW)
+		return I2C_CHANNEL_OPERATION_ENGINE_BUSY;
+	else if (value & dce_i2c_hw->masks->DC_I2C_SW_STOPPED_ON_NACK)
+		return I2C_CHANNEL_OPERATION_NO_RESPONSE;
+	else if (value & dce_i2c_hw->masks->DC_I2C_SW_TIMEOUT)
+		return I2C_CHANNEL_OPERATION_TIMEOUT;
+	else if (value & dce_i2c_hw->masks->DC_I2C_SW_ABORTED)
+		return I2C_CHANNEL_OPERATION_FAILED;
+	else if (value & dce_i2c_hw->masks->DC_I2C_SW_DONE)
+		return I2C_CHANNEL_OPERATION_SUCCEEDED;
+
+	/*
+	 * this is the case when HW used for communication, I2C_SW_STATUS
+	 * could be zero
+	 */
+	return I2C_CHANNEL_OPERATION_SUCCEEDED;
+}
+
+static void submit_channel_request_hw(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_request_transaction_data *request)
+{
+	request->status = I2C_CHANNEL_OPERATION_SUCCEEDED;
+
+	if (!dce_i2c_hw->funcs->process_transaction(dce_i2c_hw, request))
+		return;
+
+	if (dce_i2c_hw->funcs->is_hw_busy(dce_i2c_hw)) {
+		request->status = I2C_CHANNEL_OPERATION_ENGINE_BUSY;
+		return;
+	}
+
+	dce_i2c_hw->funcs->execute_transaction(dce_i2c_hw);
+
+
+}
+uint32_t get_reference_clock(
+		struct dc_bios *bios)
+{
+	struct dc_firmware_info info = { { 0 } };
+
+	if (bios->funcs->get_firmware_info(bios, &info) != BP_RESULT_OK)
+		return 0;
+
+	return info.pll_info.crystal_frequency;
+}
+
+static void execute_transaction_hw(
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	REG_UPDATE_N(SETUP, 5,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_EN), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_CLK_DRIVE_EN), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_DATA_DRIVE_SEL), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_TRANSACTION_DELAY), 0,
+		     FN(DC_I2C_DDC1_SETUP, DC_I2C_DDC1_INTRA_BYTE_DELAY), 0);
+
+
+	REG_UPDATE_5(DC_I2C_CONTROL,
+		     DC_I2C_SOFT_RESET, 0,
+		     DC_I2C_SW_STATUS_RESET, 0,
+		     DC_I2C_SEND_RESET, 0,
+		     DC_I2C_GO, 0,
+		     DC_I2C_TRANSACTION_COUNT, dce_i2c_hw->transaction_count - 1);
+
+	/* start I2C transfer */
+	REG_UPDATE(DC_I2C_CONTROL, DC_I2C_GO, 1);
+
+	/* all transactions were executed and HW buffer became empty
+	 * (even though it actually happens when status becomes DONE)
+	 */
+	dce_i2c_hw->transaction_count = 0;
+	dce_i2c_hw->buffer_used_bytes = 0;
+}
+static bool process_transaction_hw_dce80(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_request_transaction_data *request)
+{
+	uint32_t length = request->length;
+	uint8_t *buffer = request->data;
+
+	bool last_transaction = false;
+	uint32_t value = 0;
+
+	{
+
+		last_transaction = ((dce_i2c_hw->transaction_count == 3) ||
+				(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||
+				(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ));
+
+
+		switch (dce_i2c_hw->transaction_count) {
+		case 0:
+			REG_UPDATE_5(DC_I2C_TRANSACTION0,
+				     DC_I2C_STOP_ON_NACK0, 1,
+				     DC_I2C_START0, 1,
+				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				     DC_I2C_COUNT0, length,
+				     DC_I2C_STOP0, last_transaction ? 1 : 0);
+			break;
+		case 1:
+			REG_UPDATE_5(DC_I2C_TRANSACTION1,
+				     DC_I2C_STOP_ON_NACK0, 1,
+				     DC_I2C_START0, 1,
+				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				     DC_I2C_COUNT0, length,
+				     DC_I2C_STOP0, last_transaction ? 1 : 0);
+			break;
+		case 2:
+			REG_UPDATE_5(DC_I2C_TRANSACTION2,
+				     DC_I2C_STOP_ON_NACK0, 1,
+				     DC_I2C_START0, 1,
+				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				     DC_I2C_COUNT0, length,
+				     DC_I2C_STOP0, last_transaction ? 1 : 0);
+			break;
+		case 3:
+			REG_UPDATE_5(DC_I2C_TRANSACTION3,
+				     DC_I2C_STOP_ON_NACK0, 1,
+				     DC_I2C_START0, 1,
+				     DC_I2C_RW0, 0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ),
+				     DC_I2C_COUNT0, length,
+				     DC_I2C_STOP0, last_transaction ? 1 : 0);
+			break;
+		default:
+			/* TODO Warning ? */
+			break;
+		}
+	}
+
+	/* Write the I2C address and I2C data
+	 * into the hardware circular buffer, one byte per entry.
+	 * As an example, the 7-bit I2C slave address for CRT monitor
+	 * for reading DDC/EDID information is 0b1010001.
+	 * For an I2C send operation, the LSB must be programmed to 0;
+	 * for I2C receive operation, the LSB must be programmed to 1.
+	 */
+
+	{
+		if (dce_i2c_hw->transaction_count == 0) {
+			value = REG_SET_4(DC_I2C_DATA, 0,
+					 DC_I2C_DATA_RW, false,
+					 DC_I2C_DATA, request->address,
+					 DC_I2C_INDEX, 0,
+					 DC_I2C_INDEX_WRITE, 1);
+		} else
+			value = REG_SET_2(DC_I2C_DATA, 0,
+					 DC_I2C_DATA_RW, false,
+					 DC_I2C_DATA, request->address);
+
+		if (!(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ)) {
+
+			while (length) {
+				REG_SET_2(DC_I2C_DATA, value,
+					 DC_I2C_INDEX_WRITE, 0,
+					 DC_I2C_DATA, *buffer++);
+				--length;
+			}
+		}
+	}
+
+	++dce_i2c_hw->transaction_count;
+	dce_i2c_hw->buffer_used_bytes += length + 1;
+
+	return last_transaction;
+}
+
+#define STOP_TRANS_PREDICAT \
+		((dce_i2c_hw->transaction_count == 3) ||	\
+				(request->action == DCE_I2C_TRANSACTION_ACTION_I2C_WRITE) ||	\
+				(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ))
+
+#define SET_I2C_TRANSACTION(id)	\
+		do {	\
+			REG_UPDATE_N(DC_I2C_TRANSACTION##id, 5,	\
+				FN(DC_I2C_TRANSACTION0, DC_I2C_STOP_ON_NACK0), 1,	\
+				FN(DC_I2C_TRANSACTION0, DC_I2C_START0), 1,	\
+				FN(DC_I2C_TRANSACTION0, DC_I2C_STOP0), STOP_TRANS_PREDICAT ? 1:0,	\
+				FN(DC_I2C_TRANSACTION0, DC_I2C_RW0), (0 != (request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ)),	\
+				FN(DC_I2C_TRANSACTION0, DC_I2C_COUNT0), length);	\
+				if (STOP_TRANS_PREDICAT)	\
+					last_transaction = true;	\
+		} while (false)
+
+static bool process_transaction_hw_dce100(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct i2c_request_transaction_data *request)
+{
+	uint32_t length = request->length;
+	uint8_t *buffer = request->data;
+	uint32_t value = 0;
+
+	bool last_transaction = false;
+
+	switch (dce_i2c_hw->transaction_count) {
+	case 0:
+		SET_I2C_TRANSACTION(0);
+		break;
+	case 1:
+		SET_I2C_TRANSACTION(1);
+		break;
+	case 2:
+		SET_I2C_TRANSACTION(2);
+		break;
+	case 3:
+		SET_I2C_TRANSACTION(3);
+		break;
+	default:
+		/* TODO Warning ? */
+		break;
+	}
+
+
+	/* Write the I2C address and I2C data
+	 * into the hardware circular buffer, one byte per entry.
+	 * As an example, the 7-bit I2C slave address for CRT monitor
+	 * for reading DDC/EDID information is 0b1010001.
+	 * For an I2C send operation, the LSB must be programmed to 0;
+	 * for I2C receive operation, the LSB must be programmed to 1.
+	 */
+	if (dce_i2c_hw->transaction_count == 0) {
+		value = REG_SET_4(DC_I2C_DATA, 0,
+				  DC_I2C_DATA_RW, false,
+				  DC_I2C_DATA, request->address,
+				  DC_I2C_INDEX, 0,
+				  DC_I2C_INDEX_WRITE, 1);
+		dce_i2c_hw->buffer_used_write = 0;
+	} else
+		value = REG_SET_2(DC_I2C_DATA, 0,
+			  DC_I2C_DATA_RW, false,
+			  DC_I2C_DATA, request->address);
+
+	dce_i2c_hw->buffer_used_write++;
+
+	if (!(request->action & DCE_I2C_TRANSACTION_ACTION_I2C_READ)) {
+		while (length) {
+			REG_SET_2(DC_I2C_DATA, value,
+				  DC_I2C_INDEX_WRITE, 0,
+				  DC_I2C_DATA, *buffer++);
+			dce_i2c_hw->buffer_used_write++;
+			--length;
+		}
+	}
+
+	++dce_i2c_hw->transaction_count;
+	dce_i2c_hw->buffer_used_bytes += length + 1;
+
+	return last_transaction;
+}
+static uint32_t get_transaction_timeout_hw(
+	const struct dce_i2c_hw *dce_i2c_hw,
+	uint32_t length)
+{
+
+	uint32_t speed = dce_i2c_hw->funcs->get_speed(dce_i2c_hw);
+
+
+
+	uint32_t period_timeout;
+	uint32_t num_of_clock_stretches;
+
+	if (!speed)
+		return 0;
+
+	period_timeout = (1000 * TRANSACTION_TIMEOUT_IN_I2C_CLOCKS) / speed;
+
+	num_of_clock_stretches = 1 + (length << 3) + 1;
+	num_of_clock_stretches +=
+		(dce_i2c_hw->buffer_used_bytes << 3) +
+		(dce_i2c_hw->transaction_count << 1);
+
+	return period_timeout * num_of_clock_stretches;
+}
+
+static void release_engine_dce_hw(
+	struct resource_pool *pool,
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	pool->i2c_hw_buffer_in_use = false;
+
+	dce_i2c_hw->funcs->release_engine(dce_i2c_hw);
+	dal_ddc_close(dce_i2c_hw->ddc);
+
+	dce_i2c_hw->ddc = NULL;
+}
+
+static void release_engine_hw(
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	bool safe_to_reset;
+
+	/* Restore original HW engine speed */
+
+	dce_i2c_hw->funcs->set_speed(dce_i2c_hw, dce_i2c_hw->original_speed);
+
+	/* Release I2C */
+	REG_UPDATE(DC_I2C_ARBITRATION, DC_I2C_SW_DONE_USING_I2C_REG, 1);
+
+	/* Reset HW engine */
+	{
+		uint32_t i2c_sw_status = 0;
+
+		REG_GET(DC_I2C_SW_STATUS, DC_I2C_SW_STATUS, &i2c_sw_status);
+		/* if used by SW, safe to reset */
+		safe_to_reset = (i2c_sw_status == 1);
+	}
+
+	if (safe_to_reset)
+		REG_UPDATE_2(DC_I2C_CONTROL,
+			     DC_I2C_SOFT_RESET, 1,
+			     DC_I2C_SW_STATUS_RESET, 1);
+	else
+		REG_UPDATE(DC_I2C_CONTROL, DC_I2C_SW_STATUS_RESET, 1);
+	/* HW I2c engine - clock gating feature */
+	if (!dce_i2c_hw->engine_keep_power_up_count)
+		dce_i2c_hw->funcs->disable_i2c_hw_engine(dce_i2c_hw);
+
+}
+
+
+static void disable_i2c_hw_engine(
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	REG_UPDATE_N(SETUP, 1, FN(SETUP, DC_I2C_DDC1_ENABLE), 0);
+}
+static uint32_t get_speed_hw(
+	const struct dce_i2c_hw *dce_i2c_hw)
+{
+	uint32_t pre_scale = 0;
+
+	REG_GET(SPEED, DC_I2C_DDC1_PRESCALE, &pre_scale);
+
+	/* [anaumov] it seems following is unnecessary */
+	/*ASSERT(value.bits.DC_I2C_DDC1_PRESCALE);*/
+	return pre_scale ?
+		dce_i2c_hw->reference_frequency / pre_scale :
+		dce_i2c_hw->default_speed;
+}
+static uint32_t get_hw_buffer_available_size(
+	const struct dce_i2c_hw *dce_i2c_hw)
+{
+	return dce_i2c_hw->buffer_size -
+			dce_i2c_hw->buffer_used_bytes;
+}
+bool dce_i2c_hw_engine_submit_request(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct dce_i2c_transaction_request *dce_i2c_request,
+	bool middle_of_transaction)
+{
+
+	struct i2c_request_transaction_data request;
+
+	uint32_t transaction_timeout;
+
+	enum i2c_channel_operation_result operation_result;
+
+	bool result = false;
+
+	/* We need following:
+	 * transaction length will not exceed
+	 * the number of free bytes in HW buffer (minus one for address)
+	 */
+
+	if (dce_i2c_request->payload.length >=
+			get_hw_buffer_available_size(dce_i2c_hw)) {
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_BUFFER_OVERFLOW;
+		return false;
+	}
+
+	if (dce_i2c_request->operation == DCE_I2C_TRANSACTION_READ)
+		request.action = middle_of_transaction ?
+			DCE_I2C_TRANSACTION_ACTION_I2C_READ_MOT :
+			DCE_I2C_TRANSACTION_ACTION_I2C_READ;
+	else if (dce_i2c_request->operation == DCE_I2C_TRANSACTION_WRITE)
+		request.action = middle_of_transaction ?
+			DCE_I2C_TRANSACTION_ACTION_I2C_WRITE_MOT :
+			DCE_I2C_TRANSACTION_ACTION_I2C_WRITE;
+	else {
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_INVALID_OPERATION;
+		/* [anaumov] in DAL2, there was no "return false" */
+		return false;
+	}
+
+	request.address = (uint8_t) dce_i2c_request->payload.address;
+	request.length = dce_i2c_request->payload.length;
+	request.data = dce_i2c_request->payload.data;
+
+	/* obtain timeout value before submitting request */
+
+	transaction_timeout = get_transaction_timeout_hw(
+		dce_i2c_hw, dce_i2c_request->payload.length + 1);
+
+	submit_channel_request_hw(
+		dce_i2c_hw, &request);
+
+	if ((request.status == I2C_CHANNEL_OPERATION_FAILED) ||
+		(request.status == I2C_CHANNEL_OPERATION_ENGINE_BUSY)) {
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_CHANNEL_BUSY;
+		return false;
+	}
+
+	/* wait until transaction proceed */
+
+	operation_result = dce_i2c_hw_engine_wait_on_operation_result(
+		dce_i2c_hw,
+		transaction_timeout,
+		I2C_CHANNEL_OPERATION_ENGINE_BUSY);
+
+	/* update transaction status */
+
+	switch (operation_result) {
+	case I2C_CHANNEL_OPERATION_SUCCEEDED:
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_SUCCEEDED;
+		result = true;
+	break;
+	case I2C_CHANNEL_OPERATION_NO_RESPONSE:
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_NACK;
+	break;
+	case I2C_CHANNEL_OPERATION_TIMEOUT:
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_TIMEOUT;
+	break;
+	case I2C_CHANNEL_OPERATION_FAILED:
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_INCOMPLETE;
+	break;
+	default:
+		dce_i2c_request->status =
+			DCE_I2C_TRANSACTION_STATUS_FAILED_OPERATION;
+	}
+
+	if (result && (dce_i2c_request->operation == DCE_I2C_TRANSACTION_READ)) {
+		struct i2c_reply_transaction_data reply;
+
+		reply.data = dce_i2c_request->payload.data;
+		reply.length = dce_i2c_request->payload.length;
+
+		dce_i2c_hw->funcs->process_channel_reply(dce_i2c_hw, &reply);
+
+
+	}
+
+	return result;
+}
+
+bool dce_i2c_submit_command_hw(
+	struct resource_pool *pool,
+	struct ddc *ddc,
+	struct i2c_command *cmd,
+	struct dce_i2c_hw *dce_i2c_hw)
+{
+	uint8_t index_of_payload = 0;
+	bool result;
+
+	dce_i2c_hw->funcs->set_speed(dce_i2c_hw, cmd->speed);
+
+	result = true;
+
+	while (index_of_payload < cmd->number_of_payloads) {
+		bool mot = (index_of_payload != cmd->number_of_payloads - 1);
+
+		struct i2c_payload *payload = cmd->payloads + index_of_payload;
+
+		struct dce_i2c_transaction_request request = { 0 };
+
+		request.operation = payload->write ?
+			DCE_I2C_TRANSACTION_WRITE :
+			DCE_I2C_TRANSACTION_READ;
+
+		request.payload.address_space =
+			DCE_I2C_TRANSACTION_ADDRESS_SPACE_I2C;
+		request.payload.address = (payload->address << 1) |
+			!payload->write;
+		request.payload.length = payload->length;
+		request.payload.data = payload->data;
+
+
+		if (!dce_i2c_hw_engine_submit_request(
+				dce_i2c_hw, &request, mot)) {
+			result = false;
+			break;
+		}
+
+
+
+		++index_of_payload;
+	}
+
+	release_engine_dce_hw(pool, dce_i2c_hw);
+
+	return result;
+}
+static const struct dce_i2c_hw_funcs dce100_i2c_hw_funcs = {
+		.setup_engine = setup_engine_hw_dce100,
+		.set_speed = set_speed_hw_dce100,
+		.get_speed = get_speed_hw,
+		.release_engine = release_engine_hw,
+		.process_transaction = process_transaction_hw_dce100,
+		.process_channel_reply = process_channel_reply_hw_dce100,
+		.is_hw_busy = is_hw_busy,
+		.get_channel_status = get_channel_status_hw,
+		.execute_transaction = execute_transaction_hw,
+		.disable_i2c_hw_engine = disable_i2c_hw_engine
+};
+static const struct dce_i2c_hw_funcs dce80_i2c_hw_funcs = {
+		.setup_engine = setup_engine_hw_dce80,
+		.set_speed = set_speed_hw_dce80,
+		.get_speed = get_speed_hw,
+		.release_engine = release_engine_hw,
+		.process_transaction = process_transaction_hw_dce80,
+		.process_channel_reply = process_channel_reply_hw_dce80,
+		.is_hw_busy = is_hw_busy,
+		.get_channel_status = get_channel_status_hw,
+		.execute_transaction = execute_transaction_hw,
+		.disable_i2c_hw_engine = disable_i2c_hw_engine
+};
+
+
+
+void dce_i2c_hw_construct(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct dc_context *ctx,
+	uint32_t engine_id,
+	const struct dce_i2c_registers *regs,
+	const struct dce_i2c_shift *shifts,
+	const struct dce_i2c_mask *masks)
+{
+	dce_i2c_hw->ctx = ctx;
+	dce_i2c_hw->engine_id = engine_id;
+	dce_i2c_hw->reference_frequency = get_reference_clock(ctx->dc_bios) >> 1;
+	dce_i2c_hw->regs = regs;
+	dce_i2c_hw->shifts = shifts;
+	dce_i2c_hw->masks = masks;
+	dce_i2c_hw->buffer_used_bytes = 0;
+	dce_i2c_hw->transaction_count = 0;
+	dce_i2c_hw->engine_keep_power_up_count = 1;
+	dce_i2c_hw->original_speed = DEFAULT_I2C_HW_SPEED;
+	dce_i2c_hw->default_speed = DEFAULT_I2C_HW_SPEED;
+	dce_i2c_hw->send_reset_length = 0;
+	dce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCE;
+	dce_i2c_hw->funcs = &dce80_i2c_hw_funcs;
+	dce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE;
+}
+
+void dce100_i2c_hw_construct(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct dc_context *ctx,
+	uint32_t engine_id,
+	const struct dce_i2c_registers *regs,
+	const struct dce_i2c_shift *shifts,
+	const struct dce_i2c_mask *masks)
+{
+
+	uint32_t xtal_ref_div = 0;
+
+	dce_i2c_hw_construct(dce_i2c_hw,
+			ctx,
+			engine_id,
+			regs,
+			shifts,
+			masks);
+	dce_i2c_hw->funcs = &dce100_i2c_hw_funcs;
+	dce_i2c_hw->buffer_size = I2C_HW_BUFFER_SIZE_DCE100;
+
+	REG_GET(MICROSECOND_TIME_BASE_DIV, XTAL_REF_DIV, &xtal_ref_div);
+
+	if (xtal_ref_div == 0)
+		xtal_ref_div = 2;
+
+	/*Calculating Reference Clock by divding original frequency by
+	 * XTAL_REF_DIV.
+	 * At upper level, uint32_t reference_frequency =
+	 *  dal_dce_i2c_get_reference_clock(as) >> 1
+	 *  which already divided by 2. So we need x2 to get original
+	 *  reference clock from ppll_info
+	 */
+	dce_i2c_hw->reference_frequency =
+		(dce_i2c_hw->reference_frequency * 2) / xtal_ref_div;
+}
+
+void dce112_i2c_hw_construct(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct dc_context *ctx,
+	uint32_t engine_id,
+	const struct dce_i2c_registers *regs,
+	const struct dce_i2c_shift *shifts,
+	const struct dce_i2c_mask *masks)
+{
+	dce100_i2c_hw_construct(dce_i2c_hw,
+			ctx,
+			engine_id,
+			regs,
+			shifts,
+			masks);
+	dce_i2c_hw->default_speed = DEFAULT_I2C_HW_SPEED_100KHZ;
+}
+
+void dcn1_i2c_hw_construct(
+	struct dce_i2c_hw *dce_i2c_hw,
+	struct dc_context *ctx,
+	uint32_t engine_id,
+	const struct dce_i2c_registers *regs,
+	const struct dce_i2c_shift *shifts,
+	const struct dce_i2c_mask *masks)
+{
+	dce112_i2c_hw_construct(dce_i2c_hw,
+			ctx,
+			engine_id,
+			regs,
+			shifts,
+			masks);
+	dce_i2c_hw->setup_limit = I2C_SETUP_TIME_LIMIT_DCN;
+}
+
