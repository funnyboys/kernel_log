commit ded33f368c903dc973b2bca79b783864a6088537
Author: Joe Perches <joe@perches.com>
Date:   Tue Mar 10 21:51:38 2020 -0700

    AMD DISPLAY CORE: Use fallthrough;
    
    Convert the various uses of fallthrough comments to fallthrough;
    
    Done via script
    Link: https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 8aa937f496c4..51481e922eb9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -479,7 +479,7 @@ static void program_grph_pixel_format(
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
 		sign = 1;
 		floating = 1;
-		/* fall through */
+		fallthrough;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F: /* shouldn't this get float too? */
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
 		grph_depth = 3;

commit 60233044d85a60fff9093b85b3183e199e17be49
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Sep 13 09:02:48 2019 +0100

    drm/amd/display: rename variable eanble -> enable
    
    There is a spelling mistake in the variable name eanble,
    rename it to enable.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 31b698bf9cfc..8aa937f496c4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -606,11 +606,11 @@ static void dce_mi_allocate_dmif(
 	}
 
 	if (dce_mi->wa.single_head_rdreq_dmif_limit) {
-		uint32_t eanble =  (total_stream_num > 1) ? 0 :
+		uint32_t enable =  (total_stream_num > 1) ? 0 :
 				dce_mi->wa.single_head_rdreq_dmif_limit;
 
 		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
-				ENABLE, eanble);
+				ENABLE, enable);
 	}
 }
 
@@ -636,11 +636,11 @@ static void dce_mi_free_dmif(
 			10, 3500);
 
 	if (dce_mi->wa.single_head_rdreq_dmif_limit) {
-		uint32_t eanble =  (total_stream_num > 1) ? 0 :
+		uint32_t enable =  (total_stream_num > 1) ? 0 :
 				dce_mi->wa.single_head_rdreq_dmif_limit;
 
 		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
-				ENABLE, eanble);
+				ENABLE, enable);
 	}
 }
 

commit d6bbece2c419debff6fc6b3c7a59fbede53bdef3
Author: Charlene Liu <charlene.liu@amd.com>
Date:   Tue Aug 20 20:33:46 2019 -0400

    drm/amd/display: dce11.x /dce12 update formula input
    
    [Description]
    1. OUTSTANDING_REQUEST_LIMIT update from 0xFF to 0x1F (HW doc update)
    2. using memory type to convert UMC's MCLK to Yclk.
    
    Signed-off-by: Charlene Liu <charlene.liu@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 1488ffddf4e3..31b698bf9cfc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -148,7 +148,7 @@ static void dce_mi_program_pte_vm(
 			pte->min_pte_before_flip_horiz_scan;
 
 	REG_UPDATE(GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT,
-			GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, 0xff);
+			GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, 0x7f);
 
 	REG_UPDATE_3(DVMM_PTE_CONTROL,
 			DVMM_PAGE_WIDTH, page_width,
@@ -157,7 +157,7 @@ static void dce_mi_program_pte_vm(
 
 	REG_UPDATE_2(DVMM_PTE_ARB_CONTROL,
 			DVMM_PTE_REQ_PER_CHUNK, pte->pte_req_per_chunk,
-			DVMM_MAX_PTE_REQ_OUTSTANDING, 0xff);
+			DVMM_MAX_PTE_REQ_OUTSTANDING, 0x7f);
 }
 
 static void program_urgency_watermark(

commit 12e2b2d4c65f6164830e25fcd9624519a424b182
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Jul 3 16:20:42 2019 -0400

    drm/amd/display: add dcc programming for dual plane
    
    Add dual plane dcc programming support for
    surfaces.
    
    Removes unions from plane size and dcc params as they
    serve no practical purpose only making our code
    more convoluted. This results in easy dual plane
    dcc and surface size programming.
    
    Temporary diags_dm code is used to handle the interface
    change without breaking functionality as a diags change
    needs to be applied after this one.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index a24a2bda8656..1488ffddf4e3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -391,10 +391,10 @@ static void program_tiling(
 static void program_size_and_rotation(
 	struct dce_mem_input *dce_mi,
 	enum dc_rotation_angle rotation,
-	const union plane_size *plane_size)
+	const struct plane_size *plane_size)
 {
-	const struct rect *in_rect = &plane_size->grph.surface_size;
-	struct rect hw_rect = plane_size->grph.surface_size;
+	const struct rect *in_rect = &plane_size->surface_size;
+	struct rect hw_rect = plane_size->surface_size;
 	const uint32_t rotation_angles[ROTATION_ANGLE_COUNT] = {
 			[ROTATION_ANGLE_0] = 0,
 			[ROTATION_ANGLE_90] = 1,
@@ -423,7 +423,7 @@ static void program_size_and_rotation(
 			GRPH_Y_END, hw_rect.height);
 
 	REG_SET(GRPH_PITCH, 0,
-			GRPH_PITCH, plane_size->grph.surface_pitch);
+			GRPH_PITCH, plane_size->surface_pitch);
 
 	REG_SET(HW_ROTATION, 0,
 			GRPH_ROTATION_ANGLE, rotation_angles[rotation]);
@@ -505,7 +505,7 @@ static void dce_mi_program_surface_config(
 	struct mem_input *mi,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
-	union plane_size *plane_size,
+	struct plane_size *plane_size,
 	enum dc_rotation_angle rotation,
 	struct dc_plane_dcc_param *dcc,
 	bool horizontal_mirror)

commit c81e5efeec48bd9c8dab08554d0209e5ea6cca1c
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 15 10:54:42 2019 -0600

    drm/amd/display/dce_mem_input: Mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch
    cases where we are expecting to fall through.
    
    Warning level 3 was used: -Wimplicit-fallthrough=3
    
    Notice that, in this particular case, the code comment is modified
    in accordance with what GCC is expecting to find.
    
    This patch is part of the ongoing efforts to enable
    -Wimplicit-fallthrough.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 85686d917636..a24a2bda8656 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -479,7 +479,7 @@ static void program_grph_pixel_format(
 	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
 		sign = 1;
 		floating = 1;
-		/* no break */
+		/* fall through */
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F: /* shouldn't this get float too? */
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
 		grph_depth = 3;

commit a14cc8422a2601348bc5279c1d849920e91170f2
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Jul 6 14:19:07 2018 +0200

    drm/amd/display: make function tables const
    
    It is good practice to make global function tables const to avoid
    accidental override.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index bae752332a9f..85686d917636 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -729,7 +729,7 @@ static bool dce_mi_program_surface_flip_and_addr(
 	return true;
 }
 
-static struct mem_input_funcs dce_mi_funcs = {
+static const struct mem_input_funcs dce_mi_funcs = {
 	.mem_input_program_display_marks = dce_mi_program_display_marks,
 	.allocate_mem_input = dce_mi_allocate_dmif,
 	.free_mem_input = dce_mi_free_dmif,
@@ -741,7 +741,7 @@ static struct mem_input_funcs dce_mi_funcs = {
 	.mem_input_is_flip_pending = dce_mi_is_flip_pending
 };
 
-static struct mem_input_funcs dce112_mi_funcs = {
+static const struct mem_input_funcs dce112_mi_funcs = {
 	.mem_input_program_display_marks = dce112_mi_program_display_marks,
 	.allocate_mem_input = dce_mi_allocate_dmif,
 	.free_mem_input = dce_mi_free_dmif,
@@ -753,7 +753,7 @@ static struct mem_input_funcs dce112_mi_funcs = {
 	.mem_input_is_flip_pending = dce_mi_is_flip_pending
 };
 
-static struct mem_input_funcs dce120_mi_funcs = {
+static const struct mem_input_funcs dce120_mi_funcs = {
 	.mem_input_program_display_marks = dce120_mi_program_display_marks,
 	.allocate_mem_input = dce_mi_allocate_dmif,
 	.free_mem_input = dce_mi_free_dmif,

commit 10e7fddd4aebf95a9468f20fc1a87e6238b7d8d4
Author: Christian König <christian.koenig@amd.com>
Date:   Fri Jul 6 13:46:05 2018 +0200

    drm/amd/display: fix invalid function table override
    
    Otherwise we try to program hardware with the wrong watermark functions
    when multiple DCE generations are installed in one system.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index b235a75355b8..bae752332a9f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -741,6 +741,29 @@ static struct mem_input_funcs dce_mi_funcs = {
 	.mem_input_is_flip_pending = dce_mi_is_flip_pending
 };
 
+static struct mem_input_funcs dce112_mi_funcs = {
+	.mem_input_program_display_marks = dce112_mi_program_display_marks,
+	.allocate_mem_input = dce_mi_allocate_dmif,
+	.free_mem_input = dce_mi_free_dmif,
+	.mem_input_program_surface_flip_and_addr =
+			dce_mi_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm = dce_mi_program_pte_vm,
+	.mem_input_program_surface_config =
+			dce_mi_program_surface_config,
+	.mem_input_is_flip_pending = dce_mi_is_flip_pending
+};
+
+static struct mem_input_funcs dce120_mi_funcs = {
+	.mem_input_program_display_marks = dce120_mi_program_display_marks,
+	.allocate_mem_input = dce_mi_allocate_dmif,
+	.free_mem_input = dce_mi_free_dmif,
+	.mem_input_program_surface_flip_and_addr =
+			dce_mi_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm = dce_mi_program_pte_vm,
+	.mem_input_program_surface_config =
+			dce_mi_program_surface_config,
+	.mem_input_is_flip_pending = dce_mi_is_flip_pending
+};
 
 void dce_mem_input_construct(
 	struct dce_mem_input *dce_mi,
@@ -769,7 +792,7 @@ void dce112_mem_input_construct(
 	const struct dce_mem_input_mask *mi_mask)
 {
 	dce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);
-	dce_mi->base.funcs->mem_input_program_display_marks = dce112_mi_program_display_marks;
+	dce_mi->base.funcs = &dce112_mi_funcs;
 }
 
 void dce120_mem_input_construct(
@@ -781,5 +804,5 @@ void dce120_mem_input_construct(
 	const struct dce_mem_input_mask *mi_mask)
 {
 	dce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);
-	dce_mi->base.funcs->mem_input_program_display_marks = dce120_mi_program_display_marks;
+	dce_mi->base.funcs = &dce120_mi_funcs;
 }

commit d72eb20379022a948c219e1fc451b6b0200cc7c5
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Wed Mar 14 14:42:25 2018 -0400

    drm/amd/display: Separate mem input constuctors for dce 112 and 120
    
    Override the memory input functions for dce120 not to program
    new registers on dce112.
    This will fix warnings thrown on Polaris asics.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 04fc86bb95a1..b235a75355b8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -225,7 +225,7 @@ static void program_nbp_watermark(
 	}
 }
 
-static void program_stutter_watermark(
+static void dce120_program_stutter_watermark(
 	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t stutter_mark,
@@ -244,6 +244,22 @@ static void program_stutter_watermark(
 				STUTTER_ENTER_SELF_REFRESH_WATERMARK, stutter_entry);
 }
 
+static void program_stutter_watermark(
+	struct dce_mem_input *dce_mi,
+	uint32_t wm_select,
+	uint32_t stutter_mark)
+{
+	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
+		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);
+
+	if (REG(DPG_PIPE_STUTTER_CONTROL2))
+		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL2,
+				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
+	else
+		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL,
+				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
+}
+
 static void dce_mi_program_display_marks(
 	struct mem_input *mi,
 	struct dce_watermarks nbp,
@@ -266,8 +282,41 @@ static void dce_mi_program_display_marks(
 	program_nbp_watermark(dce_mi, 2, nbp.a_mark); /* set a */
 	program_nbp_watermark(dce_mi, 1, nbp.d_mark); /* set d */
 
-	program_stutter_watermark(dce_mi, 2, stutter_exit.a_mark, stutter_enter.a_mark); /* set a */
-	program_stutter_watermark(dce_mi, 1, stutter_exit.d_mark, stutter_enter.d_mark); /* set d */
+	program_stutter_watermark(dce_mi, 2, stutter_exit.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter_exit.d_mark); /* set d */
+}
+
+static void dce112_mi_program_display_marks(struct mem_input *mi,
+	struct dce_watermarks nbp,
+	struct dce_watermarks stutter_exit,
+	struct dce_watermarks stutter_entry,
+	struct dce_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
+	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
+
+	program_urgency_watermark(dce_mi, 0, /* set a */
+			urgent.a_mark, total_dest_line_time_ns);
+	program_urgency_watermark(dce_mi, 1, /* set b */
+			urgent.b_mark, total_dest_line_time_ns);
+	program_urgency_watermark(dce_mi, 2, /* set c */
+			urgent.c_mark, total_dest_line_time_ns);
+	program_urgency_watermark(dce_mi, 3, /* set d */
+			urgent.d_mark, total_dest_line_time_ns);
+
+	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
+		STUTTER_ENABLE, stutter_en,
+		STUTTER_IGNORE_FBC, 1);
+	program_nbp_watermark(dce_mi, 0, nbp.a_mark); /* set a */
+	program_nbp_watermark(dce_mi, 1, nbp.b_mark); /* set b */
+	program_nbp_watermark(dce_mi, 2, nbp.c_mark); /* set c */
+	program_nbp_watermark(dce_mi, 3, nbp.d_mark); /* set d */
+
+	program_stutter_watermark(dce_mi, 0, stutter_exit.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter_exit.b_mark); /* set b */
+	program_stutter_watermark(dce_mi, 2, stutter_exit.c_mark); /* set c */
+	program_stutter_watermark(dce_mi, 3, stutter_exit.d_mark); /* set d */
 }
 
 static void dce120_mi_program_display_marks(struct mem_input *mi,
@@ -297,10 +346,10 @@ static void dce120_mi_program_display_marks(struct mem_input *mi,
 	program_nbp_watermark(dce_mi, 2, nbp.c_mark); /* set c */
 	program_nbp_watermark(dce_mi, 3, nbp.d_mark); /* set d */
 
-	program_stutter_watermark(dce_mi, 0, stutter_exit.a_mark, stutter_entry.a_mark); /* set a */
-	program_stutter_watermark(dce_mi, 1, stutter_exit.b_mark, stutter_entry.b_mark); /* set b */
-	program_stutter_watermark(dce_mi, 2, stutter_exit.c_mark, stutter_entry.c_mark); /* set c */
-	program_stutter_watermark(dce_mi, 3, stutter_exit.d_mark, stutter_entry.d_mark); /* set d */
+	dce120_program_stutter_watermark(dce_mi, 0, stutter_exit.a_mark, stutter_entry.a_mark); /* set a */
+	dce120_program_stutter_watermark(dce_mi, 1, stutter_exit.b_mark, stutter_entry.b_mark); /* set b */
+	dce120_program_stutter_watermark(dce_mi, 2, stutter_exit.c_mark, stutter_entry.c_mark); /* set c */
+	dce120_program_stutter_watermark(dce_mi, 3, stutter_exit.d_mark, stutter_entry.d_mark); /* set d */
 }
 
 static void program_tiling(
@@ -718,6 +767,18 @@ void dce112_mem_input_construct(
 	const struct dce_mem_input_registers *regs,
 	const struct dce_mem_input_shift *mi_shift,
 	const struct dce_mem_input_mask *mi_mask)
+{
+	dce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);
+	dce_mi->base.funcs->mem_input_program_display_marks = dce112_mi_program_display_marks;
+}
+
+void dce120_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask)
 {
 	dce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);
 	dce_mi->base.funcs->mem_input_program_display_marks = dce120_mi_program_display_marks;

commit 3722c794641f91e0b960dd901d6c5d2f3cc24080
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Wed Feb 21 16:57:10 2018 -0500

    drm/amd/display: Implementing new bandwidth registers for DCE120
    
    Registers are added and defined.
    Programmed to default values.
    Stutter level watermark register is being set to calculated value.
    Urgent level registers are programmed to the same as urgency.
    The programming of the registers is not expected to have any
    functional difference in performance.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 0790f25c7b3b..04fc86bb95a1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -174,6 +174,25 @@ static void program_urgency_watermark(
 		URGENCY_HIGH_WATERMARK, urgency_high_wm);
 }
 
+static void dce120_program_urgency_watermark(
+	struct dce_mem_input *dce_mi,
+	uint32_t wm_select,
+	uint32_t urgency_low_wm,
+	uint32_t urgency_high_wm)
+{
+	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
+		URGENCY_WATERMARK_MASK, wm_select);
+
+	REG_SET_2(DPG_PIPE_URGENCY_CONTROL, 0,
+		URGENCY_LOW_WATERMARK, urgency_low_wm,
+		URGENCY_HIGH_WATERMARK, urgency_high_wm);
+
+	REG_SET_2(DPG_PIPE_URGENT_LEVEL_CONTROL, 0,
+		URGENT_LEVEL_LOW_WATERMARK, urgency_low_wm,
+		URGENT_LEVEL_HIGH_WATERMARK, urgency_high_wm);
+
+}
+
 static void program_nbp_watermark(
 	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
@@ -209,23 +228,27 @@ static void program_nbp_watermark(
 static void program_stutter_watermark(
 	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
-	uint32_t stutter_mark)
+	uint32_t stutter_mark,
+	uint32_t stutter_entry)
 {
 	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);
 
 	if (REG(DPG_PIPE_STUTTER_CONTROL2))
-		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL2,
-				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
+		REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL2,
+				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark,
+				STUTTER_ENTER_SELF_REFRESH_WATERMARK, stutter_entry);
 	else
-		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL,
-				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
+		REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
+				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark,
+				STUTTER_ENTER_SELF_REFRESH_WATERMARK, stutter_entry);
 }
 
 static void dce_mi_program_display_marks(
 	struct mem_input *mi,
 	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
+	struct dce_watermarks stutter_exit,
+	struct dce_watermarks stutter_enter,
 	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
@@ -243,26 +266,27 @@ static void dce_mi_program_display_marks(
 	program_nbp_watermark(dce_mi, 2, nbp.a_mark); /* set a */
 	program_nbp_watermark(dce_mi, 1, nbp.d_mark); /* set d */
 
-	program_stutter_watermark(dce_mi, 2, stutter.a_mark); /* set a */
-	program_stutter_watermark(dce_mi, 1, stutter.d_mark); /* set d */
+	program_stutter_watermark(dce_mi, 2, stutter_exit.a_mark, stutter_enter.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter_exit.d_mark, stutter_enter.d_mark); /* set d */
 }
 
 static void dce120_mi_program_display_marks(struct mem_input *mi,
 	struct dce_watermarks nbp,
-	struct dce_watermarks stutter,
+	struct dce_watermarks stutter_exit,
+	struct dce_watermarks stutter_entry,
 	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
 	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
 
-	program_urgency_watermark(dce_mi, 0, /* set a */
+	dce120_program_urgency_watermark(dce_mi, 0, /* set a */
 			urgent.a_mark, total_dest_line_time_ns);
-	program_urgency_watermark(dce_mi, 1, /* set b */
+	dce120_program_urgency_watermark(dce_mi, 1, /* set b */
 			urgent.b_mark, total_dest_line_time_ns);
-	program_urgency_watermark(dce_mi, 2, /* set c */
+	dce120_program_urgency_watermark(dce_mi, 2, /* set c */
 			urgent.c_mark, total_dest_line_time_ns);
-	program_urgency_watermark(dce_mi, 3, /* set d */
+	dce120_program_urgency_watermark(dce_mi, 3, /* set d */
 			urgent.d_mark, total_dest_line_time_ns);
 
 	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
@@ -273,10 +297,10 @@ static void dce120_mi_program_display_marks(struct mem_input *mi,
 	program_nbp_watermark(dce_mi, 2, nbp.c_mark); /* set c */
 	program_nbp_watermark(dce_mi, 3, nbp.d_mark); /* set d */
 
-	program_stutter_watermark(dce_mi, 0, stutter.a_mark); /* set a */
-	program_stutter_watermark(dce_mi, 1, stutter.b_mark); /* set b */
-	program_stutter_watermark(dce_mi, 2, stutter.c_mark); /* set c */
-	program_stutter_watermark(dce_mi, 3, stutter.d_mark); /* set d */
+	program_stutter_watermark(dce_mi, 0, stutter_exit.a_mark, stutter_entry.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter_exit.b_mark, stutter_entry.b_mark); /* set b */
+	program_stutter_watermark(dce_mi, 2, stutter_exit.c_mark, stutter_entry.c_mark); /* set c */
+	program_stutter_watermark(dce_mi, 3, stutter_exit.d_mark, stutter_entry.d_mark); /* set d */
 }
 
 static void program_tiling(

commit 4beb50ff5e96014787d8588a78d07e49df0d114a
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Oct 4 13:54:35 2017 -0400

    drm/amd/display: Fix warning about uninitialized variable
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index ed301c3b2736..0790f25c7b3b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -361,7 +361,7 @@ static void program_grph_pixel_format(
 	enum surface_pixel_format format)
 {
 	uint32_t red_xbar = 0, blue_xbar = 0; /* no swap */
-	uint32_t grph_depth, grph_format;
+	uint32_t grph_depth = 0, grph_format = 0;
 	uint32_t sign = 0, floating = 0;
 
 	if (format == SURFACE_PIXEL_FORMAT_GRPH_ABGR8888 ||

commit 8feabd03d34e4555c119e69269dae28f52e0d86c
Author: Yue Hin Lau <Yuehin.Lau@amd.com>
Date:   Mon Oct 2 14:39:42 2017 -0400

    drm/amd/display: rename struct mem_input to hubp for dcn
    
    Signed-off-by: Yue Hin Lau <Yuehin.Lau@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 83d9caa4f438..ed301c3b2736 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -685,9 +685,6 @@ void dce_mem_input_construct(
 	dce_mi->regs = regs;
 	dce_mi->shifts = mi_shift;
 	dce_mi->masks = mi_mask;
-
-	dce_mi->base.mpcc_id = 0xf;
-	dce_mi->base.opp_id = 0xf;
 }
 
 void dce112_mem_input_construct(

commit 8eb5def95762dc1cd9e516510925a95060452c5a
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 28 08:16:27 2017 -0400

    drm/amd/display: fix hubp mpcc and opp tracking
    
    This should be handled by mi and mpc only
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 627669749740..83d9caa4f438 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -686,6 +686,8 @@ void dce_mem_input_construct(
 	dce_mi->shifts = mi_shift;
 	dce_mi->masks = mi_mask;
 
+	dce_mi->base.mpcc_id = 0xf;
+	dce_mi->base.opp_id = 0xf;
 }
 
 void dce112_mem_input_construct(

commit 08b1688620426ad3e09fc7a98aabc28dda30cde6
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Sun Jul 23 18:30:15 2017 -0400

    drm/amd/display: Move DCHUBBUB block from MemInput to HW sequencer.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 157f4e1680e3..627669749740 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -656,57 +656,6 @@ static bool dce_mi_program_surface_flip_and_addr(
 	return true;
 }
 
-static void dce_mi_update_dchub(struct mem_input *mi,
-		struct dchub_init_data *dh_data)
-{
-	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
-	/* TODO: port code from dal2 */
-	switch (dh_data->fb_mode) {
-	case FRAME_BUFFER_MODE_ZFB_ONLY:
-		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
-		REG_UPDATE_2(DCHUB_FB_LOCATION,
-				FB_TOP, 0,
-				FB_BASE, 0x0FFFF);
-
-		REG_UPDATE(DCHUB_AGP_BASE,
-				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		REG_UPDATE(DCHUB_AGP_BOT,
-				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		REG_UPDATE(DCHUB_AGP_TOP,
-				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
-		break;
-	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-		REG_UPDATE(DCHUB_AGP_BASE,
-				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
-
-		REG_UPDATE(DCHUB_AGP_BOT,
-				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
-
-		REG_UPDATE(DCHUB_AGP_TOP,
-				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
-		break;
-	case FRAME_BUFFER_MODE_LOCAL_ONLY:
-		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
-		REG_UPDATE(DCHUB_AGP_BASE,
-				AGP_BASE, 0);
-
-		REG_UPDATE(DCHUB_AGP_BOT,
-				AGP_BOT, 0x03FFFF);
-
-		REG_UPDATE(DCHUB_AGP_TOP,
-				AGP_TOP, 0);
-		break;
-	default:
-		break;
-	}
-
-	dh_data->dchub_initialzied = true;
-	dh_data->dchub_info_valid = false;
-}
-
 static struct mem_input_funcs dce_mi_funcs = {
 	.mem_input_program_display_marks = dce_mi_program_display_marks,
 	.allocate_mem_input = dce_mi_allocate_dmif,
@@ -716,8 +665,7 @@ static struct mem_input_funcs dce_mi_funcs = {
 	.mem_input_program_pte_vm = dce_mi_program_pte_vm,
 	.mem_input_program_surface_config =
 			dce_mi_program_surface_config,
-	.mem_input_is_flip_pending = dce_mi_is_flip_pending,
-	.mem_input_update_dchub = dce_mi_update_dchub
+	.mem_input_is_flip_pending = dce_mi_is_flip_pending
 };
 
 

commit a7562ab35ee96810e9e4c41969a375f1c3f249ae
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 18 17:02:43 2017 -0400

    drm/amd/display: remove GRPH_SURFACE_UPDATE_IMMEDIATE_EN field programming
    
    This is causing asserts for dce 8 and 10 since they do not contain this
    field. It is also unnecessary for later DCEs as it is left in it's
    default state of 0
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 673371e5f9f0..157f4e1680e3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -621,15 +621,10 @@ static bool dce_mi_program_surface_flip_and_addr(
 {
 	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);
 
-	/* TODO: Figure out if two modes are needed:
-	 * non-XDMA Mode: GRPH_SURFACE_UPDATE_IMMEDIATE_EN = 1
-	 * XDMA Mode: GRPH_SURFACE_UPDATE_H_RETRACE_EN = 1
-	 */
 	REG_UPDATE(GRPH_UPDATE, GRPH_UPDATE_LOCK, 1);
 
-	REG_UPDATE_2(
+	REG_UPDATE(
 		GRPH_FLIP_CONTROL,
-		GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
 		GRPH_SURFACE_UPDATE_H_RETRACE_EN, flip_immediate ? 1 : 0);
 
 	switch (address->type) {

commit 0b3454b7c49bfc6aa7a1096d1aa9d059201a73a7
Author: Tom St Denis <tom.stdenis@amd.com>
Date:   Tue May 16 10:22:05 2017 -0400

    drm/amd/display: Tidy up mem_input_program_surface_flip_and_addr()
    
    Signed-off-by: Tom St Denis <tom.stdenis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 718688c41f7b..673371e5f9f0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -625,18 +625,12 @@ static bool dce_mi_program_surface_flip_and_addr(
 	 * non-XDMA Mode: GRPH_SURFACE_UPDATE_IMMEDIATE_EN = 1
 	 * XDMA Mode: GRPH_SURFACE_UPDATE_H_RETRACE_EN = 1
 	 */
-	REG_UPDATE(GRPH_UPDATE,
-			GRPH_UPDATE_LOCK, 1);
-
-	if (flip_immediate) {
-		REG_UPDATE_2(GRPH_FLIP_CONTROL,
-			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
-			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 1);
-	} else {
-		REG_UPDATE_2(GRPH_FLIP_CONTROL,
-			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
-			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 0);
-	}
+	REG_UPDATE(GRPH_UPDATE, GRPH_UPDATE_LOCK, 1);
+
+	REG_UPDATE_2(
+		GRPH_FLIP_CONTROL,
+		GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
+		GRPH_SURFACE_UPDATE_H_RETRACE_EN, flip_immediate ? 1 : 0);
 
 	switch (address->type) {
 	case PLN_ADDR_TYPE_GRAPHICS:
@@ -645,8 +639,8 @@ static bool dce_mi_program_surface_flip_and_addr(
 		program_pri_addr(dce_mi, address->grph.addr);
 		break;
 	case PLN_ADDR_TYPE_GRPH_STEREO:
-		if (address->grph_stereo.left_addr.quad_part == 0
-			|| address->grph_stereo.right_addr.quad_part == 0)
+		if (address->grph_stereo.left_addr.quad_part == 0 ||
+		    address->grph_stereo.right_addr.quad_part == 0)
 			break;
 		program_pri_addr(dce_mi, address->grph_stereo.left_addr);
 		program_sec_addr(dce_mi, address->grph_stereo.right_addr);
@@ -662,8 +656,7 @@ static bool dce_mi_program_surface_flip_and_addr(
 	if (flip_immediate)
 		mem_input->current_address = *address;
 
-	REG_UPDATE(GRPH_UPDATE,
-			GRPH_UPDATE_LOCK, 0);
+	REG_UPDATE(GRPH_UPDATE, GRPH_UPDATE_LOCK, 0);
 
 	return true;
 }

commit c34892144d38eddb4499ac425c24455b1e34dd61
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon May 15 08:31:51 2017 -0400

    drm/amd/display: dce 8 - 12 mem_input refactor to new style
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 0552fc5f7ecc..718688c41f7b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -23,18 +23,18 @@
  *
  */
 
-#include "mem_input.h"
+#include "dce_mem_input.h"
 #include "reg_helper.h"
 #include "basics/conversion.h"
 
 #define CTX \
-	mi->ctx
+	dce_mi->base.ctx
 #define REG(reg)\
-	mi->regs->reg
+	dce_mi->regs->reg
 
 #undef FN
 #define FN(reg_name, field_name) \
-	mi->shifts->field_name, mi->masks->field_name
+	dce_mi->shifts->field_name, dce_mi->masks->field_name
 
 struct pte_setting {
 	unsigned int bpp;
@@ -130,11 +130,13 @@ static bool is_vert_scan(enum dc_rotation_angle rotation)
 	}
 }
 
-void dce_mem_input_program_pte_vm(struct mem_input *mi,
+static void dce_mi_program_pte_vm(
+		struct mem_input *mi,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,
 		enum dc_rotation_angle rotation)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	enum mi_bits_per_pixel mi_bpp = get_mi_bpp(format);
 	enum mi_tiling_format mi_tiling = get_mi_tiling(tiling_info);
 	const struct pte_setting *pte = &pte_settings[mi_tiling][mi_bpp];
@@ -158,7 +160,8 @@ void dce_mem_input_program_pte_vm(struct mem_input *mi,
 			DVMM_MAX_PTE_REQ_OUTSTANDING, 0xff);
 }
 
-static void program_urgency_watermark(struct mem_input *mi,
+static void program_urgency_watermark(
+	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t urgency_low_wm,
 	uint32_t urgency_high_wm)
@@ -171,7 +174,8 @@ static void program_urgency_watermark(struct mem_input *mi,
 		URGENCY_HIGH_WATERMARK, urgency_high_wm);
 }
 
-static void program_nbp_watermark(struct mem_input *mi,
+static void program_nbp_watermark(
+	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t nbp_wm)
 {
@@ -202,7 +206,8 @@ static void program_nbp_watermark(struct mem_input *mi,
 	}
 }
 
-static void program_stutter_watermark(struct mem_input *mi,
+static void program_stutter_watermark(
+	struct dce_mem_input *dce_mi,
 	uint32_t wm_select,
 	uint32_t stutter_mark)
 {
@@ -217,41 +222,67 @@ static void program_stutter_watermark(struct mem_input *mi,
 				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
 }
 
-void dce_mem_input_program_display_marks(struct mem_input *mi,
+static void dce_mi_program_display_marks(
+	struct mem_input *mi,
 	struct dce_watermarks nbp,
 	struct dce_watermarks stutter,
 	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
 
-	program_urgency_watermark(mi, 0, /* set a */
+	program_urgency_watermark(dce_mi, 2, /* set a */
 			urgent.a_mark, total_dest_line_time_ns);
-	program_urgency_watermark(mi, 1, /* set b */
+	program_urgency_watermark(dce_mi, 1, /* set d */
+			urgent.d_mark, total_dest_line_time_ns);
+
+	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
+		STUTTER_ENABLE, stutter_en,
+		STUTTER_IGNORE_FBC, 1);
+	program_nbp_watermark(dce_mi, 2, nbp.a_mark); /* set a */
+	program_nbp_watermark(dce_mi, 1, nbp.d_mark); /* set d */
+
+	program_stutter_watermark(dce_mi, 2, stutter.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter.d_mark); /* set d */
+}
+
+static void dce120_mi_program_display_marks(struct mem_input *mi,
+	struct dce_watermarks nbp,
+	struct dce_watermarks stutter,
+	struct dce_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
+	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
+
+	program_urgency_watermark(dce_mi, 0, /* set a */
+			urgent.a_mark, total_dest_line_time_ns);
+	program_urgency_watermark(dce_mi, 1, /* set b */
 			urgent.b_mark, total_dest_line_time_ns);
-	program_urgency_watermark(mi, 2, /* set c */
+	program_urgency_watermark(dce_mi, 2, /* set c */
 			urgent.c_mark, total_dest_line_time_ns);
-	program_urgency_watermark(mi, 3, /* set d */
+	program_urgency_watermark(dce_mi, 3, /* set d */
 			urgent.d_mark, total_dest_line_time_ns);
 
 	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
 		STUTTER_ENABLE, stutter_en,
 		STUTTER_IGNORE_FBC, 1);
-	program_nbp_watermark(mi, 0, nbp.a_mark); /* set a */
-	program_nbp_watermark(mi, 1, nbp.b_mark); /* set b */
-	program_nbp_watermark(mi, 2, nbp.c_mark); /* set c */
-	program_nbp_watermark(mi, 3, nbp.d_mark); /* set d */
-
-	program_stutter_watermark(mi, 0, stutter.a_mark); /* set a */
-	program_stutter_watermark(mi, 1, stutter.b_mark); /* set b */
-	program_stutter_watermark(mi, 2, stutter.c_mark); /* set c */
-	program_stutter_watermark(mi, 3, stutter.d_mark); /* set d */
+	program_nbp_watermark(dce_mi, 0, nbp.a_mark); /* set a */
+	program_nbp_watermark(dce_mi, 1, nbp.b_mark); /* set b */
+	program_nbp_watermark(dce_mi, 2, nbp.c_mark); /* set c */
+	program_nbp_watermark(dce_mi, 3, nbp.d_mark); /* set d */
+
+	program_stutter_watermark(dce_mi, 0, stutter.a_mark); /* set a */
+	program_stutter_watermark(dce_mi, 1, stutter.b_mark); /* set b */
+	program_stutter_watermark(dce_mi, 2, stutter.c_mark); /* set c */
+	program_stutter_watermark(dce_mi, 3, stutter.d_mark); /* set d */
 }
 
-static void program_tiling(struct mem_input *mi,
-	const union dc_tiling_info *info)
+static void program_tiling(
+	struct dce_mem_input *dce_mi, const union dc_tiling_info *info)
 {
-	if (mi->masks->GRPH_SW_MODE) { /* GFX9 */
+	if (dce_mi->masks->GRPH_SW_MODE) { /* GFX9 */
 		REG_UPDATE_6(GRPH_CONTROL,
 				GRPH_SW_MODE, info->gfx9.swizzle,
 				GRPH_NUM_BANKS, log_2(info->gfx9.num_banks),
@@ -265,7 +296,7 @@ static void program_tiling(struct mem_input *mi,
 		 */
 	}
 
-	if (mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
+	if (dce_mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
 		REG_UPDATE_9(GRPH_CONTROL,
 				GRPH_NUM_BANKS, info->gfx8.num_banks,
 				GRPH_BANK_WIDTH, info->gfx8.bank_width,
@@ -285,7 +316,7 @@ static void program_tiling(struct mem_input *mi,
 
 
 static void program_size_and_rotation(
-	struct mem_input *mi,
+	struct dce_mem_input *dce_mi,
 	enum dc_rotation_angle rotation,
 	const union plane_size *plane_size)
 {
@@ -326,7 +357,7 @@ static void program_size_and_rotation(
 }
 
 static void program_grph_pixel_format(
-	struct mem_input *mi,
+	struct dce_mem_input *dce_mi,
 	enum surface_pixel_format format)
 {
 	uint32_t red_xbar = 0, blue_xbar = 0; /* no swap */
@@ -397,7 +428,8 @@ static void program_grph_pixel_format(
 			GRPH_PRESCALE_B_SIGN, sign);
 }
 
-void dce_mem_input_program_surface_config(struct mem_input *mi,
+static void dce_mi_program_surface_config(
+	struct mem_input *mi,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
 	union plane_size *plane_size,
@@ -405,14 +437,15 @@ void dce_mem_input_program_surface_config(struct mem_input *mi,
 	struct dc_plane_dcc_param *dcc,
 	bool horizontal_mirror)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	REG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);
 
-	program_tiling(mi, tiling_info);
-	program_size_and_rotation(mi, rotation, plane_size);
+	program_tiling(dce_mi, tiling_info);
+	program_size_and_rotation(dce_mi, rotation, plane_size);
 
 	if (format >= SURFACE_PIXEL_FORMAT_GRPH_BEGIN &&
 		format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
-		program_grph_pixel_format(mi, format);
+		program_grph_pixel_format(dce_mi, format);
 }
 
 static uint32_t get_dmif_switch_time_us(
@@ -461,12 +494,14 @@ static uint32_t get_dmif_switch_time_us(
 	return frame_time;
 }
 
-void dce_mem_input_allocate_dmif(struct mem_input *mi,
+static void dce_mi_allocate_dmif(
+	struct mem_input *mi,
 	uint32_t h_total,
 	uint32_t v_total,
 	uint32_t pix_clk_khz,
 	uint32_t total_stream_num)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	const uint32_t retry_delay = 10;
 	uint32_t retry_count = get_dmif_switch_time_us(
 			h_total,
@@ -497,18 +532,20 @@ void dce_mem_input_allocate_dmif(struct mem_input *mi,
 			PIXEL_DURATION, pix_dur);
 	}
 
-	if (mi->wa.single_head_rdreq_dmif_limit) {
+	if (dce_mi->wa.single_head_rdreq_dmif_limit) {
 		uint32_t eanble =  (total_stream_num > 1) ? 0 :
-				mi->wa.single_head_rdreq_dmif_limit;
+				dce_mi->wa.single_head_rdreq_dmif_limit;
 
 		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
 				ENABLE, eanble);
 	}
 }
 
-void dce_mem_input_free_dmif(struct mem_input *mi,
+static void dce_mi_free_dmif(
+		struct mem_input *mi,
 		uint32_t total_stream_num)
 {
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
 	uint32_t buffers_allocated;
 	uint32_t dmif_buffer_control;
 
@@ -525,11 +562,204 @@ void dce_mem_input_free_dmif(struct mem_input *mi,
 			DMIF_BUFFERS_ALLOCATION_COMPLETED, 1,
 			10, 3500);
 
-	if (mi->wa.single_head_rdreq_dmif_limit) {
+	if (dce_mi->wa.single_head_rdreq_dmif_limit) {
 		uint32_t eanble =  (total_stream_num > 1) ? 0 :
-				mi->wa.single_head_rdreq_dmif_limit;
+				dce_mi->wa.single_head_rdreq_dmif_limit;
 
 		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
 				ENABLE, eanble);
 	}
 }
+
+
+static void program_sec_addr(
+	struct dce_mem_input *dce_mi,
+	PHYSICAL_ADDRESS_LOC address)
+{
+	/*high register MUST be programmed first*/
+	REG_SET(GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, 0,
+		GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
+		address.high_part);
+
+	REG_SET_2(GRPH_SECONDARY_SURFACE_ADDRESS, 0,
+		GRPH_SECONDARY_SURFACE_ADDRESS, address.low_part >> 8,
+		GRPH_SECONDARY_DFQ_ENABLE, 0);
+}
+
+static void program_pri_addr(
+	struct dce_mem_input *dce_mi,
+	PHYSICAL_ADDRESS_LOC address)
+{
+	/*high register MUST be programmed first*/
+	REG_SET(GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, 0,
+		GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
+		address.high_part);
+
+	REG_SET(GRPH_PRIMARY_SURFACE_ADDRESS, 0,
+		GRPH_PRIMARY_SURFACE_ADDRESS,
+		address.low_part >> 8);
+}
+
+
+static bool dce_mi_is_flip_pending(struct mem_input *mem_input)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);
+	uint32_t update_pending;
+
+	REG_GET(GRPH_UPDATE, GRPH_SURFACE_UPDATE_PENDING, &update_pending);
+	if (update_pending)
+		return true;
+
+	mem_input->current_address = mem_input->request_address;
+	return false;
+}
+
+static bool dce_mi_program_surface_flip_and_addr(
+	struct mem_input *mem_input,
+	const struct dc_plane_address *address,
+	bool flip_immediate)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mem_input);
+
+	/* TODO: Figure out if two modes are needed:
+	 * non-XDMA Mode: GRPH_SURFACE_UPDATE_IMMEDIATE_EN = 1
+	 * XDMA Mode: GRPH_SURFACE_UPDATE_H_RETRACE_EN = 1
+	 */
+	REG_UPDATE(GRPH_UPDATE,
+			GRPH_UPDATE_LOCK, 1);
+
+	if (flip_immediate) {
+		REG_UPDATE_2(GRPH_FLIP_CONTROL,
+			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
+			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 1);
+	} else {
+		REG_UPDATE_2(GRPH_FLIP_CONTROL,
+			GRPH_SURFACE_UPDATE_IMMEDIATE_EN, 0,
+			GRPH_SURFACE_UPDATE_H_RETRACE_EN, 0);
+	}
+
+	switch (address->type) {
+	case PLN_ADDR_TYPE_GRAPHICS:
+		if (address->grph.addr.quad_part == 0)
+			break;
+		program_pri_addr(dce_mi, address->grph.addr);
+		break;
+	case PLN_ADDR_TYPE_GRPH_STEREO:
+		if (address->grph_stereo.left_addr.quad_part == 0
+			|| address->grph_stereo.right_addr.quad_part == 0)
+			break;
+		program_pri_addr(dce_mi, address->grph_stereo.left_addr);
+		program_sec_addr(dce_mi, address->grph_stereo.right_addr);
+		break;
+	default:
+		/* not supported */
+		BREAK_TO_DEBUGGER();
+		break;
+	}
+
+	mem_input->request_address = *address;
+
+	if (flip_immediate)
+		mem_input->current_address = *address;
+
+	REG_UPDATE(GRPH_UPDATE,
+			GRPH_UPDATE_LOCK, 0);
+
+	return true;
+}
+
+static void dce_mi_update_dchub(struct mem_input *mi,
+		struct dchub_init_data *dh_data)
+{
+	struct dce_mem_input *dce_mi = TO_DCE_MEM_INPUT(mi);
+	/* TODO: port code from dal2 */
+	switch (dh_data->fb_mode) {
+	case FRAME_BUFFER_MODE_ZFB_ONLY:
+		/*For ZFB case need to put DCHUB FB BASE and TOP upside down to indicate ZFB mode*/
+		REG_UPDATE_2(DCHUB_FB_LOCATION,
+				FB_TOP, 0,
+				FB_BASE, 0x0FFFF);
+
+		REG_UPDATE(DCHUB_AGP_BASE,
+				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUB_AGP_BOT,
+				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUB_AGP_TOP,
+				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_MIXED_ZFB_AND_LOCAL:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUB_AGP_BASE,
+				AGP_BASE, dh_data->zfb_phys_addr_base >> 22);
+
+		REG_UPDATE(DCHUB_AGP_BOT,
+				AGP_BOT, dh_data->zfb_mc_base_addr >> 22);
+
+		REG_UPDATE(DCHUB_AGP_TOP,
+				AGP_TOP, (dh_data->zfb_mc_base_addr + dh_data->zfb_size_in_byte - 1) >> 22);
+		break;
+	case FRAME_BUFFER_MODE_LOCAL_ONLY:
+		/*Should not touch FB LOCATION (done by VBIOS on AsicInit table)*/
+		REG_UPDATE(DCHUB_AGP_BASE,
+				AGP_BASE, 0);
+
+		REG_UPDATE(DCHUB_AGP_BOT,
+				AGP_BOT, 0x03FFFF);
+
+		REG_UPDATE(DCHUB_AGP_TOP,
+				AGP_TOP, 0);
+		break;
+	default:
+		break;
+	}
+
+	dh_data->dchub_initialzied = true;
+	dh_data->dchub_info_valid = false;
+}
+
+static struct mem_input_funcs dce_mi_funcs = {
+	.mem_input_program_display_marks = dce_mi_program_display_marks,
+	.allocate_mem_input = dce_mi_allocate_dmif,
+	.free_mem_input = dce_mi_free_dmif,
+	.mem_input_program_surface_flip_and_addr =
+			dce_mi_program_surface_flip_and_addr,
+	.mem_input_program_pte_vm = dce_mi_program_pte_vm,
+	.mem_input_program_surface_config =
+			dce_mi_program_surface_config,
+	.mem_input_is_flip_pending = dce_mi_is_flip_pending,
+	.mem_input_update_dchub = dce_mi_update_dchub
+};
+
+
+void dce_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask)
+{
+	dce_mi->base.ctx = ctx;
+
+	dce_mi->base.inst = inst;
+	dce_mi->base.funcs = &dce_mi_funcs;
+
+	dce_mi->regs = regs;
+	dce_mi->shifts = mi_shift;
+	dce_mi->masks = mi_mask;
+
+}
+
+void dce112_mem_input_construct(
+	struct dce_mem_input *dce_mi,
+	struct dc_context *ctx,
+	int inst,
+	const struct dce_mem_input_registers *regs,
+	const struct dce_mem_input_shift *mi_shift,
+	const struct dce_mem_input_mask *mi_mask)
+{
+	dce_mem_input_construct(dce_mi, ctx, inst, regs, mi_shift, mi_mask);
+	dce_mi->base.funcs->mem_input_program_display_marks = dce120_mi_program_display_marks;
+}

commit 4b28b76bfe14430a91de74a5cf9215f3c108acf9
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 11 17:15:14 2017 -0400

    drm/amd/display: fix mpo blanking out on one of planes being set not visible
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 9da539db287c..0552fc5f7ecc 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -403,8 +403,7 @@ void dce_mem_input_program_surface_config(struct mem_input *mi,
 	union plane_size *plane_size,
 	enum dc_rotation_angle rotation,
 	struct dc_plane_dcc_param *dcc,
-	bool horizontal_mirror,
-	bool visible)
+	bool horizontal_mirror)
 {
 	REG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);
 

commit 9037d802a97812cb8d614b48f817a5532cf1558c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 2 17:29:48 2017 -0400

    drm/amd/display: refactor bw related variable structure in val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 884f453d91b0..9da539db287c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -218,9 +218,9 @@ static void program_stutter_watermark(struct mem_input *mi,
 }
 
 void dce_mem_input_program_display_marks(struct mem_input *mi,
-	struct bw_watermarks nbp,
-	struct bw_watermarks stutter,
-	struct bw_watermarks urgent,
+	struct dce_watermarks nbp,
+	struct dce_watermarks stutter,
+	struct dce_watermarks urgent,
 	uint32_t total_dest_line_time_ns)
 {
 	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;

commit 940c654e64e1ed70b49ec663f2370a8b4de6d2ac
Author: Roman Li <Roman.Li@amd.com>
Date:   Fri Mar 24 16:26:09 2017 -0400

    drm/amd/display: increase timeout for dmif dealloc
    
    In some use-cases, e.g. multiple 4K displays,
    exisitng wait time for reg update of 30msec timed out
    during mode setiing that sometimes resulted in system bad state
    as we continue without waiting for registry update complete.
    Increasing timeout to 35msec fixes that problem.
    
    Signed-off-by: Roman Li <Roman.Li@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 7acd87152811..884f453d91b0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -524,7 +524,7 @@ void dce_mem_input_free_dmif(struct mem_input *mi,
 
 	REG_WAIT(DMIF_BUFFER_CONTROL,
 			DMIF_BUFFERS_ALLOCATION_COMPLETED, 1,
-			10, 0xBB8);
+			10, 3500);
 
 	if (mi->wa.single_head_rdreq_dmif_limit) {
 		uint32_t eanble =  (total_stream_num > 1) ? 0 :

commit 8fa9ca2ec6919656db87391a1633692ee8d57c22
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:21:43 2017 -0400

    drm/amd/display: Remove DCE12 guards
    
    Signed-off-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index c494f712b5b5..7acd87152811 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -187,7 +187,7 @@ static void program_nbp_watermark(struct mem_input *mi,
 		REG_UPDATE(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
 				NB_PSTATE_CHANGE_WATERMARK, nbp_wm);
 	}
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+
 	if (REG(DPG_PIPE_LOW_POWER_CONTROL)) {
 		REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
 				PSTATE_CHANGE_WATERMARK_MASK, wm_select);
@@ -200,7 +200,6 @@ static void program_nbp_watermark(struct mem_input *mi,
 		REG_UPDATE(DPG_PIPE_LOW_POWER_CONTROL,
 				PSTATE_CHANGE_WATERMARK, nbp_wm);
 	}
-#endif
 }
 
 static void program_stutter_watermark(struct mem_input *mi,
@@ -210,12 +209,10 @@ static void program_stutter_watermark(struct mem_input *mi,
 	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);
 
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 	if (REG(DPG_PIPE_STUTTER_CONTROL2))
 		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL2,
 				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
 	else
-#endif
 		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL,
 				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
 }
@@ -254,7 +251,6 @@ void dce_mem_input_program_display_marks(struct mem_input *mi,
 static void program_tiling(struct mem_input *mi,
 	const union dc_tiling_info *info)
 {
-#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
 	if (mi->masks->GRPH_SW_MODE) { /* GFX9 */
 		REG_UPDATE_6(GRPH_CONTROL,
 				GRPH_SW_MODE, info->gfx9.swizzle,
@@ -268,7 +264,7 @@ static void program_tiling(struct mem_input *mi,
 		GRPH_Z, 0);
 		 */
 	}
-#endif
+
 	if (mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
 		REG_UPDATE_9(GRPH_CONTROL,
 				GRPH_NUM_BANKS, info->gfx8.num_banks,

commit 2c8ad2d5a20c8b7425b547dd4a969ffecad29b39
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:20:24 2017 -0400

    drm/amd/display: Enable DCE12 support
    
    This wires DCE12 support into DC and enables it.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index e14a21cedfd5..c494f712b5b5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -187,6 +187,20 @@ static void program_nbp_watermark(struct mem_input *mi,
 		REG_UPDATE(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
 				NB_PSTATE_CHANGE_WATERMARK, nbp_wm);
 	}
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+	if (REG(DPG_PIPE_LOW_POWER_CONTROL)) {
+		REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
+				PSTATE_CHANGE_WATERMARK_MASK, wm_select);
+
+		REG_UPDATE_3(DPG_PIPE_LOW_POWER_CONTROL,
+				PSTATE_CHANGE_ENABLE, 1,
+				PSTATE_CHANGE_URGENT_DURING_REQUEST, 1,
+				PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST, 1);
+
+		REG_UPDATE(DPG_PIPE_LOW_POWER_CONTROL,
+				PSTATE_CHANGE_WATERMARK, nbp_wm);
+	}
+#endif
 }
 
 static void program_stutter_watermark(struct mem_input *mi,
@@ -196,6 +210,12 @@ static void program_stutter_watermark(struct mem_input *mi,
 	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
 		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);
 
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+	if (REG(DPG_PIPE_STUTTER_CONTROL2))
+		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL2,
+				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
+	else
+#endif
 		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL,
 				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
 }
@@ -234,6 +254,21 @@ void dce_mem_input_program_display_marks(struct mem_input *mi,
 static void program_tiling(struct mem_input *mi,
 	const union dc_tiling_info *info)
 {
+#if defined(CONFIG_DRM_AMD_DC_DCE12_0)
+	if (mi->masks->GRPH_SW_MODE) { /* GFX9 */
+		REG_UPDATE_6(GRPH_CONTROL,
+				GRPH_SW_MODE, info->gfx9.swizzle,
+				GRPH_NUM_BANKS, log_2(info->gfx9.num_banks),
+				GRPH_NUM_SHADER_ENGINES, log_2(info->gfx9.num_shader_engines),
+				GRPH_NUM_PIPES, log_2(info->gfx9.num_pipes),
+				GRPH_COLOR_EXPANSION_MODE, 1,
+				GRPH_SE_ENABLE, info->gfx9.shaderEnable);
+		/* TODO: DCP0_GRPH_CONTROL__GRPH_SE_ENABLE where to get info
+		GRPH_SE_ENABLE, 1,
+		GRPH_Z, 0);
+		 */
+	}
+#endif
 	if (mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
 		REG_UPDATE_9(GRPH_CONTROL,
 				GRPH_NUM_BANKS, info->gfx8.num_banks,

commit 8693049a896c2c3a2bb74f0efde62318636beaef
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Mon Jan 16 20:50:47 2017 -0500

    drm/amd/display: rename BGRA8888 to ABGR8888
    
    DC actually support ABGR8888 instead of BGRA8888 (R/B swap rather than endian swap) ,
    rename to avoid confusion
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 130935fffba3..e14a21cedfd5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -302,7 +302,7 @@ static void program_grph_pixel_format(
 	uint32_t grph_depth, grph_format;
 	uint32_t sign = 0, floating = 0;
 
-	if (format == SURFACE_PIXEL_FORMAT_GRPH_BGRA8888 ||
+	if (format == SURFACE_PIXEL_FORMAT_GRPH_ABGR8888 ||
 			/*todo: doesn't look like we handle BGRA here,
 			 *  should problem swap endian*/
 		format == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010 ||
@@ -331,7 +331,7 @@ static void program_grph_pixel_format(
 		grph_format = 1;
 		break;
 	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
-	case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR8888:
 		grph_depth = 2;
 		grph_format = 0;
 		break;

commit 624d7c4708b27be2dc095579394efadd80f090dd
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Jan 9 09:42:33 2017 -0500

    drm/amd/display: Pass visible flag into surface programming
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index e9005e0048e6..130935fffba3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -372,7 +372,8 @@ void dce_mem_input_program_surface_config(struct mem_input *mi,
 	union plane_size *plane_size,
 	enum dc_rotation_angle rotation,
 	struct dc_plane_dcc_param *dcc,
-	bool horizontal_mirror)
+	bool horizontal_mirror,
+	bool visible)
 {
 	REG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);
 

commit 88499197de090c9bb391cc11bf9410b9f020092f
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Mon Dec 12 14:20:45 2016 -0500

    drm/amd/display: Moved swizzle parameter translation to dc.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index fd8a49afbec6..e9005e0048e6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -25,6 +25,7 @@
 
 #include "mem_input.h"
 #include "reg_helper.h"
+#include "basics/conversion.h"
 
 #define CTX \
 	mi->ctx
@@ -129,16 +130,6 @@ static bool is_vert_scan(enum dc_rotation_angle rotation)
 	}
 }
 
-static unsigned int log_2(unsigned int num)
-{
-	unsigned int result = 0;
-
-	while ((num >>= 1) != 0)
-		result++;
-
-	return result;
-}
-
 void dce_mem_input_program_pte_vm(struct mem_input *mi,
 		enum surface_pixel_format format,
 		union dc_tiling_info *tiling_info,

commit 197062bf12d7a516ea96e24859fe5981e30ea9ff
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Nov 30 16:15:47 2016 -0500

    drm/amd/display: refactor DCE11 DVVM
    
    - move to new programming style
    - clean up table to make it obvious what we are programming
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
index 654731cccdcd..fd8a49afbec6 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -35,6 +35,137 @@
 #define FN(reg_name, field_name) \
 	mi->shifts->field_name, mi->masks->field_name
 
+struct pte_setting {
+	unsigned int bpp;
+	unsigned int page_width;
+	unsigned int page_height;
+	unsigned char min_pte_before_flip_horiz_scan;
+	unsigned char min_pte_before_flip_vert_scan;
+	unsigned char pte_req_per_chunk;
+	unsigned char param_6;
+	unsigned char param_7;
+	unsigned char param_8;
+};
+
+enum mi_bits_per_pixel {
+	mi_bpp_8 = 0,
+	mi_bpp_16,
+	mi_bpp_32,
+	mi_bpp_64,
+	mi_bpp_count,
+};
+
+enum mi_tiling_format {
+	mi_tiling_linear = 0,
+	mi_tiling_1D,
+	mi_tiling_2D,
+	mi_tiling_count,
+};
+
+static const struct pte_setting pte_settings[mi_tiling_count][mi_bpp_count] = {
+	[mi_tiling_linear] = {
+		{  8, 4096, 1, 8, 0, 1, 0, 0, 0},
+		{ 16, 2048, 1, 8, 0, 1, 0, 0, 0},
+		{ 32, 1024, 1, 8, 0, 1, 0, 0, 0},
+		{ 64,  512, 1, 8, 0, 1, 0, 0, 0}, /* new for 64bpp from HW */
+	},
+	[mi_tiling_1D] = {
+		{  8, 512, 8, 1, 0, 1, 0, 0, 0},  /* 0 for invalid */
+		{ 16, 256, 8, 2, 0, 1, 0, 0, 0},
+		{ 32, 128, 8, 4, 0, 1, 0, 0, 0},
+		{ 64,  64, 8, 4, 0, 1, 0, 0, 0}, /* fake */
+	},
+	[mi_tiling_2D] = {
+		{  8, 64, 64,  8,  8, 1, 4, 0, 0},
+		{ 16, 64, 32,  8, 16, 1, 8, 0, 0},
+		{ 32, 32, 32, 16, 16, 1, 8, 0, 0},
+		{ 64,  8, 32, 16, 16, 1, 8, 0, 0}, /* fake */
+	},
+};
+
+static enum mi_bits_per_pixel get_mi_bpp(
+		enum surface_pixel_format format)
+{
+	if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616)
+		return mi_bpp_64;
+	else if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB8888)
+		return mi_bpp_32;
+	else if (format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB1555)
+		return mi_bpp_16;
+	else
+		return mi_bpp_8;
+}
+
+static enum mi_tiling_format get_mi_tiling(
+		union dc_tiling_info *tiling_info)
+{
+	switch (tiling_info->gfx8.array_mode) {
+	case DC_ARRAY_1D_TILED_THIN1:
+	case DC_ARRAY_1D_TILED_THICK:
+	case DC_ARRAY_PRT_TILED_THIN1:
+		return mi_tiling_1D;
+	case DC_ARRAY_2D_TILED_THIN1:
+	case DC_ARRAY_2D_TILED_THICK:
+	case DC_ARRAY_2D_TILED_X_THICK:
+	case DC_ARRAY_PRT_2D_TILED_THIN1:
+	case DC_ARRAY_PRT_2D_TILED_THICK:
+		return mi_tiling_2D;
+	case DC_ARRAY_LINEAR_GENERAL:
+	case DC_ARRAY_LINEAR_ALLIGNED:
+		return mi_tiling_linear;
+	default:
+		return mi_tiling_2D;
+	}
+}
+
+static bool is_vert_scan(enum dc_rotation_angle rotation)
+{
+	switch (rotation) {
+	case ROTATION_ANGLE_90:
+	case ROTATION_ANGLE_270:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static unsigned int log_2(unsigned int num)
+{
+	unsigned int result = 0;
+
+	while ((num >>= 1) != 0)
+		result++;
+
+	return result;
+}
+
+void dce_mem_input_program_pte_vm(struct mem_input *mi,
+		enum surface_pixel_format format,
+		union dc_tiling_info *tiling_info,
+		enum dc_rotation_angle rotation)
+{
+	enum mi_bits_per_pixel mi_bpp = get_mi_bpp(format);
+	enum mi_tiling_format mi_tiling = get_mi_tiling(tiling_info);
+	const struct pte_setting *pte = &pte_settings[mi_tiling][mi_bpp];
+
+	unsigned int page_width = log_2(pte->page_width);
+	unsigned int page_height = log_2(pte->page_height);
+	unsigned int min_pte_before_flip = is_vert_scan(rotation) ?
+			pte->min_pte_before_flip_vert_scan :
+			pte->min_pte_before_flip_horiz_scan;
+
+	REG_UPDATE(GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT,
+			GRPH_PIPE_OUTSTANDING_REQUEST_LIMIT, 0xff);
+
+	REG_UPDATE_3(DVMM_PTE_CONTROL,
+			DVMM_PAGE_WIDTH, page_width,
+			DVMM_PAGE_HEIGHT, page_height,
+			DVMM_MIN_PTE_BEFORE_FLIP, min_pte_before_flip);
+
+	REG_UPDATE_2(DVMM_PTE_ARB_CONTROL,
+			DVMM_PTE_REQ_PER_CHUNK, pte->pte_req_per_chunk,
+			DVMM_MAX_PTE_REQ_OUTSTANDING, 0xff);
+}
 
 static void program_urgency_watermark(struct mem_input *mi,
 	uint32_t wm_select,
@@ -244,7 +375,7 @@ static void program_grph_pixel_format(
 			GRPH_PRESCALE_B_SIGN, sign);
 }
 
-bool dce_mem_input_program_surface_config(struct mem_input *mi,
+void dce_mem_input_program_surface_config(struct mem_input *mi,
 	enum surface_pixel_format format,
 	union dc_tiling_info *tiling_info,
 	union plane_size *plane_size,
@@ -260,8 +391,6 @@ bool dce_mem_input_program_surface_config(struct mem_input *mi,
 	if (format >= SURFACE_PIXEL_FORMAT_GRPH_BEGIN &&
 		format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 		program_grph_pixel_format(mi, format);
-
-	return true;
 }
 
 static uint32_t get_dmif_switch_time_us(

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
new file mode 100644
index 000000000000..654731cccdcd
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_mem_input.c
@@ -0,0 +1,384 @@
+/*
+ * Copyright 2016 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "mem_input.h"
+#include "reg_helper.h"
+
+#define CTX \
+	mi->ctx
+#define REG(reg)\
+	mi->regs->reg
+
+#undef FN
+#define FN(reg_name, field_name) \
+	mi->shifts->field_name, mi->masks->field_name
+
+
+static void program_urgency_watermark(struct mem_input *mi,
+	uint32_t wm_select,
+	uint32_t urgency_low_wm,
+	uint32_t urgency_high_wm)
+{
+	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
+		URGENCY_WATERMARK_MASK, wm_select);
+
+	REG_SET_2(DPG_PIPE_URGENCY_CONTROL, 0,
+		URGENCY_LOW_WATERMARK, urgency_low_wm,
+		URGENCY_HIGH_WATERMARK, urgency_high_wm);
+}
+
+static void program_nbp_watermark(struct mem_input *mi,
+	uint32_t wm_select,
+	uint32_t nbp_wm)
+{
+	if (REG(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL)) {
+		REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
+				NB_PSTATE_CHANGE_WATERMARK_MASK, wm_select);
+
+		REG_UPDATE_3(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
+				NB_PSTATE_CHANGE_ENABLE, 1,
+				NB_PSTATE_CHANGE_URGENT_DURING_REQUEST, 1,
+				NB_PSTATE_CHANGE_NOT_SELF_REFRESH_DURING_REQUEST, 1);
+
+		REG_UPDATE(DPG_PIPE_NB_PSTATE_CHANGE_CONTROL,
+				NB_PSTATE_CHANGE_WATERMARK, nbp_wm);
+	}
+}
+
+static void program_stutter_watermark(struct mem_input *mi,
+	uint32_t wm_select,
+	uint32_t stutter_mark)
+{
+	REG_UPDATE(DPG_WATERMARK_MASK_CONTROL,
+		STUTTER_EXIT_SELF_REFRESH_WATERMARK_MASK, wm_select);
+
+		REG_UPDATE(DPG_PIPE_STUTTER_CONTROL,
+				STUTTER_EXIT_SELF_REFRESH_WATERMARK, stutter_mark);
+}
+
+void dce_mem_input_program_display_marks(struct mem_input *mi,
+	struct bw_watermarks nbp,
+	struct bw_watermarks stutter,
+	struct bw_watermarks urgent,
+	uint32_t total_dest_line_time_ns)
+{
+	uint32_t stutter_en = mi->ctx->dc->debug.disable_stutter ? 0 : 1;
+
+	program_urgency_watermark(mi, 0, /* set a */
+			urgent.a_mark, total_dest_line_time_ns);
+	program_urgency_watermark(mi, 1, /* set b */
+			urgent.b_mark, total_dest_line_time_ns);
+	program_urgency_watermark(mi, 2, /* set c */
+			urgent.c_mark, total_dest_line_time_ns);
+	program_urgency_watermark(mi, 3, /* set d */
+			urgent.d_mark, total_dest_line_time_ns);
+
+	REG_UPDATE_2(DPG_PIPE_STUTTER_CONTROL,
+		STUTTER_ENABLE, stutter_en,
+		STUTTER_IGNORE_FBC, 1);
+	program_nbp_watermark(mi, 0, nbp.a_mark); /* set a */
+	program_nbp_watermark(mi, 1, nbp.b_mark); /* set b */
+	program_nbp_watermark(mi, 2, nbp.c_mark); /* set c */
+	program_nbp_watermark(mi, 3, nbp.d_mark); /* set d */
+
+	program_stutter_watermark(mi, 0, stutter.a_mark); /* set a */
+	program_stutter_watermark(mi, 1, stutter.b_mark); /* set b */
+	program_stutter_watermark(mi, 2, stutter.c_mark); /* set c */
+	program_stutter_watermark(mi, 3, stutter.d_mark); /* set d */
+}
+
+static void program_tiling(struct mem_input *mi,
+	const union dc_tiling_info *info)
+{
+	if (mi->masks->GRPH_ARRAY_MODE) { /* GFX8 */
+		REG_UPDATE_9(GRPH_CONTROL,
+				GRPH_NUM_BANKS, info->gfx8.num_banks,
+				GRPH_BANK_WIDTH, info->gfx8.bank_width,
+				GRPH_BANK_HEIGHT, info->gfx8.bank_height,
+				GRPH_MACRO_TILE_ASPECT, info->gfx8.tile_aspect,
+				GRPH_TILE_SPLIT, info->gfx8.tile_split,
+				GRPH_MICRO_TILE_MODE, info->gfx8.tile_mode,
+				GRPH_PIPE_CONFIG, info->gfx8.pipe_config,
+				GRPH_ARRAY_MODE, info->gfx8.array_mode,
+				GRPH_COLOR_EXPANSION_MODE, 1);
+		/* 01 - DCP_GRPH_COLOR_EXPANSION_MODE_ZEXP: zero expansion for YCbCr */
+		/*
+				GRPH_Z, 0);
+				*/
+	}
+}
+
+
+static void program_size_and_rotation(
+	struct mem_input *mi,
+	enum dc_rotation_angle rotation,
+	const union plane_size *plane_size)
+{
+	const struct rect *in_rect = &plane_size->grph.surface_size;
+	struct rect hw_rect = plane_size->grph.surface_size;
+	const uint32_t rotation_angles[ROTATION_ANGLE_COUNT] = {
+			[ROTATION_ANGLE_0] = 0,
+			[ROTATION_ANGLE_90] = 1,
+			[ROTATION_ANGLE_180] = 2,
+			[ROTATION_ANGLE_270] = 3,
+	};
+
+	if (rotation == ROTATION_ANGLE_90 || rotation == ROTATION_ANGLE_270) {
+		hw_rect.x = in_rect->y;
+		hw_rect.y = in_rect->x;
+
+		hw_rect.height = in_rect->width;
+		hw_rect.width = in_rect->height;
+	}
+
+	REG_SET(GRPH_X_START, 0,
+			GRPH_X_START, hw_rect.x);
+
+	REG_SET(GRPH_Y_START, 0,
+			GRPH_Y_START, hw_rect.y);
+
+	REG_SET(GRPH_X_END, 0,
+			GRPH_X_END, hw_rect.width);
+
+	REG_SET(GRPH_Y_END, 0,
+			GRPH_Y_END, hw_rect.height);
+
+	REG_SET(GRPH_PITCH, 0,
+			GRPH_PITCH, plane_size->grph.surface_pitch);
+
+	REG_SET(HW_ROTATION, 0,
+			GRPH_ROTATION_ANGLE, rotation_angles[rotation]);
+}
+
+static void program_grph_pixel_format(
+	struct mem_input *mi,
+	enum surface_pixel_format format)
+{
+	uint32_t red_xbar = 0, blue_xbar = 0; /* no swap */
+	uint32_t grph_depth, grph_format;
+	uint32_t sign = 0, floating = 0;
+
+	if (format == SURFACE_PIXEL_FORMAT_GRPH_BGRA8888 ||
+			/*todo: doesn't look like we handle BGRA here,
+			 *  should problem swap endian*/
+		format == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010 ||
+		format == SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS ||
+		format == SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F) {
+		/* ABGR formats */
+		red_xbar = 2;
+		blue_xbar = 2;
+	}
+
+	REG_SET_2(GRPH_SWAP_CNTL, 0,
+			GRPH_RED_CROSSBAR, red_xbar,
+			GRPH_BLUE_CROSSBAR, blue_xbar);
+
+	switch (format) {
+	case SURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS:
+		grph_depth = 0;
+		grph_format = 0;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB1555:
+		grph_depth = 1;
+		grph_format = 0;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_RGB565:
+		grph_depth = 1;
+		grph_format = 1;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB8888:
+	case SURFACE_PIXEL_FORMAT_GRPH_BGRA8888:
+		grph_depth = 2;
+		grph_format = 0;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010:
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010_XR_BIAS:
+		grph_depth = 2;
+		grph_format = 1;
+		break;
+	case SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F:
+		sign = 1;
+		floating = 1;
+		/* no break */
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F: /* shouldn't this get float too? */
+	case SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616:
+		grph_depth = 3;
+		grph_format = 0;
+		break;
+	default:
+		DC_ERR("unsupported grph pixel format");
+		break;
+	}
+
+	REG_UPDATE_2(GRPH_CONTROL,
+			GRPH_DEPTH, grph_depth,
+			GRPH_FORMAT, grph_format);
+
+	REG_UPDATE_4(PRESCALE_GRPH_CONTROL,
+			GRPH_PRESCALE_SELECT, floating,
+			GRPH_PRESCALE_R_SIGN, sign,
+			GRPH_PRESCALE_G_SIGN, sign,
+			GRPH_PRESCALE_B_SIGN, sign);
+}
+
+bool dce_mem_input_program_surface_config(struct mem_input *mi,
+	enum surface_pixel_format format,
+	union dc_tiling_info *tiling_info,
+	union plane_size *plane_size,
+	enum dc_rotation_angle rotation,
+	struct dc_plane_dcc_param *dcc,
+	bool horizontal_mirror)
+{
+	REG_UPDATE(GRPH_ENABLE, GRPH_ENABLE, 1);
+
+	program_tiling(mi, tiling_info);
+	program_size_and_rotation(mi, rotation, plane_size);
+
+	if (format >= SURFACE_PIXEL_FORMAT_GRPH_BEGIN &&
+		format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+		program_grph_pixel_format(mi, format);
+
+	return true;
+}
+
+static uint32_t get_dmif_switch_time_us(
+	uint32_t h_total,
+	uint32_t v_total,
+	uint32_t pix_clk_khz)
+{
+	uint32_t frame_time;
+	uint32_t pixels_per_second;
+	uint32_t pixels_per_frame;
+	uint32_t refresh_rate;
+	const uint32_t us_in_sec = 1000000;
+	const uint32_t min_single_frame_time_us = 30000;
+	/*return double of frame time*/
+	const uint32_t single_frame_time_multiplier = 2;
+
+	if (!h_total || v_total || !pix_clk_khz)
+		return single_frame_time_multiplier * min_single_frame_time_us;
+
+	/*TODO: should we use pixel format normalized pixel clock here?*/
+	pixels_per_second = pix_clk_khz * 1000;
+	pixels_per_frame = h_total * v_total;
+
+	if (!pixels_per_second || !pixels_per_frame) {
+		/* avoid division by zero */
+		ASSERT(pixels_per_frame);
+		ASSERT(pixels_per_second);
+		return single_frame_time_multiplier * min_single_frame_time_us;
+	}
+
+	refresh_rate = pixels_per_second / pixels_per_frame;
+
+	if (!refresh_rate) {
+		/* avoid division by zero*/
+		ASSERT(refresh_rate);
+		return single_frame_time_multiplier * min_single_frame_time_us;
+	}
+
+	frame_time = us_in_sec / refresh_rate;
+
+	if (frame_time < min_single_frame_time_us)
+		frame_time = min_single_frame_time_us;
+
+	frame_time *= single_frame_time_multiplier;
+
+	return frame_time;
+}
+
+void dce_mem_input_allocate_dmif(struct mem_input *mi,
+	uint32_t h_total,
+	uint32_t v_total,
+	uint32_t pix_clk_khz,
+	uint32_t total_stream_num)
+{
+	const uint32_t retry_delay = 10;
+	uint32_t retry_count = get_dmif_switch_time_us(
+			h_total,
+			v_total,
+			pix_clk_khz) / retry_delay;
+
+	uint32_t pix_dur;
+	uint32_t buffers_allocated;
+	uint32_t dmif_buffer_control;
+
+	dmif_buffer_control = REG_GET(DMIF_BUFFER_CONTROL,
+			DMIF_BUFFERS_ALLOCATED, &buffers_allocated);
+
+	if (buffers_allocated == 2)
+		return;
+
+	REG_SET(DMIF_BUFFER_CONTROL, dmif_buffer_control,
+			DMIF_BUFFERS_ALLOCATED, 2);
+
+	REG_WAIT(DMIF_BUFFER_CONTROL,
+			DMIF_BUFFERS_ALLOCATION_COMPLETED, 1,
+			retry_delay, retry_count);
+
+	if (pix_clk_khz != 0) {
+		pix_dur = 1000000000ULL / pix_clk_khz;
+
+		REG_UPDATE(DPG_PIPE_ARBITRATION_CONTROL1,
+			PIXEL_DURATION, pix_dur);
+	}
+
+	if (mi->wa.single_head_rdreq_dmif_limit) {
+		uint32_t eanble =  (total_stream_num > 1) ? 0 :
+				mi->wa.single_head_rdreq_dmif_limit;
+
+		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
+				ENABLE, eanble);
+	}
+}
+
+void dce_mem_input_free_dmif(struct mem_input *mi,
+		uint32_t total_stream_num)
+{
+	uint32_t buffers_allocated;
+	uint32_t dmif_buffer_control;
+
+	dmif_buffer_control = REG_GET(DMIF_BUFFER_CONTROL,
+			DMIF_BUFFERS_ALLOCATED, &buffers_allocated);
+
+	if (buffers_allocated == 0)
+		return;
+
+	REG_SET(DMIF_BUFFER_CONTROL, dmif_buffer_control,
+			DMIF_BUFFERS_ALLOCATED, 0);
+
+	REG_WAIT(DMIF_BUFFER_CONTROL,
+			DMIF_BUFFERS_ALLOCATION_COMPLETED, 1,
+			10, 0xBB8);
+
+	if (mi->wa.single_head_rdreq_dmif_limit) {
+		uint32_t eanble =  (total_stream_num > 1) ? 0 :
+				mi->wa.single_head_rdreq_dmif_limit;
+
+		REG_UPDATE(MC_HUB_RDREQ_DMIF_LIMIT,
+				ENABLE, eanble);
+	}
+}
