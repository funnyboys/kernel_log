commit d4caa72e275c1920d38a9541b2e4dcc167733734
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Wed Apr 8 13:31:50 2020 -0400

    drm/amd/display: change from panel to panel cntl
    
    [Why]
    it doesn't represent panel specifically, it's more like the control
    logic for the panel
    
    [How]
    change from panel to panel cntl to make it a bit more clear
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index dca7f7c0b488..a19be9de2df7 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -50,7 +50,7 @@
 #include "dce/dce_hwseq.h"
 #include "dce80/dce80_hw_sequencer.h"
 #include "dce100/dce100_resource.h"
-#include "dce/dce_panel.h"
+#include "dce/dce_panel_cntl.h"
 
 #include "reg_helper.h"
 
@@ -267,16 +267,16 @@ static const struct dce_stream_encoder_mask se_mask = {
 		SE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)
 };
 
-static const struct dce_panel_registers panel_regs[] = {
-	{ DCE_PANEL_REG_LIST() }
+static const struct dce_panel_cntl_registers panel_cntl_regs[] = {
+	{ DCE_PANEL_CNTL_REG_LIST() }
 };
 
-static const struct dce_panel_shift panel_shift = {
-	DCE_PANEL_MASK_SH_LIST(__SHIFT)
+static const struct dce_panel_cntl_shift panel_cntl_shift = {
+	DCE_PANEL_CNTL_MASK_SH_LIST(__SHIFT)
 };
 
-static const struct dce_panel_mask panel_mask = {
-	DCE_PANEL_MASK_SH_LIST(_MASK)
+static const struct dce_panel_cntl_mask panel_cntl_mask = {
+	DCE_PANEL_CNTL_MASK_SH_LIST(_MASK)
 };
 
 #define opp_regs(id)\
@@ -741,21 +741,21 @@ struct link_encoder *dce80_link_encoder_create(
 	return &enc110->base;
 }
 
-static struct panel *dce80_panel_create(const struct panel_init_data *init_data)
+static struct panel_cntl *dce80_panel_cntl_create(const struct panel_cntl_init_data *init_data)
 {
-	struct dce_panel *panel =
-		kzalloc(sizeof(struct dce_panel), GFP_KERNEL);
+	struct dce_panel_cntl *panel_cntl =
+		kzalloc(sizeof(struct dce_panel_cntl), GFP_KERNEL);
 
-	if (!panel)
+	if (!panel_cntl)
 		return NULL;
 
-	dce_panel_construct(panel,
+	dce_panel_cntl_construct(panel_cntl,
 			init_data,
-			&panel_regs[init_data->inst],
-			&panel_shift,
-			&panel_mask);
+			&panel_cntl_regs[init_data->inst],
+			&panel_cntl_shift,
+			&panel_cntl_mask);
 
-	return &panel->base;
+	return &panel_cntl->base;
 }
 
 struct clock_source *dce80_clock_source_create(
@@ -939,7 +939,7 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce80_res_pool_funcs = {
 	.destroy = dce80_destroy_resource_pool,
 	.link_enc_create = dce80_link_encoder_create,
-	.panel_create = dce80_panel_create,
+	.panel_cntl_create = dce80_panel_cntl_create,
 	.validate_bandwidth = dce80_validate_bandwidth,
 	.validate_plane = dce100_validate_plane,
 	.add_stream_to_ctx = dce100_add_stream_to_ctx,

commit 904fb6e0f4e8158e6db1e21c3c97bdc238e537f5
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Sat Mar 28 01:44:14 2020 -0400

    drm/amd/display: move panel power seq to new panel struct
    
    [Why]
    panel power sequencer is currently just sitting in hwseq but it really
    it tied to internal panels
    
    [How]
    make a new panel struct to contain power sequencer code
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 2ad5c28c6e66..dca7f7c0b488 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -50,6 +50,7 @@
 #include "dce/dce_hwseq.h"
 #include "dce80/dce80_hw_sequencer.h"
 #include "dce100/dce100_resource.h"
+#include "dce/dce_panel.h"
 
 #include "reg_helper.h"
 
@@ -266,6 +267,18 @@ static const struct dce_stream_encoder_mask se_mask = {
 		SE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)
 };
 
+static const struct dce_panel_registers panel_regs[] = {
+	{ DCE_PANEL_REG_LIST() }
+};
+
+static const struct dce_panel_shift panel_shift = {
+	DCE_PANEL_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce_panel_mask panel_mask = {
+	DCE_PANEL_MASK_SH_LIST(_MASK)
+};
+
 #define opp_regs(id)\
 [id] = {\
 	OPP_DCE_80_REG_LIST(id),\
@@ -728,6 +741,23 @@ struct link_encoder *dce80_link_encoder_create(
 	return &enc110->base;
 }
 
+static struct panel *dce80_panel_create(const struct panel_init_data *init_data)
+{
+	struct dce_panel *panel =
+		kzalloc(sizeof(struct dce_panel), GFP_KERNEL);
+
+	if (!panel)
+		return NULL;
+
+	dce_panel_construct(panel,
+			init_data,
+			&panel_regs[init_data->inst],
+			&panel_shift,
+			&panel_mask);
+
+	return &panel->base;
+}
+
 struct clock_source *dce80_clock_source_create(
 	struct dc_context *ctx,
 	struct dc_bios *bios,
@@ -909,6 +939,7 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce80_res_pool_funcs = {
 	.destroy = dce80_destroy_resource_pool,
 	.link_enc_create = dce80_link_encoder_create,
+	.panel_create = dce80_panel_create,
 	.validate_bandwidth = dce80_validate_bandwidth,
 	.validate_plane = dce100_validate_plane,
 	.add_stream_to_ctx = dce100_add_stream_to_ctx,

commit d9e32672a1285d6c5e06bedaabb465441c172aa8
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Thu Oct 31 21:39:39 2019 -0400

    drm/amd/display: cleanup of construct and destruct funcs
    
    [Why]
    Too many construct functions which makes searching
    difficult, especially on some debuggers.
    
    [How]
    Append all construct and destruct functions with dcn
    number and object type to make each construct function
    name unique
    
    Signed-off-by: Anthony Koo <Anthony.Koo@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 3e8d4b49f279..2ad5c28c6e66 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -773,7 +773,7 @@ static struct input_pixel_processor *dce80_ipp_create(
 	return &ipp->base;
 }
 
-static void destruct(struct dce110_resource_pool *pool)
+static void dce80_resource_destruct(struct dce110_resource_pool *pool)
 {
 	unsigned int i;
 
@@ -901,7 +901,7 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 {
 	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
 
-	destruct(dce110_pool);
+	dce80_resource_destruct(dce110_pool);
 	kfree(dce110_pool);
 	*pool = NULL;
 }
@@ -1093,7 +1093,7 @@ static bool dce80_construct(
 	return true;
 
 res_create_fail:
-	destruct(pool);
+	dce80_resource_destruct(pool);
 	return false;
 }
 
@@ -1290,7 +1290,7 @@ static bool dce81_construct(
 	return true;
 
 res_create_fail:
-	destruct(pool);
+	dce80_resource_destruct(pool);
 	return false;
 }
 
@@ -1483,7 +1483,7 @@ static bool dce83_construct(
 	return true;
 
 res_create_fail:
-	destruct(pool);
+	dce80_resource_destruct(pool);
 	return false;
 }
 

commit bf7f5ac3167a75f60c2f27f16613a6ab90e55908
Author: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
Date:   Wed Oct 2 12:36:33 2019 +0530

    drm/amd/display: map TRANSMITTER_UNIPHY_x to LINK_REGS_x
    
    [Why]
    The enum value for TRANSMITTER_UNIPHY_G is 9. In resource dc_xx_resource
    file structure link_enc_regs[], the TRANSMITTER_UNIPHY_G registers are
    initialized at index 6. Due to this mismatch, if monitor is attached to
    port using TRANSMITTER_UNIPHY_G then the monitor blanks out.
    
    [How]
    add function map_transmitter_id_to_phy_instance() and use the function
    to map enum transmitter to link regs.
    
    Signed-off-by: Yogesh Mohan Marimuthu <yogesh.mohanmarimuthu@amd.com>
    Reviewed-by: Eric Yang <eric.yang2@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 59ebd657462d..3e8d4b49f279 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -439,6 +439,37 @@ static const struct dce_abm_mask abm_mask = {
 #define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8
 #endif
 
+static int map_transmitter_id_to_phy_instance(
+	enum transmitter transmitter)
+{
+	switch (transmitter) {
+	case TRANSMITTER_UNIPHY_A:
+		return 0;
+	break;
+	case TRANSMITTER_UNIPHY_B:
+		return 1;
+	break;
+	case TRANSMITTER_UNIPHY_C:
+		return 2;
+	break;
+	case TRANSMITTER_UNIPHY_D:
+		return 3;
+	break;
+	case TRANSMITTER_UNIPHY_E:
+		return 4;
+	break;
+	case TRANSMITTER_UNIPHY_F:
+		return 5;
+	break;
+	case TRANSMITTER_UNIPHY_G:
+		return 6;
+	break;
+	default:
+		ASSERT(0);
+		return 0;
+	}
+}
+
 static void read_dce_straps(
 	struct dc_context *ctx,
 	struct resource_straps *straps)
@@ -680,14 +711,18 @@ struct link_encoder *dce80_link_encoder_create(
 {
 	struct dce110_link_encoder *enc110 =
 		kzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);
+	int link_regs_id;
 
 	if (!enc110)
 		return NULL;
 
+	link_regs_id =
+		map_transmitter_id_to_phy_instance(enc_init_data->transmitter);
+
 	dce110_link_encoder_construct(enc110,
 				      enc_init_data,
 				      &link_enc_feature,
-				      &link_enc_regs[enc_init_data->transmitter],
+				      &link_enc_regs[link_regs_id],
 				      &link_enc_aux_regs[enc_init_data->channel - 1],
 				      &link_enc_hpd_regs[enc_init_data->hpd_source]);
 	return &enc110->base;

commit f6040a439f9b6d9f90b7d4ef56762f412dfd1f9d
Author: abdoulaye berthe <abdoulaye.berthe@amd.com>
Date:   Thu Jul 18 15:58:25 2019 -0400

    drm/amd/display: configurable aux timeout support
    
    [Description]
    1-add configurable timeout support to aux engine.
    2-add timeout support field to dc_caps
    3-add reg_key to override extended timeout support
    
    Signed-off-by: abdoulaye berthe <abdoulaye.berthe@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 04235be2d617..59ebd657462d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -501,7 +501,8 @@ struct dce_aux *dce80_aux_engine_create(
 				    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,
 				    &aux_engine_regs[inst],
 					&aux_mask,
-					&aux_shift);
+					&aux_shift,
+					ctx->dc->caps.extended_aux_timeout_support);
 
 	return &aux_engine->base;
 }
@@ -905,6 +906,7 @@ static bool dce80_construct(
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;
 	dc->caps.dual_link_dvi = true;
+	dc->caps.extended_aux_timeout_support = false;
 
 	/*************************************************
 	 *  Create resources                             *

commit 8276dd871fd4240037cffb3904eda2dfe028fd85
Author: abdoulaye berthe <abdoulaye.berthe@amd.com>
Date:   Tue Aug 13 09:24:10 2019 -0400

    drm/amd/display: update register field access mechanism
    
    1-add timeout length and multiplier fields to aux_control1 register
    2-update access mechanism from macro constructed name to uint32_t
    defined addresses.
    3-define registers and field per asic family
    
    Signed-off-by: abdoulaye berthe <abdoulaye.berthe@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 643ccb0ade00..04235be2d617 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -288,6 +288,14 @@ static const struct dce_opp_mask opp_mask = {
 	OPP_COMMON_MASK_SH_LIST_DCE_80(_MASK)
 };
 
+static const struct dce110_aux_registers_shift aux_shift = {
+	DCE10_AUX_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce110_aux_registers_mask aux_mask = {
+	DCE10_AUX_MASK_SH_LIST(_MASK)
+};
+
 #define aux_engine_regs(id)\
 [id] = {\
 	AUX_COMMON_REG_LIST(id), \
@@ -491,7 +499,9 @@ struct dce_aux *dce80_aux_engine_create(
 
 	dce110_aux_engine_construct(aux_engine, ctx, inst,
 				    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,
-				    &aux_engine_regs[inst]);
+				    &aux_engine_regs[inst],
+					&aux_mask,
+					&aux_shift);
 
 	return &aux_engine->base;
 }

commit cabe144bfd0c106c2e55d900320c2464c42ab94c
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Mon Sep 16 22:20:44 2019 -0500

    drm/amd/display: memory leak
    
    In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated
    clk_src needs release.
    
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 4625df9f9fd2..643ccb0ade00 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -701,6 +701,7 @@ struct clock_source *dce80_clock_source_create(
 		return &clk_src->base;
 	}
 
+	kfree(clk_src);
 	BREAK_TO_DEBUGGER();
 	return NULL;
 }

commit 9adc8050bf3ca3e49c65e13259a4c310640542f1
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Jul 12 15:06:06 2019 -0400

    drm/amd/display: make firmware info only load once during dc_bios create
    
    Currently every time DC wants to access firmware info we make a call
    into VBIOS. This makes no sense as there is nothing that can change
    runtime inside fw info and can cause issues when calling unstable
    bios during bringup.
    
    This change eliminate this behavior by only calling bios once for fw
    info and keeping it stored as part of dc_bios.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Chris Park <Chris.Park@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 2a1ce9ecc66e..4625df9f9fd2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -876,7 +876,6 @@ static bool dce80_construct(
 {
 	unsigned int i;
 	struct dc_context *ctx = dc->ctx;
-	struct dc_firmware_info info;
 	struct dc_bios *bp;
 
 	ctx->dc_bios->regs = &bios_regs;
@@ -902,8 +901,7 @@ static bool dce80_construct(
 
 	bp = ctx->dc_bios;
 
-	if ((bp->funcs->get_firmware_info(bp, &info) == BP_RESULT_OK) &&
-		info.external_clock_source_frequency_for_dp != 0) {
+	if (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {
 		pool->base.dp_clock_source =
 				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
 
@@ -1075,7 +1073,6 @@ static bool dce81_construct(
 {
 	unsigned int i;
 	struct dc_context *ctx = dc->ctx;
-	struct dc_firmware_info info;
 	struct dc_bios *bp;
 
 	ctx->dc_bios->regs = &bios_regs;
@@ -1101,8 +1098,7 @@ static bool dce81_construct(
 
 	bp = ctx->dc_bios;
 
-	if ((bp->funcs->get_firmware_info(bp, &info) == BP_RESULT_OK) &&
-		info.external_clock_source_frequency_for_dp != 0) {
+	if (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {
 		pool->base.dp_clock_source =
 				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
 
@@ -1274,7 +1270,6 @@ static bool dce83_construct(
 {
 	unsigned int i;
 	struct dc_context *ctx = dc->ctx;
-	struct dc_firmware_info info;
 	struct dc_bios *bp;
 
 	ctx->dc_bios->regs = &bios_regs;
@@ -1300,8 +1295,7 @@ static bool dce83_construct(
 
 	bp = ctx->dc_bios;
 
-	if ((bp->funcs->get_firmware_info(bp, &info) == BP_RESULT_OK) &&
-		info.external_clock_source_frequency_for_dp != 0) {
+	if (bp->fw_info_valid && bp->fw_info.external_clock_source_frequency_for_dp != 0) {
 		pool->base.dp_clock_source =
 				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
 

commit 54a9bcb0a4ff6ee401955a1e2e657b97b9391eb7
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Fri Aug 9 22:12:19 2019 +0200

    drm/amd/display: Fix a typo - dce_aduio_mask --> dce_audio_mask
    
    This should be 'dce_audio_mask', not 'dce_aduio_mask'.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 860a524ebcfa..2a1ce9ecc66e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -322,7 +322,7 @@ static const struct dce_audio_shift audio_shift = {
 		AUD_COMMON_MASK_SH_LIST(__SHIFT)
 };
 
-static const struct dce_aduio_mask audio_mask = {
+static const struct dce_audio_mask audio_mask = {
 		AUD_COMMON_MASK_SH_LIST(_MASK)
 };
 

commit 2454fcea338ad821a39d471bc7db5a58ba41b742
Merge: 561564bea324 51e857af9f3f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Fri Jun 14 11:31:13 2019 +0200

    Merge tag 'drm-misc-next-2019-06-14' of git://anongit.freedesktop.org/drm/drm-misc into drm-next
    
    drm-misc-next for v5.3:
    
    UAPI Changes:
    
    Cross-subsystem Changes:
    - Add code to signal all dma-fences when freed with pending signals.
    - Annotate reservation object access in CONFIG_DEBUG_MUTEXES
    
    Core Changes:
    - Assorted documentation fixes.
    - Use irqsave/restore spinlock to add crc entry.
    - Move code around to drm_client, for internal modeset clients.
    - Make drm_crtc.h and drm_debugfs.h self-contained.
    - Remove drm_fb_helper_connector.
    - Add bootsplash to todo.
    - Fix lock ordering in pan_display_legacy.
    - Support pinning buffers to current location in gem-vram.
    - Remove the now unused locking functions from gem-vram.
    - Remove the now unused kmap-object argument from vram helpers.
    - Stop checking return value of debugfs_create.
    - Add atomic encoder enable/disable helpers.
    - pass drm_atomic_state to atomic connector check.
    - Add atomic support for bridge enable/disable.
    - Add self refresh helpers to core.
    
    Driver Changes:
    - Add extra delay to make MTP SDM845 work.
    - Small fixes to virtio, vkms, sii902x, sii9234, ast, mcde, analogix, rockchip.
    - Add zpos and ?BGR8888 support to meson.
    - More removals of drm_os_linux and drmP headers for amd, radeon, sti, r128, r128, savage, sis.
    - Allow synopsis to unwedge the i2c hdmi bus.
    - Add orientation quirks for GPD panels.
    - Edid cleanups and fixing handling for edid < 1.2.
    - Add runtime pm to stm.
    - Handle s/r in dw-hdmi.
    - Add hooks for power on/off to dsi for stm.
    - Remove virtio dirty tracking code, done in drm core.
    - Rework BO handling in ast and mgag200.
    
    Tiny conflict in drivers/gpu/drm/amd/display/dc/clk_mgr/clk_mgr.c,
    needed #include <linux/slab.h> to make it compile.
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/0e01de30-9797-853c-732f-4a5bd6e61445@linux.intel.com

commit 4fc4dca8320e46b067037496fde3a6d95381d60f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 10 00:07:50 2019 +0200

    drm/amd: drop use of drmp.h in os_types.h
    
    Drop use of the deprecated drmP.h from display/dc/os_types.h
    
    Fix all fallout after this change.
    Most of the fixes was adding a missing include of vmalloc.h.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: "Christian KÃ¶nig" <christian.koenig@amd.com>
    Cc: "David (ChunMing) Zhou" <David1.Zhou@amd.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190609220757.10862-4-sam@ravnborg.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 27d0cc394963..83c4cc8516c1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -23,6 +23,8 @@
  *
  */
 
+#include <linux/slab.h>
+
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 

commit dc88b4a684d284a200c0ecfd8d87179d6f6c89a3
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Mon Apr 22 19:39:35 2019 -0400

    drm/amd/display: make clk mgr soc specific
    
    [Why]
    First step of refactoring clk mgr to better handle different
    ways of handling clock operations. Clock operation policies are
    soc specific and not just DCN vesion specific. It is not a hw resource,
    should not be in the resource pool.
    
    [How]
    Change clock manager creation to be based on HW internal ID, rename
    clock manager members to be more clear. Move clock manager out of
    resource.
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 2c21135a8510..1dccd59c59c5 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -37,7 +37,6 @@
 #include "dce110/dce110_timing_generator.h"
 #include "dce110/dce110_resource.h"
 #include "dce80/dce80_timing_generator.h"
-#include "dce/dce_clk_mgr.h"
 #include "dce/dce_mem_input.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
@@ -154,19 +153,6 @@ static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
 #define SRI(reg_name, block, id)\
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
-
-static const struct clk_mgr_registers disp_clk_regs = {
-		CLK_COMMON_REG_LIST_DCE_BASE()
-};
-
-static const struct clk_mgr_shift disp_clk_shift = {
-		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
-};
-
-static const struct clk_mgr_mask disp_clk_mask = {
-		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
-};
-
 #define ipp_regs(id)\
 [id] = {\
 		IPP_COMMON_REG_LIST_DCE_BASE(id)\
@@ -802,9 +788,6 @@ static void destruct(struct dce110_resource_pool *pool)
 		}
 	}
 
-	if (pool->base.clk_mgr != NULL)
-		dce_clk_mgr_destroy(&pool->base.clk_mgr);
-
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
 	}
@@ -955,16 +938,6 @@ static bool dce80_construct(
 		}
 	}
 
-	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
-			&disp_clk_regs,
-			&disp_clk_shift,
-			&disp_clk_mask);
-	if (pool->base.clk_mgr == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto res_create_fail;
-	}
-
 	pool->base.dmcu = dce_dmcu_create(ctx,
 			&dmcu_regs,
 			&dmcu_shift,
@@ -1164,16 +1137,6 @@ static bool dce81_construct(
 		}
 	}
 
-	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
-			&disp_clk_regs,
-			&disp_clk_shift,
-			&disp_clk_mask);
-	if (pool->base.clk_mgr == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto res_create_fail;
-	}
-
 	pool->base.dmcu = dce_dmcu_create(ctx,
 			&dmcu_regs,
 			&dmcu_shift,
@@ -1369,16 +1332,6 @@ static bool dce83_construct(
 		}
 	}
 
-	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
-			&disp_clk_regs,
-			&disp_clk_shift,
-			&disp_clk_mask);
-	if (pool->base.clk_mgr == NULL) {
-		dm_error("DC: failed to create display clock!\n");
-		BREAK_TO_DEBUGGER();
-		goto res_create_fail;
-	}
-
 	pool->base.dmcu = dce_dmcu_create(ctx,
 			&dmcu_regs,
 			&dmcu_shift,

commit 78cc70b1e47d660207dabf75ca2751fc1e4edf84
Author: Wesley Chalmers <Wesley.Chalmers@amd.com>
Date:   Wed Apr 24 15:25:41 2019 -0400

    drm/amd/display: Engine-specific encoder allocation
    
    [WHY]
    From DCE110 onward, we have the ability to assign DIG BE and FE
    separately for any display connector type; before, we could only do this
    for DP.
    
    Signed-off-by: Wesley Chalmers <Wesley.Chalmers@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 27d0cc394963..2c21135a8510 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -880,7 +880,8 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_bandwidth = dce80_validate_bandwidth,
 	.validate_plane = dce100_validate_plane,
 	.add_stream_to_ctx = dce100_add_stream_to_ctx,
-	.validate_global = dce80_validate_global
+	.validate_global = dce80_validate_global,
+	.find_first_free_match_stream_enc_for_link = dce100_find_first_free_match_stream_enc_for_link
 };
 
 static bool dce80_construct(

commit afcd526b1ba9dbc5707f9bd8d2d032ae62e337dc
Author: Joshua Aberback <joshua.aberback@amd.com>
Date:   Mon Apr 1 15:18:29 2019 -0400

    drm/amd/display: Add fast_validate parameter
    
    Add a fast_validate parameter in dc_validate_global_state for future use
    
    Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 9569f3af12a3..27d0cc394963 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -812,7 +812,8 @@ static void destruct(struct dce110_resource_pool *pool)
 
 bool dce80_validate_bandwidth(
 	struct dc *dc,
-	struct dc_state *context)
+	struct dc_state *context,
+	bool fast_validate)
 {
 	int i;
 	bool at_least_one_pipe = false;

commit ea36ad34c5b2d6d2e079efc20fb0784e63dad438
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Mar 26 17:32:59 2019 -0400

    drm/amd/display: expand plane caps to include fp16 and scaling capability
    
    [why]
    there are some scaling capabilities such as fp16 which are known to be unsupported
    on a given ASIC.  exposing these static capabilities allows much simpler implementation
    for OS interfaces which require to report such static capabilities to reduce the
    number of dynamic validation calls
    
    [how]
    refactor the existing plane caps to be more extensible, and add fp16 and scaling
    capabilities
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet Lakha@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index c7899ec96287..9569f3af12a3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -389,7 +389,24 @@ static const struct resource_caps res_cap_83 = {
 
 static const struct dc_plane_cap plane_cap = {
 	.type = DC_PLANE_TYPE_DCE_RGB,
-	.supports_argb8888 = true,
+
+	.pixel_format_support = {
+			.argb8888 = true,
+			.nv12 = false,
+			.fp16 = false
+	},
+
+	.max_upscale_factor = {
+			.argb8888 = 16000,
+			.nv12 = 1,
+			.fp16 = 1
+	},
+
+	.max_downscale_factor = {
+			.argb8888 = 250,
+			.nv12 = 1,
+			.fp16 = 1
+	}
 };
 
 static const struct dce_dmcu_registers dmcu_regs = {

commit 813d20dccf93f84f4c16236f7c037dc34db48f10
Author: Aidan Wood <Aidan.Wood@amd.com>
Date:   Fri Feb 22 13:37:03 2019 -0500

    drm/amd/display: Fix multi-thread writing to 1 state
    
    [Why]
    Multiple threads were writing back to one global VBA in DC resulting
    in multiple threads overwriting eachother's data
    
    [How]
    Add an instance of DML (which contains VBA) to each context and
    change all calls that used dc->dml to use context->dml. Created a
    seperate copy constructor for linux in a case where there is no
    access to DC.
    
    Signed-off-by: Aidan Wood <Aidan.Wood@amd.com>
    Reviewed-by: Jun Lei <Jun.Lei@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 066fd89747c2..c7899ec96287 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -807,11 +807,11 @@ bool dce80_validate_bandwidth(
 
 	if (at_least_one_pipe) {
 		/* TODO implement when needed but for now hardcode max value*/
-		context->bw.dce.dispclk_khz = 681000;
-		context->bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;
+		context->bw_ctx.bw.dce.dispclk_khz = 681000;
+		context->bw_ctx.bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;
 	} else {
-		context->bw.dce.dispclk_khz = 0;
-		context->bw.dce.yclk_khz = 0;
+		context->bw_ctx.bw.dce.dispclk_khz = 0;
+		context->bw_ctx.bw.dce.yclk_khz = 0;
 	}
 
 	return true;

commit 457109829f4ee4107e8c7108237afba21fabbb5e
Merge: b4e4538a0ab5 7a65bdc6903d
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 3 11:36:52 2019 +1000

    Merge branch 'drm-next-5.2' of git://people.freedesktop.org/~agd5f/linux into drm-next
    
    amdgpu:
    - Switch to HMM for userptr (reverted until HMM fixes land)
    - New experimental SMU 11 replacement for powerplay for vega20 (not enabled by default)
    - Initial RAS support for vega20
    - BACO support for vega12
    - BACO fixes for vega20
    - Rework IH handling for page fault and retry interrupts
    - Cleanly split CPU and GPU paths for GPUVM updates
    - Powerplay fixes
    - XGMI fixes
    - Rework how DC interacts with atomic for planes
    - Clean up and simplify DC/Powerplay interfaces
    - Misc cleanups and bug fixes
    
    amdkfd:
    - Switch to HMM for userptr (reverted until HMM fixes land)
    - Add initial RAS support
    - MQD fixes
    
    ttm:
    - Unify DRM_FILE_PAGE_OFFSET handling
    - Account for kernel allocations in kernel zone only
    - Misc cleanups
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Alex Deucher <alexdeucher@gmail.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190402170820.22197-1-alexander.deucher@amd.com

commit e5c419709097e77e7f14a751591ea05f04cf5570
Author: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
Date:   Tue Feb 5 12:50:01 2019 -0500

    drm/amd/display: Add plane capabilities to dc_caps
    
    [Why]
    The current dc_caps doesn't provide the information needed to
    determine the count and type of each plane to be exposed to userspace.
    
    There are three types of DRM planes that are exposed to userspace:
    
    1. Primary planes (can be used for modesetting)
    2. Overlay planes (can be blended below or above a primary plane)
    3. Cursor planes (blended topmost)
    
    We need to know the number and type of each in amdgpu_dm to expose
    to userspace.
    
    Hardware supports blending planes below, above or both ways depending
    on the ASIC. Alpha support is also ASIC dependent. Some hardware has
    dedicated pipes for overlays and other hardware combines the pipes.
    
    All of this should be exposed in a way that DM can query and use.
    
    [How]
    Introduce the dc_plane_cap structure that describes the capabilities
    for the hw planes.
    
    It describes:
    - the type of the plane
    - whether the plane can blend with planes below it
    - whether the plane can blend with planes above it
    - whether the plane supports per pixel alpha blending
    - supported formats on the plane (partial list for now)
    
    Pre DCN ASICs don't have their full capabilities described for now.
    They can be updated as needed in the future.
    
    Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 2eca81b5cf2f..549855eb053f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -387,6 +387,11 @@ static const struct resource_caps res_cap_83 = {
 		.num_ddc = 2,
 };
 
+static const struct dc_plane_cap plane_cap = {
+	.type = DC_PLANE_TYPE_DCE_RGB,
+	.supports_argb8888 = true,
+};
+
 static const struct dce_dmcu_registers dmcu_regs = {
 		DMCU_DCE80_REG_LIST()
 };
@@ -1019,6 +1024,10 @@ static bool dce80_construct(
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
+
+	for (i = 0; i < dc->caps.max_planes; ++i)
+		dc->caps.planes[i] = plane_cap;
+
 	dc->caps.disable_dp_clk_share = true;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
@@ -1224,6 +1233,10 @@ static bool dce81_construct(
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
+
+	for (i = 0; i < dc->caps.max_planes; ++i)
+		dc->caps.planes[i] = plane_cap;
+
 	dc->caps.disable_dp_clk_share = true;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
@@ -1425,6 +1438,10 @@ static bool dce83_construct(
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
+
+	for (i = 0; i < dc->caps.max_planes; ++i)
+		dc->caps.planes[i] = plane_cap;
+
 	dc->caps.disable_dp_clk_share = true;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,

commit 2c3cd66f4c66b169c18a2dbebbc894681d282278
Merge: 7fbd5d784f75 1c163f4c7b3f
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Mar 4 12:02:55 2019 +1000

    Merge v5.0 into drm-next
    
    There is a really hairy resolution involving amdgpu fixes, that I'd rather confirm here.
    
    Also some misc fixes are landed by me, but the pr has them as well.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit 4ece61a22be5ab5d49cc5fc20a19a0afa24a019d
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Feb 5 14:03:52 2019 -0500

    drm/amd/display: set clocks to 0 on suspend on dce80
    
    [Why]
    When a dce80 asic was suspended, the clocks were not set to 0.
    Upon resume, the new clock was compared to the existing clock,
    they were found to be the same, and so the clock was not set.
    This resulted in a blackscreen.
    
    [How]
    In atomic commit, check to see if there are any active pipes.
    If no, set clocks to 0
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index cdd1d6b7b9f2..4e9ea50141bd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -790,9 +790,22 @@ bool dce80_validate_bandwidth(
 	struct dc *dc,
 	struct dc_state *context)
 {
-	/* TODO implement when needed but for now hardcode max value*/
-	context->bw.dce.dispclk_khz = 681000;
-	context->bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;
+	int i;
+	bool at_least_one_pipe = false;
+
+	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+		if (context->res_ctx.pipe_ctx[i].stream)
+			at_least_one_pipe = true;
+	}
+
+	if (at_least_one_pipe) {
+		/* TODO implement when needed but for now hardcode max value*/
+		context->bw.dce.dispclk_khz = 681000;
+		context->bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;
+	} else {
+		context->bw.dce.dispclk_khz = 0;
+		context->bw.dce.yclk_khz = 0;
+	}
 
 	return true;
 }

commit c69dffab819f5abd98f9791fdb8aede1ec2f172f
Author: hersen wu <hersenxs.wu@amd.com>
Date:   Fri Jan 11 10:39:30 2019 -0500

    drm/amd/display: fix eDP fast bootup for pre-raven asic
    
    [Why]
    For fastboot, Bios will light up eDP before SW driver is loaded. SW
    driver will check if eDP is lit by bios through reading the
    BIOS_SCRATCH_3 register. If lit, SW driver will not power down eDP
    power and phy to save time.
    
    Definition of BIOS_SCRATCH_3 are missing for pre-raven asic. This
    causes eDP fast boot to not work property. For some eDP panels, even
    if dp tx sends NoVideoStream_flag =1 and dpcd 0x600=2, eDP rx may not
    handle properly. This may cause a short flash on screen.
    
    [How] Add definition of BIOS_SCRATCH_3 for all asic
    
    Signed-off-by: hersen wu <hersenxs.wu@amd.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Acked-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index e0bba0bc996b..2eca81b5cf2f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -77,6 +77,7 @@
 
 #ifndef mmBIOS_SCRATCH_2
 	#define mmBIOS_SCRATCH_2 0x05CB
+	#define mmBIOS_SCRATCH_3 0x05CC
 	#define mmBIOS_SCRATCH_6 0x05CF
 #endif
 
@@ -358,6 +359,7 @@ static const struct dce110_clk_src_mask cs_mask = {
 };
 
 static const struct bios_registers bios_regs = {
+	.BIOS_SCRATCH_3 = mmBIOS_SCRATCH_3,
 	.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6
 };
 

commit 1877ccf6eea42993c4ca0d5e6876ced8b5b4ee8a
Author: David Francis <David.Francis@amd.com>
Date:   Fri Nov 30 10:32:01 2018 -0500

    drm/amd/display: Change from aux_engine to dce_aux
    
    [Why]
    The aux_engine struct is needlessly complex and
    is defined multiple times.  It contains function pointers
    that each have only one version and are called only from
    inside dce_aux.
    
    [How]
    Replace aux_engine with a new struct called dce_aux.
    Remove all function pointers and call functions directly.
    Remove unused functions
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index cdd1d6b7b9f2..e0bba0bc996b 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -467,7 +467,7 @@ static struct output_pixel_processor *dce80_opp_create(
 	return &opp->base;
 }
 
-struct aux_engine *dce80_aux_engine_create(
+struct dce_aux *dce80_aux_engine_create(
 	struct dc_context *ctx,
 	uint32_t inst)
 {

commit 77f6916aee7a66c8153b54c52c01453b71906d2d
Author: Brajeswar Ghosh <brajeswar.linux@gmail.com>
Date:   Thu Nov 22 19:31:26 2018 +0530

    drm/amd/display: Remove duplicate header
    
    Remove dce/dce_mem_input.h which is included more than once
    
    Signed-off-by: Brajeswar Ghosh <brajeswar.linux@gmail.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 6d40b3d54ac1..cdd1d6b7b9f2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -41,7 +41,6 @@
 #include "dce/dce_mem_input.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
-#include "dce/dce_mem_input.h"
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_opp.h"

commit 84e7fc05a92700297f1de945251fa3b14349532c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Sep 28 07:46:42 2018 -0400

    drm/amd/display: rename dccg to clk_mgr
    
    In preparation for adding the actual dccg block since the
    current implementation of dccg is mor eof a clock manager
    than a hw block
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 1fccb5230296..6d40b3d54ac1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -23,7 +23,6 @@
  *
  */
 
-#include "../dce/dce_dccg.h"
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
@@ -38,6 +37,7 @@
 #include "dce110/dce110_timing_generator.h"
 #include "dce110/dce110_resource.h"
 #include "dce80/dce80_timing_generator.h"
+#include "dce/dce_clk_mgr.h"
 #include "dce/dce_mem_input.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
@@ -155,15 +155,15 @@ static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
 
-static const struct dccg_registers disp_clk_regs = {
+static const struct clk_mgr_registers disp_clk_regs = {
 		CLK_COMMON_REG_LIST_DCE_BASE()
 };
 
-static const struct dccg_shift disp_clk_shift = {
+static const struct clk_mgr_shift disp_clk_shift = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
-static const struct dccg_mask disp_clk_mask = {
+static const struct clk_mgr_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
@@ -779,8 +779,8 @@ static void destruct(struct dce110_resource_pool *pool)
 		}
 	}
 
-	if (pool->base.dccg != NULL)
-		dce_dccg_destroy(&pool->base.dccg);
+	if (pool->base.clk_mgr != NULL)
+		dce_clk_mgr_destroy(&pool->base.clk_mgr);
 
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
@@ -917,11 +917,11 @@ static bool dce80_construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -1122,11 +1122,11 @@ static bool dce81_construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -1323,11 +1323,11 @@ static bool dce83_construct(
 		}
 	}
 
-	pool->base.dccg = dce_dccg_create(ctx,
+	pool->base.clk_mgr = dce_clk_mgr_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.dccg == NULL) {
+	if (pool->base.clk_mgr == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;

commit 4c5e8b54152795581a67bea94dcfe1393a955013
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Sep 24 15:28:00 2018 -0400

    drm/amd/display: split dccg clock manager into asic folders
    
    Currently dccg contains code related to every dcn revision in
    a single file.
    
    This change splits out the dcn parts of code into correct folders
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Charlene Liu <Charlene.Liu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 313141b532e0..1fccb5230296 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -23,7 +23,7 @@
  *
  */
 
-#include "../dce/dce_clocks.h"
+#include "../dce/dce_dccg.h"
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 

commit 4244381cd153ced27c724a893a1480ddb342280a
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue Sep 18 15:37:36 2018 -0400

    drm/amd/display: clean up base dccg struct
    
    Move things not accessed outside dccg block into dce specific
    struct
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 76f58c6a6130..313141b532e0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -855,7 +855,6 @@ static bool dce80_construct(
 	struct dc_context *ctx = dc->ctx;
 	struct dc_firmware_info info;
 	struct dc_bios *bp;
-	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	ctx->dc_bios->regs = &bios_regs;
 
@@ -948,10 +947,6 @@ static bool dce80_construct(
 		goto res_create_fail;
 	}
 
-	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		pool->base.dccg->max_clks_state =
-					static_clk_info.max_clocks_state;
-
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;
@@ -1065,7 +1060,6 @@ static bool dce81_construct(
 	struct dc_context *ctx = dc->ctx;
 	struct dc_firmware_info info;
 	struct dc_bios *bp;
-	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	ctx->dc_bios->regs = &bios_regs;
 
@@ -1158,10 +1152,6 @@ static bool dce81_construct(
 		goto res_create_fail;
 	}
 
-	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		pool->base.dccg->max_clks_state =
-					static_clk_info.max_clocks_state;
-
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;
@@ -1275,7 +1265,6 @@ static bool dce83_construct(
 	struct dc_context *ctx = dc->ctx;
 	struct dc_firmware_info info;
 	struct dc_bios *bp;
-	struct dm_pp_static_clock_info static_clk_info = {0};
 
 	ctx->dc_bios->regs = &bios_regs;
 
@@ -1364,10 +1353,6 @@ static bool dce83_construct(
 		goto res_create_fail;
 	}
 
-	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		pool->base.dccg->max_clks_state =
-					static_clk_info.max_clocks_state;
-
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;

commit 24f7dd7ea98dc54fa45a0dd10c7a472e00ca01d4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Sep 13 17:42:14 2018 -0400

    drm/amd/display: move pplib/smu notification to dccg block
    
    This is done to clear up the clock programming sequence
    since the only time we need to notify pplib is after
    clock update.
    
    This also renames the clk block to dccg, at the moment
    this block contains both clock management and dccg
    functionality.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index d68f951f9869..76f58c6a6130 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -23,6 +23,7 @@
  *
  */
 
+#include "../dce/dce_clocks.h"
 #include "dce/dce_8_0_d.h"
 #include "dce/dce_8_0_sh_mask.h"
 
@@ -44,7 +45,6 @@
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_opp.h"
-#include "dce/dce_clocks.h"
 #include "dce/dce_clock_source.h"
 #include "dce/dce_audio.h"
 #include "dce/dce_hwseq.h"
@@ -793,7 +793,7 @@ bool dce80_validate_bandwidth(
 {
 	/* TODO implement when needed but for now hardcode max value*/
 	context->bw.dce.dispclk_khz = 681000;
-	context->bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER;
+	context->bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER_CZ;
 
 	return true;
 }

commit 88ed9fb77ef420cf2e4ec1624f3e638685e28c8d
Author: Jun Lei <Jun.Lei@amd.com>
Date:   Tue Sep 18 09:38:20 2018 -0400

    drm/amd/display: fix memory leak in resource pools
    
    [why]
    ddc engines were recently changed to be independently tracked
    from pipe count.  the change was reflected in resource constructor
    but not in destructor.  this manifests as a memory leak when
    pipe harvesting is enabled, since not all constructed ddc engines
    are freed
    
    [how]
    make destructor symmetric with constructor for all dcX_resource
    
    Signed-off-by: Jun Lei <Jun.Lei@amd.com>
    Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 79e5c5c0de56..d68f951f9869 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -738,7 +738,9 @@ static void destruct(struct dce110_resource_pool *pool)
 			kfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
 			pool->base.timing_generators[i] = NULL;
 		}
+	}
 
+	for (i = 0; i < pool->base.res_cap->num_ddc; i++) {
 		if (pool->base.engines[i] != NULL)
 			dce110_engine_destroy(&pool->base.engines[i]);
 		if (pool->base.hw_i2cs[i] != NULL) {

commit e15fc81f11854451ec8a8ed9168b8247e4e9a10b
Author: Eric Yang <Eric.Yang2@amd.com>
Date:   Fri Sep 14 15:55:01 2018 -0400

    drm/amd/display: clean up encoding checks
    
    [Why]
    All ASICS we support has YCbCr support, so
    the check is unnecessary, the currently logic
    in validate output also returns true all
    the time, so the unneccessary logic is removed
    
    Signed-off-by: Eric Yang <Eric.Yang2@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 1dc590ccc5f9..79e5c5c0de56 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -650,8 +650,7 @@ static const struct encoder_feature_support link_enc_feature = {
 		.max_hdmi_deep_color = COLOR_DEPTH_121212,
 		.max_hdmi_pixel_clock = 297000,
 		.flags.bits.IS_HBR2_CAPABLE = true,
-		.flags.bits.IS_TPS3_CAPABLE = true,
-		.flags.bits.IS_YCBCR_CAPABLE = true
+		.flags.bits.IS_TPS3_CAPABLE = true
 };
 
 struct link_encoder *dce80_link_encoder_create(

commit 0e8e4fbf8d8905071c045f2922de55adbe1a6abe
Author: Hersen Wu <hersenxs.wu@amd.com>
Date:   Tue Aug 21 09:35:47 2018 -0400

    drm/amd/display: num of sw i2c/aux engines less than num of connectors
    
    [why]
    AMD Stoney reference board, there are only 2 pipes (not include
    underlay), and 3 connectors. resource creation, only
    2 I2C/AUX engines are created. Within dc_link_aux_transfer, when
    pin_data_en =2, refer to enengines[ddc_pin->pin_data->en] = NULL.
    NULL point is referred later causing system crash.
    
    [how]
    each asic design has fixed number of ddc engines at hw side.
    for each ddc engine, create its i2x/aux engine at sw side.
    
    Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 4eae859e6383..1dc590ccc5f9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -367,6 +367,7 @@ static const struct resource_caps res_cap = {
 		.num_audio = 6,
 		.num_stream_encoder = 6,
 		.num_pll = 3,
+		.num_ddc = 6,
 };
 
 static const struct resource_caps res_cap_81 = {
@@ -374,6 +375,7 @@ static const struct resource_caps res_cap_81 = {
 		.num_audio = 7,
 		.num_stream_encoder = 7,
 		.num_pll = 3,
+		.num_ddc = 6,
 };
 
 static const struct resource_caps res_cap_83 = {
@@ -381,6 +383,7 @@ static const struct resource_caps res_cap_83 = {
 		.num_audio = 6,
 		.num_stream_encoder = 6,
 		.num_pll = 2,
+		.num_ddc = 2,
 };
 
 static const struct dce_dmcu_registers dmcu_regs = {
@@ -992,7 +995,9 @@ static bool dce80_construct(
 			dm_error("DC: failed to create output pixel processor!\n");
 			goto res_create_fail;
 		}
+	}
 
+	for (i = 0; i < pool->base.res_cap->num_ddc; i++) {
 		pool->base.engines[i] = dce80_aux_engine_create(ctx, i);
 		if (pool->base.engines[i] == NULL) {
 			BREAK_TO_DEBUGGER();
@@ -1200,6 +1205,16 @@ static bool dce81_construct(
 			dm_error("DC: failed to create output pixel processor!\n");
 			goto res_create_fail;
 		}
+	}
+
+	for (i = 0; i < pool->base.res_cap->num_ddc; i++) {
+		pool->base.engines[i] = dce80_aux_engine_create(ctx, i);
+		if (pool->base.engines[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create aux engine!!\n");
+			goto res_create_fail;
+		}
 		pool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);
 		if (pool->base.hw_i2cs[i] == NULL) {
 			BREAK_TO_DEBUGGER();
@@ -1396,6 +1411,16 @@ static bool dce83_construct(
 			dm_error("DC: failed to create output pixel processor!\n");
 			goto res_create_fail;
 		}
+	}
+
+	for (i = 0; i < pool->base.res_cap->num_ddc; i++) {
+		pool->base.engines[i] = dce80_aux_engine_create(ctx, i);
+		if (pool->base.engines[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create aux engine!!\n");
+			goto res_create_fail;
+		}
 		pool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);
 		if (pool->base.hw_i2cs[i] == NULL) {
 			BREAK_TO_DEBUGGER();

commit c85e6e546edd7e362693218a33a6f63217802fd3
Author: David Francis <David.Francis@amd.com>
Date:   Mon Jul 23 14:12:10 2018 -0400

    drm/amd/display: Create new i2c resource
    
    [Why]
    I2C code did not match dc resource model and was generally
    unpleasant
    
    [How]
    Move code into new svelte dce_i2c files, replacing various i2c
    objects with two structs: dce_i2c_sw and dce_i2c_hw.  Fully split
    sw and hw code paths.  Remove all redundant declarations.  Use
    address lists to distinguish between versions.  Change dce80 code
    to newer register access macros.
    
    Signed-off-by: David Francis <David.Francis@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 604c62969ead..4eae859e6383 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -56,6 +56,7 @@
 #include "dce/dce_dmcu.h"
 #include "dce/dce_aux.h"
 #include "dce/dce_abm.h"
+#include "dce/dce_i2c.h"
 /* TODO remove this include */
 
 #ifndef mmMC_HUB_RDREQ_DMIF_LIMIT
@@ -480,7 +481,54 @@ struct aux_engine *dce80_aux_engine_create(
 
 	return &aux_engine->base;
 }
+#define i2c_inst_regs(id) { I2C_HW_ENGINE_COMMON_REG_LIST(id) }
+
+static const struct dce_i2c_registers i2c_hw_regs[] = {
+		i2c_inst_regs(1),
+		i2c_inst_regs(2),
+		i2c_inst_regs(3),
+		i2c_inst_regs(4),
+		i2c_inst_regs(5),
+		i2c_inst_regs(6),
+};
+
+static const struct dce_i2c_shift i2c_shifts = {
+		I2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+};
+
+static const struct dce_i2c_mask i2c_masks = {
+		I2C_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+};
+
+struct dce_i2c_hw *dce80_i2c_hw_create(
+	struct dc_context *ctx,
+	uint32_t inst)
+{
+	struct dce_i2c_hw *dce_i2c_hw =
+		kzalloc(sizeof(struct dce_i2c_hw), GFP_KERNEL);
+
+	if (!dce_i2c_hw)
+		return NULL;
+
+	dce_i2c_hw_construct(dce_i2c_hw, ctx, inst,
+				    &i2c_hw_regs[inst], &i2c_shifts, &i2c_masks);
 
+	return dce_i2c_hw;
+}
+
+struct dce_i2c_sw *dce80_i2c_sw_create(
+	struct dc_context *ctx)
+{
+	struct dce_i2c_sw *dce_i2c_sw =
+		kzalloc(sizeof(struct dce_i2c_sw), GFP_KERNEL);
+
+	if (!dce_i2c_sw)
+		return NULL;
+
+	dce_i2c_sw_construct(dce_i2c_sw, ctx);
+
+	return dce_i2c_sw;
+}
 static struct stream_encoder *dce80_stream_encoder_create(
 	enum engine_id eng_id,
 	struct dc_context *ctx)
@@ -691,6 +739,14 @@ static void destruct(struct dce110_resource_pool *pool)
 
 		if (pool->base.engines[i] != NULL)
 			dce110_engine_destroy(&pool->base.engines[i]);
+		if (pool->base.hw_i2cs[i] != NULL) {
+			kfree(pool->base.hw_i2cs[i]);
+			pool->base.hw_i2cs[i] = NULL;
+		}
+		if (pool->base.sw_i2cs[i] != NULL) {
+			kfree(pool->base.sw_i2cs[i]);
+			pool->base.sw_i2cs[i] = NULL;
+		}
 	}
 
 	for (i = 0; i < pool->base.stream_enc_count; i++) {
@@ -887,6 +943,7 @@ static bool dce80_construct(
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
 	}
+
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
 		pool->base.dccg->max_clks_state =
 					static_clk_info.max_clocks_state;
@@ -943,6 +1000,20 @@ static bool dce80_construct(
 				"DC:failed to create aux engine!!\n");
 			goto res_create_fail;
 		}
+		pool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);
+		if (pool->base.hw_i2cs[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create i2c engine!!\n");
+			goto res_create_fail;
+		}
+		pool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);
+		if (pool->base.sw_i2cs[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create sw i2c!!\n");
+			goto res_create_fail;
+		}
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
@@ -1129,6 +1200,20 @@ static bool dce81_construct(
 			dm_error("DC: failed to create output pixel processor!\n");
 			goto res_create_fail;
 		}
+		pool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);
+		if (pool->base.hw_i2cs[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create i2c engine!!\n");
+			goto res_create_fail;
+		}
+		pool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);
+		if (pool->base.sw_i2cs[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create sw i2c!!\n");
+			goto res_create_fail;
+		}
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
@@ -1311,6 +1396,20 @@ static bool dce83_construct(
 			dm_error("DC: failed to create output pixel processor!\n");
 			goto res_create_fail;
 		}
+		pool->base.hw_i2cs[i] = dce80_i2c_hw_create(ctx, i);
+		if (pool->base.hw_i2cs[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create i2c engine!!\n");
+			goto res_create_fail;
+		}
+		pool->base.sw_i2cs[i] = dce80_i2c_sw_create(ctx);
+		if (pool->base.sw_i2cs[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create sw i2c!!\n");
+			goto res_create_fail;
+		}
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;

commit 3e27e10e2ecee0d3a0083f8ae76354ac9c6ad15c
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Thu Jul 12 16:44:05 2018 -0400

    drm/amd/display: Don't share clk source between DP and HDMI
    
    [why]
    Prevent clock source sharing between HDMI and DP connectors.
    DP shouldn't be sharing its ref clock with phy clock,
    which caused an issue of older ASICS booting up with multiple
    diplays plugged in.
    
    [how]
    Add an extra check that would prevent HDMI and DP sharing clk.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index dc9f3e9afc33..604c62969ead 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -946,6 +946,7 @@ static bool dce80_construct(
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->caps.disable_dp_clk_share = true;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -1131,6 +1132,7 @@ static bool dce81_construct(
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->caps.disable_dp_clk_share = true;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -1312,6 +1314,7 @@ static bool dce83_construct(
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;
+	dc->caps.disable_dp_clk_share = true;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))

commit 65c78961b30005447a0d9b285de93354d8308f34
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Thu Jun 28 17:50:05 2018 -0400

    drm/amd/display: flatten aux_engine and engine
    
    [Why]
    engine and aux_engine are unnecessary layers we want to remove this
    layer.
    
    [How]
    flatten engine and aux engine structs into one struct called
    aux_engine and remove all references to the engine struct.
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 6fb33ad2d3c8..dc9f3e9afc33 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -464,7 +464,7 @@ static struct output_pixel_processor *dce80_opp_create(
 	return &opp->base;
 }
 
-struct engine *dce80_aux_engine_create(
+struct aux_engine *dce80_aux_engine_create(
 	struct dc_context *ctx,
 	uint32_t inst)
 {
@@ -478,7 +478,7 @@ struct engine *dce80_aux_engine_create(
 				    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,
 				    &aux_engine_regs[inst]);
 
-	return &aux_engine->base.base;
+	return &aux_engine->base;
 }
 
 static struct stream_encoder *dce80_stream_encoder_create(

commit 5c6ac7112fb2b73a5e4e7ac1648cdaceb558f268
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Jul 10 17:20:17 2018 -0400

    drm/amd/display: Decouple aux from i2c
    
    [Why]
    Aux engine is created from i2caux layer. We want to remove this layer
    and use the engine directly.
    
    [How]
    Decouple aux engine from i2caux. Move aux engine related code to dce folder and use
    dc resource pool to manage the engine. And use the engine functions directly
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Acked-by: Leo Li <sunpeng.li@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 2ac95ec2bf96..6fb33ad2d3c8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -54,6 +54,7 @@
 #include "reg_helper.h"
 
 #include "dce/dce_dmcu.h"
+#include "dce/dce_aux.h"
 #include "dce/dce_abm.h"
 /* TODO remove this include */
 
@@ -298,6 +299,21 @@ static const struct dce_opp_mask opp_mask = {
 	OPP_COMMON_MASK_SH_LIST_DCE_80(_MASK)
 };
 
+#define aux_engine_regs(id)\
+[id] = {\
+	AUX_COMMON_REG_LIST(id), \
+	.AUX_RESET_MASK = 0 \
+}
+
+static const struct dce110_aux_registers aux_engine_regs[] = {
+		aux_engine_regs(0),
+		aux_engine_regs(1),
+		aux_engine_regs(2),
+		aux_engine_regs(3),
+		aux_engine_regs(4),
+		aux_engine_regs(5)
+};
+
 #define audio_regs(id)\
 [id] = {\
 	AUD_COMMON_REG_LIST(id)\
@@ -448,6 +464,23 @@ static struct output_pixel_processor *dce80_opp_create(
 	return &opp->base;
 }
 
+struct engine *dce80_aux_engine_create(
+	struct dc_context *ctx,
+	uint32_t inst)
+{
+	struct aux_engine_dce110 *aux_engine =
+		kzalloc(sizeof(struct aux_engine_dce110), GFP_KERNEL);
+
+	if (!aux_engine)
+		return NULL;
+
+	dce110_aux_engine_construct(aux_engine, ctx, inst,
+				    SW_AUX_TIMEOUT_PERIOD_MULTIPLIER * AUX_TIMEOUT_PERIOD,
+				    &aux_engine_regs[inst]);
+
+	return &aux_engine->base.base;
+}
+
 static struct stream_encoder *dce80_stream_encoder_create(
 	enum engine_id eng_id,
 	struct dc_context *ctx)
@@ -655,6 +688,9 @@ static void destruct(struct dce110_resource_pool *pool)
 			kfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
 			pool->base.timing_generators[i] = NULL;
 		}
+
+		if (pool->base.engines[i] != NULL)
+			dce110_engine_destroy(&pool->base.engines[i]);
 	}
 
 	for (i = 0; i < pool->base.stream_enc_count; i++) {
@@ -899,6 +935,14 @@ static bool dce80_construct(
 			dm_error("DC: failed to create output pixel processor!\n");
 			goto res_create_fail;
 		}
+
+		pool->base.engines[i] = dce80_aux_engine_create(ctx, i);
+		if (pool->base.engines[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error(
+				"DC:failed to create aux engine!!\n");
+			goto res_create_fail;
+		}
 	}
 
 	dc->caps.max_planes =  pool->base.pipe_count;

commit 3cdecd4513d57993aaddc03ccdf4539add772aa4
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu May 24 16:48:38 2018 -0400

    drm/amd/display: rename dce_disp_clk to dccg
    
    No functional change.
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Nikola Cornij <Nikola.Cornij@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 70700530aec2..2ac95ec2bf96 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -153,15 +153,15 @@ static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
 
-static const struct dce_disp_clk_registers disp_clk_regs = {
+static const struct dccg_registers disp_clk_regs = {
 		CLK_COMMON_REG_LIST_DCE_BASE()
 };
 
-static const struct dce_disp_clk_shift disp_clk_shift = {
+static const struct dccg_shift disp_clk_shift = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
 };
 
-static const struct dce_disp_clk_mask disp_clk_mask = {
+static const struct dccg_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 

commit 6ca11246180a6e5e6b5b668545c2575b304c9f7f
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 23 16:44:26 2018 -0400

    drm/amd/display: rename display clock block to dccg
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 48a068964722..70700530aec2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -683,8 +683,8 @@ static void destruct(struct dce110_resource_pool *pool)
 		}
 	}
 
-	if (pool->base.display_clock != NULL)
-		dce_disp_clk_destroy(&pool->base.display_clock);
+	if (pool->base.dccg != NULL)
+		dce_dccg_destroy(&pool->base.dccg);
 
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
@@ -822,11 +822,11 @@ static bool dce80_construct(
 		}
 	}
 
-	pool->base.display_clock = dce_disp_clk_create(ctx,
+	pool->base.dccg = dce_dccg_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.display_clock == NULL) {
+	if (pool->base.dccg == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -852,7 +852,7 @@ static bool dce80_construct(
 		goto res_create_fail;
 	}
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		pool->base.display_clock->max_clks_state =
+		pool->base.dccg->max_clks_state =
 					static_clk_info.max_clocks_state;
 
 	{
@@ -1006,11 +1006,11 @@ static bool dce81_construct(
 		}
 	}
 
-	pool->base.display_clock = dce_disp_clk_create(ctx,
+	pool->base.dccg = dce_dccg_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.display_clock == NULL) {
+	if (pool->base.dccg == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -1037,7 +1037,7 @@ static bool dce81_construct(
 	}
 
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		pool->base.display_clock->max_clks_state =
+		pool->base.dccg->max_clks_state =
 					static_clk_info.max_clocks_state;
 
 	{
@@ -1187,11 +1187,11 @@ static bool dce83_construct(
 		}
 	}
 
-	pool->base.display_clock = dce_disp_clk_create(ctx,
+	pool->base.dccg = dce_dccg_create(ctx,
 			&disp_clk_regs,
 			&disp_clk_shift,
 			&disp_clk_mask);
-	if (pool->base.display_clock == NULL) {
+	if (pool->base.dccg == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
 		goto res_create_fail;
@@ -1218,7 +1218,7 @@ static bool dce83_construct(
 	}
 
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
-		pool->base.display_clock->max_clks_state =
+		pool->base.dccg->max_clks_state =
 					static_clk_info.max_clocks_state;
 
 	{

commit 6133470c8e2ffdc6a5d67a1d79a9a0c1c0a94a10
Author: Julian Parkin <jparkin@amd.com>
Date:   Tue Mar 13 15:53:13 2018 -0400

    drm/amd/display: drop dc_validate_guaranteed
    
    Block FP16 scaling in validate_resources codepath.
    
    Signed-off-by: Julian Parkin <jparkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5d854a37a978..48a068964722 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -691,23 +691,6 @@ static void destruct(struct dce110_resource_pool *pool)
 	}
 }
 
-static enum dc_status build_mapped_resource(
-		const struct dc *dc,
-		struct dc_state *context,
-		struct dc_stream_state *stream)
-{
-	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
-
-	if (!pipe_ctx)
-		return DC_ERROR_UNEXPECTED;
-
-	dce110_resource_build_pipe_hw_param(pipe_ctx);
-
-	resource_build_info_frame(pipe_ctx);
-
-	return DC_OK;
-}
-
 bool dce80_validate_bandwidth(
 	struct dc *dc,
 	struct dc_state *context)
@@ -749,37 +732,6 @@ enum dc_status dce80_validate_global(
 	return DC_OK;
 }
 
-enum dc_status dce80_validate_guaranteed(
-		struct dc *dc,
-		struct dc_stream_state *dc_stream,
-		struct dc_state *context)
-{
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-
-	context->streams[0] = dc_stream;
-	dc_stream_retain(context->streams[0]);
-	context->stream_count++;
-
-	result = resource_map_pool_resources(dc, context, dc_stream);
-
-	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context, dc_stream);
-
-	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, dc_stream);
-
-	if (result == DC_OK) {
-		validate_guaranteed_copy_streams(
-				context, dc->caps.max_streams);
-		result = resource_build_scaling_params_for_context(dc, context);
-	}
-
-	if (result == DC_OK)
-		result = dce80_validate_bandwidth(dc, context);
-
-	return result;
-}
-
 static void dce80_destroy_resource_pool(struct resource_pool **pool)
 {
 	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
@@ -792,7 +744,6 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce80_res_pool_funcs = {
 	.destroy = dce80_destroy_resource_pool,
 	.link_enc_create = dce80_link_encoder_create,
-	.validate_guaranteed = dce80_validate_guaranteed,
 	.validate_bandwidth = dce80_validate_bandwidth,
 	.validate_plane = dce100_validate_plane,
 	.add_stream_to_ctx = dce100_add_stream_to_ctx,

commit d54ee946032be661b7645f30f7fa6ae10caa9bc3
Author: Mikita Lipski <mikita.lipski@amd.com>
Date:   Tue Feb 27 16:22:29 2018 -0500

    drm/amd/display: Enable backlight support for pre-DCE11 ASICs
    
    Initializing ABM and DMCU modules for dce 80/81/83/100 as in DCE110
    Adding constructors and destructors for each module.
    Adding register list for DMCU in dce80 as some registers are missing
    in dce80 from the basic list. DMCU is never used, so it would not have
    any functional impact.
    
    Signed-off-by: Mikita Lipski <mikita.lipski@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index a36c14d3d9a8..5d854a37a978 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -53,6 +53,8 @@
 
 #include "reg_helper.h"
 
+#include "dce/dce_dmcu.h"
+#include "dce/dce_abm.h"
 /* TODO remove this include */
 
 #ifndef mmMC_HUB_RDREQ_DMIF_LIMIT
@@ -364,6 +366,29 @@ static const struct resource_caps res_cap_83 = {
 		.num_pll = 2,
 };
 
+static const struct dce_dmcu_registers dmcu_regs = {
+		DMCU_DCE80_REG_LIST()
+};
+
+static const struct dce_dmcu_shift dmcu_shift = {
+		DMCU_MASK_SH_LIST_DCE80(__SHIFT)
+};
+
+static const struct dce_dmcu_mask dmcu_mask = {
+		DMCU_MASK_SH_LIST_DCE80(_MASK)
+};
+static const struct dce_abm_registers abm_regs = {
+		ABM_DCE110_COMMON_REG_LIST()
+};
+
+static const struct dce_abm_shift abm_shift = {
+		ABM_MASK_SH_LIST_DCE110(__SHIFT)
+};
+
+static const struct dce_abm_mask abm_mask = {
+		ABM_MASK_SH_LIST_DCE110(_MASK)
+};
+
 #define CTX  ctx
 #define REG(reg) mm ## reg
 
@@ -643,6 +668,12 @@ static void destruct(struct dce110_resource_pool *pool)
 		}
 	}
 
+	if (pool->base.abm != NULL)
+			dce_abm_destroy(&pool->base.abm);
+
+	if (pool->base.dmcu != NULL)
+			dce_dmcu_destroy(&pool->base.dmcu);
+
 	if (pool->base.dp_clock_source != NULL)
 		dce80_clock_source_destroy(&pool->base.dp_clock_source);
 
@@ -850,7 +881,25 @@ static bool dce80_construct(
 		goto res_create_fail;
 	}
 
+	pool->base.dmcu = dce_dmcu_create(ctx,
+			&dmcu_regs,
+			&dmcu_shift,
+			&dmcu_mask);
+	if (pool->base.dmcu == NULL) {
+		dm_error("DC: failed to create dmcu!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
 
+	pool->base.abm = dce_abm_create(ctx,
+			&abm_regs,
+			&abm_shift,
+			&abm_mask);
+	if (pool->base.abm == NULL) {
+		dm_error("DC: failed to create abm!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
 		pool->base.display_clock->max_clks_state =
 					static_clk_info.max_clocks_state;
@@ -1016,6 +1065,25 @@ static bool dce81_construct(
 		goto res_create_fail;
 	}
 
+	pool->base.dmcu = dce_dmcu_create(ctx,
+			&dmcu_regs,
+			&dmcu_shift,
+			&dmcu_mask);
+	if (pool->base.dmcu == NULL) {
+		dm_error("DC: failed to create dmcu!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	pool->base.abm = dce_abm_create(ctx,
+			&abm_regs,
+			&abm_shift,
+			&abm_mask);
+	if (pool->base.abm == NULL) {
+		dm_error("DC: failed to create abm!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
 
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
 		pool->base.display_clock->max_clks_state =
@@ -1178,6 +1246,25 @@ static bool dce83_construct(
 		goto res_create_fail;
 	}
 
+	pool->base.dmcu = dce_dmcu_create(ctx,
+			&dmcu_regs,
+			&dmcu_shift,
+			&dmcu_mask);
+	if (pool->base.dmcu == NULL) {
+		dm_error("DC: failed to create dmcu!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	pool->base.abm = dce_abm_create(ctx,
+			&abm_regs,
+			&abm_shift,
+			&abm_mask);
+	if (pool->base.abm == NULL) {
+		dm_error("DC: failed to create abm!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
 
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
 		pool->base.display_clock->max_clks_state =

commit 3be1406a72b08e3122660f7ea2a41a129fe5e266
Author: Yongqiang Sun <yongqiang.sun@amd.com>
Date:   Fri Jan 5 13:53:06 2018 -0500

    drm/amd/display: Add timing generator count to resource pool.
    
    Use tg count in resource pool for further reference.
    
    Signed-off-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 25d7eb1567ae..a36c14d3d9a8 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -790,6 +790,7 @@ static bool dce80_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap.num_timing_generator;
+	pool->base.timing_generator_count = res_cap.num_timing_generator;
 	dc->caps.max_downscale_ratio = 200;
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;
@@ -955,6 +956,7 @@ static bool dce81_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap_81.num_timing_generator;
+	pool->base.timing_generator_count = res_cap_81.num_timing_generator;
 	dc->caps.max_downscale_ratio = 200;
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;
@@ -1120,6 +1122,7 @@ static bool dce83_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap_83.num_timing_generator;
+	pool->base.timing_generator_count = res_cap_83.num_timing_generator;
 	dc->caps.max_downscale_ratio = 200;
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;

commit 7e98ab103521f82957f3c2d82d555a6803360440
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Dec 19 16:17:22 2017 -0500

    drm/amd/display: Don't allow dual-link DVI on all ASICs.
    
    Our APUs (Carrizo, Stoney, Raven) don't support it.
    
    v2: Don't use is_apu as other ASICs might also not support it
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 8f2bd56f3461..25d7eb1567ae 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -793,6 +793,7 @@ static bool dce80_construct(
 	dc->caps.max_downscale_ratio = 200;
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;
+	dc->caps.dual_link_dvi = true;
 
 	/*************************************************
 	 *  Create resources                             *

commit 553aae12e3ad4d4d9cb9accb129a8c818bce506b
Author: Anthony Koo <Anthony.Koo@amd.com>
Date:   Mon Oct 16 10:43:59 2017 -0400

    drm/amd/display: Add APU cap in dc_caps
    
    Some features should only be enabled on APUs or should not
    be enabled on APUs.
    
    Signed-off-by: Anthony Koo <anthony.koo@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 9c18efd3446f..8f2bd56f3461 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -957,6 +957,7 @@ static bool dce81_construct(
 	dc->caps.max_downscale_ratio = 200;
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;
+	dc->caps.is_apu = true;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1121,6 +1122,7 @@ static bool dce83_construct(
 	dc->caps.max_downscale_ratio = 200;
 	dc->caps.i2c_speed_in_khz = 40;
 	dc->caps.max_cursor_size = 128;
+	dc->caps.is_apu = true;
 
 	/*************************************************
 	 *  Create resources                             *

commit 94de2bbdfa613165ff20a3e958775c8d01581946
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:40 2017 +1000

    amdgpu/dc: remove pointless return from build_pipe_hw_param
    
    This never returned anything else.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index c6571a908786..9c18efd3446f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -665,16 +665,12 @@ static enum dc_status build_mapped_resource(
 		struct dc_state *context,
 		struct dc_stream_state *stream)
 {
-	enum dc_status status = DC_OK;
 	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
 
 	if (!pipe_ctx)
 		return DC_ERROR_UNEXPECTED;
 
-	status = dce110_resource_build_pipe_hw_param(pipe_ctx);
-
-	if (status != DC_OK)
-		return status;
+	dce110_resource_build_pipe_hw_param(pipe_ctx);
 
 	resource_build_info_frame(pipe_ctx);
 

commit c13b408b81f8a101501d78ca499afee98e0f0ab9
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 14:34:39 2017 +1000

    amdgpu/dc: another round of dce/dcn construct cleanups.
    
    This removes any remaining pointless return codepaths from the
    DCE code.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5e00ca6a1292..c6571a908786 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -910,8 +910,7 @@ static bool dce80_construct(
 		goto res_create_fail;
 
 	/* Create hardware sequencer */
-	if (!dce80_hw_sequencer_construct(dc))
-		goto res_create_fail;
+	dce80_hw_sequencer_construct(dc);
 
 	return true;
 
@@ -1075,8 +1074,7 @@ static bool dce81_construct(
 		goto res_create_fail;
 
 	/* Create hardware sequencer */
-	if (!dce80_hw_sequencer_construct(dc))
-		goto res_create_fail;
+	dce80_hw_sequencer_construct(dc);
 
 	return true;
 
@@ -1236,8 +1234,7 @@ static bool dce83_construct(
 		goto res_create_fail;
 
 	/* Create hardware sequencer */
-	if (!dce80_hw_sequencer_construct(dc))
-		goto res_create_fail;
+	dce80_hw_sequencer_construct(dc);
 
 	return true;
 

commit 99913a171d00b2d4c94127a9e38e5457bc45635d
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 13:16:00 2017 +1000

    amdgpu/dc: make dce80 timing generator construct return void.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index db8afb6491cd..5e00ca6a1292 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -404,12 +404,8 @@ static struct timing_generator *dce80_timing_generator_create(
 	if (!tg110)
 		return NULL;
 
-	if (dce80_timing_generator_construct(tg110, ctx, instance, offsets))
-		return &tg110->base;
-
-	BREAK_TO_DEBUGGER();
-	kfree(tg110);
-	return NULL;
+	dce80_timing_generator_construct(tg110, ctx, instance, offsets);
+	return &tg110->base;
 }
 
 static struct output_pixel_processor *dce80_opp_create(

commit 5fb005c4583749f54d5bab6622dbed1d2d56c268
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 13:15:59 2017 +1000

    amdgpu/dc: make dce transform constructor void
    
    This never returns anything but true.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 71f265b6b670..db8afb6491cd 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -535,15 +535,10 @@ static struct transform *dce80_transform_create(
 	if (!transform)
 		return NULL;
 
-	if (dce_transform_construct(transform, ctx, inst,
-			&xfm_regs[inst], &xfm_shift, &xfm_mask)) {
-		transform->prescaler_on = false;
-		return &transform->base;
-	}
-
-	BREAK_TO_DEBUGGER();
-	kfree(transform);
-	return NULL;
+	dce_transform_construct(transform, ctx, inst,
+				&xfm_regs[inst], &xfm_shift, &xfm_mask);
+	transform->prescaler_on = false;
+	return &transform->base;
 }
 
 static const struct encoder_feature_support link_enc_feature = {

commit 9cf29399f615fc13732f3c8ba3f5ff47e2ca256d
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 13:15:58 2017 +1000

    amdgpu/dc: make opp construct void.
    
    This doesn't return anything except true.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 3603ae93cd72..71f265b6b670 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -422,13 +422,9 @@ static struct output_pixel_processor *dce80_opp_create(
 	if (!opp)
 		return NULL;
 
-	if (dce110_opp_construct(opp,
-			ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask))
-		return &opp->base;
-
-	BREAK_TO_DEBUGGER();
-	kfree(opp);
-	return NULL;
+	dce110_opp_construct(opp,
+			     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);
+	return &opp->base;
 }
 
 static struct stream_encoder *dce80_stream_encoder_create(

commit c60ae11201caff8b0c5c23e4349bf42388e3828b
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 13:15:57 2017 +1000

    amdgpu/dc: make link encoder construct void.
    
    This only ever returned true.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 0b309acab6b1..3603ae93cd72 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -567,20 +567,13 @@ struct link_encoder *dce80_link_encoder_create(
 	if (!enc110)
 		return NULL;
 
-	if (dce110_link_encoder_construct(
-			enc110,
-			enc_init_data,
-			&link_enc_feature,
-			&link_enc_regs[enc_init_data->transmitter],
-			&link_enc_aux_regs[enc_init_data->channel - 1],
-			&link_enc_hpd_regs[enc_init_data->hpd_source])) {
-
-		return &enc110->base;
-	}
-
-	BREAK_TO_DEBUGGER();
-	kfree(enc110);
-	return NULL;
+	dce110_link_encoder_construct(enc110,
+				      enc_init_data,
+				      &link_enc_feature,
+				      &link_enc_regs[enc_init_data->transmitter],
+				      &link_enc_aux_regs[enc_init_data->channel - 1],
+				      &link_enc_hpd_regs[enc_init_data->hpd_source]);
+	return &enc110->base;
 }
 
 struct clock_source *dce80_clock_source_create(

commit f29f918f2868ece27c8aff0edc84c7d7fbdc5598
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Sep 29 13:15:56 2017 +1000

    amdgpu/dc: make stream encoder constructor return void.
    
    The checks weren't useful here really.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 170509a4a221..0b309acab6b1 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -441,14 +441,10 @@ static struct stream_encoder *dce80_stream_encoder_create(
 	if (!enc110)
 		return NULL;
 
-	if (dce110_stream_encoder_construct(
-			enc110, ctx, ctx->dc_bios, eng_id,
-			&stream_enc_regs[eng_id], &se_shift, &se_mask))
-		return &enc110->base;
-
-	BREAK_TO_DEBUGGER();
-	kfree(enc110);
-	return NULL;
+	dce110_stream_encoder_construct(enc110, ctx, ctx->dc_bios, eng_id,
+					&stream_enc_regs[eng_id],
+					&se_shift, &se_mask);
+	return &enc110->base;
 }
 
 #define SRII(reg_name, block, id)\

commit 2004f45ef83f07f43f5da6ede780b08068c7583d
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Sep 27 10:53:50 2017 -0400

    drm/amd/display: Use kernel alloc/free
    
    Abstractions are frowned upon.
    
    cocci script:
    virtual context
    virtual patch
    virtual org
    virtual report
    
    @@
    expression ptr;
    @@
    
    - dm_alloc(ptr)
    + kzalloc(ptr, GFP_KERNEL)
    
    @@
    expression ptr, size;
    @@
    
    - dm_realloc(ptr, size)
    + krealloc(ptr, size, GFP_KERNEL)
    
    @@
    expression ptr;
    @@
    
    - dm_free(ptr)
    + kfree(ptr)
    
    v2: use GFP_KERNEL, not GFP_ATOMIC. add cocci script
    
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5453f02ea8ca..170509a4a221 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -399,7 +399,7 @@ static struct timing_generator *dce80_timing_generator_create(
 		const struct dce110_timing_generator_offsets *offsets)
 {
 	struct dce110_timing_generator *tg110 =
-		dm_alloc(sizeof(struct dce110_timing_generator));
+		kzalloc(sizeof(struct dce110_timing_generator), GFP_KERNEL);
 
 	if (!tg110)
 		return NULL;
@@ -408,7 +408,7 @@ static struct timing_generator *dce80_timing_generator_create(
 		return &tg110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(tg110);
+	kfree(tg110);
 	return NULL;
 }
 
@@ -417,7 +417,7 @@ static struct output_pixel_processor *dce80_opp_create(
 	uint32_t inst)
 {
 	struct dce110_opp *opp =
-		dm_alloc(sizeof(struct dce110_opp));
+		kzalloc(sizeof(struct dce110_opp), GFP_KERNEL);
 
 	if (!opp)
 		return NULL;
@@ -427,7 +427,7 @@ static struct output_pixel_processor *dce80_opp_create(
 		return &opp->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(opp);
+	kfree(opp);
 	return NULL;
 }
 
@@ -436,7 +436,7 @@ static struct stream_encoder *dce80_stream_encoder_create(
 	struct dc_context *ctx)
 {
 	struct dce110_stream_encoder *enc110 =
-		dm_alloc(sizeof(struct dce110_stream_encoder));
+		kzalloc(sizeof(struct dce110_stream_encoder), GFP_KERNEL);
 
 	if (!enc110)
 		return NULL;
@@ -447,7 +447,7 @@ static struct stream_encoder *dce80_stream_encoder_create(
 		return &enc110->base;
 
 	BREAK_TO_DEBUGGER();
-	dm_free(enc110);
+	kfree(enc110);
 	return NULL;
 }
 
@@ -469,7 +469,7 @@ static const struct dce_hwseq_mask hwseq_mask = {
 static struct dce_hwseq *dce80_hwseq_create(
 	struct dc_context *ctx)
 {
-	struct dce_hwseq *hws = dm_alloc(sizeof(struct dce_hwseq));
+	struct dce_hwseq *hws = kzalloc(sizeof(struct dce_hwseq), GFP_KERNEL);
 
 	if (hws) {
 		hws->ctx = ctx;
@@ -514,7 +514,8 @@ static struct mem_input *dce80_mem_input_create(
 	struct dc_context *ctx,
 	uint32_t inst)
 {
-	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
+	struct dce_mem_input *dce_mi = kzalloc(sizeof(struct dce_mem_input),
+					       GFP_KERNEL);
 
 	if (!dce_mi) {
 		BREAK_TO_DEBUGGER();
@@ -528,7 +529,7 @@ static struct mem_input *dce80_mem_input_create(
 
 static void dce80_transform_destroy(struct transform **xfm)
 {
-	dm_free(TO_DCE_TRANSFORM(*xfm));
+	kfree(TO_DCE_TRANSFORM(*xfm));
 	*xfm = NULL;
 }
 
@@ -537,7 +538,7 @@ static struct transform *dce80_transform_create(
 	uint32_t inst)
 {
 	struct dce_transform *transform =
-		dm_alloc(sizeof(struct dce_transform));
+		kzalloc(sizeof(struct dce_transform), GFP_KERNEL);
 
 	if (!transform)
 		return NULL;
@@ -549,7 +550,7 @@ static struct transform *dce80_transform_create(
 	}
 
 	BREAK_TO_DEBUGGER();
-	dm_free(transform);
+	kfree(transform);
 	return NULL;
 }
 
@@ -565,7 +566,7 @@ struct link_encoder *dce80_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
 	struct dce110_link_encoder *enc110 =
-		dm_alloc(sizeof(struct dce110_link_encoder));
+		kzalloc(sizeof(struct dce110_link_encoder), GFP_KERNEL);
 
 	if (!enc110)
 		return NULL;
@@ -582,7 +583,7 @@ struct link_encoder *dce80_link_encoder_create(
 	}
 
 	BREAK_TO_DEBUGGER();
-	dm_free(enc110);
+	kfree(enc110);
 	return NULL;
 }
 
@@ -594,7 +595,7 @@ struct clock_source *dce80_clock_source_create(
 	bool dp_clk_src)
 {
 	struct dce110_clk_src *clk_src =
-		dm_alloc(sizeof(struct dce110_clk_src));
+		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);
 
 	if (!clk_src)
 		return NULL;
@@ -611,14 +612,14 @@ struct clock_source *dce80_clock_source_create(
 
 void dce80_clock_source_destroy(struct clock_source **clk_src)
 {
-	dm_free(TO_DCE110_CLK_SRC(*clk_src));
+	kfree(TO_DCE110_CLK_SRC(*clk_src));
 	*clk_src = NULL;
 }
 
 static struct input_pixel_processor *dce80_ipp_create(
 	struct dc_context *ctx, uint32_t inst)
 {
-	struct dce_ipp *ipp = dm_alloc(sizeof(struct dce_ipp));
+	struct dce_ipp *ipp = kzalloc(sizeof(struct dce_ipp), GFP_KERNEL);
 
 	if (!ipp) {
 		BREAK_TO_DEBUGGER();
@@ -645,19 +646,19 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
+			kfree(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
 		if (pool->base.timing_generators[i] != NULL)	{
-			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			kfree(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
 			pool->base.timing_generators[i] = NULL;
 		}
 	}
 
 	for (i = 0; i < pool->base.stream_enc_count; i++) {
 		if (pool->base.stream_enc[i] != NULL)
-			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+			kfree(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
 	}
 
 	for (i = 0; i < pool->base.clk_src_count; i++) {
@@ -781,7 +782,7 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
 
 	destruct(dce110_pool);
-	dm_free(dce110_pool);
+	kfree(dce110_pool);
 	*pool = NULL;
 }
 
@@ -948,7 +949,7 @@ struct resource_pool *dce80_create_resource_pool(
 	struct dc *dc)
 {
 	struct dce110_resource_pool *pool =
-		dm_alloc(sizeof(struct dce110_resource_pool));
+		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
 
 	if (!pool)
 		return NULL;
@@ -1113,7 +1114,7 @@ struct resource_pool *dce81_create_resource_pool(
 	struct dc *dc)
 {
 	struct dce110_resource_pool *pool =
-		dm_alloc(sizeof(struct dce110_resource_pool));
+		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
 
 	if (!pool)
 		return NULL;
@@ -1274,7 +1275,7 @@ struct resource_pool *dce83_create_resource_pool(
 	struct dc *dc)
 {
 	struct dce110_resource_pool *pool =
-		dm_alloc(sizeof(struct dce110_resource_pool));
+		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);
 
 	if (!pool)
 		return NULL;

commit 513b5693391af332feda8f273af8446ccd4a220b
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Aug 25 22:34:51 2017 -0400

    drm/amd/display: Restore missing DCE8 xfm regs
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Roman Li <Roman.Li@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 9234086aac27..5453f02ea8ca 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -187,7 +187,7 @@ static const struct dce_ipp_mask ipp_mask = {
 
 #define transform_regs(id)\
 [id] = {\
-		XFM_COMMON_REG_LIST_DCE_BASE(id)\
+		XFM_COMMON_REG_LIST_DCE80(id)\
 }
 
 static const struct dce_transform_registers xfm_regs[] = {
@@ -200,11 +200,11 @@ static const struct dce_transform_registers xfm_regs[] = {
 };
 
 static const struct dce_transform_shift xfm_shift = {
-		XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+		XFM_COMMON_MASK_SH_LIST_DCE80(__SHIFT)
 };
 
 static const struct dce_transform_mask xfm_mask = {
-		XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+		XFM_COMMON_MASK_SH_LIST_DCE80(_MASK)
 };
 
 #define aux_regs(id)\

commit 1d9521a74029c3afcf996e207ecd61a74414dd68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Fri Aug 25 16:33:40 2017 -0400

    drm/amd/display: Set add_stream_ctx for CZ, Hawaii and others
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 316080767a21..9234086aac27 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -791,6 +791,7 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_guaranteed = dce80_validate_guaranteed,
 	.validate_bandwidth = dce80_validate_bandwidth,
 	.validate_plane = dce100_validate_plane,
+	.add_stream_to_ctx = dce100_add_stream_to_ctx,
 	.validate_global = dce80_validate_global
 };
 

commit 608ac7bb3924178d7bfa8b88d79d3d9d72b8f485
Author: Jerry Zuo <Jerry.Zuo@amd.com>
Date:   Fri Aug 25 16:16:10 2017 -0400

    drm/amd/display: Rename dc validate_context and current_context
    
    Rename all the dc validate_context to dc_stateÂ and
    dc current_context to current_state.
    
    Signed-off-by: Jerry Zuo <Jerry.Zuo@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 945ff7ee6cd9..316080767a21 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -685,7 +685,7 @@ static void destruct(struct dce110_resource_pool *pool)
 
 static enum dc_status build_mapped_resource(
 		const struct dc *dc,
-		struct validate_context *context,
+		struct dc_state *context,
 		struct dc_stream_state *stream)
 {
 	enum dc_status status = DC_OK;
@@ -706,7 +706,7 @@ static enum dc_status build_mapped_resource(
 
 bool dce80_validate_bandwidth(
 	struct dc *dc,
-	struct validate_context *context)
+	struct dc_state *context)
 {
 	/* TODO implement when needed but for now hardcode max value*/
 	context->bw.dce.dispclk_khz = 681000;
@@ -716,7 +716,7 @@ bool dce80_validate_bandwidth(
 }
 
 static bool dce80_validate_surface_sets(
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	int i;
 
@@ -737,7 +737,7 @@ static bool dce80_validate_surface_sets(
 
 enum dc_status dce80_validate_global(
 		struct dc *dc,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	if (!dce80_validate_surface_sets(context))
 		return DC_FAIL_SURFACE_VALIDATE;
@@ -748,7 +748,7 @@ enum dc_status dce80_validate_global(
 enum dc_status dce80_validate_guaranteed(
 		struct dc *dc,
 		struct dc_stream_state *dc_stream,
-		struct validate_context *context)
+		struct dc_state *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 

commit 19f89e2392e692208a0a00465d30b2b2bf43e9a9
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Aug 11 10:43:45 2017 -0400

    drm/amd/display: Per plane validation context build.
    
    Introduce add/remove plane to/from context.
    Make DC wrapper to use them in WIndows/Diags.
    Use them in dc_update_surface_to_stream.
    Call add/remove plane from Linux DM.
    
    Remove dc_validation_set from dc_validate_global_state interface
    and by this remove clean Linux DM from using it.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index ac3f42a44030..945ff7ee6cd9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -716,19 +716,18 @@ bool dce80_validate_bandwidth(
 }
 
 static bool dce80_validate_surface_sets(
-		const struct dc_validation_set set[],
-		int set_count)
+		struct validate_context *context)
 {
 	int i;
 
-	for (i = 0; i < set_count; i++) {
-		if (set[i].plane_count == 0)
+	for (i = 0; i < context->stream_count; i++) {
+		if (context->stream_status[i].plane_count == 0)
 			continue;
 
-		if (set[i].plane_count > 1)
+		if (context->stream_status[i].plane_count > 1)
 			return false;
 
-		if (set[i].plane_states[0]->format
+		if (context->stream_status[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -738,12 +737,9 @@ static bool dce80_validate_surface_sets(
 
 enum dc_status dce80_validate_global(
 		struct dc *dc,
-		const struct dc_validation_set set[],
-		int set_count,
-		struct validate_context *old_context,
 		struct validate_context *context)
 {
-	if (!dce80_validate_surface_sets(set, set_count))
+	if (!dce80_validate_surface_sets(context))
 		return DC_FAIL_SURFACE_VALIDATE;
 
 	return DC_OK;

commit 1dc904974eb7deef924650adc5af542878ce2040
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Mon Jul 31 11:29:25 2017 -0400

    drm/amd/display: Per stream validate_context build v2.
    
    Until now new context would start as empty, then populated
    with exsisting pipes + new. Now we start with duplication
    of existing context and then add/delete from the context
    pipes as needed.
    
    This allows to do a per stream resource
    population, start discarding dc_validation_set
    and by this brings DC closer to to DRM.
    
    v2: Add some fixes and rebase.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 838bfdaee009..ac3f42a44030 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -686,35 +686,20 @@ static void destruct(struct dce110_resource_pool *pool)
 static enum dc_status build_mapped_resource(
 		const struct dc *dc,
 		struct validate_context *context,
-		struct validate_context *old_context)
+		struct dc_stream_state *stream)
 {
 	enum dc_status status = DC_OK;
-	uint8_t i, j;
+	struct pipe_ctx *pipe_ctx = resource_get_head_pipe_for_stream(&context->res_ctx, stream);
 
-	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream_state *stream = context->streams[i];
+	if (!pipe_ctx)
+		return DC_ERROR_UNEXPECTED;
 
-		if (old_context && resource_is_stream_unchanged(old_context, stream))
-			continue;
-
-		for (j = 0; j < MAX_PIPES; j++) {
-			struct pipe_ctx *pipe_ctx =
-				&context->res_ctx.pipe_ctx[j];
-
-			if (context->res_ctx.pipe_ctx[j].stream != stream)
-				continue;
-
-			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+	status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-			if (status != DC_OK)
-				return status;
+	if (status != DC_OK)
+		return status;
 
-			resource_build_info_frame(pipe_ctx);
-
-			/* do not need to validate non root pipes */
-			break;
-		}
-	}
+	resource_build_info_frame(pipe_ctx);
 
 	return DC_OK;
 }
@@ -751,47 +736,17 @@ static bool dce80_validate_surface_sets(
 	return true;
 }
 
-enum dc_status dce80_validate_with_context(
+enum dc_status dce80_validate_global(
 		struct dc *dc,
 		const struct dc_validation_set set[],
 		int set_count,
-		struct validate_context *context,
-		struct validate_context *old_context)
+		struct validate_context *old_context,
+		struct validate_context *context)
 {
-	struct dc_context *dc_ctx = dc->ctx;
-	enum dc_status result = DC_ERROR_UNEXPECTED;
-	int i;
-
 	if (!dce80_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	for (i = 0; i < set_count; i++) {
-		context->streams[i] = set[i].stream;
-		dc_stream_retain(context->streams[i]);
-		context->stream_count++;
-	}
-
-	result = resource_map_pool_resources(dc, context, old_context);
-
-	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context, old_context);
-
-	if (!resource_validate_attach_surfaces(set, set_count,
-			old_context, context, dc->res_pool)) {
-		DC_ERROR("Failed to attach surface to stream!\n");
-		return DC_FAIL_ATTACH_SURFACES;
-	}
-
-	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, old_context);
-
-	if (result == DC_OK)
-		result = resource_build_scaling_params_for_context(dc, context);
-
-	if (result == DC_OK)
-		result = dce80_validate_bandwidth(dc, context);
-
-	return result;
+	return DC_OK;
 }
 
 enum dc_status dce80_validate_guaranteed(
@@ -805,13 +760,13 @@ enum dc_status dce80_validate_guaranteed(
 	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context, NULL);
+	result = resource_map_pool_resources(dc, context, dc_stream);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context, NULL);
+		result = resource_map_clock_resources(dc, context, dc_stream);
 
 	if (result == DC_OK)
-		result = build_mapped_resource(dc, context, NULL);
+		result = build_mapped_resource(dc, context, dc_stream);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
@@ -837,10 +792,10 @@ static void dce80_destroy_resource_pool(struct resource_pool **pool)
 static const struct resource_funcs dce80_res_pool_funcs = {
 	.destroy = dce80_destroy_resource_pool,
 	.link_enc_create = dce80_link_encoder_create,
-	.validate_with_context = dce80_validate_with_context,
 	.validate_guaranteed = dce80_validate_guaranteed,
 	.validate_bandwidth = dce80_validate_bandwidth,
-	.validate_plane = dce100_validate_plane
+	.validate_plane = dce100_validate_plane,
+	.validate_global = dce80_validate_global
 };
 
 static bool dce80_construct(

commit fb3466a450cc4684654367ae2f47fc3fc7846574
Author: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date:   Tue Aug 1 15:00:25 2017 -0400

    drm/amd/display: Flattening core_dc to dc
    
    -Flattening core_dc to dc
    
    Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 132117e8bb77..838bfdaee009 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -684,7 +684,7 @@ static void destruct(struct dce110_resource_pool *pool)
 }
 
 static enum dc_status build_mapped_resource(
-		const struct core_dc *dc,
+		const struct dc *dc,
 		struct validate_context *context,
 		struct validate_context *old_context)
 {
@@ -720,7 +720,7 @@ static enum dc_status build_mapped_resource(
 }
 
 bool dce80_validate_bandwidth(
-	const struct core_dc *dc,
+	struct dc *dc,
 	struct validate_context *context)
 {
 	/* TODO implement when needed but for now hardcode max value*/
@@ -752,7 +752,7 @@ static bool dce80_validate_surface_sets(
 }
 
 enum dc_status dce80_validate_with_context(
-		const struct core_dc *dc,
+		struct dc *dc,
 		const struct dc_validation_set set[],
 		int set_count,
 		struct validate_context *context,
@@ -795,7 +795,7 @@ enum dc_status dce80_validate_with_context(
 }
 
 enum dc_status dce80_validate_guaranteed(
-		const struct core_dc *dc,
+		struct dc *dc,
 		struct dc_stream_state *dc_stream,
 		struct validate_context *context)
 {
@@ -815,7 +815,7 @@ enum dc_status dce80_validate_guaranteed(
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(
-				context, dc->public.caps.max_streams);
+				context, dc->caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 
@@ -845,7 +845,7 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 
 static bool dce80_construct(
 	uint8_t num_virtual_links,
-	struct core_dc *dc,
+	struct dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -865,9 +865,9 @@ static bool dce80_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap.num_timing_generator;
-	dc->public.caps.max_downscale_ratio = 200;
-	dc->public.caps.i2c_speed_in_khz = 40;
-	dc->public.caps.max_cursor_size = 128;
+	dc->caps.max_downscale_ratio = 200;
+	dc->caps.i2c_speed_in_khz = 40;
+	dc->caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -974,7 +974,7 @@ static bool dce80_construct(
 		}
 	}
 
-	dc->public.caps.max_planes =  pool->base.pipe_count;
+	dc->caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -993,7 +993,7 @@ static bool dce80_construct(
 
 struct resource_pool *dce80_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct core_dc *dc)
+	struct dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
@@ -1010,7 +1010,7 @@ struct resource_pool *dce80_create_resource_pool(
 
 static bool dce81_construct(
 	uint8_t num_virtual_links,
-	struct core_dc *dc,
+	struct dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -1030,9 +1030,9 @@ static bool dce81_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap_81.num_timing_generator;
-	dc->public.caps.max_downscale_ratio = 200;
-	dc->public.caps.i2c_speed_in_khz = 40;
-	dc->public.caps.max_cursor_size = 128;
+	dc->caps.max_downscale_ratio = 200;
+	dc->caps.i2c_speed_in_khz = 40;
+	dc->caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1139,7 +1139,7 @@ static bool dce81_construct(
 		}
 	}
 
-	dc->public.caps.max_planes =  pool->base.pipe_count;
+	dc->caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -1158,7 +1158,7 @@ static bool dce81_construct(
 
 struct resource_pool *dce81_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct core_dc *dc)
+	struct dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));
@@ -1175,7 +1175,7 @@ struct resource_pool *dce81_create_resource_pool(
 
 static bool dce83_construct(
 	uint8_t num_virtual_links,
-	struct core_dc *dc,
+	struct dc *dc,
 	struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -1195,9 +1195,9 @@ static bool dce83_construct(
 	 *************************************************/
 	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap_83.num_timing_generator;
-	dc->public.caps.max_downscale_ratio = 200;
-	dc->public.caps.i2c_speed_in_khz = 40;
-	dc->public.caps.max_cursor_size = 128;
+	dc->caps.max_downscale_ratio = 200;
+	dc->caps.i2c_speed_in_khz = 40;
+	dc->caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *
@@ -1300,7 +1300,7 @@ static bool dce83_construct(
 		}
 	}
 
-	dc->public.caps.max_planes =  pool->base.pipe_count;
+	dc->caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
@@ -1319,7 +1319,7 @@ static bool dce83_construct(
 
 struct resource_pool *dce83_create_resource_pool(
 	uint8_t num_virtual_links,
-	struct core_dc *dc)
+	struct dc *dc)
 {
 	struct dce110_resource_pool *pool =
 		dm_alloc(sizeof(struct dce110_resource_pool));

commit 7992a6290a79afc1568c873d434f39234f7d3e26
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Thu Aug 10 14:39:51 2017 -0400

    drm/amd/disply/dc: add resource support for DCE8 APUs (v2)
    
    Add the appropriate resources for APUs:
    KV:    4 pipes, 7 dig, 3 PPLLs
    KB/ML: 2 pipes, 6 dig, 2 PPLLs
    
    v2: rebase changes
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 40a9591833aa..132117e8bb77 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -350,6 +350,20 @@ static const struct resource_caps res_cap = {
 		.num_pll = 3,
 };
 
+static const struct resource_caps res_cap_81 = {
+		.num_timing_generator = 4,
+		.num_audio = 7,
+		.num_stream_encoder = 7,
+		.num_pll = 3,
+};
+
+static const struct resource_caps res_cap_83 = {
+		.num_timing_generator = 2,
+		.num_audio = 6,
+		.num_stream_encoder = 6,
+		.num_pll = 2,
+};
+
 #define CTX  ctx
 #define REG(reg) mm ## reg
 
@@ -829,7 +843,7 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_plane = dce100_validate_plane
 };
 
-static bool construct(
+static bool dce80_construct(
 	uint8_t num_virtual_links,
 	struct core_dc *dc,
 	struct dce110_resource_pool *pool)
@@ -987,10 +1001,335 @@ struct resource_pool *dce80_create_resource_pool(
 	if (!pool)
 		return NULL;
 
-	if (construct(num_virtual_links, dc, pool))
+	if (dce80_construct(num_virtual_links, dc, pool))
 		return &pool->base;
 
 	BREAK_TO_DEBUGGER();
 	return NULL;
 }
 
+static bool dce81_construct(
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool)
+{
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+	struct dc_firmware_info info;
+	struct dc_bios *bp;
+	struct dm_pp_static_clock_info static_clk_info = {0};
+
+	ctx->dc_bios->regs = &bios_regs;
+
+	pool->base.res_cap = &res_cap_81;
+	pool->base.funcs = &dce80_res_pool_funcs;
+
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
+	pool->base.pipe_count = res_cap_81.num_timing_generator;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+	bp = ctx->dc_bios;
+
+	if ((bp->funcs->get_firmware_info(bp, &info) == BP_RESULT_OK) &&
+		info.external_clock_source_frequency_for_dp != 0) {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);
+		pool->base.clock_sources[2] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);
+		pool->base.clk_src_count = 3;
+
+	} else {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);
+		pool->base.clk_src_count = 2;
+	}
+
+	if (pool->base.dp_clock_source == NULL) {
+		dm_error("DC: failed to create dp clock source!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto res_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dce_disp_clk_create(ctx,
+			&disp_clk_regs,
+			&disp_clk_shift,
+			&disp_clk_mask);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
+		pool->base.display_clock->max_clks_state =
+					static_clk_info.max_clocks_state;
+
+	{
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_dce80_create(&init_data);
+		if (!pool->base.irqs)
+			goto res_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] = dce80_timing_generator_create(
+				ctx, i, &dce80_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.mis[i] = dce80_mem_input_create(ctx, i);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create memory input!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.ipps[i] = dce80_ipp_create(ctx, i);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create input pixel processor!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.transforms[i] = dce80_transform_create(ctx, i);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create transform!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.opps[i] = dce80_opp_create(ctx, i);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create output pixel processor!\n");
+			goto res_create_fail;
+		}
+	}
+
+	dc->public.caps.max_planes =  pool->base.pipe_count;
+
+	if (!resource_construct(num_virtual_links, dc, &pool->base,
+			&res_create_funcs))
+		goto res_create_fail;
+
+	/* Create hardware sequencer */
+	if (!dce80_hw_sequencer_construct(dc))
+		goto res_create_fail;
+
+	return true;
+
+res_create_fail:
+	destruct(pool);
+	return false;
+}
+
+struct resource_pool *dce81_create_resource_pool(
+	uint8_t num_virtual_links,
+	struct core_dc *dc)
+{
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
+
+	if (!pool)
+		return NULL;
+
+	if (dce81_construct(num_virtual_links, dc, pool))
+		return &pool->base;
+
+	BREAK_TO_DEBUGGER();
+	return NULL;
+}
+
+static bool dce83_construct(
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool)
+{
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+	struct dc_firmware_info info;
+	struct dc_bios *bp;
+	struct dm_pp_static_clock_info static_clk_info = {0};
+
+	ctx->dc_bios->regs = &bios_regs;
+
+	pool->base.res_cap = &res_cap_83;
+	pool->base.funcs = &dce80_res_pool_funcs;
+
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
+	pool->base.pipe_count = res_cap_83.num_timing_generator;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+	bp = ctx->dc_bios;
+
+	if ((bp->funcs->get_firmware_info(bp, &info) == BP_RESULT_OK) &&
+		info.external_clock_source_frequency_for_dp != 0) {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[0], false);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[1], false);
+		pool->base.clk_src_count = 2;
+
+	} else {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[0], true);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[1], false);
+		pool->base.clk_src_count = 1;
+	}
+
+	if (pool->base.dp_clock_source == NULL) {
+		dm_error("DC: failed to create dp clock source!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto res_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dce_disp_clk_create(ctx,
+			&disp_clk_regs,
+			&disp_clk_shift,
+			&disp_clk_mask);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
+		pool->base.display_clock->max_clks_state =
+					static_clk_info.max_clocks_state;
+
+	{
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_dce80_create(&init_data);
+		if (!pool->base.irqs)
+			goto res_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] = dce80_timing_generator_create(
+				ctx, i, &dce80_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.mis[i] = dce80_mem_input_create(ctx, i);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create memory input!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.ipps[i] = dce80_ipp_create(ctx, i);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create input pixel processor!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.transforms[i] = dce80_transform_create(ctx, i);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create transform!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.opps[i] = dce80_opp_create(ctx, i);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create output pixel processor!\n");
+			goto res_create_fail;
+		}
+	}
+
+	dc->public.caps.max_planes =  pool->base.pipe_count;
+
+	if (!resource_construct(num_virtual_links, dc, &pool->base,
+			&res_create_funcs))
+		goto res_create_fail;
+
+	/* Create hardware sequencer */
+	if (!dce80_hw_sequencer_construct(dc))
+		goto res_create_fail;
+
+	return true;
+
+res_create_fail:
+	destruct(pool);
+	return false;
+}
+
+struct resource_pool *dce83_create_resource_pool(
+	uint8_t num_virtual_links,
+	struct core_dc *dc)
+{
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
+
+	if (!pool)
+		return NULL;
+
+	if (dce83_construct(num_virtual_links, dc, pool))
+		return &pool->base;
+
+	BREAK_TO_DEBUGGER();
+	return NULL;
+}

commit ea062558fd796ecff167ca64282bd2c3e3e2663f
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Thu Aug 10 14:39:49 2017 -0400

    drm/amd/display/dc: add DIGG for KV
    
    KV has 7 possible DIG blocks.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Harry Wentland <harry.wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 7473f58584c3..40a9591833aa 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -262,7 +262,8 @@ static const struct dce110_stream_enc_registers stream_enc_regs[] = {
 	stream_enc_regs(2),
 	stream_enc_regs(3),
 	stream_enc_regs(4),
-	stream_enc_regs(5)
+	stream_enc_regs(5),
+	stream_enc_regs(6)
 };
 
 static const struct dce_stream_encoder_shift se_shift = {

commit 3be5262e353b8ab97c528bfc7d0dd3c820e4ba27
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:55:38 2017 -0400

    drm/amd/display: Rename more dc_surface stuff to plane_state
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 734b35eddeed..7473f58584c3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -722,13 +722,13 @@ static bool dce80_validate_surface_sets(
 	int i;
 
 	for (i = 0; i < set_count; i++) {
-		if (set[i].surface_count == 0)
+		if (set[i].plane_count == 0)
 			continue;
 
-		if (set[i].surface_count > 1)
+		if (set[i].plane_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->format
+		if (set[i].plane_states[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;
 	}
@@ -959,7 +959,7 @@ static bool construct(
 		}
 	}
 
-	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+	dc->public.caps.max_planes =  pool->base.pipe_count;
 
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))

commit 0971c40e180696c3512b9a63ca7ca5161cbfce32
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:33:33 2017 -0400

    drm/amd/display: Rename dc_stream to dc_stream_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream/struct dc_stream_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_update/struct dc_stream_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_stream_state_status/struct dc_stream_status/g'
    
    Plus some manual changes
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index bcb66447b558..734b35eddeed 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -677,7 +677,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct dc_stream *stream = context->streams[i];
+		struct dc_stream_state *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -781,7 +781,7 @@ enum dc_status dce80_validate_with_context(
 
 enum dc_status dce80_validate_guaranteed(
 		const struct core_dc *dc,
-		struct dc_stream *dc_stream,
+		struct dc_stream_state *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;

commit c9614aeb12f80fa7a787e608d75b707175997edd
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Thu Jul 27 09:24:04 2017 -0400

    drm/amd/display: Rename dc_surface to dc_plane_state
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_surface/struct dc_plane_state/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_update/struct dc_surface_update/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_status/struct dc_surface_status/g'
    
    find -name Makefile -o -name Kconfig -o -name "*.c" -o -name "*.h" \
    -o -name "*.cpp" -o -name "*.hpp" | \
    xargs sed -i 's/struct dc_plane_state_dcc_cap/struct dc_surface_dcc_cap/g'
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 6eeb5e9f656f..bcb66447b558 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -825,7 +825,7 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_with_context = dce80_validate_with_context,
 	.validate_guaranteed = dce80_validate_guaranteed,
 	.validate_bandwidth = dce80_validate_bandwidth,
-	.validate_surface = dce100_validate_surface
+	.validate_plane = dce100_validate_plane
 };
 
 static bool construct(

commit 792671d7e1e28995c6a63104fac1208e19a0ab08
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Wed Jul 26 15:51:31 2017 -0400

    drm/amd/display: Add per surface validation hook.
    
    For now just validate pixel format in the hook.
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 92f01ed97621..6eeb5e9f656f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -49,6 +49,7 @@
 #include "dce/dce_audio.h"
 #include "dce/dce_hwseq.h"
 #include "dce80/dce80_hw_sequencer.h"
+#include "dce100/dce100_resource.h"
 
 #include "reg_helper.h"
 
@@ -823,7 +824,8 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.link_enc_create = dce80_link_encoder_create,
 	.validate_with_context = dce80_validate_with_context,
 	.validate_guaranteed = dce80_validate_guaranteed,
-	.validate_bandwidth = dce80_validate_bandwidth
+	.validate_bandwidth = dce80_validate_bandwidth,
+	.validate_surface = dce100_validate_surface
 };
 
 static bool construct(

commit 1515a47b44c8667987d070fdc494691f91b44b46
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Wed Jul 26 19:31:53 2017 -0400

    drm/amd/display: Rename firmware_info to dc_firmware_info
    
    This is to avoid conflicts with amdgpu's firmware_info once we
    merge amdgpu_dm_types with amdgpu_dm.
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 2fde43c91ad0..92f01ed97621 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -833,7 +833,7 @@ static bool construct(
 {
 	unsigned int i;
 	struct dc_context *ctx = dc->ctx;
-	struct firmware_info info;
+	struct dc_firmware_info info;
 	struct dc_bios *bp;
 	struct dm_pp_static_clock_info static_clk_info = {0};
 

commit 4fa086b9b6640818c053c79d4d7104790ba76cb7
Author: Leo (Sunpeng) Li <sunpeng.li@amd.com>
Date:   Tue Jul 25 20:51:26 2017 -0400

    drm/amd/display: Roll core_stream into dc_stream
    
    Signed-off-by: Leo (Sunpeng) Li <sunpeng.li@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 0123006e5360..2fde43c91ad0 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -676,7 +676,7 @@ static enum dc_status build_mapped_resource(
 	uint8_t i, j;
 
 	for (i = 0; i < context->stream_count; i++) {
-		struct core_stream *stream = context->streams[i];
+		struct dc_stream *stream = context->streams[i];
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -750,8 +750,8 @@ enum dc_status dce80_validate_with_context(
 		return DC_FAIL_SURFACE_VALIDATE;
 
 	for (i = 0; i < set_count; i++) {
-		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
-		dc_stream_retain(&context->streams[i]->public);
+		context->streams[i] = set[i].stream;
+		dc_stream_retain(context->streams[i]);
 		context->stream_count++;
 	}
 
@@ -780,13 +780,13 @@ enum dc_status dce80_validate_with_context(
 
 enum dc_status dce80_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_stream *dc_stream,
+		struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
-	dc_stream_retain(&context->streams[0]->public);
+	context->streams[0] = dc_stream;
+	dc_stream_retain(context->streams[0]);
 	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context, NULL);

commit 9345d9874c324b2f8cce79d4de11f27ae1ef80e9
Author: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
Date:   Fri Jul 21 16:34:36 2017 -0400

    drm/amd/display: Move stream validations into seperate function.
    
    Stateless streams validations (not require resource population)
    moved into hook to be called directly from DM.
    
    Call dc_validate_stream be before validate_with_context for
    non Linux APIs
    
    Signed-off-by: Andrey Grodzovsky <Andrey.Grodzovsky@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index b2319dbf3be3..0123006e5360 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -667,7 +667,7 @@ static void destruct(struct dce110_resource_pool *pool)
 	}
 }
 
-static enum dc_status validate_mapped_resource(
+static enum dc_status build_mapped_resource(
 		const struct core_dc *dc,
 		struct validate_context *context,
 		struct validate_context *old_context)
@@ -677,7 +677,6 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
@@ -689,26 +688,8 @@ static enum dc_status validate_mapped_resource(
 			if (context->res_ctx.pipe_ctx[j].stream != stream)
 				continue;
 
-			if (!pipe_ctx->tg->funcs->validate_timing(
-				pipe_ctx->tg, &stream->public.timing))
-				return DC_FAIL_CONTROLLER_VALIDATE;
-
 			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-			if (status != DC_OK)
-				return status;
-
-			if (!link->link_enc->funcs->validate_output_with_stream(
-				link->link_enc,
-				pipe_ctx))
-				return DC_FAIL_ENC_VALIDATE;
-
-			/* TODO: validate audio ASIC caps, encoder */
-
-			status = dc_link_validate_mode_timing(stream,
-							      link,
-							      &stream->public.timing);
-
 			if (status != DC_OK)
 				return status;
 
@@ -786,7 +767,7 @@ enum dc_status dce80_validate_with_context(
 	}
 
 	if (result == DC_OK)
-		result = validate_mapped_resource(dc, context, old_context);
+		result = build_mapped_resource(dc, context, old_context);
 
 	if (result == DC_OK)
 		result = resource_build_scaling_params_for_context(dc, context);
@@ -814,7 +795,7 @@ enum dc_status dce80_validate_guaranteed(
 		result = resource_map_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = validate_mapped_resource(dc, context, NULL);
+		result = build_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(

commit d0778ebfd58f5650de17531296ee5ecdde39ba68
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Sat Jul 22 20:05:20 2017 -0400

    drm/amd/display: Roll core_link into dc_link
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5861b3fdf7d2..b2319dbf3be3 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -677,7 +677,7 @@ static enum dc_status validate_mapped_resource(
 
 	for (i = 0; i < context->stream_count; i++) {
 		struct core_stream *stream = context->streams[i];
-		struct core_link *link = stream->sink->link;
+		struct dc_link *link = stream->sink->link;
 
 		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;

commit 430ef426bc43b59a7444c08d664e24a7cf89710e
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed May 17 16:05:40 2017 -0400

    drm/amd/display: make dc_get_validate_context re-entrant
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 095e437ce112..5861b3fdf7d2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -669,7 +669,8 @@ static void destruct(struct dce110_resource_pool *pool)
 
 static enum dc_status validate_mapped_resource(
 		const struct core_dc *dc,
-		struct validate_context *context)
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	enum dc_status status = DC_OK;
 	uint8_t i, j;
@@ -678,7 +679,7 @@ static enum dc_status validate_mapped_resource(
 		struct core_stream *stream = context->streams[i];
 		struct core_link *link = stream->sink->link;
 
-		if (resource_is_stream_unchanged(dc->current_context, stream))
+		if (old_context && resource_is_stream_unchanged(old_context, stream))
 			continue;
 
 		for (j = 0; j < MAX_PIPES; j++) {
@@ -757,7 +758,8 @@ enum dc_status dce80_validate_with_context(
 		const struct core_dc *dc,
 		const struct dc_validation_set set[],
 		int set_count,
-		struct validate_context *context)
+		struct validate_context *context,
+		struct validate_context *old_context)
 {
 	struct dc_context *dc_ctx = dc->ctx;
 	enum dc_status result = DC_ERROR_UNEXPECTED;
@@ -772,19 +774,19 @@ enum dc_status dce80_validate_with_context(
 		context->stream_count++;
 	}
 
-	result = resource_map_pool_resources(dc, context);
+	result = resource_map_pool_resources(dc, context, old_context);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context);
+		result = resource_map_clock_resources(dc, context, old_context);
 
 	if (!resource_validate_attach_surfaces(set, set_count,
-			dc->current_context, context, dc->res_pool)) {
+			old_context, context, dc->res_pool)) {
 		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
 
 	if (result == DC_OK)
-		result = validate_mapped_resource(dc, context);
+		result = validate_mapped_resource(dc, context, old_context);
 
 	if (result == DC_OK)
 		result = resource_build_scaling_params_for_context(dc, context);
@@ -806,13 +808,13 @@ enum dc_status dce80_validate_guaranteed(
 	dc_stream_retain(&context->streams[0]->public);
 	context->stream_count++;
 
-	result = resource_map_pool_resources(dc, context);
+	result = resource_map_pool_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = resource_map_clock_resources(dc, context);
+		result = resource_map_clock_resources(dc, context, NULL);
 
 	if (result == DC_OK)
-		result = validate_mapped_resource(dc, context);
+		result = validate_mapped_resource(dc, context, NULL);
 
 	if (result == DC_OK) {
 		validate_guaranteed_copy_streams(

commit c34892144d38eddb4499ac425c24455b1e34dd61
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon May 15 08:31:51 2017 -0400

    drm/amd/display: dce 8 - 12 mem_input refactor to new style
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 5735914a8737..095e437ce112 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -35,12 +35,12 @@
 #include "include/irq_service_interface.h"
 #include "irq/dce80/irq_service_dce80.h"
 #include "dce110/dce110_timing_generator.h"
-#include "dce110/dce110_mem_input.h"
 #include "dce110/dce110_resource.h"
 #include "dce80/dce80_timing_generator.h"
+#include "dce/dce_mem_input.h"
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
-#include "dce80/dce80_mem_input.h"
+#include "dce/dce_mem_input.h"
 #include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_opp.h"
@@ -141,51 +141,6 @@ static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
 		}
 };
 
-static const struct dce110_mem_input_reg_offsets dce80_mi_reg_offsets[] = {
-	{
-		.dcp = (mmGRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE3_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE4_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	},
-	{
-		.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),
-		.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
-				- mmDPG_WATERMARK_MASK_CONTROL),
-		.pipe = (mmPIPE5_DMIF_BUFFER_CONTROL
-				- mmPIPE0_DMIF_BUFFER_CONTROL),
-	}
-};
-
 /* set register offset */
 #define SR(reg_name)\
 	.reg_name = mm ## reg_name
@@ -541,28 +496,18 @@ static const struct dce_mem_input_mask mi_masks = {
 
 static struct mem_input *dce80_mem_input_create(
 	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_mem_input_reg_offsets *offsets)
+	uint32_t inst)
 {
-	struct dce110_mem_input *mem_input80 =
-		dm_alloc(sizeof(struct dce110_mem_input));
+	struct dce_mem_input *dce_mi = dm_alloc(sizeof(struct dce_mem_input));
 
-	if (!mem_input80)
+	if (!dce_mi) {
+		BREAK_TO_DEBUGGER();
 		return NULL;
-
-	if (dce80_mem_input_construct(mem_input80, ctx, inst, offsets)) {
-		struct mem_input *mi = &mem_input80->base;
-
-		mi->regs = &mi_regs[inst];
-		mi->shifts = &mi_shifts;
-		mi->masks = &mi_masks;
-		mi->wa.single_head_rdreq_dmif_limit = 2;
-		return mi;
 	}
 
-	BREAK_TO_DEBUGGER();
-	dm_free(mem_input80);
-	return NULL;
+	dce_mem_input_construct(dce_mi, ctx, inst, &mi_regs[inst], &mi_shifts, &mi_masks);
+	dce_mi->wa.single_head_rdreq_dmif_limit = 2;
+	return &dce_mi->base;
 }
 
 static void dce80_transform_destroy(struct transform **xfm)
@@ -684,7 +629,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
-			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			dm_free(TO_DCE_MEM_INPUT(pool->base.mis[i]));
 			pool->base.mis[i] = NULL;
 		}
 
@@ -1000,8 +945,7 @@ static bool construct(
 			goto res_create_fail;
 		}
 
-		pool->base.mis[i] = dce80_mem_input_create(ctx, i,
-				&dce80_mi_reg_offsets[i]);
+		pool->base.mis[i] = dce80_mem_input_create(ctx, i);
 		if (pool->base.mis[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error("DC: failed to create memory input!\n");

commit 9037d802a97812cb8d614b48f817a5532cf1558c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Tue May 2 17:29:48 2017 -0400

    drm/amd/display: refactor bw related variable structure in val_ctx
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 0aa128e5ed84..5735914a8737 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -781,8 +781,8 @@ bool dce80_validate_bandwidth(
 	struct validate_context *context)
 {
 	/* TODO implement when needed but for now hardcode max value*/
-	context->dispclk_khz = 681000;
-	context->bw_results.required_yclk = 250000 * MEMORY_TYPE_MULTIPLIER;
+	context->bw.dce.dispclk_khz = 681000;
+	context->bw.dce.yclk_khz = 250000 * MEMORY_TYPE_MULTIPLIER;
 
 	return true;
 }

commit a2b8659db9b435853cb0dc78d225a492e7ee69d0
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Sat Apr 22 14:17:51 2017 -0400

    drm/amd/display: decouple resource_pool from resource_context
    
    to avoid null access in case res_ctx is used to access res_pool before it's fully constructed
    
    also make it clear which function has dependency on resource_pool
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index d49092986d54..0aa128e5ed84 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -821,8 +821,6 @@ enum dc_status dce80_validate_with_context(
 	if (!dce80_validate_surface_sets(set, set_count))
 		return DC_FAIL_SURFACE_VALIDATE;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	for (i = 0; i < set_count; i++) {
 		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
 		dc_stream_retain(&context->streams[i]->public);
@@ -834,8 +832,8 @@ enum dc_status dce80_validate_with_context(
 	if (result == DC_OK)
 		result = resource_map_clock_resources(dc, context);
 
-	if (!resource_validate_attach_surfaces(
-			set, set_count, dc->current_context, context)) {
+	if (!resource_validate_attach_surfaces(set, set_count,
+			dc->current_context, context, dc->res_pool)) {
 		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
@@ -859,8 +857,6 @@ enum dc_status dce80_validate_guaranteed(
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
-	context->res_ctx.pool = dc->res_pool;
-
 	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
 	dc_stream_retain(&context->streams[0]->public);
 	context->stream_count++;

commit e6303950ea7221e49cabb240383fa4e2bd035b0c
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Mon Apr 24 16:30:58 2017 -0400

    drm/amd/display: dce80, 100, 110 and 112 to dce ipp refactor
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index ab8cee3e734e..d49092986d54 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -41,10 +41,9 @@
 #include "dce/dce_link_encoder.h"
 #include "dce/dce_stream_encoder.h"
 #include "dce80/dce80_mem_input.h"
-#include "dce80/dce80_ipp.h"
+#include "dce/dce_ipp.h"
 #include "dce/dce_transform.h"
 #include "dce/dce_opp.h"
-#include "dce110/dce110_ipp.h"
 #include "dce/dce_clocks.h"
 #include "dce/dce_clock_source.h"
 #include "dce/dce_audio.h"
@@ -187,27 +186,6 @@ static const struct dce110_mem_input_reg_offsets dce80_mi_reg_offsets[] = {
 	}
 };
 
-static const struct dce110_ipp_reg_offsets ipp_reg_offsets[] = {
-{
-	.dcp_offset = (mmDCP0_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-},
-{
-	.dcp_offset = (mmDCP1_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-},
-{
-	.dcp_offset = (mmDCP2_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-},
-{
-	.dcp_offset = (mmDCP3_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-},
-{
-	.dcp_offset = (mmDCP4_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-},
-{
-	.dcp_offset = (mmDCP5_CUR_CONTROL - mmDCP0_CUR_CONTROL),
-}
-};
-
 /* set register offset */
 #define SR(reg_name)\
 	.reg_name = mm ## reg_name
@@ -229,6 +207,28 @@ static const struct dce_disp_clk_mask disp_clk_mask = {
 		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
 };
 
+#define ipp_regs(id)\
+[id] = {\
+		IPP_COMMON_REG_LIST_DCE_BASE(id)\
+}
+
+static const struct dce_ipp_registers ipp_regs[] = {
+		ipp_regs(0),
+		ipp_regs(1),
+		ipp_regs(2),
+		ipp_regs(3),
+		ipp_regs(4),
+		ipp_regs(5)
+};
+
+static const struct dce_ipp_shift ipp_shift = {
+		IPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+};
+
+static const struct dce_ipp_mask ipp_mask = {
+		IPP_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+};
+
 #define transform_regs(id)\
 [id] = {\
 		XFM_COMMON_REG_LIST_DCE_BASE(id)\
@@ -592,25 +592,6 @@ static struct transform *dce80_transform_create(
 	return NULL;
 }
 
-static struct input_pixel_processor *dce80_ipp_create(
-	struct dc_context *ctx,
-	uint32_t inst,
-	const struct dce110_ipp_reg_offsets *offset)
-{
-	struct dce110_ipp *ipp =
-		dm_alloc(sizeof(struct dce110_ipp));
-
-	if (!ipp)
-		return NULL;
-
-	if (dce80_ipp_construct(ipp, ctx, inst, offset))
-		return &ipp->base;
-
-	BREAK_TO_DEBUGGER();
-	dm_free(ipp);
-	return NULL;
-}
-
 static const struct encoder_feature_support link_enc_feature = {
 		.max_hdmi_deep_color = COLOR_DEPTH_121212,
 		.max_hdmi_pixel_clock = 297000,
@@ -673,6 +654,21 @@ void dce80_clock_source_destroy(struct clock_source **clk_src)
 	*clk_src = NULL;
 }
 
+static struct input_pixel_processor *dce80_ipp_create(
+	struct dc_context *ctx, uint32_t inst)
+{
+	struct dce_ipp *ipp = dm_alloc(sizeof(struct dce_ipp));
+
+	if (!ipp) {
+		BREAK_TO_DEBUGGER();
+		return NULL;
+	}
+
+	dce_ipp_construct(ipp, ctx, inst,
+			&ipp_regs[inst], &ipp_shift, &ipp_mask);
+	return &ipp->base;
+}
+
 static void destruct(struct dce110_resource_pool *pool)
 {
 	unsigned int i;
@@ -685,7 +681,7 @@ static void destruct(struct dce110_resource_pool *pool)
 			dce80_transform_destroy(&pool->base.transforms[i]);
 
 		if (pool->base.ipps[i] != NULL)
-			dce80_ipp_destroy(&pool->base.ipps[i]);
+			dce_ipp_destroy(&pool->base.ipps[i]);
 
 		if (pool->base.mis[i] != NULL) {
 			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
@@ -1016,7 +1012,7 @@ static bool construct(
 			goto res_create_fail;
 		}
 
-		pool->base.ipps[i] = dce80_ipp_create(ctx, i, &ipp_reg_offsets[i]);
+		pool->base.ipps[i] = dce80_ipp_create(ctx, i);
 		if (pool->base.ipps[i] == NULL) {
 			BREAK_TO_DEBUGGER();
 			dm_error("DC: failed to create input pixel processor!\n");

commit 934d292316b5d3933d7fe6811c5d7a696c33910c
Author: Reza Amini <reza.amini@amd.com>
Date:   Fri Mar 17 15:24:09 2017 -0400

    drm/amd/display: remove surface validation against stream rect
    
    Surface information is by default copied from old context in dc_commit_stream.
    Thus unchange streams will not be affected. For new streams, we shouldn't
    validate the new mode against the surface configuration of old_context.
    
    Signed-off-by: Reza Amini <reza.amini@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 752e0e7579b9..ab8cee3e734e 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -804,11 +804,6 @@ static bool dce80_validate_surface_sets(
 		if (set[i].surface_count > 1)
 			return false;
 
-		if (set[i].surfaces[0]->clip_rect.width
-				> set[i].stream->src.width
-				|| set[i].surfaces[0]->clip_rect.height
-				> set[i].stream->src.height)
-			return false;
 		if (set[i].surfaces[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
 			return false;

commit d4e13b0db124345be93bc2ff39ecb48409da2c9b
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Thu Jun 15 16:24:01 2017 -0400

    drm/amd/display: decouple per-crtc-plane model
    
    Current design has per-crtc-plane model.
    As a result, for asic's that support underlay,
    are unable to expose it to user space for modesetting.
    
    To enable this, the drm driver intialisation now runs
    for number of surfaces instead of stream/crtc.
    
    This patch plumbs surface capabilities to drm framework
    so that it can be effectively used by user space.
    
    Tests: (On Chromium OS for Stoney Only)
    * 'modetest -p'  now shows additional plane
      with YUV capabilities in case of CZ and ST.
    * 'plane_test' fails with below error:
      [drm:amdgpu_dm_connector_atomic_set_property [amdgpu]] *ERROR* Unsupported screen depth 0
      as ther is no support for YUYV
    * Checked multimonitor display works fine
    
    Signed-off-by: Shirish S <shirish.s@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index a3e8182885b2..752e0e7579b9 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -1043,6 +1043,8 @@ static bool construct(
 		}
 	}
 
+	dc->public.caps.max_surfaces =  pool->base.pipe_count;
+
 	if (!resource_construct(num_virtual_links, dc, &pool->base,
 			&res_create_funcs))
 		goto res_create_fail;

commit 45209ef7197bd4b5e7e224ff46fa9a3eca25c3bd
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Fri Feb 24 14:19:40 2017 -0500

    drm/amd/display: remove apply_clk_constraints, used validate_bandwidth universally
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index fbbdd0ee2d4c..a3e8182885b2 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -780,7 +780,7 @@ static enum dc_status validate_mapped_resource(
 	return DC_OK;
 }
 
-enum dc_status dce80_validate_bandwidth(
+bool dce80_validate_bandwidth(
 	const struct core_dc *dc,
 	struct validate_context *context)
 {
@@ -788,7 +788,7 @@ enum dc_status dce80_validate_bandwidth(
 	context->dispclk_khz = 681000;
 	context->bw_results.required_yclk = 250000 * MEMORY_TYPE_MULTIPLIER;
 
-	return DC_OK;
+	return true;
 }
 
 static bool dce80_validate_surface_sets(

commit 1781958ff41b28b3cd7b4a2ed691c932031c5515
Author: Leon Elazar <leon.elazar@amd.com>
Date:   Thu Feb 23 16:10:43 2017 -0500

    drm/amd/display: Surface Validation Fixes + Audio Mask
    
    1. dc: Adding missing mask for audio register DCCG_AUDIO_DTO_SOURCE
    2. Changing the surface validation to check the limits of the clip rect instead of the source rect.
    
    Signed-off-by: Leon Elazar <leon.elazar@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 272c7fc31406..fbbdd0ee2d4c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -805,9 +805,9 @@ static bool dce80_validate_surface_sets(
 			return false;
 
 		if (set[i].surfaces[0]->clip_rect.width
-				!= set[i].stream->src.width
+				> set[i].stream->src.width
 				|| set[i].surfaces[0]->clip_rect.height
-				!= set[i].stream->src.height)
+				> set[i].stream->src.height)
 			return false;
 		if (set[i].surfaces[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)

commit a37656b99aca947967f32931bfd5ba04133154d8
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Feb 8 22:13:52 2017 -0500

    drm/amd/display: report cursor size base on the ASIC
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 3de8bfb47dce..272c7fc31406 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -935,6 +935,7 @@ static bool construct(
 	pool->base.pipe_count = res_cap.num_timing_generator;
 	dc->public.caps.max_downscale_ratio = 200;
 	dc->public.caps.i2c_speed_in_khz = 40;
+	dc->public.caps.max_cursor_size = 128;
 
 	/*************************************************
 	 *  Create resources                             *

commit a99240d5f8e14fc081e2cccad6ac46b48cea7def
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Feb 2 17:08:19 2017 -0500

    drm/amd/display: use disp clock value in context rather than bw_results
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index fea60aa5d297..3de8bfb47dce 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -785,7 +785,7 @@ enum dc_status dce80_validate_bandwidth(
 	struct validate_context *context)
 {
 	/* TODO implement when needed but for now hardcode max value*/
-	context->bw_results.dispclk_khz = 681000;
+	context->dispclk_khz = 681000;
 	context->bw_results.required_yclk = 250000 * MEMORY_TYPE_MULTIPLIER;
 
 	return DC_OK;

commit f0e3db90a6fbee4acc921a4912a3e3460efb5cc0
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Mon Jan 23 11:49:24 2017 -0500

    drm/amd/display: Don't reserve pipe for underlay on ASIC without underlay
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Jordan Lazare <Jordan.Lazare@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index bee3a41ffe9f..fea60aa5d297 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -931,7 +931,7 @@ static bool construct(
 	/*************************************************
 	 *  Resource + asic cap harcoding                *
 	 *************************************************/
-	pool->base.underlay_pipe_index = -1;
+	pool->base.underlay_pipe_index = NO_UNDERLAY_PIPE;
 	pool->base.pipe_count = res_cap.num_timing_generator;
 	dc->public.caps.max_downscale_ratio = 200;
 	dc->public.caps.i2c_speed_in_khz = 40;

commit ab2541b67395088b9de8ebf3943ef9ef86bccc41
Author: Aric Cyr <aric.cyr@amd.com>
Date:   Thu Dec 29 15:27:12 2016 -0500

    drm/amd/display: Remove dc_target object
    
    dc_target does not fit well into DRM framework so removed it.
    This will prevent the driver from leveraging the pipe-split
    code for tiled displays, so will have to be handled at a higher
    level.  Most places that used dc_target now directly use dc_stream
    instead.
    
    Signed-off-by: Aric Cyr <aric.cyr@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index e2bfa7efce1c..bee3a41ffe9f 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -731,54 +731,49 @@ static enum dc_status validate_mapped_resource(
 		struct validate_context *context)
 {
 	enum dc_status status = DC_OK;
-	uint8_t i, j, k;
+	uint8_t i, j;
 
-	for (i = 0; i < context->target_count; i++) {
-		struct core_target *target = context->targets[i];
+	for (i = 0; i < context->stream_count; i++) {
+		struct core_stream *stream = context->streams[i];
+		struct core_link *link = stream->sink->link;
 
-		for (j = 0; j < target->public.stream_count; j++) {
-			struct core_stream *stream =
-				DC_STREAM_TO_CORE(target->public.streams[j]);
-			struct core_link *link = stream->sink->link;
-
-			if (resource_is_stream_unchanged(dc->current_context, stream))
-				continue;
+		if (resource_is_stream_unchanged(dc->current_context, stream))
+			continue;
 
-			for (k = 0; k < MAX_PIPES; k++) {
-				struct pipe_ctx *pipe_ctx =
-					&context->res_ctx.pipe_ctx[k];
+		for (j = 0; j < MAX_PIPES; j++) {
+			struct pipe_ctx *pipe_ctx =
+				&context->res_ctx.pipe_ctx[j];
 
-				if (context->res_ctx.pipe_ctx[k].stream != stream)
-					continue;
+			if (context->res_ctx.pipe_ctx[j].stream != stream)
+				continue;
 
-				if (!pipe_ctx->tg->funcs->validate_timing(
-						pipe_ctx->tg, &stream->public.timing))
-					return DC_FAIL_CONTROLLER_VALIDATE;
+			if (!pipe_ctx->tg->funcs->validate_timing(
+				pipe_ctx->tg, &stream->public.timing))
+				return DC_FAIL_CONTROLLER_VALIDATE;
 
-				status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+			status = dce110_resource_build_pipe_hw_param(pipe_ctx);
 
-				if (status != DC_OK)
-					return status;
+			if (status != DC_OK)
+				return status;
 
-				if (!link->link_enc->funcs->validate_output_with_stream(
-						link->link_enc,
-						pipe_ctx))
-					return DC_FAIL_ENC_VALIDATE;
+			if (!link->link_enc->funcs->validate_output_with_stream(
+				link->link_enc,
+				pipe_ctx))
+				return DC_FAIL_ENC_VALIDATE;
 
-				/* TODO: validate audio ASIC caps, encoder */
+			/* TODO: validate audio ASIC caps, encoder */
 
-				status = dc_link_validate_mode_timing(stream,
-						link,
-						&stream->public.timing);
+			status = dc_link_validate_mode_timing(stream,
+							      link,
+							      &stream->public.timing);
 
-				if (status != DC_OK)
-					return status;
+			if (status != DC_OK)
+				return status;
 
-				resource_build_info_frame(pipe_ctx);
+			resource_build_info_frame(pipe_ctx);
 
-				/* do not need to validate non root pipes */
-				break;
-			}
+			/* do not need to validate non root pipes */
+			break;
 		}
 	}
 
@@ -810,9 +805,9 @@ static bool dce80_validate_surface_sets(
 			return false;
 
 		if (set[i].surfaces[0]->clip_rect.width
-				!= set[i].target->streams[0]->src.width
+				!= set[i].stream->src.width
 				|| set[i].surfaces[0]->clip_rect.height
-				!= set[i].target->streams[0]->src.height)
+				!= set[i].stream->src.height)
 			return false;
 		if (set[i].surfaces[0]->format
 				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
@@ -838,9 +833,9 @@ enum dc_status dce80_validate_with_context(
 	context->res_ctx.pool = dc->res_pool;
 
 	for (i = 0; i < set_count; i++) {
-		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
-		dc_target_retain(&context->targets[i]->public);
-		context->target_count++;
+		context->streams[i] = DC_STREAM_TO_CORE(set[i].stream);
+		dc_stream_retain(&context->streams[i]->public);
+		context->stream_count++;
 	}
 
 	result = resource_map_pool_resources(dc, context);
@@ -850,7 +845,7 @@ enum dc_status dce80_validate_with_context(
 
 	if (!resource_validate_attach_surfaces(
 			set, set_count, dc->current_context, context)) {
-		DC_ERROR("Failed to attach surface to target!\n");
+		DC_ERROR("Failed to attach surface to stream!\n");
 		return DC_FAIL_ATTACH_SURFACES;
 	}
 
@@ -868,16 +863,16 @@ enum dc_status dce80_validate_with_context(
 
 enum dc_status dce80_validate_guaranteed(
 		const struct core_dc *dc,
-		const struct dc_target *dc_target,
+		const struct dc_stream *dc_stream,
 		struct validate_context *context)
 {
 	enum dc_status result = DC_ERROR_UNEXPECTED;
 
 	context->res_ctx.pool = dc->res_pool;
 
-	context->targets[0] = DC_TARGET_TO_CORE(dc_target);
-	dc_target_retain(&context->targets[0]->public);
-	context->target_count++;
+	context->streams[0] = DC_STREAM_TO_CORE(dc_stream);
+	dc_stream_retain(&context->streams[0]->public);
+	context->stream_count++;
 
 	result = resource_map_pool_resources(dc, context);
 
@@ -888,8 +883,8 @@ enum dc_status dce80_validate_guaranteed(
 		result = validate_mapped_resource(dc, context);
 
 	if (result == DC_OK) {
-		validate_guaranteed_copy_target(
-				context, dc->public.caps.max_targets);
+		validate_guaranteed_copy_streams(
+				context, dc->public.caps.max_streams);
 		result = resource_build_scaling_params_for_context(dc, context);
 	}
 

commit 7fc698a0c0e5901923a6d6c04a59aceefffe4c9b
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Tue Jan 3 12:40:40 2017 -0500

    drm/amd/display: limit HBR3 support to Polaris and up
    
    - also fix YCbCr420 supported on Polaris and up
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Hersen Wu <hersenxs.wu@amd.com>
    Reviewed-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 56a63d985440..e2bfa7efce1c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -611,6 +611,14 @@ static struct input_pixel_processor *dce80_ipp_create(
 	return NULL;
 }
 
+static const struct encoder_feature_support link_enc_feature = {
+		.max_hdmi_deep_color = COLOR_DEPTH_121212,
+		.max_hdmi_pixel_clock = 297000,
+		.flags.bits.IS_HBR2_CAPABLE = true,
+		.flags.bits.IS_TPS3_CAPABLE = true,
+		.flags.bits.IS_YCBCR_CAPABLE = true
+};
+
 struct link_encoder *dce80_link_encoder_create(
 	const struct encoder_init_data *enc_init_data)
 {
@@ -623,12 +631,11 @@ struct link_encoder *dce80_link_encoder_create(
 	if (dce110_link_encoder_construct(
 			enc110,
 			enc_init_data,
+			&link_enc_feature,
 			&link_enc_regs[enc_init_data->transmitter],
 			&link_enc_aux_regs[enc_init_data->channel - 1],
 			&link_enc_hpd_regs[enc_init_data->hpd_source])) {
 
-		enc110->base.features.ycbcr420_supported = false;
-		enc110->base.features.max_hdmi_pixel_clock = 297000;
 		return &enc110->base;
 	}
 

commit ab3ee7a556343c9549ccbefb9d31039377806f28
Author: Zeyu Fan <Zeyu.Fan@amd.com>
Date:   Wed Dec 14 18:54:41 2016 -0500

    drm/amd/display: OPP refactor and consolidation for DCE.
    
    Signed-off-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 517d42dfff0c..56a63d985440 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -43,7 +43,7 @@
 #include "dce80/dce80_mem_input.h"
 #include "dce80/dce80_ipp.h"
 #include "dce/dce_transform.h"
-#include "dce80/dce80_opp.h"
+#include "dce/dce_opp.h"
 #include "dce110/dce110_ipp.h"
 #include "dce/dce_clocks.h"
 #include "dce/dce_clock_source.h"
@@ -317,6 +317,28 @@ static const struct dce_stream_encoder_mask se_mask = {
 		SE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)
 };
 
+#define opp_regs(id)\
+[id] = {\
+	OPP_DCE_80_REG_LIST(id),\
+}
+
+static const struct dce_opp_registers opp_regs[] = {
+	opp_regs(0),
+	opp_regs(1),
+	opp_regs(2),
+	opp_regs(3),
+	opp_regs(4),
+	opp_regs(5)
+};
+
+static const struct dce_opp_shift opp_shift = {
+	OPP_COMMON_MASK_SH_LIST_DCE_80(__SHIFT)
+};
+
+static const struct dce_opp_mask opp_mask = {
+	OPP_COMMON_MASK_SH_LIST_DCE_80(_MASK)
+};
+
 #define audio_regs(id)\
 [id] = {\
 	AUD_COMMON_REG_LIST(id)\
@@ -419,6 +441,25 @@ static struct timing_generator *dce80_timing_generator_create(
 	return NULL;
 }
 
+static struct output_pixel_processor *dce80_opp_create(
+	struct dc_context *ctx,
+	uint32_t inst)
+{
+	struct dce110_opp *opp =
+		dm_alloc(sizeof(struct dce110_opp));
+
+	if (!opp)
+		return NULL;
+
+	if (dce110_opp_construct(opp,
+			ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask))
+		return &opp->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(opp);
+	return NULL;
+}
+
 static struct stream_encoder *dce80_stream_encoder_create(
 	enum engine_id eng_id,
 	struct dc_context *ctx)
@@ -631,7 +672,7 @@ static void destruct(struct dce110_resource_pool *pool)
 
 	for (i = 0; i < pool->base.pipe_count; i++) {
 		if (pool->base.opps[i] != NULL)
-			dce80_opp_destroy(&pool->base.opps[i]);
+			dce110_opp_destroy(&pool->base.opps[i]);
 
 		if (pool->base.transforms[i] != NULL)
 			dce80_transform_destroy(&pool->base.transforms[i]);

commit 9a70eba7f2c65b408ee56c7219b0cb4ae588b2bc
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Thu Dec 1 18:13:25 2016 -0500

    drm/amd/display: consolidate dce8-11.2 display clock code
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 1d2a31e34617..517d42dfff0c 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -45,6 +45,7 @@
 #include "dce/dce_transform.h"
 #include "dce80/dce80_opp.h"
 #include "dce110/dce110_ipp.h"
+#include "dce/dce_clocks.h"
 #include "dce/dce_clock_source.h"
 #include "dce/dce_audio.h"
 #include "dce/dce_hwseq.h"
@@ -215,6 +216,19 @@ static const struct dce110_ipp_reg_offsets ipp_reg_offsets[] = {
 #define SRI(reg_name, block, id)\
 	.reg_name = mm ## block ## id ## _ ## reg_name
 
+
+static const struct dce_disp_clk_registers disp_clk_regs = {
+		CLK_COMMON_REG_LIST_DCE_BASE()
+};
+
+static const struct dce_disp_clk_shift disp_clk_shift = {
+		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+};
+
+static const struct dce_disp_clk_mask disp_clk_mask = {
+		CLK_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+};
+
 #define transform_regs(id)\
 [id] = {\
 		XFM_COMMON_REG_LIST_DCE_BASE(id)\
@@ -656,11 +670,8 @@ static void destruct(struct dce110_resource_pool *pool)
 		}
 	}
 
-	if (pool->base.display_clock != NULL) {
-		pool->base.display_clock->funcs->destroy(
-				&pool->base.display_clock);
-		pool->base.display_clock = NULL;
-	}
+	if (pool->base.display_clock != NULL)
+		dce_disp_clk_destroy(&pool->base.display_clock);
 
 	if (pool->base.irqs != NULL) {
 		dal_irq_service_destroy(&pool->base.irqs);
@@ -857,47 +868,6 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_bandwidth = dce80_validate_bandwidth
 };
 
-static enum dm_pp_clocks_state dce80_resource_convert_clock_state_pp_to_dc(
-	enum dm_pp_clocks_state pp_clock_state)
-{
-	enum dm_pp_clocks_state dc_clocks_state = DM_PP_CLOCKS_STATE_INVALID;
-
-	switch (pp_clock_state) {
-	case DM_PP_CLOCKS_STATE_INVALID:
-		dc_clocks_state = DM_PP_CLOCKS_STATE_INVALID;
-		break;
-	case DM_PP_CLOCKS_STATE_ULTRA_LOW:
-		dc_clocks_state = DM_PP_CLOCKS_STATE_ULTRA_LOW;
-		break;
-	case DM_PP_CLOCKS_STATE_LOW:
-		dc_clocks_state = DM_PP_CLOCKS_STATE_LOW;
-		break;
-	case DM_PP_CLOCKS_STATE_NOMINAL:
-		dc_clocks_state = DM_PP_CLOCKS_STATE_NOMINAL;
-		break;
-	case DM_PP_CLOCKS_STATE_PERFORMANCE:
-		dc_clocks_state = DM_PP_CLOCKS_STATE_PERFORMANCE;
-		break;
-	case DM_PP_CLOCKS_DPM_STATE_LEVEL_4:
-		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_4;
-		break;
-	case DM_PP_CLOCKS_DPM_STATE_LEVEL_5:
-		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_5;
-		break;
-	case DM_PP_CLOCKS_DPM_STATE_LEVEL_6:
-		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_6;
-		break;
-	case DM_PP_CLOCKS_DPM_STATE_LEVEL_7:
-		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_7;
-		break;
-	default:
-		dc_clocks_state = DM_PP_CLOCKS_STATE_INVALID;
-		break;
-	}
-
-	return dc_clocks_state;
-}
-
 static bool construct(
 	uint8_t num_virtual_links,
 	struct core_dc *dc,
@@ -967,7 +937,10 @@ static bool construct(
 		}
 	}
 
-	pool->base.display_clock = dal_display_clock_dce80_create(ctx);
+	pool->base.display_clock = dce_disp_clk_create(ctx,
+			&disp_clk_regs,
+			&disp_clk_shift,
+			&disp_clk_mask);
 	if (pool->base.display_clock == NULL) {
 		dm_error("DC: failed to create display clock!\n");
 		BREAK_TO_DEBUGGER();
@@ -977,8 +950,7 @@ static bool construct(
 
 	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
 		pool->base.display_clock->max_clks_state =
-				dce80_resource_convert_clock_state_pp_to_dc(
-					static_clk_info.max_clocks_state);
+					static_clk_info.max_clocks_state;
 
 	{
 		struct irq_service_init_data init_data;

commit e9c58bb439bce021da205df09057fe6908ff54c5
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 16:07:50 2016 -0500

    drm/amd/display: remove clocks_state enum
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 51721d10c811..1d2a31e34617 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -857,41 +857,41 @@ static const struct resource_funcs dce80_res_pool_funcs = {
 	.validate_bandwidth = dce80_validate_bandwidth
 };
 
-static enum clocks_state dce80_resource_convert_clock_state_pp_to_dc(
+static enum dm_pp_clocks_state dce80_resource_convert_clock_state_pp_to_dc(
 	enum dm_pp_clocks_state pp_clock_state)
 {
-	enum clocks_state dc_clocks_state = CLOCKS_STATE_INVALID;
+	enum dm_pp_clocks_state dc_clocks_state = DM_PP_CLOCKS_STATE_INVALID;
 
 	switch (pp_clock_state) {
 	case DM_PP_CLOCKS_STATE_INVALID:
-		dc_clocks_state = CLOCKS_STATE_INVALID;
+		dc_clocks_state = DM_PP_CLOCKS_STATE_INVALID;
 		break;
 	case DM_PP_CLOCKS_STATE_ULTRA_LOW:
-		dc_clocks_state = CLOCKS_STATE_ULTRA_LOW;
+		dc_clocks_state = DM_PP_CLOCKS_STATE_ULTRA_LOW;
 		break;
 	case DM_PP_CLOCKS_STATE_LOW:
-		dc_clocks_state = CLOCKS_STATE_LOW;
+		dc_clocks_state = DM_PP_CLOCKS_STATE_LOW;
 		break;
 	case DM_PP_CLOCKS_STATE_NOMINAL:
-		dc_clocks_state = CLOCKS_STATE_NOMINAL;
+		dc_clocks_state = DM_PP_CLOCKS_STATE_NOMINAL;
 		break;
 	case DM_PP_CLOCKS_STATE_PERFORMANCE:
-		dc_clocks_state = CLOCKS_STATE_PERFORMANCE;
+		dc_clocks_state = DM_PP_CLOCKS_STATE_PERFORMANCE;
 		break;
 	case DM_PP_CLOCKS_DPM_STATE_LEVEL_4:
-		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_4;
+		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_4;
 		break;
 	case DM_PP_CLOCKS_DPM_STATE_LEVEL_5:
-		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_5;
+		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_5;
 		break;
 	case DM_PP_CLOCKS_DPM_STATE_LEVEL_6:
-		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_6;
+		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_6;
 		break;
 	case DM_PP_CLOCKS_DPM_STATE_LEVEL_7:
-		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_7;
+		dc_clocks_state = DM_PP_CLOCKS_DPM_STATE_LEVEL_7;
 		break;
 	default:
-		dc_clocks_state = CLOCKS_STATE_INVALID;
+		dc_clocks_state = DM_PP_CLOCKS_STATE_INVALID;
 		break;
 	}
 

commit 3bad7c5ccfacca7a893b2960d872878d75a151d7
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 14:26:37 2016 -0500

    drm/amd/display: remove store clock state
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 1e829f805d42..51721d10c811 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -975,15 +975,11 @@ static bool construct(
 	}
 
 
-	if (dm_pp_get_static_clocks(ctx, &static_clk_info)) {
-		enum clocks_state max_clocks_state =
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info))
+		pool->base.display_clock->max_clks_state =
 				dce80_resource_convert_clock_state_pp_to_dc(
 					static_clk_info.max_clocks_state);
 
-		pool->base.display_clock->funcs->store_max_clocks_state(
-				pool->base.display_clock, max_clocks_state);
-	}
-
 	{
 		struct irq_service_init_data init_data;
 		init_data.ctx = dc->ctx;

commit 5d6d185f32eb0cce16caff13e716d08b594a6046
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 11:03:37 2016 -0500

    drm/amd/display: restyle display clock calls part 2
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index dfff2bfff13d..1e829f805d42 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -657,7 +657,9 @@ static void destruct(struct dce110_resource_pool *pool)
 	}
 
 	if (pool->base.display_clock != NULL) {
-		dal_display_clock_destroy(&pool->base.display_clock);
+		pool->base.display_clock->funcs->destroy(
+				&pool->base.display_clock);
+		pool->base.display_clock = NULL;
 	}
 
 	if (pool->base.irqs != NULL) {

commit 1a687574a71f187dedcab3ac6012b0889c5a4e99
Author: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date:   Wed Nov 30 10:49:51 2016 -0500

    drm/amd/display: restyle display clock calls part 1
    
    Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
    Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 3b626b7883d4..dfff2bfff13d 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -978,7 +978,7 @@ static bool construct(
 				dce80_resource_convert_clock_state_pp_to_dc(
 					static_clk_info.max_clocks_state);
 
-		dal_display_clock_store_max_clocks_state(
+		pool->base.display_clock->funcs->store_max_clocks_state(
 				pool->base.display_clock, max_clocks_state);
 	}
 

commit 197062bf12d7a516ea96e24859fe5981e30ea9ff
Author: Tony Cheng <tony.cheng@amd.com>
Date:   Wed Nov 30 16:15:47 2016 -0500

    drm/amd/display: refactor DCE11 DVVM
    
    - move to new programming style
    - clean up table to make it obvious what we are programming
    
    Signed-off-by: Tony Cheng <tony.cheng@amd.com>
    Reviewed-by: Zeyu Fan <Zeyu.Fan@amd.com>
    Acked-by: Harry Wentland <Harry.Wentland@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
index 06720407b6fc..3b626b7883d4 100644
--- a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -462,7 +462,7 @@ static const struct resource_create_funcs res_create_funcs = {
 };
 
 #define mi_inst_regs(id) { \
-	MI_REG_LIST(id), \
+	MI_DCE8_REG_LIST(id), \
 	.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \
 }
 static const struct dce_mem_input_registers mi_regs[] = {
@@ -475,12 +475,12 @@ static const struct dce_mem_input_registers mi_regs[] = {
 };
 
 static const struct dce_mem_input_shift mi_shifts = {
-		MI_DCE_MASK_SH_LIST(__SHIFT),
+		MI_DCE8_MASK_SH_LIST(__SHIFT),
 		.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT
 };
 
 static const struct dce_mem_input_mask mi_masks = {
-		MI_DCE_MASK_SH_LIST(_MASK),
+		MI_DCE8_MASK_SH_LIST(_MASK),
 		.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK
 };
 

commit 4562236b3bc0a28aeb6ee93b2d8a849a4c4e1c7c
Author: Harry Wentland <harry.wentland@amd.com>
Date:   Tue Sep 12 15:58:20 2017 -0400

    drm/amd/dc: Add dc display driver (v2)
    
    Supported DCE versions: 8.0, 10.0, 11.0, 11.2
    
    v2: rebase against 4.11
    
    Signed-off-by: Harry Wentland <harry.wentland@amd.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
new file mode 100644
index 000000000000..06720407b6fc
--- /dev/null
+++ b/drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c
@@ -0,0 +1,1063 @@
+/*
+ * Copyright 2012-15 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: AMD
+ *
+ */
+
+#include "dce/dce_8_0_d.h"
+#include "dce/dce_8_0_sh_mask.h"
+
+#include "dm_services.h"
+
+#include "link_encoder.h"
+#include "stream_encoder.h"
+
+#include "resource.h"
+#include "include/irq_service_interface.h"
+#include "irq/dce80/irq_service_dce80.h"
+#include "dce110/dce110_timing_generator.h"
+#include "dce110/dce110_mem_input.h"
+#include "dce110/dce110_resource.h"
+#include "dce80/dce80_timing_generator.h"
+#include "dce/dce_link_encoder.h"
+#include "dce/dce_stream_encoder.h"
+#include "dce80/dce80_mem_input.h"
+#include "dce80/dce80_ipp.h"
+#include "dce/dce_transform.h"
+#include "dce80/dce80_opp.h"
+#include "dce110/dce110_ipp.h"
+#include "dce/dce_clock_source.h"
+#include "dce/dce_audio.h"
+#include "dce/dce_hwseq.h"
+#include "dce80/dce80_hw_sequencer.h"
+
+#include "reg_helper.h"
+
+/* TODO remove this include */
+
+#ifndef mmMC_HUB_RDREQ_DMIF_LIMIT
+#include "gmc/gmc_7_1_d.h"
+#include "gmc/gmc_7_1_sh_mask.h"
+#endif
+
+#ifndef mmDP_DPHY_INTERNAL_CTRL
+#define mmDP_DPHY_INTERNAL_CTRL                         0x1CDE
+#define mmDP0_DP_DPHY_INTERNAL_CTRL                     0x1CDE
+#define mmDP1_DP_DPHY_INTERNAL_CTRL                     0x1FDE
+#define mmDP2_DP_DPHY_INTERNAL_CTRL                     0x42DE
+#define mmDP3_DP_DPHY_INTERNAL_CTRL                     0x45DE
+#define mmDP4_DP_DPHY_INTERNAL_CTRL                     0x48DE
+#define mmDP5_DP_DPHY_INTERNAL_CTRL                     0x4BDE
+#define mmDP6_DP_DPHY_INTERNAL_CTRL                     0x4EDE
+#endif
+
+
+#ifndef mmBIOS_SCRATCH_2
+	#define mmBIOS_SCRATCH_2 0x05CB
+	#define mmBIOS_SCRATCH_6 0x05CF
+#endif
+
+#ifndef mmDP_DPHY_FAST_TRAINING
+	#define mmDP_DPHY_FAST_TRAINING                         0x1CCE
+	#define mmDP0_DP_DPHY_FAST_TRAINING                     0x1CCE
+	#define mmDP1_DP_DPHY_FAST_TRAINING                     0x1FCE
+	#define mmDP2_DP_DPHY_FAST_TRAINING                     0x42CE
+	#define mmDP3_DP_DPHY_FAST_TRAINING                     0x45CE
+	#define mmDP4_DP_DPHY_FAST_TRAINING                     0x48CE
+	#define mmDP5_DP_DPHY_FAST_TRAINING                     0x4BCE
+	#define mmDP6_DP_DPHY_FAST_TRAINING                     0x4ECE
+#endif
+
+
+#ifndef mmHPD_DC_HPD_CONTROL
+	#define mmHPD_DC_HPD_CONTROL                            0x189A
+	#define mmHPD0_DC_HPD_CONTROL                           0x189A
+	#define mmHPD1_DC_HPD_CONTROL                           0x18A2
+	#define mmHPD2_DC_HPD_CONTROL                           0x18AA
+	#define mmHPD3_DC_HPD_CONTROL                           0x18B2
+	#define mmHPD4_DC_HPD_CONTROL                           0x18BA
+	#define mmHPD5_DC_HPD_CONTROL                           0x18C2
+#endif
+
+#define DCE11_DIG_FE_CNTL 0x4a00
+#define DCE11_DIG_BE_CNTL 0x4a47
+#define DCE11_DP_SEC 0x4ac3
+
+static const struct dce110_timing_generator_offsets dce80_tg_offsets[] = {
+		{
+			.crtc = (mmCRTC0_CRTC_CONTROL - mmCRTC_CONTROL),
+			.dcp =  (mmGRPH_CONTROL - mmGRPH_CONTROL),
+			.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
+					- mmDPG_WATERMARK_MASK_CONTROL),
+		},
+		{
+			.crtc = (mmCRTC1_CRTC_CONTROL - mmCRTC_CONTROL),
+			.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
+			.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
+					- mmDPG_WATERMARK_MASK_CONTROL),
+		},
+		{
+			.crtc = (mmCRTC2_CRTC_CONTROL - mmCRTC_CONTROL),
+			.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
+			.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
+					- mmDPG_WATERMARK_MASK_CONTROL),
+		},
+		{
+			.crtc = (mmCRTC3_CRTC_CONTROL - mmCRTC_CONTROL),
+			.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),
+			.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
+					- mmDPG_WATERMARK_MASK_CONTROL),
+		},
+		{
+			.crtc = (mmCRTC4_CRTC_CONTROL - mmCRTC_CONTROL),
+			.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),
+			.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
+					- mmDPG_WATERMARK_MASK_CONTROL),
+		},
+		{
+			.crtc = (mmCRTC5_CRTC_CONTROL - mmCRTC_CONTROL),
+			.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),
+			.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
+					- mmDPG_WATERMARK_MASK_CONTROL),
+		}
+};
+
+static const struct dce110_mem_input_reg_offsets dce80_mi_reg_offsets[] = {
+	{
+		.dcp = (mmGRPH_CONTROL - mmGRPH_CONTROL),
+		.dmif = (mmDMIF_PG0_DPG_WATERMARK_MASK_CONTROL
+				- mmDPG_WATERMARK_MASK_CONTROL),
+		.pipe = (mmPIPE0_DMIF_BUFFER_CONTROL
+				- mmPIPE0_DMIF_BUFFER_CONTROL),
+	},
+	{
+		.dcp = (mmDCP1_GRPH_CONTROL - mmGRPH_CONTROL),
+		.dmif = (mmDMIF_PG1_DPG_WATERMARK_MASK_CONTROL
+				- mmDPG_WATERMARK_MASK_CONTROL),
+		.pipe = (mmPIPE1_DMIF_BUFFER_CONTROL
+				- mmPIPE0_DMIF_BUFFER_CONTROL),
+	},
+	{
+		.dcp = (mmDCP2_GRPH_CONTROL - mmGRPH_CONTROL),
+		.dmif = (mmDMIF_PG2_DPG_WATERMARK_MASK_CONTROL
+				- mmDPG_WATERMARK_MASK_CONTROL),
+		.pipe = (mmPIPE2_DMIF_BUFFER_CONTROL
+				- mmPIPE0_DMIF_BUFFER_CONTROL),
+	},
+	{
+		.dcp = (mmDCP3_GRPH_CONTROL - mmGRPH_CONTROL),
+		.dmif = (mmDMIF_PG3_DPG_WATERMARK_MASK_CONTROL
+				- mmDPG_WATERMARK_MASK_CONTROL),
+		.pipe = (mmPIPE3_DMIF_BUFFER_CONTROL
+				- mmPIPE0_DMIF_BUFFER_CONTROL),
+	},
+	{
+		.dcp = (mmDCP4_GRPH_CONTROL - mmGRPH_CONTROL),
+		.dmif = (mmDMIF_PG4_DPG_WATERMARK_MASK_CONTROL
+				- mmDPG_WATERMARK_MASK_CONTROL),
+		.pipe = (mmPIPE4_DMIF_BUFFER_CONTROL
+				- mmPIPE0_DMIF_BUFFER_CONTROL),
+	},
+	{
+		.dcp = (mmDCP5_GRPH_CONTROL - mmGRPH_CONTROL),
+		.dmif = (mmDMIF_PG5_DPG_WATERMARK_MASK_CONTROL
+				- mmDPG_WATERMARK_MASK_CONTROL),
+		.pipe = (mmPIPE5_DMIF_BUFFER_CONTROL
+				- mmPIPE0_DMIF_BUFFER_CONTROL),
+	}
+};
+
+static const struct dce110_ipp_reg_offsets ipp_reg_offsets[] = {
+{
+	.dcp_offset = (mmDCP0_CUR_CONTROL - mmDCP0_CUR_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP1_CUR_CONTROL - mmDCP0_CUR_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP2_CUR_CONTROL - mmDCP0_CUR_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP3_CUR_CONTROL - mmDCP0_CUR_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP4_CUR_CONTROL - mmDCP0_CUR_CONTROL),
+},
+{
+	.dcp_offset = (mmDCP5_CUR_CONTROL - mmDCP0_CUR_CONTROL),
+}
+};
+
+/* set register offset */
+#define SR(reg_name)\
+	.reg_name = mm ## reg_name
+
+/* set register offset with instance */
+#define SRI(reg_name, block, id)\
+	.reg_name = mm ## block ## id ## _ ## reg_name
+
+#define transform_regs(id)\
+[id] = {\
+		XFM_COMMON_REG_LIST_DCE_BASE(id)\
+}
+
+static const struct dce_transform_registers xfm_regs[] = {
+		transform_regs(0),
+		transform_regs(1),
+		transform_regs(2),
+		transform_regs(3),
+		transform_regs(4),
+		transform_regs(5)
+};
+
+static const struct dce_transform_shift xfm_shift = {
+		XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+};
+
+static const struct dce_transform_mask xfm_mask = {
+		XFM_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+};
+
+#define aux_regs(id)\
+[id] = {\
+	AUX_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_aux_registers link_enc_aux_regs[] = {
+	aux_regs(0),
+	aux_regs(1),
+	aux_regs(2),
+	aux_regs(3),
+	aux_regs(4),
+	aux_regs(5)
+};
+
+#define hpd_regs(id)\
+[id] = {\
+	HPD_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_hpd_registers link_enc_hpd_regs[] = {
+		hpd_regs(0),
+		hpd_regs(1),
+		hpd_regs(2),
+		hpd_regs(3),
+		hpd_regs(4),
+		hpd_regs(5)
+};
+
+#define link_regs(id)\
+[id] = {\
+	LE_DCE80_REG_LIST(id)\
+}
+
+static const struct dce110_link_enc_registers link_enc_regs[] = {
+	link_regs(0),
+	link_regs(1),
+	link_regs(2),
+	link_regs(3),
+	link_regs(4),
+	link_regs(5),
+	link_regs(6),
+};
+
+#define stream_enc_regs(id)\
+[id] = {\
+	SE_COMMON_REG_LIST_DCE_BASE(id),\
+	.AFMT_CNTL = 0,\
+}
+
+static const struct dce110_stream_enc_registers stream_enc_regs[] = {
+	stream_enc_regs(0),
+	stream_enc_regs(1),
+	stream_enc_regs(2),
+	stream_enc_regs(3),
+	stream_enc_regs(4),
+	stream_enc_regs(5)
+};
+
+static const struct dce_stream_encoder_shift se_shift = {
+		SE_COMMON_MASK_SH_LIST_DCE80_100(__SHIFT)
+};
+
+static const struct dce_stream_encoder_mask se_mask = {
+		SE_COMMON_MASK_SH_LIST_DCE80_100(_MASK)
+};
+
+#define audio_regs(id)\
+[id] = {\
+	AUD_COMMON_REG_LIST(id)\
+}
+
+static const struct dce_audio_registers audio_regs[] = {
+	audio_regs(0),
+	audio_regs(1),
+	audio_regs(2),
+	audio_regs(3),
+	audio_regs(4),
+	audio_regs(5),
+	audio_regs(6),
+};
+
+static const struct dce_audio_shift audio_shift = {
+		AUD_COMMON_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce_aduio_mask audio_mask = {
+		AUD_COMMON_MASK_SH_LIST(_MASK)
+};
+
+#define clk_src_regs(id)\
+[id] = {\
+	CS_COMMON_REG_LIST_DCE_80(id),\
+}
+
+
+static const struct dce110_clk_src_regs clk_src_regs[] = {
+	clk_src_regs(0),
+	clk_src_regs(1),
+	clk_src_regs(2)
+};
+
+static const struct dce110_clk_src_shift cs_shift = {
+		CS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(__SHIFT)
+};
+
+static const struct dce110_clk_src_mask cs_mask = {
+		CS_COMMON_MASK_SH_LIST_DCE_COMMON_BASE(_MASK)
+};
+
+static const struct bios_registers bios_regs = {
+	.BIOS_SCRATCH_6 = mmBIOS_SCRATCH_6
+};
+
+static const struct resource_caps res_cap = {
+		.num_timing_generator = 6,
+		.num_audio = 6,
+		.num_stream_encoder = 6,
+		.num_pll = 3,
+};
+
+#define CTX  ctx
+#define REG(reg) mm ## reg
+
+#ifndef mmCC_DC_HDMI_STRAPS
+#define mmCC_DC_HDMI_STRAPS 0x1918
+#define CC_DC_HDMI_STRAPS__HDMI_DISABLE_MASK 0x40
+#define CC_DC_HDMI_STRAPS__HDMI_DISABLE__SHIFT 0x6
+#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER_MASK 0x700
+#define CC_DC_HDMI_STRAPS__AUDIO_STREAM_NUMBER__SHIFT 0x8
+#endif
+
+static void read_dce_straps(
+	struct dc_context *ctx,
+	struct resource_straps *straps)
+{
+	REG_GET_2(CC_DC_HDMI_STRAPS,
+			HDMI_DISABLE, &straps->hdmi_disable,
+			AUDIO_STREAM_NUMBER, &straps->audio_stream_number);
+
+	REG_GET(DC_PINSTRAPS, DC_PINSTRAPS_AUDIO, &straps->dc_pinstraps_audio);
+}
+
+static struct audio *create_audio(
+		struct dc_context *ctx, unsigned int inst)
+{
+	return dce_audio_create(ctx, inst,
+			&audio_regs[inst], &audio_shift, &audio_mask);
+}
+
+static struct timing_generator *dce80_timing_generator_create(
+		struct dc_context *ctx,
+		uint32_t instance,
+		const struct dce110_timing_generator_offsets *offsets)
+{
+	struct dce110_timing_generator *tg110 =
+		dm_alloc(sizeof(struct dce110_timing_generator));
+
+	if (!tg110)
+		return NULL;
+
+	if (dce80_timing_generator_construct(tg110, ctx, instance, offsets))
+		return &tg110->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(tg110);
+	return NULL;
+}
+
+static struct stream_encoder *dce80_stream_encoder_create(
+	enum engine_id eng_id,
+	struct dc_context *ctx)
+{
+	struct dce110_stream_encoder *enc110 =
+		dm_alloc(sizeof(struct dce110_stream_encoder));
+
+	if (!enc110)
+		return NULL;
+
+	if (dce110_stream_encoder_construct(
+			enc110, ctx, ctx->dc_bios, eng_id,
+			&stream_enc_regs[eng_id], &se_shift, &se_mask))
+		return &enc110->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(enc110);
+	return NULL;
+}
+
+#define SRII(reg_name, block, id)\
+	.reg_name[id] = mm ## block ## id ## _ ## reg_name
+
+static const struct dce_hwseq_registers hwseq_reg = {
+		HWSEQ_DCE8_REG_LIST()
+};
+
+static const struct dce_hwseq_shift hwseq_shift = {
+		HWSEQ_DCE8_MASK_SH_LIST(__SHIFT)
+};
+
+static const struct dce_hwseq_mask hwseq_mask = {
+		HWSEQ_DCE8_MASK_SH_LIST(_MASK)
+};
+
+static struct dce_hwseq *dce80_hwseq_create(
+	struct dc_context *ctx)
+{
+	struct dce_hwseq *hws = dm_alloc(sizeof(struct dce_hwseq));
+
+	if (hws) {
+		hws->ctx = ctx;
+		hws->regs = &hwseq_reg;
+		hws->shifts = &hwseq_shift;
+		hws->masks = &hwseq_mask;
+	}
+	return hws;
+}
+
+static const struct resource_create_funcs res_create_funcs = {
+	.read_dce_straps = read_dce_straps,
+	.create_audio = create_audio,
+	.create_stream_encoder = dce80_stream_encoder_create,
+	.create_hwseq = dce80_hwseq_create,
+};
+
+#define mi_inst_regs(id) { \
+	MI_REG_LIST(id), \
+	.MC_HUB_RDREQ_DMIF_LIMIT = mmMC_HUB_RDREQ_DMIF_LIMIT \
+}
+static const struct dce_mem_input_registers mi_regs[] = {
+		mi_inst_regs(0),
+		mi_inst_regs(1),
+		mi_inst_regs(2),
+		mi_inst_regs(3),
+		mi_inst_regs(4),
+		mi_inst_regs(5),
+};
+
+static const struct dce_mem_input_shift mi_shifts = {
+		MI_DCE_MASK_SH_LIST(__SHIFT),
+		.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE__SHIFT
+};
+
+static const struct dce_mem_input_mask mi_masks = {
+		MI_DCE_MASK_SH_LIST(_MASK),
+		.ENABLE = MC_HUB_RDREQ_DMIF_LIMIT__ENABLE_MASK
+};
+
+static struct mem_input *dce80_mem_input_create(
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dce110_mem_input_reg_offsets *offsets)
+{
+	struct dce110_mem_input *mem_input80 =
+		dm_alloc(sizeof(struct dce110_mem_input));
+
+	if (!mem_input80)
+		return NULL;
+
+	if (dce80_mem_input_construct(mem_input80, ctx, inst, offsets)) {
+		struct mem_input *mi = &mem_input80->base;
+
+		mi->regs = &mi_regs[inst];
+		mi->shifts = &mi_shifts;
+		mi->masks = &mi_masks;
+		mi->wa.single_head_rdreq_dmif_limit = 2;
+		return mi;
+	}
+
+	BREAK_TO_DEBUGGER();
+	dm_free(mem_input80);
+	return NULL;
+}
+
+static void dce80_transform_destroy(struct transform **xfm)
+{
+	dm_free(TO_DCE_TRANSFORM(*xfm));
+	*xfm = NULL;
+}
+
+static struct transform *dce80_transform_create(
+	struct dc_context *ctx,
+	uint32_t inst)
+{
+	struct dce_transform *transform =
+		dm_alloc(sizeof(struct dce_transform));
+
+	if (!transform)
+		return NULL;
+
+	if (dce_transform_construct(transform, ctx, inst,
+			&xfm_regs[inst], &xfm_shift, &xfm_mask)) {
+		transform->prescaler_on = false;
+		return &transform->base;
+	}
+
+	BREAK_TO_DEBUGGER();
+	dm_free(transform);
+	return NULL;
+}
+
+static struct input_pixel_processor *dce80_ipp_create(
+	struct dc_context *ctx,
+	uint32_t inst,
+	const struct dce110_ipp_reg_offsets *offset)
+{
+	struct dce110_ipp *ipp =
+		dm_alloc(sizeof(struct dce110_ipp));
+
+	if (!ipp)
+		return NULL;
+
+	if (dce80_ipp_construct(ipp, ctx, inst, offset))
+		return &ipp->base;
+
+	BREAK_TO_DEBUGGER();
+	dm_free(ipp);
+	return NULL;
+}
+
+struct link_encoder *dce80_link_encoder_create(
+	const struct encoder_init_data *enc_init_data)
+{
+	struct dce110_link_encoder *enc110 =
+		dm_alloc(sizeof(struct dce110_link_encoder));
+
+	if (!enc110)
+		return NULL;
+
+	if (dce110_link_encoder_construct(
+			enc110,
+			enc_init_data,
+			&link_enc_regs[enc_init_data->transmitter],
+			&link_enc_aux_regs[enc_init_data->channel - 1],
+			&link_enc_hpd_regs[enc_init_data->hpd_source])) {
+
+		enc110->base.features.ycbcr420_supported = false;
+		enc110->base.features.max_hdmi_pixel_clock = 297000;
+		return &enc110->base;
+	}
+
+	BREAK_TO_DEBUGGER();
+	dm_free(enc110);
+	return NULL;
+}
+
+struct clock_source *dce80_clock_source_create(
+	struct dc_context *ctx,
+	struct dc_bios *bios,
+	enum clock_source_id id,
+	const struct dce110_clk_src_regs *regs,
+	bool dp_clk_src)
+{
+	struct dce110_clk_src *clk_src =
+		dm_alloc(sizeof(struct dce110_clk_src));
+
+	if (!clk_src)
+		return NULL;
+
+	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
+			regs, &cs_shift, &cs_mask)) {
+		clk_src->base.dp_clk_src = dp_clk_src;
+		return &clk_src->base;
+	}
+
+	BREAK_TO_DEBUGGER();
+	return NULL;
+}
+
+void dce80_clock_source_destroy(struct clock_source **clk_src)
+{
+	dm_free(TO_DCE110_CLK_SRC(*clk_src));
+	*clk_src = NULL;
+}
+
+static void destruct(struct dce110_resource_pool *pool)
+{
+	unsigned int i;
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		if (pool->base.opps[i] != NULL)
+			dce80_opp_destroy(&pool->base.opps[i]);
+
+		if (pool->base.transforms[i] != NULL)
+			dce80_transform_destroy(&pool->base.transforms[i]);
+
+		if (pool->base.ipps[i] != NULL)
+			dce80_ipp_destroy(&pool->base.ipps[i]);
+
+		if (pool->base.mis[i] != NULL) {
+			dm_free(TO_DCE110_MEM_INPUT(pool->base.mis[i]));
+			pool->base.mis[i] = NULL;
+		}
+
+		if (pool->base.timing_generators[i] != NULL)	{
+			dm_free(DCE110TG_FROM_TG(pool->base.timing_generators[i]));
+			pool->base.timing_generators[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < pool->base.stream_enc_count; i++) {
+		if (pool->base.stream_enc[i] != NULL)
+			dm_free(DCE110STRENC_FROM_STRENC(pool->base.stream_enc[i]));
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] != NULL) {
+			dce80_clock_source_destroy(&pool->base.clock_sources[i]);
+		}
+	}
+
+	if (pool->base.dp_clock_source != NULL)
+		dce80_clock_source_destroy(&pool->base.dp_clock_source);
+
+	for (i = 0; i < pool->base.audio_count; i++)	{
+		if (pool->base.audios[i] != NULL) {
+			dce_aud_destroy(&pool->base.audios[i]);
+		}
+	}
+
+	if (pool->base.display_clock != NULL) {
+		dal_display_clock_destroy(&pool->base.display_clock);
+	}
+
+	if (pool->base.irqs != NULL) {
+		dal_irq_service_destroy(&pool->base.irqs);
+	}
+}
+
+static enum dc_status validate_mapped_resource(
+		const struct core_dc *dc,
+		struct validate_context *context)
+{
+	enum dc_status status = DC_OK;
+	uint8_t i, j, k;
+
+	for (i = 0; i < context->target_count; i++) {
+		struct core_target *target = context->targets[i];
+
+		for (j = 0; j < target->public.stream_count; j++) {
+			struct core_stream *stream =
+				DC_STREAM_TO_CORE(target->public.streams[j]);
+			struct core_link *link = stream->sink->link;
+
+			if (resource_is_stream_unchanged(dc->current_context, stream))
+				continue;
+
+			for (k = 0; k < MAX_PIPES; k++) {
+				struct pipe_ctx *pipe_ctx =
+					&context->res_ctx.pipe_ctx[k];
+
+				if (context->res_ctx.pipe_ctx[k].stream != stream)
+					continue;
+
+				if (!pipe_ctx->tg->funcs->validate_timing(
+						pipe_ctx->tg, &stream->public.timing))
+					return DC_FAIL_CONTROLLER_VALIDATE;
+
+				status = dce110_resource_build_pipe_hw_param(pipe_ctx);
+
+				if (status != DC_OK)
+					return status;
+
+				if (!link->link_enc->funcs->validate_output_with_stream(
+						link->link_enc,
+						pipe_ctx))
+					return DC_FAIL_ENC_VALIDATE;
+
+				/* TODO: validate audio ASIC caps, encoder */
+
+				status = dc_link_validate_mode_timing(stream,
+						link,
+						&stream->public.timing);
+
+				if (status != DC_OK)
+					return status;
+
+				resource_build_info_frame(pipe_ctx);
+
+				/* do not need to validate non root pipes */
+				break;
+			}
+		}
+	}
+
+	return DC_OK;
+}
+
+enum dc_status dce80_validate_bandwidth(
+	const struct core_dc *dc,
+	struct validate_context *context)
+{
+	/* TODO implement when needed but for now hardcode max value*/
+	context->bw_results.dispclk_khz = 681000;
+	context->bw_results.required_yclk = 250000 * MEMORY_TYPE_MULTIPLIER;
+
+	return DC_OK;
+}
+
+static bool dce80_validate_surface_sets(
+		const struct dc_validation_set set[],
+		int set_count)
+{
+	int i;
+
+	for (i = 0; i < set_count; i++) {
+		if (set[i].surface_count == 0)
+			continue;
+
+		if (set[i].surface_count > 1)
+			return false;
+
+		if (set[i].surfaces[0]->clip_rect.width
+				!= set[i].target->streams[0]->src.width
+				|| set[i].surfaces[0]->clip_rect.height
+				!= set[i].target->streams[0]->src.height)
+			return false;
+		if (set[i].surfaces[0]->format
+				>= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)
+			return false;
+	}
+
+	return true;
+}
+
+enum dc_status dce80_validate_with_context(
+		const struct core_dc *dc,
+		const struct dc_validation_set set[],
+		int set_count,
+		struct validate_context *context)
+{
+	struct dc_context *dc_ctx = dc->ctx;
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+	int i;
+
+	if (!dce80_validate_surface_sets(set, set_count))
+		return DC_FAIL_SURFACE_VALIDATE;
+
+	context->res_ctx.pool = dc->res_pool;
+
+	for (i = 0; i < set_count; i++) {
+		context->targets[i] = DC_TARGET_TO_CORE(set[i].target);
+		dc_target_retain(&context->targets[i]->public);
+		context->target_count++;
+	}
+
+	result = resource_map_pool_resources(dc, context);
+
+	if (result == DC_OK)
+		result = resource_map_clock_resources(dc, context);
+
+	if (!resource_validate_attach_surfaces(
+			set, set_count, dc->current_context, context)) {
+		DC_ERROR("Failed to attach surface to target!\n");
+		return DC_FAIL_ATTACH_SURFACES;
+	}
+
+	if (result == DC_OK)
+		result = validate_mapped_resource(dc, context);
+
+	if (result == DC_OK)
+		result = resource_build_scaling_params_for_context(dc, context);
+
+	if (result == DC_OK)
+		result = dce80_validate_bandwidth(dc, context);
+
+	return result;
+}
+
+enum dc_status dce80_validate_guaranteed(
+		const struct core_dc *dc,
+		const struct dc_target *dc_target,
+		struct validate_context *context)
+{
+	enum dc_status result = DC_ERROR_UNEXPECTED;
+
+	context->res_ctx.pool = dc->res_pool;
+
+	context->targets[0] = DC_TARGET_TO_CORE(dc_target);
+	dc_target_retain(&context->targets[0]->public);
+	context->target_count++;
+
+	result = resource_map_pool_resources(dc, context);
+
+	if (result == DC_OK)
+		result = resource_map_clock_resources(dc, context);
+
+	if (result == DC_OK)
+		result = validate_mapped_resource(dc, context);
+
+	if (result == DC_OK) {
+		validate_guaranteed_copy_target(
+				context, dc->public.caps.max_targets);
+		result = resource_build_scaling_params_for_context(dc, context);
+	}
+
+	if (result == DC_OK)
+		result = dce80_validate_bandwidth(dc, context);
+
+	return result;
+}
+
+static void dce80_destroy_resource_pool(struct resource_pool **pool)
+{
+	struct dce110_resource_pool *dce110_pool = TO_DCE110_RES_POOL(*pool);
+
+	destruct(dce110_pool);
+	dm_free(dce110_pool);
+	*pool = NULL;
+}
+
+static const struct resource_funcs dce80_res_pool_funcs = {
+	.destroy = dce80_destroy_resource_pool,
+	.link_enc_create = dce80_link_encoder_create,
+	.validate_with_context = dce80_validate_with_context,
+	.validate_guaranteed = dce80_validate_guaranteed,
+	.validate_bandwidth = dce80_validate_bandwidth
+};
+
+static enum clocks_state dce80_resource_convert_clock_state_pp_to_dc(
+	enum dm_pp_clocks_state pp_clock_state)
+{
+	enum clocks_state dc_clocks_state = CLOCKS_STATE_INVALID;
+
+	switch (pp_clock_state) {
+	case DM_PP_CLOCKS_STATE_INVALID:
+		dc_clocks_state = CLOCKS_STATE_INVALID;
+		break;
+	case DM_PP_CLOCKS_STATE_ULTRA_LOW:
+		dc_clocks_state = CLOCKS_STATE_ULTRA_LOW;
+		break;
+	case DM_PP_CLOCKS_STATE_LOW:
+		dc_clocks_state = CLOCKS_STATE_LOW;
+		break;
+	case DM_PP_CLOCKS_STATE_NOMINAL:
+		dc_clocks_state = CLOCKS_STATE_NOMINAL;
+		break;
+	case DM_PP_CLOCKS_STATE_PERFORMANCE:
+		dc_clocks_state = CLOCKS_STATE_PERFORMANCE;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_4:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_4;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_5:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_5;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_6:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_6;
+		break;
+	case DM_PP_CLOCKS_DPM_STATE_LEVEL_7:
+		dc_clocks_state = CLOCKS_DPM_STATE_LEVEL_7;
+		break;
+	default:
+		dc_clocks_state = CLOCKS_STATE_INVALID;
+		break;
+	}
+
+	return dc_clocks_state;
+}
+
+static bool construct(
+	uint8_t num_virtual_links,
+	struct core_dc *dc,
+	struct dce110_resource_pool *pool)
+{
+	unsigned int i;
+	struct dc_context *ctx = dc->ctx;
+	struct firmware_info info;
+	struct dc_bios *bp;
+	struct dm_pp_static_clock_info static_clk_info = {0};
+
+	ctx->dc_bios->regs = &bios_regs;
+
+	pool->base.res_cap = &res_cap;
+	pool->base.funcs = &dce80_res_pool_funcs;
+
+
+	/*************************************************
+	 *  Resource + asic cap harcoding                *
+	 *************************************************/
+	pool->base.underlay_pipe_index = -1;
+	pool->base.pipe_count = res_cap.num_timing_generator;
+	dc->public.caps.max_downscale_ratio = 200;
+	dc->public.caps.i2c_speed_in_khz = 40;
+
+	/*************************************************
+	 *  Create resources                             *
+	 *************************************************/
+
+	bp = ctx->dc_bios;
+
+	if ((bp->funcs->get_firmware_info(bp, &info) == BP_RESULT_OK) &&
+		info.external_clock_source_frequency_for_dp != 0) {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_EXTERNAL, NULL, true);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], false);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);
+		pool->base.clock_sources[2] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);
+		pool->base.clk_src_count = 3;
+
+	} else {
+		pool->base.dp_clock_source =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL0, &clk_src_regs[0], true);
+
+		pool->base.clock_sources[0] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL1, &clk_src_regs[1], false);
+		pool->base.clock_sources[1] =
+				dce80_clock_source_create(ctx, bp, CLOCK_SOURCE_ID_PLL2, &clk_src_regs[2], false);
+		pool->base.clk_src_count = 2;
+	}
+
+	if (pool->base.dp_clock_source == NULL) {
+		dm_error("DC: failed to create dp clock source!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+	for (i = 0; i < pool->base.clk_src_count; i++) {
+		if (pool->base.clock_sources[i] == NULL) {
+			dm_error("DC: failed to create clock sources!\n");
+			BREAK_TO_DEBUGGER();
+			goto res_create_fail;
+		}
+	}
+
+	pool->base.display_clock = dal_display_clock_dce80_create(ctx);
+	if (pool->base.display_clock == NULL) {
+		dm_error("DC: failed to create display clock!\n");
+		BREAK_TO_DEBUGGER();
+		goto res_create_fail;
+	}
+
+
+	if (dm_pp_get_static_clocks(ctx, &static_clk_info)) {
+		enum clocks_state max_clocks_state =
+				dce80_resource_convert_clock_state_pp_to_dc(
+					static_clk_info.max_clocks_state);
+
+		dal_display_clock_store_max_clocks_state(
+				pool->base.display_clock, max_clocks_state);
+	}
+
+	{
+		struct irq_service_init_data init_data;
+		init_data.ctx = dc->ctx;
+		pool->base.irqs = dal_irq_service_dce80_create(&init_data);
+		if (!pool->base.irqs)
+			goto res_create_fail;
+	}
+
+	for (i = 0; i < pool->base.pipe_count; i++) {
+		pool->base.timing_generators[i] = dce80_timing_generator_create(
+				ctx, i, &dce80_tg_offsets[i]);
+		if (pool->base.timing_generators[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create tg!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.mis[i] = dce80_mem_input_create(ctx, i,
+				&dce80_mi_reg_offsets[i]);
+		if (pool->base.mis[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create memory input!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.ipps[i] = dce80_ipp_create(ctx, i, &ipp_reg_offsets[i]);
+		if (pool->base.ipps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create input pixel processor!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.transforms[i] = dce80_transform_create(ctx, i);
+		if (pool->base.transforms[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create transform!\n");
+			goto res_create_fail;
+		}
+
+		pool->base.opps[i] = dce80_opp_create(ctx, i);
+		if (pool->base.opps[i] == NULL) {
+			BREAK_TO_DEBUGGER();
+			dm_error("DC: failed to create output pixel processor!\n");
+			goto res_create_fail;
+		}
+	}
+
+	if (!resource_construct(num_virtual_links, dc, &pool->base,
+			&res_create_funcs))
+		goto res_create_fail;
+
+	/* Create hardware sequencer */
+	if (!dce80_hw_sequencer_construct(dc))
+		goto res_create_fail;
+
+	return true;
+
+res_create_fail:
+	destruct(pool);
+	return false;
+}
+
+struct resource_pool *dce80_create_resource_pool(
+	uint8_t num_virtual_links,
+	struct core_dc *dc)
+{
+	struct dce110_resource_pool *pool =
+		dm_alloc(sizeof(struct dce110_resource_pool));
+
+	if (!pool)
+		return NULL;
+
+	if (construct(num_virtual_links, dc, pool))
+		return &pool->base;
+
+	BREAK_TO_DEBUGGER();
+	return NULL;
+}
+
